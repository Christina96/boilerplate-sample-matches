
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.790924755887421%, Tokens: 10</h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-async_param_server.cpp</h3>
            <pre><code>1  #ifdef USE_MLSL
2  #include <cstdlib>
3  #include <climits>
4  #include <boost/make_shared.hpp>
5  #include <thread>
6  #include "caffe/caffe.hpp"
7  #include "caffe/multinode/async_param_server.hpp"
8  namespace caffe {
9    namespace mn {
10      using std::make_pair;
11      template <typename Dtype>
12      AsyncParamServer<Dtype>::AsyncParamServer(boost::shared_ptr<Solver<Dtype> > solver) :
13        recv_tasks_iter_(0), 
14        solver_(solver),
15        send_cnt_(0), update_cnt_(0) {
16        int mpi_rank = get_node_rank();
17        shared_ptr<Net<Dtype>> net = solver_->net();
18        const vector<Blob<Dtype> *> &net_params = net->learnable_params();
19        const std::vector<bool>& layer_need_backward{ net->layer_need_backward() };
20        for (int i = 0; i < get_num_groups(); i++) {
21          int root_rank = get_group_root_rank(i);
22          for (int j = 0; j < net->layers().size(); j++) {
23            shared_ptr<Layer<Dtype>> layer = net->layers()[j];
24            if (!layer_need_backward[j])
25                continue;
26            const MultinodeLayerParameter & mn_layer_param = layer->layer_param().multinode();
27            int model_parts = mn_layer_param.model_parts();
28            int mn_num_nodes = mn_layer_param.num_nodes();
29            GetCanonicalMnParam(mn_num_nodes, model_parts);
30            vector<int> layer_param_ids = net->get_layer_learnable_param_ids(j);
31            for (int k = 0; k < layer_param_ids.size(); k++) {
32              int param_id = layer_param_ids[k];
33              if (!layer->ParamNeedReduce(k)) continue;
34              if (param_to_server_rank(j, param_id) != mpi_rank) continue;
35              Blob<Dtype> *blob = net_params[param_id];
36              Dtype* buf = (Dtype*)std::malloc(sizeof(Dtype) * blob->count());
37              recv_buf_[make_pair(root_rank, param_id)] = make_pair(buf, blob->count());
38              for (int part_id = 0; part_id < model_parts; part_id++) {
39                int part_root_rank = get_group_root_rank(i, part_id, model_parts);
40                int64_t part_offset = part_id * blob->count() / model_parts;
41                TaskRequest recv_task(part_root_rank, j, param_id, part_id, model_parts);
42                recv_tasks_.push_back(recv_task);
43                rank_layer_blob_to_vec_pos[make_pair(part_root_rank, param_id)] =
44                  recv_tasks_.size() - 1;
45                MPI_Irecv(buf + part_offset, blob->count() / model_parts,
46                          DtypeToMPIDtype<Dtype>(), part_root_rank,
47                          recv_task.GetTag(), MPI_COMM_WORLD,
48                          &(recv_tasks_[recv_tasks_.size() - 1].mpi_request_));
49                async_iter_[make_pair(param_id, part_id)] = solver_->iter();
50              }
51              buf = (Dtype*)std::malloc(sizeof(Dtype) * blob->count());
52              send_buf_[make_pair(root_rank, param_id)] = make_pair(buf, blob->count());
53            }
54          }
55        }
56        total_update_ = total_send_ = recv_tasks_.size() * solver_->param().max_iter();
57      }
58      template <typename Dtype>
59      AsyncParamServer<Dtype>::~AsyncParamServer() {
60        shared_ptr<Net<Dtype>> net = solver_->net();
61        for (int i = 0; i < get_num_groups(); i++) {
62          int root_rank = get_group_root_rank(i);
63          for (int j = 0; j < net->layers().size(); j++) {
64            vector<int> layer_param_ids = net->get_layer_learnable_param_ids(j);
65            for (int k = 0; k < layer_param_ids.size(); k++) {
66              pair<int,int> key = make_pair(root_rank, layer_param_ids[k]);
67              if (send_buf_.find(key) != send_buf_.end()) {
68                std::free(send_buf_[key].first);
69              }
70              if (recv_buf_.find(key) != recv_buf_.end()) {
71                std::free(recv_buf_[key].first);
72              }
73            }
74          }
75        }
76      }
77      template <typename Dtype>
78      void AsyncParamServer<Dtype>::ProcessUpdateTask() {
79        const vector<Blob<Dtype> *> &net_params = solver_->net()->learnable_params();
80        std::deque<TaskRequest> to_update;
81        update_queue_mutex_.lock();
82        to_update.swap(update_tasks_);
83        update_queue_mutex_.unlock();
84        while (!to_update.empty() ) {
85          TaskRequest task = to_update.front();
86          to_update.pop_front();
87          int root_rank = world_rank_to_root_rank(task.part_root_rank_);
88          Blob<Dtype>* blob = net_params[task.param_id_];
89          Dtype* solver_diff = blob->mutable_cpu_diff();
90          Dtype* mpi_buf = 
91            recv_buf_[make_pair(root_rank, task.param_id_)].first;
92          int64_t count = 
93            recv_buf_[make_pair(root_rank, task.param_id_)].second;
94          CHECK(count == blob->count() );
95          int64_t part_offset = task.part_id_ * count / task.num_parts_;
96          caffe_copy(count / task.num_parts_,
97                     mpi_buf + part_offset, solver_diff + part_offset);
98          int blob_wise_iter = async_iter_[make_pair(task.param_id_, task.part_id_) ];
99          solver_->set_iter(blob_wise_iter);
100          solver_->ApplyUpdate(task.param_id_);
101          DLOG(INFO) << "PS (iter " << blob_wise_iter << "): param id=" << task.param_id_ << " weight=" << net_params[task.param_id_]->sumsq_diff();
102          DLOG(INFO) << "PS (iter " << blob_wise_iter << "): param id=" << task.param_id_ << " data=" << net_params[task.param_id_]->sumsq_data();
103          solver_->net()->ClearParamDiffs(task.param_id_);
104          async_iter_[ make_pair(task.param_id_, task.part_id_) ] += 1;
105          update_cnt_ += 1;
106          mpi_buf = send_buf_[make_pair(root_rank, task.param_id_)].first;
107          caffe_copy(count / task.num_parts_,
108                     blob->cpu_data() + part_offset, mpi_buf + part_offset);
109          send_queue_mutex_.lock();
110          send_tasks_.push_back(task);
111          send_queue_mutex_.unlock();
112        }
113      }
114      template <typename Dtype>
115      void AsyncParamServer<Dtype>::ProcessSendTask() {
116        std::deque<TaskRequest> to_send;
117        send_queue_mutex_.lock();
118        to_send.swap(send_tasks_);
119        send_queue_mutex_.unlock();
120        std::vector<MPI_Request> send_request;
121        while (!to_send.empty() ) {
<span onclick='openModal()' class='match'>122          TaskRequest task = to_send.front();
123          to_send.pop_front();
124          int root_rank = world_rank_to_root_rank(task.part_root_rank_);
125          int param_id = task.param_id_;
126          int part_id = task.part_id_;
127          int tag = task.GetTag();
128          Dtype* recv_ptr = recv_buf_[make_pair(root_rank, param_id)].first;
</span>129          int count = recv_buf_[make_pair(root_rank, param_id)].second;
130          int64_t part_offset = part_id * count / task.num_parts_;
131          int vec_pos = rank_layer_blob_to_vec_pos[make_pair(task.part_root_rank_, param_id)];
132          MPI_Irecv(recv_ptr + part_offset, count / task.num_parts_, DtypeToMPIDtype<Dtype>(),
133                    task.part_root_rank_, tag, MPI_COMM_WORLD, &(recv_tasks_[vec_pos].mpi_request_) );
134  #ifdef DEBUG_ORDER_BCAST
135          DEBUG_INFO("PS send message for layer ") << layer_id << " to rank " << root_rank << " for tag " << tag << std::endl;
136  #endif
137          std::pair<Dtype*, int64_t> buf = send_buf_[make_pair(root_rank, param_id)];
138          Dtype* send_ptr = buf.first;
139          send_request.push_back(MPI_Request() );
140          MPI_Isend(send_ptr + part_offset, count / task.num_parts_, DtypeToMPIDtype<Dtype>(),
141                    task.part_root_rank_, tag, MPI_COMM_WORLD, &(send_request.back() ) );
142          send_cnt_ += 1;
143        }
144        if (send_request.size() != 0) {
145          MPI_Waitall(send_request.size(), &send_request[0], MPI_STATUSES_IGNORE);
146        }
147      }
148      template <typename Dtype>
149      void AsyncParamServer<Dtype>::ProcessRecvTask() {
150        int flag = 0;
151        for (int i = 0; i < recv_tasks_.size(); i++) {
152          if (recv_tasks_[recv_tasks_iter_].mpi_request_ != MPI_REQUEST_NULL) {
153            MPI_Test(&(recv_tasks_[recv_tasks_iter_].mpi_request_), &flag, MPI_STATUS_IGNORE);
154            if (flag) {
155              update_queue_mutex_.lock();
156              update_tasks_.push_back(recv_tasks_[recv_tasks_iter_] );
157              update_queue_mutex_.unlock();
158            }
159          }
160          recv_tasks_iter_ = (recv_tasks_iter_ + 1) % recv_tasks_.size();
161          if (flag) return;
162        }
163      }
164      template <typename Dtype>
165      void AsyncParamServer<Dtype>::ComputeLoop() {
166        do {
167          ProcessUpdateTask();
168        } while(update_cnt_ < total_update_);
169      }
170      template <typename Dtype>
171      void AsyncParamServer<Dtype>::CommLoop() {
172        do {
173          ProcessSendTask();
174          ProcessRecvTask();
175        } while(send_cnt_ < total_send_);
176      }
177      template <typename Dtype>
178      void AsyncParamServer<Dtype>::Run() {
179        std::thread compute_thread(&AsyncParamServer<Dtype>::ComputeLoop, this);
180        CommLoop();
181        compute_thread.join();
182      }
183      INSTANTIATE_CLASS(AsyncParamServer);
184    } 
185  } 
186  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-tablefind.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include <algorithm>
5  #include <cmath>
6  #include <utility>
7  #include "tablefind.h"
8  #include <allheaders.h>
9  #include "colpartitionset.h"
10  #include "tablerecog.h"
11  namespace tesseract {
12  const int kMaxVerticalSpacing = 500;
13  const int kMaxBlobWidth = 500;
14  const double kSplitPartitionSize = 2.0;
15  const double kAllowTextHeight = 0.5;
16  const double kAllowTextWidth = 0.6;
17  const double kAllowTextArea = 0.8;
18  const double kAllowBlobHeight = 0.3;
19  const double kAllowBlobWidth = 0.4;
20  const double kAllowBlobArea = 0.05;
21  const int kMinBoxesInTextPartition = 10;
22  const int kMaxBoxesInDataPartition = 20;
23  const double kMaxGapInTextPartition = 4.0;
24  const double kMinMaxGapInTextPartition = 0.5;
25  const double kMaxBlobOverlapFactor = 4.0;
26  const double kMaxTableCellXheight = 2.0;
27  const int kMaxColumnHeaderDistance = 4;
28  const double kTableColumnThreshold = 3.0;
29  const double kMinOverlapWithTable = 0.6;
30  const int kSideSpaceMargin = 10;
31  const double kSmallTableProjectionThreshold = 0.35;
32  const double kLargeTableProjectionThreshold = 0.45;
33  const int kLargeTableRowCount = 6;
34  const int kMinRowsInTable = 3;
35  const int kAdjacentLeaderSearchPadding = 2;
36  const double kParagraphEndingPreviousLineRatio = 1.3;
37  const double kMaxParagraphEndingLeftSpaceMultiple = 3.0;
38  const double kMinParagraphEndingTextToWhitespaceRatio = 3.0;
39  const double kMaxXProjectionGapFactor = 2.0;
40  const double kStrokeWidthFractionalTolerance = 0.25;
41  const double kStrokeWidthConstantTolerance = 2.0;
42  #ifndef GRAPHICS_DISABLED
43  static BOOL_VAR(textord_show_tables, false, "Show table regions (ScrollView)");
44  static BOOL_VAR(textord_tablefind_show_mark, false,
45                  "Debug table marking steps in detail (ScrollView)");
46  static BOOL_VAR(textord_tablefind_show_stats, false,
47                  "Show page stats used in table finding (ScrollView)");
48  #endif
49  static BOOL_VAR(textord_tablefind_recognize_tables, false,
50                  "Enables the table recognizer for table layout and filtering.");
51  template <typename T>
52  void DeleteObject(T *object) {
53    delete object;
54  }
55  TableFinder::TableFinder()
56      : resolution_(0),
57        global_median_xheight_(0),
58        global_median_blob_width_(0),
59        global_median_ledding_(0),
60        left_to_right_language_(true) {}
61  TableFinder::~TableFinder() {
62    clean_part_grid_.ClearGridData(&DeleteObject<ColPartition>);
63    leader_and_ruling_grid_.ClearGridData(&DeleteObject<ColPartition>);
64    fragmented_text_grid_.ClearGridData(&DeleteObject<ColPartition>);
65    col_seg_grid_.ClearGridData(&DeleteObject<ColSegment>);
66    table_grid_.ClearGridData(&DeleteObject<ColSegment>);
67  }
68  void TableFinder::set_left_to_right_language(bool order) {
69    left_to_right_language_ = order;
70  }
71  void TableFinder::Init(int grid_size, const ICOORD &bottom_left,
72                         const ICOORD &top_right) {
73    clean_part_grid_.Init(grid_size, bottom_left, top_right);
74    leader_and_ruling_grid_.Init(grid_size, bottom_left, top_right);
75    fragmented_text_grid_.Init(grid_size, bottom_left, top_right);
76    col_seg_grid_.Init(grid_size, bottom_left, top_right);
77    table_grid_.Init(grid_size, bottom_left, top_right);
78  }
79  void TableFinder::InsertCleanPartitions(ColPartitionGrid *grid,
80                                          TO_BLOCK *block) {
81    SetGlobalSpacings(grid);
82    ColPartitionGridSearch gsearch(grid);
83    gsearch.SetUniqueMode(true);
84    gsearch.StartFullSearch();
85    ColPartition *part = nullptr;
86    while ((part = gsearch.NextFullSearch()) != nullptr) {
87      if (part->blob_type() == BRT_NOISE || part->bounding_box().area() <= 0) {
88        continue;
89      }
90      ColPartition *clean_part = part->ShallowCopy();
91      ColPartition *leader_part = nullptr;
92      if (part->IsLineType()) {
93        InsertRulingPartition(clean_part);
94        continue;
95      }
96      if (!part->IsTextType()) {
97        InsertImagePartition(clean_part);
98        continue;
99      }
100      BLOBNBOX_CLIST *part_boxes = part->boxes();
101      BLOBNBOX_C_IT pit(part_boxes);
102      for (pit.mark_cycle_pt(); !pit.cycled_list(); pit.forward()) {
103        BLOBNBOX *pblob = pit.data();
104        if (!AllowBlob(*pblob)) {
105          continue;
106        }
107        if (pblob->flow() == BTFT_LEADER) {
108          if (leader_part == nullptr) {
109            leader_part = part->ShallowCopy();
110            leader_part->set_flow(BTFT_LEADER);
111          }
112          leader_part->AddBox(pblob);
113        } else if (pblob->region_type() != BRT_NOISE) {
114          clean_part->AddBox(pblob);
115        }
116      }
117      clean_part->ComputeLimits();
118      ColPartition *fragmented = clean_part->CopyButDontOwnBlobs();
119      InsertTextPartition(clean_part);
120      SplitAndInsertFragmentedTextPartition(fragmented);
121      if (leader_part != nullptr) {
122        leader_part->ComputeLimits();
123        InsertLeaderPartition(leader_part);
124      }
125    }
126    clean_part_grid_.FindPartitionPartners();
127    clean_part_grid_.RefinePartitionPartners(false);
128  }
129  void TableFinder::LocateTables(ColPartitionGrid *grid,
130                                 ColPartitionSet **all_columns,
131                                 WidthCallback width_cb, const FCOORD &reskew) {
132    InitializePartitions(all_columns);
133  #ifndef GRAPHICS_DISABLED
134    if (textord_show_tables) {
135      ScrollView *table_win = MakeWindow(0, 300, "Column Partitions & Neighbors");
136      DisplayColPartitions(table_win, &clean_part_grid_, ScrollView::BLUE);
137      DisplayColPartitions(table_win, &leader_and_ruling_grid_,
138                           ScrollView::AQUAMARINE);
139      DisplayColPartitionConnections(table_win, &clean_part_grid_,
140                                     ScrollView::ORANGE);
141      table_win = MakeWindow(100, 300, "Fragmented Text");
142      DisplayColPartitions(table_win, &fragmented_text_grid_, ScrollView::BLUE);
143    }
144  #endif 
145    MarkTablePartitions();
146    ColSegment_LIST column_blocks;
147    GetColumnBlocks(all_columns, &column_blocks);
148    SetColumnsType(&column_blocks);
149    MoveColSegmentsToGrid(&column_blocks, &col_seg_grid_);
150    GridMergeColumnBlocks();
151    ColSegment_LIST table_columns;
152    GetTableColumns(&table_columns);
153    ColSegment_LIST table_regions;
154    GetTableRegions(&table_columns, &table_regions);
155  #ifndef GRAPHICS_DISABLED
156    if (textord_tablefind_show_mark) {
157      ScrollView *table_win = MakeWindow(1200, 300, "Table Columns and Regions");
158      DisplayColSegments(table_win, &table_columns, ScrollView::DARK_TURQUOISE);
159      DisplayColSegments(table_win, &table_regions, ScrollView::YELLOW);
160    }
161  #endif 
162    MoveColSegmentsToGrid(&table_regions, &table_grid_);
163    GridMergeTableRegions();
164    AdjustTableBoundaries();
165    GridMergeTableRegions();
166    if (textord_tablefind_recognize_tables) {
167      DeleteSingleColumnTables();
168  #ifndef GRAPHICS_DISABLED
169      if (textord_show_tables) {
170        ScrollView *table_win = MakeWindow(1200, 300, "Detected Table Locations");
171        DisplayColPartitions(table_win, &clean_part_grid_, ScrollView::BLUE);
172        DisplayColSegments(table_win, &table_columns, ScrollView::KHAKI);
173        table_grid_.DisplayBoxes(table_win);
174      }
175  #endif 
176      RecognizeTables();
177      GridMergeTableRegions();
178      RecognizeTables();
179  #ifndef GRAPHICS_DISABLED
180      if (textord_show_tables) {
181        ScrollView *table_win = MakeWindow(1400, 600, "Recognized Tables");
182        DisplayColPartitions(table_win, &clean_part_grid_, ScrollView::BLUE,
183                             ScrollView::BLUE);
184        table_grid_.DisplayBoxes(table_win);
185      }
186  #endif 
187    } else {
188      DeleteSingleColumnTables();
189  #ifndef GRAPHICS_DISABLED
190      if (textord_show_tables) {
191        ScrollView *table_win = MakeWindow(1500, 300, "Detected Tables");
192        DisplayColPartitions(table_win, &clean_part_grid_, ScrollView::BLUE,
193                             ScrollView::BLUE);
194        table_grid_.DisplayBoxes(table_win);
195      }
196  #endif 
197    }
198    MakeTableBlocks(grid, all_columns, width_cb);
199  }
200  int TableFinder::gridsize() const {
201    return clean_part_grid_.gridsize();
202  }
203  int TableFinder::gridwidth() const {
204    return clean_part_grid_.gridwidth();
205  }
206  int TableFinder::gridheight() const {
207    return clean_part_grid_.gridheight();
208  }
209  const ICOORD &TableFinder::bleft() const {
210    return clean_part_grid_.bleft();
211  }
212  const ICOORD &TableFinder::tright() const {
213    return clean_part_grid_.tright();
214  }
215  void TableFinder::InsertTextPartition(ColPartition *part) {
216    ASSERT_HOST(part != nullptr);
217    if (AllowTextPartition(*part)) {
218      clean_part_grid_.InsertBBox(true, true, part);
219    } else {
220      delete part;
221    }
222  }
223  void TableFinder::InsertFragmentedTextPartition(ColPartition *part) {
224    ASSERT_HOST(part != nullptr);
225    if (AllowTextPartition(*part)) {
226      fragmented_text_grid_.InsertBBox(true, true, part);
227    } else {
228      delete part;
229    }
230  }
231  void TableFinder::InsertLeaderPartition(ColPartition *part) {
232    ASSERT_HOST(part != nullptr);
233    if (!part->IsEmpty() && part->bounding_box().area() > 0) {
234      leader_and_ruling_grid_.InsertBBox(true, true, part);
235    } else {
236      delete part;
237    }
238  }
239  void TableFinder::InsertRulingPartition(ColPartition *part) {
240    leader_and_ruling_grid_.InsertBBox(true, true, part);
241  }
242  void TableFinder::InsertImagePartition(ColPartition *part) {
243    clean_part_grid_.InsertBBox(true, true, part);
244  }
245  void TableFinder::SplitAndInsertFragmentedTextPartition(ColPartition *part) {
246    ASSERT_HOST(part != nullptr);
247    if (part->boxes()->empty()) {
248      delete part;
249      return;
250    }
251    ASSERT_HOST(part->median_width() > 0);
252    const double kThreshold = part->median_width() * kSplitPartitionSize;
253    ColPartition *right_part = part;
254    bool found_split = true;
255    while (found_split) {
256      found_split = false;
257      BLOBNBOX_C_IT box_it(right_part->boxes());
258      int previous_right = INT32_MIN;
259      for (box_it.mark_cycle_pt(); !box_it.cycled_list(); box_it.forward()) {
260        const TBOX &box = box_it.data()->bounding_box();
261        if (previous_right != INT32_MIN &&
262            box.left() - previous_right > kThreshold) {
263          int mid_x = (box.left() + previous_right) / 2;
264          ColPartition *left_part = right_part;
265          right_part = left_part->SplitAt(mid_x);
266          InsertFragmentedTextPartition(left_part);
267          found_split = true;
268          break;
269        }
270        previous_right = std::max(previous_right, static_cast<int>(box.right()));
271      }
272    }
273    InsertFragmentedTextPartition(right_part);
274  }
275  bool TableFinder::AllowTextPartition(const ColPartition &part) const {
276    const double kHeightRequired = global_median_xheight_ * kAllowTextHeight;
277    const double kWidthRequired = global_median_blob_width_ * kAllowTextWidth;
278    const int median_area = global_median_xheight_ * global_median_blob_width_;
279    const double kAreaPerBlobRequired = median_area * kAllowTextArea;
280    return part.median_height() > kHeightRequired &&
281           part.median_width() > kWidthRequired &&
282           part.bounding_box().area() > kAreaPerBlobRequired * part.boxes_count();
283  }
284  bool TableFinder::AllowBlob(const BLOBNBOX &blob) const {
285    const TBOX &box = blob.bounding_box();
286    const double kHeightRequired = global_median_xheight_ * kAllowBlobHeight;
287    const double kWidthRequired = global_median_blob_width_ * kAllowBlobWidth;
288    const int median_area = global_median_xheight_ * global_median_blob_width_;
289    const double kAreaRequired = median_area * kAllowBlobArea;
290    return box.height() > kHeightRequired && box.width() > kWidthRequired &&
291           box.area() > kAreaRequired;
292  }
293  #ifndef GRAPHICS_DISABLED
294  ScrollView *TableFinder::MakeWindow(int x, int y, const char *window_name) {
295    return clean_part_grid_.MakeWindow(x, y, window_name);
296  }
297  #endif
298  void TableFinder::GetColumnBlocks(ColPartitionSet **all_columns,
299                                    ColSegment_LIST *column_blocks) {
300    for (int i = 0; i < gridheight(); ++i) {
301      ColPartitionSet *columns = all_columns[i];
302      if (columns != nullptr) {
303        ColSegment_LIST new_blocks;
304        columns->GetColumnBoxes(i * gridsize(), (i + 1) * gridsize(),
305                                &new_blocks);
306        GroupColumnBlocks(&new_blocks, column_blocks);
307      }
308    }
309  }
310  void TableFinder::GroupColumnBlocks(ColSegment_LIST *new_blocks,
311                                      ColSegment_LIST *column_blocks) {
312    ColSegment_IT src_it(new_blocks);
313    ColSegment_IT dest_it(column_blocks);
314    for (src_it.mark_cycle_pt(); !src_it.cycled_list(); src_it.forward()) {
315      ColSegment *src_seg = src_it.data();
316      const TBOX &src_box = src_seg->bounding_box();
317      bool match_found = false;
318      for (dest_it.mark_cycle_pt(); !dest_it.cycled_list(); dest_it.forward()) {
319        ColSegment *dest_seg = dest_it.data();
320        TBOX dest_box = dest_seg->bounding_box();
321        if (ConsecutiveBoxes(src_box, dest_box)) {
322          dest_seg->InsertBox(src_box);
323          match_found = true;
324          delete src_it.extract();
325          break;
326        }
327      }
328      if (!match_found) {
329        dest_it.add_after_then_move(src_it.extract());
330      }
331    }
332  }
333  bool TableFinder::ConsecutiveBoxes(const TBOX &b1, const TBOX &b2) {
334    int x_margin = 20;
335    int y_margin = 5;
336    return (abs(b1.left() - b2.left()) < x_margin) &&
337           (abs(b1.right() - b2.right()) < x_margin) &&
338           (abs(b1.top() - b2.bottom()) < y_margin ||
339            abs(b2.top() - b1.bottom()) < y_margin);
340  }
341  void TableFinder::InitializePartitions(ColPartitionSet **all_columns) {
342    FindNeighbors();
343    SetPartitionSpacings(&clean_part_grid_, all_columns);
344    SetGlobalSpacings(&clean_part_grid_);
345  }
346  void TableFinder::SetPartitionSpacings(ColPartitionGrid *grid,
347                                         ColPartitionSet **all_columns) {
348    ColPartitionGridSearch gsearch(grid);
349    gsearch.StartFullSearch();
350    ColPartition *part = nullptr;
351    while ((part = gsearch.NextFullSearch()) != nullptr) {
352      ColPartitionSet *columns = all_columns[gsearch.GridY()];
353      TBOX box = part->bounding_box();
354      int y = part->MidY();
355      ColPartition *left_column = columns->ColumnContaining(box.left(), y);
356      ColPartition *right_column = columns->ColumnContaining(box.right(), y);
357      if (left_column) {
358        int left_space = std::max(0, box.left() - left_column->LeftAtY(y));
359        part->set_space_to_left(left_space);
360      }
361      if (right_column) {
362        int right_space = std::max(0, right_column->RightAtY(y) - box.right());
363        part->set_space_to_right(right_space);
364      }
365      ColPartitionGridSearch hsearch(grid);
366      hsearch.StartSideSearch(box.left(), box.bottom(), box.top());
367      ColPartition *neighbor = nullptr;
368      while ((neighbor = hsearch.NextSideSearch(true)) != nullptr) {
369        if (neighbor->type() == PT_PULLOUT_IMAGE ||
370            neighbor->type() == PT_FLOWING_IMAGE ||
371            neighbor->type() == PT_HEADING_IMAGE) {
372          int right = neighbor->bounding_box().right();
373          if (right < box.left()) {
374            int space = std::min(box.left() - right, part->space_to_left());
375            part->set_space_to_left(space);
376          }
377        }
378      }
379      hsearch.StartSideSearch(box.left(), box.bottom(), box.top());
380      neighbor = nullptr;
381      while ((neighbor = hsearch.NextSideSearch(false)) != nullptr) {
382        if (neighbor->type() == PT_PULLOUT_IMAGE ||
383            neighbor->type() == PT_FLOWING_IMAGE ||
384            neighbor->type() == PT_HEADING_IMAGE) {
385          int left = neighbor->bounding_box().left();
386          if (left > box.right()) {
387            int space = std::min(left - box.right(), part->space_to_right());
388            part->set_space_to_right(space);
389          }
390        }
391      }
392      ColPartition *upper_part = part->SingletonPartner(true);
393      if (upper_part) {
394        int space =
395            std::max(0, static_cast<int>(upper_part->bounding_box().bottom() -
396                                         part->bounding_box().bottom()));
397        part->set_space_above(space);
398      } else {
399        part->set_space_above(INT32_MAX);
400      }
401      ColPartition *lower_part = part->SingletonPartner(false);
402      if (lower_part) {
403        int space =
404            std::max(0, static_cast<int>(part->bounding_box().bottom() -
405                                         lower_part->bounding_box().bottom()));
406        part->set_space_below(space);
407      } else {
408        part->set_space_below(INT32_MAX);
409      }
410    }
411  }
412  void TableFinder::SetVerticalSpacing(ColPartition *part) {
413    TBOX box = part->bounding_box();
414    int top_range =
415        std::min(box.top() + kMaxVerticalSpacing, static_cast<int>(tright().y()));
416    int bottom_range = std::max(box.bottom() - kMaxVerticalSpacing,
417                                static_cast<int>(bleft().y()));
418    box.set_top(top_range);
419    box.set_bottom(bottom_range);
420    TBOX part_box = part->bounding_box();
421    GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> rectsearch(
422        &clean_part_grid_);
423    rectsearch.StartRectSearch(box);
424    ColPartition *neighbor;
425    int min_space_above = kMaxVerticalSpacing;
426    int min_space_below = kMaxVerticalSpacing;
427    ColPartition *above_neighbor = nullptr;
428    ColPartition *below_neighbor = nullptr;
429    while ((neighbor = rectsearch.NextRectSearch()) != nullptr) {
430      if (neighbor == part) {
431        continue;
432      }
433      TBOX neighbor_box = neighbor->bounding_box();
434      if (neighbor_box.major_x_overlap(part_box)) {
435        int gap = abs(part->median_bottom() - neighbor->median_bottom());
436        if (neighbor_box.top() < part_box.bottom() && gap < min_space_below) {
437          min_space_below = gap;
438          below_neighbor = neighbor;
439        } 
440        else if (part_box.top() < neighbor_box.bottom() &&
441                 gap < min_space_above) {
442          min_space_above = gap;
443          above_neighbor = neighbor;
444        }
445      }
446    }
447    part->set_space_above(min_space_above);
448    part->set_space_below(min_space_below);
449    part->set_nearest_neighbor_above(above_neighbor);
450    part->set_nearest_neighbor_below(below_neighbor);
451  }
452  void TableFinder::SetGlobalSpacings(ColPartitionGrid *grid) {
453    STATS xheight_stats(0, kMaxVerticalSpacing);
454    STATS width_stats(0, kMaxBlobWidth);
455    STATS ledding_stats(0, kMaxVerticalSpacing);
456    ColPartitionGridSearch gsearch(grid);
457    gsearch.SetUniqueMode(true);
458    gsearch.StartFullSearch();
459    ColPartition *part = nullptr;
460    while ((part = gsearch.NextFullSearch()) != nullptr) {
461      if (part->IsTextType()) {
462        BLOBNBOX_C_IT it(part->boxes());
463        for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
464          xheight_stats.add(it.data()->bounding_box().height(), 1);
465          width_stats.add(it.data()->bounding_box().width(), 1);
466        }
467        ledding_stats.add(part->space_above(), 1);
468        ledding_stats.add(part->space_below(), 1);
469      }
470    }
471    set_global_median_xheight(static_cast<int>(xheight_stats.median() + 0.5));
472    set_global_median_blob_width(static_cast<int>(width_stats.median() + 0.5));
473    set_global_median_ledding(static_cast<int>(ledding_stats.median() + 0.5));
474  #ifndef GRAPHICS_DISABLED
475    if (textord_tablefind_show_stats) {
476      const char *kWindowName = "X-height (R), X-width (G), and ledding (B)";
477      ScrollView *stats_win = MakeWindow(500, 10, kWindowName);
478      xheight_stats.plot(stats_win, 10, 200, 2, 15, ScrollView::RED);
479      width_stats.plot(stats_win, 10, 200, 2, 15, ScrollView::GREEN);
480      ledding_stats.plot(stats_win, 10, 200, 2, 15, ScrollView::BLUE);
481    }
482  #endif 
483  }
484  void TableFinder::set_global_median_xheight(int xheight) {
485    global_median_xheight_ = xheight;
486  }
487  void TableFinder::set_global_median_blob_width(int width) {
488    global_median_blob_width_ = width;
489  }
490  void TableFinder::set_global_median_ledding(int ledding) {
491    global_median_ledding_ = ledding;
492  }
493  void TableFinder::FindNeighbors() {
494    ColPartitionGridSearch gsearch(&clean_part_grid_);
495    gsearch.StartFullSearch();
496    ColPartition *part = nullptr;
497    while ((part = gsearch.NextFullSearch()) != nullptr) {
498      ColPartition *upper = part->SingletonPartner(true);
499      if (upper) {
500        part->set_nearest_neighbor_above(upper);
501      }
502      ColPartition *lower = part->SingletonPartner(false);
503      if (lower) {
504        part->set_nearest_neighbor_below(lower);
505      }
506    }
507  }
508  void TableFinder::MarkTablePartitions() {
509    MarkPartitionsUsingLocalInformation();
510  #ifndef GRAPHICS_DISABLED
511    if (textord_tablefind_show_mark) {
512      ScrollView *table_win = MakeWindow(300, 300, "Initial Table Partitions");
513      DisplayColPartitions(table_win, &clean_part_grid_, ScrollView::BLUE);
514      DisplayColPartitions(table_win, &leader_and_ruling_grid_,
515                           ScrollView::AQUAMARINE);
516    }
517  #endif
518    FilterFalseAlarms();
519  #ifndef GRAPHICS_DISABLED
520    if (textord_tablefind_show_mark) {
521      ScrollView *table_win = MakeWindow(600, 300, "Filtered Table Partitions");
522      DisplayColPartitions(table_win, &clean_part_grid_, ScrollView::BLUE);
523      DisplayColPartitions(table_win, &leader_and_ruling_grid_,
524                           ScrollView::AQUAMARINE);
525    }
526  #endif
527    SmoothTablePartitionRuns();
528  #ifndef GRAPHICS_DISABLED
529    if (textord_tablefind_show_mark) {
530      ScrollView *table_win = MakeWindow(900, 300, "Smoothed Table Partitions");
531      DisplayColPartitions(table_win, &clean_part_grid_, ScrollView::BLUE);
532      DisplayColPartitions(table_win, &leader_and_ruling_grid_,
533                           ScrollView::AQUAMARINE);
534    }
535  #endif
536    FilterFalseAlarms();
537  #ifndef GRAPHICS_DISABLED
538    if (textord_tablefind_show_mark || textord_show_tables) {
539      ScrollView *table_win = MakeWindow(900, 300, "Final Table Partitions");
540      DisplayColPartitions(table_win, &clean_part_grid_, ScrollView::BLUE);
541      DisplayColPartitions(table_win, &leader_and_ruling_grid_,
542                           ScrollView::AQUAMARINE);
543    }
544  #endif
545  }
546  void TableFinder::MarkPartitionsUsingLocalInformation() {
547    GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> gsearch(
548        &clean_part_grid_);
549    gsearch.StartFullSearch();
550    ColPartition *part = nullptr;
551    while ((part = gsearch.NextFullSearch()) != nullptr) {
552      if (!part->IsTextType()) { 
553        continue;
554      }
555      if (part->median_height() > kMaxTableCellXheight * global_median_xheight_) {
556        continue;
557      }
558      if (HasWideOrNoInterWordGap(part) || HasLeaderAdjacent(*part)) {
559        part->set_table_type();
560      }
561    }
562  }
563  bool TableFinder::HasWideOrNoInterWordGap(ColPartition *part) const {
564    ASSERT_HOST(part->IsTextType());
565    BLOBNBOX_CLIST *part_boxes = part->boxes();
566    BLOBNBOX_C_IT it(part_boxes);
567    if (part->bounding_box().width() <
568            kMinBoxesInTextPartition * part->median_height() &&
569        part_boxes->length() < kMinBoxesInTextPartition) {
570      return true;
571    }
572    int current_x0 = -1;
573    int current_x1 = -1;
574    int previous_x1 = -1;
575    int largest_partition_gap_found = -1;
576    const double max_gap = kMaxGapInTextPartition * part->median_height();
577    const double min_gap = kMinMaxGapInTextPartition * part->median_height();
578    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
579      BLOBNBOX *blob = it.data();
580      current_x0 = blob->bounding_box().left();
581      current_x1 = blob->bounding_box().right();
582      if (previous_x1 != -1) {
583        int gap = current_x0 - previous_x1;
584        if (gap < 0) {
585          if (-gap < part->median_height() * kMaxBlobOverlapFactor) {
586            previous_x1 = std::max(previous_x1, current_x1);
587            continue;
588          }
589          else {
590          }
591        }
592        if (gap > max_gap) {
593          return true;
594        }
595        if (gap > largest_partition_gap_found) {
596          largest_partition_gap_found = gap;
597        }
598      }
599      previous_x1 = current_x1;
600    }
601    if (part->bounding_box().width() >
602            kMaxBoxesInDataPartition * part->median_height() ||
603        part_boxes->length() > kMaxBoxesInDataPartition) {
604      return false;
605    }
606    if (largest_partition_gap_found == -1) {
607      return true;
608    }
609    return largest_partition_gap_found < min_gap;
610  }
611  bool TableFinder::HasLeaderAdjacent(const ColPartition &part) {
612    if (part.flow() == BTFT_LEADER) {
613      return true;
614    }
615    const TBOX &box = part.bounding_box();
616    const int search_size = kAdjacentLeaderSearchPadding * global_median_xheight_;
617    const int top = box.top() + search_size;
618    const int bottom = box.bottom() - search_size;
619    ColPartitionGridSearch hsearch(&leader_and_ruling_grid_);
620    for (int direction = 0; direction < 2; ++direction) {
621      bool right_to_left = (direction == 0);
622      int x = right_to_left ? box.right() : box.left();
623      hsearch.StartSideSearch(x, bottom, top);
624      ColPartition *leader = nullptr;
625      while ((leader = hsearch.NextSideSearch(right_to_left)) != nullptr) {
626        if (leader->flow() != BTFT_LEADER) {
627          continue;
628        }
629        ASSERT_HOST(&part != leader);
630        if (!part.IsInSameColumnAs(*leader)) {
631          break;
632        }
633        if (!leader->VSignificantCoreOverlap(part)) {
634          continue;
635        }
636        return true;
637      }
638    }
639    return false;
640  }
641  void TableFinder::FilterFalseAlarms() {
642    FilterParagraphEndings();
643    FilterHeaderAndFooter();
644  }
645  void TableFinder::FilterParagraphEndings() {
646    ColPartitionGridSearch gsearch(&clean_part_grid_);
647    gsearch.StartFullSearch();
648    ColPartition *part = nullptr;
649    while ((part = gsearch.NextFullSearch()) != nullptr) {
650      if (part->type() != PT_TABLE) {
651        continue; 
652      }
653      ColPartition *upper_part = part->nearest_neighbor_above();
654      if (!upper_part) {
655        continue;
656      }
657      if (upper_part->type() != PT_FLOWING_TEXT) {
658        continue;
659      }
660      if (upper_part->bounding_box().width() < 2 * part->bounding_box().width()) {
661        continue;
662      }
663      int mid = (part->bounding_box().left() + part->bounding_box().right()) / 2;
664      int upper_mid = (upper_part->bounding_box().left() +
665                       upper_part->bounding_box().right()) /
666                      2;
667      int current_spacing = 0; 
668      int upper_spacing = 0;   
669      if (left_to_right_language_) {
670        int left = std::min(part->bounding_box().left(),
671                            upper_part->bounding_box().left());
672        current_spacing = mid - left;
673        upper_spacing = upper_mid - left;
674      } else {
675        int right = std::max(part->bounding_box().right(),
676                             upper_part->bounding_box().right());
677        current_spacing = right - mid;
678        upper_spacing = right - upper_mid;
679      }
680      if (current_spacing * kParagraphEndingPreviousLineRatio > upper_spacing) {
681        continue;
682      }
683      if (!part->MatchingSizes(*upper_part) ||
684          !part->MatchingStrokeWidth(*upper_part, kStrokeWidthFractionalTolerance,
685                                     kStrokeWidthConstantTolerance)) {
686        continue;
687      }
688      if (part->space_to_left() >
689          kMaxParagraphEndingLeftSpaceMultiple * part->median_height()) {
690        continue;
691      }
692      if (upper_part->bounding_box().width() <
693          kMinParagraphEndingTextToWhitespaceRatio *
694              upper_part->space_to_right()) {
695        continue;
696      }
697      if (part->space_above() >= part->space_below() ||
698          part->space_above() > 2 * global_median_ledding_) {
699        continue;
700      }
701      part->clear_table_type();
702    }
703  }
704  void TableFinder::FilterHeaderAndFooter() {
705    ColPartition *header = nullptr;
706    ColPartition *footer = nullptr;
707    int max_top = INT32_MIN;
708    int min_bottom = INT32_MAX;
709    ColPartitionGridSearch gsearch(&clean_part_grid_);
710    gsearch.StartFullSearch();
711    ColPartition *part = nullptr;
712    while ((part = gsearch.NextFullSearch()) != nullptr) {
713      if (!part->IsTextType()) {
714        continue; 
715      }
716      int top = part->bounding_box().top();
717      int bottom = part->bounding_box().bottom();
718      if (top > max_top) {
719        max_top = top;
720        header = part;
721      }
722      if (bottom < min_bottom) {
723        min_bottom = bottom;
724        footer = part;
725      }
726    }
727    if (header) {
728      header->clear_table_type();
729    }
730    if (footer) {
731      footer->clear_table_type();
732    }
733  }
734  void TableFinder::SmoothTablePartitionRuns() {
735    ColPartitionGridSearch gsearch(&clean_part_grid_);
736    gsearch.StartFullSearch();
737    ColPartition *part = nullptr;
738    while ((part = gsearch.NextFullSearch()) != nullptr) {
739      if (part->type() >= PT_TABLE || part->type() == PT_UNKNOWN) {
740        continue; 
741      }
742      ColPartition *upper_part = part->nearest_neighbor_above();
743      ColPartition *lower_part = part->nearest_neighbor_below();
744      if (!upper_part || !lower_part) {
745        continue;
746      }
747      if (upper_part->type() == PT_TABLE && lower_part->type() == PT_TABLE) {
748        part->set_table_type();
749      }
750    }
751    gsearch.StartFullSearch();
752    part = nullptr;
753    while ((part = gsearch.NextFullSearch()) != nullptr) {
754      if (part->type() != PT_TABLE) {
755        continue; 
756      }
757      ColPartition *upper_part = part->nearest_neighbor_above();
758      ColPartition *lower_part = part->nearest_neighbor_below();
759      if ((upper_part && upper_part->type() != PT_TABLE) &&
760          (lower_part && lower_part->type() != PT_TABLE)) {
761        part->clear_table_type();
762      }
763    }
764  }
765  void TableFinder::SetColumnsType(ColSegment_LIST *column_blocks) {
766    ColSegment_IT it(column_blocks);
767    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
768      ColSegment *seg = it.data();
769      TBOX box = seg->bounding_box();
770      int num_table_cells = 0;
771      int num_text_cells = 0;
772      GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> rsearch(
773          &clean_part_grid_);
774      rsearch.SetUniqueMode(true);
775      rsearch.StartRectSearch(box);
776      ColPartition *part = nullptr;
777      while ((part = rsearch.NextRectSearch()) != nullptr) {
778        if (part->type() == PT_TABLE) {
779          num_table_cells++;
780        } else if (part->type() == PT_FLOWING_TEXT) {
781          num_text_cells++;
782        }
783      }
784      if (!num_table_cells && !num_text_cells) {
785        delete it.extract();
786      } else {
787        seg->set_num_table_cells(num_table_cells);
788        seg->set_num_text_cells(num_text_cells);
789        seg->set_type();
790      }
791    }
792  }
793  void TableFinder::MoveColSegmentsToGrid(ColSegment_LIST *segments,
794                                          ColSegmentGrid *col_seg_grid) {
795    ColSegment_IT it(segments);
796    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
797      ColSegment *seg = it.extract();
798      col_seg_grid->InsertBBox(true, true, seg);
799    }
800  }
801  void TableFinder::GridMergeColumnBlocks() {
802    int margin = gridsize();
803    GridSearch<ColSegment, ColSegment_CLIST, ColSegment_C_IT> gsearch(
804        &col_seg_grid_);
805    gsearch.StartFullSearch();
806    ColSegment *seg;
807    while ((seg = gsearch.NextFullSearch()) != nullptr) {
808      if (seg->type() != COL_TEXT) {
809        continue; 
810      }
811      bool neighbor_found = false;
812      bool modified = false; 
813      do {
814        TBOX box = seg->bounding_box();
815        int top_range =
816            std::min(box.top() + margin, static_cast<int>(tright().y()));
817        int bottom_range =
818            std::max(box.bottom() - margin, static_cast<int>(bleft().y()));
819        box.set_top(top_range);
820        box.set_bottom(bottom_range);
821        neighbor_found = false;
822        GridSearch<ColSegment, ColSegment_CLIST, ColSegment_C_IT> rectsearch(
823            &col_seg_grid_);
824        rectsearch.StartRectSearch(box);
825        ColSegment *neighbor = nullptr;
826        while ((neighbor = rectsearch.NextRectSearch()) != nullptr) {
827          if (neighbor == seg) {
828            continue;
829          }
830          const TBOX &neighbor_box = neighbor->bounding_box();
831          if (neighbor_box.overlap_fraction(box) >= 0.9) {
832            seg->InsertBox(neighbor_box);
833            modified = true;
834            rectsearch.RemoveBBox();
835            gsearch.RepositionIterator();
836            delete neighbor;
837            continue;
838          }
839          if (neighbor->type() != COL_TABLE) {
840            continue;
841          }
842          if (neighbor_box.major_x_overlap(box) && !box.contains(neighbor_box)) {
843            seg->InsertBox(neighbor_box);
844            neighbor_found = true;
845            modified = true;
846            rectsearch.RemoveBBox();
847            gsearch.RepositionIterator();
848            delete neighbor;
849          }
850        }
851      } while (neighbor_found);
852      if (modified) {
853        gsearch.RemoveBBox();
854        col_seg_grid_.InsertBBox(true, true, seg);
855        gsearch.RepositionIterator();
856      }
857    }
858  }
859  void TableFinder::GetTableColumns(ColSegment_LIST *table_columns) {
860    ColSegment_IT it(table_columns);
861    GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> gsearch(
862        &clean_part_grid_);
863    gsearch.StartFullSearch();
864    ColPartition *part;
865    while ((part = gsearch.NextFullSearch()) != nullptr) {
866      if (part->inside_table_column() || part->type() != PT_TABLE) {
867        continue; 
868      }
869      const TBOX &box = part->bounding_box();
870      auto *col = new ColSegment();
871      col->InsertBox(box);
872      part->set_inside_table_column(true);
873      GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> vsearch(
874          &clean_part_grid_);
875      vsearch.StartVerticalSearch(box.left(), box.right(), box.bottom());
876      ColPartition *neighbor = nullptr;
877      bool found_neighbours = false;
878      while ((neighbor = vsearch.NextVerticalSearch(true)) != nullptr) {
879        if (neighbor->inside_table_column()) {
880          continue;
881        }
882        if (neighbor->IsHorizontalLine()) {
883          continue;
884        }
885        if (neighbor->type() != PT_TABLE) {
886          break;
887        }
888        const TBOX &neighbor_box = neighbor->bounding_box();
889        col->InsertBox(neighbor_box);
890        neighbor->set_inside_table_column(true);
891        found_neighbours = true;
892      }
893      if (found_neighbours) {
894        it.add_after_then_move(col);
895      } else {
896        part->set_inside_table_column(false);
897        delete col;
898      }
899    }
900  }
901  void TableFinder::GetTableRegions(ColSegment_LIST *table_columns,
902                                    ColSegment_LIST *table_regions) {
903    ColSegment_IT cit(table_columns);
904    ColSegment_IT rit(table_regions);
905    GridSearch<ColSegment, ColSegment_CLIST, ColSegment_C_IT> gsearch(
906        &col_seg_grid_);
907    gsearch.StartFullSearch();
908    ColSegment *part;
909    int page_height = tright().y() - bleft().y();
910    ASSERT_HOST(page_height > 0);
911    bool *table_region = new bool[page_height];
912    while ((part = gsearch.NextFullSearch()) != nullptr) {
913      const TBOX &part_box = part->bounding_box();
914      for (int i = 0; i < page_height; i++) {
915        table_region[i] = false;
916      }
917      cit.move_to_first();
918      for (cit.mark_cycle_pt(); !cit.cycled_list(); cit.forward()) {
919        TBOX col_box = cit.data()->bounding_box();
920        TBOX intersection_box = col_box.intersection(part_box);
921        for (int i = intersection_box.bottom(); i < intersection_box.top(); i++) {
922          table_region[i - bleft().y()] = true;
923        }
924      }
925      TBOX current_table_box;
926      current_table_box.set_left(part_box.left());
927      current_table_box.set_right(part_box.right());
928      for (int i = 1; i < page_height; i++) {
929        if (!table_region[i - 1] && table_region[i]) {
930          current_table_box.set_bottom(i + bleft().y());
931        }
932        if (table_region[i - 1] && !table_region[i]) {
933          current_table_box.set_top(i + bleft().y());
934          if (!current_table_box.null_box()) {
935            auto *seg = new ColSegment();
936            seg->InsertBox(current_table_box);
937            rit.add_after_then_move(seg);
938          }
939        }
940      }
941    }
942    delete[] table_region;
943  }
944  void TableFinder::GridMergeTableRegions() {
945    GridSearch<ColSegment, ColSegment_CLIST, ColSegment_C_IT> gsearch(
946        &table_grid_);
947    gsearch.StartFullSearch();
948    ColSegment *seg = nullptr;
949    while ((seg = gsearch.NextFullSearch()) != nullptr) {
950      bool neighbor_found = false;
951      bool modified = false; 
952      do {
953        const TBOX &box = seg->bounding_box();
954        TBOX search_region(box);
955        search_region.set_left(bleft().x());
956        search_region.set_right(tright().x());
957        neighbor_found = false;
958        GridSearch<ColSegment, ColSegment_CLIST, ColSegment_C_IT> rectsearch(
959            &table_grid_);
960        rectsearch.StartRectSearch(search_region);
961        ColSegment *neighbor = nullptr;
962        while ((neighbor = rectsearch.NextRectSearch()) != nullptr) {
963          if (neighbor == seg) {
964            continue;
965          }
966          const TBOX &neighbor_box = neighbor->bounding_box();
967          if (neighbor_box.overlap_fraction(box) >= 0.9) {
968            seg->InsertBox(neighbor_box);
969            rectsearch.RemoveBBox();
970            gsearch.RepositionIterator();
971            delete neighbor;
972            modified = true;
973            continue;
974          }
975          if (BelongToOneTable(box, neighbor_box)) {
976            seg->InsertBox(neighbor_box);
977            neighbor_found = true;
978            modified = true;
979            rectsearch.RemoveBBox();
980            gsearch.RepositionIterator();
981            delete neighbor;
982          }
983        }
984      } while (neighbor_found);
985      if (modified) {
986        gsearch.RemoveBBox();
987        table_grid_.InsertBBox(true, true, seg);
988        gsearch.RepositionIterator();
989      }
990    }
991  }
992  bool TableFinder::BelongToOneTable(const TBOX &box1, const TBOX &box2) {
993    if (box1.overlap(box2)) {
994      return true;
995    }
996    TBOX bbox = box1.bounding_union(box2);
997    GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> rectsearch(
998        &clean_part_grid_);
999    rectsearch.StartRectSearch(bbox);
1000    ColPartition *part = nullptr;
1001    while ((part = rectsearch.NextRectSearch()) != nullptr) {
1002      const TBOX &part_box = part->bounding_box();
1003      if (part_box.overlap(box1) && part_box.overlap(box2) &&
1004          !part->IsImageType()) {
1005        return true;
1006      }
1007    }
1008    return false;
1009  }
1010  void TableFinder::AdjustTableBoundaries() {
1011    ColSegment_CLIST adjusted_tables;
1012    ColSegment_C_IT it(&adjusted_tables);
1013    ColSegmentGridSearch gsearch(&table_grid_);
1014    gsearch.StartFullSearch();
1015    ColSegment *table = nullptr;
1016    while ((table = gsearch.NextFullSearch()) != nullptr) {
1017      const TBOX &table_box = table->bounding_box();
1018      TBOX grown_box = table_box;
1019      GrowTableBox(table_box, &grown_box);
1020      if (!grown_box.null_box()) {
1021        auto *col = new ColSegment();
1022        col->InsertBox(grown_box);
1023        it.add_after_then_move(col);
1024      }
1025      gsearch.RemoveBBox();
1026      delete table;
1027    }
1028    table_grid_.Clear();
1029    it.move_to_first();
1030    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1031      ColSegment *seg = it.extract();
1032      table_grid_.InsertBBox(true, true, seg);
1033    }
1034  }
1035  void TableFinder::GrowTableBox(const TBOX &table_box, TBOX *result_box) {
1036    TBOX search_box = table_box;
1037    GrowTableToIncludePartials(table_box, search_box, result_box);
1038    GrowTableToIncludeLines(table_box, search_box, result_box);
1039    IncludeLeftOutColumnHeaders(result_box);
1040  }
1041  void TableFinder::GrowTableToIncludePartials(const TBOX &table_box,
1042                                               const TBOX &search_range,
1043                                               TBOX *result_box) {
1044    for (int i = 0; i < 2; ++i) {
1045      ColPartitionGrid *grid =
1046          (i == 0) ? &fragmented_text_grid_ : &leader_and_ruling_grid_;
1047      ColPartitionGridSearch rectsearch(grid);
1048      rectsearch.StartRectSearch(search_range);
1049      ColPartition *part = nullptr;
1050      while ((part = rectsearch.NextRectSearch()) != nullptr) {
1051        if (part->IsImageType()) {
1052          continue;
1053        }
1054        const TBOX &part_box = part->bounding_box();
1055        if (part_box.overlap_fraction(table_box) > kMinOverlapWithTable) {
1056          *result_box = result_box->bounding_union(part_box);
1057          continue;
1058        }
1059      }
1060    }
1061  }
1062  void TableFinder::GrowTableToIncludeLines(const TBOX &table_box,
1063                                            const TBOX &search_range,
1064                                            TBOX *result_box) {
1065    ColPartitionGridSearch rsearch(&leader_and_ruling_grid_);
1066    rsearch.SetUniqueMode(true);
1067    rsearch.StartRectSearch(search_range);
1068    ColPartition *part = nullptr;
1069    while ((part = rsearch.NextRectSearch()) != nullptr) {
1070      if (!part->IsLineType()) {
1071        continue;
1072      }
1073      const TBOX &part_box = part->bounding_box();
1074      if (result_box->contains(part_box)) {
1075        continue;
1076      }
1077      if (HLineBelongsToTable(*part, table_box)) {
1078        *result_box = result_box->bounding_union(part_box);
1079      }
1080    }
1081  }
1082  bool TableFinder::HLineBelongsToTable(const ColPartition &part,
1083                                        const TBOX &table_box) {
1084    if (!part.IsHorizontalLine()) {
1085      return false;
1086    }
1087    const TBOX &part_box = part.bounding_box();
1088    if (!part_box.major_x_overlap(table_box)) {
1089      return false;
1090    }
1091    const TBOX bbox = part_box.bounding_union(table_box);
1092    int num_extra_partitions = 0;
1093    int extra_space_to_right = 0;
1094    int extra_space_to_left = 0;
1095    for (int i = 0; i < 2; ++i) {
1096      ColPartitionGrid *grid =
1097          (i == 0) ? &clean_part_grid_ : &leader_and_ruling_grid_;
1098      ColPartitionGridSearch rectsearch(grid);
1099      rectsearch.SetUniqueMode(true);
1100      rectsearch.StartRectSearch(bbox);
1101      ColPartition *extra_part = nullptr;
1102      while ((extra_part = rectsearch.NextRectSearch()) != nullptr) {
1103        const TBOX &extra_part_box = extra_part->bounding_box();
1104        if (extra_part_box.overlap_fraction(table_box) > kMinOverlapWithTable) {
1105          continue;
1106        }
1107        if (extra_part->IsImageType()) {
1108          continue;
1109        }
1110        num_extra_partitions++;
1111        if (extra_part->type() == PT_TABLE || extra_part->IsLineType()) {
1112          extra_space_to_right++;
1113          extra_space_to_left++;
1114          continue;
1115        }
1116        int space_threshold = kSideSpaceMargin * part.median_height();
1117        if (extra_part->space_to_right() > space_threshold) {
1118          extra_space_to_right++;
1119        }
1120        if (extra_part->space_to_left() > space_threshold) {
1121          extra_space_to_left++;
1122        }
1123      }
1124    }
1125    return (extra_space_to_right > num_extra_partitions / 2) ||
1126           (extra_space_to_left > num_extra_partitions / 2);
1127  }
1128  void TableFinder::IncludeLeftOutColumnHeaders(TBOX *table_box) {
1129    ColPartitionGridSearch vsearch(&clean_part_grid_);
1130    vsearch.StartVerticalSearch(table_box->left(), table_box->right(),
1131                                table_box->top());
1132    ColPartition *neighbor = nullptr;
1133    ColPartition *previous_neighbor = nullptr;
1134    while ((neighbor = vsearch.NextVerticalSearch(false)) != nullptr) {
1135      const int max_distance =
1136          kMaxColumnHeaderDistance * neighbor->median_height();
1137      int table_top = table_box->top();
1138      const TBOX &box = neighbor->bounding_box();
1139      if (box.bottom() - table_top > max_distance) {
1140        break;
1141      }
1142      if (neighbor->type() == PT_TABLE || neighbor->IsLineType()) {
1143        table_box->set_top(box.top());
1144        previous_neighbor = nullptr;
1145        continue;
1146      }
1147      if (previous_neighbor == nullptr) {
1148        previous_neighbor = neighbor;
1149      } else {
1150        const TBOX &previous_box = previous_neighbor->bounding_box();
1151        if (!box.major_y_overlap(previous_box)) {
1152          break;
1153        }
1154      }
1155    }
1156  }
1157  void TableFinder::DeleteSingleColumnTables() {
1158    int page_width = tright().x() - bleft().x();
1159    ASSERT_HOST(page_width > 0);
1160    int *table_xprojection = new int[page_width];
1161    GridSearch<ColSegment, ColSegment_CLIST, ColSegment_C_IT> table_search(
1162        &table_grid_);
1163    table_search.StartFullSearch();
1164    ColSegment *table;
1165    while ((table = table_search.NextFullSearch()) != nullptr) {
1166      TBOX table_box = table->bounding_box();
1167      for (int i = 0; i < page_width; i++) {
1168        table_xprojection[i] = 0;
1169      }
1170      GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> rectsearch(
1171          &clean_part_grid_);
1172      rectsearch.SetUniqueMode(true);
1173      rectsearch.StartRectSearch(table_box);
1174      ColPartition *part;
1175      while ((part = rectsearch.NextRectSearch()) != nullptr) {
1176        if (!part->IsTextType()) {
1177          continue; 
1178        }
1179        if (part->flow() == BTFT_LEADER) {
1180          continue; 
1181        }
1182        TBOX part_box = part->bounding_box();
1183        if (part_box.overlap_fraction(table_box) < kMinOverlapWithTable) {
1184          continue;
1185        }
1186        BLOBNBOX_CLIST *part_boxes = part->boxes();
1187        BLOBNBOX_C_IT pit(part_boxes);
1188        int next_position_to_write = 0;
1189        for (pit.mark_cycle_pt(); !pit.cycled_list(); pit.forward()) {
1190          BLOBNBOX *pblob = pit.data();
1191          int xstart = pblob->bounding_box().left();
1192          int xend = pblob->bounding_box().right();
1193          xstart = std::max(xstart, next_position_to_write);
1194          for (int i = xstart; i < xend; i++) {
1195            table_xprojection[i - bleft().x()]++;
1196          }
1197          next_position_to_write = xend;
1198        }
1199      }
1200      if (!GapInXProjection(table_xprojection, page_width)) {
1201        table_search.RemoveBBox();
1202        delete table;
1203      }
1204    }
1205    delete[] table_xprojection;
1206  }
1207  bool TableFinder::GapInXProjection(int *xprojection, int length) {
1208    int peak_value = 0;
1209    for (int i = 0; i < length; i++) {
1210      if (xprojection[i] > peak_value) {
1211        peak_value = xprojection[i];
1212      }
1213    }
1214    if (peak_value < kMinRowsInTable) {
1215      return false;
1216    }
1217    double projection_threshold = kSmallTableProjectionThreshold * peak_value;
1218    if (peak_value >= kLargeTableRowCount) {
1219      projection_threshold = kLargeTableProjectionThreshold * peak_value;
1220    }
1221    for (int i = 0; i < length; i++) {
1222      xprojection[i] = (xprojection[i] >= projection_threshold) ? 1 : 0;
1223    }
1224    int largest_gap = 0;
1225    int run_start = -1;
1226    for (int i = 1; i < length; i++) {
1227      if (xprojection[i - 1] && !xprojection[i]) {
1228        run_start = i;
1229      }
1230      if (run_start != -1 && !xprojection[i - 1] && xprojection[i]) {
1231        int gap = i - run_start;
1232        if (gap > largest_gap) {
1233          largest_gap = gap;
1234        }
1235        run_start = -1;
1236      }
1237    }
1238    return largest_gap > kMaxXProjectionGapFactor * global_median_xheight_;
1239  }
1240  void TableFinder::RecognizeTables() {
1241  #ifndef GRAPHICS_DISABLED
1242    ScrollView *table_win = nullptr;
1243    if (textord_show_tables) {
1244      table_win = MakeWindow(0, 0, "Table Structure");
1245      DisplayColPartitions(table_win, &fragmented_text_grid_, ScrollView::BLUE,
1246                           ScrollView::LIGHT_BLUE);
1247    }
1248  #endif
1249    TableRecognizer recognizer;
1250    recognizer.Init();
1251    recognizer.set_line_grid(&leader_and_ruling_grid_);
1252    recognizer.set_text_grid(&fragmented_text_grid_);
1253    recognizer.set_max_text_height(global_median_xheight_ * 2.0);
1254    recognizer.set_min_height(1.5 * gridheight());
1255    ColSegment_CLIST good_tables;
1256    ColSegment_C_IT good_it(&good_tables);
1257    ColSegmentGridSearch gsearch(&table_grid_);
1258    gsearch.StartFullSearch();
1259    ColSegment *found_table = nullptr;
1260    while ((found_table = gsearch.NextFullSearch()) != nullptr) {
1261      gsearch.RemoveBBox();
1262      const TBOX &found_box = found_table->bounding_box();
1263      StructuredTable *table_structure = recognizer.RecognizeTable(found_box);
1264      if (table_structure != nullptr) {
1265  #ifndef GRAPHICS_DISABLED
1266        if (textord_show_tables) {
1267          table_structure->Display(table_win, ScrollView::LIME_GREEN);
1268        }
1269  #endif
1270        found_table->set_bounding_box(table_structure->bounding_box());
1271        delete table_structure;
1272        good_it.add_after_then_move(found_table);
1273      } else {
1274        delete found_table;
1275      }
1276    }
1277    for (good_it.mark_cycle_pt(); !good_it.cycled_list(); good_it.forward()) {
1278      table_grid_.InsertBBox(true, true, good_it.extract());
1279    }
1280  }
1281  #ifndef GRAPHICS_DISABLED
1282  void TableFinder::DisplayColSegments(ScrollView *win, ColSegment_LIST *segments,
1283                                       ScrollView::Color color) {
1284    win->Pen(color);
1285    win->Brush(ScrollView::NONE);
1286    ColSegment_IT it(segments);
1287    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1288      ColSegment *col = it.data();
1289      const TBOX &box = col->bounding_box();
1290      int left_x = box.left();
1291      int right_x = box.right();
1292      int top_y = box.top();
1293      int bottom_y = box.bottom();
1294      win->Rectangle(left_x, bottom_y, right_x, top_y);
1295    }
1296    win->UpdateWindow();
1297  }
1298  void TableFinder::DisplayColPartitions(ScrollView *win, ColPartitionGrid *grid,
1299                                         ScrollView::Color default_color,
1300                                         ScrollView::Color table_color) {
1301    ScrollView::Color color = default_color;
1302    GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> gsearch(grid);
1303    gsearch.StartFullSearch();
1304    ColPartition *part = nullptr;
1305    while ((part = gsearch.NextFullSearch()) != nullptr) {
1306      color = default_color;
1307      if (part->type() == PT_TABLE) {
1308        color = table_color;
1309      }
1310      const TBOX &box = part->bounding_box();
1311      int left_x = box.left();
1312      int right_x = box.right();
1313      int top_y = box.top();
1314      int bottom_y = box.bottom();
1315      win->Brush(ScrollView::NONE);
1316      win->Pen(color);
1317      win->Rectangle(left_x, bottom_y, right_x, top_y);
1318    }
1319    win->UpdateWindow();
1320  }
1321  void TableFinder::DisplayColPartitions(ScrollView *win, ColPartitionGrid *grid,
1322                                         ScrollView::Color default_color) {
1323    DisplayColPartitions(win, grid, default_color, ScrollView::YELLOW);
1324  }
1325  void TableFinder::DisplayColPartitionConnections(ScrollView *win,
1326                                                   ColPartitionGrid *grid,
1327                                                   ScrollView::Color color) {
1328    GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> gsearch(grid);
1329    gsearch.StartFullSearch();
1330    ColPartition *part = nullptr;
1331    while ((part = gsearch.NextFullSearch()) != nullptr) {
<span onclick='openModal()' class='match'>1332      const TBOX &box = part->bounding_box();
1333      int left_x = box.left();
1334      int right_x = box.right();
1335      int top_y = box.top();
1336      int bottom_y = box.bottom();
1337      ColPartition *upper_part = part->nearest_neighbor_above();
</span>1338      if (upper_part) {
1339        const TBOX &upper_box = upper_part->bounding_box();
1340        int mid_x = (left_x + right_x) / 2;
1341        int mid_y = (top_y + bottom_y) / 2;
1342        int other_x = (upper_box.left() + upper_box.right()) / 2;
1343        int other_y = (upper_box.top() + upper_box.bottom()) / 2;
1344        win->Brush(ScrollView::NONE);
1345        win->Pen(color);
1346        win->Line(mid_x, mid_y, other_x, other_y);
1347      }
1348      ColPartition *lower_part = part->nearest_neighbor_below();
1349      if (lower_part) {
1350        const TBOX &lower_box = lower_part->bounding_box();
1351        int mid_x = (left_x + right_x) / 2;
1352        int mid_y = (top_y + bottom_y) / 2;
1353        int other_x = (lower_box.left() + lower_box.right()) / 2;
1354        int other_y = (lower_box.top() + lower_box.bottom()) / 2;
1355        win->Brush(ScrollView::NONE);
1356        win->Pen(color);
1357        win->Line(mid_x, mid_y, other_x, other_y);
1358      }
1359    }
1360    win->UpdateWindow();
1361  }
1362  #endif
1363  void TableFinder::MakeTableBlocks(ColPartitionGrid *grid,
1364                                    ColPartitionSet **all_columns,
1365                                    const WidthCallback &width_cb) {
1366    GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> gsearch(grid);
1367    gsearch.StartFullSearch();
1368    ColPartition *part = nullptr;
1369    while ((part = gsearch.NextFullSearch()) != nullptr) {
1370      if (part->type() == PT_TABLE) {
1371        part->clear_table_type();
1372      }
1373    }
1374    GridSearch<ColSegment, ColSegment_CLIST, ColSegment_C_IT> table_search(
1375        &table_grid_);
1376    table_search.StartFullSearch();
1377    ColSegment *table;
1378    while ((table = table_search.NextFullSearch()) != nullptr) {
1379      const TBOX &table_box = table->bounding_box();
1380      GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> rectsearch(
1381          grid);
1382      rectsearch.StartRectSearch(table_box);
1383      ColPartition *part;
1384      ColPartition *table_partition = nullptr;
1385      while ((part = rectsearch.NextRectSearch()) != nullptr) {
1386        if (!part->IsTextType()) {
1387          continue;
1388        }
1389        TBOX part_box = part->bounding_box();
1390        if (part_box.overlap_fraction(table_box) > kMinOverlapWithTable) {
1391          rectsearch.RemoveBBox();
1392          if (table_partition) {
1393            table_partition->Absorb(part, width_cb);
1394          } else {
1395            table_partition = part;
1396          }
1397        }
1398      }
1399      if (table_partition) {
1400        const TBOX &table_box = table_partition->bounding_box();
1401        int grid_x, grid_y;
1402        grid->GridCoords(table_box.left(), table_box.bottom(), &grid_x, &grid_y);
1403        table_partition->SetPartitionType(resolution_, all_columns[grid_y]);
1404        table_partition->set_table_type();
1405        table_partition->set_blob_type(BRT_TEXT);
1406        table_partition->set_flow(BTFT_CHAIN);
1407        table_partition->SetBlobTypes();
1408        grid->InsertBBox(true, true, table_partition);
1409      }
1410    }
1411  }
1412  ColSegment::ColSegment()
1413      : ELIST_LINK(),
1414        num_table_cells_(0),
1415        num_text_cells_(0),
1416        type_(COL_UNKNOWN) {}
1417  ScrollView::Color ColSegment::BoxColor() const {
1418    const ScrollView::Color kBoxColors[PT_COUNT] = {
1419        ScrollView::YELLOW,
1420        ScrollView::BLUE,
1421        ScrollView::YELLOW,
1422        ScrollView::MAGENTA,
1423    };
1424    return kBoxColors[type_];
1425  }
1426  void ColSegment::InsertBox(const TBOX &other) {
1427    bounding_box_ = bounding_box_.bounding_union(other);
1428  }
1429  void ColSegment::set_type() {
1430    if (num_table_cells_ > kTableColumnThreshold * num_text_cells_) {
1431      type_ = COL_TABLE;
1432    } else if (num_text_cells_ > num_table_cells_) {
1433      type_ = COL_TEXT;
1434    } else {
1435      type_ = COL_MIXED;
1436    }
1437  }
1438  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-async_param_server.cpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-tablefind.cpp</div>
                <div class="column column_space"><pre><code>122          TaskRequest task = to_send.front();
123          to_send.pop_front();
124          int root_rank = world_rank_to_root_rank(task.part_root_rank_);
125          int param_id = task.param_id_;
126          int part_id = task.part_id_;
127          int tag = task.GetTag();
128          Dtype* recv_ptr = recv_buf_[make_pair(root_rank, param_id)].first;
</pre></code></div>
                <div class="column column_space"><pre><code>1332      const TBOX &box = part->bounding_box();
1333      int left_x = box.left();
1334      int right_x = box.right();
1335      int top_y = box.top();
1336      int bottom_y = box.bottom();
1337      ColPartition *upper_part = part->nearest_neighbor_above();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    