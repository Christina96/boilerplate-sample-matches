<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for YProperty.h & tnode.h</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for YProperty.h & tnode.h
      </h3>
      <h1 align="center">
        5.2%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>YProperty.h (8.275862%)<TH>tnode.h (3.8961039%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match1021-0.html#0',2,'match1021-1.html#0',3)" NAME="0">(67-77)<TD><A HREF="javascript:ZweiFrames('match1021-0.html#0',2,'match1021-1.html#0',3)" NAME="0">(276-280)</A><TD ALIGN=center><FONT COLOR="#ff0000">12</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>YProperty.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
  Copyright (C) 2000-2012 Novell, Inc
  This library is free software; you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as
  published by the Free Software Foundation; either version 2.1 of the
  License, or (at your option) version 3.0 of the License. This library
  is distributed in the hope that it will be useful, but WITHOUT ANY
  WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
  License for more details. You should have received a copy of the GNU
  Lesser General Public License along with this library; if not, write
  to the Free Software Foundation, Inc., 51 Franklin Street, Fifth
  Floor, Boston, MA 02110-1301 USA
*/


/*-/

  File:		YProperty.h

  Author:	Stefan Hundhammer &lt;shundhammer@suse.de&gt;

/-*/

#ifndef YProperty_h
#define YProperty_h

#include &lt;string&gt;
#include &lt;vector&gt;



enum YPropertyType
{
    YUnknownPropertyType = 0,
    YOtherProperty,		// requires futher checking
    YStringProperty,		// const std::string &amp;
    YBoolProperty,		// bool
    YIntegerProperty		// YCP Integer == C++ long long
};

class YWidget;
class YProperty;

typedef long long	YInteger;


/**
 * Class for widget properties.
 **/
class YProperty
{
public:
    /**
     * Constructor: Create a property with the specified name and type.
     * 'isReadOnly' is for properties that cannot be set, only retrieved.
     **/
    YProperty( const std::string &amp; name, YPropertyType type, bool isReadOnly = false )
	: _name( name )
	, _type( type )
	, _isReadOnly( isReadOnly )
	{}

<A NAME="0"></A>    /**
     * Returns the name of this property.
     **/
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match1021-1.html#0',3,'match1021-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    std::string name() const { return _name; }

    /**
     * Returns the type of this property.
     **/
    YPropertyType type() const { return _type; }

    /**
     * Returns 'true' if this property cannot be changed, only retrieved.
     **/
    bool isReadOnly() const { return _isReadOnly; }</B></FONT>

    /**
     * Returns the type of this property as string.
     **/
    std::string typeAsStr() const { return YProperty::typeAsStr( _type ); }

    /**
     * Returns a string description of a property type.
     **/
    static std::string typeAsStr( YPropertyType type );

private:

    std::string		_name;
    YPropertyType	_type;
    bool		_isReadOnly;
};


/**
 * Transport class for the value of simple properties.
 *
 * More complex properties (lists of items, tree descriptions, ...) have to
 * be handled specifically someplace else, but most properties are of
 * simple types and can be treated in similar ways.
 **/
class YPropertyValue
{
public:

    /**
     * Constructor for string properties.
     **/
    YPropertyValue( const std::string &amp; str ):
	_type( YStringProperty ), _stringVal( str ) {}

    /**
     * Constructor for const char * (string) properties.
     **/
    YPropertyValue( const char * str ):
	_type( YStringProperty ), _stringVal( str ) {}

    /**
     * Constructor for bool properties.
     **/
    explicit YPropertyValue( bool b ):
	_type( YBoolProperty ), _boolVal( b ) {}

    /**
     * Constructor for numerical (YCP integer) properties.
     **/
    explicit YPropertyValue( YInteger num ):
	_type( YIntegerProperty ), _integerVal( num ) {}

    /**
     * Constructor for numerical (YCP integer) properties.
     **/
    explicit YPropertyValue( int num ):
	_type( YIntegerProperty ), _integerVal( num ) {}

    explicit YPropertyValue( YPropertyType type ) :
	_type( type ) {}

    /**
     * Default constructor
     **/
    YPropertyValue():
	_type( YUnknownPropertyType ) {}

    /**
     * Destructor.
     **/
    ~YPropertyValue();

    /**
     * Equality operator, can compare with another YPropertyValue.
     * @throw YUIException for incompatible property types
     * @return true if the value is the same
     */
    bool operator==( const YPropertyValue &amp;other ) const;

    /** Inequality operator
     * @throw YUIException for incompatible property types
     * @see operator==
     */
    bool operator!=( const YPropertyValue &amp;other ) const;

    /**
     * Returns the type of this property value.
     * Use this to determine which xyVal() method to use.
     **/
    YPropertyType type() const { return _type; }

    /**
     * Returns the type of this property value as string.
     **/
    std::string typeAsStr() const { return YProperty::typeAsStr( _type ); }

    /**
     * Methods to get the value of this property.
     * Check with type() which one to use.
     **/
    std::string	stringVal() 	const { return _stringVal;	}
    bool 	boolVal()	const { return _boolVal;	}
    YInteger 	integerVal()	const { return _integerVal;	}


private:

    YPropertyType	_type;
    std::string		_stringVal;
    bool		_boolVal;
    YInteger		_integerVal;
};


/**
 * A set of properties to check names and types against.
 **/
class YPropertySet
{
public:
    /**
     * Constructor.
     **/
    YPropertySet();

    /**
     * Check if a property 'propertyName' exists in this property set.
     * Throw a YUIUnknownPropertyException if it does not exist.
     * Use YPropertySet::contains() for a check that simply returns 'false'
     * if it does not exist.
     **/
    void check( const std::string &amp; propertyName ) const;

    /**
     * Check if a property 'propertyName' exists in this property set.
     * Throw a YUIUnknownPropertyException if it does not exist.
     *
     * If there is a property with that name, check also the expected type
     * against 'type'. If the types don't match, throw a
     * YUIPropertyTypeMismatchException.
     * If the property is read-only, throw a YUISetReadOnlyPropertyException.
     **/
    void check( const std::string &amp; propertyName, YPropertyType type ) const;

    /**
     * Same as above, overloaded for convenience.
     **/
    void check( const YProperty &amp; prop ) const
	{ check( prop.name(), prop.type() ); }

    /**
     * Check if a property 'propertyName' exists in this property set.
     * Returns 'true' if it exists, 'false' if not.
     *
     * Use YPropertySet::check() for a check that throws exceptions if
     * there is no such property.
     **/
    bool contains( const std::string &amp; propertyName ) const throw();

    /**
     * Check if a property 'propertyName' exists in this property set.
     * Returns 'true' if it exists, 'false' if not.
     *
     * If there is a property with that name, check also the expected type
     * against 'type'. If the types don't match, throw a
     * YUIPropertyTypeMismatchException.
     *
     * If the property is read-only, throw a YUISetReadOnlyPropertyException.
     *
     * Use YPropertySet::check() for a check that throws exceptions if
     * there is no such property.
     **/
    bool contains( const std::string &amp; propertyName, YPropertyType type ) const;

    /**
     * Same as above, overloaded for convenience.
     **/
    bool contains( const YProperty &amp; prop ) const
	{ return contains( prop.name(), prop.type() ); }

    /**
     * Returns 'true' if this property set does not contain anything.
     **/
    bool isEmpty() const { return _properties.empty(); }

    /**
     * Returns the number of properties in this set.
     **/
    int size() const { return (int) _properties.size(); }

    /**
     * Add a property to this property set.
     **/
    void add( const YProperty &amp; prop );

    /**
     * Adds all properties of another property set.
     *
     * If that other set contains duplicates (properties that are already
     * in this set), those others will never be found with lookup().
     **/
    void add( const YPropertySet &amp; otherSet );

    typedef std::vector&lt;YProperty&gt;::const_iterator const_iterator;

    /**
     * Returns an iterator that points to the first property in this set.
     **/
    const_iterator propertiesBegin() const;

    /**
     * Returns an iterator that points after the last property in this set.
     **/
    const_iterator propertiesEnd() const;

private:

    /**
     * This class uses a simple std::vector as a container to hold the
     * properties: Normally, the number of properties for each widget is so
     * small (2..5) that using any more sophisticated container like
     * std::set etc. would not pay off. More likely, it would add overhead.
     **/
    std::vector&lt;YProperty&gt; _properties;
};


#endif // YProperty_h
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>tnode.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
  Copyright (C) 2000-2012 Novell, Inc
  This library is free software; you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as
  published by the Free Software Foundation; either version 2.1 of the
  License, or (at your option) version 3.0 of the License. This library
  is distributed in the hope that it will be useful, but WITHOUT ANY
  WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
  License for more details. You should have received a copy of the GNU
  Lesser General Public License along with this library; if not, write
  to the Free Software Foundation, Inc., 51 Franklin Street, Fifth
  Floor, Boston, MA 02110-1301 USA
*/


/*-/

   File:       tnode.h

   Author:     Michael Andres &lt;ma@suse.de&gt;

/-*/

#ifndef tnode_h
#define tnode_h

#include &lt;iosfwd&gt;

/**
 * Tree node.
 *
 * Traversing the tree with \ref Next and \ref Prev is done
 * pre-order (self before children)
 * and depth-first (children before siblings)
 *
 * See also
 * - https://en.wikipedia.org/wiki/Depth-first_search
 * - https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR)
 *
 * In practice all instances of this template use NCWidget * for n_value.
 */
template &lt;class n_value&gt; class tnode
{

    tnode &amp; operator=( const tnode &amp; );
    tnode( const tnode &amp; );

protected:

    typedef tnode&lt;n_value&gt;   self;

    mutable n_value val;

private:

    self * parent;
    self * psibling;    // prev sibling
    self * nsibling;    // next sibling
    self * fchild;      // first child
    self * lchild;      // last  child

    // Disconnect from old parent, connect to new parent *p*.
    //
    // If *s* is specified (not nilptr), insert this
    // as its previous sibling (if *behind* is false)
    // or as its next sibling (if *behind* is true).
    //
    // If *s* is omitted (nilptr), become the first (behind==false) or last
    // (behind=true) child
    //
    // In case *s* is specified but is not in fact a child of *p* then it is
    // treated as omitted.
    //
    // @param p new parent
    // @param s reference sibling
    // @param behind true: insert after *s*; false: insert before *s*
    // @return true on success;
    //   false on failure (*p* is myself or a descendant of mine)
    bool DoReparentTo( self &amp; p, self * s, bool behind )
    {

	if ( &amp;p == this || p.IsDescendantOf( this ) )
	    return false;

	Disconnect();

	parent = &amp;p;

	PreReparent();

	if ( !s || s-&gt;parent != parent ) // using default sibling
	    s = behind ? parent-&gt;lchild : parent-&gt;fchild;

	if ( !s )
	{
	    // no sibling, so we'll be the only child
	    parent-&gt;fchild = parent-&gt;lchild = this;
	}
	else
	{
	    if ( behind )
	    {
		psibling    = s;
		nsibling    = s-&gt;nsibling;
		s-&gt;nsibling = this;

		if ( nsibling )
		    nsibling-&gt;psibling = this;
		else
		    parent-&gt;lchild     = this;
	    }
	    else
	    {
		psibling    = s-&gt;psibling;
		nsibling    = s;
		s-&gt;psibling = this;

		if ( psibling )
		    psibling-&gt;nsibling = this;
		else
		    parent-&gt;fchild     = this;
	    }
	}

	PostReparent();

	return true;
    }

protected:

    virtual void PreDisconnect()  {}

    virtual void PostDisconnect() {}

    virtual void PreReparent()	  {}

    virtual void PostReparent()   {}

public:

    /// New node, added as the last child by default (which is natural).
    /// @param p parent
    tnode( n_value v, self * p = 0, bool behind = true )
	    : val( v )
	    , parent( 0 )
	    , psibling( 0 )
	    , nsibling( 0 )
	    , fchild( 0 )
	    , lchild( 0 )
    {
	if ( p )
	    DoReparentTo( *p, 0, behind );
    }

    /// New node, added as the last child by default (which is natural).
    /// @param p parent
    tnode( n_value v, self &amp; p, bool behind = true )
	    : val( v )
	    , parent( 0 )
	    , psibling( 0 )
	    , nsibling( 0 )
	    , fchild( 0 )
	    , lchild( 0 )
    {
	DoReparentTo( p, 0, behind );
    }

    /// New node under *p*, just after *s* (or before *s* if behind==false)
    /// @param p parent
    /// @param s reference sibling
    tnode( n_value v, self &amp; p, self &amp; s, bool behind = true )
	    : val( v )
	    , parent( 0 )
	    , psibling( 0 )
	    , nsibling( 0 )
	    , fchild( 0 )
	    , lchild( 0 )
    {
	DoReparentTo( p, &amp;s, behind );
    }


    virtual ~tnode()
    {
	while ( fchild )
	    fchild-&gt;Disconnect();

	Disconnect();
    }

    /// Disconnect from the parent and siblings, but keep children.
    void Disconnect()
    {
	if ( !parent )
	    return;

	PreDisconnect();

	if ( psibling )
	    psibling-&gt;nsibling = nsibling;
	else
	    parent-&gt;fchild     = nsibling;

	if ( nsibling )
	    nsibling-&gt;psibling = psibling;
	else
	    parent-&gt;lchild     = psibling;

	parent = psibling = nsibling = 0;

	PostDisconnect();
    }

    /// Disconnect from old parent, connect to new parent *p*.
    /// Become the last child (or the first, if behind==false).
    ///
    /// @param p new parent
    /// @return true on success;
    ///   false on failure (*p* is myself or a descendant of mine)
    bool ReparentTo( self &amp; p, bool behind = true )
    {
	return DoReparentTo( p, 0, behind );
    }

    /// Disconnect from old parent, connect to new parent *p* and sibling *s*.
    ///
    /// Insert this as just after *s* (or just before, if behind==false).
    ///
    /// In case *s* is not in fact a child of *p* then we become *p*'s last
    /// (first) child.
    ///
    /// @param p new parent
    /// @param s reference sibling
    /// @param behind true: insert after *s*; false: insert before *s*
    /// @return true on success;
    ///   false on failure (*p* is myself or a descendant of mine)
    bool ReparentTo( self &amp; p, self &amp; s, bool behind = true )
    {
	return DoReparentTo( p, &amp;s, behind );
    }


    n_value &amp; Value()	   const { return val; }

    /// Alias for \ref Value
    n_value &amp; operator()() const { return Value(); }

    self *	 Parent()	  { return parent; }

    const self * Parent()   const { return parent; }

    /// Previous sibling
    self *	 Psibling()	  { return psibling; }

    /// Previous sibling
    const self * Psibling() const { return psibling; }

    /// Next sibling
    self *	 Nsibling()	  { return nsibling; }

    /// Next sibling
    const self * Nsibling() const { return nsibling; }

    /// First child
    self *	 Fchild()	  { return fchild; }

    /// First child
    const self * Fchild()   const { return fchild; }

    /// Last child
<A NAME="0"></A>    self *	 Lchild()	  { return lchild; }

    /// Last child
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1021-0.html#0',2,'match1021-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    const self * Lchild()   const { return lchild; }

    bool HasParent()   const { return parent; }

    bool HasSiblings() const { return psibling || nsibling; }</B></FONT>

    bool HasChildren() const { return fchild; }

    bool IsParentOf( const self &amp; c ) const { return c.parent == this; }

    bool IsSiblingOf( const self &amp; s ) const { return parent &amp;&amp; s.parent == parent; }

    bool IsChildOf( const self &amp; p ) const { return parent == &amp;p; }

    /// Depth: zero if no parent, otherwise 1 + parent's depth.
    unsigned Depth() const
    {
	self * l = const_cast&lt;self *&gt;( this );
	unsigned level = 0;

	while ( l-&gt;parent )
	{
	    l = l-&gt;parent;
	    ++level;
	}

	return level;
    }

    // tree walk

    bool IsDescendantOf( const self &amp; n ) const
    {
	for ( const self * l = parent; l; l = l-&gt;parent )
	{
	    if ( l == &amp;n )
		return true;
	}

	return false;
    }

    bool IsDescendantOf( const self * n ) const
    {
	return( n &amp;&amp; IsDescendantOf( *n ) );
    }

    /// Root of the tree
    self &amp; Top()
    {
	self * l = this;

	while ( l-&gt;parent )
	    l = l-&gt;parent;

	return *l;
    }

    /// Next node: depth first, pre-order.
    /// @param restart if true, the last node's Next is the first (\ref Top);
    ///   otherwise nilptr.
    self * Next( bool restart = false )
    {
	if ( fchild ) // down first
	    return fchild;

	self * l = this; // then next

	while ( !l-&gt;nsibling )
	{
	    if ( l-&gt;parent )
		l = l-&gt;parent;
	    else
		return restart ? l : 0; // at Top()
	}

	return l-&gt;nsibling;
    }

    self * Prev( bool restart = false )
    {
	if ( !psibling &amp;&amp; parent )
	    return parent;

	if ( !psibling &amp;&amp; !restart )
	    return 0;

	// have psibling or at Top() and restart:
	self * l = psibling ? psibling : this;

	while ( l-&gt;lchild )
	    l = l-&gt;lchild;

	return l;
    }

    /// Return \ref Next and assign it to *c*.
    self * Next( self *&amp; c, bool restart = false )
    {
	return c = Next( restart );
    }

    /// Return \ref Prev and assign it to *c*.
    self * Prev( self *&amp; c, bool restart = false )
    {
	return c = Prev( restart );
    }

    // const versions

    const self &amp; Top() const
    {
	return const_cast&lt;self *&gt;( this )-&gt;Top();
    }

    const self * Next( bool restart = false ) const
    {
	return const_cast&lt;self *&gt;( this )-&gt;Next( restart );
    }

    const self * Prev( bool restart = false ) const
    {
	return const_cast&lt;self *&gt;( this )-&gt;Prev( restart );
    }

    const self * Next( const self *&amp; c, bool restart = false ) const
    {
	return c = const_cast&lt;self *&gt;( this )-&gt;Next( restart );
    }

    const self * Prev( const self *&amp; c, bool restart = false ) const
    {
	return c = const_cast&lt;self *&gt;( this )-&gt;Prev( restart );
    }

};

#endif // tnode_h
</PRE>
</div>
  </div>
</body>
</html>
