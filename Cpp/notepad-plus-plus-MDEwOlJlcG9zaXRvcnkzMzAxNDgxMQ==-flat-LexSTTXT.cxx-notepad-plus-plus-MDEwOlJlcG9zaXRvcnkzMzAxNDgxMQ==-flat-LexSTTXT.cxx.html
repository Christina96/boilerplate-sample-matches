
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 49, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexSTTXT.cxx</h3>
            <pre><code>1  #include <stdlib.h>
2  #include <string.h>
3  #include <stdio.h>
4  #include <stdarg.h>
5  #include <assert.h>
6  #include <ctype.h>
7  #include <string>
8  #include <string_view>
9  #include "ILexer.h"
10  #include "Scintilla.h"
11  #include "SciLexer.h"
12  #include "WordList.h"
13  #include "LexAccessor.h"
14  #include "Accessor.h"
15  #include "StyleContext.h"
16  #include "CharacterSet.h"
17  #include "LexerModule.h"
18  using namespace Lexilla;
19  static void ClassifySTTXTWord(WordList *keywordlists[], StyleContext &sc)
20  {
21  	char s[256] = { 0 };
22  	sc.GetCurrentLowered(s, sizeof(s));
23   	if ((*keywordlists[0]).InList(s)) {
24   		sc.ChangeState(SCE_STTXT_KEYWORD);
25   	}
26  	else if ((*keywordlists[1]).InList(s)) {
27  		sc.ChangeState(SCE_STTXT_TYPE);
28  	}
29  	else if ((*keywordlists[2]).InList(s)) {
30  		sc.ChangeState(SCE_STTXT_FUNCTION);
31  	}
32  	else if ((*keywordlists[3]).InList(s)) {
33  		sc.ChangeState(SCE_STTXT_FB);
34  	}
35  	else if ((*keywordlists[4]).InList(s)) {
36  		sc.ChangeState(SCE_STTXT_VARS);
37  	}
38  	else if ((*keywordlists[5]).InList(s)) {
39  		sc.ChangeState(SCE_STTXT_PRAGMAS);
40  	}
41  	sc.SetState(SCE_STTXT_DEFAULT);
42  }
43  static void ColouriseSTTXTDoc (Sci_PositionU startPos, Sci_Position length, int initStyle,
44  							  WordList *keywordlists[], Accessor &styler)
45  {
46  	StyleContext sc(startPos, length, initStyle, styler);
47  	CharacterSet setWord(CharacterSet::setAlphaNum, "_", 0x80, true);
48  	CharacterSet setWordStart(CharacterSet::setAlpha, "_", 0x80, true);
49  	CharacterSet setNumber(CharacterSet::setDigits, "_.eE");
50  	CharacterSet setHexNumber(CharacterSet::setDigits, "_abcdefABCDEF");
51  	CharacterSet setOperator(CharacterSet::setNone,",.+-*/:;<=>[]()%&");
52  	CharacterSet setDataTime(CharacterSet::setDigits,"_.-:dmshDMSH");
53   	for ( ; sc.More() ; sc.Forward())
54   	{
55  		if(sc.atLineStart && sc.state != SCE_STTXT_COMMENT)
56  			sc.SetState(SCE_STTXT_DEFAULT);
57  		switch(sc.state)
58  		{
59  			case SCE_STTXT_NUMBER: {
60  				if(!setNumber.Contains(sc.ch))
61  					sc.SetState(SCE_STTXT_DEFAULT);
62  				break;
63  			}
64  			case SCE_STTXT_HEXNUMBER: {
65  				if (setHexNumber.Contains(sc.ch))
66  					continue;
67  				else if(setDataTime.Contains(sc.ch))
68  					sc.ChangeState(SCE_STTXT_DATETIME);
69  				else if(setWord.Contains(sc.ch))
70  					sc.ChangeState(SCE_STTXT_DEFAULT);
71  				else
72  					sc.SetState(SCE_STTXT_DEFAULT);
73  				break;
74  			}
75  			case SCE_STTXT_DATETIME: {
76  				if (setDataTime.Contains(sc.ch))
77  					continue;
78  				else if(setWord.Contains(sc.ch))
79  					sc.ChangeState(SCE_STTXT_DEFAULT);
80  				else
81  					sc.SetState(SCE_STTXT_DEFAULT);
82  				break;
83  			}
84  			case SCE_STTXT_OPERATOR: {
85  				sc.SetState(SCE_STTXT_DEFAULT);
86  				break;
87  			}
88  			case SCE_STTXT_PRAGMA: {
89  				if (sc.ch == '}')
90  					sc.ForwardSetState(SCE_STTXT_DEFAULT);
91  				break;
92  			}
93  			case SCE_STTXT_COMMENTLINE: {
94  				if (sc.atLineStart)
95  					sc.SetState(SCE_STTXT_DEFAULT);
96  				break;
97  			}
98  			case SCE_STTXT_COMMENT: {
99  				if(sc.Match('*',')'))
100  				{
101  					sc.Forward();
102  					sc.ForwardSetState(SCE_STTXT_DEFAULT);
103  				}
104  				break;
105  			}
106  			case SCE_STTXT_STRING1: {
107  				if(sc.atLineEnd)
108  					sc.SetState(SCE_STTXT_STRINGEOL);
109  				else if(sc.ch == '\'' && sc.chPrev != '$')
110  					sc.ForwardSetState(SCE_STTXT_DEFAULT);
111  				break;
112  			}
113  			case SCE_STTXT_STRING2: {
114  				if (sc.atLineEnd)
<span onclick='openModal()' class='match'>115  					sc.SetState(SCE_STTXT_STRINGEOL);
116  				else if(sc.ch == '\"' && sc.chPrev != '$')
117  					sc.ForwardSetState(SCE_STTXT_DEFAULT);
118  				break;
119  			}
120  			case SCE_STTXT_STRINGEOL: {
121  				if(sc.atLineStart)
122  					sc.SetState(SCE_STTXT_DEFAULT);
123  				break;
</span>124  			}
125  			case SCE_STTXT_CHARACTER: {
126  				if(setHexNumber.Contains(sc.ch))
127  					sc.SetState(SCE_STTXT_HEXNUMBER);
128  				else if(setDataTime.Contains(sc.ch))
129  					sc.SetState(SCE_STTXT_DATETIME);
130  				else sc.SetState(SCE_STTXT_DEFAULT);
131  				break;
132  			}
133  			case SCE_STTXT_IDENTIFIER: {
134  				if(!setWord.Contains(sc.ch))
135  					ClassifySTTXTWord(keywordlists, sc);
136  				break;
137  			}
138  		}
139  		if(sc.state == SCE_STTXT_DEFAULT)
140  		{
141  			if(IsADigit(sc.ch))
142  				sc.SetState(SCE_STTXT_NUMBER);
143  			else if (setWordStart.Contains(sc.ch))
144  				sc.SetState(SCE_STTXT_IDENTIFIER);
145  			else if (sc.Match('/', '/'))
146  				sc.SetState(SCE_STTXT_COMMENTLINE);
147  			else if(sc.Match('(', '*'))
148  				sc.SetState(SCE_STTXT_COMMENT);
149  			else if (sc.ch == '{')
150  				sc.SetState(SCE_STTXT_PRAGMA);
151  			else if (sc.ch == '\'')
152  				sc.SetState(SCE_STTXT_STRING1);
153  			else if (sc.ch == '\"')
154  				sc.SetState(SCE_STTXT_STRING2);
155  			else if(sc.ch == '#')
156  				sc.SetState(SCE_STTXT_CHARACTER);
157  			else if (setOperator.Contains(sc.ch))
158  				sc.SetState(SCE_STTXT_OPERATOR);
159  		}
160   	}
161  	if (sc.state == SCE_STTXT_IDENTIFIER && setWord.Contains(sc.chPrev))
162  		ClassifySTTXTWord(keywordlists, sc);
163  	sc.Complete();
164  }
165  static const char * const STTXTWordListDesc[] = {
166  	"Keywords",
167  	"Types",
168  	"Functions",
169  	"FB",
170  	"Local_Var",
171  	"Local_Pragma",
172  	0
173  };
174  static bool IsCommentLine(Sci_Position line, Accessor &styler, bool type)
175  {
176  	Sci_Position pos = styler.LineStart(line);
177  	Sci_Position eolPos = styler.LineStart(line + 1) - 1;
178  	for (Sci_Position i = pos; i < eolPos; i++)
179  	{
180  		char ch = styler[i];
181  		char chNext = styler.SafeGetCharAt(i + 1);
182  		int style = styler.StyleAt(i);
183  		if(type) {
184  			 if (ch == '/' && chNext == '/' && style == SCE_STTXT_COMMENTLINE)
185  				return true;
186  		}
187  		else if (ch == '(' && chNext == '*' && style == SCE_STTXT_COMMENT)
188  			break;
189  		if (!IsASpaceOrTab(ch))
190  			return false;
191  	}
192  	for (Sci_Position i = eolPos-2; i>pos; i--)
193  	{
194  		char ch = styler[i];
195  		char chPrev = styler.SafeGetCharAt(i-1);
196  		int style = styler.StyleAt(i);
197  		if(ch == ')' && chPrev == '*' && style == SCE_STTXT_COMMENT)
198  			return true;
199  		if(!IsASpaceOrTab(ch))
200  			return false;
201  	}
202  	return false;
203  }
204  static bool IsPragmaLine(Sci_Position line, Accessor &styler)
205  {
206  	Sci_Position pos = styler.LineStart(line);
207  	Sci_Position eolPos = styler.LineStart(line+1) - 1;
208  	for (Sci_Position i = pos ; i < eolPos ; i++)
209  	{
210  		char ch = styler[i];
211  		int style = styler.StyleAt(i);
212  		if(ch == '{' && style == SCE_STTXT_PRAGMA)
213  			return true;
214  		else if (!IsASpaceOrTab(ch))
215  			return false;
216  	}
217  	return false;
218  }
219  static void GetRangeUpper(Sci_PositionU start,Sci_PositionU end,Accessor &styler,char *s,Sci_PositionU len)
220  {
221  	Sci_PositionU i = 0;
222  	while ((i < end - start + 1) && (i < len-1)) {
223  		s[i] = static_cast<char>(toupper(styler[start + i]));
224  		i++;
225  	}
226  	s[i] = '\0';
227  }
228  static void ClassifySTTXTWordFoldPoint(int &levelCurrent,Sci_PositionU lastStart,
229  									 Sci_PositionU currentPos, Accessor &styler)
230  {
231  	char s[256];
232  	GetRangeUpper(lastStart, currentPos, styler, s, sizeof(s));
233  	if (!strcmp(s, "ACTION") ||
234  		!strcmp(s, "CASE") ||
235  		!strcmp(s, "CONFIGURATION") ||
236  		!strcmp(s, "FOR") ||
237  		!strcmp(s, "FUNCTION") ||
238  		!strcmp(s, "FUNCTION_BLOCK") ||
239  		!strcmp(s, "IF") ||
240  		!strcmp(s, "INITIAL_STEP") ||
241  		!strcmp(s, "REPEAT") ||
242  		!strcmp(s, "RESOURCE") ||
243  		!strcmp(s, "STEP") ||
244  		!strcmp(s, "STRUCT") ||
245  		!strcmp(s, "TRANSITION") ||
246  		!strcmp(s, "TYPE") ||
247  		!strcmp(s, "VAR") ||
248  		!strcmp(s, "VAR_INPUT") ||
249  		!strcmp(s, "VAR_OUTPUT") ||
250  		!strcmp(s, "VAR_IN_OUT") ||
251  		!strcmp(s, "VAR_TEMP") ||
252  		!strcmp(s, "VAR_EXTERNAL") ||
253  		!strcmp(s, "VAR_ACCESS") ||
254  		!strcmp(s, "VAR_CONFIG") ||
255  		!strcmp(s, "VAR_GLOBAL") ||
256  		!strcmp(s, "WHILE"))
257  	{
258  		levelCurrent++;
259  	}
260  	else if (!strcmp(s, "END_ACTION") ||
261  		!strcmp(s, "END_CASE") ||
262  		!strcmp(s, "END_CONFIGURATION") ||
263  		!strcmp(s, "END_FOR") ||
264  		!strcmp(s, "END_FUNCTION") ||
265  		!strcmp(s, "END_FUNCTION_BLOCK") ||
266  		!strcmp(s, "END_IF") ||
267  		!strcmp(s, "END_REPEAT") ||
268  		!strcmp(s, "END_RESOURCE") ||
269  		!strcmp(s, "END_STEP") ||
270  		!strcmp(s, "END_STRUCT") ||
271  		!strcmp(s, "END_TRANSITION") ||
272  		!strcmp(s, "END_TYPE") ||
273  		!strcmp(s, "END_VAR") ||
274  		!strcmp(s, "END_WHILE"))
275  	{
276  		levelCurrent--;
277  		if (levelCurrent < SC_FOLDLEVELBASE) {
278  			levelCurrent = SC_FOLDLEVELBASE;
279  		}
280  	}
281  }
282  static void FoldSTTXTDoc(Sci_PositionU startPos, Sci_Position length, int initStyle, WordList *[],Accessor &styler)
283  {
284  	bool foldComment = styler.GetPropertyInt("fold.comment") != 0;
285  	bool foldPreprocessor = styler.GetPropertyInt("fold.preprocessor") != 0;
286  	bool foldCompact = styler.GetPropertyInt("fold.compact", 1) != 0;
287  	Sci_PositionU endPos = startPos + length;
288  	int visibleChars = 0;
289  	Sci_Position lineCurrent = styler.GetLine(startPos);
290  	int levelPrev = styler.LevelAt(lineCurrent) & SC_FOLDLEVELNUMBERMASK;
291  	int levelCurrent = levelPrev;
292  	char chNext = styler[startPos];
293  	int styleNext = styler.StyleAt(startPos);
294  	int style = initStyle;
295  	Sci_Position lastStart = 0;
296  	CharacterSet setWord(CharacterSet::setAlphaNum, "_", 0x80, true);
297  	for (Sci_PositionU i = startPos; i < endPos; i++)
298  	{
299  		char ch = chNext;
300  		chNext = styler.SafeGetCharAt(i + 1);
301  		int stylePrev = style;
302  		style = styleNext;
303  		styleNext = styler.StyleAt(i + 1);
304  		bool atEOL = (ch == '\r' && chNext != '\n') || (ch == '\n');
305  		if (foldComment && style == SCE_STTXT_COMMENT) {
306  			if(stylePrev != SCE_STTXT_COMMENT)
307  				levelCurrent++;
308  			else if(styleNext != SCE_STTXT_COMMENT && !atEOL)
309  				levelCurrent--;
310  		}
311  		if ( foldComment && atEOL && ( IsCommentLine(lineCurrent, styler,false)
312  			|| IsCommentLine(lineCurrent,styler,true))) {
313   			if(!IsCommentLine(lineCurrent-1, styler,true) && IsCommentLine(lineCurrent+1, styler,true))
314  				levelCurrent++;
315  			if (IsCommentLine(lineCurrent-1, styler,true) && !IsCommentLine(lineCurrent+1, styler,true))
316  				levelCurrent--;
317  			if (!IsCommentLine(lineCurrent-1, styler,false) && IsCommentLine(lineCurrent+1, styler,false))
318  				levelCurrent++;
319  			if (IsCommentLine(lineCurrent-1, styler,false) && !IsCommentLine(lineCurrent+1, styler,false))
320  				levelCurrent--;
321  		}
322  		if(foldPreprocessor && atEOL && IsPragmaLine(lineCurrent, styler)) {
323  			if(!IsPragmaLine(lineCurrent-1, styler) && IsPragmaLine(lineCurrent+1, styler ))
324  				levelCurrent++;
325  			else if(IsPragmaLine(lineCurrent-1, styler) && !IsPragmaLine(lineCurrent+1, styler))
326  				levelCurrent--;
327  		}
328  		if (stylePrev != SCE_STTXT_KEYWORD && style == SCE_STTXT_KEYWORD) {
329  				lastStart = i;
330  		}
331  		if(stylePrev == SCE_STTXT_KEYWORD) {
332  			if(setWord.Contains(ch) && !setWord.Contains(chNext))
333  				ClassifySTTXTWordFoldPoint(levelCurrent,lastStart, i, styler);
334  		}
335  		if (!IsASpace(ch)) {
336  			visibleChars++;
337  		}
338  		if (atEOL) {
339  			int lev = levelPrev;
340  			if (visibleChars == 0 && foldCompact)
341  				lev |= SC_FOLDLEVELWHITEFLAG;
342  			if ((levelCurrent > levelPrev) && (visibleChars > 0))
343  				lev |= SC_FOLDLEVELHEADERFLAG;
344  			if (lev != styler.LevelAt(lineCurrent))
345  				styler.SetLevel(lineCurrent, lev);
346  			lineCurrent++;
347  			levelPrev = levelCurrent;
348  			visibleChars = 0;
349  		}
350  		int lev = levelPrev;
351  		if (visibleChars == 0 && foldCompact)
352  			lev |= SC_FOLDLEVELWHITEFLAG;
353  		styler.SetLevel(lineCurrent, lev);
354  	}
355  }
356  LexerModule lmSTTXT(SCLEX_STTXT, ColouriseSTTXTDoc, "fcST", FoldSTTXTDoc, STTXTWordListDesc);
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexSTTXT.cxx</h3>
            <pre><code>1  #include <stdlib.h>
2  #include <string.h>
3  #include <stdio.h>
4  #include <stdarg.h>
5  #include <assert.h>
6  #include <ctype.h>
7  #include <string>
8  #include <string_view>
9  #include "ILexer.h"
10  #include "Scintilla.h"
11  #include "SciLexer.h"
12  #include "WordList.h"
13  #include "LexAccessor.h"
14  #include "Accessor.h"
15  #include "StyleContext.h"
16  #include "CharacterSet.h"
17  #include "LexerModule.h"
18  using namespace Lexilla;
19  static void ClassifySTTXTWord(WordList *keywordlists[], StyleContext &sc)
20  {
21  	char s[256] = { 0 };
22  	sc.GetCurrentLowered(s, sizeof(s));
23   	if ((*keywordlists[0]).InList(s)) {
24   		sc.ChangeState(SCE_STTXT_KEYWORD);
25   	}
26  	else if ((*keywordlists[1]).InList(s)) {
27  		sc.ChangeState(SCE_STTXT_TYPE);
28  	}
29  	else if ((*keywordlists[2]).InList(s)) {
30  		sc.ChangeState(SCE_STTXT_FUNCTION);
31  	}
32  	else if ((*keywordlists[3]).InList(s)) {
33  		sc.ChangeState(SCE_STTXT_FB);
34  	}
35  	else if ((*keywordlists[4]).InList(s)) {
36  		sc.ChangeState(SCE_STTXT_VARS);
37  	}
38  	else if ((*keywordlists[5]).InList(s)) {
39  		sc.ChangeState(SCE_STTXT_PRAGMAS);
40  	}
41  	sc.SetState(SCE_STTXT_DEFAULT);
42  }
43  static void ColouriseSTTXTDoc (Sci_PositionU startPos, Sci_Position length, int initStyle,
44  							  WordList *keywordlists[], Accessor &styler)
45  {
46  	StyleContext sc(startPos, length, initStyle, styler);
47  	CharacterSet setWord(CharacterSet::setAlphaNum, "_", 0x80, true);
48  	CharacterSet setWordStart(CharacterSet::setAlpha, "_", 0x80, true);
49  	CharacterSet setNumber(CharacterSet::setDigits, "_.eE");
50  	CharacterSet setHexNumber(CharacterSet::setDigits, "_abcdefABCDEF");
51  	CharacterSet setOperator(CharacterSet::setNone,",.+-*/:;<=>[]()%&");
52  	CharacterSet setDataTime(CharacterSet::setDigits,"_.-:dmshDMSH");
53   	for ( ; sc.More() ; sc.Forward())
54   	{
55  		if(sc.atLineStart && sc.state != SCE_STTXT_COMMENT)
56  			sc.SetState(SCE_STTXT_DEFAULT);
57  		switch(sc.state)
58  		{
59  			case SCE_STTXT_NUMBER: {
60  				if(!setNumber.Contains(sc.ch))
61  					sc.SetState(SCE_STTXT_DEFAULT);
62  				break;
63  			}
64  			case SCE_STTXT_HEXNUMBER: {
65  				if (setHexNumber.Contains(sc.ch))
66  					continue;
67  				else if(setDataTime.Contains(sc.ch))
68  					sc.ChangeState(SCE_STTXT_DATETIME);
69  				else if(setWord.Contains(sc.ch))
70  					sc.ChangeState(SCE_STTXT_DEFAULT);
71  				else
72  					sc.SetState(SCE_STTXT_DEFAULT);
73  				break;
74  			}
75  			case SCE_STTXT_DATETIME: {
76  				if (setDataTime.Contains(sc.ch))
77  					continue;
78  				else if(setWord.Contains(sc.ch))
79  					sc.ChangeState(SCE_STTXT_DEFAULT);
80  				else
81  					sc.SetState(SCE_STTXT_DEFAULT);
82  				break;
83  			}
84  			case SCE_STTXT_OPERATOR: {
85  				sc.SetState(SCE_STTXT_DEFAULT);
86  				break;
87  			}
88  			case SCE_STTXT_PRAGMA: {
89  				if (sc.ch == '}')
90  					sc.ForwardSetState(SCE_STTXT_DEFAULT);
91  				break;
92  			}
93  			case SCE_STTXT_COMMENTLINE: {
94  				if (sc.atLineStart)
95  					sc.SetState(SCE_STTXT_DEFAULT);
96  				break;
97  			}
98  			case SCE_STTXT_COMMENT: {
99  				if(sc.Match('*',')'))
100  				{
101  					sc.Forward();
102  					sc.ForwardSetState(SCE_STTXT_DEFAULT);
103  				}
104  				break;
105  			}
106  			case SCE_STTXT_STRING1: {
107  				if(sc.atLineEnd)
108  					sc.SetState(SCE_STTXT_STRINGEOL);
109  				else if(sc.ch == '\'' && sc.chPrev != '$')
110  					sc.ForwardSetState(SCE_STTXT_DEFAULT);
111  				break;
112  			}
113  			case SCE_STTXT_STRING2: {
114  				if (sc.atLineEnd)
<span onclick='openModal()' class='match'>115  					sc.SetState(SCE_STTXT_STRINGEOL);
116  				else if(sc.ch == '\"' && sc.chPrev != '$')
117  					sc.ForwardSetState(SCE_STTXT_DEFAULT);
118  				break;
119  			}
120  			case SCE_STTXT_STRINGEOL: {
121  				if(sc.atLineStart)
122  					sc.SetState(SCE_STTXT_DEFAULT);
123  				break;
</span>124  			}
125  			case SCE_STTXT_CHARACTER: {
126  				if(setHexNumber.Contains(sc.ch))
127  					sc.SetState(SCE_STTXT_HEXNUMBER);
128  				else if(setDataTime.Contains(sc.ch))
129  					sc.SetState(SCE_STTXT_DATETIME);
130  				else sc.SetState(SCE_STTXT_DEFAULT);
131  				break;
132  			}
133  			case SCE_STTXT_IDENTIFIER: {
134  				if(!setWord.Contains(sc.ch))
135  					ClassifySTTXTWord(keywordlists, sc);
136  				break;
137  			}
138  		}
139  		if(sc.state == SCE_STTXT_DEFAULT)
140  		{
141  			if(IsADigit(sc.ch))
142  				sc.SetState(SCE_STTXT_NUMBER);
143  			else if (setWordStart.Contains(sc.ch))
144  				sc.SetState(SCE_STTXT_IDENTIFIER);
145  			else if (sc.Match('/', '/'))
146  				sc.SetState(SCE_STTXT_COMMENTLINE);
147  			else if(sc.Match('(', '*'))
148  				sc.SetState(SCE_STTXT_COMMENT);
149  			else if (sc.ch == '{')
150  				sc.SetState(SCE_STTXT_PRAGMA);
151  			else if (sc.ch == '\'')
152  				sc.SetState(SCE_STTXT_STRING1);
153  			else if (sc.ch == '\"')
154  				sc.SetState(SCE_STTXT_STRING2);
155  			else if(sc.ch == '#')
156  				sc.SetState(SCE_STTXT_CHARACTER);
157  			else if (setOperator.Contains(sc.ch))
158  				sc.SetState(SCE_STTXT_OPERATOR);
159  		}
160   	}
161  	if (sc.state == SCE_STTXT_IDENTIFIER && setWord.Contains(sc.chPrev))
162  		ClassifySTTXTWord(keywordlists, sc);
163  	sc.Complete();
164  }
165  static const char * const STTXTWordListDesc[] = {
166  	"Keywords",
167  	"Types",
168  	"Functions",
169  	"FB",
170  	"Local_Var",
171  	"Local_Pragma",
172  	0
173  };
174  static bool IsCommentLine(Sci_Position line, Accessor &styler, bool type)
175  {
176  	Sci_Position pos = styler.LineStart(line);
177  	Sci_Position eolPos = styler.LineStart(line + 1) - 1;
178  	for (Sci_Position i = pos; i < eolPos; i++)
179  	{
180  		char ch = styler[i];
181  		char chNext = styler.SafeGetCharAt(i + 1);
182  		int style = styler.StyleAt(i);
183  		if(type) {
184  			 if (ch == '/' && chNext == '/' && style == SCE_STTXT_COMMENTLINE)
185  				return true;
186  		}
187  		else if (ch == '(' && chNext == '*' && style == SCE_STTXT_COMMENT)
188  			break;
189  		if (!IsASpaceOrTab(ch))
190  			return false;
191  	}
192  	for (Sci_Position i = eolPos-2; i>pos; i--)
193  	{
194  		char ch = styler[i];
195  		char chPrev = styler.SafeGetCharAt(i-1);
196  		int style = styler.StyleAt(i);
197  		if(ch == ')' && chPrev == '*' && style == SCE_STTXT_COMMENT)
198  			return true;
199  		if(!IsASpaceOrTab(ch))
200  			return false;
201  	}
202  	return false;
203  }
204  static bool IsPragmaLine(Sci_Position line, Accessor &styler)
205  {
206  	Sci_Position pos = styler.LineStart(line);
207  	Sci_Position eolPos = styler.LineStart(line+1) - 1;
208  	for (Sci_Position i = pos ; i < eolPos ; i++)
209  	{
210  		char ch = styler[i];
211  		int style = styler.StyleAt(i);
212  		if(ch == '{' && style == SCE_STTXT_PRAGMA)
213  			return true;
214  		else if (!IsASpaceOrTab(ch))
215  			return false;
216  	}
217  	return false;
218  }
219  static void GetRangeUpper(Sci_PositionU start,Sci_PositionU end,Accessor &styler,char *s,Sci_PositionU len)
220  {
221  	Sci_PositionU i = 0;
222  	while ((i < end - start + 1) && (i < len-1)) {
223  		s[i] = static_cast<char>(toupper(styler[start + i]));
224  		i++;
225  	}
226  	s[i] = '\0';
227  }
228  static void ClassifySTTXTWordFoldPoint(int &levelCurrent,Sci_PositionU lastStart,
229  									 Sci_PositionU currentPos, Accessor &styler)
230  {
231  	char s[256];
232  	GetRangeUpper(lastStart, currentPos, styler, s, sizeof(s));
233  	if (!strcmp(s, "ACTION") ||
234  		!strcmp(s, "CASE") ||
235  		!strcmp(s, "CONFIGURATION") ||
236  		!strcmp(s, "FOR") ||
237  		!strcmp(s, "FUNCTION") ||
238  		!strcmp(s, "FUNCTION_BLOCK") ||
239  		!strcmp(s, "IF") ||
240  		!strcmp(s, "INITIAL_STEP") ||
241  		!strcmp(s, "REPEAT") ||
242  		!strcmp(s, "RESOURCE") ||
243  		!strcmp(s, "STEP") ||
244  		!strcmp(s, "STRUCT") ||
245  		!strcmp(s, "TRANSITION") ||
246  		!strcmp(s, "TYPE") ||
247  		!strcmp(s, "VAR") ||
248  		!strcmp(s, "VAR_INPUT") ||
249  		!strcmp(s, "VAR_OUTPUT") ||
250  		!strcmp(s, "VAR_IN_OUT") ||
251  		!strcmp(s, "VAR_TEMP") ||
252  		!strcmp(s, "VAR_EXTERNAL") ||
253  		!strcmp(s, "VAR_ACCESS") ||
254  		!strcmp(s, "VAR_CONFIG") ||
255  		!strcmp(s, "VAR_GLOBAL") ||
256  		!strcmp(s, "WHILE"))
257  	{
258  		levelCurrent++;
259  	}
260  	else if (!strcmp(s, "END_ACTION") ||
261  		!strcmp(s, "END_CASE") ||
262  		!strcmp(s, "END_CONFIGURATION") ||
263  		!strcmp(s, "END_FOR") ||
264  		!strcmp(s, "END_FUNCTION") ||
265  		!strcmp(s, "END_FUNCTION_BLOCK") ||
266  		!strcmp(s, "END_IF") ||
267  		!strcmp(s, "END_REPEAT") ||
268  		!strcmp(s, "END_RESOURCE") ||
269  		!strcmp(s, "END_STEP") ||
270  		!strcmp(s, "END_STRUCT") ||
271  		!strcmp(s, "END_TRANSITION") ||
272  		!strcmp(s, "END_TYPE") ||
273  		!strcmp(s, "END_VAR") ||
274  		!strcmp(s, "END_WHILE"))
275  	{
276  		levelCurrent--;
277  		if (levelCurrent < SC_FOLDLEVELBASE) {
278  			levelCurrent = SC_FOLDLEVELBASE;
279  		}
280  	}
281  }
282  static void FoldSTTXTDoc(Sci_PositionU startPos, Sci_Position length, int initStyle, WordList *[],Accessor &styler)
283  {
284  	bool foldComment = styler.GetPropertyInt("fold.comment") != 0;
285  	bool foldPreprocessor = styler.GetPropertyInt("fold.preprocessor") != 0;
286  	bool foldCompact = styler.GetPropertyInt("fold.compact", 1) != 0;
287  	Sci_PositionU endPos = startPos + length;
288  	int visibleChars = 0;
289  	Sci_Position lineCurrent = styler.GetLine(startPos);
290  	int levelPrev = styler.LevelAt(lineCurrent) & SC_FOLDLEVELNUMBERMASK;
291  	int levelCurrent = levelPrev;
292  	char chNext = styler[startPos];
293  	int styleNext = styler.StyleAt(startPos);
294  	int style = initStyle;
295  	Sci_Position lastStart = 0;
296  	CharacterSet setWord(CharacterSet::setAlphaNum, "_", 0x80, true);
297  	for (Sci_PositionU i = startPos; i < endPos; i++)
298  	{
299  		char ch = chNext;
300  		chNext = styler.SafeGetCharAt(i + 1);
301  		int stylePrev = style;
302  		style = styleNext;
303  		styleNext = styler.StyleAt(i + 1);
304  		bool atEOL = (ch == '\r' && chNext != '\n') || (ch == '\n');
305  		if (foldComment && style == SCE_STTXT_COMMENT) {
306  			if(stylePrev != SCE_STTXT_COMMENT)
307  				levelCurrent++;
308  			else if(styleNext != SCE_STTXT_COMMENT && !atEOL)
309  				levelCurrent--;
310  		}
311  		if ( foldComment && atEOL && ( IsCommentLine(lineCurrent, styler,false)
312  			|| IsCommentLine(lineCurrent,styler,true))) {
313   			if(!IsCommentLine(lineCurrent-1, styler,true) && IsCommentLine(lineCurrent+1, styler,true))
314  				levelCurrent++;
315  			if (IsCommentLine(lineCurrent-1, styler,true) && !IsCommentLine(lineCurrent+1, styler,true))
316  				levelCurrent--;
317  			if (!IsCommentLine(lineCurrent-1, styler,false) && IsCommentLine(lineCurrent+1, styler,false))
318  				levelCurrent++;
319  			if (IsCommentLine(lineCurrent-1, styler,false) && !IsCommentLine(lineCurrent+1, styler,false))
320  				levelCurrent--;
321  		}
322  		if(foldPreprocessor && atEOL && IsPragmaLine(lineCurrent, styler)) {
323  			if(!IsPragmaLine(lineCurrent-1, styler) && IsPragmaLine(lineCurrent+1, styler ))
324  				levelCurrent++;
325  			else if(IsPragmaLine(lineCurrent-1, styler) && !IsPragmaLine(lineCurrent+1, styler))
326  				levelCurrent--;
327  		}
328  		if (stylePrev != SCE_STTXT_KEYWORD && style == SCE_STTXT_KEYWORD) {
329  				lastStart = i;
330  		}
331  		if(stylePrev == SCE_STTXT_KEYWORD) {
332  			if(setWord.Contains(ch) && !setWord.Contains(chNext))
333  				ClassifySTTXTWordFoldPoint(levelCurrent,lastStart, i, styler);
334  		}
335  		if (!IsASpace(ch)) {
336  			visibleChars++;
337  		}
338  		if (atEOL) {
339  			int lev = levelPrev;
340  			if (visibleChars == 0 && foldCompact)
341  				lev |= SC_FOLDLEVELWHITEFLAG;
342  			if ((levelCurrent > levelPrev) && (visibleChars > 0))
343  				lev |= SC_FOLDLEVELHEADERFLAG;
344  			if (lev != styler.LevelAt(lineCurrent))
345  				styler.SetLevel(lineCurrent, lev);
346  			lineCurrent++;
347  			levelPrev = levelCurrent;
348  			visibleChars = 0;
349  		}
350  		int lev = levelPrev;
351  		if (visibleChars == 0 && foldCompact)
352  			lev |= SC_FOLDLEVELWHITEFLAG;
353  		styler.SetLevel(lineCurrent, lev);
354  	}
355  }
356  LexerModule lmSTTXT(SCLEX_STTXT, ColouriseSTTXTDoc, "fcST", FoldSTTXTDoc, STTXTWordListDesc);
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexSTTXT.cxx</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexSTTXT.cxx</div>
                </div>
                <div class="column column_space"><pre><code>115  					sc.SetState(SCE_STTXT_STRINGEOL);
116  				else if(sc.ch == '\"' && sc.chPrev != '$')
117  					sc.ForwardSetState(SCE_STTXT_DEFAULT);
118  				break;
119  			}
120  			case SCE_STTXT_STRINGEOL: {
121  				if(sc.atLineStart)
122  					sc.SetState(SCE_STTXT_DEFAULT);
123  				break;
</pre></code></div>
                <div class="column column_space"><pre><code>115  					sc.SetState(SCE_STTXT_STRINGEOL);
116  				else if(sc.ch == '\"' && sc.chPrev != '$')
117  					sc.ForwardSetState(SCE_STTXT_DEFAULT);
118  				break;
119  			}
120  			case SCE_STTXT_STRINGEOL: {
121  				if(sc.atLineStart)
122  					sc.SetState(SCE_STTXT_DEFAULT);
123  				break;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    