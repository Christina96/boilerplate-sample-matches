
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.705779334500876%, Tokens: 11</h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-matrix.cpp</h3>
            <pre><code>1  #include "matrix.h"
2  #include "ratngs.h"
3  #include "tprintf.h"
4  #include "unicharset.h"
5  namespace tesseract {
6  MATRIX::~MATRIX() = default;
7  bool MATRIX::Classified(int col, int row, int wildcard_id) const {
8    if (get(col, row) == NOT_CLASSIFIED) {
9      return false;
10    }
11    BLOB_CHOICE_IT b_it(get(col, row));
12    for (b_it.mark_cycle_pt(); !b_it.cycled_list(); b_it.forward()) {
13      BLOB_CHOICE *choice = b_it.data();
14      if (choice->IsClassified()) {
15        return true;
16      }
17    }
18    return false;
19  }
20  void MATRIX::IncreaseBandSize(int bandwidth) {
21    ResizeWithCopy(dimension(), bandwidth);
22  }
23  MATRIX *MATRIX::ConsumeAndMakeBigger(int ind) {
24    int dim = dimension();
25    int band_width = bandwidth();
26    for (int col = ind; col >= 0 && col > ind - band_width; --col) {
27      if (array_[col * band_width + band_width - 1] != empty_) {
28        ++band_width;
29        break;
30      }
31    }
32    auto *result = new MATRIX(dim + 1, band_width);
<span onclick='openModal()' class='match'>33    for (int col = 0; col < dim; ++col) {
34      for (int row = col; row < dim && row < col + bandwidth(); ++row) {
35        MATRIX_COORD coord(col, row);
36        coord.MapForSplit(ind);
37        BLOB_CHOICE_LIST *choices = get(col, row);
</span>38        if (choices != nullptr) {
39          BLOB_CHOICE_IT bc_it(choices);
40          for (bc_it.mark_cycle_pt(); !bc_it.cycled_list(); bc_it.forward()) {
41            BLOB_CHOICE *choice = bc_it.data();
42            choice->set_matrix_cell(coord.col, coord.row);
43          }
44          ASSERT_HOST(coord.Valid(*result));
45          result->put(coord.col, coord.row, choices);
46        }
47      }
48    }
49    delete this;
50    return result;
51  }
52  MATRIX *MATRIX::DeepCopy() const {
53    int dim = dimension();
54    int band_width = bandwidth();
55    auto *result = new MATRIX(dim, band_width);
56    for (int col = 0; col < dim; ++col) {
57      for (int row = col; row < dim && row < col + band_width; ++row) {
58        BLOB_CHOICE_LIST *choices = get(col, row);
59        if (choices != nullptr) {
60          auto *copy_choices = new BLOB_CHOICE_LIST;
61          copy_choices->deep_copy(choices, &BLOB_CHOICE::deep_copy);
62          result->put(col, row, copy_choices);
63        }
64      }
65    }
66    return result;
67  }
68  void MATRIX::print(const UNICHARSET &unicharset) const {
69    tprintf("Ratings Matrix (top 3 choices)\n");
70    int dim = dimension();
71    int band_width = bandwidth();
72    int row, col;
73    for (col = 0; col < dim; ++col) {
74      for (row = col; row < dim && row < col + band_width; ++row) {
75        BLOB_CHOICE_LIST *rating = this->get(col, row);
76        if (rating == NOT_CLASSIFIED) {
77          continue;
78        }
79        BLOB_CHOICE_IT b_it(rating);
80        tprintf("col=%d row=%d ", col, row);
81        for (b_it.mark_cycle_pt(); !b_it.cycled_list(); b_it.forward()) {
82          tprintf("%s rat=%g cert=%g ", unicharset.id_to_unichar(b_it.data()->unichar_id()),
83                  b_it.data()->rating(), b_it.data()->certainty());
84        }
85        tprintf("\n");
86      }
87      tprintf("\n");
88    }
89    tprintf("\n");
90    for (col = 0; col < dim; ++col) {
91      tprintf("\t%d", col);
92    }
93    tprintf("\n");
94    for (row = 0; row < dim; ++row) {
95      for (col = 0; col <= row; ++col) {
96        if (col == 0) {
97          tprintf("%d\t", row);
98        }
99        if (row >= col + band_width) {
100          tprintf(" \t");
101          continue;
102        }
103        BLOB_CHOICE_LIST *rating = this->get(col, row);
104        if (rating != NOT_CLASSIFIED) {
105          BLOB_CHOICE_IT b_it(rating);
106          int counter = 0;
107          for (b_it.mark_cycle_pt(); !b_it.cycled_list(); b_it.forward()) {
108            tprintf("%s ", unicharset.id_to_unichar(b_it.data()->unichar_id()));
109            ++counter;
110            if (counter == 3) {
111              break;
112            }
113          }
114          tprintf("\t");
115        } else {
116          tprintf(" \t");
117        }
118      }
119      tprintf("\n");
120    }
121  }
122  } 
</code></pre>
        </div>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_mkl_pooling_layer.cpp</h3>
            <pre><code>1  #ifdef MKL2017_SUPPORTED
2  #include <vector>
3  #include "gtest/gtest.h"
4  #include "caffe/blob.hpp"
5  #include "caffe/common.hpp"
6  #include "caffe/filler.hpp"
7  #include "caffe/layers/mkl_layers.hpp"
8  #include "caffe/test/test_caffe_main.hpp"
9  #include "caffe/test/test_gradient_check_util.hpp"
10  namespace caffe {
11  template <typename TypeParam>
12  class MKLPoolingLayerTest : public MultiDeviceTest<TypeParam> {
13    typedef typename TypeParam::Dtype Dtype;
14   protected:
15    MKLPoolingLayerTest()
16        : blob_bottom_(new Blob<Dtype>()),
17          blob_top_(new Blob<Dtype>()),
18          blob_top_mask_(new Blob<size_t>()) {}
19    virtual void SetUp() {
20      Caffe::set_random_seed(1701);
21      blob_bottom_->Reshape(2, 3, 6, 5);
22      FillerParameter filler_param;
23      GaussianFiller<Dtype> filler(filler_param);
24      filler.Fill(this->blob_bottom_);
25      blob_bottom_vec_.push_back(blob_bottom_);
26      blob_top_vec_.push_back(blob_top_);
27    }
28    virtual ~MKLPoolingLayerTest() {
29      delete blob_bottom_;
30      delete blob_top_;
31      delete blob_top_mask_;
32    }
33    Blob<Dtype>* const blob_bottom_;
34    Blob<Dtype>* const blob_top_;
35    Blob<size_t>* const blob_top_mask_;
36    vector<Blob<Dtype>*> blob_bottom_vec_;
37    vector<Blob<Dtype>*> blob_top_vec_;
38    void TestForwardSquare() {
39      LayerParameter layer_param;
40      PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
41      pooling_param->set_kernel_size(2);
42      pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
43      const int num = 2;
44      const int channels = 2;
45      blob_bottom_->Reshape(num, channels, 3, 5);
46      for (int i = 0; i < 15 * num * channels; i += 15) {
47        blob_bottom_->mutable_cpu_data()[i +  0] = 1;
48        blob_bottom_->mutable_cpu_data()[i +  1] = 2;
49        blob_bottom_->mutable_cpu_data()[i +  2] = 5;
50        blob_bottom_->mutable_cpu_data()[i +  3] = 2;
51        blob_bottom_->mutable_cpu_data()[i +  4] = 3;
52        blob_bottom_->mutable_cpu_data()[i +  5] = 9;
53        blob_bottom_->mutable_cpu_data()[i +  6] = 4;
54        blob_bottom_->mutable_cpu_data()[i +  7] = 1;
55        blob_bottom_->mutable_cpu_data()[i +  8] = 4;
56        blob_bottom_->mutable_cpu_data()[i +  9] = 8;
57        blob_bottom_->mutable_cpu_data()[i + 10] = 1;
58        blob_bottom_->mutable_cpu_data()[i + 11] = 2;
59        blob_bottom_->mutable_cpu_data()[i + 12] = 5;
60        blob_bottom_->mutable_cpu_data()[i + 13] = 2;
61        blob_bottom_->mutable_cpu_data()[i + 14] = 3;
62      }
63      MKLPoolingLayer<Dtype> layer(layer_param);
64      layer.SetUp(blob_bottom_vec_, blob_top_vec_);
65      EXPECT_EQ(blob_top_->num(), num);
66      EXPECT_EQ(blob_top_->channels(), channels);
67      EXPECT_EQ(blob_top_->height(), 2);
68      EXPECT_EQ(blob_top_->width(), 4);
69      if (blob_top_vec_.size() > 1) {
70        EXPECT_EQ(blob_top_mask_->num(), num);
71        EXPECT_EQ(blob_top_mask_->channels(), channels);
72        EXPECT_EQ(blob_top_mask_->height(), 2);
73        EXPECT_EQ(blob_top_mask_->width(), 4);
74      }
75      layer.Forward(blob_bottom_vec_, blob_top_vec_);
76      for (int i = 0; i < 8 * num * channels; i += 8) {
77        EXPECT_EQ(blob_top_->cpu_data()[i + 0], 9);
78        EXPECT_EQ(blob_top_->cpu_data()[i + 1], 5);
79        EXPECT_EQ(blob_top_->cpu_data()[i + 2], 5);
80        EXPECT_EQ(blob_top_->cpu_data()[i + 3], 8);
81        EXPECT_EQ(blob_top_->cpu_data()[i + 4], 9);
82        EXPECT_EQ(blob_top_->cpu_data()[i + 5], 5);
83        EXPECT_EQ(blob_top_->cpu_data()[i + 6], 5);
84        EXPECT_EQ(blob_top_->cpu_data()[i + 7], 8);
85      }
86      if (blob_top_vec_.size() > 1) {
87        for (int i = 0; i < 8 * num * channels; i += 8) {
88          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 0],  5);
89          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 1],  2);
90          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 2],  2);
91          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 3],  9);
92          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 4],  5);
93          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 5], 12);
94          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 6], 12);
95          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 7],  9);
96        }
97      }
98    }
99    void TestForwardRectHigh() {
100      LayerParameter layer_param;
101      PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
102      pooling_param->set_kernel_h(3);
103      pooling_param->set_kernel_w(2);
104      pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
105      const int num = 2;
106      const int channels = 2;
107      blob_bottom_->Reshape(num, channels, 6, 6);
108      for (int i = 0; i < 36 * num * channels; i += 36) {
109        blob_bottom_->mutable_cpu_data()[i +  0] = 35;
110        blob_bottom_->mutable_cpu_data()[i +  1] = 1;
111        blob_bottom_->mutable_cpu_data()[i +  2] = 6;
112        blob_bottom_->mutable_cpu_data()[i +  3] = 26;
113        blob_bottom_->mutable_cpu_data()[i +  4] = 19;
114        blob_bottom_->mutable_cpu_data()[i +  5] = 24;
115        blob_bottom_->mutable_cpu_data()[i +  6] = 3;
116        blob_bottom_->mutable_cpu_data()[i +  7] = 32;
117        blob_bottom_->mutable_cpu_data()[i +  8] = 7;
118        blob_bottom_->mutable_cpu_data()[i +  9] = 21;
119        blob_bottom_->mutable_cpu_data()[i + 10] = 23;
120        blob_bottom_->mutable_cpu_data()[i + 11] = 25;
121        blob_bottom_->mutable_cpu_data()[i + 12] = 31;
122        blob_bottom_->mutable_cpu_data()[i + 13] = 9;
123        blob_bottom_->mutable_cpu_data()[i + 14] = 2;
124        blob_bottom_->mutable_cpu_data()[i + 15] = 22;
125        blob_bottom_->mutable_cpu_data()[i + 16] = 27;
126        blob_bottom_->mutable_cpu_data()[i + 17] = 20;
127        blob_bottom_->mutable_cpu_data()[i + 18] = 8;
128        blob_bottom_->mutable_cpu_data()[i + 19] = 28;
129        blob_bottom_->mutable_cpu_data()[i + 20] = 33;
130        blob_bottom_->mutable_cpu_data()[i + 21] = 17;
131        blob_bottom_->mutable_cpu_data()[i + 22] = 10;
132        blob_bottom_->mutable_cpu_data()[i + 23] = 15;
133        blob_bottom_->mutable_cpu_data()[i + 24] = 30;
134        blob_bottom_->mutable_cpu_data()[i + 25] = 5;
135        blob_bottom_->mutable_cpu_data()[i + 26] = 34;
136        blob_bottom_->mutable_cpu_data()[i + 27] = 12;
137        blob_bottom_->mutable_cpu_data()[i + 28] = 14;
138        blob_bottom_->mutable_cpu_data()[i + 29] = 16;
139        blob_bottom_->mutable_cpu_data()[i + 30] = 4;
140        blob_bottom_->mutable_cpu_data()[i + 31] = 36;
141        blob_bottom_->mutable_cpu_data()[i + 32] = 29;
142        blob_bottom_->mutable_cpu_data()[i + 33] = 13;
143        blob_bottom_->mutable_cpu_data()[i + 34] = 18;
144        blob_bottom_->mutable_cpu_data()[i + 35] = 11;
145      }
146      MKLPoolingLayer<Dtype> layer(layer_param);
147      layer.SetUp(blob_bottom_vec_, blob_top_vec_);
148      EXPECT_EQ(blob_top_->num(), num);
149      EXPECT_EQ(blob_top_->channels(), channels);
150      EXPECT_EQ(blob_top_->height(), 4);
151      EXPECT_EQ(blob_top_->width(), 5);
152      if (blob_top_vec_.size() > 1) {
153        EXPECT_EQ(blob_top_mask_->num(), num);
154        EXPECT_EQ(blob_top_mask_->channels(), channels);
155        EXPECT_EQ(blob_top_mask_->height(), 4);
156        EXPECT_EQ(blob_top_mask_->width(), 5);
157      }
158      layer.Forward(blob_bottom_vec_, blob_top_vec_);
159      for (int i = 0; i < 20 * num * channels; i += 20) {
160        EXPECT_EQ(blob_top_->cpu_data()[i +  0], 35);
161        EXPECT_EQ(blob_top_->cpu_data()[i +  1], 32);
162        EXPECT_EQ(blob_top_->cpu_data()[i +  2], 26);
163        EXPECT_EQ(blob_top_->cpu_data()[i +  3], 27);
164        EXPECT_EQ(blob_top_->cpu_data()[i +  4], 27);
165        EXPECT_EQ(blob_top_->cpu_data()[i +  5], 32);
166        EXPECT_EQ(blob_top_->cpu_data()[i +  6], 33);
167        EXPECT_EQ(blob_top_->cpu_data()[i +  7], 33);
168        EXPECT_EQ(blob_top_->cpu_data()[i +  8], 27);
169        EXPECT_EQ(blob_top_->cpu_data()[i +  9], 27);
170        EXPECT_EQ(blob_top_->cpu_data()[i + 10], 31);
171        EXPECT_EQ(blob_top_->cpu_data()[i + 11], 34);
172        EXPECT_EQ(blob_top_->cpu_data()[i + 12], 34);
173        EXPECT_EQ(blob_top_->cpu_data()[i + 13], 27);
174        EXPECT_EQ(blob_top_->cpu_data()[i + 14], 27);
175        EXPECT_EQ(blob_top_->cpu_data()[i + 15], 36);
176        EXPECT_EQ(blob_top_->cpu_data()[i + 16], 36);
177        EXPECT_EQ(blob_top_->cpu_data()[i + 17], 34);
178        EXPECT_EQ(blob_top_->cpu_data()[i + 18], 18);
179        EXPECT_EQ(blob_top_->cpu_data()[i + 19], 18);
180      }
181      if (blob_top_vec_.size() > 1) {
182        for (int i = 0; i < 20 * num * channels; i += 20) {
183          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  0],  0);
184          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  1],  7);
185          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  2],  3);
186          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  3], 16);
187          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  4], 16);
188          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  5],  7);
189          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  6], 20);
190          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  7], 20);
191          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  8], 16);
192          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  9], 16);
193          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 10], 12);
194          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 11], 26);
195          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 12], 26);
196          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 13], 16);
197          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 14], 16);
198          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 15], 31);
199          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 16], 31);
200          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 17], 26);
201          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 18], 34);
202          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 19], 34);
203        }
204      }
205    }
206    void TestForwardRectWide() {
207      LayerParameter layer_param;
208      PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
209      pooling_param->set_kernel_h(2);
210      pooling_param->set_kernel_w(3);
211      pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
212      const int num = 2;
213      const int channels = 2;
214      blob_bottom_->Reshape(num, channels, 6, 6);
215      for (int i = 0; i < 36 * num * channels; i += 36) {
216        blob_bottom_->mutable_cpu_data()[i +  0] = 35;
217        blob_bottom_->mutable_cpu_data()[i +  1] = 1;
218        blob_bottom_->mutable_cpu_data()[i +  2] = 6;
219        blob_bottom_->mutable_cpu_data()[i +  3] = 26;
220        blob_bottom_->mutable_cpu_data()[i +  4] = 19;
221        blob_bottom_->mutable_cpu_data()[i +  5] = 24;
222        blob_bottom_->mutable_cpu_data()[i +  6] = 3;
223        blob_bottom_->mutable_cpu_data()[i +  7] = 32;
224        blob_bottom_->mutable_cpu_data()[i +  8] = 7;
225        blob_bottom_->mutable_cpu_data()[i +  9] = 21;
226        blob_bottom_->mutable_cpu_data()[i + 10] = 23;
227        blob_bottom_->mutable_cpu_data()[i + 11] = 25;
228        blob_bottom_->mutable_cpu_data()[i + 12] = 31;
229        blob_bottom_->mutable_cpu_data()[i + 13] = 9;
230        blob_bottom_->mutable_cpu_data()[i + 14] = 2;
231        blob_bottom_->mutable_cpu_data()[i + 15] = 22;
232        blob_bottom_->mutable_cpu_data()[i + 16] = 27;
233        blob_bottom_->mutable_cpu_data()[i + 17] = 20;
234        blob_bottom_->mutable_cpu_data()[i + 18] = 8;
235        blob_bottom_->mutable_cpu_data()[i + 19] = 28;
236        blob_bottom_->mutable_cpu_data()[i + 20] = 33;
237        blob_bottom_->mutable_cpu_data()[i + 21] = 17;
238        blob_bottom_->mutable_cpu_data()[i + 22] = 10;
239        blob_bottom_->mutable_cpu_data()[i + 23] = 15;
240        blob_bottom_->mutable_cpu_data()[i + 24] = 30;
241        blob_bottom_->mutable_cpu_data()[i + 25] = 5;
242        blob_bottom_->mutable_cpu_data()[i + 26] = 34;
243        blob_bottom_->mutable_cpu_data()[i + 27] = 12;
244        blob_bottom_->mutable_cpu_data()[i + 28] = 14;
245        blob_bottom_->mutable_cpu_data()[i + 29] = 16;
246        blob_bottom_->mutable_cpu_data()[i + 30] = 4;
247        blob_bottom_->mutable_cpu_data()[i + 31] = 36;
248        blob_bottom_->mutable_cpu_data()[i + 32] = 29;
249        blob_bottom_->mutable_cpu_data()[i + 33] = 13;
250        blob_bottom_->mutable_cpu_data()[i + 34] = 18;
251        blob_bottom_->mutable_cpu_data()[i + 35] = 11;
252      }
253      MKLPoolingLayer<Dtype> layer(layer_param);
254      layer.SetUp(blob_bottom_vec_, blob_top_vec_);
255      EXPECT_EQ(blob_top_->num(), num);
256      EXPECT_EQ(blob_top_->channels(), channels);
257      EXPECT_EQ(blob_top_->height(), 5);
258      EXPECT_EQ(blob_top_->width(), 4);
259      if (blob_top_vec_.size() > 1) {
260        EXPECT_EQ(blob_top_mask_->num(), num);
261        EXPECT_EQ(blob_top_mask_->channels(), channels);
262        EXPECT_EQ(blob_top_mask_->height(), 5);
263        EXPECT_EQ(blob_top_mask_->width(), 4);
264      }
265      layer.Forward(blob_bottom_vec_, blob_top_vec_);
266      for (int i = 0; i < 20 * num * channels; i += 20) {
267        EXPECT_EQ(blob_top_->cpu_data()[i +  0], 35);
268        EXPECT_EQ(blob_top_->cpu_data()[i +  1], 32);
269        EXPECT_EQ(blob_top_->cpu_data()[i +  2], 26);
270        EXPECT_EQ(blob_top_->cpu_data()[i +  3], 26);
271        EXPECT_EQ(blob_top_->cpu_data()[i +  4], 32);
272        EXPECT_EQ(blob_top_->cpu_data()[i +  5], 32);
273        EXPECT_EQ(blob_top_->cpu_data()[i +  6], 27);
274        EXPECT_EQ(blob_top_->cpu_data()[i +  7], 27);
275        EXPECT_EQ(blob_top_->cpu_data()[i +  8], 33);
276        EXPECT_EQ(blob_top_->cpu_data()[i +  9], 33);
277        EXPECT_EQ(blob_top_->cpu_data()[i + 10], 33);
278        EXPECT_EQ(blob_top_->cpu_data()[i + 11], 27);
279        EXPECT_EQ(blob_top_->cpu_data()[i + 12], 34);
280        EXPECT_EQ(blob_top_->cpu_data()[i + 13], 34);
281        EXPECT_EQ(blob_top_->cpu_data()[i + 14], 34);
282        EXPECT_EQ(blob_top_->cpu_data()[i + 15], 17);
283        EXPECT_EQ(blob_top_->cpu_data()[i + 16], 36);
284        EXPECT_EQ(blob_top_->cpu_data()[i + 17], 36);
285        EXPECT_EQ(blob_top_->cpu_data()[i + 18], 34);
286        EXPECT_EQ(blob_top_->cpu_data()[i + 19], 18);
287      }
288      if (blob_top_vec_.size() > 1) {
289        for (int i = 0; i < 20 * num * channels; i += 20) {
290          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  0],  0);
291          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  1],  7);
292          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  2],  3);
293          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  3],  3);
294          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  4],  7);
295          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  5],  7);
296          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  6], 16);
297          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  7], 16);
298          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  8], 20);
299          EXPECT_EQ(blob_top_mask_->cpu_data()[i +  9], 20);
300          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 10], 20);
301          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 11], 16);
302          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 12], 26);
303          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 13], 26);
304          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 14], 26);
305          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 15], 21);
306          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 16], 31);
307          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 17], 31);
308          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 18], 26);
309          EXPECT_EQ(blob_top_mask_->cpu_data()[i + 19], 34);
310        }
311      }
312    }
313  };
314  typedef ::testing::Types<CPUDevice<float>,
315                           CPUDevice<double> > TestDtypesCPU;
316  TYPED_TEST_CASE(MKLPoolingLayerTest, TestDtypesCPU);
317  TYPED_TEST(MKLPoolingLayerTest, TestSetup) {
318    typedef typename TypeParam::Dtype Dtype;
319    LayerParameter layer_param;
320    PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
321    pooling_param->set_kernel_size(3);
322    pooling_param->set_stride(2);
323    MKLPoolingLayer<Dtype> layer(layer_param);
324    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
325    EXPECT_EQ(this->blob_top_->num(), this->blob_bottom_->num());
326    EXPECT_EQ(this->blob_top_->channels(), this->blob_bottom_->channels());
327    EXPECT_EQ(this->blob_top_->height(), 3);
328    EXPECT_EQ(this->blob_top_->width(), 2);
329  }
330  TYPED_TEST(MKLPoolingLayerTest, TestSetupPadded) {
331    typedef typename TypeParam::Dtype Dtype;
332    LayerParameter layer_param;
333    PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
334    pooling_param->set_kernel_size(3);
335    pooling_param->set_stride(2);
336    pooling_param->set_pad(1);
337    pooling_param->set_pool(PoolingParameter_PoolMethod_AVE);
338    MKLPoolingLayer<Dtype> layer(layer_param);
339    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
340    EXPECT_EQ(this->blob_top_->num(), this->blob_bottom_->num());
341    EXPECT_EQ(this->blob_top_->channels(), this->blob_bottom_->channels());
342    EXPECT_EQ(this->blob_top_->height(), 4);
343    EXPECT_EQ(this->blob_top_->width(), 3);
344  }
345  TYPED_TEST(MKLPoolingLayerTest, TestSetupGlobalPooling) {
346    typedef typename TypeParam::Dtype Dtype;
347    LayerParameter layer_param;
348    PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
349    pooling_param->set_global_pooling(true);
350    pooling_param->set_pool(PoolingParameter_PoolMethod_AVE);
351    MKLPoolingLayer<Dtype> layer(layer_param);
352    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
353    EXPECT_EQ(this->blob_top_->num(), this->blob_bottom_->num());
354    EXPECT_EQ(this->blob_top_->channels(), this->blob_bottom_->channels());
355    EXPECT_EQ(this->blob_top_->height(), 1);
356    EXPECT_EQ(this->blob_top_->width(), 1);
357  }
358  TYPED_TEST(MKLPoolingLayerTest, TestForwardMax) {
359    this->TestForwardSquare();
360    this->TestForwardRectHigh();
361    this->TestForwardRectWide();
362  }
363  TYPED_TEST(MKLPoolingLayerTest, TestForwardMaxTopMask) {
364    typedef typename TypeParam::Dtype Dtype;
365    this->blob_top_vec_.push_back(reinterpret_cast<Blob<Dtype>* >
366            (this->blob_top_mask_));
367    this->TestForwardSquare();
368    this->TestForwardRectHigh();
369    this->TestForwardRectWide();
370  }
371  TYPED_TEST(MKLPoolingLayerTest, TestGradientMax) {
372    typedef typename TypeParam::Dtype Dtype;
<span onclick='openModal()' class='match'>373    for (int kernel_h = 3; kernel_h <= 4; kernel_h++) {
374      for (int kernel_w = 3; kernel_w <= 4; kernel_w++) {
375        LayerParameter layer_param;
376        PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
</span>377        pooling_param->set_kernel_h(kernel_h);
378        pooling_param->set_kernel_w(kernel_w);
379        pooling_param->set_stride(2);
380        pooling_param->set_pad(1);
381        pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
382        MKLPoolingLayer<Dtype> layer(layer_param);
383        GradientChecker<Dtype> checker(1e-4, 1e-2);
384        checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
385            this->blob_top_vec_);
386      }
387    }
388  }
389  TYPED_TEST(MKLPoolingLayerTest, TestForwardMaxPadded) {
390    typedef typename TypeParam::Dtype Dtype;
391    LayerParameter layer_param;
392    PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
393    pooling_param->set_kernel_size(3);
394    pooling_param->set_stride(2);
395    pooling_param->set_pad(2);
396    pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
397    this->blob_bottom_->Reshape(1, 1, 3, 3);
398    this->blob_bottom_->mutable_cpu_data()[0] = 1;
399    this->blob_bottom_->mutable_cpu_data()[1] = 2;
400    this->blob_bottom_->mutable_cpu_data()[2] = 4;
401    this->blob_bottom_->mutable_cpu_data()[3] = 2;
402    this->blob_bottom_->mutable_cpu_data()[4] = 3;
403    this->blob_bottom_->mutable_cpu_data()[5] = 2;
404    this->blob_bottom_->mutable_cpu_data()[6] = 4;
405    this->blob_bottom_->mutable_cpu_data()[7] = 2;
406    this->blob_bottom_->mutable_cpu_data()[8] = 1;
407    MKLPoolingLayer<Dtype> layer(layer_param);
408    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
409    EXPECT_EQ(this->blob_top_->num(), 1);
410    EXPECT_EQ(this->blob_top_->channels(), 1);
411    EXPECT_EQ(this->blob_top_->height(), 3);
412    EXPECT_EQ(this->blob_top_->width(), 3);
413    layer.Forward(this->blob_bottom_vec_, this->blob_top_vec_);
414    Dtype epsilon = 1e-8;
415    EXPECT_NEAR(this->blob_top_->cpu_data()[0], 1, epsilon);
416    EXPECT_NEAR(this->blob_top_->cpu_data()[1], 4, epsilon);
417    EXPECT_NEAR(this->blob_top_->cpu_data()[2], 4, epsilon);
418    EXPECT_NEAR(this->blob_top_->cpu_data()[3], 4, epsilon);
419    EXPECT_NEAR(this->blob_top_->cpu_data()[4], 4, epsilon);
420    EXPECT_NEAR(this->blob_top_->cpu_data()[5], 4, epsilon);
421    EXPECT_NEAR(this->blob_top_->cpu_data()[6], 4, epsilon);
422    EXPECT_NEAR(this->blob_top_->cpu_data()[7], 4, epsilon);
423    EXPECT_NEAR(this->blob_top_->cpu_data()[8], 1, epsilon);
424  }
425  #if 0
426  TYPED_TEST(MKLPoolingLayerTest, TestGradientMaxTopMask) {
427    typedef typename TypeParam::Dtype Dtype;
428    for (int kernel_h = 3; kernel_h <= 4; kernel_h++) {
429      for (int kernel_w = 3; kernel_w <= 4; kernel_w++) {
430        LayerParameter layer_param;
431        PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
432        pooling_param->set_kernel_h(kernel_h);
433        pooling_param->set_kernel_w(kernel_w);
434        pooling_param->set_stride(2);
435        pooling_param->set_pool(PoolingParameter_PoolMethod_MAX);
436        this->blob_top_vec_.push_back(reinterpret_cast<Blob<Dtype>* >
437                (this->blob_top_mask_));
438        MKLPoolingLayer<Dtype> layer(layer_param);
439        GradientChecker<Dtype> checker(1e-4, 1e-2);
440        checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
441            this->blob_top_vec_);
442        this->blob_top_vec_.pop_back();
443      }
444    }
445  }
446  #endif
447  #if 0  
448  TYPED_TEST(MKLPoolingLayerTest, TestForwardAve) {
449    typedef typename TypeParam::Dtype Dtype;
450    LayerParameter layer_param;
451    PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
452    pooling_param->set_kernel_size(3);
453    pooling_param->set_stride(1);
454    pooling_param->set_pad(1);
455    pooling_param->set_pool(PoolingParameter_PoolMethod_AVE);
456    this->blob_bottom_->Reshape(1, 1, 3, 3);
457    FillerParameter filler_param;
458    filler_param.set_value(Dtype(2));
459    ConstantFiller<Dtype> filler(filler_param);
460    filler.Fill(this->blob_bottom_);
461    MKLPoolingLayer<Dtype> layer(layer_param);
462    layer.SetUp(this->blob_bottom_vec_, this->blob_top_vec_);
463    EXPECT_EQ(this->blob_top_->num(), 1);
464    EXPECT_EQ(this->blob_top_->channels(), 1);
465    EXPECT_EQ(this->blob_top_->height(), 3);
466    EXPECT_EQ(this->blob_top_->width(), 3);
467    layer.Forward(this->blob_bottom_vec_, this->blob_top_vec_);
468    Dtype epsilon = 1e-5;
469    EXPECT_NEAR(this->blob_top_->cpu_data()[0], 8.0 / 9, epsilon);
470    EXPECT_NEAR(this->blob_top_->cpu_data()[1], 4.0 / 3, epsilon);
471    EXPECT_NEAR(this->blob_top_->cpu_data()[2], 8.0 / 9, epsilon);
472    EXPECT_NEAR(this->blob_top_->cpu_data()[3], 4.0 / 3, epsilon);
473    EXPECT_NEAR(this->blob_top_->cpu_data()[4], 2.0    , epsilon);
474    EXPECT_NEAR(this->blob_top_->cpu_data()[5], 4.0 / 3, epsilon);
475    EXPECT_NEAR(this->blob_top_->cpu_data()[6], 8.0 / 9, epsilon);
476    EXPECT_NEAR(this->blob_top_->cpu_data()[7], 4.0 / 3, epsilon);
477    EXPECT_NEAR(this->blob_top_->cpu_data()[8], 8.0 / 9, epsilon);
478  }
479  TYPED_TEST(MKLPoolingLayerTest, TestGradientAve) {
480    typedef typename TypeParam::Dtype Dtype;
481    for (int kernel_h = 3; kernel_h <= 4; kernel_h++) {
482      for (int kernel_w = 3; kernel_w <= 4; kernel_w++) {
483        LayerParameter layer_param;
484        PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
485        pooling_param->set_kernel_h(kernel_h);
486        pooling_param->set_kernel_w(kernel_w);
487        pooling_param->set_stride(2);
488        pooling_param->set_pool(PoolingParameter_PoolMethod_AVE);
489        MKLPoolingLayer<Dtype> layer(layer_param);
490        GradientChecker<Dtype> checker(1e-2, 1e-2);
491        checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
492            this->blob_top_vec_);
493      }
494    }
495  }
496  TYPED_TEST(MKLPoolingLayerTest, TestGradientAvePadded) {
497    typedef typename TypeParam::Dtype Dtype;
498    for (int kernel_h = 3; kernel_h <= 4; kernel_h++) {
499      for (int kernel_w = 3; kernel_w <= 4; kernel_w++) {
500        LayerParameter layer_param;
501        PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
502        pooling_param->set_kernel_h(kernel_h);
503        pooling_param->set_kernel_w(kernel_w);
504        pooling_param->set_stride(2);
505        pooling_param->set_pad(2);
506        pooling_param->set_pool(PoolingParameter_PoolMethod_AVE);
507        MKLPoolingLayer<Dtype> layer(layer_param);
508        GradientChecker<Dtype> checker(1e-2, 1e-2);
509        checker.CheckGradientExhaustive(&layer, this->blob_bottom_vec_,
510            this->blob_top_vec_);
511      }
512    }
513  }
514  #endif
515  }  
516  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-matrix.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_mkl_pooling_layer.cpp</div>
                </div>
                <div class="column column_space"><pre><code>33    for (int col = 0; col < dim; ++col) {
34      for (int row = col; row < dim && row < col + bandwidth(); ++row) {
35        MATRIX_COORD coord(col, row);
36        coord.MapForSplit(ind);
37        BLOB_CHOICE_LIST *choices = get(col, row);
</pre></code></div>
                <div class="column column_space"><pre><code>373    for (int kernel_h = 3; kernel_h <= 4; kernel_h++) {
374      for (int kernel_w = 3; kernel_w <= 4; kernel_w++) {
375        LayerParameter layer_param;
376        PoolingParameter* pooling_param = layer_param.mutable_pooling_param();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    