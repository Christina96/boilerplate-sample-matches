
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 1.0995052226498077%, Tokens: 10</h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-websocket_59.cpp</h3>
            <pre><code>1  #include <nano/boost/asio/bind_executor.hpp>
2  #include <nano/boost/asio/dispatch.hpp>
3  #include <nano/boost/asio/strand.hpp>
4  #include <nano/lib/tlsconfig.hpp>
5  #include <nano/lib/work.hpp>
6  #include <nano/node/node_observers.hpp>
7  #include <nano/node/transport/channel.hpp>
8  #include <nano/node/transport/transport.hpp>
9  #include <nano/node/wallet.hpp>
10  #include <nano/node/websocket.hpp>
11  #include <boost/algorithm/string.hpp>
12  #include <boost/property_tree/json_parser.hpp>
13  #include <algorithm>
14  #include <chrono>
15  nano::websocket::confirmation_options::confirmation_options (nano::wallets & wallets_a) :
16  	wallets (wallets_a)
17  {
18  }
19  nano::websocket::confirmation_options::confirmation_options (boost::property_tree::ptree const & options_a, nano::wallets & wallets_a, nano::logger_mt & logger_a) :
20  	wallets (wallets_a),
21  	logger (logger_a)
22  {
23  	include_block = options_a.get<bool> ("include_block", true);
24  	include_election_info = options_a.get<bool> ("include_election_info", false);
25  	include_election_info_with_votes = options_a.get<bool> ("include_election_info_with_votes", false);
26  	include_sideband_info = options_a.get<bool> ("include_sideband_info", false);
27  	confirmation_types = 0;
28  	auto type_l (options_a.get<std::string> ("confirmation_type", "all"));
29  	if (boost::iequals (type_l, "active"))
30  	{
31  		confirmation_types = type_all_active;
32  	}
33  	else if (boost::iequals (type_l, "active_quorum"))
34  	{
35  		confirmation_types = type_active_quorum;
36  	}
37  	else if (boost::iequals (type_l, "active_confirmation_height"))
38  	{
39  		confirmation_types = type_active_confirmation_height;
40  	}
41  	else if (boost::iequals (type_l, "inactive"))
42  	{
43  		confirmation_types = type_inactive;
44  	}
45  	else
46  	{
47  		confirmation_types = type_all;
48  	}
49  	auto all_local_accounts_l (options_a.get_optional<bool> ("all_local_accounts"));
50  	if (all_local_accounts_l.is_initialized ())
51  	{
52  		all_local_accounts = all_local_accounts_l.get ();
53  		has_account_filtering_options = true;
54  		if (!include_block)
55  		{
56  			logger_a.always_log ("Websocket: Filtering option \"all_local_accounts\" requires that \"include_block\" is set to true to be effective");
57  		}
58  	}
59  	auto accounts_l (options_a.get_child_optional ("accounts"));
60  	if (accounts_l)
61  	{
62  		has_account_filtering_options = true;
63  		for (auto account_l : *accounts_l)
64  		{
65  			nano::account result_l{};
66  			if (!result_l.decode_account (account_l.second.data ()))
67  			{
68  				accounts.insert (result_l.to_account ());
69  			}
70  			else
71  			{
72  				logger_a.always_log ("Websocket: invalid account provided for filtering blocks: ", account_l.second.data ());
73  			}
74  		}
75  		if (!include_block)
76  		{
77  			logger_a.always_log ("Websocket: Filtering option \"accounts\" requires that \"include_block\" is set to true to be effective");
78  		}
79  	}
80  	check_filter_empty ();
81  }
82  bool nano::websocket::confirmation_options::should_filter (nano::websocket::message const & message_a) const
83  {
84  	bool should_filter_conf_type_l (true);
85  	auto type_text_l (message_a.contents.get<std::string> ("message.confirmation_type"));
86  	if (type_text_l == "active_quorum" && confirmation_types & type_active_quorum)
87  	{
88  		should_filter_conf_type_l = false;
89  	}
90  	else if (type_text_l == "active_confirmation_height" && confirmation_types & type_active_confirmation_height)
91  	{
92  		should_filter_conf_type_l = false;
93  	}
94  	else if (type_text_l == "inactive" && confirmation_types & type_inactive)
95  	{
96  		should_filter_conf_type_l = false;
97  	}
98  	bool should_filter_account (has_account_filtering_options);
99  	auto destination_opt_l (message_a.contents.get_optional<std::string> ("message.block.link_as_account"));
100  	if (destination_opt_l)
101  	{
102  		auto source_text_l (message_a.contents.get<std::string> ("message.account"));
103  		if (all_local_accounts)
104  		{
105  			auto transaction_l (wallets.tx_begin_read ());
106  			nano::account source_l{};
107  			nano::account destination_l{};
108  			auto decode_source_ok_l (!source_l.decode_account (source_text_l));
109  			auto decode_destination_ok_l (!destination_l.decode_account (destination_opt_l.get ()));
110  			(void)decode_source_ok_l;
111  			(void)decode_destination_ok_l;
112  			debug_assert (decode_source_ok_l && decode_destination_ok_l);
113  			if (wallets.exists (transaction_l, source_l) || wallets.exists (transaction_l, destination_l))
114  			{
115  				should_filter_account = false;
116  			}
117  		}
118  		if (accounts.find (source_text_l) != accounts.end () || accounts.find (destination_opt_l.get ()) != accounts.end ())
119  		{
120  			should_filter_account = false;
121  		}
122  	}
123  	return should_filter_conf_type_l || should_filter_account;
124  }
125  bool nano::websocket::confirmation_options::update (boost::property_tree::ptree const & options_a)
126  {
127  	auto update_accounts = [this] (boost::property_tree::ptree const & accounts_text_a, bool insert_a) {
128  		this->has_account_filtering_options = true;
129  		for (auto const & account_l : accounts_text_a)
130  		{
131  			nano::account result_l{};
132  			if (!result_l.decode_account (account_l.second.data ()))
133  			{
134  				auto encoded_l (result_l.to_account ());
135  				if (insert_a)
136  				{
137  					this->accounts.insert (encoded_l);
138  				}
139  				else
140  				{
141  					this->accounts.erase (encoded_l);
142  				}
143  			}
144  			else if (this->logger.is_initialized ())
145  			{
146  				this->logger->always_log ("Websocket: invalid account provided for filtering blocks: ", account_l.second.data ());
147  			}
148  		}
149  	};
150  	auto accounts_add_l (options_a.get_child_optional ("accounts_add"));
151  	if (accounts_add_l)
152  	{
153  		update_accounts (*accounts_add_l, true);
154  	}
155  	auto accounts_del_l (options_a.get_child_optional ("accounts_del"));
156  	if (accounts_del_l)
157  	{
158  		update_accounts (*accounts_del_l, false);
159  	}
160  	check_filter_empty ();
161  	return false;
162  }
163  void nano::websocket::confirmation_options::check_filter_empty () const
164  {
165  	if (logger.is_initialized () && has_account_filtering_options && !all_local_accounts && accounts.empty ())
166  	{
167  		logger->always_log ("Websocket: provided options resulted in an empty block confirmation filter");
168  	}
169  }
170  nano::websocket::vote_options::vote_options (boost::property_tree::ptree const & options_a, nano::logger_mt & logger_a)
171  {
172  	include_replays = options_a.get<bool> ("include_replays", false);
173  	include_indeterminate = options_a.get<bool> ("include_indeterminate", false);
174  	auto representatives_l (options_a.get_child_optional ("representatives"));
175  	if (representatives_l)
176  	{
177  		for (auto representative_l : *representatives_l)
178  		{
179  			nano::account result_l{};
180  			if (!result_l.decode_account (representative_l.second.data ()))
181  			{
182  				representatives.insert (result_l.to_account ());
183  			}
184  			else
185  			{
186  				logger_a.always_log ("Websocket: invalid account given to filter votes: ", representative_l.second.data ());
187  			}
188  		}
189  		if (representatives.empty ())
190  		{
191  			logger_a.always_log ("Websocket: account filter for votes is empty, no messages will be filtered");
192  		}
193  	}
194  }
195  bool nano::websocket::vote_options::should_filter (nano::websocket::message const & message_a) const
196  {
197  	auto type (message_a.contents.get<std::string> ("message.type"));
198  	bool should_filter_l = (!include_replays && type == "replay") || (!include_indeterminate && type == "indeterminate");
199  	if (!should_filter_l && !representatives.empty ())
200  	{
201  		auto representative_text_l (message_a.contents.get<std::string> ("message.account"));
202  		if (representatives.find (representative_text_l) == representatives.end ())
203  		{
204  			should_filter_l = true;
205  		}
206  	}
207  	return should_filter_l;
208  }
209  #ifdef NANO_SECURE_RPC
210  nano::websocket::session::session (nano::websocket::listener & listener_a, socket_type socket_a, boost::asio::ssl::context & ctx_a) :
211  	ws_listener (listener_a), ws (std::move (socket_a), ctx_a)
212  {
213  	ws_listener.get_logger ().try_log ("Websocket: secure session started");
214  }
215  #endif
216  nano::websocket::session::session (nano::websocket::listener & listener_a, socket_type socket_a) :
217  	ws_listener (listener_a), ws (std::move (socket_a))
218  {
219  	ws_listener.get_logger ().try_log ("Websocket: session started");
220  }
221  nano::websocket::session::~session ()
222  {
223  	{
224  		nano::unique_lock<nano::mutex> lk (subscriptions_mutex);
225  		for (auto & subscription : subscriptions)
226  		{
227  			ws_listener.decrease_subscriber_count (subscription.first);
228  		}
229  	}
230  }
231  void nano::websocket::session::handshake ()
232  {
233  	auto this_l (shared_from_this ());
234  	ws.handshake ([this_l] (boost::system::error_code const & ec) {
235  		if (!ec)
236  		{
237  			this_l->read ();
238  		}
239  		else
240  		{
241  			this_l->ws_listener.get_logger ().always_log ("Websocket: handshake failed: ", ec.message ());
242  		}
243  	});
244  }
245  void nano::websocket::session::close ()
246  {
247  	ws_listener.get_logger ().try_log ("Websocket: session closing");
248  	auto this_l (shared_from_this ());
249  	boost::asio::dispatch (ws.get_strand (),
250  	[this_l] () {
251  		boost::beast::websocket::close_reason reason;
252  		reason.code = boost::beast::websocket::close_code::normal;
253  		reason.reason = "Shutting down";
254  		boost::system::error_code ec_ignore;
255  		this_l->ws.close (reason, ec_ignore);
256  	});
257  }
258  void nano::websocket::session::write (nano::websocket::message message_a)
259  {
260  	nano::unique_lock<nano::mutex> lk (subscriptions_mutex);
261  	auto subscription (subscriptions.find (message_a.topic));
262  	if (message_a.topic == nano::websocket::topic::ack || (subscription != subscriptions.end () && !subscription->second->should_filter (message_a)))
263  	{
264  		lk.unlock ();
265  		auto this_l (shared_from_this ());
266  		boost::asio::post (ws.get_strand (),
267  		[message_a, this_l] () {
268  			bool write_in_progress = !this_l->send_queue.empty ();
269  			this_l->send_queue.emplace_back (message_a);
270  			if (!write_in_progress)
271  			{
272  				this_l->write_queued_messages ();
273  			}
274  		});
275  	}
276  }
277  void nano::websocket::session::write_queued_messages ()
278  {
279  	auto msg (send_queue.front ().to_string ());
280  	auto this_l (shared_from_this ());
281  	ws.async_write (nano::shared_const_buffer (msg),
282  	[this_l] (boost::system::error_code ec, std::size_t bytes_transferred) {
283  		this_l->send_queue.pop_front ();
284  		if (!ec)
285  		{
286  			if (!this_l->send_queue.empty ())
287  			{
288  				this_l->write_queued_messages ();
289  			}
290  		}
291  	});
292  }
293  void nano::websocket::session::read ()
294  {
295  	auto this_l (shared_from_this ());
296  	boost::asio::post (ws.get_strand (), [this_l] () {
297  		this_l->ws.async_read (this_l->read_buffer,
298  		[this_l] (boost::system::error_code ec, std::size_t bytes_transferred) {
299  			if (!ec)
300  			{
301  				std::stringstream os;
302  				os << beast_buffers (this_l->read_buffer.data ());
303  				std::string incoming_message = os.str ();
304  				this_l->read_buffer.consume (this_l->read_buffer.size ());
305  				boost::property_tree::ptree tree_msg;
306  				try
307  				{
308  					boost::property_tree::read_json (os, tree_msg);
309  					this_l->handle_message (tree_msg);
310  					this_l->read ();
311  				}
312  				catch (boost::property_tree::json_parser::json_parser_error const & ex)
313  				{
314  					this_l->ws_listener.get_logger ().try_log ("Websocket: json parsing failed: ", ex.what ());
315  				}
316  			}
317  			else if (ec != boost::asio::error::eof)
318  			{
319  				this_l->ws_listener.get_logger ().try_log ("Websocket: read failed: ", ec.message ());
320  			}
321  		});
322  	});
323  }
324  namespace
325  {
326  nano::websocket::topic to_topic (std::string const & topic_a)
327  {
328  	nano::websocket::topic topic = nano::websocket::topic::invalid;
329  	if (topic_a == "confirmation")
330  	{
331  		topic = nano::websocket::topic::confirmation;
332  	}
333  	else if (topic_a == "started_election")
334  	{
335  		topic = nano::websocket::topic::started_election;
336  	}
337  	else if (topic_a == "stopped_election")
338  	{
339  		topic = nano::websocket::topic::stopped_election;
340  	}
341  	else if (topic_a == "vote")
342  	{
343  		topic = nano::websocket::topic::vote;
344  	}
345  	else if (topic_a == "ack")
346  	{
347  		topic = nano::websocket::topic::ack;
348  	}
349  	else if (topic_a == "work")
350  	{
351  		topic = nano::websocket::topic::work;
352  	}
353  	else if (topic_a == "bootstrap")
354  	{
355  		topic = nano::websocket::topic::bootstrap;
356  	}
357  	else if (topic_a == "telemetry")
358  	{
359  		topic = nano::websocket::topic::telemetry;
360  	}
361  	else if (topic_a == "new_unconfirmed_block")
362  	{
363  		topic = nano::websocket::topic::new_unconfirmed_block;
364  	}
365  	return topic;
366  }
367  std::string from_topic (nano::websocket::topic topic_a)
368  {
369  	std::string topic = "invalid";
370  	if (topic_a == nano::websocket::topic::confirmation)
371  	{
372  		topic = "confirmation";
373  	}
374  	else if (topic_a == nano::websocket::topic::started_election)
375  	{
376  		topic = "started_election";
377  	}
378  	else if (topic_a == nano::websocket::topic::stopped_election)
379  	{
380  		topic = "stopped_election";
381  	}
382  	else if (topic_a == nano::websocket::topic::vote)
383  	{
384  		topic = "vote";
385  	}
386  	else if (topic_a == nano::websocket::topic::ack)
387  	{
388  		topic = "ack";
389  	}
390  	else if (topic_a == nano::websocket::topic::work)
391  	{
392  		topic = "work";
393  	}
394  	else if (topic_a == nano::websocket::topic::bootstrap)
395  	{
396  		topic = "bootstrap";
397  	}
398  	else if (topic_a == nano::websocket::topic::telemetry)
399  	{
400  		topic = "telemetry";
401  	}
402  	else if (topic_a == nano::websocket::topic::new_unconfirmed_block)
403  	{
404  		topic = "new_unconfirmed_block";
405  	}
406  	return topic;
407  }
408  }
409  void nano::websocket::session::send_ack (std::string action_a, std::string id_a)
410  {
411  	nano::websocket::message msg (nano::websocket::topic::ack);
412  	boost::property_tree::ptree & message_l = msg.contents;
413  	message_l.add ("ack", action_a);
414  	message_l.add ("time", std::to_string (nano::milliseconds_since_epoch ()));
415  	if (!id_a.empty ())
416  	{
417  		message_l.add ("id", id_a);
418  	}
419  	write (msg);
420  }
421  void nano::websocket::session::handle_message (boost::property_tree::ptree const & message_a)
422  {
423  	std::string action (message_a.get<std::string> ("action", ""));
424  	auto topic_l (to_topic (message_a.get<std::string> ("topic", "")));
425  	auto ack_l (message_a.get<bool> ("ack", false));
426  	auto id_l (message_a.get<std::string> ("id", ""));
427  	auto action_succeeded (false);
428  	if (action == "subscribe" && topic_l != nano::websocket::topic::invalid)
429  	{
430  		auto options_text_l (message_a.get_child_optional ("options"));
431  		nano::lock_guard<nano::mutex> lk (subscriptions_mutex);
432  		std::unique_ptr<nano::websocket::options> options_l{ nullptr };
433  		if (options_text_l && topic_l == nano::websocket::topic::confirmation)
434  		{
435  			options_l = std::make_unique<nano::websocket::confirmation_options> (options_text_l.get (), ws_listener.get_wallets (), ws_listener.get_logger ());
436  		}
437  		else if (options_text_l && topic_l == nano::websocket::topic::vote)
438  		{
439  			options_l = std::make_unique<nano::websocket::vote_options> (options_text_l.get (), ws_listener.get_logger ());
440  		}
441  		else
442  		{
443  			options_l = std::make_unique<nano::websocket::options> ();
444  		}
445  		auto existing (subscriptions.find (topic_l));
446  		if (existing != subscriptions.end ())
447  		{
448  			existing->second = std::move (options_l);
449  			ws_listener.get_logger ().always_log ("Websocket: updated subscription to topic: ", from_topic (topic_l));
450  		}
451  		else
452  		{
453  			subscriptions.emplace (topic_l, std::move (options_l));
454  			ws_listener.get_logger ().always_log ("Websocket: new subscription to topic: ", from_topic (topic_l));
455  			ws_listener.increase_subscriber_count (topic_l);
456  		}
457  		action_succeeded = true;
458  	}
459  	else if (action == "update")
460  	{
461  		nano::lock_guard<nano::mutex> lk (subscriptions_mutex);
462  		auto existing (subscriptions.find (topic_l));
463  		if (existing != subscriptions.end ())
464  		{
465  			auto options_text_l (message_a.get_child_optional ("options"));
466  			if (options_text_l.is_initialized () && !existing->second->update (*options_text_l))
467  			{
468  				action_succeeded = true;
469  			}
470  		}
471  	}
472  	else if (action == "unsubscribe" && topic_l != nano::websocket::topic::invalid)
473  	{
474  		nano::lock_guard<nano::mutex> lk (subscriptions_mutex);
475  		if (subscriptions.erase (topic_l))
476  		{
477  			ws_listener.get_logger ().always_log ("Websocket: removed subscription to topic: ", from_topic (topic_l));
478  			ws_listener.decrease_subscriber_count (topic_l);
479  		}
480  		action_succeeded = true;
481  	}
482  	else if (action == "ping")
483  	{
484  		action_succeeded = true;
485  		ack_l = "true";
486  		action = "pong";
487  	}
488  	if (ack_l && action_succeeded)
489  	{
490  		send_ack (action, id_l);
491  	}
492  }
493  void nano::websocket::listener::stop ()
494  {
495  	stopped = true;
496  	acceptor.close ();
497  	nano::lock_guard<nano::mutex> lk (sessions_mutex);
498  	for (auto & weak_session : sessions)
499  	{
500  		auto session_ptr (weak_session.lock ());
501  		if (session_ptr)
502  		{
503  			session_ptr->close ();
504  		}
505  	}
506  	sessions.clear ();
507  }
508  nano::websocket::listener::listener (std::shared_ptr<nano::tls_config> const & tls_config_a, nano::logger_mt & logger_a, nano::wallets & wallets_a, boost::asio::io_context & io_ctx_a, boost::asio::ip::tcp::endpoint endpoint_a) :
509  	tls_config (tls_config_a),
510  	logger (logger_a),
511  	wallets (wallets_a),
512  	acceptor (io_ctx_a),
513  	socket (io_ctx_a)
514  {
515  	try
516  	{
517  		for (std::atomic<std::size_t> & item : topic_subscriber_count)
518  		{
519  			item = std::size_t (0);
520  		}
521  		acceptor.open (endpoint_a.protocol ());
522  		acceptor.set_option (boost::asio::socket_base::reuse_address (true));
523  		acceptor.bind (endpoint_a);
524  		acceptor.listen (boost::asio::socket_base::max_listen_connections);
525  	}
526  	catch (std::exception const & ex)
527  	{
528  		logger.always_log ("Websocket: listen failed: ", ex.what ());
529  	}
530  }
531  void nano::websocket::listener::run ()
532  {
533  	if (acceptor.is_open ())
534  	{
535  		accept ();
536  	}
537  }
538  void nano::websocket::listener::accept ()
539  {
540  	auto this_l (shared_from_this ());
541  	acceptor.async_accept (socket,
542  	[this_l] (boost::system::error_code const & ec) {
543  		this_l->on_accept (ec);
544  	});
545  }
546  void nano::websocket::listener::on_accept (boost::system::error_code ec)
547  {
548  	if (ec)
549  	{
550  		logger.always_log ("Websocket: accept failed: ", ec.message ());
551  	}
552  	else
553  	{
554  		std::shared_ptr<nano::websocket::session> session;
555  		if (tls_config && tls_config->enable_wss)
556  		{
557  #ifdef NANO_SECURE_RPC
558  			session = std::make_shared<nano::websocket::session> (*this, std::move (socket), tls_config->ssl_context);
559  #endif
560  		}
561  		else
562  		{
563  			session = std::make_shared<nano::websocket::session> (*this, std::move (socket));
564  		}
565  		sessions_mutex.lock ();
566  		sessions.push_back (session);
<span onclick='openModal()' class='match'>567  		sessions.erase (std::remove_if (sessions.begin (), sessions.end (), [] (auto & elem) { return elem.expired (); }), sessions.end ());
568  		sessions_mutex.unlock ();
569  		session->handshake ();
570  	}
571  	if (!stopped)
572  	{
573  		accept ();
574  	}
575  }
576  void nano::websocket::listener::broadcast_confirmation (std::shared_ptr<nano::block> const & block_a, nano::account const & account_a, nano::amount const & amount_a, std::string const & subtype, nano::election_status const & election_status_a, std::vector<nano::vote_with_weight_info> const & election_votes_a)
</span>577  {
578  	nano::websocket::message_builder builder;
579  	nano::lock_guard<nano::mutex> lk (sessions_mutex);
580  	boost::optional<nano::websocket::message> msg_with_block;
581  	boost::optional<nano::websocket::message> msg_without_block;
582  	for (auto & weak_session : sessions)
583  	{
584  		auto session_ptr (weak_session.lock ());
585  		if (session_ptr)
586  		{
587  			auto subscription (session_ptr->subscriptions.find (nano::websocket::topic::confirmation));
588  			if (subscription != session_ptr->subscriptions.end ())
589  			{
590  				nano::websocket::confirmation_options default_options (wallets);
591  				auto conf_options (dynamic_cast<nano::websocket::confirmation_options *> (subscription->second.get ()));
592  				if (conf_options == nullptr)
593  				{
594  					conf_options = &default_options;
595  				}
596  				auto include_block (conf_options == nullptr ? true : conf_options->get_include_block ());
597  				if (include_block && !msg_with_block)
598  				{
599  					msg_with_block = builder.block_confirmed (block_a, account_a, amount_a, subtype, include_block, election_status_a, election_votes_a, *conf_options);
600  				}
601  				else if (!include_block && !msg_without_block)
602  				{
603  					msg_without_block = builder.block_confirmed (block_a, account_a, amount_a, subtype, include_block, election_status_a, election_votes_a, *conf_options);
604  				}
605  				session_ptr->write (include_block ? msg_with_block.get () : msg_without_block.get ());
606  			}
607  		}
608  	}
609  }
610  void nano::websocket::listener::broadcast (nano::websocket::message message_a)
611  {
612  	nano::lock_guard<nano::mutex> lk (sessions_mutex);
613  	for (auto & weak_session : sessions)
614  	{
615  		auto session_ptr (weak_session.lock ());
616  		if (session_ptr)
617  		{
618  			session_ptr->write (message_a);
619  		}
620  	}
621  }
622  void nano::websocket::listener::increase_subscriber_count (nano::websocket::topic const & topic_a)
623  {
624  	topic_subscriber_count[static_cast<std::size_t> (topic_a)] += 1;
625  }
626  void nano::websocket::listener::decrease_subscriber_count (nano::websocket::topic const & topic_a)
627  {
628  	auto & count (topic_subscriber_count[static_cast<std::size_t> (topic_a)]);
629  	release_assert (count > 0);
630  	count -= 1;
631  }
632  nano::websocket::message nano::websocket::message_builder::started_election (nano::block_hash const & hash_a)
633  {
634  	nano::websocket::message message_l (nano::websocket::topic::started_election);
635  	set_common_fields (message_l);
636  	boost::property_tree::ptree message_node_l;
637  	message_node_l.add ("hash", hash_a.to_string ());
638  	message_l.contents.add_child ("message", message_node_l);
639  	return message_l;
640  }
641  nano::websocket::message nano::websocket::message_builder::stopped_election (nano::block_hash const & hash_a)
642  {
643  	nano::websocket::message message_l (nano::websocket::topic::stopped_election);
644  	set_common_fields (message_l);
645  	boost::property_tree::ptree message_node_l;
646  	message_node_l.add ("hash", hash_a.to_string ());
647  	message_l.contents.add_child ("message", message_node_l);
648  	return message_l;
649  }
650  nano::websocket::message nano::websocket::message_builder::block_confirmed (std::shared_ptr<nano::block> const & block_a, nano::account const & account_a, nano::amount const & amount_a, std::string subtype, bool include_block_a, nano::election_status const & election_status_a, std::vector<nano::vote_with_weight_info> const & election_votes_a, nano::websocket::confirmation_options const & options_a)
651  {
652  	nano::websocket::message message_l (nano::websocket::topic::confirmation);
653  	set_common_fields (message_l);
654  	boost::property_tree::ptree message_node_l;
655  	message_node_l.add ("account", account_a.to_account ());
656  	message_node_l.add ("amount", amount_a.to_string_dec ());
657  	message_node_l.add ("hash", block_a->hash ().to_string ());
658  	std::string confirmation_type = "unknown";
659  	switch (election_status_a.type)
660  	{
661  		case nano::election_status_type::active_confirmed_quorum:
662  			confirmation_type = "active_quorum";
663  			break;
664  		case nano::election_status_type::active_confirmation_height:
665  			confirmation_type = "active_confirmation_height";
666  			break;
667  		case nano::election_status_type::inactive_confirmation_height:
668  			confirmation_type = "inactive";
669  			break;
670  		default:
671  			break;
672  	};
673  	message_node_l.add ("confirmation_type", confirmation_type);
674  	if (options_a.get_include_election_info () || options_a.get_include_election_info_with_votes ())
675  	{
676  		boost::property_tree::ptree election_node_l;
677  		election_node_l.add ("duration", election_status_a.election_duration.count ());
678  		election_node_l.add ("time", election_status_a.election_end.count ());
679  		election_node_l.add ("tally", election_status_a.tally.to_string_dec ());
680  		election_node_l.add ("final", election_status_a.final_tally.to_string_dec ());
681  		election_node_l.add ("blocks", std::to_string (election_status_a.block_count));
682  		election_node_l.add ("voters", std::to_string (election_status_a.voter_count));
683  		election_node_l.add ("request_count", std::to_string (election_status_a.confirmation_request_count));
684  		if (options_a.get_include_election_info_with_votes ())
685  		{
686  			boost::property_tree::ptree election_votes_l;
687  			for (auto const & vote_l : election_votes_a)
688  			{
689  				boost::property_tree::ptree entry;
690  				entry.put ("representative", vote_l.representative.to_account ());
691  				entry.put ("timestamp", vote_l.timestamp);
692  				entry.put ("hash", vote_l.hash.to_string ());
693  				entry.put ("weight", vote_l.weight.convert_to<std::string> ());
694  				election_votes_l.push_back (std::make_pair ("", entry));
695  			}
696  			election_node_l.add_child ("votes", election_votes_l);
697  		}
698  		message_node_l.add_child ("election_info", election_node_l);
699  	}
700  	if (include_block_a)
701  	{
702  		boost::property_tree::ptree block_node_l;
703  		block_a->serialize_json (block_node_l);
704  		if (!subtype.empty ())
705  		{
706  			block_node_l.add ("subtype", subtype);
707  		}
708  		message_node_l.add_child ("block", block_node_l);
709  	}
710  	if (options_a.get_include_sideband_info ())
711  	{
712  		boost::property_tree::ptree sideband_node_l;
713  		sideband_node_l.add ("height", std::to_string (block_a->sideband ().height));
714  		sideband_node_l.add ("local_timestamp", std::to_string (block_a->sideband ().timestamp));
715  		message_node_l.add_child ("sideband", sideband_node_l);
716  	}
717  	message_l.contents.add_child ("message", message_node_l);
718  	return message_l;
719  }
720  nano::websocket::message nano::websocket::message_builder::vote_received (std::shared_ptr<nano::vote> const & vote_a, nano::vote_code code_a)
721  {
722  	nano::websocket::message message_l (nano::websocket::topic::vote);
723  	set_common_fields (message_l);
724  	boost::property_tree::ptree vote_node_l;
725  	vote_a->serialize_json (vote_node_l);
726  	std::string vote_type = "invalid";
727  	switch (code_a)
728  	{
729  		case nano::vote_code::vote:
730  			vote_type = "vote";
731  			break;
732  		case nano::vote_code::replay:
733  			vote_type = "replay";
734  			break;
735  		case nano::vote_code::indeterminate:
736  			vote_type = "indeterminate";
737  			break;
738  		case nano::vote_code::invalid:
739  			debug_assert (false);
740  			break;
741  	}
742  	vote_node_l.put ("type", vote_type);
743  	message_l.contents.add_child ("message", vote_node_l);
744  	return message_l;
745  }
746  nano::websocket::message nano::websocket::message_builder::work_generation (nano::work_version const version_a, nano::block_hash const & root_a, uint64_t work_a, uint64_t difficulty_a, uint64_t publish_threshold_a, std::chrono::milliseconds const & duration_a, std::string const & peer_a, std::vector<std::string> const & bad_peers_a, bool completed_a, bool cancelled_a)
747  {
748  	nano::websocket::message message_l (nano::websocket::topic::work);
749  	set_common_fields (message_l);
750  	boost::property_tree::ptree work_l;
751  	work_l.put ("success", completed_a ? "true" : "false");
752  	work_l.put ("reason", completed_a ? "" : cancelled_a ? "cancelled"
753  														 : "failure");
754  	work_l.put ("duration", duration_a.count ());
755  	boost::property_tree::ptree request_l;
756  	request_l.put ("version", nano::to_string (version_a));
757  	request_l.put ("hash", root_a.to_string ());
758  	request_l.put ("difficulty", nano::to_string_hex (difficulty_a));
759  	auto request_multiplier_l (nano::difficulty::to_multiplier (difficulty_a, publish_threshold_a));
760  	request_l.put ("multiplier", nano::to_string (request_multiplier_l));
761  	work_l.add_child ("request", request_l);
762  	if (completed_a)
763  	{
764  		boost::property_tree::ptree result_l;
765  		result_l.put ("source", peer_a);
766  		result_l.put ("work", nano::to_string_hex (work_a));
767  		auto result_difficulty_l (nano::dev::network_params.work.difficulty (version_a, root_a, work_a));
768  		result_l.put ("difficulty", nano::to_string_hex (result_difficulty_l));
769  		auto result_multiplier_l (nano::difficulty::to_multiplier (result_difficulty_l, publish_threshold_a));
770  		result_l.put ("multiplier", nano::to_string (result_multiplier_l));
771  		work_l.add_child ("result", result_l);
772  	}
773  	boost::property_tree::ptree bad_peers_l;
774  	for (auto & peer_text : bad_peers_a)
775  	{
776  		boost::property_tree::ptree entry;
777  		entry.put ("", peer_text);
778  		bad_peers_l.push_back (std::make_pair ("", entry));
779  	}
780  	work_l.add_child ("bad_peers", bad_peers_l);
781  	message_l.contents.add_child ("message", work_l);
782  	return message_l;
783  }
784  nano::websocket::message nano::websocket::message_builder::work_cancelled (nano::work_version const version_a, nano::block_hash const & root_a, uint64_t const difficulty_a, uint64_t const publish_threshold_a, std::chrono::milliseconds const & duration_a, std::vector<std::string> const & bad_peers_a)
785  {
786  	return work_generation (version_a, root_a, 0, difficulty_a, publish_threshold_a, duration_a, "", bad_peers_a, false, true);
787  }
788  nano::websocket::message nano::websocket::message_builder::work_failed (nano::work_version const version_a, nano::block_hash const & root_a, uint64_t const difficulty_a, uint64_t const publish_threshold_a, std::chrono::milliseconds const & duration_a, std::vector<std::string> const & bad_peers_a)
789  {
790  	return work_generation (version_a, root_a, 0, difficulty_a, publish_threshold_a, duration_a, "", bad_peers_a, false, false);
791  }
792  nano::websocket::message nano::websocket::message_builder::bootstrap_started (std::string const & id_a, std::string const & mode_a)
793  {
794  	nano::websocket::message message_l (nano::websocket::topic::bootstrap);
795  	set_common_fields (message_l);
796  	boost::property_tree::ptree bootstrap_l;
797  	bootstrap_l.put ("reason", "started");
798  	bootstrap_l.put ("id", id_a);
799  	bootstrap_l.put ("mode", mode_a);
800  	message_l.contents.add_child ("message", bootstrap_l);
801  	return message_l;
802  }
803  nano::websocket::message nano::websocket::message_builder::bootstrap_exited (std::string const & id_a, std::string const & mode_a, std::chrono::steady_clock::time_point const start_time_a, uint64_t const total_blocks_a)
804  {
805  	nano::websocket::message message_l (nano::websocket::topic::bootstrap);
806  	set_common_fields (message_l);
807  	boost::property_tree::ptree bootstrap_l;
808  	bootstrap_l.put ("reason", "exited");
809  	bootstrap_l.put ("id", id_a);
810  	bootstrap_l.put ("mode", mode_a);
811  	bootstrap_l.put ("total_blocks", total_blocks_a);
812  	bootstrap_l.put ("duration", std::chrono::duration_cast<std::chrono::seconds> (std::chrono::steady_clock::now () - start_time_a).count ());
813  	message_l.contents.add_child ("message", bootstrap_l);
814  	return message_l;
815  }
816  nano::websocket::message nano::websocket::message_builder::telemetry_received (nano::telemetry_data const & telemetry_data_a, nano::endpoint const & endpoint_a)
817  {
818  	nano::websocket::message message_l (nano::websocket::topic::telemetry);
819  	set_common_fields (message_l);
820  	nano::jsonconfig telemetry_l;
821  	telemetry_data_a.serialize_json (telemetry_l, false);
822  	telemetry_l.put ("address", endpoint_a.address ());
823  	telemetry_l.put ("port", endpoint_a.port ());
824  	message_l.contents.add_child ("message", telemetry_l.get_tree ());
825  	return message_l;
826  }
827  nano::websocket::message nano::websocket::message_builder::new_block_arrived (nano::block const & block_a)
828  {
829  	nano::websocket::message message_l (nano::websocket::topic::new_unconfirmed_block);
830  	set_common_fields (message_l);
831  	boost::property_tree::ptree block_l;
832  	block_a.serialize_json (block_l);
833  	auto subtype (nano::state_subtype (block_a.sideband ().details));
834  	block_l.put ("subtype", subtype);
835  	message_l.contents.add_child ("message", block_l);
836  	return message_l;
837  }
838  void nano::websocket::message_builder::set_common_fields (nano::websocket::message & message_a)
839  {
840  	message_a.contents.add ("topic", from_topic (message_a.topic));
841  	message_a.contents.add ("time", std::to_string (nano::milliseconds_since_epoch ()));
842  }
843  std::string nano::websocket::message::to_string () const
844  {
845  	std::ostringstream ostream;
846  	boost::property_tree::write_json (ostream, contents);
847  	ostream.flush ();
848  	return ostream.str ();
849  }
850  nano::websocket_server::websocket_server (nano::websocket::config & config_a, nano::node_observers & observers_a, nano::wallets & wallets_a, nano::ledger & ledger_a, boost::asio::io_context & io_ctx_a, nano::logger_mt & logger_a) :
851  	config{ config_a },
852  	observers{ observers_a },
853  	wallets{ wallets_a },
854  	ledger{ ledger_a },
855  	io_ctx{ io_ctx_a },
856  	logger{ logger_a }
857  {
858  	if (!config.enabled)
859  	{
860  		return;
861  	}
862  	auto endpoint = nano::tcp_endpoint{ boost::asio::ip::make_address_v6 (config.address), config.port };
863  	server = std::make_shared<nano::websocket::listener> (config.tls_config, logger, wallets, io_ctx, endpoint);
864  	observers.blocks.add ([this] (nano::election_status const & status_a, std::vector<nano::vote_with_weight_info> const & votes_a, nano::account const & account_a, nano::amount const & amount_a, bool is_state_send_a, bool is_state_epoch_a) {
865  		debug_assert (status_a.type != nano::election_status_type::ongoing);
866  		if (server->any_subscriber (nano::websocket::topic::confirmation))
867  		{
868  			auto block_a = status_a.winner;
869  			std::string subtype;
870  			if (is_state_send_a)
871  			{
872  				subtype = "send";
873  			}
874  			else if (block_a->type () == nano::block_type::state)
875  			{
876  				if (block_a->link ().is_zero ())
877  				{
878  					subtype = "change";
879  				}
880  				else if (is_state_epoch_a)
881  				{
882  					debug_assert (amount_a == 0 && ledger.is_epoch_link (block_a->link ()));
883  					subtype = "epoch";
884  				}
885  				else
886  				{
887  					subtype = "receive";
888  				}
889  			}
890  			server->broadcast_confirmation (block_a, account_a, amount_a, subtype, status_a, votes_a);
891  		}
892  	});
893  	observers.active_started.add ([this] (nano::block_hash const & hash_a) {
894  		if (server->any_subscriber (nano::websocket::topic::started_election))
895  		{
896  			nano::websocket::message_builder builder;
897  			server->broadcast (builder.started_election (hash_a));
898  		}
899  	});
900  	observers.active_stopped.add ([this] (nano::block_hash const & hash_a) {
901  		if (server->any_subscriber (nano::websocket::topic::stopped_election))
902  		{
903  			nano::websocket::message_builder builder;
904  			server->broadcast (builder.stopped_election (hash_a));
905  		}
906  	});
907  	observers.telemetry.add ([this] (nano::telemetry_data const & telemetry_data, std::shared_ptr<nano::transport::channel> const & channel) {
908  		if (server->any_subscriber (nano::websocket::topic::telemetry))
909  		{
910  			nano::websocket::message_builder builder;
911  			server->broadcast (builder.telemetry_received (telemetry_data, channel->get_endpoint ()));
912  		}
913  	});
914  	observers.vote.add ([this] (std::shared_ptr<nano::vote> vote_a, std::shared_ptr<nano::transport::channel> const & channel_a, nano::vote_code code_a) {
915  		if (server->any_subscriber (nano::websocket::topic::vote))
916  		{
917  			nano::websocket::message_builder builder;
918  			auto msg{ builder.vote_received (vote_a, code_a) };
919  			server->broadcast (msg);
920  		}
921  	});
922  }
923  void nano::websocket_server::start ()
924  {
925  	if (server)
926  	{
927  		server->run ();
928  	}
929  }
930  void nano::websocket_server::stop ()
931  {
932  	if (server)
933  	{
934  		server->stop ();
935  	}
936  }
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-intmatcher.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "intmatcher.h"
5  #include "classify.h"
6  #include "float2int.h"
7  #include "fontinfo.h"
8  #include "intproto.h"
9  #include "scrollview.h"
10  #include "shapetable.h"
11  #include "helpers.h"
12  #include <cassert>
13  #include <cmath>
14  namespace tesseract {
15  const float IntegerMatcher::kSEExponentialMultiplier = 0.0f;
16  const float IntegerMatcher::kSimilarityCenter = 0.0075f;
17  static const uint8_t offset_table[] = {
18      255, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2,
19      0,   1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0,
20      1,   0, 2, 0, 1, 0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1,
21      0,   3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0,
22      2,   0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4,
23      0,   1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0,
24      1,   0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1,
25      0,   2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0,
26      3,   0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0};
27  static const uint8_t next_table[] = {
28      0,    0,    0,    0x2,  0,    0x4,  0x4,  0x6,  0,    0x8,  0x8,  0x0a, 0x08, 0x0c, 0x0c, 0x0e,
29      0,    0x10, 0x10, 0x12, 0x10, 0x14, 0x14, 0x16, 0x10, 0x18, 0x18, 0x1a, 0x18, 0x1c, 0x1c, 0x1e,
30      0,    0x20, 0x20, 0x22, 0x20, 0x24, 0x24, 0x26, 0x20, 0x28, 0x28, 0x2a, 0x28, 0x2c, 0x2c, 0x2e,
31      0x20, 0x30, 0x30, 0x32, 0x30, 0x34, 0x34, 0x36, 0x30, 0x38, 0x38, 0x3a, 0x38, 0x3c, 0x3c, 0x3e,
32      0,    0x40, 0x40, 0x42, 0x40, 0x44, 0x44, 0x46, 0x40, 0x48, 0x48, 0x4a, 0x48, 0x4c, 0x4c, 0x4e,
33      0x40, 0x50, 0x50, 0x52, 0x50, 0x54, 0x54, 0x56, 0x50, 0x58, 0x58, 0x5a, 0x58, 0x5c, 0x5c, 0x5e,
34      0x40, 0x60, 0x60, 0x62, 0x60, 0x64, 0x64, 0x66, 0x60, 0x68, 0x68, 0x6a, 0x68, 0x6c, 0x6c, 0x6e,
35      0x60, 0x70, 0x70, 0x72, 0x70, 0x74, 0x74, 0x76, 0x70, 0x78, 0x78, 0x7a, 0x78, 0x7c, 0x7c, 0x7e,
36      0,    0x80, 0x80, 0x82, 0x80, 0x84, 0x84, 0x86, 0x80, 0x88, 0x88, 0x8a, 0x88, 0x8c, 0x8c, 0x8e,
37      0x80, 0x90, 0x90, 0x92, 0x90, 0x94, 0x94, 0x96, 0x90, 0x98, 0x98, 0x9a, 0x98, 0x9c, 0x9c, 0x9e,
38      0x80, 0xa0, 0xa0, 0xa2, 0xa0, 0xa4, 0xa4, 0xa6, 0xa0, 0xa8, 0xa8, 0xaa, 0xa8, 0xac, 0xac, 0xae,
39      0xa0, 0xb0, 0xb0, 0xb2, 0xb0, 0xb4, 0xb4, 0xb6, 0xb0, 0xb8, 0xb8, 0xba, 0xb8, 0xbc, 0xbc, 0xbe,
40      0x80, 0xc0, 0xc0, 0xc2, 0xc0, 0xc4, 0xc4, 0xc6, 0xc0, 0xc8, 0xc8, 0xca, 0xc8, 0xcc, 0xcc, 0xce,
41      0xc0, 0xd0, 0xd0, 0xd2, 0xd0, 0xd4, 0xd4, 0xd6, 0xd0, 0xd8, 0xd8, 0xda, 0xd8, 0xdc, 0xdc, 0xde,
42      0xc0, 0xe0, 0xe0, 0xe2, 0xe0, 0xe4, 0xe4, 0xe6, 0xe0, 0xe8, 0xe8, 0xea, 0xe8, 0xec, 0xec, 0xee,
43      0xe0, 0xf0, 0xf0, 0xf2, 0xf0, 0xf4, 0xf4, 0xf6, 0xf0, 0xf8, 0xf8, 0xfa, 0xf8, 0xfc, 0xfc, 0xfe};
44  static void HeapSort(int n, int ra[], int rb[]) {
45    int i, rra, rrb;
46    int l, j, ir;
47    l = (n >> 1) + 1;
48    ir = n;
49    for (;;) {
50      if (l > 1) {
51        rra = ra[--l];
52        rrb = rb[l];
53      } else {
54        rra = ra[ir];
55        rrb = rb[ir];
56        ra[ir] = ra[1];
57        rb[ir] = rb[1];
58        if (--ir == 1) {
59          ra[1] = rra;
60          rb[1] = rrb;
61          return;
62        }
63      }
64      i = l;
65      j = l << 1;
66      while (j <= ir) {
67        if (j < ir && ra[j] < ra[j + 1]) {
68          ++j;
69        }
70        if (rra < ra[j]) {
71          ra[i] = ra[j];
72          rb[i] = rb[j];
73          j += (i = j);
74        } else {
75          j = ir + 1;
76        }
77      }
78      ra[i] = rra;
79      rb[i] = rrb;
80    }
81  }
82  class ClassPruner {
83  public:
84    ClassPruner(int max_classes) {
85      max_classes_ = max_classes;
86      rounded_classes_ =
87          RoundUp(max_classes, WERDS_PER_CP_VECTOR * BITS_PER_WERD / NUM_BITS_PER_CLASS);
88      class_count_ = new int[rounded_classes_];
89      norm_count_ = new int[rounded_classes_];
90      sort_key_ = new int[rounded_classes_ + 1];
91      sort_index_ = new int[rounded_classes_ + 1];
92      for (int i = 0; i < rounded_classes_; i++) {
93        class_count_[i] = 0;
94      }
95      pruning_threshold_ = 0;
96      num_features_ = 0;
97      num_classes_ = 0;
98    }
99    ~ClassPruner() {
100      delete[] class_count_;
101      delete[] norm_count_;
102      delete[] sort_key_;
103      delete[] sort_index_;
104    }
105    void ComputeScores(const INT_TEMPLATES_STRUCT *int_templates, int num_features,
106                       const INT_FEATURE_STRUCT *features) {
107      num_features_ = num_features;
108      auto num_pruners = int_templates->NumClassPruners;
109      for (int f = 0; f < num_features; ++f) {
110        const INT_FEATURE_STRUCT *feature = &features[f];
111        int x = feature->X * NUM_CP_BUCKETS >> 8;
112        int y = feature->Y * NUM_CP_BUCKETS >> 8;
113        int theta = feature->Theta * NUM_CP_BUCKETS >> 8;
114        int class_id = 0;
115        for (unsigned pruner_set = 0; pruner_set < num_pruners; ++pruner_set) {
116          const uint32_t *pruner_word_ptr = int_templates->ClassPruners[pruner_set]->p[x][y][theta];
117          for (int word = 0; word < WERDS_PER_CP_VECTOR; ++word) {
118            uint32_t pruner_word = *pruner_word_ptr++;
119            class_count_[class_id++] += pruner_word & CLASS_PRUNER_CLASS_MASK;
120            pruner_word >>= NUM_BITS_PER_CLASS;
121            class_count_[class_id++] += pruner_word & CLASS_PRUNER_CLASS_MASK;
122            pruner_word >>= NUM_BITS_PER_CLASS;
123            class_count_[class_id++] += pruner_word & CLASS_PRUNER_CLASS_MASK;
124            pruner_word >>= NUM_BITS_PER_CLASS;
125            class_count_[class_id++] += pruner_word & CLASS_PRUNER_CLASS_MASK;
126            pruner_word >>= NUM_BITS_PER_CLASS;
127            class_count_[class_id++] += pruner_word & CLASS_PRUNER_CLASS_MASK;
128            pruner_word >>= NUM_BITS_PER_CLASS;
129            class_count_[class_id++] += pruner_word & CLASS_PRUNER_CLASS_MASK;
130            pruner_word >>= NUM_BITS_PER_CLASS;
131            class_count_[class_id++] += pruner_word & CLASS_PRUNER_CLASS_MASK;
132            pruner_word >>= NUM_BITS_PER_CLASS;
133            class_count_[class_id++] += pruner_word & CLASS_PRUNER_CLASS_MASK;
134            pruner_word >>= NUM_BITS_PER_CLASS;
135            class_count_[class_id++] += pruner_word & CLASS_PRUNER_CLASS_MASK;
136            pruner_word >>= NUM_BITS_PER_CLASS;
137            class_count_[class_id++] += pruner_word & CLASS_PRUNER_CLASS_MASK;
138            pruner_word >>= NUM_BITS_PER_CLASS;
139            class_count_[class_id++] += pruner_word & CLASS_PRUNER_CLASS_MASK;
140            pruner_word >>= NUM_BITS_PER_CLASS;
141            class_count_[class_id++] += pruner_word & CLASS_PRUNER_CLASS_MASK;
142            pruner_word >>= NUM_BITS_PER_CLASS;
143            class_count_[class_id++] += pruner_word & CLASS_PRUNER_CLASS_MASK;
144            pruner_word >>= NUM_BITS_PER_CLASS;
145            class_count_[class_id++] += pruner_word & CLASS_PRUNER_CLASS_MASK;
146            pruner_word >>= NUM_BITS_PER_CLASS;
147            class_count_[class_id++] += pruner_word & CLASS_PRUNER_CLASS_MASK;
148            pruner_word >>= NUM_BITS_PER_CLASS;
149            class_count_[class_id++] += pruner_word & CLASS_PRUNER_CLASS_MASK;
150          }
151        }
152      }
153    }
154    void AdjustForExpectedNumFeatures(const uint16_t *expected_num_features, int cutoff_strength) {
155      for (int class_id = 0; class_id < max_classes_; ++class_id) {
156        if (num_features_ < expected_num_features[class_id]) {
157          int deficit = expected_num_features[class_id] - num_features_;
158          class_count_[class_id] -=
159              class_count_[class_id] * deficit / (num_features_ * cutoff_strength + deficit);
160        }
161      }
162    }
163    void DisableDisabledClasses(const UNICHARSET &unicharset) {
164      for (int class_id = 0; class_id < max_classes_; ++class_id) {
165        if (!unicharset.get_enabled(class_id)) {
166          class_count_[class_id] = 0; 
167        }
168      }
169    }
170    void DisableFragments(const UNICHARSET &unicharset) {
171      for (int class_id = 0; class_id < max_classes_; ++class_id) {
172        if (unicharset.get_fragment(class_id)) {
173          class_count_[class_id] = 0;
174        }
175      }
176    }
177    void NormalizeForXheight(int norm_multiplier, const uint8_t *normalization_factors) {
178      for (int class_id = 0; class_id < max_classes_; class_id++) {
179        norm_count_[class_id] =
180            class_count_[class_id] - ((norm_multiplier * normalization_factors[class_id]) >> 8);
181      }
182    }
183    void NoNormalization() {
184      for (int class_id = 0; class_id < max_classes_; class_id++) {
185        norm_count_[class_id] = class_count_[class_id];
186      }
187    }
188    void PruneAndSort(int pruning_factor, int keep_this, bool max_of_non_fragments,
189                      const UNICHARSET &unicharset) {
190      int max_count = 0;
191      for (int c = 0; c < max_classes_; ++c) {
192        if (norm_count_[c] > max_count &&
193            (!max_of_non_fragments || !unicharset.get_fragment(c))) {
194          max_count = norm_count_[c];
195        }
196      }
197      pruning_threshold_ = (max_count * pruning_factor) >> 8;
198      if (pruning_threshold_ < 1) {
199        pruning_threshold_ = 1;
200      }
201      num_classes_ = 0;
202      for (int class_id = 0; class_id < max_classes_; class_id++) {
203        if (norm_count_[class_id] >= pruning_threshold_ || class_id == keep_this) {
204          ++num_classes_;
205          sort_index_[num_classes_] = class_id;
206          sort_key_[num_classes_] = norm_count_[class_id];
<span onclick='openModal()' class='match'>207        }
208      }
209      if (num_classes_ > 1) {
210        HeapSort(num_classes_, sort_key_, sort_index_);
211      }
212    }
213    void DebugMatch(const Classify &classify, const INT_TEMPLATES_STRUCT *int_templates,
214                    const INT_FEATURE_STRUCT *features) const {
</span>215      int num_pruners = int_templates->NumClassPruners;
216      int max_num_classes = int_templates->NumClasses;
217      for (int f = 0; f < num_features_; ++f) {
218        const INT_FEATURE_STRUCT *feature = &features[f];
219        tprintf("F=%3d(%d,%d,%d),", f, feature->X, feature->Y, feature->Theta);
220        int x = feature->X * NUM_CP_BUCKETS >> 8;
221        int y = feature->Y * NUM_CP_BUCKETS >> 8;
222        int theta = feature->Theta * NUM_CP_BUCKETS >> 8;
223        int class_id = 0;
224        for (int pruner_set = 0; pruner_set < num_pruners; ++pruner_set) {
225          const uint32_t *pruner_word_ptr = int_templates->ClassPruners[pruner_set]->p[x][y][theta];
226          for (int word = 0; word < WERDS_PER_CP_VECTOR; ++word) {
227            uint32_t pruner_word = *pruner_word_ptr++;
228            for (int word_class = 0; word_class < 16 && class_id < max_num_classes;
229                 ++word_class, ++class_id) {
230              if (norm_count_[class_id] >= pruning_threshold_) {
231                tprintf(" %s=%d,", classify.ClassIDToDebugStr(int_templates, class_id, 0).c_str(),
232                        pruner_word & CLASS_PRUNER_CLASS_MASK);
233              }
234              pruner_word >>= NUM_BITS_PER_CLASS;
235            }
236          }
237          tprintf("\n");
238        }
239      }
240    }
241    void SummarizeResult(const Classify &classify, const INT_TEMPLATES_STRUCT *int_templates,
242                         const uint16_t *expected_num_features, int norm_multiplier,
243                         const uint8_t *normalization_factors) const {
244      tprintf("CP:%d classes, %d features:\n", num_classes_, num_features_);
245      for (int i = 0; i < num_classes_; ++i) {
246        int class_id = sort_index_[num_classes_ - i];
247        std::string class_string = classify.ClassIDToDebugStr(int_templates, class_id, 0);
248        tprintf(
249            "%s:Initial=%d, E=%d, Xht-adj=%d, N=%d, Rat=%.2f\n", class_string.c_str(),
250            class_count_[class_id], expected_num_features[class_id],
251            (norm_multiplier * normalization_factors[class_id]) >> 8, sort_key_[num_classes_ - i],
252            100.0 - 100.0 * sort_key_[num_classes_ - i] / (CLASS_PRUNER_CLASS_MASK * num_features_));
253      }
254    }
255    int SetupResults(std::vector<CP_RESULT_STRUCT> *results) const {
256      results->clear();
257      results->resize(num_classes_);
258      for (int c = 0; c < num_classes_; ++c) {
259        (*results)[c].Class = sort_index_[num_classes_ - c];
260        (*results)[c].Rating =
261            1.0f - sort_key_[num_classes_ - c] /
262                       (static_cast<float>(CLASS_PRUNER_CLASS_MASK) * num_features_);
263      }
264      return num_classes_;
265    }
266  private:
267    int *class_count_;
268    int *norm_count_;
269    int *sort_key_;
270    int *sort_index_;
271    int max_classes_;
272    int rounded_classes_;
273    int pruning_threshold_;
274    int num_features_;
275    int num_classes_;
276  };
277  int Classify::PruneClasses(const INT_TEMPLATES_STRUCT *int_templates, int num_features,
278                             int keep_this, const INT_FEATURE_STRUCT *features,
279                             const uint8_t *normalization_factors,
280                             const uint16_t *expected_num_features,
281                             std::vector<CP_RESULT_STRUCT> *results) {
282    ClassPruner pruner(int_templates->NumClasses);
283    pruner.ComputeScores(int_templates, num_features, features);
284    pruner.AdjustForExpectedNumFeatures(expected_num_features, classify_cp_cutoff_strength);
285    if (shape_table_ == nullptr) {
286      pruner.DisableDisabledClasses(unicharset);
287    }
288    if (disable_character_fragments && shape_table_ == nullptr) {
289      pruner.DisableFragments(unicharset);
290    }
291    if (normalization_factors != nullptr) {
292      pruner.NormalizeForXheight(classify_class_pruner_multiplier, normalization_factors);
293    } else {
294      pruner.NoNormalization();
295    }
296    pruner.PruneAndSort(classify_class_pruner_threshold, keep_this, shape_table_ == nullptr,
297                        unicharset);
298    if (classify_debug_level > 2) {
299      pruner.DebugMatch(*this, int_templates, features);
300    }
301    if (classify_debug_level > 1) {
302      pruner.SummarizeResult(*this, int_templates, expected_num_features,
303                             classify_class_pruner_multiplier, normalization_factors);
304    }
305    return pruner.SetupResults(results);
306  }
307  void IntegerMatcher::Match(INT_CLASS_STRUCT *ClassTemplate, BIT_VECTOR ProtoMask, BIT_VECTOR ConfigMask,
308                             int16_t NumFeatures, const INT_FEATURE_STRUCT *Features,
309                             UnicharRating *Result, int AdaptFeatureThreshold, int Debug,
310                             bool SeparateDebugWindows) {
311    auto *tables = new ScratchEvidence();
312    int Feature;
313    if (MatchDebuggingOn(Debug)) {
314      tprintf("Integer Matcher -------------------------------------------\n");
315    }
316    tables->Clear(ClassTemplate);
317    Result->feature_misses = 0;
318    for (Feature = 0; Feature < NumFeatures; Feature++) {
319      int csum = UpdateTablesForFeature(ClassTemplate, ProtoMask, ConfigMask, Feature,
320                                        &Features[Feature], tables, Debug);
321      if (csum == 0) {
322        ++Result->feature_misses;
323      }
324    }
325  #ifndef GRAPHICS_DISABLED
326    if (PrintProtoMatchesOn(Debug) || PrintMatchSummaryOn(Debug)) {
327      DebugFeatureProtoError(ClassTemplate, ProtoMask, ConfigMask, *tables, NumFeatures, Debug);
328    }
329    if (DisplayProtoMatchesOn(Debug)) {
330      DisplayProtoDebugInfo(ClassTemplate, ConfigMask, *tables, SeparateDebugWindows);
331    }
332    if (DisplayFeatureMatchesOn(Debug)) {
333      DisplayFeatureDebugInfo(ClassTemplate, ProtoMask, ConfigMask, NumFeatures, Features,
334                              AdaptFeatureThreshold, Debug, SeparateDebugWindows);
335    }
336  #endif
337    tables->UpdateSumOfProtoEvidences(ClassTemplate, ConfigMask);
338    tables->NormalizeSums(ClassTemplate, NumFeatures);
339    FindBestMatch(ClassTemplate, *tables, Result);
340  #ifndef GRAPHICS_DISABLED
341    if (PrintMatchSummaryOn(Debug)) {
342      Result->Print();
343    }
344    if (MatchDebuggingOn(Debug)) {
345      tprintf("Match Complete --------------------------------------------\n");
346    }
347  #endif
348    delete tables;
349  }
350  int IntegerMatcher::FindGoodProtos(INT_CLASS_STRUCT *ClassTemplate, BIT_VECTOR ProtoMask,
351                                     BIT_VECTOR ConfigMask, int16_t NumFeatures,
352                                     INT_FEATURE_ARRAY Features, PROTO_ID *ProtoArray,
353                                     int AdaptProtoThreshold, int Debug) {
354    auto *tables = new ScratchEvidence();
355    int NumGoodProtos = 0;
356    if (MatchDebuggingOn(Debug)) {
357      tprintf("Find Good Protos -------------------------------------------\n");
358    }
359    tables->Clear(ClassTemplate);
360    for (int Feature = 0; Feature < NumFeatures; Feature++) {
361      UpdateTablesForFeature(ClassTemplate, ProtoMask, ConfigMask, Feature, &(Features[Feature]),
362                             tables, Debug);
363    }
364  #ifndef GRAPHICS_DISABLED
365    if (PrintProtoMatchesOn(Debug) || PrintMatchSummaryOn(Debug)) {
366      DebugFeatureProtoError(ClassTemplate, ProtoMask, ConfigMask, *tables, NumFeatures, Debug);
367    }
368  #endif
369    for (int proto = 0; proto < ClassTemplate->NumProtos; proto++) {
370      int Temp = 0;
371      for (uint8_t i = 0; i < MAX_PROTO_INDEX && i < ClassTemplate->ProtoLengths[proto]; i++) {
372        Temp += tables->proto_evidence_[proto][i];
373      }
374      Temp /= ClassTemplate->ProtoLengths[proto];
375      if (Temp >= AdaptProtoThreshold) {
376        *ProtoArray = proto;
377        ProtoArray++;
378        NumGoodProtos++;
379      }
380    }
381    if (MatchDebuggingOn(Debug)) {
382      tprintf("Match Complete --------------------------------------------\n");
383    }
384    delete tables;
385    return NumGoodProtos;
386  }
387  int IntegerMatcher::FindBadFeatures(INT_CLASS_STRUCT *ClassTemplate, BIT_VECTOR ProtoMask,
388                                      BIT_VECTOR ConfigMask, int16_t NumFeatures,
389                                      INT_FEATURE_ARRAY Features, FEATURE_ID *FeatureArray,
390                                      int AdaptFeatureThreshold, int Debug) {
391    auto *tables = new ScratchEvidence();
392    int NumBadFeatures = 0;
393    if (MatchDebuggingOn(Debug)) {
394      tprintf("Find Bad Features -------------------------------------------\n");
395    }
396    tables->Clear(ClassTemplate);
397    for (int Feature = 0; Feature < NumFeatures; Feature++) {
398      UpdateTablesForFeature(ClassTemplate, ProtoMask, ConfigMask, Feature, &Features[Feature],
399                             tables, Debug);
400      int best = 0;
401      assert(ClassTemplate->NumConfigs < MAX_NUM_CONFIGS);
402      for (int i = 0; i < MAX_NUM_CONFIGS && i < ClassTemplate->NumConfigs; i++) {
403        if (tables->feature_evidence_[i] > best) {
404          best = tables->feature_evidence_[i];
405        }
406      }
407      if (best < AdaptFeatureThreshold) {
408        *FeatureArray = Feature;
409        FeatureArray++;
410        NumBadFeatures++;
411      }
412    }
413  #ifndef GRAPHICS_DISABLED
414    if (PrintProtoMatchesOn(Debug) || PrintMatchSummaryOn(Debug)) {
415      DebugFeatureProtoError(ClassTemplate, ProtoMask, ConfigMask, *tables, NumFeatures, Debug);
416    }
417  #endif
418    if (MatchDebuggingOn(Debug)) {
419      tprintf("Match Complete --------------------------------------------\n");
420    }
421    delete tables;
422    return NumBadFeatures;
423  }
424  IntegerMatcher::IntegerMatcher(tesseract::IntParam *classify_debug_level)
425      : classify_debug_level_(classify_debug_level) {
426    for (int i = 0; i < SE_TABLE_SIZE; i++) {
427      uint32_t IntSimilarity = i << (27 - SE_TABLE_BITS);
428      double Similarity = (static_cast<double>(IntSimilarity)) / 65536.0 / 65536.0;
429      double evidence = Similarity / kSimilarityCenter;
430      evidence = 255.0 / (evidence * evidence + 1.0);
431      if (kSEExponentialMultiplier > 0.0) {
432        double scale =
433            1.0 - std::exp(-kSEExponentialMultiplier) *
434                      exp(kSEExponentialMultiplier * (static_cast<double>(i) / SE_TABLE_SIZE));
435        evidence *= ClipToRange(scale, 0.0, 1.0);
436      }
437      similarity_evidence_table_[i] = static_cast<uint8_t>(evidence + 0.5);
438    }
439    evidence_table_mask_ = ((1 << kEvidenceTableBits) - 1) << (9 - kEvidenceTableBits);
440    mult_trunc_shift_bits_ = (14 - kIntEvidenceTruncBits);
441    table_trunc_shift_bits_ = (27 - SE_TABLE_BITS - (mult_trunc_shift_bits_ << 1));
442    evidence_mult_mask_ = ((1 << kIntEvidenceTruncBits) - 1);
443  }
444  void ScratchEvidence::Clear(const INT_CLASS_STRUCT *class_template) {
445    memset(sum_feature_evidence_, 0, class_template->NumConfigs * sizeof(sum_feature_evidence_[0]));
446    memset(proto_evidence_, 0, class_template->NumProtos * sizeof(proto_evidence_[0]));
447  }
448  void ScratchEvidence::ClearFeatureEvidence(const INT_CLASS_STRUCT *class_template) {
449    memset(feature_evidence_, 0, class_template->NumConfigs * sizeof(feature_evidence_[0]));
450  }
451  static void IMDebugConfiguration(int FeatureNum, uint16_t ActualProtoNum, uint8_t Evidence,
452                                   uint32_t ConfigWord) {
453    tprintf("F = %3d, P = %3d, E = %3d, Configs = ", FeatureNum, static_cast<int>(ActualProtoNum),
454            static_cast<int>(Evidence));
455    while (ConfigWord) {
456      if (ConfigWord & 1) {
457        tprintf("1");
458      } else {
459        tprintf("0");
460      }
461      ConfigWord >>= 1;
462    }
463    tprintf("\n");
464  }
465  static void IMDebugConfigurationSum(int FeatureNum, uint8_t *FeatureEvidence, int32_t ConfigCount) {
466    tprintf("F=%3d, C=", FeatureNum);
467    for (int ConfigNum = 0; ConfigNum < ConfigCount; ConfigNum++) {
468      tprintf("%4d", FeatureEvidence[ConfigNum]);
469    }
470    tprintf("\n");
471  }
472  int IntegerMatcher::UpdateTablesForFeature(INT_CLASS_STRUCT *ClassTemplate, BIT_VECTOR ProtoMask,
473                                             BIT_VECTOR ConfigMask, int FeatureNum,
474                                             const INT_FEATURE_STRUCT *Feature,
475                                             ScratchEvidence *tables, int Debug) {
476    uint32_t ConfigWord;
477    uint32_t ProtoWord;
478    uint32_t ProtoNum;
479    uint32_t ActualProtoNum;
480    uint8_t proto_byte;
481    int32_t proto_word_offset;
482    int32_t proto_offset;
483    PROTO_SET_STRUCT *ProtoSet;
484    uint32_t *ProtoPrunerPtr;
485    INT_PROTO_STRUCT *Proto;
486    int ProtoSetIndex;
487    uint8_t Evidence;
488    uint32_t XFeatureAddress;
489    uint32_t YFeatureAddress;
490    uint32_t ThetaFeatureAddress;
491    tables->ClearFeatureEvidence(ClassTemplate);
492    XFeatureAddress = ((Feature->X >> 2) << 1);
493    YFeatureAddress = (NUM_PP_BUCKETS << 1) + ((Feature->Y >> 2) << 1);
494    ThetaFeatureAddress = (NUM_PP_BUCKETS << 2) + ((Feature->Theta >> 2) << 1);
495    for (ProtoSetIndex = 0, ActualProtoNum = 0; ProtoSetIndex < ClassTemplate->NumProtoSets;
496         ProtoSetIndex++) {
497      ProtoSet = ClassTemplate->ProtoSets[ProtoSetIndex];
498      ProtoPrunerPtr = reinterpret_cast<uint32_t *>((*ProtoSet).ProtoPruner);
499      for (ProtoNum = 0; ProtoNum < PROTOS_PER_PROTO_SET; ProtoNum += (PROTOS_PER_PROTO_SET >> 1),
500          ActualProtoNum += (PROTOS_PER_PROTO_SET >> 1), ProtoMask++, ProtoPrunerPtr++) {
501        ProtoWord = *(ProtoPrunerPtr + XFeatureAddress);
502        ProtoWord &= *(ProtoPrunerPtr + YFeatureAddress);
503        ProtoWord &= *(ProtoPrunerPtr + ThetaFeatureAddress);
504        ProtoWord &= *ProtoMask;
505        if (ProtoWord != 0) {
506          proto_byte = ProtoWord & 0xff;
507          ProtoWord >>= 8;
508          proto_word_offset = 0;
509          while (ProtoWord != 0 || proto_byte != 0) {
510            while (proto_byte == 0) {
511              proto_byte = ProtoWord & 0xff;
512              ProtoWord >>= 8;
513              proto_word_offset += 8;
514            }
515            proto_offset = offset_table[proto_byte] + proto_word_offset;
516            proto_byte = next_table[proto_byte];
517            Proto = &(ProtoSet->Protos[ProtoNum + proto_offset]);
518            ConfigWord = Proto->Configs[0];
519            int32_t A3 = (((Proto->A * (Feature->X - 128)) * 2) - (Proto->B * (Feature->Y - 128)) +
520                          (Proto->C * 512));
521            int32_t M3 = ((static_cast<int8_t>(Feature->Theta - Proto->Angle)) * kIntThetaFudge) * 2;
522            if (A3 < 0) {
523              A3 = ~A3;
524            }
525            if (M3 < 0) {
526              M3 = ~M3;
527            }
528            A3 >>= mult_trunc_shift_bits_;
529            M3 >>= mult_trunc_shift_bits_;
530            if (static_cast<uint32_t>(A3) > evidence_mult_mask_) {
531              A3 = evidence_mult_mask_;
532            }
533            if (static_cast<uint32_t>(M3) > evidence_mult_mask_) {
534              M3 = evidence_mult_mask_;
535            }
536            uint32_t A4 = (A3 * A3) + (M3 * M3);
537            A4 >>= table_trunc_shift_bits_;
538            if (A4 > evidence_table_mask_) {
539              Evidence = 0;
540            } else {
541              Evidence = similarity_evidence_table_[A4];
542            }
543            if (PrintFeatureMatchesOn(Debug)) {
544              IMDebugConfiguration(FeatureNum, ActualProtoNum + proto_offset, Evidence, ConfigWord);
545            }
546            ConfigWord &= *ConfigMask;
547            uint8_t feature_evidence_index = 0;
548            uint8_t config_byte = 0;
549            while (ConfigWord != 0 || config_byte != 0) {
550              while (config_byte == 0) {
551                config_byte = ConfigWord & 0xff;
552                ConfigWord >>= 8;
553                feature_evidence_index += 8;
554              }
555              const uint8_t config_offset = offset_table[config_byte] + feature_evidence_index - 8;
556              config_byte = next_table[config_byte];
557              if (Evidence > tables->feature_evidence_[config_offset]) {
558                tables->feature_evidence_[config_offset] = Evidence;
559              }
560            }
561            uint8_t ProtoIndex = ClassTemplate->ProtoLengths[ActualProtoNum + proto_offset];
562            if (ProtoIndex > MAX_PROTO_INDEX) {
563              ProtoIndex = MAX_PROTO_INDEX;
564            }
565            uint8_t *UINT8Pointer = &(tables->proto_evidence_[ActualProtoNum + proto_offset][0]);
566            for (; Evidence > 0 && ProtoIndex > 0; ProtoIndex--, UINT8Pointer++) {
567              if (Evidence > *UINT8Pointer) {
568                uint8_t Temp = *UINT8Pointer;
569                *UINT8Pointer = Evidence;
570                Evidence = Temp;
571              }
572            }
573          }
574        }
575      }
576    }
577    if (PrintFeatureMatchesOn(Debug)) {
578      IMDebugConfigurationSum(FeatureNum, tables->feature_evidence_, ClassTemplate->NumConfigs);
579    }
580    int *IntPointer = tables->sum_feature_evidence_;
581    uint8_t *UINT8Pointer = tables->feature_evidence_;
582    int SumOverConfigs = 0;
583    for (int ConfigNum = ClassTemplate->NumConfigs; ConfigNum > 0; ConfigNum--) {
584      int evidence = *UINT8Pointer++;
585      SumOverConfigs += evidence;
586      *IntPointer++ += evidence;
587    }
588    return SumOverConfigs;
589  }
590  #ifndef GRAPHICS_DISABLED
591  void IntegerMatcher::DebugFeatureProtoError(INT_CLASS_STRUCT *ClassTemplate, BIT_VECTOR ProtoMask,
592                                              BIT_VECTOR ConfigMask, const ScratchEvidence &tables,
593                                              int16_t NumFeatures, int Debug) {
594    float ProtoConfigs[MAX_NUM_CONFIGS];
595    int ConfigNum;
596    uint32_t ConfigWord;
597    int ProtoSetIndex;
598    uint16_t ProtoNum;
599    uint8_t ProtoWordNum;
600    PROTO_SET_STRUCT *ProtoSet;
601    uint16_t ActualProtoNum;
602    if (PrintMatchSummaryOn(Debug)) {
603      tprintf("Configuration Mask:\n");
604      for (ConfigNum = 0; ConfigNum < ClassTemplate->NumConfigs; ConfigNum++) {
605        tprintf("%1d", (((*ConfigMask) >> ConfigNum) & 1));
606      }
607      tprintf("\n");
608      tprintf("Feature Error for Configurations:\n");
609      for (ConfigNum = 0; ConfigNum < ClassTemplate->NumConfigs; ConfigNum++) {
610        tprintf(" %5.1f", 100.0 * (1.0 - static_cast<float>(tables.sum_feature_evidence_[ConfigNum]) /
611                                             NumFeatures / 256.0));
612      }
613      tprintf("\n\n\n");
614    }
615    if (PrintMatchSummaryOn(Debug)) {
616      tprintf("Proto Mask:\n");
617      for (ProtoSetIndex = 0; ProtoSetIndex < ClassTemplate->NumProtoSets; ProtoSetIndex++) {
618        ActualProtoNum = (ProtoSetIndex * PROTOS_PER_PROTO_SET);
619        for (ProtoWordNum = 0; ProtoWordNum < 2; ProtoWordNum++, ProtoMask++) {
620          ActualProtoNum = (ProtoSetIndex * PROTOS_PER_PROTO_SET);
621          for (ProtoNum = 0; ((ProtoNum < (PROTOS_PER_PROTO_SET >> 1)) &&
622                              (ActualProtoNum < ClassTemplate->NumProtos));
623               ProtoNum++, ActualProtoNum++) {
624            tprintf("%1d", (((*ProtoMask) >> ProtoNum) & 1));
625          }
626          tprintf("\n");
627        }
628      }
629      tprintf("\n");
630    }
631    for (int i = 0; i < ClassTemplate->NumConfigs; i++) {
632      ProtoConfigs[i] = 0;
633    }
634    if (PrintProtoMatchesOn(Debug)) {
635      tprintf("Proto Evidence:\n");
636      for (ProtoSetIndex = 0; ProtoSetIndex < ClassTemplate->NumProtoSets; ProtoSetIndex++) {
637        ProtoSet = ClassTemplate->ProtoSets[ProtoSetIndex];
638        ActualProtoNum = (ProtoSetIndex * PROTOS_PER_PROTO_SET);
639        for (ProtoNum = 0;
640             ((ProtoNum < PROTOS_PER_PROTO_SET) && (ActualProtoNum < ClassTemplate->NumProtos));
641             ProtoNum++, ActualProtoNum++) {
642          tprintf("P %3d =", ActualProtoNum);
643          int temp = 0;
644          for (uint8_t j = 0; j < ClassTemplate->ProtoLengths[ActualProtoNum]; j++) {
645            uint8_t data = tables.proto_evidence_[ActualProtoNum][j];
646            tprintf(" %d", data);
647            temp += data;
648          }
649          tprintf(" = %6.4f%%\n", temp / 256.0 / ClassTemplate->ProtoLengths[ActualProtoNum]);
650          ConfigWord = ProtoSet->Protos[ProtoNum].Configs[0];
651          ConfigNum = 0;
652          while (ConfigWord) {
653            tprintf("%5d", ConfigWord & 1 ? temp : 0);
654            if (ConfigWord & 1) {
655              ProtoConfigs[ConfigNum] += temp;
656            }
657            ConfigNum++;
658            ConfigWord >>= 1;
659          }
660          tprintf("\n");
661        }
662      }
663    }
664    if (PrintMatchSummaryOn(Debug)) {
665      tprintf("Proto Error for Configurations:\n");
666      for (ConfigNum = 0; ConfigNum < ClassTemplate->NumConfigs; ConfigNum++) {
667        tprintf(" %5.1f", 100.0 * (1.0 - ProtoConfigs[ConfigNum] /
668                                             ClassTemplate->ConfigLengths[ConfigNum] / 256.0));
669      }
670      tprintf("\n\n");
671    }
672    if (PrintProtoMatchesOn(Debug)) {
673      tprintf("Proto Sum for Configurations:\n");
674      for (ConfigNum = 0; ConfigNum < ClassTemplate->NumConfigs; ConfigNum++) {
675        tprintf(" %4.1f", ProtoConfigs[ConfigNum] / 256.0);
676      }
677      tprintf("\n\n");
678      tprintf("Proto Length for Configurations:\n");
679      for (ConfigNum = 0; ConfigNum < ClassTemplate->NumConfigs; ConfigNum++) {
680        tprintf(" %4.1f", static_cast<float>(ClassTemplate->ConfigLengths[ConfigNum]));
681      }
682      tprintf("\n\n");
683    }
684  }
685  void IntegerMatcher::DisplayProtoDebugInfo(INT_CLASS_STRUCT *ClassTemplate, BIT_VECTOR ConfigMask,
686                                             const ScratchEvidence &tables,
687                                             bool SeparateDebugWindows) {
688    uint16_t ProtoNum;
689    uint16_t ActualProtoNum;
690    PROTO_SET_STRUCT *ProtoSet;
691    int ProtoSetIndex;
692    InitIntMatchWindowIfReqd();
693    if (SeparateDebugWindows) {
694      InitFeatureDisplayWindowIfReqd();
695      InitProtoDisplayWindowIfReqd();
696    }
697    for (ProtoSetIndex = 0; ProtoSetIndex < ClassTemplate->NumProtoSets; ProtoSetIndex++) {
698      ProtoSet = ClassTemplate->ProtoSets[ProtoSetIndex];
699      ActualProtoNum = ProtoSetIndex * PROTOS_PER_PROTO_SET;
700      for (ProtoNum = 0;
701           ((ProtoNum < PROTOS_PER_PROTO_SET) && (ActualProtoNum < ClassTemplate->NumProtos));
702           ProtoNum++, ActualProtoNum++) {
703        int temp = 0;
704        for (uint8_t i = 0; i < ClassTemplate->ProtoLengths[ActualProtoNum]; i++) {
705          temp += tables.proto_evidence_[ActualProtoNum][i];
706        }
707        temp /= ClassTemplate->ProtoLengths[ActualProtoNum];
708        if ((ProtoSet->Protos[ProtoNum]).Configs[0] & (*ConfigMask)) {
709          DisplayIntProto(ClassTemplate, ActualProtoNum, temp / 255.0);
710        }
711      }
712    }
713  }
714  void IntegerMatcher::DisplayFeatureDebugInfo(INT_CLASS_STRUCT *ClassTemplate, BIT_VECTOR ProtoMask,
715                                               BIT_VECTOR ConfigMask, int16_t NumFeatures,
716                                               const INT_FEATURE_STRUCT *Features,
717                                               int AdaptFeatureThreshold, int Debug,
718                                               bool SeparateDebugWindows) {
719    auto *tables = new ScratchEvidence();
720    tables->Clear(ClassTemplate);
721    InitIntMatchWindowIfReqd();
722    if (SeparateDebugWindows) {
723      InitFeatureDisplayWindowIfReqd();
724      InitProtoDisplayWindowIfReqd();
725    }
726    for (int Feature = 0; Feature < NumFeatures; Feature++) {
727      UpdateTablesForFeature(ClassTemplate, ProtoMask, ConfigMask, Feature, &Features[Feature],
728                             tables, 0);
729      int best = 0;
730      assert(ClassTemplate->NumConfigs < MAX_NUM_CONFIGS);
731      for (int i = 0; i < MAX_NUM_CONFIGS && i < ClassTemplate->NumConfigs; i++) {
732        if (tables->feature_evidence_[i] > best) {
733          best = tables->feature_evidence_[i];
734        }
735      }
736      if (ClipMatchEvidenceOn(Debug)) {
737        if (best < AdaptFeatureThreshold) {
738          DisplayIntFeature(&Features[Feature], 0.0);
739        } else {
740          DisplayIntFeature(&Features[Feature], 1.0);
741        }
742      } else {
743        DisplayIntFeature(&Features[Feature], best / 255.0);
744      }
745    }
746    delete tables;
747  }
748  #endif
749  void ScratchEvidence::UpdateSumOfProtoEvidences(INT_CLASS_STRUCT *ClassTemplate, BIT_VECTOR ConfigMask) {
750    int *IntPointer;
751    uint32_t ConfigWord;
752    int ProtoSetIndex;
753    uint16_t ProtoNum;
754    PROTO_SET_STRUCT *ProtoSet;
755    int NumProtos;
756    uint16_t ActualProtoNum;
757    NumProtos = ClassTemplate->NumProtos;
758    for (ProtoSetIndex = 0; ProtoSetIndex < ClassTemplate->NumProtoSets; ProtoSetIndex++) {
759      ProtoSet = ClassTemplate->ProtoSets[ProtoSetIndex];
760      ActualProtoNum = (ProtoSetIndex * PROTOS_PER_PROTO_SET);
761      for (ProtoNum = 0; ((ProtoNum < PROTOS_PER_PROTO_SET) && (ActualProtoNum < NumProtos));
762           ProtoNum++, ActualProtoNum++) {
763        int temp = 0;
764        for (uint8_t i = 0; i < MAX_PROTO_INDEX && i < ClassTemplate->ProtoLengths[ActualProtoNum];
765             i++) {
766          temp += proto_evidence_[ActualProtoNum][i];
767        }
768        ConfigWord = ProtoSet->Protos[ProtoNum].Configs[0];
769        ConfigWord &= *ConfigMask;
770        IntPointer = sum_feature_evidence_;
771        while (ConfigWord) {
772          if (ConfigWord & 1) {
773            *IntPointer += temp;
774          }
775          IntPointer++;
776          ConfigWord >>= 1;
777        }
778      }
779    }
780  }
781  void ScratchEvidence::NormalizeSums(INT_CLASS_STRUCT *ClassTemplate, int16_t NumFeatures) {
782    for (int i = 0; i < MAX_NUM_CONFIGS && i < ClassTemplate->NumConfigs; i++) {
783      sum_feature_evidence_[i] =
784          (sum_feature_evidence_[i] << 8) / (NumFeatures + ClassTemplate->ConfigLengths[i]);
785    }
786  }
787  int IntegerMatcher::FindBestMatch(INT_CLASS_STRUCT *class_template, const ScratchEvidence &tables,
788                                    UnicharRating *result) {
789    int best_match = 0;
790    result->config = 0;
791    result->fonts.clear();
792    result->fonts.reserve(class_template->NumConfigs);
793    for (int c = 0; c < MAX_NUM_CONFIGS && c < class_template->NumConfigs; ++c) {
794      int rating = tables.sum_feature_evidence_[c];
795      if (*classify_debug_level_ > 2) {
796        tprintf("Config %d, rating=%d\n", c, rating);
797      }
798      if (rating > best_match) {
799        result->config = c;
800        best_match = rating;
801      }
802      result->fonts.emplace_back(c, rating);
803    }
804    result->rating = best_match / 65536.0f;
805    return best_match;
806  }
807  float IntegerMatcher::ApplyCNCorrection(float rating, int blob_length, int normalization_factor,
808                                          int matcher_multiplier) {
809    int divisor = blob_length + matcher_multiplier;
810    return divisor == 0
811               ? 1.0f
812               : (rating * blob_length + matcher_multiplier * normalization_factor / 256.0f) /
813                     divisor;
814  }
815  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-websocket_59.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-intmatcher.cpp</div>
                </div>
                <div class="column column_space"><pre><code>567  		sessions.erase (std::remove_if (sessions.begin (), sessions.end (), [] (auto & elem) { return elem.expired (); }), sessions.end ());
568  		sessions_mutex.unlock ();
569  		session->handshake ();
570  	}
571  	if (!stopped)
572  	{
573  		accept ();
574  	}
575  }
576  void nano::websocket::listener::broadcast_confirmation (std::shared_ptr<nano::block> const & block_a, nano::account const & account_a, nano::amount const & amount_a, std::string const & subtype, nano::election_status const & election_status_a, std::vector<nano::vote_with_weight_info> const & election_votes_a)
</pre></code></div>
                <div class="column column_space"><pre><code>207        }
208      }
209      if (num_classes_ > 1) {
210        HeapSort(num_classes_, sort_key_, sort_index_);
211      }
212    }
213    void DebugMatch(const Classify &classify, const INT_TEMPLATES_STRUCT *int_templates,
214                    const INT_FEATURE_STRUCT *features) const {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    