
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 9.031318281136198%, Tokens: 12</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-yahoodm.h</h3>
            <pre><code>1  #ifndef YahooDm_h
2  #define YahooDm_h
3  #include "base.h"
4  #include "dmdata.h"
5  #include "yahoobs.h"
6  #include "mg.h"
7  #include "md.h"
8  class TYTbVar: public TTbVar{
9  private:
10    TStr Nm;
11    PTbVarType VarType;
12  public:
13    TYTbVar(const TStr& _Nm, const PTbVarType& _VarType):
14      TTbVar(), Nm(_Nm), VarType(_VarType){}
15    TYTbVar(TSIn& SIn): TTbVar(SIn), Nm(SIn){}
16    void Save(TSOut& SOut){TTbVar::Save(SOut); Nm.Save(SOut);}
17    TYTbVar& operator=(const TYTbVar& YTbVar){
18      TTbVar::operator=(YTbVar); Nm=YTbVar.Nm; VarType=YTbVar.VarType;
19      return *this;}
20    TStr GetNm() const {return Nm;}
21    PTbVarType GetVarType() const {return VarType;}
22    TFSet GetActVTSet() const {return VarType->GetAlwVTSet();}
23    void DefVarType(){Fail;}
24    TTbVal GetDscVal(const TStr& Str){return VarType->GetDscVal(Str);}
25    TTbVal GetDscVal(const int& Dsc){return VarType->GetDscVal(Dsc);}
26    TTbVal GetFltVal(const double& Flt){return VarType->GetFltVal(Flt);}
27    TTbVal GetVal(const TTbVal& Val){return VarType->GetVal(Val);}
28  };
29  class TYTb: public TTb{
30  protected:
31    PYBs YBs;
32    PYDsBs YDsBs;
33    TIntV VarNToWordIdV, WordIdToVarNV;
34    TIntV TupNToDocIdV, DocIdToTupNV;
35  public:
36    TYTb(const PYBs& _YBs, const PYDsBs& _YDsBs);
37    TYTb(TSIn& SIn):
38      TTb(SIn), YBs(SIn), YDsBs(SIn),
39      VarNToWordIdV(SIn), WordIdToVarNV(SIn),
40      TupNToDocIdV(SIn), DocIdToTupNV(SIn){}
41    void Save(TSOut& SOut){
42      TTb::Save(SOut); YBs.Save(SOut); YDsBs.Save(SOut);
43      VarNToWordIdV.Save(SOut); WordIdToVarNV.Save(SOut);
44      TupNToDocIdV.Save(SOut); DocIdToTupNV.Save(SOut);}
45    int AddVar(const PTbVar&){Fail; return -1;}
46    void DefVarTypes(){Fail;}
47    int GetVars(){return VarNToWordIdV.Len();}
48    PTbVar GetVar(const int& VarN){
49      TStr WordStr=YBs->GetWordStr(VarNToWordIdV[VarN]);
<span onclick='openModal()' class='match'>50      return new TYTbVar(WordStr, TTbVarType::GetFltVarType());}
51    int GetVarN(const TStr& Nm){return WordIdToVarNV[YBs->GetWordId(Nm)];}
52    int AddTup(const TStr&){Fail; return -1;}
53    int GetTups(){return TupNToDocIdV.Len();}
</span>54    TStr GetTupNm(const int& TupN){return YBs->GetDocUrlStr(TupNToDocIdV[TupN]);}
55    int GetTupN(const TStr& Nm){return DocIdToTupNV[YBs->GetDocId(Nm)];}
56    void PutDsc(const int&, const int&, const TStr&){Fail;}
57    void PutDsc(const int&, const int&, const int&){Fail;}
58    void PutFlt(const int&, const int&, const double&){Fail;}
59    void PutVal(const int&, const int&, const TTbVal&){Fail;}
60    TTbVal GetVal(const int& TupN, const int& VarN);
61    TStr GetValStr(const int& TupN, const int& VarN){
62      return GetVal(TupN, VarN).GetStr();}
63  };
64  typedef TGDmHdVar TYDmHdVar;
65  class TYDmHd: public TDmHd{
66  private:
67    PYBs YBs;
68    PYDsBs YDsBs;
69  public:
70    TYDmHd(const PYBs& _YBs, const PYDsBs& _YDsBs):
71      TDmHd(), YBs(_YBs), YDsBs(_YDsBs){IAssert(YBs->IsIdEqN());}
72    TYDmHd& operator=(const TYDmHd&){Fail; return *this;}
73    int GetClasses() const {return YBs->GetDocs();}
74    int GetClassN(const TStr& Nm) const {return YBs->GetDocId(Nm);}
75    TStr GetClassNm(const int& ClassN) const {return YBs->GetDocUrlStr(ClassN);}
76    PDmHdVar GetClass(const int& ClassN) const {
77      TStr ClassNm=YBs->GetDocUrlStr(ClassN);
78      return new TYDmHdVar(ClassNm, TTbVarType::GetDscBoolVarType());}
79    int GetAttrs() const {return YBs->GetWords();}
80    int GetAttrN(const TStr& Nm) const {return YBs->GetWordId(Nm);}
81    TStr GetAttrNm(const int& AttrN) const {return YBs->GetWordStr(AttrN);}
82    PDmHdVar GetAttr(const int& AttrN) const {
83      TStr AttrNm=YBs->GetWordStr(AttrN);
84      return new TYDmHdVar(AttrNm, TTbVarType::GetFltVarType());}
85  };
86  typedef enum {yndtEmpty, yndtRoot, yndtAll} TYNegDsType;
87  typedef enum {yptWords, yptSects, yptDocs} TYPriorType;
88  class TYDmDs: public TDmDs{
89  private:
90    bool DoPriorDmDs;
91    int YNegDsType;
92    int YPriorType;
93    PYBs YBs;
94    PYDsBs YDsBs;
95    PDmHd DmHd;
96    PYWordDs NegWordDs;
97    PYWordDs PosWordDs;
98    PTbValDs CValDs;
99    double NegCValPrb;
100    double PosCValPrb;
101  public:
102    TYDmDs(
103     const bool& _DoPriorDmDs, const int& ClassN,
104     const int& _YNegDsType, const int& _YPriorType,
105     const PYBs& _YBs, const PYDsBs& _YDsBs, const PDmHd& _DmHd);
106    TYDmDs(TSIn&){Fail;}
107    void Save(TSOut&){Fail;}
108    TYDmDs& operator=(const TYDmDs&){Fail; return *this;}
109    double GetSumW();
110    PTbValDs GetCDs();
111    PTbValDs GetAVDs(const int& AttrN);
112    PTbValDs GetCAVDs(const TTbVal& CVal, const int& AttrN);
113    static PYWordDs GetNegWordDs(
114     const int& YNegDsType, const PYBs& YBs, const PYDsBs& YDsBs);
115    static PTbValDs GetPriorValDs(const int& YPriorType,
116     const PYWordDs& NegWordDs, const PYWordDs& PosWordDs);
117    static TStr GetYNegDsTypeStr(const TYNegDsType& YNegDsType);
118    static TStr GetYPriorTypeStr(const TYPriorType& YPriorType);
119  };
120  typedef enum {yfstFix, yfstPosPrc, yfstUnionPrc} TYFSelType;
121  class TYFSelBs{
122  private:
123    TCRef CRef;
124  private:
125    TInt YNegDsType;
126    TVec<TIntFltKdV> DocIdToWordIdEstVV;
127  public:
128    TYFSelBs(
129     const TYFSelType& FSelType, const double& FSels,
130     const bool& FSelPosWords, const PAttrEst& AttrEst,
131     const TYNegDsType& YNegDsType, const TYPriorType& YPriorType,
132     const PYBs& YBs, const PYDsBs& YDsBs, const PNotify& Notify=NULL);
133    ~TYFSelBs(){}
134    TYFSelBs(TSIn& SIn):
135      YNegDsType(SIn), DocIdToWordIdEstVV(SIn){SIn.LoadCs();}
136    static TPt<TYFSelBs> Load(TSIn& SIn){return new TYFSelBs(SIn);}
137    void Save(TSOut& SOut){
138      YNegDsType.Save(SOut); DocIdToWordIdEstVV.Save(SOut); SOut.SaveCs();}
139    TYFSelBs& operator=(const TYFSelBs&){Fail; return *this;}
140    int GetWords(const int& DocId){
141      return DocIdToWordIdEstVV[DocId].Len();}
142    TIntFltKdV& GetWordIdEstV(const int& DocId){
143      return DocIdToWordIdEstVV[DocId];}
144    void GetBestWordIdV(
145     const int& DocId, const double& EstExp, const double& SumEstPrb,
146     const PYWordDs& IntrsWordDs, TIntV& BestWordIdV);
147    bool IsWordId(const TIntFltKdV& WordIdEstV, const int& WordId){
148      return WordIdEstV.SearchBin(TIntFltKd(WordId))!=-1;}
149    void SaveTxt(
150     const PSOut& SOut, const PYBs& YBs, const PYDsBs& YDsBs);
151    static TStr GetYFSelTypeStr(const TYFSelType& YFSelType);
152    friend TPt<TYFSelBs>;
153  };
154  typedef TPt<TYFSelBs> PYFSelBs;
155  class TYInvIx{
156  private:
157    TCRef CRef;
158  private:
159    TIntIntH WordIdToFirstDocIdNH;
160    TIntV DocIdVHeap;
161    TIntV AllDocIdV;
162  public:
163    TYInvIx(
164     const double& EstExp, const double& SumEstPrb,
165     const PYBs& YBs, const PYDsBs& YDsBs,
166     const PYFSelBs& YFSelBs, const PNotify& Notify);
167    TYInvIx(TSIn& SIn):
168      WordIdToFirstDocIdNH(SIn), DocIdVHeap(SIn),
169      AllDocIdV(SIn){SIn.LoadCs();}
170    static TPt<TYInvIx> Load(TSIn& SIn){return new TYInvIx(SIn);}
171    void Save(TSOut& SOut){
172      WordIdToFirstDocIdNH.Save(SOut); DocIdVHeap.Save(SOut);
173      AllDocIdV.Save(SOut); SOut.SaveCs();}
174    TYInvIx& operator=(const TYInvIx&){Fail; return *this;}
175    void GetDocIdV(const PYWordDs& WordDs, const int& MnDocFq, TIntV& DocIdV);
176    int FFirstDocId(const int& WordId){
177      return WordIdToFirstDocIdNH.GetDat(WordId);}
178    bool FNextWordId(int& DocIdN, int& DocId){
179      if (DocIdN==-1){return false;}
180      else {DocId=DocIdVHeap[DocIdN++]; return DocId!=-1;}}
181    void SaveTxt(const PSOut& SOut, const PYBs& YBs);
182    friend TPt<TYInvIx>;
183  };
184  typedef TPt<TYInvIx> PYInvIx;
185  class TYValRet: public TValRet{
186  private:
187    double MnWordPrb;
188    PYBs YBs;
189    PYWordDs WordDs;
190    TIntV WordIdToAttrNV;
191  public:
192    TYValRet(const double& _MnWordPrb, const PDmHd& _DmHd,
193     const PYBs& _YBs, const PYWordDs& _WordDs):
194      TValRet(_DmHd), MnWordPrb(_MnWordPrb), YBs(_YBs), WordDs(_WordDs){}
195    TTbVal GetVal(const int& AttrN) const {
196      return TTbVal(WordDs->IsWordId(AttrN));}
197    int FFirstAttrN() const {return WordDs->FFirstWordId();}
198    bool FNextAttrN(int& AttrP, int& AttrN, TTbVal& AttrVal) const;
199  };
200  class TMdYBayes: public TMd{
201  private:
202    TInt YNegDsType;
203    TInt YPriorType;
204    PYBs YBs;
205    PYDsBs YDsBs;
206    PYFSelBs YFSelBs;
207    PYInvIx YInvIx;
208    PYWordDs NegWordDs;
209  public:
210    TMdYBayes(
211     const TYNegDsType& _YNegDsType, const TYPriorType& _YPriorType,
212     const PYBs& _YBs, const PYDsBs& _YDsBs,
213     const PYFSelBs& _YFSelBs, const PYInvIx& _YInvIx);
214    static PMd Load(TSIn& SIn);
215    void Save(TSOut& SOut);
216    PTbValDs GetPriorValDs(const int& ClassN) const {
217      PYWordDs PosWordDs=YDsBs->GetWordDs(ClassN);
218      return TYDmDs::GetPriorValDs(YPriorType, NegWordDs, PosWordDs);}
219    PTbValDs GetPostrValDs(const PValRet& ValRet, const int& ClassN) const;
220    PTbValDs GetPostrValDs(const PValRet& ValRet, const int& ClassN,
221     TFltIntKdV& WordPrbIdV) const;
222    PYBs GetYBs() const {return YBs;}
223    PYDsBs GetYDsBs() const {return YDsBs;}
224    PYFSelBs GetYFSelBs() const {return YFSelBs;}
225    PYInvIx GetYInvIx() const {return YInvIx;}
226    void Print(const int&) const {}
227  };
228  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-hashmp.h</h3>
            <pre><code>1  #ifndef hashmp_h
2  #define hashmp_h
3  #ifdef GCC_ATOMIC
4  #include "bd.h"
5  #pragma pack(push, 1) 
6  template <class TKey, class TDat>
7  class THashMPKeyDat {
8  public:
9    TInt HashCd;
10    TKey Key;
11    TDat Dat;
12  public:
13    THashMPKeyDat():
14      HashCd(-1), Key(), Dat(){}
15    THashMPKeyDat(const int& _HashCd, const TKey& _Key):
16      HashCd(_HashCd), Key(_Key), Dat(){}
17    explicit THashMPKeyDat(TSIn& SIn):
18      HashCd(SIn), Key(SIn), Dat(SIn){}
19    void Save(TSOut& SOut) const {
20      HashCd.Save(SOut); Key.Save(SOut); Dat.Save(SOut);}
21    bool operator==(const THashMPKeyDat& HashKeyDat) const {
22      if (this==&HashKeyDat || (HashCd==HashKeyDat.HashCd
23        && Key==HashKeyDat.Key && Dat==HashKeyDat.Dat)){return true;}
24      return false;}
25    THashMPKeyDat& operator=(const THashMPKeyDat& HashKeyDat){
26      if (this!=&HashKeyDat){
27        HashCd=HashKeyDat.HashCd; Key=HashKeyDat.Key;
28        Dat=HashKeyDat.Dat;}
29      return *this;}
30  };
31  #pragma pack(pop)
32  template<class TKey, class TDat>
33  class THashMPKeyDatI{
34  public:
35    typedef THashMPKeyDat<TKey, TDat> TPHKeyDat;
36  private:
37    TPHKeyDat* KeyDatI;
38    TPHKeyDat* EndI;
39  public:
40    THashMPKeyDatI(): KeyDatI(NULL), EndI(NULL){}
41    THashMPKeyDatI(const THashMPKeyDatI& _HashKeyDatI):
42      KeyDatI(_HashKeyDatI.KeyDatI), EndI(_HashKeyDatI.EndI){}
43    THashMPKeyDatI(const TPHKeyDat* _KeyDatI, const TPHKeyDat* _EndI):
44      KeyDatI((TPHKeyDat*)_KeyDatI), EndI((TPHKeyDat*)_EndI){}
45    THashMPKeyDatI& operator=(const THashMPKeyDatI& HashKeyDatI){
46      KeyDatI=HashKeyDatI.KeyDatI; EndI=HashKeyDatI.EndI; return *this;}
47    bool operator==(const THashMPKeyDatI& HashKeyDatI) const {
48      return KeyDatI==HashKeyDatI.KeyDatI;}
49    bool operator<(const THashMPKeyDatI& HashKeyDatI) const {
50      return KeyDatI<HashKeyDatI.KeyDatI;}
51    THashMPKeyDatI& operator++(int){ KeyDatI++; while (KeyDatI < EndI && KeyDatI->HashCd==-1) { KeyDatI++; } return *this; }
52    THashMPKeyDatI& operator--(int){ do { KeyDatI--; } while (KeyDatI->HashCd==-1); return *this;}
53    TPHKeyDat& operator*() const { return *KeyDatI; }
54    TPHKeyDat& operator()() const { return *KeyDatI; }
55    TPHKeyDat* operator->() const { return KeyDatI; }
56    THashMPKeyDatI& Next(){ operator++(1); return *this; }
57    bool IsEmpty() const { return KeyDatI == NULL; }
58    bool IsEnd() const { return EndI == KeyDatI; }
59    const TKey& GetKey() const {Assert((KeyDatI!=NULL)&&(KeyDatI->HashCd!=-1)); return KeyDatI->Key;}
60    const TDat& GetDat() const {&bsol;*Assert((KeyDatI!=NULL)&&(KeyDatI->HashCd!=-1));*/ return KeyDatI->Dat;}
61    TDat& GetDat() {Assert((KeyDatI!=NULL)&&(KeyDatI->HashCd!=-1)); return KeyDatI->Dat;}
62  };
63  template<class TKey, class TDat, class THashFunc = TDefaultHashFunc<TKey> >
64  class THashMP {
65  public:
66    enum {HashPrimes=32};
67    static const unsigned int HashPrimeT[HashPrimes];
68  public:
69    typedef THashMPKeyDatI<TKey, TDat> TIter;
70  private:
71    typedef THashMPKeyDat<TKey, TDat> TPHKeyDat;
72    typedef TPair<TKey, TDat> TKeyDatP;
73    TVec<TPHKeyDat> Table;
74    TInt NumVals;
75  private:
76    class THashMPKeyDatCmp {
77    public:
78      const THashMP<TKey, TDat, THashFunc>& Hash;
79      bool CmpKey, Asc;
80      THashMPKeyDatCmp(THashMP<TKey, TDat, THashFunc>& _Hash, const bool& _CmpKey, const bool& _Asc) :
81        Hash(_Hash), CmpKey(_CmpKey), Asc(_Asc) { }
82      bool operator () (const int& KeyId1, const int& KeyId2) const {
83        if (CmpKey) {
84          if (Asc) { return Hash.GetKey(KeyId1) < Hash.GetKey(KeyId2); }
85          else { return Hash.GetKey(KeyId2) < Hash.GetKey(KeyId1); } }
86        else {
87          if (Asc) { return Hash[KeyId1] < Hash[KeyId2]; }
88          else { return Hash[KeyId2] < Hash[KeyId1]; } } }
89    };
90  private:
91    TPHKeyDat& GetPHashKeyDat(const int& KeyId){
92      TPHKeyDat& KeyDat=Table[KeyId];
93      Assert(KeyDat.HashCd!=-1); return KeyDat;}
94    const TPHKeyDat& GetPHashKeyDat(const int& KeyId) const {
95      const TPHKeyDat& KeyDat=Table[KeyId];
96      Assert(KeyDat.HashCd!=-1); return KeyDat;}
97    uint GetNextPrime(const uint& Val) const;
98  public:
99    THashMP():
100      Table(), NumVals(0){}
101    THashMP(const THashMP& PHash):
102      Table(PHash.Table), NumVals(PHash.NumVals){}
103    explicit THashMP(const int& ExpectVals) {
104      Gen(ExpectVals);}
105    explicit THashMP(TSIn& SIn):
106      Table(SIn), NumVals(SIn){
107      SIn.LoadCs();}
108    void Load(TSIn& SIn){
109      Table.Load(SIn); NumVals.Load(SIn);
110      SIn.LoadCs();}
111    void Save(TSOut& SOut) const {
112      Table.Save(SOut); NumVals.Save(SOut);
113      SOut.SaveCs();}
114    THashMP& operator=(const THashMP& Hash){
115      if (this!=&Hash){
116        Table=Hash.Table; NumVals=Hash.NumVals;}
117      return *this;}
118    bool operator==(const THashMP& Hash) const; 
119    const TDat& operator[](const int& KeyId) const {return GetPHashKeyDat(KeyId).Dat;}
120    TDat& operator[](const int& KeyId){return GetPHashKeyDat(KeyId).Dat;}
121    TDat& operator()(const TKey& Key){return AddDat(Key);}
122    ::TSize GetMemUsed() const {
123        int64 MemUsed = sizeof(int);
124        for (int TableN = 0; TableN < Table.Len(); TableN++) {
125            MemUsed += int64(sizeof(TInt));
126            MemUsed += int64(Table[TableN].Key.GetMemUsed());
127            MemUsed += int64(Table[TableN].Dat.GetMemUsed());
128        }
129        return ::TSize(MemUsed);
130    }
131    TIter BegI() const {
132      if (Len() == 0){return TIter(Table.EndI(), Table.EndI());}
133      return TIter(Table.BegI(), Table.EndI());}
134    TIter EndI() const {return TIter(Table.EndI(), Table.EndI());}
135    TIter GetI(const TKey& Key) const {return TIter(&Table[GetKeyId(Key)], Table.EndI());}
136    void Gen(const int& ExpectVals){
137      Table.Gen(GetNextPrime(2 * ExpectVals));}
138    void Clr(const bool& DoDel=true);
139    bool Empty() const {return Len()==0;}
140    int Len() const {return NumVals;}
<span onclick='openModal()' class='match'>141    void SetLen(const int& Length) {NumVals=Length;}
142    int GetMxKeyIds() const {return Table.Len();}
143    int GetReservedKeyIds() const {return Table.Reserved();}
144    int AddKey(const TKey& Key);
</span>145    int AddKey11(const int& Idx, const TKey& Key, bool& Found);
146    int AddKey12(const int& Idx, const TKey& Key, bool& Found);
147    int AddKey13(const int& Idx, const TKey& Key);
148    int AddKey1(const TKey& Key, bool& Found);
149    int AddKey2(const int& Idx, const TKey& Key, bool& Found);
150    TDat& AddDatId(const TKey& Key){
151      int KeyId=AddKey(Key); return Table[KeyId].Dat=KeyId;}
152    TDat& AddDat(const TKey& Key){return Table[AddKey(Key)].Dat;}
153    TDat& AddDat(const TKey& Key, const TDat& Dat){
154      return Table[AddKey(Key)].Dat=Dat;}
155    const TKey& GetKey(const int& KeyId) const { return GetPHashKeyDat(KeyId).Key;}
156    int GetKeyId(const TKey& Key) const;
157    int GetRndKeyId(TRnd& Rnd) const;
158    int GetRndKeyId(TRnd& Rnd, const double& EmptyFrac);
159    bool IsKey(const TKey& Key) const {return GetKeyId(Key)!=-1;}
160    bool IsKey(const TKey& Key, int& KeyId) const { KeyId=GetKeyId(Key); return KeyId!=-1;}
161    bool IsKeyId(const int& KeyId) const {
162      return (0<=KeyId)&&(KeyId<Table.Len())&&(Table[KeyId].HashCd!=-1);}
163    const TDat& GetDat(const TKey& Key) const {return Table[GetKeyId(Key)].Dat;}
164    TDat& GetDat(const TKey& Key){return Table[GetKeyId(Key)].Dat;}
165    void GetKeyDat(const int& KeyId, TKey& Key, TDat& Dat) const {
166      const TPHKeyDat& KeyDat=GetPHashKeyDat(KeyId);
167      Key=KeyDat.Key; Dat=KeyDat.Dat;}
168    bool IsKeyGetDat(const TKey& Key, TDat& Dat) const {int KeyId;
169      if (IsKey(Key, KeyId)){Dat=GetPHashKeyDat(KeyId).Dat; return true;}
170      else {return false;}}
171    int FFirstKeyId() const {return 0-1;}
172    bool FNextKeyId(int& KeyId) const;
173    void GetKeyV(TVec<TKey>& KeyV) const;
174    void GetDatV(TVec<TDat>& DatV) const;
175    void GetKeyDatPrV(TVec<TPair<TKey, TDat> >& KeyDatPrV) const;
176    void GetDatKeyPrV(TVec<TPair<TDat, TKey> >& DatKeyPrV) const;
177    void GetKeyDatKdV(TVec<TKeyDat<TKey, TDat> >& KeyDatKdV) const;
178    void GetDatKeyKdV(TVec<TKeyDat<TDat, TKey> >& DatKeyKdV) const;
179    void Swap(THashMP& Hash);
180    void Pack(){Table.Pack();}
181  };
182  template<class TKey, class TDat, class THashFunc>
183  const unsigned int THashMP<TKey, TDat, THashFunc>::HashPrimeT[HashPrimes]={
184    3ul, 5ul, 11ul, 23ul,
185    53ul,         97ul,         193ul,       389ul,       769ul,
186    1543ul,       3079ul,       6151ul,      12289ul,     24593ul,
187    49157ul,      98317ul,      196613ul,    393241ul,    786433ul,
188    1572869ul,    3145739ul,    6291469ul,   12582917ul,  25165843ul,
189    50331653ul,   100663319ul,  201326611ul, 402653189ul, 805306457ul,
190    1610612741ul, 3221225473ul, 4294967291ul
191  };
192  template<class TKey, class TDat, class THashFunc>
193  uint THashMP<TKey, TDat, THashFunc>::GetNextPrime(const uint& Val) const {
194    const uint* f=(const uint*)HashPrimeT, *m, *l=(const uint*)HashPrimeT + (int)HashPrimes;
195    int h, len = (int)HashPrimes;
196    while (len > 0) {
197      h = len >> 1;  m = f + h;
198      if (*m < Val) { f = m;  f++;  len = len - h - 1; }
199      else len = h;
200    }
201    return f == l ? *(l - 1) : *f;
202  }
203  template<class TKey, class TDat, class THashFunc>
204  bool THashMP<TKey, TDat, THashFunc>::operator==(const THashMP& Hash) const {
205    if (Len() != Hash.Len()) { return false; }
206    for (int i = FFirstKeyId(); FNextKeyId(i); ) {
207      const TKey& Key = GetKey(i);
208      if (! Hash.IsKey(Key)) { return false; }
209      if (GetDat(Key) != Hash.GetDat(Key)) { return false; }
210    }
211    return true;
212  }
213  template<class TKey, class TDat, class THashFunc>
214  int THashMP<TKey, TDat, THashFunc>::AddKey(const TKey& Key) {
215    const int BegTableN=abs(Key.GetPrimHashCd()%Table.Len());
216    const int HashCd=abs(Key.GetSecHashCd());
217    int TableN = BegTableN;
218    while (Table[TableN].HashCd != -1 || 
219      (!__sync_bool_compare_and_swap(&Table[TableN].HashCd.Val, -1, HashCd))) {
220      TableN = (TableN + 1) % Table.Len();    
221    }
222    Table[TableN].Key = Key;
223    __sync_fetch_and_add(&NumVals.Val, 1);
224    return TableN;
225  }
226  template<class TKey, class TDat, class THashFunc>
227  int THashMP<TKey, TDat, THashFunc>::AddKey11(const int& BegTableN, const TKey& Key, bool& Found) {
228    const int Length = Table.Len();
229    const int HashCd=abs(Key.GetSecHashCd());
230    int TableN = BegTableN;
231    Found = false;
232    do {
233      if (Table[TableN].HashCd.Val != -1) {
234        if (Table[TableN].Key == Key) {
235          Found = true;
236          return TableN;
237        }
238      } else if (__sync_bool_compare_and_swap(&Table[TableN].HashCd.Val, -1, HashCd)) {
239        break;
240      }
241      TableN++;
242      if (TableN >= Length) {
243        TableN = 0;
244      }
245    } while (1);
246    Table[TableN].Key = Key;
247    return TableN;
248  }
249  template<class TKey, class TDat, class THashFunc>
250  int THashMP<TKey, TDat, THashFunc>::AddKey12(const int& BegTableN, const TKey& Key, bool& Found) {
251    const int Length = Table.Len();
252    int TableN = BegTableN;
253    do {
254      int HashCd = Table[TableN].HashCd.Val;
255      if (HashCd == -1) {
256        if (__sync_bool_compare_and_swap(&Table[TableN].HashCd.Val, -1, 1)) {
257          break;
258        }
259      } else {
260        if (HashCd != 2) {
261          while (!__sync_bool_compare_and_swap(&Table[TableN].HashCd.Val, 2, 2)) {
262            usleep(20);
263          }
264        }
265        if (Table[TableN].Key == Key) {
266          Found = true;
267          return TableN;
268        }
269        TableN++;
270        if (TableN >= Length) {
271          TableN = 0;
272        }
273      }
274    } while (1);
275    Table[TableN].Key = Key;
276    Table[TableN].HashCd.Val = 2;
277    Found = false;
278    return TableN;
279  }
280  template<class TKey, class TDat, class THashFunc>
281  int THashMP<TKey, TDat, THashFunc>::AddKey13(const int& BegTableN, const TKey& Key) {
282    const int Length = Table.Len();
283    int TableN = BegTableN;
284    do {
285      int HashCd = Table[TableN].HashCd.Val;
286      if (HashCd == -1) {
287        if (__sync_bool_compare_and_swap(&Table[TableN].HashCd.Val, -1, 1)) {
288          break;
289        }
290      } else {
291        TableN++;
292        if (TableN >= Length) {
293          TableN = 0;
294        }
295      }
296    } while (1);
297    Table[TableN].Key = Key;
298    Table[TableN].HashCd.Val = 2;
299    return TableN;
300  }
301  template<class TKey, class TDat, class THashFunc>
302  int THashMP<TKey, TDat, THashFunc>::AddKey1(const TKey& Key, bool& Found) {
303    const int Length = Table.Len();
304    const int BegTableN = abs(Key.GetPrimHashCd() % Length);
305    const int HashCd = abs(Key.GetSecHashCd());
306    int TableN = BegTableN;
307    while (Table[TableN].HashCd.Val != -1) {
308      if (Table[TableN].Key == Key) {
309        Found = true;
310        return TableN;
311      }
312      TableN++;
313      if (TableN >= Length) {
314        TableN = 0;
315      }
316    }
317    NumVals.Val++;
318    Found = false;
319    Table[TableN].HashCd.Val = HashCd;
320    Table[TableN].Key = Key;
321    return TableN;
322  }
323  template<class TKey, class TDat, class THashFunc>
324  int THashMP<TKey, TDat, THashFunc>::AddKey2(const int& BegTableN, const TKey& Key, bool& Found) {
325    const int Length = Table.Len();
326    const int HashCd = abs(Key.GetSecHashCd());
327    int TableN = BegTableN;
328    while (Table[TableN].HashCd.Val != -1) {
329      if (Table[TableN].Key == Key) {
330        Found = true;
331        return TableN;
332      }
333      TableN++;
334      if (TableN >= Length) {
335        TableN = 0;
336      }
337    }
338    Found = false;
339    Table[TableN].HashCd.Val = HashCd;
340    Table[TableN].Key = Key;
341    return TableN;
342  }
343  template<class TKey, class TDat, class THashFunc>
344  int THashMP<TKey, TDat, THashFunc>::GetKeyId(const TKey& Key) const {
345    const int BegTableN=abs(Key.GetPrimHashCd()%Table.Len());
346    int TableN = BegTableN;
347    while (Table[TableN].HashCd != -1) {
348      if (Table[TableN].Key == Key) { return TableN; }
349      TableN = (TableN + 1) % Table.Len();
350      if (TableN == BegTableN) { return -1; }
351    }
352    return -1;
353  }
354  template<class TKey, class TDat, class THashFunc>
355  void THashMP<TKey, TDat, THashFunc>::Clr(const bool& DoDel){
356    if (DoDel){
357      Table.Clr();
358    } else {
359      Table.PutAll(TPHKeyDat());
360    }
361    NumVals = TInt(0);
362  }
363  template<class TKey, class TDat, class THashFunc>
364  bool THashMP<TKey, TDat, THashFunc>::FNextKeyId(int& KeyId) const {
365    do {KeyId++;} while ((KeyId<Table.Len())&&(Table[KeyId].HashCd==-1));
366    return KeyId<Table.Len();
367  }
368  template<class TKey, class TDat, class THashFunc>
369  void THashMP<TKey, TDat, THashFunc>::GetKeyV(TVec<TKey>& KeyV) const {
370    KeyV.Gen(Len(), 0);
371    int KeyId=FFirstKeyId();
372    while (FNextKeyId(KeyId)){
373      KeyV.Add(GetKey(KeyId));}
374  }
375  template<class TKey, class TDat, class THashFunc>
376  void THashMP<TKey, TDat, THashFunc>::GetDatV(TVec<TDat>& DatV) const {
377    DatV.Gen(Len(), 0);
378    int KeyId=FFirstKeyId();
379    while (FNextKeyId(KeyId)){
380      DatV.Add(GetPHashKeyDat(KeyId).Dat);}
381  }
382  template<class TKey, class TDat, class THashFunc>
383  void THashMP<TKey, TDat, THashFunc>::GetKeyDatPrV(TVec<TPair<TKey, TDat> >& KeyDatPrV) const {
384    KeyDatPrV.Gen(Len(), 0);
385    TKey Key; TDat Dat;
386    int KeyId=FFirstKeyId();
387    while (FNextKeyId(KeyId)){
388      GetKeyDat(KeyId, Key, Dat);
389      KeyDatPrV.Add(TPair<TKey, TDat>(Key, Dat));
390    }
391  }
392  template<class TKey, class TDat, class THashFunc>
393  void THashMP<TKey, TDat, THashFunc>::GetDatKeyPrV(TVec<TPair<TDat, TKey> >& DatKeyPrV) const {
394    DatKeyPrV.Gen(Len(), 0);
395    TKey Key; TDat Dat;
396    int KeyId=FFirstKeyId();
397    while (FNextKeyId(KeyId)){
398      GetKeyDat(KeyId, Key, Dat);
399      DatKeyPrV.Add(TPair<TDat, TKey>(Dat, Key));
400    }
401  }
402  template<class TKey, class TDat, class THashFunc>
403  void THashMP<TKey, TDat, THashFunc>::GetKeyDatKdV(TVec<TKeyDat<TKey, TDat> >& KeyDatKdV) const {
404    KeyDatKdV.Gen(Len(), 0);
405    TKey Key; TDat Dat;
406    int KeyId=FFirstKeyId();
407    while (FNextKeyId(KeyId)){
408      GetKeyDat(KeyId, Key, Dat);
409      KeyDatKdV.Add(TKeyDat<TKey, TDat>(Key, Dat));
410    }
411  }
412  template<class TKey, class TDat, class THashFunc>
413  void THashMP<TKey, TDat, THashFunc>::GetDatKeyKdV(TVec<TKeyDat<TDat, TKey> >& DatKeyKdV) const {
414    DatKeyKdV.Gen(Len(), 0);
415    TKey Key; TDat Dat;
416    int KeyId=FFirstKeyId();
417    while (FNextKeyId(KeyId)){
418      GetKeyDat(KeyId, Key, Dat);
419      DatKeyKdV.Add(TKeyDat<TDat, TKey>(Dat, Key));
420    }
421  }
422  template<class TKey, class TDat, class THashFunc>
423  void THashMP<TKey, TDat, THashFunc>::Swap(THashMP& Hash) {
424    if (this!=&Hash){
425      Table.Swap(Hash.Table);
426      ::Swap(NumVals, Hash.NumVals);
427    }
428  }
429  template<class TKey, class TDat, class THashFunc>
430  int THashMP<TKey, TDat, THashFunc>::GetRndKeyId(TRnd& Rnd) const  {
431    printf("*** ERROR *** THashMP<TKey, TDat, THashFunc>::GetRndKeyId called\n");
432    return 0;
433  }
434  template<class TKey, class TDat, class THashFunc>
435  int THashMP<TKey, TDat, THashFunc>::GetRndKeyId(TRnd& Rnd, const double& EmptyFrac) {
436    printf("*** ERROR *** THashMP<TKey, TDat, THashFunc>::GetRndKeyId called\n");
437    return 0;
438  }
439  #endif 
440  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-yahoodm.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-hashmp.h</div>
                </div>
                <div class="column column_space"><pre><code>50      return new TYTbVar(WordStr, TTbVarType::GetFltVarType());}
51    int GetVarN(const TStr& Nm){return WordIdToVarNV[YBs->GetWordId(Nm)];}
52    int AddTup(const TStr&){Fail; return -1;}
53    int GetTups(){return TupNToDocIdV.Len();}
</pre></code></div>
                <div class="column column_space"><pre><code>141    void SetLen(const int& Length) {NumVals=Length;}
142    int GetMxKeyIds() const {return Table.Len();}
143    int GetReservedKeyIds() const {return Table.Reserved();}
144    int AddKey(const TKey& Key);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    