
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 67, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-clst.h</h3>
            <pre><code>1  #ifndef CLST_H
2  #define CLST_H
3  #include "list.h"
4  #include "lsterr.h"
5  #include "serialis.h"
6  #include <cstdio>
7  namespace tesseract {
8  class CLIST_ITERATOR;
9  class CLIST_LINK {
10    friend class CLIST_ITERATOR;
11    friend class CLIST;
12    CLIST_LINK *next;
13    void *data;
14  public:
15    CLIST_LINK() { 
16      data = next = nullptr;
17    }
18    CLIST_LINK(const CLIST_LINK &) = delete;
19    void operator=(const CLIST_LINK &) = delete;
20  };
21  class TESS_API CLIST {
22    friend class CLIST_ITERATOR;
23    CLIST_LINK *last = nullptr; 
24    CLIST_LINK *First() { 
25      return last != nullptr ? last->next : nullptr;
26    }
27    const CLIST_LINK *First() const { 
28      return last != nullptr ? last->next : nullptr;
29    }
30  public:
31    ~CLIST() { 
32      shallow_clear();
33    }
34    void internal_deep_clear(    
35        void (*zapper)(void *)); 
36    void shallow_clear(); 
37    bool empty() const { 
38      return !last;
39    }
40    bool singleton() const {
41      return last != nullptr ? (last == last->next) : false;
42    }
43    void shallow_copy(      
44        CLIST *from_list) { 
45      last = from_list->last;
46    }
47    void assign_to_sublist(       
48        CLIST_ITERATOR *start_it, 
49        CLIST_ITERATOR *end_it);  
<span onclick='openModal()' class='match'>50    int32_t length() const { 
51      int32_t count = 0;
52      if (last != nullptr) {
53        count = 1;
54        for (auto it = last->next; it != last; it = it->next) {
55          count++;
56        }
57      }
58      return count;
59    }
60    void sort(          
61        int comparator( 
62            const void *, const void *));
63    bool add_sorted(int comparator(const void *, const void *), bool unique, void *new_data);
</span>64    void set_subtract(int comparator(const void *, const void *), bool unique, CLIST *minuend,
65                      CLIST *subtrahend);
66  };
67  class TESS_API CLIST_ITERATOR {
68    friend void CLIST::assign_to_sublist(CLIST_ITERATOR *, CLIST_ITERATOR *);
69    CLIST *list;                  
70    CLIST_LINK *prev;             
71    CLIST_LINK *current;          
72    CLIST_LINK *next;             
73    CLIST_LINK *cycle_pt;         
74    bool ex_current_was_last;     
75    bool ex_current_was_cycle_pt; 
76    bool started_cycling;         
77    CLIST_LINK *extract_sublist(   
78        CLIST_ITERATOR *other_it); 
79  public:
80    CLIST_ITERATOR() { 
81      list = nullptr;
82    } 
83    CLIST_ITERATOR( 
84        CLIST *list_to_iterate);
85    void set_to_list( 
86        CLIST *list_to_iterate);
87    void add_after_then_move( 
88        void *new_data);      
89    void add_after_stay_put( 
90        void *new_data);     
91    void add_before_then_move( 
92        void *new_data);       
93    void add_before_stay_put( 
94        void *new_data);      
95    void add_list_after(     
96        CLIST *list_to_add); 
97    void add_list_before(    
98        CLIST *list_to_add); 
99    void *data() { 
100  #ifndef NDEBUG
101      if (!list) {
102        NO_LIST.error("CLIST_ITERATOR::data", ABORT);
103      }
104  #endif
105      return current->data;
106    }
107    void *data_relative( 
108        int8_t offset);  
109    void *forward(); 
110    void *extract(); 
111    void *move_to_first(); 
112    void *move_to_last(); 
113    void mark_cycle_pt(); 
114    bool empty() const { 
115      return list->empty();
116    }
117    bool current_extracted() const { 
118      return !current;
119    }
120    bool at_first() const; 
121    bool at_last() const; 
122    bool cycled_list() const; 
123    void add_to_end(     
124        void *new_data); 
125    void exchange(                 
126        CLIST_ITERATOR *other_it); 
127    int32_t length() const; 
128    void sort(          
129        int comparator( 
130            const void *, const void *));
131  };
132  inline void CLIST_ITERATOR::set_to_list( 
133      CLIST *list_to_iterate) {
134    list = list_to_iterate;
135    prev = list->last;
136    current = list->First();
137    next = current != nullptr ? current->next : nullptr;
138    cycle_pt = nullptr; 
139    started_cycling = false;
140    ex_current_was_last = false;
141    ex_current_was_cycle_pt = false;
142  }
143  inline CLIST_ITERATOR::CLIST_ITERATOR(CLIST *list_to_iterate) {
144    set_to_list(list_to_iterate);
145  }
146  inline void CLIST_ITERATOR::add_after_then_move( 
147      void *new_data) {
148  #ifndef NDEBUG
149    if (!new_data) {
150      BAD_PARAMETER.error("CLIST_ITERATOR::add_after_then_move", ABORT, "new_data is nullptr");
151    }
152  #endif
153    auto new_element = new CLIST_LINK;
154    new_element->data = new_data;
155    if (list->empty()) {
156      new_element->next = new_element;
157      list->last = new_element;
158      prev = next = new_element;
159    } else {
160      new_element->next = next;
161      if (current) { 
162        current->next = new_element;
163        prev = current;
164        if (current == list->last) {
165          list->last = new_element;
166        }
167      } else { 
168        prev->next = new_element;
169        if (ex_current_was_last) {
170          list->last = new_element;
171        }
172        if (ex_current_was_cycle_pt) {
173          cycle_pt = new_element;
174        }
175      }
176    }
177    current = new_element;
178  }
179  inline void CLIST_ITERATOR::add_after_stay_put( 
180      void *new_data) {
181  #ifndef NDEBUG
182    if (!new_data) {
183      BAD_PARAMETER.error("CLIST_ITERATOR::add_after_stay_put", ABORT, "new_data is nullptr");
184    }
185  #endif
186    auto new_element = new CLIST_LINK;
187    new_element->data = new_data;
188    if (list->empty()) {
189      new_element->next = new_element;
190      list->last = new_element;
191      prev = next = new_element;
192      ex_current_was_last = false;
193      current = nullptr;
194    } else {
195      new_element->next = next;
196      if (current) { 
197        current->next = new_element;
198        if (prev == current) {
199          prev = new_element;
200        }
201        if (current == list->last) {
202          list->last = new_element;
203        }
204      } else { 
205        prev->next = new_element;
206        if (ex_current_was_last) {
207          list->last = new_element;
208          ex_current_was_last = false;
209        }
210      }
211      next = new_element;
212    }
213  }
214  inline void CLIST_ITERATOR::add_before_then_move( 
215      void *new_data) {
216  #ifndef NDEBUG
217    if (!new_data) {
218      BAD_PARAMETER.error("CLIST_ITERATOR::add_before_then_move", ABORT, "new_data is nullptr");
219    }
220  #endif
221    auto new_element = new CLIST_LINK;
222    new_element->data = new_data;
223    if (list->empty()) {
224      new_element->next = new_element;
225      list->last = new_element;
226      prev = next = new_element;
227    } else {
228      prev->next = new_element;
229      if (current) { 
230        new_element->next = current;
231        next = current;
232      } else { 
233        new_element->next = next;
234        if (ex_current_was_last) {
235          list->last = new_element;
236        }
237        if (ex_current_was_cycle_pt) {
238          cycle_pt = new_element;
239        }
240      }
241    }
242    current = new_element;
243  }
244  inline void CLIST_ITERATOR::add_before_stay_put( 
245      void *new_data) {
246  #ifndef NDEBUG
247    if (!new_data) {
248      BAD_PARAMETER.error("CLIST_ITERATOR::add_before_stay_put", ABORT, "new_data is nullptr");
249    }
250  #endif
251    auto new_element = new CLIST_LINK;
252    new_element->data = new_data;
253    if (list->empty()) {
254      new_element->next = new_element;
255      list->last = new_element;
256      prev = next = new_element;
257      ex_current_was_last = true;
258      current = nullptr;
259    } else {
260      prev->next = new_element;
261      if (current) { 
262        new_element->next = current;
263        if (next == current) {
264          next = new_element;
265        }
266      } else { 
267        new_element->next = next;
268        if (ex_current_was_last) {
269          list->last = new_element;
270        }
271      }
272      prev = new_element;
273    }
274  }
275  inline void CLIST_ITERATOR::add_list_after(CLIST *list_to_add) {
276    if (!list_to_add->empty()) {
277      if (list->empty()) {
278        list->last = list_to_add->last;
279        prev = list->last;
280        next = list->First();
281        ex_current_was_last = true;
282        current = nullptr;
283      } else {
284        if (current) { 
285          current->next = list_to_add->First();
286          if (current == list->last) {
287            list->last = list_to_add->last;
288          }
289          list_to_add->last->next = next;
290          next = current->next;
291        } else { 
292          prev->next = list_to_add->First();
293          if (ex_current_was_last) {
294            list->last = list_to_add->last;
295            ex_current_was_last = false;
296          }
297          list_to_add->last->next = next;
298          next = prev->next;
299        }
300      }
301      list_to_add->last = nullptr;
302    }
303  }
304  inline void CLIST_ITERATOR::add_list_before(CLIST *list_to_add) {
305    if (!list_to_add->empty()) {
306      if (list->empty()) {
307        list->last = list_to_add->last;
308        prev = list->last;
309        current = list->First();
310        next = current->next;
311        ex_current_was_last = false;
312      } else {
313        prev->next = list_to_add->First();
314        if (current) { 
315          list_to_add->last->next = current;
316        } else { 
317          list_to_add->last->next = next;
318          if (ex_current_was_last) {
319            list->last = list_to_add->last;
320          }
321          if (ex_current_was_cycle_pt) {
322            cycle_pt = prev->next;
323          }
324        }
325        current = prev->next;
326        next = current->next;
327      }
328      list_to_add->last = nullptr;
329    }
330  }
331  inline void *CLIST_ITERATOR::extract() {
332  #ifndef NDEBUG
333    if (!current) { 
334      NULL_CURRENT.error("CLIST_ITERATOR::extract", ABORT);
335    }
336  #endif
337    if (list->singleton()) {
338      prev = next = list->last = nullptr;
339    } else {
340      prev->next = next; 
341      if (current == list->last) {
342        list->last = prev;
343        ex_current_was_last = true;
344      } else {
345        ex_current_was_last = false;
346      }
347    }
348    ex_current_was_cycle_pt = (current == cycle_pt);
349    auto extracted_data = current->data;
350    delete (current); 
351    current = nullptr;
352    return extracted_data;
353  }
354  inline void *CLIST_ITERATOR::move_to_first() {
355    current = list->First();
356    prev = list->last;
357    next = current != nullptr ? current->next : nullptr;
358    return current != nullptr ? current->data : nullptr;
359  }
360  inline void CLIST_ITERATOR::mark_cycle_pt() {
361  #ifndef NDEBUG
362    if (!list) {
363      NO_LIST.error("CLIST_ITERATOR::mark_cycle_pt", ABORT);
364    }
365  #endif
366    if (current) {
367      cycle_pt = current;
368    } else {
369      ex_current_was_cycle_pt = true;
370    }
371    started_cycling = false;
372  }
373  inline bool CLIST_ITERATOR::at_first() const {
374    return ((list->empty()) || (current == list->First()) ||
375            ((current == nullptr) && (prev == list->last) && 
376             !ex_current_was_last));                         
377  }
378  inline bool CLIST_ITERATOR::at_last() const {
379    return ((list->empty()) || (current == list->last) ||
380            ((current == nullptr) && (prev == list->last) && 
381             ex_current_was_last));                          
382  }
383  inline bool CLIST_ITERATOR::cycled_list() const {
384    return ((list->empty()) || ((current == cycle_pt) && started_cycling));
385  }
386  inline int32_t CLIST_ITERATOR::length() const {
387    return list->length();
388  }
389  inline void CLIST_ITERATOR::sort( 
390      int comparator(               
391          const void *, const void *)) {
392    list->sort(comparator);
393    move_to_first();
394  }
395  inline void CLIST_ITERATOR::add_to_end( 
396      void *new_data) {
397  #ifndef NDEBUG
398    if (!list) {
399      NO_LIST.error("CLIST_ITERATOR::add_to_end", ABORT);
400    }
401    if (!new_data) {
402      BAD_PARAMETER.error("CLIST_ITERATOR::add_to_end", ABORT, "new_data is nullptr");
403    }
404  #endif
405    if (this->at_last()) {
406      this->add_after_stay_put(new_data);
407    } else {
408      if (this->at_first()) {
409        this->add_before_stay_put(new_data);
410        list->last = prev;
411      } else { 
412        auto new_element = new CLIST_LINK;
413        new_element->data = new_data;
414        new_element->next = list->last->next;
415        list->last->next = new_element;
416        list->last = new_element;
417      }
418    }
419  }
420  template <typename CLASSNAME>
421  class X_CLIST : public CLIST {
422  public:
423    X_CLIST() = default;
424    X_CLIST(const X_CLIST &) = delete;
425    X_CLIST &operator=(const X_CLIST &) = delete;
426    void deep_clear() {
427      internal_deep_clear([](void *link) {delete static_cast<CLASSNAME *>(link);});
428    }
429  };
430  #define CLISTIZEH(CLASSNAME)                                    \
431    class CLASSNAME##_CLIST : public X_CLIST<CLASSNAME> {         \
432      using X_CLIST<CLASSNAME>::X_CLIST;                          \
433    };                                                            \
434    struct CLASSNAME##_C_IT : X_ITER<CLIST_ITERATOR, CLASSNAME> { \
435      using X_ITER<CLIST_ITERATOR, CLASSNAME>::X_ITER;            \
436    };
437  } 
438  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-clst.h</h3>
            <pre><code>1  #ifndef CLST_H
2  #define CLST_H
3  #include "list.h"
4  #include "lsterr.h"
5  #include "serialis.h"
6  #include <cstdio>
7  namespace tesseract {
8  class CLIST_ITERATOR;
9  class CLIST_LINK {
10    friend class CLIST_ITERATOR;
11    friend class CLIST;
12    CLIST_LINK *next;
13    void *data;
14  public:
15    CLIST_LINK() { 
16      data = next = nullptr;
17    }
18    CLIST_LINK(const CLIST_LINK &) = delete;
19    void operator=(const CLIST_LINK &) = delete;
20  };
21  class TESS_API CLIST {
22    friend class CLIST_ITERATOR;
23    CLIST_LINK *last = nullptr; 
24    CLIST_LINK *First() { 
25      return last != nullptr ? last->next : nullptr;
26    }
27    const CLIST_LINK *First() const { 
28      return last != nullptr ? last->next : nullptr;
29    }
30  public:
31    ~CLIST() { 
32      shallow_clear();
33    }
34    void internal_deep_clear(    
35        void (*zapper)(void *)); 
36    void shallow_clear(); 
37    bool empty() const { 
38      return !last;
39    }
40    bool singleton() const {
41      return last != nullptr ? (last == last->next) : false;
42    }
43    void shallow_copy(      
44        CLIST *from_list) { 
45      last = from_list->last;
46    }
47    void assign_to_sublist(       
48        CLIST_ITERATOR *start_it, 
49        CLIST_ITERATOR *end_it);  
<span onclick='openModal()' class='match'>50    int32_t length() const { 
51      int32_t count = 0;
52      if (last != nullptr) {
53        count = 1;
54        for (auto it = last->next; it != last; it = it->next) {
55          count++;
56        }
57      }
58      return count;
59    }
60    void sort(          
61        int comparator( 
62            const void *, const void *));
63    bool add_sorted(int comparator(const void *, const void *), bool unique, void *new_data);
</span>64    void set_subtract(int comparator(const void *, const void *), bool unique, CLIST *minuend,
65                      CLIST *subtrahend);
66  };
67  class TESS_API CLIST_ITERATOR {
68    friend void CLIST::assign_to_sublist(CLIST_ITERATOR *, CLIST_ITERATOR *);
69    CLIST *list;                  
70    CLIST_LINK *prev;             
71    CLIST_LINK *current;          
72    CLIST_LINK *next;             
73    CLIST_LINK *cycle_pt;         
74    bool ex_current_was_last;     
75    bool ex_current_was_cycle_pt; 
76    bool started_cycling;         
77    CLIST_LINK *extract_sublist(   
78        CLIST_ITERATOR *other_it); 
79  public:
80    CLIST_ITERATOR() { 
81      list = nullptr;
82    } 
83    CLIST_ITERATOR( 
84        CLIST *list_to_iterate);
85    void set_to_list( 
86        CLIST *list_to_iterate);
87    void add_after_then_move( 
88        void *new_data);      
89    void add_after_stay_put( 
90        void *new_data);     
91    void add_before_then_move( 
92        void *new_data);       
93    void add_before_stay_put( 
94        void *new_data);      
95    void add_list_after(     
96        CLIST *list_to_add); 
97    void add_list_before(    
98        CLIST *list_to_add); 
99    void *data() { 
100  #ifndef NDEBUG
101      if (!list) {
102        NO_LIST.error("CLIST_ITERATOR::data", ABORT);
103      }
104  #endif
105      return current->data;
106    }
107    void *data_relative( 
108        int8_t offset);  
109    void *forward(); 
110    void *extract(); 
111    void *move_to_first(); 
112    void *move_to_last(); 
113    void mark_cycle_pt(); 
114    bool empty() const { 
115      return list->empty();
116    }
117    bool current_extracted() const { 
118      return !current;
119    }
120    bool at_first() const; 
121    bool at_last() const; 
122    bool cycled_list() const; 
123    void add_to_end(     
124        void *new_data); 
125    void exchange(                 
126        CLIST_ITERATOR *other_it); 
127    int32_t length() const; 
128    void sort(          
129        int comparator( 
130            const void *, const void *));
131  };
132  inline void CLIST_ITERATOR::set_to_list( 
133      CLIST *list_to_iterate) {
134    list = list_to_iterate;
135    prev = list->last;
136    current = list->First();
137    next = current != nullptr ? current->next : nullptr;
138    cycle_pt = nullptr; 
139    started_cycling = false;
140    ex_current_was_last = false;
141    ex_current_was_cycle_pt = false;
142  }
143  inline CLIST_ITERATOR::CLIST_ITERATOR(CLIST *list_to_iterate) {
144    set_to_list(list_to_iterate);
145  }
146  inline void CLIST_ITERATOR::add_after_then_move( 
147      void *new_data) {
148  #ifndef NDEBUG
149    if (!new_data) {
150      BAD_PARAMETER.error("CLIST_ITERATOR::add_after_then_move", ABORT, "new_data is nullptr");
151    }
152  #endif
153    auto new_element = new CLIST_LINK;
154    new_element->data = new_data;
155    if (list->empty()) {
156      new_element->next = new_element;
157      list->last = new_element;
158      prev = next = new_element;
159    } else {
160      new_element->next = next;
161      if (current) { 
162        current->next = new_element;
163        prev = current;
164        if (current == list->last) {
165          list->last = new_element;
166        }
167      } else { 
168        prev->next = new_element;
169        if (ex_current_was_last) {
170          list->last = new_element;
171        }
172        if (ex_current_was_cycle_pt) {
173          cycle_pt = new_element;
174        }
175      }
176    }
177    current = new_element;
178  }
179  inline void CLIST_ITERATOR::add_after_stay_put( 
180      void *new_data) {
181  #ifndef NDEBUG
182    if (!new_data) {
183      BAD_PARAMETER.error("CLIST_ITERATOR::add_after_stay_put", ABORT, "new_data is nullptr");
184    }
185  #endif
186    auto new_element = new CLIST_LINK;
187    new_element->data = new_data;
188    if (list->empty()) {
189      new_element->next = new_element;
190      list->last = new_element;
191      prev = next = new_element;
192      ex_current_was_last = false;
193      current = nullptr;
194    } else {
195      new_element->next = next;
196      if (current) { 
197        current->next = new_element;
198        if (prev == current) {
199          prev = new_element;
200        }
201        if (current == list->last) {
202          list->last = new_element;
203        }
204      } else { 
205        prev->next = new_element;
206        if (ex_current_was_last) {
207          list->last = new_element;
208          ex_current_was_last = false;
209        }
210      }
211      next = new_element;
212    }
213  }
214  inline void CLIST_ITERATOR::add_before_then_move( 
215      void *new_data) {
216  #ifndef NDEBUG
217    if (!new_data) {
218      BAD_PARAMETER.error("CLIST_ITERATOR::add_before_then_move", ABORT, "new_data is nullptr");
219    }
220  #endif
221    auto new_element = new CLIST_LINK;
222    new_element->data = new_data;
223    if (list->empty()) {
224      new_element->next = new_element;
225      list->last = new_element;
226      prev = next = new_element;
227    } else {
228      prev->next = new_element;
229      if (current) { 
230        new_element->next = current;
231        next = current;
232      } else { 
233        new_element->next = next;
234        if (ex_current_was_last) {
235          list->last = new_element;
236        }
237        if (ex_current_was_cycle_pt) {
238          cycle_pt = new_element;
239        }
240      }
241    }
242    current = new_element;
243  }
244  inline void CLIST_ITERATOR::add_before_stay_put( 
245      void *new_data) {
246  #ifndef NDEBUG
247    if (!new_data) {
248      BAD_PARAMETER.error("CLIST_ITERATOR::add_before_stay_put", ABORT, "new_data is nullptr");
249    }
250  #endif
251    auto new_element = new CLIST_LINK;
252    new_element->data = new_data;
253    if (list->empty()) {
254      new_element->next = new_element;
255      list->last = new_element;
256      prev = next = new_element;
257      ex_current_was_last = true;
258      current = nullptr;
259    } else {
260      prev->next = new_element;
261      if (current) { 
262        new_element->next = current;
263        if (next == current) {
264          next = new_element;
265        }
266      } else { 
267        new_element->next = next;
268        if (ex_current_was_last) {
269          list->last = new_element;
270        }
271      }
272      prev = new_element;
273    }
274  }
275  inline void CLIST_ITERATOR::add_list_after(CLIST *list_to_add) {
276    if (!list_to_add->empty()) {
277      if (list->empty()) {
278        list->last = list_to_add->last;
279        prev = list->last;
280        next = list->First();
281        ex_current_was_last = true;
282        current = nullptr;
283      } else {
284        if (current) { 
285          current->next = list_to_add->First();
286          if (current == list->last) {
287            list->last = list_to_add->last;
288          }
289          list_to_add->last->next = next;
290          next = current->next;
291        } else { 
292          prev->next = list_to_add->First();
293          if (ex_current_was_last) {
294            list->last = list_to_add->last;
295            ex_current_was_last = false;
296          }
297          list_to_add->last->next = next;
298          next = prev->next;
299        }
300      }
301      list_to_add->last = nullptr;
302    }
303  }
304  inline void CLIST_ITERATOR::add_list_before(CLIST *list_to_add) {
305    if (!list_to_add->empty()) {
306      if (list->empty()) {
307        list->last = list_to_add->last;
308        prev = list->last;
309        current = list->First();
310        next = current->next;
311        ex_current_was_last = false;
312      } else {
313        prev->next = list_to_add->First();
314        if (current) { 
315          list_to_add->last->next = current;
316        } else { 
317          list_to_add->last->next = next;
318          if (ex_current_was_last) {
319            list->last = list_to_add->last;
320          }
321          if (ex_current_was_cycle_pt) {
322            cycle_pt = prev->next;
323          }
324        }
325        current = prev->next;
326        next = current->next;
327      }
328      list_to_add->last = nullptr;
329    }
330  }
331  inline void *CLIST_ITERATOR::extract() {
332  #ifndef NDEBUG
333    if (!current) { 
334      NULL_CURRENT.error("CLIST_ITERATOR::extract", ABORT);
335    }
336  #endif
337    if (list->singleton()) {
338      prev = next = list->last = nullptr;
339    } else {
340      prev->next = next; 
341      if (current == list->last) {
342        list->last = prev;
343        ex_current_was_last = true;
344      } else {
345        ex_current_was_last = false;
346      }
347    }
348    ex_current_was_cycle_pt = (current == cycle_pt);
349    auto extracted_data = current->data;
350    delete (current); 
351    current = nullptr;
352    return extracted_data;
353  }
354  inline void *CLIST_ITERATOR::move_to_first() {
355    current = list->First();
356    prev = list->last;
357    next = current != nullptr ? current->next : nullptr;
358    return current != nullptr ? current->data : nullptr;
359  }
360  inline void CLIST_ITERATOR::mark_cycle_pt() {
361  #ifndef NDEBUG
362    if (!list) {
363      NO_LIST.error("CLIST_ITERATOR::mark_cycle_pt", ABORT);
364    }
365  #endif
366    if (current) {
367      cycle_pt = current;
368    } else {
369      ex_current_was_cycle_pt = true;
370    }
371    started_cycling = false;
372  }
373  inline bool CLIST_ITERATOR::at_first() const {
374    return ((list->empty()) || (current == list->First()) ||
375            ((current == nullptr) && (prev == list->last) && 
376             !ex_current_was_last));                         
377  }
378  inline bool CLIST_ITERATOR::at_last() const {
379    return ((list->empty()) || (current == list->last) ||
380            ((current == nullptr) && (prev == list->last) && 
381             ex_current_was_last));                          
382  }
383  inline bool CLIST_ITERATOR::cycled_list() const {
384    return ((list->empty()) || ((current == cycle_pt) && started_cycling));
385  }
386  inline int32_t CLIST_ITERATOR::length() const {
387    return list->length();
388  }
389  inline void CLIST_ITERATOR::sort( 
390      int comparator(               
391          const void *, const void *)) {
392    list->sort(comparator);
393    move_to_first();
394  }
395  inline void CLIST_ITERATOR::add_to_end( 
396      void *new_data) {
397  #ifndef NDEBUG
398    if (!list) {
399      NO_LIST.error("CLIST_ITERATOR::add_to_end", ABORT);
400    }
401    if (!new_data) {
402      BAD_PARAMETER.error("CLIST_ITERATOR::add_to_end", ABORT, "new_data is nullptr");
403    }
404  #endif
405    if (this->at_last()) {
406      this->add_after_stay_put(new_data);
407    } else {
408      if (this->at_first()) {
409        this->add_before_stay_put(new_data);
410        list->last = prev;
411      } else { 
412        auto new_element = new CLIST_LINK;
413        new_element->data = new_data;
414        new_element->next = list->last->next;
415        list->last->next = new_element;
416        list->last = new_element;
417      }
418    }
419  }
420  template <typename CLASSNAME>
421  class X_CLIST : public CLIST {
422  public:
423    X_CLIST() = default;
424    X_CLIST(const X_CLIST &) = delete;
425    X_CLIST &operator=(const X_CLIST &) = delete;
426    void deep_clear() {
427      internal_deep_clear([](void *link) {delete static_cast<CLASSNAME *>(link);});
428    }
429  };
430  #define CLISTIZEH(CLASSNAME)                                    \
431    class CLASSNAME##_CLIST : public X_CLIST<CLASSNAME> {         \
432      using X_CLIST<CLASSNAME>::X_CLIST;                          \
433    };                                                            \
434    struct CLASSNAME##_C_IT : X_ITER<CLIST_ITERATOR, CLASSNAME> { \
435      using X_ITER<CLIST_ITERATOR, CLASSNAME>::X_ITER;            \
436    };
437  } 
438  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-clst.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-clst.h</div>
                </div>
                <div class="column column_space"><pre><code>50    int32_t length() const { 
51      int32_t count = 0;
52      if (last != nullptr) {
53        count = 1;
54        for (auto it = last->next; it != last; it = it->next) {
55          count++;
56        }
57      }
58      return count;
59    }
60    void sort(          
61        int comparator( 
62            const void *, const void *));
63    bool add_sorted(int comparator(const void *, const void *), bool unique, void *new_data);
</pre></code></div>
                <div class="column column_space"><pre><code>50    int32_t length() const { 
51      int32_t count = 0;
52      if (last != nullptr) {
53        count = 1;
54        for (auto it = last->next; it != last; it = it->next) {
55          count++;
56        }
57      }
58      return count;
59    }
60    void sort(          
61        int comparator( 
62            const void *, const void *));
63    bool add_sorted(int comparator(const void *, const void *), bool unique, void *new_data);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    