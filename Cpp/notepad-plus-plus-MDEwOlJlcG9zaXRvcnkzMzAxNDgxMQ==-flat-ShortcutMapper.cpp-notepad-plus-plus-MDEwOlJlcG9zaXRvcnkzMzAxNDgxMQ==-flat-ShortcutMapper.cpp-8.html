
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 23, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ShortcutMapper.cpp</h3>
            <pre><code>1  #include &quot;ShortcutMapper.h&quot;
2  #include &quot;Notepad_plus.h&quot;
3  using namespace std;
4  void ShortcutMapper::initTabs()
5  {
6  	HWND hTab = _hTabCtrl = ::GetDlgItem(_hSelf, IDC_BABYGRID_TABBAR);
7  	NppDarkMode::subclassTabControl(hTab);
8  	TCITEM tie{};
9  	tie.mask = TCIF_TEXT;
10  	for (size_t i = 0; i &lt; _nbTab; ++i)
11  	{
12  		_tabNames[i] = getTabString(i);
13  		tie.pszText = const_cast&lt;LPWSTR&gt;(_tabNames[i].c_str());
14  		::SendMessage(hTab, TCM_INSERTITEM, i, reinterpret_cast&lt;LPARAM&gt;(&amp;tie));
15  	}
16      TabCtrl_SetCurSel(_hTabCtrl, int(_currentState));
17  	RECT rcTab{};
18  	WINDOWPLACEMENT wp{};
19  	wp.length = sizeof(wp);
20  	::GetWindowPlacement(hTab, &amp;wp);
21  	::SendMessage(hTab, TCM_GETITEMRECT, 0, reinterpret_cast&lt;LPARAM&gt;(&amp;rcTab));
22  	wp.rcNormalPosition.bottom = NppParameters::getInstance()._dpiManager.scaleY(30);
23  	wp.rcNormalPosition.top = wp.rcNormalPosition.bottom - rcTab.bottom;
24  	::SetWindowPlacement(hTab, &amp;wp);
25  }
26  void ShortcutMapper::getClientRect(RECT &amp; rc) const 
27  {
28  		Window::getClientRect(rc);
29  		RECT tabRect{}, btnRect{};
30  		::GetClientRect(::GetDlgItem(_hSelf, IDC_BABYGRID_TABBAR), &amp;tabRect);
31  		int tabH = tabRect.bottom - tabRect.top;
32  		int paddingTop = tabH / 2;
33  		rc.top += tabH + paddingTop;
34  		RECT infoRect{}, filterRect{};
35  		::GetClientRect(::GetDlgItem(_hSelf, IDC_BABYGRID_INFO), &amp;infoRect);
36  		::GetClientRect(::GetDlgItem(_hSelf, IDC_BABYGRID_FILTER), &amp;filterRect);
37  		::GetClientRect(::GetDlgItem(_hSelf, IDOK), &amp;btnRect);
38  		int infoH = infoRect.bottom - infoRect.top;
39  		int filterH = filterRect.bottom - filterRect.top;
40  		int btnH = btnRect.bottom - btnRect.top;
41  		int paddingBottom = btnH + NppParameters::getInstance()._dpiManager.scaleY(16);
42  		rc.bottom -= btnH + filterH + infoH + paddingBottom;
43  		rc.left += NppParameters::getInstance()._dpiManager.scaleX(5);
44  		rc.right -= NppParameters::getInstance()._dpiManager.scaleX(5);
45  }
46  generic_string ShortcutMapper::getTabString(size_t i) const
47  {
48  	if (i &gt;= _nbTab)
49  		return TEXT(&quot;&quot;);
50  	NativeLangSpeaker* nativeLangSpeaker = NppParameters::getInstance().getNativeLangSpeaker();
51  	switch (i)
52  	{
53  		case 1:
54  			return nativeLangSpeaker-&gt;getShortcutMapperLangStr(&quot;MacrosTab&quot;, TEXT(&quot;Macros&quot;));
55  		case 2:
56  			return nativeLangSpeaker-&gt;getShortcutMapperLangStr(&quot;RunCommandsTab&quot;, TEXT(&quot;Run commands&quot;));
57  		case 3:
58  			return nativeLangSpeaker-&gt;getShortcutMapperLangStr(&quot;PluginCommandsTab&quot;, TEXT(&quot;Plugin commands&quot;));
59  		case 4:
60  			return nativeLangSpeaker-&gt;getShortcutMapperLangStr(&quot;ScintillaCommandsTab&quot;, TEXT(&quot;Scintilla commands&quot;));
61  		default: 
62  			return nativeLangSpeaker-&gt;getShortcutMapperLangStr(&quot;MainMenuTab&quot;, TEXT(&quot;Main menu&quot;));
63  	}
64  }
65  void ShortcutMapper::initBabyGrid()
66  {
67  	RECT rect{};
68  	getClientRect(rect);
69  	_lastHomeRow.resize(5, 1);
70  	_lastCursorRow.resize(5, 1);
71  	_hGridFonts.resize(MAX_GRID_FONTS);
72  	_hGridFonts.at(GFONT_HEADER) = ::CreateFont(
73  		NppParameters::getInstance()._dpiManager.scaleY(18), 0, 0, 0, FW_BOLD,
74  		FALSE, FALSE, FALSE, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH,
75  		TEXT(&quot;MS Shell Dlg&quot;));
76  	_hGridFonts.at(GFONT_ROWS) = ::CreateFont(
77  		NppParameters::getInstance()._dpiManager.scaleY(16), 0, 0, 0, FW_NORMAL,
78  		FALSE, FALSE, FALSE, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH,
79  		TEXT(&quot;MS Shell Dlg&quot;));
80  	_babygrid.init(_hInst, _hSelf, IDD_BABYGRID_ID1);
81  	NppDarkMode::setDarkScrollBar(_babygrid.getHSelf());
82  	_babygrid.setHeaderFont(_hGridFonts.at(GFONT_HEADER));
83  	_babygrid.setRowFont(_hGridFonts.at(GFONT_ROWS));
84  	_babygrid.reSizeToWH(rect);
85  	_babygrid.hideCursor();
86  	_babygrid.makeColAutoWidth(true);
87  	_babygrid.setAutoRow(true);
88  	_babygrid.setColsNumbered(false);
89  	_babygrid.setColWidth(0, NppParameters::getInstance()._dpiManager.scaleX(30));  
90  	_babygrid.setHeaderHeight(NppParameters::getInstance()._dpiManager.scaleY(21));
91  	_babygrid.setRowHeight(NppParameters::getInstance()._dpiManager.scaleY(21));
92  	if (NppDarkMode::isEnabled())
93  	{
94  		_babygrid.setTextColor(NppDarkMode::getDarkerTextColor());
95  		_babygrid.setHighlightTextColor(NppDarkMode::getTextColor());
96  		_babygrid.setTitleTextColor(NppDarkMode::getTextColor());
97  		_babygrid.setUnprotectColor(NppDarkMode::getBackgroundColor());
98  		_babygrid.setTitleColor(NppDarkMode::getBackgroundColor());
99  		_babygrid.setBackgroundColor(NppDarkMode::getDarkerBackgroundColor());
100  		_babygrid.setHighlightColor(NppDarkMode::getHotBackgroundColor());
101  		_babygrid.setHighlightColorNoFocus(NppDarkMode::getSofterBackgroundColor());
102  		_babygrid.setProtectColor(NppDarkMode::getErrorBackgroundColor());
103  		_babygrid.setHighlightColorProtect(RGB(244, 10, 20));
104  		_babygrid.setHighlightColorProtectNoFocus(RGB(230, 100, 110));
105  		_babygrid.setGridlinesColor(NppDarkMode::getEdgeColor());
106  		_babygrid.setTitleGridlinesColor(NppDarkMode::getHotEdgeColor());
107  	}
108  	else
109  	{
110  		_babygrid.setTextColor(RGB(0, 0, 0));
111  		_babygrid.setHighlightTextColor(RGB(255, 255, 255));
112  		_babygrid.setTitleTextColor(RGB(0, 0, 0));
113  		_babygrid.setUnprotectColor(RGB(255, 255, 255));
114  		_babygrid.setTitleColor(::GetSysColor(COLOR_BTNFACE));
115  		_babygrid.setBackgroundColor(::GetSysColor(COLOR_BTNFACE));
116  		_babygrid.setHighlightColor(RGB(0, 0, 128));
117  		_babygrid.setHighlightColorNoFocus(RGB(200, 200, 210));
118  		_babygrid.setProtectColor(RGB(255, 130, 120));
119  		_babygrid.setHighlightColorProtect(RGB(244, 10, 20));
120  		_babygrid.setHighlightColorProtectNoFocus(RGB(230, 194, 190));
121  		_babygrid.setGridlinesColor(RGB(220, 220, 220));
122  		_babygrid.setTitleGridlinesColor(RGB(120, 120, 120));
123  	}
124  	NativeLangSpeaker* nativeLangSpeaker = NppParameters::getInstance().getNativeLangSpeaker();
125  	nativeLangSpeaker-&gt;changeDlgLang(_hSelf, &quot;ShortcutMapper&quot;);
126  	_conflictInfoOk = nativeLangSpeaker-&gt;getShortcutMapperLangStr(&quot;ConflictInfoOk&quot;, TEXT(&quot;No shortcut conflicts for this item.&quot;));
127  	_conflictInfoEditing = nativeLangSpeaker-&gt;getShortcutMapperLangStr(&quot;ConflictInfoEditing&quot;, TEXT(&quot;No conflicts . . .&quot;));
128  }
129  generic_string ShortcutMapper::getTextFromCombo(HWND hCombo)
130  {
131  	const int NB_MAX(128);
132  	TCHAR str[NB_MAX](TEXT(&quot;\0&quot;));
133  	::SendMessage(hCombo, WM_GETTEXT, NB_MAX, reinterpret_cast&lt;LPARAM&gt;(str));
134  	generic_string res(str);
135  	return stringToLower(res);
136  }
137  bool ShortcutMapper::isFilterValid(Shortcut sc)
138  {
139  	if (_shortcutFilter.empty())
140  		return true;
141  	wstring shortcut_name = stringToLower(string2wstring(sc.getName(), CP_UTF8));
142  	wstring shortcut_value = stringToLower(string2wstring(sc.toString(), CP_UTF8));
143  	return (shortcut_name.find(_shortcutFilter) != std::string::npos) || 
144  		(shortcut_value.find(_shortcutFilter) != std::string::npos);
145  }
146  bool ShortcutMapper::isFilterValid(PluginCmdShortcut sc)
147  {
148  	Shortcut shortcut = sc;
149  	bool match = false;
150  	wstring module_name = stringToLower(string2wstring(sc.getModuleName(), CP_UTF8));
151  	if (isFilterValid(shortcut)){
152  		return true;
153  	}
154  	size_t match_pos = module_name.find(_shortcutFilter);
155  	if (match_pos != std::string::npos){
156  		match = true;
157  	}
158  	return match;
159  }
160  void ShortcutMapper::fillOutBabyGrid()
161  {
162  	NppParameters&amp; nppParam = NppParameters::getInstance();
163  	_babygrid.clear();
164  	_babygrid.setInitialContent(true);
165  	_shortcutIndex.clear();
166  	size_t nbItems = 0;
167  	NativeLangSpeaker* nativeLangSpeaker = nppParam.getNativeLangSpeaker();
168  	generic_string nameStr = nativeLangSpeaker-&gt;getShortcutMapperLangStr(&quot;ColumnName&quot;, TEXT(&quot;Name&quot;));
169  	generic_string shortcutStr = nativeLangSpeaker-&gt;getShortcutMapperLangStr(&quot;ColumnShortcut&quot;, TEXT(&quot;Shortcut&quot;));
170  	_babygrid.setText(0, 1, nameStr.c_str());
171  	_babygrid.setText(0, 2, shortcutStr.c_str());
172  	switch(_currentState)
173  	{
174  		case STATE_MENU:
175  		{
176  			nbItems = nppParam.getUserShortcuts().size();
177  			_babygrid.setLineColNumber(nbItems, 3);
178  			generic_string categoryStr = nativeLangSpeaker-&gt;getShortcutMapperLangStr(&quot;ColumnCategory&quot;, TEXT(&quot;Category&quot;));
179  			_babygrid.setText(0, 3, categoryStr.c_str());
180  		}
181  		break;
182  		case STATE_MACRO:
183  		{
184  			nbItems = nppParam.getMacroList().size();
185  			_babygrid.setLineColNumber(nbItems, 2);
186  		}
187  		break;
188  		case STATE_USER:
189  		{
190  			nbItems = nppParam.getUserCommandList().size();
191  			_babygrid.setLineColNumber(nbItems, 2);
192  		}
193  		break;
194  		case STATE_PLUGIN:
195  		{
196  			nbItems = nppParam.getPluginCommandList().size();
197  			_babygrid.setLineColNumber(nbItems, 3);
198  			generic_string pluginStr = nativeLangSpeaker-&gt;getShortcutMapperLangStr(&quot;ColumnPlugin&quot;, TEXT(&quot;Plugin&quot;));
199  			_babygrid.setText(0, 3, pluginStr.c_str());
200  		}
201  		break;
202  		case STATE_SCINTILLA:
203  		{
204  			nbItems = nppParam.getScintillaKeyList().size();
205  			_babygrid.setLineColNumber(nbItems, 2);
206  		}
207  		break;
208  	}
209  	bool isMarker = false;
210  	size_t cs_index = 0;
211  	_shortcutFilter = getTextFromCombo(::GetDlgItem(_hSelf, IDC_BABYGRID_FILTER));
212  	switch(_currentState) 
213  	{
214  		case STATE_MENU:
215  		{
216  			vector&lt;CommandShortcut&gt; &amp; cshortcuts = nppParam.getUserShortcuts();
217  			cs_index = 1;
218  			for (size_t i = 0; i &lt; nbItems; ++i)
219  			{
220  				if (isFilterValid(cshortcuts[i]))
221  				{
222  					if (findKeyConflicts(nullptr, cshortcuts[i].getKeyCombo(), i))
223  						isMarker = _babygrid.setMarker(true);
224  					_babygrid.setText(cs_index, 1, string2wstring(cshortcuts[i].getName(), CP_UTF8).c_str());
225  					if (cshortcuts[i].isEnabled()) 
226  						_babygrid.setText(cs_index, 2, string2wstring(cshortcuts[i].toString(), CP_UTF8).c_str());
227  					const TCHAR* category = cshortcuts[i].getCategory();
228  					generic_string categoryStr = nativeLangSpeaker-&gt;getShortcutMapperLangStr((std::string(wstring2string(category, CP_UTF8)) + &quot;Category&quot;).c_str(), category);
229  					_babygrid.setText(cs_index, 3, categoryStr.c_str());
230  					if (isMarker)
231  						isMarker = _babygrid.setMarker(false);
232  					_shortcutIndex.push_back(i);
233  					cs_index++;
234  				}
235  			}
236  			_babygrid.setLineColNumber(cs_index - 1 , 3);
237  			::EnableWindow(::GetDlgItem(_hSelf, IDM_BABYGRID_MODIFY), true);
238  			::EnableWindow(::GetDlgItem(_hSelf, IDM_BABYGRID_CLEAR), true);
239  			::EnableWindow(::GetDlgItem(_hSelf, IDM_BABYGRID_DELETE), false);
240  		}
241  		break;
242  		case STATE_MACRO:
243  		{
244  			vector&lt;MacroShortcut&gt; &amp; cshortcuts = nppParam.getMacroList();
245  			cs_index = 1;
246  			for (size_t i = 0; i &lt; nbItems; ++i)
247  			{
248  				if (isFilterValid(cshortcuts[i]))
249  				{
250  					if (findKeyConflicts(nullptr, cshortcuts[i].getKeyCombo(), i))
251  						isMarker = _babygrid.setMarker(true);
252  					_babygrid.setText(cs_index, 1, string2wstring(cshortcuts[i].getName(), CP_UTF8).c_str());
253  					if (cshortcuts[i].isEnabled()) 
254  						_babygrid.setText(cs_index, 2, string2wstring(cshortcuts[i].toString(), CP_UTF8).c_str());
255  					if (isMarker)
256  						isMarker = _babygrid.setMarker(false);
257  					_shortcutIndex.push_back(i);
258  					cs_index++;
259  				}
260  			}
261  			_babygrid.setLineColNumber(cs_index - 1 , 2);
262              bool shouldBeEnabled = nbItems &gt; 0;
263              ::EnableWindow(::GetDlgItem(_hSelf, IDM_BABYGRID_MODIFY), shouldBeEnabled);
264              ::EnableWindow(::GetDlgItem(_hSelf, IDM_BABYGRID_CLEAR), shouldBeEnabled);
265              ::EnableWindow(::GetDlgItem(_hSelf, IDM_BABYGRID_DELETE), shouldBeEnabled);
266  		}
267  		break;
268  		case STATE_USER:
269  		{
270  			vector&lt;UserCommand&gt; &amp; cshortcuts = nppParam.getUserCommandList();
271  			cs_index = 1;
272  			for (size_t i = 0; i &lt; nbItems; ++i)
273  			{
274  				if (isFilterValid(cshortcuts[i]))
275  				{
276  					if (findKeyConflicts(nullptr, cshortcuts[i].getKeyCombo(), i))
277  						isMarker = _babygrid.setMarker(true);
278  					_babygrid.setText(cs_index, 1, string2wstring(cshortcuts[i].getName(), CP_UTF8).c_str());
279  					if (cshortcuts[i].isEnabled()) 
280  						_babygrid.setText(cs_index, 2, string2wstring(cshortcuts[i].toString(), CP_UTF8).c_str());
281  					if (isMarker)
282  						isMarker = _babygrid.setMarker(false);
<span onclick='openModal()' class='match'>283  					_shortcutIndex.push_back(i);
284  					cs_index++;
285  				}
286  			}
287  			_babygrid.setLineColNumber(cs_index - 1 , 2);
288              bool shouldBeEnabled = nbItems &gt; 0;
</span>289              ::EnableWindow(::GetDlgItem(_hSelf, IDM_BABYGRID_MODIFY), shouldBeEnabled);
290              ::EnableWindow(::GetDlgItem(_hSelf, IDM_BABYGRID_CLEAR), shouldBeEnabled);
291              ::EnableWindow(::GetDlgItem(_hSelf, IDM_BABYGRID_DELETE), shouldBeEnabled);
292  		}
293  		break;
294  		case STATE_PLUGIN:
295  		{
296  			vector&lt;PluginCmdShortcut&gt; &amp; cshortcuts = nppParam.getPluginCommandList();
297  			cs_index = 1;
298  			for (size_t i = 0; i &lt; nbItems; ++i)
299  			{
300  				if (isFilterValid(cshortcuts[i]))
301  				{
302  					if (findKeyConflicts(nullptr, cshortcuts[i].getKeyCombo(), i))
303  						isMarker = _babygrid.setMarker(true);
304  					_babygrid.setText(cs_index, 1, string2wstring(cshortcuts[i].getName(), CP_UTF8).c_str());
305  					if (cshortcuts[i].isEnabled()) 
306  						_babygrid.setText(cs_index, 2, string2wstring(cshortcuts[i].toString(), CP_UTF8).c_str());
307  					_babygrid.setText(cs_index, 3, string2wstring(cshortcuts[i].getModuleName(), CP_UTF8).c_str());
308  					if (isMarker)
309  						isMarker = _babygrid.setMarker(false);
310  					_shortcutIndex.push_back(i);
311  					cs_index++;
312  				}
313  			}
314  			_babygrid.setLineColNumber(cs_index - 1 , 3);
315              bool shouldBeEnabled = nbItems &gt; 0;
316              ::EnableWindow(::GetDlgItem(_hSelf, IDM_BABYGRID_MODIFY), shouldBeEnabled);
317              ::EnableWindow(::GetDlgItem(_hSelf, IDM_BABYGRID_CLEAR), shouldBeEnabled);
318              ::EnableWindow(::GetDlgItem(_hSelf, IDM_BABYGRID_DELETE), false);
319  		}
320  		break;
321  		case STATE_SCINTILLA:
322  		{
323  			vector&lt;ScintillaKeyMap&gt; &amp; cshortcuts = nppParam.getScintillaKeyList();
324  			cs_index=1;
325  			for (size_t i = 0; i &lt; nbItems; ++i)
326  			{
327  				if (isFilterValid(cshortcuts[i]))
328  				{
329  					if (cshortcuts[i].isEnabled())
330  					{
331  						size_t sciCombos = cshortcuts[i].getSize();
332  						for (size_t sciIndex = 0; sciIndex &lt; sciCombos; ++sciIndex)
333  						{
334  							if (findKeyConflicts(nullptr, cshortcuts[i].getKeyComboByIndex(sciIndex), i))
335  							{
336  								isMarker = _babygrid.setMarker(true);
337  								break;
338  							}
339  						}
340  					}
341  					_babygrid.setText(cs_index, 1, string2wstring(cshortcuts[i].getName(), CP_UTF8).c_str());
342  					if (cshortcuts[i].isEnabled()) 
343  						_babygrid.setText(cs_index, 2, string2wstring(cshortcuts[i].toString(), CP_UTF8).c_str());
344  					if (isMarker)
345  						isMarker = _babygrid.setMarker(false);
346  					_shortcutIndex.push_back(i);
347  					cs_index++;
348  				}
349  			}
350  			_babygrid.setLineColNumber(cs_index - 1 , 2);
351              ::EnableWindow(::GetDlgItem(_hSelf, IDM_BABYGRID_MODIFY), true);
352              ::EnableWindow(::GetDlgItem(_hSelf, IDM_BABYGRID_CLEAR), false);
353              ::EnableWindow(::GetDlgItem(_hSelf, IDM_BABYGRID_DELETE), false);
354  		}
355  		break;
356  	}
357  	if (nbItems &gt; 0) 
358  		_babygrid.setLastView(_lastHomeRow[_currentState], _lastCursorRow[_currentState]);
359  	else 
360  		::SendDlgItemMessage(_hSelf, IDC_BABYGRID_INFO, WM_SETTEXT, 0, 0);
361  	_babygrid.setInitialContent(false);
362  }
363  intptr_t CALLBACK ShortcutMapper::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
364  {
365  	switch (message) 
366  	{
367  		case WM_INITDIALOG :
368  		{
369  			initBabyGrid();
370  			initTabs();
371  			fillOutBabyGrid();
372  			_babygrid.display();	
373  			goToCenter();
374  			NppDarkMode::autoSubclassAndThemeChildControls(_hSelf);
375  			RECT rect;
376  			Window::getClientRect(rect);
377  			_clientWidth = rect.right - rect.left;
378  			_clientHeight = rect.bottom - rect.top;
379  			int cy_border = GetSystemMetrics(SM_CYFRAME);
380  			int cy_caption = GetSystemMetrics(SM_CYCAPTION);
381  			_initClientWidth = _clientWidth;
382  			_initClientHeight = _clientHeight + cy_caption + cy_border;
383  			_dialogInitDone = true;
384  			return TRUE;
385  		}
386  		case WM_CTLCOLOREDIT:
387  		{
388  			return NppDarkMode::onCtlColorSofter(reinterpret_cast&lt;HDC&gt;(wParam));
389  		}
390  		case WM_CTLCOLORDLG:
391  		case WM_CTLCOLORSTATIC:
392  		{
393  			return NppDarkMode::onCtlColorDarker(reinterpret_cast&lt;HDC&gt;(wParam));
394  		}
395  		case WM_PRINTCLIENT:
396  		{
397  			if (NppDarkMode::isEnabled())
398  			{
399  				return TRUE;
400  			}
401  			break;
402  		}
403  		case NPPM_INTERNAL_REFRESHDARKMODE:
404  		{
405  			NppDarkMode::autoThemeChildControls(_hSelf);
406  			return TRUE;
407  		}
408  		case WM_GETMINMAXINFO :
409  		{
410  			MINMAXINFO* mmi = (MINMAXINFO*)lParam;
411  			if (_dialogInitDone)
412  			{
413  				mmi-&gt;ptMinTrackSize.x = _initClientWidth;
414  				mmi-&gt;ptMinTrackSize.y = _initClientHeight;
415  			}
416  			return 0;
417  		}
418  		case WM_DESTROY:
419  		{
420  			for (const HFONT &amp; hFont : _hGridFonts)
421  				::DeleteObject(hFont);
422  			_hGridFonts.clear();
423  			_hGridFonts.shrink_to_fit();
424  			break;
425  		}
426  		case WM_SIZE:
427  		{
428  			LONG newWidth = LOWORD(lParam);
429  			LONG newHeight = HIWORD(lParam);
430  			RECT rect;
431  			LONG addWidth = newWidth - _clientWidth;
432  			LONG addHeight = newHeight - _clientHeight;
433  			_clientWidth = newWidth;
434  			_clientHeight = newHeight;
435  			getClientRect(rect);
436  			_babygrid.reSizeToWH(rect);
437  			const auto moveWindowIDs = {
438  				IDM_BABYGRID_MODIFY, IDM_BABYGRID_CLEAR, IDM_BABYGRID_DELETE, IDOK
439  			};
440  			const UINT flags = SWP_NOZORDER | SWP_NOOWNERZORDER | SWP_NOACTIVATE | SWP_NOCOPYBITS;
441  			Window::getClientRect(rect);
442  			for (int moveWndID : moveWindowIDs)
443  			{
444  				HWND moveHwnd = ::GetDlgItem(_hSelf, moveWndID);
445  				::GetWindowRect(moveHwnd, &amp;rect);
446  				::MapWindowPoints(NULL, _hSelf, (LPPOINT)&amp;rect, 2);
447  				::SetWindowPos(moveHwnd, NULL, rect.left + addWidth / 2, rect.top + addHeight, 0, 0, SWP_NOSIZE | flags);
448  			}
449  			HWND moveHwnd = ::GetDlgItem(_hSelf, IDC_BABYGRID_STATIC);
450  			::GetWindowRect(moveHwnd, &amp;rect);
451  			::MapWindowPoints(NULL, _hSelf, (LPPOINT)&amp;rect, 2);
452  			::SetWindowPos(moveHwnd, NULL, rect.left, rect.top + addHeight, 0, 0, SWP_NOSIZE | flags);
453  			HWND resizeHwnd = ::GetDlgItem(_hSelf, IDC_BABYGRID_INFO);
454  			::GetWindowRect(resizeHwnd, &amp;rect);
455  			::MapWindowPoints(NULL, _hSelf, (LPPOINT)&amp;rect, 2);
456  			::SetWindowPos(resizeHwnd, NULL, rect.left, rect.top + addHeight, rect.right - rect.left + addWidth, rect.bottom - rect.top, flags);
457  			resizeHwnd = ::GetDlgItem(_hSelf, IDC_BABYGRID_FILTER);
458  			::GetWindowRect(resizeHwnd, &amp;rect);
459  			::MapWindowPoints(NULL, _hSelf, (LPPOINT)&amp;rect, 2);
460  			::SetWindowPos(resizeHwnd, NULL, rect.left, rect.top + addHeight, rect.right - rect.left + addWidth, rect.bottom - rect.top, flags);
461  			break;
462  		}
463  		break;
464  		case WM_NOTIFY:
465  		{
466  			NMHDR nmh = *((NMHDR*)lParam);
467  			if (nmh.hwndFrom == _hTabCtrl)
468  			{
469  				if (nmh.code == TCN_SELCHANGE)
470  				{
471  					_lastHomeRow[_currentState] = _babygrid.getHomeRow();
472  					_lastCursorRow[_currentState] = _babygrid.getSelectedRow();
473  					int index = TabCtrl_GetCurSel(_hTabCtrl);
474  					switch (index)
475  					{
476  						case 0:
477  							_currentState = STATE_MENU;
478  							break;
479  						case 1:
480  							_currentState = STATE_MACRO;
481  							break;
482  						case 2:
483  							_currentState = STATE_USER;
484  							break;
485  						case 3:
486  							_currentState = STATE_PLUGIN;
487  							break;
488  						case 4:
489  							_currentState = STATE_SCINTILLA;
490  							break;
491  					}
492  					fillOutBabyGrid();
493  				}
494  			}
495  		}
496  		break;
497  		case NPPM_INTERNAL_FINDKEYCONFLICTS:
498  		{
499  			if (!wParam || !lParam)
500  				break;
501  			generic_string conflictInfo;
502  			size_t realIndexOfSelectedItem = _shortcutIndex[_babygrid.getSelectedRow() - 1];
503  			const bool isConflict = findKeyConflicts(&amp;conflictInfo, *reinterpret_cast&lt;KeyCombo*&gt;(wParam), realIndexOfSelectedItem);
504  			*reinterpret_cast&lt;bool*&gt;(lParam) = isConflict;
505  			if (isConflict)
506  				::SendDlgItemMessage(_hSelf, IDC_BABYGRID_INFO, WM_SETTEXT, 0, reinterpret_cast&lt;LPARAM&gt;(conflictInfo.c_str()));
507  			else
508  				::SendDlgItemMessage(_hSelf, IDC_BABYGRID_INFO, WM_SETTEXT, 0, reinterpret_cast&lt;LPARAM&gt;(_conflictInfoEditing.c_str()));
509  			return TRUE;
510  		}
511  		case WM_COMMAND : 
512  		{
513  			switch (LOWORD(wParam))
514  			{
515  				case IDCANCEL :
516  				{
517  					::EndDialog(_hSelf, -1);
518  					return TRUE;
519  				}
520  				case IDOK :
521  				{
522  					::EndDialog(_hSelf, 0);
523  					return TRUE;
524  				}
525  				case IDM_BABYGRID_CLEAR :
526  				{
527  					if (_babygrid.getNumberRows() &lt; 1)
528  						return TRUE;
529  					NppParameters&amp; nppParam = NppParameters::getInstance();
530  					int row = _babygrid.getSelectedRow();
531  					size_t shortcutIndex = _shortcutIndex[row-1];
532  					bool isModified = false;
533  					switch(_currentState)
534  					{
535  						case STATE_MENU:
536  						{
537  							vector&lt;CommandShortcut&gt; &amp; shortcuts = nppParam.getUserShortcuts();
538  							CommandShortcut csc = shortcuts[shortcutIndex];
539  							csc.clear();
540  							shortcuts[shortcutIndex] = csc;
541  							nppParam.addUserModifiedIndex(shortcutIndex);
542  							_lastHomeRow[_currentState] = _babygrid.getHomeRow();
543  							_lastCursorRow[_currentState] = _babygrid.getSelectedRow();
544  							fillOutBabyGrid();
545  							isModified = true;
546  							nppParam.getAccelerator()-&gt;updateShortcuts();
547  							nppParam.setShortcutDirty();
548  						}
549  						break;
550  						case STATE_MACRO: 
551  						{
552  							vector&lt;MacroShortcut&gt; &amp; shortcuts = nppParam.getMacroList();
553  							MacroShortcut msc = shortcuts[shortcutIndex];
554  							msc.clear();
555  							shortcuts[shortcutIndex] = msc;
556  							_lastHomeRow[_currentState] = _babygrid.getHomeRow();
557  							_lastCursorRow[_currentState] = _babygrid.getSelectedRow();
558  							fillOutBabyGrid();
559  							isModified = true;
560  							nppParam.getAccelerator()-&gt;updateShortcuts();
561  							nppParam.setShortcutDirty();
562  						}
563  						break;
564  						case STATE_USER: 
565  						{
566  							vector&lt;UserCommand&gt; &amp; shortcuts = nppParam.getUserCommandList();
567  							UserCommand ucmd = shortcuts[shortcutIndex];
568  							ucmd.clear();
569  							shortcuts[shortcutIndex] = ucmd;
570  							_lastHomeRow[_currentState] = _babygrid.getHomeRow();
571  							_lastCursorRow[_currentState] = _babygrid.getSelectedRow();
572  							fillOutBabyGrid();
573  							isModified = true;
574  							nppParam.getAccelerator()-&gt;updateShortcuts();
575  							nppParam.setShortcutDirty();
576  						}
577  						break;
578  						case STATE_PLUGIN: 
579  						{
580  							vector&lt;PluginCmdShortcut&gt; &amp; shortcuts = nppParam.getPluginCommandList();
581  							PluginCmdShortcut pcsc = shortcuts[shortcutIndex];
582  							pcsc.clear();
583  							nppParam.addPluginModifiedIndex(shortcutIndex);
584  							shortcuts[shortcutIndex] = pcsc;
585  							_lastHomeRow[_currentState] = _babygrid.getHomeRow();
586  							_lastCursorRow[_currentState] = _babygrid.getSelectedRow();
587  							fillOutBabyGrid();
588  							isModified = true;
589  							nppParam.getAccelerator()-&gt;updateShortcuts();
590  							unsigned long cmdID = pcsc.getID();
591  							ShortcutKey shortcut;
592  							shortcut._isAlt = FALSE;
593  							shortcut._isCtrl = FALSE;
594  							shortcut._isShift = FALSE;
595  							shortcut._key = &#x27;\0&#x27;;
596  							::SendMessage(_hParent, NPPM_INTERNAL_PLUGINSHORTCUTMOTIFIED, cmdID, reinterpret_cast&lt;LPARAM&gt;(&amp;shortcut));
597  							nppParam.setShortcutDirty();
598  						}
599  						break;
600  						case STATE_SCINTILLA: 
601  						{
602  						}
603  						break;
604  					}
605  					if (!isModified)
606  						::SendMessage(_hSelf, WM_COMMAND, MAKEWPARAM(IDD_BABYGRID_ID1, BGN_ROWCHANGED), row);
607  					return TRUE;
608  				}
609  				case IDM_BABYGRID_MODIFY :
610  				{
611  					if (_babygrid.getNumberRows() &lt; 1)
612  						return TRUE;
613  					NppParameters&amp; nppParam = NppParameters::getInstance();
614  					int row = _babygrid.getSelectedRow();
615  					size_t shortcutIndex = _shortcutIndex[row-1];
616  					bool isModified = false;
617  					switch(_currentState)
618  					{
619  						case STATE_MENU:
620  						{
621  							vector&lt;CommandShortcut&gt; &amp; shortcuts = nppParam.getUserShortcuts();
622  							CommandShortcut csc = shortcuts[shortcutIndex], prevcsc = shortcuts[shortcutIndex];
623  							csc.init(_hInst, _hSelf);
624  							if (csc.doDialog() != -1 &amp;&amp; prevcsc != csc)
625  							{
626  								nppParam.addUserModifiedIndex(shortcutIndex);
627  								shortcuts[shortcutIndex] = csc;
628  								_lastHomeRow[_currentState] = _babygrid.getHomeRow();
629  								_lastCursorRow[_currentState] = _babygrid.getSelectedRow();
630  								fillOutBabyGrid();
631  								isModified = true;
632  								nppParam.getAccelerator()-&gt;updateShortcuts();
633  								nppParam.setShortcutDirty();
634  							}
635  						}
636  						break;
637  						case STATE_MACRO: 
638  						{
639  							vector&lt;MacroShortcut&gt; &amp; shortcuts = nppParam.getMacroList();
640  							MacroShortcut msc = shortcuts[shortcutIndex], prevmsc = shortcuts[shortcutIndex];
641  							msc.init(_hInst, _hSelf);
642  							if (msc.doDialog() != -1 &amp;&amp; prevmsc != msc)
643  							{
644  								shortcuts[shortcutIndex] = msc;
645  								_lastHomeRow[_currentState] = _babygrid.getHomeRow();
646  								_lastCursorRow[_currentState] = _babygrid.getSelectedRow();
647  								fillOutBabyGrid();
648  								isModified = true;
649  								nppParam.getAccelerator()-&gt;updateShortcuts();
650  								nppParam.setShortcutDirty();
651  							}
652  						}
653  						break; 
654  						case STATE_USER: 
655  						{
656  							vector&lt;UserCommand&gt; &amp; shortcuts = nppParam.getUserCommandList();
657  							UserCommand ucmd = shortcuts[shortcutIndex];
658  							ucmd.init(_hInst, _hSelf);
659  							UserCommand prevucmd = ucmd;
660  							if (ucmd.doDialog() != -1 &amp;&amp; prevucmd != ucmd)
661  							{
662  								shortcuts[shortcutIndex] = ucmd;
663  								_lastHomeRow[_currentState] = _babygrid.getHomeRow();
664  								_lastCursorRow[_currentState] = _babygrid.getSelectedRow();
665  								fillOutBabyGrid();
666  								isModified = true;
667  								nppParam.getAccelerator()-&gt;updateShortcuts();
668  								nppParam.setShortcutDirty();
669  							}
670  						}
671  						break; 
672  						case STATE_PLUGIN:
673  						{
674  							vector&lt;PluginCmdShortcut&gt; &amp; shortcuts = nppParam.getPluginCommandList();
675  							PluginCmdShortcut pcsc = shortcuts[shortcutIndex];
676  							pcsc.init(_hInst, _hSelf);
677  							PluginCmdShortcut prevpcsc = pcsc;
678  							if (pcsc.doDialog() != -1 &amp;&amp; prevpcsc != pcsc)
679  							{
680  								nppParam.addPluginModifiedIndex(shortcutIndex);
681  								shortcuts[shortcutIndex] = pcsc;
682  								_lastHomeRow[_currentState] = _babygrid.getHomeRow();
683  								_lastCursorRow[_currentState] = _babygrid.getSelectedRow();
684  								fillOutBabyGrid();
685  								isModified = true;
686  								nppParam.getAccelerator()-&gt;updateShortcuts();
687  								unsigned long cmdID = pcsc.getID();
688  								ShortcutKey shortcut;
689  								shortcut._isAlt = pcsc.getKeyCombo()._isAlt;
690  								shortcut._isCtrl = pcsc.getKeyCombo()._isCtrl;
691  								shortcut._isShift = pcsc.getKeyCombo()._isShift;
692  								shortcut._key = pcsc.getKeyCombo()._key;
693  								::SendMessage(_hParent, NPPM_INTERNAL_PLUGINSHORTCUTMOTIFIED, cmdID, reinterpret_cast&lt;LPARAM&gt;(&amp;shortcut));
694  								nppParam.setShortcutDirty();
695  							}
696  						}
697  						break;
698  						case STATE_SCINTILLA:
699  						{
700  							vector&lt;ScintillaKeyMap&gt; &amp; shortcuts = nppParam.getScintillaKeyList();
701  							ScintillaKeyMap skm = shortcuts[shortcutIndex], prevskm = shortcuts[shortcutIndex];
702  							skm.init(_hInst, _hSelf);
703  							if (skm.doDialog() != -1 &amp;&amp; prevskm != skm)
704  							{
705  								nppParam.addScintillaModifiedIndex((int)shortcutIndex);
706  								shortcuts[shortcutIndex] = skm;
707  								_lastHomeRow[_currentState] = _babygrid.getHomeRow();
708  								_lastCursorRow[_currentState] = _babygrid.getSelectedRow();
709  								fillOutBabyGrid();
710  								_babygrid.updateView();
711  								isModified = true;
712  								nppParam.getScintillaAccelerator()-&gt;updateKeys();
713  								nppParam.setShortcutDirty();
714  							}
715  						}
716  						break;  
717  					}
718  					if (!isModified)
719  						::SendMessage(_hSelf, WM_COMMAND, MAKEWPARAM(IDD_BABYGRID_ID1, BGN_ROWCHANGED), row);
720  					return TRUE;
721  				}
722  				case IDM_BABYGRID_DELETE :
723  				{
724  					if (_babygrid.getNumberRows() &lt; 1)
725  						return TRUE;
726  					NppParameters&amp; nppParam = NppParameters::getInstance();
727  					int res = nppParam.getNativeLangSpeaker()-&gt;messageBox(&quot;SCMapperDoDeleteOrNot&quot;,
728  						_hSelf,
729  						TEXT(&quot;Are you sure you want to delete this shortcut?&quot;),
730  						TEXT(&quot;Are you sure?&quot;),
731  						MB_OKCANCEL);
732  					if (res == IDOK)
733  					{
734  						const int row = _babygrid.getSelectedRow();
735  						size_t shortcutIndex = _shortcutIndex[row-1];
736  						switch(_currentState) 
737  						{
738  							case STATE_MENU:
739  							case STATE_PLUGIN:
740  							case STATE_SCINTILLA: 
741  							{
742  								return FALSE;
743  							}
744  							case STATE_MACRO: 
745  							{
746  								vector&lt;MacroShortcut&gt; &amp; theMacros = nppParam.getMacroList();
747  								theMacros.erase(theMacros.begin() + shortcutIndex);
748  								_lastHomeRow[_currentState] = _babygrid.getHomeRow();
749  								_lastCursorRow[_currentState] = _babygrid.getSelectedRow();
750  								const size_t numberRows = _babygrid.getNumberRows();
751  								if (_lastHomeRow[_currentState] == numberRows)
752  									--_lastHomeRow[_currentState];
753  								if (_lastCursorRow[_currentState] == numberRows)
754  									--_lastCursorRow[_currentState];
755  								fillOutBabyGrid();
756  								DynamicMenu&amp; macroMenu = nppParam.getMacroMenuItems();
757  								macroMenu.clearMenu();
758  								macroMenu.erase(shortcutIndex);
759  								size_t nbElem = theMacros.size();
760  								for (size_t i = shortcutIndex; i &lt; nbElem; ++i)	
761  								{
762  									MacroShortcut ms = theMacros[i];
763  									ms.setID(ms.getID() - 1);	
764  									theMacros[i] = ms;
765  									MenuItemUnit&amp; miu = macroMenu.getItemFromIndex(i);
766  									miu._cmdID -= 1;	
767  								}
768  								macroMenu.createMenu();
769  								HMENU m = reinterpret_cast&lt;HMENU&gt;(::SendMessage(_hParent, NPPM_INTERNAL_GETMENU, 0, 0));
770  								HMENU hMenu = ::GetSubMenu(m, MENUINDEX_MACRO);
771  								if (!hMenu) return FALSE;
772  								int32_t posBase = macroMenu.getPosBase();
773  								if (nbElem == 0)
774  								{
775  									::RemoveMenu(hMenu, IDM_SETTING_SHORTCUT_MAPPER_MACRO, MF_BYCOMMAND);
776  									::RemoveMenu(hMenu, posBase - 1, MF_BYPOSITION);
777  									::RemoveMenu(hMenu, posBase - 1, MF_BYPOSITION);
778  								}
779  							}
780  							break; 
781  							case STATE_USER: 
782  							{
783  								vector&lt;UserCommand&gt; &amp; theUserCmds = nppParam.getUserCommandList();
784  								theUserCmds.erase(theUserCmds.begin() + shortcutIndex);
785  								_lastHomeRow[_currentState] = _babygrid.getHomeRow();
786  								_lastCursorRow[_currentState] = _babygrid.getSelectedRow();
787  								const size_t numberRows = _babygrid.getNumberRows();
788  								if (_lastHomeRow[_currentState] == numberRows)
789  									--_lastHomeRow[_currentState];
790  								if (_lastCursorRow[_currentState] == numberRows)
791  									--_lastCursorRow[_currentState];
792  								fillOutBabyGrid();
793  								DynamicMenu&amp; runMenu = nppParam.getRunMenuItems();
794  								runMenu.clearMenu();
795  								runMenu.erase(shortcutIndex);
796  								size_t nbElem = theUserCmds.size();
797  								for (size_t i = shortcutIndex; i &lt; nbElem; ++i)	
798  								{
799  									UserCommand uc = theUserCmds[i];
800  									uc.setID(uc.getID() - 1);	
801  									theUserCmds[i] = uc;
802  									MenuItemUnit&amp; miu = runMenu.getItemFromIndex(i);
803  									miu._cmdID -= 1;	
804  								}
805  								runMenu.createMenu();
806  								HMENU m = reinterpret_cast&lt;HMENU&gt;(::SendMessage(_hParent, NPPM_INTERNAL_GETMENU, 0, 0));
807  								HMENU hMenu = ::GetSubMenu(m, MENUINDEX_RUN);
808  								if (!hMenu) return FALSE;
809  								int32_t posBase = runMenu.getPosBase();
810  								if (nbElem == 0)
811  								{
812  									::RemoveMenu(hMenu, IDM_SETTING_SHORTCUT_MAPPER_RUN, MF_BYCOMMAND);
813  									::RemoveMenu(hMenu, posBase - 1, MF_BYPOSITION);
814  									::RemoveMenu(hMenu, posBase - 1, MF_BYPOSITION);
815  								}
816  							}
817  							break;
818  						}
819  						nppParam.getAccelerator()-&gt;updateShortcuts();
820  						nppParam.setShortcutDirty();
821  					}
822  					return TRUE;
823  				}
824  				case IDD_BABYGRID_ID1: 
825  				{
826  					switch (HIWORD(wParam))
827  					{
828  						case BGN_CELLDBCLICKED: 
829  						{
830  							return ::SendMessage(_hSelf, WM_COMMAND, IDM_BABYGRID_MODIFY, LOWORD(lParam));
831  						}
832  						case BGN_CELLRCLICKED: 
833  						{
834  							POINT p{};
835  							::GetCursorPos(&amp;p);
836  							if (!_rightClickMenu.isCreated())
837  							{
838  								vector&lt;MenuItemUnit&gt; itemUnitArray;
839  								NativeLangSpeaker* nativeLangSpeaker = NppParameters::getInstance().getNativeLangSpeaker();
840  								generic_string modifyStr = nativeLangSpeaker-&gt;getShortcutMapperLangStr(&quot;ModifyContextMenu&quot;, TEXT(&quot;Modify&quot;));
841  								generic_string deleteStr = nativeLangSpeaker-&gt;getShortcutMapperLangStr(&quot;DeleteContextMenu&quot;, TEXT(&quot;Delete&quot;));
842  								generic_string clearStr = nativeLangSpeaker-&gt;getShortcutMapperLangStr(&quot;ClearContextMenu&quot;, TEXT(&quot;Clear&quot;));
843  								itemUnitArray.push_back(MenuItemUnit(IDM_BABYGRID_MODIFY, modifyStr.c_str()));
844  								itemUnitArray.push_back(MenuItemUnit(IDM_BABYGRID_DELETE, deleteStr.c_str()));
845  								itemUnitArray.push_back(MenuItemUnit(IDM_BABYGRID_CLEAR, clearStr.c_str()));
846  								_rightClickMenu.create(_hSelf, itemUnitArray);
847  							}
848  							if (_babygrid.getNumberRows() &lt; 1)
849  							{
850  								_rightClickMenu.enableItem(IDM_BABYGRID_MODIFY, false);
851  								_rightClickMenu.enableItem(IDM_BABYGRID_DELETE, false);
852  								_rightClickMenu.enableItem(IDM_BABYGRID_CLEAR, false);
853  							}
854  							else
855  							{
856  								_rightClickMenu.enableItem(IDM_BABYGRID_MODIFY, true);
857  								_rightClickMenu.enableItem(IDM_BABYGRID_DELETE, true);
858  								if (_currentState == STATE_SCINTILLA)
859  									_rightClickMenu.enableItem(IDM_BABYGRID_CLEAR, false);
860  								else
861  									_rightClickMenu.enableItem(IDM_BABYGRID_CLEAR, true);
862  								switch(_currentState)
863  								{
864  									case STATE_MACRO:
865  									case STATE_USER:
866  									{
867  										_rightClickMenu.enableItem(IDM_BABYGRID_DELETE, true);
868  									}
869  									break;
870  									case STATE_MENU:
871  									case STATE_PLUGIN:
872  									case STATE_SCINTILLA:
873  									{
874  										_rightClickMenu.enableItem(IDM_BABYGRID_DELETE, false);
875  									}
876  									break;
877  								}
878  							}
879  							_rightClickMenu.display(p);
880  							return TRUE;
881  						}
882  						case BGN_DELETECELL: 
883  						{
884  							switch(_currentState) 
885  							{
886  								case STATE_MACRO:
887  								case STATE_USER:
888  									return ::SendMessage(_hSelf, WM_COMMAND, IDM_BABYGRID_DELETE, 0);
889  								case STATE_MENU:
890  								case STATE_PLUGIN:
891  								case STATE_SCINTILLA:
892  								default:
893  									break;
894  							}
895  							return TRUE;
896  						}
897  						case BGN_ROWCHANGED:
898  						{
899  							if (_babygrid.getNumberRows() &lt; 1)
900  								return TRUE;
901  							NppParameters&amp; nppParam = NppParameters::getInstance();
902  							const size_t currentIndex = LOWORD(lParam) - 1;
903  							size_t realIndexOfSelectedItem = _shortcutIndex[currentIndex];
904  							generic_string conflictInfo;
905  							switch (_currentState)
906  							{
907  								case STATE_MENU:
908  								{
909  									vector&lt;CommandShortcut&gt; &amp; vShortcuts = nppParam.getUserShortcuts();
910  									findKeyConflicts(&amp;conflictInfo, vShortcuts[realIndexOfSelectedItem].getKeyCombo(), realIndexOfSelectedItem);
911  								}
912  								break;
913  								case STATE_MACRO:
914  								{
915  									vector&lt;MacroShortcut&gt; &amp; vShortcuts = nppParam.getMacroList();
916  									findKeyConflicts(&amp;conflictInfo, vShortcuts[realIndexOfSelectedItem].getKeyCombo(), realIndexOfSelectedItem);
917  								}
918  								break;
919  								case STATE_USER:
920  								{
921  									vector&lt;UserCommand&gt; &amp; vShortcuts = nppParam.getUserCommandList();
922  									findKeyConflicts(&amp;conflictInfo, vShortcuts[realIndexOfSelectedItem].getKeyCombo(), realIndexOfSelectedItem);
923  								}
924  								break;
925  								case STATE_PLUGIN:
926  								{
927  									vector&lt;PluginCmdShortcut&gt; &amp; vShortcuts = nppParam.getPluginCommandList();
928  									findKeyConflicts(&amp;conflictInfo, vShortcuts[realIndexOfSelectedItem].getKeyCombo(), realIndexOfSelectedItem);
929  								}
930  								break;
931  								case STATE_SCINTILLA:
932  								{
933  									vector&lt;ScintillaKeyMap&gt; &amp; vShortcuts = nppParam.getScintillaKeyList();
934  									size_t sciCombos = vShortcuts[realIndexOfSelectedItem].getSize();
935  									for (size_t sciIndex = 0; sciIndex &lt; sciCombos; ++sciIndex)
936  										findKeyConflicts(&amp;conflictInfo, vShortcuts[realIndexOfSelectedItem].getKeyComboByIndex(sciIndex), realIndexOfSelectedItem);
937  								}
938  								break;
939  							}
940  							if (conflictInfo.empty())
941  								::SendDlgItemMessage(_hSelf, IDC_BABYGRID_INFO, WM_SETTEXT, 0, reinterpret_cast&lt;LPARAM&gt;(_conflictInfoOk.c_str()));
942  							else
943  								::SendDlgItemMessage(_hSelf, IDC_BABYGRID_INFO, WM_SETTEXT, 0, reinterpret_cast&lt;LPARAM&gt;(conflictInfo.c_str()));
944  							return TRUE;
945  						}
946  					}
947  					break;
948  				}
949  				case IDC_BABYGRID_FILTER:
950  				{
951  					if (HIWORD(wParam) == EN_CHANGE)
952  					{
953  						fillOutBabyGrid();
954  					}
955  					return TRUE;
956  				}
957  				default:
958  				{
959  					break;
960  				}
961  			}
962  			break;
963  		}
964  		default:
965  			return FALSE;
966  	}
967  	return FALSE;
968  }
969  bool ShortcutMapper::findKeyConflicts(__inout_opt generic_string * const keyConflictLocation,
970  										const KeyCombo &amp; itemKeyComboToTest, const size_t &amp; itemIndexToTest) const
971  {
972  	if (itemKeyComboToTest._key == 0) 
973  		return false;
974  	bool retIsConflict = false; 
975  	NppParameters&amp; nppParam = NppParameters::getInstance();
976  	for (size_t gridState = STATE_MENU; gridState &lt;= STATE_SCINTILLA; ++gridState)
977  	{
978  		switch (gridState)
979  		{
980  			case STATE_MENU:
981  			{
982  				vector&lt;CommandShortcut&gt; &amp; vShortcuts = nppParam.getUserShortcuts();
983  				size_t nbItems = vShortcuts.size();
984  				for (size_t itemIndex = 0; itemIndex &lt; nbItems; ++itemIndex)
985  				{
986  					if (!vShortcuts[itemIndex].isEnabled()) 
987  						continue;
988  					if ((itemIndex == itemIndexToTest) &amp;&amp; (gridState == static_cast&lt;size_t&gt;(_currentState))) 
989  						continue;
990  					if (isConflict(vShortcuts[itemIndex].getKeyCombo(), itemKeyComboToTest))
991  					{
992  						retIsConflict = true;
993  						if (keyConflictLocation == nullptr)
994  							return retIsConflict;
995  						else
996  						{
997  							if (!keyConflictLocation-&gt;empty())
998  								*keyConflictLocation += TEXT(&quot;\r\n&quot;);
999  							*keyConflictLocation += _tabNames[gridState];
1000  							*keyConflictLocation += TEXT(&quot;  |  &quot;);
1001  							*keyConflictLocation += std::to_wstring(itemIndex + 1);
1002  							*keyConflictLocation += TEXT(&quot;   &quot;);
1003  							*keyConflictLocation += string2wstring(vShortcuts[itemIndex].getName(), CP_UTF8);
1004  							*keyConflictLocation += TEXT(&quot;  ( &quot;);
1005  							*keyConflictLocation += string2wstring(vShortcuts[itemIndex].toString(), CP_UTF8);
1006  							*keyConflictLocation += TEXT(&quot; )&quot;);
1007  						}
1008  					}
1009  				}
1010  				break;
1011  			} 
1012  			case STATE_MACRO:
1013  			{
1014  				vector&lt;MacroShortcut&gt; &amp; vShortcuts = nppParam.getMacroList();
1015  				size_t nbItems = vShortcuts.size();
1016  				for (size_t itemIndex = 0; itemIndex &lt; nbItems; ++itemIndex)
1017  				{
1018  					if (!vShortcuts[itemIndex].isEnabled()) 
1019  						continue;
1020  					if ((itemIndex == itemIndexToTest) &amp;&amp; (gridState == static_cast&lt;size_t&gt;(_currentState))) 
1021  						continue;
1022  					if (isConflict(vShortcuts[itemIndex].getKeyCombo(), itemKeyComboToTest))
1023  					{
1024  						retIsConflict = true;
1025  						if (keyConflictLocation == nullptr)
1026  							return retIsConflict;
1027  						else
1028  						{
1029  							if (!keyConflictLocation-&gt;empty())
1030  								*keyConflictLocation += TEXT(&quot;\r\n&quot;);
1031  							*keyConflictLocation += _tabNames[gridState];
1032  							*keyConflictLocation += TEXT(&quot;  |  &quot;);
1033  							*keyConflictLocation += std::to_wstring(itemIndex + 1);
1034  							*keyConflictLocation += TEXT(&quot;   &quot;);
1035  							*keyConflictLocation += string2wstring(vShortcuts[itemIndex].getName(), CP_UTF8);
1036  							*keyConflictLocation += TEXT(&quot;  ( &quot;);
1037  							*keyConflictLocation += string2wstring(vShortcuts[itemIndex].toString(), CP_UTF8);
1038  							*keyConflictLocation += TEXT(&quot; )&quot;);
1039  						}
1040  					}
1041  				}
1042  				break;
1043  			} 
1044  			case STATE_USER:
1045  			{
1046  				vector&lt;UserCommand&gt; &amp; vShortcuts = nppParam.getUserCommandList();
1047  				size_t nbItems = vShortcuts.size();
1048  				for (size_t itemIndex = 0; itemIndex &lt; nbItems; ++itemIndex)
1049  				{
1050  					if (!vShortcuts[itemIndex].isEnabled()) 
1051  						continue;
1052  					if ((itemIndex == itemIndexToTest) &amp;&amp; (gridState == static_cast&lt;size_t&gt;(_currentState))) 
1053  						continue;
1054  					if (isConflict(vShortcuts[itemIndex].getKeyCombo(), itemKeyComboToTest))
1055  					{
1056  						retIsConflict = true;
1057  						if (keyConflictLocation == nullptr)
1058  							return retIsConflict;
1059  						else
1060  						{
1061  							if (!keyConflictLocation-&gt;empty())
1062  								*keyConflictLocation += TEXT(&quot;\r\n&quot;);
1063  							*keyConflictLocation += _tabNames[gridState];
1064  							*keyConflictLocation += TEXT(&quot;  |  &quot;);
1065  							*keyConflictLocation += std::to_wstring(itemIndex + 1);
1066  							*keyConflictLocation += TEXT(&quot;   &quot;);
1067  							*keyConflictLocation += string2wstring(vShortcuts[itemIndex].getName(), CP_UTF8);
1068  							*keyConflictLocation += TEXT(&quot;  ( &quot;);
1069  							*keyConflictLocation += string2wstring(vShortcuts[itemIndex].toString(), CP_UTF8);
1070  							*keyConflictLocation += TEXT(&quot; )&quot;);
1071  						}
1072  					}
1073  				}
1074  				break;
1075  			} 
1076  			case STATE_PLUGIN:
1077  			{
1078  				vector&lt;PluginCmdShortcut&gt; &amp; vShortcuts = nppParam.getPluginCommandList();
1079  				size_t nbItems = vShortcuts.size();
1080  				for (size_t itemIndex = 0; itemIndex &lt; nbItems; ++itemIndex)
1081  				{
1082  					if (!vShortcuts[itemIndex].isEnabled()) 
1083  						continue;
1084  					if ((itemIndex == itemIndexToTest) &amp;&amp; (gridState == static_cast&lt;size_t&gt;(_currentState))) 
1085  						continue;
1086  					if (isConflict(vShortcuts[itemIndex].getKeyCombo(), itemKeyComboToTest))
1087  					{
1088  						retIsConflict = true;
1089  						if (keyConflictLocation == nullptr)
1090  							return retIsConflict;
1091  						else
1092  						{
1093  							if (!keyConflictLocation-&gt;empty())
1094  								*keyConflictLocation += TEXT(&quot;\r\n&quot;);
1095  							*keyConflictLocation += _tabNames[gridState];
1096  							*keyConflictLocation += TEXT(&quot;  |  &quot;);
1097  							*keyConflictLocation += std::to_wstring(itemIndex + 1);
1098  							*keyConflictLocation += TEXT(&quot;   &quot;);
1099  							*keyConflictLocation += string2wstring(vShortcuts[itemIndex].getName(), CP_UTF8);;
1100  							*keyConflictLocation += TEXT(&quot;  ( &quot;);
1101  							*keyConflictLocation += string2wstring(vShortcuts[itemIndex].toString(), CP_UTF8);
1102  							*keyConflictLocation += TEXT(&quot; )&quot;);
1103  						}
1104  					}
1105  				}
1106  				break;
1107  			} 
1108  			case STATE_SCINTILLA:
1109  			{
1110  				vector&lt;ScintillaKeyMap&gt; &amp; vShortcuts = nppParam.getScintillaKeyList();
1111  				size_t nbItems = vShortcuts.size();
1112  				for (size_t itemIndex = 0; itemIndex &lt; nbItems; ++itemIndex)
1113  				{
1114  					if (!vShortcuts[itemIndex].isEnabled()) 
1115  						continue;
1116  					if ((itemIndex == itemIndexToTest) &amp;&amp; (gridState == static_cast&lt;size_t&gt;(_currentState))) 
1117  						continue;
1118  					size_t sciCombos = vShortcuts[itemIndex].getSize();
1119  					for (size_t sciIndex = 0; sciIndex &lt; sciCombos; ++sciIndex)
1120  					{
1121  						if (isConflict(vShortcuts[itemIndex].getKeyComboByIndex(sciIndex), itemKeyComboToTest))
1122  						{
1123  							retIsConflict = true;
1124  							if (keyConflictLocation == nullptr)
1125  								return retIsConflict;
1126  							else
1127  							{
1128  								if (!keyConflictLocation-&gt;empty())
1129  									*keyConflictLocation += TEXT(&quot;\r\n&quot;);
1130  								*keyConflictLocation += _tabNames[gridState];
1131  								*keyConflictLocation += TEXT(&quot;  |  &quot;);
1132  								*keyConflictLocation += std::to_wstring(itemIndex + 1);
1133  								if (sciIndex &gt; 0)
1134  									*keyConflictLocation += TEXT(&quot;*   &quot;);
1135  								else
1136  									*keyConflictLocation += TEXT(&quot;   &quot;);
1137  								*keyConflictLocation += string2wstring(vShortcuts[itemIndex].getName(), CP_UTF8);
1138  								*keyConflictLocation += TEXT(&quot;  ( &quot;);
1139  								*keyConflictLocation += string2wstring(vShortcuts[itemIndex].toString(sciIndex), CP_UTF8);
1140  								*keyConflictLocation += TEXT(&quot; )&quot;);
1141  							}
1142  						}
1143  					}
1144  				}
1145  				break;
1146  			}
1147  		}
1148  	}
1149  	return retIsConflict;
1150  }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ShortcutMapper.cpp</h3>
            <pre><code>1  #include &quot;ShortcutMapper.h&quot;
2  #include &quot;Notepad_plus.h&quot;
3  using namespace std;
4  void ShortcutMapper::initTabs()
5  {
6  	HWND hTab = _hTabCtrl = ::GetDlgItem(_hSelf, IDC_BABYGRID_TABBAR);
7  	NppDarkMode::subclassTabControl(hTab);
8  	TCITEM tie{};
9  	tie.mask = TCIF_TEXT;
10  	for (size_t i = 0; i &lt; _nbTab; ++i)
11  	{
12  		_tabNames[i] = getTabString(i);
13  		tie.pszText = const_cast&lt;LPWSTR&gt;(_tabNames[i].c_str());
14  		::SendMessage(hTab, TCM_INSERTITEM, i, reinterpret_cast&lt;LPARAM&gt;(&amp;tie));
15  	}
16      TabCtrl_SetCurSel(_hTabCtrl, int(_currentState));
17  	RECT rcTab{};
18  	WINDOWPLACEMENT wp{};
19  	wp.length = sizeof(wp);
20  	::GetWindowPlacement(hTab, &amp;wp);
21  	::SendMessage(hTab, TCM_GETITEMRECT, 0, reinterpret_cast&lt;LPARAM&gt;(&amp;rcTab));
22  	wp.rcNormalPosition.bottom = NppParameters::getInstance()._dpiManager.scaleY(30);
23  	wp.rcNormalPosition.top = wp.rcNormalPosition.bottom - rcTab.bottom;
24  	::SetWindowPlacement(hTab, &amp;wp);
25  }
26  void ShortcutMapper::getClientRect(RECT &amp; rc) const 
27  {
28  		Window::getClientRect(rc);
29  		RECT tabRect{}, btnRect{};
30  		::GetClientRect(::GetDlgItem(_hSelf, IDC_BABYGRID_TABBAR), &amp;tabRect);
31  		int tabH = tabRect.bottom - tabRect.top;
32  		int paddingTop = tabH / 2;
33  		rc.top += tabH + paddingTop;
34  		RECT infoRect{}, filterRect{};
35  		::GetClientRect(::GetDlgItem(_hSelf, IDC_BABYGRID_INFO), &amp;infoRect);
36  		::GetClientRect(::GetDlgItem(_hSelf, IDC_BABYGRID_FILTER), &amp;filterRect);
37  		::GetClientRect(::GetDlgItem(_hSelf, IDOK), &amp;btnRect);
38  		int infoH = infoRect.bottom - infoRect.top;
39  		int filterH = filterRect.bottom - filterRect.top;
40  		int btnH = btnRect.bottom - btnRect.top;
41  		int paddingBottom = btnH + NppParameters::getInstance()._dpiManager.scaleY(16);
42  		rc.bottom -= btnH + filterH + infoH + paddingBottom;
43  		rc.left += NppParameters::getInstance()._dpiManager.scaleX(5);
44  		rc.right -= NppParameters::getInstance()._dpiManager.scaleX(5);
45  }
46  generic_string ShortcutMapper::getTabString(size_t i) const
47  {
48  	if (i &gt;= _nbTab)
49  		return TEXT(&quot;&quot;);
50  	NativeLangSpeaker* nativeLangSpeaker = NppParameters::getInstance().getNativeLangSpeaker();
51  	switch (i)
52  	{
53  		case 1:
54  			return nativeLangSpeaker-&gt;getShortcutMapperLangStr(&quot;MacrosTab&quot;, TEXT(&quot;Macros&quot;));
55  		case 2:
56  			return nativeLangSpeaker-&gt;getShortcutMapperLangStr(&quot;RunCommandsTab&quot;, TEXT(&quot;Run commands&quot;));
57  		case 3:
58  			return nativeLangSpeaker-&gt;getShortcutMapperLangStr(&quot;PluginCommandsTab&quot;, TEXT(&quot;Plugin commands&quot;));
59  		case 4:
60  			return nativeLangSpeaker-&gt;getShortcutMapperLangStr(&quot;ScintillaCommandsTab&quot;, TEXT(&quot;Scintilla commands&quot;));
61  		default: 
62  			return nativeLangSpeaker-&gt;getShortcutMapperLangStr(&quot;MainMenuTab&quot;, TEXT(&quot;Main menu&quot;));
63  	}
64  }
65  void ShortcutMapper::initBabyGrid()
66  {
67  	RECT rect{};
68  	getClientRect(rect);
69  	_lastHomeRow.resize(5, 1);
70  	_lastCursorRow.resize(5, 1);
71  	_hGridFonts.resize(MAX_GRID_FONTS);
72  	_hGridFonts.at(GFONT_HEADER) = ::CreateFont(
73  		NppParameters::getInstance()._dpiManager.scaleY(18), 0, 0, 0, FW_BOLD,
74  		FALSE, FALSE, FALSE, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH,
75  		TEXT(&quot;MS Shell Dlg&quot;));
76  	_hGridFonts.at(GFONT_ROWS) = ::CreateFont(
77  		NppParameters::getInstance()._dpiManager.scaleY(16), 0, 0, 0, FW_NORMAL,
78  		FALSE, FALSE, FALSE, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH,
79  		TEXT(&quot;MS Shell Dlg&quot;));
80  	_babygrid.init(_hInst, _hSelf, IDD_BABYGRID_ID1);
81  	NppDarkMode::setDarkScrollBar(_babygrid.getHSelf());
82  	_babygrid.setHeaderFont(_hGridFonts.at(GFONT_HEADER));
83  	_babygrid.setRowFont(_hGridFonts.at(GFONT_ROWS));
84  	_babygrid.reSizeToWH(rect);
85  	_babygrid.hideCursor();
86  	_babygrid.makeColAutoWidth(true);
87  	_babygrid.setAutoRow(true);
88  	_babygrid.setColsNumbered(false);
89  	_babygrid.setColWidth(0, NppParameters::getInstance()._dpiManager.scaleX(30));  
90  	_babygrid.setHeaderHeight(NppParameters::getInstance()._dpiManager.scaleY(21));
91  	_babygrid.setRowHeight(NppParameters::getInstance()._dpiManager.scaleY(21));
92  	if (NppDarkMode::isEnabled())
93  	{
94  		_babygrid.setTextColor(NppDarkMode::getDarkerTextColor());
95  		_babygrid.setHighlightTextColor(NppDarkMode::getTextColor());
96  		_babygrid.setTitleTextColor(NppDarkMode::getTextColor());
97  		_babygrid.setUnprotectColor(NppDarkMode::getBackgroundColor());
98  		_babygrid.setTitleColor(NppDarkMode::getBackgroundColor());
99  		_babygrid.setBackgroundColor(NppDarkMode::getDarkerBackgroundColor());
100  		_babygrid.setHighlightColor(NppDarkMode::getHotBackgroundColor());
101  		_babygrid.setHighlightColorNoFocus(NppDarkMode::getSofterBackgroundColor());
102  		_babygrid.setProtectColor(NppDarkMode::getErrorBackgroundColor());
103  		_babygrid.setHighlightColorProtect(RGB(244, 10, 20));
104  		_babygrid.setHighlightColorProtectNoFocus(RGB(230, 100, 110));
105  		_babygrid.setGridlinesColor(NppDarkMode::getEdgeColor());
106  		_babygrid.setTitleGridlinesColor(NppDarkMode::getHotEdgeColor());
107  	}
108  	else
109  	{
110  		_babygrid.setTextColor(RGB(0, 0, 0));
111  		_babygrid.setHighlightTextColor(RGB(255, 255, 255));
112  		_babygrid.setTitleTextColor(RGB(0, 0, 0));
113  		_babygrid.setUnprotectColor(RGB(255, 255, 255));
114  		_babygrid.setTitleColor(::GetSysColor(COLOR_BTNFACE));
115  		_babygrid.setBackgroundColor(::GetSysColor(COLOR_BTNFACE));
116  		_babygrid.setHighlightColor(RGB(0, 0, 128));
117  		_babygrid.setHighlightColorNoFocus(RGB(200, 200, 210));
118  		_babygrid.setProtectColor(RGB(255, 130, 120));
119  		_babygrid.setHighlightColorProtect(RGB(244, 10, 20));
120  		_babygrid.setHighlightColorProtectNoFocus(RGB(230, 194, 190));
121  		_babygrid.setGridlinesColor(RGB(220, 220, 220));
122  		_babygrid.setTitleGridlinesColor(RGB(120, 120, 120));
123  	}
124  	NativeLangSpeaker* nativeLangSpeaker = NppParameters::getInstance().getNativeLangSpeaker();
125  	nativeLangSpeaker-&gt;changeDlgLang(_hSelf, &quot;ShortcutMapper&quot;);
126  	_conflictInfoOk = nativeLangSpeaker-&gt;getShortcutMapperLangStr(&quot;ConflictInfoOk&quot;, TEXT(&quot;No shortcut conflicts for this item.&quot;));
127  	_conflictInfoEditing = nativeLangSpeaker-&gt;getShortcutMapperLangStr(&quot;ConflictInfoEditing&quot;, TEXT(&quot;No conflicts . . .&quot;));
128  }
129  generic_string ShortcutMapper::getTextFromCombo(HWND hCombo)
130  {
131  	const int NB_MAX(128);
132  	TCHAR str[NB_MAX](TEXT(&quot;\0&quot;));
133  	::SendMessage(hCombo, WM_GETTEXT, NB_MAX, reinterpret_cast&lt;LPARAM&gt;(str));
134  	generic_string res(str);
135  	return stringToLower(res);
136  }
137  bool ShortcutMapper::isFilterValid(Shortcut sc)
138  {
139  	if (_shortcutFilter.empty())
140  		return true;
141  	wstring shortcut_name = stringToLower(string2wstring(sc.getName(), CP_UTF8));
142  	wstring shortcut_value = stringToLower(string2wstring(sc.toString(), CP_UTF8));
143  	return (shortcut_name.find(_shortcutFilter) != std::string::npos) || 
144  		(shortcut_value.find(_shortcutFilter) != std::string::npos);
145  }
146  bool ShortcutMapper::isFilterValid(PluginCmdShortcut sc)
147  {
148  	Shortcut shortcut = sc;
149  	bool match = false;
150  	wstring module_name = stringToLower(string2wstring(sc.getModuleName(), CP_UTF8));
151  	if (isFilterValid(shortcut)){
152  		return true;
153  	}
154  	size_t match_pos = module_name.find(_shortcutFilter);
155  	if (match_pos != std::string::npos){
156  		match = true;
157  	}
158  	return match;
159  }
160  void ShortcutMapper::fillOutBabyGrid()
161  {
162  	NppParameters&amp; nppParam = NppParameters::getInstance();
163  	_babygrid.clear();
164  	_babygrid.setInitialContent(true);
165  	_shortcutIndex.clear();
166  	size_t nbItems = 0;
167  	NativeLangSpeaker* nativeLangSpeaker = nppParam.getNativeLangSpeaker();
168  	generic_string nameStr = nativeLangSpeaker-&gt;getShortcutMapperLangStr(&quot;ColumnName&quot;, TEXT(&quot;Name&quot;));
169  	generic_string shortcutStr = nativeLangSpeaker-&gt;getShortcutMapperLangStr(&quot;ColumnShortcut&quot;, TEXT(&quot;Shortcut&quot;));
170  	_babygrid.setText(0, 1, nameStr.c_str());
171  	_babygrid.setText(0, 2, shortcutStr.c_str());
172  	switch(_currentState)
173  	{
174  		case STATE_MENU:
175  		{
176  			nbItems = nppParam.getUserShortcuts().size();
177  			_babygrid.setLineColNumber(nbItems, 3);
178  			generic_string categoryStr = nativeLangSpeaker-&gt;getShortcutMapperLangStr(&quot;ColumnCategory&quot;, TEXT(&quot;Category&quot;));
179  			_babygrid.setText(0, 3, categoryStr.c_str());
180  		}
181  		break;
182  		case STATE_MACRO:
183  		{
184  			nbItems = nppParam.getMacroList().size();
185  			_babygrid.setLineColNumber(nbItems, 2);
186  		}
187  		break;
188  		case STATE_USER:
189  		{
190  			nbItems = nppParam.getUserCommandList().size();
191  			_babygrid.setLineColNumber(nbItems, 2);
192  		}
193  		break;
194  		case STATE_PLUGIN:
195  		{
196  			nbItems = nppParam.getPluginCommandList().size();
197  			_babygrid.setLineColNumber(nbItems, 3);
198  			generic_string pluginStr = nativeLangSpeaker-&gt;getShortcutMapperLangStr(&quot;ColumnPlugin&quot;, TEXT(&quot;Plugin&quot;));
199  			_babygrid.setText(0, 3, pluginStr.c_str());
200  		}
201  		break;
202  		case STATE_SCINTILLA:
203  		{
204  			nbItems = nppParam.getScintillaKeyList().size();
205  			_babygrid.setLineColNumber(nbItems, 2);
206  		}
207  		break;
208  	}
209  	bool isMarker = false;
210  	size_t cs_index = 0;
211  	_shortcutFilter = getTextFromCombo(::GetDlgItem(_hSelf, IDC_BABYGRID_FILTER));
212  	switch(_currentState) 
213  	{
214  		case STATE_MENU:
215  		{
216  			vector&lt;CommandShortcut&gt; &amp; cshortcuts = nppParam.getUserShortcuts();
217  			cs_index = 1;
218  			for (size_t i = 0; i &lt; nbItems; ++i)
219  			{
220  				if (isFilterValid(cshortcuts[i]))
221  				{
222  					if (findKeyConflicts(nullptr, cshortcuts[i].getKeyCombo(), i))
223  						isMarker = _babygrid.setMarker(true);
224  					_babygrid.setText(cs_index, 1, string2wstring(cshortcuts[i].getName(), CP_UTF8).c_str());
225  					if (cshortcuts[i].isEnabled()) 
226  						_babygrid.setText(cs_index, 2, string2wstring(cshortcuts[i].toString(), CP_UTF8).c_str());
227  					const TCHAR* category = cshortcuts[i].getCategory();
228  					generic_string categoryStr = nativeLangSpeaker-&gt;getShortcutMapperLangStr((std::string(wstring2string(category, CP_UTF8)) + &quot;Category&quot;).c_str(), category);
229  					_babygrid.setText(cs_index, 3, categoryStr.c_str());
230  					if (isMarker)
231  						isMarker = _babygrid.setMarker(false);
232  					_shortcutIndex.push_back(i);
233  					cs_index++;
234  				}
235  			}
236  			_babygrid.setLineColNumber(cs_index - 1 , 3);
237  			::EnableWindow(::GetDlgItem(_hSelf, IDM_BABYGRID_MODIFY), true);
238  			::EnableWindow(::GetDlgItem(_hSelf, IDM_BABYGRID_CLEAR), true);
239  			::EnableWindow(::GetDlgItem(_hSelf, IDM_BABYGRID_DELETE), false);
240  		}
241  		break;
242  		case STATE_MACRO:
243  		{
244  			vector&lt;MacroShortcut&gt; &amp; cshortcuts = nppParam.getMacroList();
245  			cs_index = 1;
246  			for (size_t i = 0; i &lt; nbItems; ++i)
247  			{
248  				if (isFilterValid(cshortcuts[i]))
249  				{
250  					if (findKeyConflicts(nullptr, cshortcuts[i].getKeyCombo(), i))
251  						isMarker = _babygrid.setMarker(true);
252  					_babygrid.setText(cs_index, 1, string2wstring(cshortcuts[i].getName(), CP_UTF8).c_str());
253  					if (cshortcuts[i].isEnabled()) 
254  						_babygrid.setText(cs_index, 2, string2wstring(cshortcuts[i].toString(), CP_UTF8).c_str());
255  					if (isMarker)
256  						isMarker = _babygrid.setMarker(false);
257  					_shortcutIndex.push_back(i);
258  					cs_index++;
259  				}
260  			}
261  			_babygrid.setLineColNumber(cs_index - 1 , 2);
262              bool shouldBeEnabled = nbItems &gt; 0;
263              ::EnableWindow(::GetDlgItem(_hSelf, IDM_BABYGRID_MODIFY), shouldBeEnabled);
264              ::EnableWindow(::GetDlgItem(_hSelf, IDM_BABYGRID_CLEAR), shouldBeEnabled);
265              ::EnableWindow(::GetDlgItem(_hSelf, IDM_BABYGRID_DELETE), shouldBeEnabled);
266  		}
267  		break;
268  		case STATE_USER:
269  		{
270  			vector&lt;UserCommand&gt; &amp; cshortcuts = nppParam.getUserCommandList();
271  			cs_index = 1;
272  			for (size_t i = 0; i &lt; nbItems; ++i)
273  			{
274  				if (isFilterValid(cshortcuts[i]))
275  				{
276  					if (findKeyConflicts(nullptr, cshortcuts[i].getKeyCombo(), i))
277  						isMarker = _babygrid.setMarker(true);
278  					_babygrid.setText(cs_index, 1, string2wstring(cshortcuts[i].getName(), CP_UTF8).c_str());
279  					if (cshortcuts[i].isEnabled()) 
280  						_babygrid.setText(cs_index, 2, string2wstring(cshortcuts[i].toString(), CP_UTF8).c_str());
281  					if (isMarker)
282  						isMarker = _babygrid.setMarker(false);
283  					_shortcutIndex.push_back(i);
284  					cs_index++;
285  				}
286  			}
287  			_babygrid.setLineColNumber(cs_index - 1 , 2);
288              bool shouldBeEnabled = nbItems &gt; 0;
289              ::EnableWindow(::GetDlgItem(_hSelf, IDM_BABYGRID_MODIFY), shouldBeEnabled);
290              ::EnableWindow(::GetDlgItem(_hSelf, IDM_BABYGRID_CLEAR), shouldBeEnabled);
291              ::EnableWindow(::GetDlgItem(_hSelf, IDM_BABYGRID_DELETE), shouldBeEnabled);
292  		}
293  		break;
294  		case STATE_PLUGIN:
295  		{
296  			vector&lt;PluginCmdShortcut&gt; &amp; cshortcuts = nppParam.getPluginCommandList();
297  			cs_index = 1;
298  			for (size_t i = 0; i &lt; nbItems; ++i)
299  			{
300  				if (isFilterValid(cshortcuts[i]))
301  				{
302  					if (findKeyConflicts(nullptr, cshortcuts[i].getKeyCombo(), i))
303  						isMarker = _babygrid.setMarker(true);
304  					_babygrid.setText(cs_index, 1, string2wstring(cshortcuts[i].getName(), CP_UTF8).c_str());
305  					if (cshortcuts[i].isEnabled()) 
306  						_babygrid.setText(cs_index, 2, string2wstring(cshortcuts[i].toString(), CP_UTF8).c_str());
307  					_babygrid.setText(cs_index, 3, string2wstring(cshortcuts[i].getModuleName(), CP_UTF8).c_str());
308  					if (isMarker)
309  						isMarker = _babygrid.setMarker(false);
<span onclick='openModal()' class='match'>310  					_shortcutIndex.push_back(i);
311  					cs_index++;
312  				}
313  			}
314  			_babygrid.setLineColNumber(cs_index - 1 , 3);
315              bool shouldBeEnabled = nbItems &gt; 0;
</span>316              ::EnableWindow(::GetDlgItem(_hSelf, IDM_BABYGRID_MODIFY), shouldBeEnabled);
317              ::EnableWindow(::GetDlgItem(_hSelf, IDM_BABYGRID_CLEAR), shouldBeEnabled);
318              ::EnableWindow(::GetDlgItem(_hSelf, IDM_BABYGRID_DELETE), false);
319  		}
320  		break;
321  		case STATE_SCINTILLA:
322  		{
323  			vector&lt;ScintillaKeyMap&gt; &amp; cshortcuts = nppParam.getScintillaKeyList();
324  			cs_index=1;
325  			for (size_t i = 0; i &lt; nbItems; ++i)
326  			{
327  				if (isFilterValid(cshortcuts[i]))
328  				{
329  					if (cshortcuts[i].isEnabled())
330  					{
331  						size_t sciCombos = cshortcuts[i].getSize();
332  						for (size_t sciIndex = 0; sciIndex &lt; sciCombos; ++sciIndex)
333  						{
334  							if (findKeyConflicts(nullptr, cshortcuts[i].getKeyComboByIndex(sciIndex), i))
335  							{
336  								isMarker = _babygrid.setMarker(true);
337  								break;
338  							}
339  						}
340  					}
341  					_babygrid.setText(cs_index, 1, string2wstring(cshortcuts[i].getName(), CP_UTF8).c_str());
342  					if (cshortcuts[i].isEnabled()) 
343  						_babygrid.setText(cs_index, 2, string2wstring(cshortcuts[i].toString(), CP_UTF8).c_str());
344  					if (isMarker)
345  						isMarker = _babygrid.setMarker(false);
346  					_shortcutIndex.push_back(i);
347  					cs_index++;
348  				}
349  			}
350  			_babygrid.setLineColNumber(cs_index - 1 , 2);
351              ::EnableWindow(::GetDlgItem(_hSelf, IDM_BABYGRID_MODIFY), true);
352              ::EnableWindow(::GetDlgItem(_hSelf, IDM_BABYGRID_CLEAR), false);
353              ::EnableWindow(::GetDlgItem(_hSelf, IDM_BABYGRID_DELETE), false);
354  		}
355  		break;
356  	}
357  	if (nbItems &gt; 0) 
358  		_babygrid.setLastView(_lastHomeRow[_currentState], _lastCursorRow[_currentState]);
359  	else 
360  		::SendDlgItemMessage(_hSelf, IDC_BABYGRID_INFO, WM_SETTEXT, 0, 0);
361  	_babygrid.setInitialContent(false);
362  }
363  intptr_t CALLBACK ShortcutMapper::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
364  {
365  	switch (message) 
366  	{
367  		case WM_INITDIALOG :
368  		{
369  			initBabyGrid();
370  			initTabs();
371  			fillOutBabyGrid();
372  			_babygrid.display();	
373  			goToCenter();
374  			NppDarkMode::autoSubclassAndThemeChildControls(_hSelf);
375  			RECT rect;
376  			Window::getClientRect(rect);
377  			_clientWidth = rect.right - rect.left;
378  			_clientHeight = rect.bottom - rect.top;
379  			int cy_border = GetSystemMetrics(SM_CYFRAME);
380  			int cy_caption = GetSystemMetrics(SM_CYCAPTION);
381  			_initClientWidth = _clientWidth;
382  			_initClientHeight = _clientHeight + cy_caption + cy_border;
383  			_dialogInitDone = true;
384  			return TRUE;
385  		}
386  		case WM_CTLCOLOREDIT:
387  		{
388  			return NppDarkMode::onCtlColorSofter(reinterpret_cast&lt;HDC&gt;(wParam));
389  		}
390  		case WM_CTLCOLORDLG:
391  		case WM_CTLCOLORSTATIC:
392  		{
393  			return NppDarkMode::onCtlColorDarker(reinterpret_cast&lt;HDC&gt;(wParam));
394  		}
395  		case WM_PRINTCLIENT:
396  		{
397  			if (NppDarkMode::isEnabled())
398  			{
399  				return TRUE;
400  			}
401  			break;
402  		}
403  		case NPPM_INTERNAL_REFRESHDARKMODE:
404  		{
405  			NppDarkMode::autoThemeChildControls(_hSelf);
406  			return TRUE;
407  		}
408  		case WM_GETMINMAXINFO :
409  		{
410  			MINMAXINFO* mmi = (MINMAXINFO*)lParam;
411  			if (_dialogInitDone)
412  			{
413  				mmi-&gt;ptMinTrackSize.x = _initClientWidth;
414  				mmi-&gt;ptMinTrackSize.y = _initClientHeight;
415  			}
416  			return 0;
417  		}
418  		case WM_DESTROY:
419  		{
420  			for (const HFONT &amp; hFont : _hGridFonts)
421  				::DeleteObject(hFont);
422  			_hGridFonts.clear();
423  			_hGridFonts.shrink_to_fit();
424  			break;
425  		}
426  		case WM_SIZE:
427  		{
428  			LONG newWidth = LOWORD(lParam);
429  			LONG newHeight = HIWORD(lParam);
430  			RECT rect;
431  			LONG addWidth = newWidth - _clientWidth;
432  			LONG addHeight = newHeight - _clientHeight;
433  			_clientWidth = newWidth;
434  			_clientHeight = newHeight;
435  			getClientRect(rect);
436  			_babygrid.reSizeToWH(rect);
437  			const auto moveWindowIDs = {
438  				IDM_BABYGRID_MODIFY, IDM_BABYGRID_CLEAR, IDM_BABYGRID_DELETE, IDOK
439  			};
440  			const UINT flags = SWP_NOZORDER | SWP_NOOWNERZORDER | SWP_NOACTIVATE | SWP_NOCOPYBITS;
441  			Window::getClientRect(rect);
442  			for (int moveWndID : moveWindowIDs)
443  			{
444  				HWND moveHwnd = ::GetDlgItem(_hSelf, moveWndID);
445  				::GetWindowRect(moveHwnd, &amp;rect);
446  				::MapWindowPoints(NULL, _hSelf, (LPPOINT)&amp;rect, 2);
447  				::SetWindowPos(moveHwnd, NULL, rect.left + addWidth / 2, rect.top + addHeight, 0, 0, SWP_NOSIZE | flags);
448  			}
449  			HWND moveHwnd = ::GetDlgItem(_hSelf, IDC_BABYGRID_STATIC);
450  			::GetWindowRect(moveHwnd, &amp;rect);
451  			::MapWindowPoints(NULL, _hSelf, (LPPOINT)&amp;rect, 2);
452  			::SetWindowPos(moveHwnd, NULL, rect.left, rect.top + addHeight, 0, 0, SWP_NOSIZE | flags);
453  			HWND resizeHwnd = ::GetDlgItem(_hSelf, IDC_BABYGRID_INFO);
454  			::GetWindowRect(resizeHwnd, &amp;rect);
455  			::MapWindowPoints(NULL, _hSelf, (LPPOINT)&amp;rect, 2);
456  			::SetWindowPos(resizeHwnd, NULL, rect.left, rect.top + addHeight, rect.right - rect.left + addWidth, rect.bottom - rect.top, flags);
457  			resizeHwnd = ::GetDlgItem(_hSelf, IDC_BABYGRID_FILTER);
458  			::GetWindowRect(resizeHwnd, &amp;rect);
459  			::MapWindowPoints(NULL, _hSelf, (LPPOINT)&amp;rect, 2);
460  			::SetWindowPos(resizeHwnd, NULL, rect.left, rect.top + addHeight, rect.right - rect.left + addWidth, rect.bottom - rect.top, flags);
461  			break;
462  		}
463  		break;
464  		case WM_NOTIFY:
465  		{
466  			NMHDR nmh = *((NMHDR*)lParam);
467  			if (nmh.hwndFrom == _hTabCtrl)
468  			{
469  				if (nmh.code == TCN_SELCHANGE)
470  				{
471  					_lastHomeRow[_currentState] = _babygrid.getHomeRow();
472  					_lastCursorRow[_currentState] = _babygrid.getSelectedRow();
473  					int index = TabCtrl_GetCurSel(_hTabCtrl);
474  					switch (index)
475  					{
476  						case 0:
477  							_currentState = STATE_MENU;
478  							break;
479  						case 1:
480  							_currentState = STATE_MACRO;
481  							break;
482  						case 2:
483  							_currentState = STATE_USER;
484  							break;
485  						case 3:
486  							_currentState = STATE_PLUGIN;
487  							break;
488  						case 4:
489  							_currentState = STATE_SCINTILLA;
490  							break;
491  					}
492  					fillOutBabyGrid();
493  				}
494  			}
495  		}
496  		break;
497  		case NPPM_INTERNAL_FINDKEYCONFLICTS:
498  		{
499  			if (!wParam || !lParam)
500  				break;
501  			generic_string conflictInfo;
502  			size_t realIndexOfSelectedItem = _shortcutIndex[_babygrid.getSelectedRow() - 1];
503  			const bool isConflict = findKeyConflicts(&amp;conflictInfo, *reinterpret_cast&lt;KeyCombo*&gt;(wParam), realIndexOfSelectedItem);
504  			*reinterpret_cast&lt;bool*&gt;(lParam) = isConflict;
505  			if (isConflict)
506  				::SendDlgItemMessage(_hSelf, IDC_BABYGRID_INFO, WM_SETTEXT, 0, reinterpret_cast&lt;LPARAM&gt;(conflictInfo.c_str()));
507  			else
508  				::SendDlgItemMessage(_hSelf, IDC_BABYGRID_INFO, WM_SETTEXT, 0, reinterpret_cast&lt;LPARAM&gt;(_conflictInfoEditing.c_str()));
509  			return TRUE;
510  		}
511  		case WM_COMMAND : 
512  		{
513  			switch (LOWORD(wParam))
514  			{
515  				case IDCANCEL :
516  				{
517  					::EndDialog(_hSelf, -1);
518  					return TRUE;
519  				}
520  				case IDOK :
521  				{
522  					::EndDialog(_hSelf, 0);
523  					return TRUE;
524  				}
525  				case IDM_BABYGRID_CLEAR :
526  				{
527  					if (_babygrid.getNumberRows() &lt; 1)
528  						return TRUE;
529  					NppParameters&amp; nppParam = NppParameters::getInstance();
530  					int row = _babygrid.getSelectedRow();
531  					size_t shortcutIndex = _shortcutIndex[row-1];
532  					bool isModified = false;
533  					switch(_currentState)
534  					{
535  						case STATE_MENU:
536  						{
537  							vector&lt;CommandShortcut&gt; &amp; shortcuts = nppParam.getUserShortcuts();
538  							CommandShortcut csc = shortcuts[shortcutIndex];
539  							csc.clear();
540  							shortcuts[shortcutIndex] = csc;
541  							nppParam.addUserModifiedIndex(shortcutIndex);
542  							_lastHomeRow[_currentState] = _babygrid.getHomeRow();
543  							_lastCursorRow[_currentState] = _babygrid.getSelectedRow();
544  							fillOutBabyGrid();
545  							isModified = true;
546  							nppParam.getAccelerator()-&gt;updateShortcuts();
547  							nppParam.setShortcutDirty();
548  						}
549  						break;
550  						case STATE_MACRO: 
551  						{
552  							vector&lt;MacroShortcut&gt; &amp; shortcuts = nppParam.getMacroList();
553  							MacroShortcut msc = shortcuts[shortcutIndex];
554  							msc.clear();
555  							shortcuts[shortcutIndex] = msc;
556  							_lastHomeRow[_currentState] = _babygrid.getHomeRow();
557  							_lastCursorRow[_currentState] = _babygrid.getSelectedRow();
558  							fillOutBabyGrid();
559  							isModified = true;
560  							nppParam.getAccelerator()-&gt;updateShortcuts();
561  							nppParam.setShortcutDirty();
562  						}
563  						break;
564  						case STATE_USER: 
565  						{
566  							vector&lt;UserCommand&gt; &amp; shortcuts = nppParam.getUserCommandList();
567  							UserCommand ucmd = shortcuts[shortcutIndex];
568  							ucmd.clear();
569  							shortcuts[shortcutIndex] = ucmd;
570  							_lastHomeRow[_currentState] = _babygrid.getHomeRow();
571  							_lastCursorRow[_currentState] = _babygrid.getSelectedRow();
572  							fillOutBabyGrid();
573  							isModified = true;
574  							nppParam.getAccelerator()-&gt;updateShortcuts();
575  							nppParam.setShortcutDirty();
576  						}
577  						break;
578  						case STATE_PLUGIN: 
579  						{
580  							vector&lt;PluginCmdShortcut&gt; &amp; shortcuts = nppParam.getPluginCommandList();
581  							PluginCmdShortcut pcsc = shortcuts[shortcutIndex];
582  							pcsc.clear();
583  							nppParam.addPluginModifiedIndex(shortcutIndex);
584  							shortcuts[shortcutIndex] = pcsc;
585  							_lastHomeRow[_currentState] = _babygrid.getHomeRow();
586  							_lastCursorRow[_currentState] = _babygrid.getSelectedRow();
587  							fillOutBabyGrid();
588  							isModified = true;
589  							nppParam.getAccelerator()-&gt;updateShortcuts();
590  							unsigned long cmdID = pcsc.getID();
591  							ShortcutKey shortcut;
592  							shortcut._isAlt = FALSE;
593  							shortcut._isCtrl = FALSE;
594  							shortcut._isShift = FALSE;
595  							shortcut._key = &#x27;\0&#x27;;
596  							::SendMessage(_hParent, NPPM_INTERNAL_PLUGINSHORTCUTMOTIFIED, cmdID, reinterpret_cast&lt;LPARAM&gt;(&amp;shortcut));
597  							nppParam.setShortcutDirty();
598  						}
599  						break;
600  						case STATE_SCINTILLA: 
601  						{
602  						}
603  						break;
604  					}
605  					if (!isModified)
606  						::SendMessage(_hSelf, WM_COMMAND, MAKEWPARAM(IDD_BABYGRID_ID1, BGN_ROWCHANGED), row);
607  					return TRUE;
608  				}
609  				case IDM_BABYGRID_MODIFY :
610  				{
611  					if (_babygrid.getNumberRows() &lt; 1)
612  						return TRUE;
613  					NppParameters&amp; nppParam = NppParameters::getInstance();
614  					int row = _babygrid.getSelectedRow();
615  					size_t shortcutIndex = _shortcutIndex[row-1];
616  					bool isModified = false;
617  					switch(_currentState)
618  					{
619  						case STATE_MENU:
620  						{
621  							vector&lt;CommandShortcut&gt; &amp; shortcuts = nppParam.getUserShortcuts();
622  							CommandShortcut csc = shortcuts[shortcutIndex], prevcsc = shortcuts[shortcutIndex];
623  							csc.init(_hInst, _hSelf);
624  							if (csc.doDialog() != -1 &amp;&amp; prevcsc != csc)
625  							{
626  								nppParam.addUserModifiedIndex(shortcutIndex);
627  								shortcuts[shortcutIndex] = csc;
628  								_lastHomeRow[_currentState] = _babygrid.getHomeRow();
629  								_lastCursorRow[_currentState] = _babygrid.getSelectedRow();
630  								fillOutBabyGrid();
631  								isModified = true;
632  								nppParam.getAccelerator()-&gt;updateShortcuts();
633  								nppParam.setShortcutDirty();
634  							}
635  						}
636  						break;
637  						case STATE_MACRO: 
638  						{
639  							vector&lt;MacroShortcut&gt; &amp; shortcuts = nppParam.getMacroList();
640  							MacroShortcut msc = shortcuts[shortcutIndex], prevmsc = shortcuts[shortcutIndex];
641  							msc.init(_hInst, _hSelf);
642  							if (msc.doDialog() != -1 &amp;&amp; prevmsc != msc)
643  							{
644  								shortcuts[shortcutIndex] = msc;
645  								_lastHomeRow[_currentState] = _babygrid.getHomeRow();
646  								_lastCursorRow[_currentState] = _babygrid.getSelectedRow();
647  								fillOutBabyGrid();
648  								isModified = true;
649  								nppParam.getAccelerator()-&gt;updateShortcuts();
650  								nppParam.setShortcutDirty();
651  							}
652  						}
653  						break; 
654  						case STATE_USER: 
655  						{
656  							vector&lt;UserCommand&gt; &amp; shortcuts = nppParam.getUserCommandList();
657  							UserCommand ucmd = shortcuts[shortcutIndex];
658  							ucmd.init(_hInst, _hSelf);
659  							UserCommand prevucmd = ucmd;
660  							if (ucmd.doDialog() != -1 &amp;&amp; prevucmd != ucmd)
661  							{
662  								shortcuts[shortcutIndex] = ucmd;
663  								_lastHomeRow[_currentState] = _babygrid.getHomeRow();
664  								_lastCursorRow[_currentState] = _babygrid.getSelectedRow();
665  								fillOutBabyGrid();
666  								isModified = true;
667  								nppParam.getAccelerator()-&gt;updateShortcuts();
668  								nppParam.setShortcutDirty();
669  							}
670  						}
671  						break; 
672  						case STATE_PLUGIN:
673  						{
674  							vector&lt;PluginCmdShortcut&gt; &amp; shortcuts = nppParam.getPluginCommandList();
675  							PluginCmdShortcut pcsc = shortcuts[shortcutIndex];
676  							pcsc.init(_hInst, _hSelf);
677  							PluginCmdShortcut prevpcsc = pcsc;
678  							if (pcsc.doDialog() != -1 &amp;&amp; prevpcsc != pcsc)
679  							{
680  								nppParam.addPluginModifiedIndex(shortcutIndex);
681  								shortcuts[shortcutIndex] = pcsc;
682  								_lastHomeRow[_currentState] = _babygrid.getHomeRow();
683  								_lastCursorRow[_currentState] = _babygrid.getSelectedRow();
684  								fillOutBabyGrid();
685  								isModified = true;
686  								nppParam.getAccelerator()-&gt;updateShortcuts();
687  								unsigned long cmdID = pcsc.getID();
688  								ShortcutKey shortcut;
689  								shortcut._isAlt = pcsc.getKeyCombo()._isAlt;
690  								shortcut._isCtrl = pcsc.getKeyCombo()._isCtrl;
691  								shortcut._isShift = pcsc.getKeyCombo()._isShift;
692  								shortcut._key = pcsc.getKeyCombo()._key;
693  								::SendMessage(_hParent, NPPM_INTERNAL_PLUGINSHORTCUTMOTIFIED, cmdID, reinterpret_cast&lt;LPARAM&gt;(&amp;shortcut));
694  								nppParam.setShortcutDirty();
695  							}
696  						}
697  						break;
698  						case STATE_SCINTILLA:
699  						{
700  							vector&lt;ScintillaKeyMap&gt; &amp; shortcuts = nppParam.getScintillaKeyList();
701  							ScintillaKeyMap skm = shortcuts[shortcutIndex], prevskm = shortcuts[shortcutIndex];
702  							skm.init(_hInst, _hSelf);
703  							if (skm.doDialog() != -1 &amp;&amp; prevskm != skm)
704  							{
705  								nppParam.addScintillaModifiedIndex((int)shortcutIndex);
706  								shortcuts[shortcutIndex] = skm;
707  								_lastHomeRow[_currentState] = _babygrid.getHomeRow();
708  								_lastCursorRow[_currentState] = _babygrid.getSelectedRow();
709  								fillOutBabyGrid();
710  								_babygrid.updateView();
711  								isModified = true;
712  								nppParam.getScintillaAccelerator()-&gt;updateKeys();
713  								nppParam.setShortcutDirty();
714  							}
715  						}
716  						break;  
717  					}
718  					if (!isModified)
719  						::SendMessage(_hSelf, WM_COMMAND, MAKEWPARAM(IDD_BABYGRID_ID1, BGN_ROWCHANGED), row);
720  					return TRUE;
721  				}
722  				case IDM_BABYGRID_DELETE :
723  				{
724  					if (_babygrid.getNumberRows() &lt; 1)
725  						return TRUE;
726  					NppParameters&amp; nppParam = NppParameters::getInstance();
727  					int res = nppParam.getNativeLangSpeaker()-&gt;messageBox(&quot;SCMapperDoDeleteOrNot&quot;,
728  						_hSelf,
729  						TEXT(&quot;Are you sure you want to delete this shortcut?&quot;),
730  						TEXT(&quot;Are you sure?&quot;),
731  						MB_OKCANCEL);
732  					if (res == IDOK)
733  					{
734  						const int row = _babygrid.getSelectedRow();
735  						size_t shortcutIndex = _shortcutIndex[row-1];
736  						switch(_currentState) 
737  						{
738  							case STATE_MENU:
739  							case STATE_PLUGIN:
740  							case STATE_SCINTILLA: 
741  							{
742  								return FALSE;
743  							}
744  							case STATE_MACRO: 
745  							{
746  								vector&lt;MacroShortcut&gt; &amp; theMacros = nppParam.getMacroList();
747  								theMacros.erase(theMacros.begin() + shortcutIndex);
748  								_lastHomeRow[_currentState] = _babygrid.getHomeRow();
749  								_lastCursorRow[_currentState] = _babygrid.getSelectedRow();
750  								const size_t numberRows = _babygrid.getNumberRows();
751  								if (_lastHomeRow[_currentState] == numberRows)
752  									--_lastHomeRow[_currentState];
753  								if (_lastCursorRow[_currentState] == numberRows)
754  									--_lastCursorRow[_currentState];
755  								fillOutBabyGrid();
756  								DynamicMenu&amp; macroMenu = nppParam.getMacroMenuItems();
757  								macroMenu.clearMenu();
758  								macroMenu.erase(shortcutIndex);
759  								size_t nbElem = theMacros.size();
760  								for (size_t i = shortcutIndex; i &lt; nbElem; ++i)	
761  								{
762  									MacroShortcut ms = theMacros[i];
763  									ms.setID(ms.getID() - 1);	
764  									theMacros[i] = ms;
765  									MenuItemUnit&amp; miu = macroMenu.getItemFromIndex(i);
766  									miu._cmdID -= 1;	
767  								}
768  								macroMenu.createMenu();
769  								HMENU m = reinterpret_cast&lt;HMENU&gt;(::SendMessage(_hParent, NPPM_INTERNAL_GETMENU, 0, 0));
770  								HMENU hMenu = ::GetSubMenu(m, MENUINDEX_MACRO);
771  								if (!hMenu) return FALSE;
772  								int32_t posBase = macroMenu.getPosBase();
773  								if (nbElem == 0)
774  								{
775  									::RemoveMenu(hMenu, IDM_SETTING_SHORTCUT_MAPPER_MACRO, MF_BYCOMMAND);
776  									::RemoveMenu(hMenu, posBase - 1, MF_BYPOSITION);
777  									::RemoveMenu(hMenu, posBase - 1, MF_BYPOSITION);
778  								}
779  							}
780  							break; 
781  							case STATE_USER: 
782  							{
783  								vector&lt;UserCommand&gt; &amp; theUserCmds = nppParam.getUserCommandList();
784  								theUserCmds.erase(theUserCmds.begin() + shortcutIndex);
785  								_lastHomeRow[_currentState] = _babygrid.getHomeRow();
786  								_lastCursorRow[_currentState] = _babygrid.getSelectedRow();
787  								const size_t numberRows = _babygrid.getNumberRows();
788  								if (_lastHomeRow[_currentState] == numberRows)
789  									--_lastHomeRow[_currentState];
790  								if (_lastCursorRow[_currentState] == numberRows)
791  									--_lastCursorRow[_currentState];
792  								fillOutBabyGrid();
793  								DynamicMenu&amp; runMenu = nppParam.getRunMenuItems();
794  								runMenu.clearMenu();
795  								runMenu.erase(shortcutIndex);
796  								size_t nbElem = theUserCmds.size();
797  								for (size_t i = shortcutIndex; i &lt; nbElem; ++i)	
798  								{
799  									UserCommand uc = theUserCmds[i];
800  									uc.setID(uc.getID() - 1);	
801  									theUserCmds[i] = uc;
802  									MenuItemUnit&amp; miu = runMenu.getItemFromIndex(i);
803  									miu._cmdID -= 1;	
804  								}
805  								runMenu.createMenu();
806  								HMENU m = reinterpret_cast&lt;HMENU&gt;(::SendMessage(_hParent, NPPM_INTERNAL_GETMENU, 0, 0));
807  								HMENU hMenu = ::GetSubMenu(m, MENUINDEX_RUN);
808  								if (!hMenu) return FALSE;
809  								int32_t posBase = runMenu.getPosBase();
810  								if (nbElem == 0)
811  								{
812  									::RemoveMenu(hMenu, IDM_SETTING_SHORTCUT_MAPPER_RUN, MF_BYCOMMAND);
813  									::RemoveMenu(hMenu, posBase - 1, MF_BYPOSITION);
814  									::RemoveMenu(hMenu, posBase - 1, MF_BYPOSITION);
815  								}
816  							}
817  							break;
818  						}
819  						nppParam.getAccelerator()-&gt;updateShortcuts();
820  						nppParam.setShortcutDirty();
821  					}
822  					return TRUE;
823  				}
824  				case IDD_BABYGRID_ID1: 
825  				{
826  					switch (HIWORD(wParam))
827  					{
828  						case BGN_CELLDBCLICKED: 
829  						{
830  							return ::SendMessage(_hSelf, WM_COMMAND, IDM_BABYGRID_MODIFY, LOWORD(lParam));
831  						}
832  						case BGN_CELLRCLICKED: 
833  						{
834  							POINT p{};
835  							::GetCursorPos(&amp;p);
836  							if (!_rightClickMenu.isCreated())
837  							{
838  								vector&lt;MenuItemUnit&gt; itemUnitArray;
839  								NativeLangSpeaker* nativeLangSpeaker = NppParameters::getInstance().getNativeLangSpeaker();
840  								generic_string modifyStr = nativeLangSpeaker-&gt;getShortcutMapperLangStr(&quot;ModifyContextMenu&quot;, TEXT(&quot;Modify&quot;));
841  								generic_string deleteStr = nativeLangSpeaker-&gt;getShortcutMapperLangStr(&quot;DeleteContextMenu&quot;, TEXT(&quot;Delete&quot;));
842  								generic_string clearStr = nativeLangSpeaker-&gt;getShortcutMapperLangStr(&quot;ClearContextMenu&quot;, TEXT(&quot;Clear&quot;));
843  								itemUnitArray.push_back(MenuItemUnit(IDM_BABYGRID_MODIFY, modifyStr.c_str()));
844  								itemUnitArray.push_back(MenuItemUnit(IDM_BABYGRID_DELETE, deleteStr.c_str()));
845  								itemUnitArray.push_back(MenuItemUnit(IDM_BABYGRID_CLEAR, clearStr.c_str()));
846  								_rightClickMenu.create(_hSelf, itemUnitArray);
847  							}
848  							if (_babygrid.getNumberRows() &lt; 1)
849  							{
850  								_rightClickMenu.enableItem(IDM_BABYGRID_MODIFY, false);
851  								_rightClickMenu.enableItem(IDM_BABYGRID_DELETE, false);
852  								_rightClickMenu.enableItem(IDM_BABYGRID_CLEAR, false);
853  							}
854  							else
855  							{
856  								_rightClickMenu.enableItem(IDM_BABYGRID_MODIFY, true);
857  								_rightClickMenu.enableItem(IDM_BABYGRID_DELETE, true);
858  								if (_currentState == STATE_SCINTILLA)
859  									_rightClickMenu.enableItem(IDM_BABYGRID_CLEAR, false);
860  								else
861  									_rightClickMenu.enableItem(IDM_BABYGRID_CLEAR, true);
862  								switch(_currentState)
863  								{
864  									case STATE_MACRO:
865  									case STATE_USER:
866  									{
867  										_rightClickMenu.enableItem(IDM_BABYGRID_DELETE, true);
868  									}
869  									break;
870  									case STATE_MENU:
871  									case STATE_PLUGIN:
872  									case STATE_SCINTILLA:
873  									{
874  										_rightClickMenu.enableItem(IDM_BABYGRID_DELETE, false);
875  									}
876  									break;
877  								}
878  							}
879  							_rightClickMenu.display(p);
880  							return TRUE;
881  						}
882  						case BGN_DELETECELL: 
883  						{
884  							switch(_currentState) 
885  							{
886  								case STATE_MACRO:
887  								case STATE_USER:
888  									return ::SendMessage(_hSelf, WM_COMMAND, IDM_BABYGRID_DELETE, 0);
889  								case STATE_MENU:
890  								case STATE_PLUGIN:
891  								case STATE_SCINTILLA:
892  								default:
893  									break;
894  							}
895  							return TRUE;
896  						}
897  						case BGN_ROWCHANGED:
898  						{
899  							if (_babygrid.getNumberRows() &lt; 1)
900  								return TRUE;
901  							NppParameters&amp; nppParam = NppParameters::getInstance();
902  							const size_t currentIndex = LOWORD(lParam) - 1;
903  							size_t realIndexOfSelectedItem = _shortcutIndex[currentIndex];
904  							generic_string conflictInfo;
905  							switch (_currentState)
906  							{
907  								case STATE_MENU:
908  								{
909  									vector&lt;CommandShortcut&gt; &amp; vShortcuts = nppParam.getUserShortcuts();
910  									findKeyConflicts(&amp;conflictInfo, vShortcuts[realIndexOfSelectedItem].getKeyCombo(), realIndexOfSelectedItem);
911  								}
912  								break;
913  								case STATE_MACRO:
914  								{
915  									vector&lt;MacroShortcut&gt; &amp; vShortcuts = nppParam.getMacroList();
916  									findKeyConflicts(&amp;conflictInfo, vShortcuts[realIndexOfSelectedItem].getKeyCombo(), realIndexOfSelectedItem);
917  								}
918  								break;
919  								case STATE_USER:
920  								{
921  									vector&lt;UserCommand&gt; &amp; vShortcuts = nppParam.getUserCommandList();
922  									findKeyConflicts(&amp;conflictInfo, vShortcuts[realIndexOfSelectedItem].getKeyCombo(), realIndexOfSelectedItem);
923  								}
924  								break;
925  								case STATE_PLUGIN:
926  								{
927  									vector&lt;PluginCmdShortcut&gt; &amp; vShortcuts = nppParam.getPluginCommandList();
928  									findKeyConflicts(&amp;conflictInfo, vShortcuts[realIndexOfSelectedItem].getKeyCombo(), realIndexOfSelectedItem);
929  								}
930  								break;
931  								case STATE_SCINTILLA:
932  								{
933  									vector&lt;ScintillaKeyMap&gt; &amp; vShortcuts = nppParam.getScintillaKeyList();
934  									size_t sciCombos = vShortcuts[realIndexOfSelectedItem].getSize();
935  									for (size_t sciIndex = 0; sciIndex &lt; sciCombos; ++sciIndex)
936  										findKeyConflicts(&amp;conflictInfo, vShortcuts[realIndexOfSelectedItem].getKeyComboByIndex(sciIndex), realIndexOfSelectedItem);
937  								}
938  								break;
939  							}
940  							if (conflictInfo.empty())
941  								::SendDlgItemMessage(_hSelf, IDC_BABYGRID_INFO, WM_SETTEXT, 0, reinterpret_cast&lt;LPARAM&gt;(_conflictInfoOk.c_str()));
942  							else
943  								::SendDlgItemMessage(_hSelf, IDC_BABYGRID_INFO, WM_SETTEXT, 0, reinterpret_cast&lt;LPARAM&gt;(conflictInfo.c_str()));
944  							return TRUE;
945  						}
946  					}
947  					break;
948  				}
949  				case IDC_BABYGRID_FILTER:
950  				{
951  					if (HIWORD(wParam) == EN_CHANGE)
952  					{
953  						fillOutBabyGrid();
954  					}
955  					return TRUE;
956  				}
957  				default:
958  				{
959  					break;
960  				}
961  			}
962  			break;
963  		}
964  		default:
965  			return FALSE;
966  	}
967  	return FALSE;
968  }
969  bool ShortcutMapper::findKeyConflicts(__inout_opt generic_string * const keyConflictLocation,
970  										const KeyCombo &amp; itemKeyComboToTest, const size_t &amp; itemIndexToTest) const
971  {
972  	if (itemKeyComboToTest._key == 0) 
973  		return false;
974  	bool retIsConflict = false; 
975  	NppParameters&amp; nppParam = NppParameters::getInstance();
976  	for (size_t gridState = STATE_MENU; gridState &lt;= STATE_SCINTILLA; ++gridState)
977  	{
978  		switch (gridState)
979  		{
980  			case STATE_MENU:
981  			{
982  				vector&lt;CommandShortcut&gt; &amp; vShortcuts = nppParam.getUserShortcuts();
983  				size_t nbItems = vShortcuts.size();
984  				for (size_t itemIndex = 0; itemIndex &lt; nbItems; ++itemIndex)
985  				{
986  					if (!vShortcuts[itemIndex].isEnabled()) 
987  						continue;
988  					if ((itemIndex == itemIndexToTest) &amp;&amp; (gridState == static_cast&lt;size_t&gt;(_currentState))) 
989  						continue;
990  					if (isConflict(vShortcuts[itemIndex].getKeyCombo(), itemKeyComboToTest))
991  					{
992  						retIsConflict = true;
993  						if (keyConflictLocation == nullptr)
994  							return retIsConflict;
995  						else
996  						{
997  							if (!keyConflictLocation-&gt;empty())
998  								*keyConflictLocation += TEXT(&quot;\r\n&quot;);
999  							*keyConflictLocation += _tabNames[gridState];
1000  							*keyConflictLocation += TEXT(&quot;  |  &quot;);
1001  							*keyConflictLocation += std::to_wstring(itemIndex + 1);
1002  							*keyConflictLocation += TEXT(&quot;   &quot;);
1003  							*keyConflictLocation += string2wstring(vShortcuts[itemIndex].getName(), CP_UTF8);
1004  							*keyConflictLocation += TEXT(&quot;  ( &quot;);
1005  							*keyConflictLocation += string2wstring(vShortcuts[itemIndex].toString(), CP_UTF8);
1006  							*keyConflictLocation += TEXT(&quot; )&quot;);
1007  						}
1008  					}
1009  				}
1010  				break;
1011  			} 
1012  			case STATE_MACRO:
1013  			{
1014  				vector&lt;MacroShortcut&gt; &amp; vShortcuts = nppParam.getMacroList();
1015  				size_t nbItems = vShortcuts.size();
1016  				for (size_t itemIndex = 0; itemIndex &lt; nbItems; ++itemIndex)
1017  				{
1018  					if (!vShortcuts[itemIndex].isEnabled()) 
1019  						continue;
1020  					if ((itemIndex == itemIndexToTest) &amp;&amp; (gridState == static_cast&lt;size_t&gt;(_currentState))) 
1021  						continue;
1022  					if (isConflict(vShortcuts[itemIndex].getKeyCombo(), itemKeyComboToTest))
1023  					{
1024  						retIsConflict = true;
1025  						if (keyConflictLocation == nullptr)
1026  							return retIsConflict;
1027  						else
1028  						{
1029  							if (!keyConflictLocation-&gt;empty())
1030  								*keyConflictLocation += TEXT(&quot;\r\n&quot;);
1031  							*keyConflictLocation += _tabNames[gridState];
1032  							*keyConflictLocation += TEXT(&quot;  |  &quot;);
1033  							*keyConflictLocation += std::to_wstring(itemIndex + 1);
1034  							*keyConflictLocation += TEXT(&quot;   &quot;);
1035  							*keyConflictLocation += string2wstring(vShortcuts[itemIndex].getName(), CP_UTF8);
1036  							*keyConflictLocation += TEXT(&quot;  ( &quot;);
1037  							*keyConflictLocation += string2wstring(vShortcuts[itemIndex].toString(), CP_UTF8);
1038  							*keyConflictLocation += TEXT(&quot; )&quot;);
1039  						}
1040  					}
1041  				}
1042  				break;
1043  			} 
1044  			case STATE_USER:
1045  			{
1046  				vector&lt;UserCommand&gt; &amp; vShortcuts = nppParam.getUserCommandList();
1047  				size_t nbItems = vShortcuts.size();
1048  				for (size_t itemIndex = 0; itemIndex &lt; nbItems; ++itemIndex)
1049  				{
1050  					if (!vShortcuts[itemIndex].isEnabled()) 
1051  						continue;
1052  					if ((itemIndex == itemIndexToTest) &amp;&amp; (gridState == static_cast&lt;size_t&gt;(_currentState))) 
1053  						continue;
1054  					if (isConflict(vShortcuts[itemIndex].getKeyCombo(), itemKeyComboToTest))
1055  					{
1056  						retIsConflict = true;
1057  						if (keyConflictLocation == nullptr)
1058  							return retIsConflict;
1059  						else
1060  						{
1061  							if (!keyConflictLocation-&gt;empty())
1062  								*keyConflictLocation += TEXT(&quot;\r\n&quot;);
1063  							*keyConflictLocation += _tabNames[gridState];
1064  							*keyConflictLocation += TEXT(&quot;  |  &quot;);
1065  							*keyConflictLocation += std::to_wstring(itemIndex + 1);
1066  							*keyConflictLocation += TEXT(&quot;   &quot;);
1067  							*keyConflictLocation += string2wstring(vShortcuts[itemIndex].getName(), CP_UTF8);
1068  							*keyConflictLocation += TEXT(&quot;  ( &quot;);
1069  							*keyConflictLocation += string2wstring(vShortcuts[itemIndex].toString(), CP_UTF8);
1070  							*keyConflictLocation += TEXT(&quot; )&quot;);
1071  						}
1072  					}
1073  				}
1074  				break;
1075  			} 
1076  			case STATE_PLUGIN:
1077  			{
1078  				vector&lt;PluginCmdShortcut&gt; &amp; vShortcuts = nppParam.getPluginCommandList();
1079  				size_t nbItems = vShortcuts.size();
1080  				for (size_t itemIndex = 0; itemIndex &lt; nbItems; ++itemIndex)
1081  				{
1082  					if (!vShortcuts[itemIndex].isEnabled()) 
1083  						continue;
1084  					if ((itemIndex == itemIndexToTest) &amp;&amp; (gridState == static_cast&lt;size_t&gt;(_currentState))) 
1085  						continue;
1086  					if (isConflict(vShortcuts[itemIndex].getKeyCombo(), itemKeyComboToTest))
1087  					{
1088  						retIsConflict = true;
1089  						if (keyConflictLocation == nullptr)
1090  							return retIsConflict;
1091  						else
1092  						{
1093  							if (!keyConflictLocation-&gt;empty())
1094  								*keyConflictLocation += TEXT(&quot;\r\n&quot;);
1095  							*keyConflictLocation += _tabNames[gridState];
1096  							*keyConflictLocation += TEXT(&quot;  |  &quot;);
1097  							*keyConflictLocation += std::to_wstring(itemIndex + 1);
1098  							*keyConflictLocation += TEXT(&quot;   &quot;);
1099  							*keyConflictLocation += string2wstring(vShortcuts[itemIndex].getName(), CP_UTF8);;
1100  							*keyConflictLocation += TEXT(&quot;  ( &quot;);
1101  							*keyConflictLocation += string2wstring(vShortcuts[itemIndex].toString(), CP_UTF8);
1102  							*keyConflictLocation += TEXT(&quot; )&quot;);
1103  						}
1104  					}
1105  				}
1106  				break;
1107  			} 
1108  			case STATE_SCINTILLA:
1109  			{
1110  				vector&lt;ScintillaKeyMap&gt; &amp; vShortcuts = nppParam.getScintillaKeyList();
1111  				size_t nbItems = vShortcuts.size();
1112  				for (size_t itemIndex = 0; itemIndex &lt; nbItems; ++itemIndex)
1113  				{
1114  					if (!vShortcuts[itemIndex].isEnabled()) 
1115  						continue;
1116  					if ((itemIndex == itemIndexToTest) &amp;&amp; (gridState == static_cast&lt;size_t&gt;(_currentState))) 
1117  						continue;
1118  					size_t sciCombos = vShortcuts[itemIndex].getSize();
1119  					for (size_t sciIndex = 0; sciIndex &lt; sciCombos; ++sciIndex)
1120  					{
1121  						if (isConflict(vShortcuts[itemIndex].getKeyComboByIndex(sciIndex), itemKeyComboToTest))
1122  						{
1123  							retIsConflict = true;
1124  							if (keyConflictLocation == nullptr)
1125  								return retIsConflict;
1126  							else
1127  							{
1128  								if (!keyConflictLocation-&gt;empty())
1129  									*keyConflictLocation += TEXT(&quot;\r\n&quot;);
1130  								*keyConflictLocation += _tabNames[gridState];
1131  								*keyConflictLocation += TEXT(&quot;  |  &quot;);
1132  								*keyConflictLocation += std::to_wstring(itemIndex + 1);
1133  								if (sciIndex &gt; 0)
1134  									*keyConflictLocation += TEXT(&quot;*   &quot;);
1135  								else
1136  									*keyConflictLocation += TEXT(&quot;   &quot;);
1137  								*keyConflictLocation += string2wstring(vShortcuts[itemIndex].getName(), CP_UTF8);
1138  								*keyConflictLocation += TEXT(&quot;  ( &quot;);
1139  								*keyConflictLocation += string2wstring(vShortcuts[itemIndex].toString(sciIndex), CP_UTF8);
1140  								*keyConflictLocation += TEXT(&quot; )&quot;);
1141  							}
1142  						}
1143  					}
1144  				}
1145  				break;
1146  			}
1147  		}
1148  	}
1149  	return retIsConflict;
1150  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ShortcutMapper.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ShortcutMapper.cpp</div>
                </div>
                <div class="column column_space"><pre><code>283  					_shortcutIndex.push_back(i);
284  					cs_index++;
285  				}
286  			}
287  			_babygrid.setLineColNumber(cs_index - 1 , 2);
288              bool shouldBeEnabled = nbItems &gt; 0;
</pre></code></div>
                <div class="column column_space"><pre><code>310  					_shortcutIndex.push_back(i);
311  					cs_index++;
312  				}
313  			}
314  			_babygrid.setLineColNumber(cs_index - 1 , 3);
315              bool shouldBeEnabled = nbItems &gt; 0;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    