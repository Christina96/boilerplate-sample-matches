
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 11.847233047544817%, Tokens: 9</h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-apply_mn_param.cpp</h3>
            <pre><code>1  #ifdef USE_MLSL
2  #include <string>
3  #include <map>
4  #include <set>
5  #include "caffe/common.hpp"
6  #include "caffe/blob.hpp"
7  #include "caffe/util/math_functions.hpp"
8  #include "caffe/multinode/mlsl.hpp"
9  #include "caffe/multinode/apply_mn_param.hpp"
10  namespace caffe {
11  template <typename Dtype>
12  void ApplyMultinodeParams(const NetParameter& param,
13      NetParameter* param_with_mn) {
14    map<string, MnModelParallelParameter> net_layer_params;
15    map<string, MnActivationParameter> blob_param_map;
16    MultinodeParameter mn_param = param.multinode();
17    const MnParamGradCompressLayerTypeList &compress_layer_list = mn_param.compress_layer_type_list();
18    for (int param_id = 0; param_id < mn_param.model_parallel_size(); param_id++) {
19      MnModelParallelParameter model_parallel_param = mn_param.model_parallel(param_id);
20      string layer_from = model_parallel_param.layer_from();
21      string layer_to = model_parallel_param.layer_to();
22      set<string> marked_blobs;
23      for (int i = 0; i < param.layer_size(); i++) {
24        const LayerParameter& layer_param = param.layer(i);
25        bool layer_covered_by_global = false;
26        if (layer_param.name() == layer_from ||
27          layer_param.name() == layer_to) {
28          layer_covered_by_global = true;
29        } else {
30          for (int j = 0; j < layer_param.bottom_size(); j++) {
31            if (marked_blobs.find(layer_param.bottom(j)) !=
32              marked_blobs.end()) {
33              layer_covered_by_global = true;
34              break;
35            }
36          }
37        }
38        if (layer_covered_by_global) {
39          for (int j = 0; j < layer_param.top_size(); j++) {
40            marked_blobs.insert(layer_param.top(j));
41          }
42          net_layer_params[layer_param.name()] = model_parallel_param;
43          if (layer_param.type() == "LRN" &&
44              layer_param.lrn_param().norm_region() ==
45              LRNParameter_NormRegion_ACROSS_CHANNELS) {
46            net_layer_params[layer_param.name()].set_model_parts(1);
47          }
48        }
49        if (layer_param.name() == layer_to ||
50            layer_param.top_size() == 0) {
51          break;
52        }
53      }
54    }
55    map<string, MnActivationParameter> blob_mdg_map;
56    for (int i = 0; i < param.layer_size(); i++) {
57      const LayerParameter& layer_param = param.layer(i);
58      string layer_name = layer_param.name();
59      string layer_type = layer_param.type();
60      const MultinodeLayerParameter& mn_layer_param = layer_param.multinode();
61      int num_nodes = mn_layer_param.num_nodes();
62      int model_parts = mn_layer_param.model_parts();
63      if (net_layer_params.find(layer_name) != net_layer_params.end()) {
64        MnModelParallelParameter model_parallel_param =
65          net_layer_params[layer_name];
66        num_nodes = model_parallel_param.num_nodes();
67        model_parts = model_parallel_param.model_parts();
68      }
69      for (int j = 0; j < layer_param.bottom_size(); j++) {
70        string bottom_name = layer_param.bottom(j);
71        if (blob_mdg_map.find(bottom_name) != blob_mdg_map.end()) {
72          MnActivationParameter mdg = blob_mdg_map[bottom_name];
73          mdg.set_num_nodes_out(num_nodes);
74          mdg.set_model_parts_out(model_parts);
75          int num_nodes_in = mdg.num_nodes_in();
76          int num_nodes_out = mdg.num_nodes_out();
77          int model_parts_in = mdg.model_parts_in();
78          int model_parts_out = mdg.model_parts_out();
79          mn::GetCanonicalMnParam(num_nodes_in, model_parts_in);
80          mn::GetCanonicalMnParam(num_nodes_out, model_parts_out);
81          if ((model_parts_out > 1 &&
82               (layer_type == "Convolution" || layer_type == "InnerProduct" ||
83                layer_type == "Accuracy" || layer_type == "SoftmaxWithLoss")) ||
84              num_nodes_in != num_nodes_out ||
85              model_parts_in != model_parts_out) {
86            string layer_blob_name = layer_name + "/" + layer_param.bottom(j);
87            if (layer_type == "Accuracy" || layer_type == "SoftmaxWithLoss") {
88              mdg.set_need_reduce(false);
89            }
90            blob_param_map[layer_blob_name] = mdg;
91          }
92          blob_mdg_map.erase(bottom_name);
93        }
<span onclick='openModal()' class='match'>94      }
95      for (int j = 0;  j < layer_param.top_size(); j++) {
96        MnActivationParameter mdg;
97        mdg.set_num_nodes_in(num_nodes);
98        mdg.set_model_parts_in(model_parts);
99        blob_mdg_map[layer_param.top(j)] = mdg;
100      }
101    }
</span>102    param_with_mn->CopyFrom(param);
103    param_with_mn->clear_layer();
104    if (mn::is_param_server()) {
105      blob_param_map.clear();
106    }
107    for (int i = 0; i < param.layer_size(); i++) {
108      const LayerParameter& orig_layer_param = param.layer(i);
109      map<int, string> updated_blob_idx_to_name;
110      for (int j = 0; j < orig_layer_param.bottom_size(); j++) {
111        const string& bottom_blob_name = orig_layer_param.bottom(j);
112        string layer_blob_name = orig_layer_param.name() + "/" + bottom_blob_name;
113        if (blob_param_map.find(layer_blob_name) != blob_param_map.end()) {
114          LayerParameter* mn_activation_layer_param =
115            param_with_mn->add_layer();
116          string new_name = "mn_activation/" + layer_blob_name;
117          mn_activation_layer_param->Clear();
118          mn_activation_layer_param->set_name(new_name);
119          mn_activation_layer_param->set_type("MnActivation");
120          mn_activation_layer_param->add_bottom(bottom_blob_name);
121          mn_activation_layer_param->add_top(new_name);
122          MnActivationParameter *mn_activation_param =
123            mn_activation_layer_param->mutable_mn_activation_param();
124          *mn_activation_param = blob_param_map[layer_blob_name];
125          updated_blob_idx_to_name[j] = new_name;
126        }
127      }
128      LayerParameter* layer_param = param_with_mn->add_layer();
129      layer_param->CopyFrom(orig_layer_param);
130      if (net_layer_params.find(layer_param->name()) != net_layer_params.end()) {
131        MultinodeLayerParameter *mn_layer_param = layer_param->mutable_multinode();
132        const MnModelParallelParameter &mn_param = net_layer_params[layer_param->name()];
133        mn_layer_param->set_num_nodes(mn_param.num_nodes());
134        mn_layer_param->set_model_parts(mn_param.model_parts());
135      }
136      const MultinodeLayerParameter &mn_layer_param = layer_param->multinode();
137      int num_nodes = mn_layer_param.num_nodes();
138      int model_parts = mn_layer_param.model_parts();
139      mn::GetCanonicalMnParam(num_nodes, model_parts);
140      if (model_parts > 1 && !mn::is_param_server()) {
141        if (layer_param->type() == "Convolution") {
142          ConvolutionParameter *conv_param = layer_param->mutable_convolution_param();
143          int new_num_output = conv_param->num_output() / model_parts;
144          CHECK_EQ(conv_param->num_output(), model_parts * new_num_output)
145            << "Convolution layer " << layer_param->name()
146            << ": Undividible num_output " << conv_param->num_output()
147            << " by model_parts " << model_parts;
148          conv_param->set_num_output(new_num_output);
149        } else if (layer_param->type() == "InnerProduct") {
150          InnerProductParameter *ip_param = layer_param->mutable_inner_product_param();
151          int new_num_output = ip_param->num_output() / model_parts;
152          CHECK_EQ(ip_param->num_output(), model_parts * new_num_output)
153            << "InnerProduct layer " << layer_param->name()
154            << ": Undividible num_output " << ip_param->num_output()
155            << " by model_parts " << model_parts;
156          ip_param->set_num_output(ip_param->num_output() / model_parts);
157          CHECK(!ip_param->transpose()) << "Model parallelism does not support transpose!";
158        }
159        for (int j = 0; j < layer_param->blobs_size(); j++) {
160          Blob<Dtype> blob;
161          Blob<Dtype> new_blob;
162          const BlobProto &proto = layer_param->blobs(j);
163          blob.FromProto(proto);
164          vector<int> shape = blob.shape();
165          new_blob.Reshape(shape);
166          if (shape.size() > 0) {
167            if (proto.has_num() || proto.has_channels() ||
168                proto.has_height() || proto.has_width()) {
169              if (layer_param->type() == "InnerProduct") {
170                CHECK_EQ(shape.size(), 4);
171                CHECK_EQ(shape[0], 1);
172                CHECK_EQ(shape[1], 1);
173                if (shape[2] == 1) {
174                  shape.resize(1);
175                  shape[0] = blob.shape(3);
176                } else {
177                  shape.resize(2);
178                  shape[0] = blob.shape(2);
179                  shape[1] = blob.shape(3);
180                }
181                new_blob.Reshape(shape);
182              }
183            }
184            int count = blob.count() / model_parts;
185            int offset = count * (mn::get_node_id() % model_parts);
186            shape[0] /= model_parts;
187            new_blob.Reshape(shape);
188            caffe_copy(count, blob.cpu_data() + offset, new_blob.mutable_cpu_data());
189            caffe_copy(count, blob.cpu_diff() + offset, new_blob.mutable_cpu_diff());
190            BlobProto *updated_blob_proto = layer_param->mutable_blobs(j);
191            updated_blob_proto->Clear();
192            new_blob.ToProto(updated_blob_proto, true);
193          }
194        }
195      }
196      for (int j = 0; j < orig_layer_param.bottom_size(); j++) {
197        if (updated_blob_idx_to_name.find(j) != updated_blob_idx_to_name.end()) {
198          layer_param->set_bottom(j, updated_blob_idx_to_name[j]);
199        }
200      }
201    }
202    for (int i = 0; i < param_with_mn->layer_size(); i++) {
203      LayerParameter *layer_param = param_with_mn->mutable_layer(i);
204      string layer_type = layer_param->type();
205      for (int j = 0; j < compress_layer_list.layer_type_size(); j++) {
206        if (compress_layer_list.layer_type(j) == layer_type) {
207          MnParamGradCompressParameter *grad_comp_param = layer_param->mutable_mn_grad_compress_param();
208          if (grad_comp_param->param_grad_compress_enable_size() == 0) {
209            grad_comp_param->add_param_grad_compress_enable(true);
210          }
211          break;
212        }
213      }
214    }
215  }
216  template <typename Dtype>
217  void CopyMultinodeParamsFromNet(const Net<Dtype> *net, NetParameter *param) {
218    for (int i = 0; i < param->layer_size(); i++) {
219      LayerParameter* source_layer = param->mutable_layer(i);
220      const string& source_layer_name = source_layer->name();
221      int target_layer_id = 0;
222      while (target_layer_id != net->layer_names().size() &&
223             net->layer_names()[target_layer_id] != source_layer_name) {
224        ++target_layer_id;
225      }
226      if (target_layer_id == net->layer_names().size()) continue;
227      *source_layer->mutable_multinode() =
228        net->layers()[target_layer_id]->layer_param().multinode();
229    }
230  }
231  template <typename Dtype>
232  void RevertMultinodeParams(NetParameter* param, bool write_diff) {
233    NetParameter orig_param;
234    orig_param.CopyFrom(*param);
235    param->clear_layer();
236    for (int i = 0; i < orig_param.layer_size(); i++) {
237      const LayerParameter& orig_layer_param = orig_param.layer(i);
238      if (orig_layer_param.type() == "MnActivation") continue;
239      LayerParameter* layer_param = param->add_layer();
240      layer_param->CopyFrom(orig_layer_param);
241      layer_param->clear_bottom();
242      for (int j = 0; j < orig_layer_param.bottom_size(); j++) {
243        string bottom_name = orig_layer_param.bottom(j);
244        string prefix = "mn_activation/" + orig_layer_param.name() + "/";
245        if (bottom_name.find(prefix) == 0) {
246          bottom_name = bottom_name.substr(prefix.size());
247        }
248        layer_param->add_bottom(bottom_name);
249      }
250      const MultinodeLayerParameter &mn_layer_param = orig_layer_param.multinode();
251      int num_nodes = mn_layer_param.num_nodes();
252      int model_parts = mn_layer_param.model_parts();
253      mn::GetCanonicalMnParam(num_nodes, model_parts);
254      if (model_parts > 1) {
255        if (layer_param->type() == "Convolution") {
256          ConvolutionParameter *conv_param = layer_param->mutable_convolution_param();
257          conv_param->set_num_output(conv_param->num_output() * model_parts);
258        } else if (layer_param->type() == "InnerProduct") {
259          InnerProductParameter *ip_param = layer_param->mutable_inner_product_param();
260          ip_param->set_num_output(ip_param->num_output() * model_parts);
261          CHECK(!ip_param->transpose()) << "Model parallelism does not support transpose!";
262        }
263        layer_param->clear_blobs();
264        for (int j = 0; j < orig_layer_param.blobs_size(); j++) {
265          BlobProto *blob_proto = layer_param->add_blobs();
266          Blob<Dtype> orig_blob;
267          orig_blob.FromProto(orig_layer_param.blobs(j));
268          vector<int> shape = orig_blob.shape();
269          Blob<Dtype> new_blob;
270          if (shape.size() > 0) {
271            mn::Distribution *distrib = mn::get_distrib(num_nodes/model_parts, model_parts);
272            int count = orig_blob.count();
273            shape[0] *= model_parts;
274            new_blob.Reshape(shape);
275            distrib->allgather<Dtype,MLSL::GT_MODEL>(
276              orig_blob.mutable_cpu_data(), count, new_blob.mutable_cpu_data());
277            if (write_diff) {
278              distrib->allgather<Dtype,MLSL::GT_MODEL>(
279                orig_blob.mutable_cpu_diff(), count, new_blob.mutable_cpu_diff());
280            }
281          }
282          new_blob.ToProto(blob_proto, write_diff);
283        }
284      }
285      layer_param->mutable_multinode()->Clear();
286    }
287  }
288  template void ApplyMultinodeParams<float>(const NetParameter& param,
289      NetParameter* param_with_mn);
290  template void ApplyMultinodeParams<double>(const NetParameter& param,
291      NetParameter* param_with_mn);
292  template void CopyMultinodeParamsFromNet<float>(const Net<float> *net, NetParameter *param);
293  template void CopyMultinodeParamsFromNet<double>(const Net<double> *net, NetParameter *param);
294  template void RevertMultinodeParams<float>(NetParameter* param, bool write_diff);
295  template void RevertMultinodeParams<double>(NetParameter* param, bool write_diff);
296  } 
297  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-gridvcl.cpp</h3>
            <pre><code>1  #include "gridvcl.h"
2  void __fastcall TVclStrGrid::OnGridKeyDown(
3   TObject *Sender, WORD &Key, TShiftState Shift){
4    if (Key==27){
5      int ColN; int RowN;
6      if (IsSelCell(ColN, RowN)){
7        PutVal(ColN, RowN, PrevSelValStr);
8      }
9    }
10    if (Key==' '){
11      int ColN; int RowN;
12      if (IsSelCell(ColN, RowN)){
13        TVclStrGridVarType VarType; GetCellVarType(ColN, RowN, VarType);
14        if (VarType==gvtBool){ 
15          ActValCheckBox->Checked=!ActValCheckBox->Checked;
16        } else
17        if (VarType==gvtStrV){ 
18          if (ActValComboBox->Items->Count>0){
19            ActValComboBox->ItemIndex=
20             (ActValComboBox->ItemIndex+1)%ActValComboBox->Items->Count;
21            OnActValChange(ActValComboBox);
22          }
23        }
24      }
25    }
26  }
27  void __fastcall TVclStrGrid::OnGridMouseDown(
28   TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y){
29    int ColN; int RowN; StrGrid->MouseToCell(X, Y, ColN, RowN);
30    SelCell(ColN, RowN);
31  }
32  void __fastcall TVclStrGrid::OnGridMouseUp(
33   TObject *Sender, TMouseButton Button, TShiftState Shift, int X, int Y){
34    SyncToGui();
35  }
36  void __fastcall TVclStrGrid::OnGridSelectCell(
37   TObject *Sender, int ACol, int ARow, bool &CanSelect){
38    CanSelect=SelCell(ACol, ARow);
39    SyncToGui();
40  }
41  void __fastcall TVclStrGrid::OnGridSetEditText(
42   TObject *Sender, int ACol, int ARow, const AnsiString Value){
43    _OnGridSetEditText(ACol, ARow, Value.c_str());
44  }
45  void __fastcall TVclStrGrid::OnGridGetEditMask(
46   TObject *Sender, int ColN, int RowN, AnsiString& MaskStr){
47    TVclStrGridVarType VarType; GetCellVarType(ColN, RowN, VarType);
48    if (VarType==gvtStrMask){
49      MaskStr="#0.9;1; ";
50    } else {
51      MaskStr="";
52    }
53  }
54  void __fastcall TVclStrGrid::OnGridTopLeftChanged(TObject *Sender){
55    SyncToGui();
56  }
57  void __fastcall TVclStrGrid::OnActValChange(TObject *Sender){
58    TStr ValStr;
59    if (Sender==ActValEd){
60      ValStr=ActValEd->Text.c_str();
61      int ColN; int RowN;
62      if (IsSelCell(ColN, RowN)){
63        TVclStrGridVarType VarType; GetCellVarType(ColN, RowN, VarType);
64      }
65    } else
66    if (Sender==ActValCheckBox){
67      ValStr=TBool::GetYesNoStr(ActValCheckBox->Checked);
68    } else
69    if (Sender==GridValCheckBox){
70      ValStr=TBool::GetYesNoStr(GridValCheckBox->Checked);
71    } else
72    if (Sender==ActValComboBox){
73      ValStr=ActValComboBox->Text.c_str();
74    } else
75    if (Sender==GridValComboBox){
76      ValStr=GridValComboBox->Text.c_str();
77    } else
78    if (Sender==ActExtValEd){
79      ValStr=ActExtValEd->Text.c_str();
80    } else {
81      Fail;
82    }
83    int ColN; int RowN;
84    if (IsSelCell(ColN, RowN)){
85      PutVal(ColN, RowN, ValStr);
86    }
87  }
88  void __fastcall TVclStrGrid::OnActExtEdBtClick(TObject *Sender){
89    TStr ExtNm=ActExtEdBt->Caption.c_str();
90    TExtGetStrF ExtGetStrF;
91    if (IsExtGetStrF(ExtNm, ExtGetStrF)){
92      int ColN; int RowN;
93      if (IsSelCell(ColN, RowN)){
94        TStr PrevValStr=GetVal(ColN, RowN);
95        TStr NewValStr; bool OkP;
96        (*ExtGetStrF())(false, PrevValStr, NewValStr, OkP);
97        if (OkP){
98          ActExtValEd->Text=NewValStr.CStr();
99        }
100      }
101    }
102  }
103  void TVclStrGrid::EnableCtrl(TControl* Control, const bool& VisibleP){
104    if (Control!=NULL){
105      if (!Control->Enabled){Control->Enabled=true;}
106      if (Control->Visible!=VisibleP){Control->Visible=VisibleP;}
107    }
108  }
109  void TVclStrGrid::DisableCtrl(TControl* Control, const bool& VisibleP){
110    if (Control!=NULL){
111      if (Control->Enabled){Control->Enabled=false;}
112      if (Control->Visible!=VisibleP){Control->Visible=VisibleP;}
113    }
114  }
115  void TVclStrGrid::InitGrid(){
116    IAssert(StrGrid!=NULL);
117    StrGrid->ScrollBars=ssBoth;
118    StrGrid->Options.Clear();
119    StrGrid->Options<<goFixedVertLine<<goFixedHorzLine;
120    StrGrid->Options<<goVertLine<<goHorzLine;
121    StrGrid->Options<<goDrawFocusSelected<<goColSizing;
122    StrGrid->Options<<goTabs;
123    StrGrid->OnKeyDown=&OnGridKeyDown;
124    StrGrid->OnMouseDown=&OnGridMouseDown;
125    StrGrid->OnMouseUp=&OnGridMouseUp;
126    StrGrid->OnSelectCell=&OnGridSelectCell;
127    StrGrid->OnSetEditText=&OnGridSetEditText;
128    StrGrid->OnGetEditMask=&OnGridGetEditMask;
129    StrGrid->OnTopLeftChanged=&OnGridTopLeftChanged;
130  }
131  void TVclStrGrid::InitActInput(const PVclStrGrid& PrevStrGrid){
132    if (PrevStrGrid.Empty()){
133      if (ActValEd!=NULL){
134        ActValEd->OnChange=&OnActValChange;
135        ActValEd->OnKeyDown=&OnGridKeyDown;
136        ActValCheckBox=new TCheckBox(StrGrid);
137        ActValCheckBox->Parent=ActValEd->Parent;
138        ActValCheckBox->OnClick=&OnActValChange;
139        ActValCheckBox->OnKeyDown=&OnGridKeyDown;
140        ActValCheckBox->Visible=false;
141        ActValCheckBox->TabOrder=-1;
142        ActValCheckBox->Anchors=ActValEd->Anchors;
143        ActValCheckBox->Left=ActValEd->Left; ActValCheckBox->Top=ActValEd->Top;
144        ActValCheckBox->Width=ActValEd->Width; ActValCheckBox->Height=ActValEd->Height;
145        GridValCheckBox=new TCheckBox(StrGrid);
146        GridValCheckBox->Parent=StrGrid->Parent;
147        GridValCheckBox->OnClick=&OnActValChange;
148        GridValCheckBox->OnKeyDown=&OnGridKeyDown;
149        GridValCheckBox->Visible=false;
150        GridValCheckBox->TabOrder=-1;
151        GridValCheckBox->Color=clActiveCaption;
152        ActValComboBox=new TComboBox(StrGrid);
153        ActValComboBox->Parent=ActValEd->Parent;
154        ActValComboBox->OnChange=&OnActValChange;
155        ActValComboBox->OnKeyDown=&OnGridKeyDown;
156        ActValComboBox->Style=Stdctrls::csDropDownList;
157        ActValComboBox->Visible=false;
158        ActValComboBox->TabOrder=-1;
159        ActValComboBox->Anchors=ActValEd->Anchors;
160        ActValComboBox->Left=ActValEd->Left; ActValComboBox->Top=ActValEd->Top;
161        ActValComboBox->Width=ActValEd->Width; ActValComboBox->Height=ActValEd->Height;
162        GridValComboBox=new TComboBox(StrGrid);
163        GridValComboBox->Parent=StrGrid->Parent;
164        GridValComboBox->OnChange=&OnActValChange;
165        GridValComboBox->OnKeyDown=&OnGridKeyDown;
166        GridValComboBox->Style=Stdctrls::csDropDownList;
167        GridValComboBox->Visible=false;
168        GridValComboBox->TabOrder=-1;
169      } else {
170        ActValCheckBox=NULL;
171        GridValCheckBox=NULL;
172        ActValComboBox=NULL;
173        GridValComboBox=NULL;
174      }
175      ActExtEdBt=new TButton(StrGrid);
176      ActExtEdBt->Parent=ActValEd->Parent;
177      ActExtEdBt->OnClick=&OnActExtEdBtClick;
178      ActExtEdBt->Visible=false;
179      ActExtEdBt->TabOrder=-1;
180      ActExtEdBt->Anchors=ActValEd->Anchors;
181      ActExtEdBt->Anchors>>akLeft;
182      ActExtEdBt->Width=80;
183      ActExtEdBt->Height=ActValEd->Height;
184      ActExtEdBt->Left=ActValEd->Left+ActValEd->Width-ActExtEdBt->Width;
185      ActExtEdBt->Top=ActValEd->Top;
186      GridExtEdBt=new TButton(StrGrid);
187      GridExtEdBt->Parent=StrGrid->Parent;
188      GridExtEdBt->OnClick=&OnActExtEdBtClick;
189      GridExtEdBt->Visible=false;
190      GridExtEdBt->TabOrder=-1;
191      ActExtValEd=new TEdit(StrGrid);
192      ActExtValEd->Parent=ActValEd->Parent;
193      ActExtValEd->OnChange=&OnActValChange;
194      ActExtValEd->OnKeyDown=&OnGridKeyDown;
195      ActExtValEd->Visible=false;
196      ActExtValEd->TabOrder=-1;
197      ActExtValEd->Anchors=ActValEd->Anchors;
198      ActExtValEd->Left=ActValEd->Left; ActExtValEd->Top=ActValEd->Top;
199      ActExtValEd->Width=ActValEd->Width-ActExtEdBt->Width-10;
200      ActExtValEd->Height=ActValEd->Height;
201    } else {
202      IAssert(PrevStrGrid->ActValEd==ActValEd);
203    }
204  }
205  TVclStrGrid::TVclStrGrid(
206   TStringGrid* _StrGrid, TEdit* _ActValEd,
207   const int& _FixedCols, const int& _FixedRows,
208   const PVclStrGrid& PrevStrGrid):
209    GridValVV(), FixedCols(_FixedCols), FixedRows(_FixedRows),
210    StrGrid(_StrGrid), GridValCheckBox(NULL), GridValComboBox(NULL),
211    SelColN(-1), SelRowN(-1), PrevSelValStr(),
212    ActValEd(_ActValEd), ActValCheckBox(NULL), ActValComboBox(NULL),
213    ActExtValEd(NULL), GridExtEdBt(NULL), ActExtEdBt(NULL),
214    ColRowPrToVarTypeH(), ColRowPrToDfValStrH(), ColRowPrToValStrVH(){
215    GridValVV.Gen(FixedCols, FixedRows);
216    InitActInput(PrevStrGrid);
217    InitGrid();
218    UnSelCell();
219    SyncToGui();
220  }
221  PVclStrGrid TVclStrGrid::New(
222   TStringGrid* StrGrid, TEdit* ActValEd,
223   const int& FixedCols, const int& FixedRows,
224   const PVclStrGrid& PrevStrGrid){
225    if (PrevStrGrid.Empty()){
226      return new TVclStrGrid(StrGrid, ActValEd, FixedCols, FixedRows, PrevStrGrid);
227    } else {
228      PVclStrGrid StrGrid=PrevStrGrid;
229      StrGrid->FixedCols=FixedCols;
230      StrGrid->FixedRows=FixedRows;
231      StrGrid->SelColN=-1;
232      StrGrid->SelRowN=-1;
233      StrGrid->PrevSelValStr="";
234      StrGrid->ColRowPrToVarTypeH.Clr();
235      StrGrid->ColRowPrToDfValStrH.Clr();
236      StrGrid->ColRowPrToValStrVH.Clr();
237      StrGrid->GridValVV.Gen(FixedCols, FixedRows);
238      StrGrid->InitGrid();
239      StrGrid->UnSelCell();
240      StrGrid->SyncToGui();
241      return StrGrid;
242    }
243  }
244  TVclStrGrid::~TVclStrGrid(){
245    if (GridValCheckBox!=NULL){GridValCheckBox->Visible=false;}
246    if (GridValComboBox!=NULL){GridValComboBox->Visible=false;}
247    if (ActValEd!=NULL){ActValEd->Visible=false;}
248    if (ActValCheckBox!=NULL){ActValCheckBox->Visible=false;}
249    if (ActValComboBox!=NULL){ActValComboBox->Visible=false;}
250    if (ActExtValEd!=NULL){ActExtValEd->Visible=false;}
251    if (ActExtEdBt!=NULL){ActExtEdBt->Visible=false;}
252    if (GridExtEdBt!=NULL){GridExtEdBt->Visible=false;}
253  }
254  void TVclStrGrid::RegExtGetStrF(
255   const TStr& ExtNm, const TExtGetStrF& ExtGetStrF){
256    TypeToGetStrFH.AddDat(ExtNm, ExtGetStrF);
257  }
258  bool TVclStrGrid::IsExtGetStrF(const TStr& ExtNm, TExtGetStrF& ExtGetStrF) const {
259    return TypeToGetStrFH.IsKeyGetDat(ExtNm, ExtGetStrF);
260  }
261  void TVclStrGrid::SyncToGui(){
262    int GridCols=TInt::GetMx(FixedCols+1, GetCols());
263    int GridRows=TInt::GetMx(FixedRows+1, GetRows());
264    if (StrGrid->FixedCols!=FixedCols){StrGrid->FixedCols=FixedCols;}
265    if (StrGrid->FixedRows!=FixedRows){StrGrid->FixedRows=FixedRows;}
266    if (StrGrid->ColCount!=GridCols){StrGrid->ColCount=GridCols;}
267    if (StrGrid->RowCount!=GridRows){StrGrid->RowCount=GridRows;}
268    for (int ColN=0; ColN<GridCols; ColN++){
269      for (int RowN=0; RowN<GridRows; RowN++){
270        if ((ColN<GetCols())&&(RowN<GetRows())){
271          TStr ValStr=GetVal(ColN, RowN);
272          if (StrGrid->Cells[ColN][RowN]!=ValStr.CStr()){
273            StrGrid->Cells[ColN][RowN]=ValStr.CStr();
274          }
275        } else {
276          StrGrid->Cells[ColN][RowN]="";
277        }
278      }
279    }
280    SelCell(SelColN, SelRowN, false);
281  }
282  void TVclStrGrid::_OnGridSetEditText(
283   const int& ColN, const int& RowN, const TStr& ValStr){
284    if ((0<=ColN)&&(ColN<GetCols())&&(0<=RowN)&&(RowN<GetRows())){
285      At(ColN, RowN)=ValStr.CStr();
286      SelCell(ColN, RowN, false);
287    }
288  }
289  void TVclStrGrid::FitColWidth(const int& MnWidth){
290    for (int ColN=0; ColN<GetCols(); ColN++){
291      int MxWidth=0;
292      for (int RowN=0; RowN<GetRows(); RowN++){
293        TStr ValStr=GetVal(ColN, RowN);
294        int Width=StrGrid->Canvas->TextWidth(ValStr.CStr());
295        MxWidth=TInt::GetMx(MxWidth, Width);
296      }
297      MxWidth=TInt::GetMx(5+MxWidth, MnWidth);
298      StrGrid->ColWidths[ColN]=MxWidth;
299    }
300    SyncToGui();
301  }
302  void TVclStrGrid::FitRowHeight(const int& MnHeight){
303    int AllMxHeight=0;
304    for (int RowN=0; RowN<GetRows(); RowN++){
305      int MxHeight=0;
306      for (int ColN=0; ColN<GetCols(); ColN++){
307        TStr ValStr=GetVal(ColN, RowN);
308        int Height=StrGrid->Canvas->TextHeight(ValStr.CStr());
309        MxHeight=TInt::GetMx(MxHeight, Height);
310      }
311      MxHeight=TInt::GetMx(1+MxHeight, MnHeight);
312      AllMxHeight=TInt::GetMx(AllMxHeight, MxHeight);
313    }
314    StrGrid->DefaultRowHeight=AllMxHeight;
315    SyncToGui();
316  }
317  void TVclStrGrid::FitColRowSize(const int& MnColWidth, const int& MnRowHeight){
318    FitColWidth(MnColWidth);
319    FitRowHeight(MnRowHeight);
320  }
321  int TVclStrGrid::SetFontSize(const int& FontSize){
322    if (FontSize>0){
323      StrGrid->Font->Size=FontSize;
324      GridValCheckBox->Font->Size=FontSize;
325      GridValComboBox->Font->Size=FontSize;
326      GridExtEdBt->Font->Size=FontSize;
327      FitColRowSize();
328    }
329    return StrGrid->Font->Size;
330  }
331  void TVclStrGrid::SetDfGridLook(){
332    SetFontSize(8);
333    for (int ColN=0; ColN<StrGrid->ColCount; ColN++){
334      TInt ColWidth;
335      if (!ColNToWidthH.IsKeyGetDat(ColN, ColWidth)){ColWidth=64;}
336      StrGrid->ColWidths[ColN]=ColWidth;
<span onclick='openModal()' class='match'>337    }
338    for (int RowN=0; RowN<StrGrid->RowCount; RowN++){
339      StrGrid->RowHeights[RowN]=22;}
340    SyncToGui();
341  }
</span>342  bool TVclStrGrid::SelCell(
343   const int ColN, const int RowN, const bool& UpdatePrevSelValStrP){
344    if ((FixedCols<=ColN)&&(ColN<GetCols())&&(FixedRows<=RowN)&&(RowN<GetRows())){
345      if (ActValEd!=NULL){
346        SelColN=-1; SelRowN=-1;
347        TVclStrGridVarType VarType; TStrV ValStrV;
348        GetCellVarType(ColN, RowN, VarType, ValStrV);
349        if (VarType==gvtBool){ 
350          DisableCtrl(ActValEd);
351          EnableCtrl(ActValCheckBox); EnableCtrl(GridValCheckBox);
352          DisableCtrl(ActValComboBox); DisableCtrl(GridValComboBox);
353          DisableCtrl(ActExtValEd); DisableCtrl(ActExtEdBt); DisableCtrl(GridExtEdBt);
354          TRect Rect=StrGrid->CellRect(ColN, RowN);
355          GridValCheckBox->Left=3+Rect.Left&bsol;*+10*/;
356          GridValCheckBox->Top=3+Rect.Top;
357          GridValCheckBox->Width=Rect.Width()&bsol;*-10*/;
358          GridValCheckBox->Height=Rect.Height();
359          ActValCheckBox->Checked=(At(ColN, RowN)==TBool::GetYesNoStr(true));
360          GridValCheckBox->Checked=ActValCheckBox->Checked;
361        } else
362        if (VarType==gvtStrV){ 
363          DisableCtrl(ActValEd);
364          DisableCtrl(ActValCheckBox); DisableCtrl(GridValCheckBox);
365          EnableCtrl(ActValComboBox); EnableCtrl(GridValComboBox);
366          DisableCtrl(ActExtValEd); DisableCtrl(ActExtEdBt); DisableCtrl(GridExtEdBt);
367          TRect Rect=StrGrid->CellRect(ColN, RowN);
368          GridValComboBox->Left=3+Rect.Left&bsol;*+10*/;
369          GridValComboBox->Top=3+Rect.Top;
370          GridValComboBox->Width=Rect.Width()&bsol;*-10*/;
371          GridValComboBox->Height=Rect.Height();
372          ActValComboBox->Items->Clear(); GridValComboBox->Items->Clear();
373          for (int ValStrN=0; ValStrN<ValStrV.Len(); ValStrN++){
374            ActValComboBox->Items->Add(ValStrV[ValStrN].CStr());
375            GridValComboBox->Items->Add(ValStrV[ValStrN].CStr());
376          }
377          ActValComboBox->ItemIndex=
378           ActValComboBox->Items->IndexOf(At(ColN, RowN).CStr());
379          if ((ValStrV.Len()>0)&&(ActValComboBox->ItemIndex==-1)){
380            ActValComboBox->ItemIndex=0;}
381          GridValComboBox->ItemIndex=ActValComboBox->ItemIndex;
382        } else
383        if (VarType==gvtExt){ 
384          TStr ExtNm;
385          if (ColRowPrToDfValStrH.IsKeyGetDat(TIntPr(ColN, 1), ExtNm)){}
386          else if (ColRowPrToDfValStrH.IsKeyGetDat(TIntPr(1, RowN), ExtNm)){}
387          else {ExtNm="";}
388          TExtGetStrF ExtGetStrF;
389          if (IsExtGetStrF(ExtNm, ExtGetStrF)){
390            DisableCtrl(ActValEd);
391            DisableCtrl(ActValCheckBox); DisableCtrl(GridValCheckBox);
392            DisableCtrl(ActValComboBox); DisableCtrl(GridValComboBox);
393            EnableCtrl(ActExtValEd); EnableCtrl(ActExtEdBt); EnableCtrl(GridExtEdBt);
394            TRect Rect=StrGrid->CellRect(ColN, RowN);
395            GridExtEdBt->Left=3+Rect.Left;
396            GridExtEdBt->Top=3+Rect.Top;
397            GridExtEdBt->Width=Rect.Width();
398            GridExtEdBt->Height=Rect.Height();
399            int TxtWidth=10+StrGrid->Canvas->TextWidth(ExtNm.CStr());
400            if (GridExtEdBt->Width>2*TxtWidth){
401              GridExtEdBt->Left=Rect.Right-TxtWidth+1;
402              GridExtEdBt->Width=TxtWidth;
403            }
404            ActExtValEd->Text=At(ColN, RowN).CStr();
405            ActExtEdBt->Caption=ExtNm.CStr();
406            GridExtEdBt->Caption=ExtNm.CStr();
407          }
408        } else { 
409          EnableCtrl(ActValEd);
410          DisableCtrl(ActValCheckBox); DisableCtrl(GridValCheckBox);
411          DisableCtrl(ActValComboBox); DisableCtrl(GridValComboBox);
412          DisableCtrl(ActExtValEd); DisableCtrl(ActExtEdBt); DisableCtrl(GridExtEdBt);
413          ActValEd->Text=At(ColN, RowN).CStr();
414        }
415      }
416      SelColN=ColN; SelRowN=RowN;
417      if (UpdatePrevSelValStrP){PrevSelValStr=GetVal(ColN, RowN);}
418      if (IsGridCell(ColN, RowN)){
419        StrGrid->Options<<goEditing;
420      } else {
421        StrGrid->Options>>goEditing;
422      }
423      TGridRect SelRect;
424      SelRect.Left=ColN; SelRect.Top=RowN;
425      SelRect.Right=ColN; SelRect.Bottom=RowN;
426      StrGrid->Selection=SelRect;
427      return true;
428    } else {
429      UnSelCell();
430      return false;
431    }
432  }
433  void TVclStrGrid::UnSelCell(){
434    SelColN=-1; SelRowN=-1;
435    DisableCtrl(ActValEd, true);
436    DisableCtrl(ActValCheckBox); DisableCtrl(GridValCheckBox);
437    DisableCtrl(ActValComboBox); DisableCtrl(GridValComboBox);
438    DisableCtrl(ActExtValEd); DisableCtrl(ActExtEdBt); DisableCtrl(GridExtEdBt);
439    if (Empty()){ActValEd->Text="No Data";}
440    else {ActValEd->Text="";}
441    StrGrid->Options>>goEditing;
442    TGridRect SelRect;
443    SelRect.Left=-1; SelRect.Top=-1;
444    SelRect.Right=-1; SelRect.Bottom=-1;
445    StrGrid->Selection=SelRect;
446  }
447  bool TVclStrGrid::IsSelCell(int& _SelColN, int& _SelRowN) const {
448    if ((FixedCols<=SelColN)&&(SelColN<GetCols())&&
449     (FixedRows<=SelRowN)&&(SelRowN<GetRows())){
450      _SelColN=SelColN; _SelRowN=SelRowN; return true;
451    } else {
452      return false;
453    }
454  }
455  TStr TVclStrGrid::GetVal(const int& ColN, const int& RowN){
456    TStr ValStr=GridValVV.At(ColN, RowN);
457    if ((FixedCols<=ColN)&&(FixedRows<=RowN)){
458      TVclStrGridVarType VarType; TStrV ValStrV;
459      GetCellVarType(ColN, RowN, VarType, ValStrV);
460      if (VarType==gvtBool){ 
461        ValStr=TBool::GetYesNoStr(ValStr==TBool::GetYesNoStr(true));
462      } else
463      if (VarType==gvtStrV){ 
464        if (!ValStrV.IsIn(ValStr)){
465          if (ValStrV.Len()>0){ValStr=ValStrV[0];} else {ValStr="";}
466        }
467      } else
468      if (VarType==gvtFlt){ 
469        if (!ValStr.IsFlt()){ValStr="0";}
470      } else
471      if (VarType==gvtInt){ 
472        if (!ValStr.IsInt()){ValStr="0";}
473      } else
474      if (VarType==gvtExt){ 
475        TStr ExtNm;
476        if (ColRowPrToDfValStrH.IsKeyGetDat(TIntPr(ColN, 1), ExtNm)){}
477        else if (ColRowPrToDfValStrH.IsKeyGetDat(TIntPr(1, RowN), ExtNm)){}
478        else {ExtNm="";}
479        TExtGetStrF ExtGetStrF;
480        if (IsExtGetStrF(ExtNm, ExtGetStrF)){
481          TStr NewValStr; bool OkP;
482          (*ExtGetStrF())(true, ValStr, NewValStr, OkP);
483          if (OkP){ValStr=NewValStr;}
484        }
485      }
486      GridValVV.PutXY(ColN, RowN, ValStr);
487    }
488    return ValStr;
489  }
490  void TVclStrGrid::DelCol(const int& ColN){
491    GridValVV.DelX(ColN);
492    SyncToGui();
493  }
494  void TVclStrGrid::DelRow(const int& DelRowN){
495    ColRowPrToVarTypeH.DelIfKey(TIntPr(1, DelRowN));
496    ColRowPrToDfValStrH.DelIfKey(TIntPr(1, DelRowN));
497    ColRowPrToValStrVH.DelIfKey(TIntPr(1, DelRowN));
498    for (int RowN=DelRowN+1; RowN<GetRows(); RowN++){
499      TInt VarType;
500      if (ColRowPrToVarTypeH.IsKeyGetDat(TIntPr(1, RowN), VarType)){
501        ColRowPrToVarTypeH.AddDat(TIntPr(1, RowN-1), VarType);
502        ColRowPrToVarTypeH.DelKey(TIntPr(1, RowN));
503      }
504      TStr DfValStr;
505      if (ColRowPrToDfValStrH.IsKeyGetDat(TIntPr(1, RowN), DfValStr)){
506        ColRowPrToDfValStrH.AddDat(TIntPr(1, RowN-1), DfValStr);
507        ColRowPrToDfValStrH.DelKey(TIntPr(1, RowN));
508      }
509      TStrV ValStrV;
510      if (ColRowPrToValStrVH.IsKeyGetDat(TIntPr(1, RowN), ValStrV)){
511        ColRowPrToValStrVH.AddDat(TIntPr(1, RowN-1), ValStrV);
512        ColRowPrToValStrVH.DelKey(TIntPr(1, RowN));
513      }
514    }
515    GridValVV.DelY(DelRowN);
516    SyncToGui();
517  }
518  void TVclStrGrid::GetCellVarType(
519   const int& ColN, const int& RowN,
520   TVclStrGridVarType& VarType, TStrV& ValStrV) const {
521    TInt _VarType;
522    if ((FixedRows==1)&&(ColRowPrToVarTypeH.IsKeyGetDat(TIntPr(ColN, 1), _VarType))){
523      VarType=TVclStrGridVarType(int(_VarType));
524      if (VarType==gvtStrV){
525        if (ColRowPrToValStrVH.IsKeyGetDat(TIntPr(ColN, 1), ValStrV)){}
526        else {ValStrV.Clr();}
527      }
528    } else
529    if ((FixedCols==1)&&(ColRowPrToVarTypeH.IsKeyGetDat(TIntPr(1, RowN), _VarType))){
530      VarType=TVclStrGridVarType(int(_VarType));
531      if (VarType==gvtStrV){
532        if (ColRowPrToValStrVH.IsKeyGetDat(TIntPr(1, RowN), ValStrV)){}
533        else {ValStrV.Clr();}
534      }
535    } else {
536      VarType=gvtUndef; ValStrV.Clr();
537    }
538  }
539  bool TVclStrGrid::IsGridCell(const int& ColN, const int& RowN) const {
540    TVclStrGridVarType VarType; GetCellVarType(ColN, RowN, VarType);
541    return (VarType!=gvtBool)&&(VarType!=gvtStrV);
542  }
543  int TVclStrGrid::AddColVar(
544   const TStr& VarNm, const int& ColWidth,
545   const TVclStrGridVarType& VarType,
546   const TStr& DfValStr, const TStrV& ValStrV){
547    IAssert(FixedRows==1);
548    GridValVV.AddXDim();
549    int ColN=GetCols()-1;
550    At(ColN, 0)=VarNm;
551    if (ColWidth!=-1){
552      ColNToWidthH.AddDat(ColN, ColWidth);
553      StrGrid->ColCount=GetCols();
554      StrGrid->ColWidths[ColN]=ColWidth;
555    }
556    ColRowPrToVarTypeH.AddDat(TIntPr(ColN, 1), VarType);
557    if (!DfValStr.Empty()){
558      ColRowPrToDfValStrH.AddDat(TIntPr(ColN, 1), DfValStr);}
559    if (!ValStrV.Empty()){
560      ColRowPrToValStrVH.AddDat(TIntPr(ColN, 1), ValStrV);}
561    SyncToGui();
562    int VarN=GetCols()-1-FixedCols;
563    return VarN;
564  }
565  int TVclStrGrid::AddColVar(
566   const TStr& VarNm, const int& ColWidth,
567   const TVclStrGridVarType& VarType,
568   const TStr& DfValStr, const TStr& ValStrVStr, const char& SplitCh){
569    TStrV ValStrV; ValStrVStr.SplitOnAllCh(SplitCh, ValStrV);
570    return AddColVar(VarNm, ColWidth, VarType, DfValStr, ValStrV);
571  }
572  int TVclStrGrid::AddRowVar(
573   const TStr& VarNm,
574   const TVclStrGridVarType& VarType,
575   const TStr& DfValStr, const TStrV& ValStrV){
576    IAssert(FixedCols==1);
577    GridValVV.AddYDim();
578    At(0, GetRows()-1)=VarNm;
579    int RowN=GetRows()-1;
580    ColRowPrToVarTypeH.AddDat(TIntPr(1, RowN), VarType);
581    if (!DfValStr.Empty()){
582      ColRowPrToDfValStrH.AddDat(TIntPr(1, RowN), DfValStr);}
583    if (!ValStrV.Empty()){
584      ColRowPrToValStrVH.AddDat(TIntPr(1, RowN), ValStrV);}
585    SyncToGui();
586    int VarN=GetRows()-1-FixedRows;
587    return VarN;
588  }
589  TStr TVclStrGrid::GetDfColVarVal(const int& ColVarN){
590    int ColN=FixedCols+ColVarN;
591    TStr DfValStr;
592    if (ColRowPrToDfValStrH.IsKeyGetDat(TIntPr(ColN, 1), DfValStr)){
593      if ((!DfValStr.Empty())&&(DfValStr.LastCh()=='#')){
594        TStr SubDfValStr=DfValStr.GetSubStr(0, DfValStr.Len()-2);
595        DfValStr=GetUniqueColVarVal(ColVarN, SubDfValStr);
596      }
597      TVclStrGridVarType VarType; GetCellVarType(ColN, -1, VarType);
598      if (VarType==gvtExt){DfValStr="";}
599    }
600    return DfValStr;
601  }
602  int TVclStrGrid::AddColRec(){
603    GridValVV.AddXDim();
604    SyncToGui();
605    int ColRecN=GetCols()-1-FixedCols;
606    return ColRecN;
607  }
608  int TVclStrGrid::AddRowRec(){
609    GridValVV.AddYDim();
610    int RowN=GetRows()-1;
611    int RowRecN=GetRows()-1-FixedRows;
612    for (int ColVarN=0; ColVarN<GetColVars(); ColVarN++){
613      PutColVarVal(ColVarN, RowRecN, GetDfColVarVal(ColVarN));}
614    SyncToGui(); SetFocus();
615    SelCell(FixedCols, RowN);
616    return RowRecN;
617  }
618  int TVclStrGrid::AddRowRec(const TStr& VarNm, const TStrV& ValStrV){
619    int RecN=AddRowRec();
620    if (!VarNm.Empty()){RowVarNm(RecN)=VarNm;}
621    for (int VarN=0; VarN<ValStrV.Len(); VarN++){
622      ColVarVal(VarN, RecN)=ValStrV[VarN];}
623    SyncToGui();
624    return RecN;
625  }
626  TStr TVclStrGrid::GetUniqueColVarVal(const int& ColVarN, const TStr& PfxValStr){
627    int RowRecs=GetRowRecs();
628    TStrH VarValH(RowRecs);
629    for (int RowRecN=0; RowRecN<RowRecs; RowRecN++){
630      VarValH.AddDat(ColVarVal(ColVarN, RowRecN));}
631    int ValStrN=1;
632    forever{
633      TStr ValStr=PfxValStr+TInt::GetStr(ValStrN);
634      if (!VarValH.IsKey(ValStr)){return ValStr;}
635      ValStrN++;
636    }
637  }
638  void TVclStrGrid::DelSelRowRec(){
639    int DelColN; int DelRowN;
640    if (IsSelCell(DelColN, DelRowN)){
641      DelRow(DelRowN);
642      SelCell(DelColN, DelRowN);
643      if (!IsSelCell()){
644        SelCell(DelColN, DelRowN-1);}
645      SyncToGui();
646    }
647    SetFocus();
648  }
649  void TVclStrGrid::CopySelRowRec(){
650    int SrcColN; int SrcRowN;
651    if (IsSelCell(SrcColN, SrcRowN)){
652      int DstRecN=AddRowRec();
653      int DstRowN=GetRowNFromRecN(DstRecN);
654      for (int ColN=0; ColN<GetCols(); ColN++){
655        At(ColN, DstRowN)=GetVal(ColN, SrcRowN);}
656      SelCell(GetFixedCols(), GetRows()-1);
657      SyncToGui();
658    }
659    SetFocus();
660  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-apply_mn_param.cpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-gridvcl.cpp</div>
                <div class="column column_space"><pre><code>94      }
95      for (int j = 0;  j < layer_param.top_size(); j++) {
96        MnActivationParameter mdg;
97        mdg.set_num_nodes_in(num_nodes);
98        mdg.set_model_parts_in(model_parts);
99        blob_mdg_map[layer_param.top(j)] = mdg;
100      }
101    }
</pre></code></div>
                <div class="column column_space"><pre><code>337    }
338    for (int RowN=0; RowN<StrGrid->RowCount; RowN++){
339      StrGrid->RowHeights[RowN]=22;}
340    SyncToGui();
341  }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    