
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 18, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-node_hash_map_test.cc</h3>
            <pre><code>1  #include "absl/container/node_hash_map.h"
2  #include "absl/container/internal/tracked.h"
3  #include "absl/container/internal/unordered_map_constructor_test.h"
4  #include "absl/container/internal/unordered_map_lookup_test.h"
5  #include "absl/container/internal/unordered_map_members_test.h"
6  #include "absl/container/internal/unordered_map_modifiers_test.h"
7  namespace absl {
8  ABSL_NAMESPACE_BEGIN
9  namespace container_internal {
10  namespace {
11  using ::testing::Field;
12  using ::testing::IsEmpty;
13  using ::testing::Pair;
14  using ::testing::UnorderedElementsAre;
15  using MapTypes = ::testing::Types<
16      absl::node_hash_map<int, int, StatefulTestingHash, StatefulTestingEqual,
17                          Alloc<std::pair<const int, int>>>,
18      absl::node_hash_map<std::string, std::string, StatefulTestingHash,
19                          StatefulTestingEqual,
20                          Alloc<std::pair<const std::string, std::string>>>>;
21  INSTANTIATE_TYPED_TEST_SUITE_P(NodeHashMap, ConstructorTest, MapTypes);
22  INSTANTIATE_TYPED_TEST_SUITE_P(NodeHashMap, LookupTest, MapTypes);
23  INSTANTIATE_TYPED_TEST_SUITE_P(NodeHashMap, MembersTest, MapTypes);
24  INSTANTIATE_TYPED_TEST_SUITE_P(NodeHashMap, ModifiersTest, MapTypes);
25  using M = absl::node_hash_map<std::string, Tracked<int>>;
26  TEST(NodeHashMap, Emplace) {
27    M m;
28    Tracked<int> t(53);
29    m.emplace("a", t);
30    ASSERT_EQ(0, t.num_moves());
31    ASSERT_EQ(1, t.num_copies());
32    m.emplace(std::string("a"), t);
33    ASSERT_EQ(0, t.num_moves());
34    ASSERT_EQ(1, t.num_copies());
35    std::string a("a");
36    m.emplace(a, t);
37    ASSERT_EQ(0, t.num_moves());
38    ASSERT_EQ(1, t.num_copies());
39    const std::string ca("a");
40    m.emplace(a, t);
41    ASSERT_EQ(0, t.num_moves());
42    ASSERT_EQ(1, t.num_copies());
43    m.emplace(std::make_pair("a", t));
44    ASSERT_EQ(0, t.num_moves());
45    ASSERT_EQ(2, t.num_copies());
46    m.emplace(std::make_pair(std::string("a"), t));
47    ASSERT_EQ(0, t.num_moves());
48    ASSERT_EQ(3, t.num_copies());
49    std::pair<std::string, Tracked<int>> p("a", t);
50    ASSERT_EQ(0, t.num_moves());
51    ASSERT_EQ(4, t.num_copies());
52    m.emplace(p);
53    ASSERT_EQ(0, t.num_moves());
54    ASSERT_EQ(4, t.num_copies());
55    const std::pair<std::string, Tracked<int>> cp("a", t);
56    ASSERT_EQ(0, t.num_moves());
57    ASSERT_EQ(5, t.num_copies());
<span onclick='openModal()' class='match'>58    m.emplace(cp);
59    ASSERT_EQ(0, t.num_moves());
60    ASSERT_EQ(5, t.num_copies());
</span>61    std::pair<const std::string, Tracked<int>> pc("a", t);
62    ASSERT_EQ(0, t.num_moves());
63    ASSERT_EQ(6, t.num_copies());
64    m.emplace(pc);
65    ASSERT_EQ(0, t.num_moves());
66    ASSERT_EQ(6, t.num_copies());
67    const std::pair<const std::string, Tracked<int>> cpc("a", t);
68    ASSERT_EQ(0, t.num_moves());
69    ASSERT_EQ(7, t.num_copies());
70    m.emplace(cpc);
71    ASSERT_EQ(0, t.num_moves());
72    ASSERT_EQ(7, t.num_copies());
73    m.emplace(std::piecewise_construct, std::forward_as_tuple("a"),
74              std::forward_as_tuple(t));
75    ASSERT_EQ(0, t.num_moves());
76    ASSERT_EQ(7, t.num_copies());
77    m.emplace(std::piecewise_construct, std::forward_as_tuple(std::string("a")),
78              std::forward_as_tuple(t));
79    ASSERT_EQ(0, t.num_moves());
80    ASSERT_EQ(7, t.num_copies());
81  }
82  TEST(NodeHashMap, AssignRecursive) {
83    struct Tree {
84      absl::node_hash_map<int, Tree> children;
85    };
86    Tree root;
87    const Tree& child = root.children.emplace().first->second;
88    root = child;
89  }
90  TEST(FlatHashMap, MoveOnlyKey) {
91    struct Key {
92      Key() = default;
93      Key(Key&&) = default;
94      Key& operator=(Key&&) = default;
95    };
96    struct Eq {
97      bool operator()(const Key&, const Key&) const { return true; }
98    };
99    struct Hash {
100      size_t operator()(const Key&) const { return 0; }
101    };
102    absl::node_hash_map<Key, int, Hash, Eq> m;
103    m[Key()];
104  }
105  struct NonMovableKey {
106    explicit NonMovableKey(int i) : i(i) {}
107    NonMovableKey(NonMovableKey&&) = delete;
108    int i;
109  };
110  struct NonMovableKeyHash {
111    using is_transparent = void;
112    size_t operator()(const NonMovableKey& k) const { return k.i; }
113    size_t operator()(int k) const { return k; }
114  };
115  struct NonMovableKeyEq {
116    using is_transparent = void;
117    bool operator()(const NonMovableKey& a, const NonMovableKey& b) const {
118      return a.i == b.i;
119    }
120    bool operator()(const NonMovableKey& a, int b) const { return a.i == b; }
121  };
122  TEST(NodeHashMap, MergeExtractInsert) {
123    absl::node_hash_map<NonMovableKey, int, NonMovableKeyHash, NonMovableKeyEq>
124        set1, set2;
125    set1.emplace(std::piecewise_construct, std::make_tuple(7),
126                 std::make_tuple(-7));
127    set1.emplace(std::piecewise_construct, std::make_tuple(17),
128                 std::make_tuple(-17));
129    set2.emplace(std::piecewise_construct, std::make_tuple(7),
130                 std::make_tuple(-70));
131    set2.emplace(std::piecewise_construct, std::make_tuple(19),
132                 std::make_tuple(-190));
133    auto Elem = [](int key, int value) {
134      return Pair(Field(&NonMovableKey::i, key), value);
135    };
136    EXPECT_THAT(set1, UnorderedElementsAre(Elem(7, -7), Elem(17, -17)));
137    EXPECT_THAT(set2, UnorderedElementsAre(Elem(7, -70), Elem(19, -190)));
138    static_assert(!std::is_move_constructible<NonMovableKey>::value, "");
139    set1.merge(set2);
140    EXPECT_THAT(set1,
141                UnorderedElementsAre(Elem(7, -7), Elem(17, -17), Elem(19, -190)));
142    EXPECT_THAT(set2, UnorderedElementsAre(Elem(7, -70)));
143    auto node = set1.extract(7);
144    EXPECT_TRUE(node);
145    EXPECT_EQ(node.key().i, 7);
146    EXPECT_EQ(node.mapped(), -7);
147    EXPECT_THAT(set1, UnorderedElementsAre(Elem(17, -17), Elem(19, -190)));
148    auto insert_result = set2.insert(std::move(node));
149    EXPECT_FALSE(node);
150    EXPECT_FALSE(insert_result.inserted);
151    EXPECT_TRUE(insert_result.node);
152    EXPECT_EQ(insert_result.node.key().i, 7);
153    EXPECT_EQ(insert_result.node.mapped(), -7);
154    EXPECT_THAT(*insert_result.position, Elem(7, -70));
155    EXPECT_THAT(set2, UnorderedElementsAre(Elem(7, -70)));
156    node = set1.extract(17);
157    EXPECT_TRUE(node);
158    EXPECT_EQ(node.key().i, 17);
159    EXPECT_EQ(node.mapped(), -17);
160    EXPECT_THAT(set1, UnorderedElementsAre(Elem(19, -190)));
161    node.mapped() = 23;
162    insert_result = set2.insert(std::move(node));
163    EXPECT_FALSE(node);
164    EXPECT_TRUE(insert_result.inserted);
165    EXPECT_FALSE(insert_result.node);
166    EXPECT_THAT(*insert_result.position, Elem(17, 23));
167    EXPECT_THAT(set2, UnorderedElementsAre(Elem(7, -70), Elem(17, 23)));
168  }
169  bool FirstIsEven(std::pair<const int, int> p) { return p.first % 2 == 0; }
170  TEST(NodeHashMap, EraseIf) {
171    {
172      node_hash_map<int, int> s = {{1, 1}, {2, 2}, {3, 3}, {4, 4}, {5, 5}};
173      EXPECT_EQ(erase_if(s, [](std::pair<const int, int>) { return true; }), 5);
174      EXPECT_THAT(s, IsEmpty());
175    }
176    {
177      node_hash_map<int, int> s = {{1, 1}, {2, 2}, {3, 3}, {4, 4}, {5, 5}};
178      EXPECT_EQ(erase_if(s, [](std::pair<const int, int>) { return false; }), 0);
179      EXPECT_THAT(s, UnorderedElementsAre(Pair(1, 1), Pair(2, 2), Pair(3, 3),
180                                          Pair(4, 4), Pair(5, 5)));
181    }
182    {
183      node_hash_map<int, int> s = {{1, 1}, {2, 2}, {3, 3}, {4, 4}, {5, 5}};
184      EXPECT_EQ(erase_if(s,
185                         [](std::pair<const int, int> kvp) {
186                           return kvp.first % 2 == 1;
187                         }),
188                3);
189      EXPECT_THAT(s, UnorderedElementsAre(Pair(2, 2), Pair(4, 4)));
190    }
191    {
192      node_hash_map<int, int> s = {{1, 1}, {2, 2}, {3, 3}, {4, 4}, {5, 5}};
193      EXPECT_EQ(erase_if(s, FirstIsEven), 2);
194      EXPECT_THAT(s, UnorderedElementsAre(Pair(1, 1), Pair(3, 3), Pair(5, 5)));
195    }
196    {
197      node_hash_map<int, int> s = {{1, 1}, {2, 2}, {3, 3}, {4, 4}, {5, 5}};
198      EXPECT_EQ(erase_if(s, &FirstIsEven), 2);
199      EXPECT_THAT(s, UnorderedElementsAre(Pair(1, 1), Pair(3, 3), Pair(5, 5)));
200    }
201  }
202  #if defined(__cpp_lib_launder) && __cpp_lib_launder >= 201606
203  TEST(NodeHashMap, NodeHandleMutableKeyAccess) {
204    node_hash_map<std::string, std::string> map;
205    map["key1"] = "mapped";
206    auto nh = map.extract(map.begin());
207    nh.key().resize(3);
208    map.insert(std::move(nh));
209    EXPECT_THAT(map, testing::ElementsAre(Pair("key", "mapped")));
210  }
211  #endif
212  TEST(NodeHashMap, RecursiveTypeCompiles) {
213    struct RecursiveType {
214      node_hash_map<int, RecursiveType> m;
215    };
216    RecursiveType t;
217    t.m[0] = RecursiveType{};
218  }
219  }  
220  }  
221  ABSL_NAMESPACE_END
222  }  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-raw_hash_set_test.cc</h3>
            <pre><code>1  #include "absl/container/internal/raw_hash_set.h"
2  #include <algorithm>
3  #include <atomic>
4  #include <cmath>
5  #include <cstdint>
6  #include <deque>
7  #include <functional>
8  #include <iostream>
9  #include <iterator>
10  #include <list>
11  #include <map>
12  #include <memory>
13  #include <numeric>
14  #include <ostream>
15  #include <random>
16  #include <string>
17  #include <type_traits>
18  #include <unordered_map>
19  #include <unordered_set>
20  #include <utility>
21  #include <vector>
22  #include "gmock/gmock.h"
23  #include "gtest/gtest.h"
24  #include "absl/base/attributes.h"
25  #include "absl/base/config.h"
26  #include "absl/base/internal/cycleclock.h"
27  #include "absl/base/prefetch.h"
28  #include "absl/container/flat_hash_map.h"
29  #include "absl/container/flat_hash_set.h"
30  #include "absl/container/internal/container_memory.h"
31  #include "absl/container/internal/hash_function_defaults.h"
32  #include "absl/container/internal/hash_policy_testing.h"
33  #include "absl/container/internal/hashtable_debug.h"
34  #include "absl/log/log.h"
35  #include "absl/strings/string_view.h"
36  namespace absl {
37  ABSL_NAMESPACE_BEGIN
38  namespace container_internal {
39  struct RawHashSetTestOnlyAccess {
40    template <typename C>
41    static auto GetSlots(const C& c) -> decltype(c.slot_array()) {
42      return c.slot_array();
43    }
44  };
45  namespace {
46  using ::testing::ElementsAre;
47  using ::testing::Eq;
48  using ::testing::Ge;
49  using ::testing::Lt;
50  using ::testing::Pair;
51  using ::testing::UnorderedElementsAre;
52  ctrl_t CtrlT(int i) { return static_cast<ctrl_t>(i); }
53  TEST(Util, NormalizeCapacity) {
54    EXPECT_EQ(1, NormalizeCapacity(0));
55    EXPECT_EQ(1, NormalizeCapacity(1));
56    EXPECT_EQ(3, NormalizeCapacity(2));
57    EXPECT_EQ(3, NormalizeCapacity(3));
58    EXPECT_EQ(7, NormalizeCapacity(4));
59    EXPECT_EQ(7, NormalizeCapacity(7));
60    EXPECT_EQ(15, NormalizeCapacity(8));
61    EXPECT_EQ(15, NormalizeCapacity(15));
62    EXPECT_EQ(15 * 2 + 1, NormalizeCapacity(15 + 1));
63    EXPECT_EQ(15 * 2 + 1, NormalizeCapacity(15 + 2));
64  }
65  TEST(Util, GrowthAndCapacity) {
66    for (size_t growth = 0; growth < 10000; ++growth) {
67      SCOPED_TRACE(growth);
68      size_t capacity = NormalizeCapacity(GrowthToLowerboundCapacity(growth));
69      EXPECT_THAT(CapacityToGrowth(capacity), Ge(growth));
70      if (capacity + 1 < Group::kWidth) {
71        EXPECT_THAT(CapacityToGrowth(capacity), Eq(capacity));
72      } else {
73        EXPECT_THAT(CapacityToGrowth(capacity), Lt(capacity));
74      }
75      if (growth != 0 && capacity > 1) {
76        EXPECT_THAT(CapacityToGrowth(capacity / 2), Lt(growth));
77      }
78    }
79    for (size_t capacity = Group::kWidth - 1; capacity < 10000;
80         capacity = 2 * capacity + 1) {
81      SCOPED_TRACE(capacity);
82      size_t growth = CapacityToGrowth(capacity);
83      EXPECT_THAT(growth, Lt(capacity));
84      EXPECT_LE(GrowthToLowerboundCapacity(growth), capacity);
85      EXPECT_EQ(NormalizeCapacity(GrowthToLowerboundCapacity(growth)), capacity);
86    }
87  }
88  TEST(Util, probe_seq) {
89    probe_seq<16> seq(0, 127);
90    auto gen = [&]() {
91      size_t res = seq.offset();
92      seq.next();
93      return res;
94    };
95    std::vector<size_t> offsets(8);
96    std::generate_n(offsets.begin(), 8, gen);
97    EXPECT_THAT(offsets, ElementsAre(0, 16, 48, 96, 32, 112, 80, 64));
98    seq = probe_seq<16>(128, 127);
99    std::generate_n(offsets.begin(), 8, gen);
100    EXPECT_THAT(offsets, ElementsAre(0, 16, 48, 96, 32, 112, 80, 64));
101  }
102  TEST(BitMask, Smoke) {
103    EXPECT_FALSE((BitMask<uint8_t, 8>(0)));
104    EXPECT_TRUE((BitMask<uint8_t, 8>(5)));
105    EXPECT_THAT((BitMask<uint8_t, 8>(0)), ElementsAre());
106    EXPECT_THAT((BitMask<uint8_t, 8>(0x1)), ElementsAre(0));
107    EXPECT_THAT((BitMask<uint8_t, 8>(0x2)), ElementsAre(1));
108    EXPECT_THAT((BitMask<uint8_t, 8>(0x3)), ElementsAre(0, 1));
109    EXPECT_THAT((BitMask<uint8_t, 8>(0x4)), ElementsAre(2));
110    EXPECT_THAT((BitMask<uint8_t, 8>(0x5)), ElementsAre(0, 2));
111    EXPECT_THAT((BitMask<uint8_t, 8>(0x55)), ElementsAre(0, 2, 4, 6));
112    EXPECT_THAT((BitMask<uint8_t, 8>(0xAA)), ElementsAre(1, 3, 5, 7));
113  }
114  TEST(BitMask, WithShift) {
115    uint64_t ctrl = 0x1716151413121110;
116    uint64_t hash = 0x12;
117    constexpr uint64_t msbs = 0x8080808080808080ULL;
118    constexpr uint64_t lsbs = 0x0101010101010101ULL;
119    auto x = ctrl ^ (lsbs * hash);
120    uint64_t mask = (x - lsbs) & ~x & msbs;
121    EXPECT_EQ(0x0000000080800000, mask);
122    BitMask<uint64_t, 8, 3> b(mask);
123    EXPECT_EQ(*b, 2);
124  }
125  TEST(BitMask, LeadingTrailing) {
126    EXPECT_EQ((BitMask<uint32_t, 16>(0x00001a40).LeadingZeros()), 3);
127    EXPECT_EQ((BitMask<uint32_t, 16>(0x00001a40).TrailingZeros()), 6);
128    EXPECT_EQ((BitMask<uint32_t, 16>(0x00000001).LeadingZeros()), 15);
129    EXPECT_EQ((BitMask<uint32_t, 16>(0x00000001).TrailingZeros()), 0);
130    EXPECT_EQ((BitMask<uint32_t, 16>(0x00008000).LeadingZeros()), 0);
131    EXPECT_EQ((BitMask<uint32_t, 16>(0x00008000).TrailingZeros()), 15);
132    EXPECT_EQ((BitMask<uint64_t, 8, 3>(0x0000008080808000).LeadingZeros()), 3);
133    EXPECT_EQ((BitMask<uint64_t, 8, 3>(0x0000008080808000).TrailingZeros()), 1);
134    EXPECT_EQ((BitMask<uint64_t, 8, 3>(0x0000000000000080).LeadingZeros()), 7);
135    EXPECT_EQ((BitMask<uint64_t, 8, 3>(0x0000000000000080).TrailingZeros()), 0);
136    EXPECT_EQ((BitMask<uint64_t, 8, 3>(0x8000000000000000).LeadingZeros()), 0);
137    EXPECT_EQ((BitMask<uint64_t, 8, 3>(0x8000000000000000).TrailingZeros()), 7);
138  }
139  TEST(Group, EmptyGroup) {
140    for (h2_t h = 0; h != 128; ++h) EXPECT_FALSE(Group{EmptyGroup()}.Match(h));
141  }
142  TEST(Group, Match) {
143    if (Group::kWidth == 16) {
144      ctrl_t group[] = {ctrl_t::kEmpty, CtrlT(1), ctrl_t::kDeleted,  CtrlT(3),
145                        ctrl_t::kEmpty, CtrlT(5), ctrl_t::kSentinel, CtrlT(7),
146                        CtrlT(7),       CtrlT(5), CtrlT(3),          CtrlT(1),
147                        CtrlT(1),       CtrlT(1), CtrlT(1),          CtrlT(1)};
148      EXPECT_THAT(Group{group}.Match(0), ElementsAre());
149      EXPECT_THAT(Group{group}.Match(1), ElementsAre(1, 11, 12, 13, 14, 15));
150      EXPECT_THAT(Group{group}.Match(3), ElementsAre(3, 10));
151      EXPECT_THAT(Group{group}.Match(5), ElementsAre(5, 9));
152      EXPECT_THAT(Group{group}.Match(7), ElementsAre(7, 8));
153    } else if (Group::kWidth == 8) {
154      ctrl_t group[] = {ctrl_t::kEmpty,    CtrlT(1), CtrlT(2),
155                        ctrl_t::kDeleted,  CtrlT(2), CtrlT(1),
156                        ctrl_t::kSentinel, CtrlT(1)};
157      EXPECT_THAT(Group{group}.Match(0), ElementsAre());
158      EXPECT_THAT(Group{group}.Match(1), ElementsAre(1, 5, 7));
159      EXPECT_THAT(Group{group}.Match(2), ElementsAre(2, 4));
160    } else {
161      FAIL() << "No test coverage for Group::kWidth==" << Group::kWidth;
162    }
163  }
164  TEST(Group, MaskEmpty) {
165    if (Group::kWidth == 16) {
166      ctrl_t group[] = {ctrl_t::kEmpty, CtrlT(1), ctrl_t::kDeleted,  CtrlT(3),
167                        ctrl_t::kEmpty, CtrlT(5), ctrl_t::kSentinel, CtrlT(7),
168                        CtrlT(7),       CtrlT(5), CtrlT(3),          CtrlT(1),
169                        CtrlT(1),       CtrlT(1), CtrlT(1),          CtrlT(1)};
170      EXPECT_THAT(Group{group}.MaskEmpty().LowestBitSet(), 0);
171      EXPECT_THAT(Group{group}.MaskEmpty().HighestBitSet(), 4);
172    } else if (Group::kWidth == 8) {
173      ctrl_t group[] = {ctrl_t::kEmpty,    CtrlT(1), CtrlT(2),
174                        ctrl_t::kDeleted,  CtrlT(2), CtrlT(1),
175                        ctrl_t::kSentinel, CtrlT(1)};
176      EXPECT_THAT(Group{group}.MaskEmpty().LowestBitSet(), 0);
177      EXPECT_THAT(Group{group}.MaskEmpty().HighestBitSet(), 0);
178    } else {
179      FAIL() << "No test coverage for Group::kWidth==" << Group::kWidth;
180    }
181  }
182  TEST(Group, MaskEmptyOrDeleted) {
183    if (Group::kWidth == 16) {
184      ctrl_t group[] = {ctrl_t::kEmpty,   CtrlT(1), ctrl_t::kEmpty,    CtrlT(3),
185                        ctrl_t::kDeleted, CtrlT(5), ctrl_t::kSentinel, CtrlT(7),
186                        CtrlT(7),         CtrlT(5), CtrlT(3),          CtrlT(1),
187                        CtrlT(1),         CtrlT(1), CtrlT(1),          CtrlT(1)};
188      EXPECT_THAT(Group{group}.MaskEmptyOrDeleted().LowestBitSet(), 0);
189      EXPECT_THAT(Group{group}.MaskEmptyOrDeleted().HighestBitSet(), 4);
190    } else if (Group::kWidth == 8) {
191      ctrl_t group[] = {ctrl_t::kEmpty,    CtrlT(1), CtrlT(2),
192                        ctrl_t::kDeleted,  CtrlT(2), CtrlT(1),
193                        ctrl_t::kSentinel, CtrlT(1)};
194      EXPECT_THAT(Group{group}.MaskEmptyOrDeleted().LowestBitSet(), 0);
195      EXPECT_THAT(Group{group}.MaskEmptyOrDeleted().HighestBitSet(), 3);
196    } else {
197      FAIL() << "No test coverage for Group::kWidth==" << Group::kWidth;
198    }
199  }
200  TEST(Batch, DropDeletes) {
201    constexpr size_t kCapacity = 63;
202    constexpr size_t kGroupWidth = container_internal::Group::kWidth;
203    std::vector<ctrl_t> ctrl(kCapacity + 1 + kGroupWidth);
204    ctrl[kCapacity] = ctrl_t::kSentinel;
205    std::vector<ctrl_t> pattern = {
206        ctrl_t::kEmpty, CtrlT(2), ctrl_t::kDeleted, CtrlT(2),
207        ctrl_t::kEmpty, CtrlT(1), ctrl_t::kDeleted};
208    for (size_t i = 0; i != kCapacity; ++i) {
209      ctrl[i] = pattern[i % pattern.size()];
210      if (i < kGroupWidth - 1)
211        ctrl[i + kCapacity + 1] = pattern[i % pattern.size()];
212    }
213    ConvertDeletedToEmptyAndFullToDeleted(ctrl.data(), kCapacity);
214    ASSERT_EQ(ctrl[kCapacity], ctrl_t::kSentinel);
215    for (size_t i = 0; i < kCapacity + kGroupWidth; ++i) {
216      ctrl_t expected = pattern[i % (kCapacity + 1) % pattern.size()];
217      if (i == kCapacity) expected = ctrl_t::kSentinel;
218      if (expected == ctrl_t::kDeleted) expected = ctrl_t::kEmpty;
219      if (IsFull(expected)) expected = ctrl_t::kDeleted;
220      EXPECT_EQ(ctrl[i], expected)
221          << i << " " << static_cast<int>(pattern[i % pattern.size()]);
222    }
223  }
224  TEST(Group, CountLeadingEmptyOrDeleted) {
225    const std::vector<ctrl_t> empty_examples = {ctrl_t::kEmpty, ctrl_t::kDeleted};
226    const std::vector<ctrl_t> full_examples = {
227        CtrlT(0), CtrlT(1), CtrlT(2),   CtrlT(3),
228        CtrlT(5), CtrlT(9), CtrlT(127), ctrl_t::kSentinel};
229    for (ctrl_t empty : empty_examples) {
230      std::vector<ctrl_t> e(Group::kWidth, empty);
231      EXPECT_EQ(Group::kWidth, Group{e.data()}.CountLeadingEmptyOrDeleted());
232      for (ctrl_t full : full_examples) {
233        for (size_t i = 0; i != Group::kWidth; ++i) {
234          std::vector<ctrl_t> f(Group::kWidth, empty);
235          f[i] = full;
236          EXPECT_EQ(i, Group{f.data()}.CountLeadingEmptyOrDeleted());
237        }
238        std::vector<ctrl_t> f(Group::kWidth, empty);
239        f[Group::kWidth * 2 / 3] = full;
240        f[Group::kWidth / 2] = full;
241        EXPECT_EQ(
242            Group::kWidth / 2, Group{f.data()}.CountLeadingEmptyOrDeleted());
243      }
244    }
245  }
246  template <class T>
247  struct ValuePolicy {
248    using slot_type = T;
249    using key_type = T;
250    using init_type = T;
251    template <class Allocator, class... Args>
252    static void construct(Allocator* alloc, slot_type* slot, Args&&... args) {
253      absl::allocator_traits<Allocator>::construct(*alloc, slot,
254                                                   std::forward<Args>(args)...);
255    }
256    template <class Allocator>
257    static void destroy(Allocator* alloc, slot_type* slot) {
258      absl::allocator_traits<Allocator>::destroy(*alloc, slot);
259    }
260    template <class Allocator>
261    static void transfer(Allocator* alloc, slot_type* new_slot,
262                         slot_type* old_slot) {
263      construct(alloc, new_slot, std::move(*old_slot));
264      destroy(alloc, old_slot);
265    }
266    static T& element(slot_type* slot) { return *slot; }
267    template <class F, class... Args>
268    static decltype(absl::container_internal::DecomposeValue(
269        std::declval<F>(), std::declval<Args>()...))
270    apply(F&& f, Args&&... args) {
271      return absl::container_internal::DecomposeValue(
272          std::forward<F>(f), std::forward<Args>(args)...);
273    }
274  };
275  using IntPolicy = ValuePolicy<int64_t>;
276  using Uint8Policy = ValuePolicy<uint8_t>;
277  class StringPolicy {
278    template <class F, class K, class V,
279              class = typename std::enable_if<
280                  std::is_convertible<const K&, absl::string_view>::value>::type>
281    decltype(std::declval<F>()(
282        std::declval<const absl::string_view&>(), std::piecewise_construct,
283        std::declval<std::tuple<K>>(),
284        std::declval<V>())) static apply_impl(F&& f,
285                                              std::pair<std::tuple<K>, V> p) {
286      const absl::string_view& key = std::get<0>(p.first);
287      return std::forward<F>(f)(key, std::piecewise_construct, std::move(p.first),
288                                std::move(p.second));
289    }
290   public:
291    struct slot_type {
292      struct ctor {};
293      template <class... Ts>
294      explicit slot_type(ctor, Ts&&... ts) : pair(std::forward<Ts>(ts)...) {}
295      std::pair<std::string, std::string> pair;
296    };
297    using key_type = std::string;
298    using init_type = std::pair<std::string, std::string>;
299    template <class allocator_type, class... Args>
300    static void construct(allocator_type* alloc, slot_type* slot, Args... args) {
301      std::allocator_traits<allocator_type>::construct(
302          *alloc, slot, typename slot_type::ctor(), std::forward<Args>(args)...);
303    }
304    template <class allocator_type>
305    static void destroy(allocator_type* alloc, slot_type* slot) {
306      std::allocator_traits<allocator_type>::destroy(*alloc, slot);
307    }
308    template <class allocator_type>
309    static void transfer(allocator_type* alloc, slot_type* new_slot,
310                         slot_type* old_slot) {
311      construct(alloc, new_slot, std::move(old_slot->pair));
312      destroy(alloc, old_slot);
313    }
314    static std::pair<std::string, std::string>& element(slot_type* slot) {
315      return slot->pair;
316    }
317    template <class F, class... Args>
318    static auto apply(F&& f, Args&&... args)
319        -> decltype(apply_impl(std::forward<F>(f),
320                               PairArgs(std::forward<Args>(args)...))) {
321      return apply_impl(std::forward<F>(f),
322                        PairArgs(std::forward<Args>(args)...));
323    }
324  };
325  struct StringHash : absl::Hash<absl::string_view> {
326    using is_transparent = void;
327  };
328  struct StringEq : std::equal_to<absl::string_view> {
329    using is_transparent = void;
330  };
331  struct StringTable
332      : raw_hash_set<StringPolicy, StringHash, StringEq, std::allocator<int>> {
333    using Base = typename StringTable::raw_hash_set;
334    StringTable() = default;
335    using Base::Base;
336  };
337  struct IntTable
338      : raw_hash_set<IntPolicy, container_internal::hash_default_hash<int64_t>,
339                     std::equal_to<int64_t>, std::allocator<int64_t>> {
340    using Base = typename IntTable::raw_hash_set;
341    using Base::Base;
342  };
343  struct Uint8Table
344      : raw_hash_set<Uint8Policy, container_internal::hash_default_hash<uint8_t>,
345                     std::equal_to<uint8_t>, std::allocator<uint8_t>> {
346    using Base = typename Uint8Table::raw_hash_set;
347    using Base::Base;
348  };
349  template <typename T>
350  struct CustomAlloc : std::allocator<T> {
351    CustomAlloc() = default;
352    template <typename U>
353    explicit CustomAlloc(const CustomAlloc<U>& &bsol;*other*/) {}
354    template<class U> struct rebind {
355      using other = CustomAlloc<U>;
356    };
357  };
358  struct CustomAllocIntTable
359      : raw_hash_set<IntPolicy, container_internal::hash_default_hash<int64_t>,
360                     std::equal_to<int64_t>, CustomAlloc<int64_t>> {
361    using Base = typename CustomAllocIntTable::raw_hash_set;
362    using Base::Base;
363  };
364  struct BadFastHash {
365    template <class T>
366    size_t operator()(const T&) const {
367      return 0;
368    }
369  };
370  struct BadTable : raw_hash_set<IntPolicy, BadFastHash, std::equal_to<int>,
371                                 std::allocator<int>> {
372    using Base = typename BadTable::raw_hash_set;
373    BadTable() = default;
374    using Base::Base;
375  };
376  TEST(Table, EmptyFunctorOptimization) {
377    static_assert(std::is_empty<std::equal_to<absl::string_view>>::value, "");
378    static_assert(std::is_empty<std::allocator<int>>::value, "");
379    struct MockTable {
380      void* infoz;
381      void* ctrl;
382      void* slots;
383      size_t size;
384      size_t capacity;
385      size_t growth_left;
386    };
387    struct MockTableInfozDisabled {
388      void* ctrl;
389      void* slots;
390      size_t size;
391      size_t capacity;
392      size_t growth_left;
393    };
394    struct StatelessHash {
395      size_t operator()(absl::string_view) const { return 0; }
396    };
397    struct StatefulHash : StatelessHash {
398      size_t dummy;
399    };
400    struct GenerationData {
401      size_t reserved_growth;
402      GenerationType* generation;
403    };
404  #if defined(__clang__)
405  #pragma clang diagnostic push
406  #pragma clang diagnostic ignored "-Wunreachable-code"
407  #endif
408    constexpr size_t mock_size = std::is_empty<HashtablezInfoHandle>()
409                                     ? sizeof(MockTableInfozDisabled)
410                                     : sizeof(MockTable);
411    constexpr size_t generation_size =
412        SwisstableGenerationsEnabled() ? sizeof(GenerationData) : 0;
413  #if defined(__clang__)
414  #pragma clang diagnostic pop
415  #endif
416    EXPECT_EQ(
417        mock_size + generation_size,
418        sizeof(
419            raw_hash_set<StringPolicy, StatelessHash,
420                         std::equal_to<absl::string_view>, std::allocator<int>>));
421    EXPECT_EQ(
422        mock_size + sizeof(StatefulHash) + generation_size,
423        sizeof(
424            raw_hash_set<StringPolicy, StatefulHash,
425                         std::equal_to<absl::string_view>, std::allocator<int>>));
426  }
427  TEST(Table, Empty) {
428    IntTable t;
429    EXPECT_EQ(0, t.size());
430    EXPECT_TRUE(t.empty());
431  }
432  TEST(Table, LookupEmpty) {
433    IntTable t;
434    auto it = t.find(0);
435    EXPECT_TRUE(it == t.end());
436  }
437  TEST(Table, Insert1) {
438    IntTable t;
439    EXPECT_TRUE(t.find(0) == t.end());
440    auto res = t.emplace(0);
441    EXPECT_TRUE(res.second);
442    EXPECT_THAT(*res.first, 0);
443    EXPECT_EQ(1, t.size());
444    EXPECT_THAT(*t.find(0), 0);
445  }
446  TEST(Table, Insert2) {
447    IntTable t;
448    EXPECT_TRUE(t.find(0) == t.end());
449    auto res = t.emplace(0);
450    EXPECT_TRUE(res.second);
451    EXPECT_THAT(*res.first, 0);
452    EXPECT_EQ(1, t.size());
453    EXPECT_TRUE(t.find(1) == t.end());
454    res = t.emplace(1);
455    EXPECT_TRUE(res.second);
456    EXPECT_THAT(*res.first, 1);
457    EXPECT_EQ(2, t.size());
458    EXPECT_THAT(*t.find(0), 0);
459    EXPECT_THAT(*t.find(1), 1);
460  }
461  TEST(Table, InsertCollision) {
462    BadTable t;
463    EXPECT_TRUE(t.find(1) == t.end());
464    auto res = t.emplace(1);
465    EXPECT_TRUE(res.second);
466    EXPECT_THAT(*res.first, 1);
467    EXPECT_EQ(1, t.size());
468    EXPECT_TRUE(t.find(2) == t.end());
469    res = t.emplace(2);
470    EXPECT_THAT(*res.first, 2);
471    EXPECT_TRUE(res.second);
472    EXPECT_EQ(2, t.size());
473    EXPECT_THAT(*t.find(1), 1);
474    EXPECT_THAT(*t.find(2), 2);
475  }
476  TEST(Table, InsertCollisionAndFindAfterDelete) {
477    BadTable t;  
478    constexpr size_t kNumInserts = Group::kWidth * 2 + 5;
479    for (size_t i = 0; i < kNumInserts; ++i) {
480      auto res = t.emplace(i);
481      EXPECT_TRUE(res.second);
482      EXPECT_THAT(*res.first, i);
483      EXPECT_EQ(i + 1, t.size());
484    }
485    for (size_t i = 0; i < kNumInserts; ++i) {
486      EXPECT_EQ(1, t.erase(i)) << i;
487      for (size_t j = i + 1; j < kNumInserts; ++j) {
488        EXPECT_THAT(*t.find(j), j);
489        auto res = t.emplace(j);
490        EXPECT_FALSE(res.second) << i << " " << j;
491        EXPECT_THAT(*res.first, j);
492        EXPECT_EQ(kNumInserts - i - 1, t.size());
493      }
494    }
495    EXPECT_TRUE(t.empty());
496  }
497  TEST(Table, InsertWithinCapacity) {
498    IntTable t;
499    t.reserve(10);
500    const size_t original_capacity = t.capacity();
501    const auto addr = [&](int i) {
502      return reinterpret_cast<uintptr_t>(&*t.find(i));
503    };
504    t.insert(0);
505    EXPECT_THAT(t.capacity(), original_capacity);
506    const uintptr_t original_addr_0 = addr(0);
507    t.insert(1);
508    EXPECT_THAT(t.capacity(), original_capacity);
509    EXPECT_THAT(addr(0), original_addr_0);
510    for (int i = 0; i < 100; ++i) {
511      t.insert(i % 10);
512    }
513    EXPECT_THAT(t.capacity(), original_capacity);
514    EXPECT_THAT(addr(0), original_addr_0);
515    std::vector<int> dup_range;
516    for (int i = 0; i < 100; ++i) {
517      dup_range.push_back(i % 10);
518    }
519    t.insert(dup_range.begin(), dup_range.end());
520    EXPECT_THAT(t.capacity(), original_capacity);
521    EXPECT_THAT(addr(0), original_addr_0);
522  }
523  TEST(Table, LazyEmplace) {
524    StringTable t;
525    bool called = false;
526    auto it = t.lazy_emplace("abc", [&](const StringTable::constructor& f) {
527      called = true;
528      f("abc", "ABC");
529    });
530    EXPECT_TRUE(called);
531    EXPECT_THAT(*it, Pair("abc", "ABC"));
532    called = false;
533    it = t.lazy_emplace("abc", [&](const StringTable::constructor& f) {
534      called = true;
535      f("abc", "DEF");
536    });
537    EXPECT_FALSE(called);
538    EXPECT_THAT(*it, Pair("abc", "ABC"));
539  }
540  TEST(Table, ContainsEmpty) {
541    IntTable t;
542    EXPECT_FALSE(t.contains(0));
543  }
544  TEST(Table, Contains1) {
545    IntTable t;
546    EXPECT_TRUE(t.insert(0).second);
547    EXPECT_TRUE(t.contains(0));
548    EXPECT_FALSE(t.contains(1));
549    EXPECT_EQ(1, t.erase(0));
550    EXPECT_FALSE(t.contains(0));
551  }
552  TEST(Table, Contains2) {
553    IntTable t;
554    EXPECT_TRUE(t.insert(0).second);
555    EXPECT_TRUE(t.contains(0));
556    EXPECT_FALSE(t.contains(1));
557    t.clear();
558    EXPECT_FALSE(t.contains(0));
559  }
560  int decompose_constructed;
561  int decompose_copy_constructed;
562  int decompose_copy_assigned;
563  int decompose_move_constructed;
564  int decompose_move_assigned;
565  struct DecomposeType {
566    DecomposeType(int i = 0) : i(i) {  
567      ++decompose_constructed;
568    }
569    explicit DecomposeType(const char* d) : DecomposeType(*d) {}
570    DecomposeType(const DecomposeType& other) : i(other.i) {
571      ++decompose_copy_constructed;
572    }
573    DecomposeType& operator=(const DecomposeType& other) {
574      ++decompose_copy_assigned;
575      i = other.i;
576      return *this;
577    }
578    DecomposeType(DecomposeType&& other) : i(other.i) {
579      ++decompose_move_constructed;
580    }
581    DecomposeType& operator=(DecomposeType&& other) {
582      ++decompose_move_assigned;
583      i = other.i;
584      return *this;
585    }
586    int i;
587  };
588  struct DecomposeHash {
589    using is_transparent = void;
590    size_t operator()(const DecomposeType& a) const { return a.i; }
591    size_t operator()(int a) const { return a; }
592    size_t operator()(const char* a) const { return *a; }
593  };
594  struct DecomposeEq {
595    using is_transparent = void;
596    bool operator()(const DecomposeType& a, const DecomposeType& b) const {
597      return a.i == b.i;
598    }
599    bool operator()(const DecomposeType& a, int b) const { return a.i == b; }
600    bool operator()(const DecomposeType& a, const char* b) const {
601      return a.i == *b;
602    }
603  };
604  struct DecomposePolicy {
605    using slot_type = DecomposeType;
606    using key_type = DecomposeType;
607    using init_type = DecomposeType;
608    template <typename T>
609    static void construct(void*, DecomposeType* slot, T&& v) {
610      ::new (slot) DecomposeType(std::forward<T>(v));
611    }
612    static void destroy(void*, DecomposeType* slot) { slot->~DecomposeType(); }
613    static DecomposeType& element(slot_type* slot) { return *slot; }
614    template <class F, class T>
615    static auto apply(F&& f, const T& x) -> decltype(std::forward<F>(f)(x, x)) {
616      return std::forward<F>(f)(x, x);
617    }
618  };
619  template <typename Hash, typename Eq>
620  void TestDecompose(bool construct_three) {
621    DecomposeType elem{0};
622    const int one = 1;
623    const char* three_p = "3";
624    const auto& three = three_p;
625    const int elem_vector_count = 256;
626    std::vector<DecomposeType> elem_vector(elem_vector_count, DecomposeType{0});
627    std::iota(elem_vector.begin(), elem_vector.end(), 0);
628    using DecomposeSet =
629        raw_hash_set<DecomposePolicy, Hash, Eq, std::allocator<int>>;
630    DecomposeSet set1;
631    decompose_constructed = 0;
632    int expected_constructed = 0;
633    EXPECT_EQ(expected_constructed, decompose_constructed);
634    set1.insert(elem);
635    EXPECT_EQ(expected_constructed, decompose_constructed);
636    set1.insert(1);
637    EXPECT_EQ(++expected_constructed, decompose_constructed);
638    set1.emplace("3");
639    EXPECT_EQ(++expected_constructed, decompose_constructed);
640    EXPECT_EQ(expected_constructed, decompose_constructed);
641    {  
642      set1.insert(1);
643      EXPECT_EQ(expected_constructed, decompose_constructed);
644    }
645    {  
646      set1.insert(one);
647      EXPECT_EQ(expected_constructed, decompose_constructed);
648    }
649    {  
650      set1.insert(set1.begin(), 1);
651      EXPECT_EQ(expected_constructed, decompose_constructed);
652    }
653    {  
654      set1.insert(set1.begin(), one);
655      EXPECT_EQ(expected_constructed, decompose_constructed);
656    }
657    {  
658      set1.emplace(1);
659      EXPECT_EQ(expected_constructed, decompose_constructed);
660      set1.emplace("3");
661      expected_constructed += construct_three;
662      EXPECT_EQ(expected_constructed, decompose_constructed);
663      set1.emplace(one);
664      EXPECT_EQ(expected_constructed, decompose_constructed);
665      set1.emplace(three);
666      expected_constructed += construct_three;
667      EXPECT_EQ(expected_constructed, decompose_constructed);
668    }
669    {  
670      set1.emplace_hint(set1.begin(), 1);
671      EXPECT_EQ(expected_constructed, decompose_constructed);
672      set1.emplace_hint(set1.begin(), "3");
673      expected_constructed += construct_three;
674      EXPECT_EQ(expected_constructed, decompose_constructed);
675      set1.emplace_hint(set1.begin(), one);
676      EXPECT_EQ(expected_constructed, decompose_constructed);
677      set1.emplace_hint(set1.begin(), three);
678      expected_constructed += construct_three;
679      EXPECT_EQ(expected_constructed, decompose_constructed);
680    }
681    decompose_copy_constructed = 0;
682    decompose_copy_assigned = 0;
683    decompose_move_constructed = 0;
684    decompose_move_assigned = 0;
685    int expected_copy_constructed = 0;
686    int expected_move_constructed = 0;
687    {  
688      DecomposeSet set2(elem_vector.begin(), elem_vector.end());
689      expected_copy_constructed += elem_vector_count;
690      EXPECT_EQ(expected_copy_constructed, decompose_copy_constructed);
691      EXPECT_EQ(expected_move_constructed, decompose_move_constructed);
692      EXPECT_EQ(0, decompose_move_assigned);
693      EXPECT_EQ(0, decompose_copy_assigned);
694    }
695    {  
696      std::list<DecomposeType> elem_list(elem_vector.begin(), elem_vector.end());
697      expected_copy_constructed = decompose_copy_constructed;
698      DecomposeSet set2(elem_list.begin(), elem_list.end());
699      expected_copy_constructed += elem_vector_count;
700      EXPECT_EQ(expected_copy_constructed, decompose_copy_constructed);
701      expected_move_constructed += elem_vector_count;
702      EXPECT_LT(expected_move_constructed, decompose_move_constructed);
703      expected_move_constructed += elem_vector_count;
704      EXPECT_GE(expected_move_constructed, decompose_move_constructed);
705      EXPECT_EQ(0, decompose_move_assigned);
706      EXPECT_EQ(0, decompose_copy_assigned);
707      expected_copy_constructed = decompose_copy_constructed;
708      expected_move_constructed = decompose_move_constructed;
709    }
710    {  
711      DecomposeSet set2;
712      set2.insert(elem_vector.begin(), elem_vector.end());
713      const int expected_new_elements = elem_vector_count;
714      const int expected_max_element_moves = 2 * elem_vector_count;
715      expected_copy_constructed += expected_new_elements;
716      EXPECT_EQ(expected_copy_constructed, decompose_copy_constructed);
717      expected_move_constructed += expected_max_element_moves;
718      EXPECT_GE(expected_move_constructed, decompose_move_constructed);
719      EXPECT_EQ(0, decompose_move_assigned);
720      EXPECT_EQ(0, decompose_copy_assigned);
721      expected_copy_constructed = decompose_copy_constructed;
722      expected_move_constructed = decompose_move_constructed;
723    }
724  }
725  TEST(Table, Decompose) {
726    if (SwisstableGenerationsEnabled()) {
727      GTEST_SKIP() << "Generations being enabled causes extra rehashes.";
728    }
729    TestDecompose<DecomposeHash, DecomposeEq>(false);
730    struct TransparentHashIntOverload {
731      size_t operator()(const DecomposeType& a) const { return a.i; }
732      size_t operator()(int a) const { return a; }
733    };
734    struct TransparentEqIntOverload {
735      bool operator()(const DecomposeType& a, const DecomposeType& b) const {
736        return a.i == b.i;
737      }
738      bool operator()(const DecomposeType& a, int b) const { return a.i == b; }
739    };
740    TestDecompose<TransparentHashIntOverload, DecomposeEq>(true);
741    TestDecompose<TransparentHashIntOverload, TransparentEqIntOverload>(true);
742    TestDecompose<DecomposeHash, TransparentEqIntOverload>(true);
743  }
744  size_t MaxDensitySize(size_t n) {
745    IntTable t;
746    t.reserve(n);
747    for (size_t i = 0; i != n; ++i) t.emplace(i);
748    const size_t c = t.bucket_count();
749    while (c == t.bucket_count()) t.emplace(n++);
750    return t.size() - 1;
751  }
752  struct Modulo1000Hash {
753    size_t operator()(int x) const { return x % 1000; }
754  };
755  struct Modulo1000HashTable
756      : public raw_hash_set<IntPolicy, Modulo1000Hash, std::equal_to<int>,
757                            std::allocator<int>> {};
758  TEST(Table, RehashWithNoResize) {
759    if (SwisstableGenerationsEnabled()) {
760      GTEST_SKIP() << "Generations being enabled causes extra rehashes.";
761    }
762    Modulo1000HashTable t;
763    const size_t kMinFullGroups = 7;
764    std::vector<int> keys;
765    for (size_t i = 0; i < MaxDensitySize(Group::kWidth * kMinFullGroups); ++i) {
766      int k = i * 1000;
767      t.emplace(k);
768      keys.push_back(k);
769    }
770    const size_t capacity = t.capacity();
771    const size_t erase_begin = Group::kWidth / 2;
772    const size_t erase_end = (t.size() / Group::kWidth - 1) * Group::kWidth;
773    for (size_t i = erase_begin; i < erase_end; ++i) {
774      EXPECT_EQ(1, t.erase(keys[i])) << i;
775    }
776    keys.erase(keys.begin() + erase_begin, keys.begin() + erase_end);
777    auto last_key = keys.back();
778    size_t last_key_num_probes = GetHashtableDebugNumProbes(t, last_key);
779    ASSERT_GT(last_key_num_probes, kMinFullGroups);
780    int x = 1;
781    while (last_key_num_probes == GetHashtableDebugNumProbes(t, last_key)) {
782      t.emplace(x);
783      ASSERT_EQ(capacity, t.capacity());
784      ASSERT_TRUE(t.find(x) != t.end()) << x;
785      for (const auto& k : keys) {
786        ASSERT_TRUE(t.find(k) != t.end()) << k;
787      }
788      t.erase(x);
789      ++x;
790    }
791  }
792  TEST(Table, InsertEraseStressTest) {
793    IntTable t;
794    const size_t kMinElementCount = 250;
795    std::deque<int> keys;
796    size_t i = 0;
797    for (; i < MaxDensitySize(kMinElementCount); ++i) {
798      t.emplace(i);
799      keys.push_back(i);
800    }
801    const size_t kNumIterations = 1000000;
802    for (; i < kNumIterations; ++i) {
803      ASSERT_EQ(1, t.erase(keys.front()));
804      keys.pop_front();
805      t.emplace(i);
806      keys.push_back(i);
807    }
808  }
809  TEST(Table, InsertOverloads) {
810    StringTable t;
811    t.insert({{}, {}});
812    t.insert({"ABC", {}});
813    t.insert({"DEF", "!!!"});
814    EXPECT_THAT(t, UnorderedElementsAre(Pair("", ""), Pair("ABC", ""),
815                                        Pair("DEF", "!!!")));
816  }
817  TEST(Table, LargeTable) {
818    IntTable t;
819    for (int64_t i = 0; i != 100000; ++i) t.emplace(i << 40);
820    for (int64_t i = 0; i != 100000; ++i) ASSERT_EQ(i << 40, *t.find(i << 40));
821  }
822  TEST(Table, EnsureNonQuadraticAsInRust) {
823    static const size_t kLargeSize = 1 << 15;
824    IntTable t;
825    for (size_t i = 0; i != kLargeSize; ++i) {
826      t.insert(i);
827    }
828    IntTable t2;
829    for (const auto& entry : t) t2.insert(entry);
830  }
831  TEST(Table, ClearBug) {
832    if (SwisstableGenerationsEnabled()) {
833      GTEST_SKIP() << "Generations being enabled causes extra rehashes.";
834    }
835    IntTable t;
836    constexpr size_t capacity = container_internal::Group::kWidth - 1;
837    constexpr size_t max_size = capacity / 2 + 1;
838    for (size_t i = 0; i < max_size; ++i) {
839      t.insert(i);
840    }
841    ASSERT_EQ(capacity, t.capacity());
842    intptr_t original = reinterpret_cast<intptr_t>(&*t.find(2));
843    t.clear();
844    ASSERT_EQ(capacity, t.capacity());
845    for (size_t i = 0; i < max_size; ++i) {
846      t.insert(i);
847    }
848    ASSERT_EQ(capacity, t.capacity());
849    intptr_t second = reinterpret_cast<intptr_t>(&*t.find(2));
850    EXPECT_LT(static_cast<size_t>(std::abs(original - second)),
851              capacity * sizeof(IntTable::value_type));
852  }
853  TEST(Table, Erase) {
854    IntTable t;
855    EXPECT_TRUE(t.find(0) == t.end());
856    auto res = t.emplace(0);
857    EXPECT_TRUE(res.second);
858    EXPECT_EQ(1, t.size());
859    t.erase(res.first);
860    EXPECT_EQ(0, t.size());
861    EXPECT_TRUE(t.find(0) == t.end());
862  }
863  TEST(Table, EraseMaintainsValidIterator) {
864    IntTable t;
865    const int kNumElements = 100;
866    for (int i = 0; i < kNumElements; i ++) {
867      EXPECT_TRUE(t.emplace(i).second);
868    }
869    EXPECT_EQ(t.size(), kNumElements);
870    int num_erase_calls = 0;
871    auto it = t.begin();
872    while (it != t.end()) {
873      t.erase(it++);
874      num_erase_calls++;
875    }
876    EXPECT_TRUE(t.empty());
877    EXPECT_EQ(num_erase_calls, kNumElements);
878  }
879  std::vector<int64_t> CollectBadMergeKeys(size_t N) {
880    static constexpr int kGroupSize = Group::kWidth - 1;
881    auto topk_range = [](size_t b, size_t e,
882                         IntTable* t) -> std::vector<int64_t> {
883      for (size_t i = b; i != e; ++i) {
884        t->emplace(i);
885      }
886      std::vector<int64_t> res;
887      res.reserve(kGroupSize);
888      auto it = t->begin();
889      for (size_t i = b; i != e && i != b + kGroupSize; ++i, ++it) {
890        res.push_back(*it);
891      }
892      return res;
893    };
894    std::vector<int64_t> bad_keys;
895    bad_keys.reserve(N);
896    IntTable t;
897    t.reserve(N * 2);
898    for (size_t b = 0; bad_keys.size() < N; b += N) {
899      auto keys = topk_range(b, b + N, &t);
900      bad_keys.insert(bad_keys.end(), keys.begin(), keys.end());
901      t.erase(t.begin(), t.end());
902      EXPECT_TRUE(t.empty());
903    }
904    return bad_keys;
905  }
906  struct ProbeStats {
907    std::vector<size_t> all_probes_histogram;
908    std::vector<double> single_table_ratios;
909    double AvgRatio() const {
910      return std::accumulate(single_table_ratios.begin(),
911                             single_table_ratios.end(), 0.0) /
912             single_table_ratios.size();
913    }
914    double MaxRatio() const {
915      return *std::max_element(single_table_ratios.begin(),
916                               single_table_ratios.end());
917    }
918    double PercentileRatio(double Percentile = 0.95) const {
919      auto r = single_table_ratios;
920      auto mid = r.begin() + static_cast<size_t>(r.size() * Percentile);
921      if (mid != r.end()) {
922        std::nth_element(r.begin(), mid, r.end());
923        return *mid;
924      } else {
925        return MaxRatio();
926      }
927    }
928    size_t MaxProbe() const { return all_probes_histogram.size(); }
929    std::vector<double> ProbeNormalizedHistogram() const {
930      double total_elements = std::accumulate(all_probes_histogram.begin(),
931                                              all_probes_histogram.end(), 0ull);
932      std::vector<double> res;
933      for (size_t p : all_probes_histogram) {
934        res.push_back(p / total_elements);
935      }
936      return res;
937    }
938    size_t PercentileProbe(double Percentile = 0.99) const {
939      size_t idx = 0;
940      for (double p : ProbeNormalizedHistogram()) {
941        if (Percentile > p) {
942          Percentile -= p;
943          ++idx;
944        } else {
945          return idx;
946        }
947      }
948      return idx;
949    }
950    friend std::ostream& operator<<(std::ostream& out, const ProbeStats& s) {
951      out << "{AvgRatio:" << s.AvgRatio() << ", MaxRatio:" << s.MaxRatio()
952          << ", PercentileRatio:" << s.PercentileRatio()
953          << ", MaxProbe:" << s.MaxProbe() << ", Probes=[";
954      for (double p : s.ProbeNormalizedHistogram()) {
955        out << p << ",";
956      }
957      out << "]}";
958      return out;
959    }
960  };
961  struct ExpectedStats {
962    double avg_ratio;
963    double max_ratio;
964    std::vector<std::pair<double, double>> pecentile_ratios;
965    std::vector<std::pair<double, double>> pecentile_probes;
966    friend std::ostream& operator<<(std::ostream& out, const ExpectedStats& s) {
967      out << "{AvgRatio:" << s.avg_ratio << ", MaxRatio:" << s.max_ratio
968          << ", PercentileRatios: [";
969      for (auto el : s.pecentile_ratios) {
970        out << el.first << ":" << el.second << ", ";
971      }
972      out << "], PercentileProbes: [";
973      for (auto el : s.pecentile_probes) {
974        out << el.first << ":" << el.second << ", ";
975      }
976      out << "]}";
977      return out;
978    }
979  };
980  void VerifyStats(size_t size, const ExpectedStats& exp,
981                   const ProbeStats& stats) {
982    EXPECT_LT(stats.AvgRatio(), exp.avg_ratio) << size << " " << stats;
983    EXPECT_LT(stats.MaxRatio(), exp.max_ratio) << size << " " << stats;
984    for (auto pr : exp.pecentile_ratios) {
985      EXPECT_LE(stats.PercentileRatio(pr.first), pr.second)
986          << size << " " << pr.first << " " << stats;
987    }
988    for (auto pr : exp.pecentile_probes) {
989      EXPECT_LE(stats.PercentileProbe(pr.first), pr.second)
990          << size << " " << pr.first << " " << stats;
991    }
992  }
993  using ProbeStatsPerSize = std::map<size_t, ProbeStats>;
994  ProbeStats CollectProbeStatsOnKeysXoredWithSeed(
995      const std::vector<int64_t>& keys, size_t num_iters) {
996    const size_t reserve_size = keys.size() * 2;
997    ProbeStats stats;
998    int64_t seed = 0x71b1a19b907d6e33;
999    while (num_iters--) {
1000      seed = static_cast<int64_t>(static_cast<uint64_t>(seed) * 17 + 13);
1001      IntTable t1;
1002      t1.reserve(reserve_size);
1003      for (const auto& key : keys) {
1004        t1.emplace(key ^ seed);
1005      }
1006      auto probe_histogram = GetHashtableDebugNumProbesHistogram(t1);
1007      stats.all_probes_histogram.resize(
1008          std::max(stats.all_probes_histogram.size(), probe_histogram.size()));
1009      std::transform(probe_histogram.begin(), probe_histogram.end(),
1010                     stats.all_probes_histogram.begin(),
1011                     stats.all_probes_histogram.begin(), std::plus<size_t>());
1012      size_t total_probe_seq_length = 0;
1013      for (size_t i = 0; i < probe_histogram.size(); ++i) {
1014        total_probe_seq_length += i * probe_histogram[i];
1015      }
1016      stats.single_table_ratios.push_back(total_probe_seq_length * 1.0 /
1017                                          keys.size());
1018      t1.erase(t1.begin(), t1.end());
1019    }
1020    return stats;
1021  }
1022  ExpectedStats XorSeedExpectedStats() {
1023    constexpr bool kRandomizesInserts =
1024  #ifdef NDEBUG
1025        false;
1026  #else   
1027        true;
1028  #endif  
1029    switch (container_internal::Group::kWidth) {
1030      case 8:
1031        if (kRandomizesInserts) {
1032    return {0.05,
1033            1.0,
1034            {{0.95, 0.5}},
1035            {{0.95, 0}, {0.99, 2}, {0.999, 4}, {0.9999, 10}}};
1036        } else {
1037    return {0.05,
1038            2.0,
1039            {{0.95, 0.1}},
1040            {{0.95, 0}, {0.99, 2}, {0.999, 4}, {0.9999, 10}}};
1041        }
1042      case 16:
1043        if (kRandomizesInserts) {
1044          return {0.1,
1045                  2.0,
1046                  {{0.95, 0.1}},
1047                  {{0.95, 0}, {0.99, 1}, {0.999, 8}, {0.9999, 15}}};
1048        } else {
1049          return {0.05,
1050                  1.0,
1051                  {{0.95, 0.05}},
1052                  {{0.95, 0}, {0.99, 1}, {0.999, 4}, {0.9999, 10}}};
1053        }
1054    }
1055    LOG(FATAL) << "Unknown Group width";
1056    return {};
1057  }
1058  TEST(Table, DISABLED_EnsureNonQuadraticTopNXorSeedByProbeSeqLength) {
1059    ProbeStatsPerSize stats;
1060    std::vector<size_t> sizes = {Group::kWidth << 5, Group::kWidth << 10};
1061    for (size_t size : sizes) {
1062      stats[size] =
1063          CollectProbeStatsOnKeysXoredWithSeed(CollectBadMergeKeys(size), 200);
1064    }
1065    auto expected = XorSeedExpectedStats();
1066    for (size_t size : sizes) {
1067      auto& stat = stats[size];
1068      VerifyStats(size, expected, stat);
1069      LOG(INFO) << size << " " << stat;
1070    }
1071  }
1072  ProbeStats CollectProbeStatsOnLinearlyTransformedKeys(
1073      const std::vector<int64_t>& keys, size_t num_iters) {
1074    ProbeStats stats;
1075    std::random_device rd;
1076    std::mt19937 rng(rd());
1077    auto linear_transform = [](size_t x, size_t y) { return x * 17 + y * 13; };
1078    std::uniform_int_distribution<size_t> dist(0, keys.size()-1);
1079    while (num_iters--) {
1080      IntTable t1;
1081      size_t num_keys = keys.size() / 10;
1082      size_t start = dist(rng);
1083      for (size_t i = 0; i != num_keys; ++i) {
1084        for (size_t j = 0; j != 10; ++j) {
1085          t1.emplace(linear_transform(keys[(i + start) % keys.size()], j));
1086        }
1087      }
1088      auto probe_histogram = GetHashtableDebugNumProbesHistogram(t1);
1089      stats.all_probes_histogram.resize(
1090          std::max(stats.all_probes_histogram.size(), probe_histogram.size()));
1091      std::transform(probe_histogram.begin(), probe_histogram.end(),
1092                     stats.all_probes_histogram.begin(),
1093                     stats.all_probes_histogram.begin(), std::plus<size_t>());
1094      size_t total_probe_seq_length = 0;
1095      for (size_t i = 0; i < probe_histogram.size(); ++i) {
1096        total_probe_seq_length += i * probe_histogram[i];
1097      }
1098      stats.single_table_ratios.push_back(total_probe_seq_length * 1.0 /
1099                                          t1.size());
1100      t1.erase(t1.begin(), t1.end());
1101    }
1102    return stats;
1103  }
1104  ExpectedStats LinearTransformExpectedStats() {
1105    constexpr bool kRandomizesInserts =
1106  #ifdef NDEBUG
1107        false;
1108  #else   
1109        true;
1110  #endif  
1111    switch (container_internal::Group::kWidth) {
1112      case 8:
1113        if (kRandomizesInserts) {
1114          return {0.1,
1115                  0.5,
1116                  {{0.95, 0.3}},
1117                  {{0.95, 0}, {0.99, 1}, {0.999, 8}, {0.9999, 15}}};
1118        } else {
1119          return {0.4,
1120                  0.6,
1121                  {{0.95, 0.5}},
1122                  {{0.95, 1}, {0.99, 14}, {0.999, 23}, {0.9999, 26}}};
1123        }
1124      case 16:
1125        if (kRandomizesInserts) {
1126          return {0.1,
1127                  0.4,
1128                  {{0.95, 0.3}},
1129                  {{0.95, 1}, {0.99, 2}, {0.999, 9}, {0.9999, 15}}};
1130        } else {
1131          return {0.05,
1132                  0.2,
1133                  {{0.95, 0.1}},
1134                  {{0.95, 0}, {0.99, 1}, {0.999, 6}, {0.9999, 10}}};
1135        }
1136    }
1137    LOG(FATAL) << "Unknown Group width";
1138    return {};
1139  }
1140  TEST(Table, DISABLED_EnsureNonQuadraticTopNLinearTransformByProbeSeqLength) {
1141    ProbeStatsPerSize stats;
1142    std::vector<size_t> sizes = {Group::kWidth << 5, Group::kWidth << 10};
1143    for (size_t size : sizes) {
1144      stats[size] = CollectProbeStatsOnLinearlyTransformedKeys(
1145          CollectBadMergeKeys(size), 300);
1146    }
1147    auto expected = LinearTransformExpectedStats();
1148    for (size_t size : sizes) {
1149      auto& stat = stats[size];
1150      VerifyStats(size, expected, stat);
1151      LOG(INFO) << size << " " << stat;
1152    }
1153  }
1154  TEST(Table, EraseCollision) {
1155    BadTable t;
1156    t.emplace(1);
1157    t.emplace(2);
1158    t.emplace(3);
1159    EXPECT_THAT(*t.find(1), 1);
1160    EXPECT_THAT(*t.find(2), 2);
1161    EXPECT_THAT(*t.find(3), 3);
1162    EXPECT_EQ(3, t.size());
1163    t.erase(t.find(2));
1164    EXPECT_THAT(*t.find(1), 1);
1165    EXPECT_TRUE(t.find(2) == t.end());
1166    EXPECT_THAT(*t.find(3), 3);
1167    EXPECT_EQ(2, t.size());
1168    t.erase(t.find(1));
1169    EXPECT_TRUE(t.find(1) == t.end());
1170    EXPECT_TRUE(t.find(2) == t.end());
1171    EXPECT_THAT(*t.find(3), 3);
1172    EXPECT_EQ(1, t.size());
1173    t.erase(t.find(3));
1174    EXPECT_TRUE(t.find(1) == t.end());
1175    EXPECT_TRUE(t.find(2) == t.end());
1176    EXPECT_TRUE(t.find(3) == t.end());
1177    EXPECT_EQ(0, t.size());
1178  }
1179  TEST(Table, EraseInsertProbing) {
1180    BadTable t(100);
1181    t.emplace(1);
1182    t.emplace(2);
1183    t.emplace(3);
1184    t.emplace(4);
1185    t.erase(t.find(2));
1186    t.erase(t.find(4));
1187    t.emplace(10);
1188    t.emplace(11);
1189    t.emplace(12);
1190    EXPECT_EQ(5, t.size());
1191    EXPECT_THAT(t, UnorderedElementsAre(1, 10, 3, 11, 12));
1192  }
1193  TEST(Table, Clear) {
1194    IntTable t;
1195    EXPECT_TRUE(t.find(0) == t.end());
1196    t.clear();
1197    EXPECT_TRUE(t.find(0) == t.end());
1198    auto res = t.emplace(0);
1199    EXPECT_TRUE(res.second);
1200    EXPECT_EQ(1, t.size());
1201    t.clear();
1202    EXPECT_EQ(0, t.size());
1203    EXPECT_TRUE(t.find(0) == t.end());
1204  }
1205  TEST(Table, Swap) {
1206    IntTable t;
1207    EXPECT_TRUE(t.find(0) == t.end());
1208    auto res = t.emplace(0);
1209    EXPECT_TRUE(res.second);
1210    EXPECT_EQ(1, t.size());
1211    IntTable u;
<span onclick='openModal()' class='match'>1212    t.swap(u);
1213    EXPECT_EQ(0, t.size());
1214    EXPECT_EQ(1, u.size());
</span>1215    EXPECT_TRUE(t.find(0) == t.end());
1216    EXPECT_THAT(*u.find(0), 0);
1217  }
1218  TEST(Table, Rehash) {
1219    IntTable t;
1220    EXPECT_TRUE(t.find(0) == t.end());
1221    t.emplace(0);
1222    t.emplace(1);
1223    EXPECT_EQ(2, t.size());
1224    t.rehash(128);
1225    EXPECT_EQ(2, t.size());
1226    EXPECT_THAT(*t.find(0), 0);
1227    EXPECT_THAT(*t.find(1), 1);
1228  }
1229  TEST(Table, RehashDoesNotRehashWhenNotNecessary) {
1230    IntTable t;
1231    t.emplace(0);
1232    t.emplace(1);
1233    auto* p = &*t.find(0);
1234    t.rehash(1);
1235    EXPECT_EQ(p, &*t.find(0));
1236  }
1237  TEST(Table, RehashZeroDoesNotAllocateOnEmptyTable) {
1238    IntTable t;
1239    t.rehash(0);
1240    EXPECT_EQ(0, t.bucket_count());
1241  }
1242  TEST(Table, RehashZeroDeallocatesEmptyTable) {
1243    IntTable t;
1244    t.emplace(0);
1245    t.clear();
1246    EXPECT_NE(0, t.bucket_count());
1247    t.rehash(0);
1248    EXPECT_EQ(0, t.bucket_count());
1249  }
1250  TEST(Table, RehashZeroForcesRehash) {
1251    IntTable t;
1252    t.emplace(0);
1253    t.emplace(1);
1254    auto* p = &*t.find(0);
1255    t.rehash(0);
1256    EXPECT_NE(p, &*t.find(0));
1257  }
1258  TEST(Table, ConstructFromInitList) {
1259    using P = std::pair<std::string, std::string>;
1260    struct Q {
1261      operator P() const { return {}; }  
1262    };
1263    StringTable t = {P(), Q(), {}, {{}, {}}};
1264  }
1265  TEST(Table, CopyConstruct) {
1266    IntTable t;
1267    t.emplace(0);
1268    EXPECT_EQ(1, t.size());
1269    {
1270      IntTable u(t);
1271      EXPECT_EQ(1, u.size());
1272      EXPECT_THAT(*u.find(0), 0);
1273    }
1274    {
1275      IntTable u{t};
1276      EXPECT_EQ(1, u.size());
1277      EXPECT_THAT(*u.find(0), 0);
1278    }
1279    {
1280      IntTable u = t;
1281      EXPECT_EQ(1, u.size());
1282      EXPECT_THAT(*u.find(0), 0);
1283    }
1284  }
1285  TEST(Table, CopyConstructWithAlloc) {
1286    StringTable t;
1287    t.emplace("a", "b");
1288    EXPECT_EQ(1, t.size());
1289    StringTable u(t, Alloc<std::pair<std::string, std::string>>());
1290    EXPECT_EQ(1, u.size());
1291    EXPECT_THAT(*u.find("a"), Pair("a", "b"));
1292  }
1293  struct ExplicitAllocIntTable
1294      : raw_hash_set<IntPolicy, container_internal::hash_default_hash<int64_t>,
1295                     std::equal_to<int64_t>, Alloc<int64_t>> {
1296    ExplicitAllocIntTable() = default;
1297  };
1298  TEST(Table, AllocWithExplicitCtor) {
1299    ExplicitAllocIntTable t;
1300    EXPECT_EQ(0, t.size());
1301  }
1302  TEST(Table, MoveConstruct) {
1303    {
1304      StringTable t;
1305      t.emplace("a", "b");
1306      EXPECT_EQ(1, t.size());
1307      StringTable u(std::move(t));
1308      EXPECT_EQ(1, u.size());
1309      EXPECT_THAT(*u.find("a"), Pair("a", "b"));
1310    }
1311    {
1312      StringTable t;
1313      t.emplace("a", "b");
1314      EXPECT_EQ(1, t.size());
1315      StringTable u{std::move(t)};
1316      EXPECT_EQ(1, u.size());
1317      EXPECT_THAT(*u.find("a"), Pair("a", "b"));
1318    }
1319    {
1320      StringTable t;
1321      t.emplace("a", "b");
1322      EXPECT_EQ(1, t.size());
1323      StringTable u = std::move(t);
1324      EXPECT_EQ(1, u.size());
1325      EXPECT_THAT(*u.find("a"), Pair("a", "b"));
1326    }
1327  }
1328  TEST(Table, MoveConstructWithAlloc) {
1329    StringTable t;
1330    t.emplace("a", "b");
1331    EXPECT_EQ(1, t.size());
1332    StringTable u(std::move(t), Alloc<std::pair<std::string, std::string>>());
1333    EXPECT_EQ(1, u.size());
1334    EXPECT_THAT(*u.find("a"), Pair("a", "b"));
1335  }
1336  TEST(Table, CopyAssign) {
1337    StringTable t;
1338    t.emplace("a", "b");
1339    EXPECT_EQ(1, t.size());
1340    StringTable u;
1341    u = t;
1342    EXPECT_EQ(1, u.size());
1343    EXPECT_THAT(*u.find("a"), Pair("a", "b"));
1344  }
1345  TEST(Table, CopySelfAssign) {
1346    StringTable t;
1347    t.emplace("a", "b");
1348    EXPECT_EQ(1, t.size());
1349    t = *&t;
1350    EXPECT_EQ(1, t.size());
1351    EXPECT_THAT(*t.find("a"), Pair("a", "b"));
1352  }
1353  TEST(Table, MoveAssign) {
1354    StringTable t;
1355    t.emplace("a", "b");
1356    EXPECT_EQ(1, t.size());
1357    StringTable u;
1358    u = std::move(t);
1359    EXPECT_EQ(1, u.size());
1360    EXPECT_THAT(*u.find("a"), Pair("a", "b"));
1361  }
1362  TEST(Table, Equality) {
1363    StringTable t;
1364    std::vector<std::pair<std::string, std::string>> v = {{"a", "b"},
1365                                                          {"aa", "bb"}};
1366    t.insert(std::begin(v), std::end(v));
1367    StringTable u = t;
1368    EXPECT_EQ(u, t);
1369  }
1370  TEST(Table, Equality2) {
1371    StringTable t;
1372    std::vector<std::pair<std::string, std::string>> v1 = {{"a", "b"},
1373                                                           {"aa", "bb"}};
1374    t.insert(std::begin(v1), std::end(v1));
1375    StringTable u;
1376    std::vector<std::pair<std::string, std::string>> v2 = {{"a", "a"},
1377                                                           {"aa", "aa"}};
1378    u.insert(std::begin(v2), std::end(v2));
1379    EXPECT_NE(u, t);
1380  }
1381  TEST(Table, Equality3) {
1382    StringTable t;
1383    std::vector<std::pair<std::string, std::string>> v1 = {{"b", "b"},
1384                                                           {"bb", "bb"}};
1385    t.insert(std::begin(v1), std::end(v1));
1386    StringTable u;
1387    std::vector<std::pair<std::string, std::string>> v2 = {{"a", "a"},
1388                                                           {"aa", "aa"}};
1389    u.insert(std::begin(v2), std::end(v2));
1390    EXPECT_NE(u, t);
1391  }
1392  TEST(Table, NumDeletedRegression) {
1393    IntTable t;
1394    t.emplace(0);
1395    t.erase(t.find(0));
1396    t.emplace(0);
1397    t.clear();
1398  }
1399  TEST(Table, FindFullDeletedRegression) {
1400    IntTable t;
1401    for (int i = 0; i < 1000; ++i) {
1402      t.emplace(i);
1403      t.erase(t.find(i));
1404    }
1405    EXPECT_EQ(0, t.size());
1406  }
1407  TEST(Table, ReplacingDeletedSlotDoesNotRehash) {
1408    size_t n;
1409    {
1410      IntTable t;
1411      t.emplace(0);
1412      size_t c = t.bucket_count();
1413      for (n = 1; c == t.bucket_count(); ++n) t.emplace(n);
1414      --n;
1415    }
1416    IntTable t;
1417    t.rehash(n);
1418    const size_t c = t.bucket_count();
1419    for (size_t i = 0; i != n; ++i) t.emplace(i);
1420    EXPECT_EQ(c, t.bucket_count()) << "rehashing threshold = " << n;
1421    t.erase(0);
1422    t.emplace(0);
1423    EXPECT_EQ(c, t.bucket_count()) << "rehashing threshold = " << n;
1424  }
1425  TEST(Table, NoThrowMoveConstruct) {
1426    ASSERT_TRUE(
1427        std::is_nothrow_copy_constructible<absl::Hash<absl::string_view>>::value);
1428    ASSERT_TRUE(std::is_nothrow_copy_constructible<
1429                std::equal_to<absl::string_view>>::value);
1430    ASSERT_TRUE(std::is_nothrow_copy_constructible<std::allocator<int>>::value);
1431    EXPECT_TRUE(std::is_nothrow_move_constructible<StringTable>::value);
1432  }
1433  TEST(Table, NoThrowMoveAssign) {
1434    ASSERT_TRUE(
1435        std::is_nothrow_move_assignable<absl::Hash<absl::string_view>>::value);
1436    ASSERT_TRUE(
1437        std::is_nothrow_move_assignable<std::equal_to<absl::string_view>>::value);
1438    ASSERT_TRUE(std::is_nothrow_move_assignable<std::allocator<int>>::value);
1439    ASSERT_TRUE(
1440        absl::allocator_traits<std::allocator<int>>::is_always_equal::value);
1441    EXPECT_TRUE(std::is_nothrow_move_assignable<StringTable>::value);
1442  }
1443  TEST(Table, NoThrowSwappable) {
1444    ASSERT_TRUE(
1445        container_internal::IsNoThrowSwappable<absl::Hash<absl::string_view>>());
1446    ASSERT_TRUE(container_internal::IsNoThrowSwappable<
1447                std::equal_to<absl::string_view>>());
1448    ASSERT_TRUE(container_internal::IsNoThrowSwappable<std::allocator<int>>());
1449    EXPECT_TRUE(container_internal::IsNoThrowSwappable<StringTable>());
1450  }
1451  TEST(Table, HeterogeneousLookup) {
1452    struct Hash {
1453      size_t operator()(int64_t i) const { return i; }
1454      size_t operator()(double i) const {
1455        ADD_FAILURE();
1456        return i;
1457      }
1458    };
1459    struct Eq {
1460      bool operator()(int64_t a, int64_t b) const { return a == b; }
1461      bool operator()(double a, int64_t b) const {
1462        ADD_FAILURE();
1463        return a == b;
1464      }
1465      bool operator()(int64_t a, double b) const {
1466        ADD_FAILURE();
1467        return a == b;
1468      }
1469      bool operator()(double a, double b) const {
1470        ADD_FAILURE();
1471        return a == b;
1472      }
1473    };
1474    struct THash {
1475      using is_transparent = void;
1476      size_t operator()(int64_t i) const { return i; }
1477      size_t operator()(double i) const { return i; }
1478    };
1479    struct TEq {
1480      using is_transparent = void;
1481      bool operator()(int64_t a, int64_t b) const { return a == b; }
1482      bool operator()(double a, int64_t b) const { return a == b; }
1483      bool operator()(int64_t a, double b) const { return a == b; }
1484      bool operator()(double a, double b) const { return a == b; }
1485    };
1486    raw_hash_set<IntPolicy, Hash, Eq, Alloc<int64_t>> s{0, 1, 2};
1487    EXPECT_EQ(1, *s.find(double{1.1}));
1488    raw_hash_set<IntPolicy, THash, TEq, Alloc<int64_t>> ts{0, 1, 2};
1489    EXPECT_TRUE(ts.find(1.1) == ts.end());
1490  }
1491  template <class Table>
1492  using CallFind = decltype(std::declval<Table&>().find(17));
1493  template <class Table>
1494  using CallErase = decltype(std::declval<Table&>().erase(17));
1495  template <class Table>
1496  using CallExtract = decltype(std::declval<Table&>().extract(17));
1497  template <class Table>
1498  using CallPrefetch = decltype(std::declval<Table&>().prefetch(17));
1499  template <class Table>
1500  using CallCount = decltype(std::declval<Table&>().count(17));
1501  template <template <typename> class C, class Table, class = void>
1502  struct VerifyResultOf : std::false_type {};
1503  template <template <typename> class C, class Table>
1504  struct VerifyResultOf<C, Table, absl::void_t<C<Table>>> : std::true_type {};
1505  TEST(Table, HeterogeneousLookupOverloads) {
1506    using NonTransparentTable =
1507        raw_hash_set<StringPolicy, absl::Hash<absl::string_view>,
1508                     std::equal_to<absl::string_view>, std::allocator<int>>;
1509    EXPECT_FALSE((VerifyResultOf<CallFind, NonTransparentTable>()));
1510    EXPECT_FALSE((VerifyResultOf<CallErase, NonTransparentTable>()));
1511    EXPECT_FALSE((VerifyResultOf<CallExtract, NonTransparentTable>()));
1512    EXPECT_FALSE((VerifyResultOf<CallPrefetch, NonTransparentTable>()));
1513    EXPECT_FALSE((VerifyResultOf<CallCount, NonTransparentTable>()));
1514    using TransparentTable = raw_hash_set<
1515        StringPolicy,
1516        absl::container_internal::hash_default_hash<absl::string_view>,
1517        absl::container_internal::hash_default_eq<absl::string_view>,
1518        std::allocator<int>>;
1519    EXPECT_TRUE((VerifyResultOf<CallFind, TransparentTable>()));
1520    EXPECT_TRUE((VerifyResultOf<CallErase, TransparentTable>()));
1521    EXPECT_TRUE((VerifyResultOf<CallExtract, TransparentTable>()));
1522    EXPECT_TRUE((VerifyResultOf<CallPrefetch, TransparentTable>()));
1523    EXPECT_TRUE((VerifyResultOf<CallCount, TransparentTable>()));
1524  }
1525  TEST(Iterator, IsDefaultConstructible) {
1526    StringTable::iterator i;
1527    EXPECT_TRUE(i == StringTable::iterator());
1528  }
1529  TEST(ConstIterator, IsDefaultConstructible) {
1530    StringTable::const_iterator i;
1531    EXPECT_TRUE(i == StringTable::const_iterator());
1532  }
1533  TEST(Iterator, ConvertsToConstIterator) {
1534    StringTable::iterator i;
1535    EXPECT_TRUE(i == StringTable::const_iterator());
1536  }
1537  TEST(Iterator, Iterates) {
1538    IntTable t;
1539    for (size_t i = 3; i != 6; ++i) EXPECT_TRUE(t.emplace(i).second);
1540    EXPECT_THAT(t, UnorderedElementsAre(3, 4, 5));
1541  }
1542  TEST(Table, Merge) {
1543    StringTable t1, t2;
1544    t1.emplace("0", "-0");
1545    t1.emplace("1", "-1");
1546    t2.emplace("0", "~0");
1547    t2.emplace("2", "~2");
1548    EXPECT_THAT(t1, UnorderedElementsAre(Pair("0", "-0"), Pair("1", "-1")));
1549    EXPECT_THAT(t2, UnorderedElementsAre(Pair("0", "~0"), Pair("2", "~2")));
1550    t1.merge(t2);
1551    EXPECT_THAT(t1, UnorderedElementsAre(Pair("0", "-0"), Pair("1", "-1"),
1552                                         Pair("2", "~2")));
1553    EXPECT_THAT(t2, UnorderedElementsAre(Pair("0", "~0")));
1554  }
1555  TEST(Table, IteratorEmplaceConstructibleRequirement) {
1556    struct Value {
1557      explicit Value(absl::string_view view) : value(view) {}
1558      std::string value;
1559      bool operator==(const Value& other) const { return value == other.value; }
1560    };
1561    struct H {
1562      size_t operator()(const Value& v) const {
1563        return absl::Hash<std::string>{}(v.value);
1564      }
1565    };
1566    struct Table : raw_hash_set<ValuePolicy<Value>, H, std::equal_to<Value>,
1567                                std::allocator<Value>> {
1568      using Base = typename Table::raw_hash_set;
1569      using Base::Base;
1570    };
1571    std::string input[3]{"A", "B", "C"};
1572    Table t(std::begin(input), std::end(input));
1573    EXPECT_THAT(t, UnorderedElementsAre(Value{"A"}, Value{"B"}, Value{"C"}));
1574    input[0] = "D";
1575    input[1] = "E";
1576    input[2] = "F";
1577    t.insert(std::begin(input), std::end(input));
1578    EXPECT_THAT(t, UnorderedElementsAre(Value{"A"}, Value{"B"}, Value{"C"},
1579                                        Value{"D"}, Value{"E"}, Value{"F"}));
1580  }
1581  TEST(Nodes, EmptyNodeType) {
1582    using node_type = StringTable::node_type;
1583    node_type n;
1584    EXPECT_FALSE(n);
1585    EXPECT_TRUE(n.empty());
1586    EXPECT_TRUE((std::is_same<node_type::allocator_type,
1587                              StringTable::allocator_type>::value));
1588  }
1589  TEST(Nodes, ExtractInsert) {
1590    constexpr char k0[] = "Very long string zero.";
1591    constexpr char k1[] = "Very long string one.";
1592    constexpr char k2[] = "Very long string two.";
1593    StringTable t = {{k0, ""}, {k1, ""}, {k2, ""}};
1594    EXPECT_THAT(t,
1595                UnorderedElementsAre(Pair(k0, ""), Pair(k1, ""), Pair(k2, "")));
1596    auto node = t.extract(k0);
1597    EXPECT_THAT(t, UnorderedElementsAre(Pair(k1, ""), Pair(k2, "")));
1598    EXPECT_TRUE(node);
1599    EXPECT_FALSE(node.empty());
1600    StringTable t2;
1601    StringTable::insert_return_type res = t2.insert(std::move(node));
1602    EXPECT_TRUE(res.inserted);
1603    EXPECT_THAT(*res.position, Pair(k0, ""));
1604    EXPECT_FALSE(res.node);
1605    EXPECT_THAT(t2, UnorderedElementsAre(Pair(k0, "")));
1606    EXPECT_THAT(t, UnorderedElementsAre(Pair(k1, ""), Pair(k2, "")));
1607    node = t.extract("Not there!");
1608    EXPECT_THAT(t, UnorderedElementsAre(Pair(k1, ""), Pair(k2, "")));
1609    EXPECT_FALSE(node);
1610    res = t2.insert(std::move(node));
1611    EXPECT_FALSE(res.inserted);
1612    EXPECT_EQ(res.position, t2.end());
1613    EXPECT_FALSE(res.node);
1614    EXPECT_THAT(t2, UnorderedElementsAre(Pair(k0, "")));
1615    t.emplace(k0, "1");
1616    node = t.extract(k0);
1617    res = t2.insert(std::move(node));
1618    EXPECT_FALSE(res.inserted);
1619    EXPECT_THAT(*res.position, Pair(k0, ""));
1620    EXPECT_TRUE(res.node);
1621    EXPECT_FALSE(node);  
1622  }
1623  TEST(Nodes, HintInsert) {
1624    IntTable t = {1, 2, 3};
1625    auto node = t.extract(1);
1626    EXPECT_THAT(t, UnorderedElementsAre(2, 3));
1627    auto it = t.insert(t.begin(), std::move(node));
1628    EXPECT_THAT(t, UnorderedElementsAre(1, 2, 3));
1629    EXPECT_EQ(*it, 1);
1630    EXPECT_FALSE(node);  
1631    node = t.extract(2);
1632    EXPECT_THAT(t, UnorderedElementsAre(1, 3));
1633    t.insert(2);
1634    EXPECT_THAT(t, UnorderedElementsAre(1, 2, 3));
1635    it = t.insert(t.begin(), std::move(node));
1636    EXPECT_EQ(*it, 2);
1637    EXPECT_TRUE(node);  
1638  }
1639  IntTable MakeSimpleTable(size_t size) {
1640    IntTable t;
1641    while (t.size() < size) t.insert(t.size());
1642    return t;
1643  }
1644  std::vector<int> OrderOfIteration(const IntTable& t) {
1645    return {t.begin(), t.end()};
1646  }
1647  TEST(Table, IterationOrderChangesByInstance) {
1648    for (size_t size : {2, 6, 12, 20}) {
1649      const auto reference_table = MakeSimpleTable(size);
1650      const auto reference = OrderOfIteration(reference_table);
1651      std::vector<IntTable> tables;
1652      bool found_difference = false;
1653      for (int i = 0; !found_difference && i < 5000; ++i) {
1654        tables.push_back(MakeSimpleTable(size));
1655        found_difference = OrderOfIteration(tables.back()) != reference;
1656      }
1657      if (!found_difference) {
1658        FAIL()
1659            << "Iteration order remained the same across many attempts with size "
1660            << size;
1661      }
1662    }
1663  }
1664  TEST(Table, IterationOrderChangesOnRehash) {
1665    std::vector<IntTable> garbage;
1666    for (int i = 0; i < 5000; ++i) {
1667      auto t = MakeSimpleTable(20);
1668      const auto reference = OrderOfIteration(t);
1669      t.rehash(0);
1670      auto trial = OrderOfIteration(t);
1671      if (trial != reference) {
1672        return;
1673      }
1674      garbage.push_back(std::move(t));
1675    }
1676    FAIL() << "Iteration order remained the same across many attempts.";
1677  }
1678  TEST(Table, UnstablePointers) {
1679    IntTable table;
1680    const auto addr = [&](int i) {
1681      return reinterpret_cast<uintptr_t>(&*table.find(i));
1682    };
1683    table.insert(0);
1684    const uintptr_t old_ptr = addr(0);
1685    table.insert(1);
1686    EXPECT_NE(old_ptr, addr(0));
1687  }
1688  bool IsAssertEnabled() {
1689    bool assert_enabled = false;
1690    assert([&]() {  
1691      assert_enabled = true;
1692      return true;
1693    }());
1694    return assert_enabled;
1695  }
1696  TEST(TableDeathTest, InvalidIteratorAsserts) {
1697    if (!IsAssertEnabled() && !SwisstableGenerationsEnabled())
1698      GTEST_SKIP() << "Assertions not enabled.";
1699    IntTable t;
1700    EXPECT_DEATH_IF_SUPPORTED(t.erase(t.end()),
1701                              "erase.* called on end.. iterator.");
1702    typename IntTable::iterator iter;
1703    EXPECT_DEATH_IF_SUPPORTED(
1704        ++iter, "operator.* called on default-constructed iterator.");
1705    t.insert(0);
1706    iter = t.begin();
1707    t.erase(iter);
1708    const char* const kErasedDeathMessage =
1709        SwisstableGenerationsEnabled()
1710            ? "operator.* called on invalid iterator.*was likely erased"
1711            : "operator.* called on invalid iterator.*might have been "
1712              "erased.*config=asan";
1713    EXPECT_DEATH_IF_SUPPORTED(++iter, kErasedDeathMessage);
1714  }
1715  constexpr const char* kInvalidIteratorDeathMessage =
1716      "heap-use-after-free|use-of-uninitialized-value|invalidated "
1717      "iterator|Invalid iterator";
1718  #if defined(_MSC_VER)
1719  constexpr bool kMsvc = true;
1720  #else
1721  constexpr bool kMsvc = false;
1722  #endif
1723  TEST(TableDeathTest, IteratorInvalidAssertsEqualityOperator) {
1724    if (!IsAssertEnabled() && !SwisstableGenerationsEnabled())
1725      GTEST_SKIP() << "Assertions not enabled.";
1726    IntTable t;
1727    t.insert(1);
1728    t.insert(2);
1729    t.insert(3);
1730    auto iter1 = t.begin();
1731    auto iter2 = std::next(iter1);
1732    ASSERT_NE(iter1, t.end());
1733    ASSERT_NE(iter2, t.end());
1734    t.erase(iter1);
1735    const char* const kErasedDeathMessage =
1736        SwisstableGenerationsEnabled()
1737            ? "Invalid iterator comparison.*was likely erased"
1738            : "Invalid iterator comparison.*might have been erased.*config=asan";
1739    EXPECT_DEATH_IF_SUPPORTED(void(iter1 == iter2), kErasedDeathMessage);
1740    EXPECT_DEATH_IF_SUPPORTED(void(iter2 != iter1), kErasedDeathMessage);
1741    t.erase(iter2);
1742    EXPECT_DEATH_IF_SUPPORTED(void(iter1 == iter2), kErasedDeathMessage);
1743    IntTable t1, t2;
1744    t1.insert(0);
1745    t2.insert(0);
1746    iter1 = t1.begin();
1747    iter2 = t2.begin();
1748    const char* const kContainerDiffDeathMessage =
1749        SwisstableGenerationsEnabled()
1750            ? "Invalid iterator comparison.*iterators from different hashtables"
1751            : "Invalid iterator comparison.*may be from different "
1752              ".*containers.*config=asan";
1753    EXPECT_DEATH_IF_SUPPORTED(void(iter1 == iter2), kContainerDiffDeathMessage);
1754    EXPECT_DEATH_IF_SUPPORTED(void(iter2 == iter1), kContainerDiffDeathMessage);
1755    for (int i = 0; i < 10; ++i) t1.insert(i);
1756    if (kMsvc) return;  
1757    const char* const kRehashedDeathMessage =
1758        SwisstableGenerationsEnabled()
1759            ? kInvalidIteratorDeathMessage
1760            : "Invalid iterator comparison.*might have rehashed.*config=asan";
1761    EXPECT_DEATH_IF_SUPPORTED(void(iter1 == t1.begin()), kRehashedDeathMessage);
1762  }
1763  #if defined(ABSL_INTERNAL_HASHTABLEZ_SAMPLE)
1764  TEST(RawHashSamplerTest, Sample) {
1765    SetHashtablezEnabled(true);
1766    SetHashtablezSampleParameter(100);
1767    auto& sampler = GlobalHashtablezSampler();
1768    size_t start_size = 0;
1769    absl::flat_hash_set<const HashtablezInfo*> preexisting_info;
1770    start_size += sampler.Iterate([&](const HashtablezInfo& info) {
1771      preexisting_info.insert(&info);
1772      ++start_size;
1773    });
1774    std::vector<IntTable> tables;
1775    for (int i = 0; i < 1000000; ++i) {
1776      tables.emplace_back();
1777      const bool do_reserve = (i % 10 > 5);
1778      const bool do_rehash = !do_reserve && (i % 10 > 0);
1779      if (do_reserve) {
1780        tables.back().reserve(10 * (i % 10));
1781      }
1782      tables.back().insert(1);
1783      tables.back().insert(i % 5);
1784      if (do_rehash) {
1785        tables.back().rehash(10 * (i % 10));
1786      }
1787    }
1788    size_t end_size = 0;
1789    absl::flat_hash_map<size_t, int> observed_checksums;
1790    absl::flat_hash_map<ssize_t, int> reservations;
1791    end_size += sampler.Iterate([&](const HashtablezInfo& info) {
1792      if (preexisting_info.count(&info) == 0) {
1793        observed_checksums[info.hashes_bitwise_xor.load(
1794            std::memory_order_relaxed)]++;
1795        reservations[info.max_reserve.load(std::memory_order_relaxed)]++;
1796      }
1797      EXPECT_EQ(info.inline_element_size, sizeof(int64_t));
1798      ++end_size;
1799    });
1800    EXPECT_NEAR((end_size - start_size) / static_cast<double>(tables.size()),
1801                0.01, 0.005);
1802    EXPECT_EQ(observed_checksums.size(), 5);
1803    for (const auto& [_, count] : observed_checksums) {
1804      EXPECT_NEAR((100 * count) / static_cast<double>(tables.size()), 0.2, 0.05);
1805    }
1806    EXPECT_EQ(reservations.size(), 10);
1807    for (const auto& [reservation, count] : reservations) {
1808      EXPECT_GE(reservation, 0);
1809      EXPECT_LT(reservation, 100);
1810      EXPECT_NEAR((100 * count) / static_cast<double>(tables.size()), 0.1, 0.05)
1811          << reservation;
1812    }
1813  }
1814  #endif  
1815  TEST(RawHashSamplerTest, DoNotSampleCustomAllocators) {
1816    SetHashtablezEnabled(true);
1817    SetHashtablezSampleParameter(100);
1818    auto& sampler = GlobalHashtablezSampler();
1819    size_t start_size = 0;
1820    start_size += sampler.Iterate([&](const HashtablezInfo&) { ++start_size; });
1821    std::vector<CustomAllocIntTable> tables;
1822    for (int i = 0; i < 1000000; ++i) {
1823      tables.emplace_back();
1824      tables.back().insert(1);
1825    }
1826    size_t end_size = 0;
1827    end_size += sampler.Iterate([&](const HashtablezInfo&) { ++end_size; });
1828    EXPECT_NEAR((end_size - start_size) / static_cast<double>(tables.size()),
1829                0.00, 0.001);
1830  }
1831  #ifdef ABSL_HAVE_ADDRESS_SANITIZER
1832  TEST(Sanitizer, PoisoningUnused) {
1833    IntTable t;
1834    t.reserve(5);
1835    int64_t& v1 = *t.insert(0).first;
1836    ASSERT_GT(t.capacity(), 1);
1837    int64_t* slots = RawHashSetTestOnlyAccess::GetSlots(t);
1838    for (size_t i = 0; i < t.capacity(); ++i) {
1839      EXPECT_EQ(slots + i != &v1, __asan_address_is_poisoned(slots + i));
1840    }
1841  }
1842  TEST(Sanitizer, PoisoningOnErase) {
1843    IntTable t;
1844    int64_t& v = *t.insert(0).first;
1845    EXPECT_FALSE(__asan_address_is_poisoned(&v));
1846    t.erase(0);
1847    EXPECT_TRUE(__asan_address_is_poisoned(&v));
1848  }
1849  #endif  
1850  TEST(Table, AlignOne) {
1851    Uint8Table t;
1852    std::unordered_set<uint8_t> verifier;  
1853    for (int64_t i = 0; i < 100000; ++i) {
1854      SCOPED_TRACE(i);
1855      const uint8_t u = (i * -i) & 0xFF;
1856      auto it = t.find(u);
1857      auto verifier_it = verifier.find(u);
1858      if (it == t.end()) {
1859        ASSERT_EQ(verifier_it, verifier.end());
1860        t.insert(u);
1861        verifier.insert(u);
1862      } else {
1863        ASSERT_NE(verifier_it, verifier.end());
1864        t.erase(it);
1865        verifier.erase(verifier_it);
1866      }
1867    }
1868    EXPECT_EQ(t.size(), verifier.size());
1869    for (uint8_t u : t) {
1870      EXPECT_EQ(verifier.count(u), 1);
1871    }
1872  }
1873  TEST(Iterator, InvalidUseCrashesWithSanitizers) {
1874    if (!SwisstableGenerationsEnabled()) GTEST_SKIP() << "Generations disabled.";
1875    if (kMsvc) GTEST_SKIP() << "MSVC doesn't support | in regexp.";
1876    IntTable t;
1877    t.insert(-1);
1878    for (int i = 0; i < 10; ++i) {
1879      auto it = t.begin();
1880      t.insert(i);
1881      EXPECT_DEATH_IF_SUPPORTED(*it, kInvalidIteratorDeathMessage);
1882      EXPECT_DEATH_IF_SUPPORTED(void(it == t.begin()),
1883                                kInvalidIteratorDeathMessage);
1884    }
1885  }
1886  TEST(Iterator, InvalidUseWithReserveCrashesWithSanitizers) {
1887    if (!SwisstableGenerationsEnabled()) GTEST_SKIP() << "Generations disabled.";
1888    if (kMsvc) GTEST_SKIP() << "MSVC doesn't support | in regexp.";
1889    IntTable t;
1890    t.reserve(10);
1891    t.insert(0);
1892    auto it = t.begin();
1893    for (int i = 1; i < 10; ++i) {
1894      t.insert(i);
1895      EXPECT_EQ(*it, 0);
1896    }
1897    const int64_t* ptr = &*it;
1898    (void)ptr;
1899    t.erase(0);
1900    t.insert(10);
1901    EXPECT_DEATH_IF_SUPPORTED(*it, kInvalidIteratorDeathMessage);
1902    EXPECT_DEATH_IF_SUPPORTED(void(it == t.begin()),
1903                              kInvalidIteratorDeathMessage);
1904  #ifdef ABSL_HAVE_ADDRESS_SANITIZER
1905    EXPECT_DEATH_IF_SUPPORTED(std::cout << *ptr, "heap-use-after-free");
1906  #endif
1907  }
1908  TEST(Table, ReservedGrowthUpdatesWhenTableDoesntGrow) {
1909    IntTable t;
1910    for (int i = 0; i < 8; ++i) t.insert(i);
1911    const size_t cap = t.capacity();
1912    t.reserve(t.size() + 2);
1913    ASSERT_EQ(cap, t.capacity());
1914    auto it = t.find(0);
1915    t.insert(100);
1916    t.insert(200);
1917    EXPECT_EQ(*it, 0);
1918  }
1919  TEST(Table, GenerationInfoResetsOnClear) {
1920    if (!SwisstableGenerationsEnabled()) GTEST_SKIP() << "Generations disabled.";
1921    if (kMsvc) GTEST_SKIP() << "MSVC doesn't support | in regexp.";
1922    IntTable t;
1923    for (int i = 0; i < 1000; ++i) t.insert(i);
1924    t.reserve(t.size() + 100);
1925    t.clear();
1926    t.insert(0);
1927    auto it = t.begin();
1928    t.insert(1);
1929    EXPECT_DEATH_IF_SUPPORTED(*it, kInvalidIteratorDeathMessage);
1930  }
1931  TEST(Table, InvalidReferenceUseCrashesWithSanitizers) {
1932    if (!SwisstableGenerationsEnabled()) GTEST_SKIP() << "Generations disabled.";
1933  #ifdef ABSL_HAVE_MEMORY_SANITIZER
1934    GTEST_SKIP() << "MSan fails to detect some of these rehashes.";
1935  #endif
1936    IntTable t;
1937    t.insert(0);
1938    int64_t i = 0;
1939    while (t.capacity() <= RehashProbabilityConstant()) {
1940      const int64_t* ptr = &*t.begin();
1941      t.insert(++i);
1942      EXPECT_DEATH_IF_SUPPORTED(std::cout << *ptr, "heap-use-after-free") << i;
1943    }
1944  }
1945  TEST(Iterator, InvalidComparisonDifferentTables) {
1946    if (!SwisstableGenerationsEnabled()) GTEST_SKIP() << "Generations disabled.";
1947    IntTable t1, t2;
1948    IntTable::iterator default_constructed_iter;
1949    EXPECT_DEATH_IF_SUPPORTED(void(t1.end() == t2.end()),
1950                              "Invalid iterator comparison.*empty hashtables");
1951    EXPECT_DEATH_IF_SUPPORTED(void(t1.end() == default_constructed_iter),
1952                              "Invalid iterator comparison.*default-constructed");
1953    t1.insert(0);
1954    EXPECT_DEATH_IF_SUPPORTED(void(t1.begin() == t2.end()),
1955                              "Invalid iterator comparison.*empty hashtable");
1956    EXPECT_DEATH_IF_SUPPORTED(void(t1.begin() == default_constructed_iter),
1957                              "Invalid iterator comparison.*default-constructed");
1958    t2.insert(0);
1959    EXPECT_DEATH_IF_SUPPORTED(void(t1.begin() == t2.end()),
1960                              "Invalid iterator comparison.*end.. iterator");
1961    EXPECT_DEATH_IF_SUPPORTED(void(t1.begin() == t2.begin()),
1962                              "Invalid iterator comparison.*non-end");
1963  }
1964  }  
1965  }  
1966  ABSL_NAMESPACE_END
1967  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-node_hash_map_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-raw_hash_set_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>58    m.emplace(cp);
59    ASSERT_EQ(0, t.num_moves());
60    ASSERT_EQ(5, t.num_copies());
</pre></code></div>
                <div class="column column_space"><pre><code>1212    t.swap(u);
1213    EXPECT_EQ(0, t.size());
1214    EXPECT_EQ(1, u.size());
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    