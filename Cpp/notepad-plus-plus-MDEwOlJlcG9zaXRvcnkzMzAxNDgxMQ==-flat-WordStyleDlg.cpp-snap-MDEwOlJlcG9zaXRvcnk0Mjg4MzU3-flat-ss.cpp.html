
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 9.251101321585903%, Tokens: 29</h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-WordStyleDlg.cpp</h3>
            <pre><code>1  #include <shlwapi.h>
2  #include "WordStyleDlg.h"
3  #include "ScintillaEditView.h"
4  #include "documentMap.h"
5  #include "AutoCompletion.h"
6  #include "preference_rc.h"
7  #include "localization.h"
8  using namespace std;
9  LRESULT CALLBACK ColourStaticTextHooker::colourStaticProc(HWND hwnd, UINT Message, WPARAM wParam, LPARAM lParam)
10  {
11  	switch(Message)
12  	{
13  		case WM_PAINT:
14  		{
15  			RECT rect{};
16  			::GetClientRect(hwnd, &rect);
17  			PAINTSTRUCT ps{};
18  			HDC hdc = ::BeginPaint(hwnd, &ps);
19  			::SetTextColor(hdc, _colour);
20  			if (NppDarkMode::isEnabled())
21  			{
22  				::SetBkColor(hdc, NppDarkMode::getDarkerBackgroundColor());
23  			}
24  			LOGFONT lf{ NppParameters::getDefaultGUIFont() };
25  			HFONT hf = ::CreateFontIndirect(&lf);
26  			HANDLE hOld = SelectObject(hdc, hf);
27  			TCHAR text[MAX_PATH]{};
28  			::GetWindowText(hwnd, text, MAX_PATH);
29  			::DrawText(hdc, text, -1, &rect, DT_LEFT);
30  			::DeleteObject(::SelectObject(hdc, hOld));
31  			::EndPaint(hwnd, &ps);
32  			return TRUE;
33  		}
34  	}
35  	return ::CallWindowProc(_oldProc, hwnd, Message, wParam, lParam);
36  }
37  void WordStyleDlg::updateGlobalOverrideCtrls()
38  {
39  	const NppGUI & nppGUI = (NppParameters::getInstance()).getNppGUI();
40  	::SendDlgItemMessage(_hSelf, IDC_GLOBAL_FG_CHECK, BM_SETCHECK, nppGUI._globalOverride.enableFg, 0);
41  	::SendDlgItemMessage(_hSelf, IDC_GLOBAL_BG_CHECK, BM_SETCHECK, nppGUI._globalOverride.enableBg, 0);
42  	::SendDlgItemMessage(_hSelf, IDC_GLOBAL_FONT_CHECK, BM_SETCHECK, nppGUI._globalOverride.enableFont, 0);
43  	::SendDlgItemMessage(_hSelf, IDC_GLOBAL_FONTSIZE_CHECK, BM_SETCHECK, nppGUI._globalOverride.enableFontSize, 0);
44  	::SendDlgItemMessage(_hSelf, IDC_GLOBAL_BOLD_CHECK, BM_SETCHECK, nppGUI._globalOverride.enableBold, 0);
45  	::SendDlgItemMessage(_hSelf, IDC_GLOBAL_ITALIC_CHECK, BM_SETCHECK, nppGUI._globalOverride.enableItalic, 0);
46  	::SendDlgItemMessage(_hSelf, IDC_GLOBAL_UNDERLINE_CHECK, BM_SETCHECK, nppGUI._globalOverride.enableUnderLine, 0);
47  }
48  intptr_t CALLBACK WordStyleDlg::run_dlgProc(UINT Message, WPARAM wParam, LPARAM lParam)
49  {
50  	switch (Message)
51  	{
52  		case WM_INITDIALOG :
53  		{
54  			NppParameters& nppParamInst = NppParameters::getInstance();
55  			_hCheckBold = ::GetDlgItem(_hSelf, IDC_BOLD_CHECK);
56  			_hCheckItalic = ::GetDlgItem(_hSelf, IDC_ITALIC_CHECK);
57  			_hCheckUnderline = ::GetDlgItem(_hSelf, IDC_UNDERLINE_CHECK);
58  			_hFontNameCombo = ::GetDlgItem(_hSelf, IDC_FONT_COMBO);
59  			_hFontSizeCombo = ::GetDlgItem(_hSelf, IDC_FONTSIZE_COMBO);
60  			_hSwitch2ThemeCombo = ::GetDlgItem(_hSelf, IDC_SWITCH2THEME_COMBO);
61  			_hFgColourStaticText = ::GetDlgItem(_hSelf, IDC_FG_STATIC);
62  			_hBgColourStaticText = ::GetDlgItem(_hSelf, IDC_BG_STATIC);
63  			_hFontNameStaticText = ::GetDlgItem(_hSelf, IDC_FONTNAME_STATIC);
64  			_hFontSizeStaticText = ::GetDlgItem(_hSelf, IDC_FONTSIZE_STATIC);
65  			_hStyleInfoStaticText = ::GetDlgItem(_hSelf, IDC_STYLEDESCRIPTION_STATIC);
66  			_colourHooker.setColour(RGB(0xFF, 0x00, 0x00));
67  			_colourHooker.hookOn(_hStyleInfoStaticText);
68  			_currentThemeIndex = -1;
69  			int defaultThemeIndex = 0;
70  			ThemeSwitcher & themeSwitcher = nppParamInst.getThemeSwitcher();
71  			for (size_t i = 0 ; i < themeSwitcher.size() ; ++i)
72  			{
73  				pair<generic_string, generic_string> & themeInfo = themeSwitcher.getElementFromIndex(i);
74  				int j = static_cast<int32_t>(::SendMessage(_hSwitch2ThemeCombo, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(themeInfo.first.c_str())));
75  				if (! themeInfo.second.compare( nppParamInst.getNppGUI()._themeName ) )
76  				{
77  					_currentThemeIndex = j;
78  					_themeName.assign(themeInfo.second);
79  				}
80  				if (! themeInfo.first.compare(TEXT("Default")) )
81  				{
82  					defaultThemeIndex = j;
83  				}
84  			}
85  			if (_currentThemeIndex == -1)
86  			{
87  				_currentThemeIndex = defaultThemeIndex;
88  			}
89  			::SendMessage(_hSwitch2ThemeCombo, CB_SETCURSEL, _currentThemeIndex, 0);
90  			for (size_t i = 0 ; i < sizeof(fontSizeStrs)/(3*sizeof(TCHAR)) ; ++i)
91  				::SendMessage(_hFontSizeCombo, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(fontSizeStrs[i]));
92  			const std::vector<generic_string> & fontlist = (NppParameters::getInstance()).getFontList();
93  			for (size_t i = 0, len = fontlist.size() ; i < len ; ++i)
94  			{
95  				auto j = ::SendMessage(_hFontNameCombo, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(fontlist[i].c_str()));
96  				::SendMessage(_hFontNameCombo, CB_SETITEMDATA, j, reinterpret_cast<LPARAM>(fontlist[i].c_str()));
97  			}
98  			_pFgColour = new ColourPicker;
99  			_pBgColour = new ColourPicker;
100  			_pFgColour->init(_hInst, _hSelf);
101  			_pBgColour->init(_hInst, _hSelf);
102  			int cpDynamicalWidth = NppParameters::getInstance()._dpiManager.scaleX(25);
103  			int cpDynamicalHeight = NppParameters::getInstance()._dpiManager.scaleY(25);
104  			move2CtrlRight(IDC_FG_STATIC, _pFgColour->getHSelf(), cpDynamicalWidth, cpDynamicalHeight);
105  			move2CtrlRight(IDC_BG_STATIC, _pBgColour->getHSelf(), cpDynamicalWidth, cpDynamicalHeight);
106  			_pFgColour->display();
107  			_pBgColour->display();
108  			::EnableWindow(::GetDlgItem(_hSelf, IDOK), _isDirty);
109  			::EnableWindow(::GetDlgItem(_hSelf, IDC_SAVECLOSE_BUTTON), FALSE&bsol;*!_isSync*/);
110  			loadLangListFromNppParam();
111  			updateGlobalOverrideCtrls();
112  			setVisualFromStyleList();
113  			_goToSettings.init(_hInst, _hSelf);
114  			_goToSettings.create(::GetDlgItem(_hSelf, IDC_GLOBAL_GOTOSETTINGS_LINK), TEXT(""));
115  			std::pair<intptr_t, intptr_t> pageAndCtrlID = goToPreferencesSettings();
116  			_goToSettings.display(pageAndCtrlID.first != -1);
117  			NppDarkMode::autoSubclassAndThemeChildControls(_hSelf);
118  			goToCenter(SWP_SHOWWINDOW | SWP_NOSIZE);
119  			return TRUE;
120  		}
121  		case WM_CTLCOLOREDIT:
122  		{
123  			auto hdcStatic = reinterpret_cast<HDC>(wParam);
124  			auto dlgCtrlID = ::GetDlgCtrlID(reinterpret_cast<HWND>(lParam));
125  			if (dlgCtrlID == IDC_USER_EXT_EDIT || dlgCtrlID == IDC_USER_KEYWORDS_EDIT)
126  			{
127  				return NppDarkMode::onCtlColorSofter(hdcStatic);
128  			}
129  			return NppDarkMode::onCtlColor(hdcStatic);
130  		}
131  		case WM_CTLCOLORLISTBOX:
132  		{
133  			return NppDarkMode::onCtlColorListbox(wParam, lParam);
134  		}
135  		case WM_CTLCOLORDLG:
136  		{
137  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
138  		}
139  		case WM_CTLCOLORSTATIC:
140  		{
141  			auto hdcStatic = reinterpret_cast<HDC>(wParam);
142  			auto dlgCtrlID = ::GetDlgCtrlID(reinterpret_cast<HWND>(lParam));
143  			bool isStaticText = (dlgCtrlID == IDC_FG_STATIC ||
144  				dlgCtrlID == IDC_BG_STATIC ||
145  				dlgCtrlID == IDC_FONTNAME_STATIC ||
146  				dlgCtrlID == IDC_FONTSIZE_STATIC);
147  			if (isStaticText)
148  			{
149  				Style& style = getCurrentStyler();
150  				bool isTextEnabled = false;
151  				if (dlgCtrlID == IDC_FG_STATIC)
152  				{
153  					isTextEnabled = HIBYTE(HIWORD(style._fgColor)) != 0xFF;
154  					if (style._styleDesc == TEXT("Selected text colour"))
155  					{
156  						isTextEnabled = NppParameters::getInstance().isSelectFgColorEnabled();
157  					}
158  				}
159  				else if (dlgCtrlID == IDC_BG_STATIC)
160  				{
161  					isTextEnabled = HIBYTE(HIWORD(style._bgColor)) != 0xFF;
162  				}
163  				else if (dlgCtrlID == IDC_FONTNAME_STATIC)
164  				{
165  					isTextEnabled = !style._fontName.empty();
166  				}
167  				else if (dlgCtrlID == IDC_FONTSIZE_STATIC)
168  				{
169  					isTextEnabled = style._fontSize != STYLE_NOT_USED && style._fontSize < 100; 
170  				}
171  				return NppDarkMode::onCtlColorDarkerBGStaticText(hdcStatic, isTextEnabled);
172  			}
173  			if (dlgCtrlID == IDC_DEF_EXT_EDIT || dlgCtrlID == IDC_DEF_KEYWORDS_EDIT)
174  			{
175  				return NppDarkMode::onCtlColor(hdcStatic);
176  			}
177  			return NppDarkMode::onCtlColorDarker(hdcStatic);
178  		}
179  		case WM_PRINTCLIENT:
180  		{
181  			if (NppDarkMode::isEnabled())
182  			{
183  				return TRUE;
184  			}
185  			break;
186  		}
187  		case NPPM_INTERNAL_REFRESHDARKMODE:
188  		{
189  			NppDarkMode::autoThemeChildControls(_hSelf);
190  			::SendMessage(_pFgColour->getHSelf(), NPPM_INTERNAL_REFRESHDARKMODE, 0, 0);
191  			::SendMessage(_pBgColour->getHSelf(), NPPM_INTERNAL_REFRESHDARKMODE, 0, 0);
192  			return TRUE;
193  		}
194  		case WM_DESTROY:
195  		{
196  			_pFgColour->destroy();
197  			_pBgColour->destroy();
198  			delete _pFgColour;
199  			delete _pBgColour;
200  			return TRUE;
201  		}
202  		case WM_HSCROLL :
203  		{
204  			if (reinterpret_cast<HWND>(lParam) == ::GetDlgItem(_hSelf, IDC_SC_PERCENTAGE_SLIDER))
205  			{
206  				int percent = static_cast<int32_t>(::SendDlgItemMessage(_hSelf, IDC_SC_PERCENTAGE_SLIDER, TBM_GETPOS, 0, 0));
207  				(NppParameters::getInstance()).SetTransparent(_hSelf, percent);
208  			}
209  			return TRUE;
210  		}
211  		case WM_COMMAND :
212  		{
213  			if (HIWORD(wParam) == EN_CHANGE)
214  			{
215  				int editID = LOWORD(wParam);
216  				if (editID == IDC_USER_KEYWORDS_EDIT)
217  				{
218  					updateUserKeywords();
219  					notifyDataModified();
220  					apply();
221  				}
222  				else if (editID == IDC_USER_EXT_EDIT)
223  				{
224  					updateExtension();
225  					notifyDataModified();
226  					apply();
227  				}
228  			}
229  			else
230  			{
231  				switch (wParam)
232  				{
233  					case IDC_BOLD_CHECK :
234  						updateFontStyleStatus(BOLD_STATUS);
235  						notifyDataModified();
236  						apply();
237  						break;
238  					case IDC_ITALIC_CHECK :
239  						updateFontStyleStatus(ITALIC_STATUS);
240  						notifyDataModified();
241  						apply();
242  						break;
243  					case IDC_UNDERLINE_CHECK :
244  						updateFontStyleStatus(UNDERLINE_STATUS);
245  						notifyDataModified();
246  						apply();
247  						break;
248  					case IDC_GLOBAL_GOTOSETTINGS_LINK :
249  					{
250  						std::pair<intptr_t, intptr_t> pageAndCtrlID = goToPreferencesSettings();
251  						if (pageAndCtrlID.first != -1)
252  							::SendMessage(_hParent, NPPM_INTERNAL_LAUNCHPREFERENCES, pageAndCtrlID.first, pageAndCtrlID.second);
253  					}
254  					break;
255  					case IDCANCEL :
256  						if (_isDirty)
257  						{
258  							NppParameters& nppParamInst = NppParameters::getInstance();
259  							if (_restoreInvalid)
260  							{
261  								generic_string str(nppParamInst.getNppGUI()._themeName);
262  								nppParamInst.reloadStylers(str.c_str());
263  								loadLangListFromNppParam();
264  							}
265  							LexerStylerArray & lsArray = nppParamInst.getLStylerArray();
266  							StyleArray & globalStyles = nppParamInst.getGlobalStylers();
267  							if (_restoreInvalid)
268  							{
269  								_lsArray = _styles2restored = lsArray;
270  								_globalStyles = _gstyles2restored = globalStyles;
271  							}
272  							else
273  							{
274  								globalStyles = _globalStyles = _gstyles2restored;
275  								lsArray = _lsArray = _styles2restored;
276  							}
277  							restoreGlobalOverrideValues();
278  							_restoreInvalid = false;
279  							_isDirty = false;
280  							_isThemeDirty = false;
281  							setVisualFromStyleList();
282  							::SendMessage(_hSwitch2ThemeCombo, CB_SETCURSEL, _currentThemeIndex, 0);
283  							::SendMessage(_hParent, WM_UPDATESCINTILLAS, 0, 0);
284  							::SendMessage(_hParent, WM_UPDATEMAINMENUBITMAPS, 0, 0);
285  						}
286  						::EnableWindow(::GetDlgItem(_hSelf, IDC_SAVECLOSE_BUTTON), FALSE&bsol;*!_isSync*/);
287  						display(false);
288  						return TRUE;
289  					case IDC_SAVECLOSE_BUTTON :
290  					{
291  						if (_isDirty)
292  						{
293  							LexerStylerArray & lsa = (NppParameters::getInstance()).getLStylerArray();
294  							StyleArray & globalStyles = (NppParameters::getInstance()).getGlobalStylers();
295  							_lsArray = lsa;
296  							_globalStyles = globalStyles;
297  							updateThemeName(_themeName);
298  							_restoreInvalid = false;
299  							_currentThemeIndex = static_cast<int32_t>(::SendMessage(_hSwitch2ThemeCombo, CB_GETCURSEL, 0, 0));
300  							::EnableWindow(::GetDlgItem(_hSelf, IDOK), FALSE);
301  							_isDirty = false;
302  						}
303  						_isThemeDirty = false;
304  						auto newSavedFilePath = (NppParameters::getInstance()).writeStyles(_lsArray, _globalStyles);
305  						if (!newSavedFilePath.empty())
306  							updateThemeName(newSavedFilePath);
307  						::EnableWindow(::GetDlgItem(_hSelf, IDC_SAVECLOSE_BUTTON), FALSE);
308  						display(false);
309  						::SendMessage(_hParent, WM_UPDATESCINTILLAS, 0, 0);
310  						::SendMessage(_hParent, WM_UPDATEMAINMENUBITMAPS, 0, 0);
311  						const TCHAR* fn = ::PathFindFileName(_themeName.c_str());
312  						NppDarkMode::setThemeName((!NppDarkMode::isEnabled() && lstrcmp(fn, L"stylers.xml") == 0) ? L"" : fn);
313  						return TRUE;
314  					}
315  					case IDC_SC_TRANSPARENT_CHECK :
316  					{
317  						bool isChecked = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_SC_TRANSPARENT_CHECK, BM_GETCHECK, 0, 0));
318  						if (isChecked)
319  						{
320  							int percent = static_cast<int32_t>(::SendDlgItemMessage(_hSelf, IDC_SC_PERCENTAGE_SLIDER, TBM_GETPOS, 0, 0));
321  							(NppParameters::getInstance()).SetTransparent(_hSelf, percent);
322  						}
323  						else
324  							(NppParameters::getInstance()).removeTransparent(_hSelf);
325  						::EnableWindow(::GetDlgItem(_hSelf, IDC_SC_PERCENTAGE_SLIDER), isChecked);
326  						return TRUE;
327  					}
328  					case IDC_GLOBAL_FG_CHECK :
329  					{
330  						GlobalOverride & glo = (NppParameters::getInstance()).getGlobalOverrideStyle();
331  						glo.enableFg = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, static_cast<int32_t>(wParam), BM_GETCHECK, 0, 0));
332  						notifyDataModified();
333  						apply();
334  						return TRUE;
335  					}
336  					case  IDC_GLOBAL_BG_CHECK:
337  					{
338  						GlobalOverride & glo = (NppParameters::getInstance()).getGlobalOverrideStyle();
339  						glo.enableBg = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, static_cast<int32_t>(wParam), BM_GETCHECK, 0, 0));
340  						notifyDataModified();
341  						apply();
342  						return TRUE;
343  					}
344  					case IDC_GLOBAL_FONT_CHECK :
345  					{
346  						GlobalOverride & glo = (NppParameters::getInstance()).getGlobalOverrideStyle();
347  						glo.enableFont = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, static_cast<int32_t>(wParam), BM_GETCHECK, 0, 0));
348  						notifyDataModified();
349  						apply();
350  						return TRUE;
351  					}
352  					case IDC_GLOBAL_FONTSIZE_CHECK :
353  					{
354  						GlobalOverride & glo = (NppParameters::getInstance()).getGlobalOverrideStyle();
355  						glo.enableFontSize = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, static_cast<int32_t>(wParam), BM_GETCHECK, 0, 0));
356  						notifyDataModified();
357  						apply();
358  						return TRUE;
359  					}
360  					case IDC_GLOBAL_BOLD_CHECK :
361  					{
362  						GlobalOverride & glo = (NppParameters::getInstance()).getGlobalOverrideStyle();
363  						glo.enableBold = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, static_cast<int32_t>(wParam), BM_GETCHECK, 0, 0));
364  						notifyDataModified();
365  						apply();
366  						return TRUE;
367  					}
368  					case IDC_GLOBAL_ITALIC_CHECK :
369  					{
370  						GlobalOverride & glo = (NppParameters::getInstance()).getGlobalOverrideStyle();
371  						glo.enableItalic = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, static_cast<int32_t>(wParam), BM_GETCHECK, 0, 0));
372  						notifyDataModified();
373  						apply();
374  						return TRUE;
375  					}
376  					case IDC_GLOBAL_UNDERLINE_CHECK :
377  					{
378  						GlobalOverride & glo = (NppParameters::getInstance()).getGlobalOverrideStyle();
379  						glo.enableUnderLine = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, static_cast<int32_t>(wParam), BM_GETCHECK, 0, 0));
380  						notifyDataModified();
381  						apply();
382  						return TRUE;
383  					}
384  					default:
385  						switch (HIWORD(wParam))
386  						{
387  							case CBN_SELCHANGE : 
388  							{
389  								switch (LOWORD(wParam))
390  								{
391  									case IDC_FONT_COMBO :
392  										updateFontName();
393  										notifyDataModified();
394  										apply();
395  										break;
396  									case IDC_FONTSIZE_COMBO :
397  										updateFontSize();
398  										notifyDataModified();
399  										apply();
400  										break;
401  									case IDC_LANGUAGES_LIST :
402  									{
403  										int i = static_cast<int32_t>(::SendDlgItemMessage(_hSelf, LOWORD(wParam), LB_GETCURSEL, 0, 0));
404  										if (i != LB_ERR)
405  										{
406  											bool prevThemeState = _isThemeDirty;
407  											setStyleListFromLexer(i);
408  											_isThemeDirty = prevThemeState;
409  										}
410  										break;
411  									}
412  									case IDC_STYLES_LIST :
413  										setVisualFromStyleList();
414  										break;
415  									case IDC_SWITCH2THEME_COMBO :
416  										applyCurrentSelectedThemeAndUpdateUI();
417  										break;
418  								}
419  								return TRUE;
420  							}
421  							case CPN_COLOURPICKED:
422  							{
423  								if (reinterpret_cast<HWND>(lParam) == _pFgColour->getHSelf())
424  								{
425  									updateColour(C_FOREGROUND);
426  									notifyDataModified();
427  									int tabColourIndex;
428  									if ((tabColourIndex = whichTabColourIndex()) != -1)
429  									{
430  										TabBarPlus::setColour(_pFgColour->getColour(), (TabBarPlus::tabColourIndex)tabColourIndex);
431  									}
432  									else if (isDocumentMapStyle())
433  									{
434  										ViewZoneDlg::setColour(_pFgColour->getColour(), ViewZoneDlg::ViewZoneColorIndex::focus);
435  									}
436  									apply();
437  									return TRUE;
438  								}
439  								else if (reinterpret_cast<HWND>(lParam) == _pBgColour->getHSelf())
440  								{
441  									updateColour(C_BACKGROUND);
442  									notifyDataModified();
443  									int tabColourIndex;
444  									if ((tabColourIndex = whichTabColourIndex()) != -1)
445  									{
446  										tabColourIndex = (tabColourIndex == TabBarPlus::inactiveText ? TabBarPlus::inactiveBg : tabColourIndex);
447  										TabBarPlus::setColour(_pBgColour->getColour(), (TabBarPlus::tabColourIndex)tabColourIndex);
448  									}
449  									else if (isDocumentMapStyle())
450  									{
451  										ViewZoneDlg::setColour(_pBgColour->getColour(), ViewZoneDlg::ViewZoneColorIndex::frost);
452  									}
453  									apply();
454  									return TRUE;
455  								}
456  								else
457  									return FALSE;
458  							}
459  							default :
460  							{
461  								return FALSE;
462  							}
463  						}
464  				}
465  			}
466  			break;
467  		}
468  		default :
469  			return FALSE;
470  	}
471  	return FALSE;
472  }
473  void WordStyleDlg::move2CtrlRight(int ctrlID, HWND handle2Move, int handle2MoveWidth, int handle2MoveHeight)
474  {
475  	POINT p{};
476  	RECT rc{};
477  	::GetWindowRect(::GetDlgItem(_hSelf, ctrlID), &rc);
478  	p.x = rc.right + NppParameters::getInstance()._dpiManager.scaleX(5);
479  	p.y = rc.top + ((rc.bottom - rc.top) / 2) - handle2MoveHeight / 2;
480  	::ScreenToClient(_hSelf, &p);
481  	::MoveWindow(handle2Move, p.x, p.y, handle2MoveWidth, handle2MoveHeight, TRUE);
482  }
483  void WordStyleDlg::loadLangListFromNppParam()
484  {
485  	NppParameters& nppParamInst = NppParameters::getInstance();
486  	_lsArray = nppParamInst.getLStylerArray();
487  	_globalStyles = nppParamInst.getGlobalStylers();
488  	::SendDlgItemMessage(_hSelf, IDC_LANGUAGES_LIST, LB_RESETCONTENT, 0, 0);
489  	::SendDlgItemMessage(_hSelf, IDC_LANGUAGES_LIST, LB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("Global Styles")));
490  	for (size_t i = 0, nb = _lsArray.getNbLexer() ; i < nb ; ++i)
491  	{
492  		::SendDlgItemMessage(_hSelf, IDC_LANGUAGES_LIST, LB_ADDSTRING, 0, reinterpret_cast<LPARAM>(_lsArray.getLexerDescFromIndex(i)));
493  	}
494  	const int index2Begin = 0;
495  	::SendDlgItemMessage(_hSelf, IDC_LANGUAGES_LIST, LB_SETCURSEL, index2Begin, 0);
496  	setStyleListFromLexer(index2Begin);
497  }
498  void WordStyleDlg::updateThemeName(const generic_string& themeName)
499  {
500  	NppParameters& nppParam = NppParameters::getInstance();
501  	NppGUI & nppGUI = (NppGUI & )nppParam.getNppGUI();
502  	nppGUI._themeName.assign( themeName );
503  }
504  bool WordStyleDlg::getStyleName(TCHAR *styleName, const size_t styleNameLen)
505  {
506  	auto i = ::SendDlgItemMessage(_hSelf, IDC_STYLES_LIST, LB_GETCURSEL, 0, 0);
507  	if (i == LB_ERR)
508  		return false;
509  	auto lbTextLen = ::SendDlgItemMessage(_hSelf, IDC_STYLES_LIST, LB_GETTEXTLEN, i, 0);
510  	if (static_cast<size_t>(lbTextLen) > styleNameLen)
511  		return false;
512  	::SendDlgItemMessage(_hSelf, IDC_STYLES_LIST, LB_GETTEXT, i, reinterpret_cast<LPARAM>(styleName));
513  	return true;
514  }
515  int WordStyleDlg::whichTabColourIndex()
516  {
517  	constexpr size_t styleNameLen = 128;
518  	TCHAR styleName[styleNameLen + 1] = { '\0' };
519  	if (!WordStyleDlg::getStyleName(styleName, styleNameLen))
520  	{
521  		return -1;
522  	}
523  	if (lstrcmp(styleName, TABBAR_ACTIVEFOCUSEDINDCATOR) == 0)
524  		return TabBarPlus::activeFocusedTop;
525  	if (lstrcmp(styleName, TABBAR_ACTIVEUNFOCUSEDINDCATOR) == 0)
526  		return TabBarPlus::activeUnfocusedTop;
527  	if (lstrcmp(styleName, TABBAR_ACTIVETEXT) == 0)
528  		return TabBarPlus::activeText;
529  	if (lstrcmp(styleName, TABBAR_INACTIVETEXT) == 0)
530  		return TabBarPlus::inactiveText;
531  	return -1;
532  }
533  bool WordStyleDlg::isDocumentMapStyle()
534  {
535  	constexpr size_t styleNameLen = 128;
536  	TCHAR styleName[styleNameLen + 1] = { '\0' };
537  	return (WordStyleDlg::getStyleName(styleName, styleNameLen) && (lstrcmp(styleName, VIEWZONE_DOCUMENTMAP) == 0));
538  }
539  void WordStyleDlg::updateColour(bool which)
540  {
541  	Style & style = getCurrentStyler();
542  	if (which == C_FOREGROUND)
543  	{
544  		style._fgColor = _pFgColour->getColour();
545  		if (_pFgColour->isEnabled())
546  			style._colorStyle |= COLORSTYLE_FOREGROUND;
547  		else
548  			style._colorStyle &= ~COLORSTYLE_FOREGROUND;
549  	}
550  	else 
551  	{
552  		style._bgColor = _pBgColour->getColour();
553  		if (_pBgColour->isEnabled())
554  			style._colorStyle |= COLORSTYLE_BACKGROUND;
555  		else
556  			style._colorStyle &= ~COLORSTYLE_BACKGROUND;
557  	}
558  }
559  void WordStyleDlg::updateFontSize()
560  {
561  	Style & style = getCurrentStyler();
562  	auto iFontSizeSel = ::SendMessage(_hFontSizeCombo, CB_GETCURSEL, 0, 0);
563  	if (iFontSizeSel != 0)
564  	{
565  		constexpr size_t intStrLen = 3;
566  		TCHAR intStr[intStrLen]{};
567  		auto lbTextLen = ::SendMessage(_hFontSizeCombo, CB_GETLBTEXTLEN, iFontSizeSel, 0);
568  		if (static_cast<size_t>(lbTextLen) >= intStrLen)
569  			return;
570  		::SendMessage(_hFontSizeCombo, CB_GETLBTEXT, iFontSizeSel, reinterpret_cast<LPARAM>(intStr));
571  		if (!intStr[0])
572  			style._fontSize = STYLE_NOT_USED;
573  		else
574  		{
575  			TCHAR *finStr = nullptr;
576  			style._fontSize = wcstol(intStr, &finStr, 10);
577  			if (*finStr != '\0')
578  				style._fontSize = STYLE_NOT_USED;
579  		}
580  	}
581  	else
582  		style._fontSize = 0;
583  }
584  void WordStyleDlg::updateExtension()
585  {
586  	constexpr int NB_MAX = 256;
587  	TCHAR ext[NB_MAX]{};
588  	::SendDlgItemMessage(_hSelf, IDC_USER_EXT_EDIT, WM_GETTEXT, NB_MAX, reinterpret_cast<LPARAM>(ext));
589  	_lsArray.getLexerFromIndex(_currentLexerIndex - 1).setLexerUserExt(ext);
590  }
591  void WordStyleDlg::updateUserKeywords()
592  {
593  	Style & style = getCurrentStyler();
594  	auto len = ::SendDlgItemMessage(_hSelf, IDC_USER_KEYWORDS_EDIT, WM_GETTEXTLENGTH, 0, 0);
595  	len += 1;
596  	TCHAR* kw = new TCHAR[len];
597  	::memset(kw, 0, len * sizeof(TCHAR));
598  	::SendDlgItemMessage(_hSelf, IDC_USER_KEYWORDS_EDIT, WM_GETTEXT, len, reinterpret_cast<LPARAM>(kw));
599  	style._keywords = kw;
600  	delete [] kw;
601  }
602  void WordStyleDlg::updateFontName()
603  {
604  	Style & style = getCurrentStyler();
605  	auto iFontSel = ::SendMessage(_hFontNameCombo, CB_GETCURSEL, 0, 0);
606  	TCHAR *fnStr = (TCHAR *)::SendMessage(_hFontNameCombo, CB_GETITEMDATA, iFontSel, 0);
607  	style._fontName = fnStr;
608  }
609  void WordStyleDlg::updateFontStyleStatus(fontStyleType whitchStyle)
610  {
611  	Style & style = getCurrentStyler();
612  	if (style._fontStyle == STYLE_NOT_USED)
613  		style._fontStyle = FONTSTYLE_NONE;
614  	int fontStyle = FONTSTYLE_UNDERLINE;
615  	HWND hWnd = _hCheckUnderline;
616  	if (whitchStyle == BOLD_STATUS)
617  	{
618  		fontStyle = FONTSTYLE_BOLD;
619  		hWnd = _hCheckBold;
620  	}
621  	if (whitchStyle == ITALIC_STATUS)
622  	{
623  		fontStyle = FONTSTYLE_ITALIC;
624  		hWnd = _hCheckItalic;
625  	}
626  	auto isChecked = ::SendMessage(hWnd, BM_GETCHECK, 0, 0);
627  	if (isChecked != BST_INDETERMINATE)
628  	{
629  		if (isChecked == BST_CHECKED)
630  			style._fontStyle |= fontStyle;
631  		else
632  			style._fontStyle &= ~fontStyle;
633  	}
634  }
635  void WordStyleDlg::switchToTheme()
636  {
637  	auto iSel = ::SendMessage(_hSwitch2ThemeCombo, CB_GETCURSEL, 0, 0);
638  	generic_string prevThemeName(_themeName);
639  	_themeName.clear();
640  	NppParameters& nppParamInst = NppParameters::getInstance();
641  	ThemeSwitcher & themeSwitcher = nppParamInst.getThemeSwitcher();
642  	pair<generic_string, generic_string> & themeInfo = themeSwitcher.getElementFromIndex(iSel);
643  	_themeName = themeInfo.second;
644  	if (_isThemeDirty)
645  	{
646  		TCHAR themeFileName[MAX_PATH]{};
647  		wcscpy_s(themeFileName, prevThemeName.c_str());
648  		PathStripPath(themeFileName);
649  		PathRemoveExtension(themeFileName);
650  		NativeLangSpeaker *pNativeSpeaker = nppParamInst.getNativeLangSpeaker();
651  		int mb_response = pNativeSpeaker->messageBox("SwitchUnsavedThemeWarning",
652  			_hSelf,
653  			TEXT("Unsaved changes are about to be discarded!\nDo you want to save your changes before switching themes?"),
654  			TEXT("$STR_REPLACE$"),
655  			MB_ICONWARNING | MB_YESNO | MB_APPLMODAL | MB_SETFOREGROUND,
656  			0,
657  			themeFileName);
658  		if ( mb_response == IDYES )
659  			(NppParameters::getInstance()).writeStyles(_lsArray, _globalStyles);
660  	}
661  	nppParamInst.reloadStylers(_themeName.c_str());
662  	loadLangListFromNppParam();
663  	_restoreInvalid = true;
664  }
665  void WordStyleDlg::applyCurrentSelectedThemeAndUpdateUI()
666  {
667  	switchToTheme();
668  	setVisualFromStyleList();
669  	notifyDataModified();
670  	_isThemeDirty = false;
671  	apply();
672  }
673  bool WordStyleDlg::selectThemeByName(const TCHAR* themeName)
674  {
675  	LRESULT iTheme = ::SendMessage(_hSwitch2ThemeCombo, CB_FINDSTRING, 1, reinterpret_cast<LPARAM>(themeName));
676  	if (iTheme == CB_ERR)
677  		return false;
678  	::SendMessage(_hSwitch2ThemeCombo, CB_SETCURSEL, iTheme, 0);
679  	applyCurrentSelectedThemeAndUpdateUI();
680  	return true;
681  }
682  bool WordStyleDlg::goToSection(const TCHAR* sectionNames)
683  {
684  	if (!sectionNames || !sectionNames[0])
685  		return false;
686  	std::vector<generic_string> sections = tokenizeString(sectionNames, ':');
687  	if (sections.size() == 0 || sections.size() >= 3)
688  		return false;
689  	auto i = ::SendDlgItemMessage(_hSelf, IDC_LANGUAGES_LIST, LB_FINDSTRING, (WPARAM)-1, (LPARAM)sections[0].c_str());
690  	if (i == LB_ERR)
691  		return false;
692  	::SendDlgItemMessage(_hSelf, IDC_LANGUAGES_LIST, LB_SETCURSEL, i, 0);
693  	setStyleListFromLexer(static_cast<int>(i));
694  	if (sections.size() == 1)
695  		return true;
696  	i = ::SendDlgItemMessage(_hSelf, IDC_STYLES_LIST, LB_FINDSTRING, (WPARAM)-1, (LPARAM)sections[1].c_str());
697  	if (i == LB_ERR)
698  		return false;
699  	::SendDlgItemMessage(_hSelf, IDC_STYLES_LIST, LB_SETCURSEL, i, 0);
700  	setVisualFromStyleList();
701  	getFocus();
702  	return true;
703  }
704  void WordStyleDlg::setStyleListFromLexer(int index)
705  {
706  	_currentLexerIndex = index;
707  	::SendDlgItemMessage(_hSelf, IDC_STYLES_LIST, LB_RESETCONTENT, 0, 0);
708  	if (index)
709  	{
710  		const TCHAR *langName = _lsArray.getLexerNameFromIndex(index - 1);
711  		const TCHAR *ext = NppParameters::getInstance().getLangExtFromName(langName);
712  		const TCHAR *userExt = (_lsArray.getLexerStylerByName(langName))->getLexerUserExt();
713  		::SendDlgItemMessage(_hSelf, IDC_DEF_EXT_EDIT, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(ext));
714  		bool isDirty = _isDirty;
715  		bool isThemeDirty = _isThemeDirty;
716  		::SendDlgItemMessage(_hSelf, IDC_USER_EXT_EDIT, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(userExt));
717  		_isDirty = isDirty;
718  		_isThemeDirty = isThemeDirty;
719  		::EnableWindow(::GetDlgItem(_hSelf, IDC_SAVECLOSE_BUTTON), isDirty || isThemeDirty);
720  	}
721  	::ShowWindow(::GetDlgItem(_hSelf, IDC_DEF_EXT_EDIT), index?SW_SHOW:SW_HIDE);
722  	::ShowWindow(::GetDlgItem(_hSelf, IDC_DEF_EXT_STATIC), index?SW_SHOW:SW_HIDE);
723  	::ShowWindow(::GetDlgItem(_hSelf, IDC_USER_EXT_EDIT), index?SW_SHOW:SW_HIDE);
724  	::ShowWindow(::GetDlgItem(_hSelf, IDC_USER_EXT_STATIC), index?SW_SHOW:SW_HIDE);
725  	::ShowWindow(::GetDlgItem(_hSelf, IDC_PLUSSYMBOL2_STATIC), index?SW_SHOW:SW_HIDE);
726  	StyleArray & lexerStyler = index?_lsArray.getLexerFromIndex(index-1):_globalStyles;
727  	for (const Style & style : lexerStyler)
728  	{
729  		::SendDlgItemMessage(_hSelf, IDC_STYLES_LIST, LB_ADDSTRING, 0, reinterpret_cast<LPARAM>(style._styleDesc.c_str()));
730  	}
731  	::SendDlgItemMessage(_hSelf, IDC_STYLES_LIST, LB_SETCURSEL, 0, 0);
732  	setVisualFromStyleList();
733  }
734  std::pair<intptr_t, intptr_t> WordStyleDlg::goToPreferencesSettings()
735  {
736  	std::pair<intptr_t, intptr_t> result;
737  	result.first = -1;
738  	result.second = -1;
739  	Style& style = getCurrentStyler();
740  	if (style._styleDesc == TEXT("Current line background colour"))
741  	{
742  		result.first = 1;
743  		result.second = IDC_RADIO_CLM_HILITE;
744  	}
745  	else if (style._styleDesc == TEXT("Caret colour"))
746  	{
747  		result.first = 1;
748  		result.second = IDC_WIDTH_COMBO;
749  	}
750  	else if (style._styleDesc == TEXT("Edge colour"))
751  	{
752  		result.first = 3;
753  		result.second = IDC_COLUMNPOS_EDIT;
754  	}
755  	else if (style._styleDesc == TEXT("Line number margin"))
756  	{
757  		result.first = 3;
758  		result.second = IDC_CHECK_LINENUMBERMARGE;
759  	}
760  	else if (style._styleDesc == TEXT("Bookmark margin"))
761  	{
762  		result.first = 3;
763  		result.second = IDC_CHECK_BOOKMARKMARGE;
764  	}
765  	else if (style._styleDesc == TEXT("Change History margin"))
766  	{
767  		result.first = 3;
768  		result.second = IDC_CHECK_CHANGHISTORYMARGE;
769  	}
770  	else if (style._styleDesc == TEXT("Fold") || style._styleDesc == TEXT("Fold active") || style._styleDesc == TEXT("Fold margin"))
771  	{
772  		result.first = 3;
773  		result.second = IDC_RADIO_BOX;
<span onclick='openModal()' class='match'>774  	}
775  	else if (style._styleDesc == TEXT("Smart Highlighting"))
776  	{
777  		result.first = 9;
778  		result.second = IDC_CHECK_ENABLSMARTHILITE;
779  	}
780  	else if (style._styleDesc == TEXT("Tags match highlighting"))
781  	{
782  		result.first = 9;
783  		result.second = IDC_CHECK_ENABLTAGSMATCHHILITE;
784  	}
785  	else if (style._styleDesc == TEXT("Tags attribute"))
786  	{
787  		result.first = 9;
788  		result.second = IDC_CHECK_ENABLTAGATTRHILITE;
789  	}
790  	else if (style._styleDesc == TEXT("Mark Style 1") || style._styleDesc == TEXT("Mark Style 2") || style._styleDesc == TEXT("Mark Style 3")
791  		|| style._styleDesc == TEXT("Mark Style 4") || style._styleDesc == TEXT("Mark Style 5"))
792  	{
793  		result.first = 9;
794  		result.second = IDC_CHECK_MARKALLCASESENSITIVE;
795  	}
796  	else if (style._styleDesc == TEXT("URL hovered"))
797  	{
798  		result.first = 17;
</span>799  		result.second = IDC_CHECK_CLICKABLELINK_ENABLE;
800  	}
801  	else if (style._styleDesc == TEXT("EOL custom color"))
802  	{
803  		result.first = 1;
804  		result.second = IDC_CHECK_WITHCUSTOMCOLOR_CRLF;
805  	}
806  	else if (style._styleDesc == g_npcStyleName)
807  	{
808  		result.first = 1;
809  		result.second = IDC_CHECK_NPC_COLOR;
810  	}
811  	return result;
812  }
813  void WordStyleDlg::setVisualFromStyleList()
814  {
815  	showGlobalOverrideCtrls(false);
816  	Style & style = getCurrentStyler();
817  	if (style._styleDesc == TEXT("Global override"))
818  	{
819  		showGlobalOverrideCtrls(true);
820  	}
821  	std::pair<intptr_t, intptr_t> pageAndCtrlID = goToPreferencesSettings();
822  	_goToSettings.display(pageAndCtrlID.first != -1);
823  	COLORREF c = NppDarkMode::isEnabled() ? NppDarkMode::getLinkTextColor() : RGB(0x00, 0x00, 0xFF);
824  	const size_t strLen = 256;
825  	TCHAR str[strLen + 1] = { '\0' };
826  	str[0] = '\0';
827  	auto i = ::SendDlgItemMessage(_hSelf, IDC_LANGUAGES_LIST, LB_GETCURSEL, 0, 0);
828  	if (i == LB_ERR)
829  		return;
830  	auto lbTextLen = ::SendDlgItemMessage(_hSelf, IDC_LANGUAGES_LIST, LB_GETTEXTLEN, i, 0);
831  	if (static_cast<size_t>(lbTextLen) > strLen)
832  		return;
833  	::SendDlgItemMessage(_hSelf, IDC_LANGUAGES_LIST, LB_GETTEXT, i, reinterpret_cast<LPARAM>(str));
834  	i = ::SendDlgItemMessage(_hSelf, IDC_STYLES_LIST, LB_GETCURSEL, 0, 0);
835  	if (i == LB_ERR)
836  		return;
837  	const size_t styleNameLen = 64;
838  	TCHAR styleName[styleNameLen + 1] = { '\0' };
839  	lbTextLen = ::SendDlgItemMessage(_hSelf, IDC_STYLES_LIST, LB_GETTEXTLEN, i, 0);
840  	if (static_cast<size_t>(lbTextLen) > styleNameLen)
841  		return;
842  	::SendDlgItemMessage(_hSelf, IDC_STYLES_LIST, LB_GETTEXT, i, reinterpret_cast<LPARAM>(styleName));
843  	wcscat_s(str, TEXT(" : "));
844  	wcscat_s(str, styleName);
845  	wcscat_s(str, TEXT("          "));
846  	_colourHooker.setColour(c);
847  	::SetWindowText(_hStyleInfoStaticText, str);
848  	bool isEnable = false;
849  	if (HIBYTE(HIWORD(style._fgColor)) != 0xFF)
850  	{
851  		_pFgColour->setColour(style._fgColor);
852  		_pFgColour->setEnabled((style._colorStyle & COLORSTYLE_FOREGROUND) != 0);
853  		isEnable = true;
854  	}
855  	if (style._styleDesc == TEXT("Selected text colour"))
856  	{
857  		isEnable = false; 
858  		if (NppParameters::getInstance().isSelectFgColorEnabled())
859  			isEnable = true;
860  	}
861  	::EnableWindow(_pFgColour->getHSelf(), isEnable);
862  	InvalidateRect(_hFgColourStaticText, NULL, FALSE);
863  	isEnable = false;
864  	if (HIBYTE(HIWORD(style._bgColor)) != 0xFF)
865  	{
866  		_pBgColour->setColour(style._bgColor);
867  		_pBgColour->setEnabled((style._colorStyle & COLORSTYLE_BACKGROUND) != 0);
868  		isEnable = true;
869  	}
870  	::EnableWindow(_pBgColour->getHSelf(), isEnable);
871  	InvalidateRect(_hBgColourStaticText, NULL, FALSE);
872  	LRESULT iFontName = 0;
873  	if (!style._fontName.empty())
874  	{
875  		iFontName = ::SendMessage(_hFontNameCombo, CB_FINDSTRING, 1, reinterpret_cast<LPARAM>(style._fontName.c_str()));
876  		if (iFontName == CB_ERR)
877  			iFontName = 0;
878  	}
879  	::SendMessage(_hFontNameCombo, CB_SETCURSEL, iFontName, 0);
880  	::EnableWindow(_hFontNameCombo, style._isFontEnabled);
881  	InvalidateRect(_hFontNameStaticText, NULL, FALSE);
882  	constexpr size_t intStrLen = 3;
883  	TCHAR intStr[intStrLen]{};
884  	LRESULT iFontSize = 0;
885  	if (style._fontSize != STYLE_NOT_USED && style._fontSize < 100) 
886  	{
887  		wsprintf(intStr, TEXT("%d"), style._fontSize);
888  		iFontSize = ::SendMessage(_hFontSizeCombo, CB_FINDSTRING, 1, reinterpret_cast<LPARAM>(intStr));
889  	}
890  	::SendMessage(_hFontSizeCombo, CB_SETCURSEL, iFontSize, 0);
891  	::EnableWindow(_hFontSizeCombo, style._isFontEnabled);
892  	InvalidateRect(_hFontSizeStaticText, NULL, FALSE);
893  	if (style._fontStyle != STYLE_NOT_USED)
894  	{
895  		int isBold = (style._fontStyle & FONTSTYLE_BOLD)?BST_CHECKED:BST_UNCHECKED;
896  		int isItalic = (style._fontStyle & FONTSTYLE_ITALIC)?BST_CHECKED:BST_UNCHECKED;
897  		int isUnderline = (style._fontStyle & FONTSTYLE_UNDERLINE)?BST_CHECKED:BST_UNCHECKED;
898  		::SendMessage(_hCheckBold, BM_SETCHECK, isBold, 0);
899  		::SendMessage(_hCheckItalic, BM_SETCHECK, isItalic, 0);
900  		::SendMessage(_hCheckUnderline, BM_SETCHECK, isUnderline, 0);
901  	}
902  	else 
903  	{
904  		::SendMessage(_hCheckBold, BM_SETCHECK, BST_UNCHECKED, 0);
905  		::SendMessage(_hCheckItalic, BM_SETCHECK, BST_UNCHECKED, 0);
906  		::SendMessage(_hCheckUnderline, BM_SETCHECK, BST_UNCHECKED, 0);
907  	}
908  	enableFontStyle(style._isFontEnabled);
909  	bool shouldBeDisplayed = style._keywordClass != STYLE_NOT_USED;
910  	if (shouldBeDisplayed)
911  	{
912  		LexerStyler & lexerStyler = _lsArray.getLexerFromIndex(_currentLexerIndex - 1);
913  		NppParameters& nppParams = NppParameters::getInstance();
914  		LangType lType = nppParams.getLangIDFromStr(lexerStyler.getLexerName());
915  		if (lType == L_TEXT)
916  		{
917  			generic_string lexerNameStr = lexerStyler.getLexerName();
918  			lexerNameStr += TEXT(" is not defined in NppParameters::getLangIDFromStr()");
919  				printStr(lexerNameStr.c_str());
920  		}
921  		const TCHAR *kws = nppParams.getWordList(lType, style._keywordClass);
922  		if (!kws)
923  			kws = TEXT("");
924  		::SendDlgItemMessage(_hSelf, IDC_DEF_KEYWORDS_EDIT, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(kws));
925  		const TCHAR *ckwStr = style._keywords.c_str();
926  		::SendDlgItemMessage(_hSelf, IDC_USER_KEYWORDS_EDIT, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(ckwStr));
927  	}
928  	int showOption = shouldBeDisplayed?SW_SHOW:SW_HIDE;
929  	::ShowWindow(::GetDlgItem(_hSelf, IDC_DEF_KEYWORDS_EDIT), showOption);
930  	::ShowWindow(::GetDlgItem(_hSelf, IDC_USER_KEYWORDS_EDIT),showOption);
931  	::ShowWindow(::GetDlgItem(_hSelf, IDC_DEF_KEYWORDS_STATIC), showOption);
932  	::ShowWindow(::GetDlgItem(_hSelf, IDC_USER_KEYWORDS_STATIC),showOption);
933  	::ShowWindow(::GetDlgItem(_hSelf, IDC_PLUSSYMBOL_STATIC),showOption);
934  	redraw();
935  }
936  void WordStyleDlg::create(int dialogID, bool isRTL, bool msgDestParent)
937  {
938  	StaticDialog::create(dialogID, isRTL, msgDestParent);
939  	if ((NppParameters::getInstance()).isTransparentAvailable())
940  	{
941  		::ShowWindow(::GetDlgItem(_hSelf, IDC_SC_TRANSPARENT_CHECK), SW_SHOW);
942  		::ShowWindow(::GetDlgItem(_hSelf, IDC_SC_PERCENTAGE_SLIDER), SW_SHOW);
943  		::SendDlgItemMessage(_hSelf, IDC_SC_PERCENTAGE_SLIDER, TBM_SETRANGE, FALSE, MAKELONG(20, 200));
944  		::SendDlgItemMessage(_hSelf, IDC_SC_PERCENTAGE_SLIDER, TBM_SETPOS, TRUE, 150);
945  		if (!(BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_SC_PERCENTAGE_SLIDER, BM_GETCHECK, 0, 0)))
946  			::EnableWindow(::GetDlgItem(_hSelf, IDC_SC_PERCENTAGE_SLIDER), FALSE);
947  	}
948  }
949  void WordStyleDlg::apply()
950  {
951  	LexerStylerArray & lsa = (NppParameters::getInstance()).getLStylerArray();
952  	StyleArray & globalStyles = (NppParameters::getInstance()).getGlobalStylers();
953  	lsa = _lsArray;
954  	globalStyles = _globalStyles;
955  	::EnableWindow(::GetDlgItem(_hSelf, IDOK), FALSE);
956  	::SendMessage(_hParent, WM_UPDATESCINTILLAS, 0, 0);
957  	::SendMessage(_hParent, WM_UPDATEMAINMENUBITMAPS, 0, 0);
958  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-ss.cpp</h3>
            <pre><code>1  TStr& TSs::At(const int& X, const int& Y){
2    if (Y>=CellStrVV.Len()){CellStrVV.Reserve(Y+1, Y+1);}
3    if (X>=CellStrVV[Y]->Len()){CellStrVV[Y]->V.Reserve(X+1, X+1);}
4    return CellStrVV[Y]->V[X];
5  }
6  void TSs::PutVal(const int& X, const int& Y, const TStr& Str){
7    if (Y>=CellStrVV.Len()){CellStrVV.Reserve(Y+1, Y+1);}
8    if (X>=CellStrVV[Y]->Len()){CellStrVV[Y]->V.Reserve(X+1, X+1);}
9    CellStrVV[Y]->V[X]=Str;
10  }
11  TStr TSs::GetVal(const int& X, const int& Y) const {
12    if ((0<=Y)&&(Y<CellStrVV.Len())){
13      if ((0<=X)&&(X<CellStrVV[Y]->Len())){
14        return CellStrVV[Y]->V[X];
15      } else {
16        return TStr::GetNullStr();
17      }
18    } else {
19      return TStr::GetNullStr();
20    }
21  }
22  int TSs::GetXLen() const {
23    if (CellStrVV.Len()==0){
24      return 0;
25    } else {
26      int MxXLen=CellStrVV[0]->Len();
27      for (int Y=1; Y<CellStrVV.Len(); Y++){
28        MxXLen=TInt::GetMx(MxXLen, CellStrVV[Y]->Len());}
29      return MxXLen;
30    }
31  }
32  int TSs::GetXLen(const int& Y) const {
33    if ((0<=Y)&&(Y<CellStrVV.Len())){
34      return CellStrVV[Y]->Len();
35    } else {
36      return 0;
37    }
38  }
39  int TSs::GetYLen() const {
40    return CellStrVV.Len();
41  }
42  int TSs::SearchX(const int& Y, const TStr& Str) const {
43    return CellStrVV[Y]->V.SearchForw(Str);
44  }
45  int TSs::SearchY(const int& X, const TStr& Str) const {
46    int YLen=GetYLen();
47    for (int Y=0; Y<YLen; Y++){
48       if (Str==GetVal(X, Y)){return Y;}}
49    return -1;
50  }
51  void TSs::DelX(const int& X){
52    int YLen=GetYLen();
53    for (int Y=0; Y<YLen; Y++){
54      CellStrVV[Y]->V.Del(X);
55    }
56  }
57  void TSs::DelY(const int& Y){
58    CellStrVV.Del(Y);
59  }
60  int TSs::GetFldX(const TStr& FldNm, const TStr& NewFldNm, const int& Y) const {
61    if (GetYLen()>Y){
62      int XLen=GetXLen(Y);
63      for (int X=0; X<XLen; X++){
64        if (GetVal(X, Y).GetTrunc()==FldNm){
65          if (!NewFldNm.Empty()){GetVal(X, Y)=NewFldNm;}
66          return X;
67        }
68      }
69      return -1;
70    } else {
71      return -1;
72    }
73  }
74  int TSs::GetFldY(const TStr& FldNm, const TStr& NewFldNm, const int& X) const {
75    for (int Y=0; Y<GetYLen(); Y++){
76      if (GetXLen(Y)>X){
77        if (GetVal(X, Y).GetTrunc()==FldNm){
78          if (!NewFldNm.Empty()){GetVal(X, Y)=NewFldNm;}
79          return Y;
80        }
81      }
82    }
83    return -1;
84  }
85  PSs TSs::LoadTxt(
86   const TSsFmt& SsFmt, const TStr& FNm,
87   const PNotify& Notify, const bool& IsExcelEoln,
88   const int& MxY, const TIntV& AllowedColNV, const bool& IsQStr){
89    TNotify::OnNotify(Notify, ntInfo, TStr("Loading File ")+FNm+" ...");
90    PSIn SIn=TFIn::New(FNm);
91    PSs Ss=TSs::New();
92    if (!SIn->Eof()){
93      int X=0; int Y=0; int PrevX=-1; int PrevY=-1;
94      char Ch=SIn->GetCh(); TChA ChA;
95      while (!SIn->Eof()){
96        ChA.Clr();
97        if (IsQStr&&(Ch=='"')){
98          Ch=SIn->GetCh();
99          forever {
100            while ((!SIn->Eof())&&(Ch!='"')){
101              ChA+=Ch; Ch=SIn->GetCh();}
102            if (Ch=='"'){
103              Ch=SIn->GetCh();
104              if (Ch=='"'){ChA+=Ch; Ch=SIn->GetCh();}
105              else {break;}
106            }
107          }
108        } else {
109          if (SsFmt==ssfTabSep){
110            while ((!SIn->Eof())&&(Ch!='\t')&&(Ch!='\r')&&((Ch!='\n')||IsExcelEoln)){
111              ChA+=Ch; Ch=SIn->GetCh();
112            }
113          } else
114          if (SsFmt==ssfCommaSep){
115            while ((!SIn->Eof())&&(Ch!=',')&&(Ch!='\r')&&((Ch!='\n')||IsExcelEoln)){
116              ChA+=Ch; Ch=SIn->GetCh();
117            }
118          } else
119          if (SsFmt==ssfSemicolonSep){
120            while ((!SIn->Eof())&&(Ch!=';')&&(Ch!='\r')&&((Ch!='\n')||IsExcelEoln)){
121              ChA+=Ch; Ch=SIn->GetCh();
122            }
123          } else
124          if (SsFmt==ssfVBar){
125            while ((!SIn->Eof())&&(Ch!='|')&&(Ch!='\r')&&((Ch!='\n')||IsExcelEoln)){
126              ChA+=Ch; Ch=SIn->GetCh();
127            }
128          } else
129          if (SsFmt==ssfSpaceSep){
130            while ((!SIn->Eof())&&(Ch!=' ')&&(Ch!='\r')&&((Ch!='\n')||IsExcelEoln)){
131              ChA+=Ch; Ch=SIn->GetCh();
132            }
133          } else {
134            Fail;
135          }
136        }
137        if (PrevY!=Y){
138          if ((MxY!=-1)&&(Ss->CellStrVV.Len()==MxY)){break;}
139          Ss->CellStrVV.Add(TStrVP::New()); PrevY=Y;
140          int Recs=Ss->CellStrVV.Len();
141          if (Recs%1000==0){
142            TNotify::OnStatus(Notify, TStr::Fmt("  %d\r", Recs));}
143        }
144        if (AllowedColNV.Empty()||AllowedColNV.IsIn(X)){
145          Ss->CellStrVV[Y]->V.Add(ChA); 
146        }
147        if (SIn->Eof()){
148          break;
149        } else
150        if ((SsFmt==ssfTabSep)&&(Ch=='\t')){
151          X++; Ch=SIn->GetCh();
152        } else
153        if ((SsFmt==ssfCommaSep)&&(Ch==',')){
154          X++; Ch=SIn->GetCh();
155        } else
156        if ((SsFmt==ssfSemicolonSep)&&(Ch==';')){
157          X++; Ch=SIn->GetCh();
158        } else
159        if ((SsFmt==ssfVBar)&&(Ch=='|')){
160          X++; Ch=SIn->GetCh();
161        } else
162        if ((SsFmt==ssfSpaceSep)&&(Ch==' ')){
163          X++; Ch=SIn->GetCh();
164        } else
165        if (Ch=='\r'){
166          if ((PrevX!=-1)&&(X!=PrevX)){
167            TNotify::OnNotify(Notify, ntWarn, "Number of fields is not the same!");}
168          PrevX=X; X=0; Y++; Ch=SIn->GetCh();
169          if ((Ch=='\n')&&(!SIn->Eof())){Ch=SIn->GetCh();}
170        } else
171        if (Ch=='\n'){
172          if ((PrevX!=-1)&&(X!=PrevX)){
173            TNotify::OnNotify(Notify, ntWarn, "Number of fields is not the same!");}
174          PrevX=X; X=0; Y++; Ch=SIn->GetCh();
175          if ((Ch=='\r')&&(!SIn->Eof())){Ch=SIn->GetCh();}
176        } else {
177          Fail;
178        }
179      }
180    }
181    int Recs=Ss->CellStrVV.Len();
182    TNotify::OnNotify(Notify, ntInfo, TStr::Fmt("  %d records read.", Recs));
183    TNotify::OnNotify(Notify, ntInfo, "... Done.");
184    return Ss;
185  }
186  void TSs::SaveTxt(const TStr& FNm, const PNotify&) const {
187    PSOut SOut=TFOut::New(FNm);
188    for (int Y=0; Y<CellStrVV.Len(); Y++){
189      for (int X=0; X<CellStrVV[Y]->Len(); X++){
190        if (X>0){SOut->PutCh('\t');}
191        TStr Str=CellStrVV[Y]->V[X];
192        TChA ChA(Str);
193        for (int ChN=0; ChN<ChA.Len(); ChN++){
194          char Ch=ChA[ChN];
195          if ((Ch=='\t')||(Ch=='\r')||(Ch=='\n')){
196            ChA.PutCh(ChN, ' ');
197          }
198        }
199        SOut->PutStr(ChA);
200      }
201      SOut->PutCh('\r'); SOut->PutCh('\n');
202    }
203  }
204  void TSs::LoadTxtFldV(
205   const TSsFmt& SsFmt, const PSIn& SIn, char& Ch,
206   TStrV& FldValV, const bool& IsExcelEoln, const bool& IsQStr){
207    if (!SIn->Eof()){
208      FldValV.Clr(false); int X=0;
209      if (Ch==TCh::NullCh){Ch=SIn->GetCh();}
210      TChA ChA;
211      while (!SIn->Eof()){
212        ChA.Clr();
213        if (IsQStr&&(Ch=='"')){
214          Ch=SIn->GetCh();
215          forever {
216            while ((!SIn->Eof())&&(Ch!='"')){
217              ChA+=Ch; Ch=SIn->GetCh();}
218            if (Ch=='"'){
219              Ch=SIn->GetCh();
220              if (Ch=='"'){ChA+=Ch; Ch=SIn->GetCh();}
221              else {break;}
222            }
223          }
224        } else {
225          if (SsFmt==ssfTabSep){
226            while ((!SIn->Eof())&&(Ch!='\t')&&(Ch!='\r')&&
227             ((Ch!='\n')||IsExcelEoln)){
228              ChA+=Ch; Ch=SIn->GetCh();
229            }
230            if ((!ChA.Empty())&&(ChA.LastCh()=='\"')){
231              ChA.Pop();}
232          } else
233          if (SsFmt==ssfCommaSep){
234            while ((!SIn->Eof())&&(Ch!=',')&&(Ch!='\r')&&
235             ((Ch!='\n')||IsExcelEoln)){
236              ChA+=Ch; Ch=SIn->GetCh();
237            }
238          } else
239          if (SsFmt==ssfSemicolonSep){
240            while ((!SIn->Eof())&&(Ch!=';')&&(Ch!='\r')&&
241             ((Ch!='\n')||IsExcelEoln)){
242              ChA+=Ch; Ch=SIn->GetCh();
243            }
244          } else
245          if (SsFmt==ssfVBar){
246            while ((!SIn->Eof())&&(Ch!='|')&&(Ch!='\r')&&
247             ((Ch!='\n')||IsExcelEoln)){
248              ChA+=Ch; Ch=SIn->GetCh();
249            }
250          } else {
251            Fail;
252          }
253        }
254        ChA.Trunc();
255        FldValV.Add(ChA);
256        if (SIn->Eof()){
257          break;
<span onclick='openModal()' class='match'>258        } else
259        if ((SsFmt==ssfTabSep)&&(Ch=='\t')){
260          X++; Ch=SIn->GetCh();
261        } else
262        if ((SsFmt==ssfCommaSep)&&(Ch==',')){
263          X++; Ch=SIn->GetCh();
264        } else
265        if ((SsFmt==ssfSemicolonSep)&&(Ch==';')){
266          X++; Ch=SIn->GetCh();
267        } else
268        if ((SsFmt==ssfVBar)&&(Ch=='|')){
269          X++; Ch=SIn->GetCh();
270        } else
271        if (Ch=='\r'){
272          Ch=SIn->GetCh();
</span>273          if ((Ch=='\n')&&(!SIn->Eof())){Ch=SIn->GetCh();}
274          break;
275        } else
276        if (Ch=='\n'){
277          X=0; Ch=SIn->GetCh();
278          if ((Ch=='\r')&&(!SIn->Eof())){Ch=SIn->GetCh();}
279          break;
280        } else {
281          Fail;
282        }
283      }
284    }
285  }
286  TSsFmt TSs::GetSsFmtFromStr(const TStr& SsFmtNm){
287    TStr LcSsFmtNm=SsFmtNm.GetLc();
288    if (LcSsFmtNm=="tab"){return ssfTabSep;}
289    else if (LcSsFmtNm=="comma"){return ssfCommaSep;}
290    else if (LcSsFmtNm=="semicolon"){return ssfSemicolonSep;}
291    else if (LcSsFmtNm=="vbar"){return ssfVBar;}
292    else if (LcSsFmtNm=="space"){return ssfSpaceSep;}
293    else if (LcSsFmtNm=="white"){return ssfWhiteSep;}
294    else {return ssfUndef;}
295  }
296  TStr TSs::GetStrFromSsFmt(const TSsFmt& SsFmt){
297    switch (SsFmt){
298      case ssfTabSep: return "tab";
299      case ssfCommaSep: return "comma";
300      case ssfSemicolonSep: return "semicolon";
301      case ssfVBar: return "vbar";
302      case ssfSpaceSep: return "space";
303      case ssfWhiteSep: return "white";
304      default: return "undef";
305    }
306  }
307  TStr TSs::GetSsFmtNmVStr(){
308    TChA ChA;
309    ChA+='(';
310    ChA+="tab"; ChA+=", ";
311    ChA+="comma"; ChA+=", ";
312    ChA+="semicolon"; ChA+=", ";
313    ChA+="space"; ChA+=", ";
314    ChA+="white"; ChA+=")";
315    return ChA;
316  }
317  TSsParser::TSsParser(const TStr& FNm, const TSsFmt _SsFmt, const bool& _SkipLeadBlanks, const bool& _SkipCmt, const bool& _SkipEmptyFld) : SsFmt(_SsFmt), 
318   SkipLeadBlanks(_SkipLeadBlanks), SkipCmt(_SkipCmt), SkipEmptyFld(_SkipEmptyFld), LineCnt(0), &bsol;*Bf(NULL),*/ SplitCh('\t'), LineStr(), FldV(), FInPt(NULL) {
319    if (TZipIn::IsZipExt(FNm.GetFExt())) { FInPt = TZipIn::New(FNm); }
320    else { FInPt = TFIn::New(FNm); }
321    switch(SsFmt) {
322      case ssfTabSep : SplitCh = '\t'; break;
323      case ssfCommaSep : SplitCh = ','; break;
324      case ssfSemicolonSep : SplitCh = ';'; break;
325      case ssfVBar : SplitCh = '|'; break;
326      case ssfSpaceSep : SplitCh = ' '; break;
327      case ssfWhiteSep: SplitCh = ' '; break;
328      default: FailR("Unknown separator character.");
329    }
330  }
331  TSsParser::TSsParser(const TStr& FNm, const char& Separator, const bool& _SkipLeadBlanks, const bool& _SkipCmt, const bool& _SkipEmptyFld) : SsFmt(ssfSpaceSep), 
332   SkipLeadBlanks(_SkipLeadBlanks), SkipCmt(_SkipCmt), SkipEmptyFld(_SkipEmptyFld), LineCnt(0), &bsol;*Bf(NULL),*/ SplitCh('\t'), LineStr(), FldV(), FInPt(NULL) {
333    if (TZipIn::IsZipExt(FNm.GetFExt())) { FInPt = TZipIn::New(FNm); }
334    else { FInPt = TFIn::New(FNm); }
335    SplitCh = Separator;
336  }
337  TSsParser::~TSsParser() {
338  }
339  bool TSsParser::NextSlow() { 
340    FldV.Clr(false);
341    LineStr.Clr();
342    FldV.Clr();
343    LineCnt++;
344    if (! FInPt->GetNextLn(LineStr)) { return false; }
345    if (SkipCmt && !LineStr.Empty() && LineStr[0]=='#') { return NextSlow(); }
346    char* cur = LineStr.CStr();
347    if (SkipLeadBlanks) { 
348      while (*cur && TCh::IsWs(*cur)) { cur++; }
349    }
350    char *last = cur;
351    while (*cur) {
352      if (SsFmt == ssfWhiteSep) { while (*cur && ! TCh::IsWs(*cur)) { cur++; } } 
353      else { while (*cur && *cur!=SplitCh) { cur++; } }
354      if (*cur == 0) { break; }
355      *cur = 0;  cur++;
356      FldV.Add(last);  last = cur;
357      if (SkipEmptyFld && strlen(FldV.Last())==0) { FldV.DelLast(); } 
358    }
359    if (*last != 0) { FldV.Add(last); }  
360    if (SkipEmptyFld && FldV.Empty()) { return NextSlow(); } 
361    return true; 
362  }
363  bool TSsParser::Next() { 
364    FldV.Clr(false);
365    LineStr.Clr();
366    FldV.Clr();
367    LineCnt++;
368    if (! FInPt->GetNextLnBf(LineStr)) { return false; }
369    if (SkipCmt && !LineStr.Empty() && LineStr[0]=='#') { return Next(); }
370    char* cur = LineStr.CStr();
371    if (SkipLeadBlanks) { 
372      while (*cur && TCh::IsWs(*cur)) { cur++; }
373    }
374    char *last = cur;
375    while (*cur) {
376      if (SsFmt == ssfWhiteSep) { while (*cur && ! TCh::IsWs(*cur)) { cur++; } } 
377      else { while (*cur && *cur!=SplitCh) { cur++; } }
378      if (*cur == 0) { break; }
379      *cur = 0;  cur++;
380      FldV.Add(last);  last = cur;
381      if (SkipEmptyFld && strlen(FldV.Last())==0) { FldV.DelLast(); } 
382    }
383    if (*last != 0) { FldV.Add(last); }  
384    if (SkipEmptyFld && FldV.Empty()) { return Next(); } 
385    return true; 
386  }
387  void TSsParser::ToLc() {
388    for (int f = 0; f < FldV.Len(); f++) {
389      for (char *c = FldV[f]; *c; c++) {
390        *c = tolower(*c); }
391    }
392  }
393  bool TSsParser::GetInt(const int& FldN, int& Val) const {
394    if (FldN >= Len()) { return false; }
395    int _Val = -1;
396    bool Minus=false;
397    const char *c = GetFld(FldN);
398    while (TCh::IsWs(*c)) { c++; }
399    if (*c=='-') { Minus=true; c++; }
400    if (! TCh::IsNum(*c)) { return false; }
401    _Val = TCh::GetNum(*c);  c++;
402    while (TCh::IsNum(*c)){ 
403      _Val = 10 * _Val + TCh::GetNum(*c); 
404      c++; 
405    }
406    if (Minus) { _Val = -_Val; }
407    if (*c != 0) { return false; }
408    Val = _Val;
409    return true;
410  }
411  bool TSsParser::GetUInt64(const int& FldN, uint64& Val) const {
412    if (FldN >= Len()) { return false; }
413    uint64 _Val=0;
414    const char *c = GetFld(FldN);
415    while (TCh::IsWs(*c)){ c++; }
416    if (*c == '+'){ c++; }
417    if (! TCh::IsNum(*c)) { return false; }
418    _Val = TCh::GetNum(*c); c++;
419    while (TCh::IsNum(*c)) {
420      _Val = 10*_Val + TCh::GetNum(*c);
421      c++;
422    }
423    if (*c != 0) { return false; }
424    Val = _Val;
425    return true;
426  }
427  bool TSsParser::GetFlt(const int& FldN, double& Val) const {
428    if (FldN >= Len()) { return false; }
429    const char *c = GetFld(FldN);
430    while (TCh::IsWs(*c)) { c++; }
431    if (*c=='+' || *c=='-') { c++; }
432    if (! TCh::IsNum(*c) && *c!='.') { return false; }
433    while (TCh::IsNum(*c)) { c++; }
434    if (*c == '.') {
435      c++;
436      while (TCh::IsNum(*c)) { c++; }
437    }
438    if (*c=='e' || *c == 'E') {
439      c++;
440      if (*c == '+' || *c == '-' ) { c++; }
441      if (! TCh::IsNum(*c)) { return false; }
442      while (TCh::IsNum(*c)) { c++; }
443    }
444    if (*c != 0) { return false; }
445    Val = atof(GetFld(FldN));
446    return true;
447  }
448  const char* TSsParser::DumpStr() const {
449    static TChA ChA(10*1024);
450    ChA.Clr();
451    for (int i = 0; i < FldV.Len(); i++) {
452      ChA += TStr::Fmt("  %d: '%s'\n", i, FldV[i]);
453    }
454    return ChA.CStr();
455  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-WordStyleDlg.cpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-ss.cpp</div>
                <div class="column column_space"><pre><code>774  	}
775  	else if (style._styleDesc == TEXT("Smart Highlighting"))
776  	{
777  		result.first = 9;
778  		result.second = IDC_CHECK_ENABLSMARTHILITE;
779  	}
780  	else if (style._styleDesc == TEXT("Tags match highlighting"))
781  	{
782  		result.first = 9;
783  		result.second = IDC_CHECK_ENABLTAGSMATCHHILITE;
784  	}
785  	else if (style._styleDesc == TEXT("Tags attribute"))
786  	{
787  		result.first = 9;
788  		result.second = IDC_CHECK_ENABLTAGATTRHILITE;
789  	}
790  	else if (style._styleDesc == TEXT("Mark Style 1") || style._styleDesc == TEXT("Mark Style 2") || style._styleDesc == TEXT("Mark Style 3")
791  		|| style._styleDesc == TEXT("Mark Style 4") || style._styleDesc == TEXT("Mark Style 5"))
792  	{
793  		result.first = 9;
794  		result.second = IDC_CHECK_MARKALLCASESENSITIVE;
795  	}
796  	else if (style._styleDesc == TEXT("URL hovered"))
797  	{
798  		result.first = 17;
</pre></code></div>
                <div class="column column_space"><pre><code>258        } else
259        if ((SsFmt==ssfTabSep)&&(Ch=='\t')){
260          X++; Ch=SIn->GetCh();
261        } else
262        if ((SsFmt==ssfCommaSep)&&(Ch==',')){
263          X++; Ch=SIn->GetCh();
264        } else
265        if ((SsFmt==ssfSemicolonSep)&&(Ch==';')){
266          X++; Ch=SIn->GetCh();
267        } else
268        if ((SsFmt==ssfVBar)&&(Ch=='|')){
269          X++; Ch=SIn->GetCh();
270        } else
271        if (Ch=='\r'){
272          Ch=SIn->GetCh();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    