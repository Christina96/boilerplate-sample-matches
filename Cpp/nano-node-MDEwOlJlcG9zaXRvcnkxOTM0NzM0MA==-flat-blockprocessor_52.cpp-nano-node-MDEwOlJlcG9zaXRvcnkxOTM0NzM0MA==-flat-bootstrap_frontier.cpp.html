
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 22, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-blockprocessor_52.cpp</h3>
            <pre><code>1  #include <nano/lib/threading.hpp>
2  #include <nano/lib/timer.hpp>
3  #include <nano/node/blockprocessor.hpp>
4  #include <nano/node/node.hpp>
5  #include <nano/secure/store.hpp>
6  #include <boost/format.hpp>
7  std::chrono::milliseconds constexpr nano::block_processor::confirmation_request_delay;
8  nano::block_processor::block_processor (nano::node & node_a, nano::write_database_queue & write_database_queue_a) :
9  	next_log (std::chrono::steady_clock::now ()),
10  	node (node_a),
11  	write_database_queue (write_database_queue_a),
12  	state_block_signature_verification (node.checker, node.ledger.constants.epochs, node.config, node.logger, node.flags.block_processor_verification_size)
13  {
14  	batch_processed.add ([this] (auto const & items) {
15  		for (auto const & item : items)
16  		{
17  			auto const & [result, block] = item;
18  			processed.notify (result, block);
19  		}
20  	});
21  	blocking.connect (*this);
22  	state_block_signature_verification.blocks_verified_callback = [this] (std::deque<nano::state_block_signature_verification::value_type> & items, std::vector<int> const & verifications, std::vector<nano::block_hash> const & hashes, std::vector<nano::signature> const & blocks_signatures) {
23  		this->process_verified_state_blocks (items, verifications, hashes, blocks_signatures);
24  	};
25  	state_block_signature_verification.transition_inactive_callback = [this] () {
26  		if (this->flushing)
27  		{
28  			{
29  				nano::lock_guard<nano::mutex> guard{ this->mutex };
30  			}
31  			this->condition.notify_all ();
32  		}
33  	};
34  	processing_thread = std::thread ([this] () {
35  		nano::thread_role::set (nano::thread_role::name::block_processing);
36  		this->process_blocks ();
37  	});
38  }
39  void nano::block_processor::stop ()
40  {
41  	{
42  		nano::lock_guard<nano::mutex> lock{ mutex };
43  		stopped = true;
44  	}
45  	condition.notify_all ();
46  	blocking.stop ();
47  	state_block_signature_verification.stop ();
48  	nano::join_or_pass (processing_thread);
49  }
50  void nano::block_processor::flush ()
51  {
52  	node.checker.flush ();
53  	flushing = true;
54  	nano::unique_lock<nano::mutex> lock{ mutex };
55  	while (!stopped && (have_blocks () || active || state_block_signature_verification.is_active ()))
56  	{
57  		condition.wait (lock);
58  	}
59  	flushing = false;
60  }
61  std::size_t nano::block_processor::size ()
62  {
63  	nano::unique_lock<nano::mutex> lock{ mutex };
64  	return (blocks.size () + state_block_signature_verification.size () + forced.size ());
65  }
66  bool nano::block_processor::full ()
67  {
68  	return size () >= node.flags.block_processor_full_size;
69  }
70  bool nano::block_processor::half_full ()
71  {
72  	return size () >= node.flags.block_processor_full_size / 2;
73  }
74  void nano::block_processor::add (std::shared_ptr<nano::block> const & block)
75  {
76  	if (full ())
77  	{
78  		node.stats.inc (nano::stat::type::blockprocessor, nano::stat::detail::overfill);
79  		return;
80  	}
81  	if (node.network_params.work.validate_entry (*block)) 
82  	{
83  		node.stats.inc (nano::stat::type::blockprocessor, nano::stat::detail::insufficient_work);
84  		return;
85  	}
86  	add_impl (block);
87  	return;
88  }
89  std::optional<nano::process_return> nano::block_processor::add_blocking (std::shared_ptr<nano::block> const & block)
90  {
91  	auto future = blocking.insert (block);
92  	add_impl (block);
93  	condition.notify_all ();
94  	std::optional<nano::process_return> result;
95  	try
96  	{
97  		auto status = future.wait_for (node.config.block_process_timeout);
98  		debug_assert (status != std::future_status::deferred);
99  		if (status == std::future_status::ready)
100  		{
101  			result = future.get ();
102  		}
103  		else
104  		{
105  			blocking.erase (block);
106  		}
107  	}
108  	catch (std::future_error const &)
109  	{
110  	}
111  	return result;
112  }
<span onclick='openModal()' class='match'>113  void nano::block_processor::rollback_competitor (nano::write_transaction const & transaction, nano::block const & block)
114  {
115  	auto hash = block.hash ();
</span>116  	auto successor = node.ledger.successor (transaction, block.qualified_root ());
117  	if (successor != nullptr && successor->hash () != hash)
118  	{
119  		if (node.config.logging.ledger_rollback_logging ())
120  		{
121  			node.logger.always_log (boost::str (boost::format ("Rolling back %1% and replacing with %2%") % successor->hash ().to_string () % hash.to_string ()));
122  		}
123  		std::vector<std::shared_ptr<nano::block>> rollback_list;
124  		if (node.ledger.rollback (transaction, successor->hash (), rollback_list))
125  		{
126  			node.stats.inc (nano::stat::type::ledger, nano::stat::detail::rollback_failed);
127  			node.logger.always_log (nano::severity_level::error, boost::str (boost::format ("Failed to roll back %1% because it or a successor was confirmed") % successor->hash ().to_string ()));
128  		}
129  		else if (node.config.logging.ledger_rollback_logging ())
130  		{
131  			node.logger.always_log (boost::str (boost::format ("%1% blocks rolled back") % rollback_list.size ()));
132  		}
133  		for (auto & i : rollback_list)
134  		{
135  			node.history.erase (i->root ());
136  			if (i->hash () != successor->hash ())
137  			{
138  				node.active.erase (*i);
139  			}
140  		}
141  	}
142  }
143  void nano::block_processor::force (std::shared_ptr<nano::block> const & block_a)
144  {
145  	{
146  		nano::lock_guard<nano::mutex> lock{ mutex };
147  		forced.push_back (block_a);
148  	}
149  	condition.notify_all ();
150  }
151  void nano::block_processor::process_blocks ()
152  {
153  	nano::unique_lock<nano::mutex> lock{ mutex };
154  	while (!stopped)
155  	{
156  		if (have_blocks_ready ())
157  		{
158  			active = true;
159  			lock.unlock ();
160  			auto processed = process_batch (lock);
161  			batch_processed.notify (processed);
162  			lock.lock ();
163  			active = false;
164  		}
165  		else
166  		{
167  			condition.notify_one ();
168  			condition.wait (lock);
169  		}
170  	}
171  }
172  bool nano::block_processor::should_log ()
173  {
174  	auto result (false);
175  	auto now (std::chrono::steady_clock::now ());
176  	if (next_log < now)
177  	{
178  		next_log = now + (node.config.logging.timing_logging () ? std::chrono::seconds (2) : std::chrono::seconds (15));
179  		result = true;
180  	}
181  	return result;
182  }
183  bool nano::block_processor::have_blocks_ready ()
184  {
185  	debug_assert (!mutex.try_lock ());
186  	return !blocks.empty () || !forced.empty ();
187  }
188  bool nano::block_processor::have_blocks ()
189  {
190  	debug_assert (!mutex.try_lock ());
191  	return have_blocks_ready () || state_block_signature_verification.size () != 0;
192  }
193  void nano::block_processor::process_verified_state_blocks (std::deque<nano::state_block_signature_verification::value_type> & items, std::vector<int> const & verifications, std::vector<nano::block_hash> const & hashes, std::vector<nano::signature> const & blocks_signatures)
194  {
195  	{
196  		nano::unique_lock<nano::mutex> lk{ mutex };
197  		for (auto i (0); i < verifications.size (); ++i)
198  		{
199  			debug_assert (verifications[i] == 1 || verifications[i] == 0);
200  			auto & item = items.front ();
201  			auto & [block] = item;
202  			if (!block->link ().is_zero () && node.ledger.is_epoch_link (block->link ()))
203  			{
204  				if (verifications[i] == 1)
205  				{
206  					blocks.emplace_back (block);
207  				}
208  				else
209  				{
210  					blocks.emplace_back (block);
211  				}
212  			}
213  			else if (verifications[i] == 1)
214  			{
215  				blocks.emplace_back (block);
216  			}
217  			items.pop_front ();
218  		}
219  	}
220  	condition.notify_all ();
221  }
222  void nano::block_processor::add_impl (std::shared_ptr<nano::block> block)
223  {
224  	if (block->type () == nano::block_type::state || block->type () == nano::block_type::open)
225  	{
226  		state_block_signature_verification.add ({ block });
227  	}
228  	else
229  	{
230  		{
231  			nano::lock_guard<nano::mutex> guard{ mutex };
232  			blocks.emplace_back (block);
233  		}
234  		condition.notify_all ();
235  	}
236  }
237  auto nano::block_processor::process_batch (nano::unique_lock<nano::mutex> & lock_a) -> std::deque<processed_t>
238  {
239  	std::deque<processed_t> processed;
240  	auto scoped_write_guard = write_database_queue.wait (nano::writer::process_batch);
241  	auto transaction (node.store.tx_begin_write ({ tables::accounts, tables::blocks, tables::frontiers, tables::pending }));
242  	nano::timer<std::chrono::milliseconds> timer_l;
243  	lock_a.lock ();
244  	timer_l.start ();
245  	unsigned number_of_blocks_processed (0), number_of_forced_processed (0);
246  	auto deadline_reached = [&timer_l, deadline = node.config.block_processor_batch_max_time] { return timer_l.after_deadline (deadline); };
247  	auto processor_batch_reached = [&number_of_blocks_processed, max = node.flags.block_processor_batch_size] { return number_of_blocks_processed >= max; };
248  	auto store_batch_reached = [&number_of_blocks_processed, max = node.store.max_block_write_batch_num ()] { return number_of_blocks_processed >= max; };
249  	while (have_blocks_ready () && (!deadline_reached () || !processor_batch_reached ()) && !store_batch_reached ())
250  	{
251  		if ((blocks.size () + state_block_signature_verification.size () + forced.size () > 64) && should_log ())
252  		{
253  			node.logger.always_log (boost::str (boost::format ("%1% blocks (+ %2% state blocks) (+ %3% forced) in processing queue") % blocks.size () % state_block_signature_verification.size () % forced.size ()));
254  		}
255  		std::shared_ptr<nano::block> block;
256  		nano::block_hash hash (0);
257  		bool force (false);
258  		if (forced.empty ())
259  		{
260  			block = blocks.front ();
261  			blocks.pop_front ();
262  			hash = block->hash ();
263  		}
264  		else
265  		{
266  			block = forced.front ();
267  			forced.pop_front ();
268  			hash = block->hash ();
269  			force = true;
270  			number_of_forced_processed++;
271  		}
272  		lock_a.unlock ();
273  		if (force)
274  		{
275  			rollback_competitor (transaction, *block);
276  		}
277  		number_of_blocks_processed++;
278  		auto result = process_one (transaction, block, force);
279  		processed.emplace_back (result, block);
280  		lock_a.lock ();
281  	}
282  	lock_a.unlock ();
283  	if (node.config.logging.timing_logging () && number_of_blocks_processed != 0 && timer_l.stop () > std::chrono::milliseconds (100))
284  	{
285  		node.logger.always_log (boost::str (boost::format ("Processed %1% blocks (%2% blocks were forced) in %3% %4%") % number_of_blocks_processed % number_of_forced_processed % timer_l.value ().count () % timer_l.unit ()));
286  	}
287  	return processed;
288  }
289  nano::process_return nano::block_processor::process_one (nano::write_transaction const & transaction_a, std::shared_ptr<nano::block> block, bool const forced_a)
290  {
291  	nano::process_return result;
292  	auto hash (block->hash ());
293  	result = node.ledger.process (transaction_a, *block);
294  	switch (result.code)
295  	{
296  		case nano::process_result::progress:
297  		{
298  			if (node.config.logging.ledger_logging ())
299  			{
300  				std::string block_string;
301  				block->serialize_json (block_string, node.config.logging.single_line_record ());
302  				node.logger.try_log (boost::str (boost::format ("Processing block %1%: %2%") % hash.to_string () % block_string));
303  			}
304  			queue_unchecked (transaction_a, hash);
305  			if (block->type () == nano::block_type::send || (block->type () == nano::block_type::state && block->sideband ().details.is_send && std::underlying_type_t<nano::epoch> (block->sideband ().details.epoch) < std::underlying_type_t<nano::epoch> (nano::epoch::max)))
306  			{
307  				queue_unchecked (transaction_a, block->destination ().is_zero () ? block->link () : block->destination ());
308  			}
309  			break;
310  		}
311  		case nano::process_result::gap_previous:
312  		{
313  			if (node.config.logging.ledger_logging ())
314  			{
315  				node.logger.try_log (boost::str (boost::format ("Gap previous for: %1%") % hash.to_string ()));
316  			}
317  			node.unchecked.put (block->previous (), block);
318  			node.stats.inc (nano::stat::type::ledger, nano::stat::detail::gap_previous);
319  			break;
320  		}
321  		case nano::process_result::gap_source:
322  		{
323  			if (node.config.logging.ledger_logging ())
324  			{
325  				node.logger.try_log (boost::str (boost::format ("Gap source for: %1%") % hash.to_string ()));
326  			}
327  			node.unchecked.put (node.ledger.block_source (transaction_a, *block), block);
328  			node.stats.inc (nano::stat::type::ledger, nano::stat::detail::gap_source);
329  			break;
330  		}
331  		case nano::process_result::gap_epoch_open_pending:
332  		{
333  			if (node.config.logging.ledger_logging ())
334  			{
335  				node.logger.try_log (boost::str (boost::format ("Gap pending entries for epoch open: %1%") % hash.to_string ()));
336  			}
337  			node.unchecked.put (block->account (), block); 
338  			node.stats.inc (nano::stat::type::ledger, nano::stat::detail::gap_source);
339  			break;
340  		}
341  		case nano::process_result::old:
342  		{
343  			if (node.config.logging.ledger_duplicate_logging ())
344  			{
345  				node.logger.try_log (boost::str (boost::format ("Old for: %1%") % hash.to_string ()));
346  			}
347  			node.stats.inc (nano::stat::type::ledger, nano::stat::detail::old);
348  			break;
349  		}
350  		case nano::process_result::bad_signature:
351  		{
352  			if (node.config.logging.ledger_logging ())
353  			{
354  				node.logger.try_log (boost::str (boost::format ("Bad signature for: %1%") % hash.to_string ()));
355  			}
356  			break;
357  		}
358  		case nano::process_result::negative_spend:
359  		{
360  			if (node.config.logging.ledger_logging ())
361  			{
362  				node.logger.try_log (boost::str (boost::format ("Negative spend for: %1%") % hash.to_string ()));
363  			}
364  			break;
365  		}
366  		case nano::process_result::unreceivable:
367  		{
368  			if (node.config.logging.ledger_logging ())
369  			{
370  				node.logger.try_log (boost::str (boost::format ("Unreceivable for: %1%") % hash.to_string ()));
371  			}
372  			break;
373  		}
374  		case nano::process_result::fork:
375  		{
376  			node.stats.inc (nano::stat::type::ledger, nano::stat::detail::fork);
377  			if (node.config.logging.ledger_logging ())
378  			{
379  				node.logger.try_log (boost::str (boost::format ("Fork for: %1% root: %2%") % hash.to_string () % block->root ().to_string ()));
380  			}
381  			break;
382  		}
383  		case nano::process_result::opened_burn_account:
384  		{
385  			if (node.config.logging.ledger_logging ())
386  			{
387  				node.logger.try_log (boost::str (boost::format ("Rejecting open block for burn account: %1%") % hash.to_string ()));
388  			}
389  			break;
390  		}
391  		case nano::process_result::balance_mismatch:
392  		{
393  			if (node.config.logging.ledger_logging ())
394  			{
395  				node.logger.try_log (boost::str (boost::format ("Balance mismatch for: %1%") % hash.to_string ()));
396  			}
397  			break;
398  		}
399  		case nano::process_result::representative_mismatch:
400  		{
401  			if (node.config.logging.ledger_logging ())
402  			{
403  				node.logger.try_log (boost::str (boost::format ("Representative mismatch for: %1%") % hash.to_string ()));
404  			}
405  			break;
406  		}
407  		case nano::process_result::block_position:
408  		{
409  			if (node.config.logging.ledger_logging ())
410  			{
411  				node.logger.try_log (boost::str (boost::format ("Block %1% cannot follow predecessor %2%") % hash.to_string () % block->previous ().to_string ()));
412  			}
413  			break;
414  		}
415  		case nano::process_result::insufficient_work:
416  		{
417  			if (node.config.logging.ledger_logging ())
418  			{
419  				node.logger.try_log (boost::str (boost::format ("Insufficient work for %1% : %2% (difficulty %3%)") % hash.to_string () % nano::to_string_hex (block->block_work ()) % nano::to_string_hex (node.network_params.work.difficulty (*block))));
420  			}
421  			break;
422  		}
423  	}
424  	node.stats.inc (nano::stat::type::blockprocessor, nano::to_stat_detail (result.code));
425  	return result;
426  }
427  void nano::block_processor::queue_unchecked (nano::write_transaction const & transaction_a, nano::hash_or_account const & hash_or_account_a)
428  {
429  	node.unchecked.trigger (hash_or_account_a);
430  	node.gap_cache.erase (hash_or_account_a.hash);
431  }
432  std::unique_ptr<nano::container_info_component> nano::collect_container_info (block_processor & block_processor, std::string const & name)
433  {
434  	std::size_t blocks_count;
435  	std::size_t forced_count;
436  	{
437  		nano::lock_guard<nano::mutex> guard{ block_processor.mutex };
438  		blocks_count = block_processor.blocks.size ();
439  		forced_count = block_processor.forced.size ();
440  	}
441  	auto composite = std::make_unique<container_info_composite> (name);
442  	composite->add_component (collect_container_info (block_processor.state_block_signature_verification, "state_block_signature_verification"));
443  	composite->add_component (std::make_unique<container_info_leaf> (container_info{ "blocks", blocks_count, sizeof (decltype (block_processor.blocks)::value_type) }));
444  	composite->add_component (std::make_unique<container_info_leaf> (container_info{ "forced", forced_count, sizeof (decltype (block_processor.forced)::value_type) }));
445  	return composite;
446  }
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-bootstrap_frontier.cpp</h3>
            <pre><code>1  #include <nano/node/bootstrap/bootstrap_attempt.hpp>
2  #include <nano/node/bootstrap/bootstrap_frontier.hpp>
3  #include <nano/node/bootstrap/bootstrap_legacy.hpp>
4  #include <nano/node/node.hpp>
5  #include <nano/node/transport/tcp.hpp>
6  #include <boost/format.hpp>
7  constexpr double nano::bootstrap_limits::bootstrap_connection_warmup_time_sec;
8  constexpr double nano::bootstrap_limits::bootstrap_minimum_elapsed_seconds_blockrate;
9  constexpr double nano::bootstrap_limits::bootstrap_minimum_frontier_blocks_per_sec;
10  constexpr unsigned nano::bootstrap_limits::bulk_push_cost_limit;
11  constexpr std::size_t nano::frontier_req_client::size_frontier;
12  void nano::frontier_req_client::run (nano::account const & start_account_a, uint32_t const frontiers_age_a, uint32_t const count_a)
13  {
14  	auto node = connection->node.lock ();
15  	if (!node)
16  	{
17  		return;
18  	}
19  	nano::frontier_req request{ node->network_params.network };
20  	request.start = (start_account_a.is_zero () || start_account_a.number () == std::numeric_limits<nano::uint256_t>::max ()) ? start_account_a : start_account_a.number () + 1;
21  	request.age = frontiers_age_a;
22  	request.count = count_a;
23  	current = start_account_a;
24  	frontiers_age = frontiers_age_a;
25  	count_limit = count_a;
26  	next (); 
27  	auto this_l (shared_from_this ());
28  	connection->channel->send (
29  	request, [this_l] (boost::system::error_code const & ec, std::size_t size_a) {
30  		auto node = this_l->connection->node.lock ();
31  		if (!node)
32  		{
33  			return;
34  		}
35  		if (!ec)
36  		{
37  			this_l->receive_frontier ();
38  		}
39  		else
40  		{
41  			if (node->config.logging.network_logging ())
42  			{
43  				node->logger.try_log (boost::str (boost::format ("Error while sending bootstrap request %1%") % ec.message ()));
44  			}
45  		}
46  	},
47  	nano::transport::buffer_drop_policy::no_limiter_drop);
48  }
49  nano::frontier_req_client::frontier_req_client (std::shared_ptr<nano::bootstrap_client> const & connection_a, std::shared_ptr<nano::bootstrap_attempt_legacy> const & attempt_a) :
50  	connection (connection_a),
51  	attempt (attempt_a),
52  	count (0),
53  	bulk_push_cost (0)
54  {
55  }
56  void nano::frontier_req_client::receive_frontier ()
57  {
58  	auto this_l (shared_from_this ());
59  	connection->socket->async_read (connection->receive_buffer, nano::frontier_req_client::size_frontier, [this_l] (boost::system::error_code const & ec, std::size_t size_a) {
60  		auto node = this_l->connection->node.lock ();
61  		if (!node)
62  		{
63  			return;
64  		}
65  		if (size_a == nano::frontier_req_client::size_frontier)
66  		{
67  			this_l->received_frontier (ec, size_a);
68  		}
69  		else
70  		{
71  			if (node->config.logging.network_message_logging ())
72  			{
73  				node->logger.try_log (boost::str (boost::format ("Invalid size: expected %1%, got %2%") % nano::frontier_req_client::size_frontier % size_a));
74  			}
75  		}
76  	});
77  }
78  bool nano::frontier_req_client::bulk_push_available ()
79  {
80  	return bulk_push_cost < nano::bootstrap_limits::bulk_push_cost_limit && frontiers_age == std::numeric_limits<decltype (frontiers_age)>::max ();
81  }
<span onclick='openModal()' class='match'>82  void nano::frontier_req_client::unsynced (nano::block_hash const & head, nano::block_hash const & end)
83  {
84  	if (bulk_push_available ())
</span>85  	{
86  		attempt->add_bulk_push_target (head, end);
87  		if (end.is_zero ())
88  		{
89  			bulk_push_cost += 2;
90  		}
91  		else
92  		{
93  			bulk_push_cost += 1;
94  		}
95  	}
96  }
97  void nano::frontier_req_client::received_frontier (boost::system::error_code const & ec, std::size_t size_a)
98  {
99  	auto node = connection->node.lock ();
100  	if (!node)
101  	{
102  		return;
103  	}
104  	if (!ec)
105  	{
106  		debug_assert (size_a == nano::frontier_req_client::size_frontier);
107  		nano::account account;
108  		nano::bufferstream account_stream (connection->receive_buffer->data (), sizeof (account));
109  		auto error1 (nano::try_read (account_stream, account));
110  		(void)error1;
111  		debug_assert (!error1);
112  		nano::block_hash latest;
113  		nano::bufferstream latest_stream (connection->receive_buffer->data () + sizeof (account), sizeof (latest));
114  		auto error2 (nano::try_read (latest_stream, latest));
115  		(void)error2;
116  		debug_assert (!error2);
117  		if (count == 0)
118  		{
119  			start_time = std::chrono::steady_clock::now ();
120  		}
121  		++count;
122  		std::chrono::duration<double> time_span = std::chrono::duration_cast<std::chrono::duration<double>> (std::chrono::steady_clock::now () - start_time);
123  		double elapsed_sec = std::max (time_span.count (), nano::bootstrap_limits::bootstrap_minimum_elapsed_seconds_blockrate);
124  		double blocks_per_sec = static_cast<double> (count) / elapsed_sec;
125  		double age_factor = (frontiers_age == std::numeric_limits<decltype (frontiers_age)>::max ()) ? 1.0 : 1.5; 
126  		if (elapsed_sec > nano::bootstrap_limits::bootstrap_connection_warmup_time_sec && blocks_per_sec * age_factor < nano::bootstrap_limits::bootstrap_minimum_frontier_blocks_per_sec)
127  		{
128  			node->logger.try_log (boost::str (boost::format ("Aborting frontier req because it was too slow: %1% frontiers per second, last %2%") % blocks_per_sec % account.to_account ()));
129  			promise.set_value (true);
130  			return;
131  		}
132  		if (attempt->should_log ())
133  		{
134  			node->logger.always_log (boost::str (boost::format ("Received %1% frontiers from %2%") % std::to_string (count) % connection->channel->to_string ()));
135  		}
136  		if (!account.is_zero () && count <= count_limit)
137  		{
138  			last_account = account;
139  			while (!current.is_zero () && current < account)
140  			{
141  				unsynced (frontier, 0);
142  				next ();
143  			}
144  			if (!current.is_zero ())
145  			{
146  				if (account == current)
147  				{
148  					if (latest == frontier)
149  					{
150  					}
151  					else
152  					{
153  						if (node->ledger.block_or_pruned_exists (latest))
154  						{
155  							unsynced (frontier, latest);
156  						}
157  						else
158  						{
159  							attempt->add_frontier (nano::pull_info (account, latest, frontier, attempt->incremental_id, 0, node->network_params.bootstrap.frontier_retry_limit));
160  							bulk_push_cost += 5;
161  						}
162  					}
163  					next ();
164  				}
165  				else
166  				{
167  					debug_assert (account < current);
168  					attempt->add_frontier (nano::pull_info (account, latest, nano::block_hash (0), attempt->incremental_id, 0, node->network_params.bootstrap.frontier_retry_limit));
169  				}
170  			}
171  			else
172  			{
173  				attempt->add_frontier (nano::pull_info (account, latest, nano::block_hash (0), attempt->incremental_id, 0, node->network_params.bootstrap.frontier_retry_limit));
174  			}
175  			receive_frontier ();
176  		}
177  		else
178  		{
179  			if (count <= count_limit)
180  			{
181  				while (!current.is_zero () && bulk_push_available ())
182  				{
183  					unsynced (frontier, 0);
184  					next ();
185  				}
186  				attempt->set_start_account (std::numeric_limits<nano::uint256_t>::max ());
187  				if (node->config.logging.bulk_pull_logging ())
188  				{
189  					node->logger.try_log ("Bulk push cost: ", bulk_push_cost);
190  				}
191  			}
192  			else
193  			{
194  				attempt->set_start_account (last_account);
195  			}
196  			node->bootstrap_initiator.connections->pool_connection (connection);
197  			try
198  			{
199  				promise.set_value (false);
200  			}
201  			catch (std::future_error &)
202  			{
203  			}
204  		}
205  	}
206  	else
207  	{
208  		if (node->config.logging.network_logging ())
209  		{
210  			node->logger.try_log (boost::str (boost::format ("Error while receiving frontier %1%") % ec.message ()));
211  		}
212  	}
213  }
214  void nano::frontier_req_client::next ()
215  {
216  	auto node = connection->node.lock ();
217  	if (!node)
218  	{
219  		return;
220  	}
221  	if (accounts.empty ())
222  	{
223  		std::size_t max_size (128);
224  		auto transaction (node->store.tx_begin_read ());
225  		for (auto i (node->store.account.begin (transaction, current.number () + 1)), n (node->store.account.end ()); i != n && accounts.size () != max_size; ++i)
226  		{
227  			nano::account_info const & info (i->second);
228  			nano::account const & account (i->first);
229  			accounts.emplace_back (account, info.head);
230  		}
231  		if (accounts.size () != max_size)
232  		{
233  			accounts.emplace_back (nano::account{}, nano::block_hash (0));
234  		}
235  	}
236  	auto const & account_pair (accounts.front ());
237  	current = account_pair.first;
238  	frontier = account_pair.second;
239  	accounts.pop_front ();
240  }
241  nano::frontier_req_server::frontier_req_server (std::shared_ptr<nano::transport::tcp_server> const & connection_a, std::unique_ptr<nano::frontier_req> request_a) :
242  	connection (connection_a),
243  	current (request_a->start.number () - 1),
244  	frontier (0),
245  	request (std::move (request_a)),
246  	count (0)
247  {
248  	next ();
249  }
250  void nano::frontier_req_server::send_next ()
251  {
252  	auto node = connection->node.lock ();
253  	if (!node)
254  	{
255  		return;
256  	}
257  	if (!current.is_zero () && count < request->count)
258  	{
259  		std::vector<uint8_t> send_buffer;
260  		{
261  			nano::vectorstream stream (send_buffer);
262  			write (stream, current.bytes);
263  			write (stream, frontier.bytes);
264  			debug_assert (!current.is_zero ());
265  			debug_assert (!frontier.is_zero ());
266  		}
267  		auto this_l (shared_from_this ());
268  		if (node->config.logging.bulk_pull_logging ())
269  		{
270  			node->logger.try_log (boost::str (boost::format ("Sending frontier for %1% %2%") % current.to_account () % frontier.to_string ()));
271  		}
272  		next ();
273  		connection->socket->async_write (nano::shared_const_buffer (std::move (send_buffer)), [this_l] (boost::system::error_code const & ec, std::size_t size_a) {
274  			this_l->sent_action (ec, size_a);
275  		});
276  	}
277  	else
278  	{
279  		send_finished ();
280  	}
281  }
282  void nano::frontier_req_server::send_finished ()
283  {
284  	auto node = connection->node.lock ();
285  	if (!node)
286  	{
287  		return;
288  	}
289  	std::vector<uint8_t> send_buffer;
290  	{
291  		nano::vectorstream stream (send_buffer);
292  		nano::uint256_union zero (0);
293  		write (stream, zero.bytes);
294  		write (stream, zero.bytes);
295  	}
296  	auto this_l (shared_from_this ());
297  	if (node->config.logging.network_logging ())
298  	{
299  		node->logger.try_log ("Frontier sending finished");
300  	}
301  	connection->socket->async_write (nano::shared_const_buffer (std::move (send_buffer)), [this_l] (boost::system::error_code const & ec, std::size_t size_a) {
302  		this_l->no_block_sent (ec, size_a);
303  	});
304  }
305  void nano::frontier_req_server::no_block_sent (boost::system::error_code const & ec, std::size_t size_a)
306  {
307  	auto node = connection->node.lock ();
308  	if (!node)
309  	{
310  		return;
311  	}
312  	if (!ec)
313  	{
314  		connection->start ();
315  	}
316  	else
317  	{
318  		if (node->config.logging.network_logging ())
319  		{
320  			node->logger.try_log (boost::str (boost::format ("Error sending frontier finish: %1%") % ec.message ()));
321  		}
322  	}
323  }
324  void nano::frontier_req_server::sent_action (boost::system::error_code const & ec, std::size_t size_a)
325  {
326  	auto node = connection->node.lock ();
327  	if (!node)
328  	{
329  		return;
330  	}
331  	if (!ec)
332  	{
333  		count++;
334  		node->bootstrap_workers.push_task ([this_l = shared_from_this ()] () {
335  			this_l->send_next ();
336  		});
337  	}
338  	else
339  	{
340  		if (node->config.logging.network_logging ())
341  		{
342  			node->logger.try_log (boost::str (boost::format ("Error sending frontier pair: %1%") % ec.message ()));
343  		}
344  	}
345  }
346  void nano::frontier_req_server::next ()
347  {
348  	auto node = connection->node.lock ();
349  	if (!node)
350  	{
351  		return;
352  	}
353  	if (accounts.empty ())
354  	{
355  		auto now (nano::seconds_since_epoch ());
356  		bool disable_age_filter (request->age == std::numeric_limits<decltype (request->age)>::max ());
357  		std::size_t max_size (128);
358  		auto transaction (node->store.tx_begin_read ());
359  		if (!send_confirmed ())
360  		{
361  			for (auto i (node->store.account.begin (transaction, current.number () + 1)), n (node->store.account.end ()); i != n && accounts.size () != max_size; ++i)
362  			{
363  				nano::account_info const & info (i->second);
364  				if (disable_age_filter || (now - info.modified) <= request->age)
365  				{
366  					nano::account const & account (i->first);
367  					accounts.emplace_back (account, info.head);
368  				}
369  			}
370  		}
371  		else
372  		{
373  			for (auto i (node->store.confirmation_height.begin (transaction, current.number () + 1)), n (node->store.confirmation_height.end ()); i != n && accounts.size () != max_size; ++i)
374  			{
375  				nano::confirmation_height_info const & info (i->second);
376  				nano::block_hash const & confirmed_frontier (info.frontier);
377  				if (!confirmed_frontier.is_zero ())
378  				{
379  					nano::account const & account (i->first);
380  					accounts.emplace_back (account, confirmed_frontier);
381  				}
382  			}
383  		}
384  		if (accounts.size () != max_size)
385  		{
386  			accounts.emplace_back (nano::account{}, nano::block_hash (0));
387  		}
388  	}
389  	auto const & account_pair (accounts.front ());
390  	current = account_pair.first;
391  	frontier = account_pair.second;
392  	accounts.pop_front ();
393  }
394  bool nano::frontier_req_server::send_confirmed ()
395  {
396  	return request->header.frontier_req_is_only_confirmed_present ();
397  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-blockprocessor_52.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-bootstrap_frontier.cpp</div>
                </div>
                <div class="column column_space"><pre><code>113  void nano::block_processor::rollback_competitor (nano::write_transaction const & transaction, nano::block const & block)
114  {
115  	auto hash = block.hash ();
</pre></code></div>
                <div class="column column_space"><pre><code>82  void nano::frontier_req_client::unsynced (nano::block_hash const & head, nano::block_hash const & end)
83  {
84  	if (bulk_push_available ())
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    