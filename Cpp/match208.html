<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for main.cpp & testRobotDevastation.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for main.cpp & testRobotDevastation.cpp
      </h3>
      <h1 align="center">
        9.6%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>main.cpp (39.02439%)<TH>testRobotDevastation.cpp (5.498282%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match208-0.html#0',2,'match208-1.html#0',3)" NAME="0">(46-61)<TD><A HREF="javascript:ZweiFrames('match208-0.html#0',2,'match208-1.html#0',3)" NAME="0">(70-85)</A><TD ALIGN=center><FONT COLOR="#ff0000">16</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>main.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
// Authors: see AUTHORS.md at project root.
// CopyPolicy: released under the terms of the LGPLv2.1, see LICENSE at project root.
// URL: https://github.com/asrob-uc3m/robotDevastation

/**
 *
 * @ingroup rd_programs
 * \defgroup robotDevastation robotDevastation
 *
 * @brief The Robot Devastation PC client. Creates an instance of the rd::RobotDevastation class.
 *
 * @section rd_robot_devastation_installation Installation
 *
 * The module is compiled when ENABLE_robotDevastation is activated (default: ON). For further
 * installation steps refer to &lt;a class=&quot;el&quot; href=&quot;pages.html&quot;&gt;your own system installation guidelines&lt;/a&gt;.
 *
 * @section rd_robot_devastation_running Running (assuming correct installation, see previous section)
 *
 * It should be straightforward to run the default test mode. Just click on the icon or open a terminal and write:
 *
\verbatim
robotDevastation
\endverbatim
 *
 * @section rd_robot_devastation_interfacing Interfacing with robotDevastation
 *
 * Press 'space' to shoot!
 *
 * @section rd_robot_devastation_modify Modify
 *
 * This file can be edited at
 * $RD_ROOT/src/programs/robotDevastation/main.cpp
 *
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;

#include &lt;yarp/os/LogStream.h&gt;
#include &lt;yarp/os/Network.h&gt;
#include &lt;yarp/os/ResourceFinder.h&gt;

<A NAME="0"></A>#include &quot;RobotDevastation.hpp&quot;

int main(int argc, char *argv[])
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match208-1.html#0',3,'match208-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>{
    std::printf(&quot;--------------------------------------------------------------\n&quot;);
    std::printf(&quot;Robot Devastation @ ASROB 2019 (C) Robotics Society of the Universidad Carlos III de Madrid\n&quot;);
    std::printf(&quot;Welcome to Robot Devastation v0.2, developed by David Estevez and Juan G Victores.\n&quot;);
    std::printf(&quot;Based on Robot Devastation v0.1, developed by Santiago Morante and Juan G Victores.\n&quot;);
    std::printf(&quot; ____       _           _   ____                      _        _   _             \n&quot;);
    std::printf(&quot;|  _ \\ ___ | |__   ___ | |_|  _ \\  _____   ____ _ ___| |_ __ _| |_(_) ___  _ __  \n&quot;);
    std::printf(&quot;| |_) / _ \\| '_ \\ / _ \\| __| | | |/ _ \\ \\ / / _` / __| __/ _` | __| |/ _ \\| '_ \\ \n&quot;);
    std::printf(&quot;|  _ &lt; (_) | |_) | (_) | |_| |_| |  __/\\ V / (_| \\__ \\ || (_| | |_| | (_) | | | |\n&quot;);
    std::printf(&quot;|_| \\_\\___/|_.__/ \\___/ \\__|____/ \\___| \\_/ \\__,_|___/\\__\\__,_|\\__|_|\\___/|_| |_|\n&quot;);
    std::printf(&quot;\n&quot;);
    std::printf(&quot;Fire with 'space'. Reload with 'r'. Move with 'Left, Up, Down, Right'. Run \&quot;robotDevastation --help\&quot; for help.\n&quot;);
    std::printf(&quot;For a full description, please visit http://wiki.asrob.uc3m.es/rddoc/group__robotDevastation.html.\n&quot;);
    std::printf(&quot;--------------------------------------------------------------\n&quot;);

    yarp::os::ResourceFinder rf;</B></FONT>
    rf.setVerbose(false);
    rf.setDefaultContext(&quot;robotDevastation&quot;);
    rf.setDefaultConfigFile(&quot;robotDevastation.ini&quot;);
    rf.configure(argc, argv);

    if(rf.check(&quot;help&quot;))
    {
        std::printf(&quot;RobotDevastation optional parameters:\n&quot;);
        std::printf(&quot;\t--help (this help)\t--from [file.ini]\t--context [path]\n&quot;);
        std::printf(&quot;\t--fakeRobotManager  //-- Fake robot motors\n&quot;);
        std::printf(&quot;\t--fakeImageManager  //-- Fake robot camera\n&quot;);
        std::printf(&quot;\t--yarpLocalImageManager  //-- Local webcam as camera\n&quot;);
        std::printf(&quot;\t--fullscreen //-- Fullscreen mode (experimental)\n&quot;);
        return 0;
    }

    yInfo() &lt;&lt; &quot;Checking for yarp network...&quot;;
    fflush(stdout);
    yarp::os::Network yarp;
    if ( ! yarp::os::Network::checkNetwork() )
    {
        yError() &lt;&lt; argv[0] &lt;&lt; &quot;found no yarp network (try running \&quot;yarpserver &amp;\&quot;)&quot;;
        return 1;
    }

    rd::RobotDevastation robotDevastation;
    return robotDevastation.runModule(rf);  //-- Internally calls rd::RobotDevastation::configure(yarp::os::ResourceFinder &amp;rf)
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>testRobotDevastation.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
// Authors: see AUTHORS.md at project root.
// CopyPolicy: released under the terms of the LGPLv2.1, see LICENSE at project root.
// URL: https://github.com/asrob-uc3m/robotDevastation

#include &quot;gtest/gtest.h&quot;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;yarp/os/Network.h&gt;
#include &lt;yarp/os/Time.h&gt;
#include &lt;yarp/sig/all.h&gt;
#include &lt;yarp/os/ResourceFinder.h&gt;

#include &quot;StateMachine.hpp&quot;
#include &quot;StateMachineBuilder.hpp&quot;
#include &quot;SDLUtils.hpp&quot;

#include &quot;MockNetworkManager.hpp&quot;
#include &quot;MockImageManager.hpp&quot;
#include &quot;MockInputManager.hpp&quot;
#include &quot;MentalMap.hpp&quot;
#include &quot;MockRobotManager.hpp&quot;
#include &quot;MockAudioManager.hpp&quot;
#include &quot;SDLScreenManager.hpp&quot;

//-- Game FSM
#include &quot;StateMachine.hpp&quot;
#include &quot;StateMachineBuilder.hpp&quot;
#include &quot;InitState.hpp&quot;
#include &quot;GameState.hpp&quot;
#include &quot;DeadState.hpp&quot;

namespace rd
{

namespace test
{

class RobotDevastationTestEnvironment : public testing::Environment
{
    public:
        RobotDevastationTestEnvironment(int argc, char ** argv)
        {
            this-&gt;argc = argc;
            this-&gt;argv = argv;
        }

        virtual void SetUp()
        {
            initSDL();
        }

        virtual void TearDown()
        {
            cleanupSDL();
        }


    private:
        int argc;
        char ** argv;

};

//-- Class for the setup of each test
//--------------------------------------------------------------------------------------
class RobotDevastationTest : public testing::Test
<A NAME="0"></A>{
    public:
        virtual void SetUp()
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match208-0.html#0',2,'match208-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>        {
            //-- Configure Resourcefinder to ind the real path to the resources
            yarp::os::ResourceFinder rf;
            rf.setDefaultContext(&quot;robotDevastation&quot;);
            rf.setDefaultConfigFile(&quot;robotDevastation.ini&quot;);

            //-- Start YARP network
            yarp::os::NetworkBase::setLocalMode(true);
            yarp::os::Network::init();

            //-- Load test images
            yarp::sig::file::read(test_frame_no_target, rf.findFileByName(FRAME_NO_TARGET_PATH));
            yarp::sig::file::read(test_frame_with_target, rf.findFileByName(FRAME_WITH_TARGET_PATH));

            //-- Init input manager
            MockInputManager::RegisterManager();</B></FONT>
            inputManager = InputManager::getInputManager(&quot;MOCK&quot;);
            mockInputManager = dynamic_cast&lt;MockInputManager *&gt;(inputManager);
            ASSERT_NE((InputManager*) NULL, inputManager);
            ASSERT_NE((MockInputManager*) NULL, mockInputManager);

            //-- Init sound
            MockAudioManager::RegisterManager();
            audioManager = AudioManager::getAudioManager(&quot;MOCK&quot;);
            mockAudioManager = dynamic_cast&lt;MockAudioManager *&gt;(audioManager);
            ASSERT_NE((AudioManager*) NULL, audioManager);
            ASSERT_NE((MockAudioManager*) NULL, mockAudioManager);
            mockAudioManager-&gt;load(&quot;RD_THEME&quot;,&quot;RD_THEME&quot;, AudioManager::MUSIC);
            mockAudioManager-&gt;load(&quot;RD_DEAD&quot;,&quot;RD_DEAD&quot;, AudioManager::MUSIC);
            mockAudioManager-&gt;load(&quot;shoot&quot;,&quot;shoot&quot;, AudioManager::FX);
            mockAudioManager-&gt;load(&quot;explosion&quot;,&quot;explosion&quot;, AudioManager::FX);
            mockAudioManager-&gt;load(&quot;noAmmo&quot;,&quot;noAmmo&quot;, AudioManager::FX);
            mockAudioManager-&gt;load(&quot;reload&quot;,&quot;reload&quot;, AudioManager::FX);

            //-- Init robot:
            mockRobotManager = new MockRobotManager(&quot;MOCK&quot;);
            robotManager = (asrob::IRobotManager *) mockRobotManager;
            ASSERT_NE((MockRobotManager*) NULL, mockRobotManager);
            ASSERT_NE((asrob::IRobotManager*) NULL, robotManager);

            //-- Init image manager
            MockImageManager::RegisterManager();
            imageManager = ImageManager::getImageManager(&quot;MOCK&quot;);
            mockImageManager = dynamic_cast&lt;MockImageManager *&gt;(imageManager);
            ASSERT_NE((ImageManager*) NULL, imageManager);
            ASSERT_NE((MockImageManager*) NULL, mockImageManager);

            //-- Init mental map
            mentalMap = MentalMap::getMentalMap();
            ASSERT_NE((MentalMap*) NULL, mentalMap);
            ASSERT_TRUE(mentalMap-&gt;configure(1));

            std::vector&lt;Player&gt; players;
            players.push_back(Player(1,&quot;test_player&quot;,MAX_HEALTH,MAX_HEALTH,0,0) );
            ASSERT_TRUE(mentalMap-&gt;updatePlayers(players));
            mentalMap-&gt;addWeapon(Weapon(&quot;Default gun&quot;, 10, MAX_AMMO));

            //-- Init network manager
            MockNetworkManager::RegisterManager();
            networkManager = NetworkManager::getNetworkManager(&quot;MOCK&quot;);
            mockNetworkManager = dynamic_cast&lt;MockNetworkManager *&gt;(networkManager);
            ASSERT_NE((NetworkManager*) NULL, networkManager);
            ASSERT_NE((MockNetworkManager*) NULL, mockNetworkManager);
            networkManager-&gt;configure(&quot;player&quot;, players[0]);

            //-- Init screen manager
            SDLScreenManager::RegisterManager();
            screenManager = ScreenManager::getScreenManager(&quot;SDL&quot;);
            ASSERT_NE((ScreenManager*) NULL, screenManager);
            screenManager-&gt;start();

            //-- Setup Game FSM
            StateMachineBuilder builder;
            builder.setDirectorType(&quot;YARP&quot;);

            //-- Create states
            init_state_id = builder.addState(new InitState(networkManager, imageManager, inputManager, mentalMap,
                                                               robotManager, audioManager, screenManager));
            game_state_id = builder.addState(new GameState(networkManager, imageManager, inputManager, mentalMap,
                                                               robotManager, audioManager, screenManager));
            dead_state_id = builder.addState(new DeadState(networkManager, imageManager, inputManager,
                                                               mentalMap, robotManager, audioManager, screenManager));
            end_state_id = builder.addState(State::getEndState());

            //-- Add transitions to other states
            builder.addTransition(init_state_id, game_state_id, InitState::LOGIN_SUCCESSFUL);
            builder.addTransition(init_state_id, end_state_id, InitState::EXIT_REQUESTED);
            builder.addTransition(game_state_id, dead_state_id, GameState::KILLED);
            builder.addTransition(game_state_id, end_state_id, GameState::EXIT_REQUESTED);
            builder.addTransition(dead_state_id, game_state_id, DeadState::RESPAWN_SELECTED);
            builder.addTransition(dead_state_id, end_state_id, DeadState::EXIT_SELECTED);

            //-- Set initial state
            builder.setInitialState(init_state_id);
            fsm = builder.buildStateMachine();
            ASSERT_NE((FiniteStateMachine*)NULL, fsm);
        }

        virtual void TearDown()
        {
            InputManager::destroyInputManager();
            inputManager = NULL;

            NetworkManager::destroyNetworkManager();
            networkManager = NULL;

            //-- Closing audio system:
            AudioManager::destroyAudioManager();
            audioManager = NULL;

            //-- Closing mental map:
            MentalMap::destroyMentalMap();
            mentalMap = NULL;

            //-- Close img related ports:
            ImageManager::destroyImageManager();
            imageManager = NULL;

            //-- Close robot:
            delete robotManager;
            robotManager = NULL;

            //-- Close screen:
            screenManager-&gt;stop();
            ScreenManager::destroyScreenManager();

            //-- Delete FSM:
            delete fsm;
            fsm = NULL;

            //-- Close YARP network
            yarp::os::Network::fini();
        }

    static const int MAX_HEALTH;
    static const int MAX_AMMO;

    protected:
        FiniteStateMachine *fsm;

        NetworkManager * networkManager;
        MockNetworkManager * mockNetworkManager;

        ImageManager * imageManager;
        MockImageManager * mockImageManager;

        InputManager * inputManager;
        MockInputManager * mockInputManager;

        AudioManager * audioManager;
        MockAudioManager * mockAudioManager;

        MentalMap * mentalMap;

        MockRobotManager * mockRobotManager;
        asrob::IRobotManager * robotManager;

        ScreenManager * screenManager;

        int init_state_id, game_state_id, dead_state_id, end_state_id;

        Image test_frame_no_target;
        Image test_frame_with_target;
        static const std::string FRAME_NO_TARGET_PATH;
        static const std::string FRAME_WITH_TARGET_PATH;
};

const int RobotDevastationTest::MAX_HEALTH = 100;
const int RobotDevastationTest::MAX_AMMO = 10;
const std::string RobotDevastationTest::FRAME_NO_TARGET_PATH = &quot;../images/test_frame_qr.ppm&quot;;
const std::string RobotDevastationTest::FRAME_WITH_TARGET_PATH = &quot;../images/test_frame_qr_centered.ppm&quot;;


//--- Tests ------------------------------------------------------------------------------------------
TEST_F(RobotDevastationTest, RobotDevastationWorks)
{
    //-- Check things that should happen before fsm starts (before setup):
    ASSERT_TRUE(mockAudioManager-&gt;isStopped());
    ASSERT_TRUE(mockNetworkManager-&gt;isStopped());
    ASSERT_TRUE(mockImageManager-&gt;isStopped());
    ASSERT_TRUE(mockInputManager-&gt;isStopped());

    //-- Start state machine
    ASSERT_TRUE(fsm-&gt;start());

    //-- Check things that should happen in initial state before login (loop):

    //yarp::os::Time::delay(1);
    ASSERT_FALSE(mockAudioManager-&gt;isStopped());
    ASSERT_TRUE(mockAudioManager-&gt;isPlaying(&quot;RD_THEME&quot;));
    ASSERT_FALSE(mockNetworkManager-&gt;isStopped());
    ASSERT_FALSE(mockNetworkManager-&gt;isLoggedIn());
    ASSERT_TRUE(mockImageManager-&gt;isStopped());
    ASSERT_FALSE(mockImageManager-&gt;isEnabled());
    ASSERT_FALSE(mockInputManager-&gt;isStopped());
    ASSERT_EQ(1, mockInputManager-&gt;getNumListeners());

    //-- When enter is pressed, the system should log in and go to next state:
    mockInputManager-&gt;sendKeyPress(Key::KEY_ENTER);
    yarp::os::Time::delay(0.5);

    //-- Check things that should happen just after the fsm starts (after setup)
    //----------------------------------------------------------------------------
    ASSERT_FALSE(mockAudioManager-&gt;isStopped());
    ASSERT_TRUE(mockAudioManager-&gt;isPlaying(&quot;RD_THEME&quot;));
    ASSERT_FALSE(mockNetworkManager-&gt;isStopped());
    ASSERT_TRUE(mockNetworkManager-&gt;isLoggedIn());
    ASSERT_FALSE(mockImageManager-&gt;isStopped());
    ASSERT_TRUE(mockImageManager-&gt;isEnabled());
    ASSERT_FALSE(mockInputManager-&gt;isStopped());
    ASSERT_EQ(1, mockInputManager-&gt;getNumListeners());

    //-- Testing game flow
    //-----------------------------------------------------------------------------
    //-- Check that GameState is active
    ASSERT_EQ(game_state_id, fsm-&gt;getCurrentState());

    //-- If my robot is hit, health decreases
    ASSERT_TRUE(mockNetworkManager-&gt;sendPlayerHit(mentalMap-&gt;getMyself(), 50));
    yarp::os::Time::delay(0.5);
    ASSERT_EQ(50, mentalMap-&gt;getMyself().getHealth());

    //-- If I send move commands, robot moves

    //-- Left
    mockInputManager-&gt;sendKeyDown(GameState::KEY_TURN_LEFT);
    yarp::os::Time::delay(0.5);
    ASSERT_TRUE(mockRobotManager-&gt;isMoving());
    ASSERT_EQ(MockRobotManager::LEFT, ((MockRobotManager *)robotManager)-&gt;getMovementDirection());
    mockInputManager-&gt;sendKeyUp(GameState::KEY_TURN_LEFT);
    yarp::os::Time::delay(0.5);
    ASSERT_FALSE(mockRobotManager-&gt;isMoving());
    ASSERT_EQ(MockRobotManager::NONE, ((MockRobotManager *)robotManager)-&gt;getMovementDirection());

    //-- Right
    mockInputManager-&gt;sendKeyDown(GameState::KEY_TURN_RIGHT);
    yarp::os::Time::delay(0.5);
    ASSERT_TRUE(mockRobotManager-&gt;isMoving());
    ASSERT_EQ(MockRobotManager::RIGHT,((MockRobotManager *)robotManager)-&gt;getMovementDirection());
    mockInputManager-&gt;sendKeyUp(GameState::KEY_TURN_RIGHT);
    yarp::os::Time::delay(0.5);
    ASSERT_FALSE(mockRobotManager-&gt;isMoving());
    ASSERT_EQ(MockRobotManager::NONE, ((MockRobotManager *)robotManager)-&gt;getMovementDirection());

    //-- Forward
    mockInputManager-&gt;sendKeyDown(GameState::KEY_MOVE_FWD);
    yarp::os::Time::delay(0.5);
    ASSERT_TRUE(mockRobotManager-&gt;isMoving());
    ASSERT_EQ(MockRobotManager::FORWARD, ((MockRobotManager *)robotManager)-&gt;getMovementDirection());
    mockInputManager-&gt;sendKeyUp(GameState::KEY_MOVE_FWD);
    yarp::os::Time::delay(0.5);
    ASSERT_FALSE(mockRobotManager-&gt;isMoving());
    ASSERT_EQ(MockRobotManager::NONE, ((MockRobotManager *)robotManager)-&gt;getMovementDirection());

    //-- Backwards
    mockInputManager-&gt;sendKeyDown(GameState::KEY_MOVE_BACK);
    yarp::os::Time::delay(0.5);
    ASSERT_TRUE(mockRobotManager-&gt;isMoving());
    ASSERT_EQ(MockRobotManager::BACKWARDS, ((MockRobotManager *)robotManager)-&gt;getMovementDirection());
    mockInputManager-&gt;sendKeyUp(GameState::KEY_MOVE_BACK);
    yarp::os::Time::delay(0.5);
    ASSERT_FALSE(mockRobotManager-&gt;isMoving());
    ASSERT_EQ(MockRobotManager::NONE, ((MockRobotManager *)robotManager)-&gt;getMovementDirection());

    //-- If I shoot with no target in the scope, the enemies life is kept equal
    mockImageManager-&gt;receiveImage(test_frame_no_target);
    yarp::os::Time::delay(0.5);
    std::vector&lt;Player&gt; players_before = mentalMap-&gt;getPlayers();
    mockInputManager-&gt;sendKeyPress(GameState::KEY_SHOOT);
    std::vector&lt;Player&gt; players_after = mentalMap-&gt;getPlayers();
    ASSERT_EQ(players_before.size(), players_after.size());
    for(int i = 0; i &lt; (int) players_before.size(); i++)
        EXPECT_EQ(players_before[i].getHealth(), players_after[i].getHealth());

    //-- If I shoot all ammo, I run out of ammo, and I cannot shoot until reloading
    for(int i = 0; i &lt; MAX_AMMO; i++)
        mockInputManager-&gt;sendKeyPress(GameState::KEY_SHOOT);
    ASSERT_EQ(0, mentalMap-&gt;getCurrentWeapon().getCurrentAmmo());
    yarp::os::Time::delay(0.5);

    //-- After reloading, I can shoot again
    mockInputManager-&gt;sendKeyPress('r');
    ASSERT_EQ(MAX_AMMO, mentalMap-&gt;getCurrentWeapon().getCurrentAmmo());

    //-- If I hit other robot, other robot health decreases
    mockImageManager-&gt;receiveImage(test_frame_with_target);
    yarp::os::Time::delay(0.5);
    players_before = mentalMap-&gt;getPlayers();
    mockInputManager-&gt;sendKeyPress(GameState::KEY_SHOOT);
    yarp::os::Time::delay(0.5);
    players_after = mentalMap-&gt;getPlayers();
    ASSERT_EQ(players_before.size(), players_after.size());
    for(int i = 0; i &lt; (int) players_before.size(); i++)
        if (players_before[i].getId() != mentalMap-&gt;getMyself().getId())
        {
            ASSERT_EQ(players_before[i].getId(), players_after[i].getId());
            EXPECT_LT(players_after[i].getHealth(), players_before[i].getHealth());
        }

    //-- If I lose all health, game is over
    ASSERT_TRUE(mockNetworkManager-&gt;sendPlayerHit(mentalMap-&gt;getMyself(), 50));
    ASSERT_EQ(0, mentalMap-&gt;getMyself().getHealth());

    //-- Check that deadState is active
    yarp::os::Time::delay(0.5);
    ASSERT_EQ(dead_state_id, fsm-&gt;getCurrentState());


    //-- Check things that should happen in dead state before time runs out (setup):
    ASSERT_EQ(0, mentalMap-&gt;getMyself().getHealth()); //-- Important thing to check
    ASSERT_FALSE(mockImageManager-&gt;isStopped());
    ASSERT_FALSE(mockImageManager-&gt;isEnabled());
    ASSERT_FALSE(mockInputManager-&gt;isStopped());
    ASSERT_EQ(0, mockInputManager-&gt;getNumListeners());
    ASSERT_FALSE(mockAudioManager-&gt;isStopped());
    ASSERT_FALSE(mockAudioManager-&gt;isPlaying(&quot;RD_THEME&quot;));
    ASSERT_TRUE(mockAudioManager-&gt;isPlaying(&quot;RD_DEAD&quot;));
    ASSERT_FALSE(mockNetworkManager-&gt;isStopped());
    ASSERT_TRUE(mockNetworkManager-&gt;isLoggedIn());

    //-- Check that deadState is active
    ASSERT_EQ(dead_state_id, fsm-&gt;getCurrentState());

    //-- When enter is pressed, but the countdown is still active, input is ignored
    yarp::os::Time::delay(0.5);
    mockInputManager-&gt;sendKeyPress(Key::KEY_ENTER);
    yarp::os::Time::delay(0.5);
    ASSERT_EQ(dead_state_id, fsm-&gt;getCurrentState());

    //-- When time is up, and esc is pressed, the system should exit the game:
    yarp::os::Time::delay(10);
    ASSERT_EQ(1, mockInputManager-&gt;getNumListeners());
    mockInputManager-&gt;sendKeyPress(Key::KEY_ESCAPE);
    yarp::os::Time::delay(0.5);

    //-- Check that it has stopped things and it is in the final state (cleanup):
    ASSERT_TRUE(mockImageManager-&gt;isStopped());
    ASSERT_FALSE(mockImageManager-&gt;isEnabled());
    ASSERT_TRUE(mockInputManager-&gt;isStopped());
    ASSERT_EQ(0, mockInputManager-&gt;getNumListeners());
    ASSERT_TRUE(mockAudioManager-&gt;isStopped());
    ASSERT_FALSE(mockAudioManager-&gt;isPlaying(&quot;RD_THEME&quot;));
    ASSERT_FALSE(mockAudioManager-&gt;isPlaying(&quot;RD_DEAD&quot;));
    ASSERT_TRUE(mockNetworkManager-&gt;isStopped());
    ASSERT_FALSE(mockNetworkManager-&gt;isLoggedIn());

    //-- Check that end state is active
    ASSERT_EQ(-1, fsm-&gt;getCurrentState()); //-- (When FSM is ended, no state is active, hence -1)

}

}  // namespace test

}  // namespace rd

//--- Main -------------------------------------------------------------------------------------------
int main(int argc, char **argv)
{
  testing::InitGoogleTest(&amp;argc, argv);
  testing::Environment* env = testing::AddGlobalTestEnvironment(new rd::test::RobotDevastationTestEnvironment(argc, argv));
  return RUN_ALL_TESTS();
}
</PRE>
</div>
  </div>
</body>
</html>
