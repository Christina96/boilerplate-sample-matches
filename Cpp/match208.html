<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for main.cpp &amp; testRobotDevastation.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for main.cpp &amp; testRobotDevastation.cpp
      </h3>
<h1 align="center">
        9.6%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>main.cpp (39.02439%)<th>testRobotDevastation.cpp (5.498282%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(46-61)<td><a href="#" name="0">(70-85)</a><td align="center"><font color="#ff0000">16</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>main.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
// Authors: see AUTHORS.md at project root.
// CopyPolicy: released under the terms of the LGPLv2.1, see LICENSE at project root.
// URL: https://github.com/asrob-uc3m/robotDevastation

/**
 *
 * @ingroup rd_programs
 * \defgroup robotDevastation robotDevastation
 *
 * @brief The Robot Devastation PC client. Creates an instance of the rd::RobotDevastation class.
 *
 * @section rd_robot_devastation_installation Installation
 *
 * The module is compiled when ENABLE_robotDevastation is activated (default: ON). For further
 * installation steps refer to &lt;a class="el" href="pages.html"&gt;your own system installation guidelines&lt;/a&gt;.
 *
 * @section rd_robot_devastation_running Running (assuming correct installation, see previous section)
 *
 * It should be straightforward to run the default test mode. Just click on the icon or open a terminal and write:
 *
\verbatim
robotDevastation
\endverbatim
 *
 * @section rd_robot_devastation_interfacing Interfacing with robotDevastation
 *
 * Press 'space' to shoot!
 *
 * @section rd_robot_devastation_modify Modify
 *
 * This file can be edited at
 * $RD_ROOT/src/programs/robotDevastation/main.cpp
 *
 */

#include &lt;cstdio&gt;
#include &lt;iostream&gt;

#include &lt;yarp/os/LogStream.h&gt;
#include &lt;yarp/os/Network.h&gt;
#include &lt;yarp/os/ResourceFinder.h&gt;

<a name="0"></a>#include "RobotDevastation.hpp"

int main(int argc, char *argv[])
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>{
    std::printf("--------------------------------------------------------------\n");
    std::printf("Robot Devastation @ ASROB 2019 (C) Robotics Society of the Universidad Carlos III de Madrid\n");
    std::printf("Welcome to Robot Devastation v0.2, developed by David Estevez and Juan G Victores.\n");
    std::printf("Based on Robot Devastation v0.1, developed by Santiago Morante and Juan G Victores.\n");
    std::printf(" ____       _           _   ____                      _        _   _             \n");
    std::printf("|  _ \\ ___ | |__   ___ | |_|  _ \\  _____   ____ _ ___| |_ __ _| |_(_) ___  _ __  \n");
    std::printf("| |_) / _ \\| '_ \\ / _ \\| __| | | |/ _ \\ \\ / / _` / __| __/ _` | __| |/ _ \\| '_ \\ \n");
    std::printf("|  _ &lt; (_) | |_) | (_) | |_| |_| |  __/\\ V / (_| \\__ \\ || (_| | |_| | (_) | | | |\n");
    std::printf("|_| \\_\\___/|_.__/ \\___/ \\__|____/ \\___| \\_/ \\__,_|___/\\__\\__,_|\\__|_|\\___/|_| |_|\n");
    std::printf("\n");
    std::printf("Fire with 'space'. Reload with 'r'. Move with 'Left, Up, Down, Right'. Run \"robotDevastation --help\" for help.\n");
    std::printf("For a full description, please visit http://wiki.asrob.uc3m.es/rddoc/group__robotDevastation.html.\n");
    std::printf("--------------------------------------------------------------\n");

    yarp::os::ResourceFinder rf;</b></font>
    rf.setVerbose(false);
    rf.setDefaultContext("robotDevastation");
    rf.setDefaultConfigFile("robotDevastation.ini");
    rf.configure(argc, argv);

    if(rf.check("help"))
    {
        std::printf("RobotDevastation optional parameters:\n");
        std::printf("\t--help (this help)\t--from [file.ini]\t--context [path]\n");
        std::printf("\t--fakeRobotManager  //-- Fake robot motors\n");
        std::printf("\t--fakeImageManager  //-- Fake robot camera\n");
        std::printf("\t--yarpLocalImageManager  //-- Local webcam as camera\n");
        std::printf("\t--fullscreen //-- Fullscreen mode (experimental)\n");
        return 0;
    }

    yInfo() &lt;&lt; "Checking for yarp network...";
    fflush(stdout);
    yarp::os::Network yarp;
    if ( ! yarp::os::Network::checkNetwork() )
    {
        yError() &lt;&lt; argv[0] &lt;&lt; "found no yarp network (try running \"yarpserver &amp;\")";
        return 1;
    }

    rd::RobotDevastation robotDevastation;
    return robotDevastation.runModule(rf);  //-- Internally calls rd::RobotDevastation::configure(yarp::os::ResourceFinder &amp;rf)
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>testRobotDevastation.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
// Authors: see AUTHORS.md at project root.
// CopyPolicy: released under the terms of the LGPLv2.1, see LICENSE at project root.
// URL: https://github.com/asrob-uc3m/robotDevastation

#include "gtest/gtest.h"
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;yarp/os/Network.h&gt;
#include &lt;yarp/os/Time.h&gt;
#include &lt;yarp/sig/all.h&gt;
#include &lt;yarp/os/ResourceFinder.h&gt;

#include "StateMachine.hpp"
#include "StateMachineBuilder.hpp"
#include "SDLUtils.hpp"

#include "MockNetworkManager.hpp"
#include "MockImageManager.hpp"
#include "MockInputManager.hpp"
#include "MentalMap.hpp"
#include "MockRobotManager.hpp"
#include "MockAudioManager.hpp"
#include "SDLScreenManager.hpp"

//-- Game FSM
#include "StateMachine.hpp"
#include "StateMachineBuilder.hpp"
#include "InitState.hpp"
#include "GameState.hpp"
#include "DeadState.hpp"

namespace rd
{

namespace test
{

class RobotDevastationTestEnvironment : public testing::Environment
{
    public:
        RobotDevastationTestEnvironment(int argc, char ** argv)
        {
            this-&gt;argc = argc;
            this-&gt;argv = argv;
        }

        virtual void SetUp()
        {
            initSDL();
        }

        virtual void TearDown()
        {
            cleanupSDL();
        }


    private:
        int argc;
        char ** argv;

};

//-- Class for the setup of each test
//--------------------------------------------------------------------------------------
class RobotDevastationTest : public testing::Test
<a name="0"></a>{
    public:
        virtual void SetUp()
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>        {
            //-- Configure Resourcefinder to ind the real path to the resources
            yarp::os::ResourceFinder rf;
            rf.setDefaultContext("robotDevastation");
            rf.setDefaultConfigFile("robotDevastation.ini");

            //-- Start YARP network
            yarp::os::NetworkBase::setLocalMode(true);
            yarp::os::Network::init();

            //-- Load test images
            yarp::sig::file::read(test_frame_no_target, rf.findFileByName(FRAME_NO_TARGET_PATH));
            yarp::sig::file::read(test_frame_with_target, rf.findFileByName(FRAME_WITH_TARGET_PATH));

            //-- Init input manager
            MockInputManager::RegisterManager();</b></font>
            inputManager = InputManager::getInputManager("MOCK");
            mockInputManager = dynamic_cast&lt;MockInputManager *&gt;(inputManager);
            ASSERT_NE((InputManager*) NULL, inputManager);
            ASSERT_NE((MockInputManager*) NULL, mockInputManager);

            //-- Init sound
            MockAudioManager::RegisterManager();
            audioManager = AudioManager::getAudioManager("MOCK");
            mockAudioManager = dynamic_cast&lt;MockAudioManager *&gt;(audioManager);
            ASSERT_NE((AudioManager*) NULL, audioManager);
            ASSERT_NE((MockAudioManager*) NULL, mockAudioManager);
            mockAudioManager-&gt;load("RD_THEME","RD_THEME", AudioManager::MUSIC);
            mockAudioManager-&gt;load("RD_DEAD","RD_DEAD", AudioManager::MUSIC);
            mockAudioManager-&gt;load("shoot","shoot", AudioManager::FX);
            mockAudioManager-&gt;load("explosion","explosion", AudioManager::FX);
            mockAudioManager-&gt;load("noAmmo","noAmmo", AudioManager::FX);
            mockAudioManager-&gt;load("reload","reload", AudioManager::FX);

            //-- Init robot:
            mockRobotManager = new MockRobotManager("MOCK");
            robotManager = (asrob::IRobotManager *) mockRobotManager;
            ASSERT_NE((MockRobotManager*) NULL, mockRobotManager);
            ASSERT_NE((asrob::IRobotManager*) NULL, robotManager);

            //-- Init image manager
            MockImageManager::RegisterManager();
            imageManager = ImageManager::getImageManager("MOCK");
            mockImageManager = dynamic_cast&lt;MockImageManager *&gt;(imageManager);
            ASSERT_NE((ImageManager*) NULL, imageManager);
            ASSERT_NE((MockImageManager*) NULL, mockImageManager);

            //-- Init mental map
            mentalMap = MentalMap::getMentalMap();
            ASSERT_NE((MentalMap*) NULL, mentalMap);
            ASSERT_TRUE(mentalMap-&gt;configure(1));

            std::vector&lt;Player&gt; players;
            players.push_back(Player(1,"test_player",MAX_HEALTH,MAX_HEALTH,0,0) );
            ASSERT_TRUE(mentalMap-&gt;updatePlayers(players));
            mentalMap-&gt;addWeapon(Weapon("Default gun", 10, MAX_AMMO));

            //-- Init network manager
            MockNetworkManager::RegisterManager();
            networkManager = NetworkManager::getNetworkManager("MOCK");
            mockNetworkManager = dynamic_cast&lt;MockNetworkManager *&gt;(networkManager);
            ASSERT_NE((NetworkManager*) NULL, networkManager);
            ASSERT_NE((MockNetworkManager*) NULL, mockNetworkManager);
            networkManager-&gt;configure("player", players[0]);

            //-- Init screen manager
            SDLScreenManager::RegisterManager();
            screenManager = ScreenManager::getScreenManager("SDL");
            ASSERT_NE((ScreenManager*) NULL, screenManager);
            screenManager-&gt;start();

            //-- Setup Game FSM
            StateMachineBuilder builder;
            builder.setDirectorType("YARP");

            //-- Create states
            init_state_id = builder.addState(new InitState(networkManager, imageManager, inputManager, mentalMap,
                                                               robotManager, audioManager, screenManager));
            game_state_id = builder.addState(new GameState(networkManager, imageManager, inputManager, mentalMap,
                                                               robotManager, audioManager, screenManager));
            dead_state_id = builder.addState(new DeadState(networkManager, imageManager, inputManager,
                                                               mentalMap, robotManager, audioManager, screenManager));
            end_state_id = builder.addState(State::getEndState());

            //-- Add transitions to other states
            builder.addTransition(init_state_id, game_state_id, InitState::LOGIN_SUCCESSFUL);
            builder.addTransition(init_state_id, end_state_id, InitState::EXIT_REQUESTED);
            builder.addTransition(game_state_id, dead_state_id, GameState::KILLED);
            builder.addTransition(game_state_id, end_state_id, GameState::EXIT_REQUESTED);
            builder.addTransition(dead_state_id, game_state_id, DeadState::RESPAWN_SELECTED);
            builder.addTransition(dead_state_id, end_state_id, DeadState::EXIT_SELECTED);

            //-- Set initial state
            builder.setInitialState(init_state_id);
            fsm = builder.buildStateMachine();
            ASSERT_NE((FiniteStateMachine*)NULL, fsm);
        }

        virtual void TearDown()
        {
            InputManager::destroyInputManager();
            inputManager = NULL;

            NetworkManager::destroyNetworkManager();
            networkManager = NULL;

            //-- Closing audio system:
            AudioManager::destroyAudioManager();
            audioManager = NULL;

            //-- Closing mental map:
            MentalMap::destroyMentalMap();
            mentalMap = NULL;

            //-- Close img related ports:
            ImageManager::destroyImageManager();
            imageManager = NULL;

            //-- Close robot:
            delete robotManager;
            robotManager = NULL;

            //-- Close screen:
            screenManager-&gt;stop();
            ScreenManager::destroyScreenManager();

            //-- Delete FSM:
            delete fsm;
            fsm = NULL;

            //-- Close YARP network
            yarp::os::Network::fini();
        }

    static const int MAX_HEALTH;
    static const int MAX_AMMO;

    protected:
        FiniteStateMachine *fsm;

        NetworkManager * networkManager;
        MockNetworkManager * mockNetworkManager;

        ImageManager * imageManager;
        MockImageManager * mockImageManager;

        InputManager * inputManager;
        MockInputManager * mockInputManager;

        AudioManager * audioManager;
        MockAudioManager * mockAudioManager;

        MentalMap * mentalMap;

        MockRobotManager * mockRobotManager;
        asrob::IRobotManager * robotManager;

        ScreenManager * screenManager;

        int init_state_id, game_state_id, dead_state_id, end_state_id;

        Image test_frame_no_target;
        Image test_frame_with_target;
        static const std::string FRAME_NO_TARGET_PATH;
        static const std::string FRAME_WITH_TARGET_PATH;
};

const int RobotDevastationTest::MAX_HEALTH = 100;
const int RobotDevastationTest::MAX_AMMO = 10;
const std::string RobotDevastationTest::FRAME_NO_TARGET_PATH = "../images/test_frame_qr.ppm";
const std::string RobotDevastationTest::FRAME_WITH_TARGET_PATH = "../images/test_frame_qr_centered.ppm";


//--- Tests ------------------------------------------------------------------------------------------
TEST_F(RobotDevastationTest, RobotDevastationWorks)
{
    //-- Check things that should happen before fsm starts (before setup):
    ASSERT_TRUE(mockAudioManager-&gt;isStopped());
    ASSERT_TRUE(mockNetworkManager-&gt;isStopped());
    ASSERT_TRUE(mockImageManager-&gt;isStopped());
    ASSERT_TRUE(mockInputManager-&gt;isStopped());

    //-- Start state machine
    ASSERT_TRUE(fsm-&gt;start());

    //-- Check things that should happen in initial state before login (loop):

    //yarp::os::Time::delay(1);
    ASSERT_FALSE(mockAudioManager-&gt;isStopped());
    ASSERT_TRUE(mockAudioManager-&gt;isPlaying("RD_THEME"));
    ASSERT_FALSE(mockNetworkManager-&gt;isStopped());
    ASSERT_FALSE(mockNetworkManager-&gt;isLoggedIn());
    ASSERT_TRUE(mockImageManager-&gt;isStopped());
    ASSERT_FALSE(mockImageManager-&gt;isEnabled());
    ASSERT_FALSE(mockInputManager-&gt;isStopped());
    ASSERT_EQ(1, mockInputManager-&gt;getNumListeners());

    //-- When enter is pressed, the system should log in and go to next state:
    mockInputManager-&gt;sendKeyPress(Key::KEY_ENTER);
    yarp::os::Time::delay(0.5);

    //-- Check things that should happen just after the fsm starts (after setup)
    //----------------------------------------------------------------------------
    ASSERT_FALSE(mockAudioManager-&gt;isStopped());
    ASSERT_TRUE(mockAudioManager-&gt;isPlaying("RD_THEME"));
    ASSERT_FALSE(mockNetworkManager-&gt;isStopped());
    ASSERT_TRUE(mockNetworkManager-&gt;isLoggedIn());
    ASSERT_FALSE(mockImageManager-&gt;isStopped());
    ASSERT_TRUE(mockImageManager-&gt;isEnabled());
    ASSERT_FALSE(mockInputManager-&gt;isStopped());
    ASSERT_EQ(1, mockInputManager-&gt;getNumListeners());

    //-- Testing game flow
    //-----------------------------------------------------------------------------
    //-- Check that GameState is active
    ASSERT_EQ(game_state_id, fsm-&gt;getCurrentState());

    //-- If my robot is hit, health decreases
    ASSERT_TRUE(mockNetworkManager-&gt;sendPlayerHit(mentalMap-&gt;getMyself(), 50));
    yarp::os::Time::delay(0.5);
    ASSERT_EQ(50, mentalMap-&gt;getMyself().getHealth());

    //-- If I send move commands, robot moves

    //-- Left
    mockInputManager-&gt;sendKeyDown(GameState::KEY_TURN_LEFT);
    yarp::os::Time::delay(0.5);
    ASSERT_TRUE(mockRobotManager-&gt;isMoving());
    ASSERT_EQ(MockRobotManager::LEFT, ((MockRobotManager *)robotManager)-&gt;getMovementDirection());
    mockInputManager-&gt;sendKeyUp(GameState::KEY_TURN_LEFT);
    yarp::os::Time::delay(0.5);
    ASSERT_FALSE(mockRobotManager-&gt;isMoving());
    ASSERT_EQ(MockRobotManager::NONE, ((MockRobotManager *)robotManager)-&gt;getMovementDirection());

    //-- Right
    mockInputManager-&gt;sendKeyDown(GameState::KEY_TURN_RIGHT);
    yarp::os::Time::delay(0.5);
    ASSERT_TRUE(mockRobotManager-&gt;isMoving());
    ASSERT_EQ(MockRobotManager::RIGHT,((MockRobotManager *)robotManager)-&gt;getMovementDirection());
    mockInputManager-&gt;sendKeyUp(GameState::KEY_TURN_RIGHT);
    yarp::os::Time::delay(0.5);
    ASSERT_FALSE(mockRobotManager-&gt;isMoving());
    ASSERT_EQ(MockRobotManager::NONE, ((MockRobotManager *)robotManager)-&gt;getMovementDirection());

    //-- Forward
    mockInputManager-&gt;sendKeyDown(GameState::KEY_MOVE_FWD);
    yarp::os::Time::delay(0.5);
    ASSERT_TRUE(mockRobotManager-&gt;isMoving());
    ASSERT_EQ(MockRobotManager::FORWARD, ((MockRobotManager *)robotManager)-&gt;getMovementDirection());
    mockInputManager-&gt;sendKeyUp(GameState::KEY_MOVE_FWD);
    yarp::os::Time::delay(0.5);
    ASSERT_FALSE(mockRobotManager-&gt;isMoving());
    ASSERT_EQ(MockRobotManager::NONE, ((MockRobotManager *)robotManager)-&gt;getMovementDirection());

    //-- Backwards
    mockInputManager-&gt;sendKeyDown(GameState::KEY_MOVE_BACK);
    yarp::os::Time::delay(0.5);
    ASSERT_TRUE(mockRobotManager-&gt;isMoving());
    ASSERT_EQ(MockRobotManager::BACKWARDS, ((MockRobotManager *)robotManager)-&gt;getMovementDirection());
    mockInputManager-&gt;sendKeyUp(GameState::KEY_MOVE_BACK);
    yarp::os::Time::delay(0.5);
    ASSERT_FALSE(mockRobotManager-&gt;isMoving());
    ASSERT_EQ(MockRobotManager::NONE, ((MockRobotManager *)robotManager)-&gt;getMovementDirection());

    //-- If I shoot with no target in the scope, the enemies life is kept equal
    mockImageManager-&gt;receiveImage(test_frame_no_target);
    yarp::os::Time::delay(0.5);
    std::vector&lt;Player&gt; players_before = mentalMap-&gt;getPlayers();
    mockInputManager-&gt;sendKeyPress(GameState::KEY_SHOOT);
    std::vector&lt;Player&gt; players_after = mentalMap-&gt;getPlayers();
    ASSERT_EQ(players_before.size(), players_after.size());
    for(int i = 0; i &lt; (int) players_before.size(); i++)
        EXPECT_EQ(players_before[i].getHealth(), players_after[i].getHealth());

    //-- If I shoot all ammo, I run out of ammo, and I cannot shoot until reloading
    for(int i = 0; i &lt; MAX_AMMO; i++)
        mockInputManager-&gt;sendKeyPress(GameState::KEY_SHOOT);
    ASSERT_EQ(0, mentalMap-&gt;getCurrentWeapon().getCurrentAmmo());
    yarp::os::Time::delay(0.5);

    //-- After reloading, I can shoot again
    mockInputManager-&gt;sendKeyPress('r');
    ASSERT_EQ(MAX_AMMO, mentalMap-&gt;getCurrentWeapon().getCurrentAmmo());

    //-- If I hit other robot, other robot health decreases
    mockImageManager-&gt;receiveImage(test_frame_with_target);
    yarp::os::Time::delay(0.5);
    players_before = mentalMap-&gt;getPlayers();
    mockInputManager-&gt;sendKeyPress(GameState::KEY_SHOOT);
    yarp::os::Time::delay(0.5);
    players_after = mentalMap-&gt;getPlayers();
    ASSERT_EQ(players_before.size(), players_after.size());
    for(int i = 0; i &lt; (int) players_before.size(); i++)
        if (players_before[i].getId() != mentalMap-&gt;getMyself().getId())
        {
            ASSERT_EQ(players_before[i].getId(), players_after[i].getId());
            EXPECT_LT(players_after[i].getHealth(), players_before[i].getHealth());
        }

    //-- If I lose all health, game is over
    ASSERT_TRUE(mockNetworkManager-&gt;sendPlayerHit(mentalMap-&gt;getMyself(), 50));
    ASSERT_EQ(0, mentalMap-&gt;getMyself().getHealth());

    //-- Check that deadState is active
    yarp::os::Time::delay(0.5);
    ASSERT_EQ(dead_state_id, fsm-&gt;getCurrentState());


    //-- Check things that should happen in dead state before time runs out (setup):
    ASSERT_EQ(0, mentalMap-&gt;getMyself().getHealth()); //-- Important thing to check
    ASSERT_FALSE(mockImageManager-&gt;isStopped());
    ASSERT_FALSE(mockImageManager-&gt;isEnabled());
    ASSERT_FALSE(mockInputManager-&gt;isStopped());
    ASSERT_EQ(0, mockInputManager-&gt;getNumListeners());
    ASSERT_FALSE(mockAudioManager-&gt;isStopped());
    ASSERT_FALSE(mockAudioManager-&gt;isPlaying("RD_THEME"));
    ASSERT_TRUE(mockAudioManager-&gt;isPlaying("RD_DEAD"));
    ASSERT_FALSE(mockNetworkManager-&gt;isStopped());
    ASSERT_TRUE(mockNetworkManager-&gt;isLoggedIn());

    //-- Check that deadState is active
    ASSERT_EQ(dead_state_id, fsm-&gt;getCurrentState());

    //-- When enter is pressed, but the countdown is still active, input is ignored
    yarp::os::Time::delay(0.5);
    mockInputManager-&gt;sendKeyPress(Key::KEY_ENTER);
    yarp::os::Time::delay(0.5);
    ASSERT_EQ(dead_state_id, fsm-&gt;getCurrentState());

    //-- When time is up, and esc is pressed, the system should exit the game:
    yarp::os::Time::delay(10);
    ASSERT_EQ(1, mockInputManager-&gt;getNumListeners());
    mockInputManager-&gt;sendKeyPress(Key::KEY_ESCAPE);
    yarp::os::Time::delay(0.5);

    //-- Check that it has stopped things and it is in the final state (cleanup):
    ASSERT_TRUE(mockImageManager-&gt;isStopped());
    ASSERT_FALSE(mockImageManager-&gt;isEnabled());
    ASSERT_TRUE(mockInputManager-&gt;isStopped());
    ASSERT_EQ(0, mockInputManager-&gt;getNumListeners());
    ASSERT_TRUE(mockAudioManager-&gt;isStopped());
    ASSERT_FALSE(mockAudioManager-&gt;isPlaying("RD_THEME"));
    ASSERT_FALSE(mockAudioManager-&gt;isPlaying("RD_DEAD"));
    ASSERT_TRUE(mockNetworkManager-&gt;isStopped());
    ASSERT_FALSE(mockNetworkManager-&gt;isLoggedIn());

    //-- Check that end state is active
    ASSERT_EQ(-1, fsm-&gt;getCurrentState()); //-- (When FSM is ended, no state is active, hence -1)

}

}  // namespace test

}  // namespace rd

//--- Main -------------------------------------------------------------------------------------------
int main(int argc, char **argv)
{
  testing::InitGoogleTest(&amp;argc, argv);
  testing::Environment* env = testing::AddGlobalTestEnvironment(new rd::test::RobotDevastationTestEnvironment(argc, argv));
  return RUN_ALL_TESTS();
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerHTML.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
