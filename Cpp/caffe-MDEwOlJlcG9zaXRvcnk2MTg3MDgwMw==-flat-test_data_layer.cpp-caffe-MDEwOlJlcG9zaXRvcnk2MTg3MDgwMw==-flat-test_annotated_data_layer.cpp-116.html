
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 39, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_data_layer.cpp</h3>
            <pre><code>1  #ifdef USE_OPENCV
2  #include &lt;string&gt;
3  #include &lt;vector&gt;
4  #include &quot;boost/scoped_ptr.hpp&quot;
5  #include &quot;gtest/gtest.h&quot;
6  #include &quot;caffe/blob.hpp&quot;
7  #include &quot;caffe/common.hpp&quot;
8  #include &quot;caffe/filler.hpp&quot;
9  #include &quot;caffe/layers/data_layer.hpp&quot;
10  #include &quot;caffe/proto/caffe.pb.h&quot;
11  #include &quot;caffe/util/db.hpp&quot;
12  #include &quot;caffe/util/io.hpp&quot;
13  #include &quot;caffe/test/test_caffe_main.hpp&quot;
14  namespace caffe {
15  using boost::scoped_ptr;
16  template &lt;typename TypeParam&gt;
17  class DataLayerTest : public MultiDeviceTest&lt;TypeParam&gt; {
18    typedef typename TypeParam::Dtype Dtype;
19   protected:
20    DataLayerTest()
21        : backend_(DataParameter_DB_LEVELDB),
22          blob_top_data_(new Blob&lt;Dtype&gt;()),
23          blob_top_label_(new Blob&lt;Dtype&gt;()),
24          seed_(1701) {}
25    virtual void SetUp() {
<span onclick='openModal()' class='match'>26      filename_.reset(new string());
27      MakeTempDir(filename_.get());
28      *filename_ += &quot;/db&quot;;
29      blob_top_vec_.push_back(blob_top_data_);
30      blob_top_vec_.push_back(blob_top_label_);
31    }
32    void Fill(const bool unique_pixels, DataParameter_DB backend) {
</span>33      backend_ = backend;
34      LOG(INFO) &lt;&lt; &quot;Using temporary dataset &quot; &lt;&lt; *filename_;
35      scoped_ptr&lt;db::DB&gt; db(db::GetDB(backend));
36      db-&gt;Open(*filename_, db::NEW);
37      scoped_ptr&lt;db::Transaction&gt; txn(db-&gt;NewTransaction());
38      for (int i = 0; i &lt; 5; ++i) {
39        Datum datum;
40        datum.set_label(i);
41        datum.set_channels(2);
42        datum.set_height(3);
43        datum.set_width(4);
44        std::string* data = datum.mutable_data();
45        for (int j = 0; j &lt; 24; ++j) {
46          int datum = unique_pixels ? j : i;
47          data-&gt;push_back(static_cast&lt;uint8_t&gt;(datum));
48        }
49        stringstream ss;
50        ss &lt;&lt; i;
51        string out;
52        CHECK(datum.SerializeToString(&amp;out));
53        txn-&gt;Put(ss.str(), out);
54      }
55      txn-&gt;Commit();
56      db-&gt;Close();
57    }
58    void TestRead() {
59      const Dtype scale = 3;
60      LayerParameter param;
61      param.set_phase(TRAIN);
62      DataParameter* data_param = param.mutable_data_param();
63      data_param-&gt;set_batch_size(5);
64      data_param-&gt;set_source(filename_-&gt;c_str());
65      data_param-&gt;set_backend(backend_);
66      TransformationParameter* transform_param =
67          param.mutable_transform_param();
68      transform_param-&gt;set_scale(scale);
69      DataLayer&lt;Dtype&gt; layer(param);
70      layer.SetUp(blob_bottom_vec_, blob_top_vec_);
71      EXPECT_EQ(blob_top_data_-&gt;num(), 5);
72      EXPECT_EQ(blob_top_data_-&gt;channels(), 2);
73      EXPECT_EQ(blob_top_data_-&gt;height(), 3);
74      EXPECT_EQ(blob_top_data_-&gt;width(), 4);
75      EXPECT_EQ(blob_top_label_-&gt;num(), 5);
76      EXPECT_EQ(blob_top_label_-&gt;channels(), 1);
77      EXPECT_EQ(blob_top_label_-&gt;height(), 1);
78      EXPECT_EQ(blob_top_label_-&gt;width(), 1);
79      for (int iter = 0; iter &lt; 100; ++iter) {
80        layer.Forward(blob_bottom_vec_, blob_top_vec_);
81        for (int i = 0; i &lt; 5; ++i) {
82          EXPECT_EQ(i, blob_top_label_-&gt;cpu_data()[i]);
83        }
84        for (int i = 0; i &lt; 5; ++i) {
85          for (int j = 0; j &lt; 24; ++j) {
86            EXPECT_EQ(scale * i, blob_top_data_-&gt;cpu_data()[i * 24 + j])
87                &lt;&lt; &quot;debug: iter &quot; &lt;&lt; iter &lt;&lt; &quot; i &quot; &lt;&lt; i &lt;&lt; &quot; j &quot; &lt;&lt; j;
88          }
89        }
90      }
91    }
92    void TestReshape(DataParameter_DB backend) {
93      const int num_inputs = 5;
94      LOG(INFO) &lt;&lt; &quot;Using temporary dataset &quot; &lt;&lt; *filename_;
95      scoped_ptr&lt;db::DB&gt; db(db::GetDB(backend));
96      db-&gt;Open(*filename_, db::NEW);
97      scoped_ptr&lt;db::Transaction&gt; txn(db-&gt;NewTransaction());
98      for (int i = 0; i &lt; num_inputs; ++i) {
99        Datum datum;
100        datum.set_label(i);
101        datum.set_channels(2);
102        datum.set_height(i % 2 + 1);
103        datum.set_width(i % 4 + 1);
104        std::string* data = datum.mutable_data();
105        const int data_size = datum.channels() * datum.height() * datum.width();
106        for (int j = 0; j &lt; data_size; ++j) {
107          data-&gt;push_back(static_cast&lt;uint8_t&gt;(j));
108        }
109        stringstream ss;
110        ss &lt;&lt; i;
111        string out;
112        CHECK(datum.SerializeToString(&amp;out));
113        txn-&gt;Put(ss.str(), out);
114      }
115      txn-&gt;Commit();
116      db-&gt;Close();
117      LayerParameter param;
118      param.set_phase(TEST);
119      DataParameter* data_param = param.mutable_data_param();
120      data_param-&gt;set_batch_size(1);
121      data_param-&gt;set_source(filename_-&gt;c_str());
122      data_param-&gt;set_backend(backend);
123      DataLayer&lt;Dtype&gt; layer(param);
124      layer.SetUp(blob_bottom_vec_, blob_top_vec_);
125      EXPECT_EQ(blob_top_data_-&gt;num(), 1);
126      EXPECT_EQ(blob_top_data_-&gt;channels(), 2);
127      EXPECT_EQ(blob_top_label_-&gt;num(), 1);
128      EXPECT_EQ(blob_top_label_-&gt;channels(), 1);
129      EXPECT_EQ(blob_top_label_-&gt;height(), 1);
130      EXPECT_EQ(blob_top_label_-&gt;width(), 1);
131      for (int iter = 0; iter &lt; num_inputs; ++iter) {
132        layer.Forward(blob_bottom_vec_, blob_top_vec_);
133        EXPECT_EQ(blob_top_data_-&gt;height(), iter % 2 + 1);
134        EXPECT_EQ(blob_top_data_-&gt;width(), iter % 4 + 1);
135        EXPECT_EQ(iter, blob_top_label_-&gt;cpu_data()[0]);
136        const int channels = blob_top_data_-&gt;channels();
137        const int height = blob_top_data_-&gt;height();
138        const int width = blob_top_data_-&gt;width();
139        for (int c = 0; c &lt; channels; ++c) {
140          for (int h = 0; h &lt; height; ++h) {
141            for (int w = 0; w &lt; width; ++w) {
142              const int idx = (c * height + h) * width + w;
143              EXPECT_EQ(idx, static_cast&lt;int&gt;(blob_top_data_-&gt;cpu_data()[idx]))
144                  &lt;&lt; &quot;debug: iter &quot; &lt;&lt; iter &lt;&lt; &quot; c &quot; &lt;&lt; c
145                  &lt;&lt; &quot; h &quot; &lt;&lt; h &lt;&lt; &quot; w &quot; &lt;&lt; w;
146            }
147          }
148        }
149      }
150    }
151    void TestReadCrop(Phase phase) {
152      const Dtype scale = 3;
153      LayerParameter param;
154      param.set_phase(phase);
155      Caffe::set_random_seed(1701);
156      DataParameter* data_param = param.mutable_data_param();
157      data_param-&gt;set_batch_size(5);
158      data_param-&gt;set_source(filename_-&gt;c_str());
159      data_param-&gt;set_backend(backend_);
160      TransformationParameter* transform_param =
161          param.mutable_transform_param();
162      transform_param-&gt;set_scale(scale);
163      transform_param-&gt;set_crop_size(1);
164      DataLayer&lt;Dtype&gt; layer(param);
165      layer.SetUp(blob_bottom_vec_, blob_top_vec_);
166      EXPECT_EQ(blob_top_data_-&gt;num(), 5);
167      EXPECT_EQ(blob_top_data_-&gt;channels(), 2);
168      EXPECT_EQ(blob_top_data_-&gt;height(), 1);
169      EXPECT_EQ(blob_top_data_-&gt;width(), 1);
170      EXPECT_EQ(blob_top_label_-&gt;num(), 5);
171      EXPECT_EQ(blob_top_label_-&gt;channels(), 1);
172      EXPECT_EQ(blob_top_label_-&gt;height(), 1);
173      EXPECT_EQ(blob_top_label_-&gt;width(), 1);
174      for (int iter = 0; iter &lt; 2; ++iter) {
175        layer.Forward(blob_bottom_vec_, blob_top_vec_);
176        for (int i = 0; i &lt; 5; ++i) {
177          EXPECT_EQ(i, blob_top_label_-&gt;cpu_data()[i]);
178        }
179        int num_with_center_value = 0;
180        for (int i = 0; i &lt; 5; ++i) {
181          for (int j = 0; j &lt; 2; ++j) {
182            const Dtype center_value = scale * (j ? 17 : 5);
183            num_with_center_value +=
184                (center_value == blob_top_data_-&gt;cpu_data()[i * 2 + j]);
185            if (phase == caffe::TEST) {
186              EXPECT_EQ(center_value, this-&gt;blob_top_data_-&gt;cpu_data()[i * 2 + j])
187                  &lt;&lt; &quot;debug: iter &quot; &lt;&lt; iter &lt;&lt; &quot; i &quot; &lt;&lt; i &lt;&lt; &quot; j &quot; &lt;&lt; j;
188            }
189          }
190        }
191        if (phase == caffe::TRAIN) {
192          EXPECT_LT(num_with_center_value, 10);
193        }
194      }
195    }
196    void TestReadCropTrainSequenceSeeded() {
197      LayerParameter param;
198      param.set_phase(TRAIN);
199      DataParameter* data_param = param.mutable_data_param();
200      data_param-&gt;set_batch_size(5);
201      data_param-&gt;set_source(filename_-&gt;c_str());
202      data_param-&gt;set_backend(backend_);
203      TransformationParameter* transform_param =
204          param.mutable_transform_param();
205      transform_param-&gt;set_crop_size(1);
206      transform_param-&gt;set_mirror(true);
207      Caffe::set_random_seed(seed_);
208      vector&lt;vector&lt;Dtype&gt; &gt; crop_sequence;
209      {
210        DataLayer&lt;Dtype&gt; layer1(param);
211        layer1.SetUp(blob_bottom_vec_, blob_top_vec_);
212        for (int iter = 0; iter &lt; 2; ++iter) {
213          layer1.Forward(blob_bottom_vec_, blob_top_vec_);
214          for (int i = 0; i &lt; 5; ++i) {
215            EXPECT_EQ(i, blob_top_label_-&gt;cpu_data()[i]);
216          }
217          vector&lt;Dtype&gt; iter_crop_sequence;
218          for (int i = 0; i &lt; 5; ++i) {
219            for (int j = 0; j &lt; 2; ++j) {
220              iter_crop_sequence.push_back(
221                  blob_top_data_-&gt;cpu_data()[i * 2 + j]);
222            }
223          }
224          crop_sequence.push_back(iter_crop_sequence);
225        }
226      }  
227      Caffe::set_random_seed(seed_);
228      DataLayer&lt;Dtype&gt; layer2(param);
229      layer2.SetUp(blob_bottom_vec_, blob_top_vec_);
230      for (int iter = 0; iter &lt; 2; ++iter) {
231        layer2.Forward(blob_bottom_vec_, blob_top_vec_);
232        for (int i = 0; i &lt; 5; ++i) {
233          EXPECT_EQ(i, blob_top_label_-&gt;cpu_data()[i]);
234        }
235        for (int i = 0; i &lt; 5; ++i) {
236          for (int j = 0; j &lt; 2; ++j) {
237            EXPECT_EQ(crop_sequence[iter][i * 2 + j],
238                      blob_top_data_-&gt;cpu_data()[i * 2 + j])
239                &lt;&lt; &quot;debug: iter &quot; &lt;&lt; iter &lt;&lt; &quot; i &quot; &lt;&lt; i &lt;&lt; &quot; j &quot; &lt;&lt; j;
240          }
241        }
242      }
243    }
244    void TestReadCropTrainSequenceUnseeded() {
245      LayerParameter param;
246      param.set_phase(TRAIN);
247      DataParameter* data_param = param.mutable_data_param();
248      data_param-&gt;set_batch_size(5);
249      data_param-&gt;set_source(filename_-&gt;c_str());
250      data_param-&gt;set_backend(backend_);
251      TransformationParameter* transform_param =
252          param.mutable_transform_param();
253      transform_param-&gt;set_crop_size(1);
254      transform_param-&gt;set_mirror(true);
255      Caffe::set_random_seed(seed_);
256      srand(seed_);
257      vector&lt;vector&lt;Dtype&gt; &gt; crop_sequence;
258      {
259        DataLayer&lt;Dtype&gt; layer1(param);
260        layer1.SetUp(blob_bottom_vec_, blob_top_vec_);
261        for (int iter = 0; iter &lt; 2; ++iter) {
262          layer1.Forward(blob_bottom_vec_, blob_top_vec_);
263          for (int i = 0; i &lt; 5; ++i) {
264            EXPECT_EQ(i, blob_top_label_-&gt;cpu_data()[i]);
265          }
266          vector&lt;Dtype&gt; iter_crop_sequence;
267          for (int i = 0; i &lt; 5; ++i) {
268            for (int j = 0; j &lt; 2; ++j) {
269              iter_crop_sequence.push_back(
270                  blob_top_data_-&gt;cpu_data()[i * 2 + j]);
271            }
272          }
273          crop_sequence.push_back(iter_crop_sequence);
274        }
275      }  
276      srand(seed_);
277      DataLayer&lt;Dtype&gt; layer2(param);
278      layer2.SetUp(blob_bottom_vec_, blob_top_vec_);
279      for (int iter = 0; iter &lt; 2; ++iter) {
280        layer2.Forward(blob_bottom_vec_, blob_top_vec_);
281        for (int i = 0; i &lt; 5; ++i) {
282          EXPECT_EQ(i, blob_top_label_-&gt;cpu_data()[i]);
283        }
284        int num_sequence_matches = 0;
285        for (int i = 0; i &lt; 5; ++i) {
286          for (int j = 0; j &lt; 2; ++j) {
287            num_sequence_matches += (crop_sequence[iter][i * 2 + j] ==
288                                     blob_top_data_-&gt;cpu_data()[i * 2 + j]);
289          }
290        }
291        EXPECT_LT(num_sequence_matches, 10);
292      }
293    }
294    virtual ~DataLayerTest() { delete blob_top_data_; delete blob_top_label_; }
295    DataParameter_DB backend_;
296    shared_ptr&lt;string&gt; filename_;
297    Blob&lt;Dtype&gt;* const blob_top_data_;
298    Blob&lt;Dtype&gt;* const blob_top_label_;
299    vector&lt;Blob&lt;Dtype&gt;*&gt; blob_bottom_vec_;
300    vector&lt;Blob&lt;Dtype&gt;*&gt; blob_top_vec_;
301    int seed_;
302  };
303  TYPED_TEST_CASE(DataLayerTest, TestDtypesAndDevices);
304  #ifdef USE_LEVELDB
305  TYPED_TEST(DataLayerTest, TestReadLevelDB) {
306    const bool unique_pixels = false;  
307    this-&gt;Fill(unique_pixels, DataParameter_DB_LEVELDB);
308    this-&gt;TestRead();
309  }
310  TYPED_TEST(DataLayerTest, TestReshapeLevelDB) {
311    this-&gt;TestReshape(DataParameter_DB_LEVELDB);
312  }
313  TYPED_TEST(DataLayerTest, TestReadCropTrainLevelDB) {
314    const bool unique_pixels = true;  
315    this-&gt;Fill(unique_pixels, DataParameter_DB_LEVELDB);
316    this-&gt;TestReadCrop(TRAIN);
317  }
318  TYPED_TEST(DataLayerTest, TestReadCropTrainSequenceSeededLevelDB) {
319    const bool unique_pixels = true;  
320    this-&gt;Fill(unique_pixels, DataParameter_DB_LEVELDB);
321    this-&gt;TestReadCropTrainSequenceSeeded();
322  }
323  TYPED_TEST(DataLayerTest, TestReadCropTrainSequenceUnseededLevelDB) {
324    const bool unique_pixels = true;  
325    this-&gt;Fill(unique_pixels, DataParameter_DB_LEVELDB);
326    this-&gt;TestReadCropTrainSequenceUnseeded();
327  }
328  TYPED_TEST(DataLayerTest, TestReadCropTestLevelDB) {
329    const bool unique_pixels = true;  
330    this-&gt;Fill(unique_pixels, DataParameter_DB_LEVELDB);
331    this-&gt;TestReadCrop(TEST);
332  }
333  #endif  
334  #ifdef USE_LMDB
335  TYPED_TEST(DataLayerTest, TestReadLMDB) {
336    const bool unique_pixels = false;  
337    this-&gt;Fill(unique_pixels, DataParameter_DB_LMDB);
338    this-&gt;TestRead();
339  }
340  TYPED_TEST(DataLayerTest, TestReshapeLMDB) {
341    this-&gt;TestReshape(DataParameter_DB_LMDB);
342  }
343  TYPED_TEST(DataLayerTest, TestReadCropTrainLMDB) {
344    const bool unique_pixels = true;  
345    this-&gt;Fill(unique_pixels, DataParameter_DB_LMDB);
346    this-&gt;TestReadCrop(TRAIN);
347  }
348  TYPED_TEST(DataLayerTest, TestReadCropTrainSequenceSeededLMDB) {
349    const bool unique_pixels = true;  
350    this-&gt;Fill(unique_pixels, DataParameter_DB_LMDB);
351    this-&gt;TestReadCropTrainSequenceSeeded();
352  }
353  TYPED_TEST(DataLayerTest, TestReadCropTrainSequenceUnseededLMDB) {
354    const bool unique_pixels = true;  
355    this-&gt;Fill(unique_pixels, DataParameter_DB_LMDB);
356    this-&gt;TestReadCropTrainSequenceUnseeded();
357  }
358  TYPED_TEST(DataLayerTest, TestReadCropTestLMDB) {
359    const bool unique_pixels = true;  
360    this-&gt;Fill(unique_pixels, DataParameter_DB_LMDB);
361    this-&gt;TestReadCrop(TEST);
362  }
363  #endif  
364  }  
365  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_annotated_data_layer.cpp</h3>
            <pre><code>1  #ifdef USE_OPENCV
2  #include &lt;algorithm&gt;
3  #include &lt;string&gt;
4  #include &lt;vector&gt;
5  #include &quot;boost/scoped_ptr.hpp&quot;
6  #include &quot;gtest/gtest.h&quot;
7  #include &quot;caffe/blob.hpp&quot;
8  #include &quot;caffe/common.hpp&quot;
9  #include &quot;caffe/filler.hpp&quot;
10  #include &quot;caffe/layers/annotated_data_layer.hpp&quot;
11  #include &quot;caffe/proto/caffe.pb.h&quot;
12  #include &quot;caffe/util/db.hpp&quot;
13  #include &quot;caffe/util/io.hpp&quot;
14  #include &quot;caffe/test/test_caffe_main.hpp&quot;
15  namespace caffe {
16  using boost::scoped_ptr;
17  static bool kBoolChoices[] = {false, true};
18  static int kNumChoices = 2;
19  int OneBBoxNum(int n) {
20    int sum = 0;
21    for (int g = 0; g &lt; n; ++g) {
22      sum += g;
23    }
24    return sum;
25  }
26  int BBoxNum(int n) {
27    int sum = 0;
28    for (int i = 0; i &lt; n; ++i) {
29      for (int g = 0; g &lt; i; ++g) {
30        sum += g;
31      }
32    }
33    return sum;
34  }
35  template &lt;typename TypeParam&gt;
36  class AnnotatedDataLayerTest : public MultiDeviceTest&lt;TypeParam&gt; {
37    typedef typename TypeParam::Dtype Dtype;
38   protected:
39    AnnotatedDataLayerTest()
40        : backend_(DataParameter_DB_LEVELDB),
41          blob_top_data_(new Blob&lt;Dtype&gt;()),
42          blob_top_label_(new Blob&lt;Dtype&gt;()),
43          seed_(1701),
44          num_(6),
45          channels_(2),
46          height_(10),
47          width_(10),
48          eps_(1e-6) {}
49    virtual void SetUp() {
50      spatial_dim_ = height_ * width_;
51      size_ = channels_ * spatial_dim_;
<span onclick='openModal()' class='match'>52      filename_.reset(new string());
53      GetTempDirname(filename_.get());
54      *filename_ += &quot;/db&quot;;
55      blob_top_vec_.push_back(blob_top_data_);
56      blob_top_vec_.push_back(blob_top_label_);
57    }
58    void Fill(DataParameter_DB backend, bool unique_pixel, bool unique_annotation,
</span>59              bool use_rich_annotation, AnnotatedDatum_AnnotationType type) {
60      backend_ = backend;
61      unique_pixel_ = unique_pixel;
62      unique_annotation_ = unique_annotation;
63      use_rich_annotation_ = use_rich_annotation;
64      type_ = type;
65      GetTempDirname(filename_.get());
66      LOG(INFO) &lt;&lt; &quot;Using temporary dataset &quot; &lt;&lt; *filename_;
67      scoped_ptr&lt;db::DB&gt; db(db::GetDB(backend));
68      db-&gt;Open(*filename_, db::NEW);
69      scoped_ptr&lt;db::Transaction&gt; txn(db-&gt;NewTransaction());
70      for (int i = 0; i &lt; num_; ++i) {
71        AnnotatedDatum anno_datum;
72        Datum* datum = anno_datum.mutable_datum();
73        datum-&gt;set_channels(channels_);
74        datum-&gt;set_height(height_);
75        datum-&gt;set_width(width_);
76        std::string* data = datum-&gt;mutable_data();
77        for (int j = 0; j &lt; size_; ++j) {
78          int elem = unique_pixel ? j : i;
79          data-&gt;push_back(static_cast&lt;uint8_t&gt;(elem));
80        }
81        if (use_rich_annotation) {
82          anno_datum.set_type(type);
83          for (int g = 0; g &lt; i; ++g) {
84            AnnotationGroup* anno_group = anno_datum.add_annotation_group();
85            anno_group-&gt;set_group_label(g);
86            for (int a = 0; a &lt; g; ++a) {
87              Annotation* anno = anno_group-&gt;add_annotation();
88              anno-&gt;set_instance_id(a);
89              if (type == AnnotatedDatum_AnnotationType_BBOX) {
90                NormalizedBBox* bbox = anno-&gt;mutable_bbox();
91                int b = unique_annotation ? a : g;
92                bbox-&gt;set_xmin(b*0.1);
93                bbox-&gt;set_ymin(b*0.1);
94                bbox-&gt;set_xmax(std::min(b*0.1 + 0.2, 1.0));
95                bbox-&gt;set_ymax(std::min(b*0.1 + 0.2, 1.0));
96                bbox-&gt;set_difficult(a % 2);
97              }
98            }
99          }
100        } else {
101          datum-&gt;set_label(i);
102        }
103        stringstream ss;
104        ss &lt;&lt; i;
105        string out;
106        CHECK(anno_datum.SerializeToString(&amp;out));
107        txn-&gt;Put(ss.str(), out);
108      }
109      txn-&gt;Commit();
110      db-&gt;Close();
111    }
112    void TestRead() {
113      LayerParameter param;
114      param.set_phase(TRAIN);
115      DataParameter* data_param = param.mutable_data_param();
116      data_param-&gt;set_batch_size(num_);
117      data_param-&gt;set_source(filename_-&gt;c_str());
118      data_param-&gt;set_backend(backend_);
119      const Dtype scale = 3;
120      TransformationParameter* transform_param =
121          param.mutable_transform_param();
122      transform_param-&gt;set_scale(scale);
123      AnnotatedDataLayer&lt;Dtype&gt; layer(param);
124      layer.SetUp(blob_bottom_vec_, blob_top_vec_);
125      EXPECT_EQ(blob_top_data_-&gt;num(), num_);
126      EXPECT_EQ(blob_top_data_-&gt;channels(), channels_);
127      EXPECT_EQ(blob_top_data_-&gt;height(), height_);
128      EXPECT_EQ(blob_top_data_-&gt;width(), width_);
129      if (use_rich_annotation_) {
130        switch (type_) {
131          case AnnotatedDatum_AnnotationType_BBOX:
132            EXPECT_EQ(blob_top_label_-&gt;num(), 1);
133            EXPECT_EQ(blob_top_label_-&gt;channels(), 1);
134            EXPECT_EQ(blob_top_label_-&gt;height(), 1);
135            EXPECT_EQ(blob_top_label_-&gt;width(), 8);
136            break;
137          default:
138            LOG(FATAL) &lt;&lt; &quot;Unknown annotation type.&quot;;
139            break;
140        }
141      } else {
142        EXPECT_EQ(blob_top_label_-&gt;num(), num_);
143        EXPECT_EQ(blob_top_label_-&gt;channels(), 1);
144        EXPECT_EQ(blob_top_label_-&gt;height(), 1);
145        EXPECT_EQ(blob_top_label_-&gt;width(), 1);
146      }
147      for (int iter = 0; iter &lt; 5; ++iter) {
148        layer.Forward(blob_bottom_vec_, blob_top_vec_);
149        const Dtype* label_data = blob_top_label_-&gt;cpu_data();
150        int cur_bbox = 0;
151        for (int i = 0; i &lt; num_; ++i) {
152          if (use_rich_annotation_) {
153            if (type_ == AnnotatedDatum_AnnotationType_BBOX) {
154              EXPECT_EQ(blob_top_label_-&gt;num(), 1);
155              EXPECT_EQ(blob_top_label_-&gt;channels(), 1);
156              EXPECT_EQ(blob_top_label_-&gt;height(), BBoxNum(num_));
157              EXPECT_EQ(blob_top_label_-&gt;width(), 8);
158              for (int g = 0; g &lt; i; ++g) {
159                for (int a = 0; a &lt; g; ++a) {
160                  EXPECT_EQ(i, label_data[cur_bbox*8]);
161                  EXPECT_EQ(g, label_data[cur_bbox*8+1]);
162                  EXPECT_EQ(a, label_data[cur_bbox*8+2]);
163                  int b = unique_annotation_ ? a : g;
164                  for (int p = 3; p &lt; 5; ++p) {
165                    EXPECT_NEAR(b*0.1, label_data[cur_bbox*8+p], this-&gt;eps_);
166                  }
167                  for (int p = 5; p &lt; 7; ++p) {
168                    EXPECT_NEAR(std::min(b*0.1 + 0.2, 1.0),
169                              label_data[cur_bbox*8+p], this-&gt;eps_);
170                  }
171                  EXPECT_EQ(a % 2, label_data[cur_bbox*8+7]);
172                  cur_bbox++;
173                }
174              }
175            } else {
176              LOG(FATAL) &lt;&lt; &quot;Unknown annotation type.&quot;;
177            }
178          } else {
179            EXPECT_EQ(i, label_data[i]);
180          }
181        }
182        for (int i = 1; i &lt; num_; ++i) {
183          for (int j = 0; j &lt; size_; ++j) {
184            EXPECT_EQ(scale * (unique_pixel_ ? j : i),
185                      blob_top_data_-&gt;cpu_data()[i * size_ + j])
186                &lt;&lt; &quot;debug: iter &quot; &lt;&lt; iter &lt;&lt; &quot; i &quot; &lt;&lt; i &lt;&lt; &quot; j &quot; &lt;&lt; j;
187          }
188        }
189      }
190    }
191    void TestReshape(DataParameter_DB backend, bool unique_pixel,
192                     bool unique_annotation, bool use_rich_annotation,
193                     AnnotatedDatum_AnnotationType type) {
194      GetTempDirname(filename_.get());
195      LOG(INFO) &lt;&lt; &quot;Using temporary dataset &quot; &lt;&lt; *filename_;
196      scoped_ptr&lt;db::DB&gt; db(db::GetDB(backend));
197      db-&gt;Open(*filename_, db::NEW);
198      scoped_ptr&lt;db::Transaction&gt; txn(db-&gt;NewTransaction());
199      for (int i = 0; i &lt; num_; ++i) {
200        AnnotatedDatum anno_datum;
201        Datum* datum = anno_datum.mutable_datum();
202        datum-&gt;set_channels(channels_);
203        datum-&gt;set_height(i % 2 + 1);
204        datum-&gt;set_width(i % 4 + 1);
205        std::string* data = datum-&gt;mutable_data();
206        const int data_size =
207            datum-&gt;channels() * datum-&gt;height() * datum-&gt;width();
208        for (int j = 0; j &lt; data_size; ++j) {
209          data-&gt;push_back(static_cast&lt;uint8_t&gt;(j));
210        }
211        if (use_rich_annotation) {
212          anno_datum.set_type(type);
213          for (int g = 0; g &lt; i; ++g) {
214            AnnotationGroup* anno_group = anno_datum.add_annotation_group();
215            anno_group-&gt;set_group_label(g);
216            for (int a = 0; a &lt; g; ++a) {
217              Annotation* anno = anno_group-&gt;add_annotation();
218              anno-&gt;set_instance_id(a);
219              if (type == AnnotatedDatum_AnnotationType_BBOX) {
220                NormalizedBBox* bbox = anno-&gt;mutable_bbox();
221                int b = unique_annotation ? a : g;
222                bbox-&gt;set_xmin(b*0.1);
223                bbox-&gt;set_ymin(b*0.1);
224                bbox-&gt;set_xmax(std::min(b*0.1 + 0.2, 1.0));
225                bbox-&gt;set_ymax(std::min(b*0.1 + 0.2, 1.0));
226                bbox-&gt;set_difficult(a % 2);
227              }
228            }
229          }
230        } else {
231          datum-&gt;set_label(i);
232        }
233        stringstream ss;
234        ss &lt;&lt; i;
235        string out;
236        CHECK(anno_datum.SerializeToString(&amp;out));
237        txn-&gt;Put(ss.str(), out);
238      }
239      txn-&gt;Commit();
240      db-&gt;Close();
241      LayerParameter param;
242      param.set_phase(TEST);
243      DataParameter* data_param = param.mutable_data_param();
244      data_param-&gt;set_batch_size(1);
245      data_param-&gt;set_source(filename_-&gt;c_str());
246      data_param-&gt;set_backend(backend);
247      AnnotatedDataLayer&lt;Dtype&gt; layer(param);
248      layer.SetUp(blob_bottom_vec_, blob_top_vec_);
249      EXPECT_EQ(blob_top_data_-&gt;num(), 1);
250      EXPECT_EQ(blob_top_data_-&gt;channels(), channels_);
251      if (use_rich_annotation) {
252        switch (type) {
253          case AnnotatedDatum_AnnotationType_BBOX:
254            EXPECT_EQ(blob_top_label_-&gt;num(), 1);
255            EXPECT_EQ(blob_top_label_-&gt;channels(), 1);
256            EXPECT_EQ(blob_top_label_-&gt;height(), 1);
257            EXPECT_EQ(blob_top_label_-&gt;width(), 8);
258            break;
259          default:
260            LOG(FATAL) &lt;&lt; &quot;Unknown annotation type.&quot;;
261            break;
262        }
263      } else {
264        EXPECT_EQ(blob_top_label_-&gt;num(), 1);
265        EXPECT_EQ(blob_top_label_-&gt;channels(), 1);
266        EXPECT_EQ(blob_top_label_-&gt;height(), 1);
267        EXPECT_EQ(blob_top_label_-&gt;width(), 1);
268      }
269      for (int iter = 0; iter &lt; 3; ++iter) {
270        layer.Forward(blob_bottom_vec_, blob_top_vec_);
271        EXPECT_EQ(blob_top_data_-&gt;height(), iter % 2 + 1);
272        EXPECT_EQ(blob_top_data_-&gt;width(), iter % 4 + 1);
273        const Dtype* label_data = blob_top_label_-&gt;cpu_data();
274        if (use_rich_annotation) {
275          if (type == AnnotatedDatum_AnnotationType_BBOX) {
276            if (iter &lt;= 1) {
277              EXPECT_EQ(blob_top_label_-&gt;num(), 1);
278              EXPECT_EQ(blob_top_label_-&gt;channels(), 1);
279              EXPECT_EQ(blob_top_label_-&gt;height(), 1);
280              EXPECT_EQ(blob_top_label_-&gt;width(), 8);
281              for (int i = 0; i &lt; 8; ++i) {
282                EXPECT_NEAR(label_data[i], -1, this-&gt;eps_);
283              }
284            } else {
285              int cur_bbox = 0;
286              EXPECT_EQ(blob_top_label_-&gt;num(), 1);
287              EXPECT_EQ(blob_top_label_-&gt;channels(), 1);
288              EXPECT_EQ(blob_top_label_-&gt;height(), OneBBoxNum(iter));
289              EXPECT_EQ(blob_top_label_-&gt;width(), 8);
290              for (int g = 0; g &lt; iter; ++g) {
291                for (int a = 0; a &lt; g; ++a) {
292                  EXPECT_EQ(0, label_data[cur_bbox*8]);
293                  EXPECT_EQ(g, label_data[cur_bbox*8+1]);
294                  EXPECT_EQ(a, label_data[cur_bbox*8+2]);
295                  int b = unique_annotation ? a : g;
296                  for (int p = 3; p &lt; 5; ++p) {
297                    EXPECT_NEAR(b*0.1, label_data[cur_bbox*8+p], this-&gt;eps_);
298                  }
299                  for (int p = 5; p &lt; 7; ++p) {
300                    EXPECT_NEAR(std::min(b*0.1 + 0.2, 1.0),
301                              label_data[cur_bbox*8+p], this-&gt;eps_);
302                  }
303                  EXPECT_EQ(a % 2, label_data[cur_bbox*8+7]);
304                  cur_bbox++;
305                }
306              }
307            }
308          } else {
309            LOG(FATAL) &lt;&lt; &quot;Unknown annotation type.&quot;;
310          }
311        } else {
312          EXPECT_EQ(iter, label_data[0]);
313        }
314        const int channels = blob_top_data_-&gt;channels();
315        const int height = blob_top_data_-&gt;height();
316        const int width = blob_top_data_-&gt;width();
317        for (int c = 0; c &lt; channels; ++c) {
318          for (int h = 0; h &lt; height; ++h) {
319            for (int w = 0; w &lt; width; ++w) {
320              const int idx = (c * height + h) * width + w;
321              EXPECT_EQ(idx, static_cast&lt;int&gt;(blob_top_data_-&gt;cpu_data()[idx]))
322                  &lt;&lt; &quot;debug: iter &quot; &lt;&lt; iter &lt;&lt; &quot; c &quot; &lt;&lt; c
323                  &lt;&lt; &quot; h &quot; &lt;&lt; h &lt;&lt; &quot; w &quot; &lt;&lt; w;
324            }
325          }
326        }
327      }
328    }
329    void TestReadCrop(Phase phase) {
330      const Dtype scale = 3;
331      LayerParameter param;
332      param.set_phase(phase);
333      Caffe::set_random_seed(1701);
334      DataParameter* data_param = param.mutable_data_param();
335      data_param-&gt;set_batch_size(num_);
336      data_param-&gt;set_source(filename_-&gt;c_str());
337      data_param-&gt;set_backend(backend_);
338      TransformationParameter* transform_param =
339          param.mutable_transform_param();
340      transform_param-&gt;set_scale(scale);
341      transform_param-&gt;set_crop_size(1);
342      AnnotatedDataLayer&lt;Dtype&gt; layer(param);
343      layer.SetUp(blob_bottom_vec_, blob_top_vec_);
344      EXPECT_EQ(blob_top_data_-&gt;num(), num_);
345      EXPECT_EQ(blob_top_data_-&gt;channels(), channels_);
346      EXPECT_EQ(blob_top_data_-&gt;height(), 1);
347      EXPECT_EQ(blob_top_data_-&gt;width(), 1);
348      EXPECT_EQ(blob_top_label_-&gt;num(), num_);
349      EXPECT_EQ(blob_top_label_-&gt;channels(), 1);
350      EXPECT_EQ(blob_top_label_-&gt;height(), 1);
351      EXPECT_EQ(blob_top_label_-&gt;width(), 1);
352      for (int iter = 0; iter &lt; 5; ++iter) {
353        layer.Forward(blob_bottom_vec_, blob_top_vec_);
354        for (int i = 0; i &lt; num_; ++i) {
355          EXPECT_EQ(i, blob_top_label_-&gt;cpu_data()[i]);
356        }
357        int num_with_center_value = 0;
358        for (int i = 0; i &lt; num_; ++i) {
359          for (int j = 0; j &lt; channels_; ++j) {
360            const Dtype center_value =
361                scale * ((ceil(height_ / 2.0) - 1) * width_ +
362                         ceil(width_ / 2.0) - 1 + j * spatial_dim_);
363            num_with_center_value +=
364                (center_value == blob_top_data_-&gt;cpu_data()[i * 2 + j]);
365            if (phase == caffe::TEST) {
366              EXPECT_EQ(center_value,
367                        this-&gt;blob_top_data_-&gt;cpu_data()[i * channels_ + j])
368                  &lt;&lt; &quot;debug: iter &quot; &lt;&lt; iter &lt;&lt; &quot; i &quot; &lt;&lt; i &lt;&lt; &quot; j &quot; &lt;&lt; j;
369            }
370          }
371        }
372        if (phase == caffe::TRAIN) {
373          EXPECT_LT(num_with_center_value, 10);
374        }
375      }
376    }
377    void TestReadCropTrainSequenceSeeded() {
378      LayerParameter param;
379      param.set_phase(TRAIN);
380      DataParameter* data_param = param.mutable_data_param();
381      data_param-&gt;set_batch_size(num_);
382      data_param-&gt;set_source(filename_-&gt;c_str());
383      data_param-&gt;set_backend(backend_);
384      TransformationParameter* transform_param =
385          param.mutable_transform_param();
386      transform_param-&gt;set_crop_size(1);
387      transform_param-&gt;set_mirror(true);
388      Caffe::set_random_seed(seed_);
389      vector&lt;vector&lt;Dtype&gt; &gt; crop_sequence;
390      {
391        AnnotatedDataLayer&lt;Dtype&gt; layer1(param);
392        layer1.SetUp(blob_bottom_vec_, blob_top_vec_);
393        for (int iter = 0; iter &lt; 2; ++iter) {
394          layer1.Forward(blob_bottom_vec_, blob_top_vec_);
395          for (int i = 0; i &lt; num_; ++i) {
396            EXPECT_EQ(i, blob_top_label_-&gt;cpu_data()[i]);
397          }
398          vector&lt;Dtype&gt; iter_crop_sequence;
399          for (int i = 0; i &lt; num_; ++i) {
400            for (int j = 0; j &lt; channels_; ++j) {
401              iter_crop_sequence.push_back(
402                  blob_top_data_-&gt;cpu_data()[i * channels_ + j]);
403            }
404          }
405          crop_sequence.push_back(iter_crop_sequence);
406        }
407      }  
408      Caffe::set_random_seed(seed_);
409      AnnotatedDataLayer&lt;Dtype&gt; layer2(param);
410      layer2.SetUp(blob_bottom_vec_, blob_top_vec_);
411      for (int iter = 0; iter &lt; 2; ++iter) {
412        layer2.Forward(blob_bottom_vec_, blob_top_vec_);
413        for (int i = 0; i &lt; num_; ++i) {
414          EXPECT_EQ(i, blob_top_label_-&gt;cpu_data()[i]);
415        }
416        for (int i = 0; i &lt; num_; ++i) {
417          for (int j = 0; j &lt; channels_; ++j) {
418            EXPECT_EQ(crop_sequence[iter][i * channels_ + j],
419                      blob_top_data_-&gt;cpu_data()[i * channels_ + j])
420                &lt;&lt; &quot;debug: iter &quot; &lt;&lt; iter &lt;&lt; &quot; i &quot; &lt;&lt; i &lt;&lt; &quot; j &quot; &lt;&lt; j;
421          }
422        }
423      }
424    }
425    void TestReadCropTrainSequenceUnseeded() {
426      LayerParameter param;
427      param.set_phase(TRAIN);
428      DataParameter* data_param = param.mutable_data_param();
429      data_param-&gt;set_batch_size(num_);
430      data_param-&gt;set_source(filename_-&gt;c_str());
431      data_param-&gt;set_backend(backend_);
432      TransformationParameter* transform_param =
433          param.mutable_transform_param();
434      transform_param-&gt;set_crop_size(1);
435      transform_param-&gt;set_mirror(true);
436      Caffe::set_random_seed(seed_);
437      srand(seed_);
438      vector&lt;vector&lt;Dtype&gt; &gt; crop_sequence;
439      {
440        AnnotatedDataLayer&lt;Dtype&gt; layer1(param);
441        layer1.SetUp(blob_bottom_vec_, blob_top_vec_);
442        for (int iter = 0; iter &lt; 2; ++iter) {
443          layer1.Forward(blob_bottom_vec_, blob_top_vec_);
444          for (int i = 0; i &lt; num_; ++i) {
445            EXPECT_EQ(i, blob_top_label_-&gt;cpu_data()[i]);
446          }
447          vector&lt;Dtype&gt; iter_crop_sequence;
448          for (int i = 0; i &lt; num_; ++i) {
449            for (int j = 0; j &lt; channels_; ++j) {
450              iter_crop_sequence.push_back(
451                  blob_top_data_-&gt;cpu_data()[i * channels_ + j]);
452            }
453          }
454          crop_sequence.push_back(iter_crop_sequence);
455        }
456      }  
457      srand(seed_);
458      AnnotatedDataLayer&lt;Dtype&gt; layer2(param);
459      layer2.SetUp(blob_bottom_vec_, blob_top_vec_);
460      for (int iter = 0; iter &lt; 2; ++iter) {
461        layer2.Forward(blob_bottom_vec_, blob_top_vec_);
462        for (int i = 0; i &lt; num_; ++i) {
463          EXPECT_EQ(i, blob_top_label_-&gt;cpu_data()[i]);
464        }
465        int num_sequence_matches = 0;
466        for (int i = 0; i &lt; num_; ++i) {
467          for (int j = 0; j &lt; channels_; ++j) {
468            num_sequence_matches +=
469                (crop_sequence[iter][i * channels_ + j] ==
470                 blob_top_data_-&gt;cpu_data()[i * channels_ + j]);
471          }
472        }
473        EXPECT_LT(num_sequence_matches, num_ * channels_);
474      }
475    }
476    virtual ~AnnotatedDataLayerTest() {
477      delete blob_top_data_;
478      delete blob_top_label_;
479    }
480    DataParameter_DB backend_;
481    shared_ptr&lt;string&gt; filename_;
482    Blob&lt;Dtype&gt;* const blob_top_data_;
483    Blob&lt;Dtype&gt;* const blob_top_label_;
484    vector&lt;Blob&lt;Dtype&gt;*&gt; blob_bottom_vec_;
485    vector&lt;Blob&lt;Dtype&gt;*&gt; blob_top_vec_;
486    int seed_;
487    int num_;
488    int channels_;
489    int height_;
490    int width_;
491    Dtype eps_;
492    int spatial_dim_;
493    int size_;
494    bool unique_pixel_;
495    bool unique_annotation_;
496    bool use_rich_annotation_;
497    AnnotatedDatum_AnnotationType type_;
498  };
499  TYPED_TEST_CASE(AnnotatedDataLayerTest, TestDtypesAndDevices);
500  #ifdef USE_LEVELDB
501  TYPED_TEST(AnnotatedDataLayerTest, TestReadLevelDB) {
502    const AnnotatedDatum_AnnotationType type = AnnotatedDatum_AnnotationType_BBOX;
503    for (int p = 0; p &lt; kNumChoices; ++p) {
504      bool unique_pixel = kBoolChoices[p];
505      for (int r = 0; r &lt; kNumChoices; ++r) {
506        bool use_rich_annotation = kBoolChoices[r];
507        for (int a = 0; a &lt; kNumChoices; ++a) {
508          if (!use_rich_annotation) {
509            continue;
510          }
511          bool unique_annotation = kBoolChoices[a];
512          this-&gt;Fill(DataParameter_DB_LEVELDB, unique_pixel, unique_annotation,
513                     use_rich_annotation, type);
514          this-&gt;TestRead();
515        }
516      }
517    }
518  }
519  TYPED_TEST(AnnotatedDataLayerTest, TestReshapeLevelDB) {
520    const AnnotatedDatum_AnnotationType type = AnnotatedDatum_AnnotationType_BBOX;
521    for (int p = 0; p &lt; kNumChoices; ++p) {
522      bool unique_pixel = kBoolChoices[p];
523      for (int r = 0; r &lt; kNumChoices; ++r) {
524        bool use_rich_annotation = kBoolChoices[r];
525        for (int a = 0; a &lt; kNumChoices; ++a) {
526          if (!use_rich_annotation) {
527            continue;
528          }
529          bool unique_annotation = kBoolChoices[a];
530          this-&gt;TestReshape(DataParameter_DB_LEVELDB, unique_pixel,
531                            unique_annotation, use_rich_annotation, type);
532        }
533      }
534    }
535  }
536  TYPED_TEST(AnnotatedDataLayerTest, TestReadCropTrainLevelDB) {
537    const bool unique_pixel = true;  
538    const bool unique_annotation = false;  
539    const bool use_rich_annotation = false;
540    AnnotatedDatum_AnnotationType type = AnnotatedDatum_AnnotationType_BBOX;
541    this-&gt;Fill(DataParameter_DB_LEVELDB, unique_pixel, unique_annotation,
542               use_rich_annotation, type);
543    this-&gt;TestReadCrop(TRAIN);
544  }
545  TYPED_TEST(AnnotatedDataLayerTest, TestReadCropTrainSequenceSeededLevelDB) {
546    const bool unique_pixel = true;  
547    const bool unique_annotation = false;  
548    const bool use_rich_annotation = false;
549    AnnotatedDatum_AnnotationType type = AnnotatedDatum_AnnotationType_BBOX;
550    this-&gt;Fill(DataParameter_DB_LEVELDB, unique_pixel, unique_annotation,
551               use_rich_annotation, type);
552    this-&gt;TestReadCropTrainSequenceSeeded();
553  }
554  TYPED_TEST(AnnotatedDataLayerTest, TestReadCropTrainSequenceUnseededLevelDB) {
555    const bool unique_pixel = true;  
556    const bool unique_annotation = false;  
557    const bool use_rich_annotation = false;
558    AnnotatedDatum_AnnotationType type = AnnotatedDatum_AnnotationType_BBOX;
559    this-&gt;Fill(DataParameter_DB_LEVELDB, unique_pixel, unique_annotation,
560               use_rich_annotation, type);
561    this-&gt;TestReadCropTrainSequenceUnseeded();
562  }
563  TYPED_TEST(AnnotatedDataLayerTest, TestReadCropTestLevelDB) {
564    const bool unique_pixel = true;  
565    const bool unique_annotation = false;  
566    const bool use_rich_annotation = false;
567    AnnotatedDatum_AnnotationType type = AnnotatedDatum_AnnotationType_BBOX;
568    this-&gt;Fill(DataParameter_DB_LEVELDB, unique_pixel, unique_annotation,
569               use_rich_annotation, type);
570    this-&gt;TestReadCrop(TEST);
571  }
572  #endif  
573  #ifdef USE_LMDB
574  TYPED_TEST(AnnotatedDataLayerTest, TestReadLMDB) {
575    const AnnotatedDatum_AnnotationType type = AnnotatedDatum_AnnotationType_BBOX;
576    for (int p = 0; p &lt; kNumChoices; ++p) {
577      bool unique_pixel = kBoolChoices[p];
578      for (int r = 0; r &lt; kNumChoices; ++r) {
579        bool use_rich_annotation = kBoolChoices[r];
580        for (int a = 0; a &lt; kNumChoices; ++a) {
581          if (!use_rich_annotation) {
582            continue;
583          }
584          bool unique_annotation = kBoolChoices[a];
585          this-&gt;Fill(DataParameter_DB_LMDB, unique_pixel, unique_annotation,
586                     use_rich_annotation, type);
587          this-&gt;TestRead();
588        }
589      }
590    }
591  }
592  TYPED_TEST(AnnotatedDataLayerTest, TestReshapeLMDB) {
593    const AnnotatedDatum_AnnotationType type = AnnotatedDatum_AnnotationType_BBOX;
594    for (int p = 0; p &lt; kNumChoices; ++p) {
595      bool unique_pixel = kBoolChoices[p];
596      for (int r = 0; r &lt; kNumChoices; ++r) {
597        bool use_rich_annotation = kBoolChoices[r];
598        for (int a = 0; a &lt; kNumChoices; ++a) {
599          if (!use_rich_annotation) {
600            continue;
601          }
602          bool unique_annotation = kBoolChoices[a];
603          this-&gt;TestReshape(DataParameter_DB_LMDB, unique_pixel,
604                            unique_annotation, use_rich_annotation, type);
605        }
606      }
607    }
608  }
609  TYPED_TEST(AnnotatedDataLayerTest, TestReadCropTrainLMDB) {
610    const bool unique_pixel = true;  
611    const bool unique_annotation = false;  
612    const bool use_rich_annotation = false;
613    AnnotatedDatum_AnnotationType type = AnnotatedDatum_AnnotationType_BBOX;
614    this-&gt;Fill(DataParameter_DB_LMDB, unique_pixel, unique_annotation,
615               use_rich_annotation, type);
616    this-&gt;TestReadCrop(TRAIN);
617  }
618  TYPED_TEST(AnnotatedDataLayerTest, TestReadCropTrainSequenceSeededLMDB) {
619    const bool unique_pixel = true;  
620    const bool unique_annotation = false;  
621    const bool use_rich_annotation = false;
622    AnnotatedDatum_AnnotationType type = AnnotatedDatum_AnnotationType_BBOX;
623    this-&gt;Fill(DataParameter_DB_LMDB, unique_pixel, unique_annotation,
624               use_rich_annotation, type);
625    this-&gt;TestReadCropTrainSequenceSeeded();
626  }
627  TYPED_TEST(AnnotatedDataLayerTest, TestReadCropTrainSequenceUnseededLMDB) {
628    const bool unique_pixel = true;  
629    const bool unique_annotation = false;  
630    const bool use_rich_annotation = false;
631    AnnotatedDatum_AnnotationType type = AnnotatedDatum_AnnotationType_BBOX;
632    this-&gt;Fill(DataParameter_DB_LMDB, unique_pixel, unique_annotation,
633               use_rich_annotation, type);
634    this-&gt;TestReadCropTrainSequenceUnseeded();
635  }
636  TYPED_TEST(AnnotatedDataLayerTest, TestReadCropTestLMDB) {
637    const bool unique_pixel = true;  
638    const bool unique_annotation = false;  
639    const bool use_rich_annotation = false;
640    AnnotatedDatum_AnnotationType type = AnnotatedDatum_AnnotationType_BBOX;
641    this-&gt;Fill(DataParameter_DB_LMDB, unique_pixel, unique_annotation,
642               use_rich_annotation, type);
643    this-&gt;TestReadCrop(TEST);
644  }
645  #endif  
646  }  
647  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_data_layer.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-test_annotated_data_layer.cpp</div>
                </div>
                <div class="column column_space"><pre><code>26      filename_.reset(new string());
27      MakeTempDir(filename_.get());
28      *filename_ += &quot;/db&quot;;
29      blob_top_vec_.push_back(blob_top_data_);
30      blob_top_vec_.push_back(blob_top_label_);
31    }
32    void Fill(const bool unique_pixels, DataParameter_DB backend) {
</pre></code></div>
                <div class="column column_space"><pre><code>52      filename_.reset(new string());
53      GetTempDirname(filename_.get());
54      *filename_ += &quot;/db&quot;;
55      blob_top_vec_.push_back(blob_top_data_);
56      blob_top_vec_.push_back(blob_top_label_);
57    }
58    void Fill(DataParameter_DB backend, bool unique_pixel, bool unique_annotation,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    