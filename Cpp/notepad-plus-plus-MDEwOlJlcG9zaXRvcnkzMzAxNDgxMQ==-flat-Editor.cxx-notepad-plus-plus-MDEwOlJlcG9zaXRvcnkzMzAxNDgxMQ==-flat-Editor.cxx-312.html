
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 21, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Editor.cxx</h3>
            <pre><code>1  #include &lt;cstddef&gt;
2  #include &lt;cstdlib&gt;
3  #include &lt;cstdint&gt;
4  #include &lt;cassert&gt;
5  #include &lt;cstring&gt;
6  #include &lt;cstdio&gt;
7  #include &lt;cmath&gt;
8  #include &lt;stdexcept&gt;
9  #include &lt;string&gt;
10  #include &lt;string_view&gt;
11  #include &lt;vector&gt;
12  #include &lt;map&gt;
13  #include &lt;set&gt;
14  #include &lt;forward_list&gt;
15  #include &lt;optional&gt;
16  #include &lt;algorithm&gt;
17  #include &lt;iterator&gt;
18  #include &lt;memory&gt;
19  #include &lt;chrono&gt;
20  #include &lt;atomic&gt;
21  #include &lt;mutex&gt;
22  #include &lt;thread&gt;
23  #include &lt;future&gt;
24  #include &quot;ScintillaTypes.h&quot;
25  #include &quot;ScintillaMessages.h&quot;
26  #include &quot;ScintillaStructures.h&quot;
27  #include &quot;ILoader.h&quot;
28  #include &quot;ILexer.h&quot;
29  #include &quot;Debugging.h&quot;
30  #include &quot;Geometry.h&quot;
31  #include &quot;Platform.h&quot;
32  #include &quot;CharacterType.h&quot;
33  #include &quot;CharacterCategoryMap.h&quot;
34  #include &quot;Position.h&quot;
35  #include &quot;UniqueString.h&quot;
36  #include &quot;SplitVector.h&quot;
37  #include &quot;Partitioning.h&quot;
38  #include &quot;RunStyles.h&quot;
39  #include &quot;ContractionState.h&quot;
40  #include &quot;CellBuffer.h&quot;
41  #include &quot;PerLine.h&quot;
42  #include &quot;KeyMap.h&quot;
43  #include &quot;Indicator.h&quot;
44  #include &quot;LineMarker.h&quot;
45  #include &quot;Style.h&quot;
46  #include &quot;ViewStyle.h&quot;
47  #include &quot;CharClassify.h&quot;
48  #include &quot;Decoration.h&quot;
49  #include &quot;CaseFolder.h&quot;
50  #include &quot;Document.h&quot;
51  #include &quot;UniConversion.h&quot;
52  #include &quot;DBCS.h&quot;
53  #include &quot;Selection.h&quot;
54  #include &quot;PositionCache.h&quot;
55  #include &quot;EditModel.h&quot;
56  #include &quot;MarginView.h&quot;
57  #include &quot;EditView.h&quot;
58  #include &quot;Editor.h&quot;
59  #include &quot;ElapsedPeriod.h&quot;
60  using namespace Scintilla;
61  using namespace Scintilla::Internal;
62  namespace {
63  constexpr bool CanDeferToLastStep(const DocModification &amp;mh) noexcept {
64  	if (FlagSet(mh.modificationType, (ModificationFlags::BeforeInsert | ModificationFlags::BeforeDelete)))
65  		return true;	
66  	if (!FlagSet(mh.modificationType, (ModificationFlags::Undo | ModificationFlags::Redo)))
67  		return false;	
68  	if (FlagSet(mh.modificationType, ModificationFlags::MultiStepUndoRedo))
69  		return true;	
70  	return false;		
71  }
72  constexpr bool CanEliminate(const DocModification &amp;mh) noexcept {
73  	return
74  		FlagSet(mh.modificationType, (ModificationFlags::BeforeInsert | ModificationFlags::BeforeDelete));
75  }
76  constexpr bool IsLastStep(const DocModification &amp;mh) noexcept {
77  	return
78  		FlagSet(mh.modificationType, (ModificationFlags::Undo | ModificationFlags::Redo))
79  	    &amp;&amp; (FlagSet(mh.modificationType, ModificationFlags::MultiStepUndoRedo))
80  	    &amp;&amp; (FlagSet(mh.modificationType, ModificationFlags::LastStepInUndoRedo))
81  	    &amp;&amp; (FlagSet(mh.modificationType, ModificationFlags::MultilineUndoRedo));
82  }
83  }
84  Timer::Timer() noexcept :
85  		ticking(false), ticksToWait(0), tickerID{} {}
86  Idler::Idler() noexcept :
87  		state(false), idlerID(nullptr) {}
88  static constexpr bool IsAllSpacesOrTabs(std::string_view sv) noexcept {
89  	for (const char ch : sv) {
90  		if (!IsSpaceOrTab(ch))
91  			return false;
92  	}
93  	return true;
94  }
95  Editor::Editor() : durationWrapOneByte(0.000001, 0.00000001, 0.00001) {
96  	ctrlID = 0;
97  	stylesValid = false;
98  	technology = Technology::Default;
99  	scaleRGBAImage = 100.0f;
100  	cursorMode = CursorShape::Normal;
101  	errorStatus = Status::Ok;
102  	mouseDownCaptures = true;
103  	mouseWheelCaptures = true;
104  	lastClickTime = 0;
105  	doubleClickCloseThreshold = Point(3, 3);
106  	dwellDelay = TimeForever;
107  	ticksToDwell = TimeForever;
108  	dwelling = false;
109  	ptMouseLast.x = 0;
110  	ptMouseLast.y = 0;
111  	inDragDrop = DragDrop::none;
112  	dropWentOutside = false;
113  	posDrop = SelectionPosition(Sci::invalidPosition);
114  	hotSpotClickPos = Sci::invalidPosition;
115  	selectionUnit = TextUnit::character;
116  	lastXChosen = 0;
117  	lineAnchorPos = 0;
118  	originalAnchorPos = 0;
119  	wordSelectAnchorStartPos = 0;
120  	wordSelectAnchorEndPos = 0;
121  	wordSelectInitialCaretPos = -1;
122  	caretPolicies.x = { CaretPolicy::Slop | CaretPolicy::Even, 50 };
123  	caretPolicies.y = { CaretPolicy::Even, 0 };
124  	visiblePolicy = { 0, 0 };
125  	searchAnchor = 0;
126  	xCaretMargin = 50;
127  	horizontalScrollBarVisible = true;
128  	scrollWidth = 2000;
129  	verticalScrollBarVisible = true;
130  	endAtLastLine = true;
131  	caretSticky = CaretSticky::Off;
132  	marginOptions = MarginOption::None;
133  	mouseSelectionRectangularSwitch = false;
134  	multipleSelection = false;
135  	additionalSelectionTyping = false;
136  	multiPasteMode = MultiPaste::Once;
137  	virtualSpaceOptions = VirtualSpace::None;
138  	targetRange = SelectionSegment();
139  	searchFlags = FindOption::None;
140  	topLine = 0;
141  	posTopLine = 0;
142  	lengthForEncode = -1;
143  	needUpdateUI = Update::None;
144  	ContainerNeedsUpdate(Update::Content);
145  	paintState = PaintState::notPainting;
146  	paintAbandonedByStyling = false;
147  	paintingAllText = false;
148  	willRedrawAll = false;
149  	idleStyling = IdleStyling::None;
150  	needIdleStyling = false;
151  	modEventMask = ModificationFlags::EventMaskAll;
152  	commandEvents = true;
153  	pdoc-&gt;AddWatcher(this, nullptr);
154  	recordingMacro = false;
155  	foldAutomatic = AutomaticFold::None;
156  	convertPastes = true;
157  	SetRepresentations();
158  }
159  Editor::~Editor() {
160  	pdoc-&gt;RemoveWatcher(this, nullptr);
161  }
162  void Editor::Finalise() {
163  	SetIdle(false);
164  	CancelModes();
165  }
166  void Editor::SetRepresentations() {
167  	reprs.SetDefaultRepresentations(pdoc-&gt;dbcsCodePage);
168  }
169  void Editor::DropGraphics() noexcept {
170  	marginView.DropGraphics();
171  	view.DropGraphics();
172  }
173  void Editor::InvalidateStyleData() noexcept {
174  	stylesValid = false;
175  	vs.technology = technology;
176  	DropGraphics();
177  	view.llc.Invalidate(LineLayout::ValidLevel::invalid);
178  	view.posCache-&gt;Clear();
179  }
180  void Editor::InvalidateStyleRedraw() {
181  	NeedWrapping();
182  	InvalidateStyleData();
183  	Redraw();
184  }
185  void Editor::RefreshStyleData() {
186  	if (!stylesValid) {
187  		stylesValid = true;
188  		AutoSurface surface(this);
189  		if (surface) {
190  			vs.Refresh(*surface, pdoc-&gt;tabInChars);
191  		}
192  		SetScrollBars();
193  		SetRectangularRange();
194  	}
195  }
196  bool Editor::HasMarginWindow() const noexcept {
197  	return wMargin.Created();
198  }
199  Point Editor::GetVisibleOriginInMain() const {
200  	return Point(0, 0);
201  }
202  PointDocument Editor::DocumentPointFromView(Point ptView) const {
203  	PointDocument ptDocument(ptView);
204  	if (HasMarginWindow()) {
205  		const Point ptOrigin = GetVisibleOriginInMain();
206  		ptDocument.x += ptOrigin.x;
207  		ptDocument.y += ptOrigin.y;
208  	} else {
209  		ptDocument.x += xOffset;
210  		ptDocument.y += topLine * vs.lineHeight;
211  	}
212  	return ptDocument;
213  }
214  Sci::Line Editor::TopLineOfMain() const noexcept {
215  	if (HasMarginWindow())
216  		return 0;
217  	else
218  		return topLine;
219  }
220  Point Editor::ClientSize() const {
221  	const PRectangle rcClient = GetClientRectangle();
222  	return Point(rcClient.Width(), rcClient.Height());
223  }
224  PRectangle Editor::GetClientRectangle() const {
225  	return wMain.GetClientPosition();
226  }
227  PRectangle Editor::GetClientDrawingRectangle() {
228  	return GetClientRectangle();
229  }
230  PRectangle Editor::GetTextRectangle() const {
231  	PRectangle rc = GetClientRectangle();
232  	rc.left += vs.textStart;
233  	rc.right -= vs.rightMarginWidth;
234  	return rc;
235  }
236  Sci::Line Editor::LinesOnScreen() const {
237  	const Point sizeClient = ClientSize();
238  	const int htClient = static_cast&lt;int&gt;(sizeClient.y);
239  	return htClient / vs.lineHeight;
240  }
241  Sci::Line Editor::LinesToScroll() const {
242  	const Sci::Line retVal = LinesOnScreen() - 1;
243  	if (retVal &lt; 1)
244  		return 1;
245  	else
246  		return retVal;
247  }
248  Sci::Line Editor::MaxScrollPos() const {
249  	Sci::Line retVal = pcs-&gt;LinesDisplayed();
250  	if (endAtLastLine) {
251  		retVal -= LinesOnScreen();
252  	} else {
253  		retVal--;
254  	}
255  	if (retVal &lt; 0) {
256  		return 0;
257  	} else {
258  		return retVal;
259  	}
260  }
261  SelectionPosition Editor::ClampPositionIntoDocument(SelectionPosition sp) const {
262  	if (sp.Position() &lt; 0) {
263  		return SelectionPosition(0);
264  	} else if (sp.Position() &gt; pdoc-&gt;Length()) {
265  		return SelectionPosition(pdoc-&gt;Length());
266  	} else {
267  		if (!pdoc-&gt;IsLineEndPosition(sp.Position()))
268  			sp.SetVirtualSpace(0);
269  		return sp;
270  	}
271  }
272  Point Editor::LocationFromPosition(SelectionPosition pos, PointEnd pe) {
273  	const PRectangle rcClient = GetTextRectangle();
274  	RefreshStyleData();
275  	AutoSurface surface(this);
276  	return view.LocationFromPosition(surface, *this, pos, topLine, vs, pe, rcClient);
277  }
278  Point Editor::LocationFromPosition(Sci::Position pos, PointEnd pe) {
279  	return LocationFromPosition(SelectionPosition(pos), pe);
280  }
281  int Editor::XFromPosition(SelectionPosition sp) {
282  	const Point pt = LocationFromPosition(sp);
283  	return static_cast&lt;int&gt;(pt.x) - vs.textStart + xOffset;
284  }
285  SelectionPosition Editor::SPositionFromLocation(Point pt, bool canReturnInvalid, bool charPosition, bool virtualSpace) {
286  	RefreshStyleData();
287  	AutoSurface surface(this);
288  	PRectangle rcClient = GetTextRectangle();
289  	const Point ptOrigin = GetVisibleOriginInMain();
290  	rcClient.Move(-ptOrigin.x, -ptOrigin.y);
291  	if (canReturnInvalid) {
292  		if (!rcClient.Contains(pt))
293  			return SelectionPosition(Sci::invalidPosition);
294  		if (pt.x &lt; vs.textStart)
295  			return SelectionPosition(Sci::invalidPosition);
296  		if (pt.y &lt; 0)
297  			return SelectionPosition(Sci::invalidPosition);
298  	}
299  	const PointDocument ptdoc = DocumentPointFromView(pt);
300  	return view.SPositionFromLocation(surface, *this, ptdoc, canReturnInvalid,
301  		charPosition, virtualSpace, vs, rcClient);
302  }
303  Sci::Position Editor::PositionFromLocation(Point pt, bool canReturnInvalid, bool charPosition) {
304  	return SPositionFromLocation(pt, canReturnInvalid, charPosition, false).Position();
305  }
306  SelectionPosition Editor::SPositionFromLineX(Sci::Line lineDoc, int x) {
307  	RefreshStyleData();
308  	if (lineDoc &gt;= pdoc-&gt;LinesTotal())
309  		return SelectionPosition(pdoc-&gt;Length());
310  	AutoSurface surface(this);
311  	return view.SPositionFromLineX(surface, *this, lineDoc, x, vs);
312  }
313  Sci::Position Editor::PositionFromLineX(Sci::Line lineDoc, int x) {
314  	return SPositionFromLineX(lineDoc, x).Position();
315  }
316  Sci::Line Editor::LineFromLocation(Point pt) const noexcept {
317  	return pcs-&gt;DocFromDisplay(static_cast&lt;int&gt;(pt.y) / vs.lineHeight + topLine);
318  }
319  void Editor::SetTopLine(Sci::Line topLineNew) {
320  	if ((topLine != topLineNew) &amp;&amp; (topLineNew &gt;= 0)) {
321  		topLine = topLineNew;
322  		ContainerNeedsUpdate(Update::VScroll);
323  	}
324  	posTopLine = pdoc-&gt;LineStart(pcs-&gt;DocFromDisplay(topLine));
325  }
326  bool Editor::AbandonPaint() {
327  	if ((paintState == PaintState::painting) &amp;&amp; !paintingAllText) {
328  		paintState = PaintState::abandoned;
329  	}
330  	return paintState == PaintState::abandoned;
331  }
332  void Editor::RedrawRect(PRectangle rc) {
333  	const PRectangle rcClient = GetClientRectangle();
334  	if (rc.top &lt; rcClient.top)
335  		rc.top = rcClient.top;
336  	if (rc.bottom &gt; rcClient.bottom)
337  		rc.bottom = rcClient.bottom;
338  	if (rc.left &lt; rcClient.left)
339  		rc.left = rcClient.left;
340  	if (rc.right &gt; rcClient.right)
341  		rc.right = rcClient.right;
342  	if ((rc.bottom &gt; rc.top) &amp;&amp; (rc.right &gt; rc.left)) {
343  		wMain.InvalidateRectangle(rc);
344  	}
345  }
346  void Editor::DiscardOverdraw() {
347  }
348  void Editor::Redraw() {
349  	if (redrawPendingText) {
350  		return;
351  	}
352  	const PRectangle rcClient = GetClientRectangle();
353  	wMain.InvalidateRectangle(rcClient);
354  	if (HasMarginWindow()) {
355  		wMargin.InvalidateAll();
356  	} else if (paintState == PaintState::notPainting) {
357  		redrawPendingText = true;
358  	}
359  }
360  void Editor::RedrawSelMargin(Sci::Line line, bool allAfter) {
361  	const bool markersInText = vs.maskInLine || vs.maskDrawInText;
362  	if (!HasMarginWindow() || markersInText) {	
363  		if (AbandonPaint()) {
364  			return;
365  		}
366  	}
367  	if (HasMarginWindow() &amp;&amp; markersInText) {
368  		Redraw();
369  		return;
370  	}
371  	if (redrawPendingMargin) {
372  		return;
373  	}
374  	PRectangle rcMarkers = GetClientRectangle();
375  	if (!markersInText) {
376  		rcMarkers.right = rcMarkers.left + vs.fixedColumnWidth;
377  	}
378  	const PRectangle rcMarkersFull = rcMarkers;
379  	if (line != -1) {
380  		PRectangle rcLine = RectangleFromRange(Range(pdoc-&gt;LineStart(line)), 0);
381  		if (vs.largestMarkerHeight &gt; vs.lineHeight) {
382  			const int delta = (vs.largestMarkerHeight - vs.lineHeight + 1) / 2;
383  			rcLine.top -= delta;
384  			rcLine.bottom += delta;
385  			if (rcLine.top &lt; rcMarkers.top)
386  				rcLine.top = rcMarkers.top;
387  			if (rcLine.bottom &gt; rcMarkers.bottom)
388  				rcLine.bottom = rcMarkers.bottom;
389  		}
390  		rcMarkers.top = rcLine.top;
391  		if (!allAfter)
392  			rcMarkers.bottom = rcLine.bottom;
393  		if (rcMarkers.Empty())
394  			return;
395  	}
396  	if (HasMarginWindow()) {
397  		const Point ptOrigin = GetVisibleOriginInMain();
398  		rcMarkers.Move(-ptOrigin.x, -ptOrigin.y);
399  		wMargin.InvalidateRectangle(rcMarkers);
400  	} else {
401  		wMain.InvalidateRectangle(rcMarkers);
402  		if (rcMarkers == rcMarkersFull) {
403  			redrawPendingMargin = true;
404  		}
405  	}
406  }
407  PRectangle Editor::RectangleFromRange(Range r, int overlap) {
408  	const Sci::Line minLine = pcs-&gt;DisplayFromDoc(
409  		pdoc-&gt;SciLineFromPosition(r.First()));
410  	const Sci::Line maxLine = pcs-&gt;DisplayLastFromDoc(
411  		pdoc-&gt;SciLineFromPosition(r.Last()));
412  	const PRectangle rcClientDrawing = GetClientDrawingRectangle();
413  	PRectangle rc;
414  	const int leftTextOverlap = ((xOffset == 0) &amp;&amp; (vs.leftMarginWidth &gt; 0)) ? 1 : 0;
415  	rc.left = static_cast&lt;XYPOSITION&gt;(vs.textStart - leftTextOverlap);
416  	rc.top = static_cast&lt;XYPOSITION&gt;((minLine - TopLineOfMain()) * vs.lineHeight - overlap);
417  	if (rc.top &lt; rcClientDrawing.top)
418  		rc.top = rcClientDrawing.top;
419  	rc.right = rcClientDrawing.right;
420  	rc.bottom = static_cast&lt;XYPOSITION&gt;((maxLine - TopLineOfMain() + 1) * vs.lineHeight + overlap);
421  	return rc;
422  }
423  void Editor::InvalidateRange(Sci::Position start, Sci::Position end) {
424  	if (redrawPendingText) {
425  		return;
426  	}
427  	RedrawRect(RectangleFromRange(Range(start, end), view.LinesOverlap() ? vs.lineOverlap : 0));
428  }
429  Sci::Position Editor::CurrentPosition() const noexcept {
430  	return sel.MainCaret();
431  }
432  bool Editor::SelectionEmpty() const noexcept {
433  	return sel.Empty();
434  }
435  SelectionPosition Editor::SelectionStart() noexcept {
436  	return sel.RangeMain().Start();
437  }
438  SelectionPosition Editor::SelectionEnd() noexcept {
439  	return sel.RangeMain().End();
440  }
441  void Editor::SetRectangularRange() {
442  	if (sel.IsRectangular()) {
443  		const int xAnchor = XFromPosition(sel.Rectangular().anchor);
444  		int xCaret = XFromPosition(sel.Rectangular().caret);
445  		if (sel.selType == Selection::SelTypes::thin) {
446  			xCaret = xAnchor;
447  		}
448  		const Sci::Line lineAnchorRect =
449  			pdoc-&gt;SciLineFromPosition(sel.Rectangular().anchor.Position());
450  		const Sci::Line lineCaret =
451  			pdoc-&gt;SciLineFromPosition(sel.Rectangular().caret.Position());
452  		const int increment = (lineCaret &gt; lineAnchorRect) ? 1 : -1;
453  		AutoSurface surface(this);
454  		for (Sci::Line line=lineAnchorRect; line != lineCaret+increment; line += increment) {
455  			SelectionRange range(
456  				view.SPositionFromLineX(surface, *this, line, xCaret, vs),
457  				view.SPositionFromLineX(surface, *this, line, xAnchor, vs));
458  			if (!FlagSet(virtualSpaceOptions, VirtualSpace::RectangularSelection))
459  				range.ClearVirtualSpace();
460  			if (line == lineAnchorRect)
461  				sel.SetSelection(range);
462  			else
463  				sel.AddSelectionWithoutTrim(range);
464  		}
465  	}
466  }
467  void Editor::ThinRectangularRange() {
468  	if (sel.IsRectangular()) {
469  		sel.selType = Selection::SelTypes::thin;
470  		if (sel.Rectangular().caret &lt; sel.Rectangular().anchor) {
471  			sel.Rectangular() = SelectionRange(sel.Range(sel.Count()-1).caret, sel.Range(0).anchor);
472  		} else {
473  			sel.Rectangular() = SelectionRange(sel.Range(sel.Count()-1).anchor, sel.Range(0).caret);
474  		}
475  		SetRectangularRange();
476  	}
477  }
478  void Editor::InvalidateSelection(SelectionRange newMain, bool invalidateWholeSelection) {
479  	if (sel.Count() &gt; 1 || !(sel.RangeMain().anchor == newMain.anchor) || sel.IsRectangular()) {
480  		invalidateWholeSelection = true;
481  	}
482  	Sci::Position firstAffected = std::min(sel.RangeMain().Start().Position(), newMain.Start().Position());
483  	Sci::Position lastAffected = std::max(newMain.caret.Position()+1, newMain.anchor.Position());
484  	lastAffected = std::max(lastAffected, sel.RangeMain().End().Position());
485  	if (invalidateWholeSelection) {
486  		for (size_t r=0; r&lt;sel.Count(); r++) {
487  			firstAffected = std::min(firstAffected, sel.Range(r).caret.Position());
488  			firstAffected = std::min(firstAffected, sel.Range(r).anchor.Position());
489  			lastAffected = std::max(lastAffected, sel.Range(r).caret.Position()+1);
490  			lastAffected = std::max(lastAffected, sel.Range(r).anchor.Position());
491  		}
492  	}
493  	ContainerNeedsUpdate(Update::Selection);
494  	InvalidateRange(firstAffected, lastAffected);
495  }
496  void Editor::InvalidateWholeSelection() {
497  	InvalidateSelection(sel.RangeMain(), true);
498  }
499  SelectionRange Editor::LineSelectionRange(SelectionPosition currentPos_, SelectionPosition anchor_) const {
500  	if (currentPos_ &gt; anchor_) {
501  		anchor_ = SelectionPosition(
502  			pdoc-&gt;LineStart(pdoc-&gt;LineFromPosition(anchor_.Position())));
503  		currentPos_ = SelectionPosition(
504  			pdoc-&gt;LineEnd(pdoc-&gt;LineFromPosition(currentPos_.Position())));
505  	} else {
506  		currentPos_ = SelectionPosition(
507  			pdoc-&gt;LineStart(pdoc-&gt;LineFromPosition(currentPos_.Position())));
508  		anchor_ = SelectionPosition(
509  			pdoc-&gt;LineEnd(pdoc-&gt;LineFromPosition(anchor_.Position())));
510  	}
511  	return SelectionRange(currentPos_, anchor_);
512  }
513  void Editor::SetSelection(SelectionPosition currentPos_, SelectionPosition anchor_) {
514  	currentPos_ = ClampPositionIntoDocument(currentPos_);
515  	anchor_ = ClampPositionIntoDocument(anchor_);
516  	const Sci::Line currentLine = pdoc-&gt;SciLineFromPosition(currentPos_.Position());
517  	SelectionRange rangeNew(currentPos_, anchor_);
518  	if (sel.selType == Selection::SelTypes::lines) {
519  		rangeNew = LineSelectionRange(currentPos_, anchor_);
520  	}
521  	if (sel.Count() &gt; 1 || !(sel.RangeMain() == rangeNew)) {
522  		InvalidateSelection(rangeNew);
523  	}
524  	sel.RangeMain() = rangeNew;
525  	SetRectangularRange();
526  	ClaimSelection();
527  	SetHoverIndicatorPosition(sel.MainCaret());
528  	if (marginView.highlightDelimiter.NeedsDrawing(currentLine)) {
529  		RedrawSelMargin();
530  	}
531  	QueueIdleWork(WorkItems::updateUI);
532  }
533  void Editor::SetSelection(Sci::Position currentPos_, Sci::Position anchor_) {
534  	SetSelection(SelectionPosition(currentPos_), SelectionPosition(anchor_));
535  }
536  void Editor::SetSelection(SelectionPosition currentPos_) {
537  	currentPos_ = ClampPositionIntoDocument(currentPos_);
538  	const Sci::Line currentLine = pdoc-&gt;SciLineFromPosition(currentPos_.Position());
539  	if (sel.Count() &gt; 1 || !(sel.RangeMain().caret == currentPos_)) {
540  		InvalidateSelection(SelectionRange(currentPos_));
541  	}
542  	if (sel.IsRectangular()) {
543  		sel.Rectangular() =
544  			SelectionRange(SelectionPosition(currentPos_), sel.Rectangular().anchor);
545  		SetRectangularRange();
546  	} else if (sel.selType == Selection::SelTypes::lines) {
547  		sel.RangeMain() = LineSelectionRange(currentPos_, sel.RangeMain().anchor);
548  	} else {
549  		sel.RangeMain() =
550  			SelectionRange(SelectionPosition(currentPos_), sel.RangeMain().anchor);
551  	}
552  	ClaimSelection();
553  	SetHoverIndicatorPosition(sel.MainCaret());
554  	if (marginView.highlightDelimiter.NeedsDrawing(currentLine)) {
555  		RedrawSelMargin();
556  	}
557  	QueueIdleWork(WorkItems::updateUI);
558  }
559  void Editor::SetEmptySelection(SelectionPosition currentPos_) {
560  	const Sci::Line currentLine = pdoc-&gt;SciLineFromPosition(currentPos_.Position());
561  	SelectionRange rangeNew(ClampPositionIntoDocument(currentPos_));
562  	if (sel.Count() &gt; 1 || !(sel.RangeMain() == rangeNew)) {
563  		InvalidateSelection(rangeNew);
564  	}
565  	sel.Clear();
566  	sel.RangeMain() = rangeNew;
567  	SetRectangularRange();
568  	ClaimSelection();
569  	SetHoverIndicatorPosition(sel.MainCaret());
570  	if (marginView.highlightDelimiter.NeedsDrawing(currentLine)) {
571  		RedrawSelMargin();
572  	}
573  	QueueIdleWork(WorkItems::updateUI);
574  }
575  void Editor::SetEmptySelection(Sci::Position currentPos_) {
576  	SetEmptySelection(SelectionPosition(currentPos_));
577  }
578  void Editor::MultipleSelectAdd(AddNumber addNumber) {
579  	if (SelectionEmpty() || !multipleSelection) {
580  		const Sci::Position startWord = pdoc-&gt;ExtendWordSelect(sel.MainCaret(), -1, true);
581  		const Sci::Position endWord = pdoc-&gt;ExtendWordSelect(startWord, 1, true);
582  		TrimAndSetSelection(endWord, startWord);
583  	} else {
584  		if (!pdoc-&gt;HasCaseFolder())
585  			pdoc-&gt;SetCaseFolder(CaseFolderForEncoding());
586  		const Range rangeMainSelection(sel.RangeMain().Start().Position(), sel.RangeMain().End().Position());
587  		const std::string selectedText = RangeText(rangeMainSelection.start, rangeMainSelection.end);
588  		const Range rangeTarget(targetRange.start.Position(), targetRange.end.Position());
589  		std::vector&lt;Range&gt; searchRanges;
590  		if (rangeTarget.Overlaps(rangeMainSelection)) {
591  			if (rangeMainSelection.end &lt; rangeTarget.end)
592  				searchRanges.push_back(Range(rangeMainSelection.end, rangeTarget.end));
593  			if (rangeTarget.start &lt; rangeMainSelection.start)
594  				searchRanges.push_back(Range(rangeTarget.start, rangeMainSelection.start));
595  		} else {
596  			searchRanges.push_back(rangeTarget);
597  		}
598  		for (const Range range : searchRanges) {
599  			Sci::Position searchStart = range.start;
600  			const Sci::Position searchEnd = range.end;
601  			for (;;) {
602  				Sci::Position lengthFound = selectedText.length();
603  				const Sci::Position pos = pdoc-&gt;FindText(searchStart, searchEnd,
604  					selectedText.c_str(), searchFlags, &amp;lengthFound);
605  				if (pos &gt;= 0) {
606  					sel.AddSelection(SelectionRange(pos + lengthFound, pos));
607  					ContainerNeedsUpdate(Update::Selection);
608  					ScrollRange(sel.RangeMain());
609  					Redraw();
610  					if (addNumber == AddNumber::one)
611  						return;
612  					searchStart = pos + lengthFound;
613  				} else {
614  					break;
615  				}
616  			}
617  		}
618  	}
619  }
620  bool Editor::RangeContainsProtected(Sci::Position start, Sci::Position end) const noexcept {
621  	if (vs.ProtectionActive()) {
622  		if (start &gt; end) {
623  			std::swap(start, end);
624  		}
625  		for (Sci::Position pos = start; pos &lt; end; pos++) {
626  			if (vs.styles[pdoc-&gt;StyleIndexAt(pos)].IsProtected())
627  				return true;
628  		}
629  	}
630  	return false;
631  }
632  bool Editor::SelectionContainsProtected() const noexcept {
633  	for (size_t r=0; r&lt;sel.Count(); r++) {
634  		if (RangeContainsProtected(sel.Range(r).Start().Position(),
635  			sel.Range(r).End().Position())) {
636  			return true;
637  		}
638  	}
639  	return false;
640  }
641  Sci::Position Editor::MovePositionOutsideChar(Sci::Position pos, Sci::Position moveDir, bool checkLineEnd) const {
642  	return MovePositionOutsideChar(SelectionPosition(pos), moveDir, checkLineEnd).Position();
643  }
644  SelectionPosition Editor::MovePositionOutsideChar(SelectionPosition pos, Sci::Position moveDir, bool checkLineEnd) const {
645  	const Sci::Position posMoved = pdoc-&gt;MovePositionOutsideChar(pos.Position(), moveDir, checkLineEnd);
646  	if (posMoved != pos.Position())
647  		pos.SetPosition(posMoved);
648  	if (vs.ProtectionActive()) {
649  		if (moveDir &gt; 0) {
650  			if ((pos.Position() &gt; 0) &amp;&amp; vs.styles[pdoc-&gt;StyleIndexAt(pos.Position() - 1)].IsProtected()) {
651  				while ((pos.Position() &lt; pdoc-&gt;Length()) &amp;&amp;
652  				        (vs.styles[pdoc-&gt;StyleIndexAt(pos.Position())].IsProtected()))
653  					pos.Add(1);
654  			}
655  		} else if (moveDir &lt; 0) {
656  			if (vs.styles[pdoc-&gt;StyleIndexAt(pos.Position())].IsProtected()) {
657  				while ((pos.Position() &gt; 0) &amp;&amp;
658  				        (vs.styles[pdoc-&gt;StyleIndexAt(pos.Position() - 1)].IsProtected()))
659  					pos.Add(-1);
660  			}
661  		}
662  	}
663  	return pos;
664  }
665  void Editor::MovedCaret(SelectionPosition newPos, SelectionPosition previousPos,
666  	bool ensureVisible, CaretPolicies policies) {
667  	const Sci::Line currentLine = pdoc-&gt;SciLineFromPosition(newPos.Position());
668  	if (ensureVisible) {
669  		if (currentLine &gt;= wrapPending.start) {
670  			if (WrapLines(WrapScope::wsAll)) {
671  				Redraw();
672  			}
673  		}
674  		const XYScrollPosition newXY = XYScrollToMakeVisible(
675  			SelectionRange(posDrag.IsValid() ? posDrag : newPos), XYScrollOptions::all, policies);
676  		if (previousPos.IsValid() &amp;&amp; (newXY.xOffset == xOffset)) {
677  			ScrollTo(newXY.topLine);
678  			InvalidateSelection(SelectionRange(previousPos), true);
679  		} else {
680  			SetXYScroll(newXY);
681  		}
682  	}
683  	ShowCaretAtCurrentPosition();
684  	NotifyCaretMove();
685  	ClaimSelection();
686  	SetHoverIndicatorPosition(sel.MainCaret());
687  	QueueIdleWork(WorkItems::updateUI);
688  	if (marginView.highlightDelimiter.NeedsDrawing(currentLine)) {
689  		RedrawSelMargin();
690  	}
691  }
692  void Editor::MovePositionTo(SelectionPosition newPos, Selection::SelTypes selt, bool ensureVisible) {
693  	const SelectionPosition spCaret = ((sel.Count() == 1) &amp;&amp; sel.Empty()) ?
694  		sel.Last() : SelectionPosition(Sci::invalidPosition);
695  	const Sci::Position delta = newPos.Position() - sel.MainCaret();
696  	newPos = ClampPositionIntoDocument(newPos);
697  	newPos = MovePositionOutsideChar(newPos, delta);
698  	if (!multipleSelection &amp;&amp; sel.IsRectangular() &amp;&amp; (selt == Selection::SelTypes::stream)) {
699  		InvalidateSelection(SelectionRange(newPos), true);
700  		sel.DropAdditionalRanges();
701  	}
702  	if (!sel.IsRectangular() &amp;&amp; (selt == Selection::SelTypes::rectangle)) {
703  		InvalidateSelection(sel.RangeMain(), false);
704  		SelectionRange rangeMain = sel.RangeMain();
705  		sel.Clear();
706  		sel.Rectangular() = rangeMain;
707  	}
708  	if (selt != Selection::SelTypes::none) {
709  		sel.selType = selt;
710  	}
711  	if (selt != Selection::SelTypes::none || sel.MoveExtends()) {
712  		SetSelection(newPos);
713  	} else {
714  		SetEmptySelection(newPos);
715  	}
716  	MovedCaret(newPos, spCaret, ensureVisible, caretPolicies);
717  }
718  void Editor::MovePositionTo(Sci::Position newPos, Selection::SelTypes selt, bool ensureVisible) {
719  	MovePositionTo(SelectionPosition(newPos), selt, ensureVisible);
720  }
721  SelectionPosition Editor::MovePositionSoVisible(SelectionPosition pos, int moveDir) {
722  	pos = ClampPositionIntoDocument(pos);
723  	pos = MovePositionOutsideChar(pos, moveDir);
724  	const Sci::Line lineDoc = pdoc-&gt;SciLineFromPosition(pos.Position());
725  	if (pcs-&gt;GetVisible(lineDoc)) {
726  		return pos;
727  	} else {
728  		Sci::Line lineDisplay = pcs-&gt;DisplayFromDoc(lineDoc);
729  		if (moveDir &gt; 0) {
730  			lineDisplay = std::clamp&lt;Sci::Line&gt;(lineDisplay, 0, pcs-&gt;LinesDisplayed());
731  			return SelectionPosition(
732  				pdoc-&gt;LineStart(pcs-&gt;DocFromDisplay(lineDisplay)));
733  		} else {
734  			lineDisplay = std::clamp&lt;Sci::Line&gt;(lineDisplay - 1, 0, pcs-&gt;LinesDisplayed());
735  			return SelectionPosition(
736  				pdoc-&gt;LineEnd(pcs-&gt;DocFromDisplay(lineDisplay)));
737  		}
738  	}
739  }
740  SelectionPosition Editor::MovePositionSoVisible(Sci::Position pos, int moveDir) {
741  	return MovePositionSoVisible(SelectionPosition(pos), moveDir);
742  }
743  Point Editor::PointMainCaret() {
744  	return LocationFromPosition(sel.Range(sel.Main()).caret);
745  }
746  void Editor::SetLastXChosen() {
747  	const Point pt = PointMainCaret();
748  	lastXChosen = static_cast&lt;int&gt;(pt.x) + xOffset;
749  }
750  void Editor::ScrollTo(Sci::Line line, bool moveThumb) {
751  	const Sci::Line topLineNew = std::clamp&lt;Sci::Line&gt;(line, 0, MaxScrollPos());
752  	if (topLineNew != topLine) {
753  #ifndef UNDER_CE
754  		const Sci::Line linesToMove = topLine - topLineNew;
755  		const bool performBlit = (std::abs(linesToMove) &lt;= 10) &amp;&amp; (paintState == PaintState::notPainting);
756  		willRedrawAll = !performBlit;
757  #endif
758  		SetTopLine(topLineNew);
759  		StyleAreaBounded(GetClientRectangle(), true);
760  #ifndef UNDER_CE
761  		if (performBlit) {
762  			ScrollText(linesToMove);
763  		} else {
764  			Redraw();
765  		}
766  		willRedrawAll = false;
767  #else
768  		Redraw();
769  #endif
770  		if (moveThumb) {
771  			SetVerticalScrollPos();
772  		}
773  	}
774  }
775  void Editor::ScrollText(Sci::Line &amp;bsol;* linesToMove */) {
776  	Redraw();
777  }
778  void Editor::HorizontalScrollTo(int xPos) {
779  	if (xPos &lt; 0)
780  		xPos = 0;
781  	if (!Wrapping() &amp;&amp; (xOffset != xPos)) {
782  		xOffset = xPos;
783  		ContainerNeedsUpdate(Update::HScroll);
784  		SetHorizontalScrollPos();
785  		RedrawRect(GetClientRectangle());
786  	}
787  }
788  void Editor::VerticalCentreCaret() {
789  	const Sci::Line lineDoc =
790  		pdoc-&gt;SciLineFromPosition(sel.IsRectangular() ? sel.Rectangular().caret.Position() : sel.MainCaret());
791  	const Sci::Line lineDisplay = pcs-&gt;DisplayFromDoc(lineDoc);
792  	const Sci::Line newTop = lineDisplay - (LinesOnScreen() / 2);
793  	if (topLine != newTop) {
794  		SetTopLine(newTop &gt; 0 ? newTop : 0);
795  		SetVerticalScrollPos();
796  		RedrawRect(GetClientRectangle());
797  	}
798  }
799  void Editor::MoveSelectedLines(int lineDelta) {
800  	if (sel.IsRectangular()) {
801  		return;
802  	}
803  	Sci::Position selectionStart = SelectionStart().Position();
804  	const Sci::Line startLine = pdoc-&gt;SciLineFromPosition(selectionStart);
805  	const Sci::Position beginningOfStartLine = pdoc-&gt;LineStart(startLine);
806  	selectionStart = beginningOfStartLine;
807  	Sci::Position selectionEnd = SelectionEnd().Position();
808  	const Sci::Line endLine = pdoc-&gt;SciLineFromPosition(selectionEnd);
809  	const Sci::Position beginningOfEndLine = pdoc-&gt;LineStart(endLine);
810  	bool appendEol = false;
811  	if (selectionEnd &gt; beginningOfEndLine
812  		|| selectionStart == selectionEnd) {
813  		selectionEnd = pdoc-&gt;LineStart(endLine + 1);
814  		appendEol = (selectionEnd == pdoc-&gt;Length() &amp;&amp; pdoc-&gt;SciLineFromPosition(selectionEnd) == endLine);
815  	}
816  	if ((selectionStart == 0 &amp;&amp; lineDelta &lt; 0)
817  		|| (selectionEnd == pdoc-&gt;Length() &amp;&amp; lineDelta &gt; 0)
818  	        || selectionStart == selectionEnd) {
819  		return;
820  	}
821  	UndoGroup ug(pdoc);
822  	if (lineDelta &gt; 0 &amp;&amp; selectionEnd == pdoc-&gt;LineStart(pdoc-&gt;LinesTotal() - 1)) {
823  		SetSelection(pdoc-&gt;MovePositionOutsideChar(selectionEnd - 1, -1), selectionEnd);
824  		ClearSelection();
825  		selectionEnd = CurrentPosition();
826  	}
827  	SetSelection(selectionStart, selectionEnd);
828  	const std::string selectedText = RangeText(selectionStart, selectionEnd);
829  	const Point currentLocation = LocationFromPosition(CurrentPosition());
830  	const Sci::Line currentLine = LineFromLocation(currentLocation);
831  	if (appendEol)
832  		SetSelection(pdoc-&gt;MovePositionOutsideChar(selectionStart - 1, -1), selectionEnd);
833  	ClearSelection();
834  	const std::string_view eol = pdoc-&gt;EOLString();
835  	if (currentLine + lineDelta &gt;= pdoc-&gt;LinesTotal())
836  		pdoc-&gt;InsertString(pdoc-&gt;Length(), eol);
837  	GoToLine(currentLine + lineDelta);
838  	Sci::Position selectionLength = pdoc-&gt;InsertString(CurrentPosition(), selectedText);
839  	if (appendEol) {
840  		const Sci::Position lengthInserted = pdoc-&gt;InsertString(CurrentPosition() + selectionLength, eol);
841  		selectionLength += lengthInserted;
842  	}
843  	SetSelection(CurrentPosition(), CurrentPosition() + selectionLength);
844  }
845  void Editor::MoveSelectedLinesUp() {
846  	MoveSelectedLines(-1);
847  }
848  void Editor::MoveSelectedLinesDown() {
849  	MoveSelectedLines(1);
850  }
851  void Editor::MoveCaretInsideView(bool ensureVisible) {
852  	const PRectangle rcClient = GetTextRectangle();
853  	const Point pt = PointMainCaret();
854  	if (pt.y &lt; rcClient.top) {
855  		MovePositionTo(SPositionFromLocation(
856  		            Point::FromInts(lastXChosen - xOffset, static_cast&lt;int&gt;(rcClient.top)),
857  					false, false, UserVirtualSpace()),
858  					Selection::SelTypes::none, ensureVisible);
859  	} else if ((pt.y + vs.lineHeight - 1) &gt; rcClient.bottom) {
860  		const ptrdiff_t yOfLastLineFullyDisplayed = static_cast&lt;ptrdiff_t&gt;(rcClient.top) + (LinesOnScreen() - 1) * vs.lineHeight;
861  		MovePositionTo(SPositionFromLocation(
862  		            Point::FromInts(lastXChosen - xOffset, static_cast&lt;int&gt;(rcClient.top + yOfLastLineFullyDisplayed)),
863  					false, false, UserVirtualSpace()),
864  		        Selection::SelTypes::none, ensureVisible);
865  	}
866  }
867  Sci::Line Editor::DisplayFromPosition(Sci::Position pos) {
868  	AutoSurface surface(this);
869  	return view.DisplayFromPosition(surface, *this, pos, vs);
870  }
871  Editor::XYScrollPosition Editor::XYScrollToMakeVisible(const SelectionRange &amp;range,
872  	const XYScrollOptions options, CaretPolicies policies) {
873  	const PRectangle rcClient = GetTextRectangle();
874  	const Point ptOrigin = GetVisibleOriginInMain();
875  	const Point pt = LocationFromPosition(range.caret) + ptOrigin;
876  	const Point ptAnchor = LocationFromPosition(range.anchor) + ptOrigin;
877  	const Point ptBottomCaret(pt.x, pt.y + vs.lineHeight - 1);
878  	XYScrollPosition newXY(xOffset, topLine);
879  	if (rcClient.Empty()) {
880  		return newXY;
881  	}
882  	if (FlagSet(options, XYScrollOptions::vertical) &amp;&amp;
883  		(pt.y &lt; rcClient.top || ptBottomCaret.y &gt;= rcClient.bottom || FlagSet(policies.y.policy, CaretPolicy::Strict))) {
884  		const Sci::Line lineCaret = DisplayFromPosition(range.caret.Position());
885  		const Sci::Line linesOnScreen = LinesOnScreen();
886  		const Sci::Line halfScreen = std::max(linesOnScreen - 1, static_cast&lt;Sci::Line&gt;(2)) / 2;
887  		const bool bSlop = FlagSet(policies.y.policy, CaretPolicy::Slop);
888  		const bool bStrict = FlagSet(policies.y.policy, CaretPolicy::Strict);
889  		const bool bJump = FlagSet(policies.y.policy, CaretPolicy::Jumps);
890  		const bool bEven = FlagSet(policies.y.policy, CaretPolicy::Even);
891  		if (bSlop) {	
892  			Sci::Line yMoveT = 0;
893  			Sci::Line yMoveB = 0;
894  			if (bStrict) {
895  				Sci::Line yMarginT = 0;
896  				Sci::Line yMarginB = 0;
897  				if (!FlagSet(options, XYScrollOptions::useMargin)) {
898  					yMarginT = yMarginB = 0;
899  				} else {
900  					yMarginT = std::clamp&lt;Sci::Line&gt;(policies.y.slop, 1, halfScreen);
901  					if (bEven) {
902  						yMarginB = yMarginT;
903  					} else {
904  						yMarginB = linesOnScreen - yMarginT - 1;
905  					}
906  				}
907  				yMoveT = yMarginT;
908  				if (bEven) {
909  					if (bJump) {
910  						yMoveT = std::clamp&lt;Sci::Line&gt;(policies.y.slop * 3, 1, halfScreen);
911  					}
912  					yMoveB = yMoveT;
913  				} else {
914  					yMoveB = linesOnScreen - yMoveT - 1;
915  				}
916  				if (lineCaret &lt; topLine + yMarginT) {
917  					newXY.topLine = lineCaret - yMoveT;
918  				} else if (lineCaret &gt; topLine + linesOnScreen - 1 - yMarginB) {
919  					newXY.topLine = lineCaret - linesOnScreen + 1 + yMoveB;
920  				}
921  			} else {	
922  				yMoveT = bJump ? policies.y.slop * 3 : policies.y.slop;
923  				yMoveT = std::clamp&lt;Sci::Line&gt;(yMoveT, 1, halfScreen);
924  				if (bEven) {
925  					yMoveB = yMoveT;
926  				} else {
927  					yMoveB = linesOnScreen - yMoveT - 1;
928  				}
929  				if (lineCaret &lt; topLine) {
930  					newXY.topLine = lineCaret - yMoveT;
931  				} else if (lineCaret &gt; topLine + linesOnScreen - 1) {
932  					newXY.topLine = lineCaret - linesOnScreen + 1 + yMoveB;
933  				}
934  			}
935  		} else {	
936  			if (!bStrict &amp;&amp; !bJump) {
937  				if (lineCaret &lt; topLine) {
938  					newXY.topLine = lineCaret;
939  				} else if (lineCaret &gt; topLine + linesOnScreen - 1) {
940  					if (bEven) {
941  						newXY.topLine = lineCaret - linesOnScreen + 1;
942  					} else {
943  						newXY.topLine = lineCaret;
944  					}
945  				}
946  			} else {	
947  				if (bEven) {
948  					newXY.topLine = lineCaret - halfScreen;
949  				} else {
950  					newXY.topLine = lineCaret;
951  				}
952  			}
953  		}
954  		if (!(range.caret == range.anchor)) {
955  			const Sci::Line lineAnchor = DisplayFromPosition(range.anchor.Position());
956  			if (lineAnchor &lt; lineCaret) {
957  				newXY.topLine = std::min(newXY.topLine, lineAnchor);
958  				newXY.topLine = std::max(newXY.topLine, lineCaret - LinesOnScreen());
959  			} else {
960  				newXY.topLine = std::max(newXY.topLine, lineAnchor - LinesOnScreen());
961  				newXY.topLine = std::min(newXY.topLine, lineCaret);
962  			}
963  		}
964  		newXY.topLine = std::clamp&lt;Sci::Line&gt;(newXY.topLine, 0, MaxScrollPos());
965  	}
966  	if (FlagSet(options, XYScrollOptions::horizontal) &amp;&amp; !Wrapping()) {
967  		const int halfScreen = std::max(static_cast&lt;int&gt;(rcClient.Width()) - 4, 4) / 2;
968  		const bool bSlop = FlagSet(policies.x.policy, CaretPolicy::Slop);
969  		const bool bStrict = FlagSet(policies.x.policy, CaretPolicy::Strict);
970  		const bool bJump = FlagSet(policies.x.policy, CaretPolicy::Jumps);
971  		const bool bEven = FlagSet(policies.x.policy, CaretPolicy::Even);
972  		if (bSlop) {	
973  			int xMoveL = 0;
974  			int xMoveR = 0;
975  			if (bStrict) {
976  				int xMarginL = 0;
977  				int xMarginR = 0;
978  				if (!FlagSet(options, XYScrollOptions::useMargin)) {
979  					xMarginL = xMarginR = 2;
980  				} else {
981  					xMarginR = std::clamp(policies.x.slop, 2, halfScreen);
982  					if (bEven) {
983  						xMarginL = xMarginR;
984  					} else {
985  						xMarginL = static_cast&lt;int&gt;(rcClient.Width()) - xMarginR - 4;
986  					}
987  				}
988  				if (bJump &amp;&amp; bEven) {
989  					xMoveL = xMoveR = std::clamp(policies.x.slop * 3, 1, halfScreen);
990  				} else {
991  					xMoveL = xMoveR = 0;	
992  				}
993  				if (pt.x &lt; rcClient.left + xMarginL) {
994  					if (bJump &amp;&amp; bEven) {
995  						newXY.xOffset -= xMoveL;
996  					} else {
997  						newXY.xOffset -= static_cast&lt;int&gt;((rcClient.left + xMarginL) - pt.x);
998  					}
999  				} else if (pt.x &gt;= rcClient.right - xMarginR) {
1000  					if (bJump &amp;&amp; bEven) {
1001  						newXY.xOffset += xMoveR;
1002  					} else {
1003  						newXY.xOffset += static_cast&lt;int&gt;(pt.x - (rcClient.right - xMarginR) + 1);
1004  					}
1005  				}
1006  			} else {	
1007  				xMoveR = bJump ? policies.x.slop * 3 : policies.x.slop;
1008  				xMoveR = std::clamp(xMoveR, 1, halfScreen);
1009  				if (bEven) {
1010  					xMoveL = xMoveR;
1011  				} else {
1012  					xMoveL = static_cast&lt;int&gt;(rcClient.Width()) - xMoveR - 4;
1013  				}
1014  				if (pt.x &lt; rcClient.left) {
1015  					newXY.xOffset -= xMoveL;
1016  				} else if (pt.x &gt;= rcClient.right) {
1017  					newXY.xOffset += xMoveR;
1018  				}
1019  			}
1020  		} else {	
1021  			if (bStrict ||
1022  			        (bJump &amp;&amp; (pt.x &lt; rcClient.left || pt.x &gt;= rcClient.right))) {
1023  				if (bEven) {
1024  					newXY.xOffset += static_cast&lt;int&gt;(pt.x - rcClient.left - halfScreen);
1025  				} else {
1026  					newXY.xOffset += static_cast&lt;int&gt;(pt.x - rcClient.right + 1);
1027  				}
1028  			} else {
1029  				if (pt.x &lt; rcClient.left) {
1030  					if (bEven) {
1031  						newXY.xOffset -= static_cast&lt;int&gt;(rcClient.left - pt.x);
1032  					} else {
1033  						newXY.xOffset += static_cast&lt;int&gt;(pt.x - rcClient.right) + 1;
1034  					}
1035  				} else if (pt.x &gt;= rcClient.right) {
1036  					newXY.xOffset += static_cast&lt;int&gt;(pt.x - rcClient.right) + 1;
1037  				}
1038  			}
1039  		}
1040  		if (pt.x + xOffset &lt; rcClient.left + newXY.xOffset) {
1041  			newXY.xOffset = static_cast&lt;int&gt;(pt.x + xOffset - rcClient.left) - 2;
1042  		} else if (pt.x + xOffset &gt;= rcClient.right + newXY.xOffset) {
1043  			newXY.xOffset = static_cast&lt;int&gt;(pt.x + xOffset - rcClient.right) + 2;
1044  			if (vs.IsBlockCaretStyle() || view.imeCaretBlockOverride) {
1045  				newXY.xOffset += static_cast&lt;int&gt;(vs.aveCharWidth);
1046  			}
1047  		}
1048  		if (!(range.caret == range.anchor)) {
1049  			if (ptAnchor.x &lt; pt.x) {
1050  				const int maxOffset = static_cast&lt;int&gt;(ptAnchor.x + xOffset - rcClient.left) - 1;
1051  				const int minOffset = static_cast&lt;int&gt;(pt.x + xOffset - rcClient.right) + 1;
1052  				newXY.xOffset = std::min(newXY.xOffset, maxOffset);
1053  				newXY.xOffset = std::max(newXY.xOffset, minOffset);
1054  			} else {
1055  				const int minOffset = static_cast&lt;int&gt;(ptAnchor.x + xOffset - rcClient.right) + 1;
1056  				const int maxOffset = static_cast&lt;int&gt;(pt.x + xOffset - rcClient.left) - 1;
1057  				newXY.xOffset = std::max(newXY.xOffset, minOffset);
1058  				newXY.xOffset = std::min(newXY.xOffset, maxOffset);
1059  			}
1060  		}
1061  		if (newXY.xOffset &lt; 0) {
1062  			newXY.xOffset = 0;
1063  		}
1064  	}
1065  	return newXY;
1066  }
1067  void Editor::SetXYScroll(XYScrollPosition newXY) {
1068  	if ((newXY.topLine != topLine) || (newXY.xOffset != xOffset)) {
1069  		if (newXY.topLine != topLine) {
1070  			SetTopLine(newXY.topLine);
1071  			SetVerticalScrollPos();
1072  		}
1073  		if (newXY.xOffset != xOffset) {
1074  			xOffset = newXY.xOffset;
1075  			ContainerNeedsUpdate(Update::HScroll);
1076  			if (newXY.xOffset &gt; 0) {
1077  				const PRectangle rcText = GetTextRectangle();
1078  				if (horizontalScrollBarVisible &amp;&amp;
1079  					rcText.Width() + xOffset &gt; scrollWidth) {
1080  					scrollWidth = xOffset + static_cast&lt;int&gt;(rcText.Width());
1081  					SetScrollBars();
1082  				}
1083  			}
1084  			SetHorizontalScrollPos();
1085  		}
1086  		Redraw();
1087  		UpdateSystemCaret();
1088  	}
1089  }
1090  void Editor::ScrollRange(SelectionRange range) {
1091  	SetXYScroll(XYScrollToMakeVisible(range, XYScrollOptions::all, caretPolicies));
1092  }
1093  void Editor::EnsureCaretVisible(bool useMargin, bool vert, bool horiz) {
1094  	SetXYScroll(XYScrollToMakeVisible(SelectionRange(posDrag.IsValid() ? posDrag : sel.RangeMain().caret),
1095  		(useMargin?XYScrollOptions::useMargin:XYScrollOptions::none)|
1096  		(vert?XYScrollOptions::vertical:XYScrollOptions::none)|
1097  		(horiz?XYScrollOptions::horizontal:XYScrollOptions::none),
1098  		caretPolicies));
1099  }
1100  void Editor::ShowCaretAtCurrentPosition() {
1101  	if (hasFocus) {
1102  		caret.active = true;
1103  		caret.on = true;
1104  		FineTickerCancel(TickReason::caret);
1105  		if (caret.period &gt; 0)
1106  			FineTickerStart(TickReason::caret, caret.period, caret.period/10);
1107  	} else {
1108  		caret.active = false;
1109  		caret.on = false;
1110  		FineTickerCancel(TickReason::caret);
1111  	}
1112  	InvalidateCaret();
1113  }
1114  void Editor::DropCaret() {
1115  	caret.active = false;
1116  	FineTickerCancel(TickReason::caret);
1117  	InvalidateCaret();
1118  }
1119  void Editor::CaretSetPeriod(int period) {
1120  	if (caret.period != period) {
1121  		caret.period = period;
1122  		caret.on = true;
1123  		FineTickerCancel(TickReason::caret);
1124  		if ((caret.active) &amp;&amp; (caret.period &gt; 0))
1125  			FineTickerStart(TickReason::caret, caret.period, caret.period/10);
1126  		InvalidateCaret();
1127  	}
1128  }
1129  void Editor::InvalidateCaret() {
1130  	if (posDrag.IsValid()) {
1131  		InvalidateRange(posDrag.Position(), posDrag.Position() + 1);
1132  	} else {
1133  		for (size_t r=0; r&lt;sel.Count(); r++) {
1134  			InvalidateRange(sel.Range(r).caret.Position(), sel.Range(r).caret.Position() + 1);
1135  		}
1136  	}
1137  	UpdateSystemCaret();
1138  }
1139  void Editor::NotifyCaretMove() {
1140  }
1141  void Editor::UpdateSystemCaret() {
1142  }
1143  bool Editor::Wrapping() const noexcept {
1144  	return vs.wrap.state != Wrap::None;
1145  }
1146  void Editor::NeedWrapping(Sci::Line docLineStart, Sci::Line docLineEnd) {
1147  	if (wrapPending.AddRange(docLineStart, docLineEnd)) {
1148  		view.llc.Invalidate(LineLayout::ValidLevel::positions);
1149  	}
1150  	if (Wrapping() &amp;&amp; wrapPending.NeedsWrap()) {
1151  		SetIdle(true);
1152  	}
1153  }
1154  bool Editor::WrapOneLine(Surface *surface, Sci::Line lineToWrap) {
1155  	std::shared_ptr&lt;LineLayout&gt; ll = view.RetrieveLineLayout(lineToWrap, *this);
1156  	int linesWrapped = 1;
1157  	if (ll) {
1158  		view.LayoutLine(*this, surface, vs, ll.get(), wrapWidth);
1159  		linesWrapped = ll-&gt;lines;
1160  	}
1161  	if (vs.annotationVisible != AnnotationVisible::Hidden) {
1162  		linesWrapped += pdoc-&gt;AnnotationLines(lineToWrap);
1163  	}
1164  	return pcs-&gt;SetHeight(lineToWrap, linesWrapped);
1165  }
1166  namespace {
1167  constexpr Sci::Position lengthToMultiThread = 4000;
1168  }
1169  bool Editor::WrapBlock(Surface *surface, Sci::Line lineToWrap, Sci::Line lineToWrapEnd) {
1170  	const size_t linesBeingWrapped = static_cast&lt;size_t&gt;(lineToWrapEnd - lineToWrap);
1171  	std::vector&lt;int&gt; linesAfterWrap(linesBeingWrapped);
1172  	size_t threads = std::min&lt;size_t&gt;({ linesBeingWrapped, view.maxLayoutThreads });
1173  	if (!surface-&gt;SupportsFeature(Supports::ThreadSafeMeasureWidths)) {
1174  		threads = 1;
1175  	}
1176  	const bool multiThreaded = threads &gt; 1;
1177  	ElapsedPeriod epWrapping;
1178  	const std::launch policy = multiThreaded ? std::launch::async : std::launch::deferred;
1179  	std::atomic&lt;size_t&gt; nextIndex = 0;
1180  	const SignificantLines significantLines {
1181  		pdoc-&gt;SciLineFromPosition(sel.MainCaret()),
1182  		pcs-&gt;DocFromDisplay(topLine),
1183  		LinesOnScreen() + 1,
1184  		view.llc.GetLevel(),
1185  	};
1186  	std::mutex mutexRetrieve;
1187  	std::vector&lt;std::future&lt;void&gt;&gt; futures;
1188  	for (size_t th = 0; th &lt; threads; th++) {
1189  		std::future&lt;void&gt; fut = std::async(policy,
1190  			[=, &amp;surface, &amp;nextIndex, &amp;linesAfterWrap, &amp;mutexRetrieve]() {
1191  			std::shared_ptr&lt;LineLayout&gt; llTemporary = std::make_shared&lt;LineLayout&gt;(-1, 200);
1192  			while (true) {
1193  				const size_t i = nextIndex.fetch_add(1, std::memory_order_acq_rel);
1194  				if (i &gt;= linesBeingWrapped) {
1195  					break;
1196  				}
1197  				const Sci::Line lineNumber = lineToWrap + i;
1198  				const Range rangeLine = pdoc-&gt;LineRange(lineNumber);
1199  				const Sci::Position lengthLine = rangeLine.Length();
1200  				if (lengthLine &lt; lengthToMultiThread) {
1201  					std::shared_ptr&lt;LineLayout&gt; ll;
1202  					if (significantLines.LineMayCache(lineNumber)) {
1203  						std::lock_guard&lt;std::mutex&gt; guard(mutexRetrieve);
1204  						ll = view.RetrieveLineLayout(lineNumber, *this);
1205  					} else {
1206  						ll = llTemporary;
1207  						ll-&gt;ReSet(lineNumber, lengthLine);
1208  					}
1209  					view.LayoutLine(*this, surface, vs, ll.get(), wrapWidth, multiThreaded);
1210  					linesAfterWrap[i] = ll-&gt;lines;
1211  				}
1212  			}
1213  		});
1214  		futures.push_back(std::move(fut));
1215  	}
1216  	for (const std::future&lt;void&gt; &amp;f : futures) {
1217  		f.wait();
1218  	}
1219  	const double durationShortLines = epWrapping.Duration(true);
1220  	const double durationShortLinesThreads = durationShortLines * threads;
1221  	std::shared_ptr&lt;LineLayout&gt; llLarge = std::make_shared&lt;LineLayout&gt;(-1, 200);
1222  	for (size_t indexLarge = 0; indexLarge &lt; linesBeingWrapped; indexLarge++) {
1223  		const Sci::Line lineNumber = lineToWrap + indexLarge;
1224  		const Range rangeLine = pdoc-&gt;LineRange(lineNumber);
1225  		const Sci::Position lengthLine = rangeLine.Length();
1226  		if (lengthLine &gt;= lengthToMultiThread) {
1227  			std::shared_ptr&lt;LineLayout&gt; ll;
1228  			if (significantLines.LineMayCache(lineNumber)) {
1229  				ll = view.RetrieveLineLayout(lineNumber, *this);
1230  			} else {
1231  				ll = llLarge;
1232  				ll-&gt;ReSet(lineNumber, lengthLine);
1233  			}
1234  			view.LayoutLine(*this, surface, vs, ll.get(), wrapWidth);
1235  			linesAfterWrap[indexLarge] = ll-&gt;lines;
1236  		}
1237  	}
1238  	const double durationLongLines = epWrapping.Duration();
1239  	const size_t bytesBeingWrapped = pdoc-&gt;LineStart(lineToWrap + linesBeingWrapped) - pdoc-&gt;LineStart(lineToWrap);
1240  	size_t wrapsDone = 0;
1241  	for (size_t i = 0; i &lt; linesBeingWrapped; i++) {
1242  		const Sci::Line lineNumber = lineToWrap + i;
1243  		int linesWrapped = linesAfterWrap[i];
1244  		if (vs.annotationVisible != AnnotationVisible::Hidden) {
1245  			linesWrapped += pdoc-&gt;AnnotationLines(lineNumber);
1246  		}
1247  		if (pcs-&gt;SetHeight(lineNumber, linesWrapped)) {
1248  			wrapsDone++;
1249  		}
1250  		wrapPending.Wrapped(lineNumber);
1251  	}
1252  	durationWrapOneByte.AddSample(bytesBeingWrapped, durationShortLinesThreads + durationLongLines);
1253  	return wrapsDone &gt; 0;
1254  }
1255  bool Editor::WrapLines(WrapScope ws) {
1256  	Sci::Line goodTopLine = topLine;
1257  	bool wrapOccurred = false;
1258  	if (!Wrapping()) {
1259  		if (wrapWidth != LineLayout::wrapWidthInfinite) {
1260  			wrapWidth = LineLayout::wrapWidthInfinite;
1261  			for (Sci::Line lineDoc = 0; lineDoc &lt; pdoc-&gt;LinesTotal(); lineDoc++) {
1262  				int linesWrapped = 1;
1263  				if (vs.annotationVisible != AnnotationVisible::Hidden) {
1264  					linesWrapped += pdoc-&gt;AnnotationLines(lineDoc);
1265  				}
1266  				pcs-&gt;SetHeight(lineDoc, linesWrapped);
1267  			}
1268  			wrapOccurred = true;
1269  		}
1270  		wrapPending.Reset();
1271  	} else if (wrapPending.NeedsWrap()) {
1272  		wrapPending.start = std::min(wrapPending.start, pdoc-&gt;LinesTotal());
1273  		if (!SetIdle(true)) {
1274  			ws = WrapScope::wsAll;
1275  		}
1276  		Sci::Line lineToWrap = wrapPending.start;
1277  		Sci::Line lineToWrapEnd = std::min(wrapPending.end, pdoc-&gt;LinesTotal());
1278  		const Sci::Line lineDocTop = pcs-&gt;DocFromDisplay(topLine);
1279  		const Sci::Line subLineTop = topLine - pcs-&gt;DisplayFromDoc(lineDocTop);
1280  		if (ws == WrapScope::wsVisible) {
1281  			lineToWrap = std::clamp(lineDocTop-5, wrapPending.start, pdoc-&gt;LinesTotal());
1282  			lineToWrapEnd = lineDocTop;
1283  			Sci::Line lines = LinesOnScreen() + 1;
1284  			constexpr double secondsAllowed = 0.1;
1285  			const size_t actionsInAllowedTime = std::clamp&lt;Sci::Line&gt;(
1286  				durationWrapOneByte.ActionsInAllowedTime(secondsAllowed),
1287  				0x2000, 0x200000);
1288  			const Sci::Line lineLast = pdoc-&gt;LineFromPositionAfter(lineToWrap, actionsInAllowedTime);
1289  			const Sci::Line maxLine = std::min(lineLast, pcs-&gt;LinesInDoc());
1290  			while ((lineToWrapEnd &lt; maxLine) &amp;&amp; (lines&gt;0)) {
1291  				if (pcs-&gt;GetVisible(lineToWrapEnd))
1292  					lines--;
1293  				lineToWrapEnd++;
1294  			}
1295  			if ((lineToWrap &gt; wrapPending.end) || (lineToWrapEnd &lt; wrapPending.start)) {
1296  				return false;
1297  			}
1298  		} else if (ws == WrapScope::wsIdle) {
1299  			constexpr double secondsAllowed = 0.01;
1300  			const size_t actionsInAllowedTime = std::clamp&lt;Sci::Line&gt;(
1301  				durationWrapOneByte.ActionsInAllowedTime(secondsAllowed),
1302  				0x200, 0x20000);
1303  			lineToWrapEnd = pdoc-&gt;LineFromPositionAfter(lineToWrap, actionsInAllowedTime);
1304  		}
1305  		const Sci::Line lineEndNeedWrap = std::min(wrapPending.end, pdoc-&gt;LinesTotal());
1306  		lineToWrapEnd = std::min(lineToWrapEnd, lineEndNeedWrap);
1307  		pdoc-&gt;EnsureStyledTo(pdoc-&gt;LineStart(lineToWrapEnd));
1308  		if (lineToWrap &lt; lineToWrapEnd) {
1309  			PRectangle rcTextArea = GetClientRectangle();
1310  			rcTextArea.left = static_cast&lt;XYPOSITION&gt;(vs.textStart);
1311  			rcTextArea.right -= vs.rightMarginWidth;
1312  			wrapWidth = static_cast&lt;int&gt;(rcTextArea.Width());
1313  			RefreshStyleData();
1314  			AutoSurface surface(this);
1315  			if (surface) {
1316  				wrapOccurred = WrapBlock(surface, lineToWrap, lineToWrapEnd);
1317  				goodTopLine = pcs-&gt;DisplayFromDoc(lineDocTop) + std::min(
1318  					subLineTop, static_cast&lt;Sci::Line&gt;(pcs-&gt;GetHeight(lineDocTop)-1));
1319  			}
1320  		}
1321  		if (wrapPending.start &gt;= lineEndNeedWrap) {
1322  			wrapPending.Reset();
1323  		}
1324  	}
1325  	if (wrapOccurred) {
1326  		SetScrollBars();
1327  		SetTopLine(std::clamp&lt;Sci::Line&gt;(goodTopLine, 0, MaxScrollPos()));
1328  		SetVerticalScrollPos();
1329  	}
1330  	return wrapOccurred;
1331  }
1332  void Editor::LinesJoin() {
1333  	if (!RangeContainsProtected(targetRange.start.Position(), targetRange.end.Position())) {
1334  		UndoGroup ug(pdoc);
1335  		const Sci::Line line = pdoc-&gt;SciLineFromPosition(targetRange.start.Position());
1336  		for (Sci::Position pos = pdoc-&gt;LineEnd(line); pos &lt; targetRange.end.Position(); pos = pdoc-&gt;LineEnd(line)) {
1337  			const char chPrev = pdoc-&gt;CharAt(pos - 1);
1338  			const Sci::Position widthChar = pdoc-&gt;LenChar(pos);
1339  			targetRange.end.Add(-widthChar);
1340  			pdoc-&gt;DeleteChars(pos, widthChar);
1341  			if (chPrev != &#x27; &#x27;) {
1342  				const Sci::Position lengthInserted = pdoc-&gt;InsertString(pos, &quot; &quot;, 1);
1343  				targetRange.end.Add(lengthInserted);
1344  			}
1345  		}
1346  	}
1347  }
1348  void Editor::LinesSplit(int pixelWidth) {
1349  	if (!RangeContainsProtected(targetRange.start.Position(), targetRange.end.Position())) {
1350  		if (pixelWidth == 0) {
1351  			const PRectangle rcText = GetTextRectangle();
1352  			pixelWidth = static_cast&lt;int&gt;(rcText.Width());
1353  		}
1354  		const Sci::Line lineStart = pdoc-&gt;SciLineFromPosition(targetRange.start.Position());
1355  		Sci::Line lineEnd = pdoc-&gt;SciLineFromPosition(targetRange.end.Position());
1356  		const std::string_view eol = pdoc-&gt;EOLString();
1357  		UndoGroup ug(pdoc);
1358  		for (Sci::Line line = lineStart; line &lt;= lineEnd; line++) {
1359  			AutoSurface surface(this);
1360  			std::shared_ptr&lt;LineLayout&gt; ll = view.RetrieveLineLayout(line, *this);
1361  			if (surface &amp;&amp; ll) {
1362  				const Sci::Position posLineStart = pdoc-&gt;LineStart(line);
1363  				view.LayoutLine(*this, surface, vs, ll.get(), pixelWidth);
1364  				Sci::Position lengthInsertedTotal = 0;
1365  				for (int subLine = 1; subLine &lt; ll-&gt;lines; subLine++) {
1366  					const Sci::Position lengthInserted = pdoc-&gt;InsertString(
1367  						posLineStart + lengthInsertedTotal + ll-&gt;LineStart(subLine), eol);
1368  					targetRange.end.Add(lengthInserted);
1369  					lengthInsertedTotal += lengthInserted;
1370  				}
1371  			}
1372  			lineEnd = pdoc-&gt;SciLineFromPosition(targetRange.end.Position());
1373  		}
1374  	}
1375  }
1376  void Editor::PaintSelMargin(Surface *surfaceWindow, const PRectangle &amp;rc) {
1377  	if (vs.fixedColumnWidth == 0)
1378  		return;
1379  	RefreshStyleData();
1380  	RefreshPixMaps(surfaceWindow);
1381  	if (!surfaceWindow-&gt;Initialised()) {
1382  		return;
1383  	}
1384  	PRectangle rcMargin = GetClientRectangle();
1385  	const Point ptOrigin = GetVisibleOriginInMain();
1386  	rcMargin.Move(0, -ptOrigin.y);
1387  	rcMargin.left = 0;
1388  	rcMargin.right = static_cast&lt;XYPOSITION&gt;(vs.fixedColumnWidth);
1389  	if (!rc.Intersects(rcMargin))
1390  		return;
1391  	Surface *surface;
1392  	if (view.bufferedDraw) {
1393  		surface = marginView.pixmapSelMargin.get();
1394  	} else {
1395  		surface = surfaceWindow;
1396  	}
1397  	surface-&gt;SetMode(CurrentSurfaceMode());
1398  	if (rcMargin.bottom &gt; rc.bottom)
1399  		rcMargin.bottom = rc.bottom;
1400  	if (rcMargin.top &lt; rc.top)
1401  		rcMargin.top = rc.top;
1402  	marginView.PaintMargin(surface, topLine, rc, rcMargin, *this, vs);
1403  	if (view.bufferedDraw) {
1404  		marginView.pixmapSelMargin-&gt;FlushDrawing();
1405  		surfaceWindow-&gt;Copy(rcMargin, Point(rcMargin.left, rcMargin.top), *marginView.pixmapSelMargin);
1406  	}
1407  }
1408  void Editor::RefreshPixMaps(Surface *surfaceWindow) {
1409  	view.RefreshPixMaps(surfaceWindow, vs);
1410  	marginView.RefreshPixMaps(surfaceWindow, vs);
1411  	if (view.bufferedDraw) {
1412  		const PRectangle rcClient = GetClientRectangle();
1413  		if (!view.pixmapLine) {
1414  			view.pixmapLine = surfaceWindow-&gt;AllocatePixMap(static_cast&lt;int&gt;(rcClient.Width()), vs.lineHeight);
1415  		}
1416  		if (!marginView.pixmapSelMargin) {
1417  			marginView.pixmapSelMargin = surfaceWindow-&gt;AllocatePixMap(vs.fixedColumnWidth,
1418  				static_cast&lt;int&gt;(rcClient.Height()));
1419  		}
1420  	}
1421  }
1422  void Editor::Paint(Surface *surfaceWindow, PRectangle rcArea) {
1423  	redrawPendingText = false;
1424  	redrawPendingMargin = false;
1425  	RefreshStyleData();
1426  	if (paintState == PaintState::abandoned)
1427  		return;	
1428  	RefreshPixMaps(surfaceWindow);
1429  	paintAbandonedByStyling = false;
1430  	StyleAreaBounded(rcArea, false);
1431  	const PRectangle rcClient = GetClientRectangle();
1432  	if (NotifyUpdateUI()) {
1433  		RefreshStyleData();
1434  		RefreshPixMaps(surfaceWindow);
1435  	}
1436  	if (WrapLines(WrapScope::wsVisible)) {
1437  		if (AbandonPaint()) {
1438  			return;
1439  		}
1440  		RefreshPixMaps(surfaceWindow);	
1441  	}
1442  	if (!marginView.pixmapSelPattern-&gt;Initialised()) {
1443  		return;
1444  	}
1445  	if (!view.bufferedDraw)
1446  		surfaceWindow-&gt;SetClip(rcArea);
1447  	if (paintState != PaintState::abandoned) {
1448  		if (vs.marginInside) {
1449  			PaintSelMargin(surfaceWindow, rcArea);
1450  			PRectangle rcRightMargin = rcClient;
1451  			rcRightMargin.left = rcRightMargin.right - vs.rightMarginWidth;
1452  			if (rcArea.Intersects(rcRightMargin)) {
1453  				surfaceWindow-&gt;FillRectangle(rcRightMargin, vs.styles[StyleDefault].back);
1454  			}
1455  		} else { 
1456  			PRectangle rcLeftMargin = rcArea;
1457  			rcLeftMargin.left = 0;
1458  			rcLeftMargin.right = rcLeftMargin.left + vs.leftMarginWidth;
1459  			if (rcArea.Intersects(rcLeftMargin)) {
1460  				surfaceWindow-&gt;FillRectangle(rcLeftMargin, vs.styles[StyleDefault].back);
1461  			}
1462  		}
1463  	}
1464  	if (paintState == PaintState::abandoned) {
1465  		if (Wrapping()) {
1466  			if (paintAbandonedByStyling) {
1467  				NeedWrapping(pcs-&gt;DocFromDisplay(topLine));
1468  			}
1469  		}
1470  		if (!view.bufferedDraw)
1471  			surfaceWindow-&gt;PopClip();
1472  		return;
1473  	}
1474  	view.PaintText(surfaceWindow, *this, vs, rcArea, rcClient);
1475  	if (horizontalScrollBarVisible &amp;&amp; trackLineWidth &amp;&amp; (view.lineWidthMaxSeen &gt; scrollWidth)) {
1476  		scrollWidth = view.lineWidthMaxSeen;
1477  		if (!FineTickerRunning(TickReason::widen)) {
1478  			FineTickerStart(TickReason::widen, 50, 5);
1479  		}
1480  	}
1481  	if (!view.bufferedDraw)
1482  		surfaceWindow-&gt;PopClip();
1483  	NotifyPainted();
1484  }
1485  Sci::Position Editor::FormatRange(Scintilla::Message iMessage, Scintilla::uptr_t wParam, Scintilla::sptr_t lParam) {
1486  	if (!lParam)
1487  		return 0;
1488  	const bool draw = wParam != 0;
1489  	void *ptr = PtrFromSPtr(lParam);
1490  	if (iMessage == Message::FormatRange) {
1491  		RangeToFormat *pfr = static_cast&lt;RangeToFormat *&gt;(ptr);
1492  		const CharacterRangeFull chrg{ pfr-&gt;chrg.cpMin,pfr-&gt;chrg.cpMax };
1493  		AutoSurface surface(pfr-&gt;hdc, this, Technology::Default);
1494  		AutoSurface surfaceMeasure(pfr-&gt;hdcTarget, this, Technology::Default);
1495  		if (!surface || !surfaceMeasure) {
1496  			return 0;
1497  		}
1498  		return view.FormatRange(draw, chrg, pfr-&gt;rc, surface, surfaceMeasure, *this, vs);
1499  	} else {
1500  		RangeToFormatFull *pfr = static_cast&lt;RangeToFormatFull *&gt;(ptr);
1501  		AutoSurface surface(pfr-&gt;hdc, this, Technology::Default);
1502  		AutoSurface surfaceMeasure(pfr-&gt;hdcTarget, this, Technology::Default);
1503  		if (!surface || !surfaceMeasure) {
1504  			return 0;
1505  		}
1506  		return view.FormatRange(draw, pfr-&gt;chrg, pfr-&gt;rc, surface, surfaceMeasure, *this, vs);
1507  	}
1508  }
1509  long Editor::TextWidth(uptr_t style, const char *text) {
1510  	RefreshStyleData();
1511  	AutoSurface surface(this);
1512  	if (surface) {
1513  		return std::lround(surface-&gt;WidthText(vs.styles[style].font.get(), text));
1514  	} else {
1515  		return 1;
1516  	}
1517  }
1518  void Editor::ReconfigureScrollBars() {}
1519  void Editor::ChangeScrollBars() {
1520  	RefreshStyleData();
1521  	const Sci::Line nMax = MaxScrollPos();
1522  	const Sci::Line nPage = LinesOnScreen();
1523  	const bool modified = ModifyScrollBars(nMax + nPage - 1, nPage);
1524  	if (modified) {
1525  		DwellEnd(true);
1526  	}
1527  	if (topLine &gt; MaxScrollPos()) {
1528  		SetTopLine(std::clamp&lt;Sci::Line&gt;(topLine, 0, MaxScrollPos()));
1529  		SetVerticalScrollPos();
1530  		Redraw();
1531  	}
1532  	if (modified) {
1533  		if (!AbandonPaint())
1534  			Redraw();
1535  	}
1536  }
1537  void Editor::SetScrollBars() {
1538  	ChangeScrollBars();
1539  }
1540  void Editor::ChangeSize() {
1541  	DropGraphics();
1542  	SetScrollBars();
1543  	if (Wrapping()) {
1544  		PRectangle rcTextArea = GetClientRectangle();
1545  		rcTextArea.left = static_cast&lt;XYPOSITION&gt;(vs.textStart);
1546  		rcTextArea.right -= vs.rightMarginWidth;
1547  		if (wrapWidth != rcTextArea.Width()) {
1548  			NeedWrapping();
1549  			Redraw();
1550  		}
1551  	}
1552  }
1553  Sci::Position Editor::RealizeVirtualSpace(Sci::Position position, Sci::Position virtualSpace) {
1554  	if (virtualSpace &gt; 0) {
1555  		const Sci::Line line = pdoc-&gt;SciLineFromPosition(position);
1556  		const Sci::Position indent = pdoc-&gt;GetLineIndentPosition(line);
1557  		if (indent == position) {
1558  			return pdoc-&gt;SetLineIndentation(line, pdoc-&gt;GetLineIndentation(line) + virtualSpace);
1559  		} else {
1560  			const std::string spaceText(virtualSpace, &#x27; &#x27;);
1561  			const Sci::Position lengthInserted = pdoc-&gt;InsertString(position, spaceText);
1562  			position += lengthInserted;
1563  		}
1564  	}
1565  	return position;
1566  }
1567  SelectionPosition Editor::RealizeVirtualSpace(const SelectionPosition &amp;position) {
1568  	return SelectionPosition(RealizeVirtualSpace(position.Position(), position.VirtualSpace()));
1569  }
1570  void Editor::AddChar(char ch) {
1571  	const char s[1] {ch};
1572  	InsertCharacter(std::string_view(s, 1), CharacterSource::DirectInput);
1573  }
1574  void Editor::FilterSelections() {
1575  	if (!additionalSelectionTyping &amp;&amp; (sel.Count() &gt; 1)) {
1576  		InvalidateWholeSelection();
1577  		sel.DropAdditionalRanges();
1578  	}
1579  }
1580  void Editor::InsertCharacter(std::string_view sv, CharacterSource charSource) {
1581  	if (sv.empty()) {
1582  		return;
1583  	}
1584  	FilterSelections();
1585  	bool wrapOccurred = false;
1586  	{
1587  		UndoGroup ug(pdoc, (sel.Count() &gt; 1) || !sel.Empty() || inOverstrike);
1588  		std::vector&lt;SelectionRange *&gt; selPtrs;
1589  		for (size_t r = 0; r &lt; sel.Count(); r++) {
1590  			selPtrs.push_back(&amp;sel.Range(r));
1591  		}
1592  		std::sort(selPtrs.begin(), selPtrs.end(),
1593  			[](const SelectionRange *a, const SelectionRange *b) noexcept {return *a &lt; *b;});
1594  		for (std::vector&lt;SelectionRange *&gt;::reverse_iterator rit = selPtrs.rbegin();
1595  			rit != selPtrs.rend(); ++rit) {
1596  			SelectionRange *currentSel = *rit;
1597  			if (!RangeContainsProtected(currentSel-&gt;Start().Position(),
1598  				currentSel-&gt;End().Position())) {
1599  				Sci::Position positionInsert = currentSel-&gt;Start().Position();
1600  				if (!currentSel-&gt;Empty()) {
1601  					if (currentSel-&gt;Length()) {
1602  						pdoc-&gt;DeleteChars(positionInsert, currentSel-&gt;Length());
1603  						currentSel-&gt;ClearVirtualSpace();
1604  					} else {
1605  						currentSel-&gt;MinimizeVirtualSpace();
1606  					}
1607  				} else if (inOverstrike) {
1608  					if (positionInsert &lt; pdoc-&gt;Length()) {
1609  						if (!pdoc-&gt;IsPositionInLineEnd(positionInsert)) {
1610  							pdoc-&gt;DelChar(positionInsert);
1611  							currentSel-&gt;ClearVirtualSpace();
1612  						}
1613  					}
1614  				}
1615  				positionInsert = RealizeVirtualSpace(positionInsert, currentSel-&gt;caret.VirtualSpace());
1616  				const Sci::Position lengthInserted = pdoc-&gt;InsertString(positionInsert, sv);
1617  				if (lengthInserted &gt; 0) {
1618  					currentSel-&gt;caret.SetPosition(positionInsert + lengthInserted);
1619  					currentSel-&gt;anchor.SetPosition(positionInsert + lengthInserted);
1620  				}
1621  				currentSel-&gt;ClearVirtualSpace();
1622  				if (Wrapping()) {
1623  					AutoSurface surface(this);
1624  					if (surface) {
1625  						if (WrapOneLine(surface, pdoc-&gt;SciLineFromPosition(positionInsert))) {
1626  							wrapOccurred = true;
1627  						}
1628  					}
1629  				}
1630  			}
1631  		}
1632  	}
1633  	if (wrapOccurred) {
1634  		SetScrollBars();
1635  		SetVerticalScrollPos();
1636  		Redraw();
1637  	}
1638  	ThinRectangularRange();
1639  	EnsureCaretVisible();
1640  	ShowCaretAtCurrentPosition();
1641  	if ((caretSticky == CaretSticky::Off) ||
1642  		((caretSticky == CaretSticky::WhiteSpace) &amp;&amp; !IsAllSpacesOrTabs(sv))) {
1643  		SetLastXChosen();
1644  	}
1645  	int ch = static_cast&lt;unsigned char&gt;(sv[0]);
1646  	if (pdoc-&gt;dbcsCodePage != CpUtf8) {
1647  		if (sv.length() &gt; 1) {
1648  			ch = (ch &lt;&lt; 8) | static_cast&lt;unsigned char&gt;(sv[1]);
1649  		}
1650  	} else {
1651  		if ((ch &lt; 0xC0) || (1 == sv.length())) {
1652  		} else {
1653  			unsigned int utf32[1] = { 0 };
1654  			UTF32FromUTF8(sv, utf32, std::size(utf32));
1655  			ch = utf32[0];
1656  		}
1657  	}
1658  	NotifyChar(ch, charSource);
1659  	if (recordingMacro &amp;&amp; charSource != CharacterSource::TentativeInput) {
1660  		std::string copy(sv); 
1661  		NotifyMacroRecord(Message::ReplaceSel, 0, reinterpret_cast&lt;sptr_t&gt;(copy.data()));
1662  	}
1663  }
1664  void Editor::ClearBeforeTentativeStart() {
1665  	FilterSelections();
1666  	UndoGroup ug(pdoc, (sel.Count() &gt; 1) || !sel.Empty() || inOverstrike);
1667  	for (size_t r = 0; r&lt;sel.Count(); r++) {
1668  		if (!RangeContainsProtected(sel.Range(r).Start().Position(),
1669  			sel.Range(r).End().Position())) {
1670  			const Sci::Position positionInsert = sel.Range(r).Start().Position();
1671  			if (!sel.Range(r).Empty()) {
1672  				if (sel.Range(r).Length()) {
1673  					pdoc-&gt;DeleteChars(positionInsert, sel.Range(r).Length());
1674  					sel.Range(r).ClearVirtualSpace();
1675  				} else {
1676  					sel.Range(r).MinimizeVirtualSpace();
1677  				}
1678  			}
1679  			RealizeVirtualSpace(positionInsert, sel.Range(r).caret.VirtualSpace());
1680  			sel.Range(r).ClearVirtualSpace();
1681  		}
1682  	}
1683  }
1684  void Editor::InsertPaste(const char *text, Sci::Position len) {
1685  	if (multiPasteMode == MultiPaste::Once) {
1686  		SelectionPosition selStart = sel.Start();
1687  		selStart = RealizeVirtualSpace(selStart);
1688  		const Sci::Position lengthInserted = pdoc-&gt;InsertString(selStart.Position(), text, len);
1689  		if (lengthInserted &gt; 0) {
1690  			SetEmptySelection(selStart.Position() + lengthInserted);
1691  		}
1692  	} else {
1693  		for (size_t r=0; r&lt;sel.Count(); r++) {
1694  			if (!RangeContainsProtected(sel.Range(r).Start().Position(),
1695  				sel.Range(r).End().Position())) {
1696  				Sci::Position positionInsert = sel.Range(r).Start().Position();
1697  				if (!sel.Range(r).Empty()) {
1698  					if (sel.Range(r).Length()) {
1699  						pdoc-&gt;DeleteChars(positionInsert, sel.Range(r).Length());
1700  						sel.Range(r).ClearVirtualSpace();
1701  					} else {
1702  						sel.Range(r).MinimizeVirtualSpace();
1703  					}
1704  				}
1705  				positionInsert = RealizeVirtualSpace(positionInsert, sel.Range(r).caret.VirtualSpace());
1706  				const Sci::Position lengthInserted = pdoc-&gt;InsertString(positionInsert, text, len);
1707  				if (lengthInserted &gt; 0) {
1708  					sel.Range(r).caret.SetPosition(positionInsert + lengthInserted);
1709  					sel.Range(r).anchor.SetPosition(positionInsert + lengthInserted);
1710  				}
1711  				sel.Range(r).ClearVirtualSpace();
1712  			}
1713  		}
1714  	}
1715  }
1716  void Editor::InsertPasteShape(const char *text, Sci::Position len, PasteShape shape) {
1717  	std::string convertedText;
1718  	if (convertPastes) {
1719  		convertedText = Document::TransformLineEnds(text, len, pdoc-&gt;eolMode);
1720  		len = convertedText.length();
1721  		text = convertedText.c_str();
1722  	}
1723  	if (shape == PasteShape::rectangular) {
1724  		PasteRectangular(sel.Start(), text, len);
1725  	} else {
1726  		if (shape == PasteShape::line) {
1727  			const Sci::Position insertPos =
1728  				pdoc-&gt;LineStart(pdoc-&gt;LineFromPosition(sel.MainCaret()));
1729  			Sci::Position lengthInserted = pdoc-&gt;InsertString(insertPos, text, len);
1730  			if ((len &gt; 0) &amp;&amp; (text[len - 1] != &#x27;\n&#x27; &amp;&amp; text[len - 1] != &#x27;\r&#x27;)) {
1731  				const std::string_view endline = pdoc-&gt;EOLString();
1732  				lengthInserted += pdoc-&gt;InsertString(insertPos + lengthInserted, endline);
1733  			}
1734  			if (sel.MainCaret() == insertPos) {
1735  				SetEmptySelection(sel.MainCaret() + lengthInserted);
1736  			}
1737  		} else {
1738  			InsertPaste(text, len);
1739  		}
1740  	}
1741  }
1742  void Editor::ClearSelection(bool retainMultipleSelections) {
1743  	if (!sel.IsRectangular() &amp;&amp; !retainMultipleSelections)
1744  		FilterSelections();
1745  	UndoGroup ug(pdoc);
1746  	for (size_t r=0; r&lt;sel.Count(); r++) {
1747  		if (!sel.Range(r).Empty()) {
1748  			if (!RangeContainsProtected(sel.Range(r).Start().Position(),
1749  				sel.Range(r).End().Position())) {
1750  				pdoc-&gt;DeleteChars(sel.Range(r).Start().Position(),
1751  					sel.Range(r).Length());
1752  				sel.Range(r) = SelectionRange(sel.Range(r).Start());
1753  			}
1754  		}
1755  	}
1756  	ThinRectangularRange();
1757  	sel.RemoveDuplicates();
1758  	ClaimSelection();
1759  	SetHoverIndicatorPosition(sel.MainCaret());
1760  }
1761  void Editor::ClearAll() {
1762  	{
1763  		UndoGroup ug(pdoc);
1764  		if (0 != pdoc-&gt;Length()) {
1765  			pdoc-&gt;DeleteChars(0, pdoc-&gt;Length());
1766  		}
1767  		if (!pdoc-&gt;IsReadOnly()) {
1768  			pcs-&gt;Clear();
1769  			pdoc-&gt;AnnotationClearAll();
1770  			pdoc-&gt;EOLAnnotationClearAll();
1771  			pdoc-&gt;MarginClearAll();
1772  		}
1773  	}
1774  	view.ClearAllTabstops();
1775  	sel.Clear();
1776  	SetTopLine(0);
1777  	SetVerticalScrollPos();
1778  	InvalidateStyleRedraw();
1779  }
1780  void Editor::ClearDocumentStyle() {
1781  	pdoc-&gt;decorations-&gt;DeleteLexerDecorations();
1782  	pdoc-&gt;StartStyling(0);
1783  	pdoc-&gt;SetStyleFor(pdoc-&gt;Length(), 0);
1784  	pcs-&gt;ShowAll();
1785  	SetAnnotationHeights(0, pdoc-&gt;LinesTotal());
1786  	pdoc-&gt;ClearLevels();
1787  }
1788  void Editor::CopyAllowLine() {
1789  	SelectionText selectedText;
1790  	CopySelectionRange(&amp;selectedText, true);
1791  	CopyToClipboard(selectedText);
1792  }
1793  void Editor::Cut() {
1794  	pdoc-&gt;CheckReadOnly();
1795  	if (!pdoc-&gt;IsReadOnly() &amp;&amp; !SelectionContainsProtected()) {
1796  		Copy();
1797  		ClearSelection();
1798  	}
1799  }
1800  void Editor::PasteRectangular(SelectionPosition pos, const char *ptr, Sci::Position len) {
1801  	if (pdoc-&gt;IsReadOnly() || SelectionContainsProtected()) {
1802  		return;
1803  	}
1804  	sel.Clear();
1805  	sel.RangeMain() = SelectionRange(pos);
1806  	Sci::Line line = pdoc-&gt;SciLineFromPosition(sel.MainCaret());
1807  	UndoGroup ug(pdoc);
1808  	sel.RangeMain().caret = RealizeVirtualSpace(sel.RangeMain().caret);
1809  	const int xInsert = XFromPosition(sel.RangeMain().caret);
1810  	bool prevCr = false;
1811  	while ((len &gt; 0) &amp;&amp; IsEOLCharacter(ptr[len-1]))
1812  		len--;
1813  	for (Sci::Position i = 0; i &lt; len; i++) {
1814  		if (IsEOLCharacter(ptr[i])) {
1815  			if ((ptr[i] == &#x27;\r&#x27;) || (!prevCr))
1816  				line++;
1817  			if (line &gt;= pdoc-&gt;LinesTotal()) {
1818  				const std::string_view eol = pdoc-&gt;EOLString();
1819  				pdoc-&gt;InsertString(pdoc-&gt;LengthNoExcept(), eol);
1820  			}
1821  			sel.RangeMain().caret.SetPosition(PositionFromLineX(line, xInsert));
1822  			if ((XFromPosition(sel.RangeMain().caret) &lt; xInsert) &amp;&amp; (i + 1 &lt; len)) {
1823  				while (XFromPosition(sel.RangeMain().caret) &lt; xInsert) {
1824  					assert(pdoc);
1825  					const Sci::Position lengthInserted = pdoc-&gt;InsertString(sel.MainCaret(), &quot; &quot;, 1);
1826  					sel.RangeMain().caret.Add(lengthInserted);
1827  				}
1828  			}
1829  			prevCr = ptr[i] == &#x27;\r&#x27;;
1830  		} else {
1831  			const Sci::Position lengthInserted = pdoc-&gt;InsertString(sel.MainCaret(), ptr + i, 1);
1832  			sel.RangeMain().caret.Add(lengthInserted);
1833  			prevCr = false;
1834  		}
1835  	}
1836  	SetEmptySelection(pos);
1837  }
1838  bool Editor::CanPaste() {
1839  	return !pdoc-&gt;IsReadOnly() &amp;&amp; !SelectionContainsProtected();
1840  }
1841  void Editor::Clear() {
1842  	if (sel.Empty()) {
1843  		bool singleVirtual = false;
1844  		if ((sel.Count() == 1) &amp;&amp;
1845  			!RangeContainsProtected(sel.MainCaret(), sel.MainCaret() + 1) &amp;&amp;
1846  			sel.RangeMain().Start().VirtualSpace()) {
1847  			singleVirtual = true;
1848  		}
1849  		UndoGroup ug(pdoc, (sel.Count() &gt; 1) || singleVirtual);
1850  		for (size_t r=0; r&lt;sel.Count(); r++) {
1851  			if (!RangeContainsProtected(sel.Range(r).caret.Position(), sel.Range(r).caret.Position() + 1)) {
1852  				if (sel.Range(r).Start().VirtualSpace()) {
1853  					if (sel.Range(r).anchor &lt; sel.Range(r).caret)
1854  						sel.Range(r) = SelectionRange(RealizeVirtualSpace(sel.Range(r).anchor.Position(), sel.Range(r).anchor.VirtualSpace()));
1855  					else
1856  						sel.Range(r) = SelectionRange(RealizeVirtualSpace(sel.Range(r).caret.Position(), sel.Range(r).caret.VirtualSpace()));
1857  				}
1858  				if ((sel.Count() == 1) || !pdoc-&gt;IsPositionInLineEnd(sel.Range(r).caret.Position())) {
1859  					pdoc-&gt;DelChar(sel.Range(r).caret.Position());
1860  					sel.Range(r).ClearVirtualSpace();
1861  				}  
1862  			} else {
1863  				sel.Range(r).ClearVirtualSpace();
1864  			}
1865  		}
1866  	} else {
1867  		ClearSelection();
1868  	}
1869  	sel.RemoveDuplicates();
1870  	ShowCaretAtCurrentPosition();		
1871  }
1872  void Editor::SelectAll() {
1873  	sel.Clear();
1874  	SetSelection(0, pdoc-&gt;Length());
1875  	Redraw();
1876  }
1877  void Editor::Undo() {
1878  	if (pdoc-&gt;CanUndo()) {
1879  		InvalidateCaret();
1880  		const Sci::Position newPos = pdoc-&gt;Undo();
1881  		if (newPos &gt;= 0)
1882  			SetEmptySelection(newPos);
1883  		EnsureCaretVisible();
1884  	}
1885  }
1886  void Editor::Redo() {
1887  	if (pdoc-&gt;CanRedo()) {
1888  		const Sci::Position newPos = pdoc-&gt;Redo();
1889  		if (newPos &gt;= 0)
1890  			SetEmptySelection(newPos);
1891  		EnsureCaretVisible();
1892  	}
1893  }
1894  void Editor::DelCharBack(bool allowLineStartDeletion) {
1895  	RefreshStyleData();
1896  	if (!sel.IsRectangular())
1897  		FilterSelections();
1898  	if (sel.IsRectangular())
1899  		allowLineStartDeletion = false;
1900  	UndoGroup ug(pdoc, (sel.Count() &gt; 1) || !sel.Empty());
1901  	if (sel.Empty()) {
1902  		for (size_t r=0; r&lt;sel.Count(); r++) {
1903  			if (!RangeContainsProtected(sel.Range(r).caret.Position() - 1, sel.Range(r).caret.Position())) {
1904  				if (sel.Range(r).caret.VirtualSpace()) {
1905  					sel.Range(r).caret.SetVirtualSpace(sel.Range(r).caret.VirtualSpace() - 1);
1906  					sel.Range(r).anchor.SetVirtualSpace(sel.Range(r).caret.VirtualSpace());
1907  				} else {
1908  					const Sci::Line lineCurrentPos =
1909  						pdoc-&gt;SciLineFromPosition(sel.Range(r).caret.Position());
1910  					if (allowLineStartDeletion || (pdoc-&gt;LineStart(lineCurrentPos) != sel.Range(r).caret.Position())) {
1911  						if (pdoc-&gt;GetColumn(sel.Range(r).caret.Position()) &lt;= pdoc-&gt;GetLineIndentation(lineCurrentPos) &amp;&amp;
1912  								pdoc-&gt;GetColumn(sel.Range(r).caret.Position()) &gt; 0 &amp;&amp; pdoc-&gt;backspaceUnindents) {
1913  							UndoGroup ugInner(pdoc, !ug.Needed());
1914  							const int indentation = pdoc-&gt;GetLineIndentation(lineCurrentPos);
1915  							const int indentationStep = pdoc-&gt;IndentSize();
1916  							int indentationChange = indentation % indentationStep;
1917  							if (indentationChange == 0)
1918  								indentationChange = indentationStep;
1919  							const Sci::Position posSelect = pdoc-&gt;SetLineIndentation(lineCurrentPos, indentation - indentationChange);
1920  							sel.Range(r) = SelectionRange(posSelect);
1921  						} else {
1922  							pdoc-&gt;DelCharBack(sel.Range(r).caret.Position());
1923  						}
1924  					}
1925  				}
1926  			} else {
1927  				sel.Range(r).ClearVirtualSpace();
1928  			}
1929  		}
1930  		ThinRectangularRange();
1931  	} else {
1932  		ClearSelection();
1933  	}
1934  	sel.RemoveDuplicates();
1935  	ContainerNeedsUpdate(Update::Selection);
1936  	ShowCaretAtCurrentPosition();
1937  }
1938  void Editor::NotifyFocus(bool focus) {
1939  	NotificationData scn = {};
1940  	scn.nmhdr.code = focus ? Notification::FocusIn : Notification::FocusOut;
1941  	NotifyParent(scn);
1942  }
1943  void Editor::SetCtrlID(int identifier) {
1944  	ctrlID = identifier;
1945  }
1946  void Editor::NotifyStyleToNeeded(Sci::Position endStyleNeeded) {
1947  	NotificationData scn = {};
1948  	scn.nmhdr.code = Notification::StyleNeeded;
1949  	scn.position = endStyleNeeded;
1950  	NotifyParent(scn);
1951  }
1952  void Editor::NotifyStyleNeeded(Document *, void *, Sci::Position endStyleNeeded) {
1953  	NotifyStyleToNeeded(endStyleNeeded);
1954  }
1955  void Editor::NotifyErrorOccurred(Document *, void *, Status status) {
1956  	errorStatus = status;
1957  }
1958  void Editor::NotifyChar(int ch, CharacterSource charSource) {
1959  	NotificationData scn = {};
1960  	scn.nmhdr.code = Notification::CharAdded;
1961  	scn.ch = ch;
1962  	scn.characterSource = charSource;
1963  	NotifyParent(scn);
1964  }
1965  void Editor::NotifySavePoint(bool isSavePoint) {
1966  	NotificationData scn = {};
1967  	if (isSavePoint) {
1968  		scn.nmhdr.code = Notification::SavePointReached;
1969  		if (changeHistoryOption != ChangeHistoryOption::Disabled) {
1970  			Redraw();
1971  		}
1972  	} else {
1973  		scn.nmhdr.code = Notification::SavePointLeft;
1974  	}
1975  	NotifyParent(scn);
1976  }
1977  void Editor::NotifyModifyAttempt() {
1978  	NotificationData scn = {};
1979  	scn.nmhdr.code = Notification::ModifyAttemptRO;
1980  	NotifyParent(scn);
1981  }
1982  void Editor::NotifyDoubleClick(Point pt, KeyMod modifiers) {
1983  	NotificationData scn = {};
1984  	scn.nmhdr.code = Notification::DoubleClick;
1985  	scn.line = LineFromLocation(pt);
1986  	scn.position = PositionFromLocation(pt, true);
1987  	scn.modifiers = modifiers;
1988  	NotifyParent(scn);
1989  }
1990  void Editor::NotifyHotSpotDoubleClicked(Sci::Position position, KeyMod modifiers) {
1991  	NotificationData scn = {};
1992  	scn.nmhdr.code = Notification::HotSpotDoubleClick;
1993  	scn.position = position;
1994  	scn.modifiers = modifiers;
1995  	NotifyParent(scn);
1996  }
1997  void Editor::NotifyHotSpotClicked(Sci::Position position, KeyMod modifiers) {
1998  	NotificationData scn = {};
1999  	scn.nmhdr.code = Notification::HotSpotClick;
2000  	scn.position = position;
2001  	scn.modifiers = modifiers;
2002  	NotifyParent(scn);
2003  }
2004  void Editor::NotifyHotSpotReleaseClick(Sci::Position position, KeyMod modifiers) {
2005  	NotificationData scn = {};
2006  	scn.nmhdr.code = Notification::HotSpotReleaseClick;
2007  	scn.position = position;
2008  	scn.modifiers = modifiers;
2009  	NotifyParent(scn);
2010  }
2011  bool Editor::NotifyUpdateUI() {
2012  	if (needUpdateUI != Update::None) {
2013  		NotificationData scn = {};
2014  		scn.nmhdr.code = Notification::UpdateUI;
2015  		scn.updated = needUpdateUI;
2016  		NotifyParent(scn);
2017  		needUpdateUI = Update::None;
2018  		return true;
2019  	}
2020  	return false;
2021  }
2022  void Editor::NotifyPainted() {
2023  	NotificationData scn = {};
2024  	scn.nmhdr.code = Notification::Painted;
2025  	NotifyParent(scn);
2026  }
2027  void Editor::NotifyIndicatorClick(bool click, Sci::Position position, KeyMod modifiers) {
2028  	const int mask = pdoc-&gt;decorations-&gt;AllOnFor(position);
2029  	if ((click &amp;&amp; mask) || pdoc-&gt;decorations-&gt;ClickNotified()) {
2030  		NotificationData scn = {};
2031  		pdoc-&gt;decorations-&gt;SetClickNotified(click);
2032  		scn.nmhdr.code = click ? Notification::IndicatorClick : Notification::IndicatorRelease;
2033  		scn.modifiers = modifiers;
2034  		scn.position = position;
2035  		NotifyParent(scn);
2036  	}
2037  }
2038  bool Editor::NotifyMarginClick(Point pt, KeyMod modifiers) {
2039  	const int marginClicked = vs.MarginFromLocation(pt);
2040  	if ((marginClicked &gt;= 0) &amp;&amp; vs.ms[marginClicked].sensitive) {
2041  		const Sci::Position position = pdoc-&gt;LineStart(LineFromLocation(pt));
2042  		if ((vs.ms[marginClicked].mask &amp; MaskFolders) &amp;&amp; (FlagSet(foldAutomatic, AutomaticFold::Click))) {
2043  			const bool ctrl = FlagSet(modifiers, KeyMod::Ctrl);
2044  			const bool shift = FlagSet(modifiers, KeyMod::Shift);
2045  			const Sci::Line lineClick = pdoc-&gt;SciLineFromPosition(position);
2046  			if (shift &amp;&amp; ctrl) {
2047  				FoldAll(FoldAction::Toggle);
2048  			} else {
2049  				const FoldLevel levelClick = pdoc-&gt;GetFoldLevel(lineClick);
2050  				if (LevelIsHeader(levelClick)) {
2051  					if (shift) {
2052  						FoldExpand(lineClick, FoldAction::Expand, levelClick);
2053  					} else if (ctrl) {
2054  						FoldExpand(lineClick, FoldAction::Toggle, levelClick);
2055  					} else {
2056  						FoldLine(lineClick, FoldAction::Toggle);
2057  					}
2058  				}
2059  			}
2060  			return true;
2061  		}
2062  		NotificationData scn = {};
2063  		scn.nmhdr.code = Notification::MarginClick;
2064  		scn.modifiers = modifiers;
2065  		scn.position = position;
2066  		scn.margin = marginClicked;
2067  		NotifyParent(scn);
2068  		return true;
2069  	} else {
2070  		return false;
2071  	}
2072  }
2073  bool Editor::NotifyMarginRightClick(Point pt, KeyMod modifiers) {
2074  	const int marginRightClicked = vs.MarginFromLocation(pt);
2075  	if ((marginRightClicked &gt;= 0) &amp;&amp; vs.ms[marginRightClicked].sensitive) {
2076  		const Sci::Position position = pdoc-&gt;LineStart(LineFromLocation(pt));
2077  		NotificationData scn = {};
2078  		scn.nmhdr.code = Notification::MarginRightClick;
2079  		scn.modifiers = modifiers;
2080  		scn.position = position;
2081  		scn.margin = marginRightClicked;
2082  		NotifyParent(scn);
2083  		return true;
2084  	} else {
2085  		return false;
2086  	}
2087  }
2088  void Editor::NotifyNeedShown(Sci::Position pos, Sci::Position len) {
2089  	NotificationData scn = {};
2090  	scn.nmhdr.code = Notification::NeedShown;
2091  	scn.position = pos;
2092  	scn.length = len;
2093  	NotifyParent(scn);
2094  }
2095  void Editor::NotifyDwelling(Point pt, bool state) {
2096  	NotificationData scn = {};
2097  	scn.nmhdr.code = state ? Notification::DwellStart : Notification::DwellEnd;
2098  	scn.position = PositionFromLocation(pt, true);
2099  	scn.x = static_cast&lt;int&gt;(pt.x + vs.ExternalMarginWidth());
2100  	scn.y = static_cast&lt;int&gt;(pt.y);
2101  	NotifyParent(scn);
2102  }
2103  void Editor::NotifyZoom() {
2104  	NotificationData scn = {};
2105  	scn.nmhdr.code = Notification::Zoom;
2106  	NotifyParent(scn);
2107  }
2108  void Editor::NotifyModifyAttempt(Document *, void *) {
2109  	NotifyModifyAttempt();
2110  }
2111  void Editor::NotifySavePoint(Document *, void *, bool atSavePoint) {
2112  	NotifySavePoint(atSavePoint);
2113  }
2114  void Editor::CheckModificationForWrap(DocModification mh) {
2115  	if (FlagSet(mh.modificationType, ModificationFlags::InsertText | ModificationFlags::DeleteText)) {
2116  		view.llc.Invalidate(LineLayout::ValidLevel::checkTextAndStyle);
2117  		const Sci::Line lineDoc = pdoc-&gt;SciLineFromPosition(mh.position);
2118  		const Sci::Line lines = std::max(static_cast&lt;Sci::Line&gt;(0), mh.linesAdded);
2119  		if (Wrapping()) {
2120  			NeedWrapping(lineDoc, lineDoc + lines + 1);
2121  		}
2122  		RefreshStyleData();
2123  		SetAnnotationHeights(lineDoc, lineDoc + lines + 2);
2124  	}
2125  }
2126  namespace {
2127  constexpr Sci::Position MovePositionForInsertion(Sci::Position position, Sci::Position startInsertion, Sci::Position length) noexcept {
2128  	if (position &gt; startInsertion) {
2129  		return position + length;
2130  	}
2131  	return position;
2132  }
2133  constexpr Sci::Position MovePositionForDeletion(Sci::Position position, Sci::Position startDeletion, Sci::Position length) noexcept {
2134  	if (position &gt; startDeletion) {
2135  		const Sci::Position endDeletion = startDeletion + length;
2136  		if (position &gt; endDeletion) {
2137  			return position - length;
2138  		} else {
2139  			return startDeletion;
2140  		}
2141  	} else {
2142  		return position;
2143  	}
2144  }
2145  }
2146  void Editor::NotifyModified(Document *, DocModification mh, void *) {
2147  	ContainerNeedsUpdate(Update::Content);
2148  	if (paintState == PaintState::painting) {
2149  		CheckForChangeOutsidePaint(Range(mh.position, mh.position + mh.length));
2150  	}
2151  	if (FlagSet(mh.modificationType, ModificationFlags::ChangeLineState)) {
2152  		if (paintState == PaintState::painting) {
2153  			CheckForChangeOutsidePaint(
2154  			    Range(pdoc-&gt;LineStart(mh.line),
2155  					pdoc-&gt;LineStart(mh.line + 1)));
2156  		} else {
2157  			Redraw();
2158  		}
2159  	}
2160  	if (FlagSet(mh.modificationType, ModificationFlags::ChangeTabStops)) {
2161  		Redraw();
2162  	}
2163  	if (FlagSet(mh.modificationType, ModificationFlags::LexerState)) {
2164  		if (paintState == PaintState::painting) {
2165  			CheckForChangeOutsidePaint(
2166  			    Range(mh.position, mh.position + mh.length));
2167  		} else {
2168  			Redraw();
2169  		}
2170  	}
2171  	if (FlagSet(mh.modificationType, ModificationFlags::ChangeStyle | ModificationFlags::ChangeIndicator)) {
2172  		if (FlagSet(mh.modificationType, ModificationFlags::ChangeStyle)) {
2173  			pdoc-&gt;IncrementStyleClock();
2174  		}
2175  		if (paintState == PaintState::notPainting) {
2176  			const Sci::Line lineDocTop = pcs-&gt;DocFromDisplay(topLine);
2177  			if (mh.position &lt; pdoc-&gt;LineStart(lineDocTop)) {
2178  				Redraw();
2179  			} else {
2180  				InvalidateRange(mh.position, mh.position + mh.length);
2181  			}
2182  		}
2183  		if (FlagSet(mh.modificationType, ModificationFlags::ChangeStyle)) {
2184  			view.llc.Invalidate(LineLayout::ValidLevel::checkTextAndStyle);
2185  		}
2186  	} else {
2187  		if (FlagSet(mh.modificationType, ModificationFlags::InsertText)) {
2188  			sel.MovePositions(true, mh.position, mh.length);
2189  			braces[0] = MovePositionForInsertion(braces[0], mh.position, mh.length);
2190  			braces[1] = MovePositionForInsertion(braces[1], mh.position, mh.length);
2191  		} else if (FlagSet(mh.modificationType, ModificationFlags::DeleteText)) {
2192  			sel.MovePositions(false, mh.position, mh.length);
2193  			braces[0] = MovePositionForDeletion(braces[0], mh.position, mh.length);
2194  			braces[1] = MovePositionForDeletion(braces[1], mh.position, mh.length);
2195  		}
2196  		if (FlagSet(mh.modificationType, ModificationFlags::BeforeInsert | ModificationFlags::BeforeDelete) &amp;&amp; pcs-&gt;HiddenLines()) {
2197  			const Sci::Line lineOfPos = pdoc-&gt;SciLineFromPosition(mh.position);
2198  			Sci::Position endNeedShown = mh.position;
2199  			if (FlagSet(mh.modificationType, ModificationFlags::BeforeInsert)) {
2200  				if (pdoc-&gt;ContainsLineEnd(mh.text, mh.length) &amp;&amp; (mh.position != pdoc-&gt;LineStart(lineOfPos)))
2201  					endNeedShown = pdoc-&gt;LineStart(lineOfPos+1);
2202  			} else if (FlagSet(mh.modificationType, ModificationFlags::BeforeDelete)) {
2203  				endNeedShown = mh.position + mh.length;
2204  				Sci::Line lineLast = pdoc-&gt;SciLineFromPosition(mh.position+mh.length);
2205  				for (Sci::Line line = lineOfPos + 1; line &lt;= lineLast; line++) {
2206  					const Sci::Line lineMaxSubord = pdoc-&gt;GetLastChild(line, {}, -1);
2207  					if (lineLast &lt; lineMaxSubord) {
2208  						lineLast = lineMaxSubord;
2209  						endNeedShown = pdoc-&gt;LineEnd(lineLast);
2210  					}
2211  				}
2212  			}
2213  			NeedShown(mh.position, endNeedShown - mh.position);
2214  		}
2215  		if (mh.linesAdded != 0) {
2216  			Sci::Line lineOfPos = pdoc-&gt;SciLineFromPosition(mh.position);
2217  			if (mh.position &gt; pdoc-&gt;LineStart(lineOfPos))
2218  				lineOfPos++;	
2219  			if (mh.linesAdded &gt; 0) {
2220  				pcs-&gt;InsertLines(lineOfPos, mh.linesAdded);
2221  			} else {
2222  				pcs-&gt;DeleteLines(lineOfPos, -mh.linesAdded);
2223  			}
2224  			view.LinesAddedOrRemoved(lineOfPos, mh.linesAdded);
2225  		}
2226  		if (FlagSet(mh.modificationType, ModificationFlags::ChangeAnnotation)) {
2227  			const Sci::Line lineDoc = pdoc-&gt;SciLineFromPosition(mh.position);
2228  			if (vs.annotationVisible != AnnotationVisible::Hidden) {
2229  				if (pcs-&gt;SetHeight(lineDoc, pcs-&gt;GetHeight(lineDoc) + static_cast&lt;int&gt;(mh.annotationLinesAdded))) {
2230  					SetScrollBars();
2231  				}
2232  				Redraw();
2233  			}
2234  		}
2235  		if (FlagSet(mh.modificationType, ModificationFlags::ChangeEOLAnnotation)) {
2236  			if (vs.eolAnnotationVisible != EOLAnnotationVisible::Hidden) {
2237  				Redraw();
2238  			}
2239  		}
2240  		CheckModificationForWrap(mh);
2241  		if (mh.linesAdded != 0) {
2242  			if (mh.position &lt; posTopLine &amp;&amp; !CanDeferToLastStep(mh)) {
2243  				const Sci::Line newTop = std::clamp&lt;Sci::Line&gt;(topLine + mh.linesAdded, 0, MaxScrollPos());
2244  				if (newTop != topLine) {
2245  					SetTopLine(newTop);
2246  					SetVerticalScrollPos();
2247  				}
2248  			}
2249  			if (paintState == PaintState::notPainting &amp;&amp; !CanDeferToLastStep(mh)) {
2250  				if (SynchronousStylingToVisible()) {
2251  					QueueIdleWork(WorkItems::style, pdoc-&gt;Length());
2252  				}
2253  				Redraw();
2254  			}
2255  		} else {
2256  			if (paintState == PaintState::notPainting &amp;&amp; mh.length &amp;&amp; !CanEliminate(mh)) {
2257  				if (SynchronousStylingToVisible()) {
2258  					QueueIdleWork(WorkItems::style, mh.position + mh.length);
2259  				}
2260  				InvalidateRange(mh.position, mh.position + mh.length);
2261  				if (FlagSet(changeHistoryOption, ChangeHistoryOption::Markers)) {
2262  					RedrawSelMargin(pdoc-&gt;SciLineFromPosition(mh.position));
2263  				}
2264  			}
2265  		}
2266  	}
2267  	if (mh.linesAdded != 0 &amp;&amp; !CanDeferToLastStep(mh)) {
2268  		SetScrollBars();
2269  	}
2270  	if ((FlagSet(mh.modificationType, ModificationFlags::ChangeMarker)) || (FlagSet(mh.modificationType, ModificationFlags::ChangeMargin))) {
2271  		if ((!willRedrawAll) &amp;&amp; ((paintState == PaintState::notPainting) || !PaintContainsMargin())) {
2272  			if (FlagSet(mh.modificationType, ModificationFlags::ChangeFold)) {
2273  				RedrawSelMargin(marginView.highlightDelimiter.isEnabled ? -1 : mh.line - 1, true);
2274  			} else {
2275  				RedrawSelMargin(mh.line);
2276  			}
2277  		}
2278  	}
2279  	if ((FlagSet(mh.modificationType, ModificationFlags::ChangeFold)) &amp;&amp; (FlagSet(foldAutomatic, AutomaticFold::Change))) {
2280  		FoldChanged(mh.line, mh.foldLevelNow, mh.foldLevelPrev);
2281  	}
2282  	if (IsLastStep(mh)) {
2283  		SetScrollBars();
2284  		Redraw();
2285  	}
2286  	if (FlagSet(mh.modificationType, modEventMask)) {
2287  		if (commandEvents) {
2288  			if ((mh.modificationType &amp; (ModificationFlags::ChangeStyle | ModificationFlags::ChangeIndicator)) == ModificationFlags::None) {
2289  				NotifyChange();	
2290  			}
2291  		}
2292  		NotificationData scn = {};
2293  		scn.nmhdr.code = Notification::Modified;
2294  		scn.position = mh.position;
2295  		scn.modificationType = mh.modificationType;
2296  		scn.text = mh.text;
2297  		scn.length = mh.length;
2298  		scn.linesAdded = mh.linesAdded;
2299  		scn.line = mh.line;
2300  		scn.foldLevelNow = mh.foldLevelNow;
2301  		scn.foldLevelPrev = mh.foldLevelPrev;
2302  		scn.token = static_cast&lt;int&gt;(mh.token);
2303  		scn.annotationLinesAdded = mh.annotationLinesAdded;
2304  		NotifyParent(scn);
2305  	}
2306  }
2307  void Editor::NotifyDeleted(Document *, void *) noexcept {
2308  }
2309  void Editor::NotifyMacroRecord(Message iMessage, uptr_t wParam, sptr_t lParam) {
2310  	switch (iMessage) {
2311  	case Message::Cut:
2312  	case Message::Copy:
2313  	case Message::Paste:
2314  	case Message::Clear:
2315  	case Message::ReplaceSel:
2316  	case Message::AddText:
2317  	case Message::InsertText:
2318  	case Message::AppendText:
2319  	case Message::ClearAll:
2320  	case Message::SelectAll:
2321  	case Message::GotoLine:
2322  	case Message::GotoPos:
2323  	case Message::SearchAnchor:
2324  	case Message::SearchNext:
2325  	case Message::SearchPrev:
2326  	case Message::LineDown:
2327  	case Message::LineDownExtend:
2328  	case Message::ParaDown:
2329  	case Message::ParaDownExtend:
2330  	case Message::LineUp:
2331  	case Message::LineUpExtend:
2332  	case Message::ParaUp:
2333  	case Message::ParaUpExtend:
2334  	case Message::CharLeft:
2335  	case Message::CharLeftExtend:
2336  	case Message::CharRight:
2337  	case Message::CharRightExtend:
2338  	case Message::WordLeft:
2339  	case Message::WordLeftExtend:
2340  	case Message::WordRight:
2341  	case Message::WordRightExtend:
2342  	case Message::WordPartLeft:
2343  	case Message::WordPartLeftExtend:
2344  	case Message::WordPartRight:
2345  	case Message::WordPartRightExtend:
2346  	case Message::WordLeftEnd:
2347  	case Message::WordLeftEndExtend:
2348  	case Message::WordRightEnd:
2349  	case Message::WordRightEndExtend:
2350  	case Message::Home:
2351  	case Message::HomeExtend:
2352  	case Message::LineEnd:
2353  	case Message::LineEndExtend:
2354  	case Message::HomeWrap:
2355  	case Message::HomeWrapExtend:
2356  	case Message::LineEndWrap:
2357  	case Message::LineEndWrapExtend:
2358  	case Message::DocumentStart:
2359  	case Message::DocumentStartExtend:
2360  	case Message::DocumentEnd:
2361  	case Message::DocumentEndExtend:
2362  	case Message::StutteredPageUp:
2363  	case Message::StutteredPageUpExtend:
2364  	case Message::StutteredPageDown:
2365  	case Message::StutteredPageDownExtend:
2366  	case Message::PageUp:
2367  	case Message::PageUpExtend:
2368  	case Message::PageDown:
2369  	case Message::PageDownExtend:
2370  	case Message::EditToggleOvertype:
2371  	case Message::Cancel:
2372  	case Message::DeleteBack:
2373  	case Message::Tab:
2374  	case Message::BackTab:
2375  	case Message::FormFeed:
2376  	case Message::VCHome:
2377  	case Message::VCHomeExtend:
2378  	case Message::VCHomeWrap:
2379  	case Message::VCHomeWrapExtend:
2380  	case Message::VCHomeDisplay:
2381  	case Message::VCHomeDisplayExtend:
2382  	case Message::DelWordLeft:
2383  	case Message::DelWordRight:
2384  	case Message::DelWordRightEnd:
2385  	case Message::DelLineLeft:
2386  	case Message::DelLineRight:
2387  	case Message::LineCopy:
2388  	case Message::LineCut:
2389  	case Message::LineDelete:
2390  	case Message::LineTranspose:
2391  	case Message::LineReverse:
2392  	case Message::LineDuplicate:
2393  	case Message::LowerCase:
2394  	case Message::UpperCase:
2395  	case Message::LineScrollDown:
2396  	case Message::LineScrollUp:
2397  	case Message::DeleteBackNotLine:
2398  	case Message::HomeDisplay:
2399  	case Message::HomeDisplayExtend:
2400  	case Message::LineEndDisplay:
2401  	case Message::LineEndDisplayExtend:
2402  	case Message::SetSelectionMode:
2403  	case Message::LineDownRectExtend:
2404  	case Message::LineUpRectExtend:
2405  	case Message::CharLeftRectExtend:
2406  	case Message::CharRightRectExtend:
2407  	case Message::HomeRectExtend:
2408  	case Message::VCHomeRectExtend:
2409  	case Message::LineEndRectExtend:
2410  	case Message::PageUpRectExtend:
2411  	case Message::PageDownRectExtend:
2412  	case Message::SelectionDuplicate:
2413  	case Message::CopyAllowLine:
2414  	case Message::VerticalCentreCaret:
2415  	case Message::MoveSelectedLinesUp:
2416  	case Message::MoveSelectedLinesDown:
2417  	case Message::ScrollToStart:
2418  	case Message::ScrollToEnd:
2419  		break;
2420  	case Message::NewLine:
2421  	default:
2422  		return;
2423  	}
2424  	NotificationData scn = {};
2425  	scn.nmhdr.code = Notification::MacroRecord;
2426  	scn.message = iMessage;
2427  	scn.wParam = wParam;
2428  	scn.lParam = lParam;
2429  	NotifyParent(scn);
2430  }
2431  void Editor::ContainerNeedsUpdate(Update flags) noexcept {
2432  	needUpdateUI = needUpdateUI | flags;
2433  }
2434  void Editor::PageMove(int direction, Selection::SelTypes selt, bool stuttered) {
2435  	Sci::Line topLineNew;
2436  	SelectionPosition newPos;
2437  	const Sci::Line currentLine = pdoc-&gt;SciLineFromPosition(sel.MainCaret());
2438  	const Sci::Line topStutterLine = topLine + caretPolicies.y.slop;
2439  	const Sci::Line bottomStutterLine =
2440  	    pdoc-&gt;SciLineFromPosition(PositionFromLocation(
2441  	                Point::FromInts(lastXChosen - xOffset, direction * vs.lineHeight * static_cast&lt;int&gt;(LinesToScroll()))))
2442  	    - caretPolicies.y.slop - 1;
2443  	if (stuttered &amp;&amp; (direction &lt; 0 &amp;&amp; currentLine &gt; topStutterLine)) {
2444  		topLineNew = topLine;
2445  		newPos = SPositionFromLocation(Point::FromInts(lastXChosen - xOffset, vs.lineHeight * caretPolicies.y.slop),
2446  			false, false, UserVirtualSpace());
2447  	} else if (stuttered &amp;&amp; (direction &gt; 0 &amp;&amp; currentLine &lt; bottomStutterLine)) {
2448  		topLineNew = topLine;
2449  		newPos = SPositionFromLocation(Point::FromInts(lastXChosen - xOffset, vs.lineHeight * static_cast&lt;int&gt;(LinesToScroll() - caretPolicies.y.slop)),
2450  			false, false, UserVirtualSpace());
2451  	} else {
2452  		const Point pt = LocationFromPosition(sel.MainCaret());
2453  		topLineNew = std::clamp&lt;Sci::Line&gt;(
2454  		            topLine + direction * LinesToScroll(), 0, MaxScrollPos());
2455  		newPos = SPositionFromLocation(
2456  			Point::FromInts(lastXChosen - xOffset, static_cast&lt;int&gt;(pt.y) +
2457  				direction * (vs.lineHeight * static_cast&lt;int&gt;(LinesToScroll()))),
2458  			false, false, UserVirtualSpace());
2459  	}
2460  	if (topLineNew != topLine) {
2461  		SetTopLine(topLineNew);
2462  		MovePositionTo(newPos, selt);
2463  		SetVerticalScrollPos();
2464  		Redraw();
2465  	} else {
2466  		MovePositionTo(newPos, selt);
2467  	}
2468  }
2469  void Editor::ChangeCaseOfSelection(CaseMapping caseMapping) {
2470  	UndoGroup ug(pdoc);
2471  	for (size_t r=0; r&lt;sel.Count(); r++) {
2472  		SelectionRange current = sel.Range(r);
2473  		SelectionRange currentNoVS = current;
2474  		currentNoVS.ClearVirtualSpace();
2475  		const size_t rangeBytes = currentNoVS.Length();
2476  		if (rangeBytes &gt; 0) {
2477  			std::string sText = RangeText(currentNoVS.Start().Position(), currentNoVS.End().Position());
2478  			std::string sMapped = CaseMapString(sText, caseMapping);
2479  			if (sMapped != sText) {
2480  				size_t firstDifference = 0;
2481  				while (sMapped[firstDifference] == sText[firstDifference])
2482  					firstDifference++;
2483  				size_t lastDifferenceText = sText.size() - 1;
2484  				size_t lastDifferenceMapped = sMapped.size() - 1;
2485  				while (sMapped[lastDifferenceMapped] == sText[lastDifferenceText]) {
2486  					lastDifferenceText--;
2487  					lastDifferenceMapped--;
2488  				}
2489  				const size_t endDifferenceText = sText.size() - 1 - lastDifferenceText;
2490  				pdoc-&gt;DeleteChars(
2491  					currentNoVS.Start().Position() + firstDifference,
2492  					rangeBytes - firstDifference - endDifferenceText);
2493  				const Sci::Position lengthChange = lastDifferenceMapped - firstDifference + 1;
2494  				const Sci::Position lengthInserted = pdoc-&gt;InsertString(
2495  					currentNoVS.Start().Position() + firstDifference,
2496  					sMapped.c_str() + firstDifference,
2497  					lengthChange);
2498  				const Sci::Position diffSizes = sMapped.size() - sText.size() + lengthInserted - lengthChange;
2499  				if (diffSizes != 0) {
2500  					if (current.anchor &gt; current.caret)
2501  						current.anchor.Add(diffSizes);
2502  					else
2503  						current.caret.Add(diffSizes);
2504  				}
2505  				sel.Range(r) = current;
2506  			}
2507  		}
2508  	}
2509  }
2510  void Editor::LineTranspose() {
2511  	const Sci::Line line = pdoc-&gt;SciLineFromPosition(sel.MainCaret());
2512  	if (line &gt; 0) {
2513  		UndoGroup ug(pdoc);
2514  		const Sci::Position startPrevious = pdoc-&gt;LineStart(line - 1);
2515  		const std::string linePrevious = RangeText(startPrevious, pdoc-&gt;LineEnd(line - 1));
2516  		Sci::Position startCurrent = pdoc-&gt;LineStart(line);
2517  		const std::string lineCurrent = RangeText(startCurrent, pdoc-&gt;LineEnd(line));
2518  		pdoc-&gt;DeleteChars(startCurrent, lineCurrent.length());
2519  		pdoc-&gt;DeleteChars(startPrevious, linePrevious.length());
2520  		startCurrent -= linePrevious.length();
2521  		startCurrent += pdoc-&gt;InsertString(startPrevious, lineCurrent);
2522  		pdoc-&gt;InsertString(startCurrent, linePrevious);
2523  		MovePositionTo(SelectionPosition(startCurrent));
2524  	}
2525  }
2526  void Editor::LineReverse() {
2527  	const Sci::Line lineStart =
2528  		pdoc-&gt;SciLineFromPosition(sel.RangeMain().Start().Position());
2529  	const Sci::Line lineEnd =
2530  		pdoc-&gt;SciLineFromPosition(sel.RangeMain().End().Position()-1);
2531  	const Sci::Line lineDiff = lineEnd - lineStart;
2532  	if (lineDiff &lt;= 0)
2533  		return;
2534  	UndoGroup ug(pdoc);
2535  	for (Sci::Line i=(lineDiff+1)/2-1; i&gt;=0; --i) {
2536  		const Sci::Line lineNum2 = lineEnd - i;
2537  		const Sci::Line lineNum1 = lineStart + i;
2538  		Sci::Position lineStart2 = pdoc-&gt;LineStart(lineNum2);
2539  		const Sci::Position lineStart1 = pdoc-&gt;LineStart(lineNum1);
2540  		const std::string line2 = RangeText(lineStart2, pdoc-&gt;LineEnd(lineNum2));
2541  		const std::string line1 = RangeText(lineStart1, pdoc-&gt;LineEnd(lineNum1));
2542  		const Sci::Position lineLen2 = line2.length();
2543  		const Sci::Position lineLen1 = line1.length();
2544  		pdoc-&gt;DeleteChars(lineStart2, lineLen2);
2545  		pdoc-&gt;DeleteChars(lineStart1, lineLen1);
2546  		lineStart2 -= lineLen1;
2547  		pdoc-&gt;InsertString(lineStart2, line1);
2548  		pdoc-&gt;InsertString(lineStart1, line2);
2549  	}
2550  	sel.RangeMain() = SelectionRange(pdoc-&gt;LineStart(lineStart),
2551  		pdoc-&gt;LineStart(lineEnd+1));
2552  }
2553  void Editor::Duplicate(bool forLine) {
2554  	if (sel.Empty()) {
2555  		forLine = true;
2556  	}
2557  	UndoGroup ug(pdoc);
2558  	std::string_view eol;
2559  	if (forLine) {
2560  		eol = pdoc-&gt;EOLString();
2561  	}
2562  	for (size_t r=0; r&lt;sel.Count(); r++) {
2563  		SelectionPosition start = sel.Range(r).Start();
2564  		SelectionPosition end = sel.Range(r).End();
2565  		if (forLine) {
2566  			const Sci::Line line = pdoc-&gt;SciLineFromPosition(sel.Range(r).caret.Position());
2567  			start = SelectionPosition(pdoc-&gt;LineStart(line));
2568  			end = SelectionPosition(pdoc-&gt;LineEnd(line));
2569  		}
2570  		std::string text = RangeText(start.Position(), end.Position());
2571  		Sci::Position lengthInserted = 0;
2572  		if (forLine)
2573  			lengthInserted = pdoc-&gt;InsertString(end.Position(), eol);
2574  		pdoc-&gt;InsertString(end.Position() + lengthInserted, text);
2575  	}
2576  	if (sel.Count() &amp;&amp; sel.IsRectangular()) {
2577  		SelectionPosition last = sel.Last();
2578  		if (forLine) {
2579  			const Sci::Line line = pdoc-&gt;SciLineFromPosition(last.Position());
2580  			last = SelectionPosition(last.Position() +
2581  				pdoc-&gt;LineStart(line+1) - pdoc-&gt;LineStart(line));
2582  		}
2583  		if (sel.Rectangular().anchor &gt; sel.Rectangular().caret)
2584  			sel.Rectangular().anchor = last;
2585  		else
2586  			sel.Rectangular().caret = last;
2587  		SetRectangularRange();
2588  	}
2589  }
2590  void Editor::CancelModes() {
2591  	sel.SetMoveExtends(false);
2592  }
2593  void Editor::NewLine() {
2594  	InvalidateWholeSelection();
2595  	if (sel.IsRectangular() || !additionalSelectionTyping) {
2596  		sel.DropAdditionalRanges();
2597  	}
2598  	UndoGroup ug(pdoc, !sel.Empty() || (sel.Count() &gt; 1));
2599  	if (!sel.Empty()) {
2600  		ClearSelection();
2601  	}
2602  	size_t countInsertions = 0;
2603  	const std::string_view eol = pdoc-&gt;EOLString();
2604  	for (size_t r = 0; r &lt; sel.Count(); r++) {
2605  		sel.Range(r).ClearVirtualSpace();
2606  		const Sci::Position positionInsert = sel.Range(r).caret.Position();
2607  		const Sci::Position insertLength = pdoc-&gt;InsertString(positionInsert, eol);
2608  		if (insertLength &gt; 0) {
2609  			sel.Range(r) = SelectionRange(positionInsert + insertLength);
2610  			countInsertions++;
2611  		}
2612  	}
2613  	for (size_t i = 0; i &lt; countInsertions; i++) {
2614  		for (const char ch : eol) {
2615  			NotifyChar(ch, CharacterSource::DirectInput);
2616  			if (recordingMacro) {
2617  				const char txt[2] = { ch, &#x27;\0&#x27; };
2618  				NotifyMacroRecord(Message::ReplaceSel, 0, reinterpret_cast&lt;sptr_t&gt;(txt));
2619  			}
2620  		}
2621  	}
2622  	SetLastXChosen();
2623  	SetScrollBars();
2624  	EnsureCaretVisible();
2625  	ShowCaretAtCurrentPosition();
2626  }
2627  SelectionPosition Editor::PositionUpOrDown(SelectionPosition spStart, int direction, int lastX) {
2628  	const Point pt = LocationFromPosition(spStart);
2629  	int skipLines = 0;
2630  	if (vs.annotationVisible != AnnotationVisible::Hidden) {
2631  		const Sci::Line lineDoc = pdoc-&gt;SciLineFromPosition(spStart.Position());
2632  		const Point ptStartLine = LocationFromPosition(pdoc-&gt;LineStart(lineDoc));
2633  		const int subLine = static_cast&lt;int&gt;(pt.y - ptStartLine.y) / vs.lineHeight;
2634  		if (direction &lt; 0 &amp;&amp; subLine == 0) {
2635  			const Sci::Line lineDisplay = pcs-&gt;DisplayFromDoc(lineDoc);
2636  			if (lineDisplay &gt; 0) {
2637  				skipLines = pdoc-&gt;AnnotationLines(pcs-&gt;DocFromDisplay(lineDisplay - 1));
2638  			}
2639  		} else if (direction &gt; 0 &amp;&amp; subLine &gt;= (pcs-&gt;GetHeight(lineDoc) - 1 - pdoc-&gt;AnnotationLines(lineDoc))) {
2640  			skipLines = pdoc-&gt;AnnotationLines(lineDoc);
2641  		}
2642  	}
2643  	const Sci::Line newY = static_cast&lt;Sci::Line&gt;(pt.y) + (1 + skipLines) * direction * vs.lineHeight;
2644  	if (lastX &lt; 0) {
2645  		lastX = static_cast&lt;int&gt;(pt.x) + xOffset;
2646  	}
2647  	SelectionPosition posNew = SPositionFromLocation(
2648  		Point::FromInts(lastX - xOffset, static_cast&lt;int&gt;(newY)), false, false, UserVirtualSpace());
2649  	if (direction &lt; 0) {
2650  		Point ptNew = LocationFromPosition(posNew.Position());
2651  		while ((posNew.Position() &gt; 0) &amp;&amp; (pt.y == ptNew.y)) {
2652  			posNew.Add(-1);
2653  			posNew.SetVirtualSpace(0);
2654  			ptNew = LocationFromPosition(posNew.Position());
2655  		}
2656  	} else if (direction &gt; 0 &amp;&amp; posNew.Position() != pdoc-&gt;Length()) {
2657  		Point ptNew = LocationFromPosition(posNew.Position());
2658  		while ((posNew.Position() &gt; spStart.Position()) &amp;&amp; (ptNew.y &gt; newY)) {
2659  			posNew.Add(-1);
2660  			posNew.SetVirtualSpace(0);
2661  			ptNew = LocationFromPosition(posNew.Position());
2662  		}
2663  	}
2664  	return posNew;
2665  }
2666  void Editor::CursorUpOrDown(int direction, Selection::SelTypes selt) {
2667  	if ((selt == Selection::SelTypes::none) &amp;&amp; sel.MoveExtends()) {
2668  		selt = !sel.IsRectangular() ? Selection::SelTypes::stream : Selection::SelTypes::rectangle;
2669  	}
2670  	SelectionPosition caretToUse = sel.Range(sel.Main()).caret;
2671  	if (sel.IsRectangular()) {
2672  		if (selt ==  Selection::SelTypes::none) {
2673  			caretToUse = (direction &gt; 0) ? sel.Limits().end : sel.Limits().start;
2674  		} else {
2675  			caretToUse = sel.Rectangular().caret;
2676  		}
2677  	}
2678  	if (selt == Selection::SelTypes::rectangle) {
2679  		const SelectionRange rangeBase = sel.IsRectangular() ? sel.Rectangular() : sel.RangeMain();
2680  		if (!sel.IsRectangular()) {
2681  			InvalidateWholeSelection();
2682  			sel.DropAdditionalRanges();
2683  		}
2684  		const SelectionPosition posNew = MovePositionSoVisible(
2685  			PositionUpOrDown(caretToUse, direction, lastXChosen), direction);
2686  		sel.selType = Selection::SelTypes::rectangle;
2687  		sel.Rectangular() = SelectionRange(posNew, rangeBase.anchor);
2688  		SetRectangularRange();
2689  		MovedCaret(posNew, caretToUse, true, caretPolicies);
2690  	} else if (sel.selType == Selection::SelTypes::lines &amp;&amp; sel.MoveExtends()) {
2691  		const SelectionPosition posNew = MovePositionSoVisible(
2692  			PositionUpOrDown(caretToUse, direction, -1), direction);
2693  		SetSelection(posNew, sel.Range(sel.Main()).anchor);
2694  	} else {
2695  		InvalidateWholeSelection();
2696  		if (!additionalSelectionTyping || (sel.IsRectangular())) {
2697  			sel.DropAdditionalRanges();
2698  		}
2699  		sel.selType = Selection::SelTypes::stream;
2700  		for (size_t r = 0; r &lt; sel.Count(); r++) {
2701  			const int lastX = (r == sel.Main()) ? lastXChosen : -1;
2702  			const SelectionPosition spCaretNow = sel.Range(r).caret;
2703  			const SelectionPosition posNew = MovePositionSoVisible(
2704  				PositionUpOrDown(spCaretNow, direction, lastX), direction);
2705  			sel.Range(r) = selt == Selection::SelTypes::stream ?
2706  				SelectionRange(posNew, sel.Range(r).anchor) : SelectionRange(posNew);
2707  		}
2708  		sel.RemoveDuplicates();
2709  		MovedCaret(sel.RangeMain().caret, caretToUse, true, caretPolicies);
2710  	}
2711  }
2712  void Editor::ParaUpOrDown(int direction, Selection::SelTypes selt) {
2713  	Sci::Line lineDoc;
2714  	const Sci::Position savedPos = sel.MainCaret();
2715  	do {
2716  		MovePositionTo(SelectionPosition(direction &gt; 0 ? pdoc-&gt;ParaDown(sel.MainCaret()) : pdoc-&gt;ParaUp(sel.MainCaret())), selt);
2717  		lineDoc = pdoc-&gt;SciLineFromPosition(sel.MainCaret());
2718  		if (direction &gt; 0) {
2719  			if (sel.MainCaret() &gt;= pdoc-&gt;Length() &amp;&amp; !pcs-&gt;GetVisible(lineDoc)) {
2720  				if (selt == Selection::SelTypes::none) {
2721  					MovePositionTo(SelectionPosition(pdoc-&gt;LineEndPosition(savedPos)));
2722  				}
2723  				break;
2724  			}
2725  		}
2726  	} while (!pcs-&gt;GetVisible(lineDoc));
2727  }
2728  Range Editor::RangeDisplayLine(Sci::Line lineVisible) {
2729  	RefreshStyleData();
2730  	AutoSurface surface(this);
2731  	return view.RangeDisplayLine(surface, *this, lineVisible, vs);
2732  }
2733  Sci::Position Editor::StartEndDisplayLine(Sci::Position pos, bool start) {
2734  	RefreshStyleData();
2735  	AutoSurface surface(this);
2736  	const Sci::Position posRet = view.StartEndDisplayLine(surface, *this, pos, start, vs);
2737  	if (posRet == Sci::invalidPosition) {
2738  		return pos;
2739  	} else {
2740  		return posRet;
2741  	}
2742  }
2743  namespace {
2744  constexpr short HighShortFromWParam(uptr_t x) {
2745  	return static_cast&lt;short&gt;(x &gt;&gt; 16);
2746  }
2747  constexpr short LowShortFromWParam(uptr_t x) {
2748  	return static_cast&lt;short&gt;(x &amp; 0xffff);
2749  }
2750  constexpr Message WithExtends(Message iMessage) noexcept {
2751  	switch (iMessage) {
2752  	case Message::CharLeft: return Message::CharLeftExtend;
2753  	case Message::CharRight: return Message::CharRightExtend;
2754  	case Message::WordLeft: return Message::WordLeftExtend;
2755  	case Message::WordRight: return Message::WordRightExtend;
2756  	case Message::WordLeftEnd: return Message::WordLeftEndExtend;
2757  	case Message::WordRightEnd: return Message::WordRightEndExtend;
2758  	case Message::WordPartLeft: return Message::WordPartLeftExtend;
2759  	case Message::WordPartRight: return Message::WordPartRightExtend;
2760  	case Message::Home: return Message::HomeExtend;
2761  	case Message::HomeDisplay: return Message::HomeDisplayExtend;
2762  	case Message::HomeWrap: return Message::HomeWrapExtend;
2763  	case Message::VCHome: return Message::VCHomeExtend;
2764  	case Message::VCHomeDisplay: return Message::VCHomeDisplayExtend;
2765  	case Message::VCHomeWrap: return Message::VCHomeWrapExtend;
2766  	case Message::LineEnd: return Message::LineEndExtend;
2767  	case Message::LineEndDisplay: return Message::LineEndDisplayExtend;
2768  	case Message::LineEndWrap: return Message::LineEndWrapExtend;
2769  	default:	return iMessage;
2770  	}
2771  }
2772  constexpr int NaturalDirection(Message iMessage) noexcept {
2773  	switch (iMessage) {
2774  	case Message::CharLeft:
2775  	case Message::CharLeftExtend:
2776  	case Message::CharLeftRectExtend:
2777  	case Message::WordLeft:
2778  	case Message::WordLeftExtend:
2779  	case Message::WordLeftEnd:
2780  	case Message::WordLeftEndExtend:
2781  	case Message::WordPartLeft:
2782  	case Message::WordPartLeftExtend:
2783  	case Message::Home:
2784  	case Message::HomeExtend:
2785  	case Message::HomeDisplay:
2786  	case Message::HomeDisplayExtend:
2787  	case Message::HomeWrap:
2788  	case Message::HomeWrapExtend:
2789  	case Message::VCHome:
2790  	case Message::VCHomeExtend:
2791  	case Message::VCHomeDisplay:
2792  	case Message::VCHomeDisplayExtend:
2793  	case Message::VCHomeWrap:
2794  	case Message::VCHomeWrapExtend:
2795  		return -1;
2796  	default:
2797  		return 1;
2798  	}
2799  }
2800  constexpr bool IsRectExtend(Message iMessage, bool isRectMoveExtends) noexcept {
2801  	switch (iMessage) {
2802  	case Message::CharLeftRectExtend:
2803  	case Message::CharRightRectExtend:
2804  	case Message::HomeRectExtend:
2805  	case Message::VCHomeRectExtend:
2806  	case Message::LineEndRectExtend:
2807  		return true;
2808  	default:
2809  		if (isRectMoveExtends) {
2810  			switch (iMessage) {
2811  			case Message::CharLeftExtend:
2812  			case Message::CharRightExtend:
2813  			case Message::HomeExtend:
2814  			case Message::VCHomeExtend:
2815  			case Message::LineEndExtend:
2816  				return true;
2817  			default:
2818  				return false;
2819  			}
2820  		}
2821  		return false;
2822  	}
2823  }
2824  }
2825  Sci::Position Editor::VCHomeDisplayPosition(Sci::Position position) {
2826  	const Sci::Position homePos = pdoc-&gt;VCHomePosition(position);
2827  	const Sci::Position viewLineStart = StartEndDisplayLine(position, true);
2828  	if (viewLineStart &gt; homePos)
2829  		return viewLineStart;
2830  	else
2831  		return homePos;
2832  }
2833  Sci::Position Editor::VCHomeWrapPosition(Sci::Position position) {
2834  	const Sci::Position homePos = pdoc-&gt;VCHomePosition(position);
2835  	const Sci::Position viewLineStart = StartEndDisplayLine(position, true);
2836  	if ((viewLineStart &lt; position) &amp;&amp; (viewLineStart &gt; homePos))
2837  		return viewLineStart;
2838  	else
2839  		return homePos;
2840  }
2841  Sci::Position Editor::LineEndWrapPosition(Sci::Position position) {
2842  	const Sci::Position endPos = StartEndDisplayLine(position, false);
2843  	const Sci::Position realEndPos = pdoc-&gt;LineEndPosition(position);
2844  	if (endPos &gt; realEndPos      
2845  		|| position &gt;= endPos) 
2846  		return realEndPos;
2847  	else
2848  		return endPos;
2849  }
2850  int Editor::HorizontalMove(Message iMessage) {
2851  	if (sel.selType == Selection::SelTypes::lines) {
2852  		return 0; 
2853  	}
2854  	if (sel.MoveExtends()) {
2855  		iMessage = WithExtends(iMessage);
2856  	}
2857  	if (!multipleSelection &amp;&amp; !sel.IsRectangular()) {
2858  		sel.SetSelection(sel.RangeMain());
2859  	}
2860  	InvalidateWholeSelection();
2861  	if (IsRectExtend(iMessage, sel.IsRectangular() &amp;&amp; sel.MoveExtends())) {
2862  		const SelectionRange rangeBase = sel.IsRectangular() ? sel.Rectangular() : sel.RangeMain();
2863  		if (!sel.IsRectangular()) {
2864  			sel.DropAdditionalRanges();
2865  		}
2866  		SelectionPosition spCaret = rangeBase.caret;
2867  		switch (iMessage) {
2868  		case Message::CharLeftRectExtend:
2869  		case Message::CharLeftExtend: 
2870  			if (pdoc-&gt;IsLineEndPosition(spCaret.Position()) &amp;&amp; spCaret.VirtualSpace()) {
2871  				spCaret.SetVirtualSpace(spCaret.VirtualSpace() - 1);
2872  			} else if (!FlagSet(virtualSpaceOptions, VirtualSpace::NoWrapLineStart) || pdoc-&gt;GetColumn(spCaret.Position()) &gt; 0) {
2873  				spCaret = SelectionPosition(spCaret.Position() - 1);
2874  			}
2875  			break;
2876  		case Message::CharRightRectExtend:
2877  		case Message::CharRightExtend: 
2878  			if (FlagSet(virtualSpaceOptions, VirtualSpace::RectangularSelection) &amp;&amp; pdoc-&gt;IsLineEndPosition(sel.MainCaret())) {
2879  				spCaret.SetVirtualSpace(spCaret.VirtualSpace() + 1);
2880  			} else {
2881  				spCaret = SelectionPosition(spCaret.Position() + 1);
2882  			}
2883  			break;
2884  		case Message::HomeRectExtend:
2885  		case Message::HomeExtend: 
2886  			spCaret = SelectionPosition(
2887  				pdoc-&gt;LineStart(pdoc-&gt;LineFromPosition(spCaret.Position())));
2888  			break;
2889  		case Message::VCHomeRectExtend:
2890  		case Message::VCHomeExtend: 
2891  			spCaret = SelectionPosition(pdoc-&gt;VCHomePosition(spCaret.Position()));
2892  			break;
2893  		case Message::LineEndRectExtend:
2894  		case Message::LineEndExtend: 
2895  			spCaret = SelectionPosition(pdoc-&gt;LineEndPosition(spCaret.Position()));
2896  			break;
2897  		default:
2898  			break;
2899  		}
2900  		const int directionMove = (spCaret &lt; rangeBase.caret) ? -1 : 1;
2901  		spCaret = MovePositionSoVisible(spCaret, directionMove);
2902  		sel.selType = Selection::SelTypes::rectangle;
2903  		sel.Rectangular() = SelectionRange(spCaret, rangeBase.anchor);
2904  		SetRectangularRange();
2905  	} else if (sel.IsRectangular()) {
2906  		SelectionPosition selAtLimit = (NaturalDirection(iMessage) &gt; 0) ? sel.Limits().end : sel.Limits().start;
2907  		switch (iMessage) {
2908  		case Message::Home:
2909  			selAtLimit = SelectionPosition(
2910  				pdoc-&gt;LineStart(pdoc-&gt;LineFromPosition(selAtLimit.Position())));
2911  			break;
2912  		case Message::VCHome:
2913  			selAtLimit = SelectionPosition(pdoc-&gt;VCHomePosition(selAtLimit.Position()));
2914  			break;
2915  		case Message::LineEnd:
2916  			selAtLimit = SelectionPosition(pdoc-&gt;LineEndPosition(selAtLimit.Position()));
2917  			break;
2918  		default:
2919  			break;
2920  		}
2921  		sel.selType = Selection::SelTypes::stream;
2922  		sel.SetSelection(SelectionRange(selAtLimit));
2923  	} else {
2924  		if (!additionalSelectionTyping) {
2925  			InvalidateWholeSelection();
2926  			sel.DropAdditionalRanges();
2927  		}
2928  		for (size_t r = 0; r &lt; sel.Count(); r++) {
2929  			const SelectionPosition spCaretNow = sel.Range(r).caret;
2930  			SelectionPosition spCaret = spCaretNow;
2931  			switch (iMessage) {
2932  			case Message::CharLeft:
2933  			case Message::CharLeftExtend:
2934  				if (spCaret.VirtualSpace()) {
2935  					spCaret.SetVirtualSpace(spCaret.VirtualSpace() - 1);
2936  				} else if (!FlagSet(virtualSpaceOptions, VirtualSpace::NoWrapLineStart) || pdoc-&gt;GetColumn(spCaret.Position()) &gt; 0) {
2937  					spCaret = SelectionPosition(spCaret.Position() - 1);
2938  				}
2939  				break;
2940  			case Message::CharRight:
2941  			case Message::CharRightExtend:
2942  				if (FlagSet(virtualSpaceOptions, VirtualSpace::UserAccessible) &amp;&amp; pdoc-&gt;IsLineEndPosition(spCaret.Position())) {
2943  					spCaret.SetVirtualSpace(spCaret.VirtualSpace() + 1);
2944  				} else {
2945  					spCaret = SelectionPosition(spCaret.Position() + 1);
2946  				}
2947  				break;
2948  			case Message::WordLeft:
2949  			case Message::WordLeftExtend:
2950  				spCaret = SelectionPosition(pdoc-&gt;NextWordStart(spCaret.Position(), -1));
2951  				break;
2952  			case Message::WordRight:
2953  			case Message::WordRightExtend:
2954  				spCaret = SelectionPosition(pdoc-&gt;NextWordStart(spCaret.Position(), 1));
2955  				break;
2956  			case Message::WordLeftEnd:
2957  			case Message::WordLeftEndExtend:
2958  				spCaret = SelectionPosition(pdoc-&gt;NextWordEnd(spCaret.Position(), -1));
2959  				break;
2960  			case Message::WordRightEnd:
2961  			case Message::WordRightEndExtend:
2962  				spCaret = SelectionPosition(pdoc-&gt;NextWordEnd(spCaret.Position(), 1));
2963  				break;
2964  			case Message::WordPartLeft:
2965  			case Message::WordPartLeftExtend:
2966  				spCaret = SelectionPosition(pdoc-&gt;WordPartLeft(spCaret.Position()));
2967  				break;
2968  			case Message::WordPartRight:
2969  			case Message::WordPartRightExtend:
2970  				spCaret = SelectionPosition(pdoc-&gt;WordPartRight(spCaret.Position()));
2971  				break;
2972  			case Message::Home:
2973  			case Message::HomeExtend:
2974  				spCaret = SelectionPosition(
2975  					pdoc-&gt;LineStart(pdoc-&gt;LineFromPosition(spCaret.Position())));
2976  				break;
2977  			case Message::HomeDisplay:
2978  			case Message::HomeDisplayExtend:
2979  				spCaret = SelectionPosition(StartEndDisplayLine(spCaret.Position(), true));
2980  				break;
2981  			case Message::HomeWrap:
2982  			case Message::HomeWrapExtend:
2983  				spCaret = MovePositionSoVisible(StartEndDisplayLine(spCaret.Position(), true), -1);
2984  				if (spCaretNow &lt;= spCaret)
2985  					spCaret = SelectionPosition(
2986  						pdoc-&gt;LineStart(pdoc-&gt;LineFromPosition(spCaret.Position())));
2987  				break;
2988  			case Message::VCHome:
2989  			case Message::VCHomeExtend:
2990  				spCaret = SelectionPosition(pdoc-&gt;VCHomePosition(spCaret.Position()));
2991  				break;
2992  			case Message::VCHomeDisplay:
2993  			case Message::VCHomeDisplayExtend:
2994  				spCaret = SelectionPosition(VCHomeDisplayPosition(spCaret.Position()));
2995  				break;
2996  			case Message::VCHomeWrap:
2997  			case Message::VCHomeWrapExtend:
2998  				spCaret = SelectionPosition(VCHomeWrapPosition(spCaret.Position()));
2999  				break;
3000  			case Message::LineEnd:
3001  			case Message::LineEndExtend:
3002  				spCaret = SelectionPosition(pdoc-&gt;LineEndPosition(spCaret.Position()));
3003  				break;
3004  			case Message::LineEndDisplay:
3005  			case Message::LineEndDisplayExtend:
3006  				spCaret = SelectionPosition(StartEndDisplayLine(spCaret.Position(), false));
3007  				break;
3008  			case Message::LineEndWrap:
3009  			case Message::LineEndWrapExtend:
3010  				spCaret = SelectionPosition(LineEndWrapPosition(spCaret.Position()));
3011  				break;
3012  			default:
3013  				PLATFORM_ASSERT(false);
3014  			}
3015  			const int directionMove = (spCaret &lt; spCaretNow) ? -1 : 1;
3016  			spCaret = MovePositionSoVisible(spCaret, directionMove);
3017  			switch (iMessage) {
3018  			case Message::CharLeft:
3019  			case Message::CharRight:
3020  				if (sel.Range(r).Empty()) {
3021  					sel.Range(r) = SelectionRange(spCaret);
3022  				} else {
3023  					sel.Range(r) = SelectionRange(
3024  						(iMessage == Message::CharLeft) ? sel.Range(r).Start() : sel.Range(r).End());
3025  				}
3026  				break;
3027  			case Message::WordLeft:
3028  			case Message::WordRight:
3029  			case Message::WordLeftEnd:
3030  			case Message::WordRightEnd:
3031  			case Message::WordPartLeft:
3032  			case Message::WordPartRight:
3033  			case Message::Home:
3034  			case Message::HomeDisplay:
3035  			case Message::HomeWrap:
3036  			case Message::VCHome:
3037  			case Message::VCHomeDisplay:
3038  			case Message::VCHomeWrap:
3039  			case Message::LineEnd:
3040  			case Message::LineEndDisplay:
3041  			case Message::LineEndWrap:
3042  				sel.Range(r) = SelectionRange(spCaret);
3043  				break;
3044  			case Message::CharLeftExtend:
3045  			case Message::CharRightExtend:
3046  			case Message::WordLeftExtend:
3047  			case Message::WordRightExtend:
3048  			case Message::WordLeftEndExtend:
3049  			case Message::WordRightEndExtend:
3050  			case Message::WordPartLeftExtend:
3051  			case Message::WordPartRightExtend:
3052  			case Message::HomeExtend:
3053  			case Message::HomeDisplayExtend:
3054  			case Message::HomeWrapExtend:
3055  			case Message::VCHomeExtend:
3056  			case Message::VCHomeDisplayExtend:
3057  			case Message::VCHomeWrapExtend:
3058  			case Message::LineEndExtend:
3059  			case Message::LineEndDisplayExtend:
3060  			case Message::LineEndWrapExtend: {
3061  				SelectionRange rangeNew = SelectionRange(spCaret, sel.Range(r).anchor);
3062  				sel.TrimOtherSelections(r, SelectionRange(rangeNew));
3063  				sel.Range(r) = rangeNew;
3064  				}
3065  				break;
3066  			default:
3067  				PLATFORM_ASSERT(false);
3068  			}
3069  		}
3070  	}
3071  	sel.RemoveDuplicates();
3072  	MovedCaret(sel.RangeMain().caret, SelectionPosition(Sci::invalidPosition), true, caretPolicies);
3073  	InvalidateWholeSelection();
3074  	SetLastXChosen();
3075  	return 0;
3076  }
3077  int Editor::DelWordOrLine(Message iMessage) {
3078  	const bool leftwards = (iMessage == Message::DelWordLeft) || (iMessage == Message::DelLineLeft);
3079  	if (!additionalSelectionTyping) {
3080  		InvalidateWholeSelection();
3081  		sel.DropAdditionalRanges();
3082  	}
3083  	UndoGroup ug0(pdoc, (sel.Count() &gt; 1) || !leftwards);
3084  	for (size_t r = 0; r &lt; sel.Count(); r++) {
3085  		if (leftwards) {
3086  			sel.Range(r).ClearVirtualSpace();
3087  		} else {
3088  			sel.Range(r) = SelectionRange(
3089  				RealizeVirtualSpace(sel.Range(r).caret));
3090  		}
3091  		Range rangeDelete;
3092  		switch (iMessage) {
3093  		case Message::DelWordLeft:
3094  			rangeDelete = Range(
3095  				pdoc-&gt;NextWordStart(sel.Range(r).caret.Position(), -1),
3096  				sel.Range(r).caret.Position());
3097  			break;
3098  		case Message::DelWordRight:
3099  			rangeDelete = Range(
3100  				sel.Range(r).caret.Position(),
3101  				pdoc-&gt;NextWordStart(sel.Range(r).caret.Position(), 1));
3102  			break;
3103  		case Message::DelWordRightEnd:
3104  			rangeDelete = Range(
3105  				sel.Range(r).caret.Position(),
3106  				pdoc-&gt;NextWordEnd(sel.Range(r).caret.Position(), 1));
3107  			break;
3108  		case Message::DelLineLeft:
3109  			rangeDelete = Range(
3110  				pdoc-&gt;LineStart(pdoc-&gt;LineFromPosition(sel.Range(r).caret.Position())),
3111  				sel.Range(r).caret.Position());
3112  			break;
3113  		case Message::DelLineRight:
3114  			rangeDelete = Range(
3115  				sel.Range(r).caret.Position(),
3116  				pdoc-&gt;LineEnd(pdoc-&gt;LineFromPosition(sel.Range(r).caret.Position())));
3117  			break;
3118  		default:
3119  			break;
3120  		}
3121  		if (!RangeContainsProtected(rangeDelete.start, rangeDelete.end)) {
3122  			pdoc-&gt;DeleteChars(rangeDelete.start, rangeDelete.end - rangeDelete.start);
3123  		}
3124  	}
3125  	sel.RemoveDuplicates();
3126  	MovedCaret(sel.RangeMain().caret, SelectionPosition(Sci::invalidPosition), true, caretPolicies);
3127  	InvalidateWholeSelection();
3128  	SetLastXChosen();
3129  	return 0;
3130  }
3131  int Editor::KeyCommand(Message iMessage) {
3132  	switch (iMessage) {
3133  	case Message::LineDown:
3134  		CursorUpOrDown(1, Selection::SelTypes::none);
3135  		break;
3136  	case Message::LineDownExtend:
3137  		CursorUpOrDown(1, Selection::SelTypes::stream);
3138  		break;
3139  	case Message::LineDownRectExtend:
3140  		CursorUpOrDown(1, Selection::SelTypes::rectangle);
3141  		break;
3142  	case Message::ParaDown:
3143  		ParaUpOrDown(1, Selection::SelTypes::none);
3144  		break;
3145  	case Message::ParaDownExtend:
3146  		ParaUpOrDown(1, Selection::SelTypes::stream);
3147  		break;
3148  	case Message::LineScrollDown:
3149  		ScrollTo(topLine + 1);
3150  		MoveCaretInsideView(false);
3151  		break;
3152  	case Message::LineUp:
3153  		CursorUpOrDown(-1, Selection::SelTypes::none);
3154  		break;
3155  	case Message::LineUpExtend:
3156  		CursorUpOrDown(-1, Selection::SelTypes::stream);
3157  		break;
3158  	case Message::LineUpRectExtend:
3159  		CursorUpOrDown(-1, Selection::SelTypes::rectangle);
3160  		break;
3161  	case Message::ParaUp:
3162  		ParaUpOrDown(-1, Selection::SelTypes::none);
3163  		break;
3164  	case Message::ParaUpExtend:
3165  		ParaUpOrDown(-1, Selection::SelTypes::stream);
3166  		break;
3167  	case Message::LineScrollUp:
3168  		ScrollTo(topLine - 1);
3169  		MoveCaretInsideView(false);
3170  		break;
3171  	case Message::CharLeft:
3172  	case Message::CharLeftExtend:
3173  	case Message::CharLeftRectExtend:
3174  	case Message::CharRight:
3175  	case Message::CharRightExtend:
3176  	case Message::CharRightRectExtend:
3177  	case Message::WordLeft:
3178  	case Message::WordLeftExtend:
3179  	case Message::WordRight:
3180  	case Message::WordRightExtend:
3181  	case Message::WordLeftEnd:
3182  	case Message::WordLeftEndExtend:
3183  	case Message::WordRightEnd:
3184  	case Message::WordRightEndExtend:
3185  	case Message::WordPartLeft:
3186  	case Message::WordPartLeftExtend:
3187  	case Message::WordPartRight:
3188  	case Message::WordPartRightExtend:
3189  	case Message::Home:
3190  	case Message::HomeExtend:
3191  	case Message::HomeRectExtend:
3192  	case Message::HomeDisplay:
3193  	case Message::HomeDisplayExtend:
3194  	case Message::HomeWrap:
3195  	case Message::HomeWrapExtend:
3196  	case Message::VCHome:
3197  	case Message::VCHomeExtend:
3198  	case Message::VCHomeRectExtend:
3199  	case Message::VCHomeDisplay:
3200  	case Message::VCHomeDisplayExtend:
3201  	case Message::VCHomeWrap:
3202  	case Message::VCHomeWrapExtend:
3203  	case Message::LineEnd:
3204  	case Message::LineEndExtend:
3205  	case Message::LineEndRectExtend:
3206  	case Message::LineEndDisplay:
3207  	case Message::LineEndDisplayExtend:
3208  	case Message::LineEndWrap:
3209  	case Message::LineEndWrapExtend:
3210  		return HorizontalMove(iMessage);
3211  	case Message::DocumentStart:
3212  		MovePositionTo(0);
3213  		SetLastXChosen();
3214  		break;
3215  	case Message::DocumentStartExtend:
3216  		MovePositionTo(0, Selection::SelTypes::stream);
3217  		SetLastXChosen();
3218  		break;
3219  	case Message::DocumentEnd:
3220  		MovePositionTo(pdoc-&gt;Length());
3221  		SetLastXChosen();
3222  		break;
3223  	case Message::DocumentEndExtend:
3224  		MovePositionTo(pdoc-&gt;Length(), Selection::SelTypes::stream);
3225  		SetLastXChosen();
3226  		break;
3227  	case Message::StutteredPageUp:
3228  		PageMove(-1, Selection::SelTypes::none, true);
3229  		break;
3230  	case Message::StutteredPageUpExtend:
3231  		PageMove(-1, Selection::SelTypes::stream, true);
3232  		break;
3233  	case Message::StutteredPageDown:
3234  		PageMove(1, Selection::SelTypes::none, true);
3235  		break;
3236  	case Message::StutteredPageDownExtend:
3237  		PageMove(1, Selection::SelTypes::stream, true);
3238  		break;
3239  	case Message::PageUp:
3240  		PageMove(-1);
3241  		break;
3242  	case Message::PageUpExtend:
3243  		PageMove(-1, Selection::SelTypes::stream);
3244  		break;
3245  	case Message::PageUpRectExtend:
3246  		PageMove(-1, Selection::SelTypes::rectangle);
3247  		break;
3248  	case Message::PageDown:
3249  		PageMove(1);
3250  		break;
3251  	case Message::PageDownExtend:
3252  		PageMove(1, Selection::SelTypes::stream);
3253  		break;
3254  	case Message::PageDownRectExtend:
3255  		PageMove(1, Selection::SelTypes::rectangle);
3256  		break;
3257  	case Message::EditToggleOvertype:
3258  		inOverstrike = !inOverstrike;
3259  		ContainerNeedsUpdate(Update::Selection);
3260  		ShowCaretAtCurrentPosition();
3261  		SetIdle(true);
3262  		break;
3263  	case Message::Cancel:            	
3264  		CancelModes();
3265  		if ((sel.Count() &gt; 1) &amp;&amp; !sel.IsRectangular()) {
3266  			InvalidateWholeSelection();
3267  			sel.DropAdditionalRanges();
3268  		}
3269  		break;
3270  	case Message::DeleteBack:
3271  		DelCharBack(true);
3272  		if ((caretSticky == CaretSticky::Off) || (caretSticky == CaretSticky::WhiteSpace)) {
3273  			SetLastXChosen();
3274  		}
3275  		EnsureCaretVisible();
3276  		break;
3277  	case Message::DeleteBackNotLine:
3278  		DelCharBack(false);
3279  		if ((caretSticky == CaretSticky::Off) || (caretSticky == CaretSticky::WhiteSpace)) {
3280  			SetLastXChosen();
3281  		}
3282  		EnsureCaretVisible();
3283  		break;
3284  	case Message::Tab:
3285  		Indent(true);
3286  		if (caretSticky == CaretSticky::Off) {
3287  			SetLastXChosen();
3288  		}
3289  		EnsureCaretVisible();
3290  		ShowCaretAtCurrentPosition();		
3291  		break;
3292  	case Message::BackTab:
3293  		Indent(false);
3294  		if ((caretSticky == CaretSticky::Off) || (caretSticky == CaretSticky::WhiteSpace)) {
3295  			SetLastXChosen();
3296  		}
3297  		EnsureCaretVisible();
3298  		ShowCaretAtCurrentPosition();		
3299  		break;
3300  	case Message::NewLine:
3301  		NewLine();
3302  		break;
3303  	case Message::FormFeed:
3304  		AddChar(&#x27;\f&#x27;);
3305  		break;
3306  	case Message::ZoomIn:
3307  		if (vs.zoomLevel &lt; 20) {
3308  			vs.zoomLevel++;
3309  			InvalidateStyleRedraw();
3310  			NotifyZoom();
3311  		}
3312  		break;
3313  	case Message::ZoomOut:
3314  		if (vs.zoomLevel &gt; -10) {
3315  			vs.zoomLevel--;
3316  			InvalidateStyleRedraw();
3317  			NotifyZoom();
3318  		}
3319  		break;
3320  	case Message::DelWordLeft:
3321  	case Message::DelWordRight:
3322  	case Message::DelWordRightEnd:
3323  	case Message::DelLineLeft:
3324  	case Message::DelLineRight:
3325  		return DelWordOrLine(iMessage);
3326  	case Message::LineCopy: {
3327  			const Sci::Line lineStart = pdoc-&gt;SciLineFromPosition(SelectionStart().Position());
3328  			const Sci::Line lineEnd = pdoc-&gt;SciLineFromPosition(SelectionEnd().Position());
3329  			CopyRangeToClipboard(pdoc-&gt;LineStart(lineStart),
3330  				pdoc-&gt;LineStart(lineEnd + 1));
3331  		}
3332  		break;
3333  	case Message::LineCut: {
3334  			const Sci::Line lineStart = pdoc-&gt;SciLineFromPosition(SelectionStart().Position());
3335  			const Sci::Line lineEnd = pdoc-&gt;SciLineFromPosition(SelectionEnd().Position());
3336  			const Sci::Position start = pdoc-&gt;LineStart(lineStart);
3337  			const Sci::Position end = pdoc-&gt;LineStart(lineEnd + 1);
3338  			SetSelection(start, end);
3339  			Cut();
3340  			SetLastXChosen();
3341  		}
3342  		break;
3343  	case Message::LineDelete: {
3344  			const Sci::Line line = pdoc-&gt;SciLineFromPosition(sel.MainCaret());
3345  			const Sci::Position start = pdoc-&gt;LineStart(line);
3346  			const Sci::Position end = pdoc-&gt;LineStart(line + 1);
3347  			pdoc-&gt;DeleteChars(start, end - start);
3348  		}
3349  		break;
3350  	case Message::LineTranspose:
3351  		LineTranspose();
3352  		break;
3353  	case Message::LineReverse:
3354  		LineReverse();
3355  		break;
3356  	case Message::LineDuplicate:
3357  		Duplicate(true);
3358  		break;
3359  	case Message::SelectionDuplicate:
3360  		Duplicate(false);
3361  		break;
3362  	case Message::LowerCase:
3363  		ChangeCaseOfSelection(CaseMapping::lower);
3364  		break;
3365  	case Message::UpperCase:
3366  		ChangeCaseOfSelection(CaseMapping::upper);
3367  		break;
3368  	case Message::ScrollToStart:
3369  		ScrollTo(0);
3370  		break;
3371  	case Message::ScrollToEnd:
3372  		ScrollTo(MaxScrollPos());
3373  		break;
3374  	default:
3375  		break;
3376  	}
3377  	return 0;
3378  }
3379  int Editor::KeyDefault(Keys, KeyMod) {
3380  	return 0;
3381  }
3382  int Editor::KeyDownWithModifiers(Keys key, KeyMod modifiers, bool *consumed) {
3383  	DwellEnd(false);
3384  	const Message msg = kmap.Find(key, modifiers);
3385  	if (msg != static_cast&lt;Message&gt;(0)) {
3386  		if (consumed)
3387  			*consumed = true;
3388  		return static_cast&lt;int&gt;(WndProc(msg, 0, 0));
3389  	} else {
3390  		if (consumed)
3391  			*consumed = false;
3392  		return KeyDefault(key, modifiers);
3393  	}
3394  }
3395  void Editor::Indent(bool forwards) {
3396  	UndoGroup ug(pdoc);
3397  	for (size_t r=0; r&lt;sel.Count(); r++) {
3398  		const Sci::Line lineOfAnchor =
3399  			pdoc-&gt;SciLineFromPosition(sel.Range(r).anchor.Position());
3400  		Sci::Position caretPosition = sel.Range(r).caret.Position();
3401  		const Sci::Line lineCurrentPos = pdoc-&gt;SciLineFromPosition(caretPosition);
3402  		if (lineOfAnchor == lineCurrentPos) {
3403  			if (forwards) {
3404  				pdoc-&gt;DeleteChars(sel.Range(r).Start().Position(), sel.Range(r).Length());
3405  				caretPosition = sel.Range(r).caret.Position();
3406  				if (pdoc-&gt;GetColumn(caretPosition) &lt;= pdoc-&gt;GetColumn(pdoc-&gt;GetLineIndentPosition(lineCurrentPos)) &amp;&amp;
3407  						pdoc-&gt;tabIndents) {
3408  					const int indentation = pdoc-&gt;GetLineIndentation(lineCurrentPos);
3409  					const int indentationStep = pdoc-&gt;IndentSize();
3410  					const Sci::Position posSelect = pdoc-&gt;SetLineIndentation(
3411  						lineCurrentPos, indentation + indentationStep - indentation % indentationStep);
3412  					sel.Range(r) = SelectionRange(posSelect);
3413  				} else {
3414  					if (pdoc-&gt;useTabs) {
3415  						const Sci::Position lengthInserted = pdoc-&gt;InsertString(caretPosition, &quot;\t&quot;, 1);
3416  						sel.Range(r) = SelectionRange(caretPosition + lengthInserted);
3417  					} else {
3418  						int numSpaces = (pdoc-&gt;tabInChars) -
3419  								(pdoc-&gt;GetColumn(caretPosition) % (pdoc-&gt;tabInChars));
3420  						if (numSpaces &lt; 1)
3421  							numSpaces = pdoc-&gt;tabInChars;
3422  						const std::string spaceText(numSpaces, &#x27; &#x27;);
3423  						const Sci::Position lengthInserted = pdoc-&gt;InsertString(caretPosition, spaceText);
3424  						sel.Range(r) = SelectionRange(caretPosition + lengthInserted);
3425  					}
3426  				}
3427  			} else {
3428  				if (pdoc-&gt;GetColumn(caretPosition) &lt;= pdoc-&gt;GetLineIndentation(lineCurrentPos) &amp;&amp;
3429  						pdoc-&gt;tabIndents) {
3430  					const int indentation = pdoc-&gt;GetLineIndentation(lineCurrentPos);
3431  					const int indentationStep = pdoc-&gt;IndentSize();
3432  					const Sci::Position posSelect = pdoc-&gt;SetLineIndentation(lineCurrentPos, indentation - indentationStep);
3433  					sel.Range(r) = SelectionRange(posSelect);
3434  				} else {
3435  					Sci::Position newColumn = ((pdoc-&gt;GetColumn(caretPosition) - 1) / pdoc-&gt;tabInChars) *
3436  							pdoc-&gt;tabInChars;
3437  					if (newColumn &lt; 0)
3438  						newColumn = 0;
3439  					Sci::Position newPos = caretPosition;
3440  					while (pdoc-&gt;GetColumn(newPos) &gt; newColumn)
3441  						newPos--;
3442  					sel.Range(r) = SelectionRange(newPos);
3443  				}
3444  			}
3445  		} else {	
3446  			const Sci::Position anchorPosOnLine = sel.Range(r).anchor.Position() -
3447  				pdoc-&gt;LineStart(lineOfAnchor);
3448  			const Sci::Position currentPosPosOnLine = caretPosition -
3449  				pdoc-&gt;LineStart(lineCurrentPos);
3450  			const Sci::Line lineTopSel = std::min(lineOfAnchor, lineCurrentPos);
3451  			Sci::Line lineBottomSel = std::max(lineOfAnchor, lineCurrentPos);
3452  			if (pdoc-&gt;LineStart(lineBottomSel) == sel.Range(r).anchor.Position() || pdoc-&gt;LineStart(lineBottomSel) == caretPosition)
3453  				lineBottomSel--;  	
3454  			pdoc-&gt;Indent(forwards, lineBottomSel, lineTopSel);
3455  			if (lineOfAnchor &lt; lineCurrentPos) {
3456  				if (currentPosPosOnLine == 0)
3457  					sel.Range(r) = SelectionRange(pdoc-&gt;LineStart(lineCurrentPos),
3458  						pdoc-&gt;LineStart(lineOfAnchor));
3459  				else
3460  					sel.Range(r) = SelectionRange(pdoc-&gt;LineStart(lineCurrentPos + 1),
3461  						pdoc-&gt;LineStart(lineOfAnchor));
3462  			} else {
3463  				if (anchorPosOnLine == 0)
3464  					sel.Range(r) = SelectionRange(pdoc-&gt;LineStart(lineCurrentPos),
3465  						pdoc-&gt;LineStart(lineOfAnchor));
3466  				else
3467  					sel.Range(r) = SelectionRange(pdoc-&gt;LineStart(lineCurrentPos),
3468  						pdoc-&gt;LineStart(lineOfAnchor + 1));
3469  			}
3470  		}
3471  	}
3472  	ContainerNeedsUpdate(Update::Selection);
3473  }
3474  std::unique_ptr&lt;CaseFolder&gt; Editor::CaseFolderForEncoding() {
3475  	return std::make_unique&lt;CaseFolderTable&gt;();
3476  }
3477  Sci::Position Editor::FindText(
3478      uptr_t wParam,		
3479      sptr_t lParam) {	
3480  	TextToFind *ft = static_cast&lt;TextToFind *&gt;(PtrFromSPtr(lParam));
3481  	Sci::Position lengthFound = strlen(ft-&gt;lpstrText);
3482  	if (!pdoc-&gt;HasCaseFolder())
3483  		pdoc-&gt;SetCaseFolder(CaseFolderForEncoding());
3484  	try {
3485  		const Sci::Position pos = pdoc-&gt;FindText(
3486  			static_cast&lt;Sci::Position&gt;(ft-&gt;chrg.cpMin),
3487  			static_cast&lt;Sci::Position&gt;(ft-&gt;chrg.cpMax),
3488  			ft-&gt;lpstrText,
3489  			static_cast&lt;FindOption&gt;(wParam),
3490  			&amp;lengthFound);
3491  		if (pos != -1) {
3492  			ft-&gt;chrgText.cpMin = static_cast&lt;Sci_PositionCR&gt;(pos);
3493  			ft-&gt;chrgText.cpMax = static_cast&lt;Sci_PositionCR&gt;(pos + lengthFound);
3494  		}
3495  		return pos;
3496  	} catch (RegexError &amp;) {
3497  		errorStatus = Status::RegEx;
3498  		return -1;
3499  	}
3500  }
3501  Sci::Position Editor::FindTextFull(
3502      uptr_t wParam,		
3503      sptr_t lParam) {	
3504  	TextToFindFull *ft = static_cast&lt;TextToFindFull *&gt;(PtrFromSPtr(lParam));
3505  	Sci::Position lengthFound = strlen(ft-&gt;lpstrText);
3506  	if (!pdoc-&gt;HasCaseFolder())
3507  		pdoc-&gt;SetCaseFolder(CaseFolderForEncoding());
3508  	try {
3509  		const Sci::Position pos = pdoc-&gt;FindText(
3510  			ft-&gt;chrg.cpMin,
3511  			ft-&gt;chrg.cpMax,
3512  			ft-&gt;lpstrText,
3513  			static_cast&lt;FindOption&gt;(wParam),
3514  			&amp;lengthFound);
3515  		if (pos != -1) {
3516  			ft-&gt;chrgText.cpMin = pos;
3517  			ft-&gt;chrgText.cpMax = pos + lengthFound;
3518  		}
3519  		return pos;
3520  	} catch (RegexError &amp;) {
3521  		errorStatus = Status::RegEx;
3522  		return -1;
3523  	}
3524  }
3525  void Editor::SearchAnchor() noexcept {
3526  	searchAnchor = SelectionStart().Position();
3527  }
3528  Sci::Position Editor::SearchText(
3529      Message iMessage,		
3530      uptr_t wParam,				
3531      sptr_t lParam) {			
3532  	const char *txt = ConstCharPtrFromSPtr(lParam);
3533  	Sci::Position pos = Sci::invalidPosition;
3534  	Sci::Position lengthFound = strlen(txt);
3535  	if (!pdoc-&gt;HasCaseFolder())
3536  		pdoc-&gt;SetCaseFolder(CaseFolderForEncoding());
3537  	try {
3538  		if (iMessage == Message::SearchNext) {
3539  			pos = pdoc-&gt;FindText(searchAnchor, pdoc-&gt;Length(), txt,
3540  					static_cast&lt;FindOption&gt;(wParam),
3541  					&amp;lengthFound);
3542  		} else {
3543  			pos = pdoc-&gt;FindText(searchAnchor, 0, txt,
3544  					static_cast&lt;FindOption&gt;(wParam),
3545  					&amp;lengthFound);
3546  		}
3547  	} catch (RegexError &amp;) {
3548  		errorStatus = Status::RegEx;
3549  		return Sci::invalidPosition;
3550  	}
3551  	if (pos != Sci::invalidPosition) {
3552  		SetSelection(pos, pos + lengthFound);
3553  	}
3554  	return pos;
3555  }
3556  std::string Editor::CaseMapString(const std::string &amp;s, CaseMapping caseMapping) {
3557  	std::string ret(s);
3558  	for (char &amp;ch : ret) {
3559  		switch (caseMapping) {
3560  			case CaseMapping::upper:
3561  				ch = MakeUpperCase(ch);
3562  				break;
3563  			case CaseMapping::lower:
3564  				ch = MakeLowerCase(ch);
3565  				break;
3566  			default:	
3567  				break;
3568  		}
3569  	}
3570  	return ret;
3571  }
3572  Sci::Position Editor::SearchInTarget(const char *text, Sci::Position length) {
3573  	Sci::Position lengthFound = length;
3574  	if (!pdoc-&gt;HasCaseFolder())
3575  		pdoc-&gt;SetCaseFolder(CaseFolderForEncoding());
3576  	try {
3577  		const Sci::Position pos = pdoc-&gt;FindText(targetRange.start.Position(), targetRange.end.Position(), text,
3578  				searchFlags,
3579  				&amp;lengthFound);
3580  		if (pos != -1) {
3581  			targetRange.start.SetPosition(pos);
3582  			targetRange.end.SetPosition(pos + lengthFound);
3583  		}
3584  		return pos;
3585  	} catch (RegexError &amp;) {
3586  		errorStatus = Status::RegEx;
3587  		return -1;
3588  	}
3589  }
3590  void Editor::GoToLine(Sci::Line lineNo) {
3591  	if (lineNo &gt; pdoc-&gt;LinesTotal())
3592  		lineNo = pdoc-&gt;LinesTotal();
3593  	if (lineNo &lt; 0)
3594  		lineNo = 0;
3595  	SetEmptySelection(pdoc-&gt;LineStart(lineNo));
3596  	ShowCaretAtCurrentPosition();
3597  	EnsureCaretVisible();
3598  }
3599  static bool Close(Point pt1, Point pt2, Point threshold) noexcept {
3600  	const Point ptDifference = pt2 - pt1;
3601  	if (std::abs(ptDifference.x) &gt; threshold.x)
3602  		return false;
3603  	if (std::abs(ptDifference.y) &gt; threshold.y)
3604  		return false;
3605  	return true;
3606  }
3607  std::string Editor::RangeText(Sci::Position start, Sci::Position end) const {
3608  	if (start &lt; end) {
3609  		const Sci::Position len = end - start;
3610  		std::string ret(len, &#x27;\0&#x27;);
3611  		pdoc-&gt;GetCharRange(ret.data(), start, len);
3612  		return ret;
3613  	}
3614  	return std::string();
3615  }
3616  void Editor::CopySelectionRange(SelectionText *ss, bool allowLineCopy) {
3617  	if (sel.Empty()) {
3618  		if (allowLineCopy) {
3619  			const Sci::Line currentLine = pdoc-&gt;SciLineFromPosition(sel.MainCaret());
3620  			const Sci::Position start = pdoc-&gt;LineStart(currentLine);
3621  			const Sci::Position end = pdoc-&gt;LineEnd(currentLine);
3622  			std::string text = RangeText(start, end);
3623  			if (pdoc-&gt;eolMode != EndOfLine::Lf)
3624  				text.push_back(&#x27;\r&#x27;);
3625  			if (pdoc-&gt;eolMode != EndOfLine::Cr)
3626  				text.push_back(&#x27;\n&#x27;);
3627  			ss-&gt;Copy(text, pdoc-&gt;dbcsCodePage,
3628  				vs.styles[StyleDefault].characterSet, false, true);
3629  		}
3630  	} else {
3631  		std::string text;
3632  		std::vector&lt;SelectionRange&gt; rangesInOrder = sel.RangesCopy();
3633  		if (sel.selType == Selection::SelTypes::rectangle)
3634  			std::sort(rangesInOrder.begin(), rangesInOrder.end());
3635  		for (const SelectionRange &amp;current : rangesInOrder) {
3636  				text.append(RangeText(current.Start().Position(), current.End().Position()));
3637  			if (sel.selType == Selection::SelTypes::rectangle) {
3638  				if (pdoc-&gt;eolMode != EndOfLine::Lf)
3639  					text.push_back(&#x27;\r&#x27;);
3640  				if (pdoc-&gt;eolMode != EndOfLine::Cr)
3641  					text.push_back(&#x27;\n&#x27;);
3642  			}
3643  		}
3644  		ss-&gt;Copy(text, pdoc-&gt;dbcsCodePage,
3645  			vs.styles[StyleDefault].characterSet, sel.IsRectangular(), sel.selType == Selection::SelTypes::lines);
3646  	}
3647  }
3648  void Editor::CopyRangeToClipboard(Sci::Position start, Sci::Position end) {
3649  	start = pdoc-&gt;ClampPositionIntoDocument(start);
3650  	end = pdoc-&gt;ClampPositionIntoDocument(end);
3651  	SelectionText selectedText;
3652  	std::string text = RangeText(start, end);
3653  	selectedText.Copy(text,
3654  		pdoc-&gt;dbcsCodePage, vs.styles[StyleDefault].characterSet, false, false);
3655  	CopyToClipboard(selectedText);
3656  }
3657  void Editor::CopyText(size_t length, const char *text) {
3658  	SelectionText selectedText;
3659  	selectedText.Copy(std::string(text, length),
3660  		pdoc-&gt;dbcsCodePage, vs.styles[StyleDefault].characterSet, false, false);
3661  	CopyToClipboard(selectedText);
3662  }
3663  void Editor::SetDragPosition(SelectionPosition newPos) {
3664  	if (newPos.Position() &gt;= 0) {
3665  		newPos = MovePositionOutsideChar(newPos, 1);
3666  		posDrop = newPos;
3667  	}
3668  	if (!(posDrag == newPos)) {
3669  		const CaretPolicies dragCaretPolicies = {
3670  			CaretPolicySlop(CaretPolicy::Slop | CaretPolicy::Strict | CaretPolicy::Even, 50),
3671  			CaretPolicySlop(CaretPolicy::Slop | CaretPolicy::Strict | CaretPolicy::Even, 2)
3672  		};
3673  		MovedCaret(newPos, posDrag, true, dragCaretPolicies);
3674  		caret.on = true;
3675  		FineTickerCancel(TickReason::caret);
3676  		if ((caret.active) &amp;&amp; (caret.period &gt; 0) &amp;&amp; (newPos.Position() &lt; 0))
3677  			FineTickerStart(TickReason::caret, caret.period, caret.period/10);
3678  		InvalidateCaret();
3679  		posDrag = newPos;
3680  		InvalidateCaret();
3681  	}
3682  }
3683  void Editor::DisplayCursor(Window::Cursor c) {
3684  	if (cursorMode == CursorShape::Normal)
3685  		wMain.SetCursor(c);
3686  	else
3687  		wMain.SetCursor(static_cast&lt;Window::Cursor&gt;(cursorMode));
3688  }
3689  bool Editor::DragThreshold(Point ptStart, Point ptNow) {
3690  	const Point ptDiff = ptStart - ptNow;
3691  	const XYPOSITION distanceSquared = ptDiff.x * ptDiff.x + ptDiff.y * ptDiff.y;
3692  	return distanceSquared &gt; 16.0f;
3693  }
3694  void Editor::StartDrag() {
3695  }
3696  void Editor::DropAt(SelectionPosition position, const char *value, size_t lengthValue, bool moving, bool rectangular) {
3697  	if (inDragDrop == DragDrop::dragging)
3698  		dropWentOutside = false;
3699  	const bool positionWasInSelection = PositionInSelection(position.Position());
3700  	const bool positionOnEdgeOfSelection =
3701  	    (position == SelectionStart()) || (position == SelectionEnd());
3702  	if ((inDragDrop != DragDrop::dragging) || !(positionWasInSelection) ||
3703  	        (positionOnEdgeOfSelection &amp;&amp; !moving)) {
3704  		const SelectionPosition selStart = SelectionStart();
3705  		const SelectionPosition selEnd = SelectionEnd();
3706  		UndoGroup ug(pdoc);
3707  		SelectionPosition positionAfterDeletion = position;
3708  		if ((inDragDrop == DragDrop::dragging) &amp;&amp; moving) {
3709  			if (rectangular || sel.selType == Selection::SelTypes::lines) {
3710  				for (size_t r=0; r&lt;sel.Count(); r++) {
3711  					if (position &gt;= sel.Range(r).Start()) {
3712  						if (position &gt; sel.Range(r).End()) {
3713  							positionAfterDeletion.Add(-sel.Range(r).Length());
3714  						} else {
3715  							positionAfterDeletion.Add(-SelectionRange(position, sel.Range(r).Start()).Length());
3716  						}
3717  					}
3718  				}
3719  			} else {
3720  				if (position &gt; selStart) {
3721  					positionAfterDeletion.Add(-SelectionRange(selEnd, selStart).Length());
3722  				}
3723  			}
3724  			ClearSelection();
3725  		}
3726  		position = positionAfterDeletion;
3727  		std::string convertedText = Document::TransformLineEnds(value, lengthValue, pdoc-&gt;eolMode);
3728  		if (rectangular) {
3729  			PasteRectangular(position, convertedText.c_str(), convertedText.length());
3730  			SetEmptySelection(position);
3731  		} else {
3732  			position = MovePositionOutsideChar(position, sel.MainCaret() - position.Position());
3733  			position = RealizeVirtualSpace(position);
3734  			const Sci::Position lengthInserted = pdoc-&gt;InsertString(
3735  				position.Position(), convertedText);
3736  			if (lengthInserted &gt; 0) {
3737  				SelectionPosition posAfterInsertion = position;
3738  				posAfterInsertion.Add(lengthInserted);
3739  				SetSelection(posAfterInsertion, position);
3740  			}
3741  		}
3742  	} else if (inDragDrop == DragDrop::dragging) {
3743  		SetEmptySelection(position);
3744  	}
3745  }
3746  void Editor::DropAt(SelectionPosition position, const char *value, bool moving, bool rectangular) {
3747  	DropAt(position, value, strlen(value), moving, rectangular);
3748  }
3749  bool Editor::PositionInSelection(Sci::Position pos) {
3750  	pos = MovePositionOutsideChar(pos, sel.MainCaret() - pos);
3751  	for (size_t r=0; r&lt;sel.Count(); r++) {
3752  		if (sel.Range(r).Contains(pos))
3753  			return true;
3754  	}
3755  	return false;
3756  }
3757  bool Editor::PointInSelection(Point pt) {
3758  	const SelectionPosition pos = SPositionFromLocation(pt, false, true);
3759  	const Point ptPos = LocationFromPosition(pos);
3760  	for (size_t r=0; r&lt;sel.Count(); r++) {
3761  		const SelectionRange &amp;range = sel.Range(r);
3762  		if (range.Contains(pos)) {
3763  			bool hit = true;
3764  			if (pos == range.Start()) {
3765  				if (pt.x &lt; ptPos.x) {
3766  					hit = false;
3767  				}
3768  			}
3769  			if (pos == range.End()) {
3770  				if (pt.x &gt; ptPos.x) {
3771  					hit = false;
3772  				}
3773  			}
3774  			if (hit)
3775  				return true;
3776  		}
3777  	}
3778  	return false;
3779  }
3780  bool Editor::PointInSelMargin(Point pt) const {
3781  	if (vs.fixedColumnWidth &gt; 0) {	
3782  		PRectangle rcSelMargin = GetClientRectangle();
3783  		rcSelMargin.right = static_cast&lt;XYPOSITION&gt;(vs.textStart - vs.leftMarginWidth);
3784  		rcSelMargin.left = static_cast&lt;XYPOSITION&gt;(vs.textStart - vs.fixedColumnWidth);
3785  		const Point ptOrigin = GetVisibleOriginInMain();
3786  		rcSelMargin.Move(0, -ptOrigin.y);
3787  		return rcSelMargin.ContainsWholePixel(pt);
3788  	} else {
3789  		return false;
3790  	}
3791  }
3792  Window::Cursor Editor::GetMarginCursor(Point pt) const noexcept {
3793  	int x = 0;
3794  	for (const MarginStyle &amp;m : vs.ms) {
3795  		if ((pt.x &gt;= x) &amp;&amp; (pt.x &lt; x + m.width))
3796  			return static_cast&lt;Window::Cursor&gt;(m.cursor);
3797  		x += m.width;
3798  	}
3799  	return Window::Cursor::reverseArrow;
3800  }
3801  void Editor::TrimAndSetSelection(Sci::Position currentPos_, Sci::Position anchor_) {
3802  	sel.TrimSelection(SelectionRange(currentPos_, anchor_));
3803  	SetSelection(currentPos_, anchor_);
3804  }
3805  void Editor::LineSelection(Sci::Position lineCurrentPos_, Sci::Position lineAnchorPos_, bool wholeLine) {
3806  	Sci::Position selCurrentPos;
3807  	Sci::Position selAnchorPos;
3808  	if (wholeLine) {
3809  		const Sci::Line lineCurrent_ = pdoc-&gt;SciLineFromPosition(lineCurrentPos_);
3810  		const Sci::Line lineAnchor_ = pdoc-&gt;SciLineFromPosition(lineAnchorPos_);
3811  		if (lineAnchorPos_ &lt; lineCurrentPos_) {
3812  			selCurrentPos = pdoc-&gt;LineStart(lineCurrent_ + 1);
3813  			selAnchorPos = pdoc-&gt;LineStart(lineAnchor_);
3814  		} else if (lineAnchorPos_ &gt; lineCurrentPos_) {
3815  			selCurrentPos = pdoc-&gt;LineStart(lineCurrent_);
3816  			selAnchorPos = pdoc-&gt;LineStart(lineAnchor_ + 1);
3817  		} else { 
3818  			selCurrentPos = pdoc-&gt;LineStart(lineAnchor_ + 1);
3819  			selAnchorPos = pdoc-&gt;LineStart(lineAnchor_);
3820  		}
3821  	} else {
3822  		if (lineAnchorPos_ &lt; lineCurrentPos_) {
3823  			selCurrentPos = StartEndDisplayLine(lineCurrentPos_, false) + 1;
3824  			selCurrentPos = pdoc-&gt;MovePositionOutsideChar(selCurrentPos, 1);
3825  			selAnchorPos = StartEndDisplayLine(lineAnchorPos_, true);
3826  		} else if (lineAnchorPos_ &gt; lineCurrentPos_) {
3827  			selCurrentPos = StartEndDisplayLine(lineCurrentPos_, true);
3828  			selAnchorPos = StartEndDisplayLine(lineAnchorPos_, false) + 1;
3829  			selAnchorPos = pdoc-&gt;MovePositionOutsideChar(selAnchorPos, 1);
3830  		} else { 
3831  			selCurrentPos = StartEndDisplayLine(lineAnchorPos_, false) + 1;
3832  			selCurrentPos = pdoc-&gt;MovePositionOutsideChar(selCurrentPos, 1);
3833  			selAnchorPos = StartEndDisplayLine(lineAnchorPos_, true);
3834  		}
3835  	}
3836  	TrimAndSetSelection(selCurrentPos, selAnchorPos);
3837  }
3838  void Editor::WordSelection(Sci::Position pos) {
3839  	if (pos &lt; wordSelectAnchorStartPos) {
3840  		if (!pdoc-&gt;IsLineEndPosition(pos))
3841  			pos = pdoc-&gt;ExtendWordSelect(pdoc-&gt;MovePositionOutsideChar(pos + 1, 1), -1);
3842  		TrimAndSetSelection(pos, wordSelectAnchorEndPos);
3843  	} else if (pos &gt; wordSelectAnchorEndPos) {
3844  		if (pos &gt; pdoc-&gt;LineStart(pdoc-&gt;LineFromPosition(pos)))
3845  			pos = pdoc-&gt;ExtendWordSelect(pdoc-&gt;MovePositionOutsideChar(pos - 1, -1), 1);
3846  		TrimAndSetSelection(pos, wordSelectAnchorStartPos);
3847  	} else {
3848  		if (pos &gt;= originalAnchorPos)
3849  			TrimAndSetSelection(wordSelectAnchorEndPos, wordSelectAnchorStartPos);
3850  		else
3851  			TrimAndSetSelection(wordSelectAnchorStartPos, wordSelectAnchorEndPos);
3852  	}
3853  }
3854  void Editor::DwellEnd(bool mouseMoved) {
3855  	if (mouseMoved)
3856  		ticksToDwell = dwellDelay;
3857  	else
3858  		ticksToDwell = TimeForever;
3859  	if (dwelling &amp;&amp; (dwellDelay &lt; TimeForever)) {
3860  		dwelling = false;
3861  		NotifyDwelling(ptMouseLast, dwelling);
3862  	}
3863  	FineTickerCancel(TickReason::dwell);
3864  }
3865  void Editor::MouseLeave() {
3866  	SetHotSpotRange(nullptr);
3867  	SetHoverIndicatorPosition(Sci::invalidPosition);
3868  	if (!HaveMouseCapture()) {
3869  		ptMouseLast = Point(-1, -1);
3870  		DwellEnd(true);
3871  	}
3872  }
3873  static constexpr bool AllowVirtualSpace(VirtualSpace virtualSpaceOptions, bool rectangular) noexcept {
3874  	return (!rectangular &amp;&amp; (FlagSet(virtualSpaceOptions, VirtualSpace::UserAccessible)))
3875  		|| (rectangular &amp;&amp; (FlagSet(virtualSpaceOptions, VirtualSpace::RectangularSelection)));
3876  }
3877  void Editor::ButtonDownWithModifiers(Point pt, unsigned int curTime, KeyMod modifiers) {
3878  	SetHoverIndicatorPoint(pt);
3879  	ptMouseLast = pt;
3880  	const bool ctrl = FlagSet(modifiers, KeyMod::Ctrl);
3881  	const bool shift = FlagSet(modifiers, KeyMod::Shift);
3882  	const bool alt = FlagSet(modifiers, KeyMod::Alt);
3883  	SelectionPosition newPos = SPositionFromLocation(pt, false, false, AllowVirtualSpace(virtualSpaceOptions, alt));
3884  	newPos = MovePositionOutsideChar(newPos, sel.MainCaret() - newPos.Position());
3885  	SelectionPosition newCharPos = SPositionFromLocation(pt, false, true, false);
3886  	newCharPos = MovePositionOutsideChar(newCharPos, -1);
3887  	inDragDrop = DragDrop::none;
3888  	sel.SetMoveExtends(false);
3889  	if (NotifyMarginClick(pt, modifiers))
3890  		return;
3891  	NotifyIndicatorClick(true, newPos.Position(), modifiers);
3892  	const bool inSelMargin = PointInSelMargin(pt);
3893  	if (ctrl &amp;&amp; inSelMargin) {
3894  		SelectAll();
3895  		lastClickTime = curTime;
3896  		lastClick = pt;
3897  		return;
3898  	}
3899  	if (shift &amp;&amp; !inSelMargin) {
3900  		SetSelection(newPos);
3901  	}
3902  	if ((curTime &lt; (lastClickTime+Platform::DoubleClickTime())) &amp;&amp; Close(pt, lastClick, doubleClickCloseThreshold)) {
3903  		SetMouseCapture(true);
3904  		FineTickerStart(TickReason::scroll, 100, 10);
3905  		if (!ctrl || !multipleSelection || (selectionUnit != TextUnit::character &amp;&amp; selectionUnit != TextUnit::word))
3906  			SetEmptySelection(newPos.Position());
3907  		bool doubleClick = false;
3908  		if (inSelMargin) {
3909  			if (selectionUnit == TextUnit::subLine) {
3910  				selectionUnit = TextUnit::wholeLine;
3911  			} else if (selectionUnit != TextUnit::subLine &amp;&amp; selectionUnit != TextUnit::wholeLine) {
3912  				selectionUnit = (Wrapping() &amp;&amp; (FlagSet(marginOptions, MarginOption::SubLineSelect))) ? TextUnit::subLine : TextUnit::wholeLine;
3913  			}
3914  		} else {
3915  			if (selectionUnit == TextUnit::character) {
3916  				selectionUnit = TextUnit::word;
3917  				doubleClick = true;
3918  			} else if (selectionUnit == TextUnit::word) {
3919  				selectionUnit = TextUnit::wholeLine;
3920  			} else {
3921  				selectionUnit = TextUnit::character;
3922  				originalAnchorPos = sel.MainCaret();
3923  			}
3924  		}
3925  		if (selectionUnit == TextUnit::word) {
3926  			Sci::Position charPos = originalAnchorPos;
3927  			if (sel.MainCaret() == originalAnchorPos) {
3928  				charPos = PositionFromLocation(pt, false, true);
3929  				charPos = MovePositionOutsideChar(charPos, -1);
3930  			}
3931  			Sci::Position startWord;
3932  			Sci::Position endWord;
3933  			if ((sel.MainCaret() &gt;= originalAnchorPos) &amp;&amp; !pdoc-&gt;IsLineEndPosition(charPos)) {
3934  				startWord = pdoc-&gt;ExtendWordSelect(pdoc-&gt;MovePositionOutsideChar(charPos + 1, 1), -1);
3935  				endWord = pdoc-&gt;ExtendWordSelect(charPos, 1);
3936  			} else {
3937  				if (charPos &gt; pdoc-&gt;LineStart(pdoc-&gt;LineFromPosition(charPos))) {
3938  					startWord = pdoc-&gt;ExtendWordSelect(charPos, -1);
3939  					endWord = pdoc-&gt;ExtendWordSelect(startWord, 1);
3940  				} else {
3941  					startWord = charPos;
3942  					endWord = charPos;
3943  				}
3944  			}
3945  			wordSelectAnchorStartPos = startWord;
3946  			wordSelectAnchorEndPos = endWord;
3947  			wordSelectInitialCaretPos = sel.MainCaret();
3948  			WordSelection(wordSelectInitialCaretPos);
3949  		} else if (selectionUnit == TextUnit::subLine || selectionUnit == TextUnit::wholeLine) {
3950  			lineAnchorPos = newPos.Position();
3951  			LineSelection(lineAnchorPos, lineAnchorPos, selectionUnit == TextUnit::wholeLine);
3952  		} else {
3953  			SetEmptySelection(sel.MainCaret());
3954  		}
3955  		if (doubleClick) {
3956  			NotifyDoubleClick(pt, modifiers);
3957  			if (PositionIsHotspot(newCharPos.Position()))
3958  				NotifyHotSpotDoubleClicked(newCharPos.Position(), modifiers);
3959  		}
3960  	} else {	
3961  		if (inSelMargin) {
3962  			if (sel.IsRectangular() || (sel.Count() &gt; 1)) {
3963  				InvalidateWholeSelection();
3964  				sel.Clear();
3965  			}
3966  			sel.selType = Selection::SelTypes::stream;
3967  			if (!shift) {
3968  				lineAnchorPos = newPos.Position();
3969  				selectionUnit = (Wrapping() &amp;&amp; (FlagSet(marginOptions, MarginOption::SubLineSelect))) ? TextUnit::subLine : TextUnit::wholeLine;
3970  				LineSelection(lineAnchorPos, lineAnchorPos, selectionUnit == TextUnit::wholeLine);
3971  			} else {
3972  				if (sel.MainAnchor() &gt; sel.MainCaret())
3973  					lineAnchorPos = sel.MainAnchor() - 1;
3974  				else
3975  					lineAnchorPos = sel.MainAnchor();
3976  				if (sel.Empty() || (selectionUnit != TextUnit::subLine &amp;&amp; selectionUnit != TextUnit::wholeLine))
3977  					selectionUnit = (Wrapping() &amp;&amp; (FlagSet(marginOptions, MarginOption::SubLineSelect))) ? TextUnit::subLine : TextUnit::wholeLine;
3978  				LineSelection(newPos.Position(), lineAnchorPos, selectionUnit == TextUnit::wholeLine);
3979  			}
3980  			SetDragPosition(SelectionPosition(Sci::invalidPosition));
3981  			SetMouseCapture(true);
3982  			FineTickerStart(TickReason::scroll, 100, 10);
3983  		} else {
3984  			if (PointIsHotspot(pt)) {
3985  				NotifyHotSpotClicked(newCharPos.Position(), modifiers);
3986  				hotSpotClickPos = newCharPos.Position();
3987  			}
3988  			if (!shift) {
3989  				if (PointInSelection(pt) &amp;&amp; !SelectionEmpty())
3990  					inDragDrop = DragDrop::initial;
3991  				else
3992  					inDragDrop = DragDrop::none;
3993  			}
3994  			SetMouseCapture(true);
3995  			FineTickerStart(TickReason::scroll, 100, 10);
3996  			if (inDragDrop != DragDrop::initial) {
3997  				SetDragPosition(SelectionPosition(Sci::invalidPosition));
3998  				if (!shift) {
3999  					if (ctrl &amp;&amp; multipleSelection) {
4000  						const SelectionRange range(newPos);
4001  						sel.TentativeSelection(range);
4002  						InvalidateSelection(range, true);
4003  					} else {
4004  						InvalidateSelection(SelectionRange(newPos), true);
4005  						if (sel.Count() &gt; 1)
4006  							Redraw();
4007  						if ((sel.Count() &gt; 1) || (sel.selType != Selection::SelTypes::stream))
4008  							sel.Clear();
4009  						sel.selType = alt ? Selection::SelTypes::rectangle : Selection::SelTypes::stream;
4010  						SetSelection(newPos, newPos);
4011  					}
4012  				}
4013  				SelectionPosition anchorCurrent = newPos;
4014  				if (shift)
4015  					anchorCurrent = sel.IsRectangular() ?
4016  						sel.Rectangular().anchor : sel.RangeMain().anchor;
4017  				sel.selType = alt ? Selection::SelTypes::rectangle : Selection::SelTypes::stream;
4018  				selectionUnit = TextUnit::character;
4019  				originalAnchorPos = sel.MainCaret();
4020  				sel.Rectangular() = SelectionRange(newPos, anchorCurrent);
4021  				SetRectangularRange();
4022  			}
4023  		}
4024  	}
4025  	lastClickTime = curTime;
4026  	lastClick = pt;
4027  	lastXChosen = static_cast&lt;int&gt;(pt.x) + xOffset;
4028  	ShowCaretAtCurrentPosition();
4029  }
4030  void Editor::RightButtonDownWithModifiers(Point pt, unsigned int, KeyMod modifiers) {
4031  	if (NotifyMarginRightClick(pt, modifiers))
4032  		return;
4033  }
4034  bool Editor::PositionIsHotspot(Sci::Position position) const noexcept {
4035  	return vs.styles[pdoc-&gt;StyleIndexAt(position)].hotspot;
4036  }
4037  bool Editor::PointIsHotspot(Point pt) {
4038  	const Sci::Position pos = PositionFromLocation(pt, true, true);
4039  	if (pos == Sci::invalidPosition)
4040  		return false;
4041  	return PositionIsHotspot(pos);
4042  }
4043  void Editor::SetHoverIndicatorPosition(Sci::Position position) {
4044  	const Sci::Position hoverIndicatorPosPrev = hoverIndicatorPos;
4045  	hoverIndicatorPos = Sci::invalidPosition;
4046  	if (!vs.indicatorsDynamic)
4047  		return;
4048  	if (position != Sci::invalidPosition) {
4049  		for (const IDecoration *deco : pdoc-&gt;decorations-&gt;View()) {
4050  			if (vs.indicators[deco-&gt;Indicator()].IsDynamic()) {
4051  				if (pdoc-&gt;decorations-&gt;ValueAt(deco-&gt;Indicator(), position)) {
4052  					hoverIndicatorPos = position;
4053  				}
4054  			}
4055  		}
4056  	}
4057  	if (hoverIndicatorPosPrev != hoverIndicatorPos) {
4058  		Redraw();
4059  	}
4060  }
4061  void Editor::SetHoverIndicatorPoint(Point pt) {
4062  	if (!vs.indicatorsDynamic) {
4063  		SetHoverIndicatorPosition(Sci::invalidPosition);
4064  	} else {
4065  		SetHoverIndicatorPosition(PositionFromLocation(pt, true, true));
4066  	}
4067  }
4068  void Editor::SetHotSpotRange(const Point *pt) {
4069  	if (pt) {
4070  		const Sci::Position pos = PositionFromLocation(*pt, false, true);
4071  		Range hsNew;
4072  		hsNew.start = pdoc-&gt;ExtendStyleRange(pos, -1, hotspotSingleLine);
4073  		hsNew.end = pdoc-&gt;ExtendStyleRange(pos, 1, hotspotSingleLine);
4074  		if (!(hsNew == hotspot)) {
4075  			if (hotspot.Valid()) {
4076  				InvalidateRange(hotspot.start, hotspot.end);
4077  			}
4078  			hotspot = hsNew;
4079  			InvalidateRange(hotspot.start, hotspot.end);
4080  		}
4081  	} else {
4082  		if (hotspot.Valid()) {
4083  			InvalidateRange(hotspot.start, hotspot.end);
4084  		}
4085  		hotspot = Range(Sci::invalidPosition);
4086  	}
4087  }
4088  void Editor::ButtonMoveWithModifiers(Point pt, unsigned int, KeyMod modifiers) {
4089  	if (ptMouseLast != pt) {
4090  		DwellEnd(true);
4091  	}
4092  	SelectionPosition movePos = SPositionFromLocation(pt, false, false,
4093  		AllowVirtualSpace(virtualSpaceOptions, sel.IsRectangular()));
4094  	movePos = MovePositionOutsideChar(movePos, sel.MainCaret() - movePos.Position());
4095  	if (inDragDrop == DragDrop::initial) {
4096  		if (DragThreshold(ptMouseLast, pt)) {
4097  			SetMouseCapture(false);
4098  			FineTickerCancel(TickReason::scroll);
4099  			SetDragPosition(movePos);
4100  			CopySelectionRange(&amp;drag);
4101  			StartDrag();
4102  		}
4103  		return;
4104  	}
4105  	ptMouseLast = pt;
4106  	PRectangle rcClient = GetClientRectangle();
4107  	const Point ptOrigin = GetVisibleOriginInMain();
4108  	rcClient.Move(0, -ptOrigin.y);
4109  	if ((dwellDelay &lt; TimeForever) &amp;&amp; rcClient.Contains(pt)) {
4110  		FineTickerStart(TickReason::dwell, dwellDelay, dwellDelay/10);
4111  	}
4112  	if (HaveMouseCapture()) {
4113  		autoScrollTimer.ticksToWait -= timer.tickSize;
4114  		if (autoScrollTimer.ticksToWait &gt; 0)
4115  			return;
4116  		autoScrollTimer.ticksToWait = autoScrollDelay;
4117  		if (posDrag.IsValid()) {
4118  			SetDragPosition(movePos);
4119  		} else {
4120  			if (selectionUnit == TextUnit::character) {
4121  				if (sel.selType == Selection::SelTypes::stream &amp;&amp; FlagSet(modifiers, KeyMod::Alt) &amp;&amp; mouseSelectionRectangularSwitch) {
4122  					sel.selType = Selection::SelTypes::rectangle;
4123  				}
4124  				if (sel.IsRectangular()) {
4125  					sel.Rectangular() = SelectionRange(movePos, sel.Rectangular().anchor);
4126  					SetSelection(movePos, sel.RangeMain().anchor);
4127  				} else if (sel.Count() &gt; 1) {
4128  					InvalidateSelection(sel.RangeMain(), false);
4129  					const SelectionRange range(movePos, sel.RangeMain().anchor);
4130  					sel.TentativeSelection(range);
4131  					InvalidateSelection(range, true);
4132  				} else {
4133  					SetSelection(movePos, sel.RangeMain().anchor);
4134  				}
4135  			} else if (selectionUnit == TextUnit::word) {
4136  				if (movePos.Position() == wordSelectInitialCaretPos) {  
4137  				} else {
4138  					wordSelectInitialCaretPos = -1;
4139  					WordSelection(movePos.Position());
4140  				}
4141  			} else {
4142  				LineSelection(movePos.Position(), lineAnchorPos, selectionUnit == TextUnit::wholeLine);
4143  			}
4144  		}
4145  		const Sci::Line lineMove = DisplayFromPosition(movePos.Position());
4146  		if (pt.y &gt;= rcClient.bottom) {
4147  			ScrollTo(lineMove - LinesOnScreen() + 1);
4148  			Redraw();
4149  		} else if (pt.y &lt; rcClient.top) {
4150  			ScrollTo(lineMove);
4151  			Redraw();
4152  		}
4153  		EnsureCaretVisible(false, false, true);
4154  		if (hotspot.Valid() &amp;&amp; !PointIsHotspot(pt))
4155  			SetHotSpotRange(nullptr);
4156  		if (hotSpotClickPos != Sci::invalidPosition &amp;&amp; PositionFromLocation(pt, true, true) != hotSpotClickPos) {
4157  			if (inDragDrop == DragDrop::none) {
4158  				DisplayCursor(Window::Cursor::text);
4159  			}
4160  			hotSpotClickPos = Sci::invalidPosition;
4161  		}
4162  	} else {
4163  		if (vs.fixedColumnWidth &gt; 0) {	
4164  			if (PointInSelMargin(pt)) {
4165  				DisplayCursor(GetMarginCursor(pt));
4166  				SetHotSpotRange(nullptr);
4167  				SetHoverIndicatorPosition(Sci::invalidPosition);
4168  				return; 	
4169  			}
4170  		}
4171  		if (PointInSelection(pt) &amp;&amp; !SelectionEmpty()) {
4172  			DisplayCursor(Window::Cursor::arrow);
4173  			SetHoverIndicatorPosition(Sci::invalidPosition);
4174  		} else {
4175  			SetHoverIndicatorPoint(pt);
4176  			if (PointIsHotspot(pt)) {
4177  				DisplayCursor(Window::Cursor::hand);
4178  				SetHotSpotRange(&amp;pt);
4179  			} else {
4180  				if (hoverIndicatorPos != Sci::invalidPosition)
4181  					DisplayCursor(Window::Cursor::hand);
4182  				else
4183  					DisplayCursor(Window::Cursor::text);
4184  				SetHotSpotRange(nullptr);
4185  			}
4186  		}
4187  	}
4188  }
4189  void Editor::ButtonUpWithModifiers(Point pt, unsigned int curTime, KeyMod modifiers) {
4190  	SelectionPosition newPos = SPositionFromLocation(pt, false, false,
4191  		AllowVirtualSpace(virtualSpaceOptions, sel.IsRectangular()));
4192  	if (hoverIndicatorPos != Sci::invalidPosition)
4193  		InvalidateRange(newPos.Position(), newPos.Position() + 1);
4194  	newPos = MovePositionOutsideChar(newPos, sel.MainCaret() - newPos.Position());
4195  	if (inDragDrop == DragDrop::initial) {
4196  		inDragDrop = DragDrop::none;
4197  		SetEmptySelection(newPos);
4198  		selectionUnit = TextUnit::character;
4199  		originalAnchorPos = sel.MainCaret();
4200  	}
4201  	if (hotSpotClickPos != Sci::invalidPosition &amp;&amp; PointIsHotspot(pt)) {
4202  		hotSpotClickPos = Sci::invalidPosition;
4203  		SelectionPosition newCharPos = SPositionFromLocation(pt, false, true, false);
4204  		newCharPos = MovePositionOutsideChar(newCharPos, -1);
4205  		NotifyHotSpotReleaseClick(newCharPos.Position(), modifiers &amp; KeyMod::Ctrl);
4206  	}
4207  	if (HaveMouseCapture()) {
4208  		if (PointInSelMargin(pt)) {
4209  			DisplayCursor(GetMarginCursor(pt));
4210  		} else {
4211  			DisplayCursor(Window::Cursor::text);
4212  			SetHotSpotRange(nullptr);
4213  		}
4214  		ptMouseLast = pt;
4215  		SetMouseCapture(false);
4216  		FineTickerCancel(TickReason::scroll);
4217  		NotifyIndicatorClick(false, newPos.Position(), modifiers);
4218  		if (inDragDrop == DragDrop::dragging) {
4219  			const SelectionPosition selStart = SelectionStart();
4220  			const SelectionPosition selEnd = SelectionEnd();
4221  			if (selStart &lt; selEnd) {
4222  				if (drag.Length()) {
4223  					const Sci::Position length = drag.Length();
4224  					if (FlagSet(modifiers, KeyMod::Ctrl)) {
4225  						const Sci::Position lengthInserted = pdoc-&gt;InsertString(
4226  							newPos.Position(), drag.Data(), length);
4227  						if (lengthInserted &gt; 0) {
4228  							SetSelection(newPos.Position(), newPos.Position() + lengthInserted);
4229  						}
4230  					} else if (newPos &lt; selStart) {
4231  						pdoc-&gt;DeleteChars(selStart.Position(), drag.Length());
4232  						const Sci::Position lengthInserted = pdoc-&gt;InsertString(
4233  							newPos.Position(), drag.Data(), length);
4234  						if (lengthInserted &gt; 0) {
4235  							SetSelection(newPos.Position(), newPos.Position() + lengthInserted);
4236  						}
4237  					} else if (newPos &gt; selEnd) {
4238  						pdoc-&gt;DeleteChars(selStart.Position(), drag.Length());
4239  						newPos.Add(-static_cast&lt;Sci::Position&gt;(drag.Length()));
4240  						const Sci::Position lengthInserted = pdoc-&gt;InsertString(
4241  							newPos.Position(), drag.Data(), length);
4242  						if (lengthInserted &gt; 0) {
4243  							SetSelection(newPos.Position(), newPos.Position() + lengthInserted);
4244  						}
4245  					} else {
4246  						SetEmptySelection(newPos.Position());
4247  					}
4248  					drag.Clear();
4249  				}
4250  				selectionUnit = TextUnit::character;
4251  			}
4252  		} else {
4253  			if (selectionUnit == TextUnit::character) {
4254  				if (sel.Count() &gt; 1) {
4255  					sel.RangeMain() =
4256  						SelectionRange(newPos, sel.Range(sel.Count() - 1).anchor);
4257  					InvalidateWholeSelection();
4258  				} else {
4259  					SetSelection(newPos, sel.RangeMain().anchor);
4260  				}
4261  			}
4262  			sel.CommitTentative();
4263  		}
4264  		SetRectangularRange();
4265  		lastClickTime = curTime;
4266  		lastClick = pt;
4267  		lastXChosen = static_cast&lt;int&gt;(pt.x) + xOffset;
4268  		if (sel.selType == Selection::SelTypes::stream) {
4269  			SetLastXChosen();
4270  		}
4271  		inDragDrop = DragDrop::none;
4272  		EnsureCaretVisible(false);
4273  	}
4274  }
4275  bool Editor::Idle() {
4276  	NotifyUpdateUI();
4277  	bool needWrap = Wrapping() &amp;&amp; wrapPending.NeedsWrap();
4278  	if (needWrap) {
4279  		WrapLines(WrapScope::wsIdle);
4280  		needWrap = wrapPending.NeedsWrap();
4281  	} else if (needIdleStyling) {
4282  		IdleStyle();
4283  	}
4284  	const bool idleDone = !needWrap &amp;&amp; !needIdleStyling; 
4285  	return !idleDone;
4286  }
4287  void Editor::TickFor(TickReason reason) {
4288  	switch (reason) {
4289  		case TickReason::caret:
4290  			caret.on = !caret.on;
4291  			if (caret.active) {
4292  				InvalidateCaret();
4293  			}
4294  			break;
4295  		case TickReason::scroll:
4296  			ButtonMoveWithModifiers(ptMouseLast, 0, KeyMod::Norm);
4297  			break;
4298  		case TickReason::widen:
4299  			SetScrollBars();
4300  			FineTickerCancel(TickReason::widen);
4301  			break;
4302  		case TickReason::dwell:
4303  			if ((!HaveMouseCapture()) &amp;&amp;
4304  				(ptMouseLast.y &gt;= 0)) {
4305  				dwelling = true;
4306  				NotifyDwelling(ptMouseLast, dwelling);
4307  			}
4308  			FineTickerCancel(TickReason::dwell);
4309  			break;
4310  		default:
4311  			break;
4312  	}
4313  }
4314  bool Editor::FineTickerRunning(TickReason) {
4315  	assert(false);
4316  	return false;
4317  }
4318  void Editor::FineTickerStart(TickReason, int, int) {
4319  	assert(false);
4320  }
4321  void Editor::FineTickerCancel(TickReason) {
4322  	assert(false);
4323  }
4324  void Editor::SetFocusState(bool focusState) {
4325  	const bool changing = hasFocus != focusState;
4326  	hasFocus = focusState;
4327  	if (changing) {
4328  		Redraw();
4329  	}
4330  	NotifyFocus(hasFocus);
4331  	if (!hasFocus) {
4332  		CancelModes();
4333  	}
4334  	ShowCaretAtCurrentPosition();
4335  }
4336  void Editor::UpdateBaseElements() {
4337  }
4338  Sci::Position Editor::PositionAfterArea(PRectangle rcArea) const {
4339  	const Sci::Line lineAfter = TopLineOfMain() + static_cast&lt;Sci::Line&gt;(rcArea.bottom - 1) / vs.lineHeight + 1;
4340  	if (lineAfter &lt; pcs-&gt;LinesDisplayed())
4341  		return pdoc-&gt;LineStart(pcs-&gt;DocFromDisplay(lineAfter) + 1);
4342  	else
4343  		return pdoc-&gt;Length();
4344  }
4345  void Editor::StyleToPositionInView(Sci::Position pos) {
4346  	Sci::Position endWindow = PositionAfterArea(GetClientDrawingRectangle());
4347  	if (pos &gt; endWindow)
4348  		pos = endWindow;
4349  	const int styleAtEnd = pdoc-&gt;StyleIndexAt(pos-1);
4350  	pdoc-&gt;EnsureStyledTo(pos);
4351  	if ((endWindow &gt; pos) &amp;&amp; (styleAtEnd != pdoc-&gt;StyleIndexAt(pos-1))) {
4352  		DiscardOverdraw();	
4353  		endWindow = PositionAfterArea(GetClientDrawingRectangle());
4354  		pdoc-&gt;EnsureStyledTo(endWindow);
4355  	}
4356  }
4357  Sci::Position Editor::PositionAfterMaxStyling(Sci::Position posMax, bool scrolling) const {
4358  	if (SynchronousStylingToVisible()) {
4359  		return posMax;
4360  	}
4361  	const double secondsAllowed = scrolling ? 0.005 : 0.02;
4362  	const size_t actionsInAllowedTime = std::clamp&lt;Sci::Line&gt;(
4363  		pdoc-&gt;durationStyleOneByte.ActionsInAllowedTime(secondsAllowed),
4364  		0x200, 0x20000);
4365  	const Sci::Line lineLast = pdoc-&gt;LineFromPositionAfter(pdoc-&gt;SciLineFromPosition(pdoc-&gt;GetEndStyled()), actionsInAllowedTime);
4366  	const Sci::Line stylingMaxLine = std::min(lineLast, pdoc-&gt;LinesTotal());
4367  	return std::min(pdoc-&gt;LineStart(stylingMaxLine), posMax);
4368  }
4369  void Editor::StartIdleStyling(bool truncatedLastStyling) {
4370  	if ((idleStyling == IdleStyling::All) || (idleStyling == IdleStyling::AfterVisible)) {
4371  		if (pdoc-&gt;GetEndStyled() &lt; pdoc-&gt;Length()) {
4372  			needIdleStyling = true;
4373  		}
4374  	} else if (truncatedLastStyling) {
4375  		needIdleStyling = true;
4376  	}
4377  	if (needIdleStyling) {
4378  		SetIdle(true);
4379  	}
4380  }
4381  void Editor::StyleAreaBounded(PRectangle rcArea, bool scrolling) {
4382  	const Sci::Position posAfterArea = PositionAfterArea(rcArea);
4383  	const Sci::Position posAfterMax = PositionAfterMaxStyling(posAfterArea, scrolling);
4384  	if (posAfterMax &lt; posAfterArea) {
4385  		pdoc-&gt;StyleToAdjustingLineDuration(posAfterMax);
4386  	} else {
4387  		StyleToPositionInView(posAfterArea);
4388  	}
4389  	StartIdleStyling(posAfterMax &lt; posAfterArea);
4390  }
4391  void Editor::IdleStyle() {
4392  	const Sci::Position posAfterArea = PositionAfterArea(GetClientRectangle());
4393  	const Sci::Position endGoal = (idleStyling &gt;= IdleStyling::AfterVisible) ?
4394  		pdoc-&gt;Length() : posAfterArea;
4395  	const Sci::Position posAfterMax = PositionAfterMaxStyling(endGoal, false);
4396  	pdoc-&gt;StyleToAdjustingLineDuration(posAfterMax);
4397  	if (pdoc-&gt;GetEndStyled() &gt;= endGoal) {
4398  		needIdleStyling = false;
4399  	}
4400  }
4401  void Editor::IdleWork() {
4402  	if (FlagSet(workNeeded.items, WorkItems::style)) {
4403  		StyleToPositionInView(pdoc-&gt;LineStart(pdoc-&gt;LineFromPosition(workNeeded.upTo) + 2));
4404  	}
4405  	NotifyUpdateUI();
4406  	workNeeded.Reset();
4407  }
4408  void Editor::QueueIdleWork(WorkItems items, Sci::Position upTo) {
4409  	workNeeded.Need(items, upTo);
4410  }
4411  int Editor::SupportsFeature(Supports feature) {
4412  	AutoSurface surface(this);
4413  	return surface-&gt;SupportsFeature(feature);
4414  }
4415  bool Editor::PaintContains(PRectangle rc) {
4416  	if (rc.Empty()) {
4417  		return true;
4418  	} else {
4419  		return rcPaint.Contains(rc);
4420  	}
4421  }
4422  bool Editor::PaintContainsMargin() {
4423  	if (HasMarginWindow()) {
4424  		return false;
4425  	}
4426  	PRectangle rcSelMargin = GetClientRectangle();
4427  	rcSelMargin.right = static_cast&lt;XYPOSITION&gt;(vs.textStart);
4428  	return PaintContains(rcSelMargin);
4429  }
4430  void Editor::CheckForChangeOutsidePaint(Range r) {
4431  	if (paintState == PaintState::painting &amp;&amp; !paintingAllText) {
4432  		if (!r.Valid())
4433  			return;
4434  		PRectangle rcRange = RectangleFromRange(r, 0);
4435  		const PRectangle rcText = GetTextRectangle();
4436  		if (rcRange.top &lt; rcText.top) {
4437  			rcRange.top = rcText.top;
4438  		}
4439  		if (rcRange.bottom &gt; rcText.bottom) {
4440  			rcRange.bottom = rcText.bottom;
4441  		}
4442  		if (!PaintContains(rcRange)) {
4443  			AbandonPaint();
4444  			paintAbandonedByStyling = true;
4445  		}
4446  	}
4447  }
4448  void Editor::SetBraceHighlight(Sci::Position pos0, Sci::Position pos1, int matchStyle) {
4449  	if ((pos0 != braces[0]) || (pos1 != braces[1]) || (matchStyle != bracesMatchStyle)) {
4450  		if ((braces[0] != pos0) || (matchStyle != bracesMatchStyle)) {
4451  			CheckForChangeOutsidePaint(Range(braces[0]));
4452  			CheckForChangeOutsidePaint(Range(pos0));
4453  			braces[0] = pos0;
4454  		}
4455  		if ((braces[1] != pos1) || (matchStyle != bracesMatchStyle)) {
4456  			CheckForChangeOutsidePaint(Range(braces[1]));
4457  			CheckForChangeOutsidePaint(Range(pos1));
4458  			braces[1] = pos1;
4459  		}
4460  		bracesMatchStyle = matchStyle;
4461  		if (paintState == PaintState::notPainting) {
4462  			Redraw();
4463  		}
4464  	}
4465  }
4466  void Editor::SetAnnotationHeights(Sci::Line start, Sci::Line end) {
4467  	if (vs.annotationVisible != AnnotationVisible::Hidden) {
4468  		RefreshStyleData();
4469  		bool changedHeight = false;
4470  		for (Sci::Line line=start; line&lt;end &amp;&amp; line&lt;pdoc-&gt;LinesTotal(); line++) {
4471  			int linesWrapped = 1;
4472  			if (Wrapping()) {
4473  				AutoSurface surface(this);
4474  				std::shared_ptr&lt;LineLayout&gt; ll = view.RetrieveLineLayout(line, *this);
4475  				if (surface &amp;&amp; ll) {
4476  					view.LayoutLine(*this, surface, vs, ll.get(), wrapWidth);
4477  					linesWrapped = ll-&gt;lines;
4478  				}
4479  			}
4480  			if (pcs-&gt;SetHeight(line, pdoc-&gt;AnnotationLines(line) + linesWrapped))
4481  				changedHeight = true;
4482  		}
4483  		if (changedHeight) {
4484  			SetScrollBars();
4485  			SetVerticalScrollPos();
4486  			Redraw();
4487  		}
4488  	}
4489  }
4490  void Editor::SetDocPointer(Document *document) {
4491  	pdoc-&gt;RemoveWatcher(this, nullptr);
4492  	pdoc-&gt;Release();
4493  	if (!document) {
4494  		pdoc = new Document(DocumentOption::Default);
4495  	} else {
4496  		pdoc = document;
4497  	}
4498  	pdoc-&gt;AddRef();
4499  	pcs = ContractionStateCreate(pdoc-&gt;IsLarge());
4500  	sel.Clear();
4501  	targetRange = SelectionSegment();
4502  	braces[0] = Sci::invalidPosition;
4503  	braces[1] = Sci::invalidPosition;
4504  	vs.ReleaseAllExtendedStyles();
4505  	SetRepresentations();
4506  	pcs-&gt;Clear();
4507  	pcs-&gt;InsertLines(0, pdoc-&gt;LinesTotal() - 1);
4508  	SetAnnotationHeights(0, pdoc-&gt;LinesTotal());
4509  	view.llc.Deallocate();
4510  	NeedWrapping();
4511  	hotspot = Range(Sci::invalidPosition);
4512  	hoverIndicatorPos = Sci::invalidPosition;
4513  	view.ClearAllTabstops();
4514  	pdoc-&gt;AddWatcher(this, nullptr);
4515  	SetScrollBars();
4516  	Redraw();
4517  }
4518  void Editor::SetAnnotationVisible(AnnotationVisible visible) {
4519  	if (vs.annotationVisible != visible) {
4520  		const bool changedFromOrToHidden = ((vs.annotationVisible != AnnotationVisible::Hidden) != (visible != AnnotationVisible::Hidden));
4521  		vs.annotationVisible = visible;
4522  		if (changedFromOrToHidden) {
4523  			const int dir = (vs.annotationVisible!= AnnotationVisible::Hidden) ? 1 : -1;
4524  			for (Sci::Line line=0; line&lt;pdoc-&gt;LinesTotal(); line++) {
4525  				const int annotationLines = pdoc-&gt;AnnotationLines(line);
4526  				if (annotationLines &gt; 0) {
4527  					pcs-&gt;SetHeight(line, pcs-&gt;GetHeight(line) + annotationLines * dir);
4528  				}
4529  			}
4530  			SetScrollBars();
4531  		}
4532  		Redraw();
4533  	}
4534  }
4535  void Editor::SetEOLAnnotationVisible(EOLAnnotationVisible visible) {
4536  	if (vs.eolAnnotationVisible != visible) {
4537  		vs.eolAnnotationVisible = visible;
4538  		Redraw();
4539  	}
4540  }
4541  Sci::Line Editor::ExpandLine(Sci::Line line) {
4542  	const Sci::Line lineMaxSubord = pdoc-&gt;GetLastChild(line);
4543  	line++;
4544  	Sci::Line lineStart = line;
4545  	while (line &lt;= lineMaxSubord) {
4546  		const FoldLevel level = pdoc-&gt;GetFoldLevel(line);
4547  		if (LevelIsHeader(level)) {
4548  			pcs-&gt;SetVisible(lineStart, line, true);
4549  			if (pcs-&gt;GetExpanded(line)) {
4550  				line = ExpandLine(line);
4551  			} else {
4552  				line = pdoc-&gt;GetLastChild(line);
4553  			}
4554  			lineStart = line + 1;
4555  		}
4556  		line++;
4557  	}
4558  	if (lineStart &lt;= lineMaxSubord) {
4559  		pcs-&gt;SetVisible(lineStart, lineMaxSubord, true);
4560  	}
4561  	return lineMaxSubord;
4562  }
4563  void Editor::SetFoldExpanded(Sci::Line lineDoc, bool expanded) {
4564  	if (pcs-&gt;SetExpanded(lineDoc, expanded)) {
4565  		RedrawSelMargin();
4566  	}
4567  }
4568  void Editor::FoldLine(Sci::Line line, FoldAction action) {
4569  	if (line &gt;= 0) {
4570  		if (action == FoldAction::Toggle) {
4571  			if (!LevelIsHeader(pdoc-&gt;GetFoldLevel(line))) {
4572  				line = pdoc-&gt;GetFoldParent(line);
4573  				if (line &lt; 0)
4574  					return;
4575  			}
4576  			action = (pcs-&gt;GetExpanded(line)) ? FoldAction::Contract : FoldAction::Expand;
4577  		}
4578  		if (action == FoldAction::Contract) {
4579  			const Sci::Line lineMaxSubord = pdoc-&gt;GetLastChild(line);
4580  			if (lineMaxSubord &gt; line) {
4581  				pcs-&gt;SetExpanded(line, false);
4582  				pcs-&gt;SetVisible(line + 1, lineMaxSubord, false);
4583  				const Sci::Line lineCurrent =
4584  					pdoc-&gt;SciLineFromPosition(sel.MainCaret());
4585  				if (lineCurrent &gt; line &amp;&amp; lineCurrent &lt;= lineMaxSubord) {
4586  					EnsureCaretVisible();
4587  				}
4588  			}
4589  		} else {
4590  			if (!(pcs-&gt;GetVisible(line))) {
4591  				EnsureLineVisible(line, false);
4592  				GoToLine(line);
4593  			}
4594  			pcs-&gt;SetExpanded(line, true);
4595  			ExpandLine(line);
4596  		}
4597  		SetScrollBars();
4598  		Redraw();
4599  	}
4600  }
4601  void Editor::FoldExpand(Sci::Line line, FoldAction action, FoldLevel level) {
4602  	bool expanding = action == FoldAction::Expand;
4603  	if (action == FoldAction::Toggle) {
4604  		expanding = !pcs-&gt;GetExpanded(line);
4605  	}
4606  	pdoc-&gt;GetLastChild(line, LevelNumberPart(level));
4607  	SetFoldExpanded(line, expanding);
4608  	if (expanding &amp;&amp; (pcs-&gt;HiddenLines() == 0))
4609  		return;
4610  	const Sci::Line lineMaxSubord = pdoc-&gt;GetLastChild(line, LevelNumberPart(level));
4611  	line++;
4612  	pcs-&gt;SetVisible(line, lineMaxSubord, expanding);
4613  	while (line &lt;= lineMaxSubord) {
4614  		const FoldLevel levelLine = pdoc-&gt;GetFoldLevel(line);
4615  		if (LevelIsHeader(levelLine)) {
4616  			SetFoldExpanded(line, expanding);
4617  		}
4618  		line++;
4619  	}
4620  	SetScrollBars();
4621  	Redraw();
4622  }
4623  Sci::Line Editor::ContractedFoldNext(Sci::Line lineStart) const {
4624  	for (Sci::Line line = lineStart; line&lt;pdoc-&gt;LinesTotal();) {
4625  		if (!pcs-&gt;GetExpanded(line) &amp;&amp; LevelIsHeader(pdoc-&gt;GetFoldLevel(line)))
4626  			return line;
4627  		line = pcs-&gt;ContractedNext(line+1);
4628  		if (line &lt; 0)
4629  			return -1;
4630  	}
4631  	return -1;
4632  }
4633  void Editor::EnsureLineVisible(Sci::Line lineDoc, bool enforcePolicy) {
4634  	if (lineDoc &gt;= wrapPending.start) {
4635  		if (WrapLines(WrapScope::wsAll)) {
4636  			Redraw();
4637  		}
4638  	}
4639  	if (!pcs-&gt;GetVisible(lineDoc)) {
4640  		Sci::Line lookLine = lineDoc;
4641  		FoldLevel lookLineLevel = pdoc-&gt;GetFoldLevel(lookLine);
4642  		while ((lookLine &gt; 0) &amp;&amp; LevelIsWhitespace(lookLineLevel)) {
4643  			lookLineLevel = pdoc-&gt;GetFoldLevel(--lookLine);
4644  		}
4645  		Sci::Line lineParent = pdoc-&gt;GetFoldParent(lookLine);
4646  		if (lineParent &lt; 0) {
4647  			lineParent = pdoc-&gt;GetFoldParent(lineDoc);
4648  		}
4649  		if (lineParent &gt;= 0) {
4650  			if (lineDoc != lineParent)
4651  				EnsureLineVisible(lineParent, enforcePolicy);
4652  			if (!pcs-&gt;GetExpanded(lineParent)) {
4653  				pcs-&gt;SetExpanded(lineParent, true);
4654  				ExpandLine(lineParent);
4655  			}
4656  		}
4657  		SetScrollBars();
4658  		Redraw();
4659  	}
4660  	if (enforcePolicy) {
4661  		const Sci::Line lineDisplay = pcs-&gt;DisplayFromDoc(lineDoc);
4662  		if (FlagSet(visiblePolicy.policy, VisiblePolicy::Slop)) {
4663  			if ((topLine &gt; lineDisplay) || ((FlagSet(visiblePolicy.policy, VisiblePolicy::Strict)) &amp;&amp; (topLine + visiblePolicy.slop &gt; lineDisplay))) {
4664  				SetTopLine(std::clamp&lt;Sci::Line&gt;(lineDisplay - visiblePolicy.slop, 0, MaxScrollPos()));
4665  				SetVerticalScrollPos();
4666  				Redraw();
4667  			} else if ((lineDisplay &gt; topLine + LinesOnScreen() - 1) ||
4668  			        ((FlagSet(visiblePolicy.policy, VisiblePolicy::Strict)) &amp;&amp; (lineDisplay &gt; topLine + LinesOnScreen() - 1 - visiblePolicy.slop))) {
4669  				SetTopLine(std::clamp&lt;Sci::Line&gt;(lineDisplay - LinesOnScreen() + 1 + visiblePolicy.slop, 0, MaxScrollPos()));
4670  				SetVerticalScrollPos();
4671  				Redraw();
4672  			}
4673  		} else {
4674  			if ((topLine &gt; lineDisplay) || (lineDisplay &gt; topLine + LinesOnScreen() - 1) || (FlagSet(visiblePolicy.policy, VisiblePolicy::Strict))) {
4675  				SetTopLine(std::clamp&lt;Sci::Line&gt;(lineDisplay - LinesOnScreen() / 2 + 1, 0, MaxScrollPos()));
4676  				SetVerticalScrollPos();
4677  				Redraw();
4678  			}
4679  		}
4680  	}
4681  }
4682  void Editor::FoldAll(FoldAction action) {
4683  	const Sci::Line maxLine = pdoc-&gt;LinesTotal();
4684  	const bool contractAll = FlagSet(action, FoldAction::ContractEveryLevel);
4685  	action = static_cast&lt;FoldAction&gt;(static_cast&lt;int&gt;(action) &amp; ~static_cast&lt;int&gt;(FoldAction::ContractEveryLevel));
4686  	bool expanding = action == FoldAction::Expand;
4687  	if (!expanding) {
4688  		pdoc-&gt;EnsureStyledTo(pdoc-&gt;Length());
4689  	}
4690  	Sci::Line line = 0;
4691  	if (action == FoldAction::Toggle) {
4692  		for (; line &lt; maxLine; line++) {
4693  			if (LevelIsHeader(pdoc-&gt;GetFoldLevel(line))) {
4694  				expanding = !pcs-&gt;GetExpanded(line);
4695  				break;
4696  			}
4697  		}
4698  	}
4699  	if (expanding) {
4700  		pcs-&gt;SetVisible(0, maxLine-1, true);
4701  		pcs-&gt;ExpandAll();
4702  	} else {
4703  		for (; line &lt; maxLine; line++) {
4704  			const FoldLevel level = pdoc-&gt;GetFoldLevel(line);
4705  			if (LevelIsHeader(level)) {
4706  				if (FoldLevel::Base == LevelNumberPart(level)) {
4707  					SetFoldExpanded(line, false);
4708  					const Sci::Line lineMaxSubord = pdoc-&gt;GetLastChild(line);
4709  					if (lineMaxSubord &gt; line) {
4710  						pcs-&gt;SetVisible(line + 1, lineMaxSubord, false);
4711  						if (!contractAll) {
4712  							line = lineMaxSubord;
4713  						}
4714  					}
4715  				} else if (contractAll) {
4716  					SetFoldExpanded(line, false);
4717  				}
4718  			}
4719  		}
4720  	}
4721  	SetScrollBars();
4722  	Redraw();
4723  }
4724  void Editor::FoldChanged(Sci::Line line, FoldLevel levelNow, FoldLevel levelPrev) {
4725  	if (LevelIsHeader(levelNow)) {
4726  		if (!LevelIsHeader(levelPrev)) {
4727  			if (pcs-&gt;SetExpanded(line, true)) {
4728  				RedrawSelMargin();
4729  			}
4730  			FoldExpand(line, FoldAction::Expand, levelPrev);
4731  		}
4732  	} else if (LevelIsHeader(levelPrev)) {
4733  		const Sci::Line prevLine = line - 1;
4734  		const FoldLevel prevLineLevel = pdoc-&gt;GetFoldLevel(prevLine);
4735  		if ((LevelNumber(prevLineLevel) == LevelNumber(levelNow)) &amp;&amp; !pcs-&gt;GetVisible(prevLine))
4736  			FoldLine(pdoc-&gt;GetFoldParent(prevLine), FoldAction::Expand);
4737  		if (!pcs-&gt;GetExpanded(line)) {
4738  			if (pcs-&gt;SetExpanded(line, true)) {
4739  				RedrawSelMargin();
4740  			}
4741  			FoldExpand(line, FoldAction::Expand, levelPrev);
4742  		}
4743  	}
4744  	if (!LevelIsWhitespace(levelNow) &amp;&amp;
4745  	        (LevelNumber(levelPrev) &gt; LevelNumber(levelNow))) {
4746  		if (pcs-&gt;HiddenLines()) {
4747  			const Sci::Line parentLine = pdoc-&gt;GetFoldParent(line);
4748  			if ((parentLine &lt; 0) || (pcs-&gt;GetExpanded(parentLine) &amp;&amp; pcs-&gt;GetVisible(parentLine))) {
4749  				pcs-&gt;SetVisible(line, line, true);
4750  				SetScrollBars();
4751  				Redraw();
4752  			}
4753  		}
4754  	}
4755  	if (!LevelIsWhitespace(levelNow) &amp;&amp; (LevelNumber(levelPrev) &lt; LevelNumber(levelNow))) {
4756  		if (pcs-&gt;HiddenLines()) {
4757  			const Sci::Line parentLine = pdoc-&gt;GetFoldParent(line);
4758  			if (!pcs-&gt;GetExpanded(parentLine) &amp;&amp; pcs-&gt;GetVisible(line))
4759  				FoldLine(parentLine, FoldAction::Expand);
4760  		}
4761  	}
4762  }
4763  void Editor::NeedShown(Sci::Position pos, Sci::Position len) {
4764  	if (FlagSet(foldAutomatic, AutomaticFold::Show)) {
4765  		const Sci::Line lineStart = pdoc-&gt;SciLineFromPosition(pos);
4766  		const Sci::Line lineEnd = pdoc-&gt;SciLineFromPosition(pos+len);
4767  		for (Sci::Line line = lineStart; line &lt;= lineEnd; line++) {
4768  			EnsureLineVisible(line, false);
4769  		}
4770  	} else {
4771  		NotifyNeedShown(pos, len);
4772  	}
4773  }
4774  Sci::Position Editor::GetTag(char *tagValue, int tagNumber) {
4775  	const char *text = nullptr;
4776  	Sci::Position length = 0;
4777  	if ((tagNumber &gt;= 1) &amp;&amp; (tagNumber &lt;= 9)) {
4778  		char name[3] = &quot;\\?&quot;;
4779  		name[1] = static_cast&lt;char&gt;(tagNumber + &#x27;0&#x27;);
4780  		length = 2;
4781  		text = pdoc-&gt;SubstituteByPosition(name, &amp;length);
4782  	}
4783  	if (tagValue) {
4784  		if (text)
4785  			memcpy(tagValue, text, length + 1);
4786  		else
4787  			*tagValue = &#x27;\0&#x27;;
4788  	}
4789  	return length;
4790  }
4791  Sci::Position Editor::ReplaceTarget(ReplaceType replaceType, std::string_view text) {
4792  	UndoGroup ug(pdoc);
4793  	if (replaceType == ReplaceType::patterns) {
4794  		Sci::Position length = text.length();
4795  		const char *p = pdoc-&gt;SubstituteByPosition(text.data(), &amp;length);
4796  		if (!p) {
4797  			return 0;
4798  		}
4799  		text = std::string_view(p, length);
4800  	}
4801  	if (replaceType == ReplaceType::minimal) {
4802  		Range range(targetRange.start.Position(), targetRange.end.Position());
4803  		pdoc-&gt;TrimReplacement(text, range);
4804  		const SelectionPosition start(range.start == targetRange.start.Position() ?
4805  			targetRange.start : SelectionPosition(range.start));
4806  		targetRange = SelectionSegment(start, SelectionPosition(range.end));
4807  	}
4808  	if (targetRange.Length() &gt; 0)
4809  		pdoc-&gt;DeleteChars(targetRange.start.Position(), targetRange.Length());
4810  	targetRange.end = targetRange.start;
4811  	const Sci::Position startAfterSpaceInsertion = RealizeVirtualSpace(targetRange.start.Position(), targetRange.start.VirtualSpace());
4812  	targetRange.start.SetPosition(startAfterSpaceInsertion);
4813  	targetRange.end = targetRange.start;
4814  	const Sci::Position lengthInserted = pdoc-&gt;InsertString(targetRange.start.Position(), text);
4815  	targetRange.end.SetPosition(targetRange.start.Position() + lengthInserted);
4816  	return text.length();
4817  }
4818  bool Editor::IsUnicodeMode() const noexcept {
4819  	return pdoc &amp;&amp; (CpUtf8 == pdoc-&gt;dbcsCodePage);
4820  }
4821  int Editor::CodePage() const noexcept {
4822  	if (pdoc)
4823  		return pdoc-&gt;dbcsCodePage;
4824  	else
4825  		return 0;
4826  }
4827  std::unique_ptr&lt;Surface&gt; Editor::CreateMeasurementSurface() const {
4828  	if (!wMain.GetID()) {
4829  		return {};
4830  	}
4831  	std::unique_ptr&lt;Surface&gt; surf = Surface::Allocate(technology);
4832  	surf-&gt;Init(wMain.GetID());
4833  	surf-&gt;SetMode(CurrentSurfaceMode());
4834  	return surf;
4835  }
4836  std::unique_ptr&lt;Surface&gt; Editor::CreateDrawingSurface(SurfaceID sid, std::optional&lt;Scintilla::Technology&gt; technologyOpt) const {
4837  	if (!wMain.GetID()) {
4838  		return {};
4839  	}
4840  	std::unique_ptr&lt;Surface&gt; surf = Surface::Allocate(technologyOpt ? *technologyOpt : technology);
4841  	surf-&gt;Init(sid, wMain.GetID());
4842  	surf-&gt;SetMode(CurrentSurfaceMode());
4843  	return surf;
4844  }
4845  Sci::Line Editor::WrapCount(Sci::Line line) {
4846  	AutoSurface surface(this);
4847  	std::shared_ptr&lt;LineLayout&gt; ll = view.RetrieveLineLayout(line, *this);
4848  	if (surface &amp;&amp; ll) {
4849  		view.LayoutLine(*this, surface, vs, ll.get(), wrapWidth);
4850  		return ll-&gt;lines;
4851  	} else {
4852  		return 1;
4853  	}
4854  }
4855  void Editor::AddStyledText(const char *buffer, Sci::Position appendLength) {
4856  	const Sci::Position textLength = appendLength / 2;
4857  	std::string text(textLength, &#x27;\0&#x27;);
4858  	for (Sci::Position i = 0; i &lt; textLength; i++) {
4859  		text[i] = buffer[i*2];
4860  	}
4861  	const Sci::Position lengthInserted = pdoc-&gt;InsertString(CurrentPosition(), text);
4862  	for (Sci::Position i = 0; i &lt; textLength; i++) {
4863  		text[i] = buffer[i*2+1];
4864  	}
4865  	pdoc-&gt;StartStyling(CurrentPosition());
4866  	pdoc-&gt;SetStyles(textLength, text.c_str());
4867  	SetEmptySelection(sel.MainCaret() + lengthInserted);
4868  }
4869  Sci::Position Editor::GetStyledText(char *buffer, Sci::Position cpMin, Sci::Position cpMax) const noexcept {
4870  	Sci::Position iPlace = 0;
4871  	for (Sci::Position iChar = cpMin; iChar &lt; cpMax; iChar++) {
4872  		buffer[iPlace++] = pdoc-&gt;CharAt(iChar);
4873  		buffer[iPlace++] = pdoc-&gt;StyleAtNoExcept(iChar);
4874  	}
4875  	buffer[iPlace] = &#x27;\0&#x27;;
4876  	buffer[iPlace + 1] = &#x27;\0&#x27;;
4877  	return iPlace;
4878  }
4879  Sci::Position Editor::GetTextRange(char *buffer, Sci::Position cpMin, Sci::Position cpMax) const {
4880  	const Sci::Position cpEnd = (cpMax == -1) ? pdoc-&gt;Length() : cpMax;
4881  	PLATFORM_ASSERT(cpEnd &lt;= pdoc-&gt;Length());
4882  	const Sci::Position len = cpEnd - cpMin; 	
4883  	pdoc-&gt;GetCharRange(buffer, cpMin, len);
4884  	buffer[len] = &#x27;\0&#x27;;
4885  	return len; 	
4886  }
4887  bool Editor::ValidMargin(uptr_t wParam) const noexcept {
4888  	return wParam &lt; vs.ms.size();
4889  }
4890  void Editor::StyleSetMessage(Message iMessage, uptr_t wParam, sptr_t lParam) {
4891  	vs.EnsureStyle(wParam);
4892  	switch (iMessage) {
4893  	case Message::StyleSetFore:
4894  		vs.styles[wParam].fore = ColourRGBA::FromIpRGB(lParam);
4895  		break;
4896  	case Message::StyleSetBack:
4897  		vs.styles[wParam].back = ColourRGBA::FromIpRGB(lParam);
4898  		break;
4899  	case Message::StyleSetBold:
4900  		vs.styles[wParam].weight = lParam != 0 ? FontWeight::Bold : FontWeight::Normal;
4901  		break;
4902  	case Message::StyleSetWeight:
4903  		vs.styles[wParam].weight = static_cast&lt;FontWeight&gt;(lParam);
4904  		break;
4905  	case Message::StyleSetItalic:
4906  		vs.styles[wParam].italic = lParam != 0;
4907  		break;
4908  	case Message::StyleSetEOLFilled:
4909  		vs.styles[wParam].eolFilled = lParam != 0;
4910  		break;
4911  	case Message::StyleSetSize:
4912  		vs.styles[wParam].size = static_cast&lt;int&gt;(lParam * FontSizeMultiplier);
4913  		break;
4914  	case Message::StyleSetSizeFractional:
4915  		vs.styles[wParam].size = static_cast&lt;int&gt;(lParam);
4916  		break;
4917  	case Message::StyleSetFont:
4918  		if (lParam != 0) {
4919  			vs.SetStyleFontName(static_cast&lt;int&gt;(wParam), ConstCharPtrFromSPtr(lParam));
4920  		}
4921  		break;
4922  	case Message::StyleSetUnderline:
4923  		vs.styles[wParam].underline = lParam != 0;
4924  		break;
4925  	case Message::StyleSetCase:
4926  		vs.styles[wParam].caseForce = static_cast&lt;Style::CaseForce&gt;(lParam);
4927  		break;
4928  	case Message::StyleSetCharacterSet:
4929  		vs.styles[wParam].characterSet = static_cast&lt;CharacterSet&gt;(lParam);
4930  		pdoc-&gt;SetCaseFolder(nullptr);
4931  		break;
4932  	case Message::StyleSetVisible:
4933  		vs.styles[wParam].visible = lParam != 0;
4934  		break;
4935  	case Message::StyleSetInvisibleRepresentation: {
4936  		const char *utf8 = ConstCharPtrFromSPtr(lParam);
4937  		char *rep = vs.styles[wParam].invisibleRepresentation;
4938  		const int classified = UTF8Classify(utf8);
4939  		if (!(classified &amp; UTF8MaskInvalid)) {
4940  			const int len = classified &amp; UTF8MaskWidth;
4941  			for (int i=0; i&lt;len &amp;&amp; i&lt;UTF8MaxBytes; i++)
4942  				*rep++ = *utf8++;
4943  		}
4944  		*rep = 0;
4945  		break;
4946  	}
4947  	case Message::StyleSetChangeable:
4948  		vs.styles[wParam].changeable = lParam != 0;
4949  		break;
4950  	case Message::StyleSetHotSpot:
4951  		vs.styles[wParam].hotspot = lParam != 0;
4952  		break;
4953  	case Message::StyleSetCheckMonospaced:
4954  		vs.styles[wParam].checkMonospaced = lParam != 0;
4955  		break;
4956  	default:
4957  		break;
4958  	}
4959  	InvalidateStyleRedraw();
4960  }
4961  sptr_t Editor::StyleGetMessage(Message iMessage, uptr_t wParam, sptr_t lParam) {
4962  	vs.EnsureStyle(wParam);
4963  	switch (iMessage) {
4964  	case Message::StyleGetFore:
4965  		return vs.styles[wParam].fore.OpaqueRGB();
4966  	case Message::StyleGetBack:
4967  		return vs.styles[wParam].back.OpaqueRGB();
4968  	case Message::StyleGetBold:
4969  		return vs.styles[wParam].weight &gt; FontWeight::Normal;
4970  	case Message::StyleGetWeight:
4971  		return static_cast&lt;sptr_t&gt;(vs.styles[wParam].weight);
4972  	case Message::StyleGetItalic:
4973  		return vs.styles[wParam].italic ? 1 : 0;
4974  	case Message::StyleGetEOLFilled:
4975  		return vs.styles[wParam].eolFilled ? 1 : 0;
4976  	case Message::StyleGetSize:
4977  		return vs.styles[wParam].size / FontSizeMultiplier;
4978  	case Message::StyleGetSizeFractional:
4979  		return vs.styles[wParam].size;
4980  	case Message::StyleGetFont:
4981  		return StringResult(lParam, vs.styles[wParam].fontName);
4982  	case Message::StyleGetUnderline:
4983  		return vs.styles[wParam].underline ? 1 : 0;
4984  	case Message::StyleGetCase:
4985  		return static_cast&lt;int&gt;(vs.styles[wParam].caseForce);
4986  	case Message::StyleGetCharacterSet:
4987  		return static_cast&lt;sptr_t&gt;(vs.styles[wParam].characterSet);
4988  	case Message::StyleGetVisible:
4989  		return vs.styles[wParam].visible ? 1 : 0;
4990  	case Message::StyleGetChangeable:
4991  		return vs.styles[wParam].changeable ? 1 : 0;
4992  	case Message::StyleGetInvisibleRepresentation:
4993  		return StringResult(lParam, vs.styles[wParam].invisibleRepresentation);
4994  	case Message::StyleGetHotSpot:
4995  		return vs.styles[wParam].hotspot ? 1 : 0;
4996  	case Message::StyleGetCheckMonospaced:
4997  		return vs.styles[wParam].checkMonospaced ? 1 : 0;
4998  	default:
4999  		break;
5000  	}
5001  	return 0;
5002  }
5003  void Editor::SetSelectionNMessage(Message iMessage, uptr_t wParam, sptr_t lParam) {
5004  	if (wParam &gt;= sel.Count()) {
5005  		return;
5006  	}
5007  	InvalidateRange(sel.Range(wParam).Start().Position(), sel.Range(wParam).End().Position());
5008  	switch (iMessage) {
5009  	case Message::SetSelectionNCaret:
5010  		sel.Range(wParam).caret.SetPosition(lParam);
5011  		break;
5012  	case Message::SetSelectionNAnchor:
5013  		sel.Range(wParam).anchor.SetPosition(lParam);
5014  		break;
5015  	case Message::SetSelectionNCaretVirtualSpace:
5016  		sel.Range(wParam).caret.SetVirtualSpace(lParam);
5017  		break;
5018  	case Message::SetSelectionNAnchorVirtualSpace:
5019  		sel.Range(wParam).anchor.SetVirtualSpace(lParam);
5020  		break;
5021  	case Message::SetSelectionNStart:
5022  		sel.Range(wParam).anchor.SetPosition(lParam);
5023  		break;
5024  	case Message::SetSelectionNEnd:
5025  		sel.Range(wParam).caret.SetPosition(lParam);
5026  		break;
5027  	default:
5028  		break;
5029  	}
5030  	InvalidateRange(sel.Range(wParam).Start().Position(), sel.Range(wParam).End().Position());
5031  	ContainerNeedsUpdate(Update::Selection);
5032  }
5033  sptr_t Editor::StringResult(sptr_t lParam, const char *val) noexcept {
5034  	const size_t len = val ? strlen(val) : 0;
5035  	if (lParam) {
5036  		char *ptr = CharPtrFromSPtr(lParam);
5037  		if (val)
5038  			memcpy(ptr, val, len+1);
5039  		else
5040  			*ptr = 0;
5041  	}
5042  	return len;	
5043  }
5044  sptr_t Editor::BytesResult(sptr_t lParam, const unsigned char *val, size_t len) noexcept {
5045  	if ((lParam) &amp;&amp; (len &gt; 0)) {
5046  		char *ptr = CharPtrFromSPtr(lParam);
5047  		if (val)
5048  			memcpy(ptr, val, len);
5049  		else
5050  			*ptr = 0;
5051  	}
5052  	return val ? len : 0;
5053  }
5054  sptr_t Editor::WndProc(Message iMessage, uptr_t wParam, sptr_t lParam) {
5055  	if (recordingMacro)
5056  		NotifyMacroRecord(iMessage, wParam, lParam);
5057  	switch (iMessage) {
5058  	case Message::GetText: {
5059  			if (lParam == 0)
5060  				return pdoc-&gt;Length();
5061  			char *ptr = CharPtrFromSPtr(lParam);
5062  			const Sci_Position len = std::min&lt;Sci_Position&gt;(wParam, pdoc-&gt;Length());
5063  			pdoc-&gt;GetCharRange(ptr, 0, len);
5064  			ptr[len] = &#x27;\0&#x27;;
5065  			return len;
5066  		}
5067  	case Message::SetText: {
5068  			if (lParam == 0)
5069  				return 0;
5070  			UndoGroup ug(pdoc);
5071  			pdoc-&gt;DeleteChars(0, pdoc-&gt;Length());
5072  			SetEmptySelection(0);
5073  			const char *text = ConstCharPtrFromSPtr(lParam);
5074  			pdoc-&gt;InsertString(0, text, strlen(text));
5075  			return 1;
5076  		}
5077  	case Message::GetTextLength:
5078  		return pdoc-&gt;Length();
5079  	case Message::Cut:
5080  		Cut();
5081  		SetLastXChosen();
5082  		break;
5083  	case Message::Copy:
5084  		Copy();
5085  		break;
5086  	case Message::CopyAllowLine:
5087  		CopyAllowLine();
5088  		break;
5089  	case Message::VerticalCentreCaret:
5090  		VerticalCentreCaret();
5091  		break;
5092  	case Message::MoveSelectedLinesUp:
5093  		MoveSelectedLinesUp();
5094  		break;
5095  	case Message::MoveSelectedLinesDown:
5096  		MoveSelectedLinesDown();
5097  		break;
5098  	case Message::CopyRange:
5099  		CopyRangeToClipboard(PositionFromUPtr(wParam), lParam);
5100  		break;
5101  	case Message::CopyText:
5102  		CopyText(wParam, ConstCharPtrFromSPtr(lParam));
5103  		break;
5104  	case Message::Paste:
5105  		Paste();
5106  		if ((caretSticky == CaretSticky::Off) || (caretSticky == CaretSticky::WhiteSpace)) {
5107  			SetLastXChosen();
5108  		}
5109  		EnsureCaretVisible();
5110  		break;
5111  	case Message::ReplaceRectangular: {
5112  		UndoGroup ug(pdoc);
5113  		if (!sel.Empty()) {
5114  			ClearSelection(); 
5115  		}
5116  		InsertPasteShape(ConstCharPtrFromSPtr(lParam), PositionFromUPtr(wParam), PasteShape::rectangular);
5117  		break;
5118  	}
5119  	case Message::Clear:
5120  		Clear();
5121  		SetLastXChosen();
5122  		EnsureCaretVisible();
5123  		break;
5124  	case Message::Undo:
5125  		Undo();
5126  		SetLastXChosen();
5127  		break;
5128  	case Message::CanUndo:
5129  		return (pdoc-&gt;CanUndo() &amp;&amp; !pdoc-&gt;IsReadOnly()) ? 1 : 0;
5130  	case Message::EmptyUndoBuffer:
5131  		pdoc-&gt;DeleteUndoHistory();
5132  		return 0;
5133  	case Message::GetFirstVisibleLine:
5134  		return topLine;
5135  	case Message::SetFirstVisibleLine:
5136  		ScrollTo(LineFromUPtr(wParam));
5137  		break;
5138  	case Message::GetLine: {	
5139  			const Sci::Position lineStart =
5140  				pdoc-&gt;LineStart(LineFromUPtr(wParam));
5141  			const Sci::Position lineEnd =
5142  				pdoc-&gt;LineStart(LineFromUPtr(wParam + 1));
5143  			const Sci::Position len = lineEnd - lineStart;
5144  			if (lParam == 0) {
5145  				return len;
5146  			}
5147  			char *ptr = CharPtrFromSPtr(lParam);
5148  			pdoc-&gt;GetCharRange(ptr, lineStart, len);
5149  			return len;
5150  		}
5151  	case Message::GetLineCount:
5152  		if (pdoc-&gt;LinesTotal() == 0)
5153  			return 1;
5154  		else
5155  			return pdoc-&gt;LinesTotal();
5156  	case Message::AllocateLines:
5157  		pdoc-&gt;AllocateLines(wParam);
5158  		break;
5159  	case Message::GetModify:
5160  		return !pdoc-&gt;IsSavePoint();
5161  	case Message::SetSel: {
5162  			Sci::Position nStart = PositionFromUPtr(wParam);
5163  			Sci::Position nEnd = lParam;
5164  			if (nEnd &lt; 0)
5165  				nEnd = pdoc-&gt;Length();
5166  			if (nStart &lt; 0)
5167  				nStart = nEnd; 	
5168  			InvalidateSelection(SelectionRange(nStart, nEnd));
5169  			sel.Clear();
5170  			sel.selType = Selection::SelTypes::stream;
5171  			SetSelection(nEnd, nStart);
5172  			EnsureCaretVisible();
5173  		}
5174  		break;
5175  	case Message::GetSelText: {
5176  			SelectionText selectedText;
5177  			CopySelectionRange(&amp;selectedText);
5178  			if (lParam) {
5179  				char *ptr = CharPtrFromSPtr(lParam);
5180  				size_t iChar = selectedText.Length();
5181  				if (iChar) {
5182  					memcpy(ptr, selectedText.Data(), iChar);
5183  				}
5184  				ptr[iChar] = &#x27;\0&#x27;;
5185  			}
5186  			return selectedText.Length();
5187  	}
5188  	case Message::LineFromPosition:
5189  		if (PositionFromUPtr(wParam) &lt; 0)
5190  			return 0;
5191  		return pdoc-&gt;LineFromPosition(PositionFromUPtr(wParam));
5192  	case Message::PositionFromLine:
5193  		if (LineFromUPtr(wParam) &lt; 0)
5194  			wParam = pdoc-&gt;LineFromPosition(SelectionStart().Position());
5195  		if (wParam == 0)
5196  			return 0; 	
5197  		if (LineFromUPtr(wParam) &gt; pdoc-&gt;LinesTotal())
5198  			return -1;
5199  		return pdoc-&gt;LineStart(LineFromUPtr(wParam));
5200  	case Message::LineLength:
5201  		if ((LineFromUPtr(wParam) &lt; 0) ||
5202  		        (LineFromUPtr(wParam) &gt; pdoc-&gt;LineFromPosition(pdoc-&gt;Length())))
5203  			return 0;
5204  		return pdoc-&gt;LineStart(LineFromUPtr(wParam) + 1) - pdoc-&gt;LineStart(LineFromUPtr(wParam));
5205  	case Message::ReplaceSel: {
5206  			if (lParam == 0)
5207  				return 0;
5208  			UndoGroup ug(pdoc);
5209  			ClearSelection();
5210  			const char *replacement = ConstCharPtrFromSPtr(lParam);
5211  			const Sci::Position lengthInserted = pdoc-&gt;InsertString(
5212  				sel.MainCaret(), replacement, strlen(replacement));
5213  			SetEmptySelection(sel.MainCaret() + lengthInserted);
5214  			SetLastXChosen();
5215  			EnsureCaretVisible();
5216  		}
5217  		break;
5218  	case Message::SetTargetStart:
5219  		targetRange.start.SetPosition(PositionFromUPtr(wParam));
5220  		break;
5221  	case Message::GetTargetStart:
5222  		return targetRange.start.Position();
5223  	case Message::SetTargetStartVirtualSpace:
5224  		targetRange.start.SetVirtualSpace(PositionFromUPtr(wParam));
5225  		break;
5226  	case Message::GetTargetStartVirtualSpace:
5227  		return targetRange.start.VirtualSpace();
5228  	case Message::SetTargetEnd:
5229  		targetRange.end.SetPosition(PositionFromUPtr(wParam));
5230  		break;
5231  	case Message::GetTargetEnd:
5232  		return targetRange.end.Position();
5233  	case Message::SetTargetEndVirtualSpace:
5234  		targetRange.end.SetVirtualSpace(PositionFromUPtr(wParam));
5235  		break;
5236  	case Message::GetTargetEndVirtualSpace:
5237  		return targetRange.end.VirtualSpace();
5238  	case Message::SetTargetRange:
5239  		targetRange.start.SetPosition(PositionFromUPtr(wParam));
5240  		targetRange.end.SetPosition(lParam);
5241  		break;
5242  	case Message::TargetWholeDocument:
5243  		targetRange.start.SetPosition(0);
5244  		targetRange.end.SetPosition(pdoc-&gt;Length());
5245  		break;
5246  	case Message::TargetFromSelection:
5247  		targetRange.start = sel.RangeMain().Start();
5248  		targetRange.end = sel.RangeMain().End();
5249  		break;
5250  	case Message::GetTargetText: {
5251  			std::string text = RangeText(targetRange.start.Position(), targetRange.end.Position());
5252  			return BytesResult(lParam, reinterpret_cast&lt;const unsigned char *&gt;(text.c_str()), text.length());
5253  		}
5254  	case Message::ReplaceTarget:
5255  		PLATFORM_ASSERT(lParam);
5256  		return ReplaceTarget(ReplaceType::basic, ViewFromParams(lParam, wParam));
5257  	case Message::ReplaceTargetRE:
5258  		PLATFORM_ASSERT(lParam);
5259  		return ReplaceTarget(ReplaceType::patterns, ViewFromParams(lParam, wParam));
5260  	case Message::ReplaceTargetMinimal:
5261  		PLATFORM_ASSERT(lParam);
5262  		return ReplaceTarget(ReplaceType::minimal, ViewFromParams(lParam, wParam));
5263  	case Message::SearchInTarget:
5264  		PLATFORM_ASSERT(lParam);
5265  		return SearchInTarget(ConstCharPtrFromSPtr(lParam), PositionFromUPtr(wParam));
5266  	case Message::SetSearchFlags:
5267  		searchFlags = static_cast&lt;FindOption&gt;(wParam);
5268  		break;
5269  	case Message::GetSearchFlags:
5270  		return static_cast&lt;sptr_t&gt;(searchFlags);
5271  	case Message::GetTag:
5272  		return GetTag(CharPtrFromSPtr(lParam), static_cast&lt;int&gt;(wParam));
5273  	case Message::PositionBefore:
5274  		return pdoc-&gt;MovePositionOutsideChar(PositionFromUPtr(wParam) - 1, -1, true);
5275  	case Message::PositionAfter:
5276  		return pdoc-&gt;MovePositionOutsideChar(PositionFromUPtr(wParam) + 1, 1, true);
5277  	case Message::PositionRelative:
5278  		return std::clamp&lt;Sci::Position&gt;(pdoc-&gt;GetRelativePosition(
5279  			PositionFromUPtr(wParam), lParam),
5280  			0, pdoc-&gt;Length());
5281  	case Message::PositionRelativeCodeUnits:
5282  		return std::clamp&lt;Sci::Position&gt;(pdoc-&gt;GetRelativePositionUTF16(
5283  			PositionFromUPtr(wParam), lParam),
5284  			0, pdoc-&gt;Length());
5285  	case Message::LineScroll:
5286  		ScrollTo(topLine + lParam);
5287  		HorizontalScrollTo(xOffset + static_cast&lt;int&gt;(static_cast&lt;int&gt;(wParam) * vs.spaceWidth));
5288  		return 1;
5289  	case Message::SetXOffset:
5290  		xOffset = static_cast&lt;int&gt;(wParam);
5291  		ContainerNeedsUpdate(Update::HScroll);
5292  		SetHorizontalScrollPos();
5293  		Redraw();
5294  		break;
5295  	case Message::GetXOffset:
5296  		return xOffset;
5297  	case Message::ChooseCaretX:
5298  		SetLastXChosen();
5299  		break;
5300  	case Message::ScrollCaret:
5301  		EnsureCaretVisible();
5302  		break;
5303  	case Message::SetReadOnly:
5304  		pdoc-&gt;SetReadOnly(wParam != 0);
5305  		return 1;
5306  	case Message::GetReadOnly:
5307  		return pdoc-&gt;IsReadOnly();
5308  	case Message::CanPaste:
5309  		return CanPaste();
5310  	case Message::PointXFromPosition:
5311  		if (lParam &lt; 0) {
5312  			return 0;
5313  		} else {
5314  			const Point pt = LocationFromPosition(lParam);
5315  			return static_cast&lt;int&gt;(pt.x) - vs.textStart + vs.fixedColumnWidth;
5316  		}
5317  	case Message::PointYFromPosition:
5318  		if (lParam &lt; 0) {
5319  			return 0;
5320  		} else {
5321  			const Point pt = LocationFromPosition(lParam);
5322  			return static_cast&lt;int&gt;(pt.y);
5323  		}
5324  	case Message::FindText:
5325  		return FindText(wParam, lParam);
5326  	case Message::FindTextFull:
5327  		return FindTextFull(wParam, lParam);
5328  	case Message::GetTextRange:
5329  		if (TextRange *tr = static_cast&lt;TextRange *&gt;(PtrFromSPtr(lParam))) {
5330  			return GetTextRange(tr-&gt;lpstrText, tr-&gt;chrg.cpMin, tr-&gt;chrg.cpMax);
5331  		}
5332  		return 0;
5333  	case Message::GetTextRangeFull:
5334  		if (TextRangeFull *tr = static_cast&lt;TextRangeFull *&gt;(PtrFromSPtr(lParam))) {
5335  			return GetTextRange(tr-&gt;lpstrText, tr-&gt;chrg.cpMin, tr-&gt;chrg.cpMax);
5336  		}
5337  		return 0;
5338  	case Message::HideSelection:
5339  		vs.selection.visible = wParam == 0;
5340  		Redraw();
5341  		break;
5342  	case Message::GetSelectionHidden:
5343  		return !vs.selection.visible;
5344  		break;
5345  	case Message::FormatRange:
5346  	case Message::FormatRangeFull:
5347  		return FormatRange(iMessage, wParam, lParam);
5348  	case Message::GetMarginLeft:
5349  		return vs.leftMarginWidth;
5350  	case Message::GetMarginRight:
5351  		return vs.rightMarginWidth;
5352  	case Message::SetMarginLeft:
5353  		lastXChosen += static_cast&lt;int&gt;(lParam) - vs.leftMarginWidth;
5354  		vs.leftMarginWidth = static_cast&lt;int&gt;(lParam);
5355  		InvalidateStyleRedraw();
5356  		break;
5357  	case Message::SetMarginRight:
5358  		vs.rightMarginWidth = static_cast&lt;int&gt;(lParam);
5359  		InvalidateStyleRedraw();
5360  		break;
5361  	case Message::AddText: {
5362  			if (lParam == 0)
5363  				return 0;
5364  			const Sci::Position lengthInserted = pdoc-&gt;InsertString(
5365  				CurrentPosition(), ConstCharPtrFromSPtr(lParam), PositionFromUPtr(wParam));
5366  			SetEmptySelection(sel.MainCaret() + lengthInserted);
5367  			return 0;
5368  		}
5369  	case Message::AddStyledText:
5370  		if (lParam)
5371  			AddStyledText(ConstCharPtrFromSPtr(lParam), PositionFromUPtr(wParam));
5372  		return 0;
5373  	case Message::InsertText: {
5374  			if (lParam == 0)
5375  				return 0;
5376  			Sci::Position insertPos = PositionFromUPtr(wParam);
5377  			if (insertPos == -1)
5378  				insertPos = CurrentPosition();
5379  			Sci::Position newCurrent = CurrentPosition();
5380  			const char *sz = ConstCharPtrFromSPtr(lParam);
5381  			const Sci::Position lengthInserted = pdoc-&gt;InsertString(insertPos, sz, strlen(sz));
5382  			if (newCurrent &gt; insertPos)
5383  				newCurrent += lengthInserted;
5384  			SetEmptySelection(newCurrent);
5385  			return 0;
5386  		}
5387  	case Message::ChangeInsertion:
5388  		PLATFORM_ASSERT(lParam);
5389  		pdoc-&gt;ChangeInsertion(ConstCharPtrFromSPtr(lParam), PositionFromUPtr(wParam));
5390  		return 0;
5391  	case Message::AppendText:
5392  		pdoc-&gt;InsertString(pdoc-&gt;Length(),
5393  			ConstCharPtrFromSPtr(lParam), PositionFromUPtr(wParam));
5394  		return 0;
5395  	case Message::ClearAll:
5396  		ClearAll();
5397  		return 0;
5398  	case Message::DeleteRange:
5399  		pdoc-&gt;DeleteChars(PositionFromUPtr(wParam), lParam);
5400  		return 0;
5401  	case Message::ClearDocumentStyle:
5402  		ClearDocumentStyle();
5403  		return 0;
5404  	case Message::SetUndoCollection:
5405  		pdoc-&gt;SetUndoCollection(wParam != 0);
5406  		return 0;
5407  	case Message::GetUndoCollection:
5408  		return pdoc-&gt;IsCollectingUndo();
5409  	case Message::BeginUndoAction:
5410  		pdoc-&gt;BeginUndoAction();
5411  		return 0;
5412  	case Message::EndUndoAction:
5413  		pdoc-&gt;EndUndoAction();
5414  		return 0;
5415  	case Message::GetCaretPeriod:
5416  		return caret.period;
5417  	case Message::SetCaretPeriod:
5418  		CaretSetPeriod(static_cast&lt;int&gt;(wParam));
5419  		break;
5420  	case Message::GetWordChars:
5421  		return pdoc-&gt;GetCharsOfClass(CharacterClass::word, UCharPtrFromSPtr(lParam));
5422  	case Message::SetWordChars: {
5423  			pdoc-&gt;SetDefaultCharClasses(false);
5424  			if (lParam == 0)
5425  				return 0;
5426  			pdoc-&gt;SetCharClasses(ConstUCharPtrFromSPtr(lParam), CharacterClass::word);
5427  		}
5428  		break;
5429  	case Message::GetWhitespaceChars:
5430  		return pdoc-&gt;GetCharsOfClass(CharacterClass::space, UCharPtrFromSPtr(lParam));
5431  	case Message::SetWhitespaceChars: {
5432  			if (lParam == 0)
5433  				return 0;
5434  			pdoc-&gt;SetCharClasses(ConstUCharPtrFromSPtr(lParam), CharacterClass::space);
5435  		}
5436  		break;
5437  	case Message::GetPunctuationChars:
5438  		return pdoc-&gt;GetCharsOfClass(CharacterClass::punctuation, UCharPtrFromSPtr(lParam));
5439  	case Message::SetPunctuationChars: {
5440  			if (lParam == 0)
5441  				return 0;
5442  			pdoc-&gt;SetCharClasses(ConstUCharPtrFromSPtr(lParam), CharacterClass::punctuation);
5443  		}
5444  		break;
5445  	case Message::SetCharsDefault:
5446  		pdoc-&gt;SetDefaultCharClasses(true);
5447  		break;
5448  	case Message::SetCharacterCategoryOptimization:
5449  		pdoc-&gt;SetCharacterCategoryOptimization(static_cast&lt;int&gt;(wParam));
5450  		break;
5451  	case Message::GetCharacterCategoryOptimization:
5452  		return pdoc-&gt;CharacterCategoryOptimization();
5453  	case Message::GetLength:
5454  		return pdoc-&gt;Length();
5455  	case Message::Allocate:
5456  		pdoc-&gt;Allocate(PositionFromUPtr(wParam));
5457  		break;
5458  	case Message::GetCharAt:
5459  		return pdoc-&gt;CharAt(PositionFromUPtr(wParam));
5460  	case Message::SetCurrentPos:
5461  		if (sel.IsRectangular()) {
5462  			sel.Rectangular().caret.SetPosition(PositionFromUPtr(wParam));
5463  			SetRectangularRange();
5464  			Redraw();
5465  		} else {
5466  			SetSelection(PositionFromUPtr(wParam), sel.MainAnchor());
5467  		}
5468  		break;
5469  	case Message::GetCurrentPos:
5470  		return sel.IsRectangular() ? sel.Rectangular().caret.Position() : sel.MainCaret();
5471  	case Message::SetAnchor:
5472  		if (sel.IsRectangular()) {
5473  			sel.Rectangular().anchor.SetPosition(PositionFromUPtr(wParam));
5474  			SetRectangularRange();
5475  			Redraw();
5476  		} else {
5477  			SetSelection(sel.MainCaret(), PositionFromUPtr(wParam));
5478  		}
5479  		break;
5480  	case Message::GetAnchor:
5481  		return sel.IsRectangular() ? sel.Rectangular().anchor.Position() : sel.MainAnchor();
5482  	case Message::SetSelectionStart:
5483  		SetSelection(std::max(sel.MainCaret(), PositionFromUPtr(wParam)), PositionFromUPtr(wParam));
5484  		break;
5485  	case Message::GetSelectionStart:
5486  		return sel.LimitsForRectangularElseMain().start.Position();
5487  	case Message::SetSelectionEnd:
5488  		SetSelection(PositionFromUPtr(wParam), std::min(sel.MainAnchor(), PositionFromUPtr(wParam)));
5489  		break;
5490  	case Message::GetSelectionEnd:
5491  		return sel.LimitsForRectangularElseMain().end.Position();
5492  	case Message::SetEmptySelection:
5493  		SetEmptySelection(PositionFromUPtr(wParam));
5494  		break;
5495  	case Message::SetPrintMagnification:
5496  		view.printParameters.magnification = static_cast&lt;int&gt;(wParam);
5497  		break;
5498  	case Message::GetPrintMagnification:
5499  		return view.printParameters.magnification;
5500  	case Message::SetPrintColourMode:
5501  		view.printParameters.colourMode = static_cast&lt;PrintOption&gt;(wParam);
5502  		break;
5503  	case Message::GetPrintColourMode:
5504  		return static_cast&lt;sptr_t&gt;(view.printParameters.colourMode);
5505  	case Message::SetPrintWrapMode:
5506  		view.printParameters.wrapState = (static_cast&lt;Wrap&gt;(wParam) == Wrap::Word) ? Wrap::Word : Wrap::None;
5507  		break;
5508  	case Message::GetPrintWrapMode:
5509  		return static_cast&lt;sptr_t&gt;(view.printParameters.wrapState);
5510  	case Message::GetStyleAt:
5511  		if (PositionFromUPtr(wParam) &gt;= pdoc-&gt;Length())
5512  			return 0;
5513  		else
5514  			return pdoc-&gt;StyleAt(PositionFromUPtr(wParam));
5515  	case Message::GetStyleIndexAt:
5516  		if (PositionFromUPtr(wParam) &gt;= pdoc-&gt;Length())
5517  			return 0;
5518  		else
5519  			return pdoc-&gt;StyleIndexAt(PositionFromUPtr(wParam));
5520  	case Message::Redo:
5521  		Redo();
5522  		break;
5523  	case Message::SelectAll:
5524  		SelectAll();
5525  		break;
5526  	case Message::SetSavePoint:
5527  		pdoc-&gt;SetSavePoint();
5528  		break;
5529  	case Message::GetStyledText:
5530  		if (TextRange *tr = static_cast&lt;TextRange *&gt;(PtrFromSPtr(lParam))) {
5531  			return GetStyledText(tr-&gt;lpstrText, tr-&gt;chrg.cpMin, tr-&gt;chrg.cpMax);
5532  		}
5533  		return 0;
5534  	case Message::GetStyledTextFull:
5535  		if (TextRangeFull *tr = static_cast&lt;TextRangeFull *&gt;(PtrFromSPtr(lParam))) {
5536  			return GetStyledText(tr-&gt;lpstrText, tr-&gt;chrg.cpMin, tr-&gt;chrg.cpMax);
5537  		}
5538  		return 0;
5539  	case Message::CanRedo:
5540  		return (pdoc-&gt;CanRedo() &amp;&amp; !pdoc-&gt;IsReadOnly()) ? 1 : 0;
5541  	case Message::MarkerLineFromHandle:
5542  		return pdoc-&gt;LineFromHandle(static_cast&lt;int&gt;(wParam));
5543  	case Message::MarkerDeleteHandle:
5544  		pdoc-&gt;DeleteMarkFromHandle(static_cast&lt;int&gt;(wParam));
5545  		break;
5546  	case Message::MarkerHandleFromLine:
5547  		return pdoc-&gt;MarkerHandleFromLine(LineFromUPtr(wParam), static_cast&lt;int&gt;(lParam));
5548  	case Message::MarkerNumberFromLine:
5549  		return pdoc-&gt;MarkerNumberFromLine(LineFromUPtr(wParam), static_cast&lt;int&gt;(lParam));
5550  	case Message::GetViewWS:
5551  		return static_cast&lt;sptr_t&gt;(vs.viewWhitespace);
5552  	case Message::SetViewWS:
5553  		vs.viewWhitespace = static_cast&lt;WhiteSpace&gt;(wParam);
5554  		Redraw();
5555  		break;
5556  	case Message::GetTabDrawMode:
5557  		return static_cast&lt;sptr_t&gt;(vs.tabDrawMode);
5558  	case Message::SetTabDrawMode:
5559  		vs.tabDrawMode = static_cast&lt;TabDrawMode&gt;(wParam);
5560  		Redraw();
5561  		break;
5562  	case Message::GetWhitespaceSize:
5563  		return vs.whitespaceSize;
5564  	case Message::SetWhitespaceSize:
5565  		vs.whitespaceSize = static_cast&lt;int&gt;(wParam);
5566  		Redraw();
5567  		break;
5568  	case Message::PositionFromPoint:
5569  		return PositionFromLocation(PointFromParameters(wParam, lParam), false, false);
5570  	case Message::PositionFromPointClose:
5571  		return PositionFromLocation(PointFromParameters(wParam, lParam), true, false);
5572  	case Message::CharPositionFromPoint:
5573  		return PositionFromLocation(PointFromParameters(wParam, lParam), false, true);
5574  	case Message::CharPositionFromPointClose:
5575  		return PositionFromLocation(PointFromParameters(wParam, lParam), true, true);
5576  	case Message::GotoLine:
5577  		GoToLine(LineFromUPtr(wParam));
5578  		break;
5579  	case Message::GotoPos:
5580  		SetEmptySelection(PositionFromUPtr(wParam));
5581  		EnsureCaretVisible();
5582  		break;
5583  	case Message::GetCurLine: {
5584  			const Sci::Line lineCurrentPos = pdoc-&gt;SciLineFromPosition(sel.MainCaret());
5585  			const Sci::Position lineStart = pdoc-&gt;LineStart(lineCurrentPos);
5586  			const Sci::Position lineEnd = pdoc-&gt;LineStart(lineCurrentPos + 1);
5587  			if (lParam == 0) {
5588  				return lineEnd - lineStart;
5589  			}
5590  			char *ptr = CharPtrFromSPtr(lParam);
5591  			const Sci::Position len = std::min&lt;uptr_t&gt;(lineEnd - lineStart, wParam);
5592  			pdoc-&gt;GetCharRange(ptr, lineStart, len);
5593  			ptr[len] = &#x27;\0&#x27;;
5594  			return sel.MainCaret() - lineStart;
5595  		}
5596  	case Message::GetEndStyled:
5597  		return pdoc-&gt;GetEndStyled();
5598  	case Message::GetEOLMode:
5599  		return static_cast&lt;sptr_t&gt;(pdoc-&gt;eolMode);
5600  	case Message::SetEOLMode:
5601  		pdoc-&gt;eolMode = static_cast&lt;EndOfLine&gt;(wParam);
5602  		break;
5603  	case Message::SetLineEndTypesAllowed:
5604  		if (pdoc-&gt;SetLineEndTypesAllowed(static_cast&lt;LineEndType&gt;(wParam))) {
5605  			pcs-&gt;Clear();
5606  			pcs-&gt;InsertLines(0, pdoc-&gt;LinesTotal() - 1);
5607  			SetAnnotationHeights(0, pdoc-&gt;LinesTotal());
5608  			InvalidateStyleRedraw();
5609  		}
5610  		break;
5611  	case Message::GetLineEndTypesAllowed:
5612  		return static_cast&lt;sptr_t&gt;(pdoc-&gt;GetLineEndTypesAllowed());
5613  	case Message::GetLineEndTypesActive:
5614  		return static_cast&lt;sptr_t&gt;(pdoc-&gt;GetLineEndTypesActive());
5615  	case Message::StartStyling:
5616  		pdoc-&gt;StartStyling(PositionFromUPtr(wParam));
5617  		break;
5618  	case Message::SetStyling:
5619  		if (PositionFromUPtr(wParam) &lt; 0)
5620  			errorStatus = Status::Failure;
5621  		else
5622  			pdoc-&gt;SetStyleFor(PositionFromUPtr(wParam), static_cast&lt;char&gt;(lParam));
5623  		break;
5624  	case Message::SetStylingEx:             
5625  		if (lParam == 0)
5626  			return 0;
5627  		pdoc-&gt;SetStyles(PositionFromUPtr(wParam), ConstCharPtrFromSPtr(lParam));
5628  		break;
5629  	case Message::SetBufferedDraw:
5630  		view.bufferedDraw = wParam != 0;
5631  		break;
5632  	case Message::GetBufferedDraw:
5633  		return view.bufferedDraw;
5634  #ifdef INCLUDE_DEPRECATED_FEATURES
5635  	case SCI_GETTWOPHASEDRAW:
5636  		return view.phasesDraw == EditView::phasesTwo;
5637  	case SCI_SETTWOPHASEDRAW:
5638  		if (view.SetTwoPhaseDraw(wParam != 0))
5639  			InvalidateStyleRedraw();
5640  		break;
5641  #endif
5642  	case Message::GetPhasesDraw:
5643  		return static_cast&lt;sptr_t&gt;(view.phasesDraw);
5644  	case Message::SetPhasesDraw:
5645  		if (view.SetPhasesDraw(static_cast&lt;int&gt;(wParam)))
5646  			InvalidateStyleRedraw();
5647  		break;
5648  	case Message::SetFontQuality:
5649  		vs.extraFontFlag = static_cast&lt;FontQuality&gt;(
5650  			(static_cast&lt;int&gt;(vs.extraFontFlag) &amp; ~static_cast&lt;int&gt;(FontQuality::QualityMask)) |
5651  			(wParam &amp; static_cast&lt;int&gt;(FontQuality::QualityMask)));
5652  		InvalidateStyleRedraw();
5653  		break;
5654  	case Message::GetFontQuality:
5655  		return static_cast&lt;int&gt;(vs.extraFontFlag) &amp; static_cast&lt;int&gt;(FontQuality::QualityMask);
5656  	case Message::SetTabWidth:
5657  		if (wParam &gt; 0) {
5658  			pdoc-&gt;tabInChars = static_cast&lt;int&gt;(wParam);
5659  			if (pdoc-&gt;indentInChars == 0)
5660  				pdoc-&gt;actualIndentInChars = pdoc-&gt;tabInChars;
5661  		}
5662  		InvalidateStyleRedraw();
5663  		break;
5664  	case Message::GetTabWidth:
5665  		return pdoc-&gt;tabInChars;
5666  	case Message::SetTabMinimumWidth:
5667  		SetAppearance(view.tabWidthMinimumPixels, static_cast&lt;int&gt;(wParam));
5668  		break;
5669  	case Message::GetTabMinimumWidth:
5670  		return view.tabWidthMinimumPixels;
5671  	case Message::ClearTabStops:
5672  		if (view.ClearTabstops(LineFromUPtr(wParam))) {
5673  			const DocModification mh(ModificationFlags::ChangeTabStops, 0, 0, 0, nullptr, LineFromUPtr(wParam));
5674  			NotifyModified(pdoc, mh, nullptr);
5675  		}
5676  		break;
5677  	case Message::AddTabStop:
5678  		if (view.AddTabstop(LineFromUPtr(wParam), static_cast&lt;int&gt;(lParam))) {
5679  			const DocModification mh(ModificationFlags::ChangeTabStops, 0, 0, 0, nullptr, LineFromUPtr(wParam));
5680  			NotifyModified(pdoc, mh, nullptr);
5681  		}
5682  		break;
5683  	case Message::GetNextTabStop:
5684  		return view.GetNextTabstop(LineFromUPtr(wParam), static_cast&lt;int&gt;(lParam));
5685  	case Message::SetIndent:
5686  		pdoc-&gt;indentInChars = static_cast&lt;int&gt;(wParam);
5687  		if (pdoc-&gt;indentInChars != 0)
5688  			pdoc-&gt;actualIndentInChars = pdoc-&gt;indentInChars;
5689  		else
5690  			pdoc-&gt;actualIndentInChars = pdoc-&gt;tabInChars;
5691  		InvalidateStyleRedraw();
5692  		break;
5693  	case Message::GetIndent:
5694  		return pdoc-&gt;indentInChars;
5695  	case Message::SetUseTabs:
5696  		pdoc-&gt;useTabs = wParam != 0;
5697  		InvalidateStyleRedraw();
5698  		break;
5699  	case Message::GetUseTabs:
5700  		return pdoc-&gt;useTabs;
5701  	case Message::SetLineIndentation:
5702  		pdoc-&gt;SetLineIndentation(LineFromUPtr(wParam), lParam);
5703  		break;
5704  	case Message::GetLineIndentation:
5705  		return pdoc-&gt;GetLineIndentation(LineFromUPtr(wParam));
5706  	case Message::GetLineIndentPosition:
5707  		return pdoc-&gt;GetLineIndentPosition(LineFromUPtr(wParam));
5708  	case Message::SetTabIndents:
5709  		pdoc-&gt;tabIndents = wParam != 0;
5710  		break;
5711  	case Message::GetTabIndents:
5712  		return pdoc-&gt;tabIndents;
5713  	case Message::SetBackSpaceUnIndents:
5714  		pdoc-&gt;backspaceUnindents = wParam != 0;
5715  		break;
5716  	case Message::GetBackSpaceUnIndents:
5717  		return pdoc-&gt;backspaceUnindents;
5718  	case Message::SetMouseDwellTime:
5719  		dwellDelay = static_cast&lt;int&gt;(wParam);
5720  		ticksToDwell = dwellDelay;
5721  		break;
5722  	case Message::GetMouseDwellTime:
5723  		return dwellDelay;
5724  	case Message::WordStartPosition:
5725  		return pdoc-&gt;ExtendWordSelect(PositionFromUPtr(wParam), -1, lParam != 0);
5726  	case Message::WordEndPosition:
5727  		return pdoc-&gt;ExtendWordSelect(PositionFromUPtr(wParam), 1, lParam != 0);
5728  	case Message::IsRangeWord:
5729  		return pdoc-&gt;IsWordAt(PositionFromUPtr(wParam), lParam);
5730  	case Message::SetIdleStyling:
5731  		idleStyling = static_cast&lt;IdleStyling&gt;(wParam);
5732  		break;
5733  	case Message::GetIdleStyling:
5734  		return static_cast&lt;sptr_t&gt;(idleStyling);
5735  	case Message::SetWrapMode:
5736  		if (vs.SetWrapState(static_cast&lt;Wrap&gt;(wParam))) {
5737  			xOffset = 0;
5738  			ContainerNeedsUpdate(Update::HScroll);
5739  			InvalidateStyleRedraw();
5740  			ReconfigureScrollBars();
5741  		}
5742  		break;
5743  	case Message::GetWrapMode:
5744  		return static_cast&lt;sptr_t&gt;(vs.wrap.state);
5745  	case Message::SetWrapVisualFlags:
5746  		if (vs.SetWrapVisualFlags(static_cast&lt;WrapVisualFlag&gt;(wParam))) {
5747  			InvalidateStyleRedraw();
5748  			ReconfigureScrollBars();
5749  		}
5750  		break;
5751  	case Message::GetWrapVisualFlags:
5752  		return static_cast&lt;sptr_t&gt;(vs.wrap.visualFlags);
5753  	case Message::SetWrapVisualFlagsLocation:
5754  		if (vs.SetWrapVisualFlagsLocation(static_cast&lt;WrapVisualLocation&gt;(wParam))) {
5755  			InvalidateStyleRedraw();
5756  		}
5757  		break;
5758  	case Message::GetWrapVisualFlagsLocation:
5759  		return static_cast&lt;sptr_t&gt;(vs.wrap.visualFlagsLocation);
5760  	case Message::SetWrapStartIndent:
5761  		if (vs.SetWrapVisualStartIndent(static_cast&lt;int&gt;(wParam))) {
5762  			InvalidateStyleRedraw();
5763  			ReconfigureScrollBars();
5764  		}
5765  		break;
5766  	case Message::GetWrapStartIndent:
5767  		return vs.wrap.visualStartIndent;
5768  	case Message::SetWrapIndentMode:
5769  		if (vs.SetWrapIndentMode(static_cast&lt;WrapIndentMode&gt;(wParam))) {
5770  			InvalidateStyleRedraw();
5771  			ReconfigureScrollBars();
5772  		}
5773  		break;
5774  	case Message::GetWrapIndentMode:
5775  		return static_cast&lt;sptr_t&gt;(vs.wrap.indentMode);
5776  	case Message::SetLayoutCache:
5777  		if (static_cast&lt;LineCache&gt;(wParam) &lt;= LineCache::Document) {
5778  			view.llc.SetLevel(static_cast&lt;LineCache&gt;(wParam));
5779  		}
5780  		break;
5781  	case Message::GetLayoutCache:
5782  		return static_cast&lt;sptr_t&gt;(view.llc.GetLevel());
5783  	case Message::SetPositionCache:
5784  		view.posCache-&gt;SetSize(wParam);
5785  		break;
5786  	case Message::GetPositionCache:
5787  		return view.posCache-&gt;GetSize();
5788  	case Message::SetLayoutThreads:
5789  		view.SetLayoutThreads(static_cast&lt;unsigned int&gt;(wParam));
5790  		break;
5791  	case Message::GetLayoutThreads:
5792  		return view.GetLayoutThreads();
5793  	case Message::SetScrollWidth:
5794  		PLATFORM_ASSERT(wParam &gt; 0);
5795  		if ((wParam &gt; 0) &amp;&amp; (wParam != static_cast&lt;unsigned int&gt;(scrollWidth))) {
5796  			view.lineWidthMaxSeen = 0;
5797  			scrollWidth = static_cast&lt;int&gt;(wParam);
5798  			SetScrollBars();
5799  		}
5800  		break;
5801  	case Message::GetScrollWidth:
5802  		return scrollWidth;
5803  	case Message::SetScrollWidthTracking:
5804  		trackLineWidth = wParam != 0;
5805  		break;
5806  	case Message::GetScrollWidthTracking:
5807  		return trackLineWidth;
5808  	case Message::LinesJoin:
5809  		LinesJoin();
5810  		break;
5811  	case Message::LinesSplit:
5812  		LinesSplit(static_cast&lt;int&gt;(wParam));
5813  		break;
5814  	case Message::TextWidth:
5815  		PLATFORM_ASSERT(wParam &lt; vs.styles.size());
5816  		PLATFORM_ASSERT(lParam);
5817  		return TextWidth(wParam, ConstCharPtrFromSPtr(lParam));
5818  	case Message::TextHeight:
5819  		RefreshStyleData();
5820  		return vs.lineHeight;
5821  	case Message::SetEndAtLastLine:
5822  		PLATFORM_ASSERT((wParam == 0) || (wParam == 1));
5823  		if (endAtLastLine != (wParam != 0)) {
5824  			endAtLastLine = wParam != 0;
5825  			SetScrollBars();
5826  		}
5827  		break;
5828  	case Message::GetEndAtLastLine:
5829  		return endAtLastLine;
5830  	case Message::SetCaretSticky:
5831  		PLATFORM_ASSERT(static_cast&lt;CaretSticky&gt;(wParam) &lt;= CaretSticky::WhiteSpace);
5832  		if (static_cast&lt;CaretSticky&gt;(wParam) &lt;= CaretSticky::WhiteSpace) {
5833  			caretSticky = static_cast&lt;CaretSticky&gt;(wParam);
5834  		}
5835  		break;
5836  	case Message::GetCaretSticky:
5837  		return static_cast&lt;sptr_t&gt;(caretSticky);
5838  	case Message::ToggleCaretSticky:
5839  		caretSticky = (caretSticky == CaretSticky::Off) ? CaretSticky::On : CaretSticky::Off;
5840  		break;
5841  	case Message::GetColumn:
5842  		return pdoc-&gt;GetColumn(PositionFromUPtr(wParam));
5843  	case Message::FindColumn:
5844  		return pdoc-&gt;FindColumn(LineFromUPtr(wParam), lParam);
5845  	case Message::SetHScrollBar :
5846  		if (horizontalScrollBarVisible != (wParam != 0)) {
5847  			horizontalScrollBarVisible = wParam != 0;
5848  			SetScrollBars();
5849  			ReconfigureScrollBars();
5850  		}
5851  		break;
5852  	case Message::GetHScrollBar:
5853  		return horizontalScrollBarVisible;
5854  	case Message::SetVScrollBar:
5855  		if (verticalScrollBarVisible != (wParam != 0)) {
5856  			verticalScrollBarVisible = wParam != 0;
5857  			SetScrollBars();
5858  			ReconfigureScrollBars();
5859  			if (verticalScrollBarVisible)
5860  				SetVerticalScrollPos();
5861  		}
5862  		break;
5863  	case Message::GetVScrollBar:
5864  		return verticalScrollBarVisible;
5865  	case Message::SetIndentationGuides:
5866  		vs.viewIndentationGuides = static_cast&lt;IndentView&gt;(wParam);
5867  		Redraw();
5868  		break;
5869  	case Message::GetIndentationGuides:
5870  		return static_cast&lt;sptr_t&gt;(vs.viewIndentationGuides);
5871  	case Message::SetHighlightGuide:
5872  		if ((highlightGuideColumn != static_cast&lt;int&gt;(wParam)) || (wParam &gt; 0)) {
5873  			highlightGuideColumn = static_cast&lt;int&gt;(wParam);
5874  			Redraw();
5875  		}
5876  		break;
5877  	case Message::GetHighlightGuide:
5878  		return highlightGuideColumn;
5879  	case Message::GetLineEndPosition:
5880  		return pdoc-&gt;LineEnd(LineFromUPtr(wParam));
5881  	case Message::SetCodePage:
5882  		if (ValidCodePage(static_cast&lt;int&gt;(wParam))) {
5883  			if (pdoc-&gt;SetDBCSCodePage(static_cast&lt;int&gt;(wParam))) {
5884  				pcs-&gt;Clear();
5885  				pcs-&gt;InsertLines(0, pdoc-&gt;LinesTotal() - 1);
5886  				SetAnnotationHeights(0, pdoc-&gt;LinesTotal());
5887  				InvalidateStyleRedraw();
5888  				SetRepresentations();
5889  			}
5890  		}
5891  		break;
5892  	case Message::GetCodePage:
5893  		return pdoc-&gt;dbcsCodePage;
5894  	case Message::SetIMEInteraction:
5895  		imeInteraction = static_cast&lt;IMEInteraction&gt;(wParam);
5896  		break;
5897  	case Message::GetIMEInteraction:
5898  		return static_cast&lt;sptr_t&gt;(imeInteraction);
5899  	case Message::SetBidirectional:
5900  		break;
5901  	case Message::GetBidirectional:
5902  		return static_cast&lt;sptr_t&gt;(bidirectional);
5903  	case Message::GetLineCharacterIndex:
5904  		return static_cast&lt;sptr_t&gt;(pdoc-&gt;LineCharacterIndex());
5905  	case Message::AllocateLineCharacterIndex:
5906  		pdoc-&gt;AllocateLineCharacterIndex(static_cast&lt;LineCharacterIndexType&gt;(wParam));
5907  		break;
5908  	case Message::ReleaseLineCharacterIndex:
5909  		pdoc-&gt;ReleaseLineCharacterIndex(static_cast&lt;LineCharacterIndexType&gt;(wParam));
5910  		break;
5911  	case Message::LineFromIndexPosition:
5912  		return pdoc-&gt;LineFromPositionIndex(PositionFromUPtr(wParam), static_cast&lt;LineCharacterIndexType&gt;(lParam));
5913  	case Message::IndexPositionFromLine:
5914  		return pdoc-&gt;IndexLineStart(LineFromUPtr(wParam), static_cast&lt;LineCharacterIndexType&gt;(lParam));
5915  	case Message::MarkerDefine:
5916  		if (wParam &lt;= MarkerMax) {
5917  			vs.markers[wParam].markType = static_cast&lt;MarkerSymbol&gt;(lParam);
5918  			vs.CalcLargestMarkerHeight();
5919  		}
5920  		InvalidateStyleData();
5921  		RedrawSelMargin();
5922  		break;
5923  	case Message::MarkerSymbolDefined:
5924  		if (wParam &lt;= MarkerMax)
5925  			return static_cast&lt;sptr_t&gt;(vs.markers[wParam].markType);
5926  		else
5927  			return 0;
5928  	case Message::MarkerSetFore:
5929  		if (wParam &lt;= MarkerMax)
5930  			vs.markers[wParam].fore = ColourRGBA::FromIpRGB(lParam);
5931  		InvalidateStyleData();
5932  		RedrawSelMargin();
5933  		break;
5934  	case Message::MarkerSetBack:
5935  		if (wParam &lt;= MarkerMax)
5936  			vs.markers[wParam].back = ColourRGBA::FromIpRGB(lParam);
5937  		InvalidateStyleData();
5938  		RedrawSelMargin();
5939  		break;
5940  	case Message::MarkerSetBackSelected:
5941  		if (wParam &lt;= MarkerMax)
5942  			vs.markers[wParam].backSelected = ColourRGBA::FromIpRGB(lParam);
5943  		InvalidateStyleData();
5944  		RedrawSelMargin();
5945  		break;
5946  	case Message::MarkerSetForeTranslucent:
5947  		if (wParam &lt;= MarkerMax)
5948  			vs.markers[wParam].fore = ColourRGBA(static_cast&lt;int&gt;(lParam));
5949  		InvalidateStyleData();
5950  		RedrawSelMargin();
5951  		break;
5952  	case Message::MarkerSetBackTranslucent:
5953  		if (wParam &lt;= MarkerMax)
5954  			vs.markers[wParam].back = ColourRGBA(static_cast&lt;int&gt;(lParam));
5955  		InvalidateStyleData();
5956  		RedrawSelMargin();
5957  		break;
5958  	case Message::MarkerSetBackSelectedTranslucent:
5959  		if (wParam &lt;= MarkerMax)
5960  			vs.markers[wParam].backSelected = ColourRGBA(static_cast&lt;int&gt;(lParam));
5961  		InvalidateStyleData();
5962  		RedrawSelMargin();
5963  		break;
5964  	case Message::MarkerSetStrokeWidth:
5965  		if (wParam &lt;= MarkerMax)
5966  			vs.markers[wParam].strokeWidth = lParam / 100.0f;
5967  		InvalidateStyleData();
5968  		RedrawSelMargin();
5969  		break;
5970  	case Message::MarkerEnableHighlight:
5971  		marginView.highlightDelimiter.isEnabled = wParam == 1;
5972  		RedrawSelMargin();
5973  		break;
5974  	case Message::MarkerSetAlpha:
5975  		if (wParam &lt;= MarkerMax) {
5976  			if (static_cast&lt;Alpha&gt;(lParam) == Alpha::NoAlpha) {
5977  				SetAppearance(vs.markers[wParam].alpha, Alpha::Opaque);
5978  				SetAppearance(vs.markers[wParam].layer, Layer::Base);
5979  			} else {
5980  				SetAppearance(vs.markers[wParam].alpha, static_cast&lt;Alpha&gt;(lParam));
5981  				SetAppearance(vs.markers[wParam].layer, Layer::OverText);
5982  			}
5983  		}
5984  		break;
5985  	case Message::MarkerSetLayer:
5986  		if (wParam &lt;= MarkerMax) {
5987  			SetAppearance(vs.markers[wParam].layer, static_cast&lt;Layer&gt;(lParam));
5988  		}
5989  		break;
5990  	case Message::MarkerGetLayer:
5991  		if (wParam &lt;= MarkerMax) {
5992  			return static_cast&lt;sptr_t&gt;(vs.markers[wParam].layer);
5993  		}
5994  		return 0;
5995  	case Message::MarkerAdd: {
5996  			const int markerID = pdoc-&gt;AddMark(LineFromUPtr(wParam), static_cast&lt;int&gt;(lParam));
5997  			return markerID;
5998  		}
5999  	case Message::MarkerAddSet:
6000  		if (lParam != 0)
6001  			pdoc-&gt;AddMarkSet(LineFromUPtr(wParam), static_cast&lt;int&gt;(lParam));
6002  		break;
6003  	case Message::MarkerDelete:
6004  		pdoc-&gt;DeleteMark(LineFromUPtr(wParam), static_cast&lt;int&gt;(lParam));
6005  		break;
6006  	case Message::MarkerDeleteAll:
6007  		pdoc-&gt;DeleteAllMarks(static_cast&lt;int&gt;(wParam));
6008  		break;
6009  	case Message::MarkerGet:
6010  		return GetMark(LineFromUPtr(wParam));
6011  	case Message::MarkerNext:
6012  		return pdoc-&gt;MarkerNext(LineFromUPtr(wParam), static_cast&lt;int&gt;(lParam));
6013  	case Message::MarkerPrevious: {
6014  			for (Sci::Line iLine = LineFromUPtr(wParam); iLine &gt;= 0; iLine--) {
6015  				if ((GetMark(iLine) &amp; lParam) != 0)
6016  					return iLine;
6017  			}
6018  		}
6019  		return -1;
6020  	case Message::MarkerDefinePixmap:
6021  		if (wParam &lt;= MarkerMax) {
6022  			vs.markers[wParam].SetXPM(ConstCharPtrFromSPtr(lParam));
6023  			vs.CalcLargestMarkerHeight();
6024  		}
6025  		InvalidateStyleData();
6026  		RedrawSelMargin();
6027  		break;
6028  	case Message::RGBAImageSetWidth:
6029  		sizeRGBAImage.x = static_cast&lt;XYPOSITION&gt;(wParam);
6030  		break;
6031  	case Message::RGBAImageSetHeight:
6032  		sizeRGBAImage.y = static_cast&lt;XYPOSITION&gt;(wParam);
6033  		break;
6034  	case Message::RGBAImageSetScale:
6035  		scaleRGBAImage = static_cast&lt;float&gt;(wParam);
6036  		break;
6037  	case Message::MarkerDefineRGBAImage:
6038  		if (wParam &lt;= MarkerMax) {
6039  			vs.markers[wParam].SetRGBAImage(sizeRGBAImage, scaleRGBAImage / 100.0f, ConstUCharPtrFromSPtr(lParam));
6040  			vs.CalcLargestMarkerHeight();
6041  		}
6042  		InvalidateStyleData();
6043  		RedrawSelMargin();
6044  		break;
6045  	case Message::SetMarginTypeN:
6046  		if (ValidMargin(wParam)) {
6047  			vs.ms[wParam].style = static_cast&lt;MarginType&gt;(lParam);
6048  			InvalidateStyleRedraw();
6049  		}
6050  		break;
6051  	case Message::GetMarginTypeN:
6052  		if (ValidMargin(wParam))
6053  			return static_cast&lt;sptr_t&gt;(vs.ms[wParam].style);
6054  		else
6055  			return 0;
6056  	case Message::SetMarginWidthN:
6057  		if (ValidMargin(wParam)) {
6058  			if (vs.ms[wParam].width != lParam) {
6059  				lastXChosen += static_cast&lt;int&gt;(lParam) - vs.ms[wParam].width;
6060  				vs.ms[wParam].width = static_cast&lt;int&gt;(lParam);
6061  				InvalidateStyleRedraw();
6062  			}
6063  		}
6064  		break;
6065  	case Message::GetMarginWidthN:
6066  		if (ValidMargin(wParam))
6067  			return vs.ms[wParam].width;
6068  		else
6069  			return 0;
6070  	case Message::SetMarginMaskN:
6071  		if (ValidMargin(wParam)) {
6072  			vs.ms[wParam].mask = static_cast&lt;int&gt;(lParam);
6073  			InvalidateStyleRedraw();
6074  		}
6075  		break;
6076  	case Message::GetMarginMaskN:
6077  		if (ValidMargin(wParam))
6078  			return vs.ms[wParam].mask;
6079  		else
6080  			return 0;
6081  	case Message::SetMarginSensitiveN:
6082  		if (ValidMargin(wParam)) {
6083  			vs.ms[wParam].sensitive = lParam != 0;
6084  			InvalidateStyleRedraw();
6085  		}
6086  		break;
6087  	case Message::GetMarginSensitiveN:
6088  		if (ValidMargin(wParam))
6089  			return vs.ms[wParam].sensitive ? 1 : 0;
6090  		else
6091  			return 0;
6092  	case Message::SetMarginCursorN:
6093  		if (ValidMargin(wParam))
6094  			vs.ms[wParam].cursor = static_cast&lt;CursorShape&gt;(lParam);
6095  		break;
6096  	case Message::GetMarginCursorN:
6097  		if (ValidMargin(wParam))
6098  			return static_cast&lt;sptr_t&gt;(vs.ms[wParam].cursor);
6099  		else
6100  			return 0;
6101  	case Message::SetMarginBackN:
6102  		if (ValidMargin(wParam)) {
6103  			vs.ms[wParam].back = ColourRGBA::FromIpRGB(lParam);
6104  			InvalidateStyleRedraw();
6105  		}
6106  		break;
6107  	case Message::GetMarginBackN:
6108  		if (ValidMargin(wParam))
6109  			return vs.ms[wParam].back.OpaqueRGB();
6110  		else
6111  			return 0;
6112  	case Message::SetMargins:
6113  		if (wParam &lt; 1000)
6114  			vs.ms.resize(wParam);
6115  		break;
6116  	case Message::GetMargins:
6117  		return vs.ms.size();
6118  	case Message::StyleClearAll:
6119  		vs.ClearStyles();
6120  		InvalidateStyleRedraw();
6121  		break;
6122  	case Message::StyleSetFore:
6123  	case Message::StyleSetBack:
6124  	case Message::StyleSetBold:
6125  	case Message::StyleSetWeight:
6126  	case Message::StyleSetItalic:
6127  	case Message::StyleSetEOLFilled:
6128  	case Message::StyleSetSize:
6129  	case Message::StyleSetSizeFractional:
6130  	case Message::StyleSetFont:
6131  	case Message::StyleSetUnderline:
6132  	case Message::StyleSetCase:
6133  	case Message::StyleSetCharacterSet:
6134  	case Message::StyleSetVisible:
6135  	case Message::StyleSetChangeable:
6136  	case Message::StyleSetHotSpot:
6137  	case Message::StyleSetCheckMonospaced:
6138  	case Message::StyleSetInvisibleRepresentation:
6139  		StyleSetMessage(iMessage, wParam, lParam);
6140  		break;
6141  	case Message::StyleGetFore:
6142  	case Message::StyleGetBack:
6143  	case Message::StyleGetBold:
6144  	case Message::StyleGetWeight:
6145  	case Message::StyleGetItalic:
6146  	case Message::StyleGetEOLFilled:
6147  	case Message::StyleGetSize:
6148  	case Message::StyleGetSizeFractional:
6149  	case Message::StyleGetFont:
6150  	case Message::StyleGetUnderline:
6151  	case Message::StyleGetCase:
6152  	case Message::StyleGetCharacterSet:
6153  	case Message::StyleGetVisible:
6154  	case Message::StyleGetChangeable:
6155  	case Message::StyleGetHotSpot:
6156  	case Message::StyleGetCheckMonospaced:
6157  	case Message::StyleGetInvisibleRepresentation:
6158  		return StyleGetMessage(iMessage, wParam, lParam);
6159  	case Message::StyleResetDefault:
6160  		vs.ResetDefaultStyle();
6161  		InvalidateStyleRedraw();
6162  		break;
6163  	case Message::SetElementColour:
6164  		if (vs.SetElementColour(static_cast&lt;Element&gt;(wParam), ColourRGBA(static_cast&lt;int&gt;(lParam)))) {
6165  			InvalidateStyleRedraw();
6166  		}
6167  		break;
6168  	case Message::GetElementColour:
6169  		return vs.ElementColour(static_cast&lt;Element&gt;(wParam)).value_or(ColourRGBA()).AsInteger();
6170  	case Message::ResetElementColour:
6171  		if (vs.ResetElement(static_cast&lt;Element&gt;(wParam))) {
6172  			InvalidateStyleRedraw();
6173  		}
6174  		break;
6175  	case Message::GetElementIsSet:
6176  		return vs.ElementColour(static_cast&lt;Element&gt;(wParam)).has_value();
6177  	case Message::GetElementAllowsTranslucent:
6178  		return vs.ElementAllowsTranslucent(static_cast&lt;Element&gt;(wParam));
6179  	case Message::GetElementBaseColour:
6180  		return vs.elementBaseColours[static_cast&lt;Element&gt;(wParam)].value_or(ColourRGBA()).AsInteger();
6181  	case Message::SetFontLocale:
6182  		if (lParam) {
6183  			vs.SetFontLocaleName(ConstCharPtrFromSPtr(lParam));
6184  			InvalidateStyleRedraw();
6185  		}
6186  		break;
6187  	case Message::GetFontLocale:
6188  		return StringResult(lParam, vs.localeName.c_str());
6189  #ifdef INCLUDE_DEPRECATED_FEATURES
6190  	case SCI_SETSTYLEBITS:
6191  		vs.EnsureStyle(0xff);
6192  		break;
6193  	case SCI_GETSTYLEBITS:
6194  		return 8;
6195  #endif
6196  	case Message::SetLineState:
6197  		return pdoc-&gt;SetLineState(LineFromUPtr(wParam), static_cast&lt;int&gt;(lParam));
6198  	case Message::GetLineState:
6199  		return pdoc-&gt;GetLineState(LineFromUPtr(wParam));
6200  	case Message::GetMaxLineState:
6201  		return pdoc-&gt;GetMaxLineState();
6202  	case Message::GetCaretLineVisible:
6203  		return vs.ElementColour(Element::CaretLineBack) ? 1 : 0;
6204  	case Message::SetCaretLineVisible:
6205  		if (wParam) {
6206  			if (!vs.elementColours.count(Element::CaretLineBack)) {
6207  				vs.elementColours[Element::CaretLineBack] = ColourRGBA(0xFF, 0xFF, 0);
6208  				InvalidateStyleRedraw();
6209  			}
6210  		} else {
6211  			if (vs.ResetElement(Element::CaretLineBack)) {
6212  				InvalidateStyleRedraw();
6213  			}
6214  		}
6215  		break;
6216  	case Message::GetCaretLineVisibleAlways:
6217  		return vs.caretLine.alwaysShow;
6218  	case Message::SetCaretLineVisibleAlways:
6219  		vs.caretLine.alwaysShow = wParam != 0;
6220  		InvalidateStyleRedraw();
6221  		break;
6222  	case Message::GetCaretLineHighlightSubLine:
6223  		return vs.caretLine.subLine;
6224  	case Message::SetCaretLineHighlightSubLine:
<span onclick='openModal()' class='match'>6225  		vs.caretLine.subLine = wParam != 0;
6226  		InvalidateStyleRedraw();
6227  		break;
6228  	case Message::GetCaretLineFrame:
6229  		return vs.caretLine.frame;
</span>6230  	case Message::SetCaretLineFrame:
6231  		vs.caretLine.frame = static_cast&lt;int&gt;(wParam);
6232  		InvalidateStyleRedraw();
6233  		break;
6234  	case Message::GetCaretLineBack:
6235  		return vs.ElementColourForced(Element::CaretLineBack).OpaqueRGB();
6236  	case Message::SetCaretLineBack:
6237  		vs.SetElementRGB(Element::CaretLineBack, static_cast&lt;int&gt;(wParam));
6238  		InvalidateStyleRedraw();
6239  		break;
6240  	case Message::GetCaretLineLayer:
6241  		return static_cast&lt;sptr_t&gt;(vs.caretLine.layer);
6242  	case Message::SetCaretLineLayer:
6243  		if (vs.caretLine.layer != static_cast&lt;Layer&gt;(wParam)) {
6244  			vs.caretLine.layer = static_cast&lt;Layer&gt;(wParam);
6245  			UpdateBaseElements();
6246  			InvalidateStyleRedraw();
6247  		}
6248  		break;
6249  	case Message::GetCaretLineBackAlpha:
6250  		if (vs.caretLine.layer == Layer::Base)
6251  			return static_cast&lt;sptr_t&gt;(Alpha::NoAlpha);
6252  		return vs.ElementColour(Element::CaretLineBack).value_or(ColourRGBA()).GetAlpha();
6253  	case Message::SetCaretLineBackAlpha: {
6254  			const Layer layerNew = (static_cast&lt;Alpha&gt;(wParam) == Alpha::NoAlpha) ? Layer::Base : Layer::OverText;
6255  			vs.caretLine.layer = layerNew;
6256  			if (vs.ElementColour(Element::CaretLineBack)) {
6257  				vs.SetElementAlpha(Element::CaretLineBack, static_cast&lt;int&gt;(wParam));
6258  			}
6259  			InvalidateStyleRedraw();
6260  		}
6261  		break;
6262  	case Message::VisibleFromDocLine:
6263  		return pcs-&gt;DisplayFromDoc(LineFromUPtr(wParam));
6264  	case Message::DocLineFromVisible:
6265  		return pcs-&gt;DocFromDisplay(LineFromUPtr(wParam));
6266  	case Message::WrapCount:
6267  		return WrapCount(LineFromUPtr(wParam));
6268  	case Message::SetFoldLevel: {
6269  			const int prev = pdoc-&gt;SetLevel(LineFromUPtr(wParam), static_cast&lt;int&gt;(lParam));
6270  			if (prev != static_cast&lt;int&gt;(lParam))
6271  				RedrawSelMargin();
6272  			return prev;
6273  		}
6274  	case Message::GetFoldLevel:
6275  		return pdoc-&gt;GetLevel(LineFromUPtr(wParam));
6276  	case Message::GetLastChild:
6277  		return pdoc-&gt;GetLastChild(LineFromUPtr(wParam), OptionalFoldLevel(lParam));
6278  	case Message::GetFoldParent:
6279  		return pdoc-&gt;GetFoldParent(LineFromUPtr(wParam));
6280  	case Message::ShowLines:
6281  		pcs-&gt;SetVisible(LineFromUPtr(wParam), lParam, true);
6282  		SetScrollBars();
6283  		Redraw();
6284  		break;
6285  	case Message::HideLines:
6286  		pcs-&gt;SetVisible(LineFromUPtr(wParam), lParam, false);
6287  		SetScrollBars();
6288  		Redraw();
6289  		break;
6290  	case Message::GetLineVisible:
6291  		return pcs-&gt;GetVisible(LineFromUPtr(wParam));
6292  	case Message::GetAllLinesVisible:
6293  		return pcs-&gt;HiddenLines() ? 0 : 1;
6294  	case Message::SetFoldExpanded:
6295  		SetFoldExpanded(LineFromUPtr(wParam), lParam != 0);
6296  		break;
6297  	case Message::GetFoldExpanded:
6298  		return pcs-&gt;GetExpanded(LineFromUPtr(wParam));
6299  	case Message::SetAutomaticFold:
6300  		foldAutomatic = static_cast&lt;AutomaticFold&gt;(wParam);
6301  		break;
6302  	case Message::GetAutomaticFold:
6303  		return static_cast&lt;sptr_t&gt;(foldAutomatic);
6304  	case Message::SetFoldFlags:
6305  		foldFlags = static_cast&lt;FoldFlag&gt;(wParam);
6306  		Redraw();
6307  		break;
6308  	case Message::ToggleFoldShowText:
6309  		pcs-&gt;SetFoldDisplayText(LineFromUPtr(wParam), ConstCharPtrFromSPtr(lParam));
6310  		FoldLine(LineFromUPtr(wParam), FoldAction::Toggle);
6311  		break;
6312  	case Message::FoldDisplayTextSetStyle:
6313  		foldDisplayTextStyle = static_cast&lt;FoldDisplayTextStyle&gt;(wParam);
6314  		Redraw();
6315  		break;
6316  	case Message::FoldDisplayTextGetStyle:
6317  		return static_cast&lt;sptr_t&gt;(foldDisplayTextStyle);
6318  	case Message::SetDefaultFoldDisplayText:
6319  		SetDefaultFoldDisplayText(ConstCharPtrFromSPtr(lParam));
6320  		Redraw();
6321  		break;
6322  	case Message::GetDefaultFoldDisplayText:
6323  		return StringResult(lParam, GetDefaultFoldDisplayText());
6324  	case Message::ToggleFold:
6325  		FoldLine(LineFromUPtr(wParam), FoldAction::Toggle);
6326  		break;
6327  	case Message::FoldLine:
6328  		FoldLine(LineFromUPtr(wParam), static_cast&lt;FoldAction&gt;(lParam));
6329  		break;
6330  	case Message::FoldChildren:
6331  		FoldExpand(LineFromUPtr(wParam), static_cast&lt;FoldAction&gt;(lParam), pdoc-&gt;GetFoldLevel(LineFromUPtr(wParam)));
6332  		break;
6333  	case Message::FoldAll:
6334  		FoldAll(static_cast&lt;FoldAction&gt;(wParam));
6335  		break;
6336  	case Message::ExpandChildren:
6337  		FoldExpand(LineFromUPtr(wParam), FoldAction::Expand, static_cast&lt;FoldLevel&gt;(lParam));
6338  		break;
6339  	case Message::ContractedFoldNext:
6340  		return ContractedFoldNext(LineFromUPtr(wParam));
6341  	case Message::EnsureVisible:
6342  		EnsureLineVisible(LineFromUPtr(wParam), false);
6343  		break;
6344  	case Message::EnsureVisibleEnforcePolicy:
6345  		EnsureLineVisible(LineFromUPtr(wParam), true);
6346  		break;
6347  	case Message::ScrollRange:
6348  		ScrollRange(SelectionRange(PositionFromUPtr(wParam), lParam));
6349  		break;
6350  	case Message::SearchAnchor:
6351  		SearchAnchor();
6352  		break;
6353  	case Message::SearchNext:
6354  	case Message::SearchPrev:
6355  		return SearchText(iMessage, wParam, lParam);
6356  	case Message::SetXCaretPolicy:
6357  		caretPolicies.x = CaretPolicySlop(wParam, lParam);
6358  		break;
6359  	case Message::SetYCaretPolicy:
6360  		caretPolicies.y = CaretPolicySlop(wParam, lParam);
6361  		break;
6362  	case Message::SetVisiblePolicy:
6363  		visiblePolicy = VisiblePolicySlop(wParam, lParam);
6364  		break;
6365  	case Message::LinesOnScreen:
6366  		return LinesOnScreen();
6367  	case Message::SetSelFore:
6368  		vs.elementColours[Element::SelectionText] = OptionalColour(wParam, lParam);
6369  		vs.elementColours[Element::SelectionAdditionalText] = OptionalColour(wParam, lParam);
6370  		InvalidateStyleRedraw();
6371  		break;
6372  	case Message::SetSelBack:
6373  		if (wParam) {
6374  			vs.SetElementRGB(Element::SelectionBack, static_cast&lt;int&gt;(lParam));
6375  			vs.SetElementRGB(Element::SelectionAdditionalBack, static_cast&lt;int&gt;(lParam));
6376  		} else {
6377  			vs.ResetElement(Element::SelectionBack);
6378  			vs.ResetElement(Element::SelectionAdditionalBack);
6379  		}
6380  		InvalidateStyleRedraw();
6381  		break;
6382  	case Message::SetSelAlpha: {
6383  			const Layer layerNew = (static_cast&lt;Alpha&gt;(wParam) == Alpha::NoAlpha) ? Layer::Base : Layer::OverText;
6384  			if (vs.selection.layer != layerNew) {
6385  			    vs.selection.layer = layerNew;
6386  			    UpdateBaseElements();
6387  			}
6388  			const int alpha = static_cast&lt;int&gt;(wParam);
6389  			vs.SetElementAlpha(Element::SelectionBack, alpha);
6390  			vs.SetElementAlpha(Element::SelectionAdditionalBack, alpha);
6391  			vs.SetElementAlpha(Element::SelectionSecondaryBack, alpha);
6392  			vs.SetElementAlpha(Element::SelectionInactiveBack, alpha);
6393  			InvalidateStyleRedraw();
6394  		}
6395  		break;
6396  	case Message::GetSelAlpha:
6397  		if (vs.selection.layer == Layer::Base)
6398  			return static_cast&lt;sptr_t&gt;(Alpha::NoAlpha);
6399  		return vs.ElementColourForced(Element::SelectionBack).GetAlpha();
6400  	case Message::GetSelEOLFilled:
6401  		return vs.selection.eolFilled;
6402  	case Message::SetSelEOLFilled:
6403  		vs.selection.eolFilled = wParam != 0;
6404  		InvalidateStyleRedraw();
6405  		break;
6406  	case Message::SetWhitespaceFore:
6407  		if (vs.SetElementColourOptional(Element::WhiteSpace, wParam, lParam)) {
6408  			InvalidateStyleRedraw();
6409  		}
6410  		break;
6411  	case Message::SetWhitespaceBack:
6412  		if (vs.SetElementColourOptional(Element::WhiteSpaceBack, wParam, lParam)) {
6413  			InvalidateStyleRedraw();
6414  		}
6415  		break;
6416  	case Message::SetSelectionLayer:
6417  		if (vs.selection.layer != static_cast&lt;Layer&gt;(wParam)) {
6418  			vs.selection.layer = static_cast&lt;Layer&gt;(wParam);
6419  			UpdateBaseElements();
6420  			InvalidateStyleRedraw();
6421  		}
6422  		break;
6423  	case Message::GetSelectionLayer:
6424  		return static_cast&lt;sptr_t&gt;(vs.selection.layer);
6425  	case Message::SetCaretFore:
6426  		vs.elementColours[Element::Caret] = ColourRGBA::FromIpRGB(SPtrFromUPtr(wParam));
6427  		InvalidateStyleRedraw();
6428  		break;
6429  	case Message::GetCaretFore:
6430  		return vs.ElementColourForced(Element::Caret).OpaqueRGB();
6431  	case Message::SetCaretStyle:
6432  		if (static_cast&lt;CaretStyle&gt;(wParam) &lt;= (CaretStyle::Block | CaretStyle::OverstrikeBlock | CaretStyle::Curses | CaretStyle::BlockAfter))
6433  			vs.caret.style = static_cast&lt;CaretStyle&gt;(wParam);
6434  		else
6435  			vs.caret.style = CaretStyle::Line;
6436  		InvalidateStyleRedraw();
6437  		break;
6438  	case Message::GetCaretStyle:
6439  		return static_cast&lt;sptr_t&gt;(vs.caret.style);
6440  	case Message::SetCaretWidth:
6441  		vs.caret.width = std::clamp(static_cast&lt;int&gt;(wParam), 0, 20);
6442  		InvalidateStyleRedraw();
6443  		break;
6444  	case Message::GetCaretWidth:
6445  		return vs.caret.width;
6446  	case Message::AssignCmdKey:
6447  		kmap.AssignCmdKey(static_cast&lt;Keys&gt;(LowShortFromWParam(wParam)),
6448  			static_cast&lt;KeyMod&gt;(HighShortFromWParam(wParam)), static_cast&lt;Message&gt;(lParam));
6449  		break;
6450  	case Message::ClearCmdKey:
6451  		kmap.AssignCmdKey(static_cast&lt;Keys&gt;(LowShortFromWParam(wParam)),
6452  			static_cast&lt;KeyMod&gt;(HighShortFromWParam(wParam)), Message::Null);
6453  		break;
6454  	case Message::ClearAllCmdKeys:
6455  		kmap.Clear();
6456  		break;
6457  	case Message::IndicSetStyle:
6458  		if (wParam &lt;= IndicatorMax) {
6459  			vs.indicators[wParam].sacNormal.style = static_cast&lt;IndicatorStyle&gt;(lParam);
6460  			vs.indicators[wParam].sacHover.style = static_cast&lt;IndicatorStyle&gt;(lParam);
6461  			InvalidateStyleRedraw();
6462  		}
6463  		break;
6464  	case Message::IndicGetStyle:
6465  		return (wParam &lt;= IndicatorMax) ?
6466  			static_cast&lt;sptr_t&gt;(vs.indicators[wParam].sacNormal.style) : 0;
6467  	case Message::IndicSetFore:
6468  		if (wParam &lt;= IndicatorMax) {
6469  			vs.indicators[wParam].sacNormal.fore = ColourRGBA::FromIpRGB(lParam);
6470  			vs.indicators[wParam].sacHover.fore = ColourRGBA::FromIpRGB(lParam);
6471  			InvalidateStyleRedraw();
6472  		}
6473  		break;
6474  	case Message::IndicGetFore:
6475  		return (wParam &lt;= IndicatorMax) ?
6476  			vs.indicators[wParam].sacNormal.fore.OpaqueRGB() : 0;
6477  	case Message::IndicSetHoverStyle:
6478  		if (wParam &lt;= IndicatorMax) {
6479  			vs.indicators[wParam].sacHover.style = static_cast&lt;IndicatorStyle&gt;(lParam);
6480  			InvalidateStyleRedraw();
6481  		}
6482  		break;
6483  	case Message::IndicGetHoverStyle:
6484  		return (wParam &lt;= IndicatorMax) ?
6485  			static_cast&lt;sptr_t&gt;(vs.indicators[wParam].sacHover.style) : 0;
6486  	case Message::IndicSetHoverFore:
6487  		if (wParam &lt;= IndicatorMax) {
6488  			vs.indicators[wParam].sacHover.fore = ColourRGBA::FromIpRGB(lParam);
6489  			InvalidateStyleRedraw();
6490  		}
6491  		break;
6492  	case Message::IndicGetHoverFore:
6493  		return (wParam &lt;= IndicatorMax) ?
6494  			vs.indicators[wParam].sacHover.fore.OpaqueRGB() : 0;
6495  	case Message::IndicSetFlags:
6496  		if (wParam &lt;= IndicatorMax) {
6497  			vs.indicators[wParam].SetFlags(static_cast&lt;IndicFlag&gt;(lParam));
6498  			InvalidateStyleRedraw();
6499  		}
6500  		break;
6501  	case Message::IndicGetFlags:
6502  		return (wParam &lt;= IndicatorMax) ?
6503  			static_cast&lt;sptr_t&gt;(vs.indicators[wParam].Flags()) : 0;
6504  	case Message::IndicSetUnder:
6505  		if (wParam &lt;= IndicatorMax) {
6506  			vs.indicators[wParam].under = lParam != 0;
6507  			InvalidateStyleRedraw();
6508  		}
6509  		break;
6510  	case Message::IndicGetUnder:
6511  		return (wParam &lt;= IndicatorMax) ?
6512  			vs.indicators[wParam].under : 0;
6513  	case Message::IndicSetAlpha:
6514  		if (wParam &lt;= IndicatorMax &amp;&amp; lParam &gt;=0 &amp;&amp; lParam &lt;= 255) {
6515  			vs.indicators[wParam].fillAlpha = static_cast&lt;int&gt;(lParam);
6516  			InvalidateStyleRedraw();
6517  		}
6518  		break;
6519  	case Message::IndicGetAlpha:
6520  		return (wParam &lt;= IndicatorMax)
6521  			? vs.indicators[wParam].fillAlpha : 0;
6522  	case Message::IndicSetOutlineAlpha:
6523  		if (wParam &lt;= IndicatorMax &amp;&amp; lParam &gt;=0 &amp;&amp; lParam &lt;= 255) {
6524  			vs.indicators[wParam].outlineAlpha = static_cast&lt;int&gt;(lParam);
6525  			InvalidateStyleRedraw();
6526  		}
6527  		break;
6528  	case Message::IndicGetOutlineAlpha:
6529  		return (wParam &lt;= IndicatorMax) ? vs.indicators[wParam].outlineAlpha : 0;
6530  	case Message::IndicSetStrokeWidth:
6531  		if (wParam &lt;= IndicatorMax &amp;&amp; lParam &gt;= 0 &amp;&amp; lParam &lt;= 1000) {
6532  			vs.indicators[wParam].strokeWidth = lParam / 100.0f;
6533  			InvalidateStyleRedraw();
6534  		}
6535  		break;
6536  	case Message::IndicGetStrokeWidth:
6537  		if (wParam &lt;= IndicatorMax) {
6538  			return std::lround(vs.indicators[wParam].strokeWidth * 100);
6539  		}
6540  		break;
6541  	case Message::SetIndicatorCurrent:
6542  		pdoc-&gt;DecorationSetCurrentIndicator(static_cast&lt;int&gt;(wParam));
6543  		break;
6544  	case Message::GetIndicatorCurrent:
6545  		return pdoc-&gt;decorations-&gt;GetCurrentIndicator();
6546  	case Message::SetIndicatorValue:
6547  		pdoc-&gt;decorations-&gt;SetCurrentValue(static_cast&lt;int&gt;(wParam));
6548  		break;
6549  	case Message::GetIndicatorValue:
6550  		return pdoc-&gt;decorations-&gt;GetCurrentValue();
6551  	case Message::IndicatorFillRange:
6552  		pdoc-&gt;DecorationFillRange(PositionFromUPtr(wParam),
6553  			pdoc-&gt;decorations-&gt;GetCurrentValue(), lParam);
6554  		break;
6555  	case Message::IndicatorClearRange:
6556  		pdoc-&gt;DecorationFillRange(PositionFromUPtr(wParam), 0,
6557  			lParam);
6558  		break;
6559  	case Message::IndicatorAllOnFor:
6560  		return pdoc-&gt;decorations-&gt;AllOnFor(PositionFromUPtr(wParam));
6561  	case Message::IndicatorValueAt:
6562  		return pdoc-&gt;decorations-&gt;ValueAt(static_cast&lt;int&gt;(wParam), lParam);
6563  	case Message::IndicatorStart:
6564  		return pdoc-&gt;decorations-&gt;Start(static_cast&lt;int&gt;(wParam), lParam);
6565  	case Message::IndicatorEnd:
6566  		return pdoc-&gt;decorations-&gt;End(static_cast&lt;int&gt;(wParam), lParam);
6567  	case Message::LineDown:
6568  	case Message::LineDownExtend:
6569  	case Message::ParaDown:
6570  	case Message::ParaDownExtend:
6571  	case Message::LineUp:
6572  	case Message::LineUpExtend:
6573  	case Message::ParaUp:
6574  	case Message::ParaUpExtend:
6575  	case Message::CharLeft:
6576  	case Message::CharLeftExtend:
6577  	case Message::CharRight:
6578  	case Message::CharRightExtend:
6579  	case Message::WordLeft:
6580  	case Message::WordLeftExtend:
6581  	case Message::WordRight:
6582  	case Message::WordRightExtend:
6583  	case Message::WordLeftEnd:
6584  	case Message::WordLeftEndExtend:
6585  	case Message::WordRightEnd:
6586  	case Message::WordRightEndExtend:
6587  	case Message::Home:
6588  	case Message::HomeExtend:
6589  	case Message::LineEnd:
6590  	case Message::LineEndExtend:
6591  	case Message::HomeWrap:
6592  	case Message::HomeWrapExtend:
6593  	case Message::LineEndWrap:
6594  	case Message::LineEndWrapExtend:
6595  	case Message::DocumentStart:
6596  	case Message::DocumentStartExtend:
6597  	case Message::DocumentEnd:
6598  	case Message::DocumentEndExtend:
6599  	case Message::ScrollToStart:
6600  	case Message::ScrollToEnd:
6601  	case Message::StutteredPageUp:
6602  	case Message::StutteredPageUpExtend:
6603  	case Message::StutteredPageDown:
6604  	case Message::StutteredPageDownExtend:
6605  	case Message::PageUp:
6606  	case Message::PageUpExtend:
6607  	case Message::PageDown:
6608  	case Message::PageDownExtend:
6609  	case Message::EditToggleOvertype:
6610  	case Message::Cancel:
6611  	case Message::DeleteBack:
6612  	case Message::Tab:
6613  	case Message::BackTab:
6614  	case Message::NewLine:
6615  	case Message::FormFeed:
6616  	case Message::VCHome:
6617  	case Message::VCHomeExtend:
6618  	case Message::VCHomeWrap:
6619  	case Message::VCHomeWrapExtend:
6620  	case Message::VCHomeDisplay:
6621  	case Message::VCHomeDisplayExtend:
6622  	case Message::ZoomIn:
6623  	case Message::ZoomOut:
6624  	case Message::DelWordLeft:
6625  	case Message::DelWordRight:
6626  	case Message::DelWordRightEnd:
6627  	case Message::DelLineLeft:
6628  	case Message::DelLineRight:
6629  	case Message::LineCopy:
6630  	case Message::LineCut:
6631  	case Message::LineDelete:
6632  	case Message::LineTranspose:
6633  	case Message::LineReverse:
6634  	case Message::LineDuplicate:
6635  	case Message::LowerCase:
6636  	case Message::UpperCase:
6637  	case Message::LineScrollDown:
6638  	case Message::LineScrollUp:
6639  	case Message::WordPartLeft:
6640  	case Message::WordPartLeftExtend:
6641  	case Message::WordPartRight:
6642  	case Message::WordPartRightExtend:
6643  	case Message::DeleteBackNotLine:
6644  	case Message::HomeDisplay:
6645  	case Message::HomeDisplayExtend:
6646  	case Message::LineEndDisplay:
6647  	case Message::LineEndDisplayExtend:
6648  	case Message::LineDownRectExtend:
6649  	case Message::LineUpRectExtend:
6650  	case Message::CharLeftRectExtend:
6651  	case Message::CharRightRectExtend:
6652  	case Message::HomeRectExtend:
6653  	case Message::VCHomeRectExtend:
6654  	case Message::LineEndRectExtend:
6655  	case Message::PageUpRectExtend:
6656  	case Message::PageDownRectExtend:
6657  	case Message::SelectionDuplicate:
6658  		return KeyCommand(iMessage);
6659  	case Message::BraceHighlight:
6660  		SetBraceHighlight(PositionFromUPtr(wParam), lParam, StyleBraceLight);
6661  		break;
6662  	case Message::BraceHighlightIndicator:
6663  		if (lParam &gt;= 0 &amp;&amp; static_cast&lt;size_t&gt;(lParam) &lt;= IndicatorMax) {
6664  			vs.braceHighlightIndicatorSet = wParam != 0;
6665  			vs.braceHighlightIndicator = static_cast&lt;int&gt;(lParam);
6666  		}
6667  		break;
6668  	case Message::BraceBadLight:
6669  		SetBraceHighlight(PositionFromUPtr(wParam), -1, StyleBraceBad);
6670  		break;
6671  	case Message::BraceBadLightIndicator:
6672  		if (lParam &gt;= 0 &amp;&amp; static_cast&lt;size_t&gt;(lParam) &lt;= IndicatorMax) {
6673  			vs.braceBadLightIndicatorSet = wParam != 0;
6674  			vs.braceBadLightIndicator = static_cast&lt;int&gt;(lParam);
6675  		}
6676  		break;
6677  	case Message::BraceMatch:
6678  		return pdoc-&gt;BraceMatch(PositionFromUPtr(wParam), lParam, 0, false);
6679  	case Message::BraceMatchNext:
6680  		return pdoc-&gt;BraceMatch(PositionFromUPtr(wParam), 0, lParam, true);
6681  	case Message::GetViewEOL:
6682  		return vs.viewEOL;
6683  	case Message::SetViewEOL:
6684  		vs.viewEOL = wParam != 0;
6685  		InvalidateStyleRedraw();
6686  		break;
6687  	case Message::SetZoom: {
6688  			const int zoomLevel = static_cast&lt;int&gt;(wParam);
6689  			if (zoomLevel != vs.zoomLevel) {
6690  				vs.zoomLevel = zoomLevel;
6691  				InvalidateStyleRedraw();
6692  				NotifyZoom();
6693  			}
6694  			break;
6695  		}
6696  	case Message::GetZoom:
6697  		return vs.zoomLevel;
6698  	case Message::GetEdgeColumn:
6699  		return vs.theEdge.column;
6700  	case Message::SetEdgeColumn:
6701  		vs.theEdge.column = static_cast&lt;int&gt;(wParam);
6702  		InvalidateStyleRedraw();
6703  		break;
6704  	case Message::GetEdgeMode:
6705  		return static_cast&lt;sptr_t&gt;(vs.edgeState);
6706  	case Message::SetEdgeMode:
6707  		vs.edgeState = static_cast&lt;EdgeVisualStyle&gt;(wParam);
6708  		InvalidateStyleRedraw();
6709  		break;
6710  	case Message::GetEdgeColour:
6711  		return vs.theEdge.colour.OpaqueRGB();
6712  	case Message::SetEdgeColour:
6713  		vs.theEdge.colour = ColourRGBA::FromIpRGB(SPtrFromUPtr(wParam));
6714  		InvalidateStyleRedraw();
6715  		break;
6716  	case Message::MultiEdgeAddLine:
6717  		vs.AddMultiEdge(static_cast&lt;int&gt;(wParam), ColourRGBA::FromIpRGB(lParam));
6718  		InvalidateStyleRedraw();
6719  		break;
6720  	case Message::MultiEdgeClearAll:
6721  		std::vector&lt;EdgeProperties&gt;().swap(vs.theMultiEdge); 
6722  		InvalidateStyleRedraw();
6723  		break;
6724  	case Message::GetMultiEdgeColumn: {
6725  			const size_t which = wParam;
6726  			if (which &gt;= vs.theMultiEdge.size()) {
6727  				return -1;
6728  			}
6729  			return vs.theMultiEdge[which].column;
6730  		}
6731  	case Message::GetAccessibility:
6732  		return static_cast&lt;sptr_t&gt;(Accessibility::Disabled);
6733  	case Message::SetAccessibility:
6734  		break;
6735  	case Message::GetDocPointer:
6736  		return reinterpret_cast&lt;sptr_t&gt;(pdoc);
6737  	case Message::SetDocPointer:
6738  		CancelModes();
6739  		SetDocPointer(static_cast&lt;Document *&gt;(PtrFromSPtr(lParam)));
6740  		return 0;
6741  	case Message::CreateDocument: {
6742  			Document *doc = new Document(static_cast&lt;DocumentOption&gt;(lParam));
6743  			doc-&gt;AddRef();
6744  			doc-&gt;Allocate(PositionFromUPtr(wParam));
6745  			pcs = ContractionStateCreate(pdoc-&gt;IsLarge());
6746  			return reinterpret_cast&lt;sptr_t&gt;(doc);
6747  		}
6748  	case Message::AddRefDocument:
6749  		(static_cast&lt;Document *&gt;(PtrFromSPtr(lParam)))-&gt;AddRef();
6750  		break;
6751  	case Message::ReleaseDocument:
6752  		(static_cast&lt;Document *&gt;(PtrFromSPtr(lParam)))-&gt;Release();
6753  		break;
6754  	case Message::GetDocumentOptions:
6755  		return static_cast&lt;sptr_t&gt;(pdoc-&gt;Options());
6756  	case Message::CreateLoader: {
6757  			Document *doc = new Document(static_cast&lt;DocumentOption&gt;(lParam));
6758  			doc-&gt;AddRef();
6759  			doc-&gt;Allocate(PositionFromUPtr(wParam));
6760  			doc-&gt;SetUndoCollection(false);
6761  			pcs = ContractionStateCreate(pdoc-&gt;IsLarge());
6762  			return reinterpret_cast&lt;sptr_t&gt;(static_cast&lt;ILoader *&gt;(doc));
6763  		}
6764  	case Message::SetModEventMask:
6765  		modEventMask = static_cast&lt;ModificationFlags&gt;(wParam);
6766  		return 0;
6767  	case Message::GetModEventMask:
6768  		return static_cast&lt;sptr_t&gt;(modEventMask);
6769  	case Message::SetCommandEvents:
6770  		commandEvents = static_cast&lt;bool&gt;(wParam);
6771  		return 0;
6772  	case Message::GetCommandEvents:
6773  		return commandEvents;
6774  	case Message::ConvertEOLs:
6775  		pdoc-&gt;ConvertLineEnds(static_cast&lt;EndOfLine&gt;(wParam));
6776  		SetSelection(sel.MainCaret(), sel.MainAnchor());	
6777  		return 0;
6778  	case Message::SetLengthForEncode:
6779  		lengthForEncode = PositionFromUPtr(wParam);
6780  		return 0;
6781  	case Message::SelectionIsRectangle:
6782  		return sel.selType == Selection::SelTypes::rectangle ? 1 : 0;
6783  	case Message::SetSelectionMode: {
6784  			switch (static_cast&lt;SelectionMode&gt;(wParam)) {
6785  			case SelectionMode::Stream:
6786  				sel.SetMoveExtends(!sel.MoveExtends() || (sel.selType != Selection::SelTypes::stream));
6787  				sel.selType = Selection::SelTypes::stream;
6788  				break;
6789  			case SelectionMode::Rectangle:
6790  				sel.SetMoveExtends(!sel.MoveExtends() || (sel.selType != Selection::SelTypes::rectangle));
6791  				sel.selType = Selection::SelTypes::rectangle;
6792  				sel.Rectangular() = sel.RangeMain(); 
6793  				break;
6794  			case SelectionMode::Lines:
6795  				sel.SetMoveExtends(!sel.MoveExtends() || (sel.selType != Selection::SelTypes::lines));
6796  				sel.selType = Selection::SelTypes::lines;
6797  				SetSelection(sel.RangeMain().caret, sel.RangeMain().anchor); 
6798  				break;
6799  			case SelectionMode::Thin:
6800  				sel.SetMoveExtends(!sel.MoveExtends() || (sel.selType != Selection::SelTypes::thin));
6801  				sel.selType = Selection::SelTypes::thin;
6802  				break;
6803  			default:
6804  				sel.SetMoveExtends(!sel.MoveExtends() || (sel.selType != Selection::SelTypes::stream));
6805  				sel.selType = Selection::SelTypes::stream;
6806  			}
6807  			InvalidateWholeSelection();
6808  			break;
6809  		}
6810  	case Message::GetSelectionMode:
6811  		switch (sel.selType) {
6812  		case Selection::SelTypes::stream:
6813  			return static_cast&lt;sptr_t&gt;(SelectionMode::Stream);
6814  		case Selection::SelTypes::rectangle:
6815  			return static_cast&lt;sptr_t&gt;(SelectionMode::Rectangle);
6816  		case Selection::SelTypes::lines:
6817  			return static_cast&lt;sptr_t&gt;(SelectionMode::Lines);
6818  		case Selection::SelTypes::thin:
6819  			return static_cast&lt;sptr_t&gt;(SelectionMode::Thin);
6820  		default:	
6821  			return static_cast&lt;sptr_t&gt;(SelectionMode::Stream);
6822  		}
6823  	case Message::GetMoveExtendsSelection:
6824  		return sel.MoveExtends();
6825  	case Message::GetLineSelStartPosition:
6826  	case Message::GetLineSelEndPosition: {
6827  			const SelectionSegment segmentLine(
6828  				SelectionPosition(pdoc-&gt;LineStart(LineFromUPtr(wParam))),
6829  				SelectionPosition(pdoc-&gt;LineEnd(LineFromUPtr(wParam))));
6830  			for (size_t r=0; r&lt;sel.Count(); r++) {
6831  				const SelectionSegment portion = sel.Range(r).Intersect(segmentLine);
6832  				if (portion.start.IsValid()) {
6833  					return (iMessage == Message::GetLineSelStartPosition) ? portion.start.Position() : portion.end.Position();
6834  				}
6835  			}
6836  			return Sci::invalidPosition;
6837  		}
6838  	case Message::SetOvertype:
6839  		if (inOverstrike != (wParam != 0)) {
6840  			inOverstrike = wParam != 0;
6841  			ContainerNeedsUpdate(Update::Selection);
6842  			ShowCaretAtCurrentPosition();
6843  			SetIdle(true);
6844  		}
6845  		break;
6846  	case Message::GetOvertype:
6847  		return inOverstrike ? 1 : 0;
6848  	case Message::SetFocus:
6849  		SetFocusState(wParam != 0);
6850  		break;
6851  	case Message::GetFocus:
6852  		return hasFocus;
6853  	case Message::SetStatus:
6854  		errorStatus = static_cast&lt;Status&gt;(wParam);
6855  		break;
6856  	case Message::GetStatus:
6857  		return static_cast&lt;sptr_t&gt;(errorStatus);
6858  	case Message::SetMouseDownCaptures:
6859  		mouseDownCaptures = wParam != 0;
6860  		break;
6861  	case Message::GetMouseDownCaptures:
6862  		return mouseDownCaptures;
6863  	case Message::SetMouseWheelCaptures:
6864  		mouseWheelCaptures = wParam != 0;
6865  		break;
6866  	case Message::GetMouseWheelCaptures:
6867  		return mouseWheelCaptures;
6868  	case Message::SetCursor:
6869  		cursorMode = static_cast&lt;CursorShape&gt;(wParam);
6870  		DisplayCursor(Window::Cursor::text);
6871  		break;
6872  	case Message::GetCursor:
6873  		return static_cast&lt;sptr_t&gt;(cursorMode);
6874  	case Message::SetControlCharSymbol:
6875  		vs.controlCharSymbol = static_cast&lt;int&gt;(wParam);
6876  		InvalidateStyleRedraw();
6877  		break;
6878  	case Message::GetControlCharSymbol:
6879  		return vs.controlCharSymbol;
6880  	case Message::SetRepresentation:
6881  		reprs.SetRepresentation(ConstCharPtrFromUPtr(wParam), ConstCharPtrFromSPtr(lParam));
6882  		break;
6883  	case Message::GetRepresentation: {
6884  			const Representation *repr = reprs.RepresentationFromCharacter(
6885  				ConstCharPtrFromUPtr(wParam));
6886  			if (repr) {
6887  				return StringResult(lParam, repr-&gt;stringRep.c_str());
6888  			}
6889  			return 0;
6890  		}
6891  	case Message::ClearRepresentation:
6892  		reprs.ClearRepresentation(ConstCharPtrFromUPtr(wParam));
6893  		break;
6894  	case Message::ClearAllRepresentations:
6895  		SetRepresentations();
6896  		break;
6897  	case Message::SetRepresentationAppearance:
6898  		reprs.SetRepresentationAppearance(ConstCharPtrFromUPtr(wParam), static_cast&lt;RepresentationAppearance&gt;(lParam));
6899  		break;
6900  	case Message::GetRepresentationAppearance: {
6901  			const Representation *repr = reprs.RepresentationFromCharacter(
6902  				ConstCharPtrFromUPtr(wParam));
6903  			if (repr) {
6904  				return static_cast&lt;sptr_t&gt;(repr-&gt;appearance);
6905  			}
6906  			return 0;
6907  		}
6908  	case Message::SetRepresentationColour:
6909  		reprs.SetRepresentationColour(ConstCharPtrFromUPtr(wParam), ColourRGBA(static_cast&lt;int&gt;(lParam)));
6910  		break;
6911  	case Message::GetRepresentationColour: {
6912  			const Representation *repr = reprs.RepresentationFromCharacter(
6913  				ConstCharPtrFromUPtr(wParam));
6914  			if (repr) {
6915  				return repr-&gt;colour.AsInteger();
6916  			}
6917  			return 0;
6918  		}
6919  	case Message::StartRecord:
6920  		recordingMacro = true;
6921  		return 0;
6922  	case Message::StopRecord:
6923  		recordingMacro = false;
6924  		return 0;
6925  	case Message::MoveCaretInsideView:
6926  		MoveCaretInsideView();
6927  		break;
6928  	case Message::SetFoldMarginColour:
6929  		vs.foldmarginColour = OptionalColour(wParam, lParam);
6930  		InvalidateStyleRedraw();
6931  		break;
6932  	case Message::SetFoldMarginHiColour:
6933  		vs.foldmarginHighlightColour = OptionalColour(wParam, lParam);
6934  		InvalidateStyleRedraw();
6935  		break;
6936  	case Message::SetHotspotActiveFore:
6937  		if (vs.SetElementColourOptional(Element::HotSpotActive, wParam, lParam)) {
6938  			InvalidateStyleRedraw();
6939  		}
6940  		break;
6941  	case Message::GetHotspotActiveFore:
6942  		return vs.ElementColour(Element::HotSpotActive).value_or(ColourRGBA()).OpaqueRGB();
6943  	case Message::SetHotspotActiveBack:
6944  		if (vs.SetElementColourOptional(Element::HotSpotActiveBack, wParam, lParam)) {
6945  			InvalidateStyleRedraw();
6946  		}
6947  		break;
6948  	case Message::GetHotspotActiveBack:
6949  		return vs.ElementColour(Element::HotSpotActiveBack).value_or(ColourRGBA()).OpaqueRGB();
6950  	case Message::SetHotspotActiveUnderline:
6951  		vs.hotspotUnderline = wParam != 0;
6952  		InvalidateStyleRedraw();
6953  		break;
6954  	case Message::GetHotspotActiveUnderline:
6955  		return vs.hotspotUnderline ? 1 : 0;
6956  	case Message::SetHotspotSingleLine:
6957  		hotspotSingleLine = wParam != 0;
6958  		InvalidateStyleRedraw();
6959  		break;
6960  	case Message::GetHotspotSingleLine:
6961  		return hotspotSingleLine ? 1 : 0;
6962  	case Message::SetPasteConvertEndings:
6963  		convertPastes = wParam != 0;
6964  		break;
6965  	case Message::GetPasteConvertEndings:
6966  		return convertPastes ? 1 : 0;
6967  	case Message::GetCharacterPointer:
6968  		return reinterpret_cast&lt;sptr_t&gt;(pdoc-&gt;BufferPointer());
6969  	case Message::GetRangePointer:
6970  		return reinterpret_cast&lt;sptr_t&gt;(pdoc-&gt;RangePointer(
6971  			PositionFromUPtr(wParam), lParam));
6972  	case Message::GetGapPosition:
6973  		return pdoc-&gt;GapPosition();
6974  	case Message::SetChangeHistory:
6975  		changeHistoryOption = static_cast&lt;ChangeHistoryOption&gt;(wParam);
6976  		pdoc-&gt;ChangeHistorySet(wParam &amp; 1);
6977  		break;
6978  	case Message::GetChangeHistory:
6979  		return static_cast&lt;sptr_t&gt;(changeHistoryOption);
6980  	case Message::SetExtraAscent:
6981  		vs.extraAscent = static_cast&lt;int&gt;(wParam);
6982  		InvalidateStyleRedraw();
6983  		break;
6984  	case Message::GetExtraAscent:
6985  		return vs.extraAscent;
6986  	case Message::SetExtraDescent:
6987  		vs.extraDescent = static_cast&lt;int&gt;(wParam);
6988  		InvalidateStyleRedraw();
6989  		break;
6990  	case Message::GetExtraDescent:
6991  		return vs.extraDescent;
6992  	case Message::MarginSetStyleOffset:
6993  		vs.marginStyleOffset = static_cast&lt;int&gt;(wParam);
6994  		InvalidateStyleRedraw();
6995  		break;
6996  	case Message::MarginGetStyleOffset:
6997  		return vs.marginStyleOffset;
6998  	case Message::SetMarginOptions:
6999  		marginOptions = static_cast&lt;MarginOption&gt;(wParam);
7000  		break;
7001  	case Message::GetMarginOptions:
7002  		return static_cast&lt;sptr_t&gt;(marginOptions);
7003  	case Message::MarginSetText:
7004  		pdoc-&gt;MarginSetText(LineFromUPtr(wParam), ConstCharPtrFromSPtr(lParam));
7005  		break;
7006  	case Message::MarginGetText: {
7007  			const StyledText st = pdoc-&gt;MarginStyledText(LineFromUPtr(wParam));
7008  			return BytesResult(lParam, reinterpret_cast&lt;const unsigned char *&gt;(st.text), st.length);
7009  		}
7010  	case Message::MarginSetStyle:
7011  		pdoc-&gt;MarginSetStyle(LineFromUPtr(wParam), static_cast&lt;int&gt;(lParam));
7012  		break;
7013  	case Message::MarginGetStyle: {
7014  			const StyledText st = pdoc-&gt;MarginStyledText(LineFromUPtr(wParam));
7015  			return st.style;
7016  		}
7017  	case Message::MarginSetStyles:
7018  		pdoc-&gt;MarginSetStyles(LineFromUPtr(wParam), ConstUCharPtrFromSPtr(lParam));
7019  		break;
7020  	case Message::MarginGetStyles: {
7021  			const StyledText st = pdoc-&gt;MarginStyledText(LineFromUPtr(wParam));
7022  			return BytesResult(lParam, st.styles, st.length);
7023  		}
7024  	case Message::MarginTextClearAll:
7025  		pdoc-&gt;MarginClearAll();
7026  		break;
7027  	case Message::AnnotationSetText:
7028  		pdoc-&gt;AnnotationSetText(LineFromUPtr(wParam), ConstCharPtrFromSPtr(lParam));
7029  		break;
7030  	case Message::AnnotationGetText: {
7031  			const StyledText st = pdoc-&gt;AnnotationStyledText(LineFromUPtr(wParam));
7032  			return BytesResult(lParam, reinterpret_cast&lt;const unsigned char *&gt;(st.text), st.length);
7033  		}
7034  	case Message::AnnotationGetStyle: {
7035  			const StyledText st = pdoc-&gt;AnnotationStyledText(LineFromUPtr(wParam));
7036  			return st.style;
7037  		}
7038  	case Message::AnnotationSetStyle:
7039  		pdoc-&gt;AnnotationSetStyle(LineFromUPtr(wParam), static_cast&lt;int&gt;(lParam));
7040  		break;
7041  	case Message::AnnotationSetStyles:
7042  		pdoc-&gt;AnnotationSetStyles(LineFromUPtr(wParam), ConstUCharPtrFromSPtr(lParam));
7043  		break;
7044  	case Message::AnnotationGetStyles: {
7045  			const StyledText st = pdoc-&gt;AnnotationStyledText(LineFromUPtr(wParam));
7046  			return BytesResult(lParam, st.styles, st.length);
7047  		}
7048  	case Message::AnnotationGetLines:
7049  		return pdoc-&gt;AnnotationLines(LineFromUPtr(wParam));
7050  	case Message::AnnotationClearAll:
7051  		pdoc-&gt;AnnotationClearAll();
7052  		break;
7053  	case Message::AnnotationSetVisible:
7054  		SetAnnotationVisible(static_cast&lt;AnnotationVisible&gt;(wParam));
7055  		break;
7056  	case Message::AnnotationGetVisible:
7057  		return static_cast&lt;sptr_t&gt;(vs.annotationVisible);
7058  	case Message::AnnotationSetStyleOffset:
7059  		vs.annotationStyleOffset = static_cast&lt;int&gt;(wParam);
7060  		InvalidateStyleRedraw();
7061  		break;
7062  	case Message::AnnotationGetStyleOffset:
7063  		return vs.annotationStyleOffset;
7064  	case Message::EOLAnnotationSetText:
7065  		pdoc-&gt;EOLAnnotationSetText(LineFromUPtr(wParam), ConstCharPtrFromSPtr(lParam));
7066  		break;
7067  	case Message::EOLAnnotationGetText: {
7068  			const StyledText st = pdoc-&gt;EOLAnnotationStyledText(LineFromUPtr(wParam));
7069  			return BytesResult(lParam, reinterpret_cast&lt;const unsigned char *&gt;(st.text), st.length);
7070  		}
7071  	case Message::EOLAnnotationGetStyle: {
7072  			const StyledText st = pdoc-&gt;EOLAnnotationStyledText(LineFromUPtr(wParam));
7073  			return st.style;
7074  		}
7075  	case Message::EOLAnnotationSetStyle:
7076  		pdoc-&gt;EOLAnnotationSetStyle(LineFromUPtr(wParam), static_cast&lt;int&gt;(lParam));
7077  		break;
7078  	case Message::EOLAnnotationClearAll:
7079  		pdoc-&gt;EOLAnnotationClearAll();
7080  		break;
7081  	case Message::EOLAnnotationSetVisible:
7082  		SetEOLAnnotationVisible(static_cast&lt;EOLAnnotationVisible&gt;(wParam));
7083  		break;
7084  	case Message::EOLAnnotationGetVisible:
7085  		return static_cast&lt;sptr_t&gt;(vs.eolAnnotationVisible);
7086  	case Message::EOLAnnotationSetStyleOffset:
7087  		vs.eolAnnotationStyleOffset = static_cast&lt;int&gt;(wParam);
7088  		InvalidateStyleRedraw();
7089  		break;
7090  	case Message::EOLAnnotationGetStyleOffset:
7091  		return vs.eolAnnotationStyleOffset;
7092  	case Message::ReleaseAllExtendedStyles:
7093  		vs.ReleaseAllExtendedStyles();
7094  		break;
7095  	case Message::AllocateExtendedStyles:
7096  		return vs.AllocateExtendedStyles(static_cast&lt;int&gt;(wParam));
7097  	case Message::SupportsFeature:
7098  		return SupportsFeature(static_cast&lt;Supports&gt;(wParam));
7099  	case Message::AddUndoAction:
7100  		pdoc-&gt;AddUndoAction(PositionFromUPtr(wParam),
7101  			FlagSet(static_cast&lt;UndoFlags&gt;(lParam), UndoFlags::MayCoalesce));
7102  		break;
7103  	case Message::SetMouseSelectionRectangularSwitch:
7104  		mouseSelectionRectangularSwitch = wParam != 0;
7105  		break;
7106  	case Message::GetMouseSelectionRectangularSwitch:
7107  		return mouseSelectionRectangularSwitch;
7108  	case Message::SetMultipleSelection:
7109  		multipleSelection = wParam != 0;
7110  		InvalidateCaret();
7111  		break;
7112  	case Message::GetMultipleSelection:
7113  		return multipleSelection;
7114  	case Message::SetAdditionalSelectionTyping:
7115  		additionalSelectionTyping = wParam != 0;
7116  		InvalidateCaret();
7117  		break;
7118  	case Message::GetAdditionalSelectionTyping:
7119  		return additionalSelectionTyping;
7120  	case Message::SetMultiPaste:
7121  		multiPasteMode = static_cast&lt;MultiPaste&gt;(wParam);
7122  		break;
7123  	case Message::GetMultiPaste:
7124  		return static_cast&lt;sptr_t&gt;(multiPasteMode);
7125  	case Message::SetAdditionalCaretsBlink:
7126  		view.additionalCaretsBlink = wParam != 0;
7127  		InvalidateCaret();
7128  		break;
7129  	case Message::GetAdditionalCaretsBlink:
7130  		return view.additionalCaretsBlink;
7131  	case Message::SetAdditionalCaretsVisible:
7132  		view.additionalCaretsVisible = wParam != 0;
7133  		InvalidateCaret();
7134  		break;
7135  	case Message::GetAdditionalCaretsVisible:
7136  		return view.additionalCaretsVisible;
7137  	case Message::GetSelections:
7138  		return sel.Count();
7139  	case Message::GetSelectionEmpty:
7140  		return sel.Empty();
7141  	case Message::ClearSelections:
7142  		sel.Clear();
7143  		ContainerNeedsUpdate(Update::Selection);
7144  		Redraw();
7145  		break;
7146  	case Message::SetSelection:
7147  		sel.SetSelection(SelectionRange(PositionFromUPtr(wParam), lParam));
7148  		Redraw();
7149  		break;
7150  	case Message::AddSelection:
7151  		sel.AddSelection(SelectionRange(PositionFromUPtr(wParam), lParam));
7152  		ContainerNeedsUpdate(Update::Selection);
7153  		Redraw();
7154  		break;
7155  	case Message::DropSelectionN:
7156  		sel.DropSelection(wParam);
7157  		ContainerNeedsUpdate(Update::Selection);
7158  		Redraw();
7159  		break;
7160  	case Message::SetMainSelection:
7161  		sel.SetMain(wParam);
7162  		ContainerNeedsUpdate(Update::Selection);
7163  		Redraw();
7164  		break;
7165  	case Message::GetMainSelection:
7166  		return sel.Main();
7167  	case Message::SetSelectionNCaret:
7168  	case Message::SetSelectionNAnchor:
7169  	case Message::SetSelectionNCaretVirtualSpace:
7170  	case Message::SetSelectionNAnchorVirtualSpace:
7171  	case Message::SetSelectionNStart:
7172  	case Message::SetSelectionNEnd:
7173  		SetSelectionNMessage(iMessage, wParam, lParam);
7174  		break;
7175  	case Message::GetSelectionNCaret:
7176  		return sel.Range(wParam).caret.Position();
7177  	case Message::GetSelectionNAnchor:
7178  		return sel.Range(wParam).anchor.Position();
7179  	case Message::GetSelectionNCaretVirtualSpace:
7180  		return sel.Range(wParam).caret.VirtualSpace();
7181  	case Message::GetSelectionNAnchorVirtualSpace:
7182  		return sel.Range(wParam).anchor.VirtualSpace();
7183  	case Message::GetSelectionNStart:
7184  		return sel.Range(wParam).Start().Position();
7185  	case Message::GetSelectionNStartVirtualSpace:
7186  		return sel.Range(wParam).Start().VirtualSpace();
7187  	case Message::GetSelectionNEnd:
7188  		return sel.Range(wParam).End().Position();
7189  	case Message::GetSelectionNEndVirtualSpace:
7190  		return sel.Range(wParam).End().VirtualSpace();
7191  	case Message::SetRectangularSelectionCaret:
7192  		if (!sel.IsRectangular())
7193  			sel.Clear();
7194  		sel.selType = Selection::SelTypes::rectangle;
7195  		sel.Rectangular().caret.SetPosition(PositionFromUPtr(wParam));
7196  		SetRectangularRange();
7197  		Redraw();
7198  		break;
7199  	case Message::GetRectangularSelectionCaret:
7200  		return sel.Rectangular().caret.Position();
7201  	case Message::SetRectangularSelectionAnchor:
7202  		if (!sel.IsRectangular())
7203  			sel.Clear();
7204  		sel.selType = Selection::SelTypes::rectangle;
7205  		sel.Rectangular().anchor.SetPosition(PositionFromUPtr(wParam));
7206  		SetRectangularRange();
7207  		Redraw();
7208  		break;
7209  	case Message::GetRectangularSelectionAnchor:
7210  		return sel.Rectangular().anchor.Position();
7211  	case Message::SetRectangularSelectionCaretVirtualSpace:
7212  		if (!sel.IsRectangular())
7213  			sel.Clear();
7214  		sel.selType = Selection::SelTypes::rectangle;
7215  		sel.Rectangular().caret.SetVirtualSpace(PositionFromUPtr(wParam));
7216  		SetRectangularRange();
7217  		Redraw();
7218  		break;
7219  	case Message::GetRectangularSelectionCaretVirtualSpace:
7220  		return sel.Rectangular().caret.VirtualSpace();
7221  	case Message::SetRectangularSelectionAnchorVirtualSpace:
7222  		if (!sel.IsRectangular())
7223  			sel.Clear();
7224  		sel.selType = Selection::SelTypes::rectangle;
7225  		sel.Rectangular().anchor.SetVirtualSpace(PositionFromUPtr(wParam));
7226  		SetRectangularRange();
7227  		Redraw();
7228  		break;
7229  	case Message::GetRectangularSelectionAnchorVirtualSpace:
7230  		return sel.Rectangular().anchor.VirtualSpace();
7231  	case Message::SetVirtualSpaceOptions:
7232  		virtualSpaceOptions = static_cast&lt;VirtualSpace&gt;(wParam);
7233  		break;
7234  	case Message::GetVirtualSpaceOptions:
7235  		return static_cast&lt;sptr_t&gt;(virtualSpaceOptions);
7236  	case Message::SetAdditionalSelFore:
7237  		vs.elementColours[Element::SelectionAdditionalText] = ColourRGBA::FromIpRGB(SPtrFromUPtr(wParam));
7238  		InvalidateStyleRedraw();
7239  		break;
7240  	case Message::SetAdditionalSelBack:
7241  		vs.SetElementRGB(Element::SelectionAdditionalBack, static_cast&lt;int&gt;(wParam));
7242  		InvalidateStyleRedraw();
7243  		break;
7244  	case Message::SetAdditionalSelAlpha:
7245  		vs.SetElementAlpha(Element::SelectionAdditionalBack, static_cast&lt;int&gt;(wParam));
7246  		InvalidateStyleRedraw();
7247  		break;
7248  	case Message::GetAdditionalSelAlpha:
7249  		if (vs.selection.layer == Layer::Base)
7250  			return static_cast&lt;sptr_t&gt;(Alpha::NoAlpha);
7251  		return vs.ElementColourForced(Element::SelectionAdditionalBack).GetAlpha();
7252  	case Message::SetAdditionalCaretFore:
7253  		vs.elementColours[Element::CaretAdditional] = ColourRGBA::FromIpRGB(SPtrFromUPtr(wParam));
7254  		InvalidateStyleRedraw();
7255  		break;
7256  	case Message::GetAdditionalCaretFore:
7257  		return vs.ElementColourForced(Element::CaretAdditional).OpaqueRGB();
7258  	case Message::RotateSelection:
7259  		sel.RotateMain();
7260  		InvalidateWholeSelection();
7261  		break;
7262  	case Message::SwapMainAnchorCaret:
7263  		InvalidateSelection(sel.RangeMain());
7264  		sel.RangeMain().Swap();
7265  		break;
7266  	case Message::MultipleSelectAddNext:
7267  		MultipleSelectAdd(AddNumber::one);
7268  		break;
7269  	case Message::MultipleSelectAddEach:
7270  		MultipleSelectAdd(AddNumber::each);
7271  		break;
7272  	case Message::ChangeLexerState:
7273  		pdoc-&gt;ChangeLexerState(PositionFromUPtr(wParam), lParam);
7274  		break;
7275  	case Message::SetIdentifier:
7276  		SetCtrlID(static_cast&lt;int&gt;(wParam));
7277  		break;
7278  	case Message::GetIdentifier:
7279  		return GetCtrlID();
7280  	case Message::SetTechnology:
7281  		break;
7282  	case Message::GetTechnology:
7283  		return static_cast&lt;sptr_t&gt;(technology);
7284  	case Message::CountCharacters:
7285  		return pdoc-&gt;CountCharacters(PositionFromUPtr(wParam), lParam);
7286  	case Message::CountCodeUnits:
7287  		return pdoc-&gt;CountUTF16(PositionFromUPtr(wParam), lParam);
7288  	default:
7289  		return DefWndProc(iMessage, wParam, lParam);
7290  	}
7291  	return 0;
7292  }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Editor.cxx</h3>
            <pre><code>1  #include &lt;cstddef&gt;
2  #include &lt;cstdlib&gt;
3  #include &lt;cstdint&gt;
4  #include &lt;cassert&gt;
5  #include &lt;cstring&gt;
6  #include &lt;cstdio&gt;
7  #include &lt;cmath&gt;
8  #include &lt;stdexcept&gt;
9  #include &lt;string&gt;
10  #include &lt;string_view&gt;
11  #include &lt;vector&gt;
12  #include &lt;map&gt;
13  #include &lt;set&gt;
14  #include &lt;forward_list&gt;
15  #include &lt;optional&gt;
16  #include &lt;algorithm&gt;
17  #include &lt;iterator&gt;
18  #include &lt;memory&gt;
19  #include &lt;chrono&gt;
20  #include &lt;atomic&gt;
21  #include &lt;mutex&gt;
22  #include &lt;thread&gt;
23  #include &lt;future&gt;
24  #include &quot;ScintillaTypes.h&quot;
25  #include &quot;ScintillaMessages.h&quot;
26  #include &quot;ScintillaStructures.h&quot;
27  #include &quot;ILoader.h&quot;
28  #include &quot;ILexer.h&quot;
29  #include &quot;Debugging.h&quot;
30  #include &quot;Geometry.h&quot;
31  #include &quot;Platform.h&quot;
32  #include &quot;CharacterType.h&quot;
33  #include &quot;CharacterCategoryMap.h&quot;
34  #include &quot;Position.h&quot;
35  #include &quot;UniqueString.h&quot;
36  #include &quot;SplitVector.h&quot;
37  #include &quot;Partitioning.h&quot;
38  #include &quot;RunStyles.h&quot;
39  #include &quot;ContractionState.h&quot;
40  #include &quot;CellBuffer.h&quot;
41  #include &quot;PerLine.h&quot;
42  #include &quot;KeyMap.h&quot;
43  #include &quot;Indicator.h&quot;
44  #include &quot;LineMarker.h&quot;
45  #include &quot;Style.h&quot;
46  #include &quot;ViewStyle.h&quot;
47  #include &quot;CharClassify.h&quot;
48  #include &quot;Decoration.h&quot;
49  #include &quot;CaseFolder.h&quot;
50  #include &quot;Document.h&quot;
51  #include &quot;UniConversion.h&quot;
52  #include &quot;DBCS.h&quot;
53  #include &quot;Selection.h&quot;
54  #include &quot;PositionCache.h&quot;
55  #include &quot;EditModel.h&quot;
56  #include &quot;MarginView.h&quot;
57  #include &quot;EditView.h&quot;
58  #include &quot;Editor.h&quot;
59  #include &quot;ElapsedPeriod.h&quot;
60  using namespace Scintilla;
61  using namespace Scintilla::Internal;
62  namespace {
63  constexpr bool CanDeferToLastStep(const DocModification &amp;mh) noexcept {
64  	if (FlagSet(mh.modificationType, (ModificationFlags::BeforeInsert | ModificationFlags::BeforeDelete)))
65  		return true;	
66  	if (!FlagSet(mh.modificationType, (ModificationFlags::Undo | ModificationFlags::Redo)))
67  		return false;	
68  	if (FlagSet(mh.modificationType, ModificationFlags::MultiStepUndoRedo))
69  		return true;	
70  	return false;		
71  }
72  constexpr bool CanEliminate(const DocModification &amp;mh) noexcept {
73  	return
74  		FlagSet(mh.modificationType, (ModificationFlags::BeforeInsert | ModificationFlags::BeforeDelete));
75  }
76  constexpr bool IsLastStep(const DocModification &amp;mh) noexcept {
77  	return
78  		FlagSet(mh.modificationType, (ModificationFlags::Undo | ModificationFlags::Redo))
79  	    &amp;&amp; (FlagSet(mh.modificationType, ModificationFlags::MultiStepUndoRedo))
80  	    &amp;&amp; (FlagSet(mh.modificationType, ModificationFlags::LastStepInUndoRedo))
81  	    &amp;&amp; (FlagSet(mh.modificationType, ModificationFlags::MultilineUndoRedo));
82  }
83  }
84  Timer::Timer() noexcept :
85  		ticking(false), ticksToWait(0), tickerID{} {}
86  Idler::Idler() noexcept :
87  		state(false), idlerID(nullptr) {}
88  static constexpr bool IsAllSpacesOrTabs(std::string_view sv) noexcept {
89  	for (const char ch : sv) {
90  		if (!IsSpaceOrTab(ch))
91  			return false;
92  	}
93  	return true;
94  }
95  Editor::Editor() : durationWrapOneByte(0.000001, 0.00000001, 0.00001) {
96  	ctrlID = 0;
97  	stylesValid = false;
98  	technology = Technology::Default;
99  	scaleRGBAImage = 100.0f;
100  	cursorMode = CursorShape::Normal;
101  	errorStatus = Status::Ok;
102  	mouseDownCaptures = true;
103  	mouseWheelCaptures = true;
104  	lastClickTime = 0;
105  	doubleClickCloseThreshold = Point(3, 3);
106  	dwellDelay = TimeForever;
107  	ticksToDwell = TimeForever;
108  	dwelling = false;
109  	ptMouseLast.x = 0;
110  	ptMouseLast.y = 0;
111  	inDragDrop = DragDrop::none;
112  	dropWentOutside = false;
113  	posDrop = SelectionPosition(Sci::invalidPosition);
114  	hotSpotClickPos = Sci::invalidPosition;
115  	selectionUnit = TextUnit::character;
116  	lastXChosen = 0;
117  	lineAnchorPos = 0;
118  	originalAnchorPos = 0;
119  	wordSelectAnchorStartPos = 0;
120  	wordSelectAnchorEndPos = 0;
121  	wordSelectInitialCaretPos = -1;
122  	caretPolicies.x = { CaretPolicy::Slop | CaretPolicy::Even, 50 };
123  	caretPolicies.y = { CaretPolicy::Even, 0 };
124  	visiblePolicy = { 0, 0 };
125  	searchAnchor = 0;
126  	xCaretMargin = 50;
127  	horizontalScrollBarVisible = true;
128  	scrollWidth = 2000;
129  	verticalScrollBarVisible = true;
130  	endAtLastLine = true;
131  	caretSticky = CaretSticky::Off;
132  	marginOptions = MarginOption::None;
133  	mouseSelectionRectangularSwitch = false;
134  	multipleSelection = false;
135  	additionalSelectionTyping = false;
136  	multiPasteMode = MultiPaste::Once;
137  	virtualSpaceOptions = VirtualSpace::None;
138  	targetRange = SelectionSegment();
139  	searchFlags = FindOption::None;
140  	topLine = 0;
141  	posTopLine = 0;
142  	lengthForEncode = -1;
143  	needUpdateUI = Update::None;
144  	ContainerNeedsUpdate(Update::Content);
145  	paintState = PaintState::notPainting;
146  	paintAbandonedByStyling = false;
147  	paintingAllText = false;
148  	willRedrawAll = false;
149  	idleStyling = IdleStyling::None;
150  	needIdleStyling = false;
151  	modEventMask = ModificationFlags::EventMaskAll;
152  	commandEvents = true;
153  	pdoc-&gt;AddWatcher(this, nullptr);
154  	recordingMacro = false;
155  	foldAutomatic = AutomaticFold::None;
156  	convertPastes = true;
157  	SetRepresentations();
158  }
159  Editor::~Editor() {
160  	pdoc-&gt;RemoveWatcher(this, nullptr);
161  }
162  void Editor::Finalise() {
163  	SetIdle(false);
164  	CancelModes();
165  }
166  void Editor::SetRepresentations() {
167  	reprs.SetDefaultRepresentations(pdoc-&gt;dbcsCodePage);
168  }
169  void Editor::DropGraphics() noexcept {
170  	marginView.DropGraphics();
171  	view.DropGraphics();
172  }
173  void Editor::InvalidateStyleData() noexcept {
174  	stylesValid = false;
175  	vs.technology = technology;
176  	DropGraphics();
177  	view.llc.Invalidate(LineLayout::ValidLevel::invalid);
178  	view.posCache-&gt;Clear();
179  }
180  void Editor::InvalidateStyleRedraw() {
181  	NeedWrapping();
182  	InvalidateStyleData();
183  	Redraw();
184  }
185  void Editor::RefreshStyleData() {
186  	if (!stylesValid) {
187  		stylesValid = true;
188  		AutoSurface surface(this);
189  		if (surface) {
190  			vs.Refresh(*surface, pdoc-&gt;tabInChars);
191  		}
192  		SetScrollBars();
193  		SetRectangularRange();
194  	}
195  }
196  bool Editor::HasMarginWindow() const noexcept {
197  	return wMargin.Created();
198  }
199  Point Editor::GetVisibleOriginInMain() const {
200  	return Point(0, 0);
201  }
202  PointDocument Editor::DocumentPointFromView(Point ptView) const {
203  	PointDocument ptDocument(ptView);
204  	if (HasMarginWindow()) {
205  		const Point ptOrigin = GetVisibleOriginInMain();
206  		ptDocument.x += ptOrigin.x;
207  		ptDocument.y += ptOrigin.y;
208  	} else {
209  		ptDocument.x += xOffset;
210  		ptDocument.y += topLine * vs.lineHeight;
211  	}
212  	return ptDocument;
213  }
214  Sci::Line Editor::TopLineOfMain() const noexcept {
215  	if (HasMarginWindow())
216  		return 0;
217  	else
218  		return topLine;
219  }
220  Point Editor::ClientSize() const {
221  	const PRectangle rcClient = GetClientRectangle();
222  	return Point(rcClient.Width(), rcClient.Height());
223  }
224  PRectangle Editor::GetClientRectangle() const {
225  	return wMain.GetClientPosition();
226  }
227  PRectangle Editor::GetClientDrawingRectangle() {
228  	return GetClientRectangle();
229  }
230  PRectangle Editor::GetTextRectangle() const {
231  	PRectangle rc = GetClientRectangle();
232  	rc.left += vs.textStart;
233  	rc.right -= vs.rightMarginWidth;
234  	return rc;
235  }
236  Sci::Line Editor::LinesOnScreen() const {
237  	const Point sizeClient = ClientSize();
238  	const int htClient = static_cast&lt;int&gt;(sizeClient.y);
239  	return htClient / vs.lineHeight;
240  }
241  Sci::Line Editor::LinesToScroll() const {
242  	const Sci::Line retVal = LinesOnScreen() - 1;
243  	if (retVal &lt; 1)
244  		return 1;
245  	else
246  		return retVal;
247  }
248  Sci::Line Editor::MaxScrollPos() const {
249  	Sci::Line retVal = pcs-&gt;LinesDisplayed();
250  	if (endAtLastLine) {
251  		retVal -= LinesOnScreen();
252  	} else {
253  		retVal--;
254  	}
255  	if (retVal &lt; 0) {
256  		return 0;
257  	} else {
258  		return retVal;
259  	}
260  }
261  SelectionPosition Editor::ClampPositionIntoDocument(SelectionPosition sp) const {
262  	if (sp.Position() &lt; 0) {
263  		return SelectionPosition(0);
264  	} else if (sp.Position() &gt; pdoc-&gt;Length()) {
265  		return SelectionPosition(pdoc-&gt;Length());
266  	} else {
267  		if (!pdoc-&gt;IsLineEndPosition(sp.Position()))
268  			sp.SetVirtualSpace(0);
269  		return sp;
270  	}
271  }
272  Point Editor::LocationFromPosition(SelectionPosition pos, PointEnd pe) {
273  	const PRectangle rcClient = GetTextRectangle();
274  	RefreshStyleData();
275  	AutoSurface surface(this);
276  	return view.LocationFromPosition(surface, *this, pos, topLine, vs, pe, rcClient);
277  }
278  Point Editor::LocationFromPosition(Sci::Position pos, PointEnd pe) {
279  	return LocationFromPosition(SelectionPosition(pos), pe);
280  }
281  int Editor::XFromPosition(SelectionPosition sp) {
282  	const Point pt = LocationFromPosition(sp);
283  	return static_cast&lt;int&gt;(pt.x) - vs.textStart + xOffset;
284  }
285  SelectionPosition Editor::SPositionFromLocation(Point pt, bool canReturnInvalid, bool charPosition, bool virtualSpace) {
286  	RefreshStyleData();
287  	AutoSurface surface(this);
288  	PRectangle rcClient = GetTextRectangle();
289  	const Point ptOrigin = GetVisibleOriginInMain();
290  	rcClient.Move(-ptOrigin.x, -ptOrigin.y);
291  	if (canReturnInvalid) {
292  		if (!rcClient.Contains(pt))
293  			return SelectionPosition(Sci::invalidPosition);
294  		if (pt.x &lt; vs.textStart)
295  			return SelectionPosition(Sci::invalidPosition);
296  		if (pt.y &lt; 0)
297  			return SelectionPosition(Sci::invalidPosition);
298  	}
299  	const PointDocument ptdoc = DocumentPointFromView(pt);
300  	return view.SPositionFromLocation(surface, *this, ptdoc, canReturnInvalid,
301  		charPosition, virtualSpace, vs, rcClient);
302  }
303  Sci::Position Editor::PositionFromLocation(Point pt, bool canReturnInvalid, bool charPosition) {
304  	return SPositionFromLocation(pt, canReturnInvalid, charPosition, false).Position();
305  }
306  SelectionPosition Editor::SPositionFromLineX(Sci::Line lineDoc, int x) {
307  	RefreshStyleData();
308  	if (lineDoc &gt;= pdoc-&gt;LinesTotal())
309  		return SelectionPosition(pdoc-&gt;Length());
310  	AutoSurface surface(this);
311  	return view.SPositionFromLineX(surface, *this, lineDoc, x, vs);
312  }
313  Sci::Position Editor::PositionFromLineX(Sci::Line lineDoc, int x) {
314  	return SPositionFromLineX(lineDoc, x).Position();
315  }
316  Sci::Line Editor::LineFromLocation(Point pt) const noexcept {
317  	return pcs-&gt;DocFromDisplay(static_cast&lt;int&gt;(pt.y) / vs.lineHeight + topLine);
318  }
319  void Editor::SetTopLine(Sci::Line topLineNew) {
320  	if ((topLine != topLineNew) &amp;&amp; (topLineNew &gt;= 0)) {
321  		topLine = topLineNew;
322  		ContainerNeedsUpdate(Update::VScroll);
323  	}
324  	posTopLine = pdoc-&gt;LineStart(pcs-&gt;DocFromDisplay(topLine));
325  }
326  bool Editor::AbandonPaint() {
327  	if ((paintState == PaintState::painting) &amp;&amp; !paintingAllText) {
328  		paintState = PaintState::abandoned;
329  	}
330  	return paintState == PaintState::abandoned;
331  }
332  void Editor::RedrawRect(PRectangle rc) {
333  	const PRectangle rcClient = GetClientRectangle();
334  	if (rc.top &lt; rcClient.top)
335  		rc.top = rcClient.top;
336  	if (rc.bottom &gt; rcClient.bottom)
337  		rc.bottom = rcClient.bottom;
338  	if (rc.left &lt; rcClient.left)
339  		rc.left = rcClient.left;
340  	if (rc.right &gt; rcClient.right)
341  		rc.right = rcClient.right;
342  	if ((rc.bottom &gt; rc.top) &amp;&amp; (rc.right &gt; rc.left)) {
343  		wMain.InvalidateRectangle(rc);
344  	}
345  }
346  void Editor::DiscardOverdraw() {
347  }
348  void Editor::Redraw() {
349  	if (redrawPendingText) {
350  		return;
351  	}
352  	const PRectangle rcClient = GetClientRectangle();
353  	wMain.InvalidateRectangle(rcClient);
354  	if (HasMarginWindow()) {
355  		wMargin.InvalidateAll();
356  	} else if (paintState == PaintState::notPainting) {
357  		redrawPendingText = true;
358  	}
359  }
360  void Editor::RedrawSelMargin(Sci::Line line, bool allAfter) {
361  	const bool markersInText = vs.maskInLine || vs.maskDrawInText;
362  	if (!HasMarginWindow() || markersInText) {	
363  		if (AbandonPaint()) {
364  			return;
365  		}
366  	}
367  	if (HasMarginWindow() &amp;&amp; markersInText) {
368  		Redraw();
369  		return;
370  	}
371  	if (redrawPendingMargin) {
372  		return;
373  	}
374  	PRectangle rcMarkers = GetClientRectangle();
375  	if (!markersInText) {
376  		rcMarkers.right = rcMarkers.left + vs.fixedColumnWidth;
377  	}
378  	const PRectangle rcMarkersFull = rcMarkers;
379  	if (line != -1) {
380  		PRectangle rcLine = RectangleFromRange(Range(pdoc-&gt;LineStart(line)), 0);
381  		if (vs.largestMarkerHeight &gt; vs.lineHeight) {
382  			const int delta = (vs.largestMarkerHeight - vs.lineHeight + 1) / 2;
383  			rcLine.top -= delta;
384  			rcLine.bottom += delta;
385  			if (rcLine.top &lt; rcMarkers.top)
386  				rcLine.top = rcMarkers.top;
387  			if (rcLine.bottom &gt; rcMarkers.bottom)
388  				rcLine.bottom = rcMarkers.bottom;
389  		}
390  		rcMarkers.top = rcLine.top;
391  		if (!allAfter)
392  			rcMarkers.bottom = rcLine.bottom;
393  		if (rcMarkers.Empty())
394  			return;
395  	}
396  	if (HasMarginWindow()) {
397  		const Point ptOrigin = GetVisibleOriginInMain();
398  		rcMarkers.Move(-ptOrigin.x, -ptOrigin.y);
399  		wMargin.InvalidateRectangle(rcMarkers);
400  	} else {
401  		wMain.InvalidateRectangle(rcMarkers);
402  		if (rcMarkers == rcMarkersFull) {
403  			redrawPendingMargin = true;
404  		}
405  	}
406  }
407  PRectangle Editor::RectangleFromRange(Range r, int overlap) {
408  	const Sci::Line minLine = pcs-&gt;DisplayFromDoc(
409  		pdoc-&gt;SciLineFromPosition(r.First()));
410  	const Sci::Line maxLine = pcs-&gt;DisplayLastFromDoc(
411  		pdoc-&gt;SciLineFromPosition(r.Last()));
412  	const PRectangle rcClientDrawing = GetClientDrawingRectangle();
413  	PRectangle rc;
414  	const int leftTextOverlap = ((xOffset == 0) &amp;&amp; (vs.leftMarginWidth &gt; 0)) ? 1 : 0;
415  	rc.left = static_cast&lt;XYPOSITION&gt;(vs.textStart - leftTextOverlap);
416  	rc.top = static_cast&lt;XYPOSITION&gt;((minLine - TopLineOfMain()) * vs.lineHeight - overlap);
417  	if (rc.top &lt; rcClientDrawing.top)
418  		rc.top = rcClientDrawing.top;
419  	rc.right = rcClientDrawing.right;
420  	rc.bottom = static_cast&lt;XYPOSITION&gt;((maxLine - TopLineOfMain() + 1) * vs.lineHeight + overlap);
421  	return rc;
422  }
423  void Editor::InvalidateRange(Sci::Position start, Sci::Position end) {
424  	if (redrawPendingText) {
425  		return;
426  	}
427  	RedrawRect(RectangleFromRange(Range(start, end), view.LinesOverlap() ? vs.lineOverlap : 0));
428  }
429  Sci::Position Editor::CurrentPosition() const noexcept {
430  	return sel.MainCaret();
431  }
432  bool Editor::SelectionEmpty() const noexcept {
433  	return sel.Empty();
434  }
435  SelectionPosition Editor::SelectionStart() noexcept {
436  	return sel.RangeMain().Start();
437  }
438  SelectionPosition Editor::SelectionEnd() noexcept {
439  	return sel.RangeMain().End();
440  }
441  void Editor::SetRectangularRange() {
442  	if (sel.IsRectangular()) {
443  		const int xAnchor = XFromPosition(sel.Rectangular().anchor);
444  		int xCaret = XFromPosition(sel.Rectangular().caret);
445  		if (sel.selType == Selection::SelTypes::thin) {
446  			xCaret = xAnchor;
447  		}
448  		const Sci::Line lineAnchorRect =
449  			pdoc-&gt;SciLineFromPosition(sel.Rectangular().anchor.Position());
450  		const Sci::Line lineCaret =
451  			pdoc-&gt;SciLineFromPosition(sel.Rectangular().caret.Position());
452  		const int increment = (lineCaret &gt; lineAnchorRect) ? 1 : -1;
453  		AutoSurface surface(this);
454  		for (Sci::Line line=lineAnchorRect; line != lineCaret+increment; line += increment) {
455  			SelectionRange range(
456  				view.SPositionFromLineX(surface, *this, line, xCaret, vs),
457  				view.SPositionFromLineX(surface, *this, line, xAnchor, vs));
458  			if (!FlagSet(virtualSpaceOptions, VirtualSpace::RectangularSelection))
459  				range.ClearVirtualSpace();
460  			if (line == lineAnchorRect)
461  				sel.SetSelection(range);
462  			else
463  				sel.AddSelectionWithoutTrim(range);
464  		}
465  	}
466  }
467  void Editor::ThinRectangularRange() {
468  	if (sel.IsRectangular()) {
469  		sel.selType = Selection::SelTypes::thin;
470  		if (sel.Rectangular().caret &lt; sel.Rectangular().anchor) {
471  			sel.Rectangular() = SelectionRange(sel.Range(sel.Count()-1).caret, sel.Range(0).anchor);
472  		} else {
473  			sel.Rectangular() = SelectionRange(sel.Range(sel.Count()-1).anchor, sel.Range(0).caret);
474  		}
475  		SetRectangularRange();
476  	}
477  }
478  void Editor::InvalidateSelection(SelectionRange newMain, bool invalidateWholeSelection) {
479  	if (sel.Count() &gt; 1 || !(sel.RangeMain().anchor == newMain.anchor) || sel.IsRectangular()) {
480  		invalidateWholeSelection = true;
481  	}
482  	Sci::Position firstAffected = std::min(sel.RangeMain().Start().Position(), newMain.Start().Position());
483  	Sci::Position lastAffected = std::max(newMain.caret.Position()+1, newMain.anchor.Position());
484  	lastAffected = std::max(lastAffected, sel.RangeMain().End().Position());
485  	if (invalidateWholeSelection) {
486  		for (size_t r=0; r&lt;sel.Count(); r++) {
487  			firstAffected = std::min(firstAffected, sel.Range(r).caret.Position());
488  			firstAffected = std::min(firstAffected, sel.Range(r).anchor.Position());
489  			lastAffected = std::max(lastAffected, sel.Range(r).caret.Position()+1);
490  			lastAffected = std::max(lastAffected, sel.Range(r).anchor.Position());
491  		}
492  	}
493  	ContainerNeedsUpdate(Update::Selection);
494  	InvalidateRange(firstAffected, lastAffected);
495  }
496  void Editor::InvalidateWholeSelection() {
497  	InvalidateSelection(sel.RangeMain(), true);
498  }
499  SelectionRange Editor::LineSelectionRange(SelectionPosition currentPos_, SelectionPosition anchor_) const {
500  	if (currentPos_ &gt; anchor_) {
501  		anchor_ = SelectionPosition(
502  			pdoc-&gt;LineStart(pdoc-&gt;LineFromPosition(anchor_.Position())));
503  		currentPos_ = SelectionPosition(
504  			pdoc-&gt;LineEnd(pdoc-&gt;LineFromPosition(currentPos_.Position())));
505  	} else {
506  		currentPos_ = SelectionPosition(
507  			pdoc-&gt;LineStart(pdoc-&gt;LineFromPosition(currentPos_.Position())));
508  		anchor_ = SelectionPosition(
509  			pdoc-&gt;LineEnd(pdoc-&gt;LineFromPosition(anchor_.Position())));
510  	}
511  	return SelectionRange(currentPos_, anchor_);
512  }
513  void Editor::SetSelection(SelectionPosition currentPos_, SelectionPosition anchor_) {
514  	currentPos_ = ClampPositionIntoDocument(currentPos_);
515  	anchor_ = ClampPositionIntoDocument(anchor_);
516  	const Sci::Line currentLine = pdoc-&gt;SciLineFromPosition(currentPos_.Position());
517  	SelectionRange rangeNew(currentPos_, anchor_);
518  	if (sel.selType == Selection::SelTypes::lines) {
519  		rangeNew = LineSelectionRange(currentPos_, anchor_);
520  	}
521  	if (sel.Count() &gt; 1 || !(sel.RangeMain() == rangeNew)) {
522  		InvalidateSelection(rangeNew);
523  	}
524  	sel.RangeMain() = rangeNew;
525  	SetRectangularRange();
526  	ClaimSelection();
527  	SetHoverIndicatorPosition(sel.MainCaret());
528  	if (marginView.highlightDelimiter.NeedsDrawing(currentLine)) {
529  		RedrawSelMargin();
530  	}
531  	QueueIdleWork(WorkItems::updateUI);
532  }
533  void Editor::SetSelection(Sci::Position currentPos_, Sci::Position anchor_) {
534  	SetSelection(SelectionPosition(currentPos_), SelectionPosition(anchor_));
535  }
536  void Editor::SetSelection(SelectionPosition currentPos_) {
537  	currentPos_ = ClampPositionIntoDocument(currentPos_);
538  	const Sci::Line currentLine = pdoc-&gt;SciLineFromPosition(currentPos_.Position());
539  	if (sel.Count() &gt; 1 || !(sel.RangeMain().caret == currentPos_)) {
540  		InvalidateSelection(SelectionRange(currentPos_));
541  	}
542  	if (sel.IsRectangular()) {
543  		sel.Rectangular() =
544  			SelectionRange(SelectionPosition(currentPos_), sel.Rectangular().anchor);
545  		SetRectangularRange();
546  	} else if (sel.selType == Selection::SelTypes::lines) {
547  		sel.RangeMain() = LineSelectionRange(currentPos_, sel.RangeMain().anchor);
548  	} else {
549  		sel.RangeMain() =
550  			SelectionRange(SelectionPosition(currentPos_), sel.RangeMain().anchor);
551  	}
552  	ClaimSelection();
553  	SetHoverIndicatorPosition(sel.MainCaret());
554  	if (marginView.highlightDelimiter.NeedsDrawing(currentLine)) {
555  		RedrawSelMargin();
556  	}
557  	QueueIdleWork(WorkItems::updateUI);
558  }
559  void Editor::SetEmptySelection(SelectionPosition currentPos_) {
560  	const Sci::Line currentLine = pdoc-&gt;SciLineFromPosition(currentPos_.Position());
561  	SelectionRange rangeNew(ClampPositionIntoDocument(currentPos_));
562  	if (sel.Count() &gt; 1 || !(sel.RangeMain() == rangeNew)) {
563  		InvalidateSelection(rangeNew);
564  	}
565  	sel.Clear();
566  	sel.RangeMain() = rangeNew;
567  	SetRectangularRange();
568  	ClaimSelection();
569  	SetHoverIndicatorPosition(sel.MainCaret());
570  	if (marginView.highlightDelimiter.NeedsDrawing(currentLine)) {
571  		RedrawSelMargin();
572  	}
573  	QueueIdleWork(WorkItems::updateUI);
574  }
575  void Editor::SetEmptySelection(Sci::Position currentPos_) {
576  	SetEmptySelection(SelectionPosition(currentPos_));
577  }
578  void Editor::MultipleSelectAdd(AddNumber addNumber) {
579  	if (SelectionEmpty() || !multipleSelection) {
580  		const Sci::Position startWord = pdoc-&gt;ExtendWordSelect(sel.MainCaret(), -1, true);
581  		const Sci::Position endWord = pdoc-&gt;ExtendWordSelect(startWord, 1, true);
582  		TrimAndSetSelection(endWord, startWord);
583  	} else {
584  		if (!pdoc-&gt;HasCaseFolder())
585  			pdoc-&gt;SetCaseFolder(CaseFolderForEncoding());
586  		const Range rangeMainSelection(sel.RangeMain().Start().Position(), sel.RangeMain().End().Position());
587  		const std::string selectedText = RangeText(rangeMainSelection.start, rangeMainSelection.end);
588  		const Range rangeTarget(targetRange.start.Position(), targetRange.end.Position());
589  		std::vector&lt;Range&gt; searchRanges;
590  		if (rangeTarget.Overlaps(rangeMainSelection)) {
591  			if (rangeMainSelection.end &lt; rangeTarget.end)
592  				searchRanges.push_back(Range(rangeMainSelection.end, rangeTarget.end));
593  			if (rangeTarget.start &lt; rangeMainSelection.start)
594  				searchRanges.push_back(Range(rangeTarget.start, rangeMainSelection.start));
595  		} else {
596  			searchRanges.push_back(rangeTarget);
597  		}
598  		for (const Range range : searchRanges) {
599  			Sci::Position searchStart = range.start;
600  			const Sci::Position searchEnd = range.end;
601  			for (;;) {
602  				Sci::Position lengthFound = selectedText.length();
603  				const Sci::Position pos = pdoc-&gt;FindText(searchStart, searchEnd,
604  					selectedText.c_str(), searchFlags, &amp;lengthFound);
605  				if (pos &gt;= 0) {
606  					sel.AddSelection(SelectionRange(pos + lengthFound, pos));
607  					ContainerNeedsUpdate(Update::Selection);
608  					ScrollRange(sel.RangeMain());
609  					Redraw();
610  					if (addNumber == AddNumber::one)
611  						return;
612  					searchStart = pos + lengthFound;
613  				} else {
614  					break;
615  				}
616  			}
617  		}
618  	}
619  }
620  bool Editor::RangeContainsProtected(Sci::Position start, Sci::Position end) const noexcept {
621  	if (vs.ProtectionActive()) {
622  		if (start &gt; end) {
623  			std::swap(start, end);
624  		}
625  		for (Sci::Position pos = start; pos &lt; end; pos++) {
626  			if (vs.styles[pdoc-&gt;StyleIndexAt(pos)].IsProtected())
627  				return true;
628  		}
629  	}
630  	return false;
631  }
632  bool Editor::SelectionContainsProtected() const noexcept {
633  	for (size_t r=0; r&lt;sel.Count(); r++) {
634  		if (RangeContainsProtected(sel.Range(r).Start().Position(),
635  			sel.Range(r).End().Position())) {
636  			return true;
637  		}
638  	}
639  	return false;
640  }
641  Sci::Position Editor::MovePositionOutsideChar(Sci::Position pos, Sci::Position moveDir, bool checkLineEnd) const {
642  	return MovePositionOutsideChar(SelectionPosition(pos), moveDir, checkLineEnd).Position();
643  }
644  SelectionPosition Editor::MovePositionOutsideChar(SelectionPosition pos, Sci::Position moveDir, bool checkLineEnd) const {
645  	const Sci::Position posMoved = pdoc-&gt;MovePositionOutsideChar(pos.Position(), moveDir, checkLineEnd);
646  	if (posMoved != pos.Position())
647  		pos.SetPosition(posMoved);
648  	if (vs.ProtectionActive()) {
649  		if (moveDir &gt; 0) {
650  			if ((pos.Position() &gt; 0) &amp;&amp; vs.styles[pdoc-&gt;StyleIndexAt(pos.Position() - 1)].IsProtected()) {
651  				while ((pos.Position() &lt; pdoc-&gt;Length()) &amp;&amp;
652  				        (vs.styles[pdoc-&gt;StyleIndexAt(pos.Position())].IsProtected()))
653  					pos.Add(1);
654  			}
655  		} else if (moveDir &lt; 0) {
656  			if (vs.styles[pdoc-&gt;StyleIndexAt(pos.Position())].IsProtected()) {
657  				while ((pos.Position() &gt; 0) &amp;&amp;
658  				        (vs.styles[pdoc-&gt;StyleIndexAt(pos.Position() - 1)].IsProtected()))
659  					pos.Add(-1);
660  			}
661  		}
662  	}
663  	return pos;
664  }
665  void Editor::MovedCaret(SelectionPosition newPos, SelectionPosition previousPos,
666  	bool ensureVisible, CaretPolicies policies) {
667  	const Sci::Line currentLine = pdoc-&gt;SciLineFromPosition(newPos.Position());
668  	if (ensureVisible) {
669  		if (currentLine &gt;= wrapPending.start) {
670  			if (WrapLines(WrapScope::wsAll)) {
671  				Redraw();
672  			}
673  		}
674  		const XYScrollPosition newXY = XYScrollToMakeVisible(
675  			SelectionRange(posDrag.IsValid() ? posDrag : newPos), XYScrollOptions::all, policies);
676  		if (previousPos.IsValid() &amp;&amp; (newXY.xOffset == xOffset)) {
677  			ScrollTo(newXY.topLine);
678  			InvalidateSelection(SelectionRange(previousPos), true);
679  		} else {
680  			SetXYScroll(newXY);
681  		}
682  	}
683  	ShowCaretAtCurrentPosition();
684  	NotifyCaretMove();
685  	ClaimSelection();
686  	SetHoverIndicatorPosition(sel.MainCaret());
687  	QueueIdleWork(WorkItems::updateUI);
688  	if (marginView.highlightDelimiter.NeedsDrawing(currentLine)) {
689  		RedrawSelMargin();
690  	}
691  }
692  void Editor::MovePositionTo(SelectionPosition newPos, Selection::SelTypes selt, bool ensureVisible) {
693  	const SelectionPosition spCaret = ((sel.Count() == 1) &amp;&amp; sel.Empty()) ?
694  		sel.Last() : SelectionPosition(Sci::invalidPosition);
695  	const Sci::Position delta = newPos.Position() - sel.MainCaret();
696  	newPos = ClampPositionIntoDocument(newPos);
697  	newPos = MovePositionOutsideChar(newPos, delta);
698  	if (!multipleSelection &amp;&amp; sel.IsRectangular() &amp;&amp; (selt == Selection::SelTypes::stream)) {
699  		InvalidateSelection(SelectionRange(newPos), true);
700  		sel.DropAdditionalRanges();
701  	}
702  	if (!sel.IsRectangular() &amp;&amp; (selt == Selection::SelTypes::rectangle)) {
703  		InvalidateSelection(sel.RangeMain(), false);
704  		SelectionRange rangeMain = sel.RangeMain();
705  		sel.Clear();
706  		sel.Rectangular() = rangeMain;
707  	}
708  	if (selt != Selection::SelTypes::none) {
709  		sel.selType = selt;
710  	}
711  	if (selt != Selection::SelTypes::none || sel.MoveExtends()) {
712  		SetSelection(newPos);
713  	} else {
714  		SetEmptySelection(newPos);
715  	}
716  	MovedCaret(newPos, spCaret, ensureVisible, caretPolicies);
717  }
718  void Editor::MovePositionTo(Sci::Position newPos, Selection::SelTypes selt, bool ensureVisible) {
719  	MovePositionTo(SelectionPosition(newPos), selt, ensureVisible);
720  }
721  SelectionPosition Editor::MovePositionSoVisible(SelectionPosition pos, int moveDir) {
722  	pos = ClampPositionIntoDocument(pos);
723  	pos = MovePositionOutsideChar(pos, moveDir);
724  	const Sci::Line lineDoc = pdoc-&gt;SciLineFromPosition(pos.Position());
725  	if (pcs-&gt;GetVisible(lineDoc)) {
726  		return pos;
727  	} else {
728  		Sci::Line lineDisplay = pcs-&gt;DisplayFromDoc(lineDoc);
729  		if (moveDir &gt; 0) {
730  			lineDisplay = std::clamp&lt;Sci::Line&gt;(lineDisplay, 0, pcs-&gt;LinesDisplayed());
731  			return SelectionPosition(
732  				pdoc-&gt;LineStart(pcs-&gt;DocFromDisplay(lineDisplay)));
733  		} else {
734  			lineDisplay = std::clamp&lt;Sci::Line&gt;(lineDisplay - 1, 0, pcs-&gt;LinesDisplayed());
735  			return SelectionPosition(
736  				pdoc-&gt;LineEnd(pcs-&gt;DocFromDisplay(lineDisplay)));
737  		}
738  	}
739  }
740  SelectionPosition Editor::MovePositionSoVisible(Sci::Position pos, int moveDir) {
741  	return MovePositionSoVisible(SelectionPosition(pos), moveDir);
742  }
743  Point Editor::PointMainCaret() {
744  	return LocationFromPosition(sel.Range(sel.Main()).caret);
745  }
746  void Editor::SetLastXChosen() {
747  	const Point pt = PointMainCaret();
748  	lastXChosen = static_cast&lt;int&gt;(pt.x) + xOffset;
749  }
750  void Editor::ScrollTo(Sci::Line line, bool moveThumb) {
751  	const Sci::Line topLineNew = std::clamp&lt;Sci::Line&gt;(line, 0, MaxScrollPos());
752  	if (topLineNew != topLine) {
753  #ifndef UNDER_CE
754  		const Sci::Line linesToMove = topLine - topLineNew;
755  		const bool performBlit = (std::abs(linesToMove) &lt;= 10) &amp;&amp; (paintState == PaintState::notPainting);
756  		willRedrawAll = !performBlit;
757  #endif
758  		SetTopLine(topLineNew);
759  		StyleAreaBounded(GetClientRectangle(), true);
760  #ifndef UNDER_CE
761  		if (performBlit) {
762  			ScrollText(linesToMove);
763  		} else {
764  			Redraw();
765  		}
766  		willRedrawAll = false;
767  #else
768  		Redraw();
769  #endif
770  		if (moveThumb) {
771  			SetVerticalScrollPos();
772  		}
773  	}
774  }
775  void Editor::ScrollText(Sci::Line &amp;bsol;* linesToMove */) {
776  	Redraw();
777  }
778  void Editor::HorizontalScrollTo(int xPos) {
779  	if (xPos &lt; 0)
780  		xPos = 0;
781  	if (!Wrapping() &amp;&amp; (xOffset != xPos)) {
782  		xOffset = xPos;
783  		ContainerNeedsUpdate(Update::HScroll);
784  		SetHorizontalScrollPos();
785  		RedrawRect(GetClientRectangle());
786  	}
787  }
788  void Editor::VerticalCentreCaret() {
789  	const Sci::Line lineDoc =
790  		pdoc-&gt;SciLineFromPosition(sel.IsRectangular() ? sel.Rectangular().caret.Position() : sel.MainCaret());
791  	const Sci::Line lineDisplay = pcs-&gt;DisplayFromDoc(lineDoc);
792  	const Sci::Line newTop = lineDisplay - (LinesOnScreen() / 2);
793  	if (topLine != newTop) {
794  		SetTopLine(newTop &gt; 0 ? newTop : 0);
795  		SetVerticalScrollPos();
796  		RedrawRect(GetClientRectangle());
797  	}
798  }
799  void Editor::MoveSelectedLines(int lineDelta) {
800  	if (sel.IsRectangular()) {
801  		return;
802  	}
803  	Sci::Position selectionStart = SelectionStart().Position();
804  	const Sci::Line startLine = pdoc-&gt;SciLineFromPosition(selectionStart);
805  	const Sci::Position beginningOfStartLine = pdoc-&gt;LineStart(startLine);
806  	selectionStart = beginningOfStartLine;
807  	Sci::Position selectionEnd = SelectionEnd().Position();
808  	const Sci::Line endLine = pdoc-&gt;SciLineFromPosition(selectionEnd);
809  	const Sci::Position beginningOfEndLine = pdoc-&gt;LineStart(endLine);
810  	bool appendEol = false;
811  	if (selectionEnd &gt; beginningOfEndLine
812  		|| selectionStart == selectionEnd) {
813  		selectionEnd = pdoc-&gt;LineStart(endLine + 1);
814  		appendEol = (selectionEnd == pdoc-&gt;Length() &amp;&amp; pdoc-&gt;SciLineFromPosition(selectionEnd) == endLine);
815  	}
816  	if ((selectionStart == 0 &amp;&amp; lineDelta &lt; 0)
817  		|| (selectionEnd == pdoc-&gt;Length() &amp;&amp; lineDelta &gt; 0)
818  	        || selectionStart == selectionEnd) {
819  		return;
820  	}
821  	UndoGroup ug(pdoc);
822  	if (lineDelta &gt; 0 &amp;&amp; selectionEnd == pdoc-&gt;LineStart(pdoc-&gt;LinesTotal() - 1)) {
823  		SetSelection(pdoc-&gt;MovePositionOutsideChar(selectionEnd - 1, -1), selectionEnd);
824  		ClearSelection();
825  		selectionEnd = CurrentPosition();
826  	}
827  	SetSelection(selectionStart, selectionEnd);
828  	const std::string selectedText = RangeText(selectionStart, selectionEnd);
829  	const Point currentLocation = LocationFromPosition(CurrentPosition());
830  	const Sci::Line currentLine = LineFromLocation(currentLocation);
831  	if (appendEol)
832  		SetSelection(pdoc-&gt;MovePositionOutsideChar(selectionStart - 1, -1), selectionEnd);
833  	ClearSelection();
834  	const std::string_view eol = pdoc-&gt;EOLString();
835  	if (currentLine + lineDelta &gt;= pdoc-&gt;LinesTotal())
836  		pdoc-&gt;InsertString(pdoc-&gt;Length(), eol);
837  	GoToLine(currentLine + lineDelta);
838  	Sci::Position selectionLength = pdoc-&gt;InsertString(CurrentPosition(), selectedText);
839  	if (appendEol) {
840  		const Sci::Position lengthInserted = pdoc-&gt;InsertString(CurrentPosition() + selectionLength, eol);
841  		selectionLength += lengthInserted;
842  	}
843  	SetSelection(CurrentPosition(), CurrentPosition() + selectionLength);
844  }
845  void Editor::MoveSelectedLinesUp() {
846  	MoveSelectedLines(-1);
847  }
848  void Editor::MoveSelectedLinesDown() {
849  	MoveSelectedLines(1);
850  }
851  void Editor::MoveCaretInsideView(bool ensureVisible) {
852  	const PRectangle rcClient = GetTextRectangle();
853  	const Point pt = PointMainCaret();
854  	if (pt.y &lt; rcClient.top) {
855  		MovePositionTo(SPositionFromLocation(
856  		            Point::FromInts(lastXChosen - xOffset, static_cast&lt;int&gt;(rcClient.top)),
857  					false, false, UserVirtualSpace()),
858  					Selection::SelTypes::none, ensureVisible);
859  	} else if ((pt.y + vs.lineHeight - 1) &gt; rcClient.bottom) {
860  		const ptrdiff_t yOfLastLineFullyDisplayed = static_cast&lt;ptrdiff_t&gt;(rcClient.top) + (LinesOnScreen() - 1) * vs.lineHeight;
861  		MovePositionTo(SPositionFromLocation(
862  		            Point::FromInts(lastXChosen - xOffset, static_cast&lt;int&gt;(rcClient.top + yOfLastLineFullyDisplayed)),
863  					false, false, UserVirtualSpace()),
864  		        Selection::SelTypes::none, ensureVisible);
865  	}
866  }
867  Sci::Line Editor::DisplayFromPosition(Sci::Position pos) {
868  	AutoSurface surface(this);
869  	return view.DisplayFromPosition(surface, *this, pos, vs);
870  }
871  Editor::XYScrollPosition Editor::XYScrollToMakeVisible(const SelectionRange &amp;range,
872  	const XYScrollOptions options, CaretPolicies policies) {
873  	const PRectangle rcClient = GetTextRectangle();
874  	const Point ptOrigin = GetVisibleOriginInMain();
875  	const Point pt = LocationFromPosition(range.caret) + ptOrigin;
876  	const Point ptAnchor = LocationFromPosition(range.anchor) + ptOrigin;
877  	const Point ptBottomCaret(pt.x, pt.y + vs.lineHeight - 1);
878  	XYScrollPosition newXY(xOffset, topLine);
879  	if (rcClient.Empty()) {
880  		return newXY;
881  	}
882  	if (FlagSet(options, XYScrollOptions::vertical) &amp;&amp;
883  		(pt.y &lt; rcClient.top || ptBottomCaret.y &gt;= rcClient.bottom || FlagSet(policies.y.policy, CaretPolicy::Strict))) {
884  		const Sci::Line lineCaret = DisplayFromPosition(range.caret.Position());
885  		const Sci::Line linesOnScreen = LinesOnScreen();
886  		const Sci::Line halfScreen = std::max(linesOnScreen - 1, static_cast&lt;Sci::Line&gt;(2)) / 2;
887  		const bool bSlop = FlagSet(policies.y.policy, CaretPolicy::Slop);
888  		const bool bStrict = FlagSet(policies.y.policy, CaretPolicy::Strict);
889  		const bool bJump = FlagSet(policies.y.policy, CaretPolicy::Jumps);
890  		const bool bEven = FlagSet(policies.y.policy, CaretPolicy::Even);
891  		if (bSlop) {	
892  			Sci::Line yMoveT = 0;
893  			Sci::Line yMoveB = 0;
894  			if (bStrict) {
895  				Sci::Line yMarginT = 0;
896  				Sci::Line yMarginB = 0;
897  				if (!FlagSet(options, XYScrollOptions::useMargin)) {
898  					yMarginT = yMarginB = 0;
899  				} else {
900  					yMarginT = std::clamp&lt;Sci::Line&gt;(policies.y.slop, 1, halfScreen);
901  					if (bEven) {
902  						yMarginB = yMarginT;
903  					} else {
904  						yMarginB = linesOnScreen - yMarginT - 1;
905  					}
906  				}
907  				yMoveT = yMarginT;
908  				if (bEven) {
909  					if (bJump) {
910  						yMoveT = std::clamp&lt;Sci::Line&gt;(policies.y.slop * 3, 1, halfScreen);
911  					}
912  					yMoveB = yMoveT;
913  				} else {
914  					yMoveB = linesOnScreen - yMoveT - 1;
915  				}
916  				if (lineCaret &lt; topLine + yMarginT) {
917  					newXY.topLine = lineCaret - yMoveT;
918  				} else if (lineCaret &gt; topLine + linesOnScreen - 1 - yMarginB) {
919  					newXY.topLine = lineCaret - linesOnScreen + 1 + yMoveB;
920  				}
921  			} else {	
922  				yMoveT = bJump ? policies.y.slop * 3 : policies.y.slop;
923  				yMoveT = std::clamp&lt;Sci::Line&gt;(yMoveT, 1, halfScreen);
924  				if (bEven) {
925  					yMoveB = yMoveT;
926  				} else {
927  					yMoveB = linesOnScreen - yMoveT - 1;
928  				}
929  				if (lineCaret &lt; topLine) {
930  					newXY.topLine = lineCaret - yMoveT;
931  				} else if (lineCaret &gt; topLine + linesOnScreen - 1) {
932  					newXY.topLine = lineCaret - linesOnScreen + 1 + yMoveB;
933  				}
934  			}
935  		} else {	
936  			if (!bStrict &amp;&amp; !bJump) {
937  				if (lineCaret &lt; topLine) {
938  					newXY.topLine = lineCaret;
939  				} else if (lineCaret &gt; topLine + linesOnScreen - 1) {
940  					if (bEven) {
941  						newXY.topLine = lineCaret - linesOnScreen + 1;
942  					} else {
943  						newXY.topLine = lineCaret;
944  					}
945  				}
946  			} else {	
947  				if (bEven) {
948  					newXY.topLine = lineCaret - halfScreen;
949  				} else {
950  					newXY.topLine = lineCaret;
951  				}
952  			}
953  		}
954  		if (!(range.caret == range.anchor)) {
955  			const Sci::Line lineAnchor = DisplayFromPosition(range.anchor.Position());
956  			if (lineAnchor &lt; lineCaret) {
957  				newXY.topLine = std::min(newXY.topLine, lineAnchor);
958  				newXY.topLine = std::max(newXY.topLine, lineCaret - LinesOnScreen());
959  			} else {
960  				newXY.topLine = std::max(newXY.topLine, lineAnchor - LinesOnScreen());
961  				newXY.topLine = std::min(newXY.topLine, lineCaret);
962  			}
963  		}
964  		newXY.topLine = std::clamp&lt;Sci::Line&gt;(newXY.topLine, 0, MaxScrollPos());
965  	}
966  	if (FlagSet(options, XYScrollOptions::horizontal) &amp;&amp; !Wrapping()) {
967  		const int halfScreen = std::max(static_cast&lt;int&gt;(rcClient.Width()) - 4, 4) / 2;
968  		const bool bSlop = FlagSet(policies.x.policy, CaretPolicy::Slop);
969  		const bool bStrict = FlagSet(policies.x.policy, CaretPolicy::Strict);
970  		const bool bJump = FlagSet(policies.x.policy, CaretPolicy::Jumps);
971  		const bool bEven = FlagSet(policies.x.policy, CaretPolicy::Even);
972  		if (bSlop) {	
973  			int xMoveL = 0;
974  			int xMoveR = 0;
975  			if (bStrict) {
976  				int xMarginL = 0;
977  				int xMarginR = 0;
978  				if (!FlagSet(options, XYScrollOptions::useMargin)) {
979  					xMarginL = xMarginR = 2;
980  				} else {
981  					xMarginR = std::clamp(policies.x.slop, 2, halfScreen);
982  					if (bEven) {
983  						xMarginL = xMarginR;
984  					} else {
985  						xMarginL = static_cast&lt;int&gt;(rcClient.Width()) - xMarginR - 4;
986  					}
987  				}
988  				if (bJump &amp;&amp; bEven) {
989  					xMoveL = xMoveR = std::clamp(policies.x.slop * 3, 1, halfScreen);
990  				} else {
991  					xMoveL = xMoveR = 0;	
992  				}
993  				if (pt.x &lt; rcClient.left + xMarginL) {
994  					if (bJump &amp;&amp; bEven) {
995  						newXY.xOffset -= xMoveL;
996  					} else {
997  						newXY.xOffset -= static_cast&lt;int&gt;((rcClient.left + xMarginL) - pt.x);
998  					}
999  				} else if (pt.x &gt;= rcClient.right - xMarginR) {
1000  					if (bJump &amp;&amp; bEven) {
1001  						newXY.xOffset += xMoveR;
1002  					} else {
1003  						newXY.xOffset += static_cast&lt;int&gt;(pt.x - (rcClient.right - xMarginR) + 1);
1004  					}
1005  				}
1006  			} else {	
1007  				xMoveR = bJump ? policies.x.slop * 3 : policies.x.slop;
1008  				xMoveR = std::clamp(xMoveR, 1, halfScreen);
1009  				if (bEven) {
1010  					xMoveL = xMoveR;
1011  				} else {
1012  					xMoveL = static_cast&lt;int&gt;(rcClient.Width()) - xMoveR - 4;
1013  				}
1014  				if (pt.x &lt; rcClient.left) {
1015  					newXY.xOffset -= xMoveL;
1016  				} else if (pt.x &gt;= rcClient.right) {
1017  					newXY.xOffset += xMoveR;
1018  				}
1019  			}
1020  		} else {	
1021  			if (bStrict ||
1022  			        (bJump &amp;&amp; (pt.x &lt; rcClient.left || pt.x &gt;= rcClient.right))) {
1023  				if (bEven) {
1024  					newXY.xOffset += static_cast&lt;int&gt;(pt.x - rcClient.left - halfScreen);
1025  				} else {
1026  					newXY.xOffset += static_cast&lt;int&gt;(pt.x - rcClient.right + 1);
1027  				}
1028  			} else {
1029  				if (pt.x &lt; rcClient.left) {
1030  					if (bEven) {
1031  						newXY.xOffset -= static_cast&lt;int&gt;(rcClient.left - pt.x);
1032  					} else {
1033  						newXY.xOffset += static_cast&lt;int&gt;(pt.x - rcClient.right) + 1;
1034  					}
1035  				} else if (pt.x &gt;= rcClient.right) {
1036  					newXY.xOffset += static_cast&lt;int&gt;(pt.x - rcClient.right) + 1;
1037  				}
1038  			}
1039  		}
1040  		if (pt.x + xOffset &lt; rcClient.left + newXY.xOffset) {
1041  			newXY.xOffset = static_cast&lt;int&gt;(pt.x + xOffset - rcClient.left) - 2;
1042  		} else if (pt.x + xOffset &gt;= rcClient.right + newXY.xOffset) {
1043  			newXY.xOffset = static_cast&lt;int&gt;(pt.x + xOffset - rcClient.right) + 2;
1044  			if (vs.IsBlockCaretStyle() || view.imeCaretBlockOverride) {
1045  				newXY.xOffset += static_cast&lt;int&gt;(vs.aveCharWidth);
1046  			}
1047  		}
1048  		if (!(range.caret == range.anchor)) {
1049  			if (ptAnchor.x &lt; pt.x) {
1050  				const int maxOffset = static_cast&lt;int&gt;(ptAnchor.x + xOffset - rcClient.left) - 1;
1051  				const int minOffset = static_cast&lt;int&gt;(pt.x + xOffset - rcClient.right) + 1;
1052  				newXY.xOffset = std::min(newXY.xOffset, maxOffset);
1053  				newXY.xOffset = std::max(newXY.xOffset, minOffset);
1054  			} else {
1055  				const int minOffset = static_cast&lt;int&gt;(ptAnchor.x + xOffset - rcClient.right) + 1;
1056  				const int maxOffset = static_cast&lt;int&gt;(pt.x + xOffset - rcClient.left) - 1;
1057  				newXY.xOffset = std::max(newXY.xOffset, minOffset);
1058  				newXY.xOffset = std::min(newXY.xOffset, maxOffset);
1059  			}
1060  		}
1061  		if (newXY.xOffset &lt; 0) {
1062  			newXY.xOffset = 0;
1063  		}
1064  	}
1065  	return newXY;
1066  }
1067  void Editor::SetXYScroll(XYScrollPosition newXY) {
1068  	if ((newXY.topLine != topLine) || (newXY.xOffset != xOffset)) {
1069  		if (newXY.topLine != topLine) {
1070  			SetTopLine(newXY.topLine);
1071  			SetVerticalScrollPos();
1072  		}
1073  		if (newXY.xOffset != xOffset) {
1074  			xOffset = newXY.xOffset;
1075  			ContainerNeedsUpdate(Update::HScroll);
1076  			if (newXY.xOffset &gt; 0) {
1077  				const PRectangle rcText = GetTextRectangle();
1078  				if (horizontalScrollBarVisible &amp;&amp;
1079  					rcText.Width() + xOffset &gt; scrollWidth) {
1080  					scrollWidth = xOffset + static_cast&lt;int&gt;(rcText.Width());
1081  					SetScrollBars();
1082  				}
1083  			}
1084  			SetHorizontalScrollPos();
1085  		}
1086  		Redraw();
1087  		UpdateSystemCaret();
1088  	}
1089  }
1090  void Editor::ScrollRange(SelectionRange range) {
1091  	SetXYScroll(XYScrollToMakeVisible(range, XYScrollOptions::all, caretPolicies));
1092  }
1093  void Editor::EnsureCaretVisible(bool useMargin, bool vert, bool horiz) {
1094  	SetXYScroll(XYScrollToMakeVisible(SelectionRange(posDrag.IsValid() ? posDrag : sel.RangeMain().caret),
1095  		(useMargin?XYScrollOptions::useMargin:XYScrollOptions::none)|
1096  		(vert?XYScrollOptions::vertical:XYScrollOptions::none)|
1097  		(horiz?XYScrollOptions::horizontal:XYScrollOptions::none),
1098  		caretPolicies));
1099  }
1100  void Editor::ShowCaretAtCurrentPosition() {
1101  	if (hasFocus) {
1102  		caret.active = true;
1103  		caret.on = true;
1104  		FineTickerCancel(TickReason::caret);
1105  		if (caret.period &gt; 0)
1106  			FineTickerStart(TickReason::caret, caret.period, caret.period/10);
1107  	} else {
1108  		caret.active = false;
1109  		caret.on = false;
1110  		FineTickerCancel(TickReason::caret);
1111  	}
1112  	InvalidateCaret();
1113  }
1114  void Editor::DropCaret() {
1115  	caret.active = false;
1116  	FineTickerCancel(TickReason::caret);
1117  	InvalidateCaret();
1118  }
1119  void Editor::CaretSetPeriod(int period) {
1120  	if (caret.period != period) {
1121  		caret.period = period;
1122  		caret.on = true;
1123  		FineTickerCancel(TickReason::caret);
1124  		if ((caret.active) &amp;&amp; (caret.period &gt; 0))
1125  			FineTickerStart(TickReason::caret, caret.period, caret.period/10);
1126  		InvalidateCaret();
1127  	}
1128  }
1129  void Editor::InvalidateCaret() {
1130  	if (posDrag.IsValid()) {
1131  		InvalidateRange(posDrag.Position(), posDrag.Position() + 1);
1132  	} else {
1133  		for (size_t r=0; r&lt;sel.Count(); r++) {
1134  			InvalidateRange(sel.Range(r).caret.Position(), sel.Range(r).caret.Position() + 1);
1135  		}
1136  	}
1137  	UpdateSystemCaret();
1138  }
1139  void Editor::NotifyCaretMove() {
1140  }
1141  void Editor::UpdateSystemCaret() {
1142  }
1143  bool Editor::Wrapping() const noexcept {
1144  	return vs.wrap.state != Wrap::None;
1145  }
1146  void Editor::NeedWrapping(Sci::Line docLineStart, Sci::Line docLineEnd) {
1147  	if (wrapPending.AddRange(docLineStart, docLineEnd)) {
1148  		view.llc.Invalidate(LineLayout::ValidLevel::positions);
1149  	}
1150  	if (Wrapping() &amp;&amp; wrapPending.NeedsWrap()) {
1151  		SetIdle(true);
1152  	}
1153  }
1154  bool Editor::WrapOneLine(Surface *surface, Sci::Line lineToWrap) {
1155  	std::shared_ptr&lt;LineLayout&gt; ll = view.RetrieveLineLayout(lineToWrap, *this);
1156  	int linesWrapped = 1;
1157  	if (ll) {
1158  		view.LayoutLine(*this, surface, vs, ll.get(), wrapWidth);
1159  		linesWrapped = ll-&gt;lines;
1160  	}
1161  	if (vs.annotationVisible != AnnotationVisible::Hidden) {
1162  		linesWrapped += pdoc-&gt;AnnotationLines(lineToWrap);
1163  	}
1164  	return pcs-&gt;SetHeight(lineToWrap, linesWrapped);
1165  }
1166  namespace {
1167  constexpr Sci::Position lengthToMultiThread = 4000;
1168  }
1169  bool Editor::WrapBlock(Surface *surface, Sci::Line lineToWrap, Sci::Line lineToWrapEnd) {
1170  	const size_t linesBeingWrapped = static_cast&lt;size_t&gt;(lineToWrapEnd - lineToWrap);
1171  	std::vector&lt;int&gt; linesAfterWrap(linesBeingWrapped);
1172  	size_t threads = std::min&lt;size_t&gt;({ linesBeingWrapped, view.maxLayoutThreads });
1173  	if (!surface-&gt;SupportsFeature(Supports::ThreadSafeMeasureWidths)) {
1174  		threads = 1;
1175  	}
1176  	const bool multiThreaded = threads &gt; 1;
1177  	ElapsedPeriod epWrapping;
1178  	const std::launch policy = multiThreaded ? std::launch::async : std::launch::deferred;
1179  	std::atomic&lt;size_t&gt; nextIndex = 0;
1180  	const SignificantLines significantLines {
1181  		pdoc-&gt;SciLineFromPosition(sel.MainCaret()),
1182  		pcs-&gt;DocFromDisplay(topLine),
1183  		LinesOnScreen() + 1,
1184  		view.llc.GetLevel(),
1185  	};
1186  	std::mutex mutexRetrieve;
1187  	std::vector&lt;std::future&lt;void&gt;&gt; futures;
1188  	for (size_t th = 0; th &lt; threads; th++) {
1189  		std::future&lt;void&gt; fut = std::async(policy,
1190  			[=, &amp;surface, &amp;nextIndex, &amp;linesAfterWrap, &amp;mutexRetrieve]() {
1191  			std::shared_ptr&lt;LineLayout&gt; llTemporary = std::make_shared&lt;LineLayout&gt;(-1, 200);
1192  			while (true) {
1193  				const size_t i = nextIndex.fetch_add(1, std::memory_order_acq_rel);
1194  				if (i &gt;= linesBeingWrapped) {
1195  					break;
1196  				}
1197  				const Sci::Line lineNumber = lineToWrap + i;
1198  				const Range rangeLine = pdoc-&gt;LineRange(lineNumber);
1199  				const Sci::Position lengthLine = rangeLine.Length();
1200  				if (lengthLine &lt; lengthToMultiThread) {
1201  					std::shared_ptr&lt;LineLayout&gt; ll;
1202  					if (significantLines.LineMayCache(lineNumber)) {
1203  						std::lock_guard&lt;std::mutex&gt; guard(mutexRetrieve);
1204  						ll = view.RetrieveLineLayout(lineNumber, *this);
1205  					} else {
1206  						ll = llTemporary;
1207  						ll-&gt;ReSet(lineNumber, lengthLine);
1208  					}
1209  					view.LayoutLine(*this, surface, vs, ll.get(), wrapWidth, multiThreaded);
1210  					linesAfterWrap[i] = ll-&gt;lines;
1211  				}
1212  			}
1213  		});
1214  		futures.push_back(std::move(fut));
1215  	}
1216  	for (const std::future&lt;void&gt; &amp;f : futures) {
1217  		f.wait();
1218  	}
1219  	const double durationShortLines = epWrapping.Duration(true);
1220  	const double durationShortLinesThreads = durationShortLines * threads;
1221  	std::shared_ptr&lt;LineLayout&gt; llLarge = std::make_shared&lt;LineLayout&gt;(-1, 200);
1222  	for (size_t indexLarge = 0; indexLarge &lt; linesBeingWrapped; indexLarge++) {
1223  		const Sci::Line lineNumber = lineToWrap + indexLarge;
1224  		const Range rangeLine = pdoc-&gt;LineRange(lineNumber);
1225  		const Sci::Position lengthLine = rangeLine.Length();
1226  		if (lengthLine &gt;= lengthToMultiThread) {
1227  			std::shared_ptr&lt;LineLayout&gt; ll;
1228  			if (significantLines.LineMayCache(lineNumber)) {
1229  				ll = view.RetrieveLineLayout(lineNumber, *this);
1230  			} else {
1231  				ll = llLarge;
1232  				ll-&gt;ReSet(lineNumber, lengthLine);
1233  			}
1234  			view.LayoutLine(*this, surface, vs, ll.get(), wrapWidth);
1235  			linesAfterWrap[indexLarge] = ll-&gt;lines;
1236  		}
1237  	}
1238  	const double durationLongLines = epWrapping.Duration();
1239  	const size_t bytesBeingWrapped = pdoc-&gt;LineStart(lineToWrap + linesBeingWrapped) - pdoc-&gt;LineStart(lineToWrap);
1240  	size_t wrapsDone = 0;
1241  	for (size_t i = 0; i &lt; linesBeingWrapped; i++) {
1242  		const Sci::Line lineNumber = lineToWrap + i;
1243  		int linesWrapped = linesAfterWrap[i];
1244  		if (vs.annotationVisible != AnnotationVisible::Hidden) {
1245  			linesWrapped += pdoc-&gt;AnnotationLines(lineNumber);
1246  		}
1247  		if (pcs-&gt;SetHeight(lineNumber, linesWrapped)) {
1248  			wrapsDone++;
1249  		}
1250  		wrapPending.Wrapped(lineNumber);
1251  	}
1252  	durationWrapOneByte.AddSample(bytesBeingWrapped, durationShortLinesThreads + durationLongLines);
1253  	return wrapsDone &gt; 0;
1254  }
1255  bool Editor::WrapLines(WrapScope ws) {
1256  	Sci::Line goodTopLine = topLine;
1257  	bool wrapOccurred = false;
1258  	if (!Wrapping()) {
1259  		if (wrapWidth != LineLayout::wrapWidthInfinite) {
1260  			wrapWidth = LineLayout::wrapWidthInfinite;
1261  			for (Sci::Line lineDoc = 0; lineDoc &lt; pdoc-&gt;LinesTotal(); lineDoc++) {
1262  				int linesWrapped = 1;
1263  				if (vs.annotationVisible != AnnotationVisible::Hidden) {
1264  					linesWrapped += pdoc-&gt;AnnotationLines(lineDoc);
1265  				}
1266  				pcs-&gt;SetHeight(lineDoc, linesWrapped);
1267  			}
1268  			wrapOccurred = true;
1269  		}
1270  		wrapPending.Reset();
1271  	} else if (wrapPending.NeedsWrap()) {
1272  		wrapPending.start = std::min(wrapPending.start, pdoc-&gt;LinesTotal());
1273  		if (!SetIdle(true)) {
1274  			ws = WrapScope::wsAll;
1275  		}
1276  		Sci::Line lineToWrap = wrapPending.start;
1277  		Sci::Line lineToWrapEnd = std::min(wrapPending.end, pdoc-&gt;LinesTotal());
1278  		const Sci::Line lineDocTop = pcs-&gt;DocFromDisplay(topLine);
1279  		const Sci::Line subLineTop = topLine - pcs-&gt;DisplayFromDoc(lineDocTop);
1280  		if (ws == WrapScope::wsVisible) {
1281  			lineToWrap = std::clamp(lineDocTop-5, wrapPending.start, pdoc-&gt;LinesTotal());
1282  			lineToWrapEnd = lineDocTop;
1283  			Sci::Line lines = LinesOnScreen() + 1;
1284  			constexpr double secondsAllowed = 0.1;
1285  			const size_t actionsInAllowedTime = std::clamp&lt;Sci::Line&gt;(
1286  				durationWrapOneByte.ActionsInAllowedTime(secondsAllowed),
1287  				0x2000, 0x200000);
1288  			const Sci::Line lineLast = pdoc-&gt;LineFromPositionAfter(lineToWrap, actionsInAllowedTime);
1289  			const Sci::Line maxLine = std::min(lineLast, pcs-&gt;LinesInDoc());
1290  			while ((lineToWrapEnd &lt; maxLine) &amp;&amp; (lines&gt;0)) {
1291  				if (pcs-&gt;GetVisible(lineToWrapEnd))
1292  					lines--;
1293  				lineToWrapEnd++;
1294  			}
1295  			if ((lineToWrap &gt; wrapPending.end) || (lineToWrapEnd &lt; wrapPending.start)) {
1296  				return false;
1297  			}
1298  		} else if (ws == WrapScope::wsIdle) {
1299  			constexpr double secondsAllowed = 0.01;
1300  			const size_t actionsInAllowedTime = std::clamp&lt;Sci::Line&gt;(
1301  				durationWrapOneByte.ActionsInAllowedTime(secondsAllowed),
1302  				0x200, 0x20000);
1303  			lineToWrapEnd = pdoc-&gt;LineFromPositionAfter(lineToWrap, actionsInAllowedTime);
1304  		}
1305  		const Sci::Line lineEndNeedWrap = std::min(wrapPending.end, pdoc-&gt;LinesTotal());
1306  		lineToWrapEnd = std::min(lineToWrapEnd, lineEndNeedWrap);
1307  		pdoc-&gt;EnsureStyledTo(pdoc-&gt;LineStart(lineToWrapEnd));
1308  		if (lineToWrap &lt; lineToWrapEnd) {
1309  			PRectangle rcTextArea = GetClientRectangle();
1310  			rcTextArea.left = static_cast&lt;XYPOSITION&gt;(vs.textStart);
1311  			rcTextArea.right -= vs.rightMarginWidth;
1312  			wrapWidth = static_cast&lt;int&gt;(rcTextArea.Width());
1313  			RefreshStyleData();
1314  			AutoSurface surface(this);
1315  			if (surface) {
1316  				wrapOccurred = WrapBlock(surface, lineToWrap, lineToWrapEnd);
1317  				goodTopLine = pcs-&gt;DisplayFromDoc(lineDocTop) + std::min(
1318  					subLineTop, static_cast&lt;Sci::Line&gt;(pcs-&gt;GetHeight(lineDocTop)-1));
1319  			}
1320  		}
1321  		if (wrapPending.start &gt;= lineEndNeedWrap) {
1322  			wrapPending.Reset();
1323  		}
1324  	}
1325  	if (wrapOccurred) {
1326  		SetScrollBars();
1327  		SetTopLine(std::clamp&lt;Sci::Line&gt;(goodTopLine, 0, MaxScrollPos()));
1328  		SetVerticalScrollPos();
1329  	}
1330  	return wrapOccurred;
1331  }
1332  void Editor::LinesJoin() {
1333  	if (!RangeContainsProtected(targetRange.start.Position(), targetRange.end.Position())) {
1334  		UndoGroup ug(pdoc);
1335  		const Sci::Line line = pdoc-&gt;SciLineFromPosition(targetRange.start.Position());
1336  		for (Sci::Position pos = pdoc-&gt;LineEnd(line); pos &lt; targetRange.end.Position(); pos = pdoc-&gt;LineEnd(line)) {
1337  			const char chPrev = pdoc-&gt;CharAt(pos - 1);
1338  			const Sci::Position widthChar = pdoc-&gt;LenChar(pos);
1339  			targetRange.end.Add(-widthChar);
1340  			pdoc-&gt;DeleteChars(pos, widthChar);
1341  			if (chPrev != &#x27; &#x27;) {
1342  				const Sci::Position lengthInserted = pdoc-&gt;InsertString(pos, &quot; &quot;, 1);
1343  				targetRange.end.Add(lengthInserted);
1344  			}
1345  		}
1346  	}
1347  }
1348  void Editor::LinesSplit(int pixelWidth) {
1349  	if (!RangeContainsProtected(targetRange.start.Position(), targetRange.end.Position())) {
1350  		if (pixelWidth == 0) {
1351  			const PRectangle rcText = GetTextRectangle();
1352  			pixelWidth = static_cast&lt;int&gt;(rcText.Width());
1353  		}
1354  		const Sci::Line lineStart = pdoc-&gt;SciLineFromPosition(targetRange.start.Position());
1355  		Sci::Line lineEnd = pdoc-&gt;SciLineFromPosition(targetRange.end.Position());
1356  		const std::string_view eol = pdoc-&gt;EOLString();
1357  		UndoGroup ug(pdoc);
1358  		for (Sci::Line line = lineStart; line &lt;= lineEnd; line++) {
1359  			AutoSurface surface(this);
1360  			std::shared_ptr&lt;LineLayout&gt; ll = view.RetrieveLineLayout(line, *this);
1361  			if (surface &amp;&amp; ll) {
1362  				const Sci::Position posLineStart = pdoc-&gt;LineStart(line);
1363  				view.LayoutLine(*this, surface, vs, ll.get(), pixelWidth);
1364  				Sci::Position lengthInsertedTotal = 0;
1365  				for (int subLine = 1; subLine &lt; ll-&gt;lines; subLine++) {
1366  					const Sci::Position lengthInserted = pdoc-&gt;InsertString(
1367  						posLineStart + lengthInsertedTotal + ll-&gt;LineStart(subLine), eol);
1368  					targetRange.end.Add(lengthInserted);
1369  					lengthInsertedTotal += lengthInserted;
1370  				}
1371  			}
1372  			lineEnd = pdoc-&gt;SciLineFromPosition(targetRange.end.Position());
1373  		}
1374  	}
1375  }
1376  void Editor::PaintSelMargin(Surface *surfaceWindow, const PRectangle &amp;rc) {
1377  	if (vs.fixedColumnWidth == 0)
1378  		return;
1379  	RefreshStyleData();
1380  	RefreshPixMaps(surfaceWindow);
1381  	if (!surfaceWindow-&gt;Initialised()) {
1382  		return;
1383  	}
1384  	PRectangle rcMargin = GetClientRectangle();
1385  	const Point ptOrigin = GetVisibleOriginInMain();
1386  	rcMargin.Move(0, -ptOrigin.y);
1387  	rcMargin.left = 0;
1388  	rcMargin.right = static_cast&lt;XYPOSITION&gt;(vs.fixedColumnWidth);
1389  	if (!rc.Intersects(rcMargin))
1390  		return;
1391  	Surface *surface;
1392  	if (view.bufferedDraw) {
1393  		surface = marginView.pixmapSelMargin.get();
1394  	} else {
1395  		surface = surfaceWindow;
1396  	}
1397  	surface-&gt;SetMode(CurrentSurfaceMode());
1398  	if (rcMargin.bottom &gt; rc.bottom)
1399  		rcMargin.bottom = rc.bottom;
1400  	if (rcMargin.top &lt; rc.top)
1401  		rcMargin.top = rc.top;
1402  	marginView.PaintMargin(surface, topLine, rc, rcMargin, *this, vs);
1403  	if (view.bufferedDraw) {
1404  		marginView.pixmapSelMargin-&gt;FlushDrawing();
1405  		surfaceWindow-&gt;Copy(rcMargin, Point(rcMargin.left, rcMargin.top), *marginView.pixmapSelMargin);
1406  	}
1407  }
1408  void Editor::RefreshPixMaps(Surface *surfaceWindow) {
1409  	view.RefreshPixMaps(surfaceWindow, vs);
1410  	marginView.RefreshPixMaps(surfaceWindow, vs);
1411  	if (view.bufferedDraw) {
1412  		const PRectangle rcClient = GetClientRectangle();
1413  		if (!view.pixmapLine) {
1414  			view.pixmapLine = surfaceWindow-&gt;AllocatePixMap(static_cast&lt;int&gt;(rcClient.Width()), vs.lineHeight);
1415  		}
1416  		if (!marginView.pixmapSelMargin) {
1417  			marginView.pixmapSelMargin = surfaceWindow-&gt;AllocatePixMap(vs.fixedColumnWidth,
1418  				static_cast&lt;int&gt;(rcClient.Height()));
1419  		}
1420  	}
1421  }
1422  void Editor::Paint(Surface *surfaceWindow, PRectangle rcArea) {
1423  	redrawPendingText = false;
1424  	redrawPendingMargin = false;
1425  	RefreshStyleData();
1426  	if (paintState == PaintState::abandoned)
1427  		return;	
1428  	RefreshPixMaps(surfaceWindow);
1429  	paintAbandonedByStyling = false;
1430  	StyleAreaBounded(rcArea, false);
1431  	const PRectangle rcClient = GetClientRectangle();
1432  	if (NotifyUpdateUI()) {
1433  		RefreshStyleData();
1434  		RefreshPixMaps(surfaceWindow);
1435  	}
1436  	if (WrapLines(WrapScope::wsVisible)) {
1437  		if (AbandonPaint()) {
1438  			return;
1439  		}
1440  		RefreshPixMaps(surfaceWindow);	
1441  	}
1442  	if (!marginView.pixmapSelPattern-&gt;Initialised()) {
1443  		return;
1444  	}
1445  	if (!view.bufferedDraw)
1446  		surfaceWindow-&gt;SetClip(rcArea);
1447  	if (paintState != PaintState::abandoned) {
1448  		if (vs.marginInside) {
1449  			PaintSelMargin(surfaceWindow, rcArea);
1450  			PRectangle rcRightMargin = rcClient;
1451  			rcRightMargin.left = rcRightMargin.right - vs.rightMarginWidth;
1452  			if (rcArea.Intersects(rcRightMargin)) {
1453  				surfaceWindow-&gt;FillRectangle(rcRightMargin, vs.styles[StyleDefault].back);
1454  			}
1455  		} else { 
1456  			PRectangle rcLeftMargin = rcArea;
1457  			rcLeftMargin.left = 0;
1458  			rcLeftMargin.right = rcLeftMargin.left + vs.leftMarginWidth;
1459  			if (rcArea.Intersects(rcLeftMargin)) {
1460  				surfaceWindow-&gt;FillRectangle(rcLeftMargin, vs.styles[StyleDefault].back);
1461  			}
1462  		}
1463  	}
1464  	if (paintState == PaintState::abandoned) {
1465  		if (Wrapping()) {
1466  			if (paintAbandonedByStyling) {
1467  				NeedWrapping(pcs-&gt;DocFromDisplay(topLine));
1468  			}
1469  		}
1470  		if (!view.bufferedDraw)
1471  			surfaceWindow-&gt;PopClip();
1472  		return;
1473  	}
1474  	view.PaintText(surfaceWindow, *this, vs, rcArea, rcClient);
1475  	if (horizontalScrollBarVisible &amp;&amp; trackLineWidth &amp;&amp; (view.lineWidthMaxSeen &gt; scrollWidth)) {
1476  		scrollWidth = view.lineWidthMaxSeen;
1477  		if (!FineTickerRunning(TickReason::widen)) {
1478  			FineTickerStart(TickReason::widen, 50, 5);
1479  		}
1480  	}
1481  	if (!view.bufferedDraw)
1482  		surfaceWindow-&gt;PopClip();
1483  	NotifyPainted();
1484  }
1485  Sci::Position Editor::FormatRange(Scintilla::Message iMessage, Scintilla::uptr_t wParam, Scintilla::sptr_t lParam) {
1486  	if (!lParam)
1487  		return 0;
1488  	const bool draw = wParam != 0;
1489  	void *ptr = PtrFromSPtr(lParam);
1490  	if (iMessage == Message::FormatRange) {
1491  		RangeToFormat *pfr = static_cast&lt;RangeToFormat *&gt;(ptr);
1492  		const CharacterRangeFull chrg{ pfr-&gt;chrg.cpMin,pfr-&gt;chrg.cpMax };
1493  		AutoSurface surface(pfr-&gt;hdc, this, Technology::Default);
1494  		AutoSurface surfaceMeasure(pfr-&gt;hdcTarget, this, Technology::Default);
1495  		if (!surface || !surfaceMeasure) {
1496  			return 0;
1497  		}
1498  		return view.FormatRange(draw, chrg, pfr-&gt;rc, surface, surfaceMeasure, *this, vs);
1499  	} else {
1500  		RangeToFormatFull *pfr = static_cast&lt;RangeToFormatFull *&gt;(ptr);
1501  		AutoSurface surface(pfr-&gt;hdc, this, Technology::Default);
1502  		AutoSurface surfaceMeasure(pfr-&gt;hdcTarget, this, Technology::Default);
1503  		if (!surface || !surfaceMeasure) {
1504  			return 0;
1505  		}
1506  		return view.FormatRange(draw, pfr-&gt;chrg, pfr-&gt;rc, surface, surfaceMeasure, *this, vs);
1507  	}
1508  }
1509  long Editor::TextWidth(uptr_t style, const char *text) {
1510  	RefreshStyleData();
1511  	AutoSurface surface(this);
1512  	if (surface) {
1513  		return std::lround(surface-&gt;WidthText(vs.styles[style].font.get(), text));
1514  	} else {
1515  		return 1;
1516  	}
1517  }
1518  void Editor::ReconfigureScrollBars() {}
1519  void Editor::ChangeScrollBars() {
1520  	RefreshStyleData();
1521  	const Sci::Line nMax = MaxScrollPos();
1522  	const Sci::Line nPage = LinesOnScreen();
1523  	const bool modified = ModifyScrollBars(nMax + nPage - 1, nPage);
1524  	if (modified) {
1525  		DwellEnd(true);
1526  	}
1527  	if (topLine &gt; MaxScrollPos()) {
1528  		SetTopLine(std::clamp&lt;Sci::Line&gt;(topLine, 0, MaxScrollPos()));
1529  		SetVerticalScrollPos();
1530  		Redraw();
1531  	}
1532  	if (modified) {
1533  		if (!AbandonPaint())
1534  			Redraw();
1535  	}
1536  }
1537  void Editor::SetScrollBars() {
1538  	ChangeScrollBars();
1539  }
1540  void Editor::ChangeSize() {
1541  	DropGraphics();
1542  	SetScrollBars();
1543  	if (Wrapping()) {
1544  		PRectangle rcTextArea = GetClientRectangle();
1545  		rcTextArea.left = static_cast&lt;XYPOSITION&gt;(vs.textStart);
1546  		rcTextArea.right -= vs.rightMarginWidth;
1547  		if (wrapWidth != rcTextArea.Width()) {
1548  			NeedWrapping();
1549  			Redraw();
1550  		}
1551  	}
1552  }
1553  Sci::Position Editor::RealizeVirtualSpace(Sci::Position position, Sci::Position virtualSpace) {
1554  	if (virtualSpace &gt; 0) {
1555  		const Sci::Line line = pdoc-&gt;SciLineFromPosition(position);
1556  		const Sci::Position indent = pdoc-&gt;GetLineIndentPosition(line);
1557  		if (indent == position) {
1558  			return pdoc-&gt;SetLineIndentation(line, pdoc-&gt;GetLineIndentation(line) + virtualSpace);
1559  		} else {
1560  			const std::string spaceText(virtualSpace, &#x27; &#x27;);
1561  			const Sci::Position lengthInserted = pdoc-&gt;InsertString(position, spaceText);
1562  			position += lengthInserted;
1563  		}
1564  	}
1565  	return position;
1566  }
1567  SelectionPosition Editor::RealizeVirtualSpace(const SelectionPosition &amp;position) {
1568  	return SelectionPosition(RealizeVirtualSpace(position.Position(), position.VirtualSpace()));
1569  }
1570  void Editor::AddChar(char ch) {
1571  	const char s[1] {ch};
1572  	InsertCharacter(std::string_view(s, 1), CharacterSource::DirectInput);
1573  }
1574  void Editor::FilterSelections() {
1575  	if (!additionalSelectionTyping &amp;&amp; (sel.Count() &gt; 1)) {
1576  		InvalidateWholeSelection();
1577  		sel.DropAdditionalRanges();
1578  	}
1579  }
1580  void Editor::InsertCharacter(std::string_view sv, CharacterSource charSource) {
1581  	if (sv.empty()) {
1582  		return;
1583  	}
1584  	FilterSelections();
1585  	bool wrapOccurred = false;
1586  	{
1587  		UndoGroup ug(pdoc, (sel.Count() &gt; 1) || !sel.Empty() || inOverstrike);
1588  		std::vector&lt;SelectionRange *&gt; selPtrs;
1589  		for (size_t r = 0; r &lt; sel.Count(); r++) {
1590  			selPtrs.push_back(&amp;sel.Range(r));
1591  		}
1592  		std::sort(selPtrs.begin(), selPtrs.end(),
1593  			[](const SelectionRange *a, const SelectionRange *b) noexcept {return *a &lt; *b;});
1594  		for (std::vector&lt;SelectionRange *&gt;::reverse_iterator rit = selPtrs.rbegin();
1595  			rit != selPtrs.rend(); ++rit) {
1596  			SelectionRange *currentSel = *rit;
1597  			if (!RangeContainsProtected(currentSel-&gt;Start().Position(),
1598  				currentSel-&gt;End().Position())) {
1599  				Sci::Position positionInsert = currentSel-&gt;Start().Position();
1600  				if (!currentSel-&gt;Empty()) {
1601  					if (currentSel-&gt;Length()) {
1602  						pdoc-&gt;DeleteChars(positionInsert, currentSel-&gt;Length());
1603  						currentSel-&gt;ClearVirtualSpace();
1604  					} else {
1605  						currentSel-&gt;MinimizeVirtualSpace();
1606  					}
1607  				} else if (inOverstrike) {
1608  					if (positionInsert &lt; pdoc-&gt;Length()) {
1609  						if (!pdoc-&gt;IsPositionInLineEnd(positionInsert)) {
1610  							pdoc-&gt;DelChar(positionInsert);
1611  							currentSel-&gt;ClearVirtualSpace();
1612  						}
1613  					}
1614  				}
1615  				positionInsert = RealizeVirtualSpace(positionInsert, currentSel-&gt;caret.VirtualSpace());
1616  				const Sci::Position lengthInserted = pdoc-&gt;InsertString(positionInsert, sv);
1617  				if (lengthInserted &gt; 0) {
1618  					currentSel-&gt;caret.SetPosition(positionInsert + lengthInserted);
1619  					currentSel-&gt;anchor.SetPosition(positionInsert + lengthInserted);
1620  				}
1621  				currentSel-&gt;ClearVirtualSpace();
1622  				if (Wrapping()) {
1623  					AutoSurface surface(this);
1624  					if (surface) {
1625  						if (WrapOneLine(surface, pdoc-&gt;SciLineFromPosition(positionInsert))) {
1626  							wrapOccurred = true;
1627  						}
1628  					}
1629  				}
1630  			}
1631  		}
1632  	}
1633  	if (wrapOccurred) {
1634  		SetScrollBars();
1635  		SetVerticalScrollPos();
1636  		Redraw();
1637  	}
1638  	ThinRectangularRange();
1639  	EnsureCaretVisible();
1640  	ShowCaretAtCurrentPosition();
1641  	if ((caretSticky == CaretSticky::Off) ||
1642  		((caretSticky == CaretSticky::WhiteSpace) &amp;&amp; !IsAllSpacesOrTabs(sv))) {
1643  		SetLastXChosen();
1644  	}
1645  	int ch = static_cast&lt;unsigned char&gt;(sv[0]);
1646  	if (pdoc-&gt;dbcsCodePage != CpUtf8) {
1647  		if (sv.length() &gt; 1) {
1648  			ch = (ch &lt;&lt; 8) | static_cast&lt;unsigned char&gt;(sv[1]);
1649  		}
1650  	} else {
1651  		if ((ch &lt; 0xC0) || (1 == sv.length())) {
1652  		} else {
1653  			unsigned int utf32[1] = { 0 };
1654  			UTF32FromUTF8(sv, utf32, std::size(utf32));
1655  			ch = utf32[0];
1656  		}
1657  	}
1658  	NotifyChar(ch, charSource);
1659  	if (recordingMacro &amp;&amp; charSource != CharacterSource::TentativeInput) {
1660  		std::string copy(sv); 
1661  		NotifyMacroRecord(Message::ReplaceSel, 0, reinterpret_cast&lt;sptr_t&gt;(copy.data()));
1662  	}
1663  }
1664  void Editor::ClearBeforeTentativeStart() {
1665  	FilterSelections();
1666  	UndoGroup ug(pdoc, (sel.Count() &gt; 1) || !sel.Empty() || inOverstrike);
1667  	for (size_t r = 0; r&lt;sel.Count(); r++) {
1668  		if (!RangeContainsProtected(sel.Range(r).Start().Position(),
1669  			sel.Range(r).End().Position())) {
1670  			const Sci::Position positionInsert = sel.Range(r).Start().Position();
1671  			if (!sel.Range(r).Empty()) {
1672  				if (sel.Range(r).Length()) {
1673  					pdoc-&gt;DeleteChars(positionInsert, sel.Range(r).Length());
1674  					sel.Range(r).ClearVirtualSpace();
1675  				} else {
1676  					sel.Range(r).MinimizeVirtualSpace();
1677  				}
1678  			}
1679  			RealizeVirtualSpace(positionInsert, sel.Range(r).caret.VirtualSpace());
1680  			sel.Range(r).ClearVirtualSpace();
1681  		}
1682  	}
1683  }
1684  void Editor::InsertPaste(const char *text, Sci::Position len) {
1685  	if (multiPasteMode == MultiPaste::Once) {
1686  		SelectionPosition selStart = sel.Start();
1687  		selStart = RealizeVirtualSpace(selStart);
1688  		const Sci::Position lengthInserted = pdoc-&gt;InsertString(selStart.Position(), text, len);
1689  		if (lengthInserted &gt; 0) {
1690  			SetEmptySelection(selStart.Position() + lengthInserted);
1691  		}
1692  	} else {
1693  		for (size_t r=0; r&lt;sel.Count(); r++) {
1694  			if (!RangeContainsProtected(sel.Range(r).Start().Position(),
1695  				sel.Range(r).End().Position())) {
1696  				Sci::Position positionInsert = sel.Range(r).Start().Position();
1697  				if (!sel.Range(r).Empty()) {
1698  					if (sel.Range(r).Length()) {
1699  						pdoc-&gt;DeleteChars(positionInsert, sel.Range(r).Length());
1700  						sel.Range(r).ClearVirtualSpace();
1701  					} else {
1702  						sel.Range(r).MinimizeVirtualSpace();
1703  					}
1704  				}
1705  				positionInsert = RealizeVirtualSpace(positionInsert, sel.Range(r).caret.VirtualSpace());
1706  				const Sci::Position lengthInserted = pdoc-&gt;InsertString(positionInsert, text, len);
1707  				if (lengthInserted &gt; 0) {
1708  					sel.Range(r).caret.SetPosition(positionInsert + lengthInserted);
1709  					sel.Range(r).anchor.SetPosition(positionInsert + lengthInserted);
1710  				}
1711  				sel.Range(r).ClearVirtualSpace();
1712  			}
1713  		}
1714  	}
1715  }
1716  void Editor::InsertPasteShape(const char *text, Sci::Position len, PasteShape shape) {
1717  	std::string convertedText;
1718  	if (convertPastes) {
1719  		convertedText = Document::TransformLineEnds(text, len, pdoc-&gt;eolMode);
1720  		len = convertedText.length();
1721  		text = convertedText.c_str();
1722  	}
1723  	if (shape == PasteShape::rectangular) {
1724  		PasteRectangular(sel.Start(), text, len);
1725  	} else {
1726  		if (shape == PasteShape::line) {
1727  			const Sci::Position insertPos =
1728  				pdoc-&gt;LineStart(pdoc-&gt;LineFromPosition(sel.MainCaret()));
1729  			Sci::Position lengthInserted = pdoc-&gt;InsertString(insertPos, text, len);
1730  			if ((len &gt; 0) &amp;&amp; (text[len - 1] != &#x27;\n&#x27; &amp;&amp; text[len - 1] != &#x27;\r&#x27;)) {
1731  				const std::string_view endline = pdoc-&gt;EOLString();
1732  				lengthInserted += pdoc-&gt;InsertString(insertPos + lengthInserted, endline);
1733  			}
1734  			if (sel.MainCaret() == insertPos) {
1735  				SetEmptySelection(sel.MainCaret() + lengthInserted);
1736  			}
1737  		} else {
1738  			InsertPaste(text, len);
1739  		}
1740  	}
1741  }
1742  void Editor::ClearSelection(bool retainMultipleSelections) {
1743  	if (!sel.IsRectangular() &amp;&amp; !retainMultipleSelections)
1744  		FilterSelections();
1745  	UndoGroup ug(pdoc);
1746  	for (size_t r=0; r&lt;sel.Count(); r++) {
1747  		if (!sel.Range(r).Empty()) {
1748  			if (!RangeContainsProtected(sel.Range(r).Start().Position(),
1749  				sel.Range(r).End().Position())) {
1750  				pdoc-&gt;DeleteChars(sel.Range(r).Start().Position(),
1751  					sel.Range(r).Length());
1752  				sel.Range(r) = SelectionRange(sel.Range(r).Start());
1753  			}
1754  		}
1755  	}
1756  	ThinRectangularRange();
1757  	sel.RemoveDuplicates();
1758  	ClaimSelection();
1759  	SetHoverIndicatorPosition(sel.MainCaret());
1760  }
1761  void Editor::ClearAll() {
1762  	{
1763  		UndoGroup ug(pdoc);
1764  		if (0 != pdoc-&gt;Length()) {
1765  			pdoc-&gt;DeleteChars(0, pdoc-&gt;Length());
1766  		}
1767  		if (!pdoc-&gt;IsReadOnly()) {
1768  			pcs-&gt;Clear();
1769  			pdoc-&gt;AnnotationClearAll();
1770  			pdoc-&gt;EOLAnnotationClearAll();
1771  			pdoc-&gt;MarginClearAll();
1772  		}
1773  	}
1774  	view.ClearAllTabstops();
1775  	sel.Clear();
1776  	SetTopLine(0);
1777  	SetVerticalScrollPos();
1778  	InvalidateStyleRedraw();
1779  }
1780  void Editor::ClearDocumentStyle() {
1781  	pdoc-&gt;decorations-&gt;DeleteLexerDecorations();
1782  	pdoc-&gt;StartStyling(0);
1783  	pdoc-&gt;SetStyleFor(pdoc-&gt;Length(), 0);
1784  	pcs-&gt;ShowAll();
1785  	SetAnnotationHeights(0, pdoc-&gt;LinesTotal());
1786  	pdoc-&gt;ClearLevels();
1787  }
1788  void Editor::CopyAllowLine() {
1789  	SelectionText selectedText;
1790  	CopySelectionRange(&amp;selectedText, true);
1791  	CopyToClipboard(selectedText);
1792  }
1793  void Editor::Cut() {
1794  	pdoc-&gt;CheckReadOnly();
1795  	if (!pdoc-&gt;IsReadOnly() &amp;&amp; !SelectionContainsProtected()) {
1796  		Copy();
1797  		ClearSelection();
1798  	}
1799  }
1800  void Editor::PasteRectangular(SelectionPosition pos, const char *ptr, Sci::Position len) {
1801  	if (pdoc-&gt;IsReadOnly() || SelectionContainsProtected()) {
1802  		return;
1803  	}
1804  	sel.Clear();
1805  	sel.RangeMain() = SelectionRange(pos);
1806  	Sci::Line line = pdoc-&gt;SciLineFromPosition(sel.MainCaret());
1807  	UndoGroup ug(pdoc);
1808  	sel.RangeMain().caret = RealizeVirtualSpace(sel.RangeMain().caret);
1809  	const int xInsert = XFromPosition(sel.RangeMain().caret);
1810  	bool prevCr = false;
1811  	while ((len &gt; 0) &amp;&amp; IsEOLCharacter(ptr[len-1]))
1812  		len--;
1813  	for (Sci::Position i = 0; i &lt; len; i++) {
1814  		if (IsEOLCharacter(ptr[i])) {
1815  			if ((ptr[i] == &#x27;\r&#x27;) || (!prevCr))
1816  				line++;
1817  			if (line &gt;= pdoc-&gt;LinesTotal()) {
1818  				const std::string_view eol = pdoc-&gt;EOLString();
1819  				pdoc-&gt;InsertString(pdoc-&gt;LengthNoExcept(), eol);
1820  			}
1821  			sel.RangeMain().caret.SetPosition(PositionFromLineX(line, xInsert));
1822  			if ((XFromPosition(sel.RangeMain().caret) &lt; xInsert) &amp;&amp; (i + 1 &lt; len)) {
1823  				while (XFromPosition(sel.RangeMain().caret) &lt; xInsert) {
1824  					assert(pdoc);
1825  					const Sci::Position lengthInserted = pdoc-&gt;InsertString(sel.MainCaret(), &quot; &quot;, 1);
1826  					sel.RangeMain().caret.Add(lengthInserted);
1827  				}
1828  			}
1829  			prevCr = ptr[i] == &#x27;\r&#x27;;
1830  		} else {
1831  			const Sci::Position lengthInserted = pdoc-&gt;InsertString(sel.MainCaret(), ptr + i, 1);
1832  			sel.RangeMain().caret.Add(lengthInserted);
1833  			prevCr = false;
1834  		}
1835  	}
1836  	SetEmptySelection(pos);
1837  }
1838  bool Editor::CanPaste() {
1839  	return !pdoc-&gt;IsReadOnly() &amp;&amp; !SelectionContainsProtected();
1840  }
1841  void Editor::Clear() {
1842  	if (sel.Empty()) {
1843  		bool singleVirtual = false;
1844  		if ((sel.Count() == 1) &amp;&amp;
1845  			!RangeContainsProtected(sel.MainCaret(), sel.MainCaret() + 1) &amp;&amp;
1846  			sel.RangeMain().Start().VirtualSpace()) {
1847  			singleVirtual = true;
1848  		}
1849  		UndoGroup ug(pdoc, (sel.Count() &gt; 1) || singleVirtual);
1850  		for (size_t r=0; r&lt;sel.Count(); r++) {
1851  			if (!RangeContainsProtected(sel.Range(r).caret.Position(), sel.Range(r).caret.Position() + 1)) {
1852  				if (sel.Range(r).Start().VirtualSpace()) {
1853  					if (sel.Range(r).anchor &lt; sel.Range(r).caret)
1854  						sel.Range(r) = SelectionRange(RealizeVirtualSpace(sel.Range(r).anchor.Position(), sel.Range(r).anchor.VirtualSpace()));
1855  					else
1856  						sel.Range(r) = SelectionRange(RealizeVirtualSpace(sel.Range(r).caret.Position(), sel.Range(r).caret.VirtualSpace()));
1857  				}
1858  				if ((sel.Count() == 1) || !pdoc-&gt;IsPositionInLineEnd(sel.Range(r).caret.Position())) {
1859  					pdoc-&gt;DelChar(sel.Range(r).caret.Position());
1860  					sel.Range(r).ClearVirtualSpace();
1861  				}  
1862  			} else {
1863  				sel.Range(r).ClearVirtualSpace();
1864  			}
1865  		}
1866  	} else {
1867  		ClearSelection();
1868  	}
1869  	sel.RemoveDuplicates();
1870  	ShowCaretAtCurrentPosition();		
1871  }
1872  void Editor::SelectAll() {
1873  	sel.Clear();
1874  	SetSelection(0, pdoc-&gt;Length());
1875  	Redraw();
1876  }
1877  void Editor::Undo() {
1878  	if (pdoc-&gt;CanUndo()) {
1879  		InvalidateCaret();
1880  		const Sci::Position newPos = pdoc-&gt;Undo();
1881  		if (newPos &gt;= 0)
1882  			SetEmptySelection(newPos);
1883  		EnsureCaretVisible();
1884  	}
1885  }
1886  void Editor::Redo() {
1887  	if (pdoc-&gt;CanRedo()) {
1888  		const Sci::Position newPos = pdoc-&gt;Redo();
1889  		if (newPos &gt;= 0)
1890  			SetEmptySelection(newPos);
1891  		EnsureCaretVisible();
1892  	}
1893  }
1894  void Editor::DelCharBack(bool allowLineStartDeletion) {
1895  	RefreshStyleData();
1896  	if (!sel.IsRectangular())
1897  		FilterSelections();
1898  	if (sel.IsRectangular())
1899  		allowLineStartDeletion = false;
1900  	UndoGroup ug(pdoc, (sel.Count() &gt; 1) || !sel.Empty());
1901  	if (sel.Empty()) {
1902  		for (size_t r=0; r&lt;sel.Count(); r++) {
1903  			if (!RangeContainsProtected(sel.Range(r).caret.Position() - 1, sel.Range(r).caret.Position())) {
1904  				if (sel.Range(r).caret.VirtualSpace()) {
1905  					sel.Range(r).caret.SetVirtualSpace(sel.Range(r).caret.VirtualSpace() - 1);
1906  					sel.Range(r).anchor.SetVirtualSpace(sel.Range(r).caret.VirtualSpace());
1907  				} else {
1908  					const Sci::Line lineCurrentPos =
1909  						pdoc-&gt;SciLineFromPosition(sel.Range(r).caret.Position());
1910  					if (allowLineStartDeletion || (pdoc-&gt;LineStart(lineCurrentPos) != sel.Range(r).caret.Position())) {
1911  						if (pdoc-&gt;GetColumn(sel.Range(r).caret.Position()) &lt;= pdoc-&gt;GetLineIndentation(lineCurrentPos) &amp;&amp;
1912  								pdoc-&gt;GetColumn(sel.Range(r).caret.Position()) &gt; 0 &amp;&amp; pdoc-&gt;backspaceUnindents) {
1913  							UndoGroup ugInner(pdoc, !ug.Needed());
1914  							const int indentation = pdoc-&gt;GetLineIndentation(lineCurrentPos);
1915  							const int indentationStep = pdoc-&gt;IndentSize();
1916  							int indentationChange = indentation % indentationStep;
1917  							if (indentationChange == 0)
1918  								indentationChange = indentationStep;
1919  							const Sci::Position posSelect = pdoc-&gt;SetLineIndentation(lineCurrentPos, indentation - indentationChange);
1920  							sel.Range(r) = SelectionRange(posSelect);
1921  						} else {
1922  							pdoc-&gt;DelCharBack(sel.Range(r).caret.Position());
1923  						}
1924  					}
1925  				}
1926  			} else {
1927  				sel.Range(r).ClearVirtualSpace();
1928  			}
1929  		}
1930  		ThinRectangularRange();
1931  	} else {
1932  		ClearSelection();
1933  	}
1934  	sel.RemoveDuplicates();
1935  	ContainerNeedsUpdate(Update::Selection);
1936  	ShowCaretAtCurrentPosition();
1937  }
1938  void Editor::NotifyFocus(bool focus) {
1939  	NotificationData scn = {};
1940  	scn.nmhdr.code = focus ? Notification::FocusIn : Notification::FocusOut;
1941  	NotifyParent(scn);
1942  }
1943  void Editor::SetCtrlID(int identifier) {
1944  	ctrlID = identifier;
1945  }
1946  void Editor::NotifyStyleToNeeded(Sci::Position endStyleNeeded) {
1947  	NotificationData scn = {};
1948  	scn.nmhdr.code = Notification::StyleNeeded;
1949  	scn.position = endStyleNeeded;
1950  	NotifyParent(scn);
1951  }
1952  void Editor::NotifyStyleNeeded(Document *, void *, Sci::Position endStyleNeeded) {
1953  	NotifyStyleToNeeded(endStyleNeeded);
1954  }
1955  void Editor::NotifyErrorOccurred(Document *, void *, Status status) {
1956  	errorStatus = status;
1957  }
1958  void Editor::NotifyChar(int ch, CharacterSource charSource) {
1959  	NotificationData scn = {};
1960  	scn.nmhdr.code = Notification::CharAdded;
1961  	scn.ch = ch;
1962  	scn.characterSource = charSource;
1963  	NotifyParent(scn);
1964  }
1965  void Editor::NotifySavePoint(bool isSavePoint) {
1966  	NotificationData scn = {};
1967  	if (isSavePoint) {
1968  		scn.nmhdr.code = Notification::SavePointReached;
1969  		if (changeHistoryOption != ChangeHistoryOption::Disabled) {
1970  			Redraw();
1971  		}
1972  	} else {
1973  		scn.nmhdr.code = Notification::SavePointLeft;
1974  	}
1975  	NotifyParent(scn);
1976  }
1977  void Editor::NotifyModifyAttempt() {
1978  	NotificationData scn = {};
1979  	scn.nmhdr.code = Notification::ModifyAttemptRO;
1980  	NotifyParent(scn);
1981  }
1982  void Editor::NotifyDoubleClick(Point pt, KeyMod modifiers) {
1983  	NotificationData scn = {};
1984  	scn.nmhdr.code = Notification::DoubleClick;
1985  	scn.line = LineFromLocation(pt);
1986  	scn.position = PositionFromLocation(pt, true);
1987  	scn.modifiers = modifiers;
1988  	NotifyParent(scn);
1989  }
1990  void Editor::NotifyHotSpotDoubleClicked(Sci::Position position, KeyMod modifiers) {
1991  	NotificationData scn = {};
1992  	scn.nmhdr.code = Notification::HotSpotDoubleClick;
1993  	scn.position = position;
1994  	scn.modifiers = modifiers;
1995  	NotifyParent(scn);
1996  }
1997  void Editor::NotifyHotSpotClicked(Sci::Position position, KeyMod modifiers) {
1998  	NotificationData scn = {};
1999  	scn.nmhdr.code = Notification::HotSpotClick;
2000  	scn.position = position;
2001  	scn.modifiers = modifiers;
2002  	NotifyParent(scn);
2003  }
2004  void Editor::NotifyHotSpotReleaseClick(Sci::Position position, KeyMod modifiers) {
2005  	NotificationData scn = {};
2006  	scn.nmhdr.code = Notification::HotSpotReleaseClick;
2007  	scn.position = position;
2008  	scn.modifiers = modifiers;
2009  	NotifyParent(scn);
2010  }
2011  bool Editor::NotifyUpdateUI() {
2012  	if (needUpdateUI != Update::None) {
2013  		NotificationData scn = {};
2014  		scn.nmhdr.code = Notification::UpdateUI;
2015  		scn.updated = needUpdateUI;
2016  		NotifyParent(scn);
2017  		needUpdateUI = Update::None;
2018  		return true;
2019  	}
2020  	return false;
2021  }
2022  void Editor::NotifyPainted() {
2023  	NotificationData scn = {};
2024  	scn.nmhdr.code = Notification::Painted;
2025  	NotifyParent(scn);
2026  }
2027  void Editor::NotifyIndicatorClick(bool click, Sci::Position position, KeyMod modifiers) {
2028  	const int mask = pdoc-&gt;decorations-&gt;AllOnFor(position);
2029  	if ((click &amp;&amp; mask) || pdoc-&gt;decorations-&gt;ClickNotified()) {
2030  		NotificationData scn = {};
2031  		pdoc-&gt;decorations-&gt;SetClickNotified(click);
2032  		scn.nmhdr.code = click ? Notification::IndicatorClick : Notification::IndicatorRelease;
2033  		scn.modifiers = modifiers;
2034  		scn.position = position;
2035  		NotifyParent(scn);
2036  	}
2037  }
2038  bool Editor::NotifyMarginClick(Point pt, KeyMod modifiers) {
2039  	const int marginClicked = vs.MarginFromLocation(pt);
2040  	if ((marginClicked &gt;= 0) &amp;&amp; vs.ms[marginClicked].sensitive) {
2041  		const Sci::Position position = pdoc-&gt;LineStart(LineFromLocation(pt));
2042  		if ((vs.ms[marginClicked].mask &amp; MaskFolders) &amp;&amp; (FlagSet(foldAutomatic, AutomaticFold::Click))) {
2043  			const bool ctrl = FlagSet(modifiers, KeyMod::Ctrl);
2044  			const bool shift = FlagSet(modifiers, KeyMod::Shift);
2045  			const Sci::Line lineClick = pdoc-&gt;SciLineFromPosition(position);
2046  			if (shift &amp;&amp; ctrl) {
2047  				FoldAll(FoldAction::Toggle);
2048  			} else {
2049  				const FoldLevel levelClick = pdoc-&gt;GetFoldLevel(lineClick);
2050  				if (LevelIsHeader(levelClick)) {
2051  					if (shift) {
2052  						FoldExpand(lineClick, FoldAction::Expand, levelClick);
2053  					} else if (ctrl) {
2054  						FoldExpand(lineClick, FoldAction::Toggle, levelClick);
2055  					} else {
2056  						FoldLine(lineClick, FoldAction::Toggle);
2057  					}
2058  				}
2059  			}
2060  			return true;
2061  		}
2062  		NotificationData scn = {};
2063  		scn.nmhdr.code = Notification::MarginClick;
2064  		scn.modifiers = modifiers;
2065  		scn.position = position;
2066  		scn.margin = marginClicked;
2067  		NotifyParent(scn);
2068  		return true;
2069  	} else {
2070  		return false;
2071  	}
2072  }
2073  bool Editor::NotifyMarginRightClick(Point pt, KeyMod modifiers) {
2074  	const int marginRightClicked = vs.MarginFromLocation(pt);
2075  	if ((marginRightClicked &gt;= 0) &amp;&amp; vs.ms[marginRightClicked].sensitive) {
2076  		const Sci::Position position = pdoc-&gt;LineStart(LineFromLocation(pt));
2077  		NotificationData scn = {};
2078  		scn.nmhdr.code = Notification::MarginRightClick;
2079  		scn.modifiers = modifiers;
2080  		scn.position = position;
2081  		scn.margin = marginRightClicked;
2082  		NotifyParent(scn);
2083  		return true;
2084  	} else {
2085  		return false;
2086  	}
2087  }
2088  void Editor::NotifyNeedShown(Sci::Position pos, Sci::Position len) {
2089  	NotificationData scn = {};
2090  	scn.nmhdr.code = Notification::NeedShown;
2091  	scn.position = pos;
2092  	scn.length = len;
2093  	NotifyParent(scn);
2094  }
2095  void Editor::NotifyDwelling(Point pt, bool state) {
2096  	NotificationData scn = {};
2097  	scn.nmhdr.code = state ? Notification::DwellStart : Notification::DwellEnd;
2098  	scn.position = PositionFromLocation(pt, true);
2099  	scn.x = static_cast&lt;int&gt;(pt.x + vs.ExternalMarginWidth());
2100  	scn.y = static_cast&lt;int&gt;(pt.y);
2101  	NotifyParent(scn);
2102  }
2103  void Editor::NotifyZoom() {
2104  	NotificationData scn = {};
2105  	scn.nmhdr.code = Notification::Zoom;
2106  	NotifyParent(scn);
2107  }
2108  void Editor::NotifyModifyAttempt(Document *, void *) {
2109  	NotifyModifyAttempt();
2110  }
2111  void Editor::NotifySavePoint(Document *, void *, bool atSavePoint) {
2112  	NotifySavePoint(atSavePoint);
2113  }
2114  void Editor::CheckModificationForWrap(DocModification mh) {
2115  	if (FlagSet(mh.modificationType, ModificationFlags::InsertText | ModificationFlags::DeleteText)) {
2116  		view.llc.Invalidate(LineLayout::ValidLevel::checkTextAndStyle);
2117  		const Sci::Line lineDoc = pdoc-&gt;SciLineFromPosition(mh.position);
2118  		const Sci::Line lines = std::max(static_cast&lt;Sci::Line&gt;(0), mh.linesAdded);
2119  		if (Wrapping()) {
2120  			NeedWrapping(lineDoc, lineDoc + lines + 1);
2121  		}
2122  		RefreshStyleData();
2123  		SetAnnotationHeights(lineDoc, lineDoc + lines + 2);
2124  	}
2125  }
2126  namespace {
2127  constexpr Sci::Position MovePositionForInsertion(Sci::Position position, Sci::Position startInsertion, Sci::Position length) noexcept {
2128  	if (position &gt; startInsertion) {
2129  		return position + length;
2130  	}
2131  	return position;
2132  }
2133  constexpr Sci::Position MovePositionForDeletion(Sci::Position position, Sci::Position startDeletion, Sci::Position length) noexcept {
2134  	if (position &gt; startDeletion) {
2135  		const Sci::Position endDeletion = startDeletion + length;
2136  		if (position &gt; endDeletion) {
2137  			return position - length;
2138  		} else {
2139  			return startDeletion;
2140  		}
2141  	} else {
2142  		return position;
2143  	}
2144  }
2145  }
2146  void Editor::NotifyModified(Document *, DocModification mh, void *) {
2147  	ContainerNeedsUpdate(Update::Content);
2148  	if (paintState == PaintState::painting) {
2149  		CheckForChangeOutsidePaint(Range(mh.position, mh.position + mh.length));
2150  	}
2151  	if (FlagSet(mh.modificationType, ModificationFlags::ChangeLineState)) {
2152  		if (paintState == PaintState::painting) {
2153  			CheckForChangeOutsidePaint(
2154  			    Range(pdoc-&gt;LineStart(mh.line),
2155  					pdoc-&gt;LineStart(mh.line + 1)));
2156  		} else {
2157  			Redraw();
2158  		}
2159  	}
2160  	if (FlagSet(mh.modificationType, ModificationFlags::ChangeTabStops)) {
2161  		Redraw();
2162  	}
2163  	if (FlagSet(mh.modificationType, ModificationFlags::LexerState)) {
2164  		if (paintState == PaintState::painting) {
2165  			CheckForChangeOutsidePaint(
2166  			    Range(mh.position, mh.position + mh.length));
2167  		} else {
2168  			Redraw();
2169  		}
2170  	}
2171  	if (FlagSet(mh.modificationType, ModificationFlags::ChangeStyle | ModificationFlags::ChangeIndicator)) {
2172  		if (FlagSet(mh.modificationType, ModificationFlags::ChangeStyle)) {
2173  			pdoc-&gt;IncrementStyleClock();
2174  		}
2175  		if (paintState == PaintState::notPainting) {
2176  			const Sci::Line lineDocTop = pcs-&gt;DocFromDisplay(topLine);
2177  			if (mh.position &lt; pdoc-&gt;LineStart(lineDocTop)) {
2178  				Redraw();
2179  			} else {
2180  				InvalidateRange(mh.position, mh.position + mh.length);
2181  			}
2182  		}
2183  		if (FlagSet(mh.modificationType, ModificationFlags::ChangeStyle)) {
2184  			view.llc.Invalidate(LineLayout::ValidLevel::checkTextAndStyle);
2185  		}
2186  	} else {
2187  		if (FlagSet(mh.modificationType, ModificationFlags::InsertText)) {
2188  			sel.MovePositions(true, mh.position, mh.length);
2189  			braces[0] = MovePositionForInsertion(braces[0], mh.position, mh.length);
2190  			braces[1] = MovePositionForInsertion(braces[1], mh.position, mh.length);
2191  		} else if (FlagSet(mh.modificationType, ModificationFlags::DeleteText)) {
2192  			sel.MovePositions(false, mh.position, mh.length);
2193  			braces[0] = MovePositionForDeletion(braces[0], mh.position, mh.length);
2194  			braces[1] = MovePositionForDeletion(braces[1], mh.position, mh.length);
2195  		}
2196  		if (FlagSet(mh.modificationType, ModificationFlags::BeforeInsert | ModificationFlags::BeforeDelete) &amp;&amp; pcs-&gt;HiddenLines()) {
2197  			const Sci::Line lineOfPos = pdoc-&gt;SciLineFromPosition(mh.position);
2198  			Sci::Position endNeedShown = mh.position;
2199  			if (FlagSet(mh.modificationType, ModificationFlags::BeforeInsert)) {
2200  				if (pdoc-&gt;ContainsLineEnd(mh.text, mh.length) &amp;&amp; (mh.position != pdoc-&gt;LineStart(lineOfPos)))
2201  					endNeedShown = pdoc-&gt;LineStart(lineOfPos+1);
2202  			} else if (FlagSet(mh.modificationType, ModificationFlags::BeforeDelete)) {
2203  				endNeedShown = mh.position + mh.length;
2204  				Sci::Line lineLast = pdoc-&gt;SciLineFromPosition(mh.position+mh.length);
2205  				for (Sci::Line line = lineOfPos + 1; line &lt;= lineLast; line++) {
2206  					const Sci::Line lineMaxSubord = pdoc-&gt;GetLastChild(line, {}, -1);
2207  					if (lineLast &lt; lineMaxSubord) {
2208  						lineLast = lineMaxSubord;
2209  						endNeedShown = pdoc-&gt;LineEnd(lineLast);
2210  					}
2211  				}
2212  			}
2213  			NeedShown(mh.position, endNeedShown - mh.position);
2214  		}
2215  		if (mh.linesAdded != 0) {
2216  			Sci::Line lineOfPos = pdoc-&gt;SciLineFromPosition(mh.position);
2217  			if (mh.position &gt; pdoc-&gt;LineStart(lineOfPos))
2218  				lineOfPos++;	
2219  			if (mh.linesAdded &gt; 0) {
2220  				pcs-&gt;InsertLines(lineOfPos, mh.linesAdded);
2221  			} else {
2222  				pcs-&gt;DeleteLines(lineOfPos, -mh.linesAdded);
2223  			}
2224  			view.LinesAddedOrRemoved(lineOfPos, mh.linesAdded);
2225  		}
2226  		if (FlagSet(mh.modificationType, ModificationFlags::ChangeAnnotation)) {
2227  			const Sci::Line lineDoc = pdoc-&gt;SciLineFromPosition(mh.position);
2228  			if (vs.annotationVisible != AnnotationVisible::Hidden) {
2229  				if (pcs-&gt;SetHeight(lineDoc, pcs-&gt;GetHeight(lineDoc) + static_cast&lt;int&gt;(mh.annotationLinesAdded))) {
2230  					SetScrollBars();
2231  				}
2232  				Redraw();
2233  			}
2234  		}
2235  		if (FlagSet(mh.modificationType, ModificationFlags::ChangeEOLAnnotation)) {
2236  			if (vs.eolAnnotationVisible != EOLAnnotationVisible::Hidden) {
2237  				Redraw();
2238  			}
2239  		}
2240  		CheckModificationForWrap(mh);
2241  		if (mh.linesAdded != 0) {
2242  			if (mh.position &lt; posTopLine &amp;&amp; !CanDeferToLastStep(mh)) {
2243  				const Sci::Line newTop = std::clamp&lt;Sci::Line&gt;(topLine + mh.linesAdded, 0, MaxScrollPos());
2244  				if (newTop != topLine) {
2245  					SetTopLine(newTop);
2246  					SetVerticalScrollPos();
2247  				}
2248  			}
2249  			if (paintState == PaintState::notPainting &amp;&amp; !CanDeferToLastStep(mh)) {
2250  				if (SynchronousStylingToVisible()) {
2251  					QueueIdleWork(WorkItems::style, pdoc-&gt;Length());
2252  				}
2253  				Redraw();
2254  			}
2255  		} else {
2256  			if (paintState == PaintState::notPainting &amp;&amp; mh.length &amp;&amp; !CanEliminate(mh)) {
2257  				if (SynchronousStylingToVisible()) {
2258  					QueueIdleWork(WorkItems::style, mh.position + mh.length);
2259  				}
2260  				InvalidateRange(mh.position, mh.position + mh.length);
2261  				if (FlagSet(changeHistoryOption, ChangeHistoryOption::Markers)) {
2262  					RedrawSelMargin(pdoc-&gt;SciLineFromPosition(mh.position));
2263  				}
2264  			}
2265  		}
2266  	}
2267  	if (mh.linesAdded != 0 &amp;&amp; !CanDeferToLastStep(mh)) {
2268  		SetScrollBars();
2269  	}
2270  	if ((FlagSet(mh.modificationType, ModificationFlags::ChangeMarker)) || (FlagSet(mh.modificationType, ModificationFlags::ChangeMargin))) {
2271  		if ((!willRedrawAll) &amp;&amp; ((paintState == PaintState::notPainting) || !PaintContainsMargin())) {
2272  			if (FlagSet(mh.modificationType, ModificationFlags::ChangeFold)) {
2273  				RedrawSelMargin(marginView.highlightDelimiter.isEnabled ? -1 : mh.line - 1, true);
2274  			} else {
2275  				RedrawSelMargin(mh.line);
2276  			}
2277  		}
2278  	}
2279  	if ((FlagSet(mh.modificationType, ModificationFlags::ChangeFold)) &amp;&amp; (FlagSet(foldAutomatic, AutomaticFold::Change))) {
2280  		FoldChanged(mh.line, mh.foldLevelNow, mh.foldLevelPrev);
2281  	}
2282  	if (IsLastStep(mh)) {
2283  		SetScrollBars();
2284  		Redraw();
2285  	}
2286  	if (FlagSet(mh.modificationType, modEventMask)) {
2287  		if (commandEvents) {
2288  			if ((mh.modificationType &amp; (ModificationFlags::ChangeStyle | ModificationFlags::ChangeIndicator)) == ModificationFlags::None) {
2289  				NotifyChange();	
2290  			}
2291  		}
2292  		NotificationData scn = {};
2293  		scn.nmhdr.code = Notification::Modified;
2294  		scn.position = mh.position;
2295  		scn.modificationType = mh.modificationType;
2296  		scn.text = mh.text;
2297  		scn.length = mh.length;
2298  		scn.linesAdded = mh.linesAdded;
2299  		scn.line = mh.line;
2300  		scn.foldLevelNow = mh.foldLevelNow;
2301  		scn.foldLevelPrev = mh.foldLevelPrev;
2302  		scn.token = static_cast&lt;int&gt;(mh.token);
2303  		scn.annotationLinesAdded = mh.annotationLinesAdded;
2304  		NotifyParent(scn);
2305  	}
2306  }
2307  void Editor::NotifyDeleted(Document *, void *) noexcept {
2308  }
2309  void Editor::NotifyMacroRecord(Message iMessage, uptr_t wParam, sptr_t lParam) {
2310  	switch (iMessage) {
2311  	case Message::Cut:
2312  	case Message::Copy:
2313  	case Message::Paste:
2314  	case Message::Clear:
2315  	case Message::ReplaceSel:
2316  	case Message::AddText:
2317  	case Message::InsertText:
2318  	case Message::AppendText:
2319  	case Message::ClearAll:
2320  	case Message::SelectAll:
2321  	case Message::GotoLine:
2322  	case Message::GotoPos:
2323  	case Message::SearchAnchor:
2324  	case Message::SearchNext:
2325  	case Message::SearchPrev:
2326  	case Message::LineDown:
2327  	case Message::LineDownExtend:
2328  	case Message::ParaDown:
2329  	case Message::ParaDownExtend:
2330  	case Message::LineUp:
2331  	case Message::LineUpExtend:
2332  	case Message::ParaUp:
2333  	case Message::ParaUpExtend:
2334  	case Message::CharLeft:
2335  	case Message::CharLeftExtend:
2336  	case Message::CharRight:
2337  	case Message::CharRightExtend:
2338  	case Message::WordLeft:
2339  	case Message::WordLeftExtend:
2340  	case Message::WordRight:
2341  	case Message::WordRightExtend:
2342  	case Message::WordPartLeft:
2343  	case Message::WordPartLeftExtend:
2344  	case Message::WordPartRight:
2345  	case Message::WordPartRightExtend:
2346  	case Message::WordLeftEnd:
2347  	case Message::WordLeftEndExtend:
2348  	case Message::WordRightEnd:
2349  	case Message::WordRightEndExtend:
2350  	case Message::Home:
2351  	case Message::HomeExtend:
2352  	case Message::LineEnd:
2353  	case Message::LineEndExtend:
2354  	case Message::HomeWrap:
2355  	case Message::HomeWrapExtend:
2356  	case Message::LineEndWrap:
2357  	case Message::LineEndWrapExtend:
2358  	case Message::DocumentStart:
2359  	case Message::DocumentStartExtend:
2360  	case Message::DocumentEnd:
2361  	case Message::DocumentEndExtend:
2362  	case Message::StutteredPageUp:
2363  	case Message::StutteredPageUpExtend:
2364  	case Message::StutteredPageDown:
2365  	case Message::StutteredPageDownExtend:
2366  	case Message::PageUp:
2367  	case Message::PageUpExtend:
2368  	case Message::PageDown:
2369  	case Message::PageDownExtend:
2370  	case Message::EditToggleOvertype:
2371  	case Message::Cancel:
2372  	case Message::DeleteBack:
2373  	case Message::Tab:
2374  	case Message::BackTab:
2375  	case Message::FormFeed:
2376  	case Message::VCHome:
2377  	case Message::VCHomeExtend:
2378  	case Message::VCHomeWrap:
2379  	case Message::VCHomeWrapExtend:
2380  	case Message::VCHomeDisplay:
2381  	case Message::VCHomeDisplayExtend:
2382  	case Message::DelWordLeft:
2383  	case Message::DelWordRight:
2384  	case Message::DelWordRightEnd:
2385  	case Message::DelLineLeft:
2386  	case Message::DelLineRight:
2387  	case Message::LineCopy:
2388  	case Message::LineCut:
2389  	case Message::LineDelete:
2390  	case Message::LineTranspose:
2391  	case Message::LineReverse:
2392  	case Message::LineDuplicate:
2393  	case Message::LowerCase:
2394  	case Message::UpperCase:
2395  	case Message::LineScrollDown:
2396  	case Message::LineScrollUp:
2397  	case Message::DeleteBackNotLine:
2398  	case Message::HomeDisplay:
2399  	case Message::HomeDisplayExtend:
2400  	case Message::LineEndDisplay:
2401  	case Message::LineEndDisplayExtend:
2402  	case Message::SetSelectionMode:
2403  	case Message::LineDownRectExtend:
2404  	case Message::LineUpRectExtend:
2405  	case Message::CharLeftRectExtend:
2406  	case Message::CharRightRectExtend:
2407  	case Message::HomeRectExtend:
2408  	case Message::VCHomeRectExtend:
2409  	case Message::LineEndRectExtend:
2410  	case Message::PageUpRectExtend:
2411  	case Message::PageDownRectExtend:
2412  	case Message::SelectionDuplicate:
2413  	case Message::CopyAllowLine:
2414  	case Message::VerticalCentreCaret:
2415  	case Message::MoveSelectedLinesUp:
2416  	case Message::MoveSelectedLinesDown:
2417  	case Message::ScrollToStart:
2418  	case Message::ScrollToEnd:
2419  		break;
2420  	case Message::NewLine:
2421  	default:
2422  		return;
2423  	}
2424  	NotificationData scn = {};
2425  	scn.nmhdr.code = Notification::MacroRecord;
2426  	scn.message = iMessage;
2427  	scn.wParam = wParam;
2428  	scn.lParam = lParam;
2429  	NotifyParent(scn);
2430  }
2431  void Editor::ContainerNeedsUpdate(Update flags) noexcept {
2432  	needUpdateUI = needUpdateUI | flags;
2433  }
2434  void Editor::PageMove(int direction, Selection::SelTypes selt, bool stuttered) {
2435  	Sci::Line topLineNew;
2436  	SelectionPosition newPos;
2437  	const Sci::Line currentLine = pdoc-&gt;SciLineFromPosition(sel.MainCaret());
2438  	const Sci::Line topStutterLine = topLine + caretPolicies.y.slop;
2439  	const Sci::Line bottomStutterLine =
2440  	    pdoc-&gt;SciLineFromPosition(PositionFromLocation(
2441  	                Point::FromInts(lastXChosen - xOffset, direction * vs.lineHeight * static_cast&lt;int&gt;(LinesToScroll()))))
2442  	    - caretPolicies.y.slop - 1;
2443  	if (stuttered &amp;&amp; (direction &lt; 0 &amp;&amp; currentLine &gt; topStutterLine)) {
2444  		topLineNew = topLine;
2445  		newPos = SPositionFromLocation(Point::FromInts(lastXChosen - xOffset, vs.lineHeight * caretPolicies.y.slop),
2446  			false, false, UserVirtualSpace());
2447  	} else if (stuttered &amp;&amp; (direction &gt; 0 &amp;&amp; currentLine &lt; bottomStutterLine)) {
2448  		topLineNew = topLine;
2449  		newPos = SPositionFromLocation(Point::FromInts(lastXChosen - xOffset, vs.lineHeight * static_cast&lt;int&gt;(LinesToScroll() - caretPolicies.y.slop)),
2450  			false, false, UserVirtualSpace());
2451  	} else {
2452  		const Point pt = LocationFromPosition(sel.MainCaret());
2453  		topLineNew = std::clamp&lt;Sci::Line&gt;(
2454  		            topLine + direction * LinesToScroll(), 0, MaxScrollPos());
2455  		newPos = SPositionFromLocation(
2456  			Point::FromInts(lastXChosen - xOffset, static_cast&lt;int&gt;(pt.y) +
2457  				direction * (vs.lineHeight * static_cast&lt;int&gt;(LinesToScroll()))),
2458  			false, false, UserVirtualSpace());
2459  	}
2460  	if (topLineNew != topLine) {
2461  		SetTopLine(topLineNew);
2462  		MovePositionTo(newPos, selt);
2463  		SetVerticalScrollPos();
2464  		Redraw();
2465  	} else {
2466  		MovePositionTo(newPos, selt);
2467  	}
2468  }
2469  void Editor::ChangeCaseOfSelection(CaseMapping caseMapping) {
2470  	UndoGroup ug(pdoc);
2471  	for (size_t r=0; r&lt;sel.Count(); r++) {
2472  		SelectionRange current = sel.Range(r);
2473  		SelectionRange currentNoVS = current;
2474  		currentNoVS.ClearVirtualSpace();
2475  		const size_t rangeBytes = currentNoVS.Length();
2476  		if (rangeBytes &gt; 0) {
2477  			std::string sText = RangeText(currentNoVS.Start().Position(), currentNoVS.End().Position());
2478  			std::string sMapped = CaseMapString(sText, caseMapping);
2479  			if (sMapped != sText) {
2480  				size_t firstDifference = 0;
2481  				while (sMapped[firstDifference] == sText[firstDifference])
2482  					firstDifference++;
2483  				size_t lastDifferenceText = sText.size() - 1;
2484  				size_t lastDifferenceMapped = sMapped.size() - 1;
2485  				while (sMapped[lastDifferenceMapped] == sText[lastDifferenceText]) {
2486  					lastDifferenceText--;
2487  					lastDifferenceMapped--;
2488  				}
2489  				const size_t endDifferenceText = sText.size() - 1 - lastDifferenceText;
2490  				pdoc-&gt;DeleteChars(
2491  					currentNoVS.Start().Position() + firstDifference,
2492  					rangeBytes - firstDifference - endDifferenceText);
2493  				const Sci::Position lengthChange = lastDifferenceMapped - firstDifference + 1;
2494  				const Sci::Position lengthInserted = pdoc-&gt;InsertString(
2495  					currentNoVS.Start().Position() + firstDifference,
2496  					sMapped.c_str() + firstDifference,
2497  					lengthChange);
2498  				const Sci::Position diffSizes = sMapped.size() - sText.size() + lengthInserted - lengthChange;
2499  				if (diffSizes != 0) {
2500  					if (current.anchor &gt; current.caret)
2501  						current.anchor.Add(diffSizes);
2502  					else
2503  						current.caret.Add(diffSizes);
2504  				}
2505  				sel.Range(r) = current;
2506  			}
2507  		}
2508  	}
2509  }
2510  void Editor::LineTranspose() {
2511  	const Sci::Line line = pdoc-&gt;SciLineFromPosition(sel.MainCaret());
2512  	if (line &gt; 0) {
2513  		UndoGroup ug(pdoc);
2514  		const Sci::Position startPrevious = pdoc-&gt;LineStart(line - 1);
2515  		const std::string linePrevious = RangeText(startPrevious, pdoc-&gt;LineEnd(line - 1));
2516  		Sci::Position startCurrent = pdoc-&gt;LineStart(line);
2517  		const std::string lineCurrent = RangeText(startCurrent, pdoc-&gt;LineEnd(line));
2518  		pdoc-&gt;DeleteChars(startCurrent, lineCurrent.length());
2519  		pdoc-&gt;DeleteChars(startPrevious, linePrevious.length());
2520  		startCurrent -= linePrevious.length();
2521  		startCurrent += pdoc-&gt;InsertString(startPrevious, lineCurrent);
2522  		pdoc-&gt;InsertString(startCurrent, linePrevious);
2523  		MovePositionTo(SelectionPosition(startCurrent));
2524  	}
2525  }
2526  void Editor::LineReverse() {
2527  	const Sci::Line lineStart =
2528  		pdoc-&gt;SciLineFromPosition(sel.RangeMain().Start().Position());
2529  	const Sci::Line lineEnd =
2530  		pdoc-&gt;SciLineFromPosition(sel.RangeMain().End().Position()-1);
2531  	const Sci::Line lineDiff = lineEnd - lineStart;
2532  	if (lineDiff &lt;= 0)
2533  		return;
2534  	UndoGroup ug(pdoc);
2535  	for (Sci::Line i=(lineDiff+1)/2-1; i&gt;=0; --i) {
2536  		const Sci::Line lineNum2 = lineEnd - i;
2537  		const Sci::Line lineNum1 = lineStart + i;
2538  		Sci::Position lineStart2 = pdoc-&gt;LineStart(lineNum2);
2539  		const Sci::Position lineStart1 = pdoc-&gt;LineStart(lineNum1);
2540  		const std::string line2 = RangeText(lineStart2, pdoc-&gt;LineEnd(lineNum2));
2541  		const std::string line1 = RangeText(lineStart1, pdoc-&gt;LineEnd(lineNum1));
2542  		const Sci::Position lineLen2 = line2.length();
2543  		const Sci::Position lineLen1 = line1.length();
2544  		pdoc-&gt;DeleteChars(lineStart2, lineLen2);
2545  		pdoc-&gt;DeleteChars(lineStart1, lineLen1);
2546  		lineStart2 -= lineLen1;
2547  		pdoc-&gt;InsertString(lineStart2, line1);
2548  		pdoc-&gt;InsertString(lineStart1, line2);
2549  	}
2550  	sel.RangeMain() = SelectionRange(pdoc-&gt;LineStart(lineStart),
2551  		pdoc-&gt;LineStart(lineEnd+1));
2552  }
2553  void Editor::Duplicate(bool forLine) {
2554  	if (sel.Empty()) {
2555  		forLine = true;
2556  	}
2557  	UndoGroup ug(pdoc);
2558  	std::string_view eol;
2559  	if (forLine) {
2560  		eol = pdoc-&gt;EOLString();
2561  	}
2562  	for (size_t r=0; r&lt;sel.Count(); r++) {
2563  		SelectionPosition start = sel.Range(r).Start();
2564  		SelectionPosition end = sel.Range(r).End();
2565  		if (forLine) {
2566  			const Sci::Line line = pdoc-&gt;SciLineFromPosition(sel.Range(r).caret.Position());
2567  			start = SelectionPosition(pdoc-&gt;LineStart(line));
2568  			end = SelectionPosition(pdoc-&gt;LineEnd(line));
2569  		}
2570  		std::string text = RangeText(start.Position(), end.Position());
2571  		Sci::Position lengthInserted = 0;
2572  		if (forLine)
2573  			lengthInserted = pdoc-&gt;InsertString(end.Position(), eol);
2574  		pdoc-&gt;InsertString(end.Position() + lengthInserted, text);
2575  	}
2576  	if (sel.Count() &amp;&amp; sel.IsRectangular()) {
2577  		SelectionPosition last = sel.Last();
2578  		if (forLine) {
2579  			const Sci::Line line = pdoc-&gt;SciLineFromPosition(last.Position());
2580  			last = SelectionPosition(last.Position() +
2581  				pdoc-&gt;LineStart(line+1) - pdoc-&gt;LineStart(line));
2582  		}
2583  		if (sel.Rectangular().anchor &gt; sel.Rectangular().caret)
2584  			sel.Rectangular().anchor = last;
2585  		else
2586  			sel.Rectangular().caret = last;
2587  		SetRectangularRange();
2588  	}
2589  }
2590  void Editor::CancelModes() {
2591  	sel.SetMoveExtends(false);
2592  }
2593  void Editor::NewLine() {
2594  	InvalidateWholeSelection();
2595  	if (sel.IsRectangular() || !additionalSelectionTyping) {
2596  		sel.DropAdditionalRanges();
2597  	}
2598  	UndoGroup ug(pdoc, !sel.Empty() || (sel.Count() &gt; 1));
2599  	if (!sel.Empty()) {
2600  		ClearSelection();
2601  	}
2602  	size_t countInsertions = 0;
2603  	const std::string_view eol = pdoc-&gt;EOLString();
2604  	for (size_t r = 0; r &lt; sel.Count(); r++) {
2605  		sel.Range(r).ClearVirtualSpace();
2606  		const Sci::Position positionInsert = sel.Range(r).caret.Position();
2607  		const Sci::Position insertLength = pdoc-&gt;InsertString(positionInsert, eol);
2608  		if (insertLength &gt; 0) {
2609  			sel.Range(r) = SelectionRange(positionInsert + insertLength);
2610  			countInsertions++;
2611  		}
2612  	}
2613  	for (size_t i = 0; i &lt; countInsertions; i++) {
2614  		for (const char ch : eol) {
2615  			NotifyChar(ch, CharacterSource::DirectInput);
2616  			if (recordingMacro) {
2617  				const char txt[2] = { ch, &#x27;\0&#x27; };
2618  				NotifyMacroRecord(Message::ReplaceSel, 0, reinterpret_cast&lt;sptr_t&gt;(txt));
2619  			}
2620  		}
2621  	}
2622  	SetLastXChosen();
2623  	SetScrollBars();
2624  	EnsureCaretVisible();
2625  	ShowCaretAtCurrentPosition();
2626  }
2627  SelectionPosition Editor::PositionUpOrDown(SelectionPosition spStart, int direction, int lastX) {
2628  	const Point pt = LocationFromPosition(spStart);
2629  	int skipLines = 0;
2630  	if (vs.annotationVisible != AnnotationVisible::Hidden) {
2631  		const Sci::Line lineDoc = pdoc-&gt;SciLineFromPosition(spStart.Position());
2632  		const Point ptStartLine = LocationFromPosition(pdoc-&gt;LineStart(lineDoc));
2633  		const int subLine = static_cast&lt;int&gt;(pt.y - ptStartLine.y) / vs.lineHeight;
2634  		if (direction &lt; 0 &amp;&amp; subLine == 0) {
2635  			const Sci::Line lineDisplay = pcs-&gt;DisplayFromDoc(lineDoc);
2636  			if (lineDisplay &gt; 0) {
2637  				skipLines = pdoc-&gt;AnnotationLines(pcs-&gt;DocFromDisplay(lineDisplay - 1));
2638  			}
2639  		} else if (direction &gt; 0 &amp;&amp; subLine &gt;= (pcs-&gt;GetHeight(lineDoc) - 1 - pdoc-&gt;AnnotationLines(lineDoc))) {
2640  			skipLines = pdoc-&gt;AnnotationLines(lineDoc);
2641  		}
2642  	}
2643  	const Sci::Line newY = static_cast&lt;Sci::Line&gt;(pt.y) + (1 + skipLines) * direction * vs.lineHeight;
2644  	if (lastX &lt; 0) {
2645  		lastX = static_cast&lt;int&gt;(pt.x) + xOffset;
2646  	}
2647  	SelectionPosition posNew = SPositionFromLocation(
2648  		Point::FromInts(lastX - xOffset, static_cast&lt;int&gt;(newY)), false, false, UserVirtualSpace());
2649  	if (direction &lt; 0) {
2650  		Point ptNew = LocationFromPosition(posNew.Position());
2651  		while ((posNew.Position() &gt; 0) &amp;&amp; (pt.y == ptNew.y)) {
2652  			posNew.Add(-1);
2653  			posNew.SetVirtualSpace(0);
2654  			ptNew = LocationFromPosition(posNew.Position());
2655  		}
2656  	} else if (direction &gt; 0 &amp;&amp; posNew.Position() != pdoc-&gt;Length()) {
2657  		Point ptNew = LocationFromPosition(posNew.Position());
2658  		while ((posNew.Position() &gt; spStart.Position()) &amp;&amp; (ptNew.y &gt; newY)) {
2659  			posNew.Add(-1);
2660  			posNew.SetVirtualSpace(0);
2661  			ptNew = LocationFromPosition(posNew.Position());
2662  		}
2663  	}
2664  	return posNew;
2665  }
2666  void Editor::CursorUpOrDown(int direction, Selection::SelTypes selt) {
2667  	if ((selt == Selection::SelTypes::none) &amp;&amp; sel.MoveExtends()) {
2668  		selt = !sel.IsRectangular() ? Selection::SelTypes::stream : Selection::SelTypes::rectangle;
2669  	}
2670  	SelectionPosition caretToUse = sel.Range(sel.Main()).caret;
2671  	if (sel.IsRectangular()) {
2672  		if (selt ==  Selection::SelTypes::none) {
2673  			caretToUse = (direction &gt; 0) ? sel.Limits().end : sel.Limits().start;
2674  		} else {
2675  			caretToUse = sel.Rectangular().caret;
2676  		}
2677  	}
2678  	if (selt == Selection::SelTypes::rectangle) {
2679  		const SelectionRange rangeBase = sel.IsRectangular() ? sel.Rectangular() : sel.RangeMain();
2680  		if (!sel.IsRectangular()) {
2681  			InvalidateWholeSelection();
2682  			sel.DropAdditionalRanges();
2683  		}
2684  		const SelectionPosition posNew = MovePositionSoVisible(
2685  			PositionUpOrDown(caretToUse, direction, lastXChosen), direction);
2686  		sel.selType = Selection::SelTypes::rectangle;
2687  		sel.Rectangular() = SelectionRange(posNew, rangeBase.anchor);
2688  		SetRectangularRange();
2689  		MovedCaret(posNew, caretToUse, true, caretPolicies);
2690  	} else if (sel.selType == Selection::SelTypes::lines &amp;&amp; sel.MoveExtends()) {
2691  		const SelectionPosition posNew = MovePositionSoVisible(
2692  			PositionUpOrDown(caretToUse, direction, -1), direction);
2693  		SetSelection(posNew, sel.Range(sel.Main()).anchor);
2694  	} else {
2695  		InvalidateWholeSelection();
2696  		if (!additionalSelectionTyping || (sel.IsRectangular())) {
2697  			sel.DropAdditionalRanges();
2698  		}
2699  		sel.selType = Selection::SelTypes::stream;
2700  		for (size_t r = 0; r &lt; sel.Count(); r++) {
2701  			const int lastX = (r == sel.Main()) ? lastXChosen : -1;
2702  			const SelectionPosition spCaretNow = sel.Range(r).caret;
2703  			const SelectionPosition posNew = MovePositionSoVisible(
2704  				PositionUpOrDown(spCaretNow, direction, lastX), direction);
2705  			sel.Range(r) = selt == Selection::SelTypes::stream ?
2706  				SelectionRange(posNew, sel.Range(r).anchor) : SelectionRange(posNew);
2707  		}
2708  		sel.RemoveDuplicates();
2709  		MovedCaret(sel.RangeMain().caret, caretToUse, true, caretPolicies);
2710  	}
2711  }
2712  void Editor::ParaUpOrDown(int direction, Selection::SelTypes selt) {
2713  	Sci::Line lineDoc;
2714  	const Sci::Position savedPos = sel.MainCaret();
2715  	do {
2716  		MovePositionTo(SelectionPosition(direction &gt; 0 ? pdoc-&gt;ParaDown(sel.MainCaret()) : pdoc-&gt;ParaUp(sel.MainCaret())), selt);
2717  		lineDoc = pdoc-&gt;SciLineFromPosition(sel.MainCaret());
2718  		if (direction &gt; 0) {
2719  			if (sel.MainCaret() &gt;= pdoc-&gt;Length() &amp;&amp; !pcs-&gt;GetVisible(lineDoc)) {
2720  				if (selt == Selection::SelTypes::none) {
2721  					MovePositionTo(SelectionPosition(pdoc-&gt;LineEndPosition(savedPos)));
2722  				}
2723  				break;
2724  			}
2725  		}
2726  	} while (!pcs-&gt;GetVisible(lineDoc));
2727  }
2728  Range Editor::RangeDisplayLine(Sci::Line lineVisible) {
2729  	RefreshStyleData();
2730  	AutoSurface surface(this);
2731  	return view.RangeDisplayLine(surface, *this, lineVisible, vs);
2732  }
2733  Sci::Position Editor::StartEndDisplayLine(Sci::Position pos, bool start) {
2734  	RefreshStyleData();
2735  	AutoSurface surface(this);
2736  	const Sci::Position posRet = view.StartEndDisplayLine(surface, *this, pos, start, vs);
2737  	if (posRet == Sci::invalidPosition) {
2738  		return pos;
2739  	} else {
2740  		return posRet;
2741  	}
2742  }
2743  namespace {
2744  constexpr short HighShortFromWParam(uptr_t x) {
2745  	return static_cast&lt;short&gt;(x &gt;&gt; 16);
2746  }
2747  constexpr short LowShortFromWParam(uptr_t x) {
2748  	return static_cast&lt;short&gt;(x &amp; 0xffff);
2749  }
2750  constexpr Message WithExtends(Message iMessage) noexcept {
2751  	switch (iMessage) {
2752  	case Message::CharLeft: return Message::CharLeftExtend;
2753  	case Message::CharRight: return Message::CharRightExtend;
2754  	case Message::WordLeft: return Message::WordLeftExtend;
2755  	case Message::WordRight: return Message::WordRightExtend;
2756  	case Message::WordLeftEnd: return Message::WordLeftEndExtend;
2757  	case Message::WordRightEnd: return Message::WordRightEndExtend;
2758  	case Message::WordPartLeft: return Message::WordPartLeftExtend;
2759  	case Message::WordPartRight: return Message::WordPartRightExtend;
2760  	case Message::Home: return Message::HomeExtend;
2761  	case Message::HomeDisplay: return Message::HomeDisplayExtend;
2762  	case Message::HomeWrap: return Message::HomeWrapExtend;
2763  	case Message::VCHome: return Message::VCHomeExtend;
2764  	case Message::VCHomeDisplay: return Message::VCHomeDisplayExtend;
2765  	case Message::VCHomeWrap: return Message::VCHomeWrapExtend;
2766  	case Message::LineEnd: return Message::LineEndExtend;
2767  	case Message::LineEndDisplay: return Message::LineEndDisplayExtend;
2768  	case Message::LineEndWrap: return Message::LineEndWrapExtend;
2769  	default:	return iMessage;
2770  	}
2771  }
2772  constexpr int NaturalDirection(Message iMessage) noexcept {
2773  	switch (iMessage) {
2774  	case Message::CharLeft:
2775  	case Message::CharLeftExtend:
2776  	case Message::CharLeftRectExtend:
2777  	case Message::WordLeft:
2778  	case Message::WordLeftExtend:
2779  	case Message::WordLeftEnd:
2780  	case Message::WordLeftEndExtend:
2781  	case Message::WordPartLeft:
2782  	case Message::WordPartLeftExtend:
2783  	case Message::Home:
2784  	case Message::HomeExtend:
2785  	case Message::HomeDisplay:
2786  	case Message::HomeDisplayExtend:
2787  	case Message::HomeWrap:
2788  	case Message::HomeWrapExtend:
2789  	case Message::VCHome:
2790  	case Message::VCHomeExtend:
2791  	case Message::VCHomeDisplay:
2792  	case Message::VCHomeDisplayExtend:
2793  	case Message::VCHomeWrap:
2794  	case Message::VCHomeWrapExtend:
2795  		return -1;
2796  	default:
2797  		return 1;
2798  	}
2799  }
2800  constexpr bool IsRectExtend(Message iMessage, bool isRectMoveExtends) noexcept {
2801  	switch (iMessage) {
2802  	case Message::CharLeftRectExtend:
2803  	case Message::CharRightRectExtend:
2804  	case Message::HomeRectExtend:
2805  	case Message::VCHomeRectExtend:
2806  	case Message::LineEndRectExtend:
2807  		return true;
2808  	default:
2809  		if (isRectMoveExtends) {
2810  			switch (iMessage) {
2811  			case Message::CharLeftExtend:
2812  			case Message::CharRightExtend:
2813  			case Message::HomeExtend:
2814  			case Message::VCHomeExtend:
2815  			case Message::LineEndExtend:
2816  				return true;
2817  			default:
2818  				return false;
2819  			}
2820  		}
2821  		return false;
2822  	}
2823  }
2824  }
2825  Sci::Position Editor::VCHomeDisplayPosition(Sci::Position position) {
2826  	const Sci::Position homePos = pdoc-&gt;VCHomePosition(position);
2827  	const Sci::Position viewLineStart = StartEndDisplayLine(position, true);
2828  	if (viewLineStart &gt; homePos)
2829  		return viewLineStart;
2830  	else
2831  		return homePos;
2832  }
2833  Sci::Position Editor::VCHomeWrapPosition(Sci::Position position) {
2834  	const Sci::Position homePos = pdoc-&gt;VCHomePosition(position);
2835  	const Sci::Position viewLineStart = StartEndDisplayLine(position, true);
2836  	if ((viewLineStart &lt; position) &amp;&amp; (viewLineStart &gt; homePos))
2837  		return viewLineStart;
2838  	else
2839  		return homePos;
2840  }
2841  Sci::Position Editor::LineEndWrapPosition(Sci::Position position) {
2842  	const Sci::Position endPos = StartEndDisplayLine(position, false);
2843  	const Sci::Position realEndPos = pdoc-&gt;LineEndPosition(position);
2844  	if (endPos &gt; realEndPos      
2845  		|| position &gt;= endPos) 
2846  		return realEndPos;
2847  	else
2848  		return endPos;
2849  }
2850  int Editor::HorizontalMove(Message iMessage) {
2851  	if (sel.selType == Selection::SelTypes::lines) {
2852  		return 0; 
2853  	}
2854  	if (sel.MoveExtends()) {
2855  		iMessage = WithExtends(iMessage);
2856  	}
2857  	if (!multipleSelection &amp;&amp; !sel.IsRectangular()) {
2858  		sel.SetSelection(sel.RangeMain());
2859  	}
2860  	InvalidateWholeSelection();
2861  	if (IsRectExtend(iMessage, sel.IsRectangular() &amp;&amp; sel.MoveExtends())) {
2862  		const SelectionRange rangeBase = sel.IsRectangular() ? sel.Rectangular() : sel.RangeMain();
2863  		if (!sel.IsRectangular()) {
2864  			sel.DropAdditionalRanges();
2865  		}
2866  		SelectionPosition spCaret = rangeBase.caret;
2867  		switch (iMessage) {
2868  		case Message::CharLeftRectExtend:
2869  		case Message::CharLeftExtend: 
2870  			if (pdoc-&gt;IsLineEndPosition(spCaret.Position()) &amp;&amp; spCaret.VirtualSpace()) {
2871  				spCaret.SetVirtualSpace(spCaret.VirtualSpace() - 1);
2872  			} else if (!FlagSet(virtualSpaceOptions, VirtualSpace::NoWrapLineStart) || pdoc-&gt;GetColumn(spCaret.Position()) &gt; 0) {
2873  				spCaret = SelectionPosition(spCaret.Position() - 1);
2874  			}
2875  			break;
2876  		case Message::CharRightRectExtend:
2877  		case Message::CharRightExtend: 
2878  			if (FlagSet(virtualSpaceOptions, VirtualSpace::RectangularSelection) &amp;&amp; pdoc-&gt;IsLineEndPosition(sel.MainCaret())) {
2879  				spCaret.SetVirtualSpace(spCaret.VirtualSpace() + 1);
2880  			} else {
2881  				spCaret = SelectionPosition(spCaret.Position() + 1);
2882  			}
2883  			break;
2884  		case Message::HomeRectExtend:
2885  		case Message::HomeExtend: 
2886  			spCaret = SelectionPosition(
2887  				pdoc-&gt;LineStart(pdoc-&gt;LineFromPosition(spCaret.Position())));
2888  			break;
2889  		case Message::VCHomeRectExtend:
2890  		case Message::VCHomeExtend: 
2891  			spCaret = SelectionPosition(pdoc-&gt;VCHomePosition(spCaret.Position()));
2892  			break;
2893  		case Message::LineEndRectExtend:
2894  		case Message::LineEndExtend: 
2895  			spCaret = SelectionPosition(pdoc-&gt;LineEndPosition(spCaret.Position()));
2896  			break;
2897  		default:
2898  			break;
2899  		}
2900  		const int directionMove = (spCaret &lt; rangeBase.caret) ? -1 : 1;
2901  		spCaret = MovePositionSoVisible(spCaret, directionMove);
2902  		sel.selType = Selection::SelTypes::rectangle;
2903  		sel.Rectangular() = SelectionRange(spCaret, rangeBase.anchor);
2904  		SetRectangularRange();
2905  	} else if (sel.IsRectangular()) {
2906  		SelectionPosition selAtLimit = (NaturalDirection(iMessage) &gt; 0) ? sel.Limits().end : sel.Limits().start;
2907  		switch (iMessage) {
2908  		case Message::Home:
2909  			selAtLimit = SelectionPosition(
2910  				pdoc-&gt;LineStart(pdoc-&gt;LineFromPosition(selAtLimit.Position())));
2911  			break;
2912  		case Message::VCHome:
2913  			selAtLimit = SelectionPosition(pdoc-&gt;VCHomePosition(selAtLimit.Position()));
2914  			break;
2915  		case Message::LineEnd:
2916  			selAtLimit = SelectionPosition(pdoc-&gt;LineEndPosition(selAtLimit.Position()));
2917  			break;
2918  		default:
2919  			break;
2920  		}
2921  		sel.selType = Selection::SelTypes::stream;
2922  		sel.SetSelection(SelectionRange(selAtLimit));
2923  	} else {
2924  		if (!additionalSelectionTyping) {
2925  			InvalidateWholeSelection();
2926  			sel.DropAdditionalRanges();
2927  		}
2928  		for (size_t r = 0; r &lt; sel.Count(); r++) {
2929  			const SelectionPosition spCaretNow = sel.Range(r).caret;
2930  			SelectionPosition spCaret = spCaretNow;
2931  			switch (iMessage) {
2932  			case Message::CharLeft:
2933  			case Message::CharLeftExtend:
2934  				if (spCaret.VirtualSpace()) {
2935  					spCaret.SetVirtualSpace(spCaret.VirtualSpace() - 1);
2936  				} else if (!FlagSet(virtualSpaceOptions, VirtualSpace::NoWrapLineStart) || pdoc-&gt;GetColumn(spCaret.Position()) &gt; 0) {
2937  					spCaret = SelectionPosition(spCaret.Position() - 1);
2938  				}
2939  				break;
2940  			case Message::CharRight:
2941  			case Message::CharRightExtend:
2942  				if (FlagSet(virtualSpaceOptions, VirtualSpace::UserAccessible) &amp;&amp; pdoc-&gt;IsLineEndPosition(spCaret.Position())) {
2943  					spCaret.SetVirtualSpace(spCaret.VirtualSpace() + 1);
2944  				} else {
2945  					spCaret = SelectionPosition(spCaret.Position() + 1);
2946  				}
2947  				break;
2948  			case Message::WordLeft:
2949  			case Message::WordLeftExtend:
2950  				spCaret = SelectionPosition(pdoc-&gt;NextWordStart(spCaret.Position(), -1));
2951  				break;
2952  			case Message::WordRight:
2953  			case Message::WordRightExtend:
2954  				spCaret = SelectionPosition(pdoc-&gt;NextWordStart(spCaret.Position(), 1));
2955  				break;
2956  			case Message::WordLeftEnd:
2957  			case Message::WordLeftEndExtend:
2958  				spCaret = SelectionPosition(pdoc-&gt;NextWordEnd(spCaret.Position(), -1));
2959  				break;
2960  			case Message::WordRightEnd:
2961  			case Message::WordRightEndExtend:
2962  				spCaret = SelectionPosition(pdoc-&gt;NextWordEnd(spCaret.Position(), 1));
2963  				break;
2964  			case Message::WordPartLeft:
2965  			case Message::WordPartLeftExtend:
2966  				spCaret = SelectionPosition(pdoc-&gt;WordPartLeft(spCaret.Position()));
2967  				break;
2968  			case Message::WordPartRight:
2969  			case Message::WordPartRightExtend:
2970  				spCaret = SelectionPosition(pdoc-&gt;WordPartRight(spCaret.Position()));
2971  				break;
2972  			case Message::Home:
2973  			case Message::HomeExtend:
2974  				spCaret = SelectionPosition(
2975  					pdoc-&gt;LineStart(pdoc-&gt;LineFromPosition(spCaret.Position())));
2976  				break;
2977  			case Message::HomeDisplay:
2978  			case Message::HomeDisplayExtend:
2979  				spCaret = SelectionPosition(StartEndDisplayLine(spCaret.Position(), true));
2980  				break;
2981  			case Message::HomeWrap:
2982  			case Message::HomeWrapExtend:
2983  				spCaret = MovePositionSoVisible(StartEndDisplayLine(spCaret.Position(), true), -1);
2984  				if (spCaretNow &lt;= spCaret)
2985  					spCaret = SelectionPosition(
2986  						pdoc-&gt;LineStart(pdoc-&gt;LineFromPosition(spCaret.Position())));
2987  				break;
2988  			case Message::VCHome:
2989  			case Message::VCHomeExtend:
2990  				spCaret = SelectionPosition(pdoc-&gt;VCHomePosition(spCaret.Position()));
2991  				break;
2992  			case Message::VCHomeDisplay:
2993  			case Message::VCHomeDisplayExtend:
2994  				spCaret = SelectionPosition(VCHomeDisplayPosition(spCaret.Position()));
2995  				break;
2996  			case Message::VCHomeWrap:
2997  			case Message::VCHomeWrapExtend:
2998  				spCaret = SelectionPosition(VCHomeWrapPosition(spCaret.Position()));
2999  				break;
3000  			case Message::LineEnd:
3001  			case Message::LineEndExtend:
3002  				spCaret = SelectionPosition(pdoc-&gt;LineEndPosition(spCaret.Position()));
3003  				break;
3004  			case Message::LineEndDisplay:
3005  			case Message::LineEndDisplayExtend:
3006  				spCaret = SelectionPosition(StartEndDisplayLine(spCaret.Position(), false));
3007  				break;
3008  			case Message::LineEndWrap:
3009  			case Message::LineEndWrapExtend:
3010  				spCaret = SelectionPosition(LineEndWrapPosition(spCaret.Position()));
3011  				break;
3012  			default:
3013  				PLATFORM_ASSERT(false);
3014  			}
3015  			const int directionMove = (spCaret &lt; spCaretNow) ? -1 : 1;
3016  			spCaret = MovePositionSoVisible(spCaret, directionMove);
3017  			switch (iMessage) {
3018  			case Message::CharLeft:
3019  			case Message::CharRight:
3020  				if (sel.Range(r).Empty()) {
3021  					sel.Range(r) = SelectionRange(spCaret);
3022  				} else {
3023  					sel.Range(r) = SelectionRange(
3024  						(iMessage == Message::CharLeft) ? sel.Range(r).Start() : sel.Range(r).End());
3025  				}
3026  				break;
3027  			case Message::WordLeft:
3028  			case Message::WordRight:
3029  			case Message::WordLeftEnd:
3030  			case Message::WordRightEnd:
3031  			case Message::WordPartLeft:
3032  			case Message::WordPartRight:
3033  			case Message::Home:
3034  			case Message::HomeDisplay:
3035  			case Message::HomeWrap:
3036  			case Message::VCHome:
3037  			case Message::VCHomeDisplay:
3038  			case Message::VCHomeWrap:
3039  			case Message::LineEnd:
3040  			case Message::LineEndDisplay:
3041  			case Message::LineEndWrap:
3042  				sel.Range(r) = SelectionRange(spCaret);
3043  				break;
3044  			case Message::CharLeftExtend:
3045  			case Message::CharRightExtend:
3046  			case Message::WordLeftExtend:
3047  			case Message::WordRightExtend:
3048  			case Message::WordLeftEndExtend:
3049  			case Message::WordRightEndExtend:
3050  			case Message::WordPartLeftExtend:
3051  			case Message::WordPartRightExtend:
3052  			case Message::HomeExtend:
3053  			case Message::HomeDisplayExtend:
3054  			case Message::HomeWrapExtend:
3055  			case Message::VCHomeExtend:
3056  			case Message::VCHomeDisplayExtend:
3057  			case Message::VCHomeWrapExtend:
3058  			case Message::LineEndExtend:
3059  			case Message::LineEndDisplayExtend:
3060  			case Message::LineEndWrapExtend: {
3061  				SelectionRange rangeNew = SelectionRange(spCaret, sel.Range(r).anchor);
3062  				sel.TrimOtherSelections(r, SelectionRange(rangeNew));
3063  				sel.Range(r) = rangeNew;
3064  				}
3065  				break;
3066  			default:
3067  				PLATFORM_ASSERT(false);
3068  			}
3069  		}
3070  	}
3071  	sel.RemoveDuplicates();
3072  	MovedCaret(sel.RangeMain().caret, SelectionPosition(Sci::invalidPosition), true, caretPolicies);
3073  	InvalidateWholeSelection();
3074  	SetLastXChosen();
3075  	return 0;
3076  }
3077  int Editor::DelWordOrLine(Message iMessage) {
3078  	const bool leftwards = (iMessage == Message::DelWordLeft) || (iMessage == Message::DelLineLeft);
3079  	if (!additionalSelectionTyping) {
3080  		InvalidateWholeSelection();
3081  		sel.DropAdditionalRanges();
3082  	}
3083  	UndoGroup ug0(pdoc, (sel.Count() &gt; 1) || !leftwards);
3084  	for (size_t r = 0; r &lt; sel.Count(); r++) {
3085  		if (leftwards) {
3086  			sel.Range(r).ClearVirtualSpace();
3087  		} else {
3088  			sel.Range(r) = SelectionRange(
3089  				RealizeVirtualSpace(sel.Range(r).caret));
3090  		}
3091  		Range rangeDelete;
3092  		switch (iMessage) {
3093  		case Message::DelWordLeft:
3094  			rangeDelete = Range(
3095  				pdoc-&gt;NextWordStart(sel.Range(r).caret.Position(), -1),
3096  				sel.Range(r).caret.Position());
3097  			break;
3098  		case Message::DelWordRight:
3099  			rangeDelete = Range(
3100  				sel.Range(r).caret.Position(),
3101  				pdoc-&gt;NextWordStart(sel.Range(r).caret.Position(), 1));
3102  			break;
3103  		case Message::DelWordRightEnd:
3104  			rangeDelete = Range(
3105  				sel.Range(r).caret.Position(),
3106  				pdoc-&gt;NextWordEnd(sel.Range(r).caret.Position(), 1));
3107  			break;
3108  		case Message::DelLineLeft:
3109  			rangeDelete = Range(
3110  				pdoc-&gt;LineStart(pdoc-&gt;LineFromPosition(sel.Range(r).caret.Position())),
3111  				sel.Range(r).caret.Position());
3112  			break;
3113  		case Message::DelLineRight:
3114  			rangeDelete = Range(
3115  				sel.Range(r).caret.Position(),
3116  				pdoc-&gt;LineEnd(pdoc-&gt;LineFromPosition(sel.Range(r).caret.Position())));
3117  			break;
3118  		default:
3119  			break;
3120  		}
3121  		if (!RangeContainsProtected(rangeDelete.start, rangeDelete.end)) {
3122  			pdoc-&gt;DeleteChars(rangeDelete.start, rangeDelete.end - rangeDelete.start);
3123  		}
3124  	}
3125  	sel.RemoveDuplicates();
3126  	MovedCaret(sel.RangeMain().caret, SelectionPosition(Sci::invalidPosition), true, caretPolicies);
3127  	InvalidateWholeSelection();
3128  	SetLastXChosen();
3129  	return 0;
3130  }
3131  int Editor::KeyCommand(Message iMessage) {
3132  	switch (iMessage) {
3133  	case Message::LineDown:
3134  		CursorUpOrDown(1, Selection::SelTypes::none);
3135  		break;
3136  	case Message::LineDownExtend:
3137  		CursorUpOrDown(1, Selection::SelTypes::stream);
3138  		break;
3139  	case Message::LineDownRectExtend:
3140  		CursorUpOrDown(1, Selection::SelTypes::rectangle);
3141  		break;
3142  	case Message::ParaDown:
3143  		ParaUpOrDown(1, Selection::SelTypes::none);
3144  		break;
3145  	case Message::ParaDownExtend:
3146  		ParaUpOrDown(1, Selection::SelTypes::stream);
3147  		break;
3148  	case Message::LineScrollDown:
3149  		ScrollTo(topLine + 1);
3150  		MoveCaretInsideView(false);
3151  		break;
3152  	case Message::LineUp:
3153  		CursorUpOrDown(-1, Selection::SelTypes::none);
3154  		break;
3155  	case Message::LineUpExtend:
3156  		CursorUpOrDown(-1, Selection::SelTypes::stream);
3157  		break;
3158  	case Message::LineUpRectExtend:
3159  		CursorUpOrDown(-1, Selection::SelTypes::rectangle);
3160  		break;
3161  	case Message::ParaUp:
3162  		ParaUpOrDown(-1, Selection::SelTypes::none);
3163  		break;
3164  	case Message::ParaUpExtend:
3165  		ParaUpOrDown(-1, Selection::SelTypes::stream);
3166  		break;
3167  	case Message::LineScrollUp:
3168  		ScrollTo(topLine - 1);
3169  		MoveCaretInsideView(false);
3170  		break;
3171  	case Message::CharLeft:
3172  	case Message::CharLeftExtend:
3173  	case Message::CharLeftRectExtend:
3174  	case Message::CharRight:
3175  	case Message::CharRightExtend:
3176  	case Message::CharRightRectExtend:
3177  	case Message::WordLeft:
3178  	case Message::WordLeftExtend:
3179  	case Message::WordRight:
3180  	case Message::WordRightExtend:
3181  	case Message::WordLeftEnd:
3182  	case Message::WordLeftEndExtend:
3183  	case Message::WordRightEnd:
3184  	case Message::WordRightEndExtend:
3185  	case Message::WordPartLeft:
3186  	case Message::WordPartLeftExtend:
3187  	case Message::WordPartRight:
3188  	case Message::WordPartRightExtend:
3189  	case Message::Home:
3190  	case Message::HomeExtend:
3191  	case Message::HomeRectExtend:
3192  	case Message::HomeDisplay:
3193  	case Message::HomeDisplayExtend:
3194  	case Message::HomeWrap:
3195  	case Message::HomeWrapExtend:
3196  	case Message::VCHome:
3197  	case Message::VCHomeExtend:
3198  	case Message::VCHomeRectExtend:
3199  	case Message::VCHomeDisplay:
3200  	case Message::VCHomeDisplayExtend:
3201  	case Message::VCHomeWrap:
3202  	case Message::VCHomeWrapExtend:
3203  	case Message::LineEnd:
3204  	case Message::LineEndExtend:
3205  	case Message::LineEndRectExtend:
3206  	case Message::LineEndDisplay:
3207  	case Message::LineEndDisplayExtend:
3208  	case Message::LineEndWrap:
3209  	case Message::LineEndWrapExtend:
3210  		return HorizontalMove(iMessage);
3211  	case Message::DocumentStart:
3212  		MovePositionTo(0);
3213  		SetLastXChosen();
3214  		break;
3215  	case Message::DocumentStartExtend:
3216  		MovePositionTo(0, Selection::SelTypes::stream);
3217  		SetLastXChosen();
3218  		break;
3219  	case Message::DocumentEnd:
3220  		MovePositionTo(pdoc-&gt;Length());
3221  		SetLastXChosen();
3222  		break;
3223  	case Message::DocumentEndExtend:
3224  		MovePositionTo(pdoc-&gt;Length(), Selection::SelTypes::stream);
3225  		SetLastXChosen();
3226  		break;
3227  	case Message::StutteredPageUp:
3228  		PageMove(-1, Selection::SelTypes::none, true);
3229  		break;
3230  	case Message::StutteredPageUpExtend:
3231  		PageMove(-1, Selection::SelTypes::stream, true);
3232  		break;
3233  	case Message::StutteredPageDown:
3234  		PageMove(1, Selection::SelTypes::none, true);
3235  		break;
3236  	case Message::StutteredPageDownExtend:
3237  		PageMove(1, Selection::SelTypes::stream, true);
3238  		break;
3239  	case Message::PageUp:
3240  		PageMove(-1);
3241  		break;
3242  	case Message::PageUpExtend:
3243  		PageMove(-1, Selection::SelTypes::stream);
3244  		break;
3245  	case Message::PageUpRectExtend:
3246  		PageMove(-1, Selection::SelTypes::rectangle);
3247  		break;
3248  	case Message::PageDown:
3249  		PageMove(1);
3250  		break;
3251  	case Message::PageDownExtend:
3252  		PageMove(1, Selection::SelTypes::stream);
3253  		break;
3254  	case Message::PageDownRectExtend:
3255  		PageMove(1, Selection::SelTypes::rectangle);
3256  		break;
3257  	case Message::EditToggleOvertype:
3258  		inOverstrike = !inOverstrike;
3259  		ContainerNeedsUpdate(Update::Selection);
3260  		ShowCaretAtCurrentPosition();
3261  		SetIdle(true);
3262  		break;
3263  	case Message::Cancel:            	
3264  		CancelModes();
3265  		if ((sel.Count() &gt; 1) &amp;&amp; !sel.IsRectangular()) {
3266  			InvalidateWholeSelection();
3267  			sel.DropAdditionalRanges();
3268  		}
3269  		break;
3270  	case Message::DeleteBack:
3271  		DelCharBack(true);
3272  		if ((caretSticky == CaretSticky::Off) || (caretSticky == CaretSticky::WhiteSpace)) {
3273  			SetLastXChosen();
3274  		}
3275  		EnsureCaretVisible();
3276  		break;
3277  	case Message::DeleteBackNotLine:
3278  		DelCharBack(false);
3279  		if ((caretSticky == CaretSticky::Off) || (caretSticky == CaretSticky::WhiteSpace)) {
3280  			SetLastXChosen();
3281  		}
3282  		EnsureCaretVisible();
3283  		break;
3284  	case Message::Tab:
3285  		Indent(true);
3286  		if (caretSticky == CaretSticky::Off) {
3287  			SetLastXChosen();
3288  		}
3289  		EnsureCaretVisible();
3290  		ShowCaretAtCurrentPosition();		
3291  		break;
3292  	case Message::BackTab:
3293  		Indent(false);
3294  		if ((caretSticky == CaretSticky::Off) || (caretSticky == CaretSticky::WhiteSpace)) {
3295  			SetLastXChosen();
3296  		}
3297  		EnsureCaretVisible();
3298  		ShowCaretAtCurrentPosition();		
3299  		break;
3300  	case Message::NewLine:
3301  		NewLine();
3302  		break;
3303  	case Message::FormFeed:
3304  		AddChar(&#x27;\f&#x27;);
3305  		break;
3306  	case Message::ZoomIn:
3307  		if (vs.zoomLevel &lt; 20) {
3308  			vs.zoomLevel++;
3309  			InvalidateStyleRedraw();
3310  			NotifyZoom();
3311  		}
3312  		break;
3313  	case Message::ZoomOut:
3314  		if (vs.zoomLevel &gt; -10) {
3315  			vs.zoomLevel--;
3316  			InvalidateStyleRedraw();
3317  			NotifyZoom();
3318  		}
3319  		break;
3320  	case Message::DelWordLeft:
3321  	case Message::DelWordRight:
3322  	case Message::DelWordRightEnd:
3323  	case Message::DelLineLeft:
3324  	case Message::DelLineRight:
3325  		return DelWordOrLine(iMessage);
3326  	case Message::LineCopy: {
3327  			const Sci::Line lineStart = pdoc-&gt;SciLineFromPosition(SelectionStart().Position());
3328  			const Sci::Line lineEnd = pdoc-&gt;SciLineFromPosition(SelectionEnd().Position());
3329  			CopyRangeToClipboard(pdoc-&gt;LineStart(lineStart),
3330  				pdoc-&gt;LineStart(lineEnd + 1));
3331  		}
3332  		break;
3333  	case Message::LineCut: {
3334  			const Sci::Line lineStart = pdoc-&gt;SciLineFromPosition(SelectionStart().Position());
3335  			const Sci::Line lineEnd = pdoc-&gt;SciLineFromPosition(SelectionEnd().Position());
3336  			const Sci::Position start = pdoc-&gt;LineStart(lineStart);
3337  			const Sci::Position end = pdoc-&gt;LineStart(lineEnd + 1);
3338  			SetSelection(start, end);
3339  			Cut();
3340  			SetLastXChosen();
3341  		}
3342  		break;
3343  	case Message::LineDelete: {
3344  			const Sci::Line line = pdoc-&gt;SciLineFromPosition(sel.MainCaret());
3345  			const Sci::Position start = pdoc-&gt;LineStart(line);
3346  			const Sci::Position end = pdoc-&gt;LineStart(line + 1);
3347  			pdoc-&gt;DeleteChars(start, end - start);
3348  		}
3349  		break;
3350  	case Message::LineTranspose:
3351  		LineTranspose();
3352  		break;
3353  	case Message::LineReverse:
3354  		LineReverse();
3355  		break;
3356  	case Message::LineDuplicate:
3357  		Duplicate(true);
3358  		break;
3359  	case Message::SelectionDuplicate:
3360  		Duplicate(false);
3361  		break;
3362  	case Message::LowerCase:
3363  		ChangeCaseOfSelection(CaseMapping::lower);
3364  		break;
3365  	case Message::UpperCase:
3366  		ChangeCaseOfSelection(CaseMapping::upper);
3367  		break;
3368  	case Message::ScrollToStart:
3369  		ScrollTo(0);
3370  		break;
3371  	case Message::ScrollToEnd:
3372  		ScrollTo(MaxScrollPos());
3373  		break;
3374  	default:
3375  		break;
3376  	}
3377  	return 0;
3378  }
3379  int Editor::KeyDefault(Keys, KeyMod) {
3380  	return 0;
3381  }
3382  int Editor::KeyDownWithModifiers(Keys key, KeyMod modifiers, bool *consumed) {
3383  	DwellEnd(false);
3384  	const Message msg = kmap.Find(key, modifiers);
3385  	if (msg != static_cast&lt;Message&gt;(0)) {
3386  		if (consumed)
3387  			*consumed = true;
3388  		return static_cast&lt;int&gt;(WndProc(msg, 0, 0));
3389  	} else {
3390  		if (consumed)
3391  			*consumed = false;
3392  		return KeyDefault(key, modifiers);
3393  	}
3394  }
3395  void Editor::Indent(bool forwards) {
3396  	UndoGroup ug(pdoc);
3397  	for (size_t r=0; r&lt;sel.Count(); r++) {
3398  		const Sci::Line lineOfAnchor =
3399  			pdoc-&gt;SciLineFromPosition(sel.Range(r).anchor.Position());
3400  		Sci::Position caretPosition = sel.Range(r).caret.Position();
3401  		const Sci::Line lineCurrentPos = pdoc-&gt;SciLineFromPosition(caretPosition);
3402  		if (lineOfAnchor == lineCurrentPos) {
3403  			if (forwards) {
3404  				pdoc-&gt;DeleteChars(sel.Range(r).Start().Position(), sel.Range(r).Length());
3405  				caretPosition = sel.Range(r).caret.Position();
3406  				if (pdoc-&gt;GetColumn(caretPosition) &lt;= pdoc-&gt;GetColumn(pdoc-&gt;GetLineIndentPosition(lineCurrentPos)) &amp;&amp;
3407  						pdoc-&gt;tabIndents) {
3408  					const int indentation = pdoc-&gt;GetLineIndentation(lineCurrentPos);
3409  					const int indentationStep = pdoc-&gt;IndentSize();
3410  					const Sci::Position posSelect = pdoc-&gt;SetLineIndentation(
3411  						lineCurrentPos, indentation + indentationStep - indentation % indentationStep);
3412  					sel.Range(r) = SelectionRange(posSelect);
3413  				} else {
3414  					if (pdoc-&gt;useTabs) {
3415  						const Sci::Position lengthInserted = pdoc-&gt;InsertString(caretPosition, &quot;\t&quot;, 1);
3416  						sel.Range(r) = SelectionRange(caretPosition + lengthInserted);
3417  					} else {
3418  						int numSpaces = (pdoc-&gt;tabInChars) -
3419  								(pdoc-&gt;GetColumn(caretPosition) % (pdoc-&gt;tabInChars));
3420  						if (numSpaces &lt; 1)
3421  							numSpaces = pdoc-&gt;tabInChars;
3422  						const std::string spaceText(numSpaces, &#x27; &#x27;);
3423  						const Sci::Position lengthInserted = pdoc-&gt;InsertString(caretPosition, spaceText);
3424  						sel.Range(r) = SelectionRange(caretPosition + lengthInserted);
3425  					}
3426  				}
3427  			} else {
3428  				if (pdoc-&gt;GetColumn(caretPosition) &lt;= pdoc-&gt;GetLineIndentation(lineCurrentPos) &amp;&amp;
3429  						pdoc-&gt;tabIndents) {
3430  					const int indentation = pdoc-&gt;GetLineIndentation(lineCurrentPos);
3431  					const int indentationStep = pdoc-&gt;IndentSize();
3432  					const Sci::Position posSelect = pdoc-&gt;SetLineIndentation(lineCurrentPos, indentation - indentationStep);
3433  					sel.Range(r) = SelectionRange(posSelect);
3434  				} else {
3435  					Sci::Position newColumn = ((pdoc-&gt;GetColumn(caretPosition) - 1) / pdoc-&gt;tabInChars) *
3436  							pdoc-&gt;tabInChars;
3437  					if (newColumn &lt; 0)
3438  						newColumn = 0;
3439  					Sci::Position newPos = caretPosition;
3440  					while (pdoc-&gt;GetColumn(newPos) &gt; newColumn)
3441  						newPos--;
3442  					sel.Range(r) = SelectionRange(newPos);
3443  				}
3444  			}
3445  		} else {	
3446  			const Sci::Position anchorPosOnLine = sel.Range(r).anchor.Position() -
3447  				pdoc-&gt;LineStart(lineOfAnchor);
3448  			const Sci::Position currentPosPosOnLine = caretPosition -
3449  				pdoc-&gt;LineStart(lineCurrentPos);
3450  			const Sci::Line lineTopSel = std::min(lineOfAnchor, lineCurrentPos);
3451  			Sci::Line lineBottomSel = std::max(lineOfAnchor, lineCurrentPos);
3452  			if (pdoc-&gt;LineStart(lineBottomSel) == sel.Range(r).anchor.Position() || pdoc-&gt;LineStart(lineBottomSel) == caretPosition)
3453  				lineBottomSel--;  	
3454  			pdoc-&gt;Indent(forwards, lineBottomSel, lineTopSel);
3455  			if (lineOfAnchor &lt; lineCurrentPos) {
3456  				if (currentPosPosOnLine == 0)
3457  					sel.Range(r) = SelectionRange(pdoc-&gt;LineStart(lineCurrentPos),
3458  						pdoc-&gt;LineStart(lineOfAnchor));
3459  				else
3460  					sel.Range(r) = SelectionRange(pdoc-&gt;LineStart(lineCurrentPos + 1),
3461  						pdoc-&gt;LineStart(lineOfAnchor));
3462  			} else {
3463  				if (anchorPosOnLine == 0)
3464  					sel.Range(r) = SelectionRange(pdoc-&gt;LineStart(lineCurrentPos),
3465  						pdoc-&gt;LineStart(lineOfAnchor));
3466  				else
3467  					sel.Range(r) = SelectionRange(pdoc-&gt;LineStart(lineCurrentPos),
3468  						pdoc-&gt;LineStart(lineOfAnchor + 1));
3469  			}
3470  		}
3471  	}
3472  	ContainerNeedsUpdate(Update::Selection);
3473  }
3474  std::unique_ptr&lt;CaseFolder&gt; Editor::CaseFolderForEncoding() {
3475  	return std::make_unique&lt;CaseFolderTable&gt;();
3476  }
3477  Sci::Position Editor::FindText(
3478      uptr_t wParam,		
3479      sptr_t lParam) {	
3480  	TextToFind *ft = static_cast&lt;TextToFind *&gt;(PtrFromSPtr(lParam));
3481  	Sci::Position lengthFound = strlen(ft-&gt;lpstrText);
3482  	if (!pdoc-&gt;HasCaseFolder())
3483  		pdoc-&gt;SetCaseFolder(CaseFolderForEncoding());
3484  	try {
3485  		const Sci::Position pos = pdoc-&gt;FindText(
3486  			static_cast&lt;Sci::Position&gt;(ft-&gt;chrg.cpMin),
3487  			static_cast&lt;Sci::Position&gt;(ft-&gt;chrg.cpMax),
3488  			ft-&gt;lpstrText,
3489  			static_cast&lt;FindOption&gt;(wParam),
3490  			&amp;lengthFound);
3491  		if (pos != -1) {
3492  			ft-&gt;chrgText.cpMin = static_cast&lt;Sci_PositionCR&gt;(pos);
3493  			ft-&gt;chrgText.cpMax = static_cast&lt;Sci_PositionCR&gt;(pos + lengthFound);
3494  		}
3495  		return pos;
3496  	} catch (RegexError &amp;) {
3497  		errorStatus = Status::RegEx;
3498  		return -1;
3499  	}
3500  }
3501  Sci::Position Editor::FindTextFull(
3502      uptr_t wParam,		
3503      sptr_t lParam) {	
3504  	TextToFindFull *ft = static_cast&lt;TextToFindFull *&gt;(PtrFromSPtr(lParam));
3505  	Sci::Position lengthFound = strlen(ft-&gt;lpstrText);
3506  	if (!pdoc-&gt;HasCaseFolder())
3507  		pdoc-&gt;SetCaseFolder(CaseFolderForEncoding());
3508  	try {
3509  		const Sci::Position pos = pdoc-&gt;FindText(
3510  			ft-&gt;chrg.cpMin,
3511  			ft-&gt;chrg.cpMax,
3512  			ft-&gt;lpstrText,
3513  			static_cast&lt;FindOption&gt;(wParam),
3514  			&amp;lengthFound);
3515  		if (pos != -1) {
3516  			ft-&gt;chrgText.cpMin = pos;
3517  			ft-&gt;chrgText.cpMax = pos + lengthFound;
3518  		}
3519  		return pos;
3520  	} catch (RegexError &amp;) {
3521  		errorStatus = Status::RegEx;
3522  		return -1;
3523  	}
3524  }
3525  void Editor::SearchAnchor() noexcept {
3526  	searchAnchor = SelectionStart().Position();
3527  }
3528  Sci::Position Editor::SearchText(
3529      Message iMessage,		
3530      uptr_t wParam,				
3531      sptr_t lParam) {			
3532  	const char *txt = ConstCharPtrFromSPtr(lParam);
3533  	Sci::Position pos = Sci::invalidPosition;
3534  	Sci::Position lengthFound = strlen(txt);
3535  	if (!pdoc-&gt;HasCaseFolder())
3536  		pdoc-&gt;SetCaseFolder(CaseFolderForEncoding());
3537  	try {
3538  		if (iMessage == Message::SearchNext) {
3539  			pos = pdoc-&gt;FindText(searchAnchor, pdoc-&gt;Length(), txt,
3540  					static_cast&lt;FindOption&gt;(wParam),
3541  					&amp;lengthFound);
3542  		} else {
3543  			pos = pdoc-&gt;FindText(searchAnchor, 0, txt,
3544  					static_cast&lt;FindOption&gt;(wParam),
3545  					&amp;lengthFound);
3546  		}
3547  	} catch (RegexError &amp;) {
3548  		errorStatus = Status::RegEx;
3549  		return Sci::invalidPosition;
3550  	}
3551  	if (pos != Sci::invalidPosition) {
3552  		SetSelection(pos, pos + lengthFound);
3553  	}
3554  	return pos;
3555  }
3556  std::string Editor::CaseMapString(const std::string &amp;s, CaseMapping caseMapping) {
3557  	std::string ret(s);
3558  	for (char &amp;ch : ret) {
3559  		switch (caseMapping) {
3560  			case CaseMapping::upper:
3561  				ch = MakeUpperCase(ch);
3562  				break;
3563  			case CaseMapping::lower:
3564  				ch = MakeLowerCase(ch);
3565  				break;
3566  			default:	
3567  				break;
3568  		}
3569  	}
3570  	return ret;
3571  }
3572  Sci::Position Editor::SearchInTarget(const char *text, Sci::Position length) {
3573  	Sci::Position lengthFound = length;
3574  	if (!pdoc-&gt;HasCaseFolder())
3575  		pdoc-&gt;SetCaseFolder(CaseFolderForEncoding());
3576  	try {
3577  		const Sci::Position pos = pdoc-&gt;FindText(targetRange.start.Position(), targetRange.end.Position(), text,
3578  				searchFlags,
3579  				&amp;lengthFound);
3580  		if (pos != -1) {
3581  			targetRange.start.SetPosition(pos);
3582  			targetRange.end.SetPosition(pos + lengthFound);
3583  		}
3584  		return pos;
3585  	} catch (RegexError &amp;) {
3586  		errorStatus = Status::RegEx;
3587  		return -1;
3588  	}
3589  }
3590  void Editor::GoToLine(Sci::Line lineNo) {
3591  	if (lineNo &gt; pdoc-&gt;LinesTotal())
3592  		lineNo = pdoc-&gt;LinesTotal();
3593  	if (lineNo &lt; 0)
3594  		lineNo = 0;
3595  	SetEmptySelection(pdoc-&gt;LineStart(lineNo));
3596  	ShowCaretAtCurrentPosition();
3597  	EnsureCaretVisible();
3598  }
3599  static bool Close(Point pt1, Point pt2, Point threshold) noexcept {
3600  	const Point ptDifference = pt2 - pt1;
3601  	if (std::abs(ptDifference.x) &gt; threshold.x)
3602  		return false;
3603  	if (std::abs(ptDifference.y) &gt; threshold.y)
3604  		return false;
3605  	return true;
3606  }
3607  std::string Editor::RangeText(Sci::Position start, Sci::Position end) const {
3608  	if (start &lt; end) {
3609  		const Sci::Position len = end - start;
3610  		std::string ret(len, &#x27;\0&#x27;);
3611  		pdoc-&gt;GetCharRange(ret.data(), start, len);
3612  		return ret;
3613  	}
3614  	return std::string();
3615  }
3616  void Editor::CopySelectionRange(SelectionText *ss, bool allowLineCopy) {
3617  	if (sel.Empty()) {
3618  		if (allowLineCopy) {
3619  			const Sci::Line currentLine = pdoc-&gt;SciLineFromPosition(sel.MainCaret());
3620  			const Sci::Position start = pdoc-&gt;LineStart(currentLine);
3621  			const Sci::Position end = pdoc-&gt;LineEnd(currentLine);
3622  			std::string text = RangeText(start, end);
3623  			if (pdoc-&gt;eolMode != EndOfLine::Lf)
3624  				text.push_back(&#x27;\r&#x27;);
3625  			if (pdoc-&gt;eolMode != EndOfLine::Cr)
3626  				text.push_back(&#x27;\n&#x27;);
3627  			ss-&gt;Copy(text, pdoc-&gt;dbcsCodePage,
3628  				vs.styles[StyleDefault].characterSet, false, true);
3629  		}
3630  	} else {
3631  		std::string text;
3632  		std::vector&lt;SelectionRange&gt; rangesInOrder = sel.RangesCopy();
3633  		if (sel.selType == Selection::SelTypes::rectangle)
3634  			std::sort(rangesInOrder.begin(), rangesInOrder.end());
3635  		for (const SelectionRange &amp;current : rangesInOrder) {
3636  				text.append(RangeText(current.Start().Position(), current.End().Position()));
3637  			if (sel.selType == Selection::SelTypes::rectangle) {
3638  				if (pdoc-&gt;eolMode != EndOfLine::Lf)
3639  					text.push_back(&#x27;\r&#x27;);
3640  				if (pdoc-&gt;eolMode != EndOfLine::Cr)
3641  					text.push_back(&#x27;\n&#x27;);
3642  			}
3643  		}
3644  		ss-&gt;Copy(text, pdoc-&gt;dbcsCodePage,
3645  			vs.styles[StyleDefault].characterSet, sel.IsRectangular(), sel.selType == Selection::SelTypes::lines);
3646  	}
3647  }
3648  void Editor::CopyRangeToClipboard(Sci::Position start, Sci::Position end) {
3649  	start = pdoc-&gt;ClampPositionIntoDocument(start);
3650  	end = pdoc-&gt;ClampPositionIntoDocument(end);
3651  	SelectionText selectedText;
3652  	std::string text = RangeText(start, end);
3653  	selectedText.Copy(text,
3654  		pdoc-&gt;dbcsCodePage, vs.styles[StyleDefault].characterSet, false, false);
3655  	CopyToClipboard(selectedText);
3656  }
3657  void Editor::CopyText(size_t length, const char *text) {
3658  	SelectionText selectedText;
3659  	selectedText.Copy(std::string(text, length),
3660  		pdoc-&gt;dbcsCodePage, vs.styles[StyleDefault].characterSet, false, false);
3661  	CopyToClipboard(selectedText);
3662  }
3663  void Editor::SetDragPosition(SelectionPosition newPos) {
3664  	if (newPos.Position() &gt;= 0) {
3665  		newPos = MovePositionOutsideChar(newPos, 1);
3666  		posDrop = newPos;
3667  	}
3668  	if (!(posDrag == newPos)) {
3669  		const CaretPolicies dragCaretPolicies = {
3670  			CaretPolicySlop(CaretPolicy::Slop | CaretPolicy::Strict | CaretPolicy::Even, 50),
3671  			CaretPolicySlop(CaretPolicy::Slop | CaretPolicy::Strict | CaretPolicy::Even, 2)
3672  		};
3673  		MovedCaret(newPos, posDrag, true, dragCaretPolicies);
3674  		caret.on = true;
3675  		FineTickerCancel(TickReason::caret);
3676  		if ((caret.active) &amp;&amp; (caret.period &gt; 0) &amp;&amp; (newPos.Position() &lt; 0))
3677  			FineTickerStart(TickReason::caret, caret.period, caret.period/10);
3678  		InvalidateCaret();
3679  		posDrag = newPos;
3680  		InvalidateCaret();
3681  	}
3682  }
3683  void Editor::DisplayCursor(Window::Cursor c) {
3684  	if (cursorMode == CursorShape::Normal)
3685  		wMain.SetCursor(c);
3686  	else
3687  		wMain.SetCursor(static_cast&lt;Window::Cursor&gt;(cursorMode));
3688  }
3689  bool Editor::DragThreshold(Point ptStart, Point ptNow) {
3690  	const Point ptDiff = ptStart - ptNow;
3691  	const XYPOSITION distanceSquared = ptDiff.x * ptDiff.x + ptDiff.y * ptDiff.y;
3692  	return distanceSquared &gt; 16.0f;
3693  }
3694  void Editor::StartDrag() {
3695  }
3696  void Editor::DropAt(SelectionPosition position, const char *value, size_t lengthValue, bool moving, bool rectangular) {
3697  	if (inDragDrop == DragDrop::dragging)
3698  		dropWentOutside = false;
3699  	const bool positionWasInSelection = PositionInSelection(position.Position());
3700  	const bool positionOnEdgeOfSelection =
3701  	    (position == SelectionStart()) || (position == SelectionEnd());
3702  	if ((inDragDrop != DragDrop::dragging) || !(positionWasInSelection) ||
3703  	        (positionOnEdgeOfSelection &amp;&amp; !moving)) {
3704  		const SelectionPosition selStart = SelectionStart();
3705  		const SelectionPosition selEnd = SelectionEnd();
3706  		UndoGroup ug(pdoc);
3707  		SelectionPosition positionAfterDeletion = position;
3708  		if ((inDragDrop == DragDrop::dragging) &amp;&amp; moving) {
3709  			if (rectangular || sel.selType == Selection::SelTypes::lines) {
3710  				for (size_t r=0; r&lt;sel.Count(); r++) {
3711  					if (position &gt;= sel.Range(r).Start()) {
3712  						if (position &gt; sel.Range(r).End()) {
3713  							positionAfterDeletion.Add(-sel.Range(r).Length());
3714  						} else {
3715  							positionAfterDeletion.Add(-SelectionRange(position, sel.Range(r).Start()).Length());
3716  						}
3717  					}
3718  				}
3719  			} else {
3720  				if (position &gt; selStart) {
3721  					positionAfterDeletion.Add(-SelectionRange(selEnd, selStart).Length());
3722  				}
3723  			}
3724  			ClearSelection();
3725  		}
3726  		position = positionAfterDeletion;
3727  		std::string convertedText = Document::TransformLineEnds(value, lengthValue, pdoc-&gt;eolMode);
3728  		if (rectangular) {
3729  			PasteRectangular(position, convertedText.c_str(), convertedText.length());
3730  			SetEmptySelection(position);
3731  		} else {
3732  			position = MovePositionOutsideChar(position, sel.MainCaret() - position.Position());
3733  			position = RealizeVirtualSpace(position);
3734  			const Sci::Position lengthInserted = pdoc-&gt;InsertString(
3735  				position.Position(), convertedText);
3736  			if (lengthInserted &gt; 0) {
3737  				SelectionPosition posAfterInsertion = position;
3738  				posAfterInsertion.Add(lengthInserted);
3739  				SetSelection(posAfterInsertion, position);
3740  			}
3741  		}
3742  	} else if (inDragDrop == DragDrop::dragging) {
3743  		SetEmptySelection(position);
3744  	}
3745  }
3746  void Editor::DropAt(SelectionPosition position, const char *value, bool moving, bool rectangular) {
3747  	DropAt(position, value, strlen(value), moving, rectangular);
3748  }
3749  bool Editor::PositionInSelection(Sci::Position pos) {
3750  	pos = MovePositionOutsideChar(pos, sel.MainCaret() - pos);
3751  	for (size_t r=0; r&lt;sel.Count(); r++) {
3752  		if (sel.Range(r).Contains(pos))
3753  			return true;
3754  	}
3755  	return false;
3756  }
3757  bool Editor::PointInSelection(Point pt) {
3758  	const SelectionPosition pos = SPositionFromLocation(pt, false, true);
3759  	const Point ptPos = LocationFromPosition(pos);
3760  	for (size_t r=0; r&lt;sel.Count(); r++) {
3761  		const SelectionRange &amp;range = sel.Range(r);
3762  		if (range.Contains(pos)) {
3763  			bool hit = true;
3764  			if (pos == range.Start()) {
3765  				if (pt.x &lt; ptPos.x) {
3766  					hit = false;
3767  				}
3768  			}
3769  			if (pos == range.End()) {
3770  				if (pt.x &gt; ptPos.x) {
3771  					hit = false;
3772  				}
3773  			}
3774  			if (hit)
3775  				return true;
3776  		}
3777  	}
3778  	return false;
3779  }
3780  bool Editor::PointInSelMargin(Point pt) const {
3781  	if (vs.fixedColumnWidth &gt; 0) {	
3782  		PRectangle rcSelMargin = GetClientRectangle();
3783  		rcSelMargin.right = static_cast&lt;XYPOSITION&gt;(vs.textStart - vs.leftMarginWidth);
3784  		rcSelMargin.left = static_cast&lt;XYPOSITION&gt;(vs.textStart - vs.fixedColumnWidth);
3785  		const Point ptOrigin = GetVisibleOriginInMain();
3786  		rcSelMargin.Move(0, -ptOrigin.y);
3787  		return rcSelMargin.ContainsWholePixel(pt);
3788  	} else {
3789  		return false;
3790  	}
3791  }
3792  Window::Cursor Editor::GetMarginCursor(Point pt) const noexcept {
3793  	int x = 0;
3794  	for (const MarginStyle &amp;m : vs.ms) {
3795  		if ((pt.x &gt;= x) &amp;&amp; (pt.x &lt; x + m.width))
3796  			return static_cast&lt;Window::Cursor&gt;(m.cursor);
3797  		x += m.width;
3798  	}
3799  	return Window::Cursor::reverseArrow;
3800  }
3801  void Editor::TrimAndSetSelection(Sci::Position currentPos_, Sci::Position anchor_) {
3802  	sel.TrimSelection(SelectionRange(currentPos_, anchor_));
3803  	SetSelection(currentPos_, anchor_);
3804  }
3805  void Editor::LineSelection(Sci::Position lineCurrentPos_, Sci::Position lineAnchorPos_, bool wholeLine) {
3806  	Sci::Position selCurrentPos;
3807  	Sci::Position selAnchorPos;
3808  	if (wholeLine) {
3809  		const Sci::Line lineCurrent_ = pdoc-&gt;SciLineFromPosition(lineCurrentPos_);
3810  		const Sci::Line lineAnchor_ = pdoc-&gt;SciLineFromPosition(lineAnchorPos_);
3811  		if (lineAnchorPos_ &lt; lineCurrentPos_) {
3812  			selCurrentPos = pdoc-&gt;LineStart(lineCurrent_ + 1);
3813  			selAnchorPos = pdoc-&gt;LineStart(lineAnchor_);
3814  		} else if (lineAnchorPos_ &gt; lineCurrentPos_) {
3815  			selCurrentPos = pdoc-&gt;LineStart(lineCurrent_);
3816  			selAnchorPos = pdoc-&gt;LineStart(lineAnchor_ + 1);
3817  		} else { 
3818  			selCurrentPos = pdoc-&gt;LineStart(lineAnchor_ + 1);
3819  			selAnchorPos = pdoc-&gt;LineStart(lineAnchor_);
3820  		}
3821  	} else {
3822  		if (lineAnchorPos_ &lt; lineCurrentPos_) {
3823  			selCurrentPos = StartEndDisplayLine(lineCurrentPos_, false) + 1;
3824  			selCurrentPos = pdoc-&gt;MovePositionOutsideChar(selCurrentPos, 1);
3825  			selAnchorPos = StartEndDisplayLine(lineAnchorPos_, true);
3826  		} else if (lineAnchorPos_ &gt; lineCurrentPos_) {
3827  			selCurrentPos = StartEndDisplayLine(lineCurrentPos_, true);
3828  			selAnchorPos = StartEndDisplayLine(lineAnchorPos_, false) + 1;
3829  			selAnchorPos = pdoc-&gt;MovePositionOutsideChar(selAnchorPos, 1);
3830  		} else { 
3831  			selCurrentPos = StartEndDisplayLine(lineAnchorPos_, false) + 1;
3832  			selCurrentPos = pdoc-&gt;MovePositionOutsideChar(selCurrentPos, 1);
3833  			selAnchorPos = StartEndDisplayLine(lineAnchorPos_, true);
3834  		}
3835  	}
3836  	TrimAndSetSelection(selCurrentPos, selAnchorPos);
3837  }
3838  void Editor::WordSelection(Sci::Position pos) {
3839  	if (pos &lt; wordSelectAnchorStartPos) {
3840  		if (!pdoc-&gt;IsLineEndPosition(pos))
3841  			pos = pdoc-&gt;ExtendWordSelect(pdoc-&gt;MovePositionOutsideChar(pos + 1, 1), -1);
3842  		TrimAndSetSelection(pos, wordSelectAnchorEndPos);
3843  	} else if (pos &gt; wordSelectAnchorEndPos) {
3844  		if (pos &gt; pdoc-&gt;LineStart(pdoc-&gt;LineFromPosition(pos)))
3845  			pos = pdoc-&gt;ExtendWordSelect(pdoc-&gt;MovePositionOutsideChar(pos - 1, -1), 1);
3846  		TrimAndSetSelection(pos, wordSelectAnchorStartPos);
3847  	} else {
3848  		if (pos &gt;= originalAnchorPos)
3849  			TrimAndSetSelection(wordSelectAnchorEndPos, wordSelectAnchorStartPos);
3850  		else
3851  			TrimAndSetSelection(wordSelectAnchorStartPos, wordSelectAnchorEndPos);
3852  	}
3853  }
3854  void Editor::DwellEnd(bool mouseMoved) {
3855  	if (mouseMoved)
3856  		ticksToDwell = dwellDelay;
3857  	else
3858  		ticksToDwell = TimeForever;
3859  	if (dwelling &amp;&amp; (dwellDelay &lt; TimeForever)) {
3860  		dwelling = false;
3861  		NotifyDwelling(ptMouseLast, dwelling);
3862  	}
3863  	FineTickerCancel(TickReason::dwell);
3864  }
3865  void Editor::MouseLeave() {
3866  	SetHotSpotRange(nullptr);
3867  	SetHoverIndicatorPosition(Sci::invalidPosition);
3868  	if (!HaveMouseCapture()) {
3869  		ptMouseLast = Point(-1, -1);
3870  		DwellEnd(true);
3871  	}
3872  }
3873  static constexpr bool AllowVirtualSpace(VirtualSpace virtualSpaceOptions, bool rectangular) noexcept {
3874  	return (!rectangular &amp;&amp; (FlagSet(virtualSpaceOptions, VirtualSpace::UserAccessible)))
3875  		|| (rectangular &amp;&amp; (FlagSet(virtualSpaceOptions, VirtualSpace::RectangularSelection)));
3876  }
3877  void Editor::ButtonDownWithModifiers(Point pt, unsigned int curTime, KeyMod modifiers) {
3878  	SetHoverIndicatorPoint(pt);
3879  	ptMouseLast = pt;
3880  	const bool ctrl = FlagSet(modifiers, KeyMod::Ctrl);
3881  	const bool shift = FlagSet(modifiers, KeyMod::Shift);
3882  	const bool alt = FlagSet(modifiers, KeyMod::Alt);
3883  	SelectionPosition newPos = SPositionFromLocation(pt, false, false, AllowVirtualSpace(virtualSpaceOptions, alt));
3884  	newPos = MovePositionOutsideChar(newPos, sel.MainCaret() - newPos.Position());
3885  	SelectionPosition newCharPos = SPositionFromLocation(pt, false, true, false);
3886  	newCharPos = MovePositionOutsideChar(newCharPos, -1);
3887  	inDragDrop = DragDrop::none;
3888  	sel.SetMoveExtends(false);
3889  	if (NotifyMarginClick(pt, modifiers))
3890  		return;
3891  	NotifyIndicatorClick(true, newPos.Position(), modifiers);
3892  	const bool inSelMargin = PointInSelMargin(pt);
3893  	if (ctrl &amp;&amp; inSelMargin) {
3894  		SelectAll();
3895  		lastClickTime = curTime;
3896  		lastClick = pt;
3897  		return;
3898  	}
3899  	if (shift &amp;&amp; !inSelMargin) {
3900  		SetSelection(newPos);
3901  	}
3902  	if ((curTime &lt; (lastClickTime+Platform::DoubleClickTime())) &amp;&amp; Close(pt, lastClick, doubleClickCloseThreshold)) {
3903  		SetMouseCapture(true);
3904  		FineTickerStart(TickReason::scroll, 100, 10);
3905  		if (!ctrl || !multipleSelection || (selectionUnit != TextUnit::character &amp;&amp; selectionUnit != TextUnit::word))
3906  			SetEmptySelection(newPos.Position());
3907  		bool doubleClick = false;
3908  		if (inSelMargin) {
3909  			if (selectionUnit == TextUnit::subLine) {
3910  				selectionUnit = TextUnit::wholeLine;
3911  			} else if (selectionUnit != TextUnit::subLine &amp;&amp; selectionUnit != TextUnit::wholeLine) {
3912  				selectionUnit = (Wrapping() &amp;&amp; (FlagSet(marginOptions, MarginOption::SubLineSelect))) ? TextUnit::subLine : TextUnit::wholeLine;
3913  			}
3914  		} else {
3915  			if (selectionUnit == TextUnit::character) {
3916  				selectionUnit = TextUnit::word;
3917  				doubleClick = true;
3918  			} else if (selectionUnit == TextUnit::word) {
3919  				selectionUnit = TextUnit::wholeLine;
3920  			} else {
3921  				selectionUnit = TextUnit::character;
3922  				originalAnchorPos = sel.MainCaret();
3923  			}
3924  		}
3925  		if (selectionUnit == TextUnit::word) {
3926  			Sci::Position charPos = originalAnchorPos;
3927  			if (sel.MainCaret() == originalAnchorPos) {
3928  				charPos = PositionFromLocation(pt, false, true);
3929  				charPos = MovePositionOutsideChar(charPos, -1);
3930  			}
3931  			Sci::Position startWord;
3932  			Sci::Position endWord;
3933  			if ((sel.MainCaret() &gt;= originalAnchorPos) &amp;&amp; !pdoc-&gt;IsLineEndPosition(charPos)) {
3934  				startWord = pdoc-&gt;ExtendWordSelect(pdoc-&gt;MovePositionOutsideChar(charPos + 1, 1), -1);
3935  				endWord = pdoc-&gt;ExtendWordSelect(charPos, 1);
3936  			} else {
3937  				if (charPos &gt; pdoc-&gt;LineStart(pdoc-&gt;LineFromPosition(charPos))) {
3938  					startWord = pdoc-&gt;ExtendWordSelect(charPos, -1);
3939  					endWord = pdoc-&gt;ExtendWordSelect(startWord, 1);
3940  				} else {
3941  					startWord = charPos;
3942  					endWord = charPos;
3943  				}
3944  			}
3945  			wordSelectAnchorStartPos = startWord;
3946  			wordSelectAnchorEndPos = endWord;
3947  			wordSelectInitialCaretPos = sel.MainCaret();
3948  			WordSelection(wordSelectInitialCaretPos);
3949  		} else if (selectionUnit == TextUnit::subLine || selectionUnit == TextUnit::wholeLine) {
3950  			lineAnchorPos = newPos.Position();
3951  			LineSelection(lineAnchorPos, lineAnchorPos, selectionUnit == TextUnit::wholeLine);
3952  		} else {
3953  			SetEmptySelection(sel.MainCaret());
3954  		}
3955  		if (doubleClick) {
3956  			NotifyDoubleClick(pt, modifiers);
3957  			if (PositionIsHotspot(newCharPos.Position()))
3958  				NotifyHotSpotDoubleClicked(newCharPos.Position(), modifiers);
3959  		}
3960  	} else {	
3961  		if (inSelMargin) {
3962  			if (sel.IsRectangular() || (sel.Count() &gt; 1)) {
3963  				InvalidateWholeSelection();
3964  				sel.Clear();
3965  			}
3966  			sel.selType = Selection::SelTypes::stream;
3967  			if (!shift) {
3968  				lineAnchorPos = newPos.Position();
3969  				selectionUnit = (Wrapping() &amp;&amp; (FlagSet(marginOptions, MarginOption::SubLineSelect))) ? TextUnit::subLine : TextUnit::wholeLine;
3970  				LineSelection(lineAnchorPos, lineAnchorPos, selectionUnit == TextUnit::wholeLine);
3971  			} else {
3972  				if (sel.MainAnchor() &gt; sel.MainCaret())
3973  					lineAnchorPos = sel.MainAnchor() - 1;
3974  				else
3975  					lineAnchorPos = sel.MainAnchor();
3976  				if (sel.Empty() || (selectionUnit != TextUnit::subLine &amp;&amp; selectionUnit != TextUnit::wholeLine))
3977  					selectionUnit = (Wrapping() &amp;&amp; (FlagSet(marginOptions, MarginOption::SubLineSelect))) ? TextUnit::subLine : TextUnit::wholeLine;
3978  				LineSelection(newPos.Position(), lineAnchorPos, selectionUnit == TextUnit::wholeLine);
3979  			}
3980  			SetDragPosition(SelectionPosition(Sci::invalidPosition));
3981  			SetMouseCapture(true);
3982  			FineTickerStart(TickReason::scroll, 100, 10);
3983  		} else {
3984  			if (PointIsHotspot(pt)) {
3985  				NotifyHotSpotClicked(newCharPos.Position(), modifiers);
3986  				hotSpotClickPos = newCharPos.Position();
3987  			}
3988  			if (!shift) {
3989  				if (PointInSelection(pt) &amp;&amp; !SelectionEmpty())
3990  					inDragDrop = DragDrop::initial;
3991  				else
3992  					inDragDrop = DragDrop::none;
3993  			}
3994  			SetMouseCapture(true);
3995  			FineTickerStart(TickReason::scroll, 100, 10);
3996  			if (inDragDrop != DragDrop::initial) {
3997  				SetDragPosition(SelectionPosition(Sci::invalidPosition));
3998  				if (!shift) {
3999  					if (ctrl &amp;&amp; multipleSelection) {
4000  						const SelectionRange range(newPos);
4001  						sel.TentativeSelection(range);
4002  						InvalidateSelection(range, true);
4003  					} else {
4004  						InvalidateSelection(SelectionRange(newPos), true);
4005  						if (sel.Count() &gt; 1)
4006  							Redraw();
4007  						if ((sel.Count() &gt; 1) || (sel.selType != Selection::SelTypes::stream))
4008  							sel.Clear();
4009  						sel.selType = alt ? Selection::SelTypes::rectangle : Selection::SelTypes::stream;
4010  						SetSelection(newPos, newPos);
4011  					}
4012  				}
4013  				SelectionPosition anchorCurrent = newPos;
4014  				if (shift)
4015  					anchorCurrent = sel.IsRectangular() ?
4016  						sel.Rectangular().anchor : sel.RangeMain().anchor;
4017  				sel.selType = alt ? Selection::SelTypes::rectangle : Selection::SelTypes::stream;
4018  				selectionUnit = TextUnit::character;
4019  				originalAnchorPos = sel.MainCaret();
4020  				sel.Rectangular() = SelectionRange(newPos, anchorCurrent);
4021  				SetRectangularRange();
4022  			}
4023  		}
4024  	}
4025  	lastClickTime = curTime;
4026  	lastClick = pt;
4027  	lastXChosen = static_cast&lt;int&gt;(pt.x) + xOffset;
4028  	ShowCaretAtCurrentPosition();
4029  }
4030  void Editor::RightButtonDownWithModifiers(Point pt, unsigned int, KeyMod modifiers) {
4031  	if (NotifyMarginRightClick(pt, modifiers))
4032  		return;
4033  }
4034  bool Editor::PositionIsHotspot(Sci::Position position) const noexcept {
4035  	return vs.styles[pdoc-&gt;StyleIndexAt(position)].hotspot;
4036  }
4037  bool Editor::PointIsHotspot(Point pt) {
4038  	const Sci::Position pos = PositionFromLocation(pt, true, true);
4039  	if (pos == Sci::invalidPosition)
4040  		return false;
4041  	return PositionIsHotspot(pos);
4042  }
4043  void Editor::SetHoverIndicatorPosition(Sci::Position position) {
4044  	const Sci::Position hoverIndicatorPosPrev = hoverIndicatorPos;
4045  	hoverIndicatorPos = Sci::invalidPosition;
4046  	if (!vs.indicatorsDynamic)
4047  		return;
4048  	if (position != Sci::invalidPosition) {
4049  		for (const IDecoration *deco : pdoc-&gt;decorations-&gt;View()) {
4050  			if (vs.indicators[deco-&gt;Indicator()].IsDynamic()) {
4051  				if (pdoc-&gt;decorations-&gt;ValueAt(deco-&gt;Indicator(), position)) {
4052  					hoverIndicatorPos = position;
4053  				}
4054  			}
4055  		}
4056  	}
4057  	if (hoverIndicatorPosPrev != hoverIndicatorPos) {
4058  		Redraw();
4059  	}
4060  }
4061  void Editor::SetHoverIndicatorPoint(Point pt) {
4062  	if (!vs.indicatorsDynamic) {
4063  		SetHoverIndicatorPosition(Sci::invalidPosition);
4064  	} else {
4065  		SetHoverIndicatorPosition(PositionFromLocation(pt, true, true));
4066  	}
4067  }
4068  void Editor::SetHotSpotRange(const Point *pt) {
4069  	if (pt) {
4070  		const Sci::Position pos = PositionFromLocation(*pt, false, true);
4071  		Range hsNew;
4072  		hsNew.start = pdoc-&gt;ExtendStyleRange(pos, -1, hotspotSingleLine);
4073  		hsNew.end = pdoc-&gt;ExtendStyleRange(pos, 1, hotspotSingleLine);
4074  		if (!(hsNew == hotspot)) {
4075  			if (hotspot.Valid()) {
4076  				InvalidateRange(hotspot.start, hotspot.end);
4077  			}
4078  			hotspot = hsNew;
4079  			InvalidateRange(hotspot.start, hotspot.end);
4080  		}
4081  	} else {
4082  		if (hotspot.Valid()) {
4083  			InvalidateRange(hotspot.start, hotspot.end);
4084  		}
4085  		hotspot = Range(Sci::invalidPosition);
4086  	}
4087  }
4088  void Editor::ButtonMoveWithModifiers(Point pt, unsigned int, KeyMod modifiers) {
4089  	if (ptMouseLast != pt) {
4090  		DwellEnd(true);
4091  	}
4092  	SelectionPosition movePos = SPositionFromLocation(pt, false, false,
4093  		AllowVirtualSpace(virtualSpaceOptions, sel.IsRectangular()));
4094  	movePos = MovePositionOutsideChar(movePos, sel.MainCaret() - movePos.Position());
4095  	if (inDragDrop == DragDrop::initial) {
4096  		if (DragThreshold(ptMouseLast, pt)) {
4097  			SetMouseCapture(false);
4098  			FineTickerCancel(TickReason::scroll);
4099  			SetDragPosition(movePos);
4100  			CopySelectionRange(&amp;drag);
4101  			StartDrag();
4102  		}
4103  		return;
4104  	}
4105  	ptMouseLast = pt;
4106  	PRectangle rcClient = GetClientRectangle();
4107  	const Point ptOrigin = GetVisibleOriginInMain();
4108  	rcClient.Move(0, -ptOrigin.y);
4109  	if ((dwellDelay &lt; TimeForever) &amp;&amp; rcClient.Contains(pt)) {
4110  		FineTickerStart(TickReason::dwell, dwellDelay, dwellDelay/10);
4111  	}
4112  	if (HaveMouseCapture()) {
4113  		autoScrollTimer.ticksToWait -= timer.tickSize;
4114  		if (autoScrollTimer.ticksToWait &gt; 0)
4115  			return;
4116  		autoScrollTimer.ticksToWait = autoScrollDelay;
4117  		if (posDrag.IsValid()) {
4118  			SetDragPosition(movePos);
4119  		} else {
4120  			if (selectionUnit == TextUnit::character) {
4121  				if (sel.selType == Selection::SelTypes::stream &amp;&amp; FlagSet(modifiers, KeyMod::Alt) &amp;&amp; mouseSelectionRectangularSwitch) {
4122  					sel.selType = Selection::SelTypes::rectangle;
4123  				}
4124  				if (sel.IsRectangular()) {
4125  					sel.Rectangular() = SelectionRange(movePos, sel.Rectangular().anchor);
4126  					SetSelection(movePos, sel.RangeMain().anchor);
4127  				} else if (sel.Count() &gt; 1) {
4128  					InvalidateSelection(sel.RangeMain(), false);
4129  					const SelectionRange range(movePos, sel.RangeMain().anchor);
4130  					sel.TentativeSelection(range);
4131  					InvalidateSelection(range, true);
4132  				} else {
4133  					SetSelection(movePos, sel.RangeMain().anchor);
4134  				}
4135  			} else if (selectionUnit == TextUnit::word) {
4136  				if (movePos.Position() == wordSelectInitialCaretPos) {  
4137  				} else {
4138  					wordSelectInitialCaretPos = -1;
4139  					WordSelection(movePos.Position());
4140  				}
4141  			} else {
4142  				LineSelection(movePos.Position(), lineAnchorPos, selectionUnit == TextUnit::wholeLine);
4143  			}
4144  		}
4145  		const Sci::Line lineMove = DisplayFromPosition(movePos.Position());
4146  		if (pt.y &gt;= rcClient.bottom) {
4147  			ScrollTo(lineMove - LinesOnScreen() + 1);
4148  			Redraw();
4149  		} else if (pt.y &lt; rcClient.top) {
4150  			ScrollTo(lineMove);
4151  			Redraw();
4152  		}
4153  		EnsureCaretVisible(false, false, true);
4154  		if (hotspot.Valid() &amp;&amp; !PointIsHotspot(pt))
4155  			SetHotSpotRange(nullptr);
4156  		if (hotSpotClickPos != Sci::invalidPosition &amp;&amp; PositionFromLocation(pt, true, true) != hotSpotClickPos) {
4157  			if (inDragDrop == DragDrop::none) {
4158  				DisplayCursor(Window::Cursor::text);
4159  			}
4160  			hotSpotClickPos = Sci::invalidPosition;
4161  		}
4162  	} else {
4163  		if (vs.fixedColumnWidth &gt; 0) {	
4164  			if (PointInSelMargin(pt)) {
4165  				DisplayCursor(GetMarginCursor(pt));
4166  				SetHotSpotRange(nullptr);
4167  				SetHoverIndicatorPosition(Sci::invalidPosition);
4168  				return; 	
4169  			}
4170  		}
4171  		if (PointInSelection(pt) &amp;&amp; !SelectionEmpty()) {
4172  			DisplayCursor(Window::Cursor::arrow);
4173  			SetHoverIndicatorPosition(Sci::invalidPosition);
4174  		} else {
4175  			SetHoverIndicatorPoint(pt);
4176  			if (PointIsHotspot(pt)) {
4177  				DisplayCursor(Window::Cursor::hand);
4178  				SetHotSpotRange(&amp;pt);
4179  			} else {
4180  				if (hoverIndicatorPos != Sci::invalidPosition)
4181  					DisplayCursor(Window::Cursor::hand);
4182  				else
4183  					DisplayCursor(Window::Cursor::text);
4184  				SetHotSpotRange(nullptr);
4185  			}
4186  		}
4187  	}
4188  }
4189  void Editor::ButtonUpWithModifiers(Point pt, unsigned int curTime, KeyMod modifiers) {
4190  	SelectionPosition newPos = SPositionFromLocation(pt, false, false,
4191  		AllowVirtualSpace(virtualSpaceOptions, sel.IsRectangular()));
4192  	if (hoverIndicatorPos != Sci::invalidPosition)
4193  		InvalidateRange(newPos.Position(), newPos.Position() + 1);
4194  	newPos = MovePositionOutsideChar(newPos, sel.MainCaret() - newPos.Position());
4195  	if (inDragDrop == DragDrop::initial) {
4196  		inDragDrop = DragDrop::none;
4197  		SetEmptySelection(newPos);
4198  		selectionUnit = TextUnit::character;
4199  		originalAnchorPos = sel.MainCaret();
4200  	}
4201  	if (hotSpotClickPos != Sci::invalidPosition &amp;&amp; PointIsHotspot(pt)) {
4202  		hotSpotClickPos = Sci::invalidPosition;
4203  		SelectionPosition newCharPos = SPositionFromLocation(pt, false, true, false);
4204  		newCharPos = MovePositionOutsideChar(newCharPos, -1);
4205  		NotifyHotSpotReleaseClick(newCharPos.Position(), modifiers &amp; KeyMod::Ctrl);
4206  	}
4207  	if (HaveMouseCapture()) {
4208  		if (PointInSelMargin(pt)) {
4209  			DisplayCursor(GetMarginCursor(pt));
4210  		} else {
4211  			DisplayCursor(Window::Cursor::text);
4212  			SetHotSpotRange(nullptr);
4213  		}
4214  		ptMouseLast = pt;
4215  		SetMouseCapture(false);
4216  		FineTickerCancel(TickReason::scroll);
4217  		NotifyIndicatorClick(false, newPos.Position(), modifiers);
4218  		if (inDragDrop == DragDrop::dragging) {
4219  			const SelectionPosition selStart = SelectionStart();
4220  			const SelectionPosition selEnd = SelectionEnd();
4221  			if (selStart &lt; selEnd) {
4222  				if (drag.Length()) {
4223  					const Sci::Position length = drag.Length();
4224  					if (FlagSet(modifiers, KeyMod::Ctrl)) {
4225  						const Sci::Position lengthInserted = pdoc-&gt;InsertString(
4226  							newPos.Position(), drag.Data(), length);
4227  						if (lengthInserted &gt; 0) {
4228  							SetSelection(newPos.Position(), newPos.Position() + lengthInserted);
4229  						}
4230  					} else if (newPos &lt; selStart) {
4231  						pdoc-&gt;DeleteChars(selStart.Position(), drag.Length());
4232  						const Sci::Position lengthInserted = pdoc-&gt;InsertString(
4233  							newPos.Position(), drag.Data(), length);
4234  						if (lengthInserted &gt; 0) {
4235  							SetSelection(newPos.Position(), newPos.Position() + lengthInserted);
4236  						}
4237  					} else if (newPos &gt; selEnd) {
4238  						pdoc-&gt;DeleteChars(selStart.Position(), drag.Length());
4239  						newPos.Add(-static_cast&lt;Sci::Position&gt;(drag.Length()));
4240  						const Sci::Position lengthInserted = pdoc-&gt;InsertString(
4241  							newPos.Position(), drag.Data(), length);
4242  						if (lengthInserted &gt; 0) {
4243  							SetSelection(newPos.Position(), newPos.Position() + lengthInserted);
4244  						}
4245  					} else {
4246  						SetEmptySelection(newPos.Position());
4247  					}
4248  					drag.Clear();
4249  				}
4250  				selectionUnit = TextUnit::character;
4251  			}
4252  		} else {
4253  			if (selectionUnit == TextUnit::character) {
4254  				if (sel.Count() &gt; 1) {
4255  					sel.RangeMain() =
4256  						SelectionRange(newPos, sel.Range(sel.Count() - 1).anchor);
4257  					InvalidateWholeSelection();
4258  				} else {
4259  					SetSelection(newPos, sel.RangeMain().anchor);
4260  				}
4261  			}
4262  			sel.CommitTentative();
4263  		}
4264  		SetRectangularRange();
4265  		lastClickTime = curTime;
4266  		lastClick = pt;
4267  		lastXChosen = static_cast&lt;int&gt;(pt.x) + xOffset;
4268  		if (sel.selType == Selection::SelTypes::stream) {
4269  			SetLastXChosen();
4270  		}
4271  		inDragDrop = DragDrop::none;
4272  		EnsureCaretVisible(false);
4273  	}
4274  }
4275  bool Editor::Idle() {
4276  	NotifyUpdateUI();
4277  	bool needWrap = Wrapping() &amp;&amp; wrapPending.NeedsWrap();
4278  	if (needWrap) {
4279  		WrapLines(WrapScope::wsIdle);
4280  		needWrap = wrapPending.NeedsWrap();
4281  	} else if (needIdleStyling) {
4282  		IdleStyle();
4283  	}
4284  	const bool idleDone = !needWrap &amp;&amp; !needIdleStyling; 
4285  	return !idleDone;
4286  }
4287  void Editor::TickFor(TickReason reason) {
4288  	switch (reason) {
4289  		case TickReason::caret:
4290  			caret.on = !caret.on;
4291  			if (caret.active) {
4292  				InvalidateCaret();
4293  			}
4294  			break;
4295  		case TickReason::scroll:
4296  			ButtonMoveWithModifiers(ptMouseLast, 0, KeyMod::Norm);
4297  			break;
4298  		case TickReason::widen:
4299  			SetScrollBars();
4300  			FineTickerCancel(TickReason::widen);
4301  			break;
4302  		case TickReason::dwell:
4303  			if ((!HaveMouseCapture()) &amp;&amp;
4304  				(ptMouseLast.y &gt;= 0)) {
4305  				dwelling = true;
4306  				NotifyDwelling(ptMouseLast, dwelling);
4307  			}
4308  			FineTickerCancel(TickReason::dwell);
4309  			break;
4310  		default:
4311  			break;
4312  	}
4313  }
4314  bool Editor::FineTickerRunning(TickReason) {
4315  	assert(false);
4316  	return false;
4317  }
4318  void Editor::FineTickerStart(TickReason, int, int) {
4319  	assert(false);
4320  }
4321  void Editor::FineTickerCancel(TickReason) {
4322  	assert(false);
4323  }
4324  void Editor::SetFocusState(bool focusState) {
4325  	const bool changing = hasFocus != focusState;
4326  	hasFocus = focusState;
4327  	if (changing) {
4328  		Redraw();
4329  	}
4330  	NotifyFocus(hasFocus);
4331  	if (!hasFocus) {
4332  		CancelModes();
4333  	}
4334  	ShowCaretAtCurrentPosition();
4335  }
4336  void Editor::UpdateBaseElements() {
4337  }
4338  Sci::Position Editor::PositionAfterArea(PRectangle rcArea) const {
4339  	const Sci::Line lineAfter = TopLineOfMain() + static_cast&lt;Sci::Line&gt;(rcArea.bottom - 1) / vs.lineHeight + 1;
4340  	if (lineAfter &lt; pcs-&gt;LinesDisplayed())
4341  		return pdoc-&gt;LineStart(pcs-&gt;DocFromDisplay(lineAfter) + 1);
4342  	else
4343  		return pdoc-&gt;Length();
4344  }
4345  void Editor::StyleToPositionInView(Sci::Position pos) {
4346  	Sci::Position endWindow = PositionAfterArea(GetClientDrawingRectangle());
4347  	if (pos &gt; endWindow)
4348  		pos = endWindow;
4349  	const int styleAtEnd = pdoc-&gt;StyleIndexAt(pos-1);
4350  	pdoc-&gt;EnsureStyledTo(pos);
4351  	if ((endWindow &gt; pos) &amp;&amp; (styleAtEnd != pdoc-&gt;StyleIndexAt(pos-1))) {
4352  		DiscardOverdraw();	
4353  		endWindow = PositionAfterArea(GetClientDrawingRectangle());
4354  		pdoc-&gt;EnsureStyledTo(endWindow);
4355  	}
4356  }
4357  Sci::Position Editor::PositionAfterMaxStyling(Sci::Position posMax, bool scrolling) const {
4358  	if (SynchronousStylingToVisible()) {
4359  		return posMax;
4360  	}
4361  	const double secondsAllowed = scrolling ? 0.005 : 0.02;
4362  	const size_t actionsInAllowedTime = std::clamp&lt;Sci::Line&gt;(
4363  		pdoc-&gt;durationStyleOneByte.ActionsInAllowedTime(secondsAllowed),
4364  		0x200, 0x20000);
4365  	const Sci::Line lineLast = pdoc-&gt;LineFromPositionAfter(pdoc-&gt;SciLineFromPosition(pdoc-&gt;GetEndStyled()), actionsInAllowedTime);
4366  	const Sci::Line stylingMaxLine = std::min(lineLast, pdoc-&gt;LinesTotal());
4367  	return std::min(pdoc-&gt;LineStart(stylingMaxLine), posMax);
4368  }
4369  void Editor::StartIdleStyling(bool truncatedLastStyling) {
4370  	if ((idleStyling == IdleStyling::All) || (idleStyling == IdleStyling::AfterVisible)) {
4371  		if (pdoc-&gt;GetEndStyled() &lt; pdoc-&gt;Length()) {
4372  			needIdleStyling = true;
4373  		}
4374  	} else if (truncatedLastStyling) {
4375  		needIdleStyling = true;
4376  	}
4377  	if (needIdleStyling) {
4378  		SetIdle(true);
4379  	}
4380  }
4381  void Editor::StyleAreaBounded(PRectangle rcArea, bool scrolling) {
4382  	const Sci::Position posAfterArea = PositionAfterArea(rcArea);
4383  	const Sci::Position posAfterMax = PositionAfterMaxStyling(posAfterArea, scrolling);
4384  	if (posAfterMax &lt; posAfterArea) {
4385  		pdoc-&gt;StyleToAdjustingLineDuration(posAfterMax);
4386  	} else {
4387  		StyleToPositionInView(posAfterArea);
4388  	}
4389  	StartIdleStyling(posAfterMax &lt; posAfterArea);
4390  }
4391  void Editor::IdleStyle() {
4392  	const Sci::Position posAfterArea = PositionAfterArea(GetClientRectangle());
4393  	const Sci::Position endGoal = (idleStyling &gt;= IdleStyling::AfterVisible) ?
4394  		pdoc-&gt;Length() : posAfterArea;
4395  	const Sci::Position posAfterMax = PositionAfterMaxStyling(endGoal, false);
4396  	pdoc-&gt;StyleToAdjustingLineDuration(posAfterMax);
4397  	if (pdoc-&gt;GetEndStyled() &gt;= endGoal) {
4398  		needIdleStyling = false;
4399  	}
4400  }
4401  void Editor::IdleWork() {
4402  	if (FlagSet(workNeeded.items, WorkItems::style)) {
4403  		StyleToPositionInView(pdoc-&gt;LineStart(pdoc-&gt;LineFromPosition(workNeeded.upTo) + 2));
4404  	}
4405  	NotifyUpdateUI();
4406  	workNeeded.Reset();
4407  }
4408  void Editor::QueueIdleWork(WorkItems items, Sci::Position upTo) {
4409  	workNeeded.Need(items, upTo);
4410  }
4411  int Editor::SupportsFeature(Supports feature) {
4412  	AutoSurface surface(this);
4413  	return surface-&gt;SupportsFeature(feature);
4414  }
4415  bool Editor::PaintContains(PRectangle rc) {
4416  	if (rc.Empty()) {
4417  		return true;
4418  	} else {
4419  		return rcPaint.Contains(rc);
4420  	}
4421  }
4422  bool Editor::PaintContainsMargin() {
4423  	if (HasMarginWindow()) {
4424  		return false;
4425  	}
4426  	PRectangle rcSelMargin = GetClientRectangle();
4427  	rcSelMargin.right = static_cast&lt;XYPOSITION&gt;(vs.textStart);
4428  	return PaintContains(rcSelMargin);
4429  }
4430  void Editor::CheckForChangeOutsidePaint(Range r) {
4431  	if (paintState == PaintState::painting &amp;&amp; !paintingAllText) {
4432  		if (!r.Valid())
4433  			return;
4434  		PRectangle rcRange = RectangleFromRange(r, 0);
4435  		const PRectangle rcText = GetTextRectangle();
4436  		if (rcRange.top &lt; rcText.top) {
4437  			rcRange.top = rcText.top;
4438  		}
4439  		if (rcRange.bottom &gt; rcText.bottom) {
4440  			rcRange.bottom = rcText.bottom;
4441  		}
4442  		if (!PaintContains(rcRange)) {
4443  			AbandonPaint();
4444  			paintAbandonedByStyling = true;
4445  		}
4446  	}
4447  }
4448  void Editor::SetBraceHighlight(Sci::Position pos0, Sci::Position pos1, int matchStyle) {
4449  	if ((pos0 != braces[0]) || (pos1 != braces[1]) || (matchStyle != bracesMatchStyle)) {
4450  		if ((braces[0] != pos0) || (matchStyle != bracesMatchStyle)) {
4451  			CheckForChangeOutsidePaint(Range(braces[0]));
4452  			CheckForChangeOutsidePaint(Range(pos0));
4453  			braces[0] = pos0;
4454  		}
4455  		if ((braces[1] != pos1) || (matchStyle != bracesMatchStyle)) {
4456  			CheckForChangeOutsidePaint(Range(braces[1]));
4457  			CheckForChangeOutsidePaint(Range(pos1));
4458  			braces[1] = pos1;
4459  		}
4460  		bracesMatchStyle = matchStyle;
4461  		if (paintState == PaintState::notPainting) {
4462  			Redraw();
4463  		}
4464  	}
4465  }
4466  void Editor::SetAnnotationHeights(Sci::Line start, Sci::Line end) {
4467  	if (vs.annotationVisible != AnnotationVisible::Hidden) {
4468  		RefreshStyleData();
4469  		bool changedHeight = false;
4470  		for (Sci::Line line=start; line&lt;end &amp;&amp; line&lt;pdoc-&gt;LinesTotal(); line++) {
4471  			int linesWrapped = 1;
4472  			if (Wrapping()) {
4473  				AutoSurface surface(this);
4474  				std::shared_ptr&lt;LineLayout&gt; ll = view.RetrieveLineLayout(line, *this);
4475  				if (surface &amp;&amp; ll) {
4476  					view.LayoutLine(*this, surface, vs, ll.get(), wrapWidth);
4477  					linesWrapped = ll-&gt;lines;
4478  				}
4479  			}
4480  			if (pcs-&gt;SetHeight(line, pdoc-&gt;AnnotationLines(line) + linesWrapped))
4481  				changedHeight = true;
4482  		}
4483  		if (changedHeight) {
4484  			SetScrollBars();
4485  			SetVerticalScrollPos();
4486  			Redraw();
4487  		}
4488  	}
4489  }
4490  void Editor::SetDocPointer(Document *document) {
4491  	pdoc-&gt;RemoveWatcher(this, nullptr);
4492  	pdoc-&gt;Release();
4493  	if (!document) {
4494  		pdoc = new Document(DocumentOption::Default);
4495  	} else {
4496  		pdoc = document;
4497  	}
4498  	pdoc-&gt;AddRef();
4499  	pcs = ContractionStateCreate(pdoc-&gt;IsLarge());
4500  	sel.Clear();
4501  	targetRange = SelectionSegment();
4502  	braces[0] = Sci::invalidPosition;
4503  	braces[1] = Sci::invalidPosition;
4504  	vs.ReleaseAllExtendedStyles();
4505  	SetRepresentations();
4506  	pcs-&gt;Clear();
4507  	pcs-&gt;InsertLines(0, pdoc-&gt;LinesTotal() - 1);
4508  	SetAnnotationHeights(0, pdoc-&gt;LinesTotal());
4509  	view.llc.Deallocate();
4510  	NeedWrapping();
4511  	hotspot = Range(Sci::invalidPosition);
4512  	hoverIndicatorPos = Sci::invalidPosition;
4513  	view.ClearAllTabstops();
4514  	pdoc-&gt;AddWatcher(this, nullptr);
4515  	SetScrollBars();
4516  	Redraw();
4517  }
4518  void Editor::SetAnnotationVisible(AnnotationVisible visible) {
4519  	if (vs.annotationVisible != visible) {
4520  		const bool changedFromOrToHidden = ((vs.annotationVisible != AnnotationVisible::Hidden) != (visible != AnnotationVisible::Hidden));
4521  		vs.annotationVisible = visible;
4522  		if (changedFromOrToHidden) {
4523  			const int dir = (vs.annotationVisible!= AnnotationVisible::Hidden) ? 1 : -1;
4524  			for (Sci::Line line=0; line&lt;pdoc-&gt;LinesTotal(); line++) {
4525  				const int annotationLines = pdoc-&gt;AnnotationLines(line);
4526  				if (annotationLines &gt; 0) {
4527  					pcs-&gt;SetHeight(line, pcs-&gt;GetHeight(line) + annotationLines * dir);
4528  				}
4529  			}
4530  			SetScrollBars();
4531  		}
4532  		Redraw();
4533  	}
4534  }
4535  void Editor::SetEOLAnnotationVisible(EOLAnnotationVisible visible) {
4536  	if (vs.eolAnnotationVisible != visible) {
4537  		vs.eolAnnotationVisible = visible;
4538  		Redraw();
4539  	}
4540  }
4541  Sci::Line Editor::ExpandLine(Sci::Line line) {
4542  	const Sci::Line lineMaxSubord = pdoc-&gt;GetLastChild(line);
4543  	line++;
4544  	Sci::Line lineStart = line;
4545  	while (line &lt;= lineMaxSubord) {
4546  		const FoldLevel level = pdoc-&gt;GetFoldLevel(line);
4547  		if (LevelIsHeader(level)) {
4548  			pcs-&gt;SetVisible(lineStart, line, true);
4549  			if (pcs-&gt;GetExpanded(line)) {
4550  				line = ExpandLine(line);
4551  			} else {
4552  				line = pdoc-&gt;GetLastChild(line);
4553  			}
4554  			lineStart = line + 1;
4555  		}
4556  		line++;
4557  	}
4558  	if (lineStart &lt;= lineMaxSubord) {
4559  		pcs-&gt;SetVisible(lineStart, lineMaxSubord, true);
4560  	}
4561  	return lineMaxSubord;
4562  }
4563  void Editor::SetFoldExpanded(Sci::Line lineDoc, bool expanded) {
4564  	if (pcs-&gt;SetExpanded(lineDoc, expanded)) {
4565  		RedrawSelMargin();
4566  	}
4567  }
4568  void Editor::FoldLine(Sci::Line line, FoldAction action) {
4569  	if (line &gt;= 0) {
4570  		if (action == FoldAction::Toggle) {
4571  			if (!LevelIsHeader(pdoc-&gt;GetFoldLevel(line))) {
4572  				line = pdoc-&gt;GetFoldParent(line);
4573  				if (line &lt; 0)
4574  					return;
4575  			}
4576  			action = (pcs-&gt;GetExpanded(line)) ? FoldAction::Contract : FoldAction::Expand;
4577  		}
4578  		if (action == FoldAction::Contract) {
4579  			const Sci::Line lineMaxSubord = pdoc-&gt;GetLastChild(line);
4580  			if (lineMaxSubord &gt; line) {
4581  				pcs-&gt;SetExpanded(line, false);
4582  				pcs-&gt;SetVisible(line + 1, lineMaxSubord, false);
4583  				const Sci::Line lineCurrent =
4584  					pdoc-&gt;SciLineFromPosition(sel.MainCaret());
4585  				if (lineCurrent &gt; line &amp;&amp; lineCurrent &lt;= lineMaxSubord) {
4586  					EnsureCaretVisible();
4587  				}
4588  			}
4589  		} else {
4590  			if (!(pcs-&gt;GetVisible(line))) {
4591  				EnsureLineVisible(line, false);
4592  				GoToLine(line);
4593  			}
4594  			pcs-&gt;SetExpanded(line, true);
4595  			ExpandLine(line);
4596  		}
4597  		SetScrollBars();
4598  		Redraw();
4599  	}
4600  }
4601  void Editor::FoldExpand(Sci::Line line, FoldAction action, FoldLevel level) {
4602  	bool expanding = action == FoldAction::Expand;
4603  	if (action == FoldAction::Toggle) {
4604  		expanding = !pcs-&gt;GetExpanded(line);
4605  	}
4606  	pdoc-&gt;GetLastChild(line, LevelNumberPart(level));
4607  	SetFoldExpanded(line, expanding);
4608  	if (expanding &amp;&amp; (pcs-&gt;HiddenLines() == 0))
4609  		return;
4610  	const Sci::Line lineMaxSubord = pdoc-&gt;GetLastChild(line, LevelNumberPart(level));
4611  	line++;
4612  	pcs-&gt;SetVisible(line, lineMaxSubord, expanding);
4613  	while (line &lt;= lineMaxSubord) {
4614  		const FoldLevel levelLine = pdoc-&gt;GetFoldLevel(line);
4615  		if (LevelIsHeader(levelLine)) {
4616  			SetFoldExpanded(line, expanding);
4617  		}
4618  		line++;
4619  	}
4620  	SetScrollBars();
4621  	Redraw();
4622  }
4623  Sci::Line Editor::ContractedFoldNext(Sci::Line lineStart) const {
4624  	for (Sci::Line line = lineStart; line&lt;pdoc-&gt;LinesTotal();) {
4625  		if (!pcs-&gt;GetExpanded(line) &amp;&amp; LevelIsHeader(pdoc-&gt;GetFoldLevel(line)))
4626  			return line;
4627  		line = pcs-&gt;ContractedNext(line+1);
4628  		if (line &lt; 0)
4629  			return -1;
4630  	}
4631  	return -1;
4632  }
4633  void Editor::EnsureLineVisible(Sci::Line lineDoc, bool enforcePolicy) {
4634  	if (lineDoc &gt;= wrapPending.start) {
4635  		if (WrapLines(WrapScope::wsAll)) {
4636  			Redraw();
4637  		}
4638  	}
4639  	if (!pcs-&gt;GetVisible(lineDoc)) {
4640  		Sci::Line lookLine = lineDoc;
4641  		FoldLevel lookLineLevel = pdoc-&gt;GetFoldLevel(lookLine);
4642  		while ((lookLine &gt; 0) &amp;&amp; LevelIsWhitespace(lookLineLevel)) {
4643  			lookLineLevel = pdoc-&gt;GetFoldLevel(--lookLine);
4644  		}
4645  		Sci::Line lineParent = pdoc-&gt;GetFoldParent(lookLine);
4646  		if (lineParent &lt; 0) {
4647  			lineParent = pdoc-&gt;GetFoldParent(lineDoc);
4648  		}
4649  		if (lineParent &gt;= 0) {
4650  			if (lineDoc != lineParent)
4651  				EnsureLineVisible(lineParent, enforcePolicy);
4652  			if (!pcs-&gt;GetExpanded(lineParent)) {
4653  				pcs-&gt;SetExpanded(lineParent, true);
4654  				ExpandLine(lineParent);
4655  			}
4656  		}
4657  		SetScrollBars();
4658  		Redraw();
4659  	}
4660  	if (enforcePolicy) {
4661  		const Sci::Line lineDisplay = pcs-&gt;DisplayFromDoc(lineDoc);
4662  		if (FlagSet(visiblePolicy.policy, VisiblePolicy::Slop)) {
4663  			if ((topLine &gt; lineDisplay) || ((FlagSet(visiblePolicy.policy, VisiblePolicy::Strict)) &amp;&amp; (topLine + visiblePolicy.slop &gt; lineDisplay))) {
4664  				SetTopLine(std::clamp&lt;Sci::Line&gt;(lineDisplay - visiblePolicy.slop, 0, MaxScrollPos()));
4665  				SetVerticalScrollPos();
4666  				Redraw();
4667  			} else if ((lineDisplay &gt; topLine + LinesOnScreen() - 1) ||
4668  			        ((FlagSet(visiblePolicy.policy, VisiblePolicy::Strict)) &amp;&amp; (lineDisplay &gt; topLine + LinesOnScreen() - 1 - visiblePolicy.slop))) {
4669  				SetTopLine(std::clamp&lt;Sci::Line&gt;(lineDisplay - LinesOnScreen() + 1 + visiblePolicy.slop, 0, MaxScrollPos()));
4670  				SetVerticalScrollPos();
4671  				Redraw();
4672  			}
4673  		} else {
4674  			if ((topLine &gt; lineDisplay) || (lineDisplay &gt; topLine + LinesOnScreen() - 1) || (FlagSet(visiblePolicy.policy, VisiblePolicy::Strict))) {
4675  				SetTopLine(std::clamp&lt;Sci::Line&gt;(lineDisplay - LinesOnScreen() / 2 + 1, 0, MaxScrollPos()));
4676  				SetVerticalScrollPos();
4677  				Redraw();
4678  			}
4679  		}
4680  	}
4681  }
4682  void Editor::FoldAll(FoldAction action) {
4683  	const Sci::Line maxLine = pdoc-&gt;LinesTotal();
4684  	const bool contractAll = FlagSet(action, FoldAction::ContractEveryLevel);
4685  	action = static_cast&lt;FoldAction&gt;(static_cast&lt;int&gt;(action) &amp; ~static_cast&lt;int&gt;(FoldAction::ContractEveryLevel));
4686  	bool expanding = action == FoldAction::Expand;
4687  	if (!expanding) {
4688  		pdoc-&gt;EnsureStyledTo(pdoc-&gt;Length());
4689  	}
4690  	Sci::Line line = 0;
4691  	if (action == FoldAction::Toggle) {
4692  		for (; line &lt; maxLine; line++) {
4693  			if (LevelIsHeader(pdoc-&gt;GetFoldLevel(line))) {
4694  				expanding = !pcs-&gt;GetExpanded(line);
4695  				break;
4696  			}
4697  		}
4698  	}
4699  	if (expanding) {
4700  		pcs-&gt;SetVisible(0, maxLine-1, true);
4701  		pcs-&gt;ExpandAll();
4702  	} else {
4703  		for (; line &lt; maxLine; line++) {
4704  			const FoldLevel level = pdoc-&gt;GetFoldLevel(line);
4705  			if (LevelIsHeader(level)) {
4706  				if (FoldLevel::Base == LevelNumberPart(level)) {
4707  					SetFoldExpanded(line, false);
4708  					const Sci::Line lineMaxSubord = pdoc-&gt;GetLastChild(line);
4709  					if (lineMaxSubord &gt; line) {
4710  						pcs-&gt;SetVisible(line + 1, lineMaxSubord, false);
4711  						if (!contractAll) {
4712  							line = lineMaxSubord;
4713  						}
4714  					}
4715  				} else if (contractAll) {
4716  					SetFoldExpanded(line, false);
4717  				}
4718  			}
4719  		}
4720  	}
4721  	SetScrollBars();
4722  	Redraw();
4723  }
4724  void Editor::FoldChanged(Sci::Line line, FoldLevel levelNow, FoldLevel levelPrev) {
4725  	if (LevelIsHeader(levelNow)) {
4726  		if (!LevelIsHeader(levelPrev)) {
4727  			if (pcs-&gt;SetExpanded(line, true)) {
4728  				RedrawSelMargin();
4729  			}
4730  			FoldExpand(line, FoldAction::Expand, levelPrev);
4731  		}
4732  	} else if (LevelIsHeader(levelPrev)) {
4733  		const Sci::Line prevLine = line - 1;
4734  		const FoldLevel prevLineLevel = pdoc-&gt;GetFoldLevel(prevLine);
4735  		if ((LevelNumber(prevLineLevel) == LevelNumber(levelNow)) &amp;&amp; !pcs-&gt;GetVisible(prevLine))
4736  			FoldLine(pdoc-&gt;GetFoldParent(prevLine), FoldAction::Expand);
4737  		if (!pcs-&gt;GetExpanded(line)) {
4738  			if (pcs-&gt;SetExpanded(line, true)) {
4739  				RedrawSelMargin();
4740  			}
4741  			FoldExpand(line, FoldAction::Expand, levelPrev);
4742  		}
4743  	}
4744  	if (!LevelIsWhitespace(levelNow) &amp;&amp;
4745  	        (LevelNumber(levelPrev) &gt; LevelNumber(levelNow))) {
4746  		if (pcs-&gt;HiddenLines()) {
4747  			const Sci::Line parentLine = pdoc-&gt;GetFoldParent(line);
4748  			if ((parentLine &lt; 0) || (pcs-&gt;GetExpanded(parentLine) &amp;&amp; pcs-&gt;GetVisible(parentLine))) {
4749  				pcs-&gt;SetVisible(line, line, true);
4750  				SetScrollBars();
4751  				Redraw();
4752  			}
4753  		}
4754  	}
4755  	if (!LevelIsWhitespace(levelNow) &amp;&amp; (LevelNumber(levelPrev) &lt; LevelNumber(levelNow))) {
4756  		if (pcs-&gt;HiddenLines()) {
4757  			const Sci::Line parentLine = pdoc-&gt;GetFoldParent(line);
4758  			if (!pcs-&gt;GetExpanded(parentLine) &amp;&amp; pcs-&gt;GetVisible(line))
4759  				FoldLine(parentLine, FoldAction::Expand);
4760  		}
4761  	}
4762  }
4763  void Editor::NeedShown(Sci::Position pos, Sci::Position len) {
4764  	if (FlagSet(foldAutomatic, AutomaticFold::Show)) {
4765  		const Sci::Line lineStart = pdoc-&gt;SciLineFromPosition(pos);
4766  		const Sci::Line lineEnd = pdoc-&gt;SciLineFromPosition(pos+len);
4767  		for (Sci::Line line = lineStart; line &lt;= lineEnd; line++) {
4768  			EnsureLineVisible(line, false);
4769  		}
4770  	} else {
4771  		NotifyNeedShown(pos, len);
4772  	}
4773  }
4774  Sci::Position Editor::GetTag(char *tagValue, int tagNumber) {
4775  	const char *text = nullptr;
4776  	Sci::Position length = 0;
4777  	if ((tagNumber &gt;= 1) &amp;&amp; (tagNumber &lt;= 9)) {
4778  		char name[3] = &quot;\\?&quot;;
4779  		name[1] = static_cast&lt;char&gt;(tagNumber + &#x27;0&#x27;);
4780  		length = 2;
4781  		text = pdoc-&gt;SubstituteByPosition(name, &amp;length);
4782  	}
4783  	if (tagValue) {
4784  		if (text)
4785  			memcpy(tagValue, text, length + 1);
4786  		else
4787  			*tagValue = &#x27;\0&#x27;;
4788  	}
4789  	return length;
4790  }
4791  Sci::Position Editor::ReplaceTarget(ReplaceType replaceType, std::string_view text) {
4792  	UndoGroup ug(pdoc);
4793  	if (replaceType == ReplaceType::patterns) {
4794  		Sci::Position length = text.length();
4795  		const char *p = pdoc-&gt;SubstituteByPosition(text.data(), &amp;length);
4796  		if (!p) {
4797  			return 0;
4798  		}
4799  		text = std::string_view(p, length);
4800  	}
4801  	if (replaceType == ReplaceType::minimal) {
4802  		Range range(targetRange.start.Position(), targetRange.end.Position());
4803  		pdoc-&gt;TrimReplacement(text, range);
4804  		const SelectionPosition start(range.start == targetRange.start.Position() ?
4805  			targetRange.start : SelectionPosition(range.start));
4806  		targetRange = SelectionSegment(start, SelectionPosition(range.end));
4807  	}
4808  	if (targetRange.Length() &gt; 0)
4809  		pdoc-&gt;DeleteChars(targetRange.start.Position(), targetRange.Length());
4810  	targetRange.end = targetRange.start;
4811  	const Sci::Position startAfterSpaceInsertion = RealizeVirtualSpace(targetRange.start.Position(), targetRange.start.VirtualSpace());
4812  	targetRange.start.SetPosition(startAfterSpaceInsertion);
4813  	targetRange.end = targetRange.start;
4814  	const Sci::Position lengthInserted = pdoc-&gt;InsertString(targetRange.start.Position(), text);
4815  	targetRange.end.SetPosition(targetRange.start.Position() + lengthInserted);
4816  	return text.length();
4817  }
4818  bool Editor::IsUnicodeMode() const noexcept {
4819  	return pdoc &amp;&amp; (CpUtf8 == pdoc-&gt;dbcsCodePage);
4820  }
4821  int Editor::CodePage() const noexcept {
4822  	if (pdoc)
4823  		return pdoc-&gt;dbcsCodePage;
4824  	else
4825  		return 0;
4826  }
4827  std::unique_ptr&lt;Surface&gt; Editor::CreateMeasurementSurface() const {
4828  	if (!wMain.GetID()) {
4829  		return {};
4830  	}
4831  	std::unique_ptr&lt;Surface&gt; surf = Surface::Allocate(technology);
4832  	surf-&gt;Init(wMain.GetID());
4833  	surf-&gt;SetMode(CurrentSurfaceMode());
4834  	return surf;
4835  }
4836  std::unique_ptr&lt;Surface&gt; Editor::CreateDrawingSurface(SurfaceID sid, std::optional&lt;Scintilla::Technology&gt; technologyOpt) const {
4837  	if (!wMain.GetID()) {
4838  		return {};
4839  	}
4840  	std::unique_ptr&lt;Surface&gt; surf = Surface::Allocate(technologyOpt ? *technologyOpt : technology);
4841  	surf-&gt;Init(sid, wMain.GetID());
4842  	surf-&gt;SetMode(CurrentSurfaceMode());
4843  	return surf;
4844  }
4845  Sci::Line Editor::WrapCount(Sci::Line line) {
4846  	AutoSurface surface(this);
4847  	std::shared_ptr&lt;LineLayout&gt; ll = view.RetrieveLineLayout(line, *this);
4848  	if (surface &amp;&amp; ll) {
4849  		view.LayoutLine(*this, surface, vs, ll.get(), wrapWidth);
4850  		return ll-&gt;lines;
4851  	} else {
4852  		return 1;
4853  	}
4854  }
4855  void Editor::AddStyledText(const char *buffer, Sci::Position appendLength) {
4856  	const Sci::Position textLength = appendLength / 2;
4857  	std::string text(textLength, &#x27;\0&#x27;);
4858  	for (Sci::Position i = 0; i &lt; textLength; i++) {
4859  		text[i] = buffer[i*2];
4860  	}
4861  	const Sci::Position lengthInserted = pdoc-&gt;InsertString(CurrentPosition(), text);
4862  	for (Sci::Position i = 0; i &lt; textLength; i++) {
4863  		text[i] = buffer[i*2+1];
4864  	}
4865  	pdoc-&gt;StartStyling(CurrentPosition());
4866  	pdoc-&gt;SetStyles(textLength, text.c_str());
4867  	SetEmptySelection(sel.MainCaret() + lengthInserted);
4868  }
4869  Sci::Position Editor::GetStyledText(char *buffer, Sci::Position cpMin, Sci::Position cpMax) const noexcept {
4870  	Sci::Position iPlace = 0;
4871  	for (Sci::Position iChar = cpMin; iChar &lt; cpMax; iChar++) {
4872  		buffer[iPlace++] = pdoc-&gt;CharAt(iChar);
4873  		buffer[iPlace++] = pdoc-&gt;StyleAtNoExcept(iChar);
4874  	}
4875  	buffer[iPlace] = &#x27;\0&#x27;;
4876  	buffer[iPlace + 1] = &#x27;\0&#x27;;
4877  	return iPlace;
4878  }
4879  Sci::Position Editor::GetTextRange(char *buffer, Sci::Position cpMin, Sci::Position cpMax) const {
4880  	const Sci::Position cpEnd = (cpMax == -1) ? pdoc-&gt;Length() : cpMax;
4881  	PLATFORM_ASSERT(cpEnd &lt;= pdoc-&gt;Length());
4882  	const Sci::Position len = cpEnd - cpMin; 	
4883  	pdoc-&gt;GetCharRange(buffer, cpMin, len);
4884  	buffer[len] = &#x27;\0&#x27;;
4885  	return len; 	
4886  }
4887  bool Editor::ValidMargin(uptr_t wParam) const noexcept {
4888  	return wParam &lt; vs.ms.size();
4889  }
4890  void Editor::StyleSetMessage(Message iMessage, uptr_t wParam, sptr_t lParam) {
4891  	vs.EnsureStyle(wParam);
4892  	switch (iMessage) {
4893  	case Message::StyleSetFore:
4894  		vs.styles[wParam].fore = ColourRGBA::FromIpRGB(lParam);
4895  		break;
4896  	case Message::StyleSetBack:
4897  		vs.styles[wParam].back = ColourRGBA::FromIpRGB(lParam);
4898  		break;
4899  	case Message::StyleSetBold:
4900  		vs.styles[wParam].weight = lParam != 0 ? FontWeight::Bold : FontWeight::Normal;
4901  		break;
4902  	case Message::StyleSetWeight:
4903  		vs.styles[wParam].weight = static_cast&lt;FontWeight&gt;(lParam);
4904  		break;
4905  	case Message::StyleSetItalic:
4906  		vs.styles[wParam].italic = lParam != 0;
4907  		break;
4908  	case Message::StyleSetEOLFilled:
4909  		vs.styles[wParam].eolFilled = lParam != 0;
4910  		break;
4911  	case Message::StyleSetSize:
4912  		vs.styles[wParam].size = static_cast&lt;int&gt;(lParam * FontSizeMultiplier);
4913  		break;
4914  	case Message::StyleSetSizeFractional:
4915  		vs.styles[wParam].size = static_cast&lt;int&gt;(lParam);
4916  		break;
4917  	case Message::StyleSetFont:
4918  		if (lParam != 0) {
4919  			vs.SetStyleFontName(static_cast&lt;int&gt;(wParam), ConstCharPtrFromSPtr(lParam));
4920  		}
4921  		break;
4922  	case Message::StyleSetUnderline:
4923  		vs.styles[wParam].underline = lParam != 0;
4924  		break;
4925  	case Message::StyleSetCase:
4926  		vs.styles[wParam].caseForce = static_cast&lt;Style::CaseForce&gt;(lParam);
4927  		break;
4928  	case Message::StyleSetCharacterSet:
4929  		vs.styles[wParam].characterSet = static_cast&lt;CharacterSet&gt;(lParam);
4930  		pdoc-&gt;SetCaseFolder(nullptr);
4931  		break;
4932  	case Message::StyleSetVisible:
4933  		vs.styles[wParam].visible = lParam != 0;
4934  		break;
4935  	case Message::StyleSetInvisibleRepresentation: {
4936  		const char *utf8 = ConstCharPtrFromSPtr(lParam);
4937  		char *rep = vs.styles[wParam].invisibleRepresentation;
4938  		const int classified = UTF8Classify(utf8);
4939  		if (!(classified &amp; UTF8MaskInvalid)) {
4940  			const int len = classified &amp; UTF8MaskWidth;
4941  			for (int i=0; i&lt;len &amp;&amp; i&lt;UTF8MaxBytes; i++)
4942  				*rep++ = *utf8++;
4943  		}
4944  		*rep = 0;
4945  		break;
4946  	}
4947  	case Message::StyleSetChangeable:
4948  		vs.styles[wParam].changeable = lParam != 0;
4949  		break;
4950  	case Message::StyleSetHotSpot:
4951  		vs.styles[wParam].hotspot = lParam != 0;
4952  		break;
4953  	case Message::StyleSetCheckMonospaced:
4954  		vs.styles[wParam].checkMonospaced = lParam != 0;
4955  		break;
4956  	default:
4957  		break;
4958  	}
4959  	InvalidateStyleRedraw();
4960  }
4961  sptr_t Editor::StyleGetMessage(Message iMessage, uptr_t wParam, sptr_t lParam) {
4962  	vs.EnsureStyle(wParam);
4963  	switch (iMessage) {
4964  	case Message::StyleGetFore:
4965  		return vs.styles[wParam].fore.OpaqueRGB();
4966  	case Message::StyleGetBack:
4967  		return vs.styles[wParam].back.OpaqueRGB();
4968  	case Message::StyleGetBold:
4969  		return vs.styles[wParam].weight &gt; FontWeight::Normal;
4970  	case Message::StyleGetWeight:
4971  		return static_cast&lt;sptr_t&gt;(vs.styles[wParam].weight);
4972  	case Message::StyleGetItalic:
4973  		return vs.styles[wParam].italic ? 1 : 0;
4974  	case Message::StyleGetEOLFilled:
4975  		return vs.styles[wParam].eolFilled ? 1 : 0;
4976  	case Message::StyleGetSize:
4977  		return vs.styles[wParam].size / FontSizeMultiplier;
4978  	case Message::StyleGetSizeFractional:
4979  		return vs.styles[wParam].size;
4980  	case Message::StyleGetFont:
4981  		return StringResult(lParam, vs.styles[wParam].fontName);
4982  	case Message::StyleGetUnderline:
4983  		return vs.styles[wParam].underline ? 1 : 0;
4984  	case Message::StyleGetCase:
4985  		return static_cast&lt;int&gt;(vs.styles[wParam].caseForce);
4986  	case Message::StyleGetCharacterSet:
4987  		return static_cast&lt;sptr_t&gt;(vs.styles[wParam].characterSet);
4988  	case Message::StyleGetVisible:
4989  		return vs.styles[wParam].visible ? 1 : 0;
4990  	case Message::StyleGetChangeable:
4991  		return vs.styles[wParam].changeable ? 1 : 0;
4992  	case Message::StyleGetInvisibleRepresentation:
4993  		return StringResult(lParam, vs.styles[wParam].invisibleRepresentation);
4994  	case Message::StyleGetHotSpot:
4995  		return vs.styles[wParam].hotspot ? 1 : 0;
4996  	case Message::StyleGetCheckMonospaced:
4997  		return vs.styles[wParam].checkMonospaced ? 1 : 0;
4998  	default:
4999  		break;
5000  	}
5001  	return 0;
5002  }
5003  void Editor::SetSelectionNMessage(Message iMessage, uptr_t wParam, sptr_t lParam) {
5004  	if (wParam &gt;= sel.Count()) {
5005  		return;
5006  	}
5007  	InvalidateRange(sel.Range(wParam).Start().Position(), sel.Range(wParam).End().Position());
5008  	switch (iMessage) {
5009  	case Message::SetSelectionNCaret:
5010  		sel.Range(wParam).caret.SetPosition(lParam);
5011  		break;
5012  	case Message::SetSelectionNAnchor:
5013  		sel.Range(wParam).anchor.SetPosition(lParam);
5014  		break;
5015  	case Message::SetSelectionNCaretVirtualSpace:
5016  		sel.Range(wParam).caret.SetVirtualSpace(lParam);
5017  		break;
5018  	case Message::SetSelectionNAnchorVirtualSpace:
5019  		sel.Range(wParam).anchor.SetVirtualSpace(lParam);
5020  		break;
5021  	case Message::SetSelectionNStart:
5022  		sel.Range(wParam).anchor.SetPosition(lParam);
5023  		break;
5024  	case Message::SetSelectionNEnd:
5025  		sel.Range(wParam).caret.SetPosition(lParam);
5026  		break;
5027  	default:
5028  		break;
5029  	}
5030  	InvalidateRange(sel.Range(wParam).Start().Position(), sel.Range(wParam).End().Position());
5031  	ContainerNeedsUpdate(Update::Selection);
5032  }
5033  sptr_t Editor::StringResult(sptr_t lParam, const char *val) noexcept {
5034  	const size_t len = val ? strlen(val) : 0;
5035  	if (lParam) {
5036  		char *ptr = CharPtrFromSPtr(lParam);
5037  		if (val)
5038  			memcpy(ptr, val, len+1);
5039  		else
5040  			*ptr = 0;
5041  	}
5042  	return len;	
5043  }
5044  sptr_t Editor::BytesResult(sptr_t lParam, const unsigned char *val, size_t len) noexcept {
5045  	if ((lParam) &amp;&amp; (len &gt; 0)) {
5046  		char *ptr = CharPtrFromSPtr(lParam);
5047  		if (val)
5048  			memcpy(ptr, val, len);
5049  		else
5050  			*ptr = 0;
5051  	}
5052  	return val ? len : 0;
5053  }
5054  sptr_t Editor::WndProc(Message iMessage, uptr_t wParam, sptr_t lParam) {
5055  	if (recordingMacro)
5056  		NotifyMacroRecord(iMessage, wParam, lParam);
5057  	switch (iMessage) {
5058  	case Message::GetText: {
5059  			if (lParam == 0)
5060  				return pdoc-&gt;Length();
5061  			char *ptr = CharPtrFromSPtr(lParam);
5062  			const Sci_Position len = std::min&lt;Sci_Position&gt;(wParam, pdoc-&gt;Length());
5063  			pdoc-&gt;GetCharRange(ptr, 0, len);
5064  			ptr[len] = &#x27;\0&#x27;;
5065  			return len;
5066  		}
5067  	case Message::SetText: {
5068  			if (lParam == 0)
5069  				return 0;
5070  			UndoGroup ug(pdoc);
5071  			pdoc-&gt;DeleteChars(0, pdoc-&gt;Length());
5072  			SetEmptySelection(0);
5073  			const char *text = ConstCharPtrFromSPtr(lParam);
5074  			pdoc-&gt;InsertString(0, text, strlen(text));
5075  			return 1;
5076  		}
5077  	case Message::GetTextLength:
5078  		return pdoc-&gt;Length();
5079  	case Message::Cut:
5080  		Cut();
5081  		SetLastXChosen();
5082  		break;
5083  	case Message::Copy:
5084  		Copy();
5085  		break;
5086  	case Message::CopyAllowLine:
5087  		CopyAllowLine();
5088  		break;
5089  	case Message::VerticalCentreCaret:
5090  		VerticalCentreCaret();
5091  		break;
5092  	case Message::MoveSelectedLinesUp:
5093  		MoveSelectedLinesUp();
5094  		break;
5095  	case Message::MoveSelectedLinesDown:
5096  		MoveSelectedLinesDown();
5097  		break;
5098  	case Message::CopyRange:
5099  		CopyRangeToClipboard(PositionFromUPtr(wParam), lParam);
5100  		break;
5101  	case Message::CopyText:
5102  		CopyText(wParam, ConstCharPtrFromSPtr(lParam));
5103  		break;
5104  	case Message::Paste:
5105  		Paste();
5106  		if ((caretSticky == CaretSticky::Off) || (caretSticky == CaretSticky::WhiteSpace)) {
5107  			SetLastXChosen();
5108  		}
5109  		EnsureCaretVisible();
5110  		break;
5111  	case Message::ReplaceRectangular: {
5112  		UndoGroup ug(pdoc);
5113  		if (!sel.Empty()) {
5114  			ClearSelection(); 
5115  		}
5116  		InsertPasteShape(ConstCharPtrFromSPtr(lParam), PositionFromUPtr(wParam), PasteShape::rectangular);
5117  		break;
5118  	}
5119  	case Message::Clear:
5120  		Clear();
5121  		SetLastXChosen();
5122  		EnsureCaretVisible();
5123  		break;
5124  	case Message::Undo:
5125  		Undo();
5126  		SetLastXChosen();
5127  		break;
5128  	case Message::CanUndo:
5129  		return (pdoc-&gt;CanUndo() &amp;&amp; !pdoc-&gt;IsReadOnly()) ? 1 : 0;
5130  	case Message::EmptyUndoBuffer:
5131  		pdoc-&gt;DeleteUndoHistory();
5132  		return 0;
5133  	case Message::GetFirstVisibleLine:
5134  		return topLine;
5135  	case Message::SetFirstVisibleLine:
5136  		ScrollTo(LineFromUPtr(wParam));
5137  		break;
5138  	case Message::GetLine: {	
5139  			const Sci::Position lineStart =
5140  				pdoc-&gt;LineStart(LineFromUPtr(wParam));
5141  			const Sci::Position lineEnd =
5142  				pdoc-&gt;LineStart(LineFromUPtr(wParam + 1));
5143  			const Sci::Position len = lineEnd - lineStart;
5144  			if (lParam == 0) {
5145  				return len;
5146  			}
5147  			char *ptr = CharPtrFromSPtr(lParam);
5148  			pdoc-&gt;GetCharRange(ptr, lineStart, len);
5149  			return len;
5150  		}
5151  	case Message::GetLineCount:
5152  		if (pdoc-&gt;LinesTotal() == 0)
5153  			return 1;
5154  		else
5155  			return pdoc-&gt;LinesTotal();
5156  	case Message::AllocateLines:
5157  		pdoc-&gt;AllocateLines(wParam);
5158  		break;
5159  	case Message::GetModify:
5160  		return !pdoc-&gt;IsSavePoint();
5161  	case Message::SetSel: {
5162  			Sci::Position nStart = PositionFromUPtr(wParam);
5163  			Sci::Position nEnd = lParam;
5164  			if (nEnd &lt; 0)
5165  				nEnd = pdoc-&gt;Length();
5166  			if (nStart &lt; 0)
5167  				nStart = nEnd; 	
5168  			InvalidateSelection(SelectionRange(nStart, nEnd));
5169  			sel.Clear();
5170  			sel.selType = Selection::SelTypes::stream;
5171  			SetSelection(nEnd, nStart);
5172  			EnsureCaretVisible();
5173  		}
5174  		break;
5175  	case Message::GetSelText: {
5176  			SelectionText selectedText;
5177  			CopySelectionRange(&amp;selectedText);
5178  			if (lParam) {
5179  				char *ptr = CharPtrFromSPtr(lParam);
5180  				size_t iChar = selectedText.Length();
5181  				if (iChar) {
5182  					memcpy(ptr, selectedText.Data(), iChar);
5183  				}
5184  				ptr[iChar] = &#x27;\0&#x27;;
5185  			}
5186  			return selectedText.Length();
5187  	}
5188  	case Message::LineFromPosition:
5189  		if (PositionFromUPtr(wParam) &lt; 0)
5190  			return 0;
5191  		return pdoc-&gt;LineFromPosition(PositionFromUPtr(wParam));
5192  	case Message::PositionFromLine:
5193  		if (LineFromUPtr(wParam) &lt; 0)
5194  			wParam = pdoc-&gt;LineFromPosition(SelectionStart().Position());
5195  		if (wParam == 0)
5196  			return 0; 	
5197  		if (LineFromUPtr(wParam) &gt; pdoc-&gt;LinesTotal())
5198  			return -1;
5199  		return pdoc-&gt;LineStart(LineFromUPtr(wParam));
5200  	case Message::LineLength:
5201  		if ((LineFromUPtr(wParam) &lt; 0) ||
5202  		        (LineFromUPtr(wParam) &gt; pdoc-&gt;LineFromPosition(pdoc-&gt;Length())))
5203  			return 0;
5204  		return pdoc-&gt;LineStart(LineFromUPtr(wParam) + 1) - pdoc-&gt;LineStart(LineFromUPtr(wParam));
5205  	case Message::ReplaceSel: {
5206  			if (lParam == 0)
5207  				return 0;
5208  			UndoGroup ug(pdoc);
5209  			ClearSelection();
5210  			const char *replacement = ConstCharPtrFromSPtr(lParam);
5211  			const Sci::Position lengthInserted = pdoc-&gt;InsertString(
5212  				sel.MainCaret(), replacement, strlen(replacement));
5213  			SetEmptySelection(sel.MainCaret() + lengthInserted);
5214  			SetLastXChosen();
5215  			EnsureCaretVisible();
5216  		}
5217  		break;
5218  	case Message::SetTargetStart:
5219  		targetRange.start.SetPosition(PositionFromUPtr(wParam));
5220  		break;
5221  	case Message::GetTargetStart:
5222  		return targetRange.start.Position();
5223  	case Message::SetTargetStartVirtualSpace:
5224  		targetRange.start.SetVirtualSpace(PositionFromUPtr(wParam));
5225  		break;
5226  	case Message::GetTargetStartVirtualSpace:
5227  		return targetRange.start.VirtualSpace();
5228  	case Message::SetTargetEnd:
5229  		targetRange.end.SetPosition(PositionFromUPtr(wParam));
5230  		break;
5231  	case Message::GetTargetEnd:
5232  		return targetRange.end.Position();
5233  	case Message::SetTargetEndVirtualSpace:
5234  		targetRange.end.SetVirtualSpace(PositionFromUPtr(wParam));
5235  		break;
5236  	case Message::GetTargetEndVirtualSpace:
5237  		return targetRange.end.VirtualSpace();
5238  	case Message::SetTargetRange:
5239  		targetRange.start.SetPosition(PositionFromUPtr(wParam));
5240  		targetRange.end.SetPosition(lParam);
5241  		break;
5242  	case Message::TargetWholeDocument:
5243  		targetRange.start.SetPosition(0);
5244  		targetRange.end.SetPosition(pdoc-&gt;Length());
5245  		break;
5246  	case Message::TargetFromSelection:
5247  		targetRange.start = sel.RangeMain().Start();
5248  		targetRange.end = sel.RangeMain().End();
5249  		break;
5250  	case Message::GetTargetText: {
5251  			std::string text = RangeText(targetRange.start.Position(), targetRange.end.Position());
5252  			return BytesResult(lParam, reinterpret_cast&lt;const unsigned char *&gt;(text.c_str()), text.length());
5253  		}
5254  	case Message::ReplaceTarget:
5255  		PLATFORM_ASSERT(lParam);
5256  		return ReplaceTarget(ReplaceType::basic, ViewFromParams(lParam, wParam));
5257  	case Message::ReplaceTargetRE:
5258  		PLATFORM_ASSERT(lParam);
5259  		return ReplaceTarget(ReplaceType::patterns, ViewFromParams(lParam, wParam));
5260  	case Message::ReplaceTargetMinimal:
5261  		PLATFORM_ASSERT(lParam);
5262  		return ReplaceTarget(ReplaceType::minimal, ViewFromParams(lParam, wParam));
5263  	case Message::SearchInTarget:
5264  		PLATFORM_ASSERT(lParam);
5265  		return SearchInTarget(ConstCharPtrFromSPtr(lParam), PositionFromUPtr(wParam));
5266  	case Message::SetSearchFlags:
5267  		searchFlags = static_cast&lt;FindOption&gt;(wParam);
5268  		break;
5269  	case Message::GetSearchFlags:
5270  		return static_cast&lt;sptr_t&gt;(searchFlags);
5271  	case Message::GetTag:
5272  		return GetTag(CharPtrFromSPtr(lParam), static_cast&lt;int&gt;(wParam));
5273  	case Message::PositionBefore:
5274  		return pdoc-&gt;MovePositionOutsideChar(PositionFromUPtr(wParam) - 1, -1, true);
5275  	case Message::PositionAfter:
5276  		return pdoc-&gt;MovePositionOutsideChar(PositionFromUPtr(wParam) + 1, 1, true);
5277  	case Message::PositionRelative:
5278  		return std::clamp&lt;Sci::Position&gt;(pdoc-&gt;GetRelativePosition(
5279  			PositionFromUPtr(wParam), lParam),
5280  			0, pdoc-&gt;Length());
5281  	case Message::PositionRelativeCodeUnits:
5282  		return std::clamp&lt;Sci::Position&gt;(pdoc-&gt;GetRelativePositionUTF16(
5283  			PositionFromUPtr(wParam), lParam),
5284  			0, pdoc-&gt;Length());
5285  	case Message::LineScroll:
5286  		ScrollTo(topLine + lParam);
5287  		HorizontalScrollTo(xOffset + static_cast&lt;int&gt;(static_cast&lt;int&gt;(wParam) * vs.spaceWidth));
5288  		return 1;
5289  	case Message::SetXOffset:
5290  		xOffset = static_cast&lt;int&gt;(wParam);
5291  		ContainerNeedsUpdate(Update::HScroll);
5292  		SetHorizontalScrollPos();
5293  		Redraw();
5294  		break;
5295  	case Message::GetXOffset:
5296  		return xOffset;
5297  	case Message::ChooseCaretX:
5298  		SetLastXChosen();
5299  		break;
5300  	case Message::ScrollCaret:
5301  		EnsureCaretVisible();
5302  		break;
5303  	case Message::SetReadOnly:
5304  		pdoc-&gt;SetReadOnly(wParam != 0);
5305  		return 1;
5306  	case Message::GetReadOnly:
5307  		return pdoc-&gt;IsReadOnly();
5308  	case Message::CanPaste:
5309  		return CanPaste();
5310  	case Message::PointXFromPosition:
5311  		if (lParam &lt; 0) {
5312  			return 0;
5313  		} else {
5314  			const Point pt = LocationFromPosition(lParam);
5315  			return static_cast&lt;int&gt;(pt.x) - vs.textStart + vs.fixedColumnWidth;
5316  		}
5317  	case Message::PointYFromPosition:
5318  		if (lParam &lt; 0) {
5319  			return 0;
5320  		} else {
5321  			const Point pt = LocationFromPosition(lParam);
5322  			return static_cast&lt;int&gt;(pt.y);
5323  		}
5324  	case Message::FindText:
5325  		return FindText(wParam, lParam);
5326  	case Message::FindTextFull:
5327  		return FindTextFull(wParam, lParam);
5328  	case Message::GetTextRange:
5329  		if (TextRange *tr = static_cast&lt;TextRange *&gt;(PtrFromSPtr(lParam))) {
5330  			return GetTextRange(tr-&gt;lpstrText, tr-&gt;chrg.cpMin, tr-&gt;chrg.cpMax);
5331  		}
5332  		return 0;
5333  	case Message::GetTextRangeFull:
5334  		if (TextRangeFull *tr = static_cast&lt;TextRangeFull *&gt;(PtrFromSPtr(lParam))) {
5335  			return GetTextRange(tr-&gt;lpstrText, tr-&gt;chrg.cpMin, tr-&gt;chrg.cpMax);
5336  		}
5337  		return 0;
5338  	case Message::HideSelection:
5339  		vs.selection.visible = wParam == 0;
5340  		Redraw();
5341  		break;
5342  	case Message::GetSelectionHidden:
5343  		return !vs.selection.visible;
5344  		break;
5345  	case Message::FormatRange:
5346  	case Message::FormatRangeFull:
5347  		return FormatRange(iMessage, wParam, lParam);
5348  	case Message::GetMarginLeft:
5349  		return vs.leftMarginWidth;
5350  	case Message::GetMarginRight:
5351  		return vs.rightMarginWidth;
5352  	case Message::SetMarginLeft:
5353  		lastXChosen += static_cast&lt;int&gt;(lParam) - vs.leftMarginWidth;
5354  		vs.leftMarginWidth = static_cast&lt;int&gt;(lParam);
5355  		InvalidateStyleRedraw();
5356  		break;
5357  	case Message::SetMarginRight:
5358  		vs.rightMarginWidth = static_cast&lt;int&gt;(lParam);
5359  		InvalidateStyleRedraw();
5360  		break;
5361  	case Message::AddText: {
5362  			if (lParam == 0)
5363  				return 0;
5364  			const Sci::Position lengthInserted = pdoc-&gt;InsertString(
5365  				CurrentPosition(), ConstCharPtrFromSPtr(lParam), PositionFromUPtr(wParam));
5366  			SetEmptySelection(sel.MainCaret() + lengthInserted);
5367  			return 0;
5368  		}
5369  	case Message::AddStyledText:
5370  		if (lParam)
5371  			AddStyledText(ConstCharPtrFromSPtr(lParam), PositionFromUPtr(wParam));
5372  		return 0;
5373  	case Message::InsertText: {
5374  			if (lParam == 0)
5375  				return 0;
5376  			Sci::Position insertPos = PositionFromUPtr(wParam);
5377  			if (insertPos == -1)
5378  				insertPos = CurrentPosition();
5379  			Sci::Position newCurrent = CurrentPosition();
5380  			const char *sz = ConstCharPtrFromSPtr(lParam);
5381  			const Sci::Position lengthInserted = pdoc-&gt;InsertString(insertPos, sz, strlen(sz));
5382  			if (newCurrent &gt; insertPos)
5383  				newCurrent += lengthInserted;
5384  			SetEmptySelection(newCurrent);
5385  			return 0;
5386  		}
5387  	case Message::ChangeInsertion:
5388  		PLATFORM_ASSERT(lParam);
5389  		pdoc-&gt;ChangeInsertion(ConstCharPtrFromSPtr(lParam), PositionFromUPtr(wParam));
5390  		return 0;
5391  	case Message::AppendText:
5392  		pdoc-&gt;InsertString(pdoc-&gt;Length(),
5393  			ConstCharPtrFromSPtr(lParam), PositionFromUPtr(wParam));
5394  		return 0;
5395  	case Message::ClearAll:
5396  		ClearAll();
5397  		return 0;
5398  	case Message::DeleteRange:
5399  		pdoc-&gt;DeleteChars(PositionFromUPtr(wParam), lParam);
5400  		return 0;
5401  	case Message::ClearDocumentStyle:
5402  		ClearDocumentStyle();
5403  		return 0;
5404  	case Message::SetUndoCollection:
5405  		pdoc-&gt;SetUndoCollection(wParam != 0);
5406  		return 0;
5407  	case Message::GetUndoCollection:
5408  		return pdoc-&gt;IsCollectingUndo();
5409  	case Message::BeginUndoAction:
5410  		pdoc-&gt;BeginUndoAction();
5411  		return 0;
5412  	case Message::EndUndoAction:
5413  		pdoc-&gt;EndUndoAction();
5414  		return 0;
5415  	case Message::GetCaretPeriod:
5416  		return caret.period;
5417  	case Message::SetCaretPeriod:
5418  		CaretSetPeriod(static_cast&lt;int&gt;(wParam));
5419  		break;
5420  	case Message::GetWordChars:
5421  		return pdoc-&gt;GetCharsOfClass(CharacterClass::word, UCharPtrFromSPtr(lParam));
5422  	case Message::SetWordChars: {
5423  			pdoc-&gt;SetDefaultCharClasses(false);
5424  			if (lParam == 0)
5425  				return 0;
5426  			pdoc-&gt;SetCharClasses(ConstUCharPtrFromSPtr(lParam), CharacterClass::word);
5427  		}
5428  		break;
5429  	case Message::GetWhitespaceChars:
5430  		return pdoc-&gt;GetCharsOfClass(CharacterClass::space, UCharPtrFromSPtr(lParam));
5431  	case Message::SetWhitespaceChars: {
5432  			if (lParam == 0)
5433  				return 0;
5434  			pdoc-&gt;SetCharClasses(ConstUCharPtrFromSPtr(lParam), CharacterClass::space);
5435  		}
5436  		break;
5437  	case Message::GetPunctuationChars:
5438  		return pdoc-&gt;GetCharsOfClass(CharacterClass::punctuation, UCharPtrFromSPtr(lParam));
5439  	case Message::SetPunctuationChars: {
5440  			if (lParam == 0)
5441  				return 0;
5442  			pdoc-&gt;SetCharClasses(ConstUCharPtrFromSPtr(lParam), CharacterClass::punctuation);
5443  		}
5444  		break;
5445  	case Message::SetCharsDefault:
5446  		pdoc-&gt;SetDefaultCharClasses(true);
5447  		break;
5448  	case Message::SetCharacterCategoryOptimization:
5449  		pdoc-&gt;SetCharacterCategoryOptimization(static_cast&lt;int&gt;(wParam));
5450  		break;
5451  	case Message::GetCharacterCategoryOptimization:
5452  		return pdoc-&gt;CharacterCategoryOptimization();
5453  	case Message::GetLength:
5454  		return pdoc-&gt;Length();
5455  	case Message::Allocate:
5456  		pdoc-&gt;Allocate(PositionFromUPtr(wParam));
5457  		break;
5458  	case Message::GetCharAt:
5459  		return pdoc-&gt;CharAt(PositionFromUPtr(wParam));
5460  	case Message::SetCurrentPos:
5461  		if (sel.IsRectangular()) {
5462  			sel.Rectangular().caret.SetPosition(PositionFromUPtr(wParam));
5463  			SetRectangularRange();
5464  			Redraw();
5465  		} else {
5466  			SetSelection(PositionFromUPtr(wParam), sel.MainAnchor());
5467  		}
5468  		break;
5469  	case Message::GetCurrentPos:
5470  		return sel.IsRectangular() ? sel.Rectangular().caret.Position() : sel.MainCaret();
5471  	case Message::SetAnchor:
5472  		if (sel.IsRectangular()) {
5473  			sel.Rectangular().anchor.SetPosition(PositionFromUPtr(wParam));
5474  			SetRectangularRange();
5475  			Redraw();
5476  		} else {
5477  			SetSelection(sel.MainCaret(), PositionFromUPtr(wParam));
5478  		}
5479  		break;
5480  	case Message::GetAnchor:
5481  		return sel.IsRectangular() ? sel.Rectangular().anchor.Position() : sel.MainAnchor();
5482  	case Message::SetSelectionStart:
5483  		SetSelection(std::max(sel.MainCaret(), PositionFromUPtr(wParam)), PositionFromUPtr(wParam));
5484  		break;
5485  	case Message::GetSelectionStart:
5486  		return sel.LimitsForRectangularElseMain().start.Position();
5487  	case Message::SetSelectionEnd:
5488  		SetSelection(PositionFromUPtr(wParam), std::min(sel.MainAnchor(), PositionFromUPtr(wParam)));
5489  		break;
5490  	case Message::GetSelectionEnd:
5491  		return sel.LimitsForRectangularElseMain().end.Position();
5492  	case Message::SetEmptySelection:
5493  		SetEmptySelection(PositionFromUPtr(wParam));
5494  		break;
5495  	case Message::SetPrintMagnification:
5496  		view.printParameters.magnification = static_cast&lt;int&gt;(wParam);
5497  		break;
5498  	case Message::GetPrintMagnification:
5499  		return view.printParameters.magnification;
5500  	case Message::SetPrintColourMode:
5501  		view.printParameters.colourMode = static_cast&lt;PrintOption&gt;(wParam);
5502  		break;
5503  	case Message::GetPrintColourMode:
5504  		return static_cast&lt;sptr_t&gt;(view.printParameters.colourMode);
5505  	case Message::SetPrintWrapMode:
5506  		view.printParameters.wrapState = (static_cast&lt;Wrap&gt;(wParam) == Wrap::Word) ? Wrap::Word : Wrap::None;
5507  		break;
5508  	case Message::GetPrintWrapMode:
5509  		return static_cast&lt;sptr_t&gt;(view.printParameters.wrapState);
5510  	case Message::GetStyleAt:
5511  		if (PositionFromUPtr(wParam) &gt;= pdoc-&gt;Length())
5512  			return 0;
5513  		else
5514  			return pdoc-&gt;StyleAt(PositionFromUPtr(wParam));
5515  	case Message::GetStyleIndexAt:
5516  		if (PositionFromUPtr(wParam) &gt;= pdoc-&gt;Length())
5517  			return 0;
5518  		else
5519  			return pdoc-&gt;StyleIndexAt(PositionFromUPtr(wParam));
5520  	case Message::Redo:
5521  		Redo();
5522  		break;
5523  	case Message::SelectAll:
5524  		SelectAll();
5525  		break;
5526  	case Message::SetSavePoint:
5527  		pdoc-&gt;SetSavePoint();
5528  		break;
5529  	case Message::GetStyledText:
5530  		if (TextRange *tr = static_cast&lt;TextRange *&gt;(PtrFromSPtr(lParam))) {
5531  			return GetStyledText(tr-&gt;lpstrText, tr-&gt;chrg.cpMin, tr-&gt;chrg.cpMax);
5532  		}
5533  		return 0;
5534  	case Message::GetStyledTextFull:
5535  		if (TextRangeFull *tr = static_cast&lt;TextRangeFull *&gt;(PtrFromSPtr(lParam))) {
5536  			return GetStyledText(tr-&gt;lpstrText, tr-&gt;chrg.cpMin, tr-&gt;chrg.cpMax);
5537  		}
5538  		return 0;
5539  	case Message::CanRedo:
5540  		return (pdoc-&gt;CanRedo() &amp;&amp; !pdoc-&gt;IsReadOnly()) ? 1 : 0;
5541  	case Message::MarkerLineFromHandle:
5542  		return pdoc-&gt;LineFromHandle(static_cast&lt;int&gt;(wParam));
5543  	case Message::MarkerDeleteHandle:
5544  		pdoc-&gt;DeleteMarkFromHandle(static_cast&lt;int&gt;(wParam));
5545  		break;
5546  	case Message::MarkerHandleFromLine:
5547  		return pdoc-&gt;MarkerHandleFromLine(LineFromUPtr(wParam), static_cast&lt;int&gt;(lParam));
5548  	case Message::MarkerNumberFromLine:
5549  		return pdoc-&gt;MarkerNumberFromLine(LineFromUPtr(wParam), static_cast&lt;int&gt;(lParam));
5550  	case Message::GetViewWS:
5551  		return static_cast&lt;sptr_t&gt;(vs.viewWhitespace);
5552  	case Message::SetViewWS:
5553  		vs.viewWhitespace = static_cast&lt;WhiteSpace&gt;(wParam);
5554  		Redraw();
5555  		break;
5556  	case Message::GetTabDrawMode:
5557  		return static_cast&lt;sptr_t&gt;(vs.tabDrawMode);
5558  	case Message::SetTabDrawMode:
5559  		vs.tabDrawMode = static_cast&lt;TabDrawMode&gt;(wParam);
5560  		Redraw();
5561  		break;
5562  	case Message::GetWhitespaceSize:
5563  		return vs.whitespaceSize;
5564  	case Message::SetWhitespaceSize:
5565  		vs.whitespaceSize = static_cast&lt;int&gt;(wParam);
5566  		Redraw();
5567  		break;
5568  	case Message::PositionFromPoint:
5569  		return PositionFromLocation(PointFromParameters(wParam, lParam), false, false);
5570  	case Message::PositionFromPointClose:
5571  		return PositionFromLocation(PointFromParameters(wParam, lParam), true, false);
5572  	case Message::CharPositionFromPoint:
5573  		return PositionFromLocation(PointFromParameters(wParam, lParam), false, true);
5574  	case Message::CharPositionFromPointClose:
5575  		return PositionFromLocation(PointFromParameters(wParam, lParam), true, true);
5576  	case Message::GotoLine:
5577  		GoToLine(LineFromUPtr(wParam));
5578  		break;
5579  	case Message::GotoPos:
5580  		SetEmptySelection(PositionFromUPtr(wParam));
5581  		EnsureCaretVisible();
5582  		break;
5583  	case Message::GetCurLine: {
5584  			const Sci::Line lineCurrentPos = pdoc-&gt;SciLineFromPosition(sel.MainCaret());
5585  			const Sci::Position lineStart = pdoc-&gt;LineStart(lineCurrentPos);
5586  			const Sci::Position lineEnd = pdoc-&gt;LineStart(lineCurrentPos + 1);
5587  			if (lParam == 0) {
5588  				return lineEnd - lineStart;
5589  			}
5590  			char *ptr = CharPtrFromSPtr(lParam);
5591  			const Sci::Position len = std::min&lt;uptr_t&gt;(lineEnd - lineStart, wParam);
5592  			pdoc-&gt;GetCharRange(ptr, lineStart, len);
5593  			ptr[len] = &#x27;\0&#x27;;
5594  			return sel.MainCaret() - lineStart;
5595  		}
5596  	case Message::GetEndStyled:
5597  		return pdoc-&gt;GetEndStyled();
5598  	case Message::GetEOLMode:
5599  		return static_cast&lt;sptr_t&gt;(pdoc-&gt;eolMode);
5600  	case Message::SetEOLMode:
5601  		pdoc-&gt;eolMode = static_cast&lt;EndOfLine&gt;(wParam);
5602  		break;
5603  	case Message::SetLineEndTypesAllowed:
5604  		if (pdoc-&gt;SetLineEndTypesAllowed(static_cast&lt;LineEndType&gt;(wParam))) {
5605  			pcs-&gt;Clear();
5606  			pcs-&gt;InsertLines(0, pdoc-&gt;LinesTotal() - 1);
5607  			SetAnnotationHeights(0, pdoc-&gt;LinesTotal());
5608  			InvalidateStyleRedraw();
5609  		}
5610  		break;
5611  	case Message::GetLineEndTypesAllowed:
5612  		return static_cast&lt;sptr_t&gt;(pdoc-&gt;GetLineEndTypesAllowed());
5613  	case Message::GetLineEndTypesActive:
5614  		return static_cast&lt;sptr_t&gt;(pdoc-&gt;GetLineEndTypesActive());
5615  	case Message::StartStyling:
5616  		pdoc-&gt;StartStyling(PositionFromUPtr(wParam));
5617  		break;
5618  	case Message::SetStyling:
5619  		if (PositionFromUPtr(wParam) &lt; 0)
5620  			errorStatus = Status::Failure;
5621  		else
5622  			pdoc-&gt;SetStyleFor(PositionFromUPtr(wParam), static_cast&lt;char&gt;(lParam));
5623  		break;
5624  	case Message::SetStylingEx:             
5625  		if (lParam == 0)
5626  			return 0;
5627  		pdoc-&gt;SetStyles(PositionFromUPtr(wParam), ConstCharPtrFromSPtr(lParam));
5628  		break;
5629  	case Message::SetBufferedDraw:
5630  		view.bufferedDraw = wParam != 0;
5631  		break;
5632  	case Message::GetBufferedDraw:
5633  		return view.bufferedDraw;
5634  #ifdef INCLUDE_DEPRECATED_FEATURES
5635  	case SCI_GETTWOPHASEDRAW:
5636  		return view.phasesDraw == EditView::phasesTwo;
5637  	case SCI_SETTWOPHASEDRAW:
5638  		if (view.SetTwoPhaseDraw(wParam != 0))
5639  			InvalidateStyleRedraw();
5640  		break;
5641  #endif
5642  	case Message::GetPhasesDraw:
5643  		return static_cast&lt;sptr_t&gt;(view.phasesDraw);
5644  	case Message::SetPhasesDraw:
5645  		if (view.SetPhasesDraw(static_cast&lt;int&gt;(wParam)))
5646  			InvalidateStyleRedraw();
5647  		break;
5648  	case Message::SetFontQuality:
5649  		vs.extraFontFlag = static_cast&lt;FontQuality&gt;(
5650  			(static_cast&lt;int&gt;(vs.extraFontFlag) &amp; ~static_cast&lt;int&gt;(FontQuality::QualityMask)) |
5651  			(wParam &amp; static_cast&lt;int&gt;(FontQuality::QualityMask)));
5652  		InvalidateStyleRedraw();
5653  		break;
5654  	case Message::GetFontQuality:
5655  		return static_cast&lt;int&gt;(vs.extraFontFlag) &amp; static_cast&lt;int&gt;(FontQuality::QualityMask);
5656  	case Message::SetTabWidth:
5657  		if (wParam &gt; 0) {
5658  			pdoc-&gt;tabInChars = static_cast&lt;int&gt;(wParam);
5659  			if (pdoc-&gt;indentInChars == 0)
5660  				pdoc-&gt;actualIndentInChars = pdoc-&gt;tabInChars;
5661  		}
5662  		InvalidateStyleRedraw();
5663  		break;
5664  	case Message::GetTabWidth:
5665  		return pdoc-&gt;tabInChars;
5666  	case Message::SetTabMinimumWidth:
5667  		SetAppearance(view.tabWidthMinimumPixels, static_cast&lt;int&gt;(wParam));
5668  		break;
5669  	case Message::GetTabMinimumWidth:
5670  		return view.tabWidthMinimumPixels;
5671  	case Message::ClearTabStops:
5672  		if (view.ClearTabstops(LineFromUPtr(wParam))) {
5673  			const DocModification mh(ModificationFlags::ChangeTabStops, 0, 0, 0, nullptr, LineFromUPtr(wParam));
5674  			NotifyModified(pdoc, mh, nullptr);
5675  		}
5676  		break;
5677  	case Message::AddTabStop:
5678  		if (view.AddTabstop(LineFromUPtr(wParam), static_cast&lt;int&gt;(lParam))) {
5679  			const DocModification mh(ModificationFlags::ChangeTabStops, 0, 0, 0, nullptr, LineFromUPtr(wParam));
5680  			NotifyModified(pdoc, mh, nullptr);
5681  		}
5682  		break;
5683  	case Message::GetNextTabStop:
5684  		return view.GetNextTabstop(LineFromUPtr(wParam), static_cast&lt;int&gt;(lParam));
5685  	case Message::SetIndent:
5686  		pdoc-&gt;indentInChars = static_cast&lt;int&gt;(wParam);
5687  		if (pdoc-&gt;indentInChars != 0)
5688  			pdoc-&gt;actualIndentInChars = pdoc-&gt;indentInChars;
5689  		else
5690  			pdoc-&gt;actualIndentInChars = pdoc-&gt;tabInChars;
5691  		InvalidateStyleRedraw();
5692  		break;
5693  	case Message::GetIndent:
5694  		return pdoc-&gt;indentInChars;
5695  	case Message::SetUseTabs:
5696  		pdoc-&gt;useTabs = wParam != 0;
5697  		InvalidateStyleRedraw();
5698  		break;
5699  	case Message::GetUseTabs:
5700  		return pdoc-&gt;useTabs;
5701  	case Message::SetLineIndentation:
5702  		pdoc-&gt;SetLineIndentation(LineFromUPtr(wParam), lParam);
5703  		break;
5704  	case Message::GetLineIndentation:
5705  		return pdoc-&gt;GetLineIndentation(LineFromUPtr(wParam));
5706  	case Message::GetLineIndentPosition:
5707  		return pdoc-&gt;GetLineIndentPosition(LineFromUPtr(wParam));
5708  	case Message::SetTabIndents:
5709  		pdoc-&gt;tabIndents = wParam != 0;
5710  		break;
5711  	case Message::GetTabIndents:
5712  		return pdoc-&gt;tabIndents;
5713  	case Message::SetBackSpaceUnIndents:
5714  		pdoc-&gt;backspaceUnindents = wParam != 0;
5715  		break;
5716  	case Message::GetBackSpaceUnIndents:
5717  		return pdoc-&gt;backspaceUnindents;
5718  	case Message::SetMouseDwellTime:
5719  		dwellDelay = static_cast&lt;int&gt;(wParam);
5720  		ticksToDwell = dwellDelay;
5721  		break;
5722  	case Message::GetMouseDwellTime:
5723  		return dwellDelay;
5724  	case Message::WordStartPosition:
5725  		return pdoc-&gt;ExtendWordSelect(PositionFromUPtr(wParam), -1, lParam != 0);
5726  	case Message::WordEndPosition:
5727  		return pdoc-&gt;ExtendWordSelect(PositionFromUPtr(wParam), 1, lParam != 0);
5728  	case Message::IsRangeWord:
5729  		return pdoc-&gt;IsWordAt(PositionFromUPtr(wParam), lParam);
5730  	case Message::SetIdleStyling:
5731  		idleStyling = static_cast&lt;IdleStyling&gt;(wParam);
5732  		break;
5733  	case Message::GetIdleStyling:
5734  		return static_cast&lt;sptr_t&gt;(idleStyling);
5735  	case Message::SetWrapMode:
5736  		if (vs.SetWrapState(static_cast&lt;Wrap&gt;(wParam))) {
5737  			xOffset = 0;
5738  			ContainerNeedsUpdate(Update::HScroll);
5739  			InvalidateStyleRedraw();
5740  			ReconfigureScrollBars();
5741  		}
5742  		break;
5743  	case Message::GetWrapMode:
5744  		return static_cast&lt;sptr_t&gt;(vs.wrap.state);
5745  	case Message::SetWrapVisualFlags:
5746  		if (vs.SetWrapVisualFlags(static_cast&lt;WrapVisualFlag&gt;(wParam))) {
5747  			InvalidateStyleRedraw();
5748  			ReconfigureScrollBars();
5749  		}
5750  		break;
5751  	case Message::GetWrapVisualFlags:
5752  		return static_cast&lt;sptr_t&gt;(vs.wrap.visualFlags);
5753  	case Message::SetWrapVisualFlagsLocation:
5754  		if (vs.SetWrapVisualFlagsLocation(static_cast&lt;WrapVisualLocation&gt;(wParam))) {
5755  			InvalidateStyleRedraw();
5756  		}
5757  		break;
5758  	case Message::GetWrapVisualFlagsLocation:
5759  		return static_cast&lt;sptr_t&gt;(vs.wrap.visualFlagsLocation);
5760  	case Message::SetWrapStartIndent:
5761  		if (vs.SetWrapVisualStartIndent(static_cast&lt;int&gt;(wParam))) {
5762  			InvalidateStyleRedraw();
5763  			ReconfigureScrollBars();
5764  		}
5765  		break;
5766  	case Message::GetWrapStartIndent:
5767  		return vs.wrap.visualStartIndent;
5768  	case Message::SetWrapIndentMode:
5769  		if (vs.SetWrapIndentMode(static_cast&lt;WrapIndentMode&gt;(wParam))) {
5770  			InvalidateStyleRedraw();
5771  			ReconfigureScrollBars();
5772  		}
5773  		break;
5774  	case Message::GetWrapIndentMode:
5775  		return static_cast&lt;sptr_t&gt;(vs.wrap.indentMode);
5776  	case Message::SetLayoutCache:
5777  		if (static_cast&lt;LineCache&gt;(wParam) &lt;= LineCache::Document) {
5778  			view.llc.SetLevel(static_cast&lt;LineCache&gt;(wParam));
5779  		}
5780  		break;
5781  	case Message::GetLayoutCache:
5782  		return static_cast&lt;sptr_t&gt;(view.llc.GetLevel());
5783  	case Message::SetPositionCache:
5784  		view.posCache-&gt;SetSize(wParam);
5785  		break;
5786  	case Message::GetPositionCache:
5787  		return view.posCache-&gt;GetSize();
5788  	case Message::SetLayoutThreads:
5789  		view.SetLayoutThreads(static_cast&lt;unsigned int&gt;(wParam));
5790  		break;
5791  	case Message::GetLayoutThreads:
5792  		return view.GetLayoutThreads();
5793  	case Message::SetScrollWidth:
5794  		PLATFORM_ASSERT(wParam &gt; 0);
5795  		if ((wParam &gt; 0) &amp;&amp; (wParam != static_cast&lt;unsigned int&gt;(scrollWidth))) {
5796  			view.lineWidthMaxSeen = 0;
5797  			scrollWidth = static_cast&lt;int&gt;(wParam);
5798  			SetScrollBars();
5799  		}
5800  		break;
5801  	case Message::GetScrollWidth:
5802  		return scrollWidth;
5803  	case Message::SetScrollWidthTracking:
5804  		trackLineWidth = wParam != 0;
5805  		break;
5806  	case Message::GetScrollWidthTracking:
5807  		return trackLineWidth;
5808  	case Message::LinesJoin:
5809  		LinesJoin();
5810  		break;
5811  	case Message::LinesSplit:
5812  		LinesSplit(static_cast&lt;int&gt;(wParam));
5813  		break;
5814  	case Message::TextWidth:
5815  		PLATFORM_ASSERT(wParam &lt; vs.styles.size());
5816  		PLATFORM_ASSERT(lParam);
5817  		return TextWidth(wParam, ConstCharPtrFromSPtr(lParam));
5818  	case Message::TextHeight:
5819  		RefreshStyleData();
5820  		return vs.lineHeight;
5821  	case Message::SetEndAtLastLine:
5822  		PLATFORM_ASSERT((wParam == 0) || (wParam == 1));
5823  		if (endAtLastLine != (wParam != 0)) {
5824  			endAtLastLine = wParam != 0;
5825  			SetScrollBars();
5826  		}
5827  		break;
5828  	case Message::GetEndAtLastLine:
5829  		return endAtLastLine;
5830  	case Message::SetCaretSticky:
5831  		PLATFORM_ASSERT(static_cast&lt;CaretSticky&gt;(wParam) &lt;= CaretSticky::WhiteSpace);
5832  		if (static_cast&lt;CaretSticky&gt;(wParam) &lt;= CaretSticky::WhiteSpace) {
5833  			caretSticky = static_cast&lt;CaretSticky&gt;(wParam);
5834  		}
5835  		break;
5836  	case Message::GetCaretSticky:
5837  		return static_cast&lt;sptr_t&gt;(caretSticky);
5838  	case Message::ToggleCaretSticky:
5839  		caretSticky = (caretSticky == CaretSticky::Off) ? CaretSticky::On : CaretSticky::Off;
5840  		break;
5841  	case Message::GetColumn:
5842  		return pdoc-&gt;GetColumn(PositionFromUPtr(wParam));
5843  	case Message::FindColumn:
5844  		return pdoc-&gt;FindColumn(LineFromUPtr(wParam), lParam);
5845  	case Message::SetHScrollBar :
5846  		if (horizontalScrollBarVisible != (wParam != 0)) {
5847  			horizontalScrollBarVisible = wParam != 0;
5848  			SetScrollBars();
5849  			ReconfigureScrollBars();
5850  		}
5851  		break;
5852  	case Message::GetHScrollBar:
5853  		return horizontalScrollBarVisible;
5854  	case Message::SetVScrollBar:
5855  		if (verticalScrollBarVisible != (wParam != 0)) {
5856  			verticalScrollBarVisible = wParam != 0;
5857  			SetScrollBars();
5858  			ReconfigureScrollBars();
5859  			if (verticalScrollBarVisible)
5860  				SetVerticalScrollPos();
5861  		}
5862  		break;
5863  	case Message::GetVScrollBar:
5864  		return verticalScrollBarVisible;
5865  	case Message::SetIndentationGuides:
5866  		vs.viewIndentationGuides = static_cast&lt;IndentView&gt;(wParam);
5867  		Redraw();
5868  		break;
5869  	case Message::GetIndentationGuides:
5870  		return static_cast&lt;sptr_t&gt;(vs.viewIndentationGuides);
5871  	case Message::SetHighlightGuide:
5872  		if ((highlightGuideColumn != static_cast&lt;int&gt;(wParam)) || (wParam &gt; 0)) {
5873  			highlightGuideColumn = static_cast&lt;int&gt;(wParam);
5874  			Redraw();
5875  		}
5876  		break;
5877  	case Message::GetHighlightGuide:
5878  		return highlightGuideColumn;
5879  	case Message::GetLineEndPosition:
5880  		return pdoc-&gt;LineEnd(LineFromUPtr(wParam));
5881  	case Message::SetCodePage:
5882  		if (ValidCodePage(static_cast&lt;int&gt;(wParam))) {
5883  			if (pdoc-&gt;SetDBCSCodePage(static_cast&lt;int&gt;(wParam))) {
5884  				pcs-&gt;Clear();
5885  				pcs-&gt;InsertLines(0, pdoc-&gt;LinesTotal() - 1);
5886  				SetAnnotationHeights(0, pdoc-&gt;LinesTotal());
5887  				InvalidateStyleRedraw();
5888  				SetRepresentations();
5889  			}
5890  		}
5891  		break;
5892  	case Message::GetCodePage:
5893  		return pdoc-&gt;dbcsCodePage;
5894  	case Message::SetIMEInteraction:
5895  		imeInteraction = static_cast&lt;IMEInteraction&gt;(wParam);
5896  		break;
5897  	case Message::GetIMEInteraction:
5898  		return static_cast&lt;sptr_t&gt;(imeInteraction);
5899  	case Message::SetBidirectional:
5900  		break;
5901  	case Message::GetBidirectional:
5902  		return static_cast&lt;sptr_t&gt;(bidirectional);
5903  	case Message::GetLineCharacterIndex:
5904  		return static_cast&lt;sptr_t&gt;(pdoc-&gt;LineCharacterIndex());
5905  	case Message::AllocateLineCharacterIndex:
5906  		pdoc-&gt;AllocateLineCharacterIndex(static_cast&lt;LineCharacterIndexType&gt;(wParam));
5907  		break;
5908  	case Message::ReleaseLineCharacterIndex:
5909  		pdoc-&gt;ReleaseLineCharacterIndex(static_cast&lt;LineCharacterIndexType&gt;(wParam));
5910  		break;
5911  	case Message::LineFromIndexPosition:
5912  		return pdoc-&gt;LineFromPositionIndex(PositionFromUPtr(wParam), static_cast&lt;LineCharacterIndexType&gt;(lParam));
5913  	case Message::IndexPositionFromLine:
5914  		return pdoc-&gt;IndexLineStart(LineFromUPtr(wParam), static_cast&lt;LineCharacterIndexType&gt;(lParam));
5915  	case Message::MarkerDefine:
5916  		if (wParam &lt;= MarkerMax) {
5917  			vs.markers[wParam].markType = static_cast&lt;MarkerSymbol&gt;(lParam);
5918  			vs.CalcLargestMarkerHeight();
5919  		}
5920  		InvalidateStyleData();
5921  		RedrawSelMargin();
5922  		break;
5923  	case Message::MarkerSymbolDefined:
5924  		if (wParam &lt;= MarkerMax)
5925  			return static_cast&lt;sptr_t&gt;(vs.markers[wParam].markType);
5926  		else
5927  			return 0;
5928  	case Message::MarkerSetFore:
5929  		if (wParam &lt;= MarkerMax)
5930  			vs.markers[wParam].fore = ColourRGBA::FromIpRGB(lParam);
5931  		InvalidateStyleData();
5932  		RedrawSelMargin();
5933  		break;
5934  	case Message::MarkerSetBack:
5935  		if (wParam &lt;= MarkerMax)
5936  			vs.markers[wParam].back = ColourRGBA::FromIpRGB(lParam);
5937  		InvalidateStyleData();
5938  		RedrawSelMargin();
5939  		break;
5940  	case Message::MarkerSetBackSelected:
5941  		if (wParam &lt;= MarkerMax)
5942  			vs.markers[wParam].backSelected = ColourRGBA::FromIpRGB(lParam);
5943  		InvalidateStyleData();
5944  		RedrawSelMargin();
5945  		break;
5946  	case Message::MarkerSetForeTranslucent:
5947  		if (wParam &lt;= MarkerMax)
5948  			vs.markers[wParam].fore = ColourRGBA(static_cast&lt;int&gt;(lParam));
5949  		InvalidateStyleData();
5950  		RedrawSelMargin();
5951  		break;
5952  	case Message::MarkerSetBackTranslucent:
5953  		if (wParam &lt;= MarkerMax)
5954  			vs.markers[wParam].back = ColourRGBA(static_cast&lt;int&gt;(lParam));
5955  		InvalidateStyleData();
5956  		RedrawSelMargin();
5957  		break;
5958  	case Message::MarkerSetBackSelectedTranslucent:
5959  		if (wParam &lt;= MarkerMax)
5960  			vs.markers[wParam].backSelected = ColourRGBA(static_cast&lt;int&gt;(lParam));
5961  		InvalidateStyleData();
5962  		RedrawSelMargin();
5963  		break;
5964  	case Message::MarkerSetStrokeWidth:
5965  		if (wParam &lt;= MarkerMax)
5966  			vs.markers[wParam].strokeWidth = lParam / 100.0f;
5967  		InvalidateStyleData();
5968  		RedrawSelMargin();
5969  		break;
5970  	case Message::MarkerEnableHighlight:
5971  		marginView.highlightDelimiter.isEnabled = wParam == 1;
5972  		RedrawSelMargin();
5973  		break;
5974  	case Message::MarkerSetAlpha:
5975  		if (wParam &lt;= MarkerMax) {
5976  			if (static_cast&lt;Alpha&gt;(lParam) == Alpha::NoAlpha) {
5977  				SetAppearance(vs.markers[wParam].alpha, Alpha::Opaque);
5978  				SetAppearance(vs.markers[wParam].layer, Layer::Base);
5979  			} else {
5980  				SetAppearance(vs.markers[wParam].alpha, static_cast&lt;Alpha&gt;(lParam));
5981  				SetAppearance(vs.markers[wParam].layer, Layer::OverText);
5982  			}
5983  		}
5984  		break;
5985  	case Message::MarkerSetLayer:
5986  		if (wParam &lt;= MarkerMax) {
5987  			SetAppearance(vs.markers[wParam].layer, static_cast&lt;Layer&gt;(lParam));
5988  		}
5989  		break;
5990  	case Message::MarkerGetLayer:
5991  		if (wParam &lt;= MarkerMax) {
5992  			return static_cast&lt;sptr_t&gt;(vs.markers[wParam].layer);
5993  		}
5994  		return 0;
5995  	case Message::MarkerAdd: {
5996  			const int markerID = pdoc-&gt;AddMark(LineFromUPtr(wParam), static_cast&lt;int&gt;(lParam));
5997  			return markerID;
5998  		}
5999  	case Message::MarkerAddSet:
6000  		if (lParam != 0)
6001  			pdoc-&gt;AddMarkSet(LineFromUPtr(wParam), static_cast&lt;int&gt;(lParam));
6002  		break;
6003  	case Message::MarkerDelete:
6004  		pdoc-&gt;DeleteMark(LineFromUPtr(wParam), static_cast&lt;int&gt;(lParam));
6005  		break;
6006  	case Message::MarkerDeleteAll:
6007  		pdoc-&gt;DeleteAllMarks(static_cast&lt;int&gt;(wParam));
6008  		break;
6009  	case Message::MarkerGet:
6010  		return GetMark(LineFromUPtr(wParam));
6011  	case Message::MarkerNext:
6012  		return pdoc-&gt;MarkerNext(LineFromUPtr(wParam), static_cast&lt;int&gt;(lParam));
6013  	case Message::MarkerPrevious: {
6014  			for (Sci::Line iLine = LineFromUPtr(wParam); iLine &gt;= 0; iLine--) {
6015  				if ((GetMark(iLine) &amp; lParam) != 0)
6016  					return iLine;
6017  			}
6018  		}
6019  		return -1;
6020  	case Message::MarkerDefinePixmap:
6021  		if (wParam &lt;= MarkerMax) {
6022  			vs.markers[wParam].SetXPM(ConstCharPtrFromSPtr(lParam));
6023  			vs.CalcLargestMarkerHeight();
6024  		}
6025  		InvalidateStyleData();
6026  		RedrawSelMargin();
6027  		break;
6028  	case Message::RGBAImageSetWidth:
6029  		sizeRGBAImage.x = static_cast&lt;XYPOSITION&gt;(wParam);
6030  		break;
6031  	case Message::RGBAImageSetHeight:
6032  		sizeRGBAImage.y = static_cast&lt;XYPOSITION&gt;(wParam);
6033  		break;
6034  	case Message::RGBAImageSetScale:
6035  		scaleRGBAImage = static_cast&lt;float&gt;(wParam);
6036  		break;
6037  	case Message::MarkerDefineRGBAImage:
6038  		if (wParam &lt;= MarkerMax) {
6039  			vs.markers[wParam].SetRGBAImage(sizeRGBAImage, scaleRGBAImage / 100.0f, ConstUCharPtrFromSPtr(lParam));
6040  			vs.CalcLargestMarkerHeight();
6041  		}
6042  		InvalidateStyleData();
6043  		RedrawSelMargin();
6044  		break;
6045  	case Message::SetMarginTypeN:
6046  		if (ValidMargin(wParam)) {
6047  			vs.ms[wParam].style = static_cast&lt;MarginType&gt;(lParam);
6048  			InvalidateStyleRedraw();
6049  		}
6050  		break;
6051  	case Message::GetMarginTypeN:
6052  		if (ValidMargin(wParam))
6053  			return static_cast&lt;sptr_t&gt;(vs.ms[wParam].style);
6054  		else
6055  			return 0;
6056  	case Message::SetMarginWidthN:
6057  		if (ValidMargin(wParam)) {
6058  			if (vs.ms[wParam].width != lParam) {
6059  				lastXChosen += static_cast&lt;int&gt;(lParam) - vs.ms[wParam].width;
6060  				vs.ms[wParam].width = static_cast&lt;int&gt;(lParam);
6061  				InvalidateStyleRedraw();
6062  			}
6063  		}
6064  		break;
6065  	case Message::GetMarginWidthN:
6066  		if (ValidMargin(wParam))
6067  			return vs.ms[wParam].width;
6068  		else
6069  			return 0;
6070  	case Message::SetMarginMaskN:
6071  		if (ValidMargin(wParam)) {
6072  			vs.ms[wParam].mask = static_cast&lt;int&gt;(lParam);
6073  			InvalidateStyleRedraw();
6074  		}
6075  		break;
6076  	case Message::GetMarginMaskN:
6077  		if (ValidMargin(wParam))
6078  			return vs.ms[wParam].mask;
6079  		else
6080  			return 0;
6081  	case Message::SetMarginSensitiveN:
6082  		if (ValidMargin(wParam)) {
6083  			vs.ms[wParam].sensitive = lParam != 0;
6084  			InvalidateStyleRedraw();
6085  		}
6086  		break;
6087  	case Message::GetMarginSensitiveN:
6088  		if (ValidMargin(wParam))
6089  			return vs.ms[wParam].sensitive ? 1 : 0;
6090  		else
6091  			return 0;
6092  	case Message::SetMarginCursorN:
6093  		if (ValidMargin(wParam))
6094  			vs.ms[wParam].cursor = static_cast&lt;CursorShape&gt;(lParam);
6095  		break;
6096  	case Message::GetMarginCursorN:
6097  		if (ValidMargin(wParam))
6098  			return static_cast&lt;sptr_t&gt;(vs.ms[wParam].cursor);
6099  		else
6100  			return 0;
6101  	case Message::SetMarginBackN:
6102  		if (ValidMargin(wParam)) {
6103  			vs.ms[wParam].back = ColourRGBA::FromIpRGB(lParam);
6104  			InvalidateStyleRedraw();
6105  		}
6106  		break;
6107  	case Message::GetMarginBackN:
6108  		if (ValidMargin(wParam))
6109  			return vs.ms[wParam].back.OpaqueRGB();
6110  		else
6111  			return 0;
6112  	case Message::SetMargins:
6113  		if (wParam &lt; 1000)
6114  			vs.ms.resize(wParam);
6115  		break;
6116  	case Message::GetMargins:
6117  		return vs.ms.size();
6118  	case Message::StyleClearAll:
6119  		vs.ClearStyles();
6120  		InvalidateStyleRedraw();
6121  		break;
6122  	case Message::StyleSetFore:
6123  	case Message::StyleSetBack:
6124  	case Message::StyleSetBold:
6125  	case Message::StyleSetWeight:
6126  	case Message::StyleSetItalic:
6127  	case Message::StyleSetEOLFilled:
6128  	case Message::StyleSetSize:
6129  	case Message::StyleSetSizeFractional:
6130  	case Message::StyleSetFont:
6131  	case Message::StyleSetUnderline:
6132  	case Message::StyleSetCase:
6133  	case Message::StyleSetCharacterSet:
6134  	case Message::StyleSetVisible:
6135  	case Message::StyleSetChangeable:
6136  	case Message::StyleSetHotSpot:
6137  	case Message::StyleSetCheckMonospaced:
6138  	case Message::StyleSetInvisibleRepresentation:
6139  		StyleSetMessage(iMessage, wParam, lParam);
6140  		break;
6141  	case Message::StyleGetFore:
6142  	case Message::StyleGetBack:
6143  	case Message::StyleGetBold:
6144  	case Message::StyleGetWeight:
6145  	case Message::StyleGetItalic:
6146  	case Message::StyleGetEOLFilled:
6147  	case Message::StyleGetSize:
6148  	case Message::StyleGetSizeFractional:
6149  	case Message::StyleGetFont:
6150  	case Message::StyleGetUnderline:
6151  	case Message::StyleGetCase:
6152  	case Message::StyleGetCharacterSet:
6153  	case Message::StyleGetVisible:
6154  	case Message::StyleGetChangeable:
6155  	case Message::StyleGetHotSpot:
6156  	case Message::StyleGetCheckMonospaced:
6157  	case Message::StyleGetInvisibleRepresentation:
6158  		return StyleGetMessage(iMessage, wParam, lParam);
6159  	case Message::StyleResetDefault:
6160  		vs.ResetDefaultStyle();
6161  		InvalidateStyleRedraw();
6162  		break;
6163  	case Message::SetElementColour:
6164  		if (vs.SetElementColour(static_cast&lt;Element&gt;(wParam), ColourRGBA(static_cast&lt;int&gt;(lParam)))) {
6165  			InvalidateStyleRedraw();
6166  		}
6167  		break;
6168  	case Message::GetElementColour:
6169  		return vs.ElementColour(static_cast&lt;Element&gt;(wParam)).value_or(ColourRGBA()).AsInteger();
6170  	case Message::ResetElementColour:
6171  		if (vs.ResetElement(static_cast&lt;Element&gt;(wParam))) {
6172  			InvalidateStyleRedraw();
6173  		}
6174  		break;
6175  	case Message::GetElementIsSet:
6176  		return vs.ElementColour(static_cast&lt;Element&gt;(wParam)).has_value();
6177  	case Message::GetElementAllowsTranslucent:
6178  		return vs.ElementAllowsTranslucent(static_cast&lt;Element&gt;(wParam));
6179  	case Message::GetElementBaseColour:
6180  		return vs.elementBaseColours[static_cast&lt;Element&gt;(wParam)].value_or(ColourRGBA()).AsInteger();
6181  	case Message::SetFontLocale:
6182  		if (lParam) {
6183  			vs.SetFontLocaleName(ConstCharPtrFromSPtr(lParam));
6184  			InvalidateStyleRedraw();
6185  		}
6186  		break;
6187  	case Message::GetFontLocale:
6188  		return StringResult(lParam, vs.localeName.c_str());
6189  #ifdef INCLUDE_DEPRECATED_FEATURES
6190  	case SCI_SETSTYLEBITS:
6191  		vs.EnsureStyle(0xff);
6192  		break;
6193  	case SCI_GETSTYLEBITS:
6194  		return 8;
6195  #endif
6196  	case Message::SetLineState:
6197  		return pdoc-&gt;SetLineState(LineFromUPtr(wParam), static_cast&lt;int&gt;(lParam));
6198  	case Message::GetLineState:
6199  		return pdoc-&gt;GetLineState(LineFromUPtr(wParam));
6200  	case Message::GetMaxLineState:
6201  		return pdoc-&gt;GetMaxLineState();
6202  	case Message::GetCaretLineVisible:
6203  		return vs.ElementColour(Element::CaretLineBack) ? 1 : 0;
6204  	case Message::SetCaretLineVisible:
6205  		if (wParam) {
6206  			if (!vs.elementColours.count(Element::CaretLineBack)) {
6207  				vs.elementColours[Element::CaretLineBack] = ColourRGBA(0xFF, 0xFF, 0);
6208  				InvalidateStyleRedraw();
6209  			}
6210  		} else {
6211  			if (vs.ResetElement(Element::CaretLineBack)) {
6212  				InvalidateStyleRedraw();
6213  			}
6214  		}
6215  		break;
6216  	case Message::GetCaretLineVisibleAlways:
6217  		return vs.caretLine.alwaysShow;
6218  	case Message::SetCaretLineVisibleAlways:
6219  		vs.caretLine.alwaysShow = wParam != 0;
6220  		InvalidateStyleRedraw();
6221  		break;
6222  	case Message::GetCaretLineHighlightSubLine:
6223  		return vs.caretLine.subLine;
6224  	case Message::SetCaretLineHighlightSubLine:
6225  		vs.caretLine.subLine = wParam != 0;
6226  		InvalidateStyleRedraw();
6227  		break;
6228  	case Message::GetCaretLineFrame:
6229  		return vs.caretLine.frame;
6230  	case Message::SetCaretLineFrame:
6231  		vs.caretLine.frame = static_cast&lt;int&gt;(wParam);
6232  		InvalidateStyleRedraw();
6233  		break;
6234  	case Message::GetCaretLineBack:
6235  		return vs.ElementColourForced(Element::CaretLineBack).OpaqueRGB();
6236  	case Message::SetCaretLineBack:
6237  		vs.SetElementRGB(Element::CaretLineBack, static_cast&lt;int&gt;(wParam));
6238  		InvalidateStyleRedraw();
6239  		break;
6240  	case Message::GetCaretLineLayer:
6241  		return static_cast&lt;sptr_t&gt;(vs.caretLine.layer);
6242  	case Message::SetCaretLineLayer:
6243  		if (vs.caretLine.layer != static_cast&lt;Layer&gt;(wParam)) {
6244  			vs.caretLine.layer = static_cast&lt;Layer&gt;(wParam);
6245  			UpdateBaseElements();
6246  			InvalidateStyleRedraw();
6247  		}
6248  		break;
6249  	case Message::GetCaretLineBackAlpha:
6250  		if (vs.caretLine.layer == Layer::Base)
6251  			return static_cast&lt;sptr_t&gt;(Alpha::NoAlpha);
6252  		return vs.ElementColour(Element::CaretLineBack).value_or(ColourRGBA()).GetAlpha();
6253  	case Message::SetCaretLineBackAlpha: {
6254  			const Layer layerNew = (static_cast&lt;Alpha&gt;(wParam) == Alpha::NoAlpha) ? Layer::Base : Layer::OverText;
6255  			vs.caretLine.layer = layerNew;
6256  			if (vs.ElementColour(Element::CaretLineBack)) {
6257  				vs.SetElementAlpha(Element::CaretLineBack, static_cast&lt;int&gt;(wParam));
6258  			}
6259  			InvalidateStyleRedraw();
6260  		}
6261  		break;
6262  	case Message::VisibleFromDocLine:
6263  		return pcs-&gt;DisplayFromDoc(LineFromUPtr(wParam));
6264  	case Message::DocLineFromVisible:
6265  		return pcs-&gt;DocFromDisplay(LineFromUPtr(wParam));
6266  	case Message::WrapCount:
6267  		return WrapCount(LineFromUPtr(wParam));
6268  	case Message::SetFoldLevel: {
6269  			const int prev = pdoc-&gt;SetLevel(LineFromUPtr(wParam), static_cast&lt;int&gt;(lParam));
6270  			if (prev != static_cast&lt;int&gt;(lParam))
6271  				RedrawSelMargin();
6272  			return prev;
6273  		}
6274  	case Message::GetFoldLevel:
6275  		return pdoc-&gt;GetLevel(LineFromUPtr(wParam));
6276  	case Message::GetLastChild:
6277  		return pdoc-&gt;GetLastChild(LineFromUPtr(wParam), OptionalFoldLevel(lParam));
6278  	case Message::GetFoldParent:
6279  		return pdoc-&gt;GetFoldParent(LineFromUPtr(wParam));
6280  	case Message::ShowLines:
6281  		pcs-&gt;SetVisible(LineFromUPtr(wParam), lParam, true);
6282  		SetScrollBars();
6283  		Redraw();
6284  		break;
6285  	case Message::HideLines:
6286  		pcs-&gt;SetVisible(LineFromUPtr(wParam), lParam, false);
6287  		SetScrollBars();
6288  		Redraw();
6289  		break;
6290  	case Message::GetLineVisible:
6291  		return pcs-&gt;GetVisible(LineFromUPtr(wParam));
6292  	case Message::GetAllLinesVisible:
6293  		return pcs-&gt;HiddenLines() ? 0 : 1;
6294  	case Message::SetFoldExpanded:
6295  		SetFoldExpanded(LineFromUPtr(wParam), lParam != 0);
6296  		break;
6297  	case Message::GetFoldExpanded:
6298  		return pcs-&gt;GetExpanded(LineFromUPtr(wParam));
6299  	case Message::SetAutomaticFold:
6300  		foldAutomatic = static_cast&lt;AutomaticFold&gt;(wParam);
6301  		break;
6302  	case Message::GetAutomaticFold:
6303  		return static_cast&lt;sptr_t&gt;(foldAutomatic);
6304  	case Message::SetFoldFlags:
6305  		foldFlags = static_cast&lt;FoldFlag&gt;(wParam);
6306  		Redraw();
6307  		break;
6308  	case Message::ToggleFoldShowText:
6309  		pcs-&gt;SetFoldDisplayText(LineFromUPtr(wParam), ConstCharPtrFromSPtr(lParam));
6310  		FoldLine(LineFromUPtr(wParam), FoldAction::Toggle);
6311  		break;
6312  	case Message::FoldDisplayTextSetStyle:
6313  		foldDisplayTextStyle = static_cast&lt;FoldDisplayTextStyle&gt;(wParam);
6314  		Redraw();
6315  		break;
6316  	case Message::FoldDisplayTextGetStyle:
6317  		return static_cast&lt;sptr_t&gt;(foldDisplayTextStyle);
6318  	case Message::SetDefaultFoldDisplayText:
6319  		SetDefaultFoldDisplayText(ConstCharPtrFromSPtr(lParam));
6320  		Redraw();
6321  		break;
6322  	case Message::GetDefaultFoldDisplayText:
6323  		return StringResult(lParam, GetDefaultFoldDisplayText());
6324  	case Message::ToggleFold:
6325  		FoldLine(LineFromUPtr(wParam), FoldAction::Toggle);
6326  		break;
6327  	case Message::FoldLine:
6328  		FoldLine(LineFromUPtr(wParam), static_cast&lt;FoldAction&gt;(lParam));
6329  		break;
6330  	case Message::FoldChildren:
6331  		FoldExpand(LineFromUPtr(wParam), static_cast&lt;FoldAction&gt;(lParam), pdoc-&gt;GetFoldLevel(LineFromUPtr(wParam)));
6332  		break;
6333  	case Message::FoldAll:
6334  		FoldAll(static_cast&lt;FoldAction&gt;(wParam));
6335  		break;
6336  	case Message::ExpandChildren:
6337  		FoldExpand(LineFromUPtr(wParam), FoldAction::Expand, static_cast&lt;FoldLevel&gt;(lParam));
6338  		break;
6339  	case Message::ContractedFoldNext:
6340  		return ContractedFoldNext(LineFromUPtr(wParam));
6341  	case Message::EnsureVisible:
6342  		EnsureLineVisible(LineFromUPtr(wParam), false);
6343  		break;
6344  	case Message::EnsureVisibleEnforcePolicy:
6345  		EnsureLineVisible(LineFromUPtr(wParam), true);
6346  		break;
6347  	case Message::ScrollRange:
6348  		ScrollRange(SelectionRange(PositionFromUPtr(wParam), lParam));
6349  		break;
6350  	case Message::SearchAnchor:
6351  		SearchAnchor();
6352  		break;
6353  	case Message::SearchNext:
6354  	case Message::SearchPrev:
6355  		return SearchText(iMessage, wParam, lParam);
6356  	case Message::SetXCaretPolicy:
6357  		caretPolicies.x = CaretPolicySlop(wParam, lParam);
6358  		break;
6359  	case Message::SetYCaretPolicy:
6360  		caretPolicies.y = CaretPolicySlop(wParam, lParam);
6361  		break;
6362  	case Message::SetVisiblePolicy:
6363  		visiblePolicy = VisiblePolicySlop(wParam, lParam);
6364  		break;
6365  	case Message::LinesOnScreen:
6366  		return LinesOnScreen();
6367  	case Message::SetSelFore:
6368  		vs.elementColours[Element::SelectionText] = OptionalColour(wParam, lParam);
6369  		vs.elementColours[Element::SelectionAdditionalText] = OptionalColour(wParam, lParam);
6370  		InvalidateStyleRedraw();
6371  		break;
6372  	case Message::SetSelBack:
6373  		if (wParam) {
6374  			vs.SetElementRGB(Element::SelectionBack, static_cast&lt;int&gt;(lParam));
6375  			vs.SetElementRGB(Element::SelectionAdditionalBack, static_cast&lt;int&gt;(lParam));
6376  		} else {
6377  			vs.ResetElement(Element::SelectionBack);
6378  			vs.ResetElement(Element::SelectionAdditionalBack);
6379  		}
6380  		InvalidateStyleRedraw();
6381  		break;
6382  	case Message::SetSelAlpha: {
6383  			const Layer layerNew = (static_cast&lt;Alpha&gt;(wParam) == Alpha::NoAlpha) ? Layer::Base : Layer::OverText;
6384  			if (vs.selection.layer != layerNew) {
6385  			    vs.selection.layer = layerNew;
6386  			    UpdateBaseElements();
6387  			}
6388  			const int alpha = static_cast&lt;int&gt;(wParam);
6389  			vs.SetElementAlpha(Element::SelectionBack, alpha);
6390  			vs.SetElementAlpha(Element::SelectionAdditionalBack, alpha);
6391  			vs.SetElementAlpha(Element::SelectionSecondaryBack, alpha);
6392  			vs.SetElementAlpha(Element::SelectionInactiveBack, alpha);
6393  			InvalidateStyleRedraw();
6394  		}
6395  		break;
6396  	case Message::GetSelAlpha:
6397  		if (vs.selection.layer == Layer::Base)
6398  			return static_cast&lt;sptr_t&gt;(Alpha::NoAlpha);
6399  		return vs.ElementColourForced(Element::SelectionBack).GetAlpha();
6400  	case Message::GetSelEOLFilled:
6401  		return vs.selection.eolFilled;
6402  	case Message::SetSelEOLFilled:
<span onclick='openModal()' class='match'>6403  		vs.selection.eolFilled = wParam != 0;
6404  		InvalidateStyleRedraw();
6405  		break;
6406  	case Message::SetWhitespaceFore:
6407  		if (vs.SetElementColourOptional(Element::WhiteSpace, wParam, lParam)) {
</span>6408  			InvalidateStyleRedraw();
6409  		}
6410  		break;
6411  	case Message::SetWhitespaceBack:
6412  		if (vs.SetElementColourOptional(Element::WhiteSpaceBack, wParam, lParam)) {
6413  			InvalidateStyleRedraw();
6414  		}
6415  		break;
6416  	case Message::SetSelectionLayer:
6417  		if (vs.selection.layer != static_cast&lt;Layer&gt;(wParam)) {
6418  			vs.selection.layer = static_cast&lt;Layer&gt;(wParam);
6419  			UpdateBaseElements();
6420  			InvalidateStyleRedraw();
6421  		}
6422  		break;
6423  	case Message::GetSelectionLayer:
6424  		return static_cast&lt;sptr_t&gt;(vs.selection.layer);
6425  	case Message::SetCaretFore:
6426  		vs.elementColours[Element::Caret] = ColourRGBA::FromIpRGB(SPtrFromUPtr(wParam));
6427  		InvalidateStyleRedraw();
6428  		break;
6429  	case Message::GetCaretFore:
6430  		return vs.ElementColourForced(Element::Caret).OpaqueRGB();
6431  	case Message::SetCaretStyle:
6432  		if (static_cast&lt;CaretStyle&gt;(wParam) &lt;= (CaretStyle::Block | CaretStyle::OverstrikeBlock | CaretStyle::Curses | CaretStyle::BlockAfter))
6433  			vs.caret.style = static_cast&lt;CaretStyle&gt;(wParam);
6434  		else
6435  			vs.caret.style = CaretStyle::Line;
6436  		InvalidateStyleRedraw();
6437  		break;
6438  	case Message::GetCaretStyle:
6439  		return static_cast&lt;sptr_t&gt;(vs.caret.style);
6440  	case Message::SetCaretWidth:
6441  		vs.caret.width = std::clamp(static_cast&lt;int&gt;(wParam), 0, 20);
6442  		InvalidateStyleRedraw();
6443  		break;
6444  	case Message::GetCaretWidth:
6445  		return vs.caret.width;
6446  	case Message::AssignCmdKey:
6447  		kmap.AssignCmdKey(static_cast&lt;Keys&gt;(LowShortFromWParam(wParam)),
6448  			static_cast&lt;KeyMod&gt;(HighShortFromWParam(wParam)), static_cast&lt;Message&gt;(lParam));
6449  		break;
6450  	case Message::ClearCmdKey:
6451  		kmap.AssignCmdKey(static_cast&lt;Keys&gt;(LowShortFromWParam(wParam)),
6452  			static_cast&lt;KeyMod&gt;(HighShortFromWParam(wParam)), Message::Null);
6453  		break;
6454  	case Message::ClearAllCmdKeys:
6455  		kmap.Clear();
6456  		break;
6457  	case Message::IndicSetStyle:
6458  		if (wParam &lt;= IndicatorMax) {
6459  			vs.indicators[wParam].sacNormal.style = static_cast&lt;IndicatorStyle&gt;(lParam);
6460  			vs.indicators[wParam].sacHover.style = static_cast&lt;IndicatorStyle&gt;(lParam);
6461  			InvalidateStyleRedraw();
6462  		}
6463  		break;
6464  	case Message::IndicGetStyle:
6465  		return (wParam &lt;= IndicatorMax) ?
6466  			static_cast&lt;sptr_t&gt;(vs.indicators[wParam].sacNormal.style) : 0;
6467  	case Message::IndicSetFore:
6468  		if (wParam &lt;= IndicatorMax) {
6469  			vs.indicators[wParam].sacNormal.fore = ColourRGBA::FromIpRGB(lParam);
6470  			vs.indicators[wParam].sacHover.fore = ColourRGBA::FromIpRGB(lParam);
6471  			InvalidateStyleRedraw();
6472  		}
6473  		break;
6474  	case Message::IndicGetFore:
6475  		return (wParam &lt;= IndicatorMax) ?
6476  			vs.indicators[wParam].sacNormal.fore.OpaqueRGB() : 0;
6477  	case Message::IndicSetHoverStyle:
6478  		if (wParam &lt;= IndicatorMax) {
6479  			vs.indicators[wParam].sacHover.style = static_cast&lt;IndicatorStyle&gt;(lParam);
6480  			InvalidateStyleRedraw();
6481  		}
6482  		break;
6483  	case Message::IndicGetHoverStyle:
6484  		return (wParam &lt;= IndicatorMax) ?
6485  			static_cast&lt;sptr_t&gt;(vs.indicators[wParam].sacHover.style) : 0;
6486  	case Message::IndicSetHoverFore:
6487  		if (wParam &lt;= IndicatorMax) {
6488  			vs.indicators[wParam].sacHover.fore = ColourRGBA::FromIpRGB(lParam);
6489  			InvalidateStyleRedraw();
6490  		}
6491  		break;
6492  	case Message::IndicGetHoverFore:
6493  		return (wParam &lt;= IndicatorMax) ?
6494  			vs.indicators[wParam].sacHover.fore.OpaqueRGB() : 0;
6495  	case Message::IndicSetFlags:
6496  		if (wParam &lt;= IndicatorMax) {
6497  			vs.indicators[wParam].SetFlags(static_cast&lt;IndicFlag&gt;(lParam));
6498  			InvalidateStyleRedraw();
6499  		}
6500  		break;
6501  	case Message::IndicGetFlags:
6502  		return (wParam &lt;= IndicatorMax) ?
6503  			static_cast&lt;sptr_t&gt;(vs.indicators[wParam].Flags()) : 0;
6504  	case Message::IndicSetUnder:
6505  		if (wParam &lt;= IndicatorMax) {
6506  			vs.indicators[wParam].under = lParam != 0;
6507  			InvalidateStyleRedraw();
6508  		}
6509  		break;
6510  	case Message::IndicGetUnder:
6511  		return (wParam &lt;= IndicatorMax) ?
6512  			vs.indicators[wParam].under : 0;
6513  	case Message::IndicSetAlpha:
6514  		if (wParam &lt;= IndicatorMax &amp;&amp; lParam &gt;=0 &amp;&amp; lParam &lt;= 255) {
6515  			vs.indicators[wParam].fillAlpha = static_cast&lt;int&gt;(lParam);
6516  			InvalidateStyleRedraw();
6517  		}
6518  		break;
6519  	case Message::IndicGetAlpha:
6520  		return (wParam &lt;= IndicatorMax)
6521  			? vs.indicators[wParam].fillAlpha : 0;
6522  	case Message::IndicSetOutlineAlpha:
6523  		if (wParam &lt;= IndicatorMax &amp;&amp; lParam &gt;=0 &amp;&amp; lParam &lt;= 255) {
6524  			vs.indicators[wParam].outlineAlpha = static_cast&lt;int&gt;(lParam);
6525  			InvalidateStyleRedraw();
6526  		}
6527  		break;
6528  	case Message::IndicGetOutlineAlpha:
6529  		return (wParam &lt;= IndicatorMax) ? vs.indicators[wParam].outlineAlpha : 0;
6530  	case Message::IndicSetStrokeWidth:
6531  		if (wParam &lt;= IndicatorMax &amp;&amp; lParam &gt;= 0 &amp;&amp; lParam &lt;= 1000) {
6532  			vs.indicators[wParam].strokeWidth = lParam / 100.0f;
6533  			InvalidateStyleRedraw();
6534  		}
6535  		break;
6536  	case Message::IndicGetStrokeWidth:
6537  		if (wParam &lt;= IndicatorMax) {
6538  			return std::lround(vs.indicators[wParam].strokeWidth * 100);
6539  		}
6540  		break;
6541  	case Message::SetIndicatorCurrent:
6542  		pdoc-&gt;DecorationSetCurrentIndicator(static_cast&lt;int&gt;(wParam));
6543  		break;
6544  	case Message::GetIndicatorCurrent:
6545  		return pdoc-&gt;decorations-&gt;GetCurrentIndicator();
6546  	case Message::SetIndicatorValue:
6547  		pdoc-&gt;decorations-&gt;SetCurrentValue(static_cast&lt;int&gt;(wParam));
6548  		break;
6549  	case Message::GetIndicatorValue:
6550  		return pdoc-&gt;decorations-&gt;GetCurrentValue();
6551  	case Message::IndicatorFillRange:
6552  		pdoc-&gt;DecorationFillRange(PositionFromUPtr(wParam),
6553  			pdoc-&gt;decorations-&gt;GetCurrentValue(), lParam);
6554  		break;
6555  	case Message::IndicatorClearRange:
6556  		pdoc-&gt;DecorationFillRange(PositionFromUPtr(wParam), 0,
6557  			lParam);
6558  		break;
6559  	case Message::IndicatorAllOnFor:
6560  		return pdoc-&gt;decorations-&gt;AllOnFor(PositionFromUPtr(wParam));
6561  	case Message::IndicatorValueAt:
6562  		return pdoc-&gt;decorations-&gt;ValueAt(static_cast&lt;int&gt;(wParam), lParam);
6563  	case Message::IndicatorStart:
6564  		return pdoc-&gt;decorations-&gt;Start(static_cast&lt;int&gt;(wParam), lParam);
6565  	case Message::IndicatorEnd:
6566  		return pdoc-&gt;decorations-&gt;End(static_cast&lt;int&gt;(wParam), lParam);
6567  	case Message::LineDown:
6568  	case Message::LineDownExtend:
6569  	case Message::ParaDown:
6570  	case Message::ParaDownExtend:
6571  	case Message::LineUp:
6572  	case Message::LineUpExtend:
6573  	case Message::ParaUp:
6574  	case Message::ParaUpExtend:
6575  	case Message::CharLeft:
6576  	case Message::CharLeftExtend:
6577  	case Message::CharRight:
6578  	case Message::CharRightExtend:
6579  	case Message::WordLeft:
6580  	case Message::WordLeftExtend:
6581  	case Message::WordRight:
6582  	case Message::WordRightExtend:
6583  	case Message::WordLeftEnd:
6584  	case Message::WordLeftEndExtend:
6585  	case Message::WordRightEnd:
6586  	case Message::WordRightEndExtend:
6587  	case Message::Home:
6588  	case Message::HomeExtend:
6589  	case Message::LineEnd:
6590  	case Message::LineEndExtend:
6591  	case Message::HomeWrap:
6592  	case Message::HomeWrapExtend:
6593  	case Message::LineEndWrap:
6594  	case Message::LineEndWrapExtend:
6595  	case Message::DocumentStart:
6596  	case Message::DocumentStartExtend:
6597  	case Message::DocumentEnd:
6598  	case Message::DocumentEndExtend:
6599  	case Message::ScrollToStart:
6600  	case Message::ScrollToEnd:
6601  	case Message::StutteredPageUp:
6602  	case Message::StutteredPageUpExtend:
6603  	case Message::StutteredPageDown:
6604  	case Message::StutteredPageDownExtend:
6605  	case Message::PageUp:
6606  	case Message::PageUpExtend:
6607  	case Message::PageDown:
6608  	case Message::PageDownExtend:
6609  	case Message::EditToggleOvertype:
6610  	case Message::Cancel:
6611  	case Message::DeleteBack:
6612  	case Message::Tab:
6613  	case Message::BackTab:
6614  	case Message::NewLine:
6615  	case Message::FormFeed:
6616  	case Message::VCHome:
6617  	case Message::VCHomeExtend:
6618  	case Message::VCHomeWrap:
6619  	case Message::VCHomeWrapExtend:
6620  	case Message::VCHomeDisplay:
6621  	case Message::VCHomeDisplayExtend:
6622  	case Message::ZoomIn:
6623  	case Message::ZoomOut:
6624  	case Message::DelWordLeft:
6625  	case Message::DelWordRight:
6626  	case Message::DelWordRightEnd:
6627  	case Message::DelLineLeft:
6628  	case Message::DelLineRight:
6629  	case Message::LineCopy:
6630  	case Message::LineCut:
6631  	case Message::LineDelete:
6632  	case Message::LineTranspose:
6633  	case Message::LineReverse:
6634  	case Message::LineDuplicate:
6635  	case Message::LowerCase:
6636  	case Message::UpperCase:
6637  	case Message::LineScrollDown:
6638  	case Message::LineScrollUp:
6639  	case Message::WordPartLeft:
6640  	case Message::WordPartLeftExtend:
6641  	case Message::WordPartRight:
6642  	case Message::WordPartRightExtend:
6643  	case Message::DeleteBackNotLine:
6644  	case Message::HomeDisplay:
6645  	case Message::HomeDisplayExtend:
6646  	case Message::LineEndDisplay:
6647  	case Message::LineEndDisplayExtend:
6648  	case Message::LineDownRectExtend:
6649  	case Message::LineUpRectExtend:
6650  	case Message::CharLeftRectExtend:
6651  	case Message::CharRightRectExtend:
6652  	case Message::HomeRectExtend:
6653  	case Message::VCHomeRectExtend:
6654  	case Message::LineEndRectExtend:
6655  	case Message::PageUpRectExtend:
6656  	case Message::PageDownRectExtend:
6657  	case Message::SelectionDuplicate:
6658  		return KeyCommand(iMessage);
6659  	case Message::BraceHighlight:
6660  		SetBraceHighlight(PositionFromUPtr(wParam), lParam, StyleBraceLight);
6661  		break;
6662  	case Message::BraceHighlightIndicator:
6663  		if (lParam &gt;= 0 &amp;&amp; static_cast&lt;size_t&gt;(lParam) &lt;= IndicatorMax) {
6664  			vs.braceHighlightIndicatorSet = wParam != 0;
6665  			vs.braceHighlightIndicator = static_cast&lt;int&gt;(lParam);
6666  		}
6667  		break;
6668  	case Message::BraceBadLight:
6669  		SetBraceHighlight(PositionFromUPtr(wParam), -1, StyleBraceBad);
6670  		break;
6671  	case Message::BraceBadLightIndicator:
6672  		if (lParam &gt;= 0 &amp;&amp; static_cast&lt;size_t&gt;(lParam) &lt;= IndicatorMax) {
6673  			vs.braceBadLightIndicatorSet = wParam != 0;
6674  			vs.braceBadLightIndicator = static_cast&lt;int&gt;(lParam);
6675  		}
6676  		break;
6677  	case Message::BraceMatch:
6678  		return pdoc-&gt;BraceMatch(PositionFromUPtr(wParam), lParam, 0, false);
6679  	case Message::BraceMatchNext:
6680  		return pdoc-&gt;BraceMatch(PositionFromUPtr(wParam), 0, lParam, true);
6681  	case Message::GetViewEOL:
6682  		return vs.viewEOL;
6683  	case Message::SetViewEOL:
6684  		vs.viewEOL = wParam != 0;
6685  		InvalidateStyleRedraw();
6686  		break;
6687  	case Message::SetZoom: {
6688  			const int zoomLevel = static_cast&lt;int&gt;(wParam);
6689  			if (zoomLevel != vs.zoomLevel) {
6690  				vs.zoomLevel = zoomLevel;
6691  				InvalidateStyleRedraw();
6692  				NotifyZoom();
6693  			}
6694  			break;
6695  		}
6696  	case Message::GetZoom:
6697  		return vs.zoomLevel;
6698  	case Message::GetEdgeColumn:
6699  		return vs.theEdge.column;
6700  	case Message::SetEdgeColumn:
6701  		vs.theEdge.column = static_cast&lt;int&gt;(wParam);
6702  		InvalidateStyleRedraw();
6703  		break;
6704  	case Message::GetEdgeMode:
6705  		return static_cast&lt;sptr_t&gt;(vs.edgeState);
6706  	case Message::SetEdgeMode:
6707  		vs.edgeState = static_cast&lt;EdgeVisualStyle&gt;(wParam);
6708  		InvalidateStyleRedraw();
6709  		break;
6710  	case Message::GetEdgeColour:
6711  		return vs.theEdge.colour.OpaqueRGB();
6712  	case Message::SetEdgeColour:
6713  		vs.theEdge.colour = ColourRGBA::FromIpRGB(SPtrFromUPtr(wParam));
6714  		InvalidateStyleRedraw();
6715  		break;
6716  	case Message::MultiEdgeAddLine:
6717  		vs.AddMultiEdge(static_cast&lt;int&gt;(wParam), ColourRGBA::FromIpRGB(lParam));
6718  		InvalidateStyleRedraw();
6719  		break;
6720  	case Message::MultiEdgeClearAll:
6721  		std::vector&lt;EdgeProperties&gt;().swap(vs.theMultiEdge); 
6722  		InvalidateStyleRedraw();
6723  		break;
6724  	case Message::GetMultiEdgeColumn: {
6725  			const size_t which = wParam;
6726  			if (which &gt;= vs.theMultiEdge.size()) {
6727  				return -1;
6728  			}
6729  			return vs.theMultiEdge[which].column;
6730  		}
6731  	case Message::GetAccessibility:
6732  		return static_cast&lt;sptr_t&gt;(Accessibility::Disabled);
6733  	case Message::SetAccessibility:
6734  		break;
6735  	case Message::GetDocPointer:
6736  		return reinterpret_cast&lt;sptr_t&gt;(pdoc);
6737  	case Message::SetDocPointer:
6738  		CancelModes();
6739  		SetDocPointer(static_cast&lt;Document *&gt;(PtrFromSPtr(lParam)));
6740  		return 0;
6741  	case Message::CreateDocument: {
6742  			Document *doc = new Document(static_cast&lt;DocumentOption&gt;(lParam));
6743  			doc-&gt;AddRef();
6744  			doc-&gt;Allocate(PositionFromUPtr(wParam));
6745  			pcs = ContractionStateCreate(pdoc-&gt;IsLarge());
6746  			return reinterpret_cast&lt;sptr_t&gt;(doc);
6747  		}
6748  	case Message::AddRefDocument:
6749  		(static_cast&lt;Document *&gt;(PtrFromSPtr(lParam)))-&gt;AddRef();
6750  		break;
6751  	case Message::ReleaseDocument:
6752  		(static_cast&lt;Document *&gt;(PtrFromSPtr(lParam)))-&gt;Release();
6753  		break;
6754  	case Message::GetDocumentOptions:
6755  		return static_cast&lt;sptr_t&gt;(pdoc-&gt;Options());
6756  	case Message::CreateLoader: {
6757  			Document *doc = new Document(static_cast&lt;DocumentOption&gt;(lParam));
6758  			doc-&gt;AddRef();
6759  			doc-&gt;Allocate(PositionFromUPtr(wParam));
6760  			doc-&gt;SetUndoCollection(false);
6761  			pcs = ContractionStateCreate(pdoc-&gt;IsLarge());
6762  			return reinterpret_cast&lt;sptr_t&gt;(static_cast&lt;ILoader *&gt;(doc));
6763  		}
6764  	case Message::SetModEventMask:
6765  		modEventMask = static_cast&lt;ModificationFlags&gt;(wParam);
6766  		return 0;
6767  	case Message::GetModEventMask:
6768  		return static_cast&lt;sptr_t&gt;(modEventMask);
6769  	case Message::SetCommandEvents:
6770  		commandEvents = static_cast&lt;bool&gt;(wParam);
6771  		return 0;
6772  	case Message::GetCommandEvents:
6773  		return commandEvents;
6774  	case Message::ConvertEOLs:
6775  		pdoc-&gt;ConvertLineEnds(static_cast&lt;EndOfLine&gt;(wParam));
6776  		SetSelection(sel.MainCaret(), sel.MainAnchor());	
6777  		return 0;
6778  	case Message::SetLengthForEncode:
6779  		lengthForEncode = PositionFromUPtr(wParam);
6780  		return 0;
6781  	case Message::SelectionIsRectangle:
6782  		return sel.selType == Selection::SelTypes::rectangle ? 1 : 0;
6783  	case Message::SetSelectionMode: {
6784  			switch (static_cast&lt;SelectionMode&gt;(wParam)) {
6785  			case SelectionMode::Stream:
6786  				sel.SetMoveExtends(!sel.MoveExtends() || (sel.selType != Selection::SelTypes::stream));
6787  				sel.selType = Selection::SelTypes::stream;
6788  				break;
6789  			case SelectionMode::Rectangle:
6790  				sel.SetMoveExtends(!sel.MoveExtends() || (sel.selType != Selection::SelTypes::rectangle));
6791  				sel.selType = Selection::SelTypes::rectangle;
6792  				sel.Rectangular() = sel.RangeMain(); 
6793  				break;
6794  			case SelectionMode::Lines:
6795  				sel.SetMoveExtends(!sel.MoveExtends() || (sel.selType != Selection::SelTypes::lines));
6796  				sel.selType = Selection::SelTypes::lines;
6797  				SetSelection(sel.RangeMain().caret, sel.RangeMain().anchor); 
6798  				break;
6799  			case SelectionMode::Thin:
6800  				sel.SetMoveExtends(!sel.MoveExtends() || (sel.selType != Selection::SelTypes::thin));
6801  				sel.selType = Selection::SelTypes::thin;
6802  				break;
6803  			default:
6804  				sel.SetMoveExtends(!sel.MoveExtends() || (sel.selType != Selection::SelTypes::stream));
6805  				sel.selType = Selection::SelTypes::stream;
6806  			}
6807  			InvalidateWholeSelection();
6808  			break;
6809  		}
6810  	case Message::GetSelectionMode:
6811  		switch (sel.selType) {
6812  		case Selection::SelTypes::stream:
6813  			return static_cast&lt;sptr_t&gt;(SelectionMode::Stream);
6814  		case Selection::SelTypes::rectangle:
6815  			return static_cast&lt;sptr_t&gt;(SelectionMode::Rectangle);
6816  		case Selection::SelTypes::lines:
6817  			return static_cast&lt;sptr_t&gt;(SelectionMode::Lines);
6818  		case Selection::SelTypes::thin:
6819  			return static_cast&lt;sptr_t&gt;(SelectionMode::Thin);
6820  		default:	
6821  			return static_cast&lt;sptr_t&gt;(SelectionMode::Stream);
6822  		}
6823  	case Message::GetMoveExtendsSelection:
6824  		return sel.MoveExtends();
6825  	case Message::GetLineSelStartPosition:
6826  	case Message::GetLineSelEndPosition: {
6827  			const SelectionSegment segmentLine(
6828  				SelectionPosition(pdoc-&gt;LineStart(LineFromUPtr(wParam))),
6829  				SelectionPosition(pdoc-&gt;LineEnd(LineFromUPtr(wParam))));
6830  			for (size_t r=0; r&lt;sel.Count(); r++) {
6831  				const SelectionSegment portion = sel.Range(r).Intersect(segmentLine);
6832  				if (portion.start.IsValid()) {
6833  					return (iMessage == Message::GetLineSelStartPosition) ? portion.start.Position() : portion.end.Position();
6834  				}
6835  			}
6836  			return Sci::invalidPosition;
6837  		}
6838  	case Message::SetOvertype:
6839  		if (inOverstrike != (wParam != 0)) {
6840  			inOverstrike = wParam != 0;
6841  			ContainerNeedsUpdate(Update::Selection);
6842  			ShowCaretAtCurrentPosition();
6843  			SetIdle(true);
6844  		}
6845  		break;
6846  	case Message::GetOvertype:
6847  		return inOverstrike ? 1 : 0;
6848  	case Message::SetFocus:
6849  		SetFocusState(wParam != 0);
6850  		break;
6851  	case Message::GetFocus:
6852  		return hasFocus;
6853  	case Message::SetStatus:
6854  		errorStatus = static_cast&lt;Status&gt;(wParam);
6855  		break;
6856  	case Message::GetStatus:
6857  		return static_cast&lt;sptr_t&gt;(errorStatus);
6858  	case Message::SetMouseDownCaptures:
6859  		mouseDownCaptures = wParam != 0;
6860  		break;
6861  	case Message::GetMouseDownCaptures:
6862  		return mouseDownCaptures;
6863  	case Message::SetMouseWheelCaptures:
6864  		mouseWheelCaptures = wParam != 0;
6865  		break;
6866  	case Message::GetMouseWheelCaptures:
6867  		return mouseWheelCaptures;
6868  	case Message::SetCursor:
6869  		cursorMode = static_cast&lt;CursorShape&gt;(wParam);
6870  		DisplayCursor(Window::Cursor::text);
6871  		break;
6872  	case Message::GetCursor:
6873  		return static_cast&lt;sptr_t&gt;(cursorMode);
6874  	case Message::SetControlCharSymbol:
6875  		vs.controlCharSymbol = static_cast&lt;int&gt;(wParam);
6876  		InvalidateStyleRedraw();
6877  		break;
6878  	case Message::GetControlCharSymbol:
6879  		return vs.controlCharSymbol;
6880  	case Message::SetRepresentation:
6881  		reprs.SetRepresentation(ConstCharPtrFromUPtr(wParam), ConstCharPtrFromSPtr(lParam));
6882  		break;
6883  	case Message::GetRepresentation: {
6884  			const Representation *repr = reprs.RepresentationFromCharacter(
6885  				ConstCharPtrFromUPtr(wParam));
6886  			if (repr) {
6887  				return StringResult(lParam, repr-&gt;stringRep.c_str());
6888  			}
6889  			return 0;
6890  		}
6891  	case Message::ClearRepresentation:
6892  		reprs.ClearRepresentation(ConstCharPtrFromUPtr(wParam));
6893  		break;
6894  	case Message::ClearAllRepresentations:
6895  		SetRepresentations();
6896  		break;
6897  	case Message::SetRepresentationAppearance:
6898  		reprs.SetRepresentationAppearance(ConstCharPtrFromUPtr(wParam), static_cast&lt;RepresentationAppearance&gt;(lParam));
6899  		break;
6900  	case Message::GetRepresentationAppearance: {
6901  			const Representation *repr = reprs.RepresentationFromCharacter(
6902  				ConstCharPtrFromUPtr(wParam));
6903  			if (repr) {
6904  				return static_cast&lt;sptr_t&gt;(repr-&gt;appearance);
6905  			}
6906  			return 0;
6907  		}
6908  	case Message::SetRepresentationColour:
6909  		reprs.SetRepresentationColour(ConstCharPtrFromUPtr(wParam), ColourRGBA(static_cast&lt;int&gt;(lParam)));
6910  		break;
6911  	case Message::GetRepresentationColour: {
6912  			const Representation *repr = reprs.RepresentationFromCharacter(
6913  				ConstCharPtrFromUPtr(wParam));
6914  			if (repr) {
6915  				return repr-&gt;colour.AsInteger();
6916  			}
6917  			return 0;
6918  		}
6919  	case Message::StartRecord:
6920  		recordingMacro = true;
6921  		return 0;
6922  	case Message::StopRecord:
6923  		recordingMacro = false;
6924  		return 0;
6925  	case Message::MoveCaretInsideView:
6926  		MoveCaretInsideView();
6927  		break;
6928  	case Message::SetFoldMarginColour:
6929  		vs.foldmarginColour = OptionalColour(wParam, lParam);
6930  		InvalidateStyleRedraw();
6931  		break;
6932  	case Message::SetFoldMarginHiColour:
6933  		vs.foldmarginHighlightColour = OptionalColour(wParam, lParam);
6934  		InvalidateStyleRedraw();
6935  		break;
6936  	case Message::SetHotspotActiveFore:
6937  		if (vs.SetElementColourOptional(Element::HotSpotActive, wParam, lParam)) {
6938  			InvalidateStyleRedraw();
6939  		}
6940  		break;
6941  	case Message::GetHotspotActiveFore:
6942  		return vs.ElementColour(Element::HotSpotActive).value_or(ColourRGBA()).OpaqueRGB();
6943  	case Message::SetHotspotActiveBack:
6944  		if (vs.SetElementColourOptional(Element::HotSpotActiveBack, wParam, lParam)) {
6945  			InvalidateStyleRedraw();
6946  		}
6947  		break;
6948  	case Message::GetHotspotActiveBack:
6949  		return vs.ElementColour(Element::HotSpotActiveBack).value_or(ColourRGBA()).OpaqueRGB();
6950  	case Message::SetHotspotActiveUnderline:
6951  		vs.hotspotUnderline = wParam != 0;
6952  		InvalidateStyleRedraw();
6953  		break;
6954  	case Message::GetHotspotActiveUnderline:
6955  		return vs.hotspotUnderline ? 1 : 0;
6956  	case Message::SetHotspotSingleLine:
6957  		hotspotSingleLine = wParam != 0;
6958  		InvalidateStyleRedraw();
6959  		break;
6960  	case Message::GetHotspotSingleLine:
6961  		return hotspotSingleLine ? 1 : 0;
6962  	case Message::SetPasteConvertEndings:
6963  		convertPastes = wParam != 0;
6964  		break;
6965  	case Message::GetPasteConvertEndings:
6966  		return convertPastes ? 1 : 0;
6967  	case Message::GetCharacterPointer:
6968  		return reinterpret_cast&lt;sptr_t&gt;(pdoc-&gt;BufferPointer());
6969  	case Message::GetRangePointer:
6970  		return reinterpret_cast&lt;sptr_t&gt;(pdoc-&gt;RangePointer(
6971  			PositionFromUPtr(wParam), lParam));
6972  	case Message::GetGapPosition:
6973  		return pdoc-&gt;GapPosition();
6974  	case Message::SetChangeHistory:
6975  		changeHistoryOption = static_cast&lt;ChangeHistoryOption&gt;(wParam);
6976  		pdoc-&gt;ChangeHistorySet(wParam &amp; 1);
6977  		break;
6978  	case Message::GetChangeHistory:
6979  		return static_cast&lt;sptr_t&gt;(changeHistoryOption);
6980  	case Message::SetExtraAscent:
6981  		vs.extraAscent = static_cast&lt;int&gt;(wParam);
6982  		InvalidateStyleRedraw();
6983  		break;
6984  	case Message::GetExtraAscent:
6985  		return vs.extraAscent;
6986  	case Message::SetExtraDescent:
6987  		vs.extraDescent = static_cast&lt;int&gt;(wParam);
6988  		InvalidateStyleRedraw();
6989  		break;
6990  	case Message::GetExtraDescent:
6991  		return vs.extraDescent;
6992  	case Message::MarginSetStyleOffset:
6993  		vs.marginStyleOffset = static_cast&lt;int&gt;(wParam);
6994  		InvalidateStyleRedraw();
6995  		break;
6996  	case Message::MarginGetStyleOffset:
6997  		return vs.marginStyleOffset;
6998  	case Message::SetMarginOptions:
6999  		marginOptions = static_cast&lt;MarginOption&gt;(wParam);
7000  		break;
7001  	case Message::GetMarginOptions:
7002  		return static_cast&lt;sptr_t&gt;(marginOptions);
7003  	case Message::MarginSetText:
7004  		pdoc-&gt;MarginSetText(LineFromUPtr(wParam), ConstCharPtrFromSPtr(lParam));
7005  		break;
7006  	case Message::MarginGetText: {
7007  			const StyledText st = pdoc-&gt;MarginStyledText(LineFromUPtr(wParam));
7008  			return BytesResult(lParam, reinterpret_cast&lt;const unsigned char *&gt;(st.text), st.length);
7009  		}
7010  	case Message::MarginSetStyle:
7011  		pdoc-&gt;MarginSetStyle(LineFromUPtr(wParam), static_cast&lt;int&gt;(lParam));
7012  		break;
7013  	case Message::MarginGetStyle: {
7014  			const StyledText st = pdoc-&gt;MarginStyledText(LineFromUPtr(wParam));
7015  			return st.style;
7016  		}
7017  	case Message::MarginSetStyles:
7018  		pdoc-&gt;MarginSetStyles(LineFromUPtr(wParam), ConstUCharPtrFromSPtr(lParam));
7019  		break;
7020  	case Message::MarginGetStyles: {
7021  			const StyledText st = pdoc-&gt;MarginStyledText(LineFromUPtr(wParam));
7022  			return BytesResult(lParam, st.styles, st.length);
7023  		}
7024  	case Message::MarginTextClearAll:
7025  		pdoc-&gt;MarginClearAll();
7026  		break;
7027  	case Message::AnnotationSetText:
7028  		pdoc-&gt;AnnotationSetText(LineFromUPtr(wParam), ConstCharPtrFromSPtr(lParam));
7029  		break;
7030  	case Message::AnnotationGetText: {
7031  			const StyledText st = pdoc-&gt;AnnotationStyledText(LineFromUPtr(wParam));
7032  			return BytesResult(lParam, reinterpret_cast&lt;const unsigned char *&gt;(st.text), st.length);
7033  		}
7034  	case Message::AnnotationGetStyle: {
7035  			const StyledText st = pdoc-&gt;AnnotationStyledText(LineFromUPtr(wParam));
7036  			return st.style;
7037  		}
7038  	case Message::AnnotationSetStyle:
7039  		pdoc-&gt;AnnotationSetStyle(LineFromUPtr(wParam), static_cast&lt;int&gt;(lParam));
7040  		break;
7041  	case Message::AnnotationSetStyles:
7042  		pdoc-&gt;AnnotationSetStyles(LineFromUPtr(wParam), ConstUCharPtrFromSPtr(lParam));
7043  		break;
7044  	case Message::AnnotationGetStyles: {
7045  			const StyledText st = pdoc-&gt;AnnotationStyledText(LineFromUPtr(wParam));
7046  			return BytesResult(lParam, st.styles, st.length);
7047  		}
7048  	case Message::AnnotationGetLines:
7049  		return pdoc-&gt;AnnotationLines(LineFromUPtr(wParam));
7050  	case Message::AnnotationClearAll:
7051  		pdoc-&gt;AnnotationClearAll();
7052  		break;
7053  	case Message::AnnotationSetVisible:
7054  		SetAnnotationVisible(static_cast&lt;AnnotationVisible&gt;(wParam));
7055  		break;
7056  	case Message::AnnotationGetVisible:
7057  		return static_cast&lt;sptr_t&gt;(vs.annotationVisible);
7058  	case Message::AnnotationSetStyleOffset:
7059  		vs.annotationStyleOffset = static_cast&lt;int&gt;(wParam);
7060  		InvalidateStyleRedraw();
7061  		break;
7062  	case Message::AnnotationGetStyleOffset:
7063  		return vs.annotationStyleOffset;
7064  	case Message::EOLAnnotationSetText:
7065  		pdoc-&gt;EOLAnnotationSetText(LineFromUPtr(wParam), ConstCharPtrFromSPtr(lParam));
7066  		break;
7067  	case Message::EOLAnnotationGetText: {
7068  			const StyledText st = pdoc-&gt;EOLAnnotationStyledText(LineFromUPtr(wParam));
7069  			return BytesResult(lParam, reinterpret_cast&lt;const unsigned char *&gt;(st.text), st.length);
7070  		}
7071  	case Message::EOLAnnotationGetStyle: {
7072  			const StyledText st = pdoc-&gt;EOLAnnotationStyledText(LineFromUPtr(wParam));
7073  			return st.style;
7074  		}
7075  	case Message::EOLAnnotationSetStyle:
7076  		pdoc-&gt;EOLAnnotationSetStyle(LineFromUPtr(wParam), static_cast&lt;int&gt;(lParam));
7077  		break;
7078  	case Message::EOLAnnotationClearAll:
7079  		pdoc-&gt;EOLAnnotationClearAll();
7080  		break;
7081  	case Message::EOLAnnotationSetVisible:
7082  		SetEOLAnnotationVisible(static_cast&lt;EOLAnnotationVisible&gt;(wParam));
7083  		break;
7084  	case Message::EOLAnnotationGetVisible:
7085  		return static_cast&lt;sptr_t&gt;(vs.eolAnnotationVisible);
7086  	case Message::EOLAnnotationSetStyleOffset:
7087  		vs.eolAnnotationStyleOffset = static_cast&lt;int&gt;(wParam);
7088  		InvalidateStyleRedraw();
7089  		break;
7090  	case Message::EOLAnnotationGetStyleOffset:
7091  		return vs.eolAnnotationStyleOffset;
7092  	case Message::ReleaseAllExtendedStyles:
7093  		vs.ReleaseAllExtendedStyles();
7094  		break;
7095  	case Message::AllocateExtendedStyles:
7096  		return vs.AllocateExtendedStyles(static_cast&lt;int&gt;(wParam));
7097  	case Message::SupportsFeature:
7098  		return SupportsFeature(static_cast&lt;Supports&gt;(wParam));
7099  	case Message::AddUndoAction:
7100  		pdoc-&gt;AddUndoAction(PositionFromUPtr(wParam),
7101  			FlagSet(static_cast&lt;UndoFlags&gt;(lParam), UndoFlags::MayCoalesce));
7102  		break;
7103  	case Message::SetMouseSelectionRectangularSwitch:
7104  		mouseSelectionRectangularSwitch = wParam != 0;
7105  		break;
7106  	case Message::GetMouseSelectionRectangularSwitch:
7107  		return mouseSelectionRectangularSwitch;
7108  	case Message::SetMultipleSelection:
7109  		multipleSelection = wParam != 0;
7110  		InvalidateCaret();
7111  		break;
7112  	case Message::GetMultipleSelection:
7113  		return multipleSelection;
7114  	case Message::SetAdditionalSelectionTyping:
7115  		additionalSelectionTyping = wParam != 0;
7116  		InvalidateCaret();
7117  		break;
7118  	case Message::GetAdditionalSelectionTyping:
7119  		return additionalSelectionTyping;
7120  	case Message::SetMultiPaste:
7121  		multiPasteMode = static_cast&lt;MultiPaste&gt;(wParam);
7122  		break;
7123  	case Message::GetMultiPaste:
7124  		return static_cast&lt;sptr_t&gt;(multiPasteMode);
7125  	case Message::SetAdditionalCaretsBlink:
7126  		view.additionalCaretsBlink = wParam != 0;
7127  		InvalidateCaret();
7128  		break;
7129  	case Message::GetAdditionalCaretsBlink:
7130  		return view.additionalCaretsBlink;
7131  	case Message::SetAdditionalCaretsVisible:
7132  		view.additionalCaretsVisible = wParam != 0;
7133  		InvalidateCaret();
7134  		break;
7135  	case Message::GetAdditionalCaretsVisible:
7136  		return view.additionalCaretsVisible;
7137  	case Message::GetSelections:
7138  		return sel.Count();
7139  	case Message::GetSelectionEmpty:
7140  		return sel.Empty();
7141  	case Message::ClearSelections:
7142  		sel.Clear();
7143  		ContainerNeedsUpdate(Update::Selection);
7144  		Redraw();
7145  		break;
7146  	case Message::SetSelection:
7147  		sel.SetSelection(SelectionRange(PositionFromUPtr(wParam), lParam));
7148  		Redraw();
7149  		break;
7150  	case Message::AddSelection:
7151  		sel.AddSelection(SelectionRange(PositionFromUPtr(wParam), lParam));
7152  		ContainerNeedsUpdate(Update::Selection);
7153  		Redraw();
7154  		break;
7155  	case Message::DropSelectionN:
7156  		sel.DropSelection(wParam);
7157  		ContainerNeedsUpdate(Update::Selection);
7158  		Redraw();
7159  		break;
7160  	case Message::SetMainSelection:
7161  		sel.SetMain(wParam);
7162  		ContainerNeedsUpdate(Update::Selection);
7163  		Redraw();
7164  		break;
7165  	case Message::GetMainSelection:
7166  		return sel.Main();
7167  	case Message::SetSelectionNCaret:
7168  	case Message::SetSelectionNAnchor:
7169  	case Message::SetSelectionNCaretVirtualSpace:
7170  	case Message::SetSelectionNAnchorVirtualSpace:
7171  	case Message::SetSelectionNStart:
7172  	case Message::SetSelectionNEnd:
7173  		SetSelectionNMessage(iMessage, wParam, lParam);
7174  		break;
7175  	case Message::GetSelectionNCaret:
7176  		return sel.Range(wParam).caret.Position();
7177  	case Message::GetSelectionNAnchor:
7178  		return sel.Range(wParam).anchor.Position();
7179  	case Message::GetSelectionNCaretVirtualSpace:
7180  		return sel.Range(wParam).caret.VirtualSpace();
7181  	case Message::GetSelectionNAnchorVirtualSpace:
7182  		return sel.Range(wParam).anchor.VirtualSpace();
7183  	case Message::GetSelectionNStart:
7184  		return sel.Range(wParam).Start().Position();
7185  	case Message::GetSelectionNStartVirtualSpace:
7186  		return sel.Range(wParam).Start().VirtualSpace();
7187  	case Message::GetSelectionNEnd:
7188  		return sel.Range(wParam).End().Position();
7189  	case Message::GetSelectionNEndVirtualSpace:
7190  		return sel.Range(wParam).End().VirtualSpace();
7191  	case Message::SetRectangularSelectionCaret:
7192  		if (!sel.IsRectangular())
7193  			sel.Clear();
7194  		sel.selType = Selection::SelTypes::rectangle;
7195  		sel.Rectangular().caret.SetPosition(PositionFromUPtr(wParam));
7196  		SetRectangularRange();
7197  		Redraw();
7198  		break;
7199  	case Message::GetRectangularSelectionCaret:
7200  		return sel.Rectangular().caret.Position();
7201  	case Message::SetRectangularSelectionAnchor:
7202  		if (!sel.IsRectangular())
7203  			sel.Clear();
7204  		sel.selType = Selection::SelTypes::rectangle;
7205  		sel.Rectangular().anchor.SetPosition(PositionFromUPtr(wParam));
7206  		SetRectangularRange();
7207  		Redraw();
7208  		break;
7209  	case Message::GetRectangularSelectionAnchor:
7210  		return sel.Rectangular().anchor.Position();
7211  	case Message::SetRectangularSelectionCaretVirtualSpace:
7212  		if (!sel.IsRectangular())
7213  			sel.Clear();
7214  		sel.selType = Selection::SelTypes::rectangle;
7215  		sel.Rectangular().caret.SetVirtualSpace(PositionFromUPtr(wParam));
7216  		SetRectangularRange();
7217  		Redraw();
7218  		break;
7219  	case Message::GetRectangularSelectionCaretVirtualSpace:
7220  		return sel.Rectangular().caret.VirtualSpace();
7221  	case Message::SetRectangularSelectionAnchorVirtualSpace:
7222  		if (!sel.IsRectangular())
7223  			sel.Clear();
7224  		sel.selType = Selection::SelTypes::rectangle;
7225  		sel.Rectangular().anchor.SetVirtualSpace(PositionFromUPtr(wParam));
7226  		SetRectangularRange();
7227  		Redraw();
7228  		break;
7229  	case Message::GetRectangularSelectionAnchorVirtualSpace:
7230  		return sel.Rectangular().anchor.VirtualSpace();
7231  	case Message::SetVirtualSpaceOptions:
7232  		virtualSpaceOptions = static_cast&lt;VirtualSpace&gt;(wParam);
7233  		break;
7234  	case Message::GetVirtualSpaceOptions:
7235  		return static_cast&lt;sptr_t&gt;(virtualSpaceOptions);
7236  	case Message::SetAdditionalSelFore:
7237  		vs.elementColours[Element::SelectionAdditionalText] = ColourRGBA::FromIpRGB(SPtrFromUPtr(wParam));
7238  		InvalidateStyleRedraw();
7239  		break;
7240  	case Message::SetAdditionalSelBack:
7241  		vs.SetElementRGB(Element::SelectionAdditionalBack, static_cast&lt;int&gt;(wParam));
7242  		InvalidateStyleRedraw();
7243  		break;
7244  	case Message::SetAdditionalSelAlpha:
7245  		vs.SetElementAlpha(Element::SelectionAdditionalBack, static_cast&lt;int&gt;(wParam));
7246  		InvalidateStyleRedraw();
7247  		break;
7248  	case Message::GetAdditionalSelAlpha:
7249  		if (vs.selection.layer == Layer::Base)
7250  			return static_cast&lt;sptr_t&gt;(Alpha::NoAlpha);
7251  		return vs.ElementColourForced(Element::SelectionAdditionalBack).GetAlpha();
7252  	case Message::SetAdditionalCaretFore:
7253  		vs.elementColours[Element::CaretAdditional] = ColourRGBA::FromIpRGB(SPtrFromUPtr(wParam));
7254  		InvalidateStyleRedraw();
7255  		break;
7256  	case Message::GetAdditionalCaretFore:
7257  		return vs.ElementColourForced(Element::CaretAdditional).OpaqueRGB();
7258  	case Message::RotateSelection:
7259  		sel.RotateMain();
7260  		InvalidateWholeSelection();
7261  		break;
7262  	case Message::SwapMainAnchorCaret:
7263  		InvalidateSelection(sel.RangeMain());
7264  		sel.RangeMain().Swap();
7265  		break;
7266  	case Message::MultipleSelectAddNext:
7267  		MultipleSelectAdd(AddNumber::one);
7268  		break;
7269  	case Message::MultipleSelectAddEach:
7270  		MultipleSelectAdd(AddNumber::each);
7271  		break;
7272  	case Message::ChangeLexerState:
7273  		pdoc-&gt;ChangeLexerState(PositionFromUPtr(wParam), lParam);
7274  		break;
7275  	case Message::SetIdentifier:
7276  		SetCtrlID(static_cast&lt;int&gt;(wParam));
7277  		break;
7278  	case Message::GetIdentifier:
7279  		return GetCtrlID();
7280  	case Message::SetTechnology:
7281  		break;
7282  	case Message::GetTechnology:
7283  		return static_cast&lt;sptr_t&gt;(technology);
7284  	case Message::CountCharacters:
7285  		return pdoc-&gt;CountCharacters(PositionFromUPtr(wParam), lParam);
7286  	case Message::CountCodeUnits:
7287  		return pdoc-&gt;CountUTF16(PositionFromUPtr(wParam), lParam);
7288  	default:
7289  		return DefWndProc(iMessage, wParam, lParam);
7290  	}
7291  	return 0;
7292  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Editor.cxx</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Editor.cxx</div>
                </div>
                <div class="column column_space"><pre><code>6225  		vs.caretLine.subLine = wParam != 0;
6226  		InvalidateStyleRedraw();
6227  		break;
6228  	case Message::GetCaretLineFrame:
6229  		return vs.caretLine.frame;
</pre></code></div>
                <div class="column column_space"><pre><code>6403  		vs.selection.eolFilled = wParam != 0;
6404  		InvalidateStyleRedraw();
6405  		break;
6406  	case Message::SetWhitespaceFore:
6407  		if (vs.SetElementColourOptional(Element::WhiteSpace, wParam, lParam)) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    