
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 61, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-batch_classification.cpp</h3>
            <pre><code>1  #include <caffe/caffe.hpp>
2  #ifdef USE_OPENCV
3  #include <opencv2/core/core.hpp>
4  #include <opencv2/highgui/highgui.hpp>
5  #include <opencv2/imgproc/imgproc.hpp>
6  #endif  
7  #include <algorithm>
8  #include <iosfwd>
9  #include <memory>
10  #include <string>
11  #include <utility>
12  #include <vector>
13  #include <gflags/gflags.h>
14  #ifdef USE_OPENCV
15  using namespace caffe;  
16  using std::string;
17  using std::cout;
18  using std::cerr;
19  using std::endl;
20  using std::vector;
21  DEFINE_string(model, "",
22      "Required; The model definition protocol buffer text file.");
23  DEFINE_string(weights, "",
24      "Required; The pretrained weights.");
25  DEFINE_string(input, "",
26      "Required; File that contain the path of input images line by line");
27  DEFINE_string(label_file, "",
28      "Required; The label file.");
29  DEFINE_string(engine, "",
30      "Optional; Engine can only be CAFFE | MKL2017 | MKLDNN");
31  DEFINE_string(mean_file, "",
32      "Optional; The mean file used to subtract from the input image.");
33  DEFINE_string(mean_value, "104,117,123",
34      "Optional; If specified, can be one value or can be same as image channels"
35      " - would subtract from the corresponding channel). Separated by ','.");
36  DEFINE_int32(batch_size, 1,
37      "Optional; batch size, default 1");
38  typedef std::pair<string, float> Prediction;
39  class Classifier {
40      public:
41          Classifier(const string& model_file,
42                  const string& trained_file,
43                  const string& mean_file,
44                  const string& mean_value,
45                  const string& label_file,
46                  const string& engine,
47                  const size_t batch_size,
48                  const size_t topN = 5
49                  );
50          vector<vector<Prediction> > ClassifyBatch(vector<cv::Mat>& imgs);
51      private:
52          void SetMean(const string& mean_file, const string& mean_value);
53          vector<float> PredictBatch(vector<cv::Mat>& imgs);
54          void WrapInputLayerBatch(vector<vector<cv::Mat> >* input_channels_batch);
55          void WriteImgToInput(const vector<cv::Mat>& imgs, vector<vector<cv::Mat> >* input_channels_batch);
56          void Preprocess(cv::Mat& img);
57          void PreprocessBatch(vector<cv::Mat>& imgs);
58      private:
59          shared_ptr<Net<float> > net_;
60          cv::Size input_geometry_;
61          int num_channels_;
62          cv::Mat mean_;
63          size_t batch_size_;
64          size_t topN_;
65          std::vector<string> labels_;
66  };
67  Classifier::Classifier(const string& model_file,
68          const string& trained_file,
69          const string& mean_file,
70          const string& mean_value,
71          const string& label_file,
72          const string& engine,
73          const size_t batch_size,
74          const size_t topN
75          ) {
76  #ifdef CPU_ONLY
77      Caffe::set_mode(Caffe::CPU);
78  #else
79      Caffe::set_mode(Caffe::GPU);
80  #endif
81      net_.reset(new Net<float>(model_file, TEST, 0, NULL, NULL, engine));
82      net_->CopyTrainedLayersFrom(trained_file);
83      CHECK_EQ(net_->num_inputs(), 1) << "Network should have exactly one input.";
84      CHECK_EQ(net_->num_outputs(), 1) << "Network should have exactly one output.";
85      Blob<float>* input_layer = net_->input_blobs()[0];
86      num_channels_ = input_layer->channels();
87      CHECK(num_channels_ == 3 || num_channels_ == 1)
88          << "Input layer should have 1 or 3 channels.";
89      input_geometry_ = cv::Size(input_layer->width(), input_layer->height());
90      SetMean(mean_file, mean_value);
91      batch_size_ = batch_size;
92      topN_ = topN;
93      if(!label_file.empty()) {
94      std::ifstream labels(label_file.c_str());
95      CHECK(labels) << "Unable to open labels file " << label_file;
96      string line;
97      while (std::getline(labels, line))
98          labels_.push_back(string(line));
99      Blob<float>* output_layer = net_->output_blobs()[0];
100      CHECK_EQ(labels_.size(), output_layer->channels())
101          << "Number of labels is different from the output layer dimension.";
102      }
103  }
104  static bool PairCompare(const std::pair<float, int>& lhs,
105          const std::pair<float, int>& rhs) {
106      return lhs.first > rhs.first;
107  }
108  static vector<int> Argmax(const vector<float>& v, int N) {
109      vector<std::pair<float, int> > pairs;
110      for (size_t i = 0; i < v.size(); ++i)
111          pairs.push_back(std::make_pair(v[i], i));
112      std::partial_sort(pairs.begin(), pairs.begin() + N, pairs.end(), PairCompare);
113      vector<int> result;
114      for (int i = 0; i < N; ++i)
115          result.push_back(pairs[i].second);
116      return result;
117  }
118  vector<vector<Prediction> > Classifier::ClassifyBatch(vector<cv::Mat>& imgs) {
119      vector<float> output_batch = PredictBatch(imgs);
120      vector<vector<Prediction> > predictionsBatch;
121      int output_channels = net_->output_blobs()[0]->channels();
122      for (size_t i = 0; i < batch_size_; ++i) {
123          vector<float> output(output_batch.begin() + i*output_channels, output_batch.begin()+(i+1)*output_channels);
124          vector<int> maxN = Argmax(output, topN_);
125          vector<Prediction>  predictions;
126          for (int i = 0; i < topN_; ++i) {
127              int idx = maxN[i];
128              if(labels_.empty()) {
129                  predictions.push_back(std::make_pair(std::to_string(idx), output[idx]));
130              } else{
131                  predictions.push_back(std::make_pair(labels_[idx], output[idx]));
132              }
133          }
134          predictionsBatch.push_back(predictions);
135      }
136      return predictionsBatch;
137  }
138  void Classifier::SetMean(const string& mean_file, const string& mean_value) {
139      cv::Scalar channel_mean;
140      if(!mean_file.empty()) {
141          BlobProto blob_proto;
142          ReadProtoFromBinaryFileOrDie(mean_file.c_str(), &blob_proto);
143          Blob<float> mean_blob;
144          mean_blob.FromProto(blob_proto);
145          CHECK_EQ(mean_blob.channels(), num_channels_)
146              << "Number of channels of mean file doesn't match input layer.";
147          vector<cv::Mat> channels;
148          float* data = mean_blob.mutable_cpu_data();
149          for (int i = 0; i < num_channels_; ++i) {
150              cv::Mat channel(mean_blob.height(), mean_blob.width(), CV_32FC1, data);
151              channels.push_back(channel);
152              data += mean_blob.height() * mean_blob.width();
153          }
154          cv::Mat mean;
155          cv::merge(channels, mean);
156          channel_mean = cv::mean(mean);
157          mean_ = cv::Mat(input_geometry_, mean.type(), channel_mean);
158      }
159      if (!mean_value.empty()) {
160          stringstream ss(mean_value);
161          vector<float> values;
162          string item;
163          while (getline(ss, item, ',')) {
164              float value = std::atof(item.c_str());
165              values.push_back(value);
166          }
167          CHECK(values.size() == 1 || values.size() == num_channels_) <<
168              "Specify either 1 mean_value or as many as channels: " << num_channels_;
169          std::vector<cv::Mat> channels;
170          for (int i = 0; i < num_channels_; ++i) {
171              cv::Mat channel(input_geometry_.height, input_geometry_.width, CV_32FC1,
172                      cv::Scalar(values[i]));
173              channels.push_back(channel);
174          }
175          cv::merge(channels, mean_);
176      }
177  }
178  vector<float> Classifier::PredictBatch(vector<cv::Mat>& imgs) {
179      Blob<float>* input_layer = net_->input_blobs()[0];
180      input_layer->Reshape(batch_size_, num_channels_,
181              input_geometry_.height, input_geometry_.width);
182      net_->Reshape();
183      vector<vector<cv::Mat> > input_channels_batch;
184      WrapInputLayerBatch(&input_channels_batch);
185      PreprocessBatch(imgs);
186      WriteImgToInput(imgs, &input_channels_batch);
187      net_->Forward();
188      Blob<float>* output_layer = net_->output_blobs()[0];
189      const float* begin = output_layer->cpu_data();
190      const float* end = begin + output_layer->channels() * batch_size_;
191      printf("output_layer->channels: %d\n", output_layer->channels());
192      return vector<float>(begin, end);
193  }
194  void Classifier::WrapInputLayerBatch(vector<vector<cv::Mat> >* input_channels_batch) {
195      Blob<float>* input_layer = net_->input_blobs()[0];
196      int width = input_layer->width();
197      int height = input_layer->height();
198      float* input_data = input_layer->mutable_cpu_data();
199      int num = input_layer->num();
200      for( int j = 0; j < num; ++j) {
201          vector<cv::Mat> input_channels;
202          for (int i = 0; i < input_layer->channels(); ++i) {
203              cv::Mat channel(height, width, CV_32FC1, input_data);
204              input_channels.push_back(channel);
205              input_data += width * height;
206          }
207          input_channels_batch->push_back(input_channels);
208      }
209  }
210  void Classifier::WriteImgToInput(const vector<cv::Mat>& imgs,
211          vector<vector<cv::Mat> >* input_channels_batch)
212  {
213      for(size_t i=0; i<batch_size_; ++i) {
214          cv::split(imgs[i], input_channels_batch->at(i));
215      }
216  }
217  void Classifier::PreprocessBatch(vector<cv::Mat>& imgs) {
218      for(size_t i=0; i<imgs.size(); ++i) {
219          Preprocess(imgs[i]);
220      }
221  }
222  void Classifier::Preprocess(cv::Mat& img) {
223      cv::Mat sample;
224      if (img.channels() == 3 && num_channels_ == 1)
225          cv::cvtColor(img, sample, cv::COLOR_BGR2GRAY);
226      else if (img.channels() == 4 && num_channels_ == 1)
227          cv::cvtColor(img, sample, cv::COLOR_BGRA2GRAY);
228      else if (img.channels() == 4 && num_channels_ == 3)
229          cv::cvtColor(img, sample, cv::COLOR_BGRA2BGR);
230      else if (img.channels() == 1 && num_channels_ == 3)
231          cv::cvtColor(img, sample, cv::COLOR_GRAY2BGR);
232      else
233          sample = img;
<span onclick='openModal()' class='match'>234      cv::Mat sample_resized;
235      if (sample.size() != input_geometry_)
236          cv::resize(sample, sample_resized, input_geometry_);
237      else
238          sample_resized = sample;
239      cv::Mat sample_float;
240      if (num_channels_ == 3)
241          sample_resized.convertTo(sample_float, CV_32FC3);
242      else
243          sample_resized.convertTo(sample_float, CV_32FC1);
244      cv::subtract(sample_float, mean_, img);
</span>245  }
246  vector<cv::Mat> loadImgBatch(vector<string> imgNames) {
247      vector<cv::Mat> imgs;
248      for(size_t i=0; i<imgNames.size(); ++i) {
249          cv::Mat img = cv::imread(imgNames[i], -1);
250          CHECK(!img.empty()) << "Unable to decode image " << imgNames[i];
251          imgs.push_back(img);
252      }
253      return imgs;
254  }
255  void printPrediction(vector<Prediction> predictions) {
256      for (size_t i = 0; i < predictions.size(); ++i) {
257          Prediction p = predictions[i];
258          cout << std::fixed << std::setprecision(4) << p.second << " - \""
259              << p.first << "\"" << endl;
260      }
261  }
262  void printPredictionsBatch(vector<string> imgNames,
263          vector<vector<Prediction> > predictionsBatch) {
264      for( size_t i = 0; i < predictionsBatch.size(); ++i) {
265          cout << "---------- "<< i + 1 <<": Prediction for "
266              << imgNames[i] << " ----------" << endl;
267          printPrediction(predictionsBatch[i]);
268      }
269  }
270  vector<string> readImgListFromPath(string file) {
271      vector<string> rawImgNames;
272      std::ifstream input_lines(file.c_str());
273      CHECK(input_lines) << "Unable to open file " << file;
274      string line;
275      while (std::getline(input_lines, line))
276          rawImgNames.push_back(string(line));
277      return rawImgNames;
278  }
279  int main(int argc, char** argv) {
280      ::google::InitGoogleLogging(argv[0]);
281  #ifndef GFLAGS_GFLAGS_H_
282      namespace gflags = google;
283  #endif
284      gflags::SetUsageMessage("Image classification.\n"
285          "Usage:\n"
286          "batch_classification <args>\n"
287          "Example: ./batch_classification --model <model path> --weights <weights path> --input <input.txt> --batch_size <num>"
288          );
289      gflags::ParseCommandLineFlags(&argc, &argv, true);
290      CHECK_GT(FLAGS_model.size(), 0) << "Need a model definition to score.";
291      CHECK_GT(FLAGS_weights.size(), 0) << "Need model weights to score.";
292      CHECK_GT(FLAGS_input.size(), 0) << "Need model weights to score.";
293      cout<<"Use batch size: "<< FLAGS_batch_size << endl;
294      if (FLAGS_mean_file.empty()) {
295          cout<<"Use mean value: "<< FLAGS_mean_value<<endl;
296      }else{
297          cout<<"Use mean file: "<<FLAGS_mean_file<<endl;
298      }
299  #ifdef USE_MLSL
300      caffe::mn::init(&argc,&argv);
301  #endif
302      Classifier classifier(FLAGS_model, FLAGS_weights, FLAGS_mean_file,
303              FLAGS_mean_value, FLAGS_label_file, FLAGS_engine, FLAGS_batch_size);
304      vector<string> rawImgNames = readImgListFromPath(FLAGS_input);
305      if(rawImgNames.size() > 0 && rawImgNames.size() < FLAGS_batch_size) {
306          while(rawImgNames.size() < FLAGS_batch_size) {
307              rawImgNames.insert(rawImgNames.end(), rawImgNames.begin(), rawImgNames.end());
308          }
309      }
310      vector<string> imgNames(rawImgNames.begin(), rawImgNames.begin() + FLAGS_batch_size);
311      vector<cv::Mat> imgs = loadImgBatch(rawImgNames);
312      vector<vector<Prediction> > predictionsBatch = classifier.ClassifyBatch(imgs);
313      printPredictionsBatch(imgNames, predictionsBatch);
314      return 0;
315  }
316  #else
317  int main(int argc, char** argv) {
318      LOG(FATAL) << "This example requires OpenCV; compile with USE_OPENCV.";
319  }
320  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-classification.cpp</h3>
            <pre><code>1  #include <caffe/caffe.hpp>
2  #ifdef USE_OPENCV
3  #include <opencv2/core/core.hpp>
4  #include <opencv2/highgui/highgui.hpp>
5  #include <opencv2/imgproc/imgproc.hpp>
6  #endif  
7  #include <algorithm>
8  #include <iosfwd>
9  #include <memory>
10  #include <string>
11  #include <utility>
12  #include <vector>
13  #ifdef USE_OPENCV
14  using namespace caffe;  
15  using std::string;
16  typedef std::pair<string, float> Prediction;
17  class Classifier {
18   public:
19    Classifier(const string& model_file,
20               const string& trained_file,
21               const string& mean_file,
22               const string& label_file,
23               const string& engine);
24    std::vector<Prediction> Classify(const cv::Mat& img, int N = 5);
25   private:
26    void SetMean(const string& mean_file);
27    std::vector<float> Predict(const cv::Mat& img);
28    void WrapInputLayer(std::vector<cv::Mat>* input_channels);
29    void Preprocess(const cv::Mat& img,
30                    std::vector<cv::Mat>* input_channels);
31   private:
32    shared_ptr<Net<float> > net_;
33    cv::Size input_geometry_;
34    int num_channels_;
35    cv::Mat mean_;
36    std::vector<string> labels_;
37  };
38  Classifier::Classifier(const string& model_file,
39                         const string& trained_file,
40                         const string& mean_file,
41                         const string& label_file,
42                         const string& engine) {
43  #ifdef CPU_ONLY
44    Caffe::set_mode(Caffe::CPU);
45  #else
46    Caffe::set_mode(Caffe::GPU);
47  #endif
48    net_.reset(new Net<float>(model_file, TEST, 0, NULL, NULL, engine));
49    net_->CopyTrainedLayersFrom(trained_file);
50    CHECK_EQ(net_->num_inputs(), 1) << "Network should have exactly one input.";
51    CHECK_EQ(net_->num_outputs(), 1) << "Network should have exactly one output.";
52    Blob<float>* input_layer = net_->input_blobs()[0];
53    num_channels_ = input_layer->channels();
54    CHECK(num_channels_ == 3 || num_channels_ == 1)
55      << "Input layer should have 1 or 3 channels.";
56    input_geometry_ = cv::Size(input_layer->width(), input_layer->height());
57    SetMean(mean_file);
58    std::ifstream labels(label_file.c_str());
59    CHECK(labels) << "Unable to open labels file " << label_file;
60    string line;
61    while (std::getline(labels, line))
62      labels_.push_back(string(line));
63    Blob<float>* output_layer = net_->output_blobs()[0];
64    CHECK_EQ(labels_.size(), output_layer->channels())
65      << "Number of labels is different from the output layer dimension.";
66  }
67  static bool PairCompare(const std::pair<float, int>& lhs,
68                          const std::pair<float, int>& rhs) {
69    return lhs.first > rhs.first;
70  }
71  static std::vector<int> Argmax(const std::vector<float>& v, int N) {
72    std::vector<std::pair<float, int> > pairs;
73    for (size_t i = 0; i < v.size(); ++i)
74      pairs.push_back(std::make_pair(v[i], i));
75    std::partial_sort(pairs.begin(), pairs.begin() + N, pairs.end(), PairCompare);
76    std::vector<int> result;
77    for (int i = 0; i < N; ++i)
78      result.push_back(pairs[i].second);
79    return result;
80  }
81  std::vector<Prediction> Classifier::Classify(const cv::Mat& img, int N) {
82    std::vector<float> output = Predict(img);
83    N = std::min<int>(labels_.size(), N);
84    std::vector<int> maxN = Argmax(output, N);
85    std::vector<Prediction> predictions;
86    for (int i = 0; i < N; ++i) {
87      int idx = maxN[i];
88      predictions.push_back(std::make_pair(labels_[idx], output[idx]));
89    }
90    return predictions;
91  }
92  void Classifier::SetMean(const string& mean_file) {
93    BlobProto blob_proto;
94    ReadProtoFromBinaryFileOrDie(mean_file.c_str(), &blob_proto);
95    Blob<float> mean_blob;
96    mean_blob.FromProto(blob_proto);
97    CHECK_EQ(mean_blob.channels(), num_channels_)
98      << "Number of channels of mean file doesn't match input layer.";
99    std::vector<cv::Mat> channels;
100    float* data = mean_blob.mutable_cpu_data();
101    for (int i = 0; i < num_channels_; ++i) {
102      cv::Mat channel(mean_blob.height(), mean_blob.width(), CV_32FC1, data);
103      channels.push_back(channel);
104      data += mean_blob.height() * mean_blob.width();
105    }
106    cv::Mat mean;
107    cv::merge(channels, mean);
108    cv::Scalar channel_mean = cv::mean(mean);
109    mean_ = cv::Mat(input_geometry_, mean.type(), channel_mean);
110  }
111  std::vector<float> Classifier::Predict(const cv::Mat& img) {
112    Blob<float>* input_layer = net_->input_blobs()[0];
113    input_layer->Reshape(1, num_channels_,
114                         input_geometry_.height, input_geometry_.width);
115    net_->Reshape();
116    std::vector<cv::Mat> input_channels;
117    WrapInputLayer(&input_channels);
118    Preprocess(img, &input_channels);
119    net_->Forward();
120    Blob<float>* output_layer = net_->output_blobs()[0];
121    const float* begin = output_layer->cpu_data();
122    const float* end = begin + output_layer->channels();
123    return std::vector<float>(begin, end);
124  }
125  void Classifier::WrapInputLayer(std::vector<cv::Mat>* input_channels) {
126    Blob<float>* input_layer = net_->input_blobs()[0];
127    int width = input_layer->width();
128    int height = input_layer->height();
129    float* input_data = input_layer->mutable_cpu_data();
130    for (int i = 0; i < input_layer->channels(); ++i) {
131      cv::Mat channel(height, width, CV_32FC1, input_data);
132      input_channels->push_back(channel);
133      input_data += width * height;
134    }
135  }
136  void Classifier::Preprocess(const cv::Mat& img,
137                              std::vector<cv::Mat>* input_channels) {
138    cv::Mat sample;
139    if (img.channels() == 3 && num_channels_ == 1)
140      cv::cvtColor(img, sample, cv::COLOR_BGR2GRAY);
141    else if (img.channels() == 4 && num_channels_ == 1)
142      cv::cvtColor(img, sample, cv::COLOR_BGRA2GRAY);
143    else if (img.channels() == 4 && num_channels_ == 3)
144      cv::cvtColor(img, sample, cv::COLOR_BGRA2BGR);
145    else if (img.channels() == 1 && num_channels_ == 3)
146      cv::cvtColor(img, sample, cv::COLOR_GRAY2BGR);
147    else
148      sample = img;
<span onclick='openModal()' class='match'>149    cv::Mat sample_resized;
150    if (sample.size() != input_geometry_)
151      cv::resize(sample, sample_resized, input_geometry_);
152    else
153      sample_resized = sample;
154    cv::Mat sample_float;
155    if (num_channels_ == 3)
156      sample_resized.convertTo(sample_float, CV_32FC3);
157    else
158      sample_resized.convertTo(sample_float, CV_32FC1);
159    cv::Mat sample_normalized;
</span>160    cv::subtract(sample_float, mean_, sample_normalized);
161    cv::split(sample_normalized, *input_channels);
162    CHECK(reinterpret_cast<float*>(input_channels->at(0).data)
163          == net_->input_blobs()[0]->cpu_data())
164      << "Input channels are not wrapping the input layer of the network.";
165  }
166  int main(int argc, char** argv) {
167    if (argc < 6) {
168      std::cerr << "Usage: " << argv[0]
169                << " deploy.prototxt network.caffemodel"
170                << " mean.binaryproto labels.txt img.jpg [CAFFE|MKL2017|MKLDNN]" << std::endl;
171      return 1;
172    }
173    ::google::InitGoogleLogging(argv[0]);
174    string model_file   = argv[1];
175    string trained_file = argv[2];
176    string mean_file    = argv[3];
177    string label_file   = argv[4];
178    string file         = argv[5];
179    string engine = "";
180    if (argc > 6) {
181      engine = argv[6];
182    }
183  #ifdef USE_MLSL
184    caffe::mn::init(&argc,&argv);
185  #endif
186    Classifier classifier(model_file, trained_file, mean_file, label_file, engine);
187    std::cout << "---------- Prediction for "
188              << file << " ----------" << std::endl;
189    cv::Mat img = cv::imread(file, -1);
190    CHECK(!img.empty()) << "Unable to decode image " << file;
191    std::vector<Prediction> predictions = classifier.Classify(img);
192    for (size_t i = 0; i < predictions.size(); ++i) {
193      Prediction p = predictions[i];
194      std::cout << std::fixed << std::setprecision(4) << p.second << " - \""
195                << p.first << "\"" << std::endl;
196    }
197  }
198  #else
199  int main(int argc, char** argv) {
200    LOG(FATAL) << "This example requires OpenCV; compile with USE_OPENCV.";
201  }
202  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-batch_classification.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-classification.cpp</div>
                </div>
                <div class="column column_space"><pre><code>234      cv::Mat sample_resized;
235      if (sample.size() != input_geometry_)
236          cv::resize(sample, sample_resized, input_geometry_);
237      else
238          sample_resized = sample;
239      cv::Mat sample_float;
240      if (num_channels_ == 3)
241          sample_resized.convertTo(sample_float, CV_32FC3);
242      else
243          sample_resized.convertTo(sample_float, CV_32FC1);
244      cv::subtract(sample_float, mean_, img);
</pre></code></div>
                <div class="column column_space"><pre><code>149    cv::Mat sample_resized;
150    if (sample.size() != input_geometry_)
151      cv::resize(sample, sample_resized, input_geometry_);
152    else
153      sample_resized = sample;
154    cv::Mat sample_float;
155    if (num_channels_ == 3)
156      sample_resized.convertTo(sample_float, CV_32FC3);
157    else
158      sample_resized.convertTo(sample_float, CV_32FC1);
159    cv::Mat sample_normalized;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    