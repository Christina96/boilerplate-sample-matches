
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-bowfl.cpp</h3>
            <pre><code>1  void TBowFl::LoadHtmlTxt(
2   PBowDocBs BowDocBs, const TStr& FPath, TIntV& NewDIdV,
3   const bool& RecurseDirP, const int& MxDocs,
4   const bool& SaveDocP, const PNotify& Notify) {
5    TStr LcNrFPath=TStr::GetNrFPath(FPath).GetLc();
6    Notify->OnStatus("Creating Bow from file-path " + FPath + " ...");
7    TFFile FFile(FPath, "", RecurseDirP);
8    TStr FNm; int Docs=0; NewDIdV.Clr();
9    while (FFile.Next(FNm)){
10      Docs++; if ((MxDocs!=-1)&&(Docs>MxDocs)){break;}
11      Notify->OnStatus(TStr::Fmt("%d\r", Docs));
12      if (TFile::Exists(FNm)) { 
13          TStr DocNm=FNm.GetLc();
14          if (DocNm.IsPrefix(LcNrFPath)){
15            DocNm=DocNm.GetSubStr(LcNrFPath.Len(), DocNm.Len()-1);}
16          TStrV CatNmV; TStr CatNm;
17          if (DocNm.IsChIn('/')){
18            TStr Str; DocNm.SplitOnCh(CatNm, '/', Str);
19          } else if (DocNm.IsChIn('\\')){
20            TStr Str; DocNm.SplitOnCh(CatNm, '\\', Str);
21          }
22          if (!CatNm.Empty()){
23            CatNmV.Add(CatNm);}
24          TStr DocStr=TStr::LoadTxt(FNm);
25          NewDIdV.Add(BowDocBs->AddHtmlDoc(DocNm, CatNmV, DocStr, SaveDocP));
26      }
27    }
28    Notify->OnStatus(TStr::Fmt("%d", Docs));
29    Notify->OnStatus("Done.");
30    BowDocBs->AssertOk();
31  }
32  PBowDocBs TBowFl::LoadHtmlTxt(
33   const TStr& FPath, const bool& RecurseDirP, const int& MxDocs,
34   const PSwSet& SwSet, const PStemmer& Stemmer,
35   const int& MxNGramLen, const int& MnNGramFq,
36   const bool& SaveDocP, const PNotify& Notify){
37    PNGramBs NGramBs;
38    if (!((MxNGramLen==1)&&(MnNGramFq==1))){
39      NGramBs=TNGramBs::GetNGramBsFromHtmlFPathV(
40       FPath, RecurseDirP, MxDocs,
41       MxNGramLen, MnNGramFq, SwSet, Stemmer);
42    }
43    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
44    TIntV NewDIdV; LoadHtmlTxt(BowDocBs, FPath, NewDIdV,
45        RecurseDirP, MxDocs, SaveDocP, Notify);
46    return BowDocBs;
47  }
48  PBowDocBs TBowFl::LoadHtmlTxt(
49   const TStr& FPath, const bool& RecurseDirP, const int& MxDocs,
50   const TStr& SwSetTypeNm, const TStr& StemmerTypeNm,
51   const int& MxNGramLen, const int& MnNGramFq,
52   const bool& SaveDocP, const PNotify& Notify){
53    PSwSet SwSet=TSwSet::GetSwSet(SwSetTypeNm);
54    PStemmer Stemmer=TStemmer::GetStemmer(StemmerTypeNm);
55    PNGramBs NGramBs;
56    if (!((MxNGramLen==1)&&(MnNGramFq==1))){
57      NGramBs=TNGramBs::GetNGramBsFromHtmlFPathV(
58       FPath, RecurseDirP, MxDocs,
59       MxNGramLen, MnNGramFq, SwSet, Stemmer);
60    }
61    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
62    TIntV NewDIdV; LoadHtmlTxt(BowDocBs, FPath, NewDIdV,
63        RecurseDirP, MxDocs, SaveDocP, Notify);
64    return BowDocBs;
65  }
66  PBowDocBs TBowFl::LoadFromSimMtx(const PBowSimMtx& BowSimMtx){
67    PBowDocBs BowDocBs=TBowDocBs::New();
68    int Docs=BowSimMtx->GetDocs();
69    BowDocBs->DocSpVV.Gen(Docs, 0);
70    for (int MtxDIdN=0; MtxDIdN<Docs; MtxDIdN++){
71      int MtxDId=BowSimMtx->GetMtxDId(MtxDIdN);
72      int DId=BowDocBs->DocNmToDescStrH.AddKey(TInt::GetStr(MtxDId));
73      IAssert(MtxDIdN==DId);
74      BowDocBs->DocSpVV.Add(TBowSpV::New(DId));
75      IAssert(DId==BowDocBs->DocSpVV.Len()-1);
76    }
77    BowDocBs->AssertOk();
78    return BowDocBs;
79  }
80  PBowDocBs TBowFl::LoadTabTxt(const TStr& FNm, const int& &bsol;*MxDocs*/){
81    PBowDocBs BowDocBs=TBowDocBs::New();
82    PDm Dm=TDm::LoadFile(FNm);
83    for (int AttrN=0; AttrN<Dm->GetAttrs(); AttrN++){
84      PTbVar Var=Dm->GetAttr(AttrN);
85      TStr VarNm=Var->GetNm();
86      PTbVarType VarType=Var->GetVarType();
87      EAssertRA(VarType->IsFlt(), "Attribute must be continuous", VarNm);
88      BowDocBs->WordStrToDescH.AddKey(VarNm);
89    }
90    for (int ExN=0; ExN<Dm->GetExs(); ExN++){
91      TStr DocNm=TInt::GetStr(ExN);
92      int DId=BowDocBs->DocNmToDescStrH.AddKey(DocNm);
93      BowDocBs->DocSpVV.Add(TBowSpV::New(DId)); IAssert(DId==BowDocBs->DocSpVV.Len()-1);
94      BowDocBs->DocCIdVV.Add(); IAssert(DId==BowDocBs->DocCIdVV.Len()-1);
95      TIntV& DocCIdV=BowDocBs->DocCIdVV[DId];
96      DocCIdV.Gen(Dm->GetClasses(), 0);
97      for (int ClassN=0; ClassN<Dm->GetClasses(); ClassN++){
98        TStr ValStr=Dm->GetClassValStr(ExN, ClassN);
99        int CId=BowDocBs->CatNmToFqH.AddKey(ValStr);
100        BowDocBs->CatNmToFqH[CId]++; DocCIdV.Add(CId);
101      }
102      DocCIdV.Sort();
103      PBowSpV DocSpV=BowDocBs->DocSpVV[DId];
104      DocSpV->GenMx(Dm->GetAttrs());
105      for (int AttrN=0; AttrN<Dm->GetAttrs(); AttrN++){
106        TStr WordStr=Dm->GetAttr(AttrN)->GetNm();
107        int WId=BowDocBs->WordStrToDescH.GetKeyId(WordStr);
108        TTbVal Val=Dm->GetAttrVal(ExN, AttrN);
109        double Wgt=Val.GetFlt();
110        TBowWordDesc& WordDesc=BowDocBs->WordStrToDescH[WId];
111        WordDesc.MnVal=TFlt::GetMn(WordDesc.MnVal, Wgt);
112        WordDesc.MxVal=TFlt::GetMx(WordDesc.MxVal, Wgt);
113        DocSpV->AddWIdWgt(WId, Wgt);
114      }
115      DocSpV->Sort();
116    }
117    BowDocBs->AssertOk();
118    return BowDocBs;
119  }
120  PBowDocBs TBowFl::LoadTsactTxt(const TStr& FNm, const int& MxDocs){
121    PBowDocBs BowDocBs=TBowDocBs::New();
122    PSIn SIn=TFIn::New(FNm);
123    printf("Loading '%s' ...\n", FNm.CStr());
124    if (!SIn->Eof()){
125      int CurDId=-1;
126      TIntH CurDocWIdToFqH(100);
127      char Ch=SIn->GetCh();
128      while ((!SIn->Eof())&&(!(('0'<=Ch)&&(Ch<='9')))){
129        Ch=SIn->GetCh();}
130      while (!SIn->Eof()){
131        if (BowDocBs->DocSpVV.Len()%1000==0){
132          printf("%d transactions read\r", BowDocBs->DocSpVV.Len());}
133        IAssert(('0'<=Ch)&&(Ch<='9'));
134        int TsactN=Ch-'0'; Ch=SIn->GetCh();
135        while (('0'<=Ch)&&(Ch<='9')){
136          TsactN=TsactN*10+Ch-'0'; Ch=SIn->GetCh();}
137        while (!(('0'<=Ch)&&(Ch<='9'))){
138          IAssert((Ch==' ')||(Ch=='\t')); Ch=SIn->GetCh();}
139        IAssert(('0'<=Ch)&&(Ch<='9'));
140        int ItemN=Ch-'0'; Ch=SIn->GetCh();
141        while (('0'<=Ch)&&(Ch<='9')){
142          ItemN=ItemN*10+Ch-'0'; Ch=SIn->GetCh();}
143        while ((!SIn->Eof())&&(!(('0'<=Ch)&&(Ch<='9')))){
144          Ch=SIn->GetCh();}
145        TStr DocNm=TInt::GetStr(TsactN);
146        int DId=BowDocBs->DocNmToDescStrH.AddKey(DocNm);
147        TStr WordStr=TInt::GetStr(ItemN);
148        int WId=BowDocBs->WordStrToDescH.AddKey(WordStr);
149        BowDocBs->WordStrToDescH[WId].Fq++;
150        if (CurDId!=DId){
151          if (CurDId!=-1){
152            if ((MxDocs!=-1)&&(BowDocBs->GetDocs()>=MxDocs-1)){break;}
153            PBowSpV NewSpV=TBowSpV::New(CurDId, CurDocWIdToFqH.Len());
154            int NewDId=BowDocBs->DocSpVV.Add(NewSpV);
155            IAssert(NewDId==CurDId);
156            for (int DocWIdN=0; DocWIdN<CurDocWIdToFqH.Len(); DocWIdN++){
157              int WId=CurDocWIdToFqH.GetKey(DocWIdN);
158              int WordFq=CurDocWIdToFqH[DocWIdN];
159              NewSpV->AddWIdWgt(WId, WordFq);
160            }
161            NewSpV->Sort();
162          }
163          CurDId=DId; CurDocWIdToFqH.Clr(false);
164        }
165        CurDocWIdToFqH.AddDat(WId)++;
166      }
167      if (CurDId!=-1){
168        PBowSpV NewSpV=TBowSpV::New(CurDId, CurDocWIdToFqH.Len());
169        BowDocBs->DocSpVV.Add(NewSpV);
170        for (int DocWIdN=0; DocWIdN<CurDocWIdToFqH.Len(); DocWIdN++){
171          int WId=CurDocWIdToFqH.GetKey(DocWIdN);
172          int WordFq=CurDocWIdToFqH[DocWIdN];
173          NewSpV->AddWIdWgt(WId, WordFq);
174        }
175        NewSpV->Sort();
176      }
177      printf("%d transactions read\n", BowDocBs->DocSpVV.Len());
178    }
179    printf("... Done.\n");
180    BowDocBs->AssertOk();
181    return BowDocBs;
182  }
183  PBowDocBs TBowFl::LoadSparseTxt(
184   const TStr& DocDefFNm, const TStr& WordDefFNm,
185   const TStr& TrainDataFNm,
186   const int& MxDocs){
187    PBowDocBs BowDocBs=TBowDocBs::New();
188    if (!DocDefFNm.Empty()){
189      PSIn SIn=TFIn::New(DocDefFNm);
190      TILx Lx(SIn, TFSet()|iloRetEoln|iloSigNum|iloExcept);
191      Lx.GetSym(syInt, syEof);
192      while (Lx.Sym==syInt){
193        int DId=Lx.Int;
194        Lx.GetSym(syColon);
195        Lx.GetSym(syQStr); TStr DocNm=Lx.Str;
196        Lx.GetSym(syEoln);
197        Lx.GetSym(syInt, syEof);
198        int NewDId=BowDocBs->DocNmToDescStrH.AddKey(DocNm);
199        EAssertR(DId==NewDId, "Document-Ids don't match.");
200      }
201    }
202    if (!WordDefFNm.Empty()){
203      PSIn SIn=TFIn::New(WordDefFNm);
204      TILx Lx(SIn, TFSet()|iloRetEoln|iloSigNum|iloExcept);
205      Lx.GetSym(syInt, syEof);
206      while (Lx.Sym==syInt){
207        int WId=Lx.Int;
208        Lx.GetSym(syColon);
209        Lx.GetSym(syQStr); TStr WordStr=Lx.Str;
210        Lx.GetSym(syEoln);
211        Lx.GetSym(syInt, syEof);
212        int NewWId=BowDocBs->WordStrToDescH.AddKey(WordStr);
213        BowDocBs->WordStrToDescH[NewWId].Fq=1;
214        EAssertR(WId==NewWId, "Word-Ids don't match.");
215      }
216    }
217    if (!TrainDataFNm.Empty()){
218      PSIn SIn=TFIn::New(TrainDataFNm);
219      TILx Lx(SIn, TFSet()|iloRetEoln|iloSigNum|iloExcept);
220      Lx.GetSym(syInt, syEof);
221      while (Lx.Sym==syInt){
222        if ((MxDocs!=-1)&&(BowDocBs->GetDocs()>=MxDocs)){break;}
223        int DId=Lx.Int;
224        PBowSpV NewSpV=TBowSpV::New(DId);
225        int NewDId=BowDocBs->DocSpVV.Add(NewSpV);
226        EAssertR(DId==NewDId, "Document-Ids don't match.");
227        Lx.GetSym(syInt, syEoln);
228        while (Lx.Sym==syInt){
229          int WId=Lx.Int;
230          Lx.GetSym(syColon, syInt, syEoln);
231          double WordFq=1;
232          if (Lx.Sym==syColon){
233            WordFq=Lx.GetFlt();
234            Lx.GetSym(syInt, syEoln);
235          }
236          NewSpV->AddWIdWgt(WId, WordFq);
237        }
238        NewSpV->Trunc();
239        Lx.GetSym(syInt, syEof);
240      }
241    }
242    BowDocBs->AssertOk();
243    return BowDocBs;
244  }
245  PBowDocBs TBowFl::LoadSvmLightTxt(
246   const TStr& DocDefFNm, const TStr& WordDefFNm,
247   const TStr& TrainDataFNm, const TStr& TestDataFNm,
248   const int& MxDocs){ 
249    PBowDocBs BowDocBs=TBowDocBs::New();
250    int MOneCId=BowDocBs->CatNmToFqH.AddKey("-1");
251    int POneCId=BowDocBs->CatNmToFqH.AddKey("+1");
252    bool DocDefP=false;
253    if (!DocDefFNm.Empty()&&(TFile::Exists(DocDefFNm))){
254      PSIn SIn=TFIn::New(DocDefFNm);
255      TILx Lx(SIn, TFSet()|iloRetEoln|iloSigNum|iloExcept);
256      Lx.GetSym(syInt, syEof);
257      while (Lx.Sym==syInt){
258        int DId=Lx.Int;
259        Lx.GetSym(syColon);
260        Lx.GetSym(syQStr); TStr DocNm=Lx.Str;
261        Lx.GetSym(syEoln);
262        Lx.GetSym(syInt, syEof);
263        int NewDId=BowDocBs->DocNmToDescStrH.AddKey(DocNm);
264        EAssertR(DId==NewDId, "Document-Ids don't match.");
265      }
266      DocDefP=true;
267    }
268    if (!WordDefFNm.Empty()&&(TFile::Exists(WordDefFNm))){
269      BowDocBs->WordStrToDescH.AddDat("Undef").Fq=0; 
270      PSIn SIn=TFIn::New(WordDefFNm);
271      TILx Lx(SIn, TFSet()|iloRetEoln|iloSigNum|iloExcept);
272      Lx.GetSym(syQStr, syEof);
273      while (Lx.Sym==syQStr){
274        TStr WordStr=Lx.Str;
275        Lx.GetSym(syInt); int WId=Lx.Int;
276        Lx.GetSym(syInt); int WordFq=Lx.Int;
277        Lx.GetSym(syEoln);
278        Lx.GetSym(syQStr, syEof);
279        int NewWId=BowDocBs->WordStrToDescH.AddKey(WordStr);
280        EAssertR(WId==NewWId, "Word-Ids don't match.");
281        BowDocBs->WordStrToDescH[WId].Fq=WordFq;
282      }
283    }
284    int MxWId=-1; TIntIntH WIdToFqH;
285    if (!TrainDataFNm.Empty()){
286      PSIn SIn=TFIn::New(TrainDataFNm);
287      TILx Lx(SIn, TFSet()|iloCmtAlw|iloRetEoln|iloSigNum|iloExcept);
288      while (Lx.GetSym(syInt, syEoln, syEof)==syEoln){}
289      while (Lx.Sym==syInt){
290        TStr DocNm=TInt::GetStr(BowDocBs->GetDocs());
291        int DId;
292        if (DocDefP){
293          DId=BowDocBs->DocNmToDescStrH.GetKeyId(DocNm);
294        } else {
295          DId=BowDocBs->DocNmToDescStrH.AddKey(DocNm);
296        }
297        BowDocBs->TrainDIdV.Add(DId);
298        int CId=(Lx.Int==-1) ? MOneCId : POneCId;
299        BowDocBs->DocCIdVV.Add(); IAssert(DId==BowDocBs->DocCIdVV.Len()-1);
300        BowDocBs->DocCIdVV.Last().Gen(1, 0);
301        BowDocBs->DocCIdVV.Last().Add(CId);
302        PBowSpV SpV=TBowSpV::New(DId);
303        BowDocBs->DocSpVV.Add(SpV); IAssert(DId==BowDocBs->DocSpVV.Len()-1);
304        Lx.GetSym(syInt, syEoln);
305        while (Lx.Sym==syInt){
306          int WId=Lx.Int;
307          Lx.GetSym(syColon);
308          Lx.GetSym(syFlt); double WordFq=Lx.Flt;
309          Lx.GetSym(syInt, syEoln);
310          SpV->AddWIdWgt(WId, WordFq);
311          if (MxWId==-1){MxWId=WId;} else {MxWId=TInt::GetMx(MxWId, WId);}
312          WIdToFqH.AddDat(WId)++;
313        }
314        if (!Lx.CmtStr.Empty()){
315          TStr CmtStr=Lx.CmtStr;
316          static TStr DocNmPrefixStr="docDesc=";
317          if (CmtStr.IsPrefix(DocNmPrefixStr)){
318            TStr NewDocNm=
319             TStr("D")+CmtStr.GetSubStr(DocNmPrefixStr.Len(), CmtStr.Len()-1);
320            BowDocBs->DocNmToDescStrH.DelKey(DocNm);
321            int NewDId=BowDocBs->DocNmToDescStrH.AddKey(NewDocNm);
322            IAssert(DId==NewDId);
323          }
324        }
325        SpV->Trunc();
326        while (Lx.GetSym(syInt, syEoln, syEof)==syEoln){}
327      }
328    }
329    if (!TestDataFNm.Empty()){
330      PSIn SIn=TFIn::New(TestDataFNm);
331      TILx Lx(SIn, TFSet()|iloCmtAlw|iloRetEoln|iloSigNum|iloExcept);
332      while (Lx.GetSym(syInt, syEoln, syEof)==syEoln){}
333      while (Lx.Sym==syInt){
334        TStr DocNm=TInt::GetStr(BowDocBs->GetDocs());
335        int DId;
336        if (DocDefP){
337          DId=BowDocBs->DocNmToDescStrH.GetKeyId(DocNm);
338        } else {
339          DId=BowDocBs->DocNmToDescStrH.AddKey(DocNm);
340        }
341        BowDocBs->TestDIdV.Add(DId);
342        int CId=(Lx.Int==-1) ? MOneCId : POneCId;
343        BowDocBs->DocCIdVV.Add(); IAssert(DId==BowDocBs->DocCIdVV.Len()-1);
344        BowDocBs->DocCIdVV.Last().Gen(1, 0);
345        BowDocBs->DocCIdVV.Last().Add(CId);
346        PBowSpV SpV=TBowSpV::New(DId);
347        BowDocBs->DocSpVV.Add(SpV); IAssert(DId==BowDocBs->DocSpVV.Len()-1);
348        Lx.GetSym(syInt, syEoln);
349        while (Lx.Sym==syInt){
350          int WId=Lx.Int;
351          Lx.GetSym(syColon);
352          Lx.GetSym(syFlt); double WordFq=Lx.Flt;
353          Lx.GetSym(syInt, syEoln);
354          SpV->AddWIdWgt(WId, WordFq);
355          if (MxWId==-1){MxWId=WId;} else {MxWId=TInt::GetMx(MxWId, WId);}
356          WIdToFqH.AddDat(WId)++;
357        }
358        if (!Lx.CmtStr.Empty()){
359          TStr CmtStr=Lx.CmtStr;
360          static TStr DocNmPrefixStr="docDesc=";
361          if (CmtStr.IsPrefix(DocNmPrefixStr)){
362            TStr NewDocNm=
363             TStr("D")+CmtStr.GetSubStr(DocNmPrefixStr.Len(), CmtStr.Len()-1);
364            BowDocBs->DocNmToDescStrH.DelKey(DocNm);
365            int NewDId=BowDocBs->DocNmToDescStrH.AddKey(NewDocNm);
366            IAssert(DId==NewDId);
367          }
368        }
369        SpV->Trunc();
370        while (Lx.GetSym(syInt, syEoln, syEof)==syEoln){}
371      }
372    }
373    for (int WId=0; WId<=MxWId; WId++){
374      if (!BowDocBs->IsWId(WId)){
375        TStr WordStr=TInt::GetStr(WId, "W%d");
376        int _WId=BowDocBs->AddWordStr(WordStr);
377        IAssert(WId==_WId);
378        TInt Fq;
379        if (WIdToFqH.IsKeyGetDat(WId, Fq)){
380          BowDocBs->PutWordFq(WId, Fq);
381        }
382      }
383    }
384    BowDocBs->AssertOk();
385    return BowDocBs;
386  }
387  PBowDocBs TBowFl::LoadCpdTxt(
388   const PSIn& CpdSIn, const int& MxDocs,
389   const TStr& SwSetTypeNm, const TStr& StemmerTypeNm,
390   const int& MxNGramLen, const int& MnNGramFq){
391    PSwSet SwSet=TSwSet::GetSwSet(SwSetTypeNm);
392    PStemmer Stemmer=TStemmer::GetStemmer(StemmerTypeNm);
393    PNGramBs NGramBs;
394    if (!((MxNGramLen==1)&&(MnNGramFq==1))){
395      NGramBs=TNGramBs::GetNGramBsFromCpd(
396       CpdSIn, MxDocs, MxNGramLen, MnNGramFq, SwSet, Stemmer);
397    }
398    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
399    printf("Load Bag-Of-Words from Compact-Documents ...\n");
400    TIntH DocWIdToFqH(100); CpdSIn->Reset();
401    PSIn CpDocSIn=TCpDoc::FFirstCpd(CpdSIn); PCpDoc CpDoc; int Docs=0;
402    while (TCpDoc::FNextCpd(CpDocSIn, CpDoc)){
403      Docs++; if (Docs%100==0){printf("  %d\r", Docs);}
404      if ((MxDocs!=-1)&&(Docs>=MxDocs)){break;}
405      TStr DocNm=CpDoc->GetDocNm();
406      TStrV CatNmV;
407      for (int CatN=0; CatN<CpDoc->GetCats(); CatN++){
408        CatNmV.Add(CpDoc->GetCatNm(CatN));
409      }
410      TStr DocStr=CpDoc->GetTxtStr();
411      TStr DateStr=CpDoc->GetDateStr();
412      int DId=BowDocBs->AddHtmlDoc(DocNm, CatNmV, DocStr, false);
413      BowDocBs->PutDateStr(DId, DateStr);
414    }
415    printf("  %d\nDone.\n", Docs);
416    BowDocBs->AssertOk();
417    return BowDocBs;
418  }
419  PBowDocBs TBowFl::LoadCpdTxt(
420   const TStr& CpdFNm, const int& MxDocs,
421   const TStr& SwSetTypeNm, const TStr& StemmerTypeNm,
422   const int& MxNGramLen, const int& MnNGramFq){
423    PSIn CpdSIn=TFIn::New(CpdFNm);
424    return TBowFl::LoadCpdTxt(
425     CpdSIn, MxDocs, SwSetTypeNm, StemmerTypeNm, MxNGramLen, MnNGramFq);
426  }
427  void TBowFl::SaveCpdToLnDocTxt(const TStr& InCpdFNm, const TStr& OutLnDocFNm){
428    TFOut FOut(OutLnDocFNm); FILE* fOut=FOut.GetFileId();
429    PSIn CpDocSIn=TCpDoc::FFirstCpd(InCpdFNm); PCpDoc CpDoc; int Docs=0;
430    printf("Saving '%s' to '%s' ...\n", InCpdFNm.CStr(), OutLnDocFNm.CStr());
431    while (TCpDoc::FNextCpd(CpDocSIn, CpDoc)){
432      Docs++; if (Docs%100==0){printf("%d Docs\r", Docs);}
433      TStr DocNm=CpDoc->GetDocNm();
434      DocNm=TStr::GetFNmStr(DocNm);
435      DocNm.ChangeChAll(' ', '_');
436      TStrV CatNmV;
437      for (int CatN=0; CatN<CpDoc->GetCats(); CatN++){
438        CatNmV.Add(CpDoc->GetCatNm(CatN));}
439      TChA DocChA=CpDoc->GetTxtStr();
440      DocChA.ChangeCh('\r', ' ');
441      DocChA.ChangeCh('\n', ' ');
442      fprintf(fOut, "%s", DocNm.CStr());
443      for (int CatN=0; CatN<CatNmV.Len(); CatN++){
444        fprintf(fOut, " !%s", CatNmV[CatN].CStr());}
445      fprintf(fOut, " %s\n", DocChA.CStr());
446    }
447    printf("%d Docs\nDone.\n", Docs);
448  }
449  PBowDocBs TBowFl::LoadTBsTxt(
450   const TStr& TBsFNm, const int& MxDocs,
451   const TStr& SwSetTypeNm, const TStr& StemmerTypeNm,
452   const int& MxNGramLen, const int& MnNGramFq){
453    PSwSet SwSet=TSwSet::GetSwSet(SwSetTypeNm);
454    PStemmer Stemmer=TStemmer::GetStemmer(StemmerTypeNm);
455    PNGramBs NGramBs;
456    if (!((MxNGramLen==1)&&(MnNGramFq==1))){
457      NGramBs=TNGramBs::GetNGramBsFromTBs(
458       TBsFNm, MxDocs,
459       MxNGramLen, MnNGramFq, SwSet, Stemmer);
460    }
461    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
462    TStr TxtBsNm=TBsFNm.GetFBase();
463    TStr TxtBsFPath=TBsFNm.GetFPath();
464    PTxtBs TxtBs=TTxtBs::New(TxtBsNm, TxtBsFPath, faRdOnly);
465    TBlobPt TxtBsTrvBlobPt=TxtBs->FFirstDocId(); TBlobPt TxtBsDocId; int Docs=0;
466    while (TxtBs->FNextDocId(TxtBsTrvBlobPt, TxtBsDocId)){
467      Docs++; if (Docs%100==0){printf("%d\r", Docs);}
468      if ((MxDocs!=-1)&&(Docs>=MxDocs)){break;}
469      TStr DocNm; TStr DocStr;
470      TxtBs->GetDocNmStr(TxtBsDocId, DocNm, DocStr);
471      BowDocBs->AddHtmlDoc(DocNm, TStrV(), DocStr, false);
472    }
473    BowDocBs->AssertOk();
474    return BowDocBs;
475  }
476  void TBowFl::LoadLnDocTxt(PBowDocBs BowDocBs, const TStr& LnDocFNm,
477   TIntV& NewDIdV, const bool& NamedP, const int& MxDocs, const bool& SaveDocP) {
478    NewDIdV.Clr(); TFIn FIn(LnDocFNm); char Ch=' '; int Docs=0;
479    while (!FIn.Eof()){
480      Docs++; if ((MxDocs!=-1)&&(Docs>=MxDocs)){break;}
481      printf("%d\r", Docs);
482      TChA DocNm;
483      Ch=FIn.GetCh();
484      if (NamedP){
485        while ((!FIn.Eof())&&(Ch!='\r')&&(Ch!='\n')&&(Ch!=' ')){
486          DocNm+=Ch; Ch=FIn.GetCh();}
487        DocNm.Trunc();
488        if (DocNm.Empty()){Docs--; continue;}
489      } else {
490          DocNm = TInt::GetStr(Docs);
491      }
492      TStrV CatNmV;
493      forever {
494        while ((!FIn.Eof())&&(Ch==' ')){Ch=FIn.GetCh();}
495        if (Ch=='!'){
496          if (!FIn.Eof()){Ch=FIn.GetCh();}
497          TChA CatNm;
498          while ((!FIn.Eof())&&(Ch!='\r')&&(Ch!='\n')&&(Ch!=' ')){
499            CatNm+=Ch; Ch=FIn.GetCh();}
500          if (!CatNm.Empty()){CatNmV.Add(CatNm);}
501        } else {
502          break;
503        }
504      }
505      TChA DocChA;
506      while ((!FIn.Eof())&&(Ch!='\r')&&(Ch!='\n')){
507        DocChA+=Ch; Ch=FIn.GetCh();}
508      if (DocNm.Empty()&&DocChA.Empty()){
509        continue;}
510      NewDIdV.Add(BowDocBs->AddHtmlDoc(DocNm, CatNmV, DocChA, SaveDocP));
511    }
512    BowDocBs->AssertOk();
513    printf("\n");
514  }
515  PBowDocBs TBowFl::LoadLnDocTxt(
516   const TStr& LnDocFNm, const bool& NamedP, const int& MxDocs,
517   const PSwSet& SwSet, const PStemmer& Stemmer,
518   const int& MxNGramLen, const int& MnNGramFq, const bool& SaveDocP){
519    PNGramBs NGramBs;
520    if (!((MxNGramLen==1)&&(MnNGramFq==1))){
521      NGramBs=TNGramBs::GetNGramBsFromLnDoc(
522       LnDocFNm, NamedP, MxDocs,
523       MxNGramLen, MnNGramFq, SwSet, Stemmer);
524    }
525    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
526    TIntV NewDIdV; LoadLnDocTxt(BowDocBs, LnDocFNm, NewDIdV, NamedP, -1, SaveDocP);
527    return BowDocBs;
528  }
529  PBowDocBs TBowFl::LoadLnDocTxt(
530   const TStr& LnDocFNm, const bool& NamedP, const int& MxDocs,
531   const TStr& SwSetTypeNm, const TStr& StemmerTypeNm,
532   const int& MxNGramLen, const int& MnNGramFq, const bool& SaveDocP){
533    PSwSet SwSet=TSwSet::GetSwSet(SwSetTypeNm);
534    PStemmer Stemmer=TStemmer::GetStemmer(StemmerTypeNm);
535    PNGramBs NGramBs;
536    if (!((MxNGramLen==1)&&(MnNGramFq==1))){
537      NGramBs=TNGramBs::GetNGramBsFromLnDoc(
538       LnDocFNm, NamedP, MxDocs,
539       MxNGramLen, MnNGramFq, SwSet, Stemmer);
540    }
541    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
542    TIntV NewDIdV; LoadLnDocTxt(BowDocBs, LnDocFNm, NewDIdV, NamedP, -1, SaveDocP);
543    return BowDocBs;
544  }
545  void TBowFl::SaveLnDocTxt(const PBowDocBs& BowDocBs, const TStr& FNm, const bool& UseDocStrP){
546    TFOut SOut(FNm);
547    int Docs=BowDocBs->GetDocs();
548    for (int DId=0; DId<Docs; DId++){
549      printf("%d/%d\r", DId+1, Docs);
550      TStr DocNm=TStr::GetFNmStr(BowDocBs->GetDocNm(DId));
551      SOut.PutStr(DocNm);
552      for (int CIdN=0; CIdN<BowDocBs->GetDocCIds(DId); CIdN++){
553        int CId=BowDocBs->GetDocCId(DId, CIdN);
554        TStr CatNm=TStr::GetFNmStr(BowDocBs->GetCatNm(CId));
555        SOut.PutCh(' '); SOut.PutCh('!'); SOut.PutStr(CatNm);
556      }
557      if (UseDocStrP){
558        TStr DocStr=BowDocBs->GetDocStr(DId);
559        SOut.PutCh(' '); SOut.PutStr(DocStr);
560      } else {
561          int DocWIds=BowDocBs->GetDocWIds(DId);
562          int WId; double WordFq;
563          for (int DocWIdN=0; DocWIdN<DocWIds; DocWIdN++){
564            BowDocBs->GetDocWIdFq(DId, DocWIdN, WId, WordFq);
565            TStr WordStr=BowDocBs->GetWordStr(WId);
566            for (int WordFqN=0; WordFqN<WordFq; WordFqN++){
567              SOut.PutCh(' '); SOut.PutStr(WordStr);
568            }
569          }
570      }
571      SOut.PutLn();
572    }
573    printf("\n");
574  }
575  PBowDocBs TBowFl::LoadReuters21578Txt(
576   const TStr& FPath, const int& MxDocs,
577   const TStr& SwSetTypeNm, const TStr& StemmerTypeNm,
578   const int& MxNGramLen, const int& MnNGramFq, const bool& SaveDocP){
579    PSwSet SwSet=TSwSet::GetSwSet(SwSetTypeNm);
580    PStemmer Stemmer=TStemmer::GetStemmer(StemmerTypeNm);
581    PNGramBs NGramBs;
582    if (!((MxNGramLen==1)&&(MnNGramFq==1))){
583      NGramBs=TNGramBs::GetNGramBsFromReuters21578(
584       FPath, MxDocs,
585       MxNGramLen, MnNGramFq, SwSet, Stemmer);
586    }
587    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
588    TFFile FFile(FPath, ".SGM", false); TStr FNm; int Docs=0;
589    while (FFile.Next(FNm)){
590      printf("Processing file '%s'\n", FNm.CStr());
591      TIntH DocWIdToFqH(100);
592      TXmlDocV LDocV; TXmlDoc::LoadTxt(FNm, LDocV);
593      for (int LDocN=0; LDocN<LDocV.Len(); LDocN++){
594        Docs++; if (Docs%100==0){printf("%d\r", Docs);}
595        if ((MxDocs!=-1)&&(Docs>=MxDocs)){break;}
596        PXmlDoc Doc=LDocV[LDocN];
597        PXmlTok DocTok=Doc->GetTok();
598        TStr DocNm=DocTok->GetArgVal("NEWID");
599        TStrV CatNmV;
600        TXmlTokV TopicsTokV; Doc->GetTagTokV("REUTERS|TOPICS|D", TopicsTokV);
601        for (int TopicsTokN=0; TopicsTokN<TopicsTokV.Len(); TopicsTokN++){
602          TStr CatNm=TopicsTokV[TopicsTokN]->GetTokStr(false);
603          CatNmV.Add(CatNm);
604        }
605        PXmlTok DocStrTok=Doc->GetTagTok("REUTERS|TEXT");
606        TStr DocStr=DocStrTok->GetTokStr(false);
607        int DId=BowDocBs->AddHtmlDoc(DocNm, CatNmV, DocStr, SaveDocP);
608        if ((DocTok->GetArgVal("LEWISSPLIT")=="TRAIN")&&(DocTok->GetArgVal("TOPICS")=="YES")){
609          BowDocBs->AddTrainDId(DId);}
610        if ((DocTok->GetArgVal("LEWISSPLIT")=="TEST")&&(DocTok->GetArgVal("TOPICS")=="YES")){
611          BowDocBs->AddTestDId(DId);}
612      }
613      if ((MxDocs!=-1)&&(Docs>=MxDocs)){break;}
614    }
615    BowDocBs->AssertOk();
616    return BowDocBs;
617  }
618  PBowDocBs TBowFl::LoadCiaWFBTxt(
619   const TStr& FPath, const int& MxDocs,
620   const TStr& SwSetTypeNm, const TStr& StemmerTypeNm,
621   const int& MxNGramLen, const int& MnNGramFq){
622    PCiaWFBBs CiaWFBBs=TCiaWFBBs::LoadHtml(FPath);
623    PSwSet SwSet=TSwSet::GetSwSet(SwSetTypeNm);
624    PStemmer Stemmer=TStemmer::GetStemmer(StemmerTypeNm);
625    PNGramBs NGramBs;
626    if (!((MxNGramLen==1)&&(MnNGramFq==1))){
627      TStrV HtmlStrV;
628      for (int CountryN=0; CountryN<CiaWFBBs->GetCountries(); CountryN++){
629        PCiaWFBCountry CiaWFBCountry=CiaWFBBs->GetCountry(CountryN);
630        HtmlStrV.Add(CiaWFBCountry->GetDescStr());
631      }
632      NGramBs=TNGramBs::GetNGramBsFromHtmlStrV(
633       HtmlStrV, MxNGramLen, MnNGramFq, SwSet, Stemmer);
634    }
635    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
636    for (int CountryN=0; CountryN<CiaWFBBs->GetCountries(); CountryN++){
637      if (CountryN==MxDocs){break;}
638      PCiaWFBCountry CiaWFBCountry=CiaWFBBs->GetCountry(CountryN);
639      TStr CountryNm=CiaWFBCountry->GetCountryNm();
640      TStr DescStr=CiaWFBCountry->GetDescStr();
641      TStr CatNm=CiaWFBCountry->GetFldVal("Map references").GetTrunc();
642      TStrV CatNmV; CatNmV.Add(CatNm);
643      BowDocBs->AddHtmlDoc(CountryNm, CatNmV, DescStr, true);
644    }
645    BowDocBs->AssertOk();
646    return BowDocBs;
647  }
648  void TBowFl::SaveSparseMatlabTxt(const PBowDocBs& BowDocBs,
649   const PBowDocWgtBs& BowDocWgtBs, const TStr& FNm,
650   const TStr& CatFNm, const TIntV& _DIdV) {
651    TIntV DIdV;
652    if (_DIdV.Empty()){
653      BowDocBs->GetAllDIdV(DIdV);
654    } else {
655      DIdV=_DIdV;
656    }
657    TFOut WdMapSOut(TStr::PutFExt(FNm, ".row-to-word-map.dat"));
658    for (int WId = 0; WId < BowDocWgtBs->GetWords(); WId++) {
659      TStr WdStr = BowDocBs->GetWordStr(WId);
660      WdMapSOut.PutStrLn(TStr::Fmt("%d %s", WId+1,  WdStr.CStr()));
661    }
662    WdMapSOut.Flush();
663    TFOut DocMapSOut(TStr::PutFExt(FNm, ".col-to-docName-map.dat"));
664    for (int DocN = 0; DocN < DIdV.Len(); DocN++) {
665      const int DId = DIdV[DocN];
666      TStr DocNm = BowDocBs->GetDocNm(DId);
667      DocMapSOut.PutStrLn(TStr::Fmt("%d %d %s", DocN, DId,  DocNm.CStr()));
668    }
669    DocMapSOut.Flush();
670    TFOut SOut(FNm);
671    for (int DocN = 0; DocN < DIdV.Len(); DocN++){
672      const int DId = DIdV[DocN];
673      PBowSpV DocSpV = BowDocWgtBs->GetSpV(DId);
674      const int DocWIds = DocSpV->GetWIds();
675      for (int DocWIdN=0; DocWIdN<DocWIds; DocWIdN++){
676        const int WId = DocSpV->GetWId(DocWIdN);
677        const double WordWgt = DocSpV->GetWgt(DocWIdN);
678        SOut.PutStrLn(TStr::Fmt("%d %d %.16f", WId+1, DocN+1, WordWgt));
679      }
680    }
681    SOut.Flush();
682    if (!CatFNm.Empty()) {
683      TFOut CatSOut(CatFNm);
684      for (int DocN = 0; DocN < DIdV.Len(); DocN++){
685        const int DId = DIdV[DocN];
686        const int DocCIds = BowDocBs->GetDocCIds(DId);
687        for (int DocCIdN=0; DocCIdN<DocCIds; DocCIdN++){
688          const int CId = BowDocBs->GetDocCId(DId, DocCIdN);
689          const double CatWgt = 1.0;
690          CatSOut.PutStrLn(TStr::Fmt("%d %d %.16f", CId+1, DocN+1, CatWgt));
691        }
692      }
693      CatSOut.Flush();
694    }
695  }
696  PBowDocBs TBowFl::LoadTabTxt(
697   const TStr& FNm, const TStr& SsFmtNm, const int& Recs,
698   const TStr& SwSetTypeNm, const TStr& StemmerTypeNm,
699   const int& MxNGramLen, const int& MnNGramFq,
700   const int& IdFldN, const TStr& IdFldNm,
701   const TIntV& CatFldNV, const TStrV& CatFldNmV,
702   const TIntV& TxtFldNV, const TStrV& TxtFldNmV){
703    TSsFmt SsFmt=TSs::GetSsFmtFromStr(SsFmtNm);
704    PSs Ss=TSs::LoadTxt(SsFmt, FNm);
705    int FinalIdFldN=IdFldN;
706    if ((FinalIdFldN==-1)&&(!IdFldNm.Empty())){
707      FinalIdFldN=Ss->GetFldX(IdFldNm);
708    }
709    TIntV FinalCatFldNV=CatFldNV;
710    for (int CatN=0; CatN<CatFldNmV.Len(); CatN++){
711      int CatFldN=Ss->GetFldX(CatFldNmV[CatN]);
712      FinalCatFldNV.Add(CatFldN);
713    }
714    FinalCatFldNV.Sort();
715    TIntV FinalTxtFldNV=TxtFldNV;
716    for (int TxtN=0; TxtN<TxtFldNmV.Len(); TxtN++){
717      int TxtFldN=Ss->GetFldX(TxtFldNmV[TxtN]);
718      FinalTxtFldNV.Add(TxtFldN);
719    }
<span onclick='openModal()' class='match'>720    FinalTxtFldNV.Sort();
721    TStrV DocNmV;
722    TVec<TStrV> CatNmVV;
723    TStrV DocStrV;
</span>724    for (int Y=1; Y<Ss->GetYLen(); Y++){
725      TStr DocNm;
726      if (FinalIdFldN==-1){
727        DocNm=TInt::GetStr(Y);
728      } else {
729        DocNm=Ss->GetVal(FinalIdFldN, Y);
730      }
731      DocNmV.Add(DocNm);
732      TStrV CatNmV;
733      for (int CatN=0; CatN<FinalCatFldNV.Len(); CatN++){
734        int CatFldN=FinalCatFldNV[CatN];
735        TStr CatNm=Ss->GetVal(CatFldN, Y);
736        if (!CatNm.Empty()){
737          CatNmV.Add(CatNm);
738        }
739      }
740      CatNmVV.Add(CatNmV);
741      TChA DocChA;
742      for (int TxtN=0; TxtN<FinalTxtFldNV.Len(); TxtN++){
743        int TxtFldN=FinalTxtFldNV[TxtN];
744        TStr TxtStr=Ss->GetVal(TxtFldN, Y);
745        if (!DocChA.Empty()){DocChA+=" <br> ";}
746        if (!TxtStr.Empty()){DocChA+=TxtStr;}
747      }
748      DocStrV.Add(DocChA);
749    }
750    PSwSet SwSet=TSwSet::GetSwSet(SwSetTypeNm);
751    PStemmer Stemmer=TStemmer::GetStemmer(StemmerTypeNm);
752    PNGramBs NGramBs;
753    if (!((MxNGramLen==1)&&(MnNGramFq==1))){
754      NGramBs=TNGramBs::GetNGramBsFromHtmlStrV(
755       DocStrV, MxNGramLen, MnNGramFq, SwSet, Stemmer);
756    }
757    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
758    for (int DocN=0; DocN<DocNmV.Len(); DocN++){
759      BowDocBs->AddHtmlDoc(DocNmV[DocN], CatNmVV[DocN], DocStrV[DocN], true);
760    }
761    BowDocBs->AssertOk();
762    return BowDocBs;
763  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-bowfl.cpp</h3>
            <pre><code>1  void TBowFl::LoadHtmlTxt(
2   PBowDocBs BowDocBs, const TStr& FPath, TIntV& NewDIdV,
3   const bool& RecurseDirP, const int& MxDocs,
4   const bool& SaveDocP, const PNotify& Notify) {
5    TStr LcNrFPath=TStr::GetNrFPath(FPath).GetLc();
6    Notify->OnStatus("Creating Bow from file-path " + FPath + " ...");
7    TFFile FFile(FPath, "", RecurseDirP);
8    TStr FNm; int Docs=0; NewDIdV.Clr();
9    while (FFile.Next(FNm)){
10      Docs++; if ((MxDocs!=-1)&&(Docs>MxDocs)){break;}
11      Notify->OnStatus(TStr::Fmt("%d\r", Docs));
12      if (TFile::Exists(FNm)) { 
13          TStr DocNm=FNm.GetLc();
14          if (DocNm.IsPrefix(LcNrFPath)){
15            DocNm=DocNm.GetSubStr(LcNrFPath.Len(), DocNm.Len()-1);}
16          TStrV CatNmV; TStr CatNm;
17          if (DocNm.IsChIn('/')){
18            TStr Str; DocNm.SplitOnCh(CatNm, '/', Str);
19          } else if (DocNm.IsChIn('\\')){
20            TStr Str; DocNm.SplitOnCh(CatNm, '\\', Str);
21          }
22          if (!CatNm.Empty()){
23            CatNmV.Add(CatNm);}
24          TStr DocStr=TStr::LoadTxt(FNm);
25          NewDIdV.Add(BowDocBs->AddHtmlDoc(DocNm, CatNmV, DocStr, SaveDocP));
26      }
27    }
28    Notify->OnStatus(TStr::Fmt("%d", Docs));
29    Notify->OnStatus("Done.");
30    BowDocBs->AssertOk();
31  }
32  PBowDocBs TBowFl::LoadHtmlTxt(
33   const TStr& FPath, const bool& RecurseDirP, const int& MxDocs,
34   const PSwSet& SwSet, const PStemmer& Stemmer,
35   const int& MxNGramLen, const int& MnNGramFq,
36   const bool& SaveDocP, const PNotify& Notify){
37    PNGramBs NGramBs;
38    if (!((MxNGramLen==1)&&(MnNGramFq==1))){
39      NGramBs=TNGramBs::GetNGramBsFromHtmlFPathV(
40       FPath, RecurseDirP, MxDocs,
41       MxNGramLen, MnNGramFq, SwSet, Stemmer);
42    }
43    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
44    TIntV NewDIdV; LoadHtmlTxt(BowDocBs, FPath, NewDIdV,
45        RecurseDirP, MxDocs, SaveDocP, Notify);
46    return BowDocBs;
47  }
48  PBowDocBs TBowFl::LoadHtmlTxt(
49   const TStr& FPath, const bool& RecurseDirP, const int& MxDocs,
50   const TStr& SwSetTypeNm, const TStr& StemmerTypeNm,
51   const int& MxNGramLen, const int& MnNGramFq,
52   const bool& SaveDocP, const PNotify& Notify){
53    PSwSet SwSet=TSwSet::GetSwSet(SwSetTypeNm);
54    PStemmer Stemmer=TStemmer::GetStemmer(StemmerTypeNm);
55    PNGramBs NGramBs;
56    if (!((MxNGramLen==1)&&(MnNGramFq==1))){
57      NGramBs=TNGramBs::GetNGramBsFromHtmlFPathV(
58       FPath, RecurseDirP, MxDocs,
59       MxNGramLen, MnNGramFq, SwSet, Stemmer);
60    }
61    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
62    TIntV NewDIdV; LoadHtmlTxt(BowDocBs, FPath, NewDIdV,
63        RecurseDirP, MxDocs, SaveDocP, Notify);
64    return BowDocBs;
65  }
66  PBowDocBs TBowFl::LoadFromSimMtx(const PBowSimMtx& BowSimMtx){
67    PBowDocBs BowDocBs=TBowDocBs::New();
68    int Docs=BowSimMtx->GetDocs();
69    BowDocBs->DocSpVV.Gen(Docs, 0);
70    for (int MtxDIdN=0; MtxDIdN<Docs; MtxDIdN++){
71      int MtxDId=BowSimMtx->GetMtxDId(MtxDIdN);
72      int DId=BowDocBs->DocNmToDescStrH.AddKey(TInt::GetStr(MtxDId));
73      IAssert(MtxDIdN==DId);
74      BowDocBs->DocSpVV.Add(TBowSpV::New(DId));
75      IAssert(DId==BowDocBs->DocSpVV.Len()-1);
76    }
77    BowDocBs->AssertOk();
78    return BowDocBs;
79  }
80  PBowDocBs TBowFl::LoadTabTxt(const TStr& FNm, const int& &bsol;*MxDocs*/){
81    PBowDocBs BowDocBs=TBowDocBs::New();
82    PDm Dm=TDm::LoadFile(FNm);
83    for (int AttrN=0; AttrN<Dm->GetAttrs(); AttrN++){
84      PTbVar Var=Dm->GetAttr(AttrN);
85      TStr VarNm=Var->GetNm();
86      PTbVarType VarType=Var->GetVarType();
87      EAssertRA(VarType->IsFlt(), "Attribute must be continuous", VarNm);
88      BowDocBs->WordStrToDescH.AddKey(VarNm);
89    }
90    for (int ExN=0; ExN<Dm->GetExs(); ExN++){
91      TStr DocNm=TInt::GetStr(ExN);
92      int DId=BowDocBs->DocNmToDescStrH.AddKey(DocNm);
93      BowDocBs->DocSpVV.Add(TBowSpV::New(DId)); IAssert(DId==BowDocBs->DocSpVV.Len()-1);
94      BowDocBs->DocCIdVV.Add(); IAssert(DId==BowDocBs->DocCIdVV.Len()-1);
95      TIntV& DocCIdV=BowDocBs->DocCIdVV[DId];
96      DocCIdV.Gen(Dm->GetClasses(), 0);
97      for (int ClassN=0; ClassN<Dm->GetClasses(); ClassN++){
98        TStr ValStr=Dm->GetClassValStr(ExN, ClassN);
99        int CId=BowDocBs->CatNmToFqH.AddKey(ValStr);
100        BowDocBs->CatNmToFqH[CId]++; DocCIdV.Add(CId);
101      }
102      DocCIdV.Sort();
103      PBowSpV DocSpV=BowDocBs->DocSpVV[DId];
104      DocSpV->GenMx(Dm->GetAttrs());
105      for (int AttrN=0; AttrN<Dm->GetAttrs(); AttrN++){
106        TStr WordStr=Dm->GetAttr(AttrN)->GetNm();
107        int WId=BowDocBs->WordStrToDescH.GetKeyId(WordStr);
108        TTbVal Val=Dm->GetAttrVal(ExN, AttrN);
109        double Wgt=Val.GetFlt();
110        TBowWordDesc& WordDesc=BowDocBs->WordStrToDescH[WId];
111        WordDesc.MnVal=TFlt::GetMn(WordDesc.MnVal, Wgt);
112        WordDesc.MxVal=TFlt::GetMx(WordDesc.MxVal, Wgt);
113        DocSpV->AddWIdWgt(WId, Wgt);
114      }
115      DocSpV->Sort();
116    }
117    BowDocBs->AssertOk();
118    return BowDocBs;
119  }
120  PBowDocBs TBowFl::LoadTsactTxt(const TStr& FNm, const int& MxDocs){
121    PBowDocBs BowDocBs=TBowDocBs::New();
122    PSIn SIn=TFIn::New(FNm);
123    printf("Loading '%s' ...\n", FNm.CStr());
124    if (!SIn->Eof()){
125      int CurDId=-1;
126      TIntH CurDocWIdToFqH(100);
127      char Ch=SIn->GetCh();
128      while ((!SIn->Eof())&&(!(('0'<=Ch)&&(Ch<='9')))){
129        Ch=SIn->GetCh();}
130      while (!SIn->Eof()){
131        if (BowDocBs->DocSpVV.Len()%1000==0){
132          printf("%d transactions read\r", BowDocBs->DocSpVV.Len());}
133        IAssert(('0'<=Ch)&&(Ch<='9'));
134        int TsactN=Ch-'0'; Ch=SIn->GetCh();
135        while (('0'<=Ch)&&(Ch<='9')){
136          TsactN=TsactN*10+Ch-'0'; Ch=SIn->GetCh();}
137        while (!(('0'<=Ch)&&(Ch<='9'))){
138          IAssert((Ch==' ')||(Ch=='\t')); Ch=SIn->GetCh();}
139        IAssert(('0'<=Ch)&&(Ch<='9'));
140        int ItemN=Ch-'0'; Ch=SIn->GetCh();
141        while (('0'<=Ch)&&(Ch<='9')){
142          ItemN=ItemN*10+Ch-'0'; Ch=SIn->GetCh();}
143        while ((!SIn->Eof())&&(!(('0'<=Ch)&&(Ch<='9')))){
144          Ch=SIn->GetCh();}
145        TStr DocNm=TInt::GetStr(TsactN);
146        int DId=BowDocBs->DocNmToDescStrH.AddKey(DocNm);
147        TStr WordStr=TInt::GetStr(ItemN);
148        int WId=BowDocBs->WordStrToDescH.AddKey(WordStr);
149        BowDocBs->WordStrToDescH[WId].Fq++;
150        if (CurDId!=DId){
151          if (CurDId!=-1){
152            if ((MxDocs!=-1)&&(BowDocBs->GetDocs()>=MxDocs-1)){break;}
153            PBowSpV NewSpV=TBowSpV::New(CurDId, CurDocWIdToFqH.Len());
154            int NewDId=BowDocBs->DocSpVV.Add(NewSpV);
155            IAssert(NewDId==CurDId);
156            for (int DocWIdN=0; DocWIdN<CurDocWIdToFqH.Len(); DocWIdN++){
157              int WId=CurDocWIdToFqH.GetKey(DocWIdN);
158              int WordFq=CurDocWIdToFqH[DocWIdN];
159              NewSpV->AddWIdWgt(WId, WordFq);
160            }
161            NewSpV->Sort();
162          }
163          CurDId=DId; CurDocWIdToFqH.Clr(false);
164        }
165        CurDocWIdToFqH.AddDat(WId)++;
166      }
167      if (CurDId!=-1){
168        PBowSpV NewSpV=TBowSpV::New(CurDId, CurDocWIdToFqH.Len());
169        BowDocBs->DocSpVV.Add(NewSpV);
170        for (int DocWIdN=0; DocWIdN<CurDocWIdToFqH.Len(); DocWIdN++){
171          int WId=CurDocWIdToFqH.GetKey(DocWIdN);
172          int WordFq=CurDocWIdToFqH[DocWIdN];
173          NewSpV->AddWIdWgt(WId, WordFq);
174        }
175        NewSpV->Sort();
176      }
177      printf("%d transactions read\n", BowDocBs->DocSpVV.Len());
178    }
179    printf("... Done.\n");
180    BowDocBs->AssertOk();
181    return BowDocBs;
182  }
183  PBowDocBs TBowFl::LoadSparseTxt(
184   const TStr& DocDefFNm, const TStr& WordDefFNm,
185   const TStr& TrainDataFNm,
186   const int& MxDocs){
187    PBowDocBs BowDocBs=TBowDocBs::New();
188    if (!DocDefFNm.Empty()){
189      PSIn SIn=TFIn::New(DocDefFNm);
190      TILx Lx(SIn, TFSet()|iloRetEoln|iloSigNum|iloExcept);
191      Lx.GetSym(syInt, syEof);
192      while (Lx.Sym==syInt){
193        int DId=Lx.Int;
194        Lx.GetSym(syColon);
195        Lx.GetSym(syQStr); TStr DocNm=Lx.Str;
196        Lx.GetSym(syEoln);
197        Lx.GetSym(syInt, syEof);
198        int NewDId=BowDocBs->DocNmToDescStrH.AddKey(DocNm);
199        EAssertR(DId==NewDId, "Document-Ids don't match.");
200      }
201    }
202    if (!WordDefFNm.Empty()){
203      PSIn SIn=TFIn::New(WordDefFNm);
204      TILx Lx(SIn, TFSet()|iloRetEoln|iloSigNum|iloExcept);
205      Lx.GetSym(syInt, syEof);
206      while (Lx.Sym==syInt){
207        int WId=Lx.Int;
208        Lx.GetSym(syColon);
209        Lx.GetSym(syQStr); TStr WordStr=Lx.Str;
210        Lx.GetSym(syEoln);
211        Lx.GetSym(syInt, syEof);
212        int NewWId=BowDocBs->WordStrToDescH.AddKey(WordStr);
213        BowDocBs->WordStrToDescH[NewWId].Fq=1;
214        EAssertR(WId==NewWId, "Word-Ids don't match.");
215      }
216    }
217    if (!TrainDataFNm.Empty()){
218      PSIn SIn=TFIn::New(TrainDataFNm);
219      TILx Lx(SIn, TFSet()|iloRetEoln|iloSigNum|iloExcept);
220      Lx.GetSym(syInt, syEof);
221      while (Lx.Sym==syInt){
222        if ((MxDocs!=-1)&&(BowDocBs->GetDocs()>=MxDocs)){break;}
223        int DId=Lx.Int;
224        PBowSpV NewSpV=TBowSpV::New(DId);
225        int NewDId=BowDocBs->DocSpVV.Add(NewSpV);
226        EAssertR(DId==NewDId, "Document-Ids don't match.");
227        Lx.GetSym(syInt, syEoln);
228        while (Lx.Sym==syInt){
229          int WId=Lx.Int;
230          Lx.GetSym(syColon, syInt, syEoln);
231          double WordFq=1;
232          if (Lx.Sym==syColon){
233            WordFq=Lx.GetFlt();
234            Lx.GetSym(syInt, syEoln);
235          }
236          NewSpV->AddWIdWgt(WId, WordFq);
237        }
238        NewSpV->Trunc();
239        Lx.GetSym(syInt, syEof);
240      }
241    }
242    BowDocBs->AssertOk();
243    return BowDocBs;
244  }
245  PBowDocBs TBowFl::LoadSvmLightTxt(
246   const TStr& DocDefFNm, const TStr& WordDefFNm,
247   const TStr& TrainDataFNm, const TStr& TestDataFNm,
248   const int& MxDocs){ 
249    PBowDocBs BowDocBs=TBowDocBs::New();
250    int MOneCId=BowDocBs->CatNmToFqH.AddKey("-1");
251    int POneCId=BowDocBs->CatNmToFqH.AddKey("+1");
252    bool DocDefP=false;
253    if (!DocDefFNm.Empty()&&(TFile::Exists(DocDefFNm))){
254      PSIn SIn=TFIn::New(DocDefFNm);
255      TILx Lx(SIn, TFSet()|iloRetEoln|iloSigNum|iloExcept);
256      Lx.GetSym(syInt, syEof);
257      while (Lx.Sym==syInt){
258        int DId=Lx.Int;
259        Lx.GetSym(syColon);
260        Lx.GetSym(syQStr); TStr DocNm=Lx.Str;
261        Lx.GetSym(syEoln);
262        Lx.GetSym(syInt, syEof);
263        int NewDId=BowDocBs->DocNmToDescStrH.AddKey(DocNm);
264        EAssertR(DId==NewDId, "Document-Ids don't match.");
265      }
266      DocDefP=true;
267    }
268    if (!WordDefFNm.Empty()&&(TFile::Exists(WordDefFNm))){
269      BowDocBs->WordStrToDescH.AddDat("Undef").Fq=0; 
270      PSIn SIn=TFIn::New(WordDefFNm);
271      TILx Lx(SIn, TFSet()|iloRetEoln|iloSigNum|iloExcept);
272      Lx.GetSym(syQStr, syEof);
273      while (Lx.Sym==syQStr){
274        TStr WordStr=Lx.Str;
275        Lx.GetSym(syInt); int WId=Lx.Int;
276        Lx.GetSym(syInt); int WordFq=Lx.Int;
277        Lx.GetSym(syEoln);
278        Lx.GetSym(syQStr, syEof);
279        int NewWId=BowDocBs->WordStrToDescH.AddKey(WordStr);
280        EAssertR(WId==NewWId, "Word-Ids don't match.");
281        BowDocBs->WordStrToDescH[WId].Fq=WordFq;
282      }
283    }
284    int MxWId=-1; TIntIntH WIdToFqH;
285    if (!TrainDataFNm.Empty()){
286      PSIn SIn=TFIn::New(TrainDataFNm);
287      TILx Lx(SIn, TFSet()|iloCmtAlw|iloRetEoln|iloSigNum|iloExcept);
288      while (Lx.GetSym(syInt, syEoln, syEof)==syEoln){}
289      while (Lx.Sym==syInt){
290        TStr DocNm=TInt::GetStr(BowDocBs->GetDocs());
291        int DId;
292        if (DocDefP){
293          DId=BowDocBs->DocNmToDescStrH.GetKeyId(DocNm);
294        } else {
295          DId=BowDocBs->DocNmToDescStrH.AddKey(DocNm);
296        }
297        BowDocBs->TrainDIdV.Add(DId);
298        int CId=(Lx.Int==-1) ? MOneCId : POneCId;
299        BowDocBs->DocCIdVV.Add(); IAssert(DId==BowDocBs->DocCIdVV.Len()-1);
300        BowDocBs->DocCIdVV.Last().Gen(1, 0);
301        BowDocBs->DocCIdVV.Last().Add(CId);
302        PBowSpV SpV=TBowSpV::New(DId);
303        BowDocBs->DocSpVV.Add(SpV); IAssert(DId==BowDocBs->DocSpVV.Len()-1);
304        Lx.GetSym(syInt, syEoln);
305        while (Lx.Sym==syInt){
306          int WId=Lx.Int;
307          Lx.GetSym(syColon);
308          Lx.GetSym(syFlt); double WordFq=Lx.Flt;
309          Lx.GetSym(syInt, syEoln);
310          SpV->AddWIdWgt(WId, WordFq);
311          if (MxWId==-1){MxWId=WId;} else {MxWId=TInt::GetMx(MxWId, WId);}
312          WIdToFqH.AddDat(WId)++;
313        }
314        if (!Lx.CmtStr.Empty()){
315          TStr CmtStr=Lx.CmtStr;
316          static TStr DocNmPrefixStr="docDesc=";
317          if (CmtStr.IsPrefix(DocNmPrefixStr)){
318            TStr NewDocNm=
319             TStr("D")+CmtStr.GetSubStr(DocNmPrefixStr.Len(), CmtStr.Len()-1);
320            BowDocBs->DocNmToDescStrH.DelKey(DocNm);
321            int NewDId=BowDocBs->DocNmToDescStrH.AddKey(NewDocNm);
322            IAssert(DId==NewDId);
323          }
324        }
325        SpV->Trunc();
326        while (Lx.GetSym(syInt, syEoln, syEof)==syEoln){}
327      }
328    }
329    if (!TestDataFNm.Empty()){
330      PSIn SIn=TFIn::New(TestDataFNm);
331      TILx Lx(SIn, TFSet()|iloCmtAlw|iloRetEoln|iloSigNum|iloExcept);
332      while (Lx.GetSym(syInt, syEoln, syEof)==syEoln){}
333      while (Lx.Sym==syInt){
334        TStr DocNm=TInt::GetStr(BowDocBs->GetDocs());
335        int DId;
336        if (DocDefP){
337          DId=BowDocBs->DocNmToDescStrH.GetKeyId(DocNm);
338        } else {
339          DId=BowDocBs->DocNmToDescStrH.AddKey(DocNm);
340        }
341        BowDocBs->TestDIdV.Add(DId);
342        int CId=(Lx.Int==-1) ? MOneCId : POneCId;
343        BowDocBs->DocCIdVV.Add(); IAssert(DId==BowDocBs->DocCIdVV.Len()-1);
344        BowDocBs->DocCIdVV.Last().Gen(1, 0);
345        BowDocBs->DocCIdVV.Last().Add(CId);
346        PBowSpV SpV=TBowSpV::New(DId);
347        BowDocBs->DocSpVV.Add(SpV); IAssert(DId==BowDocBs->DocSpVV.Len()-1);
348        Lx.GetSym(syInt, syEoln);
349        while (Lx.Sym==syInt){
350          int WId=Lx.Int;
351          Lx.GetSym(syColon);
352          Lx.GetSym(syFlt); double WordFq=Lx.Flt;
353          Lx.GetSym(syInt, syEoln);
354          SpV->AddWIdWgt(WId, WordFq);
355          if (MxWId==-1){MxWId=WId;} else {MxWId=TInt::GetMx(MxWId, WId);}
356          WIdToFqH.AddDat(WId)++;
357        }
358        if (!Lx.CmtStr.Empty()){
359          TStr CmtStr=Lx.CmtStr;
360          static TStr DocNmPrefixStr="docDesc=";
361          if (CmtStr.IsPrefix(DocNmPrefixStr)){
362            TStr NewDocNm=
363             TStr("D")+CmtStr.GetSubStr(DocNmPrefixStr.Len(), CmtStr.Len()-1);
364            BowDocBs->DocNmToDescStrH.DelKey(DocNm);
365            int NewDId=BowDocBs->DocNmToDescStrH.AddKey(NewDocNm);
366            IAssert(DId==NewDId);
367          }
368        }
369        SpV->Trunc();
370        while (Lx.GetSym(syInt, syEoln, syEof)==syEoln){}
371      }
372    }
373    for (int WId=0; WId<=MxWId; WId++){
374      if (!BowDocBs->IsWId(WId)){
375        TStr WordStr=TInt::GetStr(WId, "W%d");
376        int _WId=BowDocBs->AddWordStr(WordStr);
377        IAssert(WId==_WId);
378        TInt Fq;
379        if (WIdToFqH.IsKeyGetDat(WId, Fq)){
380          BowDocBs->PutWordFq(WId, Fq);
381        }
382      }
383    }
384    BowDocBs->AssertOk();
385    return BowDocBs;
386  }
387  PBowDocBs TBowFl::LoadCpdTxt(
388   const PSIn& CpdSIn, const int& MxDocs,
389   const TStr& SwSetTypeNm, const TStr& StemmerTypeNm,
390   const int& MxNGramLen, const int& MnNGramFq){
391    PSwSet SwSet=TSwSet::GetSwSet(SwSetTypeNm);
392    PStemmer Stemmer=TStemmer::GetStemmer(StemmerTypeNm);
393    PNGramBs NGramBs;
394    if (!((MxNGramLen==1)&&(MnNGramFq==1))){
395      NGramBs=TNGramBs::GetNGramBsFromCpd(
396       CpdSIn, MxDocs, MxNGramLen, MnNGramFq, SwSet, Stemmer);
397    }
398    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
399    printf("Load Bag-Of-Words from Compact-Documents ...\n");
400    TIntH DocWIdToFqH(100); CpdSIn->Reset();
401    PSIn CpDocSIn=TCpDoc::FFirstCpd(CpdSIn); PCpDoc CpDoc; int Docs=0;
402    while (TCpDoc::FNextCpd(CpDocSIn, CpDoc)){
403      Docs++; if (Docs%100==0){printf("  %d\r", Docs);}
404      if ((MxDocs!=-1)&&(Docs>=MxDocs)){break;}
405      TStr DocNm=CpDoc->GetDocNm();
406      TStrV CatNmV;
407      for (int CatN=0; CatN<CpDoc->GetCats(); CatN++){
408        CatNmV.Add(CpDoc->GetCatNm(CatN));
409      }
410      TStr DocStr=CpDoc->GetTxtStr();
411      TStr DateStr=CpDoc->GetDateStr();
412      int DId=BowDocBs->AddHtmlDoc(DocNm, CatNmV, DocStr, false);
413      BowDocBs->PutDateStr(DId, DateStr);
414    }
415    printf("  %d\nDone.\n", Docs);
416    BowDocBs->AssertOk();
417    return BowDocBs;
418  }
419  PBowDocBs TBowFl::LoadCpdTxt(
420   const TStr& CpdFNm, const int& MxDocs,
421   const TStr& SwSetTypeNm, const TStr& StemmerTypeNm,
422   const int& MxNGramLen, const int& MnNGramFq){
423    PSIn CpdSIn=TFIn::New(CpdFNm);
424    return TBowFl::LoadCpdTxt(
425     CpdSIn, MxDocs, SwSetTypeNm, StemmerTypeNm, MxNGramLen, MnNGramFq);
426  }
427  void TBowFl::SaveCpdToLnDocTxt(const TStr& InCpdFNm, const TStr& OutLnDocFNm){
428    TFOut FOut(OutLnDocFNm); FILE* fOut=FOut.GetFileId();
429    PSIn CpDocSIn=TCpDoc::FFirstCpd(InCpdFNm); PCpDoc CpDoc; int Docs=0;
430    printf("Saving '%s' to '%s' ...\n", InCpdFNm.CStr(), OutLnDocFNm.CStr());
431    while (TCpDoc::FNextCpd(CpDocSIn, CpDoc)){
432      Docs++; if (Docs%100==0){printf("%d Docs\r", Docs);}
433      TStr DocNm=CpDoc->GetDocNm();
434      DocNm=TStr::GetFNmStr(DocNm);
435      DocNm.ChangeChAll(' ', '_');
436      TStrV CatNmV;
437      for (int CatN=0; CatN<CpDoc->GetCats(); CatN++){
438        CatNmV.Add(CpDoc->GetCatNm(CatN));}
439      TChA DocChA=CpDoc->GetTxtStr();
440      DocChA.ChangeCh('\r', ' ');
441      DocChA.ChangeCh('\n', ' ');
442      fprintf(fOut, "%s", DocNm.CStr());
443      for (int CatN=0; CatN<CatNmV.Len(); CatN++){
444        fprintf(fOut, " !%s", CatNmV[CatN].CStr());}
445      fprintf(fOut, " %s\n", DocChA.CStr());
446    }
447    printf("%d Docs\nDone.\n", Docs);
448  }
449  PBowDocBs TBowFl::LoadTBsTxt(
450   const TStr& TBsFNm, const int& MxDocs,
451   const TStr& SwSetTypeNm, const TStr& StemmerTypeNm,
452   const int& MxNGramLen, const int& MnNGramFq){
453    PSwSet SwSet=TSwSet::GetSwSet(SwSetTypeNm);
454    PStemmer Stemmer=TStemmer::GetStemmer(StemmerTypeNm);
455    PNGramBs NGramBs;
456    if (!((MxNGramLen==1)&&(MnNGramFq==1))){
457      NGramBs=TNGramBs::GetNGramBsFromTBs(
458       TBsFNm, MxDocs,
459       MxNGramLen, MnNGramFq, SwSet, Stemmer);
460    }
461    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
462    TStr TxtBsNm=TBsFNm.GetFBase();
463    TStr TxtBsFPath=TBsFNm.GetFPath();
464    PTxtBs TxtBs=TTxtBs::New(TxtBsNm, TxtBsFPath, faRdOnly);
465    TBlobPt TxtBsTrvBlobPt=TxtBs->FFirstDocId(); TBlobPt TxtBsDocId; int Docs=0;
466    while (TxtBs->FNextDocId(TxtBsTrvBlobPt, TxtBsDocId)){
467      Docs++; if (Docs%100==0){printf("%d\r", Docs);}
468      if ((MxDocs!=-1)&&(Docs>=MxDocs)){break;}
469      TStr DocNm; TStr DocStr;
470      TxtBs->GetDocNmStr(TxtBsDocId, DocNm, DocStr);
471      BowDocBs->AddHtmlDoc(DocNm, TStrV(), DocStr, false);
472    }
473    BowDocBs->AssertOk();
474    return BowDocBs;
475  }
476  void TBowFl::LoadLnDocTxt(PBowDocBs BowDocBs, const TStr& LnDocFNm,
477   TIntV& NewDIdV, const bool& NamedP, const int& MxDocs, const bool& SaveDocP) {
478    NewDIdV.Clr(); TFIn FIn(LnDocFNm); char Ch=' '; int Docs=0;
479    while (!FIn.Eof()){
480      Docs++; if ((MxDocs!=-1)&&(Docs>=MxDocs)){break;}
481      printf("%d\r", Docs);
482      TChA DocNm;
483      Ch=FIn.GetCh();
484      if (NamedP){
485        while ((!FIn.Eof())&&(Ch!='\r')&&(Ch!='\n')&&(Ch!=' ')){
486          DocNm+=Ch; Ch=FIn.GetCh();}
487        DocNm.Trunc();
488        if (DocNm.Empty()){Docs--; continue;}
489      } else {
490          DocNm = TInt::GetStr(Docs);
491      }
492      TStrV CatNmV;
493      forever {
494        while ((!FIn.Eof())&&(Ch==' ')){Ch=FIn.GetCh();}
495        if (Ch=='!'){
496          if (!FIn.Eof()){Ch=FIn.GetCh();}
497          TChA CatNm;
498          while ((!FIn.Eof())&&(Ch!='\r')&&(Ch!='\n')&&(Ch!=' ')){
499            CatNm+=Ch; Ch=FIn.GetCh();}
500          if (!CatNm.Empty()){CatNmV.Add(CatNm);}
501        } else {
502          break;
503        }
504      }
505      TChA DocChA;
506      while ((!FIn.Eof())&&(Ch!='\r')&&(Ch!='\n')){
507        DocChA+=Ch; Ch=FIn.GetCh();}
508      if (DocNm.Empty()&&DocChA.Empty()){
509        continue;}
510      NewDIdV.Add(BowDocBs->AddHtmlDoc(DocNm, CatNmV, DocChA, SaveDocP));
511    }
512    BowDocBs->AssertOk();
513    printf("\n");
514  }
515  PBowDocBs TBowFl::LoadLnDocTxt(
516   const TStr& LnDocFNm, const bool& NamedP, const int& MxDocs,
517   const PSwSet& SwSet, const PStemmer& Stemmer,
518   const int& MxNGramLen, const int& MnNGramFq, const bool& SaveDocP){
519    PNGramBs NGramBs;
520    if (!((MxNGramLen==1)&&(MnNGramFq==1))){
521      NGramBs=TNGramBs::GetNGramBsFromLnDoc(
522       LnDocFNm, NamedP, MxDocs,
523       MxNGramLen, MnNGramFq, SwSet, Stemmer);
524    }
525    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
526    TIntV NewDIdV; LoadLnDocTxt(BowDocBs, LnDocFNm, NewDIdV, NamedP, -1, SaveDocP);
527    return BowDocBs;
528  }
529  PBowDocBs TBowFl::LoadLnDocTxt(
530   const TStr& LnDocFNm, const bool& NamedP, const int& MxDocs,
531   const TStr& SwSetTypeNm, const TStr& StemmerTypeNm,
532   const int& MxNGramLen, const int& MnNGramFq, const bool& SaveDocP){
533    PSwSet SwSet=TSwSet::GetSwSet(SwSetTypeNm);
534    PStemmer Stemmer=TStemmer::GetStemmer(StemmerTypeNm);
535    PNGramBs NGramBs;
536    if (!((MxNGramLen==1)&&(MnNGramFq==1))){
537      NGramBs=TNGramBs::GetNGramBsFromLnDoc(
538       LnDocFNm, NamedP, MxDocs,
539       MxNGramLen, MnNGramFq, SwSet, Stemmer);
540    }
541    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
542    TIntV NewDIdV; LoadLnDocTxt(BowDocBs, LnDocFNm, NewDIdV, NamedP, -1, SaveDocP);
543    return BowDocBs;
544  }
545  void TBowFl::SaveLnDocTxt(const PBowDocBs& BowDocBs, const TStr& FNm, const bool& UseDocStrP){
546    TFOut SOut(FNm);
547    int Docs=BowDocBs->GetDocs();
548    for (int DId=0; DId<Docs; DId++){
549      printf("%d/%d\r", DId+1, Docs);
550      TStr DocNm=TStr::GetFNmStr(BowDocBs->GetDocNm(DId));
551      SOut.PutStr(DocNm);
552      for (int CIdN=0; CIdN<BowDocBs->GetDocCIds(DId); CIdN++){
553        int CId=BowDocBs->GetDocCId(DId, CIdN);
554        TStr CatNm=TStr::GetFNmStr(BowDocBs->GetCatNm(CId));
555        SOut.PutCh(' '); SOut.PutCh('!'); SOut.PutStr(CatNm);
556      }
557      if (UseDocStrP){
558        TStr DocStr=BowDocBs->GetDocStr(DId);
559        SOut.PutCh(' '); SOut.PutStr(DocStr);
560      } else {
561          int DocWIds=BowDocBs->GetDocWIds(DId);
562          int WId; double WordFq;
563          for (int DocWIdN=0; DocWIdN<DocWIds; DocWIdN++){
564            BowDocBs->GetDocWIdFq(DId, DocWIdN, WId, WordFq);
565            TStr WordStr=BowDocBs->GetWordStr(WId);
566            for (int WordFqN=0; WordFqN<WordFq; WordFqN++){
567              SOut.PutCh(' '); SOut.PutStr(WordStr);
568            }
569          }
570      }
571      SOut.PutLn();
572    }
573    printf("\n");
574  }
575  PBowDocBs TBowFl::LoadReuters21578Txt(
576   const TStr& FPath, const int& MxDocs,
577   const TStr& SwSetTypeNm, const TStr& StemmerTypeNm,
578   const int& MxNGramLen, const int& MnNGramFq, const bool& SaveDocP){
579    PSwSet SwSet=TSwSet::GetSwSet(SwSetTypeNm);
580    PStemmer Stemmer=TStemmer::GetStemmer(StemmerTypeNm);
581    PNGramBs NGramBs;
582    if (!((MxNGramLen==1)&&(MnNGramFq==1))){
583      NGramBs=TNGramBs::GetNGramBsFromReuters21578(
584       FPath, MxDocs,
585       MxNGramLen, MnNGramFq, SwSet, Stemmer);
586    }
587    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
588    TFFile FFile(FPath, ".SGM", false); TStr FNm; int Docs=0;
589    while (FFile.Next(FNm)){
590      printf("Processing file '%s'\n", FNm.CStr());
591      TIntH DocWIdToFqH(100);
592      TXmlDocV LDocV; TXmlDoc::LoadTxt(FNm, LDocV);
593      for (int LDocN=0; LDocN<LDocV.Len(); LDocN++){
594        Docs++; if (Docs%100==0){printf("%d\r", Docs);}
595        if ((MxDocs!=-1)&&(Docs>=MxDocs)){break;}
596        PXmlDoc Doc=LDocV[LDocN];
597        PXmlTok DocTok=Doc->GetTok();
598        TStr DocNm=DocTok->GetArgVal("NEWID");
599        TStrV CatNmV;
600        TXmlTokV TopicsTokV; Doc->GetTagTokV("REUTERS|TOPICS|D", TopicsTokV);
601        for (int TopicsTokN=0; TopicsTokN<TopicsTokV.Len(); TopicsTokN++){
602          TStr CatNm=TopicsTokV[TopicsTokN]->GetTokStr(false);
603          CatNmV.Add(CatNm);
604        }
605        PXmlTok DocStrTok=Doc->GetTagTok("REUTERS|TEXT");
606        TStr DocStr=DocStrTok->GetTokStr(false);
607        int DId=BowDocBs->AddHtmlDoc(DocNm, CatNmV, DocStr, SaveDocP);
608        if ((DocTok->GetArgVal("LEWISSPLIT")=="TRAIN")&&(DocTok->GetArgVal("TOPICS")=="YES")){
609          BowDocBs->AddTrainDId(DId);}
610        if ((DocTok->GetArgVal("LEWISSPLIT")=="TEST")&&(DocTok->GetArgVal("TOPICS")=="YES")){
611          BowDocBs->AddTestDId(DId);}
612      }
613      if ((MxDocs!=-1)&&(Docs>=MxDocs)){break;}
614    }
615    BowDocBs->AssertOk();
616    return BowDocBs;
617  }
618  PBowDocBs TBowFl::LoadCiaWFBTxt(
619   const TStr& FPath, const int& MxDocs,
620   const TStr& SwSetTypeNm, const TStr& StemmerTypeNm,
621   const int& MxNGramLen, const int& MnNGramFq){
622    PCiaWFBBs CiaWFBBs=TCiaWFBBs::LoadHtml(FPath);
623    PSwSet SwSet=TSwSet::GetSwSet(SwSetTypeNm);
624    PStemmer Stemmer=TStemmer::GetStemmer(StemmerTypeNm);
625    PNGramBs NGramBs;
626    if (!((MxNGramLen==1)&&(MnNGramFq==1))){
627      TStrV HtmlStrV;
628      for (int CountryN=0; CountryN<CiaWFBBs->GetCountries(); CountryN++){
629        PCiaWFBCountry CiaWFBCountry=CiaWFBBs->GetCountry(CountryN);
630        HtmlStrV.Add(CiaWFBCountry->GetDescStr());
631      }
632      NGramBs=TNGramBs::GetNGramBsFromHtmlStrV(
633       HtmlStrV, MxNGramLen, MnNGramFq, SwSet, Stemmer);
634    }
635    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
636    for (int CountryN=0; CountryN<CiaWFBBs->GetCountries(); CountryN++){
637      if (CountryN==MxDocs){break;}
638      PCiaWFBCountry CiaWFBCountry=CiaWFBBs->GetCountry(CountryN);
639      TStr CountryNm=CiaWFBCountry->GetCountryNm();
640      TStr DescStr=CiaWFBCountry->GetDescStr();
641      TStr CatNm=CiaWFBCountry->GetFldVal("Map references").GetTrunc();
642      TStrV CatNmV; CatNmV.Add(CatNm);
643      BowDocBs->AddHtmlDoc(CountryNm, CatNmV, DescStr, true);
644    }
645    BowDocBs->AssertOk();
646    return BowDocBs;
647  }
648  void TBowFl::SaveSparseMatlabTxt(const PBowDocBs& BowDocBs,
649   const PBowDocWgtBs& BowDocWgtBs, const TStr& FNm,
650   const TStr& CatFNm, const TIntV& _DIdV) {
651    TIntV DIdV;
652    if (_DIdV.Empty()){
653      BowDocBs->GetAllDIdV(DIdV);
654    } else {
655      DIdV=_DIdV;
656    }
657    TFOut WdMapSOut(TStr::PutFExt(FNm, ".row-to-word-map.dat"));
658    for (int WId = 0; WId < BowDocWgtBs->GetWords(); WId++) {
659      TStr WdStr = BowDocBs->GetWordStr(WId);
660      WdMapSOut.PutStrLn(TStr::Fmt("%d %s", WId+1,  WdStr.CStr()));
661    }
662    WdMapSOut.Flush();
663    TFOut DocMapSOut(TStr::PutFExt(FNm, ".col-to-docName-map.dat"));
664    for (int DocN = 0; DocN < DIdV.Len(); DocN++) {
665      const int DId = DIdV[DocN];
666      TStr DocNm = BowDocBs->GetDocNm(DId);
667      DocMapSOut.PutStrLn(TStr::Fmt("%d %d %s", DocN, DId,  DocNm.CStr()));
668    }
669    DocMapSOut.Flush();
670    TFOut SOut(FNm);
671    for (int DocN = 0; DocN < DIdV.Len(); DocN++){
672      const int DId = DIdV[DocN];
673      PBowSpV DocSpV = BowDocWgtBs->GetSpV(DId);
674      const int DocWIds = DocSpV->GetWIds();
675      for (int DocWIdN=0; DocWIdN<DocWIds; DocWIdN++){
676        const int WId = DocSpV->GetWId(DocWIdN);
677        const double WordWgt = DocSpV->GetWgt(DocWIdN);
678        SOut.PutStrLn(TStr::Fmt("%d %d %.16f", WId+1, DocN+1, WordWgt));
679      }
680    }
681    SOut.Flush();
682    if (!CatFNm.Empty()) {
683      TFOut CatSOut(CatFNm);
684      for (int DocN = 0; DocN < DIdV.Len(); DocN++){
685        const int DId = DIdV[DocN];
686        const int DocCIds = BowDocBs->GetDocCIds(DId);
687        for (int DocCIdN=0; DocCIdN<DocCIds; DocCIdN++){
688          const int CId = BowDocBs->GetDocCId(DId, DocCIdN);
689          const double CatWgt = 1.0;
690          CatSOut.PutStrLn(TStr::Fmt("%d %d %.16f", CId+1, DocN+1, CatWgt));
691        }
692      }
693      CatSOut.Flush();
694    }
695  }
696  PBowDocBs TBowFl::LoadTabTxt(
697   const TStr& FNm, const TStr& SsFmtNm, const int& Recs,
698   const TStr& SwSetTypeNm, const TStr& StemmerTypeNm,
699   const int& MxNGramLen, const int& MnNGramFq,
700   const int& IdFldN, const TStr& IdFldNm,
701   const TIntV& CatFldNV, const TStrV& CatFldNmV,
702   const TIntV& TxtFldNV, const TStrV& TxtFldNmV){
703    TSsFmt SsFmt=TSs::GetSsFmtFromStr(SsFmtNm);
704    PSs Ss=TSs::LoadTxt(SsFmt, FNm);
705    int FinalIdFldN=IdFldN;
706    if ((FinalIdFldN==-1)&&(!IdFldNm.Empty())){
707      FinalIdFldN=Ss->GetFldX(IdFldNm);
708    }
709    TIntV FinalCatFldNV=CatFldNV;
710    for (int CatN=0; CatN<CatFldNmV.Len(); CatN++){
711      int CatFldN=Ss->GetFldX(CatFldNmV[CatN]);
712      FinalCatFldNV.Add(CatFldN);
713    }
714    FinalCatFldNV.Sort();
715    TIntV FinalTxtFldNV=TxtFldNV;
716    for (int TxtN=0; TxtN<TxtFldNmV.Len(); TxtN++){
717      int TxtFldN=Ss->GetFldX(TxtFldNmV[TxtN]);
718      FinalTxtFldNV.Add(TxtFldN);
719    }
<span onclick='openModal()' class='match'>720    FinalTxtFldNV.Sort();
721    TStrV DocNmV;
722    TVec<TStrV> CatNmVV;
723    TStrV DocStrV;
</span>724    for (int Y=1; Y<Ss->GetYLen(); Y++){
725      TStr DocNm;
726      if (FinalIdFldN==-1){
727        DocNm=TInt::GetStr(Y);
728      } else {
729        DocNm=Ss->GetVal(FinalIdFldN, Y);
730      }
731      DocNmV.Add(DocNm);
732      TStrV CatNmV;
733      for (int CatN=0; CatN<FinalCatFldNV.Len(); CatN++){
734        int CatFldN=FinalCatFldNV[CatN];
735        TStr CatNm=Ss->GetVal(CatFldN, Y);
736        if (!CatNm.Empty()){
737          CatNmV.Add(CatNm);
738        }
739      }
740      CatNmVV.Add(CatNmV);
741      TChA DocChA;
742      for (int TxtN=0; TxtN<FinalTxtFldNV.Len(); TxtN++){
743        int TxtFldN=FinalTxtFldNV[TxtN];
744        TStr TxtStr=Ss->GetVal(TxtFldN, Y);
745        if (!DocChA.Empty()){DocChA+=" <br> ";}
746        if (!TxtStr.Empty()){DocChA+=TxtStr;}
747      }
748      DocStrV.Add(DocChA);
749    }
750    PSwSet SwSet=TSwSet::GetSwSet(SwSetTypeNm);
751    PStemmer Stemmer=TStemmer::GetStemmer(StemmerTypeNm);
752    PNGramBs NGramBs;
753    if (!((MxNGramLen==1)&&(MnNGramFq==1))){
754      NGramBs=TNGramBs::GetNGramBsFromHtmlStrV(
755       DocStrV, MxNGramLen, MnNGramFq, SwSet, Stemmer);
756    }
757    PBowDocBs BowDocBs=TBowDocBs::New(SwSet, Stemmer, NGramBs);
758    for (int DocN=0; DocN<DocNmV.Len(); DocN++){
759      BowDocBs->AddHtmlDoc(DocNmV[DocN], CatNmVV[DocN], DocStrV[DocN], true);
760    }
761    BowDocBs->AssertOk();
762    return BowDocBs;
763  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-bowfl.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-bowfl.cpp</div>
                </div>
                <div class="column column_space"><pre><code>720    FinalTxtFldNV.Sort();
721    TStrV DocNmV;
722    TVec<TStrV> CatNmVV;
723    TStrV DocStrV;
</pre></code></div>
                <div class="column column_space"><pre><code>720    FinalTxtFldNV.Sort();
721    TStrV DocNmV;
722    TVec<TStrV> CatNmVV;
723    TStrV DocStrV;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    