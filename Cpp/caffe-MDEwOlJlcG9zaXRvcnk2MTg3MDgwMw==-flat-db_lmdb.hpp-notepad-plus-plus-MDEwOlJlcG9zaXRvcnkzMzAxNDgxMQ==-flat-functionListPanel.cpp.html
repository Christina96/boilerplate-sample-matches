
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.2522522522522523%, Tokens: 10</h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-db_lmdb.hpp</h3>
            <pre><code>1  #ifdef USE_LMDB
2  #ifndef CAFFE_UTIL_DB_LMDB_HPP
3  #define CAFFE_UTIL_DB_LMDB_HPP
4  #include <string>
5  #include <utility>
6  #include <vector>
7  #include "lmdb.h"
8  #include "caffe/util/db.hpp"
9  namespace caffe { namespace db {
10  inline void MDB_CHECK(int mdb_status) {
11    CHECK_EQ(mdb_status, MDB_SUCCESS) << mdb_strerror(mdb_status);
12  }
13  class LMDBCursor : public Cursor {
14   public:
15    explicit LMDBCursor(MDB_txn* mdb_txn, MDB_cursor* mdb_cursor)
16      : mdb_txn_(mdb_txn), mdb_cursor_(mdb_cursor), valid_(false) {
17      SeekToFirst();
18    }
19    virtual ~LMDBCursor() {
20      mdb_cursor_close(mdb_cursor_);
21      mdb_txn_abort(mdb_txn_);
22    }
23    virtual void SeekToFirst() { Seek(MDB_FIRST); }
24    virtual void Next() { Seek(MDB_NEXT); }
25    virtual string key() {
26      return string(static_cast<const char*>(mdb_key_.mv_data), mdb_key_.mv_size);
27    }
28    virtual string value() {
29      return string(static_cast<const char*>(mdb_value_.mv_data),
30          mdb_value_.mv_size);
31    }
32    virtual std::pair<void*, size_t> valuePointer() {
33      return std::make_pair(mdb_value_.mv_data, mdb_value_.mv_size);
34    }
35    virtual bool valid() { return valid_; }
36   private:
37    void Seek(MDB_cursor_op op) {
<span onclick='openModal()' class='match'>38      int mdb_status = mdb_cursor_get(mdb_cursor_, &mdb_key_, &mdb_value_, op);
39      if (mdb_status == MDB_NOTFOUND) {
40        valid_ = false;
41      } else {
42        MDB_CHECK(mdb_status);
43        valid_ = true;
44      }
45    }
</span>46    MDB_txn* mdb_txn_;
47    MDB_cursor* mdb_cursor_;
48    MDB_val mdb_key_, mdb_value_;
49    bool valid_;
50  };
51  class LMDBTransaction : public Transaction {
52   public:
53    explicit LMDBTransaction(MDB_env* mdb_env)
54      : mdb_env_(mdb_env) { }
55    virtual void Put(const string& key, const string& value);
56    virtual void Commit();
57   private:
58    MDB_env* mdb_env_;
59    vector<string> keys, values;
60    void DoubleMapSize();
61    DISABLE_COPY_AND_ASSIGN(LMDBTransaction);
62  };
63  class LMDB : public DB {
64   public:
65    LMDB() : mdb_env_(NULL) { }
66    virtual ~LMDB() { Close(); }
67    virtual void Open(const string& source, Mode mode);
68    virtual void Close() {
69      if (mdb_env_ != NULL) {
70        mdb_dbi_close(mdb_env_, mdb_dbi_);
71        mdb_env_close(mdb_env_);
72        mdb_env_ = NULL;
73      }
74    }
75    virtual LMDBCursor* NewCursor();
76    virtual LMDBTransaction* NewTransaction();
77   private:
78    MDB_env* mdb_env_;
79    MDB_dbi mdb_dbi_;
80  };
81  }  
82  }  
83  #endif  
84  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-functionListPanel.cpp</h3>
            <pre><code>1  #include "json.hpp"
2  #include "functionListPanel.h"
3  #include "ScintillaEditView.h"
4  #include "localization.h"
5  #include <fstream>
6  using nlohmann::json;
7  using namespace std;
8  #define INDEX_ROOT        0
9  #define INDEX_NODE        1
10  #define INDEX_LEAF        2
11  #define FL_PREFERENCES_INITIALSORT_ID   1
12  FunctionListPanel::~FunctionListPanel()
13  {
14  	for (const auto s : _posStrs)
15  	{
16  		delete s;
17  	}
18  	if (_hFontSearchEdit != nullptr)
19  	{
20  		::DeleteObject(_hFontSearchEdit);
21  		_hFontSearchEdit = nullptr;
22  	}
23  }
24  void FunctionListPanel::addEntry(const TCHAR *nodeName, const TCHAR *displayText, size_t pos)
25  {
26  	HTREEITEM itemParent = NULL;
27  	std::wstring posStr = std::to_wstring(pos);
28  	HTREEITEM root = _treeView.getRoot();
29  	if (nodeName != NULL && *nodeName != '\0')
30  	{
31  		itemParent = _treeView.searchSubItemByName(nodeName, root);
32  		if (!itemParent)
33  		{
34  			generic_string* invalidValueStr = new generic_string(posStr);
35  			_posStrs.push_back(invalidValueStr);
36  			LPARAM lParamInvalidPosStr = reinterpret_cast<LPARAM>(invalidValueStr);
37  			itemParent = _treeView.addItem(nodeName, root, INDEX_NODE, lParamInvalidPosStr);
38  		}
39  	}
40  	else
41  		itemParent = root;
42  	generic_string* posString = new generic_string(posStr);
43  	_posStrs.push_back(posString);
44  	LPARAM lParamPosStr = reinterpret_cast<LPARAM>(posString);
45  	_treeView.addItem(displayText, itemParent, INDEX_LEAF, lParamPosStr);
46  }
47  void FunctionListPanel::removeAllEntries()
48  {
49  	_treeView.removeAllItems();
50  }
51  size_t FunctionListPanel::getBodyClosePos(size_t begin, const TCHAR *bodyOpenSymbol, const TCHAR *bodyCloseSymbol)
52  {
53  	size_t cntOpen = 1;
54  	size_t docLen = (*_ppEditView)->getCurrentDocLen();
55  	if (begin >= docLen)
56  		return docLen;
57  	generic_string exprToSearch = TEXT("(");
58  	exprToSearch += bodyOpenSymbol;
59  	exprToSearch += TEXT("|");
60  	exprToSearch += bodyCloseSymbol;
61  	exprToSearch += TEXT(")");
62  	int flags = SCFIND_REGEXP | SCFIND_POSIX;
63  	(*_ppEditView)->execute(SCI_SETSEARCHFLAGS, flags);
64  	intptr_t targetStart = (*_ppEditView)->searchInTarget(exprToSearch.c_str(), exprToSearch.length(), begin, docLen);
65  	intptr_t targetEnd = 0;
66  	do
67  	{
68  		if (targetStart >= 0) 
69  		{
70  			targetEnd = (*_ppEditView)->execute(SCI_GETTARGETEND);
<span onclick='openModal()' class='match'>71  			intptr_t tmpStart = (*_ppEditView)->searchInTarget(bodyOpenSymbol, lstrlen(bodyOpenSymbol), targetStart, targetEnd);
72  			if (tmpStart >= 0) 
73  			{
74  				++cntOpen;
75  			}
76  			else 
77  			{
78  				--cntOpen;
79  			}
80  		}
</span>81  		else 
82  		{
83  			cntOpen = 0; 
84  			targetEnd = begin;
85  		}
86  		targetStart = (*_ppEditView)->searchInTarget(exprToSearch.c_str(), exprToSearch.length(), targetEnd, docLen);
87  	} while (cntOpen);
88  	return targetEnd;
89  }
90  generic_string FunctionListPanel::parseSubLevel(size_t begin, size_t end, std::vector< generic_string > dataToSearch, intptr_t& foundPos)
91  {
92  	if (begin >= end)
93  	{
94  		foundPos = -1;
95  		return TEXT("");
96  	}
97  	if (!dataToSearch.size())
98  		return TEXT("");
99  	int flags = SCFIND_REGEXP | SCFIND_POSIX;
100  	(*_ppEditView)->execute(SCI_SETSEARCHFLAGS, flags);
101  	const TCHAR *regExpr2search = dataToSearch[0].c_str();
102  	intptr_t targetStart = (*_ppEditView)->searchInTarget(regExpr2search, lstrlen(regExpr2search), begin, end);
103  	if (targetStart < 0)
104  	{
105  		foundPos = -1;
106  		return TEXT("");
107  	}
108  	intptr_t targetEnd = (*_ppEditView)->execute(SCI_GETTARGETEND);
109  	if (dataToSearch.size() >= 2)
110  	{
111  		dataToSearch.erase(dataToSearch.begin());
112  		return parseSubLevel(targetStart, targetEnd, dataToSearch, foundPos);
113  	}
114  	else 
115  	{
116  		TCHAR foundStr[1024]{};
117  		(*_ppEditView)->getGenericText(foundStr, 1024, targetStart, targetEnd);
118  		foundPos = targetStart;
119  		return foundStr;
120  	}
121  }
122  void FunctionListPanel::addInStateArray(TreeStateNode tree2Update, const TCHAR *searchText, bool isSorted)
123  {
124  	bool found = false;
125  	for (size_t i = 0, len = _treeParams.size(); i < len; ++i)
126  	{
127  		if (_treeParams[i]._treeState._extraData == tree2Update._extraData)
128  		{
129  			_treeParams[i]._searchParameters._text2Find = searchText;
130  			_treeParams[i]._searchParameters._doSort = isSorted;
131  			_treeParams[i]._treeState = tree2Update;
132  			found = true;
133  		}
134  	}
135  	if (!found)
136  	{
137  		TreeParams params;
138  		params._treeState = tree2Update;
139  		params._searchParameters._text2Find = searchText;
140  		params._searchParameters._doSort = isSorted;
141  		_treeParams.push_back(params);
142  	}
143  }
144  TreeParams* FunctionListPanel::getFromStateArray(generic_string fullFilePath)
145  {
146  	for (size_t i = 0, len = _treeParams.size(); i < len; ++i)
147  	{
148  		if (_treeParams[i]._treeState._extraData == fullFilePath)
149  			return &_treeParams[i];
150  	}
151  	return NULL;
152  }
153  void FunctionListPanel::sortOrUnsort()
154  {
155  	bool doSort = shouldSort();
156  	if (doSort)
157  		_pTreeView->sort(_pTreeView->getRoot(), true);
158  	else
159  	{
160  		TCHAR text2search[MAX_PATH] = { '\0' };
161  		::SendMessage(_hSearchEdit, WM_GETTEXT, MAX_PATH, reinterpret_cast<LPARAM>(text2search));
162  		if (text2search[0] == '\0') 
163  		{
164  			_pTreeView->customSorting(_pTreeView->getRoot(), categorySortFunc, 0, true);
165  		}
166  		else 
167  		{
168  			reload();
169  			if (_treeView.getRoot() == NULL)
170  				return;
171  			_treeViewSearchResult.removeAllItems();
172  			const TCHAR *fn = ((*_ppEditView)->getCurrentBuffer())->getFileName();
173  			generic_string* invalidValueStr = new generic_string(TEXT("-1"));
174  			_posStrs.push_back(invalidValueStr);
175  			LPARAM lParamInvalidPosStr = reinterpret_cast<LPARAM>(invalidValueStr);
176  			_treeViewSearchResult.addItem(fn, NULL, INDEX_ROOT, lParamInvalidPosStr);
177  			_treeView.searchLeafAndBuildTree(_treeViewSearchResult, text2search, INDEX_LEAF);
178  			_treeViewSearchResult.display(true);
179  			_treeViewSearchResult.expand(_treeViewSearchResult.getRoot());
180  			_treeView.display(false);
181  			_pTreeView = &_treeViewSearchResult;
182  		}
183  	}
184  }
185  int CALLBACK FunctionListPanel::categorySortFunc(LPARAM lParam1, LPARAM lParam2, LPARAM &bsol;*lParamSort*/)
186  {
187  	generic_string* posString1 = reinterpret_cast<generic_string*>(lParam1);
188  	generic_string* posString2 = reinterpret_cast<generic_string*>(lParam2);
189  	size_t pos1 = _wtoi(posString1->c_str());
190  	size_t pos2 = _wtoi(posString2->c_str());
191  	if (pos1 > pos2)
192  		return 1;
193  	else 
194  		return -1;
195  }
196  bool FunctionListPanel::serialize(const generic_string & outputFilename)
197  {
198  	Buffer* currentBuf = (*_ppEditView)->getCurrentBuffer();
199  	const TCHAR* fileNameLabel = currentBuf->getFileName();
200  	generic_string fname2write;
201  	if (outputFilename.empty()) 
202  	{
203  		const TCHAR *fullFilePath = currentBuf->getFullPathName();
204  		bool exportFuncntionList = (NppParameters::getInstance()).doFunctionListExport();
205  		if (exportFuncntionList && ::PathFileExists(fullFilePath))
206  		{
207  			fname2write = fullFilePath;
208  			fname2write += TEXT(".result");
209  			fname2write += TEXT(".json");
210  		}
211  		else
212  			return false;
213  	}
214  	else
215  	{
216  		fname2write = outputFilename;
217  	}
218  	const char* rootLabel = "root";
219  	const char* nodesLabel = "nodes";
220  	const char* leavesLabel = "leaves";
221  	const char* nameLabel = "name";
222  	WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
223  	json j;
224  	j[rootLabel] = wmc.wchar2char(fileNameLabel, CP_ACP);
225  	for (const auto & info : _foundFuncInfos)
226  	{
227  		std::string leafName = wmc.wchar2char(info._data.c_str(), CP_ACP);
228  		if (!info._data2.empty()) 
229  		{
230  			bool isFound = false;
231  			std::string nodeName = wmc.wchar2char(info._data2.c_str(), CP_ACP);
232  			for (auto & i : j[nodesLabel])
233  			{
234  				if (nodeName == std::string{ i[nameLabel] })
235  				{
236  					i[leavesLabel].push_back(leafName.c_str());
237  					isFound = true;
238  					break;
239  				}
240  			}
241  			if (!isFound)
242  			{
243  				json aNode = { { leavesLabel, json::array() },{ nameLabel, nodeName.c_str() } };
244  				aNode[leavesLabel].push_back(leafName.c_str());
245  				j[nodesLabel].push_back(aNode);
246  			}
247  		}
248  		else 
249  		{
250  			j[leavesLabel].push_back(leafName.c_str());
251  		}
252  	}
253  	std::ofstream file(wmc.wchar2char(fname2write.c_str(), CP_ACP));
254  	file << j;
255  	return true;
256  }
257  void FunctionListPanel::reload()
258  {
259  	bool isScrollBarOn = GetWindowLongPtr(_treeView.getHSelf(), GWL_STYLE) & WS_VSCROLL;
260  	if (isScrollBarOn)
261  	{
262  		GetScrollInfo(_treeView.getHSelf(), SB_VERT, &si);
263  	}
264  	_findLine = -1;
265  	_findEndLine = -1;
266  	TreeStateNode currentTree;
267  	bool isOK = _treeView.retrieveFoldingStateTo(currentTree, _treeView.getRoot());
268  	if (isOK)
269  	{
270  		TCHAR text2Search[MAX_PATH] = { '\0' };
271  		::SendMessage(_hSearchEdit, WM_GETTEXT, MAX_PATH, reinterpret_cast<LPARAM>(text2Search));
272  		bool isSorted =  shouldSort();
273  		addInStateArray(currentTree, text2Search, isSorted);
274  	}
275  	removeAllEntries();
276  	::SendMessage(_hSearchEdit, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(TEXT("")));
277  	setSort(false);
278  	_foundFuncInfos.clear();
279  	Buffer* currentBuf = (*_ppEditView)->getCurrentBuffer();
280  	const TCHAR *fn = currentBuf->getFileName();
281  	LangType langID = currentBuf->getLangType();
282  	if (langID == L_JS)
283  		langID = L_JAVASCRIPT;
284  	const TCHAR *udln = NULL;
285  	if (langID == L_USER)
286  	{
287  		udln = currentBuf->getUserDefineLangName();
288  	}
289  	TCHAR *ext = ::PathFindExtension(fn);
290  	bool parsedOK = _funcParserMgr.parse(_foundFuncInfos, AssociationInfo(-1, langID, ext, udln));
291  	if (parsedOK)
292  	{
293  		generic_string* invalidValueStr = new generic_string(TEXT("-1"));
294  		_posStrs.push_back(invalidValueStr);
295  		LPARAM lParamInvalidPosStr = reinterpret_cast<LPARAM>(invalidValueStr);
296  		_treeView.addItem(fn, NULL, INDEX_ROOT, lParamInvalidPosStr);
297  	}
298  	for (size_t i = 0, len = _foundFuncInfos.size(); i < len; ++i)
299  	{
300  		addEntry(_foundFuncInfos[i]._data2.c_str(), _foundFuncInfos[i]._data.c_str(), _foundFuncInfos[i]._pos);
301  	}
302  	HTREEITEM root = _treeView.getRoot();
303  	if (root)
304  	{
305  		currentBuf = (*_ppEditView)->getCurrentBuffer();
306  		const TCHAR *fullFilePath = currentBuf->getFullPathName();
307  		generic_string* fullPathStr = new generic_string(fullFilePath);
308  		_posStrs.push_back(fullPathStr);
309  		LPARAM lParamFullPathStr = reinterpret_cast<LPARAM>(fullPathStr);
310  		_treeView.setItemParam(root, lParamFullPathStr);
311  		TreeParams *previousParams = getFromStateArray(fullFilePath);
312  		if (!previousParams)
313  		{
314  			::SendMessage(_hSearchEdit, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(TEXT("")));
315  			setSort(NppParameters::getInstance().getNppGUI()._shouldSortFunctionList);
316  			sortOrUnsort();
317  			_treeView.expand(root);
318  		}
319  		else
320  		{
321  			::SendMessage(_hSearchEdit, WM_SETTEXT, 0, reinterpret_cast<LPARAM>((previousParams->_searchParameters)._text2Find.c_str()));
322  			bool isSort = (previousParams->_searchParameters)._doSort;
323  			setSort(isSort);
324  			if (isSort)
325  				_pTreeView->sort(_pTreeView->getRoot(), true);
326  			_treeView.restoreFoldingStateFrom(previousParams->_treeState, root);
327  		}
328  	}
329  	::InvalidateRect(_hSearchEdit, NULL, TRUE);
330  	if (isScrollBarOn)
331  	{
332  		SetScrollInfo(_treeView.getHSelf(), SB_VERT, &si, TRUE);
333  	}
334  }
335  void FunctionListPanel::initPreferencesMenu()
336  {
337  	NativeLangSpeaker* pNativeSpeaker = NppParameters::getInstance().getNativeLangSpeaker();
338  	NppGUI& nppGUI = NppParameters::getInstance().getNppGUI();
339  	generic_string shouldSortFunctionListStr = pNativeSpeaker->getAttrNameStr(TEXT("Sort functions (A to Z) by default"), FL_FUCTIONLISTROOTNODE, FL_PREFERENCE_INITIALSORT);
340  	_hPreferencesMenu = ::CreatePopupMenu();
341  	::InsertMenu(_hPreferencesMenu, 0, MF_BYCOMMAND, FL_PREFERENCES_INITIALSORT_ID, shouldSortFunctionListStr.c_str());
342  	::CheckMenuItem(_hPreferencesMenu, FL_PREFERENCES_INITIALSORT_ID, MF_BYCOMMAND | (nppGUI._shouldSortFunctionList ? MF_CHECKED : MF_UNCHECKED));
343  }
344  void FunctionListPanel::showPreferencesMenu()
345  {
346  	RECT rectToolbar{};
347  	RECT rectPreferencesButton{};
348  	::GetWindowRect(_hToolbarMenu, &rectToolbar);
349  	::SendMessage(_hToolbarMenu, TB_GETRECT, IDC_PREFERENCEBUTTON_FUNCLIST, (LPARAM)&rectPreferencesButton);
350  	::TrackPopupMenu(_hPreferencesMenu,
351  		NppParameters::getInstance().getNativeLangSpeaker()->isRTL() ? TPM_RIGHTALIGN | TPM_LAYOUTRTL : TPM_LEFTALIGN,
352  		rectToolbar.left + rectPreferencesButton.left,
353  		rectToolbar.top + rectPreferencesButton.bottom,
354  		0, _hSelf, NULL);
355  }
356  void FunctionListPanel::markEntry()
357  {
358  	LONG lineNr = static_cast<LONG>((*_ppEditView)->getCurrentLineNumber());
359  	HTREEITEM root = _treeView.getRoot();
360  	if (_findLine != -1 && _findEndLine != -1 && lineNr >= _findLine && lineNr < _findEndLine)
361  		return;
362  	_findLine = -1;
363  	_findEndLine = -1;
364  	findMarkEntry(root, lineNr);
365  	if (_findLine != -1)
366  	{
367  		_treeView.selectItem(_findItem);
368  	}
369  	else
370  	{
371  		_treeView.selectItem(root);
372  	}
373  }
374  void FunctionListPanel::findMarkEntry(HTREEITEM htItem, LONG line)
375  {
376  	HTREEITEM cItem{};
377  	TVITEM tvItem{};
378  	for (; htItem != NULL; htItem = _treeView.getNextSibling(htItem))
379  	{
380  		cItem = _treeView.getChildFrom(htItem);
381  		if (cItem != NULL)
382  		{
383  			findMarkEntry(cItem, line);
384  		}
385  		else
386  		{
387  			tvItem.hItem = htItem;
388  			tvItem.mask = TVIF_IMAGE | TVIF_PARAM;
389  			::SendMessage(_treeViewSearchResult.getHSelf(), TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
390  			generic_string *posStr = reinterpret_cast<generic_string *>(tvItem.lParam);
391  			if (posStr)
392  			{
393  				int pos = _wtoi(posStr->c_str());
394  				if (pos != -1)
395  				{
396  					LONG sci_line = static_cast<LONG>((*_ppEditView)->execute(SCI_LINEFROMPOSITION, pos));
397  					if (line >= sci_line)
398  					{
399  						if (sci_line > _findLine || _findLine == -1)
400  						{
401  							_findLine = sci_line;
402  							_findItem = htItem;
403  						}
404  					}
405  					else
406  					{
407  						if (sci_line < _findEndLine)
408  							_findEndLine = sci_line;
409  					}
410  				}
411  			}
412  		}
413  	}
414  }
415  void FunctionListPanel::init(HINSTANCE hInst, HWND hPere, ScintillaEditView **ppEditView)
416  {
417  	DockingDlgInterface::init(hInst, hPere);
418  	_ppEditView = ppEditView;
419  	NppParameters& nppParams = NppParameters::getInstance();
420  	generic_string funcListXmlPath = nppParams.getUserPath();
421  	pathAppend(funcListXmlPath, TEXT("functionList"));
422  	generic_string funcListDefaultXmlPath = nppParams.getNppPath();
423  	pathAppend(funcListDefaultXmlPath, TEXT("functionList"));
424  	bool doLocalConf = nppParams.isLocal();
425  	if (!doLocalConf)
426  	{
427  		if (!PathFileExists(funcListXmlPath.c_str()))
428  		{
429  			if (PathFileExists(funcListDefaultXmlPath.c_str()))
430  			{
431  				::CopyFile(funcListDefaultXmlPath.c_str(), funcListXmlPath.c_str(), TRUE);
432  				_funcParserMgr.init(funcListXmlPath, funcListDefaultXmlPath, ppEditView);
433  			}
434  		}
435  		else
436  		{
437  			_funcParserMgr.init(funcListXmlPath, funcListDefaultXmlPath, ppEditView);
438  		}
439  	}
440  	else
441  	{
442  		generic_string funcListDefaultXmlPath = nppParams.getNppPath();
443  		pathAppend(funcListDefaultXmlPath, TEXT("functionList"));
444  		if (PathFileExists(funcListDefaultXmlPath.c_str()))
445  		{
446  			_funcParserMgr.init(funcListDefaultXmlPath, funcListDefaultXmlPath, ppEditView);
447  		}
448  	}
449  	ZeroMemory(&si, sizeof(si));
450  	si.cbSize = sizeof(si);
451  	si.fMask = SIF_POS;
452  }
453  bool FunctionListPanel::openSelection(const TreeView & treeView)
454  {
455  	TVITEM tvItem{};
456  	tvItem.mask = TVIF_IMAGE | TVIF_PARAM;
457  	tvItem.hItem = treeView.getSelection();
458  	::SendMessage(treeView.getHSelf(), TVM_GETITEM, 0, reinterpret_cast<LPARAM>(&tvItem));
459  	if (tvItem.iImage == INDEX_ROOT || tvItem.iImage == INDEX_NODE)
460  	{
461  		return false;
462  	}
463  	generic_string *posStr = reinterpret_cast<generic_string *>(tvItem.lParam);
464  	if (!posStr)
465  		return false;
466  	int pos = _wtoi(posStr->c_str());
467  	if (pos == -1)
468  		return false;
469  	auto sci_line = (*_ppEditView)->execute(SCI_LINEFROMPOSITION, pos);
470  	(*_ppEditView)->execute(SCI_ENSUREVISIBLE, sci_line);
471  	(*_ppEditView)->scrollPosToCenter(pos);
472  	return true;
473  }
474  void FunctionListPanel::notified(LPNMHDR notification)
475  {
476  	if (notification->code == TTN_GETDISPINFO)
477  	{
478  		LPTOOLTIPTEXT lpttt = (LPTOOLTIPTEXT)notification;
479  		lpttt->hinst = NULL;
480  		if (notification->idFrom == IDC_SORTBUTTON_FUNCLIST)
481  		{
482  			wcscpy_s(lpttt->szText, _sortTipStr.c_str());
483  		}
484  		else if (notification->idFrom == IDC_RELOADBUTTON_FUNCLIST)
485  		{
486  			wcscpy_s(lpttt->szText, _reloadTipStr.c_str());
487  		}
488  		else if (notification->idFrom == IDC_PREFERENCEBUTTON_FUNCLIST)
489  		{
490  			wcscpy_s(lpttt->szText, _preferenceTipStr.c_str());
491  		}
492  	}
493  	else if (notification->hwndFrom == _treeView.getHSelf() || notification->hwndFrom == _treeViewSearchResult.getHSelf())
494  	{
495  		const TreeView & treeView = notification->hwndFrom == _treeView.getHSelf()?_treeView:_treeViewSearchResult;
496  		switch (notification->code)
497  		{
498  			case NM_DBLCLK:
499  			{
500  				openSelection(treeView);
501  				PostMessage(_hParent, WM_COMMAND, SCEN_SETFOCUS << 16, reinterpret_cast<LPARAM>((*_ppEditView)->getHSelf()));
502  			}
503  			break;
504  			case NM_RETURN:
505  				SetWindowLongPtr(_hSelf, DWLP_MSGRESULT, 1); 
506  			break;
507  			case TVN_KEYDOWN:
508  			{
509  				LPNMTVKEYDOWN ptvkd = (LPNMTVKEYDOWN)notification;
510  				if (ptvkd->wVKey == VK_RETURN)
511  				{
512  					if (!openSelection(treeView))
513  					{
514  						HTREEITEM hItem = treeView.getSelection();
515  						treeView.toggleExpandCollapse(hItem);
516  						break;
517  					}
518  					PostMessage(_hParent, WM_COMMAND, SCEN_SETFOCUS << 16, reinterpret_cast<LPARAM>((*_ppEditView)->getHSelf()));
519  				}
520  				else if (ptvkd->wVKey == VK_TAB)
521  				{
522  					::SetFocus(_hSearchEdit);
523  					SetWindowLongPtr(_hSelf, DWLP_MSGRESULT, 1); 
524  				}
525  				else if (ptvkd->wVKey == VK_ESCAPE)
526  				{
527  					::SendMessage(_hSearchEdit, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(TEXT("")));
528  					SetWindowLongPtr(_hSelf, DWLP_MSGRESULT, 1); 
529  					PostMessage(_hParent, WM_COMMAND, SCEN_SETFOCUS << 16, reinterpret_cast<LPARAM>((*_ppEditView)->getHSelf()));
530  				}
531  			}
532  			break;
533  		}
534  	}
535  	else if (notification->code == DMN_SWITCHIN)
536  	{
537  		reload();
538  	}
539  	else if (notification->code == DMN_CLOSE)
540  	{
541  		::SendMessage(_hParent, WM_COMMAND, IDM_VIEW_FUNC_LIST, 0);
542  	}
543  }
544  void FunctionListPanel::searchFuncAndSwitchView()
545  {
546  	TCHAR text2search[MAX_PATH] = { '\0' };
547  	::SendMessage(_hSearchEdit, WM_GETTEXT, MAX_PATH, reinterpret_cast<LPARAM>(text2search));
548  	if (text2search[0] == '\0')
549  	{
550  		_treeViewSearchResult.display(false);
551  		_treeView.display(true);
552  		_pTreeView = &_treeView;
553  	}
554  	else
555  	{
556  		if (_treeView.getRoot() == NULL)
557  			return;
558  		_treeViewSearchResult.removeAllItems();
559  		const TCHAR *fn = ((*_ppEditView)->getCurrentBuffer())->getFileName();
560  		generic_string* invalidValueStr = new generic_string(TEXT("-1"));
561  		_posStrs.push_back(invalidValueStr);
562  		LPARAM lParamInvalidPosStr = reinterpret_cast<LPARAM>(invalidValueStr);
563  		_treeViewSearchResult.addItem(fn, NULL, INDEX_ROOT, lParamInvalidPosStr);
564  		_treeView.searchLeafAndBuildTree(_treeViewSearchResult, text2search, INDEX_LEAF);
565  		_treeViewSearchResult.display(true);
566  		_treeViewSearchResult.expand(_treeViewSearchResult.getRoot());
567  		_treeView.display(false);
568  		_pTreeView = &_treeViewSearchResult;
569  		::InvalidateRect(_hSearchEdit, NULL, TRUE);
570  	}
571  	if (shouldSort())
572  		_pTreeView->sort(_pTreeView->getRoot(), true);
573  	else
574  		_pTreeView->customSorting(_pTreeView->getRoot(), categorySortFunc, 0, true);
575  }
576  static WNDPROC oldFunclstToolbarProc = NULL;
577  static LRESULT CALLBACK funclstToolbarProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
578  {
579  	switch (message)
580  	{
581  		case WM_CTLCOLOREDIT :
582  		{
583  			return ::SendMessage(::GetParent(hwnd), WM_CTLCOLOREDIT, wParam, lParam);
584  		}
585  	}
586  	return oldFunclstToolbarProc(hwnd, message, wParam, lParam);
587  }
588  static WNDPROC oldFunclstSearchEditProc = NULL;
589  static LRESULT CALLBACK funclstSearchEditProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
590  {
591  	switch (message)
592  	{
593  		case WM_CHAR:
594  		{
595  			if (wParam == VK_ESCAPE)
596  			{
597  				::SendMessage(hwnd, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(TEXT("")));
598  				return FALSE;
599  			}
600  			else if (wParam == VK_TAB)
601  			{
602  				::SendMessage(GetParent(hwnd), WM_COMMAND, VK_TAB, 1);
603  				return FALSE;
604  			}
605  		}
606  	}
607  	return oldFunclstSearchEditProc(hwnd, message, wParam, lParam);
608  }
609  bool FunctionListPanel::shouldSort()
610  {
611  	TBBUTTONINFO tbbuttonInfo{};
612  	tbbuttonInfo.cbSize = sizeof(TBBUTTONINFO);
613  	tbbuttonInfo.dwMask = TBIF_STATE;
614  	::SendMessage(_hToolbarMenu, TB_GETBUTTONINFO, IDC_SORTBUTTON_FUNCLIST, reinterpret_cast<LPARAM>(&tbbuttonInfo));
615  	return (tbbuttonInfo.fsState & TBSTATE_CHECKED) != 0;
616  }
617  void FunctionListPanel::setSort(bool isEnabled)
618  {
619  	TBBUTTONINFO tbbuttonInfo{};
620  	tbbuttonInfo.cbSize = sizeof(TBBUTTONINFO);
621  	tbbuttonInfo.dwMask = TBIF_STATE;
622  	tbbuttonInfo.fsState = isEnabled ? TBSTATE_ENABLED | TBSTATE_CHECKED : TBSTATE_ENABLED;
623  	::SendMessage(_hToolbarMenu, TB_SETBUTTONINFO, IDC_SORTBUTTON_FUNCLIST, reinterpret_cast<LPARAM>(&tbbuttonInfo));
624  }
625  intptr_t CALLBACK FunctionListPanel::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
626  {
627  	switch (message)
628  	{
629  		case WM_CTLCOLOREDIT :
630  		{
631  			TCHAR text2search[MAX_PATH] = { '\0' };
632  			::SendMessage(_hSearchEdit, WM_GETTEXT, MAX_PATH, reinterpret_cast<LPARAM>(text2search));
633  			bool textFound = false;
634  			if (text2search[0] == '\0')
635  			{
636  				textFound = true; 
637  			}
638  			if (!textFound)
639  			{
640  				HTREEITEM searchViewRoot = _treeViewSearchResult.getRoot();
641  				if (searchViewRoot)
642  				{
643  					if (_treeViewSearchResult.getChildFrom(searchViewRoot))
644  					{
645  						textFound = true; 
646  					}
647  				}
648  				else
649  				{
650  					textFound = true; 
651  				}
652  			}
653  			auto hdc = reinterpret_cast<HDC>(wParam);
654  			if (NppDarkMode::isEnabled())
655  			{
656  				if (textFound)
657  				{
658  					return NppDarkMode::onCtlColorSofter(hdc);
659  				}
660  				else 
661  				{
662  					return NppDarkMode::onCtlColorError(hdc);
663  				}
664  			}
665  			if (textFound)
666  			{
667  				return FALSE;
668  			}
669  			static HBRUSH hBrushBackground = CreateSolidBrush(BCKGRD_COLOR);
670  			SetTextColor(hdc, TXT_COLOR);
671  			SetBkColor(hdc, BCKGRD_COLOR);
672  			return reinterpret_cast<LRESULT>(hBrushBackground);
673  		}
674  		case WM_INITDIALOG :
675  		{
676  			FunctionListPanel::initPreferencesMenu();
677  			NppParameters& nppParams = NppParameters::getInstance();
678  			int editWidth = nppParams._dpiManager.scaleX(100);
679  			int editWidthSep = nppParams._dpiManager.scaleX(105); 
680  			int editHeight = nppParams._dpiManager.scaleY(20);
681  			int style = WS_CHILD | WS_VISIBLE | CCS_ADJUSTABLE | TBSTYLE_AUTOSIZE | TBSTYLE_FLAT | TBSTYLE_LIST | TBSTYLE_TRANSPARENT | BTNS_AUTOSIZE | BTNS_SEP | TBSTYLE_TOOLTIPS;
682  			_hToolbarMenu = CreateWindowEx(0,TOOLBARCLASSNAME,NULL, style,
683  								0,0,0,0,_hSelf,nullptr, _hInst, NULL);
684  			oldFunclstToolbarProc = reinterpret_cast<WNDPROC>(::SetWindowLongPtr(_hToolbarMenu, GWLP_WNDPROC, reinterpret_cast<LONG_PTR>(funclstToolbarProc)));
685  			int iconSizeDyn = nppParams._dpiManager.scaleX(16);
686  			::SendMessage(_hToolbarMenu, TB_SETBITMAPSIZE, 0, MAKELPARAM(iconSizeDyn, iconSizeDyn));
687  			TBADDBITMAP addbmp = { 0, 0 };
688  			const int nbIcons = 3;
689  			int iconIDs[nbIcons] = { IDI_FUNCLIST_SORTBUTTON, IDI_FUNCLIST_RELOADBUTTON, IDI_FUNCLIST_PREFERENCEBUTTON };
690  			int iconDarkModeIDs[nbIcons] = { IDI_FUNCLIST_SORTBUTTON_DM, IDI_FUNCLIST_RELOADBUTTON_DM, IDI_FUNCLIST_PREFERENCEBUTTON_DM };
691  			for (size_t i = 0; i < nbIcons; ++i)
692  			{
693  				int icoID = NppDarkMode::isEnabled() ? iconDarkModeIDs[i] : iconIDs[i];
694  				HBITMAP hBmp = static_cast<HBITMAP>(::LoadImage(_hInst, MAKEINTRESOURCE(icoID), IMAGE_BITMAP, iconSizeDyn, iconSizeDyn, LR_LOADMAP3DCOLORS | LR_LOADTRANSPARENT));
695  				addbmp.nID = reinterpret_cast<UINT_PTR>(hBmp);
696  				::SendMessage(_hToolbarMenu, TB_ADDBITMAP, 1, reinterpret_cast<LPARAM>(&addbmp));
697  			}
698  			TBBUTTON tbButtons[1 + nbIcons]{};
699  			tbButtons[0].idCommand = 0;
700  			tbButtons[0].iBitmap = editWidthSep;
701  			tbButtons[0].fsState = TBSTATE_ENABLED;
702  			tbButtons[0].fsStyle = BTNS_SEP; 
703  			tbButtons[0].iString = 0;
704  			tbButtons[1].idCommand = IDC_SORTBUTTON_FUNCLIST;
705  			tbButtons[1].iBitmap = 0;
706  			tbButtons[1].fsState = TBSTATE_ENABLED;
707  			tbButtons[1].fsStyle = BTNS_CHECK | BTNS_AUTOSIZE;
708  			tbButtons[1].iString = reinterpret_cast<intptr_t>(TEXT(""));
709  			tbButtons[2].idCommand = IDC_RELOADBUTTON_FUNCLIST;
710  			tbButtons[2].iBitmap = 1;
711  			tbButtons[2].fsState = TBSTATE_ENABLED;
712  			tbButtons[2].fsStyle = BTNS_BUTTON | BTNS_AUTOSIZE;
713  			tbButtons[2].iString = reinterpret_cast<intptr_t>(TEXT(""));
714  			tbButtons[3].idCommand = IDC_PREFERENCEBUTTON_FUNCLIST;
715  			tbButtons[3].iBitmap = 2;
716  			tbButtons[3].fsState = TBSTATE_ENABLED;
717  			tbButtons[3].fsStyle = BTNS_BUTTON | BTNS_AUTOSIZE;
718  			tbButtons[3].iString = reinterpret_cast<intptr_t>(TEXT(""));
719  			::SendMessage(_hToolbarMenu, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);
720  			::SendMessage(_hToolbarMenu, TB_SETBUTTONSIZE, 0, MAKELONG(nppParams._dpiManager.scaleX(16), nppParams._dpiManager.scaleY(16)));
721  			::SendMessage(_hToolbarMenu, TB_ADDBUTTONS, sizeof(tbButtons) / sizeof(TBBUTTON), reinterpret_cast<LPARAM>(&tbButtons));
722  			::SendMessage(_hToolbarMenu, TB_AUTOSIZE, 0, 0);
723  			ShowWindow(_hToolbarMenu, SW_SHOW);
724  			NativeLangSpeaker *pNativeSpeaker = nppParams.getNativeLangSpeaker();
725  			_sortTipStr = pNativeSpeaker->getAttrNameStr(_sortTipStr.c_str(), FL_FUCTIONLISTROOTNODE, FL_SORTLOCALNODENAME);
726  			_reloadTipStr = pNativeSpeaker->getAttrNameStr(_reloadTipStr.c_str(), FL_FUCTIONLISTROOTNODE, FL_RELOADLOCALNODENAME);
727  			_preferenceTipStr = pNativeSpeaker->getAttrNameStr(_preferenceTipStr.c_str(), FL_FUCTIONLISTROOTNODE, FL_PREFERENCESLOCALNODENAME);
728  			_hSearchEdit = CreateWindowEx(WS_EX_CLIENTEDGE, L"Edit", NULL,
729  								WS_CHILD | WS_VISIBLE | ES_AUTOVSCROLL,
730  								2, 2, editWidth, editHeight,
731  								_hToolbarMenu, reinterpret_cast<HMENU>(IDC_SEARCHFIELD_FUNCLIST), _hInst, 0 );
732  			oldFunclstSearchEditProc = reinterpret_cast<WNDPROC>(::SetWindowLongPtr(_hSearchEdit, GWLP_WNDPROC, reinterpret_cast<LONG_PTR>(funclstSearchEditProc)));
733  			if (_hFontSearchEdit == nullptr)
734  			{
735  				LOGFONT lf{ NppParameters::getDefaultGUIFont() };
736  				_hFontSearchEdit = ::CreateFontIndirect(&lf);
737  			}
738  			if (_hFontSearchEdit != nullptr)
739  			{
740  				::SendMessage(_hSearchEdit, WM_SETFONT, reinterpret_cast<WPARAM>(_hFontSearchEdit), MAKELPARAM(TRUE, 0));
741  			}
742  			_treeView.init(_hInst, _hSelf, IDC_LIST_FUNCLIST);
743  			_treeView.setImageList(CX_BITMAP, CY_BITMAP, 3, IDI_FUNCLIST_ROOT, IDI_FUNCLIST_NODE, IDI_FUNCLIST_LEAF);
744  			_treeViewSearchResult.init(_hInst, _hSelf, IDC_LIST_FUNCLIST_AUX);
745  			_treeViewSearchResult.setImageList(CX_BITMAP, 3, CY_BITMAP, IDI_FUNCLIST_ROOT, IDI_FUNCLIST_NODE, IDI_FUNCLIST_LEAF);
746  			_treeView.makeLabelEditable(false);
747  			_treeView.display();
748  			NppDarkMode::autoSubclassAndThemeChildControls(_hSelf);
749  			NppDarkMode::autoSubclassAndThemeWindowNotify(_hSelf);
750  			return TRUE;
751  		}
752  		case NPPM_INTERNAL_REFRESHDARKMODE:
753  		{
754  			if (static_cast<BOOL>(lParam) != TRUE)
755  			{
756  				NppDarkMode::autoThemeChildControls(_hSelf);
757  			}
758  			NppDarkMode::setTreeViewStyle(_treeView.getHSelf());
759  			return TRUE;
760  		}
761  		case WM_DESTROY:
762  			_treeView.destroy();
763  			_treeViewSearchResult.destroy();
764  			::DestroyMenu(_hPreferencesMenu);
765  			::DestroyWindow(_hToolbarMenu);
766  			break;
767  		case WM_COMMAND :
768  		{
769  			if (HIWORD(wParam) == EN_CHANGE)
770  			{
771  				switch (LOWORD(wParam))
772  				{
773  					case  IDC_SEARCHFIELD_FUNCLIST:
774  					{
775  						searchFuncAndSwitchView();
776  						return TRUE;
777  					}
778  				}
779  			}
780  			else if (wParam == VK_TAB)
781  			{
782  				if (_treeViewSearchResult.isVisible())
783  					::SetFocus(_treeViewSearchResult.getHSelf());
784  				else
785  					::SetFocus(_treeView.getHSelf());
786  				return TRUE;
787  			}
788  			switch (LOWORD(wParam))
789  			{
790  				case IDC_SORTBUTTON_FUNCLIST:
791  				{
792  					sortOrUnsort();
793  				}
794  				return TRUE;
795  				case IDC_RELOADBUTTON_FUNCLIST:
796  				{
797  					reload();
798  				}
799  				return TRUE;
800  				case IDC_PREFERENCEBUTTON_FUNCLIST:
801  				{
802  					showPreferencesMenu();
803  				}
804  				return TRUE;
805  				case FL_PREFERENCES_INITIALSORT_ID:
806  				{
807  					bool& shouldSortFunctionList = NppParameters::getInstance().getNppGUI()._shouldSortFunctionList;
808  					shouldSortFunctionList = !shouldSortFunctionList;
809  					::CheckMenuItem(_hPreferencesMenu, FL_PREFERENCES_INITIALSORT_ID, MF_BYCOMMAND | (shouldSortFunctionList ? MF_CHECKED : MF_UNCHECKED));
810  				}
811  				return TRUE;
812  			}
813  		}
814  		break;
815  		case WM_NOTIFY:
816  		{
817  			notified((LPNMHDR)lParam);
818  		}
819  		return TRUE;
820  		case WM_SIZE:
821  		{
822  			int width = LOWORD(lParam);
823  			int height = HIWORD(lParam);
824  			int extraValue = NppParameters::getInstance()._dpiManager.scaleX(4);
825  			RECT toolbarMenuRect;
826  			::GetClientRect(_hToolbarMenu, &toolbarMenuRect);
827  			::MoveWindow(_hToolbarMenu, 0, 0, width, toolbarMenuRect.bottom, TRUE);
828  			HWND hwnd = _treeView.getHSelf();
829  			if (hwnd)
830  				::MoveWindow(hwnd, 0, toolbarMenuRect.bottom + extraValue, width, height - toolbarMenuRect.bottom - extraValue, TRUE);
831  			HWND hwnd_aux = _treeViewSearchResult.getHSelf();
832  			if (hwnd_aux)
833  				::MoveWindow(hwnd_aux, 0, toolbarMenuRect.bottom + extraValue, width, height - toolbarMenuRect.bottom - extraValue, TRUE);
834  			break;
835  		}
836  		default :
837  			return DockingDlgInterface::run_dlgProc(message, wParam, lParam);
838  	}
839  	return DockingDlgInterface::run_dlgProc(message, wParam, lParam);
840  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-db_lmdb.hpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-functionListPanel.cpp</div>
                <div class="column column_space"><pre><code>38      int mdb_status = mdb_cursor_get(mdb_cursor_, &mdb_key_, &mdb_value_, op);
39      if (mdb_status == MDB_NOTFOUND) {
40        valid_ = false;
41      } else {
42        MDB_CHECK(mdb_status);
43        valid_ = true;
44      }
45    }
</pre></code></div>
                <div class="column column_space"><pre><code>71  			intptr_t tmpStart = (*_ppEditView)->searchInTarget(bodyOpenSymbol, lstrlen(bodyOpenSymbol), targetStart, targetEnd);
72  			if (tmpStart >= 0) 
73  			{
74  				++cntOpen;
75  			}
76  			else 
77  			{
78  				--cntOpen;
79  			}
80  		}
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    