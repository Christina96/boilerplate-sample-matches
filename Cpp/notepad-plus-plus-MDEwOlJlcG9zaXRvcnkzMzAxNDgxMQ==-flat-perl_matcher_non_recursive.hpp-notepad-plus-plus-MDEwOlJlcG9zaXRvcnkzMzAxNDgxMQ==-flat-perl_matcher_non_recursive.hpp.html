
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-perl_matcher_non_recursive.hpp</h3>
            <pre><code>1  #ifndef BOOST_REGEX_V5_PERL_MATCHER_NON_RECURSIVE_HPP
2  #define BOOST_REGEX_V5_PERL_MATCHER_NON_RECURSIVE_HPP
3  #include <boost/regex/v5/mem_block_cache.hpp>
4  #ifdef BOOST_REGEX_MSVC
5  #  pragma warning(push)
6  #  pragma warning(disable: 4706 4459)
7  #if BOOST_REGEX_MSVC < 1910
8  #pragma warning(disable:4800)
9  #endif
10  #endif
11  namespace boost{
12  namespace BOOST_REGEX_DETAIL_NS{
13  template <class T>
14  inline void inplace_destroy(T* p)
15  {
16     (void)p;  
17     p->~T();
18  }
19  struct saved_state
20  {
21     union{
22        unsigned int state_id;
23        std::size_t padding1;
24        std::ptrdiff_t padding2;
25        void* padding3;
26     };
27     saved_state(unsigned i) : state_id(i) {}
28  };
29  template <class BidiIterator>
30  struct saved_matched_paren : public saved_state
31  {
32     int index;
33     sub_match<BidiIterator> sub;
34     saved_matched_paren(int i, const sub_match<BidiIterator>& s) : saved_state(1), index(i), sub(s){}
35  };
36  template <class BidiIterator>
37  struct saved_position : public saved_state
38  {
39     const re_syntax_base* pstate;
40     BidiIterator position;
41     saved_position(const re_syntax_base* ps, BidiIterator pos, int i) : saved_state(i), pstate(ps), position(pos){}
42  };
43  template <class BidiIterator>
44  struct saved_assertion : public saved_position<BidiIterator>
45  {
46     bool positive;
47     saved_assertion(bool p, const re_syntax_base* ps, BidiIterator pos) 
48        : saved_position<BidiIterator>(ps, pos, saved_type_assertion), positive(p){}
49  };
50  template <class BidiIterator>
51  struct saved_repeater : public saved_state
52  {
53     repeater_count<BidiIterator> count;
54     saved_repeater(int i, repeater_count<BidiIterator>** s, BidiIterator start, int current_recursion_id)
55        : saved_state(saved_state_repeater_count), count(i, s, start, current_recursion_id){}
56  };
57  struct saved_extra_block : public saved_state
58  {
59     saved_state *base, *end;
60     saved_extra_block(saved_state* b, saved_state* e) 
61        : saved_state(saved_state_extra_block), base(b), end(e) {}
62  };
63  struct save_state_init
64  {
65     saved_state** stack;
66     save_state_init(saved_state** base, saved_state** end)
67        : stack(base)
68     {
69        *base = static_cast<saved_state*>(get_mem_block());
70        *end = reinterpret_cast<saved_state*>(reinterpret_cast<char*>(*base)+BOOST_REGEX_BLOCKSIZE);
71        --(*end);
72        (void) new (*end)saved_state(0);
73        BOOST_REGEX_ASSERT(*end > *base);
74     }
75     ~save_state_init()
76     {
77        put_mem_block(*stack);
78        *stack = 0;
79     }
80  };
81  template <class BidiIterator>
82  struct saved_single_repeat : public saved_state
83  {
84     std::size_t count;
85     const re_repeat* rep;
86     BidiIterator last_position;
87     saved_single_repeat(std::size_t c, const re_repeat* r, BidiIterator lp, int arg_id) 
88        : saved_state(arg_id), count(c), rep(r), last_position(lp){}
89  };
90  template <class Results>
91  struct saved_recursion : public saved_state
92  {
93     saved_recursion(int idx, const re_syntax_base* p, Results* pr, Results* pr2) 
94        : saved_state(14), recursion_id(idx), preturn_address(p), internal_results(*pr), prior_results(*pr2) {}
95     int recursion_id;
96     const re_syntax_base* preturn_address;
97     Results internal_results, prior_results;
98  };
99  struct saved_change_case : public saved_state
100  {
101     bool icase;
102     saved_change_case(bool c) : saved_state(18), icase(c) {}
103  };
104  struct incrementer
105  {
106     incrementer(unsigned* pu) : m_pu(pu) { ++*m_pu; }
107     ~incrementer() { --*m_pu; }
108     bool operator > (unsigned i) { return *m_pu > i; }
109  private:
110     unsigned* m_pu;
111  };
112  template <class BidiIterator, class Allocator, class traits>
113  bool perl_matcher<BidiIterator, Allocator, traits>::match_all_states()
114  {
115     static matcher_proc_type const s_match_vtable[34] = 
116     {
117        (&perl_matcher<BidiIterator, Allocator, traits>::match_startmark),
118        &perl_matcher<BidiIterator, Allocator, traits>::match_endmark,
119        &perl_matcher<BidiIterator, Allocator, traits>::match_literal,
120        &perl_matcher<BidiIterator, Allocator, traits>::match_start_line,
121        &perl_matcher<BidiIterator, Allocator, traits>::match_end_line,
122        &perl_matcher<BidiIterator, Allocator, traits>::match_wild,
123        &perl_matcher<BidiIterator, Allocator, traits>::match_match,
124        &perl_matcher<BidiIterator, Allocator, traits>::match_word_boundary,
125        &perl_matcher<BidiIterator, Allocator, traits>::match_within_word,
126        &perl_matcher<BidiIterator, Allocator, traits>::match_word_start,
127        &perl_matcher<BidiIterator, Allocator, traits>::match_word_end,
128        &perl_matcher<BidiIterator, Allocator, traits>::match_buffer_start,
129        &perl_matcher<BidiIterator, Allocator, traits>::match_buffer_end,
130        &perl_matcher<BidiIterator, Allocator, traits>::match_backref,
131        &perl_matcher<BidiIterator, Allocator, traits>::match_long_set,
132        &perl_matcher<BidiIterator, Allocator, traits>::match_set,
133        &perl_matcher<BidiIterator, Allocator, traits>::match_jump,
134        &perl_matcher<BidiIterator, Allocator, traits>::match_alt,
135        &perl_matcher<BidiIterator, Allocator, traits>::match_rep,
136        &perl_matcher<BidiIterator, Allocator, traits>::match_combining,
137        &perl_matcher<BidiIterator, Allocator, traits>::match_soft_buffer_end,
138        &perl_matcher<BidiIterator, Allocator, traits>::match_restart_continue,
139        &perl_matcher<BidiIterator, Allocator, traits>::match_dot_repeat_dispatch,
140        &perl_matcher<BidiIterator, Allocator, traits>::match_char_repeat,
141        &perl_matcher<BidiIterator, Allocator, traits>::match_set_repeat,
142        &perl_matcher<BidiIterator, Allocator, traits>::match_long_set_repeat,
143        &perl_matcher<BidiIterator, Allocator, traits>::match_backstep,
144        &perl_matcher<BidiIterator, Allocator, traits>::match_assert_backref,
145        &perl_matcher<BidiIterator, Allocator, traits>::match_toggle_case,
146        &perl_matcher<BidiIterator, Allocator, traits>::match_recursion,
147        &perl_matcher<BidiIterator, Allocator, traits>::match_fail,
148        &perl_matcher<BidiIterator, Allocator, traits>::match_accept,
149        &perl_matcher<BidiIterator, Allocator, traits>::match_commit,
150        &perl_matcher<BidiIterator, Allocator, traits>::match_then,
151     };
152     incrementer inc(&m_recursions);
153     if(inc > 80)
154        raise_error(traits_inst, regex_constants::error_complexity);
155     push_recursion_stopper();
156     do{
157        while(pstate)
158        {
159           matcher_proc_type proc = s_match_vtable[pstate->type];
160           ++state_count;
161           if(!(this->*proc)())
162           {
163              if(state_count > max_state_count)
164                 raise_error(traits_inst, regex_constants::error_complexity);
165              if((m_match_flags & match_partial) && (position == last) && (position != search_base))
166                 m_has_partial_match = true;
167              bool successful_unwind = unwind(false);
168              if((m_match_flags & match_partial) && (position == last) && (position != search_base))
169                 m_has_partial_match = true;
170              if(!successful_unwind)
171                 return m_recursive_result;
172           }
173        }
174     }while(unwind(true));
175     return m_recursive_result;
176  }
177  template <class BidiIterator, class Allocator, class traits>
178  void perl_matcher<BidiIterator, Allocator, traits>::extend_stack()
179  {
180     if(used_block_count)
181     {
182        --used_block_count;
183        saved_state* stack_base;
184        saved_state* backup_state;
185        stack_base = static_cast<saved_state*>(get_mem_block());
186        backup_state = reinterpret_cast<saved_state*>(reinterpret_cast<char*>(stack_base)+BOOST_REGEX_BLOCKSIZE);
187        saved_extra_block* block = static_cast<saved_extra_block*>(backup_state);
188        --block;
189        (void) new (block) saved_extra_block(m_stack_base, m_backup_state);
190        m_stack_base = stack_base;
191        m_backup_state = block;
192     }
193     else
194        raise_error(traits_inst, regex_constants::error_stack);
195  }
196  template <class BidiIterator, class Allocator, class traits>
197  inline void perl_matcher<BidiIterator, Allocator, traits>::push_matched_paren(int index, const sub_match<BidiIterator>& sub)
198  {
199     saved_matched_paren<BidiIterator>* pmp = static_cast<saved_matched_paren<BidiIterator>*>(m_backup_state);
200     --pmp;
201     if(pmp < m_stack_base)
202     {
203        extend_stack();
204        pmp = static_cast<saved_matched_paren<BidiIterator>*>(m_backup_state);
205        --pmp;
206     }
207     (void) new (pmp)saved_matched_paren<BidiIterator>(index, sub);
208     m_backup_state = pmp;
209  }
210  template <class BidiIterator, class Allocator, class traits>
211  inline void perl_matcher<BidiIterator, Allocator, traits>::push_case_change(bool c)
212  {
213     saved_change_case* pmp = static_cast<saved_change_case*>(m_backup_state);
214     --pmp;
215     if(pmp < m_stack_base)
216     {
217        extend_stack();
218        pmp = static_cast<saved_change_case*>(m_backup_state);
219        --pmp;
220     }
221     (void) new (pmp)saved_change_case(c);
222     m_backup_state = pmp;
223  }
224  template <class BidiIterator, class Allocator, class traits>
225  inline void perl_matcher<BidiIterator, Allocator, traits>::push_recursion_stopper()
226  {
227     saved_state* pmp = m_backup_state;
228     --pmp;
229     if(pmp < m_stack_base)
230     {
231        extend_stack();
232        pmp = m_backup_state;
233        --pmp;
234     }
235     (void) new (pmp)saved_state(saved_type_recurse);
236     m_backup_state = pmp;
237  }
238  template <class BidiIterator, class Allocator, class traits>
239  inline void perl_matcher<BidiIterator, Allocator, traits>::push_assertion(const re_syntax_base* ps, bool positive)
240  {
241     saved_assertion<BidiIterator>* pmp = static_cast<saved_assertion<BidiIterator>*>(m_backup_state);
242     --pmp;
243     if(pmp < m_stack_base)
244     {
245        extend_stack();
246        pmp = static_cast<saved_assertion<BidiIterator>*>(m_backup_state);
247        --pmp;
248     }
249     (void) new (pmp)saved_assertion<BidiIterator>(positive, ps, position);
250     m_backup_state = pmp;
251  }
252  template <class BidiIterator, class Allocator, class traits>
253  inline void perl_matcher<BidiIterator, Allocator, traits>::push_alt(const re_syntax_base* ps)
254  {
255     saved_position<BidiIterator>* pmp = static_cast<saved_position<BidiIterator>*>(m_backup_state);
256     --pmp;
257     if(pmp < m_stack_base)
258     {
259        extend_stack();
260        pmp = static_cast<saved_position<BidiIterator>*>(m_backup_state);
261        --pmp;
262     }
263     (void) new (pmp)saved_position<BidiIterator>(ps, position, saved_state_alt);
264     m_backup_state = pmp;
265  }
266  template <class BidiIterator, class Allocator, class traits>
267  inline void perl_matcher<BidiIterator, Allocator, traits>::push_non_greedy_repeat(const re_syntax_base* ps)
268  {
269     saved_position<BidiIterator>* pmp = static_cast<saved_position<BidiIterator>*>(m_backup_state);
270     --pmp;
271     if(pmp < m_stack_base)
272     {
273        extend_stack();
274        pmp = static_cast<saved_position<BidiIterator>*>(m_backup_state);
275        --pmp;
276     }
277     (void) new (pmp)saved_position<BidiIterator>(ps, position, saved_state_non_greedy_long_repeat);
278     m_backup_state = pmp;
279  }
280  template <class BidiIterator, class Allocator, class traits>
281  inline void perl_matcher<BidiIterator, Allocator, traits>::push_repeater_count(int i, repeater_count<BidiIterator>** s)
282  {
283     saved_repeater<BidiIterator>* pmp = static_cast<saved_repeater<BidiIterator>*>(m_backup_state);
284     --pmp;
285     if(pmp < m_stack_base)
286     {
287        extend_stack();
288        pmp = static_cast<saved_repeater<BidiIterator>*>(m_backup_state);
289        --pmp;
290     }
291     (void) new (pmp)saved_repeater<BidiIterator>(i, s, position, this->recursion_stack.empty() ? (INT_MIN + 3) : this->recursion_stack.back().idx);
292     m_backup_state = pmp;
293  }
294  template <class BidiIterator, class Allocator, class traits>
295  inline void perl_matcher<BidiIterator, Allocator, traits>::push_single_repeat(std::size_t c, const re_repeat* r, BidiIterator last_position, int state_id)
296  {
297     saved_single_repeat<BidiIterator>* pmp = static_cast<saved_single_repeat<BidiIterator>*>(m_backup_state);
298     --pmp;
299     if(pmp < m_stack_base)
300     {
301        extend_stack();
302        pmp = static_cast<saved_single_repeat<BidiIterator>*>(m_backup_state);
303        --pmp;
304     }
305     (void) new (pmp)saved_single_repeat<BidiIterator>(c, r, last_position, state_id);
306     m_backup_state = pmp;
307  }
308  template <class BidiIterator, class Allocator, class traits>
309  inline void perl_matcher<BidiIterator, Allocator, traits>::push_recursion(int idx, const re_syntax_base* p, results_type* presults, results_type* presults2)
310  {
311     saved_recursion<results_type>* pmp = static_cast<saved_recursion<results_type>*>(m_backup_state);
312     --pmp;
313     if(pmp < m_stack_base)
314     {
315        extend_stack();
316        pmp = static_cast<saved_recursion<results_type>*>(m_backup_state);
317        --pmp;
318     }
319     (void) new (pmp)saved_recursion<results_type>(idx, p, presults, presults2);
320     m_backup_state = pmp;
321  }
322  template <class BidiIterator, class Allocator, class traits>
323  bool perl_matcher<BidiIterator, Allocator, traits>::match_toggle_case()
324  {
325     push_case_change(this->icase);
326     this->icase = static_cast<const re_case*>(pstate)->icase;
327     pstate = pstate->next.p;
328     return true;
329  }
330  template <class BidiIterator, class Allocator, class traits>
331  bool perl_matcher<BidiIterator, Allocator, traits>::match_startmark()
332  {
333     int index = static_cast<const re_brace*>(pstate)->index;
334     icase = static_cast<const re_brace*>(pstate)->icase;
335     switch(index)
336     {
337     case 0:
338        pstate = pstate->next.p;
339        break;
340     case -1:
341     case -2:
342        {
343           const re_syntax_base* next_pstate = static_cast<const re_jump*>(pstate->next.p)->alt.p->next.p;
344           pstate = pstate->next.p->next.p;
345           push_assertion(next_pstate, index == -1);
346           break;
347        }
348     case -3:
349        {
350           bool old_independent = m_independent;
351           m_independent = true;
352           const re_syntax_base* next_pstate = static_cast<const re_jump*>(pstate->next.p)->alt.p->next.p;
353           pstate = pstate->next.p->next.p;
354           bool r = false;
355  #if !defined(BOOST_NO_EXCEPTIONS)
356        try{
357  #endif
358           r = match_all_states();
359           if(!r && !m_independent)
360           {
361              while (m_backup_state->state_id)
362                 unwind(false);
363              return false;
364           }
365  #if !defined(BOOST_NO_EXCEPTIONS)
366        }
367        catch(...)
368        {
369           pstate = next_pstate;
370           while(unwind(true)) {}
371           throw;
372        }
373  #endif
374        pstate = next_pstate;
375        m_independent = old_independent;
376  #ifdef BOOST_REGEX_MATCH_EXTRA
377           if(r && (m_match_flags & match_extra))
378           {
379              match_results<BidiIterator, Allocator> temp_match(*m_presult);
380              unsigned i;
381              for(i = 0; i < temp_match.size(); ++i)
382                 (*m_presult)[i].get_captures().clear();
383  #if !defined(BOOST_NO_EXCEPTIONS)
384              try{
385  #endif
386                 r = match_all_states();
387  #if !defined(BOOST_NO_EXCEPTIONS)
388              }
389              catch(...)
390              {
391                 pstate = next_pstate;
392                 while(unwind(true)) {}
393                 throw;
394              }
395  #endif
396              for(i = 0; i < temp_match.size(); ++i)
397              {
398                 typedef typename sub_match<BidiIterator>::capture_sequence_type seq;
399                 seq& s1 = (*m_presult)[i].get_captures();
400                 const seq& s2 = temp_match[i].captures();
401                 s1.insert(
402                    s1.end(), 
403                    s2.begin(), 
404                    s2.end());
405              }
406           }
407  #endif
408           return r;
409        }
410     case -4:
411        {
412        const re_alt* alt = static_cast<const re_alt*>(pstate->next.p);
413        BOOST_REGEX_ASSERT(alt->type == syntax_element_alt);
414        pstate = alt->next.p;
415        if(pstate->type == syntax_element_assert_backref)
416        {
417           if(!match_assert_backref())
418              pstate = alt->alt.p;
419           break;
420        }
421        else
422        {
423           BOOST_REGEX_ASSERT(pstate->type == syntax_element_startmark);
424           bool negated = static_cast<const re_brace*>(pstate)->index == -2;
425           BidiIterator saved_position = position;
426           const re_syntax_base* next_pstate = static_cast<const re_jump*>(pstate->next.p)->alt.p->next.p;
427           pstate = pstate->next.p->next.p;
428  #if !defined(BOOST_NO_EXCEPTIONS)
429           try{
430  #endif
431              bool r = match_all_states();
432              position = saved_position;
433              if(negated)
434                 r = !r;
435              if(r)
436                 pstate = next_pstate;
437              else
438                 pstate = alt->alt.p;
439  #if !defined(BOOST_NO_EXCEPTIONS)
440           }
441           catch(...)
442           {
443              pstate = next_pstate;
444              while(unwind(true)){}
445              throw;
446           }
447  #endif
448           break;
449        }
450        }
451     case -5:
452        {
453           push_matched_paren(0, (*m_presult)[0]);
454           m_presult->set_first(position, 0, true);
455           pstate = pstate->next.p;
456           break;
457        }
458     default:
459     {
460        BOOST_REGEX_ASSERT(index > 0);
461        if((m_match_flags & match_nosubs) == 0)
462        {
463           push_matched_paren(index, (*m_presult)[index]);
464           m_presult->set_first(position, index);
465        }
466        pstate = pstate->next.p;
467        break;
468     }
469     }
470     return true;
471  }
472  template <class BidiIterator, class Allocator, class traits>
473  bool perl_matcher<BidiIterator, Allocator, traits>::match_alt()
474  {
475     bool take_first, take_second;
476     const re_alt* jmp = static_cast<const re_alt*>(pstate);
477     if(position == last)
478     {
479        take_first = jmp->can_be_null & mask_take;
480        take_second = jmp->can_be_null & mask_skip;
481     }
482     else
483     {
484        take_first = can_start(*position, jmp->_map, (unsigned char)mask_take);
485        take_second = can_start(*position, jmp->_map, (unsigned char)mask_skip);
486    }
487     if(take_first)
488     {
489        if(take_second)
490        {
491           push_alt(jmp->alt.p);
492        }
493        pstate = pstate->next.p;
494        return true;
495     }
496     if(take_second)
497     {
498        pstate = jmp->alt.p;
499        return true;
500     }
501     return false;  
502  }
503  template <class BidiIterator, class Allocator, class traits>
504  bool perl_matcher<BidiIterator, Allocator, traits>::match_rep()
505  {
506  #ifdef BOOST_REGEX_MSVC
507  #pragma warning(push)
508  #pragma warning(disable:4127 4244)
509  #endif
510  #ifdef BOOST_BORLANDC
511  #pragma option push -w-8008 -w-8066 -w-8004
512  #endif
513     const re_repeat* rep = static_cast<const re_repeat*>(pstate);
514     bool take_first, take_second;
515     if(position == last)
516     {
517        take_first = rep->can_be_null & mask_take;
518        take_second = rep->can_be_null & mask_skip;
519     }
520     else
521     {
522        take_first = can_start(*position, rep->_map, (unsigned char)mask_take);
523        take_second = can_start(*position, rep->_map, (unsigned char)mask_skip);
524     }
525     if((m_backup_state->state_id != saved_state_repeater_count) 
526        || (static_cast<saved_repeater<BidiIterator>*>(m_backup_state)->count.get_id() != rep->state_id)
527        || (next_count->get_id() != rep->state_id))
528     {
529        push_repeater_count(rep->state_id, &next_count);
530     }
531     next_count->check_null_repeat(position, rep->max);
532     if(next_count->get_count() < rep->min)
533     {
534        if(take_first)
535        {
536           ++(*next_count);
537           pstate = rep->next.p;
538           return true;
539        }
540        return false;
541     }
542     bool greedy = (rep->greedy) && (!(m_match_flags & regex_constants::match_any) || m_independent);   
543     if(greedy)
544     {
<span onclick='openModal()' class='match'>545        if((next_count->get_count() < rep->max) && take_first)
546        {
547           if(take_second)
</span>548           {
549              push_alt(rep->alt.p);
550           }
551           ++(*next_count);
552           pstate = rep->next.p;
553           return true;
554        }
555        else if(take_second)
556        {
557           pstate = rep->alt.p;
558           return true;
559        }
560        return false; 
561     }
562     else 
563     {
564        if(take_second)
565        {
566           if((next_count->get_count() < rep->max) && take_first)
567           {
568              push_non_greedy_repeat(rep->next.p);
569           }
570           pstate = rep->alt.p;
571           return true;
572        }
573        if((next_count->get_count() < rep->max) && take_first)
574        {
575           ++(*next_count);
576           pstate = rep->next.p;
577           return true;
578        }
579     }
580     return false;
581  #ifdef BOOST_BORLANDC
582  #pragma option pop
583  #endif
584  #ifdef BOOST_REGEX_MSVC
585  #pragma warning(pop)
586  #endif
587  }
588  template <class BidiIterator, class Allocator, class traits>
589  bool perl_matcher<BidiIterator, Allocator, traits>::match_dot_repeat_slow()
590  {
591     std::size_t count = 0;
592     const re_repeat* rep = static_cast<const re_repeat*>(pstate);
593     re_syntax_base* psingle = rep->next.p;
594     while(count < rep->min)
595     {
596        pstate = psingle;
597        if(!match_wild())
598           return false;
599        ++count;
600     }
601     bool greedy = (rep->greedy) && (!(m_match_flags & regex_constants::match_any) || m_independent);   
602     if(greedy)
603     {
604        while(count < rep->max)
605        {
606           pstate = psingle;
607           if(!match_wild())
608              break;
609           ++count;
610        }
611        if((rep->leading) && (count < rep->max))
612           restart = position;
613        if(count - rep->min)
614           push_single_repeat(count, rep, position, saved_state_greedy_single_repeat);
615        pstate = rep->alt.p;
616        return true;
617     }
618     else
619     {
620        if(count < rep->max)
621           push_single_repeat(count, rep, position, saved_state_rep_slow_dot);
622        pstate = rep->alt.p;
623        return (position == last) ? (rep->can_be_null & mask_skip) : can_start(*position, rep->_map, mask_skip);
624     }
625  }
626  template <class BidiIterator, class Allocator, class traits>
627  bool perl_matcher<BidiIterator, Allocator, traits>::match_dot_repeat_fast()
628  {
629     if(m_match_flags & match_not_dot_null)
630        return match_dot_repeat_slow();
631     if((static_cast<const re_dot*>(pstate->next.p)->mask & match_any_mask) == 0)
632        return match_dot_repeat_slow();
633     const re_repeat* rep = static_cast<const re_repeat*>(pstate);
634     bool greedy = (rep->greedy) && (!(m_match_flags & regex_constants::match_any) || m_independent);   
635     std::size_t count = static_cast<std::size_t>((std::min)(static_cast<std::size_t>(std::distance(position, last)), greedy ? rep->max : rep->min));
636     if(rep->min > count)
637     {
638        position = last;
639        return false;  
640     }
641     std::advance(position, count);
642     if(greedy)
643     {
644        if((rep->leading) && (count < rep->max))
645           restart = position;
646        if(count - rep->min)
647           push_single_repeat(count, rep, position, saved_state_greedy_single_repeat);
648        pstate = rep->alt.p;
649        return true;
650     }
651     else
652     {
653        if(count < rep->max)
654           push_single_repeat(count, rep, position, saved_state_rep_fast_dot);
655        pstate = rep->alt.p;
656        return (position == last) ? (rep->can_be_null & mask_skip) : can_start(*position, rep->_map, mask_skip);
657     }
658  }
659  template <class BidiIterator, class Allocator, class traits>
660  bool perl_matcher<BidiIterator, Allocator, traits>::match_char_repeat()
661  {
662  #ifdef BOOST_REGEX_MSVC
663  #pragma warning(push)
664  #pragma warning(disable:4127)
665  #endif
666  #ifdef BOOST_BORLANDC
667  #pragma option push -w-8008 -w-8066 -w-8004
668  #endif
669     const re_repeat* rep = static_cast<const re_repeat*>(pstate);
670     BOOST_REGEX_ASSERT(1 == static_cast<const re_literal*>(rep->next.p)->length);
671     const char_type what = *reinterpret_cast<const char_type*>(static_cast<const re_literal*>(rep->next.p) + 1);
672     std::size_t count = 0;
673     bool greedy = (rep->greedy) && (!(m_match_flags & regex_constants::match_any) || m_independent);   
674     std::size_t desired = greedy ? rep->max : rep->min;
675     if(::boost::is_random_access_iterator<BidiIterator>::value)
676     {
677        BidiIterator end = position;
678        std::size_t len = (desired == (std::numeric_limits<std::size_t>::max)()) ? 0u : std::distance(position, last);
679        if(desired >= len)
680           end = last;
681        else
682           std::advance(end, desired);
683        BidiIterator origin(position);
684        while((position != end) && (traits_inst.translate(*position, icase) == what))
685        {
686           ++position;
687        }
688        count = (unsigned)std::distance(origin, position);
689     }
690     else
691     {
692        while((count < desired) && (position != last) && (traits_inst.translate(*position, icase) == what))
693        {
694           ++position;
695           ++count;
696        }
697     }
698     if(count < rep->min)
699        return false;
700     if(greedy)
701     {
702        if((rep->leading) && (count < rep->max))
703           restart = position;
704        if(count - rep->min)
705           push_single_repeat(count, rep, position, saved_state_greedy_single_repeat);
706        pstate = rep->alt.p;
707        return true;
708     }
709     else
710     {
711        if(count < rep->max)
712           push_single_repeat(count, rep, position, saved_state_rep_char);
713        pstate = rep->alt.p;
714        return (position == last) ? (rep->can_be_null & mask_skip) : can_start(*position, rep->_map, mask_skip);
715     }
716  #ifdef BOOST_BORLANDC
717  #pragma option pop
718  #endif
719  #ifdef BOOST_REGEX_MSVC
720  #pragma warning(pop)
721  #endif
722  }
723  template <class BidiIterator, class Allocator, class traits>
724  bool perl_matcher<BidiIterator, Allocator, traits>::match_set_repeat()
725  {
726  #ifdef BOOST_REGEX_MSVC
727  #pragma warning(push)
728  #pragma warning(disable:4127)
729  #endif
730  #ifdef BOOST_BORLANDC
731  #pragma option push -w-8008 -w-8066 -w-8004
732  #endif
733     const re_repeat* rep = static_cast<const re_repeat*>(pstate);
734     const unsigned char* map = static_cast<const re_set*>(rep->next.p)->_map;
735     std::size_t count = 0;
736     bool greedy = (rep->greedy) && (!(m_match_flags & regex_constants::match_any) || m_independent);   
737     std::size_t desired = greedy ? rep->max : rep->min;
738     if(::boost::is_random_access_iterator<BidiIterator>::value)
739     {
740        BidiIterator end = position;
741        std::size_t len = (desired == (std::numeric_limits<std::size_t>::max)()) ? 0u : std::distance(position, last);
742        if(desired >= len)
743           end = last;
744        else
745           std::advance(end, desired);
746        BidiIterator origin(position);
747        while((position != end) && map[static_cast<unsigned char>(traits_inst.translate(*position, icase))])
748        {
749           ++position;
750        }
751        count = (unsigned)std::distance(origin, position);
752     }
753     else
754     {
755        while((count < desired) && (position != last) && map[static_cast<unsigned char>(traits_inst.translate(*position, icase))])
756        {
757           ++position;
758           ++count;
759        }
760     }
761     if(count < rep->min)
762        return false;
763     if(greedy)
764     {
765        if((rep->leading) && (count < rep->max))
766           restart = position;
767        if(count - rep->min)
768           push_single_repeat(count, rep, position, saved_state_greedy_single_repeat);
769        pstate = rep->alt.p;
770        return true;
771     }
772     else
773     {
774        if(count < rep->max)
775           push_single_repeat(count, rep, position, saved_state_rep_short_set);
776        pstate = rep->alt.p;
777        return (position == last) ? (rep->can_be_null & mask_skip) : can_start(*position, rep->_map, mask_skip);
778     }
779  #ifdef BOOST_BORLANDC
780  #pragma option pop
781  #endif
782  #ifdef BOOST_REGEX_MSVC
783  #pragma warning(pop)
784  #endif
785  }
786  template <class BidiIterator, class Allocator, class traits>
787  bool perl_matcher<BidiIterator, Allocator, traits>::match_long_set_repeat()
788  {
789  #ifdef BOOST_REGEX_MSVC
790  #pragma warning(push)
791  #pragma warning(disable:4127)
792  #endif
793  #ifdef BOOST_BORLANDC
794  #pragma option push -w-8008 -w-8066 -w-8004
795  #endif
796     typedef typename traits::char_class_type m_type;
797     const re_repeat* rep = static_cast<const re_repeat*>(pstate);
798     const re_set_long<m_type>* set = static_cast<const re_set_long<m_type>*>(pstate->next.p);
799     std::size_t count = 0;
800     bool greedy = (rep->greedy) && (!(m_match_flags & regex_constants::match_any) || m_independent);   
801     std::size_t desired = greedy ? rep->max : rep->min;
802     if(::boost::is_random_access_iterator<BidiIterator>::value)
803     {
804        BidiIterator end = position;
805        std::size_t len = (desired == (std::numeric_limits<std::size_t>::max)()) ? 0u : std::distance(position, last);
806        if(desired >= len)
807           end = last;
808        else
809           std::advance(end, desired);
810        BidiIterator origin(position);
811        while((position != end) && (position != re_is_set_member(position, last, set, re.get_data(), icase)))
812        {
813           ++position;
814        }
815        count = (unsigned)std::distance(origin, position);
816     }
817     else
818     {
819        while((count < desired) && (position != last) && (position != re_is_set_member(position, last, set, re.get_data(), icase)))
820        {
821           ++position;
822           ++count;
823        }
824     }
825     if(count < rep->min)
826        return false;
827     if(greedy)
828     {
829        if((rep->leading) && (count < rep->max))
830           restart = position;
831        if(count - rep->min)
832           push_single_repeat(count, rep, position, saved_state_greedy_single_repeat);
833        pstate = rep->alt.p;
834        return true;
835     }
836     else
837     {
838        if(count < rep->max)
839           push_single_repeat(count, rep, position, saved_state_rep_long_set);
840        pstate = rep->alt.p;
841        return (position == last) ? (rep->can_be_null & mask_skip) : can_start(*position, rep->_map, mask_skip);
842     }
843  #ifdef BOOST_BORLANDC
844  #pragma option pop
845  #endif
846  #ifdef BOOST_REGEX_MSVC
847  #pragma warning(pop)
848  #endif
849  }
850  template <class BidiIterator, class Allocator, class traits>
851  bool perl_matcher<BidiIterator, Allocator, traits>::match_recursion()
852  {
853     BOOST_REGEX_ASSERT(pstate->type == syntax_element_recurse);
854     for(typename std::vector<recursion_info<results_type> >::reverse_iterator i = recursion_stack.rbegin(); i != recursion_stack.rend(); ++i)
855     {
856        if(i->idx == static_cast<const re_brace*>(static_cast<const re_jump*>(pstate)->alt.p)->index)
857        {
858           if(i->location_of_start == position)
859              return false;
860           break;
861        }
862     }
863     push_recursion_pop();
864     if(recursion_stack.capacity() == 0)
865     {
866        recursion_stack.reserve(50);
867     }
868     recursion_stack.push_back(recursion_info<results_type>());
869     recursion_stack.back().preturn_address = pstate->next.p;
870     recursion_stack.back().results = *m_presult;
871     pstate = static_cast<const re_jump*>(pstate)->alt.p;
872     recursion_stack.back().idx = static_cast<const re_brace*>(pstate)->index;
873     recursion_stack.back().location_of_start = position;
874     {
875        push_repeater_count(-(2 + static_cast<const re_brace*>(pstate)->index), &next_count);
876     }
877     return true;
878  }
879  template <class BidiIterator, class Allocator, class traits>
880  bool perl_matcher<BidiIterator, Allocator, traits>::match_endmark()
881  {
882     int index = static_cast<const re_brace*>(pstate)->index;
883     icase = static_cast<const re_brace*>(pstate)->icase;
884     if(index > 0)
885     {
886        if((m_match_flags & match_nosubs) == 0)
887        {
888           m_presult->set_second(position, index);
889        }
890        if(!recursion_stack.empty())
891        {
892           if(index == recursion_stack.back().idx)
893           {
894              pstate = recursion_stack.back().preturn_address;
895              *m_presult = recursion_stack.back().results;
896              push_recursion(recursion_stack.back().idx, recursion_stack.back().preturn_address, m_presult, &recursion_stack.back().results);
897              recursion_stack.pop_back();
898              push_repeater_count(-(2 + index), &next_count);
899           }
900        }
901     }
902     else if((index < 0) && (index != -4))
903     {
904        pstate = 0;
905        return true;
906     }
907     pstate = pstate->next.p;
908     return true;
909  }
910  template <class BidiIterator, class Allocator, class traits>
911  bool perl_matcher<BidiIterator, Allocator, traits>::match_match()
912  {
913     if(!recursion_stack.empty())
914     {
915        BOOST_REGEX_ASSERT(0 == recursion_stack.back().idx);
916        pstate = recursion_stack.back().preturn_address;
917        push_recursion(recursion_stack.back().idx, recursion_stack.back().preturn_address, m_presult, &recursion_stack.back().results);
918        *m_presult = recursion_stack.back().results;
919        recursion_stack.pop_back();
920        return true;
921     }
922     if((m_match_flags & match_not_null) && (position == (*m_presult)[0].first))
923        return false;
924     if((m_match_flags & match_all) && (position != last))
925        return false;
926     if((m_match_flags & regex_constants::match_not_initial_null) && (position == search_base))
927        return false;
928     m_presult->set_second(position);
929     pstate = 0;
930     m_has_found_match = true;
931     if((m_match_flags & match_posix) == match_posix)
932     {
933        m_result.maybe_assign(*m_presult);
934        if((m_match_flags & match_any) == 0)
935           return false;
936     }
937  #ifdef BOOST_REGEX_MATCH_EXTRA
938     if(match_extra & m_match_flags)
939     {
940        for(unsigned i = 0; i < m_presult->size(); ++i)
941           if((*m_presult)[i].matched)
942              ((*m_presult)[i]).get_captures().push_back((*m_presult)[i]);
943     }
944  #endif
945     return true;
946  }
947  template <class BidiIterator, class Allocator, class traits>
948  bool perl_matcher<BidiIterator, Allocator, traits>::match_commit()
949  {
950     switch(static_cast<const re_commit*>(pstate)->action)
951     {
952     case commit_commit:
953        restart = last;
954        break;
955     case commit_skip:
956        if(base != position)
957        {
958           restart = position;
959           --restart;
960        }
961        break;
962     case commit_prune:
963        break;
964     }
965     saved_state* pmp = m_backup_state;
966     --pmp;
967     if(pmp < m_stack_base)
968     {
969        extend_stack();
970        pmp = m_backup_state;
971        --pmp;
972     }
973     (void) new (pmp)saved_state(16);
974     m_backup_state = pmp;
975     pstate = pstate->next.p;
976     return true;
977  }
978  template <class BidiIterator, class Allocator, class traits>
979  bool perl_matcher<BidiIterator, Allocator, traits>::match_then()
980  {
981     saved_state* pmp = m_backup_state;
982     --pmp;
983     if(pmp < m_stack_base)
984     {
985        extend_stack();
986        pmp = m_backup_state;
987        --pmp;
988     }
989     (void) new (pmp)saved_state(17);
990     m_backup_state = pmp;
991     pstate = pstate->next.p;
992     return true;
993  }
994  template <class BidiIterator, class Allocator, class traits>
995  bool perl_matcher<BidiIterator, Allocator, traits>::skip_until_paren(int index, bool have_match)
996  {
997     while(pstate)
998     {
999        if(pstate->type == syntax_element_endmark)
1000        {
1001           if(static_cast<const re_brace*>(pstate)->index == index)
1002           {
1003              if(have_match)
1004                 return this->match_endmark();
1005              pstate = pstate->next.p;
1006              return true;
1007           }
1008           else
1009           {
1010              const re_syntax_base* sp = pstate;
1011              match_endmark();
1012              if(!pstate)
1013              {
1014                 unwind(true);
1015                 if (!pstate)
1016                    pstate = sp->next.p;
1017              }
1018           }
1019           continue;
1020        }
1021        else if(pstate->type == syntax_element_match)
1022           return true;
1023        else if(pstate->type == syntax_element_startmark)
1024        {
1025           int idx = static_cast<const re_brace*>(pstate)->index;
1026           pstate = pstate->next.p;
1027           skip_until_paren(idx, false);
1028           continue;
1029        }
1030        pstate = pstate->next.p;
1031     }
1032     return true;
1033  }
1034  template <class BidiIterator, class Allocator, class traits>
1035  bool perl_matcher<BidiIterator, Allocator, traits>::unwind(bool have_match)
1036  {
1037     static unwind_proc_type const s_unwind_table[19] = 
1038     {
1039        &perl_matcher<BidiIterator, Allocator, traits>::unwind_end,
1040        &perl_matcher<BidiIterator, Allocator, traits>::unwind_paren,
1041        &perl_matcher<BidiIterator, Allocator, traits>::unwind_recursion_stopper,
1042        &perl_matcher<BidiIterator, Allocator, traits>::unwind_assertion,
1043        &perl_matcher<BidiIterator, Allocator, traits>::unwind_alt,
1044        &perl_matcher<BidiIterator, Allocator, traits>::unwind_repeater_counter,
1045        &perl_matcher<BidiIterator, Allocator, traits>::unwind_extra_block,
1046        &perl_matcher<BidiIterator, Allocator, traits>::unwind_greedy_single_repeat,
1047        &perl_matcher<BidiIterator, Allocator, traits>::unwind_slow_dot_repeat,
1048        &perl_matcher<BidiIterator, Allocator, traits>::unwind_fast_dot_repeat,
1049        &perl_matcher<BidiIterator, Allocator, traits>::unwind_char_repeat,
1050        &perl_matcher<BidiIterator, Allocator, traits>::unwind_short_set_repeat,
1051        &perl_matcher<BidiIterator, Allocator, traits>::unwind_long_set_repeat,
1052        &perl_matcher<BidiIterator, Allocator, traits>::unwind_non_greedy_repeat,
1053        &perl_matcher<BidiIterator, Allocator, traits>::unwind_recursion,
1054        &perl_matcher<BidiIterator, Allocator, traits>::unwind_recursion_pop,
1055        &perl_matcher<BidiIterator, Allocator, traits>::unwind_commit,
1056        &perl_matcher<BidiIterator, Allocator, traits>::unwind_then,
1057        &perl_matcher<BidiIterator, Allocator, traits>::unwind_case,
1058     };
1059     m_recursive_result = have_match;
1060     m_unwound_lookahead = false;
1061     m_unwound_alt = false;
1062     unwind_proc_type unwinder;
1063     bool cont;
1064     do
1065     {
1066        unwinder = s_unwind_table[m_backup_state->state_id];
1067        cont = (this->*unwinder)(m_recursive_result);
1068     }while(cont);
1069     return pstate ? true : false;
1070  }
1071  template <class BidiIterator, class Allocator, class traits>
1072  bool perl_matcher<BidiIterator, Allocator, traits>::unwind_end(bool)
1073  {
1074     pstate = 0;   
1075     return false; 
1076  }
1077  template <class BidiIterator, class Allocator, class traits>
1078  bool perl_matcher<BidiIterator, Allocator, traits>::unwind_case(bool)
1079  {
1080     saved_change_case* pmp = static_cast<saved_change_case*>(m_backup_state);
1081     icase = pmp->icase;
1082     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(pmp++);
1083     m_backup_state = pmp;
1084     return true;
1085  }
1086  template <class BidiIterator, class Allocator, class traits>
1087  bool perl_matcher<BidiIterator, Allocator, traits>::unwind_paren(bool have_match)
1088  {
1089     saved_matched_paren<BidiIterator>* pmp = static_cast<saved_matched_paren<BidiIterator>*>(m_backup_state);
1090     if(!have_match)
1091     {
1092        m_presult->set_first(pmp->sub.first, pmp->index, pmp->index == 0);
1093        m_presult->set_second(pmp->sub.second, pmp->index, pmp->sub.matched, pmp->index == 0);
1094     }
1095  #ifdef BOOST_REGEX_MATCH_EXTRA
1096     else if(pmp->sub.matched && (match_extra & m_match_flags))
1097        ((*m_presult)[pmp->index]).get_captures().push_back(pmp->sub);
1098  #endif
1099     m_backup_state = pmp+1;
1100     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(pmp);
1101     return true; 
1102  }
1103  template <class BidiIterator, class Allocator, class traits>
1104  bool perl_matcher<BidiIterator, Allocator, traits>::unwind_recursion_stopper(bool)
1105  {
1106     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(m_backup_state++);
1107     pstate = 0;   
1108     return false; 
1109  }
1110  template <class BidiIterator, class Allocator, class traits>
1111  bool perl_matcher<BidiIterator, Allocator, traits>::unwind_assertion(bool r)
1112  {
1113     saved_assertion<BidiIterator>* pmp = static_cast<saved_assertion<BidiIterator>*>(m_backup_state);
1114     pstate = pmp->pstate;
1115     position = pmp->position;
1116     bool result = (r == pmp->positive);
1117     m_recursive_result = pmp->positive ? r : !r;
1118     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(pmp++);
1119     m_backup_state = pmp;
1120     m_unwound_lookahead = true;
1121     return !result; 
1122  }
1123  template <class BidiIterator, class Allocator, class traits>
1124  bool perl_matcher<BidiIterator, Allocator, traits>::unwind_alt(bool r)
1125  {
1126     saved_position<BidiIterator>* pmp = static_cast<saved_position<BidiIterator>*>(m_backup_state);
1127     if(!r)
1128     {
1129        pstate = pmp->pstate;
1130        position = pmp->position;
1131     }
1132     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(pmp++);
1133     m_backup_state = pmp;
1134     m_unwound_alt = !r;
1135     return r; 
1136  }
1137  template <class BidiIterator, class Allocator, class traits>
1138  bool perl_matcher<BidiIterator, Allocator, traits>::unwind_repeater_counter(bool)
1139  {
1140     saved_repeater<BidiIterator>* pmp = static_cast<saved_repeater<BidiIterator>*>(m_backup_state);
1141     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(pmp++);
1142     m_backup_state = pmp;
1143     return true; 
1144  }
1145  template <class BidiIterator, class Allocator, class traits>
1146  bool perl_matcher<BidiIterator, Allocator, traits>::unwind_extra_block(bool)
1147  {
1148     ++used_block_count;
1149     saved_extra_block* pmp = static_cast<saved_extra_block*>(m_backup_state);
1150     void* condemmed = m_stack_base;
1151     m_stack_base = pmp->base;
1152     m_backup_state = pmp->end;
1153     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(pmp);
1154     put_mem_block(condemmed);
1155     return true; 
1156  }
1157  template <class BidiIterator, class Allocator, class traits>
1158  inline void perl_matcher<BidiIterator, Allocator, traits>::destroy_single_repeat()
1159  {
1160     saved_single_repeat<BidiIterator>* p = static_cast<saved_single_repeat<BidiIterator>*>(m_backup_state);
1161     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(p++);
1162     m_backup_state = p;
1163  }
1164  template <class BidiIterator, class Allocator, class traits>
1165  bool perl_matcher<BidiIterator, Allocator, traits>::unwind_greedy_single_repeat(bool r)
1166  {
1167     saved_single_repeat<BidiIterator>* pmp = static_cast<saved_single_repeat<BidiIterator>*>(m_backup_state);
1168     if(r) 
1169     {
1170        destroy_single_repeat();
1171        return true;
1172     }
1173     const re_repeat* rep = pmp->rep;
1174     std::size_t count = pmp->count;
1175     BOOST_REGEX_ASSERT(rep->next.p != 0);
1176     BOOST_REGEX_ASSERT(rep->alt.p != 0);
1177     count -= rep->min;
1178     if((m_match_flags & match_partial) && (position == last))
1179        m_has_partial_match = true;
1180     BOOST_REGEX_ASSERT(count);
1181     position = pmp->last_position;
1182     do
1183     {
1184        --position;
1185        --count;
1186        ++state_count;
1187     }while(count && !can_start(*position, rep->_map, mask_skip));
1188     if(count == 0)
1189     {
1190           destroy_single_repeat();
1191           if(!can_start(*position, rep->_map, mask_skip))
1192              return true;
1193     }
1194     else
1195     {
1196        pmp->count = count + rep->min;
1197        pmp->last_position = position;
1198     }
1199     pstate = rep->alt.p;
1200     return false;
1201  }
1202  template <class BidiIterator, class Allocator, class traits>
1203  bool perl_matcher<BidiIterator, Allocator, traits>::unwind_slow_dot_repeat(bool r)
1204  {
1205     saved_single_repeat<BidiIterator>* pmp = static_cast<saved_single_repeat<BidiIterator>*>(m_backup_state);
1206     if(r) 
1207     {
1208        destroy_single_repeat();
1209        return true;
1210     }
1211     const re_repeat* rep = pmp->rep;
1212     std::size_t count = pmp->count;
1213     BOOST_REGEX_ASSERT(rep->type == syntax_element_dot_rep);
1214     BOOST_REGEX_ASSERT(rep->next.p != 0);
1215     BOOST_REGEX_ASSERT(rep->alt.p != 0);
1216     BOOST_REGEX_ASSERT(rep->next.p->type == syntax_element_wild);
1217     BOOST_REGEX_ASSERT(count < rep->max);
1218     pstate = rep->next.p;
1219     position = pmp->last_position;
1220     if(position != last)
1221     {
1222        do
1223        {
1224           if(!match_wild())
1225           {
1226              destroy_single_repeat();
1227              return true;
1228           }
1229           ++count;
1230           ++state_count;
1231           pstate = rep->next.p;
1232        }while((count < rep->max) && (position != last) && !can_start(*position, rep->_map, mask_skip));
1233     }   
1234     if(position == last)
1235     {
1236        destroy_single_repeat();
1237        if((m_match_flags & match_partial) && (position == last) && (position != search_base))
1238           m_has_partial_match = true;
1239        if(0 == (rep->can_be_null & mask_skip))
1240           return true;
1241     }
1242     else if(count == rep->max)
1243     {
1244        destroy_single_repeat();
1245        if(!can_start(*position, rep->_map, mask_skip))
1246           return true;
1247     }
1248     else
1249     {
1250        pmp->count = count;
1251        pmp->last_position = position;
1252     }
1253     pstate = rep->alt.p;
1254     return false;
1255  }
1256  template <class BidiIterator, class Allocator, class traits>
1257  bool perl_matcher<BidiIterator, Allocator, traits>::unwind_fast_dot_repeat(bool r)
1258  {
1259     saved_single_repeat<BidiIterator>* pmp = static_cast<saved_single_repeat<BidiIterator>*>(m_backup_state);
1260     if(r) 
1261     {
1262        destroy_single_repeat();
1263        return true;
1264     }
1265     const re_repeat* rep = pmp->rep;
1266     std::size_t count = pmp->count;
1267     BOOST_REGEX_ASSERT(count < rep->max);
1268     position = pmp->last_position;
1269     if(position != last)
1270     {
1271        do
1272        {
1273           ++position;
1274           ++count;
1275           ++state_count;
1276        }while((count < rep->max) && (position != last) && !can_start(*position, rep->_map, mask_skip));
1277     }
1278     if((rep->leading) && (count < rep->max))
1279        restart = position;
1280     if(position == last)
1281     {
1282        destroy_single_repeat();
1283        if((m_match_flags & match_partial) && (position == last) && (position != search_base))
1284           m_has_partial_match = true;
1285        if(0 == (rep->can_be_null & mask_skip))
1286           return true;
1287     }
1288     else if(count == rep->max)
1289     {
1290        destroy_single_repeat();
1291        if(!can_start(*position, rep->_map, mask_skip))
1292           return true;
1293     }
1294     else
1295     {
1296        pmp->count = count;
1297        pmp->last_position = position;
1298     }
1299     pstate = rep->alt.p;
1300     return false;
1301  }
1302  template <class BidiIterator, class Allocator, class traits>
1303  bool perl_matcher<BidiIterator, Allocator, traits>::unwind_char_repeat(bool r)
1304  {
1305     saved_single_repeat<BidiIterator>* pmp = static_cast<saved_single_repeat<BidiIterator>*>(m_backup_state);
1306     if(r) 
1307     {
1308        destroy_single_repeat();
1309        return true;
1310     }
1311     const re_repeat* rep = pmp->rep;
1312     std::size_t count = pmp->count;
1313     pstate = rep->next.p;
1314     const char_type what = *reinterpret_cast<const char_type*>(static_cast<const re_literal*>(pstate) + 1);
1315     position = pmp->last_position;
1316     BOOST_REGEX_ASSERT(rep->type == syntax_element_char_rep);
1317     BOOST_REGEX_ASSERT(rep->next.p != 0);
1318     BOOST_REGEX_ASSERT(rep->alt.p != 0);
1319     BOOST_REGEX_ASSERT(rep->next.p->type == syntax_element_literal);
1320     BOOST_REGEX_ASSERT(count < rep->max);
1321     if(position != last)
1322     {
1323        do
1324        {
1325           if(traits_inst.translate(*position, icase) != what)
1326           {
1327              destroy_single_repeat();
1328              return true;
1329           }
1330           ++count;
1331           ++ position;
1332           ++state_count;
1333           pstate = rep->next.p;
1334        }while((count < rep->max) && (position != last) && !can_start(*position, rep->_map, mask_skip));
1335     }   
1336     if((rep->leading) && (count < rep->max))
1337        restart = position;
1338     if(position == last)
1339     {
1340        destroy_single_repeat();
1341        if((m_match_flags & match_partial) && (position == last) && (position != search_base))
1342           m_has_partial_match = true;
1343        if(0 == (rep->can_be_null & mask_skip))
1344           return true;
1345     }
1346     else if(count == rep->max)
1347     {
1348        destroy_single_repeat();
1349        if(!can_start(*position, rep->_map, mask_skip))
1350           return true;
1351     }
1352     else
1353     {
1354        pmp->count = count;
1355        pmp->last_position = position;
1356     }
1357     pstate = rep->alt.p;
1358     return false;
1359  }
1360  template <class BidiIterator, class Allocator, class traits>
1361  bool perl_matcher<BidiIterator, Allocator, traits>::unwind_short_set_repeat(bool r)
1362  {
1363     saved_single_repeat<BidiIterator>* pmp = static_cast<saved_single_repeat<BidiIterator>*>(m_backup_state);
1364     if(r) 
1365     {
1366        destroy_single_repeat();
1367        return true;
1368     }
1369     const re_repeat* rep = pmp->rep;
1370     std::size_t count = pmp->count;
1371     pstate = rep->next.p;
1372     const unsigned char* map = static_cast<const re_set*>(rep->next.p)->_map;
1373     position = pmp->last_position;
1374     BOOST_REGEX_ASSERT(rep->type == syntax_element_short_set_rep);
1375     BOOST_REGEX_ASSERT(rep->next.p != 0);
1376     BOOST_REGEX_ASSERT(rep->alt.p != 0);
1377     BOOST_REGEX_ASSERT(rep->next.p->type == syntax_element_set);
1378     BOOST_REGEX_ASSERT(count < rep->max);
1379     if(position != last)
1380     {
1381        do
1382        {
1383           if(!map[static_cast<unsigned char>(traits_inst.translate(*position, icase))])
1384           {
1385              destroy_single_repeat();
1386              return true;
1387           }
1388           ++count;
1389           ++ position;
1390           ++state_count;
1391           pstate = rep->next.p;
1392        }while((count < rep->max) && (position != last) && !can_start(*position, rep->_map, mask_skip));
1393     }   
1394     if((rep->leading) && (count < rep->max))
1395        restart = position;
1396     if(position == last)
1397     {
1398        destroy_single_repeat();
1399        if((m_match_flags & match_partial) && (position == last) && (position != search_base))
1400           m_has_partial_match = true;
1401        if(0 == (rep->can_be_null & mask_skip))
1402           return true;
1403     }
1404     else if(count == rep->max)
1405     {
1406        destroy_single_repeat();
1407        if(!can_start(*position, rep->_map, mask_skip))
1408           return true;
1409     }
1410     else
1411     {
1412        pmp->count = count;
1413        pmp->last_position = position;
1414     }
1415     pstate = rep->alt.p;
1416     return false;
1417  }
1418  template <class BidiIterator, class Allocator, class traits>
1419  bool perl_matcher<BidiIterator, Allocator, traits>::unwind_long_set_repeat(bool r)
1420  {
1421     typedef typename traits::char_class_type m_type;
1422     saved_single_repeat<BidiIterator>* pmp = static_cast<saved_single_repeat<BidiIterator>*>(m_backup_state);
1423     if(r)
1424     {
1425        destroy_single_repeat();
1426        return true;
1427     }
1428     const re_repeat* rep = pmp->rep;
1429     std::size_t count = pmp->count;
1430     pstate = rep->next.p;
1431     const re_set_long<m_type>* set = static_cast<const re_set_long<m_type>*>(pstate);
1432     position = pmp->last_position;
1433     BOOST_REGEX_ASSERT(rep->type == syntax_element_long_set_rep);
1434     BOOST_REGEX_ASSERT(rep->next.p != 0);
1435     BOOST_REGEX_ASSERT(rep->alt.p != 0);
1436     BOOST_REGEX_ASSERT(rep->next.p->type == syntax_element_long_set);
1437     BOOST_REGEX_ASSERT(count < rep->max);
1438     if(position != last)
1439     {
1440        do
1441        {
1442           if(position == re_is_set_member(position, last, set, re.get_data(), icase))
1443           {
1444              destroy_single_repeat();
1445              return true;
1446           }
1447           ++position;
1448           ++count;
1449           ++state_count;
1450           pstate = rep->next.p;
1451        }while((count < rep->max) && (position != last) && !can_start(*position, rep->_map, mask_skip));
1452     }   
1453     if((rep->leading) && (count < rep->max))
1454        restart = position;
1455     if(position == last)
1456     {
1457        destroy_single_repeat();
1458        if((m_match_flags & match_partial) && (position == last) && (position != search_base))
1459           m_has_partial_match = true;
1460        if(0 == (rep->can_be_null & mask_skip))
1461           return true;
1462     }
1463     else if(count == rep->max)
1464     {
1465        destroy_single_repeat();
1466        if(!can_start(*position, rep->_map, mask_skip))
1467           return true;
1468     }
1469     else
1470     {
1471        pmp->count = count;
1472        pmp->last_position = position;
1473     }
1474     pstate = rep->alt.p;
1475     return false;
1476  }
1477  template <class BidiIterator, class Allocator, class traits>
1478  bool perl_matcher<BidiIterator, Allocator, traits>::unwind_non_greedy_repeat(bool r)
1479  {
1480     saved_position<BidiIterator>* pmp = static_cast<saved_position<BidiIterator>*>(m_backup_state);
1481     if(!r)
1482     {
1483        position = pmp->position;
1484        pstate = pmp->pstate;
1485        ++(*next_count);
1486     }
1487     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(pmp++);
1488     m_backup_state = pmp;
1489     return r;
1490  }
1491  template <class BidiIterator, class Allocator, class traits>
1492  bool perl_matcher<BidiIterator, Allocator, traits>::unwind_recursion(bool r)
1493  {
1494     saved_recursion<results_type>* pmp = static_cast<saved_recursion<results_type>*>(m_backup_state);
1495     if (!r)
1496     {
1497        recursion_stack.push_back(recursion_info<results_type>());
1498        recursion_stack.back().idx = pmp->recursion_id;
1499        recursion_stack.back().preturn_address = pmp->preturn_address;
1500        recursion_stack.back().results = pmp->prior_results;
1501        recursion_stack.back().location_of_start = position;
1502        *m_presult = pmp->internal_results;
1503     }
1504     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(pmp++);
1505     m_backup_state = pmp;
1506     return true;
1507  }
1508  template <class BidiIterator, class Allocator, class traits>
1509  bool perl_matcher<BidiIterator, Allocator, traits>::unwind_recursion_pop(bool r)
1510  {
1511     saved_state* pmp = static_cast<saved_state*>(m_backup_state);
1512     if (!r && !recursion_stack.empty())
1513     {
1514        *m_presult = recursion_stack.back().results;
1515        position = recursion_stack.back().location_of_start;
1516        recursion_stack.pop_back();
1517     }
1518     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(pmp++);
1519     m_backup_state = pmp;
1520     return true;
1521  }
1522  template <class BidiIterator, class Allocator, class traits>
1523  void perl_matcher<BidiIterator, Allocator, traits>::push_recursion_pop()
1524  {
1525     saved_state* pmp = static_cast<saved_state*>(m_backup_state);
1526     --pmp;
1527     if(pmp < m_stack_base)
1528     {
1529        extend_stack();
1530        pmp = static_cast<saved_state*>(m_backup_state);
1531        --pmp;
1532     }
1533     (void) new (pmp)saved_state(15);
1534     m_backup_state = pmp;
1535  }
1536  template <class BidiIterator, class Allocator, class traits>
1537  bool perl_matcher<BidiIterator, Allocator, traits>::unwind_commit(bool b)
1538  {
1539     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(m_backup_state++);
1540     while(unwind(b) && !m_unwound_lookahead){}
1541     if(m_unwound_lookahead && pstate)
1542     {
1543        m_unwound_lookahead = false;
1544        saved_state* pmp = m_backup_state;
1545        --pmp;
1546        if(pmp < m_stack_base)
1547        {
1548           extend_stack();
1549           pmp = m_backup_state;
1550           --pmp;
1551        }
1552        (void) new (pmp)saved_state(16);
1553        m_backup_state = pmp;
1554     }
1555     m_independent = false;
1556     return false;
1557  }
1558  template <class BidiIterator, class Allocator, class traits>
1559  bool perl_matcher<BidiIterator, Allocator, traits>::unwind_then(bool b)
1560  {
1561     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(m_backup_state++);
1562     bool result = false;
1563     result = unwind(b);
1564     while(result && !m_unwound_alt)
1565     {
1566        result = unwind(b);
1567     }
1568     if(result && m_unwound_alt)
1569        unwind(b);
1570     return false;
1571  }
1572  } 
1573  } 
1574  #ifdef BOOST_REGEX_MSVC
1575  #  pragma warning(pop)
1576  #endif
1577  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-perl_matcher_non_recursive.hpp</h3>
            <pre><code>1  #ifndef BOOST_REGEX_V5_PERL_MATCHER_NON_RECURSIVE_HPP
2  #define BOOST_REGEX_V5_PERL_MATCHER_NON_RECURSIVE_HPP
3  #include <boost/regex/v5/mem_block_cache.hpp>
4  #ifdef BOOST_REGEX_MSVC
5  #  pragma warning(push)
6  #  pragma warning(disable: 4706 4459)
7  #if BOOST_REGEX_MSVC < 1910
8  #pragma warning(disable:4800)
9  #endif
10  #endif
11  namespace boost{
12  namespace BOOST_REGEX_DETAIL_NS{
13  template <class T>
14  inline void inplace_destroy(T* p)
15  {
16     (void)p;  
17     p->~T();
18  }
19  struct saved_state
20  {
21     union{
22        unsigned int state_id;
23        std::size_t padding1;
24        std::ptrdiff_t padding2;
25        void* padding3;
26     };
27     saved_state(unsigned i) : state_id(i) {}
28  };
29  template <class BidiIterator>
30  struct saved_matched_paren : public saved_state
31  {
32     int index;
33     sub_match<BidiIterator> sub;
34     saved_matched_paren(int i, const sub_match<BidiIterator>& s) : saved_state(1), index(i), sub(s){}
35  };
36  template <class BidiIterator>
37  struct saved_position : public saved_state
38  {
39     const re_syntax_base* pstate;
40     BidiIterator position;
41     saved_position(const re_syntax_base* ps, BidiIterator pos, int i) : saved_state(i), pstate(ps), position(pos){}
42  };
43  template <class BidiIterator>
44  struct saved_assertion : public saved_position<BidiIterator>
45  {
46     bool positive;
47     saved_assertion(bool p, const re_syntax_base* ps, BidiIterator pos) 
48        : saved_position<BidiIterator>(ps, pos, saved_type_assertion), positive(p){}
49  };
50  template <class BidiIterator>
51  struct saved_repeater : public saved_state
52  {
53     repeater_count<BidiIterator> count;
54     saved_repeater(int i, repeater_count<BidiIterator>** s, BidiIterator start, int current_recursion_id)
55        : saved_state(saved_state_repeater_count), count(i, s, start, current_recursion_id){}
56  };
57  struct saved_extra_block : public saved_state
58  {
59     saved_state *base, *end;
60     saved_extra_block(saved_state* b, saved_state* e) 
61        : saved_state(saved_state_extra_block), base(b), end(e) {}
62  };
63  struct save_state_init
64  {
65     saved_state** stack;
66     save_state_init(saved_state** base, saved_state** end)
67        : stack(base)
68     {
69        *base = static_cast<saved_state*>(get_mem_block());
70        *end = reinterpret_cast<saved_state*>(reinterpret_cast<char*>(*base)+BOOST_REGEX_BLOCKSIZE);
71        --(*end);
72        (void) new (*end)saved_state(0);
73        BOOST_REGEX_ASSERT(*end > *base);
74     }
75     ~save_state_init()
76     {
77        put_mem_block(*stack);
78        *stack = 0;
79     }
80  };
81  template <class BidiIterator>
82  struct saved_single_repeat : public saved_state
83  {
84     std::size_t count;
85     const re_repeat* rep;
86     BidiIterator last_position;
87     saved_single_repeat(std::size_t c, const re_repeat* r, BidiIterator lp, int arg_id) 
88        : saved_state(arg_id), count(c), rep(r), last_position(lp){}
89  };
90  template <class Results>
91  struct saved_recursion : public saved_state
92  {
93     saved_recursion(int idx, const re_syntax_base* p, Results* pr, Results* pr2) 
94        : saved_state(14), recursion_id(idx), preturn_address(p), internal_results(*pr), prior_results(*pr2) {}
95     int recursion_id;
96     const re_syntax_base* preturn_address;
97     Results internal_results, prior_results;
98  };
99  struct saved_change_case : public saved_state
100  {
101     bool icase;
102     saved_change_case(bool c) : saved_state(18), icase(c) {}
103  };
104  struct incrementer
105  {
106     incrementer(unsigned* pu) : m_pu(pu) { ++*m_pu; }
107     ~incrementer() { --*m_pu; }
108     bool operator > (unsigned i) { return *m_pu > i; }
109  private:
110     unsigned* m_pu;
111  };
112  template <class BidiIterator, class Allocator, class traits>
113  bool perl_matcher<BidiIterator, Allocator, traits>::match_all_states()
114  {
115     static matcher_proc_type const s_match_vtable[34] = 
116     {
117        (&perl_matcher<BidiIterator, Allocator, traits>::match_startmark),
118        &perl_matcher<BidiIterator, Allocator, traits>::match_endmark,
119        &perl_matcher<BidiIterator, Allocator, traits>::match_literal,
120        &perl_matcher<BidiIterator, Allocator, traits>::match_start_line,
121        &perl_matcher<BidiIterator, Allocator, traits>::match_end_line,
122        &perl_matcher<BidiIterator, Allocator, traits>::match_wild,
123        &perl_matcher<BidiIterator, Allocator, traits>::match_match,
124        &perl_matcher<BidiIterator, Allocator, traits>::match_word_boundary,
125        &perl_matcher<BidiIterator, Allocator, traits>::match_within_word,
126        &perl_matcher<BidiIterator, Allocator, traits>::match_word_start,
127        &perl_matcher<BidiIterator, Allocator, traits>::match_word_end,
128        &perl_matcher<BidiIterator, Allocator, traits>::match_buffer_start,
129        &perl_matcher<BidiIterator, Allocator, traits>::match_buffer_end,
130        &perl_matcher<BidiIterator, Allocator, traits>::match_backref,
131        &perl_matcher<BidiIterator, Allocator, traits>::match_long_set,
132        &perl_matcher<BidiIterator, Allocator, traits>::match_set,
133        &perl_matcher<BidiIterator, Allocator, traits>::match_jump,
134        &perl_matcher<BidiIterator, Allocator, traits>::match_alt,
135        &perl_matcher<BidiIterator, Allocator, traits>::match_rep,
136        &perl_matcher<BidiIterator, Allocator, traits>::match_combining,
137        &perl_matcher<BidiIterator, Allocator, traits>::match_soft_buffer_end,
138        &perl_matcher<BidiIterator, Allocator, traits>::match_restart_continue,
139        &perl_matcher<BidiIterator, Allocator, traits>::match_dot_repeat_dispatch,
140        &perl_matcher<BidiIterator, Allocator, traits>::match_char_repeat,
141        &perl_matcher<BidiIterator, Allocator, traits>::match_set_repeat,
142        &perl_matcher<BidiIterator, Allocator, traits>::match_long_set_repeat,
143        &perl_matcher<BidiIterator, Allocator, traits>::match_backstep,
144        &perl_matcher<BidiIterator, Allocator, traits>::match_assert_backref,
145        &perl_matcher<BidiIterator, Allocator, traits>::match_toggle_case,
146        &perl_matcher<BidiIterator, Allocator, traits>::match_recursion,
147        &perl_matcher<BidiIterator, Allocator, traits>::match_fail,
148        &perl_matcher<BidiIterator, Allocator, traits>::match_accept,
149        &perl_matcher<BidiIterator, Allocator, traits>::match_commit,
150        &perl_matcher<BidiIterator, Allocator, traits>::match_then,
151     };
152     incrementer inc(&m_recursions);
153     if(inc > 80)
154        raise_error(traits_inst, regex_constants::error_complexity);
155     push_recursion_stopper();
156     do{
157        while(pstate)
158        {
159           matcher_proc_type proc = s_match_vtable[pstate->type];
160           ++state_count;
161           if(!(this->*proc)())
162           {
163              if(state_count > max_state_count)
164                 raise_error(traits_inst, regex_constants::error_complexity);
165              if((m_match_flags & match_partial) && (position == last) && (position != search_base))
166                 m_has_partial_match = true;
167              bool successful_unwind = unwind(false);
168              if((m_match_flags & match_partial) && (position == last) && (position != search_base))
169                 m_has_partial_match = true;
170              if(!successful_unwind)
171                 return m_recursive_result;
172           }
173        }
174     }while(unwind(true));
175     return m_recursive_result;
176  }
177  template <class BidiIterator, class Allocator, class traits>
178  void perl_matcher<BidiIterator, Allocator, traits>::extend_stack()
179  {
180     if(used_block_count)
181     {
182        --used_block_count;
183        saved_state* stack_base;
184        saved_state* backup_state;
185        stack_base = static_cast<saved_state*>(get_mem_block());
186        backup_state = reinterpret_cast<saved_state*>(reinterpret_cast<char*>(stack_base)+BOOST_REGEX_BLOCKSIZE);
187        saved_extra_block* block = static_cast<saved_extra_block*>(backup_state);
188        --block;
189        (void) new (block) saved_extra_block(m_stack_base, m_backup_state);
190        m_stack_base = stack_base;
191        m_backup_state = block;
192     }
193     else
194        raise_error(traits_inst, regex_constants::error_stack);
195  }
196  template <class BidiIterator, class Allocator, class traits>
197  inline void perl_matcher<BidiIterator, Allocator, traits>::push_matched_paren(int index, const sub_match<BidiIterator>& sub)
198  {
199     saved_matched_paren<BidiIterator>* pmp = static_cast<saved_matched_paren<BidiIterator>*>(m_backup_state);
200     --pmp;
201     if(pmp < m_stack_base)
202     {
203        extend_stack();
204        pmp = static_cast<saved_matched_paren<BidiIterator>*>(m_backup_state);
205        --pmp;
206     }
207     (void) new (pmp)saved_matched_paren<BidiIterator>(index, sub);
208     m_backup_state = pmp;
209  }
210  template <class BidiIterator, class Allocator, class traits>
211  inline void perl_matcher<BidiIterator, Allocator, traits>::push_case_change(bool c)
212  {
213     saved_change_case* pmp = static_cast<saved_change_case*>(m_backup_state);
214     --pmp;
215     if(pmp < m_stack_base)
216     {
217        extend_stack();
218        pmp = static_cast<saved_change_case*>(m_backup_state);
219        --pmp;
220     }
221     (void) new (pmp)saved_change_case(c);
222     m_backup_state = pmp;
223  }
224  template <class BidiIterator, class Allocator, class traits>
225  inline void perl_matcher<BidiIterator, Allocator, traits>::push_recursion_stopper()
226  {
227     saved_state* pmp = m_backup_state;
228     --pmp;
229     if(pmp < m_stack_base)
230     {
231        extend_stack();
232        pmp = m_backup_state;
233        --pmp;
234     }
235     (void) new (pmp)saved_state(saved_type_recurse);
236     m_backup_state = pmp;
237  }
238  template <class BidiIterator, class Allocator, class traits>
239  inline void perl_matcher<BidiIterator, Allocator, traits>::push_assertion(const re_syntax_base* ps, bool positive)
240  {
241     saved_assertion<BidiIterator>* pmp = static_cast<saved_assertion<BidiIterator>*>(m_backup_state);
242     --pmp;
243     if(pmp < m_stack_base)
244     {
245        extend_stack();
246        pmp = static_cast<saved_assertion<BidiIterator>*>(m_backup_state);
247        --pmp;
248     }
249     (void) new (pmp)saved_assertion<BidiIterator>(positive, ps, position);
250     m_backup_state = pmp;
251  }
252  template <class BidiIterator, class Allocator, class traits>
253  inline void perl_matcher<BidiIterator, Allocator, traits>::push_alt(const re_syntax_base* ps)
254  {
255     saved_position<BidiIterator>* pmp = static_cast<saved_position<BidiIterator>*>(m_backup_state);
256     --pmp;
257     if(pmp < m_stack_base)
258     {
259        extend_stack();
260        pmp = static_cast<saved_position<BidiIterator>*>(m_backup_state);
261        --pmp;
262     }
263     (void) new (pmp)saved_position<BidiIterator>(ps, position, saved_state_alt);
264     m_backup_state = pmp;
265  }
266  template <class BidiIterator, class Allocator, class traits>
267  inline void perl_matcher<BidiIterator, Allocator, traits>::push_non_greedy_repeat(const re_syntax_base* ps)
268  {
269     saved_position<BidiIterator>* pmp = static_cast<saved_position<BidiIterator>*>(m_backup_state);
270     --pmp;
271     if(pmp < m_stack_base)
272     {
273        extend_stack();
274        pmp = static_cast<saved_position<BidiIterator>*>(m_backup_state);
275        --pmp;
276     }
277     (void) new (pmp)saved_position<BidiIterator>(ps, position, saved_state_non_greedy_long_repeat);
278     m_backup_state = pmp;
279  }
280  template <class BidiIterator, class Allocator, class traits>
281  inline void perl_matcher<BidiIterator, Allocator, traits>::push_repeater_count(int i, repeater_count<BidiIterator>** s)
282  {
283     saved_repeater<BidiIterator>* pmp = static_cast<saved_repeater<BidiIterator>*>(m_backup_state);
284     --pmp;
285     if(pmp < m_stack_base)
286     {
287        extend_stack();
288        pmp = static_cast<saved_repeater<BidiIterator>*>(m_backup_state);
289        --pmp;
290     }
291     (void) new (pmp)saved_repeater<BidiIterator>(i, s, position, this->recursion_stack.empty() ? (INT_MIN + 3) : this->recursion_stack.back().idx);
292     m_backup_state = pmp;
293  }
294  template <class BidiIterator, class Allocator, class traits>
295  inline void perl_matcher<BidiIterator, Allocator, traits>::push_single_repeat(std::size_t c, const re_repeat* r, BidiIterator last_position, int state_id)
296  {
297     saved_single_repeat<BidiIterator>* pmp = static_cast<saved_single_repeat<BidiIterator>*>(m_backup_state);
298     --pmp;
299     if(pmp < m_stack_base)
300     {
301        extend_stack();
302        pmp = static_cast<saved_single_repeat<BidiIterator>*>(m_backup_state);
303        --pmp;
304     }
305     (void) new (pmp)saved_single_repeat<BidiIterator>(c, r, last_position, state_id);
306     m_backup_state = pmp;
307  }
308  template <class BidiIterator, class Allocator, class traits>
309  inline void perl_matcher<BidiIterator, Allocator, traits>::push_recursion(int idx, const re_syntax_base* p, results_type* presults, results_type* presults2)
310  {
311     saved_recursion<results_type>* pmp = static_cast<saved_recursion<results_type>*>(m_backup_state);
312     --pmp;
313     if(pmp < m_stack_base)
314     {
315        extend_stack();
316        pmp = static_cast<saved_recursion<results_type>*>(m_backup_state);
317        --pmp;
318     }
319     (void) new (pmp)saved_recursion<results_type>(idx, p, presults, presults2);
320     m_backup_state = pmp;
321  }
322  template <class BidiIterator, class Allocator, class traits>
323  bool perl_matcher<BidiIterator, Allocator, traits>::match_toggle_case()
324  {
325     push_case_change(this->icase);
326     this->icase = static_cast<const re_case*>(pstate)->icase;
327     pstate = pstate->next.p;
328     return true;
329  }
330  template <class BidiIterator, class Allocator, class traits>
331  bool perl_matcher<BidiIterator, Allocator, traits>::match_startmark()
332  {
333     int index = static_cast<const re_brace*>(pstate)->index;
334     icase = static_cast<const re_brace*>(pstate)->icase;
335     switch(index)
336     {
337     case 0:
338        pstate = pstate->next.p;
339        break;
340     case -1:
341     case -2:
342        {
343           const re_syntax_base* next_pstate = static_cast<const re_jump*>(pstate->next.p)->alt.p->next.p;
344           pstate = pstate->next.p->next.p;
345           push_assertion(next_pstate, index == -1);
346           break;
347        }
348     case -3:
349        {
350           bool old_independent = m_independent;
351           m_independent = true;
352           const re_syntax_base* next_pstate = static_cast<const re_jump*>(pstate->next.p)->alt.p->next.p;
353           pstate = pstate->next.p->next.p;
354           bool r = false;
355  #if !defined(BOOST_NO_EXCEPTIONS)
356        try{
357  #endif
358           r = match_all_states();
359           if(!r && !m_independent)
360           {
361              while (m_backup_state->state_id)
362                 unwind(false);
363              return false;
364           }
365  #if !defined(BOOST_NO_EXCEPTIONS)
366        }
367        catch(...)
368        {
369           pstate = next_pstate;
370           while(unwind(true)) {}
371           throw;
372        }
373  #endif
374        pstate = next_pstate;
375        m_independent = old_independent;
376  #ifdef BOOST_REGEX_MATCH_EXTRA
377           if(r && (m_match_flags & match_extra))
378           {
379              match_results<BidiIterator, Allocator> temp_match(*m_presult);
380              unsigned i;
381              for(i = 0; i < temp_match.size(); ++i)
382                 (*m_presult)[i].get_captures().clear();
383  #if !defined(BOOST_NO_EXCEPTIONS)
384              try{
385  #endif
386                 r = match_all_states();
387  #if !defined(BOOST_NO_EXCEPTIONS)
388              }
389              catch(...)
390              {
391                 pstate = next_pstate;
392                 while(unwind(true)) {}
393                 throw;
394              }
395  #endif
396              for(i = 0; i < temp_match.size(); ++i)
397              {
398                 typedef typename sub_match<BidiIterator>::capture_sequence_type seq;
399                 seq& s1 = (*m_presult)[i].get_captures();
400                 const seq& s2 = temp_match[i].captures();
401                 s1.insert(
402                    s1.end(), 
403                    s2.begin(), 
404                    s2.end());
405              }
406           }
407  #endif
408           return r;
409        }
410     case -4:
411        {
412        const re_alt* alt = static_cast<const re_alt*>(pstate->next.p);
413        BOOST_REGEX_ASSERT(alt->type == syntax_element_alt);
414        pstate = alt->next.p;
415        if(pstate->type == syntax_element_assert_backref)
416        {
417           if(!match_assert_backref())
418              pstate = alt->alt.p;
419           break;
420        }
421        else
422        {
423           BOOST_REGEX_ASSERT(pstate->type == syntax_element_startmark);
424           bool negated = static_cast<const re_brace*>(pstate)->index == -2;
425           BidiIterator saved_position = position;
426           const re_syntax_base* next_pstate = static_cast<const re_jump*>(pstate->next.p)->alt.p->next.p;
427           pstate = pstate->next.p->next.p;
428  #if !defined(BOOST_NO_EXCEPTIONS)
429           try{
430  #endif
431              bool r = match_all_states();
432              position = saved_position;
433              if(negated)
434                 r = !r;
435              if(r)
436                 pstate = next_pstate;
437              else
438                 pstate = alt->alt.p;
439  #if !defined(BOOST_NO_EXCEPTIONS)
440           }
441           catch(...)
442           {
443              pstate = next_pstate;
444              while(unwind(true)){}
445              throw;
446           }
447  #endif
448           break;
449        }
450        }
451     case -5:
452        {
453           push_matched_paren(0, (*m_presult)[0]);
454           m_presult->set_first(position, 0, true);
455           pstate = pstate->next.p;
456           break;
457        }
458     default:
459     {
460        BOOST_REGEX_ASSERT(index > 0);
461        if((m_match_flags & match_nosubs) == 0)
462        {
463           push_matched_paren(index, (*m_presult)[index]);
464           m_presult->set_first(position, index);
465        }
466        pstate = pstate->next.p;
467        break;
468     }
469     }
470     return true;
471  }
472  template <class BidiIterator, class Allocator, class traits>
473  bool perl_matcher<BidiIterator, Allocator, traits>::match_alt()
474  {
475     bool take_first, take_second;
476     const re_alt* jmp = static_cast<const re_alt*>(pstate);
477     if(position == last)
478     {
479        take_first = jmp->can_be_null & mask_take;
480        take_second = jmp->can_be_null & mask_skip;
481     }
482     else
483     {
484        take_first = can_start(*position, jmp->_map, (unsigned char)mask_take);
485        take_second = can_start(*position, jmp->_map, (unsigned char)mask_skip);
486    }
487     if(take_first)
488     {
489        if(take_second)
490        {
491           push_alt(jmp->alt.p);
492        }
493        pstate = pstate->next.p;
494        return true;
495     }
496     if(take_second)
497     {
498        pstate = jmp->alt.p;
499        return true;
500     }
501     return false;  
502  }
503  template <class BidiIterator, class Allocator, class traits>
504  bool perl_matcher<BidiIterator, Allocator, traits>::match_rep()
505  {
506  #ifdef BOOST_REGEX_MSVC
507  #pragma warning(push)
508  #pragma warning(disable:4127 4244)
509  #endif
510  #ifdef BOOST_BORLANDC
511  #pragma option push -w-8008 -w-8066 -w-8004
512  #endif
513     const re_repeat* rep = static_cast<const re_repeat*>(pstate);
514     bool take_first, take_second;
515     if(position == last)
516     {
517        take_first = rep->can_be_null & mask_take;
518        take_second = rep->can_be_null & mask_skip;
519     }
520     else
521     {
522        take_first = can_start(*position, rep->_map, (unsigned char)mask_take);
523        take_second = can_start(*position, rep->_map, (unsigned char)mask_skip);
524     }
525     if((m_backup_state->state_id != saved_state_repeater_count) 
526        || (static_cast<saved_repeater<BidiIterator>*>(m_backup_state)->count.get_id() != rep->state_id)
527        || (next_count->get_id() != rep->state_id))
528     {
529        push_repeater_count(rep->state_id, &next_count);
530     }
531     next_count->check_null_repeat(position, rep->max);
532     if(next_count->get_count() < rep->min)
533     {
534        if(take_first)
535        {
536           ++(*next_count);
537           pstate = rep->next.p;
538           return true;
539        }
540        return false;
541     }
542     bool greedy = (rep->greedy) && (!(m_match_flags & regex_constants::match_any) || m_independent);   
543     if(greedy)
544     {
<span onclick='openModal()' class='match'>545        if((next_count->get_count() < rep->max) && take_first)
546        {
547           if(take_second)
</span>548           {
549              push_alt(rep->alt.p);
550           }
551           ++(*next_count);
552           pstate = rep->next.p;
553           return true;
554        }
555        else if(take_second)
556        {
557           pstate = rep->alt.p;
558           return true;
559        }
560        return false; 
561     }
562     else 
563     {
564        if(take_second)
565        {
566           if((next_count->get_count() < rep->max) && take_first)
567           {
568              push_non_greedy_repeat(rep->next.p);
569           }
570           pstate = rep->alt.p;
571           return true;
572        }
573        if((next_count->get_count() < rep->max) && take_first)
574        {
575           ++(*next_count);
576           pstate = rep->next.p;
577           return true;
578        }
579     }
580     return false;
581  #ifdef BOOST_BORLANDC
582  #pragma option pop
583  #endif
584  #ifdef BOOST_REGEX_MSVC
585  #pragma warning(pop)
586  #endif
587  }
588  template <class BidiIterator, class Allocator, class traits>
589  bool perl_matcher<BidiIterator, Allocator, traits>::match_dot_repeat_slow()
590  {
591     std::size_t count = 0;
592     const re_repeat* rep = static_cast<const re_repeat*>(pstate);
593     re_syntax_base* psingle = rep->next.p;
594     while(count < rep->min)
595     {
596        pstate = psingle;
597        if(!match_wild())
598           return false;
599        ++count;
600     }
601     bool greedy = (rep->greedy) && (!(m_match_flags & regex_constants::match_any) || m_independent);   
602     if(greedy)
603     {
604        while(count < rep->max)
605        {
606           pstate = psingle;
607           if(!match_wild())
608              break;
609           ++count;
610        }
611        if((rep->leading) && (count < rep->max))
612           restart = position;
613        if(count - rep->min)
614           push_single_repeat(count, rep, position, saved_state_greedy_single_repeat);
615        pstate = rep->alt.p;
616        return true;
617     }
618     else
619     {
620        if(count < rep->max)
621           push_single_repeat(count, rep, position, saved_state_rep_slow_dot);
622        pstate = rep->alt.p;
623        return (position == last) ? (rep->can_be_null & mask_skip) : can_start(*position, rep->_map, mask_skip);
624     }
625  }
626  template <class BidiIterator, class Allocator, class traits>
627  bool perl_matcher<BidiIterator, Allocator, traits>::match_dot_repeat_fast()
628  {
629     if(m_match_flags & match_not_dot_null)
630        return match_dot_repeat_slow();
631     if((static_cast<const re_dot*>(pstate->next.p)->mask & match_any_mask) == 0)
632        return match_dot_repeat_slow();
633     const re_repeat* rep = static_cast<const re_repeat*>(pstate);
634     bool greedy = (rep->greedy) && (!(m_match_flags & regex_constants::match_any) || m_independent);   
635     std::size_t count = static_cast<std::size_t>((std::min)(static_cast<std::size_t>(std::distance(position, last)), greedy ? rep->max : rep->min));
636     if(rep->min > count)
637     {
638        position = last;
639        return false;  
640     }
641     std::advance(position, count);
642     if(greedy)
643     {
644        if((rep->leading) && (count < rep->max))
645           restart = position;
646        if(count - rep->min)
647           push_single_repeat(count, rep, position, saved_state_greedy_single_repeat);
648        pstate = rep->alt.p;
649        return true;
650     }
651     else
652     {
653        if(count < rep->max)
654           push_single_repeat(count, rep, position, saved_state_rep_fast_dot);
655        pstate = rep->alt.p;
656        return (position == last) ? (rep->can_be_null & mask_skip) : can_start(*position, rep->_map, mask_skip);
657     }
658  }
659  template <class BidiIterator, class Allocator, class traits>
660  bool perl_matcher<BidiIterator, Allocator, traits>::match_char_repeat()
661  {
662  #ifdef BOOST_REGEX_MSVC
663  #pragma warning(push)
664  #pragma warning(disable:4127)
665  #endif
666  #ifdef BOOST_BORLANDC
667  #pragma option push -w-8008 -w-8066 -w-8004
668  #endif
669     const re_repeat* rep = static_cast<const re_repeat*>(pstate);
670     BOOST_REGEX_ASSERT(1 == static_cast<const re_literal*>(rep->next.p)->length);
671     const char_type what = *reinterpret_cast<const char_type*>(static_cast<const re_literal*>(rep->next.p) + 1);
672     std::size_t count = 0;
673     bool greedy = (rep->greedy) && (!(m_match_flags & regex_constants::match_any) || m_independent);   
674     std::size_t desired = greedy ? rep->max : rep->min;
675     if(::boost::is_random_access_iterator<BidiIterator>::value)
676     {
677        BidiIterator end = position;
678        std::size_t len = (desired == (std::numeric_limits<std::size_t>::max)()) ? 0u : std::distance(position, last);
679        if(desired >= len)
680           end = last;
681        else
682           std::advance(end, desired);
683        BidiIterator origin(position);
684        while((position != end) && (traits_inst.translate(*position, icase) == what))
685        {
686           ++position;
687        }
688        count = (unsigned)std::distance(origin, position);
689     }
690     else
691     {
692        while((count < desired) && (position != last) && (traits_inst.translate(*position, icase) == what))
693        {
694           ++position;
695           ++count;
696        }
697     }
698     if(count < rep->min)
699        return false;
700     if(greedy)
701     {
702        if((rep->leading) && (count < rep->max))
703           restart = position;
704        if(count - rep->min)
705           push_single_repeat(count, rep, position, saved_state_greedy_single_repeat);
706        pstate = rep->alt.p;
707        return true;
708     }
709     else
710     {
711        if(count < rep->max)
712           push_single_repeat(count, rep, position, saved_state_rep_char);
713        pstate = rep->alt.p;
714        return (position == last) ? (rep->can_be_null & mask_skip) : can_start(*position, rep->_map, mask_skip);
715     }
716  #ifdef BOOST_BORLANDC
717  #pragma option pop
718  #endif
719  #ifdef BOOST_REGEX_MSVC
720  #pragma warning(pop)
721  #endif
722  }
723  template <class BidiIterator, class Allocator, class traits>
724  bool perl_matcher<BidiIterator, Allocator, traits>::match_set_repeat()
725  {
726  #ifdef BOOST_REGEX_MSVC
727  #pragma warning(push)
728  #pragma warning(disable:4127)
729  #endif
730  #ifdef BOOST_BORLANDC
731  #pragma option push -w-8008 -w-8066 -w-8004
732  #endif
733     const re_repeat* rep = static_cast<const re_repeat*>(pstate);
734     const unsigned char* map = static_cast<const re_set*>(rep->next.p)->_map;
735     std::size_t count = 0;
736     bool greedy = (rep->greedy) && (!(m_match_flags & regex_constants::match_any) || m_independent);   
737     std::size_t desired = greedy ? rep->max : rep->min;
738     if(::boost::is_random_access_iterator<BidiIterator>::value)
739     {
740        BidiIterator end = position;
741        std::size_t len = (desired == (std::numeric_limits<std::size_t>::max)()) ? 0u : std::distance(position, last);
742        if(desired >= len)
743           end = last;
744        else
745           std::advance(end, desired);
746        BidiIterator origin(position);
747        while((position != end) && map[static_cast<unsigned char>(traits_inst.translate(*position, icase))])
748        {
749           ++position;
750        }
751        count = (unsigned)std::distance(origin, position);
752     }
753     else
754     {
755        while((count < desired) && (position != last) && map[static_cast<unsigned char>(traits_inst.translate(*position, icase))])
756        {
757           ++position;
758           ++count;
759        }
760     }
761     if(count < rep->min)
762        return false;
763     if(greedy)
764     {
765        if((rep->leading) && (count < rep->max))
766           restart = position;
767        if(count - rep->min)
768           push_single_repeat(count, rep, position, saved_state_greedy_single_repeat);
769        pstate = rep->alt.p;
770        return true;
771     }
772     else
773     {
774        if(count < rep->max)
775           push_single_repeat(count, rep, position, saved_state_rep_short_set);
776        pstate = rep->alt.p;
777        return (position == last) ? (rep->can_be_null & mask_skip) : can_start(*position, rep->_map, mask_skip);
778     }
779  #ifdef BOOST_BORLANDC
780  #pragma option pop
781  #endif
782  #ifdef BOOST_REGEX_MSVC
783  #pragma warning(pop)
784  #endif
785  }
786  template <class BidiIterator, class Allocator, class traits>
787  bool perl_matcher<BidiIterator, Allocator, traits>::match_long_set_repeat()
788  {
789  #ifdef BOOST_REGEX_MSVC
790  #pragma warning(push)
791  #pragma warning(disable:4127)
792  #endif
793  #ifdef BOOST_BORLANDC
794  #pragma option push -w-8008 -w-8066 -w-8004
795  #endif
796     typedef typename traits::char_class_type m_type;
797     const re_repeat* rep = static_cast<const re_repeat*>(pstate);
798     const re_set_long<m_type>* set = static_cast<const re_set_long<m_type>*>(pstate->next.p);
799     std::size_t count = 0;
800     bool greedy = (rep->greedy) && (!(m_match_flags & regex_constants::match_any) || m_independent);   
801     std::size_t desired = greedy ? rep->max : rep->min;
802     if(::boost::is_random_access_iterator<BidiIterator>::value)
803     {
804        BidiIterator end = position;
805        std::size_t len = (desired == (std::numeric_limits<std::size_t>::max)()) ? 0u : std::distance(position, last);
806        if(desired >= len)
807           end = last;
808        else
809           std::advance(end, desired);
810        BidiIterator origin(position);
811        while((position != end) && (position != re_is_set_member(position, last, set, re.get_data(), icase)))
812        {
813           ++position;
814        }
815        count = (unsigned)std::distance(origin, position);
816     }
817     else
818     {
819        while((count < desired) && (position != last) && (position != re_is_set_member(position, last, set, re.get_data(), icase)))
820        {
821           ++position;
822           ++count;
823        }
824     }
825     if(count < rep->min)
826        return false;
827     if(greedy)
828     {
829        if((rep->leading) && (count < rep->max))
830           restart = position;
831        if(count - rep->min)
832           push_single_repeat(count, rep, position, saved_state_greedy_single_repeat);
833        pstate = rep->alt.p;
834        return true;
835     }
836     else
837     {
838        if(count < rep->max)
839           push_single_repeat(count, rep, position, saved_state_rep_long_set);
840        pstate = rep->alt.p;
841        return (position == last) ? (rep->can_be_null & mask_skip) : can_start(*position, rep->_map, mask_skip);
842     }
843  #ifdef BOOST_BORLANDC
844  #pragma option pop
845  #endif
846  #ifdef BOOST_REGEX_MSVC
847  #pragma warning(pop)
848  #endif
849  }
850  template <class BidiIterator, class Allocator, class traits>
851  bool perl_matcher<BidiIterator, Allocator, traits>::match_recursion()
852  {
853     BOOST_REGEX_ASSERT(pstate->type == syntax_element_recurse);
854     for(typename std::vector<recursion_info<results_type> >::reverse_iterator i = recursion_stack.rbegin(); i != recursion_stack.rend(); ++i)
855     {
856        if(i->idx == static_cast<const re_brace*>(static_cast<const re_jump*>(pstate)->alt.p)->index)
857        {
858           if(i->location_of_start == position)
859              return false;
860           break;
861        }
862     }
863     push_recursion_pop();
864     if(recursion_stack.capacity() == 0)
865     {
866        recursion_stack.reserve(50);
867     }
868     recursion_stack.push_back(recursion_info<results_type>());
869     recursion_stack.back().preturn_address = pstate->next.p;
870     recursion_stack.back().results = *m_presult;
871     pstate = static_cast<const re_jump*>(pstate)->alt.p;
872     recursion_stack.back().idx = static_cast<const re_brace*>(pstate)->index;
873     recursion_stack.back().location_of_start = position;
874     {
875        push_repeater_count(-(2 + static_cast<const re_brace*>(pstate)->index), &next_count);
876     }
877     return true;
878  }
879  template <class BidiIterator, class Allocator, class traits>
880  bool perl_matcher<BidiIterator, Allocator, traits>::match_endmark()
881  {
882     int index = static_cast<const re_brace*>(pstate)->index;
883     icase = static_cast<const re_brace*>(pstate)->icase;
884     if(index > 0)
885     {
886        if((m_match_flags & match_nosubs) == 0)
887        {
888           m_presult->set_second(position, index);
889        }
890        if(!recursion_stack.empty())
891        {
892           if(index == recursion_stack.back().idx)
893           {
894              pstate = recursion_stack.back().preturn_address;
895              *m_presult = recursion_stack.back().results;
896              push_recursion(recursion_stack.back().idx, recursion_stack.back().preturn_address, m_presult, &recursion_stack.back().results);
897              recursion_stack.pop_back();
898              push_repeater_count(-(2 + index), &next_count);
899           }
900        }
901     }
902     else if((index < 0) && (index != -4))
903     {
904        pstate = 0;
905        return true;
906     }
907     pstate = pstate->next.p;
908     return true;
909  }
910  template <class BidiIterator, class Allocator, class traits>
911  bool perl_matcher<BidiIterator, Allocator, traits>::match_match()
912  {
913     if(!recursion_stack.empty())
914     {
915        BOOST_REGEX_ASSERT(0 == recursion_stack.back().idx);
916        pstate = recursion_stack.back().preturn_address;
917        push_recursion(recursion_stack.back().idx, recursion_stack.back().preturn_address, m_presult, &recursion_stack.back().results);
918        *m_presult = recursion_stack.back().results;
919        recursion_stack.pop_back();
920        return true;
921     }
922     if((m_match_flags & match_not_null) && (position == (*m_presult)[0].first))
923        return false;
924     if((m_match_flags & match_all) && (position != last))
925        return false;
926     if((m_match_flags & regex_constants::match_not_initial_null) && (position == search_base))
927        return false;
928     m_presult->set_second(position);
929     pstate = 0;
930     m_has_found_match = true;
931     if((m_match_flags & match_posix) == match_posix)
932     {
933        m_result.maybe_assign(*m_presult);
934        if((m_match_flags & match_any) == 0)
935           return false;
936     }
937  #ifdef BOOST_REGEX_MATCH_EXTRA
938     if(match_extra & m_match_flags)
939     {
940        for(unsigned i = 0; i < m_presult->size(); ++i)
941           if((*m_presult)[i].matched)
942              ((*m_presult)[i]).get_captures().push_back((*m_presult)[i]);
943     }
944  #endif
945     return true;
946  }
947  template <class BidiIterator, class Allocator, class traits>
948  bool perl_matcher<BidiIterator, Allocator, traits>::match_commit()
949  {
950     switch(static_cast<const re_commit*>(pstate)->action)
951     {
952     case commit_commit:
953        restart = last;
954        break;
955     case commit_skip:
956        if(base != position)
957        {
958           restart = position;
959           --restart;
960        }
961        break;
962     case commit_prune:
963        break;
964     }
965     saved_state* pmp = m_backup_state;
966     --pmp;
967     if(pmp < m_stack_base)
968     {
969        extend_stack();
970        pmp = m_backup_state;
971        --pmp;
972     }
973     (void) new (pmp)saved_state(16);
974     m_backup_state = pmp;
975     pstate = pstate->next.p;
976     return true;
977  }
978  template <class BidiIterator, class Allocator, class traits>
979  bool perl_matcher<BidiIterator, Allocator, traits>::match_then()
980  {
981     saved_state* pmp = m_backup_state;
982     --pmp;
983     if(pmp < m_stack_base)
984     {
985        extend_stack();
986        pmp = m_backup_state;
987        --pmp;
988     }
989     (void) new (pmp)saved_state(17);
990     m_backup_state = pmp;
991     pstate = pstate->next.p;
992     return true;
993  }
994  template <class BidiIterator, class Allocator, class traits>
995  bool perl_matcher<BidiIterator, Allocator, traits>::skip_until_paren(int index, bool have_match)
996  {
997     while(pstate)
998     {
999        if(pstate->type == syntax_element_endmark)
1000        {
1001           if(static_cast<const re_brace*>(pstate)->index == index)
1002           {
1003              if(have_match)
1004                 return this->match_endmark();
1005              pstate = pstate->next.p;
1006              return true;
1007           }
1008           else
1009           {
1010              const re_syntax_base* sp = pstate;
1011              match_endmark();
1012              if(!pstate)
1013              {
1014                 unwind(true);
1015                 if (!pstate)
1016                    pstate = sp->next.p;
1017              }
1018           }
1019           continue;
1020        }
1021        else if(pstate->type == syntax_element_match)
1022           return true;
1023        else if(pstate->type == syntax_element_startmark)
1024        {
1025           int idx = static_cast<const re_brace*>(pstate)->index;
1026           pstate = pstate->next.p;
1027           skip_until_paren(idx, false);
1028           continue;
1029        }
1030        pstate = pstate->next.p;
1031     }
1032     return true;
1033  }
1034  template <class BidiIterator, class Allocator, class traits>
1035  bool perl_matcher<BidiIterator, Allocator, traits>::unwind(bool have_match)
1036  {
1037     static unwind_proc_type const s_unwind_table[19] = 
1038     {
1039        &perl_matcher<BidiIterator, Allocator, traits>::unwind_end,
1040        &perl_matcher<BidiIterator, Allocator, traits>::unwind_paren,
1041        &perl_matcher<BidiIterator, Allocator, traits>::unwind_recursion_stopper,
1042        &perl_matcher<BidiIterator, Allocator, traits>::unwind_assertion,
1043        &perl_matcher<BidiIterator, Allocator, traits>::unwind_alt,
1044        &perl_matcher<BidiIterator, Allocator, traits>::unwind_repeater_counter,
1045        &perl_matcher<BidiIterator, Allocator, traits>::unwind_extra_block,
1046        &perl_matcher<BidiIterator, Allocator, traits>::unwind_greedy_single_repeat,
1047        &perl_matcher<BidiIterator, Allocator, traits>::unwind_slow_dot_repeat,
1048        &perl_matcher<BidiIterator, Allocator, traits>::unwind_fast_dot_repeat,
1049        &perl_matcher<BidiIterator, Allocator, traits>::unwind_char_repeat,
1050        &perl_matcher<BidiIterator, Allocator, traits>::unwind_short_set_repeat,
1051        &perl_matcher<BidiIterator, Allocator, traits>::unwind_long_set_repeat,
1052        &perl_matcher<BidiIterator, Allocator, traits>::unwind_non_greedy_repeat,
1053        &perl_matcher<BidiIterator, Allocator, traits>::unwind_recursion,
1054        &perl_matcher<BidiIterator, Allocator, traits>::unwind_recursion_pop,
1055        &perl_matcher<BidiIterator, Allocator, traits>::unwind_commit,
1056        &perl_matcher<BidiIterator, Allocator, traits>::unwind_then,
1057        &perl_matcher<BidiIterator, Allocator, traits>::unwind_case,
1058     };
1059     m_recursive_result = have_match;
1060     m_unwound_lookahead = false;
1061     m_unwound_alt = false;
1062     unwind_proc_type unwinder;
1063     bool cont;
1064     do
1065     {
1066        unwinder = s_unwind_table[m_backup_state->state_id];
1067        cont = (this->*unwinder)(m_recursive_result);
1068     }while(cont);
1069     return pstate ? true : false;
1070  }
1071  template <class BidiIterator, class Allocator, class traits>
1072  bool perl_matcher<BidiIterator, Allocator, traits>::unwind_end(bool)
1073  {
1074     pstate = 0;   
1075     return false; 
1076  }
1077  template <class BidiIterator, class Allocator, class traits>
1078  bool perl_matcher<BidiIterator, Allocator, traits>::unwind_case(bool)
1079  {
1080     saved_change_case* pmp = static_cast<saved_change_case*>(m_backup_state);
1081     icase = pmp->icase;
1082     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(pmp++);
1083     m_backup_state = pmp;
1084     return true;
1085  }
1086  template <class BidiIterator, class Allocator, class traits>
1087  bool perl_matcher<BidiIterator, Allocator, traits>::unwind_paren(bool have_match)
1088  {
1089     saved_matched_paren<BidiIterator>* pmp = static_cast<saved_matched_paren<BidiIterator>*>(m_backup_state);
1090     if(!have_match)
1091     {
1092        m_presult->set_first(pmp->sub.first, pmp->index, pmp->index == 0);
1093        m_presult->set_second(pmp->sub.second, pmp->index, pmp->sub.matched, pmp->index == 0);
1094     }
1095  #ifdef BOOST_REGEX_MATCH_EXTRA
1096     else if(pmp->sub.matched && (match_extra & m_match_flags))
1097        ((*m_presult)[pmp->index]).get_captures().push_back(pmp->sub);
1098  #endif
1099     m_backup_state = pmp+1;
1100     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(pmp);
1101     return true; 
1102  }
1103  template <class BidiIterator, class Allocator, class traits>
1104  bool perl_matcher<BidiIterator, Allocator, traits>::unwind_recursion_stopper(bool)
1105  {
1106     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(m_backup_state++);
1107     pstate = 0;   
1108     return false; 
1109  }
1110  template <class BidiIterator, class Allocator, class traits>
1111  bool perl_matcher<BidiIterator, Allocator, traits>::unwind_assertion(bool r)
1112  {
1113     saved_assertion<BidiIterator>* pmp = static_cast<saved_assertion<BidiIterator>*>(m_backup_state);
1114     pstate = pmp->pstate;
1115     position = pmp->position;
1116     bool result = (r == pmp->positive);
1117     m_recursive_result = pmp->positive ? r : !r;
1118     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(pmp++);
1119     m_backup_state = pmp;
1120     m_unwound_lookahead = true;
1121     return !result; 
1122  }
1123  template <class BidiIterator, class Allocator, class traits>
1124  bool perl_matcher<BidiIterator, Allocator, traits>::unwind_alt(bool r)
1125  {
1126     saved_position<BidiIterator>* pmp = static_cast<saved_position<BidiIterator>*>(m_backup_state);
1127     if(!r)
1128     {
1129        pstate = pmp->pstate;
1130        position = pmp->position;
1131     }
1132     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(pmp++);
1133     m_backup_state = pmp;
1134     m_unwound_alt = !r;
1135     return r; 
1136  }
1137  template <class BidiIterator, class Allocator, class traits>
1138  bool perl_matcher<BidiIterator, Allocator, traits>::unwind_repeater_counter(bool)
1139  {
1140     saved_repeater<BidiIterator>* pmp = static_cast<saved_repeater<BidiIterator>*>(m_backup_state);
1141     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(pmp++);
1142     m_backup_state = pmp;
1143     return true; 
1144  }
1145  template <class BidiIterator, class Allocator, class traits>
1146  bool perl_matcher<BidiIterator, Allocator, traits>::unwind_extra_block(bool)
1147  {
1148     ++used_block_count;
1149     saved_extra_block* pmp = static_cast<saved_extra_block*>(m_backup_state);
1150     void* condemmed = m_stack_base;
1151     m_stack_base = pmp->base;
1152     m_backup_state = pmp->end;
1153     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(pmp);
1154     put_mem_block(condemmed);
1155     return true; 
1156  }
1157  template <class BidiIterator, class Allocator, class traits>
1158  inline void perl_matcher<BidiIterator, Allocator, traits>::destroy_single_repeat()
1159  {
1160     saved_single_repeat<BidiIterator>* p = static_cast<saved_single_repeat<BidiIterator>*>(m_backup_state);
1161     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(p++);
1162     m_backup_state = p;
1163  }
1164  template <class BidiIterator, class Allocator, class traits>
1165  bool perl_matcher<BidiIterator, Allocator, traits>::unwind_greedy_single_repeat(bool r)
1166  {
1167     saved_single_repeat<BidiIterator>* pmp = static_cast<saved_single_repeat<BidiIterator>*>(m_backup_state);
1168     if(r) 
1169     {
1170        destroy_single_repeat();
1171        return true;
1172     }
1173     const re_repeat* rep = pmp->rep;
1174     std::size_t count = pmp->count;
1175     BOOST_REGEX_ASSERT(rep->next.p != 0);
1176     BOOST_REGEX_ASSERT(rep->alt.p != 0);
1177     count -= rep->min;
1178     if((m_match_flags & match_partial) && (position == last))
1179        m_has_partial_match = true;
1180     BOOST_REGEX_ASSERT(count);
1181     position = pmp->last_position;
1182     do
1183     {
1184        --position;
1185        --count;
1186        ++state_count;
1187     }while(count && !can_start(*position, rep->_map, mask_skip));
1188     if(count == 0)
1189     {
1190           destroy_single_repeat();
1191           if(!can_start(*position, rep->_map, mask_skip))
1192              return true;
1193     }
1194     else
1195     {
1196        pmp->count = count + rep->min;
1197        pmp->last_position = position;
1198     }
1199     pstate = rep->alt.p;
1200     return false;
1201  }
1202  template <class BidiIterator, class Allocator, class traits>
1203  bool perl_matcher<BidiIterator, Allocator, traits>::unwind_slow_dot_repeat(bool r)
1204  {
1205     saved_single_repeat<BidiIterator>* pmp = static_cast<saved_single_repeat<BidiIterator>*>(m_backup_state);
1206     if(r) 
1207     {
1208        destroy_single_repeat();
1209        return true;
1210     }
1211     const re_repeat* rep = pmp->rep;
1212     std::size_t count = pmp->count;
1213     BOOST_REGEX_ASSERT(rep->type == syntax_element_dot_rep);
1214     BOOST_REGEX_ASSERT(rep->next.p != 0);
1215     BOOST_REGEX_ASSERT(rep->alt.p != 0);
1216     BOOST_REGEX_ASSERT(rep->next.p->type == syntax_element_wild);
1217     BOOST_REGEX_ASSERT(count < rep->max);
1218     pstate = rep->next.p;
1219     position = pmp->last_position;
1220     if(position != last)
1221     {
1222        do
1223        {
1224           if(!match_wild())
1225           {
1226              destroy_single_repeat();
1227              return true;
1228           }
1229           ++count;
1230           ++state_count;
1231           pstate = rep->next.p;
1232        }while((count < rep->max) && (position != last) && !can_start(*position, rep->_map, mask_skip));
1233     }   
1234     if(position == last)
1235     {
1236        destroy_single_repeat();
1237        if((m_match_flags & match_partial) && (position == last) && (position != search_base))
1238           m_has_partial_match = true;
1239        if(0 == (rep->can_be_null & mask_skip))
1240           return true;
1241     }
1242     else if(count == rep->max)
1243     {
1244        destroy_single_repeat();
1245        if(!can_start(*position, rep->_map, mask_skip))
1246           return true;
1247     }
1248     else
1249     {
1250        pmp->count = count;
1251        pmp->last_position = position;
1252     }
1253     pstate = rep->alt.p;
1254     return false;
1255  }
1256  template <class BidiIterator, class Allocator, class traits>
1257  bool perl_matcher<BidiIterator, Allocator, traits>::unwind_fast_dot_repeat(bool r)
1258  {
1259     saved_single_repeat<BidiIterator>* pmp = static_cast<saved_single_repeat<BidiIterator>*>(m_backup_state);
1260     if(r) 
1261     {
1262        destroy_single_repeat();
1263        return true;
1264     }
1265     const re_repeat* rep = pmp->rep;
1266     std::size_t count = pmp->count;
1267     BOOST_REGEX_ASSERT(count < rep->max);
1268     position = pmp->last_position;
1269     if(position != last)
1270     {
1271        do
1272        {
1273           ++position;
1274           ++count;
1275           ++state_count;
1276        }while((count < rep->max) && (position != last) && !can_start(*position, rep->_map, mask_skip));
1277     }
1278     if((rep->leading) && (count < rep->max))
1279        restart = position;
1280     if(position == last)
1281     {
1282        destroy_single_repeat();
1283        if((m_match_flags & match_partial) && (position == last) && (position != search_base))
1284           m_has_partial_match = true;
1285        if(0 == (rep->can_be_null & mask_skip))
1286           return true;
1287     }
1288     else if(count == rep->max)
1289     {
1290        destroy_single_repeat();
1291        if(!can_start(*position, rep->_map, mask_skip))
1292           return true;
1293     }
1294     else
1295     {
1296        pmp->count = count;
1297        pmp->last_position = position;
1298     }
1299     pstate = rep->alt.p;
1300     return false;
1301  }
1302  template <class BidiIterator, class Allocator, class traits>
1303  bool perl_matcher<BidiIterator, Allocator, traits>::unwind_char_repeat(bool r)
1304  {
1305     saved_single_repeat<BidiIterator>* pmp = static_cast<saved_single_repeat<BidiIterator>*>(m_backup_state);
1306     if(r) 
1307     {
1308        destroy_single_repeat();
1309        return true;
1310     }
1311     const re_repeat* rep = pmp->rep;
1312     std::size_t count = pmp->count;
1313     pstate = rep->next.p;
1314     const char_type what = *reinterpret_cast<const char_type*>(static_cast<const re_literal*>(pstate) + 1);
1315     position = pmp->last_position;
1316     BOOST_REGEX_ASSERT(rep->type == syntax_element_char_rep);
1317     BOOST_REGEX_ASSERT(rep->next.p != 0);
1318     BOOST_REGEX_ASSERT(rep->alt.p != 0);
1319     BOOST_REGEX_ASSERT(rep->next.p->type == syntax_element_literal);
1320     BOOST_REGEX_ASSERT(count < rep->max);
1321     if(position != last)
1322     {
1323        do
1324        {
1325           if(traits_inst.translate(*position, icase) != what)
1326           {
1327              destroy_single_repeat();
1328              return true;
1329           }
1330           ++count;
1331           ++ position;
1332           ++state_count;
1333           pstate = rep->next.p;
1334        }while((count < rep->max) && (position != last) && !can_start(*position, rep->_map, mask_skip));
1335     }   
1336     if((rep->leading) && (count < rep->max))
1337        restart = position;
1338     if(position == last)
1339     {
1340        destroy_single_repeat();
1341        if((m_match_flags & match_partial) && (position == last) && (position != search_base))
1342           m_has_partial_match = true;
1343        if(0 == (rep->can_be_null & mask_skip))
1344           return true;
1345     }
1346     else if(count == rep->max)
1347     {
1348        destroy_single_repeat();
1349        if(!can_start(*position, rep->_map, mask_skip))
1350           return true;
1351     }
1352     else
1353     {
1354        pmp->count = count;
1355        pmp->last_position = position;
1356     }
1357     pstate = rep->alt.p;
1358     return false;
1359  }
1360  template <class BidiIterator, class Allocator, class traits>
1361  bool perl_matcher<BidiIterator, Allocator, traits>::unwind_short_set_repeat(bool r)
1362  {
1363     saved_single_repeat<BidiIterator>* pmp = static_cast<saved_single_repeat<BidiIterator>*>(m_backup_state);
1364     if(r) 
1365     {
1366        destroy_single_repeat();
1367        return true;
1368     }
1369     const re_repeat* rep = pmp->rep;
1370     std::size_t count = pmp->count;
1371     pstate = rep->next.p;
1372     const unsigned char* map = static_cast<const re_set*>(rep->next.p)->_map;
1373     position = pmp->last_position;
1374     BOOST_REGEX_ASSERT(rep->type == syntax_element_short_set_rep);
1375     BOOST_REGEX_ASSERT(rep->next.p != 0);
1376     BOOST_REGEX_ASSERT(rep->alt.p != 0);
1377     BOOST_REGEX_ASSERT(rep->next.p->type == syntax_element_set);
1378     BOOST_REGEX_ASSERT(count < rep->max);
1379     if(position != last)
1380     {
1381        do
1382        {
1383           if(!map[static_cast<unsigned char>(traits_inst.translate(*position, icase))])
1384           {
1385              destroy_single_repeat();
1386              return true;
1387           }
1388           ++count;
1389           ++ position;
1390           ++state_count;
1391           pstate = rep->next.p;
1392        }while((count < rep->max) && (position != last) && !can_start(*position, rep->_map, mask_skip));
1393     }   
1394     if((rep->leading) && (count < rep->max))
1395        restart = position;
1396     if(position == last)
1397     {
1398        destroy_single_repeat();
1399        if((m_match_flags & match_partial) && (position == last) && (position != search_base))
1400           m_has_partial_match = true;
1401        if(0 == (rep->can_be_null & mask_skip))
1402           return true;
1403     }
1404     else if(count == rep->max)
1405     {
1406        destroy_single_repeat();
1407        if(!can_start(*position, rep->_map, mask_skip))
1408           return true;
1409     }
1410     else
1411     {
1412        pmp->count = count;
1413        pmp->last_position = position;
1414     }
1415     pstate = rep->alt.p;
1416     return false;
1417  }
1418  template <class BidiIterator, class Allocator, class traits>
1419  bool perl_matcher<BidiIterator, Allocator, traits>::unwind_long_set_repeat(bool r)
1420  {
1421     typedef typename traits::char_class_type m_type;
1422     saved_single_repeat<BidiIterator>* pmp = static_cast<saved_single_repeat<BidiIterator>*>(m_backup_state);
1423     if(r)
1424     {
1425        destroy_single_repeat();
1426        return true;
1427     }
1428     const re_repeat* rep = pmp->rep;
1429     std::size_t count = pmp->count;
1430     pstate = rep->next.p;
1431     const re_set_long<m_type>* set = static_cast<const re_set_long<m_type>*>(pstate);
1432     position = pmp->last_position;
1433     BOOST_REGEX_ASSERT(rep->type == syntax_element_long_set_rep);
1434     BOOST_REGEX_ASSERT(rep->next.p != 0);
1435     BOOST_REGEX_ASSERT(rep->alt.p != 0);
1436     BOOST_REGEX_ASSERT(rep->next.p->type == syntax_element_long_set);
1437     BOOST_REGEX_ASSERT(count < rep->max);
1438     if(position != last)
1439     {
1440        do
1441        {
1442           if(position == re_is_set_member(position, last, set, re.get_data(), icase))
1443           {
1444              destroy_single_repeat();
1445              return true;
1446           }
1447           ++position;
1448           ++count;
1449           ++state_count;
1450           pstate = rep->next.p;
1451        }while((count < rep->max) && (position != last) && !can_start(*position, rep->_map, mask_skip));
1452     }   
1453     if((rep->leading) && (count < rep->max))
1454        restart = position;
1455     if(position == last)
1456     {
1457        destroy_single_repeat();
1458        if((m_match_flags & match_partial) && (position == last) && (position != search_base))
1459           m_has_partial_match = true;
1460        if(0 == (rep->can_be_null & mask_skip))
1461           return true;
1462     }
1463     else if(count == rep->max)
1464     {
1465        destroy_single_repeat();
1466        if(!can_start(*position, rep->_map, mask_skip))
1467           return true;
1468     }
1469     else
1470     {
1471        pmp->count = count;
1472        pmp->last_position = position;
1473     }
1474     pstate = rep->alt.p;
1475     return false;
1476  }
1477  template <class BidiIterator, class Allocator, class traits>
1478  bool perl_matcher<BidiIterator, Allocator, traits>::unwind_non_greedy_repeat(bool r)
1479  {
1480     saved_position<BidiIterator>* pmp = static_cast<saved_position<BidiIterator>*>(m_backup_state);
1481     if(!r)
1482     {
1483        position = pmp->position;
1484        pstate = pmp->pstate;
1485        ++(*next_count);
1486     }
1487     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(pmp++);
1488     m_backup_state = pmp;
1489     return r;
1490  }
1491  template <class BidiIterator, class Allocator, class traits>
1492  bool perl_matcher<BidiIterator, Allocator, traits>::unwind_recursion(bool r)
1493  {
1494     saved_recursion<results_type>* pmp = static_cast<saved_recursion<results_type>*>(m_backup_state);
1495     if (!r)
1496     {
1497        recursion_stack.push_back(recursion_info<results_type>());
1498        recursion_stack.back().idx = pmp->recursion_id;
1499        recursion_stack.back().preturn_address = pmp->preturn_address;
1500        recursion_stack.back().results = pmp->prior_results;
1501        recursion_stack.back().location_of_start = position;
1502        *m_presult = pmp->internal_results;
1503     }
1504     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(pmp++);
1505     m_backup_state = pmp;
1506     return true;
1507  }
1508  template <class BidiIterator, class Allocator, class traits>
1509  bool perl_matcher<BidiIterator, Allocator, traits>::unwind_recursion_pop(bool r)
1510  {
1511     saved_state* pmp = static_cast<saved_state*>(m_backup_state);
1512     if (!r && !recursion_stack.empty())
1513     {
1514        *m_presult = recursion_stack.back().results;
1515        position = recursion_stack.back().location_of_start;
1516        recursion_stack.pop_back();
1517     }
1518     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(pmp++);
1519     m_backup_state = pmp;
1520     return true;
1521  }
1522  template <class BidiIterator, class Allocator, class traits>
1523  void perl_matcher<BidiIterator, Allocator, traits>::push_recursion_pop()
1524  {
1525     saved_state* pmp = static_cast<saved_state*>(m_backup_state);
1526     --pmp;
1527     if(pmp < m_stack_base)
1528     {
1529        extend_stack();
1530        pmp = static_cast<saved_state*>(m_backup_state);
1531        --pmp;
1532     }
1533     (void) new (pmp)saved_state(15);
1534     m_backup_state = pmp;
1535  }
1536  template <class BidiIterator, class Allocator, class traits>
1537  bool perl_matcher<BidiIterator, Allocator, traits>::unwind_commit(bool b)
1538  {
1539     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(m_backup_state++);
1540     while(unwind(b) && !m_unwound_lookahead){}
1541     if(m_unwound_lookahead && pstate)
1542     {
1543        m_unwound_lookahead = false;
1544        saved_state* pmp = m_backup_state;
1545        --pmp;
1546        if(pmp < m_stack_base)
1547        {
1548           extend_stack();
1549           pmp = m_backup_state;
1550           --pmp;
1551        }
1552        (void) new (pmp)saved_state(16);
1553        m_backup_state = pmp;
1554     }
1555     m_independent = false;
1556     return false;
1557  }
1558  template <class BidiIterator, class Allocator, class traits>
1559  bool perl_matcher<BidiIterator, Allocator, traits>::unwind_then(bool b)
1560  {
1561     boost::BOOST_REGEX_DETAIL_NS::inplace_destroy(m_backup_state++);
1562     bool result = false;
1563     result = unwind(b);
1564     while(result && !m_unwound_alt)
1565     {
1566        result = unwind(b);
1567     }
1568     if(result && m_unwound_alt)
1569        unwind(b);
1570     return false;
1571  }
1572  } 
1573  } 
1574  #ifdef BOOST_REGEX_MSVC
1575  #  pragma warning(pop)
1576  #endif
1577  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-perl_matcher_non_recursive.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-perl_matcher_non_recursive.hpp</div>
                </div>
                <div class="column column_space"><pre><code>545        if((next_count->get_count() < rep->max) && take_first)
546        {
547           if(take_second)
</pre></code></div>
                <div class="column column_space"><pre><code>545        if((next_count->get_count() < rep->max) && take_first)
546        {
547           if(take_second)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    