
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-wmine.cpp</h3>
            <pre><code>1  #include "wmine.h"
2  void TWebLog::GetUsrUrlRankStep(
3   const double& TaxFact, const TIntPrV& LRIdPrV,
4   TFltIntKdV& WgtLIdKdV, TFltIntKdV& WgtRIdKdV, double& WgtDiff){
5    int WgtRIdKds=WgtRIdKdV.Len();
6    TFltIntKdV NewWgtRIdKdV(WgtRIdKds, 0);
7    for (int NewRIdN=0; NewRIdN<WgtRIdKds; NewRIdN++){
8      NewWgtRIdKdV.Add(TFltIntKd(0, WgtRIdKdV[NewRIdN].Dat));}
9    double TaxWealth=0;
10    int LRIdKdN=0; int LRIdKds=LRIdPrV.Len(); double WgtSum=0;
11    while (LRIdKdN<LRIdKds){
12      int LId=LRIdPrV[LRIdKdN].Val1;
13      double LWgt=(1-TaxFact)*WgtLIdKdV[LId].Key;
14      TaxWealth+=TaxFact*WgtLIdKdV[LId].Key;
15      int RIds=0;
16      while ((LRIdKdN+RIds<LRIdKds)&&
17       (LRIdPrV[LRIdKdN+RIds].Val1==LId)){RIds++;}
18      for (int RIdN=0; RIdN<RIds; RIdN++){
19        int RId=LRIdPrV[LRIdKdN+RIdN].Val2;
20        NewWgtRIdKdV[RId].Key+=LWgt/RIds;
21        WgtSum+=LWgt/RIds;
22      }
23      LRIdKdN+=RIds;
24    }
25    for (int RIdWgtKdN=0; RIdWgtKdN<WgtRIdKds; RIdWgtKdN++){
26      WgtDiff+=fabs(NewWgtRIdKdV[RIdWgtKdN].Key-WgtRIdKdV[RIdWgtKdN].Key);
27      WgtRIdKdV[RIdWgtKdN].Key=0;
28      WgtRIdKdV[RIdWgtKdN].Key+=NewWgtRIdKdV[RIdWgtKdN].Key;
29    }
30  }
31  void TWebLog::GetUsrUrlRank(
32   TFltIntKdV& WgtUsrIdKdV, TFltIntKdV& WgtUrlIdKdV) const {
33    int Usrs=GetUsrs(); int Urls=GetUrls();
34    WgtUsrIdKdV.Gen(Usrs, 0); WgtUrlIdKdV.Gen(Urls, 0);
35    for (int UsrId=0; UsrId<Usrs; UsrId++){WgtUsrIdKdV.Add(TFltIntKd(1, UsrId));}
36    for (int UrlId=0; UrlId<Urls; UrlId++){WgtUrlIdKdV.Add(TFltIntKd(0, UrlId));}
37    double TaxFact=0.15; int IterN=0; double KdevWgtDiff=0; double WgtDiff=0;
38    forever {
39      GetUsrUrlRankStep(TaxFact, UsrIdUrlIdPrV, WgtUsrIdKdV, WgtUrlIdKdV, WgtDiff);
40      GetUsrUrlRankStep(TaxFact, UrlIdUsrIdPrV, WgtUrlIdKdV, WgtUsrIdKdV, WgtDiff);
41      IterN++;
42      printf("%d: %g\n", IterN, fabs(WgtDiff-KdevWgtDiff));
43      if (fabs(WgtDiff-KdevWgtDiff)<0.001){break;}
44      KdevWgtDiff=WgtDiff;
45    }
46    WgtUrlIdKdV.Sort(false); WgtUsrIdKdV.Sort(false);
47  }
48  void TWebLog::SaveTxtUURank(const PSOut& SOut,
49   const TFltIntKdV& WgtUsrIdKdV, const TFltIntKdV& WgtUrlIdKdV,
50   const int& TopRecs) const {
51    int TopUrls=TopRecs;
52    if ((TopUrls==-1)||(TopUrls>GetUrls())){TopUrls=GetUrls();}
53    SOut->PutStr("================================="); SOut->PutLn();
54    SOut->PutStr("Best Urls"); SOut->PutLn();
55    for (int UrlN=0; UrlN<TopUrls; UrlN++){
56      double Wgt=WgtUrlIdKdV[UrlN].Key;
57      int UrlId=WgtUrlIdKdV[UrlN].Dat;
58      TStr UrlStr=GetUrlNm(UrlId);
59      TChA OutLn;
60      OutLn+=TInt::GetStr(UrlN+1, "%d.");
61      OutLn+=TFlt::GetStr(Wgt, " (%g)");
62      OutLn+=TStr::GetStr(UrlStr, " '%s'");
63      SOut->PutStr(OutLn); SOut->PutLn();
64    }
65    int TopUsrs=TopRecs;
66    if ((TopUsrs==-1)||(TopUsrs>GetUsrs())){TopUsrs=GetUsrs();}
67    SOut->PutStr("================================="); SOut->PutLn();
68    SOut->PutStr("Best Users"); SOut->PutLn();
69    for (int UsrN=0; UsrN<TopUsrs; UsrN++){
70      double Wgt=WgtUsrIdKdV[UsrN].Key;
71      int UsrId=WgtUsrIdKdV[UsrN].Dat;
72      TStr UsrStr=GetUsrNm(UsrId);
73      TChA OutLn;
74      OutLn+=TInt::GetStr(UsrN+1, "%d.");
75      OutLn+=TFlt::GetStr(Wgt, " (%g)");
76      OutLn+=TStr::GetStr(UsrStr, " '%s'");
77      SOut->PutStr(OutLn); SOut->PutLn();
78    }
79  }
80  void TWebLog::SaveXmlUURank(const PSOut& SOut,
81   const TFltIntKdV& WgtUsrIdKdV, const TFltIntKdV& WgtUrlIdKdV,
82   const int& TopRecs) const {
83    SOut->PutStr("<UrlUserRank>"); SOut->PutLn();
84    int TopUrls=TopRecs;
85    if ((TopUrls==-1)||(TopUrls>GetUrls())){TopUrls=GetUrls();}
86    SOut->PutStr("<UrlRank>"); SOut->PutLn();
87    for (int UrlN=0; UrlN<TopUrls; UrlN++){
88      double Wgt=WgtUrlIdKdV[UrlN].Key;
89      int UrlId=WgtUrlIdKdV[UrlN].Dat;
90      TStr UrlStr=GetUrlNm(UrlId);
91      TChA BTagChA;
92      BTagChA+="<Rank";
93      BTagChA+=TInt::GetStr(UrlN+1, " Place=\"%d\"");
94      BTagChA+=TFlt::GetStr(Wgt, " Weigth=\"%g\"");
95      BTagChA+=">";
96      SOut->PutStr(BTagChA);
97      TStr UrlXmlStr=TXmlLx::GetXmlStrFromPlainStr(UrlStr);
98      SOut->PutStr(UrlXmlStr);
99      SOut->PutStr("</Rank>");
100      SOut->PutLn();
101    }
102    SOut->PutStr("</UrlRank>"); SOut->PutLn();
103    int TopUsrs=TopRecs;
104    if ((TopUsrs==-1)||(TopUsrs>GetUsrs())){TopUsrs=GetUsrs();}
105    SOut->PutStr("<UserRank>"); SOut->PutLn();
106    for (int UsrN=0; UsrN<TopUsrs; UsrN++){
107      double Wgt=WgtUsrIdKdV[UsrN].Key;
108      int UsrId=WgtUsrIdKdV[UsrN].Dat;
109      TStr UsrStr=GetUsrNm(UsrId);
110      TChA BTagChA;
111      BTagChA+="<Rank";
112      BTagChA+=TInt::GetStr(UsrN+1, " Place=\"%d\"");
113      BTagChA+=TFlt::GetStr(Wgt, " Weigth=\"%g\"");
114      BTagChA+=">";
115      SOut->PutStr(BTagChA);
116      TStr UsrXmlStr=TXmlLx::GetXmlStrFromPlainStr(UsrStr);
117      SOut->PutStr(UsrXmlStr);
118      SOut->PutStr("</Rank>");
119      SOut->PutLn();
120    }
121    SOut->PutStr("</UserRank>"); SOut->PutLn();
122    SOut->PutStr("</UrlUserRank>"); SOut->PutLn();
123  }
124  PBowDocBs TWebLog::GetBowDocBs(
125   const TStrIntH& DocNmToFqH, const TIntPrV& DIdWIdPrV,
126   const TStrIntH& WordStrToFqH, const int& MnFq) const {
127    printf("Generating Bag-Of-Words...\n");
128    PBowDocBs BowDocBs=TBowDocBs::New();
129    int DIdWIdPrs=DIdWIdPrV.Len();
130    int PrevDId=-1; TStr DocNm; TStrV WordStrV;
131    for (int DIdWIdPrN=0; DIdWIdPrN<DIdWIdPrs; DIdWIdPrN++){
132      if (DIdWIdPrN%100==0){printf("%d/%d\r", DIdWIdPrN, DIdWIdPrs);}
133      int DId=DIdWIdPrV[DIdWIdPrN].Val1;
134      int WId=DIdWIdPrV[DIdWIdPrN].Val2;
135      if ((PrevDId!=-1)&&(PrevDId!=DId)){
136        if (WordStrV.Len()>=MnFq){
137          BowDocBs->AddDoc(DocNm, TStrV(), WordStrV, "");}
138        DocNm=DocNmToFqH.GetKey(DId);
139        WordStrV.Clr(false);
140      }
141      WordStrV.Add(WordStrToFqH.GetKey(WId));
142      PrevDId=DId;
143    }
144    if (!WordStrV.Empty()){
145      if (WordStrV.Len()>=MnFq){
146        BowDocBs->AddDoc(DocNm, TStrV(), WordStrV, "");}
147    }
148    BowDocBs->AssertOk();
149    printf("\nDone.\n");
150    return BowDocBs;
151  }
152  PBowDocBs TWebLog::GetUsrBowDocBsFromUrl(const int& MnFq) const {
153    return GetBowDocBs(UsrNmToClicksH, UsrIdUrlIdPrV, UrlNmToClicksH, MnFq);
154  }
155  PBowDocBs TWebLog::GetUrlBowDocBsFromUsr(const int& MnFq) const {
156    return GetBowDocBs(UrlNmToClicksH, UrlIdUsrIdPrV, UsrNmToClicksH, MnFq);
157  }
158  PBowDocBs TWebLog::GetUsrBowDocBsFromHtml(
159   const int& MnFq, const TStr& WebRootFPath){
160    printf("Generating Bag-Of-Words...\n");
161    PBowDocBs BowDocBs=TBowDocBs::New();
162    TStrIntH& DocNmToFqH=UsrNmToClicksH;
163    TIntPrV& DIdWIdPrV=UsrIdUrlIdPrV;
164    TStrIntH& WordStrToFqH=UrlNmToClicksH;
165    TStr WebRootNrFPath=TStr::GetNrFPath(WebRootFPath);
166    if ((WebRootNrFPath.Len()>0)&&(WebRootNrFPath.LastCh()=='/')){
167      WebRootNrFPath.DelSubStr(WebRootNrFPath.Len()-1, WebRootNrFPath.Len()-1);}
168    PSwSet SwSet=TSwSet::GetSwSet(swstEn523);
169    int DIdWIdPrs=DIdWIdPrV.Len();
170    int PrevDId=-1; TStr DocNm; TStrV WordStrV; int NotFoundDocs=0;
171    for (int DIdWIdPrN=0; DIdWIdPrN<DIdWIdPrs; DIdWIdPrN++){
172      if (DIdWIdPrN%10==0){
173        printf("%d/%d (%d missed)\r", DIdWIdPrN, DIdWIdPrs, NotFoundDocs);}
174      int DId=DIdWIdPrV[DIdWIdPrN].Val1;
175      int WId=DIdWIdPrV[DIdWIdPrN].Val2;
<span onclick='openModal()' class='match'>176      if ((PrevDId!=-1)&&(PrevDId!=DId)){
177        if (WordStrV.Len()>=MnFq){
</span>178          BowDocBs->AddDoc(DocNm, TStrV(), WordStrV, "");}
179        DocNm=DocNmToFqH.GetKey(DId);
180        WordStrV.Clr(false);
181      }
182      TStr HtmlFNm=WebRootNrFPath+WordStrToFqH.GetKey(WId);
183      if (TFile::Exists(HtmlFNm)){
184        PSIn HtmlSIn=TFIn::New(HtmlFNm);
185        THtmlLx HtmlLx(HtmlSIn);
186        while (HtmlLx.Sym!=hsyEof){
187          if (HtmlLx.Sym==hsyStr){
188            TStr WordStr=HtmlLx.UcChA;
189            if (!SwSet->IsIn(WordStr)){
190              WordStrV.Add(WordStr);
191            }
192          }
193          HtmlLx.GetSym();
194        }
195      } else {
196        NotFoundDocs++;
197      }
198      PrevDId=DId;
199    }
200    if (!WordStrV.Empty()){
201      if (WordStrV.Len()>=MnFq){
202        BowDocBs->AddDoc(DocNm, TStrV(), WordStrV, "");}
203    }
204    BowDocBs->AssertOk();
205    printf("\nDone.\n");
206    return BowDocBs;
207  }
208  PWebLog TWebLog::LoadTxt(const TStr& FNm, const int& MxRecs,
209   const TSsFmt& SsFmt, const bool& HdLnP){
210    printf("Loading web-log '%s' ...\n", FNm.CStr());
211    PWebLog WebLog=TWebLog::New();
212    PSIn SIn=TFIn::New(FNm);
213    int UsrIdFldN=0; int UrlIdFldN=1;
214    if (HdLnP){
215      char Ch=' '; TStrV FldNmV; TSs::LoadTxtFldV(SsFmt, SIn, Ch, FldNmV);
216      UsrIdFldN=FldNmV.SearchForw("UserID");
217      UrlIdFldN=FldNmV.SearchForw("URLID");
218    }
219    TStrV FldValV; int Recs=0;
220    while (!SIn->Eof()){
221      if ((MxRecs!=-1)&&(Recs>MxRecs)){break;}
222      Recs++; if (Recs%100==0){printf("%d\r", Recs);}
223      char Ch=' '; TSs::LoadTxtFldV(SsFmt, SIn, Ch, FldValV);
224      TStr UsrNm=FldValV[UsrIdFldN].GetLc();
225      TStr UrlNm=FldValV[UrlIdFldN].GetLc();
226      int UsrId=WebLog->UsrNmToClicksH.AddKey(UsrNm);
227      int UrlId=WebLog->UrlNmToClicksH.AddKey(UrlNm);
228      WebLog->UsrNmToClicksH[UsrId]++;
229      WebLog->UrlNmToClicksH[UrlId]++;
230      WebLog->UsrIdUrlIdPrV.Add(TIntPr(UsrId, UrlId));
231      WebLog->UrlIdUsrIdPrV.Add(TIntPr(UrlId, UsrId));
232    }
233    WebLog->UsrIdUrlIdPrV.Sort();
234    WebLog->UrlIdUsrIdPrV.Sort();
235    printf("   Users:%d   Urls:%d   Clicks:%d\n",
236     WebLog->GetUsrs(), WebLog->GetUrls(), WebLog->GetClicks());
237    printf("Done.\n");
238    return WebLog;
239  }
240  PWebLog TWebLog::LoadBinOrTxt(
241   const TStr& BinFNm, const TStr& TxtFNm, const int& MxRecs){
242    PWebLog WebLog;
243    if (TFile::Exists(BinFNm)){
244      printf("Loading binary file '%s' ... ", BinFNm.CStr());
245      WebLog=TWebLog::LoadBin(BinFNm);
246      printf("Done.\n");
247    } else {
248      printf("Loading text file '%s' ... ", TxtFNm.CStr());
249      WebLog=LoadTxt(TxtFNm, MxRecs);
250      printf("Done.\n");
251      if (!BinFNm.Empty()){
252        printf("Saving binary file '%s'... ", BinFNm.CStr());
253        WebLog->SaveBin(BinFNm);
254        printf("Done.\n");
255      }
256    }
257    return WebLog;
258  }
259  PWebLog TWebLog::LoadYbTxt(const TStr& FNm, const int& MxRecs){
260    printf("Loading Yield-Broker Web-Log '%s' ...\n", FNm.CStr());
261    PWebLog WebLog=TWebLog::New();
262    PSIn SIn=TFIn::New(FNm);
263    char Ch=' '; TStrV FldNmV; TSs::LoadTxtFldV(ssfCommaSep, SIn, Ch, FldNmV);
264    int UsrIdFldN=FldNmV.SearchForw("UserID");
265    int UrlIdFldN=FldNmV.SearchForw("URLID");
266    TStrV FldValV; int Recs=0;
267    while (!SIn->Eof()){
268      if ((MxRecs!=-1)&&(Recs>MxRecs)){break;}
269      Recs++; if (Recs%100==0){printf("%d\r", Recs);}
270      char Ch=' '; TSs::LoadTxtFldV(ssfCommaSep, SIn, Ch, FldValV);
271      TStr UsrNm=FldValV[UsrIdFldN].GetLc();
272      TStr UrlNm=FldValV[UrlIdFldN].GetLc();
273      int UsrId=WebLog->UsrNmToClicksH.AddKey(UsrNm);
274      int UrlId=WebLog->UrlNmToClicksH.AddKey(UrlNm);
275      WebLog->UsrNmToClicksH[UsrId]++;
276      WebLog->UrlNmToClicksH[UrlId]++;
277      WebLog->UsrIdUrlIdPrV.Add(TIntPr(UsrId, UrlId));
278      WebLog->UrlIdUsrIdPrV.Add(TIntPr(UrlId, UsrId));
279    }
280    WebLog->UsrIdUrlIdPrV.Sort();
281    WebLog->UrlIdUsrIdPrV.Sort();
282    printf("   Users:%d   Urls:%d   Clicks:%d\n",
283     WebLog->GetUsrs(), WebLog->GetUrls(), WebLog->GetClicks());
284    printf("Done.\n");
285    return WebLog;
286  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-ss.cpp</h3>
            <pre><code>1  TStr& TSs::At(const int& X, const int& Y){
2    if (Y>=CellStrVV.Len()){CellStrVV.Reserve(Y+1, Y+1);}
3    if (X>=CellStrVV[Y]->Len()){CellStrVV[Y]->V.Reserve(X+1, X+1);}
4    return CellStrVV[Y]->V[X];
5  }
6  void TSs::PutVal(const int& X, const int& Y, const TStr& Str){
7    if (Y>=CellStrVV.Len()){CellStrVV.Reserve(Y+1, Y+1);}
8    if (X>=CellStrVV[Y]->Len()){CellStrVV[Y]->V.Reserve(X+1, X+1);}
9    CellStrVV[Y]->V[X]=Str;
10  }
11  TStr TSs::GetVal(const int& X, const int& Y) const {
12    if ((0<=Y)&&(Y<CellStrVV.Len())){
13      if ((0<=X)&&(X<CellStrVV[Y]->Len())){
14        return CellStrVV[Y]->V[X];
15      } else {
16        return TStr::GetNullStr();
17      }
18    } else {
19      return TStr::GetNullStr();
20    }
21  }
22  int TSs::GetXLen() const {
23    if (CellStrVV.Len()==0){
24      return 0;
25    } else {
26      int MxXLen=CellStrVV[0]->Len();
27      for (int Y=1; Y<CellStrVV.Len(); Y++){
28        MxXLen=TInt::GetMx(MxXLen, CellStrVV[Y]->Len());}
29      return MxXLen;
30    }
31  }
32  int TSs::GetXLen(const int& Y) const {
33    if ((0<=Y)&&(Y<CellStrVV.Len())){
34      return CellStrVV[Y]->Len();
35    } else {
36      return 0;
37    }
38  }
39  int TSs::GetYLen() const {
40    return CellStrVV.Len();
41  }
42  int TSs::SearchX(const int& Y, const TStr& Str) const {
43    return CellStrVV[Y]->V.SearchForw(Str);
44  }
45  int TSs::SearchY(const int& X, const TStr& Str) const {
46    int YLen=GetYLen();
47    for (int Y=0; Y<YLen; Y++){
48       if (Str==GetVal(X, Y)){return Y;}}
49    return -1;
50  }
51  void TSs::DelX(const int& X){
52    int YLen=GetYLen();
53    for (int Y=0; Y<YLen; Y++){
54      CellStrVV[Y]->V.Del(X);
55    }
56  }
57  void TSs::DelY(const int& Y){
58    CellStrVV.Del(Y);
59  }
60  int TSs::GetFldX(const TStr& FldNm, const TStr& NewFldNm, const int& Y) const {
61    if (GetYLen()>Y){
62      int XLen=GetXLen(Y);
63      for (int X=0; X<XLen; X++){
64        if (GetVal(X, Y).GetTrunc()==FldNm){
65          if (!NewFldNm.Empty()){GetVal(X, Y)=NewFldNm;}
66          return X;
67        }
68      }
69      return -1;
70    } else {
71      return -1;
72    }
73  }
74  int TSs::GetFldY(const TStr& FldNm, const TStr& NewFldNm, const int& X) const {
75    for (int Y=0; Y<GetYLen(); Y++){
76      if (GetXLen(Y)>X){
77        if (GetVal(X, Y).GetTrunc()==FldNm){
78          if (!NewFldNm.Empty()){GetVal(X, Y)=NewFldNm;}
79          return Y;
80        }
81      }
82    }
83    return -1;
84  }
85  PSs TSs::LoadTxt(
86   const TSsFmt& SsFmt, const TStr& FNm,
87   const PNotify& Notify, const bool& IsExcelEoln,
88   const int& MxY, const TIntV& AllowedColNV, const bool& IsQStr){
89    TNotify::OnNotify(Notify, ntInfo, TStr("Loading File ")+FNm+" ...");
90    PSIn SIn=TFIn::New(FNm);
91    PSs Ss=TSs::New();
92    if (!SIn->Eof()){
93      int X=0; int Y=0; int PrevX=-1; int PrevY=-1;
94      char Ch=SIn->GetCh(); TChA ChA;
95      while (!SIn->Eof()){
96        ChA.Clr();
97        if (IsQStr&&(Ch=='"')){
98          Ch=SIn->GetCh();
99          forever {
100            while ((!SIn->Eof())&&(Ch!='"')){
101              ChA+=Ch; Ch=SIn->GetCh();}
102            if (Ch=='"'){
103              Ch=SIn->GetCh();
104              if (Ch=='"'){ChA+=Ch; Ch=SIn->GetCh();}
105              else {break;}
106            }
107          }
108        } else {
109          if (SsFmt==ssfTabSep){
110            while ((!SIn->Eof())&&(Ch!='\t')&&(Ch!='\r')&&((Ch!='\n')||IsExcelEoln)){
111              ChA+=Ch; Ch=SIn->GetCh();
112            }
113          } else
114          if (SsFmt==ssfCommaSep){
115            while ((!SIn->Eof())&&(Ch!=',')&&(Ch!='\r')&&((Ch!='\n')||IsExcelEoln)){
116              ChA+=Ch; Ch=SIn->GetCh();
117            }
118          } else
119          if (SsFmt==ssfSemicolonSep){
120            while ((!SIn->Eof())&&(Ch!=';')&&(Ch!='\r')&&((Ch!='\n')||IsExcelEoln)){
121              ChA+=Ch; Ch=SIn->GetCh();
122            }
123          } else
124          if (SsFmt==ssfVBar){
125            while ((!SIn->Eof())&&(Ch!='|')&&(Ch!='\r')&&((Ch!='\n')||IsExcelEoln)){
126              ChA+=Ch; Ch=SIn->GetCh();
127            }
128          } else
129          if (SsFmt==ssfSpaceSep){
130            while ((!SIn->Eof())&&(Ch!=' ')&&(Ch!='\r')&&((Ch!='\n')||IsExcelEoln)){
131              ChA+=Ch; Ch=SIn->GetCh();
132            }
133          } else {
134            Fail;
135          }
136        }
137        if (PrevY!=Y){
138          if ((MxY!=-1)&&(Ss->CellStrVV.Len()==MxY)){break;}
139          Ss->CellStrVV.Add(TStrVP::New()); PrevY=Y;
140          int Recs=Ss->CellStrVV.Len();
141          if (Recs%1000==0){
142            TNotify::OnStatus(Notify, TStr::Fmt("  %d\r", Recs));}
143        }
144        if (AllowedColNV.Empty()||AllowedColNV.IsIn(X)){
145          Ss->CellStrVV[Y]->V.Add(ChA); 
146        }
147        if (SIn->Eof()){
148          break;
149        } else
150        if ((SsFmt==ssfTabSep)&&(Ch=='\t')){
151          X++; Ch=SIn->GetCh();
152        } else
153        if ((SsFmt==ssfCommaSep)&&(Ch==',')){
154          X++; Ch=SIn->GetCh();
155        } else
156        if ((SsFmt==ssfSemicolonSep)&&(Ch==';')){
157          X++; Ch=SIn->GetCh();
158        } else
159        if ((SsFmt==ssfVBar)&&(Ch=='|')){
160          X++; Ch=SIn->GetCh();
161        } else
162        if ((SsFmt==ssfSpaceSep)&&(Ch==' ')){
163          X++; Ch=SIn->GetCh();
164        } else
165        if (Ch=='\r'){
<span onclick='openModal()' class='match'>166          if ((PrevX!=-1)&&(X!=PrevX)){
167            TNotify::OnNotify(Notify, ntWarn, "Number of fields is not the same!");}
</span>168          PrevX=X; X=0; Y++; Ch=SIn->GetCh();
169          if ((Ch=='\n')&&(!SIn->Eof())){Ch=SIn->GetCh();}
170        } else
171        if (Ch=='\n'){
172          if ((PrevX!=-1)&&(X!=PrevX)){
173            TNotify::OnNotify(Notify, ntWarn, "Number of fields is not the same!");}
174          PrevX=X; X=0; Y++; Ch=SIn->GetCh();
175          if ((Ch=='\r')&&(!SIn->Eof())){Ch=SIn->GetCh();}
176        } else {
177          Fail;
178        }
179      }
180    }
181    int Recs=Ss->CellStrVV.Len();
182    TNotify::OnNotify(Notify, ntInfo, TStr::Fmt("  %d records read.", Recs));
183    TNotify::OnNotify(Notify, ntInfo, "... Done.");
184    return Ss;
185  }
186  void TSs::SaveTxt(const TStr& FNm, const PNotify&) const {
187    PSOut SOut=TFOut::New(FNm);
188    for (int Y=0; Y<CellStrVV.Len(); Y++){
189      for (int X=0; X<CellStrVV[Y]->Len(); X++){
190        if (X>0){SOut->PutCh('\t');}
191        TStr Str=CellStrVV[Y]->V[X];
192        TChA ChA(Str);
193        for (int ChN=0; ChN<ChA.Len(); ChN++){
194          char Ch=ChA[ChN];
195          if ((Ch=='\t')||(Ch=='\r')||(Ch=='\n')){
196            ChA.PutCh(ChN, ' ');
197          }
198        }
199        SOut->PutStr(ChA);
200      }
201      SOut->PutCh('\r'); SOut->PutCh('\n');
202    }
203  }
204  void TSs::LoadTxtFldV(
205   const TSsFmt& SsFmt, const PSIn& SIn, char& Ch,
206   TStrV& FldValV, const bool& IsExcelEoln, const bool& IsQStr){
207    if (!SIn->Eof()){
208      FldValV.Clr(false); int X=0;
209      if (Ch==TCh::NullCh){Ch=SIn->GetCh();}
210      TChA ChA;
211      while (!SIn->Eof()){
212        ChA.Clr();
213        if (IsQStr&&(Ch=='"')){
214          Ch=SIn->GetCh();
215          forever {
216            while ((!SIn->Eof())&&(Ch!='"')){
217              ChA+=Ch; Ch=SIn->GetCh();}
218            if (Ch=='"'){
219              Ch=SIn->GetCh();
220              if (Ch=='"'){ChA+=Ch; Ch=SIn->GetCh();}
221              else {break;}
222            }
223          }
224        } else {
225          if (SsFmt==ssfTabSep){
226            while ((!SIn->Eof())&&(Ch!='\t')&&(Ch!='\r')&&
227             ((Ch!='\n')||IsExcelEoln)){
228              ChA+=Ch; Ch=SIn->GetCh();
229            }
230            if ((!ChA.Empty())&&(ChA.LastCh()=='\"')){
231              ChA.Pop();}
232          } else
233          if (SsFmt==ssfCommaSep){
234            while ((!SIn->Eof())&&(Ch!=',')&&(Ch!='\r')&&
235             ((Ch!='\n')||IsExcelEoln)){
236              ChA+=Ch; Ch=SIn->GetCh();
237            }
238          } else
239          if (SsFmt==ssfSemicolonSep){
240            while ((!SIn->Eof())&&(Ch!=';')&&(Ch!='\r')&&
241             ((Ch!='\n')||IsExcelEoln)){
242              ChA+=Ch; Ch=SIn->GetCh();
243            }
244          } else
245          if (SsFmt==ssfVBar){
246            while ((!SIn->Eof())&&(Ch!='|')&&(Ch!='\r')&&
247             ((Ch!='\n')||IsExcelEoln)){
248              ChA+=Ch; Ch=SIn->GetCh();
249            }
250          } else {
251            Fail;
252          }
253        }
254        ChA.Trunc();
255        FldValV.Add(ChA);
256        if (SIn->Eof()){
257          break;
258        } else
259        if ((SsFmt==ssfTabSep)&&(Ch=='\t')){
260          X++; Ch=SIn->GetCh();
261        } else
262        if ((SsFmt==ssfCommaSep)&&(Ch==',')){
263          X++; Ch=SIn->GetCh();
264        } else
265        if ((SsFmt==ssfSemicolonSep)&&(Ch==';')){
266          X++; Ch=SIn->GetCh();
267        } else
268        if ((SsFmt==ssfVBar)&&(Ch=='|')){
269          X++; Ch=SIn->GetCh();
270        } else
271        if (Ch=='\r'){
272          Ch=SIn->GetCh();
273          if ((Ch=='\n')&&(!SIn->Eof())){Ch=SIn->GetCh();}
274          break;
275        } else
276        if (Ch=='\n'){
277          X=0; Ch=SIn->GetCh();
278          if ((Ch=='\r')&&(!SIn->Eof())){Ch=SIn->GetCh();}
279          break;
280        } else {
281          Fail;
282        }
283      }
284    }
285  }
286  TSsFmt TSs::GetSsFmtFromStr(const TStr& SsFmtNm){
287    TStr LcSsFmtNm=SsFmtNm.GetLc();
288    if (LcSsFmtNm=="tab"){return ssfTabSep;}
289    else if (LcSsFmtNm=="comma"){return ssfCommaSep;}
290    else if (LcSsFmtNm=="semicolon"){return ssfSemicolonSep;}
291    else if (LcSsFmtNm=="vbar"){return ssfVBar;}
292    else if (LcSsFmtNm=="space"){return ssfSpaceSep;}
293    else if (LcSsFmtNm=="white"){return ssfWhiteSep;}
294    else {return ssfUndef;}
295  }
296  TStr TSs::GetStrFromSsFmt(const TSsFmt& SsFmt){
297    switch (SsFmt){
298      case ssfTabSep: return "tab";
299      case ssfCommaSep: return "comma";
300      case ssfSemicolonSep: return "semicolon";
301      case ssfVBar: return "vbar";
302      case ssfSpaceSep: return "space";
303      case ssfWhiteSep: return "white";
304      default: return "undef";
305    }
306  }
307  TStr TSs::GetSsFmtNmVStr(){
308    TChA ChA;
309    ChA+='(';
310    ChA+="tab"; ChA+=", ";
311    ChA+="comma"; ChA+=", ";
312    ChA+="semicolon"; ChA+=", ";
313    ChA+="space"; ChA+=", ";
314    ChA+="white"; ChA+=")";
315    return ChA;
316  }
317  TSsParser::TSsParser(const TStr& FNm, const TSsFmt _SsFmt, const bool& _SkipLeadBlanks, const bool& _SkipCmt, const bool& _SkipEmptyFld) : SsFmt(_SsFmt), 
318   SkipLeadBlanks(_SkipLeadBlanks), SkipCmt(_SkipCmt), SkipEmptyFld(_SkipEmptyFld), LineCnt(0), &bsol;*Bf(NULL),*/ SplitCh('\t'), LineStr(), FldV(), FInPt(NULL) {
319    if (TZipIn::IsZipExt(FNm.GetFExt())) { FInPt = TZipIn::New(FNm); }
320    else { FInPt = TFIn::New(FNm); }
321    switch(SsFmt) {
322      case ssfTabSep : SplitCh = '\t'; break;
323      case ssfCommaSep : SplitCh = ','; break;
324      case ssfSemicolonSep : SplitCh = ';'; break;
325      case ssfVBar : SplitCh = '|'; break;
326      case ssfSpaceSep : SplitCh = ' '; break;
327      case ssfWhiteSep: SplitCh = ' '; break;
328      default: FailR("Unknown separator character.");
329    }
330  }
331  TSsParser::TSsParser(const TStr& FNm, const char& Separator, const bool& _SkipLeadBlanks, const bool& _SkipCmt, const bool& _SkipEmptyFld) : SsFmt(ssfSpaceSep), 
332   SkipLeadBlanks(_SkipLeadBlanks), SkipCmt(_SkipCmt), SkipEmptyFld(_SkipEmptyFld), LineCnt(0), &bsol;*Bf(NULL),*/ SplitCh('\t'), LineStr(), FldV(), FInPt(NULL) {
333    if (TZipIn::IsZipExt(FNm.GetFExt())) { FInPt = TZipIn::New(FNm); }
334    else { FInPt = TFIn::New(FNm); }
335    SplitCh = Separator;
336  }
337  TSsParser::~TSsParser() {
338  }
339  bool TSsParser::NextSlow() { 
340    FldV.Clr(false);
341    LineStr.Clr();
342    FldV.Clr();
343    LineCnt++;
344    if (! FInPt->GetNextLn(LineStr)) { return false; }
345    if (SkipCmt && !LineStr.Empty() && LineStr[0]=='#') { return NextSlow(); }
346    char* cur = LineStr.CStr();
347    if (SkipLeadBlanks) { 
348      while (*cur && TCh::IsWs(*cur)) { cur++; }
349    }
350    char *last = cur;
351    while (*cur) {
352      if (SsFmt == ssfWhiteSep) { while (*cur && ! TCh::IsWs(*cur)) { cur++; } } 
353      else { while (*cur && *cur!=SplitCh) { cur++; } }
354      if (*cur == 0) { break; }
355      *cur = 0;  cur++;
356      FldV.Add(last);  last = cur;
357      if (SkipEmptyFld && strlen(FldV.Last())==0) { FldV.DelLast(); } 
358    }
359    if (*last != 0) { FldV.Add(last); }  
360    if (SkipEmptyFld && FldV.Empty()) { return NextSlow(); } 
361    return true; 
362  }
363  bool TSsParser::Next() { 
364    FldV.Clr(false);
365    LineStr.Clr();
366    FldV.Clr();
367    LineCnt++;
368    if (! FInPt->GetNextLnBf(LineStr)) { return false; }
369    if (SkipCmt && !LineStr.Empty() && LineStr[0]=='#') { return Next(); }
370    char* cur = LineStr.CStr();
371    if (SkipLeadBlanks) { 
372      while (*cur && TCh::IsWs(*cur)) { cur++; }
373    }
374    char *last = cur;
375    while (*cur) {
376      if (SsFmt == ssfWhiteSep) { while (*cur && ! TCh::IsWs(*cur)) { cur++; } } 
377      else { while (*cur && *cur!=SplitCh) { cur++; } }
378      if (*cur == 0) { break; }
379      *cur = 0;  cur++;
380      FldV.Add(last);  last = cur;
381      if (SkipEmptyFld && strlen(FldV.Last())==0) { FldV.DelLast(); } 
382    }
383    if (*last != 0) { FldV.Add(last); }  
384    if (SkipEmptyFld && FldV.Empty()) { return Next(); } 
385    return true; 
386  }
387  void TSsParser::ToLc() {
388    for (int f = 0; f < FldV.Len(); f++) {
389      for (char *c = FldV[f]; *c; c++) {
390        *c = tolower(*c); }
391    }
392  }
393  bool TSsParser::GetInt(const int& FldN, int& Val) const {
394    if (FldN >= Len()) { return false; }
395    int _Val = -1;
396    bool Minus=false;
397    const char *c = GetFld(FldN);
398    while (TCh::IsWs(*c)) { c++; }
399    if (*c=='-') { Minus=true; c++; }
400    if (! TCh::IsNum(*c)) { return false; }
401    _Val = TCh::GetNum(*c);  c++;
402    while (TCh::IsNum(*c)){ 
403      _Val = 10 * _Val + TCh::GetNum(*c); 
404      c++; 
405    }
406    if (Minus) { _Val = -_Val; }
407    if (*c != 0) { return false; }
408    Val = _Val;
409    return true;
410  }
411  bool TSsParser::GetUInt64(const int& FldN, uint64& Val) const {
412    if (FldN >= Len()) { return false; }
413    uint64 _Val=0;
414    const char *c = GetFld(FldN);
415    while (TCh::IsWs(*c)){ c++; }
416    if (*c == '+'){ c++; }
417    if (! TCh::IsNum(*c)) { return false; }
418    _Val = TCh::GetNum(*c); c++;
419    while (TCh::IsNum(*c)) {
420      _Val = 10*_Val + TCh::GetNum(*c);
421      c++;
422    }
423    if (*c != 0) { return false; }
424    Val = _Val;
425    return true;
426  }
427  bool TSsParser::GetFlt(const int& FldN, double& Val) const {
428    if (FldN >= Len()) { return false; }
429    const char *c = GetFld(FldN);
430    while (TCh::IsWs(*c)) { c++; }
431    if (*c=='+' || *c=='-') { c++; }
432    if (! TCh::IsNum(*c) && *c!='.') { return false; }
433    while (TCh::IsNum(*c)) { c++; }
434    if (*c == '.') {
435      c++;
436      while (TCh::IsNum(*c)) { c++; }
437    }
438    if (*c=='e' || *c == 'E') {
439      c++;
440      if (*c == '+' || *c == '-' ) { c++; }
441      if (! TCh::IsNum(*c)) { return false; }
442      while (TCh::IsNum(*c)) { c++; }
443    }
444    if (*c != 0) { return false; }
445    Val = atof(GetFld(FldN));
446    return true;
447  }
448  const char* TSsParser::DumpStr() const {
449    static TChA ChA(10*1024);
450    ChA.Clr();
451    for (int i = 0; i < FldV.Len(); i++) {
452      ChA += TStr::Fmt("  %d: '%s'\n", i, FldV[i]);
453    }
454    return ChA.CStr();
455  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-wmine.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-ss.cpp</div>
                </div>
                <div class="column column_space"><pre><code>176      if ((PrevDId!=-1)&&(PrevDId!=DId)){
177        if (WordStrV.Len()>=MnFq){
</pre></code></div>
                <div class="column column_space"><pre><code>166          if ((PrevX!=-1)&&(X!=PrevX)){
167            TNotify::OnNotify(Notify, ntWarn, "Number of fields is not the same!");}
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    