
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.033182503770739%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-NppDarkMode.h</h3>
            <pre><code>1  #pragma once
2  #include <windows.h>
3  #include "Common.h" 
4  namespace NppDarkMode
5  {
6  	struct Colors
<span onclick='openModal()' class='match'>7  	{
8  		COLORREF background = 0;
9  		COLORREF softerBackground = 0;
10  		COLORREF hotBackground = 0;
11  		COLORREF pureBackground = 0;
12  		COLORREF errorBackground = 0;
13  		COLORREF text = 0;
14  		COLORREF darkerText = 0;
15  		COLORREF disabledText = 0;
16  		COLORREF linkText = 0;
17  		COLORREF edge = 0;
</span>18  		COLORREF hotEdge = 0;
19  		COLORREF disabledEdge = 0;
20  	};
21  	struct Options
22  	{
23  		bool enable = false;
24  		bool enableMenubar = false;
25  		bool enablePlugin = false;
26  	};
27  	struct NppDarkModeParams
28  	{
29  		const wchar_t* _themeClassName = nullptr;
30  		bool _subclass = false;
31  		bool _theme = false;
32  	};
33  	enum class ToolTipsType
34  	{
35  		tooltip,
36  		toolbar,
37  		listview,
38  		treeview,
39  		tabbar
40  	};
41  	enum ColorTone {
42  		blackTone  = 0,
43  		redTone    = 1,
44  		greenTone  = 2,
45  		blueTone   = 3,
46  		purpleTone = 4,
47  		cyanTone   = 5,
48  		oliveTone  = 6,
49  		customizedTone = 32
50  	};
51  	enum class TreeViewStyle
52  	{
53  		classic = 0,
54  		light = 1,
55  		dark = 2
56  	};
57  	struct AdvOptDefaults
58  	{
59  		generic_string _xmlFileName;
60  		int _toolBarIconSet = -1;
61  		int _tabIconSet = -1;
62  		bool _tabUseTheme = false;
63  	};
64  	struct AdvancedOptions
65  	{
66  		bool _enableWindowsMode = false;
67  		NppDarkMode::AdvOptDefaults _darkDefaults{ L"DarkModeDefault.xml", 0, 2, false };
68  		NppDarkMode::AdvOptDefaults _lightDefaults{ L"", 4, 0, true };
69  	};
70  	void initDarkMode();				
71  	void refreshDarkMode(HWND hwnd, bool forceRefresh = false);	
72  	void initAdvancedOptions();
73  	bool isEnabled();
74  	bool isDarkMenuEnabled();
75  	bool isEnabledForPlugins();
76  	bool isExperimentalActive();
77  	bool isExperimentalSupported();
78  	bool isWindowsModeEnabled();
79  	void setWindowsMode(bool enable);
80  	generic_string getThemeName();
81  	void setThemeName(const generic_string& newThemeName);
82  	int getToolBarIconSet(bool useDark);
83  	void setToolBarIconSet(int state2Set, bool useDark);
84  	int getTabIconSet(bool useDark);
85  	void setTabIconSet(bool useAltIcons, bool useDark);
86  	bool useTabTheme();
87  	void setAdvancedOptions();
88  	bool isWindows10();
89  	bool isWindows11();
90  	DWORD getWindowsBuildNumber();
91  	COLORREF invertLightness(COLORREF c);
92  	COLORREF invertLightnessSofter(COLORREF c);
93  	double calculatePerceivedLighness(COLORREF c);
94  	void setDarkTone(ColorTone colorToneChoice);
95  	COLORREF getBackgroundColor();
96  	COLORREF getSofterBackgroundColor();
97  	COLORREF getHotBackgroundColor();
98  	COLORREF getDarkerBackgroundColor();
99  	COLORREF getErrorBackgroundColor();
100  	COLORREF getTextColor();
101  	COLORREF getDarkerTextColor();
102  	COLORREF getDisabledTextColor();
103  	COLORREF getLinkTextColor();
104  	COLORREF getEdgeColor();
105  	COLORREF getHotEdgeColor();
106  	COLORREF getDisabledEdgeColor();
107  	HBRUSH getBackgroundBrush();
108  	HBRUSH getDarkerBackgroundBrush();
109  	HBRUSH getSofterBackgroundBrush();
110  	HBRUSH getHotBackgroundBrush();
111  	HBRUSH getErrorBackgroundBrush();
112  	HBRUSH getEdgeBrush();
113  	HBRUSH getHotEdgeBrush();
114  	HBRUSH getDisabledEdgeBrush();
115  	HPEN getDarkerTextPen();
116  	HPEN getEdgePen();
117  	HPEN getHotEdgePen();
118  	HPEN getDisabledEdgePen();
119  	COLORREF getIndividualTabColour(int colourIndex, bool themeDependant, bool saturated);
120  	void setBackgroundColor(COLORREF c);
121  	void setSofterBackgroundColor(COLORREF c);
122  	void setHotBackgroundColor(COLORREF c);
123  	void setDarkerBackgroundColor(COLORREF c);
124  	void setErrorBackgroundColor(COLORREF c);
125  	void setTextColor(COLORREF c);
126  	void setDarkerTextColor(COLORREF c);
127  	void setDisabledTextColor(COLORREF c);
128  	void setLinkTextColor(COLORREF c);
129  	void setEdgeColor(COLORREF c);
130  	void setHotEdgeColor(COLORREF c);
131  	void setDisabledEdgeColor(COLORREF c);
132  	Colors getDarkModeDefaultColors();
133  	void changeCustomTheme(const Colors& colors);
134  	void handleSettingChange(HWND hwnd, LPARAM lParam, bool isFromBtn = false);
135  	bool isDarkModeReg();
136  	bool runUAHWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam, LRESULT* lr);
137  	void drawUAHMenuNCBottomLine(HWND hWnd);
138  	void initExperimentalDarkMode();
139  	void setDarkMode(bool useDark, bool fixDarkScrollbar);
140  	void allowDarkModeForApp(bool allow);
141  	bool allowDarkModeForWindow(HWND hWnd, bool allow);
142  	void setTitleBarThemeColor(HWND hWnd);
143  	void enableDarkScrollBarForWindowAndChildren(HWND hwnd);
144  	inline void paintRoundFrameRect(HDC hdc, const RECT rect, const HPEN hpen, int width = 0, int height = 0);
145  	void subclassButtonControl(HWND hwnd);
146  	void subclassGroupboxControl(HWND hwnd);
147  	void subclassTabControl(HWND hwnd);
148  	void subclassComboBoxControl(HWND hwnd);
149  	void subclassAndThemeButton(HWND hwnd, NppDarkModeParams p);
150  	void subclassAndThemeComboBox(HWND hwnd, NppDarkModeParams p);
151  	void subclassAndThemeListBoxOrEditControl(HWND hwnd, NppDarkModeParams p, bool isListBox);
152  	void subclassAndThemeListView(HWND hwnd, NppDarkModeParams p);
153  	void themeTreeView(HWND hwnd, NppDarkModeParams p);
154  	void themeToolbar(HWND hwnd, NppDarkModeParams p);
155  	void themeRichEdit(HWND hwnd, NppDarkModeParams p);
156  	void autoSubclassAndThemeChildControls(HWND hwndParent, bool subclass = true, bool theme = true);
157  	void autoThemeChildControls(HWND hwndParent);
158  	LRESULT darkToolBarNotifyCustomDraw(LPARAM lParam);
159  	LRESULT darkListViewNotifyCustomDraw(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, bool isPlugin);
160  	LRESULT darkTreeViewNotifyCustomDraw(LPARAM lParam);
161  	void autoSubclassAndThemePluginDockWindow(HWND hwnd);
162  	ULONG autoSubclassAndThemePlugin(HWND hwnd, ULONG dmFlags);
163  	void autoSubclassAndThemeWindowNotify(HWND hwnd);
164  	bool subclassTabUpDownControl(HWND hwnd);
165  	void setDarkTitleBar(HWND hwnd);
166  	void setDarkExplorerTheme(HWND hwnd);
167  	void setDarkScrollBar(HWND hwnd);
168  	void setDarkTooltips(HWND hwnd, ToolTipsType type);
169  	void setDarkLineAbovePanelToolbar(HWND hwnd);
170  	void setDarkListView(HWND hwnd);
171  	void disableVisualStyle(HWND hwnd, bool doDisable);
172  	void calculateTreeViewStyle();
173  	void setTreeViewStyle(HWND hwnd);
174  	bool isThemeDark();
175  	void setBorder(HWND hwnd, bool border = true);
176  	BOOL CALLBACK enumAutocompleteProc(HWND hwnd, LPARAM lParam);
177  	void setDarkAutoCompletion();
178  	LRESULT onCtlColor(HDC hdc);
179  	LRESULT onCtlColorSofter(HDC hdc);
180  	LRESULT onCtlColorDarker(HDC hdc);
181  	LRESULT onCtlColorError(HDC hdc);
182  	LRESULT onCtlColorDarkerBGStaticText(HDC hdc, bool isTextEnabled);
183  	INT_PTR onCtlColorListbox(WPARAM wParam, LPARAM lParam);
184  }
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-ratngs.h</h3>
            <pre><code>1  #ifndef RATNGS_H
2  #define RATNGS_H
3  #ifdef HAVE_CONFIG_H
4  #  include "config_auto.h" 
5  #endif
6  #include "clst.h"
7  #include "elst.h"
8  #ifndef DISABLED_LEGACY_ENGINE
9  #  include "fontinfo.h"
10  #endif 
11  #include "matrix.h"
12  #include "unicharset.h"
13  #include "werd.h"
14  #include <tesseract/unichar.h>
15  #include <cassert>
16  #include <cfloat> 
17  namespace tesseract {
18  class MATRIX;
19  struct TBLOB;
20  struct TWERD;
21  enum BlobChoiceClassifier {
22    BCC_STATIC_CLASSIFIER,  
23    BCC_ADAPTED_CLASSIFIER, 
24    BCC_SPECKLE_CLASSIFIER, 
25    BCC_AMBIG,              
26    BCC_FAKE,               
27  };
28  class BLOB_CHOICE : public ELIST_LINK {
29  public:
<span onclick='openModal()' class='match'>30    BLOB_CHOICE() {
31      unichar_id_ = UNICHAR_SPACE;
32      fontinfo_id_ = -1;
33      fontinfo_id2_ = -1;
34      rating_ = 10.0f;
35      certainty_ = -1.0f;
36      script_id_ = -1;
37      min_xheight_ = 0.0f;
38      max_xheight_ = 0.0f;
39      yshift_ = 0.0f;
40      classifier_ = BCC_FAKE;
</span>41    }
42    BLOB_CHOICE(UNICHAR_ID src_unichar_id, 
43                float src_rating,          
44                float src_cert,            
45                int script_id,             
46                float min_xheight,         
47                float max_xheight,         
48                float yshift,              
49                BlobChoiceClassifier c);   
50    BLOB_CHOICE(const BLOB_CHOICE &other);
51    ~BLOB_CHOICE() = default;
52    UNICHAR_ID unichar_id() const {
53      return unichar_id_;
54    }
55    float rating() const {
56      return rating_;
57    }
58    float certainty() const {
59      return certainty_;
60    }
61    int16_t fontinfo_id() const {
62      return fontinfo_id_;
63    }
64    int16_t fontinfo_id2() const {
65      return fontinfo_id2_;
66    }
67  #ifndef DISABLED_LEGACY_ENGINE
68    const std::vector<ScoredFont> &fonts() const {
69      return fonts_;
70    }
71    void set_fonts(const std::vector<ScoredFont> &fonts) {
72      fonts_ = fonts;
73      int score1 = 0, score2 = 0;
74      fontinfo_id_ = -1;
75      fontinfo_id2_ = -1;
76      for (auto &f : fonts_) {
77        if (f.score > score1) {
78          score2 = score1;
79          fontinfo_id2_ = fontinfo_id_;
80          score1 = f.score;
81          fontinfo_id_ = f.fontinfo_id;
82        } else if (f.score > score2) {
83          score2 = f.score;
84          fontinfo_id2_ = f.fontinfo_id;
85        }
86      }
87    }
88  #endif 
89    int script_id() const {
90      return script_id_;
91    }
92    const MATRIX_COORD &matrix_cell() {
93      return matrix_cell_;
94    }
95    float min_xheight() const {
96      return min_xheight_;
97    }
98    float max_xheight() const {
99      return max_xheight_;
100    }
101    float yshift() const {
102      return yshift_;
103    }
104    BlobChoiceClassifier classifier() const {
105      return classifier_;
106    }
107    bool IsAdapted() const {
108      return classifier_ == BCC_ADAPTED_CLASSIFIER;
109    }
110    bool IsClassified() const {
111      return classifier_ == BCC_STATIC_CLASSIFIER || classifier_ == BCC_ADAPTED_CLASSIFIER ||
112             classifier_ == BCC_SPECKLE_CLASSIFIER;
113    }
114    void set_unichar_id(UNICHAR_ID newunichar_id) {
115      unichar_id_ = newunichar_id;
116    }
117    void set_rating(float newrat) {
118      rating_ = newrat;
119    }
120    void set_certainty(float newrat) {
121      certainty_ = newrat;
122    }
123    void set_script(int newscript_id) {
124      script_id_ = newscript_id;
125    }
126    void set_matrix_cell(int col, int row) {
127      matrix_cell_.col = col;
128      matrix_cell_.row = row;
129    }
130    void set_classifier(BlobChoiceClassifier classifier) {
131      classifier_ = classifier;
132    }
133    static BLOB_CHOICE *deep_copy(const BLOB_CHOICE *src) {
134      auto *choice = new BLOB_CHOICE;
135      *choice = *src;
136      return choice;
137    }
138    bool PosAndSizeAgree(const BLOB_CHOICE &other, float x_height, bool debug) const;
139    void print(const UNICHARSET *unicharset) const {
140      tprintf("r%.2f c%.2f x[%g,%g]: %d %s",
141              static_cast<double>(rating_),
142              static_cast<double>(certainty_),
143              static_cast<double>(min_xheight_),
144              static_cast<double>(max_xheight_),
145              unichar_id_, (unicharset == nullptr) ? "" : unicharset->debug_str(unichar_id_).c_str());
146    }
147    void print_full() const {
148      print(nullptr);
149      tprintf(" script=%d, font1=%d, font2=%d, yshift=%g, classifier=%d\n", script_id_, fontinfo_id_,
150              fontinfo_id2_, static_cast<double>(yshift_), classifier_);
151    }
152    static int SortByRating(const void *p1, const void *p2) {
153      const BLOB_CHOICE *bc1 = *static_cast<const BLOB_CHOICE *const *>(p1);
154      const BLOB_CHOICE *bc2 = *static_cast<const BLOB_CHOICE *const *>(p2);
155      return (bc1->rating_ < bc2->rating_) ? -1 : 1;
156    }
157  private:
158    BLOB_CHOICE &operator=(const BLOB_CHOICE &other);
159    UNICHAR_ID unichar_id_; 
160  #ifndef DISABLED_LEGACY_ENGINE
161    std::vector<ScoredFont> fonts_;
162  #endif                   
163    int16_t fontinfo_id_;  
164    int16_t fontinfo_id2_; 
165    float rating_; 
166    float certainty_; 
167    int script_id_;
168    MATRIX_COORD matrix_cell_;
169    float min_xheight_;
170    float max_xheight_;
171    float yshift_;
172    BlobChoiceClassifier classifier_; 
173  };
174  ELISTIZEH(BLOB_CHOICE)
175  BLOB_CHOICE *FindMatchingChoice(UNICHAR_ID char_id, BLOB_CHOICE_LIST *bc_list);
176  enum PermuterType {
177    NO_PERM,           
178    PUNC_PERM,         
179    TOP_CHOICE_PERM,   
180    LOWER_CASE_PERM,   
181    UPPER_CASE_PERM,   
182    NGRAM_PERM,        
183    NUMBER_PERM,       
184    USER_PATTERN_PERM, 
185    SYSTEM_DAWG_PERM,  
186    DOC_DAWG_PERM,     
187    USER_DAWG_PERM,    
188    FREQ_DAWG_PERM,    
189    COMPOUND_PERM,     
190    NUM_PERMUTER_TYPES
191  };
192  enum ScriptPos { SP_NORMAL, SP_SUBSCRIPT, SP_SUPERSCRIPT, SP_DROPCAP };
193  const char *ScriptPosToString(ScriptPos script_pos);
194  class TESS_API WERD_CHOICE : public ELIST_LINK {
195  public:
196    static const float kBadRating;
197    static const char *permuter_name(uint8_t permuter);
198    WERD_CHOICE(const UNICHARSET *unicharset) : unicharset_(unicharset) {
199      this->init(8);
200    }
201    WERD_CHOICE(const UNICHARSET *unicharset, int reserved) : unicharset_(unicharset) {
202      this->init(reserved);
203    }
204    WERD_CHOICE(const char *src_string, const char *src_lengths, float src_rating,
205                float src_certainty, uint8_t src_permuter, const UNICHARSET &unicharset)
206        : unicharset_(&unicharset) {
207      this->init(src_string, src_lengths, src_rating, src_certainty, src_permuter);
208    }
209    WERD_CHOICE(const char *src_string, const UNICHARSET &unicharset);
210    WERD_CHOICE(const WERD_CHOICE &word) : ELIST_LINK(word), unicharset_(word.unicharset_) {
211      this->init(word.length());
212      this->operator=(word);
213    }
214    ~WERD_CHOICE();
215    const UNICHARSET *unicharset() const {
216      return unicharset_;
217    }
218    bool empty() const {
219      return length_ == 0;
220    }
221    inline unsigned length() const {
222      return length_;
223    }
224    float adjust_factor() const {
225      return adjust_factor_;
226    }
227    void set_adjust_factor(float factor) {
228      adjust_factor_ = factor;
229    }
230    inline const std::vector<UNICHAR_ID> &unichar_ids() const {
231      return unichar_ids_;
232    }
233    inline UNICHAR_ID unichar_id(unsigned index) const {
234      assert(index < length_);
235      return unichar_ids_[index];
236    }
237    inline unsigned state(unsigned index) const {
238      return state_[index];
239    }
240    ScriptPos BlobPosition(unsigned index) const {
241      if (index >= length_) {
242        return SP_NORMAL;
243      }
244      return script_pos_[index];
245    }
246    inline float rating() const {
247      return rating_;
248    }
249    inline float certainty() const {
250      return certainty_;
251    }
252    inline float certainty(unsigned index) const {
253      return certainties_[index];
254    }
255    inline float min_x_height() const {
256      return min_x_height_;
257    }
258    inline float max_x_height() const {
259      return max_x_height_;
260    }
261    inline void set_x_heights(float min_height, float max_height) {
262      min_x_height_ = min_height;
263      max_x_height_ = max_height;
264    }
265    inline uint8_t permuter() const {
266      return permuter_;
267    }
268    const char *permuter_name() const;
269    BLOB_CHOICE_LIST *blob_choices(unsigned index, MATRIX *ratings) const;
270    MATRIX_COORD MatrixCoord(unsigned index) const;
271    inline void set_unichar_id(UNICHAR_ID unichar_id, unsigned index) {
272      assert(index < length_);
273      unichar_ids_[index] = unichar_id;
274    }
275    bool dangerous_ambig_found() const {
276      return dangerous_ambig_found_;
277    }
278    void set_dangerous_ambig_found_(bool value) {
279      dangerous_ambig_found_ = value;
280    }
281    inline void set_rating(float new_val) {
282      rating_ = new_val;
283    }
284    inline void set_certainty(float new_val) {
285      certainty_ = new_val;
286    }
287    inline void set_permuter(uint8_t perm) {
288      permuter_ = perm;
289    }
290    inline void set_length(unsigned len) {
291      ASSERT_HOST(reserved_ >= len);
292      length_ = len;
293    }
294    inline void double_the_size() {
295      if (reserved_ > 0) {
296        reserved_ *= 2;
297      } else {
298        reserved_ = 1;
299      }
300      unichar_ids_.resize(reserved_);
301      script_pos_.resize(reserved_);
302      state_.resize(reserved_);
303      certainties_.resize(reserved_);
304    }
305    inline void init(unsigned reserved) {
306      reserved_ = reserved;
307      if (reserved > 0) {
308        unichar_ids_.resize(reserved);
309        script_pos_.resize(reserved);
310        state_.resize(reserved);
311        certainties_.resize(reserved);
312      } else {
313        unichar_ids_.clear();
314        script_pos_.clear();
315        state_.clear();
316        certainties_.clear();
317      }
318      length_ = 0;
319      adjust_factor_ = 1.0f;
320      rating_ = 0.0;
321      certainty_ = FLT_MAX;
322      min_x_height_ = 0.0f;
323      max_x_height_ = FLT_MAX;
324      permuter_ = NO_PERM;
325      unichars_in_script_order_ = false; 
326      dangerous_ambig_found_ = false;
327    }
328    void init(const char *src_string, const char *src_lengths, float src_rating, float src_certainty,
329              uint8_t src_permuter);
330    inline void make_bad() {
331      length_ = 0;
332      rating_ = kBadRating;
333      certainty_ = -FLT_MAX;
334    }
335    inline void append_unichar_id_space_allocated(UNICHAR_ID unichar_id, int blob_count, float rating,
336                                                  float certainty) {
337      assert(reserved_ > length_);
338      length_++;
339      this->set_unichar_id(unichar_id, blob_count, rating, certainty, length_ - 1);
340    }
341    void append_unichar_id(UNICHAR_ID unichar_id, int blob_count, float rating, float certainty);
342    inline void set_unichar_id(UNICHAR_ID unichar_id, int blob_count, float rating, float certainty,
343                               unsigned index) {
344      assert(index < length_);
345      unichar_ids_[index] = unichar_id;
346      state_[index] = blob_count;
347      certainties_[index] = certainty;
348      script_pos_[index] = SP_NORMAL;
349      rating_ += rating;
350      if (certainty < certainty_) {
351        certainty_ = certainty;
352      }
353    }
354    void set_blob_choice(unsigned index, int blob_count, const BLOB_CHOICE *blob_choice);
355    bool contains_unichar_id(UNICHAR_ID unichar_id) const;
356    void remove_unichar_ids(unsigned index, int num);
357    inline void remove_last_unichar_id() {
358      --length_;
359    }
360    inline void remove_unichar_id(unsigned index) {
361      this->remove_unichar_ids(index, 1);
362    }
363    bool has_rtl_unichar_id() const;
364    void reverse_and_mirror_unichar_ids();
365    void punct_stripped(unsigned *start_core, unsigned *end_core) const;
366    void GetNonSuperscriptSpan(int *start, int *end) const;
367    WERD_CHOICE shallow_copy(unsigned start, unsigned end) const;
368    void string_and_lengths(std::string *word_str, std::string *word_lengths_str) const;
369    std::string debug_string() const {
370      std::string word_str;
371      for (unsigned i = 0; i < length_; ++i) {
372        word_str += unicharset_->debug_str(unichar_ids_[i]);
373        word_str += " ";
374      }
375      return word_str;
376    }
377    bool ContainsAnyNonSpaceDelimited() const {
378      for (unsigned i = 0; i < length_; ++i) {
379        if (!unicharset_->IsSpaceDelimited(unichar_ids_[i])) {
380          return true;
381        }
382      }
383      return false;
384    }
385    bool IsAllSpaces() const {
386      for (unsigned i = 0; i < length_; ++i) {
387        if (unichar_ids_[i] != UNICHAR_SPACE) {
388          return false;
389        }
390      }
391      return true;
392    }
393    bool set_unichars_in_script_order(bool in_script_order) {
394      return unichars_in_script_order_ = in_script_order;
395    }
396    bool unichars_in_script_order() const {
397      return unichars_in_script_order_;
398    }
399    std::string &unichar_string() {
400      this->string_and_lengths(&unichar_string_, &unichar_lengths_);
401      return unichar_string_;
402    }
403    const std::string &unichar_string() const {
404      this->string_and_lengths(&unichar_string_, &unichar_lengths_);
405      return unichar_string_;
406    }
407    const std::string &unichar_lengths() const {
408      this->string_and_lengths(&unichar_string_, &unichar_lengths_);
409      return unichar_lengths_;
410    }
411    void SetScriptPositions(bool small_caps, TWERD *word, int debug = 0);
412    void SetAllScriptPositions(ScriptPos position);
413    static ScriptPos ScriptPositionOf(bool print_debug, const UNICHARSET &unicharset,
414                                      const TBOX &blob_box, UNICHAR_ID unichar_id);
415    int GetTopScriptID() const;
416    void UpdateStateForSplit(int blob_position);
417    unsigned TotalOfStates() const;
418    void print() const {
419      this->print("");
420    }
421    void print(const char *msg) const;
422    void print_state(const char *msg) const;
423    void DisplaySegmentation(TWERD *word);
424    WERD_CHOICE &operator+=(        
425        const WERD_CHOICE &second); 
426    WERD_CHOICE &operator=(const WERD_CHOICE &source);
427  private:
428    const UNICHARSET *unicharset_;
429    std::vector<UNICHAR_ID> unichar_ids_; 
430    std::vector<ScriptPos> script_pos_;   
431    std::vector<int> state_;              
432    std::vector<float> certainties_;      
433    unsigned reserved_;            
434    unsigned length_;              
435    float adjust_factor_;
436    float rating_; 
437    float certainty_; 
438    float min_x_height_;
439    float max_x_height_;
440    uint8_t permuter_; 
441    bool unichars_in_script_order_;
442    bool dangerous_ambig_found_;
443    mutable std::string unichar_string_;
444    mutable std::string unichar_lengths_;
445  };
446  ELISTIZEH(WERD_CHOICE)
447  using BLOB_CHOICE_LIST_VECTOR = std::vector<BLOB_CHOICE_LIST *>;
448  bool EqualIgnoringCaseAndTerminalPunct(const WERD_CHOICE &word1, const WERD_CHOICE &word2);
449  void print_ratings_list(const char *msg,                     
450                          BLOB_CHOICE_LIST *ratings,           
451                          const UNICHARSET &current_unicharset 
452  );
453  } 
454  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-NppDarkMode.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-ratngs.h</div>
                </div>
                <div class="column column_space"><pre><code>7  	{
8  		COLORREF background = 0;
9  		COLORREF softerBackground = 0;
10  		COLORREF hotBackground = 0;
11  		COLORREF pureBackground = 0;
12  		COLORREF errorBackground = 0;
13  		COLORREF text = 0;
14  		COLORREF darkerText = 0;
15  		COLORREF disabledText = 0;
16  		COLORREF linkText = 0;
17  		COLORREF edge = 0;
</pre></code></div>
                <div class="column column_space"><pre><code>30    BLOB_CHOICE() {
31      unichar_id_ = UNICHAR_SPACE;
32      fontinfo_id_ = -1;
33      fontinfo_id2_ = -1;
34      rating_ = 10.0f;
35      certainty_ = -1.0f;
36      script_id_ = -1;
37      min_xheight_ = 0.0f;
38      max_xheight_ = 0.0f;
39      yshift_ = 0.0f;
40      classifier_ = BCC_FAKE;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    