
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 37, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-openclwrapper.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include &quot;config_auto.h&quot;
3  #endif
4  #ifdef USE_OPENCL
5  #  ifdef _WIN32
6  #    include &lt;io.h&gt;
7  #    include &lt;windows.h&gt;
8  #  else
9  #    include &lt;sys/types.h&gt;
10  #    include &lt;unistd.h&gt;
11  #  endif
12  #  include &lt;cfloat&gt;
13  #  include &lt;ctime&gt; 
14  #  include &quot;oclkernels.h&quot;
15  #  include &quot;openclwrapper.h&quot;
16  #  include &quot;otsuthr.h&quot;
17  #  include &quot;thresholder.h&quot;
18  #  if defined(WIN32) || defined(__WIN32__) || defined(_WIN32) || defined(__CYGWIN__) || \
19        defined(__MINGW32__)
20  #    define ON_WINDOWS 1
21  #    define ON_APPLE 0
22  #  elif defined(__linux__)
23  #    define ON_WINDOWS 0
24  #    define ON_APPLE 0
25  #  elif defined(__APPLE__)
26  #    define ON_WINDOWS 0
27  #    define ON_APPLE 1
28  #  else
29  #    define ON_WINDOWS 0
30  #    define ON_APPLE 0
31  #  endif
32  #  if ON_APPLE
33  #    include &lt;mach/mach_time.h&gt;
34  #  endif
35  #  include &lt;cstdio&gt;
36  #  include &lt;cstdlib&gt;
37  #  include &lt;cstring&gt; 
38  #  include &lt;vector&gt;
39  #  include &quot;errcode.h&quot; 
40  #  include &quot;image.h&quot;   
41  namespace tesseract {
42  GPUEnv OpenclDevice::gpuEnv;
43  bool OpenclDevice::deviceIsSelected = false;
44  ds_device OpenclDevice::selectedDevice;
45  int OpenclDevice::isInited = 0;
46  static l_int32 MORPH_BC = ASYMMETRIC_MORPH_BC;
47  static const l_uint32 lmask32[] = {
48      0x80000000, 0xc0000000, 0xe0000000, 0xf0000000, 0xf8000000, 0xfc000000, 0xfe000000, 0xff000000,
49      0xff800000, 0xffc00000, 0xffe00000, 0xfff00000, 0xfff80000, 0xfffc0000, 0xfffe0000, 0xffff0000,
50      0xffff8000, 0xffffc000, 0xffffe000, 0xfffff000, 0xfffff800, 0xfffffc00, 0xfffffe00, 0xffffff00,
51      0xffffff80, 0xffffffc0, 0xffffffe0, 0xfffffff0, 0xfffffff8, 0xfffffffc, 0xfffffffe, 0xffffffff};
52  static const l_uint32 rmask32[] = {
53      0x00000001, 0x00000003, 0x00000007, 0x0000000f, 0x0000001f, 0x0000003f, 0x0000007f, 0x000000ff,
54      0x000001ff, 0x000003ff, 0x000007ff, 0x00000fff, 0x00001fff, 0x00003fff, 0x00007fff, 0x0000ffff,
55      0x0001ffff, 0x0003ffff, 0x0007ffff, 0x000fffff, 0x001fffff, 0x003fffff, 0x007fffff, 0x00ffffff,
56      0x01ffffff, 0x03ffffff, 0x07ffffff, 0x0fffffff, 0x1fffffff, 0x3fffffff, 0x7fffffff, 0xffffffff};
57  static cl_mem pixsCLBuffer, pixdCLBuffer,
58      pixdCLIntermediate;    
59  static cl_mem pixThBuffer; 
60  static cl_int clStatus;
61  static KernelEnv rEnv;
62  #  define DS_TAG_VERSION &quot;&lt;version&gt;&quot;
63  #  define DS_TAG_VERSION_END &quot;&lt;/version&gt;&quot;
64  #  define DS_TAG_DEVICE &quot;&lt;device&gt;&quot;
65  #  define DS_TAG_DEVICE_END &quot;&lt;/device&gt;&quot;
66  #  define DS_TAG_SCORE &quot;&lt;score&gt;&quot;
67  #  define DS_TAG_SCORE_END &quot;&lt;/score&gt;&quot;
68  #  define DS_TAG_DEVICE_TYPE &quot;&lt;type&gt;&quot;
69  #  define DS_TAG_DEVICE_TYPE_END &quot;&lt;/type&gt;&quot;
70  #  define DS_TAG_DEVICE_NAME &quot;&lt;name&gt;&quot;
71  #  define DS_TAG_DEVICE_NAME_END &quot;&lt;/name&gt;&quot;
72  #  define DS_TAG_DEVICE_DRIVER_VERSION &quot;&lt;driver&gt;&quot;
73  #  define DS_TAG_DEVICE_DRIVER_VERSION_END &quot;&lt;/driver&gt;&quot;
74  #  define DS_DEVICE_NATIVE_CPU_STRING &quot;native_cpu&quot;
75  #  define DS_DEVICE_NAME_LENGTH 256
76  enum ds_evaluation_type { DS_EVALUATE_ALL, DS_EVALUATE_NEW_ONLY };
77  struct ds_profile {
78    std::vector&lt;ds_device&gt; devices;
79    unsigned int numDevices;
80    const char *version;
81  };
82  enum ds_status {
83    DS_SUCCESS = 0,
84    DS_INVALID_PROFILE = 1000,
85    DS_MEMORY_ERROR,
86    DS_INVALID_PERF_EVALUATOR_TYPE,
87    DS_INVALID_PERF_EVALUATOR,
88    DS_PERF_EVALUATOR_ERROR,
89    DS_FILE_ERROR,
90    DS_UNKNOWN_DEVICE_TYPE,
91    DS_PROFILE_FILE_ERROR,
92    DS_SCORE_SERIALIZER_ERROR,
93    DS_SCORE_DESERIALIZER_ERROR
94  };
95  typedef ds_status (*ds_perf_evaluator)(ds_device *device, void *data);
96  typedef ds_status (*ds_score_release)(TessDeviceScore *score);
97  static ds_status releaseDSProfile(ds_profile *profile, ds_score_release sr) {
98    ds_status status = DS_SUCCESS;
99    if (profile != nullptr) {
100      if (sr != nullptr) {
101        unsigned int i;
102        for (i = 0; i &lt; profile-&gt;numDevices; i++) {
103          free(profile-&gt;devices[i].oclDeviceName);
104          free(profile-&gt;devices[i].oclDriverVersion);
105          status = sr(profile-&gt;devices[i].score);
106          if (status != DS_SUCCESS)
107            break;
108        }
109      }
110      delete profile;
111    }
112    return status;
113  }
114  static ds_status initDSProfile(ds_profile **p, const char *version) {
115    int numDevices;
116    cl_uint numPlatforms;
117    std::vector&lt;cl_platform_id&gt; platforms;
118    std::vector&lt;cl_device_id&gt; devices;
119    ds_status status = DS_SUCCESS;
120    unsigned int next;
121    unsigned int i;
122    if (p == nullptr)
123      return DS_INVALID_PROFILE;
124    ds_profile *profile = new ds_profile;
125    memset(profile, 0, sizeof(ds_profile));
126    clGetPlatformIDs(0, nullptr, &amp;numPlatforms);
127    if (numPlatforms &gt; 0) {
128      platforms.reserve(numPlatforms);
129      clGetPlatformIDs(numPlatforms, &amp;platforms[0], nullptr);
130    }
131    numDevices = 0;
132    for (i = 0; i &lt; numPlatforms; i++) {
133      cl_uint num;
134      clGetDeviceIDs(platforms[i], CL_DEVICE_TYPE_ALL, 0, nullptr, &amp;num);
135      numDevices += num;
136    }
137    if (numDevices &gt; 0) {
138      devices.reserve(numDevices);
139    }
140    profile-&gt;numDevices = numDevices + 1; 
141    profile-&gt;devices.reserve(profile-&gt;numDevices);
142    memset(&amp;profile-&gt;devices[0], 0, profile-&gt;numDevices * sizeof(ds_device));
143    next = 0;
144    for (i = 0; i &lt; numPlatforms; i++) {
145      cl_uint num;
146      unsigned j;
147      clGetDeviceIDs(platforms[i], CL_DEVICE_TYPE_ALL, numDevices, &amp;devices[0], &amp;num);
148      for (j = 0; j &lt; num; j++, next++) {
149        char buffer[DS_DEVICE_NAME_LENGTH];
150        size_t length;
151        profile-&gt;devices[next].type = DS_DEVICE_OPENCL_DEVICE;
152        profile-&gt;devices[next].oclDeviceID = devices[j];
153        clGetDeviceInfo(profile-&gt;devices[next].oclDeviceID, CL_DEVICE_NAME, DS_DEVICE_NAME_LENGTH,
154                        &amp;buffer, nullptr);
155        length = strlen(buffer);
156        profile-&gt;devices[next].oclDeviceName = (char *)malloc(length + 1);
157        memcpy(profile-&gt;devices[next].oclDeviceName, buffer, length + 1);
158        clGetDeviceInfo(profile-&gt;devices[next].oclDeviceID, CL_DRIVER_VERSION, DS_DEVICE_NAME_LENGTH,
159                        &amp;buffer, nullptr);
160        length = strlen(buffer);
161        profile-&gt;devices[next].oclDriverVersion = (char *)malloc(length + 1);
162        memcpy(profile-&gt;devices[next].oclDriverVersion, buffer, length + 1);
163      }
164    }
165    profile-&gt;devices[next].type = DS_DEVICE_NATIVE_CPU;
166    profile-&gt;version = version;
167    *p = profile;
168    return status;
169  }
170  static ds_status profileDevices(ds_profile *profile, const ds_evaluation_type type,
171                                  ds_perf_evaluator evaluator, void *evaluatorData,
172                                  unsigned int *numUpdates) {
173    ds_status status = DS_SUCCESS;
174    unsigned int i;
175    unsigned int updates = 0;
176    if (profile == nullptr) {
177      return DS_INVALID_PROFILE;
178    }
179    if (evaluator == nullptr) {
180      return DS_INVALID_PERF_EVALUATOR;
181    }
182    for (i = 0; i &lt; profile-&gt;numDevices; i++) {
183      ds_status evaluatorStatus;
184      switch (type) {
185        case DS_EVALUATE_NEW_ONLY:
186          if (profile-&gt;devices[i].score != nullptr)
187            break;
188        case DS_EVALUATE_ALL:
189          evaluatorStatus = evaluator(&amp;profile-&gt;devices[i], evaluatorData);
190          if (evaluatorStatus != DS_SUCCESS) {
191            status = evaluatorStatus;
192            return status;
193          }
194          updates++;
195          break;
196        default:
197          return DS_INVALID_PERF_EVALUATOR_TYPE;
198          break;
199      };
200    }
201    if (numUpdates)
202      *numUpdates = updates;
203    return status;
204  }
205  static const char *findString(const char *contentStart, const char *contentEnd,
206                                const char *string) {
207    size_t stringLength;
208    const char *currentPosition;
209    const char *found = nullptr;
210    stringLength = strlen(string);
211    currentPosition = contentStart;
212    for (currentPosition = contentStart; currentPosition &lt; contentEnd; currentPosition++) {
213      if (*currentPosition == string[0]) {
214        if (currentPosition + stringLength &lt; contentEnd) {
215          if (strncmp(currentPosition, string, stringLength) == 0) {
216            found = currentPosition;
217            break;
218          }
219        }
220      }
221    }
222    return found;
223  }
224  static ds_status readProFile(const char *fileName, char **content, size_t *contentSize) {
225    *contentSize = 0;
226    *content = nullptr;
227    ds_status status = DS_SUCCESS;
228    FILE *input = fopen(fileName, &quot;rb&quot;);
229    if (input == nullptr) {
230      status = DS_FILE_ERROR;
231    } else {
232      fseek(input, 0L, SEEK_END);
233      auto pos = std::ftell(input);
234      rewind(input);
235      if (pos &gt; 0) {
236        size_t size = pos;
237        char *binary = new char[size];
238        if (fread(binary, sizeof(char), size, input) != size) {
239          status = DS_FILE_ERROR;
240          delete[] binary;
241        } else {
242          *contentSize = size;
243          *content = binary;
244        }
245      }
246      fclose(input);
247    }
248    return status;
249  }
250  typedef ds_status (*ds_score_deserializer)(ds_device *device, const uint8_t *serializedScore,
251                                             unsigned int serializedScoreSize);
252  static ds_status readProfileFromFile(ds_profile *profile, ds_score_deserializer deserializer,
253                                       const char *file) {
254    ds_status status = DS_SUCCESS;
255    char *contentStart;
256    size_t contentSize;
257    if (profile == nullptr)
258      return DS_INVALID_PROFILE;
259    status = readProFile(file, &amp;contentStart, &amp;contentSize);
260    if (status == DS_SUCCESS) {
261      const char *currentPosition;
262      const char *dataStart;
263      const char *dataEnd;
264      const char *contentEnd = contentStart + contentSize;
265      currentPosition = contentStart;
266      dataStart = findString(currentPosition, contentEnd, DS_TAG_VERSION);
267      if (dataStart == nullptr) {
268        status = DS_PROFILE_FILE_ERROR;
269        goto cleanup;
270      }
271      dataStart += strlen(DS_TAG_VERSION);
272      dataEnd = findString(dataStart, contentEnd, DS_TAG_VERSION_END);
273      if (dataEnd == nullptr) {
274        status = DS_PROFILE_FILE_ERROR;
275        goto cleanup;
276      }
277      size_t versionStringLength = strlen(profile-&gt;version);
278      if (versionStringLength + dataStart != dataEnd ||
279          strncmp(profile-&gt;version, dataStart, versionStringLength) != 0) {
280        status = DS_PROFILE_FILE_ERROR;
281        goto cleanup;
282      }
283      currentPosition = dataEnd + strlen(DS_TAG_VERSION_END);
284      while (1) {
285        unsigned int i;
286        const char *deviceTypeStart;
287        const char *deviceTypeEnd;
288        ds_device_type deviceType;
289        const char *deviceNameStart;
290        const char *deviceNameEnd;
291        const char *deviceScoreStart;
292        const char *deviceScoreEnd;
293        const char *deviceDriverStart;
294        const char *deviceDriverEnd;
295        dataStart = findString(currentPosition, contentEnd, DS_TAG_DEVICE);
296        if (dataStart == nullptr) {
297          break;
298        }
299        dataStart += strlen(DS_TAG_DEVICE);
300        dataEnd = findString(dataStart, contentEnd, DS_TAG_DEVICE_END);
301        if (dataEnd == nullptr) {
302          status = DS_PROFILE_FILE_ERROR;
303          goto cleanup;
304        }
305        deviceTypeStart = findString(dataStart, contentEnd, DS_TAG_DEVICE_TYPE);
306        if (deviceTypeStart == nullptr) {
307          status = DS_PROFILE_FILE_ERROR;
308          goto cleanup;
309        }
310        deviceTypeStart += strlen(DS_TAG_DEVICE_TYPE);
311        deviceTypeEnd = findString(deviceTypeStart, contentEnd, DS_TAG_DEVICE_TYPE_END);
312        if (deviceTypeEnd == nullptr) {
313          status = DS_PROFILE_FILE_ERROR;
314          goto cleanup;
315        }
316        memcpy(&amp;deviceType, deviceTypeStart, sizeof(ds_device_type));
317        if (deviceType == DS_DEVICE_OPENCL_DEVICE) {
318          deviceNameStart = findString(dataStart, contentEnd, DS_TAG_DEVICE_NAME);
319          if (deviceNameStart == nullptr) {
320            status = DS_PROFILE_FILE_ERROR;
321            goto cleanup;
322          }
323          deviceNameStart += strlen(DS_TAG_DEVICE_NAME);
324          deviceNameEnd = findString(deviceNameStart, contentEnd, DS_TAG_DEVICE_NAME_END);
325          if (deviceNameEnd == nullptr) {
326            status = DS_PROFILE_FILE_ERROR;
327            goto cleanup;
328          }
329          deviceDriverStart = findString(dataStart, contentEnd, DS_TAG_DEVICE_DRIVER_VERSION);
330          if (deviceDriverStart == nullptr) {
331            status = DS_PROFILE_FILE_ERROR;
332            goto cleanup;
333          }
334          deviceDriverStart += strlen(DS_TAG_DEVICE_DRIVER_VERSION);
335          deviceDriverEnd =
336              findString(deviceDriverStart, contentEnd, DS_TAG_DEVICE_DRIVER_VERSION_END);
337          if (deviceDriverEnd == nullptr) {
338            status = DS_PROFILE_FILE_ERROR;
339            goto cleanup;
340          }
341          for (i = 0; i &lt; profile-&gt;numDevices; i++) {
342            if (profile-&gt;devices[i].type == DS_DEVICE_OPENCL_DEVICE) {
343              size_t actualDeviceNameLength;
344              size_t driverVersionLength;
345              actualDeviceNameLength = strlen(profile-&gt;devices[i].oclDeviceName);
346              driverVersionLength = strlen(profile-&gt;devices[i].oclDriverVersion);
347              if (deviceNameStart + actualDeviceNameLength == deviceNameEnd &amp;&amp;
348                  deviceDriverStart + driverVersionLength == deviceDriverEnd &amp;&amp;
349                  strncmp(profile-&gt;devices[i].oclDeviceName, deviceNameStart,
350                          actualDeviceNameLength) == 0 &amp;&amp;
351                  strncmp(profile-&gt;devices[i].oclDriverVersion, deviceDriverStart,
352                          driverVersionLength) == 0) {
353                deviceScoreStart = findString(dataStart, contentEnd, DS_TAG_SCORE);
354                deviceScoreStart += strlen(DS_TAG_SCORE);
355                deviceScoreEnd = findString(deviceScoreStart, contentEnd, DS_TAG_SCORE_END);
356                status = deserializer(&amp;profile-&gt;devices[i], (const unsigned char *)deviceScoreStart,
357                                      deviceScoreEnd - deviceScoreStart);
358                if (status != DS_SUCCESS) {
359                  goto cleanup;
360                }
361              }
362            }
363          }
364        } else if (deviceType == DS_DEVICE_NATIVE_CPU) {
365          for (i = 0; i &lt; profile-&gt;numDevices; i++) {
366            if (profile-&gt;devices[i].type == DS_DEVICE_NATIVE_CPU) {
367              deviceScoreStart = findString(dataStart, contentEnd, DS_TAG_SCORE);
368              if (deviceScoreStart == nullptr) {
369                status = DS_PROFILE_FILE_ERROR;
370                goto cleanup;
371              }
372              deviceScoreStart += strlen(DS_TAG_SCORE);
373              deviceScoreEnd = findString(deviceScoreStart, contentEnd, DS_TAG_SCORE_END);
374              status = deserializer(&amp;profile-&gt;devices[i], (const unsigned char *)deviceScoreStart,
375                                    deviceScoreEnd - deviceScoreStart);
376              if (status != DS_SUCCESS) {
377                goto cleanup;
378              }
379            }
380          }
381        }
382        currentPosition = dataEnd + strlen(DS_TAG_DEVICE_END);
383      }
384    }
385  cleanup:
386    delete[] contentStart;
387    return status;
388  }
389  typedef ds_status (*ds_score_serializer)(ds_device *device, uint8_t **serializedScore,
390                                           unsigned int *serializedScoreSize);
391  static ds_status writeProfileToFile(ds_profile *profile, ds_score_serializer serializer,
392                                      const char *file) {
393    ds_status status = DS_SUCCESS;
394    if (profile == nullptr)
395      return DS_INVALID_PROFILE;
396    FILE *profileFile = fopen(file, &quot;wb&quot;);
397    if (profileFile == nullptr) {
398      status = DS_FILE_ERROR;
399    } else {
400      unsigned int i;
401      fwrite(DS_TAG_VERSION, sizeof(char), strlen(DS_TAG_VERSION), profileFile);
402      fwrite(profile-&gt;version, sizeof(char), strlen(profile-&gt;version), profileFile);
403      fwrite(DS_TAG_VERSION_END, sizeof(char), strlen(DS_TAG_VERSION_END), profileFile);
404      fwrite(&quot;\n&quot;, sizeof(char), 1, profileFile);
405      for (i = 0; i &lt; profile-&gt;numDevices &amp;&amp; status == DS_SUCCESS; i++) {
406        uint8_t *serializedScore;
407        unsigned int serializedScoreSize;
408        fwrite(DS_TAG_DEVICE, sizeof(char), strlen(DS_TAG_DEVICE), profileFile);
409        fwrite(DS_TAG_DEVICE_TYPE, sizeof(char), strlen(DS_TAG_DEVICE_TYPE), profileFile);
410        fwrite(&amp;profile-&gt;devices[i].type, sizeof(ds_device_type), 1, profileFile);
411        fwrite(DS_TAG_DEVICE_TYPE_END, sizeof(char), strlen(DS_TAG_DEVICE_TYPE_END), profileFile);
412        switch (profile-&gt;devices[i].type) {
413          case DS_DEVICE_NATIVE_CPU: {
414          } break;
415          case DS_DEVICE_OPENCL_DEVICE: {
416            fwrite(DS_TAG_DEVICE_NAME, sizeof(char), strlen(DS_TAG_DEVICE_NAME), profileFile);
417            fwrite(profile-&gt;devices[i].oclDeviceName, sizeof(char),
418                   strlen(profile-&gt;devices[i].oclDeviceName), profileFile);
419            fwrite(DS_TAG_DEVICE_NAME_END, sizeof(char), strlen(DS_TAG_DEVICE_NAME_END), profileFile);
420            fwrite(DS_TAG_DEVICE_DRIVER_VERSION, sizeof(char), strlen(DS_TAG_DEVICE_DRIVER_VERSION),
421                   profileFile);
422            fwrite(profile-&gt;devices[i].oclDriverVersion, sizeof(char),
423                   strlen(profile-&gt;devices[i].oclDriverVersion), profileFile);
424            fwrite(DS_TAG_DEVICE_DRIVER_VERSION_END, sizeof(char),
425                   strlen(DS_TAG_DEVICE_DRIVER_VERSION_END), profileFile);
426          } break;
427          default:
428            status = DS_UNKNOWN_DEVICE_TYPE;
429            continue;
430        };
431        fwrite(DS_TAG_SCORE, sizeof(char), strlen(DS_TAG_SCORE), profileFile);
432        status = serializer(&amp;profile-&gt;devices[i], &amp;serializedScore, &amp;serializedScoreSize);
433        if (status == DS_SUCCESS &amp;&amp; serializedScore != nullptr &amp;&amp; serializedScoreSize &gt; 0) {
434          fwrite(serializedScore, sizeof(char), serializedScoreSize, profileFile);
435          delete[] serializedScore;
436        }
437        fwrite(DS_TAG_SCORE_END, sizeof(char), strlen(DS_TAG_SCORE_END), profileFile);
438        fwrite(DS_TAG_DEVICE_END, sizeof(char), strlen(DS_TAG_DEVICE_END), profileFile);
439        fwrite(&quot;\n&quot;, sizeof(char), 1, profileFile);
440      }
441      fclose(profileFile);
442    }
443    return status;
444  }
445  static void legalizeFileName(char *fileName) {
446    const char *invalidChars = &quot;/\?:*\&quot;&gt;&lt;| &quot;; 
447    for (unsigned i = 0; i &lt; strlen(invalidChars); i++) {
448      char invalidStr[4];
449      invalidStr[0] = invalidChars[i];
450      invalidStr[1] = &#x27;\0&#x27;;
451      for (char *pos = strstr(fileName, invalidStr); pos != nullptr;
452           pos = strstr(pos + 1, invalidStr)) {
453        pos[0] = &#x27;_&#x27;;
454      }
455    }
456  }
457  static void populateGPUEnvFromDevice(GPUEnv *gpuInfo, cl_device_id device) {
458    size_t size;
459    gpuInfo-&gt;mnIsUserCreated = 1;
460    gpuInfo-&gt;mpDevID = device;
461    gpuInfo-&gt;mpArryDevsID = new cl_device_id[1];
462    gpuInfo-&gt;mpArryDevsID[0] = gpuInfo-&gt;mpDevID;
463    clStatus = clGetDeviceInfo(gpuInfo-&gt;mpDevID, CL_DEVICE_TYPE, sizeof(cl_device_type),
464                               &amp;gpuInfo-&gt;mDevType, &amp;size);
465    CHECK_OPENCL(clStatus, &quot;populateGPUEnv::getDeviceInfo(TYPE)&quot;);
466    clStatus = clGetDeviceInfo(gpuInfo-&gt;mpDevID, CL_DEVICE_PLATFORM, sizeof(cl_platform_id),
467                               &amp;gpuInfo-&gt;mpPlatformID, &amp;size);
468    CHECK_OPENCL(clStatus, &quot;populateGPUEnv::getDeviceInfo(PLATFORM)&quot;);
469    cl_context_properties props[3];
470    props[0] = CL_CONTEXT_PLATFORM;
471    props[1] = (cl_context_properties)gpuInfo-&gt;mpPlatformID;
472    props[2] = 0;
473    gpuInfo-&gt;mpContext = clCreateContext(props, 1, &amp;gpuInfo-&gt;mpDevID, nullptr, nullptr, &amp;clStatus);
474    CHECK_OPENCL(clStatus, &quot;populateGPUEnv::createContext&quot;);
475    cl_command_queue_properties queueProperties = 0;
476    gpuInfo-&gt;mpCmdQueue =
477        clCreateCommandQueue(gpuInfo-&gt;mpContext, gpuInfo-&gt;mpDevID, queueProperties, &amp;clStatus);
478    CHECK_OPENCL(clStatus, &quot;populateGPUEnv::createCommandQueue&quot;);
479  }
480  int OpenclDevice::LoadOpencl() {
481  #  ifdef WIN32
482    HINSTANCE HOpenclDll = nullptr;
483    void *OpenclDll = nullptr;
484    OpenclDll = static_cast&lt;HINSTANCE&gt;(HOpenclDll);
485    OpenclDll = LoadLibrary(&quot;openCL.dll&quot;);
486    if (!static_cast&lt;HINSTANCE&gt;(OpenclDll)) {
487      fprintf(stderr, &quot;[OD] Load opencl.dll failed!\n&quot;);
488      FreeLibrary(static_cast&lt;HINSTANCE&gt;(OpenclDll));
489      return 0;
490    }
491    fprintf(stderr, &quot;[OD] Load opencl.dll successful!\n&quot;);
492  #  endif
493    return 1;
494  }
495  int OpenclDevice::SetKernelEnv(KernelEnv *envInfo) {
496    envInfo-&gt;mpkContext = gpuEnv.mpContext;
497    envInfo-&gt;mpkCmdQueue = gpuEnv.mpCmdQueue;
498    envInfo-&gt;mpkProgram = gpuEnv.mpArryPrograms[0];
499    return 1;
500  }
501  static cl_mem allocateZeroCopyBuffer(const KernelEnv &amp;rEnv, l_uint32 *hostbuffer, size_t nElements,
502                                       cl_mem_flags flags, cl_int *pStatus) {
503    cl_mem membuffer = clCreateBuffer(rEnv.mpkContext, (cl_mem_flags)(flags),
504                                      nElements * sizeof(l_uint32), hostbuffer, pStatus);
505    return membuffer;
506  }
507  static Image mapOutputCLBuffer(const KernelEnv &amp;rEnv, cl_mem clbuffer, Image pixd, Image pixs,
508                                int elements, cl_mem_flags flags, bool memcopy = false,
509                                bool sync = true) {
510    if (!pixd) {
511      if (memcopy) {
512        if ((pixd = pixCreateTemplate(pixs)) == nullptr)
513          tprintf(&quot;pixd not made\n&quot;);
514      } else {
515        if ((pixd = pixCreateHeader(pixGetWidth(pixs), pixGetHeight(pixs), pixGetDepth(pixs))) ==
516            nullptr)
517          tprintf(&quot;pixd not made\n&quot;);
518      }
519    }
520    l_uint32 *pValues =
521        (l_uint32 *)clEnqueueMapBuffer(rEnv.mpkCmdQueue, clbuffer, CL_TRUE, flags, 0,
522                                       elements * sizeof(l_uint32), 0, nullptr, nullptr, nullptr);
523    if (memcopy) {
524      memcpy(pixGetData(pixd), pValues, elements * sizeof(l_uint32));
525    } else {
526      pixSetData(pixd, pValues);
527    }
528    clEnqueueUnmapMemObject(rEnv.mpkCmdQueue, clbuffer, pValues, 0, nullptr, nullptr);
529    if (sync) {
530      clFinish(rEnv.mpkCmdQueue);
531    }
532    return pixd;
533  }
534  void OpenclDevice::releaseMorphCLBuffers() {
535    if (pixdCLIntermediate != nullptr)
536      clReleaseMemObject(pixdCLIntermediate);
537    if (pixsCLBuffer != nullptr)
538      clReleaseMemObject(pixsCLBuffer);
539    if (pixdCLBuffer != nullptr)
540      clReleaseMemObject(pixdCLBuffer);
541    if (pixThBuffer != nullptr)
542      clReleaseMemObject(pixThBuffer);
543    pixdCLIntermediate = pixsCLBuffer = pixdCLBuffer = pixThBuffer = nullptr;
544  }
545  int OpenclDevice::initMorphCLAllocations(l_int32 wpl, l_int32 h, Image pixs) {
546    SetKernelEnv(&amp;rEnv);
547    if (pixThBuffer != nullptr) {
548      pixsCLBuffer = allocateZeroCopyBuffer(rEnv, nullptr, wpl * h, CL_MEM_ALLOC_HOST_PTR, &amp;clStatus);
549      clStatus = clEnqueueCopyBuffer(rEnv.mpkCmdQueue, pixThBuffer, pixsCLBuffer, 0, 0,
550                                     sizeof(l_uint32) * wpl * h, 0, nullptr, nullptr);
551    } else {
552      l_uint32 *srcdata = reinterpret_cast&lt;l_uint32 *&gt;(malloc(wpl * h * sizeof(l_uint32)));
553      memcpy(srcdata, pixGetData(pixs), wpl * h * sizeof(l_uint32));
554      pixsCLBuffer = allocateZeroCopyBuffer(rEnv, srcdata, wpl * h, CL_MEM_USE_HOST_PTR, &amp;clStatus);
555    }
556    pixdCLBuffer = allocateZeroCopyBuffer(rEnv, nullptr, wpl * h, CL_MEM_ALLOC_HOST_PTR, &amp;clStatus);
557    pixdCLIntermediate =
558        allocateZeroCopyBuffer(rEnv, nullptr, wpl * h, CL_MEM_ALLOC_HOST_PTR, &amp;clStatus);
559    return (int)clStatus;
560  }
561  int OpenclDevice::InitEnv() {
562  #  ifdef SAL_WIN32
563    while (1) {
564      if (1 == LoadOpencl())
565        break;
566    }
567  #  endif
568    InitOpenclRunEnv_DeviceSelection(0);
569    return 1;
570  }
571  int OpenclDevice::ReleaseOpenclRunEnv() {
572    ReleaseOpenclEnv(&amp;gpuEnv);
573  #  ifdef SAL_WIN32
574    FreeOpenclDll();
575  #  endif
576    return 1;
577  }
578  inline int OpenclDevice::AddKernelConfig(int kCount, const char *kName) {
579    ASSERT_HOST(kCount &gt; 0);
580    ASSERT_HOST(strlen(kName) &lt; sizeof(gpuEnv.mArrykernelNames[kCount - 1]));
581    strcpy(gpuEnv.mArrykernelNames[kCount - 1], kName);
582    gpuEnv.mnKernelCount++;
583    return 0;
584  }
585  int OpenclDevice::RegistOpenclKernel() {
586    if (!gpuEnv.mnIsUserCreated)
587      memset(&amp;gpuEnv, 0, sizeof(gpuEnv));
588    gpuEnv.mnFileCount = 0; 
589    gpuEnv.mnKernelCount = 0UL;
590    AddKernelConfig(1, &quot;oclAverageSub1&quot;);
591    return 0;
592  }
593  int OpenclDevice::InitOpenclRunEnv_DeviceSelection(int argc) {
594    if (!isInited) {
595      ds_device bestDevice_DS = getDeviceSelection();
596      cl_device_id bestDevice = bestDevice_DS.oclDeviceID;
597      if (selectedDeviceIsOpenCL()) {
598        populateGPUEnvFromDevice(&amp;gpuEnv, bestDevice);
599        gpuEnv.mnFileCount = 0; 
600        gpuEnv.mnKernelCount = 0UL;
601        CompileKernelFile(&amp;gpuEnv, &quot;&quot;);
602      } else {
603      }
604      isInited = 1;
605    }
606    return 0;
607  }
608  OpenclDevice::OpenclDevice() {
609  }
610  OpenclDevice::~OpenclDevice() {
611  }
612  int OpenclDevice::ReleaseOpenclEnv(GPUEnv *gpuInfo) {
613    int i = 0;
614    int clStatus = 0;
615    if (!isInited) {
616      return 1;
617    }
618    for (i = 0; i &lt; gpuEnv.mnFileCount; i++) {
619      if (gpuEnv.mpArryPrograms[i]) {
620        clStatus = clReleaseProgram(gpuEnv.mpArryPrograms[i]);
621        CHECK_OPENCL(clStatus, &quot;clReleaseProgram&quot;);
622        gpuEnv.mpArryPrograms[i] = nullptr;
623      }
624    }
625    if (gpuEnv.mpCmdQueue) {
626      clReleaseCommandQueue(gpuEnv.mpCmdQueue);
627      gpuEnv.mpCmdQueue = nullptr;
628    }
629    if (gpuEnv.mpContext) {
630      clReleaseContext(gpuEnv.mpContext);
631      gpuEnv.mpContext = nullptr;
632    }
633    isInited = 0;
634    gpuInfo-&gt;mnIsUserCreated = 0;
635    delete[] gpuInfo-&gt;mpArryDevsID;
636    return 1;
637  }
638  int OpenclDevice::BinaryGenerated(const char *clFileName, FILE **fhandle) {
639    unsigned int i = 0;
640    cl_int clStatus;
641    int status = 0;
642    FILE *fd = nullptr;
643    char fileName[256];
644    char cl_name[128];
645    char deviceName[1024];
646    clStatus = clGetDeviceInfo(gpuEnv.mpArryDevsID[i], CL_DEVICE_NAME, sizeof(deviceName), deviceName,
647                               nullptr);
648    CHECK_OPENCL(clStatus, &quot;clGetDeviceInfo&quot;);
649    const char *str = strstr(clFileName, &quot;.cl&quot;);
650    memcpy(cl_name, clFileName, str - clFileName);
651    cl_name[str - clFileName] = &#x27;\0&#x27;;
652    snprintf(fileName, sizeof(fileName), &quot;%s-%s.bin&quot;, cl_name, deviceName);
653    legalizeFileName(fileName);
654    fd = fopen(fileName, &quot;rb&quot;);
655    status = (fd != nullptr) ? 1 : 0;
656    if (fd != nullptr) {
657      *fhandle = fd;
658    }
659    return status;
660  }
661  int OpenclDevice::CachedOfKernerPrg(const GPUEnv *gpuEnvCached, const char *clFileName) {
662    int i;
663    for (i = 0; i &lt; gpuEnvCached-&gt;mnFileCount; i++) {
664      if (strcasecmp(gpuEnvCached-&gt;mArryKnelSrcFile[i], clFileName) == 0) {
665        if (gpuEnvCached-&gt;mpArryPrograms[i] != nullptr) {
666          return 1;
667        }
668      }
669    }
670    return 0;
671  }
672  int OpenclDevice::WriteBinaryToFile(const char *fileName, const char *birary, size_t numBytes) {
673    FILE *output = nullptr;
674    output = fopen(fileName, &quot;wb&quot;);
675    if (output == nullptr) {
676      return 0;
677    }
678    fwrite(birary, sizeof(char), numBytes, output);
679    fclose(output);
680    return 1;
681  }
682  int OpenclDevice::GeneratBinFromKernelSource(cl_program program, const char *clFileName) {
683    unsigned int i = 0;
684    cl_int clStatus;
685    cl_uint numDevices;
686    clStatus =
687        clGetProgramInfo(program, CL_PROGRAM_NUM_DEVICES, sizeof(numDevices), &amp;numDevices, nullptr);
688    CHECK_OPENCL(clStatus, &quot;clGetProgramInfo&quot;);
689    std::vector&lt;cl_device_id&gt; mpArryDevsID(numDevices);
690    clStatus = clGetProgramInfo(program, CL_PROGRAM_DEVICES, sizeof(cl_device_id) * numDevices,
691                                &amp;mpArryDevsID[0], nullptr);
692    CHECK_OPENCL(clStatus, &quot;clGetProgramInfo&quot;);
693    std::vector&lt;size_t&gt; binarySizes(numDevices);
694    clStatus = clGetProgramInfo(program, CL_PROGRAM_BINARY_SIZES, sizeof(size_t) * numDevices,
695                                &amp;binarySizes[0], nullptr);
696    CHECK_OPENCL(clStatus, &quot;clGetProgramInfo&quot;);
697    std::vector&lt;char *&gt; binaries(numDevices);
698    for (i = 0; i &lt; numDevices; i++) {
699      if (binarySizes[i] != 0) {
700        binaries[i] = new char[binarySizes[i]];
701      } else {
702        binaries[i] = nullptr;
703      }
704    }
705    clStatus = clGetProgramInfo(program, CL_PROGRAM_BINARIES, sizeof(char *) * numDevices,
706                                &amp;binaries[0], nullptr);
707    CHECK_OPENCL(clStatus, &quot;clGetProgramInfo&quot;);
708    for (i = 0; i &lt; numDevices; i++) {
709      if (binarySizes[i] != 0) {
710        char fileName[256];
711        char cl_name[128];
712        char deviceName[1024];
713        clStatus =
714            clGetDeviceInfo(mpArryDevsID[i], CL_DEVICE_NAME, sizeof(deviceName), deviceName, nullptr);
715        CHECK_OPENCL(clStatus, &quot;clGetDeviceInfo&quot;);
716        const char *str = strstr(clFileName, &quot;.cl&quot;);
717        memcpy(cl_name, clFileName, str - clFileName);
718        cl_name[str - clFileName] = &#x27;\0&#x27;;
719        snprintf(fileName, sizeof(fileName), &quot;%s-%s.bin&quot;, cl_name, deviceName);
720        legalizeFileName(fileName);
721        if (!WriteBinaryToFile(fileName, binaries[i], binarySizes[i])) {
722          tprintf(&quot;[OD] write binary[%s] failed\n&quot;, fileName);
723          return 0;
724        } 
725        tprintf(&quot;[OD] write binary[%s] successfully\n&quot;, fileName);
726      }
727    }
728    for (i = 0; i &lt; numDevices; i++) {
729      delete[] binaries[i];
730    }
731    return 1;
732  }
733  int OpenclDevice::CompileKernelFile(GPUEnv *gpuInfo, const char *buildOption) {
734    cl_int clStatus = 0;
735    const char *source;
736    size_t source_size[1];
737    int binary_status, binaryExisted, idx;
738    cl_uint numDevices;
739    FILE *fd, *fd1;
740    const char *filename = &quot;kernel.cl&quot;;
741    if (CachedOfKernerPrg(gpuInfo, filename) == 1) {
742      return 1;
743    }
744    idx = gpuInfo-&gt;mnFileCount;
745    source = kernel_src;
746    source_size[0] = strlen(source);
747    binaryExisted = 0;
748    binaryExisted = BinaryGenerated(filename, &amp;fd); 
749    if (binaryExisted == 1) {
750      clStatus = clGetContextInfo(gpuInfo-&gt;mpContext, CL_CONTEXT_NUM_DEVICES, sizeof(numDevices),
751                                  &amp;numDevices, nullptr);
752      CHECK_OPENCL(clStatus, &quot;clGetContextInfo&quot;);
753      std::vector&lt;cl_device_id&gt; mpArryDevsID(numDevices);
754      bool b_error = fseek(fd, 0, SEEK_END) &lt; 0;
755      auto pos = std::ftell(fd);
756      b_error |= (pos &lt;= 0);
757      size_t length = pos;
758      b_error |= fseek(fd, 0, SEEK_SET) &lt; 0;
759      if (b_error) {
760        fclose(fd);
761        return 0;
762      }
763      std::vector&lt;uint8_t&gt; binary(length + 2);
764      memset(&amp;binary[0], 0, length + 2);
765      b_error |= fread(&amp;binary[0], 1, length, fd) != length;
766      fclose(fd);
767      fd = nullptr;
768      clStatus = clGetContextInfo(gpuInfo-&gt;mpContext, CL_CONTEXT_DEVICES,
769                                  sizeof(cl_device_id) * numDevices, &amp;mpArryDevsID[0], nullptr);
770      CHECK_OPENCL(clStatus, &quot;clGetContextInfo&quot;);
771      const uint8_t *c_binary = &amp;binary[0];
772      gpuInfo-&gt;mpArryPrograms[idx] =
773          clCreateProgramWithBinary(gpuInfo-&gt;mpContext, numDevices, &amp;mpArryDevsID[0], &amp;length,
774                                    &amp;c_binary, &amp;binary_status, &amp;clStatus);
775      CHECK_OPENCL(clStatus, &quot;clCreateProgramWithBinary&quot;);
776    } else {
777      gpuInfo-&gt;mpArryPrograms[idx] =
778          clCreateProgramWithSource(gpuInfo-&gt;mpContext, 1, &amp;source, source_size, &amp;clStatus);
779      CHECK_OPENCL(clStatus, &quot;clCreateProgramWithSource&quot;);
780    }
781    if (gpuInfo-&gt;mpArryPrograms[idx] == (cl_program) nullptr) {
782      return 0;
783    }
784    if (!gpuInfo-&gt;mnIsUserCreated) {
785      clStatus = clBuildProgram(gpuInfo-&gt;mpArryPrograms[idx], 1, gpuInfo-&gt;mpArryDevsID, buildOption,
786                                nullptr, nullptr);
787    } else {
788      clStatus = clBuildProgram(gpuInfo-&gt;mpArryPrograms[idx], 1, &amp;(gpuInfo-&gt;mpDevID), buildOption,
789                                nullptr, nullptr);
790    }
791    if (clStatus != CL_SUCCESS) {
792      tprintf(&quot;BuildProgram error!\n&quot;);
793      size_t length;
794      if (!gpuInfo-&gt;mnIsUserCreated) {
795        clStatus = clGetProgramBuildInfo(gpuInfo-&gt;mpArryPrograms[idx], gpuInfo-&gt;mpArryDevsID[0],
796                                         CL_PROGRAM_BUILD_LOG, 0, nullptr, &amp;length);
797      } else {
798        clStatus = clGetProgramBuildInfo(gpuInfo-&gt;mpArryPrograms[idx], gpuInfo-&gt;mpDevID,
799                                         CL_PROGRAM_BUILD_LOG, 0, nullptr, &amp;length);
800      }
801      if (clStatus != CL_SUCCESS) {
802        tprintf(&quot;opencl create build log fail\n&quot;);
803        return 0;
804      }
805      std::vector&lt;char&gt; buildLog(length);
806      if (!gpuInfo-&gt;mnIsUserCreated) {
807        clStatus = clGetProgramBuildInfo(gpuInfo-&gt;mpArryPrograms[idx], gpuInfo-&gt;mpArryDevsID[0],
808                                         CL_PROGRAM_BUILD_LOG, length, &amp;buildLog[0], &amp;length);
809      } else {
810        clStatus = clGetProgramBuildInfo(gpuInfo-&gt;mpArryPrograms[idx], gpuInfo-&gt;mpDevID,
811                                         CL_PROGRAM_BUILD_LOG, length, &amp;buildLog[0], &amp;length);
812      }
813      if (clStatus != CL_SUCCESS) {
814        tprintf(&quot;opencl program build info fail\n&quot;);
815        return 0;
816      }
817      fd1 = fopen(&quot;kernel-build.log&quot;, &quot;w+&quot;);
818      if (fd1 != nullptr) {
819        fwrite(&amp;buildLog[0], sizeof(char), length, fd1);
820        fclose(fd1);
821      }
822      return 0;
823    }
824    strcpy(gpuInfo-&gt;mArryKnelSrcFile[idx], filename);
825    if (binaryExisted == 0) {
826      GeneratBinFromKernelSource(gpuInfo-&gt;mpArryPrograms[idx], filename);
827    }
828    gpuInfo-&gt;mnFileCount += 1;
829    return 1;
830  }
831  l_uint32 *OpenclDevice::pixReadFromTiffKernel(l_uint32 *tiffdata, l_int32 w, l_int32 h, l_int32 wpl,
832                                                l_uint32 *line) {
833    cl_int clStatus;
834    KernelEnv rEnv;
835    size_t globalThreads[2];
836    size_t localThreads[2];
837    int gsize;
838    cl_mem valuesCl;
839    cl_mem outputCl;
840    gsize = (w + GROUPSIZE_X - 1) / GROUPSIZE_X * GROUPSIZE_X;
841    globalThreads[0] = gsize;
842    gsize = (h + GROUPSIZE_Y - 1) / GROUPSIZE_Y * GROUPSIZE_Y;
843    globalThreads[1] = gsize;
844    localThreads[0] = GROUPSIZE_X;
845    localThreads[1] = GROUPSIZE_Y;
846    SetKernelEnv(&amp;rEnv);
847    l_uint32 *pResult = (l_uint32 *)malloc(w * h * sizeof(l_uint32));
848    rEnv.mpkKernel = clCreateKernel(rEnv.mpkProgram, &quot;composeRGBPixel&quot;, &amp;clStatus);
849    CHECK_OPENCL(clStatus, &quot;clCreateKernel composeRGBPixel&quot;);
850    valuesCl = allocateZeroCopyBuffer(rEnv, tiffdata, w * h, CL_MEM_READ_ONLY | CL_MEM_USE_HOST_PTR,
851                                      &amp;clStatus);
852    outputCl = allocateZeroCopyBuffer(rEnv, pResult, w * h, CL_MEM_WRITE_ONLY | CL_MEM_USE_HOST_PTR,
853                                      &amp;clStatus);
854    clStatus = clSetKernelArg(rEnv.mpkKernel, 0, sizeof(cl_mem), &amp;valuesCl);
855    CHECK_OPENCL(clStatus, &quot;clSetKernelArg&quot;);
856    clStatus = clSetKernelArg(rEnv.mpkKernel, 1, sizeof(w), &amp;w);
857    CHECK_OPENCL(clStatus, &quot;clSetKernelArg&quot;);
858    clStatus = clSetKernelArg(rEnv.mpkKernel, 2, sizeof(h), &amp;h);
859    CHECK_OPENCL(clStatus, &quot;clSetKernelArg&quot;);
860    clStatus = clSetKernelArg(rEnv.mpkKernel, 3, sizeof(wpl), &amp;wpl);
861    CHECK_OPENCL(clStatus, &quot;clSetKernelArg&quot;);
862    clStatus = clSetKernelArg(rEnv.mpkKernel, 4, sizeof(cl_mem), &amp;outputCl);
863    CHECK_OPENCL(clStatus, &quot;clSetKernelArg&quot;);
864    clStatus = clEnqueueNDRangeKernel(rEnv.mpkCmdQueue, rEnv.mpkKernel, 2, nullptr, globalThreads,
865                                      localThreads, 0, nullptr, nullptr);
866    CHECK_OPENCL(clStatus, &quot;clEnqueueNDRangeKernel&quot;);
867    void *ptr = clEnqueueMapBuffer(rEnv.mpkCmdQueue, outputCl, CL_TRUE, CL_MAP_READ, 0,
868                                   w * h * sizeof(l_uint32), 0, nullptr, nullptr, &amp;clStatus);
869    CHECK_OPENCL(clStatus, &quot;clEnqueueMapBuffer outputCl&quot;);
870    clEnqueueUnmapMemObject(rEnv.mpkCmdQueue, outputCl, ptr, 0, nullptr, nullptr);
871    clFinish(rEnv.mpkCmdQueue);
872    return pResult;
873  }
874  static cl_int pixDilateCL_55(l_int32 wpl, l_int32 h) {
875    size_t globalThreads[2];
876    cl_mem pixtemp;
877    cl_int status;
878    int gsize;
879    size_t localThreads[2];
880    gsize = (wpl * h + GROUPSIZE_HMORX - 1) / GROUPSIZE_HMORX * GROUPSIZE_HMORX;
881    globalThreads[0] = gsize;
882    globalThreads[1] = GROUPSIZE_HMORY;
883    localThreads[0] = GROUPSIZE_HMORX;
884    localThreads[1] = GROUPSIZE_HMORY;
885    rEnv.mpkKernel = clCreateKernel(rEnv.mpkProgram, &quot;morphoDilateHor_5x5&quot;, &amp;status);
886    CHECK_OPENCL(status, &quot;clCreateKernel morphoDilateHor_5x5&quot;);
887    status = clSetKernelArg(rEnv.mpkKernel, 0, sizeof(cl_mem), &amp;pixsCLBuffer);
888    status = clSetKernelArg(rEnv.mpkKernel, 1, sizeof(cl_mem), &amp;pixdCLBuffer);
889    status = clSetKernelArg(rEnv.mpkKernel, 2, sizeof(wpl), &amp;wpl);
890    status = clSetKernelArg(rEnv.mpkKernel, 3, sizeof(h), &amp;h);
891    status = clEnqueueNDRangeKernel(rEnv.mpkCmdQueue, rEnv.mpkKernel, 2, nullptr, globalThreads,
892                                    localThreads, 0, nullptr, nullptr);
893    pixtemp = pixsCLBuffer;
894    pixsCLBuffer = pixdCLBuffer;
895    pixdCLBuffer = pixtemp;
896    gsize = (wpl + GROUPSIZE_X - 1) / GROUPSIZE_X * GROUPSIZE_X;
897    globalThreads[0] = gsize;
898    gsize = (h + GROUPSIZE_Y - 1) / GROUPSIZE_Y * GROUPSIZE_Y;
899    globalThreads[1] = gsize;
900    localThreads[0] = GROUPSIZE_X;
901    localThreads[1] = GROUPSIZE_Y;
902    rEnv.mpkKernel = clCreateKernel(rEnv.mpkProgram, &quot;morphoDilateVer_5x5&quot;, &amp;status);
903    CHECK_OPENCL(status, &quot;clCreateKernel morphoDilateVer_5x5&quot;);
904    status = clSetKernelArg(rEnv.mpkKernel, 0, sizeof(cl_mem), &amp;pixsCLBuffer);
905    status = clSetKernelArg(rEnv.mpkKernel, 1, sizeof(cl_mem), &amp;pixdCLBuffer);
906    status = clSetKernelArg(rEnv.mpkKernel, 2, sizeof(wpl), &amp;wpl);
907    status = clSetKernelArg(rEnv.mpkKernel, 3, sizeof(h), &amp;h);
908    status = clEnqueueNDRangeKernel(rEnv.mpkCmdQueue, rEnv.mpkKernel, 2, nullptr, globalThreads,
909                                    localThreads, 0, nullptr, nullptr);
910    return status;
911  }
912  static cl_int pixErodeCL_55(l_int32 wpl, l_int32 h) {
913    size_t globalThreads[2];
914    cl_mem pixtemp;
915    cl_int status;
916    int gsize;
917    l_uint32 fwmask, lwmask;
918    size_t localThreads[2];
919    lwmask = lmask32[31 - 2];
920    fwmask = rmask32[31 - 2];
921    gsize = (wpl * h + GROUPSIZE_HMORX - 1) / GROUPSIZE_HMORX * GROUPSIZE_HMORX;
922    globalThreads[0] = gsize;
923    globalThreads[1] = GROUPSIZE_HMORY;
924    localThreads[0] = GROUPSIZE_HMORX;
925    localThreads[1] = GROUPSIZE_HMORY;
926    rEnv.mpkKernel = clCreateKernel(rEnv.mpkProgram, &quot;morphoErodeHor_5x5&quot;, &amp;status);
927    CHECK_OPENCL(status, &quot;clCreateKernel morphoErodeHor_5x5&quot;);
928    status = clSetKernelArg(rEnv.mpkKernel, 0, sizeof(cl_mem), &amp;pixsCLBuffer);
929    status = clSetKernelArg(rEnv.mpkKernel, 1, sizeof(cl_mem), &amp;pixdCLBuffer);
930    status = clSetKernelArg(rEnv.mpkKernel, 2, sizeof(wpl), &amp;wpl);
931    status = clSetKernelArg(rEnv.mpkKernel, 3, sizeof(h), &amp;h);
932    status = clEnqueueNDRangeKernel(rEnv.mpkCmdQueue, rEnv.mpkKernel, 2, nullptr, globalThreads,
933                                    localThreads, 0, nullptr, nullptr);
934    pixtemp = pixsCLBuffer;
935    pixsCLBuffer = pixdCLBuffer;
936    pixdCLBuffer = pixtemp;
937    gsize = (wpl + GROUPSIZE_X - 1) / GROUPSIZE_X * GROUPSIZE_X;
938    globalThreads[0] = gsize;
939    gsize = (h + GROUPSIZE_Y - 1) / GROUPSIZE_Y * GROUPSIZE_Y;
940    globalThreads[1] = gsize;
941    localThreads[0] = GROUPSIZE_X;
942    localThreads[1] = GROUPSIZE_Y;
943    rEnv.mpkKernel = clCreateKernel(rEnv.mpkProgram, &quot;morphoErodeVer_5x5&quot;, &amp;status);
944    CHECK_OPENCL(status, &quot;clCreateKernel morphoErodeVer_5x5&quot;);
945    status = clSetKernelArg(rEnv.mpkKernel, 0, sizeof(cl_mem), &amp;pixsCLBuffer);
946    status = clSetKernelArg(rEnv.mpkKernel, 1, sizeof(cl_mem), &amp;pixdCLBuffer);
947    status = clSetKernelArg(rEnv.mpkKernel, 2, sizeof(wpl), &amp;wpl);
948    status = clSetKernelArg(rEnv.mpkKernel, 3, sizeof(h), &amp;h);
949    status = clSetKernelArg(rEnv.mpkKernel, 4, sizeof(fwmask), &amp;fwmask);
950    status = clSetKernelArg(rEnv.mpkKernel, 5, sizeof(lwmask), &amp;lwmask);
951    status = clEnqueueNDRangeKernel(rEnv.mpkCmdQueue, rEnv.mpkKernel, 2, nullptr, globalThreads,
952                                    localThreads, 0, nullptr, nullptr);
953    return status;
954  }
955  static cl_int pixDilateCL(l_int32 hsize, l_int32 vsize, l_int32 wpl, l_int32 h) {
956    l_int32 xp, yp, xn, yn;
957    SEL *sel;
958    size_t globalThreads[2];
959    cl_mem pixtemp;
960    cl_int status = 0;
961    int gsize;
962    size_t localThreads[2];
963    char isEven;
964    OpenclDevice::SetKernelEnv(&amp;rEnv);
965    if (hsize == 5 &amp;&amp; vsize == 5) {
966      status = pixDilateCL_55(wpl, h);
967      return status;
968    }
969    sel = selCreateBrick(vsize, hsize, vsize / 2, hsize / 2, SEL_HIT);
970    selFindMaxTranslations(sel, &amp;xp, &amp;yp, &amp;xn, &amp;yn);
971    selDestroy(&amp;sel);
972    gsize = (wpl + GROUPSIZE_X - 1) / GROUPSIZE_X * GROUPSIZE_X;
973    globalThreads[0] = gsize;
974    gsize = (h + GROUPSIZE_Y - 1) / GROUPSIZE_Y * GROUPSIZE_Y;
975    globalThreads[1] = gsize;
976    localThreads[0] = GROUPSIZE_X;
977    localThreads[1] = GROUPSIZE_Y;
978    if (xp &gt; 31 || xn &gt; 31) {
979      rEnv.mpkKernel = clCreateKernel(rEnv.mpkProgram, &quot;morphoDilateHor&quot;, &amp;status);
980      CHECK_OPENCL(status, &quot;clCreateKernel morphoDilateHor&quot;);
981      status = clSetKernelArg(rEnv.mpkKernel, 0, sizeof(cl_mem), &amp;pixsCLBuffer);
982      status = clSetKernelArg(rEnv.mpkKernel, 1, sizeof(cl_mem), &amp;pixdCLBuffer);
983      status = clSetKernelArg(rEnv.mpkKernel, 2, sizeof(xp), &amp;xp);
984      status = clSetKernelArg(rEnv.mpkKernel, 3, sizeof(xn), &amp;xn);
985      status = clSetKernelArg(rEnv.mpkKernel, 4, sizeof(wpl), &amp;wpl);
986      status = clSetKernelArg(rEnv.mpkKernel, 5, sizeof(h), &amp;h);
987      status = clEnqueueNDRangeKernel(rEnv.mpkCmdQueue, rEnv.mpkKernel, 2, nullptr, globalThreads,
988                                      localThreads, 0, nullptr, nullptr);
989      if (yp &gt; 0 || yn &gt; 0) {
990        pixtemp = pixsCLBuffer;
991        pixsCLBuffer = pixdCLBuffer;
992        pixdCLBuffer = pixtemp;
993      }
994    } else if (xp &gt; 0 || xn &gt; 0) {
995      rEnv.mpkKernel = clCreateKernel(rEnv.mpkProgram, &quot;morphoDilateHor_32word&quot;, &amp;status);
996      CHECK_OPENCL(status, &quot;clCreateKernel morphoDilateHor_32word&quot;);
997      isEven = (xp != xn);
998      status = clSetKernelArg(rEnv.mpkKernel, 0, sizeof(cl_mem), &amp;pixsCLBuffer);
999      status = clSetKernelArg(rEnv.mpkKernel, 1, sizeof(cl_mem), &amp;pixdCLBuffer);
1000      status = clSetKernelArg(rEnv.mpkKernel, 2, sizeof(xp), &amp;xp);
1001      status = clSetKernelArg(rEnv.mpkKernel, 3, sizeof(wpl), &amp;wpl);
1002      status = clSetKernelArg(rEnv.mpkKernel, 4, sizeof(h), &amp;h);
1003      status = clSetKernelArg(rEnv.mpkKernel, 5, sizeof(isEven), &amp;isEven);
1004      status = clEnqueueNDRangeKernel(rEnv.mpkCmdQueue, rEnv.mpkKernel, 2, nullptr, globalThreads,
1005                                      localThreads, 0, nullptr, nullptr);
1006      if (yp &gt; 0 || yn &gt; 0) {
1007        pixtemp = pixsCLBuffer;
1008        pixsCLBuffer = pixdCLBuffer;
1009        pixdCLBuffer = pixtemp;
1010      }
1011    }
1012    if (yp &gt; 0 || yn &gt; 0) {
1013      rEnv.mpkKernel = clCreateKernel(rEnv.mpkProgram, &quot;morphoDilateVer&quot;, &amp;status);
1014      CHECK_OPENCL(status, &quot;clCreateKernel morphoDilateVer&quot;);
1015      status = clSetKernelArg(rEnv.mpkKernel, 0, sizeof(cl_mem), &amp;pixsCLBuffer);
1016      status = clSetKernelArg(rEnv.mpkKernel, 1, sizeof(cl_mem), &amp;pixdCLBuffer);
1017      status = clSetKernelArg(rEnv.mpkKernel, 2, sizeof(yp), &amp;yp);
1018      status = clSetKernelArg(rEnv.mpkKernel, 3, sizeof(wpl), &amp;wpl);
1019      status = clSetKernelArg(rEnv.mpkKernel, 4, sizeof(h), &amp;h);
1020      status = clSetKernelArg(rEnv.mpkKernel, 5, sizeof(yn), &amp;yn);
1021      status = clEnqueueNDRangeKernel(rEnv.mpkCmdQueue, rEnv.mpkKernel, 2, nullptr, globalThreads,
1022                                      localThreads, 0, nullptr, nullptr);
1023    }
1024    return status;
1025  }
1026  static cl_int pixErodeCL(l_int32 hsize, l_int32 vsize, l_uint32 wpl, l_uint32 h) {
1027    l_int32 xp, yp, xn, yn;
1028    SEL *sel;
1029    size_t globalThreads[2];
1030    size_t localThreads[2];
1031    cl_mem pixtemp;
1032    cl_int status = 0;
1033    int gsize;
1034    char isAsymmetric = (MORPH_BC == ASYMMETRIC_MORPH_BC);
1035    l_uint32 rwmask, lwmask;
1036    char isEven;
1037    sel = selCreateBrick(vsize, hsize, vsize / 2, hsize / 2, SEL_HIT);
1038    selFindMaxTranslations(sel, &amp;xp, &amp;yp, &amp;xn, &amp;yn);
1039    selDestroy(&amp;sel);
1040    OpenclDevice::SetKernelEnv(&amp;rEnv);
1041    if (hsize == 5 &amp;&amp; vsize == 5 &amp;&amp; isAsymmetric) {
1042      status = pixErodeCL_55(wpl, h);
1043      return status;
1044    }
1045    lwmask = lmask32[31 - (xn &amp; 31)];
1046    rwmask = rmask32[31 - (xp &amp; 31)];
1047    gsize = (wpl + GROUPSIZE_X - 1) / GROUPSIZE_X * GROUPSIZE_X;
1048    globalThreads[0] = gsize;
1049    gsize = (h + GROUPSIZE_Y - 1) / GROUPSIZE_Y * GROUPSIZE_Y;
1050    globalThreads[1] = gsize;
1051    localThreads[0] = GROUPSIZE_X;
1052    localThreads[1] = GROUPSIZE_Y;
1053    if (xp &gt; 31 || xn &gt; 31) {
1054      rEnv.mpkKernel = clCreateKernel(rEnv.mpkProgram, &quot;morphoErodeHor&quot;, &amp;status);
1055      status = clSetKernelArg(rEnv.mpkKernel, 0, sizeof(cl_mem), &amp;pixsCLBuffer);
1056      status = clSetKernelArg(rEnv.mpkKernel, 1, sizeof(cl_mem), &amp;pixdCLBuffer);
1057      status = clSetKernelArg(rEnv.mpkKernel, 2, sizeof(xp), &amp;xp);
1058      status = clSetKernelArg(rEnv.mpkKernel, 3, sizeof(xn), &amp;xn);
1059      status = clSetKernelArg(rEnv.mpkKernel, 4, sizeof(wpl), &amp;wpl);
1060      status = clSetKernelArg(rEnv.mpkKernel, 5, sizeof(h), &amp;h);
1061      status = clSetKernelArg(rEnv.mpkKernel, 6, sizeof(isAsymmetric), &amp;isAsymmetric);
1062      status = clSetKernelArg(rEnv.mpkKernel, 7, sizeof(rwmask), &amp;rwmask);
1063      status = clSetKernelArg(rEnv.mpkKernel, 8, sizeof(lwmask), &amp;lwmask);
1064      status = clEnqueueNDRangeKernel(rEnv.mpkCmdQueue, rEnv.mpkKernel, 2, nullptr, globalThreads,
1065                                      localThreads, 0, nullptr, nullptr);
1066      if (yp &gt; 0 || yn &gt; 0) {
1067        pixtemp = pixsCLBuffer;
1068        pixsCLBuffer = pixdCLBuffer;
1069        pixdCLBuffer = pixtemp;
1070      }
1071    } else if (xp &gt; 0 || xn &gt; 0) {
1072      rEnv.mpkKernel = clCreateKernel(rEnv.mpkProgram, &quot;morphoErodeHor_32word&quot;, &amp;status);
1073      isEven = (xp != xn);
1074      status = clSetKernelArg(rEnv.mpkKernel, 0, sizeof(cl_mem), &amp;pixsCLBuffer);
1075      status = clSetKernelArg(rEnv.mpkKernel, 1, sizeof(cl_mem), &amp;pixdCLBuffer);
1076      status = clSetKernelArg(rEnv.mpkKernel, 2, sizeof(xp), &amp;xp);
1077      status = clSetKernelArg(rEnv.mpkKernel, 3, sizeof(wpl), &amp;wpl);
1078      status = clSetKernelArg(rEnv.mpkKernel, 4, sizeof(h), &amp;h);
1079      status = clSetKernelArg(rEnv.mpkKernel, 5, sizeof(isAsymmetric), &amp;isAsymmetric);
1080      status = clSetKernelArg(rEnv.mpkKernel, 6, sizeof(rwmask), &amp;rwmask);
1081      status = clSetKernelArg(rEnv.mpkKernel, 7, sizeof(lwmask), &amp;lwmask);
1082      status = clSetKernelArg(rEnv.mpkKernel, 8, sizeof(isEven), &amp;isEven);
1083      status = clEnqueueNDRangeKernel(rEnv.mpkCmdQueue, rEnv.mpkKernel, 2, nullptr, globalThreads,
1084                                      localThreads, 0, nullptr, nullptr);
1085      if (yp &gt; 0 || yn &gt; 0) {
1086        pixtemp = pixsCLBuffer;
1087        pixsCLBuffer = pixdCLBuffer;
1088        pixdCLBuffer = pixtemp;
1089      }
1090    }
1091    if (yp &gt; 0 || yn &gt; 0) {
1092      rEnv.mpkKernel = clCreateKernel(rEnv.mpkProgram, &quot;morphoErodeVer&quot;, &amp;status);
1093      CHECK_OPENCL(status, &quot;clCreateKernel morphoErodeVer&quot;);
1094      status = clSetKernelArg(rEnv.mpkKernel, 0, sizeof(cl_mem), &amp;pixsCLBuffer);
1095      status = clSetKernelArg(rEnv.mpkKernel, 1, sizeof(cl_mem), &amp;pixdCLBuffer);
1096      status = clSetKernelArg(rEnv.mpkKernel, 2, sizeof(yp), &amp;yp);
1097      status = clSetKernelArg(rEnv.mpkKernel, 3, sizeof(wpl), &amp;wpl);
1098      status = clSetKernelArg(rEnv.mpkKernel, 4, sizeof(h), &amp;h);
1099      status = clSetKernelArg(rEnv.mpkKernel, 5, sizeof(isAsymmetric), &amp;isAsymmetric);
1100      status = clSetKernelArg(rEnv.mpkKernel, 6, sizeof(yn), &amp;yn);
1101      status = clEnqueueNDRangeKernel(rEnv.mpkCmdQueue, rEnv.mpkKernel, 2, nullptr, globalThreads,
1102                                      localThreads, 0, nullptr, nullptr);
1103    }
1104    return status;
1105  }
1106  static cl_int pixOpenCL(l_int32 hsize, l_int32 vsize, l_int32 wpl, l_int32 h) {
1107    cl_int status;
1108    cl_mem pixtemp;
1109    status = pixErodeCL(hsize, vsize, wpl, h);
1110    pixtemp = pixsCLBuffer;
1111    pixsCLBuffer = pixdCLBuffer;
1112    pixdCLBuffer = pixtemp;
1113    status = pixDilateCL(hsize, vsize, wpl, h);
1114    return status;
1115  }
1116  static cl_int pixCloseCL(l_int32 hsize, l_int32 vsize, l_int32 wpl, l_int32 h) {
1117    cl_int status;
1118    cl_mem pixtemp;
1119    status = pixDilateCL(hsize, vsize, wpl, h);
1120    pixtemp = pixsCLBuffer;
1121    pixsCLBuffer = pixdCLBuffer;
1122    pixdCLBuffer = pixtemp;
1123    status = pixErodeCL(hsize, vsize, wpl, h);
1124    return status;
1125  }
1126  static cl_int pixSubtractCL_work(l_uint32 wpl, l_uint32 h, cl_mem buffer1, cl_mem buffer2) {
1127    cl_int status;
1128    size_t globalThreads[2];
1129    int gsize;
1130    size_t localThreads[] = {GROUPSIZE_X, GROUPSIZE_Y};
1131    gsize = (wpl + GROUPSIZE_X - 1) / GROUPSIZE_X * GROUPSIZE_X;
1132    globalThreads[0] = gsize;
1133    gsize = (h + GROUPSIZE_Y - 1) / GROUPSIZE_Y * GROUPSIZE_Y;
1134    globalThreads[1] = gsize;
1135    rEnv.mpkKernel = clCreateKernel(rEnv.mpkProgram, &quot;pixSubtract_inplace&quot;, &amp;status);
1136    CHECK_OPENCL(status, &quot;clCreateKernel pixSubtract_inplace&quot;);
1137    status = clSetKernelArg(rEnv.mpkKernel, 0, sizeof(cl_mem), &amp;buffer1);
1138    status = clSetKernelArg(rEnv.mpkKernel, 1, sizeof(cl_mem), &amp;buffer2);
1139    status = clSetKernelArg(rEnv.mpkKernel, 2, sizeof(wpl), &amp;wpl);
1140    status = clSetKernelArg(rEnv.mpkKernel, 3, sizeof(h), &amp;h);
1141    status = clEnqueueNDRangeKernel(rEnv.mpkCmdQueue, rEnv.mpkKernel, 2, nullptr, globalThreads,
1142                                    localThreads, 0, nullptr, nullptr);
1143    return status;
1144  }
1145  void OpenclDevice::pixGetLinesCL(Image pixd, Image pixs, Image *pix_vline, Image *pix_hline,
1146                                   Image *pixClosed, bool getpixClosed, l_int32 close_hsize,
1147                                   l_int32 close_vsize, l_int32 open_hsize, l_int32 open_vsize,
1148                                   l_int32 line_hsize, l_int32 line_vsize) {
1149    l_uint32 wpl, h;
1150    cl_mem pixtemp;
1151    wpl = pixGetWpl(pixs);
1152    h = pixGetHeight(pixs);
1153    clStatus = pixCloseCL(close_hsize, close_vsize, wpl, h);
1154    if (getpixClosed) {
1155      *pixClosed =
1156          mapOutputCLBuffer(rEnv, pixdCLBuffer, *pixClosed, pixs, wpl * h, CL_MAP_READ, true, false);
1157    }
1158    clStatus = clEnqueueCopyBuffer(rEnv.mpkCmdQueue, pixdCLBuffer, pixdCLIntermediate, 0, 0,
1159                                   sizeof(int) * wpl * h, 0, nullptr, nullptr);
1160    pixtemp = pixsCLBuffer;
1161    pixsCLBuffer = pixdCLBuffer;
1162    pixdCLBuffer = pixtemp;
1163    clStatus = pixOpenCL(open_hsize, open_vsize, wpl, h);
1164    pixtemp = pixsCLBuffer;
1165    pixsCLBuffer = pixdCLBuffer;
1166    pixdCLBuffer = pixdCLIntermediate;
1167    pixdCLIntermediate = pixtemp;
1168    clStatus = pixSubtractCL_work(wpl, h, pixdCLBuffer, pixsCLBuffer);
1169    clStatus = clEnqueueCopyBuffer(rEnv.mpkCmdQueue, pixdCLBuffer, pixdCLIntermediate, 0, 0,
1170                                   sizeof(int) * wpl * h, 0, nullptr, nullptr);
1171    pixtemp = pixsCLBuffer;
1172    pixsCLBuffer = pixdCLBuffer;
1173    pixdCLBuffer = pixtemp;
1174    clStatus = pixOpenCL(1, line_vsize, wpl, h);
1175    *pix_vline =
1176        mapOutputCLBuffer(rEnv, pixdCLBuffer, *pix_vline, pixs, wpl * h, CL_MAP_READ, true, false);
1177    pixtemp = pixsCLBuffer;
1178    pixsCLBuffer = pixdCLIntermediate;
1179    pixdCLIntermediate = pixtemp;
1180    clStatus = pixOpenCL(line_hsize, 1, wpl, h);
1181    *pix_hline =
1182        mapOutputCLBuffer(rEnv, pixdCLBuffer, *pix_hline, pixs, wpl * h, CL_MAP_READ, true, true);
1183    return;
1184  }
1185  int OpenclDevice::HistogramRectOCL(void *imageData, int bytes_per_pixel, int bytes_per_line,
1186                                     int left, 
1187                                     int top,  
1188                                     int width, int height, int kHistogramSize,
1189                                     int *histogramAllChannels) {
1190    cl_int clStatus;
1191    int retVal = 0;
1192    KernelEnv histKern;
1193    SetKernelEnv(&amp;histKern);
1194    KernelEnv histRedKern;
1195    SetKernelEnv(&amp;histRedKern);
<span onclick='openModal()' class='match'>1196    cl_mem imageBuffer =
1197        clCreateBuffer(histKern.mpkContext, CL_MEM_READ_ONLY | CL_MEM_USE_HOST_PTR,
1198                       width * height * bytes_per_pixel * sizeof(char), imageData, &amp;clStatus);
1199    CHECK_OPENCL(clStatus, &quot;clCreateBuffer imageBuffer&quot;);
1200    int block_size = 256;
</span>1201    cl_uint numCUs;
1202    clStatus = clGetDeviceInfo(gpuEnv.mpDevID, CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(numCUs), &amp;numCUs,
1203                               nullptr);
1204    CHECK_OPENCL(clStatus, &quot;clCreateBuffer imageBuffer&quot;);
1205    int requestedOccupancy = 10;
1206    int numWorkGroups = numCUs * requestedOccupancy;
1207    int numThreads = block_size * numWorkGroups;
1208    size_t local_work_size[] = {static_cast&lt;size_t&gt;(block_size)};
1209    size_t global_work_size[] = {static_cast&lt;size_t&gt;(numThreads)};
1210    size_t red_global_work_size[] = {
1211        static_cast&lt;size_t&gt;(block_size * kHistogramSize * bytes_per_pixel)};
1212    cl_mem histogramBuffer = clCreateBuffer(
1213        histKern.mpkContext, CL_MEM_READ_WRITE | CL_MEM_USE_HOST_PTR,
1214        kHistogramSize * bytes_per_pixel * sizeof(int), histogramAllChannels, &amp;clStatus);
1215    CHECK_OPENCL(clStatus, &quot;clCreateBuffer histogramBuffer&quot;);
1216    int histRed = 256;
1217    int tmpHistogramBins = kHistogramSize * bytes_per_pixel * histRed;
1218    cl_mem tmpHistogramBuffer =
1219        clCreateBuffer(histKern.mpkContext, CL_MEM_READ_WRITE, tmpHistogramBins * sizeof(cl_uint),
1220                       nullptr, &amp;clStatus);
1221    CHECK_OPENCL(clStatus, &quot;clCreateBuffer tmpHistogramBuffer&quot;);
1222    int *zeroBuffer = new int[1];
1223    zeroBuffer[0] = 0;
1224    cl_mem atomicSyncBuffer =
1225        clCreateBuffer(histKern.mpkContext, CL_MEM_READ_WRITE | CL_MEM_COPY_HOST_PTR, sizeof(cl_int),
1226                       zeroBuffer, &amp;clStatus);
1227    CHECK_OPENCL(clStatus, &quot;clCreateBuffer atomicSyncBuffer&quot;);
1228    delete[] zeroBuffer;
1229    if (bytes_per_pixel == 1) {
1230      histKern.mpkKernel =
1231          clCreateKernel(histKern.mpkProgram, &quot;kernel_HistogramRectOneChannel&quot;, &amp;clStatus);
1232      CHECK_OPENCL(clStatus, &quot;clCreateKernel kernel_HistogramRectOneChannel&quot;);
1233      histRedKern.mpkKernel = clCreateKernel(histRedKern.mpkProgram,
1234                                             &quot;kernel_HistogramRectOneChannelReduction&quot;, &amp;clStatus);
1235      CHECK_OPENCL(clStatus, &quot;clCreateKernel kernel_HistogramRectOneChannelReduction&quot;);
1236    } else {
1237      histKern.mpkKernel =
1238          clCreateKernel(histKern.mpkProgram, &quot;kernel_HistogramRectAllChannels&quot;, &amp;clStatus);
1239      CHECK_OPENCL(clStatus, &quot;clCreateKernel kernel_HistogramRectAllChannels&quot;);
1240      histRedKern.mpkKernel = clCreateKernel(histRedKern.mpkProgram,
1241                                             &quot;kernel_HistogramRectAllChannelsReduction&quot;, &amp;clStatus);
1242      CHECK_OPENCL(clStatus, &quot;clCreateKernel kernel_HistogramRectAllChannelsReduction&quot;);
1243    }
1244    void *ptr;
1245    ptr = clEnqueueMapBuffer(histKern.mpkCmdQueue, tmpHistogramBuffer, CL_TRUE, CL_MAP_WRITE, 0,
1246                             tmpHistogramBins * sizeof(cl_uint), 0, nullptr, nullptr, &amp;clStatus);
1247    CHECK_OPENCL(clStatus, &quot;clEnqueueMapBuffer tmpHistogramBuffer&quot;);
1248    memset(ptr, 0, tmpHistogramBins * sizeof(cl_uint));
1249    clEnqueueUnmapMemObject(histKern.mpkCmdQueue, tmpHistogramBuffer, ptr, 0, nullptr, nullptr);
1250    clStatus = clSetKernelArg(histKern.mpkKernel, 0, sizeof(cl_mem), &amp;imageBuffer);
1251    CHECK_OPENCL(clStatus, &quot;clSetKernelArg imageBuffer&quot;);
1252    cl_uint numPixels = width * height;
1253    clStatus = clSetKernelArg(histKern.mpkKernel, 1, sizeof(cl_uint), &amp;numPixels);
1254    CHECK_OPENCL(clStatus, &quot;clSetKernelArg numPixels&quot;);
1255    clStatus = clSetKernelArg(histKern.mpkKernel, 2, sizeof(cl_mem), &amp;tmpHistogramBuffer);
1256    CHECK_OPENCL(clStatus, &quot;clSetKernelArg tmpHistogramBuffer&quot;);
1257    int n = numThreads / bytes_per_pixel;
1258    clStatus = clSetKernelArg(histRedKern.mpkKernel, 0, sizeof(cl_int), &amp;n);
1259    CHECK_OPENCL(clStatus, &quot;clSetKernelArg imageBuffer&quot;);
1260    clStatus = clSetKernelArg(histRedKern.mpkKernel, 1, sizeof(cl_mem), &amp;tmpHistogramBuffer);
1261    CHECK_OPENCL(clStatus, &quot;clSetKernelArg tmpHistogramBuffer&quot;);
1262    clStatus = clSetKernelArg(histRedKern.mpkKernel, 2, sizeof(cl_mem), &amp;histogramBuffer);
1263    CHECK_OPENCL(clStatus, &quot;clSetKernelArg histogramBuffer&quot;);
1264    clStatus = clEnqueueNDRangeKernel(histKern.mpkCmdQueue, histKern.mpkKernel, 1, nullptr,
1265                                      global_work_size, local_work_size, 0, nullptr, nullptr);
1266    CHECK_OPENCL(clStatus, &quot;clEnqueueNDRangeKernel kernel_HistogramRectAllChannels&quot;);
1267    clFinish(histKern.mpkCmdQueue);
1268    if (clStatus != 0) {
1269      retVal = -1;
1270    }
1271    clStatus = clEnqueueNDRangeKernel(histRedKern.mpkCmdQueue, histRedKern.mpkKernel, 1, nullptr,
1272                                      red_global_work_size, local_work_size, 0, nullptr, nullptr);
1273    CHECK_OPENCL(clStatus, &quot;clEnqueueNDRangeKernel kernel_HistogramRectAllChannelsReduction&quot;);
1274    clFinish(histRedKern.mpkCmdQueue);
1275    if (clStatus != 0) {
1276      retVal = -1;
1277    }
1278    ptr = clEnqueueMapBuffer(histRedKern.mpkCmdQueue, histogramBuffer, CL_TRUE, CL_MAP_READ, 0,
1279                             kHistogramSize * bytes_per_pixel * sizeof(int), 0, nullptr, nullptr,
1280                             &amp;clStatus);
1281    CHECK_OPENCL(clStatus, &quot;clEnqueueMapBuffer histogramBuffer&quot;);
1282    if (clStatus != 0) {
1283      retVal = -1;
1284    }
1285    clEnqueueUnmapMemObject(histRedKern.mpkCmdQueue, histogramBuffer, ptr, 0, nullptr, nullptr);
1286    clReleaseMemObject(histogramBuffer);
1287    clReleaseMemObject(imageBuffer);
1288    return retVal;
1289  }
1290  int OpenclDevice::ThresholdRectToPixOCL(unsigned char *imageData, int bytes_per_pixel,
1291                                          int bytes_per_line, int *thresholds, int *hi_values,
1292                                          Image *pix, int height, int width, int top, int left) {
1293    int retVal = 0;
1294    *pix = pixCreate(width, height, 1);
1295    uint32_t *pixData = pixGetData(*pix);
1296    int wpl = pixGetWpl(*pix);
1297    int pixSize = wpl * height * sizeof(uint32_t); 
1298    cl_int clStatus;
1299    KernelEnv rEnv;
1300    SetKernelEnv(&amp;rEnv);
1301    int block_size = 256;
1302    cl_uint numCUs = 6;
1303    clStatus = clGetDeviceInfo(gpuEnv.mpDevID, CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(numCUs), &amp;numCUs,
1304                               nullptr);
1305    CHECK_OPENCL(clStatus, &quot;clCreateBuffer imageBuffer&quot;);
1306    int requestedOccupancy = 10;
1307    int numWorkGroups = numCUs * requestedOccupancy;
1308    int numThreads = block_size * numWorkGroups;
1309    size_t local_work_size[] = {(size_t)block_size};
1310    size_t global_work_size[] = {(size_t)numThreads};
1311    cl_mem imageBuffer =
1312        clCreateBuffer(rEnv.mpkContext, CL_MEM_READ_ONLY | CL_MEM_USE_HOST_PTR,
1313                       width * height * bytes_per_pixel * sizeof(char), imageData, &amp;clStatus);
1314    CHECK_OPENCL(clStatus, &quot;clCreateBuffer imageBuffer&quot;);
1315    pixThBuffer = clCreateBuffer(rEnv.mpkContext, CL_MEM_READ_WRITE | CL_MEM_USE_HOST_PTR, pixSize,
1316                                 pixData, &amp;clStatus);
1317    CHECK_OPENCL(clStatus, &quot;clCreateBuffer pix&quot;);
1318    cl_mem thresholdsBuffer = clCreateBuffer(rEnv.mpkContext, CL_MEM_READ_ONLY | CL_MEM_USE_HOST_PTR,
1319                                             bytes_per_pixel * sizeof(int), thresholds, &amp;clStatus);
1320    CHECK_OPENCL(clStatus, &quot;clCreateBuffer thresholdBuffer&quot;);
1321    cl_mem hiValuesBuffer = clCreateBuffer(rEnv.mpkContext, CL_MEM_READ_ONLY | CL_MEM_USE_HOST_PTR,
1322                                           bytes_per_pixel * sizeof(int), hi_values, &amp;clStatus);
1323    CHECK_OPENCL(clStatus, &quot;clCreateBuffer hiValuesBuffer&quot;);
1324    if (bytes_per_pixel == 4) {
1325      rEnv.mpkKernel = clCreateKernel(rEnv.mpkProgram, &quot;kernel_ThresholdRectToPix&quot;, &amp;clStatus);
1326      CHECK_OPENCL(clStatus, &quot;clCreateKernel kernel_ThresholdRectToPix&quot;);
1327    } else {
1328      rEnv.mpkKernel =
1329          clCreateKernel(rEnv.mpkProgram, &quot;kernel_ThresholdRectToPix_OneChan&quot;, &amp;clStatus);
1330      CHECK_OPENCL(clStatus, &quot;clCreateKernel kernel_ThresholdRectToPix_OneChan&quot;);
1331    }
1332    clStatus = clSetKernelArg(rEnv.mpkKernel, 0, sizeof(cl_mem), &amp;imageBuffer);
1333    CHECK_OPENCL(clStatus, &quot;clSetKernelArg imageBuffer&quot;);
1334    clStatus = clSetKernelArg(rEnv.mpkKernel, 1, sizeof(int), &amp;height);
1335    CHECK_OPENCL(clStatus, &quot;clSetKernelArg height&quot;);
1336    clStatus = clSetKernelArg(rEnv.mpkKernel, 2, sizeof(int), &amp;width);
1337    CHECK_OPENCL(clStatus, &quot;clSetKernelArg width&quot;);
1338    clStatus = clSetKernelArg(rEnv.mpkKernel, 3, sizeof(int), &amp;wpl);
1339    CHECK_OPENCL(clStatus, &quot;clSetKernelArg wpl&quot;);
1340    clStatus = clSetKernelArg(rEnv.mpkKernel, 4, sizeof(cl_mem), &amp;thresholdsBuffer);
1341    CHECK_OPENCL(clStatus, &quot;clSetKernelArg thresholdsBuffer&quot;);
1342    clStatus = clSetKernelArg(rEnv.mpkKernel, 5, sizeof(cl_mem), &amp;hiValuesBuffer);
1343    CHECK_OPENCL(clStatus, &quot;clSetKernelArg hiValuesBuffer&quot;);
1344    clStatus = clSetKernelArg(rEnv.mpkKernel, 6, sizeof(cl_mem), &amp;pixThBuffer);
1345    CHECK_OPENCL(clStatus, &quot;clSetKernelArg pixThBuffer&quot;);
1346    clStatus = clEnqueueNDRangeKernel(rEnv.mpkCmdQueue, rEnv.mpkKernel, 1, nullptr, global_work_size,
1347                                      local_work_size, 0, nullptr, nullptr);
1348    CHECK_OPENCL(clStatus, &quot;clEnqueueNDRangeKernel kernel_ThresholdRectToPix&quot;);
1349    clFinish(rEnv.mpkCmdQueue);
1350    if (clStatus != 0) {
1351      tprintf(&quot;Setting return value to -1\n&quot;);
1352      retVal = -1;
1353    }
1354    void *ptr = clEnqueueMapBuffer(rEnv.mpkCmdQueue, pixThBuffer, CL_TRUE, CL_MAP_READ, 0, pixSize, 0,
1355                                   nullptr, nullptr, &amp;clStatus);
1356    CHECK_OPENCL(clStatus, &quot;clEnqueueMapBuffer histogramBuffer&quot;);
1357    clEnqueueUnmapMemObject(rEnv.mpkCmdQueue, pixThBuffer, ptr, 0, nullptr, nullptr);
1358    clReleaseMemObject(imageBuffer);
1359    clReleaseMemObject(thresholdsBuffer);
1360    clReleaseMemObject(hiValuesBuffer);
1361    return retVal;
1362  }
1363  struct TessScoreEvaluationInputData {
1364    int height;
1365    int width;
1366    int numChannels;
1367    unsigned char *imageData;
1368    Image pix;
1369  };
1370  static void populateTessScoreEvaluationInputData(TessScoreEvaluationInputData *input) {
1371    srand(1);
1372    int height = 3328; 
1373    int width = 2560;  
1374    int numChannels = 4;
1375    input-&gt;height = height;
1376    input-&gt;width = width;
1377    input-&gt;numChannels = numChannels;
1378    unsigned char(*imageData4)[4] = (unsigned char(*)[4])malloc(
1379        height * width * numChannels * sizeof(unsigned char)); 
1380    input-&gt;imageData = (unsigned char *)&amp;imageData4[0];
1381    unsigned char pixelWhite[4] = {0, 0, 0, 255};
1382    unsigned char pixelBlack[4] = {255, 255, 255, 255};
1383    for (int p = 0; p &lt; height * width; p++) {
1384      imageData4[p][0] = pixelWhite[0];
1385      imageData4[p][1] = pixelWhite[1];
1386      imageData4[p][2] = pixelWhite[2];
1387      imageData4[p][3] = pixelWhite[3];
1388    }
1389    int maxLineWidth = 64; 
1390    int numLines = 10;
1391    for (int i = 0; i &lt; numLines; i++) {
1392      int lineWidth = rand() % maxLineWidth;
1393      int vertLinePos = lineWidth + rand() % (width - 2 * lineWidth);
1394      for (int row = vertLinePos - lineWidth / 2; row &lt; vertLinePos + lineWidth / 2; row++) {
1395        for (int col = 0; col &lt; height; col++) {
1396          imageData4[row * width + col][0] = pixelBlack[0];
1397          imageData4[row * width + col][1] = pixelBlack[1];
1398          imageData4[row * width + col][2] = pixelBlack[2];
1399          imageData4[row * width + col][3] = pixelBlack[3];
1400        }
1401      }
1402    }
1403    for (int i = 0; i &lt; numLines; i++) {
1404      int lineWidth = rand() % maxLineWidth;
1405      int horLinePos = lineWidth + rand() % (height - 2 * lineWidth);
1406      for (int row = 0; row &lt; width; row++) {
1407        for (int col = horLinePos - lineWidth / 2; col &lt; horLinePos + lineWidth / 2;
1408             col++) { 
1409          imageData4[row * width + col][0] = pixelBlack[0];
1410          imageData4[row * width + col][1] = pixelBlack[1];
1411          imageData4[row * width + col][2] = pixelBlack[2];
1412          imageData4[row * width + col][3] = pixelBlack[3];
1413        }
1414      }
1415    }
1416    float fractionBlack = 0.1; 
1417    int numSpots = (height * width) * fractionBlack / (maxLineWidth * maxLineWidth / 2 / 2);
1418    for (int i = 0; i &lt; numSpots; i++) {
1419      int lineWidth = rand() % maxLineWidth;
1420      int col = lineWidth + rand() % (width - 2 * lineWidth);
1421      int row = lineWidth + rand() % (height - 2 * lineWidth);
1422      for (int r = row - lineWidth / 2; r &lt; row + lineWidth / 2; r++) {
1423        for (int c = col - lineWidth / 2; c &lt; col + lineWidth / 2; c++) {
1424          imageData4[r * width + c][0] = pixelBlack[0];
1425          imageData4[r * width + c][1] = pixelBlack[1];
1426          imageData4[r * width + c][2] = pixelBlack[2];
1427          imageData4[r * width + c][3] = pixelBlack[3];
1428        }
1429      }
1430    }
1431    input-&gt;pix = pixCreate(input-&gt;width, input-&gt;height, 8 * input-&gt;numChannels);
1432  }
1433  struct TessDeviceScore {
1434    float time;   
1435    bool clError; 
1436    bool valid;   
1437  };
1438  static double composeRGBPixelMicroBench(GPUEnv *env, TessScoreEvaluationInputData input,
1439                                          ds_device_type type) {
1440    double time = 0;
1441  #  if ON_WINDOWS
1442    LARGE_INTEGER freq, time_funct_start, time_funct_end;
1443    QueryPerformanceFrequency(&amp;freq);
1444  #  elif ON_APPLE
1445    mach_timebase_info_data_t info = {0, 0};
1446    mach_timebase_info(&amp;info);
1447    long long start, stop;
1448  #  else
1449    timespec time_funct_start, time_funct_end;
1450  #  endif
1451    l_uint32 *tiffdata = (l_uint32 *)input.imageData; 
1452    if (type == DS_DEVICE_OPENCL_DEVICE) {
1453  #  if ON_WINDOWS
1454      QueryPerformanceCounter(&amp;time_funct_start);
1455  #  elif ON_APPLE
1456      start = mach_absolute_time();
1457  #  else
1458      clock_gettime(CLOCK_MONOTONIC, &amp;time_funct_start);
1459  #  endif
1460      OpenclDevice::gpuEnv = *env;
1461      int wpl = pixGetWpl(input.pix);
1462      OpenclDevice::pixReadFromTiffKernel(tiffdata, input.width, input.height, wpl, nullptr);
1463  #  if ON_WINDOWS
1464      QueryPerformanceCounter(&amp;time_funct_end);
1465      time = (time_funct_end.QuadPart - time_funct_start.QuadPart) / (double)(freq.QuadPart);
1466  #  elif ON_APPLE
1467      stop = mach_absolute_time();
1468      time = ((stop - start) * (double)info.numer / info.denom) / 1.0E9;
1469  #  else
1470      clock_gettime(CLOCK_MONOTONIC, &amp;time_funct_end);
1471      time = (time_funct_end.tv_sec - time_funct_start.tv_sec) * 1.0 +
1472             (time_funct_end.tv_nsec - time_funct_start.tv_nsec) / 1000000000.0;
1473  #  endif
1474    } else {
1475  #  if ON_WINDOWS
1476      QueryPerformanceCounter(&amp;time_funct_start);
1477  #  elif ON_APPLE
1478      start = mach_absolute_time();
1479  #  else
1480      clock_gettime(CLOCK_MONOTONIC, &amp;time_funct_start);
1481  #  endif
1482      Image pix = pixCreate(input.width, input.height, 32);
1483      l_uint32 *pixData = pixGetData(pix);
1484      int i, j;
1485      int idx = 0;
1486      for (i = 0; i &lt; input.height; i++) {
1487        for (j = 0; j &lt; input.width; j++) {
1488          l_uint32 tiffword = tiffdata[i * input.width + j];
1489          l_int32 rval = ((tiffword)&amp;0xff);
1490          l_int32 gval = (((tiffword) &gt;&gt; 8) &amp; 0xff);
1491          l_int32 bval = (((tiffword) &gt;&gt; 16) &amp; 0xff);
1492          l_uint32 value = (rval &lt;&lt; 24) | (gval &lt;&lt; 16) | (bval &lt;&lt; 8);
1493          pixData[idx] = value;
1494          idx++;
1495        }
1496      }
1497  #  if ON_WINDOWS
1498      QueryPerformanceCounter(&amp;time_funct_end);
1499      time = (time_funct_end.QuadPart - time_funct_start.QuadPart) / (double)(freq.QuadPart);
1500  #  elif ON_APPLE
1501      stop = mach_absolute_time();
1502      time = ((stop - start) * (double)info.numer / info.denom) / 1.0E9;
1503  #  else
1504      clock_gettime(CLOCK_MONOTONIC, &amp;time_funct_end);
1505      time = (time_funct_end.tv_sec - time_funct_start.tv_sec) * 1.0 +
1506             (time_funct_end.tv_nsec - time_funct_start.tv_nsec) / 1000000000.0;
1507  #  endif
1508      pix.destroy();
1509    }
1510    return time;
1511  }
1512  static double histogramRectMicroBench(GPUEnv *env, TessScoreEvaluationInputData input,
1513                                        ds_device_type type) {
1514    double time;
1515  #  if ON_WINDOWS
1516    LARGE_INTEGER freq, time_funct_start, time_funct_end;
1517    QueryPerformanceFrequency(&amp;freq);
1518  #  elif ON_APPLE
1519    mach_timebase_info_data_t info = {0, 0};
1520    mach_timebase_info(&amp;info);
1521    long long start, stop;
1522  #  else
1523    timespec time_funct_start, time_funct_end;
1524  #  endif
1525    const int left = 0;
1526    const int top = 0;
1527    int kHistogramSize = 256;
1528    int bytes_per_line = input.width * input.numChannels;
1529    int *histogramAllChannels = new int[kHistogramSize * input.numChannels];
1530    if (type == DS_DEVICE_OPENCL_DEVICE) {
1531  #  if ON_WINDOWS
1532      QueryPerformanceCounter(&amp;time_funct_start);
1533  #  elif ON_APPLE
1534      start = mach_absolute_time();
1535  #  else
1536      clock_gettime(CLOCK_MONOTONIC, &amp;time_funct_start);
1537  #  endif
1538      OpenclDevice::gpuEnv = *env;
1539      int retVal = OpenclDevice::HistogramRectOCL(input.imageData, input.numChannels, bytes_per_line,
1540                                                  left, top, input.width, input.height,
1541                                                  kHistogramSize, histogramAllChannels);
1542  #  if ON_WINDOWS
1543      QueryPerformanceCounter(&amp;time_funct_end);
1544      time = (time_funct_end.QuadPart - time_funct_start.QuadPart) / (double)(freq.QuadPart);
1545  #  elif ON_APPLE
1546      stop = mach_absolute_time();
1547      if (retVal == 0) {
1548        time = ((stop - start) * (double)info.numer / info.denom) / 1.0E9;
1549      } else {
1550        time = FLT_MAX;
1551      }
1552  #  else
1553      clock_gettime(CLOCK_MONOTONIC, &amp;time_funct_end);
1554      time = (time_funct_end.tv_sec - time_funct_start.tv_sec) * 1.0 +
1555             (time_funct_end.tv_nsec - time_funct_start.tv_nsec) / 1000000000.0;
1556  #  endif
1557    } else {
1558      int *histogram = new int[kHistogramSize];
1559  #  if ON_WINDOWS
1560      QueryPerformanceCounter(&amp;time_funct_start);
1561  #  elif ON_APPLE
1562      start = mach_absolute_time();
1563  #  else
1564      clock_gettime(CLOCK_MONOTONIC, &amp;time_funct_start);
1565  #  endif
1566      for (int ch = 0; ch &lt; input.numChannels; ++ch) {
1567        tesseract::HistogramRect(input.pix, input.numChannels, left, top, input.width, input.height,
1568                                 histogram);
1569      }
1570  #  if ON_WINDOWS
1571      QueryPerformanceCounter(&amp;time_funct_end);
1572      time = (time_funct_end.QuadPart - time_funct_start.QuadPart) / (double)(freq.QuadPart);
1573  #  elif ON_APPLE
1574      stop = mach_absolute_time();
1575      time = ((stop - start) * (double)info.numer / info.denom) / 1.0E9;
1576  #  else
1577      clock_gettime(CLOCK_MONOTONIC, &amp;time_funct_end);
1578      time = (time_funct_end.tv_sec - time_funct_start.tv_sec) * 1.0 +
1579             (time_funct_end.tv_nsec - time_funct_start.tv_nsec) / 1000000000.0;
1580  #  endif
1581      delete[] histogram;
1582    }
1583    delete[] histogramAllChannels;
1584    return time;
1585  }
1586  static void ThresholdRectToPix_Native(const unsigned char *imagedata, int bytes_per_pixel,
1587                                        int bytes_per_line, const int *thresholds,
1588                                        const int *hi_values, Image *pix) {
1589    int top = 0;
1590    int left = 0;
1591    int width = pixGetWidth(*pix);
1592    int height = pixGetHeight(*pix);
1593    *pix = pixCreate(width, height, 1);
1594    uint32_t *pixdata = pixGetData(*pix);
1595    int wpl = pixGetWpl(*pix);
1596    const unsigned char *srcdata = imagedata + top * bytes_per_line + left * bytes_per_pixel;
1597    for (int y = 0; y &lt; height; ++y) {
1598      const uint8_t *linedata = srcdata;
1599      uint32_t *pixline = pixdata + y * wpl;
1600      for (int x = 0; x &lt; width; ++x, linedata += bytes_per_pixel) {
1601        bool white_result = true;
1602        for (int ch = 0; ch &lt; bytes_per_pixel; ++ch) {
1603          if (hi_values[ch] &gt;= 0 &amp;&amp; (linedata[ch] &gt; thresholds[ch]) == (hi_values[ch] == 0)) {
1604            white_result = false;
1605            break;
1606          }
1607        }
1608        if (white_result)
1609          CLEAR_DATA_BIT(pixline, x);
1610        else
1611          SET_DATA_BIT(pixline, x);
1612      }
1613      srcdata += bytes_per_line;
1614    }
1615  }
1616  static double thresholdRectToPixMicroBench(GPUEnv *env, TessScoreEvaluationInputData input,
1617                                             ds_device_type type) {
1618    double time;
1619  #  if ON_WINDOWS
1620    LARGE_INTEGER freq, time_funct_start, time_funct_end;
1621    QueryPerformanceFrequency(&amp;freq);
1622  #  elif ON_APPLE
1623    mach_timebase_info_data_t info = {0, 0};
1624    mach_timebase_info(&amp;info);
1625    long long start, stop;
1626  #  else
1627    timespec time_funct_start, time_funct_end;
1628  #  endif
1629    unsigned char pixelHi = (unsigned char)255;
1630    int thresholds[4] = {pixelHi, pixelHi, pixelHi, pixelHi};
1631    int top = 0;
1632    int left = 0;
1633    int bytes_per_line = input.width * input.numChannels;
1634    if (type == DS_DEVICE_OPENCL_DEVICE) {
1635  #  if ON_WINDOWS
1636      QueryPerformanceCounter(&amp;time_funct_start);
1637  #  elif ON_APPLE
1638      start = mach_absolute_time();
1639  #  else
1640      clock_gettime(CLOCK_MONOTONIC, &amp;time_funct_start);
1641  #  endif
1642      OpenclDevice::gpuEnv = *env;
1643      int hi_values[4];
1644      int retVal = OpenclDevice::ThresholdRectToPixOCL(
1645          input.imageData, input.numChannels, bytes_per_line, thresholds, hi_values, &amp;input.pix,
1646          input.height, input.width, top, left);
1647  #  if ON_WINDOWS
1648      QueryPerformanceCounter(&amp;time_funct_end);
1649      time = (time_funct_end.QuadPart - time_funct_start.QuadPart) / (double)(freq.QuadPart);
1650  #  elif ON_APPLE
1651      stop = mach_absolute_time();
1652      if (retVal == 0) {
1653        time = ((stop - start) * (double)info.numer / info.denom) / 1.0E9;
1654      } else {
1655        time = FLT_MAX;
1656      }
1657  #  else
1658      clock_gettime(CLOCK_MONOTONIC, &amp;time_funct_end);
1659      time = (time_funct_end.tv_sec - time_funct_start.tv_sec) * 1.0 +
1660             (time_funct_end.tv_nsec - time_funct_start.tv_nsec) / 1000000000.0;
1661  #  endif
1662    } else {
1663      tesseract::ImageThresholder thresholder;
1664      thresholder.SetImage(input.pix);
1665  #  if ON_WINDOWS
1666      QueryPerformanceCounter(&amp;time_funct_start);
1667  #  elif ON_APPLE
1668      start = mach_absolute_time();
1669  #  else
1670      clock_gettime(CLOCK_MONOTONIC, &amp;time_funct_start);
1671  #  endif
1672      int hi_values[4] = {};
1673      ThresholdRectToPix_Native(input.imageData, input.numChannels, bytes_per_line, thresholds,
1674                                hi_values, &amp;input.pix);
1675  #  if ON_WINDOWS
1676      QueryPerformanceCounter(&amp;time_funct_end);
1677      time = (time_funct_end.QuadPart - time_funct_start.QuadPart) / (double)(freq.QuadPart);
1678  #  elif ON_APPLE
1679      stop = mach_absolute_time();
1680      time = ((stop - start) * (double)info.numer / info.denom) / 1.0E9;
1681  #  else
1682      clock_gettime(CLOCK_MONOTONIC, &amp;time_funct_end);
1683      time = (time_funct_end.tv_sec - time_funct_start.tv_sec) * 1.0 +
1684             (time_funct_end.tv_nsec - time_funct_start.tv_nsec) / 1000000000.0;
1685  #  endif
1686    }
1687    return time;
1688  }
1689  static double getLineMasksMorphMicroBench(GPUEnv *env, TessScoreEvaluationInputData input,
1690                                            ds_device_type type) {
1691    double time = 0;
1692  #  if ON_WINDOWS
1693    LARGE_INTEGER freq, time_funct_start, time_funct_end;
1694    QueryPerformanceFrequency(&amp;freq);
1695  #  elif ON_APPLE
1696    mach_timebase_info_data_t info = {0, 0};
1697    mach_timebase_info(&amp;info);
1698    long long start, stop;
1699  #  else
1700    timespec time_funct_start, time_funct_end;
1701  #  endif
1702    int resolution = 300;
1703    int wpl = pixGetWpl(input.pix);
1704    int kThinLineFraction = 20;     
1705    int kMinLineLengthFraction = 4; 
1706    int max_line_width = resolution / kThinLineFraction;
1707    int min_line_length = resolution / kMinLineLengthFraction;
1708    int closing_brick = max_line_width / 3;
1709    if (type == DS_DEVICE_OPENCL_DEVICE) {
1710  #  if ON_WINDOWS
1711      QueryPerformanceCounter(&amp;time_funct_start);
1712  #  elif ON_APPLE
1713      start = mach_absolute_time();
1714  #  else
1715      clock_gettime(CLOCK_MONOTONIC, &amp;time_funct_start);
1716  #  endif
1717      OpenclDevice::gpuEnv = *env;
1718      OpenclDevice::initMorphCLAllocations(wpl, input.height, input.pix);
1719      Image pix_vline = nullptr, pix_hline = nullptr, pix_closed = nullptr;
1720      OpenclDevice::pixGetLinesCL(nullptr, input.pix, &amp;pix_vline, &amp;pix_hline, &amp;pix_closed, true,
1721                                  closing_brick, closing_brick, max_line_width, max_line_width,
1722                                  min_line_length, min_line_length);
1723      OpenclDevice::releaseMorphCLBuffers();
1724  #  if ON_WINDOWS
1725      QueryPerformanceCounter(&amp;time_funct_end);
1726      time = (time_funct_end.QuadPart - time_funct_start.QuadPart) / (double)(freq.QuadPart);
1727  #  elif ON_APPLE
1728      stop = mach_absolute_time();
1729      time = ((stop - start) * (double)info.numer / info.denom) / 1.0E9;
1730  #  else
1731      clock_gettime(CLOCK_MONOTONIC, &amp;time_funct_end);
1732      time = (time_funct_end.tv_sec - time_funct_start.tv_sec) * 1.0 +
1733             (time_funct_end.tv_nsec - time_funct_start.tv_nsec) / 1000000000.0;
1734  #  endif
1735    } else {
1736  #  if ON_WINDOWS
1737      QueryPerformanceCounter(&amp;time_funct_start);
1738  #  elif ON_APPLE
1739      start = mach_absolute_time();
1740  #  else
1741      clock_gettime(CLOCK_MONOTONIC, &amp;time_funct_start);
1742  #  endif
1743      Image src_pix = input.pix;
1744      Image pix_closed = pixCloseBrick(nullptr, src_pix, closing_brick, closing_brick);
1745      Image pix_solid = pixOpenBrick(nullptr, pix_closed, max_line_width, max_line_width);
1746      Image pix_hollow = pixSubtract(nullptr, pix_closed, pix_solid);
1747      pix_solid.destroy();
1748      Image pix_vline = pixOpenBrick(nullptr, pix_hollow, 1, min_line_length);
1749      Image pix_hline = pixOpenBrick(nullptr, pix_hollow, min_line_length, 1);
1750      pix_hline.destroy();
1751      pix_vline.destroy();
1752      pix_hollow.destroy();
1753  #  if ON_WINDOWS
1754      QueryPerformanceCounter(&amp;time_funct_end);
1755      time = (time_funct_end.QuadPart - time_funct_start.QuadPart) / (double)(freq.QuadPart);
1756  #  elif ON_APPLE
1757      stop = mach_absolute_time();
1758      time = ((stop - start) * (double)info.numer / info.denom) / 1.0E9;
1759  #  else
1760      clock_gettime(CLOCK_MONOTONIC, &amp;time_funct_end);
1761      time = (time_funct_end.tv_sec - time_funct_start.tv_sec) * 1.0 +
1762             (time_funct_end.tv_nsec - time_funct_start.tv_nsec) / 1000000000.0;
1763  #  endif
1764    }
1765    return time;
1766  }
1767  static ds_status serializeScore(ds_device *device, uint8_t **serializedScore,
1768                                  unsigned int *serializedScoreSize) {
1769    *serializedScoreSize = sizeof(TessDeviceScore);
1770    *serializedScore = new uint8_t[*serializedScoreSize];
1771    memcpy(*serializedScore, device-&gt;score, *serializedScoreSize);
1772    return DS_SUCCESS;
1773  }
1774  static ds_status deserializeScore(ds_device *device, const uint8_t *serializedScore,
1775                                    unsigned int serializedScoreSize) {
1776    device-&gt;score = new TessDeviceScore;
1777    memcpy(device-&gt;score, serializedScore, serializedScoreSize);
1778    return DS_SUCCESS;
1779  }
1780  static ds_status releaseScore(TessDeviceScore *score) {
1781    delete score;
1782    return DS_SUCCESS;
1783  }
1784  static ds_status evaluateScoreForDevice(ds_device *device, void *inputData) {
1785    tprintf(&quot;\n[DS] Device: \&quot;%s\&quot; (%s) evaluation...\n&quot;, device-&gt;oclDeviceName,
1786            device-&gt;type == DS_DEVICE_OPENCL_DEVICE ? &quot;OpenCL&quot; : &quot;Native&quot;);
1787    GPUEnv *env = nullptr;
1788    if (device-&gt;type == DS_DEVICE_OPENCL_DEVICE) {
1789      env = &amp;OpenclDevice::gpuEnv;
1790      memset(env, 0, sizeof(*env));
1791      populateGPUEnvFromDevice(env, device-&gt;oclDeviceID);
1792      env-&gt;mnFileCount = 0; 
1793      env-&gt;mnKernelCount = 0UL;
1794      OpenclDevice::CompileKernelFile(env, &quot;&quot;);
1795    }
1796    TessScoreEvaluationInputData *input = static_cast&lt;TessScoreEvaluationInputData *&gt;(inputData);
1797    double composeRGBPixelTime = composeRGBPixelMicroBench(env, *input, device-&gt;type);
1798    double histogramRectTime = histogramRectMicroBench(env, *input, device-&gt;type);
1799    double thresholdRectToPixTime = thresholdRectToPixMicroBench(env, *input, device-&gt;type);
1800    double getLineMasksMorphTime = getLineMasksMorphMicroBench(env, *input, device-&gt;type);
1801    float composeRGBPixelWeight = 1.2f;
1802    float histogramRectWeight = 2.4f;
1803    float thresholdRectToPixWeight = 4.5f;
1804    float getLineMasksMorphWeight = 5.0f;
1805    float weightedTime = composeRGBPixelWeight * composeRGBPixelTime +
1806                         histogramRectWeight * histogramRectTime +
1807                         thresholdRectToPixWeight * thresholdRectToPixTime +
1808                         getLineMasksMorphWeight * getLineMasksMorphTime;
1809    device-&gt;score = new TessDeviceScore;
1810    device-&gt;score-&gt;time = weightedTime;
1811    tprintf(&quot;[DS] Device: \&quot;%s\&quot; (%s) evaluated\n&quot;, device-&gt;oclDeviceName,
1812            device-&gt;type == DS_DEVICE_OPENCL_DEVICE ? &quot;OpenCL&quot; : &quot;Native&quot;);
1813    tprintf(&quot;[DS]%25s: %f (w=%.1f)\n&quot;, &quot;composeRGBPixel&quot;, composeRGBPixelTime, composeRGBPixelWeight);
1814    tprintf(&quot;[DS]%25s: %f (w=%.1f)\n&quot;, &quot;HistogramRect&quot;, histogramRectTime, histogramRectWeight);
1815    tprintf(&quot;[DS]%25s: %f (w=%.1f)\n&quot;, &quot;ThresholdRectToPix&quot;, thresholdRectToPixTime,
1816            thresholdRectToPixWeight);
1817    tprintf(&quot;[DS]%25s: %f (w=%.1f)\n&quot;, &quot;getLineMasksMorph&quot;, getLineMasksMorphTime,
1818            getLineMasksMorphWeight);
1819    tprintf(&quot;[DS]%25s: %f\n&quot;, &quot;Score&quot;, device-&gt;score-&gt;time);
1820    return DS_SUCCESS;
1821  }
1822  ds_device OpenclDevice::getDeviceSelection() {
1823    if (!deviceIsSelected) {
1824      if (1 == LoadOpencl()) {
1825        ds_status status;
1826        ds_profile *profile;
1827        status = initDSProfile(&amp;profile, &quot;v0.1&quot;);
1828        const char *fileName = &quot;tesseract_opencl_profile_devices.dat&quot;;
1829        status = readProfileFromFile(profile, deserializeScore, fileName);
1830        if (status != DS_SUCCESS) {
1831          tprintf(&quot;[DS] Profile file not available (%s); performing profiling.\n&quot;, fileName);
1832          TessScoreEvaluationInputData input;
1833          populateTessScoreEvaluationInputData(&amp;input);
1834          unsigned int numUpdates;
1835          status =
1836              profileDevices(profile, DS_EVALUATE_ALL, evaluateScoreForDevice, &amp;input, &amp;numUpdates);
1837          if (status == DS_SUCCESS) {
1838            status = writeProfileToFile(profile, serializeScore, fileName);
1839            if (status == DS_SUCCESS) {
1840              tprintf(&quot;[DS] Scores written to file (%s).\n&quot;, fileName);
1841            } else {
1842              tprintf(
1843                  &quot;[DS] Error saving scores to file (%s); scores not written to &quot;
1844                  &quot;file.\n&quot;,
1845                  fileName);
1846            }
1847          } else {
1848            tprintf(
1849                &quot;[DS] Unable to evaluate performance; scores not written to &quot;
1850                &quot;file.\n&quot;);
1851          }
1852        } else {
1853          tprintf(&quot;[DS] Profile read from file (%s).\n&quot;, fileName);
1854        }
1855        float bestTime = FLT_MAX; 
1856        int bestDeviceIdx = -1;
1857        for (unsigned d = 0; d &lt; profile-&gt;numDevices; d++) {
1858          ds_device device = profile-&gt;devices[d];
1859          if (device.score == nullptr)
1860            continue;
1861          TessDeviceScore score = *device.score;
1862          float time = score.time;
1863          tprintf(&quot;[DS] Device[%u] %i:%s score is %f\n&quot;, d + 1, device.type, device.oclDeviceName,
1864                  time);
1865          if (time &lt; bestTime) {
1866            bestTime = time;
1867            bestDeviceIdx = d;
1868          }
1869        }
1870        if (bestDeviceIdx &gt;= 0) {
1871          tprintf(
1872              &quot;[DS] Selected Device[%i]: \&quot;%s\&quot; (%s)\n&quot;, bestDeviceIdx + 1,
1873              profile-&gt;devices[bestDeviceIdx].oclDeviceName,
1874              profile-&gt;devices[bestDeviceIdx].type == DS_DEVICE_OPENCL_DEVICE ? &quot;OpenCL&quot; : &quot;Native&quot;);
1875        }
1876        bool overridden = false;
1877        char *overrideDeviceStr = getenv(&quot;TESSERACT_OPENCL_DEVICE&quot;);
1878        if (overrideDeviceStr != nullptr) {
1879          int overrideDeviceIdx = atoi(overrideDeviceStr);
1880          if (overrideDeviceIdx &gt; 0 &amp;&amp; overrideDeviceIdx &lt;= profile-&gt;numDevices) {
1881            tprintf(
1882                &quot;[DS] Overriding Device Selection (TESSERACT_OPENCL_DEVICE=%s, &quot;
1883                &quot;%i)\n&quot;,
1884                overrideDeviceStr, overrideDeviceIdx);
1885            bestDeviceIdx = overrideDeviceIdx - 1;
1886            overridden = true;
1887          } else {
1888            tprintf(
1889                &quot;[DS] Ignoring invalid TESSERACT_OPENCL_DEVICE=%s ([1,%i] are &quot;
1890                &quot;valid devices).\n&quot;,
1891                overrideDeviceStr, profile-&gt;numDevices);
1892          }
1893        }
1894        if (overridden) {
1895          tprintf(
1896              &quot;[DS] Overridden Device[%i]: \&quot;%s\&quot; (%s)\n&quot;, bestDeviceIdx + 1,
1897              profile-&gt;devices[bestDeviceIdx].oclDeviceName,
1898              profile-&gt;devices[bestDeviceIdx].type == DS_DEVICE_OPENCL_DEVICE ? &quot;OpenCL&quot; : &quot;Native&quot;);
1899        }
1900        selectedDevice = profile-&gt;devices[bestDeviceIdx];
1901        releaseDSProfile(profile, releaseScore);
1902      } else {
1903        tprintf(&quot;[DS] OpenCL runtime not available.\n&quot;);
1904        selectedDevice.type = DS_DEVICE_NATIVE_CPU;
1905        selectedDevice.oclDeviceName = &quot;(null)&quot;;
1906        selectedDevice.score = nullptr;
1907        selectedDevice.oclDeviceID = nullptr;
1908        selectedDevice.oclDriverVersion = nullptr;
1909      }
1910      deviceIsSelected = true;
1911    }
1912    return selectedDevice;
1913  }
1914  bool OpenclDevice::selectedDeviceIsOpenCL() {
1915    ds_device device = getDeviceSelection();
1916    return (device.type == DS_DEVICE_OPENCL_DEVICE);
1917  }
1918  } 
1919  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-openclwrapper.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include &quot;config_auto.h&quot;
3  #endif
4  #ifdef USE_OPENCL
5  #  ifdef _WIN32
6  #    include &lt;io.h&gt;
7  #    include &lt;windows.h&gt;
8  #  else
9  #    include &lt;sys/types.h&gt;
10  #    include &lt;unistd.h&gt;
11  #  endif
12  #  include &lt;cfloat&gt;
13  #  include &lt;ctime&gt; 
14  #  include &quot;oclkernels.h&quot;
15  #  include &quot;openclwrapper.h&quot;
16  #  include &quot;otsuthr.h&quot;
17  #  include &quot;thresholder.h&quot;
18  #  if defined(WIN32) || defined(__WIN32__) || defined(_WIN32) || defined(__CYGWIN__) || \
19        defined(__MINGW32__)
20  #    define ON_WINDOWS 1
21  #    define ON_APPLE 0
22  #  elif defined(__linux__)
23  #    define ON_WINDOWS 0
24  #    define ON_APPLE 0
25  #  elif defined(__APPLE__)
26  #    define ON_WINDOWS 0
27  #    define ON_APPLE 1
28  #  else
29  #    define ON_WINDOWS 0
30  #    define ON_APPLE 0
31  #  endif
32  #  if ON_APPLE
33  #    include &lt;mach/mach_time.h&gt;
34  #  endif
35  #  include &lt;cstdio&gt;
36  #  include &lt;cstdlib&gt;
37  #  include &lt;cstring&gt; 
38  #  include &lt;vector&gt;
39  #  include &quot;errcode.h&quot; 
40  #  include &quot;image.h&quot;   
41  namespace tesseract {
42  GPUEnv OpenclDevice::gpuEnv;
43  bool OpenclDevice::deviceIsSelected = false;
44  ds_device OpenclDevice::selectedDevice;
45  int OpenclDevice::isInited = 0;
46  static l_int32 MORPH_BC = ASYMMETRIC_MORPH_BC;
47  static const l_uint32 lmask32[] = {
48      0x80000000, 0xc0000000, 0xe0000000, 0xf0000000, 0xf8000000, 0xfc000000, 0xfe000000, 0xff000000,
49      0xff800000, 0xffc00000, 0xffe00000, 0xfff00000, 0xfff80000, 0xfffc0000, 0xfffe0000, 0xffff0000,
50      0xffff8000, 0xffffc000, 0xffffe000, 0xfffff000, 0xfffff800, 0xfffffc00, 0xfffffe00, 0xffffff00,
51      0xffffff80, 0xffffffc0, 0xffffffe0, 0xfffffff0, 0xfffffff8, 0xfffffffc, 0xfffffffe, 0xffffffff};
52  static const l_uint32 rmask32[] = {
53      0x00000001, 0x00000003, 0x00000007, 0x0000000f, 0x0000001f, 0x0000003f, 0x0000007f, 0x000000ff,
54      0x000001ff, 0x000003ff, 0x000007ff, 0x00000fff, 0x00001fff, 0x00003fff, 0x00007fff, 0x0000ffff,
55      0x0001ffff, 0x0003ffff, 0x0007ffff, 0x000fffff, 0x001fffff, 0x003fffff, 0x007fffff, 0x00ffffff,
56      0x01ffffff, 0x03ffffff, 0x07ffffff, 0x0fffffff, 0x1fffffff, 0x3fffffff, 0x7fffffff, 0xffffffff};
57  static cl_mem pixsCLBuffer, pixdCLBuffer,
58      pixdCLIntermediate;    
59  static cl_mem pixThBuffer; 
60  static cl_int clStatus;
61  static KernelEnv rEnv;
62  #  define DS_TAG_VERSION &quot;&lt;version&gt;&quot;
63  #  define DS_TAG_VERSION_END &quot;&lt;/version&gt;&quot;
64  #  define DS_TAG_DEVICE &quot;&lt;device&gt;&quot;
65  #  define DS_TAG_DEVICE_END &quot;&lt;/device&gt;&quot;
66  #  define DS_TAG_SCORE &quot;&lt;score&gt;&quot;
67  #  define DS_TAG_SCORE_END &quot;&lt;/score&gt;&quot;
68  #  define DS_TAG_DEVICE_TYPE &quot;&lt;type&gt;&quot;
69  #  define DS_TAG_DEVICE_TYPE_END &quot;&lt;/type&gt;&quot;
70  #  define DS_TAG_DEVICE_NAME &quot;&lt;name&gt;&quot;
71  #  define DS_TAG_DEVICE_NAME_END &quot;&lt;/name&gt;&quot;
72  #  define DS_TAG_DEVICE_DRIVER_VERSION &quot;&lt;driver&gt;&quot;
73  #  define DS_TAG_DEVICE_DRIVER_VERSION_END &quot;&lt;/driver&gt;&quot;
74  #  define DS_DEVICE_NATIVE_CPU_STRING &quot;native_cpu&quot;
75  #  define DS_DEVICE_NAME_LENGTH 256
76  enum ds_evaluation_type { DS_EVALUATE_ALL, DS_EVALUATE_NEW_ONLY };
77  struct ds_profile {
78    std::vector&lt;ds_device&gt; devices;
79    unsigned int numDevices;
80    const char *version;
81  };
82  enum ds_status {
83    DS_SUCCESS = 0,
84    DS_INVALID_PROFILE = 1000,
85    DS_MEMORY_ERROR,
86    DS_INVALID_PERF_EVALUATOR_TYPE,
87    DS_INVALID_PERF_EVALUATOR,
88    DS_PERF_EVALUATOR_ERROR,
89    DS_FILE_ERROR,
90    DS_UNKNOWN_DEVICE_TYPE,
91    DS_PROFILE_FILE_ERROR,
92    DS_SCORE_SERIALIZER_ERROR,
93    DS_SCORE_DESERIALIZER_ERROR
94  };
95  typedef ds_status (*ds_perf_evaluator)(ds_device *device, void *data);
96  typedef ds_status (*ds_score_release)(TessDeviceScore *score);
97  static ds_status releaseDSProfile(ds_profile *profile, ds_score_release sr) {
98    ds_status status = DS_SUCCESS;
99    if (profile != nullptr) {
100      if (sr != nullptr) {
101        unsigned int i;
102        for (i = 0; i &lt; profile-&gt;numDevices; i++) {
103          free(profile-&gt;devices[i].oclDeviceName);
104          free(profile-&gt;devices[i].oclDriverVersion);
105          status = sr(profile-&gt;devices[i].score);
106          if (status != DS_SUCCESS)
107            break;
108        }
109      }
110      delete profile;
111    }
112    return status;
113  }
114  static ds_status initDSProfile(ds_profile **p, const char *version) {
115    int numDevices;
116    cl_uint numPlatforms;
117    std::vector&lt;cl_platform_id&gt; platforms;
118    std::vector&lt;cl_device_id&gt; devices;
119    ds_status status = DS_SUCCESS;
120    unsigned int next;
121    unsigned int i;
122    if (p == nullptr)
123      return DS_INVALID_PROFILE;
124    ds_profile *profile = new ds_profile;
125    memset(profile, 0, sizeof(ds_profile));
126    clGetPlatformIDs(0, nullptr, &amp;numPlatforms);
127    if (numPlatforms &gt; 0) {
128      platforms.reserve(numPlatforms);
129      clGetPlatformIDs(numPlatforms, &amp;platforms[0], nullptr);
130    }
131    numDevices = 0;
132    for (i = 0; i &lt; numPlatforms; i++) {
133      cl_uint num;
134      clGetDeviceIDs(platforms[i], CL_DEVICE_TYPE_ALL, 0, nullptr, &amp;num);
135      numDevices += num;
136    }
137    if (numDevices &gt; 0) {
138      devices.reserve(numDevices);
139    }
140    profile-&gt;numDevices = numDevices + 1; 
141    profile-&gt;devices.reserve(profile-&gt;numDevices);
142    memset(&amp;profile-&gt;devices[0], 0, profile-&gt;numDevices * sizeof(ds_device));
143    next = 0;
144    for (i = 0; i &lt; numPlatforms; i++) {
145      cl_uint num;
146      unsigned j;
147      clGetDeviceIDs(platforms[i], CL_DEVICE_TYPE_ALL, numDevices, &amp;devices[0], &amp;num);
148      for (j = 0; j &lt; num; j++, next++) {
149        char buffer[DS_DEVICE_NAME_LENGTH];
150        size_t length;
151        profile-&gt;devices[next].type = DS_DEVICE_OPENCL_DEVICE;
152        profile-&gt;devices[next].oclDeviceID = devices[j];
153        clGetDeviceInfo(profile-&gt;devices[next].oclDeviceID, CL_DEVICE_NAME, DS_DEVICE_NAME_LENGTH,
154                        &amp;buffer, nullptr);
155        length = strlen(buffer);
156        profile-&gt;devices[next].oclDeviceName = (char *)malloc(length + 1);
157        memcpy(profile-&gt;devices[next].oclDeviceName, buffer, length + 1);
158        clGetDeviceInfo(profile-&gt;devices[next].oclDeviceID, CL_DRIVER_VERSION, DS_DEVICE_NAME_LENGTH,
159                        &amp;buffer, nullptr);
160        length = strlen(buffer);
161        profile-&gt;devices[next].oclDriverVersion = (char *)malloc(length + 1);
162        memcpy(profile-&gt;devices[next].oclDriverVersion, buffer, length + 1);
163      }
164    }
165    profile-&gt;devices[next].type = DS_DEVICE_NATIVE_CPU;
166    profile-&gt;version = version;
167    *p = profile;
168    return status;
169  }
170  static ds_status profileDevices(ds_profile *profile, const ds_evaluation_type type,
171                                  ds_perf_evaluator evaluator, void *evaluatorData,
172                                  unsigned int *numUpdates) {
173    ds_status status = DS_SUCCESS;
174    unsigned int i;
175    unsigned int updates = 0;
176    if (profile == nullptr) {
177      return DS_INVALID_PROFILE;
178    }
179    if (evaluator == nullptr) {
180      return DS_INVALID_PERF_EVALUATOR;
181    }
182    for (i = 0; i &lt; profile-&gt;numDevices; i++) {
183      ds_status evaluatorStatus;
184      switch (type) {
185        case DS_EVALUATE_NEW_ONLY:
186          if (profile-&gt;devices[i].score != nullptr)
187            break;
188        case DS_EVALUATE_ALL:
189          evaluatorStatus = evaluator(&amp;profile-&gt;devices[i], evaluatorData);
190          if (evaluatorStatus != DS_SUCCESS) {
191            status = evaluatorStatus;
192            return status;
193          }
194          updates++;
195          break;
196        default:
197          return DS_INVALID_PERF_EVALUATOR_TYPE;
198          break;
199      };
200    }
201    if (numUpdates)
202      *numUpdates = updates;
203    return status;
204  }
205  static const char *findString(const char *contentStart, const char *contentEnd,
206                                const char *string) {
207    size_t stringLength;
208    const char *currentPosition;
209    const char *found = nullptr;
210    stringLength = strlen(string);
211    currentPosition = contentStart;
212    for (currentPosition = contentStart; currentPosition &lt; contentEnd; currentPosition++) {
213      if (*currentPosition == string[0]) {
214        if (currentPosition + stringLength &lt; contentEnd) {
215          if (strncmp(currentPosition, string, stringLength) == 0) {
216            found = currentPosition;
217            break;
218          }
219        }
220      }
221    }
222    return found;
223  }
224  static ds_status readProFile(const char *fileName, char **content, size_t *contentSize) {
225    *contentSize = 0;
226    *content = nullptr;
227    ds_status status = DS_SUCCESS;
228    FILE *input = fopen(fileName, &quot;rb&quot;);
229    if (input == nullptr) {
230      status = DS_FILE_ERROR;
231    } else {
232      fseek(input, 0L, SEEK_END);
233      auto pos = std::ftell(input);
234      rewind(input);
235      if (pos &gt; 0) {
236        size_t size = pos;
237        char *binary = new char[size];
238        if (fread(binary, sizeof(char), size, input) != size) {
239          status = DS_FILE_ERROR;
240          delete[] binary;
241        } else {
242          *contentSize = size;
243          *content = binary;
244        }
245      }
246      fclose(input);
247    }
248    return status;
249  }
250  typedef ds_status (*ds_score_deserializer)(ds_device *device, const uint8_t *serializedScore,
251                                             unsigned int serializedScoreSize);
252  static ds_status readProfileFromFile(ds_profile *profile, ds_score_deserializer deserializer,
253                                       const char *file) {
254    ds_status status = DS_SUCCESS;
255    char *contentStart;
256    size_t contentSize;
257    if (profile == nullptr)
258      return DS_INVALID_PROFILE;
259    status = readProFile(file, &amp;contentStart, &amp;contentSize);
260    if (status == DS_SUCCESS) {
261      const char *currentPosition;
262      const char *dataStart;
263      const char *dataEnd;
264      const char *contentEnd = contentStart + contentSize;
265      currentPosition = contentStart;
266      dataStart = findString(currentPosition, contentEnd, DS_TAG_VERSION);
267      if (dataStart == nullptr) {
268        status = DS_PROFILE_FILE_ERROR;
269        goto cleanup;
270      }
271      dataStart += strlen(DS_TAG_VERSION);
272      dataEnd = findString(dataStart, contentEnd, DS_TAG_VERSION_END);
273      if (dataEnd == nullptr) {
274        status = DS_PROFILE_FILE_ERROR;
275        goto cleanup;
276      }
277      size_t versionStringLength = strlen(profile-&gt;version);
278      if (versionStringLength + dataStart != dataEnd ||
279          strncmp(profile-&gt;version, dataStart, versionStringLength) != 0) {
280        status = DS_PROFILE_FILE_ERROR;
281        goto cleanup;
282      }
283      currentPosition = dataEnd + strlen(DS_TAG_VERSION_END);
284      while (1) {
285        unsigned int i;
286        const char *deviceTypeStart;
287        const char *deviceTypeEnd;
288        ds_device_type deviceType;
289        const char *deviceNameStart;
290        const char *deviceNameEnd;
291        const char *deviceScoreStart;
292        const char *deviceScoreEnd;
293        const char *deviceDriverStart;
294        const char *deviceDriverEnd;
295        dataStart = findString(currentPosition, contentEnd, DS_TAG_DEVICE);
296        if (dataStart == nullptr) {
297          break;
298        }
299        dataStart += strlen(DS_TAG_DEVICE);
300        dataEnd = findString(dataStart, contentEnd, DS_TAG_DEVICE_END);
301        if (dataEnd == nullptr) {
302          status = DS_PROFILE_FILE_ERROR;
303          goto cleanup;
304        }
305        deviceTypeStart = findString(dataStart, contentEnd, DS_TAG_DEVICE_TYPE);
306        if (deviceTypeStart == nullptr) {
307          status = DS_PROFILE_FILE_ERROR;
308          goto cleanup;
309        }
310        deviceTypeStart += strlen(DS_TAG_DEVICE_TYPE);
311        deviceTypeEnd = findString(deviceTypeStart, contentEnd, DS_TAG_DEVICE_TYPE_END);
312        if (deviceTypeEnd == nullptr) {
313          status = DS_PROFILE_FILE_ERROR;
314          goto cleanup;
315        }
316        memcpy(&amp;deviceType, deviceTypeStart, sizeof(ds_device_type));
317        if (deviceType == DS_DEVICE_OPENCL_DEVICE) {
318          deviceNameStart = findString(dataStart, contentEnd, DS_TAG_DEVICE_NAME);
319          if (deviceNameStart == nullptr) {
320            status = DS_PROFILE_FILE_ERROR;
321            goto cleanup;
322          }
323          deviceNameStart += strlen(DS_TAG_DEVICE_NAME);
324          deviceNameEnd = findString(deviceNameStart, contentEnd, DS_TAG_DEVICE_NAME_END);
325          if (deviceNameEnd == nullptr) {
326            status = DS_PROFILE_FILE_ERROR;
327            goto cleanup;
328          }
329          deviceDriverStart = findString(dataStart, contentEnd, DS_TAG_DEVICE_DRIVER_VERSION);
330          if (deviceDriverStart == nullptr) {
331            status = DS_PROFILE_FILE_ERROR;
332            goto cleanup;
333          }
334          deviceDriverStart += strlen(DS_TAG_DEVICE_DRIVER_VERSION);
335          deviceDriverEnd =
336              findString(deviceDriverStart, contentEnd, DS_TAG_DEVICE_DRIVER_VERSION_END);
337          if (deviceDriverEnd == nullptr) {
338            status = DS_PROFILE_FILE_ERROR;
339            goto cleanup;
340          }
341          for (i = 0; i &lt; profile-&gt;numDevices; i++) {
342            if (profile-&gt;devices[i].type == DS_DEVICE_OPENCL_DEVICE) {
343              size_t actualDeviceNameLength;
344              size_t driverVersionLength;
345              actualDeviceNameLength = strlen(profile-&gt;devices[i].oclDeviceName);
346              driverVersionLength = strlen(profile-&gt;devices[i].oclDriverVersion);
347              if (deviceNameStart + actualDeviceNameLength == deviceNameEnd &amp;&amp;
348                  deviceDriverStart + driverVersionLength == deviceDriverEnd &amp;&amp;
349                  strncmp(profile-&gt;devices[i].oclDeviceName, deviceNameStart,
350                          actualDeviceNameLength) == 0 &amp;&amp;
351                  strncmp(profile-&gt;devices[i].oclDriverVersion, deviceDriverStart,
352                          driverVersionLength) == 0) {
353                deviceScoreStart = findString(dataStart, contentEnd, DS_TAG_SCORE);
354                deviceScoreStart += strlen(DS_TAG_SCORE);
355                deviceScoreEnd = findString(deviceScoreStart, contentEnd, DS_TAG_SCORE_END);
356                status = deserializer(&amp;profile-&gt;devices[i], (const unsigned char *)deviceScoreStart,
357                                      deviceScoreEnd - deviceScoreStart);
358                if (status != DS_SUCCESS) {
359                  goto cleanup;
360                }
361              }
362            }
363          }
364        } else if (deviceType == DS_DEVICE_NATIVE_CPU) {
365          for (i = 0; i &lt; profile-&gt;numDevices; i++) {
366            if (profile-&gt;devices[i].type == DS_DEVICE_NATIVE_CPU) {
367              deviceScoreStart = findString(dataStart, contentEnd, DS_TAG_SCORE);
368              if (deviceScoreStart == nullptr) {
369                status = DS_PROFILE_FILE_ERROR;
370                goto cleanup;
371              }
372              deviceScoreStart += strlen(DS_TAG_SCORE);
373              deviceScoreEnd = findString(deviceScoreStart, contentEnd, DS_TAG_SCORE_END);
374              status = deserializer(&amp;profile-&gt;devices[i], (const unsigned char *)deviceScoreStart,
375                                    deviceScoreEnd - deviceScoreStart);
376              if (status != DS_SUCCESS) {
377                goto cleanup;
378              }
379            }
380          }
381        }
382        currentPosition = dataEnd + strlen(DS_TAG_DEVICE_END);
383      }
384    }
385  cleanup:
386    delete[] contentStart;
387    return status;
388  }
389  typedef ds_status (*ds_score_serializer)(ds_device *device, uint8_t **serializedScore,
390                                           unsigned int *serializedScoreSize);
391  static ds_status writeProfileToFile(ds_profile *profile, ds_score_serializer serializer,
392                                      const char *file) {
393    ds_status status = DS_SUCCESS;
394    if (profile == nullptr)
395      return DS_INVALID_PROFILE;
396    FILE *profileFile = fopen(file, &quot;wb&quot;);
397    if (profileFile == nullptr) {
398      status = DS_FILE_ERROR;
399    } else {
400      unsigned int i;
401      fwrite(DS_TAG_VERSION, sizeof(char), strlen(DS_TAG_VERSION), profileFile);
402      fwrite(profile-&gt;version, sizeof(char), strlen(profile-&gt;version), profileFile);
403      fwrite(DS_TAG_VERSION_END, sizeof(char), strlen(DS_TAG_VERSION_END), profileFile);
404      fwrite(&quot;\n&quot;, sizeof(char), 1, profileFile);
405      for (i = 0; i &lt; profile-&gt;numDevices &amp;&amp; status == DS_SUCCESS; i++) {
406        uint8_t *serializedScore;
407        unsigned int serializedScoreSize;
408        fwrite(DS_TAG_DEVICE, sizeof(char), strlen(DS_TAG_DEVICE), profileFile);
409        fwrite(DS_TAG_DEVICE_TYPE, sizeof(char), strlen(DS_TAG_DEVICE_TYPE), profileFile);
410        fwrite(&amp;profile-&gt;devices[i].type, sizeof(ds_device_type), 1, profileFile);
411        fwrite(DS_TAG_DEVICE_TYPE_END, sizeof(char), strlen(DS_TAG_DEVICE_TYPE_END), profileFile);
412        switch (profile-&gt;devices[i].type) {
413          case DS_DEVICE_NATIVE_CPU: {
414          } break;
415          case DS_DEVICE_OPENCL_DEVICE: {
416            fwrite(DS_TAG_DEVICE_NAME, sizeof(char), strlen(DS_TAG_DEVICE_NAME), profileFile);
417            fwrite(profile-&gt;devices[i].oclDeviceName, sizeof(char),
418                   strlen(profile-&gt;devices[i].oclDeviceName), profileFile);
419            fwrite(DS_TAG_DEVICE_NAME_END, sizeof(char), strlen(DS_TAG_DEVICE_NAME_END), profileFile);
420            fwrite(DS_TAG_DEVICE_DRIVER_VERSION, sizeof(char), strlen(DS_TAG_DEVICE_DRIVER_VERSION),
421                   profileFile);
422            fwrite(profile-&gt;devices[i].oclDriverVersion, sizeof(char),
423                   strlen(profile-&gt;devices[i].oclDriverVersion), profileFile);
424            fwrite(DS_TAG_DEVICE_DRIVER_VERSION_END, sizeof(char),
425                   strlen(DS_TAG_DEVICE_DRIVER_VERSION_END), profileFile);
426          } break;
427          default:
428            status = DS_UNKNOWN_DEVICE_TYPE;
429            continue;
430        };
431        fwrite(DS_TAG_SCORE, sizeof(char), strlen(DS_TAG_SCORE), profileFile);
432        status = serializer(&amp;profile-&gt;devices[i], &amp;serializedScore, &amp;serializedScoreSize);
433        if (status == DS_SUCCESS &amp;&amp; serializedScore != nullptr &amp;&amp; serializedScoreSize &gt; 0) {
434          fwrite(serializedScore, sizeof(char), serializedScoreSize, profileFile);
435          delete[] serializedScore;
436        }
437        fwrite(DS_TAG_SCORE_END, sizeof(char), strlen(DS_TAG_SCORE_END), profileFile);
438        fwrite(DS_TAG_DEVICE_END, sizeof(char), strlen(DS_TAG_DEVICE_END), profileFile);
439        fwrite(&quot;\n&quot;, sizeof(char), 1, profileFile);
440      }
441      fclose(profileFile);
442    }
443    return status;
444  }
445  static void legalizeFileName(char *fileName) {
446    const char *invalidChars = &quot;/\?:*\&quot;&gt;&lt;| &quot;; 
447    for (unsigned i = 0; i &lt; strlen(invalidChars); i++) {
448      char invalidStr[4];
449      invalidStr[0] = invalidChars[i];
450      invalidStr[1] = &#x27;\0&#x27;;
451      for (char *pos = strstr(fileName, invalidStr); pos != nullptr;
452           pos = strstr(pos + 1, invalidStr)) {
453        pos[0] = &#x27;_&#x27;;
454      }
455    }
456  }
457  static void populateGPUEnvFromDevice(GPUEnv *gpuInfo, cl_device_id device) {
458    size_t size;
459    gpuInfo-&gt;mnIsUserCreated = 1;
460    gpuInfo-&gt;mpDevID = device;
461    gpuInfo-&gt;mpArryDevsID = new cl_device_id[1];
462    gpuInfo-&gt;mpArryDevsID[0] = gpuInfo-&gt;mpDevID;
463    clStatus = clGetDeviceInfo(gpuInfo-&gt;mpDevID, CL_DEVICE_TYPE, sizeof(cl_device_type),
464                               &amp;gpuInfo-&gt;mDevType, &amp;size);
465    CHECK_OPENCL(clStatus, &quot;populateGPUEnv::getDeviceInfo(TYPE)&quot;);
466    clStatus = clGetDeviceInfo(gpuInfo-&gt;mpDevID, CL_DEVICE_PLATFORM, sizeof(cl_platform_id),
467                               &amp;gpuInfo-&gt;mpPlatformID, &amp;size);
468    CHECK_OPENCL(clStatus, &quot;populateGPUEnv::getDeviceInfo(PLATFORM)&quot;);
469    cl_context_properties props[3];
470    props[0] = CL_CONTEXT_PLATFORM;
471    props[1] = (cl_context_properties)gpuInfo-&gt;mpPlatformID;
472    props[2] = 0;
473    gpuInfo-&gt;mpContext = clCreateContext(props, 1, &amp;gpuInfo-&gt;mpDevID, nullptr, nullptr, &amp;clStatus);
474    CHECK_OPENCL(clStatus, &quot;populateGPUEnv::createContext&quot;);
475    cl_command_queue_properties queueProperties = 0;
476    gpuInfo-&gt;mpCmdQueue =
477        clCreateCommandQueue(gpuInfo-&gt;mpContext, gpuInfo-&gt;mpDevID, queueProperties, &amp;clStatus);
478    CHECK_OPENCL(clStatus, &quot;populateGPUEnv::createCommandQueue&quot;);
479  }
480  int OpenclDevice::LoadOpencl() {
481  #  ifdef WIN32
482    HINSTANCE HOpenclDll = nullptr;
483    void *OpenclDll = nullptr;
484    OpenclDll = static_cast&lt;HINSTANCE&gt;(HOpenclDll);
485    OpenclDll = LoadLibrary(&quot;openCL.dll&quot;);
486    if (!static_cast&lt;HINSTANCE&gt;(OpenclDll)) {
487      fprintf(stderr, &quot;[OD] Load opencl.dll failed!\n&quot;);
488      FreeLibrary(static_cast&lt;HINSTANCE&gt;(OpenclDll));
489      return 0;
490    }
491    fprintf(stderr, &quot;[OD] Load opencl.dll successful!\n&quot;);
492  #  endif
493    return 1;
494  }
495  int OpenclDevice::SetKernelEnv(KernelEnv *envInfo) {
496    envInfo-&gt;mpkContext = gpuEnv.mpContext;
497    envInfo-&gt;mpkCmdQueue = gpuEnv.mpCmdQueue;
498    envInfo-&gt;mpkProgram = gpuEnv.mpArryPrograms[0];
499    return 1;
500  }
501  static cl_mem allocateZeroCopyBuffer(const KernelEnv &amp;rEnv, l_uint32 *hostbuffer, size_t nElements,
502                                       cl_mem_flags flags, cl_int *pStatus) {
503    cl_mem membuffer = clCreateBuffer(rEnv.mpkContext, (cl_mem_flags)(flags),
504                                      nElements * sizeof(l_uint32), hostbuffer, pStatus);
505    return membuffer;
506  }
507  static Image mapOutputCLBuffer(const KernelEnv &amp;rEnv, cl_mem clbuffer, Image pixd, Image pixs,
508                                int elements, cl_mem_flags flags, bool memcopy = false,
509                                bool sync = true) {
510    if (!pixd) {
511      if (memcopy) {
512        if ((pixd = pixCreateTemplate(pixs)) == nullptr)
513          tprintf(&quot;pixd not made\n&quot;);
514      } else {
515        if ((pixd = pixCreateHeader(pixGetWidth(pixs), pixGetHeight(pixs), pixGetDepth(pixs))) ==
516            nullptr)
517          tprintf(&quot;pixd not made\n&quot;);
518      }
519    }
520    l_uint32 *pValues =
521        (l_uint32 *)clEnqueueMapBuffer(rEnv.mpkCmdQueue, clbuffer, CL_TRUE, flags, 0,
522                                       elements * sizeof(l_uint32), 0, nullptr, nullptr, nullptr);
523    if (memcopy) {
524      memcpy(pixGetData(pixd), pValues, elements * sizeof(l_uint32));
525    } else {
526      pixSetData(pixd, pValues);
527    }
528    clEnqueueUnmapMemObject(rEnv.mpkCmdQueue, clbuffer, pValues, 0, nullptr, nullptr);
529    if (sync) {
530      clFinish(rEnv.mpkCmdQueue);
531    }
532    return pixd;
533  }
534  void OpenclDevice::releaseMorphCLBuffers() {
535    if (pixdCLIntermediate != nullptr)
536      clReleaseMemObject(pixdCLIntermediate);
537    if (pixsCLBuffer != nullptr)
538      clReleaseMemObject(pixsCLBuffer);
539    if (pixdCLBuffer != nullptr)
540      clReleaseMemObject(pixdCLBuffer);
541    if (pixThBuffer != nullptr)
542      clReleaseMemObject(pixThBuffer);
543    pixdCLIntermediate = pixsCLBuffer = pixdCLBuffer = pixThBuffer = nullptr;
544  }
545  int OpenclDevice::initMorphCLAllocations(l_int32 wpl, l_int32 h, Image pixs) {
546    SetKernelEnv(&amp;rEnv);
547    if (pixThBuffer != nullptr) {
548      pixsCLBuffer = allocateZeroCopyBuffer(rEnv, nullptr, wpl * h, CL_MEM_ALLOC_HOST_PTR, &amp;clStatus);
549      clStatus = clEnqueueCopyBuffer(rEnv.mpkCmdQueue, pixThBuffer, pixsCLBuffer, 0, 0,
550                                     sizeof(l_uint32) * wpl * h, 0, nullptr, nullptr);
551    } else {
552      l_uint32 *srcdata = reinterpret_cast&lt;l_uint32 *&gt;(malloc(wpl * h * sizeof(l_uint32)));
553      memcpy(srcdata, pixGetData(pixs), wpl * h * sizeof(l_uint32));
554      pixsCLBuffer = allocateZeroCopyBuffer(rEnv, srcdata, wpl * h, CL_MEM_USE_HOST_PTR, &amp;clStatus);
555    }
556    pixdCLBuffer = allocateZeroCopyBuffer(rEnv, nullptr, wpl * h, CL_MEM_ALLOC_HOST_PTR, &amp;clStatus);
557    pixdCLIntermediate =
558        allocateZeroCopyBuffer(rEnv, nullptr, wpl * h, CL_MEM_ALLOC_HOST_PTR, &amp;clStatus);
559    return (int)clStatus;
560  }
561  int OpenclDevice::InitEnv() {
562  #  ifdef SAL_WIN32
563    while (1) {
564      if (1 == LoadOpencl())
565        break;
566    }
567  #  endif
568    InitOpenclRunEnv_DeviceSelection(0);
569    return 1;
570  }
571  int OpenclDevice::ReleaseOpenclRunEnv() {
572    ReleaseOpenclEnv(&amp;gpuEnv);
573  #  ifdef SAL_WIN32
574    FreeOpenclDll();
575  #  endif
576    return 1;
577  }
578  inline int OpenclDevice::AddKernelConfig(int kCount, const char *kName) {
579    ASSERT_HOST(kCount &gt; 0);
580    ASSERT_HOST(strlen(kName) &lt; sizeof(gpuEnv.mArrykernelNames[kCount - 1]));
581    strcpy(gpuEnv.mArrykernelNames[kCount - 1], kName);
582    gpuEnv.mnKernelCount++;
583    return 0;
584  }
585  int OpenclDevice::RegistOpenclKernel() {
586    if (!gpuEnv.mnIsUserCreated)
587      memset(&amp;gpuEnv, 0, sizeof(gpuEnv));
588    gpuEnv.mnFileCount = 0; 
589    gpuEnv.mnKernelCount = 0UL;
590    AddKernelConfig(1, &quot;oclAverageSub1&quot;);
591    return 0;
592  }
593  int OpenclDevice::InitOpenclRunEnv_DeviceSelection(int argc) {
594    if (!isInited) {
595      ds_device bestDevice_DS = getDeviceSelection();
596      cl_device_id bestDevice = bestDevice_DS.oclDeviceID;
597      if (selectedDeviceIsOpenCL()) {
598        populateGPUEnvFromDevice(&amp;gpuEnv, bestDevice);
599        gpuEnv.mnFileCount = 0; 
600        gpuEnv.mnKernelCount = 0UL;
601        CompileKernelFile(&amp;gpuEnv, &quot;&quot;);
602      } else {
603      }
604      isInited = 1;
605    }
606    return 0;
607  }
608  OpenclDevice::OpenclDevice() {
609  }
610  OpenclDevice::~OpenclDevice() {
611  }
612  int OpenclDevice::ReleaseOpenclEnv(GPUEnv *gpuInfo) {
613    int i = 0;
614    int clStatus = 0;
615    if (!isInited) {
616      return 1;
617    }
618    for (i = 0; i &lt; gpuEnv.mnFileCount; i++) {
619      if (gpuEnv.mpArryPrograms[i]) {
620        clStatus = clReleaseProgram(gpuEnv.mpArryPrograms[i]);
621        CHECK_OPENCL(clStatus, &quot;clReleaseProgram&quot;);
622        gpuEnv.mpArryPrograms[i] = nullptr;
623      }
624    }
625    if (gpuEnv.mpCmdQueue) {
626      clReleaseCommandQueue(gpuEnv.mpCmdQueue);
627      gpuEnv.mpCmdQueue = nullptr;
628    }
629    if (gpuEnv.mpContext) {
630      clReleaseContext(gpuEnv.mpContext);
631      gpuEnv.mpContext = nullptr;
632    }
633    isInited = 0;
634    gpuInfo-&gt;mnIsUserCreated = 0;
635    delete[] gpuInfo-&gt;mpArryDevsID;
636    return 1;
637  }
638  int OpenclDevice::BinaryGenerated(const char *clFileName, FILE **fhandle) {
639    unsigned int i = 0;
640    cl_int clStatus;
641    int status = 0;
642    FILE *fd = nullptr;
643    char fileName[256];
644    char cl_name[128];
645    char deviceName[1024];
646    clStatus = clGetDeviceInfo(gpuEnv.mpArryDevsID[i], CL_DEVICE_NAME, sizeof(deviceName), deviceName,
647                               nullptr);
648    CHECK_OPENCL(clStatus, &quot;clGetDeviceInfo&quot;);
649    const char *str = strstr(clFileName, &quot;.cl&quot;);
650    memcpy(cl_name, clFileName, str - clFileName);
651    cl_name[str - clFileName] = &#x27;\0&#x27;;
652    snprintf(fileName, sizeof(fileName), &quot;%s-%s.bin&quot;, cl_name, deviceName);
653    legalizeFileName(fileName);
654    fd = fopen(fileName, &quot;rb&quot;);
655    status = (fd != nullptr) ? 1 : 0;
656    if (fd != nullptr) {
657      *fhandle = fd;
658    }
659    return status;
660  }
661  int OpenclDevice::CachedOfKernerPrg(const GPUEnv *gpuEnvCached, const char *clFileName) {
662    int i;
663    for (i = 0; i &lt; gpuEnvCached-&gt;mnFileCount; i++) {
664      if (strcasecmp(gpuEnvCached-&gt;mArryKnelSrcFile[i], clFileName) == 0) {
665        if (gpuEnvCached-&gt;mpArryPrograms[i] != nullptr) {
666          return 1;
667        }
668      }
669    }
670    return 0;
671  }
672  int OpenclDevice::WriteBinaryToFile(const char *fileName, const char *birary, size_t numBytes) {
673    FILE *output = nullptr;
674    output = fopen(fileName, &quot;wb&quot;);
675    if (output == nullptr) {
676      return 0;
677    }
678    fwrite(birary, sizeof(char), numBytes, output);
679    fclose(output);
680    return 1;
681  }
682  int OpenclDevice::GeneratBinFromKernelSource(cl_program program, const char *clFileName) {
683    unsigned int i = 0;
684    cl_int clStatus;
685    cl_uint numDevices;
686    clStatus =
687        clGetProgramInfo(program, CL_PROGRAM_NUM_DEVICES, sizeof(numDevices), &amp;numDevices, nullptr);
688    CHECK_OPENCL(clStatus, &quot;clGetProgramInfo&quot;);
689    std::vector&lt;cl_device_id&gt; mpArryDevsID(numDevices);
690    clStatus = clGetProgramInfo(program, CL_PROGRAM_DEVICES, sizeof(cl_device_id) * numDevices,
691                                &amp;mpArryDevsID[0], nullptr);
692    CHECK_OPENCL(clStatus, &quot;clGetProgramInfo&quot;);
693    std::vector&lt;size_t&gt; binarySizes(numDevices);
694    clStatus = clGetProgramInfo(program, CL_PROGRAM_BINARY_SIZES, sizeof(size_t) * numDevices,
695                                &amp;binarySizes[0], nullptr);
696    CHECK_OPENCL(clStatus, &quot;clGetProgramInfo&quot;);
697    std::vector&lt;char *&gt; binaries(numDevices);
698    for (i = 0; i &lt; numDevices; i++) {
699      if (binarySizes[i] != 0) {
700        binaries[i] = new char[binarySizes[i]];
701      } else {
702        binaries[i] = nullptr;
703      }
704    }
705    clStatus = clGetProgramInfo(program, CL_PROGRAM_BINARIES, sizeof(char *) * numDevices,
706                                &amp;binaries[0], nullptr);
707    CHECK_OPENCL(clStatus, &quot;clGetProgramInfo&quot;);
708    for (i = 0; i &lt; numDevices; i++) {
709      if (binarySizes[i] != 0) {
710        char fileName[256];
711        char cl_name[128];
712        char deviceName[1024];
713        clStatus =
714            clGetDeviceInfo(mpArryDevsID[i], CL_DEVICE_NAME, sizeof(deviceName), deviceName, nullptr);
715        CHECK_OPENCL(clStatus, &quot;clGetDeviceInfo&quot;);
716        const char *str = strstr(clFileName, &quot;.cl&quot;);
717        memcpy(cl_name, clFileName, str - clFileName);
718        cl_name[str - clFileName] = &#x27;\0&#x27;;
719        snprintf(fileName, sizeof(fileName), &quot;%s-%s.bin&quot;, cl_name, deviceName);
720        legalizeFileName(fileName);
721        if (!WriteBinaryToFile(fileName, binaries[i], binarySizes[i])) {
722          tprintf(&quot;[OD] write binary[%s] failed\n&quot;, fileName);
723          return 0;
724        } 
725        tprintf(&quot;[OD] write binary[%s] successfully\n&quot;, fileName);
726      }
727    }
728    for (i = 0; i &lt; numDevices; i++) {
729      delete[] binaries[i];
730    }
731    return 1;
732  }
733  int OpenclDevice::CompileKernelFile(GPUEnv *gpuInfo, const char *buildOption) {
734    cl_int clStatus = 0;
735    const char *source;
736    size_t source_size[1];
737    int binary_status, binaryExisted, idx;
738    cl_uint numDevices;
739    FILE *fd, *fd1;
740    const char *filename = &quot;kernel.cl&quot;;
741    if (CachedOfKernerPrg(gpuInfo, filename) == 1) {
742      return 1;
743    }
744    idx = gpuInfo-&gt;mnFileCount;
745    source = kernel_src;
746    source_size[0] = strlen(source);
747    binaryExisted = 0;
748    binaryExisted = BinaryGenerated(filename, &amp;fd); 
749    if (binaryExisted == 1) {
750      clStatus = clGetContextInfo(gpuInfo-&gt;mpContext, CL_CONTEXT_NUM_DEVICES, sizeof(numDevices),
751                                  &amp;numDevices, nullptr);
752      CHECK_OPENCL(clStatus, &quot;clGetContextInfo&quot;);
753      std::vector&lt;cl_device_id&gt; mpArryDevsID(numDevices);
754      bool b_error = fseek(fd, 0, SEEK_END) &lt; 0;
755      auto pos = std::ftell(fd);
756      b_error |= (pos &lt;= 0);
757      size_t length = pos;
758      b_error |= fseek(fd, 0, SEEK_SET) &lt; 0;
759      if (b_error) {
760        fclose(fd);
761        return 0;
762      }
763      std::vector&lt;uint8_t&gt; binary(length + 2);
764      memset(&amp;binary[0], 0, length + 2);
765      b_error |= fread(&amp;binary[0], 1, length, fd) != length;
766      fclose(fd);
767      fd = nullptr;
768      clStatus = clGetContextInfo(gpuInfo-&gt;mpContext, CL_CONTEXT_DEVICES,
769                                  sizeof(cl_device_id) * numDevices, &amp;mpArryDevsID[0], nullptr);
770      CHECK_OPENCL(clStatus, &quot;clGetContextInfo&quot;);
771      const uint8_t *c_binary = &amp;binary[0];
772      gpuInfo-&gt;mpArryPrograms[idx] =
773          clCreateProgramWithBinary(gpuInfo-&gt;mpContext, numDevices, &amp;mpArryDevsID[0], &amp;length,
774                                    &amp;c_binary, &amp;binary_status, &amp;clStatus);
775      CHECK_OPENCL(clStatus, &quot;clCreateProgramWithBinary&quot;);
776    } else {
777      gpuInfo-&gt;mpArryPrograms[idx] =
778          clCreateProgramWithSource(gpuInfo-&gt;mpContext, 1, &amp;source, source_size, &amp;clStatus);
779      CHECK_OPENCL(clStatus, &quot;clCreateProgramWithSource&quot;);
780    }
781    if (gpuInfo-&gt;mpArryPrograms[idx] == (cl_program) nullptr) {
782      return 0;
783    }
784    if (!gpuInfo-&gt;mnIsUserCreated) {
785      clStatus = clBuildProgram(gpuInfo-&gt;mpArryPrograms[idx], 1, gpuInfo-&gt;mpArryDevsID, buildOption,
786                                nullptr, nullptr);
787    } else {
788      clStatus = clBuildProgram(gpuInfo-&gt;mpArryPrograms[idx], 1, &amp;(gpuInfo-&gt;mpDevID), buildOption,
789                                nullptr, nullptr);
790    }
791    if (clStatus != CL_SUCCESS) {
792      tprintf(&quot;BuildProgram error!\n&quot;);
793      size_t length;
794      if (!gpuInfo-&gt;mnIsUserCreated) {
795        clStatus = clGetProgramBuildInfo(gpuInfo-&gt;mpArryPrograms[idx], gpuInfo-&gt;mpArryDevsID[0],
796                                         CL_PROGRAM_BUILD_LOG, 0, nullptr, &amp;length);
797      } else {
798        clStatus = clGetProgramBuildInfo(gpuInfo-&gt;mpArryPrograms[idx], gpuInfo-&gt;mpDevID,
799                                         CL_PROGRAM_BUILD_LOG, 0, nullptr, &amp;length);
800      }
801      if (clStatus != CL_SUCCESS) {
802        tprintf(&quot;opencl create build log fail\n&quot;);
803        return 0;
804      }
805      std::vector&lt;char&gt; buildLog(length);
806      if (!gpuInfo-&gt;mnIsUserCreated) {
807        clStatus = clGetProgramBuildInfo(gpuInfo-&gt;mpArryPrograms[idx], gpuInfo-&gt;mpArryDevsID[0],
808                                         CL_PROGRAM_BUILD_LOG, length, &amp;buildLog[0], &amp;length);
809      } else {
810        clStatus = clGetProgramBuildInfo(gpuInfo-&gt;mpArryPrograms[idx], gpuInfo-&gt;mpDevID,
811                                         CL_PROGRAM_BUILD_LOG, length, &amp;buildLog[0], &amp;length);
812      }
813      if (clStatus != CL_SUCCESS) {
814        tprintf(&quot;opencl program build info fail\n&quot;);
815        return 0;
816      }
817      fd1 = fopen(&quot;kernel-build.log&quot;, &quot;w+&quot;);
818      if (fd1 != nullptr) {
819        fwrite(&amp;buildLog[0], sizeof(char), length, fd1);
820        fclose(fd1);
821      }
822      return 0;
823    }
824    strcpy(gpuInfo-&gt;mArryKnelSrcFile[idx], filename);
825    if (binaryExisted == 0) {
826      GeneratBinFromKernelSource(gpuInfo-&gt;mpArryPrograms[idx], filename);
827    }
828    gpuInfo-&gt;mnFileCount += 1;
829    return 1;
830  }
831  l_uint32 *OpenclDevice::pixReadFromTiffKernel(l_uint32 *tiffdata, l_int32 w, l_int32 h, l_int32 wpl,
832                                                l_uint32 *line) {
833    cl_int clStatus;
834    KernelEnv rEnv;
835    size_t globalThreads[2];
836    size_t localThreads[2];
837    int gsize;
838    cl_mem valuesCl;
839    cl_mem outputCl;
840    gsize = (w + GROUPSIZE_X - 1) / GROUPSIZE_X * GROUPSIZE_X;
841    globalThreads[0] = gsize;
842    gsize = (h + GROUPSIZE_Y - 1) / GROUPSIZE_Y * GROUPSIZE_Y;
843    globalThreads[1] = gsize;
844    localThreads[0] = GROUPSIZE_X;
845    localThreads[1] = GROUPSIZE_Y;
846    SetKernelEnv(&amp;rEnv);
847    l_uint32 *pResult = (l_uint32 *)malloc(w * h * sizeof(l_uint32));
848    rEnv.mpkKernel = clCreateKernel(rEnv.mpkProgram, &quot;composeRGBPixel&quot;, &amp;clStatus);
849    CHECK_OPENCL(clStatus, &quot;clCreateKernel composeRGBPixel&quot;);
850    valuesCl = allocateZeroCopyBuffer(rEnv, tiffdata, w * h, CL_MEM_READ_ONLY | CL_MEM_USE_HOST_PTR,
851                                      &amp;clStatus);
852    outputCl = allocateZeroCopyBuffer(rEnv, pResult, w * h, CL_MEM_WRITE_ONLY | CL_MEM_USE_HOST_PTR,
853                                      &amp;clStatus);
854    clStatus = clSetKernelArg(rEnv.mpkKernel, 0, sizeof(cl_mem), &amp;valuesCl);
855    CHECK_OPENCL(clStatus, &quot;clSetKernelArg&quot;);
856    clStatus = clSetKernelArg(rEnv.mpkKernel, 1, sizeof(w), &amp;w);
857    CHECK_OPENCL(clStatus, &quot;clSetKernelArg&quot;);
858    clStatus = clSetKernelArg(rEnv.mpkKernel, 2, sizeof(h), &amp;h);
859    CHECK_OPENCL(clStatus, &quot;clSetKernelArg&quot;);
860    clStatus = clSetKernelArg(rEnv.mpkKernel, 3, sizeof(wpl), &amp;wpl);
861    CHECK_OPENCL(clStatus, &quot;clSetKernelArg&quot;);
862    clStatus = clSetKernelArg(rEnv.mpkKernel, 4, sizeof(cl_mem), &amp;outputCl);
863    CHECK_OPENCL(clStatus, &quot;clSetKernelArg&quot;);
864    clStatus = clEnqueueNDRangeKernel(rEnv.mpkCmdQueue, rEnv.mpkKernel, 2, nullptr, globalThreads,
865                                      localThreads, 0, nullptr, nullptr);
866    CHECK_OPENCL(clStatus, &quot;clEnqueueNDRangeKernel&quot;);
867    void *ptr = clEnqueueMapBuffer(rEnv.mpkCmdQueue, outputCl, CL_TRUE, CL_MAP_READ, 0,
868                                   w * h * sizeof(l_uint32), 0, nullptr, nullptr, &amp;clStatus);
869    CHECK_OPENCL(clStatus, &quot;clEnqueueMapBuffer outputCl&quot;);
870    clEnqueueUnmapMemObject(rEnv.mpkCmdQueue, outputCl, ptr, 0, nullptr, nullptr);
871    clFinish(rEnv.mpkCmdQueue);
872    return pResult;
873  }
874  static cl_int pixDilateCL_55(l_int32 wpl, l_int32 h) {
875    size_t globalThreads[2];
876    cl_mem pixtemp;
877    cl_int status;
878    int gsize;
879    size_t localThreads[2];
880    gsize = (wpl * h + GROUPSIZE_HMORX - 1) / GROUPSIZE_HMORX * GROUPSIZE_HMORX;
881    globalThreads[0] = gsize;
882    globalThreads[1] = GROUPSIZE_HMORY;
883    localThreads[0] = GROUPSIZE_HMORX;
884    localThreads[1] = GROUPSIZE_HMORY;
885    rEnv.mpkKernel = clCreateKernel(rEnv.mpkProgram, &quot;morphoDilateHor_5x5&quot;, &amp;status);
886    CHECK_OPENCL(status, &quot;clCreateKernel morphoDilateHor_5x5&quot;);
887    status = clSetKernelArg(rEnv.mpkKernel, 0, sizeof(cl_mem), &amp;pixsCLBuffer);
888    status = clSetKernelArg(rEnv.mpkKernel, 1, sizeof(cl_mem), &amp;pixdCLBuffer);
889    status = clSetKernelArg(rEnv.mpkKernel, 2, sizeof(wpl), &amp;wpl);
890    status = clSetKernelArg(rEnv.mpkKernel, 3, sizeof(h), &amp;h);
891    status = clEnqueueNDRangeKernel(rEnv.mpkCmdQueue, rEnv.mpkKernel, 2, nullptr, globalThreads,
892                                    localThreads, 0, nullptr, nullptr);
893    pixtemp = pixsCLBuffer;
894    pixsCLBuffer = pixdCLBuffer;
895    pixdCLBuffer = pixtemp;
896    gsize = (wpl + GROUPSIZE_X - 1) / GROUPSIZE_X * GROUPSIZE_X;
897    globalThreads[0] = gsize;
898    gsize = (h + GROUPSIZE_Y - 1) / GROUPSIZE_Y * GROUPSIZE_Y;
899    globalThreads[1] = gsize;
900    localThreads[0] = GROUPSIZE_X;
901    localThreads[1] = GROUPSIZE_Y;
902    rEnv.mpkKernel = clCreateKernel(rEnv.mpkProgram, &quot;morphoDilateVer_5x5&quot;, &amp;status);
903    CHECK_OPENCL(status, &quot;clCreateKernel morphoDilateVer_5x5&quot;);
904    status = clSetKernelArg(rEnv.mpkKernel, 0, sizeof(cl_mem), &amp;pixsCLBuffer);
905    status = clSetKernelArg(rEnv.mpkKernel, 1, sizeof(cl_mem), &amp;pixdCLBuffer);
906    status = clSetKernelArg(rEnv.mpkKernel, 2, sizeof(wpl), &amp;wpl);
907    status = clSetKernelArg(rEnv.mpkKernel, 3, sizeof(h), &amp;h);
908    status = clEnqueueNDRangeKernel(rEnv.mpkCmdQueue, rEnv.mpkKernel, 2, nullptr, globalThreads,
909                                    localThreads, 0, nullptr, nullptr);
910    return status;
911  }
912  static cl_int pixErodeCL_55(l_int32 wpl, l_int32 h) {
913    size_t globalThreads[2];
914    cl_mem pixtemp;
915    cl_int status;
916    int gsize;
917    l_uint32 fwmask, lwmask;
918    size_t localThreads[2];
919    lwmask = lmask32[31 - 2];
920    fwmask = rmask32[31 - 2];
921    gsize = (wpl * h + GROUPSIZE_HMORX - 1) / GROUPSIZE_HMORX * GROUPSIZE_HMORX;
922    globalThreads[0] = gsize;
923    globalThreads[1] = GROUPSIZE_HMORY;
924    localThreads[0] = GROUPSIZE_HMORX;
925    localThreads[1] = GROUPSIZE_HMORY;
926    rEnv.mpkKernel = clCreateKernel(rEnv.mpkProgram, &quot;morphoErodeHor_5x5&quot;, &amp;status);
927    CHECK_OPENCL(status, &quot;clCreateKernel morphoErodeHor_5x5&quot;);
928    status = clSetKernelArg(rEnv.mpkKernel, 0, sizeof(cl_mem), &amp;pixsCLBuffer);
929    status = clSetKernelArg(rEnv.mpkKernel, 1, sizeof(cl_mem), &amp;pixdCLBuffer);
930    status = clSetKernelArg(rEnv.mpkKernel, 2, sizeof(wpl), &amp;wpl);
931    status = clSetKernelArg(rEnv.mpkKernel, 3, sizeof(h), &amp;h);
932    status = clEnqueueNDRangeKernel(rEnv.mpkCmdQueue, rEnv.mpkKernel, 2, nullptr, globalThreads,
933                                    localThreads, 0, nullptr, nullptr);
934    pixtemp = pixsCLBuffer;
935    pixsCLBuffer = pixdCLBuffer;
936    pixdCLBuffer = pixtemp;
937    gsize = (wpl + GROUPSIZE_X - 1) / GROUPSIZE_X * GROUPSIZE_X;
938    globalThreads[0] = gsize;
939    gsize = (h + GROUPSIZE_Y - 1) / GROUPSIZE_Y * GROUPSIZE_Y;
940    globalThreads[1] = gsize;
941    localThreads[0] = GROUPSIZE_X;
942    localThreads[1] = GROUPSIZE_Y;
943    rEnv.mpkKernel = clCreateKernel(rEnv.mpkProgram, &quot;morphoErodeVer_5x5&quot;, &amp;status);
944    CHECK_OPENCL(status, &quot;clCreateKernel morphoErodeVer_5x5&quot;);
945    status = clSetKernelArg(rEnv.mpkKernel, 0, sizeof(cl_mem), &amp;pixsCLBuffer);
946    status = clSetKernelArg(rEnv.mpkKernel, 1, sizeof(cl_mem), &amp;pixdCLBuffer);
947    status = clSetKernelArg(rEnv.mpkKernel, 2, sizeof(wpl), &amp;wpl);
948    status = clSetKernelArg(rEnv.mpkKernel, 3, sizeof(h), &amp;h);
949    status = clSetKernelArg(rEnv.mpkKernel, 4, sizeof(fwmask), &amp;fwmask);
950    status = clSetKernelArg(rEnv.mpkKernel, 5, sizeof(lwmask), &amp;lwmask);
951    status = clEnqueueNDRangeKernel(rEnv.mpkCmdQueue, rEnv.mpkKernel, 2, nullptr, globalThreads,
952                                    localThreads, 0, nullptr, nullptr);
953    return status;
954  }
955  static cl_int pixDilateCL(l_int32 hsize, l_int32 vsize, l_int32 wpl, l_int32 h) {
956    l_int32 xp, yp, xn, yn;
957    SEL *sel;
958    size_t globalThreads[2];
959    cl_mem pixtemp;
960    cl_int status = 0;
961    int gsize;
962    size_t localThreads[2];
963    char isEven;
964    OpenclDevice::SetKernelEnv(&amp;rEnv);
965    if (hsize == 5 &amp;&amp; vsize == 5) {
966      status = pixDilateCL_55(wpl, h);
967      return status;
968    }
969    sel = selCreateBrick(vsize, hsize, vsize / 2, hsize / 2, SEL_HIT);
970    selFindMaxTranslations(sel, &amp;xp, &amp;yp, &amp;xn, &amp;yn);
971    selDestroy(&amp;sel);
972    gsize = (wpl + GROUPSIZE_X - 1) / GROUPSIZE_X * GROUPSIZE_X;
973    globalThreads[0] = gsize;
974    gsize = (h + GROUPSIZE_Y - 1) / GROUPSIZE_Y * GROUPSIZE_Y;
975    globalThreads[1] = gsize;
976    localThreads[0] = GROUPSIZE_X;
977    localThreads[1] = GROUPSIZE_Y;
978    if (xp &gt; 31 || xn &gt; 31) {
979      rEnv.mpkKernel = clCreateKernel(rEnv.mpkProgram, &quot;morphoDilateHor&quot;, &amp;status);
980      CHECK_OPENCL(status, &quot;clCreateKernel morphoDilateHor&quot;);
981      status = clSetKernelArg(rEnv.mpkKernel, 0, sizeof(cl_mem), &amp;pixsCLBuffer);
982      status = clSetKernelArg(rEnv.mpkKernel, 1, sizeof(cl_mem), &amp;pixdCLBuffer);
983      status = clSetKernelArg(rEnv.mpkKernel, 2, sizeof(xp), &amp;xp);
984      status = clSetKernelArg(rEnv.mpkKernel, 3, sizeof(xn), &amp;xn);
985      status = clSetKernelArg(rEnv.mpkKernel, 4, sizeof(wpl), &amp;wpl);
986      status = clSetKernelArg(rEnv.mpkKernel, 5, sizeof(h), &amp;h);
987      status = clEnqueueNDRangeKernel(rEnv.mpkCmdQueue, rEnv.mpkKernel, 2, nullptr, globalThreads,
988                                      localThreads, 0, nullptr, nullptr);
989      if (yp &gt; 0 || yn &gt; 0) {
990        pixtemp = pixsCLBuffer;
991        pixsCLBuffer = pixdCLBuffer;
992        pixdCLBuffer = pixtemp;
993      }
994    } else if (xp &gt; 0 || xn &gt; 0) {
995      rEnv.mpkKernel = clCreateKernel(rEnv.mpkProgram, &quot;morphoDilateHor_32word&quot;, &amp;status);
996      CHECK_OPENCL(status, &quot;clCreateKernel morphoDilateHor_32word&quot;);
997      isEven = (xp != xn);
998      status = clSetKernelArg(rEnv.mpkKernel, 0, sizeof(cl_mem), &amp;pixsCLBuffer);
999      status = clSetKernelArg(rEnv.mpkKernel, 1, sizeof(cl_mem), &amp;pixdCLBuffer);
1000      status = clSetKernelArg(rEnv.mpkKernel, 2, sizeof(xp), &amp;xp);
1001      status = clSetKernelArg(rEnv.mpkKernel, 3, sizeof(wpl), &amp;wpl);
1002      status = clSetKernelArg(rEnv.mpkKernel, 4, sizeof(h), &amp;h);
1003      status = clSetKernelArg(rEnv.mpkKernel, 5, sizeof(isEven), &amp;isEven);
1004      status = clEnqueueNDRangeKernel(rEnv.mpkCmdQueue, rEnv.mpkKernel, 2, nullptr, globalThreads,
1005                                      localThreads, 0, nullptr, nullptr);
1006      if (yp &gt; 0 || yn &gt; 0) {
1007        pixtemp = pixsCLBuffer;
1008        pixsCLBuffer = pixdCLBuffer;
1009        pixdCLBuffer = pixtemp;
1010      }
1011    }
1012    if (yp &gt; 0 || yn &gt; 0) {
1013      rEnv.mpkKernel = clCreateKernel(rEnv.mpkProgram, &quot;morphoDilateVer&quot;, &amp;status);
1014      CHECK_OPENCL(status, &quot;clCreateKernel morphoDilateVer&quot;);
1015      status = clSetKernelArg(rEnv.mpkKernel, 0, sizeof(cl_mem), &amp;pixsCLBuffer);
1016      status = clSetKernelArg(rEnv.mpkKernel, 1, sizeof(cl_mem), &amp;pixdCLBuffer);
1017      status = clSetKernelArg(rEnv.mpkKernel, 2, sizeof(yp), &amp;yp);
1018      status = clSetKernelArg(rEnv.mpkKernel, 3, sizeof(wpl), &amp;wpl);
1019      status = clSetKernelArg(rEnv.mpkKernel, 4, sizeof(h), &amp;h);
1020      status = clSetKernelArg(rEnv.mpkKernel, 5, sizeof(yn), &amp;yn);
1021      status = clEnqueueNDRangeKernel(rEnv.mpkCmdQueue, rEnv.mpkKernel, 2, nullptr, globalThreads,
1022                                      localThreads, 0, nullptr, nullptr);
1023    }
1024    return status;
1025  }
1026  static cl_int pixErodeCL(l_int32 hsize, l_int32 vsize, l_uint32 wpl, l_uint32 h) {
1027    l_int32 xp, yp, xn, yn;
1028    SEL *sel;
1029    size_t globalThreads[2];
1030    size_t localThreads[2];
1031    cl_mem pixtemp;
1032    cl_int status = 0;
1033    int gsize;
1034    char isAsymmetric = (MORPH_BC == ASYMMETRIC_MORPH_BC);
1035    l_uint32 rwmask, lwmask;
1036    char isEven;
1037    sel = selCreateBrick(vsize, hsize, vsize / 2, hsize / 2, SEL_HIT);
1038    selFindMaxTranslations(sel, &amp;xp, &amp;yp, &amp;xn, &amp;yn);
1039    selDestroy(&amp;sel);
1040    OpenclDevice::SetKernelEnv(&amp;rEnv);
1041    if (hsize == 5 &amp;&amp; vsize == 5 &amp;&amp; isAsymmetric) {
1042      status = pixErodeCL_55(wpl, h);
1043      return status;
1044    }
1045    lwmask = lmask32[31 - (xn &amp; 31)];
1046    rwmask = rmask32[31 - (xp &amp; 31)];
1047    gsize = (wpl + GROUPSIZE_X - 1) / GROUPSIZE_X * GROUPSIZE_X;
1048    globalThreads[0] = gsize;
1049    gsize = (h + GROUPSIZE_Y - 1) / GROUPSIZE_Y * GROUPSIZE_Y;
1050    globalThreads[1] = gsize;
1051    localThreads[0] = GROUPSIZE_X;
1052    localThreads[1] = GROUPSIZE_Y;
1053    if (xp &gt; 31 || xn &gt; 31) {
1054      rEnv.mpkKernel = clCreateKernel(rEnv.mpkProgram, &quot;morphoErodeHor&quot;, &amp;status);
1055      status = clSetKernelArg(rEnv.mpkKernel, 0, sizeof(cl_mem), &amp;pixsCLBuffer);
1056      status = clSetKernelArg(rEnv.mpkKernel, 1, sizeof(cl_mem), &amp;pixdCLBuffer);
1057      status = clSetKernelArg(rEnv.mpkKernel, 2, sizeof(xp), &amp;xp);
1058      status = clSetKernelArg(rEnv.mpkKernel, 3, sizeof(xn), &amp;xn);
1059      status = clSetKernelArg(rEnv.mpkKernel, 4, sizeof(wpl), &amp;wpl);
1060      status = clSetKernelArg(rEnv.mpkKernel, 5, sizeof(h), &amp;h);
1061      status = clSetKernelArg(rEnv.mpkKernel, 6, sizeof(isAsymmetric), &amp;isAsymmetric);
1062      status = clSetKernelArg(rEnv.mpkKernel, 7, sizeof(rwmask), &amp;rwmask);
1063      status = clSetKernelArg(rEnv.mpkKernel, 8, sizeof(lwmask), &amp;lwmask);
1064      status = clEnqueueNDRangeKernel(rEnv.mpkCmdQueue, rEnv.mpkKernel, 2, nullptr, globalThreads,
1065                                      localThreads, 0, nullptr, nullptr);
1066      if (yp &gt; 0 || yn &gt; 0) {
1067        pixtemp = pixsCLBuffer;
1068        pixsCLBuffer = pixdCLBuffer;
1069        pixdCLBuffer = pixtemp;
1070      }
1071    } else if (xp &gt; 0 || xn &gt; 0) {
1072      rEnv.mpkKernel = clCreateKernel(rEnv.mpkProgram, &quot;morphoErodeHor_32word&quot;, &amp;status);
1073      isEven = (xp != xn);
1074      status = clSetKernelArg(rEnv.mpkKernel, 0, sizeof(cl_mem), &amp;pixsCLBuffer);
1075      status = clSetKernelArg(rEnv.mpkKernel, 1, sizeof(cl_mem), &amp;pixdCLBuffer);
1076      status = clSetKernelArg(rEnv.mpkKernel, 2, sizeof(xp), &amp;xp);
1077      status = clSetKernelArg(rEnv.mpkKernel, 3, sizeof(wpl), &amp;wpl);
1078      status = clSetKernelArg(rEnv.mpkKernel, 4, sizeof(h), &amp;h);
1079      status = clSetKernelArg(rEnv.mpkKernel, 5, sizeof(isAsymmetric), &amp;isAsymmetric);
1080      status = clSetKernelArg(rEnv.mpkKernel, 6, sizeof(rwmask), &amp;rwmask);
1081      status = clSetKernelArg(rEnv.mpkKernel, 7, sizeof(lwmask), &amp;lwmask);
1082      status = clSetKernelArg(rEnv.mpkKernel, 8, sizeof(isEven), &amp;isEven);
1083      status = clEnqueueNDRangeKernel(rEnv.mpkCmdQueue, rEnv.mpkKernel, 2, nullptr, globalThreads,
1084                                      localThreads, 0, nullptr, nullptr);
1085      if (yp &gt; 0 || yn &gt; 0) {
1086        pixtemp = pixsCLBuffer;
1087        pixsCLBuffer = pixdCLBuffer;
1088        pixdCLBuffer = pixtemp;
1089      }
1090    }
1091    if (yp &gt; 0 || yn &gt; 0) {
1092      rEnv.mpkKernel = clCreateKernel(rEnv.mpkProgram, &quot;morphoErodeVer&quot;, &amp;status);
1093      CHECK_OPENCL(status, &quot;clCreateKernel morphoErodeVer&quot;);
1094      status = clSetKernelArg(rEnv.mpkKernel, 0, sizeof(cl_mem), &amp;pixsCLBuffer);
1095      status = clSetKernelArg(rEnv.mpkKernel, 1, sizeof(cl_mem), &amp;pixdCLBuffer);
1096      status = clSetKernelArg(rEnv.mpkKernel, 2, sizeof(yp), &amp;yp);
1097      status = clSetKernelArg(rEnv.mpkKernel, 3, sizeof(wpl), &amp;wpl);
1098      status = clSetKernelArg(rEnv.mpkKernel, 4, sizeof(h), &amp;h);
1099      status = clSetKernelArg(rEnv.mpkKernel, 5, sizeof(isAsymmetric), &amp;isAsymmetric);
1100      status = clSetKernelArg(rEnv.mpkKernel, 6, sizeof(yn), &amp;yn);
1101      status = clEnqueueNDRangeKernel(rEnv.mpkCmdQueue, rEnv.mpkKernel, 2, nullptr, globalThreads,
1102                                      localThreads, 0, nullptr, nullptr);
1103    }
1104    return status;
1105  }
1106  static cl_int pixOpenCL(l_int32 hsize, l_int32 vsize, l_int32 wpl, l_int32 h) {
1107    cl_int status;
1108    cl_mem pixtemp;
1109    status = pixErodeCL(hsize, vsize, wpl, h);
1110    pixtemp = pixsCLBuffer;
1111    pixsCLBuffer = pixdCLBuffer;
1112    pixdCLBuffer = pixtemp;
1113    status = pixDilateCL(hsize, vsize, wpl, h);
1114    return status;
1115  }
1116  static cl_int pixCloseCL(l_int32 hsize, l_int32 vsize, l_int32 wpl, l_int32 h) {
1117    cl_int status;
1118    cl_mem pixtemp;
1119    status = pixDilateCL(hsize, vsize, wpl, h);
1120    pixtemp = pixsCLBuffer;
1121    pixsCLBuffer = pixdCLBuffer;
1122    pixdCLBuffer = pixtemp;
1123    status = pixErodeCL(hsize, vsize, wpl, h);
1124    return status;
1125  }
1126  static cl_int pixSubtractCL_work(l_uint32 wpl, l_uint32 h, cl_mem buffer1, cl_mem buffer2) {
1127    cl_int status;
1128    size_t globalThreads[2];
1129    int gsize;
1130    size_t localThreads[] = {GROUPSIZE_X, GROUPSIZE_Y};
1131    gsize = (wpl + GROUPSIZE_X - 1) / GROUPSIZE_X * GROUPSIZE_X;
1132    globalThreads[0] = gsize;
1133    gsize = (h + GROUPSIZE_Y - 1) / GROUPSIZE_Y * GROUPSIZE_Y;
1134    globalThreads[1] = gsize;
1135    rEnv.mpkKernel = clCreateKernel(rEnv.mpkProgram, &quot;pixSubtract_inplace&quot;, &amp;status);
1136    CHECK_OPENCL(status, &quot;clCreateKernel pixSubtract_inplace&quot;);
1137    status = clSetKernelArg(rEnv.mpkKernel, 0, sizeof(cl_mem), &amp;buffer1);
1138    status = clSetKernelArg(rEnv.mpkKernel, 1, sizeof(cl_mem), &amp;buffer2);
1139    status = clSetKernelArg(rEnv.mpkKernel, 2, sizeof(wpl), &amp;wpl);
1140    status = clSetKernelArg(rEnv.mpkKernel, 3, sizeof(h), &amp;h);
1141    status = clEnqueueNDRangeKernel(rEnv.mpkCmdQueue, rEnv.mpkKernel, 2, nullptr, globalThreads,
1142                                    localThreads, 0, nullptr, nullptr);
1143    return status;
1144  }
1145  void OpenclDevice::pixGetLinesCL(Image pixd, Image pixs, Image *pix_vline, Image *pix_hline,
1146                                   Image *pixClosed, bool getpixClosed, l_int32 close_hsize,
1147                                   l_int32 close_vsize, l_int32 open_hsize, l_int32 open_vsize,
1148                                   l_int32 line_hsize, l_int32 line_vsize) {
1149    l_uint32 wpl, h;
1150    cl_mem pixtemp;
1151    wpl = pixGetWpl(pixs);
1152    h = pixGetHeight(pixs);
1153    clStatus = pixCloseCL(close_hsize, close_vsize, wpl, h);
1154    if (getpixClosed) {
1155      *pixClosed =
1156          mapOutputCLBuffer(rEnv, pixdCLBuffer, *pixClosed, pixs, wpl * h, CL_MAP_READ, true, false);
1157    }
1158    clStatus = clEnqueueCopyBuffer(rEnv.mpkCmdQueue, pixdCLBuffer, pixdCLIntermediate, 0, 0,
1159                                   sizeof(int) * wpl * h, 0, nullptr, nullptr);
1160    pixtemp = pixsCLBuffer;
1161    pixsCLBuffer = pixdCLBuffer;
1162    pixdCLBuffer = pixtemp;
1163    clStatus = pixOpenCL(open_hsize, open_vsize, wpl, h);
1164    pixtemp = pixsCLBuffer;
1165    pixsCLBuffer = pixdCLBuffer;
1166    pixdCLBuffer = pixdCLIntermediate;
1167    pixdCLIntermediate = pixtemp;
1168    clStatus = pixSubtractCL_work(wpl, h, pixdCLBuffer, pixsCLBuffer);
1169    clStatus = clEnqueueCopyBuffer(rEnv.mpkCmdQueue, pixdCLBuffer, pixdCLIntermediate, 0, 0,
1170                                   sizeof(int) * wpl * h, 0, nullptr, nullptr);
1171    pixtemp = pixsCLBuffer;
1172    pixsCLBuffer = pixdCLBuffer;
1173    pixdCLBuffer = pixtemp;
1174    clStatus = pixOpenCL(1, line_vsize, wpl, h);
1175    *pix_vline =
1176        mapOutputCLBuffer(rEnv, pixdCLBuffer, *pix_vline, pixs, wpl * h, CL_MAP_READ, true, false);
1177    pixtemp = pixsCLBuffer;
1178    pixsCLBuffer = pixdCLIntermediate;
1179    pixdCLIntermediate = pixtemp;
1180    clStatus = pixOpenCL(line_hsize, 1, wpl, h);
1181    *pix_hline =
1182        mapOutputCLBuffer(rEnv, pixdCLBuffer, *pix_hline, pixs, wpl * h, CL_MAP_READ, true, true);
1183    return;
1184  }
1185  int OpenclDevice::HistogramRectOCL(void *imageData, int bytes_per_pixel, int bytes_per_line,
1186                                     int left, 
1187                                     int top,  
1188                                     int width, int height, int kHistogramSize,
1189                                     int *histogramAllChannels) {
1190    cl_int clStatus;
1191    int retVal = 0;
1192    KernelEnv histKern;
1193    SetKernelEnv(&amp;histKern);
1194    KernelEnv histRedKern;
1195    SetKernelEnv(&amp;histRedKern);
1196    cl_mem imageBuffer =
1197        clCreateBuffer(histKern.mpkContext, CL_MEM_READ_ONLY | CL_MEM_USE_HOST_PTR,
1198                       width * height * bytes_per_pixel * sizeof(char), imageData, &amp;clStatus);
1199    CHECK_OPENCL(clStatus, &quot;clCreateBuffer imageBuffer&quot;);
1200    int block_size = 256;
1201    cl_uint numCUs;
1202    clStatus = clGetDeviceInfo(gpuEnv.mpDevID, CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(numCUs), &amp;numCUs,
1203                               nullptr);
1204    CHECK_OPENCL(clStatus, &quot;clCreateBuffer imageBuffer&quot;);
1205    int requestedOccupancy = 10;
1206    int numWorkGroups = numCUs * requestedOccupancy;
1207    int numThreads = block_size * numWorkGroups;
1208    size_t local_work_size[] = {static_cast&lt;size_t&gt;(block_size)};
1209    size_t global_work_size[] = {static_cast&lt;size_t&gt;(numThreads)};
1210    size_t red_global_work_size[] = {
1211        static_cast&lt;size_t&gt;(block_size * kHistogramSize * bytes_per_pixel)};
1212    cl_mem histogramBuffer = clCreateBuffer(
1213        histKern.mpkContext, CL_MEM_READ_WRITE | CL_MEM_USE_HOST_PTR,
1214        kHistogramSize * bytes_per_pixel * sizeof(int), histogramAllChannels, &amp;clStatus);
1215    CHECK_OPENCL(clStatus, &quot;clCreateBuffer histogramBuffer&quot;);
1216    int histRed = 256;
1217    int tmpHistogramBins = kHistogramSize * bytes_per_pixel * histRed;
1218    cl_mem tmpHistogramBuffer =
1219        clCreateBuffer(histKern.mpkContext, CL_MEM_READ_WRITE, tmpHistogramBins * sizeof(cl_uint),
1220                       nullptr, &amp;clStatus);
1221    CHECK_OPENCL(clStatus, &quot;clCreateBuffer tmpHistogramBuffer&quot;);
1222    int *zeroBuffer = new int[1];
1223    zeroBuffer[0] = 0;
1224    cl_mem atomicSyncBuffer =
1225        clCreateBuffer(histKern.mpkContext, CL_MEM_READ_WRITE | CL_MEM_COPY_HOST_PTR, sizeof(cl_int),
1226                       zeroBuffer, &amp;clStatus);
1227    CHECK_OPENCL(clStatus, &quot;clCreateBuffer atomicSyncBuffer&quot;);
1228    delete[] zeroBuffer;
1229    if (bytes_per_pixel == 1) {
1230      histKern.mpkKernel =
1231          clCreateKernel(histKern.mpkProgram, &quot;kernel_HistogramRectOneChannel&quot;, &amp;clStatus);
1232      CHECK_OPENCL(clStatus, &quot;clCreateKernel kernel_HistogramRectOneChannel&quot;);
1233      histRedKern.mpkKernel = clCreateKernel(histRedKern.mpkProgram,
1234                                             &quot;kernel_HistogramRectOneChannelReduction&quot;, &amp;clStatus);
1235      CHECK_OPENCL(clStatus, &quot;clCreateKernel kernel_HistogramRectOneChannelReduction&quot;);
1236    } else {
1237      histKern.mpkKernel =
1238          clCreateKernel(histKern.mpkProgram, &quot;kernel_HistogramRectAllChannels&quot;, &amp;clStatus);
1239      CHECK_OPENCL(clStatus, &quot;clCreateKernel kernel_HistogramRectAllChannels&quot;);
1240      histRedKern.mpkKernel = clCreateKernel(histRedKern.mpkProgram,
1241                                             &quot;kernel_HistogramRectAllChannelsReduction&quot;, &amp;clStatus);
1242      CHECK_OPENCL(clStatus, &quot;clCreateKernel kernel_HistogramRectAllChannelsReduction&quot;);
1243    }
1244    void *ptr;
1245    ptr = clEnqueueMapBuffer(histKern.mpkCmdQueue, tmpHistogramBuffer, CL_TRUE, CL_MAP_WRITE, 0,
1246                             tmpHistogramBins * sizeof(cl_uint), 0, nullptr, nullptr, &amp;clStatus);
1247    CHECK_OPENCL(clStatus, &quot;clEnqueueMapBuffer tmpHistogramBuffer&quot;);
1248    memset(ptr, 0, tmpHistogramBins * sizeof(cl_uint));
1249    clEnqueueUnmapMemObject(histKern.mpkCmdQueue, tmpHistogramBuffer, ptr, 0, nullptr, nullptr);
1250    clStatus = clSetKernelArg(histKern.mpkKernel, 0, sizeof(cl_mem), &amp;imageBuffer);
1251    CHECK_OPENCL(clStatus, &quot;clSetKernelArg imageBuffer&quot;);
1252    cl_uint numPixels = width * height;
1253    clStatus = clSetKernelArg(histKern.mpkKernel, 1, sizeof(cl_uint), &amp;numPixels);
1254    CHECK_OPENCL(clStatus, &quot;clSetKernelArg numPixels&quot;);
1255    clStatus = clSetKernelArg(histKern.mpkKernel, 2, sizeof(cl_mem), &amp;tmpHistogramBuffer);
1256    CHECK_OPENCL(clStatus, &quot;clSetKernelArg tmpHistogramBuffer&quot;);
1257    int n = numThreads / bytes_per_pixel;
1258    clStatus = clSetKernelArg(histRedKern.mpkKernel, 0, sizeof(cl_int), &amp;n);
1259    CHECK_OPENCL(clStatus, &quot;clSetKernelArg imageBuffer&quot;);
1260    clStatus = clSetKernelArg(histRedKern.mpkKernel, 1, sizeof(cl_mem), &amp;tmpHistogramBuffer);
1261    CHECK_OPENCL(clStatus, &quot;clSetKernelArg tmpHistogramBuffer&quot;);
1262    clStatus = clSetKernelArg(histRedKern.mpkKernel, 2, sizeof(cl_mem), &amp;histogramBuffer);
1263    CHECK_OPENCL(clStatus, &quot;clSetKernelArg histogramBuffer&quot;);
1264    clStatus = clEnqueueNDRangeKernel(histKern.mpkCmdQueue, histKern.mpkKernel, 1, nullptr,
1265                                      global_work_size, local_work_size, 0, nullptr, nullptr);
1266    CHECK_OPENCL(clStatus, &quot;clEnqueueNDRangeKernel kernel_HistogramRectAllChannels&quot;);
1267    clFinish(histKern.mpkCmdQueue);
1268    if (clStatus != 0) {
1269      retVal = -1;
1270    }
1271    clStatus = clEnqueueNDRangeKernel(histRedKern.mpkCmdQueue, histRedKern.mpkKernel, 1, nullptr,
1272                                      red_global_work_size, local_work_size, 0, nullptr, nullptr);
1273    CHECK_OPENCL(clStatus, &quot;clEnqueueNDRangeKernel kernel_HistogramRectAllChannelsReduction&quot;);
1274    clFinish(histRedKern.mpkCmdQueue);
1275    if (clStatus != 0) {
1276      retVal = -1;
1277    }
1278    ptr = clEnqueueMapBuffer(histRedKern.mpkCmdQueue, histogramBuffer, CL_TRUE, CL_MAP_READ, 0,
1279                             kHistogramSize * bytes_per_pixel * sizeof(int), 0, nullptr, nullptr,
1280                             &amp;clStatus);
1281    CHECK_OPENCL(clStatus, &quot;clEnqueueMapBuffer histogramBuffer&quot;);
1282    if (clStatus != 0) {
1283      retVal = -1;
1284    }
1285    clEnqueueUnmapMemObject(histRedKern.mpkCmdQueue, histogramBuffer, ptr, 0, nullptr, nullptr);
1286    clReleaseMemObject(histogramBuffer);
1287    clReleaseMemObject(imageBuffer);
1288    return retVal;
1289  }
1290  int OpenclDevice::ThresholdRectToPixOCL(unsigned char *imageData, int bytes_per_pixel,
1291                                          int bytes_per_line, int *thresholds, int *hi_values,
1292                                          Image *pix, int height, int width, int top, int left) {
1293    int retVal = 0;
1294    *pix = pixCreate(width, height, 1);
1295    uint32_t *pixData = pixGetData(*pix);
1296    int wpl = pixGetWpl(*pix);
1297    int pixSize = wpl * height * sizeof(uint32_t); 
1298    cl_int clStatus;
1299    KernelEnv rEnv;
1300    SetKernelEnv(&amp;rEnv);
1301    int block_size = 256;
1302    cl_uint numCUs = 6;
1303    clStatus = clGetDeviceInfo(gpuEnv.mpDevID, CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(numCUs), &amp;numCUs,
1304                               nullptr);
1305    CHECK_OPENCL(clStatus, &quot;clCreateBuffer imageBuffer&quot;);
1306    int requestedOccupancy = 10;
1307    int numWorkGroups = numCUs * requestedOccupancy;
1308    int numThreads = block_size * numWorkGroups;
1309    size_t local_work_size[] = {(size_t)block_size};
1310    size_t global_work_size[] = {(size_t)numThreads};
<span onclick='openModal()' class='match'>1311    cl_mem imageBuffer =
1312        clCreateBuffer(rEnv.mpkContext, CL_MEM_READ_ONLY | CL_MEM_USE_HOST_PTR,
1313                       width * height * bytes_per_pixel * sizeof(char), imageData, &amp;clStatus);
1314    CHECK_OPENCL(clStatus, &quot;clCreateBuffer imageBuffer&quot;);
1315    pixThBuffer = clCreateBuffer(rEnv.mpkContext, CL_MEM_READ_WRITE | CL_MEM_USE_HOST_PTR, pixSize,
</span>1316                                 pixData, &amp;clStatus);
1317    CHECK_OPENCL(clStatus, &quot;clCreateBuffer pix&quot;);
1318    cl_mem thresholdsBuffer = clCreateBuffer(rEnv.mpkContext, CL_MEM_READ_ONLY | CL_MEM_USE_HOST_PTR,
1319                                             bytes_per_pixel * sizeof(int), thresholds, &amp;clStatus);
1320    CHECK_OPENCL(clStatus, &quot;clCreateBuffer thresholdBuffer&quot;);
1321    cl_mem hiValuesBuffer = clCreateBuffer(rEnv.mpkContext, CL_MEM_READ_ONLY | CL_MEM_USE_HOST_PTR,
1322                                           bytes_per_pixel * sizeof(int), hi_values, &amp;clStatus);
1323    CHECK_OPENCL(clStatus, &quot;clCreateBuffer hiValuesBuffer&quot;);
1324    if (bytes_per_pixel == 4) {
1325      rEnv.mpkKernel = clCreateKernel(rEnv.mpkProgram, &quot;kernel_ThresholdRectToPix&quot;, &amp;clStatus);
1326      CHECK_OPENCL(clStatus, &quot;clCreateKernel kernel_ThresholdRectToPix&quot;);
1327    } else {
1328      rEnv.mpkKernel =
1329          clCreateKernel(rEnv.mpkProgram, &quot;kernel_ThresholdRectToPix_OneChan&quot;, &amp;clStatus);
1330      CHECK_OPENCL(clStatus, &quot;clCreateKernel kernel_ThresholdRectToPix_OneChan&quot;);
1331    }
1332    clStatus = clSetKernelArg(rEnv.mpkKernel, 0, sizeof(cl_mem), &amp;imageBuffer);
1333    CHECK_OPENCL(clStatus, &quot;clSetKernelArg imageBuffer&quot;);
1334    clStatus = clSetKernelArg(rEnv.mpkKernel, 1, sizeof(int), &amp;height);
1335    CHECK_OPENCL(clStatus, &quot;clSetKernelArg height&quot;);
1336    clStatus = clSetKernelArg(rEnv.mpkKernel, 2, sizeof(int), &amp;width);
1337    CHECK_OPENCL(clStatus, &quot;clSetKernelArg width&quot;);
1338    clStatus = clSetKernelArg(rEnv.mpkKernel, 3, sizeof(int), &amp;wpl);
1339    CHECK_OPENCL(clStatus, &quot;clSetKernelArg wpl&quot;);
1340    clStatus = clSetKernelArg(rEnv.mpkKernel, 4, sizeof(cl_mem), &amp;thresholdsBuffer);
1341    CHECK_OPENCL(clStatus, &quot;clSetKernelArg thresholdsBuffer&quot;);
1342    clStatus = clSetKernelArg(rEnv.mpkKernel, 5, sizeof(cl_mem), &amp;hiValuesBuffer);
1343    CHECK_OPENCL(clStatus, &quot;clSetKernelArg hiValuesBuffer&quot;);
1344    clStatus = clSetKernelArg(rEnv.mpkKernel, 6, sizeof(cl_mem), &amp;pixThBuffer);
1345    CHECK_OPENCL(clStatus, &quot;clSetKernelArg pixThBuffer&quot;);
1346    clStatus = clEnqueueNDRangeKernel(rEnv.mpkCmdQueue, rEnv.mpkKernel, 1, nullptr, global_work_size,
1347                                      local_work_size, 0, nullptr, nullptr);
1348    CHECK_OPENCL(clStatus, &quot;clEnqueueNDRangeKernel kernel_ThresholdRectToPix&quot;);
1349    clFinish(rEnv.mpkCmdQueue);
1350    if (clStatus != 0) {
1351      tprintf(&quot;Setting return value to -1\n&quot;);
1352      retVal = -1;
1353    }
1354    void *ptr = clEnqueueMapBuffer(rEnv.mpkCmdQueue, pixThBuffer, CL_TRUE, CL_MAP_READ, 0, pixSize, 0,
1355                                   nullptr, nullptr, &amp;clStatus);
1356    CHECK_OPENCL(clStatus, &quot;clEnqueueMapBuffer histogramBuffer&quot;);
1357    clEnqueueUnmapMemObject(rEnv.mpkCmdQueue, pixThBuffer, ptr, 0, nullptr, nullptr);
1358    clReleaseMemObject(imageBuffer);
1359    clReleaseMemObject(thresholdsBuffer);
1360    clReleaseMemObject(hiValuesBuffer);
1361    return retVal;
1362  }
1363  struct TessScoreEvaluationInputData {
1364    int height;
1365    int width;
1366    int numChannels;
1367    unsigned char *imageData;
1368    Image pix;
1369  };
1370  static void populateTessScoreEvaluationInputData(TessScoreEvaluationInputData *input) {
1371    srand(1);
1372    int height = 3328; 
1373    int width = 2560;  
1374    int numChannels = 4;
1375    input-&gt;height = height;
1376    input-&gt;width = width;
1377    input-&gt;numChannels = numChannels;
1378    unsigned char(*imageData4)[4] = (unsigned char(*)[4])malloc(
1379        height * width * numChannels * sizeof(unsigned char)); 
1380    input-&gt;imageData = (unsigned char *)&amp;imageData4[0];
1381    unsigned char pixelWhite[4] = {0, 0, 0, 255};
1382    unsigned char pixelBlack[4] = {255, 255, 255, 255};
1383    for (int p = 0; p &lt; height * width; p++) {
1384      imageData4[p][0] = pixelWhite[0];
1385      imageData4[p][1] = pixelWhite[1];
1386      imageData4[p][2] = pixelWhite[2];
1387      imageData4[p][3] = pixelWhite[3];
1388    }
1389    int maxLineWidth = 64; 
1390    int numLines = 10;
1391    for (int i = 0; i &lt; numLines; i++) {
1392      int lineWidth = rand() % maxLineWidth;
1393      int vertLinePos = lineWidth + rand() % (width - 2 * lineWidth);
1394      for (int row = vertLinePos - lineWidth / 2; row &lt; vertLinePos + lineWidth / 2; row++) {
1395        for (int col = 0; col &lt; height; col++) {
1396          imageData4[row * width + col][0] = pixelBlack[0];
1397          imageData4[row * width + col][1] = pixelBlack[1];
1398          imageData4[row * width + col][2] = pixelBlack[2];
1399          imageData4[row * width + col][3] = pixelBlack[3];
1400        }
1401      }
1402    }
1403    for (int i = 0; i &lt; numLines; i++) {
1404      int lineWidth = rand() % maxLineWidth;
1405      int horLinePos = lineWidth + rand() % (height - 2 * lineWidth);
1406      for (int row = 0; row &lt; width; row++) {
1407        for (int col = horLinePos - lineWidth / 2; col &lt; horLinePos + lineWidth / 2;
1408             col++) { 
1409          imageData4[row * width + col][0] = pixelBlack[0];
1410          imageData4[row * width + col][1] = pixelBlack[1];
1411          imageData4[row * width + col][2] = pixelBlack[2];
1412          imageData4[row * width + col][3] = pixelBlack[3];
1413        }
1414      }
1415    }
1416    float fractionBlack = 0.1; 
1417    int numSpots = (height * width) * fractionBlack / (maxLineWidth * maxLineWidth / 2 / 2);
1418    for (int i = 0; i &lt; numSpots; i++) {
1419      int lineWidth = rand() % maxLineWidth;
1420      int col = lineWidth + rand() % (width - 2 * lineWidth);
1421      int row = lineWidth + rand() % (height - 2 * lineWidth);
1422      for (int r = row - lineWidth / 2; r &lt; row + lineWidth / 2; r++) {
1423        for (int c = col - lineWidth / 2; c &lt; col + lineWidth / 2; c++) {
1424          imageData4[r * width + c][0] = pixelBlack[0];
1425          imageData4[r * width + c][1] = pixelBlack[1];
1426          imageData4[r * width + c][2] = pixelBlack[2];
1427          imageData4[r * width + c][3] = pixelBlack[3];
1428        }
1429      }
1430    }
1431    input-&gt;pix = pixCreate(input-&gt;width, input-&gt;height, 8 * input-&gt;numChannels);
1432  }
1433  struct TessDeviceScore {
1434    float time;   
1435    bool clError; 
1436    bool valid;   
1437  };
1438  static double composeRGBPixelMicroBench(GPUEnv *env, TessScoreEvaluationInputData input,
1439                                          ds_device_type type) {
1440    double time = 0;
1441  #  if ON_WINDOWS
1442    LARGE_INTEGER freq, time_funct_start, time_funct_end;
1443    QueryPerformanceFrequency(&amp;freq);
1444  #  elif ON_APPLE
1445    mach_timebase_info_data_t info = {0, 0};
1446    mach_timebase_info(&amp;info);
1447    long long start, stop;
1448  #  else
1449    timespec time_funct_start, time_funct_end;
1450  #  endif
1451    l_uint32 *tiffdata = (l_uint32 *)input.imageData; 
1452    if (type == DS_DEVICE_OPENCL_DEVICE) {
1453  #  if ON_WINDOWS
1454      QueryPerformanceCounter(&amp;time_funct_start);
1455  #  elif ON_APPLE
1456      start = mach_absolute_time();
1457  #  else
1458      clock_gettime(CLOCK_MONOTONIC, &amp;time_funct_start);
1459  #  endif
1460      OpenclDevice::gpuEnv = *env;
1461      int wpl = pixGetWpl(input.pix);
1462      OpenclDevice::pixReadFromTiffKernel(tiffdata, input.width, input.height, wpl, nullptr);
1463  #  if ON_WINDOWS
1464      QueryPerformanceCounter(&amp;time_funct_end);
1465      time = (time_funct_end.QuadPart - time_funct_start.QuadPart) / (double)(freq.QuadPart);
1466  #  elif ON_APPLE
1467      stop = mach_absolute_time();
1468      time = ((stop - start) * (double)info.numer / info.denom) / 1.0E9;
1469  #  else
1470      clock_gettime(CLOCK_MONOTONIC, &amp;time_funct_end);
1471      time = (time_funct_end.tv_sec - time_funct_start.tv_sec) * 1.0 +
1472             (time_funct_end.tv_nsec - time_funct_start.tv_nsec) / 1000000000.0;
1473  #  endif
1474    } else {
1475  #  if ON_WINDOWS
1476      QueryPerformanceCounter(&amp;time_funct_start);
1477  #  elif ON_APPLE
1478      start = mach_absolute_time();
1479  #  else
1480      clock_gettime(CLOCK_MONOTONIC, &amp;time_funct_start);
1481  #  endif
1482      Image pix = pixCreate(input.width, input.height, 32);
1483      l_uint32 *pixData = pixGetData(pix);
1484      int i, j;
1485      int idx = 0;
1486      for (i = 0; i &lt; input.height; i++) {
1487        for (j = 0; j &lt; input.width; j++) {
1488          l_uint32 tiffword = tiffdata[i * input.width + j];
1489          l_int32 rval = ((tiffword)&amp;0xff);
1490          l_int32 gval = (((tiffword) &gt;&gt; 8) &amp; 0xff);
1491          l_int32 bval = (((tiffword) &gt;&gt; 16) &amp; 0xff);
1492          l_uint32 value = (rval &lt;&lt; 24) | (gval &lt;&lt; 16) | (bval &lt;&lt; 8);
1493          pixData[idx] = value;
1494          idx++;
1495        }
1496      }
1497  #  if ON_WINDOWS
1498      QueryPerformanceCounter(&amp;time_funct_end);
1499      time = (time_funct_end.QuadPart - time_funct_start.QuadPart) / (double)(freq.QuadPart);
1500  #  elif ON_APPLE
1501      stop = mach_absolute_time();
1502      time = ((stop - start) * (double)info.numer / info.denom) / 1.0E9;
1503  #  else
1504      clock_gettime(CLOCK_MONOTONIC, &amp;time_funct_end);
1505      time = (time_funct_end.tv_sec - time_funct_start.tv_sec) * 1.0 +
1506             (time_funct_end.tv_nsec - time_funct_start.tv_nsec) / 1000000000.0;
1507  #  endif
1508      pix.destroy();
1509    }
1510    return time;
1511  }
1512  static double histogramRectMicroBench(GPUEnv *env, TessScoreEvaluationInputData input,
1513                                        ds_device_type type) {
1514    double time;
1515  #  if ON_WINDOWS
1516    LARGE_INTEGER freq, time_funct_start, time_funct_end;
1517    QueryPerformanceFrequency(&amp;freq);
1518  #  elif ON_APPLE
1519    mach_timebase_info_data_t info = {0, 0};
1520    mach_timebase_info(&amp;info);
1521    long long start, stop;
1522  #  else
1523    timespec time_funct_start, time_funct_end;
1524  #  endif
1525    const int left = 0;
1526    const int top = 0;
1527    int kHistogramSize = 256;
1528    int bytes_per_line = input.width * input.numChannels;
1529    int *histogramAllChannels = new int[kHistogramSize * input.numChannels];
1530    if (type == DS_DEVICE_OPENCL_DEVICE) {
1531  #  if ON_WINDOWS
1532      QueryPerformanceCounter(&amp;time_funct_start);
1533  #  elif ON_APPLE
1534      start = mach_absolute_time();
1535  #  else
1536      clock_gettime(CLOCK_MONOTONIC, &amp;time_funct_start);
1537  #  endif
1538      OpenclDevice::gpuEnv = *env;
1539      int retVal = OpenclDevice::HistogramRectOCL(input.imageData, input.numChannels, bytes_per_line,
1540                                                  left, top, input.width, input.height,
1541                                                  kHistogramSize, histogramAllChannels);
1542  #  if ON_WINDOWS
1543      QueryPerformanceCounter(&amp;time_funct_end);
1544      time = (time_funct_end.QuadPart - time_funct_start.QuadPart) / (double)(freq.QuadPart);
1545  #  elif ON_APPLE
1546      stop = mach_absolute_time();
1547      if (retVal == 0) {
1548        time = ((stop - start) * (double)info.numer / info.denom) / 1.0E9;
1549      } else {
1550        time = FLT_MAX;
1551      }
1552  #  else
1553      clock_gettime(CLOCK_MONOTONIC, &amp;time_funct_end);
1554      time = (time_funct_end.tv_sec - time_funct_start.tv_sec) * 1.0 +
1555             (time_funct_end.tv_nsec - time_funct_start.tv_nsec) / 1000000000.0;
1556  #  endif
1557    } else {
1558      int *histogram = new int[kHistogramSize];
1559  #  if ON_WINDOWS
1560      QueryPerformanceCounter(&amp;time_funct_start);
1561  #  elif ON_APPLE
1562      start = mach_absolute_time();
1563  #  else
1564      clock_gettime(CLOCK_MONOTONIC, &amp;time_funct_start);
1565  #  endif
1566      for (int ch = 0; ch &lt; input.numChannels; ++ch) {
1567        tesseract::HistogramRect(input.pix, input.numChannels, left, top, input.width, input.height,
1568                                 histogram);
1569      }
1570  #  if ON_WINDOWS
1571      QueryPerformanceCounter(&amp;time_funct_end);
1572      time = (time_funct_end.QuadPart - time_funct_start.QuadPart) / (double)(freq.QuadPart);
1573  #  elif ON_APPLE
1574      stop = mach_absolute_time();
1575      time = ((stop - start) * (double)info.numer / info.denom) / 1.0E9;
1576  #  else
1577      clock_gettime(CLOCK_MONOTONIC, &amp;time_funct_end);
1578      time = (time_funct_end.tv_sec - time_funct_start.tv_sec) * 1.0 +
1579             (time_funct_end.tv_nsec - time_funct_start.tv_nsec) / 1000000000.0;
1580  #  endif
1581      delete[] histogram;
1582    }
1583    delete[] histogramAllChannels;
1584    return time;
1585  }
1586  static void ThresholdRectToPix_Native(const unsigned char *imagedata, int bytes_per_pixel,
1587                                        int bytes_per_line, const int *thresholds,
1588                                        const int *hi_values, Image *pix) {
1589    int top = 0;
1590    int left = 0;
1591    int width = pixGetWidth(*pix);
1592    int height = pixGetHeight(*pix);
1593    *pix = pixCreate(width, height, 1);
1594    uint32_t *pixdata = pixGetData(*pix);
1595    int wpl = pixGetWpl(*pix);
1596    const unsigned char *srcdata = imagedata + top * bytes_per_line + left * bytes_per_pixel;
1597    for (int y = 0; y &lt; height; ++y) {
1598      const uint8_t *linedata = srcdata;
1599      uint32_t *pixline = pixdata + y * wpl;
1600      for (int x = 0; x &lt; width; ++x, linedata += bytes_per_pixel) {
1601        bool white_result = true;
1602        for (int ch = 0; ch &lt; bytes_per_pixel; ++ch) {
1603          if (hi_values[ch] &gt;= 0 &amp;&amp; (linedata[ch] &gt; thresholds[ch]) == (hi_values[ch] == 0)) {
1604            white_result = false;
1605            break;
1606          }
1607        }
1608        if (white_result)
1609          CLEAR_DATA_BIT(pixline, x);
1610        else
1611          SET_DATA_BIT(pixline, x);
1612      }
1613      srcdata += bytes_per_line;
1614    }
1615  }
1616  static double thresholdRectToPixMicroBench(GPUEnv *env, TessScoreEvaluationInputData input,
1617                                             ds_device_type type) {
1618    double time;
1619  #  if ON_WINDOWS
1620    LARGE_INTEGER freq, time_funct_start, time_funct_end;
1621    QueryPerformanceFrequency(&amp;freq);
1622  #  elif ON_APPLE
1623    mach_timebase_info_data_t info = {0, 0};
1624    mach_timebase_info(&amp;info);
1625    long long start, stop;
1626  #  else
1627    timespec time_funct_start, time_funct_end;
1628  #  endif
1629    unsigned char pixelHi = (unsigned char)255;
1630    int thresholds[4] = {pixelHi, pixelHi, pixelHi, pixelHi};
1631    int top = 0;
1632    int left = 0;
1633    int bytes_per_line = input.width * input.numChannels;
1634    if (type == DS_DEVICE_OPENCL_DEVICE) {
1635  #  if ON_WINDOWS
1636      QueryPerformanceCounter(&amp;time_funct_start);
1637  #  elif ON_APPLE
1638      start = mach_absolute_time();
1639  #  else
1640      clock_gettime(CLOCK_MONOTONIC, &amp;time_funct_start);
1641  #  endif
1642      OpenclDevice::gpuEnv = *env;
1643      int hi_values[4];
1644      int retVal = OpenclDevice::ThresholdRectToPixOCL(
1645          input.imageData, input.numChannels, bytes_per_line, thresholds, hi_values, &amp;input.pix,
1646          input.height, input.width, top, left);
1647  #  if ON_WINDOWS
1648      QueryPerformanceCounter(&amp;time_funct_end);
1649      time = (time_funct_end.QuadPart - time_funct_start.QuadPart) / (double)(freq.QuadPart);
1650  #  elif ON_APPLE
1651      stop = mach_absolute_time();
1652      if (retVal == 0) {
1653        time = ((stop - start) * (double)info.numer / info.denom) / 1.0E9;
1654      } else {
1655        time = FLT_MAX;
1656      }
1657  #  else
1658      clock_gettime(CLOCK_MONOTONIC, &amp;time_funct_end);
1659      time = (time_funct_end.tv_sec - time_funct_start.tv_sec) * 1.0 +
1660             (time_funct_end.tv_nsec - time_funct_start.tv_nsec) / 1000000000.0;
1661  #  endif
1662    } else {
1663      tesseract::ImageThresholder thresholder;
1664      thresholder.SetImage(input.pix);
1665  #  if ON_WINDOWS
1666      QueryPerformanceCounter(&amp;time_funct_start);
1667  #  elif ON_APPLE
1668      start = mach_absolute_time();
1669  #  else
1670      clock_gettime(CLOCK_MONOTONIC, &amp;time_funct_start);
1671  #  endif
1672      int hi_values[4] = {};
1673      ThresholdRectToPix_Native(input.imageData, input.numChannels, bytes_per_line, thresholds,
1674                                hi_values, &amp;input.pix);
1675  #  if ON_WINDOWS
1676      QueryPerformanceCounter(&amp;time_funct_end);
1677      time = (time_funct_end.QuadPart - time_funct_start.QuadPart) / (double)(freq.QuadPart);
1678  #  elif ON_APPLE
1679      stop = mach_absolute_time();
1680      time = ((stop - start) * (double)info.numer / info.denom) / 1.0E9;
1681  #  else
1682      clock_gettime(CLOCK_MONOTONIC, &amp;time_funct_end);
1683      time = (time_funct_end.tv_sec - time_funct_start.tv_sec) * 1.0 +
1684             (time_funct_end.tv_nsec - time_funct_start.tv_nsec) / 1000000000.0;
1685  #  endif
1686    }
1687    return time;
1688  }
1689  static double getLineMasksMorphMicroBench(GPUEnv *env, TessScoreEvaluationInputData input,
1690                                            ds_device_type type) {
1691    double time = 0;
1692  #  if ON_WINDOWS
1693    LARGE_INTEGER freq, time_funct_start, time_funct_end;
1694    QueryPerformanceFrequency(&amp;freq);
1695  #  elif ON_APPLE
1696    mach_timebase_info_data_t info = {0, 0};
1697    mach_timebase_info(&amp;info);
1698    long long start, stop;
1699  #  else
1700    timespec time_funct_start, time_funct_end;
1701  #  endif
1702    int resolution = 300;
1703    int wpl = pixGetWpl(input.pix);
1704    int kThinLineFraction = 20;     
1705    int kMinLineLengthFraction = 4; 
1706    int max_line_width = resolution / kThinLineFraction;
1707    int min_line_length = resolution / kMinLineLengthFraction;
1708    int closing_brick = max_line_width / 3;
1709    if (type == DS_DEVICE_OPENCL_DEVICE) {
1710  #  if ON_WINDOWS
1711      QueryPerformanceCounter(&amp;time_funct_start);
1712  #  elif ON_APPLE
1713      start = mach_absolute_time();
1714  #  else
1715      clock_gettime(CLOCK_MONOTONIC, &amp;time_funct_start);
1716  #  endif
1717      OpenclDevice::gpuEnv = *env;
1718      OpenclDevice::initMorphCLAllocations(wpl, input.height, input.pix);
1719      Image pix_vline = nullptr, pix_hline = nullptr, pix_closed = nullptr;
1720      OpenclDevice::pixGetLinesCL(nullptr, input.pix, &amp;pix_vline, &amp;pix_hline, &amp;pix_closed, true,
1721                                  closing_brick, closing_brick, max_line_width, max_line_width,
1722                                  min_line_length, min_line_length);
1723      OpenclDevice::releaseMorphCLBuffers();
1724  #  if ON_WINDOWS
1725      QueryPerformanceCounter(&amp;time_funct_end);
1726      time = (time_funct_end.QuadPart - time_funct_start.QuadPart) / (double)(freq.QuadPart);
1727  #  elif ON_APPLE
1728      stop = mach_absolute_time();
1729      time = ((stop - start) * (double)info.numer / info.denom) / 1.0E9;
1730  #  else
1731      clock_gettime(CLOCK_MONOTONIC, &amp;time_funct_end);
1732      time = (time_funct_end.tv_sec - time_funct_start.tv_sec) * 1.0 +
1733             (time_funct_end.tv_nsec - time_funct_start.tv_nsec) / 1000000000.0;
1734  #  endif
1735    } else {
1736  #  if ON_WINDOWS
1737      QueryPerformanceCounter(&amp;time_funct_start);
1738  #  elif ON_APPLE
1739      start = mach_absolute_time();
1740  #  else
1741      clock_gettime(CLOCK_MONOTONIC, &amp;time_funct_start);
1742  #  endif
1743      Image src_pix = input.pix;
1744      Image pix_closed = pixCloseBrick(nullptr, src_pix, closing_brick, closing_brick);
1745      Image pix_solid = pixOpenBrick(nullptr, pix_closed, max_line_width, max_line_width);
1746      Image pix_hollow = pixSubtract(nullptr, pix_closed, pix_solid);
1747      pix_solid.destroy();
1748      Image pix_vline = pixOpenBrick(nullptr, pix_hollow, 1, min_line_length);
1749      Image pix_hline = pixOpenBrick(nullptr, pix_hollow, min_line_length, 1);
1750      pix_hline.destroy();
1751      pix_vline.destroy();
1752      pix_hollow.destroy();
1753  #  if ON_WINDOWS
1754      QueryPerformanceCounter(&amp;time_funct_end);
1755      time = (time_funct_end.QuadPart - time_funct_start.QuadPart) / (double)(freq.QuadPart);
1756  #  elif ON_APPLE
1757      stop = mach_absolute_time();
1758      time = ((stop - start) * (double)info.numer / info.denom) / 1.0E9;
1759  #  else
1760      clock_gettime(CLOCK_MONOTONIC, &amp;time_funct_end);
1761      time = (time_funct_end.tv_sec - time_funct_start.tv_sec) * 1.0 +
1762             (time_funct_end.tv_nsec - time_funct_start.tv_nsec) / 1000000000.0;
1763  #  endif
1764    }
1765    return time;
1766  }
1767  static ds_status serializeScore(ds_device *device, uint8_t **serializedScore,
1768                                  unsigned int *serializedScoreSize) {
1769    *serializedScoreSize = sizeof(TessDeviceScore);
1770    *serializedScore = new uint8_t[*serializedScoreSize];
1771    memcpy(*serializedScore, device-&gt;score, *serializedScoreSize);
1772    return DS_SUCCESS;
1773  }
1774  static ds_status deserializeScore(ds_device *device, const uint8_t *serializedScore,
1775                                    unsigned int serializedScoreSize) {
1776    device-&gt;score = new TessDeviceScore;
1777    memcpy(device-&gt;score, serializedScore, serializedScoreSize);
1778    return DS_SUCCESS;
1779  }
1780  static ds_status releaseScore(TessDeviceScore *score) {
1781    delete score;
1782    return DS_SUCCESS;
1783  }
1784  static ds_status evaluateScoreForDevice(ds_device *device, void *inputData) {
1785    tprintf(&quot;\n[DS] Device: \&quot;%s\&quot; (%s) evaluation...\n&quot;, device-&gt;oclDeviceName,
1786            device-&gt;type == DS_DEVICE_OPENCL_DEVICE ? &quot;OpenCL&quot; : &quot;Native&quot;);
1787    GPUEnv *env = nullptr;
1788    if (device-&gt;type == DS_DEVICE_OPENCL_DEVICE) {
1789      env = &amp;OpenclDevice::gpuEnv;
1790      memset(env, 0, sizeof(*env));
1791      populateGPUEnvFromDevice(env, device-&gt;oclDeviceID);
1792      env-&gt;mnFileCount = 0; 
1793      env-&gt;mnKernelCount = 0UL;
1794      OpenclDevice::CompileKernelFile(env, &quot;&quot;);
1795    }
1796    TessScoreEvaluationInputData *input = static_cast&lt;TessScoreEvaluationInputData *&gt;(inputData);
1797    double composeRGBPixelTime = composeRGBPixelMicroBench(env, *input, device-&gt;type);
1798    double histogramRectTime = histogramRectMicroBench(env, *input, device-&gt;type);
1799    double thresholdRectToPixTime = thresholdRectToPixMicroBench(env, *input, device-&gt;type);
1800    double getLineMasksMorphTime = getLineMasksMorphMicroBench(env, *input, device-&gt;type);
1801    float composeRGBPixelWeight = 1.2f;
1802    float histogramRectWeight = 2.4f;
1803    float thresholdRectToPixWeight = 4.5f;
1804    float getLineMasksMorphWeight = 5.0f;
1805    float weightedTime = composeRGBPixelWeight * composeRGBPixelTime +
1806                         histogramRectWeight * histogramRectTime +
1807                         thresholdRectToPixWeight * thresholdRectToPixTime +
1808                         getLineMasksMorphWeight * getLineMasksMorphTime;
1809    device-&gt;score = new TessDeviceScore;
1810    device-&gt;score-&gt;time = weightedTime;
1811    tprintf(&quot;[DS] Device: \&quot;%s\&quot; (%s) evaluated\n&quot;, device-&gt;oclDeviceName,
1812            device-&gt;type == DS_DEVICE_OPENCL_DEVICE ? &quot;OpenCL&quot; : &quot;Native&quot;);
1813    tprintf(&quot;[DS]%25s: %f (w=%.1f)\n&quot;, &quot;composeRGBPixel&quot;, composeRGBPixelTime, composeRGBPixelWeight);
1814    tprintf(&quot;[DS]%25s: %f (w=%.1f)\n&quot;, &quot;HistogramRect&quot;, histogramRectTime, histogramRectWeight);
1815    tprintf(&quot;[DS]%25s: %f (w=%.1f)\n&quot;, &quot;ThresholdRectToPix&quot;, thresholdRectToPixTime,
1816            thresholdRectToPixWeight);
1817    tprintf(&quot;[DS]%25s: %f (w=%.1f)\n&quot;, &quot;getLineMasksMorph&quot;, getLineMasksMorphTime,
1818            getLineMasksMorphWeight);
1819    tprintf(&quot;[DS]%25s: %f\n&quot;, &quot;Score&quot;, device-&gt;score-&gt;time);
1820    return DS_SUCCESS;
1821  }
1822  ds_device OpenclDevice::getDeviceSelection() {
1823    if (!deviceIsSelected) {
1824      if (1 == LoadOpencl()) {
1825        ds_status status;
1826        ds_profile *profile;
1827        status = initDSProfile(&amp;profile, &quot;v0.1&quot;);
1828        const char *fileName = &quot;tesseract_opencl_profile_devices.dat&quot;;
1829        status = readProfileFromFile(profile, deserializeScore, fileName);
1830        if (status != DS_SUCCESS) {
1831          tprintf(&quot;[DS] Profile file not available (%s); performing profiling.\n&quot;, fileName);
1832          TessScoreEvaluationInputData input;
1833          populateTessScoreEvaluationInputData(&amp;input);
1834          unsigned int numUpdates;
1835          status =
1836              profileDevices(profile, DS_EVALUATE_ALL, evaluateScoreForDevice, &amp;input, &amp;numUpdates);
1837          if (status == DS_SUCCESS) {
1838            status = writeProfileToFile(profile, serializeScore, fileName);
1839            if (status == DS_SUCCESS) {
1840              tprintf(&quot;[DS] Scores written to file (%s).\n&quot;, fileName);
1841            } else {
1842              tprintf(
1843                  &quot;[DS] Error saving scores to file (%s); scores not written to &quot;
1844                  &quot;file.\n&quot;,
1845                  fileName);
1846            }
1847          } else {
1848            tprintf(
1849                &quot;[DS] Unable to evaluate performance; scores not written to &quot;
1850                &quot;file.\n&quot;);
1851          }
1852        } else {
1853          tprintf(&quot;[DS] Profile read from file (%s).\n&quot;, fileName);
1854        }
1855        float bestTime = FLT_MAX; 
1856        int bestDeviceIdx = -1;
1857        for (unsigned d = 0; d &lt; profile-&gt;numDevices; d++) {
1858          ds_device device = profile-&gt;devices[d];
1859          if (device.score == nullptr)
1860            continue;
1861          TessDeviceScore score = *device.score;
1862          float time = score.time;
1863          tprintf(&quot;[DS] Device[%u] %i:%s score is %f\n&quot;, d + 1, device.type, device.oclDeviceName,
1864                  time);
1865          if (time &lt; bestTime) {
1866            bestTime = time;
1867            bestDeviceIdx = d;
1868          }
1869        }
1870        if (bestDeviceIdx &gt;= 0) {
1871          tprintf(
1872              &quot;[DS] Selected Device[%i]: \&quot;%s\&quot; (%s)\n&quot;, bestDeviceIdx + 1,
1873              profile-&gt;devices[bestDeviceIdx].oclDeviceName,
1874              profile-&gt;devices[bestDeviceIdx].type == DS_DEVICE_OPENCL_DEVICE ? &quot;OpenCL&quot; : &quot;Native&quot;);
1875        }
1876        bool overridden = false;
1877        char *overrideDeviceStr = getenv(&quot;TESSERACT_OPENCL_DEVICE&quot;);
1878        if (overrideDeviceStr != nullptr) {
1879          int overrideDeviceIdx = atoi(overrideDeviceStr);
1880          if (overrideDeviceIdx &gt; 0 &amp;&amp; overrideDeviceIdx &lt;= profile-&gt;numDevices) {
1881            tprintf(
1882                &quot;[DS] Overriding Device Selection (TESSERACT_OPENCL_DEVICE=%s, &quot;
1883                &quot;%i)\n&quot;,
1884                overrideDeviceStr, overrideDeviceIdx);
1885            bestDeviceIdx = overrideDeviceIdx - 1;
1886            overridden = true;
1887          } else {
1888            tprintf(
1889                &quot;[DS] Ignoring invalid TESSERACT_OPENCL_DEVICE=%s ([1,%i] are &quot;
1890                &quot;valid devices).\n&quot;,
1891                overrideDeviceStr, profile-&gt;numDevices);
1892          }
1893        }
1894        if (overridden) {
1895          tprintf(
1896              &quot;[DS] Overridden Device[%i]: \&quot;%s\&quot; (%s)\n&quot;, bestDeviceIdx + 1,
1897              profile-&gt;devices[bestDeviceIdx].oclDeviceName,
1898              profile-&gt;devices[bestDeviceIdx].type == DS_DEVICE_OPENCL_DEVICE ? &quot;OpenCL&quot; : &quot;Native&quot;);
1899        }
1900        selectedDevice = profile-&gt;devices[bestDeviceIdx];
1901        releaseDSProfile(profile, releaseScore);
1902      } else {
1903        tprintf(&quot;[DS] OpenCL runtime not available.\n&quot;);
1904        selectedDevice.type = DS_DEVICE_NATIVE_CPU;
1905        selectedDevice.oclDeviceName = &quot;(null)&quot;;
1906        selectedDevice.score = nullptr;
1907        selectedDevice.oclDeviceID = nullptr;
1908        selectedDevice.oclDriverVersion = nullptr;
1909      }
1910      deviceIsSelected = true;
1911    }
1912    return selectedDevice;
1913  }
1914  bool OpenclDevice::selectedDeviceIsOpenCL() {
1915    ds_device device = getDeviceSelection();
1916    return (device.type == DS_DEVICE_OPENCL_DEVICE);
1917  }
1918  } 
1919  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-openclwrapper.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-openclwrapper.cpp</div>
                </div>
                <div class="column column_space"><pre><code>1196    cl_mem imageBuffer =
1197        clCreateBuffer(histKern.mpkContext, CL_MEM_READ_ONLY | CL_MEM_USE_HOST_PTR,
1198                       width * height * bytes_per_pixel * sizeof(char), imageData, &amp;clStatus);
1199    CHECK_OPENCL(clStatus, &quot;clCreateBuffer imageBuffer&quot;);
1200    int block_size = 256;
</pre></code></div>
                <div class="column column_space"><pre><code>1311    cl_mem imageBuffer =
1312        clCreateBuffer(rEnv.mpkContext, CL_MEM_READ_ONLY | CL_MEM_USE_HOST_PTR,
1313                       width * height * bytes_per_pixel * sizeof(char), imageData, &amp;clStatus);
1314    CHECK_OPENCL(clStatus, &quot;clCreateBuffer imageBuffer&quot;);
1315    pixThBuffer = clCreateBuffer(rEnv.mpkContext, CL_MEM_READ_WRITE | CL_MEM_USE_HOST_PTR, pixSize,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    