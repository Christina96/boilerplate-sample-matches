
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 12.093023255813954%, Tokens: 13</h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-account_store.cpp</h3>
            <pre><code>1  #include <nano/node/rocksdb/account_store.hpp>
2  #include <nano/node/rocksdb/rocksdb.hpp>
3  #include <nano/secure/parallel_traversal.hpp>
4  nano::rocksdb::account_store::account_store (nano::rocksdb::store & store_a) :
5  	store (store_a){};
6  void nano::rocksdb::account_store::put (nano::write_transaction const & transaction, nano::account const & account, nano::account_info const & info)
7  {
8  	auto status = store.put (transaction, tables::accounts, account, info);
9  	store.release_assert_success (status);
10  }
11  bool nano::rocksdb::account_store::get (nano::transaction const & transaction, nano::account const & account, nano::account_info & info)
12  {
13  	nano::rocksdb_val value;
14  	auto status1 (store.get (transaction, tables::accounts, account, value));
15  	release_assert (store.success (status1) || store.not_found (status1));
16  	bool result (true);
17  	if (store.success (status1))
18  	{
19  		nano::bufferstream stream (reinterpret_cast<uint8_t const *> (value.data ()), value.size ());
20  		result = info.deserialize (stream);
21  	}
22  	return result;
23  }
24  void nano::rocksdb::account_store::del (nano::write_transaction const & transaction_a, nano::account const & account_a)
25  {
26  	auto status = store.del (transaction_a, tables::accounts, account_a);
27  	store.release_assert_success (status);
28  }
29  bool nano::rocksdb::account_store::exists (nano::transaction const & transaction_a, nano::account const & account_a)
30  {
31  	auto iterator (begin (transaction_a, account_a));
32  	return iterator != end () && nano::account (iterator->first) == account_a;
33  }
34  size_t nano::rocksdb::account_store::count (nano::transaction const & transaction_a)
35  {
36  	return store.count (transaction_a, tables::accounts);
37  }
38  nano::store_iterator<nano::account, nano::account_info> nano::rocksdb::account_store::begin (nano::transaction const & transaction, nano::account const & account) const
39  {
40  	return store.make_iterator<nano::account, nano::account_info> (transaction, tables::accounts, account);
41  }
42  nano::store_iterator<nano::account, nano::account_info> nano::rocksdb::account_store::begin (nano::transaction const & transaction) const
<span onclick='openModal()' class='match'>43  {
44  	return store.make_iterator<nano::account, nano::account_info> (transaction, tables::accounts);
45  }
46  nano::store_iterator<nano::account, nano::account_info> nano::rocksdb::account_store::rbegin (nano::transaction const & transaction_a) const
47  {
48  	return store.make_iterator<nano::account, nano::account_info> (transaction_a, tables::accounts, false);
49  }
50  nano::store_iterator<nano::account, nano::account_info> nano::rocksdb::account_store::end () const
51  {
52  	return nano::store_iterator<nano::account, nano::account_info> (nullptr);
53  }
54  void nano::rocksdb::account_store::for_each_par (std::function<void (nano::read_transaction const &, nano::store_iterator<nano::account, nano::account_info>, nano::store_iterator<nano::account, nano::account_info>)> const & action_a) const
</span>55  {
56  	parallel_traversal<nano::uint256_t> (
57  	[&action_a, this] (nano::uint256_t const & start, nano::uint256_t const & end, bool const is_last) {
58  		auto transaction (this->store.tx_begin_read ());
59  		action_a (transaction, this->begin (transaction, start), !is_last ? this->begin (transaction, end) : this->end ());
60  	});
61  }
</code></pre>
        </div>
        <div class="column">
            <h3>MMKV-MDEwOlJlcG9zaXRvcnkxNDkxMTE4MTM=-flat-MemoryFile.h</h3>
            <pre><code>1  #ifndef MMKV_MAMERYFILE_H
2  #define MMKV_MAMERYFILE_H
3  #ifdef __cplusplus
4  #include "MMKVPredef.h"
5  #include <functional>
6  #ifdef MMKV_ANDROID
7  MMKVPath_t ashmemMMKVPathWithID(const MMKVPath_t &mmapID);
8  namespace mmkv {
9  extern int g_android_api;
10  extern std::string g_android_tmpDir;
11  enum FileType : bool { MMFILE_TYPE_FILE = false, MMFILE_TYPE_ASHMEM = true };
12  } 
13  #endif 
14  namespace mmkv {
15  enum class OpenFlag : uint32_t {
16      ReadOnly = 1 << 0,
17      WriteOnly = 1 << 1,
18      ReadWrite = ReadOnly | WriteOnly,
19      Create = 1 << 2,
20      Excel = 1 << 3, 
21      Truncate = 1 << 4,
22  };
23  static inline OpenFlag operator | (OpenFlag left, OpenFlag right) {
24      return static_cast<OpenFlag>(static_cast<uint32_t>(left) | static_cast<uint32_t>(right));
25  }
26  static inline bool operator & (OpenFlag left, OpenFlag right) {
27      return ((static_cast<uint32_t>(left) & static_cast<uint32_t>(right)) != 0);
28  }
29  class File {
30      MMKVPath_t m_path;
31      MMKVFileHandle_t m_fd;
32  public:
33      const OpenFlag m_flag;
34  #ifndef MMKV_ANDROID
35      explicit File(MMKVPath_t path, OpenFlag flag);
36  #else
37      File(MMKVPath_t path, OpenFlag flag, size_t size = 0, FileType fileType = MMFILE_TYPE_FILE);
38      explicit File(MMKVFileHandle_t ashmemFD);
39      size_t m_size;
40      const FileType m_fileType;
41  #endif 
42      ~File() { close(); }
43      bool open();
44      void close();
<span onclick='openModal()' class='match'>45      MMKVFileHandle_t getFd() { return m_fd; }
46      const MMKVPath_t &getPath() const { return m_path; }
47  #ifndef MMKV_WIN32
48      bool isFileValid() const { return m_fd >= 0; }
49  #else
50      bool isFileValid() const { return m_fd != INVALID_HANDLE_VALUE; }
</span>51  #endif
52      size_t getActualFileSize() const;
53      explicit File(const File &other) = delete;
54      File &operator=(const File &other) = delete;
55      friend class MemoryFile;
56  };
57  class MemoryFile {
58      File m_diskFile;
59  #ifdef MMKV_WIN32
60      HANDLE m_fileMapping;
61  #endif
62      void *m_ptr;
63      size_t m_size;
64      bool mmap();
65      void doCleanMemoryCache(bool forceClean);
66  public:
67  #ifndef MMKV_ANDROID
68      explicit MemoryFile(MMKVPath_t path);
69  #else
70      MemoryFile(MMKVPath_t path, size_t size, FileType fileType);
71      explicit MemoryFile(MMKVFileHandle_t ashmemFD);
72      const FileType m_fileType;
73  #endif 
74      ~MemoryFile() { doCleanMemoryCache(true); }
75      size_t getFileSize() const { return m_size; }
76      size_t getActualFileSize() const { return m_diskFile.getActualFileSize(); }
77      void *getMemory() { return m_ptr; }
78      const MMKVPath_t &getPath() { return m_diskFile.getPath(); }
79      MMKVFileHandle_t getFd() { return m_diskFile.getFd(); }
80      bool truncate(size_t size);
81      bool msync(SyncFlag syncFlag);
82      void reloadFromFile();
83      void clearMemoryCache() { doCleanMemoryCache(false); }
84  #ifndef MMKV_WIN32
85      bool isFileValid() { return m_diskFile.isFileValid() && m_size > 0 && m_ptr; }
86  #else
87      bool isFileValid() { return m_diskFile.isFileValid() && m_size > 0 && m_fileMapping && m_ptr; }
88  #endif
89      explicit MemoryFile(const MemoryFile &other) = delete;
90      MemoryFile &operator=(const MemoryFile &other) = delete;
91  };
92  class MMBuffer;
93  extern bool mkPath(const MMKVPath_t &path);
94  extern bool isFileExist(const MMKVPath_t &nsFilePath);
95  extern MMBuffer *readWholeFile(const MMKVPath_t &path);
96  extern bool zeroFillFile(MMKVFileHandle_t fd, size_t startPos, size_t size);
97  extern size_t getPageSize();
98  extern bool tryAtomicRename(const MMKVPath_t &srcPath, const MMKVPath_t &dstPath);
99  extern bool copyFile(const MMKVPath_t &srcPath, const MMKVPath_t &dstPath);
100  extern bool copyFileContent(const MMKVPath_t &srcPath, const MMKVPath_t &dstPath);
101  extern bool copyFileContent(const MMKVPath_t &srcPath, MMKVFileHandle_t dstFD);
102  extern bool copyFileContent(const MMKVPath_t &srcPath, MMKVFileHandle_t dstFD, bool needTruncate);
103  enum WalkType : uint32_t {
104      WalkFile = 1 << 0,
105      WalkFolder = 1 << 1,
106  };
107  extern void walkInDir(const MMKVPath_t &dirPath, WalkType type, const std::function<void(const MMKVPath_t&, WalkType)> &walker);
108  } 
109  #endif
110  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-account_store.cpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from MMKV-MDEwOlJlcG9zaXRvcnkxNDkxMTE4MTM=-flat-MemoryFile.h</div>
                <div class="column column_space"><pre><code>43  {
44  	return store.make_iterator<nano::account, nano::account_info> (transaction, tables::accounts);
45  }
46  nano::store_iterator<nano::account, nano::account_info> nano::rocksdb::account_store::rbegin (nano::transaction const & transaction_a) const
47  {
48  	return store.make_iterator<nano::account, nano::account_info> (transaction_a, tables::accounts, false);
49  }
50  nano::store_iterator<nano::account, nano::account_info> nano::rocksdb::account_store::end () const
51  {
52  	return nano::store_iterator<nano::account, nano::account_info> (nullptr);
53  }
54  void nano::rocksdb::account_store::for_each_par (std::function<void (nano::read_transaction const &, nano::store_iterator<nano::account, nano::account_info>, nano::store_iterator<nano::account, nano::account_info>)> const & action_a) const
</pre></code></div>
                <div class="column column_space"><pre><code>45      MMKVFileHandle_t getFd() { return m_fd; }
46      const MMKVPath_t &getPath() const { return m_path; }
47  #ifndef MMKV_WIN32
48      bool isFileValid() const { return m_fd >= 0; }
49  #else
50      bool isFileValid() const { return m_fd != INVALID_HANDLE_VALUE; }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    