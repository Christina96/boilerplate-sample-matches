
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 799, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-unordered_set_constructor_test.h</h3>
            <pre><code>1  #ifndef ABSL_CONTAINER_INTERNAL_UNORDERED_SET_CONSTRUCTOR_TEST_H_
2  #define ABSL_CONTAINER_INTERNAL_UNORDERED_SET_CONSTRUCTOR_TEST_H_
3  #include <algorithm>
4  #include <unordered_set>
5  #include <vector>
6  #include "gmock/gmock.h"
7  #include "gtest/gtest.h"
8  #include "absl/container/internal/hash_generator_testing.h"
9  #include "absl/container/internal/hash_policy_testing.h"
10  #include "absl/meta/type_traits.h"
11  namespace absl {
12  ABSL_NAMESPACE_BEGIN
13  namespace container_internal {
14  template <class UnordMap>
15  class ConstructorTest : public ::testing::Test {};
16  TYPED_TEST_SUITE_P(ConstructorTest);
17  TYPED_TEST_P(ConstructorTest, NoArgs) {
18    TypeParam m;
19    EXPECT_TRUE(m.empty());
20    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAre());
21  }
22  TYPED_TEST_P(ConstructorTest, BucketCount) {
23    TypeParam m(123);
24    EXPECT_TRUE(m.empty());
25    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAre());
26    EXPECT_GE(m.bucket_count(), 123);
27  }
28  TYPED_TEST_P(ConstructorTest, BucketCountHash) {
29    using H = typename TypeParam::hasher;
30    H hasher;
31    TypeParam m(123, hasher);
32    EXPECT_EQ(m.hash_function(), hasher);
33    EXPECT_TRUE(m.empty());
34    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAre());
35    EXPECT_GE(m.bucket_count(), 123);
36  }
37  TYPED_TEST_P(ConstructorTest, BucketCountHashEqual) {
38    using H = typename TypeParam::hasher;
39    using E = typename TypeParam::key_equal;
40    H hasher;
41    E equal;
42    TypeParam m(123, hasher, equal);
43    EXPECT_EQ(m.hash_function(), hasher);
44    EXPECT_EQ(m.key_eq(), equal);
45    EXPECT_TRUE(m.empty());
46    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAre());
47    EXPECT_GE(m.bucket_count(), 123);
48  }
49  TYPED_TEST_P(ConstructorTest, BucketCountHashEqualAlloc) {
50    using H = typename TypeParam::hasher;
51    using E = typename TypeParam::key_equal;
52    using A = typename TypeParam::allocator_type;
53    H hasher;
54    E equal;
55    A alloc(0);
56    TypeParam m(123, hasher, equal, alloc);
57    EXPECT_EQ(m.hash_function(), hasher);
58    EXPECT_EQ(m.key_eq(), equal);
59    EXPECT_EQ(m.get_allocator(), alloc);
60    EXPECT_TRUE(m.empty());
61    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAre());
62    EXPECT_GE(m.bucket_count(), 123);
63    const auto& cm = m;
64    EXPECT_EQ(cm.hash_function(), hasher);
65    EXPECT_EQ(cm.key_eq(), equal);
66    EXPECT_EQ(cm.get_allocator(), alloc);
67    EXPECT_TRUE(cm.empty());
68    EXPECT_THAT(keys(cm), ::testing::UnorderedElementsAre());
69    EXPECT_GE(cm.bucket_count(), 123);
70  }
71  template <typename T>
72  struct is_std_unordered_set : std::false_type {};
73  template <typename... T>
74  struct is_std_unordered_set<std::unordered_set<T...>> : std::true_type {};
75  #if defined(UNORDERED_SET_CXX14) || defined(UNORDERED_SET_CXX17)
76  using has_cxx14_std_apis = std::true_type;
77  #else
78  using has_cxx14_std_apis = std::false_type;
79  #endif
80  template <typename T>
81  using expect_cxx14_apis =
82      absl::disjunction<absl::negation<is_std_unordered_set<T>>,
83                        has_cxx14_std_apis>;
84  template <typename TypeParam>
85  void BucketCountAllocTest(std::false_type) {}
86  template <typename TypeParam>
87  void BucketCountAllocTest(std::true_type) {
88    using A = typename TypeParam::allocator_type;
89    A alloc(0);
90    TypeParam m(123, alloc);
91    EXPECT_EQ(m.get_allocator(), alloc);
92    EXPECT_TRUE(m.empty());
93    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAre());
94    EXPECT_GE(m.bucket_count(), 123);
95  }
96  TYPED_TEST_P(ConstructorTest, BucketCountAlloc) {
97    BucketCountAllocTest<TypeParam>(expect_cxx14_apis<TypeParam>());
98  }
99  template <typename TypeParam>
100  void BucketCountHashAllocTest(std::false_type) {}
101  template <typename TypeParam>
102  void BucketCountHashAllocTest(std::true_type) {
103    using H = typename TypeParam::hasher;
104    using A = typename TypeParam::allocator_type;
105    H hasher;
106    A alloc(0);
107    TypeParam m(123, hasher, alloc);
108    EXPECT_EQ(m.hash_function(), hasher);
109    EXPECT_EQ(m.get_allocator(), alloc);
110    EXPECT_TRUE(m.empty());
111    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAre());
112    EXPECT_GE(m.bucket_count(), 123);
113  }
114  TYPED_TEST_P(ConstructorTest, BucketCountHashAlloc) {
115    BucketCountHashAllocTest<TypeParam>(expect_cxx14_apis<TypeParam>());
116  }
117  #if ABSL_UNORDERED_SUPPORTS_ALLOC_CTORS
118  using has_alloc_std_constructors = std::true_type;
119  #else
120  using has_alloc_std_constructors = std::false_type;
121  #endif
122  template <typename T>
123  using expect_alloc_constructors =
124      absl::disjunction<absl::negation<is_std_unordered_set<T>>,
125                        has_alloc_std_constructors>;
126  template <typename TypeParam>
127  void AllocTest(std::false_type) {}
128  template <typename TypeParam>
129  void AllocTest(std::true_type) {
130    using A = typename TypeParam::allocator_type;
131    A alloc(0);
132    TypeParam m(alloc);
133    EXPECT_EQ(m.get_allocator(), alloc);
134    EXPECT_TRUE(m.empty());
135    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAre());
136  }
137  TYPED_TEST_P(ConstructorTest, Alloc) {
138    AllocTest<TypeParam>(expect_alloc_constructors<TypeParam>());
139  }
140  TYPED_TEST_P(ConstructorTest, InputIteratorBucketHashEqualAlloc) {
141    using T = hash_internal::GeneratedType<TypeParam>;
142    using H = typename TypeParam::hasher;
143    using E = typename TypeParam::key_equal;
144    using A = typename TypeParam::allocator_type;
145    H hasher;
146    E equal;
147    A alloc(0);
148    std::vector<T> values;
149    for (size_t i = 0; i != 10; ++i)
150      values.push_back(hash_internal::Generator<T>()());
151    TypeParam m(values.begin(), values.end(), 123, hasher, equal, alloc);
152    EXPECT_EQ(m.hash_function(), hasher);
153    EXPECT_EQ(m.key_eq(), equal);
154    EXPECT_EQ(m.get_allocator(), alloc);
155    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAreArray(values));
156    EXPECT_GE(m.bucket_count(), 123);
157  }
158  template <typename TypeParam>
159  void InputIteratorBucketAllocTest(std::false_type) {}
160  template <typename TypeParam>
161  void InputIteratorBucketAllocTest(std::true_type) {
162    using T = hash_internal::GeneratedType<TypeParam>;
163    using A = typename TypeParam::allocator_type;
164    A alloc(0);
165    std::vector<T> values;
166    for (size_t i = 0; i != 10; ++i)
167      values.push_back(hash_internal::Generator<T>()());
168    TypeParam m(values.begin(), values.end(), 123, alloc);
169    EXPECT_EQ(m.get_allocator(), alloc);
170    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAreArray(values));
171    EXPECT_GE(m.bucket_count(), 123);
172  }
173  TYPED_TEST_P(ConstructorTest, InputIteratorBucketAlloc) {
174    InputIteratorBucketAllocTest<TypeParam>(expect_cxx14_apis<TypeParam>());
175  }
176  template <typename TypeParam>
177  void InputIteratorBucketHashAllocTest(std::false_type) {}
178  template <typename TypeParam>
179  void InputIteratorBucketHashAllocTest(std::true_type) {
180    using T = hash_internal::GeneratedType<TypeParam>;
181    using H = typename TypeParam::hasher;
182    using A = typename TypeParam::allocator_type;
183    H hasher;
184    A alloc(0);
185    std::vector<T> values;
186    for (size_t i = 0; i != 10; ++i)
187      values.push_back(hash_internal::Generator<T>()());
188    TypeParam m(values.begin(), values.end(), 123, hasher, alloc);
189    EXPECT_EQ(m.hash_function(), hasher);
190    EXPECT_EQ(m.get_allocator(), alloc);
191    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAreArray(values));
192    EXPECT_GE(m.bucket_count(), 123);
193  }
194  TYPED_TEST_P(ConstructorTest, InputIteratorBucketHashAlloc) {
195    InputIteratorBucketHashAllocTest<TypeParam>(expect_cxx14_apis<TypeParam>());
196  }
197  TYPED_TEST_P(ConstructorTest, CopyConstructor) {
198    using T = hash_internal::GeneratedType<TypeParam>;
199    using H = typename TypeParam::hasher;
200    using E = typename TypeParam::key_equal;
201    using A = typename TypeParam::allocator_type;
202    H hasher;
203    E equal;
204    A alloc(0);
205    TypeParam m(123, hasher, equal, alloc);
206    for (size_t i = 0; i != 10; ++i) m.insert(hash_internal::Generator<T>()());
207    TypeParam n(m);
208    EXPECT_EQ(m.hash_function(), n.hash_function());
209    EXPECT_EQ(m.key_eq(), n.key_eq());
210    EXPECT_EQ(m.get_allocator(), n.get_allocator());
211    EXPECT_EQ(m, n);
212    EXPECT_NE(TypeParam(0, hasher, equal, alloc), n);
213  }
214  template <typename TypeParam>
215  void CopyConstructorAllocTest(std::false_type) {}
216  template <typename TypeParam>
217  void CopyConstructorAllocTest(std::true_type) {
218    using T = hash_internal::GeneratedType<TypeParam>;
219    using H = typename TypeParam::hasher;
220    using E = typename TypeParam::key_equal;
221    using A = typename TypeParam::allocator_type;
222    H hasher;
223    E equal;
224    A alloc(0);
225    TypeParam m(123, hasher, equal, alloc);
226    for (size_t i = 0; i != 10; ++i) m.insert(hash_internal::Generator<T>()());
227    TypeParam n(m, A(11));
228    EXPECT_EQ(m.hash_function(), n.hash_function());
229    EXPECT_EQ(m.key_eq(), n.key_eq());
230    EXPECT_NE(m.get_allocator(), n.get_allocator());
231    EXPECT_EQ(m, n);
232  }
233  TYPED_TEST_P(ConstructorTest, CopyConstructorAlloc) {
234    CopyConstructorAllocTest<TypeParam>(expect_alloc_constructors<TypeParam>());
235  }
236  TYPED_TEST_P(ConstructorTest, MoveConstructor) {
237    using T = hash_internal::GeneratedType<TypeParam>;
238    using H = typename TypeParam::hasher;
239    using E = typename TypeParam::key_equal;
240    using A = typename TypeParam::allocator_type;
241    H hasher;
242    E equal;
243    A alloc(0);
244    TypeParam m(123, hasher, equal, alloc);
245    for (size_t i = 0; i != 10; ++i) m.insert(hash_internal::Generator<T>()());
246    TypeParam t(m);
247    TypeParam n(std::move(t));
248    EXPECT_EQ(m.hash_function(), n.hash_function());
249    EXPECT_EQ(m.key_eq(), n.key_eq());
250    EXPECT_EQ(m.get_allocator(), n.get_allocator());
251    EXPECT_EQ(m, n);
252  }
253  template <typename TypeParam>
254  void MoveConstructorAllocTest(std::false_type) {}
255  template <typename TypeParam>
256  void MoveConstructorAllocTest(std::true_type) {
257    using T = hash_internal::GeneratedType<TypeParam>;
258    using H = typename TypeParam::hasher;
259    using E = typename TypeParam::key_equal;
260    using A = typename TypeParam::allocator_type;
261    H hasher;
262    E equal;
263    A alloc(0);
264    TypeParam m(123, hasher, equal, alloc);
265    for (size_t i = 0; i != 10; ++i) m.insert(hash_internal::Generator<T>()());
266    TypeParam t(m);
267    TypeParam n(std::move(t), A(1));
268    EXPECT_EQ(m.hash_function(), n.hash_function());
269    EXPECT_EQ(m.key_eq(), n.key_eq());
270    EXPECT_NE(m.get_allocator(), n.get_allocator());
271    EXPECT_EQ(m, n);
272  }
273  TYPED_TEST_P(ConstructorTest, MoveConstructorAlloc) {
274    MoveConstructorAllocTest<TypeParam>(expect_alloc_constructors<TypeParam>());
275  }
276  TYPED_TEST_P(ConstructorTest, InitializerListBucketHashEqualAlloc) {
277    using T = hash_internal::GeneratedType<TypeParam>;
278    hash_internal::Generator<T> gen;
279    std::initializer_list<T> values = {gen(), gen(), gen(), gen(), gen()};
280    using H = typename TypeParam::hasher;
281    using E = typename TypeParam::key_equal;
282    using A = typename TypeParam::allocator_type;
283    H hasher;
284    E equal;
285    A alloc(0);
286    TypeParam m(values, 123, hasher, equal, alloc);
287    EXPECT_EQ(m.hash_function(), hasher);
288    EXPECT_EQ(m.key_eq(), equal);
289    EXPECT_EQ(m.get_allocator(), alloc);
290    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAreArray(values));
291    EXPECT_GE(m.bucket_count(), 123);
292  }
293  template <typename TypeParam>
294  void InitializerListBucketAllocTest(std::false_type) {}
295  template <typename TypeParam>
296  void InitializerListBucketAllocTest(std::true_type) {
297    using T = hash_internal::GeneratedType<TypeParam>;
298    using A = typename TypeParam::allocator_type;
299    hash_internal::Generator<T> gen;
300    std::initializer_list<T> values = {gen(), gen(), gen(), gen(), gen()};
301    A alloc(0);
302    TypeParam m(values, 123, alloc);
303    EXPECT_EQ(m.get_allocator(), alloc);
304    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAreArray(values));
305    EXPECT_GE(m.bucket_count(), 123);
306  }
307  TYPED_TEST_P(ConstructorTest, InitializerListBucketAlloc) {
308    InitializerListBucketAllocTest<TypeParam>(expect_cxx14_apis<TypeParam>());
309  }
310  template <typename TypeParam>
311  void InitializerListBucketHashAllocTest(std::false_type) {}
312  template <typename TypeParam>
313  void InitializerListBucketHashAllocTest(std::true_type) {
314    using T = hash_internal::GeneratedType<TypeParam>;
315    using H = typename TypeParam::hasher;
316    using A = typename TypeParam::allocator_type;
317    H hasher;
318    A alloc(0);
319    hash_internal::Generator<T> gen;
320    std::initializer_list<T> values = {gen(), gen(), gen(), gen(), gen()};
<span onclick='openModal()' class='match'>321    TypeParam m(values, 123, hasher, alloc);
322    EXPECT_EQ(m.hash_function(), hasher);
323    EXPECT_EQ(m.get_allocator(), alloc);
324    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAreArray(values));
325    EXPECT_GE(m.bucket_count(), 123);
326  }
327  TYPED_TEST_P(ConstructorTest, InitializerListBucketHashAlloc) {
328    InitializerListBucketHashAllocTest<TypeParam>(expect_cxx14_apis<TypeParam>());
329  }
330  TYPED_TEST_P(ConstructorTest, CopyAssignment) {
331    using T = hash_internal::GeneratedType<TypeParam>;
332    using H = typename TypeParam::hasher;
333    using E = typename TypeParam::key_equal;
334    using A = typename TypeParam::allocator_type;
335    H hasher;
336    E equal;
337    A alloc(0);
338    hash_internal::Generator<T> gen;
339    TypeParam m({gen(), gen(), gen()}, 123, hasher, equal, alloc);
340    TypeParam n;
341    n = m;
342    EXPECT_EQ(m.hash_function(), n.hash_function());
343    EXPECT_EQ(m.key_eq(), n.key_eq());
344    EXPECT_EQ(m, n);
345  }
346  TYPED_TEST_P(ConstructorTest, MoveAssignment) {
347    using T = hash_internal::GeneratedType<TypeParam>;
348    using H = typename TypeParam::hasher;
349    using E = typename TypeParam::key_equal;
350    using A = typename TypeParam::allocator_type;
351    H hasher;
352    E equal;
353    A alloc(0);
354    hash_internal::Generator<T> gen;
355    TypeParam m({gen(), gen(), gen()}, 123, hasher, equal, alloc);
356    TypeParam t(m);
357    TypeParam n;
358    n = std::move(t);
359    EXPECT_EQ(m.hash_function(), n.hash_function());
360    EXPECT_EQ(m.key_eq(), n.key_eq());
361    EXPECT_EQ(m, n);
362  }
363  TYPED_TEST_P(ConstructorTest, AssignmentFromInitializerList) {
364    using T = hash_internal::GeneratedType<TypeParam>;
365    hash_internal::Generator<T> gen;
366    std::initializer_list<T> values = {gen(), gen(), gen(), gen(), gen()};
367    TypeParam m;
368    m = values;
369    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAreArray(values));
370  }
371  TYPED_TEST_P(ConstructorTest, AssignmentOverwritesExisting) {
372    using T = hash_internal::GeneratedType<TypeParam>;
373    hash_internal::Generator<T> gen;
374    TypeParam m({gen(), gen(), gen()});
375    TypeParam n({gen()});
376    n = m;
377    EXPECT_EQ(m, n);
378  }
379  TYPED_TEST_P(ConstructorTest, MoveAssignmentOverwritesExisting) {
380    using T = hash_internal::GeneratedType<TypeParam>;
381    hash_internal::Generator<T> gen;
382    TypeParam m({gen(), gen(), gen()});
383    TypeParam t(m);
384    TypeParam n({gen()});
385    n = std::move(t);
386    EXPECT_EQ(m, n);
387  }
388  TYPED_TEST_P(ConstructorTest, AssignmentFromInitializerListOverwritesExisting) {
389    using T = hash_internal::GeneratedType<TypeParam>;
390    hash_internal::Generator<T> gen;
391    std::initializer_list<T> values = {gen(), gen(), gen(), gen(), gen()};
392    TypeParam m;
393    m = values;
394    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAreArray(values));
395  }
396  TYPED_TEST_P(ConstructorTest, AssignmentOnSelf) {
397    using T = hash_internal::GeneratedType<TypeParam>;
398    hash_internal::Generator<T> gen;
399    std::initializer_list<T> values = {gen(), gen(), gen(), gen(), gen()};
400    TypeParam m(values);
401    m = *&m;  
402    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAreArray(values));
403  }
404  REGISTER_TYPED_TEST_SUITE_P(
405      ConstructorTest, NoArgs, BucketCount, BucketCountHash, BucketCountHashEqual,
406      BucketCountHashEqualAlloc, BucketCountAlloc, BucketCountHashAlloc, Alloc,
407      InputIteratorBucketHashEqualAlloc, InputIteratorBucketAlloc,
408      InputIteratorBucketHashAlloc, CopyConstructor, CopyConstructorAlloc,
409      MoveConstructor, MoveConstructorAlloc, InitializerListBucketHashEqualAlloc,
410      InitializerListBucketAlloc, InitializerListBucketHashAlloc, CopyAssignment,
411      MoveAssignment, AssignmentFromInitializerList, AssignmentOverwritesExisting,
412      MoveAssignmentOverwritesExisting,
413      AssignmentFromInitializerListOverwritesExisting, AssignmentOnSelf);
414  }  
415  ABSL_NAMESPACE_END
416  }  
417  #endif  
</span></code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-unordered_set_constructor_test.h</h3>
            <pre><code>1  #ifndef ABSL_CONTAINER_INTERNAL_UNORDERED_SET_CONSTRUCTOR_TEST_H_
2  #define ABSL_CONTAINER_INTERNAL_UNORDERED_SET_CONSTRUCTOR_TEST_H_
3  #include <algorithm>
4  #include <unordered_set>
5  #include <vector>
6  #include "gmock/gmock.h"
7  #include "gtest/gtest.h"
8  #include "absl/container/internal/hash_generator_testing.h"
9  #include "absl/container/internal/hash_policy_testing.h"
10  #include "absl/meta/type_traits.h"
11  namespace absl {
12  ABSL_NAMESPACE_BEGIN
13  namespace container_internal {
14  template <class UnordMap>
15  class ConstructorTest : public ::testing::Test {};
16  TYPED_TEST_SUITE_P(ConstructorTest);
17  TYPED_TEST_P(ConstructorTest, NoArgs) {
18    TypeParam m;
19    EXPECT_TRUE(m.empty());
20    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAre());
21  }
22  TYPED_TEST_P(ConstructorTest, BucketCount) {
23    TypeParam m(123);
24    EXPECT_TRUE(m.empty());
25    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAre());
26    EXPECT_GE(m.bucket_count(), 123);
27  }
28  TYPED_TEST_P(ConstructorTest, BucketCountHash) {
29    using H = typename TypeParam::hasher;
30    H hasher;
31    TypeParam m(123, hasher);
32    EXPECT_EQ(m.hash_function(), hasher);
33    EXPECT_TRUE(m.empty());
34    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAre());
35    EXPECT_GE(m.bucket_count(), 123);
36  }
37  TYPED_TEST_P(ConstructorTest, BucketCountHashEqual) {
38    using H = typename TypeParam::hasher;
39    using E = typename TypeParam::key_equal;
40    H hasher;
41    E equal;
42    TypeParam m(123, hasher, equal);
43    EXPECT_EQ(m.hash_function(), hasher);
44    EXPECT_EQ(m.key_eq(), equal);
45    EXPECT_TRUE(m.empty());
46    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAre());
47    EXPECT_GE(m.bucket_count(), 123);
48  }
49  TYPED_TEST_P(ConstructorTest, BucketCountHashEqualAlloc) {
50    using H = typename TypeParam::hasher;
51    using E = typename TypeParam::key_equal;
52    using A = typename TypeParam::allocator_type;
53    H hasher;
54    E equal;
55    A alloc(0);
56    TypeParam m(123, hasher, equal, alloc);
57    EXPECT_EQ(m.hash_function(), hasher);
58    EXPECT_EQ(m.key_eq(), equal);
59    EXPECT_EQ(m.get_allocator(), alloc);
60    EXPECT_TRUE(m.empty());
61    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAre());
62    EXPECT_GE(m.bucket_count(), 123);
63    const auto& cm = m;
64    EXPECT_EQ(cm.hash_function(), hasher);
65    EXPECT_EQ(cm.key_eq(), equal);
66    EXPECT_EQ(cm.get_allocator(), alloc);
67    EXPECT_TRUE(cm.empty());
68    EXPECT_THAT(keys(cm), ::testing::UnorderedElementsAre());
69    EXPECT_GE(cm.bucket_count(), 123);
70  }
71  template <typename T>
72  struct is_std_unordered_set : std::false_type {};
73  template <typename... T>
74  struct is_std_unordered_set<std::unordered_set<T...>> : std::true_type {};
75  #if defined(UNORDERED_SET_CXX14) || defined(UNORDERED_SET_CXX17)
76  using has_cxx14_std_apis = std::true_type;
77  #else
78  using has_cxx14_std_apis = std::false_type;
79  #endif
80  template <typename T>
81  using expect_cxx14_apis =
82      absl::disjunction<absl::negation<is_std_unordered_set<T>>,
83                        has_cxx14_std_apis>;
84  template <typename TypeParam>
85  void BucketCountAllocTest(std::false_type) {}
86  template <typename TypeParam>
87  void BucketCountAllocTest(std::true_type) {
88    using A = typename TypeParam::allocator_type;
89    A alloc(0);
90    TypeParam m(123, alloc);
91    EXPECT_EQ(m.get_allocator(), alloc);
92    EXPECT_TRUE(m.empty());
93    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAre());
94    EXPECT_GE(m.bucket_count(), 123);
95  }
96  TYPED_TEST_P(ConstructorTest, BucketCountAlloc) {
97    BucketCountAllocTest<TypeParam>(expect_cxx14_apis<TypeParam>());
98  }
99  template <typename TypeParam>
100  void BucketCountHashAllocTest(std::false_type) {}
101  template <typename TypeParam>
102  void BucketCountHashAllocTest(std::true_type) {
103    using H = typename TypeParam::hasher;
104    using A = typename TypeParam::allocator_type;
105    H hasher;
106    A alloc(0);
107    TypeParam m(123, hasher, alloc);
108    EXPECT_EQ(m.hash_function(), hasher);
109    EXPECT_EQ(m.get_allocator(), alloc);
110    EXPECT_TRUE(m.empty());
111    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAre());
112    EXPECT_GE(m.bucket_count(), 123);
113  }
114  TYPED_TEST_P(ConstructorTest, BucketCountHashAlloc) {
115    BucketCountHashAllocTest<TypeParam>(expect_cxx14_apis<TypeParam>());
116  }
117  #if ABSL_UNORDERED_SUPPORTS_ALLOC_CTORS
118  using has_alloc_std_constructors = std::true_type;
119  #else
120  using has_alloc_std_constructors = std::false_type;
121  #endif
122  template <typename T>
123  using expect_alloc_constructors =
124      absl::disjunction<absl::negation<is_std_unordered_set<T>>,
125                        has_alloc_std_constructors>;
126  template <typename TypeParam>
127  void AllocTest(std::false_type) {}
128  template <typename TypeParam>
129  void AllocTest(std::true_type) {
130    using A = typename TypeParam::allocator_type;
131    A alloc(0);
132    TypeParam m(alloc);
133    EXPECT_EQ(m.get_allocator(), alloc);
134    EXPECT_TRUE(m.empty());
135    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAre());
136  }
137  TYPED_TEST_P(ConstructorTest, Alloc) {
138    AllocTest<TypeParam>(expect_alloc_constructors<TypeParam>());
139  }
140  TYPED_TEST_P(ConstructorTest, InputIteratorBucketHashEqualAlloc) {
141    using T = hash_internal::GeneratedType<TypeParam>;
142    using H = typename TypeParam::hasher;
143    using E = typename TypeParam::key_equal;
144    using A = typename TypeParam::allocator_type;
145    H hasher;
146    E equal;
147    A alloc(0);
148    std::vector<T> values;
149    for (size_t i = 0; i != 10; ++i)
150      values.push_back(hash_internal::Generator<T>()());
151    TypeParam m(values.begin(), values.end(), 123, hasher, equal, alloc);
152    EXPECT_EQ(m.hash_function(), hasher);
153    EXPECT_EQ(m.key_eq(), equal);
154    EXPECT_EQ(m.get_allocator(), alloc);
155    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAreArray(values));
156    EXPECT_GE(m.bucket_count(), 123);
157  }
158  template <typename TypeParam>
159  void InputIteratorBucketAllocTest(std::false_type) {}
160  template <typename TypeParam>
161  void InputIteratorBucketAllocTest(std::true_type) {
162    using T = hash_internal::GeneratedType<TypeParam>;
163    using A = typename TypeParam::allocator_type;
164    A alloc(0);
165    std::vector<T> values;
166    for (size_t i = 0; i != 10; ++i)
167      values.push_back(hash_internal::Generator<T>()());
168    TypeParam m(values.begin(), values.end(), 123, alloc);
169    EXPECT_EQ(m.get_allocator(), alloc);
170    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAreArray(values));
171    EXPECT_GE(m.bucket_count(), 123);
172  }
173  TYPED_TEST_P(ConstructorTest, InputIteratorBucketAlloc) {
174    InputIteratorBucketAllocTest<TypeParam>(expect_cxx14_apis<TypeParam>());
175  }
176  template <typename TypeParam>
177  void InputIteratorBucketHashAllocTest(std::false_type) {}
178  template <typename TypeParam>
179  void InputIteratorBucketHashAllocTest(std::true_type) {
180    using T = hash_internal::GeneratedType<TypeParam>;
181    using H = typename TypeParam::hasher;
182    using A = typename TypeParam::allocator_type;
183    H hasher;
184    A alloc(0);
185    std::vector<T> values;
186    for (size_t i = 0; i != 10; ++i)
187      values.push_back(hash_internal::Generator<T>()());
188    TypeParam m(values.begin(), values.end(), 123, hasher, alloc);
189    EXPECT_EQ(m.hash_function(), hasher);
190    EXPECT_EQ(m.get_allocator(), alloc);
191    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAreArray(values));
192    EXPECT_GE(m.bucket_count(), 123);
193  }
194  TYPED_TEST_P(ConstructorTest, InputIteratorBucketHashAlloc) {
195    InputIteratorBucketHashAllocTest<TypeParam>(expect_cxx14_apis<TypeParam>());
196  }
197  TYPED_TEST_P(ConstructorTest, CopyConstructor) {
198    using T = hash_internal::GeneratedType<TypeParam>;
199    using H = typename TypeParam::hasher;
200    using E = typename TypeParam::key_equal;
201    using A = typename TypeParam::allocator_type;
202    H hasher;
203    E equal;
204    A alloc(0);
205    TypeParam m(123, hasher, equal, alloc);
206    for (size_t i = 0; i != 10; ++i) m.insert(hash_internal::Generator<T>()());
207    TypeParam n(m);
208    EXPECT_EQ(m.hash_function(), n.hash_function());
209    EXPECT_EQ(m.key_eq(), n.key_eq());
210    EXPECT_EQ(m.get_allocator(), n.get_allocator());
211    EXPECT_EQ(m, n);
212    EXPECT_NE(TypeParam(0, hasher, equal, alloc), n);
213  }
214  template <typename TypeParam>
215  void CopyConstructorAllocTest(std::false_type) {}
216  template <typename TypeParam>
217  void CopyConstructorAllocTest(std::true_type) {
218    using T = hash_internal::GeneratedType<TypeParam>;
219    using H = typename TypeParam::hasher;
220    using E = typename TypeParam::key_equal;
221    using A = typename TypeParam::allocator_type;
222    H hasher;
223    E equal;
224    A alloc(0);
225    TypeParam m(123, hasher, equal, alloc);
226    for (size_t i = 0; i != 10; ++i) m.insert(hash_internal::Generator<T>()());
227    TypeParam n(m, A(11));
228    EXPECT_EQ(m.hash_function(), n.hash_function());
229    EXPECT_EQ(m.key_eq(), n.key_eq());
230    EXPECT_NE(m.get_allocator(), n.get_allocator());
231    EXPECT_EQ(m, n);
232  }
233  TYPED_TEST_P(ConstructorTest, CopyConstructorAlloc) {
234    CopyConstructorAllocTest<TypeParam>(expect_alloc_constructors<TypeParam>());
235  }
236  TYPED_TEST_P(ConstructorTest, MoveConstructor) {
237    using T = hash_internal::GeneratedType<TypeParam>;
238    using H = typename TypeParam::hasher;
239    using E = typename TypeParam::key_equal;
240    using A = typename TypeParam::allocator_type;
241    H hasher;
242    E equal;
243    A alloc(0);
244    TypeParam m(123, hasher, equal, alloc);
245    for (size_t i = 0; i != 10; ++i) m.insert(hash_internal::Generator<T>()());
246    TypeParam t(m);
247    TypeParam n(std::move(t));
248    EXPECT_EQ(m.hash_function(), n.hash_function());
249    EXPECT_EQ(m.key_eq(), n.key_eq());
250    EXPECT_EQ(m.get_allocator(), n.get_allocator());
251    EXPECT_EQ(m, n);
252  }
253  template <typename TypeParam>
254  void MoveConstructorAllocTest(std::false_type) {}
255  template <typename TypeParam>
256  void MoveConstructorAllocTest(std::true_type) {
257    using T = hash_internal::GeneratedType<TypeParam>;
258    using H = typename TypeParam::hasher;
259    using E = typename TypeParam::key_equal;
260    using A = typename TypeParam::allocator_type;
261    H hasher;
262    E equal;
263    A alloc(0);
264    TypeParam m(123, hasher, equal, alloc);
265    for (size_t i = 0; i != 10; ++i) m.insert(hash_internal::Generator<T>()());
266    TypeParam t(m);
267    TypeParam n(std::move(t), A(1));
268    EXPECT_EQ(m.hash_function(), n.hash_function());
269    EXPECT_EQ(m.key_eq(), n.key_eq());
270    EXPECT_NE(m.get_allocator(), n.get_allocator());
271    EXPECT_EQ(m, n);
272  }
273  TYPED_TEST_P(ConstructorTest, MoveConstructorAlloc) {
274    MoveConstructorAllocTest<TypeParam>(expect_alloc_constructors<TypeParam>());
275  }
276  TYPED_TEST_P(ConstructorTest, InitializerListBucketHashEqualAlloc) {
277    using T = hash_internal::GeneratedType<TypeParam>;
278    hash_internal::Generator<T> gen;
279    std::initializer_list<T> values = {gen(), gen(), gen(), gen(), gen()};
280    using H = typename TypeParam::hasher;
281    using E = typename TypeParam::key_equal;
282    using A = typename TypeParam::allocator_type;
283    H hasher;
284    E equal;
285    A alloc(0);
286    TypeParam m(values, 123, hasher, equal, alloc);
287    EXPECT_EQ(m.hash_function(), hasher);
288    EXPECT_EQ(m.key_eq(), equal);
289    EXPECT_EQ(m.get_allocator(), alloc);
290    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAreArray(values));
291    EXPECT_GE(m.bucket_count(), 123);
292  }
293  template <typename TypeParam>
294  void InitializerListBucketAllocTest(std::false_type) {}
295  template <typename TypeParam>
296  void InitializerListBucketAllocTest(std::true_type) {
297    using T = hash_internal::GeneratedType<TypeParam>;
298    using A = typename TypeParam::allocator_type;
299    hash_internal::Generator<T> gen;
300    std::initializer_list<T> values = {gen(), gen(), gen(), gen(), gen()};
301    A alloc(0);
302    TypeParam m(values, 123, alloc);
303    EXPECT_EQ(m.get_allocator(), alloc);
304    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAreArray(values));
305    EXPECT_GE(m.bucket_count(), 123);
306  }
307  TYPED_TEST_P(ConstructorTest, InitializerListBucketAlloc) {
308    InitializerListBucketAllocTest<TypeParam>(expect_cxx14_apis<TypeParam>());
309  }
310  template <typename TypeParam>
311  void InitializerListBucketHashAllocTest(std::false_type) {}
312  template <typename TypeParam>
313  void InitializerListBucketHashAllocTest(std::true_type) {
314    using T = hash_internal::GeneratedType<TypeParam>;
315    using H = typename TypeParam::hasher;
316    using A = typename TypeParam::allocator_type;
317    H hasher;
318    A alloc(0);
319    hash_internal::Generator<T> gen;
320    std::initializer_list<T> values = {gen(), gen(), gen(), gen(), gen()};
<span onclick='openModal()' class='match'>321    TypeParam m(values, 123, hasher, alloc);
322    EXPECT_EQ(m.hash_function(), hasher);
323    EXPECT_EQ(m.get_allocator(), alloc);
324    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAreArray(values));
325    EXPECT_GE(m.bucket_count(), 123);
326  }
327  TYPED_TEST_P(ConstructorTest, InitializerListBucketHashAlloc) {
328    InitializerListBucketHashAllocTest<TypeParam>(expect_cxx14_apis<TypeParam>());
329  }
330  TYPED_TEST_P(ConstructorTest, CopyAssignment) {
331    using T = hash_internal::GeneratedType<TypeParam>;
332    using H = typename TypeParam::hasher;
333    using E = typename TypeParam::key_equal;
334    using A = typename TypeParam::allocator_type;
335    H hasher;
336    E equal;
337    A alloc(0);
338    hash_internal::Generator<T> gen;
339    TypeParam m({gen(), gen(), gen()}, 123, hasher, equal, alloc);
340    TypeParam n;
341    n = m;
342    EXPECT_EQ(m.hash_function(), n.hash_function());
343    EXPECT_EQ(m.key_eq(), n.key_eq());
344    EXPECT_EQ(m, n);
345  }
346  TYPED_TEST_P(ConstructorTest, MoveAssignment) {
347    using T = hash_internal::GeneratedType<TypeParam>;
348    using H = typename TypeParam::hasher;
349    using E = typename TypeParam::key_equal;
350    using A = typename TypeParam::allocator_type;
351    H hasher;
352    E equal;
353    A alloc(0);
354    hash_internal::Generator<T> gen;
355    TypeParam m({gen(), gen(), gen()}, 123, hasher, equal, alloc);
356    TypeParam t(m);
357    TypeParam n;
358    n = std::move(t);
359    EXPECT_EQ(m.hash_function(), n.hash_function());
360    EXPECT_EQ(m.key_eq(), n.key_eq());
361    EXPECT_EQ(m, n);
362  }
363  TYPED_TEST_P(ConstructorTest, AssignmentFromInitializerList) {
364    using T = hash_internal::GeneratedType<TypeParam>;
365    hash_internal::Generator<T> gen;
366    std::initializer_list<T> values = {gen(), gen(), gen(), gen(), gen()};
367    TypeParam m;
368    m = values;
369    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAreArray(values));
370  }
371  TYPED_TEST_P(ConstructorTest, AssignmentOverwritesExisting) {
372    using T = hash_internal::GeneratedType<TypeParam>;
373    hash_internal::Generator<T> gen;
374    TypeParam m({gen(), gen(), gen()});
375    TypeParam n({gen()});
376    n = m;
377    EXPECT_EQ(m, n);
378  }
379  TYPED_TEST_P(ConstructorTest, MoveAssignmentOverwritesExisting) {
380    using T = hash_internal::GeneratedType<TypeParam>;
381    hash_internal::Generator<T> gen;
382    TypeParam m({gen(), gen(), gen()});
383    TypeParam t(m);
384    TypeParam n({gen()});
385    n = std::move(t);
386    EXPECT_EQ(m, n);
387  }
388  TYPED_TEST_P(ConstructorTest, AssignmentFromInitializerListOverwritesExisting) {
389    using T = hash_internal::GeneratedType<TypeParam>;
390    hash_internal::Generator<T> gen;
391    std::initializer_list<T> values = {gen(), gen(), gen(), gen(), gen()};
392    TypeParam m;
393    m = values;
394    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAreArray(values));
395  }
396  TYPED_TEST_P(ConstructorTest, AssignmentOnSelf) {
397    using T = hash_internal::GeneratedType<TypeParam>;
398    hash_internal::Generator<T> gen;
399    std::initializer_list<T> values = {gen(), gen(), gen(), gen(), gen()};
400    TypeParam m(values);
401    m = *&m;  
402    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAreArray(values));
403  }
404  REGISTER_TYPED_TEST_SUITE_P(
405      ConstructorTest, NoArgs, BucketCount, BucketCountHash, BucketCountHashEqual,
406      BucketCountHashEqualAlloc, BucketCountAlloc, BucketCountHashAlloc, Alloc,
407      InputIteratorBucketHashEqualAlloc, InputIteratorBucketAlloc,
408      InputIteratorBucketHashAlloc, CopyConstructor, CopyConstructorAlloc,
409      MoveConstructor, MoveConstructorAlloc, InitializerListBucketHashEqualAlloc,
410      InitializerListBucketAlloc, InitializerListBucketHashAlloc, CopyAssignment,
411      MoveAssignment, AssignmentFromInitializerList, AssignmentOverwritesExisting,
412      MoveAssignmentOverwritesExisting,
413      AssignmentFromInitializerListOverwritesExisting, AssignmentOnSelf);
414  }  
415  ABSL_NAMESPACE_END
416  }  
417  #endif  
</span></code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-unordered_set_constructor_test.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-unordered_set_constructor_test.h</div>
                </div>
                <div class="column column_space"><pre><code>321    TypeParam m(values, 123, hasher, alloc);
322    EXPECT_EQ(m.hash_function(), hasher);
323    EXPECT_EQ(m.get_allocator(), alloc);
324    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAreArray(values));
325    EXPECT_GE(m.bucket_count(), 123);
326  }
327  TYPED_TEST_P(ConstructorTest, InitializerListBucketHashAlloc) {
328    InitializerListBucketHashAllocTest<TypeParam>(expect_cxx14_apis<TypeParam>());
329  }
330  TYPED_TEST_P(ConstructorTest, CopyAssignment) {
331    using T = hash_internal::GeneratedType<TypeParam>;
332    using H = typename TypeParam::hasher;
333    using E = typename TypeParam::key_equal;
334    using A = typename TypeParam::allocator_type;
335    H hasher;
336    E equal;
337    A alloc(0);
338    hash_internal::Generator<T> gen;
339    TypeParam m({gen(), gen(), gen()}, 123, hasher, equal, alloc);
340    TypeParam n;
341    n = m;
342    EXPECT_EQ(m.hash_function(), n.hash_function());
343    EXPECT_EQ(m.key_eq(), n.key_eq());
344    EXPECT_EQ(m, n);
345  }
346  TYPED_TEST_P(ConstructorTest, MoveAssignment) {
347    using T = hash_internal::GeneratedType<TypeParam>;
348    using H = typename TypeParam::hasher;
349    using E = typename TypeParam::key_equal;
350    using A = typename TypeParam::allocator_type;
351    H hasher;
352    E equal;
353    A alloc(0);
354    hash_internal::Generator<T> gen;
355    TypeParam m({gen(), gen(), gen()}, 123, hasher, equal, alloc);
356    TypeParam t(m);
357    TypeParam n;
358    n = std::move(t);
359    EXPECT_EQ(m.hash_function(), n.hash_function());
360    EXPECT_EQ(m.key_eq(), n.key_eq());
361    EXPECT_EQ(m, n);
362  }
363  TYPED_TEST_P(ConstructorTest, AssignmentFromInitializerList) {
364    using T = hash_internal::GeneratedType<TypeParam>;
365    hash_internal::Generator<T> gen;
366    std::initializer_list<T> values = {gen(), gen(), gen(), gen(), gen()};
367    TypeParam m;
368    m = values;
369    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAreArray(values));
370  }
371  TYPED_TEST_P(ConstructorTest, AssignmentOverwritesExisting) {
372    using T = hash_internal::GeneratedType<TypeParam>;
373    hash_internal::Generator<T> gen;
374    TypeParam m({gen(), gen(), gen()});
375    TypeParam n({gen()});
376    n = m;
377    EXPECT_EQ(m, n);
378  }
379  TYPED_TEST_P(ConstructorTest, MoveAssignmentOverwritesExisting) {
380    using T = hash_internal::GeneratedType<TypeParam>;
381    hash_internal::Generator<T> gen;
382    TypeParam m({gen(), gen(), gen()});
383    TypeParam t(m);
384    TypeParam n({gen()});
385    n = std::move(t);
386    EXPECT_EQ(m, n);
387  }
388  TYPED_TEST_P(ConstructorTest, AssignmentFromInitializerListOverwritesExisting) {
389    using T = hash_internal::GeneratedType<TypeParam>;
390    hash_internal::Generator<T> gen;
391    std::initializer_list<T> values = {gen(), gen(), gen(), gen(), gen()};
392    TypeParam m;
393    m = values;
394    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAreArray(values));
395  }
396  TYPED_TEST_P(ConstructorTest, AssignmentOnSelf) {
397    using T = hash_internal::GeneratedType<TypeParam>;
398    hash_internal::Generator<T> gen;
399    std::initializer_list<T> values = {gen(), gen(), gen(), gen(), gen()};
400    TypeParam m(values);
401    m = *&m;  
402    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAreArray(values));
403  }
404  REGISTER_TYPED_TEST_SUITE_P(
405      ConstructorTest, NoArgs, BucketCount, BucketCountHash, BucketCountHashEqual,
406      BucketCountHashEqualAlloc, BucketCountAlloc, BucketCountHashAlloc, Alloc,
407      InputIteratorBucketHashEqualAlloc, InputIteratorBucketAlloc,
408      InputIteratorBucketHashAlloc, CopyConstructor, CopyConstructorAlloc,
409      MoveConstructor, MoveConstructorAlloc, InitializerListBucketHashEqualAlloc,
410      InitializerListBucketAlloc, InitializerListBucketHashAlloc, CopyAssignment,
411      MoveAssignment, AssignmentFromInitializerList, AssignmentOverwritesExisting,
412      MoveAssignmentOverwritesExisting,
413      AssignmentFromInitializerListOverwritesExisting, AssignmentOnSelf);
414  }  
415  ABSL_NAMESPACE_END
416  }  
417  #endif  
</pre></code></div>
                <div class="column column_space"><pre><code>321    TypeParam m(values, 123, hasher, alloc);
322    EXPECT_EQ(m.hash_function(), hasher);
323    EXPECT_EQ(m.get_allocator(), alloc);
324    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAreArray(values));
325    EXPECT_GE(m.bucket_count(), 123);
326  }
327  TYPED_TEST_P(ConstructorTest, InitializerListBucketHashAlloc) {
328    InitializerListBucketHashAllocTest<TypeParam>(expect_cxx14_apis<TypeParam>());
329  }
330  TYPED_TEST_P(ConstructorTest, CopyAssignment) {
331    using T = hash_internal::GeneratedType<TypeParam>;
332    using H = typename TypeParam::hasher;
333    using E = typename TypeParam::key_equal;
334    using A = typename TypeParam::allocator_type;
335    H hasher;
336    E equal;
337    A alloc(0);
338    hash_internal::Generator<T> gen;
339    TypeParam m({gen(), gen(), gen()}, 123, hasher, equal, alloc);
340    TypeParam n;
341    n = m;
342    EXPECT_EQ(m.hash_function(), n.hash_function());
343    EXPECT_EQ(m.key_eq(), n.key_eq());
344    EXPECT_EQ(m, n);
345  }
346  TYPED_TEST_P(ConstructorTest, MoveAssignment) {
347    using T = hash_internal::GeneratedType<TypeParam>;
348    using H = typename TypeParam::hasher;
349    using E = typename TypeParam::key_equal;
350    using A = typename TypeParam::allocator_type;
351    H hasher;
352    E equal;
353    A alloc(0);
354    hash_internal::Generator<T> gen;
355    TypeParam m({gen(), gen(), gen()}, 123, hasher, equal, alloc);
356    TypeParam t(m);
357    TypeParam n;
358    n = std::move(t);
359    EXPECT_EQ(m.hash_function(), n.hash_function());
360    EXPECT_EQ(m.key_eq(), n.key_eq());
361    EXPECT_EQ(m, n);
362  }
363  TYPED_TEST_P(ConstructorTest, AssignmentFromInitializerList) {
364    using T = hash_internal::GeneratedType<TypeParam>;
365    hash_internal::Generator<T> gen;
366    std::initializer_list<T> values = {gen(), gen(), gen(), gen(), gen()};
367    TypeParam m;
368    m = values;
369    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAreArray(values));
370  }
371  TYPED_TEST_P(ConstructorTest, AssignmentOverwritesExisting) {
372    using T = hash_internal::GeneratedType<TypeParam>;
373    hash_internal::Generator<T> gen;
374    TypeParam m({gen(), gen(), gen()});
375    TypeParam n({gen()});
376    n = m;
377    EXPECT_EQ(m, n);
378  }
379  TYPED_TEST_P(ConstructorTest, MoveAssignmentOverwritesExisting) {
380    using T = hash_internal::GeneratedType<TypeParam>;
381    hash_internal::Generator<T> gen;
382    TypeParam m({gen(), gen(), gen()});
383    TypeParam t(m);
384    TypeParam n({gen()});
385    n = std::move(t);
386    EXPECT_EQ(m, n);
387  }
388  TYPED_TEST_P(ConstructorTest, AssignmentFromInitializerListOverwritesExisting) {
389    using T = hash_internal::GeneratedType<TypeParam>;
390    hash_internal::Generator<T> gen;
391    std::initializer_list<T> values = {gen(), gen(), gen(), gen(), gen()};
392    TypeParam m;
393    m = values;
394    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAreArray(values));
395  }
396  TYPED_TEST_P(ConstructorTest, AssignmentOnSelf) {
397    using T = hash_internal::GeneratedType<TypeParam>;
398    hash_internal::Generator<T> gen;
399    std::initializer_list<T> values = {gen(), gen(), gen(), gen(), gen()};
400    TypeParam m(values);
401    m = *&m;  
402    EXPECT_THAT(keys(m), ::testing::UnorderedElementsAreArray(values));
403  }
404  REGISTER_TYPED_TEST_SUITE_P(
405      ConstructorTest, NoArgs, BucketCount, BucketCountHash, BucketCountHashEqual,
406      BucketCountHashEqualAlloc, BucketCountAlloc, BucketCountHashAlloc, Alloc,
407      InputIteratorBucketHashEqualAlloc, InputIteratorBucketAlloc,
408      InputIteratorBucketHashAlloc, CopyConstructor, CopyConstructorAlloc,
409      MoveConstructor, MoveConstructorAlloc, InitializerListBucketHashEqualAlloc,
410      InitializerListBucketAlloc, InitializerListBucketHashAlloc, CopyAssignment,
411      MoveAssignment, AssignmentFromInitializerList, AssignmentOverwritesExisting,
412      MoveAssignmentOverwritesExisting,
413      AssignmentFromInitializerListOverwritesExisting, AssignmentOnSelf);
414  }  
415  ABSL_NAMESPACE_END
416  }  
417  #endif  
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    