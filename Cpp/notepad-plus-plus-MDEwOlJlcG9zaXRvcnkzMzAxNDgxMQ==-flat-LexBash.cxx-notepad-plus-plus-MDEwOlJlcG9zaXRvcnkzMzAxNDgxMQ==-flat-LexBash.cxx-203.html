
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 22, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexBash.cxx</h3>
            <pre><code>1  #include &lt;cstdlib&gt;
2  #include &lt;cassert&gt;
3  #include &lt;cstring&gt;
4  #include &lt;cstdio&gt;
5  #include &lt;cstdarg&gt;
6  #include &lt;string&gt;
7  #include &lt;string_view&gt;
8  #include &lt;vector&gt;
9  #include &lt;map&gt;
10  #include &lt;functional&gt;
11  #include &quot;ILexer.h&quot;
12  #include &quot;Scintilla.h&quot;
13  #include &quot;SciLexer.h&quot;
14  #include &quot;StringCopy.h&quot;
15  #include &quot;WordList.h&quot;
16  #include &quot;LexAccessor.h&quot;
17  #include &quot;StyleContext.h&quot;
18  #include &quot;CharacterSet.h&quot;
19  #include &quot;LexerModule.h&quot;
20  #include &quot;OptionSet.h&quot;
21  #include &quot;SubStyles.h&quot;
22  #include &quot;DefaultLexer.h&quot;
23  using namespace Scintilla;
24  using namespace Lexilla;
25  namespace {
26  #define HERE_DELIM_MAX			256
27  #undef PEDANTIC_OCTAL
28  #define BASH_BASE_ERROR			65
29  #define BASH_BASE_DECIMAL		66
30  #define BASH_BASE_HEX			67
31  #ifdef PEDANTIC_OCTAL
32  #define BASH_BASE_OCTAL			68
33  #define	BASH_BASE_OCTAL_ERROR	69
34  #endif
35  enum class CmdState {
36  	Body,
37  	Start,
38  	Word,
39  	Test,
40  	Arithmetic,
41  	Delimiter,
42  };
<span onclick='openModal()' class='match'>43  enum class TestExprType {
44  	Test,			
45  	DoubleBracket,	
46  	SingleBracket,	
47  };
48  enum class CommandSubstitution {
49  	Backtick,
50  	Inside,
51  	InsideTrack,
52  };
</span>53  enum class QuoteStyle {
54  	Literal,		
55  	CString,		
56  	String,			
57  	LString,		
58  	HereDoc,		
59  	Backtick,		
60  	Parameter,		
61  	Command,		
62  	CommandInside,	
63  	Arithmetic,		
64  };
65  #define BASH_QUOTE_STACK_MAX	7
66  constexpr int commandSubstitutionFlag = 0x40;
67  constexpr int MaskCommand(int state) noexcept {
68  	return state &amp; ~commandSubstitutionFlag;
69  }
70  constexpr int translateBashDigit(int ch) noexcept {
71  	if (ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;) {
72  		return ch - &#x27;0&#x27;;
73  	} else if (ch &gt;= &#x27;a&#x27; &amp;&amp; ch &lt;= &#x27;z&#x27;) {
74  		return ch - &#x27;a&#x27; + 10;
75  	} else if (ch &gt;= &#x27;A&#x27; &amp;&amp; ch &lt;= &#x27;Z&#x27;) {
76  		return ch - &#x27;A&#x27; + 36;
77  	} else if (ch == &#x27;@&#x27;) {
78  		return 62;
79  	} else if (ch == &#x27;_&#x27;) {
80  		return 63;
81  	}
82  	return BASH_BASE_ERROR;
83  }
84  int getBashNumberBase(char *s) noexcept {
85  	int i = 0;
86  	int base = 0;
87  	while (*s) {
88  		base = base * 10 + (*s++ - &#x27;0&#x27;);
89  		i++;
90  	}
91  	if (base &gt; 64 || i &gt; 2) {
92  		return BASH_BASE_ERROR;
93  	}
94  	return base;
95  }
96  constexpr int opposite(int ch) noexcept {
97  	if (ch == &#x27;(&#x27;) return &#x27;)&#x27;;
98  	if (ch == &#x27;[&#x27;) return &#x27;]&#x27;;
99  	if (ch == &#x27;{&#x27;) return &#x27;}&#x27;;
100  	if (ch == &#x27;&lt;&#x27;) return &#x27;&gt;&#x27;;
101  	return ch;
102  }
103  int GlobScan(StyleContext &amp;sc) {
104  	int c = 0;
105  	int sLen = 0;
106  	int pCount = 0;
107  	int hash = 0;
108  	while ((c = sc.GetRelativeCharacter(++sLen)) != 0) {
109  		if (IsASpace(c)) {
110  			return 0;
111  		} else if (c == &#x27;\&#x27;&#x27; || c == &#x27;\&quot;&#x27;) {
112  			if (hash != 2) return 0;
113  		} else if (c == &#x27;#&#x27; &amp;&amp; hash == 0) {
114  			hash = (sLen == 1) ? 2:1;
115  		} else if (c == &#x27;(&#x27;) {
116  			pCount++;
117  		} else if (c == &#x27;)&#x27;) {
118  			if (pCount == 0) {
119  				if (hash) return sLen;
120  				return 0;
121  			}
122  			pCount--;
123  		}
124  	}
125  	return 0;
126  }
127  bool IsCommentLine(Sci_Position line, LexAccessor &amp;styler) {
128  	const Sci_Position pos = styler.LineStart(line);
129  	const Sci_Position eol_pos = styler.LineStart(line + 1) - 1;
130  	for (Sci_Position i = pos; i &lt; eol_pos; i++) {
131  		const char ch = styler[i];
132  		if (ch == &#x27;#&#x27;)
133  			return true;
134  		else if (ch != &#x27; &#x27; &amp;&amp; ch != &#x27;\t&#x27;)
135  			return false;
136  	}
137  	return false;
138  }
139  struct OptionsBash {
140  	bool fold = false;
141  	bool foldComment = false;
142  	bool foldCompact = true;
143  	bool stylingInsideString = false;
144  	bool stylingInsideBackticks = false;
145  	bool stylingInsideParameter = false;
146  	bool stylingInsideHeredoc = false;
147  	int commandSubstitution = static_cast&lt;int&gt;(CommandSubstitution::Backtick);
148  	[[nodiscard]] bool stylingInside(int state) const noexcept {
149  		switch (state) {
150  		case SCE_SH_STRING:
151  			return stylingInsideString;
152  		case SCE_SH_BACKTICKS:
153  			return stylingInsideBackticks;
154  		case SCE_SH_PARAM:
155  			return stylingInsideParameter;
156  		case SCE_SH_HERE_Q:
157  			return stylingInsideHeredoc;
158  		default:
159  			return false;
160  		}
161  	}
162  };
163  const char * const bashWordListDesc[] = {
164  	&quot;Keywords&quot;,
165  	nullptr
166  };
167  struct OptionSetBash : public OptionSet&lt;OptionsBash&gt; {
168  	OptionSetBash() {
169  		DefineProperty(&quot;fold&quot;, &amp;OptionsBash::fold);
170  		DefineProperty(&quot;fold.comment&quot;, &amp;OptionsBash::foldComment);
171  		DefineProperty(&quot;fold.compact&quot;, &amp;OptionsBash::foldCompact);
172  		DefineProperty(&quot;lexer.bash.styling.inside.string&quot;, &amp;OptionsBash::stylingInsideString,
173  			&quot;Set this property to 1 to highlight shell expansions inside string.&quot;);
174  		DefineProperty(&quot;lexer.bash.styling.inside.backticks&quot;, &amp;OptionsBash::stylingInsideBackticks,
175  			&quot;Set this property to 1 to highlight shell expansions inside backticks.&quot;);
176  		DefineProperty(&quot;lexer.bash.styling.inside.parameter&quot;, &amp;OptionsBash::stylingInsideParameter,
177  			&quot;Set this property to 1 to highlight shell expansions inside ${} parameter expansion.&quot;);
178  		DefineProperty(&quot;lexer.bash.styling.inside.heredoc&quot;, &amp;OptionsBash::stylingInsideHeredoc,
179  			&quot;Set this property to 1 to highlight shell expansions inside here document.&quot;);
180  		DefineProperty(&quot;lexer.bash.command.substitution&quot;, &amp;OptionsBash::commandSubstitution,
181  			&quot;Set how to highlight $() command substitution. &quot;
182  			&quot;0 (the default) highlighted as backticks. &quot;
183  			&quot;1 highlighted inside. &quot;
184  			&quot;2 highlighted inside with extra scope tracking.&quot;);
185  		DefineWordListSets(bashWordListDesc);
186  	}
187  };
188  class QuoteCls {	
189  public:
190  	int Count = 0;
191  	int Up = &#x27;\0&#x27;;
192  	int Down = &#x27;\0&#x27;;
193  	QuoteStyle Style = QuoteStyle::Literal;
194  	int Outer = SCE_SH_DEFAULT;
195  	void Clear() noexcept {
196  		Count = 0;
197  		Up	  = &#x27;\0&#x27;;
198  		Down  = &#x27;\0&#x27;;
199  		Style = QuoteStyle::Literal;
200  		Outer = SCE_SH_DEFAULT;
201  	}
202  	void Start(int u, QuoteStyle s, int outer) noexcept {
203  		Count = 1;
204  		Up    = u;
205  		Down  = opposite(Up);
206  		Style = s;
207  		Outer = outer;
208  	}
209  };
210  class QuoteStackCls {	
211  public:
212  	int Depth = 0;
213  	int State = SCE_SH_DEFAULT;
214  	CommandSubstitution commandSubstitution = CommandSubstitution::Backtick;
215  	int insideCommand = 0;
216  	QuoteCls Current;
217  	QuoteCls Stack[BASH_QUOTE_STACK_MAX];
218  	[[nodiscard]] bool Empty() const noexcept {
219  		return Current.Up == &#x27;\0&#x27;;
220  	}
221  	void Start(int u, QuoteStyle s, int outer) noexcept {
222  		if (Empty()) {
223  			Current.Start(u, s, outer);
224  		} else {
225  			Push(u, s, outer);
226  		}
227  	}
228  	void Push(int u, QuoteStyle s, int outer) noexcept {
229  		if (Depth &gt;= BASH_QUOTE_STACK_MAX) {
230  			return;
231  		}
232  		Stack[Depth] = Current;
233  		Depth++;
234  		Current.Start(u, s, outer);
235  	}
236  	void Pop() noexcept {
237  		if (Depth == 0) {
238  			Clear();
239  			return;
240  		}
241  		if (insideCommand != 0) {
242  			insideCommand = 0;
243  			for (int i = 0; i &lt; Depth; i++) {
244  				if (Stack[i].Style == QuoteStyle::CommandInside) {
245  					insideCommand = commandSubstitutionFlag;
246  					break;
247  				}
248  			}
249  		}
250  		Depth--;
251  		Current = Stack[Depth];
252  	}
253  	void Clear() noexcept {
254  		Depth = 0;
255  		State = SCE_SH_DEFAULT;
256  		insideCommand = 0;
257  		Current.Clear();
258  	}
259  	bool CountDown(StyleContext &amp;sc, CmdState &amp;cmdState) {
260  		Current.Count--;
261  		if (Current.Count == 1 &amp;&amp; sc.Match(&#x27;)&#x27;, &#x27;)&#x27;)) {
262  			Current.Count--;
263  			sc.Forward();
264  		}
265  		if (Current.Count == 0) {
266  			cmdState = CmdState::Body;
267  			const int outer = Current.Outer;
268  			Pop();
269  			sc.ForwardSetState(outer | insideCommand);
270  			return true;
271  		}
272  		return false;
273  	}
274  	void Expand(StyleContext &amp;sc, CmdState &amp;cmdState, bool stylingInside) {
275  		const int state = sc.state;
276  		QuoteStyle style = QuoteStyle::Literal;
277  		State = state;
278  		sc.SetState(SCE_SH_SCALAR);
279  		sc.Forward();
280  		if (sc.ch == &#x27;{&#x27;) {
281  			style = QuoteStyle::Parameter;
282  			sc.ChangeState(SCE_SH_PARAM);
283  		} else if (sc.ch == &#x27;\&#x27;&#x27;) {
284  			style = QuoteStyle::CString;
285  			sc.ChangeState(SCE_SH_STRING);
286  		} else if (sc.ch == &#x27;&quot;&#x27;) {
287  			style = QuoteStyle::LString;
288  			sc.ChangeState(SCE_SH_STRING);
289  		} else if (sc.ch == &#x27;(&#x27; || sc.ch == &#x27;[&#x27;) {
290  			if (sc.ch == &#x27;[&#x27; || sc.chNext == &#x27;(&#x27;) {
291  				style = QuoteStyle::Arithmetic;
292  				cmdState = CmdState::Arithmetic;
293  				sc.ChangeState(SCE_SH_OPERATOR);
294  			} else {
295  				if (stylingInside &amp;&amp; commandSubstitution &gt;= CommandSubstitution::Inside) {
296  					style = QuoteStyle::CommandInside;
297  					cmdState = CmdState::Delimiter;
298  					sc.ChangeState(SCE_SH_OPERATOR);
299  					if (commandSubstitution == CommandSubstitution::InsideTrack) {
300  						insideCommand = commandSubstitutionFlag;
301  					}
302  				} else {
303  					style = QuoteStyle::Command;
304  					sc.ChangeState(SCE_SH_BACKTICKS);
305  				}
306  			}
307  			if (sc.Match(&#x27;(&#x27;, &#x27;(&#x27;) &amp;&amp; state == SCE_SH_DEFAULT &amp;&amp; Depth == 0) {
308  				style = QuoteStyle::Literal;
309  			}
310  		} else if (sc.ch == &#x27;`&#x27;) {	
311  			style = QuoteStyle::Backtick;
312  			sc.ChangeState(SCE_SH_BACKTICKS);
313  		} else {
314  		}
315  		if (!stylingInside) {
316  			sc.ChangeState(state);
317  		} else {
318  			sc.ChangeState(sc.state | insideCommand);
319  		}
320  		if (style != QuoteStyle::Literal) {
321  			Start(sc.ch, style, state);
322  			sc.Forward();
323  		}
324  	}
325  };
326  const char styleSubable[] = { SCE_SH_IDENTIFIER, SCE_SH_SCALAR, 0 };
327  const LexicalClass lexicalClasses[] = {
328  	0, &quot;SCE_SH_DEFAULT&quot;, &quot;default&quot;, &quot;White space&quot;,
329  	1, &quot;SCE_SH_ERROR&quot;, &quot;error&quot;, &quot;Error&quot;,
330  	2, &quot;SCE_SH_COMMENTLINE&quot;, &quot;comment line&quot;, &quot;Line comment: #&quot;,
331  	3, &quot;SCE_SH_NUMBER&quot;, &quot;literal numeric&quot;, &quot;Number&quot;,
332  	4, &quot;SCE_SH_WORD&quot;, &quot;keyword&quot;, &quot;Keyword&quot;,
333  	5, &quot;SCE_SH_STRING&quot;, &quot;literal string&quot;, &quot;String&quot;,
334  	6, &quot;SCE_SH_CHARACTER&quot;, &quot;literal string&quot;, &quot;Single quoted string&quot;,
335  	7, &quot;SCE_SH_OPERATOR&quot;, &quot;operator&quot;, &quot;Operators&quot;,
336  	8, &quot;SCE_SH_IDENTIFIER&quot;, &quot;identifier&quot;, &quot;Identifiers&quot;,
337  	9, &quot;SCE_SH_SCALAR&quot;, &quot;identifier&quot;, &quot;Scalar variable&quot;,
338  	10, &quot;SCE_SH_PARAM&quot;, &quot;identifier&quot;, &quot;Parameter&quot;,
339  	11, &quot;SCE_SH_BACKTICKS&quot;, &quot;literal string&quot;, &quot;Backtick quoted command&quot;,
340  	12, &quot;SCE_SH_HERE_DELIM&quot;, &quot;operator&quot;, &quot;Heredoc delimiter&quot;,
341  	13, &quot;SCE_SH_HERE_Q&quot;, &quot;literal string&quot;, &quot;Heredoc quoted string&quot;,
342  };
343  }
344  class LexerBash final : public DefaultLexer {
345  	WordList keywords;
346  	WordList cmdDelimiter;
347  	WordList bashStruct;
348  	WordList bashStruct_in;
349  	OptionsBash options;
350  	OptionSetBash osBash;
351  	enum { ssIdentifier, ssScalar };
352  	SubStyles subStyles;
353  public:
354  	LexerBash() :
355  		DefaultLexer(&quot;bash&quot;, SCLEX_BASH, lexicalClasses, ELEMENTS(lexicalClasses)),
356  		subStyles(styleSubable, 0x80, 0x40, 0) {
357  		cmdDelimiter.Set(&quot;| || |&amp; &amp; &amp;&amp; ; ;; ( ) { }&quot;);
358  		bashStruct.Set(&quot;if elif fi while until else then do done esac eval&quot;);
359  		bashStruct_in.Set(&quot;for case select&quot;);
360  	}
361  	void SCI_METHOD Release() override {
362  		delete this;
363  	}
364  	int SCI_METHOD Version() const override {
365  		return lvRelease5;
366  	}
367  	const char * SCI_METHOD PropertyNames() override {
368  		return osBash.PropertyNames();
369  	}
370  	int SCI_METHOD PropertyType(const char* name) override {
371  		return osBash.PropertyType(name);
372  	}
373  	const char * SCI_METHOD DescribeProperty(const char *name) override {
374  		return osBash.DescribeProperty(name);
375  	}
376  	Sci_Position SCI_METHOD PropertySet(const char *key, const char *val) override;
377  	const char * SCI_METHOD PropertyGet(const char* key) override {
378  		return osBash.PropertyGet(key);
379  	}
380  	const char * SCI_METHOD DescribeWordListSets() override {
381  		return osBash.DescribeWordListSets();
382  	}
383  	Sci_Position SCI_METHOD WordListSet(int n, const char *wl) override;
384  	void SCI_METHOD Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) override;
385  	void SCI_METHOD Fold(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) override;
386  	void * SCI_METHOD PrivateCall(int, void *) override {
387  		return nullptr;
388  	}
389  	int SCI_METHOD AllocateSubStyles(int styleBase, int numberStyles) override {
390  		return subStyles.Allocate(styleBase, numberStyles);
391  	}
392  	int SCI_METHOD SubStylesStart(int styleBase) override {
393  		return subStyles.Start(styleBase);
394  	}
395  	int SCI_METHOD SubStylesLength(int styleBase) override {
396  		return subStyles.Length(styleBase);
397  	}
398  	int SCI_METHOD StyleFromSubStyle(int subStyle) override {
399  		const int styleBase = subStyles.BaseStyle(subStyle);
400  		return styleBase;
401  	}
402  	int SCI_METHOD PrimaryStyleFromStyle(int style) override {
403  		return style;
404  	}
405  	void SCI_METHOD FreeSubStyles() override {
406  		subStyles.Free();
407  	}
408  	void SCI_METHOD SetIdentifiers(int style, const char *identifiers) override {
409  		subStyles.SetIdentifiers(style, identifiers);
410  	}
411  	int SCI_METHOD DistanceToSecondaryStyles() override {
412  		return 0;
413  	}
414  	const char *SCI_METHOD GetSubStyleBases() override {
415  		return styleSubable;
416  	}
417  	static ILexer5 *LexerFactoryBash() {
418  		return new LexerBash();
419  	}
420  };
421  Sci_Position SCI_METHOD LexerBash::PropertySet(const char *key, const char *val) {
422  	if (osBash.PropertySet(&amp;options, key, val)) {
423  		return 0;
424  	}
425  	return -1;
426  }
427  Sci_Position SCI_METHOD LexerBash::WordListSet(int n, const char *wl) {
428  	WordList *wordListN = nullptr;
429  	switch (n) {
430  	case 0:
431  		wordListN = &amp;keywords;
432  		break;
433  	}
434  	Sci_Position firstModification = -1;
435  	if (wordListN) {
436  		if (wordListN-&gt;Set(wl)) {
437  			firstModification = 0;
438  		}
439  	}
440  	return firstModification;
441  }
442  void SCI_METHOD LexerBash::Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) {
443  	const CharacterSet setWordStart(CharacterSet::setAlpha, &quot;_&quot;);
444  	const CharacterSet setWord(CharacterSet::setAlphaNum, &quot;._+-&quot;);
445  	CharacterSet setMetaCharacter(CharacterSet::setNone, &quot;|&amp;;()&lt;&gt; \t\r\n&quot;);
446  	setMetaCharacter.Add(0);
447  	const CharacterSet setBashOperator(CharacterSet::setNone, &quot;^&amp;%()-+=|{}[]:;&gt;,*/&lt;?!.~@&quot;);
448  	const CharacterSet setSingleCharOp(CharacterSet::setNone, &quot;rwxoRWXOezsfdlpSbctugkTBMACahGLNn&quot;);
449  	const CharacterSet setParam(CharacterSet::setAlphaNum, &quot;_&quot;);
450  	const CharacterSet setHereDoc(CharacterSet::setAlpha, &quot;_\\-+!%*,./:?@[]^`{}~&quot;);
451  	const CharacterSet setHereDoc2(CharacterSet::setAlphaNum, &quot;_-+!%*,./:=?@[]^`{}~&quot;);
452  	const CharacterSet setLeftShift(CharacterSet::setDigits, &quot;$&quot;);
453  	class HereDocCls {	
454  	public:
455  		int State = 0;			
456  		int Quote = &#x27;\0&#x27;;		
457  		bool Quoted = false;		
458  		bool Escaped = false;		
459  		bool Indent = false;		
460  		int DelimiterLength = 0;	
461  		char Delimiter[HERE_DELIM_MAX]{};	
462  		HereDocCls() noexcept = default;
463  		void Append(int ch) {
464  			Delimiter[DelimiterLength++] = static_cast&lt;char&gt;(ch);
465  			Delimiter[DelimiterLength] = &#x27;\0&#x27;;
466  		}
467  	};
468  	HereDocCls HereDoc;
469  	QuoteStackCls QuoteStack;
470  	QuoteStack.commandSubstitution = static_cast&lt;CommandSubstitution&gt;(options.commandSubstitution);
471  	const WordClassifier &amp;classifierIdentifiers = subStyles.Classifier(SCE_SH_IDENTIFIER);
472  	const WordClassifier &amp;classifierScalars = subStyles.Classifier(SCE_SH_SCALAR);
473  	int numBase = 0;
474  	int digit = 0;
475  	const Sci_PositionU endPos = startPos + length;
476  	CmdState cmdState = CmdState::Start;
477  	TestExprType testExprType = TestExprType::Test;
478  	LexAccessor styler(pAccess);
479  	Sci_Position ln = styler.GetLine(startPos);
480  	if (ln &gt; 0 &amp;&amp; startPos == static_cast&lt;Sci_PositionU&gt;(styler.LineStart(ln)))
481  		ln--;
482  	for (;;) {
483  		startPos = styler.LineStart(ln);
484  		if (ln == 0 || styler.GetLineState(ln) == static_cast&lt;int&gt;(CmdState::Start))
485  			break;
486  		ln--;
487  	}
488  	initStyle = SCE_SH_DEFAULT;
489  	StyleContext sc(startPos, endPos - startPos, initStyle, styler);
490  	while (sc.More()) {
491  		if (sc.atLineStart) {
492  			if (MaskCommand(sc.state) == SCE_SH_STRING
493  			 || MaskCommand(sc.state) == SCE_SH_BACKTICKS
494  			 || MaskCommand(sc.state) == SCE_SH_CHARACTER
495  			 || MaskCommand(sc.state) == SCE_SH_HERE_Q
496  			 || MaskCommand(sc.state) == SCE_SH_COMMENTLINE
497  			 || MaskCommand(sc.state) == SCE_SH_PARAM) {
498  				styler.SetLineState(sc.currentLine, static_cast&lt;int&gt;(CmdState::Body));
499  			} else {
500  				if (sc.currentLine &gt; 0) {
501  					if ((sc.GetRelative(-3) == &#x27;\\&#x27; &amp;&amp; sc.GetRelative(-2) == &#x27;\r&#x27; &amp;&amp; sc.chPrev == &#x27;\n&#x27;)
502  					 || sc.GetRelative(-2) == &#x27;\\&#x27;) {	
503  					} else
504  						cmdState = CmdState::Start;
505  				}
506  				const CmdState state = QuoteStack.Empty() ? cmdState : CmdState::Body;
507  				styler.SetLineState(sc.currentLine, static_cast&lt;int&gt;(state));
508  			}
509  		}
510  		CmdState cmdStateNew = CmdState::Body;
511  		if (cmdState == CmdState::Test || cmdState == CmdState::Arithmetic || cmdState == CmdState::Word)
512  			cmdStateNew = cmdState;
513  		const int stylePrev = MaskCommand(sc.state);
514  		const int insideCommand = QuoteStack.insideCommand;
515  		switch (MaskCommand(sc.state)) {
516  			case SCE_SH_OPERATOR:
517  				sc.SetState(SCE_SH_DEFAULT | insideCommand);
518  				if (cmdState == CmdState::Delimiter)		
519  					cmdStateNew = CmdState::Start;
520  				else if (sc.chPrev == &#x27;\\&#x27;)			
521  					cmdStateNew = cmdState;
522  				break;
523  			case SCE_SH_WORD:
524  				if (!setWord.Contains(sc.ch)) {
525  					char s[500];
526  					sc.GetCurrent(s, sizeof(s));
527  					int identifierStyle = SCE_SH_IDENTIFIER | insideCommand;
528  					const int subStyle = classifierIdentifiers.ValueFor(s);
529  					if (subStyle &gt;= 0) {
530  						identifierStyle = subStyle | insideCommand;
531  					}
532  					char s2[10];
533  					s2[0] = static_cast&lt;char&gt;(sc.ch);
534  					s2[1] = &#x27;\0&#x27;;
535  					const bool keywordEnds = IsASpace(sc.ch) || cmdDelimiter.InList(s2);
536  					if (cmdState == CmdState::Word) {
537  						if (strcmp(s, &quot;in&quot;) == 0 &amp;&amp; keywordEnds)
538  							cmdStateNew = CmdState::Body;
539  						else if (strcmp(s, &quot;do&quot;) == 0 &amp;&amp; keywordEnds)
540  							cmdStateNew = CmdState::Start;
541  						else
542  							sc.ChangeState(identifierStyle);
543  						sc.SetState(SCE_SH_DEFAULT | insideCommand);
544  						break;
545  					}
546  					if (strcmp(s, &quot;test&quot;) == 0) {
547  						if (cmdState == CmdState::Start &amp;&amp; keywordEnds) {
548  							cmdStateNew = CmdState::Test;
549  							testExprType = TestExprType::Test;
550  						} else
551  							sc.ChangeState(identifierStyle);
552  					}
553  					else if (bashStruct.InList(s)) {
554  						if (cmdState == CmdState::Start &amp;&amp; keywordEnds)
555  							cmdStateNew = CmdState::Start;
556  						else
557  							sc.ChangeState(identifierStyle);
558  					}
559  					else if (bashStruct_in.InList(s)) {
560  						if (cmdState == CmdState::Start &amp;&amp; keywordEnds)
561  							cmdStateNew = CmdState::Word;
562  						else
563  							sc.ChangeState(identifierStyle);
564  					}
565  					else if (s[0] == &#x27;-&#x27;) {
566  						if (cmdState != CmdState::Test)
567  							sc.ChangeState(identifierStyle);
568  					}
569  					else if (cmdState != CmdState::Start
570  						  || !(keywords.InList(s) &amp;&amp; keywordEnds)) {
571  						sc.ChangeState(identifierStyle);
572  					}
573  					sc.SetState(SCE_SH_DEFAULT | insideCommand);
574  				}
575  				break;
576  			case SCE_SH_IDENTIFIER:
577  				if (sc.chPrev == &#x27;\\&#x27; || !setWord.Contains(sc.ch) ||
578  					  (cmdState == CmdState::Arithmetic &amp;&amp; !setWordStart.Contains(sc.ch))) {
579  					char s[500];
580  					sc.GetCurrent(s, sizeof(s));
581  					const int subStyle = classifierIdentifiers.ValueFor(s);
582  					if (subStyle &gt;= 0) {
583  						sc.ChangeState(subStyle | insideCommand);
584  					}
585  					if (sc.chPrev == &#x27;\\&#x27;) {	
586  						sc.Forward();
587  					}
588  					sc.SetState(SCE_SH_DEFAULT | insideCommand);
589  				}
590  				break;
591  			case SCE_SH_NUMBER:
592  				digit = translateBashDigit(sc.ch);
593  				if (numBase == BASH_BASE_DECIMAL) {
594  					if (sc.ch == &#x27;#&#x27;) {
595  						char s[10];
596  						sc.GetCurrent(s, sizeof(s));
597  						numBase = getBashNumberBase(s);
598  						if (numBase != BASH_BASE_ERROR)
599  							break;
600  					} else if (IsADigit(sc.ch))
601  						break;
602  				} else if (numBase == BASH_BASE_HEX) {
603  					if (IsADigit(sc.ch, 16))
604  						break;
605  #ifdef PEDANTIC_OCTAL
606  				} else if (numBase == BASH_BASE_OCTAL ||
607  						   numBase == BASH_BASE_OCTAL_ERROR) {
608  					if (digit &lt;= 7)
609  						break;
610  					if (digit &lt;= 9) {
611  						numBase = BASH_BASE_OCTAL_ERROR;
612  						break;
613  					}
614  #endif
615  				} else if (numBase == BASH_BASE_ERROR) {
616  					if (digit &lt;= 9)
617  						break;
618  				} else {	
619  					if (digit != BASH_BASE_ERROR) {
620  						if (numBase &lt;= 36) {
621  							if (digit &gt;= 36) digit -= 26;
622  						}
623  						if (digit &lt; numBase)
624  							break;
625  						if (digit &lt;= 9) {
626  							numBase = BASH_BASE_ERROR;
627  							break;
628  						}
629  					}
630  				}
631  				if (numBase == BASH_BASE_ERROR
632  #ifdef PEDANTIC_OCTAL
633  					|| numBase == BASH_BASE_OCTAL_ERROR
634  #endif
635  				) {
636  					sc.ChangeState(SCE_SH_ERROR | insideCommand);
637  				}
638  				sc.SetState(SCE_SH_DEFAULT | insideCommand);
639  				break;
640  			case SCE_SH_COMMENTLINE:
641  				if (sc.MatchLineEnd() &amp;&amp; sc.chPrev != &#x27;\\&#x27;) {
642  					sc.SetState(SCE_SH_DEFAULT | insideCommand);
643  				}
644  				break;
645  			case SCE_SH_HERE_DELIM:
646  				if (HereDoc.State == 0) { 
647  					HereDoc.Quote = sc.chNext;
648  					HereDoc.Quoted = false;
649  					HereDoc.Escaped = false;
650  					HereDoc.DelimiterLength = 0;
651  					HereDoc.Delimiter[HereDoc.DelimiterLength] = &#x27;\0&#x27;;
652  					if (sc.chNext == &#x27;\&#x27;&#x27; || sc.chNext == &#x27;\&quot;&#x27;) {	
653  						sc.Forward();
654  						HereDoc.Quoted = true;
655  						HereDoc.State = 1;
656  					} else if (setHereDoc.Contains(sc.chNext) ||
657  					           (sc.chNext == &#x27;=&#x27; &amp;&amp; cmdState != CmdState::Arithmetic)) {
658  						HereDoc.State = 1;
659  					} else if (sc.chNext == &#x27;&lt;&#x27;) {	
660  						sc.Forward();
661  						sc.ForwardSetState(SCE_SH_DEFAULT | insideCommand);
662  					} else if (IsASpace(sc.chNext)) {
663  					} else if (setLeftShift.Contains(sc.chNext) ||
664  					           (sc.chNext == &#x27;=&#x27; &amp;&amp; cmdState == CmdState::Arithmetic)) {
665  						sc.ChangeState(SCE_SH_OPERATOR | insideCommand);
666  						sc.ForwardSetState(SCE_SH_DEFAULT | insideCommand);
667  					} else {
668  						HereDoc.State = 1;
669  					}
670  				} else if (HereDoc.State == 1) { 
671  					if ((HereDoc.Quote == &#x27;\&#x27;&#x27; &amp;&amp; sc.ch != HereDoc.Quote) ||
672  					    (HereDoc.Quoted &amp;&amp; sc.ch != HereDoc.Quote &amp;&amp; sc.ch != &#x27;\\&#x27;) ||
673  					    (HereDoc.Quote != &#x27;\&#x27;&#x27; &amp;&amp; sc.chPrev == &#x27;\\&#x27;) ||
674  					    (setHereDoc2.Contains(sc.ch))) {
675  						HereDoc.Append(sc.ch);
676  					} else if (HereDoc.Quoted &amp;&amp; sc.ch == HereDoc.Quote) {	
677  						sc.ForwardSetState(SCE_SH_DEFAULT);
678  					} else if (sc.ch == &#x27;\\&#x27;) {
679  						HereDoc.Escaped = true;
680  						if (HereDoc.Quoted &amp;&amp; sc.chNext != HereDoc.Quote &amp;&amp; sc.chNext != &#x27;\\&#x27;) {
681  							HereDoc.Append(sc.ch);
682  						} else {
683  						}
684  					} else if (!HereDoc.Quoted) {
685  						sc.SetState(SCE_SH_DEFAULT | insideCommand);
686  					}
687  					if (HereDoc.DelimiterLength &gt;= HERE_DELIM_MAX - 1) {	
688  						sc.SetState(SCE_SH_ERROR | insideCommand);
689  						HereDoc.State = 0;
690  					}
691  				}
692  				break;
693  			case SCE_SH_SCALAR:	
694  				if (!setParam.Contains(sc.ch)) {
695  					char s[500];
696  					sc.GetCurrent(s, sizeof(s));
697  					const int subStyle = classifierScalars.ValueFor(&amp;s[1]); 
698  					if (subStyle &gt;= 0) {
699  						sc.ChangeState(subStyle | insideCommand);
700  					}
701  					if (sc.LengthCurrent() == 1) {
702  						sc.Forward();
703  					}
704  					sc.SetState(QuoteStack.State | insideCommand);
705  					continue;
706  				}
707  				break;
708  			case SCE_SH_HERE_Q:
709  				if (sc.atLineStart &amp;&amp; QuoteStack.Current.Style == QuoteStyle::HereDoc) {
710  					sc.SetState(SCE_SH_HERE_Q | insideCommand);
711  					if (HereDoc.Indent) { 
712  						while (sc.ch == &#x27;\t&#x27;) {
713  							sc.Forward();
714  						}
715  					}
716  					if ((static_cast&lt;Sci_Position&gt;(sc.currentPos + HereDoc.DelimiterLength) == sc.lineEnd) &amp;&amp;
717  						(HereDoc.DelimiterLength == 0 || sc.Match(HereDoc.Delimiter))) {
718  						while (!sc.MatchLineEnd()) {
719  							sc.Forward();
720  						}
721  						QuoteStack.Pop();
722  						sc.SetState(SCE_SH_DEFAULT | QuoteStack.insideCommand);
723  						break;
724  					}
725  				}
726  				if (HereDoc.Quoted || HereDoc.Escaped) {
727  					break;
728  				}
729  				[[fallthrough]];
730  			case SCE_SH_STRING:	
731  			case SCE_SH_PARAM: 
732  			case SCE_SH_BACKTICKS:
733  				if (sc.ch == &#x27;\\&#x27;) {
734  					if (QuoteStack.Current.Style != QuoteStyle::Literal)
735  						sc.Forward();
736  				} else if (sc.ch == QuoteStack.Current.Down) {
737  					if (QuoteStack.CountDown(sc, cmdState)) {
738  						continue;
739  					}
740  				} else if (sc.ch == QuoteStack.Current.Up) {
741  					QuoteStack.Current.Count++;
742  				} else {
743  					if (QuoteStack.Current.Style == QuoteStyle::String ||
744  						QuoteStack.Current.Style == QuoteStyle::HereDoc ||
745  						QuoteStack.Current.Style == QuoteStyle::LString
746  					) {	
747  						const bool stylingInside = options.stylingInside(MaskCommand(sc.state));
748  						if (sc.ch == &#x27;`&#x27;) {
749  							QuoteStack.Push(sc.ch, QuoteStyle::Backtick, sc.state);
750  							if (stylingInside) {
751  								sc.SetState(SCE_SH_BACKTICKS | insideCommand);
752  							}
753  						} else if (sc.ch == &#x27;$&#x27;) {
754  							QuoteStack.Expand(sc, cmdState, stylingInside);
755  							continue;
756  						}
757  					} else if (QuoteStack.Current.Style == QuoteStyle::Command ||
758  							   QuoteStack.Current.Style == QuoteStyle::Parameter ||
759  							   QuoteStack.Current.Style == QuoteStyle::Backtick
760  					) {	
761  						const bool stylingInside = options.stylingInside(MaskCommand(sc.state));
762  						if (sc.ch == &#x27;\&#x27;&#x27;) {
763  							if (stylingInside) {
764  								QuoteStack.State = sc.state;
765  								sc.SetState(SCE_SH_CHARACTER | insideCommand);
766  							} else {
767  								QuoteStack.Push(sc.ch, QuoteStyle::Literal, sc.state);
768  							}
769  						} else if (sc.ch == &#x27;\&quot;&#x27;) {
770  							QuoteStack.Push(sc.ch, QuoteStyle::String, sc.state);
771  							if (stylingInside) {
772  								sc.SetState(SCE_SH_STRING | insideCommand);
773  							}
774  						} else if (sc.ch == &#x27;`&#x27;) {
775  							QuoteStack.Push(sc.ch, QuoteStyle::Backtick, sc.state);
776  							if (stylingInside) {
777  								sc.SetState(SCE_SH_BACKTICKS | insideCommand);
778  							}
779  						} else if (sc.ch == &#x27;$&#x27;) {
780  							QuoteStack.Expand(sc, cmdState, stylingInside);
781  							continue;
782  						}
783  					}
784  				}
785  				break;
786  			case SCE_SH_CHARACTER: 
787  				if (sc.ch == &#x27;\&#x27;&#x27;) {
788  					sc.ForwardSetState(QuoteStack.State | insideCommand);
789  					continue;
790  				}
791  				break;
792  		}
793  		if (HereDoc.State == 1 &amp;&amp; sc.MatchLineEnd()) {
794  			HereDoc.State = 2;
795  			if (HereDoc.Quoted) {
796  				if (MaskCommand(sc.state) == SCE_SH_HERE_DELIM) {
797  					sc.ChangeState(SCE_SH_ERROR | insideCommand);
798  					sc.SetState(SCE_SH_DEFAULT | insideCommand);
799  				} else {
800  					sc.SetState(SCE_SH_HERE_Q | insideCommand);
801  					QuoteStack.Start(-1, QuoteStyle::HereDoc, SCE_SH_DEFAULT);
802  				}
803  			} else if (HereDoc.DelimiterLength == 0) {
804  				sc.ChangeState(SCE_SH_ERROR | insideCommand);
805  				sc.SetState(SCE_SH_DEFAULT | insideCommand);
806  			} else {
807  				sc.SetState(SCE_SH_HERE_Q | insideCommand);
808  				QuoteStack.Start(-1, QuoteStyle::HereDoc, SCE_SH_DEFAULT);
809  			}
810  		}
811  		if (stylePrev != SCE_SH_DEFAULT &amp;&amp; MaskCommand(sc.state) == SCE_SH_DEFAULT) {
812  			cmdState = cmdStateNew;
813  		}
814  		if (MaskCommand(sc.state) == SCE_SH_DEFAULT) {
815  			if (sc.ch == &#x27;\\&#x27;) {
816  				sc.SetState(SCE_SH_IDENTIFIER | insideCommand);
817  				if (sc.chNext == &#x27;\r&#x27; || sc.chNext == &#x27;\n&#x27;)
818  					sc.SetState(SCE_SH_OPERATOR | insideCommand);
819  			} else if (IsADigit(sc.ch)) {
820  				sc.SetState(SCE_SH_NUMBER | insideCommand);
821  				numBase = BASH_BASE_DECIMAL;
822  				if (sc.ch == &#x27;0&#x27;) {	
823  					if (sc.chNext == &#x27;x&#x27; || sc.chNext == &#x27;X&#x27;) {
824  						numBase = BASH_BASE_HEX;
825  						sc.Forward();
826  					} else if (IsADigit(sc.chNext)) {
827  #ifdef PEDANTIC_OCTAL
828  						numBase = BASH_BASE_OCTAL;
829  #else
830  						numBase = BASH_BASE_HEX;
831  #endif
832  					}
833  				}
834  			} else if (setWordStart.Contains(sc.ch)) {
835  				sc.SetState(SCE_SH_WORD | insideCommand);
836  			} else if (sc.ch == &#x27;#&#x27;) {
837  				if (stylePrev != SCE_SH_WORD &amp;&amp; stylePrev != SCE_SH_IDENTIFIER &amp;&amp;
838  					(sc.currentPos == 0 || setMetaCharacter.Contains(sc.chPrev))) {
839  					sc.SetState(SCE_SH_COMMENTLINE | insideCommand);
840  				} else {
841  					sc.SetState(SCE_SH_WORD | insideCommand);
842  				}
843  				if (cmdState == CmdState::Arithmetic) {
844  					if (sc.chPrev == &#x27;[&#x27;) {	
845  						sc.SetState(SCE_SH_WORD | insideCommand);
846  						if (sc.chNext == &#x27;#&#x27;) {
847  							sc.Forward();
848  						}
849  					} else if (sc.Match(&quot;##^&quot;) &amp;&amp; IsUpperCase(sc.GetRelative(3))) {	
850  						sc.SetState(SCE_SH_IDENTIFIER | insideCommand);
851  						sc.Forward(3);
852  					} else if (sc.chNext == &#x27;#&#x27; &amp;&amp; !IsASpace(sc.GetRelative(2))) {	
853  						sc.SetState(SCE_SH_IDENTIFIER | insideCommand);
854  						sc.Forward(2);
855  					} else if (setWordStart.Contains(sc.chNext)) {	
856  						sc.SetState(SCE_SH_IDENTIFIER | insideCommand);
857  					}
858  				}
859  			} else if (sc.ch == &#x27;\&quot;&#x27;) {
860  				sc.SetState(SCE_SH_STRING | insideCommand);
861  				QuoteStack.Start(sc.ch, QuoteStyle::String, SCE_SH_DEFAULT);
862  			} else if (sc.ch == &#x27;\&#x27;&#x27;) {
863  				QuoteStack.State = SCE_SH_DEFAULT;
864  				sc.SetState(SCE_SH_CHARACTER | insideCommand);
865  			} else if (sc.ch == &#x27;`&#x27;) {
866  				sc.SetState(SCE_SH_BACKTICKS | insideCommand);
867  				QuoteStack.Start(sc.ch, QuoteStyle::Backtick, SCE_SH_DEFAULT);
868  			} else if (sc.ch == &#x27;$&#x27;) {
869  				QuoteStack.Expand(sc, cmdState, true);
870  				continue;
871  			} else if (cmdState != CmdState::Arithmetic &amp;&amp; sc.Match(&#x27;&lt;&#x27;, &#x27;&lt;&#x27;)) {
872  				sc.SetState(SCE_SH_HERE_DELIM | insideCommand);
873  				HereDoc.State = 0;
874  				if (sc.GetRelative(2) == &#x27;-&#x27;) {	
875  					HereDoc.Indent = true;
876  					sc.Forward();
877  				} else {
878  					HereDoc.Indent = false;
879  				}
880  			} else if (sc.ch == &#x27;-&#x27;	&amp;&amp;	
881  					   setSingleCharOp.Contains(sc.chNext) &amp;&amp;
882  					   !setWord.Contains(sc.GetRelative(2)) &amp;&amp;
883  					   IsASpace(sc.chPrev)) {
884  				sc.SetState(SCE_SH_WORD | insideCommand);
885  				sc.Forward();
886  			} else if (setBashOperator.Contains(sc.ch)) {
887  				bool isCmdDelim = false;
888  				sc.SetState(SCE_SH_OPERATOR | insideCommand);
889  				if (QuoteStack.Current.Style == QuoteStyle::Arithmetic || QuoteStack.Current.Style == QuoteStyle::CommandInside) {
890  					if (sc.ch == QuoteStack.Current.Down) {
891  						if (QuoteStack.CountDown(sc, cmdState)) {
892  							continue;
893  						}
894  					} else if (sc.ch == QuoteStack.Current.Up) {
895  						QuoteStack.Current.Count++;
896  					}
897  				}
898  				if (cmdState != CmdState::Arithmetic &amp;&amp; sc.ch == &#x27;(&#x27; &amp;&amp; sc.chNext != &#x27;(&#x27;) {
899  					const int i = GlobScan(sc);
900  					if (i &gt; 1) {
901  						sc.SetState(SCE_SH_IDENTIFIER | insideCommand);
902  						sc.Forward(i + 1);
903  						continue;
904  					}
905  				}
906  				if (cmdState == CmdState::Start
907  				 || cmdState == CmdState::Body) {
908  					if (sc.Match(&#x27;(&#x27;, &#x27;(&#x27;)) {
909  						cmdState = CmdState::Arithmetic;
910  						sc.Forward();
911  					} else if (sc.Match(&#x27;[&#x27;, &#x27;[&#x27;) &amp;&amp; IsASpace(sc.GetRelative(2))) {
912  						cmdState = CmdState::Test;
913  						testExprType = TestExprType::DoubleBracket;
914  						sc.Forward();
915  					} else if (sc.ch == &#x27;[&#x27; &amp;&amp; IsASpace(sc.chNext)) {
916  						cmdState = CmdState::Test;
917  						testExprType = TestExprType::SingleBracket;
918  					}
919  				}
920  				if (cmdState == CmdState::Word &amp;&amp; sc.Match(&#x27;(&#x27;, &#x27;(&#x27;)) {
921  					cmdState = CmdState::Arithmetic;
922  					sc.Forward(2);
923  					continue;
924  				}
925  				if (cmdState == CmdState::Start
926  				 || cmdState == CmdState::Body
927  				 || cmdState == CmdState::Word
928  				 || (cmdState == CmdState::Test &amp;&amp; testExprType == TestExprType::Test)) {
929  					char s[10];
930  					s[0] = static_cast&lt;char&gt;(sc.ch);
931  					if (setBashOperator.Contains(sc.chNext)) {
932  						s[1] = static_cast&lt;char&gt;(sc.chNext);
933  						s[2] = &#x27;\0&#x27;;
934  						isCmdDelim = cmdDelimiter.InList(s);
935  						if (isCmdDelim)
936  							sc.Forward();
937  					}
938  					if (!isCmdDelim) {
939  						s[1] = &#x27;\0&#x27;;
940  						isCmdDelim = cmdDelimiter.InList(s);
941  					}
942  					if (isCmdDelim) {
943  						cmdState = CmdState::Delimiter;
944  						sc.Forward();
945  						continue;
946  					}
947  				}
948  				if (cmdState == CmdState::Arithmetic &amp;&amp; sc.Match(&#x27;)&#x27;, &#x27;)&#x27;)) {
949  					cmdState = CmdState::Body;
950  					sc.Forward();
951  				} else if (cmdState == CmdState::Test &amp;&amp; IsASpace(sc.chPrev)) {
952  					if (sc.Match(&#x27;]&#x27;, &#x27;]&#x27;) &amp;&amp; testExprType == TestExprType::DoubleBracket) {
953  						sc.Forward();
954  						cmdState = CmdState::Body;
955  					} else if (sc.ch == &#x27;]&#x27; &amp;&amp; testExprType == TestExprType::SingleBracket) {
956  						cmdState = CmdState::Body;
957  					}
958  				}
959  			}
960  		}
961  		sc.Forward();
962  	}
963  	sc.Complete();
964  	if (MaskCommand(sc.state) == SCE_SH_HERE_Q) {
965  		styler.ChangeLexerState(sc.currentPos, styler.Length());
966  	}
967  	sc.Complete();
968  }
969  void SCI_METHOD LexerBash::Fold(Sci_PositionU startPos, Sci_Position length, int, IDocument *pAccess) {
970  	if(!options.fold)
971  		return;
972  	LexAccessor styler(pAccess);
973  	const Sci_PositionU endPos = startPos + length;
974  	int visibleChars = 0;
975  	int skipHereCh = 0;
976  	Sci_Position lineCurrent = styler.GetLine(startPos);
977  	int levelPrev = styler.LevelAt(lineCurrent) &amp; SC_FOLDLEVELNUMBERMASK;
978  	int levelCurrent = levelPrev;
979  	char chNext = styler[startPos];
980  	int styleNext = MaskCommand(styler.StyleIndexAt(startPos));
981  	char word[8] = { &#x27;\0&#x27; }; 
982  	unsigned int wordlen = 0;
983  	for (Sci_PositionU i = startPos; i &lt; endPos; i++) {
984  		const char ch = chNext;
985  		chNext = styler.SafeGetCharAt(i + 1);
986  		const int style = styleNext;
987  		styleNext = MaskCommand(styler.StyleIndexAt(i + 1));
988  		const bool atEOL = (ch == &#x27;\r&#x27; &amp;&amp; chNext != &#x27;\n&#x27;) || (ch == &#x27;\n&#x27;);
989  		if (options.foldComment &amp;&amp; atEOL &amp;&amp; IsCommentLine(lineCurrent, styler))
990  		{
991  			if (!IsCommentLine(lineCurrent - 1, styler)
992  				&amp;&amp; IsCommentLine(lineCurrent + 1, styler))
993  				levelCurrent++;
994  			else if (IsCommentLine(lineCurrent - 1, styler)
995  					 &amp;&amp; !IsCommentLine(lineCurrent + 1, styler))
996  				levelCurrent--;
997  		}
998  		if (style == SCE_SH_WORD) {
999  			if ((wordlen + 1) &lt; sizeof(word))
1000  				word[wordlen++] = ch;
1001  			if (styleNext != style) {
1002  				word[wordlen] = &#x27;\0&#x27;;
1003  				wordlen = 0;
1004  				if (strcmp(word, &quot;if&quot;) == 0 || strcmp(word, &quot;case&quot;) == 0 || strcmp(word, &quot;do&quot;) == 0) {
1005  					levelCurrent++;
1006  				} else if (strcmp(word, &quot;fi&quot;) == 0 || strcmp(word, &quot;esac&quot;) == 0 || strcmp(word, &quot;done&quot;) == 0) {
1007  					levelCurrent--;
1008  				}
1009  			}
1010  		}
1011  		if (style == SCE_SH_OPERATOR) {
1012  			if (ch == &#x27;{&#x27;) {
1013  				levelCurrent++;
1014  			} else if (ch == &#x27;}&#x27;) {
1015  				levelCurrent--;
1016  			}
1017  		}
1018  		if (style == SCE_SH_HERE_DELIM) {
1019  			if (ch == &#x27;&lt;&#x27; &amp;&amp; chNext == &#x27;&lt;&#x27;) {
1020  				if (styler.SafeGetCharAt(i + 2) == &#x27;&lt;&#x27;) {
1021  					skipHereCh = 1;
1022  				} else {
1023  					if (skipHereCh == 0) {
1024  						levelCurrent++;
1025  					} else {
1026  						skipHereCh = 0;
1027  					}
1028  				}
1029  			}
1030  		} else if (style == SCE_SH_HERE_Q &amp;&amp; styler.StyleAt(i+1) == SCE_SH_DEFAULT) {
1031  			levelCurrent--;
1032  		}
1033  		if (atEOL) {
1034  			int lev = levelPrev;
1035  			if (visibleChars == 0 &amp;&amp; options.foldCompact)
1036  				lev |= SC_FOLDLEVELWHITEFLAG;
1037  			if ((levelCurrent &gt; levelPrev) &amp;&amp; (visibleChars &gt; 0))
1038  				lev |= SC_FOLDLEVELHEADERFLAG;
1039  			if (lev != styler.LevelAt(lineCurrent)) {
1040  				styler.SetLevel(lineCurrent, lev);
1041  			}
1042  			lineCurrent++;
1043  			levelPrev = levelCurrent;
1044  			visibleChars = 0;
1045  		}
1046  		if (!isspacechar(ch))
1047  			visibleChars++;
1048  	}
1049  	const int flagsNext = styler.LevelAt(lineCurrent) &amp; ~SC_FOLDLEVELNUMBERMASK;
1050  	styler.SetLevel(lineCurrent, levelPrev | flagsNext);
1051  }
1052  LexerModule lmBash(SCLEX_BASH, LexerBash::LexerFactoryBash, &quot;bash&quot;, bashWordListDesc);
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexBash.cxx</h3>
            <pre><code>1  #include &lt;cstdlib&gt;
2  #include &lt;cassert&gt;
3  #include &lt;cstring&gt;
4  #include &lt;cstdio&gt;
5  #include &lt;cstdarg&gt;
6  #include &lt;string&gt;
7  #include &lt;string_view&gt;
8  #include &lt;vector&gt;
9  #include &lt;map&gt;
10  #include &lt;functional&gt;
11  #include &quot;ILexer.h&quot;
12  #include &quot;Scintilla.h&quot;
13  #include &quot;SciLexer.h&quot;
14  #include &quot;StringCopy.h&quot;
15  #include &quot;WordList.h&quot;
16  #include &quot;LexAccessor.h&quot;
17  #include &quot;StyleContext.h&quot;
18  #include &quot;CharacterSet.h&quot;
19  #include &quot;LexerModule.h&quot;
20  #include &quot;OptionSet.h&quot;
21  #include &quot;SubStyles.h&quot;
22  #include &quot;DefaultLexer.h&quot;
23  using namespace Scintilla;
24  using namespace Lexilla;
25  namespace {
26  #define HERE_DELIM_MAX			256
27  #undef PEDANTIC_OCTAL
28  #define BASH_BASE_ERROR			65
29  #define BASH_BASE_DECIMAL		66
30  #define BASH_BASE_HEX			67
31  #ifdef PEDANTIC_OCTAL
32  #define BASH_BASE_OCTAL			68
33  #define	BASH_BASE_OCTAL_ERROR	69
34  #endif
35  enum class CmdState {
36  	Body,
37  	Start,
38  	Word,
39  	Test,
40  	Arithmetic,
41  	Delimiter,
42  };
43  enum class TestExprType {
44  	Test,			
45  	DoubleBracket,	
46  	SingleBracket,	
47  };
<span onclick='openModal()' class='match'>48  enum class CommandSubstitution {
49  	Backtick,
50  	Inside,
51  	InsideTrack,
52  };
53  enum class QuoteStyle {
54  	Literal,		
55  	CString,		
56  	String,			
57  	LString,		
</span>58  	HereDoc,		
59  	Backtick,		
60  	Parameter,		
61  	Command,		
62  	CommandInside,	
63  	Arithmetic,		
64  };
65  #define BASH_QUOTE_STACK_MAX	7
66  constexpr int commandSubstitutionFlag = 0x40;
67  constexpr int MaskCommand(int state) noexcept {
68  	return state &amp; ~commandSubstitutionFlag;
69  }
70  constexpr int translateBashDigit(int ch) noexcept {
71  	if (ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;) {
72  		return ch - &#x27;0&#x27;;
73  	} else if (ch &gt;= &#x27;a&#x27; &amp;&amp; ch &lt;= &#x27;z&#x27;) {
74  		return ch - &#x27;a&#x27; + 10;
75  	} else if (ch &gt;= &#x27;A&#x27; &amp;&amp; ch &lt;= &#x27;Z&#x27;) {
76  		return ch - &#x27;A&#x27; + 36;
77  	} else if (ch == &#x27;@&#x27;) {
78  		return 62;
79  	} else if (ch == &#x27;_&#x27;) {
80  		return 63;
81  	}
82  	return BASH_BASE_ERROR;
83  }
84  int getBashNumberBase(char *s) noexcept {
85  	int i = 0;
86  	int base = 0;
87  	while (*s) {
88  		base = base * 10 + (*s++ - &#x27;0&#x27;);
89  		i++;
90  	}
91  	if (base &gt; 64 || i &gt; 2) {
92  		return BASH_BASE_ERROR;
93  	}
94  	return base;
95  }
96  constexpr int opposite(int ch) noexcept {
97  	if (ch == &#x27;(&#x27;) return &#x27;)&#x27;;
98  	if (ch == &#x27;[&#x27;) return &#x27;]&#x27;;
99  	if (ch == &#x27;{&#x27;) return &#x27;}&#x27;;
100  	if (ch == &#x27;&lt;&#x27;) return &#x27;&gt;&#x27;;
101  	return ch;
102  }
103  int GlobScan(StyleContext &amp;sc) {
104  	int c = 0;
105  	int sLen = 0;
106  	int pCount = 0;
107  	int hash = 0;
108  	while ((c = sc.GetRelativeCharacter(++sLen)) != 0) {
109  		if (IsASpace(c)) {
110  			return 0;
111  		} else if (c == &#x27;\&#x27;&#x27; || c == &#x27;\&quot;&#x27;) {
112  			if (hash != 2) return 0;
113  		} else if (c == &#x27;#&#x27; &amp;&amp; hash == 0) {
114  			hash = (sLen == 1) ? 2:1;
115  		} else if (c == &#x27;(&#x27;) {
116  			pCount++;
117  		} else if (c == &#x27;)&#x27;) {
118  			if (pCount == 0) {
119  				if (hash) return sLen;
120  				return 0;
121  			}
122  			pCount--;
123  		}
124  	}
125  	return 0;
126  }
127  bool IsCommentLine(Sci_Position line, LexAccessor &amp;styler) {
128  	const Sci_Position pos = styler.LineStart(line);
129  	const Sci_Position eol_pos = styler.LineStart(line + 1) - 1;
130  	for (Sci_Position i = pos; i &lt; eol_pos; i++) {
131  		const char ch = styler[i];
132  		if (ch == &#x27;#&#x27;)
133  			return true;
134  		else if (ch != &#x27; &#x27; &amp;&amp; ch != &#x27;\t&#x27;)
135  			return false;
136  	}
137  	return false;
138  }
139  struct OptionsBash {
140  	bool fold = false;
141  	bool foldComment = false;
142  	bool foldCompact = true;
143  	bool stylingInsideString = false;
144  	bool stylingInsideBackticks = false;
145  	bool stylingInsideParameter = false;
146  	bool stylingInsideHeredoc = false;
147  	int commandSubstitution = static_cast&lt;int&gt;(CommandSubstitution::Backtick);
148  	[[nodiscard]] bool stylingInside(int state) const noexcept {
149  		switch (state) {
150  		case SCE_SH_STRING:
151  			return stylingInsideString;
152  		case SCE_SH_BACKTICKS:
153  			return stylingInsideBackticks;
154  		case SCE_SH_PARAM:
155  			return stylingInsideParameter;
156  		case SCE_SH_HERE_Q:
157  			return stylingInsideHeredoc;
158  		default:
159  			return false;
160  		}
161  	}
162  };
163  const char * const bashWordListDesc[] = {
164  	&quot;Keywords&quot;,
165  	nullptr
166  };
167  struct OptionSetBash : public OptionSet&lt;OptionsBash&gt; {
168  	OptionSetBash() {
169  		DefineProperty(&quot;fold&quot;, &amp;OptionsBash::fold);
170  		DefineProperty(&quot;fold.comment&quot;, &amp;OptionsBash::foldComment);
171  		DefineProperty(&quot;fold.compact&quot;, &amp;OptionsBash::foldCompact);
172  		DefineProperty(&quot;lexer.bash.styling.inside.string&quot;, &amp;OptionsBash::stylingInsideString,
173  			&quot;Set this property to 1 to highlight shell expansions inside string.&quot;);
174  		DefineProperty(&quot;lexer.bash.styling.inside.backticks&quot;, &amp;OptionsBash::stylingInsideBackticks,
175  			&quot;Set this property to 1 to highlight shell expansions inside backticks.&quot;);
176  		DefineProperty(&quot;lexer.bash.styling.inside.parameter&quot;, &amp;OptionsBash::stylingInsideParameter,
177  			&quot;Set this property to 1 to highlight shell expansions inside ${} parameter expansion.&quot;);
178  		DefineProperty(&quot;lexer.bash.styling.inside.heredoc&quot;, &amp;OptionsBash::stylingInsideHeredoc,
179  			&quot;Set this property to 1 to highlight shell expansions inside here document.&quot;);
180  		DefineProperty(&quot;lexer.bash.command.substitution&quot;, &amp;OptionsBash::commandSubstitution,
181  			&quot;Set how to highlight $() command substitution. &quot;
182  			&quot;0 (the default) highlighted as backticks. &quot;
183  			&quot;1 highlighted inside. &quot;
184  			&quot;2 highlighted inside with extra scope tracking.&quot;);
185  		DefineWordListSets(bashWordListDesc);
186  	}
187  };
188  class QuoteCls {	
189  public:
190  	int Count = 0;
191  	int Up = &#x27;\0&#x27;;
192  	int Down = &#x27;\0&#x27;;
193  	QuoteStyle Style = QuoteStyle::Literal;
194  	int Outer = SCE_SH_DEFAULT;
195  	void Clear() noexcept {
196  		Count = 0;
197  		Up	  = &#x27;\0&#x27;;
198  		Down  = &#x27;\0&#x27;;
199  		Style = QuoteStyle::Literal;
200  		Outer = SCE_SH_DEFAULT;
201  	}
202  	void Start(int u, QuoteStyle s, int outer) noexcept {
203  		Count = 1;
204  		Up    = u;
205  		Down  = opposite(Up);
206  		Style = s;
207  		Outer = outer;
208  	}
209  };
210  class QuoteStackCls {	
211  public:
212  	int Depth = 0;
213  	int State = SCE_SH_DEFAULT;
214  	CommandSubstitution commandSubstitution = CommandSubstitution::Backtick;
215  	int insideCommand = 0;
216  	QuoteCls Current;
217  	QuoteCls Stack[BASH_QUOTE_STACK_MAX];
218  	[[nodiscard]] bool Empty() const noexcept {
219  		return Current.Up == &#x27;\0&#x27;;
220  	}
221  	void Start(int u, QuoteStyle s, int outer) noexcept {
222  		if (Empty()) {
223  			Current.Start(u, s, outer);
224  		} else {
225  			Push(u, s, outer);
226  		}
227  	}
228  	void Push(int u, QuoteStyle s, int outer) noexcept {
229  		if (Depth &gt;= BASH_QUOTE_STACK_MAX) {
230  			return;
231  		}
232  		Stack[Depth] = Current;
233  		Depth++;
234  		Current.Start(u, s, outer);
235  	}
236  	void Pop() noexcept {
237  		if (Depth == 0) {
238  			Clear();
239  			return;
240  		}
241  		if (insideCommand != 0) {
242  			insideCommand = 0;
243  			for (int i = 0; i &lt; Depth; i++) {
244  				if (Stack[i].Style == QuoteStyle::CommandInside) {
245  					insideCommand = commandSubstitutionFlag;
246  					break;
247  				}
248  			}
249  		}
250  		Depth--;
251  		Current = Stack[Depth];
252  	}
253  	void Clear() noexcept {
254  		Depth = 0;
255  		State = SCE_SH_DEFAULT;
256  		insideCommand = 0;
257  		Current.Clear();
258  	}
259  	bool CountDown(StyleContext &amp;sc, CmdState &amp;cmdState) {
260  		Current.Count--;
261  		if (Current.Count == 1 &amp;&amp; sc.Match(&#x27;)&#x27;, &#x27;)&#x27;)) {
262  			Current.Count--;
263  			sc.Forward();
264  		}
265  		if (Current.Count == 0) {
266  			cmdState = CmdState::Body;
267  			const int outer = Current.Outer;
268  			Pop();
269  			sc.ForwardSetState(outer | insideCommand);
270  			return true;
271  		}
272  		return false;
273  	}
274  	void Expand(StyleContext &amp;sc, CmdState &amp;cmdState, bool stylingInside) {
275  		const int state = sc.state;
276  		QuoteStyle style = QuoteStyle::Literal;
277  		State = state;
278  		sc.SetState(SCE_SH_SCALAR);
279  		sc.Forward();
280  		if (sc.ch == &#x27;{&#x27;) {
281  			style = QuoteStyle::Parameter;
282  			sc.ChangeState(SCE_SH_PARAM);
283  		} else if (sc.ch == &#x27;\&#x27;&#x27;) {
284  			style = QuoteStyle::CString;
285  			sc.ChangeState(SCE_SH_STRING);
286  		} else if (sc.ch == &#x27;&quot;&#x27;) {
287  			style = QuoteStyle::LString;
288  			sc.ChangeState(SCE_SH_STRING);
289  		} else if (sc.ch == &#x27;(&#x27; || sc.ch == &#x27;[&#x27;) {
290  			if (sc.ch == &#x27;[&#x27; || sc.chNext == &#x27;(&#x27;) {
291  				style = QuoteStyle::Arithmetic;
292  				cmdState = CmdState::Arithmetic;
293  				sc.ChangeState(SCE_SH_OPERATOR);
294  			} else {
295  				if (stylingInside &amp;&amp; commandSubstitution &gt;= CommandSubstitution::Inside) {
296  					style = QuoteStyle::CommandInside;
297  					cmdState = CmdState::Delimiter;
298  					sc.ChangeState(SCE_SH_OPERATOR);
299  					if (commandSubstitution == CommandSubstitution::InsideTrack) {
300  						insideCommand = commandSubstitutionFlag;
301  					}
302  				} else {
303  					style = QuoteStyle::Command;
304  					sc.ChangeState(SCE_SH_BACKTICKS);
305  				}
306  			}
307  			if (sc.Match(&#x27;(&#x27;, &#x27;(&#x27;) &amp;&amp; state == SCE_SH_DEFAULT &amp;&amp; Depth == 0) {
308  				style = QuoteStyle::Literal;
309  			}
310  		} else if (sc.ch == &#x27;`&#x27;) {	
311  			style = QuoteStyle::Backtick;
312  			sc.ChangeState(SCE_SH_BACKTICKS);
313  		} else {
314  		}
315  		if (!stylingInside) {
316  			sc.ChangeState(state);
317  		} else {
318  			sc.ChangeState(sc.state | insideCommand);
319  		}
320  		if (style != QuoteStyle::Literal) {
321  			Start(sc.ch, style, state);
322  			sc.Forward();
323  		}
324  	}
325  };
326  const char styleSubable[] = { SCE_SH_IDENTIFIER, SCE_SH_SCALAR, 0 };
327  const LexicalClass lexicalClasses[] = {
328  	0, &quot;SCE_SH_DEFAULT&quot;, &quot;default&quot;, &quot;White space&quot;,
329  	1, &quot;SCE_SH_ERROR&quot;, &quot;error&quot;, &quot;Error&quot;,
330  	2, &quot;SCE_SH_COMMENTLINE&quot;, &quot;comment line&quot;, &quot;Line comment: #&quot;,
331  	3, &quot;SCE_SH_NUMBER&quot;, &quot;literal numeric&quot;, &quot;Number&quot;,
332  	4, &quot;SCE_SH_WORD&quot;, &quot;keyword&quot;, &quot;Keyword&quot;,
333  	5, &quot;SCE_SH_STRING&quot;, &quot;literal string&quot;, &quot;String&quot;,
334  	6, &quot;SCE_SH_CHARACTER&quot;, &quot;literal string&quot;, &quot;Single quoted string&quot;,
335  	7, &quot;SCE_SH_OPERATOR&quot;, &quot;operator&quot;, &quot;Operators&quot;,
336  	8, &quot;SCE_SH_IDENTIFIER&quot;, &quot;identifier&quot;, &quot;Identifiers&quot;,
337  	9, &quot;SCE_SH_SCALAR&quot;, &quot;identifier&quot;, &quot;Scalar variable&quot;,
338  	10, &quot;SCE_SH_PARAM&quot;, &quot;identifier&quot;, &quot;Parameter&quot;,
339  	11, &quot;SCE_SH_BACKTICKS&quot;, &quot;literal string&quot;, &quot;Backtick quoted command&quot;,
340  	12, &quot;SCE_SH_HERE_DELIM&quot;, &quot;operator&quot;, &quot;Heredoc delimiter&quot;,
341  	13, &quot;SCE_SH_HERE_Q&quot;, &quot;literal string&quot;, &quot;Heredoc quoted string&quot;,
342  };
343  }
344  class LexerBash final : public DefaultLexer {
345  	WordList keywords;
346  	WordList cmdDelimiter;
347  	WordList bashStruct;
348  	WordList bashStruct_in;
349  	OptionsBash options;
350  	OptionSetBash osBash;
351  	enum { ssIdentifier, ssScalar };
352  	SubStyles subStyles;
353  public:
354  	LexerBash() :
355  		DefaultLexer(&quot;bash&quot;, SCLEX_BASH, lexicalClasses, ELEMENTS(lexicalClasses)),
356  		subStyles(styleSubable, 0x80, 0x40, 0) {
357  		cmdDelimiter.Set(&quot;| || |&amp; &amp; &amp;&amp; ; ;; ( ) { }&quot;);
358  		bashStruct.Set(&quot;if elif fi while until else then do done esac eval&quot;);
359  		bashStruct_in.Set(&quot;for case select&quot;);
360  	}
361  	void SCI_METHOD Release() override {
362  		delete this;
363  	}
364  	int SCI_METHOD Version() const override {
365  		return lvRelease5;
366  	}
367  	const char * SCI_METHOD PropertyNames() override {
368  		return osBash.PropertyNames();
369  	}
370  	int SCI_METHOD PropertyType(const char* name) override {
371  		return osBash.PropertyType(name);
372  	}
373  	const char * SCI_METHOD DescribeProperty(const char *name) override {
374  		return osBash.DescribeProperty(name);
375  	}
376  	Sci_Position SCI_METHOD PropertySet(const char *key, const char *val) override;
377  	const char * SCI_METHOD PropertyGet(const char* key) override {
378  		return osBash.PropertyGet(key);
379  	}
380  	const char * SCI_METHOD DescribeWordListSets() override {
381  		return osBash.DescribeWordListSets();
382  	}
383  	Sci_Position SCI_METHOD WordListSet(int n, const char *wl) override;
384  	void SCI_METHOD Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) override;
385  	void SCI_METHOD Fold(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) override;
386  	void * SCI_METHOD PrivateCall(int, void *) override {
387  		return nullptr;
388  	}
389  	int SCI_METHOD AllocateSubStyles(int styleBase, int numberStyles) override {
390  		return subStyles.Allocate(styleBase, numberStyles);
391  	}
392  	int SCI_METHOD SubStylesStart(int styleBase) override {
393  		return subStyles.Start(styleBase);
394  	}
395  	int SCI_METHOD SubStylesLength(int styleBase) override {
396  		return subStyles.Length(styleBase);
397  	}
398  	int SCI_METHOD StyleFromSubStyle(int subStyle) override {
399  		const int styleBase = subStyles.BaseStyle(subStyle);
400  		return styleBase;
401  	}
402  	int SCI_METHOD PrimaryStyleFromStyle(int style) override {
403  		return style;
404  	}
405  	void SCI_METHOD FreeSubStyles() override {
406  		subStyles.Free();
407  	}
408  	void SCI_METHOD SetIdentifiers(int style, const char *identifiers) override {
409  		subStyles.SetIdentifiers(style, identifiers);
410  	}
411  	int SCI_METHOD DistanceToSecondaryStyles() override {
412  		return 0;
413  	}
414  	const char *SCI_METHOD GetSubStyleBases() override {
415  		return styleSubable;
416  	}
417  	static ILexer5 *LexerFactoryBash() {
418  		return new LexerBash();
419  	}
420  };
421  Sci_Position SCI_METHOD LexerBash::PropertySet(const char *key, const char *val) {
422  	if (osBash.PropertySet(&amp;options, key, val)) {
423  		return 0;
424  	}
425  	return -1;
426  }
427  Sci_Position SCI_METHOD LexerBash::WordListSet(int n, const char *wl) {
428  	WordList *wordListN = nullptr;
429  	switch (n) {
430  	case 0:
431  		wordListN = &amp;keywords;
432  		break;
433  	}
434  	Sci_Position firstModification = -1;
435  	if (wordListN) {
436  		if (wordListN-&gt;Set(wl)) {
437  			firstModification = 0;
438  		}
439  	}
440  	return firstModification;
441  }
442  void SCI_METHOD LexerBash::Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) {
443  	const CharacterSet setWordStart(CharacterSet::setAlpha, &quot;_&quot;);
444  	const CharacterSet setWord(CharacterSet::setAlphaNum, &quot;._+-&quot;);
445  	CharacterSet setMetaCharacter(CharacterSet::setNone, &quot;|&amp;;()&lt;&gt; \t\r\n&quot;);
446  	setMetaCharacter.Add(0);
447  	const CharacterSet setBashOperator(CharacterSet::setNone, &quot;^&amp;%()-+=|{}[]:;&gt;,*/&lt;?!.~@&quot;);
448  	const CharacterSet setSingleCharOp(CharacterSet::setNone, &quot;rwxoRWXOezsfdlpSbctugkTBMACahGLNn&quot;);
449  	const CharacterSet setParam(CharacterSet::setAlphaNum, &quot;_&quot;);
450  	const CharacterSet setHereDoc(CharacterSet::setAlpha, &quot;_\\-+!%*,./:?@[]^`{}~&quot;);
451  	const CharacterSet setHereDoc2(CharacterSet::setAlphaNum, &quot;_-+!%*,./:=?@[]^`{}~&quot;);
452  	const CharacterSet setLeftShift(CharacterSet::setDigits, &quot;$&quot;);
453  	class HereDocCls {	
454  	public:
455  		int State = 0;			
456  		int Quote = &#x27;\0&#x27;;		
457  		bool Quoted = false;		
458  		bool Escaped = false;		
459  		bool Indent = false;		
460  		int DelimiterLength = 0;	
461  		char Delimiter[HERE_DELIM_MAX]{};	
462  		HereDocCls() noexcept = default;
463  		void Append(int ch) {
464  			Delimiter[DelimiterLength++] = static_cast&lt;char&gt;(ch);
465  			Delimiter[DelimiterLength] = &#x27;\0&#x27;;
466  		}
467  	};
468  	HereDocCls HereDoc;
469  	QuoteStackCls QuoteStack;
470  	QuoteStack.commandSubstitution = static_cast&lt;CommandSubstitution&gt;(options.commandSubstitution);
471  	const WordClassifier &amp;classifierIdentifiers = subStyles.Classifier(SCE_SH_IDENTIFIER);
472  	const WordClassifier &amp;classifierScalars = subStyles.Classifier(SCE_SH_SCALAR);
473  	int numBase = 0;
474  	int digit = 0;
475  	const Sci_PositionU endPos = startPos + length;
476  	CmdState cmdState = CmdState::Start;
477  	TestExprType testExprType = TestExprType::Test;
478  	LexAccessor styler(pAccess);
479  	Sci_Position ln = styler.GetLine(startPos);
480  	if (ln &gt; 0 &amp;&amp; startPos == static_cast&lt;Sci_PositionU&gt;(styler.LineStart(ln)))
481  		ln--;
482  	for (;;) {
483  		startPos = styler.LineStart(ln);
484  		if (ln == 0 || styler.GetLineState(ln) == static_cast&lt;int&gt;(CmdState::Start))
485  			break;
486  		ln--;
487  	}
488  	initStyle = SCE_SH_DEFAULT;
489  	StyleContext sc(startPos, endPos - startPos, initStyle, styler);
490  	while (sc.More()) {
491  		if (sc.atLineStart) {
492  			if (MaskCommand(sc.state) == SCE_SH_STRING
493  			 || MaskCommand(sc.state) == SCE_SH_BACKTICKS
494  			 || MaskCommand(sc.state) == SCE_SH_CHARACTER
495  			 || MaskCommand(sc.state) == SCE_SH_HERE_Q
496  			 || MaskCommand(sc.state) == SCE_SH_COMMENTLINE
497  			 || MaskCommand(sc.state) == SCE_SH_PARAM) {
498  				styler.SetLineState(sc.currentLine, static_cast&lt;int&gt;(CmdState::Body));
499  			} else {
500  				if (sc.currentLine &gt; 0) {
501  					if ((sc.GetRelative(-3) == &#x27;\\&#x27; &amp;&amp; sc.GetRelative(-2) == &#x27;\r&#x27; &amp;&amp; sc.chPrev == &#x27;\n&#x27;)
502  					 || sc.GetRelative(-2) == &#x27;\\&#x27;) {	
503  					} else
504  						cmdState = CmdState::Start;
505  				}
506  				const CmdState state = QuoteStack.Empty() ? cmdState : CmdState::Body;
507  				styler.SetLineState(sc.currentLine, static_cast&lt;int&gt;(state));
508  			}
509  		}
510  		CmdState cmdStateNew = CmdState::Body;
511  		if (cmdState == CmdState::Test || cmdState == CmdState::Arithmetic || cmdState == CmdState::Word)
512  			cmdStateNew = cmdState;
513  		const int stylePrev = MaskCommand(sc.state);
514  		const int insideCommand = QuoteStack.insideCommand;
515  		switch (MaskCommand(sc.state)) {
516  			case SCE_SH_OPERATOR:
517  				sc.SetState(SCE_SH_DEFAULT | insideCommand);
518  				if (cmdState == CmdState::Delimiter)		
519  					cmdStateNew = CmdState::Start;
520  				else if (sc.chPrev == &#x27;\\&#x27;)			
521  					cmdStateNew = cmdState;
522  				break;
523  			case SCE_SH_WORD:
524  				if (!setWord.Contains(sc.ch)) {
525  					char s[500];
526  					sc.GetCurrent(s, sizeof(s));
527  					int identifierStyle = SCE_SH_IDENTIFIER | insideCommand;
528  					const int subStyle = classifierIdentifiers.ValueFor(s);
529  					if (subStyle &gt;= 0) {
530  						identifierStyle = subStyle | insideCommand;
531  					}
532  					char s2[10];
533  					s2[0] = static_cast&lt;char&gt;(sc.ch);
534  					s2[1] = &#x27;\0&#x27;;
535  					const bool keywordEnds = IsASpace(sc.ch) || cmdDelimiter.InList(s2);
536  					if (cmdState == CmdState::Word) {
537  						if (strcmp(s, &quot;in&quot;) == 0 &amp;&amp; keywordEnds)
538  							cmdStateNew = CmdState::Body;
539  						else if (strcmp(s, &quot;do&quot;) == 0 &amp;&amp; keywordEnds)
540  							cmdStateNew = CmdState::Start;
541  						else
542  							sc.ChangeState(identifierStyle);
543  						sc.SetState(SCE_SH_DEFAULT | insideCommand);
544  						break;
545  					}
546  					if (strcmp(s, &quot;test&quot;) == 0) {
547  						if (cmdState == CmdState::Start &amp;&amp; keywordEnds) {
548  							cmdStateNew = CmdState::Test;
549  							testExprType = TestExprType::Test;
550  						} else
551  							sc.ChangeState(identifierStyle);
552  					}
553  					else if (bashStruct.InList(s)) {
554  						if (cmdState == CmdState::Start &amp;&amp; keywordEnds)
555  							cmdStateNew = CmdState::Start;
556  						else
557  							sc.ChangeState(identifierStyle);
558  					}
559  					else if (bashStruct_in.InList(s)) {
560  						if (cmdState == CmdState::Start &amp;&amp; keywordEnds)
561  							cmdStateNew = CmdState::Word;
562  						else
563  							sc.ChangeState(identifierStyle);
564  					}
565  					else if (s[0] == &#x27;-&#x27;) {
566  						if (cmdState != CmdState::Test)
567  							sc.ChangeState(identifierStyle);
568  					}
569  					else if (cmdState != CmdState::Start
570  						  || !(keywords.InList(s) &amp;&amp; keywordEnds)) {
571  						sc.ChangeState(identifierStyle);
572  					}
573  					sc.SetState(SCE_SH_DEFAULT | insideCommand);
574  				}
575  				break;
576  			case SCE_SH_IDENTIFIER:
577  				if (sc.chPrev == &#x27;\\&#x27; || !setWord.Contains(sc.ch) ||
578  					  (cmdState == CmdState::Arithmetic &amp;&amp; !setWordStart.Contains(sc.ch))) {
579  					char s[500];
580  					sc.GetCurrent(s, sizeof(s));
581  					const int subStyle = classifierIdentifiers.ValueFor(s);
582  					if (subStyle &gt;= 0) {
583  						sc.ChangeState(subStyle | insideCommand);
584  					}
585  					if (sc.chPrev == &#x27;\\&#x27;) {	
586  						sc.Forward();
587  					}
588  					sc.SetState(SCE_SH_DEFAULT | insideCommand);
589  				}
590  				break;
591  			case SCE_SH_NUMBER:
592  				digit = translateBashDigit(sc.ch);
593  				if (numBase == BASH_BASE_DECIMAL) {
594  					if (sc.ch == &#x27;#&#x27;) {
595  						char s[10];
596  						sc.GetCurrent(s, sizeof(s));
597  						numBase = getBashNumberBase(s);
598  						if (numBase != BASH_BASE_ERROR)
599  							break;
600  					} else if (IsADigit(sc.ch))
601  						break;
602  				} else if (numBase == BASH_BASE_HEX) {
603  					if (IsADigit(sc.ch, 16))
604  						break;
605  #ifdef PEDANTIC_OCTAL
606  				} else if (numBase == BASH_BASE_OCTAL ||
607  						   numBase == BASH_BASE_OCTAL_ERROR) {
608  					if (digit &lt;= 7)
609  						break;
610  					if (digit &lt;= 9) {
611  						numBase = BASH_BASE_OCTAL_ERROR;
612  						break;
613  					}
614  #endif
615  				} else if (numBase == BASH_BASE_ERROR) {
616  					if (digit &lt;= 9)
617  						break;
618  				} else {	
619  					if (digit != BASH_BASE_ERROR) {
620  						if (numBase &lt;= 36) {
621  							if (digit &gt;= 36) digit -= 26;
622  						}
623  						if (digit &lt; numBase)
624  							break;
625  						if (digit &lt;= 9) {
626  							numBase = BASH_BASE_ERROR;
627  							break;
628  						}
629  					}
630  				}
631  				if (numBase == BASH_BASE_ERROR
632  #ifdef PEDANTIC_OCTAL
633  					|| numBase == BASH_BASE_OCTAL_ERROR
634  #endif
635  				) {
636  					sc.ChangeState(SCE_SH_ERROR | insideCommand);
637  				}
638  				sc.SetState(SCE_SH_DEFAULT | insideCommand);
639  				break;
640  			case SCE_SH_COMMENTLINE:
641  				if (sc.MatchLineEnd() &amp;&amp; sc.chPrev != &#x27;\\&#x27;) {
642  					sc.SetState(SCE_SH_DEFAULT | insideCommand);
643  				}
644  				break;
645  			case SCE_SH_HERE_DELIM:
646  				if (HereDoc.State == 0) { 
647  					HereDoc.Quote = sc.chNext;
648  					HereDoc.Quoted = false;
649  					HereDoc.Escaped = false;
650  					HereDoc.DelimiterLength = 0;
651  					HereDoc.Delimiter[HereDoc.DelimiterLength] = &#x27;\0&#x27;;
652  					if (sc.chNext == &#x27;\&#x27;&#x27; || sc.chNext == &#x27;\&quot;&#x27;) {	
653  						sc.Forward();
654  						HereDoc.Quoted = true;
655  						HereDoc.State = 1;
656  					} else if (setHereDoc.Contains(sc.chNext) ||
657  					           (sc.chNext == &#x27;=&#x27; &amp;&amp; cmdState != CmdState::Arithmetic)) {
658  						HereDoc.State = 1;
659  					} else if (sc.chNext == &#x27;&lt;&#x27;) {	
660  						sc.Forward();
661  						sc.ForwardSetState(SCE_SH_DEFAULT | insideCommand);
662  					} else if (IsASpace(sc.chNext)) {
663  					} else if (setLeftShift.Contains(sc.chNext) ||
664  					           (sc.chNext == &#x27;=&#x27; &amp;&amp; cmdState == CmdState::Arithmetic)) {
665  						sc.ChangeState(SCE_SH_OPERATOR | insideCommand);
666  						sc.ForwardSetState(SCE_SH_DEFAULT | insideCommand);
667  					} else {
668  						HereDoc.State = 1;
669  					}
670  				} else if (HereDoc.State == 1) { 
671  					if ((HereDoc.Quote == &#x27;\&#x27;&#x27; &amp;&amp; sc.ch != HereDoc.Quote) ||
672  					    (HereDoc.Quoted &amp;&amp; sc.ch != HereDoc.Quote &amp;&amp; sc.ch != &#x27;\\&#x27;) ||
673  					    (HereDoc.Quote != &#x27;\&#x27;&#x27; &amp;&amp; sc.chPrev == &#x27;\\&#x27;) ||
674  					    (setHereDoc2.Contains(sc.ch))) {
675  						HereDoc.Append(sc.ch);
676  					} else if (HereDoc.Quoted &amp;&amp; sc.ch == HereDoc.Quote) {	
677  						sc.ForwardSetState(SCE_SH_DEFAULT);
678  					} else if (sc.ch == &#x27;\\&#x27;) {
679  						HereDoc.Escaped = true;
680  						if (HereDoc.Quoted &amp;&amp; sc.chNext != HereDoc.Quote &amp;&amp; sc.chNext != &#x27;\\&#x27;) {
681  							HereDoc.Append(sc.ch);
682  						} else {
683  						}
684  					} else if (!HereDoc.Quoted) {
685  						sc.SetState(SCE_SH_DEFAULT | insideCommand);
686  					}
687  					if (HereDoc.DelimiterLength &gt;= HERE_DELIM_MAX - 1) {	
688  						sc.SetState(SCE_SH_ERROR | insideCommand);
689  						HereDoc.State = 0;
690  					}
691  				}
692  				break;
693  			case SCE_SH_SCALAR:	
694  				if (!setParam.Contains(sc.ch)) {
695  					char s[500];
696  					sc.GetCurrent(s, sizeof(s));
697  					const int subStyle = classifierScalars.ValueFor(&amp;s[1]); 
698  					if (subStyle &gt;= 0) {
699  						sc.ChangeState(subStyle | insideCommand);
700  					}
701  					if (sc.LengthCurrent() == 1) {
702  						sc.Forward();
703  					}
704  					sc.SetState(QuoteStack.State | insideCommand);
705  					continue;
706  				}
707  				break;
708  			case SCE_SH_HERE_Q:
709  				if (sc.atLineStart &amp;&amp; QuoteStack.Current.Style == QuoteStyle::HereDoc) {
710  					sc.SetState(SCE_SH_HERE_Q | insideCommand);
711  					if (HereDoc.Indent) { 
712  						while (sc.ch == &#x27;\t&#x27;) {
713  							sc.Forward();
714  						}
715  					}
716  					if ((static_cast&lt;Sci_Position&gt;(sc.currentPos + HereDoc.DelimiterLength) == sc.lineEnd) &amp;&amp;
717  						(HereDoc.DelimiterLength == 0 || sc.Match(HereDoc.Delimiter))) {
718  						while (!sc.MatchLineEnd()) {
719  							sc.Forward();
720  						}
721  						QuoteStack.Pop();
722  						sc.SetState(SCE_SH_DEFAULT | QuoteStack.insideCommand);
723  						break;
724  					}
725  				}
726  				if (HereDoc.Quoted || HereDoc.Escaped) {
727  					break;
728  				}
729  				[[fallthrough]];
730  			case SCE_SH_STRING:	
731  			case SCE_SH_PARAM: 
732  			case SCE_SH_BACKTICKS:
733  				if (sc.ch == &#x27;\\&#x27;) {
734  					if (QuoteStack.Current.Style != QuoteStyle::Literal)
735  						sc.Forward();
736  				} else if (sc.ch == QuoteStack.Current.Down) {
737  					if (QuoteStack.CountDown(sc, cmdState)) {
738  						continue;
739  					}
740  				} else if (sc.ch == QuoteStack.Current.Up) {
741  					QuoteStack.Current.Count++;
742  				} else {
743  					if (QuoteStack.Current.Style == QuoteStyle::String ||
744  						QuoteStack.Current.Style == QuoteStyle::HereDoc ||
745  						QuoteStack.Current.Style == QuoteStyle::LString
746  					) {	
747  						const bool stylingInside = options.stylingInside(MaskCommand(sc.state));
748  						if (sc.ch == &#x27;`&#x27;) {
749  							QuoteStack.Push(sc.ch, QuoteStyle::Backtick, sc.state);
750  							if (stylingInside) {
751  								sc.SetState(SCE_SH_BACKTICKS | insideCommand);
752  							}
753  						} else if (sc.ch == &#x27;$&#x27;) {
754  							QuoteStack.Expand(sc, cmdState, stylingInside);
755  							continue;
756  						}
757  					} else if (QuoteStack.Current.Style == QuoteStyle::Command ||
758  							   QuoteStack.Current.Style == QuoteStyle::Parameter ||
759  							   QuoteStack.Current.Style == QuoteStyle::Backtick
760  					) {	
761  						const bool stylingInside = options.stylingInside(MaskCommand(sc.state));
762  						if (sc.ch == &#x27;\&#x27;&#x27;) {
763  							if (stylingInside) {
764  								QuoteStack.State = sc.state;
765  								sc.SetState(SCE_SH_CHARACTER | insideCommand);
766  							} else {
767  								QuoteStack.Push(sc.ch, QuoteStyle::Literal, sc.state);
768  							}
769  						} else if (sc.ch == &#x27;\&quot;&#x27;) {
770  							QuoteStack.Push(sc.ch, QuoteStyle::String, sc.state);
771  							if (stylingInside) {
772  								sc.SetState(SCE_SH_STRING | insideCommand);
773  							}
774  						} else if (sc.ch == &#x27;`&#x27;) {
775  							QuoteStack.Push(sc.ch, QuoteStyle::Backtick, sc.state);
776  							if (stylingInside) {
777  								sc.SetState(SCE_SH_BACKTICKS | insideCommand);
778  							}
779  						} else if (sc.ch == &#x27;$&#x27;) {
780  							QuoteStack.Expand(sc, cmdState, stylingInside);
781  							continue;
782  						}
783  					}
784  				}
785  				break;
786  			case SCE_SH_CHARACTER: 
787  				if (sc.ch == &#x27;\&#x27;&#x27;) {
788  					sc.ForwardSetState(QuoteStack.State | insideCommand);
789  					continue;
790  				}
791  				break;
792  		}
793  		if (HereDoc.State == 1 &amp;&amp; sc.MatchLineEnd()) {
794  			HereDoc.State = 2;
795  			if (HereDoc.Quoted) {
796  				if (MaskCommand(sc.state) == SCE_SH_HERE_DELIM) {
797  					sc.ChangeState(SCE_SH_ERROR | insideCommand);
798  					sc.SetState(SCE_SH_DEFAULT | insideCommand);
799  				} else {
800  					sc.SetState(SCE_SH_HERE_Q | insideCommand);
801  					QuoteStack.Start(-1, QuoteStyle::HereDoc, SCE_SH_DEFAULT);
802  				}
803  			} else if (HereDoc.DelimiterLength == 0) {
804  				sc.ChangeState(SCE_SH_ERROR | insideCommand);
805  				sc.SetState(SCE_SH_DEFAULT | insideCommand);
806  			} else {
807  				sc.SetState(SCE_SH_HERE_Q | insideCommand);
808  				QuoteStack.Start(-1, QuoteStyle::HereDoc, SCE_SH_DEFAULT);
809  			}
810  		}
811  		if (stylePrev != SCE_SH_DEFAULT &amp;&amp; MaskCommand(sc.state) == SCE_SH_DEFAULT) {
812  			cmdState = cmdStateNew;
813  		}
814  		if (MaskCommand(sc.state) == SCE_SH_DEFAULT) {
815  			if (sc.ch == &#x27;\\&#x27;) {
816  				sc.SetState(SCE_SH_IDENTIFIER | insideCommand);
817  				if (sc.chNext == &#x27;\r&#x27; || sc.chNext == &#x27;\n&#x27;)
818  					sc.SetState(SCE_SH_OPERATOR | insideCommand);
819  			} else if (IsADigit(sc.ch)) {
820  				sc.SetState(SCE_SH_NUMBER | insideCommand);
821  				numBase = BASH_BASE_DECIMAL;
822  				if (sc.ch == &#x27;0&#x27;) {	
823  					if (sc.chNext == &#x27;x&#x27; || sc.chNext == &#x27;X&#x27;) {
824  						numBase = BASH_BASE_HEX;
825  						sc.Forward();
826  					} else if (IsADigit(sc.chNext)) {
827  #ifdef PEDANTIC_OCTAL
828  						numBase = BASH_BASE_OCTAL;
829  #else
830  						numBase = BASH_BASE_HEX;
831  #endif
832  					}
833  				}
834  			} else if (setWordStart.Contains(sc.ch)) {
835  				sc.SetState(SCE_SH_WORD | insideCommand);
836  			} else if (sc.ch == &#x27;#&#x27;) {
837  				if (stylePrev != SCE_SH_WORD &amp;&amp; stylePrev != SCE_SH_IDENTIFIER &amp;&amp;
838  					(sc.currentPos == 0 || setMetaCharacter.Contains(sc.chPrev))) {
839  					sc.SetState(SCE_SH_COMMENTLINE | insideCommand);
840  				} else {
841  					sc.SetState(SCE_SH_WORD | insideCommand);
842  				}
843  				if (cmdState == CmdState::Arithmetic) {
844  					if (sc.chPrev == &#x27;[&#x27;) {	
845  						sc.SetState(SCE_SH_WORD | insideCommand);
846  						if (sc.chNext == &#x27;#&#x27;) {
847  							sc.Forward();
848  						}
849  					} else if (sc.Match(&quot;##^&quot;) &amp;&amp; IsUpperCase(sc.GetRelative(3))) {	
850  						sc.SetState(SCE_SH_IDENTIFIER | insideCommand);
851  						sc.Forward(3);
852  					} else if (sc.chNext == &#x27;#&#x27; &amp;&amp; !IsASpace(sc.GetRelative(2))) {	
853  						sc.SetState(SCE_SH_IDENTIFIER | insideCommand);
854  						sc.Forward(2);
855  					} else if (setWordStart.Contains(sc.chNext)) {	
856  						sc.SetState(SCE_SH_IDENTIFIER | insideCommand);
857  					}
858  				}
859  			} else if (sc.ch == &#x27;\&quot;&#x27;) {
860  				sc.SetState(SCE_SH_STRING | insideCommand);
861  				QuoteStack.Start(sc.ch, QuoteStyle::String, SCE_SH_DEFAULT);
862  			} else if (sc.ch == &#x27;\&#x27;&#x27;) {
863  				QuoteStack.State = SCE_SH_DEFAULT;
864  				sc.SetState(SCE_SH_CHARACTER | insideCommand);
865  			} else if (sc.ch == &#x27;`&#x27;) {
866  				sc.SetState(SCE_SH_BACKTICKS | insideCommand);
867  				QuoteStack.Start(sc.ch, QuoteStyle::Backtick, SCE_SH_DEFAULT);
868  			} else if (sc.ch == &#x27;$&#x27;) {
869  				QuoteStack.Expand(sc, cmdState, true);
870  				continue;
871  			} else if (cmdState != CmdState::Arithmetic &amp;&amp; sc.Match(&#x27;&lt;&#x27;, &#x27;&lt;&#x27;)) {
872  				sc.SetState(SCE_SH_HERE_DELIM | insideCommand);
873  				HereDoc.State = 0;
874  				if (sc.GetRelative(2) == &#x27;-&#x27;) {	
875  					HereDoc.Indent = true;
876  					sc.Forward();
877  				} else {
878  					HereDoc.Indent = false;
879  				}
880  			} else if (sc.ch == &#x27;-&#x27;	&amp;&amp;	
881  					   setSingleCharOp.Contains(sc.chNext) &amp;&amp;
882  					   !setWord.Contains(sc.GetRelative(2)) &amp;&amp;
883  					   IsASpace(sc.chPrev)) {
884  				sc.SetState(SCE_SH_WORD | insideCommand);
885  				sc.Forward();
886  			} else if (setBashOperator.Contains(sc.ch)) {
887  				bool isCmdDelim = false;
888  				sc.SetState(SCE_SH_OPERATOR | insideCommand);
889  				if (QuoteStack.Current.Style == QuoteStyle::Arithmetic || QuoteStack.Current.Style == QuoteStyle::CommandInside) {
890  					if (sc.ch == QuoteStack.Current.Down) {
891  						if (QuoteStack.CountDown(sc, cmdState)) {
892  							continue;
893  						}
894  					} else if (sc.ch == QuoteStack.Current.Up) {
895  						QuoteStack.Current.Count++;
896  					}
897  				}
898  				if (cmdState != CmdState::Arithmetic &amp;&amp; sc.ch == &#x27;(&#x27; &amp;&amp; sc.chNext != &#x27;(&#x27;) {
899  					const int i = GlobScan(sc);
900  					if (i &gt; 1) {
901  						sc.SetState(SCE_SH_IDENTIFIER | insideCommand);
902  						sc.Forward(i + 1);
903  						continue;
904  					}
905  				}
906  				if (cmdState == CmdState::Start
907  				 || cmdState == CmdState::Body) {
908  					if (sc.Match(&#x27;(&#x27;, &#x27;(&#x27;)) {
909  						cmdState = CmdState::Arithmetic;
910  						sc.Forward();
911  					} else if (sc.Match(&#x27;[&#x27;, &#x27;[&#x27;) &amp;&amp; IsASpace(sc.GetRelative(2))) {
912  						cmdState = CmdState::Test;
913  						testExprType = TestExprType::DoubleBracket;
914  						sc.Forward();
915  					} else if (sc.ch == &#x27;[&#x27; &amp;&amp; IsASpace(sc.chNext)) {
916  						cmdState = CmdState::Test;
917  						testExprType = TestExprType::SingleBracket;
918  					}
919  				}
920  				if (cmdState == CmdState::Word &amp;&amp; sc.Match(&#x27;(&#x27;, &#x27;(&#x27;)) {
921  					cmdState = CmdState::Arithmetic;
922  					sc.Forward(2);
923  					continue;
924  				}
925  				if (cmdState == CmdState::Start
926  				 || cmdState == CmdState::Body
927  				 || cmdState == CmdState::Word
928  				 || (cmdState == CmdState::Test &amp;&amp; testExprType == TestExprType::Test)) {
929  					char s[10];
930  					s[0] = static_cast&lt;char&gt;(sc.ch);
931  					if (setBashOperator.Contains(sc.chNext)) {
932  						s[1] = static_cast&lt;char&gt;(sc.chNext);
933  						s[2] = &#x27;\0&#x27;;
934  						isCmdDelim = cmdDelimiter.InList(s);
935  						if (isCmdDelim)
936  							sc.Forward();
937  					}
938  					if (!isCmdDelim) {
939  						s[1] = &#x27;\0&#x27;;
940  						isCmdDelim = cmdDelimiter.InList(s);
941  					}
942  					if (isCmdDelim) {
943  						cmdState = CmdState::Delimiter;
944  						sc.Forward();
945  						continue;
946  					}
947  				}
948  				if (cmdState == CmdState::Arithmetic &amp;&amp; sc.Match(&#x27;)&#x27;, &#x27;)&#x27;)) {
949  					cmdState = CmdState::Body;
950  					sc.Forward();
951  				} else if (cmdState == CmdState::Test &amp;&amp; IsASpace(sc.chPrev)) {
952  					if (sc.Match(&#x27;]&#x27;, &#x27;]&#x27;) &amp;&amp; testExprType == TestExprType::DoubleBracket) {
953  						sc.Forward();
954  						cmdState = CmdState::Body;
955  					} else if (sc.ch == &#x27;]&#x27; &amp;&amp; testExprType == TestExprType::SingleBracket) {
956  						cmdState = CmdState::Body;
957  					}
958  				}
959  			}
960  		}
961  		sc.Forward();
962  	}
963  	sc.Complete();
964  	if (MaskCommand(sc.state) == SCE_SH_HERE_Q) {
965  		styler.ChangeLexerState(sc.currentPos, styler.Length());
966  	}
967  	sc.Complete();
968  }
969  void SCI_METHOD LexerBash::Fold(Sci_PositionU startPos, Sci_Position length, int, IDocument *pAccess) {
970  	if(!options.fold)
971  		return;
972  	LexAccessor styler(pAccess);
973  	const Sci_PositionU endPos = startPos + length;
974  	int visibleChars = 0;
975  	int skipHereCh = 0;
976  	Sci_Position lineCurrent = styler.GetLine(startPos);
977  	int levelPrev = styler.LevelAt(lineCurrent) &amp; SC_FOLDLEVELNUMBERMASK;
978  	int levelCurrent = levelPrev;
979  	char chNext = styler[startPos];
980  	int styleNext = MaskCommand(styler.StyleIndexAt(startPos));
981  	char word[8] = { &#x27;\0&#x27; }; 
982  	unsigned int wordlen = 0;
983  	for (Sci_PositionU i = startPos; i &lt; endPos; i++) {
984  		const char ch = chNext;
985  		chNext = styler.SafeGetCharAt(i + 1);
986  		const int style = styleNext;
987  		styleNext = MaskCommand(styler.StyleIndexAt(i + 1));
988  		const bool atEOL = (ch == &#x27;\r&#x27; &amp;&amp; chNext != &#x27;\n&#x27;) || (ch == &#x27;\n&#x27;);
989  		if (options.foldComment &amp;&amp; atEOL &amp;&amp; IsCommentLine(lineCurrent, styler))
990  		{
991  			if (!IsCommentLine(lineCurrent - 1, styler)
992  				&amp;&amp; IsCommentLine(lineCurrent + 1, styler))
993  				levelCurrent++;
994  			else if (IsCommentLine(lineCurrent - 1, styler)
995  					 &amp;&amp; !IsCommentLine(lineCurrent + 1, styler))
996  				levelCurrent--;
997  		}
998  		if (style == SCE_SH_WORD) {
999  			if ((wordlen + 1) &lt; sizeof(word))
1000  				word[wordlen++] = ch;
1001  			if (styleNext != style) {
1002  				word[wordlen] = &#x27;\0&#x27;;
1003  				wordlen = 0;
1004  				if (strcmp(word, &quot;if&quot;) == 0 || strcmp(word, &quot;case&quot;) == 0 || strcmp(word, &quot;do&quot;) == 0) {
1005  					levelCurrent++;
1006  				} else if (strcmp(word, &quot;fi&quot;) == 0 || strcmp(word, &quot;esac&quot;) == 0 || strcmp(word, &quot;done&quot;) == 0) {
1007  					levelCurrent--;
1008  				}
1009  			}
1010  		}
1011  		if (style == SCE_SH_OPERATOR) {
1012  			if (ch == &#x27;{&#x27;) {
1013  				levelCurrent++;
1014  			} else if (ch == &#x27;}&#x27;) {
1015  				levelCurrent--;
1016  			}
1017  		}
1018  		if (style == SCE_SH_HERE_DELIM) {
1019  			if (ch == &#x27;&lt;&#x27; &amp;&amp; chNext == &#x27;&lt;&#x27;) {
1020  				if (styler.SafeGetCharAt(i + 2) == &#x27;&lt;&#x27;) {
1021  					skipHereCh = 1;
1022  				} else {
1023  					if (skipHereCh == 0) {
1024  						levelCurrent++;
1025  					} else {
1026  						skipHereCh = 0;
1027  					}
1028  				}
1029  			}
1030  		} else if (style == SCE_SH_HERE_Q &amp;&amp; styler.StyleAt(i+1) == SCE_SH_DEFAULT) {
1031  			levelCurrent--;
1032  		}
1033  		if (atEOL) {
1034  			int lev = levelPrev;
1035  			if (visibleChars == 0 &amp;&amp; options.foldCompact)
1036  				lev |= SC_FOLDLEVELWHITEFLAG;
1037  			if ((levelCurrent &gt; levelPrev) &amp;&amp; (visibleChars &gt; 0))
1038  				lev |= SC_FOLDLEVELHEADERFLAG;
1039  			if (lev != styler.LevelAt(lineCurrent)) {
1040  				styler.SetLevel(lineCurrent, lev);
1041  			}
1042  			lineCurrent++;
1043  			levelPrev = levelCurrent;
1044  			visibleChars = 0;
1045  		}
1046  		if (!isspacechar(ch))
1047  			visibleChars++;
1048  	}
1049  	const int flagsNext = styler.LevelAt(lineCurrent) &amp; ~SC_FOLDLEVELNUMBERMASK;
1050  	styler.SetLevel(lineCurrent, levelPrev | flagsNext);
1051  }
1052  LexerModule lmBash(SCLEX_BASH, LexerBash::LexerFactoryBash, &quot;bash&quot;, bashWordListDesc);
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexBash.cxx</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexBash.cxx</div>
                </div>
                <div class="column column_space"><pre><code>43  enum class TestExprType {
44  	Test,			
45  	DoubleBracket,	
46  	SingleBracket,	
47  };
48  enum class CommandSubstitution {
49  	Backtick,
50  	Inside,
51  	InsideTrack,
52  };
</pre></code></div>
                <div class="column column_space"><pre><code>48  enum class CommandSubstitution {
49  	Backtick,
50  	Inside,
51  	InsideTrack,
52  };
53  enum class QuoteStyle {
54  	Literal,		
55  	CString,		
56  	String,			
57  	LString,		
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    