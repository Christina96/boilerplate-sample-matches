
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 1.3605442176870748%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-cyc.cpp</h3>
            <pre><code>1  #include "cyc.h"
2  TStr TCycVrtx::GetCycVrtxFlagStr(const TCycVrtxFlag& CycVrtxFlag){
3    switch (CycVrtxFlag){
4      case cvfUndef: return "Undef";
5      case cvfNum: return "Num";
6      case cvfStr: return "Str";
7      case cvfCycL: return "CycL";
8      case cvfCycLConst: return "CycLConst"; 
9      case cvfCycLExpr: return "CycLExpr";
10      case cvfCycLPred: return "CycLPred";
11      case cvfBackLink: return "BackLink";
12      case cvfHumanOk: return "HumanOk";
13      case cvfHumanRelevant: return "HumanRelevant";
14      case cfvHumanIrrelevant: return "HumanIrrelevant";
15      case cfvHumanClarifying: return "HumanClarifying";
16      default: Fail; return "";
17    }
18  }
19  TStr TCycVrtx::GetFlagStr() const {
20    TChA ChA;
21    ChA+='[';
22    for (int FlagId=cvfMn; FlagId<cvfMx; FlagId++){
23      if (IsFlag(FlagId)){
24        if (ChA.Len()>1){ChA+=' ';}
25        ChA+=GetCycVrtxFlagStr(TCycVrtxFlag(FlagId));
26      }
27    }
28    ChA+=']';
29    return ChA;
30  }
31  int TCycBs::AddVNm(const TStr& VNm){
32    int VId;
33    if (VNmToVrtxH.IsKey(VNm.CStr(), VId)){
34      return VId;
35    } else {
36      VId=VNmToVrtxH.AddKey(VNm);
37      TCycVrtx& Vrtx=VNmToVrtxH[VId];
38      Vrtx.PutVId(VId);
39      if (VNm.IsPrefix("~")){
40        Vrtx.SetFlag(cvfBackLink);
41      } else
42      if (VNm.IsPrefix("#$")&&(!VNm.IsChIn(' '))){
43        Vrtx.SetFlag(cvfCycL);
44        if (VNm.Len()>2){
45          char Ch=VNm[2];
46          if (('a'<=Ch)&&(Ch<='z')){
47            Vrtx.SetFlag(cvfCycLPred);
48          } else {
49            Vrtx.SetFlag(cvfCycLConst);
50          }
51        }
52      } else
53      if (VNm.IsPrefix("(#$")){
54        Vrtx.SetFlag(cvfCycL);
55        Vrtx.SetFlag(cvfCycLExpr);
56      } else {
57        if (VNm.IsFlt()){
58          Vrtx.SetFlag(cvfNum);
59        } else {
60          Vrtx.SetFlag(cvfStr);
61        }
62      }
63      return VId;
64    }
65  }
66  void TCycBs::GetRelNmV(TStrV& RelNmV){
67    TStrH RelNmH;
68    for (int VId=0; VId<GetVIds(); VId++){
69      TStr VNm=GetVNm(VId);
70      TCycVrtx& Vrtx=GetVrtx(VId);
71      for (int EdgeN=0; EdgeN<Vrtx.GetEdges(); EdgeN++){
72        TCycEdge& Edge=Vrtx.GetEdge(EdgeN);
73        TStr RelNm=GetVNm(Edge.GetRelId());
74        RelNmH.AddKey(RelNm);
75      }
76    }
77    RelNmH.GetKeyV(RelNmV);
78  }
79  TStr TCycBs::GetDocStrFromCycLConstStr(const TStr& CycLConstStr){
80    TChA ChA=CycLConstStr;
81    TChA DstChA;
82    if ((ChA.Len()>2)&&(ChA[0]=='#')&&(ChA[1]=='$')){
83      int ChN=2;
84      while (ChN<ChA.Len()){
85        if (DstChA.Len()>0){DstChA+=' ';}
86        if ((ChA[ChN]=='-')||(ChA[ChN]=='_')||(ChA[ChN]==':')){
87          DstChA+="-"; ChN++;
88        } else
89        if (('0'<=ChA[ChN])&&(ChA[ChN]<='9')){
90          do {
91            DstChA+=ChA[ChN]; ChN++;
92          } while ((ChN<ChA.Len())&&('0'<=ChA[ChN])&&(ChA[ChN]<='9'));
93        } else
94        if (('a'<=ChA[ChN])&&(ChA[ChN]<='z')){
95          do {
96            DstChA+=ChA[ChN]; ChN++;
97          } while ((ChN<ChA.Len())&&('a'<=ChA[ChN])&&(ChA[ChN]<='z'));
98        } else
99        if (('A'<=ChA[ChN])&&(ChA[ChN]<='Z')){
100          if ((ChN+1<ChA.Len())&&('a'<=ChA[ChN+1])&&(ChA[ChN+1]<='z')){
101            do {
102              DstChA+=ChA[ChN]; ChN++;
103            } while ((ChN<ChA.Len())&&('a'<=ChA[ChN])&&(ChA[ChN]<='z'));
104          } else {
105            do {
106              DstChA+=ChA[ChN]; ChN++;
107            } while (((ChN==ChA.Len()-1)&&('A'<=ChA[ChN])&&(ChA[ChN]<='Z'))||
108              ((ChN+1<ChA.Len())&&('A'<=ChA[ChN+1])&&(ChA[ChN+1]<='Z')));
109          }
110        } else {
111          DstChA=""; break;
112        }
113      }
114    } else {
115      DstChA="";
116    }
117    return DstChA;
118  }
119  PLwOnto TCycBs::LoadCycVoc(const TStr& CycBsFNm, const bool& HumanOkOnlyP){
120    printf("Loading Cyc-Base from Binary-File '%s' ... ", CycBsFNm.CStr());
121    PCycBs CycBs=TCycBs::LoadBin(CycBsFNm);
122    int VIds=CycBs->GetVIds();
123    printf("Done.\n");
124    PLwOnto LwOnto=TLwOnto::New();
125    int EnLangId=LwOnto->GetLangBs()->AddLang("EN", "English");
126    PLwTermType C_TermType=TLwTermType::New(0, "Class", EnLangId);
127    PLwTermType L_TermType=TLwTermType::New(1, "Lexical", EnLangId);
128    int C_TermTypeId=LwOnto->GetTermTypeBs()->AddTermType(C_TermType);
129    int L_TermTypeId=LwOnto->GetTermTypeBs()->AddTermType(L_TermType);
130    {printf("Creating link-types ...");
131    TStrV RelNmV; CycBs->GetRelNmV(RelNmV);
132    for (int RelNmN=0; RelNmN<RelNmV.Len(); RelNmN++){
133      TStr RelNm=RelNmV[RelNmN];
134      if (RelNm[0]=='~'){continue;}
135      PLwLinkType LinkType=TLwLinkType::New(RelNmN, RelNm, EnLangId, "");
136      LwOnto->GetLinkTypeBs()->AddLinkType(LinkType);
137    }
138    printf(" Done. (%d)\n", LwOnto->GetLinkTypeBs()->GetLinkTypes());}
139    {printf("Creating terms ...\n");
140    for (int VId=0; VId<VIds; VId++){
141      if (VId%1000==0){printf("%d/%d\r", VId, VIds);}
142      TCycVrtx& Vrtx=CycBs->GetVrtx(VId);
143      if (Vrtx.IsFlag(cvfCycLPred)){continue;}
144      if ((!Vrtx.IsFlag(cvfStr))&&
145       (HumanOkOnlyP&&(!Vrtx.IsFlag(cvfHumanOk)))){continue;}
146      TStr VNm=CycBs->GetVNm(VId);
147      int TermTypeId=(Vrtx.IsFlag(cvfStr)) ? L_TermTypeId : C_TermTypeId;
148      PLwTerm Term=TLwTerm::New(VId, VNm, EnLangId, TermTypeId);
149      LwOnto->GetTermBs()->AddTerm(Term);
150    }
151    printf("Done. (%d)\n", LwOnto->GetTermBs()->GetTerms());}
152    {printf("Creating links ...\n");
153    for (int VId=0; VId<VIds; VId++){
154      if (VId%1000==0){printf("%d/%d\r", VId, VIds);}
155      if (!LwOnto->GetTermBs()->IsTermId(VId)){continue;}
156      TCycVrtx& Vrtx=CycBs->GetVrtx(VId);
157      for (int EdgeN=0; EdgeN<Vrtx.GetEdges(); EdgeN++){
158        TCycEdge& Edge=Vrtx.GetEdge(EdgeN);
159        int DstVId=Edge.GetDstVId();
160        if (!LwOnto->GetTermBs()->IsTermId(DstVId)){continue;}
161        TStr RelNm=CycBs->GetVNm(Edge.GetRelId());
162        if (LwOnto->GetLinkTypeBs()->IsLinkType(RelNm, EnLangId)){
163          int LinkTypeId=LwOnto->GetLinkTypeBs()->GetLinkTypeId(RelNm, EnLangId);
164          LwOnto->GetLinkBs()->AddLink(VId, LinkTypeId, DstVId);
165        }
166      }
167    }
168    printf("Done. (%d)\n", LwOnto->GetLinkBs()->GetLinks());}
169    return LwOnto;
170  }
171  void TCycBs::SaveTxt(const TStr& FNm){
172    TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
173    for (int VId=0; VId<GetVIds(); VId++){
174      TStr VNm=GetVNm(VId);
175      TCycVrtx& Vrtx=GetVrtx(VId);
176      TStr FlagStr=Vrtx.GetFlagStr();
177      fprintf(fOut, "(%d) %s - %s\n", VId, VNm.CStr(), FlagStr.CStr());
178      for (int EdgeN=0; EdgeN<Vrtx.GetEdges(); EdgeN++){
179        TCycEdge& Edge=Vrtx.GetEdge(EdgeN);
180        TStr RelNm=GetVNm(Edge.GetRelId());
181        TStr DstVNm=GetVNm(Edge.GetDstVId());
182        fprintf(fOut, "     %d. [%s] --> %s\n", 1+EdgeN, RelNm.CStr(), DstVNm.CStr());
183      }
184    }
185  }
186  void TCycBs::_SaveTaxonomyTxt(FILE* fOut, 
187   const int& Lev, TIntPrV& RelIdVIdPrV, TIntIntH& VIdToLevH){
188    for (int VidN=0; VidN<RelIdVIdPrV.Len(); VidN++){
189      int FromRelId=RelIdVIdPrV[VidN].Val1;
190      int SrcVId=RelIdVIdPrV[VidN].Val2;
191      TStr SrcVNm=GetVNm(SrcVId);
192      TCycVrtx& SrcVrtx=GetVrtx(SrcVId);
193      if (!SrcVrtx.IsFlag(cvfHumanOk)){continue;}
194      TStr FlagStr=SrcVrtx.GetFlagStr();
195      if (FromRelId==-1){
196        if (Lev>0){fprintf(fOut, "===upper");} else {fprintf(fOut, "===lower");}
197        fprintf(fOut, "=======================================================\n");
198        fprintf(fOut, "%s - %s\n", SrcVNm.CStr(), FlagStr.CStr());
199      } else {
200        TStr FromRelNm=GetVNm(FromRelId);
201        fprintf(fOut, "%*c[%s] --> %s\n", (Lev-1)*5, ' ', FromRelNm.CStr(), SrcVNm.CStr());
202      }
203      TIntPrV UpRelIdVIdPrV;
204      for (int EdgeN=0; EdgeN<SrcVrtx.GetEdges(); EdgeN++){
205        TCycEdge& Edge=SrcVrtx.GetEdge(EdgeN);
206        int RelId=Edge.GetRelId();
207        int DstVId=Edge.GetDstVId();
208        TStr RelNm=GetVNm(RelId);
209        TStr DstVNm=GetVNm(DstVId);
210        if (Lev>0){
211          if ((RelNm=="#$isa")||(RelNm=="#$genls")){
212            if (!VIdToLevH.IsKey(DstVId)){
213              VIdToLevH.AddDat(DstVId, Lev+1);
214              UpRelIdVIdPrV.Add(TIntPr(RelId, DstVId));
215            }
216          }
217        } else {
218          if ((RelNm=="~#$isa")||(RelNm=="~#$genls")){
219            if (!VIdToLevH.IsKey(DstVId)){
220              VIdToLevH.AddDat(DstVId, Lev-1);
221              UpRelIdVIdPrV.Add(TIntPr(RelId, DstVId));
222            }
223          }
224        }
225      } 
226      if (Lev>0){
227        _SaveTaxonomyTxt(fOut, Lev+1, UpRelIdVIdPrV, VIdToLevH);
228      } else {
229        _SaveTaxonomyTxt(fOut, Lev-1, UpRelIdVIdPrV, VIdToLevH);
230      }
231    }
232  }
233  void TCycBs::SaveTaxonomyTxt(const TStr& FNm){
234    TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
235    for (int VId=0; VId<GetVIds(); VId++){
236      printf("%d/%d (%.1f%%)\r", 1+VId, GetVIds(), 100.0*(1+VId)/GetVIds());
237      {int Lev=0;
238      TIntIntH VIdToLevH; VIdToLevH.AddDat(VId, Lev);
239      TIntPrV UpRelIdVIdPrV; UpRelIdVIdPrV.Add(TIntPr(-1, VId));
240      _SaveTaxonomyTxt(fOut, Lev+1, UpRelIdVIdPrV, VIdToLevH);}
241      {int Lev=0;
242      TIntIntH VIdToLevH; VIdToLevH.AddDat(VId, Lev);
243      TIntPrV UpRelIdVIdPrV; UpRelIdVIdPrV.Add(TIntPr(-1, VId));
244      _SaveTaxonomyTxt(fOut, Lev-1, UpRelIdVIdPrV, VIdToLevH);}
245    }
246    printf("\n");
247  }
248  void TCycBs::SaveStatTxt(const TStr& FNm){
249    PMom CommentLenMom=TMom::New();
250    PMom StrsLenMom=TMom::New();
251    PMom HumanOk_StrsLenMom=TMom::New();
252    PMom ClassesPerStrMom=TMom::New();
253    PMom StrsPerClassMom=TMom::New();
254    PMom HumanOk_StrsPerClassMom=TMom::New();
255    PMom IsasPerClassMom=TMom::New();
256    PMom HumanOk_IsasPerClassMom=TMom::New();
257    PMom GenlsPerClassMom=TMom::New();
258    PMom HumanOk_GenlsPerClassMom=TMom::New();
259    PMom IsasGenlsPerClassMom=TMom::New();
260    PMom HumanOk_IsasGenlsPerClassMom=TMom::New();
261    int Classes=0;
262    int HumanOk_Classes=0;
263    int Comments=0;
264    int HumanOk_Comments=0;
265    for (int VId=0; VId<GetVIds(); VId++){
266      TStr VNm=GetVNm(VId);
267      TCycVrtx& Vrtx=GetVrtx(VId);
268      TStr FlagStr=Vrtx.GetFlagStr();
269      int StrsLen=0;
270      int ClassesPerStrInstance=0;
271      int NmStrs=0; int BackLinkNmStrs=0;
272      int Isas=0; int Genls=0;
273      for (int EdgeN=0; EdgeN<Vrtx.GetEdges(); EdgeN++){
274        TCycEdge& Edge=Vrtx.GetEdge(EdgeN);
275        TStr RelNm=GetVNm(Edge.GetRelId());
276        TStr DstVNm=GetVNm(Edge.GetDstVId());
277        TCycVrtx& DstVrtx=GetVrtx(Edge.GetDstVId());
278        if (RelNm=="#$comment"){
279          CommentLenMom->Add(DstVNm.Len());
280          Comments++; 
281          if (Vrtx.IsFlag(cvfHumanOk)){HumanOk_Comments++;}
282        }
283        if (DstVrtx.IsFlag(cvfStr)){StrsLen+=DstVNm.Len();}
284        if (Vrtx.IsFlag(cvfStr)){ClassesPerStrInstance++;}
285        if (RelNm=="#$nameString"){NmStrs++;}
286        if (RelNm=="~#$nameString"){BackLinkNmStrs++;}
287        if (RelNm=="#$isa"){Isas++;}
288        if (RelNm=="#$genls"){Genls++;}
289      }
290      if (Vrtx.IsFlag(cvfCycL)){Classes++;}
291      if (Vrtx.IsFlag(cvfCycL)){StrsLenMom->Add(StrsLen);}
292      if (Vrtx.IsFlag(cvfStr)){ClassesPerStrMom->Add(BackLinkNmStrs);}
293      if (Vrtx.IsFlag(cvfCycL)){StrsPerClassMom->Add(NmStrs);}
294      if (Vrtx.IsFlag(cvfCycL)){IsasPerClassMom->Add(Isas);}
295      if (Vrtx.IsFlag(cvfCycL)){GenlsPerClassMom->Add(Genls);}
296      if (Vrtx.IsFlag(cvfCycL)){IsasGenlsPerClassMom->Add(Isas+Genls);}
297      if (Vrtx.IsFlag(cvfHumanOk)){
298        if (Vrtx.IsFlag(cvfCycL)){HumanOk_Classes++;}
299        if (Vrtx.IsFlag(cvfCycL)){HumanOk_StrsLenMom->Add(StrsLen);}
300        if (Vrtx.IsFlag(cvfCycL)){HumanOk_StrsPerClassMom->Add(NmStrs);}
301        if (Vrtx.IsFlag(cvfCycL)){HumanOk_IsasPerClassMom->Add(Isas);}
302        if (Vrtx.IsFlag(cvfCycL)){HumanOk_GenlsPerClassMom->Add(Genls);}
303        if (Vrtx.IsFlag(cvfCycL)){HumanOk_IsasGenlsPerClassMom->Add(Isas+Genls);}
304      }
305    }
306    CommentLenMom->Def();
307    StrsLenMom->Def();
308    HumanOk_StrsLenMom->Def();
309    ClassesPerStrMom->Def();
310    StrsPerClassMom->Def();
311    HumanOk_StrsPerClassMom->Def();
312    IsasPerClassMom->Def();
313    HumanOk_IsasPerClassMom->Def();
314    GenlsPerClassMom->Def();
315    HumanOk_GenlsPerClassMom->Def();
316    IsasGenlsPerClassMom->Def();
317    HumanOk_IsasGenlsPerClassMom->Def();
318    {TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
319    fprintf(fOut, "CommentLen: %s\n", CommentLenMom->GetStr().CStr());
320    fprintf(fOut, "StrsLen: %s\n", StrsLenMom->GetStr().CStr());
321    fprintf(fOut, "HumanOk_StrsLen: %s\n", HumanOk_StrsLenMom->GetStr().CStr());
322    fprintf(fOut, "ClassesPerStr: %s\n", ClassesPerStrMom->GetStr().CStr());
323    fprintf(fOut, "StrsPerClass: %s\n", StrsPerClassMom->GetStr().CStr());
324    fprintf(fOut, "HumanOk_StrsPerClass: %s\n", HumanOk_StrsPerClassMom->GetStr().CStr());
325    fprintf(fOut, "IsasPerClass: %s\n", IsasPerClassMom->GetStr().CStr());
326    fprintf(fOut, "HumanOk_IsasPerClass: %s\n", HumanOk_IsasPerClassMom->GetStr().CStr());
327    fprintf(fOut, "GenlsPerClass: %s\n", GenlsPerClassMom->GetStr().CStr());
328    fprintf(fOut, "HumanOk_GenlsPerClass: %s\n", HumanOk_GenlsPerClassMom->GetStr().CStr());
329    fprintf(fOut, "IsasGenlsPerClass: %s\n", IsasGenlsPerClassMom->GetStr().CStr());
330    fprintf(fOut, "HumanOk_IsasGenlsPerClass: %s\n", HumanOk_IsasGenlsPerClassMom->GetStr().CStr());
331    fprintf(fOut, "Classes: %d\n", Classes);
332    fprintf(fOut, "HumanOk_Classes: %d\n", HumanOk_Classes);
333    fprintf(fOut, "Comments: %d\n", Comments);
334    fprintf(fOut, "HumanOk_Comments: %d\n", HumanOk_Comments);
335    fprintf(fOut, "End");}
336  }
337  PCycBs TCycBs::LoadCycXmlDump(const TStr& FPath){
338    TStr NrFPath=TStr::GetNrFPath(FPath);
339    TStr CycLexiconFNm=NrFPath+"lexicon-dump.xml";
340    TStr CycTaxonomyFNm=NrFPath+"taxonomy-dump.xml";
341    TStr CycRelevanceFNm=NrFPath+"relevance-dump.xml";
342    TStr CycKBaseFNm=NrFPath+"kb-dump.xml";                                                 
343    PCycBs CycBs=TCycBs::New();
344    {printf("Processing Lexicon %s ...\n", CycLexiconFNm.CStr());
345    PSIn CycLexiconSIn=TFIn::New(CycLexiconFNm);
346    PXmlDoc XmlDoc; int XmlDocs=0;
347    TStr PrevCycWStr; TStr PrevCycLStr;
348    forever{
349      XmlDocs++; if (XmlDocs%1000==0){printf("%d Docs\r", XmlDocs);}
350      XmlDoc=TXmlDoc::LoadTxt(CycLexiconSIn);
351      if (!XmlDoc->IsOk()){
352        printf("%s - %s\n", PrevCycWStr.CStr(), PrevCycLStr.CStr());
353        Fail;
354      }
355      PXmlTok TopTok=XmlDoc->GetTok();
356      if (TopTok->IsTag("end")){break;}
357      IAssert(TopTok->IsTag("word"));
358      TStr CycWStr=TopTok->GetArgVal("string");
359      TStr CycLStr=TopTok->GetArgVal("cycl");
360      PrevCycWStr=CycWStr; PrevCycLStr;
361      CycBs->AddEdge(CycLStr, "#$nameString", CycWStr);
362      CycBs->AddEdge(CycWStr, "~#$nameString", CycLStr);
363    }
364    printf("%d Docs\nDone.\n", XmlDocs);}
365    {printf("Processing Taxonomy %s ...\n", CycTaxonomyFNm.CStr());
366    PSIn CycTaxonomySIn=TFIn::New(CycTaxonomyFNm);
367    PXmlDoc XmlDoc; int XmlDocs=0;
368    TStr PrevSrcCycLStr;
369    forever{
370      XmlDocs++;
371      if (XmlDocs%1000==0){
372        printf("%d Docs\r", XmlDocs);}
373      XmlDoc=TXmlDoc::LoadTxt(CycTaxonomySIn);
374      if (!XmlDoc->IsOk()){
375        printf("%s\n", PrevSrcCycLStr.CStr());
376        Fail;
377      }
378      PXmlTok TopTok=XmlDoc->GetTok();
379      if (TopTok->IsTag("end")){break;}
380      IAssert(TopTok->IsTag("term"));
381      TStr SrcCycLStr=TopTok->GetArgVal("cycl");
382      PrevSrcCycLStr=SrcCycLStr;
383      for (int SubTokN=0; SubTokN<TopTok->GetSubToks(); SubTokN++){
384        PXmlTok SubTok=TopTok->GetSubTok(SubTokN);
385        TStr DstCycLStr=SubTok->GetTagNm();
<span onclick='openModal()' class='match'>386        if (SubTok->IsTag("isa")){
387          DstCycLStr=SubTok->GetArgVal("value");
388          CycBs->AddEdge(SrcCycLStr, "#$isa", DstCycLStr);
389          CycBs->AddEdge(DstCycLStr, "~#$isa", SrcCycLStr);
390        } else
391        if (SubTok->IsTag("genl")){
392          DstCycLStr=SubTok->GetArgVal("value");
393          CycBs->AddEdge(SrcCycLStr, "#$genls", DstCycLStr);
394          CycBs->AddEdge(DstCycLStr, "~#$genls", SrcCycLStr);
395        } else {
</span>396          Fail;
397        }
398      }
399    }
400    printf("%d Docs\nDone.\n", XmlDocs);}
401    {printf("Processing Relevance %s ...\n", CycRelevanceFNm.CStr());
402    PSIn CycRelevanceSIn=TFIn::New(CycRelevanceFNm);
403    PXmlDoc XmlDoc; int XmlDocs=0;
404    TStr PrevCycStr;
405    forever{
406      XmlDocs++;
407      if (XmlDocs%1000==0){
408        printf("%d Docs\r", XmlDocs);}
409      XmlDoc=TXmlDoc::LoadTxt(CycRelevanceSIn);
410      if (!XmlDoc->IsOk()){
411        printf("%s\n", PrevCycStr.CStr());
412        Fail;
413      }
414      PXmlTok TopTok=XmlDoc->GetTok();
415      if (TopTok->IsTag("end")){break;}
416      IAssert(TopTok->IsTag("term"));
417      TStr CycStr=TopTok->GetArgVal("cyc");
418      PrevCycStr=CycStr;
419      if (CycBs->IsVNm(CycStr)){
420        if (TopTok->GetArgVal("thcl")=="T"){
421          CycBs->GetVrtx(CycStr).SetFlag(cvfHumanRelevant, true);}
422        if (TopTok->GetArgVal("irrel")=="T"){
423          CycBs->GetVrtx(CycStr).SetFlag(cfvHumanIrrelevant, true);}
424        if (TopTok->GetArgVal("clarifying")=="T"){
425          CycBs->GetVrtx(CycStr).SetFlag(cfvHumanClarifying, true);}
426        if ((TopTok->GetArgVal("thcl")=="T")||(TopTok->GetArgVal("clarifying")=="T")){
427          CycBs->GetVrtx(CycStr).SetFlag(cvfHumanOk, true);}
428      } else {
429      }
430    }
431    printf("%d Docs\nDone.\n", XmlDocs);}
432    {printf("Processing KBase %s ...\n", CycKBaseFNm.CStr());
433    PSIn CycKBaseSIn=TFIn::New(CycKBaseFNm);
434    PXmlDoc XmlDoc; int XmlDocs=0;
435    TStr PrevCycLStr; TStrV PrevArgCycLStrV;
436    TStrIntH HdCycLToFq;
437    forever{
438      XmlDocs++;
439      if (XmlDocs%1000==0){
440        printf("%d Docs\r", XmlDocs);}
441      XmlDoc=TXmlDoc::LoadTxt(CycKBaseSIn);
442      if (!XmlDoc->IsOk()){
443        printf("%s\n", PrevCycLStr.CStr());
444        for (int ArgN=0; ArgN<PrevArgCycLStrV.Len(); ArgN++){
445          printf(" [%s]", PrevArgCycLStrV[ArgN].CStr());}
446        printf("\n");
447        Fail;
448      }
449      PXmlTok TopTok=XmlDoc->GetTok();
450      if (TopTok->IsTag("end")){break;}
451      IAssert(TopTok->IsTag("sentence"));
452      TStr CycLStr=TopTok->GetArgVal("cycl");
453      TXmlTokV ArgXmlTokV; XmlDoc->GetTagTokV("sentence|arg", ArgXmlTokV);
454      TStrV ArgCycLStrV;
455      for (int ArgN=0; ArgN<ArgXmlTokV.Len(); ArgN++){
456        PXmlTok Tok=ArgXmlTokV[ArgN];
457        IAssert(Tok->IsTag("arg"));
458        if (Tok->IsArg("cycl")){
459          TStr ArgCycLStr=Tok->GetArgVal("cycl");
460          ArgCycLStrV.Add(ArgCycLStr);
461        } else {
462          ArgCycLStrV.Add("Empty");
463        }
464      }
465      PrevCycLStr=CycLStr;
466      PrevArgCycLStrV=ArgCycLStrV;
467      if (ArgCycLStrV.Len()>0){
468        HdCycLToFq.AddDat(ArgCycLStrV[0]+" - "+TInt::GetStr(ArgCycLStrV.Len()-1))++;}
469      if (ArgCycLStrV.Len()==3){
470        TStr PredNm=ArgCycLStrV[0];
471        if ((PredNm!="#$isa")&&(PredNm!="#$termOfUnit")&&(PredNm!="#$genls")){
472          TStr BackLinkPredNm=TStr("~")+PredNm;
473          TStr Arg1=ArgCycLStrV[1];
474          TStr Arg2=ArgCycLStrV[2];
475          CycBs->AddEdge(Arg1, PredNm, Arg2);
476          CycBs->AddEdge(Arg2, BackLinkPredNm, Arg1);
477        }
478      }
479    }
480    {TFOut CycLSOut("CycKB-CycLFq.Stat.Txt"); FILE* fCycL=CycLSOut.GetFileId();
481    TIntStrPrV FqCycLStrPrV; HdCycLToFq.GetDatKeyPrV(FqCycLStrPrV); 
482    FqCycLStrPrV.Sort(false);
483    for (int CycLN=0; CycLN<FqCycLStrPrV.Len(); CycLN++){
484      fprintf(fCycL, "%6d. %s\n", 1+FqCycLStrPrV[CycLN].Val1, FqCycLStrPrV[CycLN].Val2.CStr());
485    }}
486    printf("%d Docs\nDone.\n", XmlDocs);}
487    return CycBs;
488  }
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-hash_12.h</h3>
            <pre><code>1  #ifndef ABSL_HASH_INTERNAL_HASH_H_
2  #define ABSL_HASH_INTERNAL_HASH_H_
3  #include <algorithm>
4  #include <array>
5  #include <bitset>
6  #include <cmath>
7  #include <cstddef>
8  #include <cstring>
9  #include <deque>
10  #include <forward_list>
11  #include <functional>
12  #include <iterator>
13  #include <limits>
14  #include <list>
15  #include <map>
16  #include <memory>
17  #include <set>
18  #include <string>
19  #include <tuple>
20  #include <type_traits>
21  #include <unordered_map>
22  #include <unordered_set>
23  #include <utility>
24  #include <vector>
25  #include "absl/base/config.h"
26  #include "absl/base/internal/unaligned_access.h"
27  #include "absl/base/port.h"
28  #include "absl/container/fixed_array.h"
29  #include "absl/hash/internal/city.h"
30  #include "absl/hash/internal/low_level_hash.h"
31  #include "absl/meta/type_traits.h"
32  #include "absl/numeric/bits.h"
33  #include "absl/numeric/int128.h"
34  #include "absl/strings/string_view.h"
35  #include "absl/types/optional.h"
36  #include "absl/types/variant.h"
37  #include "absl/utility/utility.h"
38  #ifdef ABSL_HAVE_STD_STRING_VIEW
39  #include <string_view>
40  #endif
41  namespace absl {
42  ABSL_NAMESPACE_BEGIN
43  class HashState;
44  namespace hash_internal {
45  constexpr size_t PiecewiseChunkSize() { return 1024; }
46  class PiecewiseCombiner {
47   public:
48    PiecewiseCombiner() : position_(0) {}
49    PiecewiseCombiner(const PiecewiseCombiner&) = delete;
50    PiecewiseCombiner& operator=(const PiecewiseCombiner&) = delete;
51    template <typename H>
52    H add_buffer(H state, const unsigned char* data, size_t size);
53    template <typename H>
54    H add_buffer(H state, const char* data, size_t size) {
55      return add_buffer(std::move(state),
56                        reinterpret_cast<const unsigned char*>(data), size);
57    }
58    template <typename H>
59    H finalize(H state);
60   private:
61    unsigned char buf_[PiecewiseChunkSize()];
62    size_t position_;
63  };
64  template <typename T>
65  struct is_hashable;
66  template <typename H>
67  class HashStateBase {
68   public:
69    template <typename T, typename... Ts>
70    static H combine(H state, const T& value, const Ts&... values);
71    static H combine(H state) { return state; }
72    template <typename T>
73    static H combine_contiguous(H state, const T* data, size_t size);
74    template <typename I>
75    static H combine_unordered(H state, I begin, I end);
76    using AbslInternalPiecewiseCombiner = PiecewiseCombiner;
77    template <typename T>
78    using is_hashable = absl::hash_internal::is_hashable<T>;
79   private:
80    template <typename I>
81    struct CombineUnorderedCallback {
82      I begin;
83      I end;
84      template <typename InnerH, typename ElementStateConsumer>
85      void operator()(InnerH inner_state, ElementStateConsumer cb) {
86        for (; begin != end; ++begin) {
87          inner_state = H::combine(std::move(inner_state), *begin);
88          cb(inner_state);
89        }
90      }
91    };
92  };
93  template <typename T, typename Enable = void>
94  struct is_uniquely_represented : std::false_type {};
95  template <>
96  struct is_uniquely_represented<unsigned char> : std::true_type {};
97  template <typename Integral>
98  struct is_uniquely_represented<
99      Integral, typename std::enable_if<std::is_integral<Integral>::value>::type>
100      : std::true_type {};
101  template <>
102  struct is_uniquely_represented<bool> : std::false_type {};
103  template <typename H, typename T>
104  H hash_bytes(H hash_state, const T& value) {
105    const unsigned char* start = reinterpret_cast<const unsigned char*>(&value);
106    return H::combine_contiguous(std::move(hash_state), start, sizeof(value));
107  }
108  template <typename H, typename B>
109  typename std::enable_if<std::is_same<B, bool>::value, H>::type AbslHashValue(
110      H hash_state, B value) {
111    return H::combine(std::move(hash_state),
112                      static_cast<unsigned char>(value ? 1 : 0));
113  }
114  template <typename H, typename Enum>
115  typename std::enable_if<std::is_enum<Enum>::value, H>::type AbslHashValue(
116      H hash_state, Enum e) {
117    return H::combine(std::move(hash_state),
118                      static_cast<typename std::underlying_type<Enum>::type>(e));
119  }
120  template <typename H, typename Float>
121  typename std::enable_if<std::is_same<Float, float>::value ||
122                              std::is_same<Float, double>::value,
123                          H>::type
124  AbslHashValue(H hash_state, Float value) {
125    return hash_internal::hash_bytes(std::move(hash_state),
126                                     value == 0 ? 0 : value);
127  }
128  template <typename H, typename LongDouble>
129  typename std::enable_if<std::is_same<LongDouble, long double>::value, H>::type
130  AbslHashValue(H hash_state, LongDouble value) {
131    const int category = std::fpclassify(value);
132    switch (category) {
133      case FP_INFINITE:
134        hash_state = H::combine(std::move(hash_state), std::signbit(value));
135        break;
136      case FP_NAN:
137      case FP_ZERO:
138      default:
139        break;
140      case FP_NORMAL:
141      case FP_SUBNORMAL:
142        int exp;
143        auto mantissa = static_cast<double>(std::frexp(value, &exp));
144        hash_state = H::combine(std::move(hash_state), mantissa, exp);
145    }
146    return H::combine(std::move(hash_state), category);
147  }
148  template <typename H, typename T>
149  H AbslHashValue(H hash_state, T* ptr) {
150    auto v = reinterpret_cast<uintptr_t>(ptr);
151    return H::combine(std::move(hash_state), v, v);
152  }
153  template <typename H>
154  H AbslHashValue(H hash_state, std::nullptr_t) {
155    return H::combine(std::move(hash_state), static_cast<void*>(nullptr));
156  }
157  template <typename H, typename T, typename C>
158  H AbslHashValue(H hash_state, T C::*ptr) {
159    auto salient_ptm_size = [](std::size_t n) -> std::size_t {
160  #if defined(_MSC_VER)
161      if (alignof(T C::*) == alignof(int)) {
162        return n;
163      } else {
164        return n == 24 ? 20 : n == 16 ? 12 : n;
165      }
166  #else
167  #ifdef __cpp_lib_has_unique_object_representations
168      static_assert(std::has_unique_object_representations<T C::*>::value);
169  #endif  
170      return n;
171  #endif
172    };
173    return H::combine_contiguous(std::move(hash_state),
174                                 reinterpret_cast<unsigned char*>(&ptr),
175                                 salient_ptm_size(sizeof ptr));
176  }
177  template <typename H, typename T1, typename T2>
178  typename std::enable_if<is_hashable<T1>::value && is_hashable<T2>::value,
179                          H>::type
180  AbslHashValue(H hash_state, const std::pair<T1, T2>& p) {
181    return H::combine(std::move(hash_state), p.first, p.second);
182  }
183  template <typename H, typename Tuple, size_t... Is>
184  H hash_tuple(H hash_state, const Tuple& t, absl::index_sequence<Is...>) {
185    return H::combine(std::move(hash_state), std::get<Is>(t)...);
186  }
187  template <typename H, typename... Ts>
188  #if defined(_MSC_VER)
189  H
190  #else   
191  typename std::enable_if<absl::conjunction<is_hashable<Ts>...>::value, H>::type
192  #endif  
193  AbslHashValue(H hash_state, const std::tuple<Ts...>& t) {
194    return hash_internal::hash_tuple(std::move(hash_state), t,
195                                     absl::make_index_sequence<sizeof...(Ts)>());
196  }
197  template <typename H, typename T, typename D>
198  H AbslHashValue(H hash_state, const std::unique_ptr<T, D>& ptr) {
199    return H::combine(std::move(hash_state), ptr.get());
200  }
201  template <typename H, typename T>
202  H AbslHashValue(H hash_state, const std::shared_ptr<T>& ptr) {
203    return H::combine(std::move(hash_state), ptr.get());
204  }
205  template <typename H>
206  H AbslHashValue(H hash_state, absl::string_view str) {
207    return H::combine(
208        H::combine_contiguous(std::move(hash_state), str.data(), str.size()),
209        str.size());
210  }
211  template <typename Char, typename Alloc, typename H,
212            typename = absl::enable_if_t<std::is_same<Char, wchar_t>::value ||
213                                         std::is_same<Char, char16_t>::value ||
214                                         std::is_same<Char, char32_t>::value>>
215  H AbslHashValue(
216      H hash_state,
217      const std::basic_string<Char, std::char_traits<Char>, Alloc>& str) {
218    return H::combine(
219        H::combine_contiguous(std::move(hash_state), str.data(), str.size()),
220        str.size());
221  }
222  #ifdef ABSL_HAVE_STD_STRING_VIEW
223  template <typename Char, typename H,
224            typename = absl::enable_if_t<std::is_same<Char, wchar_t>::value ||
225                                         std::is_same<Char, char16_t>::value ||
226                                         std::is_same<Char, char32_t>::value>>
227  H AbslHashValue(H hash_state, std::basic_string_view<Char> str) {
228    return H::combine(
229        H::combine_contiguous(std::move(hash_state), str.data(), str.size()),
230        str.size());
231  }
232  #endif  
233  template <typename H, typename T, size_t N>
234  typename std::enable_if<is_hashable<T>::value, H>::type AbslHashValue(
235      H hash_state, const std::array<T, N>& array) {
236    return H::combine_contiguous(std::move(hash_state), array.data(),
237                                 array.size());
238  }
239  template <typename H, typename T, typename Allocator>
240  typename std::enable_if<is_hashable<T>::value, H>::type AbslHashValue(
241      H hash_state, const std::deque<T, Allocator>& deque) {
242    for (const auto& t : deque) {
243      hash_state = H::combine(std::move(hash_state), t);
244    }
245    return H::combine(std::move(hash_state), deque.size());
246  }
247  template <typename H, typename T, typename Allocator>
248  typename std::enable_if<is_hashable<T>::value, H>::type AbslHashValue(
249      H hash_state, const std::forward_list<T, Allocator>& list) {
250    size_t size = 0;
251    for (const T& t : list) {
252      hash_state = H::combine(std::move(hash_state), t);
253      ++size;
254    }
255    return H::combine(std::move(hash_state), size);
256  }
257  template <typename H, typename T, typename Allocator>
258  typename std::enable_if<is_hashable<T>::value, H>::type AbslHashValue(
259      H hash_state, const std::list<T, Allocator>& list) {
260    for (const auto& t : list) {
261      hash_state = H::combine(std::move(hash_state), t);
262    }
263    return H::combine(std::move(hash_state), list.size());
264  }
265  template <typename H, typename T, typename Allocator>
266  typename std::enable_if<is_hashable<T>::value && !std::is_same<T, bool>::value,
267                          H>::type
268  AbslHashValue(H hash_state, const std::vector<T, Allocator>& vector) {
269    return H::combine(H::combine_contiguous(std::move(hash_state), vector.data(),
270                                            vector.size()),
271                      vector.size());
272  }
273  #if defined(ABSL_IS_BIG_ENDIAN) && \
274      (defined(__GLIBCXX__) || defined(__GLIBCPP__))
275  template <typename H, typename T, typename Allocator>
276  typename std::enable_if<is_hashable<T>::value && std::is_same<T, bool>::value,
277                          H>::type
278  AbslHashValue(H hash_state, const std::vector<T, Allocator>& vector) {
279    typename H::AbslInternalPiecewiseCombiner combiner;
280    for (const auto& i : vector) {
281      unsigned char c = static_cast<unsigned char>(i);
282      hash_state = combiner.add_buffer(std::move(hash_state), &c, sizeof(c));
283    }
284    return H::combine(combiner.finalize(std::move(hash_state)), vector.size());
285  }
286  #else
287  template <typename H, typename T, typename Allocator>
288  typename std::enable_if<is_hashable<T>::value && std::is_same<T, bool>::value,
289                          H>::type
290  AbslHashValue(H hash_state, const std::vector<T, Allocator>& vector) {
291    return H::combine(std::move(hash_state),
292                      std::hash<std::vector<T, Allocator>>{}(vector),
293                      vector.size());
294  }
295  #endif
296  template <typename H, typename Key, typename T, typename Compare,
297            typename Allocator>
298  typename std::enable_if<is_hashable<Key>::value && is_hashable<T>::value,
299                          H>::type
300  AbslHashValue(H hash_state, const std::map<Key, T, Compare, Allocator>& map) {
301    for (const auto& t : map) {
302      hash_state = H::combine(std::move(hash_state), t);
303    }
304    return H::combine(std::move(hash_state), map.size());
305  }
306  template <typename H, typename Key, typename T, typename Compare,
307            typename Allocator>
308  typename std::enable_if<is_hashable<Key>::value && is_hashable<T>::value,
309                          H>::type
310  AbslHashValue(H hash_state,
311                const std::multimap<Key, T, Compare, Allocator>& map) {
312    for (const auto& t : map) {
313      hash_state = H::combine(std::move(hash_state), t);
314    }
315    return H::combine(std::move(hash_state), map.size());
316  }
317  template <typename H, typename Key, typename Compare, typename Allocator>
318  typename std::enable_if<is_hashable<Key>::value, H>::type AbslHashValue(
319      H hash_state, const std::set<Key, Compare, Allocator>& set) {
320    for (const auto& t : set) {
321      hash_state = H::combine(std::move(hash_state), t);
322    }
323    return H::combine(std::move(hash_state), set.size());
324  }
325  template <typename H, typename Key, typename Compare, typename Allocator>
326  typename std::enable_if<is_hashable<Key>::value, H>::type AbslHashValue(
327      H hash_state, const std::multiset<Key, Compare, Allocator>& set) {
328    for (const auto& t : set) {
329      hash_state = H::combine(std::move(hash_state), t);
330    }
331    return H::combine(std::move(hash_state), set.size());
332  }
333  template <typename H, typename Key, typename Hash, typename KeyEqual,
334            typename Alloc>
335  typename std::enable_if<is_hashable<Key>::value, H>::type AbslHashValue(
336      H hash_state, const std::unordered_set<Key, Hash, KeyEqual, Alloc>& s) {
337    return H::combine(
338        H::combine_unordered(std::move(hash_state), s.begin(), s.end()),
339        s.size());
340  }
341  template <typename H, typename Key, typename Hash, typename KeyEqual,
342            typename Alloc>
343  typename std::enable_if<is_hashable<Key>::value, H>::type AbslHashValue(
344      H hash_state,
345      const std::unordered_multiset<Key, Hash, KeyEqual, Alloc>& s) {
346    return H::combine(
347        H::combine_unordered(std::move(hash_state), s.begin(), s.end()),
348        s.size());
349  }
350  template <typename H, typename Key, typename T, typename Hash,
351            typename KeyEqual, typename Alloc>
352  typename std::enable_if<is_hashable<Key>::value && is_hashable<T>::value,
353                          H>::type
354  AbslHashValue(H hash_state,
355                const std::unordered_map<Key, T, Hash, KeyEqual, Alloc>& s) {
356    return H::combine(
357        H::combine_unordered(std::move(hash_state), s.begin(), s.end()),
358        s.size());
359  }
360  template <typename H, typename Key, typename T, typename Hash,
361            typename KeyEqual, typename Alloc>
362  typename std::enable_if<is_hashable<Key>::value && is_hashable<T>::value,
363                          H>::type
364  AbslHashValue(H hash_state,
365                const std::unordered_multimap<Key, T, Hash, KeyEqual, Alloc>& s) {
366    return H::combine(
367        H::combine_unordered(std::move(hash_state), s.begin(), s.end()),
368        s.size());
369  }
370  template <typename H, typename T>
371  typename std::enable_if<is_hashable<T>::value, H>::type AbslHashValue(
372      H hash_state, std::reference_wrapper<T> opt) {
373    return H::combine(std::move(hash_state), opt.get());
374  }
375  template <typename H, typename T>
376  typename std::enable_if<is_hashable<T>::value, H>::type AbslHashValue(
377      H hash_state, const absl::optional<T>& opt) {
378    if (opt) hash_state = H::combine(std::move(hash_state), *opt);
379    return H::combine(std::move(hash_state), opt.has_value());
380  }
381  template <typename H>
382  struct VariantVisitor {
383    H&& hash_state;
384    template <typename T>
385    H operator()(const T& t) const {
386      return H::combine(std::move(hash_state), t);
387    }
388  };
389  template <typename H, typename... T>
390  typename std::enable_if<conjunction<is_hashable<T>...>::value, H>::type
391  AbslHashValue(H hash_state, const absl::variant<T...>& v) {
392    if (!v.valueless_by_exception()) {
393      hash_state = absl::visit(VariantVisitor<H>{std::move(hash_state)}, v);
394    }
395    return H::combine(std::move(hash_state), v.index());
396  }
397  #if defined(ABSL_IS_BIG_ENDIAN) && \
398      (defined(__GLIBCXX__) || defined(__GLIBCPP__))
399  template <typename H, size_t N>
400  H AbslHashValue(H hash_state, const std::bitset<N>& set) {
401    typename H::AbslInternalPiecewiseCombiner combiner;
402    for (int i = 0; i < N; i++) {
403      unsigned char c = static_cast<unsigned char>(set[i]);
404      hash_state = combiner.add_buffer(std::move(hash_state), &c, sizeof(c));
405    }
406    return H::combine(combiner.finalize(std::move(hash_state)), N);
407  }
408  #endif
409  template <typename H, typename T>
410  typename std::enable_if<is_uniquely_represented<T>::value, H>::type
411  hash_range_or_bytes(H hash_state, const T* data, size_t size) {
412    const auto* bytes = reinterpret_cast<const unsigned char*>(data);
413    return H::combine_contiguous(std::move(hash_state), bytes, sizeof(T) * size);
414  }
415  template <typename H, typename T>
416  typename std::enable_if<!is_uniquely_represented<T>::value, H>::type
417  hash_range_or_bytes(H hash_state, const T* data, size_t size) {
418    for (const auto end = data + size; data < end; ++data) {
419      hash_state = H::combine(std::move(hash_state), *data);
420    }
421    return hash_state;
422  }
423  #if defined(ABSL_INTERNAL_LEGACY_HASH_NAMESPACE) && \
424      ABSL_META_INTERNAL_STD_HASH_SFINAE_FRIENDLY_
425  #define ABSL_HASH_INTERNAL_SUPPORT_LEGACY_HASH_ 1
426  #else
427  #define ABSL_HASH_INTERNAL_SUPPORT_LEGACY_HASH_ 0
428  #endif
429  struct HashSelect {
430   private:
431    struct State : HashStateBase<State> {
432      static State combine_contiguous(State hash_state, const unsigned char*,
433                                      size_t);
434      using State::HashStateBase::combine_contiguous;
435    };
436    struct UniquelyRepresentedProbe {
437      template <typename H, typename T>
438      static auto Invoke(H state, const T& value)
439          -> absl::enable_if_t<is_uniquely_represented<T>::value, H> {
440        return hash_internal::hash_bytes(std::move(state), value);
441      }
442    };
443    struct HashValueProbe {
444      template <typename H, typename T>
445      static auto Invoke(H state, const T& value) -> absl::enable_if_t<
446          std::is_same<H,
447                       decltype(AbslHashValue(std::move(state), value))>::value,
448          H> {
449        return AbslHashValue(std::move(state), value);
450      }
451    };
452    struct LegacyHashProbe {
453  #if ABSL_HASH_INTERNAL_SUPPORT_LEGACY_HASH_
454      template <typename H, typename T>
455      static auto Invoke(H state, const T& value) -> absl::enable_if_t<
456          std::is_convertible<
457              decltype(ABSL_INTERNAL_LEGACY_HASH_NAMESPACE::hash<T>()(value)),
458              size_t>::value,
459          H> {
460        return hash_internal::hash_bytes(
461            std::move(state),
462            ABSL_INTERNAL_LEGACY_HASH_NAMESPACE::hash<T>{}(value));
463      }
464  #endif  
465    };
466    struct StdHashProbe {
467      template <typename H, typename T>
468      static auto Invoke(H state, const T& value)
469          -> absl::enable_if_t<type_traits_internal::IsHashable<T>::value, H> {
470        return hash_internal::hash_bytes(std::move(state), std::hash<T>{}(value));
471      }
472    };
473    template <typename Hash, typename T>
474    struct Probe : Hash {
475     private:
476      template <typename H, typename = decltype(H::Invoke(
477                                std::declval<State>(), std::declval<const T&>()))>
478      static std::true_type Test(int);
479      template <typename U>
480      static std::false_type Test(char);
481     public:
482      static constexpr bool value = decltype(Test<Hash>(0))::value;
483    };
484   public:
485    template <typename T>
486    using Apply = absl::disjunction<         
487        Probe<UniquelyRepresentedProbe, T>,  
488        Probe<HashValueProbe, T>,            
489        Probe<LegacyHashProbe, T>,           
490        Probe<StdHashProbe, T>,              
491        std::false_type>;
492  };
493  template <typename T>
494  struct is_hashable
495      : std::integral_constant<bool, HashSelect::template Apply<T>::value> {};
496  class ABSL_DLL MixingHashState : public HashStateBase<MixingHashState> {
497  #ifdef ABSL_HAVE_INTRINSIC_INT128
498    using uint128 = __uint128_t;
499  #else   
500    using uint128 = absl::uint128;
501  #endif  
502    static constexpr uint64_t kMul =
503    sizeof(size_t) == 4 ? uint64_t{0xcc9e2d51}
504                        : uint64_t{0x9ddfea08eb382d69};
505    template <typename T>
506    using IntegralFastPath =
507        conjunction<std::is_integral<T>, is_uniquely_represented<T>>;
508   public:
509    MixingHashState(MixingHashState&&) = default;
510    MixingHashState& operator=(MixingHashState&&) = default;
511    static MixingHashState combine_contiguous(MixingHashState hash_state,
512                                              const unsigned char* first,
513                                              size_t size) {
514      return MixingHashState(
515          CombineContiguousImpl(hash_state.state_, first, size,
516                                std::integral_constant<int, sizeof(size_t)>{}));
517    }
518    using MixingHashState::HashStateBase::combine_contiguous;
519    template <typename T, absl::enable_if_t<IntegralFastPath<T>::value, int> = 0>
520    static size_t hash(T value) {
521      return static_cast<size_t>(
522          Mix(Seed(), static_cast<std::make_unsigned_t<T>>(value)));
523    }
524    template <typename T, absl::enable_if_t<!IntegralFastPath<T>::value, int> = 0>
525    static size_t hash(const T& value) {
526      return static_cast<size_t>(combine(MixingHashState{}, value).state_);
527    }
528   private:
529    MixingHashState() : state_(Seed()) {}
530    friend class MixingHashState::HashStateBase;
531    template <typename CombinerT>
532    static MixingHashState RunCombineUnordered(MixingHashState state,
533                                               CombinerT combiner) {
534      uint64_t unordered_state = 0;
535      combiner(MixingHashState{}, [&](MixingHashState& inner_state) {
536        auto element_state = inner_state.state_;
537        unordered_state += element_state;
538        if (unordered_state < element_state) {
539          ++unordered_state;
540        }
541        inner_state = MixingHashState{};
542      });
543      return MixingHashState::combine(std::move(state), unordered_state);
544    }
545    friend class absl::HashState;
546    MixingHashState(const MixingHashState&) = default;
547    explicit MixingHashState(uint64_t state) : state_(state) {}
548    static uint64_t CombineContiguousImpl(uint64_t state,
549                                          const unsigned char* first, size_t len,
550                                          std::integral_constant<int, 4>
551                                          );
552    static uint64_t CombineContiguousImpl(uint64_t state,
553                                          const unsigned char* first, size_t len,
554                                          std::integral_constant<int, 8>
555                                          );
556    static uint64_t CombineLargeContiguousImpl32(uint64_t state,
557                                                 const unsigned char* first,
558                                                 size_t len);
559    static uint64_t CombineLargeContiguousImpl64(uint64_t state,
560                                                 const unsigned char* first,
561                                                 size_t len);
562    static std::pair<uint64_t, uint64_t> Read9To16(const unsigned char* p,
563                                                   size_t len) {
564      uint64_t low_mem = absl::base_internal::UnalignedLoad64(p);
565      uint64_t high_mem = absl::base_internal::UnalignedLoad64(p + len - 8);
566  #ifdef ABSL_IS_LITTLE_ENDIAN
567      uint64_t most_significant = high_mem;
568      uint64_t least_significant = low_mem;
569  #else
570      uint64_t most_significant = low_mem;
571      uint64_t least_significant = high_mem;
572  #endif
573      return {least_significant, most_significant};
574    }
575    static uint64_t Read4To8(const unsigned char* p, size_t len) {
576      uint32_t low_mem = absl::base_internal::UnalignedLoad32(p);
577      uint32_t high_mem = absl::base_internal::UnalignedLoad32(p + len - 4);
578  #ifdef ABSL_IS_LITTLE_ENDIAN
579      uint32_t most_significant = high_mem;
580      uint32_t least_significant = low_mem;
581  #else
582      uint32_t most_significant = low_mem;
583      uint32_t least_significant = high_mem;
584  #endif
585      return (static_cast<uint64_t>(most_significant) << (len - 4) * 8) |
586             least_significant;
587    }
588    static uint32_t Read1To3(const unsigned char* p, size_t len) {
589      unsigned char mem0 = p[0];
590      unsigned char mem1 = p[len / 2];
591      unsigned char mem2 = p[len - 1];
592  #ifdef ABSL_IS_LITTLE_ENDIAN
593      unsigned char significant2 = mem2;
594      unsigned char significant1 = mem1;
595      unsigned char significant0 = mem0;
596  #else
597      unsigned char significant2 = mem0;
598      unsigned char significant1 = len == 2 ? mem0 : mem1;
599      unsigned char significant0 = mem2;
600  #endif
601      return static_cast<uint32_t>(significant0 |                     
602                                   (significant1 << (len / 2 * 8)) |  
603                                   (significant2 << ((len - 1) * 8)));
604    }
605    ABSL_ATTRIBUTE_ALWAYS_INLINE static uint64_t Mix(uint64_t state, uint64_t v) {
606      using MultType =
607          absl::conditional_t<sizeof(size_t) == 4, uint64_t, uint128>;
608      MultType m = state + v;
609      m *= kMul;
610      return static_cast<uint64_t>(m ^ (m >> (sizeof(m) * 8 / 2)));
611    }
612    static uint64_t LowLevelHashImpl(const unsigned char* data, size_t len);
613    ABSL_ATTRIBUTE_ALWAYS_INLINE static uint64_t Hash64(const unsigned char* data,
614                                                        size_t len) {
615  #ifdef ABSL_HAVE_INTRINSIC_INT128
616      return LowLevelHashImpl(data, len);
617  #else
618      return hash_internal::CityHash64(reinterpret_cast<const char*>(data), len);
619  #endif
620    }
621    ABSL_ATTRIBUTE_ALWAYS_INLINE static uint64_t Seed() {
622  #if (!defined(__clang__) || __clang_major__ > 11) && \
623      (!defined(__apple_build_version__) ||            \
624       __apple_build_version__ >= 19558921)  
625      return static_cast<uint64_t>(reinterpret_cast<uintptr_t>(&kSeed));
626  #else
627      return static_cast<uint64_t>(reinterpret_cast<uintptr_t>(kSeed));
628  #endif
629    }
630    static const void* const kSeed;
631    uint64_t state_;
632  };
633  inline uint64_t MixingHashState::CombineContiguousImpl(
634      uint64_t state, const unsigned char* first, size_t len,
635      std::integral_constant<int, 4> &bsol;* sizeof_size_t */) {
636    uint64_t v;
637    if (len > 8) {
638      if (ABSL_PREDICT_FALSE(len > PiecewiseChunkSize())) {
639        return CombineLargeContiguousImpl32(state, first, len);
640      }
641      v = hash_internal::CityHash32(reinterpret_cast<const char*>(first), len);
<span onclick='openModal()' class='match'>642    } else if (len >= 4) {
643      v = Read4To8(first, len);
644    } else if (len > 0) {
645      v = Read1To3(first, len);
646    } else {
</span>647      return state;
648    }
649    return Mix(state, v);
650  }
651  inline uint64_t MixingHashState::CombineContiguousImpl(
652      uint64_t state, const unsigned char* first, size_t len,
653      std::integral_constant<int, 8> &bsol;* sizeof_size_t */) {
654    uint64_t v;
655    if (len > 16) {
656      if (ABSL_PREDICT_FALSE(len > PiecewiseChunkSize())) {
657        return CombineLargeContiguousImpl64(state, first, len);
658      }
659      v = Hash64(first, len);
660    } else if (len > 8) {
661      auto p = Read9To16(first, len);
662      uint64_t lo = p.first;
663      uint64_t hi = p.second;
664      lo = absl::rotr(lo, 53);
665      state += kMul;
666      lo += state;
667      state ^= hi;
668      uint128 m = state;
669      m *= lo;
670      return static_cast<uint64_t>(m ^ (m >> 64));
671    } else if (len >= 4) {
672      v = Read4To8(first, len);
673    } else if (len > 0) {
674      v = Read1To3(first, len);
675    } else {
676      return state;
677    }
678    return Mix(state, v);
679  }
680  struct AggregateBarrier {};
681  struct PoisonedHash : private AggregateBarrier {
682    PoisonedHash() = delete;
683    PoisonedHash(const PoisonedHash&) = delete;
684    PoisonedHash& operator=(const PoisonedHash&) = delete;
685  };
686  template <typename T>
687  struct HashImpl {
688    size_t operator()(const T& value) const {
689      return MixingHashState::hash(value);
690    }
691  };
692  template <typename T>
693  struct Hash
694      : absl::conditional_t<is_hashable<T>::value, HashImpl<T>, PoisonedHash> {};
695  template <typename H>
696  template <typename T, typename... Ts>
697  H HashStateBase<H>::combine(H state, const T& value, const Ts&... values) {
698    return H::combine(hash_internal::HashSelect::template Apply<T>::Invoke(
699                          std::move(state), value),
700                      values...);
701  }
702  template <typename H>
703  template <typename T>
704  H HashStateBase<H>::combine_contiguous(H state, const T* data, size_t size) {
705    return hash_internal::hash_range_or_bytes(std::move(state), data, size);
706  }
707  template <typename H>
708  template <typename I>
709  H HashStateBase<H>::combine_unordered(H state, I begin, I end) {
710    return H::RunCombineUnordered(std::move(state),
711                                  CombineUnorderedCallback<I>{begin, end});
712  }
713  template <typename H>
714  H PiecewiseCombiner::add_buffer(H state, const unsigned char* data,
715                                  size_t size) {
716    if (position_ + size < PiecewiseChunkSize()) {
717      memcpy(buf_ + position_, data, size);
718      position_ += size;
719      return state;
720    }
721    if (position_ != 0) {
722      const size_t bytes_needed = PiecewiseChunkSize() - position_;
723      memcpy(buf_ + position_, data, bytes_needed);
724      state = H::combine_contiguous(std::move(state), buf_, PiecewiseChunkSize());
725      data += bytes_needed;
726      size -= bytes_needed;
727    }
728    while (size >= PiecewiseChunkSize()) {
729      state = H::combine_contiguous(std::move(state), data, PiecewiseChunkSize());
730      data += PiecewiseChunkSize();
731      size -= PiecewiseChunkSize();
732    }
733    memcpy(buf_, data, size);
734    position_ = size;
735    return state;
736  }
737  template <typename H>
738  H PiecewiseCombiner::finalize(H state) {
739    return H::combine_contiguous(std::move(state), buf_, position_);
740  }
741  }  
742  ABSL_NAMESPACE_END
743  }  
744  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-cyc.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-hash_12.h</div>
                </div>
                <div class="column column_space"><pre><code>386        if (SubTok->IsTag("isa")){
387          DstCycLStr=SubTok->GetArgVal("value");
388          CycBs->AddEdge(SrcCycLStr, "#$isa", DstCycLStr);
389          CycBs->AddEdge(DstCycLStr, "~#$isa", SrcCycLStr);
390        } else
391        if (SubTok->IsTag("genl")){
392          DstCycLStr=SubTok->GetArgVal("value");
393          CycBs->AddEdge(SrcCycLStr, "#$genls", DstCycLStr);
394          CycBs->AddEdge(DstCycLStr, "~#$genls", SrcCycLStr);
395        } else {
</pre></code></div>
                <div class="column column_space"><pre><code>642    } else if (len >= 4) {
643      v = Read4To8(first, len);
644    } else if (len > 0) {
645      v = Read1To3(first, len);
646    } else {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    