<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for transport.cpp &amp; datagram-transport.t.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for transport.cpp &amp; datagram-transport.t.cpp
      </h3>
<h1 align="center">
        6.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>transport.cpp (5.504587%)<th>datagram-transport.t.cpp (8.633094%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(53-63)<td><a href="#" name="0">(40-48)</a><td align="center"><font color="#ff0000">12</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>transport.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
/*
 * Copyright (c) 2014-2020,  Regents of the University of California,
 *                           Arizona Board of Regents,
 *                           Colorado State University,
 *                           University Pierre &amp; Marie Curie, Sorbonne University,
 *                           Washington University in St. Louis,
 *                           Beijing Institute of Technology,
 *                           The University of Memphis.
 *
 * This file is part of NFD (Named Data Networking Forwarding Daemon).
 * See AUTHORS.md for complete list of NFD authors and contributors.
 *
 * NFD is free software: you can redistribute it and/or modify it under the terms
 * of the GNU General Public License as published by the Free Software Foundation,
 * either version 3 of the License, or (at your option) any later version.
 *
 * NFD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * NFD, e.g., in COPYING.md file.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

#include "transport.hpp"
#include "face.hpp"

namespace nfd {
namespace face {

NFD_LOG_INIT(Transport);

std::ostream&amp;
operator&lt;&lt;(std::ostream&amp; os, TransportState state)
{
  switch (state) {
  case TransportState::UP:
    return os &lt;&lt; "UP";
  case TransportState::DOWN:
    return os &lt;&lt; "DOWN";
  case TransportState::CLOSING:
    return os &lt;&lt; "CLOSING";
  case TransportState::FAILED:
    return os &lt;&lt; "FAILED";
  case TransportState::CLOSED:
    return os &lt;&lt; "CLOSED";
  default:
    return os &lt;&lt; "NONE";
<a name="0"></a>  }
}

<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>Transport::Transport()
  : m_face(nullptr)
  , m_service(nullptr)
  , m_scope(ndn::nfd::FACE_SCOPE_NONE)
  , m_persistency(ndn::nfd::FACE_PERSISTENCY_NONE)
  , m_linkType(ndn::nfd::LINK_TYPE_NONE)
  , m_mtu(MTU_INVALID)
  , m_sendQueueCapacity(QUEUE_UNSUPPORTED)
  , m_state(TransportState::UP)
  , m_expirationTime(time::steady_clock::TimePoint::max())
{</b></font>
}

Transport::~Transport() = default;

void
Transport::setFaceAndLinkService(Face&amp; face, LinkService&amp; service)
{
  BOOST_ASSERT(m_face == nullptr);
  BOOST_ASSERT(m_service == nullptr);

  m_face = &amp;face;
  m_service = &amp;service;
}

void
Transport::close()
{
  if (m_state != TransportState::UP &amp;&amp; m_state != TransportState::DOWN) {
    return;
  }

  this-&gt;setState(TransportState::CLOSING);
  this-&gt;doClose();
  // warning: don't access any members after this:
  // the Transport may be deallocated if doClose changes state to CLOSED
}

void
Transport::send(const Block&amp; packet)
{
  BOOST_ASSERT(packet.isValid());
  BOOST_ASSERT(this-&gt;getMtu() == MTU_UNLIMITED ||
               packet.size() &lt;= static_cast&lt;size_t&gt;(this-&gt;getMtu()));

  TransportState state = this-&gt;getState();
  if (state != TransportState::UP &amp;&amp; state != TransportState::DOWN) {
    NFD_LOG_FACE_TRACE("send ignored in " &lt;&lt; state &lt;&lt; " state");
    return;
  }

  if (state == TransportState::UP) {
    ++this-&gt;nOutPackets;
    this-&gt;nOutBytes += packet.size();
  }

  this-&gt;doSend(packet);
}

void
Transport::receive(const Block&amp; packet, const EndpointId&amp; endpoint)
{
  BOOST_ASSERT(packet.isValid());
  BOOST_ASSERT(this-&gt;getMtu() == MTU_UNLIMITED ||
               packet.size() &lt;= static_cast&lt;size_t&gt;(this-&gt;getMtu()));

  ++this-&gt;nInPackets;
  this-&gt;nInBytes += packet.size();

  m_service-&gt;receivePacket(packet, endpoint);
}

void
Transport::setMtu(ssize_t mtu)
{
  BOOST_ASSERT(mtu == MTU_UNLIMITED || mtu &gt;= 0);

  if (mtu == m_mtu) {
    return;
  }

  if (m_mtu != MTU_INVALID) {
    NFD_LOG_FACE_INFO("setMtu " &lt;&lt; m_mtu &lt;&lt; " -&gt; " &lt;&lt; mtu);
  }

  m_mtu = mtu;
}

bool
Transport::canChangePersistencyTo(ndn::nfd::FacePersistency newPersistency) const
{
  // not changing, or setting initial persistency in subclass constructor
  if (m_persistency == newPersistency || m_persistency == ndn::nfd::FACE_PERSISTENCY_NONE) {
    return true;
  }

  if (newPersistency == ndn::nfd::FACE_PERSISTENCY_NONE) {
    NFD_LOG_FACE_TRACE("cannot change persistency to NONE");
    return false;
  }

  return this-&gt;canChangePersistencyToImpl(newPersistency);
}

bool
Transport::canChangePersistencyToImpl(ndn::nfd::FacePersistency newPersistency) const
{
  return false;
}

void
Transport::setPersistency(ndn::nfd::FacePersistency newPersistency)
{
  BOOST_ASSERT(canChangePersistencyTo(newPersistency));

  if (m_persistency == newPersistency) {
    return;
  }

  auto oldPersistency = m_persistency;
  m_persistency = newPersistency;

  if (oldPersistency != ndn::nfd::FACE_PERSISTENCY_NONE) {
    NFD_LOG_FACE_INFO("setPersistency " &lt;&lt; oldPersistency &lt;&lt; " -&gt; " &lt;&lt; newPersistency);
    this-&gt;afterChangePersistency(oldPersistency);
  }
}

void
Transport::afterChangePersistency(ndn::nfd::FacePersistency oldPersistency)
{
}

void
Transport::setState(TransportState newState)
{
  if (m_state == newState) {
    return;
  }

  bool isValid = false;
  switch (m_state) {
    case TransportState::UP:
      isValid = newState == TransportState::DOWN ||
                newState == TransportState::CLOSING ||
                newState == TransportState::FAILED;
      break;
    case TransportState::DOWN:
      isValid = newState == TransportState::UP ||
                newState == TransportState::CLOSING ||
                newState == TransportState::FAILED;
      break;
    case TransportState::CLOSING:
    case TransportState::FAILED:
      isValid = newState == TransportState::CLOSED;
      break;
    default:
      break;
  }

  if (!isValid) {
    NDN_THROW(std::runtime_error("Invalid state transition"));
  }

  NFD_LOG_FACE_INFO("setState " &lt;&lt; m_state &lt;&lt; " -&gt; " &lt;&lt; newState);

  TransportState oldState = m_state;
  m_state = newState;
  afterStateChange(oldState, newState);
  // warning: don't access any members after this:
  // the Transport may be deallocated in the signal handler if newState is CLOSED
}

std::ostream&amp;
operator&lt;&lt;(std::ostream&amp; os, const FaceLogHelper&lt;Transport&gt;&amp; flh)
{
  const Transport&amp; transport = flh.obj;
  const Face* face = transport.getFace();
  FaceId faceId = face == nullptr ? INVALID_FACEID : face-&gt;getId();

  os &lt;&lt; "[id=" &lt;&lt; faceId &lt;&lt; ",local=" &lt;&lt; transport.getLocalUri()
     &lt;&lt; ",remote=" &lt;&lt; transport.getRemoteUri() &lt;&lt; "] ";
  return os;
}

} // namespace face
} // namespace nfd
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>datagram-transport.t.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
/*
 * Copyright (c) 2014-2022,  Regents of the University of California,
 *                           Arizona Board of Regents,
 *                           Colorado State University,
 *                           University Pierre &amp; Marie Curie, Sorbonne University,
 *                           Washington University in St. Louis,
 *                           Beijing Institute of Technology,
 *                           The University of Memphis.
 *
 * This file is part of NFD (Named Data Networking Forwarding Daemon).
 * See AUTHORS.md for complete list of NFD authors and contributors.
 *
 * NFD is free software: you can redistribute it and/or modify it under the terms
 * of the GNU General Public License as published by the Free Software Foundation,
 * either version 3 of the License, or (at your option) any later version.
 *
 * NFD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * NFD, e.g., in COPYING.md file.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

#include "unicast-udp-transport-fixture.hpp"
#include "multicast-udp-transport-fixture.hpp"

#include "transport-test-common.hpp"

#include &lt;boost/mpl/vector.hpp&gt;

namespace nfd {
namespace face {
namespace tests {

<a name="0"></a>BOOST_AUTO_TEST_SUITE(Face)
BOOST_AUTO_TEST_SUITE(TestDatagramTransport)

<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>using DatagramTransportFixtures = boost::mpl::vector&lt;
  GENERATE_IP_TRANSPORT_FIXTURE_INSTANTIATIONS(UnicastUdpTransportFixture),
  IpTransportFixture&lt;MulticastUdpTransportFixture, AddressFamily::V4, AddressScope::Global, MulticastInterface::Yes&gt;,
  IpTransportFixture&lt;MulticastUdpTransportFixture, AddressFamily::V6, AddressScope::LinkLocal, MulticastInterface::Yes&gt;,
  IpTransportFixture&lt;MulticastUdpTransportFixture, AddressFamily::V6, AddressScope::Global, MulticastInterface::Yes&gt;
&gt;;

BOOST_FIXTURE_TEST_CASE_TEMPLATE(Send, T, DatagramTransportFixtures, T)
{</b></font>
  TRANSPORT_TEST_INIT();

  auto block1 = ndn::encoding::makeStringBlock(300, "hello");
  this-&gt;transport-&gt;send(block1);
  BOOST_CHECK_EQUAL(this-&gt;transport-&gt;getCounters().nOutPackets, 1);
  BOOST_CHECK_EQUAL(this-&gt;transport-&gt;getCounters().nOutBytes, block1.size());

  std::vector&lt;uint8_t&gt; readBuf(block1.size());
  this-&gt;remoteRead(readBuf);

  BOOST_CHECK_EQUAL_COLLECTIONS(readBuf.begin(), readBuf.end(), block1.begin(), block1.end());
  BOOST_CHECK_EQUAL(this-&gt;transport-&gt;getState(), TransportState::UP);
}

BOOST_FIXTURE_TEST_CASE_TEMPLATE(ReceiveNormal, T, DatagramTransportFixtures, T)
{
  TRANSPORT_TEST_INIT();

  auto pkt1 = ndn::encoding::makeStringBlock(300, "hello");
  ndn::Buffer buf1(pkt1.begin(), pkt1.end());
  this-&gt;remoteWrite(buf1);

  BOOST_CHECK_EQUAL(this-&gt;transport-&gt;getCounters().nInPackets, 1);
  BOOST_CHECK_EQUAL(this-&gt;transport-&gt;getCounters().nInBytes, pkt1.size());

  auto pkt2 = ndn::encoding::makeStringBlock(301, "world!");
  ndn::Buffer buf2(pkt2.begin(), pkt2.end());
  this-&gt;remoteWrite(buf2);

  BOOST_CHECK_EQUAL(this-&gt;transport-&gt;getCounters().nInPackets, 2);
  BOOST_CHECK_EQUAL(this-&gt;transport-&gt;getCounters().nInBytes, pkt1.size() + pkt2.size());
  BOOST_CHECK_EQUAL(this-&gt;transport-&gt;getState(), TransportState::UP);

  BOOST_REQUIRE_EQUAL(this-&gt;receivedPackets-&gt;size(), 2);
  BOOST_CHECK(this-&gt;receivedPackets-&gt;at(0).packet == pkt1);
  BOOST_CHECK(this-&gt;receivedPackets-&gt;at(1).packet == pkt2);
  BOOST_CHECK_EQUAL(this-&gt;receivedPackets-&gt;at(0).endpoint,
                    this-&gt;receivedPackets-&gt;at(1).endpoint);
}

BOOST_FIXTURE_TEST_CASE_TEMPLATE(ReceiveIncomplete, T, DatagramTransportFixtures, T)
{
  TRANSPORT_TEST_INIT();

  this-&gt;remoteWrite({0x05, 0x03, 0x00, 0x01});

  BOOST_CHECK_EQUAL(this-&gt;transport-&gt;getCounters().nInPackets, 0);
  BOOST_CHECK_EQUAL(this-&gt;transport-&gt;getCounters().nInBytes, 0);
  BOOST_CHECK_EQUAL(this-&gt;receivedPackets-&gt;size(), 0);
  BOOST_CHECK_EQUAL(this-&gt;transport-&gt;getState(), TransportState::UP);
}

BOOST_FIXTURE_TEST_CASE_TEMPLATE(ReceiveTrailingGarbage, T, DatagramTransportFixtures, T)
{
  TRANSPORT_TEST_INIT();

  auto pkt1 = ndn::encoding::makeStringBlock(300, "hello");
  auto pkt2 = ndn::encoding::makeStringBlock(301, "world");
  ndn::Buffer buf(pkt1.size() + pkt2.size());
  std::copy(pkt1.begin(), pkt1.end(), buf.begin());
  std::copy(pkt2.begin(), pkt2.end(), buf.begin() + pkt1.size());

  this-&gt;remoteWrite(buf);

  BOOST_CHECK_EQUAL(this-&gt;transport-&gt;getCounters().nInPackets, 0);
  BOOST_CHECK_EQUAL(this-&gt;transport-&gt;getCounters().nInBytes, 0);
  BOOST_CHECK_EQUAL(this-&gt;receivedPackets-&gt;size(), 0);
  BOOST_CHECK_EQUAL(this-&gt;transport-&gt;getState(), TransportState::UP);
}

BOOST_FIXTURE_TEST_CASE_TEMPLATE(ReceiveTooLarge, T, DatagramTransportFixtures, T)
{
  TRANSPORT_TEST_INIT();

  const std::vector&lt;uint8_t&gt; bytes(ndn::MAX_NDN_PACKET_SIZE, 0);
  auto pkt1 = ndn::encoding::makeBinaryBlock(300, ndn::make_span(bytes).subspan(6));
  ndn::Buffer buf1(pkt1.begin(), pkt1.end());
  BOOST_REQUIRE_EQUAL(buf1.size(), ndn::MAX_NDN_PACKET_SIZE);

  auto pkt2 = ndn::encoding::makeBinaryBlock(301, bytes);
  ndn::Buffer buf2(pkt2.begin(), pkt2.end());
  BOOST_REQUIRE_GT(buf2.size(), ndn::MAX_NDN_PACKET_SIZE);

  this-&gt;remoteWrite(buf1); // this should succeed

  BOOST_CHECK_EQUAL(this-&gt;transport-&gt;getCounters().nInPackets, 1);
  BOOST_CHECK_EQUAL(this-&gt;transport-&gt;getCounters().nInBytes, buf1.size());
  BOOST_CHECK_EQUAL(this-&gt;receivedPackets-&gt;size(), 1);
  BOOST_CHECK_EQUAL(this-&gt;transport-&gt;getState(), TransportState::UP);

  this-&gt;remoteWrite(buf2, false); // this should fail

  BOOST_CHECK_EQUAL(this-&gt;transport-&gt;getCounters().nInPackets, 1);
  BOOST_CHECK_EQUAL(this-&gt;transport-&gt;getCounters().nInBytes, buf1.size());
  BOOST_CHECK_EQUAL(this-&gt;receivedPackets-&gt;size(), 1);
  BOOST_CHECK_EQUAL(this-&gt;transport-&gt;getState(), TransportState::UP);
}

BOOST_FIXTURE_TEST_CASE_TEMPLATE(Close, T, DatagramTransportFixtures, T)
{
  TRANSPORT_TEST_INIT();

  this-&gt;transport-&gt;afterStateChange.connectSingleShot([] (auto oldState, auto newState) {
    BOOST_CHECK_EQUAL(oldState, TransportState::UP);
    BOOST_CHECK_EQUAL(newState, TransportState::CLOSING);
  });

  this-&gt;transport-&gt;close();

  this-&gt;transport-&gt;afterStateChange.connectSingleShot([this] (auto oldState, auto newState) {
    BOOST_CHECK_EQUAL(oldState, TransportState::CLOSING);
    BOOST_CHECK_EQUAL(newState, TransportState::CLOSED);
    this-&gt;limitedIo.afterOp();
  });

  BOOST_REQUIRE_EQUAL(this-&gt;limitedIo.run(1, 1_s), LimitedIo::EXCEED_OPS);
}

BOOST_FIXTURE_TEST_CASE_TEMPLATE(SendQueueLength, T, DatagramTransportFixtures, T)
{
  TRANSPORT_TEST_INIT();

  BOOST_CHECK_EQUAL(this-&gt;transport-&gt;getSendQueueLength(), 0);
}

BOOST_AUTO_TEST_SUITE_END() // TestDatagramTransport
BOOST_AUTO_TEST_SUITE_END() // Face

} // namespace tests
} // namespace face
} // namespace nfd
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
