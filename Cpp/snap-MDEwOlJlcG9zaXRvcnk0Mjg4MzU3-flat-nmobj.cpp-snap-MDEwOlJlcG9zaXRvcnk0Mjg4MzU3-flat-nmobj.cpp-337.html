
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 26, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-nmobj.cpp</h3>
            <pre><code>1  #include &quot;nmobj.h&quot;
2  TNmObjBs::TNmObjBs(
3   const TSwSetType&amp; SwSetType, const PSIn&amp; CustSwSetSIn,
4   const PSIn&amp; NrWordBsSIn, const PSIn&amp; WordTypeBsSIn, const TStr&amp; MteFNm):
5    ChDef(),
6    WordStrToNrH(),
7    WordStrVToNmObjAttrSetH(),
8    NmObjWordStrVToNrH(),
9    NmObjWordStrVToDocIdVH(),
10    DocNmToNmObjDocH(){
11    ChDef=THtmlLxChDef::GetChDef();
12    SwSet=TSwSet::GetSwSet(SwSetType);
13    LoadCustSwSet(CustSwSetSIn);
14    LoadNrWordBs(NrWordBsSIn);
15    LoadNmObjTypeBs(WordTypeBsSIn);
16    if (!MteFNm.Empty()){
17      }
18  }
19  TStr TNmObjBs::PeriodTagStr=&quot;&lt;.&gt;&quot;;
20  TStr TNmObjBs::BreakTagStr=&quot;&lt;br&gt;&quot;;
21  TStr TNmObjBs::ParagraphTagStr=&quot;&lt;p&gt;&quot;;
22  TStr TNmObjBs::EofTagStr=&quot;&lt;eof&gt;&quot;;
23  void TNmObjBs::LoadCustSwSet(const PSIn&amp; SIn){
24    if (SIn.Empty()){return;}
25    TILx Lx(SIn, TFSet(iloCmtAlw, iloRetEoln, iloExcept));
26    Lx.GetSym(syLn, syEof);
27    while (Lx.Sym!=syEof){
28      TStr WordStrVStr=Lx.Str;
29      TStrV WordStrV; WordStrVStr.SplitOnWs(WordStrV);
30      if (!WordStrV.Empty()){
31        WordStrVToNmObjAttrSetH.AddDat(WordStrV).Incl(noaIgnore);
32      }
33      Lx.GetSym(syLn, syEof);
34    }
35  }
36  void TNmObjBs::LoadNrWordBs(const PSIn&amp; SIn){
37    if (SIn.Empty()){return;}
38    TILx Lx(SIn, TFSet(iloCmtAlw, iloRetEoln, iloExcept));
39    Lx.GetSym(syQStr, syEoln, syEof);
40    while (Lx.Sym!=syEof){
41      if (Lx.Sym==syQStr){
42        TStr NrWordStr=Lx.Str;
43        Lx.GetSym(syColon);
44        Lx.GetSym(syQStr, syEoln);
45        while (Lx.Sym!=syEoln){
46          TStr WordStr=Lx.Str;
47          if (WordStrToNrH.IsKey(WordStr)){
48            printf(&quot;Word already normalized (%s)&quot;, WordStr.CStr());}
49          WordStrToNrH.AddDat(WordStr, NrWordStr);
50          Lx.GetSym(syQStr, syEoln);
51        }
52        Lx.GetSym(syQStr, syEoln, syEof);
53      } else
54      if (Lx.Sym==syEoln){
55        Lx.GetSym(syQStr, syEoln, syEof);
56      } else {
57        Fail;
58      }
59    }
60  }
61  TStr TNmObjBs::GetNrWordStr(const TStr&amp; _WordStr) const {
62    TStr WordStr=_WordStr;
63    if (WordStr.IsChIn(&#x27;_&#x27;)){
64      WordStr.ChangeChAll(&#x27;_&#x27;, &#x27;$&#x27;);
65    }
66    TStr NrWordStr;
67    if (WordStrToNrH.IsKeyGetDat(WordStr, NrWordStr)){
68      return NrWordStr;
69    } else
70    if (MteLex.Empty()){
71      return WordStr;
72    } else {
73      TStr UcWordStr=ChDef-&gt;GetUcStr(WordStr); 
74      TStr NrUcWordStr;
75      if (MteLex-&gt;IsInfWord(UcWordStr, NrUcWordStr)){
76        if (UcWordStr==NrUcWordStr){
77          return WordStr;
78        } else
79        if (IsAllCapWordStr(WordStr)){
80          return NrUcWordStr;
81        } else
82        if (IsFirstCapWordStr(WordStr)){
83          TChA NrWordChA(NrUcWordStr);
84          ChDef-&gt;GetLcChA(NrWordChA);
85          if (NrWordChA.Len()&gt;0){
86            NrWordChA.PutCh(0, ChDef-&gt;GetUc(NrWordChA[0]));}
87          return NrWordChA;
88        } else {
89          TStr NrLcWordStr=ChDef-&gt;GetLcStr(NrUcWordStr);
90          return NrLcWordStr;
91        }
92      } else {
93        return WordStr;
94      }
95    }
96  }
97  TNmObjAttr TNmObjBs::GetNmObjTypeFromStr(const TStr&amp; Str){
98    if (Str==&quot;Ignore&quot;){return noaIgnore;}
99    if (Str==&quot;Standalone&quot;){return noaStandalone;}
100    if (Str==&quot;AsCapitalized&quot;){return noaAsCapitalized;}
101    if (Str==&quot;Unperiod&quot;){return noaUnperiod;}
102    if (Str==&quot;Acronym&quot;){return noaAcronym;}
103    if (Str==&quot;FirstName&quot;){return noaFirstName;}
104    if (Str==&quot;Person&quot;){return noaPerson;}
105    if (Str==&quot;Company&quot;){return noaCompany;}
106    if (Str==&quot;Organization&quot;){return noaOrganization;}
107    if (Str==&quot;Country&quot;){return noaCountry;}
108    if (Str==&quot;Geography&quot;){return noaGeography;}
109    TExcept::Throw(&quot;Invalid Named-Object name.&quot;, Str);
110    return noaIgnore;
111  }
112  void TNmObjBs::LoadNmObjTypeBs(const PSIn&amp; SIn){
113    if (SIn.Empty()){return;}
114    TILx Lx(SIn, TFSet(iloCmtAlw, iloRetEoln, iloExcept));
115    Lx.GetSym(syQStr, syIdStr, syEoln, syEof);
116    while (Lx.Sym!=syEof){
117      if ((Lx.Sym==syQStr)||(Lx.Sym==syIdStr)){
118        TVec&lt;TStrV&gt; NmObjWordStrVV;
119        TB32Set NmObjAttrSet;
120        while ((Lx.Sym==syQStr)||(Lx.Sym==syIdStr)){
121          if (Lx.Sym==syQStr){
122            TStr WordStrVStr=Lx.Str;
123            TStrV WordStrV; WordStrVStr.SplitOnWs(WordStrV);
124            NmObjWordStrVV.Add(WordStrV);
125          } else
126          if (Lx.Sym==syIdStr){
127            TNmObjAttr NmObjAttr=TNmObjBs::GetNmObjTypeFromStr(Lx.Str);
128            NmObjAttrSet.Incl(NmObjAttr);
129          } else {
130            Fail;
131          }
132          Lx.GetSym(syQStr, syIdStr, syEoln, syEof);
133        }
134        if (!NmObjAttrSet.In(noaIgnore)){
135          NmObjAttrSet.Incl(noaDefined);}
136        for (int NmObjN=0; NmObjN&lt;NmObjWordStrVV.Len(); NmObjN++){
137          WordStrVToNmObjAttrSetH.AddDat(NmObjWordStrVV[NmObjN])|=NmObjAttrSet;
138        }
139        {for (int NmObjN=1; NmObjN&lt;NmObjWordStrVV.Len(); NmObjN++){
140          NmObjWordStrVToNrH.AddDat(NmObjWordStrVV[NmObjN], NmObjWordStrVV[0]);
141        }}
142      } else
143      if (Lx.Sym==syEoln){
144        Lx.GetSym(syQStr, syEoln, syEof);
145      } else {
146        Fail;
147      }
148    }
149  }
150  bool TNmObjBs::IsNmObjAttr(const TStr&amp; WordStr, const TNmObjAttr&amp; NmObjAttr) const {
151    TStrV WordStrV; WordStrV.Add(WordStr);
152    return IsNmObjAttr(WordStrV, NmObjAttr);
153  }
154  bool TNmObjBs::IsNmObjAttr(const TStrV&amp; WordStrV, const TNmObjAttr&amp; NmObjAttr) const {
155    int WordStrVToNmObjAttrSetP=WordStrVToNmObjAttrSetH.GetKeyId(WordStrV);
156    if (WordStrVToNmObjAttrSetP==-1){return false;}
157    else {return WordStrVToNmObjAttrSetH[WordStrVToNmObjAttrSetP].In(NmObjAttr);}
158  }
159  bool TNmObjBs::IsFirstCapWordStr(const TStr&amp; Str) const {
160    if (Str.Empty()){return false;}
161    char FirstCh=Str[0];
162    if (!ChDef-&gt;IsAlpha(FirstCh)){return false;}
163    if (!ChDef-&gt;IsUc(FirstCh)){return false;}
164    return true;
165  }
166  bool TNmObjBs::IsAllCapWordStr(const TStr&amp; Str) const {
167    TChA ChA=Str;
168    for (int ChN=0; ChN&lt;ChA.Len(); ChN++){
169      if (!ChDef-&gt;IsUc(ChA[ChN])){return false;}
170    }
171    return true;
172  }
173  bool TNmObjBs::IsNumStr(const TStr&amp; Str) const {
174    if (Str.Empty()){return false;}
175    char FirstCh=Str[0];
176    if (!ChDef-&gt;IsNum(FirstCh)){return false;}
177    return true;
178  }
179  bool TNmObjBs::IsTagStr(const TStr&amp; Str) const {
180    return (!Str.Empty())&amp;&amp;(Str[0]==&#x27;&lt;&#x27;);
181  }
182  bool TNmObjBs::IsMatchPfx(
183   const TStr&amp; Str1, const TStr&amp; Str2,
184   const int&amp; MnPfxLen, const int&amp; MxSfxLen) const {
185    TChA ChA1=Str1; TChA ChA2=Str2;
186    int ChN=0;
187    forever {
188      if (ChN&gt;=ChA1.Len()){break;}
189      if (ChN&gt;=ChA2.Len()){break;}
190      if (ChA1[ChN]!=ChA2[ChN]){break;}
191      ChN++;
192    }
193    if (ChN+1&lt;=MnPfxLen){return false;}
194    if (ChA1.Len()-ChN+1&gt;MxSfxLen){return false;}
195    if (ChA2.Len()-ChN+1&gt;MxSfxLen){return false;}
196    return true;
197  }
198  int TNmObjBs::GetNmObjId(const TStrV&amp; WordStrV, const bool&amp; DefP){
199    int NmObjId=-1;
200    if (DefP){
201      NmObjId=NmObjWordStrVToDocIdVH.AddKey(WordStrV);
202    } else {
203      NmObjId=NmObjWordStrVToDocIdVH.GetKeyId(WordStrV);
204    }
205    return NmObjId;
206  }
207  TStr TNmObjBs::GetWordStrVStr(const TStrV&amp; WordStrV, const char&amp; SepCh) const {
208    TChA WordChA;
209    for (int WordStrN=0; WordStrN&lt;WordStrV.Len(); WordStrN++){
210      if (WordStrN&gt;0){WordChA+=SepCh;}
211      WordChA+=WordStrV[WordStrN];
212    }
213    return WordChA;
214  }
215  void TNmObjBs::GetNrNmObjStrV(const TStrV&amp; NmObjStrV, TStrV&amp; NrNmObjStrV) const {
216    int NmObjWordStrVToNrP=NmObjWordStrVToNrH.GetKeyId(NmObjStrV);
217    if (NmObjWordStrVToNrP==-1){NrNmObjStrV=NmObjStrV;}
218    else {NrNmObjStrV=NmObjWordStrVToNrH[NmObjWordStrVToNrP];}
219  }
220  void TNmObjBs::ExtrCandWordStrV(
221   const TStr&amp; HtmlStr, TStrV&amp; CandWordStrV, const bool&amp; DumpP){
222    CandWordStrV.Clr();
223    PSIn HtmlSIn=TStrIn::New(HtmlStr);
224    PHtmlDoc HtmlDoc=THtmlDoc::New(HtmlSIn, hdtAll, false);
225    PHtmlTok Tok;
226    THtmlLxSym Sym; TStr Str; TStr NrStr;
227    CandWordStrV.Add(PeriodTagStr);
228    bool InTitle=false; bool InScript=false; int LastNmObjTokN=-1;
229    if (DumpP){printf(&quot;Tokens: &quot;);}
230    for (int TokN=0; TokN&lt;HtmlDoc-&gt;GetToks(); TokN++){
231      PHtmlTok Tok=HtmlDoc-&gt;GetTok(TokN);
232      HtmlDoc-&gt;GetTok(TokN, Sym, Str);
233      switch (Sym){
234        case hsyUndef: break;
235        case hsyStr:
236        case hsyNum:
237          if (InTitle){break;}
238          if (InScript){break;}
239          NrStr=GetNrWordStr(Str);
240          if (DumpP){
241            if (Str==NrStr){printf(&quot;%s &quot;, Str.CStr());}
242            else {printf(&quot;%s(%s) &quot;, Str.CStr(), NrStr.CStr());}
243          }
244          if (IsFirstCapWordStr(NrStr)||IsNmObjAttr(NrStr, noaAsCapitalized)){
245            if ((LastNmObjTokN!=-1)&amp;&amp;(LastNmObjTokN&lt;TokN-1)){
246              if (CandWordStrV.Last()!=PeriodTagStr){
247                CandWordStrV.Add(BreakTagStr);
248              }
249            }
250            CandWordStrV.Add(NrStr); LastNmObjTokN=TokN;
251          }
252          break;
253        case hsySSym:
254          if (InTitle){break;}
255          if (InScript){break;}
256          if (DumpP){
257            printf(&quot;%s &quot;, Str.CStr());}
258          if (
259           (Str==&quot;.&quot;)||(Str==&quot;!&quot;)||(Str==&quot;?&quot;)||
260           (Str==&quot;\&quot;&quot;)||(Str==&quot;-&quot;)||(Str==&quot;/&quot;)||
261           (Str==&quot;:&quot;)||(Str==&quot;;&quot;)){
262            if (CandWordStrV.Last()!=PeriodTagStr){
263              CandWordStrV.Add(PeriodTagStr);
264            }
265          }
266          break;
267        case hsyBTag:
268        case hsyETag:
269          if (Str==&quot;&lt;TITLE&gt;&quot;){
270            InTitle=(Sym==hsyBTag);
271          } else
272          if (Str==&quot;&lt;SCRIPT&gt;&quot;){
273            InScript=(Sym==hsyBTag);
274          } else
275          if (Str==&quot;&lt;P&gt;&quot;){
276            if ((!CandWordStrV.Empty())&amp;&amp;(CandWordStrV.Last()!=ParagraphTagStr)){
277              CandWordStrV.Add(ParagraphTagStr);
278              CandWordStrV.Add(PeriodTagStr);
279            }
280          } else
281          if ((Str==&quot;&lt;TD&gt;&quot;)||(Str==&quot;&lt;BR&gt;&quot;)){
282            CandWordStrV.Add(PeriodTagStr);
283          }
284          break;
285        case hsyEof: break;
286        default: break;
287      }
288    }
289    CandWordStrV.Add(EofTagStr);
290    if (DumpP){printf(&quot;\n&quot;);}
291    if (DumpP){
292      printf(&quot;Candidates: &quot;);
293      for (int CandWordStrN=0; CandWordStrN&lt;CandWordStrV.Len(); CandWordStrN++){
294        printf(&quot;%s &quot;, CandWordStrV[CandWordStrN].CStr());}
295      printf(&quot;\n&quot;);
296    }
297  }
298  void TNmObjBs::FilterCandToNmObjIdV(
299   const TStrV&amp; CandWordStrV, TIntV&amp; NmObjIdV, const bool&amp; DumpP){
300    TVec&lt;TStrV&gt; NmObjIdWordStrVV;
301    int CandWordStrN=0; int CandWordStrs=CandWordStrV.Len();
302    while (CandWordStrN&lt;CandWordStrs){
303      TStr WordStr=CandWordStrV[CandWordStrN];
304      if (WordStr.Len()&lt;=1){CandWordStrN++; continue;}
305      if (WordStr==ParagraphTagStr){CandWordStrN++; continue;}
306      if (WordStr==BreakTagStr){CandWordStrN++; continue;}
307      if (WordStr==EofTagStr){CandWordStrN++; break;}
308      if (IsNumStr(WordStr)){CandWordStrN++; continue;}
309      TStr UcWordStr=ChDef-&gt;GetUcStr(WordStr);
310      if ((WordStr==UcWordStr)&amp;&amp;((WordStr.Len()&gt;4)&amp;&amp;(!IsNmObjAttr(WordStr, noaAcronym)))){
311        CandWordStrN++; continue;}
312      if (IsNmObjAttr(WordStr, noaUnperiod)&amp;&amp;(CandWordStrV[CandWordStrN+1]==PeriodTagStr)){
313        CandWordStrN+=1;
314      }
315      if (WordStr==PeriodTagStr){
316        CandWordStrN++; WordStr=CandWordStrV[CandWordStrN];
317        if (IsTagStr(WordStr)){continue;}
318        if (IsNmObjAttr(WordStr, noaDefined)){
319          continue;
320        } else 
321        if ((CandWordStrN&gt;1)&amp;&amp;(IsNmObjAttr(CandWordStrV[CandWordStrN-2], noaUnperiod))){
322          continue;
323        } else {
324          TStr NextWordStr=CandWordStrV[CandWordStrN+1];
325          if (IsFirstCapWordStr(NextWordStr)||IsNmObjAttr(NextWordStr, noaAsCapitalized)){
326            continue;
327          } else 
328          if (!IsNmObj(WordStr)){
329            CandWordStrN++; continue;
330          }
331        }
332      }
333      if (IsNmObjAttr(WordStr, noaIgnore)){
334        CandWordStrN++; continue;
335      } 
336      TStrV WordStrV;
337      forever {
338        WordStrV.Add(WordStr);
339        CandWordStrN++; WordStr=CandWordStrV[CandWordStrN];
340        if (IsTagStr(WordStr)){break;}
341        if (WordStr.Len()&lt;=1){break;}
342        if (IsNmObjAttr(WordStr, noaIgnore)){CandWordStrN++; break;}
343        if (IsNmObjAttr(WordStr, noaStandalone)){break;}
344        if (IsNmObjAttr(WordStrV, noaStandalone)){break;}
345      }
346      TStrV NrWordStrV; GetNrNmObjStrV(WordStrV, NrWordStrV);
347      if (IsNmObjAttr(NrWordStrV, noaIgnore)){continue;}
348      if (IsNmObjAttr(NrWordStrV, noaFirstName)){continue;}
349      if (NrWordStrV.Len()&gt;5){
350        while (NrWordStrV.Len()&gt;2){NrWordStrV.Del(0);}}
351      if (NrWordStrV.Len()==1){
352        TStr UcWordStr=ChDef-&gt;GetUcStr(NrWordStrV[0]);
353        if (SwSet-&gt;IsIn(UcWordStr, true)){continue;}
354      }
355      NmObjIdWordStrVV.Add(NrWordStrV);
356    }
357    for (int NmObjN=0; NmObjN&lt;NmObjIdWordStrVV.Len(); NmObjN++){
358      TStrV&amp; WordStrV=NmObjIdWordStrVV[NmObjN];
359      if (WordStrV.Len()==1){
360        for (int SubNmObjN=0; SubNmObjN&lt;NmObjIdWordStrVV.Len(); SubNmObjN++){
361          TStrV&amp; SubWordStrV=NmObjIdWordStrVV[SubNmObjN];
362          if (SubWordStrV.Len()==1){
363            if (WordStrV[0]!=SubWordStrV[0]){
364              if (IsMatchPfx(WordStrV[0], SubWordStrV[0], 3, 4)){
365                if (WordStrV[0].Len()&lt;SubWordStrV[0].Len()){SubWordStrV=WordStrV;}
366                else {WordStrV=SubWordStrV;}
367              }
368            }
369          }
370        }
371      } else
372      if (WordStrV.Len()&gt;=2){
373        TStr LastNm=WordStrV.Last();
374        for (int SubNmObjN=0; SubNmObjN&lt;NmObjIdWordStrVV.Len(); SubNmObjN++){
375          TStrV&amp; SubWordStrV=NmObjIdWordStrVV[SubNmObjN];
376          if (SubWordStrV.Len()==1){
377            TStr SubLastNm=SubWordStrV[0];
378            if (LastNm!=SubLastNm){
379              if (IsMatchPfx(LastNm, SubLastNm, 3, 4)){
380                if (LastNm.Len()&lt;SubLastNm.Len()){SubWordStrV=WordStrV;} 
381                else {WordStrV=SubWordStrV;}
382              }
383            }
384          } else
385          if (false&amp;&amp;(SubWordStrV.Len()==2)){
386            if ((WordStrV[0]!=SubWordStrV[0])||(WordStrV[1]!=SubWordStrV[1])){
387              if ((IsMatchPfx(WordStrV[0], SubWordStrV[0], 3, 4))&amp;&amp;
388               (IsMatchPfx(WordStrV[1], SubWordStrV[1], 3, 4))){
389                if (WordStrV[0].Len()&lt;SubWordStrV[0].Len()){
390                  SubWordStrV[0]=WordStrV[0];}
391                else {WordStrV[0]=SubWordStrV[0];}
392                if (WordStrV[1].Len()&lt;SubWordStrV[1].Len()){
393                  SubWordStrV[1]=WordStrV[1];}
394                else {WordStrV[1]=SubWordStrV[1];}
395              }
396            }
397          }
398        }
399      }
400    }
401    NmObjIdV.Gen(NmObjIdWordStrVV.Len(), 0);
402    {for (int NmObjN=0; NmObjN&lt;NmObjIdWordStrVV.Len(); NmObjN++){
403      TStrV&amp; NmObjWordStrV=NmObjIdWordStrVV[NmObjN];
404      int NmObjId=GetNmObjId(NmObjWordStrV, true);
405      NmObjIdV.Add(NmObjId);
406    }}
407    if (DumpP){
408      printf(&quot;Named-Objects: &quot;);
409      for (int NmObjN=0; NmObjN&lt;NmObjIdV.Len(); NmObjN++){
410        int NmObjId=NmObjIdV[NmObjN];
411        TStr NmObjStr=GetNmObjStr(NmObjId);
412        printf(&quot;%s &quot;, NmObjStr.CStr());
413      }
414      printf(&quot;\n&quot;);
415    }
416  }
417  PNmObjBs TNmObjBs::GetFromStrQuV(
418   const TStrQuV&amp; IdTitleSrcHtmlQuV,
419   const TSwSetType&amp; SwSetType, const TStr&amp; CustSwSetFNm,
420   const TStr&amp; NrWordBsFNm, const TStr&amp; WordTypeBsFNm, const TStr&amp; MteFNm,
421   const int&amp; MxDocs, const bool&amp; DumpP){
422    PSIn CustSwSetSIn;
423    if (!CustSwSetFNm.Empty()&amp;&amp;(TFile::Exists(CustSwSetFNm))){
424      CustSwSetSIn=TFIn::New(CustSwSetFNm);}
425    PSIn NrWordBsSIn;
426    if (!NrWordBsFNm.Empty()&amp;&amp;(TFile::Exists(NrWordBsFNm))){
427      NrWordBsSIn=TFIn::New(NrWordBsFNm);}
428    PSIn WordTypeBsSIn;
429    if (!WordTypeBsFNm.Empty()&amp;&amp;(TFile::Exists(WordTypeBsFNm))){
430      WordTypeBsSIn=TFIn::New(WordTypeBsFNm);}
431    PNmObjBs NmObjBs=
432     TNmObjBs::New(SwSetType, CustSwSetSIn, NrWordBsSIn, WordTypeBsSIn, MteFNm);
433    for (int DocN=0; DocN&lt;IdTitleSrcHtmlQuV.Len(); DocN++){
434      if ((MxDocs!=-1)&amp;&amp;(DocN&gt;MxDocs)){break;}
435      TStr DocNm=IdTitleSrcHtmlQuV[DocN].Val1;
436      TStr TitleStr=IdTitleSrcHtmlQuV[DocN].Val2;
437      TStr HtmlStr=IdTitleSrcHtmlQuV[DocN].Val4;
438      if (DumpP){
439        printf(&quot;===============================================\n&quot;);
440        printf(&quot;%s\n&quot;, DocNm.CStr());
441      }
442      TStrV CandWordStrV; NmObjBs-&gt;ExtrCandWordStrV(HtmlStr, CandWordStrV, DumpP);
443      TIntV NmObjIdV; NmObjBs-&gt;FilterCandToNmObjIdV(CandWordStrV, NmObjIdV, DumpP);
444      NmObjBs-&gt;AddDoc(DocNm, &quot;&quot;, NmObjIdV);
445    }
446    TIntV NewNmObjIdV; NmObjBs-&gt;GetMergedNmObj(NewNmObjIdV);
447    NmObjBs-&gt;PutMergedNmObj(NewNmObjIdV);
448    return NmObjBs;
449  }
450  PNmObjBs TNmObjBs::GetFromCpd(
451   const PSIn&amp; _CpdSIn,
452   const TSwSetType&amp; SwSetType, const PSIn&amp; CustSwSetSIn,
453   const PSIn&amp; NrWordBsSIn, const PSIn&amp; WordTypeBsSIn, const TStr&amp; MteFNm,
454   const int&amp; MxDocs, const bool&amp; DumpP){
455    PNmObjBs NmObjBs=
456     TNmObjBs::New(SwSetType, CustSwSetSIn, NrWordBsSIn, WordTypeBsSIn, MteFNm);
457    PSIn CpdSIn=TCpDoc::FFirstCpd(_CpdSIn); PCpDoc CpDoc; int Docs=0;
458    while (TCpDoc::FNextCpd(CpdSIn, CpDoc)){
459      if ((MxDocs!=-1)&amp;&amp;(Docs&gt;MxDocs)){break;}
460      TStr DocNm=CpDoc-&gt;GetDocNm();
461      TStr DateStr=CpDoc-&gt;GetDateStr();
462      TStr HtmlStr=CpDoc-&gt;GetTxtStr();
463      Docs++; printf(&quot;%d %s\r&quot;, Docs, DocNm.CStr());
464      if (DumpP){
465        printf(&quot;===============================================\n&quot;);
466        printf(&quot;%s\n&quot;, DocNm.CStr());
467      }
468      TStrV CandWordStrV; NmObjBs-&gt;ExtrCandWordStrV(HtmlStr, CandWordStrV, DumpP);
469      TIntV NmObjIdV; NmObjBs-&gt;FilterCandToNmObjIdV(CandWordStrV, NmObjIdV, DumpP);
470      NmObjBs-&gt;AddDoc(DocNm, DateStr, NmObjIdV);
471    }
472    TIntV NewNmObjIdV; NmObjBs-&gt;GetMergedNmObj(NewNmObjIdV);
473    NmObjBs-&gt;PutMergedNmObj(NewNmObjIdV);
474    return NmObjBs;
475  }
476  PNmObjBs TNmObjBs::GetFromCpd(
477   const TStr&amp; CpdFNm,
478   const TSwSetType&amp; SwSetType, const TStr&amp; CustSwSetFNm,
479   const TStr&amp; NrWordBsFNm, const TStr&amp; WordTypeBsFNm, const TStr&amp; MteFNm,
480   const int&amp; MxDocs, const bool&amp; DumpP){
481    PSIn CpdSIn=TFIn::New(CpdFNm);
482    PSIn CustSwSetSIn;
483    if (!CustSwSetFNm.Empty()&amp;&amp;(TFile::Exists(CustSwSetFNm))){
484      CustSwSetSIn=TFIn::New(CustSwSetFNm);}
485    PSIn NrWordBsSIn;
486    if (!NrWordBsFNm.Empty()&amp;&amp;(TFile::Exists(NrWordBsFNm))){
487      NrWordBsSIn=TFIn::New(NrWordBsFNm);}
488    PSIn WordTypeBsSIn;
489    if (!WordTypeBsFNm.Empty()&amp;&amp;(TFile::Exists(WordTypeBsFNm))){
490      WordTypeBsSIn=TFIn::New(WordTypeBsFNm);}
491    return TNmObjBs::GetFromCpd(
492     CpdSIn, SwSetType, CustSwSetSIn, NrWordBsSIn, WordTypeBsSIn, MteFNm,
493     MxDocs, DumpP);
494  }
495  void TNmObjBs::GetMergedNmObj(TIntV&amp; NewNmObjIdV){
496    int MnPfxLen=3; int MxSfxLen=2;
497    int NmObjs=NmObjWordStrVToDocIdVH.Len();
498    NewNmObjIdV.Gen(NmObjs); NewNmObjIdV.PutAll(-1);
499    {int SingleWords=0; int ReducedSingleWords=0;
500    TStrIntVH PfxStrToNmObjIdVH;
501    for (int NmObjId=0; NmObjId&lt;NmObjs; NmObjId++){
502      if (NewNmObjIdV[NmObjId]!=-1){continue;}
503      const TStrV&amp; WordStrV=NmObjWordStrVToDocIdVH.GetKey(NmObjId);
504      if (WordStrV.Len()==1){
505        TStr PfxStr=WordStrV[0].GetSubStr(0, 2);
506        PfxStrToNmObjIdVH.AddDat(PfxStr).Add(NmObjId);
507        SingleWords++;
508      }
509    }
510    int Pfxs=PfxStrToNmObjIdVH.Len();
511    for (int PfxId=0; PfxId&lt;Pfxs; PfxId++){
512      TIntV&amp; NmObjIdV=PfxStrToNmObjIdVH[PfxId];
513      for (int NmObjIdN=0; NmObjIdN&lt;NmObjIdV.Len(); NmObjIdN++){
514        int NmObjId=NmObjIdV[NmObjIdN];
515        if (NewNmObjIdV[NmObjId]!=-1){continue;}
516        NewNmObjIdV[NmObjId]=NmObjId;
517        const TStr&amp; WordStr=NmObjWordStrVToDocIdVH.GetKey(NmObjId)[0];
518        int Fq=NmObjWordStrVToDocIdVH[NmObjId].Len();
519        TIntPrV FqNmObjIdPrV(NmObjIdV.Len(), 0);
520        FqNmObjIdPrV.Add(TIntPr(Fq, NmObjId));
521        for (int SubNmObjIdN=NmObjIdN+1; SubNmObjIdN&lt;NmObjIdV.Len(); SubNmObjIdN++){
522          int SubNmObjId=NmObjIdV[SubNmObjIdN];
523          if (NewNmObjIdV[SubNmObjId]!=-1){continue;}
524          const TStr&amp; SubWordStr=NmObjWordStrVToDocIdVH.GetKey(SubNmObjId)[0];
525          if (IsMatchPfx(WordStr, SubWordStr, MnPfxLen, MxSfxLen)){
526            NewNmObjIdV[SubNmObjId]=NmObjId;
527            int SubFq=NmObjWordStrVToDocIdVH[SubNmObjId].Len();
528            FqNmObjIdPrV.Add(TIntPr(SubFq, SubNmObjId));
529          }
530        }
531        ReducedSingleWords++;
532        if (FqNmObjIdPrV.Len()&gt;1){
533          FqNmObjIdPrV.Sort(false);
534          int MainNmObjId=FqNmObjIdPrV[0].Val2;
535          NewNmObjIdV[MainNmObjId]=MainNmObjId;
536          TStr MainWordStr=NmObjWordStrVToDocIdVH.GetKey(MainNmObjId)[0];
537          for (int FqNmObjIdPrN=1; FqNmObjIdPrN&lt;FqNmObjIdPrV.Len(); FqNmObjIdPrN++){
538            int SubNmObjId=FqNmObjIdPrV[FqNmObjIdPrN].Val2;
539            NewNmObjIdV[SubNmObjId]=MainNmObjId;
540          }
541        }
542      }
543    }
544    }
545    {int DoubleWords=0; int ReducedDoubleWords=0;
546    TStrIntVH PfxStrToNmObjIdVH;
547    for (int NmObjId=0; NmObjId&lt;NmObjs; NmObjId++){
548      if (NewNmObjIdV[NmObjId]!=-1){continue;}
549      const TStrV&amp; WordStrV=NmObjWordStrVToDocIdVH.GetKey(NmObjId);
550      if (WordStrV.Len()==2){
551        TStr PfxStr=WordStrV[0].GetSubStr(0, 2)+WordStrV[1].GetSubStr(0, 2);
552        PfxStrToNmObjIdVH.AddDat(PfxStr).Add(NmObjId);
553        DoubleWords++;
554      }
555    }
556    int Pfxs=PfxStrToNmObjIdVH.Len();
557    for (int PfxId=0; PfxId&lt;Pfxs; PfxId++){
558      TIntV&amp; NmObjIdV=PfxStrToNmObjIdVH[PfxId];
559      for (int NmObjIdN=0; NmObjIdN&lt;NmObjIdV.Len(); NmObjIdN++){
560        int NmObjId=NmObjIdV[NmObjIdN];
561        if (NewNmObjIdV[NmObjId]!=-1){continue;}
562        NewNmObjIdV[NmObjId]=NmObjId;
563        const TStr&amp; WordStr1=NmObjWordStrVToDocIdVH.GetKey(NmObjId)[0];
564        const TStr&amp; WordStr2=NmObjWordStrVToDocIdVH.GetKey(NmObjId)[1];
565        int Fq=NmObjWordStrVToDocIdVH[NmObjId].Len();
566        TIntPrV FqNmObjIdPrV(NmObjIdV.Len(), 0);
567        FqNmObjIdPrV.Add(TIntPr(Fq, NmObjId));
568        for (int SubNmObjIdN=NmObjIdN+1; SubNmObjIdN&lt;NmObjIdV.Len(); SubNmObjIdN++){
569          int SubNmObjId=NmObjIdV[SubNmObjIdN];
570          if (NewNmObjIdV[SubNmObjId]!=-1){continue;}
571          const TStr&amp; SubWordStr1=NmObjWordStrVToDocIdVH.GetKey(SubNmObjId)[0];
572          const TStr&amp; SubWordStr2=NmObjWordStrVToDocIdVH.GetKey(SubNmObjId)[1];
573          if (IsMatchPfx(WordStr1, SubWordStr1, MnPfxLen, MxSfxLen+1)&amp;&amp;
574           IsMatchPfx(WordStr2, SubWordStr2, MnPfxLen, MxSfxLen+1)){
575            NewNmObjIdV[SubNmObjId]=NmObjId;
576            int SubFq=NmObjWordStrVToDocIdVH[SubNmObjId].Len();
577            FqNmObjIdPrV.Add(TIntPr(SubFq, SubNmObjId));
578          }
579        }
580        ReducedDoubleWords++;
581        if (FqNmObjIdPrV.Len()&gt;1){
582          FqNmObjIdPrV.Sort(false);
583          int MainNmObjId=FqNmObjIdPrV[0].Val2;
584          NewNmObjIdV[MainNmObjId]=MainNmObjId;
585          TStr MainWordStr1=NmObjWordStrVToDocIdVH.GetKey(MainNmObjId)[0];
586          TStr MainWordStr2=NmObjWordStrVToDocIdVH.GetKey(MainNmObjId)[1];
587          for (int FqNmObjIdPrN=1; FqNmObjIdPrN&lt;FqNmObjIdPrV.Len(); FqNmObjIdPrN++){
588            int SubNmObjId=FqNmObjIdPrV[FqNmObjIdPrN].Val2;
589            NewNmObjIdV[SubNmObjId]=MainNmObjId;
590          }
591        }
592      }
593    }
594    }
595    {int TripleWords=0; int ReducedTripleWords=0;
596    TStrIntVH PfxStrToNmObjIdVH;
597    for (int NmObjId=0; NmObjId&lt;NmObjs; NmObjId++){
598      if (NewNmObjIdV[NmObjId]!=-1){continue;}
599      const TStrV&amp; WordStrV=NmObjWordStrVToDocIdVH.GetKey(NmObjId);
600      if (WordStrV.Len()==3){
601        TripleWords++;
602        TStrV DbWordStrV(2, 0);
603        DbWordStrV.Add(WordStrV[1]); DbWordStrV.Add(WordStrV[2]);
604        int DbNmObjId=NmObjWordStrVToDocIdVH.GetKeyId(DbWordStrV);
605        if (DbNmObjId!=-1){
606          ReducedTripleWords++;
607          int NewDbNmObjId=NewNmObjIdV[DbNmObjId];
608          NewNmObjIdV[NmObjId]=NewDbNmObjId;
609        }
610      }
611    }
612    }
613    {int TripleWords=0; int ReducedTripleWords=0;
614    TStrIntVH PfxStrToNmObjIdVH;
615    for (int NmObjId=0; NmObjId&lt;NmObjs; NmObjId++){
616      if (NewNmObjIdV[NmObjId]!=-1){continue;}
617      const TStrV&amp; WordStrV=NmObjWordStrVToDocIdVH.GetKey(NmObjId);
618      if (WordStrV.Len()==3){
619        TStr PfxStr=WordStrV[0].GetSubStr(0, 2)+WordStrV[1].GetSubStr(0, 2)+WordStrV[2].GetSubStr(0, 2);
620        PfxStrToNmObjIdVH.AddDat(PfxStr).Add(NmObjId);
621        TripleWords++;
622      }
623    }
624    int Pfxs=PfxStrToNmObjIdVH.Len();
625    for (int PfxId=0; PfxId&lt;Pfxs; PfxId++){
626      TIntV&amp; NmObjIdV=PfxStrToNmObjIdVH[PfxId];
627      for (int NmObjIdN=0; NmObjIdN&lt;NmObjIdV.Len(); NmObjIdN++){
628        int NmObjId=NmObjIdV[NmObjIdN];
629        if (NewNmObjIdV[NmObjId]!=-1){continue;}
630        NewNmObjIdV[NmObjId]=NmObjId;
631        const TStr&amp; WordStr1=NmObjWordStrVToDocIdVH.GetKey(NmObjId)[0];
632        const TStr&amp; WordStr2=NmObjWordStrVToDocIdVH.GetKey(NmObjId)[1];
633        const TStr&amp; WordStr3=NmObjWordStrVToDocIdVH.GetKey(NmObjId)[2];
634        int Fq=NmObjWordStrVToDocIdVH[NmObjId].Len();
635        TIntPrV FqNmObjIdPrV(NmObjIdV.Len(), 0);
636        FqNmObjIdPrV.Add(TIntPr(Fq, NmObjId));
637        for (int SubNmObjIdN=NmObjIdN+1; SubNmObjIdN&lt;NmObjIdV.Len(); SubNmObjIdN++){
638          int SubNmObjId=NmObjIdV[SubNmObjIdN];
639          if (NewNmObjIdV[SubNmObjId]!=-1){continue;}
640          const TStr&amp; SubWordStr1=NmObjWordStrVToDocIdVH.GetKey(SubNmObjId)[0];
641          const TStr&amp; SubWordStr2=NmObjWordStrVToDocIdVH.GetKey(SubNmObjId)[1];
642          const TStr&amp; SubWordStr3=NmObjWordStrVToDocIdVH.GetKey(SubNmObjId)[2];
643          if (IsMatchPfx(WordStr1, SubWordStr1, MnPfxLen, MxSfxLen+1)&amp;&amp;
644           IsMatchPfx(WordStr2, SubWordStr2, MnPfxLen, MxSfxLen+1)&amp;&amp;
645           IsMatchPfx(WordStr3, SubWordStr3, MnPfxLen, MxSfxLen+1)){
646            NewNmObjIdV[SubNmObjId]=NmObjId;
647            int SubFq=NmObjWordStrVToDocIdVH[SubNmObjId].Len();
648            FqNmObjIdPrV.Add(TIntPr(SubFq, SubNmObjId));
649          }
650        }
651        ReducedTripleWords++;
652        if (FqNmObjIdPrV.Len()&gt;1){
653          FqNmObjIdPrV.Sort(false);
654          int MainNmObjId=FqNmObjIdPrV[0].Val2;
655          NewNmObjIdV[MainNmObjId]=MainNmObjId;
656          TStr MainWordStr1=NmObjWordStrVToDocIdVH.GetKey(MainNmObjId)[0];
657          TStr MainWordStr2=NmObjWordStrVToDocIdVH.GetKey(MainNmObjId)[1];
658          TStr MainWordStr3=NmObjWordStrVToDocIdVH.GetKey(MainNmObjId)[2];
659          for (int FqNmObjIdPrN=1; FqNmObjIdPrN&lt;FqNmObjIdPrV.Len(); FqNmObjIdPrN++){
660            int SubNmObjId=FqNmObjIdPrV[FqNmObjIdPrN].Val2;
661            NewNmObjIdV[SubNmObjId]=MainNmObjId;
662          }
663        }
664      }
665    }
666    }
667  }
668  void TNmObjBs::PutMergedNmObj(const TIntV&amp; NewNmObjIdV){
669    TStrVIntVH NewNmObjWordStrVToDocIdVH;
670    for (int NmObjId=0; NmObjId&lt;NewNmObjIdV.Len(); NmObjId++){
671      if (NewNmObjIdV[NmObjId]!=NmObjId){continue;}
672      const TStrV&amp; WordStrV=NmObjWordStrVToDocIdVH.GetKey(NmObjId);
673      NewNmObjWordStrVToDocIdVH.AddDat(WordStrV);
674    }
675    {for (int NmObjId=0; NmObjId&lt;NewNmObjIdV.Len(); NmObjId++){
676      if (NewNmObjIdV[NmObjId]==NmObjId){continue;}
677      const TStrV&amp; WordStrV=NmObjWordStrVToDocIdVH.GetKey(NmObjId);
678      int NrNmObjId=NewNmObjIdV[NmObjId];
679      if (NrNmObjId!=-1){
680        const TStrV&amp; NrWordStrV=NmObjWordStrVToDocIdVH.GetKey(NrNmObjId);
681        NmObjWordStrVToNrH.AddDat(WordStrV, NrWordStrV);
682      }
683    }}
684    int Docs=GetDocs();
685    for (int DocId=0; DocId&lt;Docs; DocId++){
686      TIntPrV&amp; NmObjIdFqPrV=GetDoc_NmObjIdFqPrV(DocId);
687      TIntIntH NewNmObjIdToFqH(NmObjIdFqPrV.Len());
688      for (int NmObjN=0; NmObjN&lt;NmObjIdFqPrV.Len(); NmObjN++){
689        int NmObjId=NmObjIdFqPrV[NmObjN].Val1;
690        int Fq=NmObjIdFqPrV[NmObjN].Val2;
691        int NrNmObjId=NewNmObjIdV[NmObjId];
692        if (NrNmObjId!=-1){
693          const TStrV&amp; NrWordStrV=NmObjWordStrVToDocIdVH.GetKey(NrNmObjId);
694          int NewNmObjId=NewNmObjWordStrVToDocIdVH.GetKeyId(NrWordStrV);
695          NewNmObjIdToFqH.AddDat(NewNmObjId)+=Fq;
696        }
697      }
698      NmObjIdFqPrV.Gen(NewNmObjIdToFqH.Len(), 0);
699      for (int NmObjP=0; NmObjP&lt;NewNmObjIdToFqH.Len(); NmObjP++){
700        int NewNmObjId=NewNmObjIdToFqH.GetKey(NmObjP);
701        int Fq=NewNmObjIdToFqH[NmObjP];
702        NmObjIdFqPrV.Add(TIntPr(NewNmObjId, Fq));
703        NewNmObjWordStrVToDocIdVH[NewNmObjId].Add(DocId);
704      }
705      NmObjIdFqPrV.Sort();
706    }
707    NmObjWordStrVToDocIdVH=NewNmObjWordStrVToDocIdVH;
708  }
709  void TNmObjBs::GetNmObjStrFqPrV(TStrIntPrV&amp; NmObjStrFqPrV, const int&amp; MnFq) const {
710    int NmObjs=GetNmObjs();
711    NmObjStrFqPrV.Gen(NmObjs, 0);
712    for (int NmObjId=0; NmObjId&lt;NmObjs; NmObjId++){
713      TStrIntPr NmObjStrFqPr;
714      NmObjStrFqPr.Val1=GetNmObjStr(NmObjId);
715      NmObjStrFqPr.Val2=GetNmObjDocs(NmObjId);
716      if (NmObjStrFqPr.Val2&gt;=MnFq){
717        NmObjStrFqPrV.Add(NmObjStrFqPr);}
718    }
719  }
720  void TNmObjBs::GetNmObjFqStrPrV(TIntStrPrV&amp; NmObjFqStrPrV, const int&amp; MnFq) const {
721    int NmObjs=GetNmObjs();
722    NmObjFqStrPrV.Gen(NmObjs, 0);
723    for (int NmObjId=0; NmObjId&lt;NmObjs; NmObjId++){
724      TIntStrPr NmObjFqStrPr;
725      NmObjFqStrPr.Val1=GetNmObjDocs(NmObjId);
726      NmObjFqStrPr.Val2=GetNmObjStr(NmObjId);
727      if (NmObjFqStrPr.Val1&gt;=MnFq){
728        NmObjFqStrPrV.Add(NmObjFqStrPr);}
729    }
730  }
731  void TNmObjBs::GetNmObjDIdV(
732   const PBowDocBs&amp; BowDocBs, TIntV&amp; BowDIdV, 
733   const TStr&amp; NmObjStr1, const TStr&amp; NmObjStr2) const {
734    int NmObjId1=GetNmObjId(NmObjStr1);
735    TIntV NmObjDocIdV1; GetNmObjDocIdV(NmObjId1, NmObjDocIdV1);
736    NmObjDocIdV1.Sort();
737    TIntV NmObjDocIdV2;
738    if (!NmObjStr2.Empty()){
739      int NmObjId2=GetNmObjId(NmObjStr2);
740      GetNmObjDocIdV(NmObjId2, NmObjDocIdV2);
741      NmObjDocIdV2.Sort();
742    }
743    TIntV NmObjDocIdV;
744    if (NmObjDocIdV2.Empty()){
745      NmObjDocIdV=NmObjDocIdV1;
746    } else {
747      NmObjDocIdV1.Intrs(NmObjDocIdV2, NmObjDocIdV);
748    }
749    BowDIdV.Gen(NmObjDocIdV.Len(), 0);
750    for (int NmObjDocIdN=0; NmObjDocIdN&lt;NmObjDocIdV.Len(); NmObjDocIdN++){
751      TStr DocNm=GetDocNm(NmObjDocIdV[NmObjDocIdN]);
752      int DId=BowDocBs-&gt;GetDId(DocNm);
753      if (DId!=-1){
754        BowDIdV.Add(DId);
755      } 
756    }
757  }
758  PBowSpV TNmObjBs::GetNmObjConcept(
759   const PBowDocBs&amp; BowDocBs, const PBowDocWgtBs&amp; BowDocWgtBs,
760   const TStr&amp; NmObjStr1, const TStr&amp; NmObjStr2) const {
761    TIntV BowDIdV; GetNmObjDIdV(BowDocBs, BowDIdV, NmObjStr1, NmObjStr2);
762    PBowSpV ConceptSpV=TBowClust::GetConceptSpV(BowDocWgtBs, NULL, BowDIdV);
763    return ConceptSpV;
764  }
765  void TNmObjBs::GetFqNmObjIdPrV(
766   const TStr&amp; TargetNmObjStr, TIntPrV&amp; FqNmObjIdPrV) const {
767    int TargetNmObjId=GetNmObjId(TargetNmObjStr);
<span onclick='openModal()' class='match'>768    TIntIntH NmObjIdToFqH;
769    int NmObjDocs=GetNmObjDocs(TargetNmObjId);
770    for (int NmObjDocIdN=0; NmObjDocIdN&lt;NmObjDocs; NmObjDocIdN++){
771      int DocId=GetNmObjDocId(TargetNmObjId, NmObjDocIdN);
</span>772      int DocNmObjs=GetDocNmObjs(DocId);
773      for (int DocNmObjN=0; DocNmObjN&lt;DocNmObjs; DocNmObjN++){
774        int NmObjId; int TermFq;
775        GetDocNmObjId(DocId, DocNmObjN, NmObjId, TermFq);
776        NmObjIdToFqH.AddDat(NmObjId)++;
777      }
778    }
779    FqNmObjIdPrV.Clr(); NmObjIdToFqH.GetDatKeyPrV(FqNmObjIdPrV);
780    FqNmObjIdPrV.Sort(false);
781  }
782  int TNmObjBs::AddDoc(const TStr&amp; DocNm, const TStr&amp; DateStr, const TIntV&amp; NmObjIdV){
783    TIntIntH NmObjIdToFqH(NmObjIdV.Len());
784    for (int NmObjN=0; NmObjN&lt;NmObjIdV.Len(); NmObjN++){
785      int NmObjId=NmObjIdV[NmObjN];
786      NmObjIdToFqH.AddDat(NmObjId)++;
787    }
788    IAssert(!IsDoc(DocNm));
789    int DocId=DocNmToNmObjDocH.AddKey(DocNm);
790    DocNmToNmObjDocH[DocId]=TNmObjDoc::New();
791    DocNmToNmObjDocH[DocId]-&gt;DateStr=DateStr;
792    TIntPrV&amp; NmObjIdFqPrV=GetDoc_NmObjIdFqPrV(DocId);
793    for (int NmObjP=0; NmObjP&lt;NmObjIdToFqH.Len(); NmObjP++){
794      int NmObjId=NmObjIdToFqH.GetKey(NmObjP);
795      int Fq=NmObjIdToFqH[NmObjP];
796      NmObjIdFqPrV.Add(TIntPr(NmObjId, Fq));
797      NmObjWordStrVToDocIdVH[NmObjId].AddSorted(DocId);
798    }
799    NmObjIdFqPrV.Sort();
800    return DocId;
801  }
802  TStr TNmObjBs::GetDoc_NmObjStrVStr(const int&amp; DocId, const char&amp; SepCh) const {
803    TChA NmObjStrVChA;
804    TIntPrV&amp; NmObjIdFqPrV=GetDoc_NmObjIdFqPrV(DocId);
805    for (int NmObjIdN=0; NmObjIdN&lt;NmObjIdFqPrV.Len(); NmObjIdN++){
806      if (NmObjIdN&gt;0){NmObjStrVChA+=SepCh;}
807      int NmObjId=NmObjIdFqPrV[NmObjIdN].Val1;
808      TStr NmObjStr=GetNmObjStr(NmObjId);
809      NmObjStrVChA+=NmObjStr;
810    }
811    return NmObjStrVChA;
812  }
813  PBowDocBs TNmObjBs::GetBowDocBs(const int&amp; MnNmObjFq) const {
814    printf(&quot;Generating Bag-Of-Words...\n&quot;);
815    PBowDocBs BowDocBs=TBowDocBs::New();
816    for (int DocId=0; DocId&lt;GetDocs(); DocId++){
817      if (DocId%100==0){printf(&quot;%d\r&quot;, DocId);}
818      TStr DocNm=GetDocNm(DocId);
819      TStr DateStr=GetDocDateStr(DocId);
820      TStrV WordStrV;
821      int DocNmObjs=GetDocNmObjs(DocId);
822      for (int DocNmObjN=0; DocNmObjN&lt;DocNmObjs; DocNmObjN++){
823        int NmObjId; int TermFq; GetDocNmObjId(DocId, DocNmObjN, NmObjId, TermFq);
824        if ((MnNmObjFq==-1)||(GetNmObjDocs(NmObjId)&gt;=MnNmObjFq)){
825          TStr NmObjStr=GetNmObjStr(NmObjId);
826          for (int TermOccN=0; TermOccN&lt;TermFq; TermOccN++){
827            WordStrV.Add(NmObjStr);
828          }
829        }
830      }
831      if (!WordStrV.Empty()){
832        int DId=BowDocBs-&gt;AddDoc(DocNm, TStrV(), WordStrV);
833        BowDocBs-&gt;PutDateStr(DId, DateStr);
834     }
835    }
836    BowDocBs-&gt;AssertOk();
837    printf(&quot;\nDone.\n&quot;);
838    return BowDocBs;
839  }
840  PBowDocBs TNmObjBs::GetNmBowDocBs(
841   const PBowDocBs&amp; BowDocBs, const PBowDocWgtBs&amp; BowDocWgtBs, const int&amp; MnNmObjFq) const {
842    int NmObjs=GetNmObjs();
843    for (int NmObjId=0; NmObjId&lt;NmObjs; NmObjId++){
844      printf(&quot;%d/%d\r&quot;, (1+NmObjId), NmObjs);
845      TStr NmObjStr=GetNmObjStr(NmObjId);
846      PBowSpV BowSpV=GetNmObjConcept(BowDocBs, BowDocWgtBs, NmObjStr);
847    }
848    printf(&quot;\n&quot;);
849    return NULL;
850  }
851  PBowDocBs TNmObjBs::GetRelBowDocBs(const PBowDocBs&amp; BowDocBs, const PBowDocWgtBs&amp; BowDocWgtBs, const int&amp; MnNmObjFq) const {
852    return NULL;
853  }
854  void TNmObjBs::SaveTxtNmObj(const TStr&amp; FqFNm, const TStr&amp; SwFNm,
855   const TStr&amp; AbcFNm, const TStr&amp; DocFNm) const {
856    TIntStrVPrV FqWordStrVPrV(NmObjWordStrVToDocIdVH.Len(), 0);
857    TStrVIntPrV WordStrVFqPrV(NmObjWordStrVToDocIdVH.Len(), 0);
858    for (int NmObjId=0; NmObjId&lt;NmObjWordStrVToDocIdVH.Len(); NmObjId++){
859      int Fq=NmObjWordStrVToDocIdVH[NmObjId].Len();
860      const TStrV&amp; WordStrV=NmObjWordStrVToDocIdVH.GetKey(NmObjId);
861      FqWordStrVPrV.Add(TIntStrVPr(Fq, WordStrV));
862      WordStrVFqPrV.Add(TStrVIntPr(WordStrV, Fq));
863    }
864    FqWordStrVPrV.Sort(false);
865    WordStrVFqPrV.Sort();
866    if (!FqFNm.Empty()){
867      printf(&quot;Saving by frequency to &#x27;%s&#x27; ...&quot;, FqFNm.CStr());
868      TFOut SOut(FqFNm); FILE* fOut=SOut.GetFileId();
869      for (int PrN=0; PrN&lt;FqWordStrVPrV.Len(); PrN++){
870        int Fq=FqWordStrVPrV[PrN].Val1;
871        TStrV&amp; WordStrV=FqWordStrVPrV[PrN].Val2;
872        TStr WordStrVStr=GetWordStrVStr(WordStrV);
873        fprintf(fOut, &quot;%d - %s\n&quot;, Fq, WordStrVStr.CStr());
874      }
875      printf(&quot; Done.\n&quot;);
876    }
877    if (!SwFNm.Empty()){
878      printf(&quot;Saving by frequency for stop-words proposal to &#x27;%s&#x27; ...&quot;, SwFNm.CStr());
879      TFOut SOut(SwFNm); FILE* fOut=SOut.GetFileId();
880      for (int PrN=0; PrN&lt;FqWordStrVPrV.Len(); PrN++){
881        TStrV&amp; WordStrV=FqWordStrVPrV[PrN].Val2;
882        TStr WordStrVStr=GetWordStrVStr(WordStrV, &#x27; &#x27;);
883        fprintf(fOut, &quot;%s\n&quot;, WordStrVStr.CStr());
884      }
885      printf(&quot; Done.\n&quot;);
886    }
887    if (!AbcFNm.Empty()){
888      printf(&quot;Saving by alphabet to &#x27;%s&#x27; ...&quot;, AbcFNm.CStr());
889      TFOut SOut(AbcFNm); FILE* fOut=SOut.GetFileId();
890      for (int PrN=0; PrN&lt;WordStrVFqPrV.Len(); PrN++){
891        TStrV&amp; WordStrV=WordStrVFqPrV[PrN].Val1;
892        int Fq=WordStrVFqPrV[PrN].Val2;
893        TStr WordStrVStr=GetWordStrVStr(WordStrV);
894        fprintf(fOut, &quot;%s - %d [&quot;, WordStrVStr.CStr(), Fq);
895        int NmObjId=GetNmObjId(WordStrV);
896        TIntV DocIdV;
897        GetNmObjDocIdV(NmObjId, DocIdV);
898        for (int DocIdN=0; DocIdN&lt;DocIdV.Len(); DocIdN++){
899          TStr DocNm=GetDocNm(DocIdV[DocIdN]);
900          fprintf(fOut, &quot;&#x27;%s&#x27; &quot;, DocNm.CStr());
901        }
902        fprintf(fOut, &quot;]\n&quot;);
903      }
904      printf(&quot; Done.\n&quot;);
905    }
906    if (!DocFNm.Empty()){
907      printf(&quot;Saving by documents to &#x27;%s&#x27; ...&quot;, DocFNm.CStr());
908      TFOut SOut(DocFNm); FILE* fOut=SOut.GetFileId();
909      for (int DocId=0; DocId&lt;GetDocs(); DocId++){
910        TStr DocNm=GetDocNm(DocId);
911        fprintf(fOut, &quot;&#x27;%s&#x27;(%d):&quot;, DocNm.CStr(), DocId);
912        TStr DateStr=GetDocDateStr(DocId);
913        if (!DateStr.Empty()){
914          fprintf(fOut, &quot;[%s]&quot;, DateStr.CStr());}
915        int DocNmObjs=GetDocNmObjs(DocId);
916        for (int DocNmObjN=0; DocNmObjN&lt;DocNmObjs; DocNmObjN++){
917          int NmObjId; int TermFq; GetDocNmObjId(DocId, DocNmObjN, NmObjId, TermFq);
918          TStr NmObjStr=GetNmObjStr(NmObjId);
919          fprintf(fOut, &quot; [%s:%d]&quot;, NmObjStr.CStr(), TermFq);
920        }
921        fprintf(fOut, &quot;\n&quot;);
922      }
923      printf(&quot; Done.\n&quot;);
924    }
925  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-nmobj.cpp</h3>
            <pre><code>1  #include &quot;nmobj.h&quot;
2  TNmObjBs::TNmObjBs(
3   const TSwSetType&amp; SwSetType, const PSIn&amp; CustSwSetSIn,
4   const PSIn&amp; NrWordBsSIn, const PSIn&amp; WordTypeBsSIn, const TStr&amp; MteFNm):
5    ChDef(),
6    WordStrToNrH(),
7    WordStrVToNmObjAttrSetH(),
8    NmObjWordStrVToNrH(),
9    NmObjWordStrVToDocIdVH(),
10    DocNmToNmObjDocH(){
11    ChDef=THtmlLxChDef::GetChDef();
12    SwSet=TSwSet::GetSwSet(SwSetType);
13    LoadCustSwSet(CustSwSetSIn);
14    LoadNrWordBs(NrWordBsSIn);
15    LoadNmObjTypeBs(WordTypeBsSIn);
16    if (!MteFNm.Empty()){
17      }
18  }
19  TStr TNmObjBs::PeriodTagStr=&quot;&lt;.&gt;&quot;;
20  TStr TNmObjBs::BreakTagStr=&quot;&lt;br&gt;&quot;;
21  TStr TNmObjBs::ParagraphTagStr=&quot;&lt;p&gt;&quot;;
22  TStr TNmObjBs::EofTagStr=&quot;&lt;eof&gt;&quot;;
23  void TNmObjBs::LoadCustSwSet(const PSIn&amp; SIn){
24    if (SIn.Empty()){return;}
25    TILx Lx(SIn, TFSet(iloCmtAlw, iloRetEoln, iloExcept));
26    Lx.GetSym(syLn, syEof);
27    while (Lx.Sym!=syEof){
28      TStr WordStrVStr=Lx.Str;
29      TStrV WordStrV; WordStrVStr.SplitOnWs(WordStrV);
30      if (!WordStrV.Empty()){
31        WordStrVToNmObjAttrSetH.AddDat(WordStrV).Incl(noaIgnore);
32      }
33      Lx.GetSym(syLn, syEof);
34    }
35  }
36  void TNmObjBs::LoadNrWordBs(const PSIn&amp; SIn){
37    if (SIn.Empty()){return;}
38    TILx Lx(SIn, TFSet(iloCmtAlw, iloRetEoln, iloExcept));
39    Lx.GetSym(syQStr, syEoln, syEof);
40    while (Lx.Sym!=syEof){
41      if (Lx.Sym==syQStr){
42        TStr NrWordStr=Lx.Str;
43        Lx.GetSym(syColon);
44        Lx.GetSym(syQStr, syEoln);
45        while (Lx.Sym!=syEoln){
46          TStr WordStr=Lx.Str;
47          if (WordStrToNrH.IsKey(WordStr)){
48            printf(&quot;Word already normalized (%s)&quot;, WordStr.CStr());}
49          WordStrToNrH.AddDat(WordStr, NrWordStr);
50          Lx.GetSym(syQStr, syEoln);
51        }
52        Lx.GetSym(syQStr, syEoln, syEof);
53      } else
54      if (Lx.Sym==syEoln){
55        Lx.GetSym(syQStr, syEoln, syEof);
56      } else {
57        Fail;
58      }
59    }
60  }
61  TStr TNmObjBs::GetNrWordStr(const TStr&amp; _WordStr) const {
62    TStr WordStr=_WordStr;
63    if (WordStr.IsChIn(&#x27;_&#x27;)){
64      WordStr.ChangeChAll(&#x27;_&#x27;, &#x27;$&#x27;);
65    }
66    TStr NrWordStr;
67    if (WordStrToNrH.IsKeyGetDat(WordStr, NrWordStr)){
68      return NrWordStr;
69    } else
70    if (MteLex.Empty()){
71      return WordStr;
72    } else {
73      TStr UcWordStr=ChDef-&gt;GetUcStr(WordStr); 
74      TStr NrUcWordStr;
75      if (MteLex-&gt;IsInfWord(UcWordStr, NrUcWordStr)){
76        if (UcWordStr==NrUcWordStr){
77          return WordStr;
78        } else
79        if (IsAllCapWordStr(WordStr)){
80          return NrUcWordStr;
81        } else
82        if (IsFirstCapWordStr(WordStr)){
83          TChA NrWordChA(NrUcWordStr);
84          ChDef-&gt;GetLcChA(NrWordChA);
85          if (NrWordChA.Len()&gt;0){
86            NrWordChA.PutCh(0, ChDef-&gt;GetUc(NrWordChA[0]));}
87          return NrWordChA;
88        } else {
89          TStr NrLcWordStr=ChDef-&gt;GetLcStr(NrUcWordStr);
90          return NrLcWordStr;
91        }
92      } else {
93        return WordStr;
94      }
95    }
96  }
97  TNmObjAttr TNmObjBs::GetNmObjTypeFromStr(const TStr&amp; Str){
98    if (Str==&quot;Ignore&quot;){return noaIgnore;}
99    if (Str==&quot;Standalone&quot;){return noaStandalone;}
100    if (Str==&quot;AsCapitalized&quot;){return noaAsCapitalized;}
101    if (Str==&quot;Unperiod&quot;){return noaUnperiod;}
102    if (Str==&quot;Acronym&quot;){return noaAcronym;}
103    if (Str==&quot;FirstName&quot;){return noaFirstName;}
104    if (Str==&quot;Person&quot;){return noaPerson;}
105    if (Str==&quot;Company&quot;){return noaCompany;}
106    if (Str==&quot;Organization&quot;){return noaOrganization;}
107    if (Str==&quot;Country&quot;){return noaCountry;}
108    if (Str==&quot;Geography&quot;){return noaGeography;}
109    TExcept::Throw(&quot;Invalid Named-Object name.&quot;, Str);
110    return noaIgnore;
111  }
112  void TNmObjBs::LoadNmObjTypeBs(const PSIn&amp; SIn){
113    if (SIn.Empty()){return;}
114    TILx Lx(SIn, TFSet(iloCmtAlw, iloRetEoln, iloExcept));
115    Lx.GetSym(syQStr, syIdStr, syEoln, syEof);
116    while (Lx.Sym!=syEof){
117      if ((Lx.Sym==syQStr)||(Lx.Sym==syIdStr)){
118        TVec&lt;TStrV&gt; NmObjWordStrVV;
119        TB32Set NmObjAttrSet;
120        while ((Lx.Sym==syQStr)||(Lx.Sym==syIdStr)){
121          if (Lx.Sym==syQStr){
122            TStr WordStrVStr=Lx.Str;
123            TStrV WordStrV; WordStrVStr.SplitOnWs(WordStrV);
124            NmObjWordStrVV.Add(WordStrV);
125          } else
126          if (Lx.Sym==syIdStr){
127            TNmObjAttr NmObjAttr=TNmObjBs::GetNmObjTypeFromStr(Lx.Str);
128            NmObjAttrSet.Incl(NmObjAttr);
129          } else {
130            Fail;
131          }
132          Lx.GetSym(syQStr, syIdStr, syEoln, syEof);
133        }
134        if (!NmObjAttrSet.In(noaIgnore)){
135          NmObjAttrSet.Incl(noaDefined);}
136        for (int NmObjN=0; NmObjN&lt;NmObjWordStrVV.Len(); NmObjN++){
137          WordStrVToNmObjAttrSetH.AddDat(NmObjWordStrVV[NmObjN])|=NmObjAttrSet;
138        }
139        {for (int NmObjN=1; NmObjN&lt;NmObjWordStrVV.Len(); NmObjN++){
140          NmObjWordStrVToNrH.AddDat(NmObjWordStrVV[NmObjN], NmObjWordStrVV[0]);
141        }}
142      } else
143      if (Lx.Sym==syEoln){
144        Lx.GetSym(syQStr, syEoln, syEof);
145      } else {
146        Fail;
147      }
148    }
149  }
150  bool TNmObjBs::IsNmObjAttr(const TStr&amp; WordStr, const TNmObjAttr&amp; NmObjAttr) const {
151    TStrV WordStrV; WordStrV.Add(WordStr);
152    return IsNmObjAttr(WordStrV, NmObjAttr);
153  }
154  bool TNmObjBs::IsNmObjAttr(const TStrV&amp; WordStrV, const TNmObjAttr&amp; NmObjAttr) const {
155    int WordStrVToNmObjAttrSetP=WordStrVToNmObjAttrSetH.GetKeyId(WordStrV);
156    if (WordStrVToNmObjAttrSetP==-1){return false;}
157    else {return WordStrVToNmObjAttrSetH[WordStrVToNmObjAttrSetP].In(NmObjAttr);}
158  }
159  bool TNmObjBs::IsFirstCapWordStr(const TStr&amp; Str) const {
160    if (Str.Empty()){return false;}
161    char FirstCh=Str[0];
162    if (!ChDef-&gt;IsAlpha(FirstCh)){return false;}
163    if (!ChDef-&gt;IsUc(FirstCh)){return false;}
164    return true;
165  }
166  bool TNmObjBs::IsAllCapWordStr(const TStr&amp; Str) const {
167    TChA ChA=Str;
168    for (int ChN=0; ChN&lt;ChA.Len(); ChN++){
169      if (!ChDef-&gt;IsUc(ChA[ChN])){return false;}
170    }
171    return true;
172  }
173  bool TNmObjBs::IsNumStr(const TStr&amp; Str) const {
174    if (Str.Empty()){return false;}
175    char FirstCh=Str[0];
176    if (!ChDef-&gt;IsNum(FirstCh)){return false;}
177    return true;
178  }
179  bool TNmObjBs::IsTagStr(const TStr&amp; Str) const {
180    return (!Str.Empty())&amp;&amp;(Str[0]==&#x27;&lt;&#x27;);
181  }
182  bool TNmObjBs::IsMatchPfx(
183   const TStr&amp; Str1, const TStr&amp; Str2,
184   const int&amp; MnPfxLen, const int&amp; MxSfxLen) const {
185    TChA ChA1=Str1; TChA ChA2=Str2;
186    int ChN=0;
187    forever {
188      if (ChN&gt;=ChA1.Len()){break;}
189      if (ChN&gt;=ChA2.Len()){break;}
190      if (ChA1[ChN]!=ChA2[ChN]){break;}
191      ChN++;
192    }
193    if (ChN+1&lt;=MnPfxLen){return false;}
194    if (ChA1.Len()-ChN+1&gt;MxSfxLen){return false;}
195    if (ChA2.Len()-ChN+1&gt;MxSfxLen){return false;}
196    return true;
197  }
198  int TNmObjBs::GetNmObjId(const TStrV&amp; WordStrV, const bool&amp; DefP){
199    int NmObjId=-1;
200    if (DefP){
201      NmObjId=NmObjWordStrVToDocIdVH.AddKey(WordStrV);
202    } else {
203      NmObjId=NmObjWordStrVToDocIdVH.GetKeyId(WordStrV);
204    }
205    return NmObjId;
206  }
207  TStr TNmObjBs::GetWordStrVStr(const TStrV&amp; WordStrV, const char&amp; SepCh) const {
208    TChA WordChA;
209    for (int WordStrN=0; WordStrN&lt;WordStrV.Len(); WordStrN++){
210      if (WordStrN&gt;0){WordChA+=SepCh;}
211      WordChA+=WordStrV[WordStrN];
212    }
213    return WordChA;
214  }
215  void TNmObjBs::GetNrNmObjStrV(const TStrV&amp; NmObjStrV, TStrV&amp; NrNmObjStrV) const {
216    int NmObjWordStrVToNrP=NmObjWordStrVToNrH.GetKeyId(NmObjStrV);
217    if (NmObjWordStrVToNrP==-1){NrNmObjStrV=NmObjStrV;}
218    else {NrNmObjStrV=NmObjWordStrVToNrH[NmObjWordStrVToNrP];}
219  }
220  void TNmObjBs::ExtrCandWordStrV(
221   const TStr&amp; HtmlStr, TStrV&amp; CandWordStrV, const bool&amp; DumpP){
222    CandWordStrV.Clr();
223    PSIn HtmlSIn=TStrIn::New(HtmlStr);
224    PHtmlDoc HtmlDoc=THtmlDoc::New(HtmlSIn, hdtAll, false);
225    PHtmlTok Tok;
226    THtmlLxSym Sym; TStr Str; TStr NrStr;
227    CandWordStrV.Add(PeriodTagStr);
228    bool InTitle=false; bool InScript=false; int LastNmObjTokN=-1;
229    if (DumpP){printf(&quot;Tokens: &quot;);}
230    for (int TokN=0; TokN&lt;HtmlDoc-&gt;GetToks(); TokN++){
231      PHtmlTok Tok=HtmlDoc-&gt;GetTok(TokN);
232      HtmlDoc-&gt;GetTok(TokN, Sym, Str);
233      switch (Sym){
234        case hsyUndef: break;
235        case hsyStr:
236        case hsyNum:
237          if (InTitle){break;}
238          if (InScript){break;}
239          NrStr=GetNrWordStr(Str);
240          if (DumpP){
241            if (Str==NrStr){printf(&quot;%s &quot;, Str.CStr());}
242            else {printf(&quot;%s(%s) &quot;, Str.CStr(), NrStr.CStr());}
243          }
244          if (IsFirstCapWordStr(NrStr)||IsNmObjAttr(NrStr, noaAsCapitalized)){
245            if ((LastNmObjTokN!=-1)&amp;&amp;(LastNmObjTokN&lt;TokN-1)){
246              if (CandWordStrV.Last()!=PeriodTagStr){
247                CandWordStrV.Add(BreakTagStr);
248              }
249            }
250            CandWordStrV.Add(NrStr); LastNmObjTokN=TokN;
251          }
252          break;
253        case hsySSym:
254          if (InTitle){break;}
255          if (InScript){break;}
256          if (DumpP){
257            printf(&quot;%s &quot;, Str.CStr());}
258          if (
259           (Str==&quot;.&quot;)||(Str==&quot;!&quot;)||(Str==&quot;?&quot;)||
260           (Str==&quot;\&quot;&quot;)||(Str==&quot;-&quot;)||(Str==&quot;/&quot;)||
261           (Str==&quot;:&quot;)||(Str==&quot;;&quot;)){
262            if (CandWordStrV.Last()!=PeriodTagStr){
263              CandWordStrV.Add(PeriodTagStr);
264            }
265          }
266          break;
267        case hsyBTag:
268        case hsyETag:
269          if (Str==&quot;&lt;TITLE&gt;&quot;){
270            InTitle=(Sym==hsyBTag);
271          } else
272          if (Str==&quot;&lt;SCRIPT&gt;&quot;){
273            InScript=(Sym==hsyBTag);
274          } else
275          if (Str==&quot;&lt;P&gt;&quot;){
276            if ((!CandWordStrV.Empty())&amp;&amp;(CandWordStrV.Last()!=ParagraphTagStr)){
277              CandWordStrV.Add(ParagraphTagStr);
278              CandWordStrV.Add(PeriodTagStr);
279            }
280          } else
281          if ((Str==&quot;&lt;TD&gt;&quot;)||(Str==&quot;&lt;BR&gt;&quot;)){
282            CandWordStrV.Add(PeriodTagStr);
283          }
284          break;
285        case hsyEof: break;
286        default: break;
287      }
288    }
289    CandWordStrV.Add(EofTagStr);
290    if (DumpP){printf(&quot;\n&quot;);}
291    if (DumpP){
292      printf(&quot;Candidates: &quot;);
293      for (int CandWordStrN=0; CandWordStrN&lt;CandWordStrV.Len(); CandWordStrN++){
294        printf(&quot;%s &quot;, CandWordStrV[CandWordStrN].CStr());}
295      printf(&quot;\n&quot;);
296    }
297  }
298  void TNmObjBs::FilterCandToNmObjIdV(
299   const TStrV&amp; CandWordStrV, TIntV&amp; NmObjIdV, const bool&amp; DumpP){
300    TVec&lt;TStrV&gt; NmObjIdWordStrVV;
301    int CandWordStrN=0; int CandWordStrs=CandWordStrV.Len();
302    while (CandWordStrN&lt;CandWordStrs){
303      TStr WordStr=CandWordStrV[CandWordStrN];
304      if (WordStr.Len()&lt;=1){CandWordStrN++; continue;}
305      if (WordStr==ParagraphTagStr){CandWordStrN++; continue;}
306      if (WordStr==BreakTagStr){CandWordStrN++; continue;}
307      if (WordStr==EofTagStr){CandWordStrN++; break;}
308      if (IsNumStr(WordStr)){CandWordStrN++; continue;}
309      TStr UcWordStr=ChDef-&gt;GetUcStr(WordStr);
310      if ((WordStr==UcWordStr)&amp;&amp;((WordStr.Len()&gt;4)&amp;&amp;(!IsNmObjAttr(WordStr, noaAcronym)))){
311        CandWordStrN++; continue;}
312      if (IsNmObjAttr(WordStr, noaUnperiod)&amp;&amp;(CandWordStrV[CandWordStrN+1]==PeriodTagStr)){
313        CandWordStrN+=1;
314      }
315      if (WordStr==PeriodTagStr){
316        CandWordStrN++; WordStr=CandWordStrV[CandWordStrN];
317        if (IsTagStr(WordStr)){continue;}
318        if (IsNmObjAttr(WordStr, noaDefined)){
319          continue;
320        } else 
321        if ((CandWordStrN&gt;1)&amp;&amp;(IsNmObjAttr(CandWordStrV[CandWordStrN-2], noaUnperiod))){
322          continue;
323        } else {
324          TStr NextWordStr=CandWordStrV[CandWordStrN+1];
325          if (IsFirstCapWordStr(NextWordStr)||IsNmObjAttr(NextWordStr, noaAsCapitalized)){
326            continue;
327          } else 
328          if (!IsNmObj(WordStr)){
329            CandWordStrN++; continue;
330          }
331        }
332      }
333      if (IsNmObjAttr(WordStr, noaIgnore)){
334        CandWordStrN++; continue;
335      } 
336      TStrV WordStrV;
337      forever {
338        WordStrV.Add(WordStr);
339        CandWordStrN++; WordStr=CandWordStrV[CandWordStrN];
340        if (IsTagStr(WordStr)){break;}
341        if (WordStr.Len()&lt;=1){break;}
342        if (IsNmObjAttr(WordStr, noaIgnore)){CandWordStrN++; break;}
343        if (IsNmObjAttr(WordStr, noaStandalone)){break;}
344        if (IsNmObjAttr(WordStrV, noaStandalone)){break;}
345      }
346      TStrV NrWordStrV; GetNrNmObjStrV(WordStrV, NrWordStrV);
347      if (IsNmObjAttr(NrWordStrV, noaIgnore)){continue;}
348      if (IsNmObjAttr(NrWordStrV, noaFirstName)){continue;}
349      if (NrWordStrV.Len()&gt;5){
350        while (NrWordStrV.Len()&gt;2){NrWordStrV.Del(0);}}
351      if (NrWordStrV.Len()==1){
352        TStr UcWordStr=ChDef-&gt;GetUcStr(NrWordStrV[0]);
353        if (SwSet-&gt;IsIn(UcWordStr, true)){continue;}
354      }
355      NmObjIdWordStrVV.Add(NrWordStrV);
356    }
357    for (int NmObjN=0; NmObjN&lt;NmObjIdWordStrVV.Len(); NmObjN++){
358      TStrV&amp; WordStrV=NmObjIdWordStrVV[NmObjN];
359      if (WordStrV.Len()==1){
360        for (int SubNmObjN=0; SubNmObjN&lt;NmObjIdWordStrVV.Len(); SubNmObjN++){
361          TStrV&amp; SubWordStrV=NmObjIdWordStrVV[SubNmObjN];
362          if (SubWordStrV.Len()==1){
363            if (WordStrV[0]!=SubWordStrV[0]){
364              if (IsMatchPfx(WordStrV[0], SubWordStrV[0], 3, 4)){
365                if (WordStrV[0].Len()&lt;SubWordStrV[0].Len()){SubWordStrV=WordStrV;}
366                else {WordStrV=SubWordStrV;}
367              }
368            }
369          }
370        }
371      } else
372      if (WordStrV.Len()&gt;=2){
373        TStr LastNm=WordStrV.Last();
374        for (int SubNmObjN=0; SubNmObjN&lt;NmObjIdWordStrVV.Len(); SubNmObjN++){
375          TStrV&amp; SubWordStrV=NmObjIdWordStrVV[SubNmObjN];
376          if (SubWordStrV.Len()==1){
377            TStr SubLastNm=SubWordStrV[0];
378            if (LastNm!=SubLastNm){
379              if (IsMatchPfx(LastNm, SubLastNm, 3, 4)){
380                if (LastNm.Len()&lt;SubLastNm.Len()){SubWordStrV=WordStrV;} 
381                else {WordStrV=SubWordStrV;}
382              }
383            }
384          } else
385          if (false&amp;&amp;(SubWordStrV.Len()==2)){
386            if ((WordStrV[0]!=SubWordStrV[0])||(WordStrV[1]!=SubWordStrV[1])){
387              if ((IsMatchPfx(WordStrV[0], SubWordStrV[0], 3, 4))&amp;&amp;
388               (IsMatchPfx(WordStrV[1], SubWordStrV[1], 3, 4))){
389                if (WordStrV[0].Len()&lt;SubWordStrV[0].Len()){
390                  SubWordStrV[0]=WordStrV[0];}
391                else {WordStrV[0]=SubWordStrV[0];}
392                if (WordStrV[1].Len()&lt;SubWordStrV[1].Len()){
393                  SubWordStrV[1]=WordStrV[1];}
394                else {WordStrV[1]=SubWordStrV[1];}
395              }
396            }
397          }
398        }
399      }
400    }
401    NmObjIdV.Gen(NmObjIdWordStrVV.Len(), 0);
402    {for (int NmObjN=0; NmObjN&lt;NmObjIdWordStrVV.Len(); NmObjN++){
403      TStrV&amp; NmObjWordStrV=NmObjIdWordStrVV[NmObjN];
404      int NmObjId=GetNmObjId(NmObjWordStrV, true);
405      NmObjIdV.Add(NmObjId);
406    }}
407    if (DumpP){
408      printf(&quot;Named-Objects: &quot;);
409      for (int NmObjN=0; NmObjN&lt;NmObjIdV.Len(); NmObjN++){
410        int NmObjId=NmObjIdV[NmObjN];
411        TStr NmObjStr=GetNmObjStr(NmObjId);
412        printf(&quot;%s &quot;, NmObjStr.CStr());
413      }
414      printf(&quot;\n&quot;);
415    }
416  }
417  PNmObjBs TNmObjBs::GetFromStrQuV(
418   const TStrQuV&amp; IdTitleSrcHtmlQuV,
419   const TSwSetType&amp; SwSetType, const TStr&amp; CustSwSetFNm,
420   const TStr&amp; NrWordBsFNm, const TStr&amp; WordTypeBsFNm, const TStr&amp; MteFNm,
421   const int&amp; MxDocs, const bool&amp; DumpP){
422    PSIn CustSwSetSIn;
423    if (!CustSwSetFNm.Empty()&amp;&amp;(TFile::Exists(CustSwSetFNm))){
424      CustSwSetSIn=TFIn::New(CustSwSetFNm);}
425    PSIn NrWordBsSIn;
426    if (!NrWordBsFNm.Empty()&amp;&amp;(TFile::Exists(NrWordBsFNm))){
427      NrWordBsSIn=TFIn::New(NrWordBsFNm);}
428    PSIn WordTypeBsSIn;
429    if (!WordTypeBsFNm.Empty()&amp;&amp;(TFile::Exists(WordTypeBsFNm))){
430      WordTypeBsSIn=TFIn::New(WordTypeBsFNm);}
431    PNmObjBs NmObjBs=
432     TNmObjBs::New(SwSetType, CustSwSetSIn, NrWordBsSIn, WordTypeBsSIn, MteFNm);
433    for (int DocN=0; DocN&lt;IdTitleSrcHtmlQuV.Len(); DocN++){
434      if ((MxDocs!=-1)&amp;&amp;(DocN&gt;MxDocs)){break;}
435      TStr DocNm=IdTitleSrcHtmlQuV[DocN].Val1;
436      TStr TitleStr=IdTitleSrcHtmlQuV[DocN].Val2;
437      TStr HtmlStr=IdTitleSrcHtmlQuV[DocN].Val4;
438      if (DumpP){
439        printf(&quot;===============================================\n&quot;);
440        printf(&quot;%s\n&quot;, DocNm.CStr());
441      }
442      TStrV CandWordStrV; NmObjBs-&gt;ExtrCandWordStrV(HtmlStr, CandWordStrV, DumpP);
443      TIntV NmObjIdV; NmObjBs-&gt;FilterCandToNmObjIdV(CandWordStrV, NmObjIdV, DumpP);
444      NmObjBs-&gt;AddDoc(DocNm, &quot;&quot;, NmObjIdV);
445    }
446    TIntV NewNmObjIdV; NmObjBs-&gt;GetMergedNmObj(NewNmObjIdV);
447    NmObjBs-&gt;PutMergedNmObj(NewNmObjIdV);
448    return NmObjBs;
449  }
450  PNmObjBs TNmObjBs::GetFromCpd(
451   const PSIn&amp; _CpdSIn,
452   const TSwSetType&amp; SwSetType, const PSIn&amp; CustSwSetSIn,
453   const PSIn&amp; NrWordBsSIn, const PSIn&amp; WordTypeBsSIn, const TStr&amp; MteFNm,
454   const int&amp; MxDocs, const bool&amp; DumpP){
455    PNmObjBs NmObjBs=
456     TNmObjBs::New(SwSetType, CustSwSetSIn, NrWordBsSIn, WordTypeBsSIn, MteFNm);
457    PSIn CpdSIn=TCpDoc::FFirstCpd(_CpdSIn); PCpDoc CpDoc; int Docs=0;
458    while (TCpDoc::FNextCpd(CpdSIn, CpDoc)){
459      if ((MxDocs!=-1)&amp;&amp;(Docs&gt;MxDocs)){break;}
460      TStr DocNm=CpDoc-&gt;GetDocNm();
461      TStr DateStr=CpDoc-&gt;GetDateStr();
462      TStr HtmlStr=CpDoc-&gt;GetTxtStr();
463      Docs++; printf(&quot;%d %s\r&quot;, Docs, DocNm.CStr());
464      if (DumpP){
465        printf(&quot;===============================================\n&quot;);
466        printf(&quot;%s\n&quot;, DocNm.CStr());
467      }
468      TStrV CandWordStrV; NmObjBs-&gt;ExtrCandWordStrV(HtmlStr, CandWordStrV, DumpP);
469      TIntV NmObjIdV; NmObjBs-&gt;FilterCandToNmObjIdV(CandWordStrV, NmObjIdV, DumpP);
470      NmObjBs-&gt;AddDoc(DocNm, DateStr, NmObjIdV);
471    }
472    TIntV NewNmObjIdV; NmObjBs-&gt;GetMergedNmObj(NewNmObjIdV);
473    NmObjBs-&gt;PutMergedNmObj(NewNmObjIdV);
474    return NmObjBs;
475  }
476  PNmObjBs TNmObjBs::GetFromCpd(
477   const TStr&amp; CpdFNm,
478   const TSwSetType&amp; SwSetType, const TStr&amp; CustSwSetFNm,
479   const TStr&amp; NrWordBsFNm, const TStr&amp; WordTypeBsFNm, const TStr&amp; MteFNm,
480   const int&amp; MxDocs, const bool&amp; DumpP){
481    PSIn CpdSIn=TFIn::New(CpdFNm);
482    PSIn CustSwSetSIn;
483    if (!CustSwSetFNm.Empty()&amp;&amp;(TFile::Exists(CustSwSetFNm))){
484      CustSwSetSIn=TFIn::New(CustSwSetFNm);}
485    PSIn NrWordBsSIn;
486    if (!NrWordBsFNm.Empty()&amp;&amp;(TFile::Exists(NrWordBsFNm))){
487      NrWordBsSIn=TFIn::New(NrWordBsFNm);}
488    PSIn WordTypeBsSIn;
489    if (!WordTypeBsFNm.Empty()&amp;&amp;(TFile::Exists(WordTypeBsFNm))){
490      WordTypeBsSIn=TFIn::New(WordTypeBsFNm);}
491    return TNmObjBs::GetFromCpd(
492     CpdSIn, SwSetType, CustSwSetSIn, NrWordBsSIn, WordTypeBsSIn, MteFNm,
493     MxDocs, DumpP);
494  }
495  void TNmObjBs::GetMergedNmObj(TIntV&amp; NewNmObjIdV){
496    int MnPfxLen=3; int MxSfxLen=2;
497    int NmObjs=NmObjWordStrVToDocIdVH.Len();
498    NewNmObjIdV.Gen(NmObjs); NewNmObjIdV.PutAll(-1);
499    {int SingleWords=0; int ReducedSingleWords=0;
500    TStrIntVH PfxStrToNmObjIdVH;
501    for (int NmObjId=0; NmObjId&lt;NmObjs; NmObjId++){
502      if (NewNmObjIdV[NmObjId]!=-1){continue;}
503      const TStrV&amp; WordStrV=NmObjWordStrVToDocIdVH.GetKey(NmObjId);
504      if (WordStrV.Len()==1){
505        TStr PfxStr=WordStrV[0].GetSubStr(0, 2);
506        PfxStrToNmObjIdVH.AddDat(PfxStr).Add(NmObjId);
507        SingleWords++;
508      }
509    }
510    int Pfxs=PfxStrToNmObjIdVH.Len();
511    for (int PfxId=0; PfxId&lt;Pfxs; PfxId++){
512      TIntV&amp; NmObjIdV=PfxStrToNmObjIdVH[PfxId];
513      for (int NmObjIdN=0; NmObjIdN&lt;NmObjIdV.Len(); NmObjIdN++){
514        int NmObjId=NmObjIdV[NmObjIdN];
515        if (NewNmObjIdV[NmObjId]!=-1){continue;}
516        NewNmObjIdV[NmObjId]=NmObjId;
517        const TStr&amp; WordStr=NmObjWordStrVToDocIdVH.GetKey(NmObjId)[0];
518        int Fq=NmObjWordStrVToDocIdVH[NmObjId].Len();
519        TIntPrV FqNmObjIdPrV(NmObjIdV.Len(), 0);
520        FqNmObjIdPrV.Add(TIntPr(Fq, NmObjId));
521        for (int SubNmObjIdN=NmObjIdN+1; SubNmObjIdN&lt;NmObjIdV.Len(); SubNmObjIdN++){
522          int SubNmObjId=NmObjIdV[SubNmObjIdN];
523          if (NewNmObjIdV[SubNmObjId]!=-1){continue;}
524          const TStr&amp; SubWordStr=NmObjWordStrVToDocIdVH.GetKey(SubNmObjId)[0];
525          if (IsMatchPfx(WordStr, SubWordStr, MnPfxLen, MxSfxLen)){
526            NewNmObjIdV[SubNmObjId]=NmObjId;
527            int SubFq=NmObjWordStrVToDocIdVH[SubNmObjId].Len();
528            FqNmObjIdPrV.Add(TIntPr(SubFq, SubNmObjId));
529          }
530        }
531        ReducedSingleWords++;
532        if (FqNmObjIdPrV.Len()&gt;1){
533          FqNmObjIdPrV.Sort(false);
534          int MainNmObjId=FqNmObjIdPrV[0].Val2;
535          NewNmObjIdV[MainNmObjId]=MainNmObjId;
536          TStr MainWordStr=NmObjWordStrVToDocIdVH.GetKey(MainNmObjId)[0];
537          for (int FqNmObjIdPrN=1; FqNmObjIdPrN&lt;FqNmObjIdPrV.Len(); FqNmObjIdPrN++){
538            int SubNmObjId=FqNmObjIdPrV[FqNmObjIdPrN].Val2;
539            NewNmObjIdV[SubNmObjId]=MainNmObjId;
540          }
541        }
542      }
543    }
544    }
545    {int DoubleWords=0; int ReducedDoubleWords=0;
546    TStrIntVH PfxStrToNmObjIdVH;
547    for (int NmObjId=0; NmObjId&lt;NmObjs; NmObjId++){
548      if (NewNmObjIdV[NmObjId]!=-1){continue;}
549      const TStrV&amp; WordStrV=NmObjWordStrVToDocIdVH.GetKey(NmObjId);
550      if (WordStrV.Len()==2){
551        TStr PfxStr=WordStrV[0].GetSubStr(0, 2)+WordStrV[1].GetSubStr(0, 2);
552        PfxStrToNmObjIdVH.AddDat(PfxStr).Add(NmObjId);
553        DoubleWords++;
554      }
555    }
556    int Pfxs=PfxStrToNmObjIdVH.Len();
557    for (int PfxId=0; PfxId&lt;Pfxs; PfxId++){
558      TIntV&amp; NmObjIdV=PfxStrToNmObjIdVH[PfxId];
559      for (int NmObjIdN=0; NmObjIdN&lt;NmObjIdV.Len(); NmObjIdN++){
560        int NmObjId=NmObjIdV[NmObjIdN];
561        if (NewNmObjIdV[NmObjId]!=-1){continue;}
562        NewNmObjIdV[NmObjId]=NmObjId;
563        const TStr&amp; WordStr1=NmObjWordStrVToDocIdVH.GetKey(NmObjId)[0];
564        const TStr&amp; WordStr2=NmObjWordStrVToDocIdVH.GetKey(NmObjId)[1];
565        int Fq=NmObjWordStrVToDocIdVH[NmObjId].Len();
566        TIntPrV FqNmObjIdPrV(NmObjIdV.Len(), 0);
567        FqNmObjIdPrV.Add(TIntPr(Fq, NmObjId));
568        for (int SubNmObjIdN=NmObjIdN+1; SubNmObjIdN&lt;NmObjIdV.Len(); SubNmObjIdN++){
569          int SubNmObjId=NmObjIdV[SubNmObjIdN];
570          if (NewNmObjIdV[SubNmObjId]!=-1){continue;}
571          const TStr&amp; SubWordStr1=NmObjWordStrVToDocIdVH.GetKey(SubNmObjId)[0];
572          const TStr&amp; SubWordStr2=NmObjWordStrVToDocIdVH.GetKey(SubNmObjId)[1];
573          if (IsMatchPfx(WordStr1, SubWordStr1, MnPfxLen, MxSfxLen+1)&amp;&amp;
574           IsMatchPfx(WordStr2, SubWordStr2, MnPfxLen, MxSfxLen+1)){
575            NewNmObjIdV[SubNmObjId]=NmObjId;
576            int SubFq=NmObjWordStrVToDocIdVH[SubNmObjId].Len();
577            FqNmObjIdPrV.Add(TIntPr(SubFq, SubNmObjId));
578          }
579        }
580        ReducedDoubleWords++;
581        if (FqNmObjIdPrV.Len()&gt;1){
582          FqNmObjIdPrV.Sort(false);
583          int MainNmObjId=FqNmObjIdPrV[0].Val2;
584          NewNmObjIdV[MainNmObjId]=MainNmObjId;
585          TStr MainWordStr1=NmObjWordStrVToDocIdVH.GetKey(MainNmObjId)[0];
586          TStr MainWordStr2=NmObjWordStrVToDocIdVH.GetKey(MainNmObjId)[1];
587          for (int FqNmObjIdPrN=1; FqNmObjIdPrN&lt;FqNmObjIdPrV.Len(); FqNmObjIdPrN++){
588            int SubNmObjId=FqNmObjIdPrV[FqNmObjIdPrN].Val2;
589            NewNmObjIdV[SubNmObjId]=MainNmObjId;
590          }
591        }
592      }
593    }
594    }
595    {int TripleWords=0; int ReducedTripleWords=0;
596    TStrIntVH PfxStrToNmObjIdVH;
597    for (int NmObjId=0; NmObjId&lt;NmObjs; NmObjId++){
598      if (NewNmObjIdV[NmObjId]!=-1){continue;}
599      const TStrV&amp; WordStrV=NmObjWordStrVToDocIdVH.GetKey(NmObjId);
600      if (WordStrV.Len()==3){
601        TripleWords++;
602        TStrV DbWordStrV(2, 0);
603        DbWordStrV.Add(WordStrV[1]); DbWordStrV.Add(WordStrV[2]);
604        int DbNmObjId=NmObjWordStrVToDocIdVH.GetKeyId(DbWordStrV);
605        if (DbNmObjId!=-1){
606          ReducedTripleWords++;
607          int NewDbNmObjId=NewNmObjIdV[DbNmObjId];
608          NewNmObjIdV[NmObjId]=NewDbNmObjId;
609        }
610      }
611    }
612    }
613    {int TripleWords=0; int ReducedTripleWords=0;
614    TStrIntVH PfxStrToNmObjIdVH;
615    for (int NmObjId=0; NmObjId&lt;NmObjs; NmObjId++){
616      if (NewNmObjIdV[NmObjId]!=-1){continue;}
617      const TStrV&amp; WordStrV=NmObjWordStrVToDocIdVH.GetKey(NmObjId);
618      if (WordStrV.Len()==3){
619        TStr PfxStr=WordStrV[0].GetSubStr(0, 2)+WordStrV[1].GetSubStr(0, 2)+WordStrV[2].GetSubStr(0, 2);
620        PfxStrToNmObjIdVH.AddDat(PfxStr).Add(NmObjId);
621        TripleWords++;
622      }
623    }
624    int Pfxs=PfxStrToNmObjIdVH.Len();
625    for (int PfxId=0; PfxId&lt;Pfxs; PfxId++){
626      TIntV&amp; NmObjIdV=PfxStrToNmObjIdVH[PfxId];
627      for (int NmObjIdN=0; NmObjIdN&lt;NmObjIdV.Len(); NmObjIdN++){
628        int NmObjId=NmObjIdV[NmObjIdN];
629        if (NewNmObjIdV[NmObjId]!=-1){continue;}
630        NewNmObjIdV[NmObjId]=NmObjId;
631        const TStr&amp; WordStr1=NmObjWordStrVToDocIdVH.GetKey(NmObjId)[0];
632        const TStr&amp; WordStr2=NmObjWordStrVToDocIdVH.GetKey(NmObjId)[1];
633        const TStr&amp; WordStr3=NmObjWordStrVToDocIdVH.GetKey(NmObjId)[2];
634        int Fq=NmObjWordStrVToDocIdVH[NmObjId].Len();
635        TIntPrV FqNmObjIdPrV(NmObjIdV.Len(), 0);
636        FqNmObjIdPrV.Add(TIntPr(Fq, NmObjId));
637        for (int SubNmObjIdN=NmObjIdN+1; SubNmObjIdN&lt;NmObjIdV.Len(); SubNmObjIdN++){
638          int SubNmObjId=NmObjIdV[SubNmObjIdN];
639          if (NewNmObjIdV[SubNmObjId]!=-1){continue;}
640          const TStr&amp; SubWordStr1=NmObjWordStrVToDocIdVH.GetKey(SubNmObjId)[0];
641          const TStr&amp; SubWordStr2=NmObjWordStrVToDocIdVH.GetKey(SubNmObjId)[1];
642          const TStr&amp; SubWordStr3=NmObjWordStrVToDocIdVH.GetKey(SubNmObjId)[2];
643          if (IsMatchPfx(WordStr1, SubWordStr1, MnPfxLen, MxSfxLen+1)&amp;&amp;
644           IsMatchPfx(WordStr2, SubWordStr2, MnPfxLen, MxSfxLen+1)&amp;&amp;
645           IsMatchPfx(WordStr3, SubWordStr3, MnPfxLen, MxSfxLen+1)){
646            NewNmObjIdV[SubNmObjId]=NmObjId;
647            int SubFq=NmObjWordStrVToDocIdVH[SubNmObjId].Len();
648            FqNmObjIdPrV.Add(TIntPr(SubFq, SubNmObjId));
649          }
650        }
651        ReducedTripleWords++;
652        if (FqNmObjIdPrV.Len()&gt;1){
653          FqNmObjIdPrV.Sort(false);
654          int MainNmObjId=FqNmObjIdPrV[0].Val2;
655          NewNmObjIdV[MainNmObjId]=MainNmObjId;
656          TStr MainWordStr1=NmObjWordStrVToDocIdVH.GetKey(MainNmObjId)[0];
657          TStr MainWordStr2=NmObjWordStrVToDocIdVH.GetKey(MainNmObjId)[1];
658          TStr MainWordStr3=NmObjWordStrVToDocIdVH.GetKey(MainNmObjId)[2];
659          for (int FqNmObjIdPrN=1; FqNmObjIdPrN&lt;FqNmObjIdPrV.Len(); FqNmObjIdPrN++){
660            int SubNmObjId=FqNmObjIdPrV[FqNmObjIdPrN].Val2;
661            NewNmObjIdV[SubNmObjId]=MainNmObjId;
662          }
663        }
664      }
665    }
666    }
667  }
668  void TNmObjBs::PutMergedNmObj(const TIntV&amp; NewNmObjIdV){
669    TStrVIntVH NewNmObjWordStrVToDocIdVH;
670    for (int NmObjId=0; NmObjId&lt;NewNmObjIdV.Len(); NmObjId++){
671      if (NewNmObjIdV[NmObjId]!=NmObjId){continue;}
672      const TStrV&amp; WordStrV=NmObjWordStrVToDocIdVH.GetKey(NmObjId);
673      NewNmObjWordStrVToDocIdVH.AddDat(WordStrV);
674    }
675    {for (int NmObjId=0; NmObjId&lt;NewNmObjIdV.Len(); NmObjId++){
676      if (NewNmObjIdV[NmObjId]==NmObjId){continue;}
677      const TStrV&amp; WordStrV=NmObjWordStrVToDocIdVH.GetKey(NmObjId);
678      int NrNmObjId=NewNmObjIdV[NmObjId];
679      if (NrNmObjId!=-1){
680        const TStrV&amp; NrWordStrV=NmObjWordStrVToDocIdVH.GetKey(NrNmObjId);
681        NmObjWordStrVToNrH.AddDat(WordStrV, NrWordStrV);
682      }
683    }}
684    int Docs=GetDocs();
685    for (int DocId=0; DocId&lt;Docs; DocId++){
686      TIntPrV&amp; NmObjIdFqPrV=GetDoc_NmObjIdFqPrV(DocId);
687      TIntIntH NewNmObjIdToFqH(NmObjIdFqPrV.Len());
688      for (int NmObjN=0; NmObjN&lt;NmObjIdFqPrV.Len(); NmObjN++){
689        int NmObjId=NmObjIdFqPrV[NmObjN].Val1;
690        int Fq=NmObjIdFqPrV[NmObjN].Val2;
691        int NrNmObjId=NewNmObjIdV[NmObjId];
692        if (NrNmObjId!=-1){
693          const TStrV&amp; NrWordStrV=NmObjWordStrVToDocIdVH.GetKey(NrNmObjId);
694          int NewNmObjId=NewNmObjWordStrVToDocIdVH.GetKeyId(NrWordStrV);
695          NewNmObjIdToFqH.AddDat(NewNmObjId)+=Fq;
696        }
697      }
698      NmObjIdFqPrV.Gen(NewNmObjIdToFqH.Len(), 0);
699      for (int NmObjP=0; NmObjP&lt;NewNmObjIdToFqH.Len(); NmObjP++){
700        int NewNmObjId=NewNmObjIdToFqH.GetKey(NmObjP);
701        int Fq=NewNmObjIdToFqH[NmObjP];
702        NmObjIdFqPrV.Add(TIntPr(NewNmObjId, Fq));
703        NewNmObjWordStrVToDocIdVH[NewNmObjId].Add(DocId);
704      }
705      NmObjIdFqPrV.Sort();
706    }
707    NmObjWordStrVToDocIdVH=NewNmObjWordStrVToDocIdVH;
708  }
709  void TNmObjBs::GetNmObjStrFqPrV(TStrIntPrV&amp; NmObjStrFqPrV, const int&amp; MnFq) const {
710    int NmObjs=GetNmObjs();
711    NmObjStrFqPrV.Gen(NmObjs, 0);
712    for (int NmObjId=0; NmObjId&lt;NmObjs; NmObjId++){
713      TStrIntPr NmObjStrFqPr;
714      NmObjStrFqPr.Val1=GetNmObjStr(NmObjId);
715      NmObjStrFqPr.Val2=GetNmObjDocs(NmObjId);
716      if (NmObjStrFqPr.Val2&gt;=MnFq){
717        NmObjStrFqPrV.Add(NmObjStrFqPr);}
718    }
719  }
720  void TNmObjBs::GetNmObjFqStrPrV(TIntStrPrV&amp; NmObjFqStrPrV, const int&amp; MnFq) const {
721    int NmObjs=GetNmObjs();
722    NmObjFqStrPrV.Gen(NmObjs, 0);
723    for (int NmObjId=0; NmObjId&lt;NmObjs; NmObjId++){
724      TIntStrPr NmObjFqStrPr;
725      NmObjFqStrPr.Val1=GetNmObjDocs(NmObjId);
726      NmObjFqStrPr.Val2=GetNmObjStr(NmObjId);
727      if (NmObjFqStrPr.Val1&gt;=MnFq){
728        NmObjFqStrPrV.Add(NmObjFqStrPr);}
729    }
730  }
731  void TNmObjBs::GetNmObjDIdV(
732   const PBowDocBs&amp; BowDocBs, TIntV&amp; BowDIdV, 
733   const TStr&amp; NmObjStr1, const TStr&amp; NmObjStr2) const {
734    int NmObjId1=GetNmObjId(NmObjStr1);
735    TIntV NmObjDocIdV1; GetNmObjDocIdV(NmObjId1, NmObjDocIdV1);
736    NmObjDocIdV1.Sort();
737    TIntV NmObjDocIdV2;
738    if (!NmObjStr2.Empty()){
739      int NmObjId2=GetNmObjId(NmObjStr2);
740      GetNmObjDocIdV(NmObjId2, NmObjDocIdV2);
741      NmObjDocIdV2.Sort();
742    }
743    TIntV NmObjDocIdV;
744    if (NmObjDocIdV2.Empty()){
745      NmObjDocIdV=NmObjDocIdV1;
746    } else {
747      NmObjDocIdV1.Intrs(NmObjDocIdV2, NmObjDocIdV);
748    }
749    BowDIdV.Gen(NmObjDocIdV.Len(), 0);
750    for (int NmObjDocIdN=0; NmObjDocIdN&lt;NmObjDocIdV.Len(); NmObjDocIdN++){
751      TStr DocNm=GetDocNm(NmObjDocIdV[NmObjDocIdN]);
752      int DId=BowDocBs-&gt;GetDId(DocNm);
753      if (DId!=-1){
754        BowDIdV.Add(DId);
755      } 
756    }
757  }
758  PBowSpV TNmObjBs::GetNmObjConcept(
759   const PBowDocBs&amp; BowDocBs, const PBowDocWgtBs&amp; BowDocWgtBs,
760   const TStr&amp; NmObjStr1, const TStr&amp; NmObjStr2) const {
761    TIntV BowDIdV; GetNmObjDIdV(BowDocBs, BowDIdV, NmObjStr1, NmObjStr2);
762    PBowSpV ConceptSpV=TBowClust::GetConceptSpV(BowDocWgtBs, NULL, BowDIdV);
763    return ConceptSpV;
764  }
765  void TNmObjBs::GetFqNmObjIdPrV(
766   const TStr&amp; TargetNmObjStr, TIntPrV&amp; FqNmObjIdPrV) const {
767    int TargetNmObjId=GetNmObjId(TargetNmObjStr);
768    TIntIntH NmObjIdToFqH;
769    int NmObjDocs=GetNmObjDocs(TargetNmObjId);
770    for (int NmObjDocIdN=0; NmObjDocIdN&lt;NmObjDocs; NmObjDocIdN++){
771      int DocId=GetNmObjDocId(TargetNmObjId, NmObjDocIdN);
772      int DocNmObjs=GetDocNmObjs(DocId);
773      for (int DocNmObjN=0; DocNmObjN&lt;DocNmObjs; DocNmObjN++){
774        int NmObjId; int TermFq;
775        GetDocNmObjId(DocId, DocNmObjN, NmObjId, TermFq);
776        NmObjIdToFqH.AddDat(NmObjId)++;
777      }
778    }
779    FqNmObjIdPrV.Clr(); NmObjIdToFqH.GetDatKeyPrV(FqNmObjIdPrV);
780    FqNmObjIdPrV.Sort(false);
781  }
782  int TNmObjBs::AddDoc(const TStr&amp; DocNm, const TStr&amp; DateStr, const TIntV&amp; NmObjIdV){
783    TIntIntH NmObjIdToFqH(NmObjIdV.Len());
784    for (int NmObjN=0; NmObjN&lt;NmObjIdV.Len(); NmObjN++){
785      int NmObjId=NmObjIdV[NmObjN];
786      NmObjIdToFqH.AddDat(NmObjId)++;
787    }
788    IAssert(!IsDoc(DocNm));
789    int DocId=DocNmToNmObjDocH.AddKey(DocNm);
790    DocNmToNmObjDocH[DocId]=TNmObjDoc::New();
791    DocNmToNmObjDocH[DocId]-&gt;DateStr=DateStr;
792    TIntPrV&amp; NmObjIdFqPrV=GetDoc_NmObjIdFqPrV(DocId);
793    for (int NmObjP=0; NmObjP&lt;NmObjIdToFqH.Len(); NmObjP++){
794      int NmObjId=NmObjIdToFqH.GetKey(NmObjP);
795      int Fq=NmObjIdToFqH[NmObjP];
796      NmObjIdFqPrV.Add(TIntPr(NmObjId, Fq));
797      NmObjWordStrVToDocIdVH[NmObjId].AddSorted(DocId);
798    }
799    NmObjIdFqPrV.Sort();
800    return DocId;
801  }
802  TStr TNmObjBs::GetDoc_NmObjStrVStr(const int&amp; DocId, const char&amp; SepCh) const {
803    TChA NmObjStrVChA;
804    TIntPrV&amp; NmObjIdFqPrV=GetDoc_NmObjIdFqPrV(DocId);
805    for (int NmObjIdN=0; NmObjIdN&lt;NmObjIdFqPrV.Len(); NmObjIdN++){
806      if (NmObjIdN&gt;0){NmObjStrVChA+=SepCh;}
807      int NmObjId=NmObjIdFqPrV[NmObjIdN].Val1;
808      TStr NmObjStr=GetNmObjStr(NmObjId);
809      NmObjStrVChA+=NmObjStr;
810    }
811    return NmObjStrVChA;
812  }
813  PBowDocBs TNmObjBs::GetBowDocBs(const int&amp; MnNmObjFq) const {
814    printf(&quot;Generating Bag-Of-Words...\n&quot;);
815    PBowDocBs BowDocBs=TBowDocBs::New();
816    for (int DocId=0; DocId&lt;GetDocs(); DocId++){
817      if (DocId%100==0){printf(&quot;%d\r&quot;, DocId);}
818      TStr DocNm=GetDocNm(DocId);
819      TStr DateStr=GetDocDateStr(DocId);
<span onclick='openModal()' class='match'>820      TStrV WordStrV;
821      int DocNmObjs=GetDocNmObjs(DocId);
822      for (int DocNmObjN=0; DocNmObjN&lt;DocNmObjs; DocNmObjN++){
823        int NmObjId; int TermFq; GetDocNmObjId(DocId, DocNmObjN, NmObjId, TermFq);
</span>824        if ((MnNmObjFq==-1)||(GetNmObjDocs(NmObjId)&gt;=MnNmObjFq)){
825          TStr NmObjStr=GetNmObjStr(NmObjId);
826          for (int TermOccN=0; TermOccN&lt;TermFq; TermOccN++){
827            WordStrV.Add(NmObjStr);
828          }
829        }
830      }
831      if (!WordStrV.Empty()){
832        int DId=BowDocBs-&gt;AddDoc(DocNm, TStrV(), WordStrV);
833        BowDocBs-&gt;PutDateStr(DId, DateStr);
834     }
835    }
836    BowDocBs-&gt;AssertOk();
837    printf(&quot;\nDone.\n&quot;);
838    return BowDocBs;
839  }
840  PBowDocBs TNmObjBs::GetNmBowDocBs(
841   const PBowDocBs&amp; BowDocBs, const PBowDocWgtBs&amp; BowDocWgtBs, const int&amp; MnNmObjFq) const {
842    int NmObjs=GetNmObjs();
843    for (int NmObjId=0; NmObjId&lt;NmObjs; NmObjId++){
844      printf(&quot;%d/%d\r&quot;, (1+NmObjId), NmObjs);
845      TStr NmObjStr=GetNmObjStr(NmObjId);
846      PBowSpV BowSpV=GetNmObjConcept(BowDocBs, BowDocWgtBs, NmObjStr);
847    }
848    printf(&quot;\n&quot;);
849    return NULL;
850  }
851  PBowDocBs TNmObjBs::GetRelBowDocBs(const PBowDocBs&amp; BowDocBs, const PBowDocWgtBs&amp; BowDocWgtBs, const int&amp; MnNmObjFq) const {
852    return NULL;
853  }
854  void TNmObjBs::SaveTxtNmObj(const TStr&amp; FqFNm, const TStr&amp; SwFNm,
855   const TStr&amp; AbcFNm, const TStr&amp; DocFNm) const {
856    TIntStrVPrV FqWordStrVPrV(NmObjWordStrVToDocIdVH.Len(), 0);
857    TStrVIntPrV WordStrVFqPrV(NmObjWordStrVToDocIdVH.Len(), 0);
858    for (int NmObjId=0; NmObjId&lt;NmObjWordStrVToDocIdVH.Len(); NmObjId++){
859      int Fq=NmObjWordStrVToDocIdVH[NmObjId].Len();
860      const TStrV&amp; WordStrV=NmObjWordStrVToDocIdVH.GetKey(NmObjId);
861      FqWordStrVPrV.Add(TIntStrVPr(Fq, WordStrV));
862      WordStrVFqPrV.Add(TStrVIntPr(WordStrV, Fq));
863    }
864    FqWordStrVPrV.Sort(false);
865    WordStrVFqPrV.Sort();
866    if (!FqFNm.Empty()){
867      printf(&quot;Saving by frequency to &#x27;%s&#x27; ...&quot;, FqFNm.CStr());
868      TFOut SOut(FqFNm); FILE* fOut=SOut.GetFileId();
869      for (int PrN=0; PrN&lt;FqWordStrVPrV.Len(); PrN++){
870        int Fq=FqWordStrVPrV[PrN].Val1;
871        TStrV&amp; WordStrV=FqWordStrVPrV[PrN].Val2;
872        TStr WordStrVStr=GetWordStrVStr(WordStrV);
873        fprintf(fOut, &quot;%d - %s\n&quot;, Fq, WordStrVStr.CStr());
874      }
875      printf(&quot; Done.\n&quot;);
876    }
877    if (!SwFNm.Empty()){
878      printf(&quot;Saving by frequency for stop-words proposal to &#x27;%s&#x27; ...&quot;, SwFNm.CStr());
879      TFOut SOut(SwFNm); FILE* fOut=SOut.GetFileId();
880      for (int PrN=0; PrN&lt;FqWordStrVPrV.Len(); PrN++){
881        TStrV&amp; WordStrV=FqWordStrVPrV[PrN].Val2;
882        TStr WordStrVStr=GetWordStrVStr(WordStrV, &#x27; &#x27;);
883        fprintf(fOut, &quot;%s\n&quot;, WordStrVStr.CStr());
884      }
885      printf(&quot; Done.\n&quot;);
886    }
887    if (!AbcFNm.Empty()){
888      printf(&quot;Saving by alphabet to &#x27;%s&#x27; ...&quot;, AbcFNm.CStr());
889      TFOut SOut(AbcFNm); FILE* fOut=SOut.GetFileId();
890      for (int PrN=0; PrN&lt;WordStrVFqPrV.Len(); PrN++){
891        TStrV&amp; WordStrV=WordStrVFqPrV[PrN].Val1;
892        int Fq=WordStrVFqPrV[PrN].Val2;
893        TStr WordStrVStr=GetWordStrVStr(WordStrV);
894        fprintf(fOut, &quot;%s - %d [&quot;, WordStrVStr.CStr(), Fq);
895        int NmObjId=GetNmObjId(WordStrV);
896        TIntV DocIdV;
897        GetNmObjDocIdV(NmObjId, DocIdV);
898        for (int DocIdN=0; DocIdN&lt;DocIdV.Len(); DocIdN++){
899          TStr DocNm=GetDocNm(DocIdV[DocIdN]);
900          fprintf(fOut, &quot;&#x27;%s&#x27; &quot;, DocNm.CStr());
901        }
902        fprintf(fOut, &quot;]\n&quot;);
903      }
904      printf(&quot; Done.\n&quot;);
905    }
906    if (!DocFNm.Empty()){
907      printf(&quot;Saving by documents to &#x27;%s&#x27; ...&quot;, DocFNm.CStr());
908      TFOut SOut(DocFNm); FILE* fOut=SOut.GetFileId();
909      for (int DocId=0; DocId&lt;GetDocs(); DocId++){
910        TStr DocNm=GetDocNm(DocId);
911        fprintf(fOut, &quot;&#x27;%s&#x27;(%d):&quot;, DocNm.CStr(), DocId);
912        TStr DateStr=GetDocDateStr(DocId);
913        if (!DateStr.Empty()){
914          fprintf(fOut, &quot;[%s]&quot;, DateStr.CStr());}
915        int DocNmObjs=GetDocNmObjs(DocId);
916        for (int DocNmObjN=0; DocNmObjN&lt;DocNmObjs; DocNmObjN++){
917          int NmObjId; int TermFq; GetDocNmObjId(DocId, DocNmObjN, NmObjId, TermFq);
918          TStr NmObjStr=GetNmObjStr(NmObjId);
919          fprintf(fOut, &quot; [%s:%d]&quot;, NmObjStr.CStr(), TermFq);
920        }
921        fprintf(fOut, &quot;\n&quot;);
922      }
923      printf(&quot; Done.\n&quot;);
924    }
925  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-nmobj.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-nmobj.cpp</div>
                </div>
                <div class="column column_space"><pre><code>768    TIntIntH NmObjIdToFqH;
769    int NmObjDocs=GetNmObjDocs(TargetNmObjId);
770    for (int NmObjDocIdN=0; NmObjDocIdN&lt;NmObjDocs; NmObjDocIdN++){
771      int DocId=GetNmObjDocId(TargetNmObjId, NmObjDocIdN);
</pre></code></div>
                <div class="column column_space"><pre><code>820      TStrV WordStrV;
821      int DocNmObjs=GetDocNmObjs(DocId);
822      for (int DocNmObjN=0; DocNmObjN&lt;DocNmObjs; DocNmObjN++){
823        int NmObjId; int TermFq; GetDocNmObjId(DocId, DocNmObjN, NmObjId, TermFq);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    