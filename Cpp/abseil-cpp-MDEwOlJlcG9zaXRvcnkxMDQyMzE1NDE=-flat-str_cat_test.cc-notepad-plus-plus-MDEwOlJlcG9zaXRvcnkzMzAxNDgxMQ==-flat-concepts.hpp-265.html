
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-str_cat_test.cc</h3>
            <pre><code>1  #include &quot;absl/strings/str_cat.h&quot;
2  #include &lt;cstdint&gt;
3  #include &lt;string&gt;
4  #include &lt;vector&gt;
5  #include &quot;gtest/gtest.h&quot;
6  #include &quot;absl/strings/str_format.h&quot;
7  #include &quot;absl/strings/substitute.h&quot;
8  #ifdef __ANDROID__
9  #define ABSL_EXPECT_DEBUG_DEATH(statement, regex) \
10    EXPECT_DEBUG_DEATH(statement, &quot;.*&quot;)
11  #else
12  #define ABSL_EXPECT_DEBUG_DEATH(statement, regex) \
13    EXPECT_DEBUG_DEATH(statement, regex)
14  #endif
15  namespace {
16  TEST(StrCat, Ints) {
17    const short s = -1;  
18    const uint16_t us = 2;
19    const int i = -3;
20    const unsigned int ui = 4;
21    const long l = -5;                 
22    const unsigned long ul = 6;        
23    const long long ll = -7;           
24    const unsigned long long ull = 8;  
25    const ptrdiff_t ptrdiff = -9;
26    const size_t size = 10;
27    const intptr_t intptr = -12;
28    const uintptr_t uintptr = 13;
29    std::string answer;
30    answer = absl::StrCat(s, us);
31    EXPECT_EQ(answer, &quot;-12&quot;);
32    answer = absl::StrCat(i, ui);
33    EXPECT_EQ(answer, &quot;-34&quot;);
34    answer = absl::StrCat(l, ul);
35    EXPECT_EQ(answer, &quot;-56&quot;);
36    answer = absl::StrCat(ll, ull);
37    EXPECT_EQ(answer, &quot;-78&quot;);
38    answer = absl::StrCat(ptrdiff, size);
39    EXPECT_EQ(answer, &quot;-910&quot;);
40    answer = absl::StrCat(ptrdiff, intptr);
41    EXPECT_EQ(answer, &quot;-9-12&quot;);
42    answer = absl::StrCat(uintptr, 0);
43    EXPECT_EQ(answer, &quot;130&quot;);
44  }
45  TEST(StrCat, Enums) {
46    enum SmallNumbers { One = 1, Ten = 10 } e = Ten;
47    EXPECT_EQ(&quot;10&quot;, absl::StrCat(e));
48    EXPECT_EQ(&quot;-5&quot;, absl::StrCat(SmallNumbers(-5)));
49    enum class Option { Boxers = 1, Briefs = -1 };
50    EXPECT_EQ(&quot;-1&quot;, absl::StrCat(Option::Briefs));
51    enum class Airplane : uint64_t {
52      Airbus = 1,
53      Boeing = 1000,
54      Canary = 10000000000  
55    };
56    EXPECT_EQ(&quot;10000000000&quot;, absl::StrCat(Airplane::Canary));
57    enum class TwoGig : int32_t {
58      TwoToTheZero = 1,
59      TwoToTheSixteenth = 1 &lt;&lt; 16,
60      TwoToTheThirtyFirst = INT32_MIN
61    };
62    EXPECT_EQ(&quot;65536&quot;, absl::StrCat(TwoGig::TwoToTheSixteenth));
63    EXPECT_EQ(&quot;-2147483648&quot;, absl::StrCat(TwoGig::TwoToTheThirtyFirst));
64    EXPECT_EQ(&quot;-1&quot;, absl::StrCat(static_cast&lt;TwoGig&gt;(-1)));
65    enum class FourGig : uint32_t {
66      TwoToTheZero = 1,
67      TwoToTheSixteenth = 1 &lt;&lt; 16,
68      TwoToTheThirtyFirst = 1U &lt;&lt; 31  
69    };
70    EXPECT_EQ(&quot;65536&quot;, absl::StrCat(FourGig::TwoToTheSixteenth));
71    EXPECT_EQ(&quot;2147483648&quot;, absl::StrCat(FourGig::TwoToTheThirtyFirst));
72    EXPECT_EQ(&quot;4294967295&quot;, absl::StrCat(static_cast&lt;FourGig&gt;(-1)));
73    EXPECT_EQ(&quot;10000000000&quot;, absl::StrCat(Airplane::Canary));
74  }
75  TEST(StrCat, Basics) {
76    std::string result;
77    std::string strs[] = {&quot;Hello&quot;, &quot;Cruel&quot;, &quot;World&quot;};
78    std::string stdstrs[] = {
79      &quot;std::Hello&quot;,
80      &quot;std::Cruel&quot;,
81      &quot;std::World&quot;
82    };
83    absl::string_view pieces[] = {&quot;Hello&quot;, &quot;Cruel&quot;, &quot;World&quot;};
84    const char* c_strs[] = {
85      &quot;Hello&quot;,
86      &quot;Cruel&quot;,
87      &quot;World&quot;
88    };
89    int32_t i32s[] = {&#x27;H&#x27;, &#x27;C&#x27;, &#x27;W&#x27;};
90    uint64_t ui64s[] = {12345678910LL, 10987654321LL};
91    EXPECT_EQ(absl::StrCat(), &quot;&quot;);
92    result = absl::StrCat(false, true, 2, 3);
93    EXPECT_EQ(result, &quot;0123&quot;);
94    result = absl::StrCat(-1);
95    EXPECT_EQ(result, &quot;-1&quot;);
96    result = absl::StrCat(absl::SixDigits(0.5));
97    EXPECT_EQ(result, &quot;0.5&quot;);
98    result = absl::StrCat(strs[1], pieces[2]);
99    EXPECT_EQ(result, &quot;CruelWorld&quot;);
100    result = absl::StrCat(stdstrs[1], &quot; &quot;, stdstrs[2]);
101    EXPECT_EQ(result, &quot;std::Cruel std::World&quot;);
102    result = absl::StrCat(strs[0], &quot;, &quot;, pieces[2]);
103    EXPECT_EQ(result, &quot;Hello, World&quot;);
104    result = absl::StrCat(strs[0], &quot;, &quot;, strs[1], &quot; &quot;, strs[2], &quot;!&quot;);
105    EXPECT_EQ(result, &quot;Hello, Cruel World!&quot;);
106    result = absl::StrCat(pieces[0], &quot;, &quot;, pieces[1], &quot; &quot;, pieces[2]);
107    EXPECT_EQ(result, &quot;Hello, Cruel World&quot;);
108    result = absl::StrCat(c_strs[0], &quot;, &quot;, c_strs[1], &quot; &quot;, c_strs[2]);
109    EXPECT_EQ(result, &quot;Hello, Cruel World&quot;);
110    result = absl::StrCat(&quot;ASCII &quot;, i32s[0], &quot;, &quot;, i32s[1], &quot; &quot;, i32s[2], &quot;!&quot;);
111    EXPECT_EQ(result, &quot;ASCII 72, 67 87!&quot;);
112    result = absl::StrCat(ui64s[0], &quot;, &quot;, ui64s[1], &quot;!&quot;);
113    EXPECT_EQ(result, &quot;12345678910, 10987654321!&quot;);
114    std::string one =
115        &quot;1&quot;;  
116    result = absl::StrCat(&quot;And a &quot;, one.size(), &quot; and a &quot;,
117                          &amp;result[2] - &amp;result[0], &quot; and a &quot;, one, &quot; 2 3 4&quot;, &quot;!&quot;);
118    EXPECT_EQ(result, &quot;And a 1 and a 2 and a 1 2 3 4!&quot;);
119    result =
120        absl::StrCat(&quot;To output a char by ASCII/numeric value, use +: &quot;, &#x27;!&#x27; + 0);
121    EXPECT_EQ(result, &quot;To output a char by ASCII/numeric value, use +: 33&quot;);
122    float f = 100000.5;
123    result = absl::StrCat(&quot;A hundred K and a half is &quot;, absl::SixDigits(f));
124    EXPECT_EQ(result, &quot;A hundred K and a half is 100000&quot;);
125    f = 100001.5;
126    result =
127        absl::StrCat(&quot;A hundred K and one and a half is &quot;, absl::SixDigits(f));
128    EXPECT_EQ(result, &quot;A hundred K and one and a half is 100002&quot;);
129    double d = 100000.5;
130    d *= d;
131    result =
132        absl::StrCat(&quot;A hundred K and a half squared is &quot;, absl::SixDigits(d));
133    EXPECT_EQ(result, &quot;A hundred K and a half squared is 1.00001e+10&quot;);
134    result = absl::StrCat(1, 2, 333, 4444, 55555, 666666, 7777777, 88888888,
135                          999999999);
136    EXPECT_EQ(result, &quot;12333444455555666666777777788888888999999999&quot;);
137  }
138  TEST(StrCat, CornerCases) {
139    std::string result;
140    result = absl::StrCat(&quot;&quot;);  
141    EXPECT_EQ(result, &quot;&quot;);
142    result = absl::StrCat(&quot;&quot;, &quot;&quot;);
143    EXPECT_EQ(result, &quot;&quot;);
144    result = absl::StrCat(&quot;&quot;, &quot;&quot;, &quot;&quot;);
145    EXPECT_EQ(result, &quot;&quot;);
146    result = absl::StrCat(&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;);
147    EXPECT_EQ(result, &quot;&quot;);
148    result = absl::StrCat(&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;);
149    EXPECT_EQ(result, &quot;&quot;);
150  }
151  TEST(StrCat, NullConstCharPtr) {
152    const char* null = nullptr;
153    EXPECT_EQ(absl::StrCat(&quot;mon&quot;, null, &quot;key&quot;), &quot;monkey&quot;);
154  }
155  template &lt;typename T&gt;
156  struct Mallocator {
157    typedef T value_type;
158    typedef size_t size_type;
159    typedef ptrdiff_t difference_type;
160    typedef T* pointer;
161    typedef const T* const_pointer;
162    typedef T&amp; reference;
163    typedef const T&amp; const_reference;
164    size_type max_size() const {
165      return size_t(std::numeric_limits&lt;size_type&gt;::max()) / sizeof(value_type);
166    }
167    template &lt;typename U&gt;
168    struct rebind {
169      typedef Mallocator&lt;U&gt; other;
170    };
171    Mallocator() = default;
<span onclick='openModal()' class='match'>172    template &lt;class U&gt;
173    Mallocator(const Mallocator&lt;U&gt;&amp;) {}  
174    T* allocate(size_t n) { return static_cast&lt;T*&gt;(std::malloc(n * sizeof(T))); }
</span>175    void deallocate(T* p, size_t) { std::free(p); }
176  };
177  template &lt;typename T, typename U&gt;
178  bool operator==(const Mallocator&lt;T&gt;&amp;, const Mallocator&lt;U&gt;&amp;) {
179    return true;
180  }
181  template &lt;typename T, typename U&gt;
182  bool operator!=(const Mallocator&lt;T&gt;&amp;, const Mallocator&lt;U&gt;&amp;) {
183    return false;
184  }
185  TEST(StrCat, CustomAllocator) {
186    using mstring =
187        std::basic_string&lt;char, std::char_traits&lt;char&gt;, Mallocator&lt;char&gt;&gt;;
188    const mstring str1(&quot;PARACHUTE OFF A BLIMP INTO MOSCONE!!&quot;);
189    const mstring str2(&quot;Read this book about coffee tables&quot;);
190    std::string result = absl::StrCat(str1, str2);
191    EXPECT_EQ(result,
192              &quot;PARACHUTE OFF A BLIMP INTO MOSCONE!!&quot;
193              &quot;Read this book about coffee tables&quot;);
194  }
195  TEST(StrCat, MaxArgs) {
196    std::string result;
197    result = absl::StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, &quot;a&quot;);
198    EXPECT_EQ(result, &quot;123456789a&quot;);
199    result = absl::StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, &quot;a&quot;, &quot;b&quot;);
200    EXPECT_EQ(result, &quot;123456789ab&quot;);
201    result = absl::StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
202    EXPECT_EQ(result, &quot;123456789abc&quot;);
203    result = absl::StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;);
204    EXPECT_EQ(result, &quot;123456789abcd&quot;);
205    result = absl::StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;);
206    EXPECT_EQ(result, &quot;123456789abcde&quot;);
207    result =
208        absl::StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;);
209    EXPECT_EQ(result, &quot;123456789abcdef&quot;);
210    result = absl::StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;,
211                          &quot;g&quot;);
212    EXPECT_EQ(result, &quot;123456789abcdefg&quot;);
213    result = absl::StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;,
214                          &quot;g&quot;, &quot;h&quot;);
215    EXPECT_EQ(result, &quot;123456789abcdefgh&quot;);
216    result = absl::StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;,
217                          &quot;g&quot;, &quot;h&quot;, &quot;i&quot;);
218    EXPECT_EQ(result, &quot;123456789abcdefghi&quot;);
219    result = absl::StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;,
220                          &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;);
221    EXPECT_EQ(result, &quot;123456789abcdefghij&quot;);
222    result = absl::StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;,
223                          &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;);
224    EXPECT_EQ(result, &quot;123456789abcdefghijk&quot;);
225    result = absl::StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;,
226                          &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;);
227    EXPECT_EQ(result, &quot;123456789abcdefghijkl&quot;);
228    result = absl::StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;,
229                          &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;);
230    EXPECT_EQ(result, &quot;123456789abcdefghijklm&quot;);
231    result = absl::StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;,
232                          &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;, &quot;n&quot;);
233    EXPECT_EQ(result, &quot;123456789abcdefghijklmn&quot;);
234    result = absl::StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;,
235                          &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;, &quot;n&quot;, &quot;o&quot;);
236    EXPECT_EQ(result, &quot;123456789abcdefghijklmno&quot;);
237    result = absl::StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;,
238                          &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;, &quot;n&quot;, &quot;o&quot;, &quot;p&quot;);
239    EXPECT_EQ(result, &quot;123456789abcdefghijklmnop&quot;);
240    result = absl::StrCat(1, 2, 3, 4, 5, 6, 7, 8, 9, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;,
241                          &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;, &quot;n&quot;, &quot;o&quot;, &quot;p&quot;, &quot;q&quot;);
242    EXPECT_EQ(result, &quot;123456789abcdefghijklmnopq&quot;);
243    result = absl::StrCat(
244        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;,
245        &quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;, &quot;n&quot;, &quot;o&quot;, &quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot;, &quot;u&quot;, &quot;v&quot;, &quot;w&quot;,
246        &quot;x&quot;, &quot;y&quot;, &quot;z&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;,
247        &quot;M&quot;, &quot;N&quot;, &quot;O&quot;, &quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;);
248    EXPECT_EQ(result,
249              &quot;12345678910abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;);
250  }
251  TEST(StrAppend, Basics) {
252    std::string result = &quot;existing text&quot;;
253    std::string strs[] = {&quot;Hello&quot;, &quot;Cruel&quot;, &quot;World&quot;};
254    std::string stdstrs[] = {
255      &quot;std::Hello&quot;,
256      &quot;std::Cruel&quot;,
257      &quot;std::World&quot;
258    };
259    absl::string_view pieces[] = {&quot;Hello&quot;, &quot;Cruel&quot;, &quot;World&quot;};
260    const char* c_strs[] = {
261      &quot;Hello&quot;,
262      &quot;Cruel&quot;,
263      &quot;World&quot;
264    };
265    int32_t i32s[] = {&#x27;H&#x27;, &#x27;C&#x27;, &#x27;W&#x27;};
266    uint64_t ui64s[] = {12345678910LL, 10987654321LL};
267    std::string::size_type old_size = result.size();
268    absl::StrAppend(&amp;result);
269    EXPECT_EQ(result.size(), old_size);
270    old_size = result.size();
271    absl::StrAppend(&amp;result, strs[0]);
272    EXPECT_EQ(result.substr(old_size), &quot;Hello&quot;);
273    old_size = result.size();
274    absl::StrAppend(&amp;result, strs[1], pieces[2]);
275    EXPECT_EQ(result.substr(old_size), &quot;CruelWorld&quot;);
276    old_size = result.size();
277    absl::StrAppend(&amp;result, stdstrs[0], &quot;, &quot;, pieces[2]);
278    EXPECT_EQ(result.substr(old_size), &quot;std::Hello, World&quot;);
279    old_size = result.size();
280    absl::StrAppend(&amp;result, strs[0], &quot;, &quot;, stdstrs[1], &quot; &quot;, strs[2], &quot;!&quot;);
281    EXPECT_EQ(result.substr(old_size), &quot;Hello, std::Cruel World!&quot;);
282    old_size = result.size();
283    absl::StrAppend(&amp;result, pieces[0], &quot;, &quot;, pieces[1], &quot; &quot;, pieces[2]);
284    EXPECT_EQ(result.substr(old_size), &quot;Hello, Cruel World&quot;);
285    old_size = result.size();
286    absl::StrAppend(&amp;result, c_strs[0], &quot;, &quot;, c_strs[1], &quot; &quot;, c_strs[2]);
287    EXPECT_EQ(result.substr(old_size), &quot;Hello, Cruel World&quot;);
288    old_size = result.size();
289    absl::StrAppend(&amp;result, &quot;ASCII &quot;, i32s[0], &quot;, &quot;, i32s[1], &quot; &quot;, i32s[2], &quot;!&quot;);
290    EXPECT_EQ(result.substr(old_size), &quot;ASCII 72, 67 87!&quot;);
291    old_size = result.size();
292    absl::StrAppend(&amp;result, ui64s[0], &quot;, &quot;, ui64s[1], &quot;!&quot;);
293    EXPECT_EQ(result.substr(old_size), &quot;12345678910, 10987654321!&quot;);
294    std::string one =
295        &quot;1&quot;;  
296    old_size = result.size();
297    absl::StrAppend(&amp;result, &quot;And a &quot;, one.size(), &quot; and a &quot;,
298                    &amp;result[2] - &amp;result[0], &quot; and a &quot;, one, &quot; 2 3 4&quot;, &quot;!&quot;);
299    EXPECT_EQ(result.substr(old_size), &quot;And a 1 and a 2 and a 1 2 3 4!&quot;);
300    old_size = result.size();
301    absl::StrAppend(&amp;result,
302                    &quot;To output a char by ASCII/numeric value, use +: &quot;, &#x27;!&#x27; + 0);
303    EXPECT_EQ(result.substr(old_size),
304              &quot;To output a char by ASCII/numeric value, use +: 33&quot;);
305    old_size = result.size();
306    absl::StrAppend(&amp;result, 1, 22, 333, 4444, 55555, 666666, 7777777, 88888888,
307                    9);
308    EXPECT_EQ(result.substr(old_size), &quot;1223334444555556666667777777888888889&quot;);
309    old_size = result.size();
310    absl::StrAppend(
311        &amp;result, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,                           
312        &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;, &quot;m&quot;,  
313        &quot;n&quot;, &quot;o&quot;, &quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;s&quot;, &quot;t&quot;, &quot;u&quot;, &quot;v&quot;, &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;,  
314        &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;,  
315        &quot;N&quot;, &quot;O&quot;, &quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;,  
316        &quot;No limit thanks to C++11&#x27;s variadic templates&quot;);
317    EXPECT_EQ(result.substr(old_size),
318              &quot;12345678910abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;
319              &quot;No limit thanks to C++11&#x27;s variadic templates&quot;);
320  }
321  TEST(StrCat, VectorBoolReferenceTypes) {
322    std::vector&lt;bool&gt; v;
323    v.push_back(true);
324    v.push_back(false);
325    std::vector&lt;bool&gt; const&amp; cv = v;
326    std::string result = absl::StrCat(v[0], v[1], cv[0], cv[1]); 
327    EXPECT_EQ(result, &quot;1010&quot;);
328  }
329  TEST(StrCat, AvoidsMemcpyWithNullptr) {
330    EXPECT_EQ(absl::StrCat(42, absl::string_view{}), &quot;42&quot;);
331    EXPECT_EQ(absl::StrCat(1, 2, 3, 4, 5, absl::string_view{}), &quot;12345&quot;);
332    std::string result;
333    absl::StrAppend(&amp;result, 1, 2, 3, 4, 5, absl::string_view{});
334    EXPECT_EQ(result, &quot;12345&quot;);
335  }
336  #if GTEST_HAS_DEATH_TEST
337  TEST(StrAppend, Death) {
338    std::string s = &quot;self&quot;;
339    ABSL_EXPECT_DEBUG_DEATH(absl::StrAppend(&amp;s, s.c_str() + 1),
340                            &quot;ssertion.*failed&quot;);
341    ABSL_EXPECT_DEBUG_DEATH(absl::StrAppend(&amp;s, s), &quot;ssertion.*failed&quot;);
342  }
343  #endif  
344  TEST(StrAppend, CornerCases) {
345    std::string result;
346    absl::StrAppend(&amp;result, &quot;&quot;);
347    EXPECT_EQ(result, &quot;&quot;);
348    absl::StrAppend(&amp;result, &quot;&quot;, &quot;&quot;);
349    EXPECT_EQ(result, &quot;&quot;);
350    absl::StrAppend(&amp;result, &quot;&quot;, &quot;&quot;, &quot;&quot;);
351    EXPECT_EQ(result, &quot;&quot;);
352    absl::StrAppend(&amp;result, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;);
353    EXPECT_EQ(result, &quot;&quot;);
354    absl::StrAppend(&amp;result, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;);
355    EXPECT_EQ(result, &quot;&quot;);
356  }
357  TEST(StrAppend, CornerCasesNonEmptyAppend) {
358    for (std::string result : {&quot;hello&quot;, &quot;a string too long to fit in the SSO&quot;}) {
359      const std::string expected = result;
360      absl::StrAppend(&amp;result, &quot;&quot;);
361      EXPECT_EQ(result, expected);
362      absl::StrAppend(&amp;result, &quot;&quot;, &quot;&quot;);
363      EXPECT_EQ(result, expected);
364      absl::StrAppend(&amp;result, &quot;&quot;, &quot;&quot;, &quot;&quot;);
365      EXPECT_EQ(result, expected);
366      absl::StrAppend(&amp;result, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;);
367      EXPECT_EQ(result, expected);
368      absl::StrAppend(&amp;result, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;);
369      EXPECT_EQ(result, expected);
370    }
371  }
372  template &lt;typename IntType&gt;
373  void CheckHex(IntType v, const char* nopad_format, const char* zeropad_format,
374                const char* spacepad_format) {
375    char expected[256];
376    std::string actual = absl::StrCat(absl::Hex(v, absl::kNoPad));
377    snprintf(expected, sizeof(expected), nopad_format, v);
378    EXPECT_EQ(expected, actual) &lt;&lt; &quot; decimal value &quot; &lt;&lt; v;
379    for (int spec = absl::kZeroPad2; spec &lt;= absl::kZeroPad20; ++spec) {
380      std::string actual =
381          absl::StrCat(absl::Hex(v, static_cast&lt;absl::PadSpec&gt;(spec)));
382      snprintf(expected, sizeof(expected), zeropad_format,
383               spec - absl::kZeroPad2 + 2, v);
384      EXPECT_EQ(expected, actual) &lt;&lt; &quot; decimal value &quot; &lt;&lt; v;
385    }
386    for (int spec = absl::kSpacePad2; spec &lt;= absl::kSpacePad20; ++spec) {
387      std::string actual =
388          absl::StrCat(absl::Hex(v, static_cast&lt;absl::PadSpec&gt;(spec)));
389      snprintf(expected, sizeof(expected), spacepad_format,
390               spec - absl::kSpacePad2 + 2, v);
391      EXPECT_EQ(expected, actual) &lt;&lt; &quot; decimal value &quot; &lt;&lt; v;
392    }
393  }
394  template &lt;typename IntType&gt;
395  void CheckDec(IntType v, const char* nopad_format, const char* zeropad_format,
396                const char* spacepad_format) {
397    char expected[256];
398    std::string actual = absl::StrCat(absl::Dec(v, absl::kNoPad));
399    snprintf(expected, sizeof(expected), nopad_format, v);
400    EXPECT_EQ(expected, actual) &lt;&lt; &quot; decimal value &quot; &lt;&lt; v;
401    for (int spec = absl::kZeroPad2; spec &lt;= absl::kZeroPad20; ++spec) {
402      std::string actual =
403          absl::StrCat(absl::Dec(v, static_cast&lt;absl::PadSpec&gt;(spec)));
404      snprintf(expected, sizeof(expected), zeropad_format,
405               spec - absl::kZeroPad2 + 2, v);
406      EXPECT_EQ(expected, actual)
407          &lt;&lt; &quot; decimal value &quot; &lt;&lt; v &lt;&lt; &quot; format &#x27;&quot; &lt;&lt; zeropad_format
408          &lt;&lt; &quot;&#x27; digits &quot; &lt;&lt; (spec - absl::kZeroPad2 + 2);
409    }
410    for (int spec = absl::kSpacePad2; spec &lt;= absl::kSpacePad20; ++spec) {
411      std::string actual =
412          absl::StrCat(absl::Dec(v, static_cast&lt;absl::PadSpec&gt;(spec)));
413      snprintf(expected, sizeof(expected), spacepad_format,
414               spec - absl::kSpacePad2 + 2, v);
415      EXPECT_EQ(expected, actual)
416          &lt;&lt; &quot; decimal value &quot; &lt;&lt; v &lt;&lt; &quot; format &#x27;&quot; &lt;&lt; spacepad_format
417          &lt;&lt; &quot;&#x27; digits &quot; &lt;&lt; (spec - absl::kSpacePad2 + 2);
418    }
419  }
420  void CheckHexDec64(uint64_t v) {
421    unsigned long long ullv = v;  
422    CheckHex(ullv, &quot;%llx&quot;, &quot;%0*llx&quot;, &quot;%*llx&quot;);
423    CheckDec(ullv, &quot;%llu&quot;, &quot;%0*llu&quot;, &quot;%*llu&quot;);
424    long long llv = static_cast&lt;long long&gt;(ullv);  
425    CheckDec(llv, &quot;%lld&quot;, &quot;%0*lld&quot;, &quot;%*lld&quot;);
426    if (sizeof(v) == sizeof(&amp;v)) {
427      auto uintptr = static_cast&lt;uintptr_t&gt;(v);
428      void* ptr = reinterpret_cast&lt;void*&gt;(uintptr);
429      CheckHex(ptr, &quot;%llx&quot;, &quot;%0*llx&quot;, &quot;%*llx&quot;);
430    }
431  }
432  void CheckHexDec32(uint32_t uv) {
433    CheckHex(uv, &quot;%x&quot;, &quot;%0*x&quot;, &quot;%*x&quot;);
434    CheckDec(uv, &quot;%u&quot;, &quot;%0*u&quot;, &quot;%*u&quot;);
435    int32_t v = static_cast&lt;int32_t&gt;(uv);
436    CheckDec(v, &quot;%d&quot;, &quot;%0*d&quot;, &quot;%*d&quot;);
437    if (sizeof(v) == sizeof(&amp;v)) {
438      auto uintptr = static_cast&lt;uintptr_t&gt;(v);
439      void* ptr = reinterpret_cast&lt;void*&gt;(uintptr);
440      CheckHex(ptr, &quot;%x&quot;, &quot;%0*x&quot;, &quot;%*x&quot;);
441    }
442  }
443  void CheckAll(uint64_t v) {
444    CheckHexDec64(v);
445    CheckHexDec32(static_cast&lt;uint32_t&gt;(v));
446  }
447  void TestFastPrints() {
448    for (int i = 0; i &lt; 10000; i++) {
449      CheckAll(i);
450    }
451    CheckAll(std::numeric_limits&lt;uint64_t&gt;::max());
452    CheckAll(std::numeric_limits&lt;uint64_t&gt;::max() - 1);
453    CheckAll(std::numeric_limits&lt;int64_t&gt;::min());
454    CheckAll(std::numeric_limits&lt;int64_t&gt;::min() + 1);
455    CheckAll(std::numeric_limits&lt;uint32_t&gt;::max());
456    CheckAll(std::numeric_limits&lt;uint32_t&gt;::max() - 1);
457    CheckAll(std::numeric_limits&lt;int32_t&gt;::min());
458    CheckAll(std::numeric_limits&lt;int32_t&gt;::min() + 1);
459    CheckAll(999999999);              
460    CheckAll(1000000000);             
461    CheckAll(9999999999);             
462    CheckAll(10000000000);            
463    CheckAll(999999999999999999);     
464    CheckAll(9999999999999999999u);   
465    CheckAll(1000000000000000000);    
466    CheckAll(10000000000000000000u);  
467    CheckAll(999999999876543210);    
468    CheckAll(9999999999876543210u);  
469    CheckAll(0x123456789abcdef0);    
470    CheckAll(0x12345678);
471    int8_t minus_one_8bit = -1;
472    EXPECT_EQ(&quot;ff&quot;, absl::StrCat(absl::Hex(minus_one_8bit)));
473    int16_t minus_one_16bit = -1;
474    EXPECT_EQ(&quot;ffff&quot;, absl::StrCat(absl::Hex(minus_one_16bit)));
475  }
476  TEST(Numbers, TestFunctionsMovedOverFromNumbersMain) {
477    TestFastPrints();
478  }
479  struct PointStringify {
480    template &lt;typename FormatSink&gt;
481    friend void AbslStringify(FormatSink&amp; sink, const PointStringify&amp; p) {
482      sink.Append(&quot;(&quot;);
483      sink.Append(absl::StrCat(p.x));
484      sink.Append(&quot;, &quot;);
485      sink.Append(absl::StrCat(p.y));
486      sink.Append(&quot;)&quot;);
487    }
488    double x = 10.0;
489    double y = 20.0;
490  };
491  TEST(StrCat, AbslStringifyExample) {
492    PointStringify p;
493    EXPECT_EQ(absl::StrCat(p), &quot;(10, 20)&quot;);
494    EXPECT_EQ(absl::StrCat(&quot;a &quot;, p, &quot; z&quot;), &quot;a (10, 20) z&quot;);
495  }
496  struct PointStringifyUsingFormat {
497    template &lt;typename FormatSink&gt;
498    friend void AbslStringify(FormatSink&amp; sink,
499                              const PointStringifyUsingFormat&amp; p) {
500      absl::Format(&amp;sink, &quot;(%g, %g)&quot;, p.x, p.y);
501    }
502    double x = 10.0;
503    double y = 20.0;
504  };
505  TEST(StrCat, AbslStringifyExampleUsingFormat) {
506    PointStringifyUsingFormat p;
507    EXPECT_EQ(absl::StrCat(p), &quot;(10, 20)&quot;);
508    EXPECT_EQ(absl::StrCat(&quot;a &quot;, p, &quot; z&quot;), &quot;a (10, 20) z&quot;);
509  }
510  enum class EnumWithStringify { Many = 0, Choices = 1 };
511  template &lt;typename Sink&gt;
512  void AbslStringify(Sink&amp; sink, EnumWithStringify e) {
513    absl::Format(&amp;sink, &quot;%s&quot;, e == EnumWithStringify::Many ? &quot;Many&quot; : &quot;Choices&quot;);
514  }
515  TEST(StrCat, AbslStringifyWithEnum) {
516    const auto e = EnumWithStringify::Choices;
517    EXPECT_EQ(absl::StrCat(e), &quot;Choices&quot;);
518  }
519  }  
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-concepts.hpp</h3>
            <pre><code>1  #ifndef BOOST_REGEX_CONCEPTS_HPP_INCLUDED
2  #define BOOST_REGEX_CONCEPTS_HPP_INCLUDED
3  #include &lt;boost/concept_archetype.hpp&gt;
4  #include &lt;boost/concept_check.hpp&gt;
5  #include &lt;boost/type_traits/is_enum.hpp&gt;
6  #include &lt;boost/type_traits/is_base_and_derived.hpp&gt;
7  #include &lt;boost/static_assert.hpp&gt;
8  #ifndef BOOST_TEST_TR1_REGEX
9  #include &lt;boost/regex.hpp&gt;
10  #endif
11  #include &lt;bitset&gt;
12  #include &lt;vector&gt;
13  #include &lt;ostream&gt;
14  #ifdef BOOST_REGEX_CXX03
15  #define RW_NS boost
16  #else
17  #define RW_NS std
18  #endif
19  namespace boost{
20  typedef std::bitset&lt;512&gt; bitmask_archetype;
21  struct char_architype
22  {
23     char_architype();
24     char_architype(const char_architype&amp;);
25     char_architype&amp; operator=(const char_architype&amp;);
26     char_architype(unsigned long val);
27     bool operator==(const char_architype&amp;)const;
28     bool operator!=(const char_architype&amp;)const;
29     bool operator&lt;(const char_architype&amp;)const;
30     bool operator&lt;=(const char_architype&amp;)const;
31     bool operator&gt;=(const char_architype&amp;)const;
32     bool operator&gt;(const char_architype&amp;)const;
33     operator long()const;
34  };
35  inline long hash_value(char_architype val)
36  {  return val;  }
37  } 
38  namespace std{
39     template&lt;&gt; struct char_traits&lt;boost::char_architype&gt;
40     {
41        typedef boost::char_architype char_type;
42     };
43  }
44  template &lt;class T&gt;
45  class allocator_architype
46  {
47  public:
48     typedef T* pointer;
49     typedef const T* const_pointer;
50     typedef T&amp; reference;
51     typedef const T&amp; const_reference;
52     typedef T value_type;
53     typedef unsigned size_type;
54     typedef int difference_type;
55     template &lt;class U&gt;
56     struct rebind
57     {
58        typedef allocator_architype&lt;U&gt; other;
59     };
60     pointer address(reference r){ return &amp;r; }
61     const_pointer address(const_reference r) { return &amp;r; }
62     pointer allocate(size_type n) { return static_cast&lt;pointer&gt;(std::malloc(n)); }
63     pointer allocate(size_type n, pointer) { return static_cast&lt;pointer&gt;(std::malloc(n)); }
64     void deallocate(pointer p, size_type) { std::free(p); }
65     size_type max_size()const { return UINT_MAX; }
66     allocator_architype(){}
67     allocator_architype(const allocator_architype&amp;){}
<span onclick='openModal()' class='match'>68     template &lt;class Other&gt;
69     allocator_architype(const allocator_architype&lt;Other&gt;&amp;){}
70     void construct(pointer p, const_reference r) { new (p)T(r); }
</span>71     void destroy(pointer p) { p-&gt;~T(); }
72  };
73  template &lt;class T&gt;
74  bool operator == (const allocator_architype&lt;T&gt;&amp;, const allocator_architype&lt;T&gt;&amp;) {return true; }
75  template &lt;class T&gt;
76  bool operator != (const allocator_architype&lt;T&gt;&amp;, const allocator_architype&lt;T&gt;&amp;) { return false; }
77  namespace boost{
78  template &lt;class charT&gt;
79  struct regex_traits_architype
80  {
81  public:
82     regex_traits_architype(){}
83     typedef charT char_type;
84     typedef std::vector&lt;char_type&gt; string_type;
85     typedef copy_constructible_archetype&lt;assignable_archetype&lt;&gt; &gt; locale_type;
86     typedef bitmask_archetype char_class_type;
87     static std::size_t length(const char_type* ) { return 0; }
88     charT translate(charT ) const { return charT(); }
89     charT translate_nocase(charT ) const { return static_object&lt;charT&gt;::get(); }
90     template &lt;class ForwardIterator&gt;
91     string_type transform(ForwardIterator , ForwardIterator ) const
92     { return static_object&lt;string_type&gt;::get(); }
93     template &lt;class ForwardIterator&gt;
94     string_type transform_primary(ForwardIterator , ForwardIterator ) const
95     { return static_object&lt;string_type&gt;::get(); }
96     template &lt;class ForwardIterator&gt;
97     char_class_type lookup_classname(ForwardIterator , ForwardIterator ) const
98     { return static_object&lt;char_class_type&gt;::get(); }
99     template &lt;class ForwardIterator&gt;
100     string_type lookup_collatename(ForwardIterator , ForwardIterator ) const
101     { return static_object&lt;string_type&gt;::get(); }
102     bool isctype(charT, char_class_type) const
103     { return false; }
104     int value(charT, int) const
105     { return 0; }
106     locale_type imbue(locale_type l)
107     { return l; }
108     locale_type getloc()const
109     { return static_object&lt;locale_type&gt;::get(); }
110  private:
111     regex_traits_architype(const regex_traits_architype&amp;){}
112     regex_traits_architype&amp; operator=(const regex_traits_architype&amp;){ return *this; }
113  };
114  #ifndef BOOST_TEST_TR1_REGEX
115  namespace global_regex_namespace = ::boost;
116  #else
117  namespace global_regex_namespace = ::std::tr1;
118  #endif
119  template &lt;class Bitmask&gt;
120  struct BitmaskConcept
121  {
122     void constraints() 
123     {
124        function_requires&lt;CopyConstructibleConcept&lt;Bitmask&gt; &gt;();
125        function_requires&lt;AssignableConcept&lt;Bitmask&gt; &gt;();
126        m_mask1 = m_mask2 | m_mask3;
127        m_mask1 = m_mask2 &amp; m_mask3;
128        m_mask1 = m_mask2 ^ m_mask3;
129        m_mask1 = ~m_mask2;
130        m_mask1 |= m_mask2;
131        m_mask1 &amp;= m_mask2;
132        m_mask1 ^= m_mask2;
133     }
134     Bitmask m_mask1, m_mask2, m_mask3;
135  };
136  template &lt;class traits&gt;
137  struct RegexTraitsConcept
138  {
139     RegexTraitsConcept();
140     typedef typename traits::char_type char_type;
141     typedef typename traits::string_type string_type;
142     typedef typename traits::locale_type locale_type;
143     typedef typename traits::char_class_type char_class_type;
144     void constraints() 
145     {
146        function_requires&lt;RandomAccessContainerConcept&lt;string_type&gt; &gt;();
147        function_requires&lt;DefaultConstructibleConcept&lt;locale_type&gt; &gt;();
148        function_requires&lt;CopyConstructibleConcept&lt;locale_type&gt; &gt;();
149        function_requires&lt;AssignableConcept&lt;locale_type&gt; &gt;();
150        function_requires&lt;BitmaskConcept&lt;char_class_type&gt; &gt;();
151        std::size_t n = traits::length(m_pointer);
152        ignore_unused_variable_warning(n);
153        char_type c = m_ctraits.translate(m_char);
154        ignore_unused_variable_warning(c);
155        c = m_ctraits.translate_nocase(m_char);
156        string_type s1 = m_ctraits.transform(m_pointer, m_pointer);
157        ignore_unused_variable_warning(s1);
158        string_type s2 = m_ctraits.transform_primary(m_pointer, m_pointer);
159        ignore_unused_variable_warning(s2);
160        char_class_type cc = m_ctraits.lookup_classname(m_pointer, m_pointer);
161        ignore_unused_variable_warning(cc);
162        string_type s3 = m_ctraits.lookup_collatename(m_pointer, m_pointer);
163        ignore_unused_variable_warning(s3);
164        bool b = m_ctraits.isctype(m_char, cc);
165        ignore_unused_variable_warning(b);
166        int v = m_ctraits.value(m_char, 16);
167        ignore_unused_variable_warning(v);
168        locale_type l(m_ctraits.getloc());
169        m_traits.imbue(l);
170        ignore_unused_variable_warning(l);
171     }
172     traits m_traits;
173     const traits m_ctraits;
174     const char_type* m_pointer;
175     char_type m_char;
176  private:
177     RegexTraitsConcept&amp; operator=(RegexTraitsConcept&amp;);
178  };
179  template &lt;class Regex&gt;
180  struct regex_traits_computer;
181  template &lt;class charT, class traits&gt;
182  struct regex_traits_computer&lt; global_regex_namespace::basic_regex&lt;charT, traits&gt; &gt;
183  {
184     typedef traits type;
185  };
186  template &lt;class Regex&gt;
187  struct BaseRegexConcept
188  {
189     typedef typename Regex::value_type value_type;
190     typedef typename Regex::flag_type flag_type;
191     typedef typename Regex::locale_type locale_type;
192     typedef input_iterator_archetype&lt;value_type&gt; input_iterator_type;
193     typedef const value_type* pointer_type;
194     typedef bidirectional_iterator_archetype&lt;value_type&gt; BidiIterator;
195     typedef global_regex_namespace::sub_match&lt;BidiIterator&gt; sub_match_type;
196     typedef global_regex_namespace::match_results&lt;BidiIterator, allocator_architype&lt;sub_match_type&gt; &gt; match_results_type;
197     typedef global_regex_namespace::match_results&lt;BidiIterator&gt; match_results_default_type;
198     typedef output_iterator_archetype&lt;value_type&gt; OutIterator;
199     typedef typename regex_traits_computer&lt;Regex&gt;::type traits_type;
200     typedef global_regex_namespace::regex_iterator&lt;BidiIterator, value_type, traits_type&gt; regex_iterator_type;
201     typedef global_regex_namespace::regex_token_iterator&lt;BidiIterator, value_type, traits_type&gt; regex_token_iterator_type;
202     void global_constraints()
203     {
204        function_requires&lt;BitmaskConcept&lt;global_regex_namespace::regex_constants::syntax_option_type&gt; &gt;();
205        global_regex_namespace::regex_constants::syntax_option_type opts
206           = global_regex_namespace::regex_constants::icase
207           | global_regex_namespace::regex_constants::nosubs
208           | global_regex_namespace::regex_constants::optimize
209           | global_regex_namespace::regex_constants::collate
210           | global_regex_namespace::regex_constants::ECMAScript
211           | global_regex_namespace::regex_constants::basic
212           | global_regex_namespace::regex_constants::extended
213           | global_regex_namespace::regex_constants::awk
214           | global_regex_namespace::regex_constants::grep
215           | global_regex_namespace::regex_constants::egrep;
216        ignore_unused_variable_warning(opts);
217        function_requires&lt;BitmaskConcept&lt;global_regex_namespace::regex_constants::match_flag_type&gt; &gt;();
218        global_regex_namespace::regex_constants::match_flag_type mopts
219           = global_regex_namespace::regex_constants::match_default
220           | global_regex_namespace::regex_constants::match_not_bol
221           | global_regex_namespace::regex_constants::match_not_eol
222           | global_regex_namespace::regex_constants::match_not_bow
223           | global_regex_namespace::regex_constants::match_not_eow
224           | global_regex_namespace::regex_constants::match_any
225           | global_regex_namespace::regex_constants::match_not_null
226           | global_regex_namespace::regex_constants::match_continuous
227           | global_regex_namespace::regex_constants::match_prev_avail
228           | global_regex_namespace::regex_constants::format_default
229           | global_regex_namespace::regex_constants::format_sed
230           | global_regex_namespace::regex_constants::format_no_copy
231           | global_regex_namespace::regex_constants::format_first_only;
232        ignore_unused_variable_warning(mopts);
233        BOOST_STATIC_ASSERT((::boost::is_enum&lt;global_regex_namespace::regex_constants::error_type&gt;::value));
234        global_regex_namespace::regex_constants::error_type e1 = global_regex_namespace::regex_constants::error_collate;
235        ignore_unused_variable_warning(e1);
236        e1 = global_regex_namespace::regex_constants::error_ctype;
237        ignore_unused_variable_warning(e1);
238        e1 = global_regex_namespace::regex_constants::error_escape;
239        ignore_unused_variable_warning(e1);
240        e1 = global_regex_namespace::regex_constants::error_backref;
241        ignore_unused_variable_warning(e1);
242        e1 = global_regex_namespace::regex_constants::error_brack;
243        ignore_unused_variable_warning(e1);
244        e1 = global_regex_namespace::regex_constants::error_paren;
245        ignore_unused_variable_warning(e1);
246        e1 = global_regex_namespace::regex_constants::error_brace;
247        ignore_unused_variable_warning(e1);
248        e1 = global_regex_namespace::regex_constants::error_badbrace;
249        ignore_unused_variable_warning(e1);
250        e1 = global_regex_namespace::regex_constants::error_range;
251        ignore_unused_variable_warning(e1);
252        e1 = global_regex_namespace::regex_constants::error_space;
253        ignore_unused_variable_warning(e1);
254        e1 = global_regex_namespace::regex_constants::error_badrepeat;
255        ignore_unused_variable_warning(e1);
256        e1 = global_regex_namespace::regex_constants::error_complexity;
257        ignore_unused_variable_warning(e1);
258        e1 = global_regex_namespace::regex_constants::error_stack;
259        ignore_unused_variable_warning(e1);
260        BOOST_STATIC_ASSERT((::boost::is_base_and_derived&lt;std::runtime_error, global_regex_namespace::regex_error&gt;::value  ));
261        const global_regex_namespace::regex_error except(e1);
262        e1 = except.code();
263        typedef typename Regex::value_type regex_value_type;
264        function_requires&lt; RegexTraitsConcept&lt;global_regex_namespace::regex_traits&lt;char&gt; &gt; &gt;();
265        function_requires&lt; BaseRegexConcept&lt;global_regex_namespace::basic_regex&lt;char&gt; &gt; &gt;();
266     }
267     void constraints() 
268     {
269        global_constraints();
270        BOOST_STATIC_ASSERT((::boost::is_same&lt; flag_type, global_regex_namespace::regex_constants::syntax_option_type&gt;::value));
271        flag_type opts
272           = Regex::icase
273           | Regex::nosubs
274           | Regex::optimize
275           | Regex::collate
276           | Regex::ECMAScript
277           | Regex::basic
278           | Regex::extended
279           | Regex::awk
280           | Regex::grep
281           | Regex::egrep;
282        ignore_unused_variable_warning(opts);
283        function_requires&lt;DefaultConstructibleConcept&lt;Regex&gt; &gt;();
284        function_requires&lt;CopyConstructibleConcept&lt;Regex&gt; &gt;();
285        Regex e1(m_pointer);
286        ignore_unused_variable_warning(e1);
287        Regex e2(m_pointer, m_flags);
288        ignore_unused_variable_warning(e2);
289        Regex e3(m_pointer, m_size, m_flags);
290        ignore_unused_variable_warning(e3);
291        Regex e4(in1, in2);
292        ignore_unused_variable_warning(e4);
293        Regex e5(in1, in2, m_flags);
294        ignore_unused_variable_warning(e5);
295        Regex e;
296        e = m_pointer;
297        e = e1;
298        e.assign(e1);
299        e.assign(m_pointer);
300        e.assign(m_pointer, m_flags);
301        e.assign(m_pointer, m_size, m_flags);
302        e.assign(in1, in2);
303        e.assign(in1, in2, m_flags);
304        const Regex ce;
305        typename Regex::size_type i = ce.mark_count();
306        ignore_unused_variable_warning(i);
307        m_flags = ce.flags();
308        e.imbue(ce.getloc());
309        e.swap(e1);
310        global_regex_namespace::swap(e, e1);
311        BOOST_STATIC_ASSERT((::boost::is_base_and_derived&lt;std::pair&lt;BidiIterator, BidiIterator&gt;, sub_match_type&gt;::value));
312        typedef typename sub_match_type::value_type sub_value_type;
313        typedef typename sub_match_type::difference_type sub_diff_type;
314        typedef typename sub_match_type::iterator sub_iter_type;
315        BOOST_STATIC_ASSERT((::boost::is_same&lt;sub_value_type, value_type&gt;::value));
316        BOOST_STATIC_ASSERT((::boost::is_same&lt;sub_iter_type, BidiIterator&gt;::value));
317        bool b = m_sub.matched;
318        ignore_unused_variable_warning(b);
319        BidiIterator bi = m_sub.first;
320        ignore_unused_variable_warning(bi);
321        bi = m_sub.second;
322        ignore_unused_variable_warning(bi);
323        sub_diff_type diff = m_sub.length();
324        ignore_unused_variable_warning(diff);
325        typedef typename match_results_type::value_type mr_value_type;
326        typedef typename match_results_type::const_reference mr_const_reference;
327        typedef typename match_results_type::reference mr_reference;
328        typedef typename match_results_type::const_iterator mr_const_iterator;
329        typedef typename match_results_type::iterator mr_iterator;
330        typedef typename match_results_type::difference_type mr_difference_type;
331        typedef typename match_results_type::size_type mr_size_type;
332        typedef typename match_results_type::allocator_type mr_allocator_type;
333        typedef typename match_results_type::char_type mr_char_type;
334        typedef typename match_results_type::string_type mr_string_type;
335        match_results_type m1;
336        mr_allocator_type at;
337        match_results_type m2(at);
338        match_results_type m3(m1);
339        m1 = m2;
340        int ival = 0;
341        mr_size_type mrs = m_cresults.size();
342        ignore_unused_variable_warning(mrs);
343        mrs = m_cresults.max_size();
344        ignore_unused_variable_warning(mrs);
345        b = m_cresults.empty();
346        ignore_unused_variable_warning(b);
347        mr_difference_type mrd = m_cresults.length();
348        ignore_unused_variable_warning(mrd);
349        mrd = m_cresults.length(ival);
350        ignore_unused_variable_warning(mrd);
351        mrd = m_cresults.position();
352        ignore_unused_variable_warning(mrd);
353        mrd = m_cresults.position(mrs);
354        ignore_unused_variable_warning(mrd);
355        mr_const_reference mrcr = m_cresults[ival];
356        ignore_unused_variable_warning(mrcr);
357        mr_const_reference mrcr2 = m_cresults.prefix();
358        ignore_unused_variable_warning(mrcr2);
359        mr_const_reference mrcr3 = m_cresults.suffix();
360        ignore_unused_variable_warning(mrcr3);
361        mr_const_iterator mrci = m_cresults.begin();
362        ignore_unused_variable_warning(mrci);
363        mrci = m_cresults.end();
364        ignore_unused_variable_warning(mrci);
365        (void) m_cresults.get_allocator();
366        m_results.swap(m_results);
367        global_regex_namespace::swap(m_results, m_results);
368        b = global_regex_namespace::regex_match(m_in, m_in, m_results, e);
369        ignore_unused_variable_warning(b);
370        b = global_regex_namespace::regex_match(m_in, m_in, m_results, e, m_mft);
371        ignore_unused_variable_warning(b);
372        b = global_regex_namespace::regex_match(m_in, m_in, e);
373        ignore_unused_variable_warning(b);
374        b = global_regex_namespace::regex_match(m_in, m_in, e, m_mft);
375        ignore_unused_variable_warning(b);
376        b = global_regex_namespace::regex_match(m_pointer, m_pmatch, e);
377        ignore_unused_variable_warning(b);
378        b = global_regex_namespace::regex_match(m_pointer, m_pmatch, e, m_mft);
379        ignore_unused_variable_warning(b);
380        b = global_regex_namespace::regex_match(m_pointer, e);
381        ignore_unused_variable_warning(b);
382        b = global_regex_namespace::regex_match(m_pointer, e, m_mft);
383        ignore_unused_variable_warning(b);
384        b = global_regex_namespace::regex_search(m_in, m_in, m_results, e);
385        ignore_unused_variable_warning(b);
386        b = global_regex_namespace::regex_search(m_in, m_in, m_results, e, m_mft);
387        ignore_unused_variable_warning(b);
388        b = global_regex_namespace::regex_search(m_in, m_in, e);
389        ignore_unused_variable_warning(b);
390        b = global_regex_namespace::regex_search(m_in, m_in, e, m_mft);
391        ignore_unused_variable_warning(b);
392        b = global_regex_namespace::regex_search(m_pointer, m_pmatch, e);
393        ignore_unused_variable_warning(b);
394        b = global_regex_namespace::regex_search(m_pointer, m_pmatch, e, m_mft);
395        ignore_unused_variable_warning(b);
396        b = global_regex_namespace::regex_search(m_pointer, e);
397        ignore_unused_variable_warning(b);
398        b = global_regex_namespace::regex_search(m_pointer, e, m_mft);
399        ignore_unused_variable_warning(b);
400        typedef typename regex_iterator_type::regex_type rit_regex_type;
401        typedef typename regex_iterator_type::value_type rit_value_type;
402        typedef typename regex_iterator_type::difference_type rit_difference_type;
403        typedef typename regex_iterator_type::pointer rit_pointer;
404        typedef typename regex_iterator_type::reference rit_reference;
405        typedef typename regex_iterator_type::iterator_category rit_iterator_category;
406        BOOST_STATIC_ASSERT((::boost::is_same&lt;rit_regex_type, Regex&gt;::value));
407        BOOST_STATIC_ASSERT((::boost::is_same&lt;rit_value_type, match_results_default_type&gt;::value));
408        BOOST_STATIC_ASSERT((::boost::is_same&lt;rit_difference_type, std::ptrdiff_t&gt;::value));
409        BOOST_STATIC_ASSERT((::boost::is_same&lt;rit_pointer, const match_results_default_type*&gt;::value));
410        BOOST_STATIC_ASSERT((::boost::is_same&lt;rit_reference, const match_results_default_type&amp;&gt;::value));
411        BOOST_STATIC_ASSERT((::boost::is_convertible&lt;rit_iterator_category*, std::forward_iterator_tag*&gt;::value));
412        function_requires&lt;ForwardIteratorConcept&lt;regex_iterator_type&gt; &gt;();
413        regex_iterator_type iter1(m_in, m_in, e);
414        ignore_unused_variable_warning(iter1);
415        regex_iterator_type iter2(m_in, m_in, e, m_mft);
416        ignore_unused_variable_warning(iter2);
417        typedef typename regex_token_iterator_type::regex_type rtit_regex_type;
418        typedef typename regex_token_iterator_type::value_type rtit_value_type;
419        typedef typename regex_token_iterator_type::difference_type rtit_difference_type;
420        typedef typename regex_token_iterator_type::pointer rtit_pointer;
421        typedef typename regex_token_iterator_type::reference rtit_reference;
422        typedef typename regex_token_iterator_type::iterator_category rtit_iterator_category;
423        BOOST_STATIC_ASSERT((::boost::is_same&lt;rtit_regex_type, Regex&gt;::value));
424        BOOST_STATIC_ASSERT((::boost::is_same&lt;rtit_value_type, sub_match_type&gt;::value));
425        BOOST_STATIC_ASSERT((::boost::is_same&lt;rtit_difference_type, std::ptrdiff_t&gt;::value));
426        BOOST_STATIC_ASSERT((::boost::is_same&lt;rtit_pointer, const sub_match_type*&gt;::value));
427        BOOST_STATIC_ASSERT((::boost::is_same&lt;rtit_reference, const sub_match_type&amp;&gt;::value));
428        BOOST_STATIC_ASSERT((::boost::is_convertible&lt;rtit_iterator_category*, std::forward_iterator_tag*&gt;::value));
429        function_requires&lt;ForwardIteratorConcept&lt;regex_token_iterator_type&gt; &gt;();
430        regex_token_iterator_type ti1(m_in, m_in, e);
431        ignore_unused_variable_warning(ti1);
432        regex_token_iterator_type ti2(m_in, m_in, e, 0);
433        ignore_unused_variable_warning(ti2);
434        regex_token_iterator_type ti3(m_in, m_in, e, 0, m_mft);
435        ignore_unused_variable_warning(ti3);
436        std::vector&lt;int&gt; subs;
437        regex_token_iterator_type ti4(m_in, m_in, e, subs);
438        ignore_unused_variable_warning(ti4);
439        regex_token_iterator_type ti5(m_in, m_in, e, subs, m_mft);
440        ignore_unused_variable_warning(ti5);
441        static const int i_array[3] = { 1, 2, 3, };
442        regex_token_iterator_type ti6(m_in, m_in, e, i_array);
443        ignore_unused_variable_warning(ti6);
444        regex_token_iterator_type ti7(m_in, m_in, e, i_array, m_mft);
445        ignore_unused_variable_warning(ti7);
446     }
447     pointer_type m_pointer;
448     flag_type m_flags;
449     std::size_t m_size;
450     input_iterator_type in1, in2;
451     const sub_match_type m_sub;
452     const value_type m_char;
453     match_results_type m_results;
454     const match_results_type m_cresults;
455     OutIterator m_out;
456     BidiIterator m_in;
457     global_regex_namespace::regex_constants::match_flag_type m_mft;
458     global_regex_namespace::match_results&lt;
459        pointer_type, 
460        allocator_architype&lt;global_regex_namespace::sub_match&lt;pointer_type&gt; &gt; &gt; 
461        m_pmatch;
462     BaseRegexConcept();
463     BaseRegexConcept(const BaseRegexConcept&amp;);
464     BaseRegexConcept&amp; operator=(const BaseRegexConcept&amp;);
465  };
466  template &lt;class Regex&gt;
467  struct RegexConcept
468  {
469     typedef typename Regex::value_type value_type;
470     typedef typename Regex::flag_type flag_type;
471     typedef typename Regex::locale_type locale_type;
472     typedef const value_type* pointer_type;
473     typedef std::basic_string&lt;value_type&gt; string_type;
474     typedef boost::bidirectional_iterator_archetype&lt;value_type&gt; BidiIterator;
475     typedef global_regex_namespace::sub_match&lt;BidiIterator&gt; sub_match_type;
476     typedef global_regex_namespace::match_results&lt;BidiIterator, allocator_architype&lt;sub_match_type&gt; &gt; match_results_type;
477     typedef output_iterator_archetype&lt;value_type&gt; OutIterator;
478     void constraints() 
479     {
480        function_requires&lt;BaseRegexConcept&lt;Regex&gt; &gt;();
481        Regex e1(m_string);
482        ignore_unused_variable_warning(e1);
483        Regex e2(m_string, m_flags);
484        ignore_unused_variable_warning(e2);
485        Regex e;
486        e = m_string;
487        e.assign(m_string);
488        e.assign(m_string, m_flags);
489        string_type s(m_sub);
490        ignore_unused_variable_warning(s);
491        s = m_sub.str();
492        ignore_unused_variable_warning(s);
493        int i = m_sub.compare(m_string);
494        ignore_unused_variable_warning(i);
495        int i2 = m_sub.compare(m_sub);
496        ignore_unused_variable_warning(i2);
497        i2 = m_sub.compare(m_pointer);
498        ignore_unused_variable_warning(i2);
499        bool b = m_sub == m_sub;
500        ignore_unused_variable_warning(b);
501        b = m_sub != m_sub;
502        ignore_unused_variable_warning(b);
503        b = m_sub &lt;= m_sub;
504        ignore_unused_variable_warning(b);
505        b = m_sub &lt;= m_sub;
506        ignore_unused_variable_warning(b);
507        b = m_sub &gt; m_sub;
508        ignore_unused_variable_warning(b);
509        b = m_sub &gt;= m_sub;
510        ignore_unused_variable_warning(b);
511        b = m_sub == m_pointer;
512        ignore_unused_variable_warning(b);
513        b = m_sub != m_pointer;
514        ignore_unused_variable_warning(b);
515        b = m_sub &lt;= m_pointer;
516        ignore_unused_variable_warning(b);
517        b = m_sub &lt;= m_pointer;
518        ignore_unused_variable_warning(b);
519        b = m_sub &gt; m_pointer;
520        ignore_unused_variable_warning(b);
521        b = m_sub &gt;= m_pointer;
522        ignore_unused_variable_warning(b);
523        b = m_pointer == m_sub;
524        ignore_unused_variable_warning(b);
525        b = m_pointer != m_sub;
526        ignore_unused_variable_warning(b);
527        b = m_pointer &lt;= m_sub;
528        ignore_unused_variable_warning(b);
529        b = m_pointer &lt;= m_sub;
530        ignore_unused_variable_warning(b);
531        b = m_pointer &gt; m_sub;
532        ignore_unused_variable_warning(b);
533        b = m_pointer &gt;= m_sub;
534        ignore_unused_variable_warning(b);
535        b = m_sub == m_char;
536        ignore_unused_variable_warning(b);
537        b = m_sub != m_char;
538        ignore_unused_variable_warning(b);
539        b = m_sub &lt;= m_char;
540        ignore_unused_variable_warning(b);
541        b = m_sub &lt;= m_char;
542        ignore_unused_variable_warning(b);
543        b = m_sub &gt; m_char;
544        ignore_unused_variable_warning(b);
545        b = m_sub &gt;= m_char;
546        ignore_unused_variable_warning(b);
547        b = m_char == m_sub;
548        ignore_unused_variable_warning(b);
549        b = m_char != m_sub;
550        ignore_unused_variable_warning(b);
551        b = m_char &lt;= m_sub;
552        ignore_unused_variable_warning(b);
553        b = m_char &lt;= m_sub;
554        ignore_unused_variable_warning(b);
555        b = m_char &gt; m_sub;
556        ignore_unused_variable_warning(b);
557        b = m_char &gt;= m_sub;
558        ignore_unused_variable_warning(b);
559        b = m_sub == m_string;
560        ignore_unused_variable_warning(b);
561        b = m_sub != m_string;
562        ignore_unused_variable_warning(b);
563        b = m_sub &lt;= m_string;
564        ignore_unused_variable_warning(b);
565        b = m_sub &lt;= m_string;
566        ignore_unused_variable_warning(b);
567        b = m_sub &gt; m_string;
568        ignore_unused_variable_warning(b);
569        b = m_sub &gt;= m_string;
570        ignore_unused_variable_warning(b);
571        b = m_string == m_sub;
572        ignore_unused_variable_warning(b);
573        b = m_string != m_sub;
574        ignore_unused_variable_warning(b);
575        b = m_string &lt;= m_sub;
576        ignore_unused_variable_warning(b);
577        b = m_string &lt;= m_sub;
578        ignore_unused_variable_warning(b);
579        b = m_string &gt; m_sub;
580        ignore_unused_variable_warning(b);
581        b = m_string &gt;= m_sub;
582        ignore_unused_variable_warning(b);
583        m_string = m_results.str();
584        ignore_unused_variable_warning(m_string);
585        m_string = m_results.str(0);
586        ignore_unused_variable_warning(m_string);
587        m_out = m_cresults.format(m_out, m_string);
588        m_out = m_cresults.format(m_out, m_string, m_mft);
589        m_string = m_cresults.format(m_string);
590        ignore_unused_variable_warning(m_string);
591        m_string = m_cresults.format(m_string, m_mft);
592        ignore_unused_variable_warning(m_string);
593        b = global_regex_namespace::regex_match(m_string, m_smatch, e);
594        ignore_unused_variable_warning(b);
595        b = global_regex_namespace::regex_match(m_string, m_smatch, e, m_mft);
596        ignore_unused_variable_warning(b);
597        b = global_regex_namespace::regex_match(m_string, e);
598        ignore_unused_variable_warning(b);
599        b = global_regex_namespace::regex_match(m_string, e, m_mft);
600        ignore_unused_variable_warning(b);
601        b = global_regex_namespace::regex_search(m_string, m_smatch, e);
602        ignore_unused_variable_warning(b);
603        b = global_regex_namespace::regex_search(m_string, m_smatch, e, m_mft);
604        ignore_unused_variable_warning(b);
605        b = global_regex_namespace::regex_search(m_string, e);
606        ignore_unused_variable_warning(b);
607        b = global_regex_namespace::regex_search(m_string, e, m_mft);
608        ignore_unused_variable_warning(b);
609        m_out = global_regex_namespace::regex_replace(m_out, m_in, m_in, e, m_string, m_mft);
610        m_out = global_regex_namespace::regex_replace(m_out, m_in, m_in, e, m_string);
611        m_string = global_regex_namespace::regex_replace(m_string, e, m_string, m_mft);
612        ignore_unused_variable_warning(m_string);
613        m_string = global_regex_namespace::regex_replace(m_string, e, m_string);
614        ignore_unused_variable_warning(m_string);
615     }
616     flag_type m_flags;
617     string_type m_string;
618     const sub_match_type m_sub;
619     match_results_type m_results;
620     pointer_type m_pointer;
621     value_type m_char;
622     const match_results_type m_cresults;
623     OutIterator m_out;
624     BidiIterator m_in;
625     global_regex_namespace::regex_constants::match_flag_type m_mft;
626     global_regex_namespace::match_results&lt;typename string_type::const_iterator, allocator_architype&lt;global_regex_namespace::sub_match&lt;typename string_type::const_iterator&gt; &gt; &gt; m_smatch;
627     RegexConcept();
628     RegexConcept(const RegexConcept&amp;);
629     RegexConcept&amp; operator=(const RegexConcept&amp;);
630  };
631  #ifndef BOOST_REGEX_TEST_STD
632  template &lt;class M&gt;
633  struct functor1
634  {
635     typedef typename M::char_type char_type;
636     const char_type* operator()(const M&amp;)const
637     {
638        static const char_type c = static_cast&lt;char_type&gt;(0);
639        return &amp;c;
640     }
641  };
642  template &lt;class M&gt;
643  struct functor1b
644  {
645     typedef typename M::char_type char_type;
646     std::vector&lt;char_type&gt; operator()(const M&amp;)const
647     {
648        static const std::vector&lt;char_type&gt; c;
649        return c;
650     }
651  };
652  template &lt;class M&gt;
653  struct functor2
654  {
655     template &lt;class O&gt;
656     O operator()(const M&amp; &amp;bsol;*m*/, O i)const
657     {
658        return i;
659     }
660  };
661  template &lt;class M&gt;
662  struct functor3
663  {
664     template &lt;class O&gt;
665     O operator()(const M&amp; &amp;bsol;*m*/, O i, regex_constants::match_flag_type)const
666     {
667        return i;
668     }
669  };
670  template &lt;class Regex&gt;
671  struct BoostRegexConcept
672  {
673     typedef typename Regex::value_type value_type;
674     typedef typename Regex::size_type size_type;
675     typedef typename Regex::flag_type flag_type;
676     typedef typename Regex::locale_type locale_type;
677     typedef const value_type* pointer_type;
678     typedef std::basic_string&lt;value_type&gt; string_type;
679     typedef typename Regex::const_iterator const_iterator;
680     typedef bidirectional_iterator_archetype&lt;value_type&gt; BidiIterator;
681     typedef output_iterator_archetype&lt;value_type&gt; OutputIterator;
682     typedef global_regex_namespace::sub_match&lt;BidiIterator&gt; sub_match_type;
683     typedef global_regex_namespace::match_results&lt;BidiIterator, allocator_architype&lt;sub_match_type&gt; &gt; match_results_type;
684     typedef global_regex_namespace::match_results&lt;BidiIterator&gt; match_results_default_type;
685     void constraints() 
686     {
687        global_regex_namespace::regex_constants::match_flag_type mopts
688           = global_regex_namespace::regex_constants::match_default
689           | global_regex_namespace::regex_constants::match_not_bol
690           | global_regex_namespace::regex_constants::match_not_eol
691           | global_regex_namespace::regex_constants::match_not_bow
692           | global_regex_namespace::regex_constants::match_not_eow
693           | global_regex_namespace::regex_constants::match_any
694           | global_regex_namespace::regex_constants::match_not_null
695           | global_regex_namespace::regex_constants::match_continuous
696           | global_regex_namespace::regex_constants::match_partial
697           | global_regex_namespace::regex_constants::match_prev_avail
698           | global_regex_namespace::regex_constants::format_default
699           | global_regex_namespace::regex_constants::format_sed
700           | global_regex_namespace::regex_constants::format_perl
701           | global_regex_namespace::regex_constants::format_no_copy
702           | global_regex_namespace::regex_constants::format_first_only;
703        (void)mopts;
704        function_requires&lt;RegexConcept&lt;Regex&gt; &gt;();
705        const global_regex_namespace::regex_error except(global_regex_namespace::regex_constants::error_collate);
706        std::ptrdiff_t pt = except.position();
707        ignore_unused_variable_warning(pt);
708        const Regex ce, ce2;
709  #ifndef BOOST_NO_STD_LOCALE
710        m_stream &lt;&lt; ce;
711  #endif
712        unsigned i = ce.error_code();
713        ignore_unused_variable_warning(i);
714        pointer_type p = ce.expression();
715        ignore_unused_variable_warning(p);
716        int i2 = ce.compare(ce2);
717        ignore_unused_variable_warning(i2);
718        bool b = ce == ce2;
719        ignore_unused_variable_warning(b);
720        b = ce.empty();
721        ignore_unused_variable_warning(b);
722        b = ce != ce2;
723        ignore_unused_variable_warning(b);
724        b = ce &lt; ce2;
725        ignore_unused_variable_warning(b);
726        b = ce &gt; ce2;
727        ignore_unused_variable_warning(b);
728        b = ce &lt;= ce2;
729        ignore_unused_variable_warning(b);
730        b = ce &gt;= ce2;
731        ignore_unused_variable_warning(b);
732        i = ce.status();
733        ignore_unused_variable_warning(i);
734        size_type s = ce.max_size();
735        ignore_unused_variable_warning(s);
736        s = ce.size();
737        ignore_unused_variable_warning(s);
738        const_iterator pi = ce.begin();
739        ignore_unused_variable_warning(pi);
740        pi = ce.end();
741        ignore_unused_variable_warning(pi);
742        string_type s2 = ce.str();
743        ignore_unused_variable_warning(s2);
744        m_string = m_sub + m_sub;
745        ignore_unused_variable_warning(m_string);
746        m_string = m_sub + m_pointer;
747        ignore_unused_variable_warning(m_string);
748        m_string = m_pointer + m_sub;
749        ignore_unused_variable_warning(m_string);
750        m_string = m_sub + m_string;
751        ignore_unused_variable_warning(m_string);
752        m_string = m_string + m_sub;
753        ignore_unused_variable_warning(m_string);
754        m_string = m_sub + m_char;
755        ignore_unused_variable_warning(m_string);
756        m_string = m_char + m_sub;
757        ignore_unused_variable_warning(m_string);
758        m_sub = m_cresults[&amp;m_char];
759        ignore_unused_variable_warning(m_sub);
760        m_sub = m_cresults[m_string];
761        ignore_unused_variable_warning(m_sub);
762        m_sub = m_cresults[&quot;&quot;];
763        ignore_unused_variable_warning(m_sub);
764        m_sub = m_cresults[std::string(&quot;&quot;)];
765        ignore_unused_variable_warning(m_sub);
766        m_string = m_cresults.str(&amp;m_char);
767        ignore_unused_variable_warning(m_string);
768        m_string = m_cresults.str(m_string);
769        ignore_unused_variable_warning(m_string);
770        m_string = m_cresults.str(&quot;&quot;);
771        ignore_unused_variable_warning(m_string);
772        m_string = m_cresults.str(std::string(&quot;&quot;));
773        ignore_unused_variable_warning(m_string);
774        typename match_results_type::difference_type diff;
775        diff = m_cresults.length(&amp;m_char);
776        ignore_unused_variable_warning(diff);
777        diff = m_cresults.length(m_string);
778        ignore_unused_variable_warning(diff);
779        diff = m_cresults.length(&quot;&quot;);
780        ignore_unused_variable_warning(diff);
781        diff = m_cresults.length(std::string(&quot;&quot;));
782        ignore_unused_variable_warning(diff);
783        diff = m_cresults.position(&amp;m_char);
784        ignore_unused_variable_warning(diff);
785        diff = m_cresults.position(m_string);
786        ignore_unused_variable_warning(diff);
787        diff = m_cresults.position(&quot;&quot;);
788        ignore_unused_variable_warning(diff);
789        diff = m_cresults.position(std::string(&quot;&quot;));
790        ignore_unused_variable_warning(diff);
791  #ifndef BOOST_NO_STD_LOCALE
792        m_stream &lt;&lt; m_sub;
793        m_stream &lt;&lt; m_cresults;
794  #endif
795        regex_constants::match_flag_type f = regex_constants::match_default;
796        OutputIterator out = static_object&lt;OutputIterator&gt;::get();
797        functor3&lt;match_results_default_type&gt; func3;
798        functor2&lt;match_results_default_type&gt; func2;
799        functor1&lt;match_results_default_type&gt; func1;
800        functor3&lt;match_results_type&gt; func3b;
801        functor2&lt;match_results_type&gt; func2b;
802        functor1&lt;match_results_type&gt; func1b;
803        out = regex_format(out, m_cresults, func3b, f);
804        out = regex_format(out, m_cresults, func3b);
805        out = regex_format(out, m_cresults, func2b, f);
806        out = regex_format(out, m_cresults, func2b);
807        out = regex_format(out, m_cresults, func1b, f);
808        out = regex_format(out, m_cresults, func1b);
809        out = regex_format(out, m_cresults, RW_NS::ref(func3b), f);
810        out = regex_format(out, m_cresults, RW_NS::ref(func3b));
811        out = regex_format(out, m_cresults, RW_NS::ref(func2b), f);
812        out = regex_format(out, m_cresults, RW_NS::ref(func2b));
813        out = regex_format(out, m_cresults, RW_NS::ref(func1b), f);
814        out = regex_format(out, m_cresults, RW_NS::ref(func1b));
815        out = regex_format(out, m_cresults, RW_NS::cref(func3b), f);
816        out = regex_format(out, m_cresults, RW_NS::cref(func3b));
817        out = regex_format(out, m_cresults, RW_NS::cref(func2b), f);
818        out = regex_format(out, m_cresults, RW_NS::cref(func2b));
819        out = regex_format(out, m_cresults, RW_NS::cref(func1b), f);
820        out = regex_format(out, m_cresults, RW_NS::cref(func1b));
821        m_string += regex_format(m_cresults, func3b, f);
822        m_string += regex_format(m_cresults, func3b);
823        m_string += regex_format(m_cresults, func2b, f);
824        m_string += regex_format(m_cresults, func2b);
825        m_string += regex_format(m_cresults, func1b, f);
826        m_string += regex_format(m_cresults, func1b);
827        m_string += regex_format(m_cresults, RW_NS::ref(func3b), f);
828        m_string += regex_format(m_cresults, RW_NS::ref(func3b));
829        m_string += regex_format(m_cresults, RW_NS::ref(func2b), f);
830        m_string += regex_format(m_cresults, RW_NS::ref(func2b));
831        m_string += regex_format(m_cresults, RW_NS::ref(func1b), f);
832        m_string += regex_format(m_cresults, RW_NS::ref(func1b));
833        m_string += regex_format(m_cresults, RW_NS::cref(func3b), f);
834        m_string += regex_format(m_cresults, RW_NS::cref(func3b));
835        m_string += regex_format(m_cresults, RW_NS::cref(func2b), f);
836        m_string += regex_format(m_cresults, RW_NS::cref(func2b));
837        m_string += regex_format(m_cresults, RW_NS::cref(func1b), f);
838        m_string += regex_format(m_cresults, RW_NS::cref(func1b));
839        out = m_cresults.format(out, func3b, f);
840        out = m_cresults.format(out, func3b);
841        out = m_cresults.format(out, func2b, f);
842        out = m_cresults.format(out, func2b);
843        out = m_cresults.format(out, func1b, f);
844        out = m_cresults.format(out, func1b);
845        out = m_cresults.format(out, RW_NS::ref(func3b), f);
846        out = m_cresults.format(out, RW_NS::ref(func3b));
847        out = m_cresults.format(out, RW_NS::ref(func2b), f);
848        out = m_cresults.format(out, RW_NS::ref(func2b));
849        out = m_cresults.format(out, RW_NS::ref(func1b), f);
850        out = m_cresults.format(out, RW_NS::ref(func1b));
851        out = m_cresults.format(out, RW_NS::cref(func3b), f);
852        out = m_cresults.format(out, RW_NS::cref(func3b));
853        out = m_cresults.format(out, RW_NS::cref(func2b), f);
854        out = m_cresults.format(out, RW_NS::cref(func2b));
855        out = m_cresults.format(out, RW_NS::cref(func1b), f);
856        out = m_cresults.format(out, RW_NS::cref(func1b));
857        m_string += m_cresults.format(func3b, f);
858        m_string += m_cresults.format(func3b);
859        m_string += m_cresults.format(func2b, f);
860        m_string += m_cresults.format(func2b);
861        m_string += m_cresults.format(func1b, f);
862        m_string += m_cresults.format(func1b);
863        m_string += m_cresults.format(RW_NS::ref(func3b), f);
864        m_string += m_cresults.format(RW_NS::ref(func3b));
865        m_string += m_cresults.format(RW_NS::ref(func2b), f);
866        m_string += m_cresults.format(RW_NS::ref(func2b));
867        m_string += m_cresults.format(RW_NS::ref(func1b), f);
868        m_string += m_cresults.format(RW_NS::ref(func1b));
869        m_string += m_cresults.format(RW_NS::cref(func3b), f);
870        m_string += m_cresults.format(RW_NS::cref(func3b));
871        m_string += m_cresults.format(RW_NS::cref(func2b), f);
872        m_string += m_cresults.format(RW_NS::cref(func2b));
873        m_string += m_cresults.format(RW_NS::cref(func1b), f);
874        m_string += m_cresults.format(RW_NS::cref(func1b));
875        out = regex_replace(out, m_in, m_in, ce, func3, f);
876        out = regex_replace(out, m_in, m_in, ce, func3);
877        out = regex_replace(out, m_in, m_in, ce, func2, f);
878        out = regex_replace(out, m_in, m_in, ce, func2);
879        out = regex_replace(out, m_in, m_in, ce, func1, f);
880        out = regex_replace(out, m_in, m_in, ce, func1);
881        out = regex_replace(out, m_in, m_in, ce, RW_NS::ref(func3), f);
882        out = regex_replace(out, m_in, m_in, ce, RW_NS::ref(func3));
883        out = regex_replace(out, m_in, m_in, ce, RW_NS::ref(func2), f);
884        out = regex_replace(out, m_in, m_in, ce, RW_NS::ref(func2));
885        out = regex_replace(out, m_in, m_in, ce, RW_NS::ref(func1), f);
886        out = regex_replace(out, m_in, m_in, ce, RW_NS::ref(func1));
887        out = regex_replace(out, m_in, m_in, ce, RW_NS::cref(func3), f);
888        out = regex_replace(out, m_in, m_in, ce, RW_NS::cref(func3));
889        out = regex_replace(out, m_in, m_in, ce, RW_NS::cref(func2), f);
890        out = regex_replace(out, m_in, m_in, ce, RW_NS::cref(func2));
891        out = regex_replace(out, m_in, m_in, ce, RW_NS::cref(func1), f);
892        out = regex_replace(out, m_in, m_in, ce, RW_NS::cref(func1));
893        functor3&lt;match_results&lt;typename string_type::const_iterator&gt; &gt; func3s;
894        functor2&lt;match_results&lt;typename string_type::const_iterator&gt; &gt; func2s;
895        functor1&lt;match_results&lt;typename string_type::const_iterator&gt; &gt; func1s;
896        m_string += regex_replace(m_string, ce, func3s, f);
897        m_string += regex_replace(m_string, ce, func3s);
898        m_string += regex_replace(m_string, ce, func2s, f);
899        m_string += regex_replace(m_string, ce, func2s);
900        m_string += regex_replace(m_string, ce, func1s, f);
901        m_string += regex_replace(m_string, ce, func1s);
902        m_string += regex_replace(m_string, ce, RW_NS::ref(func3s), f);
903        m_string += regex_replace(m_string, ce, RW_NS::ref(func3s));
904        m_string += regex_replace(m_string, ce, RW_NS::ref(func2s), f);
905        m_string += regex_replace(m_string, ce, RW_NS::ref(func2s));
906        m_string += regex_replace(m_string, ce, RW_NS::ref(func1s), f);
907        m_string += regex_replace(m_string, ce, RW_NS::ref(func1s));
908        m_string += regex_replace(m_string, ce, RW_NS::cref(func3s), f);
909        m_string += regex_replace(m_string, ce, RW_NS::cref(func3s));
910        m_string += regex_replace(m_string, ce, RW_NS::cref(func2s), f);
911        m_string += regex_replace(m_string, ce, RW_NS::cref(func2s));
912        m_string += regex_replace(m_string, ce, RW_NS::cref(func1s), f);
913        m_string += regex_replace(m_string, ce, RW_NS::cref(func1s));
914     }
915     std::basic_ostream&lt;value_type&gt; m_stream;
916     sub_match_type m_sub;
917     pointer_type m_pointer;
918     string_type m_string;
919     const value_type m_char;
920     match_results_type m_results;
921     const match_results_type m_cresults;
922     BidiIterator m_in;
923     BoostRegexConcept();
924     BoostRegexConcept(const BoostRegexConcept&amp;);
925     BoostRegexConcept&amp; operator=(const BoostRegexConcept&amp;);
926  };
927  #endif 
928  }
929  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-str_cat_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-concepts.hpp</div>
                </div>
                <div class="column column_space"><pre><code>172    template &lt;class U&gt;
173    Mallocator(const Mallocator&lt;U&gt;&amp;) {}  
174    T* allocate(size_t n) { return static_cast&lt;T*&gt;(std::malloc(n * sizeof(T))); }
</pre></code></div>
                <div class="column column_space"><pre><code>68     template &lt;class Other&gt;
69     allocator_architype(const allocator_architype&lt;Other&gt;&amp;){}
70     void construct(pointer p, const_reference r) { new (p)T(r); }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    