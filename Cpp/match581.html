<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for TestPlatform.cpp &amp; ConfigurableDomain.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for TestPlatform.cpp &amp; ConfigurableDomain.cpp
      </h3>
<h1 align="center">
        2.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>TestPlatform.cpp (4.193548%)<th>ConfigurableDomain.cpp (1.7591339%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(360-378)<td><a href="#" name="0">(1190-1207)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>TestPlatform.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Copyright (c) 2011-2015, Intel Corporation
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation and/or
 * other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its contributors
 * may be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#include &lt;stdlib.h&gt;
#include &lt;sstream&gt;
#include &lt;assert.h&gt;
#include &lt;errno.h&gt;
#include &lt;convert.hpp&gt;
#include &lt;sstream&gt;
#include "TestPlatform.h"
using std::string;
CTestPlatform::CTestPlatform(const string &amp;strClass, uint16_t iPortNumber)
    : mParameterMgrPlatformConnector(strClass), mLogger(), mRemoteProcessorServer(iPortNumber)
{
    mParameterMgrPlatformConnector.setLogger(&amp;mLogger);
}
CTestPlatform::~CTestPlatform()
{
}
CTestPlatform::CommandReturn CTestPlatform::exit(const IRemoteCommand &amp; /*command*/,
                                                 string &amp; /*strResult*/)
{
    mRemoteProcessorServer.stop();
    return CTestPlatform::CCommandHandler::EDone;
}
bool CTestPlatform::run(std::string &amp;strError)
{
    if (!mRemoteProcessorServer.start(strError)) {
        strError = "TestPlatform: Unable to start remote processor server: " + strError;
        return false;
    }
    CCommandHandler commandHandler(this);
    commandHandler.addCommandParser("exit", &amp;CTestPlatform::exit, 0, "", "Exit TestPlatform");
    commandHandler.addCommandParser("createExclusiveSelectionCriterionFromStateList",
                                    &amp;CTestPlatform::createExclusiveSelectionCriterionFromStateList,
                                    2, "&lt;name&gt; &lt;stateList&gt;",
                                    "Create inclusive selection criterion from state name list");
    commandHandler.addCommandParser("createInclusiveSelectionCriterionFromStateList",
                                    &amp;CTestPlatform::createInclusiveSelectionCriterionFromStateList,
                                    2, "&lt;name&gt; &lt;stateList&gt;",
                                    "Create exclusive selection criterion from state name list");
    commandHandler.addCommandParser("createExclusiveSelectionCriterion",
                                    &amp;CTestPlatform::createExclusiveSelectionCriterion, 2,
                                    "&lt;name&gt; &lt;nbStates&gt;", "Create inclusive selection criterion");
    commandHandler.addCommandParser("createInclusiveSelectionCriterion",
                                    &amp;CTestPlatform::createInclusiveSelectionCriterion, 2,
                                    "&lt;name&gt; &lt;nbStates&gt;", "Create exclusive selection criterion");
    commandHandler.addCommandParser("start", &amp;CTestPlatform::startParameterMgr, 0, "",
                                    "Start ParameterMgr");
    commandHandler.addCommandParser("setCriterionState", &amp;CTestPlatform::setCriterionState, 2,
                                    "&lt;name&gt; &lt;state&gt;",
                                    "Set the current state of a selection criterion");
    commandHandler.addCommandParser(
        "applyConfigurations", &amp;CTestPlatform::applyConfigurations, 0, "",
        "Apply configurations selected by current selection criteria states");
    commandHandler.addCommandParser(
        "setFailureOnMissingSubsystem",
        &amp;CTestPlatform::setter&lt;&amp;CParameterMgrPlatformConnector::setFailureOnMissingSubsystem&gt;, 1,
        "true|false", "Set policy for missing subsystems, "
                      "either abort start or fallback on virtual subsystem.");
    commandHandler.addCommandParser(
        "getMissingSubsystemPolicy",
        &amp;CTestPlatform::getter&lt;&amp;CParameterMgrPlatformConnector::getFailureOnMissingSubsystem&gt;, 0,
        "", "Get policy for missing subsystems, "
            "either abort start or fallback on virtual subsystem.");
    commandHandler.addCommandParser(
        "setFailureOnFailedSettingsLoad",
        &amp;CTestPlatform::setter&lt;&amp;CParameterMgrPlatformConnector::setFailureOnFailedSettingsLoad&gt;, 1,
        "true|false",
        "Set policy for failed settings load, either abort start or continue without domains.");
    commandHandler.addCommandParser(
        "getFailedSettingsLoadPolicy",
        &amp;CTestPlatform::getter&lt;&amp;CParameterMgrPlatformConnector::getFailureOnFailedSettingsLoad&gt;, 0,
        "", "Get policy for failed settings load, either abort start or continue without domains.");
    commandHandler.addCommandParser(
        "setValidateSchemasOnStart",
        &amp;CTestPlatform::setter&lt;&amp;CParameterMgrPlatformConnector::setValidateSchemasOnStart&gt;, 1,
        "true|false", "Set policy for schema validation based on .xsd files (false by default).");
    commandHandler.addCommandParser(
        "getValidateSchemasOnStart",
        &amp;CTestPlatform::getter&lt;&amp;CParameterMgrPlatformConnector::getValidateSchemasOnStart&gt;, 0, "",
        "Get policy for schema validation based on .xsd files.");
    commandHandler.addCommandParser("getSchemaUri", &amp;CTestPlatform::getSchemaUri, 0, "",
                                    "Get the directory where schemas can be found.");
    commandHandler.addCommandParser("setSchemaUri", &amp;CTestPlatform::setSchemaUri, 1, "&lt;directory&gt;",
                                    "Set the directory where schemas can be found.");
    return mRemoteProcessorServer.process(commandHandler);
}
CTestPlatform::CommandReturn CTestPlatform::createExclusiveSelectionCriterionFromStateList(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    return createExclusiveSelectionCriterionFromStateList(remoteCommand.getArgument(0),
                                                          remoteCommand, strResult)
               ? CTestPlatform::CCommandHandler::EDone
               : CTestPlatform::CCommandHandler::EFailed;
}
CTestPlatform::CommandReturn CTestPlatform::createInclusiveSelectionCriterionFromStateList(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    return createInclusiveSelectionCriterionFromStateList(remoteCommand.getArgument(0),
                                                          remoteCommand, strResult)
               ? CTestPlatform::CCommandHandler::EDone
               : CTestPlatform::CCommandHandler::EFailed;
}
CTestPlatform::CommandReturn CTestPlatform::createExclusiveSelectionCriterion(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    return createExclusiveSelectionCriterion(
               remoteCommand.getArgument(0),
               strtoul(remoteCommand.getArgument(1).c_str(), nullptr, 0), strResult)
               ? CTestPlatform::CCommandHandler::EDone
               : CTestPlatform::CCommandHandler::EFailed;
}
CTestPlatform::CommandReturn CTestPlatform::createInclusiveSelectionCriterion(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    return createInclusiveSelectionCriterion(
               remoteCommand.getArgument(0),
               strtoul(remoteCommand.getArgument(1).c_str(), nullptr, 0), strResult)
               ? CTestPlatform::CCommandHandler::EDone
               : CTestPlatform::CCommandHandler::EFailed;
}
CTestPlatform::CommandReturn CTestPlatform::startParameterMgr(
    const IRemoteCommand &amp; /*remoteCommand*/, string &amp;strResult)
{
    return mParameterMgrPlatformConnector.start(strResult)
               ? CTestPlatform::CCommandHandler::EDone
               : CTestPlatform::CCommandHandler::EFailed;
}
template &lt;CTestPlatform::setter_t setFunction&gt;
CTestPlatform::CommandReturn CTestPlatform::setter(const IRemoteCommand &amp;remoteCommand,
                                                   string &amp;strResult)
{
    const string &amp;strAbort = remoteCommand.getArgument(0);
    bool bFail;
    if (!convertTo(strAbort, bFail)) {
        return CTestPlatform::CCommandHandler::EShowUsage;
    }
    return (mParameterMgrPlatformConnector.*setFunction)(bFail, strResult)
               ? CTestPlatform::CCommandHandler::EDone
               : CTestPlatform::CCommandHandler::EFailed;
}
template &lt;CTestPlatform::getter_t getFunction&gt;
CTestPlatform::CommandReturn CTestPlatform::getter(const IRemoteCommand &amp; /*command*/,
                                                   string &amp;strResult)
{
    strResult = (mParameterMgrPlatformConnector.*getFunction)() ? "true" : "false";
    return CTestPlatform::CCommandHandler::ESucceeded;
}
CTestPlatform::CommandReturn CTestPlatform::getSchemaUri(const IRemoteCommand &amp; /*remotecommand*/,
                                                         string &amp;result)
{
    result = mParameterMgrPlatformConnector.getSchemaUri();
    return CTestPlatform::CCommandHandler::EDone;
}
CTestPlatform::CommandReturn CTestPlatform::setSchemaUri(const IRemoteCommand &amp;remotecommand,
                                                         string &amp; /*result*/)
{
    mParameterMgrPlatformConnector.setSchemaUri(remotecommand.getArgument(0));
    return CTestPlatform::CCommandHandler::EDone;
}
CTestPlatform::CommandReturn CTestPlatform::setCriterionState(const IRemoteCommand &amp;remoteCommand,
                                                              string &amp;strResult)
{
    bool bSuccess;
    uint32_t state;
    if (convertTo(remoteCommand.getArgument(1), state)) {
        bSuccess = setCriterionState(remoteCommand.getArgument(0), state, strResult);
    } else {
        bSuccess = setCriterionStateByLexicalSpace(remoteCommand, strResult);
    }
    return bSuccess ? CTestPlatform::CCommandHandler::EDone
                    : CTestPlatform::CCommandHandler::EFailed;
}
CTestPlatform::CommandReturn CTestPlatform::applyConfigurations(const IRemoteCommand &amp; /*command*/,
                                                                string &amp; /*strResult*/)
{
    mParameterMgrPlatformConnector.applyConfigurations();
    return CTestPlatform::CCommandHandler::EDone;
}
bool CTestPlatform::createExclusiveSelectionCriterionFromStateList(
    const string &amp;strName, const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    ISelectionCriterionTypeInterface *pCriterionType =
        mParameterMgrPlatformConnector.createSelectionCriterionType(false);
    assert(pCriterionType != nullptr);
    size_t nbStates = remoteCommand.getArgumentCount() - 1;
    for (size_t state = 0; state &lt; nbStates; state++) {
        const std::string &amp;strValue = remoteCommand.getArgument(state + 1);
        if (!pCriterionType-&gt;addValuePair(int(state), strValue, strResult)) {
            strResult = "Unable to add value: " + strValue + ": " + strResult;
            return false;
        }
    }
    mParameterMgrPlatformConnector.createSelectionCriterion(strName, pCriterionType);
    return true;
}
bool CTestPlatform::createInclusiveSelectionCriterionFromStateList(
    const string &amp;strName, const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    ISelectionCriterionTypeInterface *pCriterionType =
        mParameterMgrPlatformConnector.createSelectionCriterionType(true);
    assert(pCriterionType != nullptr);
    size_t nbStates = remoteCommand.getArgumentCount() - 1;
    for (size_t state = 0; state &lt; nbStates; state++) {
        const std::string &amp;strValue = remoteCommand.getArgument(state + 1);
        if (!pCriterionType-&gt;addValuePair(0x1 &lt;&lt; state, strValue, strResult)) {
            strResult = "Unable to add value: " + strValue + ": " + strResult;
            return false;
        }
    }
    mParameterMgrPlatformConnector.createSelectionCriterion(strName, pCriterionType);
    return true;
}
bool CTestPlatform::createExclusiveSelectionCriterion(const string &amp;strName, size_t nbStates,
                                                      string &amp;strResult)
{
    ISelectionCriterionTypeInterface *pCriterionType =
        mParameterMgrPlatformConnector.createSelectionCriterionType(false);
    for (size_t state = 0; state &lt; nbStates; state++) {
        std::ostringstream ostrValue;
        ostrValue &lt;&lt; "State_";
        ostrValue &lt;&lt; state;
        if (!pCriterionType-&gt;addValuePair(int(state), ostrValue.str(), strResult)) {
            strResult = "Unable to add value: " + ostrValue.str() + ": " + strResult;
            return false;
        }
    }
    mParameterMgrPlatformConnector.createSelectionCriterion(strName, pCriterionType);
    return true;
}
bool CTestPlatform::createInclusiveSelectionCriterion(const string &amp;strName, size_t nbStates,
                                                      string &amp;strResult)
{
    ISelectionCriterionTypeInterface *pCriterionType =
        mParameterMgrPlatformConnector.createSelectionCriterionType(true);
    for (size_t state = 0; state &lt; nbStates; state++) {
        std::ostringstream ostrValue;
        ostrValue &lt;&lt; "State_0x";
        ostrValue &lt;&lt; (0x1 &lt;&lt; state);
        if (!pCriterionType-&gt;addValuePair(0x1 &lt;&lt; state, ostrValue.str(), strResult)) {
            strResult = "Unable to add value: " + ostrValue.str() + ": " + strResult;
            return false;
        }
    }
<a name="0"></a>
    mParameterMgrPlatformConnector.createSelectionCriterion(strName, pCriterionType);
<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    return true;
}
bool CTestPlatform::setCriterionState(const string &amp;strName, uint32_t uiState, string &amp;strResult)
{
    ISelectionCriterionInterface *pCriterion =
        mParameterMgrPlatformConnector.getSelectionCriterion(strName);
    if (!pCriterion) {
        strResult = "Unable to retrieve selection criterion: " + strName;
        return false;
    }
    pCriterion-&gt;setCriterionState(uiState);
    return true;
}</b></font>
bool CTestPlatform::setCriterionStateByLexicalSpace(const IRemoteCommand &amp;remoteCommand,
                                                    string &amp;strResult)
{
    std::string strCriterionName = remoteCommand.getArgument(0);
    ISelectionCriterionInterface *pCriterion =
        mParameterMgrPlatformConnector.getSelectionCriterion(strCriterionName);
    if (!pCriterion) {
        strResult = "Unable to retrieve selection criterion: " + strCriterionName;
        return false;
    }
    const ISelectionCriterionTypeInterface *pCriterionType = pCriterion-&gt;getCriterionType();
    size_t nbSubStates = remoteCommand.getArgumentCount() - 1;
    if (!pCriterionType-&gt;isTypeInclusive() &amp;&amp; nbSubStates != 1) {
        strResult = "Exclusive criterion " + strCriterionName + " can only have one state";
        return false;
    }
    int iNumericalState = 0;
    size_t lexicalSubStateIndex;
    std::string strLexicalState = "";
    for (lexicalSubStateIndex = 1; lexicalSubStateIndex &lt;= nbSubStates; lexicalSubStateIndex++) {
        /*
         * getNumericalValue method from ISelectionCriterionTypeInterface strip his parameter
         * first parameter based on | sign. In case that the user uses multiple parameters
         * to set InclusiveCriterion value, we aggregate all desired values to be sure
         * they will be handled correctly.
         */
        if (lexicalSubStateIndex != 1) {
            strLexicalState += "|";
        }
        strLexicalState += remoteCommand.getArgument(lexicalSubStateIndex);
    }
    if (!pCriterionType-&gt;getNumericalValue(strLexicalState, iNumericalState)) {
        strResult = "Unable to find lexical state \"" + strLexicalState + "\" in criteria " +
                    strCriterionName;
        return false;
    }
    pCriterion-&gt;setCriterionState(iNumericalState);
    return true;
}
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ConfigurableDomain.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/*
 * Copyright (c) 2011-2015, Intel Corporation
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation and/or
 * other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its contributors
 * may be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#include "ConfigurableDomain.h"
#include "DomainConfiguration.h"
#include "ConfigurableElement.h"
#include "ConfigurationAccessContext.h"
#include "XmlDomainSerializingContext.h"
#include "XmlDomainImportContext.h"
#include "XmlDomainExportContext.h"
#include "Utility.h"
#include "AlwaysAssert.hpp"
#include &lt;cassert&gt;
#define base CElement
using std::string;
CConfigurableDomain::CConfigurableDomain(const string &amp;strName) : base(strName)
{
}
CConfigurableDomain::~CConfigurableDomain()
{
    ConfigurableElementListIterator it;
    for (it = _configurableElementList.begin(); it != _configurableElementList.end(); ++it) {
        CConfigurableElement *pConfigurableElement = *it;
        pConfigurableElement-&gt;removeAttachedConfigurableDomain(this);
    }
    ConfigurableElementToSyncerSetMapIterator mapIt;
    for (mapIt = _configurableElementToSyncerSetMap.begin();
         mapIt != _configurableElementToSyncerSetMap.end(); ++mapIt) {
        delete mapIt-&gt;second;
    }
}
string CConfigurableDomain::getKind() const
{
    return "ConfigurableDomain";
}
bool CConfigurableDomain::childrenAreDynamic() const
{
    return true;
}
string CConfigurableDomain::logValue(utility::ErrorContext &amp; /*ctx*/) const
{
    return string("{") +
           "Sequence aware: " + (_bSequenceAware ? "yes" : "no") +
           ", Last applied configuration: " +
           (_pLastAppliedConfiguration ? _pLastAppliedConfiguration-&gt;getName() : "&lt;none&gt;") +
           "}";
}
void CConfigurableDomain::setSequenceAwareness(bool bSequenceAware)
{
    if (_bSequenceAware != bSequenceAware) {
        _bSequenceAware = bSequenceAware;
    }
}
bool CConfigurableDomain::getSequenceAwareness() const
{
    return _bSequenceAware;
}
void CConfigurableDomain::toXml(CXmlElement &amp;xmlElement,
                                CXmlSerializingContext &amp;serializingContext) const
{
    base::toXml(xmlElement, serializingContext);
    xmlElement.setAttribute("SequenceAware", _bSequenceAware);
}
void CConfigurableDomain::childrenToXml(CXmlElement &amp;xmlElement,
                                        CXmlSerializingContext &amp;serializingContext) const
{
    composeDomainConfigurations(xmlElement, serializingContext);
    composeConfigurableElements(xmlElement);
    composeSettings(xmlElement, static_cast&lt;CXmlDomainExportContext &amp;&gt;(serializingContext));
}
void CConfigurableDomain::composeDomainConfigurations(
    CXmlElement &amp;xmlElement, CXmlSerializingContext &amp;serializingContext) const
{
    CXmlElement xmlConfigurationsElement;
    xmlElement.createChild(xmlConfigurationsElement, "Configurations");
    base::childrenToXml(xmlConfigurationsElement, serializingContext);
}
void CConfigurableDomain::composeConfigurableElements(CXmlElement &amp;xmlElement) const
{
    CXmlElement xmlConfigurableElementsElement;
    xmlElement.createChild(xmlConfigurableElementsElement, "ConfigurableElements");
    ConfigurableElementListIterator it;
    for (it = _configurableElementList.begin(); it != _configurableElementList.end(); ++it) {
        const CConfigurableElement *pConfigurableElement = *it;
        CXmlElement xmlChildConfigurableElement;
        xmlConfigurableElementsElement.createChild(xmlChildConfigurableElement,
                                                   "ConfigurableElement");
        xmlChildConfigurableElement.setAttribute("Path", pConfigurableElement-&gt;getPath());
    }
}
void CConfigurableDomain::composeSettings(CXmlElement &amp;xmlElement,
                                          CXmlDomainExportContext &amp;context) const
{
    if (!context.withSettings()) {
        return;
    }
    CXmlElement xmlSettingsElement;
    xmlElement.createChild(xmlSettingsElement, "Settings");
    size_t uiNbConfigurations = getNbChildren();
    size_t uiChildConfiguration;
    for (uiChildConfiguration = 0; uiChildConfiguration &lt; uiNbConfigurations;
         uiChildConfiguration++) {
        const CDomainConfiguration *pDomainConfiguration =
            static_cast&lt;const CDomainConfiguration *&gt;(getChild(uiChildConfiguration));
        CXmlElement xmlConfigurationSettingsElement;
        xmlSettingsElement.createChild(xmlConfigurationSettingsElement,
                                       pDomainConfiguration-&gt;getXmlElementName());
        xmlConfigurationSettingsElement.setNameAttribute(pDomainConfiguration-&gt;getName());
        pDomainConfiguration-&gt;composeSettings(xmlConfigurationSettingsElement, context);
    }
}
bool CConfigurableDomain::fromXml(const CXmlElement &amp;xmlElement,
                                  CXmlSerializingContext &amp;serializingContext)
{
    CXmlDomainImportContext &amp;xmlDomainImportContext =
        static_cast&lt;CXmlDomainImportContext &amp;&gt;(serializingContext);
    xmlElement.getAttribute("SequenceAware", _bSequenceAware);
    std::string name;
    xmlElement.getAttribute("Name", name);
    setName(name);
    if (!parseDomainConfigurations(xmlElement, xmlDomainImportContext) ||
        !parseConfigurableElements(xmlElement, xmlDomainImportContext) ||
        !parseSettings(xmlElement, xmlDomainImportContext)) {
        return false;
    }
    if (xmlDomainImportContext.autoValidationRequired()) {
        autoValidateAll();
    }
    return true;
}
bool CConfigurableDomain::parseDomainConfigurations(const CXmlElement &amp;xmlElement,
                                                    CXmlDomainImportContext &amp;serializingContext)
{
    assert(_configurableElementList.empty());
    CXmlElement xmlConfigurationsElement;
    xmlElement.getChildElement("Configurations", xmlConfigurationsElement);
    return base::fromXml(xmlConfigurationsElement, serializingContext);
}
bool CConfigurableDomain::parseConfigurableElements(const CXmlElement &amp;xmlElement,
                                                    CXmlDomainImportContext &amp;serializingContext)
{
    CSystemClass &amp;systemClass = serializingContext.getSystemClass();
    CXmlElement xmlConfigurableElementsElement;
    xmlElement.getChildElement("ConfigurableElements", xmlConfigurableElementsElement);
    CXmlElement::CChildIterator it(xmlConfigurableElementsElement);
    CXmlElement xmlConfigurableElementElement;
    while (it.next(xmlConfigurableElementElement)) {
        string strConfigurableElementPath;
        xmlConfigurableElementElement.getAttribute("Path", strConfigurableElementPath);
        CPathNavigator pathNavigator(strConfigurableElementPath);
        string strError;
        if (!pathNavigator.navigateThrough(systemClass.getName(), strError)) {
            serializingContext.setError(
                "Could not find configurable element of path " + strConfigurableElementPath +
                " from ConfigurableDomain description " + getName() + " (" + strError + ")");
            return false;
        }
        CConfigurableElement *pConfigurableElement =
            static_cast&lt;CConfigurableElement *&gt;(systemClass.findDescendant(pathNavigator));
        if (!pConfigurableElement) {
            serializingContext.setError("Could not find configurable element of path " +
                                        strConfigurableElementPath +
                                        " from ConfigurableDomain description " + getName());
            return false;
        }
        core::Results infos;
        if (!addConfigurableElement(pConfigurableElement, nullptr, infos)) {
            strError = utility::asString(infos);
            serializingContext.setError(strError);
            return false;
        }
    }
    return true;
}
bool CConfigurableDomain::parseSettings(const CXmlElement &amp;xmlElement,
                                        CXmlDomainImportContext &amp;serializingContext)
{
    if (!serializingContext.withSettings()) {
        return true;
    }
    CXmlElement xmlSettingsElement;
    if (!xmlElement.getChildElement("Settings", xmlSettingsElement)) {
        return true;
    }
    CXmlElement::CChildIterator it(xmlSettingsElement);
    CXmlElement xmlConfigurationSettingsElement;
    while (it.next(xmlConfigurationSettingsElement)) {
        CDomainConfiguration *pDomainConfiguration = static_cast&lt;CDomainConfiguration *&gt;(
            findChild(xmlConfigurationSettingsElement.getNameAttribute()));
        if (!pDomainConfiguration) {
            serializingContext.setError("Could not find domain configuration referred to by"
                                        " configurable domain \"" +
                                        getName() + "\".");
            return false;
        }
        if (!pDomainConfiguration-&gt;parseSettings(xmlConfigurationSettingsElement,
                                                 serializingContext)) {
            return false;
        }
    }
    return true;
}
bool CConfigurableDomain::addConfigurableElement(CConfigurableElement *pConfigurableElement,
                                                 const CParameterBlackboard *pMainBlackboard,
                                                 core::Results &amp;infos)
{
    if (containsConfigurableElement(pConfigurableElement)) {
        infos.push_back("Configurable element " + pConfigurableElement-&gt;getPath() +
                        " already associated to configuration domain " + getName());
        return false;
    }
    if (pConfigurableElement-&gt;belongsTo(this)) {
        infos.push_back("Configurable element " + pConfigurableElement-&gt;getPath() +
                        " already owned by configuration domain " + getName());
        return false;
    }
    doAddConfigurableElement(pConfigurableElement, infos, pMainBlackboard);
    return true;
}
bool CConfigurableDomain::removeConfigurableElement(CConfigurableElement *pConfigurableElement,
                                                    string &amp;strError)
{
    if (!containsConfigurableElement(pConfigurableElement)) {
        strError = "Configurable element " + pConfigurableElement-&gt;getPath() +
                   " not associated to configuration domain " + getName();
        return false;
    }
    doRemoveConfigurableElement(pConfigurableElement, true);
    return true;
}
/**
* Blackboard Configuration and Base Offset retrieval.
*
* This method fetches the Blackboard associated to the ConfigurableElement
* given in parameter, for a specific Configuration. The ConfigurableElement
* must belong to the Domain. If a Blackboard is found, the base offset of
* the ConfigurableElement is returned as well. This base offset corresponds to
* the offset of the ancestor of the ConfigurableElement associated to the Configuration.
*
* @param[in] strConfiguration                           Name of the Configuration.
* @param[in] pCandidateDescendantConfigurableElement    Pointer to a CConfigurableElement that
*                                                       belongs to the Domain.
* @param[out] baseOffset                              The base offset of the CConfigurableElement.
* @param[out] bIsLastApplied                            Boolean indicating that the Configuration is
*                                                       the last one applied of the Domain.
* @param[out] strError                                  Error message
*
* return Pointer to the Blackboard of the Configuration.
*/
CParameterBlackboard *CConfigurableDomain::findConfigurationBlackboard(
    const string &amp;strConfiguration,
    const CConfigurableElement *pCandidateDescendantConfigurableElement, size_t &amp;baseOffset,
    bool &amp;bIsLastApplied, string &amp;strError) const
{
    const CDomainConfiguration *pDomainConfiguration =
        static_cast&lt;const CDomainConfiguration *&gt;(findChild(strConfiguration));
    if (!pDomainConfiguration) {
        strError = "Domain configuration " + strConfiguration + " not found";
        return nullptr;
    }
    ConfigurableElementListIterator it;
    for (it = _configurableElementList.begin(); it != _configurableElementList.end(); ++it) {
        const CConfigurableElement *pAssociatedConfigurableElement = *it;
        if ((pCandidateDescendantConfigurableElement == pAssociatedConfigurableElement) ||
            (pCandidateDescendantConfigurableElement-&gt;isDescendantOf(
                pAssociatedConfigurableElement))) {
            baseOffset = pAssociatedConfigurableElement-&gt;getOffset();
            bIsLastApplied = (pDomainConfiguration == _pLastAppliedConfiguration);
            return pDomainConfiguration-&gt;getBlackboard(pAssociatedConfigurableElement);
        }
    }
    strError = "Element not associated to the Domain";
    return nullptr;
}
bool CConfigurableDomain::split(CConfigurableElement *pConfigurableElement, core::Results &amp;infos)
{
    if (!containsConfigurableElement(pConfigurableElement)) {
        std::string strError = "Configurable element " + pConfigurableElement-&gt;getPath() +
                               " not associated to configuration domain " + getName();
        infos.push_back(strError);
        return false;
    }
    size_t uiNbConfigurableElementChildren = pConfigurableElement-&gt;getNbChildren();
    if (!uiNbConfigurableElementChildren) {
        std::string strError = "Configurable element " + pConfigurableElement-&gt;getPath() +
                               " has no children to split configurable domain to";
        infos.push_back(strError);
        return false;
    }
    for (size_t uiChild = 0; uiChild &lt; uiNbConfigurableElementChildren; uiChild++) {
        CConfigurableElement *pChildConfigurableElement =
            static_cast&lt;CConfigurableElement *&gt;(pConfigurableElement-&gt;getChild(uiChild));
        doAddConfigurableElement(pChildConfigurableElement, infos);
    }
    size_t uiNbConfigurations = getNbChildren();
    for (size_t uiChild = 0; uiChild &lt; uiNbConfigurations; uiChild++) {
        CDomainConfiguration *pDomainConfiguration =
            static_cast&lt;CDomainConfiguration *&gt;(getChild(uiChild));
        pDomainConfiguration-&gt;split(pConfigurableElement);
    }
    doRemoveConfigurableElement(pConfigurableElement, false);
    return true;
}
const CDomainConfiguration *CConfigurableDomain::getPendingConfiguration() const
{
    const CDomainConfiguration *pApplicableDomainConfiguration =
        findApplicableDomainConfiguration();
    if (pApplicableDomainConfiguration) {
        if (!_pLastAppliedConfiguration ||
            (_pLastAppliedConfiguration != pApplicableDomainConfiguration)) {
            return pApplicableDomainConfiguration;
        }
    }
    return nullptr;
}
void CConfigurableDomain::apply(CParameterBlackboard *pParameterBlackboard, CSyncerSet *pSyncerSet,
                                bool bForce, std::string &amp;strInfo) const
{
    if (!pSyncerSet ^ _bSequenceAware) {
        return;
    }
    if (bForce) {
        _pLastAppliedConfiguration = nullptr;
    }
    const CDomainConfiguration *pApplicableDomainConfiguration =
        findApplicableDomainConfiguration();
    if (pApplicableDomainConfiguration) {
        if (!_pLastAppliedConfiguration ||
            _pLastAppliedConfiguration != pApplicableDomainConfiguration) {
            strInfo = "Applying configuration '" + pApplicableDomainConfiguration-&gt;getName() +
                      "' from domain '" + getName() + "'";
            bool bSync = !pSyncerSet &amp;&amp; _bSequenceAware;
            pApplicableDomainConfiguration-&gt;restore(pParameterBlackboard, bSync, nullptr);
            _pLastAppliedConfiguration = pApplicableDomainConfiguration;
            if (pSyncerSet &amp;&amp; !_bSequenceAware) {
                *pSyncerSet += _syncerSet;
            }
        }
    }
}
bool CConfigurableDomain::isApplicableConfigurationValid(
    const CConfigurableElement *pConfigurableElement) const
{
    const CDomainConfiguration *pApplicableDomainConfiguration =
        findApplicableDomainConfiguration();
    return pApplicableDomainConfiguration &amp;&amp;
           pApplicableDomainConfiguration-&gt;isValid(pConfigurableElement);
}
void CConfigurableDomain::computeSyncSet()
{
    _syncerSet.clear();
    ConfigurableElementToSyncerSetMapIterator mapIt;
    for (mapIt = _configurableElementToSyncerSetMap.begin();
         mapIt != _configurableElementToSyncerSetMap.end(); ++mapIt) {
        const CSyncerSet *pSyncerSet = mapIt-&gt;second;
        _syncerSet += *pSyncerSet;
    }
}
bool CConfigurableDomain::createConfiguration(const string &amp;strName,
                                              const CParameterBlackboard *pMainBlackboard,
                                              string &amp;strError)
{
    if (findChild(strName)) {
        strError = "Already existing configuration";
        return false;
    }
    auto pDomainConfiguration = new CDomainConfiguration(strName);
    ConfigurableElementListIterator it;
    for (it = _configurableElementList.begin(); it != _configurableElementList.end(); ++it) {
        const CConfigurableElement *pConfigurableElement = *it;
        ;
        CSyncerSet *pSyncerSet = getSyncerSet(pConfigurableElement);
        pDomainConfiguration-&gt;addConfigurableElement(pConfigurableElement, pSyncerSet);
    }
    addChild(pDomainConfiguration);
    if (!autoValidateConfiguration(pDomainConfiguration)) {
        pDomainConfiguration-&gt;validate(pMainBlackboard);
    }
    return true;
}
bool CConfigurableDomain::deleteConfiguration(const string &amp;strName, string &amp;strError)
{
    CDomainConfiguration *pDomainConfiguration = findConfiguration(strName, strError);
    if (!pDomainConfiguration) {
        return false;
    }
    if (pDomainConfiguration == _pLastAppliedConfiguration) {
        _pLastAppliedConfiguration = nullptr;
    }
    removeChild(pDomainConfiguration);
    delete pDomainConfiguration;
    return true;
}
void CConfigurableDomain::listAssociatedToElements(string &amp;strResult) const
{
    ConfigurableElementListIterator it;
    for (it = _configurableElementList.begin(); it != _configurableElementList.end(); ++it) {
        const CConfigurableElement *pConfigurableElement = *it;
        strResult += pConfigurableElement-&gt;getPath() + "\n";
    }
}
bool CConfigurableDomain::renameConfiguration(const string &amp;strName, const string &amp;strNewName,
                                              string &amp;strError)
{
    CDomainConfiguration *pDomainConfiguration = findConfiguration(strName, strError);
    if (!pDomainConfiguration) {
        return false;
    }
    return pDomainConfiguration-&gt;rename(strNewName, strError);
}
bool CConfigurableDomain::restoreConfiguration(const string &amp;configurationName,
                                               CParameterBlackboard *mainBlackboard, bool autoSync,
                                               core::Results &amp;errors) const
{
    string error;
    const CDomainConfiguration *configuration = findConfiguration(configurationName, error);
    if (configuration == nullptr) {
        errors.push_back(error);
        return false;
    }
    bool bSuccess = configuration-&gt;restore(mainBlackboard, autoSync &amp;&amp; _bSequenceAware, &amp;errors);
    _pLastAppliedConfiguration = configuration;
    if (autoSync &amp;&amp; !_bSequenceAware) {
        bSuccess &amp;= _syncerSet.sync(*mainBlackboard, false, &amp;errors);
    }
    return bSuccess;
}
bool CConfigurableDomain::saveConfiguration(const string &amp;strName,
                                            const CParameterBlackboard *pMainBlackboard,
                                            string &amp;strError)
{
    CDomainConfiguration *pDomainConfiguration = findConfiguration(strName, strError);
    if (!pDomainConfiguration) {
        return false;
    }
    pDomainConfiguration-&gt;save(pMainBlackboard);
    return true;
}
bool CConfigurableDomain::setElementSequence(const string &amp;strConfiguration,
                                             const std::vector&lt;string&gt; &amp;astrNewElementSequence,
                                             string &amp;strError)
{
    CDomainConfiguration *pDomainConfiguration = findConfiguration(strConfiguration, strError);
    if (!pDomainConfiguration) {
        return false;
    }
    return pDomainConfiguration-&gt;setElementSequence(astrNewElementSequence, strError);
}
bool CConfigurableDomain::getElementSequence(const string &amp;strConfiguration,
                                             string &amp;strResult) const
{
    const CDomainConfiguration *pDomainConfiguration =
        findConfiguration(strConfiguration, strResult);
    if (!pDomainConfiguration) {
        return false;
    }
    pDomainConfiguration-&gt;getElementSequence(strResult);
    return true;
}
bool CConfigurableDomain::setApplicationRule(
    const string &amp;strConfiguration, const string &amp;strApplicationRule,
    const CSelectionCriteriaDefinition *pSelectionCriteriaDefinition, string &amp;strError)
{
    CDomainConfiguration *pDomainConfiguration = findConfiguration(strConfiguration, strError);
    if (!pDomainConfiguration) {
        return false;
    }
    return pDomainConfiguration-&gt;setApplicationRule(strApplicationRule,
                                                    pSelectionCriteriaDefinition, strError);
}
bool CConfigurableDomain::clearApplicationRule(const string &amp;strConfiguration, string &amp;strError)
{
    CDomainConfiguration *pDomainConfiguration = findConfiguration(strConfiguration, strError);
    if (!pDomainConfiguration) {
        return false;
    }
    pDomainConfiguration-&gt;clearApplicationRule();
    return true;
}
bool CConfigurableDomain::getApplicationRule(const string &amp;strConfiguration,
                                             string &amp;strResult) const
{
    const CDomainConfiguration *pDomainConfiguration =
        findConfiguration(strConfiguration, strResult);
    if (!pDomainConfiguration) {
        return false;
    }
    strResult = pDomainConfiguration-&gt;getApplicationRule();
    return true;
}
string CConfigurableDomain::getLastAppliedConfigurationName() const
{
    if (_pLastAppliedConfiguration) {
        return _pLastAppliedConfiguration-&gt;getName();
    }
    return "&lt;none&gt;";
}
string CConfigurableDomain::getPendingConfigurationName() const
{
    const CDomainConfiguration *pApplicableDomainConfiguration =
        findApplicableDomainConfiguration();
    if (!pApplicableDomainConfiguration) {
        return "&lt;none&gt;";
    }
    if (pApplicableDomainConfiguration != _pLastAppliedConfiguration) {
        return pApplicableDomainConfiguration-&gt;getName();
    } else {
        return "";
    }
}
void CConfigurableDomain::validate(const CParameterBlackboard *pMainBlackboard)
{
    size_t uiNbConfigurations = getNbChildren();
    for (size_t uiChild = 0; uiChild &lt; uiNbConfigurations; uiChild++) {
        CDomainConfiguration *pDomainConfiguration =
            static_cast&lt;CDomainConfiguration *&gt;(getChild(uiChild));
        pDomainConfiguration-&gt;validate(pMainBlackboard);
    }
}
void CConfigurableDomain::validateAreas(const CConfigurableElement *pConfigurableElement,
                                        const CParameterBlackboard *pMainBlackboard)
{
    size_t uiNbConfigurations = getNbChildren();
    for (size_t uiChild = 0; uiChild &lt; uiNbConfigurations; uiChild++) {
        CDomainConfiguration *pDomainConfiguration =
            static_cast&lt;CDomainConfiguration *&gt;(getChild(uiChild));
        pDomainConfiguration-&gt;validate(pConfigurableElement, pMainBlackboard);
    }
}
void CConfigurableDomain::autoValidateAll()
{
    ConfigurableElementListIterator it;
    for (it = _configurableElementList.begin(); it != _configurableElementList.end(); ++it) {
        const CConfigurableElement *pConfigurableElement = *it;
        autoValidateAreas(pConfigurableElement);
    }
}
void CConfigurableDomain::autoValidateAreas(const CConfigurableElement *pConfigurableElement)
{
    const CDomainConfiguration *pValidDomainConfiguration =
        findValidDomainConfiguration(pConfigurableElement);
    if (!pValidDomainConfiguration) {
        return;
    }
    size_t uiNbConfigurations = getNbChildren();
    for (size_t uiChild = 0; uiChild &lt; uiNbConfigurations; uiChild++) {
        CDomainConfiguration *pDomainConfiguration =
            static_cast&lt;CDomainConfiguration *&gt;(getChild(uiChild));
        if (pDomainConfiguration != pValidDomainConfiguration &amp;&amp;
            !pDomainConfiguration-&gt;isValid(pConfigurableElement)) {
            pDomainConfiguration-&gt;validateAgainst(pValidDomainConfiguration, pConfigurableElement);
        }
    }
}
bool CConfigurableDomain::autoValidateConfiguration(CDomainConfiguration *pDomainConfiguration)
{
    size_t uiNbConfigurations = getNbChildren();
    for (size_t uiChild = 0; uiChild &lt; uiNbConfigurations; uiChild++) {
        const CDomainConfiguration *pPotententialValidDomainConfiguration =
            static_cast&lt;const CDomainConfiguration *&gt;(getChild(uiChild));
        if (pPotententialValidDomainConfiguration != pDomainConfiguration) {
            pDomainConfiguration-&gt;validateAgainst(pPotententialValidDomainConfiguration);
            return true;
        }
    }
    return false;
}
const CDomainConfiguration *CConfigurableDomain::findValidDomainConfiguration(
    const CConfigurableElement *pConfigurableElement) const
{
    size_t uiNbConfigurations = getNbChildren();
    for (size_t uiChild = 0; uiChild &lt; uiNbConfigurations; uiChild++) {
        const CDomainConfiguration *pDomainConfiguration =
            static_cast&lt;const CDomainConfiguration *&gt;(getChild(uiChild));
        if (pDomainConfiguration-&gt;isValid(pConfigurableElement)) {
            return pDomainConfiguration;
        }
    }
    return nullptr;
}
const CDomainConfiguration *CConfigurableDomain::findApplicableDomainConfiguration() const
{
    size_t uiNbConfigurations = getNbChildren();
    for (size_t uiChild = 0; uiChild &lt; uiNbConfigurations; uiChild++) {
        const CDomainConfiguration *pDomainConfiguration =
            static_cast&lt;const CDomainConfiguration *&gt;(getChild(uiChild));
        if (pDomainConfiguration-&gt;isApplicable()) {
            return pDomainConfiguration;
        }
    }
    return nullptr;
}
void CConfigurableDomain::gatherConfigurableElements(
    std::set&lt;const CConfigurableElement *&gt; &amp;configurableElementSet) const
{
    configurableElementSet.insert(_configurableElementList.begin(), _configurableElementList.end());
}
bool CConfigurableDomain::containsConfigurableElement(
    const CConfigurableElement *pConfigurableCandidateElement) const
{
    ConfigurableElementListIterator it;
    for (it = _configurableElementList.begin(); it != _configurableElementList.end(); ++it) {
        if (pConfigurableCandidateElement == *it) {
            return true;
        }
    }
    return false;
}
void CConfigurableDomain::mergeAlreadyAssociatedDescendantConfigurableElements(
    CConfigurableElement *newElement, core::Results &amp;infos)
{
    std::list&lt;CConfigurableElement *&gt; mergedConfigurableElementList;
    ConfigurableElementListIterator it;
    for (it = _configurableElementList.begin(); it != _configurableElementList.end(); ++it) {
        CConfigurableElement *pConfigurablePotentialDescendantElement = *it;
        if (pConfigurablePotentialDescendantElement-&gt;isDescendantOf(newElement)) {
            infos.push_back("In domain '" + getName() +
                            "', merging descendant configurable element's configurations '" +
                            pConfigurablePotentialDescendantElement-&gt;getName() +
                            "' into its ascendant '" + newElement-&gt;getName() + "' ones");
            mergeConfigurations(newElement, pConfigurablePotentialDescendantElement);
            mergedConfigurableElementList.push_back(pConfigurablePotentialDescendantElement);
        }
    }
    for (it = mergedConfigurableElementList.begin(); it != mergedConfigurableElementList.end();
         ++it) {
        CConfigurableElement *pMergedConfigurableElement = *it;
        doRemoveConfigurableElement(pMergedConfigurableElement, false);
    }
}
void CConfigurableDomain::mergeConfigurations(CConfigurableElement *pToConfigurableElement,
                                              CConfigurableElement *pFromConfigurableElement)
{
    size_t uiNbConfigurations = getNbChildren();
    for (size_t uiChild = 0; uiChild &lt; uiNbConfigurations; uiChild++) {
        CDomainConfiguration *pDomainConfiguration =
            static_cast&lt;CDomainConfiguration *&gt;(getChild(uiChild));
        pDomainConfiguration-&gt;merge(pToConfigurableElement, pFromConfigurableElement);
    }
}
void CConfigurableDomain::doAddConfigurableElement(CConfigurableElement *pConfigurableElement,
                                                   core::Results &amp;infos,
                                                   const CParameterBlackboard *pMainBlackboard)
{
    pConfigurableElement-&gt;addAttachedConfigurableDomain(this);
    auto pSyncerSet = new CSyncerSet;
    pConfigurableElement-&gt;fillSyncerSet(*pSyncerSet);
    _configurableElementToSyncerSetMap[pConfigurableElement] = pSyncerSet;
    _syncerSet += *pSyncerSet;
    size_t uiNbConfigurations = getNbChildren();
    for (size_t uiChild = 0; uiChild &lt; uiNbConfigurations; uiChild++) {
        CDomainConfiguration *pDomainConfiguration =
            static_cast&lt;CDomainConfiguration *&gt;(getChild(uiChild));
        pDomainConfiguration-&gt;addConfigurableElement(pConfigurableElement, pSyncerSet);
    }
    if (pMainBlackboard) {
        infos.push_back("Validating domain '" + getName() +
                        "' against main blackboard for configurable element '" +
                        pConfigurableElement-&gt;getPath() + "'");
        validateAreas(pConfigurableElement, pMainBlackboard);
    }
    mergeAlreadyAssociatedDescendantConfigurableElements(pConfigurableElement, infos);
    _configurableElementList.push_back(pConfigurableElement);
}
void CConfigurableDomain::doRemoveConfigurableElement(CConfigurableElement *pConfigurableElement,
                                                      bool bRecomputeSyncSet)
{
    _configurableElementList.remove(pConfigurableElement);
    CSyncerSet *pSyncerSet = getSyncerSet(pConfigurableElement);
    _configurableElementToSyncerSetMap.erase(pConfigurableElement);
    delete pSyncerSet;
    pConfigurableElement-&gt;removeAttachedConfigurableDomain(this);
    size_t uiNbConfigurations = getNbChildren();
    for (size_t uiChild = 0; uiChild &lt; uiNbConfigurations; uiChild++) {
        CDomainConfiguration *pDomainConfiguration =
            static_cast&lt;CDomainConfiguration *&gt;(getChild(uiChild));
        pDomainConfiguration-&gt;removeConfigurableElement(pConfigurableElement);
    }
    if (bRecomputeSyncSet) {
        computeSyncSet();
    }
}
CSyncerSet *CConfigurableDomain::getSyncerSet(
    const CConfigurableElement *pConfigurableElement) const
{
    auto mapIt = _configurableElementToSyncerSetMap.find(pConfigurableElement);
<a name="0"></a>    ALWAYS_ASSERT(mapIt != _configurableElementToSyncerSetMap.end(),
                  "Could not find syncer set for " &lt;&lt; getName() &lt;&lt; " configurable domain");
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    return mapIt-&gt;second;
}
CDomainConfiguration *CConfigurableDomain::findConfiguration(const string &amp;strConfiguration,
                                                             string &amp;strError)
{
    CDomainConfiguration *pDomainConfiguration =
        static_cast&lt;CDomainConfiguration *&gt;(findChild(strConfiguration));
    if (!pDomainConfiguration) {
        strError = "Domain configuration " + strConfiguration + " not found";
        return nullptr;
    }
    return pDomainConfiguration;
}</b></font>
const CDomainConfiguration *CConfigurableDomain::findConfiguration(const string &amp;strConfiguration,
                                                                   string &amp;strError) const
{
    const CDomainConfiguration *pDomainConfiguration =
        static_cast&lt;const CDomainConfiguration *&gt;(findChild(strConfiguration));
    if (!pDomainConfiguration) {
        strError = "Domain configuration " + strConfiguration + " not found";
        return nullptr;
    }
    return pDomainConfiguration;
}
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
