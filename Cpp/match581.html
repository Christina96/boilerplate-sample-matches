<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for TestPlatform.cpp &amp; ConfigurableDomain.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for TestPlatform.cpp &amp; ConfigurableDomain.cpp
      </h3>
<h1 align="center">
        2.4%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>TestPlatform.cpp (4.193548%)<th>ConfigurableDomain.cpp (1.7591339%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(360-378)<td><a href="#" name="0">(1190-1207)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>TestPlatform.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 /*
2  * Copyright (c) 2011-2015, Intel Corporation
3  * All rights reserved.
4  *
5  * Redistribution and use in source and binary forms, with or without modification,
6  * are permitted provided that the following conditions are met:
7  *
8  * 1. Redistributions of source code must retain the above copyright notice, this
9  * list of conditions and the following disclaimer.
10  *
11  * 2. Redistributions in binary form must reproduce the above copyright notice,
12  * this list of conditions and the following disclaimer in the documentation and/or
13  * other materials provided with the distribution.
14  *
15  * 3. Neither the name of the copyright holder nor the names of its contributors
16  * may be used to endorse or promote products derived from this software without
17  * specific prior written permission.
18  *
19  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
20  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
21  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
22  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
23  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
24  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
25  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
26  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
27  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
28  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
29  */
30 #include &lt;stdlib.h&gt;
31 #include &lt;sstream&gt;
32 #include &lt;assert.h&gt;
33 #include &lt;errno.h&gt;
34 #include &lt;convert.hpp&gt;
35 #include &lt;sstream&gt;
36 #include "TestPlatform.h"
37 using std::string;
38 CTestPlatform::CTestPlatform(const string &amp;strClass, uint16_t iPortNumber)
39     : mParameterMgrPlatformConnector(strClass), mLogger(), mRemoteProcessorServer(iPortNumber)
40 {
41     mParameterMgrPlatformConnector.setLogger(&amp;mLogger);
42 }
43 CTestPlatform::~CTestPlatform()
44 {
45 }
46 CTestPlatform::CommandReturn CTestPlatform::exit(const IRemoteCommand &amp; /*command*/,
47                                                  string &amp; /*strResult*/)
48 {
49     mRemoteProcessorServer.stop();
50     return CTestPlatform::CCommandHandler::EDone;
51 }
52 bool CTestPlatform::run(std::string &amp;strError)
53 {
54     if (!mRemoteProcessorServer.start(strError)) {
55         strError = "TestPlatform: Unable to start remote processor server: " + strError;
56         return false;
57     }
58     CCommandHandler commandHandler(this);
59     commandHandler.addCommandParser("exit", &amp;CTestPlatform::exit, 0, "", "Exit TestPlatform");
60     commandHandler.addCommandParser("createExclusiveSelectionCriterionFromStateList",
61                                     &amp;CTestPlatform::createExclusiveSelectionCriterionFromStateList,
62                                     2, "&lt;name&gt; &lt;stateList&gt;",
63                                     "Create inclusive selection criterion from state name list");
64     commandHandler.addCommandParser("createInclusiveSelectionCriterionFromStateList",
65                                     &amp;CTestPlatform::createInclusiveSelectionCriterionFromStateList,
66                                     2, "&lt;name&gt; &lt;stateList&gt;",
67                                     "Create exclusive selection criterion from state name list");
68     commandHandler.addCommandParser("createExclusiveSelectionCriterion",
69                                     &amp;CTestPlatform::createExclusiveSelectionCriterion, 2,
70                                     "&lt;name&gt; &lt;nbStates&gt;", "Create inclusive selection criterion");
71     commandHandler.addCommandParser("createInclusiveSelectionCriterion",
72                                     &amp;CTestPlatform::createInclusiveSelectionCriterion, 2,
73                                     "&lt;name&gt; &lt;nbStates&gt;", "Create exclusive selection criterion");
74     commandHandler.addCommandParser("start", &amp;CTestPlatform::startParameterMgr, 0, "",
75                                     "Start ParameterMgr");
76     commandHandler.addCommandParser("setCriterionState", &amp;CTestPlatform::setCriterionState, 2,
77                                     "&lt;name&gt; &lt;state&gt;",
78                                     "Set the current state of a selection criterion");
79     commandHandler.addCommandParser(
80         "applyConfigurations", &amp;CTestPlatform::applyConfigurations, 0, "",
81         "Apply configurations selected by current selection criteria states");
82     commandHandler.addCommandParser(
83         "setFailureOnMissingSubsystem",
84         &amp;CTestPlatform::setter&lt;&amp;CParameterMgrPlatformConnector::setFailureOnMissingSubsystem&gt;, 1,
85         "true|false", "Set policy for missing subsystems, "
86                       "either abort start or fallback on virtual subsystem.");
87     commandHandler.addCommandParser(
88         "getMissingSubsystemPolicy",
89         &amp;CTestPlatform::getter&lt;&amp;CParameterMgrPlatformConnector::getFailureOnMissingSubsystem&gt;, 0,
90         "", "Get policy for missing subsystems, "
91             "either abort start or fallback on virtual subsystem.");
92     commandHandler.addCommandParser(
93         "setFailureOnFailedSettingsLoad",
94         &amp;CTestPlatform::setter&lt;&amp;CParameterMgrPlatformConnector::setFailureOnFailedSettingsLoad&gt;, 1,
95         "true|false",
96         "Set policy for failed settings load, either abort start or continue without domains.");
97     commandHandler.addCommandParser(
98         "getFailedSettingsLoadPolicy",
99         &amp;CTestPlatform::getter&lt;&amp;CParameterMgrPlatformConnector::getFailureOnFailedSettingsLoad&gt;, 0,
100         "", "Get policy for failed settings load, either abort start or continue without domains.");
101     commandHandler.addCommandParser(
102         "setValidateSchemasOnStart",
103         &amp;CTestPlatform::setter&lt;&amp;CParameterMgrPlatformConnector::setValidateSchemasOnStart&gt;, 1,
104         "true|false", "Set policy for schema validation based on .xsd files (false by default).");
105     commandHandler.addCommandParser(
106         "getValidateSchemasOnStart",
107         &amp;CTestPlatform::getter&lt;&amp;CParameterMgrPlatformConnector::getValidateSchemasOnStart&gt;, 0, "",
108         "Get policy for schema validation based on .xsd files.");
109     commandHandler.addCommandParser("getSchemaUri", &amp;CTestPlatform::getSchemaUri, 0, "",
110                                     "Get the directory where schemas can be found.");
111     commandHandler.addCommandParser("setSchemaUri", &amp;CTestPlatform::setSchemaUri, 1, "&lt;directory&gt;",
112                                     "Set the directory where schemas can be found.");
113     return mRemoteProcessorServer.process(commandHandler);
114 }
115 CTestPlatform::CommandReturn CTestPlatform::createExclusiveSelectionCriterionFromStateList(
116     const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
117 {
118     return createExclusiveSelectionCriterionFromStateList(remoteCommand.getArgument(0),
119                                                           remoteCommand, strResult)
120                ? CTestPlatform::CCommandHandler::EDone
121                : CTestPlatform::CCommandHandler::EFailed;
122 }
123 CTestPlatform::CommandReturn CTestPlatform::createInclusiveSelectionCriterionFromStateList(
124     const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
125 {
126     return createInclusiveSelectionCriterionFromStateList(remoteCommand.getArgument(0),
127                                                           remoteCommand, strResult)
128                ? CTestPlatform::CCommandHandler::EDone
129                : CTestPlatform::CCommandHandler::EFailed;
130 }
131 CTestPlatform::CommandReturn CTestPlatform::createExclusiveSelectionCriterion(
132     const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
133 {
134     return createExclusiveSelectionCriterion(
135                remoteCommand.getArgument(0),
136                strtoul(remoteCommand.getArgument(1).c_str(), nullptr, 0), strResult)
137                ? CTestPlatform::CCommandHandler::EDone
138                : CTestPlatform::CCommandHandler::EFailed;
139 }
140 CTestPlatform::CommandReturn CTestPlatform::createInclusiveSelectionCriterion(
141     const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
142 {
143     return createInclusiveSelectionCriterion(
144                remoteCommand.getArgument(0),
145                strtoul(remoteCommand.getArgument(1).c_str(), nullptr, 0), strResult)
146                ? CTestPlatform::CCommandHandler::EDone
147                : CTestPlatform::CCommandHandler::EFailed;
148 }
149 CTestPlatform::CommandReturn CTestPlatform::startParameterMgr(
150     const IRemoteCommand &amp; /*remoteCommand*/, string &amp;strResult)
151 {
152     return mParameterMgrPlatformConnector.start(strResult)
153                ? CTestPlatform::CCommandHandler::EDone
154                : CTestPlatform::CCommandHandler::EFailed;
155 }
156 template &lt;CTestPlatform::setter_t setFunction&gt;
157 CTestPlatform::CommandReturn CTestPlatform::setter(const IRemoteCommand &amp;remoteCommand,
158                                                    string &amp;strResult)
159 {
160     const string &amp;strAbort = remoteCommand.getArgument(0);
161     bool bFail;
162     if (!convertTo(strAbort, bFail)) {
163         return CTestPlatform::CCommandHandler::EShowUsage;
164     }
165     return (mParameterMgrPlatformConnector.*setFunction)(bFail, strResult)
166                ? CTestPlatform::CCommandHandler::EDone
167                : CTestPlatform::CCommandHandler::EFailed;
168 }
169 template &lt;CTestPlatform::getter_t getFunction&gt;
170 CTestPlatform::CommandReturn CTestPlatform::getter(const IRemoteCommand &amp; /*command*/,
171                                                    string &amp;strResult)
172 {
173     strResult = (mParameterMgrPlatformConnector.*getFunction)() ? "true" : "false";
174     return CTestPlatform::CCommandHandler::ESucceeded;
175 }
176 CTestPlatform::CommandReturn CTestPlatform::getSchemaUri(const IRemoteCommand &amp; /*remotecommand*/,
177                                                          string &amp;result)
178 {
179     result = mParameterMgrPlatformConnector.getSchemaUri();
180     return CTestPlatform::CCommandHandler::EDone;
181 }
182 CTestPlatform::CommandReturn CTestPlatform::setSchemaUri(const IRemoteCommand &amp;remotecommand,
183                                                          string &amp; /*result*/)
184 {
185     mParameterMgrPlatformConnector.setSchemaUri(remotecommand.getArgument(0));
186     return CTestPlatform::CCommandHandler::EDone;
187 }
188 CTestPlatform::CommandReturn CTestPlatform::setCriterionState(const IRemoteCommand &amp;remoteCommand,
189                                                               string &amp;strResult)
190 {
191     bool bSuccess;
192     uint32_t state;
193     if (convertTo(remoteCommand.getArgument(1), state)) {
194         bSuccess = setCriterionState(remoteCommand.getArgument(0), state, strResult);
195     } else {
196         bSuccess = setCriterionStateByLexicalSpace(remoteCommand, strResult);
197     }
198     return bSuccess ? CTestPlatform::CCommandHandler::EDone
199                     : CTestPlatform::CCommandHandler::EFailed;
200 }
201 CTestPlatform::CommandReturn CTestPlatform::applyConfigurations(const IRemoteCommand &amp; /*command*/,
202                                                                 string &amp; /*strResult*/)
203 {
204     mParameterMgrPlatformConnector.applyConfigurations();
205     return CTestPlatform::CCommandHandler::EDone;
206 }
207 bool CTestPlatform::createExclusiveSelectionCriterionFromStateList(
208     const string &amp;strName, const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
209 {
210     ISelectionCriterionTypeInterface *pCriterionType =
211         mParameterMgrPlatformConnector.createSelectionCriterionType(false);
212     assert(pCriterionType != nullptr);
213     size_t nbStates = remoteCommand.getArgumentCount() - 1;
214     for (size_t state = 0; state &lt; nbStates; state++) {
215         const std::string &amp;strValue = remoteCommand.getArgument(state + 1);
216         if (!pCriterionType-&gt;addValuePair(int(state), strValue, strResult)) {
217             strResult = "Unable to add value: " + strValue + ": " + strResult;
218             return false;
219         }
220     }
221     mParameterMgrPlatformConnector.createSelectionCriterion(strName, pCriterionType);
222     return true;
223 }
224 bool CTestPlatform::createInclusiveSelectionCriterionFromStateList(
225     const string &amp;strName, const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
226 {
227     ISelectionCriterionTypeInterface *pCriterionType =
228         mParameterMgrPlatformConnector.createSelectionCriterionType(true);
229     assert(pCriterionType != nullptr);
230     size_t nbStates = remoteCommand.getArgumentCount() - 1;
231     for (size_t state = 0; state &lt; nbStates; state++) {
232         const std::string &amp;strValue = remoteCommand.getArgument(state + 1);
233         if (!pCriterionType-&gt;addValuePair(0x1 &lt;&lt; state, strValue, strResult)) {
234             strResult = "Unable to add value: " + strValue + ": " + strResult;
235             return false;
236         }
237     }
238     mParameterMgrPlatformConnector.createSelectionCriterion(strName, pCriterionType);
239     return true;
240 }
241 bool CTestPlatform::createExclusiveSelectionCriterion(const string &amp;strName, size_t nbStates,
242                                                       string &amp;strResult)
243 {
244     ISelectionCriterionTypeInterface *pCriterionType =
245         mParameterMgrPlatformConnector.createSelectionCriterionType(false);
246     for (size_t state = 0; state &lt; nbStates; state++) {
247         std::ostringstream ostrValue;
248         ostrValue &lt;&lt; "State_";
249         ostrValue &lt;&lt; state;
250         if (!pCriterionType-&gt;addValuePair(int(state), ostrValue.str(), strResult)) {
251             strResult = "Unable to add value: " + ostrValue.str() + ": " + strResult;
252             return false;
253         }
254     }
255     mParameterMgrPlatformConnector.createSelectionCriterion(strName, pCriterionType);
256     return true;
257 }
258 bool CTestPlatform::createInclusiveSelectionCriterion(const string &amp;strName, size_t nbStates,
259                                                       string &amp;strResult)
260 {
261     ISelectionCriterionTypeInterface *pCriterionType =
262         mParameterMgrPlatformConnector.createSelectionCriterionType(true);
263     for (size_t state = 0; state &lt; nbStates; state++) {
264         std::ostringstream ostrValue;
265         ostrValue &lt;&lt; "State_0x";
266         ostrValue &lt;&lt; (0x1 &lt;&lt; state);
267         if (!pCriterionType-&gt;addValuePair(0x1 &lt;&lt; state, ostrValue.str(), strResult)) {
268             strResult = "Unable to add value: " + ostrValue.str() + ": " + strResult;
269             return false;
270         }
271     }
272 <a name="0"></a>
273     mParameterMgrPlatformConnector.createSelectionCriterion(strName, pCriterionType);
274 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    return true;
275 }
276 bool CTestPlatform::setCriterionState(const string &amp;strName, uint32_t uiState, string &amp;strResult)
277 {
278     ISelectionCriterionInterface *pCriterion =
279         mParameterMgrPlatformConnector.getSelectionCriterion(strName);
280     if (!pCriterion) {
281         strResult = "Unable to retrieve selection criterion: " + strName;
282         return false;
283     }
284     pCriterion-&gt;setCriterionState(uiState);
285     return true;
286 }</b></font>
287 bool CTestPlatform::setCriterionStateByLexicalSpace(const IRemoteCommand &amp;remoteCommand,
288                                                     string &amp;strResult)
289 {
290     std::string strCriterionName = remoteCommand.getArgument(0);
291     ISelectionCriterionInterface *pCriterion =
292         mParameterMgrPlatformConnector.getSelectionCriterion(strCriterionName);
293     if (!pCriterion) {
294         strResult = "Unable to retrieve selection criterion: " + strCriterionName;
295         return false;
296     }
297     const ISelectionCriterionTypeInterface *pCriterionType = pCriterion-&gt;getCriterionType();
298     size_t nbSubStates = remoteCommand.getArgumentCount() - 1;
299     if (!pCriterionType-&gt;isTypeInclusive() &amp;&amp; nbSubStates != 1) {
300         strResult = "Exclusive criterion " + strCriterionName + " can only have one state";
301         return false;
302     }
303     int iNumericalState = 0;
304     size_t lexicalSubStateIndex;
305     std::string strLexicalState = "";
306     for (lexicalSubStateIndex = 1; lexicalSubStateIndex &lt;= nbSubStates; lexicalSubStateIndex++) {
307         /*
308          * getNumericalValue method from ISelectionCriterionTypeInterface strip his parameter
309          * first parameter based on | sign. In case that the user uses multiple parameters
310          * to set InclusiveCriterion value, we aggregate all desired values to be sure
311          * they will be handled correctly.
312          */
313         if (lexicalSubStateIndex != 1) {
314             strLexicalState += "|";
315         }
316         strLexicalState += remoteCommand.getArgument(lexicalSubStateIndex);
317     }
318     if (!pCriterionType-&gt;getNumericalValue(strLexicalState, iNumericalState)) {
319         strResult = "Unable to find lexical state \"" + strLexicalState + "\" in criteria " +
320                     strCriterionName;
321         return false;
322     }
323     pCriterion-&gt;setCriterionState(iNumericalState);
324     return true;
325 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ConfigurableDomain.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 /*
2  * Copyright (c) 2011-2015, Intel Corporation
3  * All rights reserved.
4  *
5  * Redistribution and use in source and binary forms, with or without modification,
6  * are permitted provided that the following conditions are met:
7  *
8  * 1. Redistributions of source code must retain the above copyright notice, this
9  * list of conditions and the following disclaimer.
10  *
11  * 2. Redistributions in binary form must reproduce the above copyright notice,
12  * this list of conditions and the following disclaimer in the documentation and/or
13  * other materials provided with the distribution.
14  *
15  * 3. Neither the name of the copyright holder nor the names of its contributors
16  * may be used to endorse or promote products derived from this software without
17  * specific prior written permission.
18  *
19  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
20  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
21  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
22  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
23  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
24  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
25  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
26  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
27  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
28  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
29  */
30 #include "ConfigurableDomain.h"
31 #include "DomainConfiguration.h"
32 #include "ConfigurableElement.h"
33 #include "ConfigurationAccessContext.h"
34 #include "XmlDomainSerializingContext.h"
35 #include "XmlDomainImportContext.h"
36 #include "XmlDomainExportContext.h"
37 #include "Utility.h"
38 #include "AlwaysAssert.hpp"
39 #include &lt;cassert&gt;
40 #define base CElement
41 using std::string;
42 CConfigurableDomain::CConfigurableDomain(const string &amp;strName) : base(strName)
43 {
44 }
45 CConfigurableDomain::~CConfigurableDomain()
46 {
47     ConfigurableElementListIterator it;
48     for (it = _configurableElementList.begin(); it != _configurableElementList.end(); ++it) {
49         CConfigurableElement *pConfigurableElement = *it;
50         pConfigurableElement-&gt;removeAttachedConfigurableDomain(this);
51     }
52     ConfigurableElementToSyncerSetMapIterator mapIt;
53     for (mapIt = _configurableElementToSyncerSetMap.begin();
54          mapIt != _configurableElementToSyncerSetMap.end(); ++mapIt) {
55         delete mapIt-&gt;second;
56     }
57 }
58 string CConfigurableDomain::getKind() const
59 {
60     return "ConfigurableDomain";
61 }
62 bool CConfigurableDomain::childrenAreDynamic() const
63 {
64     return true;
65 }
66 string CConfigurableDomain::logValue(utility::ErrorContext &amp; /*ctx*/) const
67 {
68     return string("{") +
69            "Sequence aware: " + (_bSequenceAware ? "yes" : "no") +
70            ", Last applied configuration: " +
71            (_pLastAppliedConfiguration ? _pLastAppliedConfiguration-&gt;getName() : "&lt;none&gt;") +
72            "}";
73 }
74 void CConfigurableDomain::setSequenceAwareness(bool bSequenceAware)
75 {
76     if (_bSequenceAware != bSequenceAware) {
77         _bSequenceAware = bSequenceAware;
78     }
79 }
80 bool CConfigurableDomain::getSequenceAwareness() const
81 {
82     return _bSequenceAware;
83 }
84 void CConfigurableDomain::toXml(CXmlElement &amp;xmlElement,
85                                 CXmlSerializingContext &amp;serializingContext) const
86 {
87     base::toXml(xmlElement, serializingContext);
88     xmlElement.setAttribute("SequenceAware", _bSequenceAware);
89 }
90 void CConfigurableDomain::childrenToXml(CXmlElement &amp;xmlElement,
91                                         CXmlSerializingContext &amp;serializingContext) const
92 {
93     composeDomainConfigurations(xmlElement, serializingContext);
94     composeConfigurableElements(xmlElement);
95     composeSettings(xmlElement, static_cast&lt;CXmlDomainExportContext &amp;&gt;(serializingContext));
96 }
97 void CConfigurableDomain::composeDomainConfigurations(
98     CXmlElement &amp;xmlElement, CXmlSerializingContext &amp;serializingContext) const
99 {
100     CXmlElement xmlConfigurationsElement;
101     xmlElement.createChild(xmlConfigurationsElement, "Configurations");
102     base::childrenToXml(xmlConfigurationsElement, serializingContext);
103 }
104 void CConfigurableDomain::composeConfigurableElements(CXmlElement &amp;xmlElement) const
105 {
106     CXmlElement xmlConfigurableElementsElement;
107     xmlElement.createChild(xmlConfigurableElementsElement, "ConfigurableElements");
108     ConfigurableElementListIterator it;
109     for (it = _configurableElementList.begin(); it != _configurableElementList.end(); ++it) {
110         const CConfigurableElement *pConfigurableElement = *it;
111         CXmlElement xmlChildConfigurableElement;
112         xmlConfigurableElementsElement.createChild(xmlChildConfigurableElement,
113                                                    "ConfigurableElement");
114         xmlChildConfigurableElement.setAttribute("Path", pConfigurableElement-&gt;getPath());
115     }
116 }
117 void CConfigurableDomain::composeSettings(CXmlElement &amp;xmlElement,
118                                           CXmlDomainExportContext &amp;context) const
119 {
120     if (!context.withSettings()) {
121         return;
122     }
123     CXmlElement xmlSettingsElement;
124     xmlElement.createChild(xmlSettingsElement, "Settings");
125     size_t uiNbConfigurations = getNbChildren();
126     size_t uiChildConfiguration;
127     for (uiChildConfiguration = 0; uiChildConfiguration &lt; uiNbConfigurations;
128          uiChildConfiguration++) {
129         const CDomainConfiguration *pDomainConfiguration =
130             static_cast&lt;const CDomainConfiguration *&gt;(getChild(uiChildConfiguration));
131         CXmlElement xmlConfigurationSettingsElement;
132         xmlSettingsElement.createChild(xmlConfigurationSettingsElement,
133                                        pDomainConfiguration-&gt;getXmlElementName());
134         xmlConfigurationSettingsElement.setNameAttribute(pDomainConfiguration-&gt;getName());
135         pDomainConfiguration-&gt;composeSettings(xmlConfigurationSettingsElement, context);
136     }
137 }
138 bool CConfigurableDomain::fromXml(const CXmlElement &amp;xmlElement,
139                                   CXmlSerializingContext &amp;serializingContext)
140 {
141     CXmlDomainImportContext &amp;xmlDomainImportContext =
142         static_cast&lt;CXmlDomainImportContext &amp;&gt;(serializingContext);
143     xmlElement.getAttribute("SequenceAware", _bSequenceAware);
144     std::string name;
145     xmlElement.getAttribute("Name", name);
146     setName(name);
147     if (!parseDomainConfigurations(xmlElement, xmlDomainImportContext) ||
148         !parseConfigurableElements(xmlElement, xmlDomainImportContext) ||
149         !parseSettings(xmlElement, xmlDomainImportContext)) {
150         return false;
151     }
152     if (xmlDomainImportContext.autoValidationRequired()) {
153         autoValidateAll();
154     }
155     return true;
156 }
157 bool CConfigurableDomain::parseDomainConfigurations(const CXmlElement &amp;xmlElement,
158                                                     CXmlDomainImportContext &amp;serializingContext)
159 {
160     assert(_configurableElementList.empty());
161     CXmlElement xmlConfigurationsElement;
162     xmlElement.getChildElement("Configurations", xmlConfigurationsElement);
163     return base::fromXml(xmlConfigurationsElement, serializingContext);
164 }
165 bool CConfigurableDomain::parseConfigurableElements(const CXmlElement &amp;xmlElement,
166                                                     CXmlDomainImportContext &amp;serializingContext)
167 {
168     CSystemClass &amp;systemClass = serializingContext.getSystemClass();
169     CXmlElement xmlConfigurableElementsElement;
170     xmlElement.getChildElement("ConfigurableElements", xmlConfigurableElementsElement);
171     CXmlElement::CChildIterator it(xmlConfigurableElementsElement);
172     CXmlElement xmlConfigurableElementElement;
173     while (it.next(xmlConfigurableElementElement)) {
174         string strConfigurableElementPath;
175         xmlConfigurableElementElement.getAttribute("Path", strConfigurableElementPath);
176         CPathNavigator pathNavigator(strConfigurableElementPath);
177         string strError;
178         if (!pathNavigator.navigateThrough(systemClass.getName(), strError)) {
179             serializingContext.setError(
180                 "Could not find configurable element of path " + strConfigurableElementPath +
181                 " from ConfigurableDomain description " + getName() + " (" + strError + ")");
182             return false;
183         }
184         CConfigurableElement *pConfigurableElement =
185             static_cast&lt;CConfigurableElement *&gt;(systemClass.findDescendant(pathNavigator));
186         if (!pConfigurableElement) {
187             serializingContext.setError("Could not find configurable element of path " +
188                                         strConfigurableElementPath +
189                                         " from ConfigurableDomain description " + getName());
190             return false;
191         }
192         core::Results infos;
193         if (!addConfigurableElement(pConfigurableElement, nullptr, infos)) {
194             strError = utility::asString(infos);
195             serializingContext.setError(strError);
196             return false;
197         }
198     }
199     return true;
200 }
201 bool CConfigurableDomain::parseSettings(const CXmlElement &amp;xmlElement,
202                                         CXmlDomainImportContext &amp;serializingContext)
203 {
204     if (!serializingContext.withSettings()) {
205         return true;
206     }
207     CXmlElement xmlSettingsElement;
208     if (!xmlElement.getChildElement("Settings", xmlSettingsElement)) {
209         return true;
210     }
211     CXmlElement::CChildIterator it(xmlSettingsElement);
212     CXmlElement xmlConfigurationSettingsElement;
213     while (it.next(xmlConfigurationSettingsElement)) {
214         CDomainConfiguration *pDomainConfiguration = static_cast&lt;CDomainConfiguration *&gt;(
215             findChild(xmlConfigurationSettingsElement.getNameAttribute()));
216         if (!pDomainConfiguration) {
217             serializingContext.setError("Could not find domain configuration referred to by"
218                                         " configurable domain \"" +
219                                         getName() + "\".");
220             return false;
221         }
222         if (!pDomainConfiguration-&gt;parseSettings(xmlConfigurationSettingsElement,
223                                                  serializingContext)) {
224             return false;
225         }
226     }
227     return true;
228 }
229 bool CConfigurableDomain::addConfigurableElement(CConfigurableElement *pConfigurableElement,
230                                                  const CParameterBlackboard *pMainBlackboard,
231                                                  core::Results &amp;infos)
232 {
233     if (containsConfigurableElement(pConfigurableElement)) {
234         infos.push_back("Configurable element " + pConfigurableElement-&gt;getPath() +
235                         " already associated to configuration domain " + getName());
236         return false;
237     }
238     if (pConfigurableElement-&gt;belongsTo(this)) {
239         infos.push_back("Configurable element " + pConfigurableElement-&gt;getPath() +
240                         " already owned by configuration domain " + getName());
241         return false;
242     }
243     doAddConfigurableElement(pConfigurableElement, infos, pMainBlackboard);
244     return true;
245 }
246 bool CConfigurableDomain::removeConfigurableElement(CConfigurableElement *pConfigurableElement,
247                                                     string &amp;strError)
248 {
249     if (!containsConfigurableElement(pConfigurableElement)) {
250         strError = "Configurable element " + pConfigurableElement-&gt;getPath() +
251                    " not associated to configuration domain " + getName();
252         return false;
253     }
254     doRemoveConfigurableElement(pConfigurableElement, true);
255     return true;
256 }
257 /**
258 * Blackboard Configuration and Base Offset retrieval.
259 *
260 * This method fetches the Blackboard associated to the ConfigurableElement
261 * given in parameter, for a specific Configuration. The ConfigurableElement
262 * must belong to the Domain. If a Blackboard is found, the base offset of
263 * the ConfigurableElement is returned as well. This base offset corresponds to
264 * the offset of the ancestor of the ConfigurableElement associated to the Configuration.
265 *
266 * @param[in] strConfiguration                           Name of the Configuration.
267 * @param[in] pCandidateDescendantConfigurableElement    Pointer to a CConfigurableElement that
268 *                                                       belongs to the Domain.
269 * @param[out] baseOffset                              The base offset of the CConfigurableElement.
270 * @param[out] bIsLastApplied                            Boolean indicating that the Configuration is
271 *                                                       the last one applied of the Domain.
272 * @param[out] strError                                  Error message
273 *
274 * return Pointer to the Blackboard of the Configuration.
275 */
276 CParameterBlackboard *CConfigurableDomain::findConfigurationBlackboard(
277     const string &amp;strConfiguration,
278     const CConfigurableElement *pCandidateDescendantConfigurableElement, size_t &amp;baseOffset,
279     bool &amp;bIsLastApplied, string &amp;strError) const
280 {
281     const CDomainConfiguration *pDomainConfiguration =
282         static_cast&lt;const CDomainConfiguration *&gt;(findChild(strConfiguration));
283     if (!pDomainConfiguration) {
284         strError = "Domain configuration " + strConfiguration + " not found";
285         return nullptr;
286     }
287     ConfigurableElementListIterator it;
288     for (it = _configurableElementList.begin(); it != _configurableElementList.end(); ++it) {
289         const CConfigurableElement *pAssociatedConfigurableElement = *it;
290         if ((pCandidateDescendantConfigurableElement == pAssociatedConfigurableElement) ||
291             (pCandidateDescendantConfigurableElement-&gt;isDescendantOf(
292                 pAssociatedConfigurableElement))) {
293             baseOffset = pAssociatedConfigurableElement-&gt;getOffset();
294             bIsLastApplied = (pDomainConfiguration == _pLastAppliedConfiguration);
295             return pDomainConfiguration-&gt;getBlackboard(pAssociatedConfigurableElement);
296         }
297     }
298     strError = "Element not associated to the Domain";
299     return nullptr;
300 }
301 bool CConfigurableDomain::split(CConfigurableElement *pConfigurableElement, core::Results &amp;infos)
302 {
303     if (!containsConfigurableElement(pConfigurableElement)) {
304         std::string strError = "Configurable element " + pConfigurableElement-&gt;getPath() +
305                                " not associated to configuration domain " + getName();
306         infos.push_back(strError);
307         return false;
308     }
309     size_t uiNbConfigurableElementChildren = pConfigurableElement-&gt;getNbChildren();
310     if (!uiNbConfigurableElementChildren) {
311         std::string strError = "Configurable element " + pConfigurableElement-&gt;getPath() +
312                                " has no children to split configurable domain to";
313         infos.push_back(strError);
314         return false;
315     }
316     for (size_t uiChild = 0; uiChild &lt; uiNbConfigurableElementChildren; uiChild++) {
317         CConfigurableElement *pChildConfigurableElement =
318             static_cast&lt;CConfigurableElement *&gt;(pConfigurableElement-&gt;getChild(uiChild));
319         doAddConfigurableElement(pChildConfigurableElement, infos);
320     }
321     size_t uiNbConfigurations = getNbChildren();
322     for (size_t uiChild = 0; uiChild &lt; uiNbConfigurations; uiChild++) {
323         CDomainConfiguration *pDomainConfiguration =
324             static_cast&lt;CDomainConfiguration *&gt;(getChild(uiChild));
325         pDomainConfiguration-&gt;split(pConfigurableElement);
326     }
327     doRemoveConfigurableElement(pConfigurableElement, false);
328     return true;
329 }
330 const CDomainConfiguration *CConfigurableDomain::getPendingConfiguration() const
331 {
332     const CDomainConfiguration *pApplicableDomainConfiguration =
333         findApplicableDomainConfiguration();
334     if (pApplicableDomainConfiguration) {
335         if (!_pLastAppliedConfiguration ||
336             (_pLastAppliedConfiguration != pApplicableDomainConfiguration)) {
337             return pApplicableDomainConfiguration;
338         }
339     }
340     return nullptr;
341 }
342 void CConfigurableDomain::apply(CParameterBlackboard *pParameterBlackboard, CSyncerSet *pSyncerSet,
343                                 bool bForce, std::string &amp;strInfo) const
344 {
345     if (!pSyncerSet ^ _bSequenceAware) {
346         return;
347     }
348     if (bForce) {
349         _pLastAppliedConfiguration = nullptr;
350     }
351     const CDomainConfiguration *pApplicableDomainConfiguration =
352         findApplicableDomainConfiguration();
353     if (pApplicableDomainConfiguration) {
354         if (!_pLastAppliedConfiguration ||
355             _pLastAppliedConfiguration != pApplicableDomainConfiguration) {
356             strInfo = "Applying configuration '" + pApplicableDomainConfiguration-&gt;getName() +
357                       "' from domain '" + getName() + "'";
358             bool bSync = !pSyncerSet &amp;&amp; _bSequenceAware;
359             pApplicableDomainConfiguration-&gt;restore(pParameterBlackboard, bSync, nullptr);
360             _pLastAppliedConfiguration = pApplicableDomainConfiguration;
361             if (pSyncerSet &amp;&amp; !_bSequenceAware) {
362                 *pSyncerSet += _syncerSet;
363             }
364         }
365     }
366 }
367 bool CConfigurableDomain::isApplicableConfigurationValid(
368     const CConfigurableElement *pConfigurableElement) const
369 {
370     const CDomainConfiguration *pApplicableDomainConfiguration =
371         findApplicableDomainConfiguration();
372     return pApplicableDomainConfiguration &amp;&amp;
373            pApplicableDomainConfiguration-&gt;isValid(pConfigurableElement);
374 }
375 void CConfigurableDomain::computeSyncSet()
376 {
377     _syncerSet.clear();
378     ConfigurableElementToSyncerSetMapIterator mapIt;
379     for (mapIt = _configurableElementToSyncerSetMap.begin();
380          mapIt != _configurableElementToSyncerSetMap.end(); ++mapIt) {
381         const CSyncerSet *pSyncerSet = mapIt-&gt;second;
382         _syncerSet += *pSyncerSet;
383     }
384 }
385 bool CConfigurableDomain::createConfiguration(const string &amp;strName,
386                                               const CParameterBlackboard *pMainBlackboard,
387                                               string &amp;strError)
388 {
389     if (findChild(strName)) {
390         strError = "Already existing configuration";
391         return false;
392     }
393     auto pDomainConfiguration = new CDomainConfiguration(strName);
394     ConfigurableElementListIterator it;
395     for (it = _configurableElementList.begin(); it != _configurableElementList.end(); ++it) {
396         const CConfigurableElement *pConfigurableElement = *it;
397         ;
398         CSyncerSet *pSyncerSet = getSyncerSet(pConfigurableElement);
399         pDomainConfiguration-&gt;addConfigurableElement(pConfigurableElement, pSyncerSet);
400     }
401     addChild(pDomainConfiguration);
402     if (!autoValidateConfiguration(pDomainConfiguration)) {
403         pDomainConfiguration-&gt;validate(pMainBlackboard);
404     }
405     return true;
406 }
407 bool CConfigurableDomain::deleteConfiguration(const string &amp;strName, string &amp;strError)
408 {
409     CDomainConfiguration *pDomainConfiguration = findConfiguration(strName, strError);
410     if (!pDomainConfiguration) {
411         return false;
412     }
413     if (pDomainConfiguration == _pLastAppliedConfiguration) {
414         _pLastAppliedConfiguration = nullptr;
415     }
416     removeChild(pDomainConfiguration);
417     delete pDomainConfiguration;
418     return true;
419 }
420 void CConfigurableDomain::listAssociatedToElements(string &amp;strResult) const
421 {
422     ConfigurableElementListIterator it;
423     for (it = _configurableElementList.begin(); it != _configurableElementList.end(); ++it) {
424         const CConfigurableElement *pConfigurableElement = *it;
425         strResult += pConfigurableElement-&gt;getPath() + "\n";
426     }
427 }
428 bool CConfigurableDomain::renameConfiguration(const string &amp;strName, const string &amp;strNewName,
429                                               string &amp;strError)
430 {
431     CDomainConfiguration *pDomainConfiguration = findConfiguration(strName, strError);
432     if (!pDomainConfiguration) {
433         return false;
434     }
435     return pDomainConfiguration-&gt;rename(strNewName, strError);
436 }
437 bool CConfigurableDomain::restoreConfiguration(const string &amp;configurationName,
438                                                CParameterBlackboard *mainBlackboard, bool autoSync,
439                                                core::Results &amp;errors) const
440 {
441     string error;
442     const CDomainConfiguration *configuration = findConfiguration(configurationName, error);
443     if (configuration == nullptr) {
444         errors.push_back(error);
445         return false;
446     }
447     bool bSuccess = configuration-&gt;restore(mainBlackboard, autoSync &amp;&amp; _bSequenceAware, &amp;errors);
448     _pLastAppliedConfiguration = configuration;
449     if (autoSync &amp;&amp; !_bSequenceAware) {
450         bSuccess &amp;= _syncerSet.sync(*mainBlackboard, false, &amp;errors);
451     }
452     return bSuccess;
453 }
454 bool CConfigurableDomain::saveConfiguration(const string &amp;strName,
455                                             const CParameterBlackboard *pMainBlackboard,
456                                             string &amp;strError)
457 {
458     CDomainConfiguration *pDomainConfiguration = findConfiguration(strName, strError);
459     if (!pDomainConfiguration) {
460         return false;
461     }
462     pDomainConfiguration-&gt;save(pMainBlackboard);
463     return true;
464 }
465 bool CConfigurableDomain::setElementSequence(const string &amp;strConfiguration,
466                                              const std::vector&lt;string&gt; &amp;astrNewElementSequence,
467                                              string &amp;strError)
468 {
469     CDomainConfiguration *pDomainConfiguration = findConfiguration(strConfiguration, strError);
470     if (!pDomainConfiguration) {
471         return false;
472     }
473     return pDomainConfiguration-&gt;setElementSequence(astrNewElementSequence, strError);
474 }
475 bool CConfigurableDomain::getElementSequence(const string &amp;strConfiguration,
476                                              string &amp;strResult) const
477 {
478     const CDomainConfiguration *pDomainConfiguration =
479         findConfiguration(strConfiguration, strResult);
480     if (!pDomainConfiguration) {
481         return false;
482     }
483     pDomainConfiguration-&gt;getElementSequence(strResult);
484     return true;
485 }
486 bool CConfigurableDomain::setApplicationRule(
487     const string &amp;strConfiguration, const string &amp;strApplicationRule,
488     const CSelectionCriteriaDefinition *pSelectionCriteriaDefinition, string &amp;strError)
489 {
490     CDomainConfiguration *pDomainConfiguration = findConfiguration(strConfiguration, strError);
491     if (!pDomainConfiguration) {
492         return false;
493     }
494     return pDomainConfiguration-&gt;setApplicationRule(strApplicationRule,
495                                                     pSelectionCriteriaDefinition, strError);
496 }
497 bool CConfigurableDomain::clearApplicationRule(const string &amp;strConfiguration, string &amp;strError)
498 {
499     CDomainConfiguration *pDomainConfiguration = findConfiguration(strConfiguration, strError);
500     if (!pDomainConfiguration) {
501         return false;
502     }
503     pDomainConfiguration-&gt;clearApplicationRule();
504     return true;
505 }
506 bool CConfigurableDomain::getApplicationRule(const string &amp;strConfiguration,
507                                              string &amp;strResult) const
508 {
509     const CDomainConfiguration *pDomainConfiguration =
510         findConfiguration(strConfiguration, strResult);
511     if (!pDomainConfiguration) {
512         return false;
513     }
514     strResult = pDomainConfiguration-&gt;getApplicationRule();
515     return true;
516 }
517 string CConfigurableDomain::getLastAppliedConfigurationName() const
518 {
519     if (_pLastAppliedConfiguration) {
520         return _pLastAppliedConfiguration-&gt;getName();
521     }
522     return "&lt;none&gt;";
523 }
524 string CConfigurableDomain::getPendingConfigurationName() const
525 {
526     const CDomainConfiguration *pApplicableDomainConfiguration =
527         findApplicableDomainConfiguration();
528     if (!pApplicableDomainConfiguration) {
529         return "&lt;none&gt;";
530     }
531     if (pApplicableDomainConfiguration != _pLastAppliedConfiguration) {
532         return pApplicableDomainConfiguration-&gt;getName();
533     } else {
534         return "";
535     }
536 }
537 void CConfigurableDomain::validate(const CParameterBlackboard *pMainBlackboard)
538 {
539     size_t uiNbConfigurations = getNbChildren();
540     for (size_t uiChild = 0; uiChild &lt; uiNbConfigurations; uiChild++) {
541         CDomainConfiguration *pDomainConfiguration =
542             static_cast&lt;CDomainConfiguration *&gt;(getChild(uiChild));
543         pDomainConfiguration-&gt;validate(pMainBlackboard);
544     }
545 }
546 void CConfigurableDomain::validateAreas(const CConfigurableElement *pConfigurableElement,
547                                         const CParameterBlackboard *pMainBlackboard)
548 {
549     size_t uiNbConfigurations = getNbChildren();
550     for (size_t uiChild = 0; uiChild &lt; uiNbConfigurations; uiChild++) {
551         CDomainConfiguration *pDomainConfiguration =
552             static_cast&lt;CDomainConfiguration *&gt;(getChild(uiChild));
553         pDomainConfiguration-&gt;validate(pConfigurableElement, pMainBlackboard);
554     }
555 }
556 void CConfigurableDomain::autoValidateAll()
557 {
558     ConfigurableElementListIterator it;
559     for (it = _configurableElementList.begin(); it != _configurableElementList.end(); ++it) {
560         const CConfigurableElement *pConfigurableElement = *it;
561         autoValidateAreas(pConfigurableElement);
562     }
563 }
564 void CConfigurableDomain::autoValidateAreas(const CConfigurableElement *pConfigurableElement)
565 {
566     const CDomainConfiguration *pValidDomainConfiguration =
567         findValidDomainConfiguration(pConfigurableElement);
568     if (!pValidDomainConfiguration) {
569         return;
570     }
571     size_t uiNbConfigurations = getNbChildren();
572     for (size_t uiChild = 0; uiChild &lt; uiNbConfigurations; uiChild++) {
573         CDomainConfiguration *pDomainConfiguration =
574             static_cast&lt;CDomainConfiguration *&gt;(getChild(uiChild));
575         if (pDomainConfiguration != pValidDomainConfiguration &amp;&amp;
576             !pDomainConfiguration-&gt;isValid(pConfigurableElement)) {
577             pDomainConfiguration-&gt;validateAgainst(pValidDomainConfiguration, pConfigurableElement);
578         }
579     }
580 }
581 bool CConfigurableDomain::autoValidateConfiguration(CDomainConfiguration *pDomainConfiguration)
582 {
583     size_t uiNbConfigurations = getNbChildren();
584     for (size_t uiChild = 0; uiChild &lt; uiNbConfigurations; uiChild++) {
585         const CDomainConfiguration *pPotententialValidDomainConfiguration =
586             static_cast&lt;const CDomainConfiguration *&gt;(getChild(uiChild));
587         if (pPotententialValidDomainConfiguration != pDomainConfiguration) {
588             pDomainConfiguration-&gt;validateAgainst(pPotententialValidDomainConfiguration);
589             return true;
590         }
591     }
592     return false;
593 }
594 const CDomainConfiguration *CConfigurableDomain::findValidDomainConfiguration(
595     const CConfigurableElement *pConfigurableElement) const
596 {
597     size_t uiNbConfigurations = getNbChildren();
598     for (size_t uiChild = 0; uiChild &lt; uiNbConfigurations; uiChild++) {
599         const CDomainConfiguration *pDomainConfiguration =
600             static_cast&lt;const CDomainConfiguration *&gt;(getChild(uiChild));
601         if (pDomainConfiguration-&gt;isValid(pConfigurableElement)) {
602             return pDomainConfiguration;
603         }
604     }
605     return nullptr;
606 }
607 const CDomainConfiguration *CConfigurableDomain::findApplicableDomainConfiguration() const
608 {
609     size_t uiNbConfigurations = getNbChildren();
610     for (size_t uiChild = 0; uiChild &lt; uiNbConfigurations; uiChild++) {
611         const CDomainConfiguration *pDomainConfiguration =
612             static_cast&lt;const CDomainConfiguration *&gt;(getChild(uiChild));
613         if (pDomainConfiguration-&gt;isApplicable()) {
614             return pDomainConfiguration;
615         }
616     }
617     return nullptr;
618 }
619 void CConfigurableDomain::gatherConfigurableElements(
620     std::set&lt;const CConfigurableElement *&gt; &amp;configurableElementSet) const
621 {
622     configurableElementSet.insert(_configurableElementList.begin(), _configurableElementList.end());
623 }
624 bool CConfigurableDomain::containsConfigurableElement(
625     const CConfigurableElement *pConfigurableCandidateElement) const
626 {
627     ConfigurableElementListIterator it;
628     for (it = _configurableElementList.begin(); it != _configurableElementList.end(); ++it) {
629         if (pConfigurableCandidateElement == *it) {
630             return true;
631         }
632     }
633     return false;
634 }
635 void CConfigurableDomain::mergeAlreadyAssociatedDescendantConfigurableElements(
636     CConfigurableElement *newElement, core::Results &amp;infos)
637 {
638     std::list&lt;CConfigurableElement *&gt; mergedConfigurableElementList;
639     ConfigurableElementListIterator it;
640     for (it = _configurableElementList.begin(); it != _configurableElementList.end(); ++it) {
641         CConfigurableElement *pConfigurablePotentialDescendantElement = *it;
642         if (pConfigurablePotentialDescendantElement-&gt;isDescendantOf(newElement)) {
643             infos.push_back("In domain '" + getName() +
644                             "', merging descendant configurable element's configurations '" +
645                             pConfigurablePotentialDescendantElement-&gt;getName() +
646                             "' into its ascendant '" + newElement-&gt;getName() + "' ones");
647             mergeConfigurations(newElement, pConfigurablePotentialDescendantElement);
648             mergedConfigurableElementList.push_back(pConfigurablePotentialDescendantElement);
649         }
650     }
651     for (it = mergedConfigurableElementList.begin(); it != mergedConfigurableElementList.end();
652          ++it) {
653         CConfigurableElement *pMergedConfigurableElement = *it;
654         doRemoveConfigurableElement(pMergedConfigurableElement, false);
655     }
656 }
657 void CConfigurableDomain::mergeConfigurations(CConfigurableElement *pToConfigurableElement,
658                                               CConfigurableElement *pFromConfigurableElement)
659 {
660     size_t uiNbConfigurations = getNbChildren();
661     for (size_t uiChild = 0; uiChild &lt; uiNbConfigurations; uiChild++) {
662         CDomainConfiguration *pDomainConfiguration =
663             static_cast&lt;CDomainConfiguration *&gt;(getChild(uiChild));
664         pDomainConfiguration-&gt;merge(pToConfigurableElement, pFromConfigurableElement);
665     }
666 }
667 void CConfigurableDomain::doAddConfigurableElement(CConfigurableElement *pConfigurableElement,
668                                                    core::Results &amp;infos,
669                                                    const CParameterBlackboard *pMainBlackboard)
670 {
671     pConfigurableElement-&gt;addAttachedConfigurableDomain(this);
672     auto pSyncerSet = new CSyncerSet;
673     pConfigurableElement-&gt;fillSyncerSet(*pSyncerSet);
674     _configurableElementToSyncerSetMap[pConfigurableElement] = pSyncerSet;
675     _syncerSet += *pSyncerSet;
676     size_t uiNbConfigurations = getNbChildren();
677     for (size_t uiChild = 0; uiChild &lt; uiNbConfigurations; uiChild++) {
678         CDomainConfiguration *pDomainConfiguration =
679             static_cast&lt;CDomainConfiguration *&gt;(getChild(uiChild));
680         pDomainConfiguration-&gt;addConfigurableElement(pConfigurableElement, pSyncerSet);
681     }
682     if (pMainBlackboard) {
683         infos.push_back("Validating domain '" + getName() +
684                         "' against main blackboard for configurable element '" +
685                         pConfigurableElement-&gt;getPath() + "'");
686         validateAreas(pConfigurableElement, pMainBlackboard);
687     }
688     mergeAlreadyAssociatedDescendantConfigurableElements(pConfigurableElement, infos);
689     _configurableElementList.push_back(pConfigurableElement);
690 }
691 void CConfigurableDomain::doRemoveConfigurableElement(CConfigurableElement *pConfigurableElement,
692                                                       bool bRecomputeSyncSet)
693 {
694     _configurableElementList.remove(pConfigurableElement);
695     CSyncerSet *pSyncerSet = getSyncerSet(pConfigurableElement);
696     _configurableElementToSyncerSetMap.erase(pConfigurableElement);
697     delete pSyncerSet;
698     pConfigurableElement-&gt;removeAttachedConfigurableDomain(this);
699     size_t uiNbConfigurations = getNbChildren();
700     for (size_t uiChild = 0; uiChild &lt; uiNbConfigurations; uiChild++) {
701         CDomainConfiguration *pDomainConfiguration =
702             static_cast&lt;CDomainConfiguration *&gt;(getChild(uiChild));
703         pDomainConfiguration-&gt;removeConfigurableElement(pConfigurableElement);
704     }
705     if (bRecomputeSyncSet) {
706         computeSyncSet();
707     }
708 }
709 CSyncerSet *CConfigurableDomain::getSyncerSet(
710     const CConfigurableElement *pConfigurableElement) const
711 {
712     auto mapIt = _configurableElementToSyncerSetMap.find(pConfigurableElement);
713 <a name="0"></a>    ALWAYS_ASSERT(mapIt != _configurableElementToSyncerSetMap.end(),
714                   "Could not find syncer set for " &lt;&lt; getName() &lt;&lt; " configurable domain");
715 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    return mapIt-&gt;second;
716 }
717 CDomainConfiguration *CConfigurableDomain::findConfiguration(const string &amp;strConfiguration,
718                                                              string &amp;strError)
719 {
720     CDomainConfiguration *pDomainConfiguration =
721         static_cast&lt;CDomainConfiguration *&gt;(findChild(strConfiguration));
722     if (!pDomainConfiguration) {
723         strError = "Domain configuration " + strConfiguration + " not found";
724         return nullptr;
725     }
726     return pDomainConfiguration;
727 }</b></font>
728 const CDomainConfiguration *CConfigurableDomain::findConfiguration(const string &amp;strConfiguration,
729                                                                    string &amp;strError) const
730 {
731     const CDomainConfiguration *pDomainConfiguration =
732         static_cast&lt;const CDomainConfiguration *&gt;(findChild(strConfiguration));
733     if (!pDomainConfiguration) {
734         strError = "Domain configuration " + strConfiguration + " not found";
735         return nullptr;
736     }
737     return pDomainConfiguration;
738 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
