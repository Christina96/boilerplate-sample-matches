<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for TestPlatform.cpp & ConfigurableDomain.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for TestPlatform.cpp & ConfigurableDomain.cpp
      </h3>
      <h1 align="center">
        2.4%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>TestPlatform.cpp (4.193548%)<TH>ConfigurableDomain.cpp (1.7591339%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match581-0.html#0',2,'match581-1.html#0',3)" NAME="0">(360-378)<TD><A HREF="javascript:ZweiFrames('match581-0.html#0',2,'match581-1.html#0',3)" NAME="0">(1190-1207)</A><TD ALIGN=center><FONT COLOR="#ff0000">13</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>TestPlatform.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (c) 2011-2015, Intel Corporation
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation and/or
 * other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its contributors
 * may be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include &lt;stdlib.h&gt;
#include &lt;sstream&gt;
#include &lt;assert.h&gt;
#include &lt;errno.h&gt;
#include &lt;convert.hpp&gt;
#include &lt;sstream&gt;
#include &quot;TestPlatform.h&quot;

using std::string;

CTestPlatform::CTestPlatform(const string &amp;strClass, uint16_t iPortNumber)
    : mParameterMgrPlatformConnector(strClass), mLogger(), mRemoteProcessorServer(iPortNumber)
{
    mParameterMgrPlatformConnector.setLogger(&amp;mLogger);
}

CTestPlatform::~CTestPlatform()
{
}

CTestPlatform::CommandReturn CTestPlatform::exit(const IRemoteCommand &amp; /*command*/,
                                                 string &amp; /*strResult*/)
{
    mRemoteProcessorServer.stop();

    return CTestPlatform::CCommandHandler::EDone;
}

bool CTestPlatform::run(std::string &amp;strError)
{
    // Start remote processor server
    if (!mRemoteProcessorServer.start(strError)) {

        strError = &quot;TestPlatform: Unable to start remote processor server: &quot; + strError;
        return false;
    }

    CCommandHandler commandHandler(this);

    // Add command parsers
    commandHandler.addCommandParser(&quot;exit&quot;, &amp;CTestPlatform::exit, 0, &quot;&quot;, &quot;Exit TestPlatform&quot;);
    commandHandler.addCommandParser(&quot;createExclusiveSelectionCriterionFromStateList&quot;,
                                    &amp;CTestPlatform::createExclusiveSelectionCriterionFromStateList,
                                    2, &quot;&lt;name&gt; &lt;stateList&gt;&quot;,
                                    &quot;Create inclusive selection criterion from state name list&quot;);
    commandHandler.addCommandParser(&quot;createInclusiveSelectionCriterionFromStateList&quot;,
                                    &amp;CTestPlatform::createInclusiveSelectionCriterionFromStateList,
                                    2, &quot;&lt;name&gt; &lt;stateList&gt;&quot;,
                                    &quot;Create exclusive selection criterion from state name list&quot;);

    commandHandler.addCommandParser(&quot;createExclusiveSelectionCriterion&quot;,
                                    &amp;CTestPlatform::createExclusiveSelectionCriterion, 2,
                                    &quot;&lt;name&gt; &lt;nbStates&gt;&quot;, &quot;Create inclusive selection criterion&quot;);
    commandHandler.addCommandParser(&quot;createInclusiveSelectionCriterion&quot;,
                                    &amp;CTestPlatform::createInclusiveSelectionCriterion, 2,
                                    &quot;&lt;name&gt; &lt;nbStates&gt;&quot;, &quot;Create exclusive selection criterion&quot;);

    commandHandler.addCommandParser(&quot;start&quot;, &amp;CTestPlatform::startParameterMgr, 0, &quot;&quot;,
                                    &quot;Start ParameterMgr&quot;);

    commandHandler.addCommandParser(&quot;setCriterionState&quot;, &amp;CTestPlatform::setCriterionState, 2,
                                    &quot;&lt;name&gt; &lt;state&gt;&quot;,
                                    &quot;Set the current state of a selection criterion&quot;);
    commandHandler.addCommandParser(
        &quot;applyConfigurations&quot;, &amp;CTestPlatform::applyConfigurations, 0, &quot;&quot;,
        &quot;Apply configurations selected by current selection criteria states&quot;);

    commandHandler.addCommandParser(
        &quot;setFailureOnMissingSubsystem&quot;,
        &amp;CTestPlatform::setter&lt;&amp;CParameterMgrPlatformConnector::setFailureOnMissingSubsystem&gt;, 1,
        &quot;true|false&quot;, &quot;Set policy for missing subsystems, &quot;
                      &quot;either abort start or fallback on virtual subsystem.&quot;);
    commandHandler.addCommandParser(
        &quot;getMissingSubsystemPolicy&quot;,
        &amp;CTestPlatform::getter&lt;&amp;CParameterMgrPlatformConnector::getFailureOnMissingSubsystem&gt;, 0,
        &quot;&quot;, &quot;Get policy for missing subsystems, &quot;
            &quot;either abort start or fallback on virtual subsystem.&quot;);

    commandHandler.addCommandParser(
        &quot;setFailureOnFailedSettingsLoad&quot;,
        &amp;CTestPlatform::setter&lt;&amp;CParameterMgrPlatformConnector::setFailureOnFailedSettingsLoad&gt;, 1,
        &quot;true|false&quot;,
        &quot;Set policy for failed settings load, either abort start or continue without domains.&quot;);
    commandHandler.addCommandParser(
        &quot;getFailedSettingsLoadPolicy&quot;,
        &amp;CTestPlatform::getter&lt;&amp;CParameterMgrPlatformConnector::getFailureOnFailedSettingsLoad&gt;, 0,
        &quot;&quot;, &quot;Get policy for failed settings load, either abort start or continue without domains.&quot;);

    commandHandler.addCommandParser(
        &quot;setValidateSchemasOnStart&quot;,
        &amp;CTestPlatform::setter&lt;&amp;CParameterMgrPlatformConnector::setValidateSchemasOnStart&gt;, 1,
        &quot;true|false&quot;, &quot;Set policy for schema validation based on .xsd files (false by default).&quot;);
    commandHandler.addCommandParser(
        &quot;getValidateSchemasOnStart&quot;,
        &amp;CTestPlatform::getter&lt;&amp;CParameterMgrPlatformConnector::getValidateSchemasOnStart&gt;, 0, &quot;&quot;,
        &quot;Get policy for schema validation based on .xsd files.&quot;);

    commandHandler.addCommandParser(&quot;getSchemaUri&quot;, &amp;CTestPlatform::getSchemaUri, 0, &quot;&quot;,
                                    &quot;Get the directory where schemas can be found.&quot;);
    commandHandler.addCommandParser(&quot;setSchemaUri&quot;, &amp;CTestPlatform::setSchemaUri, 1, &quot;&lt;directory&gt;&quot;,
                                    &quot;Set the directory where schemas can be found.&quot;);

    return mRemoteProcessorServer.process(commandHandler);
}

//////////////// Remote command parsers
/// Selection Criterion
CTestPlatform::CommandReturn CTestPlatform::createExclusiveSelectionCriterionFromStateList(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    return createExclusiveSelectionCriterionFromStateList(remoteCommand.getArgument(0),
                                                          remoteCommand, strResult)
               ? CTestPlatform::CCommandHandler::EDone
               : CTestPlatform::CCommandHandler::EFailed;
}

CTestPlatform::CommandReturn CTestPlatform::createInclusiveSelectionCriterionFromStateList(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    return createInclusiveSelectionCriterionFromStateList(remoteCommand.getArgument(0),
                                                          remoteCommand, strResult)
               ? CTestPlatform::CCommandHandler::EDone
               : CTestPlatform::CCommandHandler::EFailed;
}

CTestPlatform::CommandReturn CTestPlatform::createExclusiveSelectionCriterion(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    return createExclusiveSelectionCriterion(
               remoteCommand.getArgument(0),
               strtoul(remoteCommand.getArgument(1).c_str(), nullptr, 0), strResult)
               ? CTestPlatform::CCommandHandler::EDone
               : CTestPlatform::CCommandHandler::EFailed;
}

CTestPlatform::CommandReturn CTestPlatform::createInclusiveSelectionCriterion(
    const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    return createInclusiveSelectionCriterion(
               remoteCommand.getArgument(0),
               strtoul(remoteCommand.getArgument(1).c_str(), nullptr, 0), strResult)
               ? CTestPlatform::CCommandHandler::EDone
               : CTestPlatform::CCommandHandler::EFailed;
}

CTestPlatform::CommandReturn CTestPlatform::startParameterMgr(
    const IRemoteCommand &amp; /*remoteCommand*/, string &amp;strResult)
{
    return mParameterMgrPlatformConnector.start(strResult)
               ? CTestPlatform::CCommandHandler::EDone
               : CTestPlatform::CCommandHandler::EFailed;
}

template &lt;CTestPlatform::setter_t setFunction&gt;
CTestPlatform::CommandReturn CTestPlatform::setter(const IRemoteCommand &amp;remoteCommand,
                                                   string &amp;strResult)
{
    const string &amp;strAbort = remoteCommand.getArgument(0);

    bool bFail;

    if (!convertTo(strAbort, bFail)) {
        return CTestPlatform::CCommandHandler::EShowUsage;
    }

    return (mParameterMgrPlatformConnector.*setFunction)(bFail, strResult)
               ? CTestPlatform::CCommandHandler::EDone
               : CTestPlatform::CCommandHandler::EFailed;
}

template &lt;CTestPlatform::getter_t getFunction&gt;
CTestPlatform::CommandReturn CTestPlatform::getter(const IRemoteCommand &amp; /*command*/,
                                                   string &amp;strResult)
{
    strResult = (mParameterMgrPlatformConnector.*getFunction)() ? &quot;true&quot; : &quot;false&quot;;

    return CTestPlatform::CCommandHandler::ESucceeded;
}

CTestPlatform::CommandReturn CTestPlatform::getSchemaUri(const IRemoteCommand &amp; /*remotecommand*/,
                                                         string &amp;result)
{
    result = mParameterMgrPlatformConnector.getSchemaUri();
    return CTestPlatform::CCommandHandler::EDone;
}

CTestPlatform::CommandReturn CTestPlatform::setSchemaUri(const IRemoteCommand &amp;remotecommand,
                                                         string &amp; /*result*/)
{
    mParameterMgrPlatformConnector.setSchemaUri(remotecommand.getArgument(0));
    return CTestPlatform::CCommandHandler::EDone;
}

CTestPlatform::CommandReturn CTestPlatform::setCriterionState(const IRemoteCommand &amp;remoteCommand,
                                                              string &amp;strResult)
{

    bool bSuccess;

    uint32_t state;

    if (convertTo(remoteCommand.getArgument(1), state)) {
        // Sucessfull conversion, set criterion state by numerical state
        bSuccess = setCriterionState(remoteCommand.getArgument(0), state, strResult);

    } else {
        // Conversion failed, set criterion state by lexical state
        bSuccess = setCriterionStateByLexicalSpace(remoteCommand, strResult);
    }

    return bSuccess ? CTestPlatform::CCommandHandler::EDone
                    : CTestPlatform::CCommandHandler::EFailed;
}

CTestPlatform::CommandReturn CTestPlatform::applyConfigurations(const IRemoteCommand &amp; /*command*/,
                                                                string &amp; /*strResult*/)
{
    mParameterMgrPlatformConnector.applyConfigurations();

    return CTestPlatform::CCommandHandler::EDone;
}

//////////////// Remote command handlers

bool CTestPlatform::createExclusiveSelectionCriterionFromStateList(
    const string &amp;strName, const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    ISelectionCriterionTypeInterface *pCriterionType =
        mParameterMgrPlatformConnector.createSelectionCriterionType(false);

    assert(pCriterionType != nullptr);

    size_t nbStates = remoteCommand.getArgumentCount() - 1;

    for (size_t state = 0; state &lt; nbStates; state++) {

        const std::string &amp;strValue = remoteCommand.getArgument(state + 1);

        // FIXME state type vs addValuePair params
        if (!pCriterionType-&gt;addValuePair(int(state), strValue, strResult)) {

            strResult = &quot;Unable to add value: &quot; + strValue + &quot;: &quot; + strResult;

            return false;
        }
    }

    mParameterMgrPlatformConnector.createSelectionCriterion(strName, pCriterionType);

    return true;
}

bool CTestPlatform::createInclusiveSelectionCriterionFromStateList(
    const string &amp;strName, const IRemoteCommand &amp;remoteCommand, string &amp;strResult)
{
    ISelectionCriterionTypeInterface *pCriterionType =
        mParameterMgrPlatformConnector.createSelectionCriterionType(true);

    assert(pCriterionType != nullptr);

    size_t nbStates = remoteCommand.getArgumentCount() - 1;

    for (size_t state = 0; state &lt; nbStates; state++) {

        const std::string &amp;strValue = remoteCommand.getArgument(state + 1);

        if (!pCriterionType-&gt;addValuePair(0x1 &lt;&lt; state, strValue, strResult)) {

            strResult = &quot;Unable to add value: &quot; + strValue + &quot;: &quot; + strResult;

            return false;
        }
    }

    mParameterMgrPlatformConnector.createSelectionCriterion(strName, pCriterionType);

    return true;
}

bool CTestPlatform::createExclusiveSelectionCriterion(const string &amp;strName, size_t nbStates,
                                                      string &amp;strResult)
{
    ISelectionCriterionTypeInterface *pCriterionType =
        mParameterMgrPlatformConnector.createSelectionCriterionType(false);

    for (size_t state = 0; state &lt; nbStates; state++) {

        std::ostringstream ostrValue;

        ostrValue &lt;&lt; &quot;State_&quot;;
        ostrValue &lt;&lt; state;

        // FIXME state type vs addValuePair params
        if (!pCriterionType-&gt;addValuePair(int(state), ostrValue.str(), strResult)) {

            strResult = &quot;Unable to add value: &quot; + ostrValue.str() + &quot;: &quot; + strResult;

            return false;
        }
    }

    mParameterMgrPlatformConnector.createSelectionCriterion(strName, pCriterionType);

    return true;
}

bool CTestPlatform::createInclusiveSelectionCriterion(const string &amp;strName, size_t nbStates,
                                                      string &amp;strResult)
{
    ISelectionCriterionTypeInterface *pCriterionType =
        mParameterMgrPlatformConnector.createSelectionCriterionType(true);

    for (size_t state = 0; state &lt; nbStates; state++) {

        std::ostringstream ostrValue;

        ostrValue &lt;&lt; &quot;State_0x&quot;;
        ostrValue &lt;&lt; (0x1 &lt;&lt; state);

        if (!pCriterionType-&gt;addValuePair(0x1 &lt;&lt; state, ostrValue.str(), strResult)) {

            strResult = &quot;Unable to add value: &quot; + ostrValue.str() + &quot;: &quot; + strResult;

            return false;
        }
    }
<A NAME="0"></A>
    mParameterMgrPlatformConnector.createSelectionCriterion(strName, pCriterionType);

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match581-1.html#0',3,'match581-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    return true;
}

bool CTestPlatform::setCriterionState(const string &amp;strName, uint32_t uiState, string &amp;strResult)
{
    ISelectionCriterionInterface *pCriterion =
        mParameterMgrPlatformConnector.getSelectionCriterion(strName);

    if (!pCriterion) {

        strResult = &quot;Unable to retrieve selection criterion: &quot; + strName;

        return false;
    }

    pCriterion-&gt;setCriterionState(uiState);

    return true;
}</B></FONT>

bool CTestPlatform::setCriterionStateByLexicalSpace(const IRemoteCommand &amp;remoteCommand,
                                                    string &amp;strResult)
{

    // Get criterion name
    std::string strCriterionName = remoteCommand.getArgument(0);

    ISelectionCriterionInterface *pCriterion =
        mParameterMgrPlatformConnector.getSelectionCriterion(strCriterionName);

    if (!pCriterion) {

        strResult = &quot;Unable to retrieve selection criterion: &quot; + strCriterionName;

        return false;
    }

    // Get criterion type
    const ISelectionCriterionTypeInterface *pCriterionType = pCriterion-&gt;getCriterionType();

    // Get substate number, the first argument (index 0) is the criterion name
    size_t nbSubStates = remoteCommand.getArgumentCount() - 1;

    // Check that exclusive criterion has only one substate
    if (!pCriterionType-&gt;isTypeInclusive() &amp;&amp; nbSubStates != 1) {

        strResult = &quot;Exclusive criterion &quot; + strCriterionName + &quot; can only have one state&quot;;

        return false;
    }

    /// Translate lexical state to numerical state
    int iNumericalState = 0;
    size_t lexicalSubStateIndex;

    // Parse lexical substates
    std::string strLexicalState = &quot;&quot;;

    for (lexicalSubStateIndex = 1; lexicalSubStateIndex &lt;= nbSubStates; lexicalSubStateIndex++) {
        /*
         * getNumericalValue method from ISelectionCriterionTypeInterface strip his parameter
         * first parameter based on | sign. In case that the user uses multiple parameters
         * to set InclusiveCriterion value, we aggregate all desired values to be sure
         * they will be handled correctly.
         */
        if (lexicalSubStateIndex != 1) {
            strLexicalState += &quot;|&quot;;
        }
        strLexicalState += remoteCommand.getArgument(lexicalSubStateIndex);
    }

    // Translate lexical to numerical substate
    if (!pCriterionType-&gt;getNumericalValue(strLexicalState, iNumericalState)) {

        strResult = &quot;Unable to find lexical state \&quot;&quot; + strLexicalState + &quot;\&quot; in criteria &quot; +
                    strCriterionName;

        return false;
    }

    // Set criterion new state
    pCriterion-&gt;setCriterionState(iNumericalState);

    return true;
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ConfigurableDomain.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
 * Copyright (c) 2011-2015, Intel Corporation
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation and/or
 * other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its contributors
 * may be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#include &quot;ConfigurableDomain.h&quot;
#include &quot;DomainConfiguration.h&quot;
#include &quot;ConfigurableElement.h&quot;
#include &quot;ConfigurationAccessContext.h&quot;
#include &quot;XmlDomainSerializingContext.h&quot;
#include &quot;XmlDomainImportContext.h&quot;
#include &quot;XmlDomainExportContext.h&quot;
#include &quot;Utility.h&quot;
#include &quot;AlwaysAssert.hpp&quot;
#include &lt;cassert&gt;

#define base CElement

using std::string;

CConfigurableDomain::CConfigurableDomain(const string &amp;strName) : base(strName)
{
}

CConfigurableDomain::~CConfigurableDomain()
{
    // Remove all configurable elements
    ConfigurableElementListIterator it;

    for (it = _configurableElementList.begin(); it != _configurableElementList.end(); ++it) {

        CConfigurableElement *pConfigurableElement = *it;

        // Remove from configurable element
        pConfigurableElement-&gt;removeAttachedConfigurableDomain(this);
    }

    // Remove all associated syncer sets
    ConfigurableElementToSyncerSetMapIterator mapIt;

    for (mapIt = _configurableElementToSyncerSetMap.begin();
         mapIt != _configurableElementToSyncerSetMap.end(); ++mapIt) {

        delete mapIt-&gt;second;
    }
}

string CConfigurableDomain::getKind() const
{
    return &quot;ConfigurableDomain&quot;;
}

bool CConfigurableDomain::childrenAreDynamic() const
{
    return true;
}

// Content dumping
string CConfigurableDomain::logValue(utility::ErrorContext &amp; /*ctx*/) const
{
    return string(&quot;{&quot;) +

           &quot;Sequence aware: &quot; + (_bSequenceAware ? &quot;yes&quot; : &quot;no&quot;) +

           &quot;, Last applied configuration: &quot; +
           (_pLastAppliedConfiguration ? _pLastAppliedConfiguration-&gt;getName() : &quot;&lt;none&gt;&quot;) +

           &quot;}&quot;;
}

// Sequence awareness
void CConfigurableDomain::setSequenceAwareness(bool bSequenceAware)
{
    if (_bSequenceAware != bSequenceAware) {

        _bSequenceAware = bSequenceAware;
    }
}

bool CConfigurableDomain::getSequenceAwareness() const
{
    return _bSequenceAware;
}

// From IXmlSource
void CConfigurableDomain::toXml(CXmlElement &amp;xmlElement,
                                CXmlSerializingContext &amp;serializingContext) const
{
    base::toXml(xmlElement, serializingContext);

    // Sequence awareness
    xmlElement.setAttribute(&quot;SequenceAware&quot;, _bSequenceAware);
}

void CConfigurableDomain::childrenToXml(CXmlElement &amp;xmlElement,
                                        CXmlSerializingContext &amp;serializingContext) const
{
    // Configurations
    composeDomainConfigurations(xmlElement, serializingContext);

    // Configurable Elements
    composeConfigurableElements(xmlElement);

    // Settings
    composeSettings(xmlElement, static_cast&lt;CXmlDomainExportContext &amp;&gt;(serializingContext));
}

// XML composing
void CConfigurableDomain::composeDomainConfigurations(
    CXmlElement &amp;xmlElement, CXmlSerializingContext &amp;serializingContext) const
{
    // Create Configurations element
    CXmlElement xmlConfigurationsElement;

    xmlElement.createChild(xmlConfigurationsElement, &quot;Configurations&quot;);

    // Delegate to base
    base::childrenToXml(xmlConfigurationsElement, serializingContext);
}

void CConfigurableDomain::composeConfigurableElements(CXmlElement &amp;xmlElement) const
{
    // Create ConfigurableElements element
    CXmlElement xmlConfigurableElementsElement;

    xmlElement.createChild(xmlConfigurableElementsElement, &quot;ConfigurableElements&quot;);

    // Serialize out all configurable elements settings
    ConfigurableElementListIterator it;

    for (it = _configurableElementList.begin(); it != _configurableElementList.end(); ++it) {

        const CConfigurableElement *pConfigurableElement = *it;

        // Create corresponding XML child element
        CXmlElement xmlChildConfigurableElement;

        xmlConfigurableElementsElement.createChild(xmlChildConfigurableElement,
                                                   &quot;ConfigurableElement&quot;);

        // Set Path attribute
        xmlChildConfigurableElement.setAttribute(&quot;Path&quot;, pConfigurableElement-&gt;getPath());
    }
}

void CConfigurableDomain::composeSettings(CXmlElement &amp;xmlElement,
                                          CXmlDomainExportContext &amp;context) const
{
    if (!context.withSettings()) {

        return;
    }

    // Create Settings element
    CXmlElement xmlSettingsElement;

    xmlElement.createChild(xmlSettingsElement, &quot;Settings&quot;);

    // Serialize out all configurations settings
    size_t uiNbConfigurations = getNbChildren();
    size_t uiChildConfiguration;

    for (uiChildConfiguration = 0; uiChildConfiguration &lt; uiNbConfigurations;
         uiChildConfiguration++) {

        const CDomainConfiguration *pDomainConfiguration =
            static_cast&lt;const CDomainConfiguration *&gt;(getChild(uiChildConfiguration));

        // Create child xml element for that configuration
        CXmlElement xmlConfigurationSettingsElement;

        xmlSettingsElement.createChild(xmlConfigurationSettingsElement,
                                       pDomainConfiguration-&gt;getXmlElementName());

        // Set its name attribute
        xmlConfigurationSettingsElement.setNameAttribute(pDomainConfiguration-&gt;getName());

        // Serialize out configuration settings
        pDomainConfiguration-&gt;composeSettings(xmlConfigurationSettingsElement, context);
    }
}

// From IXmlSink
bool CConfigurableDomain::fromXml(const CXmlElement &amp;xmlElement,
                                  CXmlSerializingContext &amp;serializingContext)
{
    // Context
    CXmlDomainImportContext &amp;xmlDomainImportContext =
        static_cast&lt;CXmlDomainImportContext &amp;&gt;(serializingContext);

    // Sequence awareness (optional)
    xmlElement.getAttribute(&quot;SequenceAware&quot;, _bSequenceAware);

    std::string name;
    xmlElement.getAttribute(&quot;Name&quot;, name);
    setName(name);

    // Local parsing. Do not dig
    if (!parseDomainConfigurations(xmlElement, xmlDomainImportContext) ||
        !parseConfigurableElements(xmlElement, xmlDomainImportContext) ||
        !parseSettings(xmlElement, xmlDomainImportContext)) {

        return false;
    }

    // All provided configurations are parsed
    // Attempt validation on areas of non provided configurations for all configurable elements if
    // required
    if (xmlDomainImportContext.autoValidationRequired()) {

        autoValidateAll();
    }

    return true;
}

// XML parsing
bool CConfigurableDomain::parseDomainConfigurations(const CXmlElement &amp;xmlElement,
                                                    CXmlDomainImportContext &amp;serializingContext)
{
    // We're supposedly clean
    assert(_configurableElementList.empty());

    // Get Configurations element
    CXmlElement xmlConfigurationsElement;

    xmlElement.getChildElement(&quot;Configurations&quot;, xmlConfigurationsElement);

    // Parse it and create domain configuration objects
    return base::fromXml(xmlConfigurationsElement, serializingContext);
}

// Parse configurable elements
bool CConfigurableDomain::parseConfigurableElements(const CXmlElement &amp;xmlElement,
                                                    CXmlDomainImportContext &amp;serializingContext)
{
    CSystemClass &amp;systemClass = serializingContext.getSystemClass();

    // Get ConfigurableElements element
    CXmlElement xmlConfigurableElementsElement;
    xmlElement.getChildElement(&quot;ConfigurableElements&quot;, xmlConfigurableElementsElement);

    // Parse it and associate found configurable elements to it
    CXmlElement::CChildIterator it(xmlConfigurableElementsElement);

    CXmlElement xmlConfigurableElementElement;

    while (it.next(xmlConfigurableElementElement)) {

        // Locate configurable element
        string strConfigurableElementPath;
        xmlConfigurableElementElement.getAttribute(&quot;Path&quot;, strConfigurableElementPath);

        CPathNavigator pathNavigator(strConfigurableElementPath);
        string strError;

        // Is there an element and does it match system class name?
        if (!pathNavigator.navigateThrough(systemClass.getName(), strError)) {

            serializingContext.setError(
                &quot;Could not find configurable element of path &quot; + strConfigurableElementPath +
                &quot; from ConfigurableDomain description &quot; + getName() + &quot; (&quot; + strError + &quot;)&quot;);

            return false;
        }
        // Browse system class for configurable element
        CConfigurableElement *pConfigurableElement =
            static_cast&lt;CConfigurableElement *&gt;(systemClass.findDescendant(pathNavigator));

        if (!pConfigurableElement) {

            serializingContext.setError(&quot;Could not find configurable element of path &quot; +
                                        strConfigurableElementPath +
                                        &quot; from ConfigurableDomain description &quot; + getName());

            return false;
        }
        // Add found element to domain
        core::Results infos;
        if (!addConfigurableElement(pConfigurableElement, nullptr, infos)) {

            strError = utility::asString(infos);
            serializingContext.setError(strError);

            return false;
        }
    }

    return true;
}

// Parse settings
bool CConfigurableDomain::parseSettings(const CXmlElement &amp;xmlElement,
                                        CXmlDomainImportContext &amp;serializingContext)
{
    // Check we actually need to parse configuration settings
    if (!serializingContext.withSettings()) {

        // No parsing required
        return true;
    }

    // Get Settings element
    CXmlElement xmlSettingsElement;
    if (!xmlElement.getChildElement(&quot;Settings&quot;, xmlSettingsElement)) {

        // No settings, bail out successfully
        return true;
    }

    // Parse configuration settings
    CXmlElement::CChildIterator it(xmlSettingsElement);

    CXmlElement xmlConfigurationSettingsElement;

    while (it.next(xmlConfigurationSettingsElement)) {
        // Get domain configuration
        CDomainConfiguration *pDomainConfiguration = static_cast&lt;CDomainConfiguration *&gt;(
            findChild(xmlConfigurationSettingsElement.getNameAttribute()));

        if (!pDomainConfiguration) {

            serializingContext.setError(&quot;Could not find domain configuration referred to by&quot;
                                        &quot; configurable domain \&quot;&quot; +
                                        getName() + &quot;\&quot;.&quot;);

            return false;
        }
        // Have domain configuration parse settings for all configurable elements
        if (!pDomainConfiguration-&gt;parseSettings(xmlConfigurationSettingsElement,
                                                 serializingContext)) {

            return false;
        }
    }

    return true;
}
// Configurable elements association
bool CConfigurableDomain::addConfigurableElement(CConfigurableElement *pConfigurableElement,
                                                 const CParameterBlackboard *pMainBlackboard,
                                                 core::Results &amp;infos)
{
    // Already associated?
    if (containsConfigurableElement(pConfigurableElement)) {

        infos.push_back(&quot;Configurable element &quot; + pConfigurableElement-&gt;getPath() +
                        &quot; already associated to configuration domain &quot; + getName());

        return false;
    }

    // Already owned?
    if (pConfigurableElement-&gt;belongsTo(this)) {

        infos.push_back(&quot;Configurable element &quot; + pConfigurableElement-&gt;getPath() +
                        &quot; already owned by configuration domain &quot; + getName());

        return false;
    }

    // Do add
    doAddConfigurableElement(pConfigurableElement, infos, pMainBlackboard);

    return true;
}

bool CConfigurableDomain::removeConfigurableElement(CConfigurableElement *pConfigurableElement,
                                                    string &amp;strError)
{
    // Not associated?
    if (!containsConfigurableElement(pConfigurableElement)) {

        strError = &quot;Configurable element &quot; + pConfigurableElement-&gt;getPath() +
                   &quot; not associated to configuration domain &quot; + getName();

        return false;
    }

    // Do remove
    doRemoveConfigurableElement(pConfigurableElement, true);

    return true;
}

/**
* Blackboard Configuration and Base Offset retrieval.
*
* This method fetches the Blackboard associated to the ConfigurableElement
* given in parameter, for a specific Configuration. The ConfigurableElement
* must belong to the Domain. If a Blackboard is found, the base offset of
* the ConfigurableElement is returned as well. This base offset corresponds to
* the offset of the ancestor of the ConfigurableElement associated to the Configuration.
*
* @param[in] strConfiguration                           Name of the Configuration.
* @param[in] pCandidateDescendantConfigurableElement    Pointer to a CConfigurableElement that
*                                                       belongs to the Domain.
* @param[out] baseOffset                              The base offset of the CConfigurableElement.
* @param[out] bIsLastApplied                            Boolean indicating that the Configuration is
*                                                       the last one applied of the Domain.
* @param[out] strError                                  Error message
*
* return Pointer to the Blackboard of the Configuration.
*/
CParameterBlackboard *CConfigurableDomain::findConfigurationBlackboard(
    const string &amp;strConfiguration,
    const CConfigurableElement *pCandidateDescendantConfigurableElement, size_t &amp;baseOffset,
    bool &amp;bIsLastApplied, string &amp;strError) const
{
    // Find Configuration
    const CDomainConfiguration *pDomainConfiguration =
        static_cast&lt;const CDomainConfiguration *&gt;(findChild(strConfiguration));

    if (!pDomainConfiguration) {

        strError = &quot;Domain configuration &quot; + strConfiguration + &quot; not found&quot;;

        return nullptr;
    }

    // Parse all configurable elements
    ConfigurableElementListIterator it;

    for (it = _configurableElementList.begin(); it != _configurableElementList.end(); ++it) {

        const CConfigurableElement *pAssociatedConfigurableElement = *it;

        // Check if the the associated element is the configurable element or one of its ancestors
        if ((pCandidateDescendantConfigurableElement == pAssociatedConfigurableElement) ||
            (pCandidateDescendantConfigurableElement-&gt;isDescendantOf(
                pAssociatedConfigurableElement))) {

            baseOffset = pAssociatedConfigurableElement-&gt;getOffset();
            bIsLastApplied = (pDomainConfiguration == _pLastAppliedConfiguration);

            return pDomainConfiguration-&gt;getBlackboard(pAssociatedConfigurableElement);
        }
    }

    strError = &quot;Element not associated to the Domain&quot;;

    return nullptr;
}

// Domain splitting
bool CConfigurableDomain::split(CConfigurableElement *pConfigurableElement, core::Results &amp;infos)
{
    // Not associated?
    if (!containsConfigurableElement(pConfigurableElement)) {

        std::string strError = &quot;Configurable element &quot; + pConfigurableElement-&gt;getPath() +
                               &quot; not associated to configuration domain &quot; + getName();
        infos.push_back(strError);

        return false;
    }

    // Create sub domain areas for all configurable element's children
    size_t uiNbConfigurableElementChildren = pConfigurableElement-&gt;getNbChildren();

    if (!uiNbConfigurableElementChildren) {

        std::string strError = &quot;Configurable element &quot; + pConfigurableElement-&gt;getPath() +
                               &quot; has no children to split configurable domain to&quot;;
        infos.push_back(strError);

        return false;
    }

    for (size_t uiChild = 0; uiChild &lt; uiNbConfigurableElementChildren; uiChild++) {

        CConfigurableElement *pChildConfigurableElement =
            static_cast&lt;CConfigurableElement *&gt;(pConfigurableElement-&gt;getChild(uiChild));

        doAddConfigurableElement(pChildConfigurableElement, infos);
    }

    // Delegate to configurations
    size_t uiNbConfigurations = getNbChildren();

    for (size_t uiChild = 0; uiChild &lt; uiNbConfigurations; uiChild++) {

        CDomainConfiguration *pDomainConfiguration =
            static_cast&lt;CDomainConfiguration *&gt;(getChild(uiChild));

        pDomainConfiguration-&gt;split(pConfigurableElement);
    }

    // Remove given configurable element from this domain
    // Note: we shouldn't need to recompute the sync set in that case, as the splitted element
    // should include the syncers of its children elements
    doRemoveConfigurableElement(pConfigurableElement, false);

    return true;
}

// Check if there is a pending configuration for this domain: i.e. an applicable configuration
// different from the last applied configuration
const CDomainConfiguration *CConfigurableDomain::getPendingConfiguration() const
{
    const CDomainConfiguration *pApplicableDomainConfiguration =
        findApplicableDomainConfiguration();

    if (pApplicableDomainConfiguration) {

        // Check not the last one before applying
        if (!_pLastAppliedConfiguration ||
            (_pLastAppliedConfiguration != pApplicableDomainConfiguration)) {

            return pApplicableDomainConfiguration;
        }
    }

    return nullptr;
}

// Configuration application if required
void CConfigurableDomain::apply(CParameterBlackboard *pParameterBlackboard, CSyncerSet *pSyncerSet,
                                bool bForce, std::string &amp;strInfo) const
{
    // Apply configuration only if the blackboard will
    // be synchronized either now or by syncerSet.
    if (!pSyncerSet ^ _bSequenceAware) {
        // The configuration can not be syncronised
        return;
    }

    if (bForce) {
        // Force a configuration restore by forgetting about last applied configuration
        _pLastAppliedConfiguration = nullptr;
    }
    const CDomainConfiguration *pApplicableDomainConfiguration =
        findApplicableDomainConfiguration();

    if (pApplicableDomainConfiguration) {

        // Check not the last one before applying
        if (!_pLastAppliedConfiguration ||
            _pLastAppliedConfiguration != pApplicableDomainConfiguration) {

            strInfo = &quot;Applying configuration '&quot; + pApplicableDomainConfiguration-&gt;getName() +
                      &quot;' from domain '&quot; + getName() + &quot;'&quot;;

            // Check if we need to synchronize during restore
            bool bSync = !pSyncerSet &amp;&amp; _bSequenceAware;

            // Do the restore
            pApplicableDomainConfiguration-&gt;restore(pParameterBlackboard, bSync, nullptr);

            // Record last applied configuration
            _pLastAppliedConfiguration = pApplicableDomainConfiguration;

            // Check we need to provide syncer set to caller
            if (pSyncerSet &amp;&amp; !_bSequenceAware) {

                // Since we applied changes, add our own sync set to the given one
                *pSyncerSet += _syncerSet;
            }
        }
    }
}

// Return applicable configuration validity for given configurable element
bool CConfigurableDomain::isApplicableConfigurationValid(
    const CConfigurableElement *pConfigurableElement) const
{
    const CDomainConfiguration *pApplicableDomainConfiguration =
        findApplicableDomainConfiguration();

    return pApplicableDomainConfiguration &amp;&amp;
           pApplicableDomainConfiguration-&gt;isValid(pConfigurableElement);
}

// In case configurable element was removed
void CConfigurableDomain::computeSyncSet()
{
    // Clean sync set first
    _syncerSet.clear();

    // Add syncer sets for all associated configurable elements
    ConfigurableElementToSyncerSetMapIterator mapIt;

    for (mapIt = _configurableElementToSyncerSetMap.begin();
         mapIt != _configurableElementToSyncerSetMap.end(); ++mapIt) {

        const CSyncerSet *pSyncerSet = mapIt-&gt;second;

        _syncerSet += *pSyncerSet;
    }
}

// Configuration Management
bool CConfigurableDomain::createConfiguration(const string &amp;strName,
                                              const CParameterBlackboard *pMainBlackboard,
                                              string &amp;strError)
{
    // Already exists?
    if (findChild(strName)) {

        strError = &quot;Already existing configuration&quot;;

        return false;
    }

    // Creation
    auto pDomainConfiguration = new CDomainConfiguration(strName);

    // Configurable elements association
    ConfigurableElementListIterator it;

    for (it = _configurableElementList.begin(); it != _configurableElementList.end(); ++it) {

        const CConfigurableElement *pConfigurableElement = *it;
        ;

        // Retrieve associated syncer set
        CSyncerSet *pSyncerSet = getSyncerSet(pConfigurableElement);

        // Associate to configuration
        pDomainConfiguration-&gt;addConfigurableElement(pConfigurableElement, pSyncerSet);
    }

    // Hierarchy
    addChild(pDomainConfiguration);

    // Ensure validity of fresh new domain configuration
    // Attempt auto validation, so that the user gets his/her own settings by defaults
    if (!autoValidateConfiguration(pDomainConfiguration)) {

        // No valid configuration found to copy in from, validate againt main blackboard (will
        // concerned remaining invalid parts)
        pDomainConfiguration-&gt;validate(pMainBlackboard);
    }

    return true;
}

bool CConfigurableDomain::deleteConfiguration(const string &amp;strName, string &amp;strError)
{
    CDomainConfiguration *pDomainConfiguration = findConfiguration(strName, strError);

    if (!pDomainConfiguration) {

        return false;
    }

    // Was the last applied?
    if (pDomainConfiguration == _pLastAppliedConfiguration) {

        // Forget about it
        _pLastAppliedConfiguration = nullptr;
    }

    // Hierarchy
    removeChild(pDomainConfiguration);

    // Destroy
    delete pDomainConfiguration;

    return true;
}

void CConfigurableDomain::listAssociatedToElements(string &amp;strResult) const
{
    ConfigurableElementListIterator it;

    // Browse all configurable elements
    for (it = _configurableElementList.begin(); it != _configurableElementList.end(); ++it) {

        const CConfigurableElement *pConfigurableElement = *it;

        strResult += pConfigurableElement-&gt;getPath() + &quot;\n&quot;;
    }
}

bool CConfigurableDomain::renameConfiguration(const string &amp;strName, const string &amp;strNewName,
                                              string &amp;strError)
{
    CDomainConfiguration *pDomainConfiguration = findConfiguration(strName, strError);

    if (!pDomainConfiguration) {

        return false;
    }

    // Rename
    return pDomainConfiguration-&gt;rename(strNewName, strError);
}

bool CConfigurableDomain::restoreConfiguration(const string &amp;configurationName,
                                               CParameterBlackboard *mainBlackboard, bool autoSync,
                                               core::Results &amp;errors) const
{
    string error;

    const CDomainConfiguration *configuration = findConfiguration(configurationName, error);

    if (configuration == nullptr) {

        errors.push_back(error);
        return false;
    }

    // Delegate
    bool bSuccess = configuration-&gt;restore(mainBlackboard, autoSync &amp;&amp; _bSequenceAware, &amp;errors);

    // Record last applied configuration
    _pLastAppliedConfiguration = configuration;

    // Synchronize
    if (autoSync &amp;&amp; !_bSequenceAware) {

        bSuccess &amp;= _syncerSet.sync(*mainBlackboard, false, &amp;errors);
    }
    return bSuccess;
}

bool CConfigurableDomain::saveConfiguration(const string &amp;strName,
                                            const CParameterBlackboard *pMainBlackboard,
                                            string &amp;strError)
{
    // Find Domain configuration
    CDomainConfiguration *pDomainConfiguration = findConfiguration(strName, strError);

    if (!pDomainConfiguration) {

        return false;
    }

    // Delegate
    pDomainConfiguration-&gt;save(pMainBlackboard);

    return true;
}

bool CConfigurableDomain::setElementSequence(const string &amp;strConfiguration,
                                             const std::vector&lt;string&gt; &amp;astrNewElementSequence,
                                             string &amp;strError)
{
    // Find Domain configuration
    CDomainConfiguration *pDomainConfiguration = findConfiguration(strConfiguration, strError);

    if (!pDomainConfiguration) {

        return false;
    }

    // Delegate to configuration
    return pDomainConfiguration-&gt;setElementSequence(astrNewElementSequence, strError);
}

bool CConfigurableDomain::getElementSequence(const string &amp;strConfiguration,
                                             string &amp;strResult) const
{
    // Find Domain configuration
    const CDomainConfiguration *pDomainConfiguration =
        findConfiguration(strConfiguration, strResult);

    if (!pDomainConfiguration) {

        return false;
    }

    // Delegate to configuration
    pDomainConfiguration-&gt;getElementSequence(strResult);

    return true;
}

bool CConfigurableDomain::setApplicationRule(
    const string &amp;strConfiguration, const string &amp;strApplicationRule,
    const CSelectionCriteriaDefinition *pSelectionCriteriaDefinition, string &amp;strError)
{
    // Find Domain configuration
    CDomainConfiguration *pDomainConfiguration = findConfiguration(strConfiguration, strError);

    if (!pDomainConfiguration) {

        return false;
    }

    // Delegate to configuration
    return pDomainConfiguration-&gt;setApplicationRule(strApplicationRule,
                                                    pSelectionCriteriaDefinition, strError);
}

bool CConfigurableDomain::clearApplicationRule(const string &amp;strConfiguration, string &amp;strError)
{
    // Find Domain configuration
    CDomainConfiguration *pDomainConfiguration = findConfiguration(strConfiguration, strError);

    if (!pDomainConfiguration) {

        return false;
    }

    // Delegate to configuration
    pDomainConfiguration-&gt;clearApplicationRule();

    return true;
}

bool CConfigurableDomain::getApplicationRule(const string &amp;strConfiguration,
                                             string &amp;strResult) const
{
    // Find Domain configuration
    const CDomainConfiguration *pDomainConfiguration =
        findConfiguration(strConfiguration, strResult);

    if (!pDomainConfiguration) {

        return false;
    }

    // Delegate to configuration
    strResult = pDomainConfiguration-&gt;getApplicationRule();

    return true;
}

// Last applied configuration
string CConfigurableDomain::getLastAppliedConfigurationName() const
{
    if (_pLastAppliedConfiguration) {

        return _pLastAppliedConfiguration-&gt;getName();
    }
    return &quot;&lt;none&gt;&quot;;
}

// Pending configuration
string CConfigurableDomain::getPendingConfigurationName() const
{
    const CDomainConfiguration *pApplicableDomainConfiguration =
        findApplicableDomainConfiguration();

    if (!pApplicableDomainConfiguration) {

        // No configuration is pending
        return &quot;&lt;none&gt;&quot;;
    }

    // Check it will be applied
    if (pApplicableDomainConfiguration != _pLastAppliedConfiguration) {

        // Found config will get applied
        return pApplicableDomainConfiguration-&gt;getName();
    } else {

        // Same configuration as current
        return &quot;&quot;;
    }
}

// Ensure validity on whole domain from main blackboard
void CConfigurableDomain::validate(const CParameterBlackboard *pMainBlackboard)
{

    // Propagate
    size_t uiNbConfigurations = getNbChildren();

    for (size_t uiChild = 0; uiChild &lt; uiNbConfigurations; uiChild++) {

        CDomainConfiguration *pDomainConfiguration =
            static_cast&lt;CDomainConfiguration *&gt;(getChild(uiChild));

        pDomainConfiguration-&gt;validate(pMainBlackboard);
    }
}

// Ensure validity on areas related to configurable element
void CConfigurableDomain::validateAreas(const CConfigurableElement *pConfigurableElement,
                                        const CParameterBlackboard *pMainBlackboard)
{
    // Propagate
    size_t uiNbConfigurations = getNbChildren();

    for (size_t uiChild = 0; uiChild &lt; uiNbConfigurations; uiChild++) {

        CDomainConfiguration *pDomainConfiguration =
            static_cast&lt;CDomainConfiguration *&gt;(getChild(uiChild));

        pDomainConfiguration-&gt;validate(pConfigurableElement, pMainBlackboard);
    }
}

// Attempt validation for all configurable element's areas, relying on already existing valid
// configuration inside domain
void CConfigurableDomain::autoValidateAll()
{
    // Validate
    ConfigurableElementListIterator it;

    // Browse all configurable elements for configuration validation
    for (it = _configurableElementList.begin(); it != _configurableElementList.end(); ++it) {

        const CConfigurableElement *pConfigurableElement = *it;

        // Auto validate element
        autoValidateAreas(pConfigurableElement);
    }
}

// Attempt validation for configurable element's areas, relying on already existing valid
// configuration inside domain
void CConfigurableDomain::autoValidateAreas(const CConfigurableElement *pConfigurableElement)
{
    // Find first valid configuration for given configurable element
    const CDomainConfiguration *pValidDomainConfiguration =
        findValidDomainConfiguration(pConfigurableElement);

    // No valid configuration found, give up
    if (!pValidDomainConfiguration) {

        return;
    }

    // Validate all other configurations against found one, if any
    size_t uiNbConfigurations = getNbChildren();

    for (size_t uiChild = 0; uiChild &lt; uiNbConfigurations; uiChild++) {

        CDomainConfiguration *pDomainConfiguration =
            static_cast&lt;CDomainConfiguration *&gt;(getChild(uiChild));

        if (pDomainConfiguration != pValidDomainConfiguration &amp;&amp;
            !pDomainConfiguration-&gt;isValid(pConfigurableElement)) {
            // Validate
            pDomainConfiguration-&gt;validateAgainst(pValidDomainConfiguration, pConfigurableElement);
        }
    }
}

// Attempt configuration validation for all configurable elements' areas, relying on already
// existing valid configuration inside domain
bool CConfigurableDomain::autoValidateConfiguration(CDomainConfiguration *pDomainConfiguration)
{
    // Find another configuration than this one, that ought to be valid!
    size_t uiNbConfigurations = getNbChildren();

    for (size_t uiChild = 0; uiChild &lt; uiNbConfigurations; uiChild++) {

        const CDomainConfiguration *pPotententialValidDomainConfiguration =
            static_cast&lt;const CDomainConfiguration *&gt;(getChild(uiChild));

        if (pPotententialValidDomainConfiguration != pDomainConfiguration) {

            // Validate against it
            pDomainConfiguration-&gt;validateAgainst(pPotententialValidDomainConfiguration);

            return true;
        }
    }
    return false;
}

// Search for a valid configuration for given configurable element
const CDomainConfiguration *CConfigurableDomain::findValidDomainConfiguration(
    const CConfigurableElement *pConfigurableElement) const
{
    size_t uiNbConfigurations = getNbChildren();

    for (size_t uiChild = 0; uiChild &lt; uiNbConfigurations; uiChild++) {

        const CDomainConfiguration *pDomainConfiguration =
            static_cast&lt;const CDomainConfiguration *&gt;(getChild(uiChild));

        if (pDomainConfiguration-&gt;isValid(pConfigurableElement)) {

            return pDomainConfiguration;
        }
    }
    return nullptr;
}

// Search for an applicable configuration
const CDomainConfiguration *CConfigurableDomain::findApplicableDomainConfiguration() const
{
    size_t uiNbConfigurations = getNbChildren();

    for (size_t uiChild = 0; uiChild &lt; uiNbConfigurations; uiChild++) {

        const CDomainConfiguration *pDomainConfiguration =
            static_cast&lt;const CDomainConfiguration *&gt;(getChild(uiChild));

        if (pDomainConfiguration-&gt;isApplicable()) {

            return pDomainConfiguration;
        }
    }
    return nullptr;
}

// Gather set of configurable elements
void CConfigurableDomain::gatherConfigurableElements(
    std::set&lt;const CConfigurableElement *&gt; &amp;configurableElementSet) const
{
    // Insert all configurable elements
    configurableElementSet.insert(_configurableElementList.begin(), _configurableElementList.end());
}

// Check configurable element already attached
bool CConfigurableDomain::containsConfigurableElement(
    const CConfigurableElement *pConfigurableCandidateElement) const
{
    ConfigurableElementListIterator it;

    // Browse all configurable elements for comparison
    for (it = _configurableElementList.begin(); it != _configurableElementList.end(); ++it) {

        if (pConfigurableCandidateElement == *it) {

            return true;
        }
    }
    return false;
}

// Merge any descended configurable element to this one with this one
void CConfigurableDomain::mergeAlreadyAssociatedDescendantConfigurableElements(
    CConfigurableElement *newElement, core::Results &amp;infos)
{
    std::list&lt;CConfigurableElement *&gt; mergedConfigurableElementList;

    ConfigurableElementListIterator it;

    // Browse all configurable elements (new one not yet in the list!)
    for (it = _configurableElementList.begin(); it != _configurableElementList.end(); ++it) {

        CConfigurableElement *pConfigurablePotentialDescendantElement = *it;

        if (pConfigurablePotentialDescendantElement-&gt;isDescendantOf(newElement)) {

            infos.push_back(&quot;In domain '&quot; + getName() +
                            &quot;', merging descendant configurable element's configurations '&quot; +
                            pConfigurablePotentialDescendantElement-&gt;getName() +
                            &quot;' into its ascendant '&quot; + newElement-&gt;getName() + &quot;' ones&quot;);

            // Merge configuration data
            mergeConfigurations(newElement, pConfigurablePotentialDescendantElement);

            // Keep track for removal
            mergedConfigurableElementList.push_back(pConfigurablePotentialDescendantElement);
        }
    }

    // Remove all merged elements (new one not yet in the list!)
    for (it = mergedConfigurableElementList.begin(); it != mergedConfigurableElementList.end();
         ++it) {

        CConfigurableElement *pMergedConfigurableElement = *it;

        // Remove merged from configurable element from internal tracking list
        // Note: we shouldn't need to recompute the sync set in that case, as the merged to element
        // should include the syncers of merged from elements
        doRemoveConfigurableElement(pMergedConfigurableElement, false);
    }
}

void CConfigurableDomain::mergeConfigurations(CConfigurableElement *pToConfigurableElement,
                                              CConfigurableElement *pFromConfigurableElement)
{
    // Propagate to domain configurations
    size_t uiNbConfigurations = getNbChildren();

    for (size_t uiChild = 0; uiChild &lt; uiNbConfigurations; uiChild++) {

        CDomainConfiguration *pDomainConfiguration =
            static_cast&lt;CDomainConfiguration *&gt;(getChild(uiChild));

        // Do the merge.
        pDomainConfiguration-&gt;merge(pToConfigurableElement, pFromConfigurableElement);
    }
}

// Configurable elements association
void CConfigurableDomain::doAddConfigurableElement(CConfigurableElement *pConfigurableElement,
                                                   core::Results &amp;infos,
                                                   const CParameterBlackboard *pMainBlackboard)
{
    // Inform configurable element
    pConfigurableElement-&gt;addAttachedConfigurableDomain(this);

    // Create associated syncer set
    auto pSyncerSet = new CSyncerSet;

    // Add to sync set the configurable element one
    pConfigurableElement-&gt;fillSyncerSet(*pSyncerSet);

    // Store it
    _configurableElementToSyncerSetMap[pConfigurableElement] = pSyncerSet;

    // Add it to global one
    _syncerSet += *pSyncerSet;

    // Inform configurations
    size_t uiNbConfigurations = getNbChildren();

    for (size_t uiChild = 0; uiChild &lt; uiNbConfigurations; uiChild++) {

        CDomainConfiguration *pDomainConfiguration =
            static_cast&lt;CDomainConfiguration *&gt;(getChild(uiChild));

        pDomainConfiguration-&gt;addConfigurableElement(pConfigurableElement, pSyncerSet);
    }

    // Ensure area validity for that configurable element (if main blackboard provided)
    if (pMainBlackboard) {

        infos.push_back(&quot;Validating domain '&quot; + getName() +
                        &quot;' against main blackboard for configurable element '&quot; +
                        pConfigurableElement-&gt;getPath() + &quot;'&quot;);
        // Need to validate against main blackboard
        validateAreas(pConfigurableElement, pMainBlackboard);
    }

    // Already associated descendend configurable elements need a merge of their configuration data
    mergeAlreadyAssociatedDescendantConfigurableElements(pConfigurableElement, infos);

    // Add to list
    _configurableElementList.push_back(pConfigurableElement);
}

void CConfigurableDomain::doRemoveConfigurableElement(CConfigurableElement *pConfigurableElement,
                                                      bool bRecomputeSyncSet)
{
    // Remove from list
    _configurableElementList.remove(pConfigurableElement);

    // Remove associated syncer set
    CSyncerSet *pSyncerSet = getSyncerSet(pConfigurableElement);

    _configurableElementToSyncerSetMap.erase(pConfigurableElement);

    delete pSyncerSet;

    // Inform configurable element
    pConfigurableElement-&gt;removeAttachedConfigurableDomain(this);

    // Inform configurations
    size_t uiNbConfigurations = getNbChildren();

    for (size_t uiChild = 0; uiChild &lt; uiNbConfigurations; uiChild++) {

        CDomainConfiguration *pDomainConfiguration =
            static_cast&lt;CDomainConfiguration *&gt;(getChild(uiChild));

        pDomainConfiguration-&gt;removeConfigurableElement(pConfigurableElement);
    }
    // Recompute our sync set if needed
    if (bRecomputeSyncSet) {

        computeSyncSet();
    }
}

// Syncer set retrieval from configurable element
CSyncerSet *CConfigurableDomain::getSyncerSet(
    const CConfigurableElement *pConfigurableElement) const
{
    auto mapIt = _configurableElementToSyncerSetMap.find(pConfigurableElement);

<A NAME="0"></A>    ALWAYS_ASSERT(mapIt != _configurableElementToSyncerSetMap.end(),
                  &quot;Could not find syncer set for &quot; &lt;&lt; getName() &lt;&lt; &quot; configurable domain&quot;);

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match581-0.html#0',2,'match581-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    return mapIt-&gt;second;
}

// Configuration retrieval
CDomainConfiguration *CConfigurableDomain::findConfiguration(const string &amp;strConfiguration,
                                                             string &amp;strError)
{
    CDomainConfiguration *pDomainConfiguration =
        static_cast&lt;CDomainConfiguration *&gt;(findChild(strConfiguration));

    if (!pDomainConfiguration) {

        strError = &quot;Domain configuration &quot; + strConfiguration + &quot; not found&quot;;

        return nullptr;
    }
    return pDomainConfiguration;
}</B></FONT>

const CDomainConfiguration *CConfigurableDomain::findConfiguration(const string &amp;strConfiguration,
                                                                   string &amp;strError) const
{
    const CDomainConfiguration *pDomainConfiguration =
        static_cast&lt;const CDomainConfiguration *&gt;(findChild(strConfiguration));

    if (!pDomainConfiguration) {

        strError = &quot;Domain configuration &quot; + strConfiguration + &quot; not found&quot;;

        return nullptr;
    }
    return pDomainConfiguration;
}
</PRE>
</div>
  </div>
</body>
</html>
