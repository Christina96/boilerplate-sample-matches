
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexRaku.cxx</h3>
            <pre><code>1  #include <stdlib.h>
2  #include <string.h>
3  #include <stdio.h>
4  #include <stdarg.h>
5  #include <assert.h>
6  #include <ctype.h>
7  #include <string>
8  #include <string_view>
9  #include <vector>
10  #include <map>
11  #include <functional>
12  #include "ILexer.h"
13  #include "Scintilla.h"
14  #include "SciLexer.h"
15  #include "WordList.h"
16  #include "LexAccessor.h"
17  #include "StyleContext.h"
18  #include "CharacterSet.h"
19  #include "CharacterCategory.h"
20  #include "LexerModule.h"
21  #include "OptionSet.h"
22  #include "DefaultLexer.h"
23  using namespace Scintilla;
24  using namespace Lexilla;
25  namespace { 
26  #define RAKUNUM_BINARY		1	
27  #define RAKUNUM_OCTAL		2
28  #define RAKUNUM_FLOAT_EXP	3	
29  #define RAKUNUM_HEX			4	
30  #define RAKUNUM_DECIMAL		5	
31  #define RAKUNUM_VECTOR		6
32  #define RAKUNUM_V_VECTOR	7
33  #define RAKUNUM_VERSION		8	
34  #define RAKUNUM_BAD			9
35  #define RAKUTYPE_REGEX_NORM		0	
36  #define RAKUTYPE_REGEX_S		1	
37  #define RAKUTYPE_REGEX_M		2	
38  #define RAKUTYPE_REGEX_Y		3	
39  #define RAKUTYPE_REGEX			4	
40  #define RAKUTYPE_REGEX_RX		5	
41  #define RAKUTYPE_REGEX_TR		6	
42  #define RAKUTYPE_QLANG			7	
43  #define RAKUTYPE_STR_WQ			8	
44  #define RAKUTYPE_STR_Q			9	
45  #define RAKUTYPE_STR_QX			10	
46  #define RAKUTYPE_STR_QW			11	
47  #define RAKUTYPE_STR_QQ			12	
48  #define RAKUTYPE_STR_QQX		13	
49  #define RAKUTYPE_STR_QQW		14	
50  #define RAKUTYPE_STR_QQWW		15	
51  #define RAKUDELIM_BRACKET		0	
52  #define RAKUDELIM_QUOTE			1	
53  const char *const rakuWordLists[] = {
54  	"Keywords and identifiers",
55  	"Functions",
56  	"Types basic",
57  	"Types composite",
58  	"Types domain-specific",
59  	"Types exception",
60  	"Adverbs",
61  	nullptr,
62  };
63  struct OptionsRaku {
64  	bool fold;
65  	bool foldCompact;
66  	bool foldComment;
67  	bool foldCommentMultiline;
68  	bool foldCommentPOD;
69  	OptionsRaku() {
70  		fold					= true;
71  		foldCompact				= false;
72  		foldComment				= true;
73  		foldCommentMultiline	= true;
74  		foldCommentPOD			= true;
75  	}
76  };
77  struct OptionSetRaku : public OptionSet<OptionsRaku> {
78  	OptionSetRaku() {
79  		DefineProperty("fold",			&OptionsRaku::fold);
80  		DefineProperty("fold.comment",	&OptionsRaku::foldComment);
81  		DefineProperty("fold.compact",	&OptionsRaku::foldCompact);
82  		DefineProperty("fold.raku.comment.multiline",	&OptionsRaku::foldCommentMultiline,
83  			"Set this property to 0 to disable folding multi-line comments when fold.comment=1.");
84  		DefineProperty("fold.raku.comment.pod",			&OptionsRaku::foldCommentPOD,
85  			"Set this property to 0 to disable folding POD comments when fold.comment=1.");
86  		DefineWordListSets(rakuWordLists);
87  	}
88  };
89  struct DelimPair {
90  	int opener;		
91  	int closer[2];	
92  	bool interpol;	
93  	short count;	
94  	DelimPair() {
95  		opener = 0;
96  		closer[0] = 0;
97  		closer[1] = 0;
98  		interpol = false;
99  		count = 0;
100  	}
101  	bool isCloser(int ch) const {
102  		return ch == closer[0] || ch == closer[1];
103  	}
104  };
105  constexpr bool IsANewLine(int ch) noexcept {
106  	return ch == '\r' || ch == '\n';
107  }
108  bool IsAWhitespace(int ch) noexcept {
109  	return IsASpaceOrTab(ch) || IsANewLine(ch);
110  }
111  constexpr bool IsAlphabet(int ch) noexcept {
112  	return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z');
113  }
114  bool IsCommentLine(Sci_Position line, LexAccessor &styler, int type = SCE_RAKU_COMMENTLINE) {
115  	Sci_Position pos = styler.LineStart(line);
116  	Sci_Position eol_pos = styler.LineStart(line + 1) - 1;
117  	for (Sci_Position i = pos; i < eol_pos; i++) {
118  		char ch = styler[i];
119  		int style = styler.StyleAt(i);
120  		if (type == SCE_RAKU_COMMENTEMBED) {
121  			if (i == (eol_pos - 1) && style == type)
122  				return true;
123  		} else { 
124  			if (ch == '#' && style == type && styler[i+1] != '`' )
125  				return true;
126  			else if (!IsASpaceOrTab(ch))
127  				return false;
128  		}
129  	}
130  	return false;
131  }
132  bool ContainsQTo(Sci_Position start, Sci_Position end, LexAccessor &styler) {
133  	std::string adverb;
134  	for (Sci_Position i = start; i < end; i++) {
135  		if (styler.StyleAt(i) == SCE_RAKU_ADVERB) {
136  			adverb.push_back(styler[i]);
137  		}
138  	}
139  	return adverb.find(":to") != std::string::npos;
140  }
141  int GetBracketCloseChar(const int ch) noexcept {
142  	const CharacterCategory cc = CategoriseCharacter(ch);
143  	switch (cc) {
144  		case ccSm:
145  			switch (ch) {
146  				case 0x3C: return 0x3E; 
147  				case 0x2208: return 0x220B; 
148  				case 0x2209: return 0x220C; 
149  				case 0x220A: return 0x220D; 
150  				case 0x2215: return 0x29F5; 
151  				case 0x2243: return 0x22CD; 
152  				case 0x2298: return 0x29B8; 
153  				case 0x22A6: return 0x2ADE; 
154  				case 0x22A8: return 0x2AE4; 
155  				case 0x22A9: return 0x2AE3; 
156  				case 0x22AB: return 0x2AE5; 
157  				case 0x22F2: return 0x22FA; 
158  				case 0x22F3: return 0x22FB; 
159  				case 0x22F4: return 0x22FC; 
160  				case 0x22F6: return 0x22FD; 
161  				case 0x22F7: return 0x22FE; 
162  				case 0xFF1C: return 0xFF1E; 
163  			}
164  			break;
165  		case ccPs:
166  			switch (ch) {
167  				case 0x5B: return 0x5D; 
168  				case 0x7B: return 0x7D; 
169  				case 0x298D: return 0x2990; 
170  				case 0x298F: return 0x298E; 
171  				case 0xFF3B: return 0xFF3D; 
172  				case 0xFF5B: return 0xFF5D; 
173  			}
174  			break;
175  		case ccPi:
176  			break;
177  		default: return 0;
178  	}
179  	return ch + 1;
180  }
181  bool IsValidQuoteOpener(const int ch, DelimPair &dp, int type = RAKUDELIM_BRACKET) noexcept {
182  	dp.closer[0] = 0;
183  	dp.closer[1] = 0;
184  	dp.interpol = true;
185  	if (type == RAKUDELIM_QUOTE) {
186  		switch (ch) {
187  			case '\'':		dp.closer[0] = '\'';	
188  				dp.interpol = false;
189  				break;
190  			case '"':		dp.closer[0] = '"';		
191  				break;
192  			case 0x2018:	dp.closer[0] = 0x2019;	
193  				dp.interpol = false;
194  				break;
195  			case 0x201C:	dp.closer[0] = 0x201D;	
196  				break;
197  			case 0x201D:	dp.closer[0] = 0x201C;	
198  				break;
199  			case 0x201E:	dp.closer[0] = 0x201C;	
200  							dp.closer[1] = 0x201D;
201  				break;
202  			case 0xFF62:	dp.closer[0] = 0xFF63;	
203  				dp.interpol = false;
204  				break;
205  			default:		return false;
206  		}
207  	} else if (type == RAKUDELIM_BRACKET) {
208  		dp.closer[0] = GetBracketCloseChar(ch);
209  	}
210  	dp.opener = ch;
211  	dp.count = 1;
212  	return dp.closer[0] > 0;
213  }
214  bool IsBracketOpenChar(int ch) noexcept {
215  	return GetBracketCloseChar(ch) > 0;
216  }
217  bool IsValidRegOrQAdjacent(int ch) noexcept {
218  	return !(IsAlphaNumeric(ch) || ch == '_' || ch == '(' || ch == ')' || ch == '\'' );
219  }
220  bool IsValidRegOrQPrecede(int ch) noexcept {
221  	return !(IsAlphaNumeric(ch) || ch == '_');
222  }
223  bool MatchCharInRange(StyleContext &sc, const Sci_Position length,
224  		const int match, bool ignoreDelim = false) {
225  	Sci_Position len = 0;
226  	int chPrev = sc.chPrev;
227  	while (++len < length) {
228  		const int ch = sc.GetRelativeCharacter(len);
229  		if (ch == match && (ignoreDelim || chPrev != '\\'))
230  			return true;
231  	}
232  	return false;
233  }
234  int PrevNonWhitespaceChar(StyleContext &sc) {
235  	Sci_Position rel = 0;
236  	Sci_Position max_back = 0 - sc.currentPos;
237  	while (--rel > max_back) {
238  		const int ch = sc.GetRelativeCharacter(rel);
239  		if (!IsAWhitespace(ch))
240  			return ch;
241  	}
242  	return 0; 
243  }
244  bool IsQLangStartAtScPos(StyleContext &sc, int &type, const Sci_Position length) {
245  	const bool valid_adj = IsValidRegOrQAdjacent(sc.chNext);
246  	const int chFw2 = sc.GetRelativeCharacter(2);
247  	const int chFw3 = sc.GetRelativeCharacter(3);
248  	type = -1;
249  	if (IsValidRegOrQPrecede(sc.chPrev)) {
250  		if (sc.ch == 'Q' && valid_adj) {
251  			type = RAKUTYPE_QLANG;
252  		} else if (sc.ch == 'q') {
253  			switch (sc.chNext) {
254  				case 'x':
255  					type = RAKUTYPE_STR_QX;
256  					break;
257  				case 'w':
258  					type = RAKUTYPE_STR_QW;
259  					break;
260  				case 'q':
261  					if (chFw2 == 'x') {
262  						type = RAKUTYPE_STR_QQX;
263  					} else if (chFw2 == 'w') {
264  						if (chFw3 == 'w') {
265  							type = RAKUTYPE_STR_QQWW;
266  						} else {
267  							type = RAKUTYPE_STR_QQW;
268  						}
269  					} else {
270  						type = RAKUTYPE_STR_QQ;
271  					}
272  					break;
273  				default:
274  					type = RAKUTYPE_STR_Q;
275  			}
276  		} else if (sc.ch == '<' && MatchCharInRange(sc, length, '>')) {
277  			type = RAKUTYPE_STR_WQ; 
278  		}
279  	}
280  	return type >= 0;
281  }
282  bool IsRegexStartAtScPos(StyleContext &sc, int &type, CharacterSet &set) {
283  	const bool valid_adj = IsValidRegOrQAdjacent(sc.chNext);
284  	type = -1;
285  	if (IsValidRegOrQPrecede(sc.chPrev)) {
286  		switch (sc.ch) {
287  			case 'r':
288  				if (sc.chNext == 'x')
289  					type = RAKUTYPE_REGEX_RX;
290  				break;
291  			case 't':
292  			case 'T':
293  				if (sc.chNext == 'r' || sc.chNext == 'R')
294  					type = RAKUTYPE_REGEX_TR;
295  				break;
296  			case 'm':
297  				if (valid_adj)
298  					type = RAKUTYPE_REGEX_M;
299  				break;
300  			case 's':
301  			case 'S':
302  				if (valid_adj)
303  					type = RAKUTYPE_REGEX_S;
304  				break;
305  			case 'y':
306  				if (valid_adj)
307  					type = RAKUTYPE_REGEX_Y;
308  				break;
309  			case '/':
310  				if (set.Contains(PrevNonWhitespaceChar(sc)))
311  					type = RAKUTYPE_REGEX_NORM;
312  		}
313  	}
314  	return type >= 0;
315  }
316  bool IsValidIdentPrecede(int ch) noexcept {
317  	return !(IsAlphaNumeric(ch) || ch == '_' || ch == '@' || ch == '$' || ch == '%');
318  }
319  bool IsValidDelimiter(int ch) noexcept {
320  	return !(IsAlphaNumeric(ch) || ch == ':');
321  }
322  int GetDelimiterCloseChar(int ch) noexcept {
323  	int ch_end = GetBracketCloseChar(ch);
324  	if (ch_end == 0 && IsValidDelimiter(ch)) {
325  		ch_end = ch;
326  	}
327  	return ch_end;
328  }
329  Sci_Position GetRepeatCharCount(StyleContext &sc, int chMatch, Sci_Position length) {
330  	Sci_Position cnt = 0;
331  	while (cnt < length) {
332  		if (sc.GetRelativeCharacter(cnt) != chMatch) {
333  			break;
334  		}
335  		cnt++;
336  	}
337  	return cnt;
338  }
339  Sci_Position LengthToDelimiter(StyleContext &sc, const DelimPair &dp,
340  		Sci_Position length, bool noTrailing = false) {
341  	short cnt_open = 0;			
342  	short cnt_close = 0;		
343  	bool is_escape = false;		
344  	Sci_Position len = 0;		
345  	int chOpener = dp.opener;	
346  	if (dp.opener == dp.closer[0])
347  		chOpener = 0;			
348  	while (len < length) {
349  		const int chPrev = sc.GetRelativeCharacter(len - 1);
350  		const int ch = sc.GetRelativeCharacter(len);
351  		const int chNext = sc.GetRelativeCharacter(len+1);
352  		if (cnt_open == 0 && cnt_close == dp.count) {
353  			return len;				
354  		} else if (is_escape) {
355  			is_escape = false;
356  		} else if (ch == '\\') {
357  			is_escape = true;
358  		} else {
359  			if (ch == chOpener) {
360  				cnt_open++;			
361  			} else if (dp.isCloser(ch)) {
362  				if ( cnt_open > 0 ) {
363  					cnt_open--;		
364  				} else if (dp.count > 1 && cnt_close < (dp.count - 1)) {
365  					if (cnt_close > 1) {
366  						if (dp.isCloser(chPrev)) {
367  							cnt_close++;
368  						} else {	
369  							cnt_close = 0;
370  						}
371  					} else {
372  						cnt_close++;
373  					}
374  				} else if (!noTrailing || (IsAWhitespace(chNext))) {
375  					cnt_close++;		
376  					if (cnt_close > 1 && !dp.isCloser(chPrev)) {
377  						cnt_close = 0;	
378  					}
379  				} else {
380  					cnt_close = 0;		
381  				}
382  			} else if (IsANewLine(ch)) {
383  				cnt_open = 0;			
384  				cnt_close = 0;
385  			}
386  		}
387  		len++;
388  	}
389  	return -1; 
390  }
391  Sci_Position LengthToEndHeredoc(const StyleContext &sc, LexAccessor &styler,
392  		const Sci_Position length, const char *delim) {
393  	bool on_new_ln = false;
394  	int i = 0; 
395  	for (int n = 0; n < length; n++) {
396  		const char ch = styler.SafeGetCharAt(sc.currentPos + n, 0);
397  		if (on_new_ln) {
398  			if (delim[i] == '\0')
399  				return n;	
400  			if (ch != delim[i++])
401  				i = 0;		
402  		}
403  		if (i == 0)			
404  			on_new_ln = IsANewLine(ch);
405  	}
406  	return -1;				
407  }
408  Sci_Position LengthToNextChar(StyleContext &sc, const Sci_Position length) {
409  	Sci_Position len = 0;
410  	while (++len < length) {
411  		const int ch = sc.GetRelativeCharacter(len);
412  		if (!IsASpaceOrTab(ch) && !IsANewLine(ch)) {
413  			break;
414  		}
415  	}
416  	return len;
417  }
418  void GetRelativeString(StyleContext &sc, Sci_Position offset, Sci_Position length,
419  		std::string &str) {
420  	Sci_Position pos = offset;
421  	str.clear();
422  	while (pos < length) {
423  		str += sc.GetRelativeCharacter(pos++);
424  	}
425  }
426  } 
427  class LexerRaku : public DefaultLexer {
428  	CharacterSet setWord;
429  	CharacterSet setSigil;
430  	CharacterSet setTwigil;
431  	CharacterSet setOperator;
432  	CharacterSet setSpecialVar;
433  	WordList regexIdent;			
434  	OptionsRaku options;			
435  	OptionSetRaku osRaku;
436  	WordList keywords;				
437  	WordList functions;
438  	WordList typesBasic;
439  	WordList typesComposite;
<span onclick='openModal()' class='match'>440  	WordList typesDomainSpecific;
441  	WordList typesExceptions;
442  	WordList adverbs;
443  public:
444  	explicit LexerRaku() :
445  		DefaultLexer("raku", SCLEX_RAKU),
</span>446  		setWord(CharacterSet::setAlphaNum, "-_", 0x80),
447  		setSigil(CharacterSet::setNone, "$&%@"),
448  		setTwigil(CharacterSet::setNone, "!*.:<=?^~"),
449  		setOperator(CharacterSet::setNone, "^&\\()-+=|{}[]:;<>,?!.~"),
450  		setSpecialVar(CharacterSet::setNone, "_/!") {
451  		regexIdent.Set("regex rule token");
452  	}
453  	LexerRaku(const LexerRaku &) = delete;
454  	LexerRaku(LexerRaku &&) = delete;
455  	void operator=(const LexerRaku &) = delete;
456  	void operator=(LexerRaku &&) = delete;
457  	virtual ~LexerRaku() {
458  	}
459  	void SCI_METHOD Release() noexcept override {
460  		delete this;
461  	}
462  	int SCI_METHOD Version() const noexcept override {
463  		return lvRelease5;
464  	}
465  	const char *SCI_METHOD PropertyNames() override {
466  		return osRaku.PropertyNames();
467  	}
468  	int SCI_METHOD PropertyType(const char *name) override {
469  		return osRaku.PropertyType(name);
470  	}
471  	const char *SCI_METHOD DescribeProperty(const char *name) override {
472  		return osRaku.DescribeProperty(name);
473  	}
474  	Sci_Position SCI_METHOD PropertySet(const char *key, const char *val) override;
475  	const char *SCI_METHOD PropertyGet(const char *key) override {
476  		return osRaku.PropertyGet(key);
477  	}
478  	const char *SCI_METHOD DescribeWordListSets() override {
479  		return osRaku.DescribeWordListSets();
480  	}
481  	Sci_Position SCI_METHOD WordListSet(int n, const char *wl) override;
482  	void SCI_METHOD Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) override;
483  	void SCI_METHOD Fold(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) override;
484  	static ILexer5 *LexerFactoryRaku() {
485  		return new LexerRaku();
486  	}
487  protected:
488  	bool IsOperatorChar(const int ch);
489  	bool IsWordChar(const int ch, bool allowNumber = true);
490  	bool IsWordStartChar(const int ch);
491  	bool IsNumberChar(const int ch, int base = 10);
492  	bool ProcessRegexTwinCapture(StyleContext &sc, const Sci_Position length,
493  		int &type, const DelimPair &dp);
494  	void ProcessStringVars(StyleContext &sc, const Sci_Position length, const int varState);
495  	bool ProcessValidRegQlangStart(StyleContext &sc, Sci_Position length, const int type,
496  		WordList &wordsAdverbs, DelimPair &dp);
497  	Sci_Position LengthToNonWordChar(StyleContext &sc, Sci_Position length,
498  		char *s, const int size, Sci_Position offset = 0);
499  };
500  bool LexerRaku::IsOperatorChar(const int ch) {
501  	if (ch > 0x7F) {
502  		switch (ch) {
503  			case 0x2208:	
504  			case 0x2209:	
505  			case 0x220B:	
506  			case 0x220C:	
507  			case 0x2216:	
508  			case 0x2229:	
509  			case 0x222A:	
510  			case 0x2282:	
511  			case 0x2283:	
512  			case 0x2284:	
513  			case 0x2285:	
514  			case 0x2286:	
515  			case 0x2287:	
516  			case 0x2288:	
517  			case 0x2289:	
518  			case 0x228D:	
519  			case 0x228E:	
520  			case 0x2296:	
521  				return true;
522  		}
523  	}
524  	return setOperator.Contains(ch);
525  }
526  bool LexerRaku::IsWordChar(const int ch, bool allowNumber) {
527  	if (ch > 0x7F) {
528  		const CharacterCategory cc = CategoriseCharacter(ch);
529  		switch (cc) {
530  			case ccLu:
531  			case ccLl:
532  			case ccLt:
533  			case ccLm:
534  			case ccLo:
535  				return true;
536  			default:
537  				return false;
538  		}
539  	} else if (allowNumber && IsADigit(ch)) {
540  		return true; 
541  	}
542  	return setWord.Contains(ch);
543  }
544  bool LexerRaku::IsWordStartChar(const int ch) {
545  	return ch != '-' && IsWordChar(ch, false); 
546  }
547  bool LexerRaku::IsNumberChar(const int ch, int base) {
548  	if (ch > 0x7F) {
549  		const CharacterCategory cc = CategoriseCharacter(ch);
550  		switch (cc) {
551  			case ccNd:
552  			case ccNl:
553  			case ccNo:
554  				return true;
555  			default:
556  				return false;
557  		}
558  	}
559  	return IsADigit(ch, base);
560  }
561  Sci_Position SCI_METHOD LexerRaku::PropertySet(const char *key, const char *val) {
562  	if (osRaku.PropertySet(&options, key, val))
563  		return 0;
564  	return -1;
565  }
566  Sci_Position SCI_METHOD LexerRaku::WordListSet(int n, const char *wl) {
567  	WordList *wordListN = nullptr;
568  	switch (n) {
569  		case 0:
570  			wordListN = &keywords;
571  			break;
572  		case 1:
573  			wordListN = &functions;
574  			break;
575  		case 2:
576  			wordListN = &typesBasic;
577  			break;
578  		case 3:
579  			wordListN = &typesComposite;
580  			break;
581  		case 4:
582  			wordListN = &typesDomainSpecific;
583  			break;
584  		case 5:
585  			wordListN = &typesExceptions;
586  			break;
587  		case 6:
588  			wordListN = &adverbs;
589  			break;
590  	}
591  	Sci_Position firstModification = -1;
592  	if (wordListN) {
593  		WordList wlNew;
594  		wlNew.Set(wl);
595  		if (*wordListN != wlNew) {
596  			wordListN->Set(wl);
597  			firstModification = 0;
598  		}
599  	}
600  	return firstModification;
601  }
602  bool LexerRaku::ProcessRegexTwinCapture(StyleContext &sc, const Sci_Position length,
603  		int &type, const DelimPair &dp) {
604  	if (type == RAKUTYPE_REGEX_S || type == RAKUTYPE_REGEX_TR || type == RAKUTYPE_REGEX_Y) {
605  		type = -1; 
606  		if (dp.isCloser(sc.chPrev))
607  			sc.Forward();
608  		if (dp.isCloser(dp.opener))
609  			return true;
610  		const Sci_Position len = LengthToNextChar(sc, length);
611  		if (sc.GetRelativeCharacter(len) == dp.opener) {
612  			sc.Forward(len);
613  			return true;
614  		}
615  	}
616  	return false;
617  }
618  void LexerRaku::ProcessStringVars(StyleContext &sc, const Sci_Position length, const int varState) {
619  	const int state = sc.state;
620  	for (Sci_Position pos = 0; pos < length; pos++) {
621  		if (sc.state == varState && !IsWordChar(sc.ch)) {
622  			sc.SetState(state);
623  		} else if (sc.chPrev != '\\'
624  				&& (sc.ch == '$' || sc.ch == '@')
625  				&& IsWordStartChar(sc.chNext)) {
626  			sc.SetState(varState);
627  		}
628  		sc.Forward(); 
629  	}
630  }
631  bool LexerRaku::ProcessValidRegQlangStart(StyleContext &sc, Sci_Position length, const int type,
632  		WordList &wordsAdverbs, DelimPair &dp) {
633  	Sci_Position startPos = sc.currentPos;
634  	Sci_Position startLen = length;
635  	const int target_state = sc.state;
636  	int state = SCE_RAKU_DEFAULT;
637  	std::string str;
638  	dp.opener = 0;					
639  	bool got_all_adverbs = false;	
640  	bool got_ident = false;			
641  	sc.SetState(state);				
642  	while ((dp.opener == 0 || !got_all_adverbs) && sc.More()) {
643  		const bool was_space = IsAWhitespace(sc.ch);
644  		if (!got_all_adverbs && was_space) {
645  			sc.Forward(LengthToNextChar(sc, length));
646  		}
647  		length = startLen - (sc.currentPos - startPos); 
648  		if (dp.opener == 0 && !got_ident && type == RAKUTYPE_REGEX && IsAlphabet(sc.ch)) {
649  			bool got_sym = false;
650  			while (sc.More()) {
651  				sc.SetState(SCE_RAKU_IDENTIFIER);
652  				while (sc.More() && (IsAlphaNumeric(sc.chNext)
653  						|| sc.chNext == '_' || sc.chNext == '-')) {
654  					sc.Forward();
655  				}
656  				sc.Forward();
657  				if (got_sym && sc.ch == '>') {
658  					sc.SetState(SCE_RAKU_OPERATOR);	
659  					sc.Forward();
660  					break;
661  				} else if (type == RAKUTYPE_REGEX && sc.Match(":sym<")) {
662  					sc.SetState(SCE_RAKU_ADVERB);	
663  					sc.Forward(4);
664  					sc.SetState(SCE_RAKU_OPERATOR);	
665  					sc.Forward();
666  					got_sym = true;
667  				} else {
668  					break;
669  				}
670  			}
671  			sc.SetState(state);
672  			got_ident = true;
673  		}
674  		else if (!got_all_adverbs && sc.ch == ':' && (!(dp.opener == 0 && got_ident)
675  				&& !(dp.opener > 0 && type >= RAKUTYPE_QLANG))) {
676  			sc.SetState(SCE_RAKU_ADVERB);
677  			while (IsAlphaNumeric(sc.chNext) && sc.More()) {
678  				sc.Forward();
679  				str += sc.ch;
680  			}
681  			str += ' ';
682  			sc.Forward();
683  			sc.SetState(state);
684  		}
685  		else if (dp.opener == 0 && (was_space || IsValidRegOrQAdjacent(sc.ch))
686  				&& IsValidDelimiter(sc.ch)) {	
687  			sc.SetState((state = target_state));
688  			dp.opener = sc.ch;					
689  			if (type < RAKUTYPE_QLANG)			
690  				dp.count = 1;					
691  			else
692  				dp.count = GetRepeatCharCount(sc, dp.opener, length);
693  			sc.Forward(dp.count);
694  		}
695  		else {
696  			if (got_all_adverbs)
697  				break; 
698  			got_all_adverbs = true;
699  		}
700  	}
701  	wordsAdverbs.Set(str.c_str());
702  	dp.closer[0] = GetDelimiterCloseChar(dp.opener);
703  	dp.closer[1] = 0; 
704  	return dp.closer[0] > 0;
705  }
706  Sci_Position LexerRaku::LengthToNonWordChar(StyleContext &sc, Sci_Position length,
707  		char *s, const int size, Sci_Position offset) {
708  	Sci_Position len = 0;
709  	Sci_Position max_length = size < length ? size : length;
710  	while (len <= max_length) {
711  		const int ch = sc.GetRelativeCharacter(len + offset);
712  		if (!IsWordChar(ch)) {
713  			s[len] = '\0';
714  			break;
715  		}
716  		s[len] = ch;
717  		len++;
718  	}
719  	s[len + 1] = '\0';
720  	return len;
721  }
722  void SCI_METHOD LexerRaku::Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) {
723  	LexAccessor styler(pAccess);
724  	DelimPair dpEmbeded;			
725  	DelimPair dpString;				
726  	DelimPair dpRegQ;				
727  	std::string hereDelim;			
728  	int hereState = 0;				
729  	int numState = 0;				
730  	short cntDecimal = 0;			
731  	std::string wordLast;			
732  	std::string identLast;			
733  	std::string adverbLast;			
734  	WordList lastAdverbs;			
735  	Sci_Position len;				
736  	char s[100];					
737  	int typeDetect = -1;			
738  	Sci_Position lengthToEnd;		
739  	Sci_PositionU newStartPos = startPos;
740  	if (initStyle != SCE_RAKU_DEFAULT) {
741  		while (newStartPos > 0) {
742  			newStartPos--;
743  			if (styler.StyleAt(newStartPos) == SCE_RAKU_DEFAULT)
744  				break;
745  		}
746  		if (initStyle == SCE_RAKU_HEREDOC_Q || initStyle == SCE_RAKU_HEREDOC_QQ) {
747  			if (newStartPos > 0) {
748  				newStartPos = styler.LineStart(styler.GetLine(newStartPos));
749  			}
750  		}
751  	} else {
752  		const Sci_Position line = styler.GetLine(newStartPos);
753  		if (line > 0) {
754  			const Sci_Position startPreviousLine = styler.LineStart(line-1);
755  			if (ContainsQTo(startPreviousLine, newStartPos, styler)) {
756  				newStartPos = startPreviousLine;
757  			}
758  		}
759  	}
760  	if (newStartPos < startPos) {
761  		initStyle = SCE_RAKU_DEFAULT;
762  		length += startPos - newStartPos;
763  		startPos = newStartPos;
764  	}
765  	StyleContext sc(startPos, length, initStyle, styler);
766  	for (; sc.More(); sc.Forward()) {
767  		lengthToEnd = (length - (sc.currentPos - startPos)); 
768  		switch (sc.state) {
769  			case SCE_RAKU_OPERATOR:
770  				sc.SetState(SCE_RAKU_DEFAULT);
771  				break; 
772  			case SCE_RAKU_COMMENTLINE:
773  				if (IsANewLine(sc.ch)) {
774  					sc.SetState(SCE_RAKU_DEFAULT);
775  				}
776  				break;
777  			case SCE_RAKU_COMMENTEMBED:
778  				if ((len = LengthToDelimiter(sc, dpEmbeded, lengthToEnd)) >= 0) {
779  					sc.Forward(len);			
780  					sc.SetState(SCE_RAKU_DEFAULT);
781  				} else {
782  					sc.Forward(lengthToEnd);	
783  				}
784  				break;
785  			case SCE_RAKU_POD:
786  				if (sc.atLineStart && sc.Match("=end pod")) {
787  					sc.Forward(8);
788  					sc.SetState(SCE_RAKU_DEFAULT);
789  				}
790  				break;
791  			case SCE_RAKU_STRING:
792  				if ((len = LengthToDelimiter(sc, dpString, lengthToEnd)) >= 0) {
793  					if (dpString.interpol) {
794  						ProcessStringVars(sc, len, SCE_RAKU_STRING_VAR);
795  					} else {
796  						sc.Forward(len);
797  					}
798  					sc.SetState(SCE_RAKU_DEFAULT);
799  				} else {
800  					sc.Forward(lengthToEnd);	
801  				}
802  				break;
803  			case SCE_RAKU_STRING_Q:
804  			case SCE_RAKU_STRING_QQ:
805  			case SCE_RAKU_STRING_Q_LANG:
806  				if (dpRegQ.count == 1 && dpRegQ.isCloser(sc.chPrev)) {
807  					sc.SetState(SCE_RAKU_DEFAULT);
808  				}
809  				else if ((len = LengthToDelimiter(sc, dpRegQ, lengthToEnd)) >= 0) {
810  					if (lastAdverbs.InList("to")) {
811  						GetRelativeString(sc, -1, len - dpRegQ.count, hereDelim);
812  						hereState = SCE_RAKU_HEREDOC_Q; 
813  					}
814  					if (sc.state == SCE_RAKU_STRING_QQ || lastAdverbs.InList("qq")) {
815  						ProcessStringVars(sc, len, SCE_RAKU_STRING_VAR);
816  						hereState = SCE_RAKU_HEREDOC_QQ; 
817  					} else {
818  						sc.Forward(len);
819  					}
820  					sc.SetState(SCE_RAKU_DEFAULT);
821  				} else {
822  					sc.Forward(lengthToEnd);	
823  				}
824  				break;
825  			case SCE_RAKU_HEREDOC_Q:
826  			case SCE_RAKU_HEREDOC_QQ:
827  				if ((len = LengthToEndHeredoc(sc, styler, lengthToEnd, hereDelim.c_str())) >= 0) {
828  					if (sc.state == SCE_RAKU_HEREDOC_QQ) {
829  						ProcessStringVars(sc, len, SCE_RAKU_STRING_VAR);
830  					} else {
831  						sc.Forward(len);
832  					}
833  					sc.SetState(SCE_RAKU_DEFAULT);
834  				} else {
835  					sc.Forward(lengthToEnd);	
836  				}
837  				hereDelim.clear();				
838  				break;
839  			case SCE_RAKU_REGEX:
840  				while (sc.state == SCE_RAKU_REGEX) {
841  					if (dpRegQ.count == 1 && dpRegQ.isCloser(sc.chPrev)) {
842  						if (ProcessRegexTwinCapture(sc, lengthToEnd, typeDetect, dpRegQ))
843  							continue;
844  						sc.SetState(SCE_RAKU_DEFAULT);
845  						break;
846  					}
847  					else if ((len = LengthToDelimiter(sc, dpRegQ, lengthToEnd)) >= 0) {
848  						ProcessStringVars(sc, len, SCE_RAKU_REGEX_VAR);
849  						if (ProcessRegexTwinCapture(sc, lengthToEnd, typeDetect, dpRegQ))
850  							continue;
851  						sc.SetState(SCE_RAKU_DEFAULT);
852  						break;
853  					} else {
854  						sc.Forward(lengthToEnd); 
855  						break;
856  					}
857  				}
858  				break;
859  			case SCE_RAKU_NUMBER:
860  				if (sc.ch == '.') {
861  					if (sc.chNext == '.') {		
862  						sc.SetState(SCE_RAKU_OPERATOR);
863  						sc.Forward();
864  						if (sc.chNext == '.')	
865  							sc.Forward();
866  						break;
867  					} else if (numState > RAKUNUM_FLOAT_EXP
868  							&& (cntDecimal < 1 || numState == RAKUNUM_VERSION)) {
869  						cntDecimal++;
870  						sc.Forward();
871  					} else {
872  						sc.SetState(SCE_RAKU_DEFAULT);
873  						break; 
874  					}
875  				}
876  				switch (numState) {
877  					case RAKUNUM_BINARY:
878  						if (!IsNumberChar(sc.ch, 2))
879  							sc.SetState(SCE_RAKU_DEFAULT);
880  						break;
881  					case RAKUNUM_OCTAL:
882  						if (!IsNumberChar(sc.ch, 8))
883  							sc.SetState(SCE_RAKU_DEFAULT);
884  						break;
885  					case RAKUNUM_HEX:
886  						if (!IsNumberChar(sc.ch, 16))
887  							sc.SetState(SCE_RAKU_DEFAULT);
888  						break;
889  					case RAKUNUM_DECIMAL:
890  					case RAKUNUM_VERSION:
891  						if (!IsNumberChar(sc.ch))
892  							sc.SetState(SCE_RAKU_DEFAULT);
893  				}
894  				break;
895  			case SCE_RAKU_WORD:
896  			case SCE_RAKU_FUNCTION:
897  			case SCE_RAKU_TYPEDEF:
898  			case SCE_RAKU_ADVERB:
899  				sc.SetState(SCE_RAKU_DEFAULT);
900  				break;
901  			case SCE_RAKU_MU:
902  			case SCE_RAKU_POSITIONAL:
903  			case SCE_RAKU_ASSOCIATIVE:
904  			case SCE_RAKU_CALLABLE:
905  			case SCE_RAKU_IDENTIFIER:
906  			case SCE_RAKU_GRAMMAR:
907  			case SCE_RAKU_CLASS:
908  				sc.SetState(SCE_RAKU_DEFAULT);
909  				break;
910  		}
911  		if (sc.state == SCE_RAKU_DEFAULT) {
912  			if (sc.ch == '#') {
913  				sc.SetState(SCE_RAKU_COMMENTLINE);
914  			}
915  			else if (sc.atLineStart && sc.Match("=begin pod")) {
916  				sc.SetState(SCE_RAKU_POD);
917  				sc.Forward(10);
918  			}
919  			else if (sc.chPrev != '\\' && (IsValidQuoteOpener(sc.ch, dpString, RAKUDELIM_QUOTE))) {
920  				sc.SetState(SCE_RAKU_STRING);
921  			}
922  			else if (IsQLangStartAtScPos(sc, typeDetect, lengthToEnd)) {
923  				int state = SCE_RAKU_STRING_Q_LANG;
924  				Sci_Position forward = 1;	
925  				if (typeDetect > RAKUTYPE_QLANG) {
926  					state = SCE_RAKU_STRING_Q;
927  					if (typeDetect == RAKUTYPE_STR_WQ)
928  						forward = 0;		
929  				}
930  				if (typeDetect > RAKUTYPE_STR_Q) {
931  					if (typeDetect == RAKUTYPE_STR_QQ)
932  						state = SCE_RAKU_STRING_QQ;
933  					forward++;				
934  				}
935  				if (typeDetect > RAKUTYPE_STR_QQ)
936  					forward++;				
937  				if (typeDetect == RAKUTYPE_STR_QQWW)
938  					forward++;				
939  				if (IsValidRegOrQAdjacent(sc.GetRelative(forward)) || typeDetect == RAKUTYPE_QLANG) {
940  					sc.SetState(state);
941  					sc.Forward(forward);
942  					lastAdverbs.Clear();
943  					if (ProcessValidRegQlangStart(sc, lengthToEnd, typeDetect,
944  							lastAdverbs, dpRegQ))
945  						sc.SetState(state);
946  				}
947  			}
948  			else if ((IsRegexStartAtScPos(sc, typeDetect, setOperator) || regexIdent.InList(wordLast.c_str()))) {
949  				if (typeDetect == -1) { 
950  					wordLast.clear();
951  					typeDetect = RAKUTYPE_REGEX;
952  				}
953  				Sci_Position forward = 0;	
954  				if (typeDetect > 0 && typeDetect != RAKUTYPE_REGEX)
955  					forward++;				
956  				if (typeDetect > RAKUTYPE_REGEX)
957  					forward++;				
958  				if (IsValidRegOrQAdjacent(sc.GetRelative(forward)) || typeDetect == RAKUTYPE_REGEX_NORM) {
959  					sc.SetState(SCE_RAKU_REGEX);
960  					sc.Forward(forward);
961  					lastAdverbs.Clear();
962  					if (ProcessValidRegQlangStart(sc, lengthToEnd, typeDetect,
963  							lastAdverbs, dpRegQ))
964  						sc.SetState(SCE_RAKU_REGEX);
965  				}
966  			}
967  			else if (IsValidIdentPrecede(sc.chPrev) && (IsNumberChar(sc.ch)
968  					|| (sc.ch == 'v' && IsNumberChar(sc.chNext) && wordLast == "use"))) {
969  				numState = RAKUNUM_DECIMAL;	
970  				cntDecimal = 0;
971  				sc.SetState(SCE_RAKU_NUMBER);
972  				if (sc.ch == 'v')			
973  					sc.Forward();
974  				if (wordLast == "use") {	
975  					numState = RAKUNUM_VERSION;
976  				} else if (sc.ch == '0') {	
977  					switch (sc.chNext) {
978  						case 'b':	
979  							numState = RAKUNUM_BINARY;
980  							break;
981  						case 'o':	
982  							numState = RAKUNUM_OCTAL;
983  							break;
984  						case 'x':	
985  							numState = RAKUNUM_HEX;
986  					}
987  					if (numState != RAKUNUM_DECIMAL)
988  						sc.Forward();		
989  				}
990  			}
991  			else if ((sc.currentPos == 0 || sc.atLineStart || IsValidIdentPrecede(sc.chPrev))
992  					&& IsWordStartChar(sc.ch)) {
993  				len = LengthToNonWordChar(sc, lengthToEnd, s, sizeof(s));
994  				if (keywords.InList(s)) {
995  					sc.SetState(SCE_RAKU_WORD);		
996  				} else if(functions.InList(s)) {
997  					sc.SetState(SCE_RAKU_FUNCTION);	
998  				} else if(typesBasic.InList(s)) {
999  					sc.SetState(SCE_RAKU_TYPEDEF);	
1000  				} else if(typesComposite.InList(s)) {
1001  					sc.SetState(SCE_RAKU_TYPEDEF);	
1002  				} else if(typesDomainSpecific.InList(s)) {
1003  					sc.SetState(SCE_RAKU_TYPEDEF);	
1004  				} else if(typesExceptions.InList(s)) {
1005  					sc.SetState(SCE_RAKU_TYPEDEF);	
1006  				} else {
1007  					if (wordLast == "class")
1008  						sc.SetState(SCE_RAKU_CLASS);	
1009  					else if (wordLast == "grammar")
1010  						sc.SetState(SCE_RAKU_GRAMMAR);	
1011  					else
1012  						sc.SetState(SCE_RAKU_IDENTIFIER);	
1013  					identLast = s;						
1014  				}
1015  				if (adverbLast == "sym") {				
1016  					sc.SetState(SCE_RAKU_IDENTIFIER);	
1017  					identLast = s;						
1018  				}
1019  				if (sc.state != SCE_RAKU_IDENTIFIER)
1020  					wordLast = s;					
1021  				sc.Forward(len - 1);				
1022  			}
1023  			else if (sc.ch == ':' && IsWordStartChar(sc.chNext)) {
1024  				len = LengthToNonWordChar(sc, lengthToEnd, s, sizeof(s), 1);
1025  				if (adverbs.InList(s)) {
1026  					sc.SetState(SCE_RAKU_ADVERB);	
1027  					adverbLast = s;					
1028  					sc.Forward(len); 
1029  				}
1030  			}
1031  			else if (setSigil.Contains(sc.ch) && (setTwigil.Contains(sc.chNext)
1032  					|| setSpecialVar.Contains(sc.chNext)
1033  					|| IsWordStartChar(sc.chNext))) {
1034  				switch (sc.ch) {
1035  					case '$': sc.SetState(SCE_RAKU_MU);
1036  						break;
1037  					case '@': sc.SetState(SCE_RAKU_POSITIONAL);
1038  						break;
1039  					case '%': sc.SetState(SCE_RAKU_ASSOCIATIVE);
1040  						break;
1041  					case '&': sc.SetState(SCE_RAKU_CALLABLE);
1042  				}
1043  				const int state = sc.state;
1044  				sc.Forward();
1045  				char ch_delim = 0;
1046  				if (setSpecialVar.Contains(sc.ch)
1047  						&& !setWord.Contains(sc.chNext)) {	
1048  					ch_delim = -1;
1049  				} else if (setTwigil.Contains(sc.ch)) {		
1050  					sc.SetState(SCE_RAKU_OPERATOR);
1051  					if (sc.ch == '<' && setWord.Contains(sc.chNext))
1052  						ch_delim = '>';
1053  					sc.Forward();
1054  					sc.SetState(state);
1055  				}
1056  				if (ch_delim >= 0) {
1057  					sc.Forward(LengthToNonWordChar(sc, lengthToEnd, s, sizeof(s)) - 1);
1058  					if (ch_delim > 0 && sc.chNext == ch_delim) {
1059  						sc.Forward();
1060  						sc.SetState(SCE_RAKU_OPERATOR);
1061  					}
1062  					identLast = s;	
1063  				}
1064  			}
1065  			else if (IsOperatorChar(sc.ch)) {
1066  				sc.SetState(SCE_RAKU_OPERATOR);
1067  			}
1068  			else if (!hereDelim.empty() && sc.atLineEnd) {
1069  				if (IsANewLine(sc.ch))
1070  					sc.Forward(); 
1071  				sc.SetState(hereState);
1072  			}
1073  			if (sc.state == SCE_RAKU_OPERATOR && (sc.ch == ';' || sc.ch == '}')) {
1074  				wordLast.clear();
1075  				identLast.clear();
1076  				adverbLast.clear();
1077  			}
1078  		}
1079  		else if (sc.state == SCE_RAKU_COMMENTLINE && sc.chPrev == '#' && sc.ch == '`') {
1080  			if (IsBracketOpenChar(sc.chNext)) {
1081  				sc.Forward(); 
1082  				dpEmbeded.opener = sc.ch;
1083  				dpEmbeded.closer[0] = GetBracketCloseChar(dpEmbeded.opener);
1084  				if (dpEmbeded.closer[0] > 0) { 
1085  					dpEmbeded.count = GetRepeatCharCount(sc, dpEmbeded.opener, lengthToEnd);
1086  					sc.SetState(SCE_RAKU_COMMENTEMBED);
1087  					sc.Forward(dpEmbeded.count - 1); 
1088  				}
1089  			}
1090  		}
1091  	}
1092  	sc.Complete();
1093  }
1094  #define RAKU_HEADFOLD_SHIFT	4
1095  #define RAKU_HEADFOLD_MASK	0xF0
1096  void SCI_METHOD LexerRaku::Fold(Sci_PositionU startPos, Sci_Position length, int &bsol;* initStyle */, IDocument *pAccess) {
1097  	if (!options.fold) return;
1098  	LexAccessor styler(pAccess);
1099  	const Sci_PositionU endPos = startPos + length;
1100  	Sci_Position lineCurrent = styler.GetLine(startPos);
1101  	if (startPos > 0 && lineCurrent > 0) {
1102  		while (lineCurrent > 0 && styler.StyleAt(startPos) != SCE_RAKU_DEFAULT) {
1103  			lineCurrent--;
1104  			startPos = styler.LineStart(lineCurrent);
1105  		}
1106  		lineCurrent = styler.GetLine(startPos);
1107  	}
1108  	Sci_PositionU lineStart = startPos;
1109  	Sci_PositionU lineStartNext = styler.LineStart(lineCurrent + 1);
1110  	int levelPrev = SC_FOLDLEVELBASE;
1111  	if (lineCurrent > 0)
1112  		levelPrev = styler.LevelAt(lineCurrent - 1) >> 16;
1113  	int levelCurrent = levelPrev;
1114  	char chNext = styler[startPos];
1115  	int stylePrev = styler.StyleAt(startPos - 1);
1116  	int styleNext = styler.StyleAt(startPos);
1117  	int styleNextStartLine = styler.StyleAt(lineStartNext);
1118  	int visibleChars = 0;
1119  	bool wasCommentMulti = false;
1120  	for (Sci_PositionU i = startPos; i < endPos; i++) {
1121  		const char ch = chNext;
1122  		chNext = styler.SafeGetCharAt(i + 1);
1123  		const int style = styleNext;
1124  		styleNext = styler.StyleAt(i + 1);
1125  		const bool atEOL = i == (lineStartNext - 1);
1126  		const bool atLineStart = i == lineStart;
1127  		if (options.foldComment) {
1128  			if (options.foldCommentMultiline) {
1129  				if (style == SCE_RAKU_COMMENTLINE && atLineStart && ch == '#' && chNext == '`'
1130  						&& styleNextStartLine == SCE_RAKU_COMMENTEMBED) {
1131  					levelCurrent++;
1132  					wasCommentMulti = true; 
1133  				} else if (style == SCE_RAKU_COMMENTEMBED && atLineStart
1134  						&& styleNextStartLine != SCE_RAKU_COMMENTEMBED) {
1135  					levelCurrent--;
1136  				}
1137  			}
1138  			if (!wasCommentMulti && atEOL && stylePrev == SCE_RAKU_COMMENTLINE
1139  					&& IsCommentLine(lineCurrent, styler)) {
1140  				if (!IsCommentLine(lineCurrent - 1, styler)
1141  						&& IsCommentLine(lineCurrent + 1, styler))
1142  					levelCurrent++;
1143  				else if (IsCommentLine(lineCurrent - 1, styler)
1144  						&& !IsCommentLine(lineCurrent + 1, styler))
1145  					levelCurrent--;
1146  			}
1147  			if (options.foldCommentPOD && atLineStart && style == SCE_RAKU_POD) {
1148  				if (styler.Match(i, "=begin"))
1149  					levelCurrent++;
1150  				else if (styler.Match(i, "=end"))
1151  					levelCurrent--;
1152  			}
1153  		}
1154  		if (style == SCE_RAKU_OPERATOR) {
1155  			if (ch == '{') {
1156  				if (levelCurrent < levelPrev) levelPrev--;
1157  				levelCurrent++;
1158  			} else if (ch == '}') {
1159  				levelCurrent--;
1160  			}
1161  		}
1162  		if (atEOL) {
1163  			int level = levelPrev;
1164  			level |= levelCurrent << 16;
1165  			if (visibleChars == 0 && options.foldCompact)
1166  				level |= SC_FOLDLEVELWHITEFLAG;
1167  			if ((levelCurrent > levelPrev) && (visibleChars > 0))
1168  				level |= SC_FOLDLEVELHEADERFLAG;
1169  			if (level != styler.LevelAt(lineCurrent)) {
1170  				styler.SetLevel(lineCurrent, level);
1171  			}
1172  			lineCurrent++;
1173  			lineStart = lineStartNext;
1174  			lineStartNext = styler.LineStart(lineCurrent + 1);
1175  			styleNextStartLine = styler.StyleAt(lineStartNext);
1176  			levelPrev = levelCurrent;
1177  			visibleChars = 0;
1178  			wasCommentMulti = false;
1179  		}
1180  		if (!isspacechar(ch))
1181  			visibleChars++;
1182  		stylePrev = style;
1183  	}
1184  	int flagsNext = styler.LevelAt(lineCurrent) & ~SC_FOLDLEVELNUMBERMASK;
1185  	styler.SetLevel(lineCurrent, levelPrev | flagsNext);
1186  }
1187  LexerModule lmRaku(SCLEX_RAKU, LexerRaku::LexerFactoryRaku, "raku", rakuWordLists);
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexRaku.cxx</h3>
            <pre><code>1  #include <stdlib.h>
2  #include <string.h>
3  #include <stdio.h>
4  #include <stdarg.h>
5  #include <assert.h>
6  #include <ctype.h>
7  #include <string>
8  #include <string_view>
9  #include <vector>
10  #include <map>
11  #include <functional>
12  #include "ILexer.h"
13  #include "Scintilla.h"
14  #include "SciLexer.h"
15  #include "WordList.h"
16  #include "LexAccessor.h"
17  #include "StyleContext.h"
18  #include "CharacterSet.h"
19  #include "CharacterCategory.h"
20  #include "LexerModule.h"
21  #include "OptionSet.h"
22  #include "DefaultLexer.h"
23  using namespace Scintilla;
24  using namespace Lexilla;
25  namespace { 
26  #define RAKUNUM_BINARY		1	
27  #define RAKUNUM_OCTAL		2
28  #define RAKUNUM_FLOAT_EXP	3	
29  #define RAKUNUM_HEX			4	
30  #define RAKUNUM_DECIMAL		5	
31  #define RAKUNUM_VECTOR		6
32  #define RAKUNUM_V_VECTOR	7
33  #define RAKUNUM_VERSION		8	
34  #define RAKUNUM_BAD			9
35  #define RAKUTYPE_REGEX_NORM		0	
36  #define RAKUTYPE_REGEX_S		1	
37  #define RAKUTYPE_REGEX_M		2	
38  #define RAKUTYPE_REGEX_Y		3	
39  #define RAKUTYPE_REGEX			4	
40  #define RAKUTYPE_REGEX_RX		5	
41  #define RAKUTYPE_REGEX_TR		6	
42  #define RAKUTYPE_QLANG			7	
43  #define RAKUTYPE_STR_WQ			8	
44  #define RAKUTYPE_STR_Q			9	
45  #define RAKUTYPE_STR_QX			10	
46  #define RAKUTYPE_STR_QW			11	
47  #define RAKUTYPE_STR_QQ			12	
48  #define RAKUTYPE_STR_QQX		13	
49  #define RAKUTYPE_STR_QQW		14	
50  #define RAKUTYPE_STR_QQWW		15	
51  #define RAKUDELIM_BRACKET		0	
52  #define RAKUDELIM_QUOTE			1	
53  const char *const rakuWordLists[] = {
54  	"Keywords and identifiers",
55  	"Functions",
56  	"Types basic",
57  	"Types composite",
58  	"Types domain-specific",
59  	"Types exception",
60  	"Adverbs",
61  	nullptr,
62  };
63  struct OptionsRaku {
64  	bool fold;
65  	bool foldCompact;
66  	bool foldComment;
67  	bool foldCommentMultiline;
68  	bool foldCommentPOD;
69  	OptionsRaku() {
70  		fold					= true;
71  		foldCompact				= false;
72  		foldComment				= true;
73  		foldCommentMultiline	= true;
74  		foldCommentPOD			= true;
75  	}
76  };
77  struct OptionSetRaku : public OptionSet<OptionsRaku> {
78  	OptionSetRaku() {
79  		DefineProperty("fold",			&OptionsRaku::fold);
80  		DefineProperty("fold.comment",	&OptionsRaku::foldComment);
81  		DefineProperty("fold.compact",	&OptionsRaku::foldCompact);
82  		DefineProperty("fold.raku.comment.multiline",	&OptionsRaku::foldCommentMultiline,
83  			"Set this property to 0 to disable folding multi-line comments when fold.comment=1.");
84  		DefineProperty("fold.raku.comment.pod",			&OptionsRaku::foldCommentPOD,
85  			"Set this property to 0 to disable folding POD comments when fold.comment=1.");
86  		DefineWordListSets(rakuWordLists);
87  	}
88  };
89  struct DelimPair {
90  	int opener;		
91  	int closer[2];	
92  	bool interpol;	
93  	short count;	
94  	DelimPair() {
95  		opener = 0;
96  		closer[0] = 0;
97  		closer[1] = 0;
98  		interpol = false;
99  		count = 0;
100  	}
101  	bool isCloser(int ch) const {
102  		return ch == closer[0] || ch == closer[1];
103  	}
104  };
105  constexpr bool IsANewLine(int ch) noexcept {
106  	return ch == '\r' || ch == '\n';
107  }
108  bool IsAWhitespace(int ch) noexcept {
109  	return IsASpaceOrTab(ch) || IsANewLine(ch);
110  }
111  constexpr bool IsAlphabet(int ch) noexcept {
112  	return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z');
113  }
114  bool IsCommentLine(Sci_Position line, LexAccessor &styler, int type = SCE_RAKU_COMMENTLINE) {
115  	Sci_Position pos = styler.LineStart(line);
116  	Sci_Position eol_pos = styler.LineStart(line + 1) - 1;
117  	for (Sci_Position i = pos; i < eol_pos; i++) {
118  		char ch = styler[i];
119  		int style = styler.StyleAt(i);
120  		if (type == SCE_RAKU_COMMENTEMBED) {
121  			if (i == (eol_pos - 1) && style == type)
122  				return true;
123  		} else { 
124  			if (ch == '#' && style == type && styler[i+1] != '`' )
125  				return true;
126  			else if (!IsASpaceOrTab(ch))
127  				return false;
128  		}
129  	}
130  	return false;
131  }
132  bool ContainsQTo(Sci_Position start, Sci_Position end, LexAccessor &styler) {
133  	std::string adverb;
134  	for (Sci_Position i = start; i < end; i++) {
135  		if (styler.StyleAt(i) == SCE_RAKU_ADVERB) {
136  			adverb.push_back(styler[i]);
137  		}
138  	}
139  	return adverb.find(":to") != std::string::npos;
140  }
141  int GetBracketCloseChar(const int ch) noexcept {
142  	const CharacterCategory cc = CategoriseCharacter(ch);
143  	switch (cc) {
144  		case ccSm:
145  			switch (ch) {
146  				case 0x3C: return 0x3E; 
147  				case 0x2208: return 0x220B; 
148  				case 0x2209: return 0x220C; 
149  				case 0x220A: return 0x220D; 
150  				case 0x2215: return 0x29F5; 
151  				case 0x2243: return 0x22CD; 
152  				case 0x2298: return 0x29B8; 
153  				case 0x22A6: return 0x2ADE; 
154  				case 0x22A8: return 0x2AE4; 
155  				case 0x22A9: return 0x2AE3; 
156  				case 0x22AB: return 0x2AE5; 
157  				case 0x22F2: return 0x22FA; 
158  				case 0x22F3: return 0x22FB; 
159  				case 0x22F4: return 0x22FC; 
160  				case 0x22F6: return 0x22FD; 
161  				case 0x22F7: return 0x22FE; 
162  				case 0xFF1C: return 0xFF1E; 
163  			}
164  			break;
165  		case ccPs:
166  			switch (ch) {
167  				case 0x5B: return 0x5D; 
168  				case 0x7B: return 0x7D; 
169  				case 0x298D: return 0x2990; 
170  				case 0x298F: return 0x298E; 
171  				case 0xFF3B: return 0xFF3D; 
172  				case 0xFF5B: return 0xFF5D; 
173  			}
174  			break;
175  		case ccPi:
176  			break;
177  		default: return 0;
178  	}
179  	return ch + 1;
180  }
181  bool IsValidQuoteOpener(const int ch, DelimPair &dp, int type = RAKUDELIM_BRACKET) noexcept {
182  	dp.closer[0] = 0;
183  	dp.closer[1] = 0;
184  	dp.interpol = true;
185  	if (type == RAKUDELIM_QUOTE) {
186  		switch (ch) {
187  			case '\'':		dp.closer[0] = '\'';	
188  				dp.interpol = false;
189  				break;
190  			case '"':		dp.closer[0] = '"';		
191  				break;
192  			case 0x2018:	dp.closer[0] = 0x2019;	
193  				dp.interpol = false;
194  				break;
195  			case 0x201C:	dp.closer[0] = 0x201D;	
196  				break;
197  			case 0x201D:	dp.closer[0] = 0x201C;	
198  				break;
199  			case 0x201E:	dp.closer[0] = 0x201C;	
200  							dp.closer[1] = 0x201D;
201  				break;
202  			case 0xFF62:	dp.closer[0] = 0xFF63;	
203  				dp.interpol = false;
204  				break;
205  			default:		return false;
206  		}
207  	} else if (type == RAKUDELIM_BRACKET) {
208  		dp.closer[0] = GetBracketCloseChar(ch);
209  	}
210  	dp.opener = ch;
211  	dp.count = 1;
212  	return dp.closer[0] > 0;
213  }
214  bool IsBracketOpenChar(int ch) noexcept {
215  	return GetBracketCloseChar(ch) > 0;
216  }
217  bool IsValidRegOrQAdjacent(int ch) noexcept {
218  	return !(IsAlphaNumeric(ch) || ch == '_' || ch == '(' || ch == ')' || ch == '\'' );
219  }
220  bool IsValidRegOrQPrecede(int ch) noexcept {
221  	return !(IsAlphaNumeric(ch) || ch == '_');
222  }
223  bool MatchCharInRange(StyleContext &sc, const Sci_Position length,
224  		const int match, bool ignoreDelim = false) {
225  	Sci_Position len = 0;
226  	int chPrev = sc.chPrev;
227  	while (++len < length) {
228  		const int ch = sc.GetRelativeCharacter(len);
229  		if (ch == match && (ignoreDelim || chPrev != '\\'))
230  			return true;
231  	}
232  	return false;
233  }
234  int PrevNonWhitespaceChar(StyleContext &sc) {
235  	Sci_Position rel = 0;
236  	Sci_Position max_back = 0 - sc.currentPos;
237  	while (--rel > max_back) {
238  		const int ch = sc.GetRelativeCharacter(rel);
239  		if (!IsAWhitespace(ch))
240  			return ch;
241  	}
242  	return 0; 
243  }
244  bool IsQLangStartAtScPos(StyleContext &sc, int &type, const Sci_Position length) {
245  	const bool valid_adj = IsValidRegOrQAdjacent(sc.chNext);
246  	const int chFw2 = sc.GetRelativeCharacter(2);
247  	const int chFw3 = sc.GetRelativeCharacter(3);
248  	type = -1;
249  	if (IsValidRegOrQPrecede(sc.chPrev)) {
250  		if (sc.ch == 'Q' && valid_adj) {
251  			type = RAKUTYPE_QLANG;
252  		} else if (sc.ch == 'q') {
253  			switch (sc.chNext) {
254  				case 'x':
255  					type = RAKUTYPE_STR_QX;
256  					break;
257  				case 'w':
258  					type = RAKUTYPE_STR_QW;
259  					break;
260  				case 'q':
261  					if (chFw2 == 'x') {
262  						type = RAKUTYPE_STR_QQX;
263  					} else if (chFw2 == 'w') {
264  						if (chFw3 == 'w') {
265  							type = RAKUTYPE_STR_QQWW;
266  						} else {
267  							type = RAKUTYPE_STR_QQW;
268  						}
269  					} else {
270  						type = RAKUTYPE_STR_QQ;
271  					}
272  					break;
273  				default:
274  					type = RAKUTYPE_STR_Q;
275  			}
276  		} else if (sc.ch == '<' && MatchCharInRange(sc, length, '>')) {
277  			type = RAKUTYPE_STR_WQ; 
278  		}
279  	}
280  	return type >= 0;
281  }
282  bool IsRegexStartAtScPos(StyleContext &sc, int &type, CharacterSet &set) {
283  	const bool valid_adj = IsValidRegOrQAdjacent(sc.chNext);
284  	type = -1;
285  	if (IsValidRegOrQPrecede(sc.chPrev)) {
286  		switch (sc.ch) {
287  			case 'r':
288  				if (sc.chNext == 'x')
289  					type = RAKUTYPE_REGEX_RX;
290  				break;
291  			case 't':
292  			case 'T':
293  				if (sc.chNext == 'r' || sc.chNext == 'R')
294  					type = RAKUTYPE_REGEX_TR;
295  				break;
296  			case 'm':
297  				if (valid_adj)
298  					type = RAKUTYPE_REGEX_M;
299  				break;
300  			case 's':
301  			case 'S':
302  				if (valid_adj)
303  					type = RAKUTYPE_REGEX_S;
304  				break;
305  			case 'y':
306  				if (valid_adj)
307  					type = RAKUTYPE_REGEX_Y;
308  				break;
309  			case '/':
310  				if (set.Contains(PrevNonWhitespaceChar(sc)))
311  					type = RAKUTYPE_REGEX_NORM;
312  		}
313  	}
314  	return type >= 0;
315  }
316  bool IsValidIdentPrecede(int ch) noexcept {
317  	return !(IsAlphaNumeric(ch) || ch == '_' || ch == '@' || ch == '$' || ch == '%');
318  }
319  bool IsValidDelimiter(int ch) noexcept {
320  	return !(IsAlphaNumeric(ch) || ch == ':');
321  }
322  int GetDelimiterCloseChar(int ch) noexcept {
323  	int ch_end = GetBracketCloseChar(ch);
324  	if (ch_end == 0 && IsValidDelimiter(ch)) {
325  		ch_end = ch;
326  	}
327  	return ch_end;
328  }
329  Sci_Position GetRepeatCharCount(StyleContext &sc, int chMatch, Sci_Position length) {
330  	Sci_Position cnt = 0;
331  	while (cnt < length) {
332  		if (sc.GetRelativeCharacter(cnt) != chMatch) {
333  			break;
334  		}
335  		cnt++;
336  	}
337  	return cnt;
338  }
339  Sci_Position LengthToDelimiter(StyleContext &sc, const DelimPair &dp,
340  		Sci_Position length, bool noTrailing = false) {
341  	short cnt_open = 0;			
342  	short cnt_close = 0;		
343  	bool is_escape = false;		
344  	Sci_Position len = 0;		
345  	int chOpener = dp.opener;	
346  	if (dp.opener == dp.closer[0])
347  		chOpener = 0;			
348  	while (len < length) {
349  		const int chPrev = sc.GetRelativeCharacter(len - 1);
350  		const int ch = sc.GetRelativeCharacter(len);
351  		const int chNext = sc.GetRelativeCharacter(len+1);
352  		if (cnt_open == 0 && cnt_close == dp.count) {
353  			return len;				
354  		} else if (is_escape) {
355  			is_escape = false;
356  		} else if (ch == '\\') {
357  			is_escape = true;
358  		} else {
359  			if (ch == chOpener) {
360  				cnt_open++;			
361  			} else if (dp.isCloser(ch)) {
362  				if ( cnt_open > 0 ) {
363  					cnt_open--;		
364  				} else if (dp.count > 1 && cnt_close < (dp.count - 1)) {
365  					if (cnt_close > 1) {
366  						if (dp.isCloser(chPrev)) {
367  							cnt_close++;
368  						} else {	
369  							cnt_close = 0;
370  						}
371  					} else {
372  						cnt_close++;
373  					}
374  				} else if (!noTrailing || (IsAWhitespace(chNext))) {
375  					cnt_close++;		
376  					if (cnt_close > 1 && !dp.isCloser(chPrev)) {
377  						cnt_close = 0;	
378  					}
379  				} else {
380  					cnt_close = 0;		
381  				}
382  			} else if (IsANewLine(ch)) {
383  				cnt_open = 0;			
384  				cnt_close = 0;
385  			}
386  		}
387  		len++;
388  	}
389  	return -1; 
390  }
391  Sci_Position LengthToEndHeredoc(const StyleContext &sc, LexAccessor &styler,
392  		const Sci_Position length, const char *delim) {
393  	bool on_new_ln = false;
394  	int i = 0; 
395  	for (int n = 0; n < length; n++) {
396  		const char ch = styler.SafeGetCharAt(sc.currentPos + n, 0);
397  		if (on_new_ln) {
398  			if (delim[i] == '\0')
399  				return n;	
400  			if (ch != delim[i++])
401  				i = 0;		
402  		}
403  		if (i == 0)			
404  			on_new_ln = IsANewLine(ch);
405  	}
406  	return -1;				
407  }
408  Sci_Position LengthToNextChar(StyleContext &sc, const Sci_Position length) {
409  	Sci_Position len = 0;
410  	while (++len < length) {
411  		const int ch = sc.GetRelativeCharacter(len);
412  		if (!IsASpaceOrTab(ch) && !IsANewLine(ch)) {
413  			break;
414  		}
415  	}
416  	return len;
417  }
418  void GetRelativeString(StyleContext &sc, Sci_Position offset, Sci_Position length,
419  		std::string &str) {
420  	Sci_Position pos = offset;
421  	str.clear();
422  	while (pos < length) {
423  		str += sc.GetRelativeCharacter(pos++);
424  	}
425  }
426  } 
427  class LexerRaku : public DefaultLexer {
428  	CharacterSet setWord;
429  	CharacterSet setSigil;
430  	CharacterSet setTwigil;
431  	CharacterSet setOperator;
432  	CharacterSet setSpecialVar;
433  	WordList regexIdent;			
434  	OptionsRaku options;			
435  	OptionSetRaku osRaku;
436  	WordList keywords;				
437  	WordList functions;
438  	WordList typesBasic;
439  	WordList typesComposite;
<span onclick='openModal()' class='match'>440  	WordList typesDomainSpecific;
441  	WordList typesExceptions;
442  	WordList adverbs;
443  public:
444  	explicit LexerRaku() :
445  		DefaultLexer("raku", SCLEX_RAKU),
</span>446  		setWord(CharacterSet::setAlphaNum, "-_", 0x80),
447  		setSigil(CharacterSet::setNone, "$&%@"),
448  		setTwigil(CharacterSet::setNone, "!*.:<=?^~"),
449  		setOperator(CharacterSet::setNone, "^&\\()-+=|{}[]:;<>,?!.~"),
450  		setSpecialVar(CharacterSet::setNone, "_/!") {
451  		regexIdent.Set("regex rule token");
452  	}
453  	LexerRaku(const LexerRaku &) = delete;
454  	LexerRaku(LexerRaku &&) = delete;
455  	void operator=(const LexerRaku &) = delete;
456  	void operator=(LexerRaku &&) = delete;
457  	virtual ~LexerRaku() {
458  	}
459  	void SCI_METHOD Release() noexcept override {
460  		delete this;
461  	}
462  	int SCI_METHOD Version() const noexcept override {
463  		return lvRelease5;
464  	}
465  	const char *SCI_METHOD PropertyNames() override {
466  		return osRaku.PropertyNames();
467  	}
468  	int SCI_METHOD PropertyType(const char *name) override {
469  		return osRaku.PropertyType(name);
470  	}
471  	const char *SCI_METHOD DescribeProperty(const char *name) override {
472  		return osRaku.DescribeProperty(name);
473  	}
474  	Sci_Position SCI_METHOD PropertySet(const char *key, const char *val) override;
475  	const char *SCI_METHOD PropertyGet(const char *key) override {
476  		return osRaku.PropertyGet(key);
477  	}
478  	const char *SCI_METHOD DescribeWordListSets() override {
479  		return osRaku.DescribeWordListSets();
480  	}
481  	Sci_Position SCI_METHOD WordListSet(int n, const char *wl) override;
482  	void SCI_METHOD Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) override;
483  	void SCI_METHOD Fold(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) override;
484  	static ILexer5 *LexerFactoryRaku() {
485  		return new LexerRaku();
486  	}
487  protected:
488  	bool IsOperatorChar(const int ch);
489  	bool IsWordChar(const int ch, bool allowNumber = true);
490  	bool IsWordStartChar(const int ch);
491  	bool IsNumberChar(const int ch, int base = 10);
492  	bool ProcessRegexTwinCapture(StyleContext &sc, const Sci_Position length,
493  		int &type, const DelimPair &dp);
494  	void ProcessStringVars(StyleContext &sc, const Sci_Position length, const int varState);
495  	bool ProcessValidRegQlangStart(StyleContext &sc, Sci_Position length, const int type,
496  		WordList &wordsAdverbs, DelimPair &dp);
497  	Sci_Position LengthToNonWordChar(StyleContext &sc, Sci_Position length,
498  		char *s, const int size, Sci_Position offset = 0);
499  };
500  bool LexerRaku::IsOperatorChar(const int ch) {
501  	if (ch > 0x7F) {
502  		switch (ch) {
503  			case 0x2208:	
504  			case 0x2209:	
505  			case 0x220B:	
506  			case 0x220C:	
507  			case 0x2216:	
508  			case 0x2229:	
509  			case 0x222A:	
510  			case 0x2282:	
511  			case 0x2283:	
512  			case 0x2284:	
513  			case 0x2285:	
514  			case 0x2286:	
515  			case 0x2287:	
516  			case 0x2288:	
517  			case 0x2289:	
518  			case 0x228D:	
519  			case 0x228E:	
520  			case 0x2296:	
521  				return true;
522  		}
523  	}
524  	return setOperator.Contains(ch);
525  }
526  bool LexerRaku::IsWordChar(const int ch, bool allowNumber) {
527  	if (ch > 0x7F) {
528  		const CharacterCategory cc = CategoriseCharacter(ch);
529  		switch (cc) {
530  			case ccLu:
531  			case ccLl:
532  			case ccLt:
533  			case ccLm:
534  			case ccLo:
535  				return true;
536  			default:
537  				return false;
538  		}
539  	} else if (allowNumber && IsADigit(ch)) {
540  		return true; 
541  	}
542  	return setWord.Contains(ch);
543  }
544  bool LexerRaku::IsWordStartChar(const int ch) {
545  	return ch != '-' && IsWordChar(ch, false); 
546  }
547  bool LexerRaku::IsNumberChar(const int ch, int base) {
548  	if (ch > 0x7F) {
549  		const CharacterCategory cc = CategoriseCharacter(ch);
550  		switch (cc) {
551  			case ccNd:
552  			case ccNl:
553  			case ccNo:
554  				return true;
555  			default:
556  				return false;
557  		}
558  	}
559  	return IsADigit(ch, base);
560  }
561  Sci_Position SCI_METHOD LexerRaku::PropertySet(const char *key, const char *val) {
562  	if (osRaku.PropertySet(&options, key, val))
563  		return 0;
564  	return -1;
565  }
566  Sci_Position SCI_METHOD LexerRaku::WordListSet(int n, const char *wl) {
567  	WordList *wordListN = nullptr;
568  	switch (n) {
569  		case 0:
570  			wordListN = &keywords;
571  			break;
572  		case 1:
573  			wordListN = &functions;
574  			break;
575  		case 2:
576  			wordListN = &typesBasic;
577  			break;
578  		case 3:
579  			wordListN = &typesComposite;
580  			break;
581  		case 4:
582  			wordListN = &typesDomainSpecific;
583  			break;
584  		case 5:
585  			wordListN = &typesExceptions;
586  			break;
587  		case 6:
588  			wordListN = &adverbs;
589  			break;
590  	}
591  	Sci_Position firstModification = -1;
592  	if (wordListN) {
593  		WordList wlNew;
594  		wlNew.Set(wl);
595  		if (*wordListN != wlNew) {
596  			wordListN->Set(wl);
597  			firstModification = 0;
598  		}
599  	}
600  	return firstModification;
601  }
602  bool LexerRaku::ProcessRegexTwinCapture(StyleContext &sc, const Sci_Position length,
603  		int &type, const DelimPair &dp) {
604  	if (type == RAKUTYPE_REGEX_S || type == RAKUTYPE_REGEX_TR || type == RAKUTYPE_REGEX_Y) {
605  		type = -1; 
606  		if (dp.isCloser(sc.chPrev))
607  			sc.Forward();
608  		if (dp.isCloser(dp.opener))
609  			return true;
610  		const Sci_Position len = LengthToNextChar(sc, length);
611  		if (sc.GetRelativeCharacter(len) == dp.opener) {
612  			sc.Forward(len);
613  			return true;
614  		}
615  	}
616  	return false;
617  }
618  void LexerRaku::ProcessStringVars(StyleContext &sc, const Sci_Position length, const int varState) {
619  	const int state = sc.state;
620  	for (Sci_Position pos = 0; pos < length; pos++) {
621  		if (sc.state == varState && !IsWordChar(sc.ch)) {
622  			sc.SetState(state);
623  		} else if (sc.chPrev != '\\'
624  				&& (sc.ch == '$' || sc.ch == '@')
625  				&& IsWordStartChar(sc.chNext)) {
626  			sc.SetState(varState);
627  		}
628  		sc.Forward(); 
629  	}
630  }
631  bool LexerRaku::ProcessValidRegQlangStart(StyleContext &sc, Sci_Position length, const int type,
632  		WordList &wordsAdverbs, DelimPair &dp) {
633  	Sci_Position startPos = sc.currentPos;
634  	Sci_Position startLen = length;
635  	const int target_state = sc.state;
636  	int state = SCE_RAKU_DEFAULT;
637  	std::string str;
638  	dp.opener = 0;					
639  	bool got_all_adverbs = false;	
640  	bool got_ident = false;			
641  	sc.SetState(state);				
642  	while ((dp.opener == 0 || !got_all_adverbs) && sc.More()) {
643  		const bool was_space = IsAWhitespace(sc.ch);
644  		if (!got_all_adverbs && was_space) {
645  			sc.Forward(LengthToNextChar(sc, length));
646  		}
647  		length = startLen - (sc.currentPos - startPos); 
648  		if (dp.opener == 0 && !got_ident && type == RAKUTYPE_REGEX && IsAlphabet(sc.ch)) {
649  			bool got_sym = false;
650  			while (sc.More()) {
651  				sc.SetState(SCE_RAKU_IDENTIFIER);
652  				while (sc.More() && (IsAlphaNumeric(sc.chNext)
653  						|| sc.chNext == '_' || sc.chNext == '-')) {
654  					sc.Forward();
655  				}
656  				sc.Forward();
657  				if (got_sym && sc.ch == '>') {
658  					sc.SetState(SCE_RAKU_OPERATOR);	
659  					sc.Forward();
660  					break;
661  				} else if (type == RAKUTYPE_REGEX && sc.Match(":sym<")) {
662  					sc.SetState(SCE_RAKU_ADVERB);	
663  					sc.Forward(4);
664  					sc.SetState(SCE_RAKU_OPERATOR);	
665  					sc.Forward();
666  					got_sym = true;
667  				} else {
668  					break;
669  				}
670  			}
671  			sc.SetState(state);
672  			got_ident = true;
673  		}
674  		else if (!got_all_adverbs && sc.ch == ':' && (!(dp.opener == 0 && got_ident)
675  				&& !(dp.opener > 0 && type >= RAKUTYPE_QLANG))) {
676  			sc.SetState(SCE_RAKU_ADVERB);
677  			while (IsAlphaNumeric(sc.chNext) && sc.More()) {
678  				sc.Forward();
679  				str += sc.ch;
680  			}
681  			str += ' ';
682  			sc.Forward();
683  			sc.SetState(state);
684  		}
685  		else if (dp.opener == 0 && (was_space || IsValidRegOrQAdjacent(sc.ch))
686  				&& IsValidDelimiter(sc.ch)) {	
687  			sc.SetState((state = target_state));
688  			dp.opener = sc.ch;					
689  			if (type < RAKUTYPE_QLANG)			
690  				dp.count = 1;					
691  			else
692  				dp.count = GetRepeatCharCount(sc, dp.opener, length);
693  			sc.Forward(dp.count);
694  		}
695  		else {
696  			if (got_all_adverbs)
697  				break; 
698  			got_all_adverbs = true;
699  		}
700  	}
701  	wordsAdverbs.Set(str.c_str());
702  	dp.closer[0] = GetDelimiterCloseChar(dp.opener);
703  	dp.closer[1] = 0; 
704  	return dp.closer[0] > 0;
705  }
706  Sci_Position LexerRaku::LengthToNonWordChar(StyleContext &sc, Sci_Position length,
707  		char *s, const int size, Sci_Position offset) {
708  	Sci_Position len = 0;
709  	Sci_Position max_length = size < length ? size : length;
710  	while (len <= max_length) {
711  		const int ch = sc.GetRelativeCharacter(len + offset);
712  		if (!IsWordChar(ch)) {
713  			s[len] = '\0';
714  			break;
715  		}
716  		s[len] = ch;
717  		len++;
718  	}
719  	s[len + 1] = '\0';
720  	return len;
721  }
722  void SCI_METHOD LexerRaku::Lex(Sci_PositionU startPos, Sci_Position length, int initStyle, IDocument *pAccess) {
723  	LexAccessor styler(pAccess);
724  	DelimPair dpEmbeded;			
725  	DelimPair dpString;				
726  	DelimPair dpRegQ;				
727  	std::string hereDelim;			
728  	int hereState = 0;				
729  	int numState = 0;				
730  	short cntDecimal = 0;			
731  	std::string wordLast;			
732  	std::string identLast;			
733  	std::string adverbLast;			
734  	WordList lastAdverbs;			
735  	Sci_Position len;				
736  	char s[100];					
737  	int typeDetect = -1;			
738  	Sci_Position lengthToEnd;		
739  	Sci_PositionU newStartPos = startPos;
740  	if (initStyle != SCE_RAKU_DEFAULT) {
741  		while (newStartPos > 0) {
742  			newStartPos--;
743  			if (styler.StyleAt(newStartPos) == SCE_RAKU_DEFAULT)
744  				break;
745  		}
746  		if (initStyle == SCE_RAKU_HEREDOC_Q || initStyle == SCE_RAKU_HEREDOC_QQ) {
747  			if (newStartPos > 0) {
748  				newStartPos = styler.LineStart(styler.GetLine(newStartPos));
749  			}
750  		}
751  	} else {
752  		const Sci_Position line = styler.GetLine(newStartPos);
753  		if (line > 0) {
754  			const Sci_Position startPreviousLine = styler.LineStart(line-1);
755  			if (ContainsQTo(startPreviousLine, newStartPos, styler)) {
756  				newStartPos = startPreviousLine;
757  			}
758  		}
759  	}
760  	if (newStartPos < startPos) {
761  		initStyle = SCE_RAKU_DEFAULT;
762  		length += startPos - newStartPos;
763  		startPos = newStartPos;
764  	}
765  	StyleContext sc(startPos, length, initStyle, styler);
766  	for (; sc.More(); sc.Forward()) {
767  		lengthToEnd = (length - (sc.currentPos - startPos)); 
768  		switch (sc.state) {
769  			case SCE_RAKU_OPERATOR:
770  				sc.SetState(SCE_RAKU_DEFAULT);
771  				break; 
772  			case SCE_RAKU_COMMENTLINE:
773  				if (IsANewLine(sc.ch)) {
774  					sc.SetState(SCE_RAKU_DEFAULT);
775  				}
776  				break;
777  			case SCE_RAKU_COMMENTEMBED:
778  				if ((len = LengthToDelimiter(sc, dpEmbeded, lengthToEnd)) >= 0) {
779  					sc.Forward(len);			
780  					sc.SetState(SCE_RAKU_DEFAULT);
781  				} else {
782  					sc.Forward(lengthToEnd);	
783  				}
784  				break;
785  			case SCE_RAKU_POD:
786  				if (sc.atLineStart && sc.Match("=end pod")) {
787  					sc.Forward(8);
788  					sc.SetState(SCE_RAKU_DEFAULT);
789  				}
790  				break;
791  			case SCE_RAKU_STRING:
792  				if ((len = LengthToDelimiter(sc, dpString, lengthToEnd)) >= 0) {
793  					if (dpString.interpol) {
794  						ProcessStringVars(sc, len, SCE_RAKU_STRING_VAR);
795  					} else {
796  						sc.Forward(len);
797  					}
798  					sc.SetState(SCE_RAKU_DEFAULT);
799  				} else {
800  					sc.Forward(lengthToEnd);	
801  				}
802  				break;
803  			case SCE_RAKU_STRING_Q:
804  			case SCE_RAKU_STRING_QQ:
805  			case SCE_RAKU_STRING_Q_LANG:
806  				if (dpRegQ.count == 1 && dpRegQ.isCloser(sc.chPrev)) {
807  					sc.SetState(SCE_RAKU_DEFAULT);
808  				}
809  				else if ((len = LengthToDelimiter(sc, dpRegQ, lengthToEnd)) >= 0) {
810  					if (lastAdverbs.InList("to")) {
811  						GetRelativeString(sc, -1, len - dpRegQ.count, hereDelim);
812  						hereState = SCE_RAKU_HEREDOC_Q; 
813  					}
814  					if (sc.state == SCE_RAKU_STRING_QQ || lastAdverbs.InList("qq")) {
815  						ProcessStringVars(sc, len, SCE_RAKU_STRING_VAR);
816  						hereState = SCE_RAKU_HEREDOC_QQ; 
817  					} else {
818  						sc.Forward(len);
819  					}
820  					sc.SetState(SCE_RAKU_DEFAULT);
821  				} else {
822  					sc.Forward(lengthToEnd);	
823  				}
824  				break;
825  			case SCE_RAKU_HEREDOC_Q:
826  			case SCE_RAKU_HEREDOC_QQ:
827  				if ((len = LengthToEndHeredoc(sc, styler, lengthToEnd, hereDelim.c_str())) >= 0) {
828  					if (sc.state == SCE_RAKU_HEREDOC_QQ) {
829  						ProcessStringVars(sc, len, SCE_RAKU_STRING_VAR);
830  					} else {
831  						sc.Forward(len);
832  					}
833  					sc.SetState(SCE_RAKU_DEFAULT);
834  				} else {
835  					sc.Forward(lengthToEnd);	
836  				}
837  				hereDelim.clear();				
838  				break;
839  			case SCE_RAKU_REGEX:
840  				while (sc.state == SCE_RAKU_REGEX) {
841  					if (dpRegQ.count == 1 && dpRegQ.isCloser(sc.chPrev)) {
842  						if (ProcessRegexTwinCapture(sc, lengthToEnd, typeDetect, dpRegQ))
843  							continue;
844  						sc.SetState(SCE_RAKU_DEFAULT);
845  						break;
846  					}
847  					else if ((len = LengthToDelimiter(sc, dpRegQ, lengthToEnd)) >= 0) {
848  						ProcessStringVars(sc, len, SCE_RAKU_REGEX_VAR);
849  						if (ProcessRegexTwinCapture(sc, lengthToEnd, typeDetect, dpRegQ))
850  							continue;
851  						sc.SetState(SCE_RAKU_DEFAULT);
852  						break;
853  					} else {
854  						sc.Forward(lengthToEnd); 
855  						break;
856  					}
857  				}
858  				break;
859  			case SCE_RAKU_NUMBER:
860  				if (sc.ch == '.') {
861  					if (sc.chNext == '.') {		
862  						sc.SetState(SCE_RAKU_OPERATOR);
863  						sc.Forward();
864  						if (sc.chNext == '.')	
865  							sc.Forward();
866  						break;
867  					} else if (numState > RAKUNUM_FLOAT_EXP
868  							&& (cntDecimal < 1 || numState == RAKUNUM_VERSION)) {
869  						cntDecimal++;
870  						sc.Forward();
871  					} else {
872  						sc.SetState(SCE_RAKU_DEFAULT);
873  						break; 
874  					}
875  				}
876  				switch (numState) {
877  					case RAKUNUM_BINARY:
878  						if (!IsNumberChar(sc.ch, 2))
879  							sc.SetState(SCE_RAKU_DEFAULT);
880  						break;
881  					case RAKUNUM_OCTAL:
882  						if (!IsNumberChar(sc.ch, 8))
883  							sc.SetState(SCE_RAKU_DEFAULT);
884  						break;
885  					case RAKUNUM_HEX:
886  						if (!IsNumberChar(sc.ch, 16))
887  							sc.SetState(SCE_RAKU_DEFAULT);
888  						break;
889  					case RAKUNUM_DECIMAL:
890  					case RAKUNUM_VERSION:
891  						if (!IsNumberChar(sc.ch))
892  							sc.SetState(SCE_RAKU_DEFAULT);
893  				}
894  				break;
895  			case SCE_RAKU_WORD:
896  			case SCE_RAKU_FUNCTION:
897  			case SCE_RAKU_TYPEDEF:
898  			case SCE_RAKU_ADVERB:
899  				sc.SetState(SCE_RAKU_DEFAULT);
900  				break;
901  			case SCE_RAKU_MU:
902  			case SCE_RAKU_POSITIONAL:
903  			case SCE_RAKU_ASSOCIATIVE:
904  			case SCE_RAKU_CALLABLE:
905  			case SCE_RAKU_IDENTIFIER:
906  			case SCE_RAKU_GRAMMAR:
907  			case SCE_RAKU_CLASS:
908  				sc.SetState(SCE_RAKU_DEFAULT);
909  				break;
910  		}
911  		if (sc.state == SCE_RAKU_DEFAULT) {
912  			if (sc.ch == '#') {
913  				sc.SetState(SCE_RAKU_COMMENTLINE);
914  			}
915  			else if (sc.atLineStart && sc.Match("=begin pod")) {
916  				sc.SetState(SCE_RAKU_POD);
917  				sc.Forward(10);
918  			}
919  			else if (sc.chPrev != '\\' && (IsValidQuoteOpener(sc.ch, dpString, RAKUDELIM_QUOTE))) {
920  				sc.SetState(SCE_RAKU_STRING);
921  			}
922  			else if (IsQLangStartAtScPos(sc, typeDetect, lengthToEnd)) {
923  				int state = SCE_RAKU_STRING_Q_LANG;
924  				Sci_Position forward = 1;	
925  				if (typeDetect > RAKUTYPE_QLANG) {
926  					state = SCE_RAKU_STRING_Q;
927  					if (typeDetect == RAKUTYPE_STR_WQ)
928  						forward = 0;		
929  				}
930  				if (typeDetect > RAKUTYPE_STR_Q) {
931  					if (typeDetect == RAKUTYPE_STR_QQ)
932  						state = SCE_RAKU_STRING_QQ;
933  					forward++;				
934  				}
935  				if (typeDetect > RAKUTYPE_STR_QQ)
936  					forward++;				
937  				if (typeDetect == RAKUTYPE_STR_QQWW)
938  					forward++;				
939  				if (IsValidRegOrQAdjacent(sc.GetRelative(forward)) || typeDetect == RAKUTYPE_QLANG) {
940  					sc.SetState(state);
941  					sc.Forward(forward);
942  					lastAdverbs.Clear();
943  					if (ProcessValidRegQlangStart(sc, lengthToEnd, typeDetect,
944  							lastAdverbs, dpRegQ))
945  						sc.SetState(state);
946  				}
947  			}
948  			else if ((IsRegexStartAtScPos(sc, typeDetect, setOperator) || regexIdent.InList(wordLast.c_str()))) {
949  				if (typeDetect == -1) { 
950  					wordLast.clear();
951  					typeDetect = RAKUTYPE_REGEX;
952  				}
953  				Sci_Position forward = 0;	
954  				if (typeDetect > 0 && typeDetect != RAKUTYPE_REGEX)
955  					forward++;				
956  				if (typeDetect > RAKUTYPE_REGEX)
957  					forward++;				
958  				if (IsValidRegOrQAdjacent(sc.GetRelative(forward)) || typeDetect == RAKUTYPE_REGEX_NORM) {
959  					sc.SetState(SCE_RAKU_REGEX);
960  					sc.Forward(forward);
961  					lastAdverbs.Clear();
962  					if (ProcessValidRegQlangStart(sc, lengthToEnd, typeDetect,
963  							lastAdverbs, dpRegQ))
964  						sc.SetState(SCE_RAKU_REGEX);
965  				}
966  			}
967  			else if (IsValidIdentPrecede(sc.chPrev) && (IsNumberChar(sc.ch)
968  					|| (sc.ch == 'v' && IsNumberChar(sc.chNext) && wordLast == "use"))) {
969  				numState = RAKUNUM_DECIMAL;	
970  				cntDecimal = 0;
971  				sc.SetState(SCE_RAKU_NUMBER);
972  				if (sc.ch == 'v')			
973  					sc.Forward();
974  				if (wordLast == "use") {	
975  					numState = RAKUNUM_VERSION;
976  				} else if (sc.ch == '0') {	
977  					switch (sc.chNext) {
978  						case 'b':	
979  							numState = RAKUNUM_BINARY;
980  							break;
981  						case 'o':	
982  							numState = RAKUNUM_OCTAL;
983  							break;
984  						case 'x':	
985  							numState = RAKUNUM_HEX;
986  					}
987  					if (numState != RAKUNUM_DECIMAL)
988  						sc.Forward();		
989  				}
990  			}
991  			else if ((sc.currentPos == 0 || sc.atLineStart || IsValidIdentPrecede(sc.chPrev))
992  					&& IsWordStartChar(sc.ch)) {
993  				len = LengthToNonWordChar(sc, lengthToEnd, s, sizeof(s));
994  				if (keywords.InList(s)) {
995  					sc.SetState(SCE_RAKU_WORD);		
996  				} else if(functions.InList(s)) {
997  					sc.SetState(SCE_RAKU_FUNCTION);	
998  				} else if(typesBasic.InList(s)) {
999  					sc.SetState(SCE_RAKU_TYPEDEF);	
1000  				} else if(typesComposite.InList(s)) {
1001  					sc.SetState(SCE_RAKU_TYPEDEF);	
1002  				} else if(typesDomainSpecific.InList(s)) {
1003  					sc.SetState(SCE_RAKU_TYPEDEF);	
1004  				} else if(typesExceptions.InList(s)) {
1005  					sc.SetState(SCE_RAKU_TYPEDEF);	
1006  				} else {
1007  					if (wordLast == "class")
1008  						sc.SetState(SCE_RAKU_CLASS);	
1009  					else if (wordLast == "grammar")
1010  						sc.SetState(SCE_RAKU_GRAMMAR);	
1011  					else
1012  						sc.SetState(SCE_RAKU_IDENTIFIER);	
1013  					identLast = s;						
1014  				}
1015  				if (adverbLast == "sym") {				
1016  					sc.SetState(SCE_RAKU_IDENTIFIER);	
1017  					identLast = s;						
1018  				}
1019  				if (sc.state != SCE_RAKU_IDENTIFIER)
1020  					wordLast = s;					
1021  				sc.Forward(len - 1);				
1022  			}
1023  			else if (sc.ch == ':' && IsWordStartChar(sc.chNext)) {
1024  				len = LengthToNonWordChar(sc, lengthToEnd, s, sizeof(s), 1);
1025  				if (adverbs.InList(s)) {
1026  					sc.SetState(SCE_RAKU_ADVERB);	
1027  					adverbLast = s;					
1028  					sc.Forward(len); 
1029  				}
1030  			}
1031  			else if (setSigil.Contains(sc.ch) && (setTwigil.Contains(sc.chNext)
1032  					|| setSpecialVar.Contains(sc.chNext)
1033  					|| IsWordStartChar(sc.chNext))) {
1034  				switch (sc.ch) {
1035  					case '$': sc.SetState(SCE_RAKU_MU);
1036  						break;
1037  					case '@': sc.SetState(SCE_RAKU_POSITIONAL);
1038  						break;
1039  					case '%': sc.SetState(SCE_RAKU_ASSOCIATIVE);
1040  						break;
1041  					case '&': sc.SetState(SCE_RAKU_CALLABLE);
1042  				}
1043  				const int state = sc.state;
1044  				sc.Forward();
1045  				char ch_delim = 0;
1046  				if (setSpecialVar.Contains(sc.ch)
1047  						&& !setWord.Contains(sc.chNext)) {	
1048  					ch_delim = -1;
1049  				} else if (setTwigil.Contains(sc.ch)) {		
1050  					sc.SetState(SCE_RAKU_OPERATOR);
1051  					if (sc.ch == '<' && setWord.Contains(sc.chNext))
1052  						ch_delim = '>';
1053  					sc.Forward();
1054  					sc.SetState(state);
1055  				}
1056  				if (ch_delim >= 0) {
1057  					sc.Forward(LengthToNonWordChar(sc, lengthToEnd, s, sizeof(s)) - 1);
1058  					if (ch_delim > 0 && sc.chNext == ch_delim) {
1059  						sc.Forward();
1060  						sc.SetState(SCE_RAKU_OPERATOR);
1061  					}
1062  					identLast = s;	
1063  				}
1064  			}
1065  			else if (IsOperatorChar(sc.ch)) {
1066  				sc.SetState(SCE_RAKU_OPERATOR);
1067  			}
1068  			else if (!hereDelim.empty() && sc.atLineEnd) {
1069  				if (IsANewLine(sc.ch))
1070  					sc.Forward(); 
1071  				sc.SetState(hereState);
1072  			}
1073  			if (sc.state == SCE_RAKU_OPERATOR && (sc.ch == ';' || sc.ch == '}')) {
1074  				wordLast.clear();
1075  				identLast.clear();
1076  				adverbLast.clear();
1077  			}
1078  		}
1079  		else if (sc.state == SCE_RAKU_COMMENTLINE && sc.chPrev == '#' && sc.ch == '`') {
1080  			if (IsBracketOpenChar(sc.chNext)) {
1081  				sc.Forward(); 
1082  				dpEmbeded.opener = sc.ch;
1083  				dpEmbeded.closer[0] = GetBracketCloseChar(dpEmbeded.opener);
1084  				if (dpEmbeded.closer[0] > 0) { 
1085  					dpEmbeded.count = GetRepeatCharCount(sc, dpEmbeded.opener, lengthToEnd);
1086  					sc.SetState(SCE_RAKU_COMMENTEMBED);
1087  					sc.Forward(dpEmbeded.count - 1); 
1088  				}
1089  			}
1090  		}
1091  	}
1092  	sc.Complete();
1093  }
1094  #define RAKU_HEADFOLD_SHIFT	4
1095  #define RAKU_HEADFOLD_MASK	0xF0
1096  void SCI_METHOD LexerRaku::Fold(Sci_PositionU startPos, Sci_Position length, int &bsol;* initStyle */, IDocument *pAccess) {
1097  	if (!options.fold) return;
1098  	LexAccessor styler(pAccess);
1099  	const Sci_PositionU endPos = startPos + length;
1100  	Sci_Position lineCurrent = styler.GetLine(startPos);
1101  	if (startPos > 0 && lineCurrent > 0) {
1102  		while (lineCurrent > 0 && styler.StyleAt(startPos) != SCE_RAKU_DEFAULT) {
1103  			lineCurrent--;
1104  			startPos = styler.LineStart(lineCurrent);
1105  		}
1106  		lineCurrent = styler.GetLine(startPos);
1107  	}
1108  	Sci_PositionU lineStart = startPos;
1109  	Sci_PositionU lineStartNext = styler.LineStart(lineCurrent + 1);
1110  	int levelPrev = SC_FOLDLEVELBASE;
1111  	if (lineCurrent > 0)
1112  		levelPrev = styler.LevelAt(lineCurrent - 1) >> 16;
1113  	int levelCurrent = levelPrev;
1114  	char chNext = styler[startPos];
1115  	int stylePrev = styler.StyleAt(startPos - 1);
1116  	int styleNext = styler.StyleAt(startPos);
1117  	int styleNextStartLine = styler.StyleAt(lineStartNext);
1118  	int visibleChars = 0;
1119  	bool wasCommentMulti = false;
1120  	for (Sci_PositionU i = startPos; i < endPos; i++) {
1121  		const char ch = chNext;
1122  		chNext = styler.SafeGetCharAt(i + 1);
1123  		const int style = styleNext;
1124  		styleNext = styler.StyleAt(i + 1);
1125  		const bool atEOL = i == (lineStartNext - 1);
1126  		const bool atLineStart = i == lineStart;
1127  		if (options.foldComment) {
1128  			if (options.foldCommentMultiline) {
1129  				if (style == SCE_RAKU_COMMENTLINE && atLineStart && ch == '#' && chNext == '`'
1130  						&& styleNextStartLine == SCE_RAKU_COMMENTEMBED) {
1131  					levelCurrent++;
1132  					wasCommentMulti = true; 
1133  				} else if (style == SCE_RAKU_COMMENTEMBED && atLineStart
1134  						&& styleNextStartLine != SCE_RAKU_COMMENTEMBED) {
1135  					levelCurrent--;
1136  				}
1137  			}
1138  			if (!wasCommentMulti && atEOL && stylePrev == SCE_RAKU_COMMENTLINE
1139  					&& IsCommentLine(lineCurrent, styler)) {
1140  				if (!IsCommentLine(lineCurrent - 1, styler)
1141  						&& IsCommentLine(lineCurrent + 1, styler))
1142  					levelCurrent++;
1143  				else if (IsCommentLine(lineCurrent - 1, styler)
1144  						&& !IsCommentLine(lineCurrent + 1, styler))
1145  					levelCurrent--;
1146  			}
1147  			if (options.foldCommentPOD && atLineStart && style == SCE_RAKU_POD) {
1148  				if (styler.Match(i, "=begin"))
1149  					levelCurrent++;
1150  				else if (styler.Match(i, "=end"))
1151  					levelCurrent--;
1152  			}
1153  		}
1154  		if (style == SCE_RAKU_OPERATOR) {
1155  			if (ch == '{') {
1156  				if (levelCurrent < levelPrev) levelPrev--;
1157  				levelCurrent++;
1158  			} else if (ch == '}') {
1159  				levelCurrent--;
1160  			}
1161  		}
1162  		if (atEOL) {
1163  			int level = levelPrev;
1164  			level |= levelCurrent << 16;
1165  			if (visibleChars == 0 && options.foldCompact)
1166  				level |= SC_FOLDLEVELWHITEFLAG;
1167  			if ((levelCurrent > levelPrev) && (visibleChars > 0))
1168  				level |= SC_FOLDLEVELHEADERFLAG;
1169  			if (level != styler.LevelAt(lineCurrent)) {
1170  				styler.SetLevel(lineCurrent, level);
1171  			}
1172  			lineCurrent++;
1173  			lineStart = lineStartNext;
1174  			lineStartNext = styler.LineStart(lineCurrent + 1);
1175  			styleNextStartLine = styler.StyleAt(lineStartNext);
1176  			levelPrev = levelCurrent;
1177  			visibleChars = 0;
1178  			wasCommentMulti = false;
1179  		}
1180  		if (!isspacechar(ch))
1181  			visibleChars++;
1182  		stylePrev = style;
1183  	}
1184  	int flagsNext = styler.LevelAt(lineCurrent) & ~SC_FOLDLEVELNUMBERMASK;
1185  	styler.SetLevel(lineCurrent, levelPrev | flagsNext);
1186  }
1187  LexerModule lmRaku(SCLEX_RAKU, LexerRaku::LexerFactoryRaku, "raku", rakuWordLists);
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexRaku.cxx</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexRaku.cxx</div>
                </div>
                <div class="column column_space"><pre><code>440  	WordList typesDomainSpecific;
441  	WordList typesExceptions;
442  	WordList adverbs;
443  public:
444  	explicit LexerRaku() :
445  		DefaultLexer("raku", SCLEX_RAKU),
</pre></code></div>
                <div class="column column_space"><pre><code>440  	WordList typesDomainSpecific;
441  	WordList typesExceptions;
442  	WordList adverbs;
443  public:
444  	explicit LexerRaku() :
445  		DefaultLexer("raku", SCLEX_RAKU),
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    