<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for TreeItem.h & tnode.h</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for TreeItem.h & tnode.h
      </h3>
      <h1 align="center">
        5.6%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>TreeItem.h (8.441559%)<TH>tnode.h (4.2207794%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match1012-0.html#0',2,'match1012-1.html#0',3)" NAME="0">(122-137)<TD><A HREF="javascript:ZweiFrames('match1012-0.html#0',2,'match1012-1.html#0',3)" NAME="0">(276-282)</A><TD ALIGN=center><FONT COLOR="#ff0000">13</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>TreeItem.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
  Copyright (C) 2000-2012 Novell, Inc
  This library is free software; you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as
  published by the Free Software Foundation; either version 2.1 of the
  License, or (at your option) version 3.0 of the License. This library
  is distributed in the hope that it will be useful, but WITHOUT ANY
  WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
  License for more details. You should have received a copy of the GNU
  Lesser General Public License along with this library; if not, write
  to the Free Software Foundation, Inc., 51 Franklin Street, Fifth
  Floor, Boston, MA 02110-1301 USA
*/


/*-/

  File:		TreeItem.h

  Author:	Stefan Hundhammer &lt;shundhammer@suse.de&gt;

/-*/

#ifndef TreeItem_h
#define TreeItem_h

#include &lt;string&gt;




/**
 * Template class for tree items that can handle tree children in a
 * generic way - firstChild(), next() and parent(). Each item stores one value
 * of type 'PAYLOAD'.
 *
 * Class 'PAYLOAD' needs to provide operator=().
 **/
template&lt;class PAYLOAD&gt; class TreeItem
{
public:

    /**
     * Constructor. Creates a new tree item with value &quot;val&quot; and inserts it
     * ( without maintaining any meaningful sort order! ) into the children list
     * of &quot;parent&quot;.
     **/
    TreeItem&lt;PAYLOAD&gt; ( const PAYLOAD &amp;		val,
			TreeItem&lt;PAYLOAD&gt; * 	parent = 0 )
	: _value( val )
	, _parent( parent )
	, _next(0)
	, _firstChild(0)
    {
	if ( _parent )
	    _parent-&gt;addChild( this );
    }


protected:

    /**
     * Constructor to be called for derived classes: Decide whether or not to
     * automatically insert this item into the parent's children list. Useful
     * for derived classes that want to maintain a specific sort order among
     * children.
     **/
    TreeItem&lt;PAYLOAD&gt; ( PAYLOAD			val,
			bool 			autoAddChild,
			TreeItem&lt;PAYLOAD&gt; * 	parent = 0 )
	: _value( val )
	, _parent( parent )
	, _next(0)
	, _firstChild(0)
    {
	if ( _parent &amp;&amp; autoAddChild )
	    _parent-&gt;addChild( this );
    }


private:
    /**
     * Private ( i.e. disabled ) copy constructor and operator=()
     * - neither makes any sense with this class.
     **/
    TreeItem&lt;PAYLOAD&gt;             ( const TreeItem&lt;PAYLOAD&gt; &amp; ) {}
    TreeItem&lt;PAYLOAD&gt; &amp; operator= ( const TreeItem&lt;PAYLOAD&gt; &amp; ) {}


public:

    /**
     * Destructor. Takes care of children - they will be deleted along with
     * this item.
     **/
    virtual ~TreeItem&lt;PAYLOAD&gt; ()
    {
	TreeItem&lt;PAYLOAD&gt; * child = firstChild();

	while ( child )
	{
	    TreeItem&lt;PAYLOAD&gt; * lastChild = child;
	    child = child-&gt;next();
	    delete lastChild;
	}
    }


    /**
     * Returns this item's value, the &quot;payload&quot;.
     **/
    const PAYLOAD &amp; value() const { return _value; }

    /**
     * Set this item's value, the &quot;payload&quot;.
     *
     * If the sort order among children of one level is important, overwrite
<A NAME="0"></A>     * this method and change the sort order according to the new value.
     * The template class itself never calls this.
     **/
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match1012-1.html#0',3,'match1012-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    void setValue( PAYLOAD newValue ) { _value = newValue; }

    /**
     * Returns this item's parent or 0 if there is none.
     **/
    TreeItem&lt;PAYLOAD&gt; * 	parent() 	const { return _parent; 	}

    /**
     * Returns this item's next sibling or 0 if there is none.
     **/
    TreeItem&lt;PAYLOAD&gt; * 	next() 		const { return _next; 		}

    /**
     * Returns this item's first child or 0 if there is none.
     **/
    TreeItem&lt;PAYLOAD&gt; * 	firstChild()	const { return _firstChild;	}</B></FONT>

    /**
     * Sets this item's parent.
     **/
    void setParent( TreeItem&lt;PAYLOAD&gt; * newParent )	{ _parent = newParent;	}

    /**
     * Sets this item's next sibling.
     **/
    void setNext( TreeItem&lt;PAYLOAD&gt; * newNext )		{ _next = newNext;	}

    /**
     * Sets this item's first child.
     **/
    void setFirstChild(	TreeItem&lt;PAYLOAD&gt; * newFirstChild )
	{ _firstChild = newFirstChild; }


    /**
     * Add a child to the internal children list - usually called from within
     * the child's default constructor.
     *
     * This default method does not maintain any meaningful sorting order -
     * derived classes that require this might want to use the other
     * constructor ( with 'autoAddChild' set to 'false' ) take care of child
     * insertion themselves.
     **/
    void addChild( TreeItem&lt;PAYLOAD&gt; * newChild )
    {
	if ( newChild )
	{
	    newChild-&gt;setNext( firstChild() );
	    setFirstChild( newChild );
	}
    }


protected:

    PAYLOAD		_value;
    TreeItem&lt;PAYLOAD&gt; *	_parent;
    TreeItem&lt;PAYLOAD&gt; * _next;
    TreeItem&lt;PAYLOAD&gt; * _firstChild;
};



/**
 * Template class for tree items that maintain sort order.
 *
 * Class 'PAYLOAD' to provide operator&lt;() in addition to what template
 *'TreeItem' requires.
 **/
template&lt;class PAYLOAD&gt; class SortedTreeItem: public TreeItem&lt;PAYLOAD&gt;
{
public:

    /**
     * Constructor. Creates a new tree item with value &quot;val&quot; and inserts it in
     * ascending sort order into the children list of &quot;parent&quot;.
     **/
    SortedTreeItem&lt;PAYLOAD&gt;( PAYLOAD 			val,
			     SortedTreeItem&lt;PAYLOAD&gt; * 	parentItem = 0 )
	: TreeItem&lt;PAYLOAD&gt; ( val, false, parentItem )
    {
	if ( parentItem )
	{
	    // Hopefully we have a SortedTreeItem parent
	    SortedTreeItem&lt;PAYLOAD&gt; * sortParent =
		dynamic_cast&lt;SortedTreeItem&lt;PAYLOAD&gt; *&gt; ( parentItem );

	    if ( sortParent )
		sortParent-&gt;insertChildSorted( this );
	    else // no SortedTreeItem parent - add unsorted
		parentItem-&gt;addChild( this );
	}
    }


    /**
     * Destructor.
     **/
    virtual ~SortedTreeItem&lt;PAYLOAD&gt; () {}


    /**
     * Insert a child into the internal children list in ascending sort order.
     * Called from the new child's constructor, thus 'public'.
     **/
    void insertChildSorted( SortedTreeItem&lt;PAYLOAD&gt; * newChild )
    {
	if ( ! newChild )
	    return;

	if ( ! firstChild() ||
	     newChild-&gt;value() &lt; firstChild()-&gt;value() )
	{
	    // Insert as first child

	    newChild-&gt;setNext( firstChild() );
	    this-&gt;setFirstChild( newChild );
	}
	else
	{
	    // Search correct place to insert

	    TreeItem&lt;PAYLOAD&gt; * child = firstChild();

	    while ( child-&gt;next() &amp;&amp;
		    child-&gt;next()-&gt;value() &lt; newChild-&gt;value() )
	    {
		child = child-&gt;next();
	    }


	    // Insert after 'child'

	    newChild-&gt;setNext( child-&gt;next() );
	    child-&gt;setNext( newChild );
	}
    }


    /**
     * Returns this item's parent or 0 if there is none.
     **/
    SortedTreeItem&lt;PAYLOAD&gt; * 	parent() 	const
	{ return ( SortedTreeItem&lt;PAYLOAD&gt; * ) TreeItem&lt;PAYLOAD&gt;::_parent; }

    /**
     * Returns this item's next sibling or 0 if there is none.
     **/
    SortedTreeItem&lt;PAYLOAD&gt; * 	next() 		const
	{ return ( SortedTreeItem&lt;PAYLOAD&gt; * ) TreeItem&lt;PAYLOAD&gt;::_next; }

    /**
     * Returns this item's first child or 0 if there is none.
     **/
    SortedTreeItem&lt;PAYLOAD&gt; * 	firstChild()	const
	{ return ( SortedTreeItem&lt;PAYLOAD&gt; * ) TreeItem&lt;PAYLOAD&gt;::_firstChild; }


private:

    /**
     * Private ( i.e. disabled ) copy constructor and operator=()
     * - neither makes any sense with this class.
     **/
    SortedTreeItem&lt;PAYLOAD&gt;             ( const SortedTreeItem&lt;PAYLOAD&gt; &amp; ) {}
    SortedTreeItem&lt;PAYLOAD&gt; &amp; operator= ( const SortedTreeItem&lt;PAYLOAD&gt; &amp; ) {}
};



/**
 * Find a direct child ( i.e., non-recursive ) with value &quot;searchVal&quot;.
 * Returns 0 if there is no such child.
 **/
template&lt;class ITEM, class PAYLOAD&gt; inline
ITEM *
findDirectChild( ITEM * item, PAYLOAD searchVal )
{
    TreeItem&lt;PAYLOAD&gt; * child = item-&gt;firstChild();

    while ( child )
    {
	if ( child-&gt;value() == searchVal )
	    return dynamic_cast&lt;ITEM *&gt; ( child );

	child = child-&gt;next();
    }

    return 0;
}



#endif // TreeItem_h
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>tnode.h</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/*
  Copyright (C) 2000-2012 Novell, Inc
  This library is free software; you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as
  published by the Free Software Foundation; either version 2.1 of the
  License, or (at your option) version 3.0 of the License. This library
  is distributed in the hope that it will be useful, but WITHOUT ANY
  WARRANTY; without even the implied warranty of MERCHANTABILITY or
  FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
  License for more details. You should have received a copy of the GNU
  Lesser General Public License along with this library; if not, write
  to the Free Software Foundation, Inc., 51 Franklin Street, Fifth
  Floor, Boston, MA 02110-1301 USA
*/


/*-/

   File:       tnode.h

   Author:     Michael Andres &lt;ma@suse.de&gt;

/-*/

#ifndef tnode_h
#define tnode_h

#include &lt;iosfwd&gt;

/**
 * Tree node.
 *
 * Traversing the tree with \ref Next and \ref Prev is done
 * pre-order (self before children)
 * and depth-first (children before siblings)
 *
 * See also
 * - https://en.wikipedia.org/wiki/Depth-first_search
 * - https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR)
 *
 * In practice all instances of this template use NCWidget * for n_value.
 */
template &lt;class n_value&gt; class tnode
{

    tnode &amp; operator=( const tnode &amp; );
    tnode( const tnode &amp; );

protected:

    typedef tnode&lt;n_value&gt;   self;

    mutable n_value val;

private:

    self * parent;
    self * psibling;    // prev sibling
    self * nsibling;    // next sibling
    self * fchild;      // first child
    self * lchild;      // last  child

    // Disconnect from old parent, connect to new parent *p*.
    //
    // If *s* is specified (not nilptr), insert this
    // as its previous sibling (if *behind* is false)
    // or as its next sibling (if *behind* is true).
    //
    // If *s* is omitted (nilptr), become the first (behind==false) or last
    // (behind=true) child
    //
    // In case *s* is specified but is not in fact a child of *p* then it is
    // treated as omitted.
    //
    // @param p new parent
    // @param s reference sibling
    // @param behind true: insert after *s*; false: insert before *s*
    // @return true on success;
    //   false on failure (*p* is myself or a descendant of mine)
    bool DoReparentTo( self &amp; p, self * s, bool behind )
    {

	if ( &amp;p == this || p.IsDescendantOf( this ) )
	    return false;

	Disconnect();

	parent = &amp;p;

	PreReparent();

	if ( !s || s-&gt;parent != parent ) // using default sibling
	    s = behind ? parent-&gt;lchild : parent-&gt;fchild;

	if ( !s )
	{
	    // no sibling, so we'll be the only child
	    parent-&gt;fchild = parent-&gt;lchild = this;
	}
	else
	{
	    if ( behind )
	    {
		psibling    = s;
		nsibling    = s-&gt;nsibling;
		s-&gt;nsibling = this;

		if ( nsibling )
		    nsibling-&gt;psibling = this;
		else
		    parent-&gt;lchild     = this;
	    }
	    else
	    {
		psibling    = s-&gt;psibling;
		nsibling    = s;
		s-&gt;psibling = this;

		if ( psibling )
		    psibling-&gt;nsibling = this;
		else
		    parent-&gt;fchild     = this;
	    }
	}

	PostReparent();

	return true;
    }

protected:

    virtual void PreDisconnect()  {}

    virtual void PostDisconnect() {}

    virtual void PreReparent()	  {}

    virtual void PostReparent()   {}

public:

    /// New node, added as the last child by default (which is natural).
    /// @param p parent
    tnode( n_value v, self * p = 0, bool behind = true )
	    : val( v )
	    , parent( 0 )
	    , psibling( 0 )
	    , nsibling( 0 )
	    , fchild( 0 )
	    , lchild( 0 )
    {
	if ( p )
	    DoReparentTo( *p, 0, behind );
    }

    /// New node, added as the last child by default (which is natural).
    /// @param p parent
    tnode( n_value v, self &amp; p, bool behind = true )
	    : val( v )
	    , parent( 0 )
	    , psibling( 0 )
	    , nsibling( 0 )
	    , fchild( 0 )
	    , lchild( 0 )
    {
	DoReparentTo( p, 0, behind );
    }

    /// New node under *p*, just after *s* (or before *s* if behind==false)
    /// @param p parent
    /// @param s reference sibling
    tnode( n_value v, self &amp; p, self &amp; s, bool behind = true )
	    : val( v )
	    , parent( 0 )
	    , psibling( 0 )
	    , nsibling( 0 )
	    , fchild( 0 )
	    , lchild( 0 )
    {
	DoReparentTo( p, &amp;s, behind );
    }


    virtual ~tnode()
    {
	while ( fchild )
	    fchild-&gt;Disconnect();

	Disconnect();
    }

    /// Disconnect from the parent and siblings, but keep children.
    void Disconnect()
    {
	if ( !parent )
	    return;

	PreDisconnect();

	if ( psibling )
	    psibling-&gt;nsibling = nsibling;
	else
	    parent-&gt;fchild     = nsibling;

	if ( nsibling )
	    nsibling-&gt;psibling = psibling;
	else
	    parent-&gt;lchild     = psibling;

	parent = psibling = nsibling = 0;

	PostDisconnect();
    }

    /// Disconnect from old parent, connect to new parent *p*.
    /// Become the last child (or the first, if behind==false).
    ///
    /// @param p new parent
    /// @return true on success;
    ///   false on failure (*p* is myself or a descendant of mine)
    bool ReparentTo( self &amp; p, bool behind = true )
    {
	return DoReparentTo( p, 0, behind );
    }

    /// Disconnect from old parent, connect to new parent *p* and sibling *s*.
    ///
    /// Insert this as just after *s* (or just before, if behind==false).
    ///
    /// In case *s* is not in fact a child of *p* then we become *p*'s last
    /// (first) child.
    ///
    /// @param p new parent
    /// @param s reference sibling
    /// @param behind true: insert after *s*; false: insert before *s*
    /// @return true on success;
    ///   false on failure (*p* is myself or a descendant of mine)
    bool ReparentTo( self &amp; p, self &amp; s, bool behind = true )
    {
	return DoReparentTo( p, &amp;s, behind );
    }


    n_value &amp; Value()	   const { return val; }

    /// Alias for \ref Value
    n_value &amp; operator()() const { return Value(); }

    self *	 Parent()	  { return parent; }

    const self * Parent()   const { return parent; }

    /// Previous sibling
    self *	 Psibling()	  { return psibling; }

    /// Previous sibling
    const self * Psibling() const { return psibling; }

    /// Next sibling
    self *	 Nsibling()	  { return nsibling; }

    /// Next sibling
    const self * Nsibling() const { return nsibling; }

    /// First child
    self *	 Fchild()	  { return fchild; }

    /// First child
    const self * Fchild()   const { return fchild; }

    /// Last child
<A NAME="0"></A>    self *	 Lchild()	  { return lchild; }

    /// Last child
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match1012-0.html#0',2,'match1012-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    const self * Lchild()   const { return lchild; }

    bool HasParent()   const { return parent; }

    bool HasSiblings() const { return psibling || nsibling; }

    bool HasChildren() const { return fchild; }</B></FONT>

    bool IsParentOf( const self &amp; c ) const { return c.parent == this; }

    bool IsSiblingOf( const self &amp; s ) const { return parent &amp;&amp; s.parent == parent; }

    bool IsChildOf( const self &amp; p ) const { return parent == &amp;p; }

    /// Depth: zero if no parent, otherwise 1 + parent's depth.
    unsigned Depth() const
    {
	self * l = const_cast&lt;self *&gt;( this );
	unsigned level = 0;

	while ( l-&gt;parent )
	{
	    l = l-&gt;parent;
	    ++level;
	}

	return level;
    }

    // tree walk

    bool IsDescendantOf( const self &amp; n ) const
    {
	for ( const self * l = parent; l; l = l-&gt;parent )
	{
	    if ( l == &amp;n )
		return true;
	}

	return false;
    }

    bool IsDescendantOf( const self * n ) const
    {
	return( n &amp;&amp; IsDescendantOf( *n ) );
    }

    /// Root of the tree
    self &amp; Top()
    {
	self * l = this;

	while ( l-&gt;parent )
	    l = l-&gt;parent;

	return *l;
    }

    /// Next node: depth first, pre-order.
    /// @param restart if true, the last node's Next is the first (\ref Top);
    ///   otherwise nilptr.
    self * Next( bool restart = false )
    {
	if ( fchild ) // down first
	    return fchild;

	self * l = this; // then next

	while ( !l-&gt;nsibling )
	{
	    if ( l-&gt;parent )
		l = l-&gt;parent;
	    else
		return restart ? l : 0; // at Top()
	}

	return l-&gt;nsibling;
    }

    self * Prev( bool restart = false )
    {
	if ( !psibling &amp;&amp; parent )
	    return parent;

	if ( !psibling &amp;&amp; !restart )
	    return 0;

	// have psibling or at Top() and restart:
	self * l = psibling ? psibling : this;

	while ( l-&gt;lchild )
	    l = l-&gt;lchild;

	return l;
    }

    /// Return \ref Next and assign it to *c*.
    self * Next( self *&amp; c, bool restart = false )
    {
	return c = Next( restart );
    }

    /// Return \ref Prev and assign it to *c*.
    self * Prev( self *&amp; c, bool restart = false )
    {
	return c = Prev( restart );
    }

    // const versions

    const self &amp; Top() const
    {
	return const_cast&lt;self *&gt;( this )-&gt;Top();
    }

    const self * Next( bool restart = false ) const
    {
	return const_cast&lt;self *&gt;( this )-&gt;Next( restart );
    }

    const self * Prev( bool restart = false ) const
    {
	return const_cast&lt;self *&gt;( this )-&gt;Prev( restart );
    }

    const self * Next( const self *&amp; c, bool restart = false ) const
    {
	return c = const_cast&lt;self *&gt;( this )-&gt;Next( restart );
    }

    const self * Prev( const self *&amp; c, bool restart = false ) const
    {
	return c = const_cast&lt;self *&gt;( this )-&gt;Prev( restart );
    }

};

#endif // tnode_h
</PRE>
</div>
  </div>
</body>
</html>
