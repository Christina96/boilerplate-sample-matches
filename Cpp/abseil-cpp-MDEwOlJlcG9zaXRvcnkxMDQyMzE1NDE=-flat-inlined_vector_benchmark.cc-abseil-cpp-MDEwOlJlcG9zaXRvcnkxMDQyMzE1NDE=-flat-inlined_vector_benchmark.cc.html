
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 23, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-inlined_vector_benchmark.cc</h3>
            <pre><code>1  #include <array>
2  #include <string>
3  #include <vector>
4  #include "absl/base/internal/raw_logging.h"
5  #include "absl/base/macros.h"
6  #include "absl/container/inlined_vector.h"
7  #include "absl/strings/str_cat.h"
8  #include "benchmark/benchmark.h"
9  namespace {
10  void BM_InlinedVectorFill(benchmark::State& state) {
11    const int len = state.range(0);
12    absl::InlinedVector<int, 8> v;
13    v.reserve(len);
14    for (auto _ : state) {
15      v.resize(0);  
16      for (int i = 0; i < len; ++i) {
17        v.push_back(i);
18      }
19      benchmark::DoNotOptimize(v);
20    }
21  }
22  BENCHMARK(BM_InlinedVectorFill)->Range(1, 256);
23  void BM_InlinedVectorFillRange(benchmark::State& state) {
24    const int len = state.range(0);
25    const std::vector<int> src(len, len);
26    absl::InlinedVector<int, 8> v;
27    v.reserve(len);
28    for (auto _ : state) {
29      benchmark::DoNotOptimize(src);
30      v.assign(src.begin(), src.end());
31      benchmark::DoNotOptimize(v);
32    }
33  }
34  BENCHMARK(BM_InlinedVectorFillRange)->Range(1, 256);
35  void BM_StdVectorFill(benchmark::State& state) {
36    const int len = state.range(0);
37    std::vector<int> v;
38    v.reserve(len);
39    for (auto _ : state) {
40      v.clear();
41      for (int i = 0; i < len; ++i) {
42        v.push_back(i);
43      }
44      benchmark::DoNotOptimize(v);
45    }
46  }
47  BENCHMARK(BM_StdVectorFill)->Range(1, 256);
48  bool StringRepresentedInline(std::string s) {
49    const char* chars = s.data();
50    std::string s1 = std::move(s);
51    return s1.data() != chars;
52  }
53  int GetNonShortStringOptimizationSize() {
54    for (int i = 24; i <= 192; i *= 2) {
55      if (!StringRepresentedInline(std::string(i, 'A'))) {
56        return i;
57      }
58    }
59    ABSL_RAW_LOG(
60        FATAL,
61        "Failed to find a string larger than the short string optimization");
62    return -1;
63  }
64  void BM_InlinedVectorFillString(benchmark::State& state) {
65    const int len = state.range(0);
66    const int no_sso = GetNonShortStringOptimizationSize();
67    std::string strings[4] = {std::string(no_sso, 'A'), std::string(no_sso, 'B'),
68                              std::string(no_sso, 'C'), std::string(no_sso, 'D')};
69    for (auto _ : state) {
70      absl::InlinedVector<std::string, 8> v;
71      for (int i = 0; i < len; i++) {
72        v.push_back(strings[i & 3]);
73      }
74    }
75    state.SetItemsProcessed(static_cast<int64_t>(state.iterations()) * len);
76  }
77  BENCHMARK(BM_InlinedVectorFillString)->Range(0, 1024);
78  void BM_StdVectorFillString(benchmark::State& state) {
79    const int len = state.range(0);
80    const int no_sso = GetNonShortStringOptimizationSize();
81    std::string strings[4] = {std::string(no_sso, 'A'), std::string(no_sso, 'B'),
82                              std::string(no_sso, 'C'), std::string(no_sso, 'D')};
83    for (auto _ : state) {
84      std::vector<std::string> v;
85      for (int i = 0; i < len; i++) {
86        v.push_back(strings[i & 3]);
87      }
88    }
89    state.SetItemsProcessed(static_cast<int64_t>(state.iterations()) * len);
90  }
91  BENCHMARK(BM_StdVectorFillString)->Range(0, 1024);
92  struct Buffer {  
93    char* base;
94    int length;
95    int capacity;
96    void* user_data;
97  };
98  void BM_InlinedVectorAssignments(benchmark::State& state) {
99    const int len = state.range(0);
100    using BufferVec = absl::InlinedVector<Buffer, 2>;
101    BufferVec src;
102    src.resize(len);
103    BufferVec dst;
104    for (auto _ : state) {
105      benchmark::DoNotOptimize(dst);
106      benchmark::DoNotOptimize(src);
107      dst = src;
108    }
109  }
110  BENCHMARK(BM_InlinedVectorAssignments)
111      ->Arg(0)
112      ->Arg(1)
113      ->Arg(2)
114      ->Arg(3)
115      ->Arg(4)
116      ->Arg(20);
117  void BM_CreateFromContainer(benchmark::State& state) {
118    for (auto _ : state) {
119      absl::InlinedVector<int, 4> src{1, 2, 3};
120      benchmark::DoNotOptimize(src);
121      absl::InlinedVector<int, 4> dst(std::move(src));
122      benchmark::DoNotOptimize(dst);
123    }
124  }
125  BENCHMARK(BM_CreateFromContainer);
126  struct LargeCopyableOnly {
127    LargeCopyableOnly() : d(1024, 17) {}
128    LargeCopyableOnly(const LargeCopyableOnly& o) = default;
129    LargeCopyableOnly& operator=(const LargeCopyableOnly& o) = default;
130    std::vector<int> d;
131  };
132  struct LargeCopyableSwappable {
133    LargeCopyableSwappable() : d(1024, 17) {}
134    LargeCopyableSwappable(const LargeCopyableSwappable& o) = default;
135    LargeCopyableSwappable& operator=(LargeCopyableSwappable o) {
136      using std::swap;
137      swap(*this, o);
138      return *this;
139    }
140    friend void swap(LargeCopyableSwappable& a, LargeCopyableSwappable& b) {
141      using std::swap;
142      swap(a.d, b.d);
143    }
144    std::vector<int> d;
145  };
146  struct LargeCopyableMovable {
147    LargeCopyableMovable() : d(1024, 17) {}
148    std::vector<int> d;
149  };
150  struct LargeCopyableMovableSwappable {
151    LargeCopyableMovableSwappable() : d(1024, 17) {}
152    LargeCopyableMovableSwappable(const LargeCopyableMovableSwappable& o) =
153        default;
154    LargeCopyableMovableSwappable(LargeCopyableMovableSwappable&& o) = default;
155    LargeCopyableMovableSwappable& operator=(LargeCopyableMovableSwappable o) {
156      using std::swap;
157      swap(*this, o);
158      return *this;
159    }
160    LargeCopyableMovableSwappable& operator=(LargeCopyableMovableSwappable&& o) =
161        default;
162    friend void swap(LargeCopyableMovableSwappable& a,
163                     LargeCopyableMovableSwappable& b) {
164      using std::swap;
165      swap(a.d, b.d);
166    }
167    std::vector<int> d;
168  };
169  template <typename ElementType>
170  void BM_SwapElements(benchmark::State& state) {
<span onclick='openModal()' class='match'>171    const int len = state.range(0);
172    using Vec = absl::InlinedVector<ElementType, 32>;
173    Vec a(len);
</span>174    Vec b;
175    for (auto _ : state) {
176      using std::swap;
177      benchmark::DoNotOptimize(a);
178      benchmark::DoNotOptimize(b);
179      swap(a, b);
180    }
181  }
182  BENCHMARK_TEMPLATE(BM_SwapElements, LargeCopyableOnly)->Range(0, 1024);
183  BENCHMARK_TEMPLATE(BM_SwapElements, LargeCopyableSwappable)->Range(0, 1024);
184  BENCHMARK_TEMPLATE(BM_SwapElements, LargeCopyableMovable)->Range(0, 1024);
185  BENCHMARK_TEMPLATE(BM_SwapElements, LargeCopyableMovableSwappable)
186      ->Range(0, 1024);
187  template <typename VecType>
188  void BM_Sizeof(benchmark::State& state) {
189    int size = 0;
190    for (auto _ : state) {
191      VecType vec;
192      size = sizeof(vec);
193    }
194    state.SetLabel(absl::StrCat("sz=", size));
195  }
196  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<char, 1>);
197  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<char, 4>);
198  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<char, 7>);
199  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<char, 8>);
200  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<int, 1>);
201  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<int, 4>);
202  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<int, 7>);
203  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<int, 8>);
204  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<void*, 1>);
205  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<void*, 4>);
206  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<void*, 7>);
207  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<void*, 8>);
208  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<std::string, 1>);
209  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<std::string, 4>);
210  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<std::string, 7>);
211  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<std::string, 8>);
212  void BM_InlinedVectorIndexInlined(benchmark::State& state) {
213    absl::InlinedVector<int, 8> v = {1, 2, 3, 4, 5, 6, 7};
214    for (auto _ : state) {
215      benchmark::DoNotOptimize(v);
216      benchmark::DoNotOptimize(v[4]);
217    }
218  }
219  BENCHMARK(BM_InlinedVectorIndexInlined);
220  void BM_InlinedVectorIndexExternal(benchmark::State& state) {
221    absl::InlinedVector<int, 8> v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
222    for (auto _ : state) {
223      benchmark::DoNotOptimize(v);
224      benchmark::DoNotOptimize(v[4]);
225    }
226  }
227  BENCHMARK(BM_InlinedVectorIndexExternal);
228  void BM_StdVectorIndex(benchmark::State& state) {
229    std::vector<int> v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
230    for (auto _ : state) {
231      benchmark::DoNotOptimize(v);
232      benchmark::DoNotOptimize(v[4]);
233    }
234  }
235  BENCHMARK(BM_StdVectorIndex);
236  void BM_InlinedVectorDataInlined(benchmark::State& state) {
237    absl::InlinedVector<int, 8> v = {1, 2, 3, 4, 5, 6, 7};
238    for (auto _ : state) {
239      benchmark::DoNotOptimize(v);
240      benchmark::DoNotOptimize(v.data());
241    }
242  }
243  BENCHMARK(BM_InlinedVectorDataInlined);
244  void BM_InlinedVectorDataExternal(benchmark::State& state) {
245    absl::InlinedVector<int, 8> v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
246    for (auto _ : state) {
247      benchmark::DoNotOptimize(v);
248      benchmark::DoNotOptimize(v.data());
249    }
250    state.SetItemsProcessed(16 * static_cast<int64_t>(state.iterations()));
251  }
252  BENCHMARK(BM_InlinedVectorDataExternal);
253  void BM_StdVectorData(benchmark::State& state) {
254    std::vector<int> v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
255    for (auto _ : state) {
256      benchmark::DoNotOptimize(v);
257      benchmark::DoNotOptimize(v.data());
258    }
259    state.SetItemsProcessed(16 * static_cast<int64_t>(state.iterations()));
260  }
261  BENCHMARK(BM_StdVectorData);
262  void BM_InlinedVectorSizeInlined(benchmark::State& state) {
263    absl::InlinedVector<int, 8> v = {1, 2, 3, 4, 5, 6, 7};
264    for (auto _ : state) {
265      benchmark::DoNotOptimize(v);
266      benchmark::DoNotOptimize(v.size());
267    }
268  }
269  BENCHMARK(BM_InlinedVectorSizeInlined);
270  void BM_InlinedVectorSizeExternal(benchmark::State& state) {
271    absl::InlinedVector<int, 8> v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
272    for (auto _ : state) {
273      benchmark::DoNotOptimize(v);
274      benchmark::DoNotOptimize(v.size());
275    }
276  }
277  BENCHMARK(BM_InlinedVectorSizeExternal);
278  void BM_StdVectorSize(benchmark::State& state) {
279    std::vector<int> v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
280    for (auto _ : state) {
281      benchmark::DoNotOptimize(v);
282      benchmark::DoNotOptimize(v.size());
283    }
284  }
285  BENCHMARK(BM_StdVectorSize);
286  void BM_InlinedVectorEmptyInlined(benchmark::State& state) {
287    absl::InlinedVector<int, 8> v = {1, 2, 3, 4, 5, 6, 7};
288    for (auto _ : state) {
289      benchmark::DoNotOptimize(v);
290      benchmark::DoNotOptimize(v.empty());
291    }
292  }
293  BENCHMARK(BM_InlinedVectorEmptyInlined);
294  void BM_InlinedVectorEmptyExternal(benchmark::State& state) {
295    absl::InlinedVector<int, 8> v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
296    for (auto _ : state) {
297      benchmark::DoNotOptimize(v);
298      benchmark::DoNotOptimize(v.empty());
299    }
300  }
301  BENCHMARK(BM_InlinedVectorEmptyExternal);
302  void BM_StdVectorEmpty(benchmark::State& state) {
303    std::vector<int> v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
304    for (auto _ : state) {
305      benchmark::DoNotOptimize(v);
306      benchmark::DoNotOptimize(v.empty());
307    }
308  }
309  BENCHMARK(BM_StdVectorEmpty);
310  constexpr size_t kInlinedCapacity = 4;
311  constexpr size_t kLargeSize = kInlinedCapacity * 2;
312  constexpr size_t kSmallSize = kInlinedCapacity / 2;
313  constexpr size_t kBatchSize = 100;
314  #define ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_FunctionTemplate, T) \
315    BENCHMARK_TEMPLATE(BM_FunctionTemplate, T, kLargeSize);        \
316    BENCHMARK_TEMPLATE(BM_FunctionTemplate, T, kSmallSize)
317  #define ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_FunctionTemplate, T)      \
318    BENCHMARK_TEMPLATE(BM_FunctionTemplate, T, kLargeSize, kLargeSize); \
319    BENCHMARK_TEMPLATE(BM_FunctionTemplate, T, kLargeSize, kSmallSize); \
320    BENCHMARK_TEMPLATE(BM_FunctionTemplate, T, kSmallSize, kLargeSize); \
321    BENCHMARK_TEMPLATE(BM_FunctionTemplate, T, kSmallSize, kSmallSize)
322  template <typename T>
323  using InlVec = absl::InlinedVector<T, kInlinedCapacity>;
324  struct TrivialType {
325    size_t val;
326  };
327  class NontrivialType {
328   public:
329    ABSL_ATTRIBUTE_NOINLINE NontrivialType() : val_() {
330      benchmark::DoNotOptimize(*this);
331    }
332    ABSL_ATTRIBUTE_NOINLINE NontrivialType(const NontrivialType& other)
333        : val_(other.val_) {
334      benchmark::DoNotOptimize(*this);
335    }
336    ABSL_ATTRIBUTE_NOINLINE NontrivialType& operator=(
337        const NontrivialType& other) {
338      val_ = other.val_;
339      benchmark::DoNotOptimize(*this);
340      return *this;
341    }
342    ABSL_ATTRIBUTE_NOINLINE ~NontrivialType() noexcept {
343      benchmark::DoNotOptimize(*this);
344    }
345   private:
346    size_t val_;
347  };
348  template <typename T, typename PrepareVecFn, typename TestVecFn>
349  void BatchedBenchmark(benchmark::State& state, PrepareVecFn prepare_vec,
350                        TestVecFn test_vec) {
351    std::array<InlVec<T>, kBatchSize> vector_batch{};
352    while (state.KeepRunningBatch(kBatchSize)) {
353      state.PauseTiming();
354      for (size_t i = 0; i < kBatchSize; ++i) {
355        prepare_vec(vector_batch.data() + i, i);
356      }
357      benchmark::DoNotOptimize(vector_batch);
358      state.ResumeTiming();
359      for (size_t i = 0; i < kBatchSize; ++i) {
360        test_vec(vector_batch.data() + i, i);
361      }
362    }
363  }
364  template <typename T, size_t ToSize>
365  void BM_ConstructFromSize(benchmark::State& state) {
366    using VecT = InlVec<T>;
367    auto size = ToSize;
368    BatchedBenchmark<T>(
369        state,
370         [](InlVec<T>* vec, size_t) { vec->~VecT(); },
371        [&](void* ptr, size_t) {
372          benchmark::DoNotOptimize(size);
373          ::new (ptr) VecT(size);
374        });
375  }
376  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromSize, TrivialType);
377  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromSize, NontrivialType);
378  template <typename T, size_t ToSize>
379  void BM_ConstructFromSizeRef(benchmark::State& state) {
380    using VecT = InlVec<T>;
381    auto size = ToSize;
382    auto ref = T();
383    BatchedBenchmark<T>(
384        state,
385         [](InlVec<T>* vec, size_t) { vec->~VecT(); },
386        [&](void* ptr, size_t) {
387          benchmark::DoNotOptimize(size);
388          benchmark::DoNotOptimize(ref);
389          ::new (ptr) VecT(size, ref);
390        });
391  }
392  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromSizeRef, TrivialType);
393  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromSizeRef, NontrivialType);
394  template <typename T, size_t ToSize>
395  void BM_ConstructFromRange(benchmark::State& state) {
396    using VecT = InlVec<T>;
397    std::array<T, ToSize> arr{};
398    BatchedBenchmark<T>(
399        state,
400         [](InlVec<T>* vec, size_t) { vec->~VecT(); },
401        [&](void* ptr, size_t) {
402          benchmark::DoNotOptimize(arr);
403          ::new (ptr) VecT(arr.begin(), arr.end());
404        });
405  }
406  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromRange, TrivialType);
407  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromRange, NontrivialType);
408  template <typename T, size_t ToSize>
409  void BM_ConstructFromCopy(benchmark::State& state) {
410    using VecT = InlVec<T>;
411    VecT other_vec(ToSize);
412    BatchedBenchmark<T>(
413        state,
414        [](InlVec<T>* vec, size_t) { vec->~VecT(); },
415        [&](void* ptr, size_t) {
416          benchmark::DoNotOptimize(other_vec);
417          ::new (ptr) VecT(other_vec);
418        });
419  }
420  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromCopy, TrivialType);
421  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromCopy, NontrivialType);
422  template <typename T, size_t ToSize>
423  void BM_ConstructFromMove(benchmark::State& state) {
424    using VecT = InlVec<T>;
425    std::array<VecT, kBatchSize> vector_batch{};
426    BatchedBenchmark<T>(
427        state,
428        [&](InlVec<T>* vec, size_t i) {
429          vector_batch[i].clear();
430          vector_batch[i].resize(ToSize);
431          vec->~VecT();
432        },
433        [&](void* ptr, size_t i) {
434          benchmark::DoNotOptimize(vector_batch[i]);
435          ::new (ptr) VecT(std::move(vector_batch[i]));
436        });
437  }
438  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromMove, TrivialType);
439  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromMove, NontrivialType);
440  void BM_CopyTrivial(benchmark::State& state) {
441    const int n = state.range(0);
442    InlVec<int64_t> src(n);
443    for (auto s : state) {
444      InlVec<int64_t> copy(src);
445      benchmark::DoNotOptimize(copy);
446    }
447  }
448  BENCHMARK(BM_CopyTrivial)->Arg(0)->Arg(1)->Arg(kLargeSize);
449  void BM_CopyNonTrivial(benchmark::State& state) {
450    const int n = state.range(0);
451    InlVec<InlVec<int64_t>> src(n);
452    for (auto s : state) {
453      InlVec<InlVec<int64_t>> copy(src);
454      benchmark::DoNotOptimize(copy);
455    }
456  }
457  BENCHMARK(BM_CopyNonTrivial)->Arg(0)->Arg(1)->Arg(kLargeSize);
458  template <typename T, size_t FromSize, size_t ToSize>
459  void BM_AssignSizeRef(benchmark::State& state) {
460    auto size = ToSize;
461    auto ref = T();
462    BatchedBenchmark<T>(
463        state,
464         [](InlVec<T>* vec, size_t) { vec->resize(FromSize); },
465        [&](InlVec<T>* vec, size_t) {
466          benchmark::DoNotOptimize(size);
467          benchmark::DoNotOptimize(ref);
468          vec->assign(size, ref);
469        });
470  }
471  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_AssignSizeRef, TrivialType);
472  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_AssignSizeRef, NontrivialType);
473  template <typename T, size_t FromSize, size_t ToSize>
474  void BM_AssignRange(benchmark::State& state) {
475    std::array<T, ToSize> arr{};
476    BatchedBenchmark<T>(
477        state,
478         [](InlVec<T>* vec, size_t) { vec->resize(FromSize); },
479        [&](InlVec<T>* vec, size_t) {
480          benchmark::DoNotOptimize(arr);
481          vec->assign(arr.begin(), arr.end());
482        });
483  }
484  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_AssignRange, TrivialType);
485  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_AssignRange, NontrivialType);
486  template <typename T, size_t FromSize, size_t ToSize>
487  void BM_AssignFromCopy(benchmark::State& state) {
488    InlVec<T> other_vec(ToSize);
489    BatchedBenchmark<T>(
490        state,
491         [](InlVec<T>* vec, size_t) { vec->resize(FromSize); },
492        [&](InlVec<T>* vec, size_t) {
493          benchmark::DoNotOptimize(other_vec);
494          *vec = other_vec;
495        });
496  }
497  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_AssignFromCopy, TrivialType);
498  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_AssignFromCopy, NontrivialType);
499  template <typename T, size_t FromSize, size_t ToSize>
500  void BM_AssignFromMove(benchmark::State& state) {
501    using VecT = InlVec<T>;
502    std::array<VecT, kBatchSize> vector_batch{};
503    BatchedBenchmark<T>(
504        state,
505        [&](InlVec<T>* vec, size_t i) {
506          vector_batch[i].clear();
507          vector_batch[i].resize(ToSize);
508          vec->resize(FromSize);
509        },
510        [&](InlVec<T>* vec, size_t i) {
511          benchmark::DoNotOptimize(vector_batch[i]);
512          *vec = std::move(vector_batch[i]);
513        });
514  }
515  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_AssignFromMove, TrivialType);
516  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_AssignFromMove, NontrivialType);
517  template <typename T, size_t FromSize, size_t ToSize>
518  void BM_ResizeSize(benchmark::State& state) {
519    BatchedBenchmark<T>(
520        state,
521        [](InlVec<T>* vec, size_t) {
522          vec->clear();
523          vec->resize(FromSize);
524        },
525        [](InlVec<T>* vec, size_t) { vec->resize(ToSize); });
526  }
527  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_ResizeSize, TrivialType);
528  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_ResizeSize, NontrivialType);
529  template <typename T, size_t FromSize, size_t ToSize>
530  void BM_ResizeSizeRef(benchmark::State& state) {
531    auto t = T();
532    BatchedBenchmark<T>(
533        state,
534        [](InlVec<T>* vec, size_t) {
535          vec->clear();
536          vec->resize(FromSize);
537        },
538        [&](InlVec<T>* vec, size_t) {
539          benchmark::DoNotOptimize(t);
540          vec->resize(ToSize, t);
541        });
542  }
543  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_ResizeSizeRef, TrivialType);
544  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_ResizeSizeRef, NontrivialType);
545  template <typename T, size_t FromSize, size_t ToSize>
546  void BM_InsertSizeRef(benchmark::State& state) {
547    auto t = T();
548    BatchedBenchmark<T>(
549        state,
550        [](InlVec<T>* vec, size_t) {
551          vec->clear();
552          vec->resize(FromSize);
553        },
554        [&](InlVec<T>* vec, size_t) {
555          benchmark::DoNotOptimize(t);
556          auto* pos = vec->data() + (vec->size() / 2);
557          vec->insert(pos, t);
558        });
559  }
560  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_InsertSizeRef, TrivialType);
561  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_InsertSizeRef, NontrivialType);
562  template <typename T, size_t FromSize, size_t ToSize>
563  void BM_InsertRange(benchmark::State& state) {
564    InlVec<T> other_vec(ToSize);
565    BatchedBenchmark<T>(
566        state,
567        [](InlVec<T>* vec, size_t) {
568          vec->clear();
569          vec->resize(FromSize);
570        },
571        [&](InlVec<T>* vec, size_t) {
572          benchmark::DoNotOptimize(other_vec);
573          auto* pos = vec->data() + (vec->size() / 2);
574          vec->insert(pos, other_vec.begin(), other_vec.end());
575        });
576  }
577  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_InsertRange, TrivialType);
578  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_InsertRange, NontrivialType);
579  template <typename T, size_t FromSize>
580  void BM_EmplaceBack(benchmark::State& state) {
581    BatchedBenchmark<T>(
582        state,
583        [](InlVec<T>* vec, size_t) {
584          vec->clear();
585          vec->resize(FromSize);
586        },
587        [](InlVec<T>* vec, size_t) { vec->emplace_back(); });
588  }
589  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_EmplaceBack, TrivialType);
590  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_EmplaceBack, NontrivialType);
591  template <typename T, size_t FromSize>
592  void BM_PopBack(benchmark::State& state) {
593    BatchedBenchmark<T>(
594        state,
595        [](InlVec<T>* vec, size_t) {
596          vec->clear();
597          vec->resize(FromSize);
598        },
599        [](InlVec<T>* vec, size_t) { vec->pop_back(); });
600  }
601  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_PopBack, TrivialType);
602  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_PopBack, NontrivialType);
603  template <typename T, size_t FromSize>
604  void BM_EraseOne(benchmark::State& state) {
605    BatchedBenchmark<T>(
606        state,
607        [](InlVec<T>* vec, size_t) {
608          vec->clear();
609          vec->resize(FromSize);
610        },
611        [](InlVec<T>* vec, size_t) {
612          auto* pos = vec->data() + (vec->size() / 2);
613          vec->erase(pos);
614        });
615  }
616  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_EraseOne, TrivialType);
617  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_EraseOne, NontrivialType);
618  template <typename T, size_t FromSize>
619  void BM_EraseRange(benchmark::State& state) {
620    BatchedBenchmark<T>(
621        state,
622        [](InlVec<T>* vec, size_t) {
623          vec->clear();
624          vec->resize(FromSize);
625        },
626        [](InlVec<T>* vec, size_t) {
627          auto* pos = vec->data() + (vec->size() / 2);
628          vec->erase(pos, pos + 1);
629        });
630  }
631  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_EraseRange, TrivialType);
632  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_EraseRange, NontrivialType);
633  template <typename T, size_t FromSize>
634  void BM_Clear(benchmark::State& state) {
635    BatchedBenchmark<T>(
636        state,
637         [](InlVec<T>* vec, size_t) { vec->resize(FromSize); },
638         [](InlVec<T>* vec, size_t) { vec->clear(); });
639  }
640  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_Clear, TrivialType);
641  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_Clear, NontrivialType);
642  template <typename T, size_t FromSize, size_t ToCapacity>
643  void BM_Reserve(benchmark::State& state) {
644    BatchedBenchmark<T>(
645        state,
646        [](InlVec<T>* vec, size_t) {
647          vec->clear();
648          vec->resize(FromSize);
649        },
650        [](InlVec<T>* vec, size_t) { vec->reserve(ToCapacity); });
651  }
652  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_Reserve, TrivialType);
653  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_Reserve, NontrivialType);
654  template <typename T, size_t FromCapacity, size_t ToCapacity>
655  void BM_ShrinkToFit(benchmark::State& state) {
656    BatchedBenchmark<T>(
657        state,
658        [](InlVec<T>* vec, size_t) {
659          vec->clear();
660          vec->resize(ToCapacity);
661          vec->reserve(FromCapacity);
662        },
663         [](InlVec<T>* vec, size_t) { vec->shrink_to_fit(); });
664  }
665  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_ShrinkToFit, TrivialType);
666  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_ShrinkToFit, NontrivialType);
667  template <typename T, size_t FromSize, size_t ToSize>
668  void BM_Swap(benchmark::State& state) {
669    using VecT = InlVec<T>;
670    std::array<VecT, kBatchSize> vector_batch{};
671    BatchedBenchmark<T>(
672        state,
673        [&](InlVec<T>* vec, size_t i) {
674          vector_batch[i].clear();
675          vector_batch[i].resize(ToSize);
676          vec->resize(FromSize);
677        },
678        [&](InlVec<T>* vec, size_t i) {
679          using std::swap;
680          benchmark::DoNotOptimize(vector_batch[i]);
681          swap(*vec, vector_batch[i]);
682        });
683  }
684  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_Swap, TrivialType);
685  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_Swap, NontrivialType);
686  }  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-inlined_vector_benchmark.cc</h3>
            <pre><code>1  #include <array>
2  #include <string>
3  #include <vector>
4  #include "absl/base/internal/raw_logging.h"
5  #include "absl/base/macros.h"
6  #include "absl/container/inlined_vector.h"
7  #include "absl/strings/str_cat.h"
8  #include "benchmark/benchmark.h"
9  namespace {
10  void BM_InlinedVectorFill(benchmark::State& state) {
11    const int len = state.range(0);
12    absl::InlinedVector<int, 8> v;
13    v.reserve(len);
14    for (auto _ : state) {
15      v.resize(0);  
16      for (int i = 0; i < len; ++i) {
17        v.push_back(i);
18      }
19      benchmark::DoNotOptimize(v);
20    }
21  }
22  BENCHMARK(BM_InlinedVectorFill)->Range(1, 256);
23  void BM_InlinedVectorFillRange(benchmark::State& state) {
24    const int len = state.range(0);
25    const std::vector<int> src(len, len);
26    absl::InlinedVector<int, 8> v;
27    v.reserve(len);
28    for (auto _ : state) {
29      benchmark::DoNotOptimize(src);
30      v.assign(src.begin(), src.end());
31      benchmark::DoNotOptimize(v);
32    }
33  }
34  BENCHMARK(BM_InlinedVectorFillRange)->Range(1, 256);
35  void BM_StdVectorFill(benchmark::State& state) {
36    const int len = state.range(0);
37    std::vector<int> v;
38    v.reserve(len);
39    for (auto _ : state) {
40      v.clear();
41      for (int i = 0; i < len; ++i) {
42        v.push_back(i);
43      }
44      benchmark::DoNotOptimize(v);
45    }
46  }
47  BENCHMARK(BM_StdVectorFill)->Range(1, 256);
48  bool StringRepresentedInline(std::string s) {
49    const char* chars = s.data();
50    std::string s1 = std::move(s);
51    return s1.data() != chars;
52  }
53  int GetNonShortStringOptimizationSize() {
54    for (int i = 24; i <= 192; i *= 2) {
55      if (!StringRepresentedInline(std::string(i, 'A'))) {
56        return i;
57      }
58    }
59    ABSL_RAW_LOG(
60        FATAL,
61        "Failed to find a string larger than the short string optimization");
62    return -1;
63  }
64  void BM_InlinedVectorFillString(benchmark::State& state) {
65    const int len = state.range(0);
66    const int no_sso = GetNonShortStringOptimizationSize();
67    std::string strings[4] = {std::string(no_sso, 'A'), std::string(no_sso, 'B'),
68                              std::string(no_sso, 'C'), std::string(no_sso, 'D')};
69    for (auto _ : state) {
70      absl::InlinedVector<std::string, 8> v;
71      for (int i = 0; i < len; i++) {
72        v.push_back(strings[i & 3]);
73      }
74    }
75    state.SetItemsProcessed(static_cast<int64_t>(state.iterations()) * len);
76  }
77  BENCHMARK(BM_InlinedVectorFillString)->Range(0, 1024);
78  void BM_StdVectorFillString(benchmark::State& state) {
79    const int len = state.range(0);
80    const int no_sso = GetNonShortStringOptimizationSize();
81    std::string strings[4] = {std::string(no_sso, 'A'), std::string(no_sso, 'B'),
82                              std::string(no_sso, 'C'), std::string(no_sso, 'D')};
83    for (auto _ : state) {
84      std::vector<std::string> v;
85      for (int i = 0; i < len; i++) {
86        v.push_back(strings[i & 3]);
87      }
88    }
89    state.SetItemsProcessed(static_cast<int64_t>(state.iterations()) * len);
90  }
91  BENCHMARK(BM_StdVectorFillString)->Range(0, 1024);
92  struct Buffer {  
93    char* base;
94    int length;
95    int capacity;
96    void* user_data;
97  };
98  void BM_InlinedVectorAssignments(benchmark::State& state) {
99    const int len = state.range(0);
100    using BufferVec = absl::InlinedVector<Buffer, 2>;
101    BufferVec src;
102    src.resize(len);
103    BufferVec dst;
104    for (auto _ : state) {
105      benchmark::DoNotOptimize(dst);
106      benchmark::DoNotOptimize(src);
107      dst = src;
108    }
109  }
110  BENCHMARK(BM_InlinedVectorAssignments)
111      ->Arg(0)
112      ->Arg(1)
113      ->Arg(2)
114      ->Arg(3)
115      ->Arg(4)
116      ->Arg(20);
117  void BM_CreateFromContainer(benchmark::State& state) {
118    for (auto _ : state) {
119      absl::InlinedVector<int, 4> src{1, 2, 3};
120      benchmark::DoNotOptimize(src);
121      absl::InlinedVector<int, 4> dst(std::move(src));
122      benchmark::DoNotOptimize(dst);
123    }
124  }
125  BENCHMARK(BM_CreateFromContainer);
126  struct LargeCopyableOnly {
127    LargeCopyableOnly() : d(1024, 17) {}
128    LargeCopyableOnly(const LargeCopyableOnly& o) = default;
129    LargeCopyableOnly& operator=(const LargeCopyableOnly& o) = default;
130    std::vector<int> d;
131  };
132  struct LargeCopyableSwappable {
133    LargeCopyableSwappable() : d(1024, 17) {}
134    LargeCopyableSwappable(const LargeCopyableSwappable& o) = default;
135    LargeCopyableSwappable& operator=(LargeCopyableSwappable o) {
136      using std::swap;
137      swap(*this, o);
138      return *this;
139    }
140    friend void swap(LargeCopyableSwappable& a, LargeCopyableSwappable& b) {
141      using std::swap;
142      swap(a.d, b.d);
143    }
144    std::vector<int> d;
145  };
146  struct LargeCopyableMovable {
147    LargeCopyableMovable() : d(1024, 17) {}
148    std::vector<int> d;
149  };
150  struct LargeCopyableMovableSwappable {
151    LargeCopyableMovableSwappable() : d(1024, 17) {}
152    LargeCopyableMovableSwappable(const LargeCopyableMovableSwappable& o) =
153        default;
154    LargeCopyableMovableSwappable(LargeCopyableMovableSwappable&& o) = default;
155    LargeCopyableMovableSwappable& operator=(LargeCopyableMovableSwappable o) {
156      using std::swap;
157      swap(*this, o);
158      return *this;
159    }
160    LargeCopyableMovableSwappable& operator=(LargeCopyableMovableSwappable&& o) =
161        default;
162    friend void swap(LargeCopyableMovableSwappable& a,
163                     LargeCopyableMovableSwappable& b) {
164      using std::swap;
165      swap(a.d, b.d);
166    }
167    std::vector<int> d;
168  };
169  template <typename ElementType>
170  void BM_SwapElements(benchmark::State& state) {
<span onclick='openModal()' class='match'>171    const int len = state.range(0);
172    using Vec = absl::InlinedVector<ElementType, 32>;
173    Vec a(len);
</span>174    Vec b;
175    for (auto _ : state) {
176      using std::swap;
177      benchmark::DoNotOptimize(a);
178      benchmark::DoNotOptimize(b);
179      swap(a, b);
180    }
181  }
182  BENCHMARK_TEMPLATE(BM_SwapElements, LargeCopyableOnly)->Range(0, 1024);
183  BENCHMARK_TEMPLATE(BM_SwapElements, LargeCopyableSwappable)->Range(0, 1024);
184  BENCHMARK_TEMPLATE(BM_SwapElements, LargeCopyableMovable)->Range(0, 1024);
185  BENCHMARK_TEMPLATE(BM_SwapElements, LargeCopyableMovableSwappable)
186      ->Range(0, 1024);
187  template <typename VecType>
188  void BM_Sizeof(benchmark::State& state) {
189    int size = 0;
190    for (auto _ : state) {
191      VecType vec;
192      size = sizeof(vec);
193    }
194    state.SetLabel(absl::StrCat("sz=", size));
195  }
196  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<char, 1>);
197  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<char, 4>);
198  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<char, 7>);
199  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<char, 8>);
200  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<int, 1>);
201  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<int, 4>);
202  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<int, 7>);
203  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<int, 8>);
204  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<void*, 1>);
205  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<void*, 4>);
206  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<void*, 7>);
207  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<void*, 8>);
208  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<std::string, 1>);
209  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<std::string, 4>);
210  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<std::string, 7>);
211  BENCHMARK_TEMPLATE(BM_Sizeof, absl::InlinedVector<std::string, 8>);
212  void BM_InlinedVectorIndexInlined(benchmark::State& state) {
213    absl::InlinedVector<int, 8> v = {1, 2, 3, 4, 5, 6, 7};
214    for (auto _ : state) {
215      benchmark::DoNotOptimize(v);
216      benchmark::DoNotOptimize(v[4]);
217    }
218  }
219  BENCHMARK(BM_InlinedVectorIndexInlined);
220  void BM_InlinedVectorIndexExternal(benchmark::State& state) {
221    absl::InlinedVector<int, 8> v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
222    for (auto _ : state) {
223      benchmark::DoNotOptimize(v);
224      benchmark::DoNotOptimize(v[4]);
225    }
226  }
227  BENCHMARK(BM_InlinedVectorIndexExternal);
228  void BM_StdVectorIndex(benchmark::State& state) {
229    std::vector<int> v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
230    for (auto _ : state) {
231      benchmark::DoNotOptimize(v);
232      benchmark::DoNotOptimize(v[4]);
233    }
234  }
235  BENCHMARK(BM_StdVectorIndex);
236  void BM_InlinedVectorDataInlined(benchmark::State& state) {
237    absl::InlinedVector<int, 8> v = {1, 2, 3, 4, 5, 6, 7};
238    for (auto _ : state) {
239      benchmark::DoNotOptimize(v);
240      benchmark::DoNotOptimize(v.data());
241    }
242  }
243  BENCHMARK(BM_InlinedVectorDataInlined);
244  void BM_InlinedVectorDataExternal(benchmark::State& state) {
245    absl::InlinedVector<int, 8> v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
246    for (auto _ : state) {
247      benchmark::DoNotOptimize(v);
248      benchmark::DoNotOptimize(v.data());
249    }
250    state.SetItemsProcessed(16 * static_cast<int64_t>(state.iterations()));
251  }
252  BENCHMARK(BM_InlinedVectorDataExternal);
253  void BM_StdVectorData(benchmark::State& state) {
254    std::vector<int> v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
255    for (auto _ : state) {
256      benchmark::DoNotOptimize(v);
257      benchmark::DoNotOptimize(v.data());
258    }
259    state.SetItemsProcessed(16 * static_cast<int64_t>(state.iterations()));
260  }
261  BENCHMARK(BM_StdVectorData);
262  void BM_InlinedVectorSizeInlined(benchmark::State& state) {
263    absl::InlinedVector<int, 8> v = {1, 2, 3, 4, 5, 6, 7};
264    for (auto _ : state) {
265      benchmark::DoNotOptimize(v);
266      benchmark::DoNotOptimize(v.size());
267    }
268  }
269  BENCHMARK(BM_InlinedVectorSizeInlined);
270  void BM_InlinedVectorSizeExternal(benchmark::State& state) {
271    absl::InlinedVector<int, 8> v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
272    for (auto _ : state) {
273      benchmark::DoNotOptimize(v);
274      benchmark::DoNotOptimize(v.size());
275    }
276  }
277  BENCHMARK(BM_InlinedVectorSizeExternal);
278  void BM_StdVectorSize(benchmark::State& state) {
279    std::vector<int> v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
280    for (auto _ : state) {
281      benchmark::DoNotOptimize(v);
282      benchmark::DoNotOptimize(v.size());
283    }
284  }
285  BENCHMARK(BM_StdVectorSize);
286  void BM_InlinedVectorEmptyInlined(benchmark::State& state) {
287    absl::InlinedVector<int, 8> v = {1, 2, 3, 4, 5, 6, 7};
288    for (auto _ : state) {
289      benchmark::DoNotOptimize(v);
290      benchmark::DoNotOptimize(v.empty());
291    }
292  }
293  BENCHMARK(BM_InlinedVectorEmptyInlined);
294  void BM_InlinedVectorEmptyExternal(benchmark::State& state) {
295    absl::InlinedVector<int, 8> v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
296    for (auto _ : state) {
297      benchmark::DoNotOptimize(v);
298      benchmark::DoNotOptimize(v.empty());
299    }
300  }
301  BENCHMARK(BM_InlinedVectorEmptyExternal);
302  void BM_StdVectorEmpty(benchmark::State& state) {
303    std::vector<int> v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
304    for (auto _ : state) {
305      benchmark::DoNotOptimize(v);
306      benchmark::DoNotOptimize(v.empty());
307    }
308  }
309  BENCHMARK(BM_StdVectorEmpty);
310  constexpr size_t kInlinedCapacity = 4;
311  constexpr size_t kLargeSize = kInlinedCapacity * 2;
312  constexpr size_t kSmallSize = kInlinedCapacity / 2;
313  constexpr size_t kBatchSize = 100;
314  #define ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_FunctionTemplate, T) \
315    BENCHMARK_TEMPLATE(BM_FunctionTemplate, T, kLargeSize);        \
316    BENCHMARK_TEMPLATE(BM_FunctionTemplate, T, kSmallSize)
317  #define ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_FunctionTemplate, T)      \
318    BENCHMARK_TEMPLATE(BM_FunctionTemplate, T, kLargeSize, kLargeSize); \
319    BENCHMARK_TEMPLATE(BM_FunctionTemplate, T, kLargeSize, kSmallSize); \
320    BENCHMARK_TEMPLATE(BM_FunctionTemplate, T, kSmallSize, kLargeSize); \
321    BENCHMARK_TEMPLATE(BM_FunctionTemplate, T, kSmallSize, kSmallSize)
322  template <typename T>
323  using InlVec = absl::InlinedVector<T, kInlinedCapacity>;
324  struct TrivialType {
325    size_t val;
326  };
327  class NontrivialType {
328   public:
329    ABSL_ATTRIBUTE_NOINLINE NontrivialType() : val_() {
330      benchmark::DoNotOptimize(*this);
331    }
332    ABSL_ATTRIBUTE_NOINLINE NontrivialType(const NontrivialType& other)
333        : val_(other.val_) {
334      benchmark::DoNotOptimize(*this);
335    }
336    ABSL_ATTRIBUTE_NOINLINE NontrivialType& operator=(
337        const NontrivialType& other) {
338      val_ = other.val_;
339      benchmark::DoNotOptimize(*this);
340      return *this;
341    }
342    ABSL_ATTRIBUTE_NOINLINE ~NontrivialType() noexcept {
343      benchmark::DoNotOptimize(*this);
344    }
345   private:
346    size_t val_;
347  };
348  template <typename T, typename PrepareVecFn, typename TestVecFn>
349  void BatchedBenchmark(benchmark::State& state, PrepareVecFn prepare_vec,
350                        TestVecFn test_vec) {
351    std::array<InlVec<T>, kBatchSize> vector_batch{};
352    while (state.KeepRunningBatch(kBatchSize)) {
353      state.PauseTiming();
354      for (size_t i = 0; i < kBatchSize; ++i) {
355        prepare_vec(vector_batch.data() + i, i);
356      }
357      benchmark::DoNotOptimize(vector_batch);
358      state.ResumeTiming();
359      for (size_t i = 0; i < kBatchSize; ++i) {
360        test_vec(vector_batch.data() + i, i);
361      }
362    }
363  }
364  template <typename T, size_t ToSize>
365  void BM_ConstructFromSize(benchmark::State& state) {
366    using VecT = InlVec<T>;
367    auto size = ToSize;
368    BatchedBenchmark<T>(
369        state,
370         [](InlVec<T>* vec, size_t) { vec->~VecT(); },
371        [&](void* ptr, size_t) {
372          benchmark::DoNotOptimize(size);
373          ::new (ptr) VecT(size);
374        });
375  }
376  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromSize, TrivialType);
377  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromSize, NontrivialType);
378  template <typename T, size_t ToSize>
379  void BM_ConstructFromSizeRef(benchmark::State& state) {
380    using VecT = InlVec<T>;
381    auto size = ToSize;
382    auto ref = T();
383    BatchedBenchmark<T>(
384        state,
385         [](InlVec<T>* vec, size_t) { vec->~VecT(); },
386        [&](void* ptr, size_t) {
387          benchmark::DoNotOptimize(size);
388          benchmark::DoNotOptimize(ref);
389          ::new (ptr) VecT(size, ref);
390        });
391  }
392  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromSizeRef, TrivialType);
393  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromSizeRef, NontrivialType);
394  template <typename T, size_t ToSize>
395  void BM_ConstructFromRange(benchmark::State& state) {
396    using VecT = InlVec<T>;
397    std::array<T, ToSize> arr{};
398    BatchedBenchmark<T>(
399        state,
400         [](InlVec<T>* vec, size_t) { vec->~VecT(); },
401        [&](void* ptr, size_t) {
402          benchmark::DoNotOptimize(arr);
403          ::new (ptr) VecT(arr.begin(), arr.end());
404        });
405  }
406  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromRange, TrivialType);
407  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromRange, NontrivialType);
408  template <typename T, size_t ToSize>
409  void BM_ConstructFromCopy(benchmark::State& state) {
410    using VecT = InlVec<T>;
411    VecT other_vec(ToSize);
412    BatchedBenchmark<T>(
413        state,
414        [](InlVec<T>* vec, size_t) { vec->~VecT(); },
415        [&](void* ptr, size_t) {
416          benchmark::DoNotOptimize(other_vec);
417          ::new (ptr) VecT(other_vec);
418        });
419  }
420  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromCopy, TrivialType);
421  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromCopy, NontrivialType);
422  template <typename T, size_t ToSize>
423  void BM_ConstructFromMove(benchmark::State& state) {
424    using VecT = InlVec<T>;
425    std::array<VecT, kBatchSize> vector_batch{};
426    BatchedBenchmark<T>(
427        state,
428        [&](InlVec<T>* vec, size_t i) {
429          vector_batch[i].clear();
430          vector_batch[i].resize(ToSize);
431          vec->~VecT();
432        },
433        [&](void* ptr, size_t i) {
434          benchmark::DoNotOptimize(vector_batch[i]);
435          ::new (ptr) VecT(std::move(vector_batch[i]));
436        });
437  }
438  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromMove, TrivialType);
439  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_ConstructFromMove, NontrivialType);
440  void BM_CopyTrivial(benchmark::State& state) {
441    const int n = state.range(0);
442    InlVec<int64_t> src(n);
443    for (auto s : state) {
444      InlVec<int64_t> copy(src);
445      benchmark::DoNotOptimize(copy);
446    }
447  }
448  BENCHMARK(BM_CopyTrivial)->Arg(0)->Arg(1)->Arg(kLargeSize);
449  void BM_CopyNonTrivial(benchmark::State& state) {
450    const int n = state.range(0);
451    InlVec<InlVec<int64_t>> src(n);
452    for (auto s : state) {
453      InlVec<InlVec<int64_t>> copy(src);
454      benchmark::DoNotOptimize(copy);
455    }
456  }
457  BENCHMARK(BM_CopyNonTrivial)->Arg(0)->Arg(1)->Arg(kLargeSize);
458  template <typename T, size_t FromSize, size_t ToSize>
459  void BM_AssignSizeRef(benchmark::State& state) {
460    auto size = ToSize;
461    auto ref = T();
462    BatchedBenchmark<T>(
463        state,
464         [](InlVec<T>* vec, size_t) { vec->resize(FromSize); },
465        [&](InlVec<T>* vec, size_t) {
466          benchmark::DoNotOptimize(size);
467          benchmark::DoNotOptimize(ref);
468          vec->assign(size, ref);
469        });
470  }
471  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_AssignSizeRef, TrivialType);
472  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_AssignSizeRef, NontrivialType);
473  template <typename T, size_t FromSize, size_t ToSize>
474  void BM_AssignRange(benchmark::State& state) {
475    std::array<T, ToSize> arr{};
476    BatchedBenchmark<T>(
477        state,
478         [](InlVec<T>* vec, size_t) { vec->resize(FromSize); },
479        [&](InlVec<T>* vec, size_t) {
480          benchmark::DoNotOptimize(arr);
481          vec->assign(arr.begin(), arr.end());
482        });
483  }
484  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_AssignRange, TrivialType);
485  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_AssignRange, NontrivialType);
486  template <typename T, size_t FromSize, size_t ToSize>
487  void BM_AssignFromCopy(benchmark::State& state) {
488    InlVec<T> other_vec(ToSize);
489    BatchedBenchmark<T>(
490        state,
491         [](InlVec<T>* vec, size_t) { vec->resize(FromSize); },
492        [&](InlVec<T>* vec, size_t) {
493          benchmark::DoNotOptimize(other_vec);
494          *vec = other_vec;
495        });
496  }
497  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_AssignFromCopy, TrivialType);
498  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_AssignFromCopy, NontrivialType);
499  template <typename T, size_t FromSize, size_t ToSize>
500  void BM_AssignFromMove(benchmark::State& state) {
501    using VecT = InlVec<T>;
502    std::array<VecT, kBatchSize> vector_batch{};
503    BatchedBenchmark<T>(
504        state,
505        [&](InlVec<T>* vec, size_t i) {
506          vector_batch[i].clear();
507          vector_batch[i].resize(ToSize);
508          vec->resize(FromSize);
509        },
510        [&](InlVec<T>* vec, size_t i) {
511          benchmark::DoNotOptimize(vector_batch[i]);
512          *vec = std::move(vector_batch[i]);
513        });
514  }
515  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_AssignFromMove, TrivialType);
516  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_AssignFromMove, NontrivialType);
517  template <typename T, size_t FromSize, size_t ToSize>
518  void BM_ResizeSize(benchmark::State& state) {
519    BatchedBenchmark<T>(
520        state,
521        [](InlVec<T>* vec, size_t) {
522          vec->clear();
523          vec->resize(FromSize);
524        },
525        [](InlVec<T>* vec, size_t) { vec->resize(ToSize); });
526  }
527  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_ResizeSize, TrivialType);
528  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_ResizeSize, NontrivialType);
529  template <typename T, size_t FromSize, size_t ToSize>
530  void BM_ResizeSizeRef(benchmark::State& state) {
531    auto t = T();
532    BatchedBenchmark<T>(
533        state,
534        [](InlVec<T>* vec, size_t) {
535          vec->clear();
536          vec->resize(FromSize);
537        },
538        [&](InlVec<T>* vec, size_t) {
539          benchmark::DoNotOptimize(t);
540          vec->resize(ToSize, t);
541        });
542  }
543  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_ResizeSizeRef, TrivialType);
544  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_ResizeSizeRef, NontrivialType);
545  template <typename T, size_t FromSize, size_t ToSize>
546  void BM_InsertSizeRef(benchmark::State& state) {
547    auto t = T();
548    BatchedBenchmark<T>(
549        state,
550        [](InlVec<T>* vec, size_t) {
551          vec->clear();
552          vec->resize(FromSize);
553        },
554        [&](InlVec<T>* vec, size_t) {
555          benchmark::DoNotOptimize(t);
556          auto* pos = vec->data() + (vec->size() / 2);
557          vec->insert(pos, t);
558        });
559  }
560  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_InsertSizeRef, TrivialType);
561  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_InsertSizeRef, NontrivialType);
562  template <typename T, size_t FromSize, size_t ToSize>
563  void BM_InsertRange(benchmark::State& state) {
564    InlVec<T> other_vec(ToSize);
565    BatchedBenchmark<T>(
566        state,
567        [](InlVec<T>* vec, size_t) {
568          vec->clear();
569          vec->resize(FromSize);
570        },
571        [&](InlVec<T>* vec, size_t) {
572          benchmark::DoNotOptimize(other_vec);
573          auto* pos = vec->data() + (vec->size() / 2);
574          vec->insert(pos, other_vec.begin(), other_vec.end());
575        });
576  }
577  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_InsertRange, TrivialType);
578  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_InsertRange, NontrivialType);
579  template <typename T, size_t FromSize>
580  void BM_EmplaceBack(benchmark::State& state) {
581    BatchedBenchmark<T>(
582        state,
583        [](InlVec<T>* vec, size_t) {
584          vec->clear();
585          vec->resize(FromSize);
586        },
587        [](InlVec<T>* vec, size_t) { vec->emplace_back(); });
588  }
589  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_EmplaceBack, TrivialType);
590  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_EmplaceBack, NontrivialType);
591  template <typename T, size_t FromSize>
592  void BM_PopBack(benchmark::State& state) {
593    BatchedBenchmark<T>(
594        state,
595        [](InlVec<T>* vec, size_t) {
596          vec->clear();
597          vec->resize(FromSize);
598        },
599        [](InlVec<T>* vec, size_t) { vec->pop_back(); });
600  }
601  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_PopBack, TrivialType);
602  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_PopBack, NontrivialType);
603  template <typename T, size_t FromSize>
604  void BM_EraseOne(benchmark::State& state) {
605    BatchedBenchmark<T>(
606        state,
607        [](InlVec<T>* vec, size_t) {
608          vec->clear();
609          vec->resize(FromSize);
610        },
611        [](InlVec<T>* vec, size_t) {
612          auto* pos = vec->data() + (vec->size() / 2);
613          vec->erase(pos);
614        });
615  }
616  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_EraseOne, TrivialType);
617  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_EraseOne, NontrivialType);
618  template <typename T, size_t FromSize>
619  void BM_EraseRange(benchmark::State& state) {
620    BatchedBenchmark<T>(
621        state,
622        [](InlVec<T>* vec, size_t) {
623          vec->clear();
624          vec->resize(FromSize);
625        },
626        [](InlVec<T>* vec, size_t) {
627          auto* pos = vec->data() + (vec->size() / 2);
628          vec->erase(pos, pos + 1);
629        });
630  }
631  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_EraseRange, TrivialType);
632  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_EraseRange, NontrivialType);
633  template <typename T, size_t FromSize>
634  void BM_Clear(benchmark::State& state) {
635    BatchedBenchmark<T>(
636        state,
637         [](InlVec<T>* vec, size_t) { vec->resize(FromSize); },
638         [](InlVec<T>* vec, size_t) { vec->clear(); });
639  }
640  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_Clear, TrivialType);
641  ABSL_INTERNAL_BENCHMARK_ONE_SIZE(BM_Clear, NontrivialType);
642  template <typename T, size_t FromSize, size_t ToCapacity>
643  void BM_Reserve(benchmark::State& state) {
644    BatchedBenchmark<T>(
645        state,
646        [](InlVec<T>* vec, size_t) {
647          vec->clear();
648          vec->resize(FromSize);
649        },
650        [](InlVec<T>* vec, size_t) { vec->reserve(ToCapacity); });
651  }
652  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_Reserve, TrivialType);
653  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_Reserve, NontrivialType);
654  template <typename T, size_t FromCapacity, size_t ToCapacity>
655  void BM_ShrinkToFit(benchmark::State& state) {
656    BatchedBenchmark<T>(
657        state,
658        [](InlVec<T>* vec, size_t) {
659          vec->clear();
660          vec->resize(ToCapacity);
661          vec->reserve(FromCapacity);
662        },
663         [](InlVec<T>* vec, size_t) { vec->shrink_to_fit(); });
664  }
665  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_ShrinkToFit, TrivialType);
666  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_ShrinkToFit, NontrivialType);
667  template <typename T, size_t FromSize, size_t ToSize>
668  void BM_Swap(benchmark::State& state) {
669    using VecT = InlVec<T>;
670    std::array<VecT, kBatchSize> vector_batch{};
671    BatchedBenchmark<T>(
672        state,
673        [&](InlVec<T>* vec, size_t i) {
674          vector_batch[i].clear();
675          vector_batch[i].resize(ToSize);
676          vec->resize(FromSize);
677        },
678        [&](InlVec<T>* vec, size_t i) {
679          using std::swap;
680          benchmark::DoNotOptimize(vector_batch[i]);
681          swap(*vec, vector_batch[i]);
682        });
683  }
684  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_Swap, TrivialType);
685  ABSL_INTERNAL_BENCHMARK_TWO_SIZE(BM_Swap, NontrivialType);
686  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-inlined_vector_benchmark.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-inlined_vector_benchmark.cc</div>
                </div>
                <div class="column column_space"><pre><code>171    const int len = state.range(0);
172    using Vec = absl::InlinedVector<ElementType, 32>;
173    Vec a(len);
</pre></code></div>
                <div class="column column_space"><pre><code>171    const int len = state.range(0);
172    using Vec = absl::InlinedVector<ElementType, 32>;
173    Vec a(len);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    