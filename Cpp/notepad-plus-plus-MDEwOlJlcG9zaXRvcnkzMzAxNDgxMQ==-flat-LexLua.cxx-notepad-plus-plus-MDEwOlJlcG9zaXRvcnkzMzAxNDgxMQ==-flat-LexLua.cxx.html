
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexLua.cxx</h3>
            <pre><code>1  #include <stdlib.h>
2  #include <string.h>
3  #include <stdio.h>
4  #include <stdarg.h>
5  #include <assert.h>
6  #include <ctype.h>
7  #include <string>
8  #include <string_view>
9  #include "ILexer.h"
10  #include "Scintilla.h"
11  #include "SciLexer.h"
12  #include "StringCopy.h"
13  #include "WordList.h"
14  #include "LexAccessor.h"
15  #include "Accessor.h"
16  #include "StyleContext.h"
17  #include "CharacterSet.h"
18  #include "LexerModule.h"
19  using namespace Lexilla;
20  static int LongDelimCheck(StyleContext &sc) {
21  	int sep = 1;
22  	while (sc.GetRelative(sep) == '=' && sep < 0xFF)
23  		sep++;
24  	if (sc.GetRelative(sep) == sc.ch)
25  		return sep;
26  	return 0;
27  }
28  static void ColouriseLuaDoc(
29  	Sci_PositionU startPos,
30  	Sci_Position length,
31  	int initStyle,
32  	WordList *keywordlists[],
33  	Accessor &styler) {
34  	const WordList &keywords = *keywordlists[0];
35  	const WordList &keywords2 = *keywordlists[1];
36  	const WordList &keywords3 = *keywordlists[2];
37  	const WordList &keywords4 = *keywordlists[3];
38  	const WordList &keywords5 = *keywordlists[4];
39  	const WordList &keywords6 = *keywordlists[5];
40  	const WordList &keywords7 = *keywordlists[6];
41  	const WordList &keywords8 = *keywordlists[7];
42  	CharacterSet setWordStart(CharacterSet::setAlpha, "_", true);
43  	CharacterSet setWord(CharacterSet::setAlphaNum, "_", true);
44  	CharacterSet setNumber(CharacterSet::setDigits, ".-+abcdefpABCDEFP");
45  	CharacterSet setExponent("eEpP");
46  	CharacterSet setLuaOperator("*/-+()={}~[];<>,.^%:#&|");
47  	CharacterSet setEscapeSkip("\"'\\");
48  	Sci_Position currentLine = styler.GetLine(startPos);
49  	int sepCount = 0;
50  	int stringWs = 0;
51  	if (initStyle == SCE_LUA_LITERALSTRING || initStyle == SCE_LUA_COMMENT ||
52  		initStyle == SCE_LUA_STRING || initStyle == SCE_LUA_CHARACTER) {
53  		const int lineState = styler.GetLineState(currentLine - 1);
54  		sepCount = lineState & 0xFF;
55  		stringWs = lineState & 0x100;
56  	}
57  	Sci_Position idenPos = 0;
58  	Sci_Position idenWordPos = 0;
59  	int idenStyle = SCE_LUA_IDENTIFIER;
60  	bool foundGoto = false;
61  	if (initStyle == SCE_LUA_STRINGEOL || initStyle == SCE_LUA_COMMENTLINE || initStyle == SCE_LUA_PREPROCESSOR) {
62  		initStyle = SCE_LUA_DEFAULT;
63  	}
64  	StyleContext sc(startPos, length, initStyle, styler);
65  	if (startPos == 0 && sc.ch == '#' && sc.chNext == '!') {
66  		sc.SetState(SCE_LUA_COMMENTLINE);
67  	}
68  	for (; sc.More(); sc.Forward()) {
69  		if (sc.atLineEnd) {
70  			currentLine = styler.GetLine(sc.currentPos);
71  			switch (sc.state) {
72  			case SCE_LUA_LITERALSTRING:
73  			case SCE_LUA_COMMENT:
74  			case SCE_LUA_STRING:
75  			case SCE_LUA_CHARACTER:
76  				styler.SetLineState(currentLine, stringWs | sepCount);
77  				break;
78  			default:
79  				styler.SetLineState(currentLine, 0);
80  				break;
81  			}
82  		}
83  		if (sc.atLineStart && (sc.state == SCE_LUA_STRING)) {
84  			sc.SetState(SCE_LUA_STRING);
85  		}
86  		if ((sc.state == SCE_LUA_STRING || sc.state == SCE_LUA_CHARACTER) &&
87  				sc.ch == '\\') {
88  			if (sc.chNext == '\n' || sc.chNext == '\r') {
89  				sc.Forward();
90  				if (sc.ch == '\r' && sc.chNext == '\n') {
91  					sc.Forward();
92  				}
93  				continue;
94  			}
95  		}
96  		if (sc.state == SCE_LUA_OPERATOR) {
97  			if (sc.ch == ':' && sc.chPrev == ':') {	
98  				sc.Forward();
99  				Sci_Position ln = 0;
100  				while (IsASpaceOrTab(sc.GetRelative(ln)))	
101  					ln++;
102  				Sci_Position ws1 = ln;
103  				if (setWordStart.Contains(sc.GetRelative(ln))) {
104  					int c, i = 0;
105  					char s[100];
106  					while (setWord.Contains(c = sc.GetRelative(ln))) {	
107  						if (i < 90)
108  							s[i++] = static_cast<char>(c);
109  						ln++;
110  					}
111  					s[i] = '\0'; Sci_Position lbl = ln;
112  					if (!keywords.InList(s)) {
113  						while (IsASpaceOrTab(sc.GetRelative(ln)))	
114  							ln++;
115  						Sci_Position ws2 = ln - lbl;
116  						if (sc.GetRelative(ln) == ':' && sc.GetRelative(ln + 1) == ':') {
117  							sc.ChangeState(SCE_LUA_LABEL);
118  							if (ws1) {
119  								sc.SetState(SCE_LUA_DEFAULT);
120  								sc.ForwardBytes(ws1);
121  							}
122  							sc.SetState(SCE_LUA_LABEL);
123  							sc.ForwardBytes(lbl - ws1);
124  							if (ws2) {
125  								sc.SetState(SCE_LUA_DEFAULT);
126  								sc.ForwardBytes(ws2);
127  							}
128  							sc.SetState(SCE_LUA_LABEL);
129  							sc.ForwardBytes(2);
130  						}
131  					}
132  				}
133  			}
134  			sc.SetState(SCE_LUA_DEFAULT);
135  		} else if (sc.state == SCE_LUA_NUMBER) {
136  			if (!setNumber.Contains(sc.ch)) {
137  				sc.SetState(SCE_LUA_DEFAULT);
138  			} else if (sc.ch == '-' || sc.ch == '+') {
139  				if (!setExponent.Contains(sc.chPrev))
140  					sc.SetState(SCE_LUA_DEFAULT);
141  			}
142  		} else if (sc.state == SCE_LUA_IDENTIFIER) {
143  			idenPos--;			
144  			if (idenWordPos > 0) {
145  				idenWordPos--;
146  				sc.ChangeState(idenStyle);
147  				sc.ForwardBytes(idenWordPos);
148  				idenPos -= idenWordPos;
149  				if (idenPos > 0) {
150  					sc.SetState(SCE_LUA_IDENTIFIER);
151  					sc.ForwardBytes(idenPos);
152  				}
153  			} else {
154  				sc.ForwardBytes(idenPos);
155  			}
156  			sc.SetState(SCE_LUA_DEFAULT);
157  			if (foundGoto) {					
158  				while (IsASpaceOrTab(sc.ch) && !sc.atLineEnd)
159  					sc.Forward();
160  				if (setWordStart.Contains(sc.ch)) {
161  					sc.SetState(SCE_LUA_LABEL);
162  					sc.Forward();
163  					while (setWord.Contains(sc.ch))
164  						sc.Forward();
165  					char s[100];
166  					sc.GetCurrent(s, sizeof(s));
167  					if (keywords.InList(s))		
168  						sc.ChangeState(SCE_LUA_WORD);
169  				}
170  				sc.SetState(SCE_LUA_DEFAULT);
171  			}
172  		} else if (sc.state == SCE_LUA_COMMENTLINE || sc.state == SCE_LUA_PREPROCESSOR) {
173  			if (sc.atLineEnd) {
174  				sc.ForwardSetState(SCE_LUA_DEFAULT);
175  			}
176  		} else if (sc.state == SCE_LUA_STRING) {
177  			if (stringWs) {
178  				if (!IsASpace(sc.ch))
179  					stringWs = 0;
180  			}
181  			if (sc.ch == '\\') {
182  				if (setEscapeSkip.Contains(sc.chNext)) {
183  					sc.Forward();
184  				} else if (sc.chNext == 'z') {
185  					sc.Forward();
186  					stringWs = 0x100;
187  				}
188  			} else if (sc.ch == '\"') {
189  				sc.ForwardSetState(SCE_LUA_DEFAULT);
190  			} else if (stringWs == 0 && sc.atLineEnd) {
191  				sc.ChangeState(SCE_LUA_STRINGEOL);
192  				sc.ForwardSetState(SCE_LUA_DEFAULT);
193  			}
194  		} else if (sc.state == SCE_LUA_CHARACTER) {
195  			if (stringWs) {
196  				if (!IsASpace(sc.ch))
197  					stringWs = 0;
198  			}
199  			if (sc.ch == '\\') {
200  				if (setEscapeSkip.Contains(sc.chNext)) {
201  					sc.Forward();
202  				} else if (sc.chNext == 'z') {
203  					sc.Forward();
204  					stringWs = 0x100;
205  				}
206  			} else if (sc.ch == '\'') {
207  				sc.ForwardSetState(SCE_LUA_DEFAULT);
208  			} else if (stringWs == 0 && sc.atLineEnd) {
209  				sc.ChangeState(SCE_LUA_STRINGEOL);
210  				sc.ForwardSetState(SCE_LUA_DEFAULT);
211  			}
212  		} else if (sc.ch == ']' && (sc.state == SCE_LUA_LITERALSTRING || sc.state == SCE_LUA_COMMENT)) {
213  			const int sep = LongDelimCheck(sc);
214  			if (sep == sepCount) {   
215  				sc.Forward(sep);
216  				sc.ForwardSetState(SCE_LUA_DEFAULT);
217  			}
218  		}
219  		if (sc.state == SCE_LUA_DEFAULT) {
220  			if (IsADigit(sc.ch) || (sc.ch == '.' && IsADigit(sc.chNext))) {
221  				sc.SetState(SCE_LUA_NUMBER);
222  				if (sc.ch == '0' && toupper(sc.chNext) == 'X') {
223  					sc.Forward();
224  				}
225  			} else if (setWordStart.Contains(sc.ch)) {
226  				std::string ident;
227  				idenPos = 0;
228  				idenWordPos = 0;
229  				idenStyle = SCE_LUA_IDENTIFIER;
230  				foundGoto = false;
231  				int cNext;
232  				do {
233  					int c;
234  					const Sci_Position idenPosOld = idenPos;
235  					std::string identSeg;
236  					identSeg += static_cast<char>(sc.GetRelative(idenPos++));
237  					while (setWord.Contains(c = sc.GetRelative(idenPos))) {
238  						identSeg += static_cast<char>(c);
239  						idenPos++;
240  					}
241  					if (keywords.InList(identSeg.c_str()) && (idenPosOld > 0)) {
242  						idenPos = idenPosOld - 1;	
243  						ident.pop_back();
244  						break;
245  					}
246  					ident += identSeg;
247  					const char* s = ident.c_str();
248  					int newStyle = SCE_LUA_IDENTIFIER;
249  					if (keywords.InList(s)) {
250  						newStyle = SCE_LUA_WORD;
251  					} else if (keywords2.InList(s)) {
252  						newStyle = SCE_LUA_WORD2;
253  					} else if (keywords3.InList(s)) {
254  						newStyle = SCE_LUA_WORD3;
255  					} else if (keywords4.InList(s)) {
256  						newStyle = SCE_LUA_WORD4;
257  					} else if (keywords5.InList(s)) {
258  						newStyle = SCE_LUA_WORD5;
259  					} else if (keywords6.InList(s)) {
260  						newStyle = SCE_LUA_WORD6;
261  					} else if (keywords7.InList(s)) {
262  						newStyle = SCE_LUA_WORD7;
263  					} else if (keywords8.InList(s)) {
264  						newStyle = SCE_LUA_WORD8;
265  					}
266  					if (newStyle != SCE_LUA_IDENTIFIER) {
267  						idenStyle = newStyle;
268  						idenWordPos = idenPos;
269  					}
270  					if (idenStyle == SCE_LUA_WORD)	
271  						break;
272  					cNext = sc.GetRelative(idenPos + 1);
273  					if ((c == '.' || c == ':') && setWordStart.Contains(cNext)) {
274  						ident += static_cast<char>(c);
275  						idenPos++;
276  					} else {
277  						cNext = 0;
278  					}
279  				} while (cNext);
280  				if ((idenStyle == SCE_LUA_WORD) && (ident.compare("goto") == 0)) {
281  					foundGoto = true;
282  				}
283  				sc.SetState(SCE_LUA_IDENTIFIER);
284  			} else if (sc.ch == '\"') {
285  				sc.SetState(SCE_LUA_STRING);
286  				stringWs = 0;
287  			} else if (sc.ch == '\'') {
288  				sc.SetState(SCE_LUA_CHARACTER);
289  				stringWs = 0;
290  			} else if (sc.ch == '[') {
291  				sepCount = LongDelimCheck(sc);
292  				if (sepCount == 0) {
293  					sc.SetState(SCE_LUA_OPERATOR);
294  				} else {
295  					sc.SetState(SCE_LUA_LITERALSTRING);
296  					sc.Forward(sepCount);
297  				}
298  			} else if (sc.Match('-', '-')) {
299  				sc.SetState(SCE_LUA_COMMENTLINE);
300  				if (sc.Match("--[")) {
301  					sc.Forward(2);
302  					sepCount = LongDelimCheck(sc);
303  					if (sepCount > 0) {
304  						sc.ChangeState(SCE_LUA_COMMENT);
305  						sc.Forward(sepCount);
306  					}
307  				} else {
308  					sc.Forward();
309  				}
310  			} else if (sc.atLineStart && sc.Match('$')) {
311  				sc.SetState(SCE_LUA_PREPROCESSOR);	
312  			} else if (setLuaOperator.Contains(sc.ch)) {
313  				sc.SetState(SCE_LUA_OPERATOR);
314  			}
315  		}
316  	}
317  	sc.Complete();
318  }
319  static void FoldLuaDoc(Sci_PositionU startPos, Sci_Position length, int initStyle, WordList *[],
320                         Accessor &styler) {
321  	const Sci_PositionU lengthDoc = startPos + length;
322  	int visibleChars = 0;
323  	Sci_Position lineCurrent = styler.GetLine(startPos);
324  	int levelPrev = styler.LevelAt(lineCurrent) & SC_FOLDLEVELNUMBERMASK;
325  	int levelCurrent = levelPrev;
326  	char chNext = styler[startPos];
327  	const bool foldCompact = styler.GetPropertyInt("fold.compact", 1) != 0;
328  	int style = initStyle;
329  	int styleNext = styler.StyleAt(startPos);
330  	for (Sci_PositionU i = startPos; i < lengthDoc; i++) {
331  		const char ch = chNext;
332  		chNext = styler.SafeGetCharAt(i + 1);
333  		const int stylePrev = style;
334  		style = styleNext;
335  		styleNext = styler.StyleAt(i + 1);
336  		const bool atEOL = (ch == '\r' && chNext != '\n') || (ch == '\n');
337  		if (style == SCE_LUA_WORD) {
338  			if (ch == 'i' || ch == 'd' || ch == 'f' || ch == 'e' || ch == 'r' || ch == 'u') {
339  				char s[10] = "";
340  				for (Sci_PositionU j = 0; j < 8; j++) {
341  					if (!iswordchar(styler[i + j])) {
342  						break;
343  					}
344  					s[j] = styler[i + j];
345  					s[j + 1] = '\0';
346  				}
347  				if ((strcmp(s, "if") == 0) || (strcmp(s, "do") == 0) || (strcmp(s, "function") == 0) || (strcmp(s, "repeat") == 0)) {
348  					levelCurrent++;
349  				}
350  				if ((strcmp(s, "end") == 0) || (strcmp(s, "elseif") == 0) || (strcmp(s, "until") == 0)) {
351  					levelCurrent--;
352  				}
353  			}
354  		} else if (style == SCE_LUA_OPERATOR) {
355  			if (ch == '{' || ch == '(') {
356  				levelCurrent++;
357  			} else if (ch == '}' || ch == ')') {
358  				levelCurrent--;
359  			}
360  		} else if (style == SCE_LUA_LITERALSTRING || style == SCE_LUA_COMMENT) {
361  			if (stylePrev != style) {
<span onclick='openModal()' class='match'>362  				levelCurrent++;
363  			} else if (styleNext != style) {
364  				levelCurrent--;
365  			}
366  		}
367  		if (atEOL) {
</span>368  			int lev = levelPrev;
369  			if (visibleChars == 0 && foldCompact) {
370  				lev |= SC_FOLDLEVELWHITEFLAG;
371  			}
372  			if ((levelCurrent > levelPrev) && (visibleChars > 0)) {
373  				lev |= SC_FOLDLEVELHEADERFLAG;
374  			}
375  			if (lev != styler.LevelAt(lineCurrent)) {
376  				styler.SetLevel(lineCurrent, lev);
377  			}
378  			lineCurrent++;
379  			levelPrev = levelCurrent;
380  			visibleChars = 0;
381  		}
382  		if (!isspacechar(ch)) {
383  			visibleChars++;
384  		}
385  	}
386  	int flagsNext = styler.LevelAt(lineCurrent) & ~SC_FOLDLEVELNUMBERMASK;
387  	styler.SetLevel(lineCurrent, levelPrev | flagsNext);
388  }
389  static const char * const luaWordListDesc[] = {
390  	"Keywords",
391  	"Basic functions",
392  	"String, (table) & math functions",
393  	"(coroutines), I/O & system facilities",
394  	"user1",
395  	"user2",
396  	"user3",
397  	"user4",
398  	0
399  };
400  namespace {
401  LexicalClass lexicalClasses[] = {
402  	0, "SCE_LUA_DEFAULT", "default", "White space: Visible only in View Whitespace mode (or if it has a back colour)",
403  	1, "SCE_LUA_COMMENT", "comment", "Block comment (Lua 5.0)",
404  	2, "SCE_LUA_COMMENTLINE", "comment line", "Line comment",
405  	3, "SCE_LUA_COMMENTDOC", "comment documentation", "Doc comment -- Not used in Lua (yet?)",
406  	4, "SCE_LUA_NUMBER", "literal numeric", "Number",
407  	5, "SCE_LUA_WORD", "keyword", "Keyword",
408  	6, "SCE_LUA_STRING", "literal string", "(Double quoted) String",
409  	7, "SCE_LUA_CHARACTER", "literal string character", "Character (Single quoted string)",
410  	8, "SCE_LUA_LITERALSTRING", "literal string", "Literal string",
411  	9, "SCE_LUA_PREPROCESSOR", "preprocessor", "Preprocessor (obsolete in Lua 4.0 and up)",
412  	10, "SCE_LUA_OPERATOR", "operator", "Operators",
413  	11, "SCE_LUA_IDENTIFIER", "identifier", "Identifier (everything else...)",
414  	12, "SCE_LUA_STRINGEOL", "error literal string", "End of line where string is not closed",
415  	13, "SCE_LUA_WORD2", "identifier", "Other keywords",
416  	14, "SCE_LUA_WORD3", "identifier", "Other keywords",
417  	15, "SCE_LUA_WORD4", "identifier", "Other keywords",
418  	16, "SCE_LUA_WORD5", "identifier", "Other keywords",
419  	17, "SCE_LUA_WORD6", "identifier", "Other keywords",
420  	18, "SCE_LUA_WORD7", "identifier", "Other keywords",
421  	19, "SCE_LUA_WORD8", "identifier", "Other keywords",
422  	20, "SCE_LUA_LABEL", "label", "Labels",
423  };
424  }
425  LexerModule lmLua(SCLEX_LUA, ColouriseLuaDoc, "lua", FoldLuaDoc, luaWordListDesc, lexicalClasses, ELEMENTS(lexicalClasses));
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexLua.cxx</h3>
            <pre><code>1  #include <stdlib.h>
2  #include <string.h>
3  #include <stdio.h>
4  #include <stdarg.h>
5  #include <assert.h>
6  #include <ctype.h>
7  #include <string>
8  #include <string_view>
9  #include "ILexer.h"
10  #include "Scintilla.h"
11  #include "SciLexer.h"
12  #include "StringCopy.h"
13  #include "WordList.h"
14  #include "LexAccessor.h"
15  #include "Accessor.h"
16  #include "StyleContext.h"
17  #include "CharacterSet.h"
18  #include "LexerModule.h"
19  using namespace Lexilla;
20  static int LongDelimCheck(StyleContext &sc) {
21  	int sep = 1;
22  	while (sc.GetRelative(sep) == '=' && sep < 0xFF)
23  		sep++;
24  	if (sc.GetRelative(sep) == sc.ch)
25  		return sep;
26  	return 0;
27  }
28  static void ColouriseLuaDoc(
29  	Sci_PositionU startPos,
30  	Sci_Position length,
31  	int initStyle,
32  	WordList *keywordlists[],
33  	Accessor &styler) {
34  	const WordList &keywords = *keywordlists[0];
35  	const WordList &keywords2 = *keywordlists[1];
36  	const WordList &keywords3 = *keywordlists[2];
37  	const WordList &keywords4 = *keywordlists[3];
38  	const WordList &keywords5 = *keywordlists[4];
39  	const WordList &keywords6 = *keywordlists[5];
40  	const WordList &keywords7 = *keywordlists[6];
41  	const WordList &keywords8 = *keywordlists[7];
42  	CharacterSet setWordStart(CharacterSet::setAlpha, "_", true);
43  	CharacterSet setWord(CharacterSet::setAlphaNum, "_", true);
44  	CharacterSet setNumber(CharacterSet::setDigits, ".-+abcdefpABCDEFP");
45  	CharacterSet setExponent("eEpP");
46  	CharacterSet setLuaOperator("*/-+()={}~[];<>,.^%:#&|");
47  	CharacterSet setEscapeSkip("\"'\\");
48  	Sci_Position currentLine = styler.GetLine(startPos);
49  	int sepCount = 0;
50  	int stringWs = 0;
51  	if (initStyle == SCE_LUA_LITERALSTRING || initStyle == SCE_LUA_COMMENT ||
52  		initStyle == SCE_LUA_STRING || initStyle == SCE_LUA_CHARACTER) {
53  		const int lineState = styler.GetLineState(currentLine - 1);
54  		sepCount = lineState & 0xFF;
55  		stringWs = lineState & 0x100;
56  	}
57  	Sci_Position idenPos = 0;
58  	Sci_Position idenWordPos = 0;
59  	int idenStyle = SCE_LUA_IDENTIFIER;
60  	bool foundGoto = false;
61  	if (initStyle == SCE_LUA_STRINGEOL || initStyle == SCE_LUA_COMMENTLINE || initStyle == SCE_LUA_PREPROCESSOR) {
62  		initStyle = SCE_LUA_DEFAULT;
63  	}
64  	StyleContext sc(startPos, length, initStyle, styler);
65  	if (startPos == 0 && sc.ch == '#' && sc.chNext == '!') {
66  		sc.SetState(SCE_LUA_COMMENTLINE);
67  	}
68  	for (; sc.More(); sc.Forward()) {
69  		if (sc.atLineEnd) {
70  			currentLine = styler.GetLine(sc.currentPos);
71  			switch (sc.state) {
72  			case SCE_LUA_LITERALSTRING:
73  			case SCE_LUA_COMMENT:
74  			case SCE_LUA_STRING:
75  			case SCE_LUA_CHARACTER:
76  				styler.SetLineState(currentLine, stringWs | sepCount);
77  				break;
78  			default:
79  				styler.SetLineState(currentLine, 0);
80  				break;
81  			}
82  		}
83  		if (sc.atLineStart && (sc.state == SCE_LUA_STRING)) {
84  			sc.SetState(SCE_LUA_STRING);
85  		}
86  		if ((sc.state == SCE_LUA_STRING || sc.state == SCE_LUA_CHARACTER) &&
87  				sc.ch == '\\') {
88  			if (sc.chNext == '\n' || sc.chNext == '\r') {
89  				sc.Forward();
90  				if (sc.ch == '\r' && sc.chNext == '\n') {
91  					sc.Forward();
92  				}
93  				continue;
94  			}
95  		}
96  		if (sc.state == SCE_LUA_OPERATOR) {
97  			if (sc.ch == ':' && sc.chPrev == ':') {	
98  				sc.Forward();
99  				Sci_Position ln = 0;
100  				while (IsASpaceOrTab(sc.GetRelative(ln)))	
101  					ln++;
102  				Sci_Position ws1 = ln;
103  				if (setWordStart.Contains(sc.GetRelative(ln))) {
104  					int c, i = 0;
105  					char s[100];
106  					while (setWord.Contains(c = sc.GetRelative(ln))) {	
107  						if (i < 90)
108  							s[i++] = static_cast<char>(c);
109  						ln++;
110  					}
111  					s[i] = '\0'; Sci_Position lbl = ln;
112  					if (!keywords.InList(s)) {
113  						while (IsASpaceOrTab(sc.GetRelative(ln)))	
114  							ln++;
115  						Sci_Position ws2 = ln - lbl;
116  						if (sc.GetRelative(ln) == ':' && sc.GetRelative(ln + 1) == ':') {
117  							sc.ChangeState(SCE_LUA_LABEL);
118  							if (ws1) {
119  								sc.SetState(SCE_LUA_DEFAULT);
120  								sc.ForwardBytes(ws1);
121  							}
122  							sc.SetState(SCE_LUA_LABEL);
123  							sc.ForwardBytes(lbl - ws1);
124  							if (ws2) {
125  								sc.SetState(SCE_LUA_DEFAULT);
126  								sc.ForwardBytes(ws2);
127  							}
128  							sc.SetState(SCE_LUA_LABEL);
129  							sc.ForwardBytes(2);
130  						}
131  					}
132  				}
133  			}
134  			sc.SetState(SCE_LUA_DEFAULT);
135  		} else if (sc.state == SCE_LUA_NUMBER) {
136  			if (!setNumber.Contains(sc.ch)) {
137  				sc.SetState(SCE_LUA_DEFAULT);
138  			} else if (sc.ch == '-' || sc.ch == '+') {
139  				if (!setExponent.Contains(sc.chPrev))
140  					sc.SetState(SCE_LUA_DEFAULT);
141  			}
142  		} else if (sc.state == SCE_LUA_IDENTIFIER) {
143  			idenPos--;			
144  			if (idenWordPos > 0) {
145  				idenWordPos--;
146  				sc.ChangeState(idenStyle);
147  				sc.ForwardBytes(idenWordPos);
148  				idenPos -= idenWordPos;
149  				if (idenPos > 0) {
150  					sc.SetState(SCE_LUA_IDENTIFIER);
151  					sc.ForwardBytes(idenPos);
152  				}
153  			} else {
154  				sc.ForwardBytes(idenPos);
155  			}
156  			sc.SetState(SCE_LUA_DEFAULT);
157  			if (foundGoto) {					
158  				while (IsASpaceOrTab(sc.ch) && !sc.atLineEnd)
159  					sc.Forward();
160  				if (setWordStart.Contains(sc.ch)) {
161  					sc.SetState(SCE_LUA_LABEL);
162  					sc.Forward();
163  					while (setWord.Contains(sc.ch))
164  						sc.Forward();
165  					char s[100];
166  					sc.GetCurrent(s, sizeof(s));
167  					if (keywords.InList(s))		
168  						sc.ChangeState(SCE_LUA_WORD);
169  				}
170  				sc.SetState(SCE_LUA_DEFAULT);
171  			}
172  		} else if (sc.state == SCE_LUA_COMMENTLINE || sc.state == SCE_LUA_PREPROCESSOR) {
173  			if (sc.atLineEnd) {
174  				sc.ForwardSetState(SCE_LUA_DEFAULT);
175  			}
176  		} else if (sc.state == SCE_LUA_STRING) {
177  			if (stringWs) {
178  				if (!IsASpace(sc.ch))
179  					stringWs = 0;
180  			}
181  			if (sc.ch == '\\') {
182  				if (setEscapeSkip.Contains(sc.chNext)) {
183  					sc.Forward();
184  				} else if (sc.chNext == 'z') {
185  					sc.Forward();
186  					stringWs = 0x100;
187  				}
188  			} else if (sc.ch == '\"') {
189  				sc.ForwardSetState(SCE_LUA_DEFAULT);
190  			} else if (stringWs == 0 && sc.atLineEnd) {
191  				sc.ChangeState(SCE_LUA_STRINGEOL);
192  				sc.ForwardSetState(SCE_LUA_DEFAULT);
193  			}
194  		} else if (sc.state == SCE_LUA_CHARACTER) {
195  			if (stringWs) {
196  				if (!IsASpace(sc.ch))
197  					stringWs = 0;
198  			}
199  			if (sc.ch == '\\') {
200  				if (setEscapeSkip.Contains(sc.chNext)) {
201  					sc.Forward();
202  				} else if (sc.chNext == 'z') {
203  					sc.Forward();
204  					stringWs = 0x100;
205  				}
206  			} else if (sc.ch == '\'') {
207  				sc.ForwardSetState(SCE_LUA_DEFAULT);
208  			} else if (stringWs == 0 && sc.atLineEnd) {
209  				sc.ChangeState(SCE_LUA_STRINGEOL);
210  				sc.ForwardSetState(SCE_LUA_DEFAULT);
211  			}
212  		} else if (sc.ch == ']' && (sc.state == SCE_LUA_LITERALSTRING || sc.state == SCE_LUA_COMMENT)) {
213  			const int sep = LongDelimCheck(sc);
214  			if (sep == sepCount) {   
215  				sc.Forward(sep);
216  				sc.ForwardSetState(SCE_LUA_DEFAULT);
217  			}
218  		}
219  		if (sc.state == SCE_LUA_DEFAULT) {
220  			if (IsADigit(sc.ch) || (sc.ch == '.' && IsADigit(sc.chNext))) {
221  				sc.SetState(SCE_LUA_NUMBER);
222  				if (sc.ch == '0' && toupper(sc.chNext) == 'X') {
223  					sc.Forward();
224  				}
225  			} else if (setWordStart.Contains(sc.ch)) {
226  				std::string ident;
227  				idenPos = 0;
228  				idenWordPos = 0;
229  				idenStyle = SCE_LUA_IDENTIFIER;
230  				foundGoto = false;
231  				int cNext;
232  				do {
233  					int c;
234  					const Sci_Position idenPosOld = idenPos;
235  					std::string identSeg;
236  					identSeg += static_cast<char>(sc.GetRelative(idenPos++));
237  					while (setWord.Contains(c = sc.GetRelative(idenPos))) {
238  						identSeg += static_cast<char>(c);
239  						idenPos++;
240  					}
241  					if (keywords.InList(identSeg.c_str()) && (idenPosOld > 0)) {
242  						idenPos = idenPosOld - 1;	
243  						ident.pop_back();
244  						break;
245  					}
246  					ident += identSeg;
247  					const char* s = ident.c_str();
248  					int newStyle = SCE_LUA_IDENTIFIER;
249  					if (keywords.InList(s)) {
250  						newStyle = SCE_LUA_WORD;
251  					} else if (keywords2.InList(s)) {
252  						newStyle = SCE_LUA_WORD2;
253  					} else if (keywords3.InList(s)) {
254  						newStyle = SCE_LUA_WORD3;
255  					} else if (keywords4.InList(s)) {
256  						newStyle = SCE_LUA_WORD4;
257  					} else if (keywords5.InList(s)) {
258  						newStyle = SCE_LUA_WORD5;
259  					} else if (keywords6.InList(s)) {
260  						newStyle = SCE_LUA_WORD6;
261  					} else if (keywords7.InList(s)) {
262  						newStyle = SCE_LUA_WORD7;
263  					} else if (keywords8.InList(s)) {
264  						newStyle = SCE_LUA_WORD8;
265  					}
266  					if (newStyle != SCE_LUA_IDENTIFIER) {
267  						idenStyle = newStyle;
268  						idenWordPos = idenPos;
269  					}
270  					if (idenStyle == SCE_LUA_WORD)	
271  						break;
272  					cNext = sc.GetRelative(idenPos + 1);
273  					if ((c == '.' || c == ':') && setWordStart.Contains(cNext)) {
274  						ident += static_cast<char>(c);
275  						idenPos++;
276  					} else {
277  						cNext = 0;
278  					}
279  				} while (cNext);
280  				if ((idenStyle == SCE_LUA_WORD) && (ident.compare("goto") == 0)) {
281  					foundGoto = true;
282  				}
283  				sc.SetState(SCE_LUA_IDENTIFIER);
284  			} else if (sc.ch == '\"') {
285  				sc.SetState(SCE_LUA_STRING);
286  				stringWs = 0;
287  			} else if (sc.ch == '\'') {
288  				sc.SetState(SCE_LUA_CHARACTER);
289  				stringWs = 0;
290  			} else if (sc.ch == '[') {
291  				sepCount = LongDelimCheck(sc);
292  				if (sepCount == 0) {
293  					sc.SetState(SCE_LUA_OPERATOR);
294  				} else {
295  					sc.SetState(SCE_LUA_LITERALSTRING);
296  					sc.Forward(sepCount);
297  				}
298  			} else if (sc.Match('-', '-')) {
299  				sc.SetState(SCE_LUA_COMMENTLINE);
300  				if (sc.Match("--[")) {
301  					sc.Forward(2);
302  					sepCount = LongDelimCheck(sc);
303  					if (sepCount > 0) {
304  						sc.ChangeState(SCE_LUA_COMMENT);
305  						sc.Forward(sepCount);
306  					}
307  				} else {
308  					sc.Forward();
309  				}
310  			} else if (sc.atLineStart && sc.Match('$')) {
311  				sc.SetState(SCE_LUA_PREPROCESSOR);	
312  			} else if (setLuaOperator.Contains(sc.ch)) {
313  				sc.SetState(SCE_LUA_OPERATOR);
314  			}
315  		}
316  	}
317  	sc.Complete();
318  }
319  static void FoldLuaDoc(Sci_PositionU startPos, Sci_Position length, int initStyle, WordList *[],
320                         Accessor &styler) {
321  	const Sci_PositionU lengthDoc = startPos + length;
322  	int visibleChars = 0;
323  	Sci_Position lineCurrent = styler.GetLine(startPos);
324  	int levelPrev = styler.LevelAt(lineCurrent) & SC_FOLDLEVELNUMBERMASK;
325  	int levelCurrent = levelPrev;
326  	char chNext = styler[startPos];
327  	const bool foldCompact = styler.GetPropertyInt("fold.compact", 1) != 0;
328  	int style = initStyle;
329  	int styleNext = styler.StyleAt(startPos);
330  	for (Sci_PositionU i = startPos; i < lengthDoc; i++) {
331  		const char ch = chNext;
332  		chNext = styler.SafeGetCharAt(i + 1);
333  		const int stylePrev = style;
334  		style = styleNext;
335  		styleNext = styler.StyleAt(i + 1);
336  		const bool atEOL = (ch == '\r' && chNext != '\n') || (ch == '\n');
337  		if (style == SCE_LUA_WORD) {
338  			if (ch == 'i' || ch == 'd' || ch == 'f' || ch == 'e' || ch == 'r' || ch == 'u') {
339  				char s[10] = "";
340  				for (Sci_PositionU j = 0; j < 8; j++) {
341  					if (!iswordchar(styler[i + j])) {
342  						break;
343  					}
344  					s[j] = styler[i + j];
345  					s[j + 1] = '\0';
346  				}
347  				if ((strcmp(s, "if") == 0) || (strcmp(s, "do") == 0) || (strcmp(s, "function") == 0) || (strcmp(s, "repeat") == 0)) {
348  					levelCurrent++;
349  				}
350  				if ((strcmp(s, "end") == 0) || (strcmp(s, "elseif") == 0) || (strcmp(s, "until") == 0)) {
351  					levelCurrent--;
352  				}
353  			}
354  		} else if (style == SCE_LUA_OPERATOR) {
355  			if (ch == '{' || ch == '(') {
356  				levelCurrent++;
357  			} else if (ch == '}' || ch == ')') {
358  				levelCurrent--;
359  			}
360  		} else if (style == SCE_LUA_LITERALSTRING || style == SCE_LUA_COMMENT) {
361  			if (stylePrev != style) {
<span onclick='openModal()' class='match'>362  				levelCurrent++;
363  			} else if (styleNext != style) {
364  				levelCurrent--;
365  			}
366  		}
367  		if (atEOL) {
</span>368  			int lev = levelPrev;
369  			if (visibleChars == 0 && foldCompact) {
370  				lev |= SC_FOLDLEVELWHITEFLAG;
371  			}
372  			if ((levelCurrent > levelPrev) && (visibleChars > 0)) {
373  				lev |= SC_FOLDLEVELHEADERFLAG;
374  			}
375  			if (lev != styler.LevelAt(lineCurrent)) {
376  				styler.SetLevel(lineCurrent, lev);
377  			}
378  			lineCurrent++;
379  			levelPrev = levelCurrent;
380  			visibleChars = 0;
381  		}
382  		if (!isspacechar(ch)) {
383  			visibleChars++;
384  		}
385  	}
386  	int flagsNext = styler.LevelAt(lineCurrent) & ~SC_FOLDLEVELNUMBERMASK;
387  	styler.SetLevel(lineCurrent, levelPrev | flagsNext);
388  }
389  static const char * const luaWordListDesc[] = {
390  	"Keywords",
391  	"Basic functions",
392  	"String, (table) & math functions",
393  	"(coroutines), I/O & system facilities",
394  	"user1",
395  	"user2",
396  	"user3",
397  	"user4",
398  	0
399  };
400  namespace {
401  LexicalClass lexicalClasses[] = {
402  	0, "SCE_LUA_DEFAULT", "default", "White space: Visible only in View Whitespace mode (or if it has a back colour)",
403  	1, "SCE_LUA_COMMENT", "comment", "Block comment (Lua 5.0)",
404  	2, "SCE_LUA_COMMENTLINE", "comment line", "Line comment",
405  	3, "SCE_LUA_COMMENTDOC", "comment documentation", "Doc comment -- Not used in Lua (yet?)",
406  	4, "SCE_LUA_NUMBER", "literal numeric", "Number",
407  	5, "SCE_LUA_WORD", "keyword", "Keyword",
408  	6, "SCE_LUA_STRING", "literal string", "(Double quoted) String",
409  	7, "SCE_LUA_CHARACTER", "literal string character", "Character (Single quoted string)",
410  	8, "SCE_LUA_LITERALSTRING", "literal string", "Literal string",
411  	9, "SCE_LUA_PREPROCESSOR", "preprocessor", "Preprocessor (obsolete in Lua 4.0 and up)",
412  	10, "SCE_LUA_OPERATOR", "operator", "Operators",
413  	11, "SCE_LUA_IDENTIFIER", "identifier", "Identifier (everything else...)",
414  	12, "SCE_LUA_STRINGEOL", "error literal string", "End of line where string is not closed",
415  	13, "SCE_LUA_WORD2", "identifier", "Other keywords",
416  	14, "SCE_LUA_WORD3", "identifier", "Other keywords",
417  	15, "SCE_LUA_WORD4", "identifier", "Other keywords",
418  	16, "SCE_LUA_WORD5", "identifier", "Other keywords",
419  	17, "SCE_LUA_WORD6", "identifier", "Other keywords",
420  	18, "SCE_LUA_WORD7", "identifier", "Other keywords",
421  	19, "SCE_LUA_WORD8", "identifier", "Other keywords",
422  	20, "SCE_LUA_LABEL", "label", "Labels",
423  };
424  }
425  LexerModule lmLua(SCLEX_LUA, ColouriseLuaDoc, "lua", FoldLuaDoc, luaWordListDesc, lexicalClasses, ELEMENTS(lexicalClasses));
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexLua.cxx</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexLua.cxx</div>
                </div>
                <div class="column column_space"><pre><code>362  				levelCurrent++;
363  			} else if (styleNext != style) {
364  				levelCurrent--;
365  			}
366  		}
367  		if (atEOL) {
</pre></code></div>
                <div class="column column_space"><pre><code>362  				levelCurrent++;
363  			} else if (styleNext != style) {
364  				levelCurrent--;
365  			}
366  		}
367  		if (atEOL) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    