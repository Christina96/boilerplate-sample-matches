
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 10.040307805056797%, Tokens: 12</h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-language_model.cpp</h3>
            <pre><code>1  #include "language_model.h"
2  #include <tesseract/unichar.h>       
3  #include <cassert>                   
4  #include <cmath>                     
5  #include "blamer.h"                  
6  #include "ccutil.h"                  
7  #include "dawg.h"                    
8  #include "errcode.h"                 
9  #include "lm_state.h"                
10  #include "matrix.h"                  
11  #include "pageres.h"                 
12  #include "params.h"                  
13  #include "params_training_featdef.h" 
14  #include "tprintf.h"                 
15  #include "unicharset.h"              
16  #include "unicity_table.h"           
17  template <typename T>
18  class UnicityTable;
19  namespace tesseract {
20  class LMPainPoints;
21  struct FontInfo;
22  #if defined(ANDROID)
23  static inline double log2(double n) {
24    return log(n) / log(2.0);
25  }
26  #endif 
27  const float LanguageModel::kMaxAvgNgramCost = 25.0f;
28  LanguageModel::LanguageModel(const UnicityTable<FontInfo> *fontinfo_table, Dict *dict)
29      : INT_MEMBER(language_model_debug_level, 0, "Language model debug level",
30                   dict->getCCUtil()->params())
31      , BOOL_INIT_MEMBER(language_model_ngram_on, false,
32                         "Turn on/off the use of character ngram model", dict->getCCUtil()->params())
33      , INT_MEMBER(language_model_ngram_order, 8, "Maximum order of the character ngram model",
34                   dict->getCCUtil()->params())
35      , INT_MEMBER(language_model_viterbi_list_max_num_prunable, 10,
36                   "Maximum number of prunable (those for which"
37                   " PrunablePath() is true) entries in each viterbi list"
38                   " recorded in BLOB_CHOICEs",
39                   dict->getCCUtil()->params())
40      , INT_MEMBER(language_model_viterbi_list_max_size, 500,
41                   "Maximum size of viterbi lists recorded in BLOB_CHOICEs",
42                   dict->getCCUtil()->params())
43      , double_MEMBER(language_model_ngram_small_prob, 0.000001,
44                      "To avoid overly small denominators use this as the "
45                      "floor of the probability returned by the ngram model.",
46                      dict->getCCUtil()->params())
47      , double_MEMBER(language_model_ngram_nonmatch_score, -40.0,
48                      "Average classifier score of a non-matching unichar.",
49                      dict->getCCUtil()->params())
50      , BOOL_MEMBER(language_model_ngram_use_only_first_uft8_step, false,
51                    "Use only the first UTF8 step of the given string"
52                    " when computing log probabilities.",
53                    dict->getCCUtil()->params())
54      , double_MEMBER(language_model_ngram_scale_factor, 0.03,
55                      "Strength of the character ngram model relative to the"
56                      " character classifier ",
57                      dict->getCCUtil()->params())
58      , double_MEMBER(language_model_ngram_rating_factor, 16.0,
59                      "Factor to bring log-probs into the same range as ratings"
60                      " when multiplied by outline length ",
61                      dict->getCCUtil()->params())
62      , BOOL_MEMBER(language_model_ngram_space_delimited_language, true,
63                    "Words are delimited by space", dict->getCCUtil()->params())
64      , INT_MEMBER(language_model_min_compound_length, 3, "Minimum length of compound words",
65                   dict->getCCUtil()->params())
66      , double_MEMBER(language_model_penalty_non_freq_dict_word, 0.1,
67                      "Penalty for words not in the frequent word dictionary",
68                      dict->getCCUtil()->params())
69      , double_MEMBER(language_model_penalty_non_dict_word, 0.15, "Penalty for non-dictionary words",
70                      dict->getCCUtil()->params())
71      , double_MEMBER(language_model_penalty_punc, 0.2, "Penalty for inconsistent punctuation",
72                      dict->getCCUtil()->params())
73      , double_MEMBER(language_model_penalty_case, 0.1, "Penalty for inconsistent case",
74                      dict->getCCUtil()->params())
75      , double_MEMBER(language_model_penalty_script, 0.5, "Penalty for inconsistent script",
76                      dict->getCCUtil()->params())
77      , double_MEMBER(language_model_penalty_chartype, 0.3, "Penalty for inconsistent character type",
78                      dict->getCCUtil()->params())
79      ,
80      double_MEMBER(language_model_penalty_font, 0.00, "Penalty for inconsistent font",
81                    dict->getCCUtil()->params())
82      , double_MEMBER(language_model_penalty_spacing, 0.05, "Penalty for inconsistent spacing",
83                      dict->getCCUtil()->params())
84      , double_MEMBER(language_model_penalty_increment, 0.01, "Penalty increment",
85                      dict->getCCUtil()->params())
86      , INT_MEMBER(wordrec_display_segmentations, 0, "Display Segmentations (ScrollView)",
87                   dict->getCCUtil()->params())
88      , BOOL_INIT_MEMBER(language_model_use_sigmoidal_certainty, false,
89                         "Use sigmoidal score for certainty", dict->getCCUtil()->params())
90      , dawg_args_(nullptr, new DawgPositionVector(), NO_PERM)
91      , fontinfo_table_(fontinfo_table)
92      , dict_(dict) {
93    ASSERT_HOST(dict_ != nullptr);
94  }
95  LanguageModel::~LanguageModel() {
96    delete dawg_args_.updated_dawgs;
97  }
98  void LanguageModel::InitForWord(const WERD_CHOICE *prev_word, bool fixed_pitch,
99                                  float max_char_wh_ratio, float rating_cert_scale) {
100    fixed_pitch_ = fixed_pitch;
101    max_char_wh_ratio_ = max_char_wh_ratio;
102    rating_cert_scale_ = rating_cert_scale;
103    acceptable_choice_found_ = false;
104    correct_segmentation_explored_ = false;
105    very_beginning_active_dawgs_.clear();
106    dict_->init_active_dawgs(&very_beginning_active_dawgs_, false);
107    beginning_active_dawgs_.clear();
108    dict_->default_dawgs(&beginning_active_dawgs_, false);
109    if (language_model_ngram_on) {
110      if (prev_word != nullptr && !prev_word->unichar_string().empty()) {
111        prev_word_str_ = prev_word->unichar_string();
112        if (language_model_ngram_space_delimited_language) {
113          prev_word_str_ += ' ';
114        }
115      } else {
116        prev_word_str_ = " ";
117      }
118      const char *str_ptr = prev_word_str_.c_str();
119      const char *str_end = str_ptr + prev_word_str_.length();
120      int step;
121      prev_word_unichar_step_len_ = 0;
122      while (str_ptr != str_end && (step = UNICHAR::utf8_step(str_ptr))) {
123        str_ptr += step;
124        ++prev_word_unichar_step_len_;
125      }
126      ASSERT_HOST(str_ptr == str_end);
127    }
128  }
129  static void ScanParentsForCaseMix(const UNICHARSET &unicharset, LanguageModelState *parent_node) {
130    if (parent_node == nullptr) {
131      return;
132    }
133    ViterbiStateEntry_IT vit(&parent_node->viterbi_state_entries);
134    for (vit.mark_cycle_pt(); !vit.cycled_list(); vit.forward()) {
135      ViterbiStateEntry *vse = vit.data();
136      vse->competing_vse = nullptr;
137      UNICHAR_ID unichar_id = vse->curr_b->unichar_id();
138      if (unicharset.get_isupper(unichar_id) || unicharset.get_islower(unichar_id)) {
139        UNICHAR_ID other_case = unicharset.get_other_case(unichar_id);
140        if (other_case == unichar_id) {
141          continue; 
142        }
143        ViterbiStateEntry_IT vit2(&parent_node->viterbi_state_entries);
144        for (vit2.mark_cycle_pt();
145             !vit2.cycled_list() && vit2.data()->curr_b->unichar_id() != other_case; vit2.forward()) {
146        }
147        if (!vit2.cycled_list()) {
148          vse->competing_vse = vit2.data();
149        }
150      }
151    }
152  }
153  static bool HasBetterCaseVariant(const UNICHARSET &unicharset, const BLOB_CHOICE *choice,
154                                   BLOB_CHOICE_LIST *choices) {
155    UNICHAR_ID choice_id = choice->unichar_id();
156    UNICHAR_ID other_case = unicharset.get_other_case(choice_id);
157    if (other_case == choice_id || other_case == INVALID_UNICHAR_ID) {
158      return false; 
159    }
160    if (unicharset.SizesDistinct(choice_id, other_case)) {
161      return false; 
162    }
163    BLOB_CHOICE_IT bc_it(choices);
164    for (bc_it.mark_cycle_pt(); !bc_it.cycled_list(); bc_it.forward()) {
165      BLOB_CHOICE *better_choice = bc_it.data();
166      if (better_choice->unichar_id() == other_case) {
167        return true; 
168      } else if (better_choice == choice) {
169        return false; 
170      }
171    }
172    return false; 
173  }
174  bool LanguageModel::UpdateState(bool just_classified, int curr_col, int curr_row,
175                                  BLOB_CHOICE_LIST *curr_list, LanguageModelState *parent_node,
176                                  LMPainPoints *pain_points, WERD_RES *word_res,
177                                  BestChoiceBundle *best_choice_bundle, BlamerBundle *blamer_bundle) {
178    if (language_model_debug_level > 0) {
179      tprintf("\nUpdateState: col=%d row=%d %s", curr_col, curr_row,
180              just_classified ? "just_classified" : "");
181      if (language_model_debug_level > 5) {
182        tprintf("(parent=%p)\n", static_cast<void *>(parent_node));
183      } else {
184        tprintf("\n");
185      }
186    }
187    bool word_end = (curr_row + 1 >= word_res->ratings->dimension());
188    bool new_changed = false;
189    float denom = (language_model_ngram_on) ? ComputeDenom(curr_list) : 1.0f;
190    const UNICHARSET &unicharset = dict_->getUnicharset();
191    BLOB_CHOICE *first_lower = nullptr;
192    BLOB_CHOICE *first_upper = nullptr;
193    BLOB_CHOICE *first_digit = nullptr;
194    bool has_alnum_mix = false;
195    if (parent_node != nullptr) {
196      int result = SetTopParentLowerUpperDigit(parent_node);
197      if (result < 0) {
198        if (language_model_debug_level > 0) {
199          tprintf("No parents found to process\n");
200        }
201        return false;
202      }
203      if (result > 0) {
204        has_alnum_mix = true;
205      }
206    }
207    if (!GetTopLowerUpperDigit(curr_list, &first_lower, &first_upper, &first_digit)) {
208      has_alnum_mix = false;
209    };
210    ScanParentsForCaseMix(unicharset, parent_node);
211    if (language_model_debug_level > 3 && parent_node != nullptr) {
212      parent_node->Print("Parent viterbi list");
213    }
214    LanguageModelState *curr_state = best_choice_bundle->beam[curr_row];
215    ViterbiStateEntry_IT vit;
216    BLOB_CHOICE_IT c_it(curr_list);
217    for (c_it.mark_cycle_pt(); !c_it.cycled_list(); c_it.forward()) {
218      BLOB_CHOICE *choice = c_it.data();
219      UNICHAR_ID unichar_id = choice->unichar_id();
220      if (unicharset.get_fragment(unichar_id)) {
221        continue; 
222      }
223      LanguageModelFlagsType blob_choice_flags = kXhtConsistentFlag;
224      if (c_it.at_first() || !new_changed) {
225        blob_choice_flags |= kSmallestRatingFlag;
226      }
227      if (first_lower == choice) {
228        blob_choice_flags |= kLowerCaseFlag;
229      }
230      if (first_upper == choice) {
231        blob_choice_flags |= kUpperCaseFlag;
232      }
233      if (first_digit == choice) {
234        blob_choice_flags |= kDigitFlag;
235      }
236      if (parent_node == nullptr) {
237        if (HasBetterCaseVariant(unicharset, choice, curr_list)) {
238          continue;
239        }
240        if (blob_choice_flags & kUpperCaseFlag) {
241          blob_choice_flags |= kLowerCaseFlag;
242        }
243        new_changed |= AddViterbiStateEntry(blob_choice_flags, denom, word_end, curr_col, curr_row,
244                                            choice, curr_state, nullptr, pain_points, word_res,
245                                            best_choice_bundle, blamer_bundle);
246      } else {
247        vit.set_to_list(&parent_node->viterbi_state_entries);
248        int vit_counter = 0;
249        vit.mark_cycle_pt();
250        ViterbiStateEntry *parent_vse = nullptr;
251        LanguageModelFlagsType top_choice_flags;
252        while ((parent_vse =
253                    GetNextParentVSE(just_classified, has_alnum_mix, c_it.data(), blob_choice_flags,
254                                     unicharset, word_res, &vit, &top_choice_flags)) != nullptr) {
255          if (PrunablePath(*parent_vse) &&
256              (++vit_counter > language_model_viterbi_list_max_num_prunable ||
257               (language_model_ngram_on && parent_vse->ngram_info->pruned))) {
258            continue;
259          }
260          if (!parent_vse->HasAlnumChoice(unicharset) &&
261              HasBetterCaseVariant(unicharset, choice, curr_list)) {
262            continue;
263          }
264          new_changed |= AddViterbiStateEntry(top_choice_flags, denom, word_end, curr_col, curr_row,
265                                              c_it.data(), curr_state, parent_vse, pain_points,
266                                              word_res, best_choice_bundle, blamer_bundle);
267        }
268      }
269    }
270    return new_changed;
271  }
272  bool LanguageModel::GetTopLowerUpperDigit(BLOB_CHOICE_LIST *curr_list, BLOB_CHOICE **first_lower,
273                                            BLOB_CHOICE **first_upper,
274                                            BLOB_CHOICE **first_digit) const {
275    BLOB_CHOICE_IT c_it(curr_list);
276    const UNICHARSET &unicharset = dict_->getUnicharset();
277    BLOB_CHOICE *first_unichar = nullptr;
278    for (c_it.mark_cycle_pt(); !c_it.cycled_list(); c_it.forward()) {
279      UNICHAR_ID unichar_id = c_it.data()->unichar_id();
280      if (unicharset.get_fragment(unichar_id)) {
281        continue; 
282      }
283      if (first_unichar == nullptr) {
284        first_unichar = c_it.data();
285      }
286      if (*first_lower == nullptr && unicharset.get_islower(unichar_id)) {
287        *first_lower = c_it.data();
288      }
289      if (*first_upper == nullptr && unicharset.get_isalpha(unichar_id) &&
290          !unicharset.get_islower(unichar_id)) {
291        *first_upper = c_it.data();
292      }
293      if (*first_digit == nullptr && unicharset.get_isdigit(unichar_id)) {
294        *first_digit = c_it.data();
295      }
296    }
297    ASSERT_HOST(first_unichar != nullptr);
298    bool mixed = (*first_lower != nullptr || *first_upper != nullptr) && *first_digit != nullptr;
299    if (*first_lower == nullptr) {
300      *first_lower = first_unichar;
301    }
302    if (*first_upper == nullptr) {
303      *first_upper = first_unichar;
304    }
305    if (*first_digit == nullptr) {
306      *first_digit = first_unichar;
307    }
308    return mixed;
309  }
310  int LanguageModel::SetTopParentLowerUpperDigit(LanguageModelState *parent_node) const {
311    if (parent_node == nullptr) {
312      return -1;
313    }
314    UNICHAR_ID top_id = INVALID_UNICHAR_ID;
315    ViterbiStateEntry *top_lower = nullptr;
316    ViterbiStateEntry *top_upper = nullptr;
317    ViterbiStateEntry *top_digit = nullptr;
318    ViterbiStateEntry *top_choice = nullptr;
319    float lower_rating = 0.0f;
320    float upper_rating = 0.0f;
321    float digit_rating = 0.0f;
322    float top_rating = 0.0f;
323    const UNICHARSET &unicharset = dict_->getUnicharset();
324    ViterbiStateEntry_IT vit(&parent_node->viterbi_state_entries);
325    for (vit.mark_cycle_pt(); !vit.cycled_list(); vit.forward()) {
326      ViterbiStateEntry *vse = vit.data();
327      ViterbiStateEntry *unichar_vse = vse;
328      UNICHAR_ID unichar_id = unichar_vse->curr_b->unichar_id();
329      float rating = unichar_vse->curr_b->rating();
330      while (unichar_id == INVALID_UNICHAR_ID && unichar_vse->parent_vse != nullptr) {
331        unichar_vse = unichar_vse->parent_vse;
332        unichar_id = unichar_vse->curr_b->unichar_id();
333        rating = unichar_vse->curr_b->rating();
334      }
335      if (unichar_id != INVALID_UNICHAR_ID) {
336        if (unicharset.get_islower(unichar_id)) {
337          if (top_lower == nullptr || lower_rating > rating) {
338            top_lower = vse;
339            lower_rating = rating;
340          }
341        } else if (unicharset.get_isalpha(unichar_id)) {
342          if (top_upper == nullptr || upper_rating > rating) {
343            top_upper = vse;
344            upper_rating = rating;
345          }
346        } else if (unicharset.get_isdigit(unichar_id)) {
347          if (top_digit == nullptr || digit_rating > rating) {
348            top_digit = vse;
349            digit_rating = rating;
350          }
351        }
352      }
353      if (top_choice == nullptr || top_rating > rating) {
354        top_choice = vse;
355        top_rating = rating;
356        top_id = unichar_id;
357      }
358    }
359    if (top_choice == nullptr) {
360      return -1;
361    }
362    bool mixed = (top_lower != nullptr || top_upper != nullptr) && top_digit != nullptr;
363    if (top_lower == nullptr) {
364      top_lower = top_choice;
365    }
366    top_lower->top_choice_flags |= kLowerCaseFlag;
367    if (top_upper == nullptr) {
368      top_upper = top_choice;
369    }
370    top_upper->top_choice_flags |= kUpperCaseFlag;
371    if (top_digit == nullptr) {
372      top_digit = top_choice;
373    }
374    top_digit->top_choice_flags |= kDigitFlag;
375    top_choice->top_choice_flags |= kSmallestRatingFlag;
376    if (top_id != INVALID_UNICHAR_ID && dict_->compound_marker(top_id) &&
377        (top_choice->top_choice_flags & (kLowerCaseFlag | kUpperCaseFlag | kDigitFlag))) {
378      top_choice->top_choice_flags |= kLowerCaseFlag | kUpperCaseFlag | kDigitFlag;
379    }
380    return mixed ? 1 : 0;
381  }
382  ViterbiStateEntry *LanguageModel::GetNextParentVSE(bool just_classified, bool mixed_alnum,
383                                                     const BLOB_CHOICE *bc,
384                                                     LanguageModelFlagsType blob_choice_flags,
385                                                     const UNICHARSET &unicharset, WERD_RES *word_res,
386                                                     ViterbiStateEntry_IT *vse_it,
387                                                     LanguageModelFlagsType *top_choice_flags) const {
388    for (; !vse_it->cycled_list(); vse_it->forward()) {
389      ViterbiStateEntry *parent_vse = vse_it->data();
390      if (!just_classified && !parent_vse->updated) {
391        continue;
392      }
393      if (language_model_debug_level > 2) {
394        parent_vse->Print("Considering");
395      }
396      *top_choice_flags = blob_choice_flags;
397      if ((blob_choice_flags & kUpperCaseFlag) && !parent_vse->HasAlnumChoice(unicharset)) {
398        *top_choice_flags |= kLowerCaseFlag;
399      }
400      *top_choice_flags &= parent_vse->top_choice_flags;
401      UNICHAR_ID unichar_id = bc->unichar_id();
402      const BLOB_CHOICE *parent_b = parent_vse->curr_b;
403      UNICHAR_ID parent_id = parent_b->unichar_id();
404      if (unicharset.get_isdigit(unichar_id) && unicharset.get_isalpha(parent_id) &&
405          (mixed_alnum || *top_choice_flags == 0)) {
406        continue; 
407      }
408      if (unicharset.get_isalpha(unichar_id) && unicharset.get_isdigit(parent_id) &&
409          (mixed_alnum || *top_choice_flags == 0)) {
410        continue; 
411      }
412      if (parent_vse->competing_vse != nullptr) {
413        const BLOB_CHOICE *competing_b = parent_vse->competing_vse->curr_b;
414        UNICHAR_ID other_id = competing_b->unichar_id();
415        if (language_model_debug_level >= 5) {
416          tprintf("Parent %s has competition %s\n", unicharset.id_to_unichar(parent_id),
417                  unicharset.id_to_unichar(other_id));
418        }
419        if (unicharset.SizesDistinct(parent_id, other_id)) {
420          if (bc->PosAndSizeAgree(*competing_b, word_res->x_height,
421                                  language_model_debug_level >= 5) &&
422              !bc->PosAndSizeAgree(*parent_b, word_res->x_height, language_model_debug_level >= 5)) {
423            continue; 
424          }
425        }
426      }
427      vse_it->forward();
428      return parent_vse; 
429    }
430    return nullptr; 
431  }
432  bool LanguageModel::AddViterbiStateEntry(LanguageModelFlagsType top_choice_flags, float denom,
433                                           bool word_end, int curr_col, int curr_row, BLOB_CHOICE *b,
434                                           LanguageModelState *curr_state,
435                                           ViterbiStateEntry *parent_vse, LMPainPoints *pain_points,
436                                           WERD_RES *word_res, BestChoiceBundle *best_choice_bundle,
437                                           BlamerBundle *blamer_bundle) {
438    ViterbiStateEntry_IT vit;
439    if (language_model_debug_level > 1) {
440      tprintf(
441          "AddViterbiStateEntry for unichar %s rating=%.4f"
442          " certainty=%.4f top_choice_flags=0x%x",
443          dict_->getUnicharset().id_to_unichar(b->unichar_id()), b->rating(), b->certainty(),
444          top_choice_flags);
445      if (language_model_debug_level > 5) {
446        tprintf(" parent_vse=%p\n", static_cast<void *>(parent_vse));
447      } else {
448        tprintf("\n");
449      }
450    }
451    ASSERT_HOST(curr_state != nullptr);
452    if (curr_state->viterbi_state_entries_length >= language_model_viterbi_list_max_size) {
453      if (language_model_debug_level > 1) {
454        tprintf("AddViterbiStateEntry: viterbi list is full!\n");
455      }
456      return false;
457    }
458    LanguageModelDawgInfo *dawg_info = GenerateDawgInfo(word_end, curr_col, curr_row, *b, parent_vse);
459    float outline_length = AssociateUtils::ComputeOutlineLength(rating_cert_scale_, *b);
460    LanguageModelNgramInfo *ngram_info = nullptr;
461    if (language_model_ngram_on) {
462      ngram_info =
463          GenerateNgramInfo(dict_->getUnicharset().id_to_unichar(b->unichar_id()), b->certainty(),
464                            denom, curr_col, curr_row, outline_length, parent_vse);
465      ASSERT_HOST(ngram_info != nullptr);
466    }
467    bool liked_by_language_model =
468        dawg_info != nullptr || (ngram_info != nullptr && !ngram_info->pruned);
469    if (!liked_by_language_model && top_choice_flags == 0) {
470      if (language_model_debug_level > 1) {
471        tprintf("Language model components very early pruned this entry\n");
472      }
473      delete ngram_info;
474      delete dawg_info;
475      return false;
476    }
477    LMConsistencyInfo consistency_info(parent_vse != nullptr ? &parent_vse->consistency_info
478                                                             : nullptr);
479    consistency_info.ComputeXheightConsistency(
480        b, dict_->getUnicharset().get_ispunctuation(b->unichar_id()));
481    if (consistency_info.InconsistentXHeight()) {
482      top_choice_flags &= ~kXhtConsistentFlag;
483    }
484    if (!liked_by_language_model && top_choice_flags == 0) {
485      if (language_model_debug_level > 1) {
486        tprintf("Language model components early pruned this entry\n");
487      }
488      delete ngram_info;
489      delete dawg_info;
490      return false;
491    }
492    FillConsistencyInfo(curr_col, word_end, b, parent_vse, word_res, &consistency_info);
493    if (dawg_info != nullptr && consistency_info.invalid_punc) {
494      consistency_info.invalid_punc = false; 
495    }
496    AssociateStats associate_stats;
497    ComputeAssociateStats(curr_col, curr_row, max_char_wh_ratio_, parent_vse, word_res,
498                          &associate_stats);
499    if (parent_vse != nullptr) {
500      associate_stats.shape_cost += parent_vse->associate_stats.shape_cost;
501      associate_stats.bad_shape |= parent_vse->associate_stats.bad_shape;
502    }
503    auto *new_vse = new ViterbiStateEntry(parent_vse, b, 0.0, outline_length, consistency_info,
504                                          associate_stats, top_choice_flags, dawg_info, ngram_info,
505                                          (language_model_debug_level > 0)
506                                              ? dict_->getUnicharset().id_to_unichar(b->unichar_id())
507                                              : nullptr);
508    new_vse->cost = ComputeAdjustedPathCost(new_vse);
509    if (language_model_debug_level >= 3) {
510      tprintf("Adjusted cost = %g\n", new_vse->cost);
511    }
512    if (!curr_state->viterbi_state_entries.empty() && new_vse->top_choice_flags) {
513      GenerateTopChoiceInfo(new_vse, parent_vse, curr_state);
514    }
515    bool keep = new_vse->top_choice_flags || liked_by_language_model;
516    if (!(top_choice_flags & kSmallestRatingFlag) && 
517        consistency_info.inconsistent_script) {      
518      keep = false;
519    }
520    if (!keep) {
521      if (language_model_debug_level > 1) {
522        tprintf("Language model components did not like this entry\n");
523      }
524      delete new_vse;
525      return false;
526    }
527    if (PrunablePath(*new_vse) &&
528        (curr_state->viterbi_state_entries_prunable_length >=
529         language_model_viterbi_list_max_num_prunable) &&
530        new_vse->cost >= curr_state->viterbi_state_entries_prunable_max_cost) {
531      if (language_model_debug_level > 1) {
532        tprintf("Discarded ViterbiEntry with high cost %g max cost %g\n", new_vse->cost,
533                curr_state->viterbi_state_entries_prunable_max_cost);
534      }
535      delete new_vse;
536      return false;
537    }
538    if (word_end) {
539      UpdateBestChoice(new_vse, pain_points, word_res, best_choice_bundle, blamer_bundle);
540      if (new_vse->cost >= WERD_CHOICE::kBadRating && new_vse != best_choice_bundle->best_vse) {
541        if (language_model_debug_level > 1) {
542          tprintf("Discarded ViterbiEntry with high cost %g\n", new_vse->cost);
543        }
544        delete new_vse;
545        return false;
546      }
547    }
548    curr_state->viterbi_state_entries.add_sorted(ViterbiStateEntry::Compare, false, new_vse);
549    curr_state->viterbi_state_entries_length++;
550    if (PrunablePath(*new_vse)) {
551      curr_state->viterbi_state_entries_prunable_length++;
552    }
553    if ((curr_state->viterbi_state_entries_prunable_length >=
554         language_model_viterbi_list_max_num_prunable) ||
555        new_vse->top_choice_flags) {
556      ASSERT_HOST(!curr_state->viterbi_state_entries.empty());
557      int prunable_counter = language_model_viterbi_list_max_num_prunable;
558      vit.set_to_list(&(curr_state->viterbi_state_entries));
559      for (vit.mark_cycle_pt(); !vit.cycled_list(); vit.forward()) {
560        ViterbiStateEntry *curr_vse = vit.data();
561        if (curr_vse->top_choice_flags && curr_vse != new_vse && curr_vse->cost > new_vse->cost) {
562          curr_vse->top_choice_flags &= ~(new_vse->top_choice_flags);
563        }
564        if (prunable_counter > 0 && PrunablePath(*curr_vse)) {
565          --prunable_counter;
566        }
567        if (prunable_counter == 0) {
568          curr_state->viterbi_state_entries_prunable_max_cost = vit.data()->cost;
569          if (language_model_debug_level > 1) {
570            tprintf("Set viterbi_state_entries_prunable_max_cost to %g\n",
571                    curr_state->viterbi_state_entries_prunable_max_cost);
572          }
573          prunable_counter = -1; 
574        }
575      }
576    }
577    if (language_model_debug_level > 2) {
578      new_vse->Print("New");
579      if (language_model_debug_level > 5) {
580        curr_state->Print("Updated viterbi list");
581      }
582    }
583    return true;
584  }
585  void LanguageModel::GenerateTopChoiceInfo(ViterbiStateEntry *new_vse,
586                                            const ViterbiStateEntry *parent_vse,
587                                            LanguageModelState *lms) {
588    ViterbiStateEntry_IT vit(&(lms->viterbi_state_entries));
589    for (vit.mark_cycle_pt();
590         !vit.cycled_list() && new_vse->top_choice_flags && new_vse->cost >= vit.data()->cost;
591         vit.forward()) {
592      new_vse->top_choice_flags &= ~(vit.data()->top_choice_flags);
593    }
594    if (language_model_debug_level > 2) {
595      tprintf("GenerateTopChoiceInfo: top_choice_flags=0x%x\n", new_vse->top_choice_flags);
596    }
597  }
598  LanguageModelDawgInfo *LanguageModel::GenerateDawgInfo(bool word_end, int curr_col, int curr_row,
599                                                         const BLOB_CHOICE &b,
600                                                         const ViterbiStateEntry *parent_vse) {
601    if (parent_vse == nullptr) {
602      dawg_args_.active_dawgs = &very_beginning_active_dawgs_;
603      dawg_args_.permuter = NO_PERM;
604    } else {
605      if (parent_vse->dawg_info == nullptr) {
606        return nullptr; 
607      }
608      dawg_args_.active_dawgs = &parent_vse->dawg_info->active_dawgs;
609      dawg_args_.permuter = parent_vse->dawg_info->permuter;
610    }
611    if (word_end && dict_->has_hyphen_end(&dict_->getUnicharset(), b.unichar_id(), curr_col == 0)) {
612      if (language_model_debug_level > 0) {
613        tprintf("Hyphenated word found\n");
614      }
615      return new LanguageModelDawgInfo(dawg_args_.active_dawgs, COMPOUND_PERM);
616    }
617    if (dict_->compound_marker(b.unichar_id()) &&
618        (parent_vse == nullptr || parent_vse->dawg_info->permuter != NUMBER_PERM)) {
619      if (language_model_debug_level > 0) {
620        tprintf("Found compound marker\n");
621      }
622      if (parent_vse == nullptr || word_end || dawg_args_.permuter == COMPOUND_PERM ||
623          parent_vse->length < language_model_min_compound_length) {
624        return nullptr;
625      }
626      bool has_word_ending = false;
627      for (unsigned i = 0; i < parent_vse->dawg_info->active_dawgs.size(); ++i) {
628        const DawgPosition &pos = parent_vse->dawg_info->active_dawgs[i];
629        const Dawg *pdawg = pos.dawg_index < 0 ? nullptr : dict_->GetDawg(pos.dawg_index);
630        if (pdawg == nullptr || pos.back_to_punc) {
631          continue;
632        };
633        if (pdawg->type() == DAWG_TYPE_WORD && pos.dawg_ref != NO_EDGE &&
634            pdawg->end_of_word(pos.dawg_ref)) {
635          has_word_ending = true;
636          break;
637        }
638      }
639      if (!has_word_ending) {
640        return nullptr;
641      }
642      if (language_model_debug_level > 0) {
643        tprintf("Compound word found\n");
644      }
645      return new LanguageModelDawgInfo(&beginning_active_dawgs_, COMPOUND_PERM);
646    } 
647    LanguageModelDawgInfo *dawg_info = nullptr;
648    const auto &normed_ids = dict_->getUnicharset().normed_ids(b.unichar_id());
649    DawgPositionVector tmp_active_dawgs;
650    for (unsigned i = 0; i < normed_ids.size(); ++i) {
651      if (language_model_debug_level > 2) {
652        tprintf("Test Letter OK for unichar %d, normed %d\n", b.unichar_id(), normed_ids[i]);
653      }
654      dict_->LetterIsOkay(&dawg_args_, dict_->getUnicharset(), normed_ids[i],
655                          word_end && i == normed_ids.size() - 1);
656      if (dawg_args_.permuter == NO_PERM) {
657        break;
658      } else if (i < normed_ids.size() - 1) {
659        tmp_active_dawgs = *dawg_args_.updated_dawgs;
660        dawg_args_.active_dawgs = &tmp_active_dawgs;
661      }
662      if (language_model_debug_level > 2) {
663        tprintf("Letter was OK for unichar %d, normed %d\n", b.unichar_id(), normed_ids[i]);
664      }
665    }
666    dawg_args_.active_dawgs = nullptr;
667    if (dawg_args_.permuter != NO_PERM) {
668      dawg_info = new LanguageModelDawgInfo(dawg_args_.updated_dawgs, dawg_args_.permuter);
669    } else if (language_model_debug_level > 3) {
670      tprintf("Letter %s not OK!\n", dict_->getUnicharset().id_to_unichar(b.unichar_id()));
671    }
672    return dawg_info;
673  }
674  LanguageModelNgramInfo *LanguageModel::GenerateNgramInfo(const char *unichar, float certainty,
675                                                           float denom, int curr_col, int curr_row,
676                                                           float outline_length,
677                                                           const ViterbiStateEntry *parent_vse) {
678    const char *pcontext_ptr = "";
679    int pcontext_unichar_step_len = 0;
680    if (parent_vse == nullptr) {
681      pcontext_ptr = prev_word_str_.c_str();
682      pcontext_unichar_step_len = prev_word_unichar_step_len_;
683    } else {
684      pcontext_ptr = parent_vse->ngram_info->context.c_str();
685      pcontext_unichar_step_len = parent_vse->ngram_info->context_unichar_step_len;
686    }
687    int unichar_step_len = 0;
688    bool pruned = false;
689    float ngram_cost;
690    float ngram_and_classifier_cost = ComputeNgramCost(unichar, certainty, denom, pcontext_ptr,
691                                                       &unichar_step_len, &pruned, &ngram_cost);
692    ngram_and_classifier_cost *= outline_length / language_model_ngram_rating_factor;
693    if (parent_vse != nullptr) {
694      ngram_and_classifier_cost += parent_vse->ngram_info->ngram_and_classifier_cost;
695      ngram_cost += parent_vse->ngram_info->ngram_cost;
696    }
697    int num_remove = (unichar_step_len + pcontext_unichar_step_len - language_model_ngram_order);
698    if (num_remove > 0) {
699      pcontext_unichar_step_len -= num_remove;
700    }
701    while (num_remove > 0 && *pcontext_ptr != '\0') {
702      pcontext_ptr += UNICHAR::utf8_step(pcontext_ptr);
703      --num_remove;
704    }
705    if (parent_vse != nullptr && parent_vse->ngram_info->pruned) {
706      pruned = true;
707    }
708    auto *ngram_info = new LanguageModelNgramInfo(pcontext_ptr, pcontext_unichar_step_len, pruned,
709                                                  ngram_cost, ngram_and_classifier_cost);
710    ngram_info->context += unichar;
711    ngram_info->context_unichar_step_len += unichar_step_len;
712    assert(ngram_info->context_unichar_step_len <= language_model_ngram_order);
713    return ngram_info;
714  }
715  float LanguageModel::ComputeNgramCost(const char *unichar, float certainty, float denom,
716                                        const char *context, int *unichar_step_len,
717                                        bool *found_small_prob, float *ngram_cost) {
718    const char *context_ptr = context;
719    char *modified_context = nullptr;
720    char *modified_context_end = nullptr;
721    const char *unichar_ptr = unichar;
722    const char *unichar_end = unichar_ptr + strlen(unichar_ptr);
723    float prob = 0.0f;
724    int step = 0;
725    while (unichar_ptr < unichar_end && (step = UNICHAR::utf8_step(unichar_ptr)) > 0) {
726      if (language_model_debug_level > 1) {
727        tprintf("prob(%s | %s)=%g\n", unichar_ptr, context_ptr,
728                dict_->ProbabilityInContext(context_ptr, -1, unichar_ptr, step));
729      }
730      prob += dict_->ProbabilityInContext(context_ptr, -1, unichar_ptr, step);
731      ++(*unichar_step_len);
732      if (language_model_ngram_use_only_first_uft8_step) {
733        break;
734      }
735      unichar_ptr += step;
736      if (unichar_ptr < unichar_end) {
737        if (modified_context == nullptr) {
738          size_t context_len = strlen(context);
739          modified_context = new char[context_len + strlen(unichar_ptr) + step + 1];
740          memcpy(modified_context, context, context_len);
741          modified_context_end = modified_context + context_len;
742          context_ptr = modified_context;
743        }
744        strncpy(modified_context_end, unichar_ptr - step, step);
745        modified_context_end += step;
746        *modified_context_end = '\0';
747      }
748    }
749    prob /= static_cast<float>(*unichar_step_len); 
750    if (prob < language_model_ngram_small_prob) {
751      if (language_model_debug_level > 0) {
752        tprintf("Found small prob %g\n", prob);
753      }
754      *found_small_prob = true;
755      prob = language_model_ngram_small_prob;
756    }
757    *ngram_cost = -1 * std::log2(prob);
758    float ngram_and_classifier_cost = -1 * std::log2(CertaintyScore(certainty) / denom) +
759                                      *ngram_cost * language_model_ngram_scale_factor;
760    if (language_model_debug_level > 1) {
761      tprintf("-log [ p(%s) * p(%s | %s) ] = -log2(%g*%g) = %g\n", unichar, unichar, context_ptr,
762              CertaintyScore(certainty) / denom, prob, ngram_and_classifier_cost);
763    }
764    delete[] modified_context;
765    return ngram_and_classifier_cost;
766  }
767  float LanguageModel::ComputeDenom(BLOB_CHOICE_LIST *curr_list) {
768    if (curr_list->empty()) {
769      return 1.0f;
770    }
771    float denom = 0.0f;
772    int len = 0;
773    BLOB_CHOICE_IT c_it(curr_list);
774    for (c_it.mark_cycle_pt(); !c_it.cycled_list(); c_it.forward()) {
775      ASSERT_HOST(c_it.data() != nullptr);
776      ++len;
777      denom += CertaintyScore(c_it.data()->certainty());
778    }
779    assert(len != 0);
780    denom +=
781        (dict_->getUnicharset().size() - len) * CertaintyScore(language_model_ngram_nonmatch_score);
782    return denom;
783  }
784  void LanguageModel::FillConsistencyInfo(int curr_col, bool word_end, BLOB_CHOICE *b,
785                                          ViterbiStateEntry *parent_vse, WERD_RES *word_res,
786                                          LMConsistencyInfo *consistency_info) {
787    const UNICHARSET &unicharset = dict_->getUnicharset();
788    UNICHAR_ID unichar_id = b->unichar_id();
789    BLOB_CHOICE *parent_b = parent_vse != nullptr ? parent_vse->curr_b : nullptr;
790    if (unicharset.get_ispunctuation(unichar_id)) {
791      consistency_info->num_punc++;
792    }
793    if (dict_->GetPuncDawg() != nullptr && !consistency_info->invalid_punc) {
794      if (dict_->compound_marker(unichar_id) && parent_b != nullptr &&
795          (unicharset.get_isalpha(parent_b->unichar_id()) ||
796           unicharset.get_isdigit(parent_b->unichar_id()))) {
797        consistency_info->punc_ref = NO_EDGE;
798      } else {
799        bool is_apos = dict_->is_apostrophe(unichar_id);
800        bool prev_is_numalpha =
801            (parent_b != nullptr && (unicharset.get_isalpha(parent_b->unichar_id()) ||
802                                     unicharset.get_isdigit(parent_b->unichar_id())));
803        UNICHAR_ID pattern_unichar_id =
804            (unicharset.get_isalpha(unichar_id) || unicharset.get_isdigit(unichar_id) ||
805             (is_apos && prev_is_numalpha))
806                ? Dawg::kPatternUnicharID
807                : unichar_id;
808        if (consistency_info->punc_ref == NO_EDGE || pattern_unichar_id != Dawg::kPatternUnicharID ||
809            dict_->GetPuncDawg()->edge_letter(consistency_info->punc_ref) !=
810                Dawg::kPatternUnicharID) {
811          NODE_REF node = Dict::GetStartingNode(dict_->GetPuncDawg(), consistency_info->punc_ref);
812          consistency_info->punc_ref = (node != NO_EDGE) ? dict_->GetPuncDawg()->edge_char_of(
813                                                               node, pattern_unichar_id, word_end)
814                                                         : NO_EDGE;
815          if (consistency_info->punc_ref == NO_EDGE) {
816            consistency_info->invalid_punc = true;
817          }
818        }
819      }
820    }
821    if (parent_vse != nullptr && !word_end && dict_->compound_marker(unichar_id)) {
822      consistency_info->num_lower = 0;
823      consistency_info->num_non_first_upper = 0;
824    } else if (unicharset.get_islower(unichar_id)) {
825      consistency_info->num_lower++;
826    } else if ((parent_b != nullptr) && unicharset.get_isupper(unichar_id)) {
827      if (unicharset.get_isupper(parent_b->unichar_id()) || consistency_info->num_lower > 0 ||
828          consistency_info->num_non_first_upper > 0) {
829        consistency_info->num_non_first_upper++;
830      }
831    }
832    consistency_info->script_id = unicharset.get_script(unichar_id);
833    if (dict_->getUnicharset().han_sid() != dict_->getUnicharset().null_sid()) {
834      if ((unicharset.hiragana_sid() != unicharset.null_sid() &&
835           consistency_info->script_id == unicharset.hiragana_sid()) ||
836          (unicharset.katakana_sid() != unicharset.null_sid() &&
837           consistency_info->script_id == unicharset.katakana_sid())) {
838        consistency_info->script_id = dict_->getUnicharset().han_sid();
839      }
840    }
841    if (parent_vse != nullptr &&
842        (parent_vse->consistency_info.script_id != dict_->getUnicharset().common_sid())) {
843      int parent_script_id = parent_vse->consistency_info.script_id;
844      if (consistency_info->script_id == dict_->getUnicharset().common_sid()) {
845        consistency_info->script_id = parent_script_id;
846      }
847      if (consistency_info->script_id != parent_script_id) {
848        consistency_info->inconsistent_script = true;
849      }
850    }
<span onclick='openModal()' class='match'>851    if (unicharset.get_isalpha(unichar_id)) {
852      consistency_info->num_alphas++;
853    } else if (unicharset.get_isdigit(unichar_id)) {
854      consistency_info->num_digits++;
855    } else if (!unicharset.get_ispunctuation(unichar_id)) {
</span>856      consistency_info->num_other++;
857    }
858    if (fontinfo_table_->size() > 0 && parent_b != nullptr) {
859      int fontinfo_id = -1;
860      if (parent_b->fontinfo_id() == b->fontinfo_id() ||
861          parent_b->fontinfo_id2() == b->fontinfo_id()) {
862        fontinfo_id = b->fontinfo_id();
863      } else if (parent_b->fontinfo_id() == b->fontinfo_id2() ||
864                 parent_b->fontinfo_id2() == b->fontinfo_id2()) {
865        fontinfo_id = b->fontinfo_id2();
866      }
867      if (language_model_debug_level > 1) {
868        tprintf(
869            "pfont %s pfont %s font %s font2 %s common %s(%d)\n",
870            (parent_b->fontinfo_id() >= 0) ? fontinfo_table_->at(parent_b->fontinfo_id()).name : "",
871            (parent_b->fontinfo_id2() >= 0) ? fontinfo_table_->at(parent_b->fontinfo_id2()).name
872                                            : "",
873            (b->fontinfo_id() >= 0) ? fontinfo_table_->at(b->fontinfo_id()).name : "",
874            (fontinfo_id >= 0) ? fontinfo_table_->at(fontinfo_id).name : "",
875            (fontinfo_id >= 0) ? fontinfo_table_->at(fontinfo_id).name : "", fontinfo_id);
876      }
877      if (!word_res->blob_widths.empty()) { 
878        bool expected_gap_found = false;
879        float expected_gap = 0.0f;
880        int temp_gap;
881        if (fontinfo_id >= 0) { 
882          ASSERT_HOST(fontinfo_id < fontinfo_table_->size());
883          if (fontinfo_table_->at(fontinfo_id)
884                  .get_spacing(parent_b->unichar_id(), unichar_id, &temp_gap)) {
885            expected_gap = temp_gap;
886            expected_gap_found = true;
887          }
888        } else {
889          consistency_info->inconsistent_font = true;
890          int num_addends = 0;
891          int temp_fid;
892          for (int i = 0; i < 4; ++i) {
893            if (i == 0) {
894              temp_fid = parent_b->fontinfo_id();
895            } else if (i == 1) {
896              temp_fid = parent_b->fontinfo_id2();
897            } else if (i == 2) {
898              temp_fid = b->fontinfo_id();
899            } else {
900              temp_fid = b->fontinfo_id2();
901            }
902            ASSERT_HOST(temp_fid < 0 || fontinfo_table_->size());
903            if (temp_fid >= 0 && fontinfo_table_->at(temp_fid).get_spacing(parent_b->unichar_id(),
904                                                                           unichar_id, &temp_gap)) {
905              expected_gap += temp_gap;
906              num_addends++;
907            }
908          }
909          if (num_addends > 0) {
910            expected_gap /= static_cast<float>(num_addends);
911            expected_gap_found = true;
912          }
913        }
914        if (expected_gap_found) {
915          int actual_gap = word_res->GetBlobsGap(curr_col - 1);
916          if (actual_gap == 0) {
917            consistency_info->num_inconsistent_spaces++;
918          } else {
919            float gap_ratio = expected_gap / actual_gap;
920            if (gap_ratio < 0.0f || gap_ratio > 2.0f) {
921              consistency_info->num_inconsistent_spaces++;
922            }
923          }
924          if (language_model_debug_level > 1) {
925            tprintf("spacing for %s(%d) %s(%d) col %d: expected %g actual %d\n",
926                    unicharset.id_to_unichar(parent_b->unichar_id()), parent_b->unichar_id(),
927                    unicharset.id_to_unichar(unichar_id), unichar_id, curr_col, expected_gap,
928                    actual_gap);
929          }
930        }
931      }
932    }
933  }
934  float LanguageModel::ComputeAdjustedPathCost(ViterbiStateEntry *vse) {
935    ASSERT_HOST(vse != nullptr);
936    if (params_model_.Initialized()) {
937      float features[PTRAIN_NUM_FEATURE_TYPES];
938      ExtractFeaturesFromPath(*vse, features);
939      float cost = params_model_.ComputeCost(features);
940      if (language_model_debug_level > 3) {
941        tprintf("ComputeAdjustedPathCost %g ParamsModel features:\n", cost);
942        if (language_model_debug_level >= 5) {
943          for (int f = 0; f < PTRAIN_NUM_FEATURE_TYPES; ++f) {
944            tprintf("%s=%g\n", kParamsTrainingFeatureTypeName[f], features[f]);
945          }
946        }
947      }
948      return cost * vse->outline_length;
949    } else {
950      float adjustment = 1.0f;
951      if (vse->dawg_info == nullptr || vse->dawg_info->permuter != FREQ_DAWG_PERM) {
952        adjustment += language_model_penalty_non_freq_dict_word;
953      }
954      if (vse->dawg_info == nullptr) {
955        adjustment += language_model_penalty_non_dict_word;
956        if (vse->length > language_model_min_compound_length) {
957          adjustment +=
958              ((vse->length - language_model_min_compound_length) * language_model_penalty_increment);
959        }
960      }
961      if (vse->associate_stats.shape_cost > 0) {
962        adjustment += vse->associate_stats.shape_cost / static_cast<float>(vse->length);
963      }
964      if (language_model_ngram_on) {
965        ASSERT_HOST(vse->ngram_info != nullptr);
966        return vse->ngram_info->ngram_and_classifier_cost * adjustment;
967      } else {
968        adjustment += ComputeConsistencyAdjustment(vse->dawg_info, vse->consistency_info);
969        return vse->ratings_sum * adjustment;
970      }
971    }
972  }
973  void LanguageModel::UpdateBestChoice(ViterbiStateEntry *vse, LMPainPoints *pain_points,
974                                       WERD_RES *word_res, BestChoiceBundle *best_choice_bundle,
975                                       BlamerBundle *blamer_bundle) {
976    bool truth_path;
977    WERD_CHOICE *word =
978        ConstructWord(vse, word_res, &best_choice_bundle->fixpt, blamer_bundle, &truth_path);
979    ASSERT_HOST(word != nullptr);
980    if (dict_->stopper_debug_level >= 1) {
981      std::string word_str;
982      word->string_and_lengths(&word_str, nullptr);
983      vse->Print(word_str.c_str());
984    }
985    if (language_model_debug_level > 0) {
986      word->print("UpdateBestChoice() constructed word");
987    }
988    ParamsTrainingHypothesis curr_hyp;
989    if (blamer_bundle != nullptr) {
990      if (vse->dawg_info != nullptr) {
991        vse->dawg_info->permuter = static_cast<PermuterType>(word->permuter());
992      }
993      ExtractFeaturesFromPath(*vse, curr_hyp.features);
994      word->string_and_lengths(&(curr_hyp.str), nullptr);
995      curr_hyp.cost = vse->cost; 
996      if (language_model_debug_level > 0) {
997        tprintf("Raw features extracted from %s (cost=%g) [ ", curr_hyp.str.c_str(), curr_hyp.cost);
998        for (float feature : curr_hyp.features) {
999          tprintf("%g ", feature);
1000        }
1001        tprintf("]\n");
1002      }
1003      blamer_bundle->AddHypothesis(curr_hyp);
1004      if (truth_path) {
1005        blamer_bundle->UpdateBestRating(word->rating());
1006      }
1007    }
1008    if (blamer_bundle != nullptr && blamer_bundle->GuidedSegsearchStillGoing()) {
1009      delete word;
1010      return;
1011    }
1012    if (word_res->chopped_word != nullptr && !word_res->chopped_word->blobs.empty()) {
1013      word->SetScriptPositions(false, word_res->chopped_word, language_model_debug_level);
1014    }
1015    if (word_res->raw_choice == nullptr || word->rating() < word_res->raw_choice->rating()) {
1016      if (word_res->LogNewRawChoice(word) && language_model_debug_level > 0) {
1017        tprintf("Updated raw choice\n");
1018      }
1019    }
1020    word->set_rating(vse->cost);
1021    dict_->adjust_word(word, vse->dawg_info == nullptr, vse->consistency_info.xht_decision, 0.0,
1022                       false, language_model_debug_level > 0);
1023    if (!word_res->LogNewCookedChoice(dict_->tessedit_truncate_wordchoice_log,
1024                                      dict_->stopper_debug_level >= 1, word)) {
1025      return;
1026    }
1027    if (word_res->best_choice == word) {
1028      if (dict_->AcceptableChoice(*word, vse->consistency_info.xht_decision) &&
1029          AcceptablePath(*vse)) {
1030        acceptable_choice_found_ = true;
1031      }
1032      best_choice_bundle->updated = true;
1033      best_choice_bundle->best_vse = vse;
1034      if (language_model_debug_level > 0) {
1035        tprintf("Updated best choice\n");
1036        word->print_state("New state ");
1037      }
1038      if (vse->dawg_info != nullptr) {
1039        if (dict_->has_hyphen_end(*word)) {
1040          dict_->set_hyphen_word(*word, *(dawg_args_.active_dawgs));
1041        } else {
1042          dict_->reset_hyphen_vars(true);
1043        }
1044      }
1045      if (blamer_bundle != nullptr) {
1046        blamer_bundle->set_best_choice_is_dict_and_top_choice(vse->dawg_info != nullptr &&
1047                                                              vse->top_choice_flags);
1048      }
1049    }
1050  #ifndef GRAPHICS_DISABLED
1051    if (wordrec_display_segmentations && word_res->chopped_word != nullptr) {
1052      word->DisplaySegmentation(word_res->chopped_word);
1053    }
1054  #endif
1055  }
1056  void LanguageModel::ExtractFeaturesFromPath(const ViterbiStateEntry &vse, float features[]) {
1057    memset(features, 0, sizeof(float) * PTRAIN_NUM_FEATURE_TYPES);
1058    int len = vse.length <= kMaxSmallWordUnichars ? 0 : vse.length <= kMaxMediumWordUnichars ? 1 : 2;
1059    if (vse.dawg_info != nullptr) {
1060      int permuter = vse.dawg_info->permuter;
1061      if (permuter == NUMBER_PERM || permuter == USER_PATTERN_PERM) {
1062        if (vse.consistency_info.num_digits == vse.length) {
1063          features[PTRAIN_DIGITS_SHORT + len] = 1.0f;
1064        } else {
1065          features[PTRAIN_NUM_SHORT + len] = 1.0f;
1066        }
1067      } else if (permuter == DOC_DAWG_PERM) {
1068        features[PTRAIN_DOC_SHORT + len] = 1.0f;
1069      } else if (permuter == SYSTEM_DAWG_PERM || permuter == USER_DAWG_PERM ||
1070                 permuter == COMPOUND_PERM) {
1071        features[PTRAIN_DICT_SHORT + len] = 1.0f;
1072      } else if (permuter == FREQ_DAWG_PERM) {
1073        features[PTRAIN_FREQ_SHORT + len] = 1.0f;
1074      }
1075    }
1076    features[PTRAIN_SHAPE_COST_PER_CHAR] =
1077        vse.associate_stats.shape_cost / static_cast<float>(vse.length);
1078    features[PTRAIN_NGRAM_COST_PER_CHAR] = 0.0f;
1079    if (vse.ngram_info != nullptr) {
1080      features[PTRAIN_NGRAM_COST_PER_CHAR] =
1081          vse.ngram_info->ngram_cost / static_cast<float>(vse.length);
1082    }
1083    features[PTRAIN_NUM_BAD_CASE] = vse.consistency_info.NumInconsistentCase();
1084    features[PTRAIN_XHEIGHT_CONSISTENCY] = vse.consistency_info.xht_decision;
1085    features[PTRAIN_NUM_BAD_CHAR_TYPE] =
1086        vse.dawg_info == nullptr ? vse.consistency_info.NumInconsistentChartype() : 0.0f;
1087    features[PTRAIN_NUM_BAD_SPACING] = vse.consistency_info.NumInconsistentSpaces();
1088    if (vse.outline_length > 0.0f) {
1089      features[PTRAIN_RATING_PER_CHAR] = vse.ratings_sum / vse.outline_length;
1090    } else {
1091      features[PTRAIN_RATING_PER_CHAR] = 0.0f;
1092    }
1093  }
1094  WERD_CHOICE *LanguageModel::ConstructWord(ViterbiStateEntry *vse, WERD_RES *word_res,
1095                                            DANGERR *fixpt, BlamerBundle *blamer_bundle,
1096                                            bool *truth_path) {
1097    if (truth_path != nullptr) {
1098      *truth_path =
1099          (blamer_bundle != nullptr && vse->length == blamer_bundle->correct_segmentation_length());
1100    }
1101    BLOB_CHOICE *curr_b = vse->curr_b;
1102    ViterbiStateEntry *curr_vse = vse;
1103    int i;
1104    bool compound = dict_->hyphenated(); 
1105    float full_wh_ratio_mean = 0.0f;
1106    if (vse->associate_stats.full_wh_ratio_var != 0.0f) {
1107      vse->associate_stats.shape_cost -= vse->associate_stats.full_wh_ratio_var;
1108      full_wh_ratio_mean =
1109          (vse->associate_stats.full_wh_ratio_total / static_cast<float>(vse->length));
1110      vse->associate_stats.full_wh_ratio_var = 0.0f;
1111    }
1112    auto *word = new WERD_CHOICE(word_res->uch_set, vse->length);
1113    word->set_length(vse->length);
1114    int total_blobs = 0;
1115    for (i = (vse->length - 1); i >= 0; --i) {
1116      if (blamer_bundle != nullptr && truth_path != nullptr && *truth_path &&
1117          !blamer_bundle->MatrixPositionCorrect(i, curr_b->matrix_cell())) {
1118        *truth_path = false;
1119      }
1120      int num_blobs = curr_b->matrix_cell().row - curr_b->matrix_cell().col + 1;
1121      total_blobs += num_blobs;
1122      word->set_blob_choice(i, num_blobs, curr_b);
1123      if ((full_wh_ratio_mean != 0.0f &&
1124           ((curr_vse != vse && curr_vse->parent_vse != nullptr) ||
1125            !dict_->getUnicharset().get_ispunctuation(curr_b->unichar_id())))) {
1126        vse->associate_stats.full_wh_ratio_var +=
1127            pow(full_wh_ratio_mean - curr_vse->associate_stats.full_wh_ratio, 2);
1128        if (language_model_debug_level > 2) {
1129          tprintf("full_wh_ratio_var += (%g-%g)^2\n", full_wh_ratio_mean,
1130                  curr_vse->associate_stats.full_wh_ratio);
1131        }
1132      }
1133      if (!compound && curr_vse->dawg_info && curr_vse->dawg_info->permuter == COMPOUND_PERM) {
1134        compound = true;
1135      }
1136      curr_vse = curr_vse->parent_vse;
1137      if (curr_vse == nullptr) {
1138        break;
1139      }
1140      curr_b = curr_vse->curr_b;
1141    }
1142    ASSERT_HOST(i == 0); 
1143    ASSERT_HOST(total_blobs == word_res->ratings->dimension());
1144    if (full_wh_ratio_mean != 0.0f) {
1145      vse->associate_stats.shape_cost += vse->associate_stats.full_wh_ratio_var;
1146    }
1147    word->set_rating(vse->ratings_sum);
1148    word->set_certainty(vse->min_certainty);
1149    word->set_x_heights(vse->consistency_info.BodyMinXHeight(),
1150                        vse->consistency_info.BodyMaxXHeight());
1151    if (vse->dawg_info != nullptr) {
1152      word->set_permuter(compound ? COMPOUND_PERM : vse->dawg_info->permuter);
1153    } else if (language_model_ngram_on && !vse->ngram_info->pruned) {
1154      word->set_permuter(NGRAM_PERM);
1155    } else if (vse->top_choice_flags) {
1156      word->set_permuter(TOP_CHOICE_PERM);
1157    } else {
1158      word->set_permuter(NO_PERM);
1159    }
1160    word->set_dangerous_ambig_found_(!dict_->NoDangerousAmbig(word, fixpt, true, word_res->ratings));
1161    return word;
1162  }
1163  } 
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-json_handler.cpp</h3>
            <pre><code>1  #include <nano/lib/config.hpp>
2  #include <nano/lib/json_error_response.hpp>
3  #include <nano/lib/timer.hpp>
4  #include <nano/node/bootstrap/bootstrap_lazy.hpp>
5  #include <nano/node/bootstrap_ascending/service.hpp>
6  #include <nano/node/common.hpp>
7  #include <nano/node/election.hpp>
8  #include <nano/node/json_handler.hpp>
9  #include <nano/node/node.hpp>
10  #include <nano/node/node_rpc_config.hpp>
11  #include <nano/node/telemetry.hpp>
12  #include <boost/property_tree/json_parser.hpp>
13  #include <boost/property_tree/ptree.hpp>
14  #include <algorithm>
15  #include <chrono>
16  #include <vector>
17  namespace
18  {
19  void construct_json (nano::container_info_component * component, boost::property_tree::ptree & parent);
20  using ipc_json_handler_no_arg_func_map = std::unordered_map<std::string, std::function<void (nano::json_handler *)>>;
21  ipc_json_handler_no_arg_func_map create_ipc_json_handler_no_arg_func_map ();
22  auto ipc_json_handler_no_arg_funcs = create_ipc_json_handler_no_arg_func_map ();
23  bool block_confirmed (nano::node & node, nano::transaction & transaction, nano::block_hash const & hash, bool include_active, bool include_only_confirmed);
24  char const * epoch_as_string (nano::epoch);
25  }
26  nano::json_handler::json_handler (nano::node & node_a, nano::node_rpc_config const & node_rpc_config_a, std::string const & body_a, std::function<void (std::string const &)> const & response_a, std::function<void ()> stop_callback_a) :
27  	body (body_a),
28  	node (node_a),
29  	response (response_a),
30  	stop_callback (stop_callback_a),
31  	node_rpc_config (node_rpc_config_a)
32  {
33  }
34  std::function<void ()> nano::json_handler::create_worker_task (std::function<void (std::shared_ptr<nano::json_handler> const &)> const & action_a)
35  {
36  	return [rpc_l = shared_from_this (), action_a] () {
37  		try
38  		{
39  			action_a (rpc_l);
40  		}
41  		catch (std::runtime_error const &)
42  		{
43  			json_error_response (rpc_l->response, "Unable to parse JSON");
44  		}
45  		catch (...)
46  		{
47  			json_error_response (rpc_l->response, "Internal server error in RPC");
48  		}
49  	};
50  }
51  void nano::json_handler::process_request (bool unsafe_a)
52  {
53  	try
54  	{
55  		std::stringstream istream (body);
56  		boost::property_tree::read_json (istream, request);
57  		if (node_rpc_config.request_callback)
58  		{
59  			debug_assert (node.network_params.network.is_dev_network ());
60  			node_rpc_config.request_callback (request);
61  		}
62  		action = request.get<std::string> ("action");
63  		auto no_arg_func_iter = ipc_json_handler_no_arg_funcs.find (action);
64  		if (no_arg_func_iter != ipc_json_handler_no_arg_funcs.cend ())
65  		{
66  			no_arg_func_iter->second (this);
67  		}
68  		else
69  		{
70  			if (action == "wallet_seed")
71  			{
72  				if (unsafe_a || node.network_params.network.is_dev_network ())
73  				{
74  					wallet_seed ();
75  				}
76  				else
77  				{
78  					json_error_response (response, "Unsafe RPC not allowed");
79  				}
80  			}
81  			else if (action == "chain")
82  			{
83  				chain ();
84  			}
85  			else if (action == "successors")
86  			{
87  				chain (true);
88  			}
89  			else if (action == "history")
90  			{
91  				response_l.put ("deprecated", "1");
92  				request.put ("head", request.get<std::string> ("hash"));
93  				account_history ();
94  			}
95  			else if (action == "knano_from_raw" || action == "krai_from_raw")
96  			{
97  				mnano_from_raw (nano::kxrb_ratio);
98  			}
99  			else if (action == "knano_to_raw" || action == "krai_to_raw")
100  			{
101  				mnano_to_raw (nano::kxrb_ratio);
102  			}
103  			else if (action == "rai_from_raw")
104  			{
105  				mnano_from_raw (nano::xrb_ratio);
106  			}
107  			else if (action == "rai_to_raw")
108  			{
109  				mnano_to_raw (nano::xrb_ratio);
110  			}
111  			else if (action == "mnano_from_raw" || action == "mrai_from_raw")
112  			{
113  				mnano_from_raw ();
114  			}
115  			else if (action == "mnano_to_raw" || action == "mrai_to_raw")
116  			{
117  				mnano_to_raw ();
118  			}
119  			else if (action == "nano_to_raw")
120  			{
121  				nano_to_raw ();
122  			}
123  			else if (action == "raw_to_nano")
124  			{
125  				raw_to_nano ();
126  			}
127  			else if (action == "password_valid")
128  			{
129  				password_valid ();
130  			}
131  			else if (action == "wallet_locked")
132  			{
133  				password_valid (true);
134  			}
135  			else
136  			{
137  				json_error_response (response, "Unknown command");
138  			}
139  		}
140  	}
141  	catch (std::runtime_error const &)
142  	{
143  		json_error_response (response, "Unable to parse JSON");
144  	}
145  	catch (...)
146  	{
147  		json_error_response (response, "Internal server error in RPC");
148  	}
149  }
150  void nano::json_handler::response_errors ()
151  {
152  	if (!ec && response_l.empty ())
153  	{
154  		ec = nano::error_rpc::empty_response;
155  	}
156  	if (ec)
157  	{
158  		boost::property_tree::ptree response_error;
159  		response_error.put ("error", ec.message ());
160  		std::stringstream ostream;
161  		boost::property_tree::write_json (ostream, response_error);
162  		response (ostream.str ());
163  	}
164  	else
165  	{
166  		std::stringstream ostream;
167  		boost::property_tree::write_json (ostream, response_l);
168  		response (ostream.str ());
169  	}
170  }
171  std::shared_ptr<nano::wallet> nano::json_handler::wallet_impl ()
172  {
173  	if (!ec)
174  	{
175  		std::string wallet_text (request.get<std::string> ("wallet"));
176  		nano::wallet_id wallet;
177  		if (!wallet.decode_hex (wallet_text))
178  		{
179  			if (auto existing = node.wallets.open (wallet); existing != nullptr)
180  			{
181  				return existing;
182  			}
183  			else
184  			{
185  				ec = nano::error_common::wallet_not_found;
186  			}
187  		}
188  		else
189  		{
190  			ec = nano::error_common::bad_wallet_number;
191  		}
192  	}
193  	return nullptr;
194  }
195  bool nano::json_handler::wallet_locked_impl (nano::transaction const & transaction_a, std::shared_ptr<nano::wallet> const & wallet_a)
196  {
197  	bool result (false);
198  	if (!ec)
199  	{
200  		if (!wallet_a->store.valid_password (transaction_a))
201  		{
202  			ec = nano::error_common::wallet_locked;
203  			result = true;
204  		}
205  	}
206  	return result;
207  }
208  bool nano::json_handler::wallet_account_impl (nano::transaction const & transaction_a, std::shared_ptr<nano::wallet> const & wallet_a, nano::account const & account_a)
209  {
210  	bool result (false);
211  	if (!ec)
212  	{
213  		if (wallet_a->store.find (transaction_a, account_a) != wallet_a->store.end ())
214  		{
215  			result = true;
216  		}
217  		else
218  		{
219  			ec = nano::error_common::account_not_found_wallet;
220  		}
221  	}
222  	return result;
223  }
224  nano::account nano::json_handler::account_impl (std::string account_text, std::error_code ec_a)
225  {
226  	nano::account result{};
227  	if (!ec)
228  	{
229  		if (account_text.empty ())
230  		{
231  			account_text = request.get<std::string> ("account");
232  		}
233  		if (result.decode_account (account_text))
234  		{
235  			ec = ec_a;
236  		}
237  		else if (account_text[3] == '-' || account_text[4] == '-')
238  		{
239  			response_l.put ("deprecated_account_format", "1");
240  		}
241  	}
242  	return result;
243  }
244  nano::account_info nano::json_handler::account_info_impl (nano::transaction const & transaction_a, nano::account const & account_a)
245  {
246  	nano::account_info result;
247  	if (!ec)
248  	{
249  		auto info = node.ledger.account_info (transaction_a, account_a);
250  		if (!info)
251  		{
252  			ec = nano::error_common::account_not_found;
253  			node.bootstrap_initiator.bootstrap_lazy (account_a, false, account_a.to_account ());
254  		}
255  		else
256  		{
257  			result = *info;
258  		}
259  	}
260  	return result;
261  }
262  nano::amount nano::json_handler::amount_impl ()
263  {
264  	nano::amount result (0);
265  	if (!ec)
266  	{
267  		std::string amount_text (request.get<std::string> ("amount"));
268  		if (result.decode_dec (amount_text))
269  		{
270  			ec = nano::error_common::invalid_amount;
271  		}
272  	}
273  	return result;
274  }
275  std::shared_ptr<nano::block> nano::json_handler::block_impl (bool signature_work_required)
276  {
277  	bool const json_block_l = request.get<bool> ("json_block", false);
278  	std::shared_ptr<nano::block> result{ nullptr };
279  	if (!ec)
280  	{
281  		boost::property_tree::ptree block_l;
282  		if (json_block_l)
283  		{
284  			block_l = request.get_child ("block");
285  		}
286  		else
287  		{
288  			std::string block_text (request.get<std::string> ("block"));
289  			std::stringstream block_stream (block_text);
290  			try
291  			{
292  				boost::property_tree::read_json (block_stream, block_l);
293  			}
294  			catch (...)
295  			{
296  				ec = nano::error_blocks::invalid_block;
297  			}
298  		}
299  		if (!ec)
300  		{
301  			if (!signature_work_required)
302  			{
303  				block_l.put ("signature", "0");
304  				block_l.put ("work", "0");
305  			}
306  			result = nano::deserialize_block_json (block_l);
307  			if (result == nullptr)
308  			{
309  				ec = nano::error_blocks::invalid_block;
310  			}
311  		}
312  	}
313  	return result;
314  }
315  nano::block_hash nano::json_handler::hash_impl (std::string search_text)
316  {
317  	nano::block_hash result (0);
318  	if (!ec)
319  	{
320  		std::string hash_text (request.get<std::string> (search_text));
321  		if (result.decode_hex (hash_text))
322  		{
323  			ec = nano::error_blocks::invalid_block_hash;
324  		}
325  	}
326  	return result;
327  }
328  nano::amount nano::json_handler::threshold_optional_impl ()
329  {
330  	nano::amount result (0);
331  	boost::optional<std::string> threshold_text (request.get_optional<std::string> ("threshold"));
332  	if (!ec && threshold_text.is_initialized ())
333  	{
334  		if (result.decode_dec (threshold_text.get ()))
335  		{
336  			ec = nano::error_common::bad_threshold;
337  		}
338  	}
339  	return result;
340  }
341  uint64_t nano::json_handler::work_optional_impl ()
342  {
343  	uint64_t result (0);
344  	boost::optional<std::string> work_text (request.get_optional<std::string> ("work"));
345  	if (!ec && work_text.is_initialized ())
346  	{
347  		if (nano::from_string_hex (work_text.get (), result))
348  		{
349  			ec = nano::error_common::bad_work_format;
350  		}
351  	}
352  	return result;
353  }
354  uint64_t nano::json_handler::difficulty_optional_impl (nano::work_version const version_a)
355  {
356  	auto difficulty (node.default_difficulty (version_a));
357  	boost::optional<std::string> difficulty_text (request.get_optional<std::string> ("difficulty"));
358  	if (!ec && difficulty_text.is_initialized ())
359  	{
360  		if (nano::from_string_hex (difficulty_text.get (), difficulty))
361  		{
362  			ec = nano::error_rpc::bad_difficulty_format;
363  		}
364  	}
365  	return difficulty;
366  }
367  uint64_t nano::json_handler::difficulty_ledger (nano::block const & block_a)
368  {
369  	nano::block_details details (nano::epoch::epoch_0, false, false, false);
370  	bool details_found (false);
371  	auto transaction (node.store.tx_begin_read ());
372  	std::shared_ptr<nano::block> block_previous (nullptr);
373  	auto previous (block_a.previous ());
374  	if (!previous.is_zero ())
375  	{
376  		block_previous = node.store.block.get (transaction, previous);
377  	}
378  	if (block_previous != nullptr)
379  	{
380  		details.is_send = node.store.block.balance (transaction, previous) > block_a.balance ().number ();
381  		details_found = true;
382  	}
383  	if (block_previous != nullptr)
384  	{
385  		details.epoch = block_previous->sideband ().details.epoch;
386  	}
387  	auto link (block_a.link ());
388  	if (!link.is_zero () && !details.is_send)
389  	{
390  		auto block_link (node.store.block.get (transaction, link.as_block_hash ()));
391  		if (block_link != nullptr && node.store.pending.exists (transaction, nano::pending_key (block_a.account (), link.as_block_hash ())))
392  		{
393  			details.epoch = std::max (details.epoch, block_link->sideband ().details.epoch);
394  			details.is_receive = true;
395  			details_found = true;
396  		}
397  	}
398  	return details_found ? node.network_params.work.threshold (block_a.work_version (), details) : node.default_difficulty (block_a.work_version ());
399  }
400  double nano::json_handler::multiplier_optional_impl (nano::work_version const version_a, uint64_t & difficulty)
401  {
402  	double multiplier (1.);
403  	boost::optional<std::string> multiplier_text (request.get_optional<std::string> ("multiplier"));
404  	if (!ec && multiplier_text.is_initialized ())
405  	{
406  		auto success = boost::conversion::try_lexical_convert<double> (multiplier_text.get (), multiplier);
407  		if (success && multiplier > 0.)
408  		{
409  			difficulty = nano::difficulty::from_multiplier (multiplier, node.default_difficulty (version_a));
410  		}
411  		else
412  		{
413  			ec = nano::error_rpc::bad_multiplier_format;
414  		}
415  	}
416  	return multiplier;
417  }
418  nano::work_version nano::json_handler::work_version_optional_impl (nano::work_version const default_a)
419  {
420  	nano::work_version result = default_a;
421  	boost::optional<std::string> version_text (request.get_optional<std::string> ("version"));
422  	if (!ec && version_text.is_initialized ())
423  	{
424  		if (*version_text == nano::to_string (nano::work_version::work_1))
425  		{
426  			result = nano::work_version::work_1;
427  		}
428  		else
429  		{
430  			ec = nano::error_rpc::bad_work_version;
431  		}
432  	}
433  	return result;
434  }
435  namespace
436  {
437  bool decode_unsigned (std::string const & text, uint64_t & number)
438  {
439  	bool result;
440  	std::size_t end;
441  	try
442  	{
443  		number = std::stoull (text, &end);
444  		result = false;
445  	}
446  	catch (std::invalid_argument const &)
447  	{
448  		result = true;
449  	}
450  	catch (std::out_of_range const &)
451  	{
452  		result = true;
453  	}
454  	result = result || end != text.size ();
455  	return result;
456  }
457  }
458  uint64_t nano::json_handler::count_impl ()
459  {
460  	uint64_t result (0);
461  	if (!ec)
462  	{
463  		std::string count_text (request.get<std::string> ("count"));
464  		if (decode_unsigned (count_text, result) || result == 0)
465  		{
466  			ec = nano::error_common::invalid_count;
467  		}
468  	}
469  	return result;
470  }
471  uint64_t nano::json_handler::count_optional_impl (uint64_t result)
472  {
473  	boost::optional<std::string> count_text (request.get_optional<std::string> ("count"));
474  	if (!ec && count_text.is_initialized ())
475  	{
476  		if (decode_unsigned (count_text.get (), result))
477  		{
478  			ec = nano::error_common::invalid_count;
479  		}
480  	}
481  	return result;
482  }
483  uint64_t nano::json_handler::offset_optional_impl (uint64_t result)
484  {
485  	boost::optional<std::string> offset_text (request.get_optional<std::string> ("offset"));
486  	if (!ec && offset_text.is_initialized ())
487  	{
488  		if (decode_unsigned (offset_text.get (), result))
489  		{
490  			ec = nano::error_rpc::invalid_offset;
491  		}
492  	}
493  	return result;
494  }
495  void nano::json_handler::account_balance ()
496  {
497  	auto account (account_impl ());
498  	if (!ec)
499  	{
500  		bool const include_only_confirmed = request.get<bool> ("include_only_confirmed", true);
501  		auto balance (node.balance_pending (account, include_only_confirmed));
502  		response_l.put ("balance", balance.first.convert_to<std::string> ());
503  		response_l.put ("pending", balance.second.convert_to<std::string> ());
504  		response_l.put ("receivable", balance.second.convert_to<std::string> ());
505  	}
506  	response_errors ();
507  }
508  void nano::json_handler::account_block_count ()
509  {
510  	auto account (account_impl ());
511  	if (!ec)
512  	{
513  		auto transaction (node.store.tx_begin_read ());
514  		auto info (account_info_impl (transaction, account));
515  		if (!ec)
516  		{
517  			response_l.put ("block_count", std::to_string (info.block_count));
518  		}
519  	}
520  	response_errors ();
521  }
522  void nano::json_handler::account_create ()
523  {
524  	node.workers.push_task (create_worker_task ([] (std::shared_ptr<nano::json_handler> const & rpc_l) {
525  		auto wallet (rpc_l->wallet_impl ());
526  		if (!rpc_l->ec)
527  		{
528  			bool const generate_work = rpc_l->request.get<bool> ("work", true);
529  			nano::account new_key;
530  			auto index_text (rpc_l->request.get_optional<std::string> ("index"));
531  			if (index_text.is_initialized ())
532  			{
533  				uint64_t index;
534  				if (decode_unsigned (index_text.get (), index) || index > static_cast<uint64_t> (std::numeric_limits<uint32_t>::max ()))
535  				{
536  					rpc_l->ec = nano::error_common::invalid_index;
537  				}
538  				else
539  				{
540  					new_key = wallet->deterministic_insert (static_cast<uint32_t> (index), generate_work);
541  				}
542  			}
543  			else
544  			{
545  				new_key = wallet->deterministic_insert (generate_work);
546  			}
547  			if (!rpc_l->ec)
548  			{
549  				if (!new_key.is_zero ())
550  				{
551  					rpc_l->response_l.put ("account", new_key.to_account ());
552  				}
553  				else
554  				{
555  					rpc_l->ec = nano::error_common::wallet_locked;
556  				}
557  			}
558  		}
559  		rpc_l->response_errors ();
560  	}));
561  }
562  void nano::json_handler::account_get ()
563  {
564  	std::string key_text (request.get<std::string> ("key"));
565  	nano::public_key pub;
566  	if (!pub.decode_hex (key_text))
567  	{
568  		response_l.put ("account", pub.to_account ());
569  	}
570  	else
571  	{
572  		ec = nano::error_common::bad_public_key;
573  	}
574  	response_errors ();
575  }
576  void nano::json_handler::account_info ()
577  {
578  	auto account (account_impl ());
579  	if (!ec)
580  	{
581  		bool const representative = request.get<bool> ("representative", false);
582  		bool const weight = request.get<bool> ("weight", false);
583  		bool const pending = request.get<bool> ("pending", false);
584  		bool const receivable = request.get<bool> ("receivable", pending);
585  		bool const include_confirmed = request.get<bool> ("include_confirmed", false);
586  		auto transaction (node.store.tx_begin_read ());
587  		auto info (account_info_impl (transaction, account));
588  		nano::confirmation_height_info confirmation_height_info;
589  		node.store.confirmation_height.get (transaction, account, confirmation_height_info);
590  		if (!ec)
591  		{
592  			response_l.put ("frontier", info.head.to_string ());
593  			response_l.put ("open_block", info.open_block.to_string ());
594  			response_l.put ("representative_block", node.ledger.representative (transaction, info.head).to_string ());
595  			nano::amount balance_l (info.balance);
596  			std::string balance;
597  			balance_l.encode_dec (balance);
598  			response_l.put ("balance", balance);
599  			nano::amount confirmed_balance_l;
600  			if (include_confirmed)
601  			{
602  				if (info.block_count != confirmation_height_info.height)
603  				{
604  					confirmed_balance_l = node.ledger.balance (transaction, confirmation_height_info.frontier);
605  				}
606  				else
607  				{
608  					confirmed_balance_l = balance_l;
609  				}
610  				std::string confirmed_balance;
611  				confirmed_balance_l.encode_dec (confirmed_balance);
612  				response_l.put ("confirmed_balance", confirmed_balance);
613  			}
614  			response_l.put ("modified_timestamp", std::to_string (info.modified));
615  			response_l.put ("block_count", std::to_string (info.block_count));
616  			response_l.put ("account_version", epoch_as_string (info.epoch ()));
617  			auto confirmed_frontier = confirmation_height_info.frontier.to_string ();
618  			if (include_confirmed)
619  			{
620  				response_l.put ("confirmed_height", std::to_string (confirmation_height_info.height));
621  				response_l.put ("confirmed_frontier", confirmed_frontier);
622  			}
623  			else
624  			{
625  				response_l.put ("confirmation_height", std::to_string (confirmation_height_info.height));
626  				response_l.put ("confirmation_height_frontier", confirmed_frontier);
627  			}
628  			std::shared_ptr<nano::block> confirmed_frontier_block;
629  			if (include_confirmed && confirmation_height_info.height > 0)
630  			{
631  				confirmed_frontier_block = node.store.block.get (transaction, confirmation_height_info.frontier);
632  			}
633  			if (representative)
634  			{
635  				response_l.put ("representative", info.representative.to_account ());
636  				if (include_confirmed)
637  				{
638  					nano::account confirmed_representative{};
639  					if (confirmed_frontier_block)
640  					{
641  						confirmed_representative = confirmed_frontier_block->representative ();
642  						if (confirmed_representative.is_zero ())
643  						{
644  							confirmed_representative = node.store.block.get (transaction, node.ledger.representative (transaction, confirmation_height_info.frontier))->representative ();
645  						}
646  					}
647  					response_l.put ("confirmed_representative", confirmed_representative.to_account ());
648  				}
649  			}
650  			if (weight)
651  			{
652  				auto account_weight (node.ledger.weight (account));
653  				response_l.put ("weight", account_weight.convert_to<std::string> ());
654  			}
655  			if (receivable)
656  			{
657  				auto account_receivable = node.ledger.account_receivable (transaction, account);
658  				response_l.put ("pending", account_receivable.convert_to<std::string> ());
659  				response_l.put ("receivable", account_receivable.convert_to<std::string> ());
660  				if (include_confirmed)
661  				{
662  					auto account_receivable = node.ledger.account_receivable (transaction, account, true);
663  					response_l.put ("confirmed_pending", account_receivable.convert_to<std::string> ());
664  					response_l.put ("confirmed_receivable", account_receivable.convert_to<std::string> ());
665  				}
666  			}
667  		}
668  	}
669  	response_errors ();
670  }
671  void nano::json_handler::account_key ()
672  {
673  	auto account (account_impl ());
674  	if (!ec)
675  	{
676  		response_l.put ("key", account.to_string ());
677  	}
678  	response_errors ();
679  }
680  void nano::json_handler::account_list ()
681  {
682  	auto wallet (wallet_impl ());
683  	if (!ec)
684  	{
685  		boost::property_tree::ptree accounts;
686  		auto transaction (node.wallets.tx_begin_read ());
687  		for (auto i (wallet->store.begin (transaction)), j (wallet->store.end ()); i != j; ++i)
688  		{
689  			boost::property_tree::ptree entry;
690  			entry.put ("", nano::account (i->first).to_account ());
691  			accounts.push_back (std::make_pair ("", entry));
692  		}
693  		response_l.add_child ("accounts", accounts);
694  	}
695  	response_errors ();
696  }
697  void nano::json_handler::account_move ()
698  {
699  	node.workers.push_task (create_worker_task ([] (std::shared_ptr<nano::json_handler> const & rpc_l) {
700  		auto wallet (rpc_l->wallet_impl ());
701  		if (!rpc_l->ec)
702  		{
703  			std::string source_text (rpc_l->request.get<std::string> ("source"));
704  			auto accounts_text (rpc_l->request.get_child ("accounts"));
705  			nano::wallet_id source;
706  			if (!source.decode_hex (source_text))
707  			{
708  				auto existing (rpc_l->node.wallets.items.find (source));
709  				if (existing != rpc_l->node.wallets.items.end ())
710  				{
711  					auto source (existing->second);
712  					std::vector<nano::public_key> accounts;
713  					for (auto i (accounts_text.begin ()), n (accounts_text.end ()); i != n; ++i)
714  					{
715  						auto account (rpc_l->account_impl (i->second.get<std::string> ("")));
716  						accounts.push_back (account);
717  					}
718  					auto transaction (rpc_l->node.wallets.tx_begin_write ());
719  					auto error (wallet->store.move (transaction, source->store, accounts));
720  					rpc_l->response_l.put ("moved", error ? "0" : "1");
721  				}
722  				else
723  				{
724  					rpc_l->ec = nano::error_rpc::source_not_found;
725  				}
726  			}
727  			else
728  			{
729  				rpc_l->ec = nano::error_rpc::bad_source;
730  			}
731  		}
732  		rpc_l->response_errors ();
733  	}));
734  }
735  void nano::json_handler::account_remove ()
736  {
737  	node.workers.push_task (create_worker_task ([] (std::shared_ptr<nano::json_handler> const & rpc_l) {
738  		auto wallet (rpc_l->wallet_impl ());
739  		auto account (rpc_l->account_impl ());
740  		if (!rpc_l->ec)
741  		{
742  			auto transaction (rpc_l->node.wallets.tx_begin_write ());
743  			rpc_l->wallet_locked_impl (transaction, wallet);
744  			rpc_l->wallet_account_impl (transaction, wallet, account);
745  			if (!rpc_l->ec)
746  			{
747  				wallet->store.erase (transaction, account);
748  				rpc_l->response_l.put ("removed", "1");
749  			}
750  		}
751  		rpc_l->response_errors ();
752  	}));
753  }
754  void nano::json_handler::account_representative ()
755  {
756  	auto account (account_impl ());
757  	if (!ec)
758  	{
759  		auto transaction (node.store.tx_begin_read ());
760  		auto info (account_info_impl (transaction, account));
761  		if (!ec)
762  		{
763  			response_l.put ("representative", info.representative.to_account ());
764  		}
765  	}
766  	response_errors ();
767  }
768  void nano::json_handler::account_representative_set ()
769  {
770  	node.workers.push_task (create_worker_task ([work_generation_enabled = node.work_generation_enabled ()] (std::shared_ptr<nano::json_handler> const & rpc_l) {
771  		auto wallet (rpc_l->wallet_impl ());
772  		auto account (rpc_l->account_impl ());
773  		std::string representative_text (rpc_l->request.get<std::string> ("representative"));
774  		auto representative (rpc_l->account_impl (representative_text, nano::error_rpc::bad_representative_number));
775  		if (!rpc_l->ec)
776  		{
777  			auto work (rpc_l->work_optional_impl ());
778  			if (!rpc_l->ec && work)
779  			{
780  				auto transaction (rpc_l->node.wallets.tx_begin_write ());
781  				rpc_l->wallet_locked_impl (transaction, wallet);
782  				rpc_l->wallet_account_impl (transaction, wallet, account);
783  				if (!rpc_l->ec)
784  				{
785  					auto block_transaction (rpc_l->node.store.tx_begin_read ());
786  					auto info (rpc_l->account_info_impl (block_transaction, account));
787  					if (!rpc_l->ec)
788  					{
789  						nano::block_details details (info.epoch (), false, false, false);
790  						if (rpc_l->node.network_params.work.difficulty (nano::work_version::work_1, info.head, work) < rpc_l->node.network_params.work.threshold (nano::work_version::work_1, details))
791  						{
792  							rpc_l->ec = nano::error_common::invalid_work;
793  						}
794  					}
795  				}
796  			}
797  			else if (!rpc_l->ec) 
798  			{
799  				if (!work_generation_enabled)
800  				{
801  					rpc_l->ec = nano::error_common::disabled_work_generation;
802  				}
803  			}
804  			if (!rpc_l->ec)
805  			{
806  				bool generate_work (work == 0); 
807  				auto response_a (rpc_l->response);
808  				auto response_data (std::make_shared<boost::property_tree::ptree> (rpc_l->response_l));
809  				wallet->change_async (
810  				account, representative, [response_a, response_data] (std::shared_ptr<nano::block> const & block) {
811  					if (block != nullptr)
812  					{
813  						response_data->put ("block", block->hash ().to_string ());
814  						std::stringstream ostream;
815  						boost::property_tree::write_json (ostream, *response_data);
816  						response_a (ostream.str ());
817  					}
818  					else
819  					{
820  						json_error_response (response_a, "Error generating block");
821  					}
822  				},
823  				work, generate_work);
824  			}
825  		}
826  		if (rpc_l->ec)
827  		{
828  			rpc_l->response_errors ();
829  		}
830  	}));
831  }
832  void nano::json_handler::account_weight ()
833  {
834  	auto account (account_impl ());
835  	if (!ec)
836  	{
837  		auto balance (node.weight (account));
838  		response_l.put ("weight", balance.convert_to<std::string> ());
839  	}
840  	response_errors ();
841  }
842  void nano::json_handler::accounts_balances ()
843  {
844  	boost::property_tree::ptree balances;
845  	boost::property_tree::ptree errors;
846  	auto transaction = node.store.tx_begin_read ();
847  	for (auto & account_from_request : request.get_child ("accounts"))
848  	{
849  		boost::property_tree::ptree entry;
850  		auto account = account_impl (account_from_request.second.data ());
851  		if (!ec)
852  		{
853  			bool const include_only_confirmed = request.get<bool> ("include_only_confirmed", true);
854  			auto balance = node.balance_pending (account, include_only_confirmed);
855  			entry.put ("balance", balance.first.convert_to<std::string> ());
856  			entry.put ("pending", balance.second.convert_to<std::string> ());
857  			entry.put ("receivable", balance.second.convert_to<std::string> ());
858  			balances.put_child (account_from_request.second.data (), entry);
859  			continue;
860  		}
861  		debug_assert (ec);
862  		errors.put (account_from_request.second.data (), ec.message ());
863  		ec = {};
864  	}
865  	if (!balances.empty ())
866  	{
867  		response_l.add_child ("balances", balances);
868  	}
869  	if (!errors.empty ())
870  	{
871  		response_l.add_child ("errors", errors);
872  	}
873  	response_errors ();
874  }
875  void nano::json_handler::accounts_representatives ()
876  {
877  	boost::property_tree::ptree representatives;
878  	boost::property_tree::ptree errors;
879  	auto transaction = node.store.tx_begin_read ();
880  	for (auto & account_from_request : request.get_child ("accounts"))
881  	{
882  		auto account = account_impl (account_from_request.second.data ());
883  		if (!ec)
884  		{
885  			auto info = account_info_impl (transaction, account);
886  			if (!ec)
887  			{
888  				representatives.put (account_from_request.second.data (), info.representative.to_account ());
889  				continue;
890  			}
891  		}
892  		debug_assert (ec);
893  		errors.put (account_from_request.second.data (), ec.message ());
894  		ec = {};
895  	}
896  	if (!representatives.empty ())
897  	{
898  		response_l.add_child ("representatives", representatives);
899  	}
900  	if (!errors.empty ())
901  	{
902  		response_l.add_child ("errors", errors);
903  	}
904  	response_errors ();
905  }
906  void nano::json_handler::accounts_create ()
907  {
908  	node.workers.push_task (create_worker_task ([] (std::shared_ptr<nano::json_handler> const & rpc_l) {
909  		auto wallet (rpc_l->wallet_impl ());
910  		auto count (rpc_l->count_impl ());
911  		if (!rpc_l->ec)
912  		{
913  			bool const generate_work = rpc_l->request.get<bool> ("work", false);
914  			boost::property_tree::ptree accounts;
915  			for (auto i (0); accounts.size () < count; ++i)
916  			{
917  				nano::account new_key (wallet->deterministic_insert (generate_work));
918  				if (!new_key.is_zero ())
919  				{
920  					boost::property_tree::ptree entry;
921  					entry.put ("", new_key.to_account ());
922  					accounts.push_back (std::make_pair ("", entry));
923  				}
924  			}
925  			rpc_l->response_l.add_child ("accounts", accounts);
926  		}
927  		rpc_l->response_errors ();
928  	}));
929  }
930  void nano::json_handler::accounts_frontiers ()
931  {
932  	boost::property_tree::ptree frontiers;
933  	boost::property_tree::ptree errors;
934  	auto transaction = node.store.tx_begin_read ();
935  	for (auto & account_from_request : request.get_child ("accounts"))
936  	{
937  		auto account = account_impl (account_from_request.second.data ());
938  		if (!ec)
939  		{
940  			auto latest = node.ledger.latest (transaction, account);
941  			if (!latest.is_zero ())
942  			{
943  				frontiers.put (account.to_account (), latest.to_string ());
944  				continue;
945  			}
946  			else
947  			{
948  				ec = nano::error_common::account_not_found;
949  			}
950  		}
951  		debug_assert (ec);
952  		errors.put (account_from_request.second.data (), ec.message ());
953  		ec = {};
954  	}
955  	if (!frontiers.empty ())
956  	{
957  		response_l.add_child ("frontiers", frontiers);
958  	}
959  	if (!errors.empty ())
960  	{
961  		response_l.add_child ("errors", errors);
962  	}
963  	response_errors ();
964  }
965  void nano::json_handler::accounts_pending ()
966  {
967  	response_l.put ("deprecated", "1");
968  	accounts_receivable ();
969  }
970  void nano::json_handler::accounts_receivable ()
971  {
972  	auto count (count_optional_impl ());
973  	auto threshold (threshold_optional_impl ());
974  	bool const source = request.get<bool> ("source", false);
975  	bool const include_active = request.get<bool> ("include_active", false);
976  	bool const include_only_confirmed = request.get<bool> ("include_only_confirmed", true);
977  	bool const sorting = request.get<bool> ("sorting", false);
978  	auto simple (threshold.is_zero () && !source && !sorting); 
979  	boost::property_tree::ptree pending;
980  	auto transaction (node.store.tx_begin_read ());
981  	for (auto & accounts : request.get_child ("accounts"))
982  	{
983  		auto account (account_impl (accounts.second.data ()));
984  		if (!ec)
985  		{
986  			boost::property_tree::ptree peers_l;
987  			for (auto i (node.store.pending.begin (transaction, nano::pending_key (account, 0))), n (node.store.pending.end ()); i != n && nano::pending_key (i->first).account == account && peers_l.size () < count; ++i)
988  			{
989  				nano::pending_key const & key (i->first);
990  				if (block_confirmed (node, transaction, key.hash, include_active, include_only_confirmed))
991  				{
992  					if (simple)
993  					{
994  						boost::property_tree::ptree entry;
995  						entry.put ("", key.hash.to_string ());
996  						peers_l.push_back (std::make_pair ("", entry));
997  					}
998  					else
999  					{
1000  						nano::pending_info const & info (i->second);
1001  						if (info.amount.number () >= threshold.number ())
1002  						{
1003  							if (source)
1004  							{
1005  								boost::property_tree::ptree pending_tree;
1006  								pending_tree.put ("amount", info.amount.number ().convert_to<std::string> ());
1007  								pending_tree.put ("source", info.source.to_account ());
1008  								peers_l.add_child (key.hash.to_string (), pending_tree);
1009  							}
1010  							else
1011  							{
1012  								peers_l.put (key.hash.to_string (), info.amount.number ().convert_to<std::string> ());
1013  							}
1014  						}
1015  					}
1016  				}
1017  			}
1018  			if (sorting && !simple)
1019  			{
1020  				if (source)
1021  				{
1022  					peers_l.sort ([] (auto const & child1, auto const & child2) -> bool {
1023  						return child1.second.template get<nano::uint128_t> ("amount") > child2.second.template get<nano::uint128_t> ("amount");
1024  					});
1025  				}
1026  				else
1027  				{
1028  					peers_l.sort ([] (auto const & child1, auto const & child2) -> bool {
1029  						return child1.second.template get<nano::uint128_t> ("") > child2.second.template get<nano::uint128_t> ("");
1030  					});
1031  				}
1032  			}
1033  			if (!peers_l.empty ())
1034  			{
1035  				pending.add_child (account.to_account (), peers_l);
1036  			}
1037  		}
1038  	}
1039  	response_l.add_child ("blocks", pending);
1040  	response_errors ();
1041  }
1042  void nano::json_handler::active_difficulty ()
1043  {
1044  	auto include_trend (request.get<bool> ("include_trend", false));
1045  	auto const multiplier_active = 1.0;
1046  	auto const default_difficulty (node.default_difficulty (nano::work_version::work_1));
1047  	auto const default_receive_difficulty (node.default_receive_difficulty (nano::work_version::work_1));
1048  	auto const receive_current_denormalized (node.network_params.work.denormalized_multiplier (multiplier_active, node.network_params.work.epoch_2_receive));
1049  	response_l.put ("deprecated", "1");
1050  	response_l.put ("network_minimum", nano::to_string_hex (default_difficulty));
1051  	response_l.put ("network_receive_minimum", nano::to_string_hex (default_receive_difficulty));
1052  	response_l.put ("network_current", nano::to_string_hex (nano::difficulty::from_multiplier (multiplier_active, default_difficulty)));
1053  	response_l.put ("network_receive_current", nano::to_string_hex (nano::difficulty::from_multiplier (receive_current_denormalized, default_receive_difficulty)));
1054  	response_l.put ("multiplier", 1.0);
1055  	if (include_trend)
1056  	{
1057  		boost::property_tree::ptree difficulty_trend_l;
1058  		boost::property_tree::ptree entry;
1059  		entry.put ("", "1.000000000000000");
1060  		difficulty_trend_l.push_back (std::make_pair ("", entry));
1061  		response_l.add_child ("difficulty_trend", difficulty_trend_l);
1062  	}
1063  	response_errors ();
1064  }
1065  void nano::json_handler::available_supply ()
1066  {
1067  	auto genesis_balance (node.balance (node.network_params.ledger.genesis->account ())); 
1068  	auto landing_balance (node.balance (nano::account ("059F68AAB29DE0D3A27443625C7EA9CDDB6517A8B76FE37727EF6A4D76832AD5"))); 
1069  	auto faucet_balance (node.balance (nano::account ("8E319CE6F3025E5B2DF66DA7AB1467FE48F1679C13DD43BFDB29FA2E9FC40D3B"))); 
1070  	auto burned_balance ((node.balance_pending (nano::account{}, false)).second); 
1071  	auto available (nano::dev::constants.genesis_amount - genesis_balance - landing_balance - faucet_balance - burned_balance);
1072  	response_l.put ("available", available.convert_to<std::string> ());
1073  	response_errors ();
1074  }
1075  void nano::json_handler::block_info ()
1076  {
1077  	auto hash (hash_impl ());
1078  	if (!ec)
1079  	{
1080  		auto transaction (node.store.tx_begin_read ());
1081  		auto block (node.store.block.get (transaction, hash));
1082  		if (block != nullptr)
1083  		{
1084  			nano::account account (block->account ().is_zero () ? block->sideband ().account : block->account ());
1085  			response_l.put ("block_account", account.to_account ());
1086  			bool error_or_pruned (false);
1087  			auto amount (node.ledger.amount_safe (transaction, hash, error_or_pruned));
1088  			if (!error_or_pruned)
1089  			{
1090  				response_l.put ("amount", amount.convert_to<std::string> ());
1091  			}
1092  			auto balance (node.ledger.balance (transaction, hash));
1093  			response_l.put ("balance", balance.convert_to<std::string> ());
1094  			response_l.put ("height", std::to_string (block->sideband ().height));
1095  			response_l.put ("local_timestamp", std::to_string (block->sideband ().timestamp));
1096  			response_l.put ("successor", block->sideband ().successor.to_string ());
1097  			auto confirmed (node.ledger.block_confirmed (transaction, hash));
1098  			response_l.put ("confirmed", confirmed);
1099  			bool json_block_l = request.get<bool> ("json_block", false);
1100  			if (json_block_l)
1101  			{
1102  				boost::property_tree::ptree block_node_l;
1103  				block->serialize_json (block_node_l);
1104  				response_l.add_child ("contents", block_node_l);
1105  			}
1106  			else
1107  			{
1108  				std::string contents;
1109  				block->serialize_json (contents);
1110  				response_l.put ("contents", contents);
1111  			}
1112  			if (block->type () == nano::block_type::state)
1113  			{
1114  				auto subtype (nano::state_subtype (block->sideband ().details));
1115  				response_l.put ("subtype", subtype);
1116  			}
1117  		}
1118  		else
1119  		{
1120  			ec = nano::error_blocks::not_found;
1121  		}
1122  	}
1123  	response_errors ();
1124  }
1125  void nano::json_handler::block_confirm ()
1126  {
1127  	auto hash (hash_impl ());
1128  	if (!ec)
1129  	{
1130  		auto transaction (node.store.tx_begin_read ());
1131  		auto block_l (node.store.block.get (transaction, hash));
1132  		if (block_l != nullptr)
1133  		{
1134  			if (!node.ledger.block_confirmed (transaction, hash))
1135  			{
1136  				if (!node.confirmation_height_processor.is_processing_block (hash))
1137  				{
1138  					node.block_confirm (std::move (block_l));
1139  				}
1140  			}
1141  			else
1142  			{
1143  				nano::election_status status{ block_l, 0, 0, std::chrono::duration_cast<std::chrono::milliseconds> (std::chrono::system_clock::now ().time_since_epoch ()), std::chrono::duration_values<std::chrono::milliseconds>::zero (), 0, 1, 0, nano::election_status_type::active_confirmation_height };
1144  				node.active.recently_cemented.put (status);
1145  				node.block_arrival.add (hash);
1146  				auto account (node.ledger.account (transaction, hash));
1147  				bool error_or_pruned (false);
1148  				auto amount (node.ledger.amount_safe (transaction, hash, error_or_pruned));
1149  				bool is_state_send (false);
1150  				bool is_state_epoch (false);
1151  				if (!error_or_pruned)
1152  				{
1153  					if (auto state = dynamic_cast<nano::state_block *> (block_l.get ()))
1154  					{
1155  						is_state_send = node.ledger.is_send (transaction, *state);
1156  						is_state_epoch = amount == 0 && node.ledger.is_epoch_link (state->link ());
1157  					}
1158  				}
1159  				node.observers.blocks.notify (status, {}, account, amount, is_state_send, is_state_epoch);
1160  			}
1161  			response_l.put ("started", "1");
1162  		}
1163  		else
1164  		{
1165  			ec = nano::error_blocks::not_found;
1166  		}
1167  	}
1168  	response_errors ();
1169  }
1170  void nano::json_handler::blocks ()
1171  {
1172  	bool const json_block_l = request.get<bool> ("json_block", false);
1173  	boost::property_tree::ptree blocks;
1174  	auto transaction (node.store.tx_begin_read ());
1175  	for (boost::property_tree::ptree::value_type & hashes : request.get_child ("hashes"))
1176  	{
1177  		if (!ec)
1178  		{
1179  			std::string hash_text = hashes.second.data ();
1180  			nano::block_hash hash;
1181  			if (!hash.decode_hex (hash_text))
1182  			{
1183  				auto block (node.store.block.get (transaction, hash));
1184  				if (block != nullptr)
1185  				{
1186  					if (json_block_l)
1187  					{
1188  						boost::property_tree::ptree block_node_l;
1189  						block->serialize_json (block_node_l);
1190  						blocks.add_child (hash_text, block_node_l);
1191  					}
1192  					else
1193  					{
1194  						std::string contents;
1195  						block->serialize_json (contents);
1196  						blocks.put (hash_text, contents);
1197  					}
1198  				}
1199  				else
1200  				{
1201  					ec = nano::error_blocks::not_found;
1202  				}
1203  			}
1204  			else
1205  			{
1206  				ec = nano::error_blocks::bad_hash_number;
1207  			}
1208  		}
1209  	}
1210  	response_l.add_child ("blocks", blocks);
1211  	response_errors ();
1212  }
1213  void nano::json_handler::blocks_info ()
1214  {
1215  	bool const pending = request.get<bool> ("pending", false);
1216  	bool const receivable = request.get<bool> ("receivable", pending);
1217  	bool const receive_hash = request.get<bool> ("receive_hash", false);
1218  	bool const source = request.get<bool> ("source", false);
1219  	bool const json_block_l = request.get<bool> ("json_block", false);
1220  	bool const include_not_found = request.get<bool> ("include_not_found", false);
1221  	boost::property_tree::ptree blocks;
1222  	boost::property_tree::ptree blocks_not_found;
1223  	auto transaction (node.store.tx_begin_read ());
1224  	for (boost::property_tree::ptree::value_type & hashes : request.get_child ("hashes"))
1225  	{
1226  		if (!ec)
1227  		{
1228  			std::string hash_text = hashes.second.data ();
1229  			nano::block_hash hash;
1230  			if (!hash.decode_hex (hash_text))
1231  			{
1232  				auto block (node.store.block.get (transaction, hash));
1233  				if (block != nullptr)
1234  				{
1235  					boost::property_tree::ptree entry;
1236  					nano::account account (block->account ().is_zero () ? block->sideband ().account : block->account ());
1237  					entry.put ("block_account", account.to_account ());
1238  					bool error_or_pruned (false);
1239  					auto amount (node.ledger.amount_safe (transaction, hash, error_or_pruned));
1240  					if (!error_or_pruned)
1241  					{
1242  						entry.put ("amount", amount.convert_to<std::string> ());
1243  					}
1244  					auto balance (node.ledger.balance (transaction, hash));
1245  					entry.put ("balance", balance.convert_to<std::string> ());
1246  					entry.put ("height", std::to_string (block->sideband ().height));
1247  					entry.put ("local_timestamp", std::to_string (block->sideband ().timestamp));
1248  					entry.put ("successor", block->sideband ().successor.to_string ());
1249  					auto confirmed (node.ledger.block_confirmed (transaction, hash));
1250  					entry.put ("confirmed", confirmed);
1251  					if (json_block_l)
1252  					{
1253  						boost::property_tree::ptree block_node_l;
1254  						block->serialize_json (block_node_l);
1255  						entry.add_child ("contents", block_node_l);
1256  					}
1257  					else
1258  					{
1259  						std::string contents;
1260  						block->serialize_json (contents);
1261  						entry.put ("contents", contents);
1262  					}
1263  					if (block->type () == nano::block_type::state)
1264  					{
1265  						auto subtype (nano::state_subtype (block->sideband ().details));
1266  						entry.put ("subtype", subtype);
1267  					}
1268  					if (receivable || receive_hash)
1269  					{
1270  						auto destination (node.ledger.block_destination (transaction, *block));
1271  						if (destination.is_zero ())
1272  						{
1273  							if (receivable)
1274  							{
1275  								entry.put ("pending", "0");
1276  								entry.put ("receivable", "0");
1277  							}
1278  							if (receive_hash)
1279  							{
1280  								entry.put ("receive_hash", nano::block_hash (0).to_string ());
1281  							}
1282  						}
1283  						else if (node.store.pending.exists (transaction, nano::pending_key (destination, hash)))
1284  						{
1285  							if (receivable)
1286  							{
1287  								entry.put ("pending", "1");
1288  								entry.put ("receivable", "1");
1289  							}
1290  							if (receive_hash)
1291  							{
1292  								entry.put ("receive_hash", nano::block_hash (0).to_string ());
1293  							}
1294  						}
1295  						else
1296  						{
1297  							if (receivable)
1298  							{
1299  								entry.put ("pending", "0");
1300  								entry.put ("receivable", "0");
1301  							}
1302  							if (receive_hash)
1303  							{
1304  								std::shared_ptr<nano::block> receive_block = node.ledger.find_receive_block_by_send_hash (transaction, destination, hash);
1305  								std::string receive_hash = receive_block ? receive_block->hash ().to_string () : nano::block_hash (0).to_string ();
1306  								entry.put ("receive_hash", receive_hash);
1307  							}
1308  						}
1309  					}
1310  					if (source)
1311  					{
1312  						nano::block_hash source_hash (node.ledger.block_source (transaction, *block));
1313  						auto block_a (node.store.block.get (transaction, source_hash));
1314  						if (block_a != nullptr)
1315  						{
1316  							auto source_account (node.ledger.account (transaction, source_hash));
1317  							entry.put ("source_account", source_account.to_account ());
1318  						}
1319  						else
1320  						{
1321  							entry.put ("source_account", "0");
1322  						}
1323  					}
1324  					blocks.push_back (std::make_pair (hash_text, entry));
1325  				}
1326  				else if (include_not_found)
1327  				{
1328  					boost::property_tree::ptree entry;
1329  					entry.put ("", hash_text);
1330  					blocks_not_found.push_back (std::make_pair ("", entry));
1331  				}
1332  				else
1333  				{
1334  					ec = nano::error_blocks::not_found;
1335  				}
1336  			}
1337  			else
1338  			{
1339  				ec = nano::error_blocks::bad_hash_number;
1340  			}
1341  		}
1342  	}
1343  	if (!ec)
1344  	{
1345  		response_l.add_child ("blocks", blocks);
1346  		if (include_not_found)
1347  		{
1348  			response_l.add_child ("blocks_not_found", blocks_not_found);
1349  		}
1350  	}
1351  	response_errors ();
1352  }
1353  void nano::json_handler::block_account ()
1354  {
1355  	auto hash (hash_impl ());
1356  	if (!ec)
1357  	{
1358  		auto transaction (node.store.tx_begin_read ());
1359  		if (node.store.block.exists (transaction, hash))
1360  		{
1361  			auto account (node.ledger.account (transaction, hash));
1362  			response_l.put ("account", account.to_account ());
1363  		}
1364  		else
1365  		{
1366  			ec = nano::error_blocks::not_found;
1367  		}
1368  	}
1369  	response_errors ();
1370  }
1371  void nano::json_handler::block_count ()
1372  {
1373  	response_l.put ("count", std::to_string (node.ledger.cache.block_count));
1374  	response_l.put ("unchecked", std::to_string (node.unchecked.count ()));
1375  	response_l.put ("cemented", std::to_string (node.ledger.cache.cemented_count));
1376  	if (node.flags.enable_pruning)
1377  	{
1378  		response_l.put ("full", std::to_string (node.ledger.cache.block_count - node.ledger.cache.pruned_count));
1379  		response_l.put ("pruned", std::to_string (node.ledger.cache.pruned_count));
1380  	}
1381  	response_errors ();
1382  }
1383  void nano::json_handler::block_create ()
1384  {
1385  	std::string type (request.get<std::string> ("type"));
1386  	nano::wallet_id wallet (0);
1387  	auto work_version (work_version_optional_impl (nano::work_version::work_1));
1388  	auto difficulty_l (difficulty_optional_impl (work_version));
1389  	boost::optional<std::string> wallet_text (request.get_optional<std::string> ("wallet"));
1390  	if (!ec && wallet_text.is_initialized ())
1391  	{
1392  		if (wallet.decode_hex (wallet_text.get ()))
1393  		{
1394  			ec = nano::error_common::bad_wallet_number;
1395  		}
1396  	}
1397  	nano::account account{};
1398  	boost::optional<std::string> account_text (request.get_optional<std::string> ("account"));
1399  	if (!ec && account_text.is_initialized ())
1400  	{
1401  		account = account_impl (account_text.get ());
1402  	}
1403  	nano::account representative{};
1404  	boost::optional<std::string> representative_text (request.get_optional<std::string> ("representative"));
1405  	if (!ec && representative_text.is_initialized ())
1406  	{
1407  		representative = account_impl (representative_text.get (), nano::error_rpc::bad_representative_number);
1408  	}
1409  	nano::account destination{};
1410  	boost::optional<std::string> destination_text (request.get_optional<std::string> ("destination"));
1411  	if (!ec && destination_text.is_initialized ())
1412  	{
1413  		destination = account_impl (destination_text.get (), nano::error_rpc::bad_destination);
1414  	}
1415  	nano::block_hash source (0);
1416  	boost::optional<std::string> source_text (request.get_optional<std::string> ("source"));
1417  	if (!ec && source_text.is_initialized ())
1418  	{
1419  		if (source.decode_hex (source_text.get ()))
1420  		{
1421  			ec = nano::error_rpc::bad_source;
1422  		}
1423  	}
1424  	nano::amount amount (0);
1425  	boost::optional<std::string> amount_text (request.get_optional<std::string> ("amount"));
1426  	if (!ec && amount_text.is_initialized ())
1427  	{
1428  		if (amount.decode_dec (amount_text.get ()))
1429  		{
1430  			ec = nano::error_common::invalid_amount;
1431  		}
1432  	}
1433  	auto work (work_optional_impl ());
1434  	nano::raw_key prv;
1435  	prv.clear ();
1436  	nano::block_hash previous (0);
1437  	nano::amount balance (0);
1438  	if (work == 0 && !node.work_generation_enabled ())
1439  	{
1440  		ec = nano::error_common::disabled_work_generation;
1441  	}
1442  	if (!ec && wallet != 0 && account != 0)
1443  	{
1444  		auto existing (node.wallets.items.find (wallet));
1445  		if (existing != node.wallets.items.end ())
1446  		{
1447  			auto transaction (node.wallets.tx_begin_read ());
1448  			auto block_transaction (node.store.tx_begin_read ());
1449  			wallet_locked_impl (transaction, existing->second);
1450  			wallet_account_impl (transaction, existing->second, account);
1451  			if (!ec)
1452  			{
1453  				existing->second->store.fetch (transaction, account, prv);
1454  				previous = node.ledger.latest (block_transaction, account);
1455  				balance = node.ledger.account_balance (block_transaction, account);
1456  			}
1457  		}
1458  		else
1459  		{
1460  			ec = nano::error_common::wallet_not_found;
1461  		}
1462  	}
1463  	boost::optional<std::string> key_text (request.get_optional<std::string> ("key"));
1464  	if (!ec && key_text.is_initialized ())
1465  	{
1466  		if (prv.decode_hex (key_text.get ()))
1467  		{
1468  			ec = nano::error_common::bad_private_key;
1469  		}
1470  	}
1471  	boost::optional<std::string> previous_text (request.get_optional<std::string> ("previous"));
1472  	if (!ec && previous_text.is_initialized ())
1473  	{
1474  		if (previous.decode_hex (previous_text.get ()))
1475  		{
1476  			ec = nano::error_rpc::bad_previous;
1477  		}
1478  	}
1479  	boost::optional<std::string> balance_text (request.get_optional<std::string> ("balance"));
1480  	if (!ec && balance_text.is_initialized ())
1481  	{
1482  		if (balance.decode_dec (balance_text.get ()))
1483  		{
1484  			ec = nano::error_rpc::invalid_balance;
1485  		}
1486  	}
1487  	nano::link link (0);
1488  	boost::optional<std::string> link_text (request.get_optional<std::string> ("link"));
1489  	if (!ec && link_text.is_initialized ())
1490  	{
1491  		if (link.decode_account (link_text.get ()))
1492  		{
1493  			if (link.decode_hex (link_text.get ()))
1494  			{
1495  				ec = nano::error_rpc::bad_link;
1496  			}
1497  		}
1498  	}
1499  	else
1500  	{
1501  		if (source.is_zero ())
1502  		{
1503  			link = destination;
1504  		}
1505  		else
1506  		{
1507  			link = source;
1508  		}
1509  	}
1510  	if (!ec)
1511  	{
1512  		auto rpc_l (shared_from_this ());
1513  		auto block_response_put_l = [rpc_l, this] (nano::block const & block_a) {
1514  			boost::property_tree::ptree response_l;
1515  			response_l.put ("hash", block_a.hash ().to_string ());
1516  			response_l.put ("difficulty", nano::to_string_hex (rpc_l->node.network_params.work.difficulty (block_a)));
1517  			bool json_block_l = request.get<bool> ("json_block", false);
1518  			if (json_block_l)
1519  			{
1520  				boost::property_tree::ptree block_node_l;
1521  				block_a.serialize_json (block_node_l);
1522  				response_l.add_child ("block", block_node_l);
1523  			}
1524  			else
1525  			{
1526  				std::string contents;
1527  				block_a.serialize_json (contents);
1528  				response_l.put ("block", contents);
1529  			}
1530  			std::stringstream ostream;
1531  			boost::property_tree::write_json (ostream, response_l);
1532  			rpc_l->response (ostream.str ());
1533  		};
1534  		auto get_callback_l = [rpc_l, block_response_put_l] (std::shared_ptr<nano::block> const & block_a) {
1535  			return [block_a, rpc_l, block_response_put_l] (boost::optional<uint64_t> const & work_a) {
1536  				if (block_a != nullptr)
1537  				{
1538  					if (work_a.is_initialized ())
1539  					{
1540  						block_a->block_work_set (*work_a);
1541  						block_response_put_l (*block_a);
1542  					}
1543  					else
1544  					{
1545  						rpc_l->ec = nano::error_common::failure_work_generation;
1546  					}
1547  				}
1548  				else
1549  				{
1550  					rpc_l->ec = nano::error_common::generic;
1551  				}
1552  				if (rpc_l->ec)
1553  				{
1554  					rpc_l->response_errors ();
1555  				}
1556  			};
1557  		};
1558  		if (prv != 0)
1559  		{
1560  			nano::account pub (nano::pub_key (prv));
1561  			if (!previous_text.is_initialized () && !balance_text.is_initialized ())
1562  			{
1563  				auto transaction (node.store.tx_begin_read ());
1564  				previous = node.ledger.latest (transaction, pub);
1565  				balance = node.ledger.account_balance (transaction, pub);
1566  			}
1567  			else if (previous_text.is_initialized () && balance_text.is_initialized () && type == "send")
1568  			{
1569  				auto transaction (node.store.tx_begin_read ());
1570  				if (node.store.block.exists (transaction, previous) && node.store.block.balance (transaction, previous) != balance.number ())
1571  				{
1572  					ec = nano::error_rpc::block_create_balance_mismatch;
1573  				}
1574  			}
1575  			if (!ec && account_text.is_initialized ())
1576  			{
1577  				if (account != pub)
1578  				{
1579  					ec = nano::error_rpc::block_create_public_key_mismatch;
1580  				}
1581  			}
1582  			nano::block_builder builder_l;
1583  			std::shared_ptr<nano::block> block_l{ nullptr };
1584  			nano::root root_l;
1585  			std::error_code ec_build;
1586  			if (type == "state")
1587  			{
1588  				if (previous_text.is_initialized () && !representative.is_zero () && (!link.is_zero () || link_text.is_initialized ()))
1589  				{
1590  					block_l = builder_l.state ()
1591  							  .account (pub)
1592  							  .previous (previous)
1593  							  .representative (representative)
1594  							  .balance (balance)
1595  							  .link (link)
1596  							  .sign (prv, pub)
1597  							  .build (ec_build);
1598  					if (previous.is_zero ())
1599  					{
1600  						root_l = pub;
1601  					}
1602  					else
1603  					{
1604  						root_l = previous;
1605  					}
1606  				}
1607  				else
1608  				{
1609  					ec = nano::error_rpc::block_create_requirements_state;
1610  				}
1611  			}
1612  			else if (type == "open")
1613  			{
1614  				if (representative != 0 && source != 0)
1615  				{
1616  					block_l = builder_l.open ()
1617  							  .account (pub)
1618  							  .source (source)
1619  							  .representative (representative)
1620  							  .sign (prv, pub)
1621  							  .build (ec_build);
1622  					root_l = pub;
1623  				}
1624  				else
1625  				{
1626  					ec = nano::error_rpc::block_create_requirements_open;
1627  				}
1628  			}
1629  			else if (type == "receive")
1630  			{
1631  				if (source != 0 && previous != 0)
1632  				{
1633  					block_l = builder_l.receive ()
1634  							  .previous (previous)
1635  							  .source (source)
1636  							  .sign (prv, pub)
1637  							  .build (ec_build);
1638  					root_l = previous;
1639  				}
1640  				else
1641  				{
1642  					ec = nano::error_rpc::block_create_requirements_receive;
1643  				}
1644  			}
1645  			else if (type == "change")
1646  			{
1647  				if (representative != 0 && previous != 0)
1648  				{
1649  					block_l = builder_l.change ()
1650  							  .previous (previous)
1651  							  .representative (representative)
1652  							  .sign (prv, pub)
1653  							  .build (ec_build);
1654  					root_l = previous;
1655  				}
1656  				else
1657  				{
1658  					ec = nano::error_rpc::block_create_requirements_change;
1659  				}
1660  			}
1661  			else if (type == "send")
1662  			{
1663  				if (destination != 0 && previous != 0 && balance != 0 && amount != 0)
1664  				{
1665  					if (balance.number () >= amount.number ())
1666  					{
1667  						block_l = builder_l.send ()
1668  								  .previous (previous)
1669  								  .destination (destination)
1670  								  .balance (balance.number () - amount.number ())
1671  								  .sign (prv, pub)
1672  								  .build (ec_build);
1673  						root_l = previous;
1674  					}
1675  					else
1676  					{
1677  						ec = nano::error_common::insufficient_balance;
1678  					}
1679  				}
1680  				else
1681  				{
1682  					ec = nano::error_rpc::block_create_requirements_send;
1683  				}
1684  			}
1685  			else
1686  			{
1687  				ec = nano::error_blocks::invalid_type;
1688  			}
1689  			if (!ec && (!ec_build || ec_build == nano::error_common::missing_work))
1690  			{
1691  				if (work == 0)
1692  				{
1693  					if (request.count ("difficulty") == 0)
1694  					{
1695  						difficulty_l = difficulty_ledger (*block_l);
1696  					}
1697  					node.work_generate (work_version, root_l, difficulty_l, get_callback_l (block_l), nano::account (pub));
1698  				}
1699  				else
1700  				{
1701  					block_l->block_work_set (work);
1702  					block_response_put_l (*block_l);
1703  				}
1704  			}
1705  		}
1706  		else
1707  		{
1708  			ec = nano::error_rpc::block_create_key_required;
1709  		}
1710  	}
1711  	if (ec)
1712  	{
1713  		response_errors ();
1714  	}
1715  }
1716  void nano::json_handler::block_hash ()
1717  {
1718  	auto block (block_impl (true));
1719  	if (!ec)
1720  	{
1721  		response_l.put ("hash", block->hash ().to_string ());
1722  	}
1723  	response_errors ();
1724  }
1725  void nano::json_handler::bootstrap ()
1726  {
1727  	std::string address_text = request.get<std::string> ("address");
1728  	std::string port_text = request.get<std::string> ("port");
1729  	boost::system::error_code address_ec;
1730  	auto address (boost::asio::ip::make_address_v6 (address_text, address_ec));
1731  	if (!address_ec)
1732  	{
1733  		uint16_t port;
1734  		if (!nano::parse_port (port_text, port))
1735  		{
1736  			if (!node.flags.disable_legacy_bootstrap)
1737  			{
1738  				std::string bootstrap_id (request.get<std::string> ("id", ""));
1739  				node.bootstrap_initiator.bootstrap (nano::endpoint (address, port), true, bootstrap_id);
1740  				response_l.put ("success", "");
1741  			}
1742  			else
1743  			{
1744  				ec = nano::error_rpc::disabled_bootstrap_legacy;
1745  			}
1746  		}
1747  		else
1748  		{
1749  			ec = nano::error_common::invalid_port;
1750  		}
1751  	}
1752  	else
1753  	{
1754  		ec = nano::error_common::invalid_ip_address;
1755  	}
1756  	response_errors ();
1757  }
1758  void nano::json_handler::bootstrap_any ()
1759  {
1760  	bool const force = request.get<bool> ("force", false);
1761  	if (!node.flags.disable_legacy_bootstrap)
1762  	{
1763  		nano::account start_account{};
1764  		boost::optional<std::string> account_text (request.get_optional<std::string> ("account"));
1765  		if (account_text.is_initialized ())
1766  		{
1767  			start_account = account_impl (account_text.get ());
1768  		}
1769  		std::string bootstrap_id (request.get<std::string> ("id", ""));
1770  		node.bootstrap_initiator.bootstrap (force, bootstrap_id, std::numeric_limits<uint32_t>::max (), start_account);
1771  		response_l.put ("success", "");
1772  	}
1773  	else
1774  	{
1775  		ec = nano::error_rpc::disabled_bootstrap_legacy;
1776  	}
1777  	response_errors ();
1778  }
1779  void nano::json_handler::bootstrap_lazy ()
1780  {
1781  	auto hash (hash_impl ());
1782  	bool const force = request.get<bool> ("force", false);
1783  	if (!ec)
1784  	{
1785  		if (!node.flags.disable_lazy_bootstrap)
1786  		{
1787  			auto existed (node.bootstrap_initiator.current_lazy_attempt () != nullptr);
1788  			std::string bootstrap_id (request.get<std::string> ("id", ""));
1789  			auto key_inserted (node.bootstrap_initiator.bootstrap_lazy (hash, force, bootstrap_id));
1790  			bool started = !existed && key_inserted;
1791  			response_l.put ("started", started ? "1" : "0");
1792  			response_l.put ("key_inserted", key_inserted ? "1" : "0");
1793  		}
1794  		else
1795  		{
1796  			ec = nano::error_rpc::disabled_bootstrap_lazy;
1797  		}
1798  	}
1799  	response_errors ();
1800  }
1801  void nano::json_handler::bootstrap_status ()
1802  {
1803  	auto attempts_count (node.bootstrap_initiator.attempts.size ());
1804  	response_l.put ("bootstrap_threads", std::to_string (node.config.bootstrap_initiator_threads));
1805  	response_l.put ("running_attempts_count", std::to_string (attempts_count));
1806  	response_l.put ("total_attempts_count", std::to_string (node.bootstrap_initiator.attempts.incremental));
1807  	boost::property_tree::ptree connections;
1808  	{
1809  		nano::lock_guard<nano::mutex> connections_lock (node.bootstrap_initiator.connections->mutex);
1810  		connections.put ("clients", std::to_string (node.bootstrap_initiator.connections->clients.size ()));
1811  		connections.put ("connections", std::to_string (node.bootstrap_initiator.connections->connections_count));
1812  		connections.put ("idle", std::to_string (node.bootstrap_initiator.connections->idle.size ()));
1813  		connections.put ("target_connections", std::to_string (node.bootstrap_initiator.connections->target_connections (node.bootstrap_initiator.connections->pulls.size (), attempts_count)));
1814  		connections.put ("pulls", std::to_string (node.bootstrap_initiator.connections->pulls.size ()));
1815  	}
1816  	response_l.add_child ("connections", connections);
1817  	boost::property_tree::ptree attempts;
1818  	{
1819  		nano::lock_guard<nano::mutex> attempts_lock (node.bootstrap_initiator.attempts.bootstrap_attempts_mutex);
1820  		for (auto i : node.bootstrap_initiator.attempts.attempts)
1821  		{
1822  			boost::property_tree::ptree entry;
1823  			auto & attempt (i.second);
1824  			entry.put ("id", attempt->id);
1825  			entry.put ("mode", attempt->mode_text ());
1826  			entry.put ("started", static_cast<bool> (attempt->started));
1827  			entry.put ("pulling", std::to_string (attempt->pulling));
1828  			entry.put ("total_blocks", std::to_string (attempt->total_blocks));
1829  			entry.put ("requeued_pulls", std::to_string (attempt->requeued_pulls));
1830  			attempt->get_information (entry);
1831  			entry.put ("duration", std::chrono::duration_cast<std::chrono::seconds> (std::chrono::steady_clock::now () - attempt->attempt_start).count ());
1832  			attempts.push_back (std::make_pair ("", entry));
1833  		}
1834  	}
1835  	response_l.add_child ("attempts", attempts);
1836  	response_errors ();
1837  }
1838  void nano::json_handler::chain (bool successors)
1839  {
1840  	successors = successors != request.get<bool> ("reverse", false);
1841  	auto hash (hash_impl ("block"));
1842  	auto count (count_impl ());
1843  	auto offset (offset_optional_impl (0));
1844  	if (!ec)
1845  	{
1846  		boost::property_tree::ptree blocks;
1847  		auto transaction (node.store.tx_begin_read ());
1848  		while (!hash.is_zero () && blocks.size () < count)
1849  		{
1850  			auto block_l (node.store.block.get (transaction, hash));
1851  			if (block_l != nullptr)
1852  			{
1853  				if (offset > 0)
1854  				{
1855  					--offset;
1856  				}
1857  				else
1858  				{
1859  					boost::property_tree::ptree entry;
1860  					entry.put ("", hash.to_string ());
1861  					blocks.push_back (std::make_pair ("", entry));
1862  				}
1863  				hash = successors ? node.store.block.successor (transaction, hash) : block_l->previous ();
1864  			}
1865  			else
1866  			{
1867  				hash.clear ();
1868  			}
1869  		}
1870  		response_l.add_child ("blocks", blocks);
1871  	}
1872  	response_errors ();
1873  }
1874  void nano::json_handler::confirmation_active ()
1875  {
1876  	uint64_t announcements (0);
1877  	uint64_t confirmed (0);
1878  	boost::optional<std::string> announcements_text (request.get_optional<std::string> ("announcements"));
1879  	if (announcements_text.is_initialized ())
1880  	{
1881  		announcements = strtoul (announcements_text.get ().c_str (), NULL, 10);
1882  	}
1883  	boost::property_tree::ptree elections;
1884  	auto active_elections = node.active.list_active ();
1885  	for (auto const & election : active_elections)
1886  	{
1887  		if (election->confirmation_request_count >= announcements)
1888  		{
1889  			if (!election->confirmed ())
1890  			{
1891  				boost::property_tree::ptree entry;
1892  				entry.put ("", election->qualified_root.to_string ());
1893  				elections.push_back (std::make_pair ("", entry));
1894  			}
1895  			else
1896  			{
1897  				++confirmed;
1898  			}
1899  		}
1900  	}
1901  	response_l.add_child ("confirmations", elections);
1902  	response_l.put ("unconfirmed", elections.size ());
1903  	response_l.put ("confirmed", confirmed);
1904  	response_errors ();
1905  }
1906  void nano::json_handler::confirmation_height_currently_processing ()
1907  {
1908  	auto hash = node.confirmation_height_processor.current ();
1909  	if (!hash.is_zero ())
1910  	{
1911  		response_l.put ("hash", hash.to_string ());
1912  	}
1913  	else
1914  	{
1915  		ec = nano::error_rpc::confirmation_height_not_processing;
1916  	}
1917  	response_errors ();
1918  }
1919  void nano::json_handler::confirmation_history ()
1920  {
1921  	boost::property_tree::ptree elections;
1922  	boost::property_tree::ptree confirmation_stats;
1923  	std::chrono::milliseconds running_total (0);
1924  	nano::block_hash hash (0);
1925  	boost::optional<std::string> hash_text (request.get_optional<std::string> ("hash"));
1926  	if (hash_text.is_initialized ())
1927  	{
1928  		hash = hash_impl ();
1929  	}
1930  	if (!ec)
1931  	{
1932  		for (auto const & status : node.active.recently_cemented.list ())
1933  		{
1934  			if (hash.is_zero () || status.winner->hash () == hash)
1935  			{
1936  				boost::property_tree::ptree election;
1937  				election.put ("hash", status.winner->hash ().to_string ());
1938  				election.put ("duration", status.election_duration.count ());
1939  				election.put ("time", status.election_end.count ());
1940  				election.put ("tally", status.tally.to_string_dec ());
1941  				election.add ("final", status.final_tally.to_string_dec ());
1942  				election.put ("blocks", std::to_string (status.block_count));
1943  				election.put ("voters", std::to_string (status.voter_count));
1944  				election.put ("request_count", std::to_string (status.confirmation_request_count));
1945  				elections.push_back (std::make_pair ("", election));
1946  			}
1947  			running_total += status.election_duration;
1948  		}
1949  	}
1950  	confirmation_stats.put ("count", elections.size ());
1951  	if (elections.size () >= 1)
1952  	{
1953  		confirmation_stats.put ("average", (running_total.count ()) / elections.size ());
1954  	}
1955  	response_l.add_child ("confirmation_stats", confirmation_stats);
1956  	response_l.add_child ("confirmations", elections);
1957  	response_errors ();
1958  }
1959  void nano::json_handler::confirmation_info ()
1960  {
1961  	bool const representatives = request.get<bool> ("representatives", false);
1962  	bool const contents = request.get<bool> ("contents", true);
1963  	bool const json_block_l = request.get<bool> ("json_block", false);
1964  	std::string root_text (request.get<std::string> ("root"));
1965  	nano::qualified_root root;
1966  	if (!root.decode_hex (root_text))
1967  	{
1968  		auto election (node.active.election (root));
1969  		if (election != nullptr && !election->confirmed ())
1970  		{
1971  			auto info = election->current_status ();
1972  			response_l.put ("announcements", std::to_string (info.status.confirmation_request_count));
1973  			response_l.put ("voters", std::to_string (info.votes.size ()));
1974  			response_l.put ("last_winner", info.status.winner->hash ().to_string ());
1975  			nano::uint128_t total (0);
1976  			boost::property_tree::ptree blocks;
1977  			for (auto const & [tally, block] : info.tally)
1978  			{
1979  				boost::property_tree::ptree entry;
1980  				entry.put ("tally", tally.convert_to<std::string> ());
1981  				total += tally;
1982  				if (contents)
1983  				{
1984  					if (json_block_l)
1985  					{
1986  						boost::property_tree::ptree block_node_l;
1987  						block->serialize_json (block_node_l);
1988  						entry.add_child ("contents", block_node_l);
1989  					}
1990  					else
1991  					{
1992  						std::string contents;
1993  						block->serialize_json (contents);
1994  						entry.put ("contents", contents);
1995  					}
1996  				}
1997  				if (representatives)
1998  				{
1999  					std::multimap<nano::uint128_t, nano::account, std::greater<nano::uint128_t>> representatives;
2000  					for (auto const & [representative, vote] : info.votes)
2001  					{
2002  						if (block->hash () == vote.hash)
2003  						{
2004  							auto amount (node.ledger.cache.rep_weights.representation_get (representative));
2005  							representatives.emplace (std::move (amount), representative);
2006  						}
2007  					}
2008  					boost::property_tree::ptree representatives_list;
2009  					for (auto const & [amount, representative] : representatives)
2010  					{
2011  						representatives_list.put (representative.to_account (), amount.convert_to<std::string> ());
2012  					}
2013  					entry.add_child ("representatives", representatives_list);
2014  				}
2015  				blocks.add_child ((block->hash ()).to_string (), entry);
2016  			}
2017  			response_l.put ("total_tally", total.convert_to<std::string> ());
2018  			response_l.put ("final_tally", info.status.final_tally.to_string_dec ());
2019  			response_l.add_child ("blocks", blocks);
2020  		}
2021  		else
2022  		{
2023  			ec = nano::error_rpc::confirmation_not_found;
2024  		}
2025  	}
2026  	else
2027  	{
2028  		ec = nano::error_rpc::invalid_root;
2029  	}
2030  	response_errors ();
2031  }
2032  void nano::json_handler::confirmation_quorum ()
2033  {
2034  	response_l.put ("quorum_delta", node.online_reps.delta ().convert_to<std::string> ());
2035  	response_l.put ("online_weight_quorum_percent", std::to_string (node.online_reps.online_weight_quorum));
2036  	response_l.put ("online_weight_minimum", node.config.online_weight_minimum.to_string_dec ());
2037  	response_l.put ("online_stake_total", node.online_reps.online ().convert_to<std::string> ());
2038  	response_l.put ("trended_stake_total", node.online_reps.trended ().convert_to<std::string> ());
2039  	response_l.put ("peers_stake_total", node.rep_crawler.total_weight ().convert_to<std::string> ());
2040  	if (request.get<bool> ("peer_details", false))
2041  	{
2042  		boost::property_tree::ptree peers;
2043  		for (auto & peer : node.rep_crawler.representatives ())
2044  		{
2045  			boost::property_tree::ptree peer_node;
2046  			peer_node.put ("account", peer.account.to_account ());
2047  			peer_node.put ("ip", peer.channel->to_string ());
2048  			peer_node.put ("weight", nano::amount{ node.ledger.weight (peer.account) }.to_string_dec ());
2049  			peers.push_back (std::make_pair ("", peer_node));
2050  		}
2051  		response_l.add_child ("peers", peers);
2052  	}
2053  	response_errors ();
2054  }
2055  void nano::json_handler::database_txn_tracker ()
2056  {
2057  	boost::property_tree::ptree json;
2058  	if (node.config.diagnostics_config.txn_tracking.enable)
2059  	{
2060  		unsigned min_read_time_milliseconds = 0;
2061  		boost::optional<std::string> min_read_time_text (request.get_optional<std::string> ("min_read_time"));
2062  		if (min_read_time_text.is_initialized ())
2063  		{
2064  			auto success = boost::conversion::try_lexical_convert<unsigned> (*min_read_time_text, min_read_time_milliseconds);
2065  			if (!success)
2066  			{
2067  				ec = nano::error_common::invalid_amount;
2068  			}
2069  		}
2070  		unsigned min_write_time_milliseconds = 0;
2071  		if (!ec)
2072  		{
2073  			boost::optional<std::string> min_write_time_text (request.get_optional<std::string> ("min_write_time"));
2074  			if (min_write_time_text.is_initialized ())
2075  			{
2076  				auto success = boost::conversion::try_lexical_convert<unsigned> (*min_write_time_text, min_write_time_milliseconds);
2077  				if (!success)
2078  				{
2079  					ec = nano::error_common::invalid_amount;
2080  				}
2081  			}
2082  		}
2083  		if (!ec)
2084  		{
2085  			node.store.serialize_mdb_tracker (json, std::chrono::milliseconds (min_read_time_milliseconds), std::chrono::milliseconds (min_write_time_milliseconds));
2086  			response_l.put_child ("txn_tracking", json);
2087  		}
2088  	}
2089  	else
2090  	{
2091  		ec = nano::error_common::tracking_not_enabled;
2092  	}
2093  	response_errors ();
2094  }
2095  void nano::json_handler::delegators ()
2096  {
2097  	auto representative (account_impl ());
2098  	auto count (count_optional_impl (1024));
2099  	auto threshold (threshold_optional_impl ());
2100  	auto start_account_text (request.get_optional<std::string> ("start"));
2101  	nano::account start_account{};
2102  	if (!ec && start_account_text.is_initialized ())
2103  	{
2104  		start_account = account_impl (start_account_text.get ());
2105  	}
2106  	if (!ec)
2107  	{
2108  		auto transaction (node.store.tx_begin_read ());
2109  		boost::property_tree::ptree delegators;
2110  		for (auto i (node.store.account.begin (transaction, start_account.number () + 1)), n (node.store.account.end ()); i != n && delegators.size () < count; ++i)
2111  		{
2112  			nano::account_info const & info (i->second);
2113  			if (info.representative == representative)
2114  			{
2115  				if (info.balance.number () >= threshold.number ())
2116  				{
2117  					std::string balance;
2118  					nano::uint128_union (info.balance).encode_dec (balance);
2119  					nano::account const & delegator (i->first);
2120  					delegators.put (delegator.to_account (), balance);
2121  				}
2122  			}
2123  		}
2124  		response_l.add_child ("delegators", delegators);
2125  	}
2126  	response_errors ();
2127  }
2128  void nano::json_handler::delegators_count ()
2129  {
2130  	auto account (account_impl ());
2131  	if (!ec)
2132  	{
2133  		uint64_t count (0);
2134  		auto transaction (node.store.tx_begin_read ());
2135  		for (auto i (node.store.account.begin (transaction)), n (node.store.account.end ()); i != n; ++i)
2136  		{
2137  			nano::account_info const & info (i->second);
2138  			if (info.representative == account)
2139  			{
2140  				++count;
2141  			}
2142  		}
2143  		response_l.put ("count", std::to_string (count));
2144  	}
2145  	response_errors ();
2146  }
2147  void nano::json_handler::deterministic_key ()
2148  {
2149  	std::string seed_text (request.get<std::string> ("seed"));
2150  	std::string index_text (request.get<std::string> ("index"));
2151  	nano::raw_key seed;
2152  	if (!seed.decode_hex (seed_text))
2153  	{
2154  		try
2155  		{
2156  			uint32_t index (std::stoul (index_text));
2157  			nano::raw_key prv = nano::deterministic_key (seed, index);
2158  			nano::public_key pub (nano::pub_key (prv));
2159  			response_l.put ("private", prv.to_string ());
2160  			response_l.put ("public", pub.to_string ());
2161  			response_l.put ("account", pub.to_account ());
2162  		}
2163  		catch (std::logic_error const &)
2164  		{
2165  			ec = nano::error_common::invalid_index;
2166  		}
2167  	}
2168  	else
2169  	{
2170  		ec = nano::error_common::bad_seed;
2171  	}
2172  	response_errors ();
2173  }
2174  void nano::json_handler::epoch_upgrade ()
2175  {
2176  	nano::epoch epoch (nano::epoch::invalid);
2177  	uint8_t epoch_int (request.get<uint8_t> ("epoch"));
2178  	switch (epoch_int)
2179  	{
2180  		case 1:
2181  			epoch = nano::epoch::epoch_1;
2182  			break;
2183  		case 2:
2184  			epoch = nano::epoch::epoch_2;
2185  			break;
2186  		default:
2187  			break;
2188  	}
2189  	if (epoch != nano::epoch::invalid)
2190  	{
2191  		uint64_t count_limit (count_optional_impl ());
2192  		uint64_t threads (0);
2193  		boost::optional<std::string> threads_text (request.get_optional<std::string> ("threads"));
2194  		if (!ec && threads_text.is_initialized ())
2195  		{
2196  			if (decode_unsigned (threads_text.get (), threads))
2197  			{
2198  				ec = nano::error_rpc::invalid_threads_count;
2199  			}
2200  		}
2201  		std::string key_text (request.get<std::string> ("key"));
2202  		nano::raw_key prv;
2203  		if (!prv.decode_hex (key_text))
2204  		{
2205  			if (nano::pub_key (prv) == node.ledger.epoch_signer (node.ledger.epoch_link (epoch)))
2206  			{
2207  				if (!node.epoch_upgrader.start (prv, epoch, count_limit, threads))
2208  				{
2209  					response_l.put ("started", "1");
2210  				}
2211  				else
2212  				{
2213  					response_l.put ("started", "0");
2214  				}
2215  			}
2216  			else
2217  			{
2218  				ec = nano::error_rpc::invalid_epoch_signer;
2219  			}
2220  		}
2221  		else
2222  		{
2223  			ec = nano::error_common::bad_private_key;
2224  		}
2225  	}
2226  	else
2227  	{
2228  		ec = nano::error_rpc::invalid_epoch;
2229  	}
2230  	response_errors ();
2231  }
2232  void nano::json_handler::frontiers ()
2233  {
2234  	auto start (account_impl ());
2235  	auto count (count_impl ());
2236  	if (!ec)
2237  	{
2238  		boost::property_tree::ptree frontiers;
2239  		auto transaction (node.store.tx_begin_read ());
2240  		for (auto i (node.store.account.begin (transaction, start)), n (node.store.account.end ()); i != n && frontiers.size () < count; ++i)
2241  		{
2242  			frontiers.put (i->first.to_account (), i->second.head.to_string ());
2243  		}
2244  		response_l.add_child ("frontiers", frontiers);
2245  	}
2246  	response_errors ();
2247  }
2248  void nano::json_handler::account_count ()
2249  {
2250  	auto size (node.ledger.cache.account_count.load ());
2251  	response_l.put ("count", std::to_string (size));
2252  	response_errors ();
2253  }
2254  namespace
2255  {
2256  class history_visitor : public nano::block_visitor
2257  {
2258  public:
2259  	history_visitor (nano::json_handler & handler_a, bool raw_a, nano::transaction & transaction_a, boost::property_tree::ptree & tree_a, nano::block_hash const & hash_a, std::vector<nano::public_key> const & accounts_filter_a) :
2260  		handler (handler_a),
2261  		raw (raw_a),
2262  		transaction (transaction_a),
2263  		tree (tree_a),
2264  		hash (hash_a),
2265  		accounts_filter (accounts_filter_a)
2266  	{
2267  	}
2268  	virtual ~history_visitor () = default;
2269  	void send_block (nano::send_block const & block_a)
2270  	{
2271  		if (should_ignore_account (block_a.hashables.destination))
2272  		{
2273  			return;
2274  		}
2275  		tree.put ("type", "send");
2276  		auto account (block_a.hashables.destination.to_account ());
2277  		tree.put ("account", account);
2278  		bool error_or_pruned (false);
2279  		auto amount (handler.node.ledger.amount_safe (transaction, hash, error_or_pruned).convert_to<std::string> ());
2280  		if (!error_or_pruned)
2281  		{
2282  			tree.put ("amount", amount);
2283  		}
2284  		if (raw)
2285  		{
2286  			tree.put ("destination", account);
2287  			tree.put ("balance", block_a.hashables.balance.to_string_dec ());
2288  			tree.put ("previous", block_a.hashables.previous.to_string ());
2289  		}
2290  	}
2291  	void receive_block (nano::receive_block const & block_a)
2292  	{
2293  		tree.put ("type", "receive");
2294  		bool error_or_pruned (false);
2295  		auto amount (handler.node.ledger.amount_safe (transaction, hash, error_or_pruned).convert_to<std::string> ());
2296  		if (!error_or_pruned)
2297  		{
2298  			auto source_account (handler.node.ledger.account_safe (transaction, block_a.hashables.source, error_or_pruned));
2299  			if (!error_or_pruned)
2300  			{
2301  				tree.put ("account", source_account.to_account ());
2302  			}
2303  			tree.put ("amount", amount);
2304  		}
2305  		if (raw)
2306  		{
2307  			tree.put ("source", block_a.hashables.source.to_string ());
2308  			tree.put ("previous", block_a.hashables.previous.to_string ());
2309  		}
2310  	}
2311  	void open_block (nano::open_block const & block_a)
2312  	{
2313  		if (raw)
2314  		{
2315  			tree.put ("type", "open");
2316  			tree.put ("representative", block_a.hashables.representative.to_account ());
2317  			tree.put ("source", block_a.hashables.source.to_string ());
2318  			tree.put ("opened", block_a.hashables.account.to_account ());
2319  		}
2320  		else
2321  		{
2322  			tree.put ("type", "receive");
2323  		}
2324  		if (block_a.hashables.source != handler.node.ledger.constants.genesis->account ())
2325  		{
2326  			bool error_or_pruned (false);
2327  			auto amount (handler.node.ledger.amount_safe (transaction, hash, error_or_pruned).convert_to<std::string> ());
2328  			if (!error_or_pruned)
2329  			{
2330  				auto source_account (handler.node.ledger.account_safe (transaction, block_a.hashables.source, error_or_pruned));
2331  				if (!error_or_pruned)
2332  				{
2333  					tree.put ("account", source_account.to_account ());
2334  				}
2335  				tree.put ("amount", amount);
2336  			}
2337  		}
2338  		else
2339  		{
2340  			tree.put ("account", handler.node.ledger.constants.genesis->account ().to_account ());
2341  			tree.put ("amount", nano::dev::constants.genesis_amount.convert_to<std::string> ());
2342  		}
2343  	}
2344  	void change_block (nano::change_block const & block_a)
2345  	{
2346  		if (raw && accounts_filter.empty ())
2347  		{
2348  			tree.put ("type", "change");
2349  			tree.put ("representative", block_a.hashables.representative.to_account ());
2350  			tree.put ("previous", block_a.hashables.previous.to_string ());
2351  		}
2352  	}
2353  	void state_block (nano::state_block const & block_a)
2354  	{
2355  		if (raw)
2356  		{
2357  			tree.put ("type", "state");
2358  			tree.put ("representative", block_a.hashables.representative.to_account ());
2359  			tree.put ("link", block_a.hashables.link.to_string ());
2360  			tree.put ("balance", block_a.hashables.balance.to_string_dec ());
2361  			tree.put ("previous", block_a.hashables.previous.to_string ());
2362  		}
2363  		auto balance (block_a.hashables.balance.number ());
2364  		bool error_or_pruned (false);
2365  		auto previous_balance (handler.node.ledger.balance_safe (transaction, block_a.hashables.previous, error_or_pruned));
2366  		if (error_or_pruned)
2367  		{
2368  			if (raw)
2369  			{
2370  				tree.put ("subtype", "unknown");
2371  			}
2372  			else
2373  			{
2374  				tree.put ("type", "unknown");
2375  			}
2376  		}
2377  		else if (balance < previous_balance)
2378  		{
2379  			if (should_ignore_account (block_a.hashables.link.as_account ()))
2380  			{
2381  				tree.clear ();
2382  				return;
2383  			}
2384  			if (raw)
2385  			{
2386  				tree.put ("subtype", "send");
2387  			}
2388  			else
2389  			{
2390  				tree.put ("type", "send");
2391  			}
2392  			tree.put ("account", block_a.hashables.link.to_account ());
2393  			tree.put ("amount", (previous_balance - balance).convert_to<std::string> ());
2394  		}
2395  		else
2396  		{
2397  			if (block_a.hashables.link.is_zero ())
2398  			{
2399  				if (raw && accounts_filter.empty ())
2400  				{
2401  					tree.put ("subtype", "change");
2402  				}
2403  			}
2404  			else if (balance == previous_balance && handler.node.ledger.is_epoch_link (block_a.hashables.link))
2405  			{
2406  				if (raw && accounts_filter.empty ())
2407  				{
2408  					tree.put ("subtype", "epoch");
2409  					tree.put ("account", handler.node.ledger.epoch_signer (block_a.link ()).to_account ());
2410  				}
2411  			}
2412  			else
2413  			{
2414  				auto source_account (handler.node.ledger.account_safe (transaction, block_a.hashables.link.as_block_hash (), error_or_pruned));
2415  				if (!error_or_pruned && should_ignore_account (source_account))
2416  				{
2417  					tree.clear ();
2418  					return;
2419  				}
2420  				if (raw)
2421  				{
2422  					tree.put ("subtype", "receive");
2423  				}
2424  				else
2425  				{
2426  					tree.put ("type", "receive");
2427  				}
2428  				if (!error_or_pruned)
2429  				{
2430  					tree.put ("account", source_account.to_account ());
2431  				}
2432  				tree.put ("amount", (balance - previous_balance).convert_to<std::string> ());
2433  			}
2434  		}
2435  	}
2436  	bool should_ignore_account (nano::public_key const & account)
2437  	{
2438  		bool ignore (false);
2439  		if (!accounts_filter.empty ())
2440  		{
2441  			if (std::find (accounts_filter.begin (), accounts_filter.end (), account) == accounts_filter.end ())
2442  			{
2443  				ignore = true;
2444  			}
2445  		}
2446  		return ignore;
2447  	}
2448  	nano::json_handler & handler;
2449  	bool raw;
2450  	nano::transaction & transaction;
2451  	boost::property_tree::ptree & tree;
2452  	nano::block_hash const & hash;
2453  	std::vector<nano::public_key> const & accounts_filter;
2454  };
2455  }
2456  void nano::json_handler::account_history ()
2457  {
2458  	std::vector<nano::public_key> accounts_to_filter;
2459  	auto const accounts_filter_node = request.get_child_optional ("account_filter");
2460  	if (accounts_filter_node.is_initialized ())
2461  	{
2462  		for (auto & a : (*accounts_filter_node))
2463  		{
2464  			auto account (account_impl (a.second.get<std::string> ("")));
2465  			if (!ec)
2466  			{
2467  				accounts_to_filter.push_back (account);
2468  			}
2469  			else
2470  			{
2471  				break;
2472  			}
2473  		}
2474  	}
2475  	nano::account account;
2476  	nano::block_hash hash;
2477  	bool reverse (request.get_optional<bool> ("reverse") == true);
2478  	auto head_str (request.get_optional<std::string> ("head"));
2479  	auto transaction (node.store.tx_begin_read ());
2480  	auto count (count_impl ());
2481  	auto offset (offset_optional_impl (0));
2482  	if (head_str)
2483  	{
2484  		if (!hash.decode_hex (*head_str))
2485  		{
2486  			if (node.store.block.exists (transaction, hash))
2487  			{
2488  				account = node.ledger.account (transaction, hash);
2489  			}
2490  			else
2491  			{
2492  				ec = nano::error_blocks::not_found;
2493  			}
2494  		}
2495  		else
2496  		{
2497  			ec = nano::error_blocks::bad_hash_number;
2498  		}
2499  	}
2500  	else
2501  	{
2502  		account = account_impl ();
2503  		if (!ec)
2504  		{
2505  			if (reverse)
2506  			{
2507  				auto info (account_info_impl (transaction, account));
2508  				if (!ec)
2509  				{
2510  					hash = info.open_block;
2511  				}
2512  			}
2513  			else
2514  			{
2515  				hash = node.ledger.latest (transaction, account);
2516  			}
2517  		}
2518  	}
2519  	if (!ec)
2520  	{
2521  		boost::property_tree::ptree history;
2522  		bool output_raw (request.get_optional<bool> ("raw") == true);
2523  		response_l.put ("account", account.to_account ());
2524  		auto block (node.store.block.get (transaction, hash));
2525  		while (block != nullptr && count > 0)
2526  		{
2527  			if (offset > 0)
2528  			{
2529  				--offset;
2530  			}
2531  			else
2532  			{
2533  				boost::property_tree::ptree entry;
2534  				history_visitor visitor (*this, output_raw, transaction, entry, hash, accounts_to_filter);
2535  				block->visit (visitor);
2536  				if (!entry.empty ())
2537  				{
2538  					entry.put ("local_timestamp", std::to_string (block->sideband ().timestamp));
2539  					entry.put ("height", std::to_string (block->sideband ().height));
2540  					entry.put ("hash", hash.to_string ());
2541  					entry.put ("confirmed", node.ledger.block_confirmed (transaction, hash));
2542  					if (output_raw)
2543  					{
2544  						entry.put ("work", nano::to_string_hex (block->block_work ()));
2545  						entry.put ("signature", block->block_signature ().to_string ());
2546  					}
2547  					history.push_back (std::make_pair ("", entry));
2548  					--count;
2549  				}
2550  			}
2551  			hash = reverse ? node.store.block.successor (transaction, hash) : block->previous ();
2552  			block = node.store.block.get (transaction, hash);
2553  		}
2554  		response_l.add_child ("history", history);
2555  		if (!hash.is_zero ())
2556  		{
2557  			response_l.put (reverse ? "next" : "previous", hash.to_string ());
2558  		}
2559  	}
2560  	response_errors ();
2561  }
2562  void nano::json_handler::keepalive ()
2563  {
2564  	if (!ec)
2565  	{
2566  		std::string address_text (request.get<std::string> ("address"));
2567  		std::string port_text (request.get<std::string> ("port"));
2568  		uint16_t port;
2569  		if (!nano::parse_port (port_text, port))
2570  		{
2571  			node.keepalive (address_text, port);
2572  			response_l.put ("started", "1");
2573  		}
2574  		else
2575  		{
2576  			ec = nano::error_common::invalid_port;
2577  		}
2578  	}
2579  	response_errors ();
2580  }
2581  void nano::json_handler::key_create ()
2582  {
2583  	nano::keypair pair;
2584  	response_l.put ("private", pair.prv.to_string ());
2585  	response_l.put ("public", pair.pub.to_string ());
2586  	response_l.put ("account", pair.pub.to_account ());
2587  	response_errors ();
2588  }
2589  void nano::json_handler::key_expand ()
2590  {
2591  	std::string key_text (request.get<std::string> ("key"));
2592  	nano::raw_key prv;
2593  	if (!prv.decode_hex (key_text))
2594  	{
2595  		nano::public_key pub (nano::pub_key (prv));
2596  		response_l.put ("private", prv.to_string ());
2597  		response_l.put ("public", pub.to_string ());
2598  		response_l.put ("account", pub.to_account ());
2599  	}
2600  	else
2601  	{
2602  		ec = nano::error_common::bad_private_key;
2603  	}
2604  	response_errors ();
2605  }
2606  void nano::json_handler::ledger ()
2607  {
2608  	auto count (count_optional_impl ());
2609  	auto threshold (threshold_optional_impl ());
2610  	if (!ec)
2611  	{
2612  		nano::account start{};
2613  		boost::optional<std::string> account_text (request.get_optional<std::string> ("account"));
2614  		if (account_text.is_initialized ())
2615  		{
2616  			start = account_impl (account_text.get ());
2617  		}
2618  		uint64_t modified_since (0);
2619  		boost::optional<std::string> modified_since_text (request.get_optional<std::string> ("modified_since"));
2620  		if (modified_since_text.is_initialized ())
2621  		{
2622  			if (decode_unsigned (modified_since_text.get (), modified_since))
2623  			{
2624  				ec = nano::error_rpc::invalid_timestamp;
2625  			}
2626  		}
2627  		bool const sorting = request.get<bool> ("sorting", false);
2628  		bool const representative = request.get<bool> ("representative", false);
2629  		bool const weight = request.get<bool> ("weight", false);
2630  		bool const pending = request.get<bool> ("pending", false);
2631  		bool const receivable = request.get<bool> ("receivable", pending);
2632  		boost::property_tree::ptree accounts;
2633  		auto transaction (node.store.tx_begin_read ());
2634  		if (!ec && !sorting) 
2635  		{
2636  			for (auto i (node.store.account.begin (transaction, start)), n (node.store.account.end ()); i != n && accounts.size () < count; ++i)
2637  			{
2638  				nano::account_info const & info (i->second);
2639  				if (info.modified >= modified_since && (receivable || info.balance.number () >= threshold.number ()))
2640  				{
2641  					nano::account const & account (i->first);
2642  					boost::property_tree::ptree response_a;
2643  					if (receivable)
2644  					{
2645  						auto account_receivable = node.ledger.account_receivable (transaction, account);
2646  						if (info.balance.number () + account_receivable < threshold.number ())
2647  						{
2648  							continue;
2649  						}
2650  						response_a.put ("pending", account_receivable.convert_to<std::string> ());
2651  						response_a.put ("receivable", account_receivable.convert_to<std::string> ());
2652  					}
2653  					response_a.put ("frontier", info.head.to_string ());
2654  					response_a.put ("open_block", info.open_block.to_string ());
2655  					response_a.put ("representative_block", node.ledger.representative (transaction, info.head).to_string ());
2656  					std::string balance;
2657  					nano::uint128_union (info.balance).encode_dec (balance);
2658  					response_a.put ("balance", balance);
2659  					response_a.put ("modified_timestamp", std::to_string (info.modified));
2660  					response_a.put ("block_count", std::to_string (info.block_count));
2661  					if (representative)
2662  					{
2663  						response_a.put ("representative", info.representative.to_account ());
2664  					}
2665  					if (weight)
2666  					{
2667  						auto account_weight (node.ledger.weight (account));
2668  						response_a.put ("weight", account_weight.convert_to<std::string> ());
2669  					}
2670  					accounts.push_back (std::make_pair (account.to_account (), response_a));
2671  				}
2672  			}
2673  		}
2674  		else if (!ec) 
2675  		{
2676  			std::vector<std::pair<nano::uint128_union, nano::account>> ledger_l;
2677  			for (auto i (node.store.account.begin (transaction, start)), n (node.store.account.end ()); i != n; ++i)
2678  			{
2679  				nano::account_info const & info (i->second);
2680  				nano::uint128_union balance (info.balance);
2681  				if (info.modified >= modified_since)
2682  				{
2683  					ledger_l.emplace_back (balance, i->first);
2684  				}
2685  			}
2686  			std::sort (ledger_l.begin (), ledger_l.end ());
2687  			std::reverse (ledger_l.begin (), ledger_l.end ());
2688  			nano::account_info info;
2689  			for (auto i (ledger_l.begin ()), n (ledger_l.end ()); i != n && accounts.size () < count; ++i)
2690  			{
2691  				node.store.account.get (transaction, i->second, info);
2692  				if (receivable || info.balance.number () >= threshold.number ())
2693  				{
2694  					nano::account const & account (i->second);
2695  					boost::property_tree::ptree response_a;
2696  					if (receivable)
2697  					{
2698  						auto account_receivable = node.ledger.account_receivable (transaction, account);
2699  						if (info.balance.number () + account_receivable < threshold.number ())
2700  						{
2701  							continue;
2702  						}
2703  						response_a.put ("pending", account_receivable.convert_to<std::string> ());
2704  						response_a.put ("receivable", account_receivable.convert_to<std::string> ());
2705  					}
2706  					response_a.put ("frontier", info.head.to_string ());
2707  					response_a.put ("open_block", info.open_block.to_string ());
2708  					response_a.put ("representative_block", node.ledger.representative (transaction, info.head).to_string ());
2709  					std::string balance;
2710  					(i->first).encode_dec (balance);
2711  					response_a.put ("balance", balance);
2712  					response_a.put ("modified_timestamp", std::to_string (info.modified));
2713  					response_a.put ("block_count", std::to_string (info.block_count));
2714  					if (representative)
2715  					{
2716  						response_a.put ("representative", info.representative.to_account ());
2717  					}
2718  					if (weight)
2719  					{
2720  						auto account_weight (node.ledger.weight (account));
2721  						response_a.put ("weight", account_weight.convert_to<std::string> ());
2722  					}
2723  					accounts.push_back (std::make_pair (account.to_account (), response_a));
2724  				}
2725  			}
2726  		}
2727  		response_l.add_child ("accounts", accounts);
2728  	}
2729  	response_errors ();
2730  }
2731  void nano::json_handler::mnano_from_raw (nano::uint128_t ratio)
2732  {
2733  	auto amount (amount_impl ());
2734  	response_l.put ("deprecated", "1");
2735  	if (!ec)
2736  	{
2737  		auto result (amount.number () / ratio);
2738  		response_l.put ("amount", result.convert_to<std::string> ());
2739  	}
2740  	response_errors ();
2741  }
2742  void nano::json_handler::mnano_to_raw (nano::uint128_t ratio)
2743  {
2744  	auto amount (amount_impl ());
2745  	response_l.put ("deprecated", "1");
2746  	if (!ec)
2747  	{
2748  		auto result (amount.number () * ratio);
2749  		if (result > amount.number ())
2750  		{
2751  			response_l.put ("amount", result.convert_to<std::string> ());
2752  		}
2753  		else
2754  		{
2755  			ec = nano::error_common::invalid_amount_big;
2756  		}
2757  	}
2758  	response_errors ();
2759  }
2760  void nano::json_handler::nano_to_raw ()
2761  {
2762  	auto amount (amount_impl ());
2763  	if (!ec)
2764  	{
2765  		auto result (amount.number () * nano::Mxrb_ratio);
2766  		if (result > amount.number ())
2767  		{
2768  			response_l.put ("amount", result.convert_to<std::string> ());
2769  		}
2770  		else
2771  		{
2772  			ec = nano::error_common::invalid_amount_big;
2773  		}
2774  	}
2775  	response_errors ();
2776  }
2777  void nano::json_handler::raw_to_nano ()
2778  {
2779  	auto amount (amount_impl ());
2780  	if (!ec)
2781  	{
2782  		auto result (amount.number () / nano::Mxrb_ratio);
2783  		response_l.put ("amount", result.convert_to<std::string> ());
2784  	}
2785  	response_errors ();
2786  }
2787  void nano::json_handler::node_id ()
2788  {
2789  	if (!ec)
2790  	{
2791  		response_l.put ("private", node.node_id.prv.to_string ());
2792  		response_l.put ("public", node.node_id.pub.to_string ());
2793  		response_l.put ("as_account", node.node_id.pub.to_account ());
2794  		response_l.put ("node_id", node.node_id.pub.to_node_id ());
2795  	}
2796  	response_errors ();
2797  }
2798  void nano::json_handler::node_id_delete ()
2799  {
2800  	response_l.put ("deprecated", "1");
2801  	response_errors ();
2802  }
2803  void nano::json_handler::password_change ()
2804  {
2805  	node.workers.push_task (create_worker_task ([] (std::shared_ptr<nano::json_handler> const & rpc_l) {
2806  		auto wallet (rpc_l->wallet_impl ());
2807  		if (!rpc_l->ec)
2808  		{
2809  			auto transaction (rpc_l->node.wallets.tx_begin_write ());
2810  			rpc_l->wallet_locked_impl (transaction, wallet);
2811  			if (!rpc_l->ec)
2812  			{
2813  				std::string password_text (rpc_l->request.get<std::string> ("password"));
2814  				bool error (wallet->store.rekey (transaction, password_text));
2815  				rpc_l->response_l.put ("changed", error ? "0" : "1");
2816  				if (!error)
2817  				{
2818  					rpc_l->node.logger.try_log ("Wallet password changed");
2819  				}
2820  			}
2821  		}
2822  		rpc_l->response_errors ();
2823  	}));
2824  }
2825  void nano::json_handler::password_enter ()
2826  {
2827  	node.workers.push_task (create_worker_task ([] (std::shared_ptr<nano::json_handler> const & rpc_l) {
2828  		auto wallet (rpc_l->wallet_impl ());
2829  		if (!rpc_l->ec)
2830  		{
2831  			std::string password_text (rpc_l->request.get<std::string> ("password"));
2832  			auto transaction (wallet->wallets.tx_begin_write ());
2833  			auto error (wallet->enter_password (transaction, password_text));
2834  			rpc_l->response_l.put ("valid", error ? "0" : "1");
2835  		}
2836  		rpc_l->response_errors ();
2837  	}));
2838  }
2839  void nano::json_handler::password_valid (bool wallet_locked)
2840  {
2841  	auto wallet (wallet_impl ());
2842  	if (!ec)
2843  	{
2844  		auto transaction (node.wallets.tx_begin_read ());
2845  		auto valid (wallet->store.valid_password (transaction));
2846  		if (!wallet_locked)
2847  		{
2848  			response_l.put ("valid", valid ? "1" : "0");
2849  		}
2850  		else
2851  		{
2852  			response_l.put ("locked", valid ? "0" : "1");
2853  		}
2854  	}
2855  	response_errors ();
2856  }
2857  void nano::json_handler::peers ()
2858  {
2859  	boost::property_tree::ptree peers_l;
2860  	bool const peer_details = request.get<bool> ("peer_details", false);
2861  	auto peers_list (node.network.list (std::numeric_limits<std::size_t>::max ()));
2862  	std::sort (peers_list.begin (), peers_list.end (), [] (auto const & lhs, auto const & rhs) {
2863  		return lhs->get_endpoint () < rhs->get_endpoint ();
2864  	});
2865  	for (auto i (peers_list.begin ()), n (peers_list.end ()); i != n; ++i)
2866  	{
2867  		std::stringstream text;
2868  		auto channel (*i);
2869  		text << channel->to_string ();
2870  		if (peer_details)
2871  		{
2872  			boost::property_tree::ptree pending_tree;
2873  			pending_tree.put ("protocol_version", std::to_string (channel->get_network_version ()));
2874  			auto node_id_l (channel->get_node_id_optional ());
2875  			if (node_id_l.is_initialized ())
2876  			{
2877  				pending_tree.put ("node_id", node_id_l.get ().to_node_id ());
2878  			}
2879  			else
2880  			{
2881  				pending_tree.put ("node_id", "");
2882  			}
2883  			debug_assert (channel->get_type () == nano::transport::transport_type::tcp);
2884  			pending_tree.put ("type", "tcp");
2885  			peers_l.push_back (boost::property_tree::ptree::value_type (text.str (), pending_tree));
2886  		}
2887  		else
2888  		{
2889  			peers_l.push_back (boost::property_tree::ptree::value_type (text.str (), boost::property_tree::ptree (std::to_string (channel->get_network_version ()))));
2890  		}
2891  	}
2892  	response_l.add_child ("peers", peers_l);
2893  	response_errors ();
2894  }
2895  void nano::json_handler::pending ()
2896  {
2897  	response_l.put ("deprecated", "1");
2898  	receivable ();
2899  }
2900  void nano::json_handler::receivable ()
2901  {
2902  	auto account (account_impl ());
2903  	auto count (count_optional_impl ());
2904  	auto offset (offset_optional_impl (0));
2905  	auto threshold (threshold_optional_impl ());
2906  	bool const source = request.get<bool> ("source", false);
2907  	bool const min_version = request.get<bool> ("min_version", false);
2908  	bool const include_active = request.get<bool> ("include_active", false);
2909  	bool const include_only_confirmed = request.get<bool> ("include_only_confirmed", true);
2910  	bool const sorting = request.get<bool> ("sorting", false);
2911  	auto simple (threshold.is_zero () && !source && !min_version && !sorting); 
2912  	bool const should_sort = sorting && !simple;
2913  	if (!ec)
2914  	{
2915  		auto offset_counter = offset;
2916  		boost::property_tree::ptree peers_l;
2917  		auto transaction (node.store.tx_begin_read ());
2918  		std::vector<std::pair<std::string, boost::property_tree::ptree>> hash_ptree_pairs;
2919  		std::vector<std::pair<std::string, nano::uint128_t>> hash_amount_pairs;
2920  		for (auto i (node.store.pending.begin (transaction, nano::pending_key (account, 0))), n (node.store.pending.end ()); i != n && nano::pending_key (i->first).account == account && (should_sort || peers_l.size () < count); ++i)
2921  		{
2922  			nano::pending_key const & key (i->first);
2923  			if (block_confirmed (node, transaction, key.hash, include_active, include_only_confirmed))
2924  			{
2925  				if (!should_sort && offset_counter > 0)
2926  				{
2927  					--offset_counter;
2928  					continue;
2929  				}
2930  				if (simple)
2931  				{
2932  					boost::property_tree::ptree entry;
2933  					entry.put ("", key.hash.to_string ());
2934  					peers_l.push_back (std::make_pair ("", entry));
2935  				}
2936  				else
2937  				{
2938  					nano::pending_info const & info (i->second);
2939  					if (info.amount.number () >= threshold.number ())
2940  					{
2941  						if (source || min_version)
2942  						{
2943  							boost::property_tree::ptree pending_tree;
2944  							pending_tree.put ("amount", info.amount.number ().convert_to<std::string> ());
2945  							if (source)
2946  							{
2947  								pending_tree.put ("source", info.source.to_account ());
2948  							}
2949  							if (min_version)
2950  							{
2951  								pending_tree.put ("min_version", epoch_as_string (info.epoch));
2952  							}
2953  							if (should_sort)
2954  							{
2955  								hash_ptree_pairs.emplace_back (key.hash.to_string (), pending_tree);
2956  							}
2957  							else
2958  							{
2959  								peers_l.add_child (key.hash.to_string (), pending_tree);
2960  							}
2961  						}
2962  						else
2963  						{
2964  							if (should_sort)
2965  							{
2966  								hash_amount_pairs.emplace_back (key.hash.to_string (), info.amount.number ());
2967  							}
2968  							else
2969  							{
2970  								peers_l.put (key.hash.to_string (), info.amount.number ().convert_to<std::string> ());
2971  							}
2972  						}
2973  					}
2974  				}
2975  			}
2976  		}
2977  		if (should_sort)
2978  		{
2979  			if (source || min_version)
2980  			{
2981  				std::stable_sort (hash_ptree_pairs.begin (), hash_ptree_pairs.end (), [] (auto const & lhs, auto const & rhs) {
2982  					return lhs.second.template get<nano::uint128_t> ("amount") > rhs.second.template get<nano::uint128_t> ("amount");
2983  				});
2984  				for (auto i = offset, j = offset + count; i < hash_ptree_pairs.size () && i < j; ++i)
2985  				{
2986  					peers_l.add_child (hash_ptree_pairs[i].first, hash_ptree_pairs[i].second);
2987  				}
2988  			}
2989  			else
2990  			{
2991  				std::stable_sort (hash_amount_pairs.begin (), hash_amount_pairs.end (), [] (auto const & lhs, auto const & rhs) {
2992  					return lhs.second > rhs.second;
2993  				});
2994  				for (auto i = offset, j = offset + count; i < hash_amount_pairs.size () && i < j; ++i)
2995  				{
2996  					peers_l.put (hash_amount_pairs[i].first, hash_amount_pairs[i].second.convert_to<std::string> ());
2997  				}
2998  			}
2999  		}
3000  		response_l.add_child ("blocks", peers_l);
3001  	}
3002  	response_errors ();
3003  }
3004  void nano::json_handler::pending_exists ()
3005  {
3006  	response_l.put ("deprecated", "1");
3007  	receivable_exists ();
3008  }
3009  void nano::json_handler::receivable_exists ()
3010  {
3011  	auto hash (hash_impl ());
3012  	bool const include_active = request.get<bool> ("include_active", false);
3013  	bool const include_only_confirmed = request.get<bool> ("include_only_confirmed", true);
3014  	if (!ec)
3015  	{
3016  		auto transaction (node.store.tx_begin_read ());
3017  		auto block (node.store.block.get (transaction, hash));
3018  		if (block != nullptr)
3019  		{
3020  			auto exists (false);
3021  			auto destination (node.ledger.block_destination (transaction, *block));
3022  			if (!destination.is_zero ())
3023  			{
3024  				exists = node.store.pending.exists (transaction, nano::pending_key (destination, hash));
3025  			}
3026  			exists = exists && (block_confirmed (node, transaction, block->hash (), include_active, include_only_confirmed));
3027  			response_l.put ("exists", exists ? "1" : "0");
3028  		}
3029  		else
3030  		{
3031  			ec = nano::error_blocks::not_found;
3032  		}
3033  	}
3034  	response_errors ();
3035  }
3036  void nano::json_handler::process ()
3037  {
3038  	node.workers.push_task (create_worker_task ([] (std::shared_ptr<nano::json_handler> const & rpc_l) {
3039  		bool const is_async = rpc_l->request.get<bool> ("async", false);
3040  		auto block (rpc_l->block_impl (true));
3041  		if (!rpc_l->ec && block->type () == nano::block_type::state)
3042  		{
3043  			std::string subtype_text (rpc_l->request.get<std::string> ("subtype", ""));
3044  			if (!subtype_text.empty ())
3045  			{
3046  				std::shared_ptr<nano::state_block> block_state (std::static_pointer_cast<nano::state_block> (block));
3047  				auto transaction (rpc_l->node.store.tx_begin_read ());
3048  				if (!block_state->hashables.previous.is_zero () && !rpc_l->node.store.block.exists (transaction, block_state->hashables.previous))
3049  				{
3050  					rpc_l->ec = nano::error_process::gap_previous;
3051  				}
3052  				else
3053  				{
3054  					auto balance (rpc_l->node.ledger.account_balance (transaction, block_state->hashables.account));
3055  					if (subtype_text == "send")
3056  					{
3057  						if (balance <= block_state->hashables.balance.number ())
3058  						{
3059  							rpc_l->ec = nano::error_rpc::invalid_subtype_balance;
3060  						}
3061  					}
3062  					else if (subtype_text == "receive")
3063  					{
3064  						if (balance > block_state->hashables.balance.number ())
3065  						{
3066  							rpc_l->ec = nano::error_rpc::invalid_subtype_balance;
3067  						}
3068  					}
3069  					else if (subtype_text == "open")
3070  					{
3071  						if (!block_state->hashables.previous.is_zero ())
3072  						{
3073  							rpc_l->ec = nano::error_rpc::invalid_subtype_previous;
3074  						}
3075  					}
3076  					else if (subtype_text == "change")
3077  					{
3078  						if (balance != block_state->hashables.balance.number ())
3079  						{
3080  							rpc_l->ec = nano::error_rpc::invalid_subtype_balance;
3081  						}
3082  						else if (block_state->hashables.previous.is_zero ())
3083  						{
3084  							rpc_l->ec = nano::error_rpc::invalid_subtype_previous;
3085  						}
3086  					}
3087  					else if (subtype_text == "epoch")
3088  					{
3089  						if (balance != block_state->hashables.balance.number ())
3090  						{
3091  							rpc_l->ec = nano::error_rpc::invalid_subtype_balance;
3092  						}
3093  						else if (!rpc_l->node.ledger.is_epoch_link (block_state->hashables.link))
3094  						{
3095  							rpc_l->ec = nano::error_rpc::invalid_subtype_epoch_link;
3096  						}
3097  					}
3098  					else
3099  					{
3100  						rpc_l->ec = nano::error_rpc::invalid_subtype;
3101  					}
3102  				}
3103  			}
3104  		}
3105  		if (!rpc_l->ec)
3106  		{
3107  			if (!rpc_l->node.network_params.work.validate_entry (*block))
3108  			{
3109  				if (!is_async)
3110  				{
3111  					auto result_maybe = rpc_l->node.process_local (block);
3112  					if (!result_maybe)
3113  					{
3114  						rpc_l->ec = nano::error_rpc::stopped;
3115  					}
3116  					else
3117  					{
3118  						auto const & result = result_maybe.value ();
3119  						switch (result.code)
3120  						{
3121  							case nano::process_result::progress:
3122  							{
3123  								rpc_l->response_l.put ("hash", block->hash ().to_string ());
3124  								break;
3125  							}
3126  							case nano::process_result::gap_previous:
3127  							{
3128  								rpc_l->ec = nano::error_process::gap_previous;
3129  								break;
3130  							}
3131  							case nano::process_result::gap_source:
3132  							{
3133  								rpc_l->ec = nano::error_process::gap_source;
3134  								break;
3135  							}
3136  							case nano::process_result::old:
3137  							{
3138  								rpc_l->ec = nano::error_process::old;
3139  								break;
3140  							}
3141  							case nano::process_result::bad_signature:
3142  							{
3143  								rpc_l->ec = nano::error_process::bad_signature;
3144  								break;
3145  							}
3146  							case nano::process_result::negative_spend:
3147  							{
3148  								rpc_l->ec = nano::error_process::negative_spend;
3149  								break;
3150  							}
3151  							case nano::process_result::balance_mismatch:
3152  							{
3153  								rpc_l->ec = nano::error_process::balance_mismatch;
3154  								break;
3155  							}
3156  							case nano::process_result::unreceivable:
3157  							{
3158  								rpc_l->ec = nano::error_process::unreceivable;
3159  								break;
3160  							}
3161  							case nano::process_result::block_position:
3162  							{
3163  								rpc_l->ec = nano::error_process::block_position;
3164  								break;
3165  							}
3166  							case nano::process_result::gap_epoch_open_pending:
3167  							{
3168  								rpc_l->ec = nano::error_process::gap_epoch_open_pending;
3169  								break;
3170  							}
3171  							case nano::process_result::fork:
3172  							{
3173  								bool const force = rpc_l->request.get<bool> ("force", false);
3174  								if (force)
3175  								{
3176  									rpc_l->node.active.erase (*block);
3177  									rpc_l->node.block_processor.force (block);
3178  									rpc_l->response_l.put ("hash", block->hash ().to_string ());
3179  								}
3180  								else
3181  								{
3182  									rpc_l->ec = nano::error_process::fork;
3183  								}
3184  								break;
3185  							}
3186  							case nano::process_result::insufficient_work:
3187  							{
3188  								rpc_l->ec = nano::error_process::insufficient_work;
3189  								break;
3190  							}
3191  							case nano::process_result::opened_burn_account:
3192  								rpc_l->ec = nano::error_process::opened_burn_account;
3193  								break;
3194  							default:
3195  							{
3196  								rpc_l->ec = nano::error_process::other;
3197  								break;
3198  							}
3199  						}
3200  					}
3201  				}
3202  				else
3203  				{
3204  					if (block->type () == nano::block_type::state)
3205  					{
3206  						rpc_l->node.process_local_async (block);
3207  						rpc_l->response_l.put ("started", "1");
3208  					}
3209  					else
3210  					{
3211  						rpc_l->ec = nano::error_common::is_not_state_block;
3212  					}
3213  				}
3214  			}
3215  			else
3216  			{
3217  				rpc_l->ec = nano::error_blocks::work_low;
3218  			}
3219  		}
3220  		rpc_l->response_errors ();
3221  	}));
3222  }
3223  void nano::json_handler::pruned_exists ()
3224  {
3225  	auto hash (hash_impl ());
3226  	if (!ec)
3227  	{
3228  		auto transaction (node.store.tx_begin_read ());
3229  		if (node.ledger.pruning)
3230  		{
3231  			auto exists (node.store.pruned.exists (transaction, hash));
3232  			response_l.put ("exists", exists ? "1" : "0");
3233  		}
3234  		else
3235  		{
3236  			ec = nano::error_rpc::pruning_disabled;
3237  		}
3238  	}
3239  	response_errors ();
3240  }
3241  void nano::json_handler::receive ()
3242  {
3243  	auto wallet (wallet_impl ());
3244  	auto account (account_impl ());
3245  	auto hash (hash_impl ("block"));
3246  	if (!ec)
3247  	{
3248  		auto wallet_transaction (node.wallets.tx_begin_read ());
3249  		wallet_locked_impl (wallet_transaction, wallet);
3250  		wallet_account_impl (wallet_transaction, wallet, account);
3251  		if (!ec)
3252  		{
3253  			auto block_transaction (node.store.tx_begin_read ());
3254  			if (node.ledger.block_or_pruned_exists (block_transaction, hash))
3255  			{
3256  				auto pending_info = node.ledger.pending_info (block_transaction, nano::pending_key (account, hash));
3257  				if (pending_info)
3258  				{
3259  					auto work (work_optional_impl ());
3260  					if (!ec && work)
3261  					{
3262  						nano::root head;
3263  						nano::epoch epoch = pending_info->epoch;
3264  						auto info = node.ledger.account_info (block_transaction, account);
3265  						if (info)
3266  						{
3267  							head = info->head;
3268  							epoch = std::max (info->epoch (), epoch);
3269  						}
3270  						else
3271  						{
3272  							head = account;
3273  						}
3274  						nano::block_details details (epoch, false, true, false);
3275  						if (node.network_params.work.difficulty (nano::work_version::work_1, head, work) < node.network_params.work.threshold (nano::work_version::work_1, details))
3276  						{
3277  							ec = nano::error_common::invalid_work;
3278  						}
3279  					}
3280  					else if (!ec) 
3281  					{
3282  						if (!node.work_generation_enabled ())
3283  						{
3284  							ec = nano::error_common::disabled_work_generation;
3285  						}
3286  					}
3287  					if (!ec)
3288  					{
3289  						nano::account representative (wallet->store.representative (wallet_transaction));
3290  						bool generate_work (work == 0); 
3291  						auto response_a (response);
3292  						wallet->receive_async (
3293  						hash, representative, nano::dev::constants.genesis_amount, account, [response_a] (std::shared_ptr<nano::block> const & block_a) {
3294  							if (block_a != nullptr)
3295  							{
3296  								boost::property_tree::ptree response_l;
3297  								response_l.put ("block", block_a->hash ().to_string ());
3298  								std::stringstream ostream;
3299  								boost::property_tree::write_json (ostream, response_l);
3300  								response_a (ostream.str ());
3301  							}
3302  							else
3303  							{
3304  								json_error_response (response_a, "Error generating block");
3305  							}
3306  						},
3307  						work, generate_work);
3308  					}
3309  				}
3310  				else
3311  				{
3312  					ec = nano::error_process::unreceivable;
3313  				}
3314  			}
3315  			else
3316  			{
3317  				ec = nano::error_blocks::not_found;
3318  			}
3319  		}
3320  	}
3321  	if (ec)
3322  	{
3323  		response_errors ();
3324  	}
3325  }
3326  void nano::json_handler::receive_minimum ()
3327  {
3328  	if (!ec)
3329  	{
3330  		response_l.put ("amount", node.config.receive_minimum.to_string_dec ());
3331  	}
3332  	response_errors ();
3333  }
3334  void nano::json_handler::receive_minimum_set ()
3335  {
3336  	auto amount (amount_impl ());
3337  	if (!ec)
3338  	{
3339  		node.config.receive_minimum = amount;
3340  		response_l.put ("success", "");
3341  	}
3342  	response_errors ();
3343  }
3344  void nano::json_handler::representatives ()
3345  {
3346  	auto count (count_optional_impl ());
3347  	if (!ec)
3348  	{
3349  		bool const sorting = request.get<bool> ("sorting", false);
3350  		boost::property_tree::ptree representatives;
3351  		auto rep_amounts = node.ledger.cache.rep_weights.get_rep_amounts ();
3352  		if (!sorting) 
3353  		{
3354  			std::map<nano::account, nano::uint128_t> ordered (rep_amounts.begin (), rep_amounts.end ());
3355  			for (auto & rep_amount : rep_amounts)
3356  			{
3357  				auto const & account (rep_amount.first);
3358  				auto const & amount (rep_amount.second);
3359  				representatives.put (account.to_account (), amount.convert_to<std::string> ());
3360  				if (representatives.size () > count)
3361  				{
3362  					break;
3363  				}
3364  			}
3365  		}
3366  		else 
3367  		{
3368  			std::vector<std::pair<nano::uint128_t, std::string>> representation;
3369  			for (auto & rep_amount : rep_amounts)
3370  			{
3371  				auto const & account (rep_amount.first);
3372  				auto const & amount (rep_amount.second);
3373  				representation.emplace_back (amount, account.to_account ());
3374  			}
3375  			std::sort (representation.begin (), representation.end ());
3376  			std::reverse (representation.begin (), representation.end ());
3377  			for (auto i (representation.begin ()), n (representation.end ()); i != n && representatives.size () < count; ++i)
3378  			{
3379  				representatives.put (i->second, (i->first).convert_to<std::string> ());
3380  			}
3381  		}
3382  		response_l.add_child ("representatives", representatives);
3383  	}
3384  	response_errors ();
3385  }
3386  void nano::json_handler::representatives_online ()
3387  {
3388  	auto const accounts_node = request.get_child_optional ("accounts");
3389  	bool const weight = request.get<bool> ("weight", false);
3390  	std::vector<nano::public_key> accounts_to_filter;
3391  	if (accounts_node.is_initialized ())
3392  	{
3393  		for (auto & a : (*accounts_node))
3394  		{
3395  			auto account (account_impl (a.second.get<std::string> ("")));
3396  			if (!ec)
3397  			{
3398  				accounts_to_filter.push_back (account);
3399  			}
3400  			else
3401  			{
3402  				break;
3403  			}
3404  		}
3405  	}
3406  	if (!ec)
3407  	{
3408  		boost::property_tree::ptree representatives;
3409  		auto reps (node.online_reps.list ());
3410  		for (auto & i : reps)
3411  		{
3412  			if (accounts_node.is_initialized ())
3413  			{
3414  				if (accounts_to_filter.empty ())
3415  				{
3416  					break;
3417  				}
3418  				auto found_acc = std::find (accounts_to_filter.begin (), accounts_to_filter.end (), i);
3419  				if (found_acc == accounts_to_filter.end ())
3420  				{
3421  					continue;
3422  				}
3423  				else
3424  				{
3425  					accounts_to_filter.erase (found_acc);
3426  				}
3427  			}
3428  			if (weight)
3429  			{
3430  				boost::property_tree::ptree weight_node;
3431  				auto account_weight (node.ledger.weight (i));
3432  				weight_node.put ("weight", account_weight.convert_to<std::string> ());
3433  				representatives.add_child (i.to_account (), weight_node);
3434  			}
3435  			else
3436  			{
3437  				boost::property_tree::ptree entry;
3438  				entry.put ("", i.to_account ());
3439  				representatives.push_back (std::make_pair ("", entry));
3440  			}
3441  		}
3442  		response_l.add_child ("representatives", representatives);
3443  	}
3444  	response_errors ();
3445  }
3446  void nano::json_handler::republish ()
3447  {
3448  	auto count (count_optional_impl (1024U));
3449  	uint64_t sources (0);
3450  	uint64_t destinations (0);
3451  	boost::optional<std::string> sources_text (request.get_optional<std::string> ("sources"));
3452  	if (!ec && sources_text.is_initialized ())
3453  	{
3454  		if (decode_unsigned (sources_text.get (), sources))
3455  		{
3456  			ec = nano::error_rpc::invalid_sources;
3457  		}
3458  	}
3459  	boost::optional<std::string> destinations_text (request.get_optional<std::string> ("destinations"));
3460  	if (!ec && destinations_text.is_initialized ())
3461  	{
3462  		if (decode_unsigned (destinations_text.get (), destinations))
3463  		{
3464  			ec = nano::error_rpc::invalid_destinations;
3465  		}
3466  	}
3467  	auto hash (hash_impl ());
3468  	if (!ec)
3469  	{
3470  		boost::property_tree::ptree blocks;
3471  		auto transaction (node.store.tx_begin_read ());
3472  		auto block (node.store.block.get (transaction, hash));
3473  		if (block != nullptr)
3474  		{
3475  			std::deque<std::shared_ptr<nano::block>> republish_bundle;
3476  			for (auto i (0); !hash.is_zero () && i < count; ++i)
3477  			{
3478  				block = node.store.block.get (transaction, hash);
3479  				if (sources != 0) 
3480  				{
3481  					nano::block_hash source (node.ledger.block_source (transaction, *block));
3482  					auto block_a (node.store.block.get (transaction, source));
3483  					std::vector<nano::block_hash> hashes;
3484  					while (block_a != nullptr && hashes.size () < sources)
3485  					{
3486  						hashes.push_back (source);
3487  						source = block_a->previous ();
3488  						block_a = node.store.block.get (transaction, source);
3489  					}
3490  					std::reverse (hashes.begin (), hashes.end ());
3491  					for (auto & hash_l : hashes)
3492  					{
3493  						block_a = node.store.block.get (transaction, hash_l);
3494  						republish_bundle.push_back (std::move (block_a));
3495  						boost::property_tree::ptree entry_l;
3496  						entry_l.put ("", hash_l.to_string ());
3497  						blocks.push_back (std::make_pair ("", entry_l));
3498  					}
3499  				}
3500  				republish_bundle.push_back (std::move (block)); 
3501  				boost::property_tree::ptree entry;
3502  				entry.put ("", hash.to_string ());
3503  				blocks.push_back (std::make_pair ("", entry));
3504  				if (destinations != 0) 
3505  				{
3506  					auto block_b (node.store.block.get (transaction, hash));
3507  					auto destination (node.ledger.block_destination (transaction, *block_b));
3508  					if (!destination.is_zero ())
3509  					{
3510  						if (!node.store.pending.exists (transaction, nano::pending_key (destination, hash)))
3511  						{
3512  							nano::block_hash previous (node.ledger.latest (transaction, destination));
3513  							auto block_d (node.store.block.get (transaction, previous));
3514  							nano::block_hash source;
3515  							std::vector<nano::block_hash> hashes;
3516  							while (block_d != nullptr && hash != source)
3517  							{
3518  								hashes.push_back (previous);
3519  								source = node.ledger.block_source (transaction, *block_d);
3520  								previous = block_d->previous ();
3521  								block_d = node.store.block.get (transaction, previous);
3522  							}
3523  							std::reverse (hashes.begin (), hashes.end ());
3524  							if (hashes.size () > destinations)
3525  							{
3526  								hashes.resize (destinations);
3527  							}
3528  							for (auto & hash_l : hashes)
3529  							{
3530  								block_d = node.store.block.get (transaction, hash_l);
3531  								republish_bundle.push_back (std::move (block_d));
3532  								boost::property_tree::ptree entry_l;
3533  								entry_l.put ("", hash_l.to_string ());
3534  								blocks.push_back (std::make_pair ("", entry_l));
3535  							}
3536  						}
3537  					}
3538  				}
3539  				hash = node.store.block.successor (transaction, hash);
3540  			}
3541  			node.network.flood_block_many (std::move (republish_bundle), nullptr, 25);
3542  			response_l.put ("success", ""); 
3543  			response_l.add_child ("blocks", blocks);
3544  		}
3545  		else
3546  		{
3547  			ec = nano::error_blocks::not_found;
3548  		}
3549  	}
3550  	response_errors ();
3551  }
3552  void nano::json_handler::search_pending ()
3553  {
3554  	response_l.put ("deprecated", "1");
3555  	search_receivable ();
3556  }
3557  void nano::json_handler::search_receivable ()
3558  {
3559  	auto wallet (wallet_impl ());
3560  	if (!ec)
3561  	{
3562  		auto error (wallet->search_receivable (wallet->wallets.tx_begin_read ()));
3563  		response_l.put ("started", !error);
3564  	}
3565  	response_errors ();
3566  }
3567  void nano::json_handler::search_pending_all ()
3568  {
3569  	response_l.put ("deprecated", "1");
3570  	search_receivable_all ();
3571  }
3572  void nano::json_handler::search_receivable_all ()
3573  {
3574  	if (!ec)
3575  	{
3576  		node.wallets.search_receivable_all ();
3577  		response_l.put ("success", "");
3578  	}
3579  	response_errors ();
3580  }
3581  void nano::json_handler::send ()
3582  {
3583  	auto wallet (wallet_impl ());
3584  	auto amount (amount_impl ());
3585  	if (!ec && amount.is_zero ())
3586  	{
3587  		ec = nano::error_common::invalid_amount;
3588  	}
3589  	std::string source_text (request.get<std::string> ("source"));
3590  	auto source (account_impl (source_text, nano::error_rpc::bad_source));
3591  	std::string destination_text (request.get<std::string> ("destination"));
3592  	auto destination (account_impl (destination_text, nano::error_rpc::bad_destination));
3593  	if (!ec)
3594  	{
3595  		auto work (work_optional_impl ());
3596  		nano::uint128_t balance (0);
3597  		if (!ec && work == 0 && !node.work_generation_enabled ())
3598  		{
3599  			ec = nano::error_common::disabled_work_generation;
3600  		}
3601  		if (!ec)
3602  		{
3603  			auto transaction (node.wallets.tx_begin_read ());
3604  			auto block_transaction (node.store.tx_begin_read ());
3605  			wallet_locked_impl (transaction, wallet);
3606  			wallet_account_impl (transaction, wallet, source);
3607  			auto info (account_info_impl (block_transaction, source));
3608  			if (!ec)
3609  			{
3610  				balance = (info.balance).number ();
3611  			}
3612  			if (!ec && work)
3613  			{
3614  				nano::block_details details (info.epoch (), true, false, false);
3615  				if (node.network_params.work.difficulty (nano::work_version::work_1, info.head, work) < node.network_params.work.threshold (nano::work_version::work_1, details))
3616  				{
3617  					ec = nano::error_common::invalid_work;
3618  				}
3619  			}
3620  		}
3621  		if (!ec)
3622  		{
3623  			bool generate_work (work == 0); 
3624  			boost::optional<std::string> send_id (request.get_optional<std::string> ("id"));
3625  			auto response_a (response);
3626  			auto response_data (std::make_shared<boost::property_tree::ptree> (response_l));
3627  			wallet->send_async (
3628  			source, destination, amount.number (), [balance, amount, response_a, response_data] (std::shared_ptr<nano::block> const & block_a) {
3629  				if (block_a != nullptr)
3630  				{
3631  					response_data->put ("block", block_a->hash ().to_string ());
3632  					std::stringstream ostream;
3633  					boost::property_tree::write_json (ostream, *response_data);
3634  					response_a (ostream.str ());
3635  				}
3636  				else
3637  				{
3638  					if (balance >= amount.number ())
3639  					{
3640  						json_error_response (response_a, "Error generating block");
3641  					}
3642  					else
3643  					{
3644  						std::error_code ec (nano::error_common::insufficient_balance);
3645  						json_error_response (response_a, ec.message ());
3646  					}
3647  				}
3648  			},
3649  			work, generate_work, send_id);
3650  		}
3651  	}
3652  	if (ec)
3653  	{
3654  		response_errors ();
3655  	}
3656  }
3657  void nano::json_handler::sign ()
3658  {
3659  	bool const json_block_l = request.get<bool> ("json_block", false);
3660  	nano::block_hash hash (0);
3661  	boost::optional<std::string> hash_text (request.get_optional<std::string> ("hash"));
3662  	if (hash_text.is_initialized ())
3663  	{
3664  		hash = hash_impl ();
3665  	}
3666  	std::shared_ptr<nano::block> block;
3667  	if (!ec && request.count ("block"))
3668  	{
3669  		block = block_impl (true);
3670  		if (block != nullptr)
3671  		{
3672  			hash = block->hash ();
3673  		}
3674  	}
3675  	if (!ec && hash.is_zero ())
3676  	{
3677  		ec = nano::error_blocks::invalid_block;
3678  	}
3679  	else if (!ec && !hash.is_zero () && block == nullptr && !node_rpc_config.enable_sign_hash)
3680  	{
3681  		ec = nano::error_rpc::sign_hash_disabled;
3682  	}
3683  	if (!ec)
3684  	{
3685  		nano::raw_key prv;
3686  		prv.clear ();
3687  		boost::optional<std::string> key_text (request.get_optional<std::string> ("key"));
3688  		if (key_text.is_initialized ())
3689  		{
3690  			if (prv.decode_hex (key_text.get ()))
3691  			{
3692  				ec = nano::error_common::bad_private_key;
3693  			}
3694  		}
3695  		else
3696  		{
3697  			boost::optional<std::string> account_text (request.get_optional<std::string> ("account"));
3698  			boost::optional<std::string> wallet_text (request.get_optional<std::string> ("wallet"));
3699  			if (wallet_text.is_initialized () && account_text.is_initialized ())
3700  			{
3701  				auto account (account_impl ());
3702  				auto wallet (wallet_impl ());
3703  				if (!ec)
3704  				{
3705  					auto transaction (node.wallets.tx_begin_read ());
3706  					wallet_locked_impl (transaction, wallet);
3707  					wallet_account_impl (transaction, wallet, account);
3708  					if (!ec)
3709  					{
3710  						wallet->store.fetch (transaction, account, prv);
3711  					}
3712  				}
3713  			}
3714  		}
3715  		if (prv != 0)
3716  		{
3717  			nano::public_key pub (nano::pub_key (prv));
3718  			nano::signature signature (nano::sign_message (prv, pub, hash));
3719  			response_l.put ("signature", signature.to_string ());
3720  			if (block != nullptr)
3721  			{
3722  				block->signature_set (signature);
3723  				if (json_block_l)
3724  				{
3725  					boost::property_tree::ptree block_node_l;
3726  					block->serialize_json (block_node_l);
3727  					response_l.add_child ("block", block_node_l);
3728  				}
3729  				else
3730  				{
3731  					std::string contents;
3732  					block->serialize_json (contents);
3733  					response_l.put ("block", contents);
3734  				}
3735  			}
3736  		}
3737  		else
3738  		{
3739  			ec = nano::error_rpc::block_create_key_required;
3740  		}
3741  	}
3742  	response_errors ();
3743  }
3744  void nano::json_handler::stats ()
3745  {
3746  	auto sink = node.stats.log_sink_json ();
3747  	std::string type (request.get<std::string> ("type", ""));
3748  	bool use_sink = false;
3749  	if (type == "counters")
3750  	{
3751  		node.stats.log_counters (*sink);
3752  		use_sink = true;
3753  	}
3754  	else if (type == "objects")
3755  	{
3756  		construct_json (collect_container_info (node, "node").get (), response_l);
3757  	}
3758  	else if (type == "samples")
3759  	{
3760  		node.stats.log_samples (*sink);
3761  		use_sink = true;
3762  	}
3763  	else if (type == "database")
3764  	{
3765  		node.store.serialize_memory_stats (response_l);
3766  	}
3767  	else
3768  	{
3769  		ec = nano::error_rpc::invalid_missing_type;
3770  	}
3771  	if (!ec && use_sink)
3772  	{
3773  		auto stat_tree_l (*static_cast<boost::property_tree::ptree *> (sink->to_object ()));
3774  		stat_tree_l.put ("stat_duration_seconds", node.stats.last_reset ().count ());
3775  		std::stringstream ostream;
3776  		boost::property_tree::write_json (ostream, stat_tree_l);
3777  		response (ostream.str ());
3778  	}
3779  	else
3780  	{
3781  		response_errors ();
3782  	}
3783  }
3784  void nano::json_handler::stats_clear ()
3785  {
3786  	node.stats.clear ();
3787  	response_l.put ("success", "");
3788  	std::stringstream ostream;
3789  	boost::property_tree::write_json (ostream, response_l);
3790  	response (ostream.str ());
3791  }
3792  void nano::json_handler::stop ()
3793  {
3794  	response_l.put ("success", "");
3795  	response_errors ();
3796  	if (!ec)
3797  	{
3798  		stop_callback ();
3799  	}
3800  }
3801  void nano::json_handler::telemetry ()
3802  {
3803  	auto address_text (request.get_optional<std::string> ("address"));
3804  	auto port_text (request.get_optional<std::string> ("port"));
3805  	if (address_text.is_initialized () || port_text.is_initialized ())
3806  	{
3807  		nano::endpoint endpoint{};
3808  		if (address_text.is_initialized () && port_text.is_initialized ())
3809  		{
3810  			uint16_t port;
3811  			if (!nano::parse_port (*port_text, port))
3812  			{
3813  				boost::asio::ip::address address;
3814  				if (!nano::parse_address (*address_text, address))
3815  				{
3816  					endpoint = { address, port };
3817  					if (address.is_loopback () && port == node.network.endpoint ().port ())
3818  					{
3819  						auto telemetry_data = node.local_telemetry ();
3820  						nano::jsonconfig config_l;
3821  						auto const should_ignore_identification_metrics = false;
3822  						auto err = telemetry_data.serialize_json (config_l, should_ignore_identification_metrics);
3823  						auto const & ptree = config_l.get_tree ();
3824  						if (!err)
3825  						{
3826  							response_l.insert (response_l.begin (), ptree.begin (), ptree.end ());
3827  						}
3828  						response_errors ();
3829  						return;
3830  					}
3831  				}
3832  				else
3833  				{
3834  					ec = nano::error_common::invalid_ip_address;
3835  				}
3836  			}
3837  			else
3838  			{
3839  				ec = nano::error_common::invalid_port;
3840  			}
3841  		}
3842  		else
3843  		{
3844  			ec = nano::error_rpc::requires_port_and_address;
3845  		}
3846  		if (!ec)
3847  		{
3848  			auto maybe_telemetry = node.telemetry.get_telemetry (nano::transport::map_endpoint_to_v6 (endpoint));
3849  			if (maybe_telemetry)
3850  			{
3851  				auto telemetry = *maybe_telemetry;
3852  				nano::jsonconfig config_l;
3853  				auto const should_ignore_identification_metrics = false;
3854  				auto err = telemetry.serialize_json (config_l, should_ignore_identification_metrics);
3855  				auto const & ptree = config_l.get_tree ();
3856  				if (!err)
3857  				{
3858  					response_l.insert (response_l.begin (), ptree.begin (), ptree.end ());
3859  				}
3860  				else
3861  				{
3862  					ec = nano::error_rpc::generic;
3863  				}
3864  			}
3865  			else
3866  			{
3867  				ec = nano::error_rpc::peer_not_found;
3868  			}
3869  			response_errors ();
3870  		}
3871  		else
3872  		{
3873  			response_errors ();
3874  		}
3875  	}
3876  	else
3877  	{
3878  		auto raw = request.get_optional<bool> ("raw");
3879  		auto output_raw = raw.value_or (false);
3880  		auto telemetry_responses = node.telemetry.get_all_telemetries ();
3881  		if (output_raw)
3882  		{
3883  			boost::property_tree::ptree metrics;
3884  			for (auto & telemetry_metrics : telemetry_responses)
3885  			{
3886  				nano::jsonconfig config_l;
3887  				auto const should_ignore_identification_metrics = false;
3888  				auto err = telemetry_metrics.second.serialize_json (config_l, should_ignore_identification_metrics);
3889  				config_l.put ("address", telemetry_metrics.first.address ());
3890  				config_l.put ("port", telemetry_metrics.first.port ());
3891  				if (!err)
3892  				{
3893  					metrics.push_back (std::make_pair ("", config_l.get_tree ()));
3894  				}
3895  				else
3896  				{
3897  					ec = nano::error_rpc::generic;
3898  				}
3899  			}
3900  			response_l.put_child ("metrics", metrics);
3901  		}
3902  		else
3903  		{
3904  			nano::jsonconfig config_l;
3905  			std::vector<nano::telemetry_data> telemetry_datas;
3906  			telemetry_datas.reserve (telemetry_responses.size ());
3907  			std::transform (telemetry_responses.begin (), telemetry_responses.end (), std::back_inserter (telemetry_datas), [] (auto const & endpoint_telemetry_data) {
3908  				return endpoint_telemetry_data.second;
3909  			});
3910  			auto average_telemetry_metrics = nano::consolidate_telemetry_data (telemetry_datas);
3911  			auto const should_ignore_identification_metrics = true;
3912  			auto err = average_telemetry_metrics.serialize_json (config_l, should_ignore_identification_metrics);
3913  			auto const & ptree = config_l.get_tree ();
3914  			if (!err)
3915  			{
3916  				response_l.insert (response_l.begin (), ptree.begin (), ptree.end ());
3917  			}
3918  			else
3919  			{
3920  				ec = nano::error_rpc::generic;
3921  			}
3922  		}
3923  		response_errors ();
3924  	}
3925  }
3926  void nano::json_handler::unchecked ()
3927  {
3928  	bool const json_block_l = request.get<bool> ("json_block", false);
3929  	auto count (count_optional_impl ());
3930  	if (!ec)
3931  	{
3932  		boost::property_tree::ptree unchecked;
3933  		node.unchecked.for_each (
3934  		[&unchecked, &json_block_l] (nano::unchecked_key const & key, nano::unchecked_info const & info) {
3935  			if (json_block_l)
3936  			{
3937  				boost::property_tree::ptree block_node_l;
3938  				info.block->serialize_json (block_node_l);
3939  				unchecked.add_child (info.block->hash ().to_string (), block_node_l);
3940  			}
3941  			else
3942  			{
3943  				std::string contents;
3944  				info.block->serialize_json (contents);
3945  				unchecked.put (info.block->hash ().to_string (), contents);
3946  			} }, [iterations = 0, count = count] () mutable { return iterations++ < count; });
3947  		response_l.add_child ("blocks", unchecked);
3948  	}
3949  	response_errors ();
3950  }
3951  void nano::json_handler::unchecked_clear ()
3952  {
3953  	node.workers.push_task (create_worker_task ([] (std::shared_ptr<nano::json_handler> const & rpc_l) {
3954  		rpc_l->node.unchecked.clear ();
3955  		rpc_l->response_l.put ("success", "");
3956  		rpc_l->response_errors ();
3957  	}));
3958  }
3959  void nano::json_handler::unchecked_get ()
3960  {
3961  	bool const json_block_l = request.get<bool> ("json_block", false);
3962  	auto hash (hash_impl ());
3963  	if (!ec)
3964  	{
3965  		bool done = false;
3966  		node.unchecked.for_each (
3967  		[&] (nano::unchecked_key const & key, nano::unchecked_info const & info) {
3968  			if (key.hash == hash)
3969  			{
3970  				response_l.put ("modified_timestamp", std::to_string (info.modified ()));
3971  				if (json_block_l)
3972  				{
3973  					boost::property_tree::ptree block_node_l;
3974  					info.block->serialize_json (block_node_l);
3975  					response_l.add_child ("contents", block_node_l);
3976  				}
3977  				else
3978  				{
3979  					std::string contents;
3980  					info.block->serialize_json (contents);
3981  					response_l.put ("contents", contents);
3982  				}
3983  				done = true;
3984  			} }, [&] () { return !done; });
3985  		if (response_l.empty ())
3986  		{
3987  			ec = nano::error_blocks::not_found;
3988  		}
3989  	}
3990  	response_errors ();
3991  }
3992  void nano::json_handler::unchecked_keys ()
3993  {
3994  	bool const json_block_l = request.get<bool> ("json_block", false);
3995  	auto count (count_optional_impl ());
3996  	nano::block_hash key (0);
3997  	boost::optional<std::string> hash_text (request.get_optional<std::string> ("key"));
3998  	if (!ec && hash_text.is_initialized ())
3999  	{
4000  		if (key.decode_hex (hash_text.get ()))
4001  		{
4002  			ec = nano::error_rpc::bad_key;
4003  		}
4004  	}
4005  	if (!ec)
4006  	{
4007  		boost::property_tree::ptree unchecked;
4008  		node.unchecked.for_each (
4009  		key,
4010  		[&unchecked, json_block_l] (nano::unchecked_key const & key, nano::unchecked_info const & info) {
4011  			boost::property_tree::ptree entry;
4012  			entry.put ("key", key.key ().to_string ());
4013  			entry.put ("hash", info.block->hash ().to_string ());
4014  			entry.put ("modified_timestamp", std::to_string (info.modified ()));
4015  			if (json_block_l)
4016  			{
4017  				boost::property_tree::ptree block_node_l;
4018  				info.block->serialize_json (block_node_l);
4019  				entry.add_child ("contents", block_node_l);
4020  			}
4021  			else
4022  			{
4023  				std::string contents;
4024  				info.block->serialize_json (contents);
4025  				entry.put ("contents", contents);
4026  			}
4027  			unchecked.push_back (std::make_pair ("", entry)); }, [&unchecked, &count] () { return unchecked.size () < count; });
4028  		response_l.add_child ("unchecked", unchecked);
4029  	}
4030  	response_errors ();
4031  }
4032  void nano::json_handler::unopened ()
4033  {
4034  	auto count (count_optional_impl ());
4035  	auto threshold (threshold_optional_impl ());
4036  	nano::account start (1); 
4037  	boost::optional<std::string> account_text (request.get_optional<std::string> ("account"));
4038  	if (account_text.is_initialized ())
4039  	{
4040  		start = account_impl (account_text.get ());
4041  	}
4042  	if (!ec)
4043  	{
4044  		auto transaction (node.store.tx_begin_read ());
4045  		auto iterator (node.store.pending.begin (transaction, nano::pending_key (start, 0)));
4046  		auto end (node.store.pending.end ());
4047  		nano::account current_account (start);
4048  		nano::uint128_t current_account_sum{ 0 };
4049  		boost::property_tree::ptree accounts;
4050  		while (iterator != end && accounts.size () < count)
4051  		{
4052  			nano::pending_key key (iterator->first);
4053  			nano::account account (key.account);
4054  			nano::pending_info info (iterator->second);
4055  			if (node.store.account.exists (transaction, account))
4056  			{
4057  				if (account.number () == std::numeric_limits<nano::uint256_t>::max ())
4058  				{
4059  					break;
4060  				}
4061  				iterator = node.store.pending.begin (transaction, nano::pending_key (account.number () + 1, 0));
4062  			}
4063  			else
4064  			{
4065  				if (account != current_account)
4066  				{
4067  					if (current_account_sum > 0)
4068  					{
4069  						if (current_account_sum >= threshold.number ())
4070  						{
4071  							accounts.put (current_account.to_account (), current_account_sum.convert_to<std::string> ());
4072  						}
4073  						current_account_sum = 0;
4074  					}
4075  					current_account = account;
4076  				}
4077  				current_account_sum += info.amount.number ();
4078  				++iterator;
4079  			}
4080  		}
4081  		if (accounts.size () < count && current_account_sum > 0 && current_account_sum >= threshold.number ())
4082  		{
4083  			accounts.put (current_account.to_account (), current_account_sum.convert_to<std::string> ());
4084  		}
4085  		response_l.add_child ("accounts", accounts);
4086  	}
4087  	response_errors ();
4088  }
4089  void nano::json_handler::uptime ()
4090  {
4091  	response_l.put ("seconds", std::chrono::duration_cast<std::chrono::seconds> (std::chrono::steady_clock::now () - node.startup_time).count ());
4092  	response_errors ();
4093  }
4094  void nano::json_handler::version ()
4095  {
4096  	response_l.put ("rpc_version", "1");
4097  	response_l.put ("store_version", std::to_string (node.store_version ()));
4098  	response_l.put ("protocol_version", std::to_string (node.network_params.network.protocol_version));
4099  	response_l.put ("node_vendor", boost::str (boost::format ("Nano %1%") % NANO_VERSION_STRING));
4100  	response_l.put ("store_vendor", node.store.vendor_get ());
4101  	response_l.put ("network", node.network_params.network.get_current_network_as_string ());
4102  	response_l.put ("network_identifier", node.network_params.ledger.genesis->hash ().to_string ());
4103  	response_l.put ("build_info", BUILD_INFO);
4104  	response_errors ();
4105  }
4106  void nano::json_handler::validate_account_number ()
4107  {
4108  	auto account (account_impl ());
4109  	(void)account;
4110  	response_l.put ("valid", ec ? "0" : "1");
4111  	ec = std::error_code (); 
4112  	response_errors ();
4113  }
4114  void nano::json_handler::wallet_add ()
4115  {
4116  	node.workers.push_task (create_worker_task ([] (std::shared_ptr<nano::json_handler> const & rpc_l) {
4117  		auto wallet (rpc_l->wallet_impl ());
4118  		if (!rpc_l->ec)
4119  		{
4120  			std::string key_text (rpc_l->request.get<std::string> ("key"));
4121  			nano::raw_key key;
4122  			if (!key.decode_hex (key_text))
4123  			{
4124  				bool const generate_work = rpc_l->request.get<bool> ("work", true);
4125  				auto pub (wallet->insert_adhoc (key, generate_work));
4126  				if (!pub.is_zero ())
4127  				{
4128  					rpc_l->response_l.put ("account", pub.to_account ());
4129  				}
4130  				else
4131  				{
4132  					rpc_l->ec = nano::error_common::wallet_locked;
4133  				}
4134  			}
4135  			else
4136  			{
4137  				rpc_l->ec = nano::error_common::bad_private_key;
4138  			}
4139  		}
4140  		rpc_l->response_errors ();
4141  	}));
4142  }
4143  void nano::json_handler::wallet_add_watch ()
4144  {
4145  	node.workers.push_task (create_worker_task ([] (std::shared_ptr<nano::json_handler> const & rpc_l) {
4146  		auto wallet (rpc_l->wallet_impl ());
4147  		if (!rpc_l->ec)
4148  		{
4149  			auto transaction (rpc_l->node.wallets.tx_begin_write ());
4150  			if (wallet->store.valid_password (transaction))
4151  			{
4152  				for (auto & accounts : rpc_l->request.get_child ("accounts"))
4153  				{
4154  					auto account (rpc_l->account_impl (accounts.second.data ()));
4155  					if (!rpc_l->ec)
4156  					{
4157  						if (wallet->insert_watch (transaction, account))
4158  						{
4159  							rpc_l->ec = nano::error_common::bad_public_key;
4160  						}
4161  					}
4162  				}
4163  				if (!rpc_l->ec)
4164  				{
4165  					rpc_l->response_l.put ("success", "");
4166  				}
4167  			}
4168  			else
4169  			{
4170  				rpc_l->ec = nano::error_common::wallet_locked;
4171  			}
4172  		}
4173  		rpc_l->response_errors ();
4174  	}));
4175  }
4176  void nano::json_handler::wallet_info ()
4177  {
4178  	auto wallet (wallet_impl ());
4179  	if (!ec)
4180  	{
4181  		nano::uint128_t balance (0);
4182  		nano::uint128_t receivable (0);
4183  		uint64_t count (0);
4184  		uint64_t block_count (0);
4185  		uint64_t cemented_block_count (0);
4186  		uint64_t deterministic_count (0);
4187  		uint64_t adhoc_count (0);
4188  		auto transaction (node.wallets.tx_begin_read ());
4189  		auto block_transaction (node.store.tx_begin_read ());
4190  		for (auto i (wallet->store.begin (transaction)), n (wallet->store.end ()); i != n; ++i)
4191  		{
4192  			nano::account const & account (i->first);
4193  			auto account_info = node.ledger.account_info (block_transaction, account);
4194  			if (account_info)
4195  			{
4196  				block_count += account_info->block_count;
4197  				balance += account_info->balance.number ();
4198  			}
4199  			nano::confirmation_height_info confirmation_info{};
4200  			if (!node.store.confirmation_height.get (block_transaction, account, confirmation_info))
4201  			{
4202  				cemented_block_count += confirmation_info.height;
4203  			}
4204  			receivable += node.ledger.account_receivable (block_transaction, account);
4205  			nano::key_type key_type (wallet->store.key_type (i->second));
4206  			if (key_type == nano::key_type::deterministic)
4207  			{
4208  				deterministic_count++;
4209  			}
4210  			else if (key_type == nano::key_type::adhoc)
4211  			{
4212  				adhoc_count++;
4213  			}
4214  			++count;
4215  		}
4216  		uint32_t deterministic_index (wallet->store.deterministic_index_get (transaction));
4217  		response_l.put ("balance", balance.convert_to<std::string> ());
4218  		response_l.put ("pending", receivable.convert_to<std::string> ());
4219  		response_l.put ("receivable", receivable.convert_to<std::string> ());
4220  		response_l.put ("accounts_count", std::to_string (count));
4221  		response_l.put ("accounts_block_count", std::to_string (block_count));
4222  		response_l.put ("accounts_cemented_block_count", std::to_string (cemented_block_count));
4223  		response_l.put ("deterministic_count", std::to_string (deterministic_count));
4224  		response_l.put ("adhoc_count", std::to_string (adhoc_count));
4225  		response_l.put ("deterministic_index", std::to_string (deterministic_index));
4226  	}
4227  	response_errors ();
4228  }
4229  void nano::json_handler::wallet_balances ()
4230  {
4231  	auto wallet (wallet_impl ());
4232  	auto threshold (threshold_optional_impl ());
4233  	if (!ec)
4234  	{
4235  		boost::property_tree::ptree balances;
4236  		auto transaction (node.wallets.tx_begin_read ());
4237  		auto block_transaction (node.store.tx_begin_read ());
4238  		for (auto i (wallet->store.begin (transaction)), n (wallet->store.end ()); i != n; ++i)
4239  		{
4240  			nano::account const & account (i->first);
4241  			nano::uint128_t balance = node.ledger.account_balance (block_transaction, account);
4242  			if (balance >= threshold.number ())
4243  			{
4244  				boost::property_tree::ptree entry;
4245  				nano::uint128_t receivable = node.ledger.account_receivable (block_transaction, account);
4246  				entry.put ("balance", balance.convert_to<std::string> ());
4247  				entry.put ("pending", receivable.convert_to<std::string> ());
4248  				entry.put ("receivable", receivable.convert_to<std::string> ());
4249  				balances.push_back (std::make_pair (account.to_account (), entry));
4250  			}
4251  		}
4252  		response_l.add_child ("balances", balances);
4253  	}
4254  	response_errors ();
4255  }
4256  void nano::json_handler::wallet_change_seed ()
4257  {
4258  	node.workers.push_task (create_worker_task ([] (std::shared_ptr<nano::json_handler> const & rpc_l) {
4259  		auto wallet (rpc_l->wallet_impl ());
4260  		if (!rpc_l->ec)
4261  		{
4262  			std::string seed_text (rpc_l->request.get<std::string> ("seed"));
4263  			nano::raw_key seed;
4264  			if (!seed.decode_hex (seed_text))
4265  			{
4266  				auto count (static_cast<uint32_t> (rpc_l->count_optional_impl (0)));
4267  				auto transaction (rpc_l->node.wallets.tx_begin_write ());
4268  				if (wallet->store.valid_password (transaction))
4269  				{
4270  					nano::public_key account (wallet->change_seed (transaction, seed, count));
4271  					rpc_l->response_l.put ("success", "");
4272  					rpc_l->response_l.put ("last_restored_account", account.to_account ());
4273  					auto index (wallet->store.deterministic_index_get (transaction));
4274  					debug_assert (index > 0);
4275  					rpc_l->response_l.put ("restored_count", std::to_string (index));
4276  				}
4277  				else
4278  				{
4279  					rpc_l->ec = nano::error_common::wallet_locked;
4280  				}
4281  			}
4282  			else
4283  			{
4284  				rpc_l->ec = nano::error_common::bad_seed;
4285  			}
4286  		}
4287  		rpc_l->response_errors ();
4288  	}));
4289  }
4290  void nano::json_handler::wallet_contains ()
4291  {
4292  	auto account (account_impl ());
4293  	auto wallet (wallet_impl ());
4294  	if (!ec)
4295  	{
4296  		auto transaction (node.wallets.tx_begin_read ());
4297  		auto exists (wallet->store.find (transaction, account) != wallet->store.end ());
4298  		response_l.put ("exists", exists ? "1" : "0");
4299  	}
4300  	response_errors ();
4301  }
4302  void nano::json_handler::wallet_create ()
4303  {
4304  	node.workers.push_task (create_worker_task ([] (std::shared_ptr<nano::json_handler> const & rpc_l) {
4305  		nano::raw_key seed;
4306  		auto seed_text (rpc_l->request.get_optional<std::string> ("seed"));
4307  		if (seed_text.is_initialized () && seed.decode_hex (seed_text.get ()))
4308  		{
4309  			rpc_l->ec = nano::error_common::bad_seed;
4310  		}
4311  		if (!rpc_l->ec)
4312  		{
4313  			auto wallet_id = random_wallet_id ();
4314  			auto wallet (rpc_l->node.wallets.create (wallet_id));
4315  			auto existing (rpc_l->node.wallets.items.find (wallet_id));
4316  			if (existing != rpc_l->node.wallets.items.end ())
4317  			{
4318  				rpc_l->response_l.put ("wallet", wallet_id.to_string ());
4319  			}
4320  			else
4321  			{
4322  				rpc_l->ec = nano::error_common::wallet_lmdb_max_dbs;
4323  			}
4324  			if (!rpc_l->ec && seed_text.is_initialized ())
4325  			{
4326  				auto transaction (rpc_l->node.wallets.tx_begin_write ());
4327  				nano::public_key account (wallet->change_seed (transaction, seed));
4328  				rpc_l->response_l.put ("last_restored_account", account.to_account ());
4329  				auto index (wallet->store.deterministic_index_get (transaction));
4330  				debug_assert (index > 0);
4331  				rpc_l->response_l.put ("restored_count", std::to_string (index));
4332  			}
4333  		}
4334  		rpc_l->response_errors ();
4335  	}));
4336  }
4337  void nano::json_handler::wallet_destroy ()
4338  {
4339  	node.workers.push_task (create_worker_task ([] (std::shared_ptr<nano::json_handler> const & rpc_l) {
4340  		std::string wallet_text (rpc_l->request.get<std::string> ("wallet"));
4341  		nano::wallet_id wallet;
4342  		if (!wallet.decode_hex (wallet_text))
4343  		{
4344  			auto existing (rpc_l->node.wallets.items.find (wallet));
4345  			if (existing != rpc_l->node.wallets.items.end ())
4346  			{
4347  				rpc_l->node.wallets.destroy (wallet);
4348  				bool destroyed (rpc_l->node.wallets.items.find (wallet) == rpc_l->node.wallets.items.end ());
4349  				rpc_l->response_l.put ("destroyed", destroyed ? "1" : "0");
4350  			}
4351  			else
4352  			{
4353  				rpc_l->ec = nano::error_common::wallet_not_found;
4354  			}
4355  		}
4356  		else
4357  		{
4358  			rpc_l->ec = nano::error_common::bad_wallet_number;
4359  		}
4360  		rpc_l->response_errors ();
4361  	}));
4362  }
4363  void nano::json_handler::wallet_export ()
4364  {
4365  	auto wallet (wallet_impl ());
4366  	if (!ec)
4367  	{
4368  		auto transaction (node.wallets.tx_begin_read ());
4369  		std::string json;
4370  		wallet->store.serialize_json (transaction, json);
4371  		response_l.put ("json", json);
4372  	}
4373  	response_errors ();
4374  }
4375  void nano::json_handler::wallet_frontiers ()
4376  {
4377  	auto wallet (wallet_impl ());
4378  	if (!ec)
4379  	{
4380  		boost::property_tree::ptree frontiers;
4381  		auto transaction (node.wallets.tx_begin_read ());
4382  		auto block_transaction (node.store.tx_begin_read ());
4383  		for (auto i (wallet->store.begin (transaction)), n (wallet->store.end ()); i != n; ++i)
4384  		{
4385  			nano::account const & account (i->first);
4386  			auto latest (node.ledger.latest (block_transaction, account));
4387  			if (!latest.is_zero ())
4388  			{
4389  				frontiers.put (account.to_account (), latest.to_string ());
4390  			}
4391  		}
4392  		response_l.add_child ("frontiers", frontiers);
4393  	}
4394  	response_errors ();
4395  }
4396  void nano::json_handler::wallet_history ()
4397  {
4398  	uint64_t modified_since (1);
4399  	boost::optional<std::string> modified_since_text (request.get_optional<std::string> ("modified_since"));
4400  	if (modified_since_text.is_initialized ())
4401  	{
4402  		if (decode_unsigned (modified_since_text.get (), modified_since))
4403  		{
4404  			ec = nano::error_rpc::invalid_timestamp;
4405  		}
4406  	}
4407  	auto wallet (wallet_impl ());
4408  	if (!ec)
4409  	{
4410  		std::multimap<uint64_t, boost::property_tree::ptree, std::greater<uint64_t>> entries;
4411  		auto transaction (node.wallets.tx_begin_read ());
4412  		auto block_transaction (node.store.tx_begin_read ());
4413  		for (auto i (wallet->store.begin (transaction)), n (wallet->store.end ()); i != n; ++i)
4414  		{
4415  			nano::account const & account (i->first);
4416  			auto info = node.ledger.account_info (block_transaction, account);
4417  			if (info)
4418  			{
4419  				auto timestamp (info->modified);
4420  				auto hash (info->head);
4421  				while (timestamp >= modified_since && !hash.is_zero ())
4422  				{
4423  					auto block (node.store.block.get (block_transaction, hash));
4424  					timestamp = block->sideband ().timestamp;
4425  					if (block != nullptr && timestamp >= modified_since)
4426  					{
4427  						boost::property_tree::ptree entry;
4428  						std::vector<nano::public_key> no_filter;
4429  						history_visitor visitor (*this, false, block_transaction, entry, hash, no_filter);
4430  						block->visit (visitor);
4431  						if (!entry.empty ())
4432  						{
4433  							entry.put ("block_account", account.to_account ());
4434  							entry.put ("hash", hash.to_string ());
4435  							entry.put ("local_timestamp", std::to_string (timestamp));
4436  							entries.insert (std::make_pair (timestamp, entry));
4437  						}
4438  						hash = block->previous ();
4439  					}
4440  					else
4441  					{
4442  						hash.clear ();
4443  					}
4444  				}
4445  			}
4446  		}
4447  		boost::property_tree::ptree history;
4448  		for (auto i (entries.begin ()), n (entries.end ()); i != n; ++i)
4449  		{
4450  			history.push_back (std::make_pair ("", i->second));
4451  		}
4452  		response_l.add_child ("history", history);
4453  	}
4454  	response_errors ();
4455  }
4456  void nano::json_handler::wallet_key_valid ()
4457  {
4458  	auto wallet (wallet_impl ());
4459  	if (!ec)
4460  	{
4461  		auto transaction (node.wallets.tx_begin_read ());
4462  		auto valid (wallet->store.valid_password (transaction));
4463  		response_l.put ("valid", valid ? "1" : "0");
4464  	}
4465  	response_errors ();
4466  }
4467  void nano::json_handler::wallet_ledger ()
4468  {
4469  	bool const representative = request.get<bool> ("representative", false);
4470  	bool const weight = request.get<bool> ("weight", false);
4471  	bool const pending = request.get<bool> ("pending", false);
4472  	bool const receivable = request.get<bool> ("receivable", pending);
4473  	uint64_t modified_since (0);
4474  	boost::optional<std::string> modified_since_text (request.get_optional<std::string> ("modified_since"));
4475  	if (modified_since_text.is_initialized ())
4476  	{
4477  		modified_since = strtoul (modified_since_text.get ().c_str (), NULL, 10);
4478  	}
4479  	auto wallet (wallet_impl ());
4480  	if (!ec)
4481  	{
4482  		boost::property_tree::ptree accounts;
4483  		auto transaction (node.wallets.tx_begin_read ());
4484  		auto block_transaction (node.store.tx_begin_read ());
4485  		for (auto i (wallet->store.begin (transaction)), n (wallet->store.end ()); i != n; ++i)
4486  		{
4487  			nano::account const & account (i->first);
4488  			auto info = node.ledger.account_info (block_transaction, account);
4489  			if (info)
4490  			{
4491  				if (info->modified >= modified_since)
4492  				{
4493  					boost::property_tree::ptree entry;
4494  					entry.put ("frontier", info->head.to_string ());
4495  					entry.put ("open_block", info->open_block.to_string ());
4496  					entry.put ("representative_block", node.ledger.representative (block_transaction, info->head).to_string ());
4497  					std::string balance;
4498  					nano::uint128_union (info->balance).encode_dec (balance);
4499  					entry.put ("balance", balance);
4500  					entry.put ("modified_timestamp", std::to_string (info->modified));
4501  					entry.put ("block_count", std::to_string (info->block_count));
4502  					if (representative)
4503  					{
4504  						entry.put ("representative", info->representative.to_account ());
4505  					}
4506  					if (weight)
4507  					{
4508  						auto account_weight (node.ledger.weight (account));
4509  						entry.put ("weight", account_weight.convert_to<std::string> ());
4510  					}
4511  					if (receivable)
4512  					{
4513  						auto account_receivable (node.ledger.account_receivable (block_transaction, account));
4514  						entry.put ("pending", account_receivable.convert_to<std::string> ());
4515  						entry.put ("receivable", account_receivable.convert_to<std::string> ());
4516  					}
4517  					accounts.push_back (std::make_pair (account.to_account (), entry));
4518  				}
4519  			}
4520  		}
4521  		response_l.add_child ("accounts", accounts);
4522  	}
4523  	response_errors ();
4524  }
4525  void nano::json_handler::wallet_lock ()
4526  {
4527  	auto wallet (wallet_impl ());
4528  	if (!ec)
4529  	{
4530  		nano::raw_key empty;
4531  		empty.clear ();
4532  		wallet->store.password.value_set (empty);
4533  		response_l.put ("locked", "1");
4534  		node.logger.try_log ("Wallet locked");
4535  	}
4536  	response_errors ();
4537  }
4538  void nano::json_handler::wallet_pending ()
4539  {
4540  	response_l.put ("deprecated", "1");
4541  	wallet_receivable ();
4542  }
4543  void nano::json_handler::wallet_receivable ()
4544  {
4545  	auto wallet (wallet_impl ());
4546  	auto count (count_optional_impl ());
4547  	auto threshold (threshold_optional_impl ());
4548  	bool const source = request.get<bool> ("source", false);
4549  	bool const min_version = request.get<bool> ("min_version", false);
4550  	bool const include_active = request.get<bool> ("include_active", false);
4551  	bool const include_only_confirmed = request.get<bool> ("include_only_confirmed", true);
4552  	if (!ec)
4553  	{
4554  		boost::property_tree::ptree pending;
4555  		auto transaction (node.wallets.tx_begin_read ());
4556  		auto block_transaction (node.store.tx_begin_read ());
4557  		for (auto i (wallet->store.begin (transaction)), n (wallet->store.end ()); i != n; ++i)
4558  		{
4559  			nano::account const & account (i->first);
4560  			boost::property_tree::ptree peers_l;
4561  			for (auto ii (node.store.pending.begin (block_transaction, nano::pending_key (account, 0))), nn (node.store.pending.end ()); ii != nn && nano::pending_key (ii->first).account == account && peers_l.size () < count; ++ii)
4562  			{
4563  				nano::pending_key key (ii->first);
4564  				if (block_confirmed (node, block_transaction, key.hash, include_active, include_only_confirmed))
4565  				{
4566  					if (threshold.is_zero () && !source)
4567  					{
4568  						boost::property_tree::ptree entry;
4569  						entry.put ("", key.hash.to_string ());
4570  						peers_l.push_back (std::make_pair ("", entry));
4571  					}
4572  					else
4573  					{
4574  						nano::pending_info info (ii->second);
4575  						if (info.amount.number () >= threshold.number ())
4576  						{
4577  							if (source || min_version)
4578  							{
4579  								boost::property_tree::ptree pending_tree;
4580  								pending_tree.put ("amount", info.amount.number ().convert_to<std::string> ());
4581  								if (source)
4582  								{
4583  									pending_tree.put ("source", info.source.to_account ());
4584  								}
4585  								if (min_version)
4586  								{
4587  									pending_tree.put ("min_version", epoch_as_string (info.epoch));
4588  								}
4589  								peers_l.add_child (key.hash.to_string (), pending_tree);
4590  							}
4591  							else
4592  							{
4593  								peers_l.put (key.hash.to_string (), info.amount.number ().convert_to<std::string> ());
4594  							}
4595  						}
4596  					}
4597  				}
4598  			}
4599  			if (!peers_l.empty ())
4600  			{
4601  				pending.add_child (account.to_account (), peers_l);
4602  			}
4603  		}
4604  		response_l.add_child ("blocks", pending);
4605  	}
4606  	response_errors ();
4607  }
4608  void nano::json_handler::wallet_representative ()
4609  {
4610  	auto wallet (wallet_impl ());
4611  	if (!ec)
4612  	{
4613  		auto transaction (node.wallets.tx_begin_read ());
4614  		response_l.put ("representative", wallet->store.representative (transaction).to_account ());
4615  	}
4616  	response_errors ();
4617  }
4618  void nano::json_handler::wallet_representative_set ()
4619  {
4620  	node.workers.push_task (create_worker_task ([] (std::shared_ptr<nano::json_handler> const & rpc_l) {
4621  		auto wallet (rpc_l->wallet_impl ());
4622  		std::string representative_text (rpc_l->request.get<std::string> ("representative"));
4623  		auto representative (rpc_l->account_impl (representative_text, nano::error_rpc::bad_representative_number));
4624  		if (!rpc_l->ec)
4625  		{
4626  			bool update_existing_accounts (rpc_l->request.get<bool> ("update_existing_accounts", false));
4627  			{
4628  				auto transaction (rpc_l->node.wallets.tx_begin_write ());
4629  				if (wallet->store.valid_password (transaction) || !update_existing_accounts)
4630  				{
4631  					wallet->store.representative_set (transaction, representative);
4632  					rpc_l->response_l.put ("set", "1");
4633  				}
4634  				else
4635  				{
4636  					rpc_l->ec = nano::error_common::wallet_locked;
4637  				}
4638  			}
4639  			if (!rpc_l->ec && update_existing_accounts)
4640  			{
4641  				std::vector<nano::account> accounts;
4642  				{
4643  					auto transaction (rpc_l->node.wallets.tx_begin_read ());
4644  					auto block_transaction (rpc_l->node.store.tx_begin_read ());
4645  					for (auto i (wallet->store.begin (transaction)), n (wallet->store.end ()); i != n; ++i)
4646  					{
4647  						nano::account const & account (i->first);
4648  						auto info = rpc_l->node.ledger.account_info (block_transaction, account);
4649  						if (info)
4650  						{
4651  							if (info->representative != representative)
4652  							{
4653  								accounts.push_back (account);
4654  							}
4655  						}
4656  					}
4657  				}
4658  				for (auto & account : accounts)
4659  				{
4660  					wallet->change_async (
4661  					account, representative, [] (std::shared_ptr<nano::block> const &) {}, 0, false);
4662  				}
4663  			}
4664  		}
4665  		rpc_l->response_errors ();
4666  	}));
4667  }
4668  void nano::json_handler::wallet_republish ()
4669  {
4670  	auto wallet (wallet_impl ());
4671  	auto count (count_impl ());
4672  	if (!ec)
4673  	{
4674  		boost::property_tree::ptree blocks;
4675  		std::deque<std::shared_ptr<nano::block>> republish_bundle;
4676  		auto transaction (node.wallets.tx_begin_read ());
4677  		auto block_transaction (node.store.tx_begin_read ());
4678  		for (auto i (wallet->store.begin (transaction)), n (wallet->store.end ()); i != n; ++i)
4679  		{
4680  			nano::account const & account (i->first);
4681  			auto latest (node.ledger.latest (block_transaction, account));
4682  			std::shared_ptr<nano::block> block;
4683  			std::vector<nano::block_hash> hashes;
4684  			while (!latest.is_zero () && hashes.size () < count)
4685  			{
4686  				hashes.push_back (latest);
4687  				block = node.store.block.get (block_transaction, latest);
4688  				if (block != nullptr)
4689  				{
4690  					latest = block->previous ();
4691  				}
4692  				else
4693  				{
4694  					latest.clear ();
4695  				}
4696  			}
4697  			std::reverse (hashes.begin (), hashes.end ());
4698  			for (auto & hash : hashes)
4699  			{
4700  				block = node.store.block.get (block_transaction, hash);
4701  				republish_bundle.push_back (std::move (block));
4702  				boost::property_tree::ptree entry;
4703  				entry.put ("", hash.to_string ());
4704  				blocks.push_back (std::make_pair ("", entry));
4705  			}
4706  		}
4707  		node.network.flood_block_many (std::move (republish_bundle), nullptr, 25);
4708  		response_l.add_child ("blocks", blocks);
4709  	}
4710  	response_errors ();
4711  }
4712  void nano::json_handler::wallet_seed ()
4713  {
4714  	auto wallet (wallet_impl ());
4715  	if (!ec)
4716  	{
4717  		auto transaction (node.wallets.tx_begin_read ());
4718  		if (wallet->store.valid_password (transaction))
4719  		{
4720  			nano::raw_key seed;
4721  			wallet->store.seed (seed, transaction);
4722  			response_l.put ("seed", seed.to_string ());
4723  		}
4724  		else
4725  		{
4726  			ec = nano::error_common::wallet_locked;
4727  		}
4728  	}
4729  	response_errors ();
4730  }
4731  void nano::json_handler::wallet_work_get ()
4732  {
4733  	auto wallet (wallet_impl ());
4734  	if (!ec)
4735  	{
4736  		boost::property_tree::ptree works;
4737  		auto transaction (node.wallets.tx_begin_read ());
4738  		for (auto i (wallet->store.begin (transaction)), n (wallet->store.end ()); i != n; ++i)
4739  		{
4740  			nano::account const & account (i->first);
4741  			uint64_t work (0);
4742  			auto error_work (wallet->store.work_get (transaction, account, work));
4743  			(void)error_work;
4744  			works.put (account.to_account (), nano::to_string_hex (work));
4745  		}
4746  		response_l.add_child ("works", works);
4747  	}
4748  	response_errors ();
4749  }
4750  void nano::json_handler::work_generate ()
4751  {
4752  	boost::optional<nano::account> account;
4753  	auto account_opt (request.get_optional<std::string> ("account"));
4754  	auto work_version (work_version_optional_impl (nano::work_version::work_1));
4755  	if (!ec && account_opt.is_initialized ())
4756  	{
4757  		account = account_impl (account_opt.get ());
4758  	}
4759  	if (!ec)
4760  	{
4761  		auto hash (hash_impl ());
4762  		auto difficulty (difficulty_optional_impl (work_version));
4763  		multiplier_optional_impl (work_version, difficulty);
4764  		if (!ec && (difficulty > node.max_work_generate_difficulty (work_version) || difficulty < node.network_params.work.threshold_entry (work_version, nano::block_type::state)))
4765  		{
4766  			ec = nano::error_rpc::difficulty_limit;
4767  		}
4768  		std::shared_ptr<nano::block> block;
4769  		if (!ec && request.count ("block"))
4770  		{
4771  			block = block_impl (true);
4772  			if (block != nullptr)
4773  			{
4774  				if (hash != block->root ().as_block_hash ())
4775  				{
4776  					ec = nano::error_rpc::block_root_mismatch;
4777  				}
4778  				if (request.count ("version") == 0)
4779  				{
4780  					work_version = block->work_version ();
4781  				}
4782  				else if (!ec && work_version != block->work_version ())
4783  				{
4784  					ec = nano::error_rpc::block_work_version_mismatch;
4785  				}
4786  				if (!ec && request.count ("difficulty") == 0 && request.count ("multiplier") == 0)
4787  				{
4788  					difficulty = difficulty_ledger (*block);
4789  				}
4790  				if (!ec && node.network_params.work.difficulty (*block) >= difficulty)
4791  				{
4792  					ec = nano::error_rpc::block_work_enough;
4793  				}
4794  			}
4795  		}
4796  		if (!ec && response_l.empty ())
4797  		{
4798  			auto use_peers (request.get<bool> ("use_peers", false));
4799  			auto rpc_l (shared_from_this ());
4800  			auto callback = [rpc_l, hash, work_version, this] (boost::optional<uint64_t> const & work_a) {
4801  				if (work_a)
4802  				{
4803  					boost::property_tree::ptree response_l;
4804  					response_l.put ("hash", hash.to_string ());
4805  					uint64_t work (work_a.value ());
4806  					response_l.put ("work", nano::to_string_hex (work));
4807  					std::stringstream ostream;
4808  					auto result_difficulty (rpc_l->node.network_params.work.difficulty (work_version, hash, work));
4809  					response_l.put ("difficulty", nano::to_string_hex (result_difficulty));
4810  					auto result_multiplier = nano::difficulty::to_multiplier (result_difficulty, node.default_difficulty (work_version));
4811  					response_l.put ("multiplier", nano::to_string (result_multiplier));
4812  					boost::property_tree::write_json (ostream, response_l);
4813  					rpc_l->response (ostream.str ());
4814  				}
4815  				else
4816  				{
4817  					json_error_response (rpc_l->response, "Cancelled");
4818  				}
4819  			};
4820  			if (!use_peers)
4821  			{
4822  				if (node.local_work_generation_enabled ())
4823  				{
4824  					auto error = node.distributed_work.make (work_version, hash, {}, difficulty, callback, {});
4825  					if (error)
4826  					{
4827  						ec = nano::error_common::failure_work_generation;
4828  					}
4829  				}
4830  				else
4831  				{
4832  					ec = nano::error_common::disabled_local_work_generation;
4833  				}
4834  			}
4835  			else
4836  			{
4837  				if (!account_opt.is_initialized ())
4838  				{
4839  					auto transaction_l (node.store.tx_begin_read ());
4840  					if (node.store.block.exists (transaction_l, hash))
4841  					{
4842  						account = node.store.block.account (transaction_l, hash);
4843  					}
4844  				}
4845  				auto secondary_work_peers_l (request.get<bool> ("secondary_work_peers", false));
4846  				auto const & peers_l (secondary_work_peers_l ? node.config.secondary_work_peers : node.config.work_peers);
4847  				if (node.work_generation_enabled (peers_l))
4848  				{
4849  					node.work_generate (work_version, hash, difficulty, callback, account, secondary_work_peers_l);
4850  				}
4851  				else
4852  				{
4853  					ec = nano::error_common::disabled_work_generation;
4854  				}
4855  			}
4856  		}
4857  	}
4858  	if (ec)
4859  	{
4860  		response_errors ();
4861  	}
4862  }
4863  void nano::json_handler::work_cancel ()
4864  {
4865  	auto hash (hash_impl ());
4866  	if (!ec)
4867  	{
4868  		node.observers.work_cancel.notify (hash);
4869  		response_l.put ("success", "");
4870  	}
4871  	response_errors ();
4872  }
4873  void nano::json_handler::work_get ()
4874  {
4875  	auto wallet (wallet_impl ());
4876  	auto account (account_impl ());
4877  	if (!ec)
4878  	{
4879  		auto transaction (node.wallets.tx_begin_read ());
4880  		wallet_account_impl (transaction, wallet, account);
4881  		if (!ec)
4882  		{
4883  			uint64_t work (0);
4884  			auto error_work (wallet->store.work_get (transaction, account, work));
4885  			(void)error_work;
4886  			response_l.put ("work", nano::to_string_hex (work));
4887  		}
4888  	}
4889  	response_errors ();
4890  }
4891  void nano::json_handler::work_set ()
4892  {
4893  	node.workers.push_task (create_worker_task ([] (std::shared_ptr<nano::json_handler> const & rpc_l) {
4894  		auto wallet (rpc_l->wallet_impl ());
4895  		auto account (rpc_l->account_impl ());
4896  		auto work (rpc_l->work_optional_impl ());
4897  		if (!rpc_l->ec)
4898  		{
4899  			auto transaction (rpc_l->node.wallets.tx_begin_write ());
4900  			rpc_l->wallet_account_impl (transaction, wallet, account);
4901  			if (!rpc_l->ec)
4902  			{
4903  				wallet->store.work_put (transaction, account, work);
4904  				rpc_l->response_l.put ("success", "");
4905  			}
4906  		}
4907  		rpc_l->response_errors ();
4908  	}));
4909  }
4910  void nano::json_handler::work_validate ()
4911  {
4912  	auto hash (hash_impl ());
4913  	auto work (work_optional_impl ());
4914  	auto work_version (work_version_optional_impl (nano::work_version::work_1));
4915  	auto difficulty (difficulty_optional_impl (work_version));
4916  	multiplier_optional_impl (work_version, difficulty);
4917  	if (!ec)
4918  	{
4919  		auto result_difficulty (node.network_params.work.difficulty (work_version, hash, work));
4920  		if (request.count ("difficulty"))
4921  		{
4922  			response_l.put ("valid", (result_difficulty >= difficulty) ? "1" : "0");
4923  		}
4924  		response_l.put ("valid_all", (result_difficulty >= node.default_difficulty (work_version)) ? "1" : "0");
4925  		response_l.put ("valid_receive", (result_difficulty >= node.network_params.work.threshold (work_version, nano::block_details (nano::epoch::epoch_2, false, true, false))) ? "1" : "0");
4926  		response_l.put ("difficulty", nano::to_string_hex (result_difficulty));
4927  		auto result_multiplier = nano::difficulty::to_multiplier (result_difficulty, node.default_difficulty (work_version));
4928  		response_l.put ("multiplier", nano::to_string (result_multiplier));
4929  	}
4930  	response_errors ();
4931  }
4932  void nano::json_handler::work_peer_add ()
4933  {
4934  	std::string address_text = request.get<std::string> ("address");
4935  	std::string port_text = request.get<std::string> ("port");
4936  	uint16_t port;
4937  	if (!nano::parse_port (port_text, port))
4938  	{
4939  		node.config.work_peers.push_back (std::make_pair (address_text, port));
4940  		response_l.put ("success", "");
4941  	}
4942  	else
4943  	{
4944  		ec = nano::error_common::invalid_port;
4945  	}
4946  	response_errors ();
4947  }
4948  void nano::json_handler::work_peers ()
4949  {
4950  	boost::property_tree::ptree work_peers_l;
4951  	for (auto i (node.config.work_peers.begin ()), n (node.config.work_peers.end ()); i != n; ++i)
4952  	{
4953  		boost::property_tree::ptree entry;
4954  		entry.put ("", boost::str (boost::format ("%1%:%2%") % i->first % i->second));
4955  		work_peers_l.push_back (std::make_pair ("", entry));
4956  	}
4957  	response_l.add_child ("work_peers", work_peers_l);
4958  	response_errors ();
4959  }
4960  void nano::json_handler::work_peers_clear ()
4961  {
4962  	node.config.work_peers.clear ();
4963  	response_l.put ("success", "");
4964  	response_errors ();
4965  }
4966  void nano::json_handler::populate_backlog ()
4967  {
4968  	node.backlog.trigger ();
4969  	response_l.put ("success", "");
4970  	response_errors ();
4971  }
4972  void nano::json_handler::debug_bootstrap_priority_info ()
4973  {
4974  	if (!ec)
4975  	{
4976  		auto [blocking, priorities] = node.ascendboot.info ();
4977  		{
4978  			boost::property_tree::ptree response_priorities;
4979  			for (auto const & entry : priorities)
4980  			{
4981  				const auto account = entry.account;
4982  				const auto priority = entry.priority;
4983  				response_priorities.put (account.to_account (), priority);
4984  			}
4985  			response_l.add_child ("priorities", response_priorities);
4986  		}
4987  		{
4988  			boost::property_tree::ptree response_blocking;
4989  			for (auto const & entry : blocking)
4990  			{
4991  				const auto account = entry.account;
4992  				const auto dependency = entry.dependency;
4993  				response_blocking.put (account.to_account (), dependency.to_string ());
4994  			}
4995  			response_l.add_child ("blocking", response_blocking);
4996  		}
4997  	}
4998  	response_errors ();
4999  }
5000  void nano::inprocess_rpc_handler::process_request (std::string const &, std::string const & body_a, std::function<void (std::string const &)> response_a)
5001  {
5002  	auto handler (std::make_shared<nano::json_handler> (node, node_rpc_config, body_a, response_a, [this] () {
5003  		this->stop_callback ();
5004  		this->stop ();
5005  	}));
5006  	handler->process_request ();
5007  }
5008  void nano::inprocess_rpc_handler::process_request_v2 (rpc_handler_request_params const & params_a, std::string const & body_a, std::function<void (std::shared_ptr<std::string> const &)> response_a)
5009  {
5010  	std::string body_l = params_a.json_envelope (body_a);
5011  	auto handler (std::make_shared<nano::ipc::flatbuffers_handler> (node, ipc_server, nullptr, node.config.ipc_config));
5012  	handler->process_json (reinterpret_cast<uint8_t const *> (body_l.data ()), body_l.size (), response_a);
5013  }
5014  namespace
5015  {
5016  void construct_json (nano::container_info_component * component, boost::property_tree::ptree & parent)
5017  {
5018  	if (!component->is_composite ())
5019  	{
5020  		auto & leaf_info = static_cast<nano::container_info_leaf *> (component)->get_info ();
5021  		boost::property_tree::ptree child;
5022  		child.put ("count", leaf_info.count);
5023  		child.put ("size", leaf_info.count * leaf_info.sizeof_element);
5024  		parent.add_child (leaf_info.name, child);
5025  		return;
5026  	}
5027  	auto composite = static_cast<nano::container_info_composite *> (component);
5028  	boost::property_tree::ptree current;
5029  	for (auto & child : composite->get_children ())
5030  	{
5031  		construct_json (child.get (), current);
5032  	}
5033  	parent.add_child (composite->get_name (), current);
5034  }
5035  ipc_json_handler_no_arg_func_map create_ipc_json_handler_no_arg_func_map ()
5036  {
5037  	ipc_json_handler_no_arg_func_map no_arg_funcs;
5038  	no_arg_funcs.emplace ("account_balance", &nano::json_handler::account_balance);
5039  	no_arg_funcs.emplace ("account_block_count", &nano::json_handler::account_block_count);
5040  	no_arg_funcs.emplace ("account_count", &nano::json_handler::account_count);
5041  	no_arg_funcs.emplace ("account_create", &nano::json_handler::account_create);
5042  	no_arg_funcs.emplace ("account_get", &nano::json_handler::account_get);
5043  	no_arg_funcs.emplace ("account_history", &nano::json_handler::account_history);
5044  	no_arg_funcs.emplace ("account_info", &nano::json_handler::account_info);
5045  	no_arg_funcs.emplace ("account_key", &nano::json_handler::account_key);
5046  	no_arg_funcs.emplace ("account_list", &nano::json_handler::account_list);
5047  	no_arg_funcs.emplace ("account_move", &nano::json_handler::account_move);
5048  	no_arg_funcs.emplace ("account_remove", &nano::json_handler::account_remove);
5049  	no_arg_funcs.emplace ("account_representative", &nano::json_handler::account_representative);
5050  	no_arg_funcs.emplace ("account_representative_set", &nano::json_handler::account_representative_set);
5051  	no_arg_funcs.emplace ("account_weight", &nano::json_handler::account_weight);
5052  	no_arg_funcs.emplace ("accounts_balances", &nano::json_handler::accounts_balances);
5053  	no_arg_funcs.emplace ("accounts_representatives", &nano::json_handler::accounts_representatives);
5054  	no_arg_funcs.emplace ("accounts_create", &nano::json_handler::accounts_create);
5055  	no_arg_funcs.emplace ("accounts_frontiers", &nano::json_handler::accounts_frontiers);
5056  	no_arg_funcs.emplace ("accounts_pending", &nano::json_handler::accounts_pending);
5057  	no_arg_funcs.emplace ("accounts_receivable", &nano::json_handler::accounts_receivable);
5058  	no_arg_funcs.emplace ("active_difficulty", &nano::json_handler::active_difficulty);
5059  	no_arg_funcs.emplace ("available_supply", &nano::json_handler::available_supply);
5060  	no_arg_funcs.emplace ("block_info", &nano::json_handler::block_info);
5061  	no_arg_funcs.emplace ("block", &nano::json_handler::block_info);
5062  	no_arg_funcs.emplace ("block_confirm", &nano::json_handler::block_confirm);
5063  	no_arg_funcs.emplace ("blocks", &nano::json_handler::blocks);
5064  	no_arg_funcs.emplace ("blocks_info", &nano::json_handler::blocks_info);
5065  	no_arg_funcs.emplace ("block_account", &nano::json_handler::block_account);
5066  	no_arg_funcs.emplace ("block_count", &nano::json_handler::block_count);
5067  	no_arg_funcs.emplace ("block_create", &nano::json_handler::block_create);
5068  	no_arg_funcs.emplace ("block_hash", &nano::json_handler::block_hash);
5069  	no_arg_funcs.emplace ("bootstrap", &nano::json_handler::bootstrap);
5070  	no_arg_funcs.emplace ("bootstrap_any", &nano::json_handler::bootstrap_any);
5071  	no_arg_funcs.emplace ("bootstrap_lazy", &nano::json_handler::bootstrap_lazy);
5072  	no_arg_funcs.emplace ("bootstrap_status", &nano::json_handler::bootstrap_status);
5073  	no_arg_funcs.emplace ("confirmation_active", &nano::json_handler::confirmation_active);
5074  	no_arg_funcs.emplace ("confirmation_height_currently_processing", &nano::json_handler::confirmation_height_currently_processing);
5075  	no_arg_funcs.emplace ("confirmation_history", &nano::json_handler::confirmation_history);
5076  	no_arg_funcs.emplace ("confirmation_info", &nano::json_handler::confirmation_info);
5077  	no_arg_funcs.emplace ("confirmation_quorum", &nano::json_handler::confirmation_quorum);
5078  	no_arg_funcs.emplace ("database_txn_tracker", &nano::json_handler::database_txn_tracker);
5079  	no_arg_funcs.emplace ("delegators", &nano::json_handler::delegators);
5080  	no_arg_funcs.emplace ("delegators_count", &nano::json_handler::delegators_count);
5081  	no_arg_funcs.emplace ("deterministic_key", &nano::json_handler::deterministic_key);
5082  	no_arg_funcs.emplace ("epoch_upgrade", &nano::json_handler::epoch_upgrade);
5083  	no_arg_funcs.emplace ("frontiers", &nano::json_handler::frontiers);
5084  	no_arg_funcs.emplace ("frontier_count", &nano::json_handler::account_count);
5085  	no_arg_funcs.emplace ("keepalive", &nano::json_handler::keepalive);
5086  	no_arg_funcs.emplace ("key_create", &nano::json_handler::key_create);
5087  	no_arg_funcs.emplace ("key_expand", &nano::json_handler::key_expand);
5088  	no_arg_funcs.emplace ("ledger", &nano::json_handler::ledger);
5089  	no_arg_funcs.emplace ("node_id", &nano::json_handler::node_id);
5090  	no_arg_funcs.emplace ("node_id_delete", &nano::json_handler::node_id_delete);
5091  	no_arg_funcs.emplace ("password_change", &nano::json_handler::password_change);
5092  	no_arg_funcs.emplace ("password_enter", &nano::json_handler::password_enter);
5093  	no_arg_funcs.emplace ("wallet_unlock", &nano::json_handler::password_enter);
5094  	no_arg_funcs.emplace ("peers", &nano::json_handler::peers);
5095  	no_arg_funcs.emplace ("pending", &nano::json_handler::pending);
5096  	no_arg_funcs.emplace ("pending_exists", &nano::json_handler::pending_exists);
5097  	no_arg_funcs.emplace ("receivable", &nano::json_handler::receivable);
5098  	no_arg_funcs.emplace ("receivable_exists", &nano::json_handler::receivable_exists);
5099  	no_arg_funcs.emplace ("process", &nano::json_handler::process);
5100  	no_arg_funcs.emplace ("pruned_exists", &nano::json_handler::pruned_exists);
5101  	no_arg_funcs.emplace ("receive", &nano::json_handler::receive);
5102  	no_arg_funcs.emplace ("receive_minimum", &nano::json_handler::receive_minimum);
5103  	no_arg_funcs.emplace ("receive_minimum_set", &nano::json_handler::receive_minimum_set);
5104  	no_arg_funcs.emplace ("representatives", &nano::json_handler::representatives);
5105  	no_arg_funcs.emplace ("representatives_online", &nano::json_handler::representatives_online);
5106  	no_arg_funcs.emplace ("republish", &nano::json_handler::republish);
5107  	no_arg_funcs.emplace ("search_pending", &nano::json_handler::search_pending);
5108  	no_arg_funcs.emplace ("search_receivable", &nano::json_handler::search_receivable);
5109  	no_arg_funcs.emplace ("search_pending_all", &nano::json_handler::search_pending_all);
5110  	no_arg_funcs.emplace ("search_receivable_all", &nano::json_handler::search_receivable_all);
5111  	no_arg_funcs.emplace ("send", &nano::json_handler::send);
5112  	no_arg_funcs.emplace ("sign", &nano::json_handler::sign);
5113  	no_arg_funcs.emplace ("stats", &nano::json_handler::stats);
5114  	no_arg_funcs.emplace ("stats_clear", &nano::json_handler::stats_clear);
5115  	no_arg_funcs.emplace ("stop", &nano::json_handler::stop);
5116  	no_arg_funcs.emplace ("telemetry", &nano::json_handler::telemetry);
5117  	no_arg_funcs.emplace ("unchecked", &nano::json_handler::unchecked);
5118  	no_arg_funcs.emplace ("unchecked_clear", &nano::json_handler::unchecked_clear);
5119  	no_arg_funcs.emplace ("unchecked_get", &nano::json_handler::unchecked_get);
5120  	no_arg_funcs.emplace ("unchecked_keys", &nano::json_handler::unchecked_keys);
5121  	no_arg_funcs.emplace ("unopened", &nano::json_handler::unopened);
5122  	no_arg_funcs.emplace ("uptime", &nano::json_handler::uptime);
5123  	no_arg_funcs.emplace ("validate_account_number", &nano::json_handler::validate_account_number);
5124  	no_arg_funcs.emplace ("version", &nano::json_handler::version);
5125  	no_arg_funcs.emplace ("wallet_add", &nano::json_handler::wallet_add);
5126  	no_arg_funcs.emplace ("wallet_add_watch", &nano::json_handler::wallet_add_watch);
5127  	no_arg_funcs.emplace ("wallet_balances", &nano::json_handler::wallet_balances);
5128  	no_arg_funcs.emplace ("wallet_change_seed", &nano::json_handler::wallet_change_seed);
5129  	no_arg_funcs.emplace ("wallet_contains", &nano::json_handler::wallet_contains);
5130  	no_arg_funcs.emplace ("wallet_create", &nano::json_handler::wallet_create);
5131  	no_arg_funcs.emplace ("wallet_destroy", &nano::json_handler::wallet_destroy);
5132  	no_arg_funcs.emplace ("wallet_export", &nano::json_handler::wallet_export);
5133  	no_arg_funcs.emplace ("wallet_frontiers", &nano::json_handler::wallet_frontiers);
5134  	no_arg_funcs.emplace ("wallet_history", &nano::json_handler::wallet_history);
5135  	no_arg_funcs.emplace ("wallet_info", &nano::json_handler::wallet_info);
5136  	no_arg_funcs.emplace ("wallet_balance_total", &nano::json_handler::wallet_info);
5137  	no_arg_funcs.emplace ("wallet_key_valid", &nano::json_handler::wallet_key_valid);
5138  	no_arg_funcs.emplace ("wallet_ledger", &nano::json_handler::wallet_ledger);
5139  	no_arg_funcs.emplace ("wallet_lock", &nano::json_handler::wallet_lock);
5140  	no_arg_funcs.emplace ("wallet_pending", &nano::json_handler::wallet_pending);
5141  	no_arg_funcs.emplace ("wallet_receivable", &nano::json_handler::wallet_receivable);
5142  	no_arg_funcs.emplace ("wallet_representative", &nano::json_handler::wallet_representative);
5143  	no_arg_funcs.emplace ("wallet_representative_set", &nano::json_handler::wallet_representative_set);
5144  	no_arg_funcs.emplace ("wallet_republish", &nano::json_handler::wallet_republish);
5145  	no_arg_funcs.emplace ("wallet_work_get", &nano::json_handler::wallet_work_get);
5146  	no_arg_funcs.emplace ("work_generate", &nano::json_handler::work_generate);
5147  	no_arg_funcs.emplace ("work_cancel", &nano::json_handler::work_cancel);
5148  	no_arg_funcs.emplace ("work_get", &nano::json_handler::work_get);
5149  	no_arg_funcs.emplace ("work_set", &nano::json_handler::work_set);
5150  	no_arg_funcs.emplace ("work_validate", &nano::json_handler::work_validate);
5151  	no_arg_funcs.emplace ("work_peer_add", &nano::json_handler::work_peer_add);
5152  	no_arg_funcs.emplace ("work_peers", &nano::json_handler::work_peers);
5153  	no_arg_funcs.emplace ("work_peers_clear", &nano::json_handler::work_peers_clear);
5154  	no_arg_funcs.emplace ("populate_backlog", &nano::json_handler::populate_backlog);
5155  	no_arg_funcs.emplace ("debug_bootstrap_priority_info", &nano::json_handler::debug_bootstrap_priority_info);
5156  	return no_arg_funcs;
5157  }
5158  bool block_confirmed (nano::node & node, nano::transaction & transaction, nano::block_hash const & hash, bool include_active, bool include_only_confirmed)
5159  {
5160  	bool is_confirmed = false;
<span onclick='openModal()' class='match'>5161  	if (include_active && !include_only_confirmed)
5162  	{
5163  		is_confirmed = true;
5164  	}
5165  	else if (node.ledger.block_confirmed (transaction, hash))
5166  	{
5167  		is_confirmed = true;
5168  	}
5169  	else if (!include_only_confirmed)
5170  	{
</span>5171  		auto block (node.store.block.get (transaction, hash));
5172  		is_confirmed = (block != nullptr && !node.active.active (*block));
5173  	}
5174  	return is_confirmed;
5175  }
5176  char const * epoch_as_string (nano::epoch epoch)
5177  {
5178  	switch (epoch)
5179  	{
5180  		case nano::epoch::epoch_2:
5181  			return "2";
5182  		case nano::epoch::epoch_1:
5183  			return "1";
5184  		default:
5185  			return "0";
5186  	}
5187  }
5188  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-language_model.cpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-json_handler.cpp</div>
                <div class="column column_space"><pre><code>851    if (unicharset.get_isalpha(unichar_id)) {
852      consistency_info->num_alphas++;
853    } else if (unicharset.get_isdigit(unichar_id)) {
854      consistency_info->num_digits++;
855    } else if (!unicharset.get_ispunctuation(unichar_id)) {
</pre></code></div>
                <div class="column column_space"><pre><code>5161  	if (include_active && !include_only_confirmed)
5162  	{
5163  		is_confirmed = true;
5164  	}
5165  	else if (node.ledger.block_confirmed (transaction, hash))
5166  	{
5167  		is_confirmed = true;
5168  	}
5169  	else if (!include_only_confirmed)
5170  	{
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    