
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.242156429518339%, Tokens: 9</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-netobj.h</h3>
            <pre><code>1  ClassTP(TNetObj, PNetObj)
2  protected:
3    typedef PNetObj (*TNetObjLoad)(TSIn& SIn);
4    typedef TFunc<TNetObjLoad> TNetObjLoadF;
5    static THash<TStr, TNetObjLoadF> TypeToLoadFH;
6    static bool Reg(const TStr& TypeNm, const TNetObjLoadF& LoadF);
7  private:
8    TInt SockId;
9    UndefCopy(TNetObj);
10  public:
11    TNetObj(): SockId(-1){}
12    TNetObj(TSIn& SIn): SockId(SIn){}
13    virtual ~TNetObj(){}
14    static PNetObj Load(TSIn& SIn);
15    virtual void Save(TSOut& SOut){
16      GetTypeNm(*this).Save(SOut); SockId.Save(SOut);}
17    TNetObj& operator=(const TNetObj&){return *this;}
<span onclick='openModal()' class='match'>18    bool operator==(const TNetObj&){return true;}
19    void PutSockId(const int& _SockId){SockId=_SockId;}
</span>20    int GetSockId() const {return SockId;}
21    virtual TStr GetStr() const {
22      return GetTypeNm(*this)+"["+TInt::GetStr(SockId)+"]:";}
23    static PSIn GetPckSIn(const PNetObj& NetObj);
24    static PNetObj GetPckNetObj(TMOut& MOut, bool& Ok);
25  };
26  class TNetAck: public TNetObj{
27  private:
28    static bool IsReg;
29    static bool MkReg(){return TNetObj::Reg(TTypeNm<TNetAck>(), &Load);}
30  private:
31  public:
32    TNetAck(): TNetObj(){}
33    ~TNetAck(){}
34    TNetAck(TSIn& SIn): TNetObj(SIn){}
35    static PNetObj Load(TSIn& SIn){return PNetObj(new TNetAck(SIn));}
36    void Save(TSOut& SOut){TNetObj::Save(SOut);}
37    TStr GetStr() const {return TNetObj::GetStr();}
38  };
39  class TNetNotify: public TNetObj{
40  private:
41    static bool IsReg;
42    static bool MkReg(){
43      return TNetObj::Reg(TTypeNm<TNetNotify>(), TNetObjLoadF(&Load));}
44  private:
45    TInt NotifyType;
46    TStr NotifyStr;
47  public:
48    TNetNotify(const TNotifyType& _NotifyType, const TStr& _NotifyStr):
49      TNetObj(), NotifyType(_NotifyType), NotifyStr(_NotifyStr){}
50    ~TNetNotify(){}
51    TNetNotify(TSIn& SIn):
52      TNetObj(SIn), NotifyType(SIn), NotifyStr(SIn){}
53    static PNetObj Load(TSIn& SIn){return PNetObj(new TNetNotify(SIn));}
54    void Save(TSOut& SOut){
55      TNetObj::Save(SOut); NotifyType.Save(SOut); NotifyStr.Save(SOut);}
56    TNotifyType GetNotifyType() const {return TNotifyType(int(NotifyType));}
57    TStr GetNotifyStr() const {return NotifyStr;}
58    TStr GetStr() const {
59      TStr NotifyTypeStr=TNotify::GetTypeStr(GetNotifyType());
60      return TNetObj::GetStr()+NotifyTypeStr+":"+NotifyStr;}
61  };
62  class TNetErr: public TNetObj{
63  private:
64    static bool IsReg;
65    static bool MkReg(){
66      return TNetObj::Reg(TTypeNm<TNetErr>(), TNetObjLoadF(&Load));}
67  private:
68    TInt ErrCd;
69    TStr MsgStr;
70  public:
71    TNetErr(const int& _ErrCd, const TStr& _MsgStr):
72      TNetObj(), ErrCd(_ErrCd), MsgStr(_MsgStr){}
73    ~TNetErr(){}
74    TNetErr(TSIn& SIn): TNetObj(SIn), ErrCd(SIn), MsgStr(SIn){}
75    static PNetObj Load(TSIn& SIn){return PNetObj(new TNetErr(SIn));}
76    void Save(TSOut& SOut){
77      TNetObj::Save(SOut); ErrCd.Save(SOut); MsgStr.Save(SOut);}
78    int GetErrCd() const {return ErrCd;}
79    TStr GetMsgStr() const {return MsgStr;}
80    TStr GetStr() const {return TNetObj::GetStr()+MsgStr;}
81  };
82  class TNetAccept: public TNetObj{
83  private:
84    static bool IsReg;
85    static bool MkReg(){
86      return TNetObj::Reg(TTypeNm<TNetAccept>(), TNetObjLoadF(&Load));}
87  private:
88    TInt SideSockId;
89  public:
90    TNetAccept(const int& _SideSockId): TNetObj(), SideSockId(_SideSockId){}
91    ~TNetAccept(){}
92    TNetAccept(TSIn& SIn): TNetObj(SIn), SideSockId(SIn){}
93    static PNetObj Load(TSIn& SIn){return PNetObj(new TNetAccept(SIn));}
94    void Save(TSOut& SOut){TNetObj::Save(SOut); SideSockId.Save(SOut);}
95    int GetSideSockId() const {return SideSockId;}
96    TStr GetStr() const {return TNetObj::GetStr()+TInt::GetStr(SideSockId);}
97  };
98  class TNetConn: public TNetObj{
99  private:
100    static bool IsReg;
101    static bool MkReg(){
102      return TNetObj::Reg(TTypeNm<TNetConn>(), TNetObjLoadF(&Load));}
103  public:
104    TNetConn(): TNetObj(){}
105    ~TNetConn(){}
106    TNetConn(TSIn& SIn): TNetObj(SIn){}
107    static PNetObj Load(TSIn& SIn){return PNetObj(new TNetConn(SIn));}
108    void Save(TSOut& SOut){TNetObj::Save(SOut);}
109  };
110  class TNetClose: public TNetObj{
111  private:
112    static bool IsReg;
113    static bool MkReg(){
114      return TNetObj::Reg(TTypeNm<TNetClose>(), TNetObjLoadF(&Load));}
115  public:
116    TNetClose(): TNetObj(){}
117    ~TNetClose(){}
118    TNetClose(TSIn& SIn): TNetObj(SIn){}
119    static PNetObj Load(TSIn& SIn){return PNetObj(new TNetClose(SIn));}
120    void Save(TSOut& SOut){TNetObj::Save(SOut);}
121  };
122  class TNetTimeOut: public TNetObj{
123  private:
124    static bool IsReg;
125    static bool MkReg(){
126      return TNetObj::Reg(TTypeNm<TNetTimeOut>(), TNetObjLoadF(&Load));}
127  private:
128    TInt TimerId;
129    TInt Ticks;
130  public:
131    TNetTimeOut(const int& _TimerId, const int& _Ticks):
132      TNetObj(), TimerId(_TimerId), Ticks(_Ticks){}
133    ~TNetTimeOut(){}
134    TNetTimeOut(TSIn& SIn): TNetObj(SIn), TimerId(SIn), Ticks(SIn){}
135    static PNetObj Load(TSIn& SIn){return PNetObj(new TNetTimeOut(SIn));}
136    void Save(TSOut& SOut){
137      TNetObj::Save(SOut); TimerId.Save(SOut); Ticks.Save(SOut);}
138    int GetTimerId() const {return TimerId;}
139    int GetTicks() const {return Ticks;}
140    TStr GetStr() const {
141      return TNetObj::GetStr()+TInt::GetStr(TimerId)+" "+TInt::GetStr(Ticks);}
142  };
143  typedef enum {nrtLogin, nrtConfirm, nrtRefuse, nrtLogout} TNetRegType;
144  class TNetReg: public TNetObj{
145  private:
146    static bool IsReg;
147    static bool MkReg(){
148      return TNetObj::Reg(TTypeNm<TNetReg>(), TNetObjLoadF(&Load));}
149  private:
150    TInt RegType;
151    TStr UsrNm;
152    TStr PwdStr;
153    TStr InfoStr;
154    TStr VerStr;
155    TStr MsgStr;
156  public:
157    TNetReg(const int& _RegType, const TStr& _UsrNm, const TStr& _PwdStr,
158     const TStr& _InfoStr, const TStr& _VerStr):
159      TNetObj(), RegType(_RegType), UsrNm(_UsrNm), PwdStr(_PwdStr),
160      InfoStr(_InfoStr), VerStr(_VerStr), MsgStr(){
161      IAssert(int(RegType)==nrtLogin);}
162    TNetReg(const int& _RegType, const TStr& _MsgStr=TStr()):
163      TNetObj(), RegType(_RegType), UsrNm(), PwdStr(),
164      InfoStr(), VerStr(), MsgStr(_MsgStr){
165      IAssert((int(RegType)==nrtConfirm)||(int(RegType)==nrtRefuse)||(int(RegType)==nrtLogout));}
166    ~TNetReg(){}
167    TNetReg(TSIn& SIn):
168      TNetObj(SIn), RegType(SIn), UsrNm(SIn), PwdStr(SIn),
169      InfoStr(SIn),
170      VerStr(SIn),
171      MsgStr(SIn){}
172    static PNetObj Load(TSIn& SIn){return PNetObj(new TNetReg(SIn));}
173    void Save(TSOut& SOut){
174      TNetObj::Save(SOut); RegType.Save(SOut);
175      UsrNm.Save(SOut); PwdStr.Save(SOut);
176      InfoStr.Save(SOut); VerStr.Save(SOut); MsgStr.Save(SOut);}
177    int GetRegType() const {return RegType;}
178    TStr GetUsrNm() const {IAssert(int(RegType)==nrtLogin); return UsrNm;}
179    TStr GetPwdStr() const {IAssert(int(RegType)==nrtLogin); return PwdStr;}
180    TStr GetVerStr() const {return VerStr;}
181    TStr GetInfoStr() const {return InfoStr;}
182    TStr GetMsg() const {return MsgStr;}
183    TStr GetStr() const {
184      TChA Str=TNetObj::GetStr()+GetRegTypeStr(RegType)+":"+MsgStr;
185      if (RegType==int(nrtLogin)){Str+=TStr(":'")+UsrNm+"'/'"+PwdStr+"'/'"+InfoStr+"'";}
186      return Str;}
187    static TStr GetRegTypeStr(const int& NetRegType);
188  };
189  class TNetChatMsg: public TNetObj{
190  private:
191    static bool IsReg;
192    static bool MkReg(){
193      return TNetObj::Reg(TTypeNm<TNetChatMsg>(), TNetObjLoadF(&Load));}
194  private:
195    TStr FromAddrStr;
196    TStrV ToAddrStrV;
197    TStr MsgStr;
198  public:
199    TNetChatMsg(
200     const TStr& _FromAddrStr, const TStrV& _ToAddrStrV, const TStr& _MsgStr):
201      TNetObj(), FromAddrStr(_FromAddrStr), ToAddrStrV(_ToAddrStrV), MsgStr(_MsgStr){}
202    ~TNetChatMsg(){}
203    TNetChatMsg(TSIn& SIn):
204      TNetObj(SIn), FromAddrStr(SIn), ToAddrStrV(SIn), MsgStr(SIn){}
205    static PNetObj Load(TSIn& SIn){return PNetObj(new TNetChatMsg(SIn));}
206    void Save(TSOut& SOut){
207      TNetObj::Save(SOut);
208      FromAddrStr.Save(SOut); ToAddrStrV.Save(SOut); MsgStr.Save(SOut);}
209    TStr GetFromAddrStr() const {return FromAddrStr;}
210    void GetToAddrStrV(TStrV& _ToAddrStrV) const {_ToAddrStrV=ToAddrStrV;}
211    int GetToAddrStrs() const {return ToAddrStrV.Len();}
212    TStr GetToAddrStr(const int& ToAddrStrN) const {return ToAddrStrV[ToAddrStrN];}
213    TStr GetMsgStr() const {return MsgStr;}
214    TStr GetStr() const {return TNetObj::GetStr();}
215    TStr GetLogStr();
216  };
217  class TNetMem: public TNetObj{
218  private:
219    static bool IsReg;
220    static bool MkReg(){
221      return TNetObj::Reg(TTypeNm<TNetMem>(), TNetObjLoadF(&Load));}
222  private:
223    TMem Mem;
224  public:
225    TNetMem(const TMem& _Mem):
226      TNetObj(), Mem(_Mem){}
227    ~TNetMem(){}
228    TNetMem(TSIn& SIn):
229      TNetObj(SIn), Mem(SIn){}
230    static PNetObj Load(TSIn& SIn){return PNetObj(new TNetMem(SIn));}
231    void Save(TSOut& SOut){
232      TNetObj::Save(SOut); Mem.Save(SOut);}
233    const TMem& GetMem() const {return Mem;}
234    TStr GetStr() const {return TNetObj::GetStr();}
235    TStr GetLogStr();
236  };
237  class TNetObjPckHd{
238  private:
239    TCh Ch;
240    TInt PckLen;
241  public:
242    TNetObjPckHd(const int& _PckLen): Ch('*'), PckLen(_PckLen){}
243    TNetObjPckHd(TSIn& SIn, bool& Ok): Ch(SIn), PckLen(SIn){Ok=(Ch==TCh('*'));}
244    void Save(TSOut& SOut){Ch.Save(SOut); PckLen.Save(SOut);}
245    int GetPckLen() const {return PckLen;}
246    static int GetSize(){return 5;}
247  };
248  class TNetSrv;
249  class TNetSrvSockEvent: public TSockEvent{
250  private:
251    TNetSrv* NetSrv;
252  public:
253    TNetSrvSockEvent(TNetSrv* _NetSrv): NetSrv(_NetSrv){}
254    ~TNetSrvSockEvent(){}
255    void OnRead(const int& SockId, const PSIn& SIn);
256    void OnWrite(const int& SockId);
257    void OnOob(const int&){Fail;}
258    void OnAccept(const int& SockId, const PSock& Sock);
259    void OnConnect(const int&){Fail;}
260    void OnClose(const int& SockId);
261    void OnTimeOut(const int& SockId);
262    void OnError(const int& SockId, const int& ErrCd, const TStr& MsgStr);
263    void OnGetHost(const PSockHost&){Fail;}
264  };
265  class TNetSrv{
266  private:
267    int PortN;
268    PSockEvent SrvSockEvent;
269    PSock SrvSock;
270    THash<TInt, PSock> CltSockIdToSockH;
271    TMOut SockMOut;
272    UndefCopyAssign(TNetSrv);
273  public:
274    TNetSrv(){Fail;}
275    TNetSrv(const int& _PortN, const bool& FixedPortNP=true);
276    virtual ~TNetSrv();
277    TNetSrv(TSIn&){Fail;}
278    void Save(TSOut&){Fail;}
279    bool IsConn() const {return !SrvSock.Empty();}
280    virtual void Disconn();
281    virtual void DisconnClt(const int& CltSockId);
282    void SendNetObj(const int& CltSockId, const PNetObj& NetObj);
283    void BroadcastNetObj(const PNetObj& NetObj);
284    virtual void OnNetObj(const PNetObj& NetObj)=0;
285    int GetPortN() const {return PortN;}
286    int GetClts() const {return CltSockIdToSockH.Len();}
287    bool IsCltSock(const int& CltSockId) const {
288      return CltSockIdToSockH.IsKey(CltSockId);}
289    PSock GetCltSock(const int& CltSockId) const {
290      return CltSockIdToSockH.GetDat(CltSockId);}
291    friend class TNetSrvSockEvent;
292  };
293  class TNetClt;
294  typedef enum {csmGetingHost, csmConnecting, csmConnected,
295   csmAfterClose} TNetCltSockEventMode;
296  class TNetCltSockEvent: public TSockEvent{
297  private:
298    static const int MxGetHostTrys;
299    TNetCltSockEventMode Mode;
300    int GetHostTrys;
301    TNetClt* NetClt;
302  public:
303    TNetCltSockEvent(TNetClt* _NetClt);
304    ~TNetCltSockEvent(){}
305    void OnRead(const int& SockId, const PSIn& SIn);
306    void OnWrite(const int& SockId);
307    void OnOob(const int&){Fail;}
308    void OnAccept(const int&, const PSock&){Fail;}
309    void OnConnect(const int& SockId);
310    void OnClose(const int& SockId);
311    void OnTimeOut(const int& SockId);
312    void OnError(const int& SockId, const int& ErrCd, const TStr& MsgStr);
313    void OnGetHost(const PSockHost& SockHost);
314  };
315  class TNetClt{
316  private:
317  protected:
318    TStr HostNm;
319    int PortN;
320    PSockEvent SockEvent;
321    PSock Sock;
322    TMOut SockMOut;
323    TStr UsrNm;
324    TStr PwdStr;
325    UndefCopyAssign(TNetClt);
326  public:
327    TNetClt(){Fail;}
328    TNetClt(
329     const TStr& _HostNm, const int& _PortN,
330     const TStr& _UsrNm=TStr(), const TStr& _PwdStr=TStr());
331    virtual ~TNetClt();
332    TNetClt(TSIn&){Fail;}
333    void Save(TSOut&){Fail;}
334    /&bsol;** bug bool IsConn() const {return !Sock.Empty();}
335    virtual void Disconn(){Sock=NULL;}
336    int GetSockId() const {return Sock->GetSockId();}
337    void SendNetObj(const PNetObj& NetObj);
338    virtual void OnNetObj(const PNetObj& NetObj)=0;
339    TStr GetHostNm() const {return HostNm;}
340    int GetPortN() const {return PortN;}
341    TStr GetHostPortStr() const {return TStr::Fmt("%s:%d", HostNm.CStr(), PortN);}
342    static TStr GetHostPortStr(const TStr& HostNm, const int& PortN){
343      return TStr::Fmt("%s:%d", HostNm.CStr(), PortN);}
344    TStr GetUsrNm() const {return UsrNm;}
345    TStr GetPwdStr() const {return PwdStr;}
346    friend class TNetCltSockEvent;
347  };
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-rids.h</h3>
            <pre><code>1  #ifndef RI3_H
2  #define	RI3_H
3  #include <map>
4  #include <math.h>
5  #include <stdint.h>
6  #include "Snap.h"
7  typedef uint32_t u_size_t;
8  typedef int32_t s_size_t;
9  typedef u_size_t sbitset_block;
10  enum TMamaParent { mpParentTypeIn, mpParentTypeOut, mpParentTypeNull };
11  enum TMatch { mIso, mIndSub, mMono };
12  class TIDer{
13  private:
14  	std::map<std::string, int> TIMap;
15  public:
16  	TIDer() { }
17  	~TIDer(){ }
18  	s_size_t IdFor(std::string* Value) {
19  		int Ret = 0;
20  		if(Value == NULL) {
21  			Ret = 0;
22  		} else {
23  			std::map<std::string, int>::iterator IT = TIMap.find(*Value);
24  			if(IT == TIMap.end()) {
25  				TIMap.insert(*(new std::pair<std::string, int>(*Value, ((int)TIMap.size())+1)));
26  				Ret = ((int)TIMap.size());
27  			} else {
28  				Ret = IT->second;
29  			}
30  		}
31  		return Ret;
32  	}
33  };
34  class TNodeList {
35  public:
36    virtual ~TNodeList() {
37    };
38    virtual int GetNode(int Id) = 0;
39    virtual void AddNode(int Id){};
40  };
41  template<class TNodeData, class TEdgeData>
42  class TInAdjList : public TNodeList {
43  private:
44    TPt<TNodeEDatNet<TNodeData, TEdgeData> > &Net;
45    int NodeId;
46  public:
47    TInAdjList(TPt<TNodeEDatNet<TNodeData, TEdgeData> > &NNet, int NNodeId):
48      Net(NNet), NodeId(NNodeId) { }
49    int GetNode(int Id) {
50      return Net->GetNI(NodeId).GetInNId(Id);
51    }
52  };
53  template<class TNodeData, class TEdgeData>
54  class TOutAdjList : public TNodeList {
55  private:
56    TPt<TNodeEDatNet<TNodeData, TEdgeData> > &Net;
57    int NodeId;
58  public:
59    TOutAdjList(TPt<TNodeEDatNet<TNodeData, TEdgeData> > &NNet, int NNodeId):
60      Net(NNet), NodeId(NNodeId) { }
61    int GetNode(int Id) {
62      return Net->GetNI(NodeId).GetOutNId(Id);
63    }
64  };
65  template<class TNodeData, class TEdgeData>
66  class TAllNodesList : public TNodeList {
67  private:
68    TPt<TNodeEDatNet<TNodeData, TEdgeData> > &Net;
69    int NodeId;
70  public:
71    TAllNodesList(TPt<TNodeEDatNet<TNodeData, TEdgeData> > &NNet):
72      Net(NNet) { }
73    int GetNode(int Id) {
74      return Net->GetNI(Id).GetId();
75    }
76  };
77  template<class TNodeData, class TEdgeData>
78  class TCandidatesList : public TNodeList {
79  private:
80    TPt<TNodeEDatNet<TNodeData, TEdgeData> > &Net;
81    int NodeId;
82    int* NodesList;
83    int curr;
84  public:
85    TCandidatesList(TPt<TNodeEDatNet<TNodeData, TEdgeData> > &NNet, int Size):
86      Net(NNet),
87      NodesList(new int[Size]),
88      curr(0) { }
89    int GetNode(int Id) { return Net->GetNI(NodesList[Id]).GetId(); }
90    void AddNode(int Id) {
91      NodesList[curr] = Id;
92      curr++;
93    }
94  };
95  template<class TNodeData, class TEdgeData>
96  int GetAdjSize(TPt<TNodeEDatNet<TNodeData, TEdgeData> > &Graph, int Id) {
97    return Graph->GetNI(Id).GetDeg();
98  }
99  template<class TNodeData, class TEdgeData>
100  int GetInAdjSize(TPt<TNodeEDatNet<TNodeData, TEdgeData> > &Graph, int Id) {
101    return Graph->GetNI(Id).GetInDeg();
102  }
103  template<class TNodeData, class TEdgeData>
104  int GetOutAdjSize(TPt<TNodeEDatNet<TNodeData, TEdgeData> > &Graph, int Id) {
105    return Graph->GetNI(Id).GetOutDeg();
106  }
107  template<class TNodeData, class TEdgeData>
108  int GetNodeInAdjList(TPt<TNodeEDatNet<TNodeData, TEdgeData> > &Graph, int NId, int N) {
109    typename TNodeEDatNet<TNodeData, TEdgeData>::TNodeI NI;
110    NI = Graph->GetNI(NId);
111    return NI.GetNbrNId(N);
112  };
113  template<class TNodeData, class TEdgeData>
114  int GetNthOutAdjList(TPt<TNodeEDatNet<TNodeData, TEdgeData> > &Graph, int NId, int N) {
115    return Graph->GetNI(NId).GetOutNId(N);
116  }
117  template<class TNodeData, class TEdgeData>
118  int GetNthInAdjList(TPt<TNodeEDatNet<TNodeData, TEdgeData> > &Graph, int NId, int N) {
119    return Graph->GetNI(NId).GetInNId(N);
120  }
121  template<class TNodeData, class TEdgeData>
122  int GetEdgeId(TPt<TNodeEDatNet<TNodeData, TEdgeData> > &Graph, int NId, int N) {
123    return Graph->GetEI(NId, N).GetId();
124  }
125  class TSBitSet {
126  static const size_t bytes_per_block = sizeof(sbitset_block);
127  static const size_t bits_per_block = sizeof(sbitset_block)*8;
128  public:
129  	sbitset_block* Bits;
130  	size_t NBlocks;
131  public:
132  	TSBitSet() {
133  		Bits = (sbitset_block*)calloc(1, bytes_per_block);
134  		NBlocks = 1;
135  	}
136  	TSBitSet(const TSBitSet &c) {
137  		Bits = (sbitset_block*)malloc(c.NBlocks * bytes_per_block);
138  		memcpy(Bits, c.Bits, c.NBlocks * bytes_per_block);
139  		NBlocks = c.NBlocks;
140  	}
141  	TSBitSet(TSBitSet &c) {
142  		Bits = (sbitset_block*)malloc(c.NBlocks * bytes_per_block);
143  		memcpy(Bits, c.Bits, c.NBlocks * bytes_per_block);
144  		NBlocks = c.NBlocks;
145  	}
146  	~TSBitSet() {
147  		delete [] Bits;
148  	}
149  	void PrintI(std::ostream &os) {
150  		for(size_t i = 0; i < NBlocks * bits_per_block; i++){
151  			os<<"("<<i<<":"<<Get(i)<<")";
152  		}
153  	}
154  	void PrintNumbers() {
155  		std::cout<<"[";
156  		for(size_t i=0; i < NBlocks * bits_per_block; i++) {
157  			if(Get(i))
158  				std::cout<<i<<" ";
159  		}
160  		std::cout<<"]";
161  	}
162  	void PrintInfo() { }
163  	bool IsEmpty() {
164  		for(size_t i = 0; i < NBlocks; i++) {
165  			if(Bits[i]!=0){
166  				return false;
167  			}
168  		}
169  		return true;
170  	}
171  	int CountOnes() {
172  		int Count = 0;
173  		for(TIterator IT = FirstOnes(); IT != End(); IT.next_ones()) {
174  			Count++;
175  		}
176  		return Count;
177  	}
178  	bool AtLeastOne() {
179  		TIterator IT = FirstOnes();
180  		return IT != End();
181  	}
182  	bool Get(size_t Pos) {
183  		if(Pos >= 0 && Pos < (NBlocks * bits_per_block)) {
184  			return Bits[Pos/bits_per_block] &
185                (1<<(bits_per_block - (Pos%bits_per_block)-1));
186  		}
187  		return 0;
188  	}
189  	void Resize(size_t NSize) {
190  		if(NSize > NBlocks * bits_per_block){
191  			size_t NNBlocks = (size_t)(ceil(NSize / bits_per_block) +1);
192  			sbitset_block* NBits = (sbitset_block*)calloc(NNBlocks, bytes_per_block);
193  			memcpy(NBits, Bits, NBlocks * bytes_per_block);
194  			NBlocks = NNBlocks;
195  			delete [] Bits;
196  			Bits = NBits;
197  		}
198  	}
199  	void ResizeAsis(size_t NSize) {
200  		if(NSize > NBlocks * bits_per_block) {
201  			size_t NNBlocks = (size_t)(ceil(NSize / bits_per_block) +1);
202  			delete [] Bits;
203  			Bits = (sbitset_block*)malloc(NNBlocks * bytes_per_block);
204  			NBlocks = NNBlocks;
205  		}
206  	}
207  	void Set(size_t Pos, bool Value) {
208  		if(Pos >= 0) {
209  			if(Pos >= NBlocks * bits_per_block) { Resize(Pos+1); }
210  			if(Value != Get(Pos)) {
211  				this->Bits[Pos/bits_per_block] ^=
212                  1<<(bits_per_block - (Pos%bits_per_block)-1);
213        }
214  		}
215  	}
216  	TSBitSet& operator&=(TSBitSet &bs){
217  		size_t WBlokcs = NBlocks <= bs.NBlocks ? NBlocks : bs.NBlocks;
218  		for(size_t i = 0; i < WBlokcs; i++) {
219  			Bits[i] &= bs.Bits[i];
220      }
221  		for(size_t i = WBlokcs; i< NBlocks; i++) {
222  			Bits[i] = 0;
223      }
224  		return *this;
225  	}
226  	TSBitSet& operator|=(TSBitSet &bs){
227  		size_t WBlokcs = NBlocks <= bs.NBlocks ? NBlocks : bs.NBlocks;
228  		for(size_t i = 0; i < WBlokcs; i++) {
229  			Bits[i] |= bs.Bits[i];
230      }
231  		if(bs.NBlocks > NBlocks) {
232  			Resize(bs.NBlocks * bits_per_block);
233  			for(size_t i = WBlokcs; i<NBlocks; i++) {
234  				Bits[i] = bs.Bits[i];
235        }
236  		}
237  		return *this;
238  	}
239  	TSBitSet& operator =(TSBitSet &b){
240  		delete [] Bits;
241  		NBlocks = b.NBlocks;
242  		Bits = (sbitset_block*)malloc(NBlocks * bytes_per_block);
243  		memcpy(Bits, b.Bits, NBlocks * bytes_per_block);
244  		return *this;
245  	}
246  	bool operator!=(TSBitSet &b){
247  		size_t wblokcs = NBlocks <= b.NBlocks ? NBlocks : b.NBlocks;
248  		for(size_t i = 0; i<wblokcs; i++) {
249  			if(Bits[i] != b.Bits[i]) { return true;}
250  		}
251  		if(wblokcs > NBlocks) {
252  			for(size_t i = wblokcs; i<b.NBlocks; i++) {
253  				if(b.Bits[i] != 0){ return true; }
254  			}
255  		} else {
256  			for(size_t i = wblokcs; i<NBlocks; i++) {
257  				if(Bits[i] != 0){ return true; }
258  			}
259  		}
260  		return false;
261  	}
262  	bool EmptyAND(TSBitSet &b){
263  		size_t WBlokcs = NBlocks <= b.NBlocks ? NBlocks : b.NBlocks;
264  		for(size_t i = 0; i < WBlokcs; i++) {
265  			if((Bits[i] & b.Bits[i]) != 0) { return false; }
266  		}
267  		return true;
268  	}
269  	void SetAll(size_t Size, bool Value){
270  		ResizeAsis(Size);
271  		sbitset_block svalue = 0x0;
272  		sbitset_block mask = Value;
273  		for(size_t i=0; i < bits_per_block; i++) {
274  			svalue |= mask;
275  			mask = mask << 1;
276  		}
277  		for(size_t i=0; i<NBlocks; i++) {
278  			Bits[i] = svalue;
279  		}
280  	}
281  	class TIterator{
282  		TSBitSet &Sb;
283  		u_size_t WBlock;
284  		unsigned short Shift;
285  		public:
286  			u_size_t First;	
287  			bool Second;	
288  		public:
289  			TIterator(TSBitSet &sb) : Sb(sb) {
290  				WBlock = 0;
291  				Shift = bits_per_block - 1;
292  				GetComps();
293  			}
294  			TIterator(TSBitSet &sb, u_size_t wblock) : Sb(sb), WBlock(wblock) {
295  				Shift = bits_per_block - 1;
296  				GetComps();
297  			}
298  		private:
299  			void GetComps() {
300  				First = (WBlock * bits_per_block) + bits_per_block - Shift - 1;
301  				if(WBlock < Sb.NBlocks) {
302  					Second =  Sb.Bits[WBlock] & 1<<(Shift);
303  				} else {
304  					Second = false;
305  				}
306  			}
307  		public:
308  			TIterator& operator++() {
309  				if(Shift == 0) {
310  					WBlock++;
311  					Shift = bits_per_block - 1;
312  				} else {
313  					Shift--;
314  				}
315  				GetComps();
316  				return (*this);
317  			}
318  			void operator++ (int) {
319  			   ++(*this);
320  			}
321  			void next_ones() {
322  				do {
323  					if(Shift == 0) {
324  						WBlock++;
325  						Shift = bits_per_block - 1;
326  						while(WBlock < Sb.NBlocks && Sb.Bits[WBlock] == 0)
327  							WBlock++;
328  					} else {
329  						Shift--;
330  					}
331  					GetComps();
332  				} while(!Second && WBlock<Sb.NBlocks);
333  			}
334  			const bool operator==(const TIterator &IT) {
335  				return &Sb == &(IT.Sb) && WBlock == IT.WBlock && Shift == IT.Shift;
336  			}
337  			const bool operator!=(const TIterator &IT) {
338  				if( &Sb != &(IT.Sb) || WBlock != IT.WBlock || Shift != IT.Shift) {
339  					return true;
340          }
341  				return false;
342  			}
343  	};
344  	TIterator Begin() {
345  		if(IsEmpty()) { return End(); }
346  		return TIterator(*this);
347  	}
348  	TIterator End() {
349  		return TIterator(*this, NBlocks);
350  	}
351  	TIterator FirstOnes() {
352  		if(IsEmpty()) { return End(); }
353  		TIterator IT(*this);
354  		if(IT.Second != 1) { IT.next_ones(); }
355  		return IT;
356  	}
357  };
358  template<class TNodeData, class TEdgeData>
359  class TMatchingMachine {
360  public:
361    class TMaMaEdge {
362    private:
363      int Source;
364      int Target;
365      TEdgeData* Attr;
366      int Id;
367    public:
368      int GetSource() const { return Source; }
369      int GetTarget() const { return Target; }
370      TEdgeData* GetAttr() const { return Attr; }
<span onclick='openModal()' class='match'>371      int GetId() const { return Id; }
372      void SetSource(const int ValSource){ Source = ValSource; }
</span>373      void SetTarget(const int ValTarget){ Target = ValTarget; }
374      void SetAttr(TEdgeData* ValAttr) { Attr = ValAttr; }
375      void SetId(int Id) { this->Id = Id; }
376      TMaMaEdge(int NSource, int NTarget, TEdgeData* NAttr, int NId) {
377        Source = NSource;
378        Target = NTarget;
379        Attr = NAttr;
380        Id = NId;
381      }
382      TMaMaEdge() {
383        Source = -1;
384        Target = -1;
385        Attr = NULL;
386        Id = -1;
387      }
388    };
389  protected:
390    int NofSn;
391    TNodeData** NodesAttrs;
392    int* EdgesSizes;
393    int* OutEdgesSizes;
394  	int* InEdgesSizes;
395    TMaMaEdge** Edges;
396    int* MapNodeToState;
397    int* MapStateToNode;
398    int* ParentState;
399    TMamaParent* ParentType;
400    TSBitSet* Domains;
401  	int* DomainsSize;
402  private:
403    int WCompare(int i, int j, int** Weights) {
404      for (int w = 0; w < 3; w++) {
405        if (Weights[i][w] != Weights[j][w]) {
406          return Weights[j][w] - Weights[i][w];
407        }
408      }
409      return i-j;
410    }
411  public:
412    TMatchingMachine(TPt<TNodeEDatNet<TNodeData, TEdgeData> > &Query,
413      TSBitSet* NDomains, int* NDomainsSize) {
414        NofSn = Query->GetNodes();
415        NodesAttrs = new TNodeData*[NofSn];
416        EdgesSizes = (int*) calloc(NofSn, sizeof(int));
417        OutEdgesSizes = (int*) calloc(NofSn, sizeof(int));
418  		  InEdgesSizes = (int*) calloc(NofSn, sizeof(int));
419        Edges = new TMaMaEdge*[NofSn];
420        MapNodeToState = (int*) calloc(NofSn, sizeof(int));
421        MapStateToNode = (int*) calloc(NofSn, sizeof(int));
422        ParentState = (int*) calloc(NofSn, sizeof(int));
423        ParentType = new TMamaParent[NofSn];
424        Domains = NDomains;
425        DomainsSize = NDomainsSize;
426    }
427    virtual ~TMatchingMachine() {
428      delete[] NodesAttrs;
429      for (int i = 0; i < NofSn; i++) {
430        delete[] Edges[i];
431      }
432      delete[] Edges;
433      free(EdgesSizes);
434      free(OutEdgesSizes);
435  		free(InEdgesSizes);
436      free(MapNodeToState);
437      free(MapStateToNode);
438      free(ParentState);
439      delete[] ParentType;
440    }
441    void Build(TPt<TNodeEDatNet<TNodeData, TEdgeData> > &SSG) {
442      enum TNodeFlag { nsCore, nsCNeigh, nsUnv };
443      TNodeFlag* NodeFlags = new TNodeFlag[NofSn];
444      int** Weights = new int*[NofSn];
445      int* ParentNode = (int*) calloc(NofSn, sizeof(int));
446      TMamaParent* ParentTypes = new TMamaParent[NofSn];
447      int NofSingleDomains = 0;
448      for (int i = 0; i < NofSn; i++) {
449        NodeFlags[i] = nsUnv;
450        Weights[i] = new int[3];
451        Weights[i][0] = 0;
452        Weights[i][1] = 0;
453        Weights[i][2] = GetOutAdjSize(SSG, i) + GetInAdjSize(SSG, i);
454        ParentNode[i] = -1;
455        ParentTypes[i] = mpParentTypeNull;
456        if(DomainsSize[i] == 1) { NofSingleDomains++; }
457      }
458      int SId = 0;
459      int n;
460      int NIT; int NId;
461      int NNIT; int NNId;
462      int NQueueL = 0, NQueueR = 0;
463      int MaxId, MaxV;
464      int Tmp;
465      if(NofSingleDomains != 0) {
466        NQueueR = NofSingleDomains;
467        for(int n = 0; n < NofSn; n++) {
468  				if(DomainsSize[n] == 1) {
469  					MapStateToNode[SId] = n;
470  					MapNodeToState[n] = SId;
471  					ParentTypes[n] = mpParentTypeNull;
472  					ParentNode[n] = -1;
473  					NQueueL++;
474  					NodeFlags[n] = nsCore;
475  					NIT = 0;
476  					while(NIT < GetOutAdjSize(SSG, n)){
477  						NId = GetNthOutAdjList(SSG, n, NIT);
478  						if(NId != n && DomainsSize[NId] > 1){
479  							Weights[NId][0]++;
480  							Weights[NId][1]--;
481  							if(NodeFlags[NId] == nsUnv) {
482  								NodeFlags[NId] = nsCNeigh;
483  								ParentNode[NId] = n;
484  								if(NIT < GetOutAdjSize(SSG, n)) {
485  									ParentTypes[NId] = mpParentTypeOut;
486  								} else {
487  									ParentTypes[NId] = mpParentTypeIn;
488                  }
489  								MapStateToNode[NQueueL] = NId;
490  								MapNodeToState[NId] = NQueueL;
491  								NQueueR++;
492  								NNIT = 0;
493  								while(NNIT < GetOutAdjSize(SSG, NId)){
494  									NNId = GetNthOutAdjList(SSG, NId, NNIT);
495  									Weights[NNId][1]++;
496  									NNIT++;
497  								}
498  							}
499  						}
500  						NIT++;
501  					}
502            NIT = 0;
503  					while(NIT < GetInAdjSize(SSG, n)){
504  						NId = GetNthInAdjList(SSG, n, NIT);
505  						if(NId != n && DomainsSize[NId] > 1){
506  							Weights[NId][0]++;
507  							Weights[NId][1]--;
508  							if(NodeFlags[NId] == nsUnv) {
509  								NodeFlags[NId] = nsCNeigh;
510  								ParentNode[NId] = n;
511  								if(NIT < GetOutAdjSize(SSG, n)) {
512  									ParentTypes[NId] = mpParentTypeOut;
513  								} else {
514  									ParentTypes[NId] = mpParentTypeIn;
515                  }
516  								MapStateToNode[NQueueR] = NId;
517  								MapNodeToState[NId] = NQueueR;
518  								NQueueR++;
519  								NNIT = 0;
520  								while(NNIT < GetInAdjSize(SSG, NId)){
521  									NNId = GetNthInAdjList(SSG, NId, NNIT);
522  									Weights[NNId][1]++;
523  									NNIT++;
524  								}
525  							}
526  						}
527  						NIT++;
528  					}
529  					SId++;
530  				}
531  			}
532      }
533      while(SId < NofSn) {
534  			if(NQueueL == NQueueR) {
535  				MaxId = -1;
536  				MaxV = -1;
537  				NIT = 0;
538  				while(NIT < NofSn) {
539  					if(NodeFlags[NIT] == nsUnv && Weights[NIT][2] > MaxV) {
540  						MaxV = Weights[NIT][2];
541  						MaxId = NIT;
542  					}
543  					NIT++;
544  				}
545  				MapStateToNode[SId] = MaxId;
546  				MapNodeToState[MaxId] = SId;
547  				ParentTypes[MaxId] = mpParentTypeNull;
548  				ParentNode[MaxId] = -1;
549  				NQueueR++;
550  				n = MaxId;
551  				NIT = 0;
552  				while(NIT < GetOutAdjSize(SSG, n)) {
553  					NId = GetNthOutAdjList(SSG, n, NIT);
554  					if(NId != n) { Weights[NId][1]++; }
555  					NIT++;
556  				}
557          while(NIT < GetInAdjSize(SSG, n)) {
558  					NId = GetNthInAdjList(SSG, n, NIT);
559  					if(NId != n) { Weights[NId][1]++; }
560  					NIT++;
561  				}
562  			}
563  			if(NQueueL != NQueueR-1) {
564  				MaxId = NQueueL;
565  				for(int mi = MaxId+1; mi < NQueueR; mi++) {
566  					if(WCompare(MapStateToNode[mi], MapStateToNode[MaxId], Weights) < 0) {
567  						MaxId = mi;
568  					}
569  				}
570  				Tmp = MapStateToNode[NQueueL];
571  				MapStateToNode[NQueueL] = MapStateToNode[MaxId];
572  				MapStateToNode[MaxId] = Tmp;
573  			}
574  			n = MapStateToNode[SId];
575  			MapNodeToState[n] = SId;
576  			NQueueL++;
577  			NodeFlags[n] = nsCore;
578  			NIT = 0;
579  			while(NIT < GetOutAdjSize(SSG, n)) {
580  				NId = GetNthOutAdjList(SSG, n, NIT);
581  				if(NId != n) {
582  					Weights[NId][0]++;
583  					Weights[NId][1]--;
584  					if(NodeFlags[NId] == nsUnv) {
585  						NodeFlags[NId] = nsCNeigh;
586  						ParentNode[NId] = n;
587  						if(NIT < GetOutAdjSize(SSG, n)) {
588  							ParentTypes[NId] = mpParentTypeOut;
589              } else {
590  							ParentTypes[NId] = mpParentTypeIn;
591              }
592  						MapStateToNode[NQueueR] = NId;
593  						MapNodeToState[NId] = NQueueR;
594  						NQueueR++;
595  						NNIT = 0;
596  						while(NNIT < GetOutAdjSize(SSG, NId)) {
597  							NNId = GetNthOutAdjList(SSG, NId, NNIT);
598  							Weights[NNId][1]++;
599  							NNIT++;
600  						}
601  					}
602  				}
603  				NIT++;
604  			}
605        NIT = 0;
606  			while(NIT < GetInAdjSize(SSG, n)) {
607  				NId = GetNthInAdjList(SSG, n, NIT);
608  				if(NId != n) {
609  					Weights[NId][0]++;
610  					Weights[NId][1]--;
611  					if(NodeFlags[NId] == nsUnv) {
612  						NodeFlags[NId] = nsCNeigh;
613  						ParentNode[NId] = n;
614  						if(NIT < GetOutAdjSize(SSG, n)) {
615  							ParentTypes[NId] = mpParentTypeOut;
616              } else {
617  							ParentTypes[NId] = mpParentTypeIn;
618              }
619  						MapStateToNode[NQueueR] = NId;
620  						MapNodeToState[NId] = NQueueR;
621  						NQueueR++;
622  						NNIT = 0;
623  						while(NNIT < GetInAdjSize(SSG, NId)) {
624  							NNId = GetNthInAdjList(SSG, NId, NNIT);
625  							Weights[NNId][1]++;
626  							NNIT++;
627  						}
628  					}
629  				}
630  				NIT++;
631  			}
632  			SId++;
633  		}
634      int ECount, OutECount, InECount; int i;
635      for (SId = 0; SId < NofSn; SId++) {
636        n = MapStateToNode[SId];
637        NodesAttrs[SId] = &SSG->GetNI(n).GetDat();
638        if (ParentNode[n] != -1) {
639          ParentState[SId] = MapNodeToState[ParentNode[n]];
640        } else {
641          ParentState[SId] = -1;
642        }
643        ParentType[SId] = ParentTypes[n];
644        ECount = 0;
645        OutECount = 0;
646        for (i = 0; i < GetOutAdjSize(SSG, n); i++) {
647          if (MapNodeToState[GetNthOutAdjList(SSG, n, i)] < SId) {
648              ECount++;
649              OutECount++;
650          }
651        }
652        InECount = 0;
653        for (i = 0; i < GetInAdjSize(SSG, n); i++) {
654          if (MapNodeToState[GetNthInAdjList(SSG, n, i)] < SId) {
655              ECount++;
656              InECount++;
657          }
658        }
659        EdgesSizes[SId] = ECount;
660        OutEdgesSizes[SId] = OutECount;
661  			InEdgesSizes[SId] = InECount;
662        Edges[SId] = new TMaMaEdge[ECount];
663        ECount = 0;
664        for (i = 0; i < GetOutAdjSize(SSG, n); i++) {
665          int m = GetNthOutAdjList(SSG, n, i);
666          if (MapNodeToState[m] < SId) {
667            Edges[SId][ECount].SetSource(MapNodeToState[n]);
668            Edges[SId][ECount].SetTarget(MapNodeToState[m]);
669            Edges[SId][ECount].SetAttr(&SSG->GetEI(n, m).GetDat());
670            ECount++;
671          }
672        }
673        for (i = 0; i < GetInAdjSize(SSG, n);i++) {
674          int m = GetNthInAdjList(SSG, n, i);
675          if (MapNodeToState[m] < SId) {
676            Edges[SId][ECount].SetTarget(MapNodeToState[n]);
677            Edges[SId][ECount].SetSource(MapNodeToState[m]);
678            Edges[SId][ECount].SetAttr(&SSG->GetEI(m, n).GetDat());
679            ECount++;
680          }
681        }
682      }
683      delete[] NodeFlags;
684      for (int i = 0; i < NofSn; i++) {
685        delete[] Weights[i];
686      }
687      delete[] Weights;
688      free(ParentNode);
689      delete[] ParentTypes;
690    }
691    void print() {
692      printf("| MatchingMachine:  nof states %d\n", NofSn);
693      printf("| \tmap state_to_node(");
694      for (int i = 0; i < NofSn; i++) {
695        printf("[%d: %d]", i, MapStateToNode[i]);
696      }
697      printf(")\n");
698      printf("| \tmap node_to_state(");
699      for (int i = 0; i < NofSn; i++) {
700        printf("[: %d]", i, MapNodeToState[i]);
701      }
702      printf(")\n");
703      printf("| \tstates (node)(parent state, parent type)\n");
704      for (int i = 0; i < NofSn; i++) {
705        printf("| \t\t[%d] (%d) (%d, ", i, MapStateToNode[i], ParentState[i]);
706        switch (ParentType[i]) {
707          case mpParentTypeIn:
708            printf("IN");
709            break;
710          case mpParentTypeOut:
711            printf("OUT");
712            break;
713          case mpParentTypeNull:
714            printf("NULL");
715            break;
716        }
717        printf(")\n");
718        printf("| \t\t\tchecking[%d] ", EdgesSizes[i]);
719        for (int j = 0; j < EdgesSizes[i]; j++) {
720          printf("{s(%d,%d):", Edges[i][j].GetSource(), Edges[i][j].GetTarget());
721          printf("n(%d,%d)}", MapStateToNode[Edges[i][j].GetSource()],
722            MapStateToNode[Edges[i][j].GetTarget()]);
723        }
724        printf("\n");
725      }
726    }
727    TMaMaEdge** GetEdges() const { return Edges; }
728    int* GetEdgesSizes() const { return EdgesSizes; }
729    int* GetOutEdgesSizes() const { return OutEdgesSizes; }
730    int* GetInEdgesSizes() const { return InEdgesSizes; }
731    int* GetMapNodeToState() const { return MapNodeToState; }
732    int* GetMapStateToNode() const { return MapStateToNode; }
733    TNodeData** GetNodesAttrs() const { return NodesAttrs; }
734    int GetNofSn() const { return NofSn; }
735    int* GetParentState() const { return ParentState;}
736    TMamaParent* GetParentType() const {
737      return ParentType;
738    }
739    void SetEdges(TMaMaEdge** edges) { this->Edges = edges; }
740    void SetEdgesSizes(int* edges_sizes) { this->EdgesSizes = edges_sizes; }
741    void SetMapNodeToState(int* MapNodeToState) {
742      this->MapNodeToState = MapNodeToState;
743    }
744    void SetMapStateToNode(int* MapStateToNode) {
745      this->MapStateToNode = MapStateToNode;
746    }
747    void SetNodesAttrs(TNodeData** nodes_attrs) {
748      this->NodesAttrs = nodes_attrs;
749    }
750    void SetNofSn(int nof_sn) { this->NofSn = nof_sn; }
751    void SetParentState(int* parent_state) {
752      this->ParentState = parent_state;
753    }
754    void SetParentType(TMamaParent* parent_type) {
755      this->ParentType = parent_type;
756    }
757  };
758  class TMatchListener {
759  protected:
760    long MatchCount;
761  public:
762    TMatchListener() { MatchCount = 0; }
763    virtual ~TMatchListener() { };
764    long GetMatchCount() const { return MatchCount; }
765    void SetMatchCount(long NMatchCount) { MatchCount = NMatchCount; }
766    virtual void Match(int n, int* QIds, int* RIds) = 0;
767  };
768  class TEmptyMatchListener : public TMatchListener {
769  public:
770    TEmptyMatchListener() : TMatchListener() { }
771    virtual void Match(int n, int* QIds, int* RIds) {
772      MatchCount++;
773    };
774  };
775  class TConsoleMatchListener : public TMatchListener {
776  public:
777    TConsoleMatchListener() : TMatchListener() { }
778    virtual void Match(int n, int* QIds, int* RIds) {
779      MatchCount++;
780      printf("{");
781      for (int i = 0; i < n; i++) {
782        printf("(%d,%d)", QIds[i], RIds[i]);
783      }
784      printf("}\n");
785    }
786  };
787  template<class TNodeData, class TEdgeData>
788  class TSolver {
789  protected:
790    TMatchingMachine<TNodeData, TEdgeData> &MaMa;
791    TPt<TNodeEDatNet<TNodeData, TEdgeData> > &RGraph;
792    TPt<TNodeEDatNet<TNodeData, TEdgeData> > &QGraph;
793    TMatchListener &MatchListener;
794    TSBitSet* Domains;
795    int* DomainsSize;
796  private:
797  public:
798    TSolver(TMatchingMachine<TNodeData, TEdgeData> &NMaMa,
799      TPt<TNodeEDatNet<TNodeData, TEdgeData> > &NRGraph,
800      TPt<TNodeEDatNet<TNodeData, TEdgeData> > &NQGraph,
801      TMatchListener &NMatchListener, TSBitSet* NDomains, int* NDomainsSize ) :
802        MaMa(NMaMa), RGraph(NRGraph), QGraph(NQGraph),
803        MatchListener(NMatchListener), Domains(NDomains),
804        DomainsSize(NDomainsSize) {
805    }
806    virtual ~TSolver() { }
807    void Solve() {
808      int IId;
809      int NofSn = MaMa.GetNofSn();
810      int* MapStateToNode = MaMa.GetMapStateToNode();
811      int* ParentState = MaMa.GetParentState();
812      TMamaParent* ParentType = MaMa.GetParentType();
813      TNodeList** Candidates = new TNodeList*[NofSn];
814      int* CandidatesIt = new int[NofSn];
815      int* CandidatesSize = new int[NofSn];
816      int* Solution = new int[NofSn];
817      for (IId = 0; IId < NofSn; IId++) {
818        Solution[IId] = -1;
819      }
820      bool* Matched = (bool*) calloc(RGraph->GetNodes(), sizeof(bool));
821      for(int i=0; i < NofSn; i++){
822  			if(ParentType[i] == mpParentTypeNull){
823  				int n = MapStateToNode[i];
824          Candidates[i] = new TCandidatesList<TNodeData, TEdgeData>(RGraph,
825            DomainsSize[n]);
826  				for(TSBitSet::TIterator IT = Domains[n].FirstOnes();
827                  IT != Domains[n].End(); IT.next_ones()){
828  					Candidates[i]->AddNode(IT.First);
829  				}
830  				CandidatesSize[i] = DomainsSize[n];
831  				CandidatesIt[i] = -1;
832  			}
833  		}
834      int PSId = -1;
835      int SId = 0;
836      int CId = -1;
837      int Sip1;
838      while (SId != -1) {
839        if (PSId >= SId) { Matched[Solution[SId]] = false; }
840        CId = -1;
841        CandidatesIt[SId]++;
842        while (CandidatesIt[SId] < CandidatesSize[SId]) {
843          CId = Candidates[SId]->GetNode(CandidatesIt[SId]);
844          Solution[SId] = CId;
845          if ((!Matched[CId]) &&
846               Domains[MapStateToNode[SId]].Get(CId) &&
847               EdgesCheck(SId, CId, Solution, Matched)) {
848            break;
849          } else {
850            CId = -1;
851          }
852          CandidatesIt[SId]++;
853        }
854        if (CId == -1) {
855          PSId = SId;
856          delete Candidates[SId];
857          SId--;
858        } else {
859          if (SId == NofSn -1) {
860            MatchListener.Match(NofSn, MapStateToNode, Solution);
861            PSId = SId;
862          } else {
863            Matched[Solution[SId]] = true;
864            Sip1 = SId + 1;
865            if (ParentType[Sip1] == mpParentTypeNull) {
866            } else {
867              if (ParentType[Sip1] == mpParentTypeIn) {
868                Candidates[Sip1] = new TInAdjList<TNodeData, TEdgeData>(RGraph,
869                  Solution[ParentState[Sip1]]);
870                CandidatesSize[Sip1] = GetInAdjSize(RGraph,
871                  Solution[ParentState[Sip1]]);
872              } else {
873                Candidates[Sip1] = new TOutAdjList<TNodeData, TEdgeData>(RGraph,
874                  Solution[ParentState[Sip1]]);
875                CandidatesSize[Sip1] = GetOutAdjSize(RGraph,
876                  Solution[ParentState[Sip1]]);
877              }
878            }
879            CandidatesIt[SId + 1] = -1;
880            PSId = SId;
881            SId++;
882          }
883        }
884      }
885    }
886    virtual bool EdgesCheck(int SId, int CId, int* Solution, bool* Matched)=0;
887  };
888  template<class TNodeData, class TEdgeData>
889  class TInducedSubGISolver : public TSolver<TNodeData, TEdgeData> {
890  using TSolver<TNodeData, TEdgeData>::RGraph;
891  using TSolver<TNodeData, TEdgeData>::QGraph;
892  using TSolver<TNodeData, TEdgeData>::MaMa;
893  public:
894    TInducedSubGISolver(TMatchingMachine<TNodeData, TEdgeData> &NMaMa,
895      TPt<TNodeEDatNet<TNodeData, TEdgeData> > &NRGraph,
896      TPt<TNodeEDatNet<TNodeData, TEdgeData> > &NQGraph,
897      TMatchListener &NMatchListener,
898      TSBitSet* NDomains,
899      int* NDomainsSize) : TSolver<TNodeData, TEdgeData>(NMaMa,
900        NRGraph, NQGraph, NMatchListener, NDomains, NDomainsSize) {
901    }
902    virtual bool EdgesCheck(int SId, int CId, int* Solution, bool* Matched) {
903      int RSource, RTarget, Source, Target, EId;
904      int IId;
905      for (int me = 0; me < MaMa.GetEdgesSizes()[SId]; me++) {
906        Source = MaMa.GetEdges()[SId][me].GetSource();
907        Target = MaMa.GetEdges()[SId][me].GetTarget();
908        RSource = Solution[Source];
909  			RTarget = Solution[Target];
910  			EId = Solution[MaMa.GetEdges()[SId][me].GetId()];
911        for (IId = 0; IId < GetOutAdjSize(RGraph, RSource); IId++) {
912          if (GetNthOutAdjList(RGraph, RSource, IId) == RTarget) {
913            if (RGraph->GetEI(RSource, GetNthOutAdjList(RGraph, RSource, IId)).GetDat() != 
914                 *MaMa.GetEdges()[SId][me].GetAttr()) {
915              return false;
916            } else {
917              break;
918            }
919          } else if(GetNthOutAdjList(RGraph, RSource, IId) > RTarget) {
920              return false;
921          }
922        }
923      }
924      int Count = 0;
925      for (IId = 0; IId < GetOutAdjSize(RGraph, CId); IId++) {
926        if (Matched[GetNthOutAdjList(RGraph, CId, IId)]) {
927          Count++;
928          if (Count > MaMa.GetOutEdgesSizes()[SId])
929            return false;
930        }
931      }
932      Count = 0;
933      for (IId = 0; IId < GetInAdjSize(RGraph, CId); IId++) {
934        if (Matched[GetNthInAdjList(RGraph, CId, IId)]) {
935          Count++;
936          if (Count > MaMa.GetInEdgesSizes()[SId])
937            return false;
938        }
939      }
940      return true;
941    }
942  };
943  template <class TNodeData, class TEdgeData>
944  class SubGISolver : public TSolver<TNodeData, TEdgeData> {
945  using TSolver<TNodeData, TEdgeData>::RGraph;
946  using TSolver<TNodeData, TEdgeData>::QGraph;
947  using TSolver<TNodeData, TEdgeData>::MaMa;
948  public:
949    SubGISolver(TMatchingMachine<TNodeData, TEdgeData> &NMaMa,
950      TPt<TNodeEDatNet<TNodeData, TEdgeData> > &NRGraph,
951      TPt<TNodeEDatNet<TNodeData, TEdgeData> > &NQGraph,
952      TMatchListener &NMatchListener,
953      TSBitSet* NDomains,
954      int* NDomainsSize) : TSolver<TNodeData, TEdgeData>(NMaMa,
955        NRGraph, NQGraph, NMatchListener, NDomains, NDomainsSize) {
956    }
957    virtual bool EdgesCheck(int SId, int CId, int* Solution, bool* Matched) {
958      int RSource, RTarget, Source, Target, EId;
959      int IId;
960      for (int me = 0; me < MaMa.GetEdgesSizes()[SId]; me++) {
961        Source = MaMa.GetEdges()[SId][me].GetSource();
962        Target = MaMa.GetEdges()[SId][me].GetTarget();
963        RSource = Solution[Source];
964  			RTarget = Solution[Target];
965        EId = Solution[MaMa.GetEdges()[SId][me].GetId()];
966        for (IId = 0; IId < GetOutAdjSize(RGraph, RSource); IId++) {
967          if (GetNthOutAdjList(RGraph, RSource, IId) == RTarget) {
968            if (RGraph->GetEI(RSource, GetNthOutAdjList(RGraph, RSource, IId)).GetDat() !=
969                 *MaMa.GetEdges()[SId][me].GetAttr()) {
970              return false;
971            } else {
972              break;
973            }
974          } else if(GetNthOutAdjList(RGraph, RSource, IId) > RTarget){
975  					return false;
976  				}
977        }
978        if (IId >= GetOutAdjSize(RGraph, RSource)) {
979          return false;
980        }
981      }
982      return true;
983    }
984  };
985  template <class TNodeData, class TEdgeData>
986  bool InitDomains(TPt<TNodeEDatNet<TNodeData, TEdgeData> > &Target,
987    TPt<TNodeEDatNet<TNodeData, TEdgeData> > &Pattern,
988  	TSBitSet* Domains,
989  	bool Iso) {
990  	if(Iso) {
991  		for(int q = 0; q < Pattern->GetNodes(); q++){
992  			for(int r = Target->GetNodes() - 1; r >= 0; r--){
993  				if(GetOutAdjSize(Target, r) == GetOutAdjSize(Pattern, q) &&
994            GetInAdjSize(Target, r) == GetInAdjSize(Pattern, q) &&
995            Target->GetNI(r).GetDat() == Pattern->GetNI(q).GetDat()) {
996  					Domains[q].Set(r, true);
997  				}
998  			}
999  			if(Domains[q].IsEmpty()) { return false; }
1000  		}
1001  	} else {
1002  		for(int q=0; q < Pattern->GetNodes(); q++) {
1003  			for(int r = Target->GetNodes()-1; r >= 0; r--) {
1004  				if(GetOutAdjSize(Target, r) >= GetOutAdjSize(Pattern, q) &&
1005            GetInAdjSize(Target, r) >= GetInAdjSize(Pattern, q) &&
1006            Target->GetNI(r).GetDat() == Pattern->GetNI(q).GetDat()) {
1007  					Domains[q].Set(r, true);
1008  				}
1009  			}
1010  			if(Domains[q].IsEmpty()){ return false; }
1011  		}
1012  	}
1013  	int ra, qb, rb;
1014  	bool NotFound;
1015  	for(int qa = 0; qa < Pattern->GetNodes(); qa++) {
1016      for(TSBitSet::TIterator qaIT = Domains[qa].FirstOnes(); qaIT !=
1017              Domains[qa].End(); qaIT.next_ones()){
1018  			ra = qaIT.First;
1019  			for(int i_qb = 0; i_qb < GetOutAdjSize(Pattern, qa); i_qb++) {
1020  				qb = GetNodeInAdjList(Pattern, qa, i_qb);
1021  				NotFound = true;
1022  				for(int i_rb=0; i_rb < GetOutAdjSize(Target, ra); i_rb++) {
1023  					rb = GetNthOutAdjList(Target, ra, i_rb);
1024            int m = GetNthOutAdjList(Pattern, qa, i_qb);
1025            int s = GetNthOutAdjList(Target, ra, i_rb);
1026  					if(Domains[qb].Get(rb) &&
1027              Pattern->GetEI(qa, m).GetDat() == Target->GetEI(ra, s).GetDat()){
1028  						NotFound = false;
1029  						break;
1030  					}
1031  				}
1032  				if(NotFound) {
1033  					Domains[qa].Set(ra, false);
1034  					break;
1035  				}
1036  			}
1037  		}
1038  		if(Domains[qa].IsEmpty()) { return false; }
1039  	}
1040  	return true;
1041  };
1042  template<class TNodeData, class TEdgeData>
1043  void Match(TPt<TNodeEDatNet<TNodeData, TEdgeData> > &Reference,
1044    TPt<TNodeEDatNet<TNodeData, TEdgeData> > &Query,
1045    TMatchingMachine<TNodeData, TEdgeData> &MatchingMachine,
1046    TMatchListener &MatchListener,
1047    TMatch MatchType,
1048    TSBitSet* Domains,
1049    int* DomainsSize) {
1050      TSolver<TNodeData, TEdgeData>* Solver;
1051      switch (MatchType) {
1052        case mIso:
1053        case mIndSub:
1054          Solver = new TInducedSubGISolver<TNodeData, TEdgeData>(MatchingMachine,
1055            Reference,
1056            Query,
1057            MatchListener,
1058            Domains,
1059            DomainsSize);
1060          break;
1061        case mMono:
1062          Solver = new SubGISolver<TNodeData, TEdgeData>(MatchingMachine,
1063            Reference,
1064            Query,
1065            MatchListener,
1066            Domains,
1067            DomainsSize);
1068          break;
1069      }
1070      Solver->Solve();
1071      /&bsol;*Steps = Solver->GetSteps();
1072      /&bsol;*TriedCouples = Solver->GetTriedCouples();
1073      /&bsol;*MatchedCouples = Solver->GetMatchedCouples();
1074      delete Solver;
1075  };
1076  template <class TNodeData, class TEdgeData>
1077  int Match(TMatch MatchType, TPt<TNodeEDatNet<TNodeData, TEdgeData> > &RefGraph,
1078    TPt<TNodeEDatNet<TNodeData, TEdgeData> > &QueGraph);
1079  template <class TNodeData, class TEdgeData>
1080  int Match(TMatch MatchType,
1081    TPt<TNodeEDatNet<TNodeData, TEdgeData> > &RefGraph,
1082    TPt<TNodeEDatNet<TNodeData, TEdgeData> > &QueGraph) {
1083  	bool DoBijIso = (MatchType == mIso);
1084      long MatchCount = 0;
1085  #ifdef PRINT_MATCHES
1086  		TMatchListener* MatchListener = new TConsoleMatchListener();
1087  #else
1088  		TMatchListener* MatchListener = new TEmptyMatchListener();
1089  #endif
1090      if(!DoBijIso ||
1091        (DoBijIso && (QueGraph->GetNodes() == RefGraph->GetNodes()))) {
1092        TSBitSet* Domains = new TSBitSet[QueGraph->GetNodes()];
1093        bool Domok = InitDomains(RefGraph, QueGraph, Domains, DoBijIso);
1094        if(Domok){
1095          int* DomainsSize = new int[QueGraph->GetNodes()];
1096          int dsize;
1097          for(int ii=0; ii < QueGraph->GetNodes(); ii++){
1098            dsize = 0;
1099            for(TSBitSet::TIterator IT = Domains[ii].FirstOnes(); IT!=Domains[ii].End(); IT.next_ones()){
1100              dsize++;
1101            }
1102            DomainsSize[ii] = dsize;
1103          }
1104          TMatchingMachine<TNodeData, TEdgeData>* MaMa =
1105            new TMatchingMachine<TNodeData, TEdgeData>(QueGraph, Domains, DomainsSize);
1106          MaMa->Build(QueGraph);
1107          Match(RefGraph,
1108            QueGraph,
1109            *MaMa,
1110            *MatchListener,
1111            MatchType,
1112            Domains,
1113            DomainsSize);
1114          delete MaMa;
1115        }
1116      }
1117  		if(MatchListener != NULL) { MatchCount += MatchListener->GetMatchCount(); }
1118  		delete MatchListener;
1119  #ifdef CSV_FORMAT
1120  	std::cout<<referencefile<<"\t"<<queryfile<<"\t";
1121  	std:cout<<load_t_q<<"\t"<<make_mama_t<<"\t"<<load_t<<"\t"<<match_t<<"\t"<<total_t<<"\t"<<Steps<<"\t"<<TriedCouples<<"\t"<<MatchedCouples<<"\t"<<MatchCount;
1122  #else
1123  	printf("number of found matches: %ld\n", MatchCount);
1124  #endif
1125  	return 0;
1126  };
1127  #endif	&bsol;* RI3_H */
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-netobj.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-rids.h</div>
                </div>
                <div class="column column_space"><pre><code>18    bool operator==(const TNetObj&){return true;}
19    void PutSockId(const int& _SockId){SockId=_SockId;}
</pre></code></div>
                <div class="column column_space"><pre><code>371      int GetId() const { return Id; }
372      void SetSource(const int ValSource){ Source = ValSource; }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    