
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-biling.cpp</h3>
            <pre><code>1  void TEvalScore::Tokenize(const TStr& Str, TStrV& TokenV) {
2      TStr LcStr = GetLc(Str);
3      TokenV.Clr(); TChA WordChA;
4      const int Chs = LcStr.Len();
5      for (int ChN = 0; ChN < Chs; ChN++) {
6          const char Ch = LcStr[ChN];
7          if (IsChar(Ch)) {
8              WordChA += Ch;
9          } else if (!WordChA.Empty()) {
10              TokenV.Add(WordChA);
11              WordChA.Clr();
12          }
13      }
14  }
15  void TEvalScore::Parse(const TStr& Str, TIntV& WIdV) {
16      TStrV TokenV; Tokenize(Str, TokenV); WIdV.Clr();
17      for (int WdN = 0; WdN < TokenV.Len(); WdN++) {
18          TStr WdStr = TokenV[WdN];
19          int WId = WordH.GetKeyId(WdStr);
20          if (WId == -1) { WId = WordH.AddKey(WdStr); }
21          WIdV.Add(WId);
22      }
23  }
24  void TEvalScore::GetNGramH(const TIntV& WIdV,
25          const int& MxNGramLen, TIntH& NGramIdH) {
26      const int Wds = WIdV.Len();
27      for (int NGramLen = 1; NGramLen <= MxNGramLen; NGramLen++) {
28          const int MxNGramStart = Wds - NGramLen + 1;
29          for (int NGramStart = 0; NGramStart < MxNGramStart; NGramStart++) {
30              TIntV NGram; WIdV.GetSubValV(NGramStart, NGramStart+NGramLen-1, NGram);
31              IAssert(NGram.Len() == NGramLen);
32              int NGramId = NGramH.GetKeyId(NGram);
33              if (NGramId == -1) { NGramId = NGramH.AddKey(NGram); }
34              NGramIdH.AddDat(NGramId)++;
35          }
36      }
37  }
38  PMom TEvalScore::EvalSig(const PTransCorpus& TransCorpus,
39          const int& Samples, const int& SampleSize, const int& Seed) {
40      TIntV SentIdV; TransCorpus->GetSentIdV(SentIdV);
41      TRnd Rnd(Seed); PMom Mom = TMom::New();
42      for (int SampleN = 0; SampleN < Samples; SampleN++) {
43          TIntV SampleIdV = SentIdV;
44          SampleIdV.Shuffle(Rnd);
45          SampleIdV.Trunc(SampleSize);
46          Mom->Add(Eval(TransCorpus, SampleIdV));
47      }
48      Mom->Def();
49      return Mom;
50  }
51  double TEvalScoreBleu::Eval(const PTransCorpus& TransCorpus, const TIntV& _SentIdV) {
52      IAssert(TransCorpus->IsTrans());
53      TIntH ClipCountNGramH, CountNGramH;
54      int FullTransLen = 0, FullRefLen = 0;
55      TIntV SentIdV = _SentIdV;
56      if (SentIdV.Empty()) { TransCorpus->GetSentIdV(SentIdV); }
57      const int Sents = SentIdV.Len();
58      for (int SentIdN = 0; SentIdN < Sents; SentIdN++) {
59          const int SentId = SentIdV[SentIdN];
60          TIntV TransWIdV; Parse(TransCorpus->GetTransStr(SentId), TransWIdV);
61          TIntH TransNGramH; GetNGramH(TransWIdV, MxNGramLen, TransNGramH);
62          TIntH FreeTransNGramH = TransNGramH; 
63          const int TransLen = TransWIdV.Len();
64          int BestLen = 0, BestLenDiff = TInt::Mx;
65          TStrV RefTransStrV = TransCorpus->GetRefTransStrV(SentId);
66          for (int RefN = 0; RefN < RefTransStrV.Len(); RefN++) {
67              TIntV RefWIdV; Parse(RefTransStrV[RefN], RefWIdV);
68              TIntH RefNGramH; GetNGramH(RefWIdV, MxNGramLen, RefNGramH);
69              int TransNGramKeyId = TransNGramH.FFirstKeyId();
70              while(TransNGramH.FNextKeyId(TransNGramKeyId)) {
71                  const int NGramId = TransNGramH.GetKey(TransNGramKeyId);
72                  const int FreeTransNGrams = FreeTransNGramH(NGramId);
73                  if (RefNGramH.IsKey(NGramId) && (FreeTransNGrams>0)) {
74                      const int RefNGrams = RefNGramH(NGramId);
75                      FreeTransNGramH(NGramId) = TInt::GetMx(0, FreeTransNGrams - RefNGrams);
76                  }
77              }
78              const int RefLen = RefWIdV.Len();
79              const int LenDiff = TInt::Abs(TransLen - RefLen);
80              if (LenDiff < BestLenDiff) {
81                  BestLen = RefLen; BestLenDiff = LenDiff;
82              }
83          }
84          int TransNGramKeyId = TransNGramH.FFirstKeyId();
85          while(TransNGramH.FNextKeyId(TransNGramKeyId)) {
86              const int NGramId = TransNGramH.GetKey(TransNGramKeyId);
87              IAssert(NGramId != -1);
88              const int FreeNGramId = FreeTransNGramH.GetKey(TransNGramKeyId);
89              IAssert(NGramId == FreeNGramId);
90              const int Count = TransNGramH[TransNGramKeyId];
91              const int ClipCount = Count - FreeTransNGramH[TransNGramKeyId];
92              CountNGramH.AddDat(NGramId) += Count;
93              ClipCountNGramH.AddDat(NGramId) += ClipCount;
94          }
95          FullTransLen += TransLen;
96          FullRefLen += BestLen;
97      }
98      TIntV ClipCountV(MxNGramLen); ClipCountV.PutAll(0);
99      int ClipCountKeyId = ClipCountNGramH.FFirstKeyId();
100      while (ClipCountNGramH.FNextKeyId(ClipCountKeyId)) {
101          const int NGramId = ClipCountNGramH.GetKey(ClipCountKeyId);
102          const int NGramLen = GetNGramLen(NGramId);
103          IAssert(0 < NGramLen && NGramLen <= MxNGramLen);
104          ClipCountV[NGramLen-1] += ClipCountNGramH[ClipCountKeyId];
105      }
106      TIntV CountV(MxNGramLen); CountV.PutAll(0);
107      int CountKeyId = CountNGramH.FFirstKeyId();
108      while (CountNGramH.FNextKeyId(CountKeyId)) {
109          const int NGramId = CountNGramH.GetKey(CountKeyId);
110          const int NGramLen = GetNGramLen(NGramId);
111          IAssert(0 < NGramLen && NGramLen <= MxNGramLen);
112          CountV[NGramLen-1] += CountNGramH[CountKeyId];
113      }
114      TFltV PrecV(MxNGramLen, 0);
115      for (int NGramLen = 0; NGramLen < MxNGramLen; NGramLen++) {
116          const int ClipCount = ClipCountV[NGramLen];
117          const int Count = CountV[NGramLen];
118          const double Prec = (Count > 0) ? double(ClipCount)/double(Count) : 0.0;
119          PrecV.Add(Prec);
120          printf("%d-gram Match:%d Total:%d Prec:%.5f\n", NGramLen+1, ClipCount, Count, Prec);
121      }
122      double LogBP = TFlt::GetMn(0.0, 1.0 - double(FullRefLen)/double(FullTransLen));
123      double BP = exp(LogBP);
124      printf("Sentence Len: %d, Best-match Sntence Len: %d, Score: %.5f\n",
125          FullTransLen, FullRefLen, LogBP);
126      double BleuScore = BP;
127      const double Wgt = 1.0 / double(MxNGramLen);
128      for (int NGramLen = 0; NGramLen < MxNGramLen; NGramLen++) {
129          BleuScore *= pow(PrecV[NGramLen], Wgt);
130      }
131      printf("BLEU Score: %.5f\n", BleuScore);
132      return BleuScore;
133  }
134  void TTransCorpus::PutScriptHeader(const PSOut& SOut) {
135  }
136  void TTransCorpus::CleanTmx(const TStr& InTmxFNm, const TStr& OutXmlFNm) {
137      TFIn FIn(InTmxFNm); TFOut FOut(OutXmlFNm);
138      TStr ChStr; bool InTagP = false;
139      while (!FIn.Eof()) {
140          ChStr = TStr::GetChStr(FIn.GetCh());
141          if (ChStr == "<") { InTagP = true; FOut.PutStr(ChStr); }
142          else if (ChStr == ">") { InTagP = false; FOut.PutStr(ChStr); }
143          else if (!InTagP && ChStr != "\n" && ChStr != "\r") {
144              FOut.PutStr(TXmlDoc::GetXmlStr(ChStr));
145          } else { FOut.PutStr(ChStr); }
146      }
147  }
148  TStr TTransCorpus::CleanRtf(const TStr& InStr) {
149      TChA OutChA; int Chs = InStr.Len(); bool RtfTagP = false;
150      for (int ChN = 0; ChN < Chs; ChN++) {
151          const char Ch = InStr[ChN];
152          if (Ch == '{' || Ch == '}') { &bsol;* skip */ }
153          else if (Ch == '\\') { RtfTagP = true; }
154          else if (Ch == ' ' && RtfTagP) { RtfTagP = false; }
155          else if (!RtfTagP) { OutChA += Ch; }
156      }
157      return OutChA;
158  }
159  int TTransCorpus::CountWords(const TIntStrH& StrH) {
160      int Words = 0, KeyId = StrH.FFirstKeyId();
161      while (StrH.FNextKeyId(KeyId)) {
162          const TStr& Str = StrH[KeyId];
163          TStrV WordV; Str.SplitOnWs(WordV);
164          Words += WordV.Len();
165      }
166      return Words;
167  }
168  int TTransCorpus::CountWords(const TIntStrVH& StrVH, const bool& AllSents) {
169      int Words = 0, KeyId = StrVH.FFirstKeyId();
170      while (StrVH.FNextKeyId(KeyId)) {
171          const TStrV& StrV = StrVH[KeyId];
172          if (AllSents) {
173              for (int StrN = 0; StrN < StrV.Len(); StrN++) {
174                  TStrV WordV; StrV[StrN].SplitOnWs(WordV);
175                  Words += WordV.Len();
176              }
177          } else {
178              TStrV WordV; StrV[0].SplitOnWs(WordV);
179              Words += WordV.Len();
180          }
181      }
182      return Words;
183  }
184  inline void TTransCorpus::AddSentenceNoTrans(const int& SentId,
185          const TStr& OrgStr, const TStr& RefTransStr) {
186      AddSentenceNoTrans(SentId, OrgStr, TStrV::GetV(RefTransStr));
187  }
188  void TTransCorpus::AddSentenceNoTrans(const int& SentId,
189          const TStr& OrgStr, const TStrV& RefTransStrV) {
190      if (OrgStr.Empty()) { return; }
191      if (RefTransStrV[0].Empty()) { return; }
192      IAssert(!OrgStrH.IsKey(SentId));
193      OrgStrH.AddDat(SentId, OrgStr);
194      RefTransStrVH.AddDat(SentId, RefTransStrV);
195      const int OrgKeyId = OrgStrH.GetKeyId(SentId);
196      const int RefTransKeyId = RefTransStrVH.GetKeyId(SentId);
197      IAssert(OrgKeyId == RefTransKeyId);
198  }
199  inline void TTransCorpus::AddSentenceNoOrg(const int& SentId,
200          const TStr& TransStr, const TStr& RefTransStr) {
201      AddSentenceNoOrg(SentId, TransStr, TStrV::GetV(RefTransStr));
202  }
203  void TTransCorpus::AddSentenceNoOrg(const int& SentId,
204          const TStr& TransStr, const TStrV& RefTransStrV) {
205      IAssert(!TransStrH.IsKey(SentId));
206      TransStrH.AddDat(SentId, TransStr);
207      RefTransStrVH.AddDat(SentId, RefTransStrV);
208      const int TransKeyId = TransStrH.GetKeyId(SentId);
209      const int RefTransKeyId = RefTransStrVH.GetKeyId(SentId);
210      IAssert(TransKeyId == RefTransKeyId);
211  }
212  inline void TTransCorpus::AddSentence(const int& SentId, const TStr& OrgStr,
213          const TStr& TransStr, const TStr& RefTransStr) {
214      AddSentence(SentId, OrgStr, TransStr, TStrV::GetV(RefTransStr));
215  }
216  void TTransCorpus::AddSentence(const int& SentId, const TStr& OrgStr,
217          const TStr& TransStr, const TStrV& RefTransStrV) {
218      IAssert(!OrgStrH.IsKey(SentId));
219      OrgStrH.AddDat(SentId, OrgStr);
220      TransStrH.AddDat(SentId, TransStr);
221      RefTransStrVH.AddDat(SentId, RefTransStrV);
222      const int OrgKeyId = OrgStrH.GetKeyId(SentId);
223      const int TransKeyId = TransStrH.GetKeyId(SentId);
224      const int RefTransKeyId = RefTransStrVH.GetKeyId(SentId);
225      IAssert(OrgKeyId == TransKeyId);
226      IAssert(OrgKeyId == RefTransKeyId);
227  }
228  void TTransCorpus::GetSentIdV(TIntV& SentIdV) const {
229      if (IsOrg()) { OrgStrH.GetKeyV(SentIdV); }
230      else if (IsTrans()) { TransStrH.GetKeyV(SentIdV); }
231      else if (IsRefTrans()) { RefTransStrVH.GetKeyV(SentIdV); }
232      else { Fail; }
233  }
234  PTransCorpus TTransCorpus::LoadAC(const TStr& InXmlFNm, const int& MxSents) {
235      PTransCorpus TransCorpus = TTransCorpus::New();
236      PSIn XmlSIn=TFIn::New(InXmlFNm);
237      TXmlDoc::SkipTopTag(XmlSIn); 
238      printf("Ignoring: %s\n", TXmlDoc::LoadTxt(XmlSIn)->GetTok()->GetTagNm().CStr()); 
239      TXmlDoc::SkipTopTag(XmlSIn); 
240      TXmlDoc::SkipTopTag(XmlSIn); 
241      PXmlDoc XmlDoc; int XmlDocs = 0, SentId = 0;;
242      forever{
243          XmlDocs++; printf("%7d Sentences \r", SentId);
244          XmlDoc=TXmlDoc::LoadTxt(XmlSIn);
245          if (!XmlDoc->IsOk()) { &bsol;*printf("Error: %s\n", XmlDoc->GetMsgStr().CStr());*/ break; }
246          PXmlTok TopTok=XmlDoc->GetTok();
247          if (TopTok->IsTag("div")){
248              TStr DocNm = TopTok->GetArgVal("n");
249              TXmlTokV LinkTokV; TopTok->GetTagTokV("linkGrp|link", LinkTokV);
250              for (int LinkTokN = 0; LinkTokN < LinkTokV.Len(); LinkTokN++) {
251                  PXmlTok LinkTok = LinkTokV[LinkTokN];
252                  TStr LinkType = LinkTok->GetArgVal("type");
253                  if (LinkType == "1:1") {
254                      TXmlTokV S1TokV; LinkTok->GetTagTokV("s1", S1TokV);
255                      TXmlTokV S2TokV; LinkTok->GetTagTokV("s2", S2TokV);
256                      IAssert(S1TokV.Len() == 1); IAssert(S2TokV.Len() == 1);
257                      TStr ParaStr1 = S1TokV[0]->GetTagTokStr("");
258                      TStr ParaStr2 = S2TokV[0]->GetTagTokStr("");
259                      TransCorpus->AddSentenceNoTrans(SentId, ParaStr1, ParaStr2); SentId++;
260                  }
261              }
262          } else {
263              printf("Unknow tag: %s\n", TopTok->GetTagNm().CStr());
264          }
265          if ((MxSents != -1) && (TransCorpus->GetSentences() > MxSents)) { break; }
266      }
267      printf("\n");
268      return TransCorpus;
269  }
270  PTransCorpus TTransCorpus::LoadEP(const TStr& InOrgFPath, const TStr& InTransFPath) {
271      PTransCorpus TransCorpus = TTransCorpus::New();
272      TStr NrmInTransFPath = TStr::GetNrAbsFPath(InTransFPath);
273      TFFile OrgFNms(InOrgFPath, "txt", false); TStr OrgFNm;
274      int SentId = 0;
275      while (OrgFNms.Next(OrgFNm)) {
276          TStr TransFNm = NrmInTransFPath + OrgFNm.GetFBase();
277          IAssertR(TFile::Exists(TransFNm), TransFNm);
278          printf("Loading %s and %s ...\r", OrgFNm.CStr(), TransFNm.CStr());
279          TLnRet OrgLnRet(TFIn::New(OrgFNm));
280          TLnRet TransLnRet(TFIn::New(TransFNm));
281          TStr OrgLn, TransLn; int LnN = 1; bool EmptyLnP = false;
282          while (OrgLnRet.NextLn(OrgLn)) {
283              if (!TransLnRet.NextLn(TransLn)) {
284                  printf("\nEarly stop in line (%s:%s)[%d]\n", OrgLn.CStr(), TransLn.CStr(), LnN);
285                  break; 
286              }
287              if (OrgLn.Empty() || TransFNm.Empty()) {
288                  EmptyLnP = true;
289              } else if (OrgLn[0] == '<' || TransLn[0] == '<') {
290                  if (TransLn[0] != OrgLn[0]) {
291                      printf("\nError in line (%s:%s)[%d]\n", OrgLn.CStr(), TransLn.CStr(), LnN);
292                      break; 
293                  }
294                  EmptyLnP = false;
295              } else if (!EmptyLnP) {
296                  TransCorpus->AddSentenceNoTrans(SentId,
297                      OrgLn.ToTrunc(), TransLn.ToTrunc());
298                  SentId++;
299              }
300              LnN++;
301          }
302      }
303      printf("\nDone!\n");
304      return TransCorpus;
305  }
306  PTransCorpus TTransCorpus::LoadTMX(const TStr& InTmxFPath,
307          const TStr& OrgLang, const TStr& RefTransLang) {
308      PTransCorpus TransCorpus = TTransCorpus::New();
309      TFFile TmxFNms(InTmxFPath, "tmx", false); TStr TmxFNm; int SentId = 0;
310      while (TmxFNms.Next(TmxFNm)) {
311          printf("Loading %s ...\n", TmxFNm.CStr());
312          TStr CleanTmxFNm = TmxFNm + ".xml";
313          CleanTmx(TmxFNm, CleanTmxFNm);
314          PSIn XmlSIn = TFIn::New(CleanTmxFNm);
315          PXmlDoc XmlDoc = TXmlDoc::LoadTxt(XmlSIn);
316          if (!XmlDoc->IsOk()) {
317              printf(" error: %s\n", XmlDoc->GetMsgStr().CStr());
318              continue;
319          }
320          TXmlTokV TuTokV; XmlDoc->GetTagTokV("tmx|body|tu", TuTokV);
321          const int TuToks = TuTokV.Len();
322          for (int TuTokN = 0; TuTokN < TuToks; TuTokN++) {
323              if (TuTokN % 100 == 0) { printf(" %d / %d\r", TuTokN, TuToks); }
324              TXmlTokV TuvTokV; TuTokV[TuTokN]->GetTagTokV("tuv", TuvTokV);
325              IAssert(TuvTokV.Len() == 2);
326              TStr OrgSent, RefTransSent;
327              for (int TuvTokN = 0; TuvTokN < TuvTokV.Len(); TuvTokN++) {
<span onclick='openModal()' class='match'>328                  TStr Lang = TuvTokV[TuvTokN]->GetStrArgVal("xml:lang", "");
329                  TStr Sent = CleanRtf(TuvTokV[TuvTokN]->GetTagTok("seg")->GetTokStr(false));
</span>330                  if (Lang == OrgLang) { OrgSent = Sent; }
331                  else if (Lang == RefTransLang) { RefTransSent = Sent; }
332              }
333              TransCorpus->AddSentenceNoTrans(SentId, OrgSent, RefTransSent); SentId++;
334          }
335          printf(" %d / %d\n", TuToks, TuToks);
336      }
337      return TransCorpus;
338  }
339  PTransCorpus TTransCorpus::LoadTxt(const TStr& InOrgFNm,
340          const TStr& InTransFNm, const TStr& InRefTransFNm) {
341      PSIn OrgSIn = !InOrgFNm.Empty() ? TFIn::New(InOrgFNm) : PSIn();
342      PSIn TransSIn = !InTransFNm.Empty() ? TFIn::New(InTransFNm) : PSIn();
343      PSIn RefTransSIn = !InRefTransFNm.Empty() ? TFIn::New(InRefTransFNm) : PSIn();
344      const bool IsOrgP = !OrgSIn.Empty();
345      const bool IsTransP = !TransSIn.Empty();
346      const bool IsRefTransP = !RefTransSIn.Empty();
347      if (!IsOrgP) { printf("No original sentences!\n"); }
348      if (!IsTransP) { printf("No machine translation sentences!\n"); }
349      if (!IsRefTransP) { printf("No reference translation sentences!\n"); }
350      PTransCorpus TransCorpus = TTransCorpus::New();
351      TLnRet OrgLnRet(OrgSIn), TransLnRet(TransSIn), RefTransLnRet(RefTransSIn);
352      TStr OrgLnStr, TransLnStr, RefTransLnStr; int LnN = 1;
353      forever {
354          if (IsOrgP && !OrgLnRet.NextLn(OrgLnStr)) { break; }
355          if (IsTransP && !TransLnRet.NextLn(TransLnStr)) { break; }
356          if (IsRefTransP && !RefTransLnRet.NextLn(RefTransLnStr)) { break; }
357          if (LnN % 100 == 0) { printf("  %7d Sentences\r", LnN); }
358          if (!IsOrgP) {
359              TransCorpus->AddSentenceNoOrg(LnN, TransLnStr, RefTransLnStr);
360          } else if (!IsTransP) {
361              TransCorpus->AddSentenceNoTrans(LnN, OrgLnStr, RefTransLnStr);
362          } else { IAssert(IsRefTransP);
363              TransCorpus->AddSentence(LnN, OrgLnStr, TransLnStr, RefTransLnStr);
364          }
365          LnN++;
366      } printf("\n");
367      return TransCorpus;
368  }
369  void TTransCorpus::SaveTxt(const TStr& OutFBase, const TStr& OutOrgFNm,
370          const TStr& OutTransFNm, const TStr& OutRefTransFNm, TStrV& OrgFNmV,
371          TStrV& TransFNmV, TStrV& RefTransFNmV, const int& LinesPerFile) {
372      OrgFNmV.Clr(); TransFNmV.Clr(); RefTransFNmV.Clr();
373      if (!OutOrgFNm.Empty()) { OrgFNmV.Add(GetOutFNm(OutFBase, 0, LinesPerFile, OutOrgFNm)); }
374      if (!OutTransFNm.Empty()) { TransFNmV.Add(GetOutFNm(OutFBase, 0, LinesPerFile, OutTransFNm)); }
375      if (!OutRefTransFNm.Empty()) { RefTransFNmV.Add(GetOutFNm(OutFBase, 0, LinesPerFile, OutRefTransFNm)); }
376      PSOut OrgSOut = !OutOrgFNm.Empty() ? TFOut::New(OrgFNmV.Last()) : PSOut();
377      PSOut TransSOut = !OutTransFNm.Empty() ? TFOut::New(TransFNmV.Last()) : PSOut();
378      PSOut RefTransSOut = !OutRefTransFNm.Empty() ? TFOut::New(RefTransFNmV.Last()) : PSOut();
379      const bool IsOrgP = !OrgSOut.Empty() && IsOrg();
380      const bool IsTransP = !TransSOut.Empty() && IsTrans();
381      const bool IsRefTransP = !RefTransSOut.Empty() && IsRefTrans();
382      if (!IsOrgP) { printf("No original sentences!\n"); }
383      if (!IsTransP) { printf("No machine translation sentences!\n"); }
384      if (!IsRefTransP) { printf("No reference translation sentences!\n"); }
385      TIntV SentIdV; GetSentIdV(SentIdV);
386      for (int SentIdN = 0; SentIdN < SentIdV.Len(); SentIdN++) {
387          const int SentId = SentIdV[SentIdN];
388          if (IsOrgP) { OrgSOut->PutStrLn(GetOrgStr(SentId)); }
389          if (IsTransP) { TransSOut->PutStrLn(GetTransStr(SentId)); }
390          if (IsRefTransP) { RefTransSOut->PutStrLn(GetRefTransStrV(SentId)[0]); }
391          if ((LinesPerFile!=-1) && (SentIdN>0) && (SentIdN % LinesPerFile == 0)) {
392              if (!OutOrgFNm.Empty()) { OrgFNmV.Add(GetOutFNm(OutFBase, SentIdN, LinesPerFile, OutOrgFNm)); }
393              if (!OutTransFNm.Empty()) { TransFNmV.Add(GetOutFNm(OutFBase, SentIdN, LinesPerFile, OutTransFNm)); }
394              if (!OutRefTransFNm.Empty()) { RefTransFNmV.Add(GetOutFNm(OutFBase, SentIdN, LinesPerFile, OutRefTransFNm)); }
395              OrgSOut = !OutOrgFNm.Empty() ? TFOut::New(OrgFNmV.Last()) : PSOut();
396              TransSOut = !OutTransFNm.Empty() ? TFOut::New(TransFNmV.Last()) : PSOut();
397              RefTransSOut = !OutRefTransFNm.Empty() ? TFOut::New(RefTransFNmV.Last()) : PSOut();
398          }
399      }
400  }
401  void TTransCorpus::SaveTransScript(const TStr& OutFBase, const TStr& OrgLang,
402          const TStr& TransLang, const TStrV& OrgFNmV, const TStrV& RefTransFNmV) {
403      const int FNms = OrgFNmV.Len();
404      IAssert(OrgFNmV.Len() == RefTransFNmV.Len());
405      PSOut TokSOut = TFOut::New(OutFBase + "_tokenize.sh");
406      PutScriptHeader(TokSOut);
407      for (int FNmN = 0; FNmN < FNms; FNmN++) {
408          TokSOut->PutStrLn("tokenize.pl -lang=" + OrgLang + " " +
409              OrgFNmV[FNmN].GetFBase() + " " +
410              TStr::PutFExt(OrgFNmV[FNmN], ".tok").GetFBase());
411          TokSOut->PutStrLn("tokenize.pl -lang=" + TransLang + " " +
412              RefTransFNmV[FNmN].GetFBase() + " " +
413              TStr::PutFExt(RefTransFNmV[FNmN], ".tok").GetFBase());
414      }
415      TokSOut->Flush();
416      PSOut AlignSOut = TFOut::New(OutFBase + "_align.sh");
417      PutScriptHeader(AlignSOut);
418      for (int FNmN = 0; FNmN < FNms; FNmN++) {
419          AlignSOut->PutStrLn("ssal -f " +
420              TStr::PutFExt(OrgFNmV[FNmN], ".tok").GetFBase() + " " +
421              TStr::PutFExt(RefTransFNmV[FNmN], ".tok").GetFBase());
422          AlignSOut->PutStrLn("mv " +
423              TStr::PutFExt(OrgFNmV[FNmN], ".tok.al").GetFBase() + " " +
424              TStr::PutFExt(OrgFNmV[FNmN], ".al").GetFBase());
425          AlignSOut->PutStrLn("mv " +
426              TStr::PutFExt(RefTransFNmV[FNmN], ".tok.al").GetFBase() + " " +
427              TStr::PutFExt(RefTransFNmV[FNmN], ".al").GetFBase());
428      }
429      AlignSOut->Flush();
430      PSOut LcSOut = TFOut::New(OutFBase + "_lowercase.sh");
431      PutScriptHeader(LcSOut);
432      for (int FNmN = 0; FNmN < FNms; FNmN++) {
433          LcSOut->PutStrLn("lc-latin.pl " +
434              TStr::PutFExt(OrgFNmV[FNmN], ".al").GetFBase() + " " +
435              TStr::PutFExt(OrgFNmV[FNmN], ".lc").GetFBase());
436          LcSOut->PutStrLn("lc-latin.pl " +
437              TStr::PutFExt(RefTransFNmV[FNmN], ".al").GetFBase() + " " +
438              TStr::PutFExt(RefTransFNmV[FNmN], ".lc").GetFBase());
439      }
440      LcSOut->Flush();
441  }
442  TAlignPair::TAlignPair(const TStr& _Lang1, const TStr& _Lang2): Lang1(_Lang1), Lang2(_Lang2) {
443      BowDocBs1 = TBowDocBs::New(TSwSet::New(swstNone), TStemmer::New(stmtNone), NULL);
444      BowDocBs2 = TBowDocBs::New(TSwSet::New(swstNone), TStemmer::New(stmtNone), NULL);
445  }
446  TAlignPair::TAlignPair(TSIn& SIn) {
447      Lang1.Load(SIn); Lang2.Load(SIn);
448      BowDocBs1 = TBowDocBs::Load(SIn); BowDocBs1->SaveTxtStat(Lang1 + Lang2 + ".txt");
449      BowDocBs2 = TBowDocBs::Load(SIn); BowDocBs2->SaveTxtStat(Lang1 + Lang2 + ".txt");
450      Def();
451  }
452  void TAlignPair::Save(TSOut& SOut) const {
453      Lang1.Save(SOut); Lang2.Save(SOut);
454      BowDocBs1->Save(SOut); BowDocBs2->Save(SOut);
455  }
456  void TAlignPair::AddSent(const TStr& Sent1, const TStr& Sent2) {
457      TStr DocNm = TInt::GetStr(BowDocBs1->GetDocs());
458      BowDocBs1->AddHtmlDoc(DocNm, TStrV(), Sent1, false);
459      BowDocBs2->AddHtmlDoc(DocNm, TStrV(), Sent2, false);
460      IAssert(BowDocBs1->GetDocs() == BowDocBs2->GetDocs());
461  }
462  void TAlignPair::Def() {
463      BowDocWgtBs1 = TBowDocWgtBs::New(BowDocBs1, bwwtNrmTFIDF);
464      BowDocWgtBs2 = TBowDocWgtBs::New(BowDocBs2, bwwtNrmTFIDF);
465      Matrix1 = TBowMatrix(BowDocWgtBs1);
466      Matrix2 = TBowMatrix(BowDocWgtBs2);
467  }
468  const TMatrix& TAlignPair::GetMatrix(const TStr& Lang) const {
469      if (Lang == Lang1) { return Matrix1; }
470      else if (Lang == Lang2) { return Matrix2; }
471      TExcept::Throw("Wrong language " + Lang + "!");
472      Fail; return *(new TBowMatrix); 
473  }
474  void TAlignPair::GetSpV(const TStr& Str, const TStr& Lang, TIntFltKdV& SpV) const {
475      EAssertR((Lang == Lang1) || (Lang == Lang2), "Wrong language " + Lang + "!");
476      PBowSpV BowSpV = (Lang == Lang1) ?
477          BowDocBs1->GetSpVFromHtmlStr(Str) :
478          BowDocBs2->GetSpVFromHtmlStr(Str);
479      BowSpV->GetIntFltKdV(SpV);
480  }
481  TStr TAlignPair::GetSpVStr(const TIntFltKdV& SpV, const TStr& Lang,
482          const int& MxWords, const double& MxWgtPrc) const {
483      EAssertR((Lang == Lang1) || (Lang == Lang2), "Wrong language " + Lang + "!");
484      PBowDocBs BowDocBs = (Lang == Lang1) ? BowDocBs1 : BowDocBs2;
485      PBowSpV BowSpV = TBowSpV::New(-1, SpV);
486      return BowSpV->GetStr(BowDocBs, MxWords, MxWgtPrc, " ", false, false);
487  }
488  PAlignPair TAlignPair::LoadAcXml(const TStr& FNm, const int& MxSents) {
489      printf("Loading %s ...\n", FNm.CStr());
490      TStr BaseNm = FNm.GetFMid();
491      TStrV PartV; BaseNm.SplitOnAllCh('-', PartV);
492      IAssertR(PartV.Len() == 3, "Bad file name: " + BaseNm);
493      PAlignPair AlignPair = TAlignPair::New(PartV[1], PartV[2]);
494      PTransCorpus TransCorpus = TTransCorpus::LoadAC(FNm, MxSents * 4);
495      const int AllSents = TransCorpus->GetSentences();
496      TIntV SentIdV(AllSents, 0);
497      for (int SentId = 0; SentId < AllSents; SentId++) {
498          SentIdV.Add(SentId);
499      }
500      if (MxSents != -1 && AllSents > MxSents) {
501          TRnd Rnd(1);
502          SentIdV.Shuffle(Rnd);
503          SentIdV.Trunc(MxSents);
504      }
505      const int Sents = SentIdV.Len();
506      for (int SentIdN = 0; SentIdN < Sents; SentIdN++) {
507          const int SentId = SentIdV[SentIdN];
508          const TStr& Sent1 = TransCorpus->GetOrgStr(SentId);
509          const TStr& Sent2 = TransCorpus->GetRefTransStrV(SentId)[0];
510          AlignPair->AddSent(Sent1, Sent2);
511      }
512      AlignPair->Def();
513      return AlignPair;
514  }
515  void TAlignPairBs::AddAlignPair(const PAlignPair& AlignPair) {
516      const int LangId1 = LangH.AddKey(AlignPair->GetLang1());
517      const int LangId2 = LangH.AddKey(AlignPair->GetLang2());
518      AlignPairV.Add(AlignPair);
519      LangToAlignPairVH.AddDat(LangId1).Add(AlignPair);
520      LangToAlignPairVH.AddDat(LangId2).Add(AlignPair);
521      TIntPr LangIdPr(TInt::GetMn(LangId1, LangId2), TInt::GetMx(LangId1, LangId2));
522      LangPrToAlignPairH.AddDat(LangIdPr, AlignPair);
523  }
524  PAlignPair TAlignPairBs::GetAlignPair(const int& LangId1, const int& LangId2) {
525      TIntPr LangIdPr(TInt::GetMn(LangId1, LangId2), TInt::GetMx(LangId1, LangId2));
526      return LangPrToAlignPairH.GetDat(LangIdPr);
527  }
528  TAlignPairBs::TAlignPairBs(TSIn& SIn) {
529      LangH.Load(SIn);
530      TAlignPairV TmpAlignPairV(SIn);
531      for (int TmpAlignPairN = 0; TmpAlignPairN < TmpAlignPairV.Len(); TmpAlignPairN++) {
532          AddAlignPair(TmpAlignPairV[TmpAlignPairN]);
533      }
534  }
535  void TAlignPairBs::Save(TSOut& SOut) const {
536      LangH.Save(SOut);
537      AlignPairV.Save(SOut);
538  }
539  TStr TAlignPairBs::MapQuery(const TAlignPairMap& Map, const TStr& QueryStr,
540          const int& QueryLangId, const int& TargetLangId, const int& TransQueryMtpy,
541          const double& MxWgtPrc) {
542      PAlignPair AlignPair = GetAlignPair(QueryLangId, TargetLangId);
543      const TStr& QueryLang = LangH.GetKey(QueryLangId);
544      const TStr& TargetLang = LangH.GetKey(TargetLangId);
545      TIntFltKdV InSpV; AlignPair->GetSpV(QueryStr, QueryLang, InSpV);
546      const TMatrix& QueryMatrix = AlignPair->GetMatrix(QueryLang);
547      const TMatrix& TargetMatrix = AlignPair->GetMatrix(TargetLang);
548      TIntFltKdV OutSpV; Map(InSpV, QueryMatrix, TargetMatrix, OutSpV);
549      return AlignPair->GetSpVStr(OutSpV, TargetLang,
550          InSpV.Len() * TransQueryMtpy, MxWgtPrc);
551  }
552  PAlignPairBs TAlignPairBs::LoadAcXml(const TStr& FPath, const int& MxSents) {
553      PAlignPairBs AlignPairBs = TAlignPairBs::New();
554      TFFile FFile(FPath, ".xml", false); TStr FNm;
555      while (FFile.Next(FNm)) {
556          PAlignPair AlignPair = TAlignPair::LoadAcXml(FNm, MxSents);
557          AlignPairBs->AddAlignPair(AlignPair);
558      }
559      return AlignPairBs;
560  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-biling.cpp</h3>
            <pre><code>1  void TEvalScore::Tokenize(const TStr& Str, TStrV& TokenV) {
2      TStr LcStr = GetLc(Str);
3      TokenV.Clr(); TChA WordChA;
4      const int Chs = LcStr.Len();
5      for (int ChN = 0; ChN < Chs; ChN++) {
6          const char Ch = LcStr[ChN];
7          if (IsChar(Ch)) {
8              WordChA += Ch;
9          } else if (!WordChA.Empty()) {
10              TokenV.Add(WordChA);
11              WordChA.Clr();
12          }
13      }
14  }
15  void TEvalScore::Parse(const TStr& Str, TIntV& WIdV) {
16      TStrV TokenV; Tokenize(Str, TokenV); WIdV.Clr();
17      for (int WdN = 0; WdN < TokenV.Len(); WdN++) {
18          TStr WdStr = TokenV[WdN];
19          int WId = WordH.GetKeyId(WdStr);
20          if (WId == -1) { WId = WordH.AddKey(WdStr); }
21          WIdV.Add(WId);
22      }
23  }
24  void TEvalScore::GetNGramH(const TIntV& WIdV,
25          const int& MxNGramLen, TIntH& NGramIdH) {
26      const int Wds = WIdV.Len();
27      for (int NGramLen = 1; NGramLen <= MxNGramLen; NGramLen++) {
28          const int MxNGramStart = Wds - NGramLen + 1;
29          for (int NGramStart = 0; NGramStart < MxNGramStart; NGramStart++) {
30              TIntV NGram; WIdV.GetSubValV(NGramStart, NGramStart+NGramLen-1, NGram);
31              IAssert(NGram.Len() == NGramLen);
32              int NGramId = NGramH.GetKeyId(NGram);
33              if (NGramId == -1) { NGramId = NGramH.AddKey(NGram); }
34              NGramIdH.AddDat(NGramId)++;
35          }
36      }
37  }
38  PMom TEvalScore::EvalSig(const PTransCorpus& TransCorpus,
39          const int& Samples, const int& SampleSize, const int& Seed) {
40      TIntV SentIdV; TransCorpus->GetSentIdV(SentIdV);
41      TRnd Rnd(Seed); PMom Mom = TMom::New();
42      for (int SampleN = 0; SampleN < Samples; SampleN++) {
43          TIntV SampleIdV = SentIdV;
44          SampleIdV.Shuffle(Rnd);
45          SampleIdV.Trunc(SampleSize);
46          Mom->Add(Eval(TransCorpus, SampleIdV));
47      }
48      Mom->Def();
49      return Mom;
50  }
51  double TEvalScoreBleu::Eval(const PTransCorpus& TransCorpus, const TIntV& _SentIdV) {
52      IAssert(TransCorpus->IsTrans());
53      TIntH ClipCountNGramH, CountNGramH;
54      int FullTransLen = 0, FullRefLen = 0;
55      TIntV SentIdV = _SentIdV;
56      if (SentIdV.Empty()) { TransCorpus->GetSentIdV(SentIdV); }
57      const int Sents = SentIdV.Len();
58      for (int SentIdN = 0; SentIdN < Sents; SentIdN++) {
59          const int SentId = SentIdV[SentIdN];
60          TIntV TransWIdV; Parse(TransCorpus->GetTransStr(SentId), TransWIdV);
61          TIntH TransNGramH; GetNGramH(TransWIdV, MxNGramLen, TransNGramH);
62          TIntH FreeTransNGramH = TransNGramH; 
63          const int TransLen = TransWIdV.Len();
64          int BestLen = 0, BestLenDiff = TInt::Mx;
65          TStrV RefTransStrV = TransCorpus->GetRefTransStrV(SentId);
66          for (int RefN = 0; RefN < RefTransStrV.Len(); RefN++) {
67              TIntV RefWIdV; Parse(RefTransStrV[RefN], RefWIdV);
68              TIntH RefNGramH; GetNGramH(RefWIdV, MxNGramLen, RefNGramH);
69              int TransNGramKeyId = TransNGramH.FFirstKeyId();
70              while(TransNGramH.FNextKeyId(TransNGramKeyId)) {
71                  const int NGramId = TransNGramH.GetKey(TransNGramKeyId);
72                  const int FreeTransNGrams = FreeTransNGramH(NGramId);
73                  if (RefNGramH.IsKey(NGramId) && (FreeTransNGrams>0)) {
74                      const int RefNGrams = RefNGramH(NGramId);
75                      FreeTransNGramH(NGramId) = TInt::GetMx(0, FreeTransNGrams - RefNGrams);
76                  }
77              }
78              const int RefLen = RefWIdV.Len();
79              const int LenDiff = TInt::Abs(TransLen - RefLen);
80              if (LenDiff < BestLenDiff) {
81                  BestLen = RefLen; BestLenDiff = LenDiff;
82              }
83          }
84          int TransNGramKeyId = TransNGramH.FFirstKeyId();
85          while(TransNGramH.FNextKeyId(TransNGramKeyId)) {
86              const int NGramId = TransNGramH.GetKey(TransNGramKeyId);
87              IAssert(NGramId != -1);
88              const int FreeNGramId = FreeTransNGramH.GetKey(TransNGramKeyId);
89              IAssert(NGramId == FreeNGramId);
90              const int Count = TransNGramH[TransNGramKeyId];
91              const int ClipCount = Count - FreeTransNGramH[TransNGramKeyId];
92              CountNGramH.AddDat(NGramId) += Count;
93              ClipCountNGramH.AddDat(NGramId) += ClipCount;
94          }
95          FullTransLen += TransLen;
96          FullRefLen += BestLen;
97      }
98      TIntV ClipCountV(MxNGramLen); ClipCountV.PutAll(0);
99      int ClipCountKeyId = ClipCountNGramH.FFirstKeyId();
100      while (ClipCountNGramH.FNextKeyId(ClipCountKeyId)) {
101          const int NGramId = ClipCountNGramH.GetKey(ClipCountKeyId);
102          const int NGramLen = GetNGramLen(NGramId);
103          IAssert(0 < NGramLen && NGramLen <= MxNGramLen);
104          ClipCountV[NGramLen-1] += ClipCountNGramH[ClipCountKeyId];
105      }
106      TIntV CountV(MxNGramLen); CountV.PutAll(0);
107      int CountKeyId = CountNGramH.FFirstKeyId();
108      while (CountNGramH.FNextKeyId(CountKeyId)) {
109          const int NGramId = CountNGramH.GetKey(CountKeyId);
110          const int NGramLen = GetNGramLen(NGramId);
111          IAssert(0 < NGramLen && NGramLen <= MxNGramLen);
112          CountV[NGramLen-1] += CountNGramH[CountKeyId];
113      }
114      TFltV PrecV(MxNGramLen, 0);
115      for (int NGramLen = 0; NGramLen < MxNGramLen; NGramLen++) {
116          const int ClipCount = ClipCountV[NGramLen];
117          const int Count = CountV[NGramLen];
118          const double Prec = (Count > 0) ? double(ClipCount)/double(Count) : 0.0;
119          PrecV.Add(Prec);
120          printf("%d-gram Match:%d Total:%d Prec:%.5f\n", NGramLen+1, ClipCount, Count, Prec);
121      }
122      double LogBP = TFlt::GetMn(0.0, 1.0 - double(FullRefLen)/double(FullTransLen));
123      double BP = exp(LogBP);
124      printf("Sentence Len: %d, Best-match Sntence Len: %d, Score: %.5f\n",
125          FullTransLen, FullRefLen, LogBP);
126      double BleuScore = BP;
127      const double Wgt = 1.0 / double(MxNGramLen);
128      for (int NGramLen = 0; NGramLen < MxNGramLen; NGramLen++) {
129          BleuScore *= pow(PrecV[NGramLen], Wgt);
130      }
131      printf("BLEU Score: %.5f\n", BleuScore);
132      return BleuScore;
133  }
134  void TTransCorpus::PutScriptHeader(const PSOut& SOut) {
135  }
136  void TTransCorpus::CleanTmx(const TStr& InTmxFNm, const TStr& OutXmlFNm) {
137      TFIn FIn(InTmxFNm); TFOut FOut(OutXmlFNm);
138      TStr ChStr; bool InTagP = false;
139      while (!FIn.Eof()) {
140          ChStr = TStr::GetChStr(FIn.GetCh());
141          if (ChStr == "<") { InTagP = true; FOut.PutStr(ChStr); }
142          else if (ChStr == ">") { InTagP = false; FOut.PutStr(ChStr); }
143          else if (!InTagP && ChStr != "\n" && ChStr != "\r") {
144              FOut.PutStr(TXmlDoc::GetXmlStr(ChStr));
145          } else { FOut.PutStr(ChStr); }
146      }
147  }
148  TStr TTransCorpus::CleanRtf(const TStr& InStr) {
149      TChA OutChA; int Chs = InStr.Len(); bool RtfTagP = false;
150      for (int ChN = 0; ChN < Chs; ChN++) {
151          const char Ch = InStr[ChN];
152          if (Ch == '{' || Ch == '}') { &bsol;* skip */ }
153          else if (Ch == '\\') { RtfTagP = true; }
154          else if (Ch == ' ' && RtfTagP) { RtfTagP = false; }
155          else if (!RtfTagP) { OutChA += Ch; }
156      }
157      return OutChA;
158  }
159  int TTransCorpus::CountWords(const TIntStrH& StrH) {
160      int Words = 0, KeyId = StrH.FFirstKeyId();
161      while (StrH.FNextKeyId(KeyId)) {
162          const TStr& Str = StrH[KeyId];
163          TStrV WordV; Str.SplitOnWs(WordV);
164          Words += WordV.Len();
165      }
166      return Words;
167  }
168  int TTransCorpus::CountWords(const TIntStrVH& StrVH, const bool& AllSents) {
169      int Words = 0, KeyId = StrVH.FFirstKeyId();
170      while (StrVH.FNextKeyId(KeyId)) {
171          const TStrV& StrV = StrVH[KeyId];
172          if (AllSents) {
173              for (int StrN = 0; StrN < StrV.Len(); StrN++) {
174                  TStrV WordV; StrV[StrN].SplitOnWs(WordV);
175                  Words += WordV.Len();
176              }
177          } else {
178              TStrV WordV; StrV[0].SplitOnWs(WordV);
179              Words += WordV.Len();
180          }
181      }
182      return Words;
183  }
184  inline void TTransCorpus::AddSentenceNoTrans(const int& SentId,
185          const TStr& OrgStr, const TStr& RefTransStr) {
186      AddSentenceNoTrans(SentId, OrgStr, TStrV::GetV(RefTransStr));
187  }
188  void TTransCorpus::AddSentenceNoTrans(const int& SentId,
189          const TStr& OrgStr, const TStrV& RefTransStrV) {
190      if (OrgStr.Empty()) { return; }
191      if (RefTransStrV[0].Empty()) { return; }
192      IAssert(!OrgStrH.IsKey(SentId));
193      OrgStrH.AddDat(SentId, OrgStr);
194      RefTransStrVH.AddDat(SentId, RefTransStrV);
195      const int OrgKeyId = OrgStrH.GetKeyId(SentId);
196      const int RefTransKeyId = RefTransStrVH.GetKeyId(SentId);
197      IAssert(OrgKeyId == RefTransKeyId);
198  }
199  inline void TTransCorpus::AddSentenceNoOrg(const int& SentId,
200          const TStr& TransStr, const TStr& RefTransStr) {
201      AddSentenceNoOrg(SentId, TransStr, TStrV::GetV(RefTransStr));
202  }
203  void TTransCorpus::AddSentenceNoOrg(const int& SentId,
204          const TStr& TransStr, const TStrV& RefTransStrV) {
205      IAssert(!TransStrH.IsKey(SentId));
206      TransStrH.AddDat(SentId, TransStr);
207      RefTransStrVH.AddDat(SentId, RefTransStrV);
208      const int TransKeyId = TransStrH.GetKeyId(SentId);
209      const int RefTransKeyId = RefTransStrVH.GetKeyId(SentId);
210      IAssert(TransKeyId == RefTransKeyId);
211  }
212  inline void TTransCorpus::AddSentence(const int& SentId, const TStr& OrgStr,
213          const TStr& TransStr, const TStr& RefTransStr) {
214      AddSentence(SentId, OrgStr, TransStr, TStrV::GetV(RefTransStr));
215  }
216  void TTransCorpus::AddSentence(const int& SentId, const TStr& OrgStr,
217          const TStr& TransStr, const TStrV& RefTransStrV) {
218      IAssert(!OrgStrH.IsKey(SentId));
219      OrgStrH.AddDat(SentId, OrgStr);
220      TransStrH.AddDat(SentId, TransStr);
221      RefTransStrVH.AddDat(SentId, RefTransStrV);
222      const int OrgKeyId = OrgStrH.GetKeyId(SentId);
223      const int TransKeyId = TransStrH.GetKeyId(SentId);
224      const int RefTransKeyId = RefTransStrVH.GetKeyId(SentId);
225      IAssert(OrgKeyId == TransKeyId);
226      IAssert(OrgKeyId == RefTransKeyId);
227  }
228  void TTransCorpus::GetSentIdV(TIntV& SentIdV) const {
229      if (IsOrg()) { OrgStrH.GetKeyV(SentIdV); }
230      else if (IsTrans()) { TransStrH.GetKeyV(SentIdV); }
231      else if (IsRefTrans()) { RefTransStrVH.GetKeyV(SentIdV); }
232      else { Fail; }
233  }
234  PTransCorpus TTransCorpus::LoadAC(const TStr& InXmlFNm, const int& MxSents) {
235      PTransCorpus TransCorpus = TTransCorpus::New();
236      PSIn XmlSIn=TFIn::New(InXmlFNm);
237      TXmlDoc::SkipTopTag(XmlSIn); 
238      printf("Ignoring: %s\n", TXmlDoc::LoadTxt(XmlSIn)->GetTok()->GetTagNm().CStr()); 
239      TXmlDoc::SkipTopTag(XmlSIn); 
240      TXmlDoc::SkipTopTag(XmlSIn); 
241      PXmlDoc XmlDoc; int XmlDocs = 0, SentId = 0;;
242      forever{
243          XmlDocs++; printf("%7d Sentences \r", SentId);
244          XmlDoc=TXmlDoc::LoadTxt(XmlSIn);
245          if (!XmlDoc->IsOk()) { &bsol;*printf("Error: %s\n", XmlDoc->GetMsgStr().CStr());*/ break; }
246          PXmlTok TopTok=XmlDoc->GetTok();
247          if (TopTok->IsTag("div")){
248              TStr DocNm = TopTok->GetArgVal("n");
249              TXmlTokV LinkTokV; TopTok->GetTagTokV("linkGrp|link", LinkTokV);
250              for (int LinkTokN = 0; LinkTokN < LinkTokV.Len(); LinkTokN++) {
251                  PXmlTok LinkTok = LinkTokV[LinkTokN];
252                  TStr LinkType = LinkTok->GetArgVal("type");
253                  if (LinkType == "1:1") {
254                      TXmlTokV S1TokV; LinkTok->GetTagTokV("s1", S1TokV);
255                      TXmlTokV S2TokV; LinkTok->GetTagTokV("s2", S2TokV);
256                      IAssert(S1TokV.Len() == 1); IAssert(S2TokV.Len() == 1);
257                      TStr ParaStr1 = S1TokV[0]->GetTagTokStr("");
258                      TStr ParaStr2 = S2TokV[0]->GetTagTokStr("");
259                      TransCorpus->AddSentenceNoTrans(SentId, ParaStr1, ParaStr2); SentId++;
260                  }
261              }
262          } else {
263              printf("Unknow tag: %s\n", TopTok->GetTagNm().CStr());
264          }
265          if ((MxSents != -1) && (TransCorpus->GetSentences() > MxSents)) { break; }
266      }
267      printf("\n");
268      return TransCorpus;
269  }
270  PTransCorpus TTransCorpus::LoadEP(const TStr& InOrgFPath, const TStr& InTransFPath) {
271      PTransCorpus TransCorpus = TTransCorpus::New();
272      TStr NrmInTransFPath = TStr::GetNrAbsFPath(InTransFPath);
273      TFFile OrgFNms(InOrgFPath, "txt", false); TStr OrgFNm;
274      int SentId = 0;
275      while (OrgFNms.Next(OrgFNm)) {
276          TStr TransFNm = NrmInTransFPath + OrgFNm.GetFBase();
277          IAssertR(TFile::Exists(TransFNm), TransFNm);
278          printf("Loading %s and %s ...\r", OrgFNm.CStr(), TransFNm.CStr());
279          TLnRet OrgLnRet(TFIn::New(OrgFNm));
280          TLnRet TransLnRet(TFIn::New(TransFNm));
281          TStr OrgLn, TransLn; int LnN = 1; bool EmptyLnP = false;
282          while (OrgLnRet.NextLn(OrgLn)) {
283              if (!TransLnRet.NextLn(TransLn)) {
284                  printf("\nEarly stop in line (%s:%s)[%d]\n", OrgLn.CStr(), TransLn.CStr(), LnN);
285                  break; 
286              }
287              if (OrgLn.Empty() || TransFNm.Empty()) {
288                  EmptyLnP = true;
289              } else if (OrgLn[0] == '<' || TransLn[0] == '<') {
290                  if (TransLn[0] != OrgLn[0]) {
291                      printf("\nError in line (%s:%s)[%d]\n", OrgLn.CStr(), TransLn.CStr(), LnN);
292                      break; 
293                  }
294                  EmptyLnP = false;
295              } else if (!EmptyLnP) {
296                  TransCorpus->AddSentenceNoTrans(SentId,
297                      OrgLn.ToTrunc(), TransLn.ToTrunc());
298                  SentId++;
299              }
300              LnN++;
301          }
302      }
303      printf("\nDone!\n");
304      return TransCorpus;
305  }
306  PTransCorpus TTransCorpus::LoadTMX(const TStr& InTmxFPath,
307          const TStr& OrgLang, const TStr& RefTransLang) {
308      PTransCorpus TransCorpus = TTransCorpus::New();
309      TFFile TmxFNms(InTmxFPath, "tmx", false); TStr TmxFNm; int SentId = 0;
310      while (TmxFNms.Next(TmxFNm)) {
311          printf("Loading %s ...\n", TmxFNm.CStr());
312          TStr CleanTmxFNm = TmxFNm + ".xml";
313          CleanTmx(TmxFNm, CleanTmxFNm);
314          PSIn XmlSIn = TFIn::New(CleanTmxFNm);
315          PXmlDoc XmlDoc = TXmlDoc::LoadTxt(XmlSIn);
316          if (!XmlDoc->IsOk()) {
317              printf(" error: %s\n", XmlDoc->GetMsgStr().CStr());
318              continue;
319          }
320          TXmlTokV TuTokV; XmlDoc->GetTagTokV("tmx|body|tu", TuTokV);
321          const int TuToks = TuTokV.Len();
322          for (int TuTokN = 0; TuTokN < TuToks; TuTokN++) {
323              if (TuTokN % 100 == 0) { printf(" %d / %d\r", TuTokN, TuToks); }
324              TXmlTokV TuvTokV; TuTokV[TuTokN]->GetTagTokV("tuv", TuvTokV);
325              IAssert(TuvTokV.Len() == 2);
326              TStr OrgSent, RefTransSent;
327              for (int TuvTokN = 0; TuvTokN < TuvTokV.Len(); TuvTokN++) {
<span onclick='openModal()' class='match'>328                  TStr Lang = TuvTokV[TuvTokN]->GetStrArgVal("xml:lang", "");
329                  TStr Sent = CleanRtf(TuvTokV[TuvTokN]->GetTagTok("seg")->GetTokStr(false));
</span>330                  if (Lang == OrgLang) { OrgSent = Sent; }
331                  else if (Lang == RefTransLang) { RefTransSent = Sent; }
332              }
333              TransCorpus->AddSentenceNoTrans(SentId, OrgSent, RefTransSent); SentId++;
334          }
335          printf(" %d / %d\n", TuToks, TuToks);
336      }
337      return TransCorpus;
338  }
339  PTransCorpus TTransCorpus::LoadTxt(const TStr& InOrgFNm,
340          const TStr& InTransFNm, const TStr& InRefTransFNm) {
341      PSIn OrgSIn = !InOrgFNm.Empty() ? TFIn::New(InOrgFNm) : PSIn();
342      PSIn TransSIn = !InTransFNm.Empty() ? TFIn::New(InTransFNm) : PSIn();
343      PSIn RefTransSIn = !InRefTransFNm.Empty() ? TFIn::New(InRefTransFNm) : PSIn();
344      const bool IsOrgP = !OrgSIn.Empty();
345      const bool IsTransP = !TransSIn.Empty();
346      const bool IsRefTransP = !RefTransSIn.Empty();
347      if (!IsOrgP) { printf("No original sentences!\n"); }
348      if (!IsTransP) { printf("No machine translation sentences!\n"); }
349      if (!IsRefTransP) { printf("No reference translation sentences!\n"); }
350      PTransCorpus TransCorpus = TTransCorpus::New();
351      TLnRet OrgLnRet(OrgSIn), TransLnRet(TransSIn), RefTransLnRet(RefTransSIn);
352      TStr OrgLnStr, TransLnStr, RefTransLnStr; int LnN = 1;
353      forever {
354          if (IsOrgP && !OrgLnRet.NextLn(OrgLnStr)) { break; }
355          if (IsTransP && !TransLnRet.NextLn(TransLnStr)) { break; }
356          if (IsRefTransP && !RefTransLnRet.NextLn(RefTransLnStr)) { break; }
357          if (LnN % 100 == 0) { printf("  %7d Sentences\r", LnN); }
358          if (!IsOrgP) {
359              TransCorpus->AddSentenceNoOrg(LnN, TransLnStr, RefTransLnStr);
360          } else if (!IsTransP) {
361              TransCorpus->AddSentenceNoTrans(LnN, OrgLnStr, RefTransLnStr);
362          } else { IAssert(IsRefTransP);
363              TransCorpus->AddSentence(LnN, OrgLnStr, TransLnStr, RefTransLnStr);
364          }
365          LnN++;
366      } printf("\n");
367      return TransCorpus;
368  }
369  void TTransCorpus::SaveTxt(const TStr& OutFBase, const TStr& OutOrgFNm,
370          const TStr& OutTransFNm, const TStr& OutRefTransFNm, TStrV& OrgFNmV,
371          TStrV& TransFNmV, TStrV& RefTransFNmV, const int& LinesPerFile) {
372      OrgFNmV.Clr(); TransFNmV.Clr(); RefTransFNmV.Clr();
373      if (!OutOrgFNm.Empty()) { OrgFNmV.Add(GetOutFNm(OutFBase, 0, LinesPerFile, OutOrgFNm)); }
374      if (!OutTransFNm.Empty()) { TransFNmV.Add(GetOutFNm(OutFBase, 0, LinesPerFile, OutTransFNm)); }
375      if (!OutRefTransFNm.Empty()) { RefTransFNmV.Add(GetOutFNm(OutFBase, 0, LinesPerFile, OutRefTransFNm)); }
376      PSOut OrgSOut = !OutOrgFNm.Empty() ? TFOut::New(OrgFNmV.Last()) : PSOut();
377      PSOut TransSOut = !OutTransFNm.Empty() ? TFOut::New(TransFNmV.Last()) : PSOut();
378      PSOut RefTransSOut = !OutRefTransFNm.Empty() ? TFOut::New(RefTransFNmV.Last()) : PSOut();
379      const bool IsOrgP = !OrgSOut.Empty() && IsOrg();
380      const bool IsTransP = !TransSOut.Empty() && IsTrans();
381      const bool IsRefTransP = !RefTransSOut.Empty() && IsRefTrans();
382      if (!IsOrgP) { printf("No original sentences!\n"); }
383      if (!IsTransP) { printf("No machine translation sentences!\n"); }
384      if (!IsRefTransP) { printf("No reference translation sentences!\n"); }
385      TIntV SentIdV; GetSentIdV(SentIdV);
386      for (int SentIdN = 0; SentIdN < SentIdV.Len(); SentIdN++) {
387          const int SentId = SentIdV[SentIdN];
388          if (IsOrgP) { OrgSOut->PutStrLn(GetOrgStr(SentId)); }
389          if (IsTransP) { TransSOut->PutStrLn(GetTransStr(SentId)); }
390          if (IsRefTransP) { RefTransSOut->PutStrLn(GetRefTransStrV(SentId)[0]); }
391          if ((LinesPerFile!=-1) && (SentIdN>0) && (SentIdN % LinesPerFile == 0)) {
392              if (!OutOrgFNm.Empty()) { OrgFNmV.Add(GetOutFNm(OutFBase, SentIdN, LinesPerFile, OutOrgFNm)); }
393              if (!OutTransFNm.Empty()) { TransFNmV.Add(GetOutFNm(OutFBase, SentIdN, LinesPerFile, OutTransFNm)); }
394              if (!OutRefTransFNm.Empty()) { RefTransFNmV.Add(GetOutFNm(OutFBase, SentIdN, LinesPerFile, OutRefTransFNm)); }
395              OrgSOut = !OutOrgFNm.Empty() ? TFOut::New(OrgFNmV.Last()) : PSOut();
396              TransSOut = !OutTransFNm.Empty() ? TFOut::New(TransFNmV.Last()) : PSOut();
397              RefTransSOut = !OutRefTransFNm.Empty() ? TFOut::New(RefTransFNmV.Last()) : PSOut();
398          }
399      }
400  }
401  void TTransCorpus::SaveTransScript(const TStr& OutFBase, const TStr& OrgLang,
402          const TStr& TransLang, const TStrV& OrgFNmV, const TStrV& RefTransFNmV) {
403      const int FNms = OrgFNmV.Len();
404      IAssert(OrgFNmV.Len() == RefTransFNmV.Len());
405      PSOut TokSOut = TFOut::New(OutFBase + "_tokenize.sh");
406      PutScriptHeader(TokSOut);
407      for (int FNmN = 0; FNmN < FNms; FNmN++) {
408          TokSOut->PutStrLn("tokenize.pl -lang=" + OrgLang + " " +
409              OrgFNmV[FNmN].GetFBase() + " " +
410              TStr::PutFExt(OrgFNmV[FNmN], ".tok").GetFBase());
411          TokSOut->PutStrLn("tokenize.pl -lang=" + TransLang + " " +
412              RefTransFNmV[FNmN].GetFBase() + " " +
413              TStr::PutFExt(RefTransFNmV[FNmN], ".tok").GetFBase());
414      }
415      TokSOut->Flush();
416      PSOut AlignSOut = TFOut::New(OutFBase + "_align.sh");
417      PutScriptHeader(AlignSOut);
418      for (int FNmN = 0; FNmN < FNms; FNmN++) {
419          AlignSOut->PutStrLn("ssal -f " +
420              TStr::PutFExt(OrgFNmV[FNmN], ".tok").GetFBase() + " " +
421              TStr::PutFExt(RefTransFNmV[FNmN], ".tok").GetFBase());
422          AlignSOut->PutStrLn("mv " +
423              TStr::PutFExt(OrgFNmV[FNmN], ".tok.al").GetFBase() + " " +
424              TStr::PutFExt(OrgFNmV[FNmN], ".al").GetFBase());
425          AlignSOut->PutStrLn("mv " +
426              TStr::PutFExt(RefTransFNmV[FNmN], ".tok.al").GetFBase() + " " +
427              TStr::PutFExt(RefTransFNmV[FNmN], ".al").GetFBase());
428      }
429      AlignSOut->Flush();
430      PSOut LcSOut = TFOut::New(OutFBase + "_lowercase.sh");
431      PutScriptHeader(LcSOut);
432      for (int FNmN = 0; FNmN < FNms; FNmN++) {
433          LcSOut->PutStrLn("lc-latin.pl " +
434              TStr::PutFExt(OrgFNmV[FNmN], ".al").GetFBase() + " " +
435              TStr::PutFExt(OrgFNmV[FNmN], ".lc").GetFBase());
436          LcSOut->PutStrLn("lc-latin.pl " +
437              TStr::PutFExt(RefTransFNmV[FNmN], ".al").GetFBase() + " " +
438              TStr::PutFExt(RefTransFNmV[FNmN], ".lc").GetFBase());
439      }
440      LcSOut->Flush();
441  }
442  TAlignPair::TAlignPair(const TStr& _Lang1, const TStr& _Lang2): Lang1(_Lang1), Lang2(_Lang2) {
443      BowDocBs1 = TBowDocBs::New(TSwSet::New(swstNone), TStemmer::New(stmtNone), NULL);
444      BowDocBs2 = TBowDocBs::New(TSwSet::New(swstNone), TStemmer::New(stmtNone), NULL);
445  }
446  TAlignPair::TAlignPair(TSIn& SIn) {
447      Lang1.Load(SIn); Lang2.Load(SIn);
448      BowDocBs1 = TBowDocBs::Load(SIn); BowDocBs1->SaveTxtStat(Lang1 + Lang2 + ".txt");
449      BowDocBs2 = TBowDocBs::Load(SIn); BowDocBs2->SaveTxtStat(Lang1 + Lang2 + ".txt");
450      Def();
451  }
452  void TAlignPair::Save(TSOut& SOut) const {
453      Lang1.Save(SOut); Lang2.Save(SOut);
454      BowDocBs1->Save(SOut); BowDocBs2->Save(SOut);
455  }
456  void TAlignPair::AddSent(const TStr& Sent1, const TStr& Sent2) {
457      TStr DocNm = TInt::GetStr(BowDocBs1->GetDocs());
458      BowDocBs1->AddHtmlDoc(DocNm, TStrV(), Sent1, false);
459      BowDocBs2->AddHtmlDoc(DocNm, TStrV(), Sent2, false);
460      IAssert(BowDocBs1->GetDocs() == BowDocBs2->GetDocs());
461  }
462  void TAlignPair::Def() {
463      BowDocWgtBs1 = TBowDocWgtBs::New(BowDocBs1, bwwtNrmTFIDF);
464      BowDocWgtBs2 = TBowDocWgtBs::New(BowDocBs2, bwwtNrmTFIDF);
465      Matrix1 = TBowMatrix(BowDocWgtBs1);
466      Matrix2 = TBowMatrix(BowDocWgtBs2);
467  }
468  const TMatrix& TAlignPair::GetMatrix(const TStr& Lang) const {
469      if (Lang == Lang1) { return Matrix1; }
470      else if (Lang == Lang2) { return Matrix2; }
471      TExcept::Throw("Wrong language " + Lang + "!");
472      Fail; return *(new TBowMatrix); 
473  }
474  void TAlignPair::GetSpV(const TStr& Str, const TStr& Lang, TIntFltKdV& SpV) const {
475      EAssertR((Lang == Lang1) || (Lang == Lang2), "Wrong language " + Lang + "!");
476      PBowSpV BowSpV = (Lang == Lang1) ?
477          BowDocBs1->GetSpVFromHtmlStr(Str) :
478          BowDocBs2->GetSpVFromHtmlStr(Str);
479      BowSpV->GetIntFltKdV(SpV);
480  }
481  TStr TAlignPair::GetSpVStr(const TIntFltKdV& SpV, const TStr& Lang,
482          const int& MxWords, const double& MxWgtPrc) const {
483      EAssertR((Lang == Lang1) || (Lang == Lang2), "Wrong language " + Lang + "!");
484      PBowDocBs BowDocBs = (Lang == Lang1) ? BowDocBs1 : BowDocBs2;
485      PBowSpV BowSpV = TBowSpV::New(-1, SpV);
486      return BowSpV->GetStr(BowDocBs, MxWords, MxWgtPrc, " ", false, false);
487  }
488  PAlignPair TAlignPair::LoadAcXml(const TStr& FNm, const int& MxSents) {
489      printf("Loading %s ...\n", FNm.CStr());
490      TStr BaseNm = FNm.GetFMid();
491      TStrV PartV; BaseNm.SplitOnAllCh('-', PartV);
492      IAssertR(PartV.Len() == 3, "Bad file name: " + BaseNm);
493      PAlignPair AlignPair = TAlignPair::New(PartV[1], PartV[2]);
494      PTransCorpus TransCorpus = TTransCorpus::LoadAC(FNm, MxSents * 4);
495      const int AllSents = TransCorpus->GetSentences();
496      TIntV SentIdV(AllSents, 0);
497      for (int SentId = 0; SentId < AllSents; SentId++) {
498          SentIdV.Add(SentId);
499      }
500      if (MxSents != -1 && AllSents > MxSents) {
501          TRnd Rnd(1);
502          SentIdV.Shuffle(Rnd);
503          SentIdV.Trunc(MxSents);
504      }
505      const int Sents = SentIdV.Len();
506      for (int SentIdN = 0; SentIdN < Sents; SentIdN++) {
507          const int SentId = SentIdV[SentIdN];
508          const TStr& Sent1 = TransCorpus->GetOrgStr(SentId);
509          const TStr& Sent2 = TransCorpus->GetRefTransStrV(SentId)[0];
510          AlignPair->AddSent(Sent1, Sent2);
511      }
512      AlignPair->Def();
513      return AlignPair;
514  }
515  void TAlignPairBs::AddAlignPair(const PAlignPair& AlignPair) {
516      const int LangId1 = LangH.AddKey(AlignPair->GetLang1());
517      const int LangId2 = LangH.AddKey(AlignPair->GetLang2());
518      AlignPairV.Add(AlignPair);
519      LangToAlignPairVH.AddDat(LangId1).Add(AlignPair);
520      LangToAlignPairVH.AddDat(LangId2).Add(AlignPair);
521      TIntPr LangIdPr(TInt::GetMn(LangId1, LangId2), TInt::GetMx(LangId1, LangId2));
522      LangPrToAlignPairH.AddDat(LangIdPr, AlignPair);
523  }
524  PAlignPair TAlignPairBs::GetAlignPair(const int& LangId1, const int& LangId2) {
525      TIntPr LangIdPr(TInt::GetMn(LangId1, LangId2), TInt::GetMx(LangId1, LangId2));
526      return LangPrToAlignPairH.GetDat(LangIdPr);
527  }
528  TAlignPairBs::TAlignPairBs(TSIn& SIn) {
529      LangH.Load(SIn);
530      TAlignPairV TmpAlignPairV(SIn);
531      for (int TmpAlignPairN = 0; TmpAlignPairN < TmpAlignPairV.Len(); TmpAlignPairN++) {
532          AddAlignPair(TmpAlignPairV[TmpAlignPairN]);
533      }
534  }
535  void TAlignPairBs::Save(TSOut& SOut) const {
536      LangH.Save(SOut);
537      AlignPairV.Save(SOut);
538  }
539  TStr TAlignPairBs::MapQuery(const TAlignPairMap& Map, const TStr& QueryStr,
540          const int& QueryLangId, const int& TargetLangId, const int& TransQueryMtpy,
541          const double& MxWgtPrc) {
542      PAlignPair AlignPair = GetAlignPair(QueryLangId, TargetLangId);
543      const TStr& QueryLang = LangH.GetKey(QueryLangId);
544      const TStr& TargetLang = LangH.GetKey(TargetLangId);
545      TIntFltKdV InSpV; AlignPair->GetSpV(QueryStr, QueryLang, InSpV);
546      const TMatrix& QueryMatrix = AlignPair->GetMatrix(QueryLang);
547      const TMatrix& TargetMatrix = AlignPair->GetMatrix(TargetLang);
548      TIntFltKdV OutSpV; Map(InSpV, QueryMatrix, TargetMatrix, OutSpV);
549      return AlignPair->GetSpVStr(OutSpV, TargetLang,
550          InSpV.Len() * TransQueryMtpy, MxWgtPrc);
551  }
552  PAlignPairBs TAlignPairBs::LoadAcXml(const TStr& FPath, const int& MxSents) {
553      PAlignPairBs AlignPairBs = TAlignPairBs::New();
554      TFFile FFile(FPath, ".xml", false); TStr FNm;
555      while (FFile.Next(FNm)) {
556          PAlignPair AlignPair = TAlignPair::LoadAcXml(FNm, MxSents);
557          AlignPairBs->AddAlignPair(AlignPair);
558      }
559      return AlignPairBs;
560  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-biling.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-biling.cpp</div>
                </div>
                <div class="column column_space"><pre><code>328                  TStr Lang = TuvTokV[TuvTokN]->GetStrArgVal("xml:lang", "");
329                  TStr Sent = CleanRtf(TuvTokV[TuvTokN]->GetTagTok("seg")->GetTokStr(false));
</pre></code></div>
                <div class="column column_space"><pre><code>328                  TStr Lang = TuvTokV[TuvTokN]->GetStrArgVal("xml:lang", "");
329                  TStr Sent = CleanRtf(TuvTokV[TuvTokN]->GetTagTok("seg")->GetTokStr(false));
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    