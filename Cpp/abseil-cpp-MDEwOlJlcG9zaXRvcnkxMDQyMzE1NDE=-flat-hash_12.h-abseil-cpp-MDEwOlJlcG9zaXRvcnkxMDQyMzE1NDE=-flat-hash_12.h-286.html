
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 71, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-hash_12.h</h3>
            <pre><code>1  #ifndef ABSL_HASH_INTERNAL_HASH_H_
2  #define ABSL_HASH_INTERNAL_HASH_H_
3  #include &lt;algorithm&gt;
4  #include &lt;array&gt;
5  #include &lt;bitset&gt;
6  #include &lt;cmath&gt;
7  #include &lt;cstddef&gt;
8  #include &lt;cstring&gt;
9  #include &lt;deque&gt;
10  #include &lt;forward_list&gt;
11  #include &lt;functional&gt;
12  #include &lt;iterator&gt;
13  #include &lt;limits&gt;
14  #include &lt;list&gt;
15  #include &lt;map&gt;
16  #include &lt;memory&gt;
17  #include &lt;set&gt;
18  #include &lt;string&gt;
19  #include &lt;tuple&gt;
20  #include &lt;type_traits&gt;
21  #include &lt;unordered_map&gt;
22  #include &lt;unordered_set&gt;
23  #include &lt;utility&gt;
24  #include &lt;vector&gt;
25  #include &quot;absl/base/config.h&quot;
26  #include &quot;absl/base/internal/unaligned_access.h&quot;
27  #include &quot;absl/base/port.h&quot;
28  #include &quot;absl/container/fixed_array.h&quot;
29  #include &quot;absl/hash/internal/city.h&quot;
30  #include &quot;absl/hash/internal/low_level_hash.h&quot;
31  #include &quot;absl/meta/type_traits.h&quot;
32  #include &quot;absl/numeric/bits.h&quot;
33  #include &quot;absl/numeric/int128.h&quot;
34  #include &quot;absl/strings/string_view.h&quot;
35  #include &quot;absl/types/optional.h&quot;
36  #include &quot;absl/types/variant.h&quot;
37  #include &quot;absl/utility/utility.h&quot;
38  #ifdef ABSL_HAVE_STD_STRING_VIEW
39  #include &lt;string_view&gt;
40  #endif
41  namespace absl {
42  ABSL_NAMESPACE_BEGIN
43  class HashState;
44  namespace hash_internal {
45  constexpr size_t PiecewiseChunkSize() { return 1024; }
46  class PiecewiseCombiner {
47   public:
48    PiecewiseCombiner() : position_(0) {}
49    PiecewiseCombiner(const PiecewiseCombiner&amp;) = delete;
50    PiecewiseCombiner&amp; operator=(const PiecewiseCombiner&amp;) = delete;
51    template &lt;typename H&gt;
52    H add_buffer(H state, const unsigned char* data, size_t size);
53    template &lt;typename H&gt;
54    H add_buffer(H state, const char* data, size_t size) {
55      return add_buffer(std::move(state),
56                        reinterpret_cast&lt;const unsigned char*&gt;(data), size);
57    }
58    template &lt;typename H&gt;
59    H finalize(H state);
60   private:
61    unsigned char buf_[PiecewiseChunkSize()];
62    size_t position_;
63  };
64  template &lt;typename T&gt;
65  struct is_hashable;
66  template &lt;typename H&gt;
67  class HashStateBase {
68   public:
69    template &lt;typename T, typename... Ts&gt;
70    static H combine(H state, const T&amp; value, const Ts&amp;... values);
71    static H combine(H state) { return state; }
72    template &lt;typename T&gt;
73    static H combine_contiguous(H state, const T* data, size_t size);
74    template &lt;typename I&gt;
75    static H combine_unordered(H state, I begin, I end);
76    using AbslInternalPiecewiseCombiner = PiecewiseCombiner;
77    template &lt;typename T&gt;
78    using is_hashable = absl::hash_internal::is_hashable&lt;T&gt;;
79   private:
80    template &lt;typename I&gt;
81    struct CombineUnorderedCallback {
82      I begin;
83      I end;
84      template &lt;typename InnerH, typename ElementStateConsumer&gt;
85      void operator()(InnerH inner_state, ElementStateConsumer cb) {
86        for (; begin != end; ++begin) {
87          inner_state = H::combine(std::move(inner_state), *begin);
88          cb(inner_state);
89        }
90      }
91    };
92  };
93  template &lt;typename T, typename Enable = void&gt;
94  struct is_uniquely_represented : std::false_type {};
95  template &lt;&gt;
96  struct is_uniquely_represented&lt;unsigned char&gt; : std::true_type {};
97  template &lt;typename Integral&gt;
98  struct is_uniquely_represented&lt;
99      Integral, typename std::enable_if&lt;std::is_integral&lt;Integral&gt;::value&gt;::type&gt;
100      : std::true_type {};
101  template &lt;&gt;
102  struct is_uniquely_represented&lt;bool&gt; : std::false_type {};
103  template &lt;typename H, typename T&gt;
104  H hash_bytes(H hash_state, const T&amp; value) {
105    const unsigned char* start = reinterpret_cast&lt;const unsigned char*&gt;(&amp;value);
106    return H::combine_contiguous(std::move(hash_state), start, sizeof(value));
107  }
108  template &lt;typename H, typename B&gt;
109  typename std::enable_if&lt;std::is_same&lt;B, bool&gt;::value, H&gt;::type AbslHashValue(
110      H hash_state, B value) {
111    return H::combine(std::move(hash_state),
112                      static_cast&lt;unsigned char&gt;(value ? 1 : 0));
113  }
114  template &lt;typename H, typename Enum&gt;
115  typename std::enable_if&lt;std::is_enum&lt;Enum&gt;::value, H&gt;::type AbslHashValue(
116      H hash_state, Enum e) {
117    return H::combine(std::move(hash_state),
118                      static_cast&lt;typename std::underlying_type&lt;Enum&gt;::type&gt;(e));
119  }
120  template &lt;typename H, typename Float&gt;
121  typename std::enable_if&lt;std::is_same&lt;Float, float&gt;::value ||
122                              std::is_same&lt;Float, double&gt;::value,
123                          H&gt;::type
124  AbslHashValue(H hash_state, Float value) {
125    return hash_internal::hash_bytes(std::move(hash_state),
126                                     value == 0 ? 0 : value);
127  }
128  template &lt;typename H, typename LongDouble&gt;
129  typename std::enable_if&lt;std::is_same&lt;LongDouble, long double&gt;::value, H&gt;::type
130  AbslHashValue(H hash_state, LongDouble value) {
131    const int category = std::fpclassify(value);
132    switch (category) {
133      case FP_INFINITE:
134        hash_state = H::combine(std::move(hash_state), std::signbit(value));
135        break;
136      case FP_NAN:
137      case FP_ZERO:
138      default:
139        break;
140      case FP_NORMAL:
141      case FP_SUBNORMAL:
142        int exp;
143        auto mantissa = static_cast&lt;double&gt;(std::frexp(value, &amp;exp));
144        hash_state = H::combine(std::move(hash_state), mantissa, exp);
145    }
146    return H::combine(std::move(hash_state), category);
147  }
148  template &lt;typename H, typename T&gt;
149  H AbslHashValue(H hash_state, T* ptr) {
150    auto v = reinterpret_cast&lt;uintptr_t&gt;(ptr);
151    return H::combine(std::move(hash_state), v, v);
152  }
153  template &lt;typename H&gt;
154  H AbslHashValue(H hash_state, std::nullptr_t) {
155    return H::combine(std::move(hash_state), static_cast&lt;void*&gt;(nullptr));
156  }
157  template &lt;typename H, typename T, typename C&gt;
158  H AbslHashValue(H hash_state, T C::*ptr) {
159    auto salient_ptm_size = [](std::size_t n) -&gt; std::size_t {
160  #if defined(_MSC_VER)
161      if (alignof(T C::*) == alignof(int)) {
162        return n;
163      } else {
164        return n == 24 ? 20 : n == 16 ? 12 : n;
165      }
166  #else
167  #ifdef __cpp_lib_has_unique_object_representations
168      static_assert(std::has_unique_object_representations&lt;T C::*&gt;::value);
169  #endif  
170      return n;
171  #endif
172    };
173    return H::combine_contiguous(std::move(hash_state),
174                                 reinterpret_cast&lt;unsigned char*&gt;(&amp;ptr),
175                                 salient_ptm_size(sizeof ptr));
176  }
177  template &lt;typename H, typename T1, typename T2&gt;
178  typename std::enable_if&lt;is_hashable&lt;T1&gt;::value &amp;&amp; is_hashable&lt;T2&gt;::value,
179                          H&gt;::type
180  AbslHashValue(H hash_state, const std::pair&lt;T1, T2&gt;&amp; p) {
181    return H::combine(std::move(hash_state), p.first, p.second);
182  }
183  template &lt;typename H, typename Tuple, size_t... Is&gt;
184  H hash_tuple(H hash_state, const Tuple&amp; t, absl::index_sequence&lt;Is...&gt;) {
185    return H::combine(std::move(hash_state), std::get&lt;Is&gt;(t)...);
186  }
187  template &lt;typename H, typename... Ts&gt;
188  #if defined(_MSC_VER)
189  H
190  #else   
191  typename std::enable_if&lt;absl::conjunction&lt;is_hashable&lt;Ts&gt;...&gt;::value, H&gt;::type
192  #endif  
193  AbslHashValue(H hash_state, const std::tuple&lt;Ts...&gt;&amp; t) {
194    return hash_internal::hash_tuple(std::move(hash_state), t,
195                                     absl::make_index_sequence&lt;sizeof...(Ts)&gt;());
196  }
197  template &lt;typename H, typename T, typename D&gt;
198  H AbslHashValue(H hash_state, const std::unique_ptr&lt;T, D&gt;&amp; ptr) {
199    return H::combine(std::move(hash_state), ptr.get());
200  }
201  template &lt;typename H, typename T&gt;
202  H AbslHashValue(H hash_state, const std::shared_ptr&lt;T&gt;&amp; ptr) {
203    return H::combine(std::move(hash_state), ptr.get());
204  }
205  template &lt;typename H&gt;
206  H AbslHashValue(H hash_state, absl::string_view str) {
207    return H::combine(
208        H::combine_contiguous(std::move(hash_state), str.data(), str.size()),
209        str.size());
210  }
211  template &lt;typename Char, typename Alloc, typename H,
212            typename = absl::enable_if_t&lt;std::is_same&lt;Char, wchar_t&gt;::value ||
213                                         std::is_same&lt;Char, char16_t&gt;::value ||
214                                         std::is_same&lt;Char, char32_t&gt;::value&gt;&gt;
215  H AbslHashValue(
216      H hash_state,
217      const std::basic_string&lt;Char, std::char_traits&lt;Char&gt;, Alloc&gt;&amp; str) {
218    return H::combine(
219        H::combine_contiguous(std::move(hash_state), str.data(), str.size()),
220        str.size());
221  }
222  #ifdef ABSL_HAVE_STD_STRING_VIEW
223  template &lt;typename Char, typename H,
224            typename = absl::enable_if_t&lt;std::is_same&lt;Char, wchar_t&gt;::value ||
225                                         std::is_same&lt;Char, char16_t&gt;::value ||
226                                         std::is_same&lt;Char, char32_t&gt;::value&gt;&gt;
227  H AbslHashValue(H hash_state, std::basic_string_view&lt;Char&gt; str) {
228    return H::combine(
229        H::combine_contiguous(std::move(hash_state), str.data(), str.size()),
230        str.size());
231  }
232  #endif  
233  template &lt;typename H, typename T, size_t N&gt;
234  typename std::enable_if&lt;is_hashable&lt;T&gt;::value, H&gt;::type AbslHashValue(
235      H hash_state, const std::array&lt;T, N&gt;&amp; array) {
236    return H::combine_contiguous(std::move(hash_state), array.data(),
237                                 array.size());
238  }
239  template &lt;typename H, typename T, typename Allocator&gt;
240  typename std::enable_if&lt;is_hashable&lt;T&gt;::value, H&gt;::type AbslHashValue(
241      H hash_state, const std::deque&lt;T, Allocator&gt;&amp; deque) {
242    for (const auto&amp; t : deque) {
243      hash_state = H::combine(std::move(hash_state), t);
244    }
245    return H::combine(std::move(hash_state), deque.size());
246  }
247  template &lt;typename H, typename T, typename Allocator&gt;
248  typename std::enable_if&lt;is_hashable&lt;T&gt;::value, H&gt;::type AbslHashValue(
249      H hash_state, const std::forward_list&lt;T, Allocator&gt;&amp; list) {
250    size_t size = 0;
251    for (const T&amp; t : list) {
252      hash_state = H::combine(std::move(hash_state), t);
253      ++size;
254    }
255    return H::combine(std::move(hash_state), size);
256  }
257  template &lt;typename H, typename T, typename Allocator&gt;
258  typename std::enable_if&lt;is_hashable&lt;T&gt;::value, H&gt;::type AbslHashValue(
259      H hash_state, const std::list&lt;T, Allocator&gt;&amp; list) {
260    for (const auto&amp; t : list) {
261      hash_state = H::combine(std::move(hash_state), t);
262    }
263    return H::combine(std::move(hash_state), list.size());
264  }
265  template &lt;typename H, typename T, typename Allocator&gt;
266  typename std::enable_if&lt;is_hashable&lt;T&gt;::value &amp;&amp; !std::is_same&lt;T, bool&gt;::value,
267                          H&gt;::type
268  AbslHashValue(H hash_state, const std::vector&lt;T, Allocator&gt;&amp; vector) {
269    return H::combine(H::combine_contiguous(std::move(hash_state), vector.data(),
270                                            vector.size()),
271                      vector.size());
272  }
273  #if defined(ABSL_IS_BIG_ENDIAN) &amp;&amp; \
274      (defined(__GLIBCXX__) || defined(__GLIBCPP__))
275  template &lt;typename H, typename T, typename Allocator&gt;
276  typename std::enable_if&lt;is_hashable&lt;T&gt;::value &amp;&amp; std::is_same&lt;T, bool&gt;::value,
277                          H&gt;::type
278  AbslHashValue(H hash_state, const std::vector&lt;T, Allocator&gt;&amp; vector) {
279    typename H::AbslInternalPiecewiseCombiner combiner;
280    for (const auto&amp; i : vector) {
281      unsigned char c = static_cast&lt;unsigned char&gt;(i);
282      hash_state = combiner.add_buffer(std::move(hash_state), &amp;c, sizeof(c));
283    }
284    return H::combine(combiner.finalize(std::move(hash_state)), vector.size());
285  }
286  #else
287  template &lt;typename H, typename T, typename Allocator&gt;
288  typename std::enable_if&lt;is_hashable&lt;T&gt;::value &amp;&amp; std::is_same&lt;T, bool&gt;::value,
289                          H&gt;::type
290  AbslHashValue(H hash_state, const std::vector&lt;T, Allocator&gt;&amp; vector) {
291    return H::combine(std::move(hash_state),
292                      std::hash&lt;std::vector&lt;T, Allocator&gt;&gt;{}(vector),
293                      vector.size());
294  }
295  #endif
296  template &lt;typename H, typename Key, typename T, typename Compare,
297            typename Allocator&gt;
298  typename std::enable_if&lt;is_hashable&lt;Key&gt;::value &amp;&amp; is_hashable&lt;T&gt;::value,
299                          H&gt;::type
300  AbslHashValue(H hash_state, const std::map&lt;Key, T, Compare, Allocator&gt;&amp; map) {
301    for (const auto&amp; t : map) {
302      hash_state = H::combine(std::move(hash_state), t);
303    }
304    return H::combine(std::move(hash_state), map.size());
305  }
306  template &lt;typename H, typename Key, typename T, typename Compare,
307            typename Allocator&gt;
308  typename std::enable_if&lt;is_hashable&lt;Key&gt;::value &amp;&amp; is_hashable&lt;T&gt;::value,
309                          H&gt;::type
310  AbslHashValue(H hash_state,
311                const std::multimap&lt;Key, T, Compare, Allocator&gt;&amp; map) {
312    for (const auto&amp; t : map) {
313      hash_state = H::combine(std::move(hash_state), t);
314    }
315    return H::combine(std::move(hash_state), map.size());
316  }
317  template &lt;typename H, typename Key, typename Compare, typename Allocator&gt;
318  typename std::enable_if&lt;is_hashable&lt;Key&gt;::value, H&gt;::type AbslHashValue(
319      H hash_state, const std::set&lt;Key, Compare, Allocator&gt;&amp; set) {
320    for (const auto&amp; t : set) {
321      hash_state = H::combine(std::move(hash_state), t);
322    }
323    return H::combine(std::move(hash_state), set.size());
324  }
325  template &lt;typename H, typename Key, typename Compare, typename Allocator&gt;
326  typename std::enable_if&lt;is_hashable&lt;Key&gt;::value, H&gt;::type AbslHashValue(
327      H hash_state, const std::multiset&lt;Key, Compare, Allocator&gt;&amp; set) {
328    for (const auto&amp; t : set) {
329      hash_state = H::combine(std::move(hash_state), t);
330    }
331    return H::combine(std::move(hash_state), set.size());
332  }
333  template &lt;typename H, typename Key, typename Hash, typename KeyEqual,
334            typename Alloc&gt;
335  typename std::enable_if&lt;is_hashable&lt;Key&gt;::value, H&gt;::type AbslHashValue(
<span onclick='openModal()' class='match'>336      H hash_state, const std::unordered_set&lt;Key, Hash, KeyEqual, Alloc&gt;&amp; s) {
337    return H::combine(
338        H::combine_unordered(std::move(hash_state), s.begin(), s.end()),
339        s.size());
340  }
341  template &lt;typename H, typename Key, typename Hash, typename KeyEqual,
342            typename Alloc&gt;
</span>343  typename std::enable_if&lt;is_hashable&lt;Key&gt;::value, H&gt;::type AbslHashValue(
344      H hash_state,
345      const std::unordered_multiset&lt;Key, Hash, KeyEqual, Alloc&gt;&amp; s) {
346    return H::combine(
347        H::combine_unordered(std::move(hash_state), s.begin(), s.end()),
348        s.size());
349  }
350  template &lt;typename H, typename Key, typename T, typename Hash,
351            typename KeyEqual, typename Alloc&gt;
352  typename std::enable_if&lt;is_hashable&lt;Key&gt;::value &amp;&amp; is_hashable&lt;T&gt;::value,
353                          H&gt;::type
354  AbslHashValue(H hash_state,
355                const std::unordered_map&lt;Key, T, Hash, KeyEqual, Alloc&gt;&amp; s) {
356    return H::combine(
357        H::combine_unordered(std::move(hash_state), s.begin(), s.end()),
358        s.size());
359  }
360  template &lt;typename H, typename Key, typename T, typename Hash,
361            typename KeyEqual, typename Alloc&gt;
362  typename std::enable_if&lt;is_hashable&lt;Key&gt;::value &amp;&amp; is_hashable&lt;T&gt;::value,
363                          H&gt;::type
364  AbslHashValue(H hash_state,
365                const std::unordered_multimap&lt;Key, T, Hash, KeyEqual, Alloc&gt;&amp; s) {
366    return H::combine(
367        H::combine_unordered(std::move(hash_state), s.begin(), s.end()),
368        s.size());
369  }
370  template &lt;typename H, typename T&gt;
371  typename std::enable_if&lt;is_hashable&lt;T&gt;::value, H&gt;::type AbslHashValue(
372      H hash_state, std::reference_wrapper&lt;T&gt; opt) {
373    return H::combine(std::move(hash_state), opt.get());
374  }
375  template &lt;typename H, typename T&gt;
376  typename std::enable_if&lt;is_hashable&lt;T&gt;::value, H&gt;::type AbslHashValue(
377      H hash_state, const absl::optional&lt;T&gt;&amp; opt) {
378    if (opt) hash_state = H::combine(std::move(hash_state), *opt);
379    return H::combine(std::move(hash_state), opt.has_value());
380  }
381  template &lt;typename H&gt;
382  struct VariantVisitor {
383    H&amp;&amp; hash_state;
384    template &lt;typename T&gt;
385    H operator()(const T&amp; t) const {
386      return H::combine(std::move(hash_state), t);
387    }
388  };
389  template &lt;typename H, typename... T&gt;
390  typename std::enable_if&lt;conjunction&lt;is_hashable&lt;T&gt;...&gt;::value, H&gt;::type
391  AbslHashValue(H hash_state, const absl::variant&lt;T...&gt;&amp; v) {
392    if (!v.valueless_by_exception()) {
393      hash_state = absl::visit(VariantVisitor&lt;H&gt;{std::move(hash_state)}, v);
394    }
395    return H::combine(std::move(hash_state), v.index());
396  }
397  #if defined(ABSL_IS_BIG_ENDIAN) &amp;&amp; \
398      (defined(__GLIBCXX__) || defined(__GLIBCPP__))
399  template &lt;typename H, size_t N&gt;
400  H AbslHashValue(H hash_state, const std::bitset&lt;N&gt;&amp; set) {
401    typename H::AbslInternalPiecewiseCombiner combiner;
402    for (int i = 0; i &lt; N; i++) {
403      unsigned char c = static_cast&lt;unsigned char&gt;(set[i]);
404      hash_state = combiner.add_buffer(std::move(hash_state), &amp;c, sizeof(c));
405    }
406    return H::combine(combiner.finalize(std::move(hash_state)), N);
407  }
408  #endif
409  template &lt;typename H, typename T&gt;
410  typename std::enable_if&lt;is_uniquely_represented&lt;T&gt;::value, H&gt;::type
411  hash_range_or_bytes(H hash_state, const T* data, size_t size) {
412    const auto* bytes = reinterpret_cast&lt;const unsigned char*&gt;(data);
413    return H::combine_contiguous(std::move(hash_state), bytes, sizeof(T) * size);
414  }
415  template &lt;typename H, typename T&gt;
416  typename std::enable_if&lt;!is_uniquely_represented&lt;T&gt;::value, H&gt;::type
417  hash_range_or_bytes(H hash_state, const T* data, size_t size) {
418    for (const auto end = data + size; data &lt; end; ++data) {
419      hash_state = H::combine(std::move(hash_state), *data);
420    }
421    return hash_state;
422  }
423  #if defined(ABSL_INTERNAL_LEGACY_HASH_NAMESPACE) &amp;&amp; \
424      ABSL_META_INTERNAL_STD_HASH_SFINAE_FRIENDLY_
425  #define ABSL_HASH_INTERNAL_SUPPORT_LEGACY_HASH_ 1
426  #else
427  #define ABSL_HASH_INTERNAL_SUPPORT_LEGACY_HASH_ 0
428  #endif
429  struct HashSelect {
430   private:
431    struct State : HashStateBase&lt;State&gt; {
432      static State combine_contiguous(State hash_state, const unsigned char*,
433                                      size_t);
434      using State::HashStateBase::combine_contiguous;
435    };
436    struct UniquelyRepresentedProbe {
437      template &lt;typename H, typename T&gt;
438      static auto Invoke(H state, const T&amp; value)
439          -&gt; absl::enable_if_t&lt;is_uniquely_represented&lt;T&gt;::value, H&gt; {
440        return hash_internal::hash_bytes(std::move(state), value);
441      }
442    };
443    struct HashValueProbe {
444      template &lt;typename H, typename T&gt;
445      static auto Invoke(H state, const T&amp; value) -&gt; absl::enable_if_t&lt;
446          std::is_same&lt;H,
447                       decltype(AbslHashValue(std::move(state), value))&gt;::value,
448          H&gt; {
449        return AbslHashValue(std::move(state), value);
450      }
451    };
452    struct LegacyHashProbe {
453  #if ABSL_HASH_INTERNAL_SUPPORT_LEGACY_HASH_
454      template &lt;typename H, typename T&gt;
455      static auto Invoke(H state, const T&amp; value) -&gt; absl::enable_if_t&lt;
456          std::is_convertible&lt;
457              decltype(ABSL_INTERNAL_LEGACY_HASH_NAMESPACE::hash&lt;T&gt;()(value)),
458              size_t&gt;::value,
459          H&gt; {
460        return hash_internal::hash_bytes(
461            std::move(state),
462            ABSL_INTERNAL_LEGACY_HASH_NAMESPACE::hash&lt;T&gt;{}(value));
463      }
464  #endif  
465    };
466    struct StdHashProbe {
467      template &lt;typename H, typename T&gt;
468      static auto Invoke(H state, const T&amp; value)
469          -&gt; absl::enable_if_t&lt;type_traits_internal::IsHashable&lt;T&gt;::value, H&gt; {
470        return hash_internal::hash_bytes(std::move(state), std::hash&lt;T&gt;{}(value));
471      }
472    };
473    template &lt;typename Hash, typename T&gt;
474    struct Probe : Hash {
475     private:
476      template &lt;typename H, typename = decltype(H::Invoke(
477                                std::declval&lt;State&gt;(), std::declval&lt;const T&amp;&gt;()))&gt;
478      static std::true_type Test(int);
479      template &lt;typename U&gt;
480      static std::false_type Test(char);
481     public:
482      static constexpr bool value = decltype(Test&lt;Hash&gt;(0))::value;
483    };
484   public:
485    template &lt;typename T&gt;
486    using Apply = absl::disjunction&lt;         
487        Probe&lt;UniquelyRepresentedProbe, T&gt;,  
488        Probe&lt;HashValueProbe, T&gt;,            
489        Probe&lt;LegacyHashProbe, T&gt;,           
490        Probe&lt;StdHashProbe, T&gt;,              
491        std::false_type&gt;;
492  };
493  template &lt;typename T&gt;
494  struct is_hashable
495      : std::integral_constant&lt;bool, HashSelect::template Apply&lt;T&gt;::value&gt; {};
496  class ABSL_DLL MixingHashState : public HashStateBase&lt;MixingHashState&gt; {
497  #ifdef ABSL_HAVE_INTRINSIC_INT128
498    using uint128 = __uint128_t;
499  #else   
500    using uint128 = absl::uint128;
501  #endif  
502    static constexpr uint64_t kMul =
503    sizeof(size_t) == 4 ? uint64_t{0xcc9e2d51}
504                        : uint64_t{0x9ddfea08eb382d69};
505    template &lt;typename T&gt;
506    using IntegralFastPath =
507        conjunction&lt;std::is_integral&lt;T&gt;, is_uniquely_represented&lt;T&gt;&gt;;
508   public:
509    MixingHashState(MixingHashState&amp;&amp;) = default;
510    MixingHashState&amp; operator=(MixingHashState&amp;&amp;) = default;
511    static MixingHashState combine_contiguous(MixingHashState hash_state,
512                                              const unsigned char* first,
513                                              size_t size) {
514      return MixingHashState(
515          CombineContiguousImpl(hash_state.state_, first, size,
516                                std::integral_constant&lt;int, sizeof(size_t)&gt;{}));
517    }
518    using MixingHashState::HashStateBase::combine_contiguous;
519    template &lt;typename T, absl::enable_if_t&lt;IntegralFastPath&lt;T&gt;::value, int&gt; = 0&gt;
520    static size_t hash(T value) {
521      return static_cast&lt;size_t&gt;(
522          Mix(Seed(), static_cast&lt;std::make_unsigned_t&lt;T&gt;&gt;(value)));
523    }
524    template &lt;typename T, absl::enable_if_t&lt;!IntegralFastPath&lt;T&gt;::value, int&gt; = 0&gt;
525    static size_t hash(const T&amp; value) {
526      return static_cast&lt;size_t&gt;(combine(MixingHashState{}, value).state_);
527    }
528   private:
529    MixingHashState() : state_(Seed()) {}
530    friend class MixingHashState::HashStateBase;
531    template &lt;typename CombinerT&gt;
532    static MixingHashState RunCombineUnordered(MixingHashState state,
533                                               CombinerT combiner) {
534      uint64_t unordered_state = 0;
535      combiner(MixingHashState{}, [&amp;](MixingHashState&amp; inner_state) {
536        auto element_state = inner_state.state_;
537        unordered_state += element_state;
538        if (unordered_state &lt; element_state) {
539          ++unordered_state;
540        }
541        inner_state = MixingHashState{};
542      });
543      return MixingHashState::combine(std::move(state), unordered_state);
544    }
545    friend class absl::HashState;
546    MixingHashState(const MixingHashState&amp;) = default;
547    explicit MixingHashState(uint64_t state) : state_(state) {}
548    static uint64_t CombineContiguousImpl(uint64_t state,
549                                          const unsigned char* first, size_t len,
550                                          std::integral_constant&lt;int, 4&gt;
551                                          );
552    static uint64_t CombineContiguousImpl(uint64_t state,
553                                          const unsigned char* first, size_t len,
554                                          std::integral_constant&lt;int, 8&gt;
555                                          );
556    static uint64_t CombineLargeContiguousImpl32(uint64_t state,
557                                                 const unsigned char* first,
558                                                 size_t len);
559    static uint64_t CombineLargeContiguousImpl64(uint64_t state,
560                                                 const unsigned char* first,
561                                                 size_t len);
562    static std::pair&lt;uint64_t, uint64_t&gt; Read9To16(const unsigned char* p,
563                                                   size_t len) {
564      uint64_t low_mem = absl::base_internal::UnalignedLoad64(p);
565      uint64_t high_mem = absl::base_internal::UnalignedLoad64(p + len - 8);
566  #ifdef ABSL_IS_LITTLE_ENDIAN
567      uint64_t most_significant = high_mem;
568      uint64_t least_significant = low_mem;
569  #else
570      uint64_t most_significant = low_mem;
571      uint64_t least_significant = high_mem;
572  #endif
573      return {least_significant, most_significant};
574    }
575    static uint64_t Read4To8(const unsigned char* p, size_t len) {
576      uint32_t low_mem = absl::base_internal::UnalignedLoad32(p);
577      uint32_t high_mem = absl::base_internal::UnalignedLoad32(p + len - 4);
578  #ifdef ABSL_IS_LITTLE_ENDIAN
579      uint32_t most_significant = high_mem;
580      uint32_t least_significant = low_mem;
581  #else
582      uint32_t most_significant = low_mem;
583      uint32_t least_significant = high_mem;
584  #endif
585      return (static_cast&lt;uint64_t&gt;(most_significant) &lt;&lt; (len - 4) * 8) |
586             least_significant;
587    }
588    static uint32_t Read1To3(const unsigned char* p, size_t len) {
589      unsigned char mem0 = p[0];
590      unsigned char mem1 = p[len / 2];
591      unsigned char mem2 = p[len - 1];
592  #ifdef ABSL_IS_LITTLE_ENDIAN
593      unsigned char significant2 = mem2;
594      unsigned char significant1 = mem1;
595      unsigned char significant0 = mem0;
596  #else
597      unsigned char significant2 = mem0;
598      unsigned char significant1 = len == 2 ? mem0 : mem1;
599      unsigned char significant0 = mem2;
600  #endif
601      return static_cast&lt;uint32_t&gt;(significant0 |                     
602                                   (significant1 &lt;&lt; (len / 2 * 8)) |  
603                                   (significant2 &lt;&lt; ((len - 1) * 8)));
604    }
605    ABSL_ATTRIBUTE_ALWAYS_INLINE static uint64_t Mix(uint64_t state, uint64_t v) {
606      using MultType =
607          absl::conditional_t&lt;sizeof(size_t) == 4, uint64_t, uint128&gt;;
608      MultType m = state + v;
609      m *= kMul;
610      return static_cast&lt;uint64_t&gt;(m ^ (m &gt;&gt; (sizeof(m) * 8 / 2)));
611    }
612    static uint64_t LowLevelHashImpl(const unsigned char* data, size_t len);
613    ABSL_ATTRIBUTE_ALWAYS_INLINE static uint64_t Hash64(const unsigned char* data,
614                                                        size_t len) {
615  #ifdef ABSL_HAVE_INTRINSIC_INT128
616      return LowLevelHashImpl(data, len);
617  #else
618      return hash_internal::CityHash64(reinterpret_cast&lt;const char*&gt;(data), len);
619  #endif
620    }
621    ABSL_ATTRIBUTE_ALWAYS_INLINE static uint64_t Seed() {
622  #if (!defined(__clang__) || __clang_major__ &gt; 11) &amp;&amp; \
623      (!defined(__apple_build_version__) ||            \
624       __apple_build_version__ &gt;= 19558921)  
625      return static_cast&lt;uint64_t&gt;(reinterpret_cast&lt;uintptr_t&gt;(&amp;kSeed));
626  #else
627      return static_cast&lt;uint64_t&gt;(reinterpret_cast&lt;uintptr_t&gt;(kSeed));
628  #endif
629    }
630    static const void* const kSeed;
631    uint64_t state_;
632  };
633  inline uint64_t MixingHashState::CombineContiguousImpl(
634      uint64_t state, const unsigned char* first, size_t len,
635      std::integral_constant&lt;int, 4&gt; &amp;bsol;* sizeof_size_t */) {
636    uint64_t v;
637    if (len &gt; 8) {
638      if (ABSL_PREDICT_FALSE(len &gt; PiecewiseChunkSize())) {
639        return CombineLargeContiguousImpl32(state, first, len);
640      }
641      v = hash_internal::CityHash32(reinterpret_cast&lt;const char*&gt;(first), len);
642    } else if (len &gt;= 4) {
643      v = Read4To8(first, len);
644    } else if (len &gt; 0) {
645      v = Read1To3(first, len);
646    } else {
647      return state;
648    }
649    return Mix(state, v);
650  }
651  inline uint64_t MixingHashState::CombineContiguousImpl(
652      uint64_t state, const unsigned char* first, size_t len,
653      std::integral_constant&lt;int, 8&gt; &amp;bsol;* sizeof_size_t */) {
654    uint64_t v;
655    if (len &gt; 16) {
656      if (ABSL_PREDICT_FALSE(len &gt; PiecewiseChunkSize())) {
657        return CombineLargeContiguousImpl64(state, first, len);
658      }
659      v = Hash64(first, len);
660    } else if (len &gt; 8) {
661      auto p = Read9To16(first, len);
662      uint64_t lo = p.first;
663      uint64_t hi = p.second;
664      lo = absl::rotr(lo, 53);
665      state += kMul;
666      lo += state;
667      state ^= hi;
668      uint128 m = state;
669      m *= lo;
670      return static_cast&lt;uint64_t&gt;(m ^ (m &gt;&gt; 64));
671    } else if (len &gt;= 4) {
672      v = Read4To8(first, len);
673    } else if (len &gt; 0) {
674      v = Read1To3(first, len);
675    } else {
676      return state;
677    }
678    return Mix(state, v);
679  }
680  struct AggregateBarrier {};
681  struct PoisonedHash : private AggregateBarrier {
682    PoisonedHash() = delete;
683    PoisonedHash(const PoisonedHash&amp;) = delete;
684    PoisonedHash&amp; operator=(const PoisonedHash&amp;) = delete;
685  };
686  template &lt;typename T&gt;
687  struct HashImpl {
688    size_t operator()(const T&amp; value) const {
689      return MixingHashState::hash(value);
690    }
691  };
692  template &lt;typename T&gt;
693  struct Hash
694      : absl::conditional_t&lt;is_hashable&lt;T&gt;::value, HashImpl&lt;T&gt;, PoisonedHash&gt; {};
695  template &lt;typename H&gt;
696  template &lt;typename T, typename... Ts&gt;
697  H HashStateBase&lt;H&gt;::combine(H state, const T&amp; value, const Ts&amp;... values) {
698    return H::combine(hash_internal::HashSelect::template Apply&lt;T&gt;::Invoke(
699                          std::move(state), value),
700                      values...);
701  }
702  template &lt;typename H&gt;
703  template &lt;typename T&gt;
704  H HashStateBase&lt;H&gt;::combine_contiguous(H state, const T* data, size_t size) {
705    return hash_internal::hash_range_or_bytes(std::move(state), data, size);
706  }
707  template &lt;typename H&gt;
708  template &lt;typename I&gt;
709  H HashStateBase&lt;H&gt;::combine_unordered(H state, I begin, I end) {
710    return H::RunCombineUnordered(std::move(state),
711                                  CombineUnorderedCallback&lt;I&gt;{begin, end});
712  }
713  template &lt;typename H&gt;
714  H PiecewiseCombiner::add_buffer(H state, const unsigned char* data,
715                                  size_t size) {
716    if (position_ + size &lt; PiecewiseChunkSize()) {
717      memcpy(buf_ + position_, data, size);
718      position_ += size;
719      return state;
720    }
721    if (position_ != 0) {
722      const size_t bytes_needed = PiecewiseChunkSize() - position_;
723      memcpy(buf_ + position_, data, bytes_needed);
724      state = H::combine_contiguous(std::move(state), buf_, PiecewiseChunkSize());
725      data += bytes_needed;
726      size -= bytes_needed;
727    }
728    while (size &gt;= PiecewiseChunkSize()) {
729      state = H::combine_contiguous(std::move(state), data, PiecewiseChunkSize());
730      data += PiecewiseChunkSize();
731      size -= PiecewiseChunkSize();
732    }
733    memcpy(buf_, data, size);
734    position_ = size;
735    return state;
736  }
737  template &lt;typename H&gt;
738  H PiecewiseCombiner::finalize(H state) {
739    return H::combine_contiguous(std::move(state), buf_, position_);
740  }
741  }  
742  ABSL_NAMESPACE_END
743  }  
744  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-hash_12.h</h3>
            <pre><code>1  #ifndef ABSL_HASH_INTERNAL_HASH_H_
2  #define ABSL_HASH_INTERNAL_HASH_H_
3  #include &lt;algorithm&gt;
4  #include &lt;array&gt;
5  #include &lt;bitset&gt;
6  #include &lt;cmath&gt;
7  #include &lt;cstddef&gt;
8  #include &lt;cstring&gt;
9  #include &lt;deque&gt;
10  #include &lt;forward_list&gt;
11  #include &lt;functional&gt;
12  #include &lt;iterator&gt;
13  #include &lt;limits&gt;
14  #include &lt;list&gt;
15  #include &lt;map&gt;
16  #include &lt;memory&gt;
17  #include &lt;set&gt;
18  #include &lt;string&gt;
19  #include &lt;tuple&gt;
20  #include &lt;type_traits&gt;
21  #include &lt;unordered_map&gt;
22  #include &lt;unordered_set&gt;
23  #include &lt;utility&gt;
24  #include &lt;vector&gt;
25  #include &quot;absl/base/config.h&quot;
26  #include &quot;absl/base/internal/unaligned_access.h&quot;
27  #include &quot;absl/base/port.h&quot;
28  #include &quot;absl/container/fixed_array.h&quot;
29  #include &quot;absl/hash/internal/city.h&quot;
30  #include &quot;absl/hash/internal/low_level_hash.h&quot;
31  #include &quot;absl/meta/type_traits.h&quot;
32  #include &quot;absl/numeric/bits.h&quot;
33  #include &quot;absl/numeric/int128.h&quot;
34  #include &quot;absl/strings/string_view.h&quot;
35  #include &quot;absl/types/optional.h&quot;
36  #include &quot;absl/types/variant.h&quot;
37  #include &quot;absl/utility/utility.h&quot;
38  #ifdef ABSL_HAVE_STD_STRING_VIEW
39  #include &lt;string_view&gt;
40  #endif
41  namespace absl {
42  ABSL_NAMESPACE_BEGIN
43  class HashState;
44  namespace hash_internal {
45  constexpr size_t PiecewiseChunkSize() { return 1024; }
46  class PiecewiseCombiner {
47   public:
48    PiecewiseCombiner() : position_(0) {}
49    PiecewiseCombiner(const PiecewiseCombiner&amp;) = delete;
50    PiecewiseCombiner&amp; operator=(const PiecewiseCombiner&amp;) = delete;
51    template &lt;typename H&gt;
52    H add_buffer(H state, const unsigned char* data, size_t size);
53    template &lt;typename H&gt;
54    H add_buffer(H state, const char* data, size_t size) {
55      return add_buffer(std::move(state),
56                        reinterpret_cast&lt;const unsigned char*&gt;(data), size);
57    }
58    template &lt;typename H&gt;
59    H finalize(H state);
60   private:
61    unsigned char buf_[PiecewiseChunkSize()];
62    size_t position_;
63  };
64  template &lt;typename T&gt;
65  struct is_hashable;
66  template &lt;typename H&gt;
67  class HashStateBase {
68   public:
69    template &lt;typename T, typename... Ts&gt;
70    static H combine(H state, const T&amp; value, const Ts&amp;... values);
71    static H combine(H state) { return state; }
72    template &lt;typename T&gt;
73    static H combine_contiguous(H state, const T* data, size_t size);
74    template &lt;typename I&gt;
75    static H combine_unordered(H state, I begin, I end);
76    using AbslInternalPiecewiseCombiner = PiecewiseCombiner;
77    template &lt;typename T&gt;
78    using is_hashable = absl::hash_internal::is_hashable&lt;T&gt;;
79   private:
80    template &lt;typename I&gt;
81    struct CombineUnorderedCallback {
82      I begin;
83      I end;
84      template &lt;typename InnerH, typename ElementStateConsumer&gt;
85      void operator()(InnerH inner_state, ElementStateConsumer cb) {
86        for (; begin != end; ++begin) {
87          inner_state = H::combine(std::move(inner_state), *begin);
88          cb(inner_state);
89        }
90      }
91    };
92  };
93  template &lt;typename T, typename Enable = void&gt;
94  struct is_uniquely_represented : std::false_type {};
95  template &lt;&gt;
96  struct is_uniquely_represented&lt;unsigned char&gt; : std::true_type {};
97  template &lt;typename Integral&gt;
98  struct is_uniquely_represented&lt;
99      Integral, typename std::enable_if&lt;std::is_integral&lt;Integral&gt;::value&gt;::type&gt;
100      : std::true_type {};
101  template &lt;&gt;
102  struct is_uniquely_represented&lt;bool&gt; : std::false_type {};
103  template &lt;typename H, typename T&gt;
104  H hash_bytes(H hash_state, const T&amp; value) {
105    const unsigned char* start = reinterpret_cast&lt;const unsigned char*&gt;(&amp;value);
106    return H::combine_contiguous(std::move(hash_state), start, sizeof(value));
107  }
108  template &lt;typename H, typename B&gt;
109  typename std::enable_if&lt;std::is_same&lt;B, bool&gt;::value, H&gt;::type AbslHashValue(
110      H hash_state, B value) {
111    return H::combine(std::move(hash_state),
112                      static_cast&lt;unsigned char&gt;(value ? 1 : 0));
113  }
114  template &lt;typename H, typename Enum&gt;
115  typename std::enable_if&lt;std::is_enum&lt;Enum&gt;::value, H&gt;::type AbslHashValue(
116      H hash_state, Enum e) {
117    return H::combine(std::move(hash_state),
118                      static_cast&lt;typename std::underlying_type&lt;Enum&gt;::type&gt;(e));
119  }
120  template &lt;typename H, typename Float&gt;
121  typename std::enable_if&lt;std::is_same&lt;Float, float&gt;::value ||
122                              std::is_same&lt;Float, double&gt;::value,
123                          H&gt;::type
124  AbslHashValue(H hash_state, Float value) {
125    return hash_internal::hash_bytes(std::move(hash_state),
126                                     value == 0 ? 0 : value);
127  }
128  template &lt;typename H, typename LongDouble&gt;
129  typename std::enable_if&lt;std::is_same&lt;LongDouble, long double&gt;::value, H&gt;::type
130  AbslHashValue(H hash_state, LongDouble value) {
131    const int category = std::fpclassify(value);
132    switch (category) {
133      case FP_INFINITE:
134        hash_state = H::combine(std::move(hash_state), std::signbit(value));
135        break;
136      case FP_NAN:
137      case FP_ZERO:
138      default:
139        break;
140      case FP_NORMAL:
141      case FP_SUBNORMAL:
142        int exp;
143        auto mantissa = static_cast&lt;double&gt;(std::frexp(value, &amp;exp));
144        hash_state = H::combine(std::move(hash_state), mantissa, exp);
145    }
146    return H::combine(std::move(hash_state), category);
147  }
148  template &lt;typename H, typename T&gt;
149  H AbslHashValue(H hash_state, T* ptr) {
150    auto v = reinterpret_cast&lt;uintptr_t&gt;(ptr);
151    return H::combine(std::move(hash_state), v, v);
152  }
153  template &lt;typename H&gt;
154  H AbslHashValue(H hash_state, std::nullptr_t) {
155    return H::combine(std::move(hash_state), static_cast&lt;void*&gt;(nullptr));
156  }
157  template &lt;typename H, typename T, typename C&gt;
158  H AbslHashValue(H hash_state, T C::*ptr) {
159    auto salient_ptm_size = [](std::size_t n) -&gt; std::size_t {
160  #if defined(_MSC_VER)
161      if (alignof(T C::*) == alignof(int)) {
162        return n;
163      } else {
164        return n == 24 ? 20 : n == 16 ? 12 : n;
165      }
166  #else
167  #ifdef __cpp_lib_has_unique_object_representations
168      static_assert(std::has_unique_object_representations&lt;T C::*&gt;::value);
169  #endif  
170      return n;
171  #endif
172    };
173    return H::combine_contiguous(std::move(hash_state),
174                                 reinterpret_cast&lt;unsigned char*&gt;(&amp;ptr),
175                                 salient_ptm_size(sizeof ptr));
176  }
177  template &lt;typename H, typename T1, typename T2&gt;
178  typename std::enable_if&lt;is_hashable&lt;T1&gt;::value &amp;&amp; is_hashable&lt;T2&gt;::value,
179                          H&gt;::type
180  AbslHashValue(H hash_state, const std::pair&lt;T1, T2&gt;&amp; p) {
181    return H::combine(std::move(hash_state), p.first, p.second);
182  }
183  template &lt;typename H, typename Tuple, size_t... Is&gt;
184  H hash_tuple(H hash_state, const Tuple&amp; t, absl::index_sequence&lt;Is...&gt;) {
185    return H::combine(std::move(hash_state), std::get&lt;Is&gt;(t)...);
186  }
187  template &lt;typename H, typename... Ts&gt;
188  #if defined(_MSC_VER)
189  H
190  #else   
191  typename std::enable_if&lt;absl::conjunction&lt;is_hashable&lt;Ts&gt;...&gt;::value, H&gt;::type
192  #endif  
193  AbslHashValue(H hash_state, const std::tuple&lt;Ts...&gt;&amp; t) {
194    return hash_internal::hash_tuple(std::move(hash_state), t,
195                                     absl::make_index_sequence&lt;sizeof...(Ts)&gt;());
196  }
197  template &lt;typename H, typename T, typename D&gt;
198  H AbslHashValue(H hash_state, const std::unique_ptr&lt;T, D&gt;&amp; ptr) {
199    return H::combine(std::move(hash_state), ptr.get());
200  }
201  template &lt;typename H, typename T&gt;
202  H AbslHashValue(H hash_state, const std::shared_ptr&lt;T&gt;&amp; ptr) {
203    return H::combine(std::move(hash_state), ptr.get());
204  }
205  template &lt;typename H&gt;
206  H AbslHashValue(H hash_state, absl::string_view str) {
207    return H::combine(
208        H::combine_contiguous(std::move(hash_state), str.data(), str.size()),
209        str.size());
210  }
211  template &lt;typename Char, typename Alloc, typename H,
212            typename = absl::enable_if_t&lt;std::is_same&lt;Char, wchar_t&gt;::value ||
213                                         std::is_same&lt;Char, char16_t&gt;::value ||
214                                         std::is_same&lt;Char, char32_t&gt;::value&gt;&gt;
215  H AbslHashValue(
216      H hash_state,
217      const std::basic_string&lt;Char, std::char_traits&lt;Char&gt;, Alloc&gt;&amp; str) {
218    return H::combine(
219        H::combine_contiguous(std::move(hash_state), str.data(), str.size()),
220        str.size());
221  }
222  #ifdef ABSL_HAVE_STD_STRING_VIEW
223  template &lt;typename Char, typename H,
224            typename = absl::enable_if_t&lt;std::is_same&lt;Char, wchar_t&gt;::value ||
225                                         std::is_same&lt;Char, char16_t&gt;::value ||
226                                         std::is_same&lt;Char, char32_t&gt;::value&gt;&gt;
227  H AbslHashValue(H hash_state, std::basic_string_view&lt;Char&gt; str) {
228    return H::combine(
229        H::combine_contiguous(std::move(hash_state), str.data(), str.size()),
230        str.size());
231  }
232  #endif  
233  template &lt;typename H, typename T, size_t N&gt;
234  typename std::enable_if&lt;is_hashable&lt;T&gt;::value, H&gt;::type AbslHashValue(
235      H hash_state, const std::array&lt;T, N&gt;&amp; array) {
236    return H::combine_contiguous(std::move(hash_state), array.data(),
237                                 array.size());
238  }
239  template &lt;typename H, typename T, typename Allocator&gt;
240  typename std::enable_if&lt;is_hashable&lt;T&gt;::value, H&gt;::type AbslHashValue(
241      H hash_state, const std::deque&lt;T, Allocator&gt;&amp; deque) {
242    for (const auto&amp; t : deque) {
243      hash_state = H::combine(std::move(hash_state), t);
244    }
245    return H::combine(std::move(hash_state), deque.size());
246  }
247  template &lt;typename H, typename T, typename Allocator&gt;
248  typename std::enable_if&lt;is_hashable&lt;T&gt;::value, H&gt;::type AbslHashValue(
249      H hash_state, const std::forward_list&lt;T, Allocator&gt;&amp; list) {
250    size_t size = 0;
251    for (const T&amp; t : list) {
252      hash_state = H::combine(std::move(hash_state), t);
253      ++size;
254    }
255    return H::combine(std::move(hash_state), size);
256  }
257  template &lt;typename H, typename T, typename Allocator&gt;
258  typename std::enable_if&lt;is_hashable&lt;T&gt;::value, H&gt;::type AbslHashValue(
259      H hash_state, const std::list&lt;T, Allocator&gt;&amp; list) {
260    for (const auto&amp; t : list) {
261      hash_state = H::combine(std::move(hash_state), t);
262    }
263    return H::combine(std::move(hash_state), list.size());
264  }
265  template &lt;typename H, typename T, typename Allocator&gt;
266  typename std::enable_if&lt;is_hashable&lt;T&gt;::value &amp;&amp; !std::is_same&lt;T, bool&gt;::value,
267                          H&gt;::type
268  AbslHashValue(H hash_state, const std::vector&lt;T, Allocator&gt;&amp; vector) {
269    return H::combine(H::combine_contiguous(std::move(hash_state), vector.data(),
270                                            vector.size()),
271                      vector.size());
272  }
273  #if defined(ABSL_IS_BIG_ENDIAN) &amp;&amp; \
274      (defined(__GLIBCXX__) || defined(__GLIBCPP__))
275  template &lt;typename H, typename T, typename Allocator&gt;
276  typename std::enable_if&lt;is_hashable&lt;T&gt;::value &amp;&amp; std::is_same&lt;T, bool&gt;::value,
277                          H&gt;::type
278  AbslHashValue(H hash_state, const std::vector&lt;T, Allocator&gt;&amp; vector) {
279    typename H::AbslInternalPiecewiseCombiner combiner;
280    for (const auto&amp; i : vector) {
281      unsigned char c = static_cast&lt;unsigned char&gt;(i);
282      hash_state = combiner.add_buffer(std::move(hash_state), &amp;c, sizeof(c));
283    }
284    return H::combine(combiner.finalize(std::move(hash_state)), vector.size());
285  }
286  #else
287  template &lt;typename H, typename T, typename Allocator&gt;
288  typename std::enable_if&lt;is_hashable&lt;T&gt;::value &amp;&amp; std::is_same&lt;T, bool&gt;::value,
289                          H&gt;::type
290  AbslHashValue(H hash_state, const std::vector&lt;T, Allocator&gt;&amp; vector) {
291    return H::combine(std::move(hash_state),
292                      std::hash&lt;std::vector&lt;T, Allocator&gt;&gt;{}(vector),
293                      vector.size());
294  }
295  #endif
296  template &lt;typename H, typename Key, typename T, typename Compare,
297            typename Allocator&gt;
298  typename std::enable_if&lt;is_hashable&lt;Key&gt;::value &amp;&amp; is_hashable&lt;T&gt;::value,
299                          H&gt;::type
300  AbslHashValue(H hash_state, const std::map&lt;Key, T, Compare, Allocator&gt;&amp; map) {
301    for (const auto&amp; t : map) {
302      hash_state = H::combine(std::move(hash_state), t);
303    }
304    return H::combine(std::move(hash_state), map.size());
305  }
306  template &lt;typename H, typename Key, typename T, typename Compare,
307            typename Allocator&gt;
308  typename std::enable_if&lt;is_hashable&lt;Key&gt;::value &amp;&amp; is_hashable&lt;T&gt;::value,
309                          H&gt;::type
310  AbslHashValue(H hash_state,
311                const std::multimap&lt;Key, T, Compare, Allocator&gt;&amp; map) {
312    for (const auto&amp; t : map) {
313      hash_state = H::combine(std::move(hash_state), t);
314    }
315    return H::combine(std::move(hash_state), map.size());
316  }
317  template &lt;typename H, typename Key, typename Compare, typename Allocator&gt;
318  typename std::enable_if&lt;is_hashable&lt;Key&gt;::value, H&gt;::type AbslHashValue(
319      H hash_state, const std::set&lt;Key, Compare, Allocator&gt;&amp; set) {
320    for (const auto&amp; t : set) {
321      hash_state = H::combine(std::move(hash_state), t);
322    }
323    return H::combine(std::move(hash_state), set.size());
324  }
325  template &lt;typename H, typename Key, typename Compare, typename Allocator&gt;
326  typename std::enable_if&lt;is_hashable&lt;Key&gt;::value, H&gt;::type AbslHashValue(
327      H hash_state, const std::multiset&lt;Key, Compare, Allocator&gt;&amp; set) {
328    for (const auto&amp; t : set) {
329      hash_state = H::combine(std::move(hash_state), t);
330    }
331    return H::combine(std::move(hash_state), set.size());
332  }
333  template &lt;typename H, typename Key, typename Hash, typename KeyEqual,
334            typename Alloc&gt;
335  typename std::enable_if&lt;is_hashable&lt;Key&gt;::value, H&gt;::type AbslHashValue(
336      H hash_state, const std::unordered_set&lt;Key, Hash, KeyEqual, Alloc&gt;&amp; s) {
337    return H::combine(
338        H::combine_unordered(std::move(hash_state), s.begin(), s.end()),
339        s.size());
340  }
341  template &lt;typename H, typename Key, typename Hash, typename KeyEqual,
342            typename Alloc&gt;
343  typename std::enable_if&lt;is_hashable&lt;Key&gt;::value, H&gt;::type AbslHashValue(
<span onclick='openModal()' class='match'>344      H hash_state,
345      const std::unordered_multiset&lt;Key, Hash, KeyEqual, Alloc&gt;&amp; s) {
346    return H::combine(
347        H::combine_unordered(std::move(hash_state), s.begin(), s.end()),
348        s.size());
349  }
350  template &lt;typename H, typename Key, typename T, typename Hash,
351            typename KeyEqual, typename Alloc&gt;
</span>352  typename std::enable_if&lt;is_hashable&lt;Key&gt;::value &amp;&amp; is_hashable&lt;T&gt;::value,
353                          H&gt;::type
354  AbslHashValue(H hash_state,
355                const std::unordered_map&lt;Key, T, Hash, KeyEqual, Alloc&gt;&amp; s) {
356    return H::combine(
357        H::combine_unordered(std::move(hash_state), s.begin(), s.end()),
358        s.size());
359  }
360  template &lt;typename H, typename Key, typename T, typename Hash,
361            typename KeyEqual, typename Alloc&gt;
362  typename std::enable_if&lt;is_hashable&lt;Key&gt;::value &amp;&amp; is_hashable&lt;T&gt;::value,
363                          H&gt;::type
364  AbslHashValue(H hash_state,
365                const std::unordered_multimap&lt;Key, T, Hash, KeyEqual, Alloc&gt;&amp; s) {
366    return H::combine(
367        H::combine_unordered(std::move(hash_state), s.begin(), s.end()),
368        s.size());
369  }
370  template &lt;typename H, typename T&gt;
371  typename std::enable_if&lt;is_hashable&lt;T&gt;::value, H&gt;::type AbslHashValue(
372      H hash_state, std::reference_wrapper&lt;T&gt; opt) {
373    return H::combine(std::move(hash_state), opt.get());
374  }
375  template &lt;typename H, typename T&gt;
376  typename std::enable_if&lt;is_hashable&lt;T&gt;::value, H&gt;::type AbslHashValue(
377      H hash_state, const absl::optional&lt;T&gt;&amp; opt) {
378    if (opt) hash_state = H::combine(std::move(hash_state), *opt);
379    return H::combine(std::move(hash_state), opt.has_value());
380  }
381  template &lt;typename H&gt;
382  struct VariantVisitor {
383    H&amp;&amp; hash_state;
384    template &lt;typename T&gt;
385    H operator()(const T&amp; t) const {
386      return H::combine(std::move(hash_state), t);
387    }
388  };
389  template &lt;typename H, typename... T&gt;
390  typename std::enable_if&lt;conjunction&lt;is_hashable&lt;T&gt;...&gt;::value, H&gt;::type
391  AbslHashValue(H hash_state, const absl::variant&lt;T...&gt;&amp; v) {
392    if (!v.valueless_by_exception()) {
393      hash_state = absl::visit(VariantVisitor&lt;H&gt;{std::move(hash_state)}, v);
394    }
395    return H::combine(std::move(hash_state), v.index());
396  }
397  #if defined(ABSL_IS_BIG_ENDIAN) &amp;&amp; \
398      (defined(__GLIBCXX__) || defined(__GLIBCPP__))
399  template &lt;typename H, size_t N&gt;
400  H AbslHashValue(H hash_state, const std::bitset&lt;N&gt;&amp; set) {
401    typename H::AbslInternalPiecewiseCombiner combiner;
402    for (int i = 0; i &lt; N; i++) {
403      unsigned char c = static_cast&lt;unsigned char&gt;(set[i]);
404      hash_state = combiner.add_buffer(std::move(hash_state), &amp;c, sizeof(c));
405    }
406    return H::combine(combiner.finalize(std::move(hash_state)), N);
407  }
408  #endif
409  template &lt;typename H, typename T&gt;
410  typename std::enable_if&lt;is_uniquely_represented&lt;T&gt;::value, H&gt;::type
411  hash_range_or_bytes(H hash_state, const T* data, size_t size) {
412    const auto* bytes = reinterpret_cast&lt;const unsigned char*&gt;(data);
413    return H::combine_contiguous(std::move(hash_state), bytes, sizeof(T) * size);
414  }
415  template &lt;typename H, typename T&gt;
416  typename std::enable_if&lt;!is_uniquely_represented&lt;T&gt;::value, H&gt;::type
417  hash_range_or_bytes(H hash_state, const T* data, size_t size) {
418    for (const auto end = data + size; data &lt; end; ++data) {
419      hash_state = H::combine(std::move(hash_state), *data);
420    }
421    return hash_state;
422  }
423  #if defined(ABSL_INTERNAL_LEGACY_HASH_NAMESPACE) &amp;&amp; \
424      ABSL_META_INTERNAL_STD_HASH_SFINAE_FRIENDLY_
425  #define ABSL_HASH_INTERNAL_SUPPORT_LEGACY_HASH_ 1
426  #else
427  #define ABSL_HASH_INTERNAL_SUPPORT_LEGACY_HASH_ 0
428  #endif
429  struct HashSelect {
430   private:
431    struct State : HashStateBase&lt;State&gt; {
432      static State combine_contiguous(State hash_state, const unsigned char*,
433                                      size_t);
434      using State::HashStateBase::combine_contiguous;
435    };
436    struct UniquelyRepresentedProbe {
437      template &lt;typename H, typename T&gt;
438      static auto Invoke(H state, const T&amp; value)
439          -&gt; absl::enable_if_t&lt;is_uniquely_represented&lt;T&gt;::value, H&gt; {
440        return hash_internal::hash_bytes(std::move(state), value);
441      }
442    };
443    struct HashValueProbe {
444      template &lt;typename H, typename T&gt;
445      static auto Invoke(H state, const T&amp; value) -&gt; absl::enable_if_t&lt;
446          std::is_same&lt;H,
447                       decltype(AbslHashValue(std::move(state), value))&gt;::value,
448          H&gt; {
449        return AbslHashValue(std::move(state), value);
450      }
451    };
452    struct LegacyHashProbe {
453  #if ABSL_HASH_INTERNAL_SUPPORT_LEGACY_HASH_
454      template &lt;typename H, typename T&gt;
455      static auto Invoke(H state, const T&amp; value) -&gt; absl::enable_if_t&lt;
456          std::is_convertible&lt;
457              decltype(ABSL_INTERNAL_LEGACY_HASH_NAMESPACE::hash&lt;T&gt;()(value)),
458              size_t&gt;::value,
459          H&gt; {
460        return hash_internal::hash_bytes(
461            std::move(state),
462            ABSL_INTERNAL_LEGACY_HASH_NAMESPACE::hash&lt;T&gt;{}(value));
463      }
464  #endif  
465    };
466    struct StdHashProbe {
467      template &lt;typename H, typename T&gt;
468      static auto Invoke(H state, const T&amp; value)
469          -&gt; absl::enable_if_t&lt;type_traits_internal::IsHashable&lt;T&gt;::value, H&gt; {
470        return hash_internal::hash_bytes(std::move(state), std::hash&lt;T&gt;{}(value));
471      }
472    };
473    template &lt;typename Hash, typename T&gt;
474    struct Probe : Hash {
475     private:
476      template &lt;typename H, typename = decltype(H::Invoke(
477                                std::declval&lt;State&gt;(), std::declval&lt;const T&amp;&gt;()))&gt;
478      static std::true_type Test(int);
479      template &lt;typename U&gt;
480      static std::false_type Test(char);
481     public:
482      static constexpr bool value = decltype(Test&lt;Hash&gt;(0))::value;
483    };
484   public:
485    template &lt;typename T&gt;
486    using Apply = absl::disjunction&lt;         
487        Probe&lt;UniquelyRepresentedProbe, T&gt;,  
488        Probe&lt;HashValueProbe, T&gt;,            
489        Probe&lt;LegacyHashProbe, T&gt;,           
490        Probe&lt;StdHashProbe, T&gt;,              
491        std::false_type&gt;;
492  };
493  template &lt;typename T&gt;
494  struct is_hashable
495      : std::integral_constant&lt;bool, HashSelect::template Apply&lt;T&gt;::value&gt; {};
496  class ABSL_DLL MixingHashState : public HashStateBase&lt;MixingHashState&gt; {
497  #ifdef ABSL_HAVE_INTRINSIC_INT128
498    using uint128 = __uint128_t;
499  #else   
500    using uint128 = absl::uint128;
501  #endif  
502    static constexpr uint64_t kMul =
503    sizeof(size_t) == 4 ? uint64_t{0xcc9e2d51}
504                        : uint64_t{0x9ddfea08eb382d69};
505    template &lt;typename T&gt;
506    using IntegralFastPath =
507        conjunction&lt;std::is_integral&lt;T&gt;, is_uniquely_represented&lt;T&gt;&gt;;
508   public:
509    MixingHashState(MixingHashState&amp;&amp;) = default;
510    MixingHashState&amp; operator=(MixingHashState&amp;&amp;) = default;
511    static MixingHashState combine_contiguous(MixingHashState hash_state,
512                                              const unsigned char* first,
513                                              size_t size) {
514      return MixingHashState(
515          CombineContiguousImpl(hash_state.state_, first, size,
516                                std::integral_constant&lt;int, sizeof(size_t)&gt;{}));
517    }
518    using MixingHashState::HashStateBase::combine_contiguous;
519    template &lt;typename T, absl::enable_if_t&lt;IntegralFastPath&lt;T&gt;::value, int&gt; = 0&gt;
520    static size_t hash(T value) {
521      return static_cast&lt;size_t&gt;(
522          Mix(Seed(), static_cast&lt;std::make_unsigned_t&lt;T&gt;&gt;(value)));
523    }
524    template &lt;typename T, absl::enable_if_t&lt;!IntegralFastPath&lt;T&gt;::value, int&gt; = 0&gt;
525    static size_t hash(const T&amp; value) {
526      return static_cast&lt;size_t&gt;(combine(MixingHashState{}, value).state_);
527    }
528   private:
529    MixingHashState() : state_(Seed()) {}
530    friend class MixingHashState::HashStateBase;
531    template &lt;typename CombinerT&gt;
532    static MixingHashState RunCombineUnordered(MixingHashState state,
533                                               CombinerT combiner) {
534      uint64_t unordered_state = 0;
535      combiner(MixingHashState{}, [&amp;](MixingHashState&amp; inner_state) {
536        auto element_state = inner_state.state_;
537        unordered_state += element_state;
538        if (unordered_state &lt; element_state) {
539          ++unordered_state;
540        }
541        inner_state = MixingHashState{};
542      });
543      return MixingHashState::combine(std::move(state), unordered_state);
544    }
545    friend class absl::HashState;
546    MixingHashState(const MixingHashState&amp;) = default;
547    explicit MixingHashState(uint64_t state) : state_(state) {}
548    static uint64_t CombineContiguousImpl(uint64_t state,
549                                          const unsigned char* first, size_t len,
550                                          std::integral_constant&lt;int, 4&gt;
551                                          );
552    static uint64_t CombineContiguousImpl(uint64_t state,
553                                          const unsigned char* first, size_t len,
554                                          std::integral_constant&lt;int, 8&gt;
555                                          );
556    static uint64_t CombineLargeContiguousImpl32(uint64_t state,
557                                                 const unsigned char* first,
558                                                 size_t len);
559    static uint64_t CombineLargeContiguousImpl64(uint64_t state,
560                                                 const unsigned char* first,
561                                                 size_t len);
562    static std::pair&lt;uint64_t, uint64_t&gt; Read9To16(const unsigned char* p,
563                                                   size_t len) {
564      uint64_t low_mem = absl::base_internal::UnalignedLoad64(p);
565      uint64_t high_mem = absl::base_internal::UnalignedLoad64(p + len - 8);
566  #ifdef ABSL_IS_LITTLE_ENDIAN
567      uint64_t most_significant = high_mem;
568      uint64_t least_significant = low_mem;
569  #else
570      uint64_t most_significant = low_mem;
571      uint64_t least_significant = high_mem;
572  #endif
573      return {least_significant, most_significant};
574    }
575    static uint64_t Read4To8(const unsigned char* p, size_t len) {
576      uint32_t low_mem = absl::base_internal::UnalignedLoad32(p);
577      uint32_t high_mem = absl::base_internal::UnalignedLoad32(p + len - 4);
578  #ifdef ABSL_IS_LITTLE_ENDIAN
579      uint32_t most_significant = high_mem;
580      uint32_t least_significant = low_mem;
581  #else
582      uint32_t most_significant = low_mem;
583      uint32_t least_significant = high_mem;
584  #endif
585      return (static_cast&lt;uint64_t&gt;(most_significant) &lt;&lt; (len - 4) * 8) |
586             least_significant;
587    }
588    static uint32_t Read1To3(const unsigned char* p, size_t len) {
589      unsigned char mem0 = p[0];
590      unsigned char mem1 = p[len / 2];
591      unsigned char mem2 = p[len - 1];
592  #ifdef ABSL_IS_LITTLE_ENDIAN
593      unsigned char significant2 = mem2;
594      unsigned char significant1 = mem1;
595      unsigned char significant0 = mem0;
596  #else
597      unsigned char significant2 = mem0;
598      unsigned char significant1 = len == 2 ? mem0 : mem1;
599      unsigned char significant0 = mem2;
600  #endif
601      return static_cast&lt;uint32_t&gt;(significant0 |                     
602                                   (significant1 &lt;&lt; (len / 2 * 8)) |  
603                                   (significant2 &lt;&lt; ((len - 1) * 8)));
604    }
605    ABSL_ATTRIBUTE_ALWAYS_INLINE static uint64_t Mix(uint64_t state, uint64_t v) {
606      using MultType =
607          absl::conditional_t&lt;sizeof(size_t) == 4, uint64_t, uint128&gt;;
608      MultType m = state + v;
609      m *= kMul;
610      return static_cast&lt;uint64_t&gt;(m ^ (m &gt;&gt; (sizeof(m) * 8 / 2)));
611    }
612    static uint64_t LowLevelHashImpl(const unsigned char* data, size_t len);
613    ABSL_ATTRIBUTE_ALWAYS_INLINE static uint64_t Hash64(const unsigned char* data,
614                                                        size_t len) {
615  #ifdef ABSL_HAVE_INTRINSIC_INT128
616      return LowLevelHashImpl(data, len);
617  #else
618      return hash_internal::CityHash64(reinterpret_cast&lt;const char*&gt;(data), len);
619  #endif
620    }
621    ABSL_ATTRIBUTE_ALWAYS_INLINE static uint64_t Seed() {
622  #if (!defined(__clang__) || __clang_major__ &gt; 11) &amp;&amp; \
623      (!defined(__apple_build_version__) ||            \
624       __apple_build_version__ &gt;= 19558921)  
625      return static_cast&lt;uint64_t&gt;(reinterpret_cast&lt;uintptr_t&gt;(&amp;kSeed));
626  #else
627      return static_cast&lt;uint64_t&gt;(reinterpret_cast&lt;uintptr_t&gt;(kSeed));
628  #endif
629    }
630    static const void* const kSeed;
631    uint64_t state_;
632  };
633  inline uint64_t MixingHashState::CombineContiguousImpl(
634      uint64_t state, const unsigned char* first, size_t len,
635      std::integral_constant&lt;int, 4&gt; &amp;bsol;* sizeof_size_t */) {
636    uint64_t v;
637    if (len &gt; 8) {
638      if (ABSL_PREDICT_FALSE(len &gt; PiecewiseChunkSize())) {
639        return CombineLargeContiguousImpl32(state, first, len);
640      }
641      v = hash_internal::CityHash32(reinterpret_cast&lt;const char*&gt;(first), len);
642    } else if (len &gt;= 4) {
643      v = Read4To8(first, len);
644    } else if (len &gt; 0) {
645      v = Read1To3(first, len);
646    } else {
647      return state;
648    }
649    return Mix(state, v);
650  }
651  inline uint64_t MixingHashState::CombineContiguousImpl(
652      uint64_t state, const unsigned char* first, size_t len,
653      std::integral_constant&lt;int, 8&gt; &amp;bsol;* sizeof_size_t */) {
654    uint64_t v;
655    if (len &gt; 16) {
656      if (ABSL_PREDICT_FALSE(len &gt; PiecewiseChunkSize())) {
657        return CombineLargeContiguousImpl64(state, first, len);
658      }
659      v = Hash64(first, len);
660    } else if (len &gt; 8) {
661      auto p = Read9To16(first, len);
662      uint64_t lo = p.first;
663      uint64_t hi = p.second;
664      lo = absl::rotr(lo, 53);
665      state += kMul;
666      lo += state;
667      state ^= hi;
668      uint128 m = state;
669      m *= lo;
670      return static_cast&lt;uint64_t&gt;(m ^ (m &gt;&gt; 64));
671    } else if (len &gt;= 4) {
672      v = Read4To8(first, len);
673    } else if (len &gt; 0) {
674      v = Read1To3(first, len);
675    } else {
676      return state;
677    }
678    return Mix(state, v);
679  }
680  struct AggregateBarrier {};
681  struct PoisonedHash : private AggregateBarrier {
682    PoisonedHash() = delete;
683    PoisonedHash(const PoisonedHash&amp;) = delete;
684    PoisonedHash&amp; operator=(const PoisonedHash&amp;) = delete;
685  };
686  template &lt;typename T&gt;
687  struct HashImpl {
688    size_t operator()(const T&amp; value) const {
689      return MixingHashState::hash(value);
690    }
691  };
692  template &lt;typename T&gt;
693  struct Hash
694      : absl::conditional_t&lt;is_hashable&lt;T&gt;::value, HashImpl&lt;T&gt;, PoisonedHash&gt; {};
695  template &lt;typename H&gt;
696  template &lt;typename T, typename... Ts&gt;
697  H HashStateBase&lt;H&gt;::combine(H state, const T&amp; value, const Ts&amp;... values) {
698    return H::combine(hash_internal::HashSelect::template Apply&lt;T&gt;::Invoke(
699                          std::move(state), value),
700                      values...);
701  }
702  template &lt;typename H&gt;
703  template &lt;typename T&gt;
704  H HashStateBase&lt;H&gt;::combine_contiguous(H state, const T* data, size_t size) {
705    return hash_internal::hash_range_or_bytes(std::move(state), data, size);
706  }
707  template &lt;typename H&gt;
708  template &lt;typename I&gt;
709  H HashStateBase&lt;H&gt;::combine_unordered(H state, I begin, I end) {
710    return H::RunCombineUnordered(std::move(state),
711                                  CombineUnorderedCallback&lt;I&gt;{begin, end});
712  }
713  template &lt;typename H&gt;
714  H PiecewiseCombiner::add_buffer(H state, const unsigned char* data,
715                                  size_t size) {
716    if (position_ + size &lt; PiecewiseChunkSize()) {
717      memcpy(buf_ + position_, data, size);
718      position_ += size;
719      return state;
720    }
721    if (position_ != 0) {
722      const size_t bytes_needed = PiecewiseChunkSize() - position_;
723      memcpy(buf_ + position_, data, bytes_needed);
724      state = H::combine_contiguous(std::move(state), buf_, PiecewiseChunkSize());
725      data += bytes_needed;
726      size -= bytes_needed;
727    }
728    while (size &gt;= PiecewiseChunkSize()) {
729      state = H::combine_contiguous(std::move(state), data, PiecewiseChunkSize());
730      data += PiecewiseChunkSize();
731      size -= PiecewiseChunkSize();
732    }
733    memcpy(buf_, data, size);
734    position_ = size;
735    return state;
736  }
737  template &lt;typename H&gt;
738  H PiecewiseCombiner::finalize(H state) {
739    return H::combine_contiguous(std::move(state), buf_, position_);
740  }
741  }  
742  ABSL_NAMESPACE_END
743  }  
744  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-hash_12.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-hash_12.h</div>
                </div>
                <div class="column column_space"><pre><code>336      H hash_state, const std::unordered_set&lt;Key, Hash, KeyEqual, Alloc&gt;&amp; s) {
337    return H::combine(
338        H::combine_unordered(std::move(hash_state), s.begin(), s.end()),
339        s.size());
340  }
341  template &lt;typename H, typename Key, typename Hash, typename KeyEqual,
342            typename Alloc&gt;
</pre></code></div>
                <div class="column column_space"><pre><code>344      H hash_state,
345      const std::unordered_multiset&lt;Key, Hash, KeyEqual, Alloc&gt;&amp; s) {
346    return H::combine(
347        H::combine_unordered(std::move(hash_state), s.begin(), s.end()),
348        s.size());
349  }
350  template &lt;typename H, typename Key, typename T, typename Hash,
351            typename KeyEqual, typename Alloc&gt;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    