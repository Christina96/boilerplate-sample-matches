
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 42, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-layout.h</h3>
            <pre><code>1  #ifndef ABSL_CONTAINER_INTERNAL_LAYOUT_H_
2  #define ABSL_CONTAINER_INTERNAL_LAYOUT_H_
3  #include <assert.h>
4  #include <stddef.h>
5  #include <stdint.h>
6  #include <ostream>
7  #include <string>
8  #include <tuple>
9  #include <type_traits>
10  #include <typeinfo>
11  #include <utility>
12  #include "absl/base/config.h"
13  #include "absl/meta/type_traits.h"
14  #include "absl/strings/str_cat.h"
15  #include "absl/types/span.h"
16  #include "absl/utility/utility.h"
17  #ifdef ABSL_HAVE_ADDRESS_SANITIZER
18  #include <sanitizer/asan_interface.h>
19  #endif
20  #if defined(__GXX_RTTI)
21  #define ABSL_INTERNAL_HAS_CXA_DEMANGLE
22  #endif
23  #ifdef ABSL_INTERNAL_HAS_CXA_DEMANGLE
24  #include <cxxabi.h>
25  #endif
26  namespace absl {
27  ABSL_NAMESPACE_BEGIN
28  namespace container_internal {
29  template <class T, size_t N>
30  struct Aligned;
31  namespace internal_layout {
32  template <class T>
33  struct NotAligned {};
34  template <class T, size_t N>
35  struct NotAligned<const Aligned<T, N>> {
36    static_assert(sizeof(T) == 0, "Aligned<T, N> cannot be const-qualified");
37  };
38  template <size_t>
39  using IntToSize = size_t;
40  template <class>
41  using TypeToSize = size_t;
42  template <class T>
43  struct Type : NotAligned<T> {
44    using type = T;
45  };
46  template <class T, size_t N>
47  struct Type<Aligned<T, N>> {
48    using type = T;
49  };
50  template <class T>
51  struct SizeOf : NotAligned<T>, std::integral_constant<size_t, sizeof(T)> {};
52  template <class T, size_t N>
53  struct SizeOf<Aligned<T, N>> : std::integral_constant<size_t, sizeof(T)> {};
54  template <class T>
55  struct AlignOf : NotAligned<T> {
56    static constexpr size_t value = alignof(T);
57  };
58  template <class T, size_t N>
59  struct AlignOf<Aligned<T, N>> {
60    static_assert(N % alignof(T) == 0,
61                  "Custom alignment can't be lower than the type's alignment");
62    static constexpr size_t value = N;
63  };
64  template <class T, class... Ts>
65  using Contains = absl::disjunction<std::is_same<T, Ts>...>;
66  template <class From, class To>
67  using CopyConst =
68      typename std::conditional<std::is_const<From>::value, const To, To>::type;
69  template <class T>
70  using SliceType = Span<T>;
71  namespace adl_barrier {
72  template <class Needle, class... Ts>
73  constexpr size_t Find(Needle, Needle, Ts...) {
74    static_assert(!Contains<Needle, Ts...>(), "Duplicate element type");
75    return 0;
76  }
77  template <class Needle, class T, class... Ts>
78  constexpr size_t Find(Needle, T, Ts...) {
79    return adl_barrier::Find(Needle(), Ts()...) + 1;
80  }
81  constexpr bool IsPow2(size_t n) { return !(n & (n - 1)); }
82  constexpr size_t Align(size_t n, size_t m) { return (n + m - 1) & ~(m - 1); }
83  constexpr size_t Min(size_t a, size_t b) { return b < a ? b : a; }
84  constexpr size_t Max(size_t a) { return a; }
85  template <class... Ts>
86  constexpr size_t Max(size_t a, size_t b, Ts... rest) {
87    return adl_barrier::Max(b < a ? a : b, rest...);
88  }
89  template <class T>
90  std::string TypeName() {
91    std::string out;
92    int status = 0;
93    char* demangled = nullptr;
94  #ifdef ABSL_INTERNAL_HAS_CXA_DEMANGLE
95    demangled = abi::__cxa_demangle(typeid(T).name(), nullptr, nullptr, &status);
96  #endif
97    if (status == 0 && demangled != nullptr) {  
98      absl::StrAppend(&out, "<", demangled, ">");
99      free(demangled);
100    } else {
101  #if defined(__GXX_RTTI) || defined(_CPPRTTI)
102      absl::StrAppend(&out, "<", typeid(T).name(), ">");
103  #endif
104    }
105    return out;
106  }
107  }  
108  template <bool C>
109  using EnableIf = typename std::enable_if<C, int>::type;
110  template <class T>
111  using IsLegalElementType = std::integral_constant<
112      bool, !std::is_reference<T>::value && !std::is_volatile<T>::value &&
113                !std::is_reference<typename Type<T>::type>::value &&
114                !std::is_volatile<typename Type<T>::type>::value &&
115                adl_barrier::IsPow2(AlignOf<T>::value)>;
116  template <class Elements, class SizeSeq, class OffsetSeq>
117  class LayoutImpl;
118  template <class... Elements, size_t... SizeSeq, size_t... OffsetSeq>
119  class LayoutImpl<std::tuple<Elements...>, absl::index_sequence<SizeSeq...>,
120                   absl::index_sequence<OffsetSeq...>> {
121   private:
122    static_assert(sizeof...(Elements) > 0, "At least one field is required");
123    static_assert(absl::conjunction<IsLegalElementType<Elements>...>::value,
124                  "Invalid element type (see IsLegalElementType)");
125    enum {
126      NumTypes = sizeof...(Elements),
127      NumSizes = sizeof...(SizeSeq),
128      NumOffsets = sizeof...(OffsetSeq),
129    };
130    static_assert(NumOffsets == adl_barrier::Min(NumTypes, NumSizes + 1),
131                  "Internal error");
132    static_assert(NumTypes > 0, "Internal error");
133    template <class T>
134    static constexpr size_t ElementIndex() {
135      static_assert(Contains<Type<T>, Type<typename Type<Elements>::type>...>(),
136                    "Type not found");
137      return adl_barrier::Find(Type<T>(),
138                               Type<typename Type<Elements>::type>()...);
139    }
140    template <size_t N>
141    using ElementAlignment =
142        AlignOf<typename std::tuple_element<N, std::tuple<Elements...>>::type>;
143   public:
144    using ElementTypes = std::tuple<typename Type<Elements>::type...>;
145    template <size_t N>
146    using ElementType = typename std::tuple_element<N, ElementTypes>::type;
147    constexpr explicit LayoutImpl(IntToSize<SizeSeq>... sizes)
148        : size_{sizes...} {}
149    static constexpr size_t Alignment() {
150      return adl_barrier::Max(AlignOf<Elements>::value...);
151    }
152    template <size_t N, EnableIf<N == 0> = 0>
153    constexpr size_t Offset() const {
154      return 0;
155    }
156    template <size_t N, EnableIf<N != 0> = 0>
157    constexpr size_t Offset() const {
158      static_assert(N < NumOffsets, "Index out of bounds");
159      return adl_barrier::Align(
160          Offset<N - 1>() + SizeOf<ElementType<N - 1>>::value * size_[N - 1],
161          ElementAlignment<N>::value);
162    }
163    template <class T>
164    constexpr size_t Offset() const {
<span onclick='openModal()' class='match'>165      return Offset<ElementIndex<T>()>();
166    }
167    constexpr std::array<size_t, NumOffsets> Offsets() const {
168      return {{Offset<OffsetSeq>()...}};
169    }
170    template <size_t N>
</span>171    constexpr size_t Size() const {
172      static_assert(N < NumSizes, "Index out of bounds");
173      return size_[N];
174    }
175    template <class T>
176    constexpr size_t Size() const {
177      return Size<ElementIndex<T>()>();
178    }
179    constexpr std::array<size_t, NumSizes> Sizes() const {
180      return {{Size<SizeSeq>()...}};
181    }
182    template <size_t N, class Char>
183    CopyConst<Char, ElementType<N>>* Pointer(Char* p) const {
184      using C = typename std::remove_const<Char>::type;
185      static_assert(
186          std::is_same<C, char>() || std::is_same<C, unsigned char>() ||
187              std::is_same<C, signed char>(),
188          "The argument must be a pointer to [const] [signed|unsigned] char");
189      constexpr size_t alignment = Alignment();
190      (void)alignment;
191      assert(reinterpret_cast<uintptr_t>(p) % alignment == 0);
192      return reinterpret_cast<CopyConst<Char, ElementType<N>>*>(p + Offset<N>());
193    }
194    template <class T, class Char>
195    CopyConst<Char, T>* Pointer(Char* p) const {
196      return Pointer<ElementIndex<T>()>(p);
197    }
198    template <class Char>
199    std::tuple<CopyConst<
200        Char, typename std::tuple_element<OffsetSeq, ElementTypes>::type>*...>
201    Pointers(Char* p) const {
202      return std::tuple<CopyConst<Char, ElementType<OffsetSeq>>*...>(
203          Pointer<OffsetSeq>(p)...);
204    }
205    template <size_t N, class Char>
206    SliceType<CopyConst<Char, ElementType<N>>> Slice(Char* p) const {
207      return SliceType<CopyConst<Char, ElementType<N>>>(Pointer<N>(p), Size<N>());
208    }
209    template <class T, class Char>
210    SliceType<CopyConst<Char, T>> Slice(Char* p) const {
211      return Slice<ElementIndex<T>()>(p);
212    }
213    template <class Char>
214    std::tuple<SliceType<CopyConst<
215        Char, typename std::tuple_element<SizeSeq, ElementTypes>::type>>...>
216    Slices(Char* p) const {
217      (void)p;
218      return std::tuple<SliceType<CopyConst<Char, ElementType<SizeSeq>>>...>(
219          Slice<SizeSeq>(p)...);
220    }
221    constexpr size_t AllocSize() const {
222      static_assert(NumTypes == NumSizes, "You must specify sizes of all fields");
223      return Offset<NumTypes - 1>() +
224          SizeOf<ElementType<NumTypes - 1>>::value * size_[NumTypes - 1];
225    }
226    template <class Char, size_t N = NumOffsets - 1, EnableIf<N == 0> = 0>
227    void PoisonPadding(const Char* p) const {
228      Pointer<0>(p);  
229    }
230    template <class Char, size_t N = NumOffsets - 1, EnableIf<N != 0> = 0>
231    void PoisonPadding(const Char* p) const {
232      static_assert(N < NumOffsets, "Index out of bounds");
233      (void)p;
234  #ifdef ABSL_HAVE_ADDRESS_SANITIZER
235      PoisonPadding<Char, N - 1>(p);
236      if (ElementAlignment<N - 1>::value % ElementAlignment<N>::value) {
237        size_t start =
238            Offset<N - 1>() + SizeOf<ElementType<N - 1>>::value * size_[N - 1];
239        ASAN_POISON_MEMORY_REGION(p + start, Offset<N>() - start);
240      }
241  #endif
242    }
243    std::string DebugString() const {
244      const auto offsets = Offsets();
245      const size_t sizes[] = {SizeOf<ElementType<OffsetSeq>>::value...};
246      const std::string types[] = {
247          adl_barrier::TypeName<ElementType<OffsetSeq>>()...};
248      std::string res = absl::StrCat("@0", types[0], "(", sizes[0], ")");
249      for (size_t i = 0; i != NumOffsets - 1; ++i) {
250        absl::StrAppend(&res, "[", size_[i], "]; @", offsets[i + 1], types[i + 1],
251                        "(", sizes[i + 1], ")");
252      }
253      int last = static_cast<int>(NumSizes) - 1;
254      if (NumTypes == NumSizes && last >= 0) {
255        absl::StrAppend(&res, "[", size_[last], "]");
256      }
257      return res;
258    }
259   private:
260    size_t size_[NumSizes > 0 ? NumSizes : 1];
261  };
262  template <size_t NumSizes, class... Ts>
263  using LayoutType = LayoutImpl<
264      std::tuple<Ts...>, absl::make_index_sequence<NumSizes>,
265      absl::make_index_sequence<adl_barrier::Min(sizeof...(Ts), NumSizes + 1)>>;
266  }  
267  template <class... Ts>
268  class Layout : public internal_layout::LayoutType<sizeof...(Ts), Ts...> {
269   public:
270    static_assert(sizeof...(Ts) > 0, "At least one field is required");
271    static_assert(
272        absl::conjunction<internal_layout::IsLegalElementType<Ts>...>::value,
273        "Invalid element type (see IsLegalElementType)");
274    template <size_t NumSizes>
275    using PartialType = internal_layout::LayoutType<NumSizes, Ts...>;
276    template <class... Sizes>
277    static constexpr PartialType<sizeof...(Sizes)> Partial(Sizes&&... sizes) {
278      static_assert(sizeof...(Sizes) <= sizeof...(Ts), "");
279      return PartialType<sizeof...(Sizes)>(absl::forward<Sizes>(sizes)...);
280    }
281    constexpr explicit Layout(internal_layout::TypeToSize<Ts>... sizes)
282        : internal_layout::LayoutType<sizeof...(Ts), Ts...>(sizes...) {}
283  };
284  }  
285  ABSL_NAMESPACE_END
286  }  
287  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-layout.h</h3>
            <pre><code>1  #ifndef ABSL_CONTAINER_INTERNAL_LAYOUT_H_
2  #define ABSL_CONTAINER_INTERNAL_LAYOUT_H_
3  #include <assert.h>
4  #include <stddef.h>
5  #include <stdint.h>
6  #include <ostream>
7  #include <string>
8  #include <tuple>
9  #include <type_traits>
10  #include <typeinfo>
11  #include <utility>
12  #include "absl/base/config.h"
13  #include "absl/meta/type_traits.h"
14  #include "absl/strings/str_cat.h"
15  #include "absl/types/span.h"
16  #include "absl/utility/utility.h"
17  #ifdef ABSL_HAVE_ADDRESS_SANITIZER
18  #include <sanitizer/asan_interface.h>
19  #endif
20  #if defined(__GXX_RTTI)
21  #define ABSL_INTERNAL_HAS_CXA_DEMANGLE
22  #endif
23  #ifdef ABSL_INTERNAL_HAS_CXA_DEMANGLE
24  #include <cxxabi.h>
25  #endif
26  namespace absl {
27  ABSL_NAMESPACE_BEGIN
28  namespace container_internal {
29  template <class T, size_t N>
30  struct Aligned;
31  namespace internal_layout {
32  template <class T>
33  struct NotAligned {};
34  template <class T, size_t N>
35  struct NotAligned<const Aligned<T, N>> {
36    static_assert(sizeof(T) == 0, "Aligned<T, N> cannot be const-qualified");
37  };
38  template <size_t>
39  using IntToSize = size_t;
40  template <class>
41  using TypeToSize = size_t;
42  template <class T>
43  struct Type : NotAligned<T> {
44    using type = T;
45  };
46  template <class T, size_t N>
47  struct Type<Aligned<T, N>> {
48    using type = T;
49  };
50  template <class T>
51  struct SizeOf : NotAligned<T>, std::integral_constant<size_t, sizeof(T)> {};
52  template <class T, size_t N>
53  struct SizeOf<Aligned<T, N>> : std::integral_constant<size_t, sizeof(T)> {};
54  template <class T>
55  struct AlignOf : NotAligned<T> {
56    static constexpr size_t value = alignof(T);
57  };
58  template <class T, size_t N>
59  struct AlignOf<Aligned<T, N>> {
60    static_assert(N % alignof(T) == 0,
61                  "Custom alignment can't be lower than the type's alignment");
62    static constexpr size_t value = N;
63  };
64  template <class T, class... Ts>
65  using Contains = absl::disjunction<std::is_same<T, Ts>...>;
66  template <class From, class To>
67  using CopyConst =
68      typename std::conditional<std::is_const<From>::value, const To, To>::type;
69  template <class T>
70  using SliceType = Span<T>;
71  namespace adl_barrier {
72  template <class Needle, class... Ts>
73  constexpr size_t Find(Needle, Needle, Ts...) {
74    static_assert(!Contains<Needle, Ts...>(), "Duplicate element type");
75    return 0;
76  }
77  template <class Needle, class T, class... Ts>
78  constexpr size_t Find(Needle, T, Ts...) {
79    return adl_barrier::Find(Needle(), Ts()...) + 1;
80  }
81  constexpr bool IsPow2(size_t n) { return !(n & (n - 1)); }
82  constexpr size_t Align(size_t n, size_t m) { return (n + m - 1) & ~(m - 1); }
83  constexpr size_t Min(size_t a, size_t b) { return b < a ? b : a; }
84  constexpr size_t Max(size_t a) { return a; }
85  template <class... Ts>
86  constexpr size_t Max(size_t a, size_t b, Ts... rest) {
87    return adl_barrier::Max(b < a ? a : b, rest...);
88  }
89  template <class T>
90  std::string TypeName() {
91    std::string out;
92    int status = 0;
93    char* demangled = nullptr;
94  #ifdef ABSL_INTERNAL_HAS_CXA_DEMANGLE
95    demangled = abi::__cxa_demangle(typeid(T).name(), nullptr, nullptr, &status);
96  #endif
97    if (status == 0 && demangled != nullptr) {  
98      absl::StrAppend(&out, "<", demangled, ">");
99      free(demangled);
100    } else {
101  #if defined(__GXX_RTTI) || defined(_CPPRTTI)
102      absl::StrAppend(&out, "<", typeid(T).name(), ">");
103  #endif
104    }
105    return out;
106  }
107  }  
108  template <bool C>
109  using EnableIf = typename std::enable_if<C, int>::type;
110  template <class T>
111  using IsLegalElementType = std::integral_constant<
112      bool, !std::is_reference<T>::value && !std::is_volatile<T>::value &&
113                !std::is_reference<typename Type<T>::type>::value &&
114                !std::is_volatile<typename Type<T>::type>::value &&
115                adl_barrier::IsPow2(AlignOf<T>::value)>;
116  template <class Elements, class SizeSeq, class OffsetSeq>
117  class LayoutImpl;
118  template <class... Elements, size_t... SizeSeq, size_t... OffsetSeq>
119  class LayoutImpl<std::tuple<Elements...>, absl::index_sequence<SizeSeq...>,
120                   absl::index_sequence<OffsetSeq...>> {
121   private:
122    static_assert(sizeof...(Elements) > 0, "At least one field is required");
123    static_assert(absl::conjunction<IsLegalElementType<Elements>...>::value,
124                  "Invalid element type (see IsLegalElementType)");
125    enum {
126      NumTypes = sizeof...(Elements),
127      NumSizes = sizeof...(SizeSeq),
128      NumOffsets = sizeof...(OffsetSeq),
129    };
130    static_assert(NumOffsets == adl_barrier::Min(NumTypes, NumSizes + 1),
131                  "Internal error");
132    static_assert(NumTypes > 0, "Internal error");
133    template <class T>
134    static constexpr size_t ElementIndex() {
135      static_assert(Contains<Type<T>, Type<typename Type<Elements>::type>...>(),
136                    "Type not found");
137      return adl_barrier::Find(Type<T>(),
138                               Type<typename Type<Elements>::type>()...);
139    }
140    template <size_t N>
141    using ElementAlignment =
142        AlignOf<typename std::tuple_element<N, std::tuple<Elements...>>::type>;
143   public:
144    using ElementTypes = std::tuple<typename Type<Elements>::type...>;
145    template <size_t N>
146    using ElementType = typename std::tuple_element<N, ElementTypes>::type;
147    constexpr explicit LayoutImpl(IntToSize<SizeSeq>... sizes)
148        : size_{sizes...} {}
149    static constexpr size_t Alignment() {
150      return adl_barrier::Max(AlignOf<Elements>::value...);
151    }
152    template <size_t N, EnableIf<N == 0> = 0>
153    constexpr size_t Offset() const {
154      return 0;
155    }
156    template <size_t N, EnableIf<N != 0> = 0>
157    constexpr size_t Offset() const {
158      static_assert(N < NumOffsets, "Index out of bounds");
159      return adl_barrier::Align(
160          Offset<N - 1>() + SizeOf<ElementType<N - 1>>::value * size_[N - 1],
161          ElementAlignment<N>::value);
162    }
163    template <class T>
164    constexpr size_t Offset() const {
165      return Offset<ElementIndex<T>()>();
166    }
167    constexpr std::array<size_t, NumOffsets> Offsets() const {
168      return {{Offset<OffsetSeq>()...}};
169    }
170    template <size_t N>
171    constexpr size_t Size() const {
172      static_assert(N < NumSizes, "Index out of bounds");
173      return size_[N];
174    }
175    template <class T>
176    constexpr size_t Size() const {
<span onclick='openModal()' class='match'>177      return Size<ElementIndex<T>()>();
178    }
179    constexpr std::array<size_t, NumSizes> Sizes() const {
180      return {{Size<SizeSeq>()...}};
181    }
182    template <size_t N, class Char>
</span>183    CopyConst<Char, ElementType<N>>* Pointer(Char* p) const {
184      using C = typename std::remove_const<Char>::type;
185      static_assert(
186          std::is_same<C, char>() || std::is_same<C, unsigned char>() ||
187              std::is_same<C, signed char>(),
188          "The argument must be a pointer to [const] [signed|unsigned] char");
189      constexpr size_t alignment = Alignment();
190      (void)alignment;
191      assert(reinterpret_cast<uintptr_t>(p) % alignment == 0);
192      return reinterpret_cast<CopyConst<Char, ElementType<N>>*>(p + Offset<N>());
193    }
194    template <class T, class Char>
195    CopyConst<Char, T>* Pointer(Char* p) const {
196      return Pointer<ElementIndex<T>()>(p);
197    }
198    template <class Char>
199    std::tuple<CopyConst<
200        Char, typename std::tuple_element<OffsetSeq, ElementTypes>::type>*...>
201    Pointers(Char* p) const {
202      return std::tuple<CopyConst<Char, ElementType<OffsetSeq>>*...>(
203          Pointer<OffsetSeq>(p)...);
204    }
205    template <size_t N, class Char>
206    SliceType<CopyConst<Char, ElementType<N>>> Slice(Char* p) const {
207      return SliceType<CopyConst<Char, ElementType<N>>>(Pointer<N>(p), Size<N>());
208    }
209    template <class T, class Char>
210    SliceType<CopyConst<Char, T>> Slice(Char* p) const {
211      return Slice<ElementIndex<T>()>(p);
212    }
213    template <class Char>
214    std::tuple<SliceType<CopyConst<
215        Char, typename std::tuple_element<SizeSeq, ElementTypes>::type>>...>
216    Slices(Char* p) const {
217      (void)p;
218      return std::tuple<SliceType<CopyConst<Char, ElementType<SizeSeq>>>...>(
219          Slice<SizeSeq>(p)...);
220    }
221    constexpr size_t AllocSize() const {
222      static_assert(NumTypes == NumSizes, "You must specify sizes of all fields");
223      return Offset<NumTypes - 1>() +
224          SizeOf<ElementType<NumTypes - 1>>::value * size_[NumTypes - 1];
225    }
226    template <class Char, size_t N = NumOffsets - 1, EnableIf<N == 0> = 0>
227    void PoisonPadding(const Char* p) const {
228      Pointer<0>(p);  
229    }
230    template <class Char, size_t N = NumOffsets - 1, EnableIf<N != 0> = 0>
231    void PoisonPadding(const Char* p) const {
232      static_assert(N < NumOffsets, "Index out of bounds");
233      (void)p;
234  #ifdef ABSL_HAVE_ADDRESS_SANITIZER
235      PoisonPadding<Char, N - 1>(p);
236      if (ElementAlignment<N - 1>::value % ElementAlignment<N>::value) {
237        size_t start =
238            Offset<N - 1>() + SizeOf<ElementType<N - 1>>::value * size_[N - 1];
239        ASAN_POISON_MEMORY_REGION(p + start, Offset<N>() - start);
240      }
241  #endif
242    }
243    std::string DebugString() const {
244      const auto offsets = Offsets();
245      const size_t sizes[] = {SizeOf<ElementType<OffsetSeq>>::value...};
246      const std::string types[] = {
247          adl_barrier::TypeName<ElementType<OffsetSeq>>()...};
248      std::string res = absl::StrCat("@0", types[0], "(", sizes[0], ")");
249      for (size_t i = 0; i != NumOffsets - 1; ++i) {
250        absl::StrAppend(&res, "[", size_[i], "]; @", offsets[i + 1], types[i + 1],
251                        "(", sizes[i + 1], ")");
252      }
253      int last = static_cast<int>(NumSizes) - 1;
254      if (NumTypes == NumSizes && last >= 0) {
255        absl::StrAppend(&res, "[", size_[last], "]");
256      }
257      return res;
258    }
259   private:
260    size_t size_[NumSizes > 0 ? NumSizes : 1];
261  };
262  template <size_t NumSizes, class... Ts>
263  using LayoutType = LayoutImpl<
264      std::tuple<Ts...>, absl::make_index_sequence<NumSizes>,
265      absl::make_index_sequence<adl_barrier::Min(sizeof...(Ts), NumSizes + 1)>>;
266  }  
267  template <class... Ts>
268  class Layout : public internal_layout::LayoutType<sizeof...(Ts), Ts...> {
269   public:
270    static_assert(sizeof...(Ts) > 0, "At least one field is required");
271    static_assert(
272        absl::conjunction<internal_layout::IsLegalElementType<Ts>...>::value,
273        "Invalid element type (see IsLegalElementType)");
274    template <size_t NumSizes>
275    using PartialType = internal_layout::LayoutType<NumSizes, Ts...>;
276    template <class... Sizes>
277    static constexpr PartialType<sizeof...(Sizes)> Partial(Sizes&&... sizes) {
278      static_assert(sizeof...(Sizes) <= sizeof...(Ts), "");
279      return PartialType<sizeof...(Sizes)>(absl::forward<Sizes>(sizes)...);
280    }
281    constexpr explicit Layout(internal_layout::TypeToSize<Ts>... sizes)
282        : internal_layout::LayoutType<sizeof...(Ts), Ts...>(sizes...) {}
283  };
284  }  
285  ABSL_NAMESPACE_END
286  }  
287  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-layout.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-layout.h</div>
                </div>
                <div class="column column_space"><pre><code>165      return Offset<ElementIndex<T>()>();
166    }
167    constexpr std::array<size_t, NumOffsets> Offsets() const {
168      return {{Offset<OffsetSeq>()...}};
169    }
170    template <size_t N>
</pre></code></div>
                <div class="column column_space"><pre><code>177      return Size<ElementIndex<T>()>();
178    }
179    constexpr std::array<size_t, NumSizes> Sizes() const {
180      return {{Size<SizeSeq>()...}};
181    }
182    template <size_t N, class Char>
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    