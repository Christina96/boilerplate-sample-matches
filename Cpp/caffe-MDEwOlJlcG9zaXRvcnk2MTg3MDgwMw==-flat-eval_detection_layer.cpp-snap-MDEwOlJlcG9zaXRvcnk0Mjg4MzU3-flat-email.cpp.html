
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 11.678832116788321%, Tokens: 14</h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-eval_detection_layer.cpp</h3>
            <pre><code>1  #include <algorithm>
2  #include <cfloat>
3  #include <vector>
4  #include <cmath>
5  #include "caffe/layers/region_loss_layer.hpp"
6  #include "caffe/layers/eval_detection_layer.hpp"
7  #include "caffe/util/math_functions.hpp"
8  #include "caffe/util/benchmark.hpp"
9  #ifdef ENABLE_NMS_OPTIMIZATION
10  #include "caffe/util/bbox_util.hpp"
11  #include <immintrin.h>
12  #include "omp.h"
13  #endif
14  namespace caffe {
15      class BoxData {
16      public:
17          int label_;
18          float score_;
19          vector<float> box_;
20      };
21      inline float sigmoid(float x)
22      {
23          return 1. / (1. + exp(-x));
24      }
25      template <typename Dtype>
26      Dtype softmax_region(Dtype* input, int classes)
27      {
28          Dtype sum = 0;
29          Dtype large = input[0];
30          for (int i = 0; i < classes; ++i) {
31              if (input[i] > large)
32                  large = input[i];
33          }
34          for (int i = 0; i < classes; ++i) {
35              Dtype e = exp(input[i] - large);
36              sum += e;
37              input[i] = e;
38          }
39          for (int i = 0; i < classes; ++i) {
40              input[i] = input[i] / sum;
41          }
42          return 0;
43      }
44      bool BoxSortDecendScore(const BoxData& box1, const BoxData& box2) {
45          return box1.score_ > box2.score_;
46      }
47      void ApplyNms(const vector<BoxData>& boxes, vector<int>* idxes, float threshold) {
48          map<int, int> idx_map;
49          for (int i = 0; i < boxes.size() - 1; ++i) {
50              if (idx_map.find(i) != idx_map.end()) {
51                  continue;
52              }
53              vector<float> box1 = boxes[i].box_;
54              for (int j = i + 1; j < boxes.size(); ++j) {
55                  if (idx_map.find(j) != idx_map.end()) {
56                      continue;
57                  }
58                  vector<float> box2 = boxes[j].box_;
59                  float iou = Calc_iou(box1, box2);
60                  if (iou >= threshold) {
61                      idx_map[j] = 1;
62                  }
63              }
64          }
65          for (int i = 0; i < boxes.size(); ++i) {
66              if (idx_map.find(i) == idx_map.end()) {
67                  idxes->push_back(i);
68              }
69          }
70      }
71      template <typename Dtype>
72      void GetGTBox(int side, vector<vector<Dtype> > boxes, map<int, vector<BoxData> >* gt_boxes) {
73          for (int i = 0; i < boxes.size(); ++i) {
74              vector<Dtype> box = boxes[i];
75              BoxData gt_box;
76              int label = box[0];
77              gt_box.label_ = label;
78              gt_box.score_ = i; 
79              gt_box.box_.push_back(box[1]);
80              gt_box.box_.push_back(box[2]);
81              gt_box.box_.push_back(box[3]);
82              gt_box.box_.push_back(box[4]);
83              if (gt_boxes->find(label) == gt_boxes->end()) {
84                  (*gt_boxes)[label] = vector<BoxData>(1, gt_box);
85              }
86              else {
87                  (*gt_boxes)[label].push_back(gt_box);
88              }
89          }
90      }
91      template <typename Dtype>
92      void GetPredBox(int side, int num_object, int num_class, Dtype* input_data, map<int, vector<BoxData> >* pred_boxes, int score_type, float nms_threshold, vector<Dtype> biases) {
93          vector<BoxData> tmp_boxes;
94          for (int j = 0; j < side; ++j) {
95              for (int i = 0; i < side; ++i) {
96                  for (int n = 0; n < 5; ++n)
97                  {
<span onclick='openModal()' class='match'>98                      int index = (j * side + i) * num_object * (num_class + 1 + 4) + n * (num_class + 1 + 4);
99                      float x = (i + sigmoid(input_data[index + 0])) / side;
100                      float y = (j + sigmoid(input_data[index + 1])) / side;
101                      float w = (exp(input_data[index + 2]) * biases[2 * n]) / side;
102                      float h = (exp(input_data[index + 3]) * biases[2 * n + 1]) / side;
103                      softmax_region(input_data + index + 5, num_class);
104                      int pred_label = 0;
105                      float max_prob = input_data[index + 5];
</span>106                      for (int c = 0; c < num_class; ++c)
107                      {
108                          if (max_prob < input_data[index + 5 + c])
109                          {
110                              max_prob = input_data[index + 5 + c];
111                              pred_label = c; 
112                          }
113                      }
114                      BoxData pred_box;
115                      pred_box.label_ = pred_label;
116                      float obj_score = sigmoid(input_data[index + 4]);
117                      if (score_type == 0) {
118                          pred_box.score_ = obj_score;
119                      }
120                      else if (score_type == 1) {
121                          pred_box.score_ = max_prob;
122                      }
123                      else {
124                          pred_box.score_ = obj_score * max_prob;
125                      }
126                      pred_box.box_.push_back(x);
127                      pred_box.box_.push_back(y);
128                      pred_box.box_.push_back(w);
129                      pred_box.box_.push_back(h);
130                      tmp_boxes.push_back(pred_box);
131                  }
132              }
133          }
134          if (nms_threshold >= 0) {
135              std::sort(tmp_boxes.begin(), tmp_boxes.end(), BoxSortDecendScore);
136              vector<int> idxes;
137  #ifdef ENABLE_NMS_OPTIMIZATION
138              if (_may_i_use_cpu_feature(_FEATURE_AVX512CD | _FEATURE_AVX512F)) {
139                  uint64_t boxes_num = tmp_boxes.size();
140                  float* x1 = (float*)aligned_alloc(64, boxes_num * sizeof(float));
141                  float* y1 = (float*)aligned_alloc(64, boxes_num * sizeof(float));
142                  float* x2 = (float*)aligned_alloc(64, boxes_num * sizeof(float));
143                  float* y2 = (float*)aligned_alloc(64, boxes_num * sizeof(float));
144                  uint64_t i = 0;
145  #pragma omp parallel for
146                  for (i = 0; i < boxes_num; ++i) {
147                      x1[i] = tmp_boxes[i].box_[0] - tmp_boxes[i].box_[2] / 2.0;       
148                      y1[i] = tmp_boxes[i].box_[1] - tmp_boxes[i].box_[3] / 2.0;       
149                      x2[i] = tmp_boxes[i].box_[0] + tmp_boxes[i].box_[2] / 2.0;       
150                      y2[i] = tmp_boxes[i].box_[1] + tmp_boxes[i].box_[3] / 2.0;       
151                  }
152                  int* keep_out = (int*)malloc(sizeof(int) * tmp_boxes.size());
153                  int num_out = 0;
154                  cpu_nms_avx512_parallize_inner(keep_out, &num_out, x1, y1, x2, y2, boxes_num, nms_threshold);
155                  for (int i = 0; i < num_out; i++) {
156                      idxes.push_back(keep_out[i]);
157                  }
158                  if (x1)
159                      free(x1);
160                  if (x2)
161                      free(x2);
162                  if (y1)
163                      free(y1);
164                  if (y2)
165                      free(y2);
166                  if (keep_out)
167                      free(keep_out);
168              }
169              else {
170  #endif
171              ApplyNms(tmp_boxes, &idxes, nms_threshold);
172  #ifdef ENABLE_NMS_OPTIMIZATION
173          }
174  #endif
175              for (int i = 0; i < idxes.size(); ++i) {
176                  BoxData box_data = tmp_boxes[idxes[i]];
177                  /&bsol;**************************************************************************************
178                  if (box_data.score_ < 0.005) 
179                      continue;
180                  if (pred_boxes->find(box_data.label_) == pred_boxes->end()) {
181                      (*pred_boxes)[box_data.label_] = vector<BoxData>();
182                  }
183                  (*pred_boxes)[box_data.label_].push_back(box_data);
184              }
185          }
186          else {
187              for (std::map<int, vector<BoxData> >::iterator it = pred_boxes->begin(); it != pred_boxes->end(); ++it) {
188                  std::sort(it->second.begin(), it->second.end(), BoxSortDecendScore);
189              }
190          }
191      }
192      template <typename Dtype>
193      void EvalDetectionLayer<Dtype>::LayerSetUp(
194          const vector<Blob<Dtype>*>& bottom, const vector<Blob<Dtype>*>& top) {
195          EvalDetectionParameter param = this->layer_param_.eval_detection_param();
196          side_ = param.side();
197          num_class_ = param.num_class();
198          num_object_ = param.num_object();
199          threshold_ = param.threshold();
200          nms_ = param.nms();
201          for (int c = 0; c < param.biases_size(); ++c) {
202              biases_.push_back(param.biases(c));
203          }
204          switch (param.score_type()) {
205          case EvalDetectionParameter_ScoreType_OBJ:
206              score_type_ = 0;
207              break;
208          case EvalDetectionParameter_ScoreType_PROB:
209              score_type_ = 1;
210              break;
211          case EvalDetectionParameter_ScoreType_MULTIPLY:
212              score_type_ = 2;
213              break;
214          default:
215              LOG(FATAL) << "Unknow score type.";
216          }
217      }
218      template <typename Dtype>
219      void EvalDetectionLayer<Dtype>::Reshape(
220          const vector<Blob<Dtype>*>& bottom, const vector<Blob<Dtype>*>& top) {
221          int input_count = bottom[0]->count(1); 
222          int tmp_input_count = side_ * side_ * num_object_ *(num_class_ + 4 + 1); 
223          CHECK_EQ(input_count, tmp_input_count);
224          vector<int> top_shape(2, 1);
225          top_shape[0] = bottom[0]->num();
226          top_shape[1] = num_class_ + side_ * side_ * num_object_ * 4; 
227          top[0]->Reshape(top_shape);
228      }
229      template <typename Dtype>
230      void EvalDetectionLayer<Dtype>::Forward_cpu(
231          const vector<Blob<Dtype>*>& bottom, const vector<Blob<Dtype>*>& top) {
232          const Dtype* label_data = bottom[1]->cpu_data();
233          Blob<Dtype> swap;
234          swap.Reshape(bottom[0]->num(), bottom[0]->height()*bottom[0]->width(), num_object_, bottom[0]->channels() / num_object_);
235          Dtype* swap_data = swap.mutable_cpu_data();
236          int index = 0;
237          int n_value = bottom[0]->num();
238          int h_value = bottom[0]->height();
239          int w_value = bottom[0]->width();
240          int c_value = bottom[0]->channels();
241          const Dtype* input_data = bottom[0]->cpu_data();
242          for (int b = 0; b < n_value; ++b) {
243              for (int h = 0; h < h_value; ++h) {
244                  for (int w = 0; w < w_value; ++w) {
245                      for (int c = 0; c < c_value; ++c) {
246                          swap_data[index++] = input_data[((b * c_value + c) * h_value + h) * w_value + w];
247                      }
248                  }
249              }
250          }
251          /&bsol;******************************************************** Label ********************************************************
252          vector<vector<vector<Dtype> > > labels;
253          labels.resize(bottom[0]->num() + 1); 
254          int num_boxes = bottom[1]->height();
255          for (int i = 0; i < num_boxes; ++i) {
256              vector<Dtype> box;
257              int item_id = label_data[i * 8 + 0]; 
258              if (item_id == -1) continue;
259              Dtype xmin = label_data[i * 8 + 3];
260              Dtype ymin = label_data[i * 8 + 4];
261              Dtype xmax = label_data[i * 8 + 5];
262              Dtype ymax = label_data[i * 8 + 6];
263              Dtype cx = (xmin + xmax) / 2.0;
264              Dtype cy = (ymin + ymax) / 2.0;
265              Dtype w = xmax - xmin;
266              Dtype h = ymax - ymin;
267              box.push_back(label_data[i * 8 + 1] - 1); 
268              box.push_back(cx); 
269              box.push_back(cy); 
270              box.push_back(w); 
271              box.push_back(h); 
272              labels[item_id].push_back(box);
273          }
274          /&bsol;*********************************************************Diff********************************************************
275          Dtype* top_data = top[0]->mutable_cpu_data();
276          caffe_set(top[0]->count(), Dtype(0), top_data);
277          for (int i = 0; i < bottom[0]->num(); ++i) {
278              int input_index = i * bottom[0]->count(1);
279              int top_index = i * top[0]->count(1);
280              map<int, vector<BoxData> > gt_boxes;
281              GetGTBox(side_, labels[i], &gt_boxes);
282              for (std::map<int, vector<BoxData > >::iterator it = gt_boxes.begin(); it != gt_boxes.end(); ++it) {
283                  int label = it->first;
284                  vector<BoxData>& g_boxes = it->second;
285                  for (int j = 0; j < g_boxes.size(); ++j) {
286                      top_data[top_index + label] += 1; 
287                  }
288              }
289              map<int, vector<BoxData> > pred_boxes;
290              GetPredBox(side_, num_object_, num_class_, swap_data + input_index, &pred_boxes, score_type_, nms_, biases_);
291              int index = top_index + num_class_;
292              int pred_count(0);
293              for (std::map<int, vector<BoxData> >::iterator it = pred_boxes.begin(); it != pred_boxes.end(); ++it) {
294                  int label = it->first;
295                  vector<BoxData>& p_boxes = it->second;
296                  if (gt_boxes.find(label) == gt_boxes.end()) {
297                      for (int b = 0; b < p_boxes.size(); ++b) {
298                          top_data[index + pred_count * 4 + 0] = p_boxes[b].label_;
299                          top_data[index + pred_count * 4 + 1] = p_boxes[b].score_;
300                          top_data[index + pred_count * 4 + 2] = 0; 
301                          top_data[index + pred_count * 4 + 3] = 1; 
302                          ++pred_count;
303                      }
304                      continue;
305                  }
306                  vector<BoxData>& g_boxes = gt_boxes[label];
307                  vector<bool> records(g_boxes.size(), false);
308                  for (int k = 0; k < p_boxes.size(); ++k) {
309                      top_data[index + pred_count * 4 + 0] = p_boxes[k].label_;
310                      top_data[index + pred_count * 4 + 1] = p_boxes[k].score_;
311                      float max_iou(-1);
312                      int idx(-1);
313                      for (int g = 0; g < g_boxes.size(); ++g) {
314                          float iou = Calc_iou(p_boxes[k].box_, g_boxes[g].box_);
315                          if (iou > max_iou) {
316                              max_iou = iou;
317                              idx = g;
318                          }
319                      }
320                      if (max_iou >= threshold_) {
321                          if (!records[idx]) {
322                              records[idx] = true;
323                              top_data[index + pred_count * 4 + 2] = 1;
324                              top_data[index + pred_count * 4 + 3] = 0;
325                          }
326                          else {
327                              top_data[index + pred_count * 4 + 2] = 0;
328                              top_data[index + pred_count * 4 + 3] = 1;
329                          }
330                      }
331                      ++pred_count;
332                  }
333              }
334          }
335      }
336      INSTANTIATE_CLASS(EvalDetectionLayer);
337      REGISTER_LAYER_CLASS(EvalDetection);
338  }  
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-email.cpp</h3>
            <pre><code>1  #include "email.h"
2  PEMailAliasBs TEMailAliasBs::LoadSsTxt(const TStr& FNm){
3    PSs Ss=TSs::LoadTxt(ssfTabSep, FNm);
4    PEMailAliasBs EMailAliasBs=TEMailAliasBs::New();
5    for (int Y=0; Y<Ss->GetYLen(); Y++){
6      TStr PersonNm=Ss->At(0, Y).GetTrunc();
7      TStr DepNm=Ss->At(1, Y).GetTrunc().GetLc();
8      for (int X=2; X<Ss->GetXLen(Y); X++){
9        TStr EAddr=Ss->At(X, Y).GetTrunc().GetLc();
10        if (!PersonNm.Empty()&&!DepNm.Empty()&&!EAddr.Empty()){
11          EMailAliasBs->EAddrToPersonNmDepNmPrH.AddDat(EAddr, TStrPr(PersonNm, DepNm));
12        }
13      }
14    }
15    return EMailAliasBs;
16  }
17  bool TEMailTsactBs::IsEAddrOk(const TStr& EAddr){
18    TChA EAddrChA=EAddr;
19    EAddrChA.ToLc();
20    for (int ChN=0; ChN<EAddrChA.Len(); ChN++){
21      char Ch=EAddrChA[ChN];
22      if ((('a'<=Ch)&&(Ch<='z'))||(('0'<=Ch)&&(Ch<='9'))||
23       (Ch=='@')||(Ch=='.')||(Ch=='-')||(Ch=='_')){
24      } else {
25        return false;
26      }
27    }
28    return true;
29  }
30  int TEMailTsactBs::AddTsact(const TStr& SrcEAddr, const TStrV& DstEAddrV, const TTm& Tm){
31    int SrcEAddrId=EAddrStrToSrcFqDstFqPrH.AddKey(SrcEAddr);
32    TIntV DstEAddrIdV(DstEAddrV.Len(), 0);
33    for (int DstEAddrN=0; DstEAddrN<DstEAddrV.Len(); DstEAddrN++){
34      int DstEAddrId=EAddrStrToSrcFqDstFqPrH.AddKey(DstEAddrV[DstEAddrN]);
35      DstEAddrIdV.Add(DstEAddrId);
36    }
37    TEMailTsact Tsact(SrcEAddrId, DstEAddrIdV, Tm);
38    return EMailTsactV.Add(Tsact);
39  }
40  TTm TEml::GetTmFromRfc2822DateTimeStr(const TStr& DateTimeStr){
41    TChA DateTimeChA=DateTimeStr;
42    int DateTimeChALen=DateTimeChA.Len();
43    TChA ChA; int ChN=0;
44    while ((ChN<DateTimeChALen)&&isspace(DateTimeChA[ChN])){ChN++;}
45    if ((ChN<DateTimeChALen)&&isalpha(DateTimeChA[ChN])){
46      ChA.Clr();
47      while ((ChN<DateTimeChALen)&&((DateTimeChA[ChN]!=',')&&(DateTimeChA[ChN]!=' '))){
48        ChA+=DateTimeChA[ChN]; ChN++;}
49      if ((ChN<DateTimeChALen)&&DateTimeChA[ChN]==','){ChN++;}
50      while ((ChN<DateTimeChALen)&&isspace(DateTimeChA[ChN])){ChN++;}
51    }
52    ChA.Clr(); 
53    while ((ChN<DateTimeChALen)&&(DateTimeChA[ChN]!=' ')){
54      ChA+=DateTimeChA[ChN]; ChN++;}
55    TStr DayStr=ChA;
56    ChA.Clr(); ChN++;
57    while ((ChN<DateTimeChALen)&&(DateTimeChA[ChN]!=' ')){
58      ChA+=DateTimeChA[ChN]; ChN++;}
59    TStr MonthStr=ChA;
60    ChA.Clr(); ChN++;
61    while ((ChN<DateTimeChALen)&&(DateTimeChA[ChN]!=' ')){
62      ChA+=DateTimeChA[ChN]; ChN++;}
63    TStr YearStr=ChA;
64    ChA.Clr(); ChN++;
65    while ((ChN<DateTimeChALen)&&(isdigit(DateTimeChA[ChN]))){
66      ChA+=DateTimeChA[ChN]; ChN++;}
67    TStr HourStr=ChA;
68    TStr MinStr;
69    if ((ChN<DateTimeChALen)&&(DateTimeStr[ChN]==':')){
70      ChA.Clr(); ChN++;
71      while ((ChN<DateTimeChALen)&&(isdigit(DateTimeChA[ChN]))){
72        ChA+=DateTimeStr[ChN]; ChN++;}
73    }
74    MinStr=ChA;
75    TStr SecStr;
76    if ((ChN<DateTimeChALen)&&(DateTimeStr[ChN]==':')){
77      ChA.Clr(); ChN++;
78      while ((ChN<DateTimeChALen)&&isdigit(DateTimeStr[ChN])){
79        ChA+=DateTimeStr[ChN]; ChN++;}
80      SecStr=ChA;
81    }
82    while ((ChN<DateTimeChALen)&&isspace(DateTimeChA[ChN])){ChN++;}
83    TStr ZoneStr;
84    if ((ChN<DateTimeChALen)&&((DateTimeStr[ChN]=='+')||(DateTimeStr[ChN]=='-'))){
85      ChA.Clr(); 
86      ChA+=DateTimeStr[ChN];
87      ChN++;
88      while ((ChN<DateTimeChALen)&&(isdigit(DateTimeStr[ChN]))){
89        ChA+=DateTimeStr[ChN]; ChN++;}
90      ZoneStr=ChA;
91    } else
92    if ((ChN<DateTimeChALen)&&isalpha(DateTimeStr[ChN])){
93      ChA.Clr(); 
94      while ((ChN<DateTimeChALen)&&(isalpha(DateTimeChA[ChN]))){
95        ChA+=DateTimeStr[ChN]; ChN++;}
96      ZoneStr=ChA;
97    }
98    if (TTmInfo::IsMonthNm(DayStr)){
99      TStr MonthStr1=DayStr; DayStr=MonthStr; MonthStr=MonthStr1;}
100    int YearN=YearStr.GetInt(-1); if ((0<=YearN)&&(YearN<=100)){YearN+=1900;}
<span onclick='openModal()' class='match'>101    int MonthN=TTmInfo::GetMonthN(MonthStr);
102    int DayN=DayStr.GetInt(-1);
103    int HourN=HourStr.GetInt(0);
104    int MinN=MinStr.GetInt(0);
105    int SecN=SecStr.GetInt(0);
106    char ZoneSign=+1;
107    int ZoneMins=0;
</span>108    if (!ZoneStr.Empty()&&!ZoneStr.IsInt()){
109      ZoneStr=TTmInfo::GetTmZoneDiffStr(ZoneStr.GetUc());
110    }
111    if (!ZoneStr.Empty()&&ZoneStr.IsInt()){
112      ZoneMins=ZoneStr.GetSubStr(1, 2).GetInt(-1)*60+ZoneStr.GetSubStr(3, 4).GetInt(-1);
113      if (ZoneStr[0]=='-'){ZoneSign=-1;}
114    }
115    TTm Tm;
116    if ((YearN!=-1)&&(MonthN!=-1)&&(DayN!=-1)){
117      Tm=TTm(YearN, MonthN, DayN, -1, HourN, MinN, SecN, 0);
118      TStr S1=Tm.GetWebLogDateTimeStr(true);
119      if (ZoneSign>0){Tm.AddTime(0, ZoneMins, 0, 0);}
120      else {Tm.SubTime(0, ZoneMins, 0, 0);}
121      TStr S2=Tm.GetWebLogDateTimeStr(true);
122    }
123    return Tm;
124  }
125  void TEml::ExtrMergeToAddrStrV(const TStr& FldVal, TStrV& AddrStrV){
126    TStrV CandAddrStrV; FldVal.SplitOnAllAnyCh("\x09 ,;", CandAddrStrV);
127    for (int CandN=0; CandN<CandAddrStrV.Len(); CandN++){
128      TStr CandAddrStr=CandAddrStrV[CandN];
129      if (!CandAddrStr.IsChIn('@')){continue;}
130      char FirstCh=CandAddrStr[0]; char LastCh=CandAddrStr.LastCh();
131      if ((FirstCh=='<')&&(LastCh=='>')){
132        CandAddrStr=CandAddrStr.GetSubStr(1, CandAddrStr.Len()-2);
133      }
134      if (!isalnum(CandAddrStr[0])){continue;}
135      AddrStrV.AddUnique(CandAddrStr);
136    }
137  }
138  bool TEml::IsFieldNmCh(const uchar& Ch) const {
139    return (32<=Ch)&&(Ch<=126)&&(Ch!=':');
140  }
141  void TEml::ToNrEncoding(const TStr& ContTransferEncVal, TChA& ChA){
142    if (ContTransferEncVal=="base64"){
143      ChA.Clr();
144    } else
145    if (ContTransferEncVal=="quoted-printable"){
146      TChA NrChA(ChA.Len()); int ChN=0;
147      while (ChN<ChA.Len()){
148        if ((ChA[ChN]=='=')&&(ChN+2<ChA.Len())){
149          ChN++; char HexCh1=ChA[ChN++]; char HexCh2=ChA[ChN++];
150          if ((TCh::IsHex(HexCh1))&&(TCh::IsHex(HexCh2))){
151            int ChVal=16*TCh::GetHex(HexCh1)+TCh::GetHex(HexCh2);
152            NrChA.AddCh(ChVal);
153          }
154        } else {
155          NrChA.AddCh(ChA[ChN]); ChN++;
156        }
157      }
158      ChA=NrChA;
159    }
160  }
161  void TEml::ExtrAddBoundaryStr(const TStr& ContTypeVal, TStrV& BoundaryStrV) const {
162    TStr FldStr="boundary=";
163    int FldChN=ContTypeVal.SearchStr(FldStr);
164    TStr BoundaryStr;
165    if (FldChN==-1){
166      BoundaryStr="";
167    } else {
168      TChA ChA=ContTypeVal.GetSubStr(FldChN+FldStr.Len(), ContTypeVal.Len());
169      if ((ChA.Len()>0)&&(ChA[0]=='\"')){ChA.Del(0);}
170      int ChN=0;
171      while ((ChN<ChA.Len())&&(ChA[ChN]!='\"')){ChN++;}
172      ChA.Trunc(ChN);
173      BoundaryStr=ChA;
174    }
175    if (!BoundaryStr.Empty()){
176      BoundaryStrV.AddUnique(BoundaryStr);}
177  }
178  bool TEml::LoadField(const PSIn& SIn, TChA& FldNm, TChA& FldVal, TChA& LcFldVal){
179    FldNm.Clr(); FldVal.Clr(); LcFldVal.Clr();
180    while (IsFieldNmCh(SIn->PeekCh())){
181      FldNm+=tolower(SIn->GetCh());} 
182    if (FldNm.Empty()){return false;}
183    if (SIn->PeekCh()!=':'){return false;} else {SIn->GetCh();}
184    forever{
185      if (SIn->PeekCh()==13){
186        SIn->GetCh(); 
187        if (SIn->PeekCh()==10){
188          SIn->GetCh();
189          if ((SIn->PeekCh()==32)||(SIn->PeekCh()==9)){
190          } else {
191            break;
192          }
193        }
194      }
195      FldVal+=SIn->GetCh();
196    }
197    LcFldVal=FldVal; LcFldVal.ToLc();
198    return true;
199  }
200  void TEml::LoadMessage(const PSIn& SIn){
201    TChA FldNm; TChA FldVal; TChA LcFldVal;
202    TStr ContTypeVal; TStr LcContTypeVal;
203    TStr ContTransferEncVal; 
204    TStrV BoundaryStrV;
205    TChA SubjChA;
206    forever {
207      bool IsFld=LoadField(SIn, FldNm, FldVal, LcFldVal); 
208      if (IsFld){
209        if (FldNm=="from"){
210          ExtrMergeToAddrStrV(LcFldVal, FromAddrStrV);}
211        else if ((FldNm=="to")||(FldNm=="cc")||(FldNm=="bcc")){
212          ExtrMergeToAddrStrV(LcFldVal, ToAddrStrV);}
213        else if (FldNm=="date"){
214          Tm=GetTmFromRfc2822DateTimeStr(LcFldVal);
215        }
216        else if (FldNm=="subject"){
217          SubjChA=FldVal;}
218        else if (FldNm=="content-type"){
219          ContTypeVal=FldVal; LcContTypeVal=LcFldVal;}
220        else if (FldNm=="content-transfer-encoding"){
221          ContTransferEncVal=LcFldVal; ContTransferEncVal.ToTrunc();}
222      } else {
223        if (SIn->PeekCh()==13){
224          SIn->GetCh(); if (SIn->PeekCh()==10){SIn->GetCh();} else {}
225        }
226        break;
227      }
228    }
229    ToNrEncoding(ContTransferEncVal, SubjChA); SubjStr=SubjChA;
230    TChA ContChA;
231    if (LcContTypeVal.Empty()||LcContTypeVal.IsStrIn("text/plain")||LcContTypeVal.IsStrIn("text/html")){
232      TStrV LnStrV; TChA LnChA;
233      while (SIn->PeekCh()!=0){
234        LnChA+=SIn->GetCh();
235        if ((LnChA.LastCh()==10)||(SIn->PeekCh()!=0)){
236          ContChA+=LnChA; LnStrV.Add(LnChA.CStr()); LnChA.Clr();}
237      }
238    } else
239    if (LcContTypeVal.IsStrIn("multipart/")){
240      ExtrAddBoundaryStr(ContTypeVal, BoundaryStrV);
241      TStrV LnStrV; TChA LnChA; bool InsLnP=false;
242      while (SIn->PeekCh()!=0){
243        LnChA+=SIn->GetCh();
244        if ((LnChA.LastCh()==10)||(SIn->PeekCh()==0)){
245          if ((ContChA.Len()>0)&&(ContChA.LastCh()!=' ')){ContChA+=' ';}
246          bool IsBoundary=false;
247          for (int BoundaryN=0; BoundaryN<BoundaryStrV.Len(); BoundaryN++){
248            if (LnChA.IsStrIn(BoundaryStrV[BoundaryN])){
249              IsBoundary=true; break;}
250          }
251          if (InsLnP&&!IsBoundary){
252            ContChA+=LnChA; LnStrV.Add(LnChA.CStr());} 
253          if (IsBoundary){
254            TStr PartContTypeVal; TStr PartLcContTypeVal; 
255            TChA PartFldNm; TChA PartFldVal; TChA PartLcFldVal;
256            forever {
257              bool IsPartFld=LoadField(SIn, PartFldNm, PartFldVal, PartLcFldVal);
258              if (IsPartFld){
259                if (PartFldNm=="content-type"){
260                  PartContTypeVal=PartFldVal; PartLcContTypeVal=PartLcFldVal;
261                  ExtrAddBoundaryStr(PartContTypeVal, BoundaryStrV);
262                } 
263                else if (PartFldNm=="content-transfer-encoding"){
264                  if (ContTransferEncVal.Empty()){
265                    ContTransferEncVal=PartLcFldVal; 
266                    ContTransferEncVal.ToTrunc();
267                  }
268                }
269              } else {
270                break;
271              }
272            }
273            InsLnP=PartLcContTypeVal.IsStrIn("text/plain")||PartLcContTypeVal.IsStrIn("text/html");
274          }
275          LnChA.Clr();
276        }
277      }
278    }
279    ToNrEncoding(ContTransferEncVal, ContChA); 
280    ContStr=ContChA; 
281  }
282  PEml TEml::LoadEml(const TStr& FNm, const TStr& OwnerNm){
283    PSIn SIn=TFIn::New(FNm);
284    PEml Eml=TEml::New();
285    Eml->OwnerNm=OwnerNm;
286    Eml->LoadMessage(SIn);
287    return Eml;
288  }
289  void TEmlBs::AddEml(const TStr& EmlNm, const PEml& Eml){
290    NmToEmlH.AddDat(EmlNm, Eml);
291    int EmlP=NmToEmlH.GetKeyId(EmlNm);
292    for (int EAddrN=0; EAddrN<Eml->GetFromEAddrs(); EAddrN++){
293      AddEAddr(Eml->GetFromEAddr(EAddrN), EmlP);}
294    for (int EAddrN=0; EAddrN<Eml->GetToEAddrs(); EAddrN++){
295      AddEAddr(Eml->GetToEAddr(EAddrN), EmlP);}
296  }
297  void TEmlBs::DelEml(const TStr& EmlNm){
298    PEml Eml=NmToEmlH.GetDat(EmlNm);
299    int EmlP=NmToEmlH.GetKeyId(EmlNm);
300    for (int EAddrN=0; EAddrN<Eml->GetFromEAddrs(); EAddrN++){
301      DelEAddr(Eml->GetFromEAddr(EAddrN), EmlP);}
302    for (int EAddrN=0; EAddrN<Eml->GetToEAddrs(); EAddrN++){
303      DelEAddr(Eml->GetToEAddr(EAddrN), EmlP);}
304    NmToEmlH.DelKey(EmlNm);
305  }
306  void TEmlBs::GetTmEmlNmPrV(TTmStrPrV& TmEmlNmPrV) const {
307    TStrV EmlIdV; GetEmlNmV(EmlIdV);
308    TmEmlNmPrV.Gen(EmlIdV.Len(), 0);
309    for (int EmlN=0; EmlN<EmlIdV.Len(); EmlN++){
310      TStr EmlNm=EmlIdV[EmlN];
311      PEml Eml=GetEml(EmlNm);
312      TmEmlNmPrV.Add(TTmStrPr(Eml->GetTm(), EmlNm));
313    }
314    TmEmlNmPrV.Sort();
315  }
316  void TEmlBs::LoadWinMailAccount(const TStr& FPath, const TStr& OwnerNm, const int& MxEmls){
317    printf("Processing WinMail-Account at '%s' ...\n", FPath.CStr());
318    TStr NrFPath=TStr::GetNrFPath(FPath);
319    PFFile FFile=TFFile::New(FPath, "eml", true); 
320    TStr EmlFNm; int Emls=0; 
321    while (FFile->Next(EmlFNm)){
322      Emls++; if ((MxEmls!=-1)&&(Emls>=MxEmls)){break;}
323      printf("%d\r", Emls);
324      TStr EmlNm=EmlFNm;
325      if (EmlNm.IsPrefix(NrFPath)){
326        EmlNm=EmlNm.GetSubStr(NrFPath.Len(), EmlNm.Len());}
327      PEml Eml=TEml::LoadEml(EmlFNm, OwnerNm);
328      if (Eml->GetTm().IsDef()){
329        AddEml(EmlNm, Eml);}
330    }
331    printf("Done.\n");
332  }
333  void TEmlBs::LoadEnronEMail(const TStr& FPath, const int& MxEmls){
334    printf("Processing Enron-EMail at '%s' ...\n", FPath.CStr());
335    TStr NrFPath=TStr::GetNrFPath(FPath);
336    PFFile FFile=TFFile::New(FPath, "", true);
337    TStr EmlFNm; int Emls=0; 
338    while (FFile->Next(EmlFNm)){
339      Emls++; if ((MxEmls!=-1)&&(Emls>=MxEmls)){break;}
340      printf("%d\r", Emls);
341      TStr EmlNm=EmlFNm;
342      if (EmlNm.IsPrefix(NrFPath)){
343        EmlNm=EmlNm.GetSubStr(NrFPath.Len(), EmlNm.Len());}
344      int OwnerEChN=EmlNm.SearchCh('/')-1;
345      TStr OwnerNm=EmlNm.GetSubStr(0, OwnerEChN);
346      PEml Eml=TEml::LoadEml(EmlFNm, OwnerNm);
347      AddEml(EmlNm, Eml);
348    }
349    printf("\nDone.\n");
350  }
351  void TEmlBs::SaveTxt(const TStr& FNm){
352    TTmStrPrV TmEmlNmPrV; GetTmEmlNmPrV(TmEmlNmPrV);
353    {TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
354    for (int EmlN=0; EmlN<TmEmlNmPrV.Len(); EmlN++){
355      TStr EmlNm=TmEmlNmPrV[EmlN].Val2;
356      PEml Eml=GetEml(EmlNm);
357      fprintf(fOut, "==================================\n");
358      fprintf(fOut, "Id: %s\n", EmlNm.CStr());
359      fprintf(fOut, "Owner: %s\n", Eml->GetOwnerNm().CStr());
360      fprintf(fOut, "From:");
361      for (int EAddrN=0; EAddrN<Eml->GetFromEAddrs(); EAddrN++){
362        fprintf(fOut, " %s", Eml->GetFromEAddr(EAddrN).CStr());
363      }
364      fprintf(fOut, "\n");
365      fprintf(fOut, "To:");
366      for (int EAddrN=0; EAddrN<Eml->GetToEAddrs(); EAddrN++){
367        fprintf(fOut, " %s", Eml->GetToEAddr(EAddrN).CStr());
368      }
369      fprintf(fOut, "\n"); 
370      fprintf(fOut, "Time: %s\n", Eml->GetTm().GetWebLogDateTimeStr(true).CStr());
371      fprintf(fOut, "Subject: %s\n", Eml->GetSubjStr().CStr());
372      TChA ContChA=Eml->GetContStr(); 
373      ContChA.ChangeCh('\r', ' '); ContChA.ChangeCh('\n', ' ');
374      fprintf(fOut, "Content: %s\n", ContChA.CStr());
375    }}
376  }
377  void TEmlBs::SaveTxtEAddr(const TStr& FNm){
378    TIntStrPrV FqAddrStrPrV; 
379    int EAddrs=GetEAddrs();
380    for (int EAddrN=0; EAddrN<EAddrs; EAddrN++){
381      FqAddrStrPrV.Add(TIntStrPr(GetEAddrFq(EAddrN), GetEAddrStr(EAddrN)));
382    }
383    {FqAddrStrPrV.Sort(false);
384    TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
385    for (int AddrN=0; AddrN<FqAddrStrPrV.Len(); AddrN++){
386      fprintf(fOut, "%d. #%d %s\n", 1+AddrN, FqAddrStrPrV[AddrN].Val1, FqAddrStrPrV[AddrN].Val2.CStr());
387    }}
388  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-eval_detection_layer.cpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-email.cpp</div>
                <div class="column column_space"><pre><code>98                      int index = (j * side + i) * num_object * (num_class + 1 + 4) + n * (num_class + 1 + 4);
99                      float x = (i + sigmoid(input_data[index + 0])) / side;
100                      float y = (j + sigmoid(input_data[index + 1])) / side;
101                      float w = (exp(input_data[index + 2]) * biases[2 * n]) / side;
102                      float h = (exp(input_data[index + 3]) * biases[2 * n + 1]) / side;
103                      softmax_region(input_data + index + 5, num_class);
104                      int pred_label = 0;
105                      float max_prob = input_data[index + 5];
</pre></code></div>
                <div class="column column_space"><pre><code>101    int MonthN=TTmInfo::GetMonthN(MonthStr);
102    int DayN=DayStr.GetInt(-1);
103    int HourN=HourStr.GetInt(0);
104    int MinN=MinStr.GetInt(0);
105    int SecN=SecStr.GetInt(0);
106    char ZoneSign=+1;
107    int ZoneMins=0;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    