
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 33.15276273022752%, Tokens: 9</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-agmattr.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "agmattr.h"
3  #include "Snap.h"
4  #include "agm.h"
5  void TCesna::RandomInit(const int InitComs) {
6    F.Gen(G->GetNodes());
7    SumFV.Gen(InitComs);
8    NumComs = InitComs;
9    for (int u = 0; u < F.Len(); u++) {
10      int Mem = G->GetNI(u).GetDeg();
11      if (Mem > 10) { Mem = 10; }
12      for (int c = 0; c < Mem; c++) {
13        int CID = Rnd.GetUniDevInt(InitComs);
14        AddCom(u, CID, Rnd.GetUniDev());
15      }
16    }
17    for (int c = 0; c < SumFV.Len(); c++) {
18      if (SumFV[c] == 0.0) {
19        int UID = Rnd.GetUniDevInt(G->GetNodes());
20        AddCom(UID, c, Rnd.GetUniDev());
21      }
22    }
23    InitW();
24  }
25  void TCesna::NeighborComInit(const int InitComs) {
26    TFltIntPrV NIdPhiV(F.Len(), 0);
27    TCesnaUtil::GetNIdPhiV<PUNGraph>(G, NIdPhiV);
28    NeighborComInit(NIdPhiV, InitComs);
29  }
30  void TCesna::NeighborComInit(TFltIntPrV& NIdPhiV, const int InitComs) {
31    NIdPhiV.Sort(true);
32    F.Gen(G->GetNodes());
33    SumFV.Gen(InitComs);
34    NumComs = InitComs;
35    TIntSet InvalidNIDS(F.Len());
36    TIntV ChosenNIDV(InitComs, 0); 
37    int CurCID = 0;
38    for (int ui = 0; ui < NIdPhiV.Len(); ui++) {
39      int UID = NIdPhiV[ui].Val2;
40      fflush(stdout);
41      if (InvalidNIDS.IsKey(UID)) { continue; }
42      ChosenNIDV.Add(UID); 
43      AddCom(UID, CurCID, 1.0);
44      TUNGraph::TNodeI NI = G->GetNI(UID);
45      fflush(stdout);
46      for (int e = 0; e < NI.GetDeg(); e++) {
47        AddCom(NI.GetNbrNId(e), CurCID, 1.0);
48      }
49      for (int e = 0; e < NI.GetDeg(); e++) {
50        InvalidNIDS.AddKey(NI.GetNbrNId(e));
51      }
52      CurCID++;
53      fflush(stdout);
54      if (CurCID >= NumComs) { break;  }
55    }
56    if (NumComs > CurCID) {
57      printf("%d communities needed to fill randomly\n", NumComs - CurCID);
58    }
59    for (int c = 0; c < SumFV.Len(); c++) {
60      if (SumFV[c] == 0.0) {
61        int ComSz = 10;
62        for (int u = 0; u < ComSz; u++) {
63          int UID = Rnd.GetUniDevInt(G->GetNodes());
64          AddCom(UID, c, Rnd.GetUniDev());
65        }
66      }
67    }
68    InitW();
69  }
70  void TCesna::SetCmtyVV(const TVec<TIntV>& CmtyVV) {
71    F.Gen(G->GetNodes());
72    SumFV.Gen(CmtyVV.Len());
73    NumComs = CmtyVV.Len();
74    InitW();
75    for (int c = 0; c < CmtyVV.Len(); c++) {
76      for (int u = 0; u < CmtyVV[c].Len(); u++) {
77        int UID = CmtyVV[c][u];
78        if (! NIDToIdx.IsKey(UID)) { continue; }
79        AddCom(NIDToIdx.GetKeyId(UID), c, 1.0);
80      }
81    }
82  }
83  void TCesna::SetGraph(const PUNGraph& GraphPt, const THash<TInt, TIntV>& NIDAttrH) {
84    HOVIDSV.Gen(GraphPt->GetNodes());  
85    HOKIDSV.Gen(GraphPt->GetNodes());  
86    X.Gen(GraphPt->GetNodes());
87    TIntV NIDV;
88    GraphPt->GetNIdV(NIDV);
89    NIDToIdx.Gen(NIDV.Len());
90    NIDToIdx.AddKeyV(NIDV);
91    printf("rearrage nodes\n");
92    G = TSnap::GetSubGraph(GraphPt, NIDV, true);
93    for (int nid = 0; nid < G->GetNodes(); nid++) {
94      IAssert(G->IsNode(nid)); 
95    }
96    TSnap::DelSelfEdges(G);
97    PNoCom = 1.0 / (double) G->GetNodes();
98    DoParallel = false;
99    if (1.0 / PNoCom > sqrt(TFlt::Mx)) { PNoCom = 0.99 / sqrt(TFlt::Mx); } 
100    NegWgt = 1.0;
101    int NumAttr = 0;
102    for (int u = 0; u < NIDAttrH.Len(); u++) {
103      int UID = NIDAttrH.GetKey(u);
104      if (! NIDToIdx.IsKey(UID)) { continue; }
105      X[NIDToIdx.GetKeyId(UID)].Gen(NIDAttrH[u].Len());
106      for (int k = 0; k < NIDAttrH[u].Len(); k++) {
107        int KID = NIDAttrH[u][k];
108        IAssert (KID >= 0);
109        X[NIDToIdx.GetKeyId(UID)].AddKey(KID);
110        if (NumAttr < KID + 1) { NumAttr = KID + 1; } 
111      }
112    }
113    Attrs = NumAttr;
114    InitW();
115  }
116  double TCesna::Likelihood(const bool _DoParallel) { 
117    TExeTm ExeTm;
118    double L = 0.0;
119    if (_DoParallel) {
120    #pragma omp parallel for 
121      for (int u = 0; u < F.Len(); u++) {
122        double LU = LikelihoodForRow(u);
123        #pragma omp atomic
124          L += LU;
125      }
126    }
127    else {
128      for (int u = 0; u < F.Len(); u++) {
129        double LU = LikelihoodForRow(u);
130          L += LU;
131      }
132    }
133    return L;
134  }
135  double TCesna::LikelihoodForRow(const int UID) {
136    return LikelihoodForRow(UID, F[UID]);
137  }
138  double TCesna::LikelihoodForRow(const int UID, const TIntFltH& FU) {
139    double L = 0.0;
140    TFltV HOSumFV; 
141    if (HOVIDSV[UID].Len() > 0) {
142      HOSumFV.Gen(SumFV.Len());
143      for (int e = 0; e < HOVIDSV[UID].Len(); e++) {
144        for (int c = 0; c < SumFV.Len(); c++) {
145          HOSumFV[c] += GetCom(HOVIDSV[UID][e], c);
146        }
147      }
148    }
149    TUNGraph::TNodeI NI = G->GetNI(UID);
150    for (int e = 0; e < NI.GetDeg(); e++) {
151      int v = NI.GetNbrNId(e);
152      if (v == UID) { continue; }
153      if (HOVIDSV[UID].IsKey(v)) { continue; }
154      L += log (1.0 - Prediction(FU, F[v])) + NegWgt * DotProduct(FU, F[v]);
155    }
156    for (TIntFltH::TIter HI = FU.BegI(); HI < FU.EndI(); HI++) {
157      double HOSum = HOVIDSV[UID].Len() > 0?  HOSumFV[HI.GetKey()].Val: 0.0;
158      L -= NegWgt * (SumFV[HI.GetKey()] - HOSum - GetCom(UID, HI.GetKey())) * HI.GetDat();
159    }
160    if (RegCoef > 0.0) { 
161      L -= RegCoef * Sum(FU);
162    }
163    if (RegCoef < 0.0) { 
164      L += RegCoef * Norm2(FU);
165    }
166    L *= (1.0 - WeightAttr);
167    for (int k = 0; k < Attrs; k++) {
168      if (HOKIDSV[UID].IsKey(k)) { continue; }
169      L += WeightAttr * LikelihoodAttrKForRow(UID, k, FU);
170    }
171    return L;
172  }
173  double TCesna::LikelihoodAttrKForRow(const int UID, const int K, const TIntFltH& FU, const TFltV& WK) {
174    double Prob = PredictAttrK(FU, WK);
175    double L = 0.0;
176    if (GetAttr(UID, K)) { 
177      L = Prob == 0.0? -100.0: log(Prob);
178    } else {
179      L = Prob == 1.0? -100.0: log(1.0 - Prob);
180    }
181    return L;
182  }
183  void TCesna::GradientForRow(const int UID, TIntFltH& GradU, const TIntSet& CIDSet) {
184    GradU.Gen(CIDSet.Len());
185    TFltV HOSumFV; 
186    if (HOVIDSV[UID].Len() > 0) {
187      HOSumFV.Gen(SumFV.Len());
188      for (int e = 0; e < HOVIDSV[UID].Len(); e++) {
189        for (int c = 0; c < SumFV.Len(); c++) {
190          HOSumFV[c] += GetCom(HOVIDSV[UID][e], c);
191        }
192      }
193    }
194    TUNGraph::TNodeI NI = G->GetNI(UID);
195    int Deg = NI.GetDeg();
196    TFltV PredV(Deg), GradV(CIDSet.Len());
197    TIntV CIDV(CIDSet.Len());
198    for (int e = 0; e < Deg; e++) {
199      if (NI.GetNbrNId(e) == UID) { continue; }
200      if (HOVIDSV[UID].IsKey(NI.GetNbrNId(e))) { continue; }
201      PredV[e] = Prediction(UID, NI.GetNbrNId(e));
202    }
203    for (int c = 0; c < CIDSet.Len(); c++) {
204      int CID = CIDSet.GetKey(c);
205      double Val = 0.0;
206      for (int e = 0; e < Deg; e++) {
207        int VID = NI.GetNbrNId(e);
208        if (VID == UID) { continue; }
209        if (HOVIDSV[UID].IsKey(VID)) { continue; }
210        Val += PredV[e] * GetCom(VID, CID) / (1.0 - PredV[e]) + NegWgt * GetCom(VID, CID);
211      }
212      double HOSum = HOVIDSV[UID].Len() > 0?  HOSumFV[CID].Val: 0.0;
213      Val -= NegWgt * (SumFV[CID] - HOSum - GetCom(UID, CID));
214      CIDV[c] = CID;
215      GradV[c] = Val;
216    }
217    if (RegCoef > 0.0) { 
218      for (int c = 0; c < GradV.Len(); c++) {
219        GradV[c] -= RegCoef; 
220      }
221    }
222    if (RegCoef < 0.0) { 
223      for (int c = 0; c < GradV.Len(); c++) {
224        GradV[c] += 2 * RegCoef * GetCom(UID, CIDV[c]); 
225      }
226    }
227    for (int c = 0; c < GradV.Len(); c++) {
228      GradV[c] *= (1.0 - WeightAttr);
229    }
230    TFltV AttrPredV(Attrs);
231    for (int k = 0; k < Attrs; k++) {
232      if (HOKIDSV[UID].IsKey(k)) { continue; }
233      AttrPredV[k] = PredictAttrK(F[UID], W[k]);
234    }
235    for (int c = 0; c < GradV.Len(); c++) {
236      for (int k = 0; k < Attrs; k++) {
237        if (HOKIDSV[UID].IsKey(k)) { continue; }
238        GradV[c] += WeightAttr * (GetAttr(UID, k) - AttrPredV[k]) * GetW(CIDV[c], k);
239      }
240    }
241    for (int c = 0; c < GradV.Len(); c++) {
242      if (GetCom(UID, CIDV[c]) == 0.0 && GradV[c] < 0.0) { continue; }
243      if (fabs(GradV[c]) < 0.0001) { continue; }
244      GradU.AddDat(CIDV[c], GradV[c]);
245    }
246    for (int c = 0; c < GradU.Len(); c++) {
247      if (GradU[c] >= 10) { GradU[c] = 10; }
248      if (GradU[c] <= -10) { GradU[c] = -10; }
249      IAssert(GradU[c] >= -10);
250    }
251  }
252  void TCesna::GetCmtyVV(TVec<TIntV>& CmtyVV) {
253    TVec<TFltV> TmpV;
254    GetCmtyVV(CmtyVV, TmpV, sqrt(2.0 * (double) G->GetEdges() / G->GetNodes() / G->GetNodes()), 3);
255  }
256  void TCesna::GetCmtyVV(TVec<TIntV>& CmtyVV, TVec<TFltV>& Wck, const double Thres, const int MinSz) {
257    CmtyVV.Gen(NumComs, 0);
258    Wck.Gen(NumComs, 0);
259    TIntFltH CIDSumFH(NumComs);
260    for (int c = 0; c < SumFV.Len(); c++) {
261      CIDSumFH.AddDat(c, SumFV[c]);
262    }
263    CIDSumFH.SortByDat(false);
264    for (int c = 0; c < NumComs; c++) {
265      int CID = CIDSumFH.GetKey(c);
266      TIntFltH NIDFucH(F.Len() / 10);
267      TIntV CmtyV;
268      IAssert(SumFV[CID] == CIDSumFH.GetDat(CID));
269      if (SumFV[CID] < Thres) { continue; }
270      for (int u = 0; u < F.Len(); u++) {
271        int NID = NIDToIdx[u];
272        if (GetCom(u, CID) >= Thres) { NIDFucH.AddDat(NID, GetCom(u, CID)); }
273      }
274      NIDFucH.SortByDat(false);
275      NIDFucH.GetKeyV(CmtyV);
276      if (CmtyV.Len() < MinSz) { continue; }
277      CmtyVV.Add(CmtyV); 
278      TFltV WV(Attrs);
279      for (int k = 0; k < Attrs; k++) {
280        WV[k] = GetW(CID, k);
281      }
282      Wck.Add(WV);
283    }
284    if ( NumComs != CmtyVV.Len()) {
285      printf("Community vector generated. %d communities are ommitted\n", NumComs.Val - CmtyVV.Len());
286    }
287  }
288  void TCesna::GetCmtyVVUnSorted(TVec<TIntV>& CmtyVV) {
289    GetCmtyVVUnSorted(CmtyVV, sqrt(2.0 * (double) G->GetEdges() / G->GetNodes() / G->GetNodes()), 3);
290  }
291  void TCesna::GetCmtyVVUnSorted(TVec<TIntV>& CmtyVV, const double Thres, const int MinSz) {
292    CmtyVV.Gen(NumComs, 0);
293    for (int c = 0; c < NumComs; c++) {
294      TIntV CmtyV;
295      for (int u = 0; u < G->GetNodes(); u++) {
296        if (GetCom(u, c) > Thres) { CmtyV.Add(NIDToIdx[u]); }
297      }
298      if (CmtyV.Len() >= MinSz) { CmtyVV.Add(CmtyV); }
299    }
300    if ( NumComs != CmtyVV.Len()) {
301      printf("Community vector generated. %d communities are ommitted\n", NumComs.Val - CmtyVV.Len());
302    }
303  }
304  int TCesna::FindComs(const int NumThreads, const int MaxComs, const int MinComs, const int DivComs, const TStr OutFNm, const bool UseBIC, const double HOFrac, const double StepAlpha, const double StepBeta) {
305      double ComsGap = exp(TMath::Log((double) MaxComs / (double) MinComs) / (double) DivComs);
306      TIntV ComsV;
307      ComsV.Add(MinComs);
308      while (ComsV.Len() < DivComs) {
309        int NewComs = int(ComsV.Last() * ComsGap);
310        if (NewComs == ComsV.Last().Val) { NewComs++; }
311        ComsV.Add(NewComs);
312      }
313      if (ComsV.Last() < MaxComs) { ComsV.Add(MaxComs); }
314      return FindComs(ComsV, UseBIC, HOFrac, NumThreads, OutFNm, StepAlpha, StepBeta);
315  }
316  int TCesna::FindComs(TIntV& ComsV, const bool UseBIC, const double HOFrac, const int NumThreads, const TStr PlotLFNm, const double StepAlpha, const double StepBeta) {
317    if (ComsV.Len() == 0) {
318      int MaxComs = G->GetNodes() / 5;
319      ComsV.Add(2);
320      while(ComsV.Last() < MaxComs) { ComsV.Add(ComsV.Last() * 2); }
321    }
322    int MaxIterCV = 3;
323    TVec<TVec<TIntSet> > HoldOutSets(MaxIterCV), HoldOutSetsAttr(MaxIterCV);
324    TFltIntPrV NIdPhiV;
325    TCesnaUtil::GetNIdPhiV<PUNGraph>(G, NIdPhiV);
326    if (! UseBIC) { 
327      TIntV NIdV1, NIdV2;
328      G->GetNIdV(NIdV1);
329      G->GetNIdV(NIdV2);
330      for (int IterCV = 0; IterCV < MaxIterCV; IterCV++) {
331        TCesnaUtil::GenHoldOutPairs(G, HoldOutSets[IterCV], HOFrac, Rnd);
332        GenHoldOutAttr(HOFrac, HoldOutSetsAttr[IterCV]);
333      }
334    }
335    TFltV HOLV(ComsV.Len());
336    TIntFltPrV ComsLV;
337    for (int c = 0; c < ComsV.Len(); c++) {
338      const int Coms = ComsV[c];
339      if (! UseBIC) { 
340        for (int IterCV = 0; IterCV < MaxIterCV; IterCV++) {
341          HOVIDSV = HoldOutSets[IterCV];
342          HOKIDSV = HoldOutSetsAttr[IterCV];
343          NeighborComInit(NIdPhiV, Coms);
344          if (NumThreads == 1) {
345            MLEGradAscent(0.01, 100 * G->GetNodes(), "", StepAlpha, StepBeta);
346          } else {
347            MLEGradAscentParallel(0.01, 100, NumThreads, "", StepAlpha, StepBeta);
348          }
349          double HOL = LikelihoodHoldOut();
350          HOL = HOL < 0? HOL: TFlt::Mn;
351          HOLV[c] += HOL;
352        }
353      }
354      else {
355        HOVIDSV.Gen(G->GetNodes());
356        HOKIDSV.Gen(G->GetNodes());
357        if (NumThreads == 1) {
358          MLEGradAscent(0.005, 100 * G->GetNodes(), "", StepAlpha, StepBeta);
359          printf("likelihood: train:%f, attr:%f, hold:%f\n", Likelihood(), LikelihoodAttr(), LikelihoodHoldOut());
360        } else {
361          MLEGradAscentParallel(0.005, 100, NumThreads, "", StepAlpha, StepBeta);
362        }
363        double NumParams = (1.0 - WeightAttr) * Coms + WeightAttr * Coms * Attrs;
364        double Observations = (1.0 - WeightAttr) * G->GetNodes() * (G->GetNodes() - 1) / 2 + WeightAttr * G->GetNodes() * Attrs;
365        double BIC = 2 * Likelihood() - NumParams * log (Observations);
366        HOLV[c] = BIC;
367      }
368    }
369    int EstComs = 2;
370    double MaxL = TFlt::Mn;
371    if (UseBIC) {
372      printf("Number of communities vs likelihood (criterion: BIC)\n");
373    } else {
374      printf("Number of communities vs likelihood (criterion: Cross validation)\n");
375    }
376    for (int c = 0; c < ComsV.Len(); c++) {
377      ComsLV.Add(TIntFltPr(ComsV[c].Val, HOLV[c].Val));
378      printf("%d(%f)\t", ComsV[c].Val, HOLV[c].Val);
379      if (MaxL < HOLV[c]) {
380        MaxL = HOLV[c];
381        EstComs = ComsV[c];
382      }
383    }
384    printf("\n");
385    RandomInit(EstComs);
386    HOVIDSV.Gen(G->GetNodes());
387    HOKIDSV.Gen(G->GetNodes());
388    if (! PlotLFNm.Empty()) {
389      TGnuPlot::PlotValV(ComsLV, PlotLFNm, "hold-out likelihood", "communities", "likelihood");
390    }
391    return EstComs;
392  }
393  double TCesna::LikelihoodHoldOut() { 
394    double L = 0.0;
395    for (int u = 0; u < HOVIDSV.Len(); u++) {
396      for (int e = 0; e < HOVIDSV[u].Len(); e++) {
397        int VID = HOVIDSV[u][e];
398        if (VID == u) { continue; } 
399        double Pred = Prediction(u, VID);
400        if (G->IsEdge(u, VID)) {
401          L += log(1.0 - Pred);
402        }
403        else {
404          L += NegWgt * log(Pred);
405        }
406      } 
407    }
408    L *= (1.0 - WeightAttr);
409    for (int u = 0; u < HOKIDSV.Len(); u++) {
410      for (int e = 0; e < HOKIDSV[u].Len(); e++) {
411        IAssert(HOKIDSV[u][e] < Attrs);
412        L += WeightAttr * LikelihoodAttrKForRow(u, HOKIDSV[u][e]);
413      }
414    }
415    return L;
416  }
417  double TCesna::GetStepSizeByLineSearch(const int UID, const TIntFltH& DeltaV, const TIntFltH& GradV, const double& Alpha, const double& Beta, const int MaxIter) {
418    double StepSize = 1.0;
419    double InitLikelihood = LikelihoodForRow(UID);
420    TIntFltH NewVarV(DeltaV.Len());
421    for(int iter = 0; iter < MaxIter; iter++) {
422      for (int i = 0; i < DeltaV.Len(); i++){
423        int CID = DeltaV.GetKey(i);
424        double NewVal = GetCom(UID, CID) + StepSize * DeltaV.GetDat(CID);
425        if (NewVal < MinVal) { NewVal = MinVal; }
<span onclick='openModal()' class='match'>426        if (NewVal > MaxVal) { NewVal = MaxVal; }
427        NewVarV.AddDat(CID, NewVal);
428      }
429      if (LikelihoodForRow(UID, NewVarV) < InitLikelihood + Alpha * StepSize * DotProduct(GradV, DeltaV)) {
430        StepSize *= Beta;
431      } else {
</span>432        break;
433      }
434      if (iter == MaxIter - 1) { 
435        StepSize = 0.0;
436        break;
437      }
438    }
439    return StepSize;
440  }
441  int TCesna::MLEGradAscent(const double& Thres, const int& MaxIter, const TStr PlotNm, const double StepAlpha, const double StepBeta) {
442    time_t InitTime = time(NULL);
443    TExeTm ExeTm, CheckTm;
444    int iter = 0, PrevIter = 0;
445    TIntFltPrV IterLV;
446    TUNGraph::TNodeI UI;
447    double PrevL = TFlt::Mn, CurL = 0.0;
448    TIntV NIdxV(F.Len(), 0);
449    for (int i = 0; i < F.Len(); i++) { NIdxV.Add(i); }
450    TIntFltH GradV;
451    TIntSet CIDSet(NumComs);
452    for (int c = 0; c < NumComs; c++) { CIDSet.AddKey(c); }
453    while(iter < MaxIter) {
454      NIdxV.Shuffle(Rnd);
455      for (int ui = 0; ui < F.Len(); ui++, iter++) {
456        int u = NIdxV[ui]; 
457        GradientForRow(u, GradV, CIDSet);
458        if (Norm2(GradV) < 1e-4) { continue; }
459        double LearnRate = GetStepSizeByLineSearch(u, GradV, GradV, StepAlpha, StepBeta);
460        if (LearnRate == 0.0) { continue; }
461        for (int ci = 0; ci < GradV.Len(); ci++) {
462          int CID = GradV.GetKey(ci);
463          double Change = LearnRate * GradV.GetDat(CID);
464          double NewFuc = GetCom(u, CID) + Change;
465          if (NewFuc <= 0.0) {
466            DelCom(u, CID);
467          } else {
468            AddCom(u, CID, NewFuc);
469          }
470        }
471        if (! PlotNm.Empty() && (iter + 1) % G->GetNodes() == 0) {
472          IterLV.Add(TIntFltPr(iter, Likelihood(false)));
473        }
474      }
475      for (int k = 0; k < Attrs; k++) {
476        TFltV GradWV(NumComs);
477        GradientForWK(GradWV, k);
478        if (TLinAlg::Norm2(GradWV) < 1e-4) { continue; }
479        double LearnRate = GetStepSizeByLineSearchForWK(k, GradWV, GradWV, StepAlpha, StepBeta);
480        if (LearnRate == 0.0) { continue; }
481        for (int c = 0; c < GradWV.Len(); c++){
482          W[k][c] += LearnRate * GradWV[c];
483          if (W[k][c] < MinValW) { W[k][c] = MinValW; }
484          if (W[k][c] > MaxValW) { W[k][c] = MaxValW; }
485        }
486      }
487      printf("\r%d iterations (%f) [%lu sec]", iter, CurL, time(NULL) - InitTime);
488      fflush(stdout);
489      if (iter - PrevIter >= 2 * G->GetNodes() && iter > 10000) {
490        PrevIter = iter;
491        CurL = Likelihood();
492        if (PrevL > TFlt::Mn && ! PlotNm.Empty()) {
493          printf("\r%d iterations, Likelihood: %f, Diff: %f", iter, CurL,  CurL - PrevL);
494        }
495        fflush(stdout);
496        if (CurL - PrevL <= Thres * fabs(PrevL)) { break; }
497        else { PrevL = CurL; }
498      }
499    }
500    printf("\n");
501    printf("MLE for Lambda completed with %d iterations(%s)\n", iter, ExeTm.GetTmStr());
502    if (! PlotNm.Empty()) {
503      TGnuPlot::PlotValV(IterLV, PlotNm + ".likelihood_Q");
504    }
505    return iter;
506  }
507  int TCesna::MLEGradAscentParallel(const double& Thres, const int& MaxIter, const int ChunkNum, const int ChunkSize, const TStr PlotNm, const double StepAlpha, const double StepBeta) {
508    time_t InitTime = time(NULL);
509    uint64 StartTm = TSecTm::GetCurTm().GetAbsSecs();
510    TExeTm ExeTm, CheckTm;
511    double PrevL = Likelihood(true);
512    TIntFltPrV IterLV;
513    int PrevIter = 0;
514    int iter = 0;
515    TIntV NIdxV(F.Len(), 0);
516    for (int i = 0; i < F.Len(); i++) { NIdxV.Add(i); }
517    TIntV NIDOPTV(F.Len()); 
518    NIDOPTV.PutAll(0);
519    TVec<TIntFltH> NewF(ChunkNum * ChunkSize);
520    TIntV NewNIDV(ChunkNum * ChunkSize);
521    for (iter = 0; iter < MaxIter; iter++) {
522      NIdxV.Clr(false);
523      for (int i = 0; i < F.Len(); i++) { 
524        if (NIDOPTV[i] == 0) {  NIdxV.Add(i); }
525      }
526      IAssert (NIdxV.Len() <= F.Len());
527      NIdxV.Shuffle(Rnd);
528  #pragma omp parallel for schedule(static, 1)
529      for (int TIdx = 0; TIdx < ChunkNum; TIdx++) {
530        TIntFltH GradV;
531        for (int ui = TIdx * ChunkSize; ui < (TIdx + 1) * ChunkSize; ui++) {
532          NewNIDV[ui] = -1;
533          if (ui >= NIdxV.Len()) { continue; }
534          int u = NIdxV[ui]; 
535          TUNGraph::TNodeI UI = G->GetNI(u);
536          TIntSet CIDSet(5 * UI.GetDeg());
537          TIntFltH CurFU = F[u];
538          for (int e = 0; e < UI.GetDeg(); e++) {
539            if (HOVIDSV[u].IsKey(UI.GetNbrNId(e))) { continue; }
540            TIntFltH& NbhCIDH = F[UI.GetNbrNId(e)];
541            for (TIntFltH::TIter CI = NbhCIDH.BegI(); CI < NbhCIDH.EndI(); CI++) {
542              CIDSet.AddKey(CI.GetKey());
543            }
544          }
545          if (CIDSet.Empty()) { 
546            CurFU.Clr();
547          }
548          else {
549            for (TIntFltH::TIter CI = CurFU.BegI(); CI < CurFU.EndI(); CI++) { 
550              if (! CIDSet.IsKey(CI.GetKey())) {
551                CurFU.DelIfKey(CI.GetKey());
552              }
553            }
554            GradientForRow(u, GradV, CIDSet);
555            if (Norm2(GradV) < 1e-4) { NIDOPTV[u] = 1; continue; }
556            double LearnRate = GetStepSizeByLineSearch(u, GradV, GradV, StepAlpha, StepBeta);
557            if (LearnRate == 0.0) { NewNIDV[ui] = -2; continue; }
558            for (int ci = 0; ci < GradV.Len(); ci++) {
559              int CID = GradV.GetKey(ci);
560              double Change = LearnRate * GradV.GetDat(CID);
561              double NewFuc = CurFU.IsKey(CID)? CurFU.GetDat(CID) + Change : Change;
562              if (NewFuc <= 0.0) {
563                CurFU.DelIfKey(CID);
564              } else {
565                CurFU.AddDat(CID) = NewFuc;
566              }
567            }
568            CurFU.Defrag();
569          }
570          NewF[ui] = CurFU;
571          NewNIDV[ui] = u;
572        }
573      }
574      int NumNoChangeGrad = 0;
575      int NumNoChangeStepSize = 0;
576      for (int ui = 0; ui < NewNIDV.Len(); ui++) {
577        int NewNID = NewNIDV[ui];
578        if (NewNID == -1) { NumNoChangeGrad++; continue; }
579        if (NewNID == -2) { NumNoChangeStepSize++; continue; }
580        for (TIntFltH::TIter CI = F[NewNID].BegI(); CI < F[NewNID].EndI(); CI++) {
581          SumFV[CI.GetKey()] -= CI.GetDat();
582        }
583      }
584  #pragma omp parallel for
585      for (int ui = 0; ui < NewNIDV.Len(); ui++) {
586        int NewNID = NewNIDV[ui];
587        if (NewNID < 0) { continue; }
588        F[NewNID] = NewF[ui];
589      }
590      for (int ui = 0; ui < NewNIDV.Len(); ui++) {
591        int NewNID = NewNIDV[ui];
592        if (NewNID < 0) { continue; }
593        for (TIntFltH::TIter CI = F[NewNID].BegI(); CI < F[NewNID].EndI(); CI++) {
594          SumFV[CI.GetKey()] += CI.GetDat();
595        }
596      }
597      for (int ui = 0; ui < NewNIDV.Len(); ui++) {
598        int NewNID = NewNIDV[ui];
599        if (NewNID < 0) { continue; }
600        TUNGraph::TNodeI UI = G->GetNI(NewNID);
601        NIDOPTV[NewNID] = 0;
602        for (int e = 0; e < UI.GetDeg(); e++) {
603          NIDOPTV[UI.GetNbrNId(e)] = 0;
604        }
605      }
606      int OPTCnt = 0;
607      for (int i = 0; i < NIDOPTV.Len(); i++) { if (NIDOPTV[i] == 1) { OPTCnt++; } }
608      if (! PlotNm.Empty()) {
609        printf("\r%d iterations [%s] %s secs", iter * ChunkSize * ChunkNum, ExeTm.GetTmStr(), TUInt64::GetStr(TSecTm::GetCurTm().GetAbsSecs()-StartTm).CStr());
610        if (PrevL > TFlt::Mn) { printf(" (%f) %d g %d s %d OPT", PrevL, NumNoChangeGrad, NumNoChangeStepSize, OPTCnt); }
611        fflush(stdout);
612      }
613      if (iter == 0 || (iter - PrevIter) * ChunkSize * ChunkNum >= G->GetNodes()) {
614    #pragma omp parallel for
615        for (int k = 0; k < Attrs; k++) {
616          TFltV GradWV(NumComs);
617          GradientForWK(GradWV, k);
618          if (TLinAlg::Norm2(GradWV) < 1e-4) { continue; }
619          double LearnRate = GetStepSizeByLineSearchForWK(k, GradWV, GradWV, StepAlpha, StepBeta);
620          if (LearnRate == 0.0) { continue; }
621          for (int c = 0; c < GradWV.Len(); c++){
622            W[k][c] += LearnRate * GradWV[c];
623            if (W[k][c] < MinValW) { W[k][c] = MinValW; }
624            if (W[k][c] > MaxValW) { W[k][c] = MaxValW; }
625          }
626        }
627        PrevIter = iter;
628        double CurL = Likelihood(true);
629        IterLV.Add(TIntFltPr(iter * ChunkSize * ChunkNum, CurL));
630        printf("\r%d iterations, Likelihood: %f, Diff: %f [%lu secs]", iter, CurL,  CurL - PrevL, time(NULL) - InitTime);
631         fflush(stdout);
632        if (CurL - PrevL <= Thres * fabs(PrevL)) { 
633          break;
634        }
635        else {
636          PrevL = CurL;
637        }
638      }
639    }
640    if (! PlotNm.Empty()) {
641      printf("\nMLE completed with %d iterations(%s secs)\n", iter, TUInt64::GetStr(TSecTm::GetCurTm().GetAbsSecs()-StartTm).CStr());
642      TGnuPlot::PlotValV(IterLV, PlotNm + ".likelihood_Q");
643    } else {
644      printf("\rMLE completed with %d iterations(%lu secs)", iter, time(NULL) - InitTime);
645      fflush(stdout);
646    }
647    return iter;
648  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-bowclust.cpp</h3>
            <pre><code>1  void TBowDocPartClust::CalcEntropy(const PBowDocBs& BowDocBs){
2    int Docs=GetDocs();
3    int Cats=BowDocBs->GetCats();
4    TFltV CatWgtV(Cats);
5    double SumCatWgt=0;
6    for (int DIdN=0; DIdN<Docs; DIdN++){
7      int DId=DIdV[DIdN];
8      int DocCats=BowDocBs->GetDocCIds(DId);
9      for (int DocCIdN=0; DocCIdN<DocCats; DocCIdN++){
10        int CId=BowDocBs->GetDocCId(DId, DocCIdN);
11        double CatWgt=1/double(DocCats);
12        CatWgtV[CId]+=CatWgt; SumCatWgt+=CatWgt;
13      }
14    }
15    int NonZeroCatWgts=0;
16    if (SumCatWgt>0){
17      for (int CId=0; CId<Cats; CId++){
18        CatWgtV[CId]/=SumCatWgt;
19        if (double(CatWgtV[CId])!=0){NonZeroCatWgts++;}
20      }
21    }
22    CIdPrbKdV.Gen(NonZeroCatWgts, 0); Entropy=0;
23    for (int CId=0; CId<Cats; CId++){
24      double Prb=CatWgtV[CId];
25      if (Prb>0){
26        Entropy-=Prb*log(Prb);
27        CIdPrbKdV.Add(TIntFltKd(CId, Prb));
28      }
29    }
30  }
31  void TBowDocPartClust::GetTopWordStrWgtPrV(
32   const PBowDocBs& BowDocBs,
33   const int& TopWords, const double& TopWordsWgtPrc,
34   TStrFltPrV& WordStrWgtPrV) const {
35    int WIds=GetConceptWords();
36    TFltIntKdV WordWgtIdKdV(WIds); double WordWgtSum=0;
37    for (int WIdN=0; WIdN<WIds; WIdN++){
38      int WId; double WordWgt;
39      GetConceptSpV()->GetWIdWgt(WIdN, WId, WordWgt);
40      WordWgtSum+=WordWgt;
41      WordWgtIdKdV[WIdN]=TFltIntKd(WordWgt, WId);
42    }
43    WordWgtIdKdV.Sort(false);
44    double CutWordWgtSum=TopWordsWgtPrc*WordWgtSum;
45    WordStrWgtPrV.Clr();
46    {for (int WIdN=0; WIdN<WIds; WIdN++){
47      double WordWgt=WordWgtIdKdV[WIdN].Key;
48      int WId=WordWgtIdKdV[WIdN].Dat;
49      TStr WordStr=BowDocBs->GetWordStr(WId);
50      WordStrWgtPrV.Add(TStrFltPr(WordStr, WordWgt));
51      if ((TopWords!=-1)&&(1+WIdN>=TopWords)){break;}
52      CutWordWgtSum-=WordWgt; if (CutWordWgtSum<0){break;}
53    }}
54  }
55  double TBowDocPartClust::GetCatPrb(const int& CId) const {
56    int CatN;
57    if (CIdPrbKdV.IsIn(TIntFltKd(CId, 0), CatN)){
58      return CIdPrbKdV[CatN].Dat;
59    } else {
60      return 0;
61    }
62  }
63  int TBowDocPartClust::GetMxPrbCId() const {
64    int MxCId=-1; double MxPrb=0;
65    int CIdPrbs=GetCIdPrbs();
66    for (int CIdPrbN=0; CIdPrbN<CIdPrbs; CIdPrbN++){
67      int CId; double Prb; GetCIdPrb(CIdPrbN, CId, Prb);
68      if ((CIdPrbN==0)||(Prb>MxPrb)){MxCId=CId; MxPrb=Prb;}
69    }
70    return MxCId;
71  }
72  void TBowDocPart::GetTopClustSimV(
73   const double& ClustSimSumPrc, TFltIntIntTrV& ClustSimN1N2TrV) const {
74    ClustSimN1N2TrV.Clr();
75    int Clusts=GetClusts();
76    double ClustSimSum=0;
77    for (int ClustN1=0; ClustN1<Clusts; ClustN1++){
78      for (int ClustN2=ClustN1+1; ClustN2<Clusts; ClustN2++){
79        double ClustSim=GetClustSim(ClustN1, ClustN2);
80        ClustSimN1N2TrV.Add(TFltIntIntTr(ClustSim, ClustN1, ClustN2));
81        ClustSimSum+=ClustSim;
82      }
83    }
84    ClustSimN1N2TrV.Sort(false);
85    double CutClustSimSum=(1-ClustSimSumPrc)*ClustSimSum;
86    while (!ClustSimN1N2TrV.Empty()){
87      CutClustSimSum-=ClustSimN1N2TrV.Last().Val1;
88      if (CutClustSimSum<=0){
89        break;
90      } else {
91        ClustSimN1N2TrV.DelLast();
92      }
93    }
94  }
95  int TBowDocPart::GetDocs() const {
96    int Docs=0;
97    int Clusts=GetClusts();
98    for (int ClustN=0; ClustN<Clusts; ClustN++){
99      Docs+=GetClust(ClustN)->GetDocs();}
100    return Docs;
101  }
102  void TBowDocPart::GetDIdV(TIntV& DIdV) const {
103    DIdV.Gen(GetDocs(), 0);
104    int Clusts=GetClusts();
105    for (int ClustN=0; ClustN<Clusts; ClustN++){
106      TIntV DIdV; GetClust(ClustN)->GetDIdV(DIdV);
107      DIdV.AddV(DIdV);
108    }
109  }
110  int TBowDocPart::GetBestClust(const PBowSpV& SpV, const PBowSim& BowSim) const {
111    int BestClustN=-1; double BestSim=0;
112    int Clusts=GetClusts(); IAssert(Clusts>0);
113    for (int ClustN=0; ClustN<Clusts; ClustN++){
114      PBowDocPartClust Clust=GetClust(ClustN);
115      IAssert(Clust->IsConceptSpV());
116      double Sim=BowSim->GetSim(SpV, Clust->GetConceptSpV());
117      if ((BestClustN==-1)||(Sim>BestSim)){
118        BestClustN=ClustN; BestSim=Sim;
119      }
120    }
121    return BestClustN;
122  }
123  int TBowDocPart::GetBestCId(const PBowSpV& SpV, const PBowSim& BowSim) const {
124    int BestClustN=GetBestClust(SpV, BowSim);
125    PBowDocPartClust BestClust=GetClust(BestClustN);
126    int BestCId=-1;
127    if (BestClust->IsSubPart()){
128      BestCId=BestClust->GetSubPart()->GetBestCId(SpV, BowSim);
129    } else {
130      BestCId=BestClust->GetMxPrbCId();
131    }
132    return BestCId;
133  }
134  void TBowDocPart::GetClustSimV(
135   const PBowSpV& SpV, const PBowSim& BowSim, TIntFltKdV& ClustSimV) const {
136    int Clusts=GetClusts(); IAssert(Clusts>0);
137    ClustSimV.Gen(Clusts, 0);
138    for (int ClustN=0; ClustN<Clusts; ClustN++){
139      PBowDocPartClust Clust=GetClust(ClustN);
140      IAssert(Clust->IsConceptSpV());
141      double Sim=BowSim->GetSim(SpV, Clust->GetConceptSpV());
142      ClustSimV.Add(TIntFltKd(ClustN, Sim));
143    }
144    IAssert(ClustSimV.Len() == Clusts);
145  }
146  void TBowDocPart::GetDefClustNmV(const TStr& ClustNmPfx, TStrV& ClustNmV) const {
147    for (int ClustN=0; ClustN<GetClusts(); ClustN++){
148      TStr ClustNm=ClustNmPfx+"_"+TInt::GetStr(ClustN);
149      ClustNmV.Add(ClustNm);
150      PBowDocPartClust Clust=GetClust(ClustN);
151      if (Clust->IsSubPart()){
152        PBowDocPart SubPart=Clust->GetSubPart();
153        SubPart->GetDefClustNmV(ClustNm, ClustNmV);
154      }
155    }
156  }
157  void TBowDocPart::GetDefClustNmV(TStrV& ClustNmV) const {
158    ClustNmV.Clr();
159    for (int ClustN=0; ClustN<GetClusts(); ClustN++){
160      TStr ClustNm=TStr("C")+TInt::GetStr(ClustN);
161      ClustNmV.Add(ClustNm);
162      PBowDocPartClust Clust=GetClust(ClustN);
163      if (Clust->IsSubPart()){
164        PBowDocPart SubPart=Clust->GetSubPart();
165        SubPart->GetDefClustNmV(ClustNm, ClustNmV);
166      }
167    }
168  }
169  void TBowDocPart::GetCfClustNmV(
170   const PBowSpV TestDocSpV, const PBowSim& BowSim, TStrV& ClustNmV) const {
171    int ClustN=GetBestClust(TestDocSpV, BowSim);
172    PBowDocPartClust Clust=GetClust(ClustN);
173    TStr ClustNm=ClustNmV.Last()+"_"+TInt::GetStr(ClustN);
174    ClustNmV.Add(ClustNm);
175    if (Clust->IsSubPart()){
176      PBowDocPart SubPart=Clust->GetSubPart();
177      SubPart->GetCfClustNmV(TestDocSpV, BowSim, ClustNmV);
178    }
179  }
180  void TBowDocPart::GetCfClustNmVV(
181   const PBowDocBs& BowDocBs, const TBowWordWgtType& WordWgtType,
182   const PBowSim& BowSim, const TIntV& TrainDIdV, const TIntV& TestDIdV,
183   TVec<TStrV>& ClustNmVV, TVec<TBowDocPartClustV>& ClustVV) const {
184    PBowDocWgtBs TrainDocWgtBs=
185     TBowDocWgtBs::New(BowDocBs, WordWgtType, 0, 0, TrainDIdV);
186    PBowDocWgtBs TestDocWgtBs=
187     TBowDocWgtBs::New(BowDocBs, WordWgtType, 0, 0, TestDIdV, TrainDIdV);
188    int TestDocs=TestDocWgtBs->GetDocs();
189    ClustNmVV.Clr(); ClustVV.Clr();
190    for (int TestDIdN=0; TestDIdN<TestDocs; TestDIdN++){
191      int TestDId=TestDIdV[TestDIdN];
192      PBowSpV TestDocSpV=TestDocWgtBs->GetSpV(TestDId);
193      TStrV ClustNmV;
194      int ClustN=GetBestClust(TestDocSpV, BowSim);
195      PBowDocPartClust Clust=GetClust(ClustN);
196      TStr ClustNm=TStr("C")+TInt::GetStr(ClustN);
197      ClustNmV.Add(ClustNm);
198      if (Clust->IsSubPart()){
199        PBowDocPart SubPart=Clust->GetSubPart();
200        SubPart->GetCfClustNmV(TestDocSpV, BowSim, ClustNmV);
201      }
202      ClustNmVV.Add(ClustNmV); ClustVV.Add(ClustV);
203    }
204  }
205  void TBowDocPart::SaveXmlCfClustNmVV(
206   const PBowDocBs& BowDocBs, const TBowWordWgtType& WordWgtType,
207   const PBowSim& BowSim, const TIntV& TrainDIdV, const TIntV& _TestDIdV,
208   const TStr& FNm){
209    TIntV TestDIdV;
210    if (_TestDIdV.Empty()){BowDocBs->GetAllDIdV(TestDIdV);}
211    else {TestDIdV=_TestDIdV;}
212    TVec<TStrV> CfClustNmVV; TVec<TBowDocPartClustV> CfClustVV;
213    GetCfClustNmVV(
214     BowDocBs, WordWgtType, BowSim, TrainDIdV, TestDIdV, CfClustNmVV, CfClustVV);
215    TFOut SOut(FNm); TFileId OutFId=SOut.GetFileId();
216    fprintf(OutFId, "<DocClusterCf>\n");
217    fprintf(OutFId, "<ClusterDefs>\n");
218    TStrV DefClustNmV; GetDefClustNmV(DefClustNmV);
219    for (int DefClustNmN=0; DefClustNmN<DefClustNmV.Len(); DefClustNmN++){
220      fprintf(OutFId, "<ClusterDef>%s</ClusterDef>\n", DefClustNmV[DefClustNmN].CStr());}
221    fprintf(OutFId, "</ClusterDefs>\n");
222    fprintf(OutFId, "<DocCfs>\n");
223    int TestDocs=TestDIdV.Len();
224    for (int TestDIdN=0; TestDIdN<TestDocs; TestDIdN++){
225      int TestDId=TestDIdV[TestDIdN];
226      TStr TestDocNm=BowDocBs->GetDocNm(TestDId);
227      fprintf(OutFId, "<DocCf Nm=\"%s\">", TestDocNm.CStr());
228      TStrV& CfClustNmV=CfClustNmVV[TestDIdN];
229      for (int CfClustNmN=0; CfClustNmN<CfClustNmV.Len(); CfClustNmN++){
230        fprintf(OutFId, "<ClusterCf>%s</ClusterCf>", CfClustNmV[CfClustNmN].CStr());
231      }
232      fprintf(OutFId, "</DocCf>\n");
233    }
234    fprintf(OutFId, "</DocCfs>\n");
235    fprintf(OutFId, "</DocClusterCf>\n");
236  }
237  void TBowDocPart::GetAreaPart(
238   const TFltRect& Rect, TClustRectPrV& ClustRectPrV, const bool& ShuffleP) const {
239    int Clusts=GetClusts(); int Docs=GetDocs();
240    if ((Clusts==0)||(Docs==0)){return;}
241    double PrevMxX=Rect.MnX; double PrevMxY=Rect.MnY;
242    TIntV ClustNV(Clusts, 0);
243    for (int ClustN=0; ClustN<Clusts; ClustN++){ClustNV.Add(ClustN);}
244    if (ShuffleP){TRnd Rnd; ClustNV.Shuffle(Rnd);}
245    for (int ClustN=0; ClustN<Clusts; ClustN++){
246      PBowDocPartClust Clust=GetClust(ClustNV[ClustN]);
247      int ClustDocs=Clust->GetDocs();
248      TFltRect SubRect;
249      if (Rect.GetXLen()>=Rect.GetYLen()){
250        SubRect.MnX=PrevMxX;
251        SubRect.MxX=PrevMxX=PrevMxX+(ClustDocs/double(Docs))*Rect.GetXLen();
252        SubRect.MnY=Rect.MnY;
253        SubRect.MxY=Rect.MxY;
254      } else {
255        SubRect.MnX=Rect.MnX;
256        SubRect.MxX=Rect.MxX;
257        SubRect.MnY=PrevMxY;
258        SubRect.MxY=PrevMxY=PrevMxY+(ClustDocs/double(Docs))*Rect.GetYLen();
259      }
260      ClustRectPrV.Add(TClustRectPr(Clust, SubRect));
261      if (Clust->IsSubPart()){
262        PBowDocPart SubPart=Clust->GetSubPart();
263        SubPart->GetAreaPart(SubRect, ClustRectPrV);
264      }
265    }
266  }
267  void TBowDocPart::GetClustAtXY(const double& X, const double Y,
268   const TClustRectPrV& ClustRectPrV, const bool& LeafPartP,
269   TBowDocPartClustV& ClustV){
270    ClustV.Clr();
271    for (int ClustRectPrN=0; ClustRectPrN<ClustRectPrV.Len(); ClustRectPrN++){
272      PBowDocPartClust Clust=ClustRectPrV[ClustRectPrN].Val1;
273      TFltRect Rect=ClustRectPrV[ClustRectPrN].Val2;
274      if (Rect.IsXYIn(X, Y)){
275        if (((LeafPartP)&&(!Clust->IsSubPart()))||(!LeafPartP)){
276          ClustV.Add(Clust);
277        }
278      }
279    }
280  }
281  void TBowDocPart::SavePartEntropyTxt(
282   const PSOut& SOut, const PBowDocBs& BowDocBs) const {
283    int Clusts=GetClusts();
284    SOut->PutStr("----------------------------\n");
285    SOut->PutStr("Inter Cluster Similarity\n");
286    for (int ClustN=0; ClustN<Clusts; ClustN++){
287      SOut->PutInt(ClustN, "\tC-%d");}
288    SOut->PutLn();
289    for (int ClustN1=0; ClustN1<Clusts; ClustN1++){
290      SOut->PutInt(ClustN1, "C-%d");
291      for (int ClustN2=0; ClustN2<Clusts; ClustN2++){
292        if (ClustN1>=ClustN2){
293          SOut->PutStr("\t.");
294        } else {
295          double Sim=GetClustSim(ClustN1, ClustN2);
296          SOut->PutFlt(Sim, "\t%.3f");
297        }
298      }
299      SOut->PutLn();
300    }
301    SOut->PutStr("----------------------------\n");
302    SOut->PutStr("Cluster Summaries\n");
303    {for (int ClustN=0; ClustN<Clusts; ClustN++){
304      PBowDocPartClust Clust=GetClust(ClustN);
305      SOut->PutInt(ClustN, "C-%d:");
306      SOut->PutFlt(Clust->GetEntropy(), " [Entropy %0.3f]");
307      SOut->PutFlt(Clust->GetMeanSim(), " [Mean Sim. %0.2f]");
308      SOut->PutInt(Clust->GetDocs(), " [%d Docs.]");
309      SOut->PutInt(Clust->GetConceptWords(), " [%d Words]\n");
310    }}
311    SOut->PutStr("----------------------------\n");
312    SOut->PutStr("Category/Cluster Probabilities\n");
313    SOut->PutStr(" ", "%20s");
314    {for (int ClustN=0; ClustN<Clusts; ClustN++){
315      SOut->PutInt(ClustN, "\tC-%d");
316    }}
317    SOut->PutLn();
318    for (int CId=0; CId<BowDocBs->GetCats(); CId++){
319      SOut->PutStr(BowDocBs->GetCatNm(CId), "%20s");
320      for (int ClustN=0; ClustN<Clusts; ClustN++){
321        PBowDocPartClust Clust=GetClust(ClustN);
322        SOut->PutStr("\t");
323        double CatPrb=Clust->GetCatPrb(CId);
324        if (CatPrb>0){
325          int MxPrbCId=Clust->GetMxPrbCId();
326          SOut->PutFlt(CatPrb, "%0.3f");
327          if (MxPrbCId==CId){SOut->PutStr("!");}
328        } else {SOut->PutStr(".");}
329      }
330      SOut->PutLn();
331    }
332  }
333  void TBowDocPart::SaveTxt(
334   const PSOut& SOut, const PBowDocBs& BowDocBs,
335   const bool& SaveWordsP, const int& TopWords, const double& TopWordsWgtPrc,
336   const bool& SaveDocsP, const TStr& PathStr) const {
337    SOut->PutStr("***********************************\n");
338    SOut->PutStr(PathStr, "Path: %s\n");
339    SOut->PutInt(GetClusts(), "Clusters: %d\n");
340    SOut->PutInt(GetDocs(), "Documents: %d\n");
341    SOut->PutFlt(GetQual(), "Quality: %g\n");
342    SOut->PutFlt(GetMeanSim(), "Mean Similarity: %.3f\n");
343    if (!GetNm().Empty()){
344      SOut->PutStr(GetNm(), "Name: \"%s\"\n");}
345    SOut->Flush();
346    for (int ClustN=0; ClustN<GetClusts(); ClustN++){
347      PBowDocPartClust Clust=GetClust(ClustN);
348      SOut->PutStr("===================================\n");
349      SOut->PutInt(ClustN, "Cluster-%d: ");
350      SOut->PutFlt(Clust->GetMeanSim(), " [Mean Sim. %0.3f]");
351      SOut->PutInt(Clust->GetDocs(), " [%d Docs.]");
352      SOut->PutInt(Clust->GetConceptWords(), " [%d Words]\n");
353      if (!Clust->GetNm().Empty()){
354        SOut->PutStr(Clust->GetNm(), "[Name: \"%s\"]\n");}
355      if ((SaveWordsP)&&(!BowDocBs.Empty())){
356        SOut->PutStr("---Words------------------------\n");
357        int WIds=Clust->GetConceptWords();
358        TFltIntKdV WordWgtIdKdV(WIds); double WordWgtSum=0;
359        for (int WIdN=0; WIdN<WIds; WIdN++){
360          int WId; double WordWgt;
361          Clust->GetConceptSpV()->GetWIdWgt(WIdN, WId, WordWgt);
362          WordWgtSum+=WordWgt;
363          WordWgtIdKdV[WIdN]=TFltIntKd(WordWgt, WId);
364        }
365        WordWgtIdKdV.Sort(false);
366        double WordWgtSumSF=0;
367        {for (int WIdN=0; WIdN<WIds; WIdN++){
368          if (TopWords==WIdN){break;}
369          if ((WordWgtSum>0)&&(WordWgtSumSF/WordWgtSum>TopWordsWgtPrc)){break;}
370          double WordWgt=WordWgtIdKdV[WIdN].Key;
371          WordWgtSumSF+=WordWgt;
372          int WId=WordWgtIdKdV[WIdN].Dat;
373          TStr WordStr=BowDocBs->GetWordStr(WId);
374          SOut->PutStr(WordStr, "'%s':");
375          SOut->PutFlt(WordWgt, "%.3f\n");
376        }}
377      }
378      SOut->Flush();
379      if (SaveDocsP){
380        SOut->PutStr("---Documents--------------------\n");
381        int Docs=Clust->GetDocs();
382        if (Clust->IsDCSimV()){
383          TFltIntPrV DCSimDIdPrV(Docs, 0);
384          for (int DIdN=0; DIdN<Docs; DIdN++){
385            DCSimDIdPrV.Add(TFltIntPr(Clust->GetDCSim(DIdN), Clust->GetDId(DIdN)));
386          }
387          DCSimDIdPrV.Sort(false);
388          {for (int DIdN=0; DIdN<Docs; DIdN++){
389            double DCSim=DCSimDIdPrV[DIdN].Val1;
390            int DId=DCSimDIdPrV[DIdN].Val2;
391            SOut->PutStr(BowDocBs->GetDocNm(DId), "'%s'");
392            SOut->PutFlt(DCSim, " : %g");
393            if (!BowDocBs->GetDocDescStr(DId).Empty()){
394              SOut->PutStr(BowDocBs->GetDocDescStr(DId), " [%s]");}
395            SOut->PutStr("\n");
396          }}
397        } else {
398          for (int DIdN=0; DIdN<Docs; DIdN++){
399            int DId=Clust->GetDId(DIdN);
400            SOut->PutStr(BowDocBs->GetDocNm(DId), "'%s'");
401            if (!BowDocBs->GetDocDescStr(DId).Empty()){
402              SOut->PutStr(BowDocBs->GetDocDescStr(DId), " [%s]");}
403            SOut->PutStr("\n");
404          }
405        }
406        if (Clust->IsDDSimVV()){
407          SOut->PutStr("---Intra-Document-Similarity----\n");
408          for (int DIdN1=0; DIdN1<Docs; DIdN1++){
409            int DId1=Clust->GetDId(DIdN1);
410            SOut->PutStr(BowDocBs->GetDocNm(DId1), "'%s': ");
411            for (int DIdN2=0; DIdN2<Docs; DIdN2++){
412              double DDSim=Clust->GetDDSim(DIdN1, DIdN2);
413              SOut->PutFlt(DDSim, " %.4f");
414            }
415            SOut->PutLn();
416          }
417        }
418      }
419    }
420    if (BowDocBs->GetCats()>0){
421      SavePartEntropyTxt(SOut, BowDocBs);}
422    {for (int ClustN=0; ClustN<GetClusts(); ClustN++){
423      PBowDocPart SubPart=GetClust(ClustN)->GetSubPart();
424      if (!SubPart.Empty()){
425        TStr NewPathStr=PathStr+"|"+TInt::GetStr(ClustN);
426        SubPart->SaveTxt(SOut, BowDocBs,
427         SaveWordsP, TopWords, TopWordsWgtPrc, SaveDocsP, NewPathStr);
428      }
429    }}
430    SOut->Flush();
431  }
432  void TBowDocPart::SaveXml(
433   const PSOut& SOut, const PBowDocBs& BowDocBs, const TStr& PathStr) const {
434    SOut->PutStr("<Partition");
435    SOut->PutStr(PathStr, " Path=\"%s\"");
436    SOut->PutInt(GetClusts(), " Clusts=\"%d\"");
437    SOut->PutInt(GetDocs(), " Documents=\"%d\"");
438    SOut->PutFlt(GetQual(), " Quality=\"%g\"");
439    SOut->PutFlt(GetMeanSim(), " MeanSimilarity=\"%g\"");
440    if (!GetNm().Empty()){
441      SOut->PutStr(GetNm(), " Name=\"%s\"");}
442    SOut->PutStr(">\n");
443    for (int ClustN=0; ClustN<GetClusts(); ClustN++){
444      PBowDocPartClust Clust=GetClust(ClustN);
445      SOut->PutStr("<Cluster");
446      SOut->PutInt(ClustN, " Id=\"%d\"");
447      SOut->PutFlt(Clust->GetQual(), " Quality=\"%g\"");
448      SOut->PutFlt(Clust->GetMeanSim(), " MeanSimilarity=\"%g\"");
449      SOut->PutFlt(Clust->GetEntropy(), " Entropy=\"%g\"");
450      if (!Clust->GetNm().Empty()){
451        SOut->PutStr(Clust->GetNm(), " Name=\"%s\"");}
452      SOut->PutStr(">\n");
453      if (BowDocBs->GetCats()>0){
454        int MxPrbCId=Clust->GetMxPrbCId();
455        SOut->PutStr("<ClassDistr");
456        SOut->PutInt(MxPrbCId, " BestId=\"%d\"");
457        SOut->PutStr(">");
458        for (int CId=0; CId<BowDocBs->GetCats(); CId++){
459          SOut->PutStr("<Class");
460          SOut->PutInt(CId, " Id=\"%d\"");
461          SOut->PutStr(BowDocBs->GetCatNm(CId), " Name=\"%s\"");
462          double CatPrb=Clust->GetCatPrb(CId);
463          SOut->PutFlt(CatPrb, " Prob=\"%g\"");
464          SOut->PutStr("/>");
465        }
466        SOut->PutStr("</ClassDistr>");
467      }
468      int Docs=Clust->GetDocs();
469      SOut->PutInt(Docs, "<Documents Count=\"%d\">\n");
470      for (int DIdN=0; DIdN<Docs; DIdN++){
471        int DId=Clust->GetDId(DIdN);
472        SOut->PutStr(BowDocBs->GetDocNm(DId), "<D Nm=\"%s\"");
473        SOut->PutInt(DId, " Id=\"%d\"");
474        if (!BowDocBs->GetDocDescStr(DId).Empty()){
475          SOut->PutStr(BowDocBs->GetDocDescStr(DId), " Desc=\"%s\"");}
476        SOut->PutStr("/>");
477      }
478      SOut->PutStr("</Documents>\n");
479      SOut->PutInt(Clust->GetConceptWords(), "<Words Count=\"%d\">\n");
480      if (!BowDocBs.Empty()){
481        int WIds=Clust->GetConceptWords();
482        TFltIntKdV WordWgtIdKdV(WIds);
483        for (int WIdN=0; WIdN<WIds; WIdN++){
484          int WId; double WordWgt;
485          Clust->GetConceptSpV()->GetWIdWgt(WIdN, WId, WordWgt);
486          WordWgtIdKdV[WIdN]=TFltIntKd(WordWgt, WId);
487        }
488        WordWgtIdKdV.Sort(false);
489        {for (int WIdN=0; WIdN<WIds; WIdN++){
490          double WordWgt=WordWgtIdKdV[WIdN].Key;
491          int WId=WordWgtIdKdV[WIdN].Dat;
492          SOut->PutStr(BowDocBs->GetWordStr(WId), "<W Nm=\"%s\" ");
493          SOut->PutInt(WId, "Id=\"%d\" ");
494          SOut->PutFlt(WordWgt, "Wgt=\"%g\"/>");
495        }}
496        SOut->PutLn();
497      }
498      SOut->PutStr("</Words>\n");
499      SOut->PutStr("</Cluster>\n");
500    }
501    {for (int ClustN=0; ClustN<GetClusts(); ClustN++){
502      PBowDocPart SubPart=GetClust(ClustN)->GetSubPart();
503      if (!SubPart.Empty()){
504        TStr NewPathStr=PathStr+"|"+TInt::GetStr(ClustN);
505        SubPart->SaveXml(SOut, BowDocBs, NewPathStr);
506      }
507    }}
508    SOut->Flush();
509    SOut->PutStr("</Partition>\n");
510  }
511  void TBowDocPart::SaveRdfClusts(const PSOut& SOut, const PBowDocBs& BowDocBs, 
512          TIntIntVH& DIdClustIdVH, const int& FatherId, int& ClustId) const {
513      for (int ClustN=0; ClustN<GetClusts(); ClustN++) {
514          PBowDocPartClust Clust=GetClust(ClustN);
515          TStr CptNm, KeyWdStr;
516          if (!Clust->GetNm().Empty()){
517              CptNm = Clust->GetNm(); }
518          if (Clust->IsConceptSpV()) {
519              KeyWdStr = Clust->GetConceptSpV()->GetStr(BowDocBs, 20); 
<span onclick='openModal()' class='match'>520              if (CptNm.Empty()) {
521                  CptNm = Clust->GetConceptSpV()->GetStr(BowDocBs, 5, 1, ", ", false); }
522          }
523          if (CptNm.Empty()) {
524              CptNm = TStr::Fmt("Clust%d", ClustId); }
</span>525          SOut->PutStrLn(TStr::Fmt("<ptop:Topic rdf:about=\"#TOP_%d\">", ClustId));
526          SOut->PutStrLn(TStr::Fmt("  <psys:description>%s</psys:description>", CptNm.CStr()));
527          if (FatherId != -1) {
528              SOut->PutStrLn(
529                  TStr::Fmt("  <ptop:subTopicOf rdf:resource=\"#TOP_%d\" />", FatherId));
530          }
531          if (!KeyWdStr.Empty()) {
532              SOut->PutStrLn(TStr::Fmt("  <jsikm:hasOntoGenClassProperties rdf:resource=\"#CLS_PROP_%d\" />", ClustId)); }
533          SOut->PutStrLn("</ptop:Topic>");
534          if (!KeyWdStr.Empty()) {
535              SOut->PutStrLn(TStr::Fmt("<jsikm:OntoGenClassProperties rdf:about=\"#CLS_PROP_%d\">", ClustId));
536              SOut->PutStrLn(TStr::Fmt("  <jsikm:hasCentroidKeywords>%s</jsikm:hasCentroidKeywords>", KeyWdStr.CStr()));
537              SOut->PutStrLn("</jsikm:OntoGenClassProperties>");
538          }
539          SOut->PutStrLn("");
540          int Docs=Clust->GetDocs();
541          for (int DIdN=0; DIdN<Docs; DIdN++){
542              int DId=Clust->GetDId(DIdN);
543              if (DIdClustIdVH.IsKey(DId)) {
544                  DIdClustIdVH.GetDat(DId).Add(ClustId);
545              } else {
546                  DIdClustIdVH.AddDat(DId, TIntV::GetV(ClustId));
547              }
548          }
549          PBowDocPart SubPart=GetClust(ClustN)->GetSubPart();
550          const int MyId = ClustId; ClustId++;
551          if (!SubPart.Empty()){
552              SubPart->SaveRdfClusts(SOut, BowDocBs, DIdClustIdVH, MyId, ClustId);
553          }
554      }
555      SOut->Flush();
556  }
557  void TBowDocPart::SaveRdf(const TStr& FNm, const PBowDocBs& BowDocBs) const {
558      PSOut SOut=TFOut::New(FNm);
559      SOut->PutStrLn("<?xml version='1.0' encoding='UTF-8'?>");
560      SOut->PutStrLn("");
561      SOut->PutStrLn("<!DOCTYPE rdf:RDF [");
562      SOut->PutStrLn("    <!ENTITY rdf  'http:&bsol;&bsol;www.w3.org/1999/02/22-rdf-syntax-ns#'>");
563      SOut->PutStrLn("    <!ENTITY rdfs 'http:&bsol;&bsol;www.w3.org/TR/1999/PR-rdf-schema-19990303#'>");
564      SOut->PutStrLn("    <!ENTITY owl  'http:&bsol;&bsol;www.w3.org/2002/07/owl#'>");
565      SOut->PutStrLn("    <!ENTITY ptop 'http:&bsol;&bsol;proton.semanticweb.org/2005/04/protont#'>");
566      SOut->PutStrLn("    <!ENTITY psys 'http:&bsol;&bsol;proton.semanticweb.org/2005/04/protons#'>");
567      SOut->PutStrLn("    <!ENTITY pupp  'http:&bsol;&bsol;proton.semanticweb.org/2005/04/protonu#'>");
568      SOut->PutStrLn("    <!ENTITY protonkm  'http:&bsol;&bsol;proton.semanticweb.org/2005/04/protonkm#'>");
569      SOut->PutStrLn("    <!ENTITY jsikm  'http:&bsol;&bsol;kt.ijs.si/blazf/jsikm#'>");
570      SOut->PutStrLn("]>");
571      SOut->PutStrLn("");
572      SOut->PutStrLn("<rdf:RDF");
573      SOut->PutStrLn("    xmlns:rdf=\"&rdf;\"");
574      SOut->PutStrLn("    xmlns:rdfs=\"&rdfs;\"");
575      SOut->PutStrLn("    xmlns:owl=\"&owl;\"");
576      SOut->PutStrLn("    xmlns:protonkm=\"&protonkm;\"");
577      SOut->PutStrLn("    xmlns:psys=\"&psys;\"");
578      SOut->PutStrLn("    xmlns:pupp=\"&pupp;\"");
579      SOut->PutStrLn("    xmlns:jsikm=\"&jsikm;\"");
580      SOut->PutStrLn("    xmlns=\"&jsikm;\"");
581      SOut->PutStrLn("    xmlns:ptop=\"&ptop;\"");
582      SOut->PutStrLn("    xml:base=\"&jsikm;\"");
583      SOut->PutStrLn(">");
584      SOut->PutStrLn("");
585      SOut->PutStrLn("<owl:Ontology rdf:about=\"\">");
586      SOut->PutStrLn("  <rdfs:comment>PROTON Topics (from Inspec Thesaurus) ordered by algorithm X</rdfs:comment>");
587      SOut->PutStrLn("  <owl:imports rdf:resource=\"http:&bsol;&bsol;proton.semanticweb.org/2005/04/protons\"/>");
588      SOut->PutStrLn("  <owl:imports rdf:resource=\"http:&bsol;&bsol;proton.semanticweb.org/2005/04/protont\"/>");
589      SOut->PutStrLn("  <owl:imports rdf:resource=\"http:&bsol;&bsol;proton.semanticweb.org/2005/04/protonu\"/>");
590      SOut->PutStrLn("  <owl:imports rdf:resource=\"http:&bsol;&bsol;proton.semanticweb.org/2005/04/protonkm\"/>");
591      SOut->PutStrLn("  <owl:imports rdf:resource=\"http:&bsol;&bsol;kt.ijs.si/blazf/jsikm\"/>");
592      SOut->PutStrLn("  <owl:versionInfo>\"0.1\"</owl:versionInfo>");
593      SOut->PutStrLn("</owl:Ontology>");
594      SOut->PutStrLn("");
595      TIntIntVH DIdClustIdVH; int ClustId = 0;
596      SaveRdfClusts(SOut, BowDocBs, DIdClustIdVH, -1, ClustId);  
597      TIntV AllDIdV; BowDocBs->GetAllDIdV(AllDIdV);
598      TStr BowFNm = TStr::PutFExt(FNm, "_docs.bow");
599      TStr ShortBowFNm = BowFNm.GetFMid() + BowFNm.GetFExt();
600      BowDocBs->SaveBin(BowFNm);
601      for (int DocN = 0; DocN < AllDIdV.Len(); DocN++) {
602          const int DId = AllDIdV[DocN];
603          SOut->PutStrLn(TStr::Fmt("<ptop:Document rdf:about=\"#DOC_%d\">", DId));
604          if (DIdClustIdVH.IsKey(DId)) {
605              const TIntV& DocCptV = DIdClustIdVH.GetDat(DId);
606              for (int CptN = 0; CptN < DocCptV.Len(); CptN++) {
607                  const int FthCptId = DocCptV[CptN];
608                  SOut->PutStrLn(TStr::Fmt("  <ptop:hasSubject rdf:resource=\"#TOP_%d\" />", FthCptId));
609              }
610          }
611          SOut->PutStrLn(TStr::Fmt("  <jsikm:hasOntoGenInstanceProperties rdf:resource=\"#INST_PROP_%d\" />", DId));
612          SOut->PutStrLn("</ptop:Topic>");
613          SOut->PutStrLn(TStr::Fmt("<jsikm:hasOntoGenInstanceProperties rdf:about=\"#INST_PROP_%d\">", DId));
614          SOut->PutStrLn(TStr::Fmt("  <jsikm:locationOfInstance>%s#%d</jsikm:locationOfInstance>", ShortBowFNm.CStr(), DId));
615          SOut->PutStrLn("</jsikm:OntoGenClassProperties>");
616          SOut->PutStrLn("");
617      }        
618      SOut->PutStrLn("</rdf:RDF>");
619      SOut->Flush();
620  }
621  const TStr TBowDocPart::BowDocPartFExt=".BowPart";
622  PBowSpV TBowClust::GetConceptSpV(
623   const PBowDocWgtBs& BowDocWgtBs, const PBowSim& BowSim, const TIntV& DIdV,
624   const double& CutWordWgtSumPrc, const TIntFltPrV& DocIdWgtPrV){
625    PBowSpV ConceptSpV;
626    if (DIdV.Empty()){
627      ConceptSpV=TBowSpV::New();
628    } else
629    if ((!BowSim.Empty())&&(BowSim->GetSimType()==bstMtx)){
630      int DIds=DIdV.Len(); int DIdGran=1;
631      int BestDId=DIdV[0]; double BestAvgSim=0;
632      for (int DIdN1=0; DIdN1<DIds; DIdN1+=DIdGran){
633        int DId1=DIdV[DIdN1];
634        double SumSim=0; int TestDIds=0;
635        for (int DIdN2=0; DIdN2<DIds; DIdN2+=DIdGran){
636          if (DIdN1==DIdN2){continue;}
637          int DId2=DIdV[DIdN2];
638          SumSim+=BowSim->GetSim(DId1, DId2); TestDIds++;
639        }
640        if (TestDIds>0){
641          double AvgSim=SumSim/TestDIds;
642          if (AvgSim>BestAvgSim){BestDId=DId1;}
643        }
644      }
645      ConceptSpV=BowDocWgtBs->GetSpV(BestDId);
646    } else {
647      int Words=BowDocWgtBs->GetWords();
648      TFltV WordWgtSumV(Words); double WordWgtSum=0;
649      int DIds=DIdV.Len();
650      TIntFltH DocIdToWgtH(DIds); 
651      for (int DIdN=0; DIdN<DocIdWgtPrV.Len(); DIdN++){
652        DocIdToWgtH.AddDat(DocIdWgtPrV[DIdN].Val1, DocIdWgtPrV[DIdN].Val2);
653      }
654      for (int DIdN=0; DIdN<DIds; DIdN++){
655        int DId=DIdV[DIdN];
656        TFlt DocWgt=1.0;
657        if (DocIdWgtPrV.Len()>0){
658          DocIdToWgtH.IsKeyGetDat(DId, DocWgt);}
659        PBowSpV SpV=BowDocWgtBs->GetSpV(DId);
660        int WIds=SpV->GetWIds();
661        for (int WIdN=0; WIdN<WIds; WIdN++){
662          int WId; double WordWgt; SpV->GetWIdWgt(WIdN, WId, WordWgt);
663          WordWgtSumV[WId]+=DocWgt.Val*WordWgt; WordWgtSum+=DocWgt.Val*WordWgt;
664        }
665      }
666      ConceptSpV=TBowSpV::New(-1, Words/10);
667      for (int WId=0; WId<Words; WId++){
668        if (double(WordWgtSumV[WId])>0){
669          double WordWgtMean=WordWgtSumV[WId]/DIds;
670          ConceptSpV->AddWIdWgt(WId, WordWgtMean);
671        }
672      }
673      if (CutWordWgtSumPrc<1.0){
674        ConceptSpV->CutLowWgtWords(CutWordWgtSumPrc);}
675      ConceptSpV->PutUnitNorm();
676      ConceptSpV->Trunc();
677    }
678    return ConceptSpV;
679  }
680  void TBowClust::GetConceptSpVV(const PBowSim& &bsol;*BowSim*/,
681   const TBowSpVV& SpVV1, const TBowSpVV& SpVV2, TBowSpVV& ConceptSpVV){
682    ConceptSpVV.Gen(SpVV1.Len()+SpVV2.Len(), 0);
683    ConceptSpVV.AddV(SpVV1);
684    ConceptSpVV.AddV(SpVV2);
685  }
686  double TBowClust::GetClustQual(
687   const PBowDocWgtBs& BowDocWgtBs,
688   const TIntV& DIdV, const PBowSpV& ConceptSpV, const PBowSim& BowSim){
689    double Qual=0;
690    int DIds=DIdV.Len();
691    for (int DIdN=0; DIdN<DIds; DIdN++){
692      int DId=DIdV[DIdN];
693      Qual+=BowSim->GetSim(ConceptSpV, BowDocWgtBs->GetSpV(DId));
694    }
695    return Qual;
696  }
697  void TBowClust::GetPartQual(
698   const PBowDocWgtBs& BowDocWgtBs,
699   const TVec<TIntV>& DIdVV, const TBowSpVV& ConceptSpVV,
700   const PBowSim& BowSim, double& PartQual, TFltV& ClustQualV){
701    int Clusts=DIdVV.Len();
702    PartQual=0;
703    ClustQualV.Gen(Clusts);
704    for (int ClustN=0; ClustN<Clusts; ClustN++){
705      double ClustQual=
706       GetClustQual(BowDocWgtBs, DIdVV[ClustN], ConceptSpVV[ClustN], BowSim);
707      PartQual+=ClustQual;
708      ClustQualV[ClustN]=ClustQual;
709    }
710  }
711  PBowDocPart TBowClust::GetKMeansPartForDocWgtBs(
712   const PNotify& Notify,
713   const PBowDocWgtBs& BowDocWgtBs,
714   const PBowDocBs& BowDocBs, const PBowSim& BowSim, TRnd& Rnd,
715   const int& Clusts, const int& ClustTrials,
716   const double& ConvergEps, const int& MnDocsPerClust,
717   const TIntFltPrV& DocIdWgtPrV){
718    int Docs=BowDocWgtBs->GetDocs();
719    int Words=BowDocWgtBs->GetWords();
720    TNotify::OnNotify(Notify, ntInfo, "-----------------------");
721    TNotify::OnNotify(Notify, ntInfo, TInt::GetStr(Docs, "Docs: %d"));
722    TNotify::OnNotify(Notify, ntInfo, TInt::GetStr(Words, "Words: %d"));
723    PBowDocPart BestPart=TBowDocPart::New();
724    int ClustTrialN=0; int AddClustTrials=0;
725    while (ClustTrialN<ClustTrials+AddClustTrials){
726      ClustTrialN++;
727      TNotify::OnNotify(Notify, ntInfo,
728       TInt::GetStr(ClustTrialN, "Clustering Trial %d"));
729      TBowSpVV ConceptSpVV(Clusts);
730      double BestStartConceptMeanSim=0;
731      TBowSpVV BestStartConceptSpVV(Clusts);
732      for (int CVTrialN=0; CVTrialN<3; CVTrialN++){
733        for (int ClustN=0; ClustN<Clusts; ClustN++){
734          int DIdN=Rnd.GetUniDevInt(Docs);
735          int DId=BowDocWgtBs->GetDId(DIdN);
736          ConceptSpVV[ClustN]=BowDocWgtBs->GetSpV(DId);
737        }
738        PMom SimMom=TMom::New();
739        for (int ClustN1=0; ClustN1<Clusts; ClustN1++){
740          for (int ClustN2=ClustN1+1; ClustN2<Clusts; ClustN2++){
741            double Sim=BowSim->GetSim(ConceptSpVV[ClustN1], ConceptSpVV[ClustN2]);
742            SimMom->Add(Sim);
743          }
744        }
745        SimMom->Def();
746        double ConceptMeanSim=SimMom->GetMean();
747        if ((CVTrialN==0)||(ConceptMeanSim<BestStartConceptMeanSim)){
748          BestStartConceptMeanSim=ConceptMeanSim;
749          BestStartConceptSpVV=ConceptSpVV;
750        }
751      }
752      ConceptSpVV=BestStartConceptSpVV;
753      double PrevPartQual=0; 
754      double PartQual=0; 
755      TFltV ClustQualV; 
756      TVec<TIntV> DIdVV; 
757      int ClustIters=0; 
758      forever {
759        ClustIters++;
760        bool EmptyClustP;
761        do {
762          DIdVV.Gen(Clusts);
763          for (int DIdN=0; DIdN<Docs; DIdN++){
764            int DId=BowDocWgtBs->GetDId(DIdN);
765            PBowSpV DocSpV=BowDocWgtBs->GetSpV(DId);
766            TFltIntKdV SimClustNKdV(Clusts);
767            for (int ClustN=0; ClustN<Clusts; ClustN++){
768              double Sim=BowSim->GetSim(ConceptSpVV[ClustN], DocSpV);
769              SimClustNKdV[ClustN]=TFltIntKd(Sim, ClustN);
770            }
771            SimClustNKdV.Sort(false); 
772            int BestClustN=SimClustNKdV[0].Dat; 
773            if ((SimClustNKdV.Len()>0)&&(SimClustNKdV[0].Key==SimClustNKdV[1].Key)){
774              int BestClusts=1;
775              for (int ClustN=1; ClustN<Clusts; ClustN++){
776                if (SimClustNKdV[0].Key==SimClustNKdV[ClustN].Key){
777                  BestClusts++;
778                } else {break;}
779              }
780              BestClustN=Rnd.GetUniDevInt(BestClusts);
781            }
782            DIdVV[BestClustN].Add(DId);
783          }
784          EmptyClustP=false;
785          for (int ClustN=0; ClustN<Clusts; ClustN++){
786            if ((MnDocsPerClust!=-1)&&(DIdVV[ClustN].Len()<MnDocsPerClust)){
787              int DId=BowDocWgtBs->GetDId(Rnd.GetUniDevInt(Docs));
788              ConceptSpVV[ClustN]=BowDocWgtBs->GetSpV(DId);
789              PrevPartQual=0; PartQual=0; ClustIters=1;
790              EmptyClustP=true; break;
791            } else {
792              ConceptSpVV[ClustN]=
793               TBowClust::GetConceptSpV(BowDocWgtBs, BowSim, DIdVV[ClustN], 1, DocIdWgtPrV);
794            }
795          }
796        } while (EmptyClustP);
797        PrevPartQual=PartQual;
798        GetPartQual(BowDocWgtBs, DIdVV, ConceptSpVV, BowSim, PartQual, ClustQualV);
799        TStr MsgStr=
800         TInt::GetStr(ClustIters, "  Iteration %d:")+
801         TFlt::GetStr(PartQual, " [Quality: %g]");
802        TNotify::OnNotify(Notify, ntInfo, MsgStr);
803        if (fabs(PartQual-PrevPartQual)<ConvergEps){break;}
804      }
805      if ((ClustTrialN==1)||(PartQual>BestPart->GetQual())){
806        BestPart=TBowDocPart::New();
807        BestPart->PutQual(PartQual);
808        for (int ClustN=0; ClustN<Clusts; ClustN++){
809          PBowDocPartClust Clust=TBowDocPartClust::New(BowDocBs,
810           "", ClustQualV[ClustN], DIdVV[ClustN], ConceptSpVV[ClustN], NULL);
811          BestPart->AddClust(Clust);
812          {TIntV& DIdV=DIdVV[ClustN]; int Docs=DIdV.Len(); TFltV DCSimV(Docs, 0);
813          for (int DIdN=0; DIdN<Docs; DIdN++){
814            PBowSpV DocSpV=BowDocWgtBs->GetSpV(DIdV[DIdN]);
815            double Sim=BowSim->GetSim(ConceptSpVV[ClustN], DocSpV);
816            DCSimV.Add(Sim);
817          }
818          Clust->AddDCSimV(DCSimV);}
819          {TIntV& DIdV=DIdVV[ClustN]; int Docs=DIdV.Len();
820          if (Docs<=200){
821            TFltVV DDSimVV(Docs, Docs);
822            for (int DIdN1=0; DIdN1<Docs; DIdN1++){
823              PBowSpV DocSpV1=BowDocWgtBs->GetSpV(DIdV[DIdN1]);
824              for (int DIdN2=0; DIdN2<Docs; DIdN2++){
825                PBowSpV DocSpV2=BowDocWgtBs->GetSpV(DIdV[DIdN2]);
826                double Sim=BowSim->GetSim(DocSpV1, DocSpV2);
827                DDSimVV.At(DIdN1, DIdN2)=Sim;
828              }
829            }
830            Clust->AddDDSimVV(DDSimVV);
831          }}
832        }
833        TFltVV ClustSimVV(Clusts, Clusts);
834        for (int ClustN1=0; ClustN1<Clusts; ClustN1++){
835          ClustSimVV.At(ClustN1, ClustN1)=
836           BowSim->GetSim(ConceptSpVV[ClustN1], ConceptSpVV[ClustN1]);
837          for (int ClustN2=ClustN1+1; ClustN2<Clusts; ClustN2++){
838            double Sim=BowSim->GetSim(ConceptSpVV[ClustN1], ConceptSpVV[ClustN2]);
839            ClustSimVV.At(ClustN1, ClustN2)=Sim;
840            ClustSimVV.At(ClustN2, ClustN1)=Sim;
841          }
842        }
843        BestPart->PutClustSim(ClustSimVV);
844      }
845    }
846    TNotify::OnNotify(Notify, ntInfo,
847     TFlt::GetStr(BestPart->GetQual(), "Final Quality: %g"));
848    return BestPart;
849  }
850  PBowDocPart TBowClust::GetHPartForDocWgtBs(
851   const PNotify& Notify,
852   const PBowDocWgtBs& BowDocWgtBs,
853   const PBowDocBs& BowDocBs, const PBowSim& BowSim, TRnd& &bsol;*Rnd*/){
854    int Docs=BowDocWgtBs->GetDocs();
855    TFltVV SimVV(Docs, Docs); SimVV.PutAll(-1);
856    TVec<TBowSpVV> ClustSpVVV(Docs, 0);
857    TBowDocPartV PartV(Docs, 0);
858    for (int DIdN1=0; DIdN1<Docs; DIdN1++){
859      int DId1=BowDocWgtBs->GetDId(DIdN1);
860      TBowSpVV ClustSpVV(1); ClustSpVV[0]=BowDocWgtBs->GetSpV(DId1);
861      ClustSpVVV.Add(ClustSpVV);
862      TIntV ClustDIdV(1); ClustDIdV[0]=DId1;
863      PBowDocPartClust Clust=
864       TBowDocPartClust::New(BowDocBs, "", 0, ClustDIdV, NULL, NULL);
865      PBowDocPart Part=TBowDocPart::New();
866      Part->AddClust(Clust);
867      PartV.Add(Part);
868      for (int DIdN2=DIdN1+1; DIdN2<Docs; DIdN2++){
869        int DId2=BowDocWgtBs->GetDId(DIdN2);
870        double Sim=
871         BowSim->GetSim(BowDocWgtBs->GetSpV(DId1), BowDocWgtBs->GetSpV(DId2));
872        SimVV.At(DIdN1, DIdN2)=Sim;
873        SimVV.At(DIdN2, DIdN1)=Sim;
874      }
875    }
876    int Clusts=Docs;
877    while (Clusts>1){
878      int DIdN1; int DIdN2; SimVV.GetMxValXY(DIdN1, DIdN2);
879      SimVV.PutX(DIdN1, -1); SimVV.PutY(DIdN1, -1);
880      SimVV.PutX(DIdN2, -1); SimVV.PutY(DIdN2, -1);
881      TBowSpVV ConceptSpVV;
882      GetConceptSpVV(BowSim, ClustSpVVV[DIdN1], ClustSpVVV[DIdN2], ConceptSpVV);
883      ClustSpVVV[DIdN1]=ConceptSpVV;
884      ClustSpVVV[DIdN2].Clr();
885      for (int DIdN=0; DIdN<Docs; DIdN++){
886        if ((ClustSpVVV[DIdN].Len()>0)&&(DIdN!=DIdN1)){
887          double Sim=BowSim->GetSim(ConceptSpVV, ClustSpVVV[DIdN]);
888          SimVV.At(DIdN1, DIdN)=Sim;
889          SimVV.At(DIdN, DIdN1)=Sim;
890        }
891      }
892      PBowDocPart Part1=PartV[DIdN1];
893      PBowDocPart Part2=PartV[DIdN2];
894      TIntV PartDIdV1; Part1->GetDIdV(PartDIdV1);
895      TIntV PartDIdV2; Part2->GetDIdV(PartDIdV2);
896      PBowDocPartClust Clust1=TBowDocPartClust::New(BowDocBs, "", 0, PartDIdV1, NULL, Part1);
897      PBowDocPartClust Clust2=TBowDocPartClust::New(BowDocBs, "", 0, PartDIdV2, NULL, Part2);
898      PBowDocPart Part=TBowDocPart::New();
899      Part->AddClust(Clust1);
900      Part->AddClust(Clust2);
901      PartV[DIdN1]=Part;
902      PartV[DIdN2]=NULL;
903      Clusts--;
904      TNotify::OnStatus(Notify, TInt::GetStr(Clusts, "Clusts: %4d\r"));
905    }
906    return PartV[0];
907  }
908  PBowDocPart TBowClust::GetKMeansPart(
909   const PNotify& Notify,
910   const PBowDocBs& BowDocBs, const PBowSim& BowSim, TRnd& Rnd,
911   const int& Clusts, const int& ClustTrials,
912   const double& ConvergEps, const int& MnDocsPerClust,
913   const TBowWordWgtType& WordWgtType, const double& CutWordWgtSumPrc,
914   const int& MnWordFq, const TIntV& _DIdV){
915    TIntV DIdV;
916    if (_DIdV.Empty()){BowDocBs->GetAllDIdV(DIdV);} else {DIdV=_DIdV;}
917    PBowDocWgtBs BowDocWgtBs=
918     TBowDocWgtBs::New(BowDocBs, WordWgtType, CutWordWgtSumPrc, MnWordFq, DIdV);
919    PBowDocPart BowDocPart=TBowClust::GetKMeansPartForDocWgtBs(
920     Notify, BowDocWgtBs, BowDocBs, BowSim,
921     Rnd, Clusts, ClustTrials, ConvergEps, MnDocsPerClust);
922    return BowDocPart;
923  }
924  PBowDocPart TBowClust::GetHKMeansPart(
925   const PNotify& Notify,
926   const PBowDocBs& BowDocBs, const PBowSim& BowSim, TRnd& Rnd,
927   const int& MxDocsPerLeafClust, const int& ClustTrials,
928   const double& ConvergEps, const int& MnDocsPerClust,
929   const TBowWordWgtType& WordWgtType, const double& CutWordWgtSumPrc,
930   const int& MnWordFq, const TIntV& _DIdV,
931   const bool& PropBowDocWgtBsP, const PBowDocWgtBs& _BowDocWgtBs){
932    TIntV DIdV;
933    if (_DIdV.Empty()){BowDocBs->GetAllDIdV(DIdV);} else {DIdV=_DIdV;}
934    PBowDocWgtBs BowDocWgtBs;
935    if ((PropBowDocWgtBsP)||(_BowDocWgtBs.Empty())){
936     BowDocWgtBs=TBowDocWgtBs::New(BowDocBs, WordWgtType, CutWordWgtSumPrc, MnWordFq, DIdV);
937    } else {
938      BowDocWgtBs=_BowDocWgtBs;
939    }
940    int BowDocWgtBsDocs=BowDocWgtBs->GetDocs();
941    PBowDocPart DocPart=TBowClust::GetKMeansPartForDocWgtBs(
942     Notify, BowDocWgtBs, BowDocBs, BowSim,
943     Rnd, 2, ClustTrials, ConvergEps, MnDocsPerClust);
944    if (!PropBowDocWgtBsP){
945      BowDocWgtBs=NULL;}
946    for (int ClustN=0; ClustN<DocPart->GetClusts(); ClustN++){
947      PBowDocPartClust Clust=DocPart->GetClust(ClustN);
948      int ClustDocs=Clust->GetDocs();
949      if ((ClustDocs>MxDocsPerLeafClust)||(ClustDocs==BowDocWgtBsDocs)){
950        TIntV ClustDIdV; Clust->GetDIdV(ClustDIdV);
951        PBowDocPart SubDocPart=GetHKMeansPart(Notify,
952         BowDocBs, BowSim, Rnd, MxDocsPerLeafClust, ClustTrials, ConvergEps,
953         MnDocsPerClust, WordWgtType, CutWordWgtSumPrc, MnWordFq, ClustDIdV,
954         PropBowDocWgtBsP, BowDocWgtBs);
955        Clust->PutSubPart(SubDocPart);
956      }
957    }
958    return DocPart;
959  }
960  PBowDocPart TBowClust::GetHPart(
961   const PNotify& Notify,
962   const PBowDocBs& BowDocBs, const PBowSim& BowSim, TRnd& Rnd,
963   const TBowWordWgtType& WordWgtType, const double& CutWordWgtSumPrc,
964   const int& MnWordFq, const TIntV& DIdV){
965    PBowDocWgtBs BowDocWgtBs=
966     TBowDocWgtBs::New(BowDocBs, WordWgtType, CutWordWgtSumPrc, MnWordFq, DIdV);
967    PBowDocPart BowDocPart=
968     GetHPartForDocWgtBs(Notify, BowDocWgtBs, BowDocBs, BowSim, Rnd);
969    return BowDocPart;
970  }
971  double TBowClust::GetNNbrCfAcc(
972   const PNotify& Notify,
973   const PBowDocBs& BowDocBs, const PBowSim& BowSim,
974   const TBowWordWgtType& WordWgtType, const int& KNbrs,
975   const TIntV& TrainDIdV, const TIntV& TestDIdV){
976    PBowDocWgtBs TrainDocWgtBs=
977     TBowDocWgtBs::New(BowDocBs, WordWgtType, 0, 0, TrainDIdV);
978    PBowDocWgtBs TestDocWgtBs=
979     TBowDocWgtBs::New(BowDocBs, WordWgtType, 0, 0, TestDIdV, TrainDIdV);
980    int TrainDocs=TrainDocWgtBs->GetDocs();
981    int TestDocs=TestDocWgtBs->GetDocs();
982    int AllCfs=0; int CorrectCfs=0;
983    for (int TestDIdN=0; TestDIdN<TestDocs; TestDIdN++){
984      int TestDId=TestDIdV[TestDIdN];
985      PBowSpV TestDocSpV=TestDocWgtBs->GetSpV(TestDId);
986      TFltIntKdV SimDIdKdV(TrainDocs, 0);
987      for (int TrainDIdN=0; TrainDIdN<TrainDocs; TrainDIdN++){
988        int TrainDId=TrainDIdV[TrainDIdN];
989        PBowSpV TrainDocSpV=TrainDocWgtBs->GetSpV(TrainDId);
990        double Sim=BowSim->GetSim(TestDocSpV, TrainDocSpV);
991        SimDIdKdV.Add(TFltIntKd(Sim, TrainDId));
992      }
993      SimDIdKdV.Sort(false);
994      int Cats=BowDocBs->GetCats();
995      TFltV CatWgtV(Cats);
996      double SumCatWgt=0;
997      int NrKNbrs=TInt::GetMn(KNbrs, SimDIdKdV.Len());
998      for (int KNbrN=0; KNbrN<NrKNbrs; KNbrN++){
999        int DId=SimDIdKdV[KNbrN].Dat;
1000        int DocCats=BowDocBs->GetDocCIds(DId);
1001        for (int DocCIdN=0; DocCIdN<DocCats; DocCIdN++){
1002          int CId=BowDocBs->GetDocCId(DId, DocCIdN);
1003          double CatWgt=1/double(DocCats);
1004          CatWgtV[CId]+=CatWgt; SumCatWgt+=CatWgt;
1005        }
1006      }
1007      if (SumCatWgt>0){
1008        for (int CId=0; CId<Cats; CId++){
1009          CatWgtV[CId]=CatWgtV[CId]/SumCatWgt;
1010        }
1011      }
1012      int BestCId=CatWgtV.GetMxValN();
1013      if (BowDocBs->IsCatInDoc(TestDId, BestCId)){
1014        printf("+"); CorrectCfs++;} else {printf("-");}
1015      AllCfs++;
1016    }
1017    double CfAcc=double(CorrectCfs)/AllCfs;
1018    TStr MsgStr=TStr("NNbr:")+TInt::GetStr(CorrectCfs)+"/"+
1019     TInt::GetStr(AllCfs)+"="+TFlt::GetStr(CfAcc, "%.3f");
1020    TNotify::OnNotify(Notify, ntInfo, MsgStr);
1021    return CfAcc;
1022  }
1023  double TBowClust::GetClustCfAcc(
1024   const PNotify& Notify,
1025   const PBowDocBs& BowDocBs, const PBowDocPart& Part, const PBowSim& BowSim,
1026   const TBowWordWgtType& WordWgtType,
1027   const TIntV& TrainDIdV, const TIntV& TestDIdV){
1028    PBowDocWgtBs TrainDocWgtBs=
1029     TBowDocWgtBs::New(BowDocBs, WordWgtType, 0, 0, TrainDIdV);
1030    PBowDocWgtBs TestDocWgtBs=
1031     TBowDocWgtBs::New(BowDocBs, WordWgtType, 0, 0, TestDIdV, TrainDIdV);
1032    int TestDocs=TestDocWgtBs->GetDocs();
1033    int AllCfs=0; int CorrectCfs=0;
1034    for (int DIdN=0; DIdN<TestDocs; DIdN++){
1035      int DId=TestDIdV[DIdN];
1036      PBowSpV DocSpV=TestDocWgtBs->GetSpV(DId);
1037      int BestCId=Part->GetBestCId(DocSpV, BowSim);
1038      if (BowDocBs->IsCatInDoc(DId, BestCId)){printf("+"); CorrectCfs++;}
1039      else {printf("-");}
1040      AllCfs++;
1041    }
1042    double CfAcc=double(CorrectCfs)/AllCfs;
1043    TStr MsgStr=TStr("Clust:")+TInt::GetStr(CorrectCfs)+"/"+
1044     TInt::GetStr(AllCfs)+"="+TFlt::GetStr(CfAcc, "%.3f");
1045    TNotify::OnNotify(Notify, ntInfo, MsgStr);
1046    return CfAcc;
1047  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-agmattr.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-bowclust.cpp</div>
                </div>
                <div class="column column_space"><pre><code>426        if (NewVal > MaxVal) { NewVal = MaxVal; }
427        NewVarV.AddDat(CID, NewVal);
428      }
429      if (LikelihoodForRow(UID, NewVarV) < InitLikelihood + Alpha * StepSize * DotProduct(GradV, DeltaV)) {
430        StepSize *= Beta;
431      } else {
</pre></code></div>
                <div class="column column_space"><pre><code>520              if (CptNm.Empty()) {
521                  CptNm = Clust->GetConceptSpV()->GetStr(BowDocBs, 5, 1, ", ", false); }
522          }
523          if (CptNm.Empty()) {
524              CptNm = TStr::Fmt("Clust%d", ClustId); }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    