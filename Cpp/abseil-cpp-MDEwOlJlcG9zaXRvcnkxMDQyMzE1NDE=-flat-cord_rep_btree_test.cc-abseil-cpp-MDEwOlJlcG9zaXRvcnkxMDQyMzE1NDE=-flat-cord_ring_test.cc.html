
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 93, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cord_rep_btree_test.cc</h3>
            <pre><code>1  #include "absl/strings/internal/cord_rep_btree.h"
2  #include <cmath>
3  #include <deque>
4  #include <iostream>
5  #include <string>
6  #include <vector>
7  #include "gmock/gmock.h"
8  #include "gtest/gtest.h"
9  #include "absl/base/config.h"
10  #include "absl/base/internal/raw_logging.h"
11  #include "absl/cleanup/cleanup.h"
12  #include "absl/strings/internal/cord_data_edge.h"
13  #include "absl/strings/internal/cord_internal.h"
14  #include "absl/strings/internal/cord_rep_test_util.h"
15  #include "absl/strings/str_cat.h"
16  #include "absl/strings/string_view.h"
17  namespace absl {
18  ABSL_NAMESPACE_BEGIN
19  namespace cord_internal {
20  class CordRepBtreeTestPeer {
21   public:
22    static void SetEdge(CordRepBtree* node, size_t idx, CordRep* edge) {
23      node->edges_[idx] = edge;
24    }
25    static void AddEdge(CordRepBtree* node, CordRep* edge) {
26      node->edges_[node->fetch_add_end(1)] = edge;
27    }
28  };
29  namespace {
30  using ::absl::cordrep_testing::AutoUnref;
31  using ::absl::cordrep_testing::CordCollectRepsIf;
32  using ::absl::cordrep_testing::CordToString;
33  using ::absl::cordrep_testing::CordVisitReps;
34  using ::absl::cordrep_testing::CreateFlatsFromString;
35  using ::absl::cordrep_testing::CreateRandomString;
36  using ::absl::cordrep_testing::MakeExternal;
37  using ::absl::cordrep_testing::MakeFlat;
38  using ::absl::cordrep_testing::MakeSubstring;
39  using ::testing::_;
40  using ::testing::AllOf;
41  using ::testing::AnyOf;
42  using ::testing::Conditional;
43  using ::testing::ElementsAre;
44  using ::testing::ElementsAreArray;
45  using ::testing::Eq;
46  using ::testing::HasSubstr;
47  using ::testing::Le;
48  using ::testing::Ne;
49  using ::testing::Not;
50  using ::testing::SizeIs;
51  using ::testing::TypedEq;
52  MATCHER_P(EqFlatHolding, data, "Equals flat holding data") {
53    if (arg->tag < FLAT) {
54      *result_listener << "Expected FLAT, got tag " << static_cast<int>(arg->tag);
55      return false;
56    }
57    std::string actual = CordToString(arg);
58    if (actual != data) {
59      *result_listener << "Expected flat holding \"" << data
60                       << "\", got flat holding \"" << actual << "\"";
61      return false;
62    }
63    return true;
64  }
65  MATCHER_P(IsNode, height, absl::StrCat("Is a valid node of height ", height)) {
66    if (arg == nullptr) {
67      *result_listener << "Expected NODE, got nullptr";
68      return false;
69    }
70    if (arg->tag != BTREE) {
71      *result_listener << "Expected NODE, got " << static_cast<int>(arg->tag);
72      return false;
73    }
74    if (!CordRepBtree::IsValid(arg->btree())) {
75      CordRepBtree::Dump(arg->btree(), "Expected valid NODE, got:", false,
76                         *result_listener->stream());
77      return false;
78    }
79    if (arg->btree()->height() != height) {
80      *result_listener << "Expected NODE of height " << height << ", got "
81                       << arg->btree()->height();
82      return false;
83    }
84    return true;
85  }
86  MATCHER_P2(IsSubstring, start, length,
87             absl::StrCat("Is a substring(start = ", start, ", length = ", length,
88                          ")")) {
89    if (arg == nullptr) {
90      *result_listener << "Expected substring, got nullptr";
91      return false;
92    }
93    if (arg->tag != SUBSTRING) {
94      *result_listener << "Expected SUBSTRING, got "
95                       << static_cast<int>(arg->tag);
96      return false;
97    }
98    const CordRepSubstring* const substr = arg->substring();
99    if (substr->start != start || substr->length != length) {
100      *result_listener << "Expected substring(" << start << ", " << length
101                       << "), got substring(" << substr->start << ", "
102                       << substr->length << ")";
103      return false;
104    }
105    return true;
106  }
107  MATCHER_P2(EqExtractResult, tree, rep, "Equals ExtractResult") {
108    if (arg.tree != tree || arg.extracted != rep) {
109      *result_listener << "Expected {" << static_cast<const void*>(tree) << ", "
110                       << static_cast<const void*>(rep) << "}, got {" << arg.tree
111                       << ", " << arg.extracted << "}";
112      return false;
113    }
114    return true;
115  }
116  class DataConsumer {
117   public:
118    DataConsumer(absl::string_view data, bool forward)
119        : data_(data), forward_(forward) {}
120    absl::string_view Next(size_t n) {
121      assert(n <= data_.size() - consumed_);
122      consumed_ += n;
123      return data_.substr(forward_ ? consumed_ - n : data_.size() - consumed_, n);
124    }
125    absl::string_view Consumed() const {
126      return forward_ ? data_.substr(0, consumed_)
127                      : data_.substr(data_.size() - consumed_);
128    }
129   private:
130    absl::string_view data_;
131    size_t consumed_ = 0;
132    bool forward_;
133  };
134  CordRepBtree* BtreeAdd(CordRepBtree* node, bool append,
135                         absl::string_view data) {
136    return append ? CordRepBtree::Append(node, data)
137                  : CordRepBtree::Prepend(node, data);
138  }
139  void GetLeafEdges(const CordRepBtree* tree, std::vector<CordRep*>& edges) {
140    if (tree->height() == 0) {
141      for (CordRep* edge : tree->Edges()) {
142        edges.push_back(edge);
143      }
144    } else {
145      for (CordRep* edge : tree->Edges()) {
146        GetLeafEdges(edge->btree(), edges);
147      }
148    }
149  }
150  std::vector<CordRep*> GetLeafEdges(const CordRepBtree* tree) {
151    std::vector<CordRep*> edges;
152    GetLeafEdges(tree, edges);
153    return edges;
154  }
155  CordRepFlat* MakeHexFlat(size_t i) {
156    return MakeFlat(absl::StrCat("0x", absl::Hex(i, absl::kZeroPad4)));
157  }
158  CordRepBtree* MakeLeaf(size_t size = CordRepBtree::kMaxCapacity) {
159    assert(size <= CordRepBtree::kMaxCapacity);
160    CordRepBtree* leaf = CordRepBtree::Create(MakeHexFlat(0));
161    for (size_t i = 1; i < size; ++i) {
162      leaf = CordRepBtree::Append(leaf, MakeHexFlat(i));
163    }
164    return leaf;
165  }
166  CordRepBtree* MakeTree(size_t size, bool append = true) {
167    CordRepBtree* tree = CordRepBtree::Create(MakeHexFlat(0));
168    for (size_t i = 1; i < size; ++i) {
169      tree = append ? CordRepBtree::Append(tree, MakeHexFlat(i))
170                    : CordRepBtree::Prepend(tree, MakeHexFlat(i));
171    }
172    return tree;
173  }
174  CordRepBtree* CreateTree(absl::Span<CordRep* const> reps) {
175    auto it = reps.begin();
176    CordRepBtree* tree = CordRepBtree::Create(*it);
177    while (++it != reps.end()) tree = CordRepBtree::Append(tree, *it);
178    return tree;
179  }
180  CordRepBtree* CreateTree(absl::string_view data, size_t chunk_size) {
181    return CreateTree(CreateFlatsFromString(data, chunk_size));
182  }
183  CordRepBtree* CreateTreeReverse(absl::string_view data, size_t chunk_size) {
184    std::vector<CordRep*> flats = CreateFlatsFromString(data, chunk_size);
185    auto rit = flats.rbegin();
186    CordRepBtree* tree = CordRepBtree::Create(*rit);
187    while (++rit != flats.rend()) tree = CordRepBtree::Prepend(tree, *rit);
188    return tree;
189  }
190  class CordRepBtreeTest : public testing::TestWithParam<bool> {
191   public:
192    bool shared() const { return GetParam(); }
193    static std::string ToString(testing::TestParamInfo<bool> param) {
194      return param.param ? "Shared" : "Private";
195    }
196  };
197  INSTANTIATE_TEST_SUITE_P(WithParam, CordRepBtreeTest, testing::Bool(),
198                           CordRepBtreeTest::ToString);
199  class CordRepBtreeHeightTest : public testing::TestWithParam<int> {
200   public:
201    int height() const { return GetParam(); }
202    static std::string ToString(testing::TestParamInfo<int> param) {
203      return absl::StrCat(param.param);
204    }
205  };
206  INSTANTIATE_TEST_SUITE_P(WithHeights, CordRepBtreeHeightTest,
207                           testing::Range(0, CordRepBtree::kMaxHeight),
208                           CordRepBtreeHeightTest::ToString);
209  using TwoBools = testing::tuple<bool, bool>;
210  class CordRepBtreeDualTest : public testing::TestWithParam<TwoBools> {
211   public:
212    bool first_shared() const { return std::get<0>(GetParam()); }
213    bool second_shared() const { return std::get<1>(GetParam()); }
214    static std::string ToString(testing::TestParamInfo<TwoBools> param) {
215      if (std::get<0>(param.param)) {
216        return std::get<1>(param.param) ? "BothShared" : "FirstShared";
217      }
218      return std::get<1>(param.param) ? "SecondShared" : "Private";
219    }
220  };
221  INSTANTIATE_TEST_SUITE_P(WithParam, CordRepBtreeDualTest,
222                           testing::Combine(testing::Bool(), testing::Bool()),
223                           CordRepBtreeDualTest::ToString);
224  TEST(CordRepBtreeTest, SizeIsMultipleOf64) {
225    if (sizeof(size_t) == 8 && sizeof(void*) == 8) {
226      EXPECT_THAT(sizeof(CordRepBtree) % 64, Eq(0u))
227          << "Should be multiple of 64";
228    }
229  }
230  TEST(CordRepBtreeTest, NewDestroyEmptyTree) {
231    auto* tree = CordRepBtree::New();
232    EXPECT_THAT(tree->size(), Eq(0u));
233    EXPECT_THAT(tree->height(), Eq(0));
234    EXPECT_THAT(tree->Edges(), ElementsAre());
235    CordRepBtree::Destroy(tree);
236  }
237  TEST(CordRepBtreeTest, NewDestroyEmptyTreeAtHeight) {
238    auto* tree = CordRepBtree::New(3);
239    EXPECT_THAT(tree->size(), Eq(0u));
240    EXPECT_THAT(tree->height(), Eq(3));
241    EXPECT_THAT(tree->Edges(), ElementsAre());
242    CordRepBtree::Destroy(tree);
243  }
244  TEST(CordRepBtreeTest, Btree) {
245    CordRep* rep = CordRepBtree::New();
246    EXPECT_THAT(rep->btree(), Eq(rep));
247    EXPECT_THAT(static_cast<const CordRep*>(rep)->btree(), Eq(rep));
248    CordRep::Unref(rep);
249  #if defined(GTEST_HAS_DEATH_TEST) && !defined(NDEBUG)
250    rep = MakeFlat("Hello world");
251    EXPECT_DEATH(rep->btree(), ".*");
252    EXPECT_DEATH(static_cast<const CordRep*>(rep)->btree(), ".*");
253    CordRep::Unref(rep);
254  #endif
255  }
256  TEST(CordRepBtreeTest, EdgeData) {
257    CordRepFlat* flat = MakeFlat("Hello world");
258    CordRepExternal* external = MakeExternal("Hello external");
259    CordRep* substr1 = MakeSubstring(1, 6, CordRep::Ref(flat));
260    CordRep* substr2 = MakeSubstring(1, 6, CordRep::Ref(external));
261    CordRep* bad_substr = MakeSubstring(1, 2, CordRep::Ref(substr1));
262    EXPECT_TRUE(IsDataEdge(flat));
263    EXPECT_THAT(EdgeData(flat).data(), TypedEq<const void*>(flat->Data()));
264    EXPECT_THAT(EdgeData(flat), Eq("Hello world"));
265    EXPECT_TRUE(IsDataEdge(external));
266    EXPECT_THAT(EdgeData(external).data(), TypedEq<const void*>(external->base));
267    EXPECT_THAT(EdgeData(external), Eq("Hello external"));
268    EXPECT_TRUE(IsDataEdge(substr1));
269    EXPECT_THAT(EdgeData(substr1).data(), TypedEq<const void*>(flat->Data() + 1));
270    EXPECT_THAT(EdgeData(substr1), Eq("ello w"));
271    EXPECT_TRUE(IsDataEdge(substr2));
272    EXPECT_THAT(EdgeData(substr2).data(),
273                TypedEq<const void*>(external->base + 1));
274    EXPECT_THAT(EdgeData(substr2), Eq("ello e"));
275    EXPECT_FALSE(IsDataEdge(bad_substr));
276  #if defined(GTEST_HAS_DEATH_TEST) && !defined(NDEBUG)
277    EXPECT_DEATH(EdgeData(bad_substr), ".*");
278  #endif
279    CordRep::Unref(bad_substr);
280    CordRep::Unref(substr2);
281    CordRep::Unref(substr1);
282    CordRep::Unref(external);
283    CordRep::Unref(flat);
284  }
285  TEST(CordRepBtreeTest, CreateUnrefLeaf) {
286    auto* flat = MakeFlat("a");
287    auto* leaf = CordRepBtree::Create(flat);
288    EXPECT_THAT(leaf->size(), Eq(1u));
289    EXPECT_THAT(leaf->height(), Eq(0));
290    EXPECT_THAT(leaf->Edges(), ElementsAre(flat));
291    CordRepBtree::Unref(leaf);
292  }
293  TEST(CordRepBtreeTest, NewUnrefNode) {
294    auto* leaf = CordRepBtree::Create(MakeFlat("a"));
295    CordRepBtree* tree = CordRepBtree::New(leaf);
296    EXPECT_THAT(tree->size(), Eq(1u));
297    EXPECT_THAT(tree->height(), Eq(1));
298    EXPECT_THAT(tree->Edges(), ElementsAre(leaf));
299    CordRepBtree::Unref(tree);
300  }
301  TEST_P(CordRepBtreeTest, AppendToLeafToCapacity) {
302    AutoUnref refs;
303    std::vector<CordRep*> flats;
304    flats.push_back(MakeHexFlat(0));
305    auto* leaf = CordRepBtree::Create(flats.back());
306    for (size_t i = 1; i < CordRepBtree::kMaxCapacity; ++i) {
307      refs.RefIf(shared(), leaf);
308      flats.push_back(MakeHexFlat(i));
309      auto* result = CordRepBtree::Append(leaf, flats.back());
310      EXPECT_THAT(result->height(), Eq(0));
311      EXPECT_THAT(result, Conditional(shared(), Ne(leaf), Eq(leaf)));
312      EXPECT_THAT(result->Edges(), ElementsAreArray(flats));
313      leaf = result;
314    }
315    CordRep::Unref(leaf);
316  }
317  TEST_P(CordRepBtreeTest, PrependToLeafToCapacity) {
318    AutoUnref refs;
319    std::deque<CordRep*> flats;
320    flats.push_front(MakeHexFlat(0));
321    auto* leaf = CordRepBtree::Create(flats.front());
322    for (size_t i = 1; i < CordRepBtree::kMaxCapacity; ++i) {
323      refs.RefIf(shared(), leaf);
324      flats.push_front(MakeHexFlat(i));
325      auto* result = CordRepBtree::Prepend(leaf, flats.front());
326      EXPECT_THAT(result->height(), Eq(0));
327      EXPECT_THAT(result, Conditional(shared(), Ne(leaf), Eq(leaf)));
328      EXPECT_THAT(result->Edges(), ElementsAreArray(flats));
329      leaf = result;
330    }
331    CordRep::Unref(leaf);
332  }
333  TEST_P(CordRepBtreeTest, AppendPrependToLeafToCapacity) {
334    AutoUnref refs;
335    std::deque<CordRep*> flats;
336    flats.push_front(MakeHexFlat(0));
337    auto* leaf = CordRepBtree::Create(flats.front());
338    for (size_t i = 1; i < CordRepBtree::kMaxCapacity; ++i) {
339      refs.RefIf(shared(), leaf);
340      CordRepBtree* result;
341      if (i % 2 != 0) {
342        flats.push_front(MakeHexFlat(i));
343        result = CordRepBtree::Prepend(leaf, flats.front());
344      } else {
345        flats.push_back(MakeHexFlat(i));
346        result = CordRepBtree::Append(leaf, flats.back());
347      }
348      EXPECT_THAT(result->height(), Eq(0));
349      EXPECT_THAT(result, Conditional(shared(), Ne(leaf), Eq(leaf)));
350      EXPECT_THAT(result->Edges(), ElementsAreArray(flats));
351      leaf = result;
352    }
353    CordRep::Unref(leaf);
354  }
355  TEST_P(CordRepBtreeTest, AppendToLeafBeyondCapacity) {
356    AutoUnref refs;
357    auto* leaf = MakeLeaf();
358    refs.RefIf(shared(), leaf);
359    CordRep* flat = MakeFlat("abc");
360    auto* result = CordRepBtree::Append(leaf, flat);
361    ASSERT_THAT(result, IsNode(1));
362    EXPECT_THAT(result, Ne(leaf));
363    absl::Span<CordRep* const> edges = result->Edges();
364    ASSERT_THAT(edges, ElementsAre(leaf, IsNode(0)));
365    EXPECT_THAT(edges[1]->btree()->Edges(), ElementsAre(flat));
366    CordRep::Unref(result);
367  }
368  TEST_P(CordRepBtreeTest, PrependToLeafBeyondCapacity) {
369    AutoUnref refs;
370    auto* leaf = MakeLeaf();
371    refs.RefIf(shared(), leaf);
372    CordRep* flat = MakeFlat("abc");
373    auto* result = CordRepBtree::Prepend(leaf, flat);
374    ASSERT_THAT(result, IsNode(1));
375    EXPECT_THAT(result, Ne(leaf));
376    absl::Span<CordRep* const> edges = result->Edges();
377    ASSERT_THAT(edges, ElementsAre(IsNode(0), leaf));
378    EXPECT_THAT(edges[0]->btree()->Edges(), ElementsAre(flat));
379    CordRep::Unref(result);
380  }
381  TEST_P(CordRepBtreeTest, AppendToTreeOneDeep) {
382    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
383    AutoUnref refs;
384    std::vector<CordRep*> flats;
385    flats.push_back(MakeHexFlat(0));
386    CordRepBtree* tree = CordRepBtree::Create(flats.back());
387    for (size_t i = 1; i <= max_cap; ++i) {
388      flats.push_back(MakeHexFlat(i));
389      tree = CordRepBtree::Append(tree, flats.back());
390    }
391    ASSERT_THAT(tree, IsNode(1));
392    for (size_t i = max_cap + 1; i < max_cap * max_cap; ++i) {
393      refs.RefIf(shared(), tree);
394      refs.RefIf(i % 4 == 0, tree->Edges().back());
395      flats.push_back(MakeHexFlat(i));
396      CordRepBtree* result = CordRepBtree::Append(tree, flats.back());
397      ASSERT_THAT(result, IsNode(1));
398      ASSERT_THAT(result, Conditional(shared(), Ne(tree), Eq(tree)));
399      std::vector<CordRep*> edges = GetLeafEdges(result);
400      ASSERT_THAT(edges, ElementsAreArray(flats));
401      tree = result;
402    }
403    CordRep::Unref(tree);
404  }
405  TEST_P(CordRepBtreeTest, AppendToTreeTwoDeep) {
406    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
407    AutoUnref refs;
408    std::vector<CordRep*> flats;
409    flats.push_back(MakeHexFlat(0));
410    CordRepBtree* tree = CordRepBtree::Create(flats.back());
411    for (size_t i = 1; i <= max_cap * max_cap; ++i) {
412      flats.push_back(MakeHexFlat(i));
413      tree = CordRepBtree::Append(tree, flats.back());
414    }
415    ASSERT_THAT(tree, IsNode(2));
416    for (size_t i = max_cap * max_cap + 1; i < max_cap * max_cap * max_cap; ++i) {
417      refs.RefIf(shared(), tree);
418      refs.RefIf(i % 16 == 0, tree->Edges().back());
419      refs.RefIf(i % 4 == 0, tree->Edges().back()->btree()->Edges().back());
420      flats.push_back(MakeHexFlat(i));
421      CordRepBtree* result = CordRepBtree::Append(tree, flats.back());
422      ASSERT_THAT(result, IsNode(2));
423      ASSERT_THAT(result, Conditional(shared(), Ne(tree), Eq(tree)));
424      std::vector<CordRep*> edges = GetLeafEdges(result);
425      ASSERT_THAT(edges, ElementsAreArray(flats));
426      tree = result;
427    }
428    CordRep::Unref(tree);
429  }
430  TEST_P(CordRepBtreeTest, PrependToTreeOneDeep) {
431    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
432    AutoUnref refs;
433    std::deque<CordRep*> flats;
434    flats.push_back(MakeHexFlat(0));
435    CordRepBtree* tree = CordRepBtree::Create(flats.back());
436    for (size_t i = 1; i <= max_cap; ++i) {
437      flats.push_front(MakeHexFlat(i));
438      tree = CordRepBtree::Prepend(tree, flats.front());
439    }
440    ASSERT_THAT(tree, IsNode(1));
441    for (size_t i = max_cap + 1; i < max_cap * max_cap; ++i) {
442      refs.RefIf(shared(), tree);
443      refs.RefIf(i % 4 == 0, tree->Edges().back());
444      flats.push_front(MakeHexFlat(i));
445      CordRepBtree* result = CordRepBtree::Prepend(tree, flats.front());
446      ASSERT_THAT(result, IsNode(1));
447      ASSERT_THAT(result, Conditional(shared(), Ne(tree), Eq(tree)));
448      std::vector<CordRep*> edges = GetLeafEdges(result);
449      ASSERT_THAT(edges, ElementsAreArray(flats));
450      tree = result;
451    }
452    CordRep::Unref(tree);
453  }
454  TEST_P(CordRepBtreeTest, PrependToTreeTwoDeep) {
455    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
456    AutoUnref refs;
457    std::deque<CordRep*> flats;
458    flats.push_back(MakeHexFlat(0));
459    CordRepBtree* tree = CordRepBtree::Create(flats.back());
460    for (size_t i = 1; i <= max_cap * max_cap; ++i) {
461      flats.push_front(MakeHexFlat(i));
462      tree = CordRepBtree::Prepend(tree, flats.front());
463    }
464    ASSERT_THAT(tree, IsNode(2));
465    for (size_t i = max_cap * max_cap + 1; i < max_cap * max_cap * max_cap; ++i) {
466      refs.RefIf(shared(), tree);
467      refs.RefIf(i % 16 == 0, tree->Edges().back());
468      refs.RefIf(i % 4 == 0, tree->Edges().back()->btree()->Edges().back());
469      flats.push_front(MakeHexFlat(i));
470      CordRepBtree* result = CordRepBtree::Prepend(tree, flats.front());
471      ASSERT_THAT(result, IsNode(2));
472      ASSERT_THAT(result, Conditional(shared(), Ne(tree), Eq(tree)));
473      std::vector<CordRep*> edges = GetLeafEdges(result);
474      ASSERT_THAT(edges, ElementsAreArray(flats));
475      tree = result;
476    }
477    CordRep::Unref(tree);
478  }
479  TEST_P(CordRepBtreeDualTest, MergeLeafsNotExceedingCapacity) {
480    for (bool use_append : {false, true}) {
481      SCOPED_TRACE(use_append ? "Using Append" : "Using Prepend");
482      AutoUnref refs;
483      std::vector<CordRep*> flats;
484      CordRepBtree* left = MakeLeaf(3);
485      GetLeafEdges(left, flats);
486      refs.RefIf(first_shared(), left);
487      CordRepBtree* right = MakeLeaf(2);
488      GetLeafEdges(right, flats);
489      refs.RefIf(second_shared(), right);
490      CordRepBtree* tree = use_append ? CordRepBtree::Append(left, right)
491                                      : CordRepBtree::Prepend(right, left);
492      EXPECT_THAT(tree, IsNode(0));
493      EXPECT_THAT(tree->Edges(), ElementsAreArray(flats));
494      CordRepBtree::Unref(tree);
495    }
496  }
497  TEST_P(CordRepBtreeDualTest, MergeLeafsExceedingCapacity) {
498    for (bool use_append : {false, true}) {
499      SCOPED_TRACE(use_append ? "Using Append" : "Using Prepend");
500      AutoUnref refs;
501      CordRepBtree* left = MakeLeaf(CordRepBtree::kMaxCapacity - 2);
502      refs.RefIf(first_shared(), left);
503      CordRepBtree* right = MakeLeaf(CordRepBtree::kMaxCapacity - 1);
504      refs.RefIf(second_shared(), right);
505      CordRepBtree* tree = use_append ? CordRepBtree::Append(left, right)
506                                      : CordRepBtree::Prepend(right, left);
507      EXPECT_THAT(tree, IsNode(1));
508      EXPECT_THAT(tree->Edges(), ElementsAre(left, right));
509      CordRepBtree::Unref(tree);
510    }
511  }
512  TEST_P(CordRepBtreeDualTest, MergeEqualHeightTrees) {
513    for (bool use_append : {false, true}) {
514      SCOPED_TRACE(use_append ? "Using Append" : "Using Prepend");
515      AutoUnref refs;
516      std::vector<CordRep*> flats;
517      CordRepBtree* left = MakeTree(CordRepBtree::kMaxCapacity * 3);
518      GetLeafEdges(left, flats);
519      refs.RefIf(first_shared(), left);
520      CordRepBtree* right = MakeTree(CordRepBtree::kMaxCapacity * 2);
521      GetLeafEdges(right, flats);
522      refs.RefIf(second_shared(), right);
523      CordRepBtree* tree = use_append ? CordRepBtree::Append(left, right)
524                                      : CordRepBtree::Prepend(right, left);
525      EXPECT_THAT(tree, IsNode(1));
526      EXPECT_THAT(tree->Edges(), SizeIs(5u));
527      EXPECT_THAT(GetLeafEdges(tree), ElementsAreArray(flats));
528      CordRepBtree::Unref(tree);
529    }
530  }
531  TEST_P(CordRepBtreeDualTest, MergeLeafWithTreeNotExceedingLeafCapacity) {
532    for (bool use_append : {false, true}) {
533      SCOPED_TRACE(use_append ? "Using Append" : "Using Prepend");
534      AutoUnref refs;
535      std::vector<CordRep*> flats;
536      CordRepBtree* left = MakeTree(CordRepBtree::kMaxCapacity * 2 + 2);
537      GetLeafEdges(left, flats);
538      refs.RefIf(first_shared(), left);
539      CordRepBtree* right = MakeTree(3);
540      GetLeafEdges(right, flats);
541      refs.RefIf(second_shared(), right);
542      CordRepBtree* tree = use_append ? CordRepBtree::Append(left, right)
543                                      : CordRepBtree::Prepend(right, left);
544      EXPECT_THAT(tree, IsNode(1));
545      EXPECT_THAT(tree->Edges(), SizeIs(3u));
546      EXPECT_THAT(GetLeafEdges(tree), ElementsAreArray(flats));
547      CordRepBtree::Unref(tree);
548    }
549  }
550  TEST_P(CordRepBtreeDualTest, MergeLeafWithTreeExceedingLeafCapacity) {
551    for (bool use_append : {false, true}) {
552      SCOPED_TRACE(use_append ? "Using Append" : "Using Prepend");
553      AutoUnref refs;
554      std::vector<CordRep*> flats;
555      CordRepBtree* left = MakeTree(CordRepBtree::kMaxCapacity * 3 - 2);
556      GetLeafEdges(left, flats);
557      refs.RefIf(first_shared(), left);
558      CordRepBtree* right = MakeTree(3);
559      GetLeafEdges(right, flats);
560      refs.RefIf(second_shared(), right);
561      CordRepBtree* tree = use_append ? CordRepBtree::Append(left, right)
562                                      : CordRepBtree::Prepend(right, left);
563      EXPECT_THAT(tree, IsNode(1));
564      EXPECT_THAT(tree->Edges(), SizeIs(4u));
565      EXPECT_THAT(GetLeafEdges(tree), ElementsAreArray(flats));
566      CordRepBtree::Unref(tree);
567    }
568  }
569  void RefEdgesAt(size_t depth, AutoUnref& refs, CordRepBtree* tree) {
570    absl::Span<CordRep* const> edges = tree->Edges();
571    if (depth == 0) {
572      refs.Ref(edges.front());
573      refs.Ref(edges.back());
574    } else {
575      assert(tree->height() > 0);
576      RefEdgesAt(depth - 1, refs, edges.front()->btree());
577      RefEdgesAt(depth - 1, refs, edges.back()->btree());
578    }
579  }
580  TEST(CordRepBtreeTest, MergeFuzzTest) {
581    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
582    std::minstd_rand rnd;
583    std::uniform_int_distribution<int> coin_flip(0, 1);
584    std::uniform_int_distribution<int> dice_throw(1, 6);
585    auto random_leaf_count = [&]() {
586      std::uniform_int_distribution<int> dist_height(0, 3);
587      std::uniform_int_distribution<int> dist_leaf(0, max_cap - 1);
588      const int height = dist_height(rnd);
589      return (height ? pow(max_cap, height) : 0) + dist_leaf(rnd);
590    };
591    for (int i = 0; i < 10000; ++i) {
592      AutoUnref refs;
593      std::vector<CordRep*> flats;
594      CordRepBtree* left = MakeTree(random_leaf_count(), coin_flip(rnd));
595      GetLeafEdges(left, flats);
596      if (dice_throw(rnd) == 1) {
597        std::uniform_int_distribution<size_t> dist(
598            0, static_cast<size_t>(left->height()));
599        RefEdgesAt(dist(rnd), refs, left);
600      }
601      CordRepBtree* right = MakeTree(random_leaf_count(), coin_flip(rnd));
602      GetLeafEdges(right, flats);
603      if (dice_throw(rnd) == 1) {
604        std::uniform_int_distribution<size_t> dist(
605            0, static_cast<size_t>(right->height()));
606        RefEdgesAt(dist(rnd), refs, right);
607      }
608      CordRepBtree* tree = CordRepBtree::Append(left, right);
609      EXPECT_THAT(GetLeafEdges(tree), ElementsAreArray(flats));
610      CordRepBtree::Unref(tree);
611    }
612  }
613  TEST_P(CordRepBtreeTest, RemoveSuffix) {
614    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
615    for (size_t cap : {max_cap - 1, max_cap * 2, max_cap * max_cap * 2}) {
616      const std::string data = CreateRandomString(cap * 512);
617      {
618        AutoUnref refs;
619        CordRepBtree* node = refs.RefIf(shared(), CreateTree(data, 512));
620        EXPECT_THAT(CordRepBtree::RemoveSuffix(node, data.length()), Eq(nullptr));
621        node = refs.RefIf(shared(), CreateTree(data, 512));
622        EXPECT_THAT(CordRepBtree::RemoveSuffix(node, 0), Eq(node));
623        CordRep::Unref(node);
624      }
625      for (size_t n = 1; n < data.length(); ++n) {
626        AutoUnref refs;
627        auto flats = CreateFlatsFromString(data, 512);
628        CordRepBtree* node = refs.RefIf(shared(), CreateTree(flats));
629        CordRep* rep = refs.Add(CordRepBtree::RemoveSuffix(node, n));
630        EXPECT_THAT(CordToString(rep), Eq(data.substr(0, data.length() - n)));
631        auto is_flat = [](CordRep* rep) { return rep->tag >= FLAT; };
632        std::vector<CordRep*> edges = CordCollectRepsIf(is_flat, rep);
633        ASSERT_THAT(edges.size(), Le(flats.size()));
634        CordRep* last_edge = edges.back();
635        edges.pop_back();
636        const size_t last_length = rep->length - edges.size() * 512;
637        size_t index = 0;
638        for (CordRep* edge : edges) {
639          ASSERT_THAT(edge, Eq(flats[index++]));
640          ASSERT_THAT(edge->length, Eq(512u));
641        }
642        if (last_length >= 500) {
643          EXPECT_THAT(last_edge, Eq(flats[index++]));
644          if (shared()) {
645            EXPECT_THAT(last_edge->length, Eq(512u));
646          } else {
647            EXPECT_TRUE(last_edge->refcount.IsOne());
648            EXPECT_THAT(last_edge->length, Eq(last_length));
649          }
650        }
651      }
652    }
653  }
654  TEST(CordRepBtreeTest, SubTree) {
655    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
656    const size_t n = max_cap * max_cap * 2;
657    const std::string data = CreateRandomString(n * 3);
658    std::vector<CordRep*> flats;
659    for (absl::string_view s = data; !s.empty(); s.remove_prefix(3)) {
660      flats.push_back(MakeFlat(s.substr(0, 3)));
661    }
662    CordRepBtree* node = CordRepBtree::Create(CordRep::Ref(flats[0]));
663    for (size_t i = 1; i < flats.size(); ++i) {
664      node = CordRepBtree::Append(node, CordRep::Ref(flats[i]));
665    }
666    for (size_t offset = 0; offset < data.length(); ++offset) {
667      for (size_t length = 1; length <= data.length() - offset; ++length) {
668        CordRep* rep = node->SubTree(offset, length);
669        EXPECT_THAT(CordToString(rep), Eq(data.substr(offset, length)));
670        CordRep::Unref(rep);
671      }
672    }
673    CordRepBtree::Unref(node);
674    for (CordRep* rep : flats) {
675      CordRep::Unref(rep);
676    }
677  }
678  TEST(CordRepBtreeTest, SubTreeOnExistingSubstring) {
679    AutoUnref refs;
680    std::string data = CreateRandomString(1000);
681    CordRepBtree* leaf = CordRepBtree::Create(MakeFlat("abc"));
682    CordRep* flat = MakeFlat(data);
683    leaf = CordRepBtree::Append(leaf, flat);
684    CordRep* result = leaf->SubTree(0, 3 + 990);
685    ASSERT_THAT(result->tag, Eq(BTREE));
686    CordRep::Unref(leaf);
687    leaf = result->btree();
688    ASSERT_THAT(leaf->Edges(), ElementsAre(_, IsSubstring(0u, 990u)));
689    EXPECT_THAT(leaf->Edges()[1]->substring()->child, Eq(flat));
690    result = leaf->SubTree(3 + 5, 970);
691    ASSERT_THAT(result, IsSubstring(5u, 970u));
692    EXPECT_THAT(result->substring()->child, Eq(flat));
693    CordRep::Unref(result);
694    CordRep::Unref(leaf);
695  }
696  TEST_P(CordRepBtreeTest, AddDataToLeaf) {
697    const size_t n = CordRepBtree::kMaxCapacity;
698    const std::string data = CreateRandomString(n * 3);
699    for (bool append : {true, false}) {
700      AutoUnref refs;
701      DataConsumer consumer(data, append);
702      SCOPED_TRACE(append ? "Append" : "Prepend");
703      CordRepBtree* leaf = CordRepBtree::Create(MakeFlat(consumer.Next(3)));
704      for (size_t i = 1; i < n; ++i) {
705        refs.RefIf(shared(), leaf);
706        CordRepBtree* result = BtreeAdd(leaf, append, consumer.Next(3));
707        EXPECT_THAT(result, Conditional(shared(), Ne(leaf), Eq(leaf)));
708        EXPECT_THAT(CordToString(result), Eq(consumer.Consumed()));
709        leaf = result;
710      }
711      CordRep::Unref(leaf);
712    }
713  }
714  TEST_P(CordRepBtreeTest, AppendDataToTree) {
715    AutoUnref refs;
716    size_t n = CordRepBtree::kMaxCapacity + CordRepBtree::kMaxCapacity / 2;
717    std::string data = CreateRandomString(n * 3);
718    CordRepBtree* tree = refs.RefIf(shared(), CreateTree(data, 3));
719    CordRepBtree* leaf0 = tree->Edges()[0]->btree();
720    CordRepBtree* leaf1 = tree->Edges()[1]->btree();
721    CordRepBtree* result = CordRepBtree::Append(tree, "123456789");
722    EXPECT_THAT(result, Conditional(shared(), Ne(tree), Eq(tree)));
723    EXPECT_THAT(result->Edges(),
724                ElementsAre(leaf0, Conditional(shared(), Ne(leaf1), Eq(leaf1))));
725    EXPECT_THAT(CordToString(result), Eq(data + "123456789"));
726    CordRep::Unref(result);
727  }
728  TEST_P(CordRepBtreeTest, PrependDataToTree) {
729    AutoUnref refs;
730    size_t n = CordRepBtree::kMaxCapacity + CordRepBtree::kMaxCapacity / 2;
731    std::string data = CreateRandomString(n * 3);
732    CordRepBtree* tree = refs.RefIf(shared(), CreateTreeReverse(data, 3));
733    CordRepBtree* leaf0 = tree->Edges()[0]->btree();
734    CordRepBtree* leaf1 = tree->Edges()[1]->btree();
735    CordRepBtree* result = CordRepBtree::Prepend(tree, "123456789");
736    EXPECT_THAT(result, Conditional(shared(), Ne(tree), Eq(tree)));
737    EXPECT_THAT(result->Edges(),
738                ElementsAre(Conditional(shared(), Ne(leaf0), Eq(leaf0)), leaf1));
739    EXPECT_THAT(CordToString(result), Eq("123456789" + data));
740    CordRep::Unref(result);
741  }
742  TEST_P(CordRepBtreeTest, AddDataToTreeThreeLevelsDeep) {
743    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
744    const size_t n = max_cap * max_cap * max_cap;
745    const std::string data = CreateRandomString(n * 3);
746    for (bool append : {true, false}) {
747      AutoUnref refs;
748      DataConsumer consumer(data, append);
749      SCOPED_TRACE(append ? "Append" : "Prepend");
750      CordRepBtree* tree = CordRepBtree::Create(MakeFlat(consumer.Next(3)));
751      for (size_t i = 1; i < max_cap; ++i) {
752        tree = BtreeAdd(tree, append, consumer.Next(3));
753      }
754      ASSERT_THAT(CordToString(tree), Eq(consumer.Consumed()));
755      refs.RefIf(shared(), tree);
756      CordRepBtree* result = BtreeAdd(tree, append, consumer.Next(3));
757      ASSERT_THAT(result, IsNode(1));
758      ASSERT_THAT(result, Ne(tree));
759      ASSERT_THAT(CordToString(result), Eq(consumer.Consumed()));
760      tree = result;
761      for (size_t i = max_cap + 1; i < max_cap * max_cap; ++i) {
762        refs.RefIf(shared(), tree);
763        result = BtreeAdd(tree, append, consumer.Next(3));
764        ASSERT_THAT(result, Conditional(shared(), Ne(tree), Eq(tree)));
765        ASSERT_THAT(CordToString(result), Eq(consumer.Consumed()));
766        tree = result;
767      }
768      refs.RefIf(shared(), tree);
769      result = BtreeAdd(tree, append, consumer.Next(3));
770      ASSERT_THAT(result, IsNode(2));
771      ASSERT_THAT(result, Ne(tree));
772      ASSERT_THAT(CordToString(result), Eq(consumer.Consumed()));
773      tree = result;
774      for (size_t i = max_cap * max_cap + 1; i < max_cap * max_cap * max_cap;
775           ++i) {
776        refs.RefIf(shared(), tree);
777        result = BtreeAdd(tree, append, consumer.Next(3));
778        ASSERT_THAT(result, Conditional(shared(), Ne(tree), Eq(tree)));
779        ASSERT_THAT(CordToString(result), Eq(consumer.Consumed()));
780        tree = result;
781      }
782      CordRep::Unref(tree);
783    }
784  }
785  TEST_P(CordRepBtreeTest, AddLargeDataToLeaf) {
786    const size_t max_cap = CordRepBtree::kMaxCapacity;
787    const size_t n = max_cap * max_cap * max_cap * 3 + 2;
788    const std::string data = CreateRandomString(n * kMaxFlatLength);
789    for (bool append : {true, false}) {
790      AutoUnref refs;
791      SCOPED_TRACE(append ? "Append" : "Prepend");
792      CordRepBtree* leaf = CordRepBtree::Create(MakeFlat("abc"));
793      refs.RefIf(shared(), leaf);
794      CordRepBtree* result = BtreeAdd(leaf, append, data);
795      EXPECT_THAT(CordToString(result), Eq(append ? "abc" + data : data + "abc"));
796      CordRep::Unref(result);
797    }
798  }
799  TEST_P(CordRepBtreeTest, CreateFromTreeReturnsTree) {
800    AutoUnref refs;
801    CordRepBtree* leaf = CordRepBtree::Create(MakeFlat("Hello world"));
802    refs.RefIf(shared(), leaf);
803    CordRepBtree* result = CordRepBtree::Create(leaf);
804    EXPECT_THAT(result, Eq(leaf));
805    CordRep::Unref(result);
806  }
807  TEST(CordRepBtreeTest, GetCharacter) {
808    size_t n = CordRepBtree::kMaxCapacity * CordRepBtree::kMaxCapacity + 2;
809    std::string data = CreateRandomString(n * 3);
810    CordRepBtree* tree = CreateTree(data, 3);
811    tree = tree->Append(tree, MakeSubstring(4, 5, MakeFlat("abcdefghijklm")));
812    data += "efghi";
813    for (size_t i = 0; i < data.length(); ++i) {
814      ASSERT_THAT(tree->GetCharacter(i), Eq(data[i]));
815    }
816    CordRep::Unref(tree);
817  }
818  TEST_P(CordRepBtreeTest, IsFlatSingleFlat) {
819    CordRepBtree* leaf = CordRepBtree::Create(MakeFlat("Hello world"));
820    absl::string_view fragment;
821    EXPECT_TRUE(leaf->IsFlat(nullptr));
822    EXPECT_TRUE(leaf->IsFlat(&fragment));
823    EXPECT_THAT(fragment, Eq("Hello world"));
<span onclick='openModal()' class='match'>824    fragment = "";
825    EXPECT_TRUE(leaf->IsFlat(0, 11, nullptr));
826    EXPECT_TRUE(leaf->IsFlat(0, 11, &fragment));
827    EXPECT_THAT(fragment, Eq("Hello world"));
828    EXPECT_TRUE(leaf->IsFlat(1, 4, &fragment));
829    EXPECT_THAT(fragment, Eq("ello"));
830    EXPECT_TRUE(leaf->IsFlat(6, 5, &fragment));
831    EXPECT_THAT(fragment, Eq("world"));
832    CordRep::Unref(leaf);
</span>833  }
834  TEST(CordRepBtreeTest, IsFlatMultiFlat) {
835    size_t n = CordRepBtree::kMaxCapacity * CordRepBtree::kMaxCapacity + 2;
836    std::string data = CreateRandomString(n * 3);
837    CordRepBtree* tree = CreateTree(data, 3);
838    tree = tree->Append(tree, MakeSubstring(4, 3, MakeFlat("abcdefghijklm")));
839    tree = tree->Append(tree, MakeSubstring(8, 3, MakeFlat("abcdefghijklm")));
840    data += "efgijk";
841    EXPECT_FALSE(tree->IsFlat(nullptr));
842    absl::string_view fragment = "Can't touch this";
843    EXPECT_FALSE(tree->IsFlat(&fragment));
844    EXPECT_THAT(fragment, Eq("Can't touch this"));
845    for (size_t offset = 0; offset < data.size(); offset += 3) {
846      EXPECT_TRUE(tree->IsFlat(offset, 3, nullptr));
847      EXPECT_TRUE(tree->IsFlat(offset, 3, &fragment));
848      EXPECT_THAT(fragment, Eq(data.substr(offset, 3)));
849      fragment = "Can't touch this";
850      if (offset > 0) {
851        EXPECT_FALSE(tree->IsFlat(offset - 1, 4, nullptr));
852        EXPECT_FALSE(tree->IsFlat(offset - 1, 4, &fragment));
853        EXPECT_THAT(fragment, Eq("Can't touch this"));
854      }
855      if (offset < data.size() - 4) {
856        EXPECT_FALSE(tree->IsFlat(offset, 4, nullptr));
857        EXPECT_FALSE(tree->IsFlat(offset, 4, &fragment));
858        EXPECT_THAT(fragment, Eq("Can't touch this"));
859      }
860    }
861    CordRep::Unref(tree);
862  }
863  #if defined(GTEST_HAS_DEATH_TEST) && !defined(NDEBUG)
864  TEST_P(CordRepBtreeHeightTest, GetAppendBufferNotPrivate) {
865    CordRepBtree* tree = CordRepBtree::Create(MakeExternal("Foo"));
866    CordRepBtree::Ref(tree);
867    EXPECT_DEATH(tree->GetAppendBuffer(1), ".*");
868    CordRepBtree::Unref(tree);
869    CordRepBtree::Unref(tree);
870  }
871  #endif  
872  TEST_P(CordRepBtreeHeightTest, GetAppendBufferNotFlat) {
873    CordRepBtree* tree = CordRepBtree::Create(MakeExternal("Foo"));
874    for (int i = 1; i <= height(); ++i) {
875      tree = CordRepBtree::New(tree);
876    }
877    EXPECT_THAT(tree->GetAppendBuffer(1), SizeIs(0u));
878    CordRepBtree::Unref(tree);
879  }
880  TEST_P(CordRepBtreeHeightTest, GetAppendBufferFlatNotPrivate) {
881    CordRepFlat* flat = MakeFlat("abc");
882    CordRepBtree* tree = CordRepBtree::Create(CordRep::Ref(flat));
883    for (int i = 1; i <= height(); ++i) {
884      tree = CordRepBtree::New(tree);
885    }
886    EXPECT_THAT(tree->GetAppendBuffer(1), SizeIs(0u));
887    CordRepBtree::Unref(tree);
888    CordRep::Unref(flat);
889  }
890  TEST_P(CordRepBtreeHeightTest, GetAppendBufferTreeNotPrivate) {
891    if (height() == 0) return;
892    AutoUnref refs;
893    CordRepFlat* flat = MakeFlat("abc");
894    CordRepBtree* tree = CordRepBtree::Create(CordRep::Ref(flat));
895    for (int i = 1; i <= height(); ++i) {
896      if (i == (height() + 1) / 2) refs.Ref(tree);
897      tree = CordRepBtree::New(tree);
898    }
899    EXPECT_THAT(tree->GetAppendBuffer(1), SizeIs(0u));
900    CordRepBtree::Unref(tree);
901    CordRep::Unref(flat);
902  }
903  TEST_P(CordRepBtreeHeightTest, GetAppendBufferFlatNoCapacity) {
904    CordRepFlat* flat = MakeFlat("abc");
905    flat->length = flat->Capacity();
906    CordRepBtree* tree = CordRepBtree::Create(flat);
907    for (int i = 1; i <= height(); ++i) {
908      tree = CordRepBtree::New(tree);
909    }
910    EXPECT_THAT(tree->GetAppendBuffer(1), SizeIs(0u));
911    CordRepBtree::Unref(tree);
912  }
913  TEST_P(CordRepBtreeHeightTest, GetAppendBufferFlatWithCapacity) {
914    CordRepFlat* flat = MakeFlat("abc");
915    CordRepBtree* tree = CordRepBtree::Create(flat);
916    for (int i = 1; i <= height(); ++i) {
917      tree = CordRepBtree::New(tree);
918    }
919    absl::Span<char> span = tree->GetAppendBuffer(2);
920    EXPECT_THAT(span, SizeIs(2u));
921    EXPECT_THAT(span.data(), TypedEq<void*>(flat->Data() + 3));
922    EXPECT_THAT(tree->length, Eq(5u));
923    size_t avail = flat->Capacity() - 5;
924    span = tree->GetAppendBuffer(avail + 100);
925    EXPECT_THAT(span, SizeIs(avail));
926    EXPECT_THAT(span.data(), TypedEq<void*>(flat->Data() + 5));
927    EXPECT_THAT(tree->length, Eq(5 + avail));
928    CordRepBtree::Unref(tree);
929  }
930  TEST(CordRepBtreeTest, Dump) {
931    std::stringstream ss;
932    CordRepBtree::Dump(nullptr, ss);
933    CordRepBtree::Dump(nullptr, "Once upon a label", ss);
934    CordRepBtree::Dump(nullptr, "Once upon a label", false, ss);
935    CordRepBtree::Dump(nullptr, "Once upon a label", true, ss);
936    CordRepFlat* flat = MakeFlat("Hello world");
937    CordRepExternal* external = MakeExternal("Hello external");
938    CordRep* substr_flat = MakeSubstring(1, 6, CordRep::Ref(flat));
939    CordRep* substr_external = MakeSubstring(2, 7, CordRep::Ref(external));
940    CordRepBtree* tree = CordRepBtree::Create(flat);
941    tree = CordRepBtree::Append(tree, external);
942    tree = CordRepBtree::Append(tree, substr_flat);
943    tree = CordRepBtree::Append(tree, substr_external);
944    while (tree->height() == 0) {
945      tree = CordRepBtree::Append(tree, CordRep::Ref(flat));
946      tree = CordRepBtree::Append(tree, CordRep::Ref(external));
947      tree = CordRepBtree::Append(tree, CordRep::Ref(substr_flat));
948      tree = CordRepBtree::Append(tree, CordRep::Ref(substr_external));
949    }
950    for (int api = 0; api <= 3; ++api) {
951      absl::string_view api_scope;
952      std::stringstream ss;
953      switch (api) {
954        case 0:
955          api_scope = "Bare";
956          CordRepBtree::Dump(tree, ss);
957          break;
958        case 1:
959          api_scope = "Label only";
960          CordRepBtree::Dump(tree, "Once upon a label", ss);
961          break;
962        case 2:
963          api_scope = "Label no content";
964          CordRepBtree::Dump(tree, "Once upon a label", false, ss);
965          break;
966        default:
967          api_scope = "Label and content";
968          CordRepBtree::Dump(tree, "Once upon a label", true, ss);
969          break;
970      }
971      SCOPED_TRACE(api_scope);
972      std::string str = ss.str();
973      EXPECT_THAT(str, AllOf(HasSubstr("Node(1)"), HasSubstr("Leaf"),
974                             HasSubstr("Private"), HasSubstr("Shared")));
975      EXPECT_THAT(str, AllOf(HasSubstr("len = 11"), HasSubstr("len = 14"),
976                             HasSubstr("len = 6"), HasSubstr("len = 7"),
977                             HasSubstr("start = 1"), HasSubstr("start = 2")));
978      EXPECT_THAT(
979          str, AllOf(HasSubstr(absl::StrCat("0x", absl::Hex(flat))),
980                     HasSubstr(absl::StrCat("0x", absl::Hex(external))),
981                     HasSubstr(absl::StrCat("0x", absl::Hex(substr_flat))),
982                     HasSubstr(absl::StrCat("0x", absl::Hex(substr_external)))));
983      if (api != 0) {
984        EXPECT_THAT(str, HasSubstr("Once upon a label"));
985      }
986      if (api != 3) {
987        EXPECT_THAT(str, Not(AnyOf((HasSubstr("data = \"Hello world\""),
988                                    HasSubstr("data = \"Hello external\""),
989                                    HasSubstr("data = \"ello w\""),
990                                    HasSubstr("data = \"llo ext\"")))));
991      } else {
992        EXPECT_THAT(str, AllOf((HasSubstr("data = \"Hello world\""),
993                                HasSubstr("data = \"Hello external\""),
994                                HasSubstr("data = \"ello w\""),
995                                HasSubstr("data = \"llo ext\""))));
996      }
997    }
998    CordRep::Unref(tree);
999  }
1000  TEST(CordRepBtreeTest, IsValid) {
1001    EXPECT_FALSE(CordRepBtree::IsValid(nullptr));
1002    CordRepBtree* empty = CordRepBtree::New(0);
1003    EXPECT_TRUE(CordRepBtree::IsValid(empty));
1004    CordRep::Unref(empty);
1005    for (bool as_tree : {false, true}) {
1006      CordRepBtree* leaf = CordRepBtree::Create(MakeFlat("abc"));
1007      CordRepBtree* tree = as_tree ? CordRepBtree::New(leaf) : nullptr;
1008      CordRepBtree* check = as_tree ? tree : leaf;
1009      ASSERT_TRUE(CordRepBtree::IsValid(check));
1010      leaf->length--;
1011      EXPECT_FALSE(CordRepBtree::IsValid(check));
1012      leaf->length++;
1013      ASSERT_TRUE(CordRepBtree::IsValid(check));
1014      leaf->tag--;
1015      EXPECT_FALSE(CordRepBtree::IsValid(check));
1016      leaf->tag++;
1017      ASSERT_TRUE(CordRepBtree::IsValid(check));
1018      leaf->storage[0] = static_cast<uint8_t>(CordRepBtree::kMaxHeight + 1);
1019      EXPECT_FALSE(CordRepBtree::IsValid(check));
1020      leaf->storage[0] = 1;
1021      EXPECT_FALSE(CordRepBtree::IsValid(check));
1022      leaf->storage[0] = 0;
1023      ASSERT_TRUE(CordRepBtree::IsValid(check));
1024      const uint8_t begin = leaf->storage[1];
1025      leaf->storage[1] = static_cast<uint8_t>(CordRepBtree::kMaxCapacity);
1026      EXPECT_FALSE(CordRepBtree::IsValid(check));
1027      leaf->storage[1] = 2;
1028      EXPECT_FALSE(CordRepBtree::IsValid(check));
1029      leaf->storage[1] = begin;
1030      ASSERT_TRUE(CordRepBtree::IsValid(check));
1031      const uint8_t end = leaf->storage[2];
1032      leaf->storage[2] = static_cast<uint8_t>(CordRepBtree::kMaxCapacity + 1);
1033      EXPECT_FALSE(CordRepBtree::IsValid(check));
1034      leaf->storage[2] = end;
1035      ASSERT_TRUE(CordRepBtree::IsValid(check));
1036      CordRep* const edge = leaf->Edges()[0];
1037      const uint8_t tag = edge->tag;
1038      CordRepBtreeTestPeer::SetEdge(leaf, begin, nullptr);
1039      EXPECT_FALSE(CordRepBtree::IsValid(check));
1040      CordRepBtreeTestPeer::SetEdge(leaf, begin, edge);
1041      edge->tag = BTREE;
1042      EXPECT_FALSE(CordRepBtree::IsValid(check));
1043      edge->tag = tag;
1044      if (as_tree) {
1045        ASSERT_TRUE(CordRepBtree::IsValid(check));
1046        leaf->length--;
1047        EXPECT_FALSE(CordRepBtree::IsValid(check));
1048        leaf->length++;
1049        ASSERT_TRUE(CordRepBtree::IsValid(check));
1050        tree->storage[0] = static_cast<uint8_t>(2);
1051        EXPECT_FALSE(CordRepBtree::IsValid(check));
1052        tree->storage[0] = 1;
1053        ASSERT_TRUE(CordRepBtree::IsValid(check));
1054        CordRep* const edge = tree->Edges()[0];
1055        const uint8_t tag = edge->tag;
1056        edge->tag = FLAT;
1057        EXPECT_FALSE(CordRepBtree::IsValid(check));
1058        edge->tag = tag;
1059      }
1060      ASSERT_TRUE(CordRepBtree::IsValid(check));
1061      CordRep::Unref(check);
1062    }
1063  }
1064  TEST(CordRepBtreeTest, AssertValid) {
1065    CordRepBtree* tree = CordRepBtree::Create(MakeFlat("abc"));
1066    const CordRepBtree* ctree = tree;
1067    EXPECT_THAT(CordRepBtree::AssertValid(tree), Eq(tree));
1068    EXPECT_THAT(CordRepBtree::AssertValid(ctree), Eq(ctree));
1069  #if defined(GTEST_HAS_DEATH_TEST)
1070    CordRepBtree* nulltree = nullptr;
1071    const CordRepBtree* cnulltree = nullptr;
1072    EXPECT_DEBUG_DEATH(
1073        EXPECT_THAT(CordRepBtree::AssertValid(nulltree), Eq(nulltree)), ".*");
1074    EXPECT_DEBUG_DEATH(
1075        EXPECT_THAT(CordRepBtree::AssertValid(cnulltree), Eq(cnulltree)), ".*");
1076    tree->length--;
1077    EXPECT_DEBUG_DEATH(EXPECT_THAT(CordRepBtree::AssertValid(tree), Eq(tree)),
1078                       ".*");
1079    EXPECT_DEBUG_DEATH(EXPECT_THAT(CordRepBtree::AssertValid(ctree), Eq(ctree)),
1080                       ".*");
1081    tree->length++;
1082  #endif
1083    CordRep::Unref(tree);
1084  }
1085  TEST(CordRepBtreeTest, CheckAssertValidShallowVsDeep) {
1086    const bool exhaustive_validation = IsCordBtreeExhaustiveValidationEnabled();
1087    auto cleanup = absl::MakeCleanup([exhaustive_validation] {
1088      SetCordBtreeExhaustiveValidation(exhaustive_validation);
1089    });
1090    CordRep* flat = MakeFlat("abc");
1091    CordRepBtree* tree = CordRepBtree::Create(flat);
1092    constexpr size_t max_cap = CordRepBtree::kMaxCapacity;
1093    const size_t n = max_cap * max_cap * 2;
1094    for (size_t i = 0; i < n; ++i) {
1095      tree = CordRepBtree::Append(tree, MakeFlat("Hello world"));
1096    }
1097    flat->length = 100;
1098    SetCordBtreeExhaustiveValidation(false);
1099    EXPECT_FALSE(CordRepBtree::IsValid(tree));
1100    EXPECT_TRUE(CordRepBtree::IsValid(tree, true));
1101    EXPECT_FALSE(CordRepBtree::IsValid(tree, false));
1102    CordRepBtree::AssertValid(tree);
1103    CordRepBtree::AssertValid(tree, true);
1104  #if defined(GTEST_HAS_DEATH_TEST)
1105    EXPECT_DEBUG_DEATH(CordRepBtree::AssertValid(tree, false), ".*");
1106  #endif
1107    SetCordBtreeExhaustiveValidation(true);
1108    EXPECT_FALSE(CordRepBtree::IsValid(tree));
1109    EXPECT_FALSE(CordRepBtree::IsValid(tree, true));
1110    EXPECT_FALSE(CordRepBtree::IsValid(tree, false));
1111  #if defined(GTEST_HAS_DEATH_TEST)
1112    EXPECT_DEBUG_DEATH(CordRepBtree::AssertValid(tree), ".*");
1113    EXPECT_DEBUG_DEATH(CordRepBtree::AssertValid(tree, true), ".*");
1114  #endif
1115    flat->length = 3;
1116    CordRep::Unref(tree);
1117  }
1118  TEST_P(CordRepBtreeTest, Rebuild) {
1119    for (size_t size : {3u, 8u, 100u, 10000u, 1000000u}) {
1120      SCOPED_TRACE(absl::StrCat("Rebuild @", size));
1121      std::vector<CordRepFlat*> flats;
1122      for (size_t i = 0; i < size; ++i) {
1123        flats.push_back(CordRepFlat::New(2));
1124        flats.back()->Data()[0] = 'x';
1125        flats.back()->length = 1;
1126      }
1127      size_t split_count = 0;
1128      size_t split_limit = 3;
1129      auto it = flats.begin();
1130      CordRepBtree* left = nullptr;
1131      CordRepBtree* right = CordRepBtree::New(*it);
1132      while (++it != flats.end()) {
1133        if (++split_count >= split_limit) {
1134          split_limit += split_limit / 16;
1135          left = left ? CordRepBtree::Append(left, right) : right;
1136          right = CordRepBtree::New(*it);
1137        } else {
1138          right = CordRepBtree::Append(right, *it);
1139        }
1140      }
1141      left = left ? CordRepBtree::Append(left, right) : right;
1142      AutoUnref ref;
1143      left = ref.Add(CordRepBtree::Rebuild(ref.RefIf(shared(), left)));
1144      ASSERT_TRUE(CordRepBtree::IsValid(left));
1145      bool ok = true;
1146      it = flats.begin();
1147      CordVisitReps(left, [&](CordRep* edge) {
1148        if (edge->tag < FLAT) return;
1149        ok = ok && (it != flats.end() && *it++ == edge);
1150      });
1151      EXPECT_TRUE(ok && it == flats.end()) << "Rebuild edges mismatch";
1152    }
1153  }
1154  CordRepBtree::ExtractResult ExtractLast(CordRepBtree* input, size_t cap = 1) {
1155    return CordRepBtree::ExtractAppendBuffer(input, cap);
1156  }
1157  TEST(CordRepBtreeTest, ExtractAppendBufferLeafSingleFlat) {
1158    CordRep* flat = MakeFlat("Abc");
1159    CordRepBtree* leaf = CordRepBtree::Create(flat);
1160    EXPECT_THAT(ExtractLast(leaf), EqExtractResult(nullptr, flat));
1161    CordRep::Unref(flat);
1162  }
1163  TEST(CordRepBtreeTest, ExtractAppendBufferNodeSingleFlat) {
1164    CordRep* flat = MakeFlat("Abc");
1165    CordRepBtree* leaf = CordRepBtree::Create(flat);
1166    CordRepBtree* node = CordRepBtree::New(leaf);
1167    EXPECT_THAT(ExtractLast(node), EqExtractResult(nullptr, flat));
1168    CordRep::Unref(flat);
1169  }
1170  TEST(CordRepBtreeTest, ExtractAppendBufferLeafTwoFlats) {
1171    std::vector<CordRep*> flats = CreateFlatsFromString("abcdef", 3);
1172    CordRepBtree* leaf = CreateTree(flats);
1173    EXPECT_THAT(ExtractLast(leaf), EqExtractResult(flats[0], flats[1]));
1174    CordRep::Unref(flats[0]);
1175    CordRep::Unref(flats[1]);
1176  }
1177  TEST(CordRepBtreeTest, ExtractAppendBufferNodeTwoFlats) {
1178    std::vector<CordRep*> flats = CreateFlatsFromString("abcdef", 3);
1179    CordRepBtree* leaf = CreateTree(flats);
1180    CordRepBtree* node = CordRepBtree::New(leaf);
1181    EXPECT_THAT(ExtractLast(node), EqExtractResult(flats[0], flats[1]));
1182    CordRep::Unref(flats[0]);
1183    CordRep::Unref(flats[1]);
1184  }
1185  TEST(CordRepBtreeTest, ExtractAppendBufferNodeTwoFlatsInTwoLeafs) {
1186    std::vector<CordRep*> flats = CreateFlatsFromString("abcdef", 3);
1187    CordRepBtree* leaf1 = CordRepBtree::Create(flats[0]);
1188    CordRepBtree* leaf2 = CordRepBtree::Create(flats[1]);
1189    CordRepBtree* node = CordRepBtree::New(leaf1, leaf2);
1190    EXPECT_THAT(ExtractLast(node), EqExtractResult(flats[0], flats[1]));
1191    CordRep::Unref(flats[0]);
1192    CordRep::Unref(flats[1]);
1193  }
1194  TEST(CordRepBtreeTest, ExtractAppendBufferLeafThreeFlats) {
1195    std::vector<CordRep*> flats = CreateFlatsFromString("abcdefghi", 3);
1196    CordRepBtree* leaf = CreateTree(flats);
1197    EXPECT_THAT(ExtractLast(leaf), EqExtractResult(leaf, flats[2]));
1198    CordRep::Unref(flats[2]);
1199    CordRep::Unref(leaf);
1200  }
1201  TEST(CordRepBtreeTest, ExtractAppendBufferNodeThreeFlatsRightNoFolding) {
1202    CordRep* flat = MakeFlat("Abc");
1203    std::vector<CordRep*> flats = CreateFlatsFromString("defghi", 3);
1204    CordRepBtree* leaf1 = CordRepBtree::Create(flat);
1205    CordRepBtree* leaf2 = CreateTree(flats);
1206    CordRepBtree* node = CordRepBtree::New(leaf1, leaf2);
1207    EXPECT_THAT(ExtractLast(node), EqExtractResult(node, flats[1]));
1208    EXPECT_THAT(node->Edges(), ElementsAre(leaf1, leaf2));
1209    EXPECT_THAT(leaf1->Edges(), ElementsAre(flat));
1210    EXPECT_THAT(leaf2->Edges(), ElementsAre(flats[0]));
1211    CordRep::Unref(node);
1212    CordRep::Unref(flats[1]);
1213  }
1214  TEST(CordRepBtreeTest, ExtractAppendBufferNodeThreeFlatsRightLeafFolding) {
1215    CordRep* flat = MakeFlat("Abc");
1216    std::vector<CordRep*> flats = CreateFlatsFromString("defghi", 3);
1217    CordRepBtree* leaf1 = CreateTree(flats);
1218    CordRepBtree* leaf2 = CordRepBtree::Create(flat);
1219    CordRepBtree* node = CordRepBtree::New(leaf1, leaf2);
1220    EXPECT_THAT(ExtractLast(node), EqExtractResult(leaf1, flat));
1221    EXPECT_THAT(leaf1->Edges(), ElementsAreArray(flats));
1222    CordRep::Unref(leaf1);
1223    CordRep::Unref(flat);
1224  }
1225  TEST(CordRepBtreeTest, ExtractAppendBufferNoCapacity) {
1226    std::vector<CordRep*> flats = CreateFlatsFromString("abcdef", 3);
1227    CordRepBtree* leaf = CreateTree(flats);
1228    size_t avail = flats[1]->flat()->Capacity() - flats[1]->length;
1229    EXPECT_THAT(ExtractLast(leaf, avail + 1), EqExtractResult(leaf, nullptr));
1230    EXPECT_THAT(ExtractLast(leaf, avail), EqExtractResult(flats[0], flats[1]));
1231    CordRep::Unref(flats[0]);
1232    CordRep::Unref(flats[1]);
1233  }
1234  TEST(CordRepBtreeTest, ExtractAppendBufferNotFlat) {
1235    std::vector<CordRep*> flats = CreateFlatsFromString("abcdef", 3);
1236    auto substr = MakeSubstring(1, 2, flats[1]);
1237    CordRepBtree* leaf = CreateTree({flats[0], substr});
1238    EXPECT_THAT(ExtractLast(leaf), EqExtractResult(leaf, nullptr));
1239    CordRep::Unref(leaf);
1240  }
1241  TEST(CordRepBtreeTest, ExtractAppendBufferShared) {
1242    std::vector<CordRep*> flats = CreateFlatsFromString("abcdef", 3);
1243    CordRepBtree* leaf = CreateTree(flats);
1244    CordRep::Ref(flats[1]);
1245    EXPECT_THAT(ExtractLast(leaf), EqExtractResult(leaf, nullptr));
1246    CordRep::Unref(flats[1]);
1247    CordRep::Ref(leaf);
1248    EXPECT_THAT(ExtractLast(leaf), EqExtractResult(leaf, nullptr));
1249    CordRep::Unref(leaf);
1250    CordRepBtree* node = CordRepBtree::New(leaf);
1251    CordRep::Ref(node);
1252    EXPECT_THAT(ExtractLast(node), EqExtractResult(node, nullptr));
1253    CordRep::Unref(node);
1254    CordRep::Unref(node);
1255  }
1256  }  
1257  }  
1258  ABSL_NAMESPACE_END
1259  }  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cord_ring_test.cc</h3>
            <pre><code>1  #include <cstdlib>
2  #include <ctime>
3  #include <memory>
4  #include <random>
5  #include <sstream>
6  #include "gmock/gmock.h"
7  #include "gtest/gtest.h"
8  #include "absl/base/config.h"
9  #include "absl/base/internal/raw_logging.h"
10  #include "absl/base/macros.h"
11  #include "absl/debugging/leak_check.h"
12  #include "absl/strings/internal/cord_internal.h"
13  #include "absl/strings/internal/cord_rep_ring.h"
14  #include "absl/strings/str_cat.h"
15  #include "absl/strings/string_view.h"
16  extern thread_local bool cord_ring;
17  namespace absl {
18  ABSL_NAMESPACE_BEGIN
19  namespace {
20  using RandomEngine = std::mt19937_64;
21  using ::absl::cord_internal::CordRep;
22  using ::absl::cord_internal::CordRepConcat;
23  using ::absl::cord_internal::CordRepExternal;
24  using ::absl::cord_internal::CordRepFlat;
25  using ::absl::cord_internal::CordRepRing;
26  using ::absl::cord_internal::CordRepSubstring;
27  using ::absl::cord_internal::EXTERNAL;
28  using ::absl::cord_internal::SUBSTRING;
29  using testing::ElementsAre;
30  using testing::ElementsAreArray;
31  using testing::Eq;
32  using testing::Ge;
33  using testing::Le;
34  using testing::Lt;
35  using testing::Ne;
36  using testing::SizeIs;
37  using index_type = CordRepRing::index_type;
38  enum InputShareMode { kPrivate, kShared, kSharedIndirect };
39  struct TestParam {
40    TestParam() = default;
41    explicit TestParam(InputShareMode input_share_mode)
42        : input_share_mode(input_share_mode) {}
43    bool refcount_is_one = true;
44    bool with_capacity = true;
45    InputShareMode input_share_mode = kPrivate;
46    std::string ToString() const {
47      return absl::StrCat(refcount_is_one ? "Private" : "Shared",
48                          with_capacity ? "" : "_NoCapacity",
49                          (input_share_mode == kPrivate) ? ""
50                          : (input_share_mode == kShared)
51                              ? "_SharedInput"
52                              : "_IndirectSharedInput");
53    }
54  };
55  using TestParams = std::vector<TestParam>;
56  MATCHER_P2(EqIfPrivate, param, rep,
57             absl::StrCat("Equal 0x", absl::Hex(rep), " if private")) {
58    return param.refcount_is_one ? arg == rep : true;
59  }
60  MATCHER_P2(EqIfPrivateAndCapacity, param, rep,
61             absl::StrCat("Equal 0x", absl::Hex(rep),
62                          " if private and capacity")) {
63    return (param.refcount_is_one && param.with_capacity) ? arg == rep : true;
64  }
65  MATCHER_P2(NeIfShared, param, rep,
66             absl::StrCat("Not equal 0x", absl::Hex(rep), " if shared")) {
67    return param.refcount_is_one ? true : arg != rep;
68  }
69  MATCHER_P2(EqIfInputPrivate, param, rep, "Equal if input is private") {
70    return param.input_share_mode == kPrivate ? arg == rep : arg != rep;
71  }
72  MATCHER(IsValidRingBuffer, "RingBuffer is valid") {
73    std::stringstream ss;
74    if (!arg->IsValid(ss)) {
75      *result_listener << "\nERROR: " << ss.str() << "\nRING = " << *arg;
76      return false;
77    }
78    return true;
79  }
80  std::vector<string_view> ToFlats(const CordRepRing* r) {
81    std::vector<string_view> flats;
82    flats.reserve(r->entries());
83    index_type pos = r->head();
84    do {
85      flats.push_back(r->entry_data(pos));
86    } while ((pos = r->advance(pos)) != r->tail());
87    return flats;
88  }
89  class not_a_string_view {
90   public:
91    explicit not_a_string_view(absl::string_view s)
92        : data_(s.data()), size_(s.size()) {}
93    explicit not_a_string_view(const void* data, size_t size)
94        : data_(data), size_(size) {}
95    not_a_string_view remove_prefix(size_t n) const {
96      return not_a_string_view(static_cast<const char*>(data_) + n, size_ - n);
97    }
98    not_a_string_view remove_suffix(size_t n) const {
99      return not_a_string_view(data_, size_ - n);
100    }
101    const void* data() const { return data_; }
102    size_t size() const { return size_; }
103   private:
104    const void* data_;
105    size_t size_;
106  };
107  bool operator==(not_a_string_view lhs, not_a_string_view rhs) {
108    return lhs.data() == rhs.data() && lhs.size() == rhs.size();
109  }
110  std::ostream& operator<<(std::ostream& s, not_a_string_view rhs) {
111    return s << "{ data: " << rhs.data() << " size: " << rhs.size() << "}";
112  }
113  std::vector<not_a_string_view> ToRawFlats(const CordRepRing* r) {
114    std::vector<not_a_string_view> flats;
115    flats.reserve(r->entries());
116    index_type pos = r->head();
117    do {
118      flats.emplace_back(r->entry_data(pos));
119    } while ((pos = r->advance(pos)) != r->tail());
120    return flats;
121  }
122  std::string ToString(const CordRepRing* r) {
123    std::string value;
124    value.reserve(r->length);
125    index_type pos = r->head();
126    do {
127      absl::string_view sv = r->entry_data(pos);
128      value.append(sv.data(), sv.size());
129    } while ((pos = r->advance(pos)) != r->tail());
130    return value;
131  }
132  CordRep* MakeFlat(absl::string_view s, size_t extra = 0) {
133    CordRepFlat* flat = CordRepFlat::New(s.length() + extra);
134    memcpy(flat->Data(), s.data(), s.length());
135    flat->length = s.length();
136    return flat;
137  }
138  CordRepExternal* MakeExternal(absl::string_view s) {
139    struct Rep : public CordRepExternal {
140      std::string s;
141      explicit Rep(absl::string_view s) : s(s) {
142        this->tag = EXTERNAL;
143        this->base = s.data();
144        this->length = s.length();
145        this->releaser_invoker = [](CordRepExternal* self) {
146          delete static_cast<Rep*>(self);
147        };
148      }
149    };
150    return new Rep(s);
151  }
152  CordRepExternal* MakeFakeExternal(size_t length) {
153    struct Rep : public CordRepExternal {
154      std::string s;
155      explicit Rep(size_t len) {
156        this->tag = EXTERNAL;
157        this->base = reinterpret_cast<const char*>(this->storage);
158        this->length = len;
159        this->releaser_invoker = [](CordRepExternal* self) {
160          delete static_cast<Rep*>(self);
161        };
162      }
163    };
164    return new Rep(length);
165  }
166  CordRep* MakeLeaf(absl::string_view s, size_t extra = 0) {
167    if (s.size() <= absl::cord_internal::kMaxFlatLength) {
168      return MakeFlat(s, extra);
169    } else {
170      return MakeExternal(s);
171    }
172  }
173  CordRepSubstring* MakeSubstring(size_t start, size_t len, CordRep* rep) {
174    auto* sub = new CordRepSubstring;
175    sub->tag = SUBSTRING;
176    sub->start = start;
177    sub->length = (len <= 0) ? rep->length - start + len : len;
178    sub->child = rep;
179    return sub;
180  }
181  CordRepSubstring* RemovePrefix(size_t start, CordRep* rep) {
182    return MakeSubstring(start, rep->length - start, rep);
183  }
184  CordRepSubstring* RemoveSuffix(size_t length, CordRep* rep) {
185    return MakeSubstring(0, rep->length - length, rep);
186  }
187  enum Composition { kMix, kAppend, kPrepend };
188  Composition RandomComposition() {
189    RandomEngine rng(GTEST_FLAG_GET(random_seed));
190    return (rng() & 1) ? kMix : ((rng() & 1) ? kAppend : kPrepend);
191  }
192  absl::string_view ToString(Composition composition) {
193    switch (composition) {
194      case kAppend:
195        return "Append";
196      case kPrepend:
197        return "Prepend";
198      case kMix:
199        return "Mix";
200    }
201    assert(false);
202    return "???";
203  }
204  constexpr const char* kFox = "The quick brown fox jumps over the lazy dog";
205  constexpr const char* kFoxFlats[] = {"The ", "quick ", "brown ",
206                                       "fox ", "jumps ", "over ",
207                                       "the ", "lazy ",  "dog"};
208  CordRepRing* FromFlats(Span<const char* const> flats,
209                         Composition composition = kAppend) {
210    if (flats.empty()) return nullptr;
211    CordRepRing* ring = nullptr;
212    switch (composition) {
213      case kAppend:
214        ring = CordRepRing::Create(MakeLeaf(flats.front()), flats.size() - 1);
215        for (int i = 1; i < flats.size(); ++i) {
216          ring = CordRepRing::Append(ring, MakeLeaf(flats[i]));
217        }
218        break;
219      case kPrepend:
220        ring = CordRepRing::Create(MakeLeaf(flats.back()), flats.size() - 1);
221        for (int i = static_cast<int>(flats.size() - 2); i >= 0; --i) {
222          ring = CordRepRing::Prepend(ring, MakeLeaf(flats[i]));
223        }
224        break;
225      case kMix:
226        size_t middle1 = flats.size() / 2, middle2 = middle1;
227        ring = CordRepRing::Create(MakeLeaf(flats[middle1]), flats.size() - 1);
228        if (!flats.empty()) {
229          if ((flats.size() & 1) == 0) {
230            ring = CordRepRing::Prepend(ring, MakeLeaf(flats[--middle1]));
231          }
232          for (int i = 1; i <= middle1; ++i) {
233            ring = CordRepRing::Prepend(ring, MakeLeaf(flats[middle1 - i]));
234            ring = CordRepRing::Append(ring, MakeLeaf(flats[middle2 + i]));
235          }
236        }
237        break;
238    }
239    EXPECT_THAT(ToFlats(ring), ElementsAreArray(flats));
240    return ring;
241  }
242  std::ostream& operator<<(std::ostream& s, const TestParam& param) {
243    return s << param.ToString();
244  }
245  std::string TestParamToString(const testing::TestParamInfo<TestParam>& info) {
246    return info.param.ToString();
247  }
248  class CordRingTest : public testing::Test {
249   public:
250    ~CordRingTest() override {
251      for (CordRep* rep : unrefs_) {
252        CordRep::Unref(rep);
253      }
254    }
255    template <typename CordRepType>
256    CordRepType* NeedsUnref(CordRepType* rep) {
257      assert(rep);
258      unrefs_.push_back(rep);
259      return rep;
260    }
261    template <typename CordRepType>
262    CordRepType* Ref(CordRepType* rep) {
263      CordRep::Ref(rep);
264      return NeedsUnref(rep);
265    }
266   private:
267    std::vector<CordRep*> unrefs_;
268  };
269  class CordRingTestWithParam : public testing::TestWithParam<TestParam> {
270   public:
271    ~CordRingTestWithParam() override {
272      for (CordRep* rep : unrefs_) {
273        CordRep::Unref(rep);
274      }
275    }
276    CordRepRing* CreateWithCapacity(CordRep* child, size_t extra_capacity) {
277      if (!GetParam().with_capacity) extra_capacity = 0;
278      CordRepRing* ring = CordRepRing::Create(child, extra_capacity);
279      ring->SetCapacityForTesting(1 + extra_capacity);
280      return RefIfShared(ring);
281    }
282    bool Shared() const { return !GetParam().refcount_is_one; }
283    bool InputShared() const { return GetParam().input_share_mode == kShared; }
284    bool InputSharedIndirect() const {
285      return GetParam().input_share_mode == kSharedIndirect;
286    }
287    template <typename CordRepType>
288    CordRepType* NeedsUnref(CordRepType* rep) {
289      assert(rep);
290      unrefs_.push_back(rep);
291      return rep;
292    }
293    template <typename CordRepType>
294    CordRepType* Ref(CordRepType* rep) {
295      CordRep::Ref(rep);
296      return NeedsUnref(rep);
297    }
298    template <typename CordRepType>
299    CordRepType* RefIfShared(CordRepType* rep) {
300      return Shared() ? Ref(rep) : rep;
301    }
302    template <typename CordRepType>
303    CordRepType* RefIfInputShared(CordRepType* rep) {
304      return InputShared() ? Ref(rep) : rep;
305    }
306    template <typename CordRepType>
307    CordRepType* RefIfInputSharedIndirect(CordRepType* rep) {
308      return InputSharedIndirect() ? Ref(rep) : rep;
309    }
310   private:
311    std::vector<CordRep*> unrefs_;
312  };
313  class CordRingCreateTest : public CordRingTestWithParam {
314   public:
315    static TestParams CreateTestParams() {
316      TestParams params;
317      params.emplace_back(InputShareMode::kPrivate);
318      params.emplace_back(InputShareMode::kShared);
319      return params;
320    }
321  };
322  class CordRingSubTest : public CordRingTestWithParam {
323   public:
324    static TestParams CreateTestParams() {
325      TestParams params;
326      for (bool refcount_is_one : {true, false}) {
327        TestParam param;
328        param.refcount_is_one = refcount_is_one;
329        params.push_back(param);
330      }
331      return params;
332    }
333  };
334  class CordRingBuildTest : public CordRingTestWithParam {
335   public:
336    static TestParams CreateTestParams() {
337      TestParams params;
338      for (bool refcount_is_one : {true, false}) {
339        for (bool with_capacity : {true, false}) {
340          TestParam param;
341          param.refcount_is_one = refcount_is_one;
342          param.with_capacity = with_capacity;
343          params.push_back(param);
344        }
345      }
346      return params;
347    }
348  };
349  class CordRingCreateFromTreeTest : public CordRingTestWithParam {
350   public:
351    static TestParams CreateTestParams() {
352      TestParams params;
353      params.emplace_back(InputShareMode::kPrivate);
354      params.emplace_back(InputShareMode::kShared);
355      params.emplace_back(InputShareMode::kSharedIndirect);
356      return params;
357    }
358  };
359  class CordRingBuildInputTest : public CordRingTestWithParam {
360   public:
361    static TestParams CreateTestParams() {
362      TestParams params;
363      for (bool refcount_is_one : {true, false}) {
364        for (bool with_capacity : {true, false}) {
365          for (InputShareMode share_mode : {kPrivate, kShared, kSharedIndirect}) {
366            TestParam param;
367            param.refcount_is_one = refcount_is_one;
368            param.with_capacity = with_capacity;
369            param.input_share_mode = share_mode;
370            params.push_back(param);
371          }
372        }
373      }
374      return params;
375    }
376  };
377  INSTANTIATE_TEST_SUITE_P(WithParam, CordRingSubTest,
378                           testing::ValuesIn(CordRingSubTest::CreateTestParams()),
379                           TestParamToString);
380  INSTANTIATE_TEST_SUITE_P(
381      WithParam, CordRingCreateTest,
382      testing::ValuesIn(CordRingCreateTest::CreateTestParams()),
383      TestParamToString);
384  INSTANTIATE_TEST_SUITE_P(
385      WithParam, CordRingCreateFromTreeTest,
386      testing::ValuesIn(CordRingCreateFromTreeTest::CreateTestParams()),
387      TestParamToString);
388  INSTANTIATE_TEST_SUITE_P(
389      WithParam, CordRingBuildTest,
390      testing::ValuesIn(CordRingBuildTest::CreateTestParams()),
391      TestParamToString);
392  INSTANTIATE_TEST_SUITE_P(
393      WithParam, CordRingBuildInputTest,
394      testing::ValuesIn(CordRingBuildInputTest::CreateTestParams()),
395      TestParamToString);
396  TEST_P(CordRingCreateTest, CreateFromFlat) {
397    absl::string_view str1 = "abcdefghijklmnopqrstuvwxyz";
398    CordRepRing* result = NeedsUnref(CordRepRing::Create(MakeFlat(str1)));
399    ASSERT_THAT(result, IsValidRingBuffer());
400    EXPECT_THAT(result->length, Eq(str1.size()));
401    EXPECT_THAT(ToFlats(result), ElementsAre(str1));
402  }
403  TEST_P(CordRingCreateTest, CreateFromRing) {
404    CordRepRing* ring = RefIfShared(FromFlats(kFoxFlats));
405    CordRepRing* result = NeedsUnref(CordRepRing::Create(ring));
406    ASSERT_THAT(result, IsValidRingBuffer());
407    EXPECT_THAT(result, EqIfPrivate(GetParam(), ring));
408    EXPECT_THAT(result, NeIfShared(GetParam(), ring));
409    EXPECT_THAT(ToFlats(result), ElementsAreArray(kFoxFlats));
410  }
411  TEST_P(CordRingCreateFromTreeTest, CreateFromSubstringRing) {
412    CordRepRing* ring = RefIfInputSharedIndirect(FromFlats(kFoxFlats));
413    CordRep* sub = RefIfInputShared(MakeSubstring(2, 11, ring));
414    CordRepRing* result = NeedsUnref(CordRepRing::Create(sub));
415    ASSERT_THAT(result, IsValidRingBuffer());
416    EXPECT_THAT(result, EqIfInputPrivate(GetParam(), ring));
417    EXPECT_THAT(ToString(result), string_view(kFox).substr(2, 11));
418  }
419  TEST_F(CordRingTest, CreateWithIllegalExtraCapacity) {
420  #if defined(ABSL_HAVE_EXCEPTIONS)
421    CordRep* flat = NeedsUnref(MakeFlat("Hello world"));
422    try {
423      CordRepRing::Create(flat, CordRepRing::kMaxCapacity);
424      GTEST_FAIL() << "expected std::length_error exception";
425    } catch (const std::length_error&) {
426    }
427  #elif defined(GTEST_HAS_DEATH_TEST)
428    CordRep* flat = NeedsUnref(MakeFlat("Hello world"));
429    EXPECT_DEATH(CordRepRing::Create(flat, CordRepRing::kMaxCapacity), ".*");
430  #endif
431  }
432  TEST_P(CordRingCreateFromTreeTest, CreateFromSubstringOfFlat) {
433    absl::string_view str1 = "abcdefghijklmnopqrstuvwxyz";
434    auto* flat = RefIfInputShared(MakeFlat(str1));
435    auto* child = RefIfInputSharedIndirect(MakeSubstring(4, 20, flat));
436    CordRepRing* result = NeedsUnref(CordRepRing::Create(child));
437    ASSERT_THAT(result, IsValidRingBuffer());
438    EXPECT_THAT(result->length, Eq(20));
439    EXPECT_THAT(ToFlats(result), ElementsAre(str1.substr(4, 20)));
440  }
441  TEST_P(CordRingCreateTest, CreateFromExternal) {
442    absl::string_view str1 = "abcdefghijklmnopqrstuvwxyz";
443    auto* child = RefIfInputShared(MakeExternal(str1));
444    CordRepRing* result = NeedsUnref(CordRepRing::Create(child));
445    ASSERT_THAT(result, IsValidRingBuffer());
446    EXPECT_THAT(result->length, Eq(str1.size()));
447    EXPECT_THAT(ToFlats(result), ElementsAre(str1));
448  }
449  TEST_P(CordRingCreateFromTreeTest, CreateFromSubstringOfExternal) {
450    absl::string_view str1 = "abcdefghijklmnopqrstuvwxyz";
451    auto* external = RefIfInputShared(MakeExternal(str1));
452    auto* child = RefIfInputSharedIndirect(MakeSubstring(1, 24, external));
453    CordRepRing* result = NeedsUnref(CordRepRing::Create(child));
454    ASSERT_THAT(result, IsValidRingBuffer());
455    EXPECT_THAT(result->length, Eq(24));
456    EXPECT_THAT(ToFlats(result), ElementsAre(str1.substr(1, 24)));
457  }
458  TEST_P(CordRingCreateFromTreeTest, CreateFromSubstringOfLargeExternal) {
459    auto* external = RefIfInputShared(MakeFakeExternal(1 << 20));
460    auto str = not_a_string_view(external->base, 1 << 20)
461                   .remove_prefix(1 << 19)
462                   .remove_suffix(6);
463    auto* child =
464        RefIfInputSharedIndirect(MakeSubstring(1 << 19, (1 << 19) - 6, external));
465    CordRepRing* result = NeedsUnref(CordRepRing::Create(child));
466    ASSERT_THAT(result, IsValidRingBuffer());
467    EXPECT_THAT(result->length, Eq(str.size()));
468    EXPECT_THAT(ToRawFlats(result), ElementsAre(str));
469  }
470  TEST_P(CordRingCreateTest, Properties) {
471    absl::string_view str1 = "abcdefghijklmnopqrstuvwxyz";
472    CordRepRing* result = NeedsUnref(CordRepRing::Create(MakeFlat(str1), 120));
473    ASSERT_THAT(result, IsValidRingBuffer());
474    EXPECT_THAT(result->head(), Eq(0));
475    EXPECT_THAT(result->tail(), Eq(1));
476    EXPECT_THAT(result->capacity(), Ge(120 + 1));
477    EXPECT_THAT(result->capacity(), Le(2 * 120 + 1));
478    EXPECT_THAT(result->entries(), Eq(1));
479    EXPECT_THAT(result->begin_pos(), Eq(0));
480  }
481  TEST_P(CordRingCreateTest, EntryForNewFlat) {
482    absl::string_view str1 = "abcdefghijklmnopqrstuvwxyz";
483    CordRep* child = MakeFlat(str1);
484    CordRepRing* result = NeedsUnref(CordRepRing::Create(child, 120));
485    ASSERT_THAT(result, IsValidRingBuffer());
486    EXPECT_THAT(result->entry_child(0), Eq(child));
487    EXPECT_THAT(result->entry_end_pos(0), Eq(str1.length()));
488    EXPECT_THAT(result->entry_data_offset(0), Eq(0));
489  }
490  TEST_P(CordRingCreateTest, EntryForNewFlatSubstring) {
491    absl::string_view str1 = "1234567890abcdefghijklmnopqrstuvwxyz";
492    CordRep* child = MakeFlat(str1);
493    CordRep* substring = MakeSubstring(10, 26, child);
494    CordRepRing* result = NeedsUnref(CordRepRing::Create(substring, 1));
495    ASSERT_THAT(result, IsValidRingBuffer());
496    EXPECT_THAT(result->entry_child(0), Eq(child));
497    EXPECT_THAT(result->entry_end_pos(0), Eq(26));
498    EXPECT_THAT(result->entry_data_offset(0), Eq(10));
499  }
500  TEST_P(CordRingBuildTest, AppendFlat) {
501    absl::string_view str1 = "abcdefghijklmnopqrstuvwxyz";
502    absl::string_view str2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
503    CordRepRing* ring = CreateWithCapacity(MakeExternal(str1), 1);
504    CordRepRing* result = NeedsUnref(CordRepRing::Append(ring, MakeFlat(str2)));
505    ASSERT_THAT(result, IsValidRingBuffer());
506    EXPECT_THAT(result, EqIfPrivateAndCapacity(GetParam(), ring));
507    EXPECT_THAT(result, NeIfShared(GetParam(), ring));
508    EXPECT_THAT(result->length, Eq(str1.size() + str2.size()));
509    EXPECT_THAT(ToFlats(result), ElementsAre(str1, str2));
510  }
511  TEST_P(CordRingBuildTest, PrependFlat) {
512    absl::string_view str1 = "abcdefghijklmnopqrstuvwxyz";
513    absl::string_view str2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
514    CordRepRing* ring = CreateWithCapacity(MakeExternal(str1), 1);
515    CordRepRing* result = NeedsUnref(CordRepRing::Prepend(ring, MakeFlat(str2)));
516    ASSERT_THAT(result, IsValidRingBuffer());
517    EXPECT_THAT(result, EqIfPrivateAndCapacity(GetParam(), ring));
518    EXPECT_THAT(result, NeIfShared(GetParam(), ring));
519    EXPECT_THAT(result->length, Eq(str1.size() + str2.size()));
520    EXPECT_THAT(ToFlats(result), ElementsAre(str2, str1));
521  }
522  TEST_P(CordRingBuildTest, AppendString) {
523    absl::string_view str1 = "abcdefghijklmnopqrstuvwxyz";
524    absl::string_view str2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
525    CordRepRing* ring = CreateWithCapacity(MakeExternal(str1), 1);
526    CordRepRing* result = NeedsUnref(CordRepRing::Append(ring, str2));
527    ASSERT_THAT(result, IsValidRingBuffer());
528    EXPECT_THAT(result, EqIfPrivateAndCapacity(GetParam(), ring));
529    EXPECT_THAT(result, NeIfShared(GetParam(), ring));
530    EXPECT_THAT(result->length, Eq(str1.size() + str2.size()));
531    EXPECT_THAT(ToFlats(result), ElementsAre(str1, str2));
532  }
533  TEST_P(CordRingBuildTest, AppendStringHavingExtra) {
534    absl::string_view str1 = "1234";
535    absl::string_view str2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
536    CordRepRing* ring = CreateWithCapacity(MakeFlat(str1, 26), 0);
537    CordRepRing* result = NeedsUnref(CordRepRing::Append(ring, str2));
538    ASSERT_THAT(result, IsValidRingBuffer());
539    EXPECT_THAT(result->length, Eq(str1.size() + str2.size()));
540    EXPECT_THAT(result, EqIfPrivate(GetParam(), ring));
541    EXPECT_THAT(result, NeIfShared(GetParam(), ring));
542  }
543  TEST_P(CordRingBuildTest, AppendStringHavingPartialExtra) {
544    absl::string_view str1 = "1234";
545    absl::string_view str2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
546    auto* flat = MakeFlat(str1, 1);
547    size_t avail = flat->flat()->Capacity() - flat->length;
548    ASSERT_THAT(avail, Lt(str2.size())) << " adjust test for larger flats!";
549    absl::string_view str1a = str2.substr(0, avail);
550    absl::string_view str2a = str2.substr(avail);
551    CordRepRing* ring = CreateWithCapacity(flat, 1);
552    CordRepRing* result = NeedsUnref(CordRepRing::Append(ring, str2));
553    ASSERT_THAT(result, IsValidRingBuffer());
554    EXPECT_THAT(result->length, Eq(str1.size() + str2.size()));
555    EXPECT_THAT(result, EqIfPrivateAndCapacity(GetParam(), ring));
556    EXPECT_THAT(result, NeIfShared(GetParam(), ring));
557    if (GetParam().refcount_is_one) {
558      EXPECT_THAT(ToFlats(result), ElementsAre(StrCat(str1, str1a), str2a));
559    } else {
560      EXPECT_THAT(ToFlats(result), ElementsAre(str1, str2));
561    }
562  }
563  TEST_P(CordRingBuildTest, AppendStringHavingExtraInSubstring) {
564    absl::string_view str1 = "123456789_1234";
565    absl::string_view str2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
566    CordRep* flat = RemovePrefix(10, MakeFlat(str1, 26));
567    CordRepRing* ring = CreateWithCapacity(flat, 0);
568    CordRepRing* result = NeedsUnref(CordRepRing::Append(ring, str2));
569    ASSERT_THAT(result, IsValidRingBuffer());
570    EXPECT_THAT(result, EqIfPrivate(GetParam(), ring));
571    EXPECT_THAT(result, NeIfShared(GetParam(), ring));
572    EXPECT_THAT(result->length, Eq(4 + str2.size()));
573    if (GetParam().refcount_is_one) {
574      EXPECT_THAT(ToFlats(result), ElementsAre(StrCat("1234", str2)));
575    } else {
576      EXPECT_THAT(ToFlats(result), ElementsAre("1234", str2));
577    }
578  }
579  TEST_P(CordRingBuildTest, AppendStringHavingSharedExtra) {
580    absl::string_view str1 = "123456789_1234";
581    absl::string_view str2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
582    for (int shared_type = 0; shared_type < 2; ++shared_type) {
583      SCOPED_TRACE(absl::StrCat("Shared extra type ", shared_type));
584      CordRep* flat = nullptr;
585      CordRep* flat1 = nullptr;
586      if (shared_type == 0) {
587        flat = CordRep::Ref(MakeFlat(str1.substr(10), 100));
588      } else if (shared_type == 1) {
589        flat1 = CordRep::Ref(MakeFlat(str1));
590        flat = RemovePrefix(10, flat1);
591      } else {
592        flat = CordRep::Ref(RemovePrefix(10, MakeFlat(str1, 100)));
593      }
594      CordRepRing* ring = CreateWithCapacity(flat, 1);
595      CordRepRing* result = NeedsUnref(CordRepRing::Append(ring, str2));
596      ASSERT_THAT(result, IsValidRingBuffer());
597      EXPECT_THAT(result, EqIfPrivateAndCapacity(GetParam(), ring));
598      EXPECT_THAT(result, NeIfShared(GetParam(), ring));
599      EXPECT_THAT(result->length, Eq(4 + str2.size()));
600      EXPECT_THAT(ToFlats(result), ElementsAre("1234", str2));
601      CordRep::Unref(shared_type == 1 ? flat1 : flat);
602    }
603  }
604  TEST_P(CordRingBuildTest, AppendStringWithExtra) {
605    absl::string_view str1 = "1234";
606    absl::string_view str2 = "1234567890";
607    absl::string_view str3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
608    CordRepRing* ring = CreateWithCapacity(MakeExternal(str1), 1);
609    CordRepRing* result = NeedsUnref(CordRepRing::Append(ring, str2, 26));
610    result = CordRepRing::Append(result, str3);
611    ASSERT_THAT(result, IsValidRingBuffer());
612    EXPECT_THAT(result->length, Eq(str1.size() + str2.size() + str3.size()));
613    EXPECT_THAT(result, EqIfPrivateAndCapacity(GetParam(), ring));
614    EXPECT_THAT(ToFlats(result), ElementsAre(str1, StrCat(str2, str3)));
615  }
616  TEST_P(CordRingBuildTest, PrependString) {
617    absl::string_view str1 = "abcdefghijklmnopqrstuvwxyz";
618    absl::string_view str2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
619    CordRepRing* ring = CreateWithCapacity(MakeExternal(str1), 1);
620    CordRepRing* result = NeedsUnref(CordRepRing::Prepend(ring, str2));
621    ASSERT_THAT(result, IsValidRingBuffer());
622    if (GetParam().with_capacity && GetParam().refcount_is_one) {
623      EXPECT_THAT(result, Eq(ring));
624    } else {
625      EXPECT_THAT(result, Ne(ring));
626    }
627    EXPECT_THAT(result->length, Eq(str1.size() + str2.size()));
628    EXPECT_THAT(ToFlats(result), ElementsAre(str2, str1));
629  }
630  TEST_P(CordRingBuildTest, PrependStringHavingExtra) {
631    absl::string_view str1 = "abcdefghijklmnopqrstuvwxyz1234";
632    absl::string_view str2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
633    CordRep* flat = RemovePrefix(26, MakeFlat(str1));
634    CordRepRing* ring = CreateWithCapacity(flat, 0);
635    CordRepRing* result = NeedsUnref(CordRepRing::Prepend(ring, str2));
636    ASSERT_THAT(result, IsValidRingBuffer());
637    EXPECT_THAT(result, EqIfPrivate(GetParam(), ring));
638    EXPECT_THAT(result, NeIfShared(GetParam(), ring));
639    EXPECT_THAT(result->length, Eq(4 + str2.size()));
640    if (GetParam().refcount_is_one) {
641      EXPECT_THAT(ToFlats(result), ElementsAre(StrCat(str2, "1234")));
642    } else {
643      EXPECT_THAT(ToFlats(result), ElementsAre(str2, "1234"));
644    }
645  }
646  TEST_P(CordRingBuildTest, PrependStringHavingSharedExtra) {
647    absl::string_view str1 = "123456789_ABCDEFGHIJKLMNOPQRSTUVWXYZ";
648    absl::string_view str2 = "abcdefghij";
649    absl::string_view str1a = str1.substr(10);
650    for (int shared_type = 1; shared_type < 2; ++shared_type) {
651      SCOPED_TRACE(absl::StrCat("Shared extra type ", shared_type));
652      CordRep* flat = nullptr;
653      CordRep* flat1 = nullptr;
654      if (shared_type == 1) {
655        flat = RemovePrefix(10, flat1 = CordRep::Ref(MakeFlat(str1)));
656      } else {
657        flat = CordRep::Ref(RemovePrefix(10, MakeFlat(str1, 100)));
658      }
659      CordRepRing* ring = CreateWithCapacity(flat, 1);
660      CordRepRing* result = NeedsUnref(CordRepRing::Prepend(ring, str2));
661      ASSERT_THAT(result, IsValidRingBuffer());
662      EXPECT_THAT(result->length, Eq(str1a.size() + str2.size()));
663      EXPECT_THAT(result, EqIfPrivateAndCapacity(GetParam(), ring));
664      EXPECT_THAT(result, NeIfShared(GetParam(), ring));
665      EXPECT_THAT(ToFlats(result), ElementsAre(str2, str1a));
666      CordRep::Unref(shared_type == 1 ? flat1 : flat);
667    }
668  }
669  TEST_P(CordRingBuildTest, PrependStringWithExtra) {
670    absl::string_view str1 = "1234";
671    absl::string_view str2 = "1234567890";
672    absl::string_view str3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
673    CordRepRing* ring = CreateWithCapacity(MakeExternal(str1), 1);
674    CordRepRing* result = NeedsUnref(CordRepRing::Prepend(ring, str2, 26));
675    ASSERT_THAT(result, IsValidRingBuffer());
676    result = CordRepRing::Prepend(result, str3);
677    EXPECT_THAT(result->length, Eq(str1.size() + str2.size() + str3.size()));
678    EXPECT_THAT(result, EqIfPrivateAndCapacity(GetParam(), ring));
679    EXPECT_THAT(ToFlats(result), ElementsAre(StrCat(str3, str2), str1));
680  }
681  TEST_P(CordRingBuildTest, AppendPrependStringMix) {
682    const auto& flats = kFoxFlats;
683    CordRepRing* ring = CreateWithCapacity(MakeFlat(flats[4]), 8);
684    CordRepRing* result = ring;
685    for (int i = 1; i <= 4; ++i) {
686      result = CordRepRing::Prepend(result, flats[4 - i]);
687      result = CordRepRing::Append(result, flats[4 + i]);
688    }
689    NeedsUnref(result);
690    ASSERT_THAT(result, IsValidRingBuffer());
691    EXPECT_THAT(result, EqIfPrivateAndCapacity(GetParam(), ring));
692    EXPECT_THAT(ToString(result), kFox);
693  }
694  TEST_P(CordRingBuildTest, AppendPrependStringMixWithExtra) {
695    const auto& flats = kFoxFlats;
696    CordRepRing* ring = CreateWithCapacity(MakeFlat(flats[4], 100), 8);
697    CordRepRing* result = ring;
698    for (int i = 1; i <= 4; ++i) {
699      result = CordRepRing::Prepend(result, flats[4 - i], 100);
700      result = CordRepRing::Append(result, flats[4 + i], 100);
701    }
702    NeedsUnref(result);
703    ASSERT_THAT(result, IsValidRingBuffer());
704    EXPECT_THAT(result, EqIfPrivateAndCapacity(GetParam(), ring));
705    if (GetParam().refcount_is_one) {
706      EXPECT_THAT(ToFlats(result),
707                  ElementsAre("The quick brown fox ", "jumps over the lazy dog"));
708    } else {
709      EXPECT_THAT(ToFlats(result), ElementsAre("The quick brown fox ", "jumps ",
710                                               "over the lazy dog"));
711    }
712  }
713  TEST_P(CordRingBuildTest, AppendPrependStringMixWithPrependedExtra) {
714    const auto& flats = kFoxFlats;
715    CordRep* flat = MakeFlat(StrCat(std::string(50, '.'), flats[4]), 50);
716    CordRepRing* ring = CreateWithCapacity(RemovePrefix(50, flat), 0);
717    CordRepRing* result = ring;
718    for (int i = 1; i <= 4; ++i) {
719      result = CordRepRing::Prepend(result, flats[4 - i], 100);
720      result = CordRepRing::Append(result, flats[4 + i], 100);
721    }
722    result = NeedsUnref(result);
723    ASSERT_THAT(result, IsValidRingBuffer());
724    EXPECT_THAT(result, EqIfPrivate(GetParam(), ring));
725    if (GetParam().refcount_is_one) {
726      EXPECT_THAT(ToFlats(result), ElementsAre(kFox));
727    } else {
728      EXPECT_THAT(ToFlats(result), ElementsAre("The quick brown fox ", "jumps ",
729                                               "over the lazy dog"));
730    }
731  }
732  TEST_P(CordRingSubTest, SubRing) {
733    auto composition = RandomComposition();
734    SCOPED_TRACE(ToString(composition));
735    auto flats = MakeSpan(kFoxFlats);
736    string_view all = kFox;
737    for (size_t offset = 0; offset < all.size() - 1; ++offset) {
738      CordRepRing* ring = RefIfShared(FromFlats(flats, composition));
739      CordRepRing* result = CordRepRing::SubRing(ring, offset, 0);
740      EXPECT_THAT(result, nullptr);
741      for (size_t len = 1; len < all.size() - offset; ++len) {
742        ring = RefIfShared(FromFlats(flats, composition));
743        result = NeedsUnref(CordRepRing::SubRing(ring, offset, len));
744        ASSERT_THAT(result, IsValidRingBuffer());
745        ASSERT_THAT(result, EqIfPrivate(GetParam(), ring));
746        ASSERT_THAT(result, NeIfShared(GetParam(), ring));
747        ASSERT_THAT(ToString(result), Eq(all.substr(offset, len)));
748      }
749    }
750  }
751  TEST_P(CordRingSubTest, SubRingFromLargeExternal) {
752    auto composition = RandomComposition();
753    std::string large_string(1 << 20, '.');
754    const char* flats[] = {
755        "abcdefghijklmnopqrstuvwxyz",
756        large_string.c_str(),
757        "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
758    };
759    std::string buffer = absl::StrCat(flats[0], flats[1], flats[2]);
760    absl::string_view all = buffer;
761    for (size_t offset = 0; offset < 30; ++offset) {
762      CordRepRing* ring = RefIfShared(FromFlats(flats, composition));
763      CordRepRing* result = CordRepRing::SubRing(ring, offset, 0);
764      EXPECT_THAT(result, nullptr);
765      for (size_t len = all.size() - 30; len < all.size() - offset; ++len) {
766        ring = RefIfShared(FromFlats(flats, composition));
767        result = NeedsUnref(CordRepRing::SubRing(ring, offset, len));
768        ASSERT_THAT(result, IsValidRingBuffer());
769        ASSERT_THAT(result, EqIfPrivate(GetParam(), ring));
770        ASSERT_THAT(result, NeIfShared(GetParam(), ring));
771        auto str = ToString(result);
772        ASSERT_THAT(str, SizeIs(len));
773        ASSERT_THAT(str, Eq(all.substr(offset, len)));
774      }
775    }
776  }
777  TEST_P(CordRingSubTest, RemovePrefix) {
778    auto composition = RandomComposition();
779    SCOPED_TRACE(ToString(composition));
780    auto flats = MakeSpan(kFoxFlats);
781    string_view all = kFox;
782    CordRepRing* ring = RefIfShared(FromFlats(flats, composition));
783    CordRepRing* result = CordRepRing::RemovePrefix(ring, all.size());
784    EXPECT_THAT(result, nullptr);
785    for (size_t len = 1; len < all.size(); ++len) {
786      ring = RefIfShared(FromFlats(flats, composition));
787      result = NeedsUnref(CordRepRing::RemovePrefix(ring, len));
788      ASSERT_THAT(result, IsValidRingBuffer());
789      EXPECT_THAT(result, EqIfPrivate(GetParam(), ring));
790      ASSERT_THAT(result, NeIfShared(GetParam(), ring));
791      EXPECT_THAT(ToString(result), Eq(all.substr(len)));
792    }
793  }
794  TEST_P(CordRingSubTest, RemovePrefixFromLargeExternal) {
795    CordRepExternal* external1 = MakeFakeExternal(1 << 20);
796    CordRepExternal* external2 = MakeFakeExternal(1 << 20);
797    CordRepRing* ring = CordRepRing::Create(external1, 1);
798    ring = CordRepRing::Append(ring, external2);
799    CordRepRing* result = NeedsUnref(CordRepRing::RemovePrefix(ring, 1 << 16));
800    EXPECT_THAT(
801        ToRawFlats(result),
802        ElementsAre(
803            not_a_string_view(external1->base, 1 << 20).remove_prefix(1 << 16),
804            not_a_string_view(external2->base, 1 << 20)));
805  }
806  TEST_P(CordRingSubTest, RemoveSuffix) {
807    auto composition = RandomComposition();
808    SCOPED_TRACE(ToString(composition));
809    auto flats = MakeSpan(kFoxFlats);
810    string_view all = kFox;
811    CordRepRing* ring = RefIfShared(FromFlats(flats, composition));
812    CordRepRing* result = CordRepRing::RemoveSuffix(ring, all.size());
813    EXPECT_THAT(result, nullptr);
814    for (size_t len = 1; len < all.size(); ++len) {
815      ring = RefIfShared(FromFlats(flats, composition));
816      result = NeedsUnref(CordRepRing::RemoveSuffix(ring, len));
817      ASSERT_THAT(result, IsValidRingBuffer());
818      ASSERT_THAT(result, EqIfPrivate(GetParam(), ring));
819      ASSERT_THAT(result, NeIfShared(GetParam(), ring));
820      ASSERT_THAT(ToString(result), Eq(all.substr(0, all.size() - len)));
821    }
822  }
823  TEST_P(CordRingSubTest, AppendRing) {
824    auto composition = RandomComposition();
825    SCOPED_TRACE(ToString(composition));
826    auto flats = MakeSpan(kFoxFlats).subspan(1);
827    CordRepRing* ring = CreateWithCapacity(MakeFlat(kFoxFlats[0]), flats.size());
828    CordRepRing* child = FromFlats(flats, composition);
829    CordRepRing* result = NeedsUnref(CordRepRing::Append(ring, child));
830    ASSERT_THAT(result, IsValidRingBuffer());
831    EXPECT_THAT(result, EqIfPrivate(GetParam(), ring));
832    EXPECT_THAT(result, NeIfShared(GetParam(), ring));
833    EXPECT_THAT(ToFlats(result), ElementsAreArray(kFoxFlats));
834  }
835  TEST_P(CordRingBuildInputTest, AppendRingWithFlatOffset) {
836    auto composition = RandomComposition();
837    SCOPED_TRACE(ToString(composition));
838    auto flats = MakeSpan(kFoxFlats);
839    CordRepRing* ring = CreateWithCapacity(MakeFlat("Head"), flats.size());
840    CordRep* child = RefIfInputSharedIndirect(FromFlats(flats, composition));
841    CordRep* stripped = RemovePrefix(10, child);
842    CordRepRing* result = NeedsUnref(CordRepRing::Append(ring, stripped));
843    ASSERT_THAT(result, IsValidRingBuffer());
844    EXPECT_THAT(result, EqIfPrivateAndCapacity(GetParam(), ring));
845    EXPECT_THAT(result, NeIfShared(GetParam(), ring));
846    EXPECT_THAT(ToFlats(result), ElementsAre("Head", "brown ", "fox ", "jumps ",
847                                             "over ", "the ", "lazy ", "dog"));
848  }
849  TEST_P(CordRingBuildInputTest, AppendRingWithBrokenOffset) {
850    auto composition = RandomComposition();
851    SCOPED_TRACE(ToString(composition));
852    auto flats = MakeSpan(kFoxFlats);
853    CordRepRing* ring = CreateWithCapacity(MakeFlat("Head"), flats.size());
854    CordRep* child = RefIfInputSharedIndirect(FromFlats(flats, composition));
855    CordRep* stripped = RemovePrefix(21, child);
856    CordRepRing* result = NeedsUnref(CordRepRing::Append(ring, stripped));
857    ASSERT_THAT(result, IsValidRingBuffer());
858    EXPECT_THAT(result, EqIfPrivateAndCapacity(GetParam(), ring));
859    EXPECT_THAT(result, NeIfShared(GetParam(), ring));
860    EXPECT_THAT(ToFlats(result),
861                ElementsAre("Head", "umps ", "over ", "the ", "lazy ", "dog"));
862  }
863  TEST_P(CordRingBuildInputTest, AppendRingWithFlatLength) {
864    auto composition = RandomComposition();
865    SCOPED_TRACE(ToString(composition));
866    auto flats = MakeSpan(kFoxFlats);
867    CordRepRing* ring = CreateWithCapacity(MakeFlat("Head"), flats.size());
868    CordRep* child = RefIfInputSharedIndirect(FromFlats(flats, composition));
869    CordRep* stripped = RemoveSuffix(8, child);
870    CordRepRing* result = NeedsUnref(CordRepRing::Append(ring, stripped));
871    ASSERT_THAT(result, IsValidRingBuffer());
872    EXPECT_THAT(result, EqIfPrivateAndCapacity(GetParam(), ring));
873    EXPECT_THAT(result, NeIfShared(GetParam(), ring));
874    EXPECT_THAT(ToFlats(result), ElementsAre("Head", "The ", "quick ", "brown ",
875                                             "fox ", "jumps ", "over ", "the "));
876  }
877  TEST_P(CordRingBuildTest, AppendRingWithBrokenFlatLength) {
878    auto composition = RandomComposition();
879    SCOPED_TRACE(ToString(composition));
880    auto flats = MakeSpan(kFoxFlats);
881    CordRepRing* ring = CreateWithCapacity(MakeFlat("Head"), flats.size());
882    CordRep* child = RefIfInputSharedIndirect(FromFlats(flats, composition));
883    CordRep* stripped = RemoveSuffix(15, child);
884    CordRepRing* result = NeedsUnref(CordRepRing::Append(ring, stripped));
885    ASSERT_THAT(result, IsValidRingBuffer());
886    EXPECT_THAT(result, EqIfPrivateAndCapacity(GetParam(), ring));
887    EXPECT_THAT(result, NeIfShared(GetParam(), ring));
888    EXPECT_THAT(ToFlats(result), ElementsAre("Head", "The ", "quick ", "brown ",
889                                             "fox ", "jumps ", "ov"));
890  }
891  TEST_P(CordRingBuildTest, AppendRingMiddlePiece) {
892    auto composition = RandomComposition();
893    SCOPED_TRACE(ToString(composition));
894    auto flats = MakeSpan(kFoxFlats);
895    CordRepRing* ring = CreateWithCapacity(MakeFlat("Head"), flats.size());
896    CordRep* child = RefIfInputSharedIndirect(FromFlats(flats, composition));
897    CordRep* stripped = MakeSubstring(7, child->length - 27, child);
898    CordRepRing* result = NeedsUnref(CordRepRing::Append(ring, stripped));
899    ASSERT_THAT(result, IsValidRingBuffer());
900    EXPECT_THAT(result, EqIfPrivateAndCapacity(GetParam(), ring));
901    EXPECT_THAT(result, NeIfShared(GetParam(), ring));
902    EXPECT_THAT(ToFlats(result),
903                ElementsAre("Head", "ck ", "brown ", "fox ", "jum"));
904  }
905  TEST_P(CordRingBuildTest, AppendRingSinglePiece) {
906    auto composition = RandomComposition();
907    SCOPED_TRACE(ToString(composition));
908    auto flats = MakeSpan(kFoxFlats);
909    CordRepRing* ring = CreateWithCapacity(MakeFlat("Head"), flats.size());
910    CordRep* child = RefIfInputSharedIndirect(FromFlats(flats, composition));
911    CordRep* stripped = RefIfInputShared(MakeSubstring(11, 3, child));
912    CordRepRing* result = NeedsUnref(CordRepRing::Append(ring, stripped));
913    ASSERT_THAT(result, IsValidRingBuffer());
914    EXPECT_THAT(result, EqIfPrivateAndCapacity(GetParam(), ring));
915    EXPECT_THAT(result, NeIfShared(GetParam(), ring));
916    EXPECT_THAT(ToFlats(result), ElementsAre("Head", "row"));
917  }
918  TEST_P(CordRingBuildInputTest, AppendRingSinglePieceWithPrefix) {
919    auto composition = RandomComposition();
920    SCOPED_TRACE(ToString(composition));
921    auto flats = MakeSpan(kFoxFlats);
922    size_t extra_capacity = 1 + (GetParam().with_capacity ? flats.size() : 0);
923    CordRepRing* ring = CordRepRing::Create(MakeFlat("Head"), extra_capacity);
924    ring->SetCapacityForTesting(1 + extra_capacity);
925    ring = RefIfShared(CordRepRing::Prepend(ring, MakeFlat("Prepend")));
926    assert(ring->IsValid(std::cout));
927    CordRepRing* child = RefIfInputSharedIndirect(FromFlats(flats, composition));
928    CordRep* stripped = RefIfInputShared(MakeSubstring(11, 3, child));
929    CordRepRing* result = NeedsUnref(CordRepRing::Append(ring, stripped));
930    ASSERT_THAT(result, IsValidRingBuffer());
931    EXPECT_THAT(result, EqIfPrivateAndCapacity(GetParam(), ring));
932    EXPECT_THAT(result, NeIfShared(GetParam(), ring));
933    EXPECT_THAT(ToFlats(result), ElementsAre("Prepend", "Head", "row"));
934  }
935  TEST_P(CordRingBuildInputTest, PrependRing) {
936    auto composition = RandomComposition();
937    SCOPED_TRACE(ToString(composition));
938    auto fox = MakeSpan(kFoxFlats);
939    auto flats = MakeSpan(fox).subspan(0, fox.size() - 1);
940    CordRepRing* ring = CreateWithCapacity(MakeFlat(fox.back()), flats.size());
941    CordRepRing* child = RefIfInputShared(FromFlats(flats, composition));
942    CordRepRing* result = NeedsUnref(CordRepRing::Prepend(ring, child));
943    ASSERT_THAT(result, IsValidRingBuffer());
944    EXPECT_THAT(result, EqIfPrivateAndCapacity(GetParam(), ring));
945    EXPECT_THAT(result, NeIfShared(GetParam(), ring));
946    EXPECT_THAT(ToFlats(result), ElementsAreArray(kFoxFlats));
947  }
948  TEST_P(CordRingBuildInputTest, PrependRingWithFlatOffset) {
949    auto composition = RandomComposition();
950    SCOPED_TRACE(ToString(composition));
951    auto flats = MakeSpan(kFoxFlats);
952    CordRepRing* ring = CreateWithCapacity(MakeFlat("Tail"), flats.size());
953    CordRep* child = RefIfInputShared(FromFlats(flats, composition));
954    CordRep* stripped = RefIfInputSharedIndirect(RemovePrefix(10, child));
955    CordRepRing* result = NeedsUnref(CordRepRing::Prepend(ring, stripped));
956    ASSERT_THAT(result, IsValidRingBuffer());
957    EXPECT_THAT(result, EqIfPrivateAndCapacity(GetParam(), ring));
958    EXPECT_THAT(result, NeIfShared(GetParam(), ring));
959    EXPECT_THAT(ToFlats(result), ElementsAre("brown ", "fox ", "jumps ", "over ",
960                                             "the ", "lazy ", "dog", "Tail"));
961  }
962  TEST_P(CordRingBuildInputTest, PrependRingWithBrokenOffset) {
963    auto composition = RandomComposition();
964    SCOPED_TRACE(ToString(composition));
965    auto flats = MakeSpan(kFoxFlats);
966    CordRepRing* ring = CreateWithCapacity(MakeFlat("Tail"), flats.size());
967    CordRep* child = RefIfInputShared(FromFlats(flats, composition));
968    CordRep* stripped = RefIfInputSharedIndirect(RemovePrefix(21, child));
969    CordRepRing* result = NeedsUnref(CordRepRing::Prepend(ring, stripped));
970    EXPECT_THAT(result, EqIfPrivateAndCapacity(GetParam(), ring));
971    EXPECT_THAT(result, NeIfShared(GetParam(), ring));
972    EXPECT_THAT(ToFlats(result),
973                ElementsAre("umps ", "over ", "the ", "lazy ", "dog", "Tail"));
974  }
975  TEST_P(CordRingBuildInputTest, PrependRingWithFlatLength) {
976    auto composition = RandomComposition();
977    SCOPED_TRACE(ToString(composition));
978    auto flats = MakeSpan(kFoxFlats);
979    CordRepRing* ring = CreateWithCapacity(MakeFlat("Tail"), flats.size());
980    CordRep* child = RefIfInputShared(FromFlats(flats, composition));
981    CordRep* stripped = RefIfInputSharedIndirect(RemoveSuffix(8, child));
982    CordRepRing* result = NeedsUnref(CordRepRing::Prepend(ring, stripped));
983    ASSERT_THAT(result, IsValidRingBuffer());
984    EXPECT_THAT(result, EqIfPrivateAndCapacity(GetParam(), ring));
985    EXPECT_THAT(result, NeIfShared(GetParam(), ring));
986    EXPECT_THAT(ToFlats(result), ElementsAre("The ", "quick ", "brown ", "fox ",
987                                             "jumps ", "over ", "the ", "Tail"));
988  }
989  TEST_P(CordRingBuildInputTest, PrependRingWithBrokenFlatLength) {
990    auto composition = RandomComposition();
991    SCOPED_TRACE(ToString(composition));
992    auto flats = MakeSpan(kFoxFlats);
993    CordRepRing* ring = CreateWithCapacity(MakeFlat("Tail"), flats.size());
994    CordRep* child = RefIfInputShared(FromFlats(flats, composition));
995    CordRep* stripped = RefIfInputSharedIndirect(RemoveSuffix(15, child));
996    CordRepRing* result = NeedsUnref(CordRepRing::Prepend(ring, stripped));
997    ASSERT_THAT(result, IsValidRingBuffer());
998    EXPECT_THAT(result, EqIfPrivateAndCapacity(GetParam(), ring));
999    EXPECT_THAT(result, NeIfShared(GetParam(), ring));
1000    EXPECT_THAT(ToFlats(result), ElementsAre("The ", "quick ", "brown ", "fox ",
1001                                             "jumps ", "ov", "Tail"));
1002  }
1003  TEST_P(CordRingBuildInputTest, PrependRingMiddlePiece) {
1004    auto composition = RandomComposition();
1005    SCOPED_TRACE(ToString(composition));
1006    auto flats = MakeSpan(kFoxFlats);
1007    CordRepRing* ring = CreateWithCapacity(MakeFlat("Tail"), flats.size());
1008    CordRep* child = RefIfInputShared(FromFlats(flats, composition));
1009    CordRep* stripped =
1010        RefIfInputSharedIndirect(MakeSubstring(7, child->length - 27, child));
1011    CordRepRing* result = NeedsUnref(CordRepRing::Prepend(ring, stripped));
1012    ASSERT_THAT(result, IsValidRingBuffer());
1013    EXPECT_THAT(result, EqIfPrivateAndCapacity(GetParam(), ring));
1014    EXPECT_THAT(result, NeIfShared(GetParam(), ring));
1015    EXPECT_THAT(ToFlats(result),
1016                ElementsAre("ck ", "brown ", "fox ", "jum", "Tail"));
1017  }
1018  TEST_P(CordRingBuildInputTest, PrependRingSinglePiece) {
1019    auto composition = RandomComposition();
1020    SCOPED_TRACE(ToString(composition));
1021    auto flats = MakeSpan(kFoxFlats);
1022    CordRepRing* ring = CreateWithCapacity(MakeFlat("Tail"), flats.size());
1023    CordRep* child = RefIfInputShared(FromFlats(flats, composition));
1024    CordRep* stripped = RefIfInputSharedIndirect(MakeSubstring(11, 3, child));
1025    CordRepRing* result = NeedsUnref(CordRepRing::Prepend(ring, stripped));
1026    ASSERT_THAT(result, IsValidRingBuffer());
1027    EXPECT_THAT(result, EqIfPrivateAndCapacity(GetParam(), ring));
1028    EXPECT_THAT(result, NeIfShared(GetParam(), ring));
1029    EXPECT_THAT(ToFlats(result), ElementsAre("row", "Tail"));
1030  }
1031  TEST_P(CordRingBuildInputTest, PrependRingSinglePieceWithPrefix) {
1032    auto composition = RandomComposition();
1033    SCOPED_TRACE(ToString(composition));
1034    auto flats = MakeSpan(kFoxFlats);
1035    size_t extra_capacity = 1 + (GetParam().with_capacity ? flats.size() : 0);
1036    CordRepRing* ring = CordRepRing::Create(MakeFlat("Tail"), extra_capacity);
1037    ring->SetCapacityForTesting(1 + extra_capacity);
1038    ring = RefIfShared(CordRepRing::Prepend(ring, MakeFlat("Prepend")));
1039    CordRep* child = RefIfInputShared(FromFlats(flats, composition));
1040    CordRep* stripped = RefIfInputSharedIndirect(MakeSubstring(11, 3, child));
1041    CordRepRing* result = NeedsUnref(CordRepRing::Prepend(ring, stripped));
1042    ASSERT_THAT(result, IsValidRingBuffer());
1043    EXPECT_THAT(result, EqIfPrivateAndCapacity(GetParam(), ring));
1044    EXPECT_THAT(result, NeIfShared(GetParam(), ring));
1045    EXPECT_THAT(ToFlats(result), ElementsAre("row", "Prepend", "Tail"));
1046  }
1047  TEST_F(CordRingTest, Find) {
1048    constexpr const char* flats[] = {
1049        "abcdefghij", "klmnopqrst", "uvwxyz",     "ABCDEFGHIJ",
1050        "KLMNOPQRST", "UVWXYZ",     "1234567890", "~!@#$%^&*()_",
1051        "+-=",        "[]\\{}|;':", ",/<>?",      "."};
1052    auto composition = RandomComposition();
1053    SCOPED_TRACE(ToString(composition));
1054    CordRepRing* ring = NeedsUnref(FromFlats(flats, composition));
1055    std::string value = ToString(ring);
1056    for (int i = 0; i < value.length(); ++i) {
1057      CordRepRing::Position found = ring->Find(i);
1058      auto data = ring->entry_data(found.index);
1059      ASSERT_THAT(found.offset, Lt(data.length()));
1060      ASSERT_THAT(data[found.offset], Eq(value[i]));
1061    }
1062  }
1063  TEST_F(CordRingTest, FindWithHint) {
1064    constexpr const char* flats[] = {
1065        "abcdefghij", "klmnopqrst", "uvwxyz",     "ABCDEFGHIJ",
1066        "KLMNOPQRST", "UVWXYZ",     "1234567890", "~!@#$%^&*()_",
1067        "+-=",        "[]\\{}|;':", ",/<>?",      "."};
1068    auto composition = RandomComposition();
1069    SCOPED_TRACE(ToString(composition));
1070    CordRepRing* ring = NeedsUnref(FromFlats(flats, composition));
1071    std::string value = ToString(ring);
1072  #if defined(GTEST_HAS_DEATH_TEST)
1073    index_type head = ring->head();
1074    EXPECT_DEBUG_DEATH(ring->Find(ring->advance(head), 0), ".*");
1075    EXPECT_DEBUG_DEATH(ring->Find(ring->advance(head), 9), ".*");
1076    EXPECT_DEBUG_DEATH(ring->Find(ring->advance(head, 3), 24), ".*");
1077  #endif
1078    int flat_pos = 0;
1079    size_t flat_offset = 0;
1080    for (auto sflat : flats) {
1081      string_view flat(sflat);
1082      for (int offset = 0; offset < flat.length(); ++offset) {
1083        for (int start = 0; start <= flat_pos; ++start) {
1084          index_type hint = ring->advance(ring->head(), start);
1085          CordRepRing::Position found = ring->Find(hint, flat_offset + offset);
1086          ASSERT_THAT(found.index, Eq(ring->advance(ring->head(), flat_pos)));
1087          ASSERT_THAT(found.offset, Eq(offset));
1088        }
1089      }
1090      ++flat_pos;
1091      flat_offset += flat.length();
1092    }
1093  }
1094  TEST_F(CordRingTest, FindInLargeRing) {
1095    constexpr const char* flats[] = {
1096        "abcdefghij", "klmnopqrst", "uvwxyz",     "ABCDEFGHIJ",
1097        "KLMNOPQRST", "UVWXYZ",     "1234567890", "~!@#$%^&*()_",
1098        "+-=",        "[]\\{}|;':", ",/<>?",      "."};
1099    auto composition = RandomComposition();
1100    SCOPED_TRACE(ToString(composition));
1101    CordRepRing* ring = FromFlats(flats, composition);
1102    for (int i = 0; i < 13; ++i) {
1103      ring = CordRepRing::Append(ring, FromFlats(flats, composition));
1104    }
1105    NeedsUnref(ring);
1106    std::string value = ToString(ring);
1107    for (int i = 0; i < value.length(); ++i) {
1108      CordRepRing::Position pos = ring->Find(i);
1109      auto data = ring->entry_data(pos.index);
1110      ASSERT_THAT(pos.offset, Lt(data.length()));
1111      ASSERT_THAT(data[pos.offset], Eq(value[i]));
1112    }
1113  }
1114  TEST_F(CordRingTest, FindTail) {
1115    constexpr const char* flats[] = {
1116        "abcdefghij", "klmnopqrst", "uvwxyz",     "ABCDEFGHIJ",
1117        "KLMNOPQRST", "UVWXYZ",     "1234567890", "~!@#$%^&*()_",
1118        "+-=",        "[]\\{}|;':", ",/<>?",      "."};
1119    auto composition = RandomComposition();
1120    SCOPED_TRACE(ToString(composition));
1121    CordRepRing* ring = NeedsUnref(FromFlats(flats, composition));
1122    std::string value = ToString(ring);
1123    for (int i = 0; i < value.length(); ++i) {
1124      CordRepRing::Position pos = ring->FindTail(i + 1);
1125      auto data = ring->entry_data(ring->retreat(pos.index));
1126      ASSERT_THAT(pos.offset, Lt(data.length()));
1127      ASSERT_THAT(data[data.length() - pos.offset - 1], Eq(value[i]));
1128    }
1129  }
1130  TEST_F(CordRingTest, FindTailWithHint) {
1131    constexpr const char* flats[] = {
1132        "abcdefghij", "klmnopqrst", "uvwxyz",     "ABCDEFGHIJ",
1133        "KLMNOPQRST", "UVWXYZ",     "1234567890", "~!@#$%^&*()_",
1134        "+-=",        "[]\\{}|;':", ",/<>?",      "."};
1135    auto composition = RandomComposition();
1136    SCOPED_TRACE(ToString(composition));
1137    CordRepRing* ring = NeedsUnref(FromFlats(flats, composition));
1138    std::string value = ToString(ring);
1139  #if defined(GTEST_HAS_DEATH_TEST)
1140    index_type head = ring->head();
1141    EXPECT_DEBUG_DEATH(ring->FindTail(ring->advance(head), 1), ".*");
1142    EXPECT_DEBUG_DEATH(ring->FindTail(ring->advance(head), 10), ".*");
1143    EXPECT_DEBUG_DEATH(ring->FindTail(ring->advance(head, 3), 26), ".*");
1144  #endif
1145    for (int i = 0; i < value.length(); ++i) {
1146      CordRepRing::Position pos = ring->FindTail(i + 1);
1147      auto data = ring->entry_data(ring->retreat(pos.index));
1148      ASSERT_THAT(pos.offset, Lt(data.length()));
1149      ASSERT_THAT(data[data.length() - pos.offset - 1], Eq(value[i]));
1150    }
1151  }
1152  TEST_F(CordRingTest, FindTailInLargeRing) {
1153    constexpr const char* flats[] = {
1154        "abcdefghij", "klmnopqrst", "uvwxyz",     "ABCDEFGHIJ",
1155        "KLMNOPQRST", "UVWXYZ",     "1234567890", "~!@#$%^&*()_",
1156        "+-=",        "[]\\{}|;':", ",/<>?",      "."};
1157    auto composition = RandomComposition();
1158    SCOPED_TRACE(ToString(composition));
1159    CordRepRing* ring = FromFlats(flats, composition);
1160    for (int i = 0; i < 13; ++i) {
1161      ring = CordRepRing::Append(ring, FromFlats(flats, composition));
1162    }
1163    NeedsUnref(ring);
1164    std::string value = ToString(ring);
1165    for (int i = 0; i < value.length(); ++i) {
1166      CordRepRing::Position pos = ring->FindTail(i + 1);
1167      auto data = ring->entry_data(ring->retreat(pos.index));
1168      ASSERT_THAT(pos.offset, Lt(data.length()));
1169      ASSERT_THAT(data[data.length() - pos.offset - 1], Eq(value[i]));
1170    }
1171  }
1172  TEST_F(CordRingTest, GetCharacter) {
1173    auto flats = MakeSpan(kFoxFlats);
1174    CordRepRing* ring = CordRepRing::Create(MakeFlat("Tail"), flats.size());
1175    CordRep* child = FromFlats(flats, kAppend);
1176    CordRepRing* result = NeedsUnref(CordRepRing::Prepend(ring, child));
1177    std::string value = ToString(result);
1178    for (int i = 0; i < value.length(); ++i) {
1179      ASSERT_THAT(result->GetCharacter(i), Eq(value[i]));
1180    }
1181  }
1182  TEST_F(CordRingTest, GetCharacterWithSubstring) {
1183    absl::string_view str1 = "abcdefghijklmnopqrstuvwxyz";
1184    auto* child = MakeSubstring(4, 20, MakeFlat(str1));
1185    CordRepRing* result = NeedsUnref(CordRepRing::Create(child));
1186    ASSERT_THAT(result, IsValidRingBuffer());
1187    std::string value = ToString(result);
1188    for (int i = 0; i < value.length(); ++i) {
1189      ASSERT_THAT(result->GetCharacter(i), Eq(value[i]));
1190    }
1191  }
1192  TEST_F(CordRingTest, IsFlatSingleFlat) {
1193    for (bool external : {false, true}) {
1194      SCOPED_TRACE(external ? "With External" : "With Flat");
1195      absl::string_view str = "Hello world";
1196      CordRep* rep = external ? MakeExternal(str) : MakeFlat(str);
1197      CordRepRing* ring = NeedsUnref(CordRepRing::Create(rep));
1198      absl::string_view fragment;
1199      EXPECT_TRUE(ring->IsFlat(nullptr));
1200      EXPECT_TRUE(ring->IsFlat(&fragment));
1201      EXPECT_THAT(fragment, Eq("Hello world"));
<span onclick='openModal()' class='match'>1202      fragment = "";
1203      EXPECT_TRUE(ring->IsFlat(0, 11, nullptr));
1204      EXPECT_TRUE(ring->IsFlat(0, 11, &fragment));
1205      EXPECT_THAT(fragment, Eq("Hello world"));
1206      EXPECT_TRUE(ring->IsFlat(1, 4, &fragment));
1207      EXPECT_THAT(fragment, Eq("ello"));
1208      EXPECT_TRUE(ring->IsFlat(6, 5, &fragment));
1209      EXPECT_THAT(fragment, Eq("world"));
1210    }
</span>1211  }
1212  TEST_F(CordRingTest, IsFlatMultiFlat) {
1213    for (bool external : {false, true}) {
1214      SCOPED_TRACE(external ? "With External" : "With Flat");
1215      absl::string_view str1 = "Hello world";
1216      absl::string_view str2 = "Halt and catch fire";
1217      CordRep* rep1 = external ? MakeExternal(str1) : MakeFlat(str1);
1218      CordRep* rep2 = external ? MakeExternal(str2) : MakeFlat(str2);
1219      CordRepRing* ring = CordRepRing::Append(CordRepRing::Create(rep1), rep2);
1220      NeedsUnref(ring);
1221      EXPECT_FALSE(ring->IsFlat(nullptr));
1222      absl::string_view fragment = "Don't touch this";
1223      EXPECT_FALSE(ring->IsFlat(&fragment));
1224      EXPECT_THAT(fragment, Eq("Don't touch this"));
1225      EXPECT_TRUE(ring->IsFlat(0, 11, &fragment));
1226      EXPECT_THAT(fragment, Eq("Hello world"));
1227      EXPECT_TRUE(ring->IsFlat(11, 19, &fragment));
1228      EXPECT_THAT(fragment, Eq("Halt and catch fire"));
1229      EXPECT_TRUE(ring->IsFlat(1, 4, &fragment));
1230      EXPECT_THAT(fragment, "ello");
1231      EXPECT_TRUE(ring->IsFlat(26, 4, &fragment));
1232      EXPECT_THAT(fragment, "fire");
1233      fragment = "Don't touch this";
1234      EXPECT_FALSE(ring->IsFlat(1, 18, &fragment));
1235      EXPECT_FALSE(ring->IsFlat(10, 2, &fragment));
1236      EXPECT_THAT(fragment, Eq("Don't touch this"));
1237    }
1238  }
1239  TEST_F(CordRingTest, Dump) {
1240    std::stringstream ss;
1241    auto flats = MakeSpan(kFoxFlats);
1242    CordRepRing* ring = NeedsUnref(FromFlats(flats, kPrepend));
1243    ss << *ring;
1244  }
1245  }  
1246  ABSL_NAMESPACE_END
1247  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cord_rep_btree_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cord_ring_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>824    fragment = "";
825    EXPECT_TRUE(leaf->IsFlat(0, 11, nullptr));
826    EXPECT_TRUE(leaf->IsFlat(0, 11, &fragment));
827    EXPECT_THAT(fragment, Eq("Hello world"));
828    EXPECT_TRUE(leaf->IsFlat(1, 4, &fragment));
829    EXPECT_THAT(fragment, Eq("ello"));
830    EXPECT_TRUE(leaf->IsFlat(6, 5, &fragment));
831    EXPECT_THAT(fragment, Eq("world"));
832    CordRep::Unref(leaf);
</pre></code></div>
                <div class="column column_space"><pre><code>1202      fragment = "";
1203      EXPECT_TRUE(ring->IsFlat(0, 11, nullptr));
1204      EXPECT_TRUE(ring->IsFlat(0, 11, &fragment));
1205      EXPECT_THAT(fragment, Eq("Hello world"));
1206      EXPECT_TRUE(ring->IsFlat(1, 4, &fragment));
1207      EXPECT_THAT(fragment, Eq("ello"));
1208      EXPECT_TRUE(ring->IsFlat(6, 5, &fragment));
1209      EXPECT_THAT(fragment, Eq("world"));
1210    }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    