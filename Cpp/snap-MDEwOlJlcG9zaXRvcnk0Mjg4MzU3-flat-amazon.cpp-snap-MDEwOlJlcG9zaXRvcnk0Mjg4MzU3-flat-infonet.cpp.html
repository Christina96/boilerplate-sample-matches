
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.933194154488518%, Tokens: 12</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-amazon.cpp</h3>
            <pre><code>1  #include "amazon.h"
2  #include "net.h"
3  TStr TAmazonItem::GetStr() const {
4    TChA ChA;
5    ChA+=ItemId;
6    ChA+=' ';
7    ChA+=TitleStr;
8    for (int AuthorNmN=0; AuthorNmN<AuthorNmV.Len(); AuthorNmN++){
9      if (AuthorNmN==0){ChA+=": ";} else {ChA+=", ";}
10      ChA+=AuthorNmV[AuthorNmN];
11    }
12    return ChA;
13  }
14  PAmazonItem TAmazonItem::New(const PXmlDoc& XmlDoc){
15    PAmazonItem AmazonItem=PAmazonItem(new TAmazonItem());
16    AmazonItem->ItemId=XmlDoc->GetTagTok("AmazonItem|ItemId")->GetTokStr(false);
17    AmazonItem->TitleStr=XmlDoc->GetTagTok("AmazonItem|Title")->GetTokStr(false);
18    TXmlTokV AuthorNmTokV;
19    XmlDoc->GetTagTokV("AmazonItem|Authors|Name", AuthorNmTokV);
20    for (int AuthorNmTokN=0; AuthorNmTokN<AuthorNmTokV.Len(); AuthorNmTokN++){
21      PXmlTok AuthorNmTok=AuthorNmTokV[AuthorNmTokN];
22      TStr AuthorNm=AuthorNmTok->GetTokStr(false);
23      AmazonItem->AuthorNmV.Add(AuthorNm);
24    }
25    TXmlTokV NextItemIdTokV;
26    XmlDoc->GetTagTokV("AmazonItem|XSell|ItemId", NextItemIdTokV);
27    for (int ItemIdTokN=0; ItemIdTokN<NextItemIdTokV.Len(); ItemIdTokN++){
28      PXmlTok NextItemIdTok=NextItemIdTokV[ItemIdTokN];
29      TStr NextItemId=NextItemIdTok->GetTokStr(false);
30      AmazonItem->NextItemIdV.Add(NextItemId);
31    }
32    return AmazonItem;
33  }
34  PXmlDoc TAmazonItem::GetXmlDoc() const {
35    PXmlTok ItemXmlTok=TXmlTok::New(xsyTag, "AmazonItem");
36    PXmlTok ItemIdTxtXmlTok=TXmlTok::New(xsyStr, ItemId);
37    PXmlTok ItemIdXmlTok=TXmlTok::New(xsyTag, "ItemId");
38    ItemIdXmlTok->AddSubTok(ItemIdTxtXmlTok);
39    ItemXmlTok->AddSubTok(ItemIdXmlTok);
40    PXmlTok TitleTxtXmlTok=TXmlTok::New(xsyStr, TitleStr);
41    PXmlTok TitleXmlTok=TXmlTok::New(xsyTag, "Title");
42    TitleXmlTok->AddSubTok(TitleTxtXmlTok);
43    ItemXmlTok->AddSubTok(TitleXmlTok);
44    PXmlTok AuthorsXmlTok=TXmlTok::New(xsyTag, "Authors");
45    ItemXmlTok->AddSubTok(AuthorsXmlTok);
46    for (int AuthorNmN=0; AuthorNmN<GetAuthorNms(); AuthorNmN++){
47      PXmlTok NameXmlTok=TXmlTok::New(xsyTag, "Name");
48      AuthorsXmlTok->AddSubTok(NameXmlTok);
49      PXmlTok NameTxtXmlTok=TXmlTok::New(xsyStr, GetAuthorNm(AuthorNmN));
50      NameXmlTok->AddSubTok(NameTxtXmlTok);
51    }
52    PXmlTok XSellXmlTok=TXmlTok::New(xsyTag, "XSell");
53    ItemXmlTok->AddSubTok(XSellXmlTok);
54    for (int NextItemId=0; NextItemId<GetNextItemIds(); NextItemId++){
55      PXmlTok ItemIdXmlTok=TXmlTok::New(xsyTag, "ItemId");
56      XSellXmlTok->AddSubTok(ItemIdXmlTok);
57      PXmlTok ItemIdTxtXmlTok=TXmlTok::New(xsyStr, GetNextItemId(NextItemId));
58      ItemIdXmlTok->AddSubTok(ItemIdTxtXmlTok);
59    }
60    PXmlDoc ItemXmlDoc=TXmlDoc::New(ItemXmlTok);
61    return ItemXmlDoc;
62  }
63  PAmazonItem TAmazonItem::GetFromWebPg(const PWebPg& WebPg){
64    TStr UrlStr=WebPg->GetUrlStr();
65    TStr ItemId=TAmazonItem::GetItemId(WebPg->GetUrl());
66    TStr HtmlStr=WebPg->GetHttpBodyAsStr();
67    PSIn HtmlSIn=TStrIn::New(HtmlStr);
68    THtmlLx HtmlLx(HtmlSIn);
69    THtmlLxSym Sym; TChA ChA;
70    while (HtmlLx.GetSym()!=hsyEof){
71      Sym=HtmlLx.Sym; ChA=HtmlLx.ChA;
72      if ((Sym==hsyBTag)&&(ChA=="<FONT>")){
73        TStr FaceArg=HtmlLx.GetArg("FACE", "");
74        TStr SizeArg=HtmlLx.GetArg("SIZE", "");
75        if ((FaceArg=="verdana,arial,helvetica")&&(SizeArg.Empty())){break;}
76      }
77    }
78    TChA TitleChA;
79    while (HtmlLx.GetSym()!=hsyEof){
80      Sym=HtmlLx.Sym; ChA=HtmlLx.ChA;
81      if ((Sym==hsyETag)&&(ChA=="<FONT>")){break;}
82      if (!TitleChA.Empty()){TitleChA+=HtmlLx.GetPreSpaceStr();}
83      TitleChA+=ChA;
84    }
85    TStr TitleStr=TitleChA;
86    TStrV AuthorNmV;
87    TChA AuthorNmChA;
88    while (HtmlLx.GetSym()!=hsyEof){
89      Sym=HtmlLx.Sym; ChA=HtmlLx.ChA;
90      if ((Sym==hsyBTag)&&(ChA=="<A>")){
91        do {
92          HtmlLx.GetSym();
93          Sym=HtmlLx.Sym; ChA=HtmlLx.ChA;
94          if (Sym==hsyStr){
95            if (!AuthorNmChA.Empty()){AuthorNmChA+=HtmlLx.GetPreSpaceStr();}
96            AuthorNmChA+=ChA;
97          }
98        } while (!((Sym==hsyETag)&&(ChA=="<A>")));
99        AuthorNmV.Add(AuthorNmChA); AuthorNmChA.Clr();
100      }
101      if ((Sym==hsyETag)&&(ChA=="<FONT>")){break;}
102    }
103    for (int AuthorNmN=0; AuthorNmN<AuthorNmV.Len(); AuthorNmN++){
104    }
105    TStrQ PrevStrQ(3);
106    while (HtmlLx.GetSym()!=hsyEof){
107      Sym=HtmlLx.Sym; ChA=HtmlLx.ChA;
108      if (Sym==hsyStr){
109        PrevStrQ.Push(ChA);
110        if ((PrevStrQ.Len()==3)&&(PrevStrQ[0]=="Customers")
111         &&(PrevStrQ[1]=="who")&&(PrevStrQ[2]=="bought")){break;}
112      } else {
113        PrevStrQ.Clr();
114      }
115    }
116    TStrV NextItemIdV;
117    while (HtmlLx.GetSym()!=hsyEof){
118      Sym=HtmlLx.Sym; ChA=HtmlLx.ChA;
119      if ((Sym==hsyBTag)&&(ChA=="<A>")){
120        TStr RelUrlStr=HtmlLx.GetArg("HREF");
121        PUrl Url=TUrl::New(RelUrlStr, UrlStr);
122        TStr NextItemId=TAmazonItem::GetItemId(Url);
123        NextItemIdV.Add(NextItemId);
124      }
125      if ((Sym==hsyETag)&&(ChA=="<UL>")){break;}
126    }
127    for (int NextItemIdN=0; NextItemIdN<NextItemIdV.Len(); NextItemIdN++){
128    }
129    PAmazonItem AmazonItem=PAmazonItem(new
130     TAmazonItem(ItemId, TitleStr, AuthorNmV, NextItemIdV));
131    return AmazonItem;
132  }
133  void TAmazonItemBs::AddItemBs(const PAmazonItemBs& AmazonItemBs){
134    for (int ItemIdN=0; ItemIdN<AmazonItemBs->GetItems(); ItemIdN++){
135      PAmazonItem Item=AmazonItemBs->GetItem(ItemIdN);
136      AddItem(Item);
137    }
138  }
139  void TAmazonItemBs::GetVoidItemIdV(TStrV& VoidItemIdV) const {
140    VoidItemIdV.Clr();
141    for (int ItemIdN=0; ItemIdN<GetItems(); ItemIdN++){
142      PAmazonItem Item=GetItem(ItemIdN);
143      for (int NextItemIdN=0; NextItemIdN<Item->GetNextItemIds(); NextItemIdN++){
144        TStr NextItemId=Item->GetNextItemId(NextItemIdN);
145        if (!IsItem(NextItemId)){VoidItemIdV.AddUnique(NextItemId);}
146      }
147    }
148  }
149  PGraph TAmazonItemBs::GetGraph() const {
150    PGraph Graph=TGGraph::New();
151    for (int ItemIdN=0; ItemIdN<GetItems(); ItemIdN++){
152      PAmazonItem Item=GetItem(ItemIdN);
153      TStr VrtxNm=Item->GetStr();
154      PVrtx Vrtx=PVrtx(new TGVrtx(ItemIdN, VrtxNm));
155      Graph->AddVrtx(Vrtx);
156    }
157    for (int SrcItemIdN=0; SrcItemIdN<GetItems(); SrcItemIdN++){
158      PVrtx SrcVrtx=Graph->GetVrtx(SrcItemIdN);
159      PAmazonItem SrcItem=GetItem(SrcItemIdN);
160      for (int NextItemIdN=0; NextItemIdN<SrcItem->GetNextItemIds(); NextItemIdN++){
161        TStr DstItemId=SrcItem->GetNextItemId(NextItemIdN);
162        if (IsItem(DstItemId)){
163          int DstItemIdN=GetItemIdN(DstItemId);
164          PVrtx DstVrtx=Graph->GetVrtx(DstItemIdN);
165          PEdge Edge=PEdge(new TGEdge(SrcVrtx, DstVrtx));
166          Graph->AddEdge(Edge);
167        }
168      }
169      if (SrcItemIdN%1000==0){printf("%d items converted\r", SrcItemIdN);}
170    }
171    printf("%d items converted\n", GetItems());
172    return Graph;
173  }
174  PAmazonItemBs TAmazonItemBs::LoadXml(const TStr& FNm, const int& MxItems){
175    PAmazonItemBs AmazonItemBs=TAmazonItemBs::New();
176    PSIn XmlSIn=TFIn::New(FNm);
177    forever {
178      PXmlDoc XmlDoc=TXmlDoc::LoadTxt(XmlSIn);
179      if (!XmlDoc->IsOk()){break;}
180      PAmazonItem AmazonItem=TAmazonItem::New(XmlDoc);
181      AmazonItemBs->AddItem(AmazonItem);
182      if (AmazonItemBs->GetItems()%1000==0){
183        printf("%d items loaded\r", AmazonItemBs->GetItems());}
184      if ((MxItems!=-1)&&(AmazonItemBs->GetItems()>=MxItems)){break;}
185    }
186    printf("%d items loaded\n", AmazonItemBs->GetItems());
187    return AmazonItemBs;
188  }
189  void TAmazonItemBs::SaveXml(const TStr& FNm){
190    PSOut XmlSOut=TFOut::New(FNm);
191    for (int ItemIdN=0; ItemIdN<GetItems(); ItemIdN++){
192      PAmazonItem Item=GetItem(ItemIdN);
193      PXmlDoc XmlDoc=Item->GetXmlDoc();
194      XmlDoc->SaveTxt(XmlSOut); XmlSOut->PutDosLn();
195    }
196  }
197  TAmazonFetch::TAmazonFetch():
198    TWebPgFetch(), ItemItemIdH(100000), XmlSOut(){
199    PutMxConns(30);
200    XmlSOut=TFOut::New("amazon.xml");
201  }
202  PAmazonFetch TAmazonFetch::New(const TStr& FNm){
203    PAmazonFetch AmazonFetch=New();
204    if (!FNm.Empty()){
205      PSIn XmlSIn=TFIn::New(FNm);
206      forever {
207        PXmlDoc XmlDoc=TXmlDoc::LoadTxt(XmlSIn);
208        if (!XmlDoc->IsOk()){break;}
209        TStr ItemId=XmlDoc->GetTagTok("AmazonItem|ItemId")->GetTokStr(false);
210        AmazonFetch->AddItem(ItemId);
211        if (AmazonFetch->GetItems()%1000==0){
212          printf("%d items loaded\r", AmazonFetch->GetItems());}
213      }
214      printf("%d items loaded\n", AmazonFetch->GetItems());
215    }
216    return AmazonFetch;
217  }
218  PAmazonFetch TAmazonFetch::New(const PAmazonItemBs& AmazonItemBs){
219    PAmazonFetch AmazonFetch=New();
220    for (int ItemIdN=0; ItemIdN<AmazonItemBs->GetItems(); ItemIdN++){
221      TStr ItemId=AmazonItemBs->GetItemId(ItemIdN);
222      AmazonFetch->AddItem(ItemId);
223    }
224    return AmazonFetch;
225  }
226  void TAmazonFetch::FetchItemIdV(const TStrV& ItemIdV){
227    for (int ItemIdN=0; ItemIdN<ItemIdV.Len(); ItemIdN++){
228      TStr UrlStr=TAmazonItem::GetUrlStr(ItemIdV[ItemIdN]);
229      FetchUrl(UrlStr);
230    }
231  }
232  void TAmazonFetch::OnFetch(const int&, const PWebPg& WebPg){
233    PAmazonItem AmazonItem=TAmazonItem::GetFromWebPg(WebPg);
<span onclick='openModal()' class='match'>234    if (!IsItem(AmazonItem->GetItemId())){
235      printf("'%s'\n", AmazonItem->GetTitleStr().CStr());
236      AddItem(AmazonItem->GetItemId());
237      PXmlDoc ItemXmlDoc=AmazonItem->GetXmlDoc();
238      ItemXmlDoc->SaveTxt(XmlSOut); XmlSOut->PutDosLn(); XmlSOut->Flush();
239      for (int ItemIdN=0; ItemIdN<AmazonItem->GetNextItemIds(); ItemIdN++){
240        TStr ItemId=AmazonItem->GetNextItemId(ItemIdN);
241        if (!IsItem(ItemId)){
242          TStr UrlStr=TAmazonItem::GetUrlStr(ItemId);
243          FetchUrl(UrlStr);
244        }
</span>245      }
246    }
247    printf("Active:%i Queue:%i Pages:%i\r",
248     GetConnUrls(), GetWaitUrls(), GetItems());
249    if (GetConnUrls()==0){TSysMsg::Quit();}
250  }
251  void TAmazonFetch::OnError(const int&, const TStr& MsgStr){
252    printf("*** Error: %s\n", MsgStr.CStr());
253    printf("Active:%i Queue:%i Pages:%i\r",
254     GetConnUrls(), GetWaitUrls(), GetItems());
255    if (GetConnUrls()==0){TSysMsg::Quit();}
256  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-infonet.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "infonet.h"
3  TStr TThermalSch::GetFldVal(const PXmlTok& RecXmlTok, const TStr& FldNm) const {
4    PXmlTok FldTagTok;
5    if (RecXmlTok->IsTagTok(FldNm, FldTagTok)){
6      return FldTagTok->GetTokStr(false);}
7    else {return "";}
8  }
9  TStr TThermalSch::GetFldVal(const PXmlDoc& RecXmlDoc, const TStr& FldNm) const {
10    PXmlTok FldTagTok;
11    if (RecXmlDoc->IsTagTok(FldNm, FldTagTok)){
12      return FldTagTok->GetTokStr(false);}
13    else {return "";}
14  }
15  TStr TThermalSch::GetFldDateVal(const PXmlTok& RecXmlTok, const TStr& FldNm) const {
16    TStr DateVal=TThermalSch::GetFldVal(RecXmlTok, FldNm);
17    DateVal.DelChAll('-');
18    return DateVal;
19  }
20  TStr TThermalSch::GetFldDateVal(const PXmlDoc& RecXmlDoc, const TStr& FldNm) const {
21    TStr DateVal=TThermalSch::GetFldVal(RecXmlDoc, FldNm);
22    DateVal.DelChAll('-');
23    return DateVal;
24  }
25  TStrV TThermalSch::GetFldValV(const PXmlTok& RecXmlTok, const TStr& FldNm,
26   const TStr& XFldNm, const TStr& SubFldNm) const {
27    TStrV FldValV;
28    PXmlTok FldTagTok;
29    if (RecXmlTok->IsTagTok(FldNm, FldTagTok)){
30      if (SubFldNm.Empty()){
31        FldTagTok->GetTagValV(XFldNm, false, FldValV);
32      } else {
33        TXmlTokV XmlTokV; FldTagTok->GetTagTokV(XFldNm, XmlTokV);
34        for (int FldN=0; FldN<XmlTokV.Len(); FldN++){
35          TStr FldVal=GetFldVal(XmlTokV[FldN], SubFldNm);
36          FldValV.Add(FldVal);
37        }
38      }
39    }
40    return FldValV;
41  }
42  TStr TThermalSch::GetXmlOut_Ok(const TStr& OpNm){
43    TChA ChA;
44    ChA+="<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
45    ChA+="<ParamOut>\n";
46    ChA+="<OperationName>";
47    ChA+=TXmlLx::GetXmlStrFromPlainStr(OpNm);
48    ChA+="</OperationName>\n";
49    ChA+="<Success>Ok</Success>\n";
50    ChA+="</ParamOut>\n";
51    return ChA;
52  }
53  TStr TThermalSch::GetXmlOut_Error(const TStr& OpNm, const TStr& MsgStr){
54    TChA ChA;
55    ChA+="<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
56    ChA+="<ParamOut>\n";
57    ChA+="<OperationName>";
58    ChA+=TXmlLx::GetXmlStrFromPlainStr(OpNm);
59    ChA+="</OperationName>\n";
60    ChA+="<Success>Error</Success>\n";
61    ChA+="<ResultMessage>";
62    ChA+=TXmlLx::GetXmlStrFromPlainStr(MsgStr);
63    ChA+="</ResultMessage>\n";
64    ChA+="</ParamOut>\n";
65    return ChA;
66  }
67  TStr TThermalSch::ExeCmFromXml(const PSIn& SIn){
68    PXmlDoc XmlDoc=TXmlDoc::LoadTxt(SIn);
69    if (XmlDoc->IsOk()){
70      TStr CmTagNm="Operation|OperationName";
71      if (XmlDoc->IsTagTok(CmTagNm)){
72        TStr CmNm=XmlDoc->GetTagTokStr(CmTagNm);
73        if (CmNm=="SetCatalogueTherapyPlaces"){
74          return ExeCm_SetCatalogueTherapyPlaces(XmlDoc);
75        } else if (CmNm=="SetCatalogueActivities"){
76          return ExeCm_SetCatalogueActivities(XmlDoc);
77        } else if (CmNm=="SetCatalogueAvailableTherapyPlaces"){
78          return ExeCm_SetCatalogueAvailableTherapyPlaces(XmlDoc);
79        } else if (CmNm=="SetCatalogueAvailableActivities"){
80          return ExeCm_SetCatalogueAvailableActivities(XmlDoc);
81        } else if (CmNm=="SetScheduledActivities"){
82          return ExeCm_SetScheduledActivities(XmlDoc);
83        } else if (CmNm=="SetCatalogueHolidays"){
84          return ExeCm_SetCatalogueHolidays(XmlDoc);
85        } else if (CmNm=="MakeSchedule"){
86          return ExeCm_MakeSchedule(XmlDoc);
87        } else if (CmNm=="CheckSchedule"){
88          return ExeCm_CheckSchedule(XmlDoc);
89        } else {
90          TStr CmXmlStr=TXmlLx::GetXmlStrFromPlainStr(CmNm);
91          return GetXmlOut_Error(CmXmlStr, TStr("Invalid Command: '")+CmXmlStr+"'.");
92        }
93      } else {
94        TStr CmTagXmlStr=TXmlLx::GetXmlStrFromPlainStr(CmTagNm);
95        return GetXmlOut_Error("NoCommand", TStr("Command tag not found: '")+CmTagXmlStr+"'.");
96      }
97    } else {
98      return GetXmlOut_Error("NoCommand", TStr("Invalid XML Format: '")+XmlDoc->GetMsgStr()+"'.");
99    }
100  }
101  TStr TThermalSch::ExeCmFromXmlFile(const TStr& FNm, const TStr& FPath){
102    TStr FullFNm=TStr::GetNrFPath(FPath)+FNm;
103    bool OpenedP;
104    PSIn SIn=TFIn::New(FullFNm, OpenedP);
105    if (OpenedP){
106      return ExeCmFromXml(SIn);
107    } else {
108      return GetXmlOut_Error("NoCommand", TStr("Can not open file: '")+FNm+"'.");
109    }
110  }
111  TStr TThermalSch::ExeCmFromXmlStr(const TStr& Str){
112    PSIn SIn=TStrIn::New(Str);
113    return ExeCmFromXml(SIn);
114  }
115  TStr TThermalSch::ExeCm_SetCatalogueTherapyPlaces(const PXmlDoc& XmlDoc){
116    TherapyPlacesXmlDoc=XmlDoc;
117    TStr MsgStr;
118    if (IsTherapyPlacesOk(MsgStr)){
119      return TThermalSch::GetXmlOut_Ok("SetCatalogueTherapyPlaces");
120    } else {
121      TherapyPlacesXmlDoc=NULL;
122      return MsgStr;
123    }
124  }
125  TStr TThermalSch::ExeCm_SetCatalogueActivities(const PXmlDoc& XmlDoc){
126    ActivitiesXmlDoc=XmlDoc;
127    TStr MsgStr;
128    if (IsActivitiesOk(MsgStr)){
129      return TThermalSch::GetXmlOut_Ok("SetCatalogueActivities");
130    } else {
131      ActivitiesXmlDoc=NULL;
132      return MsgStr;
133    }
134  }
135  TStr TThermalSch::ExeCm_SetCatalogueAvailableTherapyPlaces(const PXmlDoc& XmlDoc){
136    AvailableTherapyPlacesXmlDoc=XmlDoc;
137    TStr MsgStr;
138    if (IsAvailableTherapyPlacesOk(MsgStr)){
139      return TThermalSch::GetXmlOut_Ok("SetCatalogueAvailableTherapyPlaces");
140    } else {
141      AvailableTherapyPlacesXmlDoc=NULL;
142      return MsgStr;
143    }
144  }
145  TStr TThermalSch::ExeCm_SetCatalogueAvailableActivities(const PXmlDoc& XmlDoc){
146    AvailableActivitiesXmlDoc=XmlDoc;
147    TStr MsgStr;
148    if (IsAvailableActivitiesOk(MsgStr)){
149      return TThermalSch::GetXmlOut_Ok("SetCatalogueAvailableActivities");
150    } else {
151      AvailableActivitiesXmlDoc=NULL;
152      return MsgStr;
153    }
154  }
155  TStr TThermalSch::ExeCm_SetScheduledActivities(const PXmlDoc& XmlDoc){
156    ScheduledActivitiesXmlDoc=XmlDoc;
157    TStr MsgStr;
158    if (IsScheduledActivitiesOk(MsgStr)){
159      return TThermalSch::GetXmlOut_Ok("SetScheduledActivities");
160    } else {
161      ScheduledActivitiesXmlDoc=NULL;
162      return MsgStr;
163    }
164  }
165  TStr TThermalSch::ExeCm_SetCatalogueHolidays(const PXmlDoc& XmlDoc){
166    HolidaysXmlDoc=XmlDoc;
167    TStr MsgStr;
168    if (IsHolidaysOk(MsgStr)){
169      return TThermalSch::GetXmlOut_Ok("SetCatalogueHolidays");
170    } else {
171      HolidaysXmlDoc=NULL;
172      return MsgStr;
173    }
174  }
175  TStr TThermalSch::ExeCm_MakeSchedule(const PXmlDoc& XmlDoc){
176    MakeScheduleXmlDoc=XmlDoc;
177    TStr MsgStr;
178    if (IsMakeScheduleOk(MsgStr)){
179      SaveOldCsv();
180      TChA CmLn;
181      CmLn+="genscher.exe";
182      CmLn+=" -dir"; CmLn+=GetMakeSchedule_PatientATPCode();
183      CmLn+=" -pass";
184      system(CmLn.CStr());
185      TThermalSch::SaveCsvToXml("URNIKXXG.TXT", "URNIKXX0.TXT", "Out.Xml");
186      TThermalSch::SaveCsvToXmlParamOut("URNIKXXG.TXT", "URNIKXX0.TXT", "ParamOut.Xml");
187      TStr XmlStr=TStr::LoadTxt("ParamOut.Xml");
188      return XmlStr;
189    } else {
190      MakeScheduleXmlDoc=NULL;
191      return MsgStr;
192    }
193  }
194  TStr TThermalSch::ExeCm_CheckSchedule(const PXmlDoc& XmlDoc){
195    CheckScheduleXmlDoc=XmlDoc;
196    TStr MsgStr;
197    if (IsCheckScheduleOk(MsgStr)){
198      return TThermalSch::GetXmlOut_Ok("CheckSchedule");
199    } else {
200      CheckScheduleXmlDoc=NULL;
201      return MsgStr;
202    }
203  }
204  bool TThermalSch::IsTherapyPlacesOk(TStr& MsgStr) const {
205    if (TherapyPlacesXmlDoc.Empty()){
206      MsgStr=GetXmlOut_Error("SetCatalogueTherapyPlaces", "TherapyPlaces doesn't exists.");
207    }
208    int TherapyPlaces=TThermalSch::GetTherapyPlaces();
209    for (int TherapyPlaceN=0; TherapyPlaceN<TherapyPlaces; TherapyPlaceN++){
210      PXmlTok TherapyPlace=TThermalSch::GetTherapyPlace(TherapyPlaceN);
211      if (TherapyPlace->IsTag("TherapyPlace")){
212        GetTherapyPlace_Code(TherapyPlace);
213        GetTherapyPlace_Type(TherapyPlace);
214        GetTherapyPlace_Location(TherapyPlace);
215        GetTherapyPlace_Capacity(TherapyPlace);
216        GetTherapyPlace_Distance(TherapyPlace);
217        GetTherapyPlace_Gender(TherapyPlace);
218        GetTherapyPlace_AlternateScheduling(TherapyPlace);
219        GetTherapyPlace_FamilyScheduling(TherapyPlace);
220        GetTherapyPlace_TherapistType(TherapyPlace);
221      } else {
222        MsgStr=GetXmlOut_Error("SetCatalogueTherapyPlaces", "Invalid TherapyPlaces.");
223        return false;
224      }
225    }
226    return true;
227  }
228  int TThermalSch::GetTherapyPlaces() const {
229    if (TherapyPlacesXmlDoc.Empty()){return 0;}
230    TXmlTokV XmlTokV;
231    TherapyPlacesXmlDoc->GetTagTokV("Operation|Parameter|TherapyPlaces|TherapyPlace", XmlTokV);
232    return XmlTokV.Len();
233  }
234  PXmlTok TThermalSch::GetTherapyPlace(const int& TherapyPlaceN) const {
235    TXmlTokV XmlTokV;
236    TherapyPlacesXmlDoc->GetTagTokV("Operation|Parameter|TherapyPlaces|TherapyPlace", XmlTokV);
237    return XmlTokV[TherapyPlaceN];
238  }
239  bool TThermalSch::IsActivitiesOk(TStr& MsgStr) const {
240    if (ActivitiesXmlDoc.Empty()){
241      MsgStr=GetXmlOut_Error("SetCatalogueActivities", "Activities doesn't exists.");
242    }
243    int Activities=TThermalSch::GetActivities();
244    for (int ActivityN=0; ActivityN<Activities; ActivityN++){
245      PXmlTok Activity=TThermalSch::GetActivity(ActivityN);
246      if (Activity->IsTag("Activity")){
247        GetActivity_Code(Activity);
248        GetActivity_Type(Activity);
249        GetActivity_Name(Activity);
250        GetActivity_Priority(Activity);
251        GetActivity_Duration(Activity);
252        GetActivity_TPDuration(Activity);
253        GetActivity_PatientDuration(Activity);
254        GetActivity_TherapistDurationPreparation(Activity);
255        GetActivity_TherapistDurationExecution(Activity);
256        GetActivity_TherapistDurationAdditionalTime(Activity);
257        GetActivity_Weariness(Activity);
258        GetActivity_Dry(Activity);
259      } else {
260        MsgStr=GetXmlOut_Error("SetCatalogueActivities", "Invalid Activities.");
261        return false;
262      }
263    }
264    return true;
265  }
266  int TThermalSch::GetActivities() const {
267    if (ActivitiesXmlDoc.Empty()){return 0;}
268    TXmlTokV XmlTokV;
269    ActivitiesXmlDoc->GetTagTokV("Operation|Parameter|Activities|Activity", XmlTokV);
270    return XmlTokV.Len();
271  }
272  PXmlTok TThermalSch::GetActivity(const int& ActivityN) const {
273    TXmlTokV XmlTokV;
274    ActivitiesXmlDoc->GetTagTokV("Operation|Parameter|Activities|Activity", XmlTokV);
275    return XmlTokV[ActivityN];
276  }
277  bool TThermalSch::IsAvailableTherapyPlacesOk(TStr& MsgStr) const {
278    if (AvailableTherapyPlacesXmlDoc.Empty()){
279      MsgStr=GetXmlOut_Error("SetCatalogueAvailableTherapyPlaces", "Available-Therapy-Places doesn't exists.");
280      return false;
281    }
282    int AvailableTherapyPlaces=TThermalSch::GetAvailableTherapyPlaces();
283    for (int AvailableTherapyPlaceN=0; AvailableTherapyPlaceN<AvailableTherapyPlaces; AvailableTherapyPlaceN++){
284      PXmlTok AvailableTherapyPlace=TThermalSch::GetAvailableTherapyPlace(AvailableTherapyPlaceN);
285      if (AvailableTherapyPlace->IsTag("AvailableTherapyPlace")){
286        GetAvailableTherapyPlace_Code(AvailableTherapyPlace);
287        int TherapyPlaceSchedules=GetTherapyPlaceSchedules(AvailableTherapyPlace);
288        for (int TherapyPlaceScheduleN=0; TherapyPlaceScheduleN<TherapyPlaceSchedules; TherapyPlaceScheduleN++){
289          PXmlTok TherapyPlaceSchedule=GetTherapyPlaceSchedule(AvailableTherapyPlace, TherapyPlaceScheduleN);
290          if (TherapyPlaceSchedule->IsTag("TherapyPlaceSchedule")){
291            GetTherapyPlaceSchedule_WeekDays(TherapyPlaceSchedule);
292            GetTherapyPlaceSchedule_OpenFrom(TherapyPlaceSchedule);
293            GetTherapyPlaceSchedule_OpenTill(TherapyPlaceSchedule);
294            GetTherapyPlaceSchedule_ValidFrom(TherapyPlaceSchedule);
295            GetTherapyPlaceSchedule_ValidTo(TherapyPlaceSchedule);
296          }
297        }
298      } else {
299        MsgStr=GetXmlOut_Error("SetCatalogueAvailableTherapyPlaces", "Invalid Available-Therapy-Places.");
300        return false;
301      }
302    }
303    return true;
304  }
305  int TThermalSch::GetAvailableTherapyPlaces() const {
306    if (AvailableTherapyPlacesXmlDoc.Empty()){return 0;}
307    TXmlTokV XmlTokV;
308    AvailableTherapyPlacesXmlDoc->GetTagTokV("Operation|Parameter|AvailableTherapyPlaces|AvailableTherapyPlace", XmlTokV);
309    return XmlTokV.Len();
310  }
311  PXmlTok TThermalSch::GetAvailableTherapyPlace(const int& AvailableTherapyPlaceN) const {
312    TXmlTokV XmlTokV;
313    AvailableTherapyPlacesXmlDoc->GetTagTokV("Operation|Parameter|AvailableTherapyPlaces|AvailableTherapyPlace", XmlTokV);
314    return XmlTokV[AvailableTherapyPlaceN];
315  }
316  int TThermalSch::GetTherapyPlaceSchedules(const PXmlTok& AvailableTherapyPlace) const {
317    TXmlTokV XmlTokV;
318    AvailableTherapyPlacesXmlDoc->GetTagTokV("Operation|Parameter|AvailableTherapyPlaces|AvailableTherapyPlace|TherapyPlaceSchedules|TherapyPlaceSchedule", XmlTokV);
319    return XmlTokV.Len();
320  }
321  PXmlTok TThermalSch::GetTherapyPlaceSchedule(const PXmlTok& AvailableTherapyPlace, const int& TherapyPlaceScheduleN) const {
322    TXmlTokV XmlTokV;
323    AvailableTherapyPlacesXmlDoc->GetTagTokV("Operation|Parameter|AvailableTherapyPlaces|AvailableTherapyPlace|TherapyPlaceSchedules|TherapyPlaceSchedule", XmlTokV);
324    return XmlTokV[TherapyPlaceScheduleN];
325  }
326  bool TThermalSch::IsAvailableActivitiesOk(TStr& MsgStr) const {
327    if (AvailableActivitiesXmlDoc.Empty()){
328      MsgStr=GetXmlOut_Error("SetCatalogueAvailableActivities", "Available-Activities doesn't exists.");
329      return false;
330    }
331    int AvailableActivities=TThermalSch::GetAvailableActivities();
332    for (int AvailableActivityN=0; AvailableActivityN<AvailableActivities; AvailableActivityN++){
333      PXmlTok AvailableActivity=TThermalSch::GetAvailableActivity(AvailableActivityN);
334      if (AvailableActivity->IsTag("AvailableActivity")){
335        GetAvailableActivity_Code(AvailableActivity);
336        int ActivitySchedules=GetActivitySchedules(AvailableActivity);
337        for (int ActivityScheduleN=0; ActivityScheduleN<ActivitySchedules; ActivityScheduleN++){
338          PXmlTok ActivitySchedule=GetActivitySchedule(AvailableActivity, ActivityScheduleN);
339          if (ActivitySchedule->IsTag("ActivitySchedule")){
340            GetActivitySchedule_WeekDays(ActivitySchedule);
341            GetActivitySchedule_StartTime(ActivitySchedule);
342            GetActivitySchedule_EndTime(ActivitySchedule);
343            GetActivitySchedule_TherapyPlaceType(ActivitySchedule);
344            GetActivitySchedule_ValidFrom(ActivitySchedule);
345            GetActivitySchedule_ValidTo(ActivitySchedule);
346          }
347        }
348      } else {
349        MsgStr=GetXmlOut_Error("SetCatalogueAvailableActivities", "Invalid Available-Activities.");
350        return false;
351      }
352    }
353    return true;
354  }
355  int TThermalSch::GetAvailableActivities() const {
356    if (AvailableActivitiesXmlDoc.Empty()){return 0;}
357    TXmlTokV XmlTokV;
358    AvailableActivitiesXmlDoc->GetTagTokV("Operation|Parameter|AvailableActivities|AvailableActivity", XmlTokV);
359    return XmlTokV.Len();
360  }
361  PXmlTok TThermalSch::GetAvailableActivity(const int& AvailableActivityN) const {
362    TXmlTokV XmlTokV;
363    AvailableActivitiesXmlDoc->GetTagTokV("Operation|Parameter|AvailableActivities|AvailableActivity", XmlTokV);
364    return XmlTokV[AvailableActivityN];
365  }
366  int TThermalSch::GetActivitySchedules(const PXmlTok& AvailableActivity) const {
367    TXmlTokV XmlTokV;
368    AvailableActivity->GetTagTokV("ActivitySchedules|ActivitySchedule", XmlTokV);
369    return XmlTokV.Len();
370  }
371  PXmlTok TThermalSch::GetActivitySchedule(const PXmlTok& AvailableActivity, const int& ActivityScheduleN) const {
372    TXmlTokV XmlTokV;
373    AvailableActivity->GetTagTokV("ActivitySchedules|ActivitySchedule", XmlTokV);
374    return XmlTokV[ActivityScheduleN];
375  }
376  bool TThermalSch::IsScheduledActivitiesOk(TStr& MsgStr) const {
377    if (ScheduledActivitiesXmlDoc.Empty()){
378      MsgStr=GetXmlOut_Error("SetScheduledActivities", "Scheduled-Activities doesn't exists.");
379      return false;
380    }
381    int ScheduledActivities=TThermalSch::GetScheduledActivities();
382    for (int ScheduledActivityN=0; ScheduledActivityN<ScheduledActivities; ScheduledActivityN++){
383      PXmlTok ScheduledActivity=TThermalSch::GetScheduledActivity(ScheduledActivityN);
384      if (ScheduledActivity->IsTag("ScheduledActivity")){
385        GetScheduledActivity_Code(ScheduledActivity);
386        GetScheduledActivity_Code(ScheduledActivity);
387        GetScheduledActivity_PatientATPCode(ScheduledActivity);
388        GetScheduledActivity_Patient(ScheduledActivity);
389        GetScheduledActivity_TherapistCode(ScheduledActivity);
390        GetScheduledActivity_TherapyPlaceCode(ScheduledActivity);
391        GetScheduledActivity_ActivityCode(ScheduledActivity);
392        GetScheduledActivity_StartDateTime(ScheduledActivity);
393        GetScheduledActivity_RepetitionNumber(ScheduledActivity);
394        GetScheduledActivity_StartingPoint(ScheduledActivity);
395        GetScheduledActivity_PatientDuration(ScheduledActivity);
396      } else {
397        MsgStr=GetXmlOut_Error("SetScheduledActivities", "Invalid Scheduled-Activities.");
398        return false;
399      }
400    }
401    return true;
402  }
403  int TThermalSch::GetScheduledActivities() const {
404    if (ScheduledActivitiesXmlDoc.Empty()){return 0;}
405    TXmlTokV XmlTokV;
406    ScheduledActivitiesXmlDoc->GetTagTokV("Operation|Parameter|ScheduledActivities|ScheduledActivity", XmlTokV);
407    return XmlTokV.Len();
408  }
409  PXmlTok TThermalSch::GetScheduledActivity(const int& ScheduledActivityN) const {
410    TXmlTokV XmlTokV;
411    ScheduledActivitiesXmlDoc->GetTagTokV("Operation|Parameter|ScheduledActivities|ScheduledActivity", XmlTokV);
412    return XmlTokV[ScheduledActivityN];
413  }
414  bool TThermalSch::IsHolidaysOk(TStr& MsgStr) const {
415    if (HolidaysXmlDoc.Empty()){
416      MsgStr=GetXmlOut_Error("SetCatalogueHolidays", "Holidays doesn't exists.");
417      return false;
418    }
419    int Holidays=TThermalSch::GetHolidays();
420    for (int HolidayN=0; HolidayN<Holidays; HolidayN++){
421      PXmlTok Holiday=TThermalSch::GetHoliday(HolidayN);
422      if (Holiday->IsTag("Holiday")){
423        TStr Str=GetHoliday_Date(Holiday);
424      } else {
425        MsgStr=GetXmlOut_Error("SetCatalogueHolidays", "Invalid Holidays.");
426        return false;
427      }
428    }
429    return true;
430  }
431  int TThermalSch::GetHolidays() const {
432    if (HolidaysXmlDoc.Empty()){return 0;}
433    TXmlTokV XmlTokV;
434    HolidaysXmlDoc->GetTagTokV("Operation|Parameter|Holidays|Holiday", XmlTokV);
435    return XmlTokV.Len();
436  }
437  PXmlTok TThermalSch::GetHoliday(const int& HolidayN) const {
438    TXmlTokV XmlTokV;
439    HolidaysXmlDoc->GetTagTokV("Operation|Parameter|Holidays|Holiday", XmlTokV);
440    return XmlTokV[HolidayN];
441  }
442  bool TThermalSch::IsMakeScheduleOk(TStr& MsgStr) const {
443    if (MakeScheduleXmlDoc.Empty()){
444      MsgStr=GetXmlOut_Error("MakeSchedule", "Make-Schedule doesn't exists.");
445      return false;
446    }
447    GetMakeSchedule_PatientCode();
448    GetMakeSchedule_PatientGender();
449    GetMakeSchedule_PatientATPCode();
450    int PlanRequests=TThermalSch::GetMakeSchedule_PlanRequests();
451    for (int PlanRequestN=0; PlanRequestN<PlanRequests; PlanRequestN++){
452      PXmlTok PlanRequest=TThermalSch::GetMakeSchedule_PlanRequest(PlanRequestN);
453      if (PlanRequest->IsTag("PlanRequest")){
454        GetMakeSchedule_PlanRequest_ActivityCode(PlanRequest);
455        GetMakeSchedule_PlanRequest_Quantity(PlanRequest);
456        GetMakeSchedule_PlanRequest_DayQuantity(PlanRequest);
457        GetMakeSchedule_PlanRequest_Frequency(PlanRequest);
458        GetMakeSchedule_PlanRequest_AlternatingActivityCode(PlanRequest);
459        GetMakeSchedule_PlanRequest_ExcludedActivities_ActivityCode(PlanRequest);
460        GetMakeSchedule_PlanRequest_ExcludedActivities_Time(PlanRequest);
461        GetMakeSchedule_PlanRequest_FamilyActivity(PlanRequest);
462        GetMakeSchedule_PlanRequest_TreatmentDate(PlanRequest);
463        GetMakeSchedule_PlanRequest_DesiredStartTime(PlanRequest);
464        GetMakeSchedule_PlanRequest_DesiredFinishTime(PlanRequest);
465      } else {
466        MsgStr=GetXmlOut_Error("MakeSchedule", "Invalid Make-Schedule.");
467        return false;
468      }
469    }
470    return true;
471  }
472  int TThermalSch::GetMakeSchedule_PlanRequests() const {
473    if (MakeScheduleXmlDoc.Empty()){return 0;}
474    TXmlTokV XmlTokV;
475    MakeScheduleXmlDoc->GetTagTokV("Operation|Parameter|PlanRequests|PlanRequest", XmlTokV);
476    return XmlTokV.Len();
477  }
478  PXmlTok TThermalSch::GetMakeSchedule_PlanRequest(const int& PlanRequestN) const {
479    TXmlTokV XmlTokV;
480    MakeScheduleXmlDoc->GetTagTokV("Operation|Parameter|PlanRequests|PlanRequest", XmlTokV);
481    return XmlTokV[PlanRequestN];
482  }
483  bool TThermalSch::IsCheckScheduleOk(TStr& MsgStr) const {
484    if (CheckScheduleXmlDoc.Empty()){
485      MsgStr=GetXmlOut_Error("CheckSchedule", "Check-Schedule doesn't exists.");
486      return false;
487    }
488    GetCheckSchedule_PatientCode();
489    GetCheckSchedule_PatientGender();
490    GetCheckSchedule_PatientATPCode();
491    GetCheckSchedule_IntRequestedActivityActivityCode();
492    GetCheckSchedule_IntRequestedActivityDayQuantity();
493    GetCheckSchedule_IntRequestedActivityTreatmentDate();
494    GetCheckSchedule_IntRequestedActivityDesiredStartTime();
495    GetCheckSchedule_IntRequestedActivityDesiredFinishTime();
496    return true;
497  }
498  void TThermalSch::SaveCsvToXml(
499   const TStr& DefFNm, const TStr& DatFNm, const TStr& XmlFNm){
500    if (!TFile::Exists(DefFNm)){
501      TFOut XmlSOut(XmlFNm); FILE* XmlFId=XmlSOut.GetFileId();
502      fprintf(XmlFId, "%s", GetXmlOut_Error("NoCommand", TStr("Can not open file: '")+DefFNm+"'."));
503      return;
504    }
505    if (!TFile::Exists(DatFNm)){
506      TFOut XmlSOut(XmlFNm); FILE* XmlFId=XmlSOut.GetFileId();
507      fprintf(XmlFId, "%s", GetXmlOut_Error("NoCommand", TStr("Can not open file: '")+DatFNm+"'."));
508      return;
509    }
510    PSs DefSs=TSs::LoadTxt(ssfCommaSep, DefFNm);
511    TStrV FldNmV;
512    for (int Y=0; Y<DefSs->GetYLen(); Y++){
513      FldNmV.Add(DefSs->GetVal(0, Y));}
514    PSs DatSs=TSs::LoadTxt(ssfCommaSep, DatFNm);
515    TVec<TStrV> RecFldValVV;
516    {for (int Y=0; Y<DatSs->GetYLen(); Y++){
517      TStrV FldValV;
518      for (int X=0; X<DatSs->GetXLen(Y); X++){
519        TStr FldVal=DatSs->GetVal(X, Y);
520        FldValV.Add(FldVal);
521      }
522      RecFldValVV.Add(FldValV);
523    }}
524    TFOut XmlSOut(XmlFNm); FILE* XmlFId=XmlSOut.GetFileId();
525    if ((DefFNm=="URNIKXXG.TXT")&&(DatFNm=="URNIKXX0.TXT")){
526      fprintf(XmlFId, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
527      fprintf(XmlFId, "<!-- edited with DarMar XML v3.14 by Darko Zupanic & Marko Grobelnik -->\n");
528      fprintf(XmlFId, "<Operation xmlns:xsi=\"http:&bsol;&bsol;www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"D:\\App\\zdr\\te\\ParamIN.xsd\">\n");
529      fprintf(XmlFId, "<OperationName>SetScheduledActivities</OperationName>\n");
530      fprintf(XmlFId, "<Parameter xsi:type=\"tParamInSetScheduledActivities\">\n");
531      fprintf(XmlFId, "<ScheduledActivities>\n");
532      for (int RecN=0; RecN<RecFldValVV.Len(); RecN++){
533        TStrV& FldValV=RecFldValVV[RecN];
534        fprintf(XmlFId, "<ScheduledActivity>\n");
535        for (int FldN=0; FldN<FldValV.Len(); FldN++){
536          TStr FldNm=FldNmV[FldN];
537          if (FldNm=="SIFRA101"){FldNm="PatientCode";}
538          else if (FldNm=="SIFRA060"){FldNm="ActivityCode";}
539          else if (FldNm=="SIFRA052"){FldNm="TherapyPlaceCode";}
540          else if (FldNm=="DATUM060"){FldNm="Date";}
541          else if (FldNm=="START060"){FldNm="StartTime";}
542          else if (FldNm=="NARP_060"){FldNm="PatientDuration";}
543          else if (FldNm=="NARA_060"){FldNm="TPDuration";}
544          else if (FldNm=="UJEMANJE"){FldNm="Accordance";}
545          fprintf(XmlFId, "<%s>%s</%s>\n",
546           TXmlLx::GetXmlStrFromPlainStr(FldNm).CStr(),
547           TXmlLx::GetXmlStrFromPlainStr(FldValV[FldN]).CStr(),
548           TXmlLx::GetXmlStrFromPlainStr(FldNm).CStr());
549        }
550        fprintf(XmlFId, "</ScheduledActivity>\n");
551      }
552      fprintf(XmlFId, "</ScheduledActivities>\n");
553      fprintf(XmlFId, "</Parameter>\n");
554      fprintf(XmlFId, "</Operation>\n");
555    } else {
556      fprintf(XmlFId, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
557      fprintf(XmlFId, "<Data>\n");
558      for (int RecN=0; RecN<RecFldValVV.Len(); RecN++){
559        TStrV& FldValV=RecFldValVV[RecN];
560        fprintf(XmlFId, "<Record>\n");
561        for (int FldN=0; FldN<FldValV.Len(); FldN++){
562          fprintf(XmlFId, "<Field Name=\"%s\" Value=\"%s\"/>\n",
563           TXmlLx::GetXmlStrFromPlainStr(FldNmV[FldN]).CStr(),
564           TXmlLx::GetXmlStrFromPlainStr(FldValV[FldN]).CStr());
565        }
566        fprintf(XmlFId, "</Record>\n");
567      }
568      fprintf(XmlFId, "</Data>\n");
569    }
570  }
571  void TThermalSch::SaveCsvToXmlParamOut(
572   const TStr& DefFNm, const TStr& DatFNm, const TStr& XmlFNm){
573    if (!TFile::Exists(DefFNm)){
574      TFOut XmlSOut(XmlFNm); FILE* XmlFId=XmlSOut.GetFileId();
575      fprintf(XmlFId, "%s", GetXmlOut_Error("NoCommand", TStr("Can not open file: '")+DefFNm+"'."));
576      return;
577    }
578    if (!TFile::Exists(DatFNm)){
579      TFOut XmlSOut(XmlFNm); FILE* XmlFId=XmlSOut.GetFileId();
580      fprintf(XmlFId, "%s", GetXmlOut_Error("NoCommand", TStr("Can not open file: '")+DatFNm+"'."));
581      return;
582    }
583    PSs DefSs=TSs::LoadTxt(ssfCommaSep, DefFNm);
584    TStrV FldNmV;
585    for (int Y=0; Y<DefSs->GetYLen(); Y++){
586      FldNmV.Add(DefSs->GetVal(0, Y));}
587    PSs DatSs=TSs::LoadTxt(ssfCommaSep, DatFNm);
588    TVec<TStrV> RecFldValVV;
589    {for (int Y=0; Y<DatSs->GetYLen(); Y++){
590      TStrV FldValV;
591      for (int X=0; X<DatSs->GetXLen(Y); X++){
592        TStr FldVal=DatSs->GetVal(X, Y);
593        FldValV.Add(FldVal);
594      }
595      RecFldValVV.Add(FldValV);
596    }}
597    TFOut XmlSOut(XmlFNm); FILE* XmlFId=XmlSOut.GetFileId();
598    if ((DefFNm=="URNIKXXG.TXT")&&(DatFNm=="URNIKXX0.TXT")){
599      fprintf(XmlFId, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
600      fprintf(XmlFId, "<ParamOut>\n");
601      fprintf(XmlFId, "<OperationName>");
602      fprintf(XmlFId, "MakeSchedule");
603      fprintf(XmlFId, "</OperationName>\n");
604      fprintf(XmlFId, "<Success>Ok</Success>\n");
605      fprintf(XmlFId, "<Data>\n");
606      fprintf(XmlFId, "<Operation xmlns:xsi=\"http:&bsol;&bsol;www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"D:\\App\\zdr\\te\\ParamIN.xsd\">\n");
607      fprintf(XmlFId, "<OperationName>SetScheduledActivities</OperationName>\n");
608      fprintf(XmlFId, "<Parameter xsi:type=\"tParamInSetScheduledActivities\">\n");
609      fprintf(XmlFId, "<ScheduledActivities>\n");
<span onclick='openModal()' class='match'>610      for (int RecN=0; RecN<RecFldValVV.Len(); RecN++){
611        TStrV& FldValV=RecFldValVV[RecN];
612        fprintf(XmlFId, "<ScheduledActivity>\n");
613        for (int FldN=0; FldN<FldValV.Len(); FldN++){
614          TStr FldNm=FldNmV[FldN];
615          if (FldNm=="SIFRA101"){FldNm="PatientCode";}
</span>616          else if (FldNm=="SIFRA060"){FldNm="ActivityCode";}
617          else if (FldNm=="SIFRA052"){FldNm="TherapyPlaceCode";}
618          else if (FldNm=="DATUM060"){FldNm="Date";}
619          else if (FldNm=="START060"){FldNm="StartTime";}
620          else if (FldNm=="NARP_060"){FldNm="PatientDuration";}
621          else if (FldNm=="NARA_060"){FldNm="TPDuration";}
622          else if (FldNm=="UJEMANJE"){FldNm="Accordance";}
623          fprintf(XmlFId, "<%s>%s</%s>\n",
624           TXmlLx::GetXmlStrFromPlainStr(FldNm).CStr(),
625           TXmlLx::GetXmlStrFromPlainStr(FldValV[FldN]).CStr(),
626           TXmlLx::GetXmlStrFromPlainStr(FldNm).CStr());
627        }
628        fprintf(XmlFId, "</ScheduledActivity>\n");
629      }
630      fprintf(XmlFId, "</ScheduledActivities>\n");
631      fprintf(XmlFId, "</Parameter>\n");
632      fprintf(XmlFId, "</Operation>\n");
633      fprintf(XmlFId, "</Data>\n");
634      fprintf(XmlFId, "</ParamOut>\n");
635    } else {
636      fprintf(XmlFId, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
637      fprintf(XmlFId, "<Data>\n");
638      for (int RecN=0; RecN<RecFldValVV.Len(); RecN++){
639        TStrV& FldValV=RecFldValVV[RecN];
640        fprintf(XmlFId, "<Record>\n");
641        for (int FldN=0; FldN<FldValV.Len(); FldN++){
642          fprintf(XmlFId, "<Field Name=\"%s\" Value=\"%s\"/>\n",
643           TXmlLx::GetXmlStrFromPlainStr(FldNmV[FldN]).CStr(),
644           TXmlLx::GetXmlStrFromPlainStr(FldValV[FldN]).CStr());
645        }
646        fprintf(XmlFId, "</Record>\n");
647      }
648      fprintf(XmlFId, "</Data>\n");
649    }
650  }
651  void TThermalSch::SaveOldCsv() const {
652    SaveOldCsv_KatalogZdrDelavcev();
653    SaveOldCsv_KatalogAparatov();
654    SaveOldCsv_KatalogAktivnosti();
655    SaveOldCsv_UrnikZaTerapevte();
656    SaveOldCsv_UrnikZaAparate();
657    SaveOldCsv_UrnikAktivnosti();
658    SaveOldCsv_MozniTerminiVDnevu();
659    SaveOldCsv_Prazniki();
660    SaveOldCsv_PredpisaneTerapije();
661    SaveOldCsv_PlaniraneAktivnosti();
662    SaveOldCsv_UrnikXX();
663  }
664  void TThermalSch::SaveOldCsv_KatalogZdrDelavcev() const {
665    TFOut DefSOut("KA051ZDG.TXT"); FILE* fDef=DefSOut.GetFileId();
666    SaveFldDef(fDef, "PRIM_051");
667    SaveFldDef(fDef, "SSIF_S23");
668    SaveFldDef(fDef, "SIFRA039");
669    SaveFldDef(fDef, "STAT_051");
670    SaveFldDef(fDef, "SIFRA051");
671    SaveFldDef(fDef, "POZ__051");
672    SaveFldDef(fDef, "EMSO_051");
673    SaveFldDef(fDef, "DATUMIPL");
674    SaveFldDef(fDef, "TIP__051");
675    TFOut DatSOut("KA051ZD0.TXT"); &bsol;*FILE* fDat=DatSOut.GetFileId();*/
676  }
677  void TThermalSch::SaveOldCsv_KatalogAparatov() const {
678    TFOut DefSOut("KA052APG.TXT"); FILE* fDef=DefSOut.GetFileId();
679    SaveFldDef(fDef, "SIFRA052"); 
680    SaveFldDef(fDef, "SSIF_T05"); 
681    SaveFldDef(fDef, "OPIS_052"); 
682    SaveFldDef(fDef, "SSIF_NE4"); 
683    SaveFldDef(fDef, "ST_P_052"); 
684    SaveFldDef(fDef, "SIFR1052"); 
685    SaveFldDef(fDef, "PODAL052"); 
686    SaveFldDef(fDef, "TR_DO052"); 
687    SaveFldDef(fDef, "RAZD_052"); 
688    SaveFldDef(fDef, "SPOL_052"); 
689    SaveFldDef(fDef, "ALTERSCH"); 
690    SaveFldDef(fDef, "FAMILSCH"); 
691    TFOut DatSOut("KA052AP0.TXT"); FILE* fDat=DatSOut.GetFileId();
692    int TherapyPlaces=TThermalSch::GetTherapyPlaces();
693    for (int TherapyPlaceN=0; TherapyPlaceN<TherapyPlaces; TherapyPlaceN++){
694      PXmlTok TherapyPlace=TThermalSch::GetTherapyPlace(TherapyPlaceN);
695      SaveFldVal(fDat, GetTherapyPlace_Code(TherapyPlace)); 
696      SaveFldVal(fDat, GetTherapyPlace_Type(TherapyPlace)); 
697      SaveFldVal(fDat, GetTherapyPlace_Location(TherapyPlace)); 
698      SaveFldVal(fDat, GetTherapyPlace_TherapistType(TherapyPlace)); 
699      SaveFldVal(fDat, GetTherapyPlace_Capacity(TherapyPlace)); 
700      SaveFldVal(fDat, ""); 
701      SaveFldVal(fDat, ""); 
702      SaveFldVal(fDat, ""); 
703      SaveFldVal(fDat, GetTherapyPlace_Distance(TherapyPlace)); 
704      SaveFldVal(fDat, GetTherapyPlace_Gender(TherapyPlace)); 
705      SaveFldVal(fDat, GetTherapyPlace_AlternateScheduling(TherapyPlace));
706      SaveFldVal(fDat, GetTherapyPlace_FamilyScheduling(TherapyPlace), true);
707    }
708  }
709  void TThermalSch::SaveOldCsv_KatalogAktivnosti() const {
710    TFOut DefSOut("KA060AOG.TXT"); FILE* fDef=DefSOut.GetFileId();
711    SaveFldDef(fDef, "SIFRA060"); 
712    SaveFldDef(fDef, "SSIF_T05"); 
713    SaveFldDef(fDef, "TRAJ_060"); 
714    SaveFldDef(fDef, "STMAX060"); 
715    SaveFldDef(fDef, "STOPT060"); 
716    SaveFldDef(fDef, "RAZ1_060"); 
717    SaveFldDef(fDef, "RAZ2_060"); 
718    SaveFldDef(fDef, "RAZ3_060"); 
719    SaveFldDef(fDef, "NARP_060"); 
720    SaveFldDef(fDef, "NARA_060"); 
721    SaveFldDef(fDef, "SSIF_T01"); 
722    SaveFldDef(fDef, "SS_T2_T3"); 
723    SaveFldDef(fDef, "TEZA_060"); 
724    SaveFldDef(fDef, "SUHA_060"); 
725    SaveFldDef(fDef, "PRIORITY"); 
726    TFOut DatSOut("KA060AO0.TXT"); FILE* fDat=DatSOut.GetFileId();
727    int Activities=TThermalSch::GetActivities();
728    for (int ActivityN=0; ActivityN<Activities; ActivityN++){
729      PXmlTok Activity=TThermalSch::GetActivity(ActivityN);
730      SaveFldVal(fDat, GetActivity_Code(Activity)); 
731      SaveFldVal(fDat, GetActivity_Type(Activity)); 
732      SaveFldVal(fDat, GetActivity_Duration(Activity)); 
733      SaveFldVal(fDat, ""); 
734      SaveFldVal(fDat, ""); 
735      SaveFldVal(fDat, GetActivity_TherapistDurationPreparation(Activity)); 
736      SaveFldVal(fDat, GetActivity_TherapistDurationExecution(Activity)); 
737      SaveFldVal(fDat, GetActivity_TherapistDurationAdditionalTime(Activity)); 
738      SaveFldVal(fDat, GetActivity_PatientDuration(Activity)); 
739      SaveFldVal(fDat, GetActivity_TPDuration(Activity)); 
740      SaveFldVal(fDat, ""); 
741      SaveFldVal(fDat, ""); 
742      SaveFldVal(fDat, GetActivity_Weariness(Activity)); 
743      SaveFldVal(fDat, GetActivity_Dry(Activity)); 
744      SaveFldVal(fDat, GetActivity_Priority(Activity), true); 
745    }
746  }
747  void TThermalSch::SaveOldCsv_UrnikZaTerapevte() const {
748    TFOut DefSOut("PR350UIG.TXT"); FILE* fDef=DefSOut.GetFileId();
749    SaveFldDef(fDef, "TIP__051");
750    SaveFldDef(fDef, "DAN__350");
751    SaveFldDef(fDef, "STEV_350");
752    SaveFldDef(fDef, "DATOD350");
753    SaveFldDef(fDef, "DATDO350");
754    TFOut DatSOut("PR350UI0.TXT"); &bsol;*FILE* fDat=DatSOut.GetFileId();*/
755  }
756  void TThermalSch::SaveOldCsv_UrnikZaAparate() const {
757    TFOut DefSOut("PR351UPG.TXT"); FILE* fDef=DefSOut.GetFileId();
758    SaveFldDef(fDef, "SIFRA052"); 
759    SaveFldDef(fDef, "AKTIV351"); 
760    SaveFldDef(fDef, "DATOD351"); 
761    SaveFldDef(fDef, "DATDO351"); 
762    SaveFldDef(fDef, "CASOD351"); 
763    SaveFldDef(fDef, "CASDO351"); 
764    SaveFldDef(fDef, "DAN"); 
765    TFOut DatSOut("PR351UP0.TXT"); FILE* fDat=DatSOut.GetFileId();
766    int AvailableTherapyPlaces=TThermalSch::GetAvailableTherapyPlaces();
767    for (int AvailableTherapyPlaceN=0; AvailableTherapyPlaceN<AvailableTherapyPlaces; AvailableTherapyPlaceN++){
768      PXmlTok AvailableTherapyPlace=TThermalSch::GetAvailableTherapyPlace(AvailableTherapyPlaceN);
769      int TherapyPlaceSchedules=GetTherapyPlaceSchedules(AvailableTherapyPlace);
770      for (int TherapyPlaceScheduleN=0; TherapyPlaceScheduleN<TherapyPlaceSchedules; TherapyPlaceScheduleN++){
771        PXmlTok TherapyPlaceSchedule=GetTherapyPlaceSchedule(AvailableTherapyPlace, TherapyPlaceScheduleN);
772        TStrV DayV=GetTherapyPlaceSchedule_WeekDays(TherapyPlaceSchedule);
773        for (int DayN=0; DayN<DayV.Len(); DayN++){
774          SaveFldVal(fDat, GetAvailableTherapyPlace_Code(AvailableTherapyPlace)); 
775          SaveFldVal(fDat, "D"); 
776          SaveFldVal(fDat, GetTherapyPlaceSchedule_ValidFrom(TherapyPlaceSchedule)); 
777          SaveFldVal(fDat, GetTherapyPlaceSchedule_ValidTo(TherapyPlaceSchedule)); 
778          SaveFldVal(fDat, GetTherapyPlaceSchedule_OpenFrom(TherapyPlaceSchedule)); 
779          SaveFldVal(fDat, GetTherapyPlaceSchedule_OpenTill(TherapyPlaceSchedule)); 
780          SaveFldVal(fDat, DayV[DayN], true); 
781        }
782      }
783    }
784  }
785  void TThermalSch::SaveOldCsv_UrnikAktivnosti() const {
786    TFOut DefSOut("PR352UAG.TXT"); FILE* fDef=DefSOut.GetFileId();
787    SaveFldDef(fDef, "SIFRA060"); 
788    SaveFldDef(fDef, "DAN__352"); 
789    SaveFldDef(fDef, "SIFRA352"); 
790    SaveFldDef(fDef, "DATOD352"); 
791    SaveFldDef(fDef, "DATDO352"); 
792    SaveFldDef(fDef, "CASOD352"); 
793    SaveFldDef(fDef, "CASDO352"); 
794    SaveFldDef(fDef, "SIFRA052"); 
795    SaveFldDef(fDef, "SPOL052"); 
796    TFOut DatSOut("PR352UA0.TXT"); FILE* fDat=DatSOut.GetFileId();
797    int AvailableActivities=TThermalSch::GetAvailableActivities();
798    for (int AvailableActivityN=0; AvailableActivityN<AvailableActivities; AvailableActivityN++){
799      PXmlTok AvailableActivity=TThermalSch::GetAvailableActivity(AvailableActivityN);
800      int ActivitySchedules=GetActivitySchedules(AvailableActivity);
801      for (int ActivityScheduleN=0; ActivityScheduleN<ActivitySchedules; ActivityScheduleN++){
802        PXmlTok ActivitySchedule=GetActivitySchedule(AvailableActivity, ActivityScheduleN);
803        TStrV DayV=GetActivitySchedule_WeekDays(ActivitySchedule);
804        for (int DayN=0; DayN<DayV.Len(); DayN++){
805          SaveFldVal(fDat, GetAvailableActivity_Code(AvailableActivity)); 
806          SaveFldVal(fDat, DayV[DayN]); 
807          SaveFldVal(fDat, ""); 
808          SaveFldVal(fDat, GetActivitySchedule_ValidFrom(ActivitySchedule)); 
809          SaveFldVal(fDat, GetActivitySchedule_ValidTo(ActivitySchedule)); 
810          SaveFldVal(fDat, GetActivitySchedule_StartTime(ActivitySchedule)); 
811          SaveFldVal(fDat, GetActivitySchedule_EndTime(ActivitySchedule)); 
812          SaveFldVal(fDat, GetActivitySchedule_TherapyPlaceType(ActivitySchedule)); 
813          SaveFldVal(fDat, GetActivitySchedule_Gender(ActivitySchedule), true);  
814        }
815      }
816    }
817  }
818  void TThermalSch::SaveOldCsv_MozniTerminiVDnevu() const {
819    TFOut DefSOut("PR352URG.TXT"); FILE* fDef=DefSOut.GetFileId();
820    SaveFldDef(fDef, "SIFRA352");
821    SaveFldDef(fDef, "ZAPST352");
822    SaveFldDef(fDef, "URAOD352");
823    SaveFldDef(fDef, "URADO352");
824    TFOut DatSOut("PR352UR0.TXT"); &bsol;*FILE* fDat=DatSOut.GetFileId();*/
825  }
826  void TThermalSch::SaveOldCsv_Prazniki() const {
827    TFOut DefSOut("PRAZNIKG.TXT"); FILE* fDef=DefSOut.GetFileId();
828    SaveFldDef(fDef, "DATUM000");
829    TFOut DatSOut("PRAZNIK0.TXT"); FILE* fDat=DatSOut.GetFileId();
830    int Holidays=TThermalSch::GetHolidays();
831    for (int HolidayN=0; HolidayN<Holidays; HolidayN++){
832      PXmlTok Holiday=TThermalSch::GetHoliday(HolidayN);
833      SaveFldVal(fDat, GetHoliday_Date(Holiday), true); 
834    }
835  }
836  void TThermalSch::SaveOldCsv_PredpisaneTerapije() const {
837    TFOut DefSOut("PR300NSG.TXT"); FILE* fDef=DefSOut.GetFileId();
838    SaveFldDef(fDef, "SIFRA210"); 
839    SaveFldDef(fDef, "SIFRA101"); 
840    SaveFldDef(fDef, "SIFRA060"); 
841    SaveFldDef(fDef, "ZAPST300"); 
842    SaveFldDef(fDef, "STPON300"); 
843    SaveFldDef(fDef, "S_P_D300"); 
844    SaveFldDef(fDef, "SSIF_T11"); 
845    SaveFldDef(fDef, "SIFR1060"); 
846    SaveFldDef(fDef, "SIFR2060"); 
847    SaveFldDef(fDef, "URAOD300"); 
848    SaveFldDef(fDef, "URADO300"); 
849    SaveFldDef(fDef, "DATOD300"); 
850    SaveFldDef(fDef, "STAT_300"); 
851    SaveFldDef(fDef, "PLAN_300"); 
852    SaveFldDef(fDef, "DATUMIPL"); 
853    SaveFldDef(fDef, "OPER_300"); 
854    SaveFldDef(fDef, "SIFRA051"); 
855    SaveFldDef(fDef, "SPOL_300"); 
856    SaveFldDef(fDef, "DRUZINA"); 
857    SaveFldDef(fDef, "ATTRNAME"); 
858    SaveFldDef(fDef, "EXCLACT"); 
859    SaveFldDef(fDef, "EXCLTIME"); 
860    TFOut DatSOut("PR300NS0.TXT"); FILE* fDat=DatSOut.GetFileId();
861    int PlanRequests=TThermalSch::GetMakeSchedule_PlanRequests();
862    for (int PlanRequestN=0; PlanRequestN<PlanRequests; PlanRequestN++){
863      PXmlTok PlanRequest=TThermalSch::GetMakeSchedule_PlanRequest(PlanRequestN);
864      SaveFldVal(fDat, GetMakeSchedule_PatientATPCode()); 
865      SaveFldVal(fDat, GetMakeSchedule_PatientCode()); 
866      SaveFldVal(fDat, GetMakeSchedule_PlanRequest_ActivityCode(PlanRequest)); 
867      SaveFldVal(fDat, ""); 
868      TStr AlternatingActivityCode=GetMakeSchedule_PlanRequest_AlternatingActivityCode(PlanRequest);
869      TStr QuantityStr=GetMakeSchedule_PlanRequest_Quantity(PlanRequest);
870      if (AlternatingActivityCode.Empty()){
871        SaveFldVal(fDat, GetMakeSchedule_PlanRequest_Quantity(PlanRequest)); 
872      } else {
873        int Quantity=2*QuantityStr.GetInt(0);
874        SaveFldVal(fDat, TInt::GetStr(Quantity)); 
875      }
876      SaveFldVal(fDat, GetMakeSchedule_PlanRequest_DayQuantity(PlanRequest)); 
877      SaveFldVal(fDat, GetMakeSchedule_PlanRequest_Frequency(PlanRequest)); 
878      SaveFldVal(fDat, GetMakeSchedule_PlanRequest_AlternatingActivityCode(PlanRequest)); 
879      SaveFldVal(fDat, ""); 
880      SaveFldVal(fDat, GetMakeSchedule_PlanRequest_DesiredStartTime(PlanRequest)); 
881      SaveFldVal(fDat, GetMakeSchedule_PlanRequest_DesiredFinishTime(PlanRequest)); 
882      SaveFldVal(fDat, GetMakeSchedule_PlanRequest_TreatmentDate(PlanRequest)); 
883      SaveFldVal(fDat, ""); 
884      SaveFldVal(fDat, ""); 
885      SaveFldVal(fDat, ""); 
886      SaveFldVal(fDat, ""); 
887      SaveFldVal(fDat, ""); 
888      SaveFldVal(fDat, GetMakeSchedule_PatientGender()); 
889      SaveFldVal(fDat, GetMakeSchedule_PatientFamily()); 
890      SaveFldVal(fDat, GetMakeSchedule_PlanRequest_AttrNm(PlanRequest)); 
891      SaveFldValV(fDat, GetMakeSchedule_PlanRequest_ExcludedActivities_ActivityCode(PlanRequest)); 
892      SaveFldValV(fDat, GetMakeSchedule_PlanRequest_ExcludedActivities_Time(PlanRequest), true); 
893    }
894  }
895  void TThermalSch::SaveOldCsv_PlaniraneAktivnosti() const {
896    TFOut DefSOut("PR360AKG.TXT"); FILE* fDef=DefSOut.GetFileId();
897    SaveFldDef(fDef, "SIFRA360"); 
898    SaveFldDef(fDef, "SIFRA210"); 
899    SaveFldDef(fDef, "SIFRA101"); 
900    SaveFldDef(fDef, "SIFRA051"); 
901    SaveFldDef(fDef, "SIFRA052"); 
902    SaveFldDef(fDef, "SIFRA060"); 
903    SaveFldDef(fDef, "DATUM360"); 
904    SaveFldDef(fDef, "STAT_360"); 
905    SaveFldDef(fDef, "Z_ST_360"); 
906    SaveFldDef(fDef, "C_OD_360"); 
907    SaveFldDef(fDef, "TRAJ_060"); 
908    SaveFldDef(fDef, "URA__360"); 
909    SaveFldDef(fDef, "SSIF_T07"); 
910    TFOut DatSOut("PR360AK0.TXT"); FILE* fDat=DatSOut.GetFileId();
911    int ScheduledActivities=TThermalSch::GetScheduledActivities();
912    for (int ScheduledActivityN=0; ScheduledActivityN<ScheduledActivities; ScheduledActivityN++){
913      PXmlTok ScheduledActivity=TThermalSch::GetScheduledActivity(ScheduledActivityN);
914      SaveFldVal(fDat, GetScheduledActivity_Code(ScheduledActivity)); 
915      SaveFldVal(fDat, GetScheduledActivity_PatientATPCode(ScheduledActivity)); 
916      SaveFldVal(fDat, GetScheduledActivity_Patient(ScheduledActivity)); 
917      SaveFldVal(fDat, GetScheduledActivity_TherapistCode(ScheduledActivity)); 
918      SaveFldVal(fDat, GetScheduledActivity_TherapyPlaceCode(ScheduledActivity)); 
919      SaveFldVal(fDat, GetScheduledActivity_ActivityCode(ScheduledActivity)); 
920      SaveFldVal(fDat, GetScheduledActivity_StartDateTime(ScheduledActivity)); 
921      SaveFldVal(fDat, ""); 
922      SaveFldVal(fDat, GetScheduledActivity_RepetitionNumber(ScheduledActivity)); 
923      SaveFldVal(fDat, GetScheduledActivity_StartingPoint(ScheduledActivity)); 
924      SaveFldVal(fDat, GetScheduledActivity_PatientDuration(ScheduledActivity)); 
925      SaveFldVal(fDat, GetScheduledActivity_StartDateTime(ScheduledActivity)); 
926      SaveFldVal(fDat, "", true); 
927    }
928  }
929  void TThermalSch::SaveOldCsv_UrnikXX() const {
930    TFOut DefSOut("URNIKXXG.TXT"); FILE* fDef=DefSOut.GetFileId();
931    SaveFldDef(fDef, "SIFRA101");
932    SaveFldDef(fDef, "SIFRA060");
933    SaveFldDef(fDef, "SIFRA052");
934    SaveFldDef(fDef, "DATUM060");
935    SaveFldDef(fDef, "START060");
936    SaveFldDef(fDef, "NARP_060");
937    SaveFldDef(fDef, "NARA_060");
938    SaveFldDef(fDef, "UJEMANJE");
939    TFOut DatSOut("URNIKXX0.TXT"); FILE* fDat=DatSOut.GetFileId();
940    int ScheduledActivities=TThermalSch::GetScheduledActivities();
941    for (int ScheduledActivityN=0; ScheduledActivityN<ScheduledActivities; ScheduledActivityN++){
942      PXmlTok ScheduledActivity=TThermalSch::GetScheduledActivity(ScheduledActivityN);
943      SaveFldVal(fDat, GetScheduledActivity_PatientCode(ScheduledActivity)); 
944      SaveFldVal(fDat, GetScheduledActivity_ActivityCode(ScheduledActivity)); 
945      SaveFldVal(fDat, GetScheduledActivity_TherapyPlaceCode(ScheduledActivity)); 
946      SaveFldVal(fDat, GetScheduledActivity_Date(ScheduledActivity)); 
947      SaveFldVal(fDat, GetScheduledActivity_StartTime(ScheduledActivity)); 
948      SaveFldVal(fDat, GetScheduledActivity_PatientDuration(ScheduledActivity)); 
949      SaveFldVal(fDat, GetScheduledActivity_TPDuration(ScheduledActivity)); 
950      SaveFldVal(fDat, GetScheduledActivity_Accordance(ScheduledActivity), true); 
951    }
952  }
953  PThermalSch TThermalSch::DllThermalSch=TThermalSch::New();
954  char* TThermalSch::DllExeCmFromXmlFile(char* FNm, char* FPath){
955    TStr MsgXmlStr=DllThermalSch->ExeCmFromXmlFile(FNm, FPath);
956    return MsgXmlStr.GetCStr();
957  }
958  char* TThermalSch::DllExeCmFromXmlStr(char* XmlStr){
959    TStr MsgXmlStr=DllThermalSch->ExeCmFromXmlStr(XmlStr);
960    return MsgXmlStr.GetCStr();
961  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-amazon.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-infonet.cpp</div>
                </div>
                <div class="column column_space"><pre><code>234    if (!IsItem(AmazonItem->GetItemId())){
235      printf("'%s'\n", AmazonItem->GetTitleStr().CStr());
236      AddItem(AmazonItem->GetItemId());
237      PXmlDoc ItemXmlDoc=AmazonItem->GetXmlDoc();
238      ItemXmlDoc->SaveTxt(XmlSOut); XmlSOut->PutDosLn(); XmlSOut->Flush();
239      for (int ItemIdN=0; ItemIdN<AmazonItem->GetNextItemIds(); ItemIdN++){
240        TStr ItemId=AmazonItem->GetNextItemId(ItemIdN);
241        if (!IsItem(ItemId)){
242          TStr UrlStr=TAmazonItem::GetUrlStr(ItemId);
243          FetchUrl(UrlStr);
244        }
</pre></code></div>
                <div class="column column_space"><pre><code>610      for (int RecN=0; RecN<RecFldValVV.Len(); RecN++){
611        TStrV& FldValV=RecFldValVV[RecN];
612        fprintf(XmlFId, "<ScheduledActivity>\n");
613        for (int FldN=0; FldN<FldValV.Len(); FldN++){
614          TStr FldNm=FldNmV[FldN];
615          if (FldNm=="SIFRA101"){FldNm="PatientCode";}
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    