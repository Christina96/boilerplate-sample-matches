
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 14.873837981407704%, Tokens: 10</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-nytngrams.cpp</h3>
            <pre><code>1  #include "nytngrams.h"
2  bool TNytNGramBs::IsNGram(const TStrV& TermStrV, int& NGramId) const {
3    NGramId=TermStrVH.GetKeyId(TermStrV);
4    return NGramId!=-1;
5  }
6  TStr TNytNGramBs::GetNGramStr(const int& NGramId) const {
7    const TStrV& TermStrV=TermStrVH.GetKey(NGramId);
8    TChA NGramChA;
9    for (int TermStrN=0; TermStrN<TermStrV.Len(); TermStrN++){
10      if (TermStrN>0){NGramChA+=' ';}
11      NGramChA+=TermStrV[TermStrN];
12    }
13    return NGramChA;
14  }
15  void TNytNGramBs::GetNGramStrV(const TStr& HtmlStr, TStrV& NGramStrV){
16    NGramStrV.Clr();
17    PSIn HtmlSIn=TStrIn::New(HtmlStr);
18    THtmlLx HtmlLx(HtmlSIn);
19    TStrV StrV;
20    while (HtmlLx.GetSym()!=hsyEof){
21      TStr Str=HtmlLx.ChA;
22      Str.ToLc();
23      switch (HtmlLx.Sym){
24        case hsyUndef:
25        case hsyUrl:
26        case hsyMTag:
27        case hsySSym:
28          StrV.Clr();
29          break;
30        case hsyStr:
31        case hsyNum:
32          NGramStrV.Add(Str);
33          StrV.Add(Str);
34          for (int NGramLen=2; NGramLen<=4; NGramLen++){
35            if (StrV.Len()<NGramLen){break;}
36            TStrV TermStrV(NGramLen, 0);
37            for (int StrN=StrV.Len()-NGramLen; StrN<StrV.Len(); StrN++){
38              TermStrV.Add(StrV[StrN]);
39            }
40            int NGramId;
41            if (IsNGram(TermStrV, NGramId)){
42              TStr NGramStr=GetNGramStr(NGramId);
43              NGramStrV.Add(NGramStr);
44            }
45          } 
46          break;
47        case hsyBTag:
48        case hsyETag:
49          StrV.Clr();
50          break;
51        case hsyEof: break;
52        default: Fail;
53      }
54    }
55  }
56  PNytNGramBs TNytNGramBs::LoadNytNGramBs(const TStr& InNGramsFPath, const int& ExpectedNGrams){
57    TStr InNGramsNrFPath=TStr::GetNrFPath(InNGramsFPath);
58    TStr LexiconFNm=InNGramsNrFPath+"Lexicon.Csv";
59    TStr Coloc2FNm=InNGramsNrFPath+"significant_colocations_2.bin";
60    TStr Coloc3FNm=InNGramsNrFPath+"significant_colocations_3.bin";
61    TStr Coloc4FNm=InNGramsNrFPath+"significant_colocations_4.bin";
62    printf("Loading Lexicon from %s ...\n", LexiconFNm.CStr());
63    PSs LexiconSs=TSs::LoadTxt(ssfCommaSep, LexiconFNm, TNotify::StdNotify, false);
64    printf("Done.");
65    PNytNGramBs NytNGramBs=TNytNGramBs::New(ExpectedNGrams);
<span onclick='openModal()' class='match'>66    int Terms=LexiconSs->GetYLen();
67    TIntStrH TermIdToStrH(Terms*2);
68    for (int TermN=0; TermN<Terms; TermN++){
69      int TermId=LexiconSs->At(0, TermN).GetInt();
70      TStr TermStr=LexiconSs->At(1, TermN);
71      TermIdToStrH.AddDat(TermId, TermStr);
72      TStrV TermStrV(1, 0); TermStrV.Add(TermStr); 
73      NytNGramBs->TermStrVH.AddDat(TermStrV);
74    }
</span>75    {printf("Load Collocations from '%s' ...\n", Coloc2FNm.CStr());
76    FILE* fColoc=fopen(Coloc2FNm.CStr(), "rb");
77    int Colocs=0; int BadColocs=0;
78    while (!feof(fColoc)){
79      Colocs++; if (Colocs%1000==0){printf("%d\r", Colocs);}
80      int TermId1=-1; int TermId2=-1; 
81      int CorpusFq=-1; int DocFq=-1; double Sig=-1;
82      fread(&TermId1, 4, 1, fColoc); TermId1=TUInt::JavaUIntToCppUInt(TermId1);
83      fread(&TermId2, 4, 1, fColoc); TermId2=TUInt::JavaUIntToCppUInt(TermId2);
84      fread(&CorpusFq, 4, 1, fColoc);
85      fread(&DocFq, 4, 1, fColoc);
86      fread(&Sig, 8, 1, fColoc);
87      TStr TermStr1; TStr TermStr2; 
88      if (TermIdToStrH.IsKeyGetDat(TermId1, TermStr1)){
89        if (TermIdToStrH.IsKeyGetDat(TermId2, TermStr2)){
90          TStrV TermStrV(2, 0); TermStrV.Add(TermStr1); TermStrV.Add(TermStr2);
91          NytNGramBs->TermStrVH.AddDat(TermStrV);
92        } else {BadColocs++;}
93      } else {BadColocs++;}
94    }
95    printf("Colocations:%d Bad Collocations:%d\nDone.\n", Colocs, BadColocs);}
96    {printf("Load Collocations from '%s' ...\n", Coloc3FNm.CStr());
97    FILE* fColoc=fopen(Coloc3FNm.CStr(), "rb");
98    int Colocs=0; int BadColocs=0;
99    while (!feof(fColoc)){
100      Colocs++; if (Colocs%1000==0){printf("%d\r", Colocs);}
101      int TermId1=-1; int TermId2=-1; int TermId3=-1;
102      int CorpusFq=-1; int DocFq=-1; double Sig=-1;
103      fread(&TermId1, 4, 1, fColoc); TermId1=TUInt::JavaUIntToCppUInt(TermId1);
104      fread(&TermId2, 4, 1, fColoc); TermId2=TUInt::JavaUIntToCppUInt(TermId2);
105      fread(&TermId3, 4, 1, fColoc); TermId3=TUInt::JavaUIntToCppUInt(TermId3);
106      fread(&CorpusFq, 4, 1, fColoc);
107      fread(&DocFq, 4, 1, fColoc);
108      fread(&Sig, 8, 1, fColoc);
109      TStr TermStr1; TStr TermStr2; TStr TermStr3; 
110      if (TermIdToStrH.IsKeyGetDat(TermId1, TermStr1)){
111        if (TermIdToStrH.IsKeyGetDat(TermId2, TermStr2)){
112          if (TermIdToStrH.IsKeyGetDat(TermId3, TermStr3)){
113            TStrV TermStrV(3, 0); 
114            TermStrV.Add(TermStr1); TermStrV.Add(TermStr2); TermStrV.Add(TermStr3);
115            NytNGramBs->TermStrVH.AddDat(TermStrV);
116          } else {BadColocs++;}
117        } else {BadColocs++;}
118      } else {BadColocs++;}
119    }
120    printf("Colocations:%d Bad Collocations:%d\nDone.\n", Colocs, BadColocs);}
121    {printf("Load Collocations from '%s' ...\n", Coloc4FNm.CStr());
122    FILE* fColoc=fopen(Coloc4FNm.CStr(), "rb");
123    int Colocs=0; int BadColocs=0;
124    while (!feof(fColoc)){
125      Colocs++; if (Colocs%1000==0){printf("%d\r", Colocs);}
126      int TermId1=-1; int TermId2=-1; int TermId3=-1; int TermId4=-1; 
127      int CorpusFq=-1; int DocFq=-1; double Sig=-1;
128      fread(&TermId1, 4, 1, fColoc); TermId1=TUInt::JavaUIntToCppUInt(TermId1);
129      fread(&TermId2, 4, 1, fColoc); TermId2=TUInt::JavaUIntToCppUInt(TermId2);
130      fread(&TermId3, 4, 1, fColoc); TermId3=TUInt::JavaUIntToCppUInt(TermId3);
131      fread(&TermId4, 4, 1, fColoc); TermId4=TUInt::JavaUIntToCppUInt(TermId4);
132      fread(&CorpusFq, 4, 1, fColoc);
133      fread(&DocFq, 4, 1, fColoc);
134      fread(&Sig, 8, 1, fColoc);
135      TStr TermStr1; TStr TermStr2; TStr TermStr3; TStr TermStr4; 
136      if (TermIdToStrH.IsKeyGetDat(TermId1, TermStr1)){
137        if (TermIdToStrH.IsKeyGetDat(TermId2, TermStr2)){
138          if (TermIdToStrH.IsKeyGetDat(TermId3, TermStr3)){
139            if (TermIdToStrH.IsKeyGetDat(TermId4, TermStr4)){
140              TStrV TermStrV(4, 0); 
141              TermStrV.Add(TermStr1); TermStrV.Add(TermStr2); 
142              TermStrV.Add(TermStr3); TermStrV.Add(TermStr4);
143              NytNGramBs->TermStrVH.AddDat(TermStrV);
144            } else {BadColocs++;}
145          } else {BadColocs++;}
146        } else {BadColocs++;}
147      } else {BadColocs++;}
148    }
149    printf("Colocations:%d Bad Collocations:%d\nDone.\n", Colocs, BadColocs);}
150    printf("All Collocations:%d\n", NytNGramBs->TermStrVH.Len());
151    return NytNGramBs;
152  }
153  void TNytNGramBs::SaveTxt(const TStr& FNm){
154    TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
155    int NGrams=TermStrVH.Len();
156    for (int NGramId=0; NGramId<NGrams; NGramId++){
157      TStr NGramStr=GetNGramStr(NGramId);
158      fprintf(fOut, "%d\t%s\n", NGramId, NGramStr.CStr());
159    }
160  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-wordnet.cpp</h3>
            <pre><code>1  #include "wordnet.h"
2  void TWnSynSet::GetDstSynSetPV(
3   const TWnRelType& RelType, TIntV& DstSynSetPV) const {
4    DstSynSetPV.Clr();
5    for (int RelN=0; RelN<RelIntIntTrV.Len(); RelN++){
6      TWnRelType CurRelType=TWnRelType(RelIntIntTrV[RelN].Val1.Val);
7      if (RelType==CurRelType){
8        int DstSynSetP=RelIntIntTrV[RelN].Val3;
9        DstSynSetPV.Add(DstSynSetP);
10      }
11    }
12  }
13  TWnSynSetType TWnBs::GetSynSetTypeFromStr(const TStr& SynSetTypeStr){
14    if (SynSetTypeStr=="n"){return wsstNoun;}
15    if (SynSetTypeStr=="v"){return wsstVerb;}
16    if (SynSetTypeStr=="a"){return wsstAdjective;}
17    if (SynSetTypeStr=="s"){return wsstAdjectiveSatellite;}
18    if (SynSetTypeStr=="r"){return wsstAdverb;}
19    Fail; return wsstUndef;
20  }
21  void TWnBs::AddRel(const TWnRelType& RelType, const TStr& SrcSynSetId, const TStr& DstSynSetId){
22    IAssert(IsSynSetId(SrcSynSetId)); IAssert(IsSynSetId(DstSynSetId));
23    int SrcSynSetP=GetSynSetP(SrcSynSetId);
24    int DstSynSetP=GetSynSetP(DstSynSetId);
25    PWnSynSet SrcSynSet=GetSynSet(SrcSynSetId);
26    PWnSynSet DstSynSet=GetSynSet(DstSynSetId);
27    SrcSynSet->AddRel(RelType, SrcSynSetP, DstSynSetP);
28    DstSynSet->AddInvRel(RelType, SrcSynSetP, DstSynSetP);
29  }
30  TStr TWnBs::GetRelTypeNm(const TWnRelType& RelType){
31    switch (RelType){
32      case wrtUndef: return "Undef";
33      case wrtSenseKey: return "SenseKey";
34      case wrtGloss: return "Gloss";
35      case wrtSyntax: return "Syntax";
36      case wrtHypernym: return "Hypernym";
37      case wrtInstance: return "Instance";
38      case wrtEntailment: return "Entailment";
39      case wrtSimilar: return "Similar";
40      case wrtMemberMeronym: return "MemberMeronym";
41      case wrtSubstanceMeronym: return "SubstanceMeronym";
42      case wrtPartMeronym: return "PartMeronym";
43      case wrtDerivation: return "Derivation";
44      case wrtClass: return "Class";
45      case wrtCause: return "Cause";
46      case wrtVerbGroup: return "VerbGroup";
47      case wrtAttribute: return "Attribute";
48      case wrtAntonym: return "Antonym";
49      case wrtAdditionalInfo: return "AdditionalInfo";
50      case wrtParticiple: return "Participle";
51      case wrtPosRel: return "PosRel";
52      case wrtFrame: return "Frame";
53      default: Fail; return "";
54    }
55  }
56  void TWnBs::LoadFromPlBs(const PPlBs& PlBs){
57    printf("Loading from Prolog-Base ...\n");
58    int S6_RelId=PlBs->GetRelId("s", 6);
59    int S4_RelId=PlBs->GetRelId("s", 4);
60    printf("  ... collect counts ...\n");
61    TStrIntSH SynSetIdToMxWordNSH;
62    TStrIntSH WordStrToMxSynSetNSH;
63    for (int RelId=0; RelId<PlBs->GetRels(); RelId++){
64      if ((RelId!=S6_RelId)&&(RelId!=S4_RelId)){continue;}
65      for (int TupN=0; TupN<PlBs->GetRelTups(RelId); TupN++){
66        int TupId=PlBs->GetRelTupId(RelId, TupN);
67        PPlTup Tup=PlBs->GetTup(TupId);
68        TStr SynSetId=TInt::GetStr(Tup->GetVal(0).GetInt());
69        int SynSetWordN=Tup->GetVal(1).GetInt();
70        TStr WordStr=PlBs->GetAtomStr(Tup->GetVal(2).GetAtomId());
71        TStr SynSetTypeStr=PlBs->GetAtomStr(Tup->GetVal(3).GetAtomId());
72        int WordSynSetN=(Tup->GetVals()>4) ? Tup->GetVal(4).GetInt() : 1;
73        TStr EWordStr=GetEWordStr(WordStr, SynSetTypeStr);
74        TInt& MxSynSetWordN=SynSetIdToMxWordNSH.AddDat(SynSetId);
75        if (SynSetWordN>MxSynSetWordN){MxSynSetWordN=SynSetWordN;}
76        TInt& MxWordSynSetN=WordStrToMxSynSetNSH.AddDat(EWordStr);
77        if (WordSynSetN>MxWordSynSetN){MxWordSynSetN=WordSynSetN;}
78      }
79    }
80    printf("  ... create synsets ...\n");
81    for (int RelId=0; RelId<PlBs->GetRels(); RelId++){
82      if ((RelId!=S6_RelId)&&(RelId!=S4_RelId)){continue;}
83      for (int TupN=0; TupN<PlBs->GetRelTups(RelId); TupN++){
84        int TupId=PlBs->GetRelTupId(RelId, TupN);
85        PPlTup Tup=PlBs->GetTup(TupId);
86        TStr SynSetId=TInt::GetStr(Tup->GetVal(0).GetInt());
87        int SynSetWordN=Tup->GetVal(1).GetInt();
88        TStr WordStr=PlBs->GetAtomStr(Tup->GetVal(2).GetAtomId());
89        TStr SynSetTypeStr=PlBs->GetAtomStr(Tup->GetVal(3).GetAtomId());
90        TWnSynSetType SynSetType=GetSynSetTypeFromStr(SynSetTypeStr);
91        int WordSynSetN=(Tup->GetVals()>4) ? Tup->GetVal(4).GetInt() : 1;
92        TStr EWordStr=GetEWordStr(WordStr, SynSetTypeStr);
93        int SynSetP=-1;
94        if (IdToWnSynSetSH.IsKey(SynSetId)){
95          SynSetP=IdToWnSynSetSH.GetKeyId(SynSetId);
96        } else {
97          SynSetP=IdToWnSynSetSH.AddKey(SynSetId);
98          IdToWnSynSetSH[SynSetP]=TWnSynSet::New();
99          IdToWnSynSetSH[SynSetP]->SynSetType=SynSetType;
100          int MxSynSetWordN=SynSetIdToMxWordNSH.GetDat(SynSetId);
101          IdToWnSynSetSH[SynSetP]->WordStrPV.Gen(MxSynSetWordN);
102          IdToWnSynSetSH[SynSetP]->WordStrPV.PutAll(-1);
103        }
104        int WordStrP=-1;
105        if (EWordStrToSynSetPVSH.IsKey(EWordStr)){
106          WordStrP=EWordStrToSynSetPVSH.GetKeyId(EWordStr);
107        } else {
108          WordStrP=EWordStrToSynSetPVSH.AddKey(EWordStr);
109          int MxWordSynSetN=WordStrToMxSynSetNSH.GetDat(EWordStr);
110          EWordStrToSynSetPVSH[WordStrP].Gen(MxWordSynSetN);
111          EWordStrToSynSetPVSH[WordStrP].PutAll(-1);
112        }
113        if (IdToWnSynSetSH[SynSetP]->WordStrPV[SynSetWordN-1]==-1){
114          IdToWnSynSetSH[SynSetP]->WordStrPV[SynSetWordN-1]=WordStrP;
115        } else {
116          int TestWordP=IdToWnSynSetSH[SynSetP]->WordStrPV[SynSetWordN-1];
117          TStr TestEWordStr=EWordStrToSynSetPVSH.GetKey(TestWordP);
118          IAssert(EWordStr==TestEWordStr);
119        }
120        if (EWordStrToSynSetPVSH[WordStrP][WordSynSetN-1]==-1){
121          EWordStrToSynSetPVSH[WordStrP][WordSynSetN-1]=SynSetP;
122        } else {
123          int TestSynSetP=EWordStrToSynSetPVSH[WordStrP][WordSynSetN-1];
124          TStr TestSynSetId=IdToWnSynSetSH.GetKey(TestSynSetP);
125          IAssert(SynSetId==TestSynSetId);
126        }
127      }
128    }
129    printf("  ... create relations ...\n");
130    int Sk_RelId=PlBs->GetRelId("sk", 3);
131    int G_RelId=PlBs->GetRelId("g", 2);
132    int Syntax_RelId=PlBs->GetRelId("syntax", 3);
133    int Hyp_RelId=PlBs->GetRelId("hyp", 2);
134    int Ins_RelId=PlBs->GetRelId("ins", 2);
135    int Ent_RelId=PlBs->GetRelId("ent", 2);
136    int Sim_RelId=PlBs->GetRelId("sim", 2);
137    int Mm_RelId=PlBs->GetRelId("mm", 2);
138    int Ms_RelId=PlBs->GetRelId("ms", 2);
139    int Mp_RelId=PlBs->GetRelId("mp", 2);
140    int Der_RelId=PlBs->GetRelId("der", 4);
141    int Cls_RelId=PlBs->GetRelId("cls", 5);
142    int Cs_RelId=PlBs->GetRelId("cs", 2);
143    int Vgp_RelId=PlBs->GetRelId("vgp", 4);
144    int At_RelId=PlBs->GetRelId("at", 2);
145    int Ant_RelId=PlBs->GetRelId("ant", 4);
146    int Sa_RelId=PlBs->GetRelId("sa", 4);
147    int Ppl_RelId=PlBs->GetRelId("ppl", 4);
148    int Per_RelId=PlBs->GetRelId("per", 4);
149    int Fr_RelId=PlBs->GetRelId("fr", 3);
150    for (int RelId=0; RelId<PlBs->GetRels(); RelId++){
151      TWnRelType RelType=wrtUndef; int SrcSynSetIdArgN=-1; int DstSynSetIdArgN=-1;
152      if (RelId==S6_RelId){RelType=wrtUndef;}
153      else if (RelId==S4_RelId){RelType=wrtUndef;}
154      else if (RelId==Sk_RelId){RelType=wrtUndef;}
155      else if (RelId==G_RelId){RelType=wrtUndef;}
156      else if (RelId==Syntax_RelId){RelType=wrtUndef;}
157      else if (RelId==Hyp_RelId){RelType=wrtHypernym; SrcSynSetIdArgN=0; DstSynSetIdArgN=1;}
158      else if (RelId==Ins_RelId){RelType=wrtInstance; SrcSynSetIdArgN=0; DstSynSetIdArgN=1;}
159      else if (RelId==Ent_RelId){RelType=wrtEntailment; SrcSynSetIdArgN=0; DstSynSetIdArgN=1;}
160      else if (RelId==Sim_RelId){RelType=wrtSimilar; SrcSynSetIdArgN=0; DstSynSetIdArgN=1;}
161      else if (RelId==Mm_RelId){RelType=wrtMemberMeronym; SrcSynSetIdArgN=0; DstSynSetIdArgN=1;}
162      else if (RelId==Ms_RelId){RelType=wrtSubstanceMeronym; SrcSynSetIdArgN=0; DstSynSetIdArgN=1;}
163      else if (RelId==Mp_RelId){RelType=wrtPartMeronym; SrcSynSetIdArgN=0; DstSynSetIdArgN=1;}
164      else if (RelId==Der_RelId){RelType=wrtDerivation; SrcSynSetIdArgN=0; DstSynSetIdArgN=2;}
165      else if (RelId==Cls_RelId){RelType=wrtClass; SrcSynSetIdArgN=0; DstSynSetIdArgN=2;}
166      else if (RelId==Cs_RelId){RelType=wrtCause; SrcSynSetIdArgN=0; DstSynSetIdArgN=1;}
167      else if (RelId==Vgp_RelId){RelType=wrtVerbGroup; SrcSynSetIdArgN=0; DstSynSetIdArgN=2;}
168      else if (RelId==At_RelId){RelType=wrtAttribute; SrcSynSetIdArgN=0; DstSynSetIdArgN=1;}
169      else if (RelId==Ant_RelId){RelType=wrtAntonym; SrcSynSetIdArgN=0; DstSynSetIdArgN=2;}
170      else if (RelId==Sa_RelId){RelType=wrtAdditionalInfo; SrcSynSetIdArgN=0; DstSynSetIdArgN=2;}
171      else if (RelId==Ppl_RelId){RelType=wrtParticiple; SrcSynSetIdArgN=0; DstSynSetIdArgN=2;}
172      else if (RelId==Per_RelId){RelType=wrtPosRel; SrcSynSetIdArgN=0; DstSynSetIdArgN=2;}
173      else if (RelId==Fr_RelId){RelType=wrtUndef;}
174      else {TStr FuncArityStr=PlBs->GetFuncArityStr(RelId); Fail;}
175      if (RelType!=wrtUndef){
176        for (int TupN=0; TupN<PlBs->GetRelTups(RelId); TupN++){
177          int TupId=PlBs->GetRelTupId(RelId, TupN);
178          PPlTup Tup=PlBs->GetTup(TupId);
179          TStr SrcSynSetId=TInt::GetStr(Tup->GetVal(SrcSynSetIdArgN).GetInt());
180          TStr DstSynSetId=TInt::GetStr(Tup->GetVal(DstSynSetIdArgN).GetInt());
181          if (IsSynSetId(SrcSynSetId)&&IsSynSetId(DstSynSetId)){
182            AddRel(RelType, SrcSynSetId, DstSynSetId);
183          }
184        }
185      }
186    }
187    printf("Done.\n");
188  }
189  void TWnBs::SaveTxtSynSet(const int& SynSetP, FILE* fOut, const int& LevelN){
190    TStr SynSetId=GetSynSetId(SynSetP);
<span onclick='openModal()' class='match'>191    PWnSynSet SynSet=GetSynSet(SynSetId);
192    fprintf(fOut, "%s%s:", TStr::GetSpaceStr(LevelN*2).CStr(), SynSetId.CStr());
193    for (int WordN=0; WordN<SynSet->GetWords(); WordN++){
194      int EWordStrP=SynSet->GetWordStrP(WordN);
195      TStr WordStr=GetEWordStrP(EWordStrP);
196      fprintf(fOut, " '%s'", WordStr.CStr());
197    }
</span>198    fprintf(fOut, "\n");
199  }
200  void TWnBs::SaveTxtRel(const TWnRelType& RelType, const int& SynSetP,
201   const bool& Recurse, FILE* fOut, const int& LevelN, TIntS& SynSetPS){
202    PWnSynSet SynSet=GetSynSetFromP(SynSetP);
203    TIntV SubSynSetPV; SynSet->GetDstSynSetPV(RelType, SubSynSetPV);
204    if ((LevelN==0)&&(!SubSynSetPV.Empty())){
205      TStr RelTypeNm=GetRelTypeNm(RelType);
206      fprintf(fOut, "  ---%s--------------------------\n", RelTypeNm.CStr());
207    }
208    for (int SubSynSetPN=0; SubSynSetPN<SubSynSetPV.Len(); SubSynSetPN++){
209      int SubSynSetP=SubSynSetPV[SubSynSetPN];
210      SaveTxtSynSet(SubSynSetP, fOut, LevelN+1);
211      if (Recurse){
212        if (!SynSetPS.IsIn(SubSynSetP)){
213          SynSetPS.Push(SubSynSetP);
214          SaveTxtRel(RelType, SubSynSetP, Recurse, fOut, LevelN+1, SynSetPS);
215          SynSetPS.Pop();
216        } else {
217          fprintf(fOut, "  ***Cycling\n");
218        }
219      }
220    }
221  }
222  void TWnBs::SaveTxt(const TStr& FNm){
223    TFOut FOut(FNm); FILE* fOut=FOut.GetFileId();
224    for (int SynSetP=0; SynSetP<GetSynSets(); SynSetP++){
225      fprintf(fOut, "=====================================\n");
226      SaveTxtSynSet(SynSetP, fOut);
227      SaveTxtRel(wrtHypernym, SynSetP, true, fOut);
228      SaveTxtRel(wrtInstance, SynSetP, false, fOut);
229      SaveTxtRel(wrtEntailment, SynSetP, false, fOut);
230      SaveTxtRel(wrtSimilar, SynSetP, false, fOut);
231      SaveTxtRel(wrtMemberMeronym, SynSetP, false, fOut);
232      SaveTxtRel(wrtSubstanceMeronym, SynSetP, false, fOut);
233      SaveTxtRel(wrtPartMeronym, SynSetP, false, fOut);
234      SaveTxtRel(wrtDerivation, SynSetP, false, fOut);
235      SaveTxtRel(wrtClass, SynSetP, false, fOut);
236      SaveTxtRel(wrtCause, SynSetP, false, fOut);
237      SaveTxtRel(wrtVerbGroup, SynSetP, false, fOut);
238      SaveTxtRel(wrtAttribute, SynSetP, false, fOut);
239      SaveTxtRel(wrtAntonym, SynSetP, false, fOut);
240      SaveTxtRel(wrtAdditionalInfo, SynSetP, false, fOut);
241      SaveTxtRel(wrtParticiple, SynSetP, false, fOut);
242      SaveTxtRel(wrtPosRel, SynSetP, false, fOut);
243      fprintf(fOut, "=====================================\n\n");
244    }
245  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-nytngrams.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-wordnet.cpp</div>
                </div>
                <div class="column column_space"><pre><code>66    int Terms=LexiconSs->GetYLen();
67    TIntStrH TermIdToStrH(Terms*2);
68    for (int TermN=0; TermN<Terms; TermN++){
69      int TermId=LexiconSs->At(0, TermN).GetInt();
70      TStr TermStr=LexiconSs->At(1, TermN);
71      TermIdToStrH.AddDat(TermId, TermStr);
72      TStrV TermStrV(1, 0); TermStrV.Add(TermStr); 
73      NytNGramBs->TermStrVH.AddDat(TermStrV);
74    }
</pre></code></div>
                <div class="column column_space"><pre><code>191    PWnSynSet SynSet=GetSynSet(SynSetId);
192    fprintf(fOut, "%s%s:", TStr::GetSpaceStr(LevelN*2).CStr(), SynSetId.CStr());
193    for (int WordN=0; WordN<SynSet->GetWords(); WordN++){
194      int EWordStrP=SynSet->GetWordStrP(WordN);
195      TStr WordStr=GetEWordStrP(EWordStrP);
196      fprintf(fOut, " '%s'", WordStr.CStr());
197    }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    