
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 13.956550362080316%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-soap.cpp</h3>
            <pre><code>1  void TSoapTb::Append(const PSoapTb& SoapTb){
2    for (int RowN=0; RowN<SoapTb->GetRows(); RowN++){
3      AddRow();
4      for (int ColN=0; ColN<SoapTb->GetCols(); ColN++){
5        TStr ColNm, ColVal;
6        if (SoapTb->IsGetColNmVal(RowN, ColN, ColNm, ColVal)){
7          AddVal(ColNm, ColVal);
8        }
9      }
10    }
11  }
12  void TSoapTb::GetValV(const int& ColN, TStrV& ValStrV) const {
13    ValStrV.Clr();
14    int Rows=GetRows();
15    for (int RowN=0; RowN<Rows; RowN++){
16      ValStrV.Add(GetVal(RowN, ColN));
17    }
18  }
19  void TSoapTb::GetValPrV(const int& ColN1, const int& ColN2, TStrPrV& ValStrPrV) const {
20    ValStrPrV.Clr();
21    int Rows=GetRows();
22    for (int RowN=0; RowN<Rows; RowN++){
23      ValStrPrV.Add(TStrPr(GetVal(RowN, ColN1), GetVal(RowN, ColN2)));
24    }
25  }
26  int TSoapTb::GetRowN(const TStr& WhereColNm, const TStr& WhereValStr) const {
27    int Rows=GetRows();
28    for (int RowN=0; RowN<Rows; RowN++){
29      int RowVals=GetRowVals(RowN);
30      TStr ColNm; TStr ValStr;
31      for (int ValN=0; ValN<RowVals; ValN++){
32        GetColNmVal(RowN, ValN, ColNm, ValStr);
33        if ((ColNm==WhereColNm)&&(ValStr==WhereValStr)){
34          return RowN;
35        }
36      }
37    }
38    return -1;
39  }
40  void TSoapTb::SelectValStrV(const TStr& SelColNm, TStrV& SelValStrV,
41   const TStr& WhereColNm, const TStr& WhereValStr) const {
42    SelValStrV.Clr();
43    int Rows=GetRows();
44    for (int RowN=0; RowN<Rows; RowN++){
45      int RowVals=GetRowVals(RowN);
46      TStr ColNm; TStr ValStr;
47      TStr CurSelValStr; TStr CurWhereValStr;
48      for (int ValN=0; ValN<RowVals; ValN++){
49        GetColNmVal(RowN, ValN, ColNm, ValStr);
50        if (ColNm==SelColNm){CurSelValStr=ValStr;}
51        if (ColNm==WhereColNm){CurWhereValStr=ValStr;}
52      }
53      if (CurWhereValStr==WhereValStr){
54        SelValStrV.Add(CurSelValStr);
55      }
56    }
57  }
58  void TSoapTb::SelectValStrV(const TStr& SelColNm, TStrV& SelValStrV,
59   const TStr& WhereColNm1, const TStr& WhereValStr1,
60   const TStr& WhereColNm2, const TStr& WhereValStr2) const {
61    SelValStrV.Clr();
62    int Rows=GetRows();
63    for (int RowN=0; RowN<Rows; RowN++){
64      int RowVals=GetRowVals(RowN);
65      TStr ColNm; TStr ValStr;
66      TStr CurSelValStr; TStr CurWhereValStr1; TStr CurWhereValStr2;
67      for (int ValN=0; ValN<RowVals; ValN++){
68        GetColNmVal(RowN, ValN, ColNm, ValStr);
69        if (ColNm==SelColNm){
70          CurSelValStr=ValStr;}
71        if (ColNm==WhereColNm1){
72          CurWhereValStr1=ValStr;}
73        if (ColNm==WhereColNm2){
74          CurWhereValStr2=ValStr;}
75      }
76      if ((CurWhereValStr1==WhereValStr1)&&(CurWhereValStr2==WhereValStr2)){
77        SelValStrV.Add(CurSelValStr);
78      }
79    }
80  }
81  void TSoapTb::SelectValStr(const TStr& SelColNm, TStr& SelValStr,
82   const TStr& WhereColNm1, const TStr& WhereValStr1,
83   const TStr& WhereColNm2, const TStr& WhereValStr2) const {
84    TStrV SelValStrV;
85    SelectValStrV(SelColNm, SelValStrV, WhereColNm1, WhereValStr1, WhereColNm2, WhereValStr2);
86    if (SelValStrV.Empty()){SelValStr="";}
87    else {SelValStr=SelValStrV[0];}
88  }
89  void TSoapTb::SelectValStr(const TStr& SelColNm, TStr& SelValStr,
90   const TStr& WhereColNm, const TStr& WhereValStr) const {
91    TStrV SelValStrV;
92    SelectValStrV(SelColNm, SelValStrV, WhereColNm, WhereValStr);
93    if (SelValStrV.Empty()){SelValStr="";}
94    else {SelValStr=SelValStrV[0];}
95  }
96  void TSoapTb::Dump(const TStr& FNm) const {
97    TStr D;
98    for (int ColN=0; ColN<GetCols(); ColN++){
99      D+="C"+TInt::GetStr(ColN)+":["+GetColNm(ColN)+"]";}
100    D+="\n";
101    for (int RowN=0; RowN<GetRows(); RowN++){
102      D+="R"+TInt::GetStr(RowN)+":";
103      int Vals=GetRowVals(RowN); TStr ColNm; TStr ValStr;
104      for (int ValN=0; ValN<Vals; ValN++){
105        GetColNmVal(RowN, ValN, ColNm, ValStr);
106        D+=" ["+ColNm+":"+ValStr+"]";
107      }
108      D+="\n";
109    }
110    TFOut F(FNm); F.PutStr(D);
111  }
112  TSoapEnv::TSoapEnv(const TStrPrV& FldNmValPrV):
113    FldNmToValH(), FldNmToValVH(), FldNmToSoapTbH(){
114    int Flds=FldNmValPrV.Len(); int FldN=0;
115    while (FldN<Flds){
116      if (TSoap::IsVecFld(FldN, FldNmValPrV)){
117        TStr FldNm; TStrV FldValV;
118        FldN=TSoap::GetVecFld(FldN, FldNm, FldValV, FldNmValPrV);
119        FldNmToValVH.AddDat(FldNm, FldValV);
120      } else
121      if (TSoap::IsTbFld(FldN, FldNmValPrV)){
122        TStr FldNm; PSoapTb SoapTb;
123        FldN=TSoap::GetTbFld(FldN, FldNm, SoapTb, FldNmValPrV);
124        FldNmToSoapTbH.AddDat(FldNm, SoapTb);
125      } else {
126        TStr FldNm=FldNmValPrV[FldN].Val1;
127        TStr FldVal=FldNmValPrV[FldN].Val2;
128        FldNmToValH.AddDat(FldNm, FldVal);
129        FldN++;
130      }
131    }
132  }
133  void TSoapEnv::CopySoapTbH(const TSoapEnv& SoapEnv){
134    FldNmToSoapTbH.Clr();
135    int KeyId=SoapEnv.FldNmToSoapTbH.FFirstKeyId();
136    while (SoapEnv.FldNmToSoapTbH.FNextKeyId(KeyId)){
137      TStr TbNm; PSoapTb SrcSoapTb;
138      SoapEnv.FldNmToSoapTbH.GetKeyDat(KeyId, TbNm, SrcSoapTb);
139      PSoapTb DestSoapTb=PSoapTb(new TSoapTb(*SrcSoapTb));
140      FldNmToSoapTbH.AddDat(TbNm, DestSoapTb);
141    }
142  }
143  void TSoapEnv::MergeSoapEnv(const PSoapEnv& SoapEnv, const bool& AppendSoapTbP){
144    {int KeyId=SoapEnv->FldNmToValH.FFirstKeyId();
145    while (SoapEnv->FldNmToValH.FNextKeyId(KeyId)){
146      TStr FldNm=SoapEnv->FldNmToValH.GetKey(KeyId);
147      TStr FldVal=SoapEnv->FldNmToValH[KeyId];
148      FldNmToValH.AddDat(FldNm, FldVal);
149    }}
150    {int KeyId=SoapEnv->FldNmToValVH.FFirstKeyId();
151    while (SoapEnv->FldNmToValVH.FNextKeyId(KeyId)){
152      TStr FldNm=SoapEnv->FldNmToValVH.GetKey(KeyId);
153      TStrV& FldValV=SoapEnv->FldNmToValVH[KeyId];
154      FldNmToValVH.AddDat(FldNm, FldValV);
155    }}
156    {int KeyId=SoapEnv->FldNmToSoapTbH.FFirstKeyId();
157    while (SoapEnv->FldNmToSoapTbH.FNextKeyId(KeyId)){
158      TStr FldNm=SoapEnv->FldNmToSoapTbH.GetKey(KeyId);
159      PSoapTb SoapTb=SoapEnv->FldNmToSoapTbH[KeyId];
160      if (AppendSoapTbP&&FldNmToSoapTbH.IsKey(FldNm)){
161        FldNmToSoapTbH.GetDat(FldNm)->Append(SoapTb);
162      } else {
163        FldNmToSoapTbH.AddDat(FldNm, SoapTb);
164      }
165    }}
166  }
167  void TSoapEnv::AddFlattened(TStrPrV& FldNmValPrV) const {
168    for (int FldN=0; FldN<FldNmToValH.Len(); FldN++){
169      TStr FldNm=FldNmToValH.GetKey(FldN);
170      TStr FldVal=FldNmToValH[FldN];
171      FldNmValPrV.Add(TStrPr(FldNm, FldVal));
172    }
173    for (int FldN=0; FldN<FldNmToValVH.Len(); FldN++){
174      TStr FldNm=FldNmToValVH.GetKey(FldN);
175      const TStrV& FldValV=FldNmToValVH[FldN];
176      TSoap::AddVecFld(FldNm, FldValV, FldNmValPrV);
177    }
178    for (int FldN=0; FldN<FldNmToSoapTbH.Len(); FldN++){
179      TStr FldNm=FldNmToSoapTbH.GetKey(FldN);
180      PSoapTb SoapTb=FldNmToSoapTbH[FldN];
181      TSoap::AddTbFld(FldNm, SoapTb, FldNmValPrV);
182    }
183  }
184  const TStr TSoap::ResponseStr="Response";
185  const TStr TSoap::VersionMismatchCodeNm="env:VersionMismatch";
186  const TStr TSoap::MustUnderstandCodeNm="env:MustUnderstand";
187  const TStr TSoap::DataEncodingUnknownCodeNm="env:DataEncodingUnknown";
188  const TStr TSoap::SenderCodeNm="env:Sender";
189  const TStr TSoap::ReceiverCodeNm="env:Receiver";
190  void TSoap::GetFromXmlStr(
191   const TStr& XmlStr, const bool& RespP,
192   TBool& Ok, bool& FaultP,
193   TStr& FuncNm, TStrPrV& FldNmValPrV,
194   TStr& FaultCodeNm, TStr& FaultReasonStr){
195    Ok=false; FaultP=true;
196    FuncNm=""; FldNmValPrV.Clr();
197    FaultCodeNm=""; FaultReasonStr="";
198    PSIn SIn=TStrIn::New(XmlStr);
199    PXmlDoc XmlDoc=TXmlDoc::LoadTxt(SIn);
200    if (XmlDoc->IsOk()){
201      PXmlTok EnvTok=XmlDoc->GetTok();
202      if (EnvTok->IsTag("env:Envelope")){
203        PXmlTok BodyTok;
204        if (EnvTok->IsSubTag("env:Body", BodyTok)){
205          PXmlTok FaultTok;
206          if (RespP&&(BodyTok->IsSubTag("env:Fault", FaultTok))){
207            FaultP=true;
208            FaultCodeNm=FaultTok->GetTagTokStr("env:Code|env:Value");
209            FaultReasonStr=FaultTok->GetTagTokStr("env:Reason|env:Text");
210            Ok=(!FaultCodeNm.Empty());
211          } else {
212            PXmlTok FuncTok;
213            for (int TokN=0; TokN<BodyTok->GetSubToks(); TokN++){
214              PXmlTok Tok=BodyTok->GetSubTok(TokN);
215              if (Tok->IsTag()){
216                TStr TagNm=Tok->GetTagNm();
217                if (RespP){
218                  if (TagNm.IsSuffix(TSoap::ResponseStr)){
219                    Ok=true; FaultP=false;
220                    FuncTok=Tok;
221                    FuncNm=TagNm.GetSubStr(0,
222                     TagNm.Len()-1-TStr(TSoap::ResponseStr).Len());
223                    break;
224                  }
225                } else {
226                  Ok=true; FaultP=false;
227                  FuncTok=Tok;
228                  FuncNm=TagNm;
229                }
230              }
231            }
232            if (!FuncTok.Empty()){
233              for (int TokN=0; TokN<FuncTok->GetSubToks(); TokN++){
234                PXmlTok FldTok=FuncTok->GetSubTok(TokN);
235                if (FldTok->IsTag()){
236                  TStr FldNm=FldTok->GetTagNm();
237                  TStr FldVal=FldTok->GetTagTokStr("");
238                  FldNmValPrV.Add(TStrPr(FldNm, FldVal));
239                }
240              }
241            }
242          }
243        }
244      }
245    }
246  }
247  TStr TSoap::GetUrlPathStr(
248   const TStr& FuncNm, const bool& RespP,
249   const TStrPrV& FldNmValPrV){
250    TChA ChA;
251    TStr UrlFuncNm=TUrl::GetUrlSearchStr(FuncNm);
252    ChA+=UrlFuncNm; if (RespP){ChA+="Response";} ChA+="?";
253    for (int FldN=0; FldN<FldNmValPrV.Len(); FldN++){
254      if (FldN>0){ChA+='&';}
255      TStr UrlFldNm=TUrl::GetUrlSearchStr(FldNmValPrV[FldN].Val1);
256      TStr UrlFldVal=TUrl::GetUrlSearchStr(FldNmValPrV[FldN].Val2);
257      ChA+=UrlFldNm; ChA+="="; ChA+=UrlFldVal;
258    }
259    return ChA;
260  }
261  TStr TSoap::GetUrlPathStr(
262   const TStr& FuncNm, const bool& RespP,
263   const TStr& FldNm1, const TStr& FldVal1,
264   const TStr& FldNm2, const TStr& FldVal2){
265    TStrPrV FldNmValPrV(2, 0);
266    if (!FldNm1.Empty()){
267      FldNmValPrV.Add(TStrPr(FldNm1, FldVal1));}
268    if (!FldNm2.Empty()){
269      FldNmValPrV.Add(TStrPr(FldNm2, FldVal2));}
270    return GetUrlPathStr(FuncNm, RespP, FldNmValPrV);
271  }
272  TStr TSoap::GetXmlStr(
273   const TStr& FuncNm, const bool& RespP,
274   const TStrPrV& FldNmValPrV){
275    TStr FuncXmlNm=FuncNm.GetTrunc(); 
276    TChA ChA;
277    ChA+="<?xml version='1.0' ?>\n";
278    ChA+="<env:Envelope xmlns:env=\"http:&bsol;&bsol;www.w3.org/2003/05/soap-envelope\">\n";
279    ChA+="  <env:Body>\n";
280    ChA+="    <"; ChA+=FuncXmlNm; if (RespP){ChA+="Response";} ChA+=">\n";
281    for (int FldN=0; FldN<FldNmValPrV.Len(); FldN++){
282      TStr FldNm=FldNmValPrV[FldN].Val1.GetTrunc(); 
283      TStr FldVal=TXmlLx::GetXmlStrFromPlainStr(FldNmValPrV[FldN].Val2);
284      ChA+="      <"; ChA+=FldNm; ChA+=">";
285      ChA+=FldVal;
286      ChA+="</"; ChA+=FldNm;ChA+=">\n";
287    }
288    ChA+="    </"; ChA+=FuncXmlNm; if (RespP){ChA+="Response";} ChA+=">\n";
289    ChA+="  </env:Body>\n";
290    ChA+="</env:Envelope>\n";
291    return ChA;
292  }
293  TStr TSoap::GetXmlStr(
294   const TStr& FuncNm, const bool& RespP){
295    TStrPrV FldNmValPrV;
296    return GetXmlStr(FuncNm, RespP, FldNmValPrV);
297  }
298  TStr TSoap::GetXmlStr(
299   const TStr& FuncNm, const bool& RespP,
300   const TStr& FldNm, const TStr& FldVal){
301    TStrPrV FldNmValPrV;
302    FldNmValPrV.Add(TStrPr(FldNm, FldVal));
303    return GetXmlStr(FuncNm, RespP, FldNmValPrV);
304  }
305  TStr TSoap::GetXmlStr(
306   const TStr& FuncNm, const bool& RespP,
307   const TStr& FldNm1, const TStr& FldVal1,
308   const TStr& FldNm2, const TStr& FldVal2){
309    TStrPrV FldNmValPrV;
310    FldNmValPrV.Add(TStrPr(FldNm1, FldVal1));
311    FldNmValPrV.Add(TStrPr(FldNm2, FldVal2));
312    return GetXmlStr(FuncNm, RespP, FldNmValPrV);
313  }
314  TStr TSoap::GetFaultXmlStr(const TStr& CodeNm, const TStr& ReasonStr){
315    TStr ReasonXmlStr=TXmlLx::GetXmlStrFromPlainStr(ReasonStr);
316    TChA ChA;
317    ChA+="<?xml version='1.0' ?>\n";
318    ChA+="<env:Envelope\n";
319    ChA+=" xmlns:env=\"http:&bsol;&bsol;www.w3.org/2003/05/soap-envelope\"\n";
320    ChA+=" xmlns:rpc='http:&bsol;&bsol;www.w3.org/2003/05/soap-rpc'>\n";
321    ChA+="  <env:Body>\n";
322    ChA+="    <env:Fault>\n";
323    ChA+="      <env:Code>\n";
324    ChA+="        <env:Value>"; ChA+=CodeNm; ChA+="</env:Value>\n";
325    ChA+="      </env:Code>\n";
326    ChA+="      <env:Reason>\n";
327    ChA+="        <env:Text>"; ChA+=ReasonXmlStr; ChA+="</env:Text>\n";
328    ChA+="      </env:Reason>\n";
329    ChA+="    </env:Fault>\n";
330    ChA+="  </env:Body>\n";
331    ChA+="</env:Envelope>";
332    return ChA;
333  }
334  bool TSoap::IsVecFld(const int& FldN, const TStrPrV& FldNmValPrV){
335    return FldNmValPrV[FldN].Val1.IsSuffix("_VecBeg");
336  }
337  bool TSoap::IsVecFld(const TStr& FldNm, const TStrPrV& FldNmValPrV){
338    TStr VecBeg_FldNm=FldNm+"_VecBeg";
339    int Flds=FldNmValPrV.Len();
340    for (int FldN=0; FldN<Flds; FldN++){
341      if (FldNmValPrV[FldN].Val1==VecBeg_FldNm){return true;}
342    }
343    return false;
344  }
345  void TSoap::AddVecFld(const TStr& FldNm, const TStrV& FldValV, TStrPrV& FldNmValPrV){
346    FldNmValPrV.Add(TStrPr(FldNm+"_VecBeg", TInt::GetStr(FldValV.Len())));
347    for (int ValN=0; ValN<FldValV.Len(); ValN++){
348      FldNmValPrV.Add(TStrPr(FldNm+"_"+TInt::GetStr(ValN), FldValV[ValN]));
349    }
350    FldNmValPrV.Add(TStrPr(FldNm+"_VecEnd", TInt::GetStr(FldValV.Len())));
351  }
352  void TSoap::GetVecFld(const TStr& FldNm, TStrV& FldValV, const TStrPrV& FldNmValPrV){
353    TStr VecBeg_FldNm=FldNm+"_VecBeg";
354    int Flds=FldNmValPrV.Len(); int FldN=0;
355    while (FldN<Flds){
356      if (FldNmValPrV[FldN].Val1==VecBeg_FldNm){break;}
357      FldN++;
358    }
359    if (FldN==Flds){
360      FldValV.Clr();
361    } else {
362      TStr _FldNm; GetVecFld(FldN, _FldNm, FldValV, FldNmValPrV);
363    }
364  }
365  int TSoap::GetVecFld(
366   const int& _FldN, TStr& FldNm, TStrV& FldValV, const TStrPrV& FldNmValPrV){
367    IAssert(IsVecFld(_FldN, FldNmValPrV));
368    int Flds=FldNmValPrV.Len();
369    int FldN=_FldN;
370    FldNm=FldNmValPrV[FldN].Val1;
371    FldNm=FldNm.GetSubStr(0, FldNm.Len()-TStr("_VecBeg").Len()-1);
372    TStr VecEnd_FldNm=FldNm+"_VecEnd";
373    FldValV.Clr(); FldN++;
374    while (FldN<Flds){
375      if (FldNmValPrV[FldN].Val1==VecEnd_FldNm){FldN++; break;}
376      else {FldValV.Add(FldNmValPrV[FldN].Val2);}
377      FldN++;
378    }
379    return FldN;
380  }
381  bool TSoap::IsTbFld(const int& FldN, const TStrPrV& FldNmValPrV){
382    return FldNmValPrV[FldN].Val1.IsSuffix("_TbBeg");
383  }
384  bool TSoap::IsTbFld(const TStr& FldNm, const TStrPrV& FldNmValPrV){
385    TStr BTbFldNm=FldNm+"_TbBeg";
386    int Flds=FldNmValPrV.Len();
387    for (int FldN=0; FldN<Flds; FldN++){
388      if (FldNmValPrV[FldN].Val1==BTbFldNm){return true;}
389    }
390    return false;
391  }
392  void TSoap::AddTbFld(const TStr& TbFldNm, const PSoapTb& SoapTb, TStrPrV& FldNmValPrV){
393    int Rows=SoapTb->GetRows();
394    FldNmValPrV.Add(TStrPr(TbFldNm+"_TbBeg", TInt::GetStr(SoapTb->GetRows())));
395    for (int RowN=0; RowN<Rows; RowN++){
396      FldNmValPrV.Add(TStrPr(TbFldNm+"_TbRowBeg_"+TInt::GetStr(RowN), TStr()));
<span onclick='openModal()' class='match'>397      int RowVals=SoapTb->GetRowVals(RowN); TStr ColNm; TStr ValStr;
398      for (int RowValN=0; RowValN<RowVals; RowValN++){
399        SoapTb->GetColNmVal(RowN, RowValN, ColNm, ValStr);
400        FldNmValPrV.Add(TStrPr(TbFldNm+"_"+ColNm+"_"+TInt::GetStr(RowN), ValStr));
401      }
402      FldNmValPrV.Add(TStrPr(TbFldNm+"_TbRowEnd_"+TInt::GetStr(RowN), TStr()));
403    }
404    FldNmValPrV.Add(TStrPr(TbFldNm+"_TbEnd", TInt::GetStr(SoapTb->GetRows())));
405  }
</span>406  void TSoap::GetTbFld(const TStr& TbFldNm, PSoapTb& SoapTb, const TStrPrV& FldNmValPrV){
407    TStr TbBeg_FldNm=TbFldNm+"_TbBeg";
408    int Flds=FldNmValPrV.Len(); int FldN=0;
409    while (FldN<Flds){
410      if (FldNmValPrV[FldN].Val1==TbBeg_FldNm){break;}
411      FldN++;
412    }
413    if (FldN==Flds){
414      SoapTb=TSoapTb::New();
415    } else {
416      TStr _FldNm; GetTbFld(FldN, _FldNm, SoapTb, FldNmValPrV);
417    }
418  }
419  int TSoap::GetTbFld(
420   const int& _FldN, TStr& TbFldNm, PSoapTb& SoapTb, const TStrPrV& FldNmValPrV){
421    IAssert(IsTbFld(_FldN, FldNmValPrV));
422    int Flds=FldNmValPrV.Len();
423    int FldN=_FldN;
424    TbFldNm=FldNmValPrV[FldN].Val1;
425    TbFldNm=TbFldNm.GetSubStr(0, TbFldNm.Len()-TStr("_TbBeg").Len()-1);
426    TStr TbEnd_FldNm=TbFldNm+"_TbEnd";
427    TStr TbRowBeg_FldNm=TbFldNm+"_TbRowBeg_"; 
428    TStr TbRowEnd_FldNm=TbFldNm+"_TbRowEnd_";
429    SoapTb=TSoapTb::New(); FldN++;
430    while (FldN<Flds){
431      TStr FldNm=FldNmValPrV[FldN].Val1;
432      TStr FldVal=FldNmValPrV[FldN].Val2;
433      if (FldNm==TbEnd_FldNm){FldN++; break;}
434      else if (FldNm.IsStrIn(TbRowBeg_FldNm)){SoapTb->AddRow();}
435      else if (FldNm.IsStrIn(TbRowEnd_FldNm)){}
436      else {
437        TStr FNmPrefix=TbFldNm+"_";
438        TStr FNmSuffix="_"+TInt::GetStr(SoapTb->GetRows()-1);
439        if (FldNm.IsPrefix(FNmPrefix)&&FldNm.IsSuffix(FNmSuffix)){
440          FldNm=FldNm.GetSubStr(FNmPrefix.Len(), FldNm.Len()-1-FNmSuffix.Len());
441        } else {WarnNotify("Invalid Field-Name Prefix/Suffix in Soap Table "+TbFldNm);}
442        SoapTb->AddVal(FldNm, FldVal);
443      }
444      FldN++;
445    }
446    return FldN;
447  }
448  PSoapRq TSoapRq::New(const TStr& FuncNm,
449   const TStr& FldNm, const TStr& FldVal){
450    PSoapRq SoapRq=TSoapRq::New(FuncNm);
451    SoapRq->AddFldNmVal(FldNm, FldVal);
452    return SoapRq;
453  }
454  PSoapRq TSoapRq::New(const TStr& FuncNm,
455   const TStr& FldNm1, const TStr& FldVal1,
456   const TStr& FldNm2, const TStr& FldVal2){
457    PSoapRq SoapRq=TSoapRq::New(FuncNm);
458    SoapRq->AddFldNmVal(FldNm1, FldVal1);
459    SoapRq->AddFldNmVal(FldNm2, FldVal2);
460    return SoapRq;
461  }
462  PSoapRq TSoapRq::New(const TStr& FuncNm,
463   const TStr& FldNm1, const TStr& FldVal1,
464   const TStr& FldNm2, const TStr& FldVal2,
465   const TStr& FldNm3, const TStr& FldVal3){
466    PSoapRq SoapRq=TSoapRq::New(FuncNm);
467    SoapRq->AddFldNmVal(FldNm1, FldVal1);
468    SoapRq->AddFldNmVal(FldNm2, FldVal2);
469    SoapRq->AddFldNmVal(FldNm3, FldVal3);
470    return SoapRq;
471  }
472  PSoapRq TSoapRq::New(const TStr& FuncNm,
473   const TStr& FldNm1, const TStr& FldVal1,
474   const TStr& FldNm2, const TStr& FldVal2,
475   const TStr& FldNm3, const TStr& FldVal3,
476   const TStr& FldNm4, const TStr& FldVal4){
477    PSoapRq SoapRq=TSoapRq::New(FuncNm);
478    SoapRq->AddFldNmVal(FldNm1, FldVal1);
479    SoapRq->AddFldNmVal(FldNm2, FldVal2);
480    SoapRq->AddFldNmVal(FldNm3, FldVal3);
481    SoapRq->AddFldNmVal(FldNm4, FldVal4);
482    return SoapRq;
483  }
484  PSoapRq TSoapRq::New(const TStr& FuncNm,
485   const TStr& FldNm1, const TStr& FldVal1,
486   const TStr& FldNm2, const TStr& FldVal2,
487   const TStr& FldNm3, const TStr& FldVal3,
488   const TStr& FldNm4, const TStr& FldVal4,
489   const TStr& FldNm5, const TStr& FldVal5){
490    PSoapRq SoapRq=TSoapRq::New(FuncNm);
491    SoapRq->AddFldNmVal(FldNm1, FldVal1);
492    SoapRq->AddFldNmVal(FldNm2, FldVal2);
493    SoapRq->AddFldNmVal(FldNm3, FldVal3);
494    SoapRq->AddFldNmVal(FldNm4, FldVal4);
495    SoapRq->AddFldNmVal(FldNm5, FldVal5);
496    return SoapRq;
497  }
498  void TSoapRq::AddFldNmVal(const TStr& FldNm, const TStr& FldVal){
499    for (int FldN=0; FldN<FldNmValPrV.Len(); FldN++){
500      if (FldNmValPrV[FldN].Val1==FldNm){
501        FldNmValPrV[FldN].Val2=FldVal; return;
502      }
503    }
504    FldNmValPrV.Add(TStrPr(FldNm, FldVal));
505  }
506  bool TSoapRq::IsFldNm(const TStr& FldNm) const {
507    int Flds=GetFlds();
508    TStr _FldNm; TStr FldVal;
509    for (int FldN=0; FldN<Flds; FldN++){
510      GetFldNmVal(FldN, _FldNm, FldVal);
511      if (FldNm==_FldNm){return true;}
512    }
513    return false;
514  }
515  bool TSoapRq::IsFldNmVal(const TStr& FldNm, const TStr& FldVal) const {
516    int Flds=GetFlds();
517    TStr _FldNm; TStr _FldVal;
518    for (int FldN=0; FldN<Flds; FldN++){
519      GetFldNmVal(FldN, _FldNm, _FldVal);
520      if ((FldNm==_FldNm)&&(FldVal==_FldVal)){return true;}
521    }
522    return false;
523  }
524  TStr TSoapRq::GetFldVal(const TStr& FldNm) const {
525    int Flds=GetFlds();
526    TStr _FldNm; TStr FldVal;
527    for (int FldN=0; FldN<Flds; FldN++){
528      GetFldNmVal(FldN, _FldNm, FldVal);
529      if (FldNm==_FldNm){return FldVal;}
530    }
531    return "";
532  }
533  TSoapRq::TSoapRq(const PHttpRq& HttpRq):
534    Ok(false){
535    if (HttpRq->IsOk()){
536      if (HttpRq->IsContType(THttp::AppSoapXmlFldVal)){
537        TStr XmlStr=HttpRq->GetBodyAsStr();
538        bool _FaultP; TStr _FaultCodeNm; TStr _FaultReasonStr;
539        TSoap::GetFromXmlStr(
540         XmlStr, false, Ok, _FaultP,
541         FuncNm, FldNmValPrV, _FaultCodeNm, _FaultReasonStr);
542      } else {
543        PUrl Url=HttpRq->GetUrl();
544        if (Url->GetPathSegs()>0){
545          FuncNm=Url->GetPathSeg(Url->GetPathSegs()-1);}
546        if (FuncNm.Empty()){
547          FuncNm="Info";
548        } else {
549          PUrlEnv UrlEnv=HttpRq->GetUrlEnv();
550          for (int KeyN=0; KeyN<UrlEnv->GetKeys(); KeyN++){
551            TStr FldNm=UrlEnv->GetKeyNm(KeyN);
552            TStr FldVal=UrlEnv->GetVal(FldNm);
553            FldNmValPrV.Add(TStrPr(FldNm, FldVal));
554          }
555        }
556        Ok=true;
557      }
558    }
559  }
560  TSoapResp::TSoapResp(const PHttpResp& HttpResp):
561    Ok(false){
562    if (HttpResp->IsOk()){
563      if (HttpResp->IsContType(THttp::AppSoapXmlFldVal)){
564        TStr XmlStr=HttpResp->GetBodyAsStr();
565        TSoap::GetFromXmlStr(
566         XmlStr, true, Ok, FaultP,
567         FuncNm, FldNmValPrV, FaultCodeNm, FaultReasonStr);
568      }
569    }
570  }
571  void TSoapResp::AddFldNmVal(const TStr& FldNm, const TStr& FldVal){
572    for (int FldN=0; FldN<FldNmValPrV.Len(); FldN++){
573      if (FldNmValPrV[FldN].Val1==FldNm){
574        FldNmValPrV[FldN].Val2=FldVal; return;
575      }
576    }
577    FldNmValPrV.Add(TStrPr(FldNm, FldVal));
578  }
579  void TSoapResp::GetFldNmValKdV(TStrKdV& FldNmValKdV) const {
580    FldNmValKdV.Clr();
581    for (int FldN=0; FldN<GetFlds(); FldN++){
582      TStr FldNm; TStr FldVal; GetFldNmVal(FldN, FldNm, FldVal);
583      FldNmValKdV.Add(TStrKd(FldNm, FldVal));
584    }
585  }
586  bool TSoapResp::IsFldNm(const TStr& FldNm) const {
587    int Flds=GetFlds();
588    TStr _FldNm; TStr FldVal;
589    for (int FldN=0; FldN<Flds; FldN++){
590      GetFldNmVal(FldN, _FldNm, FldVal);
591      if (FldNm==_FldNm){return true;}
592    }
593    return false;
594  }
595  TStr TSoapResp::GetFldVal(const TStr& FldNm) const {
596    int Flds=GetFlds();
597    TStr _FldNm; TStr FldVal;
598    for (int FldN=0; FldN<Flds; FldN++){
599      GetFldNmVal(FldN, _FldNm, FldVal);
600      if (FldNm==_FldNm){return FldVal;}
601    }
602    return "";
603  }
604  TStr TSoapResp::GetRespStr() const {
605    if (IsOk()){
606      if (IsResult()){
607        return GetRespStr(FuncNm, FldNmValPrV);
608      } else {
609        return GetFaultRespStr(FaultCodeNm, FaultReasonStr);
610      }
611    } else {
612      return GetFaultRespStr(TSoap::DataEncodingUnknownCodeNm, "Unknown Error.");
613    }
614  }
615  TStr TSoapResp::GetAsUrlPathStr() const {
616    if (IsResult()){
617      return TSoap::GetUrlPathStr(FuncNm, true, FldNmValPrV);
618    } else
619    if (IsFault()){
620      return TSoap::GetUrlPathStr("Fault", true,
621       "FaultCode", GetFaultCodeNm(),
622       "FaultReason", GetFaultReasonStr());
623    } else {
624      return TSoap::GetUrlPathStr("Fault", true);
625    }
626  }
627  PHttpResp TSoapResp::GetHttpResp(const TStr& FuncNm,
628   const TStr& FldNm1, const TStr& FldVal1,
629   const TStr& FldNm2, const TStr& FldVal2,
630   const TStr& FldNm3, const TStr& FldVal3){
631    PSoapResp SoapResp=TSoapResp::New(FuncNm);
632    SoapResp->AddFldNmVal(FldNm1, FldVal1);
633    SoapResp->AddFldNmVal(FldNm2, FldVal2);
634    SoapResp->AddFldNmVal(FldNm3, FldVal3);
635    return SoapResp->GetHttpResp();
636  }
637  PHttpResp TSoapResp::GetHttpResp(const TStr& FuncNm,
638   const TStr& FldNm1, const TStr& FldVal1,
639   const TStr& FldNm2, const TStr& FldVal2,
640   const TStr& FldNm3, const TStr& FldVal3,
641   const TStr& FldNm4, const TStr& FldVal4){
642    PSoapResp SoapResp=TSoapResp::New(FuncNm);
643    SoapResp->AddFldNmVal(FldNm1, FldVal1);
644    SoapResp->AddFldNmVal(FldNm2, FldVal2);
645    SoapResp->AddFldNmVal(FldNm3, FldVal3);
646    SoapResp->AddFldNmVal(FldNm4, FldVal4);
647    return SoapResp->GetHttpResp();
648  }
649  PHttpResp TSoapResp::GetHttpResp(const TStr& FuncNm,
650   const TStr& FldNm1, const TStr& FldVal1,
651   const TStr& FldNm2, const TStr& FldVal2,
652   const TStr& FldNm3, const TStr& FldVal3,
653   const TStr& FldNm4, const TStr& FldVal4,
654   const TStr& FldNm5, const TStr& FldVal5){
655    PSoapResp SoapResp=TSoapResp::New(FuncNm);
656    SoapResp->AddFldNmVal(FldNm1, FldVal1);
657    SoapResp->AddFldNmVal(FldNm2, FldVal2);
658    SoapResp->AddFldNmVal(FldNm3, FldVal3);
659    SoapResp->AddFldNmVal(FldNm4, FldVal4);
660    SoapResp->AddFldNmVal(FldNm5, FldVal5);
661    return SoapResp->GetHttpResp();
662  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-bowlearn.cpp</h3>
            <pre><code>1  void TBowLearn::TrainMajorityMd(const PBowDocBs& BowDocBs, TFltV& MdCatExWgtV){
2    int AllCats=BowDocBs->GetCats();
3    double SumCatExWgt=0;
4    {for (int DIdN=0; DIdN<BowDocBs->GetTrainDocs(); DIdN++){
5      int DId=BowDocBs->GetTrainDId(DIdN);
6      int CIds=BowDocBs->GetDocCIds(DId);
7      for (int CIdN=0; CIdN<CIds; CIdN++){
8        int CId=BowDocBs->GetDocCId(DId, CIdN);
9        MdCatExWgtV[CId]++; SumCatExWgt++;
10      }
11    }}
12    if (SumCatExWgt>0){
13      for (int CId=0; CId<AllCats; CId++){
14        MdCatExWgtV[CId]/=SumCatExWgt;
15        TStr CatNm=BowDocBs->GetCatNm(CId);
16      }
17    } else {printf("No training examples!\n");}
18  }
19  double TBowLearn::TestMajorityMd(const PBowDocBs& BowDocBs,
20   TFltV& MdCatExWgtV, FILE* OutFile, int& TestExs){
21    int AllCats=BowDocBs->GetCats();
22    double CorrectExs=0; TestExs=0;
23    int MajorCId=-1; TFlt MajorCatWgt=0;
24    {for (int CId=0; CId<AllCats; CId++){
25      if (MdCatExWgtV[CId]>MajorCatWgt){MajorCId=CId; MajorCatWgt=MdCatExWgtV[CId];}
26    }}
27    if (MajorCId>-1){
28      TStr CatNm=BowDocBs->GetCatNm(MajorCId);
29      printf("\nMajority category P(%d:%s)=%.5f\n", MajorCId, CatNm(), MajorCatWgt()); /&bsol;**
30      fprintf(OutFile, "\nMajority category P(%d:%s)=%.5f\n", MajorCId, CatNm(), MajorCatWgt());
31    } else {
32      printf("No category with probability > 0\n"); /&bsol;**
33      fprintf(OutFile, "No category with probability > 0\n");
34      return CorrectExs;
35    }
36    for (int DIdN=0; DIdN<BowDocBs->GetTestDocs(); DIdN++){
37      int DId=BowDocBs->GetTestDId(DIdN);
38      int WIds=BowDocBs->GetDocWIds(DId);
39      int CIds=BowDocBs->GetDocCIds(DId);
40      TestExs++;
41      fprintf(OutFile, "Document vector:");
42      {for (int WIdN=0; WIdN<WIds; WIdN++){
<span onclick='openModal()' class='match'>43        int WId; double WordFq; BowDocBs->GetDocWIdFq(DId, WIdN, WId, WordFq);
44        TStr WordStr=BowDocBs->GetWordStr(WId);
45        for (int WordFqN=0; WordFqN<WordFq; WordFqN++){
46          fprintf(OutFile, "%s ", WordStr.CStr()); /&bsol;**
47        }
48      }}
</span>49      fprintf(OutFile, "\n");
50      {for (int CIdN=0; CIdN<CIds; CIdN++){
51        int CId=BowDocBs->GetDocCId(DId, CIdN);
52        TStr CatNm=BowDocBs->GetCatNm(CId);
53        fprintf(OutFile, "[%d:%s] ", CId, CatNm());
54        if (CId==MajorCId){CorrectExs+=1/double(CIds);}
55      }}
56      fprintf(OutFile, "  --> ");
57      int CId=MajorCId;
58      TStr CatNm=BowDocBs->GetCatNm(CId);
59      fprintf(OutFile, "\n  [%d:%s]:%.5f ", CId, CatNm(), MajorCatWgt());
60      fprintf(OutFile, "\n    Model evidence: majority class value");
61      fprintf(OutFile, "\n");
62    }
63    printf("Testing documents:%d, Non-empty documents:%d ",
64     BowDocBs->GetTestDocs(), TestExs);
65    fprintf(OutFile, "Testing documents:%d, Non-empty documents:%d ",
66     BowDocBs->GetTestDocs(), TestExs);
67    if (TestExs>0){
68      printf("CorrectExs:%.5f\n", CorrectExs);
69      fprintf(OutFile, "CorrectExs:%.5f\n", CorrectExs);
70    } else {
71      printf("CorrectExs:%.5f\n", CorrectExs);
72      fprintf(OutFile, "CorrectExs:%.5f\n", CorrectExs);
73    }
74    return CorrectExs;
75  }
76  void TBowLearn::TrainInvertedMd(const PBowDocBs& BowDocBs,
77   TFltVV& MdWordCatWgtVV, TFltV& MdWordWgtV, TFltV& MdCatWgtV){
78    int AllWords=BowDocBs->GetWords();
79    int AllCats=BowDocBs->GetCats();
80    for (int DIdN=0; DIdN<BowDocBs->GetTrainDocs(); DIdN++){
81      int DId=BowDocBs->GetTrainDId(DIdN);
82      int WIds=BowDocBs->GetDocWIds(DId);
83      int CIds=BowDocBs->GetDocCIds(DId);
84      for (int WIdN=0; WIdN<WIds; WIdN++){
85        int WId; double WordFq; BowDocBs->GetDocWIdFq(DId, WIdN, WId, WordFq);
86        for (int CIdN=0; CIdN<CIds; CIdN++){
87          int CId=BowDocBs->GetDocCId(DId, CIdN);
88          double CatWgt=WordFq*(1/double(CIds));
89          MdWordCatWgtVV.At(WId, CId)+=CatWgt;
90        }
91      }
92    }
93    for (int WId=0; WId<AllWords; WId++){
94      double SumWordCatWgt=0;
95      for (int CId=0; CId<AllCats; CId++){
96        SumWordCatWgt+=MdWordCatWgtVV.At(WId, CId);}
97      if (SumWordCatWgt>0){
98        for (int CId=0; CId<AllCats; CId++){
99          MdWordCatWgtVV.At(WId, CId)/=SumWordCatWgt;}
100      }
101      double WordWgt=0;
102      {for (int CId=0; CId<AllCats; CId++){
103        double WordCatWgt=MdWordCatWgtVV.At(WId, CId);
104        if (WordCatWgt>=0){
105          WordWgt-=WordCatWgt*log(WordCatWgt);}
106      }}
107      TStr WordStr=BowDocBs->GetWordStr(WId);
108      MdWordWgtV[WId]=1/(1+TMath::Sqr(WordWgt));
109    }
110    printf("\n"); /&bsol;**
111    double SumCatExWgt=0;
112    {for (int DIdN=0; DIdN<BowDocBs->GetTrainDocs(); DIdN++){
113      int DId=BowDocBs->GetTrainDId(DIdN);
114      int CIds=BowDocBs->GetDocCIds(DId);
115      for (int CIdN=0; CIdN<CIds; CIdN++){
116        int CId=BowDocBs->GetDocCId(DId, CIdN);
117       MdCatWgtV[CId]++; SumCatExWgt++;
118      }
119    }}
120    if (SumCatExWgt>0){
121      for (int CId=0; CId<AllCats; CId++){
122        TStr CatNm=BowDocBs->GetCatNm(CId); /&bsol;**
123        MdCatWgtV[CId]=1/log(1+1+TMath::Sqr(MdCatWgtV[CId]));
124      }
125      printf("\n"); /&bsol;**
126    } else {printf("No training examples!\n");}
127  }
128  double TBowLearn::TestInvertedMd(const PBowDocBs& BowDocBs,
129   TFltVV& MdWordCatWgtVV, TFltV& MdWordWgtV, TFltV& MdCatWgtV,
130   FILE* OutFile, int& TestExs){
131    int AllCats=BowDocBs->GetCats();
132    double CorrectExs=0; TestExs=0;
133    int MajorCId=-1; TFlt MajorCatWgt=0;
134    {for (int CId=0; CId<AllCats; CId++){
135      if (MdCatWgtV[CId]>MajorCatWgt){MajorCId=CId; MajorCatWgt=MdCatWgtV[CId];}
136    }}
137    if (MajorCId>-1){
138      TStr CatNm=BowDocBs->GetCatNm(MajorCId);
139      printf("\nMajority category P(%d:%s])=%.5f\n", MajorCId, CatNm(), MajorCatWgt()); /&bsol;**
140      fprintf(OutFile, "\nMajority category P(%d:%s])=%.5f\n", MajorCId, CatNm(), MajorCatWgt());
141    } else {
142      printf("No category with probability > 0\n"); /&bsol;**
143      fprintf(OutFile, "No category with probability > 0\n");
144    }
145    for (int DIdN=0; DIdN<BowDocBs->GetTestDocs(); DIdN++){
146      int DId=BowDocBs->GetTestDId(DIdN);
147      int WIds=BowDocBs->GetDocWIds(DId);
148      int CIds=BowDocBs->GetDocCIds(DId);
149      if (WIds==0){printf("It is hard to classify an empty document!\n"); continue;}
150      TFltIntKdV CatWgtCIdKdV(AllCats);
151      {for (int CId=0; CId<AllCats; CId++){
152        CatWgtCIdKdV[CId].Dat=CId; CatWgtCIdKdV[CId].Key=0;
153      }}
154      {for (int WIdN=0; WIdN<WIds; WIdN++){
155        int WId; double WordFq; BowDocBs->GetDocWIdFq(DId, WIdN, WId, WordFq);
156        printf("MdWordWgtV[%d]:%.3f ", WId, MdWordWgtV[WId]());/&bsol;**
157        for (int CId=0; CId<AllCats; CId++){
158          double CatWgt=
159           WordFq*MdCatWgtV[CId]*MdWordWgtV[WId]*MdWordCatWgtVV.At(WId, CId);
160          CatWgtCIdKdV[CId].Key+=CatWgt;
161          if ((CId==5)||(CId==130)){printf("CatWgt[%d]=%.1f*%.3f*%.3f*%.3f\n",
162              CId, WordFq, MdCatWgtV[CId](), MdWordWgtV[WId](), MdWordCatWgtVV.At(WId, CId)());} /&bsol;**
163          if ((CId==5)||(CId==130)){printf("CatWgt.Key[%d]=%.5f\n", CId, CatWgtCIdKdV[CId].Key());} /&bsol;**
164        }
165      }}
166      double SumCatWgt=0;
167      {for (int CId=0; CId<AllCats; CId++){
168        SumCatWgt+=CatWgtCIdKdV[CId].Key;
169        if ((CId==5)||(CId==130)){ /&bsol;**
170          printf("\nMdCatWgtV[%d]=%.5f CatWgt[%d]=%.5f\n", CId, MdCatWgtV[CId](),
171            CId, CatWgtCIdKdV[CId].Key());
172        }
173      }}
174      printf("\n");
175      if (SumCatWgt>0){
176        for (int CId=0; CId<AllCats; CId++){CatWgtCIdKdV[CId].Key/=SumCatWgt;}
177      }
178      CatWgtCIdKdV.Sort(false);
179      printf("BestCat:%d, prob:%.5f\n", CatWgtCIdKdV[0].Dat(), CatWgtCIdKdV[0].Key()); /&bsol;**
180      if (CatWgtCIdKdV[0].Key<=0.0001){ 
181        printf("No category found for %d!\n", DId); /&bsol;**
182        fprintf(OutFile, "No category found for %d!\n", DId);
183        continue;
184      }
185      double SumCatWgtSF=0; TIntV BestCIdV;
186      for (int CIdN=0; CIdN<AllCats; CIdN++){
187        double CatWgt=CatWgtCIdKdV[CIdN].Key;
188        int CId=CatWgtCIdKdV[CIdN].Dat;
189        SumCatWgtSF+=CatWgt; BestCIdV.Add(CId);
190        if (SumCatWgtSF>0.25){break;}
191      }
192      TestExs++;
193      printf("Document vector: "); /&bsol;**
194      fprintf(OutFile, "Document vector:");
195      {for (int WIdN=0; WIdN<WIds; WIdN++){
196        int WId; double WordFq; BowDocBs->GetDocWIdFq(DId, WIdN, WId, WordFq);
197        TStr WordStr=BowDocBs->GetWordStr(WId);
198        for (int WordFqN=0; WordFqN<WordFq; WordFqN++){
199          printf("%s ", WordStr.CStr()); /&bsol;**
200          fprintf(OutFile, "%s ", WordStr.CStr()); /&bsol;**
201        }
202      }}
203      printf("\n"); /&bsol;**
204      fprintf(OutFile, "\n");
205      {for (int CIdN=0; CIdN<CIds; CIdN++){
206        int CId=BowDocBs->GetDocCId(DId, CIdN);
207        TStr CatNm=BowDocBs->GetCatNm(CId);
208        printf("[%d:%s] ", CId, CatNm()); /&bsol;**
209        fprintf(OutFile, "[%d:%s] ", CId, CatNm());
210        if (BestCIdV.IsIn(CId)){CorrectExs+=1/double(CIds);}
211      }}
212      printf("  --> "); /&bsol;**
213      fprintf(OutFile, "  --> ");
214      {for (int CIdN=0; CIdN<BestCIdV.Len(); CIdN++){
215        int CId=BestCIdV[CIdN];
216        TStr CatNm=BowDocBs->GetCatNm(CId);
217        printf("\n  [%d:%s]:%.5f ", CId, CatNm(), CatWgtCIdKdV[CIdN].Key()); /&bsol;**
218        fprintf(OutFile, "\n  [%d:%s]:%.5f ", CId, CatNm(), CatWgtCIdKdV[CIdN].Key());
219        printf("\n    Model evidence: ");  /&bsol;**
220        fprintf(OutFile, "\n    Model evidence: ");
221        for (int WIdN=0; WIdN<WIds; WIdN++){
222          int WId; double WordFq; BowDocBs->GetDocWIdFq(DId, WIdN, WId, WordFq);
223          if (MdWordCatWgtVV.At(WId, CId)>0){
224            TStr WordStr=BowDocBs->GetWordStr(WId);
225            printf("TF(%s)=%.1f ", WordStr.CStr(), MdWordCatWgtVV.At(WId, CId)()); /&bsol;**
226            fprintf(OutFile, "TF(%s)=%.1f ", WordStr.CStr(), MdWordCatWgtVV.At(WId, CId)());
227          }
228        }
229        printf("\n"); /&bsol;**
230        fprintf(OutFile, "\n");
231      }}
232      printf("\n"); /&bsol;**
233      fprintf(OutFile, "\n");
234    }
235    printf("Testing documents:%d, Non-empty documents:%d ",
236     BowDocBs->GetTestDocs(), TestExs);
237    fprintf(OutFile, "Testing documents:%d, Non-empty documents:%d ",
238     BowDocBs->GetTestDocs(), TestExs);
239    if (TestExs>0){
240      printf("CorrectExs:%.5f\n", CorrectExs);
241      fprintf(OutFile, "CorrectExs:%.5f\n", CorrectExs);
242    } else {
243      printf("CorrectExs:%.5f\n", CorrectExs);
244      fprintf(OutFile, "CorrectExs:%.5f\n", CorrectExs);
245    }
246    return CorrectExs;
247  }
248  void TBowLearn::TrainSimMd(const PBowDocBs& BowDocBs,
249   const TVec<TIntV>& DIdVV, TBowSpVV& ConceptSpVV){
250    int AllCats=BowDocBs->GetCats();
251    TIntV CtxTrainDIdV; BowDocBs->GetTrainDIdV(CtxTrainDIdV);
252    PBowDocWgtBs BowDocWgtBs= /&bsol;** Dunja: error, CtxTrainDIdV has 389 Ids, but their range is 0..3175
253     TBowDocWgtBs::New(BowDocBs, bwwtNrmTFIDF, 0, 0, CtxTrainDIdV);
254    PBowSim BowSim=TBowSim::New(bstCos);
255    for (int CIdN=0; CIdN<AllCats; CIdN++){
256      ConceptSpVV[CIdN]=TBowClust::GetConceptSpV(BowDocWgtBs, BowSim, DIdVV[CIdN]);
257    }
258  }
259  double TBowLearn::TestSimMd(const PBowDocBs& BowDocBs,
260   const TBowSpVV& ConceptSpVV,
261   FILE* OutFile, int& TestExs){
262    int AllCats=BowDocBs->GetCats();
263    TIntV CtxTestDIdNV; BowDocBs->GetTestDIdV(CtxTestDIdNV);
264    PBowDocWgtBs BowDocWgtBs=
265     TBowDocWgtBs::New(BowDocBs, bwwtNrmTFIDF, 0, 0, CtxTestDIdNV);
266    double CorrectExs=0; TestExs=0;
267    for (int DIdN=0; DIdN<BowDocBs->GetTestDocs(); DIdN++){
268      int DId=BowDocWgtBs->GetDId(DIdN);
269      PBowSpV SpV=BowDocWgtBs->GetSpV(DId);
270      int DIdx=BowDocBs->GetTestDId(DIdN);
271      printf("DIdx:%d = DId:%d ", DIdx, DId); 
272      int WIdsx=BowDocBs->GetDocWIds(DId);
273      int WIds=SpV->GetWIds();
274      printf("WIdsx:%d = WIds:%d", WIdsx, WIds); 
275      int CIds=BowDocBs->GetDocCIds(DId);
276      if (WIds==0){printf("It is hard to classify an empty document!\n"); continue;}
277      for (int WIdN=0; WIdN<WIds; WIdN++){
278        int WId=SpV->GetWId(WIdN); double WordWgt=SpV->GetWgt(WIdN);
279        printf("WId:%d  ", WId);
280        TStr WordStr=BowDocBs->GetWordStr(WId);
281        printf("%s:%.2f ", WordStr.CStr(), WordWgt); /&bsol;**
282      }
283      printf("\n");
284      PBowSim BowSim=TBowSim::New(bstCos);
285      TFltIntKdV CatWgtCIdKdV(AllCats);
286      for (int CId=0; CId<AllCats; CId++){
287        CatWgtCIdKdV[CId].Dat=CId;
288        CatWgtCIdKdV[CId].Key=BowSim->GetSim(ConceptSpVV[CId], SpV);
289        printf("Sim[%d]=%.3f ", CId, CatWgtCIdKdV[CId].Key());
290      }
291      CatWgtCIdKdV.Sort(false);
292      printf("BestCat:%d, prob:%.5f\n", CatWgtCIdKdV[0].Dat(), CatWgtCIdKdV[0].Key());
293      if (CatWgtCIdKdV[0].Key<=0.0001){ 
294        printf("No category found for %d!\n", DId); /&bsol;**
295        fprintf(OutFile, "No category found for %d!\n", DId);
296        continue;
297      }
298      double SumCatWgtSF=0; TIntV BestCIdV;
299      for (int CIdN=0; CIdN<AllCats; CIdN++){
300        double CatWgt=CatWgtCIdKdV[CIdN].Key;
301        int CId=CatWgtCIdKdV[CIdN].Dat;
302        SumCatWgtSF+=CatWgt; BestCIdV.Add(CId);
303        if (SumCatWgtSF>0.25){break;}
304      }
305      TestExs++;
306      {for (int CIdN=0; CIdN<CIds; CIdN++){
307        int CId=BowDocBs->GetDocCId(DId, CIdN);
308        TStr CatNm=BowDocBs->GetCatNm(CId);
309        printf("[%s]-%d ", CatNm(), CId); /&bsol;**
310        fprintf(OutFile, "[%s]-%d ", CatNm(), CId);
311        if (BestCIdV.IsIn(CId)){CorrectExs+=1/double(CIds);}
312      }}
313      printf("  Document: "); /&bsol;**
314      fprintf(OutFile, "  Document: ");
315      {for (int WIdN=0; WIdN<WIds; WIdN++){
316        int WId=SpV->GetWId(WIdN); double WordWgt=SpV->GetWgt(WIdN);
317        TStr WordStr=BowDocBs->GetWordStr(WId);
318        printf("%s:%.2f ", WordStr.CStr(), WordWgt);
319        fprintf(OutFile, "%s:%.2f ", WordStr.CStr(), WordWgt);
320      }}
321      printf("\n--> "); /&bsol;**
322      fprintf(OutFile, "\n--> ");
323      {for (int CIdN=0; CIdN<BestCIdV.Len(); CIdN++){
324        int CId=BestCIdV[CIdN];
325        TStr CatNm=BowDocBs->GetCatNm(CId);
326        printf("[%s]:%.5f ", CatNm(), CatWgtCIdKdV[CIdN].Key());
327        fprintf(OutFile, "[%s]:%.5f ", CatNm(), CatWgtCIdKdV[CIdN].Key());
328        for (int WIdN=0; WIdN<WIds; WIdN++){
329          int WId=SpV->GetWId(WIdN); double WordWgt=ConceptSpVV[CId]->GetWgt(WIdN);
330          if (WordWgt>0){
331            TStr WordStr=BowDocBs->GetWordStr(WId);
332            printf("TF(%s,%d)=%.5f ", WordStr.CStr(), CId, WordWgt);
333            fprintf(OutFile, "TF(%s,%d)=%.5f ", WordStr.CStr(), CId, WordWgt);
334          }
335        }
336      }}
337      printf("\n"); /&bsol;**
338      fprintf(OutFile, "\n");
339    }
340    return CorrectExs;
341  }
342  void TBowLearn::TrainNBayesMd(const PBowDocBs& BowDocBs,
343   TFltVV& MdWordCatWgtVV, TFltV& MdCatWgtV,
344   TFltV& MdCatExWgtV){
345    int AllWords=BowDocBs->GetWords();
346    int AllCats=BowDocBs->GetCats();
347    int TrainDocs=BowDocBs->GetTrainDocs();
348    for (int DIdN=0; DIdN<TrainDocs; DIdN++){
349      int DId=BowDocBs->GetTrainDId(DIdN);
350      int WIds=BowDocBs->GetDocWIds(DId);
351      int CIds=BowDocBs->GetDocCIds(DId);
352      for (int WIdN=0; WIdN<WIds; WIdN++){
353        int WId; double WordFq; BowDocBs->GetDocWIdFq(DId, WIdN, WId, WordFq);
354        for (int CIdN=0; CIdN<CIds; CIdN++){
355          int CId=BowDocBs->GetDocCId(DId, CIdN);
356          double CatWgt=WordFq*(1/double(CIds));
357          MdWordCatWgtVV.At(WId, CId)+=CatWgt;
358        }
359      }
360    }
361    {for (int CId=0; CId<AllCats; CId++){
362      double SumWordCatWgt=0;
363      for (int WId=0; WId<AllWords; WId++){
364        SumWordCatWgt+=MdWordCatWgtVV.At(WId, CId);
365      }
366      MdCatWgtV[CId]=SumWordCatWgt;
367    }}
368    {for (int DIdN=0; DIdN<TrainDocs; DIdN++){
369      int DId=BowDocBs->GetTrainDId(DIdN);
370      int CIds=BowDocBs->GetDocCIds(DId);
371      for (int CIdN=0; CIdN<CIds; CIdN++){
372        int CId=BowDocBs->GetDocCId(DId, CIdN);
373        MdCatExWgtV[CId]++;
374      }
375    }}
376    if (TrainDocs>0){
377      for (int CId=0; CId<AllCats; CId++){
378        MdCatExWgtV[CId]/=TrainDocs;
379        TStr CatNm=BowDocBs->GetCatNm(CId);
380      }
381    } else {printf("No training examples!\n");}
382  }
383  double TBowLearn::TestNBayesMd(const PBowDocBs& BowDocBs,
384   TFltVV& MdWordCatWgtVV, TFltV& MdCatWgtV,
385   TFltV& MdCatExWgtV, FILE* OutFile, FILE* ErrFile, int& TestExs){
386    int AllWords=BowDocBs->GetWords();
387    int AllCats=BowDocBs->GetCats();
388    int MajorCId=-1; TFlt MajorCatWgt=0;
389    {for (int CId=0; CId<AllCats; CId++){
390      if (MdCatExWgtV[CId]>MajorCatWgt){MajorCId=CId; MajorCatWgt=MdCatExWgtV[CId];}
391    }}
392    if (MajorCId>-1){
393      TStr CatNm=BowDocBs->GetCatNm(MajorCId);
394      fprintf(OutFile, "      Majority P(%d:%s])=%.5f\n", MajorCId, CatNm(), MajorCatWgt());
395    } else {
396      fprintf(OutFile, "      No category with probability > 0\n");
397    }
398    double CorrectExs=0; TestExs=0;
399    for (int DIdN=0; DIdN<BowDocBs->GetTestDocs(); DIdN++){
400      int DId=BowDocBs->GetTestDId(DIdN);
401      int WIds=BowDocBs->GetDocWIds(DId);
402      int CIds=BowDocBs->GetDocCIds(DId);
403      if (WIds==0){printf("It is hard to classify an empty document!\n"); continue;}
404      TIntV ShareWordsCat(AllCats); 
405      TFltIntKdV CatWgtCIdKdV(AllCats);
406      {for (int CId=0; CId<AllCats; CId++){
407        ShareWordsCat[CId]=0;
408        CatWgtCIdKdV[CId].Dat=CId; CatWgtCIdKdV[CId].Key=0;
409      }}
410      {for (int CId=0; CId<AllCats; CId++){
411        if(MdCatExWgtV[CId]>0){ 
412          for (int WIdN=0; WIdN<WIds; WIdN++){
413            int WId; double WordFq; BowDocBs->GetDocWIdFq(DId, WIdN, WId, WordFq);
414            WordFq=1;
415            if(MdWordCatWgtVV.At(WId, CId)>0){
416              ShareWordsCat[CId]=1;
417            }
418            double CatWgt=(MdWordCatWgtVV.At(WId, CId)+1)/(MdCatWgtV[CId]+double(AllWords));
419            CatWgtCIdKdV[CId].Key+=(log(CatWgt)*WordFq);
420          }
421          CatWgtCIdKdV[CId].Key+=log(double(MdCatExWgtV[CId]));
422        } else {
423          CatWgtCIdKdV[CId].Key=TFlt::NInf;
424        }
425      }}
426      CatWgtCIdKdV.Sort(false);
427      if(ShareWordsCat[CatWgtCIdKdV[0].Dat]==0){ 
428        continue; 
429      }
430      double SumCatWgt=0;
431      {for (int CIdN=0; CIdN<AllCats; CIdN++){
432        if (ShareWordsCat[CatWgtCIdKdV[CIdN].Dat]==1){
433          CatWgtCIdKdV[CIdN].Key=exp(double(CatWgtCIdKdV[CIdN].Key));
434        } else {CatWgtCIdKdV[CIdN].Key=0;}
435        SumCatWgt+=CatWgtCIdKdV[CIdN].Key;
436      }}
437      if (SumCatWgt>0){
438        {for (int CIdN=0; CIdN<AllCats; CIdN++){
439          CatWgtCIdKdV[CIdN].Key/=SumCatWgt;
440        }}
441      }
442      double SumCatWgtSF=0; TIntV BestCIdV;
443      {for (int CIdN=0; CIdN<AllCats; CIdN++){
444        double CatWgt=CatWgtCIdKdV[CIdN].Key;
445        int CId=CatWgtCIdKdV[CIdN].Dat;
446        SumCatWgtSF+=CatWgt; BestCIdV.Add(CId);
447        if (SumCatWgtSF>0.25){break;}
448      }}
449      bool ErrorInClass=true;
450      {for (int CIdN=0; CIdN<CIds; CIdN++){
451        int CId=BowDocBs->GetDocCId(DId, CIdN);
452        if (BestCIdV.IsIn(CId)){ErrorInClass=false;}
453      }}
454      if (ErrorInClass){fprintf(ErrFile, "%s\n", BowDocBs->GetDocNm(DId).CStr());}
455      TestExs++;
456      fprintf(OutFile, "Document vector:");
457      {for (int WIdN=0; WIdN<WIds; WIdN++){
458        int WId; double WordFq; BowDocBs->GetDocWIdFq(DId, WIdN, WId, WordFq);
459        TStr WordStr=BowDocBs->GetWordStr(WId);
460        for (int WordFqN=0; WordFqN<WordFq; WordFqN++){
461          fprintf(OutFile, "%s ", WordStr.CStr()); /&bsol;**
462        }
463      }}
464      fprintf(OutFile, "\n");
465      {for (int CIdN=0; CIdN<CIds; CIdN++){
466        int CId=BowDocBs->GetDocCId(DId, CIdN);
467        TStr CatNm=BowDocBs->GetCatNm(CId);
468        fprintf(OutFile, "[%d:%s] ", CId, CatNm());
469        if (BestCIdV.IsIn(CId)){CorrectExs+=1/double(CIds);}
470      }}
471      fprintf(OutFile, "  --> ");
472      {for (int CIdN=0; CIdN<BestCIdV.Len(); CIdN++){
473        int CId=BestCIdV[CIdN];
474        TStr CatNm=BowDocBs->GetCatNm(CId);
475        fprintf(OutFile, "\n  [%d:%s]:%.5f ", CId, CatNm(), CatWgtCIdKdV[CIdN].Key());
476        fprintf(OutFile, "\n    Model evidence: ");
477        for (int WIdN=0; WIdN<WIds; WIdN++){
478          int WId; double WordFq; BowDocBs->GetDocWIdFq(DId, WIdN, WId, WordFq);
479          if (MdWordCatWgtVV.At(WId, CId)>0){
480            TStr WordStr=BowDocBs->GetWordStr(WId);
481            fprintf(OutFile, "TF(%s)=%.1f ", WordStr.CStr(), MdWordCatWgtVV.At(WId, CId)());
482          }
483        }
484        fprintf(OutFile, "\n");
485      }}
486      fprintf(OutFile, "\n");
487    }
488    fprintf(OutFile, "Testing documents:%d, Non-empty documents:%d ", BowDocBs->GetTestDocs(), TestExs);
489    if (TestExs>0){
490      fprintf(OutFile, "CorrectExs:%.5f\n", CorrectExs);
491    } else {
492      fprintf(OutFile, "CorrectExs:%.5f\n", CorrectExs);
493    }
494    return CorrectExs;
495  }
496  void TBowLearn::TrainBinNBayesMd(const PBowDocBs& BowDocBs,
497   TFltVV& MdWordCatWgtVV, TFltV& MdCatWgtV,
498   TFltV& MdCatExWgtV, const TFileId& OutFile){
499    int AllWords=BowDocBs->GetWords();
500    int AllCats=BowDocBs->GetCats();
501    int TrainDocs=BowDocBs->GetTrainDocs();
502    for (int DIdN=0; DIdN<TrainDocs; DIdN++){
503      int DId=BowDocBs->GetTrainDId(DIdN);
504      int WIds=BowDocBs->GetDocWIds(DId);
505      int CIds=BowDocBs->GetDocCIds(DId);
506      for (int WIdN=0; WIdN<WIds; WIdN++){
507        int WId; double WordFq; BowDocBs->GetDocWIdFq(DId, WIdN, WId, WordFq);
508        for (int CIdN=0; CIdN<CIds; CIdN++){
509          int CId=BowDocBs->GetDocCId(DId, CIdN);
510          double CatWgt=WordFq*(1/double(CIds));
511          MdWordCatWgtVV.At(WId, CId)+=CatWgt;
512        }
513      }
514    }
515    {for (int CId=0; CId<AllCats; CId++){
516      double SumWordCatWgt=0;
517      for (int WId=0; WId<AllWords; WId++){
518        SumWordCatWgt+=MdWordCatWgtVV.At(WId, CId);
519      }
520      MdCatWgtV[CId]=SumWordCatWgt;
521    }}
522    {for (int DIdN=0; DIdN<TrainDocs; DIdN++){
523      int DId=BowDocBs->GetTrainDId(DIdN);
524      int CIds=BowDocBs->GetDocCIds(DId);
525      for (int CIdN=0; CIdN<CIds; CIdN++){
526        int CId=BowDocBs->GetDocCId(DId, CIdN);
527        MdCatExWgtV[CId]++;
528      }
529    }}
530    if (TrainDocs>0){
531      for (int CId=0; CId<AllCats; CId++){
532        MdCatExWgtV[CId]/=TrainDocs;
533        TStr CatNm=BowDocBs->GetCatNm(CId);
534      }
535    } else {printf("No training examples!\n");}
536    fprintf(OutFile, "\n# NBayes Model\n");
537    fprintf(OutFile, "# Feature");
538    for (int CId=0; CId<AllCats; CId++){
539      TStr CatNm=BowDocBs->GetCatNm(CId);
540      fprintf(OutFile, ", %s_Weight", CatNm.CStr());
541    }
542    fprintf(OutFile, "\n");
543    {for (int WId=0; WId<AllWords; WId++){
544      fprintf(OutFile, "%s", BowDocBs->GetWordStr(WId).CStr());
545      for (int CId=0; CId<AllCats; CId++){
546        fprintf(OutFile, ", %0.5f", MdWordCatWgtVV.At(WId, CId)());
547      }
548      fprintf(OutFile, "\n");
549    }}
550  }
551  void TBowLearn::TestBinNBayesMd(const PBowDocBs& BowDocBs,
552   const TStr& TargetCatNm,
553   TFltVV& MdWordCatWgtVV, TFltV& MdCatWgtV, TFltV& MdCatExWgtV,
554   const TFileId& TrainOutFile, const TFileId& TestOutFile, const TFileId& ErrFile){
555    double MnProb=0.00000001;
556    int AllWords=BowDocBs->GetWords();
557    int AllCats=BowDocBs->GetCats();
558    int TargetCId=BowDocBs->GetCId(TargetCatNm);
559    int TrainDocs=BowDocBs->GetTrainDocs();
560    int TestDocs=BowDocBs->GetTestDocs();
561    int MajorCId=-1; TFlt MajorCatWgt=0;
562    {for (int CId=0; CId<AllCats; CId++){
563      if (MdCatExWgtV[CId]>MajorCatWgt){MajorCId=CId; MajorCatWgt=MdCatExWgtV[CId];}
564    }}
565    if (MajorCId>-1){
566      TStr CatNm=BowDocBs->GetCatNm(MajorCId);
567      printf("      Majority P([%d]:%s)=%.5f\n", MajorCId, CatNm(), MajorCatWgt()); /&bsol;**
568      fprintf(ErrFile, "      Majority P([%d]:%s)=%.5f\n", MajorCId, CatNm(), MajorCatWgt());
569    } else {
570      printf("      No category with probability > 0\n"); /&bsol;**
571      fprintf(ErrFile, "      No category with probability > 0\n");
572    }
573    {int FalsePos=0; int FalseNeg=0; int TruePos=0; int TrueNeg=0;
574    for (int DIdN=0; DIdN<TrainDocs; DIdN++){
575      int DId=BowDocBs->GetTrainDId(DIdN);
576      bool ClassVal=BowDocBs->IsCatInDoc(DId, TargetCId);
577      int DocWIds=BowDocBs->GetDocWIds(DId);
578      if (DocWIds==0){
579        printf("It is hard to classify an empty document %s!\n", BowDocBs->GetDocNm(DId).CStr());
580      }
581      TFltIntKdV CatWgtCIdKdV(AllCats);
582      {for (int CId=0; CId<AllCats; CId++){
583        CatWgtCIdKdV[CId].Dat=CId; CatWgtCIdKdV[CId].Key=0;
584      }}
585      {for (int WIdN=0; WIdN<DocWIds; WIdN++){
586        int WId; double WordFq; BowDocBs->GetDocWIdFq(DId, WIdN, WId, WordFq);
587        WordFq=1; 
588        for (int CId=0; CId<AllCats; CId++){
589          double CatWgt=(MdWordCatWgtVV.At(WId, CId)+1)/(MdCatWgtV[CId]+double(AllWords));
590          CatWgtCIdKdV[CId].Key+=(log(CatWgt)*WordFq);
591        }
592      }}
593      {for (int CId=0; CId<AllCats; CId++){
594        if(MdCatExWgtV[CId]>0){
595          CatWgtCIdKdV[CId].Key+=log(double(MdCatExWgtV[CId]));
596        } else {CatWgtCIdKdV[CId].Key=TFlt::NInf;}
597      }}
598      CatWgtCIdKdV.Sort(false); 
599      {for (int CId=1; CId<AllCats; CId++){
600        CatWgtCIdKdV[CId].Key-=CatWgtCIdKdV[0].Key;
601      }}
602      CatWgtCIdKdV[0].Key-=CatWgtCIdKdV[0].Key;
603      double SumCatWgt=0;
604      for (int CId=0; CId<AllCats; CId++){
605        CatWgtCIdKdV[CId].Key=exp(double(CatWgtCIdKdV[CId].Key));
606        SumCatWgt+=CatWgtCIdKdV[CId].Key;
607      }
608      if (SumCatWgt>0){
609        for (int CId=0; CId<AllCats; CId++){CatWgtCIdKdV[CId].Key/=SumCatWgt;}
610      }
611      if (CatWgtCIdKdV[0].Key<=MnProb){ 
612        CatWgtCIdKdV[0].Dat=MajorCId; CatWgtCIdKdV[0].Key=MajorCatWgt;
613      }
614      bool PredClassVal;
615      PredClassVal=(CatWgtCIdKdV[0].Dat==TargetCId);
616      if (PredClassVal==ClassVal){
617        if (PredClassVal){TruePos++;} else {TrueNeg++;}
618      } else {
619        if (PredClassVal){FalsePos++;} else {FalseNeg++;}
620      }
621      int ClassValN=(ClassVal)?1:-1;
622      int PredClassValN=(PredClassVal)?1:-1;
623      fprintf(TrainOutFile, "%0.6f # true=%d # docDesc=%s\n",
624       PredClassValN*CatWgtCIdKdV[0].Key, ClassValN, BowDocBs->GetDocNm(DId).CStr());
625    }}
626    {int FalsePos=0; int FalseNeg=0; int TruePos=0; int TrueNeg=0;
627    for (int DIdN=0; DIdN<TestDocs; DIdN++){
628      int DId=BowDocBs->GetTestDId(DIdN);
629      bool ClassVal=BowDocBs->IsCatInDoc(DId, TargetCId);
630      int DocWIds=BowDocBs->GetDocWIds(DId);
631      if (DocWIds==0){
632        printf("It is hard to classify an empty document %s!\n", BowDocBs->GetDocNm(DId).CStr());
633      }
634      TFltIntKdV CatWgtCIdKdV(AllCats);
635      {for (int CId=0; CId<AllCats; CId++){
636        CatWgtCIdKdV[CId].Dat=CId; CatWgtCIdKdV[CId].Key=0;
637      }}
638      {for (int WIdN=0; WIdN<DocWIds; WIdN++){
639        int WId; double WordFq; BowDocBs->GetDocWIdFq(DId, WIdN, WId, WordFq);
640        WordFq=1; 
641        for (int CId=0; CId<AllCats; CId++){
642          double CatWgt=(MdWordCatWgtVV.At(WId, CId)+1)/(MdCatWgtV[CId]+double(AllWords));
643          CatWgtCIdKdV[CId].Key+=(log(CatWgt)*WordFq);
644        }
645      }}
646      {for (int CId=0; CId<AllCats; CId++){
647        CatWgtCIdKdV[CId].Key+=log(double(MdCatExWgtV[CId]));
648      }}
649      CatWgtCIdKdV.Sort(false); 
650      {for (int CId=1; CId<AllCats; CId++){
651        CatWgtCIdKdV[CId].Key-=CatWgtCIdKdV[0].Key;
652      }}
653      CatWgtCIdKdV[0].Key-=CatWgtCIdKdV[0].Key;
654      double SumCatWgt=0;
655      for (int CId=0; CId<AllCats; CId++){
656        CatWgtCIdKdV[CId].Key=exp(double(CatWgtCIdKdV[CId].Key));
657        SumCatWgt+=CatWgtCIdKdV[CId].Key;
658      }
659      if (SumCatWgt>0){
660        for (int CId=0; CId<AllCats; CId++){CatWgtCIdKdV[CId].Key/=SumCatWgt;}
661      }
662      if (CatWgtCIdKdV[0].Key<=MnProb){ 
663        CatWgtCIdKdV[0].Dat=MajorCId; CatWgtCIdKdV[0].Key=MajorCatWgt;
664      }
665      bool PredClassVal;
666      PredClassVal=(CatWgtCIdKdV[0].Dat==TargetCId);
667      if (PredClassVal==ClassVal){
668        if (PredClassVal){TruePos++;} else {TrueNeg++;}
669      } else {
670        fprintf(ErrFile, "%s\n", BowDocBs->GetDocNm(DId).CStr());
671        if (PredClassVal){FalsePos++;} else {FalseNeg++;}
672      }
673      int ClassValN=(ClassVal)?1:-1;
674      int PredClassValN=(PredClassVal)?1:-1;
675      fprintf(TestOutFile, "%0.6f # true=%d # docDesc=%s\n",
676       PredClassValN*CatWgtCIdKdV[0].Key, ClassValN, BowDocBs->GetDocNm(DId).CStr());
677    }
678    double Acc=100*(TruePos+TrueNeg)/double(TestDocs);
679    double Prec=100*(TruePos/double(TruePos+FalsePos));
680    double Rec=100*(TruePos/double(TruePos+FalseNeg));
681    printf("Precision %0.2f%%, Recall %0.2f%%, Accuracy %0.2f%%\n", Prec, Rec, Acc);
682    }
683  }
684  void TBowLearn::TrainWinnowMd(const PBowDocBs& BowDocBs,
685   const TStr& TargetCatNm, TFltV& ExpWgtV,
686   const TFileId& OutFile, const double& Beta){
687    double VoteTsh=0.5;
688    int TargetCId=BowDocBs->GetCId(TargetCatNm);
689    int TrainDocs=BowDocBs->GetTrainDocs();
690    ExpWgtV.PutAll(1);
691    const double MnWgt=1e-15;
692    double PrevAcc=0; double PrevPrec=0; double PrevRec=0; double PrevF1=0;
693    const double MxDiff=-0.005; const int MxWorseIters=3; int WorseIters=0;
694    const int MxIters=50; int IterN=0;
695    while ((IterN<MxIters)&&(WorseIters<MxWorseIters)){
696      IterN++;
697      int FalsePos=0; int FalseNeg=0; int TruePos=0; int TrueNeg=0;
698      for (int DIdN=0; DIdN<TrainDocs; DIdN++){
699        int DId=BowDocBs->GetTrainDId(DIdN);
700        bool ClassVal=BowDocBs->IsCatInDoc(DId, TargetCId);
701        double PosWgt=0; double NegWgt=0;
702        double OldSum=0; double NewSum=0;
703        int DocWIds=BowDocBs->GetDocWIds(DId);
704        for (int DocWIdN=0; DocWIdN<DocWIds; DocWIdN++){
705          int DocWId=BowDocBs->GetDocWId(DId, DocWIdN);
706          int PosExpN=2*DocWId; int NegExpN=2*DocWId+1;
707          OldSum+=ExpWgtV[PosExpN]+ExpWgtV[NegExpN];
708          int PenN=(ClassVal)?NegExpN:PosExpN;
709          ExpWgtV[PenN]=ExpWgtV[PenN]*Beta;
710          NewSum+=ExpWgtV[PosExpN]+ExpWgtV[NegExpN];
711          PosWgt+=ExpWgtV[PosExpN]; NegWgt+=ExpWgtV[NegExpN];
712        }
713        if (NewSum>MnWgt){
714          for (int DocWIdN=0; DocWIdN<DocWIds; DocWIdN++){
715            int DocWId=BowDocBs->GetDocWId(DId, DocWIdN);
716            ExpWgtV[2*DocWId]=ExpWgtV[2*DocWId]*OldSum/NewSum;
717            ExpWgtV[2*DocWId+1]=ExpWgtV[2*DocWId+1]*OldSum/NewSum;
718          }
719        }
720        bool PredClassVal;
721        if (PosWgt+NegWgt==0){PredClassVal=TBool::GetRnd();}
722        else {PredClassVal=(PosWgt/(PosWgt+NegWgt))>VoteTsh;}
723        if (PredClassVal==ClassVal){
724          if (PredClassVal){TruePos++;} else {TrueNeg++;}
725        } else {
726          if (PredClassVal){FalsePos++;} else {FalseNeg++;}
727        }
728      }
729      double Acc=100*(TruePos+TrueNeg)/double(TrainDocs);
730      double Prec=(TruePos/double(TruePos+FalsePos));
731      double Rec=(TruePos/double(TruePos+FalseNeg));
732      double F1=(2*Prec*Rec/(Prec+Rec));
733      if (((Acc-PrevAcc)<MxDiff)||((F1-PrevF1)<MxDiff)||(((Prec-PrevPrec)<MxDiff)&&
734       ((Rec-PrevRec)<MxDiff))){WorseIters++;}
735      else {WorseIters=0;}
736      PrevAcc=Acc; PrevPrec=Prec; PrevRec=Rec; PrevF1=F1;
737    if(IterN==1){fprintf(OutFile, "# IterN, Precision, Recall, F1, Accuracy\n");}
738      printf("%d] Precision %0.2f, Recall %0.2f, F1 %0.2f, Accuracy %0.2f%%\n",
739        IterN, Prec, Rec, F1, Acc);
740      fprintf(OutFile,
741        "%d %0.2f, %0.2f, %0.2f, %0.2f%%\n", IterN, Prec, Rec, F1, Acc);
742    }
743  }
744  void TBowLearn::TestWinnowMd(const PBowDocBs& BowDocBs,
745   const TStr& TargetCatNm, const TFltV& ExpWgtV,
746   const TFileId& TrainOutFile, const TFileId& TestOutFile, const TFileId& ErrFile,
747   const double& &bsol;*Beta*/){
748    double VoteTsh=0.5;
749    int TargetCId=BowDocBs->GetCId(TargetCatNm);
750    int TrainDocs=BowDocBs->GetTrainDocs();
751    int TestDocs=BowDocBs->GetTestDocs();
752    {int FalsePos=0; int FalseNeg=0; int TruePos=0; int TrueNeg=0;
753    for (int DIdN=0; DIdN<TrainDocs; DIdN++){
754      int DId=BowDocBs->GetTrainDId(DIdN);
755      bool ClassVal=BowDocBs->IsCatInDoc(DId, TargetCId);
756      double PosWgt=0; double NegWgt=0;
757      int DocWIds=BowDocBs->GetDocWIds(DId);
758      if (DocWIds==0){
759        printf("It is hard to classify an empty document %s!\n", BowDocBs->GetDocNm(DId).CStr());
760      }
761      for (int DocWIdN=0; DocWIdN<DocWIds; DocWIdN++){
762        int DocWId=BowDocBs->GetDocWId(DId, DocWIdN);
763        int PosExpN=2*DocWId; int NegExpN=2*DocWId+1;
764        PosWgt+=ExpWgtV[PosExpN]; NegWgt+=ExpWgtV[NegExpN];
765      }
766      bool PredClassVal;
767      if (PosWgt+NegWgt==0){PredClassVal=TBool::GetRnd();}
768      else {PredClassVal=(PosWgt/(PosWgt+NegWgt))>VoteTsh;}
769      if (PredClassVal==ClassVal){
770        if (PredClassVal){TruePos++;} else {TrueNeg++;}
771      } else {
772        if (PredClassVal){FalsePos++;} else {FalseNeg++;}
773      }
774      int ClassValN=(ClassVal)?1:-1;
775      fprintf(TrainOutFile, "%0.6f # true=%d # docDesc=%s\n",
776       (PosWgt/(PosWgt+NegWgt))-VoteTsh, ClassValN, BowDocBs->GetDocNm(DId).CStr());
777    }}
778    {int FalsePos=0; int FalseNeg=0; int TruePos=0; int TrueNeg=0;
779    for (int DIdN=0; DIdN<TestDocs; DIdN++){
780      int DId=BowDocBs->GetTestDId(DIdN);
781      bool ClassVal=BowDocBs->IsCatInDoc(DId, TargetCId);
782      double PosWgt=0; double NegWgt=0;
783      int DocWIds=BowDocBs->GetDocWIds(DId);
784      if (DocWIds==0){
785        printf("It is hard to classify an empty document %s!\n", BowDocBs->GetDocNm(DId).CStr());
786      }
787      for (int DocWIdN=0; DocWIdN<DocWIds; DocWIdN++){
788        int DocWId=BowDocBs->GetDocWId(DId, DocWIdN);
789        int PosExpN=2*DocWId; int NegExpN=2*DocWId+1;
790        PosWgt+=ExpWgtV[PosExpN]; NegWgt+=ExpWgtV[NegExpN];
791      }
792      bool PredClassVal; double PredVal;
793      if (PosWgt+NegWgt==0){
794        PredClassVal=TBool::GetRnd(); PredVal=double(PredClassVal);}
795      else {
796        PredClassVal=(PosWgt/(PosWgt+NegWgt))>VoteTsh;
797        PredVal=double(PosWgt/(PosWgt+NegWgt))-VoteTsh;
798      }
799      if (PredClassVal==ClassVal){
800        if (PredClassVal){TruePos++;} else {TrueNeg++;}
801      } else {
802        fprintf(ErrFile, "%s\n", BowDocBs->GetDocNm(DId).CStr());
803        if (PredClassVal){FalsePos++;} else {FalseNeg++;}
804      }
805      int ClassValN=(ClassVal)?1:-1;
806      fprintf(TestOutFile, "%0.6f # true=%d # docDesc=%s\n",
807       PredVal, ClassValN, BowDocBs->GetDocNm(DId).CStr());
808    }
809    double Acc=100*(TruePos+TrueNeg)/double(TestDocs);
810    double Prec=(TruePos/double(TruePos+FalsePos));
811    double Rec=(TruePos/double(TruePos+FalseNeg));
812    double F1=(2*Prec*Rec/(Prec+Rec));
813    printf("Precision %0.2f%%, Recall %0.2f%%, F1 %0.2f, Accuracy %0.2f%%\n", Prec, Rec, F1, Acc);
814    }
815  }
816  void TBowLearn::TrainPerceptronMd(const PBowDocBs& BowDocBs,
817   const TStr& TargetCatNm, TFltV& ExpWgtV,
818   const TFileId& OutFile, const double& Beta, const double& VoteTsh){
819    int TargetCId=BowDocBs->GetCId(TargetCatNm);
820    int TrainDocs=BowDocBs->GetTrainDocs();
821    ExpWgtV.PutAll(0);
822    double PrevAcc=0; double PrevPrec=0; double PrevRec=0; double PrevF1=0;
823    const double MxDiff=-0.005; const int MxWorseIters=3; int WorseIters=0;
824    const int MxIters=30; int IterN=0;
825    while ((IterN<MxIters)&&(WorseIters<MxWorseIters)){
826      IterN++;
827      int FalsePos=0; int FalseNeg=0; int TruePos=0; int TrueNeg=0;
828      for (int DIdN=0; DIdN<TrainDocs; DIdN++){
829        int DId=BowDocBs->GetTrainDId(DIdN);
830        bool ClassVal=BowDocBs->IsCatInDoc(DId, TargetCId);
831        double Wgt=0;
832        int DocWIds=BowDocBs->GetDocWIds(DId);
833        for (int DocWIdN=0; DocWIdN<DocWIds; DocWIdN++){
834          int DocWId=BowDocBs->GetDocWId(DId, DocWIdN);
835          Wgt+=ExpWgtV[DocWId];
836        }
837        bool PredClassVal;
838        if (Wgt==0){PredClassVal=TBool::GetRnd();}
839        else {PredClassVal=(Wgt>VoteTsh);}
840        if ((PredClassVal==ClassVal)&&(fabs(Wgt)>VoteTsh)){
841          if (PredClassVal){TruePos++;} else {TrueNeg++;}
842        } else { 
843          if (PredClassVal){FalsePos++;} else {FalseNeg++;}
844          for (int DocWIdN=0; DocWIdN<DocWIds; DocWIdN++){
845            int DocWId; double WordFq; BowDocBs->GetDocWIdFq(DId, DocWIdN, DocWId, WordFq);
846            if (PredClassVal){ExpWgtV[DocWId]-=Beta*WordFq;} else {ExpWgtV[DocWId]+=Beta*WordFq;}
847          }
848        }
849      }
850      double Acc=100*(TruePos+TrueNeg)/double(TrainDocs);
851      double Prec=(TruePos/double(TruePos+FalsePos));
852      double Rec=(TruePos/double(TruePos+FalseNeg));
853      double F1=(2*Prec*Rec/(Prec+Rec));
854      if (((Acc-PrevAcc)<MxDiff)||((F1-PrevF1)<MxDiff)||(((Prec-PrevPrec)<MxDiff)&&
855       ((Rec-PrevRec)<MxDiff))){WorseIters++;}
856      else {WorseIters=0;}
857      PrevAcc=Acc; PrevPrec=Prec; PrevRec=Rec; PrevF1=F1;
858      if(IterN==1){fprintf(OutFile, "# IterN, Precision, Recall, F1, Accuracy\n");}
859      printf("%d] Precision %0.2f, Recall %0.2f, F1 %0.4f, Accuracy %0.2f%%\n",
860        IterN, Prec, Rec, F1, Acc);
861      fprintf(OutFile,
862        "%d %0.2f, %0.2f, %0.2f, %0.2f%%\n", IterN, Prec, Rec, F1, Acc);
863    }
864  }
865  void TBowLearn::TestPerceptronMd(const PBowDocBs& BowDocBs,
866   const TStr& TargetCatNm, const TFltV& ExpWgtV,
867   const TFileId& TrainOutFile, const TFileId& TestOutFile, const TFileId& ErrFile,
868   const double& &bsol;*Beta*/){
869    double VoteTsh=0.0;
870    const double MxWgt=1e+15;
871    int TargetCId=BowDocBs->GetCId(TargetCatNm);
872    int TrainDocs=BowDocBs->GetTrainDocs();
873    int TestDocs=BowDocBs->GetTestDocs();
874    {int FalsePos=0; int FalseNeg=0; int TruePos=0; int TrueNeg=0;
875    for (int DIdN=0; DIdN<TrainDocs; DIdN++){
876      int DId=BowDocBs->GetTrainDId(DIdN);
877      bool ClassVal=BowDocBs->IsCatInDoc(DId, TargetCId);
878      double Wgt=0;
879      int DocWIds=BowDocBs->GetDocWIds(DId);
880      if (DocWIds==0){
881        printf("It is hard to classify an empty document %s!\n", BowDocBs->GetDocNm(DId).CStr());
882      }
883      for (int DocWIdN=0; DocWIdN<DocWIds; DocWIdN++){
884        int DocWId=BowDocBs->GetDocWId(DId, DocWIdN);
885        Wgt+=ExpWgtV[DocWId];
886      }
887      bool PredClassVal;
888      if (Wgt==0){PredClassVal=TBool::GetRnd();}
889      else {PredClassVal=(Wgt>VoteTsh);}
890      if (PredClassVal==ClassVal){
891        if (PredClassVal){TruePos++;} else {TrueNeg++;}
892      } else {
893        if (PredClassVal){FalsePos++;} else {FalseNeg++;}
894      }
895      int ClassValN=(ClassVal)?1:-1;
896      fprintf(TrainOutFile, "%0.6f # true=%d # docDesc=%s\n",
897       Wgt-VoteTsh, ClassValN, BowDocBs->GetDocNm(DId).CStr());
898    }}
899    {int FalsePos=0; int FalseNeg=0; int TruePos=0; int TrueNeg=0;
900    for (int DIdN=0; DIdN<TestDocs; DIdN++){
901      int DId=BowDocBs->GetTestDId(DIdN);
902      bool ClassVal=BowDocBs->IsCatInDoc(DId, TargetCId);
903      double Wgt=0;
904      int DocWIds=BowDocBs->GetDocWIds(DId);
905      if (DocWIds==0){
906        printf("It is hard to classify an empty document %s!\n", BowDocBs->GetDocNm(DId).CStr());
907      }
908      for (int DocWIdN=0; DocWIdN<DocWIds; DocWIdN++){
909        int DocWId=BowDocBs->GetDocWId(DId, DocWIdN);
910        Wgt+=ExpWgtV[DocWId];
911      }
912      if(Wgt>MxWgt){Wgt=MxWgt;}
913      bool PredClassVal=(Wgt>VoteTsh);
914      if (PredClassVal==ClassVal){
915        if (PredClassVal){TruePos++;} else {TrueNeg++;}
916      } else {
917        fprintf(ErrFile, "%s\n", BowDocBs->GetDocNm(DId).CStr());
918        if (PredClassVal){FalsePos++;} else {FalseNeg++;}
919      }
920      int ClassValN=(ClassVal)?1:-1;
921      fprintf(TestOutFile, "%0.6f # true=%d # docDesc=%s\n",
922       Wgt-VoteTsh, ClassValN, BowDocBs->GetDocNm(DId).CStr());
923    }
924    double Acc=100*(TruePos+TrueNeg)/double(TestDocs);
925    double Prec=(TruePos/double(TruePos+FalsePos));
926    double Rec=(TruePos/double(TruePos+FalseNeg));
927    double F1=(2*Prec*Rec/(Prec+Rec));
928    printf("Precision %0.2f, Recall %0.2f, F1: %0.2f, Accuracy %0.2f%%\n", Prec, Rec, F1, Acc);
929    }
930  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-soap.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-bowlearn.cpp</div>
                </div>
                <div class="column column_space"><pre><code>397      int RowVals=SoapTb->GetRowVals(RowN); TStr ColNm; TStr ValStr;
398      for (int RowValN=0; RowValN<RowVals; RowValN++){
399        SoapTb->GetColNmVal(RowN, RowValN, ColNm, ValStr);
400        FldNmValPrV.Add(TStrPr(TbFldNm+"_"+ColNm+"_"+TInt::GetStr(RowN), ValStr));
401      }
402      FldNmValPrV.Add(TStrPr(TbFldNm+"_TbRowEnd_"+TInt::GetStr(RowN), TStr()));
403    }
404    FldNmValPrV.Add(TStrPr(TbFldNm+"_TbEnd", TInt::GetStr(SoapTb->GetRows())));
405  }
</pre></code></div>
                <div class="column column_space"><pre><code>43        int WId; double WordFq; BowDocBs->GetDocWIdFq(DId, WIdN, WId, WordFq);
44        TStr WordStr=BowDocBs->GetWordStr(WId);
45        for (int WordFqN=0; WordFqN<WordFq; WordFqN++){
46          fprintf(OutFile, "%s ", WordStr.CStr()); /&bsol;**
47        }
48      }}
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    