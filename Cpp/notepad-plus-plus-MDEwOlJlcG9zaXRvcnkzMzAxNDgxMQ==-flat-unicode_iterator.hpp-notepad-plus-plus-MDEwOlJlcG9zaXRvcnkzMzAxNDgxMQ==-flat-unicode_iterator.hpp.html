
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 44, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-unicode_iterator.hpp</h3>
            <pre><code>1  #ifndef BOOST_REGEX_UNICODE_ITERATOR_HPP
2  #define BOOST_REGEX_UNICODE_ITERATOR_HPP
3  #include <cstdint>
4  #include <boost/regex/config.hpp>
5  #include <stdexcept>
6  #include <sstream>
7  #include <ios>
8  #include <limits.h> 
9  #ifndef BOOST_REGEX_STANDALONE
10  #include <boost/throw_exception.hpp>
11  #endif
12  namespace boost{
13  namespace detail{
14  static const std::uint16_t high_surrogate_base = 0xD7C0u;
15  static const std::uint16_t low_surrogate_base = 0xDC00u;
16  static const std::uint32_t ten_bit_mask = 0x3FFu;
17  inline bool is_high_surrogate(std::uint16_t v)
18  {
19     return (v & 0xFFFFFC00u) == 0xd800u;
20  }
21  inline bool is_low_surrogate(std::uint16_t v)
22  {
23     return (v & 0xFFFFFC00u) == 0xdc00u;
24  }
25  template <class T>
26  inline bool is_surrogate(T v)
27  {
28     return (v & 0xFFFFF800u) == 0xd800;
29  }
30  inline unsigned utf8_byte_count(std::uint8_t c)
31  {
32     std::uint8_t mask = 0x80u;
33     unsigned result = 0;
34     while(c & mask)
35     {
36        ++result;
37        mask >>= 1;
38     }
39     return (result == 0) ? 1 : ((result > 4) ? 4 : result);
40  }
41  inline unsigned utf8_trailing_byte_count(std::uint8_t c)
42  {
43     return utf8_byte_count(c) - 1;
44  }
45  #ifdef BOOST_REGEX_MSVC
46  #pragma warning(push)
47  #pragma warning(disable:4100)
48  #endif
49  #ifndef BOOST_NO_EXCEPTIONS
50  BOOST_REGEX_NORETURN
51  #endif
52  inline void invalid_utf32_code_point(std::uint32_t val)
53  {
54     std::stringstream ss;
55     ss << "Invalid UTF-32 code point U+" << std::showbase << std::hex << val << " encountered while trying to encode UTF-16 sequence";
56     std::out_of_range e(ss.str());
57  #ifndef BOOST_REGEX_STANDALONE
58     boost::throw_exception(e);
59  #else
60     throw e;
61  #endif
62  }
63  #ifdef BOOST_REGEX_MSVC
64  #pragma warning(pop)
65  #endif
66  } 
67  template <class BaseIterator, class U16Type = std::uint16_t>
68  class u32_to_u16_iterator
69  {
70     typedef typename std::iterator_traits<BaseIterator>::value_type base_value_type;
71     static_assert(sizeof(base_value_type)*CHAR_BIT == 32, "Incorrectly sized template argument");
72     static_assert(sizeof(U16Type)*CHAR_BIT == 16, "Incorrectly sized template argument");
73  public:
74     typedef std::ptrdiff_t     difference_type;
75     typedef U16Type            value_type;
76     typedef value_type const*  pointer;
77     typedef value_type const   reference;
78     typedef std::bidirectional_iterator_tag iterator_category;
79     reference operator*()const
80     {
81        if(m_current == 2)
82           extract_current();
83        return m_values[m_current];
84     }
85     bool operator==(const u32_to_u16_iterator& that)const
86     {
87        if(m_position == that.m_position)
88        {
89           return (m_current + that.m_current) & 1u ? false : true;
90        }
91        return false;
92     }
93     bool operator!=(const u32_to_u16_iterator& that)const
94     {
95        return !(*this == that);
96     }
97     u32_to_u16_iterator& operator++()
98     {
99        if(m_current == 2)
100        {
101           extract_current();
102        }
103        ++m_current;
104        if(m_values[m_current] == 0)
105        {
<span onclick='openModal()' class='match'>106           m_current = 2;
107           ++m_position;
108        }
109        return *this;
110     }
111     u32_to_u16_iterator operator++(int)
112     {
113        u32_to_u16_iterator r(*this);
114        ++(*this);
115        return r;
116     }
117     u32_to_u16_iterator& operator--()
118     {
119        if(m_current != 1)
</span>120        {
121           --m_position;
122           extract_current();
123           m_current = m_values[1] ? 1 : 0;
124        }
125        else
126        {
127           m_current = 0;
128        }
129        return *this;
130     }
131     u32_to_u16_iterator operator--(int)
132     {
133        u32_to_u16_iterator r(*this);
134        --(*this);
135        return r;
136     }
137     BaseIterator base()const
138     {
139        return m_position;
140     }
141     u32_to_u16_iterator() : m_position(), m_current(0)
142     {
143        m_values[0] = 0;
144        m_values[1] = 0;
145        m_values[2] = 0;
146     }
147     u32_to_u16_iterator(BaseIterator b) : m_position(b), m_current(2)
148     {
149        m_values[0] = 0;
150        m_values[1] = 0;
151        m_values[2] = 0;
152     }
153  private:
154     void extract_current()const
155     {
156        std::uint32_t v = *m_position;
157        if(v >= 0x10000u)
158        {
159           if(v > 0x10FFFFu)
160              detail::invalid_utf32_code_point(*m_position);
161           m_values[0] = static_cast<U16Type>(v >> 10) + detail::high_surrogate_base;
162           m_values[1] = static_cast<U16Type>(v & detail::ten_bit_mask) + detail::low_surrogate_base;
163           m_current = 0;
164           BOOST_REGEX_ASSERT(detail::is_high_surrogate(m_values[0]));
165           BOOST_REGEX_ASSERT(detail::is_low_surrogate(m_values[1]));
166        }
167        else
168        {
169           m_values[0] = static_cast<U16Type>(*m_position);
170           m_values[1] = 0;
171           m_current = 0;
172           if(detail::is_surrogate(m_values[0]))
173              detail::invalid_utf32_code_point(*m_position);
174        }
175     }
176     BaseIterator m_position;
177     mutable U16Type m_values[3];
178     mutable unsigned m_current;
179  };
180  template <class BaseIterator, class U32Type = std::uint32_t>
181  class u16_to_u32_iterator
182  {
183     static const U32Type pending_read = 0xffffffffu;
184     typedef typename std::iterator_traits<BaseIterator>::value_type base_value_type;
185     static_assert(sizeof(base_value_type)*CHAR_BIT == 16, "Incorrectly sized template argument");
186     static_assert(sizeof(U32Type)*CHAR_BIT == 32, "Incorrectly sized template argument");
187  public:
188     typedef std::ptrdiff_t     difference_type;
189     typedef U32Type            value_type;
190     typedef value_type const*  pointer;
191     typedef value_type const   reference;
192     typedef std::bidirectional_iterator_tag iterator_category;
193     reference operator*()const
194     {
195        if(m_value == pending_read)
196           extract_current();
197        return m_value;
198     }
199     bool operator==(const u16_to_u32_iterator& that)const
200     {
201        return m_position == that.m_position;
202     }
203     bool operator!=(const u16_to_u32_iterator& that)const
204     {
205        return !(*this == that);
206     }
207     u16_to_u32_iterator& operator++()
208     {
209        if(detail::is_high_surrogate(*m_position)) ++m_position;
210        ++m_position;
211        m_value = pending_read;
212        return *this;
213     }
214     u16_to_u32_iterator operator++(int)
215     {
216        u16_to_u32_iterator r(*this);
217        ++(*this);
218        return r;
219     }
220     u16_to_u32_iterator& operator--()
221     {
222        --m_position;
223        if(detail::is_low_surrogate(*m_position)) 
224           --m_position;
225        m_value = pending_read;
226        return *this;
227     }
228     u16_to_u32_iterator operator--(int)
229     {
230        u16_to_u32_iterator r(*this);
231        --(*this);
232        return r;
233     }
234     BaseIterator base()const
235     {
236        return m_position;
237     }
238     u16_to_u32_iterator() : m_position()
239     {
240        m_value = pending_read;
241     }
242     u16_to_u32_iterator(BaseIterator b) : m_position(b)
243     {
244        m_value = pending_read;
245     }
246     u16_to_u32_iterator(BaseIterator b, BaseIterator start, BaseIterator end) : m_position(b)
247     {
248        m_value = pending_read;
249        std::uint16_t val;
250        if(start != end)
251        {
252           if((b != start) && (b != end))
253           {
254              val = *b;
255              if(detail::is_surrogate(val) && ((val & 0xFC00u) == 0xDC00u))
256                 invalid_code_point(val);
257           }
258           val = *start;
259           if(detail::is_surrogate(val) && ((val & 0xFC00u) == 0xDC00u))
260              invalid_code_point(val);
261           val = *--end;
262           if(detail::is_high_surrogate(val))
263              invalid_code_point(val);
264        }
265     }
266  private:
267     static void invalid_code_point(std::uint16_t val)
268     {
269        std::stringstream ss;
270        ss << "Misplaced UTF-16 surrogate U+" << std::showbase << std::hex << val << " encountered while trying to encode UTF-32 sequence";
271        std::out_of_range e(ss.str());
272  #ifndef BOOST_REGEX_STANDALONE
273        boost::throw_exception(e);
274  #else
275        throw e;
276  #endif
277     }
278     void extract_current()const
279     {
280        m_value = static_cast<U32Type>(static_cast< std::uint16_t>(*m_position));
281        if(detail::is_high_surrogate(*m_position))
282        {
283           BaseIterator next(m_position);
284           std::uint16_t t = *++next;
285           if((t & 0xFC00u) != 0xDC00u)
286              invalid_code_point(t);
287           m_value = (m_value - detail::high_surrogate_base) << 10;
288           m_value |= (static_cast<U32Type>(static_cast< std::uint16_t>(t)) & detail::ten_bit_mask);
289        }
290        if(detail::is_surrogate(m_value))
291           invalid_code_point(static_cast< std::uint16_t>(m_value));
292     }
293     BaseIterator m_position;
294     mutable U32Type m_value;
295  };
296  template <class BaseIterator, class U8Type = std::uint8_t>
297  class u32_to_u8_iterator
298  {
299     typedef typename std::iterator_traits<BaseIterator>::value_type base_value_type;
300     static_assert(sizeof(base_value_type)*CHAR_BIT == 32, "Incorrectly sized template argument");
301     static_assert(sizeof(U8Type)*CHAR_BIT == 8, "Incorrectly sized template argument");
302  public:
303     typedef std::ptrdiff_t     difference_type;
304     typedef U8Type             value_type;
305     typedef value_type const*  pointer;
306     typedef value_type const   reference;
307     typedef std::bidirectional_iterator_tag iterator_category;
308     reference operator*()const
309     {
310        if(m_current == 4)
311           extract_current();
312        return m_values[m_current];
313     }
314     bool operator==(const u32_to_u8_iterator& that)const
315     {
316        if(m_position == that.m_position)
317        {
318           return (m_current == that.m_current)
319              || (((m_current | that.m_current) & 3) == 0);
320        }
321        return false;
322     }
323     bool operator!=(const u32_to_u8_iterator& that)const
324     {
325        return !(*this == that);
326     }
327     u32_to_u8_iterator& operator++()
328     {
329        if(m_current == 4)
330        {
331           extract_current();
332        }
333        ++m_current;
334        if(m_values[m_current] == 0)
335        {
336           m_current = 4;
337           ++m_position;
338        }
339        return *this;
340     }
341     u32_to_u8_iterator operator++(int)
342     {
343        u32_to_u8_iterator r(*this);
344        ++(*this);
345        return r;
346     }
347     u32_to_u8_iterator& operator--()
348     {
349        if((m_current & 3) == 0)
350        {
351           --m_position;
352           extract_current();
353           m_current = 3;
354           while(m_current && (m_values[m_current] == 0))
355              --m_current;
356        }
357        else
358           --m_current;
359        return *this;
360     }
361     u32_to_u8_iterator operator--(int)
362     {
363        u32_to_u8_iterator r(*this);
364        --(*this);
365        return r;
366     }
367     BaseIterator base()const
368     {
369        return m_position;
370     }
371     u32_to_u8_iterator() : m_position(), m_current(0)
372     {
373        m_values[0] = 0;
374        m_values[1] = 0;
375        m_values[2] = 0;
376        m_values[3] = 0;
377        m_values[4] = 0;
378     }
379     u32_to_u8_iterator(BaseIterator b) : m_position(b), m_current(4)
380     {
381        m_values[0] = 0;
382        m_values[1] = 0;
383        m_values[2] = 0;
384        m_values[3] = 0;
385        m_values[4] = 0;
386     }
387  private:
388     void extract_current()const
389     {
390        std::uint32_t c = *m_position;
391        if(c > 0x10FFFFu)
392           detail::invalid_utf32_code_point(c);
393        if(c < 0x80u)
394        {
395           m_values[0] = static_cast<unsigned char>(c);
396           m_values[1] = static_cast<unsigned char>(0u);
397           m_values[2] = static_cast<unsigned char>(0u);
398           m_values[3] = static_cast<unsigned char>(0u);
399        }
400        else if(c < 0x800u)
401        {
402           m_values[0] = static_cast<unsigned char>(0xC0u + (c >> 6));
403           m_values[1] = static_cast<unsigned char>(0x80u + (c & 0x3Fu));
404           m_values[2] = static_cast<unsigned char>(0u);
405           m_values[3] = static_cast<unsigned char>(0u);
406        }
407        else if(c < 0x10000u)
408        {
409           m_values[0] = static_cast<unsigned char>(0xE0u + (c >> 12));
410           m_values[1] = static_cast<unsigned char>(0x80u + ((c >> 6) & 0x3Fu));
411           m_values[2] = static_cast<unsigned char>(0x80u + (c & 0x3Fu));
412           m_values[3] = static_cast<unsigned char>(0u);
413        }
414        else
415        {
416           m_values[0] = static_cast<unsigned char>(0xF0u + (c >> 18));
417           m_values[1] = static_cast<unsigned char>(0x80u + ((c >> 12) & 0x3Fu));
418           m_values[2] = static_cast<unsigned char>(0x80u + ((c >> 6) & 0x3Fu));
419           m_values[3] = static_cast<unsigned char>(0x80u + (c & 0x3Fu));
420        }
421        m_current= 0;
422     }
423     BaseIterator m_position;
424     mutable U8Type m_values[5];
425     mutable unsigned m_current;
426  };
427  template <class BaseIterator, class U32Type = std::uint32_t>
428  class u8_to_u32_iterator
429  {
430     static const U32Type pending_read = 0xffffffffu;
431     typedef typename std::iterator_traits<BaseIterator>::value_type base_value_type;
432     static_assert(sizeof(base_value_type)*CHAR_BIT == 8, "Incorrectly sized template argument");
433     static_assert(sizeof(U32Type)*CHAR_BIT == 32, "Incorrectly sized template argument");
434  public:
435     typedef std::ptrdiff_t     difference_type;
436     typedef U32Type            value_type;
437     typedef value_type const*  pointer;
438     typedef value_type const   reference;
439     typedef std::bidirectional_iterator_tag iterator_category;
440     reference operator*()const
441     {
442        if(m_value == pending_read)
443           extract_current();
444        return m_value;
445     }
446     bool operator==(const u8_to_u32_iterator& that)const
447     {
448        return m_position == that.m_position;
449     }
450     bool operator!=(const u8_to_u32_iterator& that)const
451     {
452        return !(*this == that);
453     }
454     u8_to_u32_iterator& operator++()
455     {
456        if((static_cast<std::uint8_t>(*m_position) & 0xC0) == 0x80)
457           invalid_sequence();
458        unsigned c = detail::utf8_byte_count(*m_position);
459        if(m_value == pending_read)
460        {
461           for(unsigned i = 0; i < c; ++i)
462           {
463              ++m_position;
464              if((i != c - 1) && ((static_cast<std::uint8_t>(*m_position) & 0xC0) != 0x80))
465                 invalid_sequence();
466           }
467        }
468        else
469        {
470           std::advance(m_position, c);
471        }
472        m_value = pending_read;
473        return *this;
474     }
475     u8_to_u32_iterator operator++(int)
476     {
477        u8_to_u32_iterator r(*this);
478        ++(*this);
479        return r;
480     }
481     u8_to_u32_iterator& operator--()
482     {
483        unsigned count = 0;
484        while((*--m_position & 0xC0u) == 0x80u) ++count;
485        if(count != detail::utf8_trailing_byte_count(*m_position))
486           invalid_sequence();
487        m_value = pending_read;
488        return *this;
489     }
490     u8_to_u32_iterator operator--(int)
491     {
492        u8_to_u32_iterator r(*this);
493        --(*this);
494        return r;
495     }
496     BaseIterator base()const
497     {
498        return m_position;
499     }
500     u8_to_u32_iterator() : m_position()
501     {
502        m_value = pending_read;
503     }
504     u8_to_u32_iterator(BaseIterator b) : m_position(b)
505     {
506        m_value = pending_read;
507     }
508     u8_to_u32_iterator(BaseIterator b, BaseIterator start, BaseIterator end) : m_position(b)
509     {
510        m_value = pending_read;
511        if(start != end)
512        {
513           unsigned char v = *start;
514           if((v & 0xC0u) == 0x80u)
515              invalid_sequence();
516           if((b != start) && (b != end) && ((*b & 0xC0u) == 0x80u))
517              invalid_sequence();
518           BaseIterator pos = end;
519           do
520           {
521              v = *--pos;
522           }
523           while((start != pos) && ((v & 0xC0u) == 0x80u));
524           std::ptrdiff_t extra = detail::utf8_byte_count(v);
525           if(std::distance(pos, end) < extra)
526              invalid_sequence();
527        }
528     }
529  private:
530     static void invalid_sequence()
531     {
532        std::out_of_range e("Invalid UTF-8 sequence encountered while trying to encode UTF-32 character");
533  #ifndef BOOST_REGEX_STANDALONE
534        boost::throw_exception(e);
535  #else
536        throw e;
537  #endif
538     }
539     void extract_current()const
540     {
541        m_value = static_cast<U32Type>(static_cast< std::uint8_t>(*m_position));
542        if((m_value & 0xC0u) == 0x80u)
543           invalid_sequence();
544        unsigned extra = detail::utf8_trailing_byte_count(*m_position);
545        BaseIterator next(m_position);
546        for(unsigned c = 0; c < extra; ++c)
547        {
548           ++next;
549           m_value <<= 6;
550           if((static_cast<std::uint8_t>(*next) & 0xC0) != 0x80)
551              invalid_sequence();
552           m_value += static_cast<std::uint8_t>(*next) & 0x3Fu;
553        }
554        static const std::uint32_t masks[4] = 
555        {
556           0x7Fu,
557           0x7FFu,
558           0xFFFFu,
559           0x1FFFFFu,
560        };
561        m_value &= masks[extra];
562        if(m_value > static_cast<U32Type>(0x10FFFFu))
563           invalid_sequence();
564        if((m_value >= static_cast<U32Type>(0xD800)) && (m_value <= static_cast<U32Type>(0xDFFF)))
565           invalid_sequence();
566        if((extra > 0) && (m_value <= static_cast<U32Type>(masks[extra - 1])))
567           invalid_sequence();
568     }
569     BaseIterator m_position;
570     mutable U32Type m_value;
571  };
572  template <class BaseIterator>
573  class utf16_output_iterator
574  {
575  public:
576     typedef void                                   difference_type;
577     typedef void                                   value_type;
578     typedef std::uint32_t*                         pointer;
579     typedef std::uint32_t&                         reference;
580     typedef std::output_iterator_tag               iterator_category;
581     utf16_output_iterator(const BaseIterator& b)
582        : m_position(b){}
583     utf16_output_iterator(const utf16_output_iterator& that)
584        : m_position(that.m_position){}
585     utf16_output_iterator& operator=(const utf16_output_iterator& that)
586     {
587        m_position = that.m_position;
588        return *this;
589     }
590     const utf16_output_iterator& operator*()const
591     {
592        return *this;
593     }
594     void operator=(std::uint32_t val)const
595     {
596        push(val);
597     }
598     utf16_output_iterator& operator++()
599     {
600        return *this;
601     }
602     utf16_output_iterator& operator++(int)
603     {
604        return *this;
605     }
606     BaseIterator base()const
607     {
608        return m_position;
609     }
610  private:
611     void push(std::uint32_t v)const
612     {
613        if(v >= 0x10000u)
614        {
615           if(v > 0x10FFFFu)
616              detail::invalid_utf32_code_point(v);
617           *m_position++ = static_cast<std::uint16_t>(v >> 10) + detail::high_surrogate_base;
618           *m_position++ = static_cast<std::uint16_t>(v & detail::ten_bit_mask) + detail::low_surrogate_base;
619        }
620        else
621        {
622           if(detail::is_surrogate(v))
623              detail::invalid_utf32_code_point(v);
624           *m_position++ = static_cast<std::uint16_t>(v);
625        }
626     }
627     mutable BaseIterator m_position;
628  };
629  template <class BaseIterator>
630  class utf8_output_iterator
631  {
632  public:
633     typedef void                                   difference_type;
634     typedef void                                   value_type;
635     typedef std::uint32_t*                       pointer;
636     typedef std::uint32_t&                       reference;
637     typedef std::output_iterator_tag               iterator_category;
638     utf8_output_iterator(const BaseIterator& b)
639        : m_position(b){}
640     utf8_output_iterator(const utf8_output_iterator& that)
641        : m_position(that.m_position){}
642     utf8_output_iterator& operator=(const utf8_output_iterator& that)
643     {
644        m_position = that.m_position;
645        return *this;
646     }
647     const utf8_output_iterator& operator*()const
648     {
649        return *this;
650     }
651     void operator=(std::uint32_t val)const
652     {
653        push(val);
654     }
655     utf8_output_iterator& operator++()
656     {
657        return *this;
658     }
659     utf8_output_iterator& operator++(int)
660     {
661        return *this;
662     }
663     BaseIterator base()const
664     {
665        return m_position;
666     }
667  private:
668     void push(std::uint32_t c)const
669     {
670        if(c > 0x10FFFFu)
671           detail::invalid_utf32_code_point(c);
672        if(c < 0x80u)
673        {
674           *m_position++ = static_cast<unsigned char>(c);
675        }
676        else if(c < 0x800u)
677        {
678           *m_position++ = static_cast<unsigned char>(0xC0u + (c >> 6));
679           *m_position++ = static_cast<unsigned char>(0x80u + (c & 0x3Fu));
680        }
681        else if(c < 0x10000u)
682        {
683           *m_position++ = static_cast<unsigned char>(0xE0u + (c >> 12));
684           *m_position++ = static_cast<unsigned char>(0x80u + ((c >> 6) & 0x3Fu));
685           *m_position++ = static_cast<unsigned char>(0x80u + (c & 0x3Fu));
686        }
687        else
688        {
689           *m_position++ = static_cast<unsigned char>(0xF0u + (c >> 18));
690           *m_position++ = static_cast<unsigned char>(0x80u + ((c >> 12) & 0x3Fu));
691           *m_position++ = static_cast<unsigned char>(0x80u + ((c >> 6) & 0x3Fu));
692           *m_position++ = static_cast<unsigned char>(0x80u + (c & 0x3Fu));
693        }
694     }
695     mutable BaseIterator m_position;
696  };
697  } 
698  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-unicode_iterator.hpp</h3>
            <pre><code>1  #ifndef BOOST_REGEX_UNICODE_ITERATOR_HPP
2  #define BOOST_REGEX_UNICODE_ITERATOR_HPP
3  #include <cstdint>
4  #include <boost/regex/config.hpp>
5  #include <stdexcept>
6  #include <sstream>
7  #include <ios>
8  #include <limits.h> 
9  #ifndef BOOST_REGEX_STANDALONE
10  #include <boost/throw_exception.hpp>
11  #endif
12  namespace boost{
13  namespace detail{
14  static const std::uint16_t high_surrogate_base = 0xD7C0u;
15  static const std::uint16_t low_surrogate_base = 0xDC00u;
16  static const std::uint32_t ten_bit_mask = 0x3FFu;
17  inline bool is_high_surrogate(std::uint16_t v)
18  {
19     return (v & 0xFFFFFC00u) == 0xd800u;
20  }
21  inline bool is_low_surrogate(std::uint16_t v)
22  {
23     return (v & 0xFFFFFC00u) == 0xdc00u;
24  }
25  template <class T>
26  inline bool is_surrogate(T v)
27  {
28     return (v & 0xFFFFF800u) == 0xd800;
29  }
30  inline unsigned utf8_byte_count(std::uint8_t c)
31  {
32     std::uint8_t mask = 0x80u;
33     unsigned result = 0;
34     while(c & mask)
35     {
36        ++result;
37        mask >>= 1;
38     }
39     return (result == 0) ? 1 : ((result > 4) ? 4 : result);
40  }
41  inline unsigned utf8_trailing_byte_count(std::uint8_t c)
42  {
43     return utf8_byte_count(c) - 1;
44  }
45  #ifdef BOOST_REGEX_MSVC
46  #pragma warning(push)
47  #pragma warning(disable:4100)
48  #endif
49  #ifndef BOOST_NO_EXCEPTIONS
50  BOOST_REGEX_NORETURN
51  #endif
52  inline void invalid_utf32_code_point(std::uint32_t val)
53  {
54     std::stringstream ss;
55     ss << "Invalid UTF-32 code point U+" << std::showbase << std::hex << val << " encountered while trying to encode UTF-16 sequence";
56     std::out_of_range e(ss.str());
57  #ifndef BOOST_REGEX_STANDALONE
58     boost::throw_exception(e);
59  #else
60     throw e;
61  #endif
62  }
63  #ifdef BOOST_REGEX_MSVC
64  #pragma warning(pop)
65  #endif
66  } 
67  template <class BaseIterator, class U16Type = std::uint16_t>
68  class u32_to_u16_iterator
69  {
70     typedef typename std::iterator_traits<BaseIterator>::value_type base_value_type;
71     static_assert(sizeof(base_value_type)*CHAR_BIT == 32, "Incorrectly sized template argument");
72     static_assert(sizeof(U16Type)*CHAR_BIT == 16, "Incorrectly sized template argument");
73  public:
74     typedef std::ptrdiff_t     difference_type;
75     typedef U16Type            value_type;
76     typedef value_type const*  pointer;
77     typedef value_type const   reference;
78     typedef std::bidirectional_iterator_tag iterator_category;
79     reference operator*()const
80     {
81        if(m_current == 2)
82           extract_current();
83        return m_values[m_current];
84     }
85     bool operator==(const u32_to_u16_iterator& that)const
86     {
87        if(m_position == that.m_position)
88        {
89           return (m_current + that.m_current) & 1u ? false : true;
90        }
91        return false;
92     }
93     bool operator!=(const u32_to_u16_iterator& that)const
94     {
95        return !(*this == that);
96     }
97     u32_to_u16_iterator& operator++()
98     {
99        if(m_current == 2)
100        {
101           extract_current();
102        }
103        ++m_current;
104        if(m_values[m_current] == 0)
105        {
<span onclick='openModal()' class='match'>106           m_current = 2;
107           ++m_position;
108        }
109        return *this;
110     }
111     u32_to_u16_iterator operator++(int)
112     {
113        u32_to_u16_iterator r(*this);
114        ++(*this);
115        return r;
116     }
117     u32_to_u16_iterator& operator--()
118     {
119        if(m_current != 1)
</span>120        {
121           --m_position;
122           extract_current();
123           m_current = m_values[1] ? 1 : 0;
124        }
125        else
126        {
127           m_current = 0;
128        }
129        return *this;
130     }
131     u32_to_u16_iterator operator--(int)
132     {
133        u32_to_u16_iterator r(*this);
134        --(*this);
135        return r;
136     }
137     BaseIterator base()const
138     {
139        return m_position;
140     }
141     u32_to_u16_iterator() : m_position(), m_current(0)
142     {
143        m_values[0] = 0;
144        m_values[1] = 0;
145        m_values[2] = 0;
146     }
147     u32_to_u16_iterator(BaseIterator b) : m_position(b), m_current(2)
148     {
149        m_values[0] = 0;
150        m_values[1] = 0;
151        m_values[2] = 0;
152     }
153  private:
154     void extract_current()const
155     {
156        std::uint32_t v = *m_position;
157        if(v >= 0x10000u)
158        {
159           if(v > 0x10FFFFu)
160              detail::invalid_utf32_code_point(*m_position);
161           m_values[0] = static_cast<U16Type>(v >> 10) + detail::high_surrogate_base;
162           m_values[1] = static_cast<U16Type>(v & detail::ten_bit_mask) + detail::low_surrogate_base;
163           m_current = 0;
164           BOOST_REGEX_ASSERT(detail::is_high_surrogate(m_values[0]));
165           BOOST_REGEX_ASSERT(detail::is_low_surrogate(m_values[1]));
166        }
167        else
168        {
169           m_values[0] = static_cast<U16Type>(*m_position);
170           m_values[1] = 0;
171           m_current = 0;
172           if(detail::is_surrogate(m_values[0]))
173              detail::invalid_utf32_code_point(*m_position);
174        }
175     }
176     BaseIterator m_position;
177     mutable U16Type m_values[3];
178     mutable unsigned m_current;
179  };
180  template <class BaseIterator, class U32Type = std::uint32_t>
181  class u16_to_u32_iterator
182  {
183     static const U32Type pending_read = 0xffffffffu;
184     typedef typename std::iterator_traits<BaseIterator>::value_type base_value_type;
185     static_assert(sizeof(base_value_type)*CHAR_BIT == 16, "Incorrectly sized template argument");
186     static_assert(sizeof(U32Type)*CHAR_BIT == 32, "Incorrectly sized template argument");
187  public:
188     typedef std::ptrdiff_t     difference_type;
189     typedef U32Type            value_type;
190     typedef value_type const*  pointer;
191     typedef value_type const   reference;
192     typedef std::bidirectional_iterator_tag iterator_category;
193     reference operator*()const
194     {
195        if(m_value == pending_read)
196           extract_current();
197        return m_value;
198     }
199     bool operator==(const u16_to_u32_iterator& that)const
200     {
201        return m_position == that.m_position;
202     }
203     bool operator!=(const u16_to_u32_iterator& that)const
204     {
205        return !(*this == that);
206     }
207     u16_to_u32_iterator& operator++()
208     {
209        if(detail::is_high_surrogate(*m_position)) ++m_position;
210        ++m_position;
211        m_value = pending_read;
212        return *this;
213     }
214     u16_to_u32_iterator operator++(int)
215     {
216        u16_to_u32_iterator r(*this);
217        ++(*this);
218        return r;
219     }
220     u16_to_u32_iterator& operator--()
221     {
222        --m_position;
223        if(detail::is_low_surrogate(*m_position)) 
224           --m_position;
225        m_value = pending_read;
226        return *this;
227     }
228     u16_to_u32_iterator operator--(int)
229     {
230        u16_to_u32_iterator r(*this);
231        --(*this);
232        return r;
233     }
234     BaseIterator base()const
235     {
236        return m_position;
237     }
238     u16_to_u32_iterator() : m_position()
239     {
240        m_value = pending_read;
241     }
242     u16_to_u32_iterator(BaseIterator b) : m_position(b)
243     {
244        m_value = pending_read;
245     }
246     u16_to_u32_iterator(BaseIterator b, BaseIterator start, BaseIterator end) : m_position(b)
247     {
248        m_value = pending_read;
249        std::uint16_t val;
250        if(start != end)
251        {
252           if((b != start) && (b != end))
253           {
254              val = *b;
255              if(detail::is_surrogate(val) && ((val & 0xFC00u) == 0xDC00u))
256                 invalid_code_point(val);
257           }
258           val = *start;
259           if(detail::is_surrogate(val) && ((val & 0xFC00u) == 0xDC00u))
260              invalid_code_point(val);
261           val = *--end;
262           if(detail::is_high_surrogate(val))
263              invalid_code_point(val);
264        }
265     }
266  private:
267     static void invalid_code_point(std::uint16_t val)
268     {
269        std::stringstream ss;
270        ss << "Misplaced UTF-16 surrogate U+" << std::showbase << std::hex << val << " encountered while trying to encode UTF-32 sequence";
271        std::out_of_range e(ss.str());
272  #ifndef BOOST_REGEX_STANDALONE
273        boost::throw_exception(e);
274  #else
275        throw e;
276  #endif
277     }
278     void extract_current()const
279     {
280        m_value = static_cast<U32Type>(static_cast< std::uint16_t>(*m_position));
281        if(detail::is_high_surrogate(*m_position))
282        {
283           BaseIterator next(m_position);
284           std::uint16_t t = *++next;
285           if((t & 0xFC00u) != 0xDC00u)
286              invalid_code_point(t);
287           m_value = (m_value - detail::high_surrogate_base) << 10;
288           m_value |= (static_cast<U32Type>(static_cast< std::uint16_t>(t)) & detail::ten_bit_mask);
289        }
290        if(detail::is_surrogate(m_value))
291           invalid_code_point(static_cast< std::uint16_t>(m_value));
292     }
293     BaseIterator m_position;
294     mutable U32Type m_value;
295  };
296  template <class BaseIterator, class U8Type = std::uint8_t>
297  class u32_to_u8_iterator
298  {
299     typedef typename std::iterator_traits<BaseIterator>::value_type base_value_type;
300     static_assert(sizeof(base_value_type)*CHAR_BIT == 32, "Incorrectly sized template argument");
301     static_assert(sizeof(U8Type)*CHAR_BIT == 8, "Incorrectly sized template argument");
302  public:
303     typedef std::ptrdiff_t     difference_type;
304     typedef U8Type             value_type;
305     typedef value_type const*  pointer;
306     typedef value_type const   reference;
307     typedef std::bidirectional_iterator_tag iterator_category;
308     reference operator*()const
309     {
310        if(m_current == 4)
311           extract_current();
312        return m_values[m_current];
313     }
314     bool operator==(const u32_to_u8_iterator& that)const
315     {
316        if(m_position == that.m_position)
317        {
318           return (m_current == that.m_current)
319              || (((m_current | that.m_current) & 3) == 0);
320        }
321        return false;
322     }
323     bool operator!=(const u32_to_u8_iterator& that)const
324     {
325        return !(*this == that);
326     }
327     u32_to_u8_iterator& operator++()
328     {
329        if(m_current == 4)
330        {
331           extract_current();
332        }
333        ++m_current;
334        if(m_values[m_current] == 0)
335        {
336           m_current = 4;
337           ++m_position;
338        }
339        return *this;
340     }
341     u32_to_u8_iterator operator++(int)
342     {
343        u32_to_u8_iterator r(*this);
344        ++(*this);
345        return r;
346     }
347     u32_to_u8_iterator& operator--()
348     {
349        if((m_current & 3) == 0)
350        {
351           --m_position;
352           extract_current();
353           m_current = 3;
354           while(m_current && (m_values[m_current] == 0))
355              --m_current;
356        }
357        else
358           --m_current;
359        return *this;
360     }
361     u32_to_u8_iterator operator--(int)
362     {
363        u32_to_u8_iterator r(*this);
364        --(*this);
365        return r;
366     }
367     BaseIterator base()const
368     {
369        return m_position;
370     }
371     u32_to_u8_iterator() : m_position(), m_current(0)
372     {
373        m_values[0] = 0;
374        m_values[1] = 0;
375        m_values[2] = 0;
376        m_values[3] = 0;
377        m_values[4] = 0;
378     }
379     u32_to_u8_iterator(BaseIterator b) : m_position(b), m_current(4)
380     {
381        m_values[0] = 0;
382        m_values[1] = 0;
383        m_values[2] = 0;
384        m_values[3] = 0;
385        m_values[4] = 0;
386     }
387  private:
388     void extract_current()const
389     {
390        std::uint32_t c = *m_position;
391        if(c > 0x10FFFFu)
392           detail::invalid_utf32_code_point(c);
393        if(c < 0x80u)
394        {
395           m_values[0] = static_cast<unsigned char>(c);
396           m_values[1] = static_cast<unsigned char>(0u);
397           m_values[2] = static_cast<unsigned char>(0u);
398           m_values[3] = static_cast<unsigned char>(0u);
399        }
400        else if(c < 0x800u)
401        {
402           m_values[0] = static_cast<unsigned char>(0xC0u + (c >> 6));
403           m_values[1] = static_cast<unsigned char>(0x80u + (c & 0x3Fu));
404           m_values[2] = static_cast<unsigned char>(0u);
405           m_values[3] = static_cast<unsigned char>(0u);
406        }
407        else if(c < 0x10000u)
408        {
409           m_values[0] = static_cast<unsigned char>(0xE0u + (c >> 12));
410           m_values[1] = static_cast<unsigned char>(0x80u + ((c >> 6) & 0x3Fu));
411           m_values[2] = static_cast<unsigned char>(0x80u + (c & 0x3Fu));
412           m_values[3] = static_cast<unsigned char>(0u);
413        }
414        else
415        {
416           m_values[0] = static_cast<unsigned char>(0xF0u + (c >> 18));
417           m_values[1] = static_cast<unsigned char>(0x80u + ((c >> 12) & 0x3Fu));
418           m_values[2] = static_cast<unsigned char>(0x80u + ((c >> 6) & 0x3Fu));
419           m_values[3] = static_cast<unsigned char>(0x80u + (c & 0x3Fu));
420        }
421        m_current= 0;
422     }
423     BaseIterator m_position;
424     mutable U8Type m_values[5];
425     mutable unsigned m_current;
426  };
427  template <class BaseIterator, class U32Type = std::uint32_t>
428  class u8_to_u32_iterator
429  {
430     static const U32Type pending_read = 0xffffffffu;
431     typedef typename std::iterator_traits<BaseIterator>::value_type base_value_type;
432     static_assert(sizeof(base_value_type)*CHAR_BIT == 8, "Incorrectly sized template argument");
433     static_assert(sizeof(U32Type)*CHAR_BIT == 32, "Incorrectly sized template argument");
434  public:
435     typedef std::ptrdiff_t     difference_type;
436     typedef U32Type            value_type;
437     typedef value_type const*  pointer;
438     typedef value_type const   reference;
439     typedef std::bidirectional_iterator_tag iterator_category;
440     reference operator*()const
441     {
442        if(m_value == pending_read)
443           extract_current();
444        return m_value;
445     }
446     bool operator==(const u8_to_u32_iterator& that)const
447     {
448        return m_position == that.m_position;
449     }
450     bool operator!=(const u8_to_u32_iterator& that)const
451     {
452        return !(*this == that);
453     }
454     u8_to_u32_iterator& operator++()
455     {
456        if((static_cast<std::uint8_t>(*m_position) & 0xC0) == 0x80)
457           invalid_sequence();
458        unsigned c = detail::utf8_byte_count(*m_position);
459        if(m_value == pending_read)
460        {
461           for(unsigned i = 0; i < c; ++i)
462           {
463              ++m_position;
464              if((i != c - 1) && ((static_cast<std::uint8_t>(*m_position) & 0xC0) != 0x80))
465                 invalid_sequence();
466           }
467        }
468        else
469        {
470           std::advance(m_position, c);
471        }
472        m_value = pending_read;
473        return *this;
474     }
475     u8_to_u32_iterator operator++(int)
476     {
477        u8_to_u32_iterator r(*this);
478        ++(*this);
479        return r;
480     }
481     u8_to_u32_iterator& operator--()
482     {
483        unsigned count = 0;
484        while((*--m_position & 0xC0u) == 0x80u) ++count;
485        if(count != detail::utf8_trailing_byte_count(*m_position))
486           invalid_sequence();
487        m_value = pending_read;
488        return *this;
489     }
490     u8_to_u32_iterator operator--(int)
491     {
492        u8_to_u32_iterator r(*this);
493        --(*this);
494        return r;
495     }
496     BaseIterator base()const
497     {
498        return m_position;
499     }
500     u8_to_u32_iterator() : m_position()
501     {
502        m_value = pending_read;
503     }
504     u8_to_u32_iterator(BaseIterator b) : m_position(b)
505     {
506        m_value = pending_read;
507     }
508     u8_to_u32_iterator(BaseIterator b, BaseIterator start, BaseIterator end) : m_position(b)
509     {
510        m_value = pending_read;
511        if(start != end)
512        {
513           unsigned char v = *start;
514           if((v & 0xC0u) == 0x80u)
515              invalid_sequence();
516           if((b != start) && (b != end) && ((*b & 0xC0u) == 0x80u))
517              invalid_sequence();
518           BaseIterator pos = end;
519           do
520           {
521              v = *--pos;
522           }
523           while((start != pos) && ((v & 0xC0u) == 0x80u));
524           std::ptrdiff_t extra = detail::utf8_byte_count(v);
525           if(std::distance(pos, end) < extra)
526              invalid_sequence();
527        }
528     }
529  private:
530     static void invalid_sequence()
531     {
532        std::out_of_range e("Invalid UTF-8 sequence encountered while trying to encode UTF-32 character");
533  #ifndef BOOST_REGEX_STANDALONE
534        boost::throw_exception(e);
535  #else
536        throw e;
537  #endif
538     }
539     void extract_current()const
540     {
541        m_value = static_cast<U32Type>(static_cast< std::uint8_t>(*m_position));
542        if((m_value & 0xC0u) == 0x80u)
543           invalid_sequence();
544        unsigned extra = detail::utf8_trailing_byte_count(*m_position);
545        BaseIterator next(m_position);
546        for(unsigned c = 0; c < extra; ++c)
547        {
548           ++next;
549           m_value <<= 6;
550           if((static_cast<std::uint8_t>(*next) & 0xC0) != 0x80)
551              invalid_sequence();
552           m_value += static_cast<std::uint8_t>(*next) & 0x3Fu;
553        }
554        static const std::uint32_t masks[4] = 
555        {
556           0x7Fu,
557           0x7FFu,
558           0xFFFFu,
559           0x1FFFFFu,
560        };
561        m_value &= masks[extra];
562        if(m_value > static_cast<U32Type>(0x10FFFFu))
563           invalid_sequence();
564        if((m_value >= static_cast<U32Type>(0xD800)) && (m_value <= static_cast<U32Type>(0xDFFF)))
565           invalid_sequence();
566        if((extra > 0) && (m_value <= static_cast<U32Type>(masks[extra - 1])))
567           invalid_sequence();
568     }
569     BaseIterator m_position;
570     mutable U32Type m_value;
571  };
572  template <class BaseIterator>
573  class utf16_output_iterator
574  {
575  public:
576     typedef void                                   difference_type;
577     typedef void                                   value_type;
578     typedef std::uint32_t*                         pointer;
579     typedef std::uint32_t&                         reference;
580     typedef std::output_iterator_tag               iterator_category;
581     utf16_output_iterator(const BaseIterator& b)
582        : m_position(b){}
583     utf16_output_iterator(const utf16_output_iterator& that)
584        : m_position(that.m_position){}
585     utf16_output_iterator& operator=(const utf16_output_iterator& that)
586     {
587        m_position = that.m_position;
588        return *this;
589     }
590     const utf16_output_iterator& operator*()const
591     {
592        return *this;
593     }
594     void operator=(std::uint32_t val)const
595     {
596        push(val);
597     }
598     utf16_output_iterator& operator++()
599     {
600        return *this;
601     }
602     utf16_output_iterator& operator++(int)
603     {
604        return *this;
605     }
606     BaseIterator base()const
607     {
608        return m_position;
609     }
610  private:
611     void push(std::uint32_t v)const
612     {
613        if(v >= 0x10000u)
614        {
615           if(v > 0x10FFFFu)
616              detail::invalid_utf32_code_point(v);
617           *m_position++ = static_cast<std::uint16_t>(v >> 10) + detail::high_surrogate_base;
618           *m_position++ = static_cast<std::uint16_t>(v & detail::ten_bit_mask) + detail::low_surrogate_base;
619        }
620        else
621        {
622           if(detail::is_surrogate(v))
623              detail::invalid_utf32_code_point(v);
624           *m_position++ = static_cast<std::uint16_t>(v);
625        }
626     }
627     mutable BaseIterator m_position;
628  };
629  template <class BaseIterator>
630  class utf8_output_iterator
631  {
632  public:
633     typedef void                                   difference_type;
634     typedef void                                   value_type;
635     typedef std::uint32_t*                       pointer;
636     typedef std::uint32_t&                       reference;
637     typedef std::output_iterator_tag               iterator_category;
638     utf8_output_iterator(const BaseIterator& b)
639        : m_position(b){}
640     utf8_output_iterator(const utf8_output_iterator& that)
641        : m_position(that.m_position){}
642     utf8_output_iterator& operator=(const utf8_output_iterator& that)
643     {
644        m_position = that.m_position;
645        return *this;
646     }
647     const utf8_output_iterator& operator*()const
648     {
649        return *this;
650     }
651     void operator=(std::uint32_t val)const
652     {
653        push(val);
654     }
655     utf8_output_iterator& operator++()
656     {
657        return *this;
658     }
659     utf8_output_iterator& operator++(int)
660     {
661        return *this;
662     }
663     BaseIterator base()const
664     {
665        return m_position;
666     }
667  private:
668     void push(std::uint32_t c)const
669     {
670        if(c > 0x10FFFFu)
671           detail::invalid_utf32_code_point(c);
672        if(c < 0x80u)
673        {
674           *m_position++ = static_cast<unsigned char>(c);
675        }
676        else if(c < 0x800u)
677        {
678           *m_position++ = static_cast<unsigned char>(0xC0u + (c >> 6));
679           *m_position++ = static_cast<unsigned char>(0x80u + (c & 0x3Fu));
680        }
681        else if(c < 0x10000u)
682        {
683           *m_position++ = static_cast<unsigned char>(0xE0u + (c >> 12));
684           *m_position++ = static_cast<unsigned char>(0x80u + ((c >> 6) & 0x3Fu));
685           *m_position++ = static_cast<unsigned char>(0x80u + (c & 0x3Fu));
686        }
687        else
688        {
689           *m_position++ = static_cast<unsigned char>(0xF0u + (c >> 18));
690           *m_position++ = static_cast<unsigned char>(0x80u + ((c >> 12) & 0x3Fu));
691           *m_position++ = static_cast<unsigned char>(0x80u + ((c >> 6) & 0x3Fu));
692           *m_position++ = static_cast<unsigned char>(0x80u + (c & 0x3Fu));
693        }
694     }
695     mutable BaseIterator m_position;
696  };
697  } 
698  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-unicode_iterator.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-unicode_iterator.hpp</div>
                </div>
                <div class="column column_space"><pre><code>106           m_current = 2;
107           ++m_position;
108        }
109        return *this;
110     }
111     u32_to_u16_iterator operator++(int)
112     {
113        u32_to_u16_iterator r(*this);
114        ++(*this);
115        return r;
116     }
117     u32_to_u16_iterator& operator--()
118     {
119        if(m_current != 1)
</pre></code></div>
                <div class="column column_space"><pre><code>106           m_current = 2;
107           ++m_position;
108        }
109        return *this;
110     }
111     u32_to_u16_iterator operator++(int)
112     {
113        u32_to_u16_iterator r(*this);
114        ++(*this);
115        return r;
116     }
117     u32_to_u16_iterator& operator--()
118     {
119        if(m_current != 1)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    