<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for handler_test.cpp &amp; dispatcher_test.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for handler_test.cpp &amp; dispatcher_test.cpp
      </h3>
<h1 align="center">
        5.5%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>handler_test.cpp (20.3125%)<th>dispatcher_test.cpp (3.233831%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(42-55)<td><a href="#" name="0">(15-30)</a><td align="center"><font color="#ff0000">13</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>handler_test.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;eventually/handler.hpp&gt;
2 #include &lt;future&gt;
3 #include "gtest/gtest.h"
4 using namespace eventually;
5 TEST(handler, basic) {
6     handler&lt;&gt; h;
7     connection c;
8     std::promise&lt;int&gt; p;
9     auto f = p.get_future();
10     h([](){
11         return 4;
12     }, c, p);
13     ASSERT_EQ(4, f.get());
14 }
15 TEST(handler, make) {
16     auto h = make_handler();
17     connection c;
18     std::promise&lt;int&gt; p;
19     auto f = p.get_future();    
20     h([](){
21         return 4;
22     }, c, p);
23     ASSERT_EQ(4, f.get());
24 }
25 TEST(handler, arguments) {
26 <a name="0"></a>    handler&lt;int, int&gt; h(2, 3);
27     connection c;
28     std::promise&lt;int&gt; p;
29 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>    auto f = p.get_future();
30     h([](int a, int b){
31         return a+b;
32     }, c, p);    
33     ASSERT_EQ(5, f.get());
34 }
35 TEST(handler, make_arguments) {
36     auto h = make_handler(2, 3);
37     connection c;
38     std::promise&lt;int&gt; p;</b></font>
39     auto f = p.get_future();
40     h([](int a, int b){
41         return a+b;
42     }, c, p);
43     ASSERT_EQ(5, f.get());
44 }
45 TEST(handler, unique_ptr) {
46     std::unique_ptr&lt;int&gt; ptr(new int(5));
47     auto h = make_handler(std::move(ptr));
48     connection c;
49     std::promise&lt;int&gt; p;
50     auto f = p.get_future();
51     h([](std::unique_ptr&lt;int&gt; ptr){
52         return *ptr;
53     }, c, p);
54     ASSERT_EQ(5, f.get());
55 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>dispatcher_test.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;eventually/dispatcher.hpp&gt;
2 #include "gtest/gtest.h"
3 using namespace eventually;
4 using namespace std::placeholders;
5 class test_exception : public std::exception
6 {
7 };
8 TEST(dispatcher, process_one) {
9 <a name="0"></a>
10     dispatcher d;
11 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>    auto f = d.dispatch([](int a, int b){
12         return a+b;
13     }, 2, 3);
14     ASSERT_TRUE(f.valid());
15     d.process_one();
16     ASSERT_EQ(5, f.get());
17 }
18 TEST(dispatcher, unique_ptr) {
19     dispatcher d;
20     auto f = d.dispatch([](std::unique_ptr&lt;int&gt; ptr){</b></font>
21         return std::move(ptr);
22     }, std::unique_ptr&lt;int&gt;(new int(5)));
23     ASSERT_TRUE(f.valid());
24     d.process_one();
25     ASSERT_EQ(5, *f.get());
26 }
27 TEST(dispatcher, bind) {
28     dispatcher d;
29     auto func = [](int a, int b, int c){
30         return a+b+c;
31     };
32     auto f = d.dispatch(std::bind(func, _1, _2, 4), 2, 3);
33     ASSERT_TRUE(f.valid());
34     d.process_one();
35     ASSERT_EQ(9, f.get());
36 }
37 TEST(dispatcher, when) {
38     dispatcher d;
39     auto f1 = d.dispatch([](int a, int b){
40         return a+b;
41     }, 2, 3);
42     auto f2 = d.when([](int c){
43         return 2.0f*c ;
44     }, std::move(f1));
45     d.process_one();
46     d.process_one();
47     ASSERT_FLOAT_EQ(10.0f, f2.get());
48 }
49 TEST(dispatcher, when_bind) {
50     dispatcher d;
51     auto func1 = [](int a, int b, int c){
52         return a+b+c;
53     };
54     auto func2 = [](int c, float f){
55         return f*c ;
56     };
57     auto f1 = d.dispatch(std::bind(func1, _1, _2, 4), 2, 3);
58     auto f2 = d.when(std::bind(func2, _1, 2.0f), std::move(f1));
59     d.process_one();
60     d.process_one();
61     ASSERT_FLOAT_EQ(18.0f, f2.get());
62 }
63 TEST(dispatcher, when_combined) {
64     dispatcher d;
65     auto f = d.when([](int c){
66         return 2.0f*c ;
67     }, d.dispatch([](int a, int b){
68         return a+b;
69     }, 2, 3));
70     d.process_one();
71     d.process_one();
72     ASSERT_FLOAT_EQ(10.0f, f.get());
73 }
74 TEST(dispatcher, when_throw) {
75     dispatcher d;
76     bool thrown = false;
77     auto f = d.when([](int c){
78         return 2.0f*c ;
79     }, d.when_throw([&amp;thrown](const std::exception&amp; e){
80         thrown = true;
81     }, d.dispatch([](){
82         throw std::exception();
83         return 0;
84     })));
85     d.process_all();
86     ASSERT_TRUE(thrown);
87     thrown = false;
88     try
89     {
90         f.get();
91     }
92     catch(...)
93     {
94         thrown = true;
95     }
96     ASSERT_TRUE(thrown);
97 }
98 TEST(dispatcher, when_throw_exception) {
99     dispatcher d;
100     bool thrown = false;
101     d.when_throw&lt;test_exception&gt;([&amp;thrown](const test_exception&amp; e){
102         thrown = true;
103     }, d.dispatch([](){
104         throw test_exception();
105         return 0;
106     }));
107     d.process_all();
108     ASSERT_TRUE(thrown);
109     thrown = false;
110     d.when_throw&lt;test_exception&gt;([&amp;thrown](const test_exception&amp; e){
111         thrown = true;
112     }, d.dispatch([](){
113         throw std::exception();
114         return 0;
115     }));
116     d.process_all();
117     ASSERT_FALSE(thrown);    
118 }
119 TEST(dispatcher, when_throw_continue) {
120     dispatcher d;
121     auto f = d.when([](int c){
122         return 2.0f*c ;
123     }, d.when_throw_continue([](const std::exception&amp; e){
124         return 2;
125     }, d.dispatch([](){
126         throw std::exception();
127         return 0;
128     })));
129     d.process_all();
130     ASSERT_FLOAT_EQ(4.0f, f.get());
131 }
132 TEST(dispatcher, when_throw_no_exception) {
133     dispatcher d;
134     auto f = d.when([](int c){
135         return 2.0f*c ;
136     }, d.when_throw([](const std::exception&amp; e){
137         return 2;
138     }, d.dispatch([](){
139         return 3;
140     })));
141     d.process_all();
142     ASSERT_FLOAT_EQ(6.0f, f.get());
143 }
144 TEST(dispatcher, when_all) {
145     dispatcher d;
146     auto f = d.when_all([](int a, float b){
147         return a*b;
148     }, d.dispatch([](int a, int b){
149         return a+b;
150     }, 2, 3), d.dispatch([](float a, float b){
151         return a/b;
152     }, 4.0f, 2.0f));
153     d.process_all();
154     ASSERT_FLOAT_EQ(10.0f, f.get());
155 }
156 TEST(dispatcher, when_all_cancel) {
157     dispatcher d;
158     connection c;
159     auto f = d.when_all(c, [](int a, float b){
160         return a*b;
161     }, d.dispatch([](int a, int b){
162         return a+b;
163     }, 2, 3), d.dispatch([](float a, float b){
164         return a/b;
165     }, 4.0f, 2.0f));
166     c.interrupt();
167     d.process_all();
168     bool threw = false;
169     try
170     {
171         f.get();
172     }
173     catch(const connection_interrupted&amp;)
174     {
175         threw = true;
176     }
177     ASSERT_TRUE(threw);
178 }
179 TEST(dispatcher, when_all_tuple) {
180     dispatcher d;
181     auto f = d.when_all(d.dispatch([](int a, int b){
182         return a+b;
183     }, 2, 3), d.dispatch([](float a, float b){
184         return a/b;
185     }, 4.0f, 2.0f));
186     d.process_all();
187     auto t = f.get();
188     ASSERT_EQ(5, std::get&lt;0&gt;(t));
189     ASSERT_FLOAT_EQ(2.0f, std::get&lt;1&gt;(t));
190 }
191 TEST(dispatcher, when_any) {
192     dispatcher d;
193     auto f = d.when_any([](int a){
194         return a;
195     }, d.dispatch([](int a, int b){
196         return a+b;
197     }, 2, 3), d.dispatch([](int a, int b){
198         return a-b;
199     }, 3, 2));
200     d.process_all();
201     ASSERT_EQ(1, f.get());
202 }
203 TEST(dispatcher, when_any_void) {
204     dispatcher d;
205     bool called = false;
206     auto f = d.when_any([&amp;called](){
207         called = true;
208     }, d.dispatch([](){}), d.dispatch([](){}));
209     d.process_all();
210     ASSERT_TRUE(called);
211 }
212 TEST(dispatcher, when_any_cancel) {
213     dispatcher d;
214     connection c;
215     auto f = d.when_any(c, [](int a){
216         return a;
217     }, d.dispatch([](int a, int b){
218         return a+b;
219     }, 2, 3), d.dispatch([](int a, int b){
220         return a-b;
221     }, 3, 2));
222     c.interrupt();
223     d.process_all();
224     bool threw = false;
225     try
226     {
227         f.get();
228     }
229     catch(const connection_interrupted&amp;)
230     {
231         threw = true;
232     }
233     ASSERT_TRUE(threw);
234 }
235 TEST(dispatcher, when_every) {
236     dispatcher d;
237     std::vector&lt;int&gt; b;
238     auto f = d.when_every([&amp;b](std::vector&lt;int&gt;&amp; a){
239         b.insert(b.end(), a.begin(), a.end());
240         for(auto&amp; i : a)
241         {
242             i += 1;
243         }
244     }, d.dispatch([](int a, int b){
245         return a+b;
246     }, 2, 3), d.dispatch([](int a, int b){
247         return a-b;
248     }, 3, 2));
249     d.process_all();
250     auto c = f.get();
251     ASSERT_EQ(3, b.size());
252     ASSERT_EQ(1, b[0]);    
253     ASSERT_EQ(2, b[1]);
254     ASSERT_EQ(5, b[2]);
255     ASSERT_EQ(2, c.size());
256     ASSERT_EQ(3, c[0]);    
257     ASSERT_EQ(6, c[1]);
258 }
259 TEST(dispatcher, when_every_vector) {
260     dispatcher d;
261     auto f = d.when_every(d.dispatch([](int a, int b){
262         return a+b;
263     }, 2, 3), d.dispatch([](int a, int b){
264         return a-b;
265     }, 3, 2));
266     d.process_all();
267     auto t = f.get();
268     ASSERT_EQ(2, t.size());
269     ASSERT_EQ(1, t[0]);    
270     ASSERT_EQ(5, t[1]);
271 }
272 TEST(dispatcher, when_every_cancel) {
273     dispatcher d;
274     connection c;
275     auto f = d.when_every(c, [](const std::vector&lt;int&gt;&amp; a){
276     }, d.dispatch([](int a, int b){
277         return a+b;
278     }, 2, 3), d.dispatch([](int a, int b){
279         return a-b;
280     }, 3, 2));
281     c.interrupt();
282     d.process_all();    
283     auto t = f.get();
284     ASSERT_EQ(0, t.size());
285 }
286 TEST(dispatcher, connection) {
287     dispatcher d;
288     connection c;
289     bool done = false;
290     d.dispatch(c, [&amp;done](){
291         done = true;
292     });
293     c.interrupt();
294     d.process_all();
295     ASSERT_FALSE(done);
296 }
297 TEST(dispatcher, connection_interrupted_exception) {
298     dispatcher d;
299     connection c;
300     bool done = false;
301     auto f = d.dispatch(c, [&amp;done](){
302         done = true;
303     });
304     c.interrupt();
305     d.process_all();
306     bool interrupted = false;
307     try
308     {
309         f.get();
310     }
311     catch(connection_interrupted&amp;)
312     {
313         interrupted = true;
314     }
315     ASSERT_TRUE(interrupted);
316 }
317 TEST(dispatcher, process_all) {
318     dispatcher d;
319     auto f1 = d.dispatch([](int a, int b){
320         return a+b;
321     }, 2, 3);
322     auto f2 = d.dispatch([](int a, int b){
323         return a-b;
324     }, 2, 3);
325     ASSERT_TRUE(f1.valid());
326     ASSERT_TRUE(f2.valid());
327     d.process_all();
328     ASSERT_EQ(5, f1.get());
329     ASSERT_EQ(-1, f2.get());
330 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
