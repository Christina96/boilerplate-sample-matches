<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for handler_test.cpp & dispatcher_test.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for handler_test.cpp & dispatcher_test.cpp
      </h3>
      <h1 align="center">
        5.5%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>handler_test.cpp (20.3125%)<TH>dispatcher_test.cpp (3.233831%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match20-0.html#0',2,'match20-1.html#0',3)" NAME="0">(42-55)<TD><A HREF="javascript:ZweiFrames('match20-0.html#0',2,'match20-1.html#0',3)" NAME="0">(15-30)</A><TD ALIGN=center><FONT COLOR="#ff0000">13</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>handler_test.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>

#include &lt;eventually/handler.hpp&gt;
#include &lt;future&gt;
#include &quot;gtest/gtest.h&quot;

using namespace eventually;


TEST(handler, basic) {

    handler&lt;&gt; h;
    connection c;
    std::promise&lt;int&gt; p;
    auto f = p.get_future();

    h([](){
        return 4;
    }, c, p);

    ASSERT_EQ(4, f.get());
}

TEST(handler, make) {

    auto h = make_handler();
    connection c;
    std::promise&lt;int&gt; p;
    auto f = p.get_future();    

    h([](){
        return 4;
    }, c, p);

    ASSERT_EQ(4, f.get());
}

TEST(handler, arguments) {

<A NAME="0"></A>    handler&lt;int, int&gt; h(2, 3);
    connection c;
    std::promise&lt;int&gt; p;
<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match20-1.html#0',3,'match20-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>    auto f = p.get_future();

    h([](int a, int b){
        return a+b;
    }, c, p);    

    ASSERT_EQ(5, f.get());
}

TEST(handler, make_arguments) {

    auto h = make_handler(2, 3);
    connection c;
    std::promise&lt;int&gt; p;</B></FONT>
    auto f = p.get_future();

    h([](int a, int b){
        return a+b;
    }, c, p);

    ASSERT_EQ(5, f.get());
}

TEST(handler, unique_ptr) {

    std::unique_ptr&lt;int&gt; ptr(new int(5));
    auto h = make_handler(std::move(ptr));
    connection c;
    std::promise&lt;int&gt; p;
    auto f = p.get_future();

    h([](std::unique_ptr&lt;int&gt; ptr){
        return *ptr;
    }, c, p);

    ASSERT_EQ(5, f.get());
}
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>dispatcher_test.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
#include &lt;eventually/dispatcher.hpp&gt;
#include &quot;gtest/gtest.h&quot;

using namespace eventually;
using namespace std::placeholders;

class test_exception : public std::exception
{
};

TEST(dispatcher, process_one) {
<A NAME="0"></A>
    dispatcher d;

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match20-0.html#0',2,'match20-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    auto f = d.dispatch([](int a, int b){
        return a+b;
    }, 2, 3);

    ASSERT_TRUE(f.valid());

    d.process_one();

    ASSERT_EQ(5, f.get());
}

TEST(dispatcher, unique_ptr) {

    dispatcher d;

    auto f = d.dispatch([](std::unique_ptr&lt;int&gt; ptr){</B></FONT>
        return std::move(ptr);
    }, std::unique_ptr&lt;int&gt;(new int(5)));

    ASSERT_TRUE(f.valid());

    d.process_one();

    ASSERT_EQ(5, *f.get());
}


TEST(dispatcher, bind) {

    dispatcher d;

    auto func = [](int a, int b, int c){
        return a+b+c;
    };

    auto f = d.dispatch(std::bind(func, _1, _2, 4), 2, 3);

    ASSERT_TRUE(f.valid());

    d.process_one();

    ASSERT_EQ(9, f.get());
}

TEST(dispatcher, when) {

    dispatcher d;

    auto f1 = d.dispatch([](int a, int b){
        return a+b;
    }, 2, 3);

    auto f2 = d.when([](int c){
        return 2.0f*c ;
    }, std::move(f1));

    d.process_one();
    d.process_one();

    ASSERT_FLOAT_EQ(10.0f, f2.get());
}

TEST(dispatcher, when_bind) {

    dispatcher d;

    auto func1 = [](int a, int b, int c){
        return a+b+c;
    };

    auto func2 = [](int c, float f){
        return f*c ;
    };

    auto f1 = d.dispatch(std::bind(func1, _1, _2, 4), 2, 3);
    auto f2 = d.when(std::bind(func2, _1, 2.0f), std::move(f1));

    d.process_one();
    d.process_one();

    ASSERT_FLOAT_EQ(18.0f, f2.get());
}


TEST(dispatcher, when_combined) {

    dispatcher d;

    auto f = d.when([](int c){
        return 2.0f*c ;
    }, d.dispatch([](int a, int b){
        return a+b;
    }, 2, 3));

    d.process_one();
    d.process_one();

    ASSERT_FLOAT_EQ(10.0f, f.get());
}

TEST(dispatcher, when_throw) {

    dispatcher d;
    bool thrown = false;

    auto f = d.when([](int c){
        return 2.0f*c ;
    }, d.when_throw([&amp;thrown](const std::exception&amp; e){
        thrown = true;
    }, d.dispatch([](){
        throw std::exception();
        return 0;
    })));

    d.process_all();

    ASSERT_TRUE(thrown);

    thrown = false;
    try
    {
        f.get();
    }
    catch(...)
    {
        thrown = true;
    }

    ASSERT_TRUE(thrown);
}

TEST(dispatcher, when_throw_exception) {

    dispatcher d;
    bool thrown = false;
    d.when_throw&lt;test_exception&gt;([&amp;thrown](const test_exception&amp; e){
        thrown = true;
    }, d.dispatch([](){
        throw test_exception();
        return 0;
    }));
    d.process_all();

    ASSERT_TRUE(thrown);

    thrown = false;
    d.when_throw&lt;test_exception&gt;([&amp;thrown](const test_exception&amp; e){
        thrown = true;
    }, d.dispatch([](){
        throw std::exception();
        return 0;
    }));
    d.process_all();

    ASSERT_FALSE(thrown);    
}


TEST(dispatcher, when_throw_continue) {

    dispatcher d;

    auto f = d.when([](int c){
        return 2.0f*c ;
    }, d.when_throw_continue([](const std::exception&amp; e){
        return 2;
    }, d.dispatch([](){
        throw std::exception();
        return 0;
    })));

    d.process_all();
    
    ASSERT_FLOAT_EQ(4.0f, f.get());
}

TEST(dispatcher, when_throw_no_exception) {

    dispatcher d;

    auto f = d.when([](int c){
        return 2.0f*c ;
    }, d.when_throw([](const std::exception&amp; e){
        return 2;
    }, d.dispatch([](){
        return 3;
    })));

    d.process_all();
    
    ASSERT_FLOAT_EQ(6.0f, f.get());
}

TEST(dispatcher, when_all) {

    dispatcher d;

    auto f = d.when_all([](int a, float b){
        return a*b;
    }, d.dispatch([](int a, int b){
        return a+b;
    }, 2, 3), d.dispatch([](float a, float b){
        return a/b;
    }, 4.0f, 2.0f));

    d.process_all();

    ASSERT_FLOAT_EQ(10.0f, f.get());
}

TEST(dispatcher, when_all_cancel) {

    dispatcher d;
    connection c;

    auto f = d.when_all(c, [](int a, float b){
        return a*b;
    }, d.dispatch([](int a, int b){
        return a+b;
    }, 2, 3), d.dispatch([](float a, float b){
        return a/b;
    }, 4.0f, 2.0f));

    c.interrupt();
    d.process_all();

    bool threw = false;
    try
    {
        f.get();
    }
    catch(const connection_interrupted&amp;)
    {
        threw = true;
    }

    ASSERT_TRUE(threw);
}


TEST(dispatcher, when_all_tuple) {

    dispatcher d;

    auto f = d.when_all(d.dispatch([](int a, int b){
        return a+b;
    }, 2, 3), d.dispatch([](float a, float b){
        return a/b;
    }, 4.0f, 2.0f));

    d.process_all();

    auto t = f.get();

    ASSERT_EQ(5, std::get&lt;0&gt;(t));
    ASSERT_FLOAT_EQ(2.0f, std::get&lt;1&gt;(t));
}

TEST(dispatcher, when_any) {

    dispatcher d;

    auto f = d.when_any([](int a){
        return a;
    }, d.dispatch([](int a, int b){
        return a+b;
    }, 2, 3), d.dispatch([](int a, int b){
        return a-b;
    }, 3, 2));

    d.process_all();

    ASSERT_EQ(1, f.get());
}

TEST(dispatcher, when_any_void) {

    dispatcher d;
    bool called = false;
    auto f = d.when_any([&amp;called](){
        called = true;
    }, d.dispatch([](){}), d.dispatch([](){}));

    d.process_all();

    ASSERT_TRUE(called);
}

TEST(dispatcher, when_any_cancel) {

    dispatcher d;
    connection c;

    auto f = d.when_any(c, [](int a){
        return a;
    }, d.dispatch([](int a, int b){
        return a+b;
    }, 2, 3), d.dispatch([](int a, int b){
        return a-b;
    }, 3, 2));

    c.interrupt();

    d.process_all();

    bool threw = false;
    try
    {
        f.get();
    }
    catch(const connection_interrupted&amp;)
    {
        threw = true;
    }

    ASSERT_TRUE(threw);
}

TEST(dispatcher, when_every) {

    dispatcher d;

    std::vector&lt;int&gt; b;
    auto f = d.when_every([&amp;b](std::vector&lt;int&gt;&amp; a){
        b.insert(b.end(), a.begin(), a.end());
        for(auto&amp; i : a)
        {
            i += 1;
        }
    }, d.dispatch([](int a, int b){
        return a+b;
    }, 2, 3), d.dispatch([](int a, int b){
        return a-b;
    }, 3, 2));

    d.process_all();
    auto c = f.get();

    ASSERT_EQ(3, b.size());
    ASSERT_EQ(1, b[0]);    
    ASSERT_EQ(2, b[1]);
    ASSERT_EQ(5, b[2]);
    ASSERT_EQ(2, c.size());
    ASSERT_EQ(3, c[0]);    
    ASSERT_EQ(6, c[1]);
}

TEST(dispatcher, when_every_vector) {

    dispatcher d;

    auto f = d.when_every(d.dispatch([](int a, int b){
        return a+b;
    }, 2, 3), d.dispatch([](int a, int b){
        return a-b;
    }, 3, 2));

    d.process_all();
    auto t = f.get();

    ASSERT_EQ(2, t.size());
    ASSERT_EQ(1, t[0]);    
    ASSERT_EQ(5, t[1]);
}

TEST(dispatcher, when_every_cancel) {

    dispatcher d;
    connection c;

    auto f = d.when_every(c, [](const std::vector&lt;int&gt;&amp; a){
    }, d.dispatch([](int a, int b){
        return a+b;
    }, 2, 3), d.dispatch([](int a, int b){
        return a-b;
    }, 3, 2));

    c.interrupt();
    d.process_all();    
    auto t = f.get();

    ASSERT_EQ(0, t.size());
}


TEST(dispatcher, connection) {

    dispatcher d;
    connection c;

    bool done = false;
    d.dispatch(c, [&amp;done](){
        done = true;
    });

    c.interrupt();

    d.process_all();

    ASSERT_FALSE(done);
}

TEST(dispatcher, connection_interrupted_exception) {

    dispatcher d;
    connection c;

    bool done = false;
    auto f = d.dispatch(c, [&amp;done](){
        done = true;
    });

    c.interrupt();

    d.process_all();

    bool interrupted = false;
    try
    {
        f.get();
    }
    catch(connection_interrupted&amp;)
    {
        interrupted = true;
    }

    ASSERT_TRUE(interrupted);
}

TEST(dispatcher, process_all) {

    dispatcher d;

    auto f1 = d.dispatch([](int a, int b){
        return a+b;
    }, 2, 3);

    auto f2 = d.dispatch([](int a, int b){
        return a-b;
    }, 2, 3);

    ASSERT_TRUE(f1.valid());
    ASSERT_TRUE(f2.valid());

    d.process_all();

    ASSERT_EQ(5, f1.get());
    ASSERT_EQ(-1, f2.get());
}
</PRE>
</div>
  </div>
</body>
</html>
