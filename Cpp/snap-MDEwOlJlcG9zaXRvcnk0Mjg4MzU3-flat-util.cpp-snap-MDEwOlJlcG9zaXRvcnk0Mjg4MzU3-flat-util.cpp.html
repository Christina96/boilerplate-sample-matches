
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 51, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-util.cpp</h3>
            <pre><code>1  void TGUtil::GetCdf(const TIntPrV& PdfV, TIntPrV& CdfV) {
2    CdfV = PdfV;
3    for (int i = 1; i < CdfV.Len(); i++) {
4      CdfV[i].Val2 = CdfV[i-1].Val2 + CdfV[i].Val2; }
5  }
6  void TGUtil::GetCdf(const TFltPrV& PdfV, TFltPrV& CdfV) {
7    CdfV = PdfV;
8    for (int i = 1; i < CdfV.Len(); i++) {
9      CdfV[i].Val2 = CdfV[i-1].Val2 + CdfV[i].Val2; }
10  }
11  void TGUtil::GetCdf(const TIntFltKdV& PdfV, TIntFltKdV& CdfV) {
12    CdfV = PdfV;
13    for (int i = 1; i < CdfV.Len(); i++) {
14      CdfV[i].Dat = CdfV[i-1].Dat + CdfV[i].Dat; }
15  }
16  TIntPrV TGUtil::GetCdf(const TIntPrV& PdfV) {
17    TIntPrV CdfV;
18    GetCdf(PdfV, CdfV);
19    return CdfV;
20  }
21  TFltPrV TGUtil::GetCdf(const TFltPrV& PdfV) {
22    TFltPrV CdfV;
23    GetCdf(PdfV, CdfV);
24    return CdfV;
25  }
26  void TGUtil::GetCCdf(const TIntPrV& PdfV, TIntPrV& CCdfV) {
27    CCdfV = PdfV;
28    for (int i = CCdfV.Len()-2; i >= 0; i--) {
29      CCdfV[i].Val2 = CCdfV[i+1].Val2 + CCdfV[i].Val2; }
30  }
31  void TGUtil::GetCCdf(const TFltPrV& PdfV, TFltPrV& CCdfV) {
32    CCdfV = PdfV;
33    for (int i = CCdfV.Len()-2; i >= 0; i--) {
34      CCdfV[i].Val2 = CCdfV[i+1].Val2 + CCdfV[i].Val2; }
35  }
36  void TGUtil::GetCCdf(const TIntFltKdV& PdfV, TIntFltKdV& CCdfV) {
37    CCdfV = PdfV;
38    for (int i = CCdfV.Len()-2; i >= 0; i--) {
39      CCdfV[i].Dat = CCdfV[i+1].Dat + CCdfV[i].Dat; }
40  }
41  TIntPrV TGUtil::GetCCdf(const TIntPrV& PdfV) {
42    TIntPrV CCdfV;
43    GetCCdf(PdfV, CCdfV);
44    return CCdfV;
45  }
46  TFltPrV TGUtil::GetCCdf(const TFltPrV& PdfV) {
47    TFltPrV CCdfV;
48    GetCCdf(PdfV, CCdfV);
49    return CCdfV;
50  }
51  void TGUtil::GetPdf(const TIntPrV& CdfV, TIntPrV& PdfV) {
52    PdfV = CdfV;
53    for (int i = PdfV.Len()-1; i > 0; i--) {
54      PdfV[i].Val2 = PdfV[i].Val2 - PdfV[i-1].Val2; }
55  }
56  void TGUtil::GetPdf(const TFltPrV& CdfV, TFltPrV& PdfV) {
57    PdfV = CdfV;
58    for (int i = PdfV.Len()-1; i > 0; i--) {
59      PdfV[i].Val2 = PdfV[i].Val2 - PdfV[i-1].Val2; }
60  }
61  void TGUtil::GetPdf(const TIntFltKdV& CdfV, TIntFltKdV& PdfV) {
62    PdfV = CdfV;
63    for (int i = PdfV.Len()-1; i > 0; i--) {
64      PdfV[i].Dat = PdfV[i].Dat - PdfV[i-1].Dat; }
65  }
66  void TGUtil::Normalize(TFltPrV& PdfV) {
67    double Sum = 0.0;
68    for (int i = 0; i < PdfV.Len(); i++) {
69      Sum += PdfV[i].Val2; }
70    if (Sum <= 0.0) { return; }
71    for (int i = 0; i < PdfV.Len(); i++) {
72      PdfV[i].Val2 /= Sum; }
73  }
74  void TGUtil::Normalize(TIntFltKdV& PdfV) {
75    double Sum = 0.0;
76    for (int i = 0; i < PdfV.Len(); i++) {
77      Sum += PdfV[i].Dat; }
78    if (Sum <= 0.0) { return; }
79    for (int i = 0; i < PdfV.Len(); i++) {
80      PdfV[i].Dat /= Sum; }
81  }
82  void TGUtil::MakeExpBins(const TFltPrV& XYValV, TFltPrV& ExpXYValV, const double& BinFactor, const double& MinYVal) {
83    TGnuPlot::MakeExpBins(XYValV, ExpXYValV, BinFactor, MinYVal);
84  }
85  void TGUtil::MakeExpBins(const TFltKdV& XYValV, TFltKdV& ExpXYValV, const double& BinFactor, const double& MinYVal) {
86    TGnuPlot::MakeExpBins(XYValV, ExpXYValV, BinFactor, MinYVal);
87  }
88  void TGUtil::MakeExpBins(const TFltV& YValV, TFltV& ExpYValV, const double& BinFactor) {
89    ExpYValV.Clr(true);
90    int prevI=0;
91    for (int i = 0; i < YValV.Len(); ) {
92      ExpYValV.Add(YValV[i]);
93      i = int(i*BinFactor);
94      if (i==prevI) { i++; }
95      prevI = i;
96    }
97  }
98  void TGUtil::MakeExpBins(const TIntV& YValV, TIntV& ExpYValV, const double& BinFactor) {
99    ExpYValV.Clr(true);
100    int prevI=0;
101    for (int i = 0; i < YValV.Len(); ) {
102      ExpYValV.Add(YValV[i]);
103      i = int(i*BinFactor);
104      if (i==prevI) { i++; }
105      prevI = i;
106    }
107  }
108  TChA& TStrUtil::GetXmlTagVal(TXmlLx& XmlLx, const TChA& TagNm) {
109    static TChA TagVal;
110    EAssertR(XmlLx.GetSym() == xsySTag, TagNm);
111    EAssertR(TagNm == XmlLx.TagNm.CStr(), TagNm);
112    const TXmlLxSym NextSym = XmlLx.GetSym();
113    TagVal = XmlLx.TxtChA;
114    if (NextSym == xsyStr) {
115      EAssertR(XmlLx.GetSym() == xsyETag, TagNm);
116    } else {
117      EAssertR(NextSym == xsyETag, TagNm); 
118    }
119    EAssertR(XmlLx.TagNm == TagNm, TagNm);
120    return TagVal;
121  }
122  void TStrUtil::GetXmlTagNmVal(TXmlLx& XmlLx, TChA& TagNm, TChA& TagVal) {
123    EAssertR(XmlLx.GetSym() == xsySTag, TagNm);
124    TagNm = XmlLx.TagNm;
125    const TXmlLxSym NextSym = XmlLx.GetSym();
126    TagVal = XmlLx.TxtChA;
127    if (NextSym == xsyStr) {
128      EAssertR(XmlLx.GetSym() == xsyETag, TagNm);
129    } else {
130      EAssertR(NextSym == xsyETag, TagNm); 
131    }
132  }
133  bool TStrUtil::GetXmlTagNmVal2(TXmlLx& XmlLx, TChA& TagNm, TChA& TagVal, const bool& TakeTagNms) {
134    if (XmlLx.GetSym() != xsySTag) {
135      return false; }
136    TagVal.Clr();
137    TagNm = XmlLx.TagNm;
138    while (XmlLx.Sym != xsyETag || XmlLx.TagNm != TagNm.CStr()) {
139      if (TakeTagNms) {
140        TagVal += XmlLx.TxtChA; }
141      else if (XmlLx.Sym == xsyStr) {
142        TagVal += XmlLx.TxtChA; }
143      XmlLx.GetSym();
144    }
145    return true;
146  }
147  TChA TStrUtil::GetDomNm(const TChA& UrlChA) {
148    int EndSlash = UrlChA.SearchCh('/', 7)-1; 
149    if (EndSlash > 0) {
150      const int BegSlash = UrlChA.SearchChBack('/', EndSlash);
151      if (BegSlash > 0) { return UrlChA.GetSubStr(BegSlash+1, EndSlash).ToLc(); }
152      else { return UrlChA.GetSubStr(0, UrlChA.SearchCh('/', 0)-1).ToLc(); }
153    } else {
154      if (UrlChA.IsPrefix("http:&bsol;&bsol;")) { return UrlChA.GetSubStr(7, UrlChA.Len()-1).ToLc(); }
155      EndSlash = UrlChA.SearchCh('/', 0);
156      if (EndSlash > 0) { return UrlChA.GetSubStr(0, EndSlash-1).ToLc(); }
157      else { return TChA(UrlChA).ToLc(); }
158    }
159  }
160  TChA TStrUtil::GetDomNm2(const TChA& UrlChA) {
161    TChA Dom = GetDomNm(UrlChA);
162    if (Dom.IsPrefix("www.")) { return Dom.GetSubStr(4, TInt::Mx); }
163    else { return Dom; }
164  }
165  int GetNthOccurence(const TChA& Url, const int& Count, const char Ch='/') {
166    const char *c = Url.CStr();
167    int cnt = 0;
168    while (*c && cnt != Count) {
169      if (*c == Ch) { cnt++; }
170      c++;
171    }
172    return int(c-Url.CStr()-1);
173  }
174  TChA TStrUtil::GetWebsiteNm(const TChA& PostUrlStr) {
175    TChA DomNm = TStrUtil::GetDomNm2(PostUrlStr);
176    if (DomNm == "blog.myspace.com") {
177      return PostUrlStr.GetSubStr(7, GetNthOccurence(PostUrlStr, 2, '&')-1);
178    }
179    if (DomNm=="blogs.msdn.com" || DomNm=="ameblo.jp" || DomNm=="xfruits.com" || DomNm=="scienceblogs.com" || DomNm=="blogs.sun.com"
180      || DomNm=="blog.wired.com" || DomNm=="weblogs.asp.net" || DomNm=="blogs.technet.com" || DomNm=="blogs.guardian.co"
181      || DomNm=="blogs.clarin.com" || DomNm=="blogs.sun.com" || DomNm=="blog.wired.com" || DomNm=="weblogs.asp.net"
182      || DomNm=="blogs.technet.com" || DomNm=="blogs.guardian.com" || DomNm=="blogs.clarin.com" || DomNm=="blogs.zdnet.com"
183      || DomNm=="blogs.citypages.com" || DomNm=="voices.washingtonpost.com" || DomNm=="blog.tv2.dk"
184      || DomNm=="blogs.menomoneefallsnow.com" || DomNm=="weblogs.baltimoresun.com" || DomNm=="eonline.com") {
185        return PostUrlStr.GetSubStr(7, GetNthOccurence(PostUrlStr, 4)-1);
186    }
187    if (DomNm == "digg.com") {
188      if (PostUrlStr.IsPrefix("http:&bsol;&bsol;digg.com/submit?")) {
189        const int Url = PostUrlStr.SearchStr(";url=");
190        if (Url != -1) {
191          return GetWebsiteNm(PostUrlStr.GetSubStr(Url+5, PostUrlStr.SearchCh('&', Url+5))); }
192      } else {
193        return PostUrlStr.GetSubStr(7, GetNthOccurence(PostUrlStr, 4)-1); }
194    }
195    if (PostUrlStr.IsPrefix("http:&bsol;&bsol;nydailynews.com/blogs/") || PostUrlStr.IsPrefix("http:&bsol;&bsol;bbc.co.uk/blogs/")
196      || PostUrlStr.IsPrefix("http:&bsol;&bsol;nydailynews.com/blogs/") || PostUrlStr.IsPrefix("http:&bsol;&bsol;newsbusters.org/blogs/")) {
197      return PostUrlStr.GetSubStr(7, GetNthOccurence(PostUrlStr, 5)-1);
198    }
199    if (DomNm=="feeds.feedburner.com") {
200      return PostUrlStr.GetSubStr(7, GetNthOccurence(PostUrlStr, 5)-1);
201    }
202    if (DomNm=="groups.google.com") {
203      return PostUrlStr.GetSubStr(7, GetNthOccurence(PostUrlStr, 5)-1);
204    }
205    if (DomNm=="news.google.com") { 
206      const int UrlPos = PostUrlStr.SearchStr("&url=");
207      if (UrlPos != -1) {
208        return GetWebsiteNm(PostUrlStr.GetSubStr(UrlPos+5, PostUrlStr.SearchCh('&', UrlPos+5))); }
209    }
210    if (DomNm == "bloggrevyen.no") { 
211      const int Http2 = PostUrlStr.SearchStr("/http:&bsol;&bsol;");
212      if (Http2!=-1) {
213        return GetWebsiteNm(PostUrlStr.GetSubStr(Http2+1, PostUrlStr.Len()-1)); }
214    }
215    if (DomNm.IsSuffix(".rd.yahoo.com")) {
216      const int Http2 = PostUrlStr.SearchStr("&bsol;*");
217      if (Http2!=-1) {
218        return GetWebsiteNm(PostUrlStr.GetSubStr(Http2+9, PostUrlStr.Len()-1)); }
219    }
220    return DomNm;
221  }
222  bool TStrUtil::GetNormalizedUrl(const TChA& UrlIn, const TChA& BaseUrl, TChA& UrlOut) {
223    UrlOut = UrlIn;
224    if (StripEnd(UrlIn, "/", UrlOut)) {}
225    else if (StripEnd(UrlIn, "/index.html", UrlOut)) {}
226    else if (StripEnd(UrlIn, "/index.htm", UrlOut)) {}
227    else if (StripEnd(UrlIn, "/index.php", UrlOut)) {}
228    if (! (UrlOut.IsPrefix("http:&bsol;&bsol;") || UrlOut.IsPrefix("ftp:&bsol;&bsol;"))) {
229      if (UrlIn.Empty() || ! (BaseUrl.IsPrefix("http:&bsol;&bsol;") || BaseUrl.IsPrefix("ftp:&bsol;&bsol;"))) {
230        return false; }
231      TChA Out;
232      if (! GetNormalizedUrl(BaseUrl, TChA(), Out)) { return false; }
233      if (UrlIn[0] != '/') { Out.AddCh('/'); }
234      Out += UrlOut;
235      UrlOut = Out;
236    }
237    if (UrlOut.IsPrefix("http:&bsol;&bsol;www.")) {
238      UrlOut = TChA("http:&bsol;&bsol;") + UrlOut.GetSubStr(11, TInt::Mx);
239    }
240    UrlOut.ToLc();
241    return true;
242  }
243  bool TStrUtil::StripEnd(const TChA& Str, const TChA& SearchStr, TChA& NewStr) {
244    const int StrLen = Str.Len();
245    const int SearchStrLen = SearchStr.Len();
246    if (StrLen < SearchStrLen) { return false; }
247    for (int i = 0; i < SearchStrLen; i++) {
248      if (Str[StrLen-i-1] != SearchStr[SearchStrLen-i-1]) { return false; }
249    }
250    NewStr = Str.GetSubStr(0, StrLen-SearchStrLen-1);
251    return true;
252  }
253  TChA TStrUtil::GetShorStr(const TChA& LongStr, const int MaxLen) {
254    if (LongStr.Len() < MaxLen) { return LongStr; }
255    TChA Str = LongStr.GetSubStr(0, MaxLen-1);
256    Str += "...";
257    return Str;
258  }
259  TChA TStrUtil::GetCleanWrdStr(const TChA& ChA) {
260    char *b = (char *) ChA.CStr();
261    while (*b && ! TCh::IsAlNum(*b)) { b++; }
262    if (*b == 0) { return TChA(); }
263    TChA OutChA(ChA.Len());
264    char *e = b, tmp;
265    while (*e) {
266      b = e;
267      while (*e && (TCh::IsAlNum(*e) || ((*e=='\'' || *e=='-') && TCh::IsAlNum(*(e+1))))) { e++; }
268      if (b < e) {
269        tmp = *e; *e=0;
270        OutChA += b;  OutChA.AddCh(' ');
271        *e = tmp;
272      }
273      while (*e && ! TCh::IsAlNum(*e)) { e++; }
274      if (! *e) { break; }
275    }
276    OutChA.DelLastCh();  OutChA.ToLc();
277    return OutChA;
278  }
279  TChA TStrUtil::GetCleanStr(const TChA& ChA) {
280    char *b = (char *) ChA.CStr();
281    while (*b && ! TCh::IsAlNum(*b)) { b++; }
282    if (*b == 0) { return TChA(); }
283    TChA OutChA(ChA.Len());
284    char *e = b;
285    bool ws=false;
286    while (*e) {
287      while (*e && TCh::IsWs(*e)) { e++; ws=true; }
288      if (! *e) { break; }
289      if (ws) { OutChA.AddCh(' '); ws=false; }
290      OutChA.AddCh(*e);
291      e++;
292    }
293    return OutChA;
294  }
295  int TStrUtil::CountWords(const TChA& ChA) {
296    return CountWords(ChA.CStr());
297  }
298  int TStrUtil::CountWords(const char* CStr) {
299    int WrdCnt = 1;
300    for (const char *c = CStr; *c; c++) {
301      if (TCh::IsWs(*c)) { WrdCnt++; }
302    }
303    return WrdCnt;
304  }
305  int TStrUtil::CountWords(const TChA& ChA, const TStrHash<TInt>& StopWordH) {
306    TChA Tmp;
307    TVec<char *> WrdV;
308    SplitWords(Tmp, WrdV);
309    int SWordCnt = 0;
310    for (int w = 0; w < WrdV.Len(); w++) {
311      if (StopWordH.IsKey(WrdV[w])) { SWordCnt++; }
312    }
313    return WrdV.Len() - SWordCnt;
314  }
315  int TStrUtil::SplitWords(TChA& ChA, TVec<char *>& WrdV, const bool& SplitOnWs) {
316    WrdV.Clr(false);
317    WrdV.Add(ChA.CStr());
318    for (char *c = (char *) ChA.CStr(); *c; c++) {
319      if ((SplitOnWs && *c == ' ') || (! SplitOnWs && ! TCh::IsAlNum(*c))) {
320        *c = 0;
321        if (! WrdV.Empty() && strlen(WrdV.Last()) == 0) { WrdV.DelLast(); }
322        WrdV.Add(c+1);
323      }
324    }
325    return WrdV.Len();
326  }
327  int TStrUtil::SplitOnCh(TChA& ChA, TVec<char *>& WrdV, const char& Ch, const bool& SkipEmpty) {
328    WrdV.Clr(false);
329    WrdV.Add(ChA.CStr());
330    for (char *c = (char *) ChA.CStr(); *c; c++) {
331      if (*c == Ch) {
332        *c = 0;
333        if (SkipEmpty && ! WrdV.Empty() && strlen(WrdV.Last()) == 0) { WrdV.DelLast(); }
334        WrdV.Add(c+1);
335      }
336    }
337    if (SkipEmpty && ! WrdV.Empty() && strlen(WrdV.Last()) == 0) { WrdV.DelLast(); }
338    return WrdV.Len();
339  }
340  int TStrUtil::SplitLines(TChA& ChA, TVec<char *>& LineV, const bool& SkipEmpty) {
341    LineV.Clr(false);
342    LineV.Add(ChA.CStr());
343    bool IsChs=false;
344    for (char *c = (char *) ChA.CStr(); *c; c++) {
345      if (*c == '\n') {
346        if (c > ChA.CStr() && *(c-1)=='\r') { *(c-1)=0; } 
347        *c=0;
348        if (SkipEmpty) {
349          if (IsChs) { LineV.Add(c+1); }
350        } else {
351          LineV.Add(c+1);
352        }
353        IsChs=false;
354      } else {
355        IsChs=true;
356      }
357    }
358    return LineV.Len();
359  }
360  int TStrUtil::SplitSentences(TChA& ChA, TVec<char *>& SentenceV) {
361    SentenceV.Clr();
362    const char *B = ChA.CStr();
363    const char *E = B+ChA.Len();
364    char *c = (char *) B;
365    while (*c && TCh::IsWs(*c)) { c++; }
366    if (*c) { SentenceV.Add(c); } else { return 0; }
367    for (; c < E; c++) {
368      if (c<E && (*c == '.' || *c == '!' || *c == '?') && ! TCh::IsAlNum(*(c+1))) { 
369        if (c<E && *(c+1)=='"') { *c='"';  c++; } 
370        if (c>=E) { continue; }
371        *c=0;  c++;
372        char *e = c-1;
373        while (e>B && *e!='"' && ! TCh::IsAlNum(*e)) { *e=0; e--; } 
374        while (c<E && ! (TCh::IsAlNum(*c) || (*c=='"' && TCh::IsAlNum(*(c+1))))) { c++; } 
375        if (c<E) { SentenceV.Add(c); }
376      }
377    }
378    return SentenceV.Len();
379  }
380  void TStrUtil::RemoveHtmlTags(const TChA& HtmlStr, TChA& TextStr) {
381    TextStr.Clr();
382    char *StrB, *StrE;
383    StrB = (char *) HtmlStr.CStr();
384    StrE = (char *) StrB+HtmlStr.Len(); 
385    for (char *e = StrB; e < StrE; ) {
386      char* b = e;
387      while (e<StrE && *e != '<') { e++; }
388      char tmp=*e;  *e = 0;
389      TextStr+= b; TextStr.AddCh(' ');  *e = tmp;
390      if (e >= StrE) { return; }
391      if (e[1]=='!' && e[2]=='-' && e[3]=='-') { 
392        e += 3;
393        while(e<StrE && !(*(e-2)=='-' && *(e-1)=='-' && *e=='>')) { e++; }
394        e++;  continue;
395      }
396      if (e[1]=='s' && e[2]=='c' && e[3]=='r' && e[4]=='i' && e[5]=='p' && e[6]=='t') {
397        e += 5;
398        while(e<StrE && !(*(e-6)=='s' && *(e-5)=='c' && *(e-4)=='r' && *(e-3)=='i' && *(e-2)=='p' && *(e-1)=='t' && *e=='>')) { e++; }
399        e++;  continue;
400      }
401      while (e < StrE && *e != '>') { e++; }
402      if (e>=StrE) { return; }
403      e++;
404    }
405  }
406  bool TStrUtil::IsLatinStr(const TChA& Str, const double& MinAlFrac) {
407    int AlNumCnt=0, ChCnt=0;
408    for (const char *c = Str.CStr(); *c; c++) {
409      if (TCh::IsWs(*c)) { continue; }
410      if (*c > 0 && TCh::IsAlNum(*c)) { AlNumCnt++; }
411      ChCnt++;
412    }
413    if (double(AlNumCnt)/double(ChCnt) > MinAlFrac) { return true; }
414    return false;
415  }
416  void TStrUtil::GetWIdV(const TStrHash<TInt>& StrH, const char *CStr, TIntV& WIdV) {
417    const int NotWId = -1;
<span onclick='openModal()' class='match'>418    TChA ChA(CStr);
419    TVec<char *> WrdV;
420    TInt WId;
421    TStrUtil::SplitWords(ChA, WrdV);
422    WIdV.Clr(false);
423    for (int w = 0; w < WrdV.Len(); w++) {
424      if (StrH.IsKeyGetDat(WrdV[w], WId)) { WIdV.Add(WId); }
</span>425      else { WIdV.Add(NotWId); }
426    }
427  }
428  void TStrUtil::GetAddWIdV(TStrHash<TInt>& StrH, const char *CStr, TIntV& WIdV) {
429    TChA ChA(CStr);
430    TVec<char *> WrdV;
431    TInt WId;
432    TStrUtil::SplitWords(ChA, WrdV);
433    WIdV.Clr(false);
434    for (int w = 0; w < WrdV.Len(); w++) {
435      WIdV.Add(StrH.AddDatId(WrdV[w]));
436    }
437  }
438  bool TStrUtil::GetTmFromStr(const char* TmStr, TSecTm& Tm) {
439    static TStrV MonthV1, MonthV2;
440    if (MonthV1.Empty()) {
441      TStr("january|february|march|april|may|june|july|august|september|october|november|december").SplitOnAllCh('|', MonthV1);
442      TStr("jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec").SplitOnAllCh('|', MonthV2);
443    }
444    TChA Tmp(TmStr);
445    Tmp.ToLc();
446    TVec<char *> WrdV;
447    const char* End = Tmp.CStr()+Tmp.Len();
448    int Col = -1, Cols=0;
449    for (char *b = Tmp.CStr(); b <End; ) {
450      WrdV.Add(b);
451      while (*b && ! (*b==' ' || *b=='-' || *b==':' || *b==',')) { b++; }
452      if (*b==':') { if(Col==-1) { Col=WrdV.Len(); } Cols++;  }
453      *b=0; b++;
454      while (*b && (*b==' ' || *b=='-' || *b==':' || *b==',')) { b++; }
455    }
456    if (Cols == 2) {
457      if (Col+1 >= WrdV.Len()) { return false; }
458      WrdV.Del(Col+1);
459    }
460    if (Col<1) { return false; }
461    const int Hr = atoi(WrdV[Col-1]);
462    const int Min = atoi(WrdV[Col]);
463    WrdV.Del(Col);  WrdV.Del(Col-1);
464    if (WrdV.Len() != 3) { return false; }
465    int y=0,m=1,d=2, Mon=-1;
466    if (TCh::IsAlpha(WrdV[0][0])) {
467      y=2; m=0; d=1;
468    } else if (TCh::IsAlpha(WrdV[1][0])) {
469      y=2; m=1; d=0;
470    } else if (TCh::IsAlpha(WrdV[2][0])) {
471      y=0; m=2; d=1;
472    } else {
473      y=0; m=1; d=2;
474      Mon = atoi(WrdV[m]);
475    }
476    int Day = atoi(WrdV[d]);
477    if (Mon <= 0) { Mon = MonthV1.SearchForw(WrdV[m])+1; }
478    if (Mon <= 0) { Mon = MonthV2.SearchForw(WrdV[m])+1; }
479    if (Mon == 0) { return false; }
480    int Year = atoi(WrdV[y]);
481    if (Day > Year) { ::Swap(Day, Year); }
482    Tm = TSecTm(Year, Mon, Day, Hr, Min, 0);
483    return true;
484  }
485  TStr TStrUtil::GetStdName(TStr AuthorName) {
486    TStr StdName;
487    AuthorName.ToLc();
488    AuthorName.ChangeChAll('\n', ' ');
489    AuthorName.ChangeChAll('.', ' ');
490    int i, pos = 0;
491    while (pos<AuthorName.Len() && (AuthorName[pos]!='#' && !TCh::IsNum(AuthorName[pos]))) {
492      pos++; }
493    if (pos < AuthorName.Len()) {
494      AuthorName = AuthorName.GetSubStr(0, pos-1).ToTrunc(); }
495    if (AuthorName.Empty()) { return TStr::GetNullStr(); }
496    int b = AuthorName.SearchCh('(');
497    if (b != -1) {
498      AuthorName = AuthorName.GetSubStr(0, b-1).ToTrunc(); }
499    if (AuthorName .SearchCh(')')!=-1) { return TStr::GetNullStr(); }
500    if (AuthorName .SearchStr("figures")!=-1 || AuthorName .SearchStr("macros")!=-1
501     || AuthorName .SearchStr("univ")!=-1 || AuthorName .SearchStr("institute")!=-1) {
502      return TStr::GetNullStr();
503    }
504    TChA NewName;
505    for (i = 0; i < AuthorName.Len(); i++) {
506      const char Ch = AuthorName[i];
507      if (TCh::IsAlpha(Ch) || TCh::IsWs(Ch) || Ch=='-') { NewName += Ch; }
508    }
509    StdName = NewName;  StdName.ToTrunc();
510    TStrV AuthNmV; StdName.SplitOnWs(AuthNmV);
511    if (! AuthNmV.Empty() && AuthNmV.Last() == "jr") AuthNmV.DelLast();
512    if (AuthNmV.Len() < 2) return TStr::GetNullStr();
513    const TStr LastNm = AuthNmV.Last();
514    if (! TCh::IsAlpha(LastNm[0]) || LastNm.Len() == 1) return TStr::GetNullStr();
515    IAssert(isalpha(AuthNmV[0][0]));
516    return TStr::Fmt("%s_%c", LastNm.CStr(), AuthNmV[0][0]);
517  }
518  void TStrUtil::GetStdNameV(TStr AuthorNames, TStrV& StdNameV) {
519    AuthorNames.ChangeChAll('\n', ' ');
520    AuthorNames.ToLc();
521    TStrV AuthV, TmpV, Tmp2V;
522    AuthorNames.SplitOnStr(" and ", TmpV);
523    int i;
524    for (i = 0; i < TmpV.Len(); i++) {
525      TmpV[i].SplitOnAllCh(',', Tmp2V);  AuthV.AddV(Tmp2V); }
526    TmpV = AuthV;  AuthV.Clr();
527    for (i = 0; i < TmpV.Len(); i++) {
528      TmpV[i].SplitOnAllCh('&', Tmp2V);  AuthV.AddV(Tmp2V); }
529    TmpV = AuthV;  AuthV.Clr();
530    for (i = 0; i < TmpV.Len(); i++) {
531      TmpV[i].SplitOnAllCh(',', Tmp2V);  AuthV.AddV(Tmp2V); }
532    TmpV = AuthV;  AuthV.Clr();
533    for (i = 0; i < TmpV.Len(); i++) {
534      TmpV[i].SplitOnAllCh(';', Tmp2V);  AuthV.AddV(Tmp2V); }
535    StdNameV.Clr();
536    for (i = 0; i < AuthV.Len(); i++) {
537      TStr StdName = GetStdName(AuthV[i]);
538      if (! StdName.Empty()) {
539        StdNameV.Add(StdName);
540      }
541    }
542  }
543  double TStopwatch::Tick() {
544  #ifdef USE_OPENMP
545    return omp_get_wtime();
546  #else
547  #ifdef GLib_WIN32
548    return GetTickCount() / 1000.0;
549  #else
550    struct rusage rusage;
551    getrusage(RUSAGE_SELF, &rusage);
552    float cputime =
553    ((float) (rusage.ru_utime.tv_usec + rusage.ru_stime.tv_usec) / 1000000) +
554    ((float) (rusage.ru_utime.tv_sec + rusage.ru_stime.tv_sec));
555    return cputime;
556  #endif
557  #endif
558  }
559  void TStopwatch::Start(const TExperiment Exp) {
560    Starts[Exp] = Tick();
561  }
562  void TStopwatch::Stop(const TExperiment Exp) {
563    double Duration = Tick() - Starts[Exp];
564    Sums[Exp] += Duration;
565    Maxs[Exp] = Maxs[Exp] >= Duration ? Maxs[Exp] : Duration;
566    Mins[Exp] = Mins[Exp] <= Duration ? Mins[Exp] : Duration;
567    Cnts[Exp]++;
568  }
569  int TStopwatch::Cnt(const TExperiment Exp) const {
570    return Cnts[Exp];
571  }
572  double TStopwatch::Sum(const TExperiment Exp) const {
573    return Sums[Exp];
574  }
575  double TStopwatch::Avg(const TExperiment Exp) const {
576    return Sums[Exp] / Cnts[Exp];
577  }
578  double TStopwatch::Max(const TExperiment Exp) const {
579    return Maxs[Exp];
580  }
581  double TStopwatch::Min(const TExperiment Exp) const {
582    return Mins[Exp];
583  }
584  #if defined(SW_WRITEN)
585  int WriteN(int fd, char *ptr, int nbytes) {
586    int nleft;
587    int nwritten;
588    nleft = nbytes;
589    while (nleft > 0) {
590      nwritten = (int) write(fd, ptr, nleft);
591      if (nwritten <= 0) {
592        return nwritten;
593      }
594      nleft -= nwritten;
595      ptr += nwritten;
596    }
597    return (nbytes-nleft);
598  }
599  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-util.cpp</h3>
            <pre><code>1  void TGUtil::GetCdf(const TIntPrV& PdfV, TIntPrV& CdfV) {
2    CdfV = PdfV;
3    for (int i = 1; i < CdfV.Len(); i++) {
4      CdfV[i].Val2 = CdfV[i-1].Val2 + CdfV[i].Val2; }
5  }
6  void TGUtil::GetCdf(const TFltPrV& PdfV, TFltPrV& CdfV) {
7    CdfV = PdfV;
8    for (int i = 1; i < CdfV.Len(); i++) {
9      CdfV[i].Val2 = CdfV[i-1].Val2 + CdfV[i].Val2; }
10  }
11  void TGUtil::GetCdf(const TIntFltKdV& PdfV, TIntFltKdV& CdfV) {
12    CdfV = PdfV;
13    for (int i = 1; i < CdfV.Len(); i++) {
14      CdfV[i].Dat = CdfV[i-1].Dat + CdfV[i].Dat; }
15  }
16  TIntPrV TGUtil::GetCdf(const TIntPrV& PdfV) {
17    TIntPrV CdfV;
18    GetCdf(PdfV, CdfV);
19    return CdfV;
20  }
21  TFltPrV TGUtil::GetCdf(const TFltPrV& PdfV) {
22    TFltPrV CdfV;
23    GetCdf(PdfV, CdfV);
24    return CdfV;
25  }
26  void TGUtil::GetCCdf(const TIntPrV& PdfV, TIntPrV& CCdfV) {
27    CCdfV = PdfV;
28    for (int i = CCdfV.Len()-2; i >= 0; i--) {
29      CCdfV[i].Val2 = CCdfV[i+1].Val2 + CCdfV[i].Val2; }
30  }
31  void TGUtil::GetCCdf(const TFltPrV& PdfV, TFltPrV& CCdfV) {
32    CCdfV = PdfV;
33    for (int i = CCdfV.Len()-2; i >= 0; i--) {
34      CCdfV[i].Val2 = CCdfV[i+1].Val2 + CCdfV[i].Val2; }
35  }
36  void TGUtil::GetCCdf(const TIntFltKdV& PdfV, TIntFltKdV& CCdfV) {
37    CCdfV = PdfV;
38    for (int i = CCdfV.Len()-2; i >= 0; i--) {
39      CCdfV[i].Dat = CCdfV[i+1].Dat + CCdfV[i].Dat; }
40  }
41  TIntPrV TGUtil::GetCCdf(const TIntPrV& PdfV) {
42    TIntPrV CCdfV;
43    GetCCdf(PdfV, CCdfV);
44    return CCdfV;
45  }
46  TFltPrV TGUtil::GetCCdf(const TFltPrV& PdfV) {
47    TFltPrV CCdfV;
48    GetCCdf(PdfV, CCdfV);
49    return CCdfV;
50  }
51  void TGUtil::GetPdf(const TIntPrV& CdfV, TIntPrV& PdfV) {
52    PdfV = CdfV;
53    for (int i = PdfV.Len()-1; i > 0; i--) {
54      PdfV[i].Val2 = PdfV[i].Val2 - PdfV[i-1].Val2; }
55  }
56  void TGUtil::GetPdf(const TFltPrV& CdfV, TFltPrV& PdfV) {
57    PdfV = CdfV;
58    for (int i = PdfV.Len()-1; i > 0; i--) {
59      PdfV[i].Val2 = PdfV[i].Val2 - PdfV[i-1].Val2; }
60  }
61  void TGUtil::GetPdf(const TIntFltKdV& CdfV, TIntFltKdV& PdfV) {
62    PdfV = CdfV;
63    for (int i = PdfV.Len()-1; i > 0; i--) {
64      PdfV[i].Dat = PdfV[i].Dat - PdfV[i-1].Dat; }
65  }
66  void TGUtil::Normalize(TFltPrV& PdfV) {
67    double Sum = 0.0;
68    for (int i = 0; i < PdfV.Len(); i++) {
69      Sum += PdfV[i].Val2; }
70    if (Sum <= 0.0) { return; }
71    for (int i = 0; i < PdfV.Len(); i++) {
72      PdfV[i].Val2 /= Sum; }
73  }
74  void TGUtil::Normalize(TIntFltKdV& PdfV) {
75    double Sum = 0.0;
76    for (int i = 0; i < PdfV.Len(); i++) {
77      Sum += PdfV[i].Dat; }
78    if (Sum <= 0.0) { return; }
79    for (int i = 0; i < PdfV.Len(); i++) {
80      PdfV[i].Dat /= Sum; }
81  }
82  void TGUtil::MakeExpBins(const TFltPrV& XYValV, TFltPrV& ExpXYValV, const double& BinFactor, const double& MinYVal) {
83    TGnuPlot::MakeExpBins(XYValV, ExpXYValV, BinFactor, MinYVal);
84  }
85  void TGUtil::MakeExpBins(const TFltKdV& XYValV, TFltKdV& ExpXYValV, const double& BinFactor, const double& MinYVal) {
86    TGnuPlot::MakeExpBins(XYValV, ExpXYValV, BinFactor, MinYVal);
87  }
88  void TGUtil::MakeExpBins(const TFltV& YValV, TFltV& ExpYValV, const double& BinFactor) {
89    ExpYValV.Clr(true);
90    int prevI=0;
91    for (int i = 0; i < YValV.Len(); ) {
92      ExpYValV.Add(YValV[i]);
93      i = int(i*BinFactor);
94      if (i==prevI) { i++; }
95      prevI = i;
96    }
97  }
98  void TGUtil::MakeExpBins(const TIntV& YValV, TIntV& ExpYValV, const double& BinFactor) {
99    ExpYValV.Clr(true);
100    int prevI=0;
101    for (int i = 0; i < YValV.Len(); ) {
102      ExpYValV.Add(YValV[i]);
103      i = int(i*BinFactor);
104      if (i==prevI) { i++; }
105      prevI = i;
106    }
107  }
108  TChA& TStrUtil::GetXmlTagVal(TXmlLx& XmlLx, const TChA& TagNm) {
109    static TChA TagVal;
110    EAssertR(XmlLx.GetSym() == xsySTag, TagNm);
111    EAssertR(TagNm == XmlLx.TagNm.CStr(), TagNm);
112    const TXmlLxSym NextSym = XmlLx.GetSym();
113    TagVal = XmlLx.TxtChA;
114    if (NextSym == xsyStr) {
115      EAssertR(XmlLx.GetSym() == xsyETag, TagNm);
116    } else {
117      EAssertR(NextSym == xsyETag, TagNm); 
118    }
119    EAssertR(XmlLx.TagNm == TagNm, TagNm);
120    return TagVal;
121  }
122  void TStrUtil::GetXmlTagNmVal(TXmlLx& XmlLx, TChA& TagNm, TChA& TagVal) {
123    EAssertR(XmlLx.GetSym() == xsySTag, TagNm);
124    TagNm = XmlLx.TagNm;
125    const TXmlLxSym NextSym = XmlLx.GetSym();
126    TagVal = XmlLx.TxtChA;
127    if (NextSym == xsyStr) {
128      EAssertR(XmlLx.GetSym() == xsyETag, TagNm);
129    } else {
130      EAssertR(NextSym == xsyETag, TagNm); 
131    }
132  }
133  bool TStrUtil::GetXmlTagNmVal2(TXmlLx& XmlLx, TChA& TagNm, TChA& TagVal, const bool& TakeTagNms) {
134    if (XmlLx.GetSym() != xsySTag) {
135      return false; }
136    TagVal.Clr();
137    TagNm = XmlLx.TagNm;
138    while (XmlLx.Sym != xsyETag || XmlLx.TagNm != TagNm.CStr()) {
139      if (TakeTagNms) {
140        TagVal += XmlLx.TxtChA; }
141      else if (XmlLx.Sym == xsyStr) {
142        TagVal += XmlLx.TxtChA; }
143      XmlLx.GetSym();
144    }
145    return true;
146  }
147  TChA TStrUtil::GetDomNm(const TChA& UrlChA) {
148    int EndSlash = UrlChA.SearchCh('/', 7)-1; 
149    if (EndSlash > 0) {
150      const int BegSlash = UrlChA.SearchChBack('/', EndSlash);
151      if (BegSlash > 0) { return UrlChA.GetSubStr(BegSlash+1, EndSlash).ToLc(); }
152      else { return UrlChA.GetSubStr(0, UrlChA.SearchCh('/', 0)-1).ToLc(); }
153    } else {
154      if (UrlChA.IsPrefix("http:&bsol;&bsol;")) { return UrlChA.GetSubStr(7, UrlChA.Len()-1).ToLc(); }
155      EndSlash = UrlChA.SearchCh('/', 0);
156      if (EndSlash > 0) { return UrlChA.GetSubStr(0, EndSlash-1).ToLc(); }
157      else { return TChA(UrlChA).ToLc(); }
158    }
159  }
160  TChA TStrUtil::GetDomNm2(const TChA& UrlChA) {
161    TChA Dom = GetDomNm(UrlChA);
162    if (Dom.IsPrefix("www.")) { return Dom.GetSubStr(4, TInt::Mx); }
163    else { return Dom; }
164  }
165  int GetNthOccurence(const TChA& Url, const int& Count, const char Ch='/') {
166    const char *c = Url.CStr();
167    int cnt = 0;
168    while (*c && cnt != Count) {
169      if (*c == Ch) { cnt++; }
170      c++;
171    }
172    return int(c-Url.CStr()-1);
173  }
174  TChA TStrUtil::GetWebsiteNm(const TChA& PostUrlStr) {
175    TChA DomNm = TStrUtil::GetDomNm2(PostUrlStr);
176    if (DomNm == "blog.myspace.com") {
177      return PostUrlStr.GetSubStr(7, GetNthOccurence(PostUrlStr, 2, '&')-1);
178    }
179    if (DomNm=="blogs.msdn.com" || DomNm=="ameblo.jp" || DomNm=="xfruits.com" || DomNm=="scienceblogs.com" || DomNm=="blogs.sun.com"
180      || DomNm=="blog.wired.com" || DomNm=="weblogs.asp.net" || DomNm=="blogs.technet.com" || DomNm=="blogs.guardian.co"
181      || DomNm=="blogs.clarin.com" || DomNm=="blogs.sun.com" || DomNm=="blog.wired.com" || DomNm=="weblogs.asp.net"
182      || DomNm=="blogs.technet.com" || DomNm=="blogs.guardian.com" || DomNm=="blogs.clarin.com" || DomNm=="blogs.zdnet.com"
183      || DomNm=="blogs.citypages.com" || DomNm=="voices.washingtonpost.com" || DomNm=="blog.tv2.dk"
184      || DomNm=="blogs.menomoneefallsnow.com" || DomNm=="weblogs.baltimoresun.com" || DomNm=="eonline.com") {
185        return PostUrlStr.GetSubStr(7, GetNthOccurence(PostUrlStr, 4)-1);
186    }
187    if (DomNm == "digg.com") {
188      if (PostUrlStr.IsPrefix("http:&bsol;&bsol;digg.com/submit?")) {
189        const int Url = PostUrlStr.SearchStr(";url=");
190        if (Url != -1) {
191          return GetWebsiteNm(PostUrlStr.GetSubStr(Url+5, PostUrlStr.SearchCh('&', Url+5))); }
192      } else {
193        return PostUrlStr.GetSubStr(7, GetNthOccurence(PostUrlStr, 4)-1); }
194    }
195    if (PostUrlStr.IsPrefix("http:&bsol;&bsol;nydailynews.com/blogs/") || PostUrlStr.IsPrefix("http:&bsol;&bsol;bbc.co.uk/blogs/")
196      || PostUrlStr.IsPrefix("http:&bsol;&bsol;nydailynews.com/blogs/") || PostUrlStr.IsPrefix("http:&bsol;&bsol;newsbusters.org/blogs/")) {
197      return PostUrlStr.GetSubStr(7, GetNthOccurence(PostUrlStr, 5)-1);
198    }
199    if (DomNm=="feeds.feedburner.com") {
200      return PostUrlStr.GetSubStr(7, GetNthOccurence(PostUrlStr, 5)-1);
201    }
202    if (DomNm=="groups.google.com") {
203      return PostUrlStr.GetSubStr(7, GetNthOccurence(PostUrlStr, 5)-1);
204    }
205    if (DomNm=="news.google.com") { 
206      const int UrlPos = PostUrlStr.SearchStr("&url=");
207      if (UrlPos != -1) {
208        return GetWebsiteNm(PostUrlStr.GetSubStr(UrlPos+5, PostUrlStr.SearchCh('&', UrlPos+5))); }
209    }
210    if (DomNm == "bloggrevyen.no") { 
211      const int Http2 = PostUrlStr.SearchStr("/http:&bsol;&bsol;");
212      if (Http2!=-1) {
213        return GetWebsiteNm(PostUrlStr.GetSubStr(Http2+1, PostUrlStr.Len()-1)); }
214    }
215    if (DomNm.IsSuffix(".rd.yahoo.com")) {
216      const int Http2 = PostUrlStr.SearchStr("&bsol;*");
217      if (Http2!=-1) {
218        return GetWebsiteNm(PostUrlStr.GetSubStr(Http2+9, PostUrlStr.Len()-1)); }
219    }
220    return DomNm;
221  }
222  bool TStrUtil::GetNormalizedUrl(const TChA& UrlIn, const TChA& BaseUrl, TChA& UrlOut) {
223    UrlOut = UrlIn;
224    if (StripEnd(UrlIn, "/", UrlOut)) {}
225    else if (StripEnd(UrlIn, "/index.html", UrlOut)) {}
226    else if (StripEnd(UrlIn, "/index.htm", UrlOut)) {}
227    else if (StripEnd(UrlIn, "/index.php", UrlOut)) {}
228    if (! (UrlOut.IsPrefix("http:&bsol;&bsol;") || UrlOut.IsPrefix("ftp:&bsol;&bsol;"))) {
229      if (UrlIn.Empty() || ! (BaseUrl.IsPrefix("http:&bsol;&bsol;") || BaseUrl.IsPrefix("ftp:&bsol;&bsol;"))) {
230        return false; }
231      TChA Out;
232      if (! GetNormalizedUrl(BaseUrl, TChA(), Out)) { return false; }
233      if (UrlIn[0] != '/') { Out.AddCh('/'); }
234      Out += UrlOut;
235      UrlOut = Out;
236    }
237    if (UrlOut.IsPrefix("http:&bsol;&bsol;www.")) {
238      UrlOut = TChA("http:&bsol;&bsol;") + UrlOut.GetSubStr(11, TInt::Mx);
239    }
240    UrlOut.ToLc();
241    return true;
242  }
243  bool TStrUtil::StripEnd(const TChA& Str, const TChA& SearchStr, TChA& NewStr) {
244    const int StrLen = Str.Len();
245    const int SearchStrLen = SearchStr.Len();
246    if (StrLen < SearchStrLen) { return false; }
247    for (int i = 0; i < SearchStrLen; i++) {
248      if (Str[StrLen-i-1] != SearchStr[SearchStrLen-i-1]) { return false; }
249    }
250    NewStr = Str.GetSubStr(0, StrLen-SearchStrLen-1);
251    return true;
252  }
253  TChA TStrUtil::GetShorStr(const TChA& LongStr, const int MaxLen) {
254    if (LongStr.Len() < MaxLen) { return LongStr; }
255    TChA Str = LongStr.GetSubStr(0, MaxLen-1);
256    Str += "...";
257    return Str;
258  }
259  TChA TStrUtil::GetCleanWrdStr(const TChA& ChA) {
260    char *b = (char *) ChA.CStr();
261    while (*b && ! TCh::IsAlNum(*b)) { b++; }
262    if (*b == 0) { return TChA(); }
263    TChA OutChA(ChA.Len());
264    char *e = b, tmp;
265    while (*e) {
266      b = e;
267      while (*e && (TCh::IsAlNum(*e) || ((*e=='\'' || *e=='-') && TCh::IsAlNum(*(e+1))))) { e++; }
268      if (b < e) {
269        tmp = *e; *e=0;
270        OutChA += b;  OutChA.AddCh(' ');
271        *e = tmp;
272      }
273      while (*e && ! TCh::IsAlNum(*e)) { e++; }
274      if (! *e) { break; }
275    }
276    OutChA.DelLastCh();  OutChA.ToLc();
277    return OutChA;
278  }
279  TChA TStrUtil::GetCleanStr(const TChA& ChA) {
280    char *b = (char *) ChA.CStr();
281    while (*b && ! TCh::IsAlNum(*b)) { b++; }
282    if (*b == 0) { return TChA(); }
283    TChA OutChA(ChA.Len());
284    char *e = b;
285    bool ws=false;
286    while (*e) {
287      while (*e && TCh::IsWs(*e)) { e++; ws=true; }
288      if (! *e) { break; }
289      if (ws) { OutChA.AddCh(' '); ws=false; }
290      OutChA.AddCh(*e);
291      e++;
292    }
293    return OutChA;
294  }
295  int TStrUtil::CountWords(const TChA& ChA) {
296    return CountWords(ChA.CStr());
297  }
298  int TStrUtil::CountWords(const char* CStr) {
299    int WrdCnt = 1;
300    for (const char *c = CStr; *c; c++) {
301      if (TCh::IsWs(*c)) { WrdCnt++; }
302    }
303    return WrdCnt;
304  }
305  int TStrUtil::CountWords(const TChA& ChA, const TStrHash<TInt>& StopWordH) {
306    TChA Tmp;
307    TVec<char *> WrdV;
308    SplitWords(Tmp, WrdV);
309    int SWordCnt = 0;
310    for (int w = 0; w < WrdV.Len(); w++) {
311      if (StopWordH.IsKey(WrdV[w])) { SWordCnt++; }
312    }
313    return WrdV.Len() - SWordCnt;
314  }
315  int TStrUtil::SplitWords(TChA& ChA, TVec<char *>& WrdV, const bool& SplitOnWs) {
316    WrdV.Clr(false);
317    WrdV.Add(ChA.CStr());
318    for (char *c = (char *) ChA.CStr(); *c; c++) {
319      if ((SplitOnWs && *c == ' ') || (! SplitOnWs && ! TCh::IsAlNum(*c))) {
320        *c = 0;
321        if (! WrdV.Empty() && strlen(WrdV.Last()) == 0) { WrdV.DelLast(); }
322        WrdV.Add(c+1);
323      }
324    }
325    return WrdV.Len();
326  }
327  int TStrUtil::SplitOnCh(TChA& ChA, TVec<char *>& WrdV, const char& Ch, const bool& SkipEmpty) {
328    WrdV.Clr(false);
329    WrdV.Add(ChA.CStr());
330    for (char *c = (char *) ChA.CStr(); *c; c++) {
331      if (*c == Ch) {
332        *c = 0;
333        if (SkipEmpty && ! WrdV.Empty() && strlen(WrdV.Last()) == 0) { WrdV.DelLast(); }
334        WrdV.Add(c+1);
335      }
336    }
337    if (SkipEmpty && ! WrdV.Empty() && strlen(WrdV.Last()) == 0) { WrdV.DelLast(); }
338    return WrdV.Len();
339  }
340  int TStrUtil::SplitLines(TChA& ChA, TVec<char *>& LineV, const bool& SkipEmpty) {
341    LineV.Clr(false);
342    LineV.Add(ChA.CStr());
343    bool IsChs=false;
344    for (char *c = (char *) ChA.CStr(); *c; c++) {
345      if (*c == '\n') {
346        if (c > ChA.CStr() && *(c-1)=='\r') { *(c-1)=0; } 
347        *c=0;
348        if (SkipEmpty) {
349          if (IsChs) { LineV.Add(c+1); }
350        } else {
351          LineV.Add(c+1);
352        }
353        IsChs=false;
354      } else {
355        IsChs=true;
356      }
357    }
358    return LineV.Len();
359  }
360  int TStrUtil::SplitSentences(TChA& ChA, TVec<char *>& SentenceV) {
361    SentenceV.Clr();
362    const char *B = ChA.CStr();
363    const char *E = B+ChA.Len();
364    char *c = (char *) B;
365    while (*c && TCh::IsWs(*c)) { c++; }
366    if (*c) { SentenceV.Add(c); } else { return 0; }
367    for (; c < E; c++) {
368      if (c<E && (*c == '.' || *c == '!' || *c == '?') && ! TCh::IsAlNum(*(c+1))) { 
369        if (c<E && *(c+1)=='"') { *c='"';  c++; } 
370        if (c>=E) { continue; }
371        *c=0;  c++;
372        char *e = c-1;
373        while (e>B && *e!='"' && ! TCh::IsAlNum(*e)) { *e=0; e--; } 
374        while (c<E && ! (TCh::IsAlNum(*c) || (*c=='"' && TCh::IsAlNum(*(c+1))))) { c++; } 
375        if (c<E) { SentenceV.Add(c); }
376      }
377    }
378    return SentenceV.Len();
379  }
380  void TStrUtil::RemoveHtmlTags(const TChA& HtmlStr, TChA& TextStr) {
381    TextStr.Clr();
382    char *StrB, *StrE;
383    StrB = (char *) HtmlStr.CStr();
384    StrE = (char *) StrB+HtmlStr.Len(); 
385    for (char *e = StrB; e < StrE; ) {
386      char* b = e;
387      while (e<StrE && *e != '<') { e++; }
388      char tmp=*e;  *e = 0;
389      TextStr+= b; TextStr.AddCh(' ');  *e = tmp;
390      if (e >= StrE) { return; }
391      if (e[1]=='!' && e[2]=='-' && e[3]=='-') { 
392        e += 3;
393        while(e<StrE && !(*(e-2)=='-' && *(e-1)=='-' && *e=='>')) { e++; }
394        e++;  continue;
395      }
396      if (e[1]=='s' && e[2]=='c' && e[3]=='r' && e[4]=='i' && e[5]=='p' && e[6]=='t') {
397        e += 5;
398        while(e<StrE && !(*(e-6)=='s' && *(e-5)=='c' && *(e-4)=='r' && *(e-3)=='i' && *(e-2)=='p' && *(e-1)=='t' && *e=='>')) { e++; }
399        e++;  continue;
400      }
401      while (e < StrE && *e != '>') { e++; }
402      if (e>=StrE) { return; }
403      e++;
404    }
405  }
406  bool TStrUtil::IsLatinStr(const TChA& Str, const double& MinAlFrac) {
407    int AlNumCnt=0, ChCnt=0;
408    for (const char *c = Str.CStr(); *c; c++) {
409      if (TCh::IsWs(*c)) { continue; }
410      if (*c > 0 && TCh::IsAlNum(*c)) { AlNumCnt++; }
411      ChCnt++;
412    }
413    if (double(AlNumCnt)/double(ChCnt) > MinAlFrac) { return true; }
414    return false;
415  }
416  void TStrUtil::GetWIdV(const TStrHash<TInt>& StrH, const char *CStr, TIntV& WIdV) {
417    const int NotWId = -1;
418    TChA ChA(CStr);
419    TVec<char *> WrdV;
420    TInt WId;
421    TStrUtil::SplitWords(ChA, WrdV);
422    WIdV.Clr(false);
423    for (int w = 0; w < WrdV.Len(); w++) {
424      if (StrH.IsKeyGetDat(WrdV[w], WId)) { WIdV.Add(WId); }
425      else { WIdV.Add(NotWId); }
426    }
427  }
428  void TStrUtil::GetAddWIdV(TStrHash<TInt>& StrH, const char *CStr, TIntV& WIdV) {
<span onclick='openModal()' class='match'>429    TChA ChA(CStr);
430    TVec<char *> WrdV;
431    TInt WId;
432    TStrUtil::SplitWords(ChA, WrdV);
433    WIdV.Clr(false);
434    for (int w = 0; w < WrdV.Len(); w++) {
435      WIdV.Add(StrH.AddDatId(WrdV[w]));
</span>436    }
437  }
438  bool TStrUtil::GetTmFromStr(const char* TmStr, TSecTm& Tm) {
439    static TStrV MonthV1, MonthV2;
440    if (MonthV1.Empty()) {
441      TStr("january|february|march|april|may|june|july|august|september|october|november|december").SplitOnAllCh('|', MonthV1);
442      TStr("jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec").SplitOnAllCh('|', MonthV2);
443    }
444    TChA Tmp(TmStr);
445    Tmp.ToLc();
446    TVec<char *> WrdV;
447    const char* End = Tmp.CStr()+Tmp.Len();
448    int Col = -1, Cols=0;
449    for (char *b = Tmp.CStr(); b <End; ) {
450      WrdV.Add(b);
451      while (*b && ! (*b==' ' || *b=='-' || *b==':' || *b==',')) { b++; }
452      if (*b==':') { if(Col==-1) { Col=WrdV.Len(); } Cols++;  }
453      *b=0; b++;
454      while (*b && (*b==' ' || *b=='-' || *b==':' || *b==',')) { b++; }
455    }
456    if (Cols == 2) {
457      if (Col+1 >= WrdV.Len()) { return false; }
458      WrdV.Del(Col+1);
459    }
460    if (Col<1) { return false; }
461    const int Hr = atoi(WrdV[Col-1]);
462    const int Min = atoi(WrdV[Col]);
463    WrdV.Del(Col);  WrdV.Del(Col-1);
464    if (WrdV.Len() != 3) { return false; }
465    int y=0,m=1,d=2, Mon=-1;
466    if (TCh::IsAlpha(WrdV[0][0])) {
467      y=2; m=0; d=1;
468    } else if (TCh::IsAlpha(WrdV[1][0])) {
469      y=2; m=1; d=0;
470    } else if (TCh::IsAlpha(WrdV[2][0])) {
471      y=0; m=2; d=1;
472    } else {
473      y=0; m=1; d=2;
474      Mon = atoi(WrdV[m]);
475    }
476    int Day = atoi(WrdV[d]);
477    if (Mon <= 0) { Mon = MonthV1.SearchForw(WrdV[m])+1; }
478    if (Mon <= 0) { Mon = MonthV2.SearchForw(WrdV[m])+1; }
479    if (Mon == 0) { return false; }
480    int Year = atoi(WrdV[y]);
481    if (Day > Year) { ::Swap(Day, Year); }
482    Tm = TSecTm(Year, Mon, Day, Hr, Min, 0);
483    return true;
484  }
485  TStr TStrUtil::GetStdName(TStr AuthorName) {
486    TStr StdName;
487    AuthorName.ToLc();
488    AuthorName.ChangeChAll('\n', ' ');
489    AuthorName.ChangeChAll('.', ' ');
490    int i, pos = 0;
491    while (pos<AuthorName.Len() && (AuthorName[pos]!='#' && !TCh::IsNum(AuthorName[pos]))) {
492      pos++; }
493    if (pos < AuthorName.Len()) {
494      AuthorName = AuthorName.GetSubStr(0, pos-1).ToTrunc(); }
495    if (AuthorName.Empty()) { return TStr::GetNullStr(); }
496    int b = AuthorName.SearchCh('(');
497    if (b != -1) {
498      AuthorName = AuthorName.GetSubStr(0, b-1).ToTrunc(); }
499    if (AuthorName .SearchCh(')')!=-1) { return TStr::GetNullStr(); }
500    if (AuthorName .SearchStr("figures")!=-1 || AuthorName .SearchStr("macros")!=-1
501     || AuthorName .SearchStr("univ")!=-1 || AuthorName .SearchStr("institute")!=-1) {
502      return TStr::GetNullStr();
503    }
504    TChA NewName;
505    for (i = 0; i < AuthorName.Len(); i++) {
506      const char Ch = AuthorName[i];
507      if (TCh::IsAlpha(Ch) || TCh::IsWs(Ch) || Ch=='-') { NewName += Ch; }
508    }
509    StdName = NewName;  StdName.ToTrunc();
510    TStrV AuthNmV; StdName.SplitOnWs(AuthNmV);
511    if (! AuthNmV.Empty() && AuthNmV.Last() == "jr") AuthNmV.DelLast();
512    if (AuthNmV.Len() < 2) return TStr::GetNullStr();
513    const TStr LastNm = AuthNmV.Last();
514    if (! TCh::IsAlpha(LastNm[0]) || LastNm.Len() == 1) return TStr::GetNullStr();
515    IAssert(isalpha(AuthNmV[0][0]));
516    return TStr::Fmt("%s_%c", LastNm.CStr(), AuthNmV[0][0]);
517  }
518  void TStrUtil::GetStdNameV(TStr AuthorNames, TStrV& StdNameV) {
519    AuthorNames.ChangeChAll('\n', ' ');
520    AuthorNames.ToLc();
521    TStrV AuthV, TmpV, Tmp2V;
522    AuthorNames.SplitOnStr(" and ", TmpV);
523    int i;
524    for (i = 0; i < TmpV.Len(); i++) {
525      TmpV[i].SplitOnAllCh(',', Tmp2V);  AuthV.AddV(Tmp2V); }
526    TmpV = AuthV;  AuthV.Clr();
527    for (i = 0; i < TmpV.Len(); i++) {
528      TmpV[i].SplitOnAllCh('&', Tmp2V);  AuthV.AddV(Tmp2V); }
529    TmpV = AuthV;  AuthV.Clr();
530    for (i = 0; i < TmpV.Len(); i++) {
531      TmpV[i].SplitOnAllCh(',', Tmp2V);  AuthV.AddV(Tmp2V); }
532    TmpV = AuthV;  AuthV.Clr();
533    for (i = 0; i < TmpV.Len(); i++) {
534      TmpV[i].SplitOnAllCh(';', Tmp2V);  AuthV.AddV(Tmp2V); }
535    StdNameV.Clr();
536    for (i = 0; i < AuthV.Len(); i++) {
537      TStr StdName = GetStdName(AuthV[i]);
538      if (! StdName.Empty()) {
539        StdNameV.Add(StdName);
540      }
541    }
542  }
543  double TStopwatch::Tick() {
544  #ifdef USE_OPENMP
545    return omp_get_wtime();
546  #else
547  #ifdef GLib_WIN32
548    return GetTickCount() / 1000.0;
549  #else
550    struct rusage rusage;
551    getrusage(RUSAGE_SELF, &rusage);
552    float cputime =
553    ((float) (rusage.ru_utime.tv_usec + rusage.ru_stime.tv_usec) / 1000000) +
554    ((float) (rusage.ru_utime.tv_sec + rusage.ru_stime.tv_sec));
555    return cputime;
556  #endif
557  #endif
558  }
559  void TStopwatch::Start(const TExperiment Exp) {
560    Starts[Exp] = Tick();
561  }
562  void TStopwatch::Stop(const TExperiment Exp) {
563    double Duration = Tick() - Starts[Exp];
564    Sums[Exp] += Duration;
565    Maxs[Exp] = Maxs[Exp] >= Duration ? Maxs[Exp] : Duration;
566    Mins[Exp] = Mins[Exp] <= Duration ? Mins[Exp] : Duration;
567    Cnts[Exp]++;
568  }
569  int TStopwatch::Cnt(const TExperiment Exp) const {
570    return Cnts[Exp];
571  }
572  double TStopwatch::Sum(const TExperiment Exp) const {
573    return Sums[Exp];
574  }
575  double TStopwatch::Avg(const TExperiment Exp) const {
576    return Sums[Exp] / Cnts[Exp];
577  }
578  double TStopwatch::Max(const TExperiment Exp) const {
579    return Maxs[Exp];
580  }
581  double TStopwatch::Min(const TExperiment Exp) const {
582    return Mins[Exp];
583  }
584  #if defined(SW_WRITEN)
585  int WriteN(int fd, char *ptr, int nbytes) {
586    int nleft;
587    int nwritten;
588    nleft = nbytes;
589    while (nleft > 0) {
590      nwritten = (int) write(fd, ptr, nleft);
591      if (nwritten <= 0) {
592        return nwritten;
593      }
594      nleft -= nwritten;
595      ptr += nwritten;
596    }
597    return (nbytes-nleft);
598  }
599  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-util.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-util.cpp</div>
                </div>
                <div class="column column_space"><pre><code>418    TChA ChA(CStr);
419    TVec<char *> WrdV;
420    TInt WId;
421    TStrUtil::SplitWords(ChA, WrdV);
422    WIdV.Clr(false);
423    for (int w = 0; w < WrdV.Len(); w++) {
424      if (StrH.IsKeyGetDat(WrdV[w], WId)) { WIdV.Add(WId); }
</pre></code></div>
                <div class="column column_space"><pre><code>429    TChA ChA(CStr);
430    TVec<char *> WrdV;
431    TInt WId;
432    TStrUtil::SplitWords(ChA, WrdV);
433    WIdV.Clr(false);
434    for (int w = 0; w < WrdV.Len(); w++) {
435      WIdV.Add(StrH.AddDatId(WrdV[w]));
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    