
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.441860465116279%, Tokens: 14</h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Printer.cpp</h3>
            <pre><code>1  #include "Printer.h"
2  #include "RunDlg.h"
3  void replaceStr(generic_string & str, generic_string str2BeReplaced, generic_string replacement)
4  {
5  	size_t pos = str.find(str2BeReplaced);
6  	if (pos != str.npos)
7  		str.replace(pos, str2BeReplaced.length(), replacement);
8  }
9  void Printer::init(HINSTANCE hInst, HWND hwnd, ScintillaEditView *pSEView, bool showDialog, size_t startPos, size_t endPos, bool isRTL)
10  {
11  	_pSEView = pSEView;
12  	_startPos = startPos;
13  	_endPos = endPos;
14  	_pdlg.lStructSize = sizeof(PRINTDLG);
15  	_pdlg.hwndOwner = hwnd;
16  	_pdlg.hInstance = hInst;
17  	_pdlg.Flags = PD_USEDEVMODECOPIES | PD_ALLPAGES | PD_RETURNDC;
18  	_pdlg.nFromPage = 1;
19  	_pdlg.nToPage = 1;
20  	_pdlg.nMinPage = 1;
21  	_pdlg.nMaxPage = 0xffffU; 
22  	_pdlg.nCopies = 1;
23  	_pdlg.hDC = 0;
24  	_pdlg.hDevMode = NULL;
25  	_pdlg.hDevNames = NULL;
26  	_pdlg.lCustData = 0;
27  	_pdlg.lpfnPrintHook = NULL;
28  	_pdlg.lpfnSetupHook = NULL;
29  	_pdlg.lpPrintTemplateName = NULL;
30  	_pdlg.lpSetupTemplateName = NULL;
31  	_pdlg.hPrintTemplate = NULL;
32  	_pdlg.hSetupTemplate = NULL;
33  	_pdlg.Flags |= (_startPos != _endPos)?PD_SELECTION:PD_NOSELECTION;
34  	if (!showDialog) 
35  	{
36  		_pdlg.Flags |= PD_RETURNDEFAULT;
37  	}
38  	_isRTL = isRTL;
39  }
40  size_t Printer::doPrint(bool justDoIt)
41  {
42  	const NppGUI & nppGUI = (NppParameters::getInstance()).getNppGUI();
43  	POINT ptPage{};
44  	POINT ptDpi{};
45  	RECT rectMargins{};
46  	RECT rectPhysMargins{};
47  	RECT userMargins{};
48  	ptDpi.x = GetDeviceCaps(_pdlg.hDC, LOGPIXELSX);    
49  	ptDpi.y = GetDeviceCaps(_pdlg.hDC, LOGPIXELSY);    
50  	ptPage.x = GetDeviceCaps(_pdlg.hDC, PHYSICALWIDTH);   
51  	ptPage.y = GetDeviceCaps(_pdlg.hDC, PHYSICALHEIGHT);  
52  	rectPhysMargins.left = GetDeviceCaps(_pdlg.hDC, PHYSICALOFFSETX);
53  	rectPhysMargins.top = GetDeviceCaps(_pdlg.hDC, PHYSICALOFFSETY);
54  	rectPhysMargins.right = ptPage.x						
55  	                        - GetDeviceCaps(_pdlg.hDC, HORZRES) 
56  	                        - rectPhysMargins.left;				
57  	rectPhysMargins.bottom = ptPage.y						
58  	                         - GetDeviceCaps(_pdlg.hDC, VERTRES)	
59  	                         - rectPhysMargins.top;				
60  	if (nppGUI._printSettings.isUserMargePresent())
61  	{
62  		userMargins.left  = MulDiv(nppGUI._printSettings._marge.left*100, ptDpi.x, 2540);
63  		userMargins.top  = MulDiv(nppGUI._printSettings._marge.top*100, ptDpi.y, 2540);
64  		userMargins.right  = MulDiv(nppGUI._printSettings._marge.right*100, ptDpi.x, 2540);
65  		userMargins.bottom  = MulDiv(nppGUI._printSettings._marge.bottom*100, ptDpi.y, 2540);
66  		rectMargins.left	= std::max<LONG>(rectPhysMargins.left, userMargins.left);
67  		rectMargins.top		= std::max<LONG>(rectPhysMargins.top, userMargins.top);
68  		rectMargins.right	= std::max<LONG>(rectPhysMargins.right, userMargins.right);
69  		rectMargins.bottom	= std::max<LONG>(rectPhysMargins.bottom, userMargins.bottom);
70  	}
71  	else
72  	{
73  	rectMargins.left	= rectPhysMargins.left;
74  	rectMargins.top		= rectPhysMargins.top;
75  	rectMargins.right	= rectPhysMargins.right;
76  	rectMargins.bottom	= rectPhysMargins.bottom;
77  	}
78  	DPtoLP(_pdlg.hDC, (LPPOINT)&rectMargins, 2);
79  	DPtoLP(_pdlg.hDC, (LPPOINT)&rectPhysMargins, 2);
80  	DPtoLP(_pdlg.hDC, &ptPage, 1);
81  	TEXTMETRIC tm{};
82  	int fontSize = nppGUI._printSettings._headerFontSize?nppGUI._printSettings._headerFontSize:9;
83  	int fontWeight = (nppGUI._printSettings._headerFontStyle & FONTSTYLE_BOLD) ? FW_BOLD : FW_NORMAL;
84  	int isFontItalic = (nppGUI._printSettings._headerFontStyle & FONTSTYLE_ITALIC) ? TRUE : FALSE;
85  	const TCHAR *fontFace = (nppGUI._printSettings._headerFontName != TEXT(""))?nppGUI._printSettings._headerFontName.c_str():TEXT("Arial");
86  	int headerLineHeight = ::MulDiv(fontSize, ptDpi.y, 72);
87  	HFONT fontHeader = ::CreateFont(headerLineHeight,
88  	                                0, 0, 0,
89  	                                fontWeight,
90  	                                isFontItalic,
91  	                                FALSE,
92  	                                0, 0, 0,
93  	                                0, 0, 0,
94  	                                fontFace);
95  	::SelectObject(_pdlg.hDC, fontHeader);
96  	::GetTextMetrics(_pdlg.hDC, &tm);
97  	headerLineHeight = tm.tmHeight + tm.tmExternalLeading;
98  	fontSize = nppGUI._printSettings._footerFontSize?nppGUI._printSettings._footerFontSize:9;
99  	fontWeight = (nppGUI._printSettings._footerFontStyle & FONTSTYLE_BOLD) ? FW_BOLD : FW_NORMAL;
100  	isFontItalic = (nppGUI._printSettings._footerFontStyle & FONTSTYLE_ITALIC) ? TRUE : FALSE;
101  	fontFace = (nppGUI._printSettings._footerFontName != TEXT(""))?nppGUI._printSettings._footerFontName.c_str():TEXT("Arial");
102  	int footerLineHeight = ::MulDiv(fontSize, ptDpi.y, 72);
103  	HFONT fontFooter = ::CreateFont(footerLineHeight,
104  	                                0, 0, 0,
105  	                                fontWeight,
106  	                                isFontItalic,
107  	                                FALSE,
108  	                                0, 0, 0,
109  	                                0, 0, 0,
110  	                                fontFace);
111  	::SelectObject(_pdlg.hDC, fontFooter);
112  	::GetTextMetrics(_pdlg.hDC, &tm);
113  	footerLineHeight = tm.tmHeight + tm.tmExternalLeading;
114  	::GetTextMetrics(_pdlg.hDC, &tm);
115  	int printMarge = tm.tmHeight + tm.tmExternalLeading;
116  	printMarge = printMarge + printMarge / 2;
117  	DOCINFO docInfo{};
118  	docInfo.cbSize = sizeof(DOCINFO);
119  	docInfo.fwType = 0;
120  	docInfo.lpszDocName = _pSEView->getCurrentBuffer()->getFullPathName();
121  	docInfo.lpszOutput = NULL;
122  	docInfo.lpszDatatype = NULL;
123  	if (::StartDoc(_pdlg.hDC, &docInfo) < 0) 
124  	{
125  		MessageBox(NULL, TEXT("Can not start printer document."), 0, MB_OK);
126  		return 0;
127  	}
128  	size_t lengthPrinted = 0;
129  	size_t lengthDoc = _pSEView->getCurrentDocLen();
130  	size_t lengthDocMax = lengthDoc;
131  	if ((!(_pdlg.Flags & PD_RETURNDEFAULT)) && (_pdlg.Flags & PD_SELECTION))
132  	{
133  		if (_startPos > _endPos) 
134  		{
135  			lengthPrinted = _endPos;
136  			lengthDoc = _startPos;
137  		}
138  		else 
139  		{
140  			lengthPrinted = _startPos;
141  			lengthDoc = _endPos;
142  		}
143  		if (lengthDoc > lengthDocMax)
144  			lengthDoc = lengthDocMax;
145  	}
146  	NPP_RangeToFormat frPrint{};
<span onclick='openModal()' class='match'>147  	frPrint.hdc = _pdlg.hDC;
148  	frPrint.hdcTarget = _pdlg.hDC;
149  	frPrint.rc.left = rectMargins.left - rectPhysMargins.left;
150  	frPrint.rc.top = rectMargins.top - rectPhysMargins.top;
151  	frPrint.rc.right = ptPage.x - rectMargins.right - rectPhysMargins.left;
152  	frPrint.rc.bottom = ptPage.y - rectMargins.bottom - rectPhysMargins.top;
153  	frPrint.rcPage.left = 0;
154  	frPrint.rcPage.top = 0;
155  	frPrint.rcPage.right = ptPage.x - rectPhysMargins.left - rectPhysMargins.right - 1;
156  	frPrint.rcPage.bottom = ptPage.y - rectPhysMargins.top - rectPhysMargins.bottom - 1;
157  	frPrint.rc.top += printMarge;
158  	frPrint.rc.bottom -= printMarge;
159  	frPrint.rc.left += printMarge;
160  	frPrint.rc.right -= printMarge;
</span>161  	const int headerSize = 256;
162  	TCHAR headerL[headerSize] = TEXT("");
163  	TCHAR headerM[headerSize] = TEXT("");
164  	TCHAR headerR[headerSize] = TEXT("");
165  	TCHAR footerL[headerSize] = TEXT("");
166  	TCHAR footerM[headerSize] = TEXT("");
167  	TCHAR footerR[headerSize] = TEXT("");
168  	const TCHAR shortDateVar[] = TEXT("$(SHORT_DATE)");
169  	const TCHAR longDateVar[] = TEXT("$(LONG_DATE)");
170  	const TCHAR timeVar[] = TEXT("$(TIME)");
171  	const int bufferSize = 64;
172  	TCHAR shortDate[bufferSize];
173  	TCHAR longDate[bufferSize];
174  	TCHAR time[bufferSize];
175  	SYSTEMTIME st{};
176  	::GetLocalTime(&st);
177  	::GetDateFormat(LOCALE_USER_DEFAULT, DATE_SHORTDATE, &st, NULL, shortDate, bufferSize);
178  	::GetDateFormat(LOCALE_USER_DEFAULT, DATE_LONGDATE, &st, NULL, longDate, bufferSize);
179  	::GetTimeFormat(LOCALE_USER_DEFAULT, TIME_NOSECONDS, &st, NULL, time, bufferSize);
180  	if (nppGUI._printSettings.isHeaderPresent())
181  	{
182  		frPrint.rc.top += headerLineHeight + headerLineHeight / 2;
183  		generic_string headerLeftPart = nppGUI._printSettings._headerLeft;
184  		if (headerLeftPart != TEXT(""))
185  		{
186  			replaceStr(headerLeftPart, shortDateVar, shortDate);
187  			replaceStr(headerLeftPart, longDateVar, longDate);
188  			replaceStr(headerLeftPart, timeVar, time);
189  			expandNppEnvironmentStrs(headerLeftPart.c_str(), headerL, headerSize, _pdlg.hwndOwner);
190  		}
191  		generic_string headerMiddlePart = nppGUI._printSettings._headerMiddle;
192  		if (headerMiddlePart != TEXT(""))
193  		{
194  			replaceStr(headerMiddlePart, shortDateVar, shortDate);
195  			replaceStr(headerMiddlePart, longDateVar, longDate);
196  			replaceStr(headerMiddlePart, timeVar, time);
197  			expandNppEnvironmentStrs(headerMiddlePart.c_str(), headerM, headerSize, _pdlg.hwndOwner);
198  		}
199  		generic_string headerRightPart = nppGUI._printSettings._headerRight;
200  		if (headerRightPart != TEXT(""))
201  		{
202  			replaceStr(headerRightPart, shortDateVar, shortDate);
203  			replaceStr(headerRightPart, longDateVar, longDate);
204  			replaceStr(headerRightPart, timeVar, time);
205  			expandNppEnvironmentStrs(headerRightPart.c_str(), headerR, headerSize, _pdlg.hwndOwner);
206  		}
207  	}
208  	if (nppGUI._printSettings.isFooterPresent())
209  	{
210  		frPrint.rc.bottom -= footerLineHeight + footerLineHeight / 2;
211  		generic_string footerLeftPart = nppGUI._printSettings._footerLeft;
212  		if (footerLeftPart != TEXT(""))
213  		{
214  			replaceStr(footerLeftPart, shortDateVar, shortDate);
215  			replaceStr(footerLeftPart, longDateVar, longDate);
216  			replaceStr(footerLeftPart, timeVar, time);
217  			expandNppEnvironmentStrs(footerLeftPart.c_str(), footerL, headerSize, _pdlg.hwndOwner);
218  		}
219  		generic_string footerMiddlePart = nppGUI._printSettings._footerMiddle;
220  		if (footerMiddlePart != TEXT(""))
221  		{
222  			replaceStr(footerMiddlePart, shortDateVar, shortDate);
223  			replaceStr(footerMiddlePart, longDateVar, longDate);
224  			replaceStr(footerMiddlePart, timeVar, time);
225  			expandNppEnvironmentStrs(footerMiddlePart.c_str(), footerM, headerSize, _pdlg.hwndOwner);
226  		}
227  		generic_string footerRightPart = nppGUI._printSettings._footerRight;
228  		if (footerRightPart != TEXT(""))
229  		{
230  			replaceStr(footerRightPart, shortDateVar, shortDate);
231  			replaceStr(footerRightPart, longDateVar, longDate);
232  			replaceStr(footerRightPart, timeVar, time);
233  			expandNppEnvironmentStrs(footerRightPart.c_str(), footerR, headerSize, _pdlg.hwndOwner);
234  		}
235  	}
236  	bool isShown = _pSEView->hasMarginShowed(ScintillaEditView::_SC_MARGE_LINENUMBER);
237  	if (!nppGUI._printSettings._printLineNumber)
238  		_pSEView->showMargin(ScintillaEditView::_SC_MARGE_LINENUMBER, false);
239  	int pageNum = 1;
240  	const TCHAR pageVar[] = TEXT("$(CURRENT_PRINTING_PAGE)");
241  	_pSEView->execute(SCI_SETPRINTCOLOURMODE, nppGUI._printSettings._printOption); 
242  	while (lengthPrinted < lengthDoc) 
243  	{
244  		bool printPage = (!(_pdlg.Flags & PD_PAGENUMS) ||
245  					((pageNum >= _pdlg.nFromPage) && (pageNum <= _pdlg.nToPage)));
246  		if (!justDoIt)
247  			printPage = false;
248  		TCHAR pageString[32]{};
249  		wsprintf(pageString, TEXT("%0d"), pageNum);
250  		if (printPage) 
251  		{
252  			::StartPage(_pdlg.hDC);
253  			if (nppGUI._printSettings.isHeaderPresent())
254  			{
255  				::SelectObject(_pdlg.hDC, fontHeader);
256  				::SetTextColor(_pdlg.hDC, RGB(0, 0, 0));
257  				::SetBkColor(_pdlg.hDC, RGB(255, 255, 255));
258  				UINT oldTASettings = ::SetTextAlign(_pdlg.hDC, _isRTL ? TA_RTLREADING | TA_BOTTOM : TA_BOTTOM);
259  				RECT rcw = {frPrint.rc.left, frPrint.rc.top - headerLineHeight - headerLineHeight / 2,
260  							frPrint.rc.right, frPrint.rc.top - headerLineHeight / 2};
261  				rcw.bottom = rcw.top + headerLineHeight;
262  				SIZE size{};
263  				if (headerL[0] != '\0')
264  				{
265  					generic_string headerLeft(headerL);
266  					size_t pos = headerLeft.find(pageVar);
267  					if (pos != headerLeft.npos)
268  						headerLeft.replace(pos, lstrlen(pageVar), pageString);
269  					::ExtTextOut(_pdlg.hDC, frPrint.rc.left + 5, frPrint.rc.top - headerLineHeight / 2,
270  						ETO_OPAQUE, &rcw, headerLeft.c_str(), static_cast<int>(headerLeft.length()), NULL);
271  				}
272  				if (headerM[0] != '\0')
273  				{
274  					generic_string headerMiddle(headerM);
275  					size_t pos = headerMiddle.find(pageVar);
276  					if (pos != headerMiddle.npos)
277  						headerMiddle.replace(pos, lstrlen(pageVar), pageString);
278  					::GetTextExtentPoint32(_pdlg.hDC, headerMiddle.c_str(), static_cast<int>(headerMiddle.length()), &size);
279  					::ExtTextOut(_pdlg.hDC, ((frPrint.rc.right - frPrint.rc.left)/2 + frPrint.rc.left) - (size.cx/2), frPrint.rc.top - headerLineHeight / 2,
280  						ETO_CLIPPED, &rcw, headerMiddle.c_str(), static_cast<int>(headerMiddle.length()), NULL);
281  				}
282  				if (headerR[0] != '\0')
283  				{
284  					generic_string headerRight(headerR);
285  					size_t pos = headerRight.find(pageVar);
286  					if (pos != headerRight.npos)
287  						headerRight.replace(pos, lstrlen(pageVar), pageString);
288  					::GetTextExtentPoint32(_pdlg.hDC, headerRight.c_str(), static_cast<int>(headerRight.length()), &size);
289  					::ExtTextOut(_pdlg.hDC, frPrint.rc.right - size.cx, frPrint.rc.top - headerLineHeight / 2,
290  						ETO_CLIPPED, &rcw, headerRight.c_str(), static_cast<int>(headerRight.length()), NULL);
291  				}
292  				::SetTextAlign(_pdlg.hDC, oldTASettings);
293  				HPEN pen = ::CreatePen(0, 1, 0x00000000);
294  				HPEN penOld = static_cast<HPEN>(::SelectObject(_pdlg.hDC, pen));
295  				::MoveToEx(_pdlg.hDC, frPrint.rc.left, frPrint.rc.top - headerLineHeight / 4, NULL);
296  				::LineTo(_pdlg.hDC, frPrint.rc.right, frPrint.rc.top - headerLineHeight / 4);
297  				::SelectObject(_pdlg.hDC, penOld);
298  				::DeleteObject(pen);
299  			}
300  		}
301  		frPrint.chrg.cpMin = static_cast<Sci_Position>(lengthPrinted);
302  		frPrint.chrg.cpMax = static_cast<Sci_Position>(lengthDoc);
303  		lengthPrinted = _pSEView->execute(SCI_FORMATRANGEFULL, printPage, reinterpret_cast<LPARAM>(&frPrint));
304  		if (printPage) 
305  		{
306  			if (nppGUI._printSettings.isFooterPresent())
307  			{
308  				::SelectObject(_pdlg.hDC, fontFooter);
309  				::SetTextColor(_pdlg.hDC, RGB(0, 0, 0));
310  				::SetBkColor(_pdlg.hDC, RGB(255, 255, 255));
311  				UINT oldta = ::SetTextAlign(_pdlg.hDC, _isRTL ? TA_RTLREADING | TA_TOP : TA_TOP);
312  				RECT rcw = {frPrint.rc.left, frPrint.rc.bottom + footerLineHeight / 2,
313  					        frPrint.rc.right, frPrint.rc.bottom + footerLineHeight + footerLineHeight / 2};
314  				SIZE size{};
315  				if (footerL[0] != '\0')
316  				{
317  					generic_string footerLeft(footerL);
318  					size_t pos = footerLeft.find(pageVar);
319  					if (pos != footerLeft.npos)
320  						footerLeft.replace(pos, lstrlen(pageVar), pageString);
321  					::ExtTextOut(_pdlg.hDC, frPrint.rc.left + 5, frPrint.rc.bottom + footerLineHeight / 2,
322  						ETO_OPAQUE, &rcw, footerLeft.c_str(), static_cast<int>(footerLeft.length()), NULL);
323  				}
324  				if (footerM[0] != '\0')
325  				{
326  					generic_string footerMiddle(footerM);
327  					size_t pos = footerMiddle.find(pageVar);
328  					if (pos != footerMiddle.npos)
329  						footerMiddle.replace(pos, lstrlen(pageVar), pageString);
330  					::GetTextExtentPoint32(_pdlg.hDC, footerMiddle.c_str(), static_cast<int>(footerMiddle.length()), &size);
331  					::ExtTextOut(_pdlg.hDC, ((frPrint.rc.right - frPrint.rc.left)/2 + frPrint.rc.left) - (size.cx/2), frPrint.rc.bottom + footerLineHeight / 2,
332  									ETO_CLIPPED, &rcw, footerMiddle.c_str(), static_cast<int>(footerMiddle.length()), NULL);
333  				}
334  				if (footerR[0] != '\0')
335  				{
336  					generic_string footerRight(footerR);
337  					size_t pos = footerRight.find(pageVar);
338  					if (pos != footerRight.npos)
339  						footerRight.replace(pos, lstrlen(pageVar), pageString);
340  					::GetTextExtentPoint32(_pdlg.hDC, footerRight.c_str(), static_cast<int>(footerRight.length()), &size);
341  					::ExtTextOut(_pdlg.hDC, frPrint.rc.right - size.cx, frPrint.rc.bottom + footerLineHeight / 2,
342  									ETO_CLIPPED, &rcw, footerRight.c_str(), static_cast<int>(footerRight.length()), NULL);
343  				}
344  				::SetTextAlign(_pdlg.hDC, oldta);
345  				HPEN pen = ::CreatePen(0, 1, 0x00000000);
346  				HPEN penOld = static_cast<HPEN>(::SelectObject(_pdlg.hDC, pen));
347  				::MoveToEx(_pdlg.hDC, frPrint.rc.left, frPrint.rc.bottom + footerLineHeight / 4, NULL);
348  				::LineTo(_pdlg.hDC, frPrint.rc.right, frPrint.rc.bottom + footerLineHeight / 4);
349  				::SelectObject(_pdlg.hDC, penOld);
350  				::DeleteObject(pen);
351  			}
352  			::EndPage(_pdlg.hDC);
353  		}
354  		++pageNum;
355  		if ((_pdlg.Flags & PD_PAGENUMS) && (pageNum > _pdlg.nToPage))
356  			break;
357  	}
358  	if (!nppGUI._printSettings._printLineNumber)
359  		_pSEView->showMargin(ScintillaEditView::_SC_MARGE_LINENUMBER, isShown);
360  	_pSEView->execute(SCI_FORMATRANGEFULL, FALSE, 0);
361  	::EndDoc(_pdlg.hDC);
362  	::DeleteDC(_pdlg.hDC);
363  	if (fontHeader)
364  		::DeleteObject(fontHeader);
365  	if (fontFooter)
366  		::DeleteObject(fontFooter);
367  	return (static_cast<size_t>(pageNum) - 1);
368  }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-NppCommands.cpp</h3>
            <pre><code>1  #include <memory>
2  #include <regex>
3  #include <shlwapi.h>
4  #include "Notepad_plus_Window.h"
5  #include "EncodingMapper.h"
6  #include "ShortcutMapper.h"
7  #include "TaskListDlg.h"
8  #include "clipboardFormats.h"
9  #include "VerticalFileSwitcher.h"
10  #include "documentMap.h"
11  #include "functionListPanel.h"
12  #include "ProjectPanel.h"
13  #include "fileBrowser.h"
14  #include "clipboardHistoryPanel.h"
15  #include "ansiCharPanel.h"
16  #include "Sorters.h"
17  #include "verifySignedfile.h"
18  #include "md5.h"
19  #include "sha-256.h"
20  using namespace std;
21  std::mutex command_mutex;
22  void Notepad_plus::macroPlayback(Macro macro)
23  {
24  	_playingBackMacro = true;
25  	_pEditView->execute(SCI_BEGINUNDOACTION);
26  	for (Macro::iterator step = macro.begin(); step != macro.end(); ++step)
27  	{
28  		if (step->isScintillaMacro())
29  			step->PlayBack(_pPublicInterface, _pEditView);
30  		else
31  			_findReplaceDlg.execSavedCommand(step->_message, step->_lParameter, string2wstring(step->_sParameter, CP_UTF8));
32  	}
33  	_pEditView->execute(SCI_ENDUNDOACTION);
34  	_playingBackMacro = false;
35  }
36  void Notepad_plus::command(int id)
37  {
38  	switch (id)
39  	{
40  		case IDM_FILE_NEW:
41  		{
42  			fileNew();
43  		}
44  		break;
45  		case IDM_EDIT_INSERT_DATETIME_SHORT:
46  		case IDM_EDIT_INSERT_DATETIME_LONG:
47  		{
48  			SYSTEMTIME currentTime = {};
49  			::GetLocalTime(&currentTime);
50  			wchar_t dateStr[128] = { '\0' };
51  			wchar_t timeStr[128] = { '\0' };
52  			int dateFlag = (id == IDM_EDIT_INSERT_DATETIME_SHORT) ? DATE_SHORTDATE : DATE_LONGDATE;
53  			GetDateFormatEx(LOCALE_NAME_USER_DEFAULT, dateFlag, &currentTime, NULL, dateStr, sizeof(dateStr) / sizeof(dateStr[0]), NULL);
54  			GetTimeFormatEx(LOCALE_NAME_USER_DEFAULT, TIME_NOSECONDS, &currentTime, NULL, timeStr, sizeof(timeStr) / sizeof(timeStr[0]));
55  			generic_string dateTimeStr;
56  			if (NppParameters::getInstance().getNppGUI()._dateTimeReverseDefaultOrder)
57  			{
58  				dateTimeStr = dateStr;
59  				dateTimeStr += TEXT(" ");
60  				dateTimeStr += timeStr;
61  			}
62  			else
63  			{
64  				dateTimeStr = timeStr;
65  				dateTimeStr += TEXT(" ");
66  				dateTimeStr += dateStr;
67  			}
68  			_pEditView->execute(SCI_BEGINUNDOACTION);
69  			_pEditView->execute(SCI_REPLACESEL, 0, reinterpret_cast<LPARAM>(""));
70  			_pEditView->addGenericText(dateTimeStr.c_str());
71  			_pEditView->execute(SCI_ENDUNDOACTION);
72  		}
73  		break;
74  		case IDM_EDIT_INSERT_DATETIME_CUSTOMIZED:
75  		{
76  			SYSTEMTIME currentTime = {};
77  			::GetLocalTime(&currentTime);
78  			NppGUI& nppGUI = NppParameters::getInstance().getNppGUI();
79  			generic_string dateTimeStr = getDateTimeStrFrom(nppGUI._dateTimeFormat, currentTime);
80  			_pEditView->execute(SCI_BEGINUNDOACTION);
81  			_pEditView->execute(SCI_REPLACESEL, 0, reinterpret_cast<LPARAM>(""));
82  			_pEditView->addGenericText(dateTimeStr.c_str());
83  			_pEditView->execute(SCI_ENDUNDOACTION);
84  		}
85  		break;
86  		case IDM_FILE_OPEN:
87  		{
88  			fileOpen();
89  		}
90  		break;
91  		case IDM_FILE_OPEN_FOLDER:
92  		{
93  			Command cmd(TEXT("explorer /select,\"$(FULL_CURRENT_PATH)\""));
94  			cmd.run(_pPublicInterface->getHSelf());
95  		}
96  		break;
97  		case IDM_FILE_OPEN_CMD:
98  		{
99  			Command cmd(NppParameters::getInstance().getNppGUI()._commandLineInterpreter.c_str());
100  			cmd.run(_pPublicInterface->getHSelf(), TEXT("$(CURRENT_DIRECTORY)"));
101  		}
102  		break;
103  		case IDM_FILE_CONTAININGFOLDERASWORKSPACE:
104  		{
105  			TCHAR currentFile[CURRENTWORD_MAXLENGTH] = { '\0' };
106  			TCHAR currentDir[CURRENTWORD_MAXLENGTH] = { '\0' };
107  			::SendMessage(_pPublicInterface->getHSelf(), NPPM_GETFULLCURRENTPATH, CURRENTWORD_MAXLENGTH, reinterpret_cast<LPARAM>(currentFile));
108  			::SendMessage(_pPublicInterface->getHSelf(), NPPM_GETCURRENTDIRECTORY, CURRENTWORD_MAXLENGTH, reinterpret_cast<LPARAM>(currentDir));
109  			if (!_pFileBrowser)
110  			{
111  				command(IDM_VIEW_FILEBROWSER);
112  			}
113  			vector<generic_string> folders;
114  			folders.push_back(currentDir);
115  			launchFileBrowser(folders, currentFile);
116  		}
117  		break;
118  		case IDM_FILE_OPEN_DEFAULT_VIEWER:
119  		{
120              BufferID buf = _pEditView->getCurrentBufferID();
121  			HINSTANCE res = ::ShellExecute(NULL, TEXT("open"), buf->getFullPathName(), NULL, NULL, SW_SHOW);
122  			int retResult = static_cast<int>(reinterpret_cast<intptr_t>(res));
123  			if (retResult <= 32)
124  			{
125  				generic_string errorMsg;
126  				errorMsg += GetLastErrorAsString(retResult);
127  				errorMsg += TEXT("An attempt was made to execute the below command.");
128  				errorMsg += TEXT("\n----------------------------------------------------------");
129  				errorMsg += TEXT("\nCommand: ");
130  				errorMsg += buf->getFullPathName();
131  				errorMsg += TEXT("\nError Code: ");
132  				errorMsg += intToString(retResult);
133  				errorMsg += TEXT("\n----------------------------------------------------------");
134  				::MessageBox(_pPublicInterface->getHSelf(), errorMsg.c_str(), TEXT("ShellExecute - ERROR"), MB_ICONINFORMATION | MB_APPLMODAL);
135  			}
136  		}
137  		break;
138  		case IDM_FILE_OPENFOLDERASWORSPACE:
139  		{
140  			NativeLangSpeaker* pNativeSpeaker = NppParameters::getInstance().getNativeLangSpeaker();
141  			generic_string openWorkspaceStr = pNativeSpeaker->getAttrNameStr(TEXT("Select a folder to add in Folder as Workspace panel"),
142  				FOLDERASWORKSPACE_NODE, "SelectFolderFromBrowserString");
143  			generic_string folderPath = folderBrowser(_pPublicInterface->getHSelf(), openWorkspaceStr);
144  			if (!folderPath.empty())
145  			{
146  				if (_pFileBrowser == nullptr) 
147  				{
148  					vector<generic_string> dummy;
149  					generic_string emptyStr;
150  					launchFileBrowser(dummy, emptyStr);
151  					if (_pFileBrowser != nullptr)
152  					{
153  						checkMenuItem(IDM_VIEW_FILEBROWSER, true);
154  						_toolBar.setCheck(IDM_VIEW_FILEBROWSER, true);
155  						_pFileBrowser->setClosed(false);
156  					}
157  					else 
158  						return;
159  				}
160  				else
161  				{
162  					if (_pFileBrowser->isClosed())
163  					{
164  						_pFileBrowser->display();
165  						checkMenuItem(IDM_VIEW_FILEBROWSER, true);
166  						_toolBar.setCheck(IDM_VIEW_FILEBROWSER, true);
167  						_pFileBrowser->setClosed(false);
168  					}
169  				}
170  				_pFileBrowser->addRootFolder(folderPath);
171  			}
172  		}
173  		break;
174  		case IDM_FILE_RELOAD:
175  			fileReload();
176  			break;
177  		case IDM_DOCLIST_FILESCLOSE:
178  		case IDM_DOCLIST_FILESCLOSEOTHERS:
179  			if (_pDocumentListPanel)
180  			{
181  				vector<SwitcherFileInfo> files = _pDocumentListPanel->getSelectedFiles(id == IDM_DOCLIST_FILESCLOSEOTHERS);
182  				for (size_t i = 0, len = files.size(); i < len; ++i)
183  				{
184  					fileClose((BufferID)files[i]._bufID, files[i]._iView);
185  				}
186  				if (id == IDM_DOCLIST_FILESCLOSEOTHERS)
187  				{
188  					_pDocumentListPanel->activateItem(_pEditView->getCurrentBufferID(), currentView());
189  				}
190  			}
191  			break;
192  		case IDM_DOCLIST_COPYNAMES:
193  		case IDM_DOCLIST_COPYPATHS:
194  			if (_pDocumentListPanel)
195  			{
196  				std::vector<Buffer*> buffers;
197  				auto files = _pDocumentListPanel->getSelectedFiles(false);
198  				for (auto&& sel : files)
199  					buffers.push_back(MainFileManager.getBufferByID(sel._bufID));
200  				buf2Clipborad(buffers, id == IDM_DOCLIST_COPYPATHS, _pDocumentListPanel->getHSelf());
201  			}
202  			break;
203  		case IDM_FILE_CLOSE:
204  			if (fileClose())
205                  checkDocState();
206  			break;
207  		case IDM_FILE_DELETE:
208  			if (fileDelete())
209                  checkDocState();
210  			break;
211  		case IDM_FILE_RENAME:
212  			fileRename();
213  			break;
214  		case IDM_FILE_CLOSEALL:
215  		{
216  			bool isSnapshotMode = NppParameters::getInstance().getNppGUI().isSnapshotMode();
217  			fileCloseAll(isSnapshotMode, false);
218              checkDocState();
219  			break;
220  		}
221  		case IDM_FILE_CLOSEALL_BUT_CURRENT :
222  			fileCloseAllButCurrent();
223              checkDocState();
224  			break;
225  		case IDM_FILE_CLOSEALL_TOLEFT :
226  			fileCloseAllToLeft();
227  			checkDocState();
228  			break;
229  		case IDM_FILE_CLOSEALL_TORIGHT :
230  			fileCloseAllToRight();
231  			checkDocState();
232  			break;
233  		case IDM_FILE_CLOSEALL_UNCHANGED:
234  			fileCloseAllUnchanged();
235  			checkDocState();
236  			break;
237  		case IDM_FILE_SAVE :
238  			fileSave();
239  			break;
240  		case IDM_FILE_SAVEALL :
241  			fileSaveAll();
242  			break;
243  		case IDM_FILE_SAVEAS :
244  			fileSaveAs();
245  			break;
246  		case IDM_FILE_SAVECOPYAS :
247  			fileSaveAs(BUFFER_INVALID, true);
248  			break;
249  		case IDM_FILE_LOADSESSION:
250  			fileLoadSession();
251  			break;
252  		case IDM_FILE_SAVESESSION:
253  			fileSaveSession();
254  			break;
255  		case IDM_FILE_PRINTNOW :
256  			filePrint(false);
257  			break;
258  		case IDM_FILE_PRINT :
259  			filePrint(true);
260  			break;
261  		case IDM_FILE_EXIT:
262  			::PostMessage(_pPublicInterface->getHSelf(), WM_CLOSE, 0, 0);
263  			break;
264  		case IDM_EDIT_UNDO:
265  		{
266  			std::lock_guard<std::mutex> lock(command_mutex);
267  			_pEditView->execute(WM_UNDO);
268  			checkClipboard();
269  			checkUndoState();
270  			break;
271  		}
272  		case IDM_EDIT_REDO:
273  		{
274  			std::lock_guard<std::mutex> lock(command_mutex);
275  			_pEditView->execute(SCI_REDO);
276  			checkClipboard();
277  			checkUndoState();
278  			break;
279  		}
280  		case IDM_EDIT_CUT:
281  			_pEditView->execute(WM_CUT);
282  			checkClipboard();
283  			break;
284  		case IDM_EDIT_COPY:
285  			_pEditView->execute(WM_COPY);
286  			checkClipboard();
287  			break;
288  		case IDM_EDIT_COPY_LINK:
289  		{
290  			size_t startPos = 0, endPos = 0, curPos = 0;
291  			if (_pEditView->getIndicatorRange(URL_INDIC, &startPos, &endPos, &curPos))
292  			{
293  				_pEditView->execute(SCI_SETSEL, startPos, endPos);
294  				_pEditView->execute(WM_COPY);
295  				checkClipboard();
296  				_pEditView->execute(SCI_SETSEL, curPos, curPos);
297  			}
298  			break;
299  		}
300  		case IDM_EDIT_COPY_BINARY:
301  		case IDM_EDIT_CUT_BINARY:
302  		{
303  			size_t textLen = _pEditView->execute(SCI_GETSELTEXT, 0, 0);
304  			if (!textLen)
305  				return;
306  			char *pBinText = new char[textLen + 1];
307  			_pEditView->getSelectedText(pBinText, textLen + 1);
308  			if (!OpenClipboard(NULL))
309  				return;
310  			EmptyClipboard();
311  			HGLOBAL hglbCopy = GlobalAlloc(GMEM_MOVEABLE, (textLen + 1) * sizeof(unsigned char));
312  			if (hglbCopy == NULL)
313  			{
314  				CloseClipboard();
315  				return;
316  			}
317  			unsigned char *lpucharCopy = (unsigned char *)GlobalLock(hglbCopy);
318  			memcpy(lpucharCopy, pBinText, textLen * sizeof(unsigned char));
319  			lpucharCopy[textLen] = 0;    
320  			delete[] pBinText;
321  			GlobalUnlock(hglbCopy);
322  			SetClipboardData(CF_TEXT, hglbCopy);
323  			HGLOBAL hglbLenCopy = GlobalAlloc(GMEM_MOVEABLE, sizeof(unsigned long));
324  			if (hglbLenCopy == NULL)
325  			{
326  				CloseClipboard();
327  				return;
328  			}
329  			unsigned long *lpLenCopy = (unsigned long *)GlobalLock(hglbLenCopy);
330  			*lpLenCopy = static_cast<unsigned long>(textLen);
331  			GlobalUnlock(hglbLenCopy);
332  			UINT f = RegisterClipboardFormat(CF_NPPTEXTLEN);
333  			SetClipboardData(f, hglbLenCopy);
334  			CloseClipboard();
335  			if (id == IDM_EDIT_CUT_BINARY)
336  				_pEditView->execute(SCI_REPLACESEL, 0, reinterpret_cast<LPARAM>(""));
337  		}
338  		break;
339  		case IDM_EDIT_PASTE:
340  		{
341  			std::lock_guard<std::mutex> lock(command_mutex);
342  			intptr_t eolMode = _pEditView->execute(SCI_GETEOLMODE);
343  			_pEditView->execute(SCI_PASTE);
344  			_pEditView->execute(SCI_CONVERTEOLS, eolMode);
345  		}
346  		break;
347  		case IDM_EDIT_PASTE_BINARY:
348  		{
349  			std::lock_guard<std::mutex> lock(command_mutex);
350  			if (!IsClipboardFormatAvailable(CF_TEXT))
351  				return;
352  			if (!OpenClipboard(NULL))
353  				return;
354  			HGLOBAL hglb = GetClipboardData(CF_TEXT);
355  			if (hglb != NULL)
356  			{
357  				char *lpchar = (char *)GlobalLock(hglb);
358  				if (lpchar != NULL)
359  				{
360  					UINT cf_nppTextLen = RegisterClipboardFormat(CF_NPPTEXTLEN);
361  					if (IsClipboardFormatAvailable(cf_nppTextLen))
362  					{
363  						HGLOBAL hglbLen = GetClipboardData(cf_nppTextLen);
364  						if (hglbLen != NULL)
365  						{
366  							unsigned long *lpLen = (unsigned long *)GlobalLock(hglbLen);
367  							if (lpLen != NULL)
368  							{
369  								_pEditView->execute(SCI_REPLACESEL, 0, reinterpret_cast<LPARAM>(""));
370  								_pEditView->execute(SCI_ADDTEXT, *lpLen, reinterpret_cast<LPARAM>(lpchar));
371  								GlobalUnlock(hglbLen);
372  							}
373  						}
374  					}
375  					else
376  					{
377  						_pEditView->execute(SCI_REPLACESEL, 0, reinterpret_cast<LPARAM>(lpchar));
378  					}
379  					GlobalUnlock(hglb);
380  				}
381  			}
382  			CloseClipboard();
383  		}
384  		break;
385  		case IDM_EDIT_OPENINFOLDER:
386  		case IDM_EDIT_OPENASFILE:
387  		{
388  			if (_pEditView->execute(SCI_GETSELECTIONS) != 1) 
389  				return;
390  			HWND hwnd = _pPublicInterface->getHSelf();
391  			TCHAR curentWord[CURRENTWORD_MAXLENGTH] = { '\0' };
392  			::SendMessage(hwnd, NPPM_GETFILENAMEATCURSOR, CURRENTWORD_MAXLENGTH, reinterpret_cast<LPARAM>(curentWord));
393  			TCHAR cmd2Exec[CURRENTWORD_MAXLENGTH] = { '\0' };
394  			if (id == IDM_EDIT_OPENINFOLDER)
395  			{
396  				wcscpy_s(cmd2Exec, TEXT("explorer"));
397  			}
398  			else
399  			{
400  				::SendMessage(hwnd, NPPM_GETNPPFULLFILEPATH, CURRENTWORD_MAXLENGTH, reinterpret_cast<LPARAM>(cmd2Exec));
401  			}
402  			if (::PathFileExists(curentWord))
403  			{
404  				generic_string fullFilePath = id == IDM_EDIT_OPENINFOLDER ? TEXT("/select,") : TEXT("");
405  				fullFilePath += TEXT("\"");
406  				fullFilePath += curentWord;
407  				fullFilePath += TEXT("\"");
408  				if (id == IDM_EDIT_OPENINFOLDER ||
409  					(id == IDM_EDIT_OPENASFILE && !::PathIsDirectory(curentWord)))
410  					::ShellExecute(hwnd, TEXT("open"), cmd2Exec, fullFilePath.c_str(), TEXT("."), SW_SHOW);
411  			}
412  			else 
413  			{
414  				TCHAR currentDir[CURRENTWORD_MAXLENGTH] = { '\0' };
415  				::SendMessage(hwnd, NPPM_GETCURRENTDIRECTORY, CURRENTWORD_MAXLENGTH, reinterpret_cast<LPARAM>(currentDir));
416  				generic_string fullFilePath = id == IDM_EDIT_OPENINFOLDER ? TEXT("/select,") : TEXT("");
417  				fullFilePath += TEXT("\"");
418  				fullFilePath += currentDir;
419  				fullFilePath += TEXT("\\");
420  				fullFilePath += curentWord;
421  				if ((id == IDM_EDIT_OPENASFILE &&
422  					(!::PathFileExists(fullFilePath.c_str() + 1) || ::PathIsDirectory(fullFilePath.c_str() + 1))))
423  				{
424  					_nativeLangSpeaker.messageBox("FilePathNotFoundWarning",
425  						_pPublicInterface->getHSelf(),
426  						TEXT("The file you're trying to open doesn't exist."),
427  						TEXT("File Open"),
428  						MB_OK | MB_APPLMODAL);
429  					return;
430  				}
431  				fullFilePath += TEXT("\"");
432  				::ShellExecute(hwnd, TEXT("open"), cmd2Exec, fullFilePath.c_str(), TEXT("."), SW_SHOW);
433  			}
434  		}
435  		break;
436  		case IDM_EDIT_SEARCHONINTERNET:
437  		{
438  			if (_pEditView->execute(SCI_GETSELECTIONS) != 1) 
439  				return;
440  			const NppGUI & nppGui = (NppParameters::getInstance()).getNppGUI();
441  			generic_string url;
442  			if (nppGui._searchEngineChoice == nppGui.se_custom)
443  			{
444  				url = nppGui._searchEngineCustom;
445  				url.erase(std::remove_if(url.begin(), url.end(), [](_TUCHAR x) {return _istspace(x); }),
446  					url.end());
447  				auto httpPos = url.find(TEXT("http:&bsol;&bsol;"));
448  				auto httpsPos = url.find(TEXT("https:&bsol;&bsol;"));
449  				if (url.empty() || (httpPos != 0 && httpsPos != 0)) 
450  				{
451  					url = TEXT("https:&bsol;&bsol;www.google.com/search?q=$(CURRENT_WORD)");
452  				}
453  			}
454  			else if (nppGui._searchEngineChoice == nppGui.se_duckDuckGo || nppGui._searchEngineChoice == nppGui.se_bing)
455  			{
456  				url = TEXT("https:&bsol;&bsol;duckduckgo.com/?q=$(CURRENT_WORD)");
457  			}
458  			else if (nppGui._searchEngineChoice == nppGui.se_google)
459  			{
460  				url = TEXT("https:&bsol;&bsol;www.google.com/search?q=$(CURRENT_WORD)");
461  			}
462  			else if (nppGui._searchEngineChoice == nppGui.se_yahoo)
463  			{
464  				url = TEXT("https:&bsol;&bsol;search.yahoo.com/search?q=$(CURRENT_WORD)");
465  			}
466  			else if (nppGui._searchEngineChoice == nppGui.se_stackoverflow)
467  			{
468  				url = TEXT("https:&bsol;&bsol;stackoverflow.com/search?q=$(CURRENT_WORD)");
469  			}
470  			Command cmd(url.c_str());
471  			cmd.run(_pPublicInterface->getHSelf());	
472  		}
473  		break;
474  		case IDM_EDIT_CHANGESEARCHENGINE:
475  		{
476  			command(IDM_SETTING_PREFERENCE);
477  			_preference.showDialogByName(TEXT("SearchEngine"));
478  		}
479  		break;
480  		case IDM_EDIT_PASTE_AS_RTF:
481  		case IDM_EDIT_PASTE_AS_HTML:
482  		{
483  			std::lock_guard<std::mutex> lock(command_mutex);
484  			UINT f = RegisterClipboardFormat(id==IDM_EDIT_PASTE_AS_HTML?CF_HTML:CF_RTF);
485  			if (!IsClipboardFormatAvailable(f))
486  				return;
487  			if (!OpenClipboard(NULL))
488  				return;
489  			HGLOBAL hglb = GetClipboardData(f);
490  			if (hglb != NULL)
491  			{
492  				LPSTR lptstr = (LPSTR)GlobalLock(hglb);
493  				if (lptstr != NULL)
494  				{
495  					_pEditView->execute(SCI_REPLACESEL, 0, reinterpret_cast<LPARAM>(lptstr));
496  					GlobalUnlock(hglb);
497  				}
498  			}
499  			CloseClipboard();
500  		}
501  		break;
502  		case IDM_EDIT_BEGINENDSELECT:
503  		case IDM_EDIT_BEGINENDSELECT_COLUMNMODE:
504  		{
505  			_pEditView->beginOrEndSelect(id == IDM_EDIT_BEGINENDSELECT_COLUMNMODE);
506  			bool isStarted = _pEditView->beginEndSelectedIsStarted();
507  			::CheckMenuItem(_mainMenuHandle, id, MF_BYCOMMAND | (isStarted ? MF_CHECKED : MF_UNCHECKED));
508  			int otherId = (id == IDM_EDIT_BEGINENDSELECT) ? IDM_EDIT_BEGINENDSELECT_COLUMNMODE : IDM_EDIT_BEGINENDSELECT;
509  			::EnableMenuItem(_mainMenuHandle, otherId, MF_BYCOMMAND | (isStarted ? (MF_DISABLED | MF_GRAYED) : MF_ENABLED));
510  		}
511  		break;
512  		case IDM_EDIT_SORTLINES_LEXICOGRAPHIC_ASCENDING:
513  		case IDM_EDIT_SORTLINES_LEXICOGRAPHIC_DESCENDING:
514  		case IDM_EDIT_SORTLINES_LEXICO_CASE_INSENS_ASCENDING:
515  		case IDM_EDIT_SORTLINES_LEXICO_CASE_INSENS_DESCENDING:
516  		case IDM_EDIT_SORTLINES_INTEGER_ASCENDING:
517  		case IDM_EDIT_SORTLINES_INTEGER_DESCENDING:
518  		case IDM_EDIT_SORTLINES_DECIMALCOMMA_ASCENDING:
519  		case IDM_EDIT_SORTLINES_DECIMALCOMMA_DESCENDING:
520  		case IDM_EDIT_SORTLINES_DECIMALDOT_ASCENDING:
521  		case IDM_EDIT_SORTLINES_DECIMALDOT_DESCENDING:
522  		case IDM_EDIT_SORTLINES_REVERSE_ORDER:
523  		case IDM_EDIT_SORTLINES_RANDOMLY:
524  		{
525  			std::lock_guard<std::mutex> lock(command_mutex);
526  			size_t fromLine = 0, toLine = 0;
527  			size_t fromColumn = 0, toColumn = 0;
528  			bool hasLineSelection = false;
529  			if (_pEditView->execute(SCI_GETSELECTIONS) > 1)
530  			{
531  				if (_pEditView->execute(SCI_SELECTIONISRECTANGLE) || _pEditView->execute(SCI_GETSELECTIONMODE) == SC_SEL_THIN)
532  				{
533  					size_t rectSelAnchor = _pEditView->execute(SCI_GETRECTANGULARSELECTIONANCHOR);
534  					size_t rectSelCaret = _pEditView->execute(SCI_GETRECTANGULARSELECTIONCARET);
535  					size_t anchorLine = _pEditView->execute(SCI_LINEFROMPOSITION, rectSelAnchor);
536  					size_t caretLine = _pEditView->execute(SCI_LINEFROMPOSITION, rectSelCaret);
537  					fromLine = std::min<size_t>(anchorLine, caretLine);
538  					toLine = std::max<size_t>(anchorLine, caretLine);
539  					size_t anchorLineOffset = rectSelAnchor - _pEditView->execute(SCI_POSITIONFROMLINE, anchorLine) + _pEditView->execute(SCI_GETRECTANGULARSELECTIONANCHORVIRTUALSPACE);
540  					size_t caretLineOffset = rectSelCaret - _pEditView->execute(SCI_POSITIONFROMLINE, caretLine) + _pEditView->execute(SCI_GETRECTANGULARSELECTIONCARETVIRTUALSPACE);
541  					fromColumn = std::min<size_t>(anchorLineOffset, caretLineOffset);
542  					toColumn = std::max<size_t>(anchorLineOffset, caretLineOffset);
543  				}
544  				else
545  				{
546  					return;
547  				}
548  			}
549  			else
550  			{
551  				auto selStart = _pEditView->execute(SCI_GETSELECTIONSTART);
552  				auto selEnd = _pEditView->execute(SCI_GETSELECTIONEND);
553  				hasLineSelection = selStart != selEnd;
554  				if (hasLineSelection)
555  				{
556  					const pair<size_t, size_t> lineRange = _pEditView->getSelectionLinesRange();
557  					if (lineRange.first == lineRange.second)
558  					{
559  						return;
560  					}
561  					fromLine = lineRange.first;
562  					toLine = lineRange.second;
563  				}
564  				else
565  				{
566  					fromLine = 0;
567  					toLine = _pEditView->execute(SCI_GETLINECOUNT) - 1;
568  				}
569  			}
570  			bool isDescending = id == IDM_EDIT_SORTLINES_LEXICOGRAPHIC_DESCENDING ||
571  								id == IDM_EDIT_SORTLINES_INTEGER_DESCENDING ||
572  								id == IDM_EDIT_SORTLINES_DECIMALCOMMA_DESCENDING ||
573  								id == IDM_EDIT_SORTLINES_DECIMALDOT_DESCENDING ||
574  								id == IDM_EDIT_SORTLINES_LEXICO_CASE_INSENS_DESCENDING;
575  			_pEditView->execute(SCI_BEGINUNDOACTION);
576  			std::unique_ptr<ISorter> pSorter;
577  			if (id == IDM_EDIT_SORTLINES_LEXICOGRAPHIC_DESCENDING || id == IDM_EDIT_SORTLINES_LEXICOGRAPHIC_ASCENDING)
578  			{
579  				pSorter = std::unique_ptr<ISorter>(new LexicographicSorter(isDescending, fromColumn, toColumn));
580  			}
581  			else if (id == IDM_EDIT_SORTLINES_LEXICO_CASE_INSENS_DESCENDING || id == IDM_EDIT_SORTLINES_LEXICO_CASE_INSENS_ASCENDING)
582  			{
583  				pSorter = std::unique_ptr<ISorter>(new LexicographicCaseInsensitiveSorter(isDescending, fromColumn, toColumn));
584  			}
585  			else if (id == IDM_EDIT_SORTLINES_INTEGER_DESCENDING || id == IDM_EDIT_SORTLINES_INTEGER_ASCENDING)
586  			{
587  				pSorter = std::unique_ptr<ISorter>(new IntegerSorter(isDescending, fromColumn, toColumn));
588  			}
589  			else if (id == IDM_EDIT_SORTLINES_DECIMALCOMMA_DESCENDING || id == IDM_EDIT_SORTLINES_DECIMALCOMMA_ASCENDING)
590  			{
591  				pSorter = std::unique_ptr<ISorter>(new DecimalCommaSorter(isDescending, fromColumn, toColumn));
592  			}
593  			else if (id == IDM_EDIT_SORTLINES_DECIMALDOT_DESCENDING || id == IDM_EDIT_SORTLINES_DECIMALDOT_ASCENDING)
594  			{
595  				pSorter = std::unique_ptr<ISorter>(new DecimalDotSorter(isDescending, fromColumn, toColumn));
596  			}
597  			else if (id == IDM_EDIT_SORTLINES_REVERSE_ORDER)
598  			{
599  				pSorter = std::unique_ptr<ISorter>(new ReverseSorter(isDescending, fromColumn, toColumn));
600  			}
601  			else
602  			{
603  				pSorter = std::unique_ptr<ISorter>(new RandomSorter(isDescending, fromColumn, toColumn));
604  			}
605  			try
606  			{
607  				_pEditView->sortLines(fromLine, toLine, pSorter.get());
608  			}
609  			catch (size_t& failedLineIndex)
610  			{
611  				size_t lineNo = 1 + fromLine + failedLineIndex;
612  				_nativeLangSpeaker.messageBox("SortingError",
613  					_pPublicInterface->getHSelf(),
614  					TEXT("Unable to perform numeric sorting due to line $INT_REPLACE$."),
615  					TEXT("Sorting Error"),
616  					MB_OK | MB_ICONINFORMATION | MB_APPLMODAL,
617  					static_cast<int>(lineNo),
618  					0);
619  			}
620  			_pEditView->execute(SCI_ENDUNDOACTION);
621  			if (hasLineSelection) 
622  			{
623  				auto posStart = _pEditView->execute(SCI_POSITIONFROMLINE, fromLine);
624  				auto posEnd = _pEditView->execute(SCI_GETLINEENDPOSITION, toLine);
625  				_pEditView->execute(SCI_SETSELECTIONSTART, posStart);
626  				_pEditView->execute(SCI_SETSELECTIONEND, posEnd);
627  			}
628  		}
629  		break;
630  		case IDM_EDIT_BLANKLINEABOVECURRENT:
631  		{
632  			_pEditView->insertNewLineAboveCurrentLine();
633  		}
634  		break;
635  		case IDM_EDIT_BLANKLINEBELOWCURRENT:
636  		{
637  			_pEditView->insertNewLineBelowCurrentLine();
638  		}
639  		break;
640  		case IDM_EDIT_CHAR_PANEL:
641  		{
642  			if (_pAnsiCharPanel && (!_pAnsiCharPanel->isClosed()))
643  			{
644  				_pAnsiCharPanel->display(false);
645  				_pAnsiCharPanel->setClosed(true);
646  				checkMenuItem(IDM_EDIT_CHAR_PANEL, false);
647  			}
648  			else
649  			{
650  				checkMenuItem(IDM_EDIT_CHAR_PANEL, true);
651  				launchAnsiCharPanel();
652  				_pAnsiCharPanel->setClosed(false);
653  			}
654  		}
655  		break;
656  		case IDM_EDIT_CLIPBOARDHISTORY_PANEL:
657  		{
658  			if (_pClipboardHistoryPanel && (!_pClipboardHistoryPanel->isClosed()))
659  			{
660  				_pClipboardHistoryPanel->display(false);
661  				_pClipboardHistoryPanel->setClosed(true);
662  				checkMenuItem(IDM_EDIT_CLIPBOARDHISTORY_PANEL, false);
663  			}
664  			else
665  			{
666  				checkMenuItem(IDM_EDIT_CLIPBOARDHISTORY_PANEL, true);
667  				launchClipboardHistoryPanel();
668  				_pClipboardHistoryPanel->setClosed(false);
669  			}
670  		}
671  		break;
672  		case IDM_VIEW_SWITCHTO_DOCLIST:
673  		{
674  			if (_pDocumentListPanel && _pDocumentListPanel->isVisible())
675  			{
676  				_pDocumentListPanel->getFocus();
677  			}
678  			else
679  			{
680  				checkMenuItem(IDM_VIEW_DOCLIST, true);
681  				_toolBar.setCheck(IDM_VIEW_DOCLIST, true);
682  				launchDocumentListPanel();
683  				_pDocumentListPanel->setClosed(false);
684  			}
685  		}
686  		break;
687  		case IDM_VIEW_DOCLIST:
688  		{
689  			if (_pDocumentListPanel && (!_pDocumentListPanel->isClosed()))
690  			{
691  				_pDocumentListPanel->display(false);
692  				_pDocumentListPanel->setClosed(true);
693  				checkMenuItem(IDM_VIEW_DOCLIST, false);
694  				_toolBar.setCheck(IDM_VIEW_DOCLIST, false);
695  			}
696  			else
697  			{
698  				launchDocumentListPanel();
699  				if (_pDocumentListPanel)
700  				{
701  					checkMenuItem(IDM_VIEW_DOCLIST, true);
702  					_toolBar.setCheck(IDM_VIEW_DOCLIST, true);
703  					_pDocumentListPanel->setClosed(false);
704  				}
705  			}
706  		}
707  		break;
708  		case IDM_VIEW_PROJECT_PANEL_1:
709  		case IDM_VIEW_PROJECT_PANEL_2:
710  		case IDM_VIEW_PROJECT_PANEL_3:
711  		{
712  			ProjectPanel** pp [] = {&_pProjectPanel_1, &_pProjectPanel_2, &_pProjectPanel_3};
713  			int idx = id - IDM_VIEW_PROJECT_PANEL_1;
714  			if (*pp [idx] == nullptr)
715  			{
716  				launchProjectPanel(id, pp [idx], idx);
717  			}
718  			else
719  			{
720  				if (!(*pp[idx])->isClosed())
721  				{
722  					if ((*pp[idx])->checkIfNeedSave())
723  					{
724  						if (::IsChild((*pp[idx])->getHSelf(), ::GetFocus()))
725  							::SetFocus(_pEditView->getHSelf());
726  						(*pp[idx])->display(false);
727  						(*pp[idx])->setClosed(true);
728  						checkMenuItem(id, false);
729  						checkProjectMenuItem();
730  					}
731  				}
732  				else
733  				{
734  					launchProjectPanel(id, pp [idx], idx);
735  				}
736  			}
737  		}
738  		break;
739  		case IDM_VIEW_SWITCHTO_PROJECT_PANEL_1:
740  		case IDM_VIEW_SWITCHTO_PROJECT_PANEL_2:
741  		case IDM_VIEW_SWITCHTO_PROJECT_PANEL_3:
742  		{
743  			ProjectPanel** pp [] = {&_pProjectPanel_1, &_pProjectPanel_2, &_pProjectPanel_3};
744  			int idx = id - IDM_VIEW_SWITCHTO_PROJECT_PANEL_1;
745  			launchProjectPanel(id - IDM_VIEW_SWITCHTO_PROJECT_PANEL_1 + IDM_VIEW_PROJECT_PANEL_1, pp [idx], idx);
746  		}
747  		break;
748  		case IDM_VIEW_FILEBROWSER:
749  		case IDM_VIEW_SWITCHTO_FILEBROWSER:
750  		{
751  			if (_pFileBrowser == nullptr) 
752  			{
753  				NppParameters& nppParam = NppParameters::getInstance();
754  				launchFileBrowser(nppParam.getFileBrowserRoots(), nppParam.getFileBrowserSelectedItemPath());
755  				if (_pFileBrowser != nullptr)
756  				{
757  					checkMenuItem(IDM_VIEW_FILEBROWSER, true);
758  					_toolBar.setCheck(IDM_VIEW_FILEBROWSER, true);
759  					_pFileBrowser->setClosed(false);
760  				}
761  			}
762  			else
763  			{
764  				if (!_pFileBrowser->isClosed() && (id != IDM_VIEW_SWITCHTO_FILEBROWSER))
765  				{
766  					_pFileBrowser->display(false);
767  					_pFileBrowser->setClosed(true);
768  					checkMenuItem(IDM_VIEW_FILEBROWSER, false);
769  					_toolBar.setCheck(IDM_VIEW_FILEBROWSER, false);
770  				}
771  				else
772  				{
773  					vector<generic_string> dummy;
774  					generic_string emptyStr;
775  					launchFileBrowser(dummy, emptyStr);
776  					checkMenuItem(IDM_VIEW_FILEBROWSER, true);
777  					_toolBar.setCheck(IDM_VIEW_FILEBROWSER, true);
778  					_pFileBrowser->setClosed(false);
779  				}
780  			}
781  		}
782  		break;
783  		case IDM_VIEW_DOC_MAP:
784  		{
785  			if (_pDocMap && (!_pDocMap->isClosed()))
786  			{
787  				_pDocMap->display(false);
788  				_pDocMap->vzDlgDisplay(false);
789  				_pDocMap->setClosed(true);
790  				checkMenuItem(IDM_VIEW_DOC_MAP, false);
791  				_toolBar.setCheck(IDM_VIEW_DOC_MAP, false);
792  			}
793  			else
794  			{
795  				launchDocMap();
796  				if (_pDocMap)
797  				{
798  					checkMenuItem(IDM_VIEW_DOC_MAP, true);
799  					_toolBar.setCheck(IDM_VIEW_DOC_MAP, true);
800  					_pDocMap->setClosed(false);
801  				}
802  			}
803  		}
804  		break;
805  		case IDM_VIEW_SWITCHTO_FUNC_LIST:
806  		{
807  			if (_pFuncList && _pFuncList->isVisible())
808  			{
809  				_pFuncList->getFocus();
810  			}
811  			else
812  			{
813  				checkMenuItem(IDM_VIEW_FUNC_LIST, true);
814  				_toolBar.setCheck(IDM_VIEW_FUNC_LIST, true);
815  				launchFunctionList();
816  				_pFuncList->setClosed(false);
817  			}
818  		}
819  		break;
820  		case IDM_VIEW_FUNC_LIST:
821  		{
822  			if (_pFuncList && (!_pFuncList->isClosed()))
823  			{
824  				_pFuncList->display(false);
825  				_pFuncList->setClosed(true);
826  				checkMenuItem(IDM_VIEW_FUNC_LIST, false);
827  				_toolBar.setCheck(IDM_VIEW_FUNC_LIST, false);
828  			}
829  			else
830  			{
831  				checkMenuItem(IDM_VIEW_FUNC_LIST, true);
832  				_toolBar.setCheck(IDM_VIEW_FUNC_LIST, true);
833  				launchFunctionList();
834  				_pFuncList->setClosed(false);
835  			}
836  		}
837  		break;
838  		case IDM_VIEW_TAB_COLOUR_NONE:
839  		case IDM_VIEW_TAB_COLOUR_1:
840  		case IDM_VIEW_TAB_COLOUR_2:
841  		case IDM_VIEW_TAB_COLOUR_3:
842  		case IDM_VIEW_TAB_COLOUR_4:
843  		case IDM_VIEW_TAB_COLOUR_5:
844  		{
845  			const int color_id = (id - IDM_VIEW_TAB_COLOUR_NONE) - 1;
846  			const auto current_index = _pDocTab->getCurrentTabIndex();
847  			BufferID buffer_id = _pDocTab->getBufferByIndex(current_index);
848  			_pDocTab->setIndividualTabColour(buffer_id, color_id);
849  			_pDocTab->redraw();
850  			if (_pDocumentListPanel != nullptr)
851  			{
852  				_pDocumentListPanel->setItemColor(buffer_id);
853  			}
854  		}
855  		break;
856  		case IDM_VIEW_TAB1:
857  		case IDM_VIEW_TAB2:
858  		case IDM_VIEW_TAB3:
859  		case IDM_VIEW_TAB4:
860  		case IDM_VIEW_TAB5:
861  		case IDM_VIEW_TAB6:
862  		case IDM_VIEW_TAB7:
863  		case IDM_VIEW_TAB8:
864  		case IDM_VIEW_TAB9:
865  		{
866  			const int index = id - IDM_VIEW_TAB1;
867  			BufferID buf = _pDocTab->getBufferByIndex(index);
868  			_isFolding = true;
869  			if (buf == BUFFER_INVALID)
870  			{
871  				const int last_index = _pDocTab->getItemCount() - 1;
872  				if (last_index > 0)
873  					switchToFile(_pDocTab->getBufferByIndex(last_index));
874  			}
875  			else
876  			{
877  				switchToFile(buf);
878  			}
879  			_isFolding = false;
880  		}
881  		break;
882  		case IDM_VIEW_TAB_NEXT:
883  		{
884  			const int current_index = _pDocTab->getCurrentTabIndex();
885  			const int last_index = _pDocTab->getItemCount() - 1;
886  			_isFolding = true;
887  			if (current_index < last_index)
888  				switchToFile(_pDocTab->getBufferByIndex(current_index + 1));
889  			else
890  			{
891  				switchToFile(_pDocTab->getBufferByIndex(0)); 
892  			}
893  			_isFolding = false;
894  		}
895  		break;
896  		case IDM_VIEW_TAB_PREV:
897  		{
898  			const int current_index = _pDocTab->getCurrentTabIndex();
899  			_isFolding = true;
900  			if (current_index > 0)
901  				switchToFile(_pDocTab->getBufferByIndex(current_index - 1));
902  			else
903  			{
904  				const int last_index = _pDocTab->getItemCount() - 1;
905  				switchToFile(_pDocTab->getBufferByIndex(last_index)); 
906  			}
907  			_isFolding = false;
908  		}
909  		break;
910  		case IDM_VIEW_TAB_MOVEFORWARD:
911  		case IDM_VIEW_TAB_MOVEBACKWARD:
912  		{
913  			const int currentTabIndex = _pDocTab->getCurrentTabIndex();
914  			const int lastTabIndex = _pDocTab->getItemCount() - 1;
915  			int newTabIndex = currentTabIndex;
916  			if (id == IDM_VIEW_TAB_MOVEFORWARD)
917  			{
918  				if (currentTabIndex >= lastTabIndex)
919  					return;
920  				++newTabIndex;
921  			}
922  			else
923  			{
924  				if (currentTabIndex < 1)
925  					return;
926  				--newTabIndex;
927  			}
928  			TCITEM tciMove{}, tciShift{};
929  			tciMove.mask = tciShift.mask = TCIF_IMAGE | TCIF_TEXT | TCIF_PARAM;
930  			const int strSizeMax = 256;
931  			TCHAR strMove[strSizeMax] = { '\0' };
932  			TCHAR strShift[strSizeMax] = { '\0' };
933  			tciMove.pszText = strMove;
934  			tciMove.cchTextMax = strSizeMax;
935  			tciShift.pszText = strShift;
936  			tciShift.cchTextMax = strSizeMax;
937  			::SendMessage(_pDocTab->getHSelf(), TCM_GETITEM, currentTabIndex, reinterpret_cast<LPARAM>(&tciMove));
938  			::SendMessage(_pDocTab->getHSelf(), TCM_GETITEM, newTabIndex, reinterpret_cast<LPARAM>(&tciShift));
939  			::SendMessage(_pDocTab->getHSelf(), TCM_SETITEM, currentTabIndex, reinterpret_cast<LPARAM>(&tciShift));
940  			::SendMessage(_pDocTab->getHSelf(), TCM_SETITEM, newTabIndex, reinterpret_cast<LPARAM>(&tciMove));
941  			::SendMessage(_pDocTab->getHSelf(), TCM_SETCURSEL, newTabIndex, 0);
942  			::SendMessage(_pDocTab->getHParent(), NPPM_INTERNAL_DOCORDERCHANGED, 0, newTabIndex);
943  		}
944  		break;
945  		case IDM_EDIT_DELETE:
946  			_pEditView->execute(WM_CLEAR);
947  			break;
948  		case IDM_MACRO_STARTRECORDINGMACRO:
949  		case IDM_MACRO_STOPRECORDINGMACRO:
950  		case IDC_EDIT_TOGGLEMACRORECORDING:
951  		{
952  			if (_recordingMacro)
953  			{
954  				_mainEditView.execute(SCI_STOPRECORD);
955  				_subEditView.execute(SCI_STOPRECORD);
956  				_mainEditView.execute(SCI_SETCURSOR, static_cast<WPARAM>(SC_CURSORNORMAL));
957  				_subEditView.execute(SCI_SETCURSOR, static_cast<WPARAM>(SC_CURSORNORMAL));
958  				_recordingMacro = false;
959  				_runMacroDlg.initMacroList();
960  			}
961  			else
962  			{
963  				_mainEditView.execute(SCI_SETCURSOR, 9);
964  				_subEditView.execute(SCI_SETCURSOR, 9);
965  				_macro.clear();
966  				_mainEditView.execute(SCI_STARTRECORD);
967  				_subEditView.execute(SCI_STARTRECORD);
968  				_recordingMacro = true;
969  			}
970  			_recordingSaved = false;
971  			checkMacroState();
972  			break;
973  		}
974  		case IDM_MACRO_PLAYBACKRECORDEDMACRO:
975  			if (!_recordingMacro) 
976  			{
977  				macroPlayback(_macro);
978  			}
979  			break;
980  		case IDM_MACRO_RUNMULTIMACRODLG :
981  		{
982  			if (!_recordingMacro) 
983  			{
984  				bool isFirstTime = !_runMacroDlg.isCreated();
985  				_runMacroDlg.doDialog(_nativeLangSpeaker.isRTL());
986  				if (isFirstTime)
987  				{
988  					_nativeLangSpeaker.changeDlgLang(_runMacroDlg.getHSelf(), "MultiMacro");
989  				}
990  				break;
991  			}
992  		}
993  		break;
994  		case IDM_MACRO_SAVECURRENTMACRO :
995  		{
996  			if (addCurrentMacro())
997  			{
998  				_recordingSaved = true;
999  				_runMacroDlg.initMacroList();
1000  				checkMacroState();
1001  			}
1002  			break;
1003  		}
1004  		case IDM_EDIT_FULLPATHTOCLIP :
1005  		case IDM_EDIT_CURRENTDIRTOCLIP :
1006  		case IDM_EDIT_FILENAMETOCLIP :
1007  		{
1008  			Buffer * buf = _pEditView->getCurrentBuffer();
1009  			if (id == IDM_EDIT_FULLPATHTOCLIP)
1010  			{
1011  				str2Cliboard(buf->getFullPathName());
1012  			}
1013  			else if (id == IDM_EDIT_CURRENTDIRTOCLIP)
1014  			{
1015  				generic_string dir(buf->getFullPathName());
1016  				PathRemoveFileSpec(dir);
1017  				str2Cliboard(dir);
1018  			}
1019  			else if (id == IDM_EDIT_FILENAMETOCLIP)
1020  			{
1021  				str2Cliboard(buf->getFileName());
1022  			}
1023  		}
1024  		break;
1025  		case IDM_EDIT_COPY_ALL_NAMES:
1026  		case IDM_EDIT_COPY_ALL_PATHS:
1027  			{
1028  				std::vector<DocTabView*> docTabs;
1029  				if (viewVisible(MAIN_VIEW))
1030  					docTabs.push_back(&_mainDocTab);
1031  				if (viewVisible(SUB_VIEW))
1032  					docTabs.push_back(&_subDocTab);
1033  				std::vector<Buffer*> buffers;
1034  				for (auto&& docTab : docTabs)
1035  				{
1036  					for (size_t i = 0, len = docTab->nbItem(); i < len; ++i)
1037  					{
1038  						BufferID bufID = docTab->getBufferByIndex(i);
1039  						Buffer* buf = MainFileManager.getBufferByID(bufID);
1040  						if (docTabs.size() < 2 || std::find(buffers.begin(), buffers.end(), buf) == buffers.end())
1041  							buffers.push_back(buf);
1042  					}
1043  				}
1044  				buf2Clipborad({ buffers.begin(), buffers.end() }, id == IDM_EDIT_COPY_ALL_PATHS, _pPublicInterface->getHSelf());
1045  			}
1046  			break;
1047  		case IDM_SEARCH_FIND :
1048  		case IDM_SEARCH_REPLACE :
1049  		case IDM_SEARCH_MARK :
1050  		{
1051  			const int strSize = FINDREPLACE_MAXLENGTH;
1052  			TCHAR str[strSize] = { '\0' };
1053  			bool isFirstTime = !_findReplaceDlg.isCreated();
1054  			DIALOG_TYPE dlgID = FIND_DLG;
1055  			if (id == IDM_SEARCH_REPLACE)
1056  				dlgID = REPLACE_DLG;
1057  			else if (id == IDM_SEARCH_MARK)
1058  				dlgID = MARK_DLG;
1059  			_findReplaceDlg.doDialog(dlgID, _nativeLangSpeaker.isRTL());
1060  			const NppGUI & nppGui = (NppParameters::getInstance()).getNppGUI();
1061  			if (nppGui._fillFindFieldWithSelected)
1062  			{
1063  				_pEditView->getGenericSelectedText(str, strSize, nppGui._fillFindFieldSelectCaret);
1064  				if (lstrlen(str) <= FINDREPLACE_INSEL_TEXTSIZE_THRESHOLD)
1065  				{
1066  					_findReplaceDlg.setSearchText(str);
1067  				}
1068  			}
1069  			setFindReplaceFolderFilter(NULL, NULL);
1070  			if (isFirstTime)
1071  				_nativeLangSpeaker.changeFindReplaceDlgLang(_findReplaceDlg);
1072  			break;
1073  		}
1074  		case IDM_SEARCH_FINDINFILES:
1075  		{
1076  			::SendMessage(_pPublicInterface->getHSelf(), NPPM_LAUNCHFINDINFILESDLG, 0, 0);
1077  			break;
1078  		}
1079  		case IDM_SEARCH_FINDINCREMENT :
1080  		{
1081  			const int strSize = FINDREPLACE_MAXLENGTH;
1082  			TCHAR str[strSize] = { '\0' };
1083  			static bool isFirstTime = true;
1084  			if (isFirstTime)
1085  			{
1086  				_nativeLangSpeaker.changeDlgLang(_incrementFindDlg.getHSelf(), "IncrementalFind");
1087  				isFirstTime = false;
1088  			}
1089  			_pEditView->getGenericSelectedText(str, strSize, false);
1090  			if (0 != str[0])         
1091  				_incrementFindDlg.setSearchText(str, _pEditView->getCurrentBuffer()->getUnicodeMode() != uni8Bit);
1092  			_incrementFindDlg.display();
1093  		}
1094  		break;
1095  		case IDM_SEARCH_FINDNEXT :
1096  		case IDM_SEARCH_FINDPREV :
1097  		{
1098  			if (_findReplaceDlg.isCreated())
1099  			{
1100  				FindOption op = _findReplaceDlg.getCurrentOptions();
1101  				NppParameters& nppParams = NppParameters::getInstance();
1102  				if ((id == IDM_SEARCH_FINDPREV) && (op._searchType == FindRegex) && !nppParams.regexBackward4PowerUser())
1103  				{
1104  				}
1105  				else
1106  				{
1107  					op._whichDirection = (id == IDM_SEARCH_FINDNEXT ? DIR_DOWN : DIR_UP);
1108  					generic_string s = _findReplaceDlg.getText2search();
1109  					FindStatus status = FSNoMessage;
1110  					_findReplaceDlg.processFindNext(s.c_str(), &op, &status);
1111  					if (status == FSEndReached)
1112  					{
1113  						generic_string msg = _nativeLangSpeaker.getLocalizedStrFromID("find-status-end-reached", TEXT("Find: Found the 1st occurrence from the top. The end of the document has been reached."));
1114  						_findReplaceDlg.setStatusbarMessage(msg, FSEndReached);
1115  					}
1116  					else if (status == FSTopReached)
1117  					{
1118  						generic_string msg = _nativeLangSpeaker.getLocalizedStrFromID("find-status-top-reached", TEXT("Find: Found the 1st occurrence from the bottom. The beginning of the document has been reached."));
1119  						_findReplaceDlg.setStatusbarMessage(msg, FSTopReached);
1120  					}
1121  				}
1122  			}
1123  		}
1124  		break;
1125          case IDM_SEARCH_SETANDFINDNEXT :
1126  		case IDM_SEARCH_SETANDFINDPREV :
1127          {
1128              bool isFirstTime = !_findReplaceDlg.isCreated();
1129  			if (isFirstTime)
1130  				_findReplaceDlg.doDialog(FIND_DLG, _nativeLangSpeaker.isRTL(), false);
1131  			const int strSize = FINDREPLACE_MAXLENGTH;
1132  			TCHAR str[strSize] = { '\0' };
1133  			_pEditView->getGenericSelectedText(str, strSize);
1134  			_findReplaceDlg.setSearchText(str);
1135  			_findReplaceDlg._env->_str2Search = str;
1136  			setFindReplaceFolderFilter(NULL, NULL);
1137  			if (isFirstTime)
1138  				_nativeLangSpeaker.changeFindReplaceDlgLang(_findReplaceDlg);
1139  			FindOption op = _findReplaceDlg.getCurrentOptions();
1140  			op._searchType = FindNormal;
1141  			op._whichDirection = (id == IDM_SEARCH_SETANDFINDNEXT?DIR_DOWN:DIR_UP);
1142  			FindStatus status = FSNoMessage;
1143  			_findReplaceDlg.processFindNext(str, &op, &status);
1144  			if (status == FSEndReached)
1145  			{
1146  				generic_string msg = _nativeLangSpeaker.getLocalizedStrFromID("find-status-end-reached", TEXT("Find: Found the 1st occurrence from the top. The end of the document has been reached."));
1147  				_findReplaceDlg.setStatusbarMessage(msg, FSEndReached);
1148  			}
1149  			else if (status == FSTopReached)
1150  			{
1151  				generic_string msg = _nativeLangSpeaker.getLocalizedStrFromID("find-status-top-reached", TEXT("Find: Found the 1st occurrence from the bottom. The beginning of the document has been reached."));
1152  				_findReplaceDlg.setStatusbarMessage(msg, FSTopReached);
1153  			}
1154          }
1155  		break;
1156  		case IDM_SEARCH_GOTONEXTFOUND:
1157  		{
1158  			_findReplaceDlg.gotoNextFoundResult();
1159  		}
1160  		break;
1161  		case IDM_SEARCH_GOTOPREVFOUND:
1162  		{
1163  			_findReplaceDlg.gotoNextFoundResult(-1);
1164  		}
1165  		break;
1166  		case IDM_FOCUS_ON_FOUND_RESULTS:
1167  		{
1168  			if (GetFocus() == _findReplaceDlg.getHFindResults())
1169  				switchEditViewTo(currentView());
1170  			else
1171  				_findReplaceDlg.focusOnFinder();
1172  		}
1173  		break;
1174  		case IDM_SEARCH_VOLATILE_FINDNEXT :
1175  		case IDM_SEARCH_VOLATILE_FINDPREV :
1176  		{
1177  			const int strSize = FINDREPLACE_MAXLENGTH;
1178  			TCHAR str[strSize] = { '\0' };
1179  			_pEditView->getGenericSelectedText(str, strSize);
1180  			FindOption op;
1181  			op._isMatchCase = false;
1182  			op._isWholeWord = false;
1183  			op._isWrapAround = true;
1184  			op._searchType = FindNormal;
1185  			op._whichDirection = (id == IDM_SEARCH_VOLATILE_FINDNEXT ? DIR_DOWN : DIR_UP);
1186  			FindStatus status = FSNoMessage;
1187  			_findReplaceDlg.processFindNext(str, &op, &status);
1188  			if (status == FSEndReached)
1189  			{
1190  				generic_string msg = _nativeLangSpeaker.getLocalizedStrFromID("find-status-end-reached", TEXT("Find: Found the 1st occurrence from the top. The end of the document has been reached."));
1191  				_findReplaceDlg.setStatusbarMessage(msg, FSEndReached);
1192  			}
1193  			else if (status == FSTopReached)
1194  			{
1195  				generic_string msg = _nativeLangSpeaker.getLocalizedStrFromID("find-status-top-reached", TEXT("Find: Found the 1st occurrence from the bottom. The beginning of the document has been reached."));
1196  				_findReplaceDlg.setStatusbarMessage(msg, FSTopReached);
1197  			}
1198  		}
1199  		break;
1200  		case IDM_SEARCH_MARKALLEXT1 :
1201  		case IDM_SEARCH_MARKALLEXT2 :
1202  		case IDM_SEARCH_MARKALLEXT3 :
1203  		case IDM_SEARCH_MARKALLEXT4 :
1204  		case IDM_SEARCH_MARKALLEXT5 :
1205  		{
1206  			int styleID;
1207  			if (id == IDM_SEARCH_MARKALLEXT1)
1208  				styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT1;
1209  			else if (id == IDM_SEARCH_MARKALLEXT2)
1210  				styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT2;
1211  			else if (id == IDM_SEARCH_MARKALLEXT3)
1212  				styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT3;
1213  			else if (id == IDM_SEARCH_MARKALLEXT4)
1214  				styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT4;
1215  			else 
1216  				styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT5;
1217  			const int strSize = FINDREPLACE_MAXLENGTH;
1218  			TCHAR selectedText[strSize] = { '\0' };
1219  			TCHAR wordOnCaret[strSize] = { '\0' };
1220  			_pEditView->getGenericSelectedText(selectedText, strSize, false);
1221  			_pEditView->getGenericWordOnCaretPos(wordOnCaret, strSize);
1222  			if (selectedText[0] == '\0')
1223  			{
1224  				if (lstrlen(wordOnCaret) > 0)
1225  				{
1226  					_findReplaceDlg.markAll(wordOnCaret, styleID);
1227  				}
1228  			}
1229  			else
1230  			{
1231  				_findReplaceDlg.markAll(selectedText, styleID);
1232  			}
1233  		}
1234  		break;
1235  		case IDM_SEARCH_MARKONEEXT1:
1236  		case IDM_SEARCH_MARKONEEXT2:
1237  		case IDM_SEARCH_MARKONEEXT3:
1238  		case IDM_SEARCH_MARKONEEXT4:
1239  		case IDM_SEARCH_MARKONEEXT5:
1240  		{
1241  			int styleID;
1242  			if (id == IDM_SEARCH_MARKONEEXT1)
1243  				styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT1;
1244  			else if (id == IDM_SEARCH_MARKONEEXT2)
1245  				styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT2;
1246  			else if (id == IDM_SEARCH_MARKONEEXT3)
1247  				styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT3;
1248  			else if (id == IDM_SEARCH_MARKONEEXT4)
1249  				styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT4;
1250  			else 
1251  				styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT5;
1252  			Sci_CharacterRangeFull range = _pEditView->getSelection();
1253  			if (range.cpMin == range.cpMax)
1254  			{
1255  				auto caretPos = _pEditView->execute(SCI_GETCURRENTPOS, 0, 0);
1256  				range.cpMin = _pEditView->execute(SCI_WORDSTARTPOSITION, caretPos, true);
1257  				range.cpMax = _pEditView->execute(SCI_WORDENDPOSITION, caretPos, true);
1258  			}
1259  			if (range.cpMax > range.cpMin)
1260  			{
1261  				_pEditView->execute(SCI_SETINDICATORCURRENT, styleID);
1262  				_pEditView->execute(SCI_INDICATORFILLRANGE, range.cpMin, range.cpMax - range.cpMin);
1263  			}
1264  		}
1265  		break;
1266  		case IDM_SEARCH_UNMARKALLEXT1 :
1267  		case IDM_SEARCH_UNMARKALLEXT2 :
1268  		case IDM_SEARCH_UNMARKALLEXT3 :
1269  		case IDM_SEARCH_UNMARKALLEXT4 :
1270  		case IDM_SEARCH_UNMARKALLEXT5 :
1271  		{
1272  			int styleID;
1273  			if (id == IDM_SEARCH_UNMARKALLEXT1)
1274  				styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT1;
1275  			else if (id == IDM_SEARCH_UNMARKALLEXT2)
1276  				styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT2;
1277  			else if (id == IDM_SEARCH_UNMARKALLEXT3)
1278  				styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT3;
1279  			else if (id == IDM_SEARCH_UNMARKALLEXT4)
1280  				styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT4;
1281  			else 
1282  				styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT5;
1283  			_pEditView->clearIndicator(styleID);
1284  		}
1285  		break;
1286  		case IDM_SEARCH_GONEXTMARKER1 :
1287  		case IDM_SEARCH_GONEXTMARKER2 :
1288  		case IDM_SEARCH_GONEXTMARKER3 :
1289  		case IDM_SEARCH_GONEXTMARKER4 :
1290  		case IDM_SEARCH_GONEXTMARKER5 :
1291  		case IDM_SEARCH_GONEXTMARKER_DEF :
1292  		{
1293  			int styleID;
1294  			if (id == IDM_SEARCH_GONEXTMARKER1)
1295  				styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT1;
1296  			else if (id == IDM_SEARCH_GONEXTMARKER2)
1297  				styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT2;
1298  			else if (id == IDM_SEARCH_GONEXTMARKER3)
1299  				styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT3;
1300  			else if (id == IDM_SEARCH_GONEXTMARKER4)
1301  				styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT4;
1302  			else if (id == IDM_SEARCH_GONEXTMARKER5)
1303  				styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT5;
1304  			else 
1305  				styleID = SCE_UNIVERSAL_FOUND_STYLE;
1306  			goToNextIndicator(styleID);
1307  		}
1308  		break;
1309  		case IDM_SEARCH_GOPREVMARKER1 :
1310  		case IDM_SEARCH_GOPREVMARKER2 :
1311  		case IDM_SEARCH_GOPREVMARKER3 :
1312  		case IDM_SEARCH_GOPREVMARKER4 :
1313  		case IDM_SEARCH_GOPREVMARKER5 :
1314  		case IDM_SEARCH_GOPREVMARKER_DEF :
1315  		{
1316  			int styleID;
1317  			if (id == IDM_SEARCH_GOPREVMARKER1)
1318  				styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT1;
1319  			else if (id == IDM_SEARCH_GOPREVMARKER2)
1320  				styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT2;
1321  			else if (id == IDM_SEARCH_GOPREVMARKER3)
1322  				styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT3;
1323  			else if (id == IDM_SEARCH_GOPREVMARKER4)
1324  				styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT4;
1325  			else if (id == IDM_SEARCH_GOPREVMARKER5)
1326  				styleID = SCE_UNIVERSAL_FOUND_STYLE_EXT5;
1327  			else 
1328  				styleID = SCE_UNIVERSAL_FOUND_STYLE;
1329  			goToPreviousIndicator(styleID);	
1330  		}
1331  		break;
1332  		case IDM_SEARCH_CLEARALLMARKS :
1333  		{
1334  			_pEditView->clearIndicator(SCE_UNIVERSAL_FOUND_STYLE_EXT1);
1335  			_pEditView->clearIndicator(SCE_UNIVERSAL_FOUND_STYLE_EXT2);
1336  			_pEditView->clearIndicator(SCE_UNIVERSAL_FOUND_STYLE_EXT3);
1337  			_pEditView->clearIndicator(SCE_UNIVERSAL_FOUND_STYLE_EXT4);
1338  			_pEditView->clearIndicator(SCE_UNIVERSAL_FOUND_STYLE_EXT5);
1339  		}
1340  		break;
1341  		case IDM_SEARCH_STYLE1TOCLIP:
1342  		{
1343  			_pEditView->markedTextToClipboard(SCE_UNIVERSAL_FOUND_STYLE_EXT1);
1344  		}
1345  		break;
1346  		case IDM_SEARCH_STYLE2TOCLIP:
1347  		{
1348  			_pEditView->markedTextToClipboard(SCE_UNIVERSAL_FOUND_STYLE_EXT2);
1349  		}
1350  		break;
1351  		case IDM_SEARCH_STYLE3TOCLIP:
1352  		{
1353  			_pEditView->markedTextToClipboard(SCE_UNIVERSAL_FOUND_STYLE_EXT3);
1354  		}
1355  		break;
1356  		case IDM_SEARCH_STYLE4TOCLIP:
1357  		{
1358  			_pEditView->markedTextToClipboard(SCE_UNIVERSAL_FOUND_STYLE_EXT4);
1359  		}
1360  		break;
1361  		case IDM_SEARCH_STYLE5TOCLIP:
1362  		{
1363  			_pEditView->markedTextToClipboard(SCE_UNIVERSAL_FOUND_STYLE_EXT5);
1364  		}
1365  		break;
1366  		case IDM_SEARCH_ALLSTYLESTOCLIP:
1367  		{
1368  			_pEditView->markedTextToClipboard(-1, true);
1369  		}
1370  		break;
1371  		case IDM_SEARCH_MARKEDTOCLIP:
1372  		{
1373  			_pEditView->markedTextToClipboard(SCE_UNIVERSAL_FOUND_STYLE);
1374  		}
1375  		break;
1376  		case IDM_SEARCH_GOTOLINE:
1377  		{
1378  			bool isFirstTime = !_goToLineDlg.isCreated();
1379  			_goToLineDlg.doDialog(_nativeLangSpeaker.isRTL());
1380  			if (isFirstTime)
1381  				_nativeLangSpeaker.changeDlgLang(_goToLineDlg.getHSelf(), "GoToLine");
1382  		}
1383  		break;
1384  		case IDM_SEARCH_FINDCHARINRANGE :
1385  		{
1386  			bool isFirstTime = !_findCharsInRangeDlg.isCreated();
1387  			_findCharsInRangeDlg.doDialog(_nativeLangSpeaker.isRTL());
1388  			if (isFirstTime)
1389  				_nativeLangSpeaker.changeDlgLang(_findCharsInRangeDlg.getHSelf(), "FindCharsInRange");
1390  		}
1391  		break;
1392          case IDM_EDIT_COLUMNMODETIP :
1393  		{
1394  			_nativeLangSpeaker.messageBox("ColumnModeTip",
1395  					_pPublicInterface->getHSelf(),
1396  					TEXT("There are 3 ways to switch to column-select mode:\r\n\r\n")
1397  					TEXT("1. (Keyboard and Mouse)  Hold Alt while left-click dragging\r\n\r\n")
1398  					TEXT("2. (Keyboard only)  Hold Alt+Shift while using arrow keys\r\n\r\n")
1399  					TEXT("3. (Keyboard or Mouse)\r\n")
1400  					TEXT("      Put caret at desired start of column block position, then\r\n")
1401  					TEXT("       execute \"Begin/End Select in Column Mode\" command;\r\n")
1402  					TEXT("      Move caret to desired end of column block position, then\r\n")
1403  					TEXT("       execute \"Begin/End Select in Column Mode\" command again\r\n"),
1404  					TEXT("Column Mode Tip"),
1405  					MB_OK|MB_APPLMODAL);
1406  		}
1407  		break;
1408          case IDM_EDIT_COLUMNMODE :
1409  		{
1410  			bool isFirstTime = !_colEditorDlg.isCreated();
1411  			_colEditorDlg.doDialog(_nativeLangSpeaker.isRTL());
1412  			if (isFirstTime)
1413  				_nativeLangSpeaker.changeDlgLang(_colEditorDlg.getHSelf(), "ColumnEditor");
1414  		}
1415  		break;
1416  		case IDM_SEARCH_GOTOMATCHINGBRACE :
1417  		case IDM_SEARCH_SELECTMATCHINGBRACES :
1418  		{
1419  			intptr_t braceAtCaret = -1;
1420  			intptr_t braceOpposite = -1;
1421  			findMatchingBracePos(braceAtCaret, braceOpposite);
1422  			if (braceOpposite != -1)
1423  			{
1424  				if (id == IDM_SEARCH_GOTOMATCHINGBRACE)
1425  					_pEditView->execute(SCI_GOTOPOS, braceOpposite);
1426  				else
1427  					_pEditView->execute(SCI_SETSEL, std::min<intptr_t>(braceAtCaret, braceOpposite), std::max<intptr_t>(braceAtCaret, braceOpposite) + 1); 
1428  				_pEditView->execute(SCI_CHOOSECARETX);
1429  			}
1430  		}
1431  		break;
1432          case IDM_SEARCH_TOGGLE_BOOKMARK :
1433  	        bookmarkToggle(-1);
1434              break;
1435  	    case IDM_SEARCH_NEXT_BOOKMARK:
1436  		    bookmarkNext(true);
1437  		    break;
1438  	    case IDM_SEARCH_PREV_BOOKMARK:
1439  		    bookmarkNext(false);
1440  		    break;
1441  	    case IDM_SEARCH_CLEAR_BOOKMARKS:
1442  			bookmarkClearAll();
1443  		    break;
1444          case IDM_LANG_USER_DLG :
1445          {
1446  		    bool isUDDlgVisible = false;
1447  		    UserDefineDialog *udd = _pEditView->getUserDefineDlg();
1448  		    if (!udd->isCreated())
1449  		    {
1450  			    _pEditView->doUserDefineDlg(true, _nativeLangSpeaker.isRTL());
1451  				_nativeLangSpeaker.changeUserDefineLang(udd);
1452  				if (_isUDDocked)
1453  					::SendMessage(udd->getHSelf(), WM_COMMAND, IDC_DOCK_BUTTON, 0);
1454  		    }
1455  			else
1456  			{
1457  				isUDDlgVisible = udd->isVisible();
1458  				bool isUDDlgDocked = udd->isDocked();
1459  				if ((isUDDlgDocked)&&(isUDDlgVisible))
1460  				{
1461  					::ShowWindow(_pMainSplitter->getHSelf(), SW_HIDE);
1462  					if (bothActive())
1463  						_pMainWindow = &_subSplitter;
1464  					else
1465  						_pMainWindow = _pDocTab;
1466  					::SendMessage(_pPublicInterface->getHSelf(), WM_SIZE, 0, 0);
1467  					udd->display(false);
1468  					_mainWindowStatus &= ~WindowUserActive;
1469  				}
1470  				else if ((isUDDlgDocked)&&(!isUDDlgVisible))
1471  				{
1472                      if (!_pMainSplitter)
1473                      {
1474                          _pMainSplitter = new SplitterContainer;
1475                          _pMainSplitter->init(_pPublicInterface->getHinst(), _pPublicInterface->getHSelf());
1476                          Window *pWindow;
1477                          if (bothActive())
1478                              pWindow = &_subSplitter;
1479                          else
1480                              pWindow = _pDocTab;
1481  						int splitterSizeDyn = NppParameters::getInstance()._dpiManager.scaleX(splitterSize);
1482                          _pMainSplitter->create(pWindow, ScintillaEditView::getUserDefineDlg(), splitterSizeDyn, SplitterMode::RIGHT_FIX, 45);
1483                      }
1484  					_pMainWindow = _pMainSplitter;
1485  					_pMainSplitter->setWin0((bothActive())?(Window *)&_subSplitter:(Window *)_pDocTab);
1486  					::SendMessage(_pPublicInterface->getHSelf(), WM_SIZE, 0, 0);
1487  					_pMainWindow->display();
1488  					_mainWindowStatus |= WindowUserActive;
1489  				}
1490  				else if ((!isUDDlgDocked)&&(isUDDlgVisible))
1491  				{
1492  					udd->display(false);
1493  				}
1494  				else 
1495  					udd->display();
1496  			}
1497  			checkMenuItem(IDM_LANG_USER_DLG, !isUDDlgVisible);
1498  			_toolBar.setCheck(IDM_LANG_USER_DLG, !isUDDlgVisible);
1499          }
1500  		break;
1501  		case IDM_EDIT_SELECTALL:
1502  			_pEditView->execute(SCI_SELECTALL);
1503  			checkClipboard();
1504  			break;
1505  		case IDM_EDIT_INS_TAB:
1506  		case IDM_EDIT_RMV_TAB:
1507  		{
1508  			bool forwards = id == IDM_EDIT_INS_TAB;
1509  			size_t selStartPos = _pEditView->execute(SCI_GETSELECTIONSTART);
1510  			size_t lineNumber = _pEditView->execute(SCI_LINEFROMPOSITION, selStartPos);
1511  			size_t numSelections = _pEditView->execute(SCI_GETSELECTIONS);
1512  			size_t selEndPos = _pEditView->execute(SCI_GETSELECTIONEND);
1513  			size_t selEndLineNumber = _pEditView->execute(SCI_LINEFROMPOSITION, selEndPos);
1514  			if ((numSelections > 1) || (lineNumber != selEndLineNumber))
1515  			{
1516  				_pEditView->execute(forwards ? SCI_TAB : SCI_BACKTAB);
1517  			}
1518  			else
1519  			{
1520  				size_t currentIndent = _pEditView->execute(SCI_GETLINEINDENTATION, lineNumber);
1521  				intptr_t indentDelta = _pEditView->execute(SCI_GETTABWIDTH);
1522  				if (!forwards) indentDelta = -indentDelta;
1523  				_pEditView->setLineIndent(lineNumber, static_cast<intptr_t>(currentIndent) + indentDelta);
1524  			}
1525  		}
1526  		break;
1527  		case IDM_EDIT_DUP_LINE:
1528  			_pEditView->execute(SCI_LINEDUPLICATE);
1529  			break;
1530  		case IDM_EDIT_REMOVE_CONSECUTIVE_DUP_LINES:
1531  			_pEditView->execute(SCI_BEGINUNDOACTION);
1532  			removeDuplicateLines();
1533  			_pEditView->execute(SCI_ENDUNDOACTION);
1534  			break;
1535  		case IDM_EDIT_REMOVE_ANY_DUP_LINES:
1536  			_pEditView->execute(SCI_BEGINUNDOACTION);
1537  			_pEditView->removeAnyDuplicateLines();
1538  			_pEditView->execute(SCI_ENDUNDOACTION);
1539  			break;
1540  		case IDM_EDIT_SPLIT_LINES:
1541  		{
1542  			if (_pEditView->execute(SCI_GETSELECTIONS) == 1)
1543  			{
1544  				pair<size_t, size_t> lineRange = _pEditView->getSelectionLinesRange();
1545  				auto anchorPos = _pEditView->execute(SCI_POSITIONFROMLINE, lineRange.first);
1546  				auto caretPos = _pEditView->execute(SCI_GETLINEENDPOSITION, lineRange.second);
1547  				_pEditView->execute(SCI_SETSELECTION, caretPos, anchorPos);
1548  				_pEditView->execute(SCI_TARGETFROMSELECTION);
1549  				size_t edgeMode = _pEditView->execute(SCI_GETEDGEMODE);
1550  				if (edgeMode == EDGE_NONE)
1551  				{
1552  					_pEditView->execute(SCI_LINESSPLIT, 0);
1553  				}
1554  				else
1555  				{
1556  					auto textWidth = _pEditView->execute(SCI_TEXTWIDTH, STYLE_DEFAULT, reinterpret_cast<LPARAM>("P"));
1557  					auto edgeCol = _pEditView->execute(SCI_GETEDGECOLUMN); 
1558  					if (edgeMode == EDGE_MULTILINE)
1559  					{
1560  						NppParameters& nppParam = NppParameters::getInstance();
1561  						ScintillaViewParams& svp = const_cast<ScintillaViewParams&>(nppParam.getSVP());
1562  						edgeCol = svp._edgeMultiColumnPos.back();  
1563  					}
1564  					++edgeCol;  
1565  					_pEditView->execute(SCI_LINESSPLIT, textWidth * edgeCol);
1566  				}
1567  			}
1568  		}
1569  		break;
1570  		case IDM_EDIT_JOIN_LINES:
1571  		{
1572  			const pair<size_t, size_t> lineRange = _pEditView->getSelectionLinesRange();
1573  			if (lineRange.first != lineRange.second)
1574  			{
1575  				auto anchorPos = _pEditView->execute(SCI_POSITIONFROMLINE, lineRange.first);
1576  				auto caretPos = _pEditView->execute(SCI_GETLINEENDPOSITION, lineRange.second);
1577  				_pEditView->execute(SCI_SETSELECTION, caretPos, anchorPos);
1578  				_pEditView->execute(SCI_TARGETFROMSELECTION);
1579  				_pEditView->execute(SCI_LINESJOIN);
1580  			}
1581  		}
1582  		break;
1583  		case IDM_EDIT_LINE_UP:
1584  			_pEditView->currentLinesUp();
1585  			break;
1586  		case IDM_EDIT_LINE_DOWN:
1587  			_pEditView->currentLinesDown();
1588  			break;
1589  		case IDM_EDIT_REMOVEEMPTYLINES:
1590  			_pEditView->execute(SCI_BEGINUNDOACTION);
1591  			removeEmptyLine(false);
1592  			_pEditView->execute(SCI_ENDUNDOACTION);
1593  			break;
1594  		case IDM_EDIT_REMOVEEMPTYLINESWITHBLANK:
1595  			_pEditView->execute(SCI_BEGINUNDOACTION);
1596  			removeEmptyLine(true);
1597  			_pEditView->execute(SCI_ENDUNDOACTION);
1598  			break;
1599  		case IDM_EDIT_UPPERCASE:
1600              _pEditView->convertSelectedTextToUpperCase();
1601  			break;
1602  		case IDM_EDIT_LOWERCASE:
1603              _pEditView->convertSelectedTextToLowerCase();
1604  			break;
1605  		case IDM_EDIT_PROPERCASE_FORCE:
1606  			_pEditView->convertSelectedTextToNewerCase(TITLECASE_FORCE);
1607  			break;
1608  		case IDM_EDIT_PROPERCASE_BLEND:
1609  			_pEditView->convertSelectedTextToNewerCase(TITLECASE_BLEND);
1610  			break;
1611  		case IDM_EDIT_SENTENCECASE_FORCE:
1612  			_pEditView->convertSelectedTextToNewerCase(SENTENCECASE_FORCE);
1613  			break;
1614  		case IDM_EDIT_SENTENCECASE_BLEND:
1615  			_pEditView->convertSelectedTextToNewerCase(SENTENCECASE_BLEND);
1616  			break;
1617  		case IDM_EDIT_INVERTCASE:
1618  			_pEditView->convertSelectedTextToNewerCase(INVERTCASE);
1619  			break;
1620  		case IDM_EDIT_RANDOMCASE:
1621  			_pEditView->convertSelectedTextToNewerCase(RANDOMCASE);
1622  			break;
1623  		case IDM_EDIT_BLOCK_COMMENT:
1624  			doBlockComment(cm_toggle);
1625   			break;
1626  		case IDM_EDIT_BLOCK_COMMENT_SET:
1627  			doBlockComment(cm_comment);
1628  			break;
1629  		case IDM_EDIT_BLOCK_UNCOMMENT:
1630  			doBlockComment(cm_uncomment);
1631  			break;
1632  		case IDM_EDIT_STREAM_COMMENT:
1633  			doStreamComment();
1634  			break;
1635  		case IDM_EDIT_STREAM_UNCOMMENT:
1636  			undoStreamComment();
1637  			break;
1638  		case IDM_EDIT_TRIMTRAILING:
1639  		{
1640  			std::lock_guard<std::mutex> lock(command_mutex);
1641  			_pEditView->execute(SCI_BEGINUNDOACTION);
1642  			doTrim(lineTail);
1643  			_pEditView->execute(SCI_ENDUNDOACTION);
1644  			break;
1645  		}
1646  		case IDM_EDIT_TRIMLINEHEAD:
1647  		{
1648  			std::lock_guard<std::mutex> lock(command_mutex);
1649  			_pEditView->execute(SCI_BEGINUNDOACTION);
1650  			doTrim(lineHeader);
1651  			_pEditView->execute(SCI_ENDUNDOACTION);
1652  			break;
1653  		}
1654  		case IDM_EDIT_TRIM_BOTH:
1655  		{
1656  			std::lock_guard<std::mutex> lock(command_mutex);
1657  			_pEditView->execute(SCI_BEGINUNDOACTION);
1658  			doTrim(lineBoth);
1659  			_pEditView->execute(SCI_ENDUNDOACTION);
1660  			break;
1661  		}
1662  		case IDM_EDIT_EOL2WS:
1663  			_pEditView->execute(SCI_BEGINUNDOACTION);
1664  			eol2ws();
1665  			_pEditView->execute(SCI_ENDUNDOACTION);
1666  			break;
1667  		case IDM_EDIT_TRIMALL:
1668  		{
1669  			std::lock_guard<std::mutex> lock(command_mutex);
1670  			_pEditView->execute(SCI_BEGINUNDOACTION);
1671  			bool isEntireDoc = _pEditView->execute(SCI_GETANCHOR) == _pEditView->execute(SCI_GETCURRENTPOS);
1672  			doTrim(lineBoth);
1673  			if (isEntireDoc || _pEditView->execute(SCI_GETANCHOR) != _pEditView->execute(SCI_GETCURRENTPOS))
1674  				eol2ws();
1675  			_pEditView->execute(SCI_ENDUNDOACTION);
1676  			break;
1677  		}
1678  		case IDM_EDIT_TAB2SW:
1679  			wsTabConvert(tab2Space);
1680  			break;
1681  		case IDM_EDIT_SW2TAB_LEADING:
1682  			wsTabConvert(space2TabLeading);
1683  			break;
1684  		case IDM_EDIT_SW2TAB_ALL:
1685  			wsTabConvert(space2TabAll);
1686  			break;
1687  		case IDM_EDIT_SETREADONLY:
1688  		{
1689  			Buffer * buf = _pEditView->getCurrentBuffer();
1690  			buf->setUserReadOnly(!buf->getUserReadOnly());
1691  		}
1692  		break;
1693  		case IDM_EDIT_CLEARREADONLY:
1694  		{
1695  			Buffer * buf = _pEditView->getCurrentBuffer();
1696  			DWORD dwFileAttribs = ::GetFileAttributes(buf->getFullPathName());
1697  			dwFileAttribs &= ~FILE_ATTRIBUTE_READONLY;
1698  			::SetFileAttributes(buf->getFullPathName(), dwFileAttribs);
1699  			buf->setFileReadOnly(false);
1700  		}
1701  		break;
1702  		case IDM_SEARCH_CUTMARKEDLINES :
1703  			cutMarkedLines();
1704  			break;
1705  		case IDM_SEARCH_COPYMARKEDLINES :
1706  			copyMarkedLines();
1707  			break;
1708  		case IDM_SEARCH_PASTEMARKEDLINES :
1709  			pasteToMarkedLines();
1710  			break;
1711  		case IDM_SEARCH_DELETEMARKEDLINES :
1712  			deleteMarkedLines(true);
1713  			break;
1714  		case IDM_SEARCH_DELETEUNMARKEDLINES :
1715  			deleteMarkedLines(false);
1716  			break;
1717  		case IDM_SEARCH_INVERSEMARKS :
1718  			inverseMarks();
1719  			break;
1720  	    case IDM_VIEW_ALWAYSONTOP:
1721  		{
1722  			int check = (::GetMenuState(_mainMenuHandle, id, MF_BYCOMMAND) == MF_CHECKED)?MF_UNCHECKED:MF_CHECKED;
1723  			::CheckMenuItem(_mainMenuHandle, id, MF_BYCOMMAND | check);
1724  			SetWindowPos(_pPublicInterface->getHSelf(), check == MF_CHECKED?HWND_TOPMOST:HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOMOVE|SWP_NOSIZE);
1725  		}
1726  		break;
1727  		case IDM_VIEW_FOLD_CURRENT:
1728  		case IDM_VIEW_UNFOLD_CURRENT:
1729  		{
1730  			bool isToggleEnabled = NppParameters::getInstance().getNppGUI()._enableFoldCmdToggable;
1731  			bool mode = id == IDM_VIEW_FOLD_CURRENT ? fold_collapse : fold_uncollapse;
1732  			if (isToggleEnabled)
1733  			{
1734  				bool isFolded = _pEditView->isCurrentLineFolded();
1735  				mode = isFolded ? fold_uncollapse : fold_collapse;
1736  			}
1737  			_pEditView->foldCurrentPos(mode);
1738  		}
1739  		break;
1740  		case IDM_VIEW_FOLDALL:
1741  		case IDM_VIEW_UNFOLDALL:
1742  		{
1743  			_isFolding = true; 
1744  			bool doCollapse = (id==IDM_VIEW_FOLDALL)?fold_collapse:fold_uncollapse;
1745   			_pEditView->foldAll(doCollapse);
1746  			if (_pDocMap)
1747  			{
1748  				_pDocMap->foldAll(doCollapse);
1749  			}
1750  			_isFolding = false;
1751  		}
1752  		break;
1753  		case IDM_VIEW_FOLD_1:
1754  		case IDM_VIEW_FOLD_2:
1755  		case IDM_VIEW_FOLD_3:
1756  		case IDM_VIEW_FOLD_4:
1757  		case IDM_VIEW_FOLD_5:
1758  		case IDM_VIEW_FOLD_6:
1759  		case IDM_VIEW_FOLD_7:
1760  		case IDM_VIEW_FOLD_8:
1761  			_isFolding = true; 
1762   			_pEditView->collapse(id - IDM_VIEW_FOLD - 1, fold_collapse);
1763  			_isFolding = false;
1764  			break;
1765  		case IDM_VIEW_UNFOLD_1:
1766  		case IDM_VIEW_UNFOLD_2:
1767  		case IDM_VIEW_UNFOLD_3:
1768  		case IDM_VIEW_UNFOLD_4:
1769  		case IDM_VIEW_UNFOLD_5:
1770  		case IDM_VIEW_UNFOLD_6:
1771  		case IDM_VIEW_UNFOLD_7:
1772  		case IDM_VIEW_UNFOLD_8:
1773  			_isFolding = true; 
1774   			_pEditView->collapse(id - IDM_VIEW_UNFOLD - 1, fold_uncollapse);
1775  			_isFolding = false;
1776  			break;
1777  		case IDM_VIEW_TOOLBAR_REDUCE:
1778  		{
1779              toolBarStatusType state = _toolBar.getState();
1780              if (state != TB_SMALL)
1781              {
1782  			    _toolBar.reduce();
1783              }
1784  		}
1785  		break;
1786  		case IDM_VIEW_TOOLBAR_ENLARGE:
1787  		{
1788              toolBarStatusType state = _toolBar.getState();
1789              if (state != TB_LARGE)
1790              {
1791  			    _toolBar.enlarge();
1792              }
1793  		}
1794  		break;
1795  		case IDM_VIEW_TOOLBAR_REDUCE_SET2:
1796  		{
1797  			toolBarStatusType state = _toolBar.getState();
1798  			if (state != TB_SMALL2)
1799  			{
1800  				_toolBar.reduceToSet2();
1801  			}
1802  		}
1803  		break;
1804  		case IDM_VIEW_TOOLBAR_ENLARGE_SET2:
1805  		{
1806  			toolBarStatusType state = _toolBar.getState();
1807  			if (state != TB_LARGE2)
1808  			{
1809  				_toolBar.enlargeToSet2();
1810  			}
1811  		}
1812  		break;
1813  		case IDM_VIEW_TOOLBAR_STANDARD:
1814  		{
1815  			toolBarStatusType state = _toolBar.getState();
1816              if (state != TB_STANDARD)
1817              {
1818  				_toolBar.setToBmpIcons();
1819  			}
1820  		}
1821  		break;
1822  		case IDM_VIEW_REDUCETABBAR:
1823  		{
1824  			_toReduceTabBar = !_toReduceTabBar;
1825  			auto& dpiManager = NppParameters::getInstance()._dpiManager;
1826  			int tabDpiDynamicalWidth = dpiManager.scaleX(g_TabWidth);
1827  			int tabDpiDynamicalHeight = dpiManager.scaleY(_toReduceTabBar ? g_TabHeight : g_TabHeightLarge);
1828  			TabCtrl_SetItemSize(_mainDocTab.getHSelf(), tabDpiDynamicalWidth, tabDpiDynamicalHeight);
1829  			TabCtrl_SetItemSize(_subDocTab.getHSelf(), tabDpiDynamicalWidth, tabDpiDynamicalHeight);
1830  			const auto& hf = _mainDocTab.getFont(_toReduceTabBar);
1831  			if (hf)
1832  			{
1833  				::SendMessage(_mainDocTab.getHSelf(), WM_SETFONT, reinterpret_cast<WPARAM>(hf), MAKELPARAM(TRUE, 0));
1834  				::SendMessage(_subDocTab.getHSelf(), WM_SETFONT, reinterpret_cast<WPARAM>(hf), MAKELPARAM(TRUE, 0));
1835  			}
1836  			::SendMessage(_pPublicInterface->getHSelf(), WM_SIZE, 0, 0);
1837  			break;
1838  		}
1839  		case IDM_VIEW_REFRESHTABAR :
1840  		{
1841  			::SendMessage(_pPublicInterface->getHSelf(), WM_SIZE, 0, 0);
1842  			break;
1843  		}
1844          case IDM_VIEW_LOCKTABBAR:
1845  		{
1846  			bool isDrag = TabBarPlus::doDragNDropOrNot();
1847              TabBarPlus::doDragNDrop(!isDrag);
1848              break;
1849  		}
1850  		case IDM_VIEW_DRAWTABBAR_INACIVETAB:
1851  		{
1852  			TabBarPlus::setDrawInactiveTab(!TabBarPlus::drawInactiveTab());
1853  			break;
1854  		}
1855  		case IDM_VIEW_DRAWTABBAR_TOPBAR:
1856  		{
1857  			TabBarPlus::setDrawTopBar(!TabBarPlus::drawTopBar());
1858  			break;
1859  		}
1860  		case IDM_VIEW_DRAWTABBAR_CLOSEBOTTUN:
1861  		{
1862  			TabBarPlus::setDrawTabCloseButton(!TabBarPlus::drawTabCloseButton());
1863  			auto& dpiManager = NppParameters::getInstance()._dpiManager;
1864  			int tabDpiDynamicalHeight = dpiManager.scaleY(_toReduceTabBar ? g_TabHeight : g_TabHeightLarge);
1865  			int tabDpiDynamicalWidth = dpiManager.scaleX(TabBarPlus::drawTabCloseButton() ? g_TabWidthCloseBtn : g_TabWidth);
1866  			TabCtrl_SetItemSize(_mainDocTab.getHSelf(), tabDpiDynamicalWidth, tabDpiDynamicalHeight);
1867  			TabCtrl_SetItemSize(_subDocTab.getHSelf(), tabDpiDynamicalWidth, tabDpiDynamicalHeight);
1868  			::SendMessage(_pPublicInterface->getHSelf(), WM_SIZE, 0, 0);
1869  			break;
1870  		}
1871  		case IDM_VIEW_DRAWTABBAR_DBCLK2CLOSE :
1872  		{
1873  			TabBarPlus::setDbClk2Close(!TabBarPlus::isDbClk2Close());
1874  			break;
1875  		}
1876  		case IDM_VIEW_DRAWTABBAR_VERTICAL :
1877  		{
1878  			TabBarPlus::setVertical(!TabBarPlus::isVertical());
1879  			::SendMessage(_pPublicInterface->getHSelf(), WM_SIZE, 0, 0);
1880  			break;
1881  		}
1882  		case IDM_VIEW_DRAWTABBAR_MULTILINE :
1883  		{
1884  			TabBarPlus::setMultiLine(!TabBarPlus::isMultiLine());
1885  			::SendMessage(_pPublicInterface->getHSelf(), WM_SIZE, 0, 0);
1886  			break;
1887  		}
1888  		case IDM_VIEW_FULLSCREENTOGGLE:
1889  		{
1890  			if (!_beforeSpecialView._isDistractionFree)
1891  				fullScreenToggle();
1892  		}
1893  		break;
1894  		case IDM_VIEW_POSTIT :
1895  		{
1896  			if (!_beforeSpecialView._isDistractionFree)
1897  				postItToggle();
1898  		}
1899  		break;
1900  		case IDM_VIEW_DISTRACTIONFREE:
1901  		{
1902  			if ((_beforeSpecialView._isDistractionFree && _beforeSpecialView._isFullScreen && _beforeSpecialView._isPostIt) ||
1903  				(!_beforeSpecialView._isDistractionFree && !_beforeSpecialView._isFullScreen && !_beforeSpecialView._isPostIt))
1904  				distractionFreeToggle();
1905  		}
1906  		break;
1907  		case IDM_VIEW_IN_FIREFOX:
1908  		case IDM_VIEW_IN_CHROME:
1909  		case IDM_VIEW_IN_EDGE:
1910  		case IDM_VIEW_IN_IE:
1911  		{
1912  			auto currentBuf = _pEditView->getCurrentBuffer();
1913  			if (!currentBuf->isUntitled())
1914  			{
1915  				generic_string appName;
1916  				if (id == IDM_VIEW_IN_FIREFOX)
1917  				{
1918  					appName = TEXT("firefox.exe");
1919  				}
1920  				else if (id == IDM_VIEW_IN_CHROME)
1921  				{
1922  					appName = TEXT("chrome.exe");
1923  				}
1924  				else if (id == IDM_VIEW_IN_EDGE)
1925  				{
1926  					appName = TEXT("msedge.exe");
1927  				}
1928  				else 
1929  				{
1930  					appName = TEXT("IEXPLORE.EXE");
1931  				}
1932  				TCHAR valData[MAX_PATH] = {'\0'};
1933  				DWORD valDataLen = MAX_PATH * sizeof(TCHAR);
1934  				DWORD valType = 0;
1935  				HKEY hKey2Check = nullptr;
1936  				generic_string appEntry = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\");
1937  				appEntry += appName;
1938  				::RegOpenKeyEx(HKEY_LOCAL_MACHINE, appEntry.c_str(), 0, KEY_READ, &hKey2Check);
1939  				::RegQueryValueEx(hKey2Check, TEXT(""), nullptr, &valType, reinterpret_cast<LPBYTE>(valData), &valDataLen);
1940  				generic_string fullCurrentPath = TEXT("\"");
1941  				fullCurrentPath += currentBuf->getFullPathName();
1942  				fullCurrentPath += TEXT("\"");
1943  				if (hKey2Check && valData[0] != '\0')
1944  				{
1945  					::ShellExecute(NULL, TEXT("open"), valData, fullCurrentPath.c_str(), NULL, SW_SHOWNORMAL);
1946  				}
1947  				else if (id == IDM_VIEW_IN_EDGE)
1948  				{
1949  					generic_string fullCurrentPath = currentBuf->getFullPathName();
1950  					::ShellExecute(NULL, TEXT("open"), TEXT("shell:Appsfolder\\Microsoft.MicrosoftEdge_8wekyb3d8bbwe!MicrosoftEdge"), fullCurrentPath.c_str(), NULL, SW_SHOW);
1951  				} 
1952  				else 
1953  				{
1954  					_nativeLangSpeaker.messageBox("ViewInBrowser",
1955  						_pPublicInterface->getHSelf(),
1956  						TEXT("Application cannot be found in your system."),
1957  						TEXT("View Current File in Browser"),
1958  						MB_OK);
1959  				}
1960  				::RegCloseKey(hKey2Check);
1961  			}
1962  		}
1963  		break;
1964  		case IDM_VIEW_TAB_SPACE:
1965  		{
1966  			const bool isChecked = !(::GetMenuState(_mainMenuHandle, id, MF_BYCOMMAND) == MF_CHECKED);
1967  			checkMenuItem(id, isChecked);
1968  			_mainEditView.showWSAndTab(isChecked);
1969  			_subEditView.showWSAndTab(isChecked);
1970  			auto& svp1 = const_cast<ScintillaViewParams&>(NppParameters::getInstance().getSVP());
1971  			svp1._whiteSpaceShow = isChecked;
1972  			const bool allChecked = svp1._whiteSpaceShow && svp1._eolShow && svp1._npcShow && svp1._ccUniEolShow;
1973  			checkMenuItem(IDM_VIEW_ALL_CHARACTERS, allChecked);
1974  			_toolBar.setCheck(IDM_VIEW_ALL_CHARACTERS, allChecked);
1975  			break;
1976  		}
1977  		case IDM_VIEW_EOL:
1978  		{
1979  			const bool isChecked = !(::GetMenuState(_mainMenuHandle, id, MF_BYCOMMAND) == MF_CHECKED);
1980  			checkMenuItem(id, isChecked);
1981  			_mainEditView.showEOL(isChecked);
1982  			_subEditView.showEOL(isChecked);
1983  			auto& svp1 = const_cast<ScintillaViewParams&>(NppParameters::getInstance().getSVP());
1984  			svp1._eolShow = isChecked;
1985  			const bool allChecked = svp1._whiteSpaceShow && svp1._eolShow && svp1._npcShow && svp1._ccUniEolShow;
1986  			checkMenuItem(IDM_VIEW_ALL_CHARACTERS, allChecked);
1987  			_toolBar.setCheck(IDM_VIEW_ALL_CHARACTERS, allChecked);
1988  			break;
1989  		}
1990  		case IDM_VIEW_NPC:
1991  		{
1992  			const bool isChecked = !(::GetMenuState(_mainMenuHandle, id, MF_BYCOMMAND) == MF_CHECKED);
1993  			checkMenuItem(id, isChecked);
1994  			auto& svp1 = const_cast<ScintillaViewParams&>(NppParameters::getInstance().getSVP());
1995  			svp1._npcShow = isChecked;
1996  			_mainEditView.showNpc(isChecked);
1997  			_subEditView.showNpc(isChecked);
1998  			const bool allChecked = svp1._whiteSpaceShow && svp1._eolShow && svp1._npcShow && svp1._ccUniEolShow;
1999  			checkMenuItem(IDM_VIEW_ALL_CHARACTERS, allChecked);
2000  			_toolBar.setCheck(IDM_VIEW_ALL_CHARACTERS, allChecked);
2001  			_findReplaceDlg.updateFinderScintillaForNpc();
2002  			break;
2003  		}
2004  		case IDM_VIEW_NPC_CCUNIEOL:
2005  		{
2006  			const bool isChecked = !(::GetMenuState(_mainMenuHandle, id, MF_BYCOMMAND) == MF_CHECKED);
2007  			checkMenuItem(id, isChecked);
2008  			auto& svp1 = const_cast<ScintillaViewParams&>(NppParameters::getInstance().getSVP());
2009  			svp1._ccUniEolShow = isChecked;
2010  			_mainEditView.showCcUniEol(isChecked);
2011  			_subEditView.showCcUniEol(isChecked);
2012  			const bool allChecked = svp1._whiteSpaceShow && svp1._eolShow && svp1._npcShow && svp1._ccUniEolShow;
2013  			checkMenuItem(IDM_VIEW_ALL_CHARACTERS, allChecked);
2014  			_toolBar.setCheck(IDM_VIEW_ALL_CHARACTERS, allChecked);
2015  			break;
2016  		}
2017  		case IDM_VIEW_ALL_CHARACTERS:
2018  		{
2019  			const bool isChecked = !(::GetMenuState(_mainMenuHandle, id, MF_BYCOMMAND) == MF_CHECKED);
2020  			checkMenuItem(id, isChecked);
2021  			checkMenuItem(IDM_VIEW_TAB_SPACE, isChecked);
2022  			checkMenuItem(IDM_VIEW_EOL, isChecked);
2023  			checkMenuItem(IDM_VIEW_NPC, isChecked);
2024  			checkMenuItem(IDM_VIEW_NPC_CCUNIEOL, isChecked);
2025  			_toolBar.setCheck(id, isChecked);
2026  			auto& svp1 = const_cast<ScintillaViewParams&>(NppParameters::getInstance().getSVP());
2027  			svp1._whiteSpaceShow = isChecked;
2028  			svp1._eolShow = isChecked;
2029  			svp1._npcShow = isChecked;
2030  			svp1._ccUniEolShow = isChecked;
2031  			_mainEditView.showInvisibleChars(isChecked);
2032  			_subEditView.showInvisibleChars(isChecked);
2033  			_findReplaceDlg.updateFinderScintillaForNpc();
2034  			break;
2035  		}
2036  		case IDM_VIEW_INDENT_GUIDE:
2037  		{
2038  			_mainEditView.showIndentGuideLine(!_pEditView->isShownIndentGuide());
2039  			_subEditView.showIndentGuideLine(!_pEditView->isShownIndentGuide());
2040              _toolBar.setCheck(IDM_VIEW_INDENT_GUIDE, _pEditView->isShownIndentGuide());
2041  			checkMenuItem(IDM_VIEW_INDENT_GUIDE, _pEditView->isShownIndentGuide());
2042              ScintillaViewParams & svp1 = (ScintillaViewParams &)(NppParameters::getInstance()).getSVP();
2043              svp1._indentGuideLineShow = _pEditView->isShownIndentGuide();
2044  			break;
2045  		}
2046  		case IDM_VIEW_WRAP:
2047  		{
2048  			bool isWraped = !_pEditView->isWrap();
2049  			if (!isWraped)
2050  			{
2051  				_mainEditView.saveCurrentPos();
2052  				_mainEditView.setWrapRestoreNeeded(true);
2053  				_subEditView.saveCurrentPos();
2054  				_subEditView.setWrapRestoreNeeded(true);
2055  			}
2056  			_mainEditView.wrap(isWraped);
2057  			_subEditView.wrap(isWraped);
2058  			_toolBar.setCheck(IDM_VIEW_WRAP, isWraped);
2059  			checkMenuItem(IDM_VIEW_WRAP, isWraped);
2060  			ScintillaViewParams & svp1 = (ScintillaViewParams &)(NppParameters::getInstance()).getSVP();
2061  			svp1._doWrap = isWraped;
2062  			if (_pDocMap)
2063  			{
2064  				_pDocMap->initWrapMap();
2065  				_pDocMap->wrapMap();
2066  			}
2067  			break;
2068  		}
2069  		case IDM_VIEW_WRAP_SYMBOL:
2070  		{
2071  			_mainEditView.showWrapSymbol(!_pEditView->isWrapSymbolVisible());
2072  			_subEditView.showWrapSymbol(!_pEditView->isWrapSymbolVisible());
2073  			checkMenuItem(IDM_VIEW_WRAP_SYMBOL, _pEditView->isWrapSymbolVisible());
2074              ScintillaViewParams & svp1 = (ScintillaViewParams &)(NppParameters::getInstance()).getSVP();
2075              svp1._wrapSymbolShow = _pEditView->isWrapSymbolVisible();
2076  			break;
2077  		}
2078  		case IDM_VIEW_HIDELINES:
2079  		{
2080  			_pEditView->hideLines();
2081  			break;
2082  		}
2083  		case IDM_VIEW_ZOOMIN:
2084  		{
2085  			_pEditView->execute(SCI_ZOOMIN);
2086  			break;
2087  		}
2088  		case IDM_VIEW_ZOOMOUT:
2089  			_pEditView->execute(SCI_ZOOMOUT);
2090  			break;
2091  		case IDM_VIEW_ZOOMRESTORE:
2092  			_pEditView->execute(SCI_SETZOOM, 0);
2093  			break;
2094  		case IDM_VIEW_SYNSCROLLV:
2095  		{
2096              bool isSynScollV = !_syncInfo._isSynScollV;
2097  			checkMenuItem(IDM_VIEW_SYNSCROLLV, isSynScollV);
2098  			_toolBar.setCheck(IDM_VIEW_SYNSCROLLV, isSynScollV);
2099              _syncInfo._isSynScollV = isSynScollV;
2100  			if (_syncInfo._isSynScollV)
2101  			{
2102  				intptr_t mainCurrentLine = _mainEditView.execute(SCI_GETFIRSTVISIBLELINE);
2103  				intptr_t subCurrentLine = _subEditView.execute(SCI_GETFIRSTVISIBLELINE);
2104  				_syncInfo._line = mainCurrentLine - subCurrentLine;
2105  			}
2106  		}
2107  		break;
2108  		case IDM_VIEW_SYNSCROLLH:
2109  		{
2110              bool isSynScollH = !_syncInfo._isSynScollH;
2111  			checkMenuItem(IDM_VIEW_SYNSCROLLH, isSynScollH);
2112  			_toolBar.setCheck(IDM_VIEW_SYNSCROLLH, isSynScollH);
2113              _syncInfo._isSynScollH = isSynScollH;
2114  			if (_syncInfo._isSynScollH)
2115  			{
2116  				intptr_t mxoffset = _mainEditView.execute(SCI_GETXOFFSET);
2117  				intptr_t pixel = _mainEditView.execute(SCI_TEXTWIDTH, STYLE_DEFAULT, reinterpret_cast<LPARAM>("P"));
2118  				intptr_t mainColumn = mxoffset/pixel;
2119  				intptr_t sxoffset = _subEditView.execute(SCI_GETXOFFSET);
2120  				pixel = _subEditView.execute(SCI_TEXTWIDTH, STYLE_DEFAULT, reinterpret_cast<LPARAM>("P"));
2121  				intptr_t subColumn = sxoffset/pixel;
2122  				_syncInfo._column = mainColumn - subColumn;
2123  			}
2124  		}
2125  		break;
2126  		case IDM_VIEW_SUMMARY:
2127  		{
2128  			generic_string characterNumber = TEXT("");
2129  			Buffer * curBuf = _pEditView->getCurrentBuffer();
2130  			int64_t fileLen = curBuf->getFileLength();
2131  			NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
2132  			if (pNativeSpeaker)
2133  			{
2134  				if (fileLen != -1)
2135  				{
2136  					generic_string filePathLabel = pNativeSpeaker->getLocalizedStrFromID("summary-filepath", TEXT("Full file path: "));
2137  					generic_string fileCreateTimeLabel = pNativeSpeaker->getLocalizedStrFromID("summary-filecreatetime", TEXT("Created: "));
2138  					generic_string fileModifyTimeLabel = pNativeSpeaker->getLocalizedStrFromID("summary-filemodifytime", TEXT("Modified: "));
2139  					characterNumber += filePathLabel;
2140  					characterNumber += curBuf->getFullPathName();
2141  					characterNumber += TEXT("\r");
2142  					characterNumber += fileCreateTimeLabel;
2143  					characterNumber += curBuf->getFileTime(Buffer::ft_created);
2144  					characterNumber += TEXT("\r");
2145  					characterNumber += fileModifyTimeLabel;
2146  					characterNumber += curBuf->getFileTime(Buffer::ft_modified);
2147  					characterNumber += TEXT("\r");
2148  				}
2149  				generic_string nbCharLabel = pNativeSpeaker->getLocalizedStrFromID("summary-nbchar", TEXT("Characters (without line endings): "));
2150  				generic_string nbWordLabel = pNativeSpeaker->getLocalizedStrFromID("summary-nbword", TEXT("Words: "));
2151  				generic_string nbLineLabel = pNativeSpeaker->getLocalizedStrFromID("summary-nbline", TEXT("Lines: "));
2152  				generic_string nbByteLabel = pNativeSpeaker->getLocalizedStrFromID("summary-nbbyte", TEXT("Document length: "));
2153  				generic_string nbSelLabel1 = pNativeSpeaker->getLocalizedStrFromID("summary-nbsel1", TEXT(" selected characters ("));
2154  				generic_string nbSelLabel2 = pNativeSpeaker->getLocalizedStrFromID("summary-nbsel2", TEXT(" bytes) in "));
2155  				generic_string nbRangeLabel = pNativeSpeaker->getLocalizedStrFromID("summary-nbrange", TEXT(" ranges"));
2156  				UniMode um = _pEditView->getCurrentBuffer()->getUnicodeMode();
2157  				size_t nbChar = getCurrentDocCharCount(um);
<span onclick='openModal()' class='match'>2158  				int nbWord = wordCount();
2159  				size_t nbLine = _pEditView->execute(SCI_GETLINECOUNT);
2160  				size_t nbByte = _pEditView->execute(SCI_GETLENGTH);
2161  				size_t nbSel = getSelectedCharNumber(um);
2162  				size_t nbSelByte = getSelectedBytes();
2163  				size_t nbRange = getSelectedAreas();
2164  				characterNumber += nbCharLabel;
2165  				characterNumber += commafyInt(nbChar).c_str();
2166  				characterNumber += TEXT("\r");
2167  				characterNumber += nbWordLabel;
2168  				characterNumber += commafyInt(nbWord).c_str();
2169  				characterNumber += TEXT("\r");
2170  				characterNumber += nbLineLabel;
2171  				characterNumber += commafyInt(nbLine).c_str();
</span>2172  				characterNumber += TEXT("\r");
2173  				characterNumber += nbByteLabel;
2174  				characterNumber += commafyInt(nbByte).c_str();
2175  				characterNumber += TEXT("\r");
2176  				characterNumber += commafyInt(nbSel).c_str();
2177  				characterNumber += nbSelLabel1;
2178  				characterNumber += commafyInt(nbSelByte).c_str();
2179  				characterNumber += nbSelLabel2;
2180  				characterNumber += commafyInt(nbRange).c_str();
2181  				characterNumber += nbRangeLabel;
2182  				characterNumber += TEXT("\r");
2183  				generic_string summaryLabel = pNativeSpeaker->getLocalizedStrFromID("summary", TEXT("Summary"));
2184  				::MessageBox(_pPublicInterface->getHSelf(), characterNumber.c_str(), summaryLabel.c_str(), MB_OK|MB_APPLMODAL);
2185  			}
2186  		}
2187  		break;
2188  		case IDM_VIEW_MONITORING:
2189  		{
2190  			Buffer * curBuf = _pEditView->getCurrentBuffer();
2191  			if (curBuf->isMonitoringOn())
2192  			{
2193  				monitoringStartOrStopAndUpdateUI(curBuf, false);
2194  			}
2195  			else
2196  			{
2197  				const TCHAR *longFileName = curBuf->getFullPathName();
2198  				if (::PathFileExists(longFileName))
2199  				{
2200  					if (curBuf->isDirty())
2201  					{
2202  						_nativeLangSpeaker.messageBox("DocTooDirtyToMonitor",
2203  							_pPublicInterface->getHSelf(),
2204  							TEXT("The document is dirty. Please save the modification before monitoring it."),
2205  							TEXT("Monitoring problem"),
2206  							MB_OK);
2207  					}
2208  					else
2209  					{
2210  						monitoringStartOrStopAndUpdateUI(curBuf, true);
2211  						createMonitoringThread(curBuf);
2212  					}
2213  				}
2214  				else
2215  				{
2216  					_nativeLangSpeaker.messageBox("DocNoExistToMonitor",
2217  						_pPublicInterface->getHSelf(),
2218  						TEXT("The file should exist to be monitored."),
2219  						TEXT("Monitoring problem"),
2220  						MB_OK);
2221  				}
2222  			}
2223  			break;
2224  		}
2225  		case IDM_EXECUTE:
2226  		{
2227  			bool isFirstTime = !_runDlg.isCreated();
2228  			_runDlg.doDialog(_nativeLangSpeaker.isRTL());
2229  			if (isFirstTime)
2230  				_nativeLangSpeaker.changeDlgLang(_runDlg.getHSelf(), "Run");
2231  			break;
2232  		}
2233  		case IDM_FORMAT_TODOS:
2234  		case IDM_FORMAT_TOUNIX:
2235  		case IDM_FORMAT_TOMAC:
2236  		{
2237  			EolType newFormat = (id == IDM_FORMAT_TODOS)
2238  				? EolType::windows
2239  				: (id == IDM_FORMAT_TOUNIX) ? EolType::unix : EolType::macos;
2240  			Buffer* buf = _pEditView->getCurrentBuffer();
2241  			if (!buf->isReadOnly())
2242  			{
2243  				std::lock_guard<std::mutex> lock(command_mutex);
2244  				buf->setEolFormat(newFormat);
2245  				_pEditView->execute(SCI_CONVERTEOLS, static_cast<int>(buf->getEolFormat()));
2246  			}
2247  			break;
2248  		}
2249  		case IDM_FORMAT_ANSI :
2250  		case IDM_FORMAT_UTF_8 :
2251  		case IDM_FORMAT_UTF_16BE :
2252  		case IDM_FORMAT_UTF_16LE :
2253  		case IDM_FORMAT_AS_UTF_8 :
2254  		{
2255  			Buffer * buf = _pEditView->getCurrentBuffer();
2256  			UniMode um;
2257  			bool shoulBeDirty = true;
2258  			switch (id)
2259  			{
2260  				case IDM_FORMAT_AS_UTF_8:
2261  					shoulBeDirty = buf->getUnicodeMode() != uni8Bit;
2262  					um = uniCookie;
2263  					break;
2264  				case IDM_FORMAT_UTF_8:
2265  					um = uniUTF8;
2266  					break;
2267  				case IDM_FORMAT_UTF_16BE:
2268  					um = uni16BE;
2269  					break;
2270  				case IDM_FORMAT_UTF_16LE:
2271  					um = uni16LE;
2272  					break;
2273  				default : 
2274  					shoulBeDirty = buf->getUnicodeMode() != uniCookie;
2275  					um = uni8Bit;
2276  			}
2277  			if (buf->getEncoding() != -1)
2278  			{
2279  				if (buf->isDirty())
2280  				{
2281  					int answer = _nativeLangSpeaker.messageBox("SaveCurrentModifWarning",
2282  						_pPublicInterface->getHSelf(),
2283  						TEXT("You should save the current modification.\rAll the saved modifications can not be undone.\r\rContinue?"),
2284  						TEXT("Save Current Modification"),
2285  						MB_YESNO);
2286  					if (answer == IDYES)
2287  					{
2288  						fileSave();
2289  						_pEditView->execute(SCI_EMPTYUNDOBUFFER);
2290  					}
2291  					else
2292  						return;
2293  				}
2294  				if (_pEditView->execute(SCI_CANUNDO) == TRUE)
2295  				{
2296  					generic_string msg, title;
2297  					int answer = _nativeLangSpeaker.messageBox("LoseUndoAbilityWarning",
2298  						_pPublicInterface->getHSelf(),
2299  						TEXT("You should save the current modification.\rAll the saved modifications can not be undone.\r\rContinue?"),
2300  						TEXT("Lose Undo Ability Waning"),
2301  						MB_YESNO);
2302  					if (answer == IDYES)
2303  					{
2304  					}
2305  					else
2306  						return;
2307  				}
2308  				buf->setEncoding(-1);
2309  				if (um == uni8Bit)
2310  					_pEditView->execute(SCI_SETCODEPAGE, CP_ACP);
2311  				else
2312  					buf->setUnicodeMode(um);
2313  				fileReload();
2314  			}
2315  			else
2316  			{
2317  				if (buf->getUnicodeMode() != um)
2318  				{
2319  					buf->setUnicodeMode(um);
2320  					if (shoulBeDirty)
2321  						buf->setDirty(true);
2322  				}
2323  			}
2324  			break;
2325  		}
2326          case IDM_FORMAT_WIN_1250 :
2327          case IDM_FORMAT_WIN_1251 :
2328          case IDM_FORMAT_WIN_1252 :
2329          case IDM_FORMAT_WIN_1253 :
2330          case IDM_FORMAT_WIN_1254 :
2331          case IDM_FORMAT_WIN_1255 :
2332          case IDM_FORMAT_WIN_1256 :
2333          case IDM_FORMAT_WIN_1257 :
2334          case IDM_FORMAT_WIN_1258 :
2335          case IDM_FORMAT_ISO_8859_1  :
2336          case IDM_FORMAT_ISO_8859_2  :
2337          case IDM_FORMAT_ISO_8859_3  :
2338          case IDM_FORMAT_ISO_8859_4  :
2339          case IDM_FORMAT_ISO_8859_5  :
2340          case IDM_FORMAT_ISO_8859_6  :
2341          case IDM_FORMAT_ISO_8859_7  :
2342          case IDM_FORMAT_ISO_8859_8  :
2343          case IDM_FORMAT_ISO_8859_9  :
2344          case IDM_FORMAT_ISO_8859_13 :
2345          case IDM_FORMAT_ISO_8859_14 :
2346          case IDM_FORMAT_ISO_8859_15 :
2347          case IDM_FORMAT_DOS_437 :
2348          case IDM_FORMAT_DOS_720 :
2349          case IDM_FORMAT_DOS_737 :
2350          case IDM_FORMAT_DOS_775 :
2351          case IDM_FORMAT_DOS_850 :
2352          case IDM_FORMAT_DOS_852 :
2353          case IDM_FORMAT_DOS_855 :
2354          case IDM_FORMAT_DOS_857 :
2355          case IDM_FORMAT_DOS_858 :
2356          case IDM_FORMAT_DOS_860 :
2357          case IDM_FORMAT_DOS_861 :
2358          case IDM_FORMAT_DOS_862 :
2359          case IDM_FORMAT_DOS_863 :
2360          case IDM_FORMAT_DOS_865 :
2361          case IDM_FORMAT_DOS_866 :
2362          case IDM_FORMAT_DOS_869 :
2363          case IDM_FORMAT_BIG5 :
2364          case IDM_FORMAT_GB2312 :
2365          case IDM_FORMAT_SHIFT_JIS :
2366          case IDM_FORMAT_KOREAN_WIN :
2367          case IDM_FORMAT_EUC_KR :
2368          case IDM_FORMAT_TIS_620 :
2369          case IDM_FORMAT_MAC_CYRILLIC :
2370          case IDM_FORMAT_KOI8U_CYRILLIC :
2371          case IDM_FORMAT_KOI8R_CYRILLIC :
2372          {
2373  			int index = id - IDM_FORMAT_ENCODE;
2374  			EncodingMapper& em = EncodingMapper::getInstance();
2375  			int encoding = em.getEncodingFromIndex(index);
2376  			if (encoding == -1)
2377  			{
2378  				return;
2379  			}
2380              Buffer* buf = _pEditView->getCurrentBuffer();
2381              if (buf->isDirty())
2382              {
2383  				generic_string warning, title;
2384  				int answer = _nativeLangSpeaker.messageBox("SaveCurrentModifWarning",
2385  					_pPublicInterface->getHSelf(),
2386  					TEXT("You should save the current modification.\rAll the saved modifications can not be undone.\r\rContinue?"),
2387  					TEXT("Save Current Modification"),
2388  					MB_YESNO);
2389                  if (answer == IDYES)
2390                  {
2391                      fileSave();
2392  					_pEditView->execute(SCI_EMPTYUNDOBUFFER);
2393                  }
2394                  else
2395                      return;
2396              }
2397              if (_pEditView->execute(SCI_CANUNDO) == TRUE)
2398              {
2399  				generic_string msg, title;
2400  				int answer = _nativeLangSpeaker.messageBox("LoseUndoAbilityWarning",
2401  					_pPublicInterface->getHSelf(),
2402  					TEXT("You should save the current modification.\rAll the saved modifications can not be undone.\r\rContinue?"),
2403  					TEXT("Lose Undo Ability Waning"),
2404  					MB_YESNO);
2405                  if (answer != IDYES)
2406                      return;
2407              }
2408              if (!buf->isDirty())
2409              {
2410  				buf->setEncoding(encoding);
2411  				buf->setUnicodeMode(uniCookie);
2412  				fileReload();
2413              }
2414  			break;
2415  		}
2416  		case IDM_FORMAT_CONV2_ANSI:
2417  		case IDM_FORMAT_CONV2_AS_UTF_8:
2418  		case IDM_FORMAT_CONV2_UTF_8:
2419  		case IDM_FORMAT_CONV2_UTF_16BE:
2420  		case IDM_FORMAT_CONV2_UTF_16LE:
2421  		{
2422  			int idEncoding = -1;
2423  			Buffer *buf = _pEditView->getCurrentBuffer();
2424              UniMode um = buf->getUnicodeMode();
2425              int encoding = buf->getEncoding();
2426  			switch(id)
2427  			{
2428  				case IDM_FORMAT_CONV2_ANSI:
2429  				{
2430                      if (encoding != -1)
2431                      {
2432                          return;
2433                      }
2434                      else
2435                      {
2436  					    if (um == uni8Bit)
2437  						    return;
2438  					    idEncoding = IDM_FORMAT_ANSI;
2439                      }
2440  					break;
2441  				}
2442  				case IDM_FORMAT_CONV2_AS_UTF_8:
2443  				{
2444                      if (encoding != -1)
2445                      {
2446                          buf->setDirty(true);
2447                          buf->setUnicodeMode(uniCookie);
2448                          buf->setEncoding(-1);
2449                          return;
2450                      }
2451  					idEncoding = IDM_FORMAT_AS_UTF_8;
2452  					if (um == uniCookie)
2453  						return;
2454  					if (um != uni8Bit)
2455  					{
2456  						::SendMessage(_pPublicInterface->getHSelf(), WM_COMMAND, idEncoding, 0);
2457  						_pEditView->execute(SCI_EMPTYUNDOBUFFER);
2458  						return;
2459  					}
2460  					break;
2461  				}
2462  				case IDM_FORMAT_CONV2_UTF_8:
2463  				{
2464                      if (encoding != -1)
2465                      {
2466                          buf->setDirty(true);
2467                          buf->setUnicodeMode(uniUTF8);
2468                          buf->setEncoding(-1);
2469                          return;
2470                      }
2471  					idEncoding = IDM_FORMAT_UTF_8;
2472  					if (um == uniUTF8)
2473  						return;
2474  					if (um != uni8Bit)
2475  					{
2476  						::SendMessage(_pPublicInterface->getHSelf(), WM_COMMAND, idEncoding, 0);
2477  						_pEditView->execute(SCI_EMPTYUNDOBUFFER);
2478  						return;
2479  					}
2480  					break;
2481  				}
2482  				case IDM_FORMAT_CONV2_UTF_16BE:
2483  				{
2484                      if (encoding != -1)
2485                      {
2486                          buf->setDirty(true);
2487                          buf->setUnicodeMode(uni16BE);
2488                          buf->setEncoding(-1);
2489                          return;
2490                      }
2491  					idEncoding = IDM_FORMAT_UTF_16BE;
2492  					if (um == uni16BE)
2493  						return;
2494  					if (um != uni8Bit)
2495  					{
2496  						::SendMessage(_pPublicInterface->getHSelf(), WM_COMMAND, idEncoding, 0);
2497  						_pEditView->execute(SCI_EMPTYUNDOBUFFER);
2498  						return;
2499  					}
2500  					break;
2501  				}
2502  				case IDM_FORMAT_CONV2_UTF_16LE:
2503  				{
2504                      if (encoding != -1)
2505                      {
2506                          buf->setDirty(true);
2507                          buf->setUnicodeMode(uni16LE);
2508                          buf->setEncoding(-1);
2509                          return;
2510                      }
2511  					idEncoding = IDM_FORMAT_UTF_16LE;
2512  					if (um == uni16LE)
2513  						return;
2514  					if (um != uni8Bit)
2515  					{
2516  						::SendMessage(_pPublicInterface->getHSelf(), WM_COMMAND, idEncoding, 0);
2517  						_pEditView->execute(SCI_EMPTYUNDOBUFFER);
2518  						return;
2519  					}
2520  					break;
2521  				}
2522  			}
2523  			if (idEncoding != -1)
2524  			{
2525  				::OpenClipboard(_pPublicInterface->getHSelf());
2526  				HANDLE clipboardData = ::GetClipboardData(CF_TEXT);
2527  				int len = static_cast<int32_t>(::GlobalSize(clipboardData));
2528  				LPVOID clipboardDataPtr = ::GlobalLock(clipboardData);
2529  				HANDLE allocClipboardData = ::GlobalAlloc(GMEM_MOVEABLE, len);
2530  				LPVOID clipboardData2 = ::GlobalLock(allocClipboardData);
2531  				::memcpy(clipboardData2, clipboardDataPtr, len);
2532  				::GlobalUnlock(clipboardData);
2533  				::GlobalUnlock(allocClipboardData);
2534  				::CloseClipboard();
2535  				_pEditView->saveCurrentPos();
2536  				size_t docLen = _pEditView->getCurrentDocLen();
2537  				_pEditView->execute(SCI_COPYRANGE, 0, docLen);
2538  				_pEditView->execute(SCI_CLEARALL);
2539  				::SendMessage(_pPublicInterface->getHSelf(), WM_COMMAND, idEncoding, 0);
2540  				_pEditView->execute(SCI_PASTE);
2541  				_pEditView->restoreCurrentPosPreStep();
2542  				::OpenClipboard(_pPublicInterface->getHSelf());
2543  				::EmptyClipboard();
2544  				::SetClipboardData(CF_TEXT, clipboardData2);
2545  				::CloseClipboard();
2546  				_pEditView->execute(SCI_EMPTYUNDOBUFFER);
2547  				buf->setSavePointDirty(true);
2548  			}
2549  			break;
2550  		}
2551  		case IDM_SETTING_IMPORTPLUGIN :
2552          {
2553              const TCHAR *extFilterName = TEXT("Notepad++ plugin");
2554              const TCHAR *extFilter = TEXT(".dll");
2555              vector<generic_string> copiedFiles = addNppPlugins(extFilterName, extFilter);
2556  			if (copiedFiles.size())
2557  			{
2558  				NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
2559  				pNativeSpeaker->messageBox("NeedToRestartToLoadPlugins",
2560  					_pPublicInterface->getHSelf(),
2561  					TEXT("You have to restart Notepad++ to load plugins you installed."),
2562  					TEXT("Notepad++ need to be relaunched"),
2563  					MB_OK | MB_APPLMODAL);
2564  			}
2565              break;
2566          }
2567          case IDM_SETTING_IMPORTSTYLETHEMS :
2568          {
2569              const TCHAR *extFilterName = TEXT("Notepad++ style theme");
2570              const TCHAR *extFilter = TEXT(".xml");
2571              const TCHAR *destDir = TEXT("themes");
2572              NppParameters& nppParams = NppParameters::getInstance();
2573              ThemeSwitcher & themeSwitcher = nppParams.getThemeSwitcher();
2574              vector<generic_string> copiedFiles = addNppComponents(destDir, extFilterName, extFilter);
2575              for (size_t i = 0, len = copiedFiles.size(); i < len ; ++i)
2576              {
2577                  generic_string themeName(themeSwitcher.getThemeFromXmlFileName(copiedFiles[i].c_str()));
2578  		        if (!themeSwitcher.themeNameExists(themeName.c_str()))
2579  		        {
2580  			        themeSwitcher.addThemeFromXml(copiedFiles[i].c_str());
2581                      if (_configStyleDlg.isCreated())
2582                      {
2583                          _configStyleDlg.addLastThemeEntry();
2584                      }
2585  		        }
2586              }
2587              break;
2588          }
2589  		case IDM_SETTING_PLUGINADM:
2590  		{
2591  			bool isFirstTime = !_pluginsAdminDlg.isCreated();
2592  			_pluginsAdminDlg.doDialog(_nativeLangSpeaker.isRTL());
2593  			if (isFirstTime)
2594  			{
2595  				_nativeLangSpeaker.changePluginsAdminDlgLang(_pluginsAdminDlg);
2596  				_pluginsAdminDlg.updateList();
2597  			}
2598  			break;
2599  		}
2600  		case IDM_SETTING_OPENPLUGINSDIR:
2601  		{
2602  			const TCHAR* pluginHomePath = NppParameters::getInstance().getPluginRootDir();
2603  			if (pluginHomePath && pluginHomePath[0])
2604  			{
2605  				::ShellExecute(NULL, NULL, pluginHomePath, NULL, NULL, SW_SHOWNORMAL);
2606  			}
2607  			break;
2608  		}
2609  		case IDM_SETTING_SHORTCUT_MAPPER :
2610  		case IDM_SETTING_SHORTCUT_MAPPER_MACRO :
2611          case IDM_SETTING_SHORTCUT_MAPPER_RUN :
2612  		{
2613              GridState st = id==IDM_SETTING_SHORTCUT_MAPPER_MACRO?STATE_MACRO:id==IDM_SETTING_SHORTCUT_MAPPER_RUN?STATE_USER:STATE_MENU;
2614  			ShortcutMapper shortcutMapper;
2615              shortcutMapper.init(_pPublicInterface->getHinst(), _pPublicInterface->getHSelf(), st);
2616  			shortcutMapper.doDialog(_nativeLangSpeaker.isRTL());
2617  			shortcutMapper.destroy();
2618  			break;
2619  		}
2620  		case IDM_SETTING_PREFERENCE:
2621  		{
2622  			bool isFirstTime = !_preference.isCreated();
2623  			_preference.doDialog(_nativeLangSpeaker.isRTL());
2624  			if (isFirstTime)
2625  			{
2626  				_nativeLangSpeaker.changePrefereceDlgLang(_preference);
2627  			}
2628  			break;
2629  		}
2630          case IDM_SETTING_EDITCONTEXTMENU :
2631          {
2632  			_nativeLangSpeaker.messageBox("ContextMenuXmlEditWarning",
2633  				_pPublicInterface->getHSelf(),
2634  				TEXT("Editing contextMenu.xml allows you to modify your Notepad++ popup context menu on edit zone.\rYou have to restart your Notepad++ to take effect after modifying contextMenu.xml."),
2635  				TEXT("Editing contextMenu"),
2636  				MB_OK|MB_APPLMODAL);
2637              NppParameters& nppParams = NppParameters::getInstance();
2638              BufferID bufID = doOpen((nppParams.getContextMenuPath()));
2639  			switchToFile(bufID);
2640              break;
2641          }
2642          case IDM_VIEW_GOTO_ANOTHER_VIEW:
2643              docGotoAnotherEditView(TransferMove);
2644  			checkSyncState();
2645  			::SendMessage(_pPublicInterface->getHSelf(), WM_SIZE, 0, 0);
2646              break;
2647          case IDM_VIEW_CLONE_TO_ANOTHER_VIEW:
2648              docGotoAnotherEditView(TransferClone);
2649  			checkSyncState();
2650  			::SendMessage(_pPublicInterface->getHSelf(), WM_SIZE, 0, 0);
2651              break;
2652          case IDM_VIEW_GOTO_NEW_INSTANCE :
2653              docOpenInNewInstance(TransferMove);
2654              break;
2655          case IDM_VIEW_LOAD_IN_NEW_INSTANCE:
2656              docOpenInNewInstance(TransferClone);
2657              break;
2658  		case IDM_VIEW_SWITCHTO_OTHER_VIEW:
2659  		{
2660  			int view_to_focus;
2661  			HWND wnd = GetFocus();
2662  			if (_pEditView->getHSelf() == wnd)
2663  			{
2664  				view_to_focus = otherView();
2665  				if (!viewVisible(view_to_focus)) view_to_focus = _activeView;
2666  			}
2667  			else
2668  			{
2669  				view_to_focus = currentView();
2670  			}
2671  			switchEditViewTo(view_to_focus);
2672  			break;
2673  		}
2674  		case IDM_TOOL_MD5_GENERATE:
2675  		{
2676  			bool isFirstTime = !_md5FromTextDlg.isCreated();
2677  			_md5FromTextDlg.doDialog(_nativeLangSpeaker.isRTL());
2678  			if (isFirstTime)
2679  				_nativeLangSpeaker.changeDlgLang(_md5FromTextDlg.getHSelf(), "MD5FromTextDlg");
2680  		}
2681  		break;
2682  		case IDM_TOOL_MD5_GENERATEFROMFILE:
2683  		{
2684  			bool isFirstTime = !_md5FromFilesDlg.isCreated();
2685  			_md5FromFilesDlg.doDialog(_nativeLangSpeaker.isRTL());
2686  			if (isFirstTime)
2687  				_nativeLangSpeaker.changeDlgLang(_md5FromFilesDlg.getHSelf(), "MD5FromFilesDlg");
2688  		}
2689  		break;
2690  		case IDM_TOOL_MD5_GENERATEINTOCLIPBOARD:
2691  		{
2692  			if (_pEditView->execute(SCI_GETSELECTIONS) == 1)
2693  			{
2694  				size_t selectionStart = _pEditView->execute(SCI_GETSELECTIONSTART);
2695  				size_t selectionEnd = _pEditView->execute(SCI_GETSELECTIONEND);
2696  				intptr_t strLen = selectionEnd - selectionStart;
2697  				if (strLen)
2698  				{
2699  					intptr_t strSize = strLen + 1;
2700  					char *selectedStr = new char[strSize];
2701  					_pEditView->execute(SCI_GETSELTEXT, 0, reinterpret_cast<LPARAM>(selectedStr));
2702  					MD5 md5;
2703  					std::string md5ResultA = md5.digestString(selectedStr);
2704  					std::wstring md5ResultW(md5ResultA.begin(), md5ResultA.end());
2705  					str2Clipboard(md5ResultW, _pPublicInterface->getHSelf());
2706  					delete [] selectedStr;
2707  				}
2708  			}
2709  		}
2710  		break;
2711  		case IDM_TOOL_SHA256_GENERATE:
2712  		{
2713  			bool isFirstTime = !_sha2FromTextDlg.isCreated();
2714  			_sha2FromTextDlg.doDialog(_nativeLangSpeaker.isRTL());
2715  			if (isFirstTime)
2716  				_nativeLangSpeaker.changeDlgLang(_sha2FromTextDlg.getHSelf(), "SHA256FromTextDlg");
2717  		}
2718  		break;
2719  		case IDM_TOOL_SHA256_GENERATEFROMFILE:
2720  		{
2721  			bool isFirstTime = !_sha2FromFilesDlg.isCreated();
2722  			_sha2FromFilesDlg.doDialog(_nativeLangSpeaker.isRTL());
2723  			if (isFirstTime)
2724  				_nativeLangSpeaker.changeDlgLang(_sha2FromFilesDlg.getHSelf(), "SHA256FromFilesDlg");
2725  		}
2726  		break;
2727  		case IDM_TOOL_SHA256_GENERATEINTOCLIPBOARD:
2728  		{
2729  			if (_pEditView->execute(SCI_GETSELECTIONS) == 1)
2730  			{
2731  				size_t selectionStart = _pEditView->execute(SCI_GETSELECTIONSTART);
2732  				size_t selectionEnd = _pEditView->execute(SCI_GETSELECTIONEND);
2733  				intptr_t strLen = selectionEnd - selectionStart;
2734  				if (strLen)
2735  				{
2736  					intptr_t strSize = strLen + 1;
2737  					char *selectedStr = new char[strSize];
2738  					_pEditView->execute(SCI_GETSELTEXT, 0, reinterpret_cast<LPARAM>(selectedStr));
2739  					uint8_t sha2hash[32];
2740  					calc_sha_256(sha2hash, reinterpret_cast<const uint8_t*>(selectedStr), strlen(selectedStr));
2741  					wchar_t sha2hashStr[65] = { '\0' };
2742  					for (size_t i = 0; i < 32; i++)
2743  						wsprintf(sha2hashStr + i * 2, TEXT("%02x"), sha2hash[i]);
2744  					str2Clipboard(sha2hashStr, _pPublicInterface->getHSelf());
2745  					delete[] selectedStr;
2746  				}
2747  			}
2748  		}
2749  		break;
2750  		case IDM_DEBUGINFO:
2751  		{
2752  			_debugInfoDlg.doDialog();
2753  			break;
2754  		}
2755          case IDM_ABOUT:
2756  		{
2757  			bool doAboutDlg = false;
2758  			const int maxSelLen = 32;
2759  			auto textLen = _pEditView->execute(SCI_GETSELTEXT, 0, 0);
2760  			if (textLen <= 0)
2761  				doAboutDlg = true;
2762  			if (textLen > maxSelLen)
2763  				doAboutDlg = true;
2764  			if (!doAboutDlg)
2765  			{
2766  				char author[maxSelLen+1] = "";
2767  				_pEditView->getSelectedText(author, maxSelLen + 1);
2768  				WcharMbcsConvertor& wmc = WcharMbcsConvertor::getInstance();
2769  				const wchar_t * authorW = wmc.char2wchar(author, _nativeLangSpeaker.getLangEncoding());
2770  				int iQuote = getQuoteIndexFrom(authorW);
2771  				if (iQuote == -1)
2772  				{
2773  					doAboutDlg = true;
2774  				}
2775  				else if (iQuote == -2)
2776  				{
2777  					generic_string noEasterEggsPath((NppParameters::getInstance()).getNppPath());
2778  					noEasterEggsPath.append(TEXT("\\noEasterEggs.xml"));
2779  					if (!::PathFileExists(noEasterEggsPath.c_str()))
2780  						showAllQuotes();
2781  					return;
2782  				}
2783  				if (iQuote != -1)
2784  				{
2785  					generic_string noEasterEggsPath((NppParameters::getInstance()).getNppPath());
2786  					noEasterEggsPath.append(TEXT("\\noEasterEggs.xml"));
2787  					if (!::PathFileExists(noEasterEggsPath.c_str()))
2788  						showQuoteFromIndex(iQuote);
2789  					return;
2790  				}
2791  			}
2792  			if (doAboutDlg)
2793  			{
2794  				_aboutDlg.doDialog();
2795  			}
2796  			break;
2797  		}
2798  		case IDM_HOMESWEETHOME :
2799  		{
2800  			::ShellExecute(NULL, TEXT("open"), TEXT("https:&bsol;&bsol;notepad-plus-plus.org/"), NULL, NULL, SW_SHOWNORMAL);
2801  			break;
2802  		}
2803  		case IDM_PROJECTPAGE :
2804  		{
2805  			::ShellExecute(NULL, TEXT("open"), TEXT("https:&bsol;&bsol;github.com/notepad-plus-plus/notepad-plus-plus/"), NULL, NULL, SW_SHOWNORMAL);
2806  			break;
2807  		}
2808  		case IDM_ONLINEDOCUMENT:
2809  		{
2810  			::ShellExecute(NULL, TEXT("open"), TEXT("https:&bsol;&bsol;npp-user-manual.org/"), NULL, NULL, SW_SHOWNORMAL);
2811  			break;
2812  		}
2813  		case IDM_CMDLINEARGUMENTS:
2814  		{
2815  			::MessageBox(_pPublicInterface->getHSelf(), COMMAND_ARG_HELP, TEXT("Notepad++ Command Argument Help"), MB_OK | MB_APPLMODAL);
2816  			break;
2817  		}
2818  		case IDM_FORUM:
2819  		{
2820  			::ShellExecute(NULL, TEXT("open"), TEXT("https:&bsol;&bsol;community.notepad-plus-plus.org/"), NULL, NULL, SW_SHOWNORMAL);
2821  			break;
2822  		}
2823  		case IDM_UPDATE_NPP :
2824  		case IDM_CONFUPDATERPROXY :
2825  		{
2826  			winVer ver = NppParameters::getInstance().getWinVersion();
2827  			if (ver <= WV_XP)
2828  			{
2829  				long res = _nativeLangSpeaker.messageBox("XpUpdaterProblem",
2830  					_pPublicInterface->getHSelf(),
2831  					TEXT("Notepad++ updater is not compatible with XP due to the obsolete security layer under XP.\rDo you want to go to Notepad++ page to download the latest version?"),
2832  					TEXT("Notepad++ Updater"),
2833  					MB_YESNO);
2834  				if (res == IDYES)
2835  				{
2836  					::ShellExecute(NULL, TEXT("open"), TEXT("https:&bsol;&bsol;notepad-plus-plus.org/downloads/"), NULL, NULL, SW_SHOWNORMAL);
2837  				}
2838  			}
2839  			else
2840  			{
2841  				generic_string updaterDir = (NppParameters::getInstance()).getNppPath();
2842  				pathAppend(updaterDir, TEXT("updater"));
2843  				generic_string updaterFullPath = updaterDir;
2844  				pathAppend(updaterFullPath, TEXT("gup.exe"));
2845  #ifdef DEBUG 
2846  				bool isCertifVerified = true;
2847  #else 
2848  				SecurityGuard securityGuard;
2849  				bool isCertifVerified = securityGuard.checkModule(updaterFullPath, nm_gup);
2850  #endif
2851  				if (isCertifVerified)
2852  				{
2853  					generic_string param;
2854  					if (id == IDM_CONFUPDATERPROXY)
2855  					{
2856  						if (!_isAdministrator)
2857  						{
2858  							_nativeLangSpeaker.messageBox("GUpProxyConfNeedAdminMode",
2859  								_pPublicInterface->getHSelf(),
2860  								TEXT("Please relaunch Notepad++ in Admin mode to configure proxy."),
2861  								TEXT("Proxy Settings"),
2862  								MB_OK | MB_APPLMODAL);
2863  							return;
2864  						}
2865  						param = TEXT("-options");
2866  					}
2867  					else
2868  					{
2869  						param = TEXT("-verbose -v");
2870  						param += VERSION_VALUE;
2871  						int archType = NppParameters::getInstance().archType();
2872  						if (archType == IMAGE_FILE_MACHINE_AMD64)
2873  						{
2874  							param += TEXT(" -px64");
2875  						}
2876  						else if (archType == IMAGE_FILE_MACHINE_ARM64)
2877  						{
2878  							param += TEXT(" -parm64");
2879  						}
2880  					}
2881  					Process updater(updaterFullPath.c_str(), param.c_str(), updaterDir.c_str());
2882  					updater.run();
2883  				}
2884  			}
2885  			break;
2886  		}
2887  		case IDM_EDIT_AUTOCOMPLETE :
2888  			showAutoComp();
2889  			break;
2890  		case IDM_EDIT_AUTOCOMPLETE_CURRENTFILE :
2891  			autoCompFromCurrentFile();
2892  			break;
2893  		case IDM_EDIT_AUTOCOMPLETE_PATH :
2894  			showPathCompletion();
2895  			break;
2896  		case IDM_EDIT_FUNCCALLTIP :
2897  			showFunctionComp();
2898  			break;
2899  		case IDM_EDIT_FUNCCALLTIP_PREVIOUS :
2900  			showFunctionNextHint(false);
2901  			break;
2902  		case IDM_EDIT_FUNCCALLTIP_NEXT :
2903  			showFunctionNextHint();
2904  			break;
2905          case IDM_LANGSTYLE_CONFIG_DLG :
2906  		{
2907  			if (!(NppParameters::getInstance()).isStylerDocLoaded())
2908  			{
2909  			}
2910  			else
2911  			{
2912  				bool isFirstTime = !_configStyleDlg.isCreated();
2913  				_configStyleDlg.doDialog(_nativeLangSpeaker.isRTL());
2914  				if (isFirstTime)
2915  					_nativeLangSpeaker.changeConfigLang(_configStyleDlg.getHSelf());
2916  			}
2917  			break;
2918  		}
2919          case IDM_LANG_C	:
2920          case IDM_LANG_CPP :
2921          case IDM_LANG_JAVA :
2922          case IDM_LANG_CS :
2923          case IDM_LANG_HTML :
2924          case IDM_LANG_XML :
2925          case IDM_LANG_JS :
2926  		case IDM_LANG_JSON :
2927  		case IDM_LANG_JSON5 :
2928          case IDM_LANG_PHP :
2929          case IDM_LANG_ASP :
2930          case IDM_LANG_CSS :
2931          case IDM_LANG_LUA :
2932          case IDM_LANG_PERL :
2933          case IDM_LANG_PYTHON :
2934          case IDM_LANG_PASCAL :
2935          case IDM_LANG_BATCH :
2936          case IDM_LANG_OBJC :
2937          case IDM_LANG_VB :
2938          case IDM_LANG_SQL :
2939          case IDM_LANG_MSSQL :
2940          case IDM_LANG_ASCII :
2941          case IDM_LANG_TEXT :
2942          case IDM_LANG_RC :
2943          case IDM_LANG_MAKEFILE :
2944          case IDM_LANG_INI :
2945          case IDM_LANG_TEX :
2946          case IDM_LANG_FORTRAN :
2947  		case IDM_LANG_FORTRAN_77 :
2948          case IDM_LANG_BASH :
2949          case IDM_LANG_FLASH :
2950  		case IDM_LANG_NSIS :
2951  		case IDM_LANG_TCL :
2952  		case IDM_LANG_LISP :
2953  		case IDM_LANG_SCHEME :
2954  		case IDM_LANG_ASM :
2955  		case IDM_LANG_DIFF :
2956  		case IDM_LANG_PROPS :
2957  		case IDM_LANG_PS:
2958  		case IDM_LANG_RUBY:
2959  		case IDM_LANG_SMALLTALK:
2960  		case IDM_LANG_VHDL :
2961          case IDM_LANG_KIX :
2962          case IDM_LANG_CAML :
2963          case IDM_LANG_ADA :
2964          case IDM_LANG_VERILOG :
2965  		case IDM_LANG_MATLAB :
2966  		case IDM_LANG_HASKELL :
2967          case IDM_LANG_AU3 :
2968  		case IDM_LANG_INNO :
2969  		case IDM_LANG_CMAKE :
2970  		case IDM_LANG_YAML :
2971          case IDM_LANG_COBOL :
2972          case IDM_LANG_D :
2973          case IDM_LANG_GUI4CLI :
2974          case IDM_LANG_POWERSHELL :
2975          case IDM_LANG_R :
2976          case IDM_LANG_JSP :
2977  		case IDM_LANG_COFFEESCRIPT:
2978  		case IDM_LANG_BAANC:
2979  		case IDM_LANG_SREC:
2980  		case IDM_LANG_IHEX:
2981  		case IDM_LANG_TEHEX:
2982  		case IDM_LANG_SWIFT:
2983          case IDM_LANG_ASN1 :
2984          case IDM_LANG_AVS :
2985          case IDM_LANG_BLITZBASIC :
2986          case IDM_LANG_PUREBASIC :
2987          case IDM_LANG_FREEBASIC :
2988          case IDM_LANG_CSOUND :
2989          case IDM_LANG_ERLANG :
2990          case IDM_LANG_ESCRIPT :
2991          case IDM_LANG_FORTH :
2992          case IDM_LANG_LATEX :
2993          case IDM_LANG_MMIXAL :
2994          case IDM_LANG_NIM :
2995          case IDM_LANG_NNCRONTAB :
2996          case IDM_LANG_OSCRIPT :
2997          case IDM_LANG_REBOL :
2998          case IDM_LANG_REGISTRY :
2999          case IDM_LANG_RUST :
3000          case IDM_LANG_SPICE :
3001          case IDM_LANG_TXT2TAGS :
3002          case IDM_LANG_VISUALPROLOG:
3003  		case IDM_LANG_TYPESCRIPT:
3004  		case IDM_LANG_GDSCRIPT:
3005  		case IDM_LANG_HOLLYWOOD:
3006  		case IDM_LANG_USER :
3007  		{
3008              setLanguage(menuID2LangType(id));
3009  			Buffer *buffer = _pEditView->getCurrentBuffer();
3010  			buffer->langHasBeenSetFromMenu();
3011  			if (_pDocMap)
3012  			{
3013  				_pDocMap->setSyntaxHiliting();
3014  			}
3015  		}
3016          break;
3017  		case IDM_LANG_OPENUDLDIR:
3018  		{
3019  			generic_string userDefineLangFolderPath = NppParameters::getInstance().getUserDefineLangFolderPath();
3020  			::ShellExecute(_pPublicInterface->getHSelf(), TEXT("open"), userDefineLangFolderPath.c_str(), NULL, NULL, SW_SHOW);
3021  			break;
3022  		}
3023  		case IDM_LANG_UDLCOLLECTION_PROJECT_SITE:
3024  		{
3025  			::ShellExecute(NULL, TEXT("open"), TEXT("https:&bsol;&bsol;github.com/notepad-plus-plus/userDefinedLanguages"), NULL, NULL, SW_SHOWNORMAL);
3026  			break;
3027  		}
3028          case IDC_PREV_DOC :
3029          case IDC_NEXT_DOC :
3030          {
3031  			size_t nbDoc = viewVisible(MAIN_VIEW) ? _mainDocTab.nbItem() : 0;
3032  			nbDoc += viewVisible(SUB_VIEW)?_subDocTab.nbItem():0;
3033  			bool doTaskList = ((NppParameters::getInstance()).getNppGUI())._doTaskList;
3034  			_isFolding = true;
3035  			if (nbDoc > 1)
3036  			{
3037  				bool direction = (id == IDC_NEXT_DOC)?dirDown:dirUp;
3038  				if (!doTaskList)
3039  				{
3040  					activateNextDoc(direction);
3041  				}
3042  				else
3043  				{
3044  					if (TaskListDlg::_instanceCount == 0)
3045  					{
3046  						TaskListDlg tld;
3047  						HIMAGELIST hImgLst = nullptr;
3048  						const int tabIconSet = NppDarkMode::getTabIconSet(NppDarkMode::isEnabled());
3049  						switch (tabIconSet)
3050  						{
3051  							case 1:
3052  							{
3053  								hImgLst = _docTabIconListAlt.getHandle();
3054  								break;
3055  							}
3056  							case 2:
3057  							{
3058  								hImgLst = _docTabIconListDarkMode.getHandle();
3059  								break;
3060  							}
3061  							default:
3062  								hImgLst = _docTabIconList.getHandle();
3063  						}
3064  						tld.init(_pPublicInterface->getHinst(), _pPublicInterface->getHSelf(), hImgLst, direction);
3065  						tld.doDialog(_nativeLangSpeaker.isRTL());
3066  					}
3067  				}
3068  			}
3069  			_isFolding = false;
3070  			_linkTriggered = true;
3071  		}
3072          break;
3073  		case IDM_OPEN_ALL_RECENT_FILE :
3074  		{
3075  			BufferID lastOne = BUFFER_INVALID;
3076  			int size = _lastRecentFileList.getSize();
3077  			for (int i = size - 1; i >= 0; i--)
3078  			{
3079  				BufferID test = doOpen(_lastRecentFileList.getIndex(i));
3080  				if (test != BUFFER_INVALID)
3081  					lastOne = test;
3082  			}
3083  			if (lastOne != BUFFER_INVALID)
3084  			{
3085  				switchToFile(lastOne);
3086  			}
3087  			break;
3088  		}
3089  		case IDM_CLEAN_RECENT_FILE_LIST :
3090  			_lastRecentFileList.clear();
3091  			break;
3092  		case IDM_EDIT_RTL :
3093  		case IDM_EDIT_LTR :
3094  		{
3095  			bool toRTL = id == IDM_EDIT_RTL;
3096  			bool isRTL = _pEditView->isTextDirectionRTL();
3097  			if ((toRTL && isRTL) || (!toRTL && !isRTL))
3098  			{
3099  				if (! ((NppParameters::getInstance()).getNppGUI())._muteSounds)
3100  					::MessageBeep(MB_OK);
3101  				break;
3102  			}
3103  			_pEditView->changeTextDirection(toRTL);
3104  			_pNonEditView->changeTextDirection(toRTL);
3105  			bool isWraped = _pEditView->isWrap();
3106  			_pEditView->wrap(!isWraped);
3107  			_pEditView->wrap(isWraped);
3108  			_pNonEditView->wrap(!isWraped);
3109  			_pNonEditView->wrap(isWraped);
3110  			if (_pDocMap)
3111  			{
3112  				_pDocMap->changeTextDirection(toRTL);
3113  			}
3114  		}
3115  		break;
3116  		case IDM_WINDOW_WINDOWS :
3117  		{
3118  			WindowsDlg _windowsDlg;
3119  			_windowsDlg.init(_pPublicInterface->getHinst(), _pPublicInterface->getHSelf(), _pDocTab);
3120              const TiXmlNodeA *nativeLangA = _nativeLangSpeaker.getNativeLangA();
3121  			TiXmlNodeA *dlgNode = NULL;
3122  			if (nativeLangA)
3123  			{
3124  				dlgNode = nativeLangA->FirstChild("Dialog");
3125  				if (dlgNode)
3126  					dlgNode = _nativeLangSpeaker.searchDlgNode(dlgNode, "Window");
3127  			}
3128  			_windowsDlg.doDialog();
3129  		}
3130  		break;
3131  		case IDM_WINDOW_SORT_FN_ASC :
3132  		{
3133  			WindowsDlg windowsDlg;
3134  			windowsDlg.init(_pPublicInterface->getHinst(), _pPublicInterface->getHSelf(), _pDocTab);
3135  			windowsDlg.sortFileNameASC();
3136  			windowsDlg.doSort();
3137  		}
3138  		break;
3139  		case IDM_WINDOW_SORT_FN_DSC :
3140  		{
3141  			WindowsDlg windowsDlg;
3142  			windowsDlg.init(_pPublicInterface->getHinst(), _pPublicInterface->getHSelf(), _pDocTab);
3143  			windowsDlg.sortFileNameDSC();
3144  			windowsDlg.doSort();
3145  		}
3146  		break;
3147  		case IDM_WINDOW_SORT_FP_ASC :
3148  		{
3149  			WindowsDlg windowsDlg;
3150  			windowsDlg.init(_pPublicInterface->getHinst(), _pPublicInterface->getHSelf(), _pDocTab);
3151  			windowsDlg.sortFilePathASC();
3152  			windowsDlg.doSort();
3153  		}
3154  		break;
3155  		case IDM_WINDOW_SORT_FP_DSC :
3156  		{
3157  			WindowsDlg windowsDlg;
3158  			windowsDlg.init(_pPublicInterface->getHinst(), _pPublicInterface->getHSelf(), _pDocTab);
3159  			windowsDlg.sortFilePathDSC();
3160  			windowsDlg.doSort();
3161  		}
3162  		break;
3163  		case IDM_WINDOW_SORT_FT_ASC :
3164  		{
3165  			WindowsDlg windowsDlg;
3166  			windowsDlg.init(_pPublicInterface->getHinst(), _pPublicInterface->getHSelf(), _pDocTab);
3167  			windowsDlg.sortFileTypeASC();
3168  			windowsDlg.doSort();
3169  		}
3170  		break;
3171  		case IDM_WINDOW_SORT_FT_DSC :
3172  		{
3173  			WindowsDlg windowsDlg;
3174  			windowsDlg.init(_pPublicInterface->getHinst(), _pPublicInterface->getHSelf(), _pDocTab);
3175  			windowsDlg.sortFileTypeDSC();
3176  			windowsDlg.doSort();
3177  		}
3178  		break;
3179  		case IDM_WINDOW_SORT_FS_ASC :
3180  		{
3181  			WindowsDlg windowsDlg;
3182  			windowsDlg.init(_pPublicInterface->getHinst(), _pPublicInterface->getHSelf(), _pDocTab);
3183  			windowsDlg.sortFileSizeASC();
3184  			windowsDlg.doSort();
3185  		}
3186  		break;
3187  		case IDM_WINDOW_SORT_FS_DSC :
3188  		{
3189  			WindowsDlg windowsDlg;
3190  			windowsDlg.init(_pPublicInterface->getHinst(), _pPublicInterface->getHSelf(), _pDocTab);
3191  			windowsDlg.sortFileSizeDSC();
3192  			windowsDlg.doSort();
3193  		}
3194  		break;
3195  		case IDM_SYSTRAYPOPUP_NEWDOC:
3196  		{
3197  			NppGUI & nppGUI = (NppParameters::getInstance()).getNppGUI();
3198  			::ShowWindow(_pPublicInterface->getHSelf(), nppGUI._isMaximized?SW_MAXIMIZE:SW_SHOW);
3199  			_dockingManager.showFloatingContainers(true);
3200  			restoreMinimizeDialogs();
3201  			fileNew();
3202  		}
3203  		break;
3204  		case IDM_SYSTRAYPOPUP_ACTIVATE :
3205  		{
3206  			NppGUI & nppGUI = (NppParameters::getInstance()).getNppGUI();
3207  			::ShowWindow(_pPublicInterface->getHSelf(), nppGUI._isMaximized?SW_MAXIMIZE:SW_SHOW);
3208  			_dockingManager.showFloatingContainers(true);
3209  			restoreMinimizeDialogs();
3210  			::SendMessage(_pPublicInterface->getHSelf(), WM_SIZE, 0, 0);
3211  		}
3212  		break;
3213  		case IDM_SYSTRAYPOPUP_NEW_AND_PASTE:
3214  		{
3215  			NppGUI & nppGUI = (NppParameters::getInstance()).getNppGUI();
3216  			::ShowWindow(_pPublicInterface->getHSelf(), nppGUI._isMaximized?SW_MAXIMIZE:SW_SHOW);
3217  			_dockingManager.showFloatingContainers(true);
3218  			restoreMinimizeDialogs();
3219  			BufferID bufferID = _pEditView->getCurrentBufferID();
3220  			Buffer * buf = MainFileManager.getBufferByID(bufferID);
3221  			if (!buf->isUntitled() || buf->docLength() != 0)
3222  			{
3223  				fileNew();
3224  			}
3225  			command(IDM_EDIT_PASTE);
3226  		}
3227  		break;
3228  		case IDM_SYSTRAYPOPUP_OPENFILE:
3229  		{
3230  			NppGUI & nppGUI = (NppParameters::getInstance()).getNppGUI();
3231  			::ShowWindow(_pPublicInterface->getHSelf(), nppGUI._isMaximized?SW_MAXIMIZE:SW_SHOW);
3232  			_dockingManager.showFloatingContainers(true);
3233  			restoreMinimizeDialogs();
3234  			::SendMessage(_pPublicInterface->getHSelf(), WM_SIZE, 0, 0);
3235  			fileOpen();
3236  		}
3237  		break;
3238  		case IDM_SYSTRAYPOPUP_CLOSE:
3239  		{
3240  			_pPublicInterface->setIsPrelaunch(false);
3241  			_pTrayIco->doTrayIcon(REMOVE);
3242  			if (!::IsWindowVisible(_pPublicInterface->getHSelf()))
3243  				::SendMessage(_pPublicInterface->getHSelf(), WM_CLOSE, 0,0);
3244  		}
3245  		break;
3246  		case IDM_FILE_RESTORELASTCLOSEDFILE:
3247  		{
3248  			generic_string lastOpenedFullPath = _lastRecentFileList.getFirstItem();
3249  			if (!lastOpenedFullPath.empty())
3250  			{
3251  				BufferID lastOpened = doOpen(lastOpenedFullPath);
3252  				if (lastOpened != BUFFER_INVALID)
3253  					switchToFile(lastOpened);
3254  			}
3255  		}
3256  		break;
3257  		case IDM_VIEW_LINENUMBER:
3258  		case IDM_VIEW_SYMBOLMARGIN:
3259  		{
3260  			int margin;
3261  			if (id == IDM_VIEW_LINENUMBER)
3262  				margin = ScintillaEditView::_SC_MARGE_LINENUMBER;
3263  			else 
3264  				margin = ScintillaEditView::_SC_MARGE_SYMBOL;
3265  			if (_mainEditView.hasMarginShowed(margin))
3266  			{
3267  				_mainEditView.showMargin(margin, false);
3268  				_subEditView.showMargin(margin, false);
3269  			}
3270  			else
3271  			{
3272  				_mainEditView.showMargin(margin);
3273  				_subEditView.showMargin(margin);
3274  			}
3275  		}
3276  		break;
3277  		case IDM_VIEW_FOLDERMAGIN_SIMPLE:
3278  		case IDM_VIEW_FOLDERMAGIN_ARROW:
3279  		case IDM_VIEW_FOLDERMAGIN_CIRCLE:
3280  		case IDM_VIEW_FOLDERMAGIN_BOX:
3281  		case IDM_VIEW_FOLDERMAGIN:
3282  		{
3283  			folderStyle fStyle = (id == IDM_VIEW_FOLDERMAGIN_SIMPLE) ? FOLDER_STYLE_SIMPLE : \
3284  				(id == IDM_VIEW_FOLDERMAGIN_ARROW) ? FOLDER_STYLE_ARROW : \
3285  				(id == IDM_VIEW_FOLDERMAGIN_CIRCLE) ? FOLDER_STYLE_CIRCLE : \
3286  				(id == IDM_VIEW_FOLDERMAGIN) ? FOLDER_STYLE_NONE : FOLDER_STYLE_BOX;
3287  			_mainEditView.setMakerStyle(fStyle);
3288  			_subEditView.setMakerStyle(fStyle);
3289  		}
3290  		break;
3291  		case IDM_VIEW_CURLINE_HILITING:
3292  		{
3293  			NppParameters& nppParams = NppParameters::getInstance();
3294  			const ScintillaViewParams& svp = nppParams.getSVP();
3295  			const COLORREF bgColour { nppParams.getCurLineHilitingColour() };
3296  			const LPARAM frameWidth { (svp._currentLineHiliteMode == LINEHILITE_FRAME) ? svp._currentLineFrameWidth : 0 };
3297  			if (svp._currentLineHiliteMode != LINEHILITE_NONE)
3298  			{
3299  				_mainEditView.execute(SCI_SETELEMENTCOLOUR, SC_ELEMENT_CARET_LINE_BACK, bgColour);
3300  				_subEditView.execute(SCI_SETELEMENTCOLOUR, SC_ELEMENT_CARET_LINE_BACK, bgColour);
3301  			}
3302  			else
3303  			{
3304  				_mainEditView.execute(SCI_RESETELEMENTCOLOUR, SC_ELEMENT_CARET_LINE_BACK, 0);
3305  				_subEditView.execute(SCI_RESETELEMENTCOLOUR, SC_ELEMENT_CARET_LINE_BACK, 0);
3306  			}
3307  			_mainEditView.execute(SCI_SETCARETLINEFRAME, frameWidth);
3308  			_subEditView.execute(SCI_SETCARETLINEFRAME, frameWidth);
3309  		}
3310  		break;
3311  		case IDM_VIEW_LWDEF:
3312  		case IDM_VIEW_LWALIGN:
3313  		case IDM_VIEW_LWINDENT:
3314  		{
3315  			int mode = (id == IDM_VIEW_LWALIGN) ? SC_WRAPINDENT_SAME : \
3316  				(id == IDM_VIEW_LWINDENT) ? SC_WRAPINDENT_INDENT : SC_WRAPINDENT_FIXED;
3317  			_mainEditView.execute(SCI_SETWRAPINDENTMODE, mode);
3318  			_subEditView.execute(SCI_SETWRAPINDENTMODE, mode);
3319  		}
3320  		break;
3321  		default :
3322  			if (id > IDM_FILEMENU_LASTONE && id < (IDM_FILEMENU_LASTONE + _lastRecentFileList.getMaxNbLRF() + 1))
3323  			{
3324  				BufferID lastOpened = doOpen(_lastRecentFileList.getItem(id));
3325  				if (lastOpened != BUFFER_INVALID)
3326  				{
3327  					switchToFile(lastOpened);
3328  				}
3329  			}
3330  			else if ((id > IDM_LANG_USER) && (id < IDM_LANG_USER_LIMIT))
3331  			{
3332  				TCHAR langName[menuItemStrLenMax];
3333  				::GetMenuString(_mainMenuHandle, id, langName, menuItemStrLenMax, MF_BYCOMMAND);
3334  				_pEditView->getCurrentBuffer()->setLangType(L_USER, langName);
3335  				if (_pDocMap)
3336  				{
3337  					_pDocMap->setSyntaxHiliting();
3338  				}
3339  			}
3340  			else if ((id >= IDM_LANG_EXTERNAL) && (id <= IDM_LANG_EXTERNAL_LIMIT))
3341  			{
3342  				setLanguage((LangType)(id - IDM_LANG_EXTERNAL + L_EXTERNAL));
3343  				if (_pDocMap)
3344  				{
3345  					_pDocMap->setSyntaxHiliting();
3346  				}
3347  			}
3348  			else if ((id >= ID_MACRO) && (id < ID_MACRO_LIMIT))
3349  			{
3350  				int i = id - ID_MACRO;
3351  				vector<MacroShortcut> & theMacros = (NppParameters::getInstance()).getMacroList();
3352  				macroPlayback(theMacros[i].getMacro());
3353  			}
3354  			else if ((id >= ID_USER_CMD) && (id < ID_USER_CMD_LIMIT))
3355  			{
3356  				int i = id - ID_USER_CMD;
3357  				vector<UserCommand> & theUserCommands = (NppParameters::getInstance()).getUserCommandList();
3358  				UserCommand ucmd = theUserCommands[i];
3359  				Command cmd(string2wstring(ucmd.getCmd(), CP_UTF8));
3360  				cmd.run(_pPublicInterface->getHSelf());
3361  			}
3362  			else if ((id >= ID_PLUGINS_CMD) && (id < ID_PLUGINS_CMD_LIMIT))
3363  			{
3364  				int i = id - ID_PLUGINS_CMD;
3365  				_pluginsManager.runPluginCommand(i);
3366  			}
3367  			else if (_pluginsManager.inDynamicRange(id)) 
3368  			{
3369  				_pluginsManager.relayNppMessages(WM_COMMAND, id, 0);
3370  			}
3371  			else if ((id >= IDM_WINDOW_MRU_FIRST) && (id <= IDM_WINDOW_MRU_LIMIT))
3372  			{
3373  				activateDoc(id - IDM_WINDOW_MRU_FIRST);
3374  			}
3375  			else if ((id >= IDM_DROPLIST_MRU_FIRST) && (id < (IDM_DROPLIST_MRU_FIRST + static_cast<int32_t>(_pDocTab->nbItem()))))
3376  			{
3377  				activateDoc(id - IDM_DROPLIST_MRU_FIRST);
3378  			}
3379  	}
3380  	if (_recordingMacro)
3381  		switch (id)
3382  		{
3383  			case IDM_FILE_NEW :
3384  			case IDM_FILE_CLOSE :
3385  			case IDM_FILE_CLOSEALL :
3386  			case IDM_FILE_CLOSEALL_BUT_CURRENT :
3387  			case IDM_FILE_CLOSEALL_TOLEFT :
3388  			case IDM_FILE_CLOSEALL_TORIGHT :
3389  			case IDM_FILE_CLOSEALL_UNCHANGED:
3390  			case IDM_FILE_SAVE :
3391  			case IDM_FILE_SAVEALL :
3392  			case IDM_FILE_RELOAD:
3393  			case IDM_EDIT_UNDO:
3394  			case IDM_EDIT_REDO:
3395  			case IDM_EDIT_CUT:
3396  			case IDM_EDIT_COPY:
3397  			case IDM_EDIT_DELETE:
3398  			case IDM_SEARCH_FINDNEXT :
3399  			case IDM_SEARCH_FINDPREV :
3400              case IDM_SEARCH_SETANDFINDNEXT :
3401  			case IDM_SEARCH_SETANDFINDPREV :
3402  			case IDM_SEARCH_GOTOMATCHINGBRACE :
3403  			case IDM_SEARCH_SELECTMATCHINGBRACES :
3404  			case IDM_SEARCH_TOGGLE_BOOKMARK :
3405  			case IDM_SEARCH_NEXT_BOOKMARK:
3406  			case IDM_SEARCH_PREV_BOOKMARK:
3407  			case IDM_SEARCH_CLEAR_BOOKMARKS:
3408  			case IDM_SEARCH_INVERSEMARKS:
3409  			case IDM_EDIT_SELECTALL:
3410  			case IDM_EDIT_INS_TAB:
3411  			case IDM_EDIT_RMV_TAB:
3412  			case IDM_EDIT_DUP_LINE:
3413  			case IDM_EDIT_REMOVE_CONSECUTIVE_DUP_LINES:
3414  			case IDM_EDIT_REMOVE_ANY_DUP_LINES:
3415  			case IDM_EDIT_TRANSPOSE_LINE:
3416  			case IDM_EDIT_SPLIT_LINES:
3417  			case IDM_EDIT_JOIN_LINES:
3418  			case IDM_EDIT_LINE_UP:
3419  			case IDM_EDIT_LINE_DOWN:
3420  			case IDM_EDIT_REMOVEEMPTYLINES:
3421  			case IDM_EDIT_REMOVEEMPTYLINESWITHBLANK:
3422  			case IDM_EDIT_UPPERCASE:
3423  			case IDM_EDIT_LOWERCASE:
3424  			case IDM_EDIT_PROPERCASE_FORCE:
3425  			case IDM_EDIT_PROPERCASE_BLEND:
3426  			case IDM_EDIT_SENTENCECASE_FORCE:
3427  			case IDM_EDIT_SENTENCECASE_BLEND:
3428  			case IDM_EDIT_INVERTCASE:
3429  			case IDM_EDIT_RANDOMCASE:
3430  			case IDM_EDIT_BLOCK_COMMENT:
3431  			case IDM_EDIT_BLOCK_COMMENT_SET:
3432  			case IDM_EDIT_BLOCK_UNCOMMENT:
3433  			case IDM_EDIT_STREAM_COMMENT:
3434  			case IDM_EDIT_TRIMTRAILING:
3435  			case IDM_EDIT_TRIMLINEHEAD:
3436  			case IDM_EDIT_TRIM_BOTH:
3437  			case IDM_EDIT_EOL2WS:
3438  			case IDM_EDIT_TRIMALL:
3439  			case IDM_EDIT_TAB2SW:
3440  			case IDM_EDIT_SW2TAB_ALL:
3441  			case IDM_EDIT_SW2TAB_LEADING:
3442  			case IDM_EDIT_SETREADONLY :
3443  			case IDM_EDIT_FULLPATHTOCLIP :
3444  			case IDM_EDIT_FILENAMETOCLIP :
3445  			case IDM_EDIT_CURRENTDIRTOCLIP :
3446  			case IDM_EDIT_CLEARREADONLY :
3447  			case IDM_EDIT_RTL :
3448  			case IDM_EDIT_LTR :
3449  			case IDM_EDIT_BEGINENDSELECT:
3450  			case IDM_EDIT_BEGINENDSELECT_COLUMNMODE:
3451  			case IDM_EDIT_SORTLINES_LEXICOGRAPHIC_ASCENDING:
3452  			case IDM_EDIT_SORTLINES_LEXICOGRAPHIC_DESCENDING:
3453  			case IDM_EDIT_SORTLINES_LEXICO_CASE_INSENS_ASCENDING:
3454  			case IDM_EDIT_SORTLINES_LEXICO_CASE_INSENS_DESCENDING:
3455  			case IDM_EDIT_SORTLINES_INTEGER_ASCENDING:
3456  			case IDM_EDIT_SORTLINES_INTEGER_DESCENDING:
3457  			case IDM_EDIT_SORTLINES_DECIMALCOMMA_ASCENDING:
3458  			case IDM_EDIT_SORTLINES_DECIMALCOMMA_DESCENDING:
3459  			case IDM_EDIT_SORTLINES_DECIMALDOT_ASCENDING:
3460  			case IDM_EDIT_SORTLINES_DECIMALDOT_DESCENDING:
3461  			case IDM_EDIT_SORTLINES_REVERSE_ORDER:
3462  			case IDM_EDIT_SORTLINES_RANDOMLY:
3463  			case IDM_EDIT_BLANKLINEABOVECURRENT:
3464  			case IDM_EDIT_BLANKLINEBELOWCURRENT:
3465  			case IDM_VIEW_FULLSCREENTOGGLE :
3466  			case IDM_VIEW_ALWAYSONTOP :
3467  			case IDM_VIEW_WRAP :
3468  			case IDM_VIEW_FOLD_CURRENT :
3469  			case IDM_VIEW_UNFOLD_CURRENT :
3470  			case IDM_VIEW_FOLDALL:
3471  			case IDM_VIEW_UNFOLDALL:
3472  			case IDM_VIEW_FOLD_1:
3473  			case IDM_VIEW_FOLD_2:
3474  			case IDM_VIEW_FOLD_3:
3475  			case IDM_VIEW_FOLD_4:
3476  			case IDM_VIEW_FOLD_5:
3477  			case IDM_VIEW_FOLD_6:
3478  			case IDM_VIEW_FOLD_7:
3479  			case IDM_VIEW_FOLD_8:
3480  			case IDM_VIEW_UNFOLD_1:
3481  			case IDM_VIEW_UNFOLD_2:
3482  			case IDM_VIEW_UNFOLD_3:
3483  			case IDM_VIEW_UNFOLD_4:
3484  			case IDM_VIEW_UNFOLD_5:
3485  			case IDM_VIEW_UNFOLD_6:
3486  			case IDM_VIEW_UNFOLD_7:
3487  			case IDM_VIEW_UNFOLD_8:
3488  			case IDM_VIEW_GOTO_ANOTHER_VIEW:
3489  			case IDM_VIEW_SYNSCROLLV:
3490  			case IDM_VIEW_SYNSCROLLH:
3491  			case IDM_VIEW_TAB1:
3492  			case IDM_VIEW_TAB2:
3493  			case IDM_VIEW_TAB3:
3494  			case IDM_VIEW_TAB4:
3495  			case IDM_VIEW_TAB5:
3496  			case IDM_VIEW_TAB6:
3497  			case IDM_VIEW_TAB7:
3498  			case IDM_VIEW_TAB8:
3499  			case IDM_VIEW_TAB9:
3500  			case IDM_VIEW_TAB_NEXT:
3501  			case IDM_VIEW_TAB_PREV:
3502  			case IDM_VIEW_TAB_MOVEFORWARD:
3503  			case IDM_VIEW_TAB_MOVEBACKWARD:
3504  			case IDC_PREV_DOC :
3505  			case IDC_NEXT_DOC :
3506  			case IDM_SEARCH_GOPREVMARKER1   :
3507  			case IDM_SEARCH_GOPREVMARKER2   :
3508  			case IDM_SEARCH_GOPREVMARKER3   :
3509  			case IDM_SEARCH_GOPREVMARKER4   :
3510  			case IDM_SEARCH_GOPREVMARKER5   :
3511  			case IDM_SEARCH_GOPREVMARKER_DEF:
3512  			case IDM_SEARCH_GONEXTMARKER1   :
3513  			case IDM_SEARCH_GONEXTMARKER2   :
3514  			case IDM_SEARCH_GONEXTMARKER3   :
3515  			case IDM_SEARCH_GONEXTMARKER4   :
3516  			case IDM_SEARCH_GONEXTMARKER5   :
3517  			case IDM_SEARCH_GONEXTMARKER_DEF:
3518  			case IDM_SEARCH_STYLE1TOCLIP:
3519  			case IDM_SEARCH_STYLE2TOCLIP:
3520  			case IDM_SEARCH_STYLE3TOCLIP:
3521  			case IDM_SEARCH_STYLE4TOCLIP:
3522  			case IDM_SEARCH_STYLE5TOCLIP:
3523  			case IDM_SEARCH_ALLSTYLESTOCLIP:
3524  			case IDM_SEARCH_MARKEDTOCLIP:
3525  			case IDM_SEARCH_VOLATILE_FINDNEXT:
3526  			case IDM_SEARCH_VOLATILE_FINDPREV:
3527  			case IDM_SEARCH_CUTMARKEDLINES   :
3528  			case IDM_SEARCH_COPYMARKEDLINES     :
3529  			case IDM_SEARCH_PASTEMARKEDLINES    :
3530  			case IDM_SEARCH_DELETEMARKEDLINES   :
3531  			case IDM_SEARCH_DELETEUNMARKEDLINES :
3532  			case IDM_SEARCH_MARKALLEXT1      :
3533  			case IDM_SEARCH_MARKALLEXT2      :
3534  			case IDM_SEARCH_MARKALLEXT3      :
3535  			case IDM_SEARCH_MARKALLEXT4      :
3536  			case IDM_SEARCH_MARKALLEXT5      :
3537  			case IDM_SEARCH_MARKONEEXT1      :
3538  			case IDM_SEARCH_MARKONEEXT2      :
3539  			case IDM_SEARCH_MARKONEEXT3      :
3540  			case IDM_SEARCH_MARKONEEXT4      :
3541  			case IDM_SEARCH_MARKONEEXT5      :
3542  			case IDM_SEARCH_UNMARKALLEXT1    :
3543  			case IDM_SEARCH_UNMARKALLEXT2    :
3544  			case IDM_SEARCH_UNMARKALLEXT3    :
3545  			case IDM_SEARCH_UNMARKALLEXT4    :
3546  			case IDM_SEARCH_UNMARKALLEXT5    :
3547  			case IDM_SEARCH_CLEARALLMARKS    :
3548  			case IDM_FORMAT_TODOS  :
3549  			case IDM_FORMAT_TOUNIX :
3550  			case IDM_FORMAT_TOMAC  :
3551  			case IDM_VIEW_IN_FIREFOX :
3552  			case IDM_VIEW_IN_CHROME  :
3553  			case IDM_VIEW_IN_EDGE    :
3554  			case IDM_VIEW_IN_IE      :
3555  			case IDM_EDIT_COPY_ALL_NAMES:
3556  			case IDM_EDIT_COPY_ALL_PATHS:
3557  				_macro.push_back(recordedMacroStep(id));
3558  				break;
3559  			case IDM_EDIT_INSERT_DATETIME_SHORT:
3560  			case IDM_EDIT_INSERT_DATETIME_LONG:
3561  			case IDM_EDIT_INSERT_DATETIME_CUSTOMIZED:
3562  			{
3563  				size_t lastIndex = _macro.size();
3564  				if (lastIndex >= 2)
3565  				{
3566  					--lastIndex;
3567  					if (_macro[lastIndex]._message == SCI_ADDTEXT && _macro[lastIndex - 1]._message == SCI_REPLACESEL)
3568  					{
3569  						_macro.erase(_macro.begin() + lastIndex);
3570  						--lastIndex;
3571  						_macro.erase(_macro.begin() + lastIndex);
3572  					}
3573  				}
3574  				_macro.push_back(recordedMacroStep(id));
3575  			}
3576  			break;
3577  		}
3578  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-Printer.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-NppCommands.cpp</div>
                </div>
                <div class="column column_space"><pre><code>147  	frPrint.hdc = _pdlg.hDC;
148  	frPrint.hdcTarget = _pdlg.hDC;
149  	frPrint.rc.left = rectMargins.left - rectPhysMargins.left;
150  	frPrint.rc.top = rectMargins.top - rectPhysMargins.top;
151  	frPrint.rc.right = ptPage.x - rectMargins.right - rectPhysMargins.left;
152  	frPrint.rc.bottom = ptPage.y - rectMargins.bottom - rectPhysMargins.top;
153  	frPrint.rcPage.left = 0;
154  	frPrint.rcPage.top = 0;
155  	frPrint.rcPage.right = ptPage.x - rectPhysMargins.left - rectPhysMargins.right - 1;
156  	frPrint.rcPage.bottom = ptPage.y - rectPhysMargins.top - rectPhysMargins.bottom - 1;
157  	frPrint.rc.top += printMarge;
158  	frPrint.rc.bottom -= printMarge;
159  	frPrint.rc.left += printMarge;
160  	frPrint.rc.right -= printMarge;
</pre></code></div>
                <div class="column column_space"><pre><code>2158  				int nbWord = wordCount();
2159  				size_t nbLine = _pEditView->execute(SCI_GETLINECOUNT);
2160  				size_t nbByte = _pEditView->execute(SCI_GETLENGTH);
2161  				size_t nbSel = getSelectedCharNumber(um);
2162  				size_t nbSelByte = getSelectedBytes();
2163  				size_t nbRange = getSelectedAreas();
2164  				characterNumber += nbCharLabel;
2165  				characterNumber += commafyInt(nbChar).c_str();
2166  				characterNumber += TEXT("\r");
2167  				characterNumber += nbWordLabel;
2168  				characterNumber += commafyInt(nbWord).c_str();
2169  				characterNumber += TEXT("\r");
2170  				characterNumber += nbLineLabel;
2171  				characterNumber += commafyInt(nbLine).c_str();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    