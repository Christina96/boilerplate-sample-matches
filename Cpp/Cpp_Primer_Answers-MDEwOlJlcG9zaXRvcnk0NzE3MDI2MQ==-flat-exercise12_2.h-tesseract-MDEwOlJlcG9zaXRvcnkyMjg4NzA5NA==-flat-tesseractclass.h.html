
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.166666666666666%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>Cpp_Primer_Answers-MDEwOlJlcG9zaXRvcnk0NzE3MDI2MQ==-flat-exercise12_2.h</h3>
            <pre><code>1  #include <vector>
2  #include <memory>
3  #include <string>
4  #include <initializer_list>
5  #include <exception>
6  using std::vector; using std::string;
7  class StrBlob
8  {
9  public:
10  	using size_type = vector<string>::size_type;
11  	StrBlob() :data(std::make_shared<vector<string>>()) {}
<span onclick='openModal()' class='match'>12  	StrBlob(std::initializer_list<string> il) : data(std::make_shared<vector<string>>(il)) {}
13  	size_type size() const
14  	{
15  		return data->size();
16  	}
17  	bool empty() const
18  	{
19  		return data->empty();
20  	}
</span>21  	void push_back(const string& s) const
22  	{
23  		data->push_back(s);
24  	}
25  	void pop_back() const
26  	{
27  		check(0, "pop_back on empty StrBlob");
28  		data->pop_back();
29  	}
30  	string& front()
31  	{
32  		check(0, "front on empty StrBlob");
33  		return data->front();
34  	}
35  	string& back()
36  	{
37  		check(0, "back on empty StrBlob");
38  		return data->back();
39  	}
40  	const string& front() const
41  	{
42  		check(0, "front on empty StrBlob");
43  		return data->front();
44  	}
45  	const string& back() const
46  	{
47  		check(0, "back on empty StrBlob");
48  		return data->back();
49  	}
50  private:
51  	void check(size_type i, const string& msg) const
52  	{
53  		if (i >= data->size())
54  			throw std::out_of_range(msg);
55  	}
56  private:
57  	std::shared_ptr<vector<string>> data;
58  };
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-tesseractclass.h</h3>
            <pre><code>1  #ifndef TESSERACT_CCMAIN_TESSERACTCLASS_H_
2  #define TESSERACT_CCMAIN_TESSERACTCLASS_H_
3  #ifdef HAVE_CONFIG_H
4  #  include "config_auto.h" 
5  #endif
6  #include "control.h"               
7  #include "debugpixa.h"             
8  #include "devanagari_processing.h" 
9  #ifndef DISABLED_LEGACY_ENGINE
10  #  include "docqual.h" 
11  #endif
12  #include "genericvector.h"   
13  #include "pageres.h"         
14  #include "params.h"          
15  #include "points.h"          
16  #include "ratngs.h"          
17  #include "tessdatamanager.h" 
18  #include "textord.h"         
19  #include "wordrec.h"         
20  #include <tesseract/publictypes.h> 
21  #include <tesseract/unichar.h>     
22  #include <allheaders.h> 
23  #include <cstdint> 
24  #include <cstdio>  
25  namespace tesseract {
26  class BLOCK_LIST;
27  class ETEXT_DESC;
28  struct OSResults;
29  class PAGE_RES;
30  class PAGE_RES_IT;
31  class ROW;
32  class SVMenuNode;
33  class TBOX;
34  class TO_BLOCK_LIST;
35  class WERD;
36  class WERD_CHOICE;
37  class WERD_RES;
38  class ColumnFinder;
39  class DocumentData;
40  #ifndef DISABLED_LEGACY_ENGINE
41  class EquationDetect;
42  #endif 
43  class ImageData;
44  class LSTMRecognizer;
45  class Tesseract;
46  struct TesseractStats {
47    TesseractStats()
48        : adaption_word_number(0)
49        , doc_blob_quality(0)
50        , doc_outline_errs(0)
51        , doc_char_quality(0)
52        , good_char_count(0)
53        , doc_good_char_quality(0)
54        , word_count(0)
55        , dict_words(0)
56        , tilde_crunch_written(false)
57        , last_char_was_newline(true)
58        , last_char_was_tilde(false)
59        , write_results_empty_block(true) {}
60    int32_t adaption_word_number;
61    int16_t doc_blob_quality;
62    int16_t doc_outline_errs;
63    int16_t doc_char_quality;
64    int16_t good_char_count;
65    int16_t doc_good_char_quality;
66    int32_t word_count;    
67    int32_t dict_words;    
68    std::string dump_words_str; 
69    bool tilde_crunch_written;
70    bool last_char_was_newline;
71    bool last_char_was_tilde;
72    bool write_results_empty_block;
73  };
74  struct WordData {
75    WordData() : word(nullptr), row(nullptr), block(nullptr), prev_word(nullptr) {}
76    explicit WordData(const PAGE_RES_IT &page_res_it)
77        : word(page_res_it.word())
78        , row(page_res_it.row()->row)
79        , block(page_res_it.block()->block)
80        , prev_word(nullptr) {}
81    WordData(BLOCK *block_in, ROW *row_in, WERD_RES *word_res)
82        : word(word_res), row(row_in), block(block_in), prev_word(nullptr) {}
83    WERD_RES *word;
84    ROW *row;
85    BLOCK *block;
86    WordData *prev_word;
87    PointerVector<WERD_RES> lang_words;
88  };
89  using WordRecognizer = void (Tesseract::*)(const WordData &, WERD_RES **,
90                                             PointerVector<WERD_RES> *);
91  class TESS_API Tesseract : public Wordrec {
92  public:
93    Tesseract();
94    ~Tesseract() override;
95    Dict &getDict() override;
96    void Clear();
97    void ResetAdaptiveClassifier();
98    void ResetDocumentDictionary();
99  #ifndef DISABLED_LEGACY_ENGINE
100    void SetEquationDetect(EquationDetect *detector);
101  #endif 
102    const FCOORD &reskew() const {
103      return reskew_;
104    }
105    Image *mutable_pix_binary() {
106      pix_binary_.destroy();
107      return &pix_binary_;
<span onclick='openModal()' class='match'>108    }
109    Image pix_binary() const {
110      return pix_binary_;
111    }
112    Image pix_grey() const {
113      return pix_grey_;
114    }
</span>115    void set_pix_grey(Image grey_pix) {
116      pix_grey_.destroy();
117      pix_grey_ = grey_pix;
118    }
119    Image pix_original() const {
120      return pix_original_;
121    }
122    void set_pix_original(Image original_pix) {
123      pix_original_.destroy();
124      pix_original_ = original_pix;
125      for (auto &lang : sub_langs_) {
126        lang->set_pix_original(original_pix ? original_pix.clone() : nullptr);
127      }
128    }
129    Image BestPix() const {
130      if (pixGetWidth(pix_original_) == ImageWidth()) {
131        return pix_original_;
132      } else if (pix_grey_ != nullptr) {
133        return pix_grey_;
134      } else {
135        return pix_binary_;
136      }
137    }
138    void set_pix_thresholds(Image thresholds) {
139      pix_thresholds_.destroy();
140      pix_thresholds_ = thresholds;
141    }
142    int source_resolution() const {
143      return source_resolution_;
144    }
145    void set_source_resolution(int ppi) {
146      source_resolution_ = ppi;
147    }
148    int ImageWidth() const {
149      return pixGetWidth(pix_binary_);
150    }
151    int ImageHeight() const {
152      return pixGetHeight(pix_binary_);
153    }
154    Image scaled_color() const {
155      return scaled_color_;
156    }
157    int scaled_factor() const {
158      return scaled_factor_;
159    }
160    void SetScaledColor(int factor, Image color) {
161      scaled_factor_ = factor;
162      scaled_color_ = color;
163    }
164    const Textord &textord() const {
165      return textord_;
166    }
167    Textord *mutable_textord() {
168      return &textord_;
169    }
170    bool right_to_left() const {
171      return right_to_left_;
172    }
173    int num_sub_langs() const {
174      return sub_langs_.size();
175    }
176    Tesseract *get_sub_lang(int index) const {
177      return sub_langs_[index];
178    }
179    bool AnyTessLang() const {
180      if (tessedit_ocr_engine_mode != OEM_LSTM_ONLY) {
181        return true;
182      }
183      for (auto &lang : sub_langs_) {
184        if (lang->tessedit_ocr_engine_mode != OEM_LSTM_ONLY) {
185          return true;
186        }
187      }
188      return false;
189    }
190    bool AnyLSTMLang() const {
191      if (tessedit_ocr_engine_mode != OEM_TESSERACT_ONLY) {
192        return true;
193      }
194      for (auto &lang : sub_langs_) {
195        if (lang->tessedit_ocr_engine_mode != OEM_TESSERACT_ONLY) {
196          return true;
197        }
198      }
199      return false;
200    }
201    void SetBlackAndWhitelist();
202    void PrepareForPageseg();
203    void PrepareForTessOCR(BLOCK_LIST *block_list, Tesseract *osd_tess, OSResults *osr);
204    int SegmentPage(const char *input_file, BLOCK_LIST *blocks, Tesseract *osd_tess, OSResults *osr);
205    void SetupWordScripts(BLOCK_LIST *blocks);
206    int AutoPageSeg(PageSegMode pageseg_mode, BLOCK_LIST *blocks, TO_BLOCK_LIST *to_blocks,
207                    BLOBNBOX_LIST *diacritic_blobs, Tesseract *osd_tess, OSResults *osr);
208    ColumnFinder *SetupPageSegAndDetectOrientation(PageSegMode pageseg_mode, BLOCK_LIST *blocks,
209                                                   Tesseract *osd_tess, OSResults *osr,
210                                                   TO_BLOCK_LIST *to_blocks, Image *photo_mask_pix,
211                                                   Image *music_mask_pix);
212    void PrerecAllWordsPar(const std::vector<WordData> &words);
213    bool TrainLineRecognizer(const char *input_imagename, const std::string &output_basename,
214                             BLOCK_LIST *block_list);
215    void TrainFromBoxes(const std::vector<TBOX> &boxes, const std::vector<std::string> &texts,
216                        BLOCK_LIST *block_list, DocumentData *training_data);
217    ImageData *GetLineData(const TBOX &line_box, const std::vector<TBOX> &boxes,
218                           const std::vector<std::string> &texts, int start_box, int end_box,
219                           const BLOCK &block);
220    ImageData *GetRectImage(const TBOX &box, const BLOCK &block, int padding,
221                            TBOX *revised_box) const;
222    void LSTMRecognizeWord(const BLOCK &block, ROW *row, WERD_RES *word,
223                           PointerVector<WERD_RES> *words);
224    void SearchWords(PointerVector<WERD_RES> *words);
225    bool ProcessTargetWord(const TBOX &word_box, const TBOX &target_word_box, const char *word_config,
226                           int pass);
227    void SetupAllWordsPassN(int pass_n, const TBOX *target_word_box, const char *word_config,
228                            PAGE_RES *page_res, std::vector<WordData> *words);
229    void SetupWordPassN(int pass_n, WordData *word);
230    bool RecogAllWordsPassN(int pass_n, ETEXT_DESC *monitor, PAGE_RES_IT *pr_it,
231                            std::vector<WordData> *words);
232    bool recog_all_words(PAGE_RES *page_res, ETEXT_DESC *monitor, const TBOX *target_word_box,
233                         const char *word_config, int dopasses);
234    void rejection_passes(PAGE_RES *page_res, ETEXT_DESC *monitor, const TBOX *target_word_box,
235                          const char *word_config);
236    void bigram_correction_pass(PAGE_RES *page_res);
237    void blamer_pass(PAGE_RES *page_res);
238    void script_pos_pass(PAGE_RES *page_res);
239    int RetryWithLanguage(const WordData &word_data, WordRecognizer recognizer, bool debug,
240                          WERD_RES **in_word, PointerVector<WERD_RES> *best_words);
241    bool ReassignDiacritics(int pass, PAGE_RES_IT *pr_it, bool *make_next_word_fuzzy);
242    void AssignDiacriticsToOverlappingBlobs(const std::vector<C_OUTLINE *> &outlines, int pass,
243                                            WERD *real_word, PAGE_RES_IT *pr_it,
244                                            std::vector<bool> *word_wanted,
245                                            std::vector<bool> *overlapped_any_blob,
246                                            std::vector<C_BLOB *> *target_blobs);
247    void AssignDiacriticsToNewBlobs(const std::vector<C_OUTLINE *> &outlines, int pass,
248                                    WERD *real_word, PAGE_RES_IT *pr_it,
249                                    std::vector<bool> *word_wanted,
250                                    std::vector<C_BLOB *> *target_blobs);
251    bool SelectGoodDiacriticOutlines(int pass, float certainty_threshold, PAGE_RES_IT *pr_it,
252                                     C_BLOB *blob, const std::vector<C_OUTLINE *> &outlines,
253                                     int num_outlines, std::vector<bool> *ok_outlines);
254    float ClassifyBlobPlusOutlines(const std::vector<bool> &ok_outlines,
255                                   const std::vector<C_OUTLINE *> &outlines, int pass_n,
256                                   PAGE_RES_IT *pr_it, C_BLOB *blob, std::string &best_str);
257    float ClassifyBlobAsWord(int pass_n, PAGE_RES_IT *pr_it, C_BLOB *blob, std::string &best_str,
258                             float *c2);
259    void classify_word_and_language(int pass_n, PAGE_RES_IT *pr_it, WordData *word_data);
260    void classify_word_pass1(const WordData &word_data, WERD_RES **in_word,
261                             PointerVector<WERD_RES> *out_words);
262    void recog_pseudo_word(PAGE_RES *page_res, 
263                           TBOX &selection_box);
264    void fix_rep_char(PAGE_RES_IT *page_res_it);
265    ACCEPTABLE_WERD_TYPE acceptable_word_string(const UNICHARSET &char_set, const char *s,
266                                                const char *lengths);
267    void match_word_pass_n(int pass_n, WERD_RES *word, ROW *row, BLOCK *block);
268    void classify_word_pass2(const WordData &word_data, WERD_RES **in_word,
269                             PointerVector<WERD_RES> *out_words);
270    void ReportXhtFixResult(bool accept_new_word, float new_x_ht, WERD_RES *word, WERD_RES *new_word);
271    bool RunOldFixXht(WERD_RES *word, BLOCK *block, ROW *row);
272    bool TrainedXheightFix(WERD_RES *word, BLOCK *block, ROW *row);
273    bool TestNewNormalization(int original_misfits, float baseline_shift, float new_x_ht,
274                              WERD_RES *word, BLOCK *block, ROW *row);
275    bool recog_interactive(PAGE_RES_IT *pr_it);
276    void set_word_fonts(WERD_RES *word);
277    void font_recognition_pass(PAGE_RES *page_res);
278    void dictionary_correction_pass(PAGE_RES *page_res);
279    bool check_debug_pt(WERD_RES *word, int location);
280    bool SubAndSuperscriptFix(WERD_RES *word_res);
281    void GetSubAndSuperscriptCandidates(const WERD_RES *word, int *num_rebuilt_leading,
282                                        ScriptPos *leading_pos, float *leading_certainty,
283                                        int *num_rebuilt_trailing, ScriptPos *trailing_pos,
284                                        float *trailing_certainty, float *avg_certainty,
285                                        float *unlikely_threshold);
286    WERD_RES *TrySuperscriptSplits(int num_chopped_leading, float leading_certainty,
287                                   ScriptPos leading_pos, int num_chopped_trailing,
288                                   float trailing_certainty, ScriptPos trailing_pos, WERD_RES *word,
289                                   bool *is_good, int *retry_leading, int *retry_trailing);
290    bool BelievableSuperscript(bool debug, const WERD_RES &word, float certainty_threshold,
291                               int *left_ok, int *right_ok) const;
292    void output_pass(PAGE_RES_IT &page_res_it, const TBOX *target_word_box);
293    void write_results(PAGE_RES_IT &page_res_it, 
294                       char newline_type,        
295                       bool force_eol            
296    );
297    void set_unlv_suspects(WERD_RES *word);
298    UNICHAR_ID get_rep_char(WERD_RES *word); 
299    bool acceptable_number_string(const char *s, const char *lengths);
300    int16_t count_alphanums(const WERD_CHOICE &word);
301    int16_t count_alphas(const WERD_CHOICE &word);
302    void read_config_file(const char *filename, SetParamConstraint constraint);
303    int init_tesseract(const std::string &arg0, const std::string &textbase,
304                       const std::string &language, OcrEngineMode oem, char **configs,
305                       int configs_size, const std::vector<std::string> *vars_vec,
306                       const std::vector<std::string> *vars_values, bool set_only_non_debug_params,
307                       TessdataManager *mgr);
308    int init_tesseract(const std::string &datapath, const std::string &language, OcrEngineMode oem) {
309      TessdataManager mgr;
310      return init_tesseract(datapath, {}, language, oem, nullptr, 0, nullptr, nullptr, false, &mgr);
311    }
312    int init_tesseract_internal(const std::string &arg0, const std::string &textbase,
313                                const std::string &language, OcrEngineMode oem, char **configs,
314                                int configs_size, const std::vector<std::string> *vars_vec,
315                                const std::vector<std::string> *vars_values,
316                                bool set_only_non_debug_params, TessdataManager *mgr);
317    void SetupUniversalFontIds();
318    void recognize_page(std::string &image_name);
319    void end_tesseract();
320    bool init_tesseract_lang_data(const std::string &arg0,
321                                  const std::string &language, OcrEngineMode oem, char **configs,
322                                  int configs_size, const std::vector<std::string> *vars_vec,
323                                  const std::vector<std::string> *vars_values,
324                                  bool set_only_non_debug_params, TessdataManager *mgr);
325    void ParseLanguageString(const std::string &lang_str, std::vector<std::string> *to_load,
326                             std::vector<std::string> *not_to_load);
327    SVMenuNode *build_menu_new();
328  #ifndef GRAPHICS_DISABLED
329    void pgeditor_main(int width, int height, PAGE_RES *page_res);
330    void process_image_event( 
331        const SVEvent &event);
332    bool process_cmd_win_event( 
333        int32_t cmd_event,      
334        char *new_value         
335    );
336  #endif 
337    void debug_word(PAGE_RES *page_res, const TBOX &selection_box);
338    void do_re_display(bool (tesseract::Tesseract::*word_painter)(PAGE_RES_IT *pr_it));
339    bool word_display(PAGE_RES_IT *pr_it);
340    bool word_bln_display(PAGE_RES_IT *pr_it);
341    bool word_blank_and_set_display(PAGE_RES_IT *pr_its);
342    bool word_set_display(PAGE_RES_IT *pr_it);
343    bool word_dumper(PAGE_RES_IT *pr_it);
344    void blob_feature_display(PAGE_RES *page_res, const TBOX &selection_box);
345    void make_reject_map(WERD_RES *word, ROW *row, int16_t pass);
346    bool one_ell_conflict(WERD_RES *word_res, bool update_map);
347    int16_t first_alphanum_index(const char *word, const char *word_lengths);
348    int16_t first_alphanum_offset(const char *word, const char *word_lengths);
349    int16_t alpha_count(const char *word, const char *word_lengths);
350    bool word_contains_non_1_digit(const char *word, const char *word_lengths);
351    void dont_allow_1Il(WERD_RES *word);
352    int16_t count_alphanums( 
353        WERD_RES *word);
354    void flip_0O(WERD_RES *word);
355    bool non_0_digit(const UNICHARSET &ch_set, UNICHAR_ID unichar_id);
356    bool non_O_upper(const UNICHARSET &ch_set, UNICHAR_ID unichar_id);
357    bool repeated_nonalphanum_wd(WERD_RES *word, ROW *row);
358    void nn_match_word( 
359        WERD_RES *word, ROW *row);
360    void nn_recover_rejects(WERD_RES *word, ROW *row);
361    void set_done( 
362        WERD_RES *word, int16_t pass);
363    int16_t safe_dict_word(const WERD_RES *werd_res); 
364    void flip_hyphens(WERD_RES *word);
365    void reject_I_1_L(WERD_RES *word);
366    void reject_edge_blobs(WERD_RES *word);
367    void reject_mostly_rejects(WERD_RES *word);
368    bool word_adaptable( 
369        WERD_RES *word, uint16_t mode);
370    void recog_word_recursive(WERD_RES *word);
371    void recog_word(WERD_RES *word);
372    void split_and_recog_word(WERD_RES *word);
373    void split_word(WERD_RES *word, unsigned split_pt, WERD_RES **right_piece,
374                    BlamerBundle **orig_blamer_bundle) const;
375    void join_words(WERD_RES *word, WERD_RES *word2, BlamerBundle *orig_bb) const;
376    bool digit_or_numeric_punct(WERD_RES *word, int char_position);
377    int16_t eval_word_spacing(WERD_RES_LIST &word_res_list);
378    void match_current_words(WERD_RES_LIST &words, ROW *row, BLOCK *block);
379    int16_t fp_eval_word_spacing(WERD_RES_LIST &word_res_list);
380    void fix_noisy_space_list(WERD_RES_LIST &best_perm, ROW *row, BLOCK *block);
381    void fix_fuzzy_space_list(WERD_RES_LIST &best_perm, ROW *row, BLOCK *block);
382    void fix_sp_fp_word(WERD_RES_IT &word_res_it, ROW *row, BLOCK *block);
383    void fix_fuzzy_spaces(   
384        ETEXT_DESC *monitor, 
385        int32_t word_count,  
386        PAGE_RES *page_res);
387    void dump_words(WERD_RES_LIST &perm, int16_t score, int16_t mode, bool improved);
388    bool fixspace_thinks_word_done(WERD_RES *word);
389    int16_t worst_noise_blob(WERD_RES *word_res, float *worst_noise_score);
390    float blob_noise_score(TBLOB *blob);
391    void break_noisiest_blob_word(WERD_RES_LIST &words);
392  #ifndef DISABLED_LEGACY_ENGINE
393    GARBAGE_LEVEL garbage_word(WERD_RES *word, bool ok_dict_word);
394    bool potential_word_crunch(WERD_RES *word, GARBAGE_LEVEL garbage_level, bool ok_dict_word);
395  #endif
396    void tilde_crunch(PAGE_RES_IT &page_res_it);
397    void unrej_good_quality_words( 
398        PAGE_RES_IT &page_res_it);
399    void doc_and_block_rejection( 
400        PAGE_RES_IT &page_res_it, bool good_quality_doc);
401    void quality_based_rejection(PAGE_RES_IT &page_res_it, bool good_quality_doc);
402    void convert_bad_unlv_chs(WERD_RES *word_res);
403    void tilde_delete(PAGE_RES_IT &page_res_it);
404    int16_t word_blob_quality(WERD_RES *word);
405    void word_char_quality(WERD_RES *word, int16_t *match_count, int16_t *accepted_match_count);
406    void unrej_good_chs(WERD_RES *word);
407    int16_t count_outline_errs(char c, int16_t outline_count);
408    int16_t word_outline_errs(WERD_RES *word);
409  #ifndef DISABLED_LEGACY_ENGINE
410    bool terrible_word_crunch(WERD_RES *word, GARBAGE_LEVEL garbage_level);
411  #endif
412    CRUNCH_MODE word_deletable(WERD_RES *word, int16_t &delete_mode);
413    int16_t failure_count(WERD_RES *word);
414    bool noise_outlines(TWERD *word);
415    void process_selected_words(PAGE_RES *page_res, 
416                                TBOX &selection_box,
417                                bool (tesseract::Tesseract::*word_processor)(PAGE_RES_IT *pr_it));
418    void tess_add_doc_word(      
419        WERD_CHOICE *word_choice 
420    );
421    void tess_segment_pass_n(int pass_n, WERD_RES *word);
422    bool tess_acceptable_word(WERD_RES *word);
423    PAGE_RES *ApplyBoxes(const char *filename, bool find_segmentation, BLOCK_LIST *block_list);
424    void PreenXHeights(BLOCK_LIST *block_list);
425    PAGE_RES *SetupApplyBoxes(const std::vector<TBOX> &boxes, BLOCK_LIST *block_list);
426    void MaximallyChopWord(const std::vector<TBOX> &boxes, BLOCK *block, ROW *row,
427                           WERD_RES *word_res);
428    bool ResegmentCharBox(PAGE_RES *page_res, const TBOX *prev_box, const TBOX &box,
429                          const TBOX *next_box, const char *correct_text);
430    bool ResegmentWordBox(BLOCK_LIST *block_list, const TBOX &box, const TBOX *next_box,
431                          const char *correct_text);
432    void ReSegmentByClassification(PAGE_RES *page_res);
433    bool ConvertStringToUnichars(const char *utf8, std::vector<UNICHAR_ID> *class_ids);
434    bool FindSegmentation(const std::vector<UNICHAR_ID> &target_text, WERD_RES *word_res);
435    void SearchForText(const std::vector<BLOB_CHOICE_LIST *> *choices, int choices_pos,
436                       unsigned choices_length, const std::vector<UNICHAR_ID> &target_text,
437                       unsigned text_index, float rating, std::vector<int> *segmentation,
438                       float *best_rating, std::vector<int> *best_segmentation);
439    void TidyUp(PAGE_RES *page_res);
440    void ReportFailedBox(int boxfile_lineno, TBOX box, const char *box_ch, const char *err_msg);
441    void CorrectClassifyWords(PAGE_RES *page_res);
442    void ApplyBoxTraining(const std::string &fontname, PAGE_RES *page_res);
443    int CountMisfitTops(WERD_RES *word_res);
444    float ComputeCompatibleXheight(WERD_RES *word_res, float *baseline_shift);
445    BOOL_VAR_H(tessedit_resegment_from_boxes);
446    BOOL_VAR_H(tessedit_resegment_from_line_boxes);
447    BOOL_VAR_H(tessedit_train_from_boxes);
448    BOOL_VAR_H(tessedit_make_boxes_from_boxes);
449    BOOL_VAR_H(tessedit_train_line_recognizer);
450    BOOL_VAR_H(tessedit_dump_pageseg_images);
451    BOOL_VAR_H(tessedit_do_invert);
452    double_VAR_H(invert_threshold);
453    INT_VAR_H(tessedit_pageseg_mode);
454    INT_VAR_H(thresholding_method);
455    BOOL_VAR_H(thresholding_debug);
456    double_VAR_H(thresholding_window_size);
457    double_VAR_H(thresholding_kfactor);
458    double_VAR_H(thresholding_tile_size);
459    double_VAR_H(thresholding_smooth_kernel_size);
460    double_VAR_H(thresholding_score_fraction);
461    INT_VAR_H(tessedit_ocr_engine_mode);
462    STRING_VAR_H(tessedit_char_blacklist);
463    STRING_VAR_H(tessedit_char_whitelist);
464    STRING_VAR_H(tessedit_char_unblacklist);
465    BOOL_VAR_H(tessedit_ambigs_training);
466    INT_VAR_H(pageseg_devanagari_split_strategy);
467    INT_VAR_H(ocr_devanagari_split_strategy);
468    STRING_VAR_H(tessedit_write_params_to_file);
469    BOOL_VAR_H(tessedit_adaption_debug);
470    INT_VAR_H(bidi_debug);
471    INT_VAR_H(applybox_debug);
472    INT_VAR_H(applybox_page);
473    STRING_VAR_H(applybox_exposure_pattern);
474    BOOL_VAR_H(applybox_learn_chars_and_char_frags_mode);
475    BOOL_VAR_H(applybox_learn_ngrams_mode);
476    BOOL_VAR_H(tessedit_display_outwords);
477    BOOL_VAR_H(tessedit_dump_choices);
478    BOOL_VAR_H(tessedit_timing_debug);
479    BOOL_VAR_H(tessedit_fix_fuzzy_spaces);
480    BOOL_VAR_H(tessedit_unrej_any_wd);
481    BOOL_VAR_H(tessedit_fix_hyphens);
482    BOOL_VAR_H(tessedit_enable_doc_dict);
483    BOOL_VAR_H(tessedit_debug_fonts);
484    INT_VAR_H(tessedit_font_id);
485    BOOL_VAR_H(tessedit_debug_block_rejection);
486    BOOL_VAR_H(tessedit_enable_bigram_correction);
487    BOOL_VAR_H(tessedit_enable_dict_correction);
488    INT_VAR_H(tessedit_bigram_debug);
489    BOOL_VAR_H(enable_noise_removal);
490    INT_VAR_H(debug_noise_removal);
491    double_VAR_H(noise_cert_basechar);
492    double_VAR_H(noise_cert_disjoint);
493    double_VAR_H(noise_cert_punc);
494    double_VAR_H(noise_cert_factor);
495    INT_VAR_H(noise_maxperblob);
496    INT_VAR_H(noise_maxperword);
497    INT_VAR_H(debug_x_ht_level);
498    STRING_VAR_H(chs_leading_punct);
499    STRING_VAR_H(chs_trailing_punct1);
500    STRING_VAR_H(chs_trailing_punct2);
501    double_VAR_H(quality_rej_pc);
502    double_VAR_H(quality_blob_pc);
503    double_VAR_H(quality_outline_pc);
504    double_VAR_H(quality_char_pc);
505    INT_VAR_H(quality_min_initial_alphas_reqd);
506    INT_VAR_H(tessedit_tess_adaption_mode);
507    BOOL_VAR_H(tessedit_minimal_rej_pass1);
508    BOOL_VAR_H(tessedit_test_adaption);
509    BOOL_VAR_H(test_pt);
510    double_VAR_H(test_pt_x);
511    double_VAR_H(test_pt_y);
512    INT_VAR_H(multilang_debug_level);
513    INT_VAR_H(paragraph_debug_level);
514    BOOL_VAR_H(paragraph_text_based);
515    BOOL_VAR_H(lstm_use_matrix);
516    STRING_VAR_H(outlines_odd);
517    STRING_VAR_H(outlines_2);
518    BOOL_VAR_H(tessedit_good_quality_unrej);
519    BOOL_VAR_H(tessedit_use_reject_spaces);
520    double_VAR_H(tessedit_reject_doc_percent);
521    double_VAR_H(tessedit_reject_block_percent);
522    double_VAR_H(tessedit_reject_row_percent);
523    double_VAR_H(tessedit_whole_wd_rej_row_percent);
524    BOOL_VAR_H(tessedit_preserve_blk_rej_perfect_wds);
525    BOOL_VAR_H(tessedit_preserve_row_rej_perfect_wds);
526    BOOL_VAR_H(tessedit_dont_blkrej_good_wds);
527    BOOL_VAR_H(tessedit_dont_rowrej_good_wds);
528    INT_VAR_H(tessedit_preserve_min_wd_len);
529    BOOL_VAR_H(tessedit_row_rej_good_docs);
530    double_VAR_H(tessedit_good_doc_still_rowrej_wd);
531    BOOL_VAR_H(tessedit_reject_bad_qual_wds);
532    BOOL_VAR_H(tessedit_debug_doc_rejection);
533    BOOL_VAR_H(tessedit_debug_quality_metrics);
534    BOOL_VAR_H(bland_unrej);
535    double_VAR_H(quality_rowrej_pc);
536    BOOL_VAR_H(unlv_tilde_crunching);
537    BOOL_VAR_H(hocr_font_info);
538    BOOL_VAR_H(hocr_char_boxes);
539    BOOL_VAR_H(crunch_early_merge_tess_fails);
540    BOOL_VAR_H(crunch_early_convert_bad_unlv_chs);
541    double_VAR_H(crunch_terrible_rating);
542    BOOL_VAR_H(crunch_terrible_garbage);
543    double_VAR_H(crunch_poor_garbage_cert);
544    double_VAR_H(crunch_poor_garbage_rate);
545    double_VAR_H(crunch_pot_poor_rate);
546    double_VAR_H(crunch_pot_poor_cert);
547    double_VAR_H(crunch_del_rating);
548    double_VAR_H(crunch_del_cert);
549    double_VAR_H(crunch_del_min_ht);
550    double_VAR_H(crunch_del_max_ht);
551    double_VAR_H(crunch_del_min_width);
552    double_VAR_H(crunch_del_high_word);
553    double_VAR_H(crunch_del_low_word);
554    double_VAR_H(crunch_small_outlines_size);
555    INT_VAR_H(crunch_rating_max);
556    INT_VAR_H(crunch_pot_indicators);
557    BOOL_VAR_H(crunch_leave_ok_strings);
558    BOOL_VAR_H(crunch_accept_ok);
559    BOOL_VAR_H(crunch_leave_accept_strings);
560    BOOL_VAR_H(crunch_include_numerals);
561    INT_VAR_H(crunch_leave_lc_strings);
562    INT_VAR_H(crunch_leave_uc_strings);
563    INT_VAR_H(crunch_long_repetitions);
564    INT_VAR_H(crunch_debug);
565    INT_VAR_H(fixsp_non_noise_limit);
566    double_VAR_H(fixsp_small_outlines_size);
567    BOOL_VAR_H(tessedit_prefer_joined_punct);
568    INT_VAR_H(fixsp_done_mode);
569    INT_VAR_H(debug_fix_space_level);
570    STRING_VAR_H(numeric_punctuation);
571    INT_VAR_H(x_ht_acceptance_tolerance);
572    INT_VAR_H(x_ht_min_change);
573    INT_VAR_H(superscript_debug);
574    double_VAR_H(superscript_worse_certainty);
575    double_VAR_H(superscript_bettered_certainty);
576    double_VAR_H(superscript_scaledown_ratio);
577    double_VAR_H(subscript_max_y_top);
578    double_VAR_H(superscript_min_y_bottom);
579    BOOL_VAR_H(tessedit_write_block_separators);
580    BOOL_VAR_H(tessedit_write_rep_codes);
581    BOOL_VAR_H(tessedit_write_unlv);
582    BOOL_VAR_H(tessedit_create_txt);
583    BOOL_VAR_H(tessedit_create_hocr);
584    BOOL_VAR_H(tessedit_create_alto);
585    BOOL_VAR_H(tessedit_create_lstmbox);
586    BOOL_VAR_H(tessedit_create_tsv);
587    BOOL_VAR_H(tessedit_create_wordstrbox);
588    BOOL_VAR_H(tessedit_create_pdf);
589    BOOL_VAR_H(textonly_pdf);
590    INT_VAR_H(jpg_quality);
591    INT_VAR_H(user_defined_dpi);
592    INT_VAR_H(min_characters_to_try);
593    STRING_VAR_H(unrecognised_char);
594    INT_VAR_H(suspect_level);
595    INT_VAR_H(suspect_short_words);
596    BOOL_VAR_H(suspect_constrain_1Il);
597    double_VAR_H(suspect_rating_per_ch);
598    double_VAR_H(suspect_accept_rating);
599    BOOL_VAR_H(tessedit_minimal_rejection);
600    BOOL_VAR_H(tessedit_zero_rejection);
601    BOOL_VAR_H(tessedit_word_for_word);
602    BOOL_VAR_H(tessedit_zero_kelvin_rejection);
603    INT_VAR_H(tessedit_reject_mode);
604    BOOL_VAR_H(tessedit_rejection_debug);
605    BOOL_VAR_H(tessedit_flip_0O);
606    double_VAR_H(tessedit_lower_flip_hyphen);
607    double_VAR_H(tessedit_upper_flip_hyphen);
608    BOOL_VAR_H(rej_trust_doc_dawg);
609    BOOL_VAR_H(rej_1Il_use_dict_word);
610    BOOL_VAR_H(rej_1Il_trust_permuter_type);
611    BOOL_VAR_H(rej_use_tess_accepted);
612    BOOL_VAR_H(rej_use_tess_blanks);
613    BOOL_VAR_H(rej_use_good_perm);
614    BOOL_VAR_H(rej_use_sensible_wd);
615    BOOL_VAR_H(rej_alphas_in_number_perm);
616    double_VAR_H(rej_whole_of_mostly_reject_word_fract);
617    INT_VAR_H(tessedit_image_border);
618    STRING_VAR_H(ok_repeated_ch_non_alphanum_wds);
619    STRING_VAR_H(conflict_set_I_l_1);
620    INT_VAR_H(min_sane_x_ht_pixels);
621    BOOL_VAR_H(tessedit_create_boxfile);
622    INT_VAR_H(tessedit_page_number);
623    BOOL_VAR_H(tessedit_write_images);
624    BOOL_VAR_H(interactive_display_mode);
625    STRING_VAR_H(file_type);
626    BOOL_VAR_H(tessedit_override_permuter);
627    STRING_VAR_H(tessedit_load_sublangs);
628    BOOL_VAR_H(tessedit_use_primary_params_model);
629    double_VAR_H(min_orientation_margin);
630    BOOL_VAR_H(textord_tabfind_show_vlines);
631    BOOL_VAR_H(textord_use_cjk_fp_model);
632    BOOL_VAR_H(poly_allow_detailed_fx);
633    BOOL_VAR_H(tessedit_init_config_only);
634  #ifndef DISABLED_LEGACY_ENGINE
635    BOOL_VAR_H(textord_equation_detect);
636  #endif 
637    BOOL_VAR_H(textord_tabfind_vertical_text);
638    BOOL_VAR_H(textord_tabfind_force_vertical_text);
639    double_VAR_H(textord_tabfind_vertical_text_ratio);
640    double_VAR_H(textord_tabfind_aligned_gap_fraction);
641    INT_VAR_H(tessedit_parallelize);
642    BOOL_VAR_H(preserve_interword_spaces);
643    STRING_VAR_H(page_separator);
644    INT_VAR_H(lstm_choice_mode);
645    INT_VAR_H(lstm_choice_iterations);
646    double_VAR_H(lstm_rating_coefficient);
647    BOOL_VAR_H(pageseg_apply_music_mask);
648    FILE *init_recog_training(const char *filename);
649    void recog_training_segmented(const char *filename, PAGE_RES *page_res,
650                                  volatile ETEXT_DESC *monitor, FILE *output_file);
651    void ambigs_classify_and_output(const char *label, PAGE_RES_IT *pr_it, FILE *output_file);
652  private:
653    const char *backup_config_file_;
654    std::string word_config_;
655    Image pix_binary_;
656    Image pix_grey_;
657    Image pix_original_;
658    Image pix_thresholds_;
659    DebugPixa pixa_debug_;
660    int source_resolution_;
661    ShiroRekhaSplitter splitter_;
662    Textord textord_;
663    bool right_to_left_;
664    Image scaled_color_;
665    int scaled_factor_;
666    FCOORD deskew_;
667    FCOORD reskew_;
668    TesseractStats stats_;
669    std::vector<Tesseract *> sub_langs_;
670    Tesseract *most_recently_used_;
671    int font_table_size_;
672  #ifndef DISABLED_LEGACY_ENGINE
673    EquationDetect *equ_detect_;
674  #endif 
675    LSTMRecognizer *lstm_recognizer_;
676    int train_line_page_num_;
677  };
678  } 
679  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from Cpp_Primer_Answers-MDEwOlJlcG9zaXRvcnk0NzE3MDI2MQ==-flat-exercise12_2.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-tesseractclass.h</div>
                </div>
                <div class="column column_space"><pre><code>12  	StrBlob(std::initializer_list<string> il) : data(std::make_shared<vector<string>>(il)) {}
13  	size_type size() const
14  	{
15  		return data->size();
16  	}
17  	bool empty() const
18  	{
19  		return data->empty();
20  	}
</pre></code></div>
                <div class="column column_space"><pre><code>108    }
109    Image pix_binary() const {
110      return pix_binary_;
111    }
112    Image pix_grey() const {
113      return pix_grey_;
114    }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    