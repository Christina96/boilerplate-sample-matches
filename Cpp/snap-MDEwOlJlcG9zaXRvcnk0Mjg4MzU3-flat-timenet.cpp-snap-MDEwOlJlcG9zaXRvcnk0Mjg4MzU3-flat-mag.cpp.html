
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 17.60520430981907%, Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-timenet.cpp</h3>
            <pre><code>1  TTimeNet& TTimeNet::operator = (const TTimeNet& TimeNet) {
2    if (this != &TimeNet) {
3      TNet::operator=(TimeNet);
4    }
5    return *this;
6  }
7  PTimeNet TTimeNet::GetSubGraph(const TIntV& NIdV) const {
8    PTimeNet NewNetPt = TTimeNet::New();
9    TTimeNet& NewNet = *NewNetPt;
10    NewNet.Reserve(NIdV.Len(), -1);
11    int node, edge;
12    TNodeI NI;
13    for (node = 0; node < NIdV.Len(); node++) {
14      NewNet.AddNode(NIdV[node], GetNDat(NIdV[node])); 
15    }
16    for (node = 0; node < NIdV.Len(); node++) {
17      NI = GetNI(NIdV[node]);
18      const int SrcNId = NI.GetId();
19      for (edge = 0; edge < NI.GetOutDeg(); edge++) {
20        const int OutNId = NI.GetOutNId(edge);
21        if (NewNet.IsNode(OutNId)) {
22          NewNet.AddEdge(SrcNId, OutNId); }
23      }
24    }
25    NewNet.Defrag();
26    return NewNetPt;
27  }
28  PTimeNENet TTimeNet::GetTimeNENet() const {
29    TIntV NIdV;  GetNIdByTm(NIdV);
30    PTimeNENet OutNet = TTimeNENet::New(GetNodes(), GetEdges());
31    for (int i = 0; i < NIdV.Len(); i++) {
32      const int Src = NIdV[i];
33      const TTimeNet::TNodeI NI = GetNI(Src);
34      const TSecTm SrcTm = NI.GetDat();
35      if (! OutNet->IsNode(Src)) { OutNet->AddNode(Src, SrcTm); }
36      for (int e = 0; e < NI.GetOutDeg(); e++) {
37        if (! OutNet->IsNode(NI.GetOutNId(e))) { OutNet->AddNode(NI.GetOutNId(e), SrcTm); }
38        OutNet->AddEdge(Src, NI.GetOutNId(e), -1, SrcTm);
39      }
40    }
41    return OutNet;
42  }
43  void TTimeNet::GetNIdByTm(TIntV& NIdV) const {
44    TVec<TKeyDat<TSecTm, TInt> > TmToNIdV(GetNodes(), 0);
45    for (TNodeI NodeI = BegNI(); NodeI < EndNI(); NodeI++) {
46      TmToNIdV.Add(TKeyDat<TSecTm, TInt>(NodeI.GetDat(), NodeI.GetId())); }
47    TmToNIdV.Sort();
48    NIdV.Gen(GetNodes(), 0);
49    for (int i = 0; i < TmToNIdV.Len(); i++) {
50      NIdV.Add(TmToNIdV[i].Dat); }
51  }
52  void TTimeNet::GetTmBuckets(const TTmUnit& TmUnit, TTmBucketV& TmBucketV) const {
53    THash<TInt, TIntV> TmIdToNIdVH;
54    for (TNodeI NodeI = BegNI(); NodeI < EndNI(); NodeI++) {
55      const int TmId = NodeI().Round(TmUnit);
56      if (! TmIdToNIdVH.IsKey(TmId)) TmIdToNIdVH.AddKey(TmId);
57      TmIdToNIdVH.GetDat(TmId).Add(NodeI.GetId());
58    }
59    TVec<TPair<TInt, TIntV> > TmIdNIdVV;
60    TmIdToNIdVH.GetKeyDatPrV(TmIdNIdVV);
61    TmIdNIdVV.Sort();
62    TmBucketV.Gen(TmIdNIdVV.Len());
63    for (int i = 0; i < TmIdNIdVV.Len(); i++) {
64      TTmBucket& Bucket = TmBucketV[i];
65      Bucket.BegTm = TmIdNIdVV[i].Val1;
66      Bucket.NIdV = TmIdNIdVV[i].Val2;
67    }
68  }
69  void TTimeNet::GetNodeBuckets(const int NodesPerBucket, TTimeNet::TTmBucketV& TmBucketV) const {
70    TIntV NIdV;
71    GetNIdByTm(NIdV);
72    TmBucketV.Gen(NIdV.Len() / NodesPerBucket + 1, 0);
73    for (int i = 0; i < NIdV.Len(); i++) {
74      const int b = i/NodesPerBucket;
75      if (TmBucketV.Len() <= b) { TmBucketV.Add(TTimeNet::TTmBucket(TSecTm(b))); }
76      TmBucketV[b].NIdV.Add(NIdV[i]);
77    }
78  }
79  PGStatVec TTimeNet::TimeGrowth(const TTmUnit& TmUnit, const TFSet& TakeStat, const TSecTm& StartTm) const {
80    PGStatVec GrowthStat = new TGStatVec(TmUnit, TakeStat);
81    TTmBucketV TmBucketV;
82    GetTmBuckets(TmUnit, TmBucketV);
83    TIntV NodeIdV;
84    TExeTm ExeTm;
85    for (int t = 0; t < TmBucketV.Len(); t++) {
86      NodeIdV.AddV(TmBucketV[t].NIdV); 
87      printf("\n=== %d/%d] %s (%d nodes)\n", t+1, TmBucketV.Len(),
88        TmBucketV[t].BegTm.GetStr().CStr(), NodeIdV.Len());  ExeTm.Tick();
89      if (TmBucketV[t].BegTm < StartTm) continue;
90      PNGraph PreGraph = TSnap::ConvertSubGraph<PNGraph>(PTimeNet((TTimeNet*)this), NodeIdV); 
91      GrowthStat->Add(PreGraph, TmBucketV[t].BegTm);
92    }
93    return GrowthStat;
94  }
95  void TTimeNet::PlotEffDiam(const TStr& FNmPref, const TStr& Desc, const TTmUnit& TmUnit,
96                             const TSecTm& StartTm, const int& NDiamRuns, const bool& OnlyWcc, const bool& AlsoRewire) const {
97    const TStr WccStr = OnlyWcc ? "WCC " : TStr::GetNullStr();
98    TTmBucketV TmBucketV;
99    GetTmBuckets(TmUnit, TmBucketV);
100    TIntV NodeIdV;
101    TExeTm ExeTm, Run1Tm;
102    TFltTrV TmDiamV, NdsDiamV;
103    TFltTrV RwTmDiamV, RwNdsDiamV;
104    for (int t = 0; t < TmBucketV.Len(); t++) {
105      NodeIdV.AddV(TmBucketV[t].NIdV); 
106      printf("\n*** %d/%d] at %s (%d nodes)\n", t+1, TmBucketV.Len(),
107        TmBucketV[t].BegTm.GetStr(TmUnit).CStr(), NodeIdV.Len());  ExeTm.Tick();
108      if (TmBucketV[t].BegTm < StartTm) continue;
109      PUNGraph PreGraph = TSnap::ConvertSubGraph<PUNGraph>(PTimeNet((TTimeNet*)this), NodeIdV);
110      { TMom Mom;
111      for (int r = 0; r < NDiamRuns; r++) {
112        printf("%d...", r+1);  Run1Tm.Tick();
113        const double EffDiam = TSnap::GetAnfEffDiam(OnlyWcc ? TSnap::GetMxWcc(PreGraph) : PreGraph);
114        Mom.Add(EffDiam);  printf("[%s]\r", Run1Tm.GetTmStr());
115      }
116      Mom.Def();
117      TmDiamV.Add(TFltTr((int)TmBucketV[t].BegTm.GetInUnits(TmUnit), Mom.GetMean(), Mom.GetSDev()));
118      NdsDiamV.Add(TFltTr(PreGraph->GetNodes(), Mom.GetMean(), Mom.GetSDev()));
119      NdsDiamV.Sort();
120      printf("  [%s]          \n", ExeTm.GetTmStr()); }
121      if (AlsoRewire) {
122        TIntV DegSeqV(PreGraph->GetNodes(), 0);
123        for (TUNGraph::TNodeI NI = PreGraph->BegNI(); NI < PreGraph->EndNI(); NI++) { DegSeqV.Add(NI.GetDeg()); }
124        PUNGraph RwGraph = TSnap::GenConfModel(DegSeqV, TInt::Rnd);
125        printf("Configuration model: (%d, %d) --> (%d, %d)\n", PreGraph->GetNodes(), PreGraph->GetEdges(), RwGraph->GetNodes(), RwGraph->GetEdges());
126        TMom Mom;
127        for (int r = 0; r < NDiamRuns; r++) {
128          printf("  diam run %d...", r+1);  Run1Tm.Tick();
129          const double EffDiam = TSnap::GetAnfEffDiam(OnlyWcc ? TSnap::GetMxWcc(PreGraph):PreGraph);
130          Mom.Add(EffDiam);  printf(" current run [%s]\n", Run1Tm.GetTmStr());
131        }
132        Mom.Def();
133        RwTmDiamV.Add(TFltTr((int)TmBucketV[t].BegTm.GetInUnits(TmUnit), Mom.GetMean(), Mom.GetSDev()));
134        RwNdsDiamV.Add(TFltTr(PreGraph->GetNodes(), Mom.GetMean(), Mom.GetSDev()));
135        RwNdsDiamV.Sort();
136        printf("done with diameter. Total time [%s] \n", ExeTm.GetTmStr());
137      }
138      { TGnuPlot GnuPlot("diamEff-T."+FNmPref, TStr::Fmt("%s. G(%d, %d)", Desc.CStr(), GetNodes(), GetEdges()));
139      GnuPlot.SetXYLabel(TStr::Fmt("TIME [%s]", TTmInfo::GetTmUnitStr(TmUnit).CStr()), WccStr+"Effective Diameter");
140      GnuPlot.AddErrBar(TmDiamV, "True", "");
141      if (! RwTmDiamV.Empty()) { GnuPlot.AddErrBar(RwTmDiamV, "Rewired", "");}
142      GnuPlot.SavePng(); }
143      { TGnuPlot GnuPlot("diamEff-N."+FNmPref, TStr::Fmt("%s. G(%d, %d)", Desc.CStr(), GetNodes(), GetEdges()));
144      GnuPlot.SetXYLabel("NODES", WccStr+"Effective Diameter");
145      GnuPlot.AddErrBar(NdsDiamV, "True", "");
146      if (! RwNdsDiamV.Empty()) { GnuPlot.AddErrBar(RwNdsDiamV, "Rewired", "");}
147      GnuPlot.SavePng(); }
148    }
149  }
150  void TTimeNet::PlotMissingPast(const TStr& FNmPref, const TStr& Desc, const TTmUnit& TmUnit,
151                                 const TSecTm& DelPreTmEdges, const TSecTm& PostTmDiam) const {
152    printf("\nGrowth over time: degree distribution, Growth Power Law, Diameter.\n  %s group by %s.\n",
153      FNmPref.CStr(), TTmInfo::GetTmUnitStr(TmUnit).CStr());
154    printf("  Delete out-edges of pre time %s nodes.\n  Take subgraph of post year %s subgraph.\n\n",
155      DelPreTmEdges.GetStr().CStr(), PostTmDiam.GetStr().CStr());
156    const int NDiamRuns = 10;
157    const int NSamples = 100;
158    PUNGraph FullGraph = TSnap::ConvertGraph<PUNGraph>(PTimeNet((TTimeNet*)this));
159    if (DelPreTmEdges.IsDef()) {
160      int NDelNodes = 0, NDelEdges = 0;
161      printf("Deleting pre-%s node out-links\n", DelPreTmEdges.GetStr().CStr());
162      for (TNodeI NodeI = BegNI(); NodeI < EndNI(); NodeI++) {
163        if (NodeI() < DelPreTmEdges) {
164          const int NodeId = NodeI.GetId();
165          for (int edge = 0; edge < NodeI.GetOutDeg(); edge++) {
166            FullGraph->DelEdge(NodeId, NodeI.GetOutNId(edge)); }
167          NDelEdges += NodeI.GetOutDeg();  NDelNodes++;
168        }
169      }
170      printf("  Deleted %d nodes out-edges (%d edges total).\n", NDelNodes, NDelEdges);
171      FullGraph->Defrag(true);
172    }
173    PGStatVec GrowthStat = TGStatVec::New(TmUnit);
174    TFltV PreDiamSDev, PreEffDiamSDev, WccDiamSDev, WccEffDiamSDev;
175    TIntV NodeIdV;
176    TExeTm ExeTm;
177    TTmBucketV TmBucketV;
178    GetTmBuckets(TmUnit, TmBucketV);
179    for (int t = 0; t < TmBucketV.Len(); t++) {
180      printf("\nGraph: %s (%d / %d) [%s]\n", TmBucketV[t].BegTm.GetTmStr().CStr(),
181        t+1, TmBucketV.Len(), TExeTm::GetCurTm());
182      NodeIdV.AddV(TmBucketV[t].NIdV); 
183      if (TmBucketV[t].BegTm < PostTmDiam) { continue; }
184      const PUNGraph PreGraph = TSnap::GetSubGraph(FullGraph, NodeIdV, true);
185      const PUNGraph WccGraph = TSnap::GetMxWcc(PreGraph);
186      TIntV PostYearNIdV, WccPostYearNIdV;
187      for (TUNGraph::TNodeI NI = PreGraph->BegNI(); NI < PreGraph->EndNI(); NI++) {
188        if (GetNDat(NI.GetId()) >= PostTmDiam) {
189          PostYearNIdV.Add(NI.GetId());
190          if (WccGraph->IsNode(NI.GetId())) { WccPostYearNIdV.Add(NI.GetId()); }
191        }
192      }
193      TMom PreDiamMom, PreEffDiamMom, WccDiamMom, WccEffDiamMom;
194      int FullDiam; double EffDiam;
195      for (int r = 0; r < NDiamRuns; r++) {
196        if (! PostYearNIdV.Empty()) {
197          TSnap::GetBfsEffDiam(PreGraph, NSamples, PostYearNIdV, false, EffDiam, FullDiam);
198          PreDiamMom.Add(FullDiam);  PreEffDiamMom.Add(EffDiam);
199        }
200        if (! WccPostYearNIdV.Empty()) {
201          TSnap::GetBfsEffDiam(WccGraph, NSamples, WccPostYearNIdV, false, EffDiam, FullDiam);
202          WccDiamMom.Add(FullDiam);  WccEffDiamMom.Add(EffDiam);
203        }
204        printf("  diam: %d  [%s]  \r", r+1, ExeTm.GetTmStr());  ExeTm.Tick();
205      }
206      PreDiamMom.Def();  PreEffDiamMom.Def();
207      WccDiamMom.Def();  WccEffDiamMom.Def();
208      PGStat GraphStatPt = GrowthStat->Add(TmBucketV[t].BegTm);
209      TGStat& GS = *GraphStatPt;
210      GS.TakeBasicStat(PreGraph, false);
211      GS.TakeBasicStat(WccGraph, true);
212      GS.SetVal(gsvFullDiam, PreDiamMom.GetMean()); 
213      GS.SetVal(gsvEffDiam, PreEffDiamMom.GetMean());
214      GS.SetVal(gsvFullWccDiam, WccDiamMom.GetMean());
215      GS.SetVal(gsvEffWccDiam, WccEffDiamMom.GetMean());
216      GS.SetVal(gsvFullDiamDev, PreDiamMom.GetSDev()); 
217      GS.SetVal(gsvEffDiamDev, PreEffDiamMom.GetSDev());
218      GS.SetVal(gsvFullWccDiamDev, WccDiamMom.GetSDev());
219      GS.SetVal(gsvEffWccDiamDev, WccEffDiamMom.GetSDev());
220      { TFOut FOut("growth."+FNmPref+".gStatVec");  GrowthStat->Save(FOut); }
221      GrowthStat->SaveTxt(FNmPref, TStr::Fmt("%s. MISSING PAST DIAMETER\nDelPreEdges\t%s\nPostYearDiam\t%s\n",
222        Desc.CStr(), DelPreTmEdges.GetStr().CStr(), PostTmDiam.GetStr().CStr()));
223    }
224  }
225  void TTimeNet::PlotCCfOverTm(const TStr& FNmPref, TStr Desc, const TTmUnit& TmUnit, const int& NodesBucket) const {
226    if (Desc.Empty()) { Desc = FNmPref; }
227    TTimeNet::TTmBucketV TmBucketV;
228    TStr XLbl;
229    if (TmUnit == tmuNodes) {
230      XLbl = "Number of nodes (time)";
231      IAssert(NodesBucket > 0);
232      GetNodeBuckets(NodesBucket, TmBucketV); }
233    else {
234      XLbl = TStr::Fmt("Time (%s)", TTmInfo::GetTmUnitStr(TmUnit).CStr());
235      GetTmBuckets(TmUnit, TmBucketV);
236    }
237    TIntV NodeIdV;
238    TFltPrV DegToCCfV, CcfV, OpClV, OpV;
239    TVec<TTuple<TFlt, 4> > OpenClsV;
240    TTuple<TFlt, 4> Tuple;
241    TExeTm ExeTm;
242    int XVal = 0;
243    printf("Clustering coefficient over time:\n  %d edges, %d edges per bucket, %d buckets \n", GetEdges(), 100000, TmBucketV.Len());
244    PUNGraph UNGraph = TSnap::ConvertGraph<PUNGraph>(PTimeNet((TTimeNet*)this));
245    for (int t = 0; t < TmBucketV.Len(); t++) {
246      printf("\r  %d/%d: ", t+1, TmBucketV.Len());
247      NodeIdV.AddV(TmBucketV[t].NIdV); 
248      int64 Open=0, Close=0;
249      const PUNGraph Graph = TSnap::GetSubGraph(UNGraph, NodeIdV);
250      const double CCf = TSnap::GetClustCf(Graph, DegToCCfV, Open, Close);
251      if (TmUnit == tmuNodes) { XVal = Graph->GetNodes(); }
252      else { XVal = TmBucketV[t].BegTm.GetInUnits(TmUnit); }
253      CcfV.Add(TFltPr(XVal, CCf));
254      double FltOpen = static_cast<double>(Open);
255      double FltClose = static_cast<double>(Close);
256      OpClV.Add(TFltPr(XVal, (Open+Close==0 ? 0.0 : FltClose/(FltOpen+FltClose))));
257      OpV.Add(TFltPr(XVal, (Open==0 ? 0.0 : FltClose/FltOpen)));
258      Tuple[0]=Graph->GetNodes();
259      Tuple[1]=Graph->GetEdges();
260      Tuple[2]=FltClose;  Tuple[3]=FltOpen;
261      OpenClsV.Add(Tuple);
262      printf(" %s", ExeTm.GetStr());
263      TGnuPlot::PlotValV(DegToCCfV, TStr::Fmt("ccfAt%02dtm.%s", t+1, FNmPref.CStr()),
264        TStr::Fmt("%s. At time %d. Clustering Coefficient. G(%d,%d)", Desc.CStr(), t+1, Graph->GetNodes(), Graph->GetEdges()),
265        "Degree", "Clustering coefficient", gpsLog10XY, false);
266    }
267    TGnuPlot::PlotValV(CcfV, "ccfOverTm."+FNmPref, Desc+". Average Clustering Coefficient", XLbl, "Average clustering coefficient", gpsAuto, false);
268    TGnuPlot::PlotValV(OpClV, "ClsOpnTr1."+FNmPref, Desc+". Close/(Open+Closed) triads", XLbl, "Close / (Open+Closed) triads", gpsAuto, false);
269    TGnuPlot::PlotValV(OpV, "ClsOpnTr2."+FNmPref, Desc+". Close/Open triads", XLbl, "Close / Open triads", gpsAuto, false);
270    TGnuPlot::SaveTs(OpenClsV, "ClsOpnTr."+FNmPref+".tab", TStr::Fmt("#%s\n#Nodes\tEdges\tClosed\tOpenTriads", Desc.CStr()));
271    printf("\n");
272  }
273  void TTimeNet::PlotMedianDegOverTm(const TStr& FNmPref, const TTmUnit& TmUnit, const int& NodesPerBucket) const {
274    TTimeNet::TTmBucketV TmBucketV;
275    TStr XLbl;
276    if (TmUnit == tmuNodes) {
277      XLbl = "Number of nodes (time)";  IAssert(NodesPerBucket > 0);
278      GetNodeBuckets(NodesPerBucket, TmBucketV); }
279    else {
280      XLbl = TStr::Fmt("Time (%s)", TTmInfo::GetTmUnitStr(TmUnit).CStr());
281      GetTmBuckets(TmUnit, TmBucketV); }
282    printf("\n\n%s\nMedian degree over time:\n  %d edges, %d edges per bucket, %d buckets \n", FNmPref.CStr(), GetEdges(), NodesPerBucket, TmBucketV.Len());
283    TFltPrV MedDegV, MedInDegV, MedOutDegV;
284    TIntV NodeIdV;
285    int XVal;
286    PUNGraph UNGraph = TSnap::ConvertGraph<PUNGraph>(PTimeNet((TTimeNet*)this));
287    PNGraph NGraph = TSnap::ConvertGraph<PNGraph>(PTimeNet((TTimeNet*)this));
288    FILE  *F = fopen(("gStat-"+FNmPref+".tab").CStr(), "wt");
289    fprintf(F, "UndirNodes\tUndirEdges\tUndirNonZNodes\tMedianDeg\tMeanDeg\tDirNodes\tDirEdges\tDirNonzNodes\tMedInDeg\tMedOutDeg\tMeanInDeg\tMeanOutDeg\n");
290    for (int t = 0; t < TmBucketV.Len(); t++) {
291      printf("\r  %d/%d: ", t+1, TmBucketV.Len());
292      NodeIdV.AddV(TmBucketV[t].NIdV); 
293      if (TmUnit == tmuNodes) { XVal = NodeIdV.Len(); }
294      else { XVal = TmBucketV[t].BegTm.GetInUnits(TmUnit); }
295      { const PUNGraph Graph = TSnap::GetSubGraph(UNGraph, NodeIdV);  TMom Mom;
296      for (TUNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) { if (NI.GetOutDeg()>0) { Mom.Add(NI.GetOutDeg());} }
297      Mom.Def();  MedDegV.Add(TFltPr(XVal, Mom.GetMedian()));
298      fprintf(F, "%d\t%d\t%d\t%f\t%f", Graph->GetNodes(), Graph->GetEdges(), TSnap::CntNonZNodes(Graph), (float)Mom.GetMedian(), (float)Mom.GetMean()); }
299      { const PNGraph Graph = TSnap::GetSubGraph<PNGraph>(NGraph, NodeIdV); TMom MomOut, MomIn;
300      for (TNGraph::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
301        if (NI.GetOutDeg()>0) { MomOut.Add(NI.GetOutDeg()); }
302        if (NI.GetInDeg()>0) { MomIn.Add(NI.GetInDeg()); } }
303      MomOut.Def();  MedOutDegV.Add(TFltPr(XVal, MomOut.GetMedian()));
304      MomIn.Def();  MedInDegV.Add(TFltPr(XVal, MomIn.GetMedian()));
305      fprintf(F, "\t%d\t%d\t%d\t%f\t%f\t%f\t%f\n", Graph->GetNodes(), Graph->GetEdges(), (int)TSnap::CntNonZNodes(Graph), (float)MomIn.GetMedian(), (float)MomOut.GetMedian(), (float)MomIn.GetMean(), (float)MomOut.GetMean()); }
306    }
307    fclose(F);
308    TGnuPlot::PlotValV(MedDegV, "medDeg."+FNmPref, FNmPref+" Median degree", TTmInfo::GetTmUnitStr(TmUnit), "Median degree");
309    TGnuPlot::PlotValV(MedOutDegV, "medOutDeg."+FNmPref, FNmPref+" Median OUT degree", TTmInfo::GetTmUnitStr(TmUnit), "Median OUT degree");
310    TGnuPlot::PlotValV(MedInDegV, "medInDeg."+FNmPref, FNmPref+" Median IN degree", TTmInfo::GetTmUnitStr(TmUnit), "Median IN degree");
311  }
312  PTimeNet TTimeNet::LoadBipartite(const TStr& InFNm) {
313    PTimeNet TimeNetPt = TTimeNet::New();
314    TTimeNet& TimeNet = *TimeNetPt;
315    PSs Ss = TSs::LoadTxt(ssfTabSep, InFNm.CStr());
316    TIntH Set1IdH; 
317    TStrV StrTimeV;
318    for (int y = 0; y < Ss->GetYLen(); y++) {
319      if (Ss->At(0, y)[0] == '#') continue; 
320      if (Ss->GetXLen(y) < 3) continue;     
321      const int& SrcId = Ss->At(0, y).GetInt();
322      IAssert(! Set1IdH.IsKey(SrcId));
323      IAssert(! TimeNet.IsNode(SrcId));
324      Set1IdH.AddKey(SrcId);
325      Ss->At(1, y).SplitOnAllCh('-', StrTimeV);
326      const int Year = StrTimeV[0].GetInt();
327      const int Month = StrTimeV[1].GetInt();
328      const int Day = StrTimeV[2].GetInt();
329      const TSecTm NodeTm(Year, Month, Day);
330      TimeNet.AddNode(SrcId, NodeTm);
331      for (int dst = 2; dst < Ss->GetXLen(y); dst++) {
332        const int DstId = Ss->At(dst, y).GetInt();
333        IAssert(! Set1IdH.IsKey(DstId));
334        if (! TimeNet.IsNode(DstId)) { TimeNet.AddNode(DstId, NodeTm); }
335        else { TimeNet.GetNDat(DstId) = TMath::Mn(NodeTm, TimeNet.GetNDat(DstId)); }
336        if (! TimeNet.IsEdge(SrcId, DstId)) { TimeNet.AddEdge(SrcId, DstId); }
337      }
338    }
339    TimeNet.Defrag();
340    printf("Bipartate graph: nodes: %d  edges: %d\n", TimeNet.GetNodes(), TimeNet.GetEdges());
341    printf("  Bipartate sets: %d nodes --> %d nodes\n", TSnap::CntInDegNodes(TimeNetPt, 0),
342      TSnap::CntOutDegNodes(TimeNetPt, 0));
343    return TimeNetPt;
344  }
345  PTimeNet TTimeNet::LoadArxiv(const TStr& PaperFNm, const TStr& CiteFNm) {
346    TExeTm ExeTm;
347    PTimeNet TimeNetPt = TTimeNet::New();
348    TTimeNet& TimeNet = *TimeNetPt;
349    printf("Arxiv citation graph (paper publication year)...\n");
350    char Line [1024];
351    FILE *PprF = fopen(PaperFNm.CStr(), "rt");
352    TStr StrId, StrTime;
353    TStrV StrV, StrTimeV;
354    int N = 0, DuplicateNode = 0;
355    while (! feof(PprF)) {
356      Line[0] = 0;
357      fgets(Line, 1024, PprF);
358      if (strlen(Line) == 0 || Line[0] == '#') continue;
359      Line[strlen(Line)-1] = 0; 
360      TStr(Line).SplitOnWs(StrV);  IAssert(StrV.Len() == 2);
361      StrId = StrV[0];  StrTime = StrV[1];  IAssert(!StrId.Empty() && !StrTime.Empty());
362      StrTime.SplitOnAllCh('-', StrTimeV);  IAssert(StrTimeV.Len() == 3);
363      const int NodeId = StrId.GetInt();
364      if (! TimeNet.IsNode(NodeId)) {
365        const int Year = StrTimeV[0].GetInt();
366        const int Month = StrTimeV[1].GetInt();
367        const int Day = StrTimeV[2].GetInt();
368        TimeNet.AddNode(NodeId, TSecTm(Year, Month, Day));
369      } else { DuplicateNode++; }
370      if (++N % 10000 == 0) printf("\r  %dk", N/1000);
371    }
372    printf("\r  %d nodes read. %d duplicate nodes. %s\n", N, DuplicateNode, ExeTm.GetTmStr());
373    fclose(PprF);
374    int NewSrcIds=0, NewDstIds=0, DupLinks=0, NewCits=0;
375    FILE *CiteF = fopen(CiteFNm.CStr(), "rt");
376    N = 0;  ExeTm.Tick();
377    printf("Loading Arxiv citations...\n");
378    TIntPrV EdgeV;
379    THash<TInt, TSecTm> NIdToTimeH;
380    while (! feof(CiteF)) {
381      Line[0] = 0;
382      fgets(Line, 1024, CiteF);
383      if (strlen(Line) == 0 || Line[0] == '#') continue;
384      Line[strlen(Line)-1] = 0; 
385      TStr(Line).SplitOnWs(StrV);  IAssert(StrV.Len() == 2);
386      const int SrcNId = StrV[0].GetInt();
387      const int DstNId = StrV[1].GetInt();
388      EdgeV.Add(TIntPr(SrcNId, DstNId));
389      if (! TimeNet.IsNode(DstNId) && TimeNet.IsNode(SrcNId)) {
390        const TSecTm& SrcTm = TimeNet.GetNDat(SrcNId);
391        if (! NIdToTimeH.IsKey(DstNId)) {
392          NIdToTimeH.AddDat(DstNId, SrcTm);
393          NewDstIds++;
394        }
395        else if (NIdToTimeH.GetDat(DstNId) < SrcTm) {
396          NIdToTimeH.GetDat(DstNId) = SrcTm; }
397      }
398      if (++N % 10000 == 0) printf("\r  %dk", N/1000);
399    }
400    fclose(CiteF);
401    for (int i = 0; i < NIdToTimeH.Len(); i++) {
402      TimeNet.AddNode(NIdToTimeH.GetKey(i), NIdToTimeH[i]);
403    }
404    for (int i = 0; i < EdgeV.Len(); i++) {
405      const int SrcNId = EdgeV[i].Val1;
406      const int DstNId = EdgeV[i].Val2;
407      if (TimeNet.IsNode(SrcNId) && TimeNet.IsNode(DstNId)) {
408        if (! TimeNet.IsEdge(SrcNId, DstNId)) { TimeNet.AddEdge(SrcNId, DstNId); }
409        else { DupLinks++; }
410      } else {
411        if (! TimeNet.IsNode(SrcNId)) {
412          NewSrcIds++;
413          if (! TimeNet.IsNode(DstNId)) { NewCits++; }
414        }
415      }
416    }
417    printf("\r  %d citations read. %s\n", N, ExeTm.GetTmStr());
418    printf("Graph: nodes: %d    edges: %d\n", TimeNet.GetNodes(), TimeNet.GetEdges());
419    printf("Removing 0-degree nodes: %d nodes\n", TSnap::CntDegNodes(TimeNetPt, 0));
420    TIntV RmNIdV;
421    for (TTimeNet::TNodeI ni = TimeNet.BegNI(); ni < TimeNet.EndNI(); ni++) {
422      if (ni.GetDeg() == 0) { RmNIdV.Add(ni.GetId()); }
423    }
424    for (int i = 0; i < RmNIdV.Len(); i++) {
425      TimeNet.DelNode(RmNIdV[i]);
426    }
427    TimeNet.Defrag(true);
428    printf("\nFinal graph: nodes: %d    edges: %d\n", TimeNet.GetNodes(), TimeNet.GetEdges());
429    printf("  Duplicate citations                    : %d\n", DupLinks);
430    printf("  Nodes without time which are cited     : %d (add them to graph, use time of the earliest source node)\n", NewDstIds);
431    printf("  Citations between unknown time nodes   : %d\n", NewCits);
432    printf("  Nodes without time which make citations: %d (do not add them into the graph)\n", NewSrcIds);
433    return TimeNetPt;
434  }
435  PTimeNet TTimeNet::LoadPatents(const TStr& PatentFNm, const TStr& CiteFNm) {
436    int N = 0;
437    TExeTm ExeTm;
438    PTimeNet TimeNetPt = TTimeNet::New();
439    TTimeNet& TimeNet = *TimeNetPt;
440    TimeNet.Reserve(4000000, 160000000);
441    printf("parsing patent data (patent grant year)...\n");
442    const int& PatIdCol = 0;
443    const int& GYearCol = 1;
444    TStrV ColV;
445    char Line [1024];
446    FILE *PatF = fopen(PatentFNm.CStr(), "rt");
447    fgets(Line, 1024, PatF); 
448    while (! feof(PatF)) {
449      Line[0] = 0;
450      fgets(Line, 1024, PatF);
451      if (strlen(Line) == 0) break;
452      TStr(Line).SplitOnAllCh(',', ColV, false);
453      IAssert(ColV.Len() == 23);
454      const int PatentId = ColV[PatIdCol].GetInt();
455      const int GrantYear = ColV[GYearCol].GetInt();
456      IAssert(! TimeNet.IsNode(PatentId));
457      TimeNet.AddNode(PatentId, TSecTm(GrantYear)); 
458      if (++N % 100000 == 0) printf("\r  %dk", N/1000);
459    }
460    printf("\r  %d patents read. %s\n", N, ExeTm.GetTmStr());
461    fclose(PatF);
462    printf("\nLoading patent citations...\n");
463    int NewSrcIds=0, NewDstIds=0, DupLinks=0, NewCits=0;
464    N = 0;  ExeTm.Tick();
465    TStr SrcId, DstId;
466    FILE *CiteF = fopen(CiteFNm.CStr(), "rt");
467    fgets(Line, 1024, CiteF); 
468    while (! feof(CiteF)) {
469      Line[0] = 0;
470      fgets(Line, 1024, CiteF);
471      if (strlen(Line) == 0) break;
472      Line[strlen(Line)-1] = 0; 
473      TStr(Line).SplitOnCh(SrcId, ',', DstId);
474      const int SrcNId = SrcId.GetInt();
475      const int DstNId = DstId.GetInt();
476      if (! TimeNet.IsNode(SrcNId) && ! TimeNet.IsNode(DstNId)) {
477        NewCits++;
478        continue;
479      }
480      else if (TimeNet.IsNode(SrcNId) && ! TimeNet.IsNode(DstNId)) {
481        TimeNet.AddNode(DstNId, TimeNet.GetNDat(SrcNId));  NewDstIds++;
482      }
483      else if (! TimeNet.IsNode(SrcNId) && TimeNet.IsNode(DstNId)) {
484        TimeNet.AddNode(SrcNId, TimeNet.GetNDat(DstNId));  NewSrcIds++;
485      }
486      if (! TimeNet.IsEdge(SrcNId, DstNId)) {
487        TimeNet.AddEdge(SrcNId, DstNId);
488      } else { DupLinks++; }
489      if (++N % 100000 == 0) printf("\r  %dk", N/1000);
490    }
491    fclose(CiteF);
492    printf("\r  %d citations read. %s\n\n", N, ExeTm.GetTmStr());
493    printf("Graph: nodes: %d    edges: %d\n", TimeNet.GetNodes(), TimeNet.GetEdges());
494    printf("Removing 0-degree nodes: %d nodes\n", TSnap::CntDegNodes(TimeNetPt, 0));
495    TIntV RmNIdV;
496    for (TTimeNet::TNodeI ni = TimeNet.BegNI(); ni < TimeNet.EndNI(); ni++) {
497      if (ni.GetDeg() == 0) { RmNIdV.Add(ni.GetId()); }
498    }
499    for (int i = 0; i < RmNIdV.Len(); i++) {
500      TimeNet.DelNode(RmNIdV[i]);
501    }
502    TimeNet.Defrag(true);
503    printf("\nFinal graph: nodes: %d    edges: %d\n", TimeNet.GetNodes(), TimeNet.GetEdges());
504    printf("  Duplicate citations                    : %d\n", DupLinks);
505    printf("  Citations between unknown time nodes   : %d\n", NewCits);
506    printf("  Nodes without time which make citations: %d\n", NewSrcIds);
507    printf("  Nodes without time which are cited     : %d\n", NewDstIds);
508    return TimeNetPt;
509  }
510  PTimeNet TTimeNet::LoadAmazon(const TStr& StlFNm) {
511    PTimeNet TimeNetPt = TTimeNet::New();
512    TTimeNet& TimeNet = *TimeNetPt;
513    TimeNet.Reserve(3953993, -1);
514    printf("Amazon Share-the-Love...\n");
515    char line [2024], MonthStr[4];
516    int NLines=0;
517    TStrV ColV;
518    FILE *F = fopen(StlFNm.CStr(), "rt");
519    while (! feof(F)) {
520      memset(line, 0, 2024);
521      fgets(line, 2024, F);
522      if (strlen(line) == 0) break;
523      TStr(line).SplitOnAllCh(',', ColV);
524      const int SrcNId = ColV[0].GetInt();
525      const int DstNId = ColV[1].GetInt();
526      TStr TmStr = ColV[2]; 
527      int Year = TmStr.GetSubStr(5, 6).GetInt();
528      if (Year < 10) { Year += 2000; } else { Year += 1900; }
529      MonthStr[0]=toupper(TmStr[2]);  MonthStr[1]=tolower(TmStr[3]);
530      MonthStr[2]=tolower(TmStr[4]);  MonthStr[3]=0;
531      const int Month = TTmInfo::GetMonthN(MonthStr, lUs);
532      const int Day = TmStr.GetSubStr(0, 1).GetInt();
533      const int Hour = TmStr.GetSubStr(8, 9).GetInt();
534      const int Min = TmStr.GetSubStr(11, 12).GetInt();
535      const int Sec = TmStr.GetSubStr(14, 15).GetInt();
536      if (! TimeNet.IsNode(SrcNId)) { TimeNet.AddNode(SrcNId, TSecTm(Year, Month, Day, Hour, Min, Sec)); }
537      if (! TimeNet.IsNode(DstNId)) { TimeNet.AddNode(DstNId, TSecTm(Year, Month, Day, Hour, Min, Sec)); }
538      if (! TimeNet.IsEdge(SrcNId, DstNId)) { TimeNet.AddEdge(SrcNId, DstNId); }
539      if (++NLines % 100000 == 0) printf("\r  %dk", NLines/1000);
540    }
541    fclose(F);
542    printf("\r  %d lines read\n", NLines);
543    printf("Graph: nodes: %d  edges: %d\n", TimeNet.GetNodes(), TimeNet.GetEdges());
544    TimeNet.Defrag(true);
545    return TimeNetPt;
546  }
547  TTimeNENet& TTimeNENet::operator = (const TTimeNENet& TimeNet) {
548    if (this != &TimeNet) {
549      TNet::operator=(TimeNet);
550    }
551    return *this;
552  }
553  PTimeNet TTimeNENet::GetTimeNet() const {
554    PTimeNet NewNet = TTimeNet::New();
555    NewNet->Reserve(GetNodes(), -1);
556    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
557      NewNet->AddNode(NI.GetId(), NI.GetDat());
558    }
559    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
560      const int src = EI.GetSrcNId();
561      const int dst = EI.GetDstNId();
562      if (! NewNet->IsEdge(src, dst)) {
563        NewNet->AddEdge(src, dst); }
564    }
565    NewNet->Defrag();
566    return NewNet;
567  }
568  PTimeNENet TTimeNENet::Get1stEdgeNet() const {
569    PTimeNENet Net = TTimeNENet::New();
570    Net->Reserve(GetNodes(), -1);
571    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
572      Net->AddNode(NI.GetId(), NI.GetDat()); }
573    TIntV EIdV;  GetEIdByTm(EIdV);
574    TIntPrSet EdgeSet(GetEdges());
575    for (int edge = 0; edge < EIdV.Len(); edge++) {
576      const TEdgeI EI = GetEI(EIdV[edge]);
577      const int Src = EI.GetSrcNId();
578      const int Dst = EI.GetDstNId();
579      if (Src==Dst || EdgeSet.IsKey(TIntPr(TMath::Mn(Src, Dst), TMath::Mx(Src, Dst)))) { continue; } 
580      EdgeSet.AddKey(TIntPr(TMath::Mn(Src, Dst), TMath::Mx(Src, Dst)));
581      Net->AddEdge(EI);
582    }
583    return Net;
584  }
585  PTimeNENet TTimeNENet::GetSubGraph(const TIntV& NIdV) const {
586    PTimeNENet NewNetPt = TTimeNENet::New();
587    TTimeNENet& NewNet = *NewNetPt;
588    NewNet.Reserve(NIdV.Len(), -1);
589    int node, edge;
590    TNodeI NI;
591    for (node = 0; node < NIdV.Len(); node++) {
592      NewNet.AddNode(NIdV[node], GetNDat(NIdV[node]));
593    }
594    for (node = 0; node < NIdV.Len(); node++) {
595      NI = GetNI(NIdV[node]);
596      for (edge = 0; edge < NI.GetOutDeg(); edge++) {
597        const TEdgeI EI = GetEI(NI.GetOutEId(edge));
598        if (NewNet.IsNode(EI.GetDstNId())) {
599          NewNet.AddEdge(EI); }
600      }
601    }
602    NewNet.Defrag();
603    return NewNetPt;
604  }
605  PTimeNENet TTimeNENet::GetESubGraph(const TIntV& EIdV) const {
606    PTimeNENet NewNetPt = TTimeNENet::New();
607    TTimeNENet& NewNet = *NewNetPt;
608    NewNet.Reserve(-1, EIdV.Len());
609    for (int edge = 0; edge < EIdV.Len(); edge++) {
610      const TEdgeI Edge = GetEI(EIdV[edge]);
611      if (! NewNet.IsNode(Edge.GetSrcNId()))
612        NewNet.AddNode(GetNI(Edge.GetSrcNId()));
613      if (! NewNet.IsNode(Edge.GetDstNId()))
614        NewNet.AddNode(GetNI(Edge.GetDstNId()));
615      NewNet.AddEdge(Edge);
616    }
617    NewNet.Defrag();
618    return NewNetPt;
619  }
620  PTimeNENet TTimeNENet::GetGraphUpToTm(const TSecTm& MaxEdgeTm) const {
621    PTimeNENet NewNetPt = TTimeNENet::New();
622    TTimeNENet& NewNet = *NewNetPt;
623    TSecTm PrevTm;
624    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
625      if (EI() > MaxEdgeTm) { break; }
626      if (! NewNet.IsNode(EI.GetSrcNId()))
627        NewNet.AddNode(GetNI(EI.GetSrcNId()));
628      if (! NewNet.IsNode(EI.GetDstNId()))
629        NewNet.AddNode(GetNI(EI.GetDstNId()));
630      NewNet.AddEdge(EI);
631      IAssert(! PrevTm.IsDef() || PrevTm <= EI()); 
632      PrevTm = EI();
633    }
634    NewNet.Defrag();
635    return NewNetPt;
636  }
637  void TTimeNENet::SortNodeEdgeTimes() {
638    NodeH.SortByDat(true);
639    EdgeH.SortByDat(true);
640  }
641  void TTimeNENet::UpdateNodeTimes() {
642    int Cnt = 0;
643    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
644      TSecTm& NodeTm = NI();
645      for (int edge = 0; edge < NI.GetOutDeg(); edge++) {
646        const TSecTm& EdgeTm = GetEDat(NI.GetOutEId(edge));
647        if (! NodeTm.IsDef() || EdgeTm < NodeTm) { NodeTm = EdgeTm; Cnt++; }
648      }
649      for (int edge = 0; edge < NI.GetInDeg(); edge++) {
650        const TSecTm& EdgeTm = GetEDat(NI.GetInEId(edge));
651        if (! NodeTm.IsDef() || EdgeTm < NodeTm) { NodeTm = EdgeTm; Cnt++; }
652      }
653    }
654    printf("Update node times: %d/%d updates\n", Cnt, GetNodes());
655  }
656  void TTimeNENet::SetNodeTmToFirstEdgeTm() {
657    int Cnt = 0;
658    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
659      if (NI.GetDeg() == 0) { continue; }
660      TSecTm NodeTm;
661      for (int edge = 0; edge < NI.GetOutDeg(); edge++) {
662        const TSecTm& EdgeTm = GetEDat(NI.GetOutEId(edge));  IAssert(EdgeTm.IsDef());
663        if (! NodeTm.IsDef() || EdgeTm < NodeTm) { NodeTm = EdgeTm; Cnt++; }
664      }
665      for (int edge = 0; edge < NI.GetInDeg(); edge++) {
666        const TSecTm& EdgeTm = GetEDat(NI.GetInEId(edge));  IAssert(EdgeTm.IsDef());
667        if (! NodeTm.IsDef() || EdgeTm < NodeTm) { NodeTm = EdgeTm; Cnt++; }
668      }
669      GetNDat(NI.GetId()) = NodeTm;
670    }
671    printf("Node times set: %d/%d updates\n", Cnt, GetNodes());
672  }
673  void TTimeNENet::SetRndEdgeTimes(const int& MinTmEdge) {
<span onclick='openModal()' class='match'>674    printf("Shuffling last %d (%d%%) edge arrival times..\n", GetEdges()-MinTmEdge, int(100.0*(GetEdges()-MinTmEdge)/double(GetEdges())));
675    TIntV RndEIdV;  GetEIdByTm(RndEIdV);
676    TIntV TrueEIdV = RndEIdV;
677    TSecTmV TrueTmV;
678    const int SwapLen = RndEIdV.Len()-MinTmEdge;
679    for (int R = 0; R < 10; R++) {
680      for (int i = MinTmEdge; i < RndEIdV.Len(); i++) {
</span>681        RndEIdV.Swap(TInt::Rnd.GetUniDevInt(SwapLen)+MinTmEdge, TInt::Rnd.GetUniDevInt(SwapLen)+MinTmEdge); }
682    }
683    for (int e = 0; e < TrueEIdV.Len(); e++) {
684      TrueTmV.Add(GetEDat(TrueEIdV[e])); }
685    for (int e = 0; e < RndEIdV.Len(); e++) {
686      GetEDat(RndEIdV[e]) = TrueTmV[e]; }
687    UpdateNodeTimes();
688  }
689  void TTimeNENet::DumpTimeStat() const {
690    TSecTm MnNodeTm, MxNodeTm;
691    TSecTm MnEdgeTm, MxEdgeTm;
692    for (TNodeI NI = BegNI(); NI < EndNI(); NI++) {
693      const TSecTm NodeTm = NI();
694      if (! MnNodeTm.IsDef() || MnNodeTm>NodeTm) { MnNodeTm = NodeTm; }
695      if (! MxNodeTm.IsDef() || MxNodeTm<NodeTm) { MxNodeTm = NodeTm; }
696    }
697    printf("Node times:\n  %s\n  %s\n", MnNodeTm.GetStr().CStr(), MxNodeTm.GetStr().CStr());
698    for (TEdgeI EI= BegEI(); EI < EndEI(); EI++) {
699      const TSecTm EdgeTm = EI();
700      if (! MnEdgeTm.IsDef() || MnEdgeTm>EdgeTm) { MnEdgeTm = EdgeTm; }
701      if (! MxEdgeTm.IsDef() || MxEdgeTm<EdgeTm) { MxEdgeTm = EdgeTm; }
702    }
703    printf("Edge times:\n  %s\n  %s\n", MnEdgeTm.GetStr().CStr(), MxEdgeTm.GetStr().CStr());
704  }
705  void TTimeNENet::GetNIdByTm(TIntV& NIdV) const {
706    TVec<TKeyDat<TSecTm, TInt> > TmToNIdV(GetNodes(), 0);
707    for (TNodeI NodeI = BegNI(); NodeI < EndNI(); NodeI++) {
708      TmToNIdV.Add(TKeyDat<TSecTm, TInt>(NodeI.GetDat(), NodeI.GetId())); }
709    TmToNIdV.Sort();
710    NIdV.Gen(GetNodes(), 0);
711    for (int i = 0; i < TmToNIdV.Len(); i++) {
712      NIdV.Add(TmToNIdV[i].Dat); }
713  }
714  void TTimeNENet::GetEIdByTm(TIntV& EIdV) const {
715    TVec<TKeyDat<TSecTm, TInt> > TmToEIdV(GetEdges(), 0);
716    for (TEdgeI EI= BegEI(); EI < EndEI(); EI++) {
717      TmToEIdV.Add(TKeyDat<TSecTm, TInt>(EI.GetDat(), EI.GetId())); }
718    TmToEIdV.Sort();
719    EIdV.Gen(GetEdges(), 0);
720    for (int i = 0; i < TmToEIdV.Len(); i++) {
721      EIdV.Add(TmToEIdV[i].Dat); }
722  }
723  void TTimeNENet::GetTmBuckets(const TTmUnit& TmUnit, TTimeNet::TTmBucketV& TmBucketV) const {
724    THash<TInt, TIntV> TmIdToNIdVH;
725    TIntV NIdV;  GetNIdByTm(NIdV);
726    for (int n = 0; n < NIdV.Len(); n++) {
727      const int TmId = GetNDat(NIdV[n]).Round(TmUnit).GetAbsSecs();
728      if (! TmIdToNIdVH.IsKey(TmId)) { TmIdToNIdVH.AddKey(TmId); }
729      TmIdToNIdVH.GetDat(TmId).Add(NIdV[n]);
730    }
731    TVec<TPair<TInt, TIntV> > TmIdNIdVV;
732    TmIdToNIdVH.GetKeyDatPrV(TmIdNIdVV);
733    TmIdNIdVV.Sort();
734    TmBucketV.Gen(TmIdNIdVV.Len());
735    for (int i = 0; i < TmIdNIdVV.Len(); i++) {
736      TTimeNet::TTmBucket& Bucket = TmBucketV[i];
737      Bucket.BegTm = TmIdNIdVV[i].Val1;
738      Bucket.NIdV = TmIdNIdVV[i].Val2;
739    }
740  }
741  void TTimeNENet::GetEdgeTmBuckets(const TTmUnit& TmUnit, TTimeNet::TTmBucketV& TmBucketV) const {
742    THash<TInt, TIntV> TmIdToEIdVH;
743    TIntV EIdV;  GetEIdByTm(EIdV);
744    for (int e = 0; e < EIdV.Len(); e++) {
745      const int TmId = GetEDat(EIdV[e]).Round(TmUnit).GetAbsSecs();
746      if (! TmIdToEIdVH.IsKey(TmId)) { TmIdToEIdVH.AddKey(TmId); }
747      TmIdToEIdVH.GetDat(TmId).Add(EIdV[e]);
748    }
749    TVec<TPair<TInt, TIntV> > TmIdEIdVV;
750    TmIdToEIdVH.GetKeyDatPrV(TmIdEIdVV);
751    TmIdEIdVV.Sort();
752    TmBucketV.Gen(TmIdEIdVV.Len());
753    for (int i = 0; i < TmIdEIdVV.Len(); i++) {
754      TTimeNet::TTmBucket& Bucket = TmBucketV[i];
755      Bucket.BegTm = TmIdEIdVV[i].Val1;
756      Bucket.NIdV = TmIdEIdVV[i].Val2;
757    }
758  }
759  void TTimeNENet::GetNodeBuckets(const int NodesPerBucket, TTimeNet::TTmBucketV& TmBucketV) const {
760    TIntV NIdV;  GetNIdByTm(NIdV);
761    TmBucketV.Gen(NIdV.Len() / NodesPerBucket + 1, 0);
762    for (int i = 0; i < NIdV.Len(); i++) {
763      const int b = i/NodesPerBucket;
764      if (TmBucketV.Len() <= b) { TmBucketV.Add(TTimeNet::TTmBucket(TSecTm(b))); }
765      TmBucketV[b].NIdV.Add(NIdV[i]);
766    }
767  }
768  void TTimeNENet::GetEdgeBuckets(const int EdgesPerBucket, TTimeNet::TTmBucketV& TmBucketV) const {
769    TIntV EIdV;  GetEIdByTm(EIdV);
770    TmBucketV.Gen(EIdV.Len()/EdgesPerBucket + 1, 0);
771    for (int i = 0; i < EIdV.Len(); i++) {
772      const int b = i/EdgesPerBucket;
773      if (TmBucketV.Len() <= b) { TmBucketV.Add(TTimeNet::TTmBucket(TSecTm(b))); }
774      TmBucketV[b].NIdV.Add(EIdV[i]);
775    }
776  }
777  int TTimeNENet::GetTriadEdges(TIntV& TriadEIdV) const {
778    PUNGraph Graph = TUNGraph::New(GetNodes(), GetEdges());
779    TIntV EIdV;  GetEIdByTm(EIdV);
780    TriadEIdV.Clr();
781    TExeTm ExeTm;
782    for (int edge = 0; edge < EIdV.Len(); edge++) {
783      const TEdgeI EI = GetEI(EIdV[edge]);
784      const int Src = EI.GetSrcNId();
785      const int Dst = EI.GetDstNId();
786      if (Src==Dst || Graph->IsEdge(Src, Dst)) { continue; } 
787      if (! Graph->IsNode(Src)) { Graph->AddNode(Src); }
788      if (! Graph->IsNode(Dst)) { Graph->AddNode(Dst); }
789      if (TSnap::GetCmnNbrs(Graph, Src, Dst) > 0) { TriadEIdV.Add(EIdV[edge]); }
790      Graph->AddEdge(Src, Dst);
791      if (edge % 10000 == 0) {
792        printf("\redges %dk / %dk: triangle edges: %dk [total %s]", edge/1000, EIdV.Len()/1000,
793          TriadEIdV.Len()/1000, ExeTm.GetStr()); }
794    }
795    return Graph->GetEdges();
796  }
797  PGStatVec TTimeNENet::TimeGrowth(const TTmUnit& TimeStep, const TFSet& TakeStat, const TSecTm& StartTm) const {
798    TExeTm ExeTm;
799    PGStatVec GStatVec = TGStatVec::New(TimeStep, TakeStat);
800    TTimeNet::TTmBucketV TmBucketV;
801    GetEdgeTmBuckets(TimeStep, TmBucketV);
802    const PNEGraph FullGraph = TSnap::ConvertGraph<PNEGraph>(PTimeNENet((TTimeNENet*)this));
803    TIntV EdgeIdV;
804    for (int t = 0; t < TmBucketV.Len(); t++) {
805      EdgeIdV.AddV(TmBucketV[t].NIdV); 
806      printf("\n***%d/%d: %s (%d edges) ", t+1, TmBucketV.Len(), TmBucketV[t].BegTm.GetStr().CStr(), EdgeIdV.Len());  ExeTm.Tick();
807      if (TmBucketV[t].BegTm < StartTm) { continue; }
808      const PNEGraph PreGraph = TSnap::GetESubGraph(FullGraph, EdgeIdV);
809      GStatVec->Add(PreGraph, TmBucketV[t].BegTm);
810      printf("  [%s]\n", ExeTm.GetTmStr());
811    }
812    return GStatVec;
813  }
814  PGStatVec TTimeNENet::TimeGrowth(const TStr& FNmPref, const TStr& Desc, const TFSet& TakeStat, const int& NDiamRuns,
815                              const TTmUnit& TmUnit, const int& TakeNTmUnits, const bool& LinkBWays) const {
816    TGStat::NDiamRuns = NDiamRuns;
817    PGStatVec GrowthStat = TGStatVec::New(TmUnit, TakeStat);
818    TTimeNet::TTmBucketV TmBucketV;
819    GetEdgeTmBuckets(TmUnit, TmBucketV);
820    TIntV EdgeIdV;
821    TExeTm ExeTm;
822    for (int t = 0; t < TmBucketV.Len(); t++) {
823      if (TakeNTmUnits == -1) {
824        EdgeIdV.AddV(TmBucketV[t].NIdV); }
825      else {
826        if (t < TakeNTmUnits) { continue; }
827        EdgeIdV.Clr(false);
828        for (int i = t-TakeNTmUnits; i < t; i++) { EdgeIdV.AddV(TmBucketV[i].NIdV); }
829      }
830      printf("*** %s (%d edges)\n", TmBucketV[t].BegTm.GetStr().CStr(), EdgeIdV.Len());  ExeTm.Tick();
831      PNEGraph PreGraph = TSnap::ConvertESubGraph<PNEGraph>(PTimeNENet((TTimeNENet*)this), EdgeIdV);
832      if (LinkBWays) {
833        TIntV KeepEIdV; 
834        for (TNEGraph::TEdgeI EI = PreGraph->BegEI(); EI < PreGraph->EndEI(); EI++) {
835          if (PreGraph->IsEdge(EI.GetDstNId(), EI.GetSrcNId(), true)) { KeepEIdV.Add(EI.GetId()); }
836        }
837        PreGraph = TSnap::GetESubGraph(PreGraph, KeepEIdV);
838      }
839      GrowthStat->Add(PreGraph, TmBucketV[t].BegTm);
840      { TFOut FOut(TStr::Fmt("growth.%s.gStatVec", FNmPref.CStr()));
841      GrowthStat->Save(FOut); }
842      GrowthStat->SaveTxt(FNmPref, Desc);
843      printf("  [%s]\n", ExeTm.GetTmStr());
844    }
845    return GrowthStat;
846  }
847  void TTimeNENet::PlotEffDiam(const TStr& FNmPref, const TStr& Desc, const TTmUnit& TmUnit,
848                               const TSecTm& StartTm, const int& NDiamRuns, const bool& OnlyWcc) const {
849    TTimeNet::TTmBucketV TmBucketV;
850    GetEdgeTmBuckets(TmUnit, TmBucketV);
851    PNEGraph FullGraph = TSnap::ConvertGraph<PNEGraph>(PTimeNENet((TTimeNENet*)this));
852    TIntV EdgeIdV;
853    TExeTm ExeTm, Run1Tm;
854    TFltTrV TmDiamV, NdsDiamV;
855    for (int t = 0; t < TmBucketV.Len(); t++) {
856      EdgeIdV.AddV(TmBucketV[t].NIdV); 
857      printf("\n*** %s (%d edges)\n", TmBucketV[t].BegTm.GetStr(TmUnit).CStr(), EdgeIdV.Len());  ExeTm.Tick();
858      if (TmBucketV[t].BegTm < StartTm) continue;
859      PNGraph PreGraph = TSnap::ConvertESubGraph<PNGraph>(FullGraph, EdgeIdV);
860      TMom Mom;
861      double EffDiam = 0.0;
862      for (int r = 0; r < NDiamRuns; r++) {
863        printf("%d...", r+1);  Run1Tm.Tick();
864        if (OnlyWcc) { EffDiam = TSnap::GetAnfEffDiam(TSnap::GetMxWcc(PreGraph)); }
865        else { EffDiam = TSnap::GetAnfEffDiam(PreGraph); }
866        Mom.Add(EffDiam);
867        printf("[%s]\r", Run1Tm.GetTmStr());
868      }
869      Mom.Def();
870      TmDiamV.Add(TFltTr(TmBucketV[t].BegTm.Round(TmUnit).GetAbsSecs(), Mom.GetMean(), Mom.GetSDev()));
871      NdsDiamV.Add(TFltTr(PreGraph->GetNodes(), Mom.GetMean(), Mom.GetSDev()));
872      NdsDiamV.Sort();
873      printf("  [%s]          \n", ExeTm.GetTmStr());
874      const TStr WccStr = OnlyWcc ? "WCC " : TStr::GetNullStr();
875      { TGnuPlot GnuPlot("diamEff1."+FNmPref, TStr::Fmt("%s. G(%d, %d). %d RUNS.", Desc.CStr(), GetNodes(), GetEdges(), NDiamRuns));
876      GnuPlot.SetXYLabel(TStr::Fmt("TIME [%s]", TTmInfo::GetTmUnitStr(TmUnit).CStr()), "AVERAGE "+WccStr+"Effective Diameter");
877      GnuPlot.AddErrBar(TmDiamV, "", "");
878      GnuPlot.SavePng(); }
879      { TGnuPlot GnuPlot("diamEff2."+FNmPref, TStr::Fmt("%s. G(%d, %d). %d RUNS.", Desc.CStr(), GetNodes(), GetEdges(), NDiamRuns));
880      GnuPlot.SetXYLabel("NODES", "AVERAGE "+WccStr+"Effective Diameter");
881      GnuPlot.AddErrBar(NdsDiamV, "", "");
882      GnuPlot.SavePng(); }
883    }
884  }
885  void TTimeNENet::PlotMissingPast(const TStr& FNmPref, const TStr& Desc, const TTmUnit& TmUnit,
886                                   const TSecTm& DelPreTmEdges, const TSecTm& PostTmDiam, const bool& LinkBWays) {
887    printf("\nGrowth over time: degree distribution, Growth Power Law, Diameter.\n  %s group by %s.\n",
888      FNmPref.CStr(), TTmInfo::GetTmUnitStr(TmUnit).CStr());
889    printf("  Delete out-edges of pre time %s nodes.\n  Take subgraph of post year %s subgraph.\n\n",
890      DelPreTmEdges.GetStr().CStr(), PostTmDiam.GetStr().CStr());
891  }
892  PTimeNENet TTimeNENet::GetGnmRndNet(const int& Nodes, const int& Edges) {
893    printf("Generating G_nm(%d, %d)\n", Nodes, Edges);
894    int Src, Dst;
895    PTimeNENet Net = TTimeNENet::New();
896    Net->Reserve(Nodes, Edges);
897    for (int e = 0; e < Edges; e++) {
898      Src = TInt::Rnd.GetUniDevInt(Nodes);
899      Dst = TInt::Rnd.GetUniDevInt(Nodes);
900      while (Dst == Src || Net->IsEdge(Src, Dst)) {
901        Dst = TInt::Rnd.GetUniDevInt(Nodes); }
902      if (! Net->IsNode(Src)) { Net->AddNode(Src, TSecTm(e)); }
903      if (! Net->IsNode(Dst)) { Net->AddNode(Dst, TSecTm(e)); }
904      Net->AddEdge(Src, Dst, -1, TSecTm(e));
905    }
906    return Net;
907  }
908  PTimeNENet TTimeNENet::GetPrefAttach(const int& Nodes, const int& Edges, const double& GammaIn, const double& GammaOut) {
909    const double Alpha = Nodes/double(Edges);
910    printf("Generating PA(%d, %d), with slope in:%.1f, out: %.1f\n", Nodes, Edges,
911      2+GammaIn/(Alpha/(1-Alpha)), 2+GammaOut/(Alpha/(1-Alpha)));
912    int nodes=0, edges=0, time=0, iter=0;
913    TIntV OutW(Edges, 0), InW(Edges, 0);
914    PTimeNENet Net = TTimeNENet::New();
915    Net->Reserve(Nodes, Edges);
916    Net->AddNode(0, TSecTm(time++));  nodes++;
917    OutW.Add(0);  InW.Add(0);
918    while (edges < Edges) {
919      int Src=-1, Dst=-1;  iter++;
920      if (TInt::Rnd.GetUniDev() < Alpha) {
921        if (nodes < Nodes) {
922          IAssert(Net->AddNode(nodes, TSecTm(time++)));
923          nodes++; }
924      } else {
925        if (TInt::Rnd.GetUniDev() < nodes*GammaIn/double(edges+nodes*GammaIn)) {
926          Src = TInt::Rnd.GetUniDevInt(nodes); }
927        else { Src = OutW[TInt::Rnd.GetUniDevInt(OutW.Len())]; }
928        if (TInt::Rnd.GetUniDev() < nodes*GammaOut/double(edges+nodes*GammaOut)) {
929          Dst = TInt::Rnd.GetUniDevInt(nodes); }
930        else { Dst = InW[TInt::Rnd.GetUniDevInt(InW.Len())]; }
931      }
932      if (Src == Dst || Net->IsEdge(Src, Dst)) {
933        continue;
934      }
935      if (! Net->IsNode(Src)) { Net->AddNode(Src, TSecTm(time++)); nodes++; }
936      if (! Net->IsNode(Dst)) { Net->AddNode(Dst, TSecTm(time++)); nodes++; }
937      Net->AddEdge(Src, Dst, -1, TSecTm(time++));
938      OutW.Add(Src); InW.Add(Dst); edges++;
939    }
940    for (int node = 0; node < Nodes; node++) {
941      if (! Net->IsNode(node)) {
942        Net->AddNode(node, TSecTm(time++)); }
943    }
944    return Net;
945  }
946  PTimeNENet TTimeNENet::GetPrefAttach(const int& Nodes, const int& OutDeg) {
947    printf("Generating PA, nodes:%d, out-deg:%d\n", Nodes, OutDeg);
948    int time=0;
949    PTimeNENet Net = TTimeNENet::New();
950    Net->Reserve(Nodes, OutDeg*Nodes);
951    Net->AddNode(0, TSecTm(++time));  Net->AddNode(1, TSecTm(++time));
952    Net->AddEdge(0, 1, -1, TSecTm(++time));
953    TIntV NIdV;  NIdV.Add(0);  NIdV.Add(1);
954    TIntSet NodeSet;
955    for (int node = 2; node <= Nodes; node++) {
956      NodeSet.Clr(false);
957      while (NodeSet.Len() < OutDeg && NodeSet.Len() < node) {
958        NodeSet.AddKey(NIdV[TInt::Rnd.GetUniDevInt(NIdV.Len())]);
959      }
960      const int N = Net->AddNode(node, TSecTm(++time));
961      for (int i = 0; i < NodeSet.Len(); i++) {
962        Net->AddEdge(node, NodeSet[i], -1, TSecTm(++time));
963        NIdV.Add(N);  NIdV.Add(NodeSet[i]);
964      }
965    }
966    return Net;
967  }
968  void TTimeNENet::SaveEdgeTm(const TStr& EdgeFNm, const bool& RenumberNId, const bool& RelativeTm) const {
969    TIntV EIdV;  GetEIdByTm(EIdV);
970    const int BegTm = RelativeTm ? GetEDat(EIdV[0]).GetAbsSecs() : 0;
971    TIntSet NIdMap;
972    if (RenumberNId) { NIdMap.Gen(GetNodes()); }
973    FILE *F = fopen(EdgeFNm.CStr(), "wt");
974    for (int e =0; e < EIdV.Len(); e++) {
975      const TEdgeI EI = GetEI(EIdV[e]);
976      if (RenumberNId) {
977        const int src = EI.GetSrcNId();
978        const int dst = EI.GetDstNId();
979        NIdMap.AddKey(src);  NIdMap.AddKey(dst);
980        fprintf(F, "%d\t%d\t%d\n", NIdMap.GetKeyId(src), NIdMap.GetKeyId(dst), EI().GetAbsSecs()-BegTm);
981      }else {
982        fprintf(F, "%d\t%d\t%d\n", EI.GetSrcNId(), EI.GetDstNId(), EI().GetAbsSecs()-BegTm); }
983    }
984    fclose(F);
985  }
986  PTimeNENet TTimeNENet::GetSmallNet() {
987    PTimeNENet Net = TTimeNENet::New();
988    for (int i = 1; i <= 6; i++) {
989      Net->AddNode(i, TSecTm(0)); }
990    int tm = 1;
991    Net->AddEdge(1, 2, -1, TSecTm(tm++));
992    Net->AddEdge(3, 4, -1, TSecTm(tm++));
993    Net->AddEdge(3, 1, -1, TSecTm(tm++));
994    Net->AddEdge(5, 6, -1, TSecTm(tm++));
995    Net->AddEdge(6, 4, -1, TSecTm(tm++));
996    Net->AddEdge(5, 3, -1, TSecTm(tm++));
997    Net->AddEdge(5, 4, -1, TSecTm(tm++));
998    Net->AddEdge(5, 2, -1, TSecTm(tm++));
999    return Net;
1000  }
1001  PTimeNENet TTimeNENet::LoadFlickr(const TStr& NodeFNm, const TStr& EdgeFNm) {
1002    const int BegOfTm = 1047369600; 
1003    PTimeNENet Net = TTimeNENet::New();
1004    printf("Adding nodes...");
1005    { TSsParser Ss(NodeFNm, ssfWhiteSep);
1006    while (Ss.Next()) {
1007      const int NId = Ss.GetInt(0);
1008      const int Tm = Ss.GetInt(1)+BegOfTm;
1009      if (TSecTm(Tm) < TSecTm(2002, 1, 1)) {
1010        printf("  skip node %g (time %d)\n", (double) Ss.GetLineNo(), Ss.GetInt(1)); continue; }
1011      Net->AddNode(NId, TSecTm(Tm));
1012    } }
1013    printf(" %d nodes\n", Net->GetNodes());
1014    printf("Adding edges...");
1015    int SkipCnt=0;
1016    { TSsParser Ss(EdgeFNm, ssfWhiteSep);
1017    while (Ss.Next()) {
1018      const int NId1 = Ss.GetInt(0);
1019      const int NId2 = Ss.GetInt(1);
1020      const TSecTm Tm = TSecTm(Ss.GetInt(2)+BegOfTm);
1021      if (! Net->IsNode(NId1) || ! Net->IsNode(NId2)) { printf("not node\n"); continue; }
1022      if (Tm < TSecTm(2002, 1, 1)) { SkipCnt++;
1023        printf("  skip edge %g (time %s)\n", (double) Ss.GetLineNo(), Tm.GetStr().CStr()); continue; }
1024      if (Tm+600 < Net->GetNDat(NId1)) {
1025        printf("  1:skip edge %g (time %s < %s)\n", (double) Ss.GetLineNo(), Tm.GetStr().CStr(), Net->GetNDat(NId1).GetStr().CStr());
1026        SkipCnt++;  continue; }
1027      if (Tm+600 < Net->GetNDat(NId2)) { SkipCnt++;
1028        printf("  2:skip edge %g (time %s < %s)\n", (double) Ss.GetLineNo(), Tm.GetStr().CStr(), Net->GetNDat(NId2).GetStr().CStr());
1029        SkipCnt++;  continue; }
1030      Net->AddEdge(NId1, NId2, -1, TSecTm(Tm));
1031    } }
1032    printf("  %d edges\n", Net->GetEdges());
1033    printf("  %d edges skipped (edge time < node time)\n", SkipCnt);
1034    Net->UpdateNodeTimes();
1035    return Net;
1036  }
1037  PTimeNENet TTimeNENet::LoadEdgeTm(const TStr& EdgeFNm, const int& SrcFld, const int& DstFld, const int& TimeFld, const TSsFmt& Separator) {
1038    printf("Loading %s\n", EdgeFNm.CStr());
1039    PTimeNENet Net = TTimeNENet::New();
1040    TStrHash<TInt> StrToId(Mega(1), true); 
1041    int LineCnt=0;
1042    TExeTm ExeTm;
1043    TSsParser Ss(EdgeFNm, Separator);
1044    TSecTm MinTm=TSecTm::GetCurTm(), MaxTm=TSecTm(100);
1045    while (Ss.Next()) {
1046      if (Ss.IsCmt()) { continue; }
1047      IAssert(Ss.Len() > TimeFld);
1048      const char* Node1 = Ss.GetFld(SrcFld);
1049      const char* Node2 = Ss.GetFld(DstFld);
1050      const char* TmStr = Ss.GetFld(TimeFld);
1051      if (strcmp(TmStr,"NULL")==0) { continue; }
1052      const TSecTm Tm(atoi(TmStr));
1053      const int NId1 = StrToId.AddKey(Node1);
1054      const int NId2 = StrToId.AddKey(Node2);
1055      if (! Net->IsNode(NId1)) { Net->AddNode(NId1, TSecTm()); }
1056      if (! Net->IsNode(NId2)) { Net->AddNode(NId2, TSecTm()); }
1057      MinTm=TMath::Mn(MinTm, Tm);
1058      MaxTm=TMath::Mx(MaxTm, Tm);
1059      Net->AddEdge(NId1, NId2, -1, Tm);
1060      if (++LineCnt % 1000 == 0) {
1061        printf("\r  %dk lines processed: %d %d [%s]", LineCnt/1000, Net->GetNodes(), Net->GetEdges(), ExeTm.GetStr()); }
1062    }
1063    printf("\r  %d lines processed: %d %d [%s]\n", LineCnt, Net->GetNodes(), Net->GetEdges(), ExeTm.GetStr());
1064    printf("  Data range %s -- %s\n", MinTm.GetStr().CStr(), MaxTm.GetStr().CStr());
1065    Net->UpdateNodeTimes();
1066    return Net;
1067  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-mag.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "mag.h"
3  TRnd TMAGNodeSimple::Rnd = TRnd(0);
4  TRnd TMAGNodeBern::Rnd = TRnd(0);
5  TRnd TMAGNodeBeta::Rnd = TRnd(0);
6  const double TMAGAffMtx::NInf = -DBL_MAX;
7  TMAGAffMtx::TMAGAffMtx(const TFltV& SeedMatrix) : SeedMtx(SeedMatrix) {
8    MtxDim = (int) sqrt((double)SeedMatrix.Len());
9    IAssert(MtxDim*MtxDim == SeedMtx.Len());
10  }
11  TMAGAffMtx& TMAGAffMtx::operator = (const TMAGAffMtx& Kronecker) {
12    if (this != &Kronecker){
13      MtxDim=Kronecker.MtxDim;
14      SeedMtx=Kronecker.SeedMtx;
15    }
16    return *this;
17  }
18  bool TMAGAffMtx::IsProbMtx() const {
19    for (int i = 0; i < Len(); i++) {
20      if (At(i) < 0.0 || At(i) > 1.0) return false;
21    }
22    return true;
23  }
24  void TMAGAffMtx::SetRndMtx(TRnd& Rnd, const int& PrmMtxDim, const double& MinProb) {
25    MtxDim = PrmMtxDim;
26    SeedMtx.Gen(MtxDim*MtxDim);
27    for (int p = 0; p < SeedMtx.Len(); p++) {
28      do {
29        SeedMtx[p] = Rnd.GetUniDev();
30      } while (SeedMtx[p] < MinProb);
31    }
32  }
33  void TMAGAffMtx::SetEpsMtx(const double& Eps1, const double& Eps0, const int& Eps1Val, const int& Eps0Val) {
34    for (int i = 0; i < Len(); i++) {
35      double& Val = At(i);
36      if (Val == Eps1Val) Val = double(Eps1);
37      else if (Val == Eps0Val) Val = double(Eps0);
38    }
39  }
40  void TMAGAffMtx::AddRndNoise(TRnd& Rnd, const double& SDev) {
41    Dump("before");
42    double NewVal;
43    int c =0;
44    for (int i = 0; i < Len(); i++) {
45      for(c = 0; ((NewVal = At(i)*Rnd.GetNrmDev(1, SDev, 0.8, 1.2)) < 0.01 || NewVal>0.99) && c <1000; c++) { }
46      if (c < 999) { At(i) = NewVal; } else { printf("XXXXX\n"); }
47    }
48    Dump("after");
49  }
50  TStr TMAGAffMtx::GetMtxStr() const {
51    TChA ChA("[");
52    for (int i = 0; i < Len(); i++) {
53      ChA += TStr::Fmt("%g", At(i));
54      if ((i+1)%GetDim()==0 && (i+1<Len())) { ChA += "; "; }
55      else if (i+1<Len()) { ChA += " "; }
56    }
57    ChA += "]";
58    return TStr(ChA);
59  }
60  void TMAGAffMtx::GetLLMtx(TMAGAffMtx& LLMtx) {
61    LLMtx.GenMtx(MtxDim);
62    for (int i = 0; i < Len(); i++) {
63      if (At(i) != 0.0) { LLMtx.At(i) = log(At(i)); }
64      else { LLMtx.At(i) = NInf; }
65    }
66  }
67  void TMAGAffMtx::GetProbMtx(TMAGAffMtx& ProbMtx) {
68    ProbMtx.GenMtx(MtxDim);
69    for (int i = 0; i < Len(); i++) {
70      if (At(i) != NInf) { ProbMtx.At(i) = exp(At(i)); }
71      else { ProbMtx.At(i) = 0.0; }
72    }
73  }
74  void TMAGAffMtx::Swap(TMAGAffMtx& Mtx) {
75    ::Swap(MtxDim, Mtx.MtxDim);
76    SeedMtx.Swap(Mtx.SeedMtx);
77  }
78  double TMAGAffMtx::GetMtxSum() const {
79    double Sum = 0;
80    for (int i = 0; i < Len(); i++) {
81      Sum += At(i); }
82    return Sum;
83  }
84  double TMAGAffMtx::GetRowSum(const int& RowId) const {
85    double Sum = 0;
86    for (int c = 0; c < GetDim(); c++) {
87      Sum += At(RowId, c); }
88    return Sum;
89  }
90  double TMAGAffMtx::GetColSum(const int& ColId) const {
91    double Sum = 0;
92    for (int r = 0; r < GetDim(); r++) {
93      Sum += At(r, ColId); }
94    return Sum;
95  }
96  double TMAGAffMtx::Normalize() {
97  	double Sum = GetMtxSum();
98  	if(Sum == 0) {
99  		return 0;
100  	}
101  	for(int i = 0; i < Len(); i++) {
102  		At(i) = At(i) / Sum;
103  	}
104  	return Sum;
105  }
106  void TMAGAffMtx::Dump(const TStr& MtxNm, const bool& Sort) const {
107    if (! MtxNm.Empty()) printf("%s\n", MtxNm.CStr());
108    double Sum=0.0;
109    TFltV ValV = SeedMtx;
110    if (Sort) { ValV.Sort(false); }
111    for (int i = 0; i < ValV.Len(); i++) {
112      printf("  %10.4g", ValV[i]());
113      Sum += ValV[i];
114      if ((i+1) % GetDim() == 0) { printf("\n"); }
115    }
116    printf(" (sum:%.4f)\n", Sum);
117  }
118  double TMAGAffMtx::GetAvgAbsErr(const TMAGAffMtx& Mtx1, const TMAGAffMtx& Mtx2) {
119    TFltV P1 = Mtx1.GetMtx();
120    TFltV P2 = Mtx2.GetMtx();
121    IAssert(P1.Len() == P2.Len());
122    P1.Sort();  P2.Sort();
123    double delta = 0.0;
124    for (int i = 0; i < P1.Len(); i++) {
125      delta += fabs(P1[i] - P2[i]);
126    }
127    return delta/P1.Len();
128  }
129  double TMAGAffMtx::GetAvgFroErr(const TMAGAffMtx& Mtx1, const TMAGAffMtx& Mtx2) {
130    TFltV P1 = Mtx1.GetMtx();
131    TFltV P2 = Mtx2.GetMtx();
132    IAssert(P1.Len() == P2.Len());
133    P1.Sort();  P2.Sort();
134    double delta = 0.0;
135    for (int i = 0; i < P1.Len(); i++) {
136      delta += pow(P1[i] - P2[i], 2);
137    }
138    return sqrt(delta/P1.Len());
139  }
140  TMAGAffMtx TMAGAffMtx::GetMtx(TStr MatlabMtxStr) {
141    TStrV RowStrV, ColStrV;
142    MatlabMtxStr.ChangeChAll(',', ' ');
143    MatlabMtxStr.SplitOnAllCh(';', RowStrV);  IAssert(! RowStrV.Empty());
144    RowStrV[0].SplitOnWs(ColStrV);    IAssert(! ColStrV.Empty());
<span onclick='openModal()' class='match'>145    const int Rows = RowStrV.Len();
146    const int Cols = ColStrV.Len();
147    IAssert(Rows == Cols);
148    TMAGAffMtx Mtx(Rows);
149    for (int r = 0; r < Rows; r++) {
150      RowStrV[r].SplitOnWs(ColStrV);
151      IAssert(ColStrV.Len() == Cols);
152      for (int c = 0; c < Cols; c++) {
</span>153        Mtx.At(r, c) = (double) ColStrV[c].GetFlt(); }
154    }
155    return Mtx;
156  }
157  TMAGAffMtx TMAGAffMtx::GetRndMtx(TRnd& Rnd, const int& Dim, const double& MinProb) {
158    TMAGAffMtx Mtx;
159    Mtx.SetRndMtx(Rnd, Dim, MinProb);
160    return Mtx;
161  }
162  void TMAGNodeSimple::AttrGen(TIntVV& AttrVV, const int& NNodes) {
163  	IAssert(Dim > 0);
164  	AttrVV.Gen(NNodes, Dim);
165  	AttrVV.PutAll(0);
166  	for(int i = 0; i < NNodes; i++) {
167  		for(int l = 0; l < Dim; l++) {
168  			if((TMAGNodeSimple::Rnd).GetUniDev() > Mu) {
169  				AttrVV.At(i, l) = 1;
170  			}
171  		}
172  	}
173  }
174  void TMAGNodeSimple::LoadTxt(const TStr& InFNm) {
175  	FILE *fp = fopen(InFNm.CStr(), "r");
176  	IAssertR(fp != NULL, "File does not exist: " + InFNm);
177  	char buf[128];
178  	char *token;
179  	TStr TokenStr;
180  	TFlt Val;
181  	token = strtok(buf, "&");
182  	token = strtok(token, " \t");
183  	TokenStr = TStr(token);
184  	Mu = TokenStr.GetFlt(Val);
185  	fclose(fp);
186  }
187  void TMAGNodeSimple::SaveTxt(TStrV& OutStrV) const {
188  	OutStrV.Gen(Dim, 0);
189  	for(int i = 0; i < Dim; i++) {
190  		OutStrV.Add(TStr::Fmt("%f", double(Mu)));
191  	}
192  }
193  TMAGNodeBern& TMAGNodeBern::operator=(const TMAGNodeBern& Dist) {
194  	MuV = Dist.MuV;
195  	Dim = Dist.Dim;
196  	return (*this);
197  }
198  void TMAGNodeBern::AttrGen(TIntVV& AttrVV, const int& NNodes) {
199  	IAssert(Dim > 0);
200  	AttrVV.Gen(NNodes, Dim);
201  	AttrVV.PutAll(0);
202  	for(int i = 0; i < NNodes; i++) {
203  		for(int l = 0; l < Dim; l++) {
204  			if((TMAGNodeBern::Rnd).GetUniDev() > MuV[l]) {
205  				AttrVV.At(i, l) = 1;
206  			}
207  		}
208  	}
209  }
210  void TMAGNodeBern::LoadTxt(const TStr& InFNm) {
211  	FILE *fp = fopen(InFNm.CStr(), "r");
212  	IAssertR(fp != NULL, "File does not exist: " + InFNm);
213  	Dim = 0;
214  	MuV.Gen(10, 0);
215  	char buf[128];
216  	char *token;
217  	TStr TokenStr;
218  	TFlt Val;
219  	while(fgets(buf, sizeof(buf), fp) != NULL) {
220  		token = strtok(buf, "&");
221  		token = strtok(token, " \t");
222  		TokenStr = TStr(token);
223  		MuV.Add(TokenStr.GetFlt(Val));
224  	}
225  	Dim = MuV.Len();
226  	fclose(fp);
227  }
228  void TMAGNodeBern::SaveTxt(TStrV& OutStrV) const {
229  	OutStrV.Gen(Dim, 0);
230  	for(int i = 0; i < Dim; i++) {
231  		OutStrV.Add(TStr::Fmt("%f", double(MuV[i])));
232  	}
233  }
234  TMAGNodeBeta& TMAGNodeBeta::operator=(const TMAGNodeBeta& Dist) {
235  	AlphaV = Dist.AlphaV;
236  	BetaV = Dist.BetaV;
237  	Dim = Dist.Dim;
238  	MuV = Dist.MuV;
239  	Dirty = Dist.Dirty;
240  	return (*this);
241  }
242  void TMAGNodeBeta::SetBeta(const int& Attr, const double& Alpha, const double& Beta) {
243  	IAssert(Attr < Dim);
244  	AlphaV[Attr] = Alpha;
245  	BetaV[Attr] = Beta;
246  	Dirty = true;
247  }
248  void TMAGNodeBeta::SetBetaV(const TFltV& _AlphaV, const TFltV& _BetaV) {
249  	IAssert(_AlphaV.Len() == _BetaV.Len());
250  	AlphaV = _AlphaV;
251  	BetaV = _BetaV;
252  	Dim = _AlphaV.Len();
253  	Dirty = true;
254  }
255  void TMAGNodeBeta::AttrGen(TIntVV& AttrVV, const int& NNodes) {
256  	IAssert(Dim > 0);
257  	AttrVV.Gen(NNodes, Dim);
258  	AttrVV.PutAll(0);
259  	for(int i = 0; i < NNodes; i++) {
260  		for(int l = 0; l < Dim; l++) {
261  			double x = TMAGNodeBeta::Rnd.GetGammaDev((int)AlphaV[l]);
262  			double y = TMAGNodeBeta::Rnd.GetGammaDev((int)BetaV[l]);
263  			MuV[l] = x / (x + y);
264  			if((TMAGNodeBeta::Rnd).GetUniDev() > MuV[l]) {
265  				AttrVV.At(i, l) = 1;
266  			}
267  		}
268  	}
269  	Dirty = false;
270  }
271  void TMAGNodeBeta::LoadTxt(const TStr& InFNm) {
272  	FILE *fp = fopen(InFNm.CStr(), "r");
273  	IAssertR(fp != NULL, "File does not exist: " + InFNm);
274  	Dim = 0;
275  	AlphaV.Gen(10, 0);
276  	BetaV.Gen(10, 0);
277  	char buf[128];
278  	char *token;
279  	TStr TokenStr;
280  	TFlt Val;
281  	while(fgets(buf, sizeof(buf), fp) != NULL) {
282  		token = strtok(buf, "&");
283  		token = strtok(token, " \t");
284  		TokenStr = TStr(token);
285  		AlphaV.Add(TokenStr.GetFlt(Val));
286  		token = strtok(NULL, " \t");
287  		TokenStr = TStr(token);
288  		BetaV.Add(TokenStr.GetFlt(Val));
289  		Dim++;
290  	}
291  	fclose(fp);
292  }
293  void TMAGNodeBeta::SaveTxt(TStrV& OutStrV) const {
294  	OutStrV.Gen(Dim, 0);
295  	for(int i = 0; i < Dim; i++) {
296  		OutStrV.Add(TStr::Fmt("%f %f", double(AlphaV[i]), double(BetaV[i])));
297  	}
298  }
299  void TMAGFitBern::SetGraph(const PNGraph& GraphPt) {
300  	Graph = GraphPt;
301  	bool NodesOk = true;
302  	for (int nid = 0; nid < Graph->GetNodes(); nid++) {
303  	if (! Graph->IsNode(nid)) { NodesOk=false; break; } }
304  	if (! NodesOk) {
305  	TIntV NIdV;  GraphPt->GetNIdV(NIdV);
306  	Graph = TSnap::GetSubGraph(GraphPt, NIdV, true);
307  	for (int nid = 0; nid < Graph->GetNodes(); nid++) {
308  	  IAssert(Graph->IsNode(nid)); }
309  	}
310  }
311  void TMAGFitBern::SetPhiVV(const TIntVV& AttrVV, const int KnownIds) {
312  	const int NNodes = Param.GetNodes();
313  	const int NAttrs = Param.GetAttrs();
314  	PhiVV.Gen(NNodes, NAttrs);
315  	KnownVV.Gen(NNodes, NAttrs);
316  	for(int l = 0; l < NAttrs; l++) {
317  		for(int i = 0; i < NNodes; i++) {
318  			if(int(AttrVV(i, l)) == 0) {
319  				PhiVV(i, l) = 0.9999;
320  			} else {
321  				PhiVV(i, l) = 0.0001;
322  			}
323  		}
324  		if(l < KnownIds) {
325  			KnownVV.PutY(l, true);
326  		} else {
327  			KnownVV.PutY(l, false);
328  		}
329  	}
330  }
331  void TMAGFitBern::SaveTxt(const TStr& FNm) {
332  	const int NNodes = Param.GetNodes();
333  	const int NAttrs = Param.GetAttrs();
334  	const TFltV MuV = GetMuV();
335  	TMAGAffMtxV MtxV;
336  	Param.GetMtxV(MtxV);
337  	FILE *fp = fopen(FNm.GetCStr(), "w");
338  	for(int l = 0; l < NAttrs; l++) {
339  		fprintf(fp, "%.4f\t", double(MuV[l]));
340  		for(int row = 0; row < 2; row++) {
341  			for(int col = 0; col < 2; col++) {
342  				fprintf(fp, " %.4f", double(MtxV[l].At(row, col)));
343  			}
344  			fprintf(fp, (row == 0) ? ";" : "\n");
345  		}
346  	}
347  	fclose(fp);
348  	fp = fopen((FNm + "f").CStr(), "w");
349  	for(int i = 0; i < NNodes; i++) {
350  		for(int l = 0; l < NAttrs; l++) {
351  			fprintf(fp, "%f ", double(PhiVV(i, l)));
352  		}
353  		fprintf(fp, "\n");
354  	}
355  	fclose(fp);
356  }
357  void TMAGFitBern::Init(const TFltV& MuV, const TMAGAffMtxV& AffMtxV) {
358  	TMAGNodeBern DistParam(MuV);
359  	Param.SetNodeAttr(DistParam);
360  	Param.SetMtxV(AffMtxV);
361  	const int NNodes = Param.GetNodes();
362  	const int NAttrs = Param.GetAttrs();
363  	PhiVV.Gen(NNodes, NAttrs);
364  	KnownVV.Gen(NNodes, NAttrs);
365  	KnownVV.PutAll(false);
366  }
367  #if 0
368  void TMAGFitBern::PerturbInit(const TFltV& MuV, const TMAGAffMtxV& AffMtxV, const double& PerturbRate) {
369  	IAssert(PerturbRate < 1.0);
370  	TFltV InitMuV = MuV;	
371  	TMAGNodeBern DistParam(InitMuV);
372  	Param.SetMtxV(AffMtxV);
373  	TRnd& Rnd = TMAGNodeBern::Rnd;
374  	TMAGAffMtxV PerturbMtxV = AffMtxV;
375  	const int NNodes = Param.GetNodes();
376  	const int NAttrs = Param.GetAttrs();
377  	for(int l = 0; l < NAttrs; l++) {
378  		double Mu = MuV[l] + PerturbRate * (Rnd.GetUniDev() - 0.5) * 2;
379  		if(Mu < 0.01) {  Mu = 0.01;  }
380  		if(Mu > 0.99) {  Mu = 0.99;  }
381  		DistParam.SetMu(l, Mu);
382  		TMAGAffMtx AffMtx(AffMtxV[l]);
383  		for(int p = 0; p < 4; p++) {
384  			AffMtx.At(p) += PerturbRate * (Rnd.GetUniDev() - 0.5) * 2;
385  			if(AffMtx.At(p) < 0.05) {  AffMtx.At(p) = 0.05;  }
386  			if(AffMtx.At(p) > 0.95) {  AffMtx.At(p) = 0.95;  }
387  		}
388  		AffMtx.At(0, 1) = AffMtx.At(1, 0);
389  		PerturbMtxV[l] = AffMtx;
390  	}
391  	printf("\n");
392  	for(int l = 0; l < NAttrs; l++) {
393  		printf("Mu = %.3f  ", DistParam.GetMu(l));
394  		printf("AffMtx = %s\n", PerturbMtxV[l].GetMtxStr().GetCStr());
395  	}
396  	Param.SetMtxV(PerturbMtxV);
397  	Param.SetNodeAttr(DistParam);
398  	PhiVV.Gen(NNodes, NAttrs);
399  	KnownVV.Gen(NNodes, NAttrs);
400  	KnownVV.PutAll(false);
401  }
402  #endif	
403  void TMAGFitBern::RandomInit(const TFltV& MuV, const TMAGAffMtxV& AffMtxV, const int& Seed) {
404  	TRnd& Rnd = TMAGNodeBern::Rnd;
405  	Rnd.PutSeed(Seed);
406  	TFltV InitMuV = MuV;	InitMuV.PutAll(0.5);
407  	TMAGNodeBern DistParam(InitMuV);
408  	Param.SetMtxV(AffMtxV);
409  	const int NNodes = Param.GetNodes();
410  	const int NAttrs = Param.GetAttrs();
411  	PhiVV.Gen(NNodes, NAttrs);
412  	KnownVV.Gen(NNodes, NAttrs);
413  	KnownVV.PutAll(false);
414  	for(int i = 0; i < NNodes; i++) {
415  		for(int l = 0; l < NAttrs; l++) {
416  			PhiVV.At(i, l) = Rnd.GetUniDev();
417  		}
418  	}
419  	TMAGAffMtxV RndMtxV = AffMtxV;
420  	for(int l = 0; l < NAttrs; l++) {
421  		for(int p = 0; p < 4; p++) {
422  			RndMtxV[l].At(p) = TMAGNodeBern::Rnd.GetUniDev();
423  			if(RndMtxV[l].At(p) < 0.1) {  RndMtxV[l].At(p) = 0.1;  }
424  			if(RndMtxV[l].At(p) > 0.9) {  RndMtxV[l].At(p) = 0.9;  }
425  		}
426  		RndMtxV[l].At(0, 1) = RndMtxV[l].At(1, 0);
427  	}
428  	printf("\n");
429  	for(int l = 0; l < NAttrs; l++) {
430  		printf("AffMtx = %s\n", RndMtxV[l].GetMtxStr().GetCStr());
431  	}
432  	Param.SetMtxV(RndMtxV);
433  	Param.SetNodeAttr(DistParam);
434  }
435  const double TMAGFitBern::GetInCoeff(const int& i, const int& j, const int& l, const int& A, const TMAGAffMtx& Theta) const {
436  	return (PhiVV.At(i, l) * Theta.At(0, A) + (1.0 - PhiVV.At(i, l)) * Theta.At(1, A));
437  }
438  const double TMAGFitBern::GetOutCoeff(const int& i, const int& j, const int& l, const int& A, const TMAGAffMtx& Theta) const {
439  	return (PhiVV.At(j, l) * Theta.At(A, 0) + (1.0 - PhiVV.At(j, l)) * Theta.At(A, 1));
440  }
441  const double TMAGFitBern::GetAvgInCoeff(const int& i, const int& AId, const int& A, const TMAGAffMtx& Theta) const {
442  	const int NNodes = Param.GetNodes();
443  	const double Mu_l = AvgPhiV[AId] / double(NNodes);
444  	return (Mu_l * Theta.At(0, A) + (1.0 - Mu_l) * Theta.At(1, A));
445  }
446  const double TMAGFitBern::GetAvgOutCoeff(const int& i, const int& AId, const int& A, const TMAGAffMtx& Theta) const {
447  	const int NNodes = Param.GetNodes();
448  	const double Mu_l = AvgPhiV[AId] / double(NNodes);
449  	return (Mu_l * Theta.At(A, 0) + (1.0 - Mu_l) * Theta.At(A, 1));
450  }
451  const double TMAGFitBern::GetProbPhi(const int& NId1, const int& NId2, const int& AId, const int& Attr1, const int& Attr2) const {
452  	double Prob1 = (Attr1 == 0) ? double(PhiVV.At(NId1, AId)) : (1.0 - PhiVV.At(NId1, AId));
453  	double Prob2 = (Attr2 == 0) ? double(PhiVV.At(NId2, AId)) : (1.0 - PhiVV.At(NId2, AId));
454  	return (Prob1 * Prob2);
455  }
456  const double TMAGFitBern::GetProbMu(const int& NId1, const int& NId2, const int& AId, const int& Attr1, const int& Attr2, const bool Left, const bool Right) const {
457  	TMAGNodeBern DistParam = Param.GetNodeAttr();
458  	double Mu = AvgPhiV[AId] / double(Param.GetNodes());
459  	double Prob1 = (Left) ? double(PhiVV.At(NId1, AId)) : double(Mu);
460  	double Prob2 = (Right)? double(PhiVV.At(NId2, AId)) : double(Mu);
461  	Prob1 = (Attr1 == 0) ? Prob1 : 1.0 - Prob1;
462  	Prob2 = (Attr2 == 0) ? Prob2 : 1.0 - Prob2;
463  	return (Prob1 * Prob2);
464  }
465  const double TMAGFitBern::GetThetaLL(const int& NId1, const int& NId2, const int& AId) const {
466  	double LL = 0.0;
467  	const TMAGAffMtx& Mtx = Param.GetMtx(AId);
468  	for(int A1 = 0; A1 < 2; A1++) {
469  		for(int A2 = 0; A2 < 2; A2++) {
470  			LL += GetProbPhi(NId1, NId2, AId, A1, A2) * Mtx.At(A1, A2);
471  		}
472  	}
473  	return log(LL);
474  }
475  const double TMAGFitBern::GetAvgThetaLL(const int& NId1, const int& NId2, const int& AId, const bool Left, const bool Right) const {
476  	double LL = 0.0;
477  	const TMAGAffMtx& Mtx = Param.GetMtx(AId);
478  	for(int A1 = 0; A1 < 2; A1++) {
479  		for(int A2 = 0; A2 < 2; A2++) {
480  			LL += GetProbMu(NId1, NId2, AId, A1, A2, Left, Right) * Mtx.At(A1, A2);
481  		}
482  	}
483  	return log(LL);
484  }
485  const double TMAGFitBern::GetSqThetaLL(const int& NId1, const int& NId2, const int& AId) const {
486  	double LL = 0.0;
487  	const TMAGAffMtx& Mtx = Param.GetMtx(AId);
488  	for(int A1 = 0; A1 < 2; A1++) {
489  		for(int A2 = 0; A2 < 2; A2++) {
490  			LL += GetProbPhi(NId1, NId2, AId, A1, A2) * Mtx.At(A1, A2) * Mtx.At(A1, A2);
491  		}
492  	}
493  	return log(LL);
494  }
495  const double TMAGFitBern::GetAvgSqThetaLL(const int& NId1, const int& NId2, const int& AId, const bool Left, const bool Right) const {
496  	double LL = 0.0;
497  	const TMAGAffMtx& Mtx = Param.GetMtx(AId);
498  	for(int A1 = 0; A1 < 2; A1++) {
499  		for(int A2 = 0; A2 < 2; A2++) {
500  			LL += GetProbMu(NId1, NId2, AId, A1, A2, Left, Right) * Mtx.At(A1, A2) * Mtx.At(A1, A2);
501  		}
502  	}
503  	return log(LL);
504  }
505  const double TMAGFitBern::GetProdLinWeight(const int& NId1, const int& NId2) const {
506  	const int NAttrs = Param.GetAttrs();
507  	double LL = 0.0;
508  	for(int l = 0; l < NAttrs; l++) {
509  		LL += GetThetaLL(NId1, NId2, l);
510  	}
511  	return LL + log(NormConst);
512  }
513  const double TMAGFitBern::GetAvgProdLinWeight(const int& NId1, const int& NId2, const bool Left, const bool Right) const {
514  	const int NAttrs = Param.GetAttrs();
515  	double LL = 0.0;
516  	for(int l = 0; l < NAttrs; l++) {
517  		LL += GetAvgThetaLL(NId1, NId2, l, Left, Right);
518  	}
519  	return LL + log(NormConst);
520  }
521  const double TMAGFitBern::GetProdSqWeight(const int& NId1, const int& NId2) const {
522  	const int NAttrs = Param.GetAttrs();
523  	double LL = 0.0;
524  	for(int l = 0; l < NAttrs; l++) {
525  		LL += GetSqThetaLL(NId1, NId2, l);
526  	}
527  	return LL + 2 * log(NormConst);
528  }
529  const double TMAGFitBern::GetAvgProdSqWeight(const int& NId1, const int& NId2, const bool Left, const bool Right) const {
530  	const int NAttrs = Param.GetAttrs();
531  	double LL = 0.0;
532  	for(int l = 0; l < NAttrs; l++) {
533  		LL += GetAvgSqThetaLL(NId1, NId2, l, Left, Right);
534  	}
535  	return LL + 2 * log(NormConst);
536  }
537  const double LogSumExp(const double LogVal1, const double LogVal2) {
538  	double MaxExp = (LogVal1 > LogVal2) ? LogVal1 : LogVal2;
539  	double Sum = exp(LogVal1 - MaxExp) + exp(LogVal2 - MaxExp);
540  	return (log(Sum) + MaxExp);
541  }
542  const double LogSumExp(const TFltV& LogValV) {
543  	const int Len = LogValV.Len();
544  	double MaxExp = -DBL_MAX;
545  	for(int i = 0; i < Len; i++) {
546  		if(MaxExp < LogValV[i]) {  MaxExp = LogValV[i];  }
547  	}
548  	double Sum = 0.0;
549  	for(int i = 0; i < Len; i++) {
550  		Sum += exp(LogValV[i] - MaxExp);
551  	}
552  	return (log(Sum) + MaxExp);
553  }
554  const double LogSumExp(const double *LogValArray, const int Len) {
555  	TFltV TmpV(Len);
556  	for(int i = 0; i < Len; i++) {  TmpV[i] = LogValArray[i];  }
557  	return LogSumExp(TmpV);
558  }
559  const double TMAGFitBern::GradPhiMI(const double& x, const int& NId, const int& AId, const double& Lambda, const double& DeltaQ, const TFltVV& CntVV) {
560  	const int NAttrs = CntVV.GetYDim();
561  	double Grad = DeltaQ - log(x) + log(1.0-x);
562  	for(int l = 0; l < NAttrs; l++) {
563  		if(l == AId) {  continue;  }
564  		const double C0 = PhiVV(NId, l);
565  		const double C1 = 1.0 - C0;
566  		Grad -= Lambda * C0 * log(CntVV(0, l) + C0 * x);
567  		Grad -= Lambda * C1 * log(CntVV(1, l) + C1 * x);
568  		Grad += Lambda * C0 * log(CntVV(2, l) + C0 * (1-x));
569  		Grad += Lambda * C1 * log(CntVV(3, l) + C1 * (1-x));
570  		Grad -= Lambda * log(CntVV(0, l) + CntVV(1, l) + x);
571  		Grad += Lambda * log(CntVV(2, l) + CntVV(3, l) + (1-x));
572  	}
573  	return Grad;
574  }
575  const double TMAGFitBern::ObjPhiMI(const double& x, const int& NId, const int& AId, const double& Lambda, const double& Q0, const double& Q1, const TFltVV& CntVV) {
576  	const int NAttrs = CntVV.GetYDim();
577  	double Val = x*(Q0 - log(x)) + (1-x)*(Q1 - log(1.0-x));
578  	for(int l = 0; l < NAttrs; l++) {
579  		if(l == AId) {  continue;  }
580  		const double C0 = PhiVV(NId, l);
581  		const double C1 = 1.0 - C0;
582  		Val -= Lambda * (CntVV(0, l) + C0 * x) * log(CntVV(0, l) + C0 * x);
583  		Val -= Lambda * (CntVV(1, l) + C1 * x) * log(CntVV(1, l) + C1 * x);
584  		Val -= Lambda * (CntVV(2, l) + C0 * (1-x)) * log(CntVV(2, l) + C0 * (1-x));
585  		Val -= Lambda * (CntVV(3, l) + C1 * (1-x)) * log(CntVV(3, l) + C1 * (1-x));
586  		Val += Lambda * (CntVV(0, l) + CntVV(1, l) + x) * log(CntVV(0, l) + CntVV(1, l) + x);
587  		Val += Lambda * (CntVV(2, l) + CntVV(3, l) + 1 - x) * log(CntVV(2, l) + CntVV(3, l) + (1-x));
588  		if(!(CntVV(0, l) > 0))	printf("CntVV(0, %d) = %.2f\n", l, double(CntVV(0, l)));
589  		if(!(CntVV(1, l) > 0))	printf("CntVV(1, %d) = %.2f\n", l, double(CntVV(1, l)));
590  		if(!(CntVV(2, l) > 0))	printf("CntVV(2, %d) = %.2f\n", l, double(CntVV(2, l)));
591  		if(!(CntVV(3, l) > 0))	printf("CntVV(3, %d) = %.2f\n", l, double(CntVV(3, l)));
592  	}
593  	return Val;
594  }
595  const double TMAGFitBern::GetEstNoEdgeLL(const int& NId, const int& AId) const {
596  	TMAGNodeBern DistParam = Param.GetNodeAttr();
597  	double LL = 0.0;
598  	return LL;
599  }
600  const double TMAGFitBern::UpdatePhi(const int& NId, const int& AId, double& Phi) {
601  	TMAGAffMtx LLTheta, Theta = Param.GetMtx(AId); 
602  	TMAGAffMtx SqTheta(Theta);
603  	const int NNodes = Param.GetNodes();
604  	Theta.GetLLMtx(LLTheta);
605  	TMAGNodeBern DistParam = Param.GetNodeAttr();
606  	const double Mu = DistParam.GetMu(AId);
607  	for(int i = 0; i < Theta.Len(); i++) {
608  		SqTheta.At(i) = SqTheta.At(i) * SqTheta.At(i);
609  	}
610  	double EdgeQ[2], NonEdgeQ[2], MaxExp[2];
611  	TFltV NonEdgeLLV[2];
612  	for(int i = 0; i < 2; i++) {
613  		EdgeQ[i] = 0.0;
614  		NonEdgeQ[i] = 0.0;
615  		MaxExp[i] = -DBL_MAX;
616  		NonEdgeLLV[i].Gen(4 * NNodes, 0);
617  	}
618  	for(int j = 0; j < NNodes; j++) {
619  		if(j == NId) {	continue;	}
620  		if(Graph->IsEdge(NId, j)) {
621  			EdgeQ[0] += GetOutCoeff(NId, j, AId, 0, LLTheta);
622  			EdgeQ[1] += GetOutCoeff(NId, j, AId, 1, LLTheta);
623  		} else {
624  			double LinW = GetProdLinWeight(NId, j) - GetThetaLL(NId, j, AId);
625  			double SqW = GetProdSqWeight(NId, j) - GetSqThetaLL(NId, j, AId);
626  			for(int i = 0; i < 2; i++) {
627  				NonEdgeLLV[i].Add(LinW + log(GetOutCoeff(NId, j, AId, i, Theta)));
628  				NonEdgeLLV[i].Add(SqW + log(GetOutCoeff(NId, j, AId, i, SqTheta)) + log(0.5));
629  			}
630  		}
631  		if(Graph->IsEdge(j, NId)) {
632  			EdgeQ[0] += GetInCoeff(j, NId, AId, 0, LLTheta);
633  			EdgeQ[1] += GetInCoeff(j, NId, AId, 1, LLTheta);
634  		} else {
635  			double LinW = GetProdLinWeight(j, NId) - GetThetaLL(j, NId, AId);
636  			double SqW = GetProdSqWeight(j, NId) - GetSqThetaLL(j, NId, AId);
637  			for(int i = 0; i < 2; i++) {
638  				NonEdgeLLV[i].Add(LinW + log(GetInCoeff(j, NId, AId, i, Theta)));
639  				NonEdgeLLV[i].Add(SqW + log(GetInCoeff(j, NId, AId, i, SqTheta)) + log(0.5));
640  			}
641  		}
642  	}
643  	NonEdgeQ[0] = LogSumExp(NonEdgeLLV[0]);
644  	NonEdgeQ[1] = LogSumExp(NonEdgeLLV[1]);
645  	double Q[2];
646  	Q[0] = log(Mu) + EdgeQ[0] - exp(NonEdgeQ[0]);
647  	Q[1] = log(1.0 - Mu) + EdgeQ[1] - exp(NonEdgeQ[1]);
648  	Phi = Q[0] - LogSumExp(Q, 2);
649  	Phi = exp(Phi);
650  	return Phi - PhiVV.At(NId, AId);
651  }
652  const double TMAGFitBern::UpdatePhiMI(const double& Lambda, const int& NId, const int& AId, double& Phi) {
653  	TMAGAffMtx LLTheta, Theta = Param.GetMtx(AId); 
654  	TMAGAffMtx SqTheta(Theta);
655  	const int NNodes = Param.GetNodes();
656  	const int NAttrs = Param.GetAttrs();
657  	Theta.GetLLMtx(LLTheta);
658  	TMAGNodeBern DistParam = Param.GetNodeAttr();
659  	const double Mu = DistParam.GetMu(AId);
660  	for(int i = 0; i < Theta.Len(); i++) {
661  		SqTheta.At(i) = SqTheta.At(i) * SqTheta.At(i);
662  	}
663  	double EdgeQ[2], NonEdgeQ[2], MaxExp[2];
664  	TFltV NonEdgeLLV[2];
665  	TFltVV CntVV(4, NAttrs);		CntVV.PutAll(0.0);
666  	for(int i = 0; i < 2; i++) {
667  		EdgeQ[i] = 0.0;
668  		NonEdgeQ[i] = 0.0;
669  		MaxExp[i] = -DBL_MAX;
670  		NonEdgeLLV[i].Gen(4 * NNodes, 0);
671  	}
672  	for(int j = 0; j < NNodes; j++) {
673  		if(j == NId) {	continue;	}
674  		for(int l = 0; l < NAttrs; l++) {
675  			if(l == AId) {  continue;  }
676  			CntVV(0, l) = CntVV(0, l) + PhiVV(j, AId) * PhiVV(j, l);
677  			CntVV(1, l) = CntVV(1, l) + PhiVV(j, AId) * (1.0-PhiVV(j, l));
678  			CntVV(2, l) = CntVV(2, l) + (1.0-PhiVV(j, AId)) * PhiVV(j, l);
679  			CntVV(3, l) = CntVV(3, l) + (1.0-PhiVV(j, AId)) * (1.0-PhiVV(j, l));
680  		}
681  		if(Graph->IsEdge(NId, j)) {
682  			EdgeQ[0] += GetOutCoeff(NId, j, AId, 0, LLTheta);
683  			EdgeQ[1] += GetOutCoeff(NId, j, AId, 1, LLTheta);
684  		} else {
685  			double LinW = GetProdLinWeight(NId, j) - GetThetaLL(NId, j, AId);
686  			double SqW = GetProdSqWeight(NId, j) - GetSqThetaLL(NId, j, AId);
687  			for(int i = 0; i < 2; i++) {
688  				NonEdgeLLV[i].Add(LinW + log(GetOutCoeff(NId, j, AId, i, Theta)));
689  				NonEdgeLLV[i].Add(SqW + log(GetOutCoeff(NId, j, AId, i, SqTheta)) + log(0.5));
690  			}
691  		}
692  		if(Graph->IsEdge(j, NId)) {
693  			EdgeQ[0] += GetInCoeff(j, NId, AId, 0, LLTheta);
694  			EdgeQ[1] += GetInCoeff(j, NId, AId, 1, LLTheta);
695  		} else {
696  			double LinW = GetProdLinWeight(j, NId) - GetThetaLL(j, NId, AId);
697  			double SqW = GetProdSqWeight(j, NId) - GetSqThetaLL(j, NId, AId);
698  			for(int i = 0; i < 2; i++) {
699  				NonEdgeLLV[i].Add(LinW + log(GetInCoeff(j, NId, AId, i, Theta)));
700  				NonEdgeLLV[i].Add(SqW + log(GetInCoeff(j, NId, AId, i, SqTheta)) + log(0.5));
701  			}
702  		}
703  	}
704  	NonEdgeQ[0] = LogSumExp(NonEdgeLLV[0]);
705  	NonEdgeQ[1] = LogSumExp(NonEdgeLLV[1]);
706  	double Q[2];
707  	Q[0] = log(Mu) + EdgeQ[0] - exp(NonEdgeQ[0]);
708  	Q[1] = log(1.0 - Mu) + EdgeQ[1] - exp(NonEdgeQ[1]);
709  	double DeltaQ = Q[0] - Q[1];
710  	double x[] = {PhiVV(NId, AId)};
711  	for(int n = 0; n < 1; n++) {
712  		double LrnRate = 0.001;
713  		for(int step = 0; step < 200; step++) {
714  			double Grad = GradPhiMI(x[n], NId, AId, Lambda, DeltaQ, CntVV);
715  			if(Grad > 0.0) {  x[n] += LrnRate;  }
716  			else {  x[n] -= LrnRate;  }
717  			if(x[n] > 0.9999) {  x[n] = 0.9999;  }
718  			if(x[n] < 0.0001) {  x[n] = 0.0001;  }
719  			LrnRate *= 0.995;
720  		}
721  	}
722  	double MaxVal = -DBL_MAX;
723  	int MaxX = -1;
724  	for(int n = 0; n < 1; n++) {
725  		double Val = ObjPhiMI(x[n], NId, AId, Lambda, Q[0], Q[1], CntVV);
726  		if(Val > MaxVal) {
727  			MaxVal = Val;
728  			MaxX = n;
729  		}
730  	}
731  	IAssert(MaxX >= 0);
732  	Phi = x[MaxX];
733  	return Phi - PhiVV.At(NId, AId);
734  }
735  const double TMAGFitBern::UpdateApxPhiMI(const double& Lambda, const int& NId, const int& AId, double& Phi, TFltVV& ProdVV) {
736  	TMAGAffMtx LLTheta, Theta = Param.GetMtx(AId); 
737  	const int NNodes = Param.GetNodes();
738  	const int NAttrs = Param.GetAttrs();
739  	Theta.GetLLMtx(LLTheta);
740  	TMAGNodeBern DistParam = Param.GetNodeAttr();
741  	const double Mu = DistParam.GetMu(AId);
742  	TMAGAffMtx SqTheta(Theta);
743  	for(int i = 0; i < Theta.Len(); i++) {
744  		SqTheta.At(i) = SqTheta.At(i) * SqTheta.At(i);
745  	}
746  	TFltV ProdV;	ProdVV.GetRow(NId, ProdV);
747  	ProdV[0] -= GetAvgThetaLL(NId, NId, AId, true, false);
748  	ProdV[1] -= GetAvgThetaLL(NId, NId, AId, false, true);
749  	ProdV[2] -= log(2.0) + GetAvgSqThetaLL(NId, NId, AId, true, false);
750  	ProdV[3] -= log(2.0) + GetAvgSqThetaLL(NId, NId, AId, false, true);
751  	double EdgeQ[2], MaxExp[2];
752  	TFltV NonEdgeLLV[2];
753  	TFltVV CntVV(4, NAttrs);		CntVV.PutAll(0.0);
754  	for(int i = 0; i < 2; i++) {
755  		EdgeQ[i] = 0.0;
756  		MaxExp[i] = -DBL_MAX;
757  		NonEdgeLLV[i].Gen(4 * NNodes, 0);
758  	}
759  	for(int F = 0; F < 2; F++) {
760  		NonEdgeLLV[F].Add(ProdV[0] + log(GetAvgOutCoeff(NId, AId, F, Theta)));
761  		NonEdgeLLV[F].Add(ProdV[1] + log(GetAvgInCoeff(NId, AId, F, Theta)));
762  		NonEdgeLLV[F].Add(ProdV[2] + log(GetAvgOutCoeff(NId, AId, F, SqTheta)));
763  		NonEdgeLLV[F].Add(ProdV[3] + log(GetAvgInCoeff(NId, AId, F, SqTheta)));
764  	}
765  	EdgeQ[0] = -(NNodes - 1) * exp(LogSumExp(NonEdgeLLV[0]));
766  	EdgeQ[1] = -(NNodes - 1) * exp(LogSumExp(NonEdgeLLV[1]));
767  	for(int l = 0; l < NAttrs; l++) {
768  		if(l == AId) {  continue;  }
769  		int BgId = (AId > l) ? AId : l;
770  		int SmId = (AId + l) - BgId;
771  		int SmL = (l < AId) ? 1 : 0;
772  		BgId *= 4;
773  		CntVV(0, l) = AvgPhiPairVV(SmId, BgId) - PhiVV(NId, AId) * PhiVV(NId, l);
774  		CntVV(1+SmL, l) = AvgPhiPairVV(SmId, BgId+1+SmL) - PhiVV(NId, AId) * (1.0-PhiVV(NId, l));
775  		CntVV(2-SmL, l) = AvgPhiPairVV(SmId, BgId+2-SmL) - (1.0-PhiVV(NId, AId)) * PhiVV(NId, l);
776  		CntVV(3, l) = AvgPhiPairVV(SmId, BgId+3) - (1.0-PhiVV(NId, AId)) * (1.0-PhiVV(NId, l));
777  	}
778  	TNGraph::TNodeI NI = Graph->GetNI(NId);
779  	for(int d = 0; d < NI.GetOutDeg(); d++) {
780  		int Out = NI.GetOutNId(d);
781  		if(NId == Out) {  continue;  }
782  		double LinW = GetProdLinWeight(NId, Out) - GetThetaLL(NId, Out, AId);
783  		double SqW = GetProdSqWeight(NId, Out) - GetSqThetaLL(NId, Out, AId);
784  		for(int F = 0; F < 2; F++) {
785  			EdgeQ[F] += GetOutCoeff(NId, Out, AId, F, LLTheta);
786  			EdgeQ[F] += exp(LinW + log(GetOutCoeff(NId, Out, AId, F, Theta)));
787  			EdgeQ[F] += 0.5 * exp(SqW + log(GetOutCoeff(NId, Out, AId, F, SqTheta)));
788  		}
789  	}
790  	for(int d = 0; d < NI.GetInDeg(); d++) {
791  		int In = NI.GetInNId(d);
792  		if(NId == In) {  continue;  }
793  		double LinW = GetProdLinWeight(In, NId) - GetThetaLL(In, NId, AId);
794  		double SqW = GetProdSqWeight(In, NId) - GetSqThetaLL(In, NId, AId);
795  		for(int F = 0; F < 2; F++) {
796  			EdgeQ[F] += GetInCoeff(In, NId, AId, F, LLTheta);
797  			EdgeQ[F] += exp(LinW + log(GetInCoeff(In, NId, AId, F, Theta)));
798  			EdgeQ[F] += 0.5 * exp(SqW + log(GetInCoeff(In, NId, AId, F, SqTheta)));
799  		}
800  	}
801  	EdgeQ[0] += log(Mu);
802  	EdgeQ[1] += log(1.0 - Mu);
803  	double DeltaQ = EdgeQ[0] - EdgeQ[1];
804  	double x[] = {PhiVV(NId, AId)};
805  	TFltV ObjValV;	ObjValV.Gen(60, 0);
806  	for(int n = 0; n < 1; n++) {
807  		double LrnRate = 0.001;
808  		for(int step = 0; step < 50; step++) {
809  			double Grad = GradPhiMI(x[n], NId, AId, Lambda, DeltaQ, CntVV);
810  			if(Grad > 0.0) {  x[n] += LrnRate;  }
811  			else {  x[n] -= LrnRate;  }
812  			if(x[n] > 0.9999) {  x[n] = 0.9999;  }
813  			if(x[n] < 0.0001) {  x[n] = 0.0001;  }
814  			if(x[n] == 0.9999 || x[n] == 0.0001) {
815  				break;
816  			}
817  			LrnRate *= 0.995;
818  		}
819  		ObjValV.Add(x[n]);
820  	}
821  	double MaxVal = -DBL_MAX;
822  	int MaxX = -1;
823  	for(int n = 0; n < ObjValV.Len(); n++) {
824  		double Val = ObjPhiMI(ObjValV[n], NId, AId, Lambda, EdgeQ[0], EdgeQ[1], CntVV);
825  		if(Val > MaxVal) {
826  			MaxVal = Val;
827  			MaxX = n;
828  		} else if(MaxX < 0) {
829  			printf("(%d, %d) : %f  Q[0] = %f  Q[1] = %f  Val = %f\n", NId, AId, double(x[n]), double(EdgeQ[0]), double(EdgeQ[1]), Val);
830  		}
831  	}
832  	IAssert(MaxX >= 0);
833  	Phi = ObjValV[MaxX];
834  	return Phi - PhiVV.At(NId, AId);
835  }
836  double TMAGFitBern::DoEStepOneIter(const TFltV& TrueMuV, TFltVV& NewPhiVV, const double& Lambda) {
837  	const int NNodes = Param.GetNodes();
838  	const int NAttrs = Param.GetAttrs();
839  	double MaxDelta = 0, L1 = 0;
840  	double Val;
841  	TFltIntIntTrV NewVal;
842  	int RndCount = 0;
843  	TFltV MuV(NAttrs);	MuV.PutAll(0.0);
844  	TIntV NIndV(NNodes), AIndV(NAttrs);
845  	NewVal.Gen(NAttrs * 2);
846  	for(int i = 0; i < NNodes; i++) {
847  		for(int l = 0; l < NAttrs * 2; l++) {
848  			const int NId = TMAGNodeBern::Rnd.GetUniDevInt(NNodes);
849  			const int AId = TMAGNodeBern::Rnd.GetUniDevInt(NAttrs);
850  			double Delta = 0.0;
851  			if(KnownVV(NId, AId)) {
852  				Val = PhiVV.At(NId, AId);
853  			} else {
854  				Delta = UpdatePhiMI(Lambda, NId, AId, Val);
855  			}
856  			NewVal[l] = TFltIntIntTr(Val, NId, AId);
857  			if(fabs(Delta) > MaxDelta) {
858  				MaxDelta = fabs(Delta);
859  			}
860  			if(Val > 0.3 && Val < 0.7) {	RndCount++;	}
861  		}
862  		for(int l = 0; l < NAttrs * 2; l++) {
863  			const int NId = NewVal[l].Val2;
864  			const int AId = NewVal[l].Val3;
865  			PhiVV.At(NId, AId) = NewVal[l].Val1;
866  		}
867  	}
868  	for(int i = 0; i < NNodes; i++) {
869  		for(int l = 0; l < NAttrs; l++) {
870  			MuV[l] = MuV[l] + PhiVV.At(i, l);
871  		}
872  	}
873  	for(int l = 0; l < NAttrs; l++) {
874  		MuV[l] = MuV[l] / double(NNodes);
875  	}
876  	TFltV SortMuV = MuV;
877  	double Avg = 0.0;
878  	SortMuV.Sort(false);
879  	for(int l = 0; l < NAttrs; l++) {
880  		printf("  F[%d] = %.3f", l, double(MuV[l]));
881  		Avg += SortMuV[l];
882  		L1 += fabs(TrueMuV[l] - SortMuV[l]);
883  	}
884  	printf("\n");
885  	printf("  Rnd = %d(%.3f)", RndCount, double(RndCount) / double(NNodes * NAttrs));
886  	printf("  Avg = %.3f\n", Avg / double(NAttrs));
887  	L1 /= double(NAttrs);
888  	return L1;
889  }
890  double TMAGFitBern::DoEStepApxOneIter(const TFltV& TrueMuV, TFltVV& NewPhiVV, const double& Lambda) {
891  	const int NNodes = Param.GetNodes();
892  	const int NAttrs = Param.GetAttrs();
893  	double MaxDelta = 0, L1 = 0;
894  	double Val;
895  	TFltIntIntTrV NewVal;
896  	int RndCount = 0;
897  	TFltV MuV(NAttrs);	MuV.PutAll(0.0);
898  	TFltVV ProdVV(NNodes, 4);	ProdVV.PutAll(0.0);
899  	TIntV NIndV(NNodes), AIndV(NAttrs);
900  	AvgPhiV.Gen(NAttrs);	AvgPhiV.PutAll(0.0);
901  	AvgPhiPairVV.Gen(NAttrs, 4*NAttrs);		AvgPhiPairVV.PutAll(0.0);
902  	for(int i = 0; i < NNodes; i++) {
903  		for(int l = 0; l < NAttrs; l++) {
904  			for(int p = l+1; p < NAttrs; p++) {
905  				int index = 4 * p;
906  				AvgPhiPairVV(l, index) += PhiVV(i, l) * PhiVV(i, p);
907  				AvgPhiPairVV(l, index+1) += PhiVV(i, l) * (1.0-PhiVV(i, p));
908  				AvgPhiPairVV(l, index+2) += (1.0-PhiVV(i, l)) * PhiVV(i, p);
909  				AvgPhiPairVV(l, index+3) += (1.0-PhiVV(i, l)) * (1.0-PhiVV(i, p));
910  			}
911  			AvgPhiV[l] += PhiVV(i, l);
912  		}
913  	}
914  	for(int i = 0; i < NNodes; i++) {
915  		ProdVV(i, 0) = GetAvgProdLinWeight(i, i, true, false);
916  		ProdVV(i, 1) = GetAvgProdLinWeight(i, i, false, true);
917  		ProdVV(i, 2) = GetAvgProdSqWeight(i, i, true, false);
918  		ProdVV(i, 3) = GetAvgProdSqWeight(i, i, false, true);
919  	}
920  	const int Iter = 3;
921  	NewVal.Gen(NAttrs * Iter);
922  	for(int i = 0; i < NNodes * Iter; i++) {
923  		for(int l = 0; l < NAttrs; l++) {
924  			const int NId = TMAGNodeBern::Rnd.GetUniDevInt(NNodes);
925  			const int AId = TMAGNodeBern::Rnd.GetUniDevInt(NAttrs);
926  			double Delta = 0.0;
927  			if(KnownVV(NId, AId)) {
928  				Val = PhiVV.At(NId, AId);
929  			} else {
930  				Delta = UpdateApxPhiMI(Lambda, NId, AId, Val, ProdVV);
931  			}
932  			NewVal[l] = TFltIntIntTr(Val, NId, AId);
933  			if(fabs(Delta) > MaxDelta) {
934  				MaxDelta = fabs(Delta);
935  			}
936  			if(Val > 0.3 && Val < 0.7) {	RndCount++;	}
937  		}
938  		for(int l = 0; l < NAttrs; l++) {
939  			const int NId = NewVal[l].Val2;
940  			const int AId = NewVal[l].Val3;
941  			ProdVV(NId, 0) -= GetAvgThetaLL(NId, NId, AId, true, false);
942  			ProdVV(NId, 1) -= GetAvgThetaLL(NId, NId, AId, false, true);
943  			ProdVV(NId, 2) -= GetAvgSqThetaLL(NId, NId, AId, true, false);
944  			ProdVV(NId, 3) -= GetAvgSqThetaLL(NId, NId, AId, false, true);
945  			for(int p = 0; p < NAttrs; p++) {
946  				if(p > AId) {
947  					int index = 4 * p;
948  					AvgPhiPairVV(AId, index) -= PhiVV(NId, AId) * PhiVV(NId, p);
949  					AvgPhiPairVV(AId, index+1) -= PhiVV(NId, AId) * (1.0-PhiVV(NId, p));
950  					AvgPhiPairVV(AId, index+2) -= (1.0-PhiVV(NId, AId)) * PhiVV(NId, p);
951  					AvgPhiPairVV(AId, index+3) -= (1.0-PhiVV(NId, AId)) * (1.0-PhiVV(NId, p));
952  				} else if (p < AId) {
953  					int index = 4 * AId;
954  					AvgPhiPairVV(p, index) -= PhiVV(NId, p) * PhiVV(NId, AId);
955  					AvgPhiPairVV(p, index+1) -= PhiVV(NId, p) * (1.0-PhiVV(NId, AId));
956  					AvgPhiPairVV(p, index+2) -= (1.0-PhiVV(NId, p)) * PhiVV(NId, AId);
957  					AvgPhiPairVV(p, index+3) -= (1.0-PhiVV(NId, p)) * (1.0-PhiVV(NId, AId));
958  				}
959  			}
960  			AvgPhiV[AId] -= PhiVV(NId, AId);
961  			PhiVV.At(NId, AId) = NewVal[l].Val1;
962  			ProdVV(NId, 0) += GetAvgThetaLL(NId, NId, AId, true, false);
963  			ProdVV(NId, 1) += GetAvgThetaLL(NId, NId, AId, false, true);
964  			ProdVV(NId, 2) += GetAvgSqThetaLL(NId, NId, AId, true, false);
965  			ProdVV(NId, 3) += GetAvgSqThetaLL(NId, NId, AId, false, true);
966  			for(int p = 0; p < NAttrs; p++) {
967  				if(p > AId) {
968  					int index = 4 * p;
969  					AvgPhiPairVV(AId, index) += PhiVV(NId, AId) * PhiVV(NId, p);
970  					AvgPhiPairVV(AId, index+1) += PhiVV(NId, AId) * (1.0-PhiVV(NId, p));
971  					AvgPhiPairVV(AId, index+2) += (1.0-PhiVV(NId, AId)) * PhiVV(NId, p);
972  					AvgPhiPairVV(AId, index+3) += (1.0-PhiVV(NId, AId)) * (1.0-PhiVV(NId, p));
973  				} else if (p < AId) {
974  					int index = 4 * AId;
975  					AvgPhiPairVV(p, index) += PhiVV(NId, p) * PhiVV(NId, AId);
976  					AvgPhiPairVV(p, index+1) += PhiVV(NId, p) * (1.0-PhiVV(NId, AId));
977  					AvgPhiPairVV(p, index+2) += (1.0-PhiVV(NId, p)) * PhiVV(NId, AId);
978  					AvgPhiPairVV(p, index+3) += (1.0-PhiVV(NId, p)) * (1.0-PhiVV(NId, AId));
979  				}
980  			}
981  			AvgPhiV[AId] += PhiVV(NId, AId);
982  		}
983  	}
984  	for(int l = 0; l < NAttrs; l++) {
985  		MuV[l] = AvgPhiV[l] / double(NNodes);
986  	}
987  	TFltV SortMuV = MuV;
988  	double Avg = 0.0;
989  	for(int l = 0; l < NAttrs; l++) {
990  		printf("  F[%d] = %.3f", l, double(MuV[l]));
991  		Avg += SortMuV[l];
992  	}
993  	printf("\n");
994  	printf("  Rnd = %d(%.3f)", RndCount, double(RndCount) / double(NNodes * NAttrs));
995  	printf("  Avg = %.3f\n", Avg / double(NAttrs));
996  	return L1;
997  }
998  double TMAGFitBern::DoEStep(const TFltV& TrueMuV, const int& NIter, double& LL, const double& Lambda) {
999  	const int NNodes = Param.GetNodes();
1000  	const int NAttrs = Param.GetAttrs();
1001  	TFltVV NewPhiVV(NNodes, NAttrs);
1002  	TFltV Delta(NIter);
1003  	for(int i = 0; i < NIter; i++) {
1004  		TExeTm IterTm;
1005  		printf("EStep iteration : %d\n", (i+1));
1006  		if(ESpeedUp) {
1007  			Delta[i] = DoEStepApxOneIter(TrueMuV, NewPhiVV, Lambda);
1008  		} else {
1009  			Delta[i] = DoEStepOneIter(TrueMuV, NewPhiVV, Lambda);
1010  		}
1011  		printf("  (Time = %s)\n", IterTm.GetTmStr());
1012  	}
1013  	printf("\n");
1014  	NewPhiVV.Clr();
1015  	return Delta.Last();
1016  }
1017  const double TMAGFitBern::UpdateMu(const int& AId) {
1018  	const int NNodes = Param.GetNodes();
1019  	TMAGNodeBern DistParam = Param.GetNodeAttr();
1020  	const double OldMu = DistParam.GetMu(AId);
1021  	double NewMu = 0.0;
1022  	for(int i = 0; i < NNodes; i++) {
1023  		NewMu += PhiVV.At(i, AId);
1024  	}
1025  	AvgPhiV[AId] = NewMu;
1026  	NewMu /= double(NNodes);
1027  	printf("      [Posterior Mu] = %.4f\n", NewMu);
1028  	double Delta = fabs(NewMu - OldMu);
1029  	DistParam.SetMu(AId, NewMu);
1030  	Param.SetNodeAttr(DistParam);
1031  	return Delta;
1032  }
1033  const void TMAGFitBern::GradAffMtx(const int& AId, const TFltVV& ProdVV, const TFltVV& SqVV, const TMAGAffMtx& CurMtx, TFltV& GradV) {
1034  	const int NNodes = Param.GetNodes();
1035  	GradV.PutAll(0.0);
1036  	for(int i = 0; i < NNodes; i++) {
1037  		for(int j = 0; j < NNodes; j++) {
1038  			double Prod = ProdVV(i, j) - GetThetaLL(i, j, AId);
1039  			double Sq = SqVV(i, j) - GetSqThetaLL(i, j, AId);
1040  			for(int p = 0; p < 4; p++) {
1041  				int Ai = p / 2;
1042  				int Aj = p % 2;
1043  				double Prob = GetProbPhi(i, j, AId, Ai, Aj);
1044  				if(Graph->IsEdge(i, j)) {
1045  					GradV[p] += Prob / CurMtx.At(p);
1046  				} else {
1047  					GradV[p] -= Prob * exp(Prod);
1048  					GradV[p] -= Prob * exp(Sq) * CurMtx.At(p);
1049  				}
1050  			}
1051  		}
1052  	}
1053  }
1054  const void TMAGFitBern::GradApxAffMtx(const int& AId, const TFltVV& ProdVV, const TFltVV& SqVV, const TMAGAffMtx& CurMtx, TFltV& GradV) {
1055  	const int NNodes = Param.GetNodes();
1056  	GradV.PutAll(0.0);
1057  	TFltV LogSumV;
1058  	for(int p = 0; p < 4; p++) {
1059  		int Ai = p / 2;
1060  		int Aj = p % 2;
1061  		LogSumV.Gen(NNodes * 4, 0);
1062  		for(int i = 0; i < NNodes; i++) {
1063  			const double LProd = ProdVV(i, 0) - GetAvgThetaLL(i, i, AId, true, false);
1064  			const double LSq = SqVV(i, 0) - GetAvgSqThetaLL(i, i, AId, true, false);
1065  			const double RProd = ProdVV(i, 1) - GetAvgThetaLL(i, i, AId, false, true);
1066  			const double RSq = SqVV(i, 1) - GetAvgSqThetaLL(i, i, AId, false, true);
1067  			LogSumV.Add(LProd + log(GetProbMu(i, i, AId, Ai, Aj, true, false)));
1068  			LogSumV.Add(LSq + log(GetProbMu(i, i, AId, Ai, Aj, true, false)) + log(CurMtx.At(p)));
1069  			LogSumV.Add(RProd + log(GetProbMu(i, i, AId, Ai, Aj, false, true)));
1070  			LogSumV.Add(RSq + log(GetProbMu(i, i, AId, Ai, Aj, false, true)) + log(CurMtx.At(p)));
1071  		}
1072  		double LogSum = LogSumExp(LogSumV);
1073  		GradV[p] -= (NNodes - 1) * 0.5 * exp(LogSum);
1074  	}
1075  	for(TNGraph::TEdgeI EI = Graph->BegEI(); EI < Graph->EndEI(); EI++) {
1076  		const int NId1 = EI.GetSrcNId();
1077  		const int NId2 = EI.GetDstNId();
1078  		const double ProdOne = GetProdLinWeight(NId1, NId2) - GetThetaLL(NId1, NId2, AId);
1079  		const double SqOne = GetProdSqWeight(NId1, NId2) - GetSqThetaLL(NId1, NId2, AId);
1080  		for(int p = 0; p < 4; p++) {
1081  			int Ai = p / 2;
1082  			int Aj = p % 2;
1083  			double Prob = GetProbPhi(NId1, NId2, AId, Ai, Aj);
1084  			GradV[p] += Prob / CurMtx.At(p);
1085  			GradV[p] += Prob * exp(ProdOne);
1086  			GradV[p] += Prob * exp(SqOne) * CurMtx.At(p);
1087  		}
1088  	}
1089  #if 0
1090  	const double Prod = ProdVV(0, 0) - GetAvgThetaLL(0, 0, AId, false, false);
1091  	const double Sq = SqVV(0, 0) - GetAvgSqThetaLL(0, 0, AId, false, false);
1092  	for(int p = 0; p < 4; p++) {
1093  		int Ai = p / 2;
1094  		int Aj = p % 2;
1095  		GradV[p] -= NSq * exp(Prod) * GetProbMu(0, 0, AId, Ai, Aj, false, false);
1096  		GradV[p] -= NSq * exp(Sq) * GetProbMu(0, 0, AId, Ai, Aj, false, false) * CurMtx.At(p);
1097  	}
1098  	for(TNGraph::TEdgeI EI = Graph->BegEI(); EI < Graph->EndEI(); EI++) {
1099  		const int NId1 = EI.GetSrcNId();
1100  		const int NId2 = EI.GetDstNId();
1101  		const double ProdOne = GetProdLinWeight(NId1, NId2) - GetThetaLL(NId1, NId2, AId);
1102  		const double SqOne = GetProdSqWeight(NId1, NId2) - GetSqThetaLL(NId1, NId2, AId);
1103  		for(int p = 0; p < 4; p++) {
1104  			int Ai = p / 2;
1105  			int Aj = p % 2;
1106  			double Prob = GetProbPhi(NId1, NId2, AId, Ai, Aj);
1107  		}
1108  	}
1109  #endif
1110  }
1111  const double TMAGFitBern::UpdateAffMtx(const int& AId, const double& LrnRate, const double& MaxGrad, const double& Lambda, TFltVV& ProdVV, TFltVV& SqVV, TMAGAffMtx& NewMtx) {
1112  	double Delta = 0.0;
1113  	TMAGAffMtx AffMtx = Param.GetMtx(AId);
1114  	TFltV GradV(4);
1115  	TFltV HessV(4);
1116  	if(MSpeedUp) {
1117  		GradApxAffMtx(AId, ProdVV, SqVV, NewMtx, GradV);
1118  	} else {
1119  		GradAffMtx(AId, ProdVV, SqVV, NewMtx, GradV);
1120  	}
1121  	double Ratio = 1.0;
1122  	for(int p = 0; p < 4; p++) {
1123  		if(fabs(Ratio * LrnRate * GradV[p]) > MaxGrad) {
1124  			Ratio = MaxGrad / fabs(LrnRate * GradV[p]);
1125  		}
1126  	}
1127  	for(int p = 0; p < 4; p++) {
1128  		GradV[p] *= (Ratio * LrnRate);
1129  		NewMtx.At(p) = AffMtx.At(p) + GradV[p];
1130  		if(NewMtx.At(p) < 0.0001) {  NewMtx.At(p) = 0.0001;  }
1131  	}
1132  	printf("      [Attr = %d]\n", AId);
1133      printf("        %s  + [%f, %f; %f %f]  ----->  %s\n", (AffMtx.GetMtxStr()).GetCStr(), double(GradV[0]), double(GradV[1]), double(GradV[2]), double(GradV[3]), (NewMtx.GetMtxStr()).GetCStr());
1134  	return Delta;
1135  }
1136  void TMAGFitBern::NormalizeAffMtxV(TMAGAffMtxV& MtxV, const bool UseMu) {
1137  	const int NNodes = Param.GetNodes();
1138  	const int NAttrs = MtxV.Len();
1139  	TFltV MuV = GetMuV();
1140  	double Product = 1.0, ExpEdge = NNodes * (NNodes - 1);
1141  	TFltV SumV(NAttrs), EdgeSumV(NAttrs);
1142  	SumV.PutAll(0.0);	EdgeSumV.PutAll(0.0);
1143  	for(int l = 0; l < NAttrs; l++) {
1144  		double Mu = (UseMu) ? double(MuV[l]) : (AvgPhiV[l] / double(NNodes));
1145  		EdgeSumV[l] += Mu * Mu * MtxV[l].At(0, 0);
1146  		EdgeSumV[l] += Mu * (1.0-Mu) * MtxV[l].At(0, 1);
1147  		EdgeSumV[l] += Mu * (1.0-Mu) * MtxV[l].At(1, 0);
1148  		EdgeSumV[l] += (1.0-Mu) * (1.0-Mu) * MtxV[l].At(1, 1);
1149  		SumV[l] = SumV[l] + MtxV[l].At(0, 0);
1150  		SumV[l] = SumV[l] + MtxV[l].At(0, 1);
1151  		SumV[l] = SumV[l] + MtxV[l].At(1, 0);
1152  		SumV[l] = SumV[l] + MtxV[l].At(1, 1);
1153  		Product *= SumV[l];
1154  		ExpEdge *= EdgeSumV[l];
1155  	}
1156  	ExpEdge = Graph->GetEdges() / ExpEdge;
1157  	NormConst *= Product;
1158  	Product = 1.0;
1159  	for(int l = 0; l < NAttrs; l++) {
1160  		for(int p = 0; p < 4; p++) {
1161  			MtxV[l].At(p) = MtxV[l].At(p) * Product / SumV[l];
1162  		}
1163  	}
1164  }
1165  void TMAGFitBern::UnNormalizeAffMtxV(TMAGAffMtxV& MtxV, const bool UseMu) {
1166  	const int NNodes = Param.GetNodes();
1167  	const int NAttrs = MtxV.Len();
1168  	TFltIntPrV MaxEntV(NAttrs);
1169  	TFltV MuV = GetMuV();
1170  	NormalizeAffMtxV(MtxV, UseMu);
1171  	double ExpEdge = NNodes * (NNodes - 1);
1172  	for(int l = 0; l < NAttrs; l++) {
1173  		double Mu = MuV[l];
1174  		double EdgeSum = Mu * Mu * MtxV[l].At(0, 0);
1175  		EdgeSum += Mu * (1.0-Mu) * MtxV[l].At(0, 1);
1176  		EdgeSum += Mu * (1.0-Mu) * MtxV[l].At(1, 0);
1177  		EdgeSum += (1.0-Mu) * (1.0-Mu) * MtxV[l].At(1, 1);
1178  		ExpEdge *= EdgeSum;
1179  	}
1180  	NormConst = double(Graph->GetEdges()) / ExpEdge;
1181  	for(int l = 0; l < NAttrs; l++) {
1182  		MaxEntV[l] = TFltIntPr(-1, l);
1183  		for(int p = 0; p < 4; p++) {
1184  			if(MaxEntV[l].Val1 < MtxV[l].At(p)) {  MaxEntV[l].Val1 = MtxV[l].At(p);  }
1185  		}
1186  	}
1187  	MaxEntV.Sort(false);
1188  	for(int l = 0; l < NAttrs; l++) {
1189  		int CurId = MaxEntV[l].Val2;
1190  		double Factor = pow(NormConst, 1.0 / double(NAttrs - l));
1191  		double MaxFactor = 0.9999 / MaxEntV[l].Val1;
1192  		Factor = (Factor > MaxFactor) ? MaxFactor : Factor;
1193  		NormConst = NormConst / Factor;
1194  		for(int p = 0; p < 4; p++) {
1195  			MtxV[CurId].At(p) = MtxV[CurId].At(p) * Factor;
1196  		}
1197  	}
1198  }
1199  const void TMAGFitBern::PrepareUpdateAffMtx(TFltVV& ProdVV, TFltVV& SqVV) {
1200  	const int NNodes = Param.GetNodes();
1201  	ProdVV.Gen(NNodes, NNodes);
1202  	SqVV.Gen(NNodes, NNodes);
1203  	for(int i = 0; i < NNodes; i++) {
1204  		for(int j = 0; j < NNodes; j++) {
1205  			ProdVV(i, j) = GetProdLinWeight(i, j);
1206  			SqVV(i, j) = GetProdSqWeight(i, j);
1207  		}
1208  	}
1209  }
1210  const void TMAGFitBern::PrepareUpdateApxAffMtx(TFltVV& ProdVV, TFltVV& SqVV) {
1211  	const int NNodes = Param.GetNodes();
1212  	ProdVV.Gen(NNodes, 2);
1213  	SqVV.Gen(NNodes, 2);
1214  	for(int i = 0; i < NNodes; i++) {
1215  		ProdVV(i, 0) = GetAvgProdLinWeight(i, i, true, false);
1216  		ProdVV(i, 1) = GetAvgProdLinWeight(i, i, false, true);
1217  		SqVV(i, 0) = GetAvgProdSqWeight(i, i, true, false);
1218  		SqVV(i, 1) = GetAvgProdSqWeight(i, i, false, true);
1219  	}
1220  }
1221  const double TMAGFitBern::UpdateAffMtxV(const int& GradIter, const double& LrnRate, const double& MaxGrad, const double& Lambda, const int& NReal) {
1222  	const int NNodes = Param.GetNodes();
1223  	const int NAttrs = Param.GetAttrs();
1224  	const TMAGNodeBern DistParam = Param.GetNodeAttr();
1225  	const TFltV MuV = DistParam.GetMuV();
1226  	double Delta = 0.0;
1227  	double DecLrnRate = LrnRate, DecMaxGrad = MaxGrad;
1228  	TFltVV ProdVV(NNodes, NNodes), SqVV(NNodes, NNodes);
1229  	TMAGAffMtxV NewMtxV, OldMtxV;
1230  	Param.GetMtxV(OldMtxV);
1231  	Param.GetMtxV(NewMtxV);
1232  	for(int g = 0; g < GradIter; g++) {
1233  		if(MSpeedUp) {
1234  			PrepareUpdateApxAffMtx(ProdVV, SqVV);
1235  		} else {
1236  			PrepareUpdateAffMtx(ProdVV, SqVV);
1237  		}
1238  		printf("    [Grad step = %d]\n", (g+1));
1239  		for(int l = NReal; l < NAttrs; l++) {
1240  			UpdateAffMtx(l, DecLrnRate, DecMaxGrad, Lambda, ProdVV, SqVV, NewMtxV[l]);
1241  			Param.SetMtxV(NewMtxV);
1242  		}
1243  		DecLrnRate *= 0.97;
1244  		DecMaxGrad *= 0.97;
1245  		printf("\n");
1246  		NormalizeAffMtxV(NewMtxV, true);
1247  		Param.SetMtxV(NewMtxV);
1248  	}
1249  	NormalizeAffMtxV(NewMtxV, true);
1250  	printf( "\nFinal\n");
1251  	for(int l = 0; l < NAttrs; l++) {
1252  		printf("    [");
1253  		for(int p = 0; p < 4; p++) {
1254  			Delta += fabs(OldMtxV[l].At(p) - NewMtxV[l].At(p));
1255  			printf(" %.4f ", double(NewMtxV[l].At(p)));
1256  		}
1257  		printf("]\n");
1258  	}
1259  	Param.SetMtxV(NewMtxV);
1260  	ProdVV.Clr();		SqVV.Clr();
1261  	return Delta;
1262  }
1263  void TMAGFitBern::DoMStep(const int& GradIter, const double& LrnRate, const double& MaxGrad, const double& Lambda, const int& NReal) {
1264  	const int NAttrs = Param.GetAttrs();
1265  	double MuDelta = 0.0, AffMtxDelta = 0.0;
1266  	TExeTm ExeTm;
1267  	printf("\n");
1268  	AvgPhiV.Gen(NAttrs);	AvgPhiV.PutAll(0.0);
1269  	for(int l = 0; l < NAttrs; l++) {
1270  		MuDelta += UpdateMu(l);
1271  	}
1272  	printf("\n");
1273  	printf("  == Update Theta\n");
1274  	AffMtxDelta += UpdateAffMtxV(GradIter, LrnRate, MaxGrad, Lambda, NReal);
1275  	printf("\n");
1276  	printf("Elpased time = %s\n", ExeTm.GetTmStr());
1277  	printf("\n");
1278  }
1279  void TMAGFitBern::DoEMAlg(const int& NStep, const int& NEstep, const int& NMstep, const double& LrnRate, const double& MaxGrad, const double& Lambda, const double& ReInit, const int& NReal) {
1280  	const int NNodes = Param.GetNodes();
1281  	const int NAttrs = Param.GetAttrs();
1282  	TIntV IndexV;
1283  	double LL;
1284  	MuHisV.Gen(NStep + 1, 0);
1285  	MtxHisV.Gen(NStep + 1, 0);
1286  	LLHisV.Gen(NStep + 1, 0);
1287  	printf("--------------------------------------------\n");
1288  	printf("Before EM Iteration\n");
1289  	printf("--------------------------------------------\n");
1290  	TMAGAffMtxV InitMtxV;
1291  	TMAGNodeBern NodeAttr = Param.GetNodeAttr();
1292  	Param.GetMtxV(InitMtxV);
1293  	TFltV InitMuV = NodeAttr.GetMuV();
1294  	for(int i = 0; i < NNodes; i++) {
1295  		for(int l = 0; l < NAttrs; l++) {
1296  			if(! KnownVV(i, l)) {
1297  				PhiVV.At(i, l) = TMAGNodeBern::Rnd.GetUniDev();
1298  			}
1299  		}
1300  	}
1301  	if(Debug) {
1302  		double LL = ComputeApxLL();
1303  		MuHisV.Add(InitMuV);
1304  		MtxHisV.Add(InitMtxV);
1305  		LLHisV.Add(LL);
1306  	}
1307  	NormalizeAffMtxV(InitMtxV, true);
1308  	Param.SetMtxV(InitMtxV);
1309  	for(int n = 0; n < NStep; n++) {
1310  		printf("--------------------------------------------\n");
1311  		printf("EM Iteration : %d\n", (n+1));
1312  		printf("--------------------------------------------\n");
1313  		NodeAttr = Param.GetNodeAttr();
1314  		for(int i = 0; i < NNodes; i++) {
1315  			for(int l = 0; l < NAttrs; l++) {
1316  				if(!KnownVV(i, l) && TMAGNodeBern::Rnd.GetUniDev() < ReInit) {
1317  					PhiVV.At(i, l) = TMAGNodeBern::Rnd.GetUniDev();
1318  				}
1319  			}
1320  		}
1321  		DoEStep(InitMuV, NEstep, LL, Lambda);
1322  		Param.GetMtxV(InitMtxV);
1323  		Param.SetMtxV(InitMtxV);
1324  		DoMStep(NMstep, LrnRate, MaxGrad, Lambda, NReal);
1325  		printf("\n");
1326  		if(Debug) {
1327  			double LL = ComputeApxLL();
1328  			MuHisV.Add(InitMuV);
1329  			MtxHisV.Add(InitMtxV);
1330  			LLHisV.Add(LL);
1331  			printf("    ApxLL = %.2f (Const = %f)\n", LL, double(NormConst));
1332  		}
1333  	}
1334  	Param.GetMtxV(InitMtxV);
1335  	UnNormalizeAffMtxV(InitMtxV, true);
1336  	Param.SetMtxV(InitMtxV);
1337  }
1338  void TMAGFitBern::MakeCCDF(const TFltPrV& RawV, TFltPrV& CcdfV) {
1339  	double Total = 0.0;
1340  	CcdfV.Gen(RawV.Len(), 0);
1341  	for(int i = 0; i < RawV.Len(); i++) {
1342  		if(RawV[i].Val2 <= 0) {  continue;  }
1343  		Total += RawV[i].Val2;
1344  		CcdfV.Add(RawV[i]);
1345  		IAssert(RawV[i].Val2 > 0);
1346  	}
1347  	for(int i = 1; i < CcdfV.Len(); i++) {
1348  		CcdfV[i].Val2 += CcdfV[i-1].Val2;
1349  	}
1350  	for(int i = CcdfV.Len() - 1; i > 0; i--) {
1351  		CcdfV[i].Val2 = (Total - CcdfV[i-1].Val2) ;
1352  		if(CcdfV[i].Val2 <= 0) {  printf("CCDF = %f\n", double(CcdfV[i].Val2));}
1353  		IAssert(CcdfV[i].Val2 > 0);
1354  	}
1355  	CcdfV[0].Val2 = Total;
1356  }
1357  void TMAGFitBern::PlotProperties(const TStr& FNm) {
1358  	const int NNodes = Param.GetNodes();
1359  	const int NAttrs = Param.GetAttrs();
1360  	TMAGParam<TMAGNodeBern> MAGGen(NNodes, NAttrs);
1361  	TMAGNodeBern MAGNode = Param.GetNodeAttr();
1362  	MAGGen.SetNodeAttr(MAGNode);
1363  	TMAGAffMtxV MtxV;	Param.GetMtxV(MtxV);
1364  	MAGGen.SetMtxV(MtxV);
1365  	PNGraph TrG = new TNGraph;
1366  	*TrG = *Graph;
1367  	TIntVV AttrVV(NNodes, NAttrs);
1368  	for(int i = 0; i < NNodes; i++) {
1369  		for(int j = 0; j < NAttrs; j++) {
1370  			if(PhiVV(i, j) > TMAGNodeBern::Rnd.GetUniDev())	AttrVV(i, j) = 0;
1371  			else AttrVV(i, j) = 1;
1372  		}
1373  	}
1374  	PNGraph MAG = MAGGen.GenMAG(AttrVV, true, 10000);
1375  	printf("%d edges created for MAG...\n", MAG->GetEdges());
1376  	TSnap::DelZeroDegNodes(TrG);
1377  	TSnap::DelZeroDegNodes(MAG);
1378  	TGStatVec GS(tmuNodes, TFSet() | gsdInDeg | gsdOutDeg | gsdWcc | gsdHops | gsdClustCf | gsdSngVec | gsdSngVal | gsdTriadPart);
1379      TGnuPlot InDegP(FNm + "-InDeg"), OutDegP(FNm + "-OutDeg"), SvalP(FNm + "-Sval"), SvecP(FNm + "-Svec"), WccP(FNm + "-Wcc"), HopP(FNm + "-Hop"), TriadP(FNm + "-Triad"), CcfP(FNm + "-Ccf");;
1380      InDegP.SetXYLabel("Degree", "# of nodes");
1381      OutDegP.SetXYLabel("Degree", "# of nodes");
1382      SvalP.SetXYLabel("Rank", "Singular value");
1383      SvecP.SetXYLabel("Rank", "Primary SngVec component");
1384      WccP.SetXYLabel("Size of component", "# of components");
1385      CcfP.SetXYLabel("Degree", "Clustering coefficient");
1386      HopP.SetXYLabel("Hops", "# of node pairs");
1387      TriadP.SetXYLabel("# of triads", "# of participating nodes");
1388      InDegP.SetScale(gpsLog10XY);    InDegP.AddCmd("set key top right");
1389      OutDegP.SetScale(gpsLog10XY);   OutDegP.AddCmd("set key top right");
1390      SvalP.SetScale(gpsLog10XY);     SvalP.AddCmd("set key top right");
1391      SvecP.SetScale(gpsLog10XY);     SvecP.AddCmd("set key top right");
1392      CcfP.SetScale(gpsLog10XY);      CcfP.AddCmd("set key top right");
1393      HopP.SetScale(gpsLog10XY);      HopP.AddCmd("set key top right");
1394      TriadP.SetScale(gpsLog10XY);    TriadP.AddCmd("set key top right");
1395  	InDegP.ShowGrid(false);
1396  	OutDegP.ShowGrid(false);
1397  	SvalP.ShowGrid(false);
1398  	SvecP.ShowGrid(false);
1399  	CcfP.ShowGrid(false);
1400  	HopP.ShowGrid(false);
1401  	TriadP.ShowGrid(false);
1402  	const TStr Style[2] = {"lt 1 lw 3 lc rgb 'black'", "lt 2 lw 3 lc rgb 'red'"};
1403  	const TStr Name[2] = {"Real", "MAG"};
1404  	GS.Add(Graph, TSecTm(1), "Real Graph");
1405  	GS.Add(MAG, TSecTm(2), "MAG");
1406  	TFltPrV InDegV, OutDegV, SvalV, SvecV, HopV, WccV, CcfV, TriadV;
1407  	for(int i = 0; i < GS.Len(); i++) {
1408  		MakeCCDF(GS.At(i)->GetDistr(gsdInDeg), InDegV);
1409  		MakeCCDF(GS.At(i)->GetDistr(gsdOutDeg), OutDegV);
1410  		SvalV = GS.At(i)->GetDistr(gsdSngVal);
1411  		SvecV = GS.At(i)->GetDistr(gsdSngVec);
1412  		MakeCCDF(GS.At(i)->GetDistr(gsdClustCf), CcfV);
1413  		HopV = GS.At(i)->GetDistr(gsdHops);
1414  		MakeCCDF(GS.At(i)->GetDistr(gsdTriadPart), TriadV);
1415  		InDegP.AddPlot(InDegV, gpwLines, Name[i], Style[i]);
1416  		OutDegP.AddPlot(OutDegV, gpwLines, Name[i], Style[i]);
1417  		SvalP.AddPlot(SvalV, gpwLines, Name[i], Style[i]);
1418  		SvecP.AddPlot(SvecV, gpwLines, Name[i], Style[i]);
1419  		CcfP.AddPlot(CcfV, gpwLines, Name[i], Style[i]);
1420  		HopP.AddPlot(HopV, gpwLines, Name[i], Style[i]);
1421  		TriadP.AddPlot(TriadV, gpwLines, Name[i], Style[i]);
1422  	}
1423  	InDegP.SaveEps(30);
1424  	OutDegP.SaveEps(30);
1425  	SvalP.SaveEps(30);
1426  	SvecP.SaveEps(30);
1427  	CcfP.SaveEps(30);
1428  	HopP.SaveEps(30);
1429  	TriadP.SaveEps(30);
1430  }
1431  void TMAGFitBern::CountAttr(TFltV& EstMuV) const {
1432  	const int NNodes = PhiVV.GetXDim();
1433  	const int NAttrs = PhiVV.GetYDim();
1434  	EstMuV.Gen(NAttrs);
1435  	EstMuV.PutAll(0.0);
1436  	for(int l = 0; l < NAttrs; l++) {
1437  		for(int i = 0; i < NNodes; i++) {
1438  			EstMuV[l] = EstMuV[l] + PhiVV(i, l);
1439  		}
1440  		EstMuV[l] = EstMuV[l] / double(NNodes);
1441  	}
1442  }
1443  void TMAGFitBern::SortAttrOrdering(const TFltV& TrueMuV, TIntV& IndexV) const {
1444  	const int NAttrs = TrueMuV.Len();
1445  	TFltV EstMuV, SortedTrueMuV, SortedEstMuV, TrueIdxV, EstIdxV;
1446  	IndexV.Gen(NAttrs);
1447  	TrueIdxV.Gen(NAttrs);
1448  	EstIdxV.Gen(NAttrs);
1449  	for(int l = 0; l < NAttrs; l++) {
1450  		TrueIdxV[l] = l;
1451  		EstIdxV[l] = l;
1452  	}
1453  	CountAttr(EstMuV);
1454  	SortedTrueMuV = TrueMuV;
1455  	SortedEstMuV = EstMuV;
1456  	for(int i = 0; i < NAttrs; i++) {
1457  		if(SortedTrueMuV[i] > 0.5) {  SortedTrueMuV[i] = 1.0 - SortedTrueMuV[i];  }
1458  		if(SortedEstMuV[i] > 0.5) {  SortedEstMuV[i] = 1.0 - SortedEstMuV[i];  }
1459  	}
1460  	for(int i = 0; i < NAttrs; i++) {
1461  		for(int j = i+1; j < NAttrs; j++) {
1462  			if(SortedTrueMuV[i] < SortedTrueMuV[j]) {
1463  				SortedTrueMuV.Swap(i, j);
1464  				TrueIdxV.Swap(i, j);
1465  			}
1466  			if(SortedEstMuV[i] < SortedEstMuV[j]) {
1467  				EstIdxV.Swap((int)SortedEstMuV[i], (int)SortedEstMuV[j]);
1468  				SortedEstMuV.Swap(i, j);
1469  			}
1470  		}
1471  	}
1472  	for(int l = 0; l < NAttrs; l++) {
1473  		IndexV[l] = (int)TrueIdxV[(int)EstIdxV[l]];
1474  	}
1475  }
1476  const bool TMAGFitBern::NextPermutation(TIntV& IndexV) const {
1477  	const int NAttrs = IndexV.Len();
1478  	int Pos = NAttrs - 1;
1479  	while(Pos > 0) {
1480  		if(IndexV[Pos-1] < IndexV[Pos]) {
1481  			break;
1482  		}
1483  		Pos--;
1484  	}
1485  	if(Pos == 0) {
1486  		return false;
1487  	}
1488  	int Val = NAttrs, NewPos = -1;
1489  	for(int i = Pos; i < NAttrs; i++) {
1490  		if(IndexV[i] > IndexV[Pos - 1] && IndexV[i] < Val) {
1491  			NewPos = i;
1492  			Val = IndexV[i];
1493  		}
1494  	}
1495  	IndexV[NewPos] = IndexV[Pos - 1];
1496  	IndexV[Pos - 1] = Val;
1497  	TIntV SubIndexV;
1498      IndexV.GetSubValV(Pos, NAttrs - 1, SubIndexV);
1499  	SubIndexV.Sort(true);
1500  	for(int i = Pos; i < NAttrs; i++) {
1501  		IndexV[i] = SubIndexV[i - Pos];
1502  	}
1503  	return true;
1504  }
1505  const double TMAGFitBern::ComputeJointOneLL(const TIntVV& AttrVV) const {
1506  	double LL = 0.0;
1507  	const int NNodes = Param.GetNodes();
1508  	const int NAttrs = Param.GetAttrs();
1509  	TMAGAffMtxV MtxV(NAttrs);	Param.GetMtxV(MtxV);
1510  	const TMAGNodeBern NodeAttr = Param.GetNodeAttr();
1511  	const TFltV MuV = NodeAttr.GetMuV();
1512  	for(int l = 0; l < NAttrs; l++) {
1513  		for(int i = 0; i < MtxV[l].Len(); i++) {
1514  			MtxV[l].At(i) = log(MtxV[l].At(i));
1515  		}
1516  	}
1517  	for(int i = 0; i < NNodes; i++) {
1518  		for(int l = 0; l < NAttrs; l++) {
1519  			if(AttrVV.At(i, l) == 0) {
1520  				LL += log(MuV[l]);
1521  			} else {
1522  				LL += log(1.0 - MuV[l]);
1523  			}
1524  		}
1525  		for(int j = 0; j < NNodes; j++) {
1526  			if(i == j) {  continue;  }
1527  			double ProbLL = 0.0;
1528  			for(int l = 0; l < NAttrs; l++) {
1529  				ProbLL += MtxV[l].At(AttrVV.At(i, l), AttrVV.At(j, l));
1530  			}
1531  			if(Graph->IsEdge(i, j)) {
1532  				LL += ProbLL;
1533  			} else {
1534  				LL += log(1-exp(ProbLL));
1535  			}
1536  		}
1537  	}
1538  	return LL;
1539  }
1540  const double TMAGFitBern::ComputeJointAdjLL(const TIntVV& AttrVV) const {
1541  	double LL = 0.0;
1542  	const int NNodes = Param.GetNodes();
1543  	const int NAttrs = Param.GetAttrs();
1544  	TMAGAffMtxV MtxV(NAttrs);	Param.GetMtxV(MtxV);
1545  	const TMAGNodeBern NodeAttr = Param.GetNodeAttr();
1546  	const TFltV MuV = NodeAttr.GetMuV();
1547  	for(int l = 0; l < NAttrs; l++) {
1548  		for(int i = 0; i < MtxV[l].Len(); i++) {
1549  			MtxV[l].At(i) = log(MtxV[l].At(i));
1550  		}
1551  	}
1552  	for(int i = 0; i < NNodes; i++) {
1553  		for(int j = 0; j < NNodes; j++) {
1554  			if(i == j) {  continue;  }
1555  			double ProbLL = 0.0;
1556  			for(int l = 0; l < NAttrs; l++) {
1557  				ProbLL += MtxV[l].At(AttrVV.At(i, l), AttrVV.At(j, l));
1558  			}
1559  			if(Graph->IsEdge(i, j)) {
1560  				LL += ProbLL;
1561  			} else {
1562  				LL += log(1-exp(ProbLL));
1563  			}
1564  		}
1565  	}
1566  	return LL;
1567  }
1568  const double TMAGFitBern::ComputeJointLL(int NSample) const {
1569  	double LL = 0.0;
1570  	const int NNodes = Param.GetNodes();
1571  	const int NAttrs = Param.GetAttrs();
1572  	TRnd Rnd(2000);
1573  	TIntVV AttrVV(NNodes, NAttrs);
1574  	int count = 0;
1575  	for(int s = 0; s < NSample; s++) {
1576  		for(int i = 0; i < NNodes; i++) {
1577  			for(int l = 0; l < NAttrs; l++) {
1578  				if(Rnd.GetUniDev() <= PhiVV(i, l)) {
1579  					AttrVV.At(i, l) = 0;
1580  				} else {
1581  					AttrVV.At(i, l) = 1;
1582  				}
1583  				if(PhiVV(i, l) > 0.05 && PhiVV(i, l) < 0.95) count++;
1584  			}
1585  		}
1586  		LL += ComputeJointOneLL(AttrVV);
1587  	}
1588  	AttrVV.Clr();
1589  	return LL / double(NSample);
1590  }
1591  const double TMAGFitBern::ComputeApxLL() const {
1592  	double LL = 0.0;
1593  	const int NNodes = Param.GetNodes();
1594  	const int NAttrs = Param.GetAttrs();
1595  	TMAGNodeBern NodeAttr = Param.GetNodeAttr();
1596  	TFltV MuV = NodeAttr.GetMuV();
1597  	TMAGAffMtxV LLMtxV(NAttrs);
1598  	for(int l = 0; l < NAttrs; l++) {
1599  		for(int i = 0; i < NNodes; i++) {
1600  			LL += PhiVV(i, l) * log(MuV[l]);
1601  			LL += (1.0 - PhiVV(i, l)) * log(1.0 - MuV[l]);
1602  			LL -= PhiVV(i, l) * log(PhiVV(i, l));
1603  			LL -= (1.0 - PhiVV(i, l)) * log(1.0 - PhiVV(i, l));
1604  		}
1605  		TMAGAffMtx Theta = Param.GetMtx(l);
1606  		Theta.GetLLMtx(LLMtxV[l]);
1607  	}
1608  	for(int i = 0; i < NNodes; i++) {
1609  		for(int j = 0; j < NNodes; j++) {
1610  			if(i == j) {  continue;  }
1611  			if(Graph->IsEdge(i, j)) {
1612  				for(int l = 0; l < NAttrs; l++) {
1613  					LL += GetProbPhi(i, j, l, 0, 0) * LLMtxV[l].At(0, 0);
1614  					LL += GetProbPhi(i, j, l, 0, 1) * LLMtxV[l].At(0, 1);
1615  					LL += GetProbPhi(i, j, l, 1, 0) * LLMtxV[l].At(1, 0);
1616  					LL += GetProbPhi(i, j, l, 1, 1) * LLMtxV[l].At(1, 1);
1617  				}
1618  				LL += log(NormConst);
1619  			} else {
1620  				LL += log(1-exp(GetProdLinWeight(i, j)));
1621  			}
1622  		}
1623  	}
1624  	return LL;
1625  }
1626  const double TMAGFitBern::ComputeApxAdjLL() const {
1627  	double LL = 0.0;
1628  	const int NNodes = Param.GetNodes();
1629  	const int NAttrs = Param.GetAttrs();
1630  	TMAGNodeBern NodeAttr = Param.GetNodeAttr();
1631  	TFltV MuV = NodeAttr.GetMuV();
1632  	MuV.PutAll(0.0);
1633  	TMAGAffMtxV LLMtxV(NAttrs);
1634  	double TotalEdge = 0.0;
1635  	for(int l = 0; l < NAttrs; l++) {
1636  		TMAGAffMtx Theta = Param.GetMtx(l);
1637  		Theta.GetLLMtx(LLMtxV[l]);
1638  	}
1639  	for(int i = 0; i < NNodes; i++) {
1640  		for(int j = 0; j < NNodes; j++) {
1641  			if(i == j) {  continue;  }
1642  			if(Graph->IsEdge(i, j)) {
1643  				for(int l = 0; l < NAttrs; l++) {
1644  					LL += GetProbPhi(i, j, l, 0, 0) * LLMtxV[l].At(0, 0);
1645  					LL += GetProbPhi(i, j, l, 0, 1) * LLMtxV[l].At(0, 1);
1646  					LL += GetProbPhi(i, j, l, 1, 0) * LLMtxV[l].At(1, 0);
1647  					LL += GetProbPhi(i, j, l, 1, 1) * LLMtxV[l].At(1, 1);
1648  				}
1649  			} else {
1650  				LL += log(1-exp(GetProdLinWeight(i, j)));
1651  			}
1652  			double TempLL = 1.0;
1653  			for(int l = 0; l < NAttrs; l++) {
1654  				int Ai = (double(PhiVV(i, l)) > 0.5) ? 0 : 1;
1655  				int Aj = (double(PhiVV(j, l)) > 0.5) ? 0 : 1;
1656  				TempLL *= Param.GetMtx(l).At(Ai, Aj);
1657  			}
1658  			if(TMAGNodeBern::Rnd.GetUniDev() < TempLL) {
1659  				TotalEdge += 1.0;
1660  			}
1661  		}
1662  	}
1663  	return LL;
1664  }
1665  const double TMAGFitBern::ComputeMI(const TIntVV& AttrV, const int AId1, const int AId2) {
1666  	const int NNodes = AttrV.GetXDim();
1667  	double MI = 0.0;
1668  	double Cor = 0.0;
1669  	TFltVV Pxy(2,2);
1670  	TFltV Px(2), Py(2);
1671  	Pxy.PutAll(0.0);
1672  	Px.PutAll(0.0);
1673  	Py.PutAll(0.0);
1674  	for(int i = 0; i < NNodes; i++) {
1675  		int X = AttrV(i, AId1);
1676  		int Y = AttrV(i, AId2);
1677  		Pxy(X, Y) = Pxy(X, Y) + 1;
1678  		Px[X] = Px[X] + 1;
1679  		Py[Y] = Py[Y] + 1;
1680  		Cor += double(X * Y);
1681  	}
1682  	for(int x = 0; x < 2; x++) {
1683  		for(int y = 0; y < 2; y++) {
1684        MI += Pxy(x, y) / double(NNodes) * (log(Pxy(x, y).Val) - log(Px[x].Val) - log(Py[y].Val) + log((double)NNodes));
1685  		}
1686  	}
1687  	return MI;
1688  }
1689  const double TMAGFitBern::ComputeMI(const TFltVV& AttrV, const int AId1, const int AId2) {
1690  	const int NNodes = AttrV.GetXDim();
1691  	double MI = 0.0;
1692  	double Cor = 0.0;
1693  	TFltVV Pxy(2,2);
1694  	TFltV Px(2), Py(2);
1695  	Pxy.PutAll(0.0);
1696  	Px.PutAll(0.0);
1697  	Py.PutAll(0.0);
1698  	for(int i = 0; i < NNodes; i++) {
1699  		double X = AttrV(i, AId1);
1700  		double Y = AttrV(i, AId2);
1701  		Pxy(0, 0) = Pxy(0, 0) + X * Y;
1702  		Pxy(0, 1) = Pxy(0, 1) + X * (1 - Y);
1703  		Pxy(1, 0) = Pxy(1, 0) + (1 - X) * Y;
1704  		Pxy(1, 1) = (i+1) - Pxy(0, 0) - Pxy(0, 1) - Pxy(1, 0);
1705  		Px[0] = Px[0] + X;
1706  		Py[0] = Py[0] + Y;
1707  		Cor += double((1-X) * (1-Y));
1708  	}
1709  	Px[1] = NNodes - Px[0];
1710  	Py[1] = NNodes - Py[0];
1711  	for(int x = 0; x < 2; x++) {
1712  		for(int y = 0; y < 2; y++) {
1713  			MI += Pxy(x, y) / double(NNodes) * (log(Pxy(x, y)) - log(Px[x]) - log(Py[y]) + log(double(NNodes)));
1714  		}
1715  	}
1716  	return MI;
1717  }
1718  const double TMAGFitBern::ComputeMI(const TIntVV& AttrV) {
1719  	const int NAttrs = AttrV.GetYDim();
1720  	double MI = 0.0;
1721  	for(int l = 0; l < NAttrs; l++) {
1722  		for(int k = l+1; k < NAttrs; k++) {
1723  			MI += ComputeMI(AttrV, l, k);
1724  		}
1725  	}
1726  	return MI;
1727  }
1728  const double TMAGFitBern::ComputeMI(const TFltVV& AttrV) {
1729  	const int NAttrs = AttrV.GetYDim();
1730  	double MI = 0.0;
1731  	for(int l = 0; l < NAttrs; l++) {
1732  		for(int k = l+1; k < NAttrs; k++) {
1733  			MI += ComputeMI(AttrV, l, k);
1734  		}
1735  	}
1736  	return MI;
1737  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-timenet.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-mag.cpp</div>
                </div>
                <div class="column column_space"><pre><code>674    printf("Shuffling last %d (%d%%) edge arrival times..\n", GetEdges()-MinTmEdge, int(100.0*(GetEdges()-MinTmEdge)/double(GetEdges())));
675    TIntV RndEIdV;  GetEIdByTm(RndEIdV);
676    TIntV TrueEIdV = RndEIdV;
677    TSecTmV TrueTmV;
678    const int SwapLen = RndEIdV.Len()-MinTmEdge;
679    for (int R = 0; R < 10; R++) {
680      for (int i = MinTmEdge; i < RndEIdV.Len(); i++) {
</pre></code></div>
                <div class="column column_space"><pre><code>145    const int Rows = RowStrV.Len();
146    const int Cols = ColStrV.Len();
147    IAssert(Rows == Cols);
148    TMAGAffMtx Mtx(Rows);
149    for (int r = 0; r < Rows; r++) {
150      RowStrV[r].SplitOnWs(ColStrV);
151      IAssert(ColStrV.Len() == Cols);
152      for (int c = 0; c < Cols; c++) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    