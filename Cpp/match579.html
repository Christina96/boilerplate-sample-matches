<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head><title>Matches for tables-config-section.t.cpp &amp; udp-factory.t.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for tables-config-section.t.cpp &amp; udp-factory.t.cpp
      </h3>
<h1 align="center">
        7.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>tables-config-section.t.cpp (16.513762%)<th>udp-factory.t.cpp (4.6753244%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(362-413)<td><a href="#" name="0">(565-615)</a><td align="center"><font color="#ff0000">22</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(125-150)<td><a href="#" name="1">(721-753)</a><td align="center"><font color="#a20000">14</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>tables-config-section.t.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
/*
 * Copyright (c) 2014-2021,  Regents of the University of California,
 *                           Arizona Board of Regents,
 *                           Colorado State University,
 *                           University Pierre &amp; Marie Curie, Sorbonne University,
 *                           Washington University in St. Louis,
 *                           Beijing Institute of Technology,
 *                           The University of Memphis.
 *
 * This file is part of NFD (Named Data Networking Forwarding Daemon).
 * See AUTHORS.md for complete list of NFD authors and contributors.
 *
 * NFD is free software: you can redistribute it and/or modify it under the terms
 * of the GNU General Public License as published by the Free Software Foundation,
 * either version 3 of the License, or (at your option) any later version.
 *
 * NFD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * NFD, e.g., in COPYING.md file.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

#include "mgmt/tables-config-section.hpp"

#include "fw/best-route-strategy.hpp"
#include "fw/forwarder.hpp"
#include "table/cs-policy-lru.hpp"
#include "table/cs-policy-priority-fifo.hpp"

#include "tests/test-common.hpp"
#include "tests/check-typeid.hpp"
#include "tests/daemon/global-io-fixture.hpp"
#include "tests/daemon/fw/dummy-strategy.hpp"

namespace nfd {
namespace tests {

class TablesConfigSectionFixture : public GlobalIoFixture
{
protected:
  TablesConfigSectionFixture()
  {
    DummyStrategy::registerAs(strategyP);
    DummyStrategy::registerAs(strategyP1);
    // strategyP1Marker is NOT registered
    DummyStrategy::registerAs(strategyQ);
  }

  void
  runConfig(const std::string&amp; config, bool isDryRun)
  {
    ConfigFile cf;
    tablesConfig.setConfigFile(cf);
    cf.parse(config, isDryRun, "dummy-config");
  }

protected:
  FaceTable faceTable;
  Forwarder forwarder{faceTable};
  Cs&amp; cs{forwarder.getCs()};
  StrategyChoice&amp; strategyChoice{forwarder.getStrategyChoice()};
  NetworkRegionTable&amp; networkRegionTable{forwarder.getNetworkRegionTable()};

  TablesConfigSection tablesConfig{forwarder};

  const Name defaultStrategy = fw::BestRouteStrategy::getStrategyName();
  const Name strategyP = Name("/tables-config-section-strategy-P").appendVersion(2);
  const Name strategyP1 = "/tables-config-section-strategy-P/v=1";
  const Name strategyP1Marker = "/tables-config-section-strategy-P/%FD%01";
  const Name strategyQ = Name("/tables-config-section-strategy-Q").appendVersion(2);
};

BOOST_AUTO_TEST_SUITE(Mgmt)
BOOST_FIXTURE_TEST_SUITE(TestTablesConfigSection, TablesConfigSectionFixture)

BOOST_AUTO_TEST_SUITE(CsMaxPackets)

BOOST_AUTO_TEST_CASE(NoSection)
{
  const size_t initialLimit = cs.getLimit();

  tablesConfig.ensureConfigured();
  BOOST_CHECK_NE(cs.getLimit(), initialLimit);
}

BOOST_AUTO_TEST_CASE(Default)
{
  const std::string CONFIG = R"CONFIG(
    tables
    {
    }
  )CONFIG";

  const size_t initialLimit = cs.getLimit();

  BOOST_REQUIRE_NO_THROW(runConfig(CONFIG, true));
  BOOST_CHECK_EQUAL(cs.getLimit(), initialLimit);

  BOOST_REQUIRE_NO_THROW(runConfig(CONFIG, false));
  BOOST_CHECK_NE(cs.getLimit(), initialLimit);
}

BOOST_AUTO_TEST_CASE(Valid)
{
  const std::string CONFIG = R"CONFIG(
    tables
    {
      cs_max_packets 101
    }
  )CONFIG";

  BOOST_REQUIRE_NE(cs.getLimit(), 101);

  BOOST_REQUIRE_NO_THROW(runConfig(CONFIG, true));
  BOOST_CHECK_NE(cs.getLimit(), 101);

  BOOST_REQUIRE_NO_THROW(runConfig(CONFIG, false));
  BOOST_CHECK_EQUAL(cs.getLimit(), 101);
<a name="1"></a>
  tablesConfig.ensureConfigured();
  BOOST_CHECK_EQUAL(cs.getLimit(), 101);
<font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}

BOOST_AUTO_TEST_CASE(MissingValue)
{
  const std::string CONFIG = R"CONFIG(
    tables
    {
      cs_max_packets
    }
  )CONFIG";

  BOOST_CHECK_THROW(runConfig(CONFIG, true), ConfigFile::Error);
  BOOST_CHECK_THROW(runConfig(CONFIG, false), ConfigFile::Error);
}

BOOST_AUTO_TEST_CASE(InvalidValue)
{
  const std::string CONFIG = R"CONFIG(
    tables
    {
      cs_max_packets invalid
    }
  )CONFIG";

  BOOST_CHECK_THROW(runConfig(CONFIG, true), ConfigFile::Error);
  BOOST_CHECK_THROW(runConfig(CONFIG, false), ConfigFile::Error);</b></font>
}

BOOST_AUTO_TEST_SUITE_END() // CsMaxPackets

BOOST_AUTO_TEST_SUITE(CsPolicy)

BOOST_AUTO_TEST_CASE(Default)
{
  const std::string CONFIG = R"CONFIG(
    tables
    {
    }
  )CONFIG";

  runConfig(CONFIG, false);
  cs::Policy* currentPolicy = cs.getPolicy();
  NFD_CHECK_TYPEID_EQUAL(*currentPolicy, cs::LruPolicy);
}

BOOST_AUTO_TEST_CASE(Known)
{
  const std::string CONFIG = R"CONFIG(
    tables
    {
      cs_policy priority_fifo
    }
  )CONFIG";

  runConfig(CONFIG, true);
  cs::Policy* currentPolicy = cs.getPolicy();
  NFD_CHECK_TYPEID_EQUAL(*currentPolicy, cs::LruPolicy);

  runConfig(CONFIG, false);
  currentPolicy = cs.getPolicy();
  NFD_CHECK_TYPEID_EQUAL(*currentPolicy, cs::PriorityFifoPolicy);
}

BOOST_AUTO_TEST_CASE(Unknown)
{
  const std::string CONFIG = R"CONFIG(
    tables
    {
      cs_policy unknown
    }
  )CONFIG";

  BOOST_CHECK_THROW(runConfig(CONFIG, true), ConfigFile::Error);
  BOOST_CHECK_THROW(runConfig(CONFIG, false), ConfigFile::Error);
}

BOOST_AUTO_TEST_SUITE_END() // CsPolicy

class CsUnsolicitedPolicyFixture : public TablesConfigSectionFixture
{
protected:
  CsUnsolicitedPolicyFixture()
  {
    forwarder.setUnsolicitedDataPolicy(make_unique&lt;fw::AdmitNetworkUnsolicitedDataPolicy&gt;());
  }
};

BOOST_FIXTURE_TEST_SUITE(CsUnsolicitedPolicy, CsUnsolicitedPolicyFixture)

BOOST_AUTO_TEST_CASE(NoSection)
{
  tablesConfig.ensureConfigured();

  auto* currentPolicy = &amp;forwarder.getUnsolicitedDataPolicy();
  NFD_CHECK_TYPEID_EQUAL(*currentPolicy, fw::DefaultUnsolicitedDataPolicy);
}

BOOST_AUTO_TEST_CASE(Default)
{
  const std::string CONFIG = R"CONFIG(
    tables
    {
    }
  )CONFIG";

  BOOST_REQUIRE_NO_THROW(runConfig(CONFIG, true));
  auto* currentPolicy = &amp;forwarder.getUnsolicitedDataPolicy();
  NFD_CHECK_TYPEID_NE(*currentPolicy, fw::DefaultUnsolicitedDataPolicy);

  BOOST_REQUIRE_NO_THROW(runConfig(CONFIG, false));
  currentPolicy = &amp;forwarder.getUnsolicitedDataPolicy();
  NFD_CHECK_TYPEID_EQUAL(*currentPolicy, fw::DefaultUnsolicitedDataPolicy);
}

BOOST_AUTO_TEST_CASE(Known)
{
  const std::string CONFIG = R"CONFIG(
    tables
    {
      cs_unsolicited_policy admit-all
    }
  )CONFIG";

  BOOST_REQUIRE_NO_THROW(runConfig(CONFIG, true));
  auto* currentPolicy = &amp;forwarder.getUnsolicitedDataPolicy();
  NFD_CHECK_TYPEID_NE(*currentPolicy, fw::AdmitAllUnsolicitedDataPolicy);

  BOOST_REQUIRE_NO_THROW(runConfig(CONFIG, false));
  currentPolicy = &amp;forwarder.getUnsolicitedDataPolicy();
  NFD_CHECK_TYPEID_EQUAL(*currentPolicy, fw::AdmitAllUnsolicitedDataPolicy);
}

BOOST_AUTO_TEST_CASE(Unknown)
{
  const std::string CONFIG = R"CONFIG(
    tables
    {
      cs_unsolicited_policy unknown
    }
  )CONFIG";

  BOOST_CHECK_THROW(runConfig(CONFIG, true), ConfigFile::Error);
  BOOST_CHECK_THROW(runConfig(CONFIG, false), ConfigFile::Error);
}

BOOST_AUTO_TEST_SUITE_END() // CsUnsolicitedPolicy

BOOST_AUTO_TEST_SUITE(StrategyChoice)

BOOST_AUTO_TEST_CASE(Unversioned)
{
  const std::string CONFIG = R"CONFIG(
    tables
    {
      strategy_choice
      {
        / /tables-config-section-strategy-P
        /a /tables-config-section-strategy-Q
      }
    }
  )CONFIG";

  BOOST_REQUIRE_NO_THROW(runConfig(CONFIG, true));
  {
    fw::Strategy&amp; rootStrategy = strategyChoice.findEffectiveStrategy("/");
    BOOST_CHECK_EQUAL(rootStrategy.getInstanceName(), defaultStrategy);

    fw::Strategy&amp; aStrategy = strategyChoice.findEffectiveStrategy("/a");
    BOOST_CHECK_EQUAL(aStrategy.getInstanceName(), defaultStrategy);
  }

  BOOST_REQUIRE_NO_THROW(runConfig(CONFIG, false));
  {
    fw::Strategy&amp; rootStrategy = strategyChoice.findEffectiveStrategy("/");
    BOOST_CHECK_EQUAL(rootStrategy.getInstanceName(), strategyP.getPrefix(-1));
    NFD_CHECK_TYPEID_EQUAL(rootStrategy, DummyStrategy);

    fw::Strategy&amp; aStrategy = strategyChoice.findEffectiveStrategy("/a");
    BOOST_CHECK_EQUAL(aStrategy.getInstanceName(), strategyQ.getPrefix(-1));
    NFD_CHECK_TYPEID_EQUAL(aStrategy, DummyStrategy);
  }
}

BOOST_AUTO_TEST_CASE(Versioned)
{
  const std::string CONFIG = R"CONFIG(
    tables
    {
      strategy_choice
      {
        /test/latest /tables-config-section-strategy-P
        /test/old /tables-config-section-strategy-P/v=1
        /test/marker /tables-config-section-strategy-P/%FD%01
      }
    }
  )CONFIG";

  BOOST_REQUIRE_NO_THROW(runConfig(CONFIG, true));
  {
    fw::Strategy&amp; testLatestStrategy = strategyChoice.findEffectiveStrategy("/test/latest");
    BOOST_CHECK_EQUAL(testLatestStrategy.getInstanceName(), defaultStrategy);

    fw::Strategy&amp; testOldStrategy = strategyChoice.findEffectiveStrategy("/test/old");
    BOOST_CHECK_EQUAL(testOldStrategy.getInstanceName(), defaultStrategy);

    fw::Strategy&amp; testMarkerStrategy = strategyChoice.findEffectiveStrategy("/test/marker");
    BOOST_CHECK_EQUAL(testMarkerStrategy.getInstanceName(), defaultStrategy);
  }

  BOOST_REQUIRE_NO_THROW(runConfig(CONFIG, false));
  {
    fw::Strategy&amp; testLatestStrategy = strategyChoice.findEffectiveStrategy("/test/latest");
    BOOST_CHECK_EQUAL(testLatestStrategy.getInstanceName(), strategyP.getPrefix(-1));
    NFD_CHECK_TYPEID_EQUAL(testLatestStrategy, DummyStrategy);

    fw::Strategy&amp; testOldStrategy = strategyChoice.findEffectiveStrategy("/test/old");
    BOOST_CHECK_EQUAL(testOldStrategy.getInstanceName(), strategyP1);
    NFD_CHECK_TYPEID_EQUAL(testOldStrategy, DummyStrategy);

    fw::Strategy&amp; testMarkerStrategy = strategyChoice.findEffectiveStrategy("/test/marker");
    BOOST_CHECK_EQUAL(testMarkerStrategy.getInstanceName(), strategyP1Marker);
    NFD_CHECK_TYPEID_EQUAL(testMarkerStrategy, DummyStrategy);
  }
}

BOOST_AUTO_TEST_CASE(NonExisting)
{
  const std::string CONFIG = R"CONFIG(
    tables
    {
      strategy_choice
      {
        / /localhost/nfd/strategy/test-doesnotexist
      }
<a name="0"></a>    }
  )CONFIG";

<font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  BOOST_CHECK_THROW(runConfig(CONFIG, true), ConfigFile::Error);
  BOOST_CHECK_THROW(runConfig(CONFIG, false), ConfigFile::Error);
}

BOOST_AUTO_TEST_CASE(MissingPrefix)
{
  const std::string CONFIG = R"CONFIG(
    tables
    {
      strategy_choice
      {
        /tables-config-section-strategy-P
      }
    }
  )CONFIG";

  BOOST_CHECK_THROW(runConfig(CONFIG, true), ConfigFile::Error);
  BOOST_CHECK_THROW(runConfig(CONFIG, false), ConfigFile::Error);
}

BOOST_AUTO_TEST_CASE(Duplicate)
{
  const std::string CONFIG = R"CONFIG(
    tables
    {
      strategy_choice
      {
        / /tables-config-section-strategy-P
        /a /tables-config-section-strategy-Q
        / /tables-config-section-strategy-Q
      }
    }
  )CONFIG";

  BOOST_CHECK_THROW(runConfig(CONFIG, true), ConfigFile::Error);
  BOOST_CHECK_THROW(runConfig(CONFIG, false), ConfigFile::Error);
}

BOOST_AUTO_TEST_CASE(UnacceptableParameters)
{
  const std::string CONFIG = R"CONFIG(
    tables
    {
      strategy_choice
      {
        / /localhost/nfd/strategy/best-route/v=5/param
      }
    }
  )CONFIG";

  BOOST_CHECK_NO_THROW(runConfig(CONFIG, true));
  BOOST_CHECK_THROW(runConfig(CONFIG, false), ConfigFile::Error);</b></font>
}

BOOST_AUTO_TEST_SUITE_END() // StrategyChoice

BOOST_AUTO_TEST_SUITE(NetworkRegion)

BOOST_AUTO_TEST_CASE(Basic)
{
  const std::string CONFIG = R"CONFIG(
    tables
    {
      network_region
      {
        /test/regionA
        /test/regionB/component
      }
    }
  )CONFIG";

  BOOST_REQUIRE_NO_THROW(runConfig(CONFIG, true));
  BOOST_CHECK_EQUAL(networkRegionTable.size(), 0);

  BOOST_CHECK(networkRegionTable.find("/test/regionA") == networkRegionTable.end());
  BOOST_CHECK(networkRegionTable.find("/test/regionB/component") == networkRegionTable.end());

  BOOST_REQUIRE_NO_THROW(runConfig(CONFIG, false));
  BOOST_CHECK_EQUAL(networkRegionTable.size(), 2);

  BOOST_CHECK(networkRegionTable.find("/test/regionA") != networkRegionTable.end());
  BOOST_CHECK(networkRegionTable.find("/test/regionB/component") != networkRegionTable.end());
}

BOOST_AUTO_TEST_CASE(Reload)
{
  const std::string CONFIG1 = R"CONFIG(
    tables
    {
      network_region
      {
        /some/region
      }
    }
  )CONFIG";

  BOOST_REQUIRE_NO_THROW(runConfig(CONFIG1, true));
  BOOST_CHECK(networkRegionTable.find("/some/region") == networkRegionTable.end());

  BOOST_REQUIRE_NO_THROW(runConfig(CONFIG1, false));
  BOOST_CHECK(networkRegionTable.find("/some/region") != networkRegionTable.end());

  const std::string CONFIG2 = R"CONFIG(
    tables
    {
      network_region
      {
        /different/region
      }
    }
  )CONFIG";

  BOOST_REQUIRE_NO_THROW(runConfig(CONFIG2, true));
  BOOST_CHECK(networkRegionTable.find("/some/region") != networkRegionTable.end());
  BOOST_CHECK(networkRegionTable.find("/different/region") == networkRegionTable.end());

  BOOST_REQUIRE_NO_THROW(runConfig(CONFIG2, false));
  BOOST_CHECK(networkRegionTable.find("/some/region") == networkRegionTable.end());
  BOOST_CHECK(networkRegionTable.find("/different/region") != networkRegionTable.end());
}

BOOST_AUTO_TEST_SUITE_END() // NetworkRegion

BOOST_AUTO_TEST_SUITE_END() // TestTablesConfigSection
BOOST_AUTO_TEST_SUITE_END() // Mgmt

} // namespace tests
} // namespace nfd
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>udp-factory.t.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
/*
 * Copyright (c) 2014-2021,  Regents of the University of California,
 *                           Arizona Board of Regents,
 *                           Colorado State University,
 *                           University Pierre &amp; Marie Curie, Sorbonne University,
 *                           Washington University in St. Louis,
 *                           Beijing Institute of Technology,
 *                           The University of Memphis.
 *
 * This file is part of NFD (Named Data Networking Forwarding Daemon).
 * See AUTHORS.md for complete list of NFD authors and contributors.
 *
 * NFD is free software: you can redistribute it and/or modify it under the terms
 * of the GNU General Public License as published by the Free Software Foundation,
 * either version 3 of the License, or (at your option) any later version.
 *
 * NFD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * NFD, e.g., in COPYING.md file.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

#include "face/udp-factory.hpp"

#include "face-system-fixture.hpp"
#include "factory-test-common.hpp"

#include &lt;boost/algorithm/string/replace.hpp&gt;

namespace nfd {
namespace face {
namespace tests {

class UdpFactoryFixture : public FaceSystemFactoryFixture&lt;UdpFactory&gt;
{
protected:
  shared_ptr&lt;UdpChannel&gt;
  createChannel(const std::string&amp; localIp, uint16_t localPort)
  {
    udp::Endpoint endpoint(boost::asio::ip::address::from_string(localIp), localPort);
    return factory.createChannel(endpoint, 5_min);
  }
};

class UdpFactoryMcastFixture : public UdpFactoryFixture
{
protected:
  UdpFactoryMcastFixture()
  {
    for (const auto&amp; netif : collectNetworkInterfaces()) {
      // same filtering logic as UdpFactory::applyMcastConfigToNetif()
      if (netif-&gt;isUp() &amp;&amp; !netif-&gt;isLoopback() &amp;&amp; netif-&gt;canMulticast()) {
        bool hasValidIpAddress = false;
        if (hasAddressFamily(*netif, ndn::net::AddressFamily::V4)) {
          hasValidIpAddress = true;
          netifsV4.push_back(netif);
        }
        if (hasAddressFamily(*netif, ndn::net::AddressFamily::V6)) {
          hasValidIpAddress = true;
          netifsV6.push_back(netif);
        }
        if (hasValidIpAddress) {
          netifs.push_back(netif);
        }
      }
    }
    this-&gt;copyRealNetifsToNetmon();
  }

  shared_ptr&lt;Face&gt;
  createMulticastFace(const std::string&amp; localIp, const std::string&amp; mcastIp, uint16_t mcastPort)
  {
    auto localAddress = boost::asio::ip::address::from_string(localIp);
    udp::Endpoint mcastEndpoint(boost::asio::ip::address::from_string(mcastIp), mcastPort);

    if (localAddress.is_v4()) {
      BOOST_ASSERT(!netifsV4.empty());
      return factory.createMulticastFace(netifsV4.front(), localAddress, mcastEndpoint);
    }
    else {
      BOOST_ASSERT(!netifsV6.empty());
      return factory.createMulticastFace(netifsV6.front(), localAddress, mcastEndpoint);
    }
  }

  /** \brief returns a non-loopback IP address suitable for the creation of a UDP multicast face
   */
  boost::asio::ip::address
  findNonLoopbackAddressForMulticastFace(ndn::net::AddressFamily af) const
  {
    const auto&amp; netifList = af == ndn::net::AddressFamily::V4 ? netifsV4 : netifsV6;
    for (const auto&amp; netif : netifList) {
      for (const auto&amp; a : netif-&gt;getNetworkAddresses()) {
        if (a.getFamily() == af &amp;&amp; !a.getIp().is_loopback())
          return a.getIp();
      }
    }
    return {};
  }

  std::vector&lt;const Face*&gt;
  listUdp4McastFaces(ndn::nfd::LinkType linkType = ndn::nfd::LINK_TYPE_MULTI_ACCESS) const
  {
    return this-&gt;listFacesByScheme("udp4", linkType);
  }

  std::vector&lt;const Face*&gt;
  listUdp6McastFaces(ndn::nfd::LinkType linkType = ndn::nfd::LINK_TYPE_MULTI_ACCESS) const
  {
    return this-&gt;listFacesByScheme("udp6", linkType);
  }

  /** \brief determine whether \p netif has at least one IP address of the given family
   */
  static bool
  hasAddressFamily(const NetworkInterface&amp; netif, ndn::net::AddressFamily af)
  {
    return std::any_of(netif.getNetworkAddresses().begin(), netif.getNetworkAddresses().end(),
                       [af] (const NetworkAddress&amp; a) { return a.getFamily() == af; });
  }

  /** \brief determine whether a UDP multicast face is created on \p netif
   */
  static bool
  isFaceOnNetif(const Face&amp; face, const NetworkInterface&amp; netif)
  {
    auto ip = boost::asio::ip::address::from_string(face.getLocalUri().getHost());
    return std::any_of(netif.getNetworkAddresses().begin(), netif.getNetworkAddresses().end(),
                       [ip] (const NetworkAddress&amp; a) { return a.getIp() == ip; });
  }

protected:
  /** \brief MulticastUdpTransport-capable network interfaces (IPv4 + IPv6)
   *
   *  This should be used in test cases that do not depend on a specific address family
   */
  std::vector&lt;shared_ptr&lt;const NetworkInterface&gt;&gt; netifs;

  /** \brief MulticastUdpTransport-capable network interfaces (IPv4 only)
   */
  std::vector&lt;shared_ptr&lt;const NetworkInterface&gt;&gt; netifsV4;

  /** \brief MulticastUdpTransport-capable network interfaces (IPv6 only)
   */
  std::vector&lt;shared_ptr&lt;const NetworkInterface&gt;&gt; netifsV6;
};

#define SKIP_IF_UDP_MCAST_NETIF_COUNT_LT(n) \
  do { \
    if (this-&gt;netifs.size() &lt; (n)) { \
      BOOST_WARN_MESSAGE(false, "skipping assertions that require " #n \
                                " or more MulticastUdpTransport-capable network interfaces"); \
      return; \
    } \
  } while (false)

#define SKIP_IF_UDP_MCAST_V4_NETIF_COUNT_LT(n) \
  do { \
    if (this-&gt;netifsV4.size() &lt; (n)) { \
      BOOST_WARN_MESSAGE(false, "skipping assertions that require " #n \
                                " or more IPv4 MulticastUdpTransport-capable network interfaces"); \
      return; \
    } \
  } while (false)

#define SKIP_IF_UDP_MCAST_V6_NETIF_COUNT_LT(n) \
  do { \
    if (this-&gt;netifsV6.size() &lt; (n)) { \
      BOOST_WARN_MESSAGE(false, "skipping assertions that require " #n \
                                " or more IPv6 MulticastUdpTransport-capable network interfaces"); \
      return; \
    } \
  } while (false)

BOOST_AUTO_TEST_SUITE(Face)
BOOST_FIXTURE_TEST_SUITE(TestUdpFactory, UdpFactoryFixture)

BOOST_AUTO_TEST_SUITE(ProcessConfig)

using nfd::Face;

BOOST_AUTO_TEST_CASE(Defaults)
{
  const std::string CONFIG = R"CONFIG(
    face_system
    {
      udp
    }
  )CONFIG";

  parseConfig(CONFIG, true);
  parseConfig(CONFIG, false);

  checkChannelListEqual(factory, {"udp4://0.0.0.0:6363", "udp6://[::]:6363"});
  for (const auto&amp; ch : factory.getChannels()) {
    BOOST_CHECK(ch-&gt;isListening());
    BOOST_CHECK_EQUAL(ch-&gt;getDefaultMtu(), ndn::MAX_NDN_PACKET_SIZE);
  }
}

BOOST_AUTO_TEST_CASE(DisableListen)
{
  const std::string CONFIG = R"CONFIG(
    face_system
    {
      udp
      {
        listen no
        port 7001
        mcast no
      }
    }
  )CONFIG";

  parseConfig(CONFIG, true);
  parseConfig(CONFIG, false);

  checkChannelListEqual(factory, {"udp4://0.0.0.0:7001", "udp6://[::]:7001"});
  for (const auto&amp; ch : factory.getChannels()) {
    BOOST_CHECK(!ch-&gt;isListening());
  }
}

BOOST_AUTO_TEST_CASE(DisableV4)
{
  const std::string CONFIG = R"CONFIG(
    face_system
    {
      udp
      {
        port 7001
        enable_v4 no
        enable_v6 yes
        unicast_mtu 1452
        mcast no
      }
    }
  )CONFIG";

  parseConfig(CONFIG, true);
  parseConfig(CONFIG, false);

  checkChannelListEqual(factory, {"udp6://[::]:7001"});
  for (const auto&amp; ch : factory.getChannels()) {
    BOOST_CHECK_EQUAL(ch-&gt;getDefaultMtu(), 1452);
  }
}

BOOST_AUTO_TEST_CASE(DisableV6)
{
  const std::string CONFIG = R"CONFIG(
    face_system
    {
      udp
      {
        port 7001
        enable_v4 yes
        enable_v6 no
        unicast_mtu 1452
        mcast no
      }
    }
  )CONFIG";

  parseConfig(CONFIG, true);
  parseConfig(CONFIG, false);

  checkChannelListEqual(factory, {"udp4://0.0.0.0:7001"});
  for (const auto&amp; ch : factory.getChannels()) {
    BOOST_CHECK_EQUAL(ch-&gt;getDefaultMtu(), 1452);
  }
}

BOOST_FIXTURE_TEST_CASE(EnableDisableMcast, UdpFactoryMcastFixture)
{
  const std::string CONFIG_WITH_MCAST = R"CONFIG(
    face_system
    {
      udp
      {
        mcast yes
      }
    }
  )CONFIG";
  const std::string CONFIG_WITHOUT_MCAST = R"CONFIG(
    face_system
    {
      udp
      {
        mcast no
      }
    }
  )CONFIG";

  parseConfig(CONFIG_WITHOUT_MCAST, false);
  BOOST_CHECK_EQUAL(this-&gt;listUdp4McastFaces().size(), 0);
  BOOST_CHECK_EQUAL(this-&gt;listUdp6McastFaces().size(), 0);

#ifdef __linux__
  // need superuser privileges to create multicast faces on Linux
  SKIP_IF_NOT_SUPERUSER();
#endif // __linux__

  parseConfig(CONFIG_WITH_MCAST, false);
  g_io.poll();
  BOOST_CHECK_EQUAL(this-&gt;listUdp4McastFaces().size(), netifsV4.size());
  BOOST_CHECK_EQUAL(this-&gt;listUdp6McastFaces().size(), netifsV6.size());

  BOOST_REQUIRE_EQUAL(factory.getChannels().size(), 2);
  for (const auto&amp; face : this-&gt;listUdp4McastFaces()) {
    BOOST_REQUIRE(face-&gt;getChannel().lock());
    BOOST_CHECK_EQUAL(face-&gt;getChannel().lock()-&gt;getUri().getScheme(), "udp4");
  }

  for (const auto&amp; face : this-&gt;listUdp6McastFaces()) {
    BOOST_REQUIRE(face-&gt;getChannel().lock());
    BOOST_CHECK_EQUAL(face-&gt;getChannel().lock()-&gt;getUri().getScheme(), "udp6");
  }

  parseConfig(CONFIG_WITHOUT_MCAST, false);
  g_io.poll();
  BOOST_CHECK_EQUAL(this-&gt;listUdp4McastFaces().size(), 0);
  BOOST_CHECK_EQUAL(this-&gt;listUdp6McastFaces().size(), 0);
}

BOOST_FIXTURE_TEST_CASE(McastAdHoc, UdpFactoryMcastFixture)
{
#ifdef __linux__
  // need superuser privileges to create multicast faces on Linux
  SKIP_IF_NOT_SUPERUSER();
#endif // __linux__
  SKIP_IF_UDP_MCAST_NETIF_COUNT_LT(1);

  const std::string CONFIG = R"CONFIG(
    face_system
    {
      udp
      {
        mcast_ad_hoc yes
      }
    }
  )CONFIG";

  parseConfig(CONFIG, false);
  BOOST_CHECK_EQUAL(this-&gt;listUdp4McastFaces(ndn::nfd::LINK_TYPE_AD_HOC).size(), netifsV4.size());
  BOOST_CHECK_EQUAL(this-&gt;listUdp6McastFaces(ndn::nfd::LINK_TYPE_AD_HOC).size(), netifsV6.size());
}

BOOST_FIXTURE_TEST_CASE(ChangeMcastEndpointV4, UdpFactoryMcastFixture)
{
#ifdef __linux__
  // need superuser privileges to create multicast faces on Linux
  SKIP_IF_NOT_SUPERUSER();
#endif // __linux__
  SKIP_IF_UDP_MCAST_V4_NETIF_COUNT_LT(1);

  const std::string CONFIG1 = R"CONFIG(
    face_system
    {
      udp
      {
        mcast_group 239.66.30.1
        mcast_port 7011
      }
    }
  )CONFIG";
  const std::string CONFIG2 = R"CONFIG(
    face_system
    {
      udp
      {
        mcast_group 239.66.30.2
        mcast_port 7012
      }
    }
  )CONFIG";

  parseConfig(CONFIG1, false);
  auto udpMcastFaces = this-&gt;listUdp4McastFaces();
  BOOST_REQUIRE_EQUAL(udpMcastFaces.size(), netifsV4.size());
  BOOST_CHECK_EQUAL(udpMcastFaces.front()-&gt;getRemoteUri(), FaceUri("udp4://239.66.30.1:7011"));

  parseConfig(CONFIG2, false);
  g_io.poll();
  udpMcastFaces = this-&gt;listUdp4McastFaces();
  BOOST_REQUIRE_EQUAL(udpMcastFaces.size(), netifsV4.size());
  BOOST_CHECK_EQUAL(udpMcastFaces.front()-&gt;getRemoteUri(), FaceUri("udp4://239.66.30.2:7012"));
}

BOOST_FIXTURE_TEST_CASE(ChangeMcastEndpointV6, UdpFactoryMcastFixture)
{
#ifdef __linux__
  // need superuser privileges to create multicast faces on Linux
  SKIP_IF_NOT_SUPERUSER();
#endif // __linux__
  SKIP_IF_UDP_MCAST_V6_NETIF_COUNT_LT(1);

  const std::string CONFIG1 = R"CONFIG(
    face_system
    {
      udp
      {
        mcast_group_v6 ff02::1101
        mcast_port_v6 7011
      }
    }
  )CONFIG";
  const std::string CONFIG2 = R"CONFIG(
    face_system
    {
      udp
      {
        mcast_group_v6 ff02::1102
        mcast_port_v6 7012
      }
    }
  )CONFIG";

  parseConfig(CONFIG1, false);
  auto udpMcastFaces = this-&gt;listUdp6McastFaces();
  BOOST_REQUIRE_EQUAL(udpMcastFaces.size(), netifsV6.size());
  auto expectedAddr = boost::asio::ip::address_v6::from_string("ff02::1101");
  expectedAddr.scope_id(netifsV6.front()-&gt;getIndex());
  BOOST_CHECK_EQUAL(udpMcastFaces.front()-&gt;getRemoteUri(), FaceUri(udp::Endpoint(expectedAddr, 7011)));

  parseConfig(CONFIG2, false);
  g_io.poll();
  udpMcastFaces = this-&gt;listUdp6McastFaces();
  BOOST_REQUIRE_EQUAL(udpMcastFaces.size(), netifsV6.size());
  expectedAddr = boost::asio::ip::address_v6::from_string("ff02::1102");
  expectedAddr.scope_id(netifsV6.front()-&gt;getIndex());
  BOOST_CHECK_EQUAL(udpMcastFaces.front()-&gt;getRemoteUri(), FaceUri(udp::Endpoint(expectedAddr, 7012)));
}

BOOST_FIXTURE_TEST_CASE(Whitelist, UdpFactoryMcastFixture)
{
#ifdef __linux__
  // need superuser privileges to create multicast faces on Linux
  SKIP_IF_NOT_SUPERUSER();
#endif // __linux__
  SKIP_IF_UDP_MCAST_NETIF_COUNT_LT(1);

  std::string CONFIG = R"CONFIG(
    face_system
    {
      udp
      {
        whitelist
        {
          ifname %ifname
        }
      }
    }
  )CONFIG";
  boost::replace_first(CONFIG, "%ifname", netifs.front()-&gt;getName());

  parseConfig(CONFIG, false);

  auto udpMcastFaces = this-&gt;listUdp4McastFaces();
  BOOST_CHECK_LE(udpMcastFaces.size(), 1);
  auto udpMcastFacesV6 = this-&gt;listUdp6McastFaces();
  BOOST_CHECK_LE(udpMcastFacesV6.size(), 1);
  udpMcastFaces.insert(udpMcastFaces.end(), udpMcastFacesV6.begin(), udpMcastFacesV6.end());
  BOOST_CHECK_GE(udpMcastFaces.size(), 1);
  BOOST_CHECK(std::all_of(udpMcastFaces.begin(), udpMcastFaces.end(),
                          [this] (const Face* face) { return isFaceOnNetif(*face, *netifs.front()); }));
}

BOOST_FIXTURE_TEST_CASE(Blacklist, UdpFactoryMcastFixture)
{
#ifdef __linux__
  // need superuser privileges to create multicast faces on Linux
  SKIP_IF_NOT_SUPERUSER();
#endif // __linux__
  SKIP_IF_UDP_MCAST_NETIF_COUNT_LT(1);

  std::string CONFIG = R"CONFIG(
    face_system
    {
      udp
      {
        blacklist
        {
          ifname %ifname
        }
      }
    }
  )CONFIG";
  boost::replace_first(CONFIG, "%ifname", netifs.front()-&gt;getName());

  parseConfig(CONFIG, false);

  auto udpMcastFaces = this-&gt;listUdp4McastFaces();
  if (!netifsV4.empty())
    BOOST_CHECK_GE(udpMcastFaces.size(), netifsV4.size() - 1);
  auto udpMcastFacesV6 = this-&gt;listUdp6McastFaces();
  if (!netifsV6.empty())
    BOOST_CHECK_GE(udpMcastFacesV6.size(), netifsV6.size() - 1);
  udpMcastFaces.insert(udpMcastFaces.end(), udpMcastFacesV6.begin(), udpMcastFacesV6.end());
  BOOST_CHECK_LT(udpMcastFaces.size(), netifsV4.size() + netifsV6.size());
  BOOST_CHECK(std::none_of(udpMcastFaces.begin(), udpMcastFaces.end(),
                           [this] (const Face* face) { return isFaceOnNetif(*face, *netifs.front()); }));
}

BOOST_FIXTURE_TEST_CASE(ChangePredicate, UdpFactoryMcastFixture)
{
#ifdef __linux__
  // need superuser privileges to create multicast faces on Linux
  SKIP_IF_NOT_SUPERUSER();
#endif // __linux__
  SKIP_IF_UDP_MCAST_NETIF_COUNT_LT(2);

  std::string CONFIG1 = R"CONFIG(
    face_system
    {
      udp
      {
        whitelist
        {
          ifname %ifname
        }
      }
    }
  )CONFIG";
  std::string CONFIG2 = CONFIG1;
  boost::replace_first(CONFIG1, "%ifname", netifs.front()-&gt;getName());
  boost::replace_first(CONFIG2, "%ifname", netifs.back()-&gt;getName());

  parseConfig(CONFIG1, false);

  auto udpMcastFaces = this-&gt;listUdp4McastFaces();
  auto udpMcastFacesV6 = this-&gt;listUdp6McastFaces();
  udpMcastFaces.insert(udpMcastFaces.end(), udpMcastFacesV6.begin(), udpMcastFacesV6.end());
  BOOST_CHECK_GE(udpMcastFaces.size(), 1);
  BOOST_CHECK(std::all_of(udpMcastFaces.begin(), udpMcastFaces.end(),
                          [this] (const Face* face) { return isFaceOnNetif(*face, *netifs.front()); }));

  parseConfig(CONFIG2, false);
  g_io.poll();

  udpMcastFaces = this-&gt;listUdp4McastFaces();
  udpMcastFacesV6 = this-&gt;listUdp6McastFaces();
  udpMcastFaces.insert(udpMcastFaces.end(), udpMcastFacesV6.begin(), udpMcastFacesV6.end());
  BOOST_CHECK_GE(udpMcastFaces.size(), 1);
  BOOST_CHECK(std::all_of(udpMcastFaces.begin(), udpMcastFaces.end(),
                          [this] (const Face* face) { return isFaceOnNetif(*face, *netifs.back()); }));
}

BOOST_AUTO_TEST_CASE(Omitted)
{
  const std::string CONFIG = R"CONFIG(
    face_system
    {
    }
  )CONFIG";

  parseConfig(CONFIG, true);
  parseConfig(CONFIG, false);
<a name="0"></a>
  BOOST_CHECK_EQUAL(factory.getChannels().size(), 0);
  BOOST_CHECK_EQUAL(this-&gt;listFacesByScheme("udp4", ndn::nfd::LINK_TYPE_MULTI_ACCESS).size(), 0);
<font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  BOOST_CHECK_EQUAL(this-&gt;listFacesByScheme("udp6", ndn::nfd::LINK_TYPE_MULTI_ACCESS).size(), 0);
}

BOOST_AUTO_TEST_CASE(AllDisabled)
{
  const std::string CONFIG = R"CONFIG(
    face_system
    {
      udp
      {
        enable_v4 no
        enable_v6 no
        mcast no
      }
    }
  )CONFIG";

  BOOST_CHECK_THROW(parseConfig(CONFIG, true), ConfigFile::Error);
  BOOST_CHECK_THROW(parseConfig(CONFIG, false), ConfigFile::Error);
}

BOOST_AUTO_TEST_CASE(BadListen)
{
  const std::string CONFIG = R"CONFIG(
    face_system
    {
      udp
      {
        listen hello
      }
    }
  )CONFIG";

  BOOST_CHECK_THROW(parseConfig(CONFIG, true), ConfigFile::Error);
  BOOST_CHECK_THROW(parseConfig(CONFIG, false), ConfigFile::Error);
}

BOOST_AUTO_TEST_CASE(BadPort)
{
  // not a number
  const std::string CONFIG1 = R"CONFIG(
    face_system
    {
      udp
      {
        port hello
      }
    }
  )CONFIG";

  BOOST_CHECK_THROW(parseConfig(CONFIG1, true), ConfigFile::Error);</b></font>
  BOOST_CHECK_THROW(parseConfig(CONFIG1, false), ConfigFile::Error);

  // negative number
  const std::string CONFIG2 = R"CONFIG(
    face_system
    {
      udp
      {
        port -1
      }
    }
  )CONFIG";

  BOOST_CHECK_THROW(parseConfig(CONFIG2, true), ConfigFile::Error);
  BOOST_CHECK_THROW(parseConfig(CONFIG2, false), ConfigFile::Error);

  // out of range
  const std::string CONFIG3 = R"CONFIG(
    face_system
    {
      udp
      {
        port 65536
      }
    }
  )CONFIG";

  BOOST_CHECK_THROW(parseConfig(CONFIG3, true), ConfigFile::Error);
  BOOST_CHECK_THROW(parseConfig(CONFIG3, false), ConfigFile::Error);
}

BOOST_AUTO_TEST_CASE(BadIdleTimeout)
{
  // not a number
  const std::string CONFIG1 = R"CONFIG(
    face_system
    {
      udp
      {
        idle_timeout hello
      }
    }
  )CONFIG";

  BOOST_CHECK_THROW(parseConfig(CONFIG1, true), ConfigFile::Error);
  BOOST_CHECK_THROW(parseConfig(CONFIG1, false), ConfigFile::Error);

  // negative number
  const std::string CONFIG2 = R"CONFIG(
    face_system
    {
      udp
      {
        idle_timeout -15
      }
    }
  )CONFIG";

  BOOST_CHECK_THROW(parseConfig(CONFIG2, true), ConfigFile::Error);
  BOOST_CHECK_THROW(parseConfig(CONFIG2, false), ConfigFile::Error);
}

BOOST_AUTO_TEST_CASE(BadMtu)
{
  // not a number
  const std::string CONFIG1 = R"CONFIG(
    face_system
    {
      udp
      {
        unicast_mtu hello
      }
    }
  )CONFIG";

  BOOST_CHECK_THROW(parseConfig(CONFIG1, true), ConfigFile::Error);
  BOOST_CHECK_THROW(parseConfig(CONFIG1, false), ConfigFile::Error);

  // underflow
  const std::string CONFIG2 = R"CONFIG(
    face_system
    {
      udp
      {
        unicast_mtu 63
      }
    }
  )CONFIG";

  BOOST_CHECK_THROW(parseConfig(CONFIG2, true), ConfigFile::Error);
  BOOST_CHECK_THROW(parseConfig(CONFIG2, false), ConfigFile::Error);

  // underflow
  const std::string CONFIG3 = R"CONFIG(
    face_system
    {
      udp
      {
        unicast_mtu 8801
      }
    }
  )CONFIG";
<a name="1"></a>
  BOOST_CHECK_THROW(parseConfig(CONFIG3, true), ConfigFile::Error);
  BOOST_CHECK_THROW(parseConfig(CONFIG3, false), ConfigFile::Error);
<font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}

BOOST_AUTO_TEST_CASE(BadMcast)
{
  const std::string CONFIG = R"CONFIG(
    face_system
    {
      udp
      {
        mcast hello
      }
    }
  )CONFIG";

  BOOST_CHECK_THROW(parseConfig(CONFIG, true), ConfigFile::Error);
  BOOST_CHECK_THROW(parseConfig(CONFIG, false), ConfigFile::Error);
}

BOOST_AUTO_TEST_CASE(BadMcastGroupV4)
{
  // not an address
  const std::string CONFIG1 = R"CONFIG(
    face_system
    {
      udp
      {
        mcast_group hello
      }
    }
  )CONFIG";

  BOOST_CHECK_THROW(parseConfig(CONFIG1, true), ConfigFile::Error);
  BOOST_CHECK_THROW(parseConfig(CONFIG1, false), ConfigFile::Error);</b></font>

  // non-multicast address
  const std::string CONFIG2 = R"CONFIG(
    face_system
    {
      udp
      {
        mcast_group 10.0.0.1
      }
    }
  )CONFIG";

  BOOST_CHECK_THROW(parseConfig(CONFIG2, true), ConfigFile::Error);
  BOOST_CHECK_THROW(parseConfig(CONFIG2, false), ConfigFile::Error);

  // wrong address family
  const std::string CONFIG3 = R"CONFIG(
    face_system
    {
      udp
      {
        mcast_group ff02::1234
      }
    }
  )CONFIG";

  BOOST_CHECK_THROW(parseConfig(CONFIG3, true), ConfigFile::Error);
  BOOST_CHECK_THROW(parseConfig(CONFIG3, false), ConfigFile::Error);
}

BOOST_AUTO_TEST_CASE(BadMcastGroupV6)
{
  // not an address
  const std::string CONFIG1 = R"CONFIG(
    face_system
    {
      udp
      {
        mcast_group_v6 foo
      }
    }
  )CONFIG";

  BOOST_CHECK_THROW(parseConfig(CONFIG1, true), ConfigFile::Error);
  BOOST_CHECK_THROW(parseConfig(CONFIG1, false), ConfigFile::Error);

  // non-multicast address
  const std::string CONFIG2 = R"CONFIG(
    face_system
    {
      udp
      {
        mcast_group_v6 fe80::1234
      }
    }
  )CONFIG";

  BOOST_CHECK_THROW(parseConfig(CONFIG2, true), ConfigFile::Error);
  BOOST_CHECK_THROW(parseConfig(CONFIG2, false), ConfigFile::Error);

  // wrong address family
  const std::string CONFIG3 = R"CONFIG(
    face_system
    {
      udp
      {
        mcast_group_v6 224.0.23.170
      }
    }
  )CONFIG";

  BOOST_CHECK_THROW(parseConfig(CONFIG3, true), ConfigFile::Error);
  BOOST_CHECK_THROW(parseConfig(CONFIG3, false), ConfigFile::Error);
}

BOOST_AUTO_TEST_CASE(BadMcastPortV4)
{
  const std::string CONFIG1 = R"CONFIG(
    face_system
    {
      udp
      {
        mcast_port hey
      }
    }
  )CONFIG";

  BOOST_CHECK_THROW(parseConfig(CONFIG1, true), ConfigFile::Error);
  BOOST_CHECK_THROW(parseConfig(CONFIG1, false), ConfigFile::Error);

  const std::string CONFIG2 = R"CONFIG(
    face_system
    {
      udp
      {
        mcast_port 99999
      }
    }
  )CONFIG";

  BOOST_CHECK_THROW(parseConfig(CONFIG2, true), ConfigFile::Error);
  BOOST_CHECK_THROW(parseConfig(CONFIG2, false), ConfigFile::Error);
}

BOOST_AUTO_TEST_CASE(BadMcastPortV6)
{
  const std::string CONFIG1 = R"CONFIG(
    face_system
    {
      udp
      {
        mcast_port_v6 bar
      }
    }
  )CONFIG";

  BOOST_CHECK_THROW(parseConfig(CONFIG1, true), ConfigFile::Error);
  BOOST_CHECK_THROW(parseConfig(CONFIG1, false), ConfigFile::Error);

  const std::string CONFIG2 = R"CONFIG(
    face_system
    {
      udp
      {
        mcast_port_v6 99999
      }
    }
  )CONFIG";

  BOOST_CHECK_THROW(parseConfig(CONFIG2, true), ConfigFile::Error);
  BOOST_CHECK_THROW(parseConfig(CONFIG2, false), ConfigFile::Error);
}

BOOST_AUTO_TEST_CASE(UnknownOption)
{
  const std::string CONFIG = R"CONFIG(
    face_system
    {
      udp
      {
        hello
      }
    }
  )CONFIG";

  BOOST_CHECK_THROW(parseConfig(CONFIG, true), ConfigFile::Error);
  BOOST_CHECK_THROW(parseConfig(CONFIG, false), ConfigFile::Error);
}

BOOST_AUTO_TEST_SUITE_END() // ProcessConfig

BOOST_AUTO_TEST_CASE(GetChannels)
{
  BOOST_CHECK_EQUAL(factory.getChannels().empty(), true);

  std::set&lt;std::string&gt; expected;
  expected.insert(createChannel("127.0.0.1", 20070)-&gt;getUri().toString());
  expected.insert(createChannel("127.0.0.1", 20071)-&gt;getUri().toString());
  expected.insert(createChannel("::1", 20071)-&gt;getUri().toString());
  checkChannelListEqual(factory, expected);
}

BOOST_FIXTURE_TEST_CASE(CreateChannel, UdpFactoryMcastFixture)
{
  auto channel1 = createChannel("127.0.0.1", 20070);
  auto channel1a = createChannel("127.0.0.1", 20070);
  BOOST_CHECK_EQUAL(channel1, channel1a);
  BOOST_CHECK_EQUAL(channel1-&gt;getUri().toString(), "udp4://127.0.0.1:20070");

  auto channel2 = createChannel("127.0.0.1", 20071);
  BOOST_CHECK_NE(channel1, channel2);

  auto channel3 = createChannel("::1", 20071);
  BOOST_CHECK_NE(channel2, channel3);
  BOOST_CHECK_EQUAL(channel3-&gt;getUri().toString(), "udp6://[::1]:20071");

#ifdef __linux__
  // need superuser privileges to create multicast faces on Linux
  SKIP_IF_NOT_SUPERUSER();
#endif // __linux__

  // createChannel with a local endpoint that has already been allocated to a UDP multicast face
  if (!netifsV4.empty()) {
    auto mcastFace = createMulticastFace("127.0.0.1", "224.0.0.254", 20072);
    BOOST_CHECK_EXCEPTION(createChannel("127.0.0.1", 20072), UdpFactory::Error,
                          [] (const UdpFactory::Error&amp; e) {
                            return strcmp(e.what(),
                                          "Cannot create UDP channel on 127.0.0.1:20072, "
                                          "endpoint already allocated to a UDP multicast face") == 0;
                          });
  }
  if (!netifsV6.empty()) {
    auto mcastFace = createMulticastFace("::1", "ff02::114", 20072);
    BOOST_CHECK_EXCEPTION(createChannel("::1", 20072), UdpFactory::Error,
                          [] (const UdpFactory::Error&amp; e) {
                            return strcmp(e.what(),
                                          "Cannot create UDP channel on [::1]:20072, "
                                          "endpoint already allocated to a UDP multicast face") == 0;
                          });
  }
}

BOOST_FIXTURE_TEST_CASE(CreateMulticastFaceV4, UdpFactoryMcastFixture)
{
#ifdef __linux__
  // need superuser privileges to create multicast faces on Linux
  SKIP_IF_NOT_SUPERUSER();
#endif // __linux__
  SKIP_IF_UDP_MCAST_V4_NETIF_COUNT_LT(1);

  auto multicastFace1  = createMulticastFace("127.0.0.1", "224.0.0.254", 20070);
  auto multicastFace1a = createMulticastFace("127.0.0.1", "224.0.0.254", 20070);
  auto multicastFace2  = createMulticastFace("127.0.0.1", "224.0.0.254", 20030);
  BOOST_CHECK_EQUAL(multicastFace1, multicastFace1a);
  BOOST_CHECK_NE(multicastFace1, multicastFace2);

  auto address = findNonLoopbackAddressForMulticastFace(ndn::net::AddressFamily::V4);
  if (!address.is_unspecified()) {
    auto multicastFace3  = createMulticastFace(address.to_string(), "224.0.0.254", 20070);
    BOOST_CHECK_NE(multicastFace1, multicastFace3);
    BOOST_CHECK_NE(multicastFace2, multicastFace3);
  }

  // create with a local endpoint already used by a channel
  auto channel = createChannel("127.0.0.1", 20071);
  BOOST_CHECK_EXCEPTION(createMulticastFace("127.0.0.1", "224.0.0.254", 20071), UdpFactory::Error,
                        [] (const UdpFactory::Error&amp; e) {
                          return strcmp(e.what(),
                                        "Cannot create UDP multicast face on 127.0.0.1:20071, "
                                        "endpoint already allocated to a UDP channel") == 0;
                        });

  // create with a local endpoint already used by a multicast face on a different multicast group
  BOOST_CHECK_EXCEPTION(createMulticastFace("127.0.0.1", "224.0.0.42", 20070), UdpFactory::Error,
                        [] (const UdpFactory::Error&amp; e) {
                          return strcmp(e.what(),
                                        "Cannot create UDP multicast face on 127.0.0.1:20070, "
                                        "endpoint already allocated to a different UDP multicast face") == 0;
                        });
}

BOOST_FIXTURE_TEST_CASE(CreateMulticastFaceV6, UdpFactoryMcastFixture)
{
#ifdef __linux__
  // need superuser privileges to create multicast faces on Linux
  SKIP_IF_NOT_SUPERUSER();
#endif // __linux__
  SKIP_IF_UDP_MCAST_V6_NETIF_COUNT_LT(1);

  auto multicastFace1  = createMulticastFace("::1", "ff02::114", 20070);
  auto multicastFace1a = createMulticastFace("::1", "ff02::114", 20070);
  auto multicastFace2  = createMulticastFace("::1", "ff02::114", 20030);
  BOOST_CHECK_EQUAL(multicastFace1, multicastFace1a);
  BOOST_CHECK_NE(multicastFace1, multicastFace2);

  auto address = findNonLoopbackAddressForMulticastFace(ndn::net::AddressFamily::V6);
  if (!address.is_unspecified()) {
    auto multicastFace3  = createMulticastFace(address.to_string(), "ff02::114", 20070);
    BOOST_CHECK_NE(multicastFace1, multicastFace3);
    BOOST_CHECK_NE(multicastFace2, multicastFace3);
  }

  // create with a local endpoint already used by a channel
  auto channel = createChannel("::1", 20071);
  BOOST_CHECK_EXCEPTION(createMulticastFace("::1", "ff02::114", 20071), UdpFactory::Error,
                        [] (const UdpFactory::Error&amp; e) {
                          return strcmp(e.what(),
                                        "Cannot create UDP multicast face on [::1]:20071, "
                                        "endpoint already allocated to a UDP channel") == 0;
                        });

  // create with a local endpoint already used by a multicast face on a different multicast group
  BOOST_CHECK_EXCEPTION(createMulticastFace("::1", "ff02::42", 20070), UdpFactory::Error,
                        [] (const UdpFactory::Error&amp; e) {
                          return strcmp(e.what(),
                                        "Cannot create UDP multicast face on [::1]:20070, "
                                        "endpoint already allocated to a different UDP multicast face") == 0;
                        });
}

BOOST_AUTO_TEST_CASE(CreateFace)
{
  createFace(factory,
             FaceUri("udp4://127.0.0.1:6363"),
             {},
             {ndn::nfd::FACE_PERSISTENCY_PERSISTENT, {}, {}, {}, false, false, false},
             {CreateFaceExpectedResult::FAILURE, 504, "No channels available to connect"});

  createChannel("127.0.0.1", 20071);

  createFace(factory,
             FaceUri("udp4://127.0.0.1:6363"),
             {},
             {ndn::nfd::FACE_PERSISTENCY_PERSISTENT, {}, {}, {}, false, false, false},
             {CreateFaceExpectedResult::SUCCESS, 0, ""});

  createFace(factory,
             FaceUri("udp4://127.0.0.1:6363"),
             {},
             {ndn::nfd::FACE_PERSISTENCY_PERMANENT, {}, {}, {}, false, false, false},
             {CreateFaceExpectedResult::SUCCESS, 0, ""});

  createFace(factory,
             FaceUri("udp4://127.0.0.1:20072"),
             {},
             {ndn::nfd::FACE_PERSISTENCY_PERMANENT, {}, {}, {}, false, false, false},
             {CreateFaceExpectedResult::SUCCESS, 0, ""});

  createFace(factory,
             FaceUri("udp4://127.0.0.1:20073"),
             {},
             {ndn::nfd::FACE_PERSISTENCY_PERMANENT, {}, {}, {}, false, true, false},
             {CreateFaceExpectedResult::SUCCESS, 0, ""});

  createFace(factory,
             FaceUri("udp4://127.0.0.1:20073"),
             {},
             {ndn::nfd::FACE_PERSISTENCY_PERMANENT, {}, {}, {}, false, false, true},
             {CreateFaceExpectedResult::SUCCESS, 0, ""});

  createFace(factory,
             FaceUri("udp4://127.0.0.1:20074"),
             {},
             {ndn::nfd::FACE_PERSISTENCY_PERMANENT, {}, {}, 1000, false, false, false},
             {CreateFaceExpectedResult::SUCCESS, 0, ""});
}

BOOST_AUTO_TEST_CASE(UnsupportedCreateFace)
{
  createChannel("127.0.0.1", 20071);

  createFace(factory,
             FaceUri("udp4://127.0.0.1:20072"),
             FaceUri("udp4://127.0.0.1:20071"),
             {ndn::nfd::FACE_PERSISTENCY_PERSISTENT, {}, {}, {}, false, false, false},
             {CreateFaceExpectedResult::FAILURE, 406,
              "Unicast UDP faces cannot be created with a LocalUri"});

  createFace(factory,
             FaceUri("udp4://127.0.0.1:20072"),
             {},
             {ndn::nfd::FACE_PERSISTENCY_ON_DEMAND, {}, {}, {}, false, false, false},
             {CreateFaceExpectedResult::FAILURE, 406,
              "Outgoing UDP faces do not support on-demand persistency"});

  createFace(factory,
             FaceUri("udp4://233.252.0.1:23252"),
             {},
             {ndn::nfd::FACE_PERSISTENCY_PERSISTENT, {}, {}, {}, false, false, false},
             {CreateFaceExpectedResult::FAILURE, 406,
              "Cannot create multicast UDP faces"});

  createFace(factory,
             FaceUri("udp4://127.0.0.1:20072"),
             {},
             {ndn::nfd::FACE_PERSISTENCY_PERSISTENT, {}, {}, {}, true, false, false},
             {CreateFaceExpectedResult::FAILURE, 406,
              "Local fields can only be enabled on faces with local scope"});
}

BOOST_AUTO_TEST_SUITE_END() // TestUdpFactory
BOOST_AUTO_TEST_SUITE_END() // Face

} // namespace tests
} // namespace face
} // namespace nfd
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
