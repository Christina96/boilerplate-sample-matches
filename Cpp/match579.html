<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for tables-config-section.t.cpp & udp-factory.t.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for tables-config-section.t.cpp & udp-factory.t.cpp
      </h3>
      <h1 align="center">
        7.2%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>tables-config-section.t.cpp (16.513762%)<TH>udp-factory.t.cpp (4.6753244%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match579-0.html#0',2,'match579-1.html#0',3)" NAME="0">(362-413)<TD><A HREF="javascript:ZweiFrames('match579-0.html#0',2,'match579-1.html#0',3)" NAME="0">(565-615)</A><TD ALIGN=center><FONT COLOR="#ff0000">22</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match579-0.html#1',2,'match579-1.html#1',3)" NAME="1">(125-150)<TD><A HREF="javascript:ZweiFrames('match579-0.html#1',2,'match579-1.html#1',3)" NAME="1">(721-753)</A><TD ALIGN=center><FONT COLOR="#a20000">14</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>tables-config-section.t.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* -*- Mode:C++; c-file-style:&quot;gnu&quot;; indent-tabs-mode:nil; -*- */
/*
 * Copyright (c) 2014-2021,  Regents of the University of California,
 *                           Arizona Board of Regents,
 *                           Colorado State University,
 *                           University Pierre &amp; Marie Curie, Sorbonne University,
 *                           Washington University in St. Louis,
 *                           Beijing Institute of Technology,
 *                           The University of Memphis.
 *
 * This file is part of NFD (Named Data Networking Forwarding Daemon).
 * See AUTHORS.md for complete list of NFD authors and contributors.
 *
 * NFD is free software: you can redistribute it and/or modify it under the terms
 * of the GNU General Public License as published by the Free Software Foundation,
 * either version 3 of the License, or (at your option) any later version.
 *
 * NFD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * NFD, e.g., in COPYING.md file.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

#include &quot;mgmt/tables-config-section.hpp&quot;

#include &quot;fw/best-route-strategy.hpp&quot;
#include &quot;fw/forwarder.hpp&quot;
#include &quot;table/cs-policy-lru.hpp&quot;
#include &quot;table/cs-policy-priority-fifo.hpp&quot;

#include &quot;tests/test-common.hpp&quot;
#include &quot;tests/check-typeid.hpp&quot;
#include &quot;tests/daemon/global-io-fixture.hpp&quot;
#include &quot;tests/daemon/fw/dummy-strategy.hpp&quot;

namespace nfd {
namespace tests {

class TablesConfigSectionFixture : public GlobalIoFixture
{
protected:
  TablesConfigSectionFixture()
  {
    DummyStrategy::registerAs(strategyP);
    DummyStrategy::registerAs(strategyP1);
    // strategyP1Marker is NOT registered
    DummyStrategy::registerAs(strategyQ);
  }

  void
  runConfig(const std::string&amp; config, bool isDryRun)
  {
    ConfigFile cf;
    tablesConfig.setConfigFile(cf);
    cf.parse(config, isDryRun, &quot;dummy-config&quot;);
  }

protected:
  FaceTable faceTable;
  Forwarder forwarder{faceTable};
  Cs&amp; cs{forwarder.getCs()};
  StrategyChoice&amp; strategyChoice{forwarder.getStrategyChoice()};
  NetworkRegionTable&amp; networkRegionTable{forwarder.getNetworkRegionTable()};

  TablesConfigSection tablesConfig{forwarder};

  const Name defaultStrategy = fw::BestRouteStrategy::getStrategyName();
  const Name strategyP = Name(&quot;/tables-config-section-strategy-P&quot;).appendVersion(2);
  const Name strategyP1 = &quot;/tables-config-section-strategy-P/v=1&quot;;
  const Name strategyP1Marker = &quot;/tables-config-section-strategy-P/%FD%01&quot;;
  const Name strategyQ = Name(&quot;/tables-config-section-strategy-Q&quot;).appendVersion(2);
};

BOOST_AUTO_TEST_SUITE(Mgmt)
BOOST_FIXTURE_TEST_SUITE(TestTablesConfigSection, TablesConfigSectionFixture)

BOOST_AUTO_TEST_SUITE(CsMaxPackets)

BOOST_AUTO_TEST_CASE(NoSection)
{
  const size_t initialLimit = cs.getLimit();

  tablesConfig.ensureConfigured();
  BOOST_CHECK_NE(cs.getLimit(), initialLimit);
}

BOOST_AUTO_TEST_CASE(Default)
{
  const std::string CONFIG = R&quot;CONFIG(
    tables
    {
    }
  )CONFIG&quot;;

  const size_t initialLimit = cs.getLimit();

  BOOST_REQUIRE_NO_THROW(runConfig(CONFIG, true));
  BOOST_CHECK_EQUAL(cs.getLimit(), initialLimit);

  BOOST_REQUIRE_NO_THROW(runConfig(CONFIG, false));
  BOOST_CHECK_NE(cs.getLimit(), initialLimit);
}

BOOST_AUTO_TEST_CASE(Valid)
{
  const std::string CONFIG = R&quot;CONFIG(
    tables
    {
      cs_max_packets 101
    }
  )CONFIG&quot;;

  BOOST_REQUIRE_NE(cs.getLimit(), 101);

  BOOST_REQUIRE_NO_THROW(runConfig(CONFIG, true));
  BOOST_CHECK_NE(cs.getLimit(), 101);

  BOOST_REQUIRE_NO_THROW(runConfig(CONFIG, false));
  BOOST_CHECK_EQUAL(cs.getLimit(), 101);
<A NAME="1"></A>
  tablesConfig.ensureConfigured();
  BOOST_CHECK_EQUAL(cs.getLimit(), 101);
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match579-1.html#1',3,'match579-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>}

BOOST_AUTO_TEST_CASE(MissingValue)
{
  const std::string CONFIG = R&quot;CONFIG(
    tables
    {
      cs_max_packets
    }
  )CONFIG&quot;;

  BOOST_CHECK_THROW(runConfig(CONFIG, true), ConfigFile::Error);
  BOOST_CHECK_THROW(runConfig(CONFIG, false), ConfigFile::Error);
}

BOOST_AUTO_TEST_CASE(InvalidValue)
{
  const std::string CONFIG = R&quot;CONFIG(
    tables
    {
      cs_max_packets invalid
    }
  )CONFIG&quot;;

  BOOST_CHECK_THROW(runConfig(CONFIG, true), ConfigFile::Error);
  BOOST_CHECK_THROW(runConfig(CONFIG, false), ConfigFile::Error);</B></FONT>
}

BOOST_AUTO_TEST_SUITE_END() // CsMaxPackets

BOOST_AUTO_TEST_SUITE(CsPolicy)

BOOST_AUTO_TEST_CASE(Default)
{
  const std::string CONFIG = R&quot;CONFIG(
    tables
    {
    }
  )CONFIG&quot;;

  runConfig(CONFIG, false);
  cs::Policy* currentPolicy = cs.getPolicy();
  NFD_CHECK_TYPEID_EQUAL(*currentPolicy, cs::LruPolicy);
}

BOOST_AUTO_TEST_CASE(Known)
{
  const std::string CONFIG = R&quot;CONFIG(
    tables
    {
      cs_policy priority_fifo
    }
  )CONFIG&quot;;

  runConfig(CONFIG, true);
  cs::Policy* currentPolicy = cs.getPolicy();
  NFD_CHECK_TYPEID_EQUAL(*currentPolicy, cs::LruPolicy);

  runConfig(CONFIG, false);
  currentPolicy = cs.getPolicy();
  NFD_CHECK_TYPEID_EQUAL(*currentPolicy, cs::PriorityFifoPolicy);
}

BOOST_AUTO_TEST_CASE(Unknown)
{
  const std::string CONFIG = R&quot;CONFIG(
    tables
    {
      cs_policy unknown
    }
  )CONFIG&quot;;

  BOOST_CHECK_THROW(runConfig(CONFIG, true), ConfigFile::Error);
  BOOST_CHECK_THROW(runConfig(CONFIG, false), ConfigFile::Error);
}

BOOST_AUTO_TEST_SUITE_END() // CsPolicy

class CsUnsolicitedPolicyFixture : public TablesConfigSectionFixture
{
protected:
  CsUnsolicitedPolicyFixture()
  {
    forwarder.setUnsolicitedDataPolicy(make_unique&lt;fw::AdmitNetworkUnsolicitedDataPolicy&gt;());
  }
};

BOOST_FIXTURE_TEST_SUITE(CsUnsolicitedPolicy, CsUnsolicitedPolicyFixture)

BOOST_AUTO_TEST_CASE(NoSection)
{
  tablesConfig.ensureConfigured();

  auto* currentPolicy = &amp;forwarder.getUnsolicitedDataPolicy();
  NFD_CHECK_TYPEID_EQUAL(*currentPolicy, fw::DefaultUnsolicitedDataPolicy);
}

BOOST_AUTO_TEST_CASE(Default)
{
  const std::string CONFIG = R&quot;CONFIG(
    tables
    {
    }
  )CONFIG&quot;;

  BOOST_REQUIRE_NO_THROW(runConfig(CONFIG, true));
  auto* currentPolicy = &amp;forwarder.getUnsolicitedDataPolicy();
  NFD_CHECK_TYPEID_NE(*currentPolicy, fw::DefaultUnsolicitedDataPolicy);

  BOOST_REQUIRE_NO_THROW(runConfig(CONFIG, false));
  currentPolicy = &amp;forwarder.getUnsolicitedDataPolicy();
  NFD_CHECK_TYPEID_EQUAL(*currentPolicy, fw::DefaultUnsolicitedDataPolicy);
}

BOOST_AUTO_TEST_CASE(Known)
{
  const std::string CONFIG = R&quot;CONFIG(
    tables
    {
      cs_unsolicited_policy admit-all
    }
  )CONFIG&quot;;

  BOOST_REQUIRE_NO_THROW(runConfig(CONFIG, true));
  auto* currentPolicy = &amp;forwarder.getUnsolicitedDataPolicy();
  NFD_CHECK_TYPEID_NE(*currentPolicy, fw::AdmitAllUnsolicitedDataPolicy);

  BOOST_REQUIRE_NO_THROW(runConfig(CONFIG, false));
  currentPolicy = &amp;forwarder.getUnsolicitedDataPolicy();
  NFD_CHECK_TYPEID_EQUAL(*currentPolicy, fw::AdmitAllUnsolicitedDataPolicy);
}

BOOST_AUTO_TEST_CASE(Unknown)
{
  const std::string CONFIG = R&quot;CONFIG(
    tables
    {
      cs_unsolicited_policy unknown
    }
  )CONFIG&quot;;

  BOOST_CHECK_THROW(runConfig(CONFIG, true), ConfigFile::Error);
  BOOST_CHECK_THROW(runConfig(CONFIG, false), ConfigFile::Error);
}

BOOST_AUTO_TEST_SUITE_END() // CsUnsolicitedPolicy

BOOST_AUTO_TEST_SUITE(StrategyChoice)

BOOST_AUTO_TEST_CASE(Unversioned)
{
  const std::string CONFIG = R&quot;CONFIG(
    tables
    {
      strategy_choice
      {
        / /tables-config-section-strategy-P
        /a /tables-config-section-strategy-Q
      }
    }
  )CONFIG&quot;;

  BOOST_REQUIRE_NO_THROW(runConfig(CONFIG, true));
  {
    fw::Strategy&amp; rootStrategy = strategyChoice.findEffectiveStrategy(&quot;/&quot;);
    BOOST_CHECK_EQUAL(rootStrategy.getInstanceName(), defaultStrategy);

    fw::Strategy&amp; aStrategy = strategyChoice.findEffectiveStrategy(&quot;/a&quot;);
    BOOST_CHECK_EQUAL(aStrategy.getInstanceName(), defaultStrategy);
  }

  BOOST_REQUIRE_NO_THROW(runConfig(CONFIG, false));
  {
    fw::Strategy&amp; rootStrategy = strategyChoice.findEffectiveStrategy(&quot;/&quot;);
    BOOST_CHECK_EQUAL(rootStrategy.getInstanceName(), strategyP.getPrefix(-1));
    NFD_CHECK_TYPEID_EQUAL(rootStrategy, DummyStrategy);

    fw::Strategy&amp; aStrategy = strategyChoice.findEffectiveStrategy(&quot;/a&quot;);
    BOOST_CHECK_EQUAL(aStrategy.getInstanceName(), strategyQ.getPrefix(-1));
    NFD_CHECK_TYPEID_EQUAL(aStrategy, DummyStrategy);
  }
}

BOOST_AUTO_TEST_CASE(Versioned)
{
  const std::string CONFIG = R&quot;CONFIG(
    tables
    {
      strategy_choice
      {
        /test/latest /tables-config-section-strategy-P
        /test/old /tables-config-section-strategy-P/v=1
        /test/marker /tables-config-section-strategy-P/%FD%01
      }
    }
  )CONFIG&quot;;

  BOOST_REQUIRE_NO_THROW(runConfig(CONFIG, true));
  {
    fw::Strategy&amp; testLatestStrategy = strategyChoice.findEffectiveStrategy(&quot;/test/latest&quot;);
    BOOST_CHECK_EQUAL(testLatestStrategy.getInstanceName(), defaultStrategy);

    fw::Strategy&amp; testOldStrategy = strategyChoice.findEffectiveStrategy(&quot;/test/old&quot;);
    BOOST_CHECK_EQUAL(testOldStrategy.getInstanceName(), defaultStrategy);

    fw::Strategy&amp; testMarkerStrategy = strategyChoice.findEffectiveStrategy(&quot;/test/marker&quot;);
    BOOST_CHECK_EQUAL(testMarkerStrategy.getInstanceName(), defaultStrategy);
  }

  BOOST_REQUIRE_NO_THROW(runConfig(CONFIG, false));
  {
    fw::Strategy&amp; testLatestStrategy = strategyChoice.findEffectiveStrategy(&quot;/test/latest&quot;);
    BOOST_CHECK_EQUAL(testLatestStrategy.getInstanceName(), strategyP.getPrefix(-1));
    NFD_CHECK_TYPEID_EQUAL(testLatestStrategy, DummyStrategy);

    fw::Strategy&amp; testOldStrategy = strategyChoice.findEffectiveStrategy(&quot;/test/old&quot;);
    BOOST_CHECK_EQUAL(testOldStrategy.getInstanceName(), strategyP1);
    NFD_CHECK_TYPEID_EQUAL(testOldStrategy, DummyStrategy);

    fw::Strategy&amp; testMarkerStrategy = strategyChoice.findEffectiveStrategy(&quot;/test/marker&quot;);
    BOOST_CHECK_EQUAL(testMarkerStrategy.getInstanceName(), strategyP1Marker);
    NFD_CHECK_TYPEID_EQUAL(testMarkerStrategy, DummyStrategy);
  }
}

BOOST_AUTO_TEST_CASE(NonExisting)
{
  const std::string CONFIG = R&quot;CONFIG(
    tables
    {
      strategy_choice
      {
        / /localhost/nfd/strategy/test-doesnotexist
      }
<A NAME="0"></A>    }
  )CONFIG&quot;;

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match579-1.html#0',3,'match579-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>  BOOST_CHECK_THROW(runConfig(CONFIG, true), ConfigFile::Error);
  BOOST_CHECK_THROW(runConfig(CONFIG, false), ConfigFile::Error);
}

BOOST_AUTO_TEST_CASE(MissingPrefix)
{
  const std::string CONFIG = R&quot;CONFIG(
    tables
    {
      strategy_choice
      {
        /tables-config-section-strategy-P
      }
    }
  )CONFIG&quot;;

  BOOST_CHECK_THROW(runConfig(CONFIG, true), ConfigFile::Error);
  BOOST_CHECK_THROW(runConfig(CONFIG, false), ConfigFile::Error);
}

BOOST_AUTO_TEST_CASE(Duplicate)
{
  const std::string CONFIG = R&quot;CONFIG(
    tables
    {
      strategy_choice
      {
        / /tables-config-section-strategy-P
        /a /tables-config-section-strategy-Q
        / /tables-config-section-strategy-Q
      }
    }
  )CONFIG&quot;;

  BOOST_CHECK_THROW(runConfig(CONFIG, true), ConfigFile::Error);
  BOOST_CHECK_THROW(runConfig(CONFIG, false), ConfigFile::Error);
}

BOOST_AUTO_TEST_CASE(UnacceptableParameters)
{
  const std::string CONFIG = R&quot;CONFIG(
    tables
    {
      strategy_choice
      {
        / /localhost/nfd/strategy/best-route/v=5/param
      }
    }
  )CONFIG&quot;;

  BOOST_CHECK_NO_THROW(runConfig(CONFIG, true));
  BOOST_CHECK_THROW(runConfig(CONFIG, false), ConfigFile::Error);</B></FONT>
}

BOOST_AUTO_TEST_SUITE_END() // StrategyChoice

BOOST_AUTO_TEST_SUITE(NetworkRegion)

BOOST_AUTO_TEST_CASE(Basic)
{
  const std::string CONFIG = R&quot;CONFIG(
    tables
    {
      network_region
      {
        /test/regionA
        /test/regionB/component
      }
    }
  )CONFIG&quot;;

  BOOST_REQUIRE_NO_THROW(runConfig(CONFIG, true));
  BOOST_CHECK_EQUAL(networkRegionTable.size(), 0);

  BOOST_CHECK(networkRegionTable.find(&quot;/test/regionA&quot;) == networkRegionTable.end());
  BOOST_CHECK(networkRegionTable.find(&quot;/test/regionB/component&quot;) == networkRegionTable.end());

  BOOST_REQUIRE_NO_THROW(runConfig(CONFIG, false));
  BOOST_CHECK_EQUAL(networkRegionTable.size(), 2);

  BOOST_CHECK(networkRegionTable.find(&quot;/test/regionA&quot;) != networkRegionTable.end());
  BOOST_CHECK(networkRegionTable.find(&quot;/test/regionB/component&quot;) != networkRegionTable.end());
}

BOOST_AUTO_TEST_CASE(Reload)
{
  const std::string CONFIG1 = R&quot;CONFIG(
    tables
    {
      network_region
      {
        /some/region
      }
    }
  )CONFIG&quot;;

  BOOST_REQUIRE_NO_THROW(runConfig(CONFIG1, true));
  BOOST_CHECK(networkRegionTable.find(&quot;/some/region&quot;) == networkRegionTable.end());

  BOOST_REQUIRE_NO_THROW(runConfig(CONFIG1, false));
  BOOST_CHECK(networkRegionTable.find(&quot;/some/region&quot;) != networkRegionTable.end());

  const std::string CONFIG2 = R&quot;CONFIG(
    tables
    {
      network_region
      {
        /different/region
      }
    }
  )CONFIG&quot;;

  BOOST_REQUIRE_NO_THROW(runConfig(CONFIG2, true));
  BOOST_CHECK(networkRegionTable.find(&quot;/some/region&quot;) != networkRegionTable.end());
  BOOST_CHECK(networkRegionTable.find(&quot;/different/region&quot;) == networkRegionTable.end());

  BOOST_REQUIRE_NO_THROW(runConfig(CONFIG2, false));
  BOOST_CHECK(networkRegionTable.find(&quot;/some/region&quot;) == networkRegionTable.end());
  BOOST_CHECK(networkRegionTable.find(&quot;/different/region&quot;) != networkRegionTable.end());
}

BOOST_AUTO_TEST_SUITE_END() // NetworkRegion

BOOST_AUTO_TEST_SUITE_END() // TestTablesConfigSection
BOOST_AUTO_TEST_SUITE_END() // Mgmt

} // namespace tests
} // namespace nfd
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>udp-factory.t.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
/* -*- Mode:C++; c-file-style:&quot;gnu&quot;; indent-tabs-mode:nil; -*- */
/*
 * Copyright (c) 2014-2021,  Regents of the University of California,
 *                           Arizona Board of Regents,
 *                           Colorado State University,
 *                           University Pierre &amp; Marie Curie, Sorbonne University,
 *                           Washington University in St. Louis,
 *                           Beijing Institute of Technology,
 *                           The University of Memphis.
 *
 * This file is part of NFD (Named Data Networking Forwarding Daemon).
 * See AUTHORS.md for complete list of NFD authors and contributors.
 *
 * NFD is free software: you can redistribute it and/or modify it under the terms
 * of the GNU General Public License as published by the Free Software Foundation,
 * either version 3 of the License, or (at your option) any later version.
 *
 * NFD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * NFD, e.g., in COPYING.md file.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

#include &quot;face/udp-factory.hpp&quot;

#include &quot;face-system-fixture.hpp&quot;
#include &quot;factory-test-common.hpp&quot;

#include &lt;boost/algorithm/string/replace.hpp&gt;

namespace nfd {
namespace face {
namespace tests {

class UdpFactoryFixture : public FaceSystemFactoryFixture&lt;UdpFactory&gt;
{
protected:
  shared_ptr&lt;UdpChannel&gt;
  createChannel(const std::string&amp; localIp, uint16_t localPort)
  {
    udp::Endpoint endpoint(boost::asio::ip::address::from_string(localIp), localPort);
    return factory.createChannel(endpoint, 5_min);
  }
};

class UdpFactoryMcastFixture : public UdpFactoryFixture
{
protected:
  UdpFactoryMcastFixture()
  {
    for (const auto&amp; netif : collectNetworkInterfaces()) {
      // same filtering logic as UdpFactory::applyMcastConfigToNetif()
      if (netif-&gt;isUp() &amp;&amp; !netif-&gt;isLoopback() &amp;&amp; netif-&gt;canMulticast()) {
        bool hasValidIpAddress = false;
        if (hasAddressFamily(*netif, ndn::net::AddressFamily::V4)) {
          hasValidIpAddress = true;
          netifsV4.push_back(netif);
        }
        if (hasAddressFamily(*netif, ndn::net::AddressFamily::V6)) {
          hasValidIpAddress = true;
          netifsV6.push_back(netif);
        }
        if (hasValidIpAddress) {
          netifs.push_back(netif);
        }
      }
    }
    this-&gt;copyRealNetifsToNetmon();
  }

  shared_ptr&lt;Face&gt;
  createMulticastFace(const std::string&amp; localIp, const std::string&amp; mcastIp, uint16_t mcastPort)
  {
    auto localAddress = boost::asio::ip::address::from_string(localIp);
    udp::Endpoint mcastEndpoint(boost::asio::ip::address::from_string(mcastIp), mcastPort);

    if (localAddress.is_v4()) {
      BOOST_ASSERT(!netifsV4.empty());
      return factory.createMulticastFace(netifsV4.front(), localAddress, mcastEndpoint);
    }
    else {
      BOOST_ASSERT(!netifsV6.empty());
      return factory.createMulticastFace(netifsV6.front(), localAddress, mcastEndpoint);
    }
  }

  /** \brief returns a non-loopback IP address suitable for the creation of a UDP multicast face
   */
  boost::asio::ip::address
  findNonLoopbackAddressForMulticastFace(ndn::net::AddressFamily af) const
  {
    const auto&amp; netifList = af == ndn::net::AddressFamily::V4 ? netifsV4 : netifsV6;
    for (const auto&amp; netif : netifList) {
      for (const auto&amp; a : netif-&gt;getNetworkAddresses()) {
        if (a.getFamily() == af &amp;&amp; !a.getIp().is_loopback())
          return a.getIp();
      }
    }
    return {};
  }

  std::vector&lt;const Face*&gt;
  listUdp4McastFaces(ndn::nfd::LinkType linkType = ndn::nfd::LINK_TYPE_MULTI_ACCESS) const
  {
    return this-&gt;listFacesByScheme(&quot;udp4&quot;, linkType);
  }

  std::vector&lt;const Face*&gt;
  listUdp6McastFaces(ndn::nfd::LinkType linkType = ndn::nfd::LINK_TYPE_MULTI_ACCESS) const
  {
    return this-&gt;listFacesByScheme(&quot;udp6&quot;, linkType);
  }

  /** \brief determine whether \p netif has at least one IP address of the given family
   */
  static bool
  hasAddressFamily(const NetworkInterface&amp; netif, ndn::net::AddressFamily af)
  {
    return std::any_of(netif.getNetworkAddresses().begin(), netif.getNetworkAddresses().end(),
                       [af] (const NetworkAddress&amp; a) { return a.getFamily() == af; });
  }

  /** \brief determine whether a UDP multicast face is created on \p netif
   */
  static bool
  isFaceOnNetif(const Face&amp; face, const NetworkInterface&amp; netif)
  {
    auto ip = boost::asio::ip::address::from_string(face.getLocalUri().getHost());
    return std::any_of(netif.getNetworkAddresses().begin(), netif.getNetworkAddresses().end(),
                       [ip] (const NetworkAddress&amp; a) { return a.getIp() == ip; });
  }

protected:
  /** \brief MulticastUdpTransport-capable network interfaces (IPv4 + IPv6)
   *
   *  This should be used in test cases that do not depend on a specific address family
   */
  std::vector&lt;shared_ptr&lt;const NetworkInterface&gt;&gt; netifs;

  /** \brief MulticastUdpTransport-capable network interfaces (IPv4 only)
   */
  std::vector&lt;shared_ptr&lt;const NetworkInterface&gt;&gt; netifsV4;

  /** \brief MulticastUdpTransport-capable network interfaces (IPv6 only)
   */
  std::vector&lt;shared_ptr&lt;const NetworkInterface&gt;&gt; netifsV6;
};

#define SKIP_IF_UDP_MCAST_NETIF_COUNT_LT(n) \
  do { \
    if (this-&gt;netifs.size() &lt; (n)) { \
      BOOST_WARN_MESSAGE(false, &quot;skipping assertions that require &quot; #n \
                                &quot; or more MulticastUdpTransport-capable network interfaces&quot;); \
      return; \
    } \
  } while (false)

#define SKIP_IF_UDP_MCAST_V4_NETIF_COUNT_LT(n) \
  do { \
    if (this-&gt;netifsV4.size() &lt; (n)) { \
      BOOST_WARN_MESSAGE(false, &quot;skipping assertions that require &quot; #n \
                                &quot; or more IPv4 MulticastUdpTransport-capable network interfaces&quot;); \
      return; \
    } \
  } while (false)

#define SKIP_IF_UDP_MCAST_V6_NETIF_COUNT_LT(n) \
  do { \
    if (this-&gt;netifsV6.size() &lt; (n)) { \
      BOOST_WARN_MESSAGE(false, &quot;skipping assertions that require &quot; #n \
                                &quot; or more IPv6 MulticastUdpTransport-capable network interfaces&quot;); \
      return; \
    } \
  } while (false)

BOOST_AUTO_TEST_SUITE(Face)
BOOST_FIXTURE_TEST_SUITE(TestUdpFactory, UdpFactoryFixture)

BOOST_AUTO_TEST_SUITE(ProcessConfig)

using nfd::Face;

BOOST_AUTO_TEST_CASE(Defaults)
{
  const std::string CONFIG = R&quot;CONFIG(
    face_system
    {
      udp
    }
  )CONFIG&quot;;

  parseConfig(CONFIG, true);
  parseConfig(CONFIG, false);

  checkChannelListEqual(factory, {&quot;udp4://0.0.0.0:6363&quot;, &quot;udp6://[::]:6363&quot;});
  for (const auto&amp; ch : factory.getChannels()) {
    BOOST_CHECK(ch-&gt;isListening());
    BOOST_CHECK_EQUAL(ch-&gt;getDefaultMtu(), ndn::MAX_NDN_PACKET_SIZE);
  }
}

BOOST_AUTO_TEST_CASE(DisableListen)
{
  const std::string CONFIG = R&quot;CONFIG(
    face_system
    {
      udp
      {
        listen no
        port 7001
        mcast no
      }
    }
  )CONFIG&quot;;

  parseConfig(CONFIG, true);
  parseConfig(CONFIG, false);

  checkChannelListEqual(factory, {&quot;udp4://0.0.0.0:7001&quot;, &quot;udp6://[::]:7001&quot;});
  for (const auto&amp; ch : factory.getChannels()) {
    BOOST_CHECK(!ch-&gt;isListening());
  }
}

BOOST_AUTO_TEST_CASE(DisableV4)
{
  const std::string CONFIG = R&quot;CONFIG(
    face_system
    {
      udp
      {
        port 7001
        enable_v4 no
        enable_v6 yes
        unicast_mtu 1452
        mcast no
      }
    }
  )CONFIG&quot;;

  parseConfig(CONFIG, true);
  parseConfig(CONFIG, false);

  checkChannelListEqual(factory, {&quot;udp6://[::]:7001&quot;});
  for (const auto&amp; ch : factory.getChannels()) {
    BOOST_CHECK_EQUAL(ch-&gt;getDefaultMtu(), 1452);
  }
}

BOOST_AUTO_TEST_CASE(DisableV6)
{
  const std::string CONFIG = R&quot;CONFIG(
    face_system
    {
      udp
      {
        port 7001
        enable_v4 yes
        enable_v6 no
        unicast_mtu 1452
        mcast no
      }
    }
  )CONFIG&quot;;

  parseConfig(CONFIG, true);
  parseConfig(CONFIG, false);

  checkChannelListEqual(factory, {&quot;udp4://0.0.0.0:7001&quot;});
  for (const auto&amp; ch : factory.getChannels()) {
    BOOST_CHECK_EQUAL(ch-&gt;getDefaultMtu(), 1452);
  }
}

BOOST_FIXTURE_TEST_CASE(EnableDisableMcast, UdpFactoryMcastFixture)
{
  const std::string CONFIG_WITH_MCAST = R&quot;CONFIG(
    face_system
    {
      udp
      {
        mcast yes
      }
    }
  )CONFIG&quot;;
  const std::string CONFIG_WITHOUT_MCAST = R&quot;CONFIG(
    face_system
    {
      udp
      {
        mcast no
      }
    }
  )CONFIG&quot;;

  parseConfig(CONFIG_WITHOUT_MCAST, false);
  BOOST_CHECK_EQUAL(this-&gt;listUdp4McastFaces().size(), 0);
  BOOST_CHECK_EQUAL(this-&gt;listUdp6McastFaces().size(), 0);

#ifdef __linux__
  // need superuser privileges to create multicast faces on Linux
  SKIP_IF_NOT_SUPERUSER();
#endif // __linux__

  parseConfig(CONFIG_WITH_MCAST, false);
  g_io.poll();
  BOOST_CHECK_EQUAL(this-&gt;listUdp4McastFaces().size(), netifsV4.size());
  BOOST_CHECK_EQUAL(this-&gt;listUdp6McastFaces().size(), netifsV6.size());

  BOOST_REQUIRE_EQUAL(factory.getChannels().size(), 2);
  for (const auto&amp; face : this-&gt;listUdp4McastFaces()) {
    BOOST_REQUIRE(face-&gt;getChannel().lock());
    BOOST_CHECK_EQUAL(face-&gt;getChannel().lock()-&gt;getUri().getScheme(), &quot;udp4&quot;);
  }

  for (const auto&amp; face : this-&gt;listUdp6McastFaces()) {
    BOOST_REQUIRE(face-&gt;getChannel().lock());
    BOOST_CHECK_EQUAL(face-&gt;getChannel().lock()-&gt;getUri().getScheme(), &quot;udp6&quot;);
  }

  parseConfig(CONFIG_WITHOUT_MCAST, false);
  g_io.poll();
  BOOST_CHECK_EQUAL(this-&gt;listUdp4McastFaces().size(), 0);
  BOOST_CHECK_EQUAL(this-&gt;listUdp6McastFaces().size(), 0);
}

BOOST_FIXTURE_TEST_CASE(McastAdHoc, UdpFactoryMcastFixture)
{
#ifdef __linux__
  // need superuser privileges to create multicast faces on Linux
  SKIP_IF_NOT_SUPERUSER();
#endif // __linux__
  SKIP_IF_UDP_MCAST_NETIF_COUNT_LT(1);

  const std::string CONFIG = R&quot;CONFIG(
    face_system
    {
      udp
      {
        mcast_ad_hoc yes
      }
    }
  )CONFIG&quot;;

  parseConfig(CONFIG, false);
  BOOST_CHECK_EQUAL(this-&gt;listUdp4McastFaces(ndn::nfd::LINK_TYPE_AD_HOC).size(), netifsV4.size());
  BOOST_CHECK_EQUAL(this-&gt;listUdp6McastFaces(ndn::nfd::LINK_TYPE_AD_HOC).size(), netifsV6.size());
}

BOOST_FIXTURE_TEST_CASE(ChangeMcastEndpointV4, UdpFactoryMcastFixture)
{
#ifdef __linux__
  // need superuser privileges to create multicast faces on Linux
  SKIP_IF_NOT_SUPERUSER();
#endif // __linux__
  SKIP_IF_UDP_MCAST_V4_NETIF_COUNT_LT(1);

  const std::string CONFIG1 = R&quot;CONFIG(
    face_system
    {
      udp
      {
        mcast_group 239.66.30.1
        mcast_port 7011
      }
    }
  )CONFIG&quot;;
  const std::string CONFIG2 = R&quot;CONFIG(
    face_system
    {
      udp
      {
        mcast_group 239.66.30.2
        mcast_port 7012
      }
    }
  )CONFIG&quot;;

  parseConfig(CONFIG1, false);
  auto udpMcastFaces = this-&gt;listUdp4McastFaces();
  BOOST_REQUIRE_EQUAL(udpMcastFaces.size(), netifsV4.size());
  BOOST_CHECK_EQUAL(udpMcastFaces.front()-&gt;getRemoteUri(), FaceUri(&quot;udp4://239.66.30.1:7011&quot;));

  parseConfig(CONFIG2, false);
  g_io.poll();
  udpMcastFaces = this-&gt;listUdp4McastFaces();
  BOOST_REQUIRE_EQUAL(udpMcastFaces.size(), netifsV4.size());
  BOOST_CHECK_EQUAL(udpMcastFaces.front()-&gt;getRemoteUri(), FaceUri(&quot;udp4://239.66.30.2:7012&quot;));
}

BOOST_FIXTURE_TEST_CASE(ChangeMcastEndpointV6, UdpFactoryMcastFixture)
{
#ifdef __linux__
  // need superuser privileges to create multicast faces on Linux
  SKIP_IF_NOT_SUPERUSER();
#endif // __linux__
  SKIP_IF_UDP_MCAST_V6_NETIF_COUNT_LT(1);

  const std::string CONFIG1 = R&quot;CONFIG(
    face_system
    {
      udp
      {
        mcast_group_v6 ff02::1101
        mcast_port_v6 7011
      }
    }
  )CONFIG&quot;;
  const std::string CONFIG2 = R&quot;CONFIG(
    face_system
    {
      udp
      {
        mcast_group_v6 ff02::1102
        mcast_port_v6 7012
      }
    }
  )CONFIG&quot;;

  parseConfig(CONFIG1, false);
  auto udpMcastFaces = this-&gt;listUdp6McastFaces();
  BOOST_REQUIRE_EQUAL(udpMcastFaces.size(), netifsV6.size());
  auto expectedAddr = boost::asio::ip::address_v6::from_string(&quot;ff02::1101&quot;);
  expectedAddr.scope_id(netifsV6.front()-&gt;getIndex());
  BOOST_CHECK_EQUAL(udpMcastFaces.front()-&gt;getRemoteUri(), FaceUri(udp::Endpoint(expectedAddr, 7011)));

  parseConfig(CONFIG2, false);
  g_io.poll();
  udpMcastFaces = this-&gt;listUdp6McastFaces();
  BOOST_REQUIRE_EQUAL(udpMcastFaces.size(), netifsV6.size());
  expectedAddr = boost::asio::ip::address_v6::from_string(&quot;ff02::1102&quot;);
  expectedAddr.scope_id(netifsV6.front()-&gt;getIndex());
  BOOST_CHECK_EQUAL(udpMcastFaces.front()-&gt;getRemoteUri(), FaceUri(udp::Endpoint(expectedAddr, 7012)));
}

BOOST_FIXTURE_TEST_CASE(Whitelist, UdpFactoryMcastFixture)
{
#ifdef __linux__
  // need superuser privileges to create multicast faces on Linux
  SKIP_IF_NOT_SUPERUSER();
#endif // __linux__
  SKIP_IF_UDP_MCAST_NETIF_COUNT_LT(1);

  std::string CONFIG = R&quot;CONFIG(
    face_system
    {
      udp
      {
        whitelist
        {
          ifname %ifname
        }
      }
    }
  )CONFIG&quot;;
  boost::replace_first(CONFIG, &quot;%ifname&quot;, netifs.front()-&gt;getName());

  parseConfig(CONFIG, false);

  auto udpMcastFaces = this-&gt;listUdp4McastFaces();
  BOOST_CHECK_LE(udpMcastFaces.size(), 1);
  auto udpMcastFacesV6 = this-&gt;listUdp6McastFaces();
  BOOST_CHECK_LE(udpMcastFacesV6.size(), 1);
  udpMcastFaces.insert(udpMcastFaces.end(), udpMcastFacesV6.begin(), udpMcastFacesV6.end());
  BOOST_CHECK_GE(udpMcastFaces.size(), 1);
  BOOST_CHECK(std::all_of(udpMcastFaces.begin(), udpMcastFaces.end(),
                          [this] (const Face* face) { return isFaceOnNetif(*face, *netifs.front()); }));
}

BOOST_FIXTURE_TEST_CASE(Blacklist, UdpFactoryMcastFixture)
{
#ifdef __linux__
  // need superuser privileges to create multicast faces on Linux
  SKIP_IF_NOT_SUPERUSER();
#endif // __linux__
  SKIP_IF_UDP_MCAST_NETIF_COUNT_LT(1);

  std::string CONFIG = R&quot;CONFIG(
    face_system
    {
      udp
      {
        blacklist
        {
          ifname %ifname
        }
      }
    }
  )CONFIG&quot;;
  boost::replace_first(CONFIG, &quot;%ifname&quot;, netifs.front()-&gt;getName());

  parseConfig(CONFIG, false);

  auto udpMcastFaces = this-&gt;listUdp4McastFaces();
  if (!netifsV4.empty())
    BOOST_CHECK_GE(udpMcastFaces.size(), netifsV4.size() - 1);
  auto udpMcastFacesV6 = this-&gt;listUdp6McastFaces();
  if (!netifsV6.empty())
    BOOST_CHECK_GE(udpMcastFacesV6.size(), netifsV6.size() - 1);
  udpMcastFaces.insert(udpMcastFaces.end(), udpMcastFacesV6.begin(), udpMcastFacesV6.end());
  BOOST_CHECK_LT(udpMcastFaces.size(), netifsV4.size() + netifsV6.size());
  BOOST_CHECK(std::none_of(udpMcastFaces.begin(), udpMcastFaces.end(),
                           [this] (const Face* face) { return isFaceOnNetif(*face, *netifs.front()); }));
}

BOOST_FIXTURE_TEST_CASE(ChangePredicate, UdpFactoryMcastFixture)
{
#ifdef __linux__
  // need superuser privileges to create multicast faces on Linux
  SKIP_IF_NOT_SUPERUSER();
#endif // __linux__
  SKIP_IF_UDP_MCAST_NETIF_COUNT_LT(2);

  std::string CONFIG1 = R&quot;CONFIG(
    face_system
    {
      udp
      {
        whitelist
        {
          ifname %ifname
        }
      }
    }
  )CONFIG&quot;;
  std::string CONFIG2 = CONFIG1;
  boost::replace_first(CONFIG1, &quot;%ifname&quot;, netifs.front()-&gt;getName());
  boost::replace_first(CONFIG2, &quot;%ifname&quot;, netifs.back()-&gt;getName());

  parseConfig(CONFIG1, false);

  auto udpMcastFaces = this-&gt;listUdp4McastFaces();
  auto udpMcastFacesV6 = this-&gt;listUdp6McastFaces();
  udpMcastFaces.insert(udpMcastFaces.end(), udpMcastFacesV6.begin(), udpMcastFacesV6.end());
  BOOST_CHECK_GE(udpMcastFaces.size(), 1);
  BOOST_CHECK(std::all_of(udpMcastFaces.begin(), udpMcastFaces.end(),
                          [this] (const Face* face) { return isFaceOnNetif(*face, *netifs.front()); }));

  parseConfig(CONFIG2, false);
  g_io.poll();

  udpMcastFaces = this-&gt;listUdp4McastFaces();
  udpMcastFacesV6 = this-&gt;listUdp6McastFaces();
  udpMcastFaces.insert(udpMcastFaces.end(), udpMcastFacesV6.begin(), udpMcastFacesV6.end());
  BOOST_CHECK_GE(udpMcastFaces.size(), 1);
  BOOST_CHECK(std::all_of(udpMcastFaces.begin(), udpMcastFaces.end(),
                          [this] (const Face* face) { return isFaceOnNetif(*face, *netifs.back()); }));
}

BOOST_AUTO_TEST_CASE(Omitted)
{
  const std::string CONFIG = R&quot;CONFIG(
    face_system
    {
    }
  )CONFIG&quot;;

  parseConfig(CONFIG, true);
  parseConfig(CONFIG, false);
<A NAME="0"></A>
  BOOST_CHECK_EQUAL(factory.getChannels().size(), 0);
  BOOST_CHECK_EQUAL(this-&gt;listFacesByScheme(&quot;udp4&quot;, ndn::nfd::LINK_TYPE_MULTI_ACCESS).size(), 0);
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match579-0.html#0',2,'match579-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>  BOOST_CHECK_EQUAL(this-&gt;listFacesByScheme(&quot;udp6&quot;, ndn::nfd::LINK_TYPE_MULTI_ACCESS).size(), 0);
}

BOOST_AUTO_TEST_CASE(AllDisabled)
{
  const std::string CONFIG = R&quot;CONFIG(
    face_system
    {
      udp
      {
        enable_v4 no
        enable_v6 no
        mcast no
      }
    }
  )CONFIG&quot;;

  BOOST_CHECK_THROW(parseConfig(CONFIG, true), ConfigFile::Error);
  BOOST_CHECK_THROW(parseConfig(CONFIG, false), ConfigFile::Error);
}

BOOST_AUTO_TEST_CASE(BadListen)
{
  const std::string CONFIG = R&quot;CONFIG(
    face_system
    {
      udp
      {
        listen hello
      }
    }
  )CONFIG&quot;;

  BOOST_CHECK_THROW(parseConfig(CONFIG, true), ConfigFile::Error);
  BOOST_CHECK_THROW(parseConfig(CONFIG, false), ConfigFile::Error);
}

BOOST_AUTO_TEST_CASE(BadPort)
{
  // not a number
  const std::string CONFIG1 = R&quot;CONFIG(
    face_system
    {
      udp
      {
        port hello
      }
    }
  )CONFIG&quot;;

  BOOST_CHECK_THROW(parseConfig(CONFIG1, true), ConfigFile::Error);</B></FONT>
  BOOST_CHECK_THROW(parseConfig(CONFIG1, false), ConfigFile::Error);

  // negative number
  const std::string CONFIG2 = R&quot;CONFIG(
    face_system
    {
      udp
      {
        port -1
      }
    }
  )CONFIG&quot;;

  BOOST_CHECK_THROW(parseConfig(CONFIG2, true), ConfigFile::Error);
  BOOST_CHECK_THROW(parseConfig(CONFIG2, false), ConfigFile::Error);

  // out of range
  const std::string CONFIG3 = R&quot;CONFIG(
    face_system
    {
      udp
      {
        port 65536
      }
    }
  )CONFIG&quot;;

  BOOST_CHECK_THROW(parseConfig(CONFIG3, true), ConfigFile::Error);
  BOOST_CHECK_THROW(parseConfig(CONFIG3, false), ConfigFile::Error);
}

BOOST_AUTO_TEST_CASE(BadIdleTimeout)
{
  // not a number
  const std::string CONFIG1 = R&quot;CONFIG(
    face_system
    {
      udp
      {
        idle_timeout hello
      }
    }
  )CONFIG&quot;;

  BOOST_CHECK_THROW(parseConfig(CONFIG1, true), ConfigFile::Error);
  BOOST_CHECK_THROW(parseConfig(CONFIG1, false), ConfigFile::Error);

  // negative number
  const std::string CONFIG2 = R&quot;CONFIG(
    face_system
    {
      udp
      {
        idle_timeout -15
      }
    }
  )CONFIG&quot;;

  BOOST_CHECK_THROW(parseConfig(CONFIG2, true), ConfigFile::Error);
  BOOST_CHECK_THROW(parseConfig(CONFIG2, false), ConfigFile::Error);
}

BOOST_AUTO_TEST_CASE(BadMtu)
{
  // not a number
  const std::string CONFIG1 = R&quot;CONFIG(
    face_system
    {
      udp
      {
        unicast_mtu hello
      }
    }
  )CONFIG&quot;;

  BOOST_CHECK_THROW(parseConfig(CONFIG1, true), ConfigFile::Error);
  BOOST_CHECK_THROW(parseConfig(CONFIG1, false), ConfigFile::Error);

  // underflow
  const std::string CONFIG2 = R&quot;CONFIG(
    face_system
    {
      udp
      {
        unicast_mtu 63
      }
    }
  )CONFIG&quot;;

  BOOST_CHECK_THROW(parseConfig(CONFIG2, true), ConfigFile::Error);
  BOOST_CHECK_THROW(parseConfig(CONFIG2, false), ConfigFile::Error);

  // underflow
  const std::string CONFIG3 = R&quot;CONFIG(
    face_system
    {
      udp
      {
        unicast_mtu 8801
      }
    }
  )CONFIG&quot;;
<A NAME="1"></A>
  BOOST_CHECK_THROW(parseConfig(CONFIG3, true), ConfigFile::Error);
  BOOST_CHECK_THROW(parseConfig(CONFIG3, false), ConfigFile::Error);
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match579-0.html#1',2,'match579-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>}

BOOST_AUTO_TEST_CASE(BadMcast)
{
  const std::string CONFIG = R&quot;CONFIG(
    face_system
    {
      udp
      {
        mcast hello
      }
    }
  )CONFIG&quot;;

  BOOST_CHECK_THROW(parseConfig(CONFIG, true), ConfigFile::Error);
  BOOST_CHECK_THROW(parseConfig(CONFIG, false), ConfigFile::Error);
}

BOOST_AUTO_TEST_CASE(BadMcastGroupV4)
{
  // not an address
  const std::string CONFIG1 = R&quot;CONFIG(
    face_system
    {
      udp
      {
        mcast_group hello
      }
    }
  )CONFIG&quot;;

  BOOST_CHECK_THROW(parseConfig(CONFIG1, true), ConfigFile::Error);
  BOOST_CHECK_THROW(parseConfig(CONFIG1, false), ConfigFile::Error);</B></FONT>

  // non-multicast address
  const std::string CONFIG2 = R&quot;CONFIG(
    face_system
    {
      udp
      {
        mcast_group 10.0.0.1
      }
    }
  )CONFIG&quot;;

  BOOST_CHECK_THROW(parseConfig(CONFIG2, true), ConfigFile::Error);
  BOOST_CHECK_THROW(parseConfig(CONFIG2, false), ConfigFile::Error);

  // wrong address family
  const std::string CONFIG3 = R&quot;CONFIG(
    face_system
    {
      udp
      {
        mcast_group ff02::1234
      }
    }
  )CONFIG&quot;;

  BOOST_CHECK_THROW(parseConfig(CONFIG3, true), ConfigFile::Error);
  BOOST_CHECK_THROW(parseConfig(CONFIG3, false), ConfigFile::Error);
}

BOOST_AUTO_TEST_CASE(BadMcastGroupV6)
{
  // not an address
  const std::string CONFIG1 = R&quot;CONFIG(
    face_system
    {
      udp
      {
        mcast_group_v6 foo
      }
    }
  )CONFIG&quot;;

  BOOST_CHECK_THROW(parseConfig(CONFIG1, true), ConfigFile::Error);
  BOOST_CHECK_THROW(parseConfig(CONFIG1, false), ConfigFile::Error);

  // non-multicast address
  const std::string CONFIG2 = R&quot;CONFIG(
    face_system
    {
      udp
      {
        mcast_group_v6 fe80::1234
      }
    }
  )CONFIG&quot;;

  BOOST_CHECK_THROW(parseConfig(CONFIG2, true), ConfigFile::Error);
  BOOST_CHECK_THROW(parseConfig(CONFIG2, false), ConfigFile::Error);

  // wrong address family
  const std::string CONFIG3 = R&quot;CONFIG(
    face_system
    {
      udp
      {
        mcast_group_v6 224.0.23.170
      }
    }
  )CONFIG&quot;;

  BOOST_CHECK_THROW(parseConfig(CONFIG3, true), ConfigFile::Error);
  BOOST_CHECK_THROW(parseConfig(CONFIG3, false), ConfigFile::Error);
}

BOOST_AUTO_TEST_CASE(BadMcastPortV4)
{
  const std::string CONFIG1 = R&quot;CONFIG(
    face_system
    {
      udp
      {
        mcast_port hey
      }
    }
  )CONFIG&quot;;

  BOOST_CHECK_THROW(parseConfig(CONFIG1, true), ConfigFile::Error);
  BOOST_CHECK_THROW(parseConfig(CONFIG1, false), ConfigFile::Error);

  const std::string CONFIG2 = R&quot;CONFIG(
    face_system
    {
      udp
      {
        mcast_port 99999
      }
    }
  )CONFIG&quot;;

  BOOST_CHECK_THROW(parseConfig(CONFIG2, true), ConfigFile::Error);
  BOOST_CHECK_THROW(parseConfig(CONFIG2, false), ConfigFile::Error);
}

BOOST_AUTO_TEST_CASE(BadMcastPortV6)
{
  const std::string CONFIG1 = R&quot;CONFIG(
    face_system
    {
      udp
      {
        mcast_port_v6 bar
      }
    }
  )CONFIG&quot;;

  BOOST_CHECK_THROW(parseConfig(CONFIG1, true), ConfigFile::Error);
  BOOST_CHECK_THROW(parseConfig(CONFIG1, false), ConfigFile::Error);

  const std::string CONFIG2 = R&quot;CONFIG(
    face_system
    {
      udp
      {
        mcast_port_v6 99999
      }
    }
  )CONFIG&quot;;

  BOOST_CHECK_THROW(parseConfig(CONFIG2, true), ConfigFile::Error);
  BOOST_CHECK_THROW(parseConfig(CONFIG2, false), ConfigFile::Error);
}

BOOST_AUTO_TEST_CASE(UnknownOption)
{
  const std::string CONFIG = R&quot;CONFIG(
    face_system
    {
      udp
      {
        hello
      }
    }
  )CONFIG&quot;;

  BOOST_CHECK_THROW(parseConfig(CONFIG, true), ConfigFile::Error);
  BOOST_CHECK_THROW(parseConfig(CONFIG, false), ConfigFile::Error);
}

BOOST_AUTO_TEST_SUITE_END() // ProcessConfig

BOOST_AUTO_TEST_CASE(GetChannels)
{
  BOOST_CHECK_EQUAL(factory.getChannels().empty(), true);

  std::set&lt;std::string&gt; expected;
  expected.insert(createChannel(&quot;127.0.0.1&quot;, 20070)-&gt;getUri().toString());
  expected.insert(createChannel(&quot;127.0.0.1&quot;, 20071)-&gt;getUri().toString());
  expected.insert(createChannel(&quot;::1&quot;, 20071)-&gt;getUri().toString());
  checkChannelListEqual(factory, expected);
}

BOOST_FIXTURE_TEST_CASE(CreateChannel, UdpFactoryMcastFixture)
{
  auto channel1 = createChannel(&quot;127.0.0.1&quot;, 20070);
  auto channel1a = createChannel(&quot;127.0.0.1&quot;, 20070);
  BOOST_CHECK_EQUAL(channel1, channel1a);
  BOOST_CHECK_EQUAL(channel1-&gt;getUri().toString(), &quot;udp4://127.0.0.1:20070&quot;);

  auto channel2 = createChannel(&quot;127.0.0.1&quot;, 20071);
  BOOST_CHECK_NE(channel1, channel2);

  auto channel3 = createChannel(&quot;::1&quot;, 20071);
  BOOST_CHECK_NE(channel2, channel3);
  BOOST_CHECK_EQUAL(channel3-&gt;getUri().toString(), &quot;udp6://[::1]:20071&quot;);

#ifdef __linux__
  // need superuser privileges to create multicast faces on Linux
  SKIP_IF_NOT_SUPERUSER();
#endif // __linux__

  // createChannel with a local endpoint that has already been allocated to a UDP multicast face
  if (!netifsV4.empty()) {
    auto mcastFace = createMulticastFace(&quot;127.0.0.1&quot;, &quot;224.0.0.254&quot;, 20072);
    BOOST_CHECK_EXCEPTION(createChannel(&quot;127.0.0.1&quot;, 20072), UdpFactory::Error,
                          [] (const UdpFactory::Error&amp; e) {
                            return strcmp(e.what(),
                                          &quot;Cannot create UDP channel on 127.0.0.1:20072, &quot;
                                          &quot;endpoint already allocated to a UDP multicast face&quot;) == 0;
                          });
  }
  if (!netifsV6.empty()) {
    auto mcastFace = createMulticastFace(&quot;::1&quot;, &quot;ff02::114&quot;, 20072);
    BOOST_CHECK_EXCEPTION(createChannel(&quot;::1&quot;, 20072), UdpFactory::Error,
                          [] (const UdpFactory::Error&amp; e) {
                            return strcmp(e.what(),
                                          &quot;Cannot create UDP channel on [::1]:20072, &quot;
                                          &quot;endpoint already allocated to a UDP multicast face&quot;) == 0;
                          });
  }
}

BOOST_FIXTURE_TEST_CASE(CreateMulticastFaceV4, UdpFactoryMcastFixture)
{
#ifdef __linux__
  // need superuser privileges to create multicast faces on Linux
  SKIP_IF_NOT_SUPERUSER();
#endif // __linux__
  SKIP_IF_UDP_MCAST_V4_NETIF_COUNT_LT(1);

  auto multicastFace1  = createMulticastFace(&quot;127.0.0.1&quot;, &quot;224.0.0.254&quot;, 20070);
  auto multicastFace1a = createMulticastFace(&quot;127.0.0.1&quot;, &quot;224.0.0.254&quot;, 20070);
  auto multicastFace2  = createMulticastFace(&quot;127.0.0.1&quot;, &quot;224.0.0.254&quot;, 20030);
  BOOST_CHECK_EQUAL(multicastFace1, multicastFace1a);
  BOOST_CHECK_NE(multicastFace1, multicastFace2);

  auto address = findNonLoopbackAddressForMulticastFace(ndn::net::AddressFamily::V4);
  if (!address.is_unspecified()) {
    auto multicastFace3  = createMulticastFace(address.to_string(), &quot;224.0.0.254&quot;, 20070);
    BOOST_CHECK_NE(multicastFace1, multicastFace3);
    BOOST_CHECK_NE(multicastFace2, multicastFace3);
  }

  // create with a local endpoint already used by a channel
  auto channel = createChannel(&quot;127.0.0.1&quot;, 20071);
  BOOST_CHECK_EXCEPTION(createMulticastFace(&quot;127.0.0.1&quot;, &quot;224.0.0.254&quot;, 20071), UdpFactory::Error,
                        [] (const UdpFactory::Error&amp; e) {
                          return strcmp(e.what(),
                                        &quot;Cannot create UDP multicast face on 127.0.0.1:20071, &quot;
                                        &quot;endpoint already allocated to a UDP channel&quot;) == 0;
                        });

  // create with a local endpoint already used by a multicast face on a different multicast group
  BOOST_CHECK_EXCEPTION(createMulticastFace(&quot;127.0.0.1&quot;, &quot;224.0.0.42&quot;, 20070), UdpFactory::Error,
                        [] (const UdpFactory::Error&amp; e) {
                          return strcmp(e.what(),
                                        &quot;Cannot create UDP multicast face on 127.0.0.1:20070, &quot;
                                        &quot;endpoint already allocated to a different UDP multicast face&quot;) == 0;
                        });
}

BOOST_FIXTURE_TEST_CASE(CreateMulticastFaceV6, UdpFactoryMcastFixture)
{
#ifdef __linux__
  // need superuser privileges to create multicast faces on Linux
  SKIP_IF_NOT_SUPERUSER();
#endif // __linux__
  SKIP_IF_UDP_MCAST_V6_NETIF_COUNT_LT(1);

  auto multicastFace1  = createMulticastFace(&quot;::1&quot;, &quot;ff02::114&quot;, 20070);
  auto multicastFace1a = createMulticastFace(&quot;::1&quot;, &quot;ff02::114&quot;, 20070);
  auto multicastFace2  = createMulticastFace(&quot;::1&quot;, &quot;ff02::114&quot;, 20030);
  BOOST_CHECK_EQUAL(multicastFace1, multicastFace1a);
  BOOST_CHECK_NE(multicastFace1, multicastFace2);

  auto address = findNonLoopbackAddressForMulticastFace(ndn::net::AddressFamily::V6);
  if (!address.is_unspecified()) {
    auto multicastFace3  = createMulticastFace(address.to_string(), &quot;ff02::114&quot;, 20070);
    BOOST_CHECK_NE(multicastFace1, multicastFace3);
    BOOST_CHECK_NE(multicastFace2, multicastFace3);
  }

  // create with a local endpoint already used by a channel
  auto channel = createChannel(&quot;::1&quot;, 20071);
  BOOST_CHECK_EXCEPTION(createMulticastFace(&quot;::1&quot;, &quot;ff02::114&quot;, 20071), UdpFactory::Error,
                        [] (const UdpFactory::Error&amp; e) {
                          return strcmp(e.what(),
                                        &quot;Cannot create UDP multicast face on [::1]:20071, &quot;
                                        &quot;endpoint already allocated to a UDP channel&quot;) == 0;
                        });

  // create with a local endpoint already used by a multicast face on a different multicast group
  BOOST_CHECK_EXCEPTION(createMulticastFace(&quot;::1&quot;, &quot;ff02::42&quot;, 20070), UdpFactory::Error,
                        [] (const UdpFactory::Error&amp; e) {
                          return strcmp(e.what(),
                                        &quot;Cannot create UDP multicast face on [::1]:20070, &quot;
                                        &quot;endpoint already allocated to a different UDP multicast face&quot;) == 0;
                        });
}

BOOST_AUTO_TEST_CASE(CreateFace)
{
  createFace(factory,
             FaceUri(&quot;udp4://127.0.0.1:6363&quot;),
             {},
             {ndn::nfd::FACE_PERSISTENCY_PERSISTENT, {}, {}, {}, false, false, false},
             {CreateFaceExpectedResult::FAILURE, 504, &quot;No channels available to connect&quot;});

  createChannel(&quot;127.0.0.1&quot;, 20071);

  createFace(factory,
             FaceUri(&quot;udp4://127.0.0.1:6363&quot;),
             {},
             {ndn::nfd::FACE_PERSISTENCY_PERSISTENT, {}, {}, {}, false, false, false},
             {CreateFaceExpectedResult::SUCCESS, 0, &quot;&quot;});

  createFace(factory,
             FaceUri(&quot;udp4://127.0.0.1:6363&quot;),
             {},
             {ndn::nfd::FACE_PERSISTENCY_PERMANENT, {}, {}, {}, false, false, false},
             {CreateFaceExpectedResult::SUCCESS, 0, &quot;&quot;});

  createFace(factory,
             FaceUri(&quot;udp4://127.0.0.1:20072&quot;),
             {},
             {ndn::nfd::FACE_PERSISTENCY_PERMANENT, {}, {}, {}, false, false, false},
             {CreateFaceExpectedResult::SUCCESS, 0, &quot;&quot;});

  createFace(factory,
             FaceUri(&quot;udp4://127.0.0.1:20073&quot;),
             {},
             {ndn::nfd::FACE_PERSISTENCY_PERMANENT, {}, {}, {}, false, true, false},
             {CreateFaceExpectedResult::SUCCESS, 0, &quot;&quot;});

  createFace(factory,
             FaceUri(&quot;udp4://127.0.0.1:20073&quot;),
             {},
             {ndn::nfd::FACE_PERSISTENCY_PERMANENT, {}, {}, {}, false, false, true},
             {CreateFaceExpectedResult::SUCCESS, 0, &quot;&quot;});

  createFace(factory,
             FaceUri(&quot;udp4://127.0.0.1:20074&quot;),
             {},
             {ndn::nfd::FACE_PERSISTENCY_PERMANENT, {}, {}, 1000, false, false, false},
             {CreateFaceExpectedResult::SUCCESS, 0, &quot;&quot;});
}

BOOST_AUTO_TEST_CASE(UnsupportedCreateFace)
{
  createChannel(&quot;127.0.0.1&quot;, 20071);

  createFace(factory,
             FaceUri(&quot;udp4://127.0.0.1:20072&quot;),
             FaceUri(&quot;udp4://127.0.0.1:20071&quot;),
             {ndn::nfd::FACE_PERSISTENCY_PERSISTENT, {}, {}, {}, false, false, false},
             {CreateFaceExpectedResult::FAILURE, 406,
              &quot;Unicast UDP faces cannot be created with a LocalUri&quot;});

  createFace(factory,
             FaceUri(&quot;udp4://127.0.0.1:20072&quot;),
             {},
             {ndn::nfd::FACE_PERSISTENCY_ON_DEMAND, {}, {}, {}, false, false, false},
             {CreateFaceExpectedResult::FAILURE, 406,
              &quot;Outgoing UDP faces do not support on-demand persistency&quot;});

  createFace(factory,
             FaceUri(&quot;udp4://233.252.0.1:23252&quot;),
             {},
             {ndn::nfd::FACE_PERSISTENCY_PERSISTENT, {}, {}, {}, false, false, false},
             {CreateFaceExpectedResult::FAILURE, 406,
              &quot;Cannot create multicast UDP faces&quot;});

  createFace(factory,
             FaceUri(&quot;udp4://127.0.0.1:20072&quot;),
             {},
             {ndn::nfd::FACE_PERSISTENCY_PERSISTENT, {}, {}, {}, true, false, false},
             {CreateFaceExpectedResult::FAILURE, 406,
              &quot;Local fields can only be enabled on faces with local scope&quot;});
}

BOOST_AUTO_TEST_SUITE_END() // TestUdpFactory
BOOST_AUTO_TEST_SUITE_END() // Face

} // namespace tests
} // namespace face
} // namespace nfd
</PRE>
</div>
  </div>
</body>
</html>
