<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for tables-config-section.t.cpp &amp; udp-factory.t.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for tables-config-section.t.cpp &amp; udp-factory.t.cpp
      </h3>
<h1 align="center">
        7.2%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>tables-config-section.t.cpp (16.513762%)<th>udp-factory.t.cpp (4.6753244%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(362-413)<td><a href="#" name="0">(565-615)</a><td align="center"><font color="#ff0000">22</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(125-150)<td><a href="#" name="1">(721-753)</a><td align="center"><font color="#a20000">14</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>tables-config-section.t.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "mgmt/tables-config-section.hpp"
2 #include "fw/best-route-strategy.hpp"
3 #include "fw/forwarder.hpp"
4 #include "table/cs-policy-lru.hpp"
5 #include "table/cs-policy-priority-fifo.hpp"
6 #include "tests/test-common.hpp"
7 #include "tests/check-typeid.hpp"
8 #include "tests/daemon/global-io-fixture.hpp"
9 #include "tests/daemon/fw/dummy-strategy.hpp"
10 namespace nfd {
11 namespace tests {
12 class TablesConfigSectionFixture : public GlobalIoFixture
13 {
14 protected:
15   TablesConfigSectionFixture()
16   {
17     DummyStrategy::registerAs(strategyP);
18     DummyStrategy::registerAs(strategyP1);
19     DummyStrategy::registerAs(strategyQ);
20   }
21   void
22   runConfig(const std::string&amp; config, bool isDryRun)
23   {
24     ConfigFile cf;
25     tablesConfig.setConfigFile(cf);
26     cf.parse(config, isDryRun, "dummy-config");
27   }
28 protected:
29   FaceTable faceTable;
30   Forwarder forwarder{faceTable};
31   Cs&amp; cs{forwarder.getCs()};
32   StrategyChoice&amp; strategyChoice{forwarder.getStrategyChoice()};
33   NetworkRegionTable&amp; networkRegionTable{forwarder.getNetworkRegionTable()};
34   TablesConfigSection tablesConfig{forwarder};
35   const Name defaultStrategy = fw::BestRouteStrategy::getStrategyName();
36   const Name strategyP = Name("/tables-config-section-strategy-P").appendVersion(2);
37   const Name strategyP1 = "/tables-config-section-strategy-P/v=1";
38   const Name strategyP1Marker = "/tables-config-section-strategy-P/%FD%01";
39   const Name strategyQ = Name("/tables-config-section-strategy-Q").appendVersion(2);
40 };
41 BOOST_AUTO_TEST_SUITE(Mgmt)
42 BOOST_FIXTURE_TEST_SUITE(TestTablesConfigSection, TablesConfigSectionFixture)
43 BOOST_AUTO_TEST_SUITE(CsMaxPackets)
44 BOOST_AUTO_TEST_CASE(NoSection)
45 {
46   const size_t initialLimit = cs.getLimit();
47   tablesConfig.ensureConfigured();
48   BOOST_CHECK_NE(cs.getLimit(), initialLimit);
49 }
50 BOOST_AUTO_TEST_CASE(Default)
51 {
52   const std::string CONFIG = R"CONFIG(
53     tables
54     {
55     }
56   )CONFIG";
57   const size_t initialLimit = cs.getLimit();
58   BOOST_REQUIRE_NO_THROW(runConfig(CONFIG, true));
59   BOOST_CHECK_EQUAL(cs.getLimit(), initialLimit);
60   BOOST_REQUIRE_NO_THROW(runConfig(CONFIG, false));
61   BOOST_CHECK_NE(cs.getLimit(), initialLimit);
62 }
63 BOOST_AUTO_TEST_CASE(Valid)
64 {
65   const std::string CONFIG = R"CONFIG(
66     tables
67     {
68       cs_max_packets 101
69     }
70   )CONFIG";
71   BOOST_REQUIRE_NE(cs.getLimit(), 101);
72   BOOST_REQUIRE_NO_THROW(runConfig(CONFIG, true));
73   BOOST_CHECK_NE(cs.getLimit(), 101);
74   BOOST_REQUIRE_NO_THROW(runConfig(CONFIG, false));
75   BOOST_CHECK_EQUAL(cs.getLimit(), 101);
76 <a name="1"></a>
77   tablesConfig.ensureConfigured();
78   BOOST_CHECK_EQUAL(cs.getLimit(), 101);
79 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>}
80 BOOST_AUTO_TEST_CASE(MissingValue)
81 {
82   const std::string CONFIG = R"CONFIG(
83     tables
84     {
85       cs_max_packets
86     }
87   )CONFIG";
88   BOOST_CHECK_THROW(runConfig(CONFIG, true), ConfigFile::Error);
89   BOOST_CHECK_THROW(runConfig(CONFIG, false), ConfigFile::Error);
90 }
91 BOOST_AUTO_TEST_CASE(InvalidValue)
92 {
93   const std::string CONFIG = R"CONFIG(
94     tables
95     {
96       cs_max_packets invalid
97     }
98   )CONFIG";
99   BOOST_CHECK_THROW(runConfig(CONFIG, true), ConfigFile::Error);
100   BOOST_CHECK_THROW(runConfig(CONFIG, false), ConfigFile::Error);</b></font>
101 }
102 BOOST_AUTO_TEST_SUITE_END() 
103 BOOST_AUTO_TEST_SUITE(CsPolicy)
104 BOOST_AUTO_TEST_CASE(Default)
105 {
106   const std::string CONFIG = R"CONFIG(
107     tables
108     {
109     }
110   )CONFIG";
111   runConfig(CONFIG, false);
112   cs::Policy* currentPolicy = cs.getPolicy();
113   NFD_CHECK_TYPEID_EQUAL(*currentPolicy, cs::LruPolicy);
114 }
115 BOOST_AUTO_TEST_CASE(Known)
116 {
117   const std::string CONFIG = R"CONFIG(
118     tables
119     {
120       cs_policy priority_fifo
121     }
122   )CONFIG";
123   runConfig(CONFIG, true);
124   cs::Policy* currentPolicy = cs.getPolicy();
125   NFD_CHECK_TYPEID_EQUAL(*currentPolicy, cs::LruPolicy);
126   runConfig(CONFIG, false);
127   currentPolicy = cs.getPolicy();
128   NFD_CHECK_TYPEID_EQUAL(*currentPolicy, cs::PriorityFifoPolicy);
129 }
130 BOOST_AUTO_TEST_CASE(Unknown)
131 {
132   const std::string CONFIG = R"CONFIG(
133     tables
134     {
135       cs_policy unknown
136     }
137   )CONFIG";
138   BOOST_CHECK_THROW(runConfig(CONFIG, true), ConfigFile::Error);
139   BOOST_CHECK_THROW(runConfig(CONFIG, false), ConfigFile::Error);
140 }
141 BOOST_AUTO_TEST_SUITE_END() 
142 class CsUnsolicitedPolicyFixture : public TablesConfigSectionFixture
143 {
144 protected:
145   CsUnsolicitedPolicyFixture()
146   {
147     forwarder.setUnsolicitedDataPolicy(make_unique&lt;fw::AdmitNetworkUnsolicitedDataPolicy&gt;());
148   }
149 };
150 BOOST_FIXTURE_TEST_SUITE(CsUnsolicitedPolicy, CsUnsolicitedPolicyFixture)
151 BOOST_AUTO_TEST_CASE(NoSection)
152 {
153   tablesConfig.ensureConfigured();
154   auto* currentPolicy = &amp;forwarder.getUnsolicitedDataPolicy();
155   NFD_CHECK_TYPEID_EQUAL(*currentPolicy, fw::DefaultUnsolicitedDataPolicy);
156 }
157 BOOST_AUTO_TEST_CASE(Default)
158 {
159   const std::string CONFIG = R"CONFIG(
160     tables
161     {
162     }
163   )CONFIG";
164   BOOST_REQUIRE_NO_THROW(runConfig(CONFIG, true));
165   auto* currentPolicy = &amp;forwarder.getUnsolicitedDataPolicy();
166   NFD_CHECK_TYPEID_NE(*currentPolicy, fw::DefaultUnsolicitedDataPolicy);
167   BOOST_REQUIRE_NO_THROW(runConfig(CONFIG, false));
168   currentPolicy = &amp;forwarder.getUnsolicitedDataPolicy();
169   NFD_CHECK_TYPEID_EQUAL(*currentPolicy, fw::DefaultUnsolicitedDataPolicy);
170 }
171 BOOST_AUTO_TEST_CASE(Known)
172 {
173   const std::string CONFIG = R"CONFIG(
174     tables
175     {
176       cs_unsolicited_policy admit-all
177     }
178   )CONFIG";
179   BOOST_REQUIRE_NO_THROW(runConfig(CONFIG, true));
180   auto* currentPolicy = &amp;forwarder.getUnsolicitedDataPolicy();
181   NFD_CHECK_TYPEID_NE(*currentPolicy, fw::AdmitAllUnsolicitedDataPolicy);
182   BOOST_REQUIRE_NO_THROW(runConfig(CONFIG, false));
183   currentPolicy = &amp;forwarder.getUnsolicitedDataPolicy();
184   NFD_CHECK_TYPEID_EQUAL(*currentPolicy, fw::AdmitAllUnsolicitedDataPolicy);
185 }
186 BOOST_AUTO_TEST_CASE(Unknown)
187 {
188   const std::string CONFIG = R"CONFIG(
189     tables
190     {
191       cs_unsolicited_policy unknown
192     }
193   )CONFIG";
194   BOOST_CHECK_THROW(runConfig(CONFIG, true), ConfigFile::Error);
195   BOOST_CHECK_THROW(runConfig(CONFIG, false), ConfigFile::Error);
196 }
197 BOOST_AUTO_TEST_SUITE_END() 
198 BOOST_AUTO_TEST_SUITE(StrategyChoice)
199 BOOST_AUTO_TEST_CASE(Unversioned)
200 {
201   const std::string CONFIG = R"CONFIG(
202     tables
203     {
204       strategy_choice
205       {
206         / /tables-config-section-strategy-P
207         /a /tables-config-section-strategy-Q
208       }
209     }
210   )CONFIG";
211   BOOST_REQUIRE_NO_THROW(runConfig(CONFIG, true));
212   {
213     fw::Strategy&amp; rootStrategy = strategyChoice.findEffectiveStrategy("/");
214     BOOST_CHECK_EQUAL(rootStrategy.getInstanceName(), defaultStrategy);
215     fw::Strategy&amp; aStrategy = strategyChoice.findEffectiveStrategy("/a");
216     BOOST_CHECK_EQUAL(aStrategy.getInstanceName(), defaultStrategy);
217   }
218   BOOST_REQUIRE_NO_THROW(runConfig(CONFIG, false));
219   {
220     fw::Strategy&amp; rootStrategy = strategyChoice.findEffectiveStrategy("/");
221     BOOST_CHECK_EQUAL(rootStrategy.getInstanceName(), strategyP.getPrefix(-1));
222     NFD_CHECK_TYPEID_EQUAL(rootStrategy, DummyStrategy);
223     fw::Strategy&amp; aStrategy = strategyChoice.findEffectiveStrategy("/a");
224     BOOST_CHECK_EQUAL(aStrategy.getInstanceName(), strategyQ.getPrefix(-1));
225     NFD_CHECK_TYPEID_EQUAL(aStrategy, DummyStrategy);
226   }
227 }
228 BOOST_AUTO_TEST_CASE(Versioned)
229 {
230   const std::string CONFIG = R"CONFIG(
231     tables
232     {
233       strategy_choice
234       {
235         /test/latest /tables-config-section-strategy-P
236         /test/old /tables-config-section-strategy-P/v=1
237         /test/marker /tables-config-section-strategy-P/%FD%01
238       }
239     }
240   )CONFIG";
241   BOOST_REQUIRE_NO_THROW(runConfig(CONFIG, true));
242   {
243     fw::Strategy&amp; testLatestStrategy = strategyChoice.findEffectiveStrategy("/test/latest");
244     BOOST_CHECK_EQUAL(testLatestStrategy.getInstanceName(), defaultStrategy);
245     fw::Strategy&amp; testOldStrategy = strategyChoice.findEffectiveStrategy("/test/old");
246     BOOST_CHECK_EQUAL(testOldStrategy.getInstanceName(), defaultStrategy);
247     fw::Strategy&amp; testMarkerStrategy = strategyChoice.findEffectiveStrategy("/test/marker");
248     BOOST_CHECK_EQUAL(testMarkerStrategy.getInstanceName(), defaultStrategy);
249   }
250   BOOST_REQUIRE_NO_THROW(runConfig(CONFIG, false));
251   {
252     fw::Strategy&amp; testLatestStrategy = strategyChoice.findEffectiveStrategy("/test/latest");
253     BOOST_CHECK_EQUAL(testLatestStrategy.getInstanceName(), strategyP.getPrefix(-1));
254     NFD_CHECK_TYPEID_EQUAL(testLatestStrategy, DummyStrategy);
255     fw::Strategy&amp; testOldStrategy = strategyChoice.findEffectiveStrategy("/test/old");
256     BOOST_CHECK_EQUAL(testOldStrategy.getInstanceName(), strategyP1);
257     NFD_CHECK_TYPEID_EQUAL(testOldStrategy, DummyStrategy);
258     fw::Strategy&amp; testMarkerStrategy = strategyChoice.findEffectiveStrategy("/test/marker");
259     BOOST_CHECK_EQUAL(testMarkerStrategy.getInstanceName(), strategyP1Marker);
260     NFD_CHECK_TYPEID_EQUAL(testMarkerStrategy, DummyStrategy);
261   }
262 }
263 BOOST_AUTO_TEST_CASE(NonExisting)
264 {
265   const std::string CONFIG = R"CONFIG(
266     tables
267     {
268       strategy_choice
269       {
270         / /localhost/nfd/strategy/test-doesnotexist
271       }
272 <a name="0"></a>    }
273   )CONFIG";
274 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  BOOST_CHECK_THROW(runConfig(CONFIG, true), ConfigFile::Error);
275   BOOST_CHECK_THROW(runConfig(CONFIG, false), ConfigFile::Error);
276 }
277 BOOST_AUTO_TEST_CASE(MissingPrefix)
278 {
279   const std::string CONFIG = R"CONFIG(
280     tables
281     {
282       strategy_choice
283       {
284         /tables-config-section-strategy-P
285       }
286     }
287   )CONFIG";
288   BOOST_CHECK_THROW(runConfig(CONFIG, true), ConfigFile::Error);
289   BOOST_CHECK_THROW(runConfig(CONFIG, false), ConfigFile::Error);
290 }
291 BOOST_AUTO_TEST_CASE(Duplicate)
292 {
293   const std::string CONFIG = R"CONFIG(
294     tables
295     {
296       strategy_choice
297       {
298         / /tables-config-section-strategy-P
299         /a /tables-config-section-strategy-Q
300         / /tables-config-section-strategy-Q
301       }
302     }
303   )CONFIG";
304   BOOST_CHECK_THROW(runConfig(CONFIG, true), ConfigFile::Error);
305   BOOST_CHECK_THROW(runConfig(CONFIG, false), ConfigFile::Error);
306 }
307 BOOST_AUTO_TEST_CASE(UnacceptableParameters)
308 {
309   const std::string CONFIG = R"CONFIG(
310     tables
311     {
312       strategy_choice
313       {
314         / /localhost/nfd/strategy/best-route/v=5/param
315       }
316     }
317   )CONFIG";
318   BOOST_CHECK_NO_THROW(runConfig(CONFIG, true));
319   BOOST_CHECK_THROW(runConfig(CONFIG, false), ConfigFile::Error);</b></font>
320 }
321 BOOST_AUTO_TEST_SUITE_END() 
322 BOOST_AUTO_TEST_SUITE(NetworkRegion)
323 BOOST_AUTO_TEST_CASE(Basic)
324 {
325   const std::string CONFIG = R"CONFIG(
326     tables
327     {
328       network_region
329       {
330         /test/regionA
331         /test/regionB/component
332       }
333     }
334   )CONFIG";
335   BOOST_REQUIRE_NO_THROW(runConfig(CONFIG, true));
336   BOOST_CHECK_EQUAL(networkRegionTable.size(), 0);
337   BOOST_CHECK(networkRegionTable.find("/test/regionA") == networkRegionTable.end());
338   BOOST_CHECK(networkRegionTable.find("/test/regionB/component") == networkRegionTable.end());
339   BOOST_REQUIRE_NO_THROW(runConfig(CONFIG, false));
340   BOOST_CHECK_EQUAL(networkRegionTable.size(), 2);
341   BOOST_CHECK(networkRegionTable.find("/test/regionA") != networkRegionTable.end());
342   BOOST_CHECK(networkRegionTable.find("/test/regionB/component") != networkRegionTable.end());
343 }
344 BOOST_AUTO_TEST_CASE(Reload)
345 {
346   const std::string CONFIG1 = R"CONFIG(
347     tables
348     {
349       network_region
350       {
351         /some/region
352       }
353     }
354   )CONFIG";
355   BOOST_REQUIRE_NO_THROW(runConfig(CONFIG1, true));
356   BOOST_CHECK(networkRegionTable.find("/some/region") == networkRegionTable.end());
357   BOOST_REQUIRE_NO_THROW(runConfig(CONFIG1, false));
358   BOOST_CHECK(networkRegionTable.find("/some/region") != networkRegionTable.end());
359   const std::string CONFIG2 = R"CONFIG(
360     tables
361     {
362       network_region
363       {
364         /different/region
365       }
366     }
367   )CONFIG";
368   BOOST_REQUIRE_NO_THROW(runConfig(CONFIG2, true));
369   BOOST_CHECK(networkRegionTable.find("/some/region") != networkRegionTable.end());
370   BOOST_CHECK(networkRegionTable.find("/different/region") == networkRegionTable.end());
371   BOOST_REQUIRE_NO_THROW(runConfig(CONFIG2, false));
372   BOOST_CHECK(networkRegionTable.find("/some/region") == networkRegionTable.end());
373   BOOST_CHECK(networkRegionTable.find("/different/region") != networkRegionTable.end());
374 }
375 BOOST_AUTO_TEST_SUITE_END() 
376 BOOST_AUTO_TEST_SUITE_END() BOOST_AUTO_TEST_SUITE_END() 
} } </pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>udp-factory.t.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "face/udp-factory.hpp"
2 #include "face-system-fixture.hpp"
3 #include "factory-test-common.hpp"
4 #include &lt;boost/algorithm/string/replace.hpp&gt;
5 namespace nfd {
6 namespace face {
7 namespace tests {
8 class UdpFactoryFixture : public FaceSystemFactoryFixture&lt;UdpFactory&gt;
9 {
10 protected:
11   shared_ptr&lt;UdpChannel&gt;
12   createChannel(const std::string&amp; localIp, uint16_t localPort)
13   {
14     udp::Endpoint endpoint(boost::asio::ip::address::from_string(localIp), localPort);
15     return factory.createChannel(endpoint, 5_min);
16   }
17 };
18 class UdpFactoryMcastFixture : public UdpFactoryFixture
19 {
20 protected:
21   UdpFactoryMcastFixture()
22   {
23     for (const auto&amp; netif : collectNetworkInterfaces()) {
24       if (netif-&gt;isUp() &amp;&amp; !netif-&gt;isLoopback() &amp;&amp; netif-&gt;canMulticast()) {
25         bool hasValidIpAddress = false;
26         if (hasAddressFamily(*netif, ndn::net::AddressFamily::V4)) {
27           hasValidIpAddress = true;
28           netifsV4.push_back(netif);
29         }
30         if (hasAddressFamily(*netif, ndn::net::AddressFamily::V6)) {
31           hasValidIpAddress = true;
32           netifsV6.push_back(netif);
33         }
34         if (hasValidIpAddress) {
35           netifs.push_back(netif);
36         }
37       }
38     }
39     this-&gt;copyRealNetifsToNetmon();
40   }
41   shared_ptr&lt;Face&gt;
42   createMulticastFace(const std::string&amp; localIp, const std::string&amp; mcastIp, uint16_t mcastPort)
43   {
44     auto localAddress = boost::asio::ip::address::from_string(localIp);
45     udp::Endpoint mcastEndpoint(boost::asio::ip::address::from_string(mcastIp), mcastPort);
46     if (localAddress.is_v4()) {
47       BOOST_ASSERT(!netifsV4.empty());
48       return factory.createMulticastFace(netifsV4.front(), localAddress, mcastEndpoint);
49     }
50     else {
51       BOOST_ASSERT(!netifsV6.empty());
52       return factory.createMulticastFace(netifsV6.front(), localAddress, mcastEndpoint);
53     }
54   }
55   boost::asio::ip::address
56   findNonLoopbackAddressForMulticastFace(ndn::net::AddressFamily af) const
57   {
58     const auto&amp; netifList = af == ndn::net::AddressFamily::V4 ? netifsV4 : netifsV6;
59     for (const auto&amp; netif : netifList) {
60       for (const auto&amp; a : netif-&gt;getNetworkAddresses()) {
61         if (a.getFamily() == af &amp;&amp; !a.getIp().is_loopback())
62           return a.getIp();
63       }
64     }
65     return {};
66   }
67   std::vector&lt;const Face*&gt;
68   listUdp4McastFaces(ndn::nfd::LinkType linkType = ndn::nfd::LINK_TYPE_MULTI_ACCESS) const
69   {
70     return this-&gt;listFacesByScheme("udp4", linkType);
71   }
72   std::vector&lt;const Face*&gt;
73   listUdp6McastFaces(ndn::nfd::LinkType linkType = ndn::nfd::LINK_TYPE_MULTI_ACCESS) const
74   {
75     return this-&gt;listFacesByScheme("udp6", linkType);
76   }
77   static bool
78   hasAddressFamily(const NetworkInterface&amp; netif, ndn::net::AddressFamily af)
79   {
80     return std::any_of(netif.getNetworkAddresses().begin(), netif.getNetworkAddresses().end(),
81                        [af] (const NetworkAddress&amp; a) { return a.getFamily() == af; });
82   }
83   static bool
84   isFaceOnNetif(const Face&amp; face, const NetworkInterface&amp; netif)
85   {
86     auto ip = boost::asio::ip::address::from_string(face.getLocalUri().getHost());
87     return std::any_of(netif.getNetworkAddresses().begin(), netif.getNetworkAddresses().end(),
88                        [ip] (const NetworkAddress&amp; a) { return a.getIp() == ip; });
89   }
90 protected:
91   std::vector&lt;shared_ptr&lt;const NetworkInterface&gt;&gt; netifs;
92   std::vector&lt;shared_ptr&lt;const NetworkInterface&gt;&gt; netifsV4;
93   std::vector&lt;shared_ptr&lt;const NetworkInterface&gt;&gt; netifsV6;
94 };
95 #define SKIP_IF_UDP_MCAST_NETIF_COUNT_LT(n) \
96   do { \
97     if (this-&gt;netifs.size() &lt; (n)) { \
98       BOOST_WARN_MESSAGE(false, "skipping assertions that require " #n \
99                                 " or more MulticastUdpTransport-capable network interfaces"); \
100       return; \
101     } \
102   } while (false)
103 #define SKIP_IF_UDP_MCAST_V4_NETIF_COUNT_LT(n) \
104   do { \
105     if (this-&gt;netifsV4.size() &lt; (n)) { \
106       BOOST_WARN_MESSAGE(false, "skipping assertions that require " #n \
107                                 " or more IPv4 MulticastUdpTransport-capable network interfaces"); \
108       return; \
109     } \
110   } while (false)
111 #define SKIP_IF_UDP_MCAST_V6_NETIF_COUNT_LT(n) \
112   do { \
113     if (this-&gt;netifsV6.size() &lt; (n)) { \
114       BOOST_WARN_MESSAGE(false, "skipping assertions that require " #n \
115                                 " or more IPv6 MulticastUdpTransport-capable network interfaces"); \
116       return; \
117     } \
118   } while (false)
119 BOOST_AUTO_TEST_SUITE(Face)
120 BOOST_FIXTURE_TEST_SUITE(TestUdpFactory, UdpFactoryFixture)
121 BOOST_AUTO_TEST_SUITE(ProcessConfig)
122 using nfd::Face;
123 BOOST_AUTO_TEST_CASE(Defaults)
124 {
125   const std::string CONFIG = R"CONFIG(
126     face_system
127     {
128       udp
129     }
130   )CONFIG";
131   parseConfig(CONFIG, true);
132   parseConfig(CONFIG, false);
133   checkChannelListEqual(factory, {"udp4://0.0.0.0:6363", "udp6://[::]:6363"});
134   for (const auto&amp; ch : factory.getChannels()) {
135     BOOST_CHECK(ch-&gt;isListening());
136     BOOST_CHECK_EQUAL(ch-&gt;getDefaultMtu(), ndn::MAX_NDN_PACKET_SIZE);
137   }
138 }
139 BOOST_AUTO_TEST_CASE(DisableListen)
140 {
141   const std::string CONFIG = R"CONFIG(
142     face_system
143     {
144       udp
145       {
146         listen no
147         port 7001
148         mcast no
149       }
150     }
151   )CONFIG";
152   parseConfig(CONFIG, true);
153   parseConfig(CONFIG, false);
154   checkChannelListEqual(factory, {"udp4://0.0.0.0:7001", "udp6://[::]:7001"});
155   for (const auto&amp; ch : factory.getChannels()) {
156     BOOST_CHECK(!ch-&gt;isListening());
157   }
158 }
159 BOOST_AUTO_TEST_CASE(DisableV4)
160 {
161   const std::string CONFIG = R"CONFIG(
162     face_system
163     {
164       udp
165       {
166         port 7001
167         enable_v4 no
168         enable_v6 yes
169         unicast_mtu 1452
170         mcast no
171       }
172     }
173   )CONFIG";
174   parseConfig(CONFIG, true);
175   parseConfig(CONFIG, false);
176   checkChannelListEqual(factory, {"udp6://[::]:7001"});
177   for (const auto&amp; ch : factory.getChannels()) {
178     BOOST_CHECK_EQUAL(ch-&gt;getDefaultMtu(), 1452);
179   }
180 }
181 BOOST_AUTO_TEST_CASE(DisableV6)
182 {
183   const std::string CONFIG = R"CONFIG(
184     face_system
185     {
186       udp
187       {
188         port 7001
189         enable_v4 yes
190         enable_v6 no
191         unicast_mtu 1452
192         mcast no
193       }
194     }
195   )CONFIG";
196   parseConfig(CONFIG, true);
197   parseConfig(CONFIG, false);
198   checkChannelListEqual(factory, {"udp4://0.0.0.0:7001"});
199   for (const auto&amp; ch : factory.getChannels()) {
200     BOOST_CHECK_EQUAL(ch-&gt;getDefaultMtu(), 1452);
201   }
202 }
203 BOOST_FIXTURE_TEST_CASE(EnableDisableMcast, UdpFactoryMcastFixture)
204 {
205   const std::string CONFIG_WITH_MCAST = R"CONFIG(
206     face_system
207     {
208       udp
209       {
210         mcast yes
211       }
212     }
213   )CONFIG";
214   const std::string CONFIG_WITHOUT_MCAST = R"CONFIG(
215     face_system
216     {
217       udp
218       {
219         mcast no
220       }
221     }
222   )CONFIG";
223   parseConfig(CONFIG_WITHOUT_MCAST, false);
224   BOOST_CHECK_EQUAL(this-&gt;listUdp4McastFaces().size(), 0);
225   BOOST_CHECK_EQUAL(this-&gt;listUdp6McastFaces().size(), 0);
226 #ifdef __linux__
227   SKIP_IF_NOT_SUPERUSER();
228 #endif 
229   parseConfig(CONFIG_WITH_MCAST, false);
230   g_io.poll();
231   BOOST_CHECK_EQUAL(this-&gt;listUdp4McastFaces().size(), netifsV4.size());
232   BOOST_CHECK_EQUAL(this-&gt;listUdp6McastFaces().size(), netifsV6.size());
233   BOOST_REQUIRE_EQUAL(factory.getChannels().size(), 2);
234   for (const auto&amp; face : this-&gt;listUdp4McastFaces()) {
235     BOOST_REQUIRE(face-&gt;getChannel().lock());
236     BOOST_CHECK_EQUAL(face-&gt;getChannel().lock()-&gt;getUri().getScheme(), "udp4");
237   }
238   for (const auto&amp; face : this-&gt;listUdp6McastFaces()) {
239     BOOST_REQUIRE(face-&gt;getChannel().lock());
240     BOOST_CHECK_EQUAL(face-&gt;getChannel().lock()-&gt;getUri().getScheme(), "udp6");
241   }
242   parseConfig(CONFIG_WITHOUT_MCAST, false);
243   g_io.poll();
244   BOOST_CHECK_EQUAL(this-&gt;listUdp4McastFaces().size(), 0);
245   BOOST_CHECK_EQUAL(this-&gt;listUdp6McastFaces().size(), 0);
246 }
247 BOOST_FIXTURE_TEST_CASE(McastAdHoc, UdpFactoryMcastFixture)
248 {
249 #ifdef __linux__
250   SKIP_IF_NOT_SUPERUSER();
251 #endif   SKIP_IF_UDP_MCAST_NETIF_COUNT_LT(1);
252   const std::string CONFIG = R"CONFIG(
253     face_system
254     {
255       udp
256       {
257         mcast_ad_hoc yes
258       }
259     }
260   )CONFIG";
261   parseConfig(CONFIG, false);
262   BOOST_CHECK_EQUAL(this-&gt;listUdp4McastFaces(ndn::nfd::LINK_TYPE_AD_HOC).size(), netifsV4.size());
263   BOOST_CHECK_EQUAL(this-&gt;listUdp6McastFaces(ndn::nfd::LINK_TYPE_AD_HOC).size(), netifsV6.size());
264 }
265 BOOST_FIXTURE_TEST_CASE(ChangeMcastEndpointV4, UdpFactoryMcastFixture)
266 {
267 #ifdef __linux__
268   SKIP_IF_NOT_SUPERUSER();
269 #endif   SKIP_IF_UDP_MCAST_V4_NETIF_COUNT_LT(1);
270   const std::string CONFIG1 = R"CONFIG(
271     face_system
272     {
273       udp
274       {
275         mcast_group 239.66.30.1
276         mcast_port 7011
277       }
278     }
279   )CONFIG";
280   const std::string CONFIG2 = R"CONFIG(
281     face_system
282     {
283       udp
284       {
285         mcast_group 239.66.30.2
286         mcast_port 7012
287       }
288     }
289   )CONFIG";
290   parseConfig(CONFIG1, false);
291   auto udpMcastFaces = this-&gt;listUdp4McastFaces();
292   BOOST_REQUIRE_EQUAL(udpMcastFaces.size(), netifsV4.size());
293   BOOST_CHECK_EQUAL(udpMcastFaces.front()-&gt;getRemoteUri(), FaceUri("udp4://239.66.30.1:7011"));
294   parseConfig(CONFIG2, false);
295   g_io.poll();
296   udpMcastFaces = this-&gt;listUdp4McastFaces();
297   BOOST_REQUIRE_EQUAL(udpMcastFaces.size(), netifsV4.size());
298   BOOST_CHECK_EQUAL(udpMcastFaces.front()-&gt;getRemoteUri(), FaceUri("udp4://239.66.30.2:7012"));
299 }
300 BOOST_FIXTURE_TEST_CASE(ChangeMcastEndpointV6, UdpFactoryMcastFixture)
301 {
302 #ifdef __linux__
303   SKIP_IF_NOT_SUPERUSER();
304 #endif   SKIP_IF_UDP_MCAST_V6_NETIF_COUNT_LT(1);
305   const std::string CONFIG1 = R"CONFIG(
306     face_system
307     {
308       udp
309       {
310         mcast_group_v6 ff02::1101
311         mcast_port_v6 7011
312       }
313     }
314   )CONFIG";
315   const std::string CONFIG2 = R"CONFIG(
316     face_system
317     {
318       udp
319       {
320         mcast_group_v6 ff02::1102
321         mcast_port_v6 7012
322       }
323     }
324   )CONFIG";
325   parseConfig(CONFIG1, false);
326   auto udpMcastFaces = this-&gt;listUdp6McastFaces();
327   BOOST_REQUIRE_EQUAL(udpMcastFaces.size(), netifsV6.size());
328   auto expectedAddr = boost::asio::ip::address_v6::from_string("ff02::1101");
329   expectedAddr.scope_id(netifsV6.front()-&gt;getIndex());
330   BOOST_CHECK_EQUAL(udpMcastFaces.front()-&gt;getRemoteUri(), FaceUri(udp::Endpoint(expectedAddr, 7011)));
331   parseConfig(CONFIG2, false);
332   g_io.poll();
333   udpMcastFaces = this-&gt;listUdp6McastFaces();
334   BOOST_REQUIRE_EQUAL(udpMcastFaces.size(), netifsV6.size());
335   expectedAddr = boost::asio::ip::address_v6::from_string("ff02::1102");
336   expectedAddr.scope_id(netifsV6.front()-&gt;getIndex());
337   BOOST_CHECK_EQUAL(udpMcastFaces.front()-&gt;getRemoteUri(), FaceUri(udp::Endpoint(expectedAddr, 7012)));
338 }
339 BOOST_FIXTURE_TEST_CASE(Whitelist, UdpFactoryMcastFixture)
340 {
341 #ifdef __linux__
342   SKIP_IF_NOT_SUPERUSER();
343 #endif   SKIP_IF_UDP_MCAST_NETIF_COUNT_LT(1);
344   std::string CONFIG = R"CONFIG(
345     face_system
346     {
347       udp
348       {
349         whitelist
350         {
351           ifname %ifname
352         }
353       }
354     }
355   )CONFIG";
356   boost::replace_first(CONFIG, "%ifname", netifs.front()-&gt;getName());
357   parseConfig(CONFIG, false);
358   auto udpMcastFaces = this-&gt;listUdp4McastFaces();
359   BOOST_CHECK_LE(udpMcastFaces.size(), 1);
360   auto udpMcastFacesV6 = this-&gt;listUdp6McastFaces();
361   BOOST_CHECK_LE(udpMcastFacesV6.size(), 1);
362   udpMcastFaces.insert(udpMcastFaces.end(), udpMcastFacesV6.begin(), udpMcastFacesV6.end());
363   BOOST_CHECK_GE(udpMcastFaces.size(), 1);
364   BOOST_CHECK(std::all_of(udpMcastFaces.begin(), udpMcastFaces.end(),
365                           [this] (const Face* face) { return isFaceOnNetif(*face, *netifs.front()); }));
366 }
367 BOOST_FIXTURE_TEST_CASE(Blacklist, UdpFactoryMcastFixture)
368 {
369 #ifdef __linux__
370   SKIP_IF_NOT_SUPERUSER();
371 #endif   SKIP_IF_UDP_MCAST_NETIF_COUNT_LT(1);
372   std::string CONFIG = R"CONFIG(
373     face_system
374     {
375       udp
376       {
377         blacklist
378         {
379           ifname %ifname
380         }
381       }
382     }
383   )CONFIG";
384   boost::replace_first(CONFIG, "%ifname", netifs.front()-&gt;getName());
385   parseConfig(CONFIG, false);
386   auto udpMcastFaces = this-&gt;listUdp4McastFaces();
387   if (!netifsV4.empty())
388     BOOST_CHECK_GE(udpMcastFaces.size(), netifsV4.size() - 1);
389   auto udpMcastFacesV6 = this-&gt;listUdp6McastFaces();
390   if (!netifsV6.empty())
391     BOOST_CHECK_GE(udpMcastFacesV6.size(), netifsV6.size() - 1);
392   udpMcastFaces.insert(udpMcastFaces.end(), udpMcastFacesV6.begin(), udpMcastFacesV6.end());
393   BOOST_CHECK_LT(udpMcastFaces.size(), netifsV4.size() + netifsV6.size());
394   BOOST_CHECK(std::none_of(udpMcastFaces.begin(), udpMcastFaces.end(),
395                            [this] (const Face* face) { return isFaceOnNetif(*face, *netifs.front()); }));
396 }
397 BOOST_FIXTURE_TEST_CASE(ChangePredicate, UdpFactoryMcastFixture)
398 {
399 #ifdef __linux__
400   SKIP_IF_NOT_SUPERUSER();
401 #endif   SKIP_IF_UDP_MCAST_NETIF_COUNT_LT(2);
402   std::string CONFIG1 = R"CONFIG(
403     face_system
404     {
405       udp
406       {
407         whitelist
408         {
409           ifname %ifname
410         }
411       }
412     }
413   )CONFIG";
414   std::string CONFIG2 = CONFIG1;
415   boost::replace_first(CONFIG1, "%ifname", netifs.front()-&gt;getName());
416   boost::replace_first(CONFIG2, "%ifname", netifs.back()-&gt;getName());
417   parseConfig(CONFIG1, false);
418   auto udpMcastFaces = this-&gt;listUdp4McastFaces();
419   auto udpMcastFacesV6 = this-&gt;listUdp6McastFaces();
420   udpMcastFaces.insert(udpMcastFaces.end(), udpMcastFacesV6.begin(), udpMcastFacesV6.end());
421   BOOST_CHECK_GE(udpMcastFaces.size(), 1);
422   BOOST_CHECK(std::all_of(udpMcastFaces.begin(), udpMcastFaces.end(),
423                           [this] (const Face* face) { return isFaceOnNetif(*face, *netifs.front()); }));
424   parseConfig(CONFIG2, false);
425   g_io.poll();
426   udpMcastFaces = this-&gt;listUdp4McastFaces();
427   udpMcastFacesV6 = this-&gt;listUdp6McastFaces();
428   udpMcastFaces.insert(udpMcastFaces.end(), udpMcastFacesV6.begin(), udpMcastFacesV6.end());
429   BOOST_CHECK_GE(udpMcastFaces.size(), 1);
430   BOOST_CHECK(std::all_of(udpMcastFaces.begin(), udpMcastFaces.end(),
431                           [this] (const Face* face) { return isFaceOnNetif(*face, *netifs.back()); }));
432 }
433 BOOST_AUTO_TEST_CASE(Omitted)
434 {
435   const std::string CONFIG = R"CONFIG(
436     face_system
437     {
438     }
439   )CONFIG";
440   parseConfig(CONFIG, true);
441   parseConfig(CONFIG, false);
442 <a name="0"></a>
443   BOOST_CHECK_EQUAL(factory.getChannels().size(), 0);
444   BOOST_CHECK_EQUAL(this-&gt;listFacesByScheme("udp4", ndn::nfd::LINK_TYPE_MULTI_ACCESS).size(), 0);
445 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>  BOOST_CHECK_EQUAL(this-&gt;listFacesByScheme("udp6", ndn::nfd::LINK_TYPE_MULTI_ACCESS).size(), 0);
446 }
447 BOOST_AUTO_TEST_CASE(AllDisabled)
448 {
449   const std::string CONFIG = R"CONFIG(
450     face_system
451     {
452       udp
453       {
454         enable_v4 no
455         enable_v6 no
456         mcast no
457       }
458     }
459   )CONFIG";
460   BOOST_CHECK_THROW(parseConfig(CONFIG, true), ConfigFile::Error);
461   BOOST_CHECK_THROW(parseConfig(CONFIG, false), ConfigFile::Error);
462 }
463 BOOST_AUTO_TEST_CASE(BadListen)
464 {
465   const std::string CONFIG = R"CONFIG(
466     face_system
467     {
468       udp
469       {
470         listen hello
471       }
472     }
473   )CONFIG";
474   BOOST_CHECK_THROW(parseConfig(CONFIG, true), ConfigFile::Error);
475   BOOST_CHECK_THROW(parseConfig(CONFIG, false), ConfigFile::Error);
476 }
477 BOOST_AUTO_TEST_CASE(BadPort)
478 {
479   const std::string CONFIG1 = R"CONFIG(
480     face_system
481     {
482       udp
483       {
484         port hello
485       }
486     }
487   )CONFIG";
488   BOOST_CHECK_THROW(parseConfig(CONFIG1, true), ConfigFile::Error);</b></font>
489   BOOST_CHECK_THROW(parseConfig(CONFIG1, false), ConfigFile::Error);
490   const std::string CONFIG2 = R"CONFIG(
491     face_system
492     {
493       udp
494       {
495         port -1
496       }
497     }
498   )CONFIG";
499   BOOST_CHECK_THROW(parseConfig(CONFIG2, true), ConfigFile::Error);
500   BOOST_CHECK_THROW(parseConfig(CONFIG2, false), ConfigFile::Error);
501   const std::string CONFIG3 = R"CONFIG(
502     face_system
503     {
504       udp
505       {
506         port 65536
507       }
508     }
509   )CONFIG";
510   BOOST_CHECK_THROW(parseConfig(CONFIG3, true), ConfigFile::Error);
511   BOOST_CHECK_THROW(parseConfig(CONFIG3, false), ConfigFile::Error);
512 }
513 BOOST_AUTO_TEST_CASE(BadIdleTimeout)
514 {
515   const std::string CONFIG1 = R"CONFIG(
516     face_system
517     {
518       udp
519       {
520         idle_timeout hello
521       }
522     }
523   )CONFIG";
524   BOOST_CHECK_THROW(parseConfig(CONFIG1, true), ConfigFile::Error);
525   BOOST_CHECK_THROW(parseConfig(CONFIG1, false), ConfigFile::Error);
526   const std::string CONFIG2 = R"CONFIG(
527     face_system
528     {
529       udp
530       {
531         idle_timeout -15
532       }
533     }
534   )CONFIG";
535   BOOST_CHECK_THROW(parseConfig(CONFIG2, true), ConfigFile::Error);
536   BOOST_CHECK_THROW(parseConfig(CONFIG2, false), ConfigFile::Error);
537 }
538 BOOST_AUTO_TEST_CASE(BadMtu)
539 {
540   const std::string CONFIG1 = R"CONFIG(
541     face_system
542     {
543       udp
544       {
545         unicast_mtu hello
546       }
547     }
548   )CONFIG";
549   BOOST_CHECK_THROW(parseConfig(CONFIG1, true), ConfigFile::Error);
550   BOOST_CHECK_THROW(parseConfig(CONFIG1, false), ConfigFile::Error);
551   const std::string CONFIG2 = R"CONFIG(
552     face_system
553     {
554       udp
555       {
556         unicast_mtu 63
557       }
558     }
559   )CONFIG";
560   BOOST_CHECK_THROW(parseConfig(CONFIG2, true), ConfigFile::Error);
561   BOOST_CHECK_THROW(parseConfig(CONFIG2, false), ConfigFile::Error);
562   const std::string CONFIG3 = R"CONFIG(
563     face_system
564     {
565       udp
566       {
567         unicast_mtu 8801
568       }
569     }
570   )CONFIG";
571 <a name="1"></a>
572   BOOST_CHECK_THROW(parseConfig(CONFIG3, true), ConfigFile::Error);
573   BOOST_CHECK_THROW(parseConfig(CONFIG3, false), ConfigFile::Error);
574 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>}
575 BOOST_AUTO_TEST_CASE(BadMcast)
576 {
577   const std::string CONFIG = R"CONFIG(
578     face_system
579     {
580       udp
581       {
582         mcast hello
583       }
584     }
585   )CONFIG";
586   BOOST_CHECK_THROW(parseConfig(CONFIG, true), ConfigFile::Error);
587   BOOST_CHECK_THROW(parseConfig(CONFIG, false), ConfigFile::Error);
588 }
589 BOOST_AUTO_TEST_CASE(BadMcastGroupV4)
590 {
591   const std::string CONFIG1 = R"CONFIG(
592     face_system
593     {
594       udp
595       {
596         mcast_group hello
597       }
598     }
599   )CONFIG";
600   BOOST_CHECK_THROW(parseConfig(CONFIG1, true), ConfigFile::Error);
601   BOOST_CHECK_THROW(parseConfig(CONFIG1, false), ConfigFile::Error);</b></font>
602   const std::string CONFIG2 = R"CONFIG(
603     face_system
604     {
605       udp
606       {
607         mcast_group 10.0.0.1
608       }
609     }
610   )CONFIG";
611   BOOST_CHECK_THROW(parseConfig(CONFIG2, true), ConfigFile::Error);
612   BOOST_CHECK_THROW(parseConfig(CONFIG2, false), ConfigFile::Error);
613   const std::string CONFIG3 = R"CONFIG(
614     face_system
615     {
616       udp
617       {
618         mcast_group ff02::1234
619       }
620     }
621   )CONFIG";
622   BOOST_CHECK_THROW(parseConfig(CONFIG3, true), ConfigFile::Error);
623   BOOST_CHECK_THROW(parseConfig(CONFIG3, false), ConfigFile::Error);
624 }
625 BOOST_AUTO_TEST_CASE(BadMcastGroupV6)
626 {
627   const std::string CONFIG1 = R"CONFIG(
628     face_system
629     {
630       udp
631       {
632         mcast_group_v6 foo
633       }
634     }
635   )CONFIG";
636   BOOST_CHECK_THROW(parseConfig(CONFIG1, true), ConfigFile::Error);
637   BOOST_CHECK_THROW(parseConfig(CONFIG1, false), ConfigFile::Error);
638   const std::string CONFIG2 = R"CONFIG(
639     face_system
640     {
641       udp
642       {
643         mcast_group_v6 fe80::1234
644       }
645     }
646   )CONFIG";
647   BOOST_CHECK_THROW(parseConfig(CONFIG2, true), ConfigFile::Error);
648   BOOST_CHECK_THROW(parseConfig(CONFIG2, false), ConfigFile::Error);
649   const std::string CONFIG3 = R"CONFIG(
650     face_system
651     {
652       udp
653       {
654         mcast_group_v6 224.0.23.170
655       }
656     }
657   )CONFIG";
658   BOOST_CHECK_THROW(parseConfig(CONFIG3, true), ConfigFile::Error);
659   BOOST_CHECK_THROW(parseConfig(CONFIG3, false), ConfigFile::Error);
660 }
661 BOOST_AUTO_TEST_CASE(BadMcastPortV4)
662 {
663   const std::string CONFIG1 = R"CONFIG(
664     face_system
665     {
666       udp
667       {
668         mcast_port hey
669       }
670     }
671   )CONFIG";
672   BOOST_CHECK_THROW(parseConfig(CONFIG1, true), ConfigFile::Error);
673   BOOST_CHECK_THROW(parseConfig(CONFIG1, false), ConfigFile::Error);
674   const std::string CONFIG2 = R"CONFIG(
675     face_system
676     {
677       udp
678       {
679         mcast_port 99999
680       }
681     }
682   )CONFIG";
683   BOOST_CHECK_THROW(parseConfig(CONFIG2, true), ConfigFile::Error);
684   BOOST_CHECK_THROW(parseConfig(CONFIG2, false), ConfigFile::Error);
685 }
686 BOOST_AUTO_TEST_CASE(BadMcastPortV6)
687 {
688   const std::string CONFIG1 = R"CONFIG(
689     face_system
690     {
691       udp
692       {
693         mcast_port_v6 bar
694       }
695     }
696   )CONFIG";
697   BOOST_CHECK_THROW(parseConfig(CONFIG1, true), ConfigFile::Error);
698   BOOST_CHECK_THROW(parseConfig(CONFIG1, false), ConfigFile::Error);
699   const std::string CONFIG2 = R"CONFIG(
700     face_system
701     {
702       udp
703       {
704         mcast_port_v6 99999
705       }
706     }
707   )CONFIG";
708   BOOST_CHECK_THROW(parseConfig(CONFIG2, true), ConfigFile::Error);
709   BOOST_CHECK_THROW(parseConfig(CONFIG2, false), ConfigFile::Error);
710 }
711 BOOST_AUTO_TEST_CASE(UnknownOption)
712 {
713   const std::string CONFIG = R"CONFIG(
714     face_system
715     {
716       udp
717       {
718         hello
719       }
720     }
721   )CONFIG";
722   BOOST_CHECK_THROW(parseConfig(CONFIG, true), ConfigFile::Error);
723   BOOST_CHECK_THROW(parseConfig(CONFIG, false), ConfigFile::Error);
724 }
725 BOOST_AUTO_TEST_SUITE_END() 
726 BOOST_AUTO_TEST_CASE(GetChannels)
727 {
728   BOOST_CHECK_EQUAL(factory.getChannels().empty(), true);
729   std::set&lt;std::string&gt; expected;
730   expected.insert(createChannel("127.0.0.1", 20070)-&gt;getUri().toString());
731   expected.insert(createChannel("127.0.0.1", 20071)-&gt;getUri().toString());
732   expected.insert(createChannel("::1", 20071)-&gt;getUri().toString());
733   checkChannelListEqual(factory, expected);
734 }
735 BOOST_FIXTURE_TEST_CASE(CreateChannel, UdpFactoryMcastFixture)
736 {
737   auto channel1 = createChannel("127.0.0.1", 20070);
738   auto channel1a = createChannel("127.0.0.1", 20070);
739   BOOST_CHECK_EQUAL(channel1, channel1a);
740   BOOST_CHECK_EQUAL(channel1-&gt;getUri().toString(), "udp4://127.0.0.1:20070");
741   auto channel2 = createChannel("127.0.0.1", 20071);
742   BOOST_CHECK_NE(channel1, channel2);
743   auto channel3 = createChannel("::1", 20071);
744   BOOST_CHECK_NE(channel2, channel3);
745   BOOST_CHECK_EQUAL(channel3-&gt;getUri().toString(), "udp6://[::1]:20071");
746 #ifdef __linux__
747   SKIP_IF_NOT_SUPERUSER();
748 #endif 
749   if (!netifsV4.empty()) {
750     auto mcastFace = createMulticastFace("127.0.0.1", "224.0.0.254", 20072);
751     BOOST_CHECK_EXCEPTION(createChannel("127.0.0.1", 20072), UdpFactory::Error,
752                           [] (const UdpFactory::Error&amp; e) {
753                             return strcmp(e.what(),
754                                           "Cannot create UDP channel on 127.0.0.1:20072, "
755                                           "endpoint already allocated to a UDP multicast face") == 0;
756                           });
757   }
758   if (!netifsV6.empty()) {
759     auto mcastFace = createMulticastFace("::1", "ff02::114", 20072);
760     BOOST_CHECK_EXCEPTION(createChannel("::1", 20072), UdpFactory::Error,
761                           [] (const UdpFactory::Error&amp; e) {
762                             return strcmp(e.what(),
763                                           "Cannot create UDP channel on [::1]:20072, "
764                                           "endpoint already allocated to a UDP multicast face") == 0;
765                           });
766   }
767 }
768 BOOST_FIXTURE_TEST_CASE(CreateMulticastFaceV4, UdpFactoryMcastFixture)
769 {
770 #ifdef __linux__
771   SKIP_IF_NOT_SUPERUSER();
772 #endif   SKIP_IF_UDP_MCAST_V4_NETIF_COUNT_LT(1);
773   auto multicastFace1  = createMulticastFace("127.0.0.1", "224.0.0.254", 20070);
774   auto multicastFace1a = createMulticastFace("127.0.0.1", "224.0.0.254", 20070);
775   auto multicastFace2  = createMulticastFace("127.0.0.1", "224.0.0.254", 20030);
776   BOOST_CHECK_EQUAL(multicastFace1, multicastFace1a);
777   BOOST_CHECK_NE(multicastFace1, multicastFace2);
778   auto address = findNonLoopbackAddressForMulticastFace(ndn::net::AddressFamily::V4);
779   if (!address.is_unspecified()) {
780     auto multicastFace3  = createMulticastFace(address.to_string(), "224.0.0.254", 20070);
781     BOOST_CHECK_NE(multicastFace1, multicastFace3);
782     BOOST_CHECK_NE(multicastFace2, multicastFace3);
783   }
784   auto channel = createChannel("127.0.0.1", 20071);
785   BOOST_CHECK_EXCEPTION(createMulticastFace("127.0.0.1", "224.0.0.254", 20071), UdpFactory::Error,
786                         [] (const UdpFactory::Error&amp; e) {
787                           return strcmp(e.what(),
788                                         "Cannot create UDP multicast face on 127.0.0.1:20071, "
789                                         "endpoint already allocated to a UDP channel") == 0;
790                         });
791   BOOST_CHECK_EXCEPTION(createMulticastFace("127.0.0.1", "224.0.0.42", 20070), UdpFactory::Error,
792                         [] (const UdpFactory::Error&amp; e) {
793                           return strcmp(e.what(),
794                                         "Cannot create UDP multicast face on 127.0.0.1:20070, "
795                                         "endpoint already allocated to a different UDP multicast face") == 0;
796                         });
797 }
798 BOOST_FIXTURE_TEST_CASE(CreateMulticastFaceV6, UdpFactoryMcastFixture)
799 {
800 #ifdef __linux__
801   SKIP_IF_NOT_SUPERUSER();
802 #endif   SKIP_IF_UDP_MCAST_V6_NETIF_COUNT_LT(1);
803   auto multicastFace1  = createMulticastFace("::1", "ff02::114", 20070);
804   auto multicastFace1a = createMulticastFace("::1", "ff02::114", 20070);
805   auto multicastFace2  = createMulticastFace("::1", "ff02::114", 20030);
806   BOOST_CHECK_EQUAL(multicastFace1, multicastFace1a);
807   BOOST_CHECK_NE(multicastFace1, multicastFace2);
808   auto address = findNonLoopbackAddressForMulticastFace(ndn::net::AddressFamily::V6);
809   if (!address.is_unspecified()) {
810     auto multicastFace3  = createMulticastFace(address.to_string(), "ff02::114", 20070);
811     BOOST_CHECK_NE(multicastFace1, multicastFace3);
812     BOOST_CHECK_NE(multicastFace2, multicastFace3);
813   }
814   auto channel = createChannel("::1", 20071);
815   BOOST_CHECK_EXCEPTION(createMulticastFace("::1", "ff02::114", 20071), UdpFactory::Error,
816                         [] (const UdpFactory::Error&amp; e) {
817                           return strcmp(e.what(),
818                                         "Cannot create UDP multicast face on [::1]:20071, "
819                                         "endpoint already allocated to a UDP channel") == 0;
820                         });
821   BOOST_CHECK_EXCEPTION(createMulticastFace("::1", "ff02::42", 20070), UdpFactory::Error,
822                         [] (const UdpFactory::Error&amp; e) {
823                           return strcmp(e.what(),
824                                         "Cannot create UDP multicast face on [::1]:20070, "
825                                         "endpoint already allocated to a different UDP multicast face") == 0;
826                         });
827 }
828 BOOST_AUTO_TEST_CASE(CreateFace)
829 {
830   createFace(factory,
831              FaceUri("udp4://127.0.0.1:6363"),
832              {},
833              {ndn::nfd::FACE_PERSISTENCY_PERSISTENT, {}, {}, {}, false, false, false},
834              {CreateFaceExpectedResult::FAILURE, 504, "No channels available to connect"});
835   createChannel("127.0.0.1", 20071);
836   createFace(factory,
837              FaceUri("udp4://127.0.0.1:6363"),
838              {},
839              {ndn::nfd::FACE_PERSISTENCY_PERSISTENT, {}, {}, {}, false, false, false},
840              {CreateFaceExpectedResult::SUCCESS, 0, ""});
841   createFace(factory,
842              FaceUri("udp4://127.0.0.1:6363"),
843              {},
844              {ndn::nfd::FACE_PERSISTENCY_PERMANENT, {}, {}, {}, false, false, false},
845              {CreateFaceExpectedResult::SUCCESS, 0, ""});
846   createFace(factory,
847              FaceUri("udp4://127.0.0.1:20072"),
848              {},
849              {ndn::nfd::FACE_PERSISTENCY_PERMANENT, {}, {}, {}, false, false, false},
850              {CreateFaceExpectedResult::SUCCESS, 0, ""});
851   createFace(factory,
852              FaceUri("udp4://127.0.0.1:20073"),
853              {},
854              {ndn::nfd::FACE_PERSISTENCY_PERMANENT, {}, {}, {}, false, true, false},
855              {CreateFaceExpectedResult::SUCCESS, 0, ""});
856   createFace(factory,
857              FaceUri("udp4://127.0.0.1:20073"),
858              {},
859              {ndn::nfd::FACE_PERSISTENCY_PERMANENT, {}, {}, {}, false, false, true},
860              {CreateFaceExpectedResult::SUCCESS, 0, ""});
861   createFace(factory,
862              FaceUri("udp4://127.0.0.1:20074"),
863              {},
864              {ndn::nfd::FACE_PERSISTENCY_PERMANENT, {}, {}, 1000, false, false, false},
865              {CreateFaceExpectedResult::SUCCESS, 0, ""});
866 }
867 BOOST_AUTO_TEST_CASE(UnsupportedCreateFace)
868 {
869   createChannel("127.0.0.1", 20071);
870   createFace(factory,
871              FaceUri("udp4://127.0.0.1:20072"),
872              FaceUri("udp4://127.0.0.1:20071"),
873              {ndn::nfd::FACE_PERSISTENCY_PERSISTENT, {}, {}, {}, false, false, false},
874              {CreateFaceExpectedResult::FAILURE, 406,
875               "Unicast UDP faces cannot be created with a LocalUri"});
876   createFace(factory,
877              FaceUri("udp4://127.0.0.1:20072"),
878              {},
879              {ndn::nfd::FACE_PERSISTENCY_ON_DEMAND, {}, {}, {}, false, false, false},
880              {CreateFaceExpectedResult::FAILURE, 406,
881               "Outgoing UDP faces do not support on-demand persistency"});
882   createFace(factory,
883              FaceUri("udp4://233.252.0.1:23252"),
884              {},
885              {ndn::nfd::FACE_PERSISTENCY_PERSISTENT, {}, {}, {}, false, false, false},
886              {CreateFaceExpectedResult::FAILURE, 406,
887               "Cannot create multicast UDP faces"});
888   createFace(factory,
889              FaceUri("udp4://127.0.0.1:20072"),
890              {},
891              {ndn::nfd::FACE_PERSISTENCY_PERSISTENT, {}, {}, {}, true, false, false},
892              {CreateFaceExpectedResult::FAILURE, 406,
893               "Local fields can only be enabled on faces with local scope"});
894 }
895 BOOST_AUTO_TEST_SUITE_END() BOOST_AUTO_TEST_SUITE_END() 
} } } </pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
