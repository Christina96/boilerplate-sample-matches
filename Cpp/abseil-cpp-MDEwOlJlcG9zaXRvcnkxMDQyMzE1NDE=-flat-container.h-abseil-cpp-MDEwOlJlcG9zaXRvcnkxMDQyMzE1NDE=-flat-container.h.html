
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-container.h</h3>
            <pre><code>1  #ifndef ABSL_ALGORITHM_CONTAINER_H_
2  #define ABSL_ALGORITHM_CONTAINER_H_
3  #include <algorithm>
4  #include <cassert>
5  #include <iterator>
6  #include <numeric>
7  #include <type_traits>
8  #include <unordered_map>
9  #include <unordered_set>
10  #include <utility>
11  #include <vector>
12  #include "absl/algorithm/algorithm.h"
13  #include "absl/base/macros.h"
14  #include "absl/meta/type_traits.h"
15  namespace absl {
16  ABSL_NAMESPACE_BEGIN
17  namespace container_algorithm_internal {
18  using std::begin;
19  using std::end;
20  template <typename C>
21  using ContainerIter = decltype(begin(std::declval<C&>()));
22  template <typename C1, typename C2>
23  using ContainerIterPairType =
24      decltype(std::make_pair(ContainerIter<C1>(), ContainerIter<C2>()));
25  template <typename C>
26  using ContainerDifferenceType = decltype(std::distance(
27      std::declval<ContainerIter<C>>(), std::declval<ContainerIter<C>>()));
28  template <typename C>
29  using ContainerPointerType =
30      typename std::iterator_traits<ContainerIter<C>>::pointer;
31  template <typename C>
32  ContainerIter<C> c_begin(C& c) {
33    return begin(c);
34  }
35  template <typename C>
36  ContainerIter<C> c_end(C& c) {
37    return end(c);
38  }
39  template <typename T>
40  struct IsUnorderedContainer : std::false_type {};
41  template <class Key, class T, class Hash, class KeyEqual, class Allocator>
42  struct IsUnorderedContainer<
43      std::unordered_map<Key, T, Hash, KeyEqual, Allocator>> : std::true_type {};
44  template <class Key, class Hash, class KeyEqual, class Allocator>
45  struct IsUnorderedContainer<std::unordered_set<Key, Hash, KeyEqual, Allocator>>
46      : std::true_type {};
47  template <class C>
48  auto c_size(C& c) -> decltype(c.size()) {
49    return c.size();
50  }
51  template <class T, std::size_t N>
52  constexpr std::size_t c_size(T (&)[N]) {
53    return N;
54  }
55  }  
56  template <typename C, typename EqualityComparable>
57  bool c_linear_search(const C& c, EqualityComparable&& value) {
58    return linear_search(container_algorithm_internal::c_begin(c),
59                         container_algorithm_internal::c_end(c),
60                         std::forward<EqualityComparable>(value));
61  }
62  template <typename C>
63  container_algorithm_internal::ContainerDifferenceType<const C> c_distance(
64      const C& c) {
65    return std::distance(container_algorithm_internal::c_begin(c),
66                         container_algorithm_internal::c_end(c));
67  }
68  template <typename C, typename Pred>
69  bool c_all_of(const C& c, Pred&& pred) {
70    return std::all_of(container_algorithm_internal::c_begin(c),
71                       container_algorithm_internal::c_end(c),
72                       std::forward<Pred>(pred));
73  }
74  template <typename C, typename Pred>
75  bool c_any_of(const C& c, Pred&& pred) {
76    return std::any_of(container_algorithm_internal::c_begin(c),
77                       container_algorithm_internal::c_end(c),
78                       std::forward<Pred>(pred));
79  }
80  template <typename C, typename Pred>
81  bool c_none_of(const C& c, Pred&& pred) {
82    return std::none_of(container_algorithm_internal::c_begin(c),
83                        container_algorithm_internal::c_end(c),
84                        std::forward<Pred>(pred));
85  }
86  template <typename C, typename Function>
87  decay_t<Function> c_for_each(C&& c, Function&& f) {
88    return std::for_each(container_algorithm_internal::c_begin(c),
89                         container_algorithm_internal::c_end(c),
90                         std::forward<Function>(f));
91  }
92  template <typename C, typename T>
93  container_algorithm_internal::ContainerIter<C> c_find(C& c, T&& value) {
94    return std::find(container_algorithm_internal::c_begin(c),
95                     container_algorithm_internal::c_end(c),
96                     std::forward<T>(value));
97  }
98  template <typename C, typename Pred>
99  container_algorithm_internal::ContainerIter<C> c_find_if(C& c, Pred&& pred) {
100    return std::find_if(container_algorithm_internal::c_begin(c),
101                        container_algorithm_internal::c_end(c),
102                        std::forward<Pred>(pred));
103  }
104  template <typename C, typename Pred>
105  container_algorithm_internal::ContainerIter<C> c_find_if_not(C& c,
106                                                               Pred&& pred) {
107    return std::find_if_not(container_algorithm_internal::c_begin(c),
108                            container_algorithm_internal::c_end(c),
109                            std::forward<Pred>(pred));
110  }
111  template <typename Sequence1, typename Sequence2>
<span onclick='openModal()' class='match'>112  container_algorithm_internal::ContainerIter<Sequence1> c_find_end(
113      Sequence1& sequence, Sequence2& subsequence) {
114    return std::find_end(container_algorithm_internal::c_begin(sequence),
</span>115                         container_algorithm_internal::c_end(sequence),
116                         container_algorithm_internal::c_begin(subsequence),
117                         container_algorithm_internal::c_end(subsequence));
118  }
119  template <typename Sequence1, typename Sequence2, typename BinaryPredicate>
120  container_algorithm_internal::ContainerIter<Sequence1> c_find_end(
121      Sequence1& sequence, Sequence2& subsequence, BinaryPredicate&& pred) {
122    return std::find_end(container_algorithm_internal::c_begin(sequence),
123                         container_algorithm_internal::c_end(sequence),
124                         container_algorithm_internal::c_begin(subsequence),
125                         container_algorithm_internal::c_end(subsequence),
126                         std::forward<BinaryPredicate>(pred));
127  }
128  template <typename C1, typename C2>
129  container_algorithm_internal::ContainerIter<C1> c_find_first_of(C1& container,
130                                                                  C2& options) {
131    return std::find_first_of(container_algorithm_internal::c_begin(container),
132                              container_algorithm_internal::c_end(container),
133                              container_algorithm_internal::c_begin(options),
134                              container_algorithm_internal::c_end(options));
135  }
136  template <typename C1, typename C2, typename BinaryPredicate>
137  container_algorithm_internal::ContainerIter<C1> c_find_first_of(
138      C1& container, C2& options, BinaryPredicate&& pred) {
139    return std::find_first_of(container_algorithm_internal::c_begin(container),
140                              container_algorithm_internal::c_end(container),
141                              container_algorithm_internal::c_begin(options),
142                              container_algorithm_internal::c_end(options),
143                              std::forward<BinaryPredicate>(pred));
144  }
145  template <typename Sequence>
146  container_algorithm_internal::ContainerIter<Sequence> c_adjacent_find(
147      Sequence& sequence) {
148    return std::adjacent_find(container_algorithm_internal::c_begin(sequence),
149                              container_algorithm_internal::c_end(sequence));
150  }
151  template <typename Sequence, typename BinaryPredicate>
152  container_algorithm_internal::ContainerIter<Sequence> c_adjacent_find(
153      Sequence& sequence, BinaryPredicate&& pred) {
154    return std::adjacent_find(container_algorithm_internal::c_begin(sequence),
155                              container_algorithm_internal::c_end(sequence),
156                              std::forward<BinaryPredicate>(pred));
157  }
158  template <typename C, typename T>
159  container_algorithm_internal::ContainerDifferenceType<const C> c_count(
160      const C& c, T&& value) {
161    return std::count(container_algorithm_internal::c_begin(c),
162                      container_algorithm_internal::c_end(c),
163                      std::forward<T>(value));
164  }
165  template <typename C, typename Pred>
166  container_algorithm_internal::ContainerDifferenceType<const C> c_count_if(
167      const C& c, Pred&& pred) {
168    return std::count_if(container_algorithm_internal::c_begin(c),
169                         container_algorithm_internal::c_end(c),
170                         std::forward<Pred>(pred));
171  }
172  template <typename C1, typename C2>
173  container_algorithm_internal::ContainerIterPairType<C1, C2> c_mismatch(C1& c1,
174                                                                         C2& c2) {
175    auto first1 = container_algorithm_internal::c_begin(c1);
176    auto last1 = container_algorithm_internal::c_end(c1);
177    auto first2 = container_algorithm_internal::c_begin(c2);
178    auto last2 = container_algorithm_internal::c_end(c2);
179    for (; first1 != last1 && first2 != last2; ++first1, (void)++first2) {
180      if (!(*first1 == *first2)) {
181        break;
182      }
183    }
184    return std::make_pair(first1, first2);
185  }
186  template <typename C1, typename C2, typename BinaryPredicate>
187  container_algorithm_internal::ContainerIterPairType<C1, C2> c_mismatch(
188      C1& c1, C2& c2, BinaryPredicate pred) {
189    auto first1 = container_algorithm_internal::c_begin(c1);
190    auto last1 = container_algorithm_internal::c_end(c1);
191    auto first2 = container_algorithm_internal::c_begin(c2);
192    auto last2 = container_algorithm_internal::c_end(c2);
193    for (; first1 != last1 && first2 != last2; ++first1, (void)++first2) {
194      if (!pred(*first1, *first2)) {
195        break;
196      }
197    }
198    return std::make_pair(first1, first2);
199  }
200  template <typename C1, typename C2>
201  bool c_equal(const C1& c1, const C2& c2) {
202    return ((container_algorithm_internal::c_size(c1) ==
203             container_algorithm_internal::c_size(c2)) &&
204            std::equal(container_algorithm_internal::c_begin(c1),
205                       container_algorithm_internal::c_end(c1),
206                       container_algorithm_internal::c_begin(c2)));
207  }
208  template <typename C1, typename C2, typename BinaryPredicate>
209  bool c_equal(const C1& c1, const C2& c2, BinaryPredicate&& pred) {
210    return ((container_algorithm_internal::c_size(c1) ==
211             container_algorithm_internal::c_size(c2)) &&
212            std::equal(container_algorithm_internal::c_begin(c1),
213                       container_algorithm_internal::c_end(c1),
214                       container_algorithm_internal::c_begin(c2),
215                       std::forward<BinaryPredicate>(pred)));
216  }
217  template <typename C1, typename C2>
218  bool c_is_permutation(const C1& c1, const C2& c2) {
219    using std::begin;
220    using std::end;
221    return c1.size() == c2.size() &&
222           std::is_permutation(begin(c1), end(c1), begin(c2));
223  }
224  template <typename C1, typename C2, typename BinaryPredicate>
225  bool c_is_permutation(const C1& c1, const C2& c2, BinaryPredicate&& pred) {
226    using std::begin;
227    using std::end;
228    return c1.size() == c2.size() &&
229           std::is_permutation(begin(c1), end(c1), begin(c2),
230                               std::forward<BinaryPredicate>(pred));
231  }
232  template <typename Sequence1, typename Sequence2>
233  container_algorithm_internal::ContainerIter<Sequence1> c_search(
234      Sequence1& sequence, Sequence2& subsequence) {
235    return std::search(container_algorithm_internal::c_begin(sequence),
236                       container_algorithm_internal::c_end(sequence),
237                       container_algorithm_internal::c_begin(subsequence),
238                       container_algorithm_internal::c_end(subsequence));
239  }
240  template <typename Sequence1, typename Sequence2, typename BinaryPredicate>
241  container_algorithm_internal::ContainerIter<Sequence1> c_search(
242      Sequence1& sequence, Sequence2& subsequence, BinaryPredicate&& pred) {
243    return std::search(container_algorithm_internal::c_begin(sequence),
244                       container_algorithm_internal::c_end(sequence),
245                       container_algorithm_internal::c_begin(subsequence),
246                       container_algorithm_internal::c_end(subsequence),
247                       std::forward<BinaryPredicate>(pred));
248  }
249  template <typename Sequence, typename Size, typename T>
250  container_algorithm_internal::ContainerIter<Sequence> c_search_n(
251      Sequence& sequence, Size count, T&& value) {
252    return std::search_n(container_algorithm_internal::c_begin(sequence),
253                         container_algorithm_internal::c_end(sequence), count,
254                         std::forward<T>(value));
255  }
256  template <typename Sequence, typename Size, typename T,
257            typename BinaryPredicate>
258  container_algorithm_internal::ContainerIter<Sequence> c_search_n(
259      Sequence& sequence, Size count, T&& value, BinaryPredicate&& pred) {
260    return std::search_n(container_algorithm_internal::c_begin(sequence),
261                         container_algorithm_internal::c_end(sequence), count,
262                         std::forward<T>(value),
263                         std::forward<BinaryPredicate>(pred));
264  }
265  template <typename InputSequence, typename OutputIterator>
266  OutputIterator c_copy(const InputSequence& input, OutputIterator output) {
267    return std::copy(container_algorithm_internal::c_begin(input),
268                     container_algorithm_internal::c_end(input), output);
269  }
270  template <typename C, typename Size, typename OutputIterator>
271  OutputIterator c_copy_n(const C& input, Size n, OutputIterator output) {
272    return std::copy_n(container_algorithm_internal::c_begin(input), n, output);
273  }
274  template <typename InputSequence, typename OutputIterator, typename Pred>
275  OutputIterator c_copy_if(const InputSequence& input, OutputIterator output,
276                           Pred&& pred) {
277    return std::copy_if(container_algorithm_internal::c_begin(input),
278                        container_algorithm_internal::c_end(input), output,
279                        std::forward<Pred>(pred));
280  }
281  template <typename C, typename BidirectionalIterator>
282  BidirectionalIterator c_copy_backward(const C& src,
283                                        BidirectionalIterator dest) {
284    return std::copy_backward(container_algorithm_internal::c_begin(src),
285                              container_algorithm_internal::c_end(src), dest);
286  }
287  template <typename C, typename OutputIterator>
288  OutputIterator c_move(C&& src, OutputIterator dest) {
289    return std::move(container_algorithm_internal::c_begin(src),
290                     container_algorithm_internal::c_end(src), dest);
291  }
292  template <typename C, typename BidirectionalIterator>
293  BidirectionalIterator c_move_backward(C&& src, BidirectionalIterator dest) {
294    return std::move_backward(container_algorithm_internal::c_begin(src),
295                              container_algorithm_internal::c_end(src), dest);
296  }
297  template <typename C1, typename C2>
298  container_algorithm_internal::ContainerIter<C2> c_swap_ranges(C1& c1, C2& c2) {
299    auto first1 = container_algorithm_internal::c_begin(c1);
300    auto last1 = container_algorithm_internal::c_end(c1);
301    auto first2 = container_algorithm_internal::c_begin(c2);
302    auto last2 = container_algorithm_internal::c_end(c2);
303    using std::swap;
304    for (; first1 != last1 && first2 != last2; ++first1, (void)++first2) {
305      swap(*first1, *first2);
306    }
307    return first2;
308  }
309  template <typename InputSequence, typename OutputIterator, typename UnaryOp>
310  OutputIterator c_transform(const InputSequence& input, OutputIterator output,
311                             UnaryOp&& unary_op) {
312    return std::transform(container_algorithm_internal::c_begin(input),
313                          container_algorithm_internal::c_end(input), output,
314                          std::forward<UnaryOp>(unary_op));
315  }
316  template <typename InputSequence1, typename InputSequence2,
317            typename OutputIterator, typename BinaryOp>
318  OutputIterator c_transform(const InputSequence1& input1,
319                             const InputSequence2& input2, OutputIterator output,
320                             BinaryOp&& binary_op) {
321    auto first1 = container_algorithm_internal::c_begin(input1);
322    auto last1 = container_algorithm_internal::c_end(input1);
323    auto first2 = container_algorithm_internal::c_begin(input2);
324    auto last2 = container_algorithm_internal::c_end(input2);
325    for (; first1 != last1 && first2 != last2;
326         ++first1, (void)++first2, ++output) {
327      *output = binary_op(*first1, *first2);
328    }
329    return output;
330  }
331  template <typename Sequence, typename T>
332  void c_replace(Sequence& sequence, const T& old_value, const T& new_value) {
333    std::replace(container_algorithm_internal::c_begin(sequence),
334                 container_algorithm_internal::c_end(sequence), old_value,
335                 new_value);
336  }
337  template <typename C, typename Pred, typename T>
338  void c_replace_if(C& c, Pred&& pred, T&& new_value) {
339    std::replace_if(container_algorithm_internal::c_begin(c),
340                    container_algorithm_internal::c_end(c),
341                    std::forward<Pred>(pred), std::forward<T>(new_value));
342  }
343  template <typename C, typename OutputIterator, typename T>
344  OutputIterator c_replace_copy(const C& c, OutputIterator result, T&& old_value,
345                                T&& new_value) {
346    return std::replace_copy(container_algorithm_internal::c_begin(c),
347                             container_algorithm_internal::c_end(c), result,
348                             std::forward<T>(old_value),
349                             std::forward<T>(new_value));
350  }
351  template <typename C, typename OutputIterator, typename Pred, typename T>
352  OutputIterator c_replace_copy_if(const C& c, OutputIterator result, Pred&& pred,
353                                   const T& new_value) {
354    return std::replace_copy_if(container_algorithm_internal::c_begin(c),
355                                container_algorithm_internal::c_end(c), result,
356                                std::forward<Pred>(pred), new_value);
357  }
358  template <typename C, typename T>
359  void c_fill(C& c, const T& value) {
360    std::fill(container_algorithm_internal::c_begin(c),
361              container_algorithm_internal::c_end(c), value);
362  }
363  template <typename C, typename Size, typename T>
364  void c_fill_n(C& c, Size n, const T& value) {
365    std::fill_n(container_algorithm_internal::c_begin(c), n, value);
366  }
367  template <typename C, typename Generator>
368  void c_generate(C& c, Generator&& gen) {
369    std::generate(container_algorithm_internal::c_begin(c),
370                  container_algorithm_internal::c_end(c),
371                  std::forward<Generator>(gen));
372  }
373  template <typename C, typename Size, typename Generator>
374  container_algorithm_internal::ContainerIter<C> c_generate_n(C& c, Size n,
375                                                              Generator&& gen) {
376    return std::generate_n(container_algorithm_internal::c_begin(c), n,
377                           std::forward<Generator>(gen));
378  }
379  template <typename C, typename OutputIterator, typename T>
380  OutputIterator c_remove_copy(const C& c, OutputIterator result,
381                               const T& value) {
382    return std::remove_copy(container_algorithm_internal::c_begin(c),
383                            container_algorithm_internal::c_end(c), result,
384                            value);
385  }
386  template <typename C, typename OutputIterator, typename Pred>
387  OutputIterator c_remove_copy_if(const C& c, OutputIterator result,
388                                  Pred&& pred) {
389    return std::remove_copy_if(container_algorithm_internal::c_begin(c),
390                               container_algorithm_internal::c_end(c), result,
391                               std::forward<Pred>(pred));
392  }
393  template <typename C, typename OutputIterator>
394  OutputIterator c_unique_copy(const C& c, OutputIterator result) {
395    return std::unique_copy(container_algorithm_internal::c_begin(c),
396                            container_algorithm_internal::c_end(c), result);
397  }
398  template <typename C, typename OutputIterator, typename BinaryPredicate>
399  OutputIterator c_unique_copy(const C& c, OutputIterator result,
400                               BinaryPredicate&& pred) {
401    return std::unique_copy(container_algorithm_internal::c_begin(c),
402                            container_algorithm_internal::c_end(c), result,
403                            std::forward<BinaryPredicate>(pred));
404  }
405  template <typename Sequence>
406  void c_reverse(Sequence& sequence) {
407    std::reverse(container_algorithm_internal::c_begin(sequence),
408                 container_algorithm_internal::c_end(sequence));
409  }
410  template <typename C, typename OutputIterator>
411  OutputIterator c_reverse_copy(const C& sequence, OutputIterator result) {
412    return std::reverse_copy(container_algorithm_internal::c_begin(sequence),
413                             container_algorithm_internal::c_end(sequence),
414                             result);
415  }
416  template <typename C,
417            typename Iterator = container_algorithm_internal::ContainerIter<C>>
418  Iterator c_rotate(C& sequence, Iterator middle) {
419    return absl::rotate(container_algorithm_internal::c_begin(sequence), middle,
420                        container_algorithm_internal::c_end(sequence));
421  }
422  template <typename C, typename OutputIterator>
423  OutputIterator c_rotate_copy(
424      const C& sequence,
425      container_algorithm_internal::ContainerIter<const C> middle,
426      OutputIterator result) {
427    return std::rotate_copy(container_algorithm_internal::c_begin(sequence),
428                            middle, container_algorithm_internal::c_end(sequence),
429                            result);
430  }
431  template <typename RandomAccessContainer, typename UniformRandomBitGenerator>
432  void c_shuffle(RandomAccessContainer& c, UniformRandomBitGenerator&& gen) {
433    std::shuffle(container_algorithm_internal::c_begin(c),
434                 container_algorithm_internal::c_end(c),
435                 std::forward<UniformRandomBitGenerator>(gen));
436  }
437  template <typename C, typename Pred>
438  bool c_is_partitioned(const C& c, Pred&& pred) {
439    return std::is_partitioned(container_algorithm_internal::c_begin(c),
440                               container_algorithm_internal::c_end(c),
441                               std::forward<Pred>(pred));
442  }
443  template <typename C, typename Pred>
444  container_algorithm_internal::ContainerIter<C> c_partition(C& c, Pred&& pred) {
445    return std::partition(container_algorithm_internal::c_begin(c),
446                          container_algorithm_internal::c_end(c),
447                          std::forward<Pred>(pred));
448  }
449  template <typename C, typename Pred>
450  container_algorithm_internal::ContainerIter<C> c_stable_partition(C& c,
451                                                                    Pred&& pred) {
452    return std::stable_partition(container_algorithm_internal::c_begin(c),
453                                 container_algorithm_internal::c_end(c),
454                                 std::forward<Pred>(pred));
455  }
456  template <typename C, typename OutputIterator1, typename OutputIterator2,
457            typename Pred>
458  std::pair<OutputIterator1, OutputIterator2> c_partition_copy(
459      const C& c, OutputIterator1 out_true, OutputIterator2 out_false,
460      Pred&& pred) {
461    return std::partition_copy(container_algorithm_internal::c_begin(c),
462                               container_algorithm_internal::c_end(c), out_true,
463                               out_false, std::forward<Pred>(pred));
464  }
465  template <typename C, typename Pred>
466  container_algorithm_internal::ContainerIter<C> c_partition_point(C& c,
467                                                                   Pred&& pred) {
468    return std::partition_point(container_algorithm_internal::c_begin(c),
469                                container_algorithm_internal::c_end(c),
470                                std::forward<Pred>(pred));
471  }
472  template <typename C>
473  void c_sort(C& c) {
474    std::sort(container_algorithm_internal::c_begin(c),
475              container_algorithm_internal::c_end(c));
476  }
477  template <typename C, typename LessThan>
478  void c_sort(C& c, LessThan&& comp) {
479    std::sort(container_algorithm_internal::c_begin(c),
480              container_algorithm_internal::c_end(c),
481              std::forward<LessThan>(comp));
482  }
483  template <typename C>
484  void c_stable_sort(C& c) {
485    std::stable_sort(container_algorithm_internal::c_begin(c),
486                     container_algorithm_internal::c_end(c));
487  }
488  template <typename C, typename LessThan>
489  void c_stable_sort(C& c, LessThan&& comp) {
490    std::stable_sort(container_algorithm_internal::c_begin(c),
491                     container_algorithm_internal::c_end(c),
492                     std::forward<LessThan>(comp));
493  }
494  template <typename C>
495  bool c_is_sorted(const C& c) {
496    return std::is_sorted(container_algorithm_internal::c_begin(c),
497                          container_algorithm_internal::c_end(c));
498  }
499  template <typename C, typename LessThan>
500  bool c_is_sorted(const C& c, LessThan&& comp) {
501    return std::is_sorted(container_algorithm_internal::c_begin(c),
502                          container_algorithm_internal::c_end(c),
503                          std::forward<LessThan>(comp));
504  }
505  template <typename RandomAccessContainer>
506  void c_partial_sort(
507      RandomAccessContainer& sequence,
508      container_algorithm_internal::ContainerIter<RandomAccessContainer> middle) {
509    std::partial_sort(container_algorithm_internal::c_begin(sequence), middle,
510                      container_algorithm_internal::c_end(sequence));
511  }
512  template <typename RandomAccessContainer, typename LessThan>
513  void c_partial_sort(
514      RandomAccessContainer& sequence,
515      container_algorithm_internal::ContainerIter<RandomAccessContainer> middle,
516      LessThan&& comp) {
517    std::partial_sort(container_algorithm_internal::c_begin(sequence), middle,
518                      container_algorithm_internal::c_end(sequence),
519                      std::forward<LessThan>(comp));
520  }
521  template <typename C, typename RandomAccessContainer>
522  container_algorithm_internal::ContainerIter<RandomAccessContainer>
523  c_partial_sort_copy(const C& sequence, RandomAccessContainer& result) {
524    return std::partial_sort_copy(container_algorithm_internal::c_begin(sequence),
525                                  container_algorithm_internal::c_end(sequence),
526                                  container_algorithm_internal::c_begin(result),
527                                  container_algorithm_internal::c_end(result));
528  }
529  template <typename C, typename RandomAccessContainer, typename LessThan>
530  container_algorithm_internal::ContainerIter<RandomAccessContainer>
531  c_partial_sort_copy(const C& sequence, RandomAccessContainer& result,
532                      LessThan&& comp) {
533    return std::partial_sort_copy(container_algorithm_internal::c_begin(sequence),
534                                  container_algorithm_internal::c_end(sequence),
535                                  container_algorithm_internal::c_begin(result),
536                                  container_algorithm_internal::c_end(result),
537                                  std::forward<LessThan>(comp));
538  }
539  template <typename C>
540  container_algorithm_internal::ContainerIter<C> c_is_sorted_until(C& c) {
541    return std::is_sorted_until(container_algorithm_internal::c_begin(c),
542                                container_algorithm_internal::c_end(c));
543  }
544  template <typename C, typename LessThan>
545  container_algorithm_internal::ContainerIter<C> c_is_sorted_until(
546      C& c, LessThan&& comp) {
547    return std::is_sorted_until(container_algorithm_internal::c_begin(c),
548                                container_algorithm_internal::c_end(c),
549                                std::forward<LessThan>(comp));
550  }
551  template <typename RandomAccessContainer>
552  void c_nth_element(
553      RandomAccessContainer& sequence,
554      container_algorithm_internal::ContainerIter<RandomAccessContainer> nth) {
555    std::nth_element(container_algorithm_internal::c_begin(sequence), nth,
556                     container_algorithm_internal::c_end(sequence));
557  }
558  template <typename RandomAccessContainer, typename LessThan>
559  void c_nth_element(
560      RandomAccessContainer& sequence,
561      container_algorithm_internal::ContainerIter<RandomAccessContainer> nth,
562      LessThan&& comp) {
563    std::nth_element(container_algorithm_internal::c_begin(sequence), nth,
564                     container_algorithm_internal::c_end(sequence),
565                     std::forward<LessThan>(comp));
566  }
567  template <typename Sequence, typename T>
568  container_algorithm_internal::ContainerIter<Sequence> c_lower_bound(
569      Sequence& sequence, const T& value) {
570    return std::lower_bound(container_algorithm_internal::c_begin(sequence),
571                            container_algorithm_internal::c_end(sequence), value);
572  }
573  template <typename Sequence, typename T, typename LessThan>
574  container_algorithm_internal::ContainerIter<Sequence> c_lower_bound(
575      Sequence& sequence, const T& value, LessThan&& comp) {
576    return std::lower_bound(container_algorithm_internal::c_begin(sequence),
577                            container_algorithm_internal::c_end(sequence), value,
578                            std::forward<LessThan>(comp));
579  }
580  template <typename Sequence, typename T>
581  container_algorithm_internal::ContainerIter<Sequence> c_upper_bound(
582      Sequence& sequence, const T& value) {
583    return std::upper_bound(container_algorithm_internal::c_begin(sequence),
584                            container_algorithm_internal::c_end(sequence), value);
585  }
586  template <typename Sequence, typename T, typename LessThan>
587  container_algorithm_internal::ContainerIter<Sequence> c_upper_bound(
588      Sequence& sequence, const T& value, LessThan&& comp) {
589    return std::upper_bound(container_algorithm_internal::c_begin(sequence),
590                            container_algorithm_internal::c_end(sequence), value,
591                            std::forward<LessThan>(comp));
592  }
593  template <typename Sequence, typename T>
594  container_algorithm_internal::ContainerIterPairType<Sequence, Sequence>
595  c_equal_range(Sequence& sequence, const T& value) {
596    return std::equal_range(container_algorithm_internal::c_begin(sequence),
597                            container_algorithm_internal::c_end(sequence), value);
598  }
599  template <typename Sequence, typename T, typename LessThan>
600  container_algorithm_internal::ContainerIterPairType<Sequence, Sequence>
601  c_equal_range(Sequence& sequence, const T& value, LessThan&& comp) {
602    return std::equal_range(container_algorithm_internal::c_begin(sequence),
603                            container_algorithm_internal::c_end(sequence), value,
604                            std::forward<LessThan>(comp));
605  }
606  template <typename Sequence, typename T>
607  bool c_binary_search(const Sequence& sequence, const T& value) {
608    return std::binary_search(container_algorithm_internal::c_begin(sequence),
609                              container_algorithm_internal::c_end(sequence),
610                              value);
611  }
612  template <typename Sequence, typename T, typename LessThan>
613  bool c_binary_search(const Sequence& sequence, const T& value,
614                       LessThan&& comp) {
615    return std::binary_search(container_algorithm_internal::c_begin(sequence),
616                              container_algorithm_internal::c_end(sequence),
617                              value, std::forward<LessThan>(comp));
618  }
619  template <typename C1, typename C2, typename OutputIterator>
620  OutputIterator c_merge(const C1& c1, const C2& c2, OutputIterator result) {
621    return std::merge(container_algorithm_internal::c_begin(c1),
622                      container_algorithm_internal::c_end(c1),
623                      container_algorithm_internal::c_begin(c2),
624                      container_algorithm_internal::c_end(c2), result);
625  }
626  template <typename C1, typename C2, typename OutputIterator, typename LessThan>
627  OutputIterator c_merge(const C1& c1, const C2& c2, OutputIterator result,
628                         LessThan&& comp) {
629    return std::merge(container_algorithm_internal::c_begin(c1),
630                      container_algorithm_internal::c_end(c1),
631                      container_algorithm_internal::c_begin(c2),
632                      container_algorithm_internal::c_end(c2), result,
633                      std::forward<LessThan>(comp));
634  }
635  template <typename C>
636  void c_inplace_merge(C& c,
637                       container_algorithm_internal::ContainerIter<C> middle) {
638    std::inplace_merge(container_algorithm_internal::c_begin(c), middle,
639                       container_algorithm_internal::c_end(c));
640  }
641  template <typename C, typename LessThan>
642  void c_inplace_merge(C& c,
643                       container_algorithm_internal::ContainerIter<C> middle,
644                       LessThan&& comp) {
645    std::inplace_merge(container_algorithm_internal::c_begin(c), middle,
646                       container_algorithm_internal::c_end(c),
647                       std::forward<LessThan>(comp));
648  }
649  template <typename C1, typename C2>
650  bool c_includes(const C1& c1, const C2& c2) {
651    return std::includes(container_algorithm_internal::c_begin(c1),
652                         container_algorithm_internal::c_end(c1),
653                         container_algorithm_internal::c_begin(c2),
654                         container_algorithm_internal::c_end(c2));
655  }
656  template <typename C1, typename C2, typename LessThan>
657  bool c_includes(const C1& c1, const C2& c2, LessThan&& comp) {
658    return std::includes(container_algorithm_internal::c_begin(c1),
659                         container_algorithm_internal::c_end(c1),
660                         container_algorithm_internal::c_begin(c2),
661                         container_algorithm_internal::c_end(c2),
662                         std::forward<LessThan>(comp));
663  }
664  template <typename C1, typename C2, typename OutputIterator,
665            typename = typename std::enable_if<
666                !container_algorithm_internal::IsUnorderedContainer<C1>::value,
667                void>::type,
668            typename = typename std::enable_if<
669                !container_algorithm_internal::IsUnorderedContainer<C2>::value,
670                void>::type>
671  OutputIterator c_set_union(const C1& c1, const C2& c2, OutputIterator output) {
672    return std::set_union(container_algorithm_internal::c_begin(c1),
673                          container_algorithm_internal::c_end(c1),
674                          container_algorithm_internal::c_begin(c2),
675                          container_algorithm_internal::c_end(c2), output);
676  }
677  template <typename C1, typename C2, typename OutputIterator, typename LessThan,
678            typename = typename std::enable_if<
679                !container_algorithm_internal::IsUnorderedContainer<C1>::value,
680                void>::type,
681            typename = typename std::enable_if<
682                !container_algorithm_internal::IsUnorderedContainer<C2>::value,
683                void>::type>
684  OutputIterator c_set_union(const C1& c1, const C2& c2, OutputIterator output,
685                             LessThan&& comp) {
686    return std::set_union(container_algorithm_internal::c_begin(c1),
687                          container_algorithm_internal::c_end(c1),
688                          container_algorithm_internal::c_begin(c2),
689                          container_algorithm_internal::c_end(c2), output,
690                          std::forward<LessThan>(comp));
691  }
692  template <typename C1, typename C2, typename OutputIterator,
693            typename = typename std::enable_if<
694                !container_algorithm_internal::IsUnorderedContainer<C1>::value,
695                void>::type,
696            typename = typename std::enable_if<
697                !container_algorithm_internal::IsUnorderedContainer<C2>::value,
698                void>::type>
699  OutputIterator c_set_intersection(const C1& c1, const C2& c2,
700                                    OutputIterator output) {
701    assert(absl::c_is_sorted(c1));
702    assert(absl::c_is_sorted(c2));
703    return std::set_intersection(container_algorithm_internal::c_begin(c1),
704                                 container_algorithm_internal::c_end(c1),
705                                 container_algorithm_internal::c_begin(c2),
706                                 container_algorithm_internal::c_end(c2), output);
707  }
708  template <typename C1, typename C2, typename OutputIterator, typename LessThan,
709            typename = typename std::enable_if<
710                !container_algorithm_internal::IsUnorderedContainer<C1>::value,
711                void>::type,
712            typename = typename std::enable_if<
713                !container_algorithm_internal::IsUnorderedContainer<C2>::value,
714                void>::type>
715  OutputIterator c_set_intersection(const C1& c1, const C2& c2,
716                                    OutputIterator output, LessThan&& comp) {
717    assert(absl::c_is_sorted(c1, comp));
718    assert(absl::c_is_sorted(c2, comp));
719    return std::set_intersection(container_algorithm_internal::c_begin(c1),
720                                 container_algorithm_internal::c_end(c1),
721                                 container_algorithm_internal::c_begin(c2),
722                                 container_algorithm_internal::c_end(c2), output,
723                                 std::forward<LessThan>(comp));
724  }
725  template <typename C1, typename C2, typename OutputIterator,
726            typename = typename std::enable_if<
727                !container_algorithm_internal::IsUnorderedContainer<C1>::value,
728                void>::type,
729            typename = typename std::enable_if<
730                !container_algorithm_internal::IsUnorderedContainer<C2>::value,
731                void>::type>
732  OutputIterator c_set_difference(const C1& c1, const C2& c2,
733                                  OutputIterator output) {
734    return std::set_difference(container_algorithm_internal::c_begin(c1),
735                               container_algorithm_internal::c_end(c1),
736                               container_algorithm_internal::c_begin(c2),
737                               container_algorithm_internal::c_end(c2), output);
738  }
739  template <typename C1, typename C2, typename OutputIterator, typename LessThan,
740            typename = typename std::enable_if<
741                !container_algorithm_internal::IsUnorderedContainer<C1>::value,
742                void>::type,
743            typename = typename std::enable_if<
744                !container_algorithm_internal::IsUnorderedContainer<C2>::value,
745                void>::type>
746  OutputIterator c_set_difference(const C1& c1, const C2& c2,
747                                  OutputIterator output, LessThan&& comp) {
748    return std::set_difference(container_algorithm_internal::c_begin(c1),
749                               container_algorithm_internal::c_end(c1),
750                               container_algorithm_internal::c_begin(c2),
751                               container_algorithm_internal::c_end(c2), output,
752                               std::forward<LessThan>(comp));
753  }
754  template <typename C1, typename C2, typename OutputIterator,
755            typename = typename std::enable_if<
756                !container_algorithm_internal::IsUnorderedContainer<C1>::value,
757                void>::type,
758            typename = typename std::enable_if<
759                !container_algorithm_internal::IsUnorderedContainer<C2>::value,
760                void>::type>
761  OutputIterator c_set_symmetric_difference(const C1& c1, const C2& c2,
762                                            OutputIterator output) {
763    return std::set_symmetric_difference(
764        container_algorithm_internal::c_begin(c1),
765        container_algorithm_internal::c_end(c1),
766        container_algorithm_internal::c_begin(c2),
767        container_algorithm_internal::c_end(c2), output);
768  }
769  template <typename C1, typename C2, typename OutputIterator, typename LessThan,
770            typename = typename std::enable_if<
771                !container_algorithm_internal::IsUnorderedContainer<C1>::value,
772                void>::type,
773            typename = typename std::enable_if<
774                !container_algorithm_internal::IsUnorderedContainer<C2>::value,
775                void>::type>
776  OutputIterator c_set_symmetric_difference(const C1& c1, const C2& c2,
777                                            OutputIterator output,
778                                            LessThan&& comp) {
779    return std::set_symmetric_difference(
780        container_algorithm_internal::c_begin(c1),
781        container_algorithm_internal::c_end(c1),
782        container_algorithm_internal::c_begin(c2),
783        container_algorithm_internal::c_end(c2), output,
784        std::forward<LessThan>(comp));
785  }
786  template <typename RandomAccessContainer>
787  void c_push_heap(RandomAccessContainer& sequence) {
788    std::push_heap(container_algorithm_internal::c_begin(sequence),
789                   container_algorithm_internal::c_end(sequence));
790  }
791  template <typename RandomAccessContainer, typename LessThan>
792  void c_push_heap(RandomAccessContainer& sequence, LessThan&& comp) {
793    std::push_heap(container_algorithm_internal::c_begin(sequence),
794                   container_algorithm_internal::c_end(sequence),
795                   std::forward<LessThan>(comp));
796  }
797  template <typename RandomAccessContainer>
798  void c_pop_heap(RandomAccessContainer& sequence) {
799    std::pop_heap(container_algorithm_internal::c_begin(sequence),
800                  container_algorithm_internal::c_end(sequence));
801  }
802  template <typename RandomAccessContainer, typename LessThan>
803  void c_pop_heap(RandomAccessContainer& sequence, LessThan&& comp) {
804    std::pop_heap(container_algorithm_internal::c_begin(sequence),
805                  container_algorithm_internal::c_end(sequence),
806                  std::forward<LessThan>(comp));
807  }
808  template <typename RandomAccessContainer>
809  void c_make_heap(RandomAccessContainer& sequence) {
810    std::make_heap(container_algorithm_internal::c_begin(sequence),
811                   container_algorithm_internal::c_end(sequence));
812  }
813  template <typename RandomAccessContainer, typename LessThan>
814  void c_make_heap(RandomAccessContainer& sequence, LessThan&& comp) {
815    std::make_heap(container_algorithm_internal::c_begin(sequence),
816                   container_algorithm_internal::c_end(sequence),
817                   std::forward<LessThan>(comp));
818  }
819  template <typename RandomAccessContainer>
820  void c_sort_heap(RandomAccessContainer& sequence) {
821    std::sort_heap(container_algorithm_internal::c_begin(sequence),
822                   container_algorithm_internal::c_end(sequence));
823  }
824  template <typename RandomAccessContainer, typename LessThan>
825  void c_sort_heap(RandomAccessContainer& sequence, LessThan&& comp) {
826    std::sort_heap(container_algorithm_internal::c_begin(sequence),
827                   container_algorithm_internal::c_end(sequence),
828                   std::forward<LessThan>(comp));
829  }
830  template <typename RandomAccessContainer>
831  bool c_is_heap(const RandomAccessContainer& sequence) {
832    return std::is_heap(container_algorithm_internal::c_begin(sequence),
833                        container_algorithm_internal::c_end(sequence));
834  }
835  template <typename RandomAccessContainer, typename LessThan>
836  bool c_is_heap(const RandomAccessContainer& sequence, LessThan&& comp) {
837    return std::is_heap(container_algorithm_internal::c_begin(sequence),
838                        container_algorithm_internal::c_end(sequence),
839                        std::forward<LessThan>(comp));
840  }
841  template <typename RandomAccessContainer>
842  container_algorithm_internal::ContainerIter<RandomAccessContainer>
843  c_is_heap_until(RandomAccessContainer& sequence) {
844    return std::is_heap_until(container_algorithm_internal::c_begin(sequence),
845                              container_algorithm_internal::c_end(sequence));
846  }
847  template <typename RandomAccessContainer, typename LessThan>
848  container_algorithm_internal::ContainerIter<RandomAccessContainer>
849  c_is_heap_until(RandomAccessContainer& sequence, LessThan&& comp) {
850    return std::is_heap_until(container_algorithm_internal::c_begin(sequence),
851                              container_algorithm_internal::c_end(sequence),
852                              std::forward<LessThan>(comp));
853  }
854  template <typename Sequence>
855  container_algorithm_internal::ContainerIter<Sequence> c_min_element(
856      Sequence& sequence) {
857    return std::min_element(container_algorithm_internal::c_begin(sequence),
858                            container_algorithm_internal::c_end(sequence));
859  }
860  template <typename Sequence, typename LessThan>
861  container_algorithm_internal::ContainerIter<Sequence> c_min_element(
862      Sequence& sequence, LessThan&& comp) {
863    return std::min_element(container_algorithm_internal::c_begin(sequence),
864                            container_algorithm_internal::c_end(sequence),
865                            std::forward<LessThan>(comp));
866  }
867  template <typename Sequence>
868  container_algorithm_internal::ContainerIter<Sequence> c_max_element(
869      Sequence& sequence) {
870    return std::max_element(container_algorithm_internal::c_begin(sequence),
871                            container_algorithm_internal::c_end(sequence));
872  }
873  template <typename Sequence, typename LessThan>
874  container_algorithm_internal::ContainerIter<Sequence> c_max_element(
875      Sequence& sequence, LessThan&& comp) {
876    return std::max_element(container_algorithm_internal::c_begin(sequence),
877                            container_algorithm_internal::c_end(sequence),
878                            std::forward<LessThan>(comp));
879  }
880  template <typename C>
881  container_algorithm_internal::ContainerIterPairType<C, C> c_minmax_element(
882      C& c) {
883    return std::minmax_element(container_algorithm_internal::c_begin(c),
884                               container_algorithm_internal::c_end(c));
885  }
886  template <typename C, typename LessThan>
887  container_algorithm_internal::ContainerIterPairType<C, C> c_minmax_element(
888      C& c, LessThan&& comp) {
889    return std::minmax_element(container_algorithm_internal::c_begin(c),
890                               container_algorithm_internal::c_end(c),
891                               std::forward<LessThan>(comp));
892  }
893  template <typename Sequence1, typename Sequence2>
894  bool c_lexicographical_compare(const Sequence1& sequence1,
895                                 const Sequence2& sequence2) {
896    return std::lexicographical_compare(
897        container_algorithm_internal::c_begin(sequence1),
898        container_algorithm_internal::c_end(sequence1),
899        container_algorithm_internal::c_begin(sequence2),
900        container_algorithm_internal::c_end(sequence2));
901  }
902  template <typename Sequence1, typename Sequence2, typename LessThan>
903  bool c_lexicographical_compare(const Sequence1& sequence1,
904                                 const Sequence2& sequence2, LessThan&& comp) {
905    return std::lexicographical_compare(
906        container_algorithm_internal::c_begin(sequence1),
907        container_algorithm_internal::c_end(sequence1),
908        container_algorithm_internal::c_begin(sequence2),
909        container_algorithm_internal::c_end(sequence2),
910        std::forward<LessThan>(comp));
911  }
912  template <typename C>
913  bool c_next_permutation(C& c) {
914    return std::next_permutation(container_algorithm_internal::c_begin(c),
915                                 container_algorithm_internal::c_end(c));
916  }
917  template <typename C, typename LessThan>
918  bool c_next_permutation(C& c, LessThan&& comp) {
919    return std::next_permutation(container_algorithm_internal::c_begin(c),
920                                 container_algorithm_internal::c_end(c),
921                                 std::forward<LessThan>(comp));
922  }
923  template <typename C>
924  bool c_prev_permutation(C& c) {
925    return std::prev_permutation(container_algorithm_internal::c_begin(c),
926                                 container_algorithm_internal::c_end(c));
927  }
928  template <typename C, typename LessThan>
929  bool c_prev_permutation(C& c, LessThan&& comp) {
930    return std::prev_permutation(container_algorithm_internal::c_begin(c),
931                                 container_algorithm_internal::c_end(c),
932                                 std::forward<LessThan>(comp));
933  }
934  template <typename Sequence, typename T>
935  void c_iota(Sequence& sequence, const T& value) {
936    std::iota(container_algorithm_internal::c_begin(sequence),
937              container_algorithm_internal::c_end(sequence), value);
938  }
939  template <typename Sequence, typename T>
940  decay_t<T> c_accumulate(const Sequence& sequence, T&& init) {
941    return std::accumulate(container_algorithm_internal::c_begin(sequence),
942                           container_algorithm_internal::c_end(sequence),
943                           std::forward<T>(init));
944  }
945  template <typename Sequence, typename T, typename BinaryOp>
946  decay_t<T> c_accumulate(const Sequence& sequence, T&& init,
947                          BinaryOp&& binary_op) {
948    return std::accumulate(container_algorithm_internal::c_begin(sequence),
949                           container_algorithm_internal::c_end(sequence),
950                           std::forward<T>(init),
951                           std::forward<BinaryOp>(binary_op));
952  }
953  template <typename Sequence1, typename Sequence2, typename T>
954  decay_t<T> c_inner_product(const Sequence1& factors1, const Sequence2& factors2,
955                             T&& sum) {
956    return std::inner_product(container_algorithm_internal::c_begin(factors1),
957                              container_algorithm_internal::c_end(factors1),
958                              container_algorithm_internal::c_begin(factors2),
959                              std::forward<T>(sum));
960  }
961  template <typename Sequence1, typename Sequence2, typename T,
962            typename BinaryOp1, typename BinaryOp2>
963  decay_t<T> c_inner_product(const Sequence1& factors1, const Sequence2& factors2,
964                             T&& sum, BinaryOp1&& op1, BinaryOp2&& op2) {
965    return std::inner_product(container_algorithm_internal::c_begin(factors1),
966                              container_algorithm_internal::c_end(factors1),
967                              container_algorithm_internal::c_begin(factors2),
968                              std::forward<T>(sum), std::forward<BinaryOp1>(op1),
969                              std::forward<BinaryOp2>(op2));
970  }
971  template <typename InputSequence, typename OutputIt>
972  OutputIt c_adjacent_difference(const InputSequence& input,
973                                 OutputIt output_first) {
974    return std::adjacent_difference(container_algorithm_internal::c_begin(input),
975                                    container_algorithm_internal::c_end(input),
976                                    output_first);
977  }
978  template <typename InputSequence, typename OutputIt, typename BinaryOp>
979  OutputIt c_adjacent_difference(const InputSequence& input,
980                                 OutputIt output_first, BinaryOp&& op) {
981    return std::adjacent_difference(container_algorithm_internal::c_begin(input),
982                                    container_algorithm_internal::c_end(input),
983                                    output_first, std::forward<BinaryOp>(op));
984  }
985  template <typename InputSequence, typename OutputIt>
986  OutputIt c_partial_sum(const InputSequence& input, OutputIt output_first) {
987    return std::partial_sum(container_algorithm_internal::c_begin(input),
988                            container_algorithm_internal::c_end(input),
989                            output_first);
990  }
991  template <typename InputSequence, typename OutputIt, typename BinaryOp>
992  OutputIt c_partial_sum(const InputSequence& input, OutputIt output_first,
993                         BinaryOp&& op) {
994    return std::partial_sum(container_algorithm_internal::c_begin(input),
995                            container_algorithm_internal::c_end(input),
996                            output_first, std::forward<BinaryOp>(op));
997  }
998  ABSL_NAMESPACE_END
999  }  
1000  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-container.h</h3>
            <pre><code>1  #ifndef ABSL_ALGORITHM_CONTAINER_H_
2  #define ABSL_ALGORITHM_CONTAINER_H_
3  #include <algorithm>
4  #include <cassert>
5  #include <iterator>
6  #include <numeric>
7  #include <type_traits>
8  #include <unordered_map>
9  #include <unordered_set>
10  #include <utility>
11  #include <vector>
12  #include "absl/algorithm/algorithm.h"
13  #include "absl/base/macros.h"
14  #include "absl/meta/type_traits.h"
15  namespace absl {
16  ABSL_NAMESPACE_BEGIN
17  namespace container_algorithm_internal {
18  using std::begin;
19  using std::end;
20  template <typename C>
21  using ContainerIter = decltype(begin(std::declval<C&>()));
22  template <typename C1, typename C2>
23  using ContainerIterPairType =
24      decltype(std::make_pair(ContainerIter<C1>(), ContainerIter<C2>()));
25  template <typename C>
26  using ContainerDifferenceType = decltype(std::distance(
27      std::declval<ContainerIter<C>>(), std::declval<ContainerIter<C>>()));
28  template <typename C>
29  using ContainerPointerType =
30      typename std::iterator_traits<ContainerIter<C>>::pointer;
31  template <typename C>
32  ContainerIter<C> c_begin(C& c) {
33    return begin(c);
34  }
35  template <typename C>
36  ContainerIter<C> c_end(C& c) {
37    return end(c);
38  }
39  template <typename T>
40  struct IsUnorderedContainer : std::false_type {};
41  template <class Key, class T, class Hash, class KeyEqual, class Allocator>
42  struct IsUnorderedContainer<
43      std::unordered_map<Key, T, Hash, KeyEqual, Allocator>> : std::true_type {};
44  template <class Key, class Hash, class KeyEqual, class Allocator>
45  struct IsUnorderedContainer<std::unordered_set<Key, Hash, KeyEqual, Allocator>>
46      : std::true_type {};
47  template <class C>
48  auto c_size(C& c) -> decltype(c.size()) {
49    return c.size();
50  }
51  template <class T, std::size_t N>
52  constexpr std::size_t c_size(T (&)[N]) {
53    return N;
54  }
55  }  
56  template <typename C, typename EqualityComparable>
57  bool c_linear_search(const C& c, EqualityComparable&& value) {
58    return linear_search(container_algorithm_internal::c_begin(c),
59                         container_algorithm_internal::c_end(c),
60                         std::forward<EqualityComparable>(value));
61  }
62  template <typename C>
63  container_algorithm_internal::ContainerDifferenceType<const C> c_distance(
64      const C& c) {
65    return std::distance(container_algorithm_internal::c_begin(c),
66                         container_algorithm_internal::c_end(c));
67  }
68  template <typename C, typename Pred>
69  bool c_all_of(const C& c, Pred&& pred) {
70    return std::all_of(container_algorithm_internal::c_begin(c),
71                       container_algorithm_internal::c_end(c),
72                       std::forward<Pred>(pred));
73  }
74  template <typename C, typename Pred>
75  bool c_any_of(const C& c, Pred&& pred) {
76    return std::any_of(container_algorithm_internal::c_begin(c),
77                       container_algorithm_internal::c_end(c),
78                       std::forward<Pred>(pred));
79  }
80  template <typename C, typename Pred>
81  bool c_none_of(const C& c, Pred&& pred) {
82    return std::none_of(container_algorithm_internal::c_begin(c),
83                        container_algorithm_internal::c_end(c),
84                        std::forward<Pred>(pred));
85  }
86  template <typename C, typename Function>
87  decay_t<Function> c_for_each(C&& c, Function&& f) {
88    return std::for_each(container_algorithm_internal::c_begin(c),
89                         container_algorithm_internal::c_end(c),
90                         std::forward<Function>(f));
91  }
92  template <typename C, typename T>
93  container_algorithm_internal::ContainerIter<C> c_find(C& c, T&& value) {
94    return std::find(container_algorithm_internal::c_begin(c),
95                     container_algorithm_internal::c_end(c),
96                     std::forward<T>(value));
97  }
98  template <typename C, typename Pred>
99  container_algorithm_internal::ContainerIter<C> c_find_if(C& c, Pred&& pred) {
100    return std::find_if(container_algorithm_internal::c_begin(c),
101                        container_algorithm_internal::c_end(c),
102                        std::forward<Pred>(pred));
103  }
104  template <typename C, typename Pred>
105  container_algorithm_internal::ContainerIter<C> c_find_if_not(C& c,
106                                                               Pred&& pred) {
107    return std::find_if_not(container_algorithm_internal::c_begin(c),
108                            container_algorithm_internal::c_end(c),
109                            std::forward<Pred>(pred));
110  }
111  template <typename Sequence1, typename Sequence2>
112  container_algorithm_internal::ContainerIter<Sequence1> c_find_end(
113      Sequence1& sequence, Sequence2& subsequence) {
114    return std::find_end(container_algorithm_internal::c_begin(sequence),
115                         container_algorithm_internal::c_end(sequence),
116                         container_algorithm_internal::c_begin(subsequence),
117                         container_algorithm_internal::c_end(subsequence));
118  }
119  template <typename Sequence1, typename Sequence2, typename BinaryPredicate>
120  container_algorithm_internal::ContainerIter<Sequence1> c_find_end(
121      Sequence1& sequence, Sequence2& subsequence, BinaryPredicate&& pred) {
122    return std::find_end(container_algorithm_internal::c_begin(sequence),
123                         container_algorithm_internal::c_end(sequence),
124                         container_algorithm_internal::c_begin(subsequence),
125                         container_algorithm_internal::c_end(subsequence),
126                         std::forward<BinaryPredicate>(pred));
127  }
128  template <typename C1, typename C2>
129  container_algorithm_internal::ContainerIter<C1> c_find_first_of(C1& container,
130                                                                  C2& options) {
131    return std::find_first_of(container_algorithm_internal::c_begin(container),
132                              container_algorithm_internal::c_end(container),
133                              container_algorithm_internal::c_begin(options),
134                              container_algorithm_internal::c_end(options));
135  }
136  template <typename C1, typename C2, typename BinaryPredicate>
137  container_algorithm_internal::ContainerIter<C1> c_find_first_of(
138      C1& container, C2& options, BinaryPredicate&& pred) {
139    return std::find_first_of(container_algorithm_internal::c_begin(container),
140                              container_algorithm_internal::c_end(container),
141                              container_algorithm_internal::c_begin(options),
142                              container_algorithm_internal::c_end(options),
143                              std::forward<BinaryPredicate>(pred));
144  }
145  template <typename Sequence>
146  container_algorithm_internal::ContainerIter<Sequence> c_adjacent_find(
147      Sequence& sequence) {
148    return std::adjacent_find(container_algorithm_internal::c_begin(sequence),
149                              container_algorithm_internal::c_end(sequence));
150  }
151  template <typename Sequence, typename BinaryPredicate>
152  container_algorithm_internal::ContainerIter<Sequence> c_adjacent_find(
153      Sequence& sequence, BinaryPredicate&& pred) {
154    return std::adjacent_find(container_algorithm_internal::c_begin(sequence),
155                              container_algorithm_internal::c_end(sequence),
156                              std::forward<BinaryPredicate>(pred));
157  }
158  template <typename C, typename T>
159  container_algorithm_internal::ContainerDifferenceType<const C> c_count(
160      const C& c, T&& value) {
161    return std::count(container_algorithm_internal::c_begin(c),
162                      container_algorithm_internal::c_end(c),
163                      std::forward<T>(value));
164  }
165  template <typename C, typename Pred>
166  container_algorithm_internal::ContainerDifferenceType<const C> c_count_if(
167      const C& c, Pred&& pred) {
168    return std::count_if(container_algorithm_internal::c_begin(c),
169                         container_algorithm_internal::c_end(c),
170                         std::forward<Pred>(pred));
171  }
172  template <typename C1, typename C2>
173  container_algorithm_internal::ContainerIterPairType<C1, C2> c_mismatch(C1& c1,
174                                                                         C2& c2) {
175    auto first1 = container_algorithm_internal::c_begin(c1);
176    auto last1 = container_algorithm_internal::c_end(c1);
177    auto first2 = container_algorithm_internal::c_begin(c2);
178    auto last2 = container_algorithm_internal::c_end(c2);
179    for (; first1 != last1 && first2 != last2; ++first1, (void)++first2) {
180      if (!(*first1 == *first2)) {
181        break;
182      }
183    }
184    return std::make_pair(first1, first2);
185  }
186  template <typename C1, typename C2, typename BinaryPredicate>
187  container_algorithm_internal::ContainerIterPairType<C1, C2> c_mismatch(
188      C1& c1, C2& c2, BinaryPredicate pred) {
189    auto first1 = container_algorithm_internal::c_begin(c1);
190    auto last1 = container_algorithm_internal::c_end(c1);
191    auto first2 = container_algorithm_internal::c_begin(c2);
192    auto last2 = container_algorithm_internal::c_end(c2);
193    for (; first1 != last1 && first2 != last2; ++first1, (void)++first2) {
194      if (!pred(*first1, *first2)) {
195        break;
196      }
197    }
198    return std::make_pair(first1, first2);
199  }
200  template <typename C1, typename C2>
201  bool c_equal(const C1& c1, const C2& c2) {
202    return ((container_algorithm_internal::c_size(c1) ==
203             container_algorithm_internal::c_size(c2)) &&
204            std::equal(container_algorithm_internal::c_begin(c1),
205                       container_algorithm_internal::c_end(c1),
206                       container_algorithm_internal::c_begin(c2)));
207  }
208  template <typename C1, typename C2, typename BinaryPredicate>
209  bool c_equal(const C1& c1, const C2& c2, BinaryPredicate&& pred) {
210    return ((container_algorithm_internal::c_size(c1) ==
211             container_algorithm_internal::c_size(c2)) &&
212            std::equal(container_algorithm_internal::c_begin(c1),
213                       container_algorithm_internal::c_end(c1),
214                       container_algorithm_internal::c_begin(c2),
215                       std::forward<BinaryPredicate>(pred)));
216  }
217  template <typename C1, typename C2>
218  bool c_is_permutation(const C1& c1, const C2& c2) {
219    using std::begin;
220    using std::end;
221    return c1.size() == c2.size() &&
222           std::is_permutation(begin(c1), end(c1), begin(c2));
223  }
224  template <typename C1, typename C2, typename BinaryPredicate>
225  bool c_is_permutation(const C1& c1, const C2& c2, BinaryPredicate&& pred) {
226    using std::begin;
227    using std::end;
228    return c1.size() == c2.size() &&
229           std::is_permutation(begin(c1), end(c1), begin(c2),
230                               std::forward<BinaryPredicate>(pred));
231  }
232  template <typename Sequence1, typename Sequence2>
233  container_algorithm_internal::ContainerIter<Sequence1> c_search(
234      Sequence1& sequence, Sequence2& subsequence) {
235    return std::search(container_algorithm_internal::c_begin(sequence),
236                       container_algorithm_internal::c_end(sequence),
237                       container_algorithm_internal::c_begin(subsequence),
238                       container_algorithm_internal::c_end(subsequence));
239  }
240  template <typename Sequence1, typename Sequence2, typename BinaryPredicate>
241  container_algorithm_internal::ContainerIter<Sequence1> c_search(
242      Sequence1& sequence, Sequence2& subsequence, BinaryPredicate&& pred) {
243    return std::search(container_algorithm_internal::c_begin(sequence),
244                       container_algorithm_internal::c_end(sequence),
245                       container_algorithm_internal::c_begin(subsequence),
246                       container_algorithm_internal::c_end(subsequence),
247                       std::forward<BinaryPredicate>(pred));
248  }
249  template <typename Sequence, typename Size, typename T>
250  container_algorithm_internal::ContainerIter<Sequence> c_search_n(
251      Sequence& sequence, Size count, T&& value) {
252    return std::search_n(container_algorithm_internal::c_begin(sequence),
253                         container_algorithm_internal::c_end(sequence), count,
254                         std::forward<T>(value));
255  }
256  template <typename Sequence, typename Size, typename T,
257            typename BinaryPredicate>
258  container_algorithm_internal::ContainerIter<Sequence> c_search_n(
259      Sequence& sequence, Size count, T&& value, BinaryPredicate&& pred) {
260    return std::search_n(container_algorithm_internal::c_begin(sequence),
261                         container_algorithm_internal::c_end(sequence), count,
262                         std::forward<T>(value),
263                         std::forward<BinaryPredicate>(pred));
264  }
265  template <typename InputSequence, typename OutputIterator>
266  OutputIterator c_copy(const InputSequence& input, OutputIterator output) {
267    return std::copy(container_algorithm_internal::c_begin(input),
268                     container_algorithm_internal::c_end(input), output);
269  }
270  template <typename C, typename Size, typename OutputIterator>
271  OutputIterator c_copy_n(const C& input, Size n, OutputIterator output) {
272    return std::copy_n(container_algorithm_internal::c_begin(input), n, output);
273  }
274  template <typename InputSequence, typename OutputIterator, typename Pred>
275  OutputIterator c_copy_if(const InputSequence& input, OutputIterator output,
276                           Pred&& pred) {
277    return std::copy_if(container_algorithm_internal::c_begin(input),
278                        container_algorithm_internal::c_end(input), output,
279                        std::forward<Pred>(pred));
280  }
281  template <typename C, typename BidirectionalIterator>
282  BidirectionalIterator c_copy_backward(const C& src,
283                                        BidirectionalIterator dest) {
284    return std::copy_backward(container_algorithm_internal::c_begin(src),
285                              container_algorithm_internal::c_end(src), dest);
286  }
287  template <typename C, typename OutputIterator>
288  OutputIterator c_move(C&& src, OutputIterator dest) {
289    return std::move(container_algorithm_internal::c_begin(src),
290                     container_algorithm_internal::c_end(src), dest);
291  }
292  template <typename C, typename BidirectionalIterator>
293  BidirectionalIterator c_move_backward(C&& src, BidirectionalIterator dest) {
294    return std::move_backward(container_algorithm_internal::c_begin(src),
295                              container_algorithm_internal::c_end(src), dest);
296  }
297  template <typename C1, typename C2>
<span onclick='openModal()' class='match'>298  container_algorithm_internal::ContainerIter<C2> c_swap_ranges(C1& c1, C2& c2) {
299    auto first1 = container_algorithm_internal::c_begin(c1);
</span>300    auto last1 = container_algorithm_internal::c_end(c1);
301    auto first2 = container_algorithm_internal::c_begin(c2);
302    auto last2 = container_algorithm_internal::c_end(c2);
303    using std::swap;
304    for (; first1 != last1 && first2 != last2; ++first1, (void)++first2) {
305      swap(*first1, *first2);
306    }
307    return first2;
308  }
309  template <typename InputSequence, typename OutputIterator, typename UnaryOp>
310  OutputIterator c_transform(const InputSequence& input, OutputIterator output,
311                             UnaryOp&& unary_op) {
312    return std::transform(container_algorithm_internal::c_begin(input),
313                          container_algorithm_internal::c_end(input), output,
314                          std::forward<UnaryOp>(unary_op));
315  }
316  template <typename InputSequence1, typename InputSequence2,
317            typename OutputIterator, typename BinaryOp>
318  OutputIterator c_transform(const InputSequence1& input1,
319                             const InputSequence2& input2, OutputIterator output,
320                             BinaryOp&& binary_op) {
321    auto first1 = container_algorithm_internal::c_begin(input1);
322    auto last1 = container_algorithm_internal::c_end(input1);
323    auto first2 = container_algorithm_internal::c_begin(input2);
324    auto last2 = container_algorithm_internal::c_end(input2);
325    for (; first1 != last1 && first2 != last2;
326         ++first1, (void)++first2, ++output) {
327      *output = binary_op(*first1, *first2);
328    }
329    return output;
330  }
331  template <typename Sequence, typename T>
332  void c_replace(Sequence& sequence, const T& old_value, const T& new_value) {
333    std::replace(container_algorithm_internal::c_begin(sequence),
334                 container_algorithm_internal::c_end(sequence), old_value,
335                 new_value);
336  }
337  template <typename C, typename Pred, typename T>
338  void c_replace_if(C& c, Pred&& pred, T&& new_value) {
339    std::replace_if(container_algorithm_internal::c_begin(c),
340                    container_algorithm_internal::c_end(c),
341                    std::forward<Pred>(pred), std::forward<T>(new_value));
342  }
343  template <typename C, typename OutputIterator, typename T>
344  OutputIterator c_replace_copy(const C& c, OutputIterator result, T&& old_value,
345                                T&& new_value) {
346    return std::replace_copy(container_algorithm_internal::c_begin(c),
347                             container_algorithm_internal::c_end(c), result,
348                             std::forward<T>(old_value),
349                             std::forward<T>(new_value));
350  }
351  template <typename C, typename OutputIterator, typename Pred, typename T>
352  OutputIterator c_replace_copy_if(const C& c, OutputIterator result, Pred&& pred,
353                                   const T& new_value) {
354    return std::replace_copy_if(container_algorithm_internal::c_begin(c),
355                                container_algorithm_internal::c_end(c), result,
356                                std::forward<Pred>(pred), new_value);
357  }
358  template <typename C, typename T>
359  void c_fill(C& c, const T& value) {
360    std::fill(container_algorithm_internal::c_begin(c),
361              container_algorithm_internal::c_end(c), value);
362  }
363  template <typename C, typename Size, typename T>
364  void c_fill_n(C& c, Size n, const T& value) {
365    std::fill_n(container_algorithm_internal::c_begin(c), n, value);
366  }
367  template <typename C, typename Generator>
368  void c_generate(C& c, Generator&& gen) {
369    std::generate(container_algorithm_internal::c_begin(c),
370                  container_algorithm_internal::c_end(c),
371                  std::forward<Generator>(gen));
372  }
373  template <typename C, typename Size, typename Generator>
374  container_algorithm_internal::ContainerIter<C> c_generate_n(C& c, Size n,
375                                                              Generator&& gen) {
376    return std::generate_n(container_algorithm_internal::c_begin(c), n,
377                           std::forward<Generator>(gen));
378  }
379  template <typename C, typename OutputIterator, typename T>
380  OutputIterator c_remove_copy(const C& c, OutputIterator result,
381                               const T& value) {
382    return std::remove_copy(container_algorithm_internal::c_begin(c),
383                            container_algorithm_internal::c_end(c), result,
384                            value);
385  }
386  template <typename C, typename OutputIterator, typename Pred>
387  OutputIterator c_remove_copy_if(const C& c, OutputIterator result,
388                                  Pred&& pred) {
389    return std::remove_copy_if(container_algorithm_internal::c_begin(c),
390                               container_algorithm_internal::c_end(c), result,
391                               std::forward<Pred>(pred));
392  }
393  template <typename C, typename OutputIterator>
394  OutputIterator c_unique_copy(const C& c, OutputIterator result) {
395    return std::unique_copy(container_algorithm_internal::c_begin(c),
396                            container_algorithm_internal::c_end(c), result);
397  }
398  template <typename C, typename OutputIterator, typename BinaryPredicate>
399  OutputIterator c_unique_copy(const C& c, OutputIterator result,
400                               BinaryPredicate&& pred) {
401    return std::unique_copy(container_algorithm_internal::c_begin(c),
402                            container_algorithm_internal::c_end(c), result,
403                            std::forward<BinaryPredicate>(pred));
404  }
405  template <typename Sequence>
406  void c_reverse(Sequence& sequence) {
407    std::reverse(container_algorithm_internal::c_begin(sequence),
408                 container_algorithm_internal::c_end(sequence));
409  }
410  template <typename C, typename OutputIterator>
411  OutputIterator c_reverse_copy(const C& sequence, OutputIterator result) {
412    return std::reverse_copy(container_algorithm_internal::c_begin(sequence),
413                             container_algorithm_internal::c_end(sequence),
414                             result);
415  }
416  template <typename C,
417            typename Iterator = container_algorithm_internal::ContainerIter<C>>
418  Iterator c_rotate(C& sequence, Iterator middle) {
419    return absl::rotate(container_algorithm_internal::c_begin(sequence), middle,
420                        container_algorithm_internal::c_end(sequence));
421  }
422  template <typename C, typename OutputIterator>
423  OutputIterator c_rotate_copy(
424      const C& sequence,
425      container_algorithm_internal::ContainerIter<const C> middle,
426      OutputIterator result) {
427    return std::rotate_copy(container_algorithm_internal::c_begin(sequence),
428                            middle, container_algorithm_internal::c_end(sequence),
429                            result);
430  }
431  template <typename RandomAccessContainer, typename UniformRandomBitGenerator>
432  void c_shuffle(RandomAccessContainer& c, UniformRandomBitGenerator&& gen) {
433    std::shuffle(container_algorithm_internal::c_begin(c),
434                 container_algorithm_internal::c_end(c),
435                 std::forward<UniformRandomBitGenerator>(gen));
436  }
437  template <typename C, typename Pred>
438  bool c_is_partitioned(const C& c, Pred&& pred) {
439    return std::is_partitioned(container_algorithm_internal::c_begin(c),
440                               container_algorithm_internal::c_end(c),
441                               std::forward<Pred>(pred));
442  }
443  template <typename C, typename Pred>
444  container_algorithm_internal::ContainerIter<C> c_partition(C& c, Pred&& pred) {
445    return std::partition(container_algorithm_internal::c_begin(c),
446                          container_algorithm_internal::c_end(c),
447                          std::forward<Pred>(pred));
448  }
449  template <typename C, typename Pred>
450  container_algorithm_internal::ContainerIter<C> c_stable_partition(C& c,
451                                                                    Pred&& pred) {
452    return std::stable_partition(container_algorithm_internal::c_begin(c),
453                                 container_algorithm_internal::c_end(c),
454                                 std::forward<Pred>(pred));
455  }
456  template <typename C, typename OutputIterator1, typename OutputIterator2,
457            typename Pred>
458  std::pair<OutputIterator1, OutputIterator2> c_partition_copy(
459      const C& c, OutputIterator1 out_true, OutputIterator2 out_false,
460      Pred&& pred) {
461    return std::partition_copy(container_algorithm_internal::c_begin(c),
462                               container_algorithm_internal::c_end(c), out_true,
463                               out_false, std::forward<Pred>(pred));
464  }
465  template <typename C, typename Pred>
466  container_algorithm_internal::ContainerIter<C> c_partition_point(C& c,
467                                                                   Pred&& pred) {
468    return std::partition_point(container_algorithm_internal::c_begin(c),
469                                container_algorithm_internal::c_end(c),
470                                std::forward<Pred>(pred));
471  }
472  template <typename C>
473  void c_sort(C& c) {
474    std::sort(container_algorithm_internal::c_begin(c),
475              container_algorithm_internal::c_end(c));
476  }
477  template <typename C, typename LessThan>
478  void c_sort(C& c, LessThan&& comp) {
479    std::sort(container_algorithm_internal::c_begin(c),
480              container_algorithm_internal::c_end(c),
481              std::forward<LessThan>(comp));
482  }
483  template <typename C>
484  void c_stable_sort(C& c) {
485    std::stable_sort(container_algorithm_internal::c_begin(c),
486                     container_algorithm_internal::c_end(c));
487  }
488  template <typename C, typename LessThan>
489  void c_stable_sort(C& c, LessThan&& comp) {
490    std::stable_sort(container_algorithm_internal::c_begin(c),
491                     container_algorithm_internal::c_end(c),
492                     std::forward<LessThan>(comp));
493  }
494  template <typename C>
495  bool c_is_sorted(const C& c) {
496    return std::is_sorted(container_algorithm_internal::c_begin(c),
497                          container_algorithm_internal::c_end(c));
498  }
499  template <typename C, typename LessThan>
500  bool c_is_sorted(const C& c, LessThan&& comp) {
501    return std::is_sorted(container_algorithm_internal::c_begin(c),
502                          container_algorithm_internal::c_end(c),
503                          std::forward<LessThan>(comp));
504  }
505  template <typename RandomAccessContainer>
506  void c_partial_sort(
507      RandomAccessContainer& sequence,
508      container_algorithm_internal::ContainerIter<RandomAccessContainer> middle) {
509    std::partial_sort(container_algorithm_internal::c_begin(sequence), middle,
510                      container_algorithm_internal::c_end(sequence));
511  }
512  template <typename RandomAccessContainer, typename LessThan>
513  void c_partial_sort(
514      RandomAccessContainer& sequence,
515      container_algorithm_internal::ContainerIter<RandomAccessContainer> middle,
516      LessThan&& comp) {
517    std::partial_sort(container_algorithm_internal::c_begin(sequence), middle,
518                      container_algorithm_internal::c_end(sequence),
519                      std::forward<LessThan>(comp));
520  }
521  template <typename C, typename RandomAccessContainer>
522  container_algorithm_internal::ContainerIter<RandomAccessContainer>
523  c_partial_sort_copy(const C& sequence, RandomAccessContainer& result) {
524    return std::partial_sort_copy(container_algorithm_internal::c_begin(sequence),
525                                  container_algorithm_internal::c_end(sequence),
526                                  container_algorithm_internal::c_begin(result),
527                                  container_algorithm_internal::c_end(result));
528  }
529  template <typename C, typename RandomAccessContainer, typename LessThan>
530  container_algorithm_internal::ContainerIter<RandomAccessContainer>
531  c_partial_sort_copy(const C& sequence, RandomAccessContainer& result,
532                      LessThan&& comp) {
533    return std::partial_sort_copy(container_algorithm_internal::c_begin(sequence),
534                                  container_algorithm_internal::c_end(sequence),
535                                  container_algorithm_internal::c_begin(result),
536                                  container_algorithm_internal::c_end(result),
537                                  std::forward<LessThan>(comp));
538  }
539  template <typename C>
540  container_algorithm_internal::ContainerIter<C> c_is_sorted_until(C& c) {
541    return std::is_sorted_until(container_algorithm_internal::c_begin(c),
542                                container_algorithm_internal::c_end(c));
543  }
544  template <typename C, typename LessThan>
545  container_algorithm_internal::ContainerIter<C> c_is_sorted_until(
546      C& c, LessThan&& comp) {
547    return std::is_sorted_until(container_algorithm_internal::c_begin(c),
548                                container_algorithm_internal::c_end(c),
549                                std::forward<LessThan>(comp));
550  }
551  template <typename RandomAccessContainer>
552  void c_nth_element(
553      RandomAccessContainer& sequence,
554      container_algorithm_internal::ContainerIter<RandomAccessContainer> nth) {
555    std::nth_element(container_algorithm_internal::c_begin(sequence), nth,
556                     container_algorithm_internal::c_end(sequence));
557  }
558  template <typename RandomAccessContainer, typename LessThan>
559  void c_nth_element(
560      RandomAccessContainer& sequence,
561      container_algorithm_internal::ContainerIter<RandomAccessContainer> nth,
562      LessThan&& comp) {
563    std::nth_element(container_algorithm_internal::c_begin(sequence), nth,
564                     container_algorithm_internal::c_end(sequence),
565                     std::forward<LessThan>(comp));
566  }
567  template <typename Sequence, typename T>
568  container_algorithm_internal::ContainerIter<Sequence> c_lower_bound(
569      Sequence& sequence, const T& value) {
570    return std::lower_bound(container_algorithm_internal::c_begin(sequence),
571                            container_algorithm_internal::c_end(sequence), value);
572  }
573  template <typename Sequence, typename T, typename LessThan>
574  container_algorithm_internal::ContainerIter<Sequence> c_lower_bound(
575      Sequence& sequence, const T& value, LessThan&& comp) {
576    return std::lower_bound(container_algorithm_internal::c_begin(sequence),
577                            container_algorithm_internal::c_end(sequence), value,
578                            std::forward<LessThan>(comp));
579  }
580  template <typename Sequence, typename T>
581  container_algorithm_internal::ContainerIter<Sequence> c_upper_bound(
582      Sequence& sequence, const T& value) {
583    return std::upper_bound(container_algorithm_internal::c_begin(sequence),
584                            container_algorithm_internal::c_end(sequence), value);
585  }
586  template <typename Sequence, typename T, typename LessThan>
587  container_algorithm_internal::ContainerIter<Sequence> c_upper_bound(
588      Sequence& sequence, const T& value, LessThan&& comp) {
589    return std::upper_bound(container_algorithm_internal::c_begin(sequence),
590                            container_algorithm_internal::c_end(sequence), value,
591                            std::forward<LessThan>(comp));
592  }
593  template <typename Sequence, typename T>
594  container_algorithm_internal::ContainerIterPairType<Sequence, Sequence>
595  c_equal_range(Sequence& sequence, const T& value) {
596    return std::equal_range(container_algorithm_internal::c_begin(sequence),
597                            container_algorithm_internal::c_end(sequence), value);
598  }
599  template <typename Sequence, typename T, typename LessThan>
600  container_algorithm_internal::ContainerIterPairType<Sequence, Sequence>
601  c_equal_range(Sequence& sequence, const T& value, LessThan&& comp) {
602    return std::equal_range(container_algorithm_internal::c_begin(sequence),
603                            container_algorithm_internal::c_end(sequence), value,
604                            std::forward<LessThan>(comp));
605  }
606  template <typename Sequence, typename T>
607  bool c_binary_search(const Sequence& sequence, const T& value) {
608    return std::binary_search(container_algorithm_internal::c_begin(sequence),
609                              container_algorithm_internal::c_end(sequence),
610                              value);
611  }
612  template <typename Sequence, typename T, typename LessThan>
613  bool c_binary_search(const Sequence& sequence, const T& value,
614                       LessThan&& comp) {
615    return std::binary_search(container_algorithm_internal::c_begin(sequence),
616                              container_algorithm_internal::c_end(sequence),
617                              value, std::forward<LessThan>(comp));
618  }
619  template <typename C1, typename C2, typename OutputIterator>
620  OutputIterator c_merge(const C1& c1, const C2& c2, OutputIterator result) {
621    return std::merge(container_algorithm_internal::c_begin(c1),
622                      container_algorithm_internal::c_end(c1),
623                      container_algorithm_internal::c_begin(c2),
624                      container_algorithm_internal::c_end(c2), result);
625  }
626  template <typename C1, typename C2, typename OutputIterator, typename LessThan>
627  OutputIterator c_merge(const C1& c1, const C2& c2, OutputIterator result,
628                         LessThan&& comp) {
629    return std::merge(container_algorithm_internal::c_begin(c1),
630                      container_algorithm_internal::c_end(c1),
631                      container_algorithm_internal::c_begin(c2),
632                      container_algorithm_internal::c_end(c2), result,
633                      std::forward<LessThan>(comp));
634  }
635  template <typename C>
636  void c_inplace_merge(C& c,
637                       container_algorithm_internal::ContainerIter<C> middle) {
638    std::inplace_merge(container_algorithm_internal::c_begin(c), middle,
639                       container_algorithm_internal::c_end(c));
640  }
641  template <typename C, typename LessThan>
642  void c_inplace_merge(C& c,
643                       container_algorithm_internal::ContainerIter<C> middle,
644                       LessThan&& comp) {
645    std::inplace_merge(container_algorithm_internal::c_begin(c), middle,
646                       container_algorithm_internal::c_end(c),
647                       std::forward<LessThan>(comp));
648  }
649  template <typename C1, typename C2>
650  bool c_includes(const C1& c1, const C2& c2) {
651    return std::includes(container_algorithm_internal::c_begin(c1),
652                         container_algorithm_internal::c_end(c1),
653                         container_algorithm_internal::c_begin(c2),
654                         container_algorithm_internal::c_end(c2));
655  }
656  template <typename C1, typename C2, typename LessThan>
657  bool c_includes(const C1& c1, const C2& c2, LessThan&& comp) {
658    return std::includes(container_algorithm_internal::c_begin(c1),
659                         container_algorithm_internal::c_end(c1),
660                         container_algorithm_internal::c_begin(c2),
661                         container_algorithm_internal::c_end(c2),
662                         std::forward<LessThan>(comp));
663  }
664  template <typename C1, typename C2, typename OutputIterator,
665            typename = typename std::enable_if<
666                !container_algorithm_internal::IsUnorderedContainer<C1>::value,
667                void>::type,
668            typename = typename std::enable_if<
669                !container_algorithm_internal::IsUnorderedContainer<C2>::value,
670                void>::type>
671  OutputIterator c_set_union(const C1& c1, const C2& c2, OutputIterator output) {
672    return std::set_union(container_algorithm_internal::c_begin(c1),
673                          container_algorithm_internal::c_end(c1),
674                          container_algorithm_internal::c_begin(c2),
675                          container_algorithm_internal::c_end(c2), output);
676  }
677  template <typename C1, typename C2, typename OutputIterator, typename LessThan,
678            typename = typename std::enable_if<
679                !container_algorithm_internal::IsUnorderedContainer<C1>::value,
680                void>::type,
681            typename = typename std::enable_if<
682                !container_algorithm_internal::IsUnorderedContainer<C2>::value,
683                void>::type>
684  OutputIterator c_set_union(const C1& c1, const C2& c2, OutputIterator output,
685                             LessThan&& comp) {
686    return std::set_union(container_algorithm_internal::c_begin(c1),
687                          container_algorithm_internal::c_end(c1),
688                          container_algorithm_internal::c_begin(c2),
689                          container_algorithm_internal::c_end(c2), output,
690                          std::forward<LessThan>(comp));
691  }
692  template <typename C1, typename C2, typename OutputIterator,
693            typename = typename std::enable_if<
694                !container_algorithm_internal::IsUnorderedContainer<C1>::value,
695                void>::type,
696            typename = typename std::enable_if<
697                !container_algorithm_internal::IsUnorderedContainer<C2>::value,
698                void>::type>
699  OutputIterator c_set_intersection(const C1& c1, const C2& c2,
700                                    OutputIterator output) {
701    assert(absl::c_is_sorted(c1));
702    assert(absl::c_is_sorted(c2));
703    return std::set_intersection(container_algorithm_internal::c_begin(c1),
704                                 container_algorithm_internal::c_end(c1),
705                                 container_algorithm_internal::c_begin(c2),
706                                 container_algorithm_internal::c_end(c2), output);
707  }
708  template <typename C1, typename C2, typename OutputIterator, typename LessThan,
709            typename = typename std::enable_if<
710                !container_algorithm_internal::IsUnorderedContainer<C1>::value,
711                void>::type,
712            typename = typename std::enable_if<
713                !container_algorithm_internal::IsUnorderedContainer<C2>::value,
714                void>::type>
715  OutputIterator c_set_intersection(const C1& c1, const C2& c2,
716                                    OutputIterator output, LessThan&& comp) {
717    assert(absl::c_is_sorted(c1, comp));
718    assert(absl::c_is_sorted(c2, comp));
719    return std::set_intersection(container_algorithm_internal::c_begin(c1),
720                                 container_algorithm_internal::c_end(c1),
721                                 container_algorithm_internal::c_begin(c2),
722                                 container_algorithm_internal::c_end(c2), output,
723                                 std::forward<LessThan>(comp));
724  }
725  template <typename C1, typename C2, typename OutputIterator,
726            typename = typename std::enable_if<
727                !container_algorithm_internal::IsUnorderedContainer<C1>::value,
728                void>::type,
729            typename = typename std::enable_if<
730                !container_algorithm_internal::IsUnorderedContainer<C2>::value,
731                void>::type>
732  OutputIterator c_set_difference(const C1& c1, const C2& c2,
733                                  OutputIterator output) {
734    return std::set_difference(container_algorithm_internal::c_begin(c1),
735                               container_algorithm_internal::c_end(c1),
736                               container_algorithm_internal::c_begin(c2),
737                               container_algorithm_internal::c_end(c2), output);
738  }
739  template <typename C1, typename C2, typename OutputIterator, typename LessThan,
740            typename = typename std::enable_if<
741                !container_algorithm_internal::IsUnorderedContainer<C1>::value,
742                void>::type,
743            typename = typename std::enable_if<
744                !container_algorithm_internal::IsUnorderedContainer<C2>::value,
745                void>::type>
746  OutputIterator c_set_difference(const C1& c1, const C2& c2,
747                                  OutputIterator output, LessThan&& comp) {
748    return std::set_difference(container_algorithm_internal::c_begin(c1),
749                               container_algorithm_internal::c_end(c1),
750                               container_algorithm_internal::c_begin(c2),
751                               container_algorithm_internal::c_end(c2), output,
752                               std::forward<LessThan>(comp));
753  }
754  template <typename C1, typename C2, typename OutputIterator,
755            typename = typename std::enable_if<
756                !container_algorithm_internal::IsUnorderedContainer<C1>::value,
757                void>::type,
758            typename = typename std::enable_if<
759                !container_algorithm_internal::IsUnorderedContainer<C2>::value,
760                void>::type>
761  OutputIterator c_set_symmetric_difference(const C1& c1, const C2& c2,
762                                            OutputIterator output) {
763    return std::set_symmetric_difference(
764        container_algorithm_internal::c_begin(c1),
765        container_algorithm_internal::c_end(c1),
766        container_algorithm_internal::c_begin(c2),
767        container_algorithm_internal::c_end(c2), output);
768  }
769  template <typename C1, typename C2, typename OutputIterator, typename LessThan,
770            typename = typename std::enable_if<
771                !container_algorithm_internal::IsUnorderedContainer<C1>::value,
772                void>::type,
773            typename = typename std::enable_if<
774                !container_algorithm_internal::IsUnorderedContainer<C2>::value,
775                void>::type>
776  OutputIterator c_set_symmetric_difference(const C1& c1, const C2& c2,
777                                            OutputIterator output,
778                                            LessThan&& comp) {
779    return std::set_symmetric_difference(
780        container_algorithm_internal::c_begin(c1),
781        container_algorithm_internal::c_end(c1),
782        container_algorithm_internal::c_begin(c2),
783        container_algorithm_internal::c_end(c2), output,
784        std::forward<LessThan>(comp));
785  }
786  template <typename RandomAccessContainer>
787  void c_push_heap(RandomAccessContainer& sequence) {
788    std::push_heap(container_algorithm_internal::c_begin(sequence),
789                   container_algorithm_internal::c_end(sequence));
790  }
791  template <typename RandomAccessContainer, typename LessThan>
792  void c_push_heap(RandomAccessContainer& sequence, LessThan&& comp) {
793    std::push_heap(container_algorithm_internal::c_begin(sequence),
794                   container_algorithm_internal::c_end(sequence),
795                   std::forward<LessThan>(comp));
796  }
797  template <typename RandomAccessContainer>
798  void c_pop_heap(RandomAccessContainer& sequence) {
799    std::pop_heap(container_algorithm_internal::c_begin(sequence),
800                  container_algorithm_internal::c_end(sequence));
801  }
802  template <typename RandomAccessContainer, typename LessThan>
803  void c_pop_heap(RandomAccessContainer& sequence, LessThan&& comp) {
804    std::pop_heap(container_algorithm_internal::c_begin(sequence),
805                  container_algorithm_internal::c_end(sequence),
806                  std::forward<LessThan>(comp));
807  }
808  template <typename RandomAccessContainer>
809  void c_make_heap(RandomAccessContainer& sequence) {
810    std::make_heap(container_algorithm_internal::c_begin(sequence),
811                   container_algorithm_internal::c_end(sequence));
812  }
813  template <typename RandomAccessContainer, typename LessThan>
814  void c_make_heap(RandomAccessContainer& sequence, LessThan&& comp) {
815    std::make_heap(container_algorithm_internal::c_begin(sequence),
816                   container_algorithm_internal::c_end(sequence),
817                   std::forward<LessThan>(comp));
818  }
819  template <typename RandomAccessContainer>
820  void c_sort_heap(RandomAccessContainer& sequence) {
821    std::sort_heap(container_algorithm_internal::c_begin(sequence),
822                   container_algorithm_internal::c_end(sequence));
823  }
824  template <typename RandomAccessContainer, typename LessThan>
825  void c_sort_heap(RandomAccessContainer& sequence, LessThan&& comp) {
826    std::sort_heap(container_algorithm_internal::c_begin(sequence),
827                   container_algorithm_internal::c_end(sequence),
828                   std::forward<LessThan>(comp));
829  }
830  template <typename RandomAccessContainer>
831  bool c_is_heap(const RandomAccessContainer& sequence) {
832    return std::is_heap(container_algorithm_internal::c_begin(sequence),
833                        container_algorithm_internal::c_end(sequence));
834  }
835  template <typename RandomAccessContainer, typename LessThan>
836  bool c_is_heap(const RandomAccessContainer& sequence, LessThan&& comp) {
837    return std::is_heap(container_algorithm_internal::c_begin(sequence),
838                        container_algorithm_internal::c_end(sequence),
839                        std::forward<LessThan>(comp));
840  }
841  template <typename RandomAccessContainer>
842  container_algorithm_internal::ContainerIter<RandomAccessContainer>
843  c_is_heap_until(RandomAccessContainer& sequence) {
844    return std::is_heap_until(container_algorithm_internal::c_begin(sequence),
845                              container_algorithm_internal::c_end(sequence));
846  }
847  template <typename RandomAccessContainer, typename LessThan>
848  container_algorithm_internal::ContainerIter<RandomAccessContainer>
849  c_is_heap_until(RandomAccessContainer& sequence, LessThan&& comp) {
850    return std::is_heap_until(container_algorithm_internal::c_begin(sequence),
851                              container_algorithm_internal::c_end(sequence),
852                              std::forward<LessThan>(comp));
853  }
854  template <typename Sequence>
855  container_algorithm_internal::ContainerIter<Sequence> c_min_element(
856      Sequence& sequence) {
857    return std::min_element(container_algorithm_internal::c_begin(sequence),
858                            container_algorithm_internal::c_end(sequence));
859  }
860  template <typename Sequence, typename LessThan>
861  container_algorithm_internal::ContainerIter<Sequence> c_min_element(
862      Sequence& sequence, LessThan&& comp) {
863    return std::min_element(container_algorithm_internal::c_begin(sequence),
864                            container_algorithm_internal::c_end(sequence),
865                            std::forward<LessThan>(comp));
866  }
867  template <typename Sequence>
868  container_algorithm_internal::ContainerIter<Sequence> c_max_element(
869      Sequence& sequence) {
870    return std::max_element(container_algorithm_internal::c_begin(sequence),
871                            container_algorithm_internal::c_end(sequence));
872  }
873  template <typename Sequence, typename LessThan>
874  container_algorithm_internal::ContainerIter<Sequence> c_max_element(
875      Sequence& sequence, LessThan&& comp) {
876    return std::max_element(container_algorithm_internal::c_begin(sequence),
877                            container_algorithm_internal::c_end(sequence),
878                            std::forward<LessThan>(comp));
879  }
880  template <typename C>
881  container_algorithm_internal::ContainerIterPairType<C, C> c_minmax_element(
882      C& c) {
883    return std::minmax_element(container_algorithm_internal::c_begin(c),
884                               container_algorithm_internal::c_end(c));
885  }
886  template <typename C, typename LessThan>
887  container_algorithm_internal::ContainerIterPairType<C, C> c_minmax_element(
888      C& c, LessThan&& comp) {
889    return std::minmax_element(container_algorithm_internal::c_begin(c),
890                               container_algorithm_internal::c_end(c),
891                               std::forward<LessThan>(comp));
892  }
893  template <typename Sequence1, typename Sequence2>
894  bool c_lexicographical_compare(const Sequence1& sequence1,
895                                 const Sequence2& sequence2) {
896    return std::lexicographical_compare(
897        container_algorithm_internal::c_begin(sequence1),
898        container_algorithm_internal::c_end(sequence1),
899        container_algorithm_internal::c_begin(sequence2),
900        container_algorithm_internal::c_end(sequence2));
901  }
902  template <typename Sequence1, typename Sequence2, typename LessThan>
903  bool c_lexicographical_compare(const Sequence1& sequence1,
904                                 const Sequence2& sequence2, LessThan&& comp) {
905    return std::lexicographical_compare(
906        container_algorithm_internal::c_begin(sequence1),
907        container_algorithm_internal::c_end(sequence1),
908        container_algorithm_internal::c_begin(sequence2),
909        container_algorithm_internal::c_end(sequence2),
910        std::forward<LessThan>(comp));
911  }
912  template <typename C>
913  bool c_next_permutation(C& c) {
914    return std::next_permutation(container_algorithm_internal::c_begin(c),
915                                 container_algorithm_internal::c_end(c));
916  }
917  template <typename C, typename LessThan>
918  bool c_next_permutation(C& c, LessThan&& comp) {
919    return std::next_permutation(container_algorithm_internal::c_begin(c),
920                                 container_algorithm_internal::c_end(c),
921                                 std::forward<LessThan>(comp));
922  }
923  template <typename C>
924  bool c_prev_permutation(C& c) {
925    return std::prev_permutation(container_algorithm_internal::c_begin(c),
926                                 container_algorithm_internal::c_end(c));
927  }
928  template <typename C, typename LessThan>
929  bool c_prev_permutation(C& c, LessThan&& comp) {
930    return std::prev_permutation(container_algorithm_internal::c_begin(c),
931                                 container_algorithm_internal::c_end(c),
932                                 std::forward<LessThan>(comp));
933  }
934  template <typename Sequence, typename T>
935  void c_iota(Sequence& sequence, const T& value) {
936    std::iota(container_algorithm_internal::c_begin(sequence),
937              container_algorithm_internal::c_end(sequence), value);
938  }
939  template <typename Sequence, typename T>
940  decay_t<T> c_accumulate(const Sequence& sequence, T&& init) {
941    return std::accumulate(container_algorithm_internal::c_begin(sequence),
942                           container_algorithm_internal::c_end(sequence),
943                           std::forward<T>(init));
944  }
945  template <typename Sequence, typename T, typename BinaryOp>
946  decay_t<T> c_accumulate(const Sequence& sequence, T&& init,
947                          BinaryOp&& binary_op) {
948    return std::accumulate(container_algorithm_internal::c_begin(sequence),
949                           container_algorithm_internal::c_end(sequence),
950                           std::forward<T>(init),
951                           std::forward<BinaryOp>(binary_op));
952  }
953  template <typename Sequence1, typename Sequence2, typename T>
954  decay_t<T> c_inner_product(const Sequence1& factors1, const Sequence2& factors2,
955                             T&& sum) {
956    return std::inner_product(container_algorithm_internal::c_begin(factors1),
957                              container_algorithm_internal::c_end(factors1),
958                              container_algorithm_internal::c_begin(factors2),
959                              std::forward<T>(sum));
960  }
961  template <typename Sequence1, typename Sequence2, typename T,
962            typename BinaryOp1, typename BinaryOp2>
963  decay_t<T> c_inner_product(const Sequence1& factors1, const Sequence2& factors2,
964                             T&& sum, BinaryOp1&& op1, BinaryOp2&& op2) {
965    return std::inner_product(container_algorithm_internal::c_begin(factors1),
966                              container_algorithm_internal::c_end(factors1),
967                              container_algorithm_internal::c_begin(factors2),
968                              std::forward<T>(sum), std::forward<BinaryOp1>(op1),
969                              std::forward<BinaryOp2>(op2));
970  }
971  template <typename InputSequence, typename OutputIt>
972  OutputIt c_adjacent_difference(const InputSequence& input,
973                                 OutputIt output_first) {
974    return std::adjacent_difference(container_algorithm_internal::c_begin(input),
975                                    container_algorithm_internal::c_end(input),
976                                    output_first);
977  }
978  template <typename InputSequence, typename OutputIt, typename BinaryOp>
979  OutputIt c_adjacent_difference(const InputSequence& input,
980                                 OutputIt output_first, BinaryOp&& op) {
981    return std::adjacent_difference(container_algorithm_internal::c_begin(input),
982                                    container_algorithm_internal::c_end(input),
983                                    output_first, std::forward<BinaryOp>(op));
984  }
985  template <typename InputSequence, typename OutputIt>
986  OutputIt c_partial_sum(const InputSequence& input, OutputIt output_first) {
987    return std::partial_sum(container_algorithm_internal::c_begin(input),
988                            container_algorithm_internal::c_end(input),
989                            output_first);
990  }
991  template <typename InputSequence, typename OutputIt, typename BinaryOp>
992  OutputIt c_partial_sum(const InputSequence& input, OutputIt output_first,
993                         BinaryOp&& op) {
994    return std::partial_sum(container_algorithm_internal::c_begin(input),
995                            container_algorithm_internal::c_end(input),
996                            output_first, std::forward<BinaryOp>(op));
997  }
998  ABSL_NAMESPACE_END
999  }  
1000  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-container.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-container.h</div>
                </div>
                <div class="column column_space"><pre><code>112  container_algorithm_internal::ContainerIter<Sequence1> c_find_end(
113      Sequence1& sequence, Sequence2& subsequence) {
114    return std::find_end(container_algorithm_internal::c_begin(sequence),
</pre></code></div>
                <div class="column column_space"><pre><code>298  container_algorithm_internal::ContainerIter<C2> c_swap_ranges(C1& c1, C2& c2) {
299    auto first1 = container_algorithm_internal::c_begin(c1);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    