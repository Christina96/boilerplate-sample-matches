
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 18.61198738170347%, Tokens: 9</h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-rejctmap.h</h3>
            <pre><code>1  #ifndef REJCTMAP_H
2  #define REJCTMAP_H
3  #include "errcode.h"
4  #include "params.h"
5  #include <bitset>
6  #include <memory>
7  namespace tesseract {
8  enum REJ_FLAGS {
9    R_TESS_FAILURE,   
10    R_SMALL_XHT,      
11    R_EDGE_CHAR,      
12    R_1IL_CONFLICT,   
13    R_POSTNN_1IL,     
14    R_REJ_CBLOB,      
15    R_MM_REJECT,      
16    R_BAD_REPETITION, 
17    R_POOR_MATCH,        
18    R_NOT_TESS_ACCEPTED, 
19    R_CONTAINS_BLANKS,   
20    R_BAD_PERMUTER,      
21    R_HYPHEN,       
22    R_DUBIOUS,      
23    R_NO_ALPHANUMS, 
24    R_MOSTLY_REJ,   
25    R_XHT_FIXUP,    
26    R_BAD_QUALITY, 
27    R_DOC_REJ,   
28    R_BLOCK_REJ, 
29    R_ROW_REJ,   
30    R_UNLV_REJ,  
31    R_NN_ACCEPT,         
32    R_HYPHEN_ACCEPT,     
33    R_MM_ACCEPT,         
34    R_QUALITY_ACCEPT,    
35    R_MINIMAL_REJ_ACCEPT 
36  };
37  #define MAP_ACCEPT '1'
38  #define MAP_REJECT_PERM '0'
39  #define MAP_REJECT_TEMP '2'
40  #define MAP_REJECT_POTENTIAL '3'
41  class REJ {
42    std::bitset<32> flags;
43    void set_flag(REJ_FLAGS rej_flag) {
44      flags.set(rej_flag);
45    }
46  public:
47    REJ() = default;
48    REJ( 
49        const REJ &source) {
50      flags = source.flags;
51    }
52    REJ &operator=( 
53        const REJ &source) = default;
54    bool flag(REJ_FLAGS rej_flag) const {
55      return flags[rej_flag];
56    }
57    char display_char() const {
58      if (perm_rejected()) {
59        return MAP_REJECT_PERM;
60      } else if (accept_if_good_quality()) {
61        return MAP_REJECT_POTENTIAL;
<span onclick='openModal()' class='match'>62      } else if (rejected()) {
63        return MAP_REJECT_TEMP;
64      } else {
65        return MAP_ACCEPT;
66      }
67    }
</span>68    bool perm_rejected() const { 
69      return (flag(R_TESS_FAILURE) || flag(R_SMALL_XHT) || flag(R_EDGE_CHAR) ||
70              flag(R_1IL_CONFLICT) || flag(R_POSTNN_1IL) || flag(R_REJ_CBLOB) ||
71              flag(R_BAD_REPETITION) || flag(R_MM_REJECT));
72    }
73  private:
74    bool rej_before_nn_accept() const {
75      return flag(R_POOR_MATCH) || flag(R_NOT_TESS_ACCEPTED) ||
76             flag(R_CONTAINS_BLANKS) || flag(R_BAD_PERMUTER);
77    }
78    bool rej_between_nn_and_mm() const {
79      return flag(R_HYPHEN) || flag(R_DUBIOUS) || flag(R_NO_ALPHANUMS) ||
80             flag(R_MOSTLY_REJ) || flag(R_XHT_FIXUP);
81    }
82    bool rej_between_mm_and_quality_accept() const {
83      return flag(R_BAD_QUALITY);
84    }
85    bool rej_between_quality_and_minimal_rej_accept() const {
86      return flag(R_DOC_REJ) || flag(R_BLOCK_REJ) || flag(R_ROW_REJ) ||
87             flag(R_UNLV_REJ);
88    }
89    bool rej_before_mm_accept() const {
90      return rej_between_nn_and_mm() ||
91             (rej_before_nn_accept() && !flag(R_NN_ACCEPT) &&
92              !flag(R_HYPHEN_ACCEPT));
93    }
94    bool rej_before_quality_accept() const {
95      return rej_between_mm_and_quality_accept() ||
96             (!flag(R_MM_ACCEPT) && rej_before_mm_accept());
97    }
98  public:
99    bool rejected() const { 
100      if (flag(R_MINIMAL_REJ_ACCEPT)) {
101        return false;
102      } else {
103        return (perm_rejected() || rej_between_quality_and_minimal_rej_accept() ||
104                (!flag(R_QUALITY_ACCEPT) && rej_before_quality_accept()));
105      }
106    }
107    bool accept_if_good_quality() const { 
108      return (rejected() && !perm_rejected() && flag(R_BAD_PERMUTER) &&
109              !flag(R_POOR_MATCH) && !flag(R_NOT_TESS_ACCEPTED) &&
110              !flag(R_CONTAINS_BLANKS) &&
111              (!rej_between_nn_and_mm() && !rej_between_mm_and_quality_accept() &&
112               !rej_between_quality_and_minimal_rej_accept()));
113    }
114    void setrej_tess_failure() { 
115      set_flag(R_TESS_FAILURE);
116    }
117    void setrej_small_xht() { 
118      set_flag(R_SMALL_XHT);
119    }
120    void setrej_edge_char() { 
121      set_flag(R_EDGE_CHAR);
122    }
123    void setrej_1Il_conflict() { 
124      set_flag(R_1IL_CONFLICT);
125    }
126    void setrej_postNN_1Il() { 
127      set_flag(R_POSTNN_1IL);
128    }
129    void setrej_rej_cblob() { 
130      set_flag(R_REJ_CBLOB);
131    }
132    void setrej_mm_reject() { 
133      set_flag(R_MM_REJECT);
134    }
135    void setrej_bad_repetition() { 
136      set_flag(R_BAD_REPETITION);
137    }
138    void setrej_poor_match() { 
139      set_flag(R_POOR_MATCH);
140    }
141    void setrej_not_tess_accepted() {
142      set_flag(R_NOT_TESS_ACCEPTED);
143    }
144    void setrej_contains_blanks() {
145      set_flag(R_CONTAINS_BLANKS);
146    }
147    void setrej_bad_permuter() { 
148      set_flag(R_BAD_PERMUTER);
149    }
150    void setrej_hyphen() { 
151      set_flag(R_HYPHEN);
152    }
153    void setrej_dubious() { 
154      set_flag(R_DUBIOUS);
155    }
156    void setrej_no_alphanums() { 
157      set_flag(R_NO_ALPHANUMS);
158    }
159    void setrej_mostly_rej() { 
160      set_flag(R_MOSTLY_REJ);
161    }
162    void setrej_xht_fixup() { 
163      set_flag(R_XHT_FIXUP);
164    }
165    void setrej_bad_quality() { 
166      set_flag(R_BAD_QUALITY);
167    }
168    void setrej_doc_rej() { 
169      set_flag(R_DOC_REJ);
170    }
171    void setrej_block_rej() { 
172      set_flag(R_BLOCK_REJ);
173    }
174    void setrej_row_rej() { 
175      set_flag(R_ROW_REJ);
176    }
177    void setrej_unlv_rej() { 
178      set_flag(R_UNLV_REJ);
179    }
180    void setrej_hyphen_accept() { 
181      set_flag(R_HYPHEN_ACCEPT);
182    }
183    void setrej_nn_accept() { 
184      set_flag(R_NN_ACCEPT);
185    }
186    void setrej_mm_accept() { 
187      set_flag(R_MM_ACCEPT);
188    }
189    void setrej_quality_accept() { 
190      set_flag(R_QUALITY_ACCEPT);
191    }
192    void setrej_minimal_rej_accept() {
193      set_flag(R_MINIMAL_REJ_ACCEPT);
194    }
195    bool accepted() const { 
196      return !rejected();
197    }
198    bool recoverable() const {
199      return (rejected() && !perm_rejected());
200    }
201    void full_print(FILE *fp) const;
202  };
203  class REJMAP {
204    std::unique_ptr<REJ[]> ptr; 
205    uint16_t len = 0;           
206  public:
207    REJMAP() = default;
208    REJMAP(const REJMAP &rejmap) {
209      *this = rejmap;
210    }
211    REJMAP &operator=(const REJMAP &source);
212    void initialise(uint16_t length);
213    REJ &operator[](         
214        uint16_t index) const 
215    {
216      ASSERT_HOST(index < len);
217      return ptr[index]; 
218    }
219    uint16_t length() const { 
220      return len;
221    }
222    int16_t accept_count() const; 
223    int16_t reject_count() const { 
224      return len - accept_count();
225    }
226    void remove_pos(uint16_t pos);
227    void print(FILE *fp) const;
228    void full_print(FILE *fp) const;
229    bool recoverable_rejects() const; 
230    bool quality_recoverable_rejects() const;
231    void rej_word_small_xht(); 
232    void rej_word_tess_failure();
233    void rej_word_not_tess_accepted();
234    void rej_word_contains_blanks();
235    void rej_word_bad_permuter();
236    void rej_word_xht_fixup(); 
237    void rej_word_no_alphanums();
238    void rej_word_mostly_rej();  
239    void rej_word_bad_quality(); 
240    void rej_word_doc_rej();     
241    void rej_word_block_rej();   
242    void rej_word_row_rej();     
243  };
244  } 
245  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-inlined_vector.h</h3>
            <pre><code>1  #ifndef ABSL_CONTAINER_INLINED_VECTOR_H_
2  #define ABSL_CONTAINER_INLINED_VECTOR_H_
3  #include <algorithm>
4  #include <cstddef>
5  #include <cstdlib>
6  #include <cstring>
7  #include <initializer_list>
8  #include <iterator>
9  #include <memory>
10  #include <type_traits>
11  #include <utility>
12  #include "absl/algorithm/algorithm.h"
13  #include "absl/base/internal/throw_delegate.h"
14  #include "absl/base/macros.h"
15  #include "absl/base/optimization.h"
16  #include "absl/base/port.h"
17  #include "absl/container/internal/inlined_vector.h"
18  #include "absl/memory/memory.h"
19  #include "absl/meta/type_traits.h"
20  namespace absl {
21  ABSL_NAMESPACE_BEGIN
22  template <typename T, size_t N, typename A = std::allocator<T>>
23  class InlinedVector {
24    static_assert(N > 0, "`absl::InlinedVector` requires an inlined capacity.");
25    using Storage = inlined_vector_internal::Storage<T, N, A>;
26    template <typename TheA>
27    using AllocatorTraits = inlined_vector_internal::AllocatorTraits<TheA>;
28    template <typename TheA>
29    using MoveIterator = inlined_vector_internal::MoveIterator<TheA>;
30    template <typename TheA>
31    using IsMoveAssignOk = inlined_vector_internal::IsMoveAssignOk<TheA>;
32    template <typename TheA, typename Iterator>
33    using IteratorValueAdapter =
34        inlined_vector_internal::IteratorValueAdapter<TheA, Iterator>;
35    template <typename TheA>
36    using CopyValueAdapter = inlined_vector_internal::CopyValueAdapter<TheA>;
37    template <typename TheA>
38    using DefaultValueAdapter =
39        inlined_vector_internal::DefaultValueAdapter<TheA>;
40    template <typename Iterator>
41    using EnableIfAtLeastForwardIterator = absl::enable_if_t<
42        inlined_vector_internal::IsAtLeastForwardIterator<Iterator>::value, int>;
43    template <typename Iterator>
44    using DisableIfAtLeastForwardIterator = absl::enable_if_t<
45        !inlined_vector_internal::IsAtLeastForwardIterator<Iterator>::value, int>;
46    using MemcpyPolicy = typename Storage::MemcpyPolicy;
47    using ElementwiseAssignPolicy = typename Storage::ElementwiseAssignPolicy;
48    using ElementwiseConstructPolicy =
49        typename Storage::ElementwiseConstructPolicy;
50    using MoveAssignmentPolicy = typename Storage::MoveAssignmentPolicy;
51   public:
52    using allocator_type = A;
53    using value_type = inlined_vector_internal::ValueType<A>;
54    using pointer = inlined_vector_internal::Pointer<A>;
55    using const_pointer = inlined_vector_internal::ConstPointer<A>;
56    using size_type = inlined_vector_internal::SizeType<A>;
57    using difference_type = inlined_vector_internal::DifferenceType<A>;
58    using reference = inlined_vector_internal::Reference<A>;
59    using const_reference = inlined_vector_internal::ConstReference<A>;
60    using iterator = inlined_vector_internal::Iterator<A>;
61    using const_iterator = inlined_vector_internal::ConstIterator<A>;
62    using reverse_iterator = inlined_vector_internal::ReverseIterator<A>;
63    using const_reverse_iterator =
64        inlined_vector_internal::ConstReverseIterator<A>;
65    InlinedVector() noexcept(noexcept(allocator_type())) : storage_() {}
66    explicit InlinedVector(const allocator_type& allocator) noexcept
67        : storage_(allocator) {}
68    explicit InlinedVector(size_type n,
69                           const allocator_type& allocator = allocator_type())
70        : storage_(allocator) {
71      storage_.Initialize(DefaultValueAdapter<A>(), n);
72    }
73    InlinedVector(size_type n, const_reference v,
74                  const allocator_type& allocator = allocator_type())
75        : storage_(allocator) {
76      storage_.Initialize(CopyValueAdapter<A>(std::addressof(v)), n);
77    }
78    InlinedVector(std::initializer_list<value_type> list,
79                  const allocator_type& allocator = allocator_type())
80        : InlinedVector(list.begin(), list.end(), allocator) {}
81    template <typename ForwardIterator,
82              EnableIfAtLeastForwardIterator<ForwardIterator> = 0>
83    InlinedVector(ForwardIterator first, ForwardIterator last,
84                  const allocator_type& allocator = allocator_type())
85        : storage_(allocator) {
86      storage_.Initialize(IteratorValueAdapter<A, ForwardIterator>(first),
87                          static_cast<size_t>(std::distance(first, last)));
88    }
89    template <typename InputIterator,
90              DisableIfAtLeastForwardIterator<InputIterator> = 0>
91    InlinedVector(InputIterator first, InputIterator last,
92                  const allocator_type& allocator = allocator_type())
93        : storage_(allocator) {
94      std::copy(first, last, std::back_inserter(*this));
95    }
96    InlinedVector(const InlinedVector& other)
97        : InlinedVector(other, other.storage_.GetAllocator()) {}
98    InlinedVector(const InlinedVector& other, const allocator_type& allocator)
99        : storage_(allocator) {
100      if (other.empty()) {
101        return;
102      }
103      if (absl::is_trivially_copy_constructible<value_type>::value &&
104          std::is_same<A, std::allocator<value_type>>::value &&
105          !other.storage_.GetIsAllocated()) {
106        storage_.MemcpyFrom(other.storage_);
107        return;
108      }
109      storage_.InitFrom(other.storage_);
110    }
111    InlinedVector(InlinedVector&& other) noexcept(
112        absl::allocator_is_nothrow<allocator_type>::value ||
113        std::is_nothrow_move_constructible<value_type>::value)
114        : storage_(other.storage_.GetAllocator()) {
115      if (absl::is_trivially_relocatable<value_type>::value &&
116          std::is_same<A, std::allocator<value_type>>::value) {
117        storage_.MemcpyFrom(other.storage_);
118        other.storage_.SetInlinedSize(0);
119        return;
120      }
121      if (other.storage_.GetIsAllocated()) {
122        storage_.SetAllocation({other.storage_.GetAllocatedData(),
123                                other.storage_.GetAllocatedCapacity()});
124        storage_.SetAllocatedSize(other.storage_.GetSize());
125        other.storage_.SetInlinedSize(0);
126        return;
127      }
128      IteratorValueAdapter<A, MoveIterator<A>> other_values(
129          MoveIterator<A>(other.storage_.GetInlinedData()));
130      inlined_vector_internal::ConstructElements<A>(
131          storage_.GetAllocator(), storage_.GetInlinedData(), other_values,
132          other.storage_.GetSize());
133      storage_.SetInlinedSize(other.storage_.GetSize());
134    }
135    InlinedVector(
136        InlinedVector&& other,
137        const allocator_type&
138            allocator) noexcept(absl::allocator_is_nothrow<allocator_type>::value)
139        : storage_(allocator) {
140      if (absl::is_trivially_relocatable<value_type>::value &&
141          std::is_same<A, std::allocator<value_type>>::value) {
142        storage_.MemcpyFrom(other.storage_);
143        other.storage_.SetInlinedSize(0);
144        return;
145      }
146      if ((storage_.GetAllocator() == other.storage_.GetAllocator()) &&
147          other.storage_.GetIsAllocated()) {
148        storage_.SetAllocation({other.storage_.GetAllocatedData(),
149                                other.storage_.GetAllocatedCapacity()});
150        storage_.SetAllocatedSize(other.storage_.GetSize());
151        other.storage_.SetInlinedSize(0);
152        return;
153      }
154      storage_.Initialize(
155          IteratorValueAdapter<A, MoveIterator<A>>(MoveIterator<A>(other.data())),
156          other.size());
157    }
158    ~InlinedVector() {}
159    bool empty() const noexcept { return !size(); }
160    size_type size() const noexcept { return storage_.GetSize(); }
161    size_type max_size() const noexcept {
162      return (std::min)(AllocatorTraits<A>::max_size(storage_.GetAllocator()),
163                        (std::numeric_limits<size_type>::max)() / 2);
164    }
165    size_type capacity() const noexcept {
166      return storage_.GetIsAllocated() ? storage_.GetAllocatedCapacity()
167                                       : storage_.GetInlinedCapacity();
168    }
169    pointer data() noexcept ABSL_ATTRIBUTE_LIFETIME_BOUND {
170      return storage_.GetIsAllocated() ? storage_.GetAllocatedData()
171                                       : storage_.GetInlinedData();
172    }
173    const_pointer data() const noexcept ABSL_ATTRIBUTE_LIFETIME_BOUND {
174      return storage_.GetIsAllocated() ? storage_.GetAllocatedData()
175                                       : storage_.GetInlinedData();
176    }
177    reference operator[](size_type i) ABSL_ATTRIBUTE_LIFETIME_BOUND {
178      ABSL_HARDENING_ASSERT(i < size());
179      return data()[i];
180    }
181    const_reference operator[](size_type i) const ABSL_ATTRIBUTE_LIFETIME_BOUND {
182      ABSL_HARDENING_ASSERT(i < size());
183      return data()[i];
184    }
185    reference at(size_type i) ABSL_ATTRIBUTE_LIFETIME_BOUND {
186      if (ABSL_PREDICT_FALSE(i >= size())) {
187        base_internal::ThrowStdOutOfRange(
188            "`InlinedVector::at(size_type)` failed bounds check");
189      }
190      return data()[i];
191    }
192    const_reference at(size_type i) const ABSL_ATTRIBUTE_LIFETIME_BOUND {
193      if (ABSL_PREDICT_FALSE(i >= size())) {
194        base_internal::ThrowStdOutOfRange(
195            "`InlinedVector::at(size_type) const` failed bounds check");
196      }
197      return data()[i];
198    }
199    reference front() ABSL_ATTRIBUTE_LIFETIME_BOUND {
200      ABSL_HARDENING_ASSERT(!empty());
201      return data()[0];
202    }
203    const_reference front() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
204      ABSL_HARDENING_ASSERT(!empty());
205      return data()[0];
206    }
207    reference back() ABSL_ATTRIBUTE_LIFETIME_BOUND {
208      ABSL_HARDENING_ASSERT(!empty());
209      return data()[size() - 1];
210    }
211    const_reference back() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
212      ABSL_HARDENING_ASSERT(!empty());
213      return data()[size() - 1];
214    }
215    iterator begin() noexcept ABSL_ATTRIBUTE_LIFETIME_BOUND { return data(); }
216    const_iterator begin() const noexcept ABSL_ATTRIBUTE_LIFETIME_BOUND {
217      return data();
218    }
219    iterator end() noexcept ABSL_ATTRIBUTE_LIFETIME_BOUND {
220      return data() + size();
221    }
222    const_iterator end() const noexcept ABSL_ATTRIBUTE_LIFETIME_BOUND {
223      return data() + size();
224    }
225    const_iterator cbegin() const noexcept ABSL_ATTRIBUTE_LIFETIME_BOUND {
226      return begin();
227    }
228    const_iterator cend() const noexcept ABSL_ATTRIBUTE_LIFETIME_BOUND {
229      return end();
230    }
231    reverse_iterator rbegin() noexcept ABSL_ATTRIBUTE_LIFETIME_BOUND {
232      return reverse_iterator(end());
233    }
234    const_reverse_iterator rbegin() const noexcept ABSL_ATTRIBUTE_LIFETIME_BOUND {
235      return const_reverse_iterator(end());
236    }
237    reverse_iterator rend() noexcept ABSL_ATTRIBUTE_LIFETIME_BOUND {
238      return reverse_iterator(begin());
239    }
240    const_reverse_iterator rend() const noexcept ABSL_ATTRIBUTE_LIFETIME_BOUND {
241      return const_reverse_iterator(begin());
242    }
243    const_reverse_iterator crbegin() const noexcept
244        ABSL_ATTRIBUTE_LIFETIME_BOUND {
245      return rbegin();
246    }
247    const_reverse_iterator crend() const noexcept ABSL_ATTRIBUTE_LIFETIME_BOUND {
248      return rend();
249    }
250    allocator_type get_allocator() const { return storage_.GetAllocator(); }
251    InlinedVector& operator=(std::initializer_list<value_type> list) {
252      assign(list.begin(), list.end());
253      return *this;
254    }
255    InlinedVector& operator=(const InlinedVector& other) {
256      if (ABSL_PREDICT_TRUE(this != std::addressof(other))) {
257        const_pointer other_data = other.data();
258        assign(other_data, other_data + other.size());
259      }
260      return *this;
261    }
262    InlinedVector& operator=(InlinedVector&& other) {
263      if (ABSL_PREDICT_TRUE(this != std::addressof(other))) {
264        MoveAssignment(MoveAssignmentPolicy{}, std::move(other));
265      }
266      return *this;
267    }
268    void assign(size_type n, const_reference v) {
269      storage_.Assign(CopyValueAdapter<A>(std::addressof(v)), n);
270    }
271    void assign(std::initializer_list<value_type> list) {
272      assign(list.begin(), list.end());
273    }
274    template <typename ForwardIterator,
275              EnableIfAtLeastForwardIterator<ForwardIterator> = 0>
276    void assign(ForwardIterator first, ForwardIterator last) {
277      storage_.Assign(IteratorValueAdapter<A, ForwardIterator>(first),
278                      static_cast<size_t>(std::distance(first, last)));
279    }
280    template <typename InputIterator,
281              DisableIfAtLeastForwardIterator<InputIterator> = 0>
282    void assign(InputIterator first, InputIterator last) {
283      size_type i = 0;
284      for (; i < size() && first != last; ++i, static_cast<void>(++first)) {
285        data()[i] = *first;
286      }
287      erase(data() + i, data() + size());
288      std::copy(first, last, std::back_inserter(*this));
289    }
290    void resize(size_type n) {
291      ABSL_HARDENING_ASSERT(n <= max_size());
292      storage_.Resize(DefaultValueAdapter<A>(), n);
293    }
294    void resize(size_type n, const_reference v) {
295      ABSL_HARDENING_ASSERT(n <= max_size());
296      storage_.Resize(CopyValueAdapter<A>(std::addressof(v)), n);
297    }
298    iterator insert(const_iterator pos,
299                    const_reference v) ABSL_ATTRIBUTE_LIFETIME_BOUND {
300      return emplace(pos, v);
301    }
302    iterator insert(const_iterator pos,
303                    value_type&& v) ABSL_ATTRIBUTE_LIFETIME_BOUND {
304      return emplace(pos, std::move(v));
305    }
306    iterator insert(const_iterator pos, size_type n,
307                    const_reference v) ABSL_ATTRIBUTE_LIFETIME_BOUND {
308      ABSL_HARDENING_ASSERT(pos >= begin());
309      ABSL_HARDENING_ASSERT(pos <= end());
310      if (ABSL_PREDICT_TRUE(n != 0)) {
311        value_type dealias = v;
312  #if !defined(__clang__) && defined(__GNUC__)
313  #pragma GCC diagnostic push
314  #pragma GCC diagnostic ignored "-Wmaybe-uninitialized"
315  #endif
316        return storage_.Insert(pos, CopyValueAdapter<A>(std::addressof(dealias)),
317                               n);
318  #if !defined(__clang__) && defined(__GNUC__)
319  #pragma GCC diagnostic pop
320  #endif
321      } else {
322        return const_cast<iterator>(pos);
323      }
324    }
325    iterator insert(const_iterator pos, std::initializer_list<value_type> list)
326        ABSL_ATTRIBUTE_LIFETIME_BOUND {
327      return insert(pos, list.begin(), list.end());
328    }
329    template <typename ForwardIterator,
330              EnableIfAtLeastForwardIterator<ForwardIterator> = 0>
331    iterator insert(const_iterator pos, ForwardIterator first,
332                    ForwardIterator last) ABSL_ATTRIBUTE_LIFETIME_BOUND {
333      ABSL_HARDENING_ASSERT(pos >= begin());
334      ABSL_HARDENING_ASSERT(pos <= end());
<span onclick='openModal()' class='match'>335      if (ABSL_PREDICT_TRUE(first != last)) {
336        return storage_.Insert(
337            pos, IteratorValueAdapter<A, ForwardIterator>(first),
338            static_cast<size_type>(std::distance(first, last)));
339      } else {
340        return const_cast<iterator>(pos);
341      }
342    }
</span>343    template <typename InputIterator,
344              DisableIfAtLeastForwardIterator<InputIterator> = 0>
345    iterator insert(const_iterator pos, InputIterator first,
346                    InputIterator last) ABSL_ATTRIBUTE_LIFETIME_BOUND {
347      ABSL_HARDENING_ASSERT(pos >= begin());
348      ABSL_HARDENING_ASSERT(pos <= end());
349      size_type index = static_cast<size_type>(std::distance(cbegin(), pos));
350      for (size_type i = index; first != last; ++i, static_cast<void>(++first)) {
351        insert(data() + i, *first);
352      }
353      return iterator(data() + index);
354    }
355    template <typename... Args>
356    iterator emplace(const_iterator pos,
357                     Args&&... args) ABSL_ATTRIBUTE_LIFETIME_BOUND {
358      ABSL_HARDENING_ASSERT(pos >= begin());
359      ABSL_HARDENING_ASSERT(pos <= end());
360      value_type dealias(std::forward<Args>(args)...);
361  #if !defined(__clang__) && defined(__GNUC__)
362  #pragma GCC diagnostic push
363  #pragma GCC diagnostic ignored "-Wmaybe-uninitialized"
364  #endif
365      return storage_.Insert(pos,
366                             IteratorValueAdapter<A, MoveIterator<A>>(
367                                 MoveIterator<A>(std::addressof(dealias))),
368                             1);
369  #if !defined(__clang__) && defined(__GNUC__)
370  #pragma GCC diagnostic pop
371  #endif
372    }
373    template <typename... Args>
374    reference emplace_back(Args&&... args) ABSL_ATTRIBUTE_LIFETIME_BOUND {
375      return storage_.EmplaceBack(std::forward<Args>(args)...);
376    }
377    void push_back(const_reference v) { static_cast<void>(emplace_back(v)); }
378    void push_back(value_type&& v) {
379      static_cast<void>(emplace_back(std::move(v)));
380    }
381    void pop_back() noexcept {
382      ABSL_HARDENING_ASSERT(!empty());
383      AllocatorTraits<A>::destroy(storage_.GetAllocator(), data() + (size() - 1));
384      storage_.SubtractSize(1);
385    }
386    iterator erase(const_iterator pos) ABSL_ATTRIBUTE_LIFETIME_BOUND {
387      ABSL_HARDENING_ASSERT(pos >= begin());
388      ABSL_HARDENING_ASSERT(pos < end());
389      return storage_.Erase(pos, pos + 1);
390    }
391    iterator erase(const_iterator from,
392                   const_iterator to) ABSL_ATTRIBUTE_LIFETIME_BOUND {
393      ABSL_HARDENING_ASSERT(from >= begin());
394      ABSL_HARDENING_ASSERT(from <= to);
395      ABSL_HARDENING_ASSERT(to <= end());
396      if (ABSL_PREDICT_TRUE(from != to)) {
397        return storage_.Erase(from, to);
398      } else {
399        return const_cast<iterator>(from);
400      }
401    }
402    void clear() noexcept {
403      inlined_vector_internal::DestroyAdapter<A>::DestroyElements(
404          storage_.GetAllocator(), data(), size());
405      storage_.DeallocateIfAllocated();
406      storage_.SetInlinedSize(0);
407    }
408    void reserve(size_type n) { storage_.Reserve(n); }
409    void shrink_to_fit() {
410      if (storage_.GetIsAllocated()) {
411        storage_.ShrinkToFit();
412      }
413    }
414    void swap(InlinedVector& other) {
415      if (ABSL_PREDICT_TRUE(this != std::addressof(other))) {
416        storage_.Swap(std::addressof(other.storage_));
417      }
418    }
419   private:
420    template <typename H, typename TheT, size_t TheN, typename TheA>
421    friend H AbslHashValue(H h, const absl::InlinedVector<TheT, TheN, TheA>& a);
422    void MoveAssignment(MemcpyPolicy, InlinedVector&& other) {
423      static_assert(absl::is_trivially_destructible<value_type>::value, "");
424      static_assert(std::is_same<A, std::allocator<value_type>>::value, "");
425      storage_.DeallocateIfAllocated();
426      storage_.MemcpyFrom(other.storage_);
427      other.storage_.SetInlinedSize(0);
428    }
429    void DestroyExistingAndAdopt(InlinedVector&& other) {
430      ABSL_HARDENING_ASSERT(other.storage_.GetIsAllocated());
431      inlined_vector_internal::DestroyAdapter<A>::DestroyElements(
432          storage_.GetAllocator(), data(), size());
433      storage_.DeallocateIfAllocated();
434      storage_.MemcpyFrom(other.storage_);
435      other.storage_.SetInlinedSize(0);
436    }
437    void MoveAssignment(ElementwiseAssignPolicy, InlinedVector&& other) {
438      if (other.storage_.GetIsAllocated()) {
439        DestroyExistingAndAdopt(std::move(other));
440        return;
441      }
442      storage_.Assign(IteratorValueAdapter<A, MoveIterator<A>>(
443                          MoveIterator<A>(other.storage_.GetInlinedData())),
444                      other.size());
445    }
446    void MoveAssignment(ElementwiseConstructPolicy, InlinedVector&& other) {
447      if (other.storage_.GetIsAllocated()) {
448        DestroyExistingAndAdopt(std::move(other));
449        return;
450      }
451      inlined_vector_internal::DestroyAdapter<A>::DestroyElements(
452          storage_.GetAllocator(), data(), size());
453      storage_.DeallocateIfAllocated();
454      IteratorValueAdapter<A, MoveIterator<A>> other_values(
455          MoveIterator<A>(other.storage_.GetInlinedData()));
456      inlined_vector_internal::ConstructElements<A>(
457          storage_.GetAllocator(), storage_.GetInlinedData(), other_values,
458          other.storage_.GetSize());
459      storage_.SetInlinedSize(other.storage_.GetSize());
460    }
461    Storage storage_;
462  };
463  template <typename T, size_t N, typename A>
464  void swap(absl::InlinedVector<T, N, A>& a,
465            absl::InlinedVector<T, N, A>& b) noexcept(noexcept(a.swap(b))) {
466    a.swap(b);
467  }
468  template <typename T, size_t N, typename A>
469  bool operator==(const absl::InlinedVector<T, N, A>& a,
470                  const absl::InlinedVector<T, N, A>& b) {
471    auto a_data = a.data();
472    auto b_data = b.data();
473    return std::equal(a_data, a_data + a.size(), b_data, b_data + b.size());
474  }
475  template <typename T, size_t N, typename A>
476  bool operator!=(const absl::InlinedVector<T, N, A>& a,
477                  const absl::InlinedVector<T, N, A>& b) {
478    return !(a == b);
479  }
480  template <typename T, size_t N, typename A>
481  bool operator<(const absl::InlinedVector<T, N, A>& a,
482                 const absl::InlinedVector<T, N, A>& b) {
483    auto a_data = a.data();
484    auto b_data = b.data();
485    return std::lexicographical_compare(a_data, a_data + a.size(), b_data,
486                                        b_data + b.size());
487  }
488  template <typename T, size_t N, typename A>
489  bool operator>(const absl::InlinedVector<T, N, A>& a,
490                 const absl::InlinedVector<T, N, A>& b) {
491    return b < a;
492  }
493  template <typename T, size_t N, typename A>
494  bool operator<=(const absl::InlinedVector<T, N, A>& a,
495                  const absl::InlinedVector<T, N, A>& b) {
496    return !(b < a);
497  }
498  template <typename T, size_t N, typename A>
499  bool operator>=(const absl::InlinedVector<T, N, A>& a,
500                  const absl::InlinedVector<T, N, A>& b) {
501    return !(a < b);
502  }
503  template <typename H, typename T, size_t N, typename A>
504  H AbslHashValue(H h, const absl::InlinedVector<T, N, A>& a) {
505    auto size = a.size();
506    return H::combine(H::combine_contiguous(std::move(h), a.data(), size), size);
507  }
508  ABSL_NAMESPACE_END
509  }  
510  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-rejctmap.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-inlined_vector.h</div>
                </div>
                <div class="column column_space"><pre><code>62      } else if (rejected()) {
63        return MAP_REJECT_TEMP;
64      } else {
65        return MAP_ACCEPT;
66      }
67    }
</pre></code></div>
                <div class="column column_space"><pre><code>335      if (ABSL_PREDICT_TRUE(first != last)) {
336        return storage_.Insert(
337            pos, IteratorValueAdapter<A, ForwardIterator>(first),
338            static_cast<size_type>(std::distance(first, last)));
339      } else {
340        return const_cast<iterator>(pos);
341      }
342    }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    