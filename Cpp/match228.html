<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for targa.c &amp; CompressorSIMD.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for targa.c &amp; CompressorSIMD.cpp
      </h3>
<h1 align="center">
        1.3%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>targa.c (2.351097%)<th>CompressorSIMD.cpp (0.9511731%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(589-602)<td><a href="#" name="0">(328-333)</a><td align="center"><font color="#ff0000">15</font>
</td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>targa.c</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef _MSC_VER
2 #  define WIN32_LEAN_AND_MEAN
3 #  define _CRT_SECURE_NO_WARNINGS
4 #endif
5 #include &lt;stdio.h&gt;
6 #include &lt;stdlib.h&gt;
7 #include &lt;string.h&gt;
8 #include &lt;errno.h&gt;
9 #include "targa.h"
10 #define TGA_COLOR_MAP_NONE							0
11 #define TGA_IMAGE_TYPE_NONE							0
12 #define TGA_IMAGE_TYPE_CM							1
13 #define TGA_IMAGE_TYPE_BGR							2
14 #define TGA_IMAGE_TYPE_BW							3
15 #define TGA_IMAGE_TYPE_RLE_CM						9
16 #define TGA_IMAGE_TYPE_RLE_BGR						10
17 #define TGA_IMAGE_TYPE_RLE_BW						11
18 #define TGA_R										0
19 #define TGA_G										1
20 #define TGA_B										2
21 #define TGA_A										3
22 static int handleTargaError(FILE *fh, int errorCode, const char *function,
23 		size_t line);
24 static int ctoi(char value);
25 static char *localStrndup(char *string, int length);
26 #define targaErrorf() \
27 	handleTargaError(fh, rc, __FUNCTION__, __LINE__)
28 static int handleTargaError(FILE *fh, int errorCode, const char *function,
29 		size_t line)
30 {
31 	char *errorMessage = NULL;
32 	if((errorMessage = strerror(errno)) == NULL) {
33 		errorMessage = "uknown error";
34 	}
35 	fprintf(stderr, "[%s():%i] error(%i) - #%i, '%s'.\n",
36 			(char *)function, (int)line, errorCode, (int)errno, errorMessage);
37 	if(fh != NULL) {
38 		fclose(fh);
39 	}
40 	return -1;
41 }
42 static int ctoi(char value)
43 {
44 	return (int)((unsigned char)value);
45 }
46 static char *localStrndup(char *string, int length)
47 {
48 	char *result = NULL;
49 	if((string == NULL) || (length &lt; 1)) {
50 		fprintf(stderr, "[%s():%i] error - invalid or missing argument(s).\n",
51 				__FUNCTION__, __LINE__);
52 		return NULL;
53 	}
54 #if defined(_GNU_SOURCE)
55 	result = strndup(string, length);
56 #else 	result = (char *)malloc(sizeof(char) * (length + 1));
57 	memset(result, 0, (sizeof(char) * (length + 1)));
58 	memcpy(result, string, length);
59 #endif 
60 	return result;
61 }
62 int targa_init(Targa *targa)
63 {
64 	if(targa == NULL) {
65 		fprintf(stderr, "[%s():%i] error - invalid or missing argument(s).\n",
66 				__FUNCTION__, __LINE__);
67 		return -1;
68 	}
69 	memset((void *)targa, 0, sizeof(Targa));
70 	targa-&gt;width = 0;
71 	targa-&gt;height = 0;
72 	targa-&gt;imageLength = 0;
73 	targa-&gt;image = NULL;
74 	return 0;
75 }
76 int targa_free(Targa *targa)
77 {
78 	if(targa == NULL) {
79 		fprintf(stderr, "[%s():%i] error - invalid or missing argument(s).\n",
80 				__FUNCTION__, __LINE__);
81 		return -1;
82 	}
83 	if(targa-&gt;image != NULL) {
84 		free(targa-&gt;image);
85 	}
86 	memset((void *)targa, 0, sizeof(Targa));
87 	return 0;
88 }
89 int targa_getDimensions(Targa *targa, int *width, int *height)
90 {
91 	if((targa == NULL) || (width == NULL) || (height == NULL)) {
92 		fprintf(stderr, "[%s():%i] error - invalid or missing argument(s).\n",
93 				__FUNCTION__, __LINE__);
94 		return -1;
95 	}
96 	*width = targa-&gt;width;
97 	*height = targa-&gt;height;
98 	return 0;
99 }
100 int targa_getImageLength(Targa *targa, int *imageLength)
101 {
102 	if((targa == NULL) || (imageLength == NULL)) {
103 		fprintf(stderr, "[%s():%i] error - invalid or missing argument(s).\n",
104 				__FUNCTION__, __LINE__);
105 		return -1;
106 	}
107 	*imageLength = targa-&gt;imageLength;
108 	return 0;
109 }
110 int targa_getRgbaTexture(Targa *targa, char **texture, int *textureLength)
111 {
112 	if((targa == NULL) || (texture == NULL) || (textureLength == NULL)) {
113 		fprintf(stderr, "[%s():%i] error - invalid or missing argument(s).\n",
114 				__FUNCTION__, __LINE__);
115 		return -1;
116 	}
117 	*texture = (char *)targa-&gt;image;
118 	*textureLength = targa-&gt;imageLength;
119 	return 0;
120 }
121 int targa_loadFromFile(Targa *targa, char *filename)
122 {
123 	int rc = 0;
124 	int fileLength = 0;
125 	unsigned char *buffer = NULL;
126 	FILE *fh = NULL;
127 	if((targa == NULL) || (filename == NULL)) {
128 		fprintf(stderr, "[%s():%i] error - invalid or missing argument(s).\n",
129 				__FUNCTION__, __LINE__);
130 		return -1;
131 	}
132 	if((fh = fopen(filename, "r+b")) == NULL) {
133 		return targaErrorf();
134 	}
135 	if((rc = fseek(fh, 0, SEEK_END)) != 0) {
136 		return targaErrorf();
137 	}
138 	if((fileLength = ftell(fh)) &lt; 0) {
139 		return targaErrorf();
140 	}
141 	if((rc = fseek(fh, 0, SEEK_SET)) != 0) {
142 		return targaErrorf();
143 	}
144 	if(fileLength &lt; 18) {
145 		fprintf(stderr, "error - TGA file '%s' length %i invalid.\n",
146 				filename, fileLength);
147 		fclose(fh);
148 		return -1;
149 	}
150 	buffer = (unsigned char *)malloc(sizeof(unsigned char) * fileLength);
151 	memset(buffer, 0, (sizeof(unsigned char) * fileLength));
152 	rc = (int)fread((char *)buffer, sizeof(char), fileLength, fh);
153 	if(rc != fileLength) {
154 		return targaErrorf();
155 	}
156 	fclose(fh);
157 	rc = targa_loadFromData(targa, buffer, fileLength);
158 	free(buffer);
159 	return rc;
160 }
161 int targa_loadFromData(Targa *targa, const unsigned char *data, int dataLength)
162 {
163 	short sNumber = 0;
164 	int ii = 0;
165 	int nn = 0;
166 	int imageIdLength = 0;
167 	int colorMap = 0;
168 	int imageType = 0;
169 	int bitLength = 0;
170 	int colorMode = 0;
171 	int length = 0;
172 	int rleId = 0;
173 	int pixel[4];
174 	unsigned char *imageId = NULL;
175 	const unsigned char *ptr = NULL;
176 	if((targa == NULL) || (data == NULL) || (dataLength &lt; 18)) {
177 		fprintf(stderr, "[%s():%i] error - invalid or missing argument(s).\n",
178 				__FUNCTION__, __LINE__);
179 		return -1;
180 	}
181 	ptr = data;
182 	imageIdLength = (int)ptr[0];
183 	ptr++;
184 	if((int)(ptr - data) &gt; dataLength) {
185 		fprintf(stderr, "[%s():%i] error - detected data overrun with %i vs "
186 				"%i.\n", __FUNCTION__, __LINE__, (int)(ptr - data),
187 				dataLength);
188 		return -1;
189 	}
190 	colorMap = (int)ptr[0];
191 	ptr++;
192 	if((int)(ptr - data) &gt; dataLength) {
193 		fprintf(stderr, "[%s():%i] error - detected data overrun with %i vs "
194 				"%i.\n", __FUNCTION__, __LINE__, (int)(ptr - data),
195 				dataLength);
196 		return -1;
197 	}
198 	if(colorMap != TGA_COLOR_MAP_NONE) {
199 		fprintf(stderr, "[%s():%i] error - unable to read TARGA color map "
200 				"%i.\n", __FUNCTION__, __LINE__, colorMap);
201 		return -1;
202 	}
203 	imageType = (int)ptr[0];
204 	ptr++;
205 	if((int)(ptr - data) &gt; dataLength) {
206 		fprintf(stderr, "[%s():%i] error - detected data overrun with %i vs "
207 				"%i.\n", __FUNCTION__, __LINE__, (int)(ptr - data),
208 				dataLength);
209 		return -1;
210 	}
211 	if((imageType == TGA_IMAGE_TYPE_NONE) ||
212 			(imageType == TGA_IMAGE_TYPE_CM) ||
213 			(imageType == TGA_IMAGE_TYPE_RLE_CM)) {
214 		fprintf(stderr, "[%s():%i] error - unsupported image type %i.\n",
215 				__FUNCTION__, __LINE__, imageType);
216 		return -1;
217 	}
218 	ptr += 9;
219 	if((int)(ptr - data) &gt; dataLength) {
220 		fprintf(stderr, "[%s():%i] error - detected data overrun with %i vs "
221 				"%i.\n", __FUNCTION__, __LINE__, (int)(ptr - data),
222 				dataLength);
223 		return -1;
224 	}
225 	memcpy((char *)&amp;sNumber, ptr, sizeof(short));
226 	ptr += sizeof(short);
227 	if((int)(ptr - data) &gt; dataLength) {
228 		fprintf(stderr, "[%s():%i] error - detected data overrun with %i vs "
229 				"%i.\n", __FUNCTION__, __LINE__, (int)(ptr - data),
230 				dataLength);
231 		return -1;
232 	}
233 	if(sNumber &lt; 1) {
234 		fprintf(stderr, "[%s():%i] error - invalid image width %i.\n",
235 				__FUNCTION__, __LINE__, (int)sNumber);
236 		return -1;
237 	}
238 	targa-&gt;width = (int)sNumber;
239 	memcpy((char *)&amp;sNumber, ptr, sizeof(short));
240 	ptr += sizeof(short);
241 	if((int)(ptr - data) &gt; dataLength) {
242 		fprintf(stderr, "[%s():%i] error - detected data overrun with %i vs "
243 				"%i.\n", __FUNCTION__, __LINE__, (int)(ptr - data),
244 				dataLength);
245 		return -1;
246 	}
247 	if(sNumber &lt; 1) {
248 		fprintf(stderr, "[%s():%i] error - invalid image height %i.\n",
249 				__FUNCTION__, __LINE__, (int)sNumber);
250 		return -1;
251 	}
252 	targa-&gt;height = (int)sNumber;
253 	bitLength = (int)ptr[0];
254 	ptr++;
255 	if((int)(ptr - data) &gt; dataLength) {
256 		fprintf(stderr, "[%s():%i] error - detected data overrun with %i vs "
257 				"%i.\n", __FUNCTION__, __LINE__, (int)(ptr - data),
258 				dataLength);
259 		return -1;
260 	}
261 	if((bitLength != 16) &amp;&amp; (bitLength != 24) &amp;&amp; (bitLength != 32)) {
262 		fprintf(stderr, "[%s():%i] error - unknown pixel depth of %i-bits.\n",
263 				__FUNCTION__, __LINE__, bitLength);
264 		return -1;
265 	}
266 	if((bitLength == 16) &amp;&amp;
267 			((imageType != TGA_IMAGE_TYPE_BGR) &amp;&amp;
268 			 (imageType != TGA_IMAGE_TYPE_BW))) {
269 		fprintf(stderr, "[%s():%i] error - unable to RLE-decode pixel depth "
270 				"of %i-bits.\n", __FUNCTION__, __LINE__, bitLength);
271 		return -1;
272 	}
273 	ptr++;
274 	if((int)(ptr - data) &gt; dataLength) {
275 		fprintf(stderr, "[%s():%i] error - detected data overrun with %i vs "
276 				"%i.\n", __FUNCTION__, __LINE__, (int)(ptr - data),
277 				dataLength);
278 		return -1;
279 	}
280 	if(imageIdLength &gt; 0) {
281 		if(((int)(ptr - data) + imageIdLength) &gt; dataLength) {
282 			fprintf(stderr, "[%s():%i] error - detected data overrun at %i "
283 					"(image ID) by %i bytes.\n", __FUNCTION__, __LINE__,
284 					(int)(ptr - data),
285 					(((int)(ptr - data) + imageIdLength) - dataLength));
286 			return -1;
287 		}
288 		imageId = (unsigned char *)localStrndup((char *)ptr, imageIdLength);
289 		ptr += imageIdLength;
290 		if((int)(ptr - data) &gt; dataLength) {
291 			fprintf(stderr, "[%s():%i] error - detected data overrun with %i "
292 					"vs %i.\n", __FUNCTION__, __LINE__, (int)(ptr - data),
293 					dataLength);
294 			return -1;
295 		}
296 	}
297 	targa-&gt;imageLength = (long int)(targa-&gt;width * targa-&gt;height * 4);
298 	targa-&gt;image = (unsigned char *)malloc(sizeof(unsigned char) *
299 			targa-&gt;imageLength);
300 	if((imageType == TGA_IMAGE_TYPE_BGR) || (imageType == TGA_IMAGE_TYPE_BW)) {
301 		if(bitLength == 16) {
302 			colorMode = 2;
303 		}
304 		else {
305 			colorMode = (bitLength / 8);
306 		}
307 		length = (targa-&gt;width * targa-&gt;height * colorMode);
308 		if(((int)(ptr - data) + length) &gt; dataLength) {
309 			fprintf(stderr, "[%s():%i] error - detected data overrun at %i "
310 					"(image pixels) by %i bytes.\n", __FUNCTION__, __LINE__,
311 					(int)(ptr - data),
312 					(((int)(ptr - data) + length) - dataLength));
313 			return -1;
314 		}
315 		for(ii = 0, nn = 0; ((ii &lt; length) &amp;&amp; (nn &lt; targa-&gt;imageLength));
316 				ii += colorMode, nn += 4) {
317 			if(colorMode == 2) {
318 				memcpy((char *)&amp;sNumber, ptr, sizeof(short));
319 				pixel[TGA_R] = ctoi((sNumber &amp; 0x1f) &lt;&lt; 3);
320 				pixel[TGA_G] = ctoi(((sNumber &gt;&gt; 5) &amp; 0x1f) &lt;&lt; 3);
321 				pixel[TGA_B] = ctoi(((sNumber &gt;&gt; 10) &amp; 0x1f) &lt;&lt; 3);
322 				pixel[TGA_A] = 255;
323 			}
324 			else {
325 				pixel[TGA_R] = ctoi(ptr[2]);
326 				pixel[TGA_G] = ctoi(ptr[1]);
327 				pixel[TGA_B] = ctoi(ptr[0]);
328 				if(colorMode == 3) {
329 					pixel[TGA_A] = 255;
330 				}
331 				else {
332 					pixel[TGA_A] = ctoi(ptr[3]);
333 				}
334 			}
335 			targa-&gt;image[(nn + 0)] = (unsigned char)pixel[TGA_R];
336 			targa-&gt;image[(nn + 1)] = (unsigned char)pixel[TGA_G];
337 			targa-&gt;image[(nn + 2)] = (unsigned char)pixel[TGA_B];
338 			targa-&gt;image[(nn + 3)] = (unsigned char)pixel[TGA_A];
339 			ptr += colorMode;
340 		}
341 	}
342 	else { 		ii = 0;
343     nn = 0;
344 		colorMode = (bitLength / 8);
345 		length = (targa-&gt;width * targa-&gt;height);
346 		while(ii &lt; length) {
347 			rleId = (int)ptr[0];
348 			ptr++;
349 			if((int)(ptr - data) &gt; dataLength) {
350 				fprintf(stderr, "[%s():%i] error - detected data overrun with "
351 						"%i vs %i.\n", __FUNCTION__, __LINE__,
352 						(int)(ptr - data), dataLength);
353 				return -1;
354 			}
355 			if(rleId &lt; 128) {
356 				rleId++;
357 				while(rleId &gt; 0) {
358 					pixel[TGA_R] = ctoi(ptr[2]);
359 					pixel[TGA_G] = ctoi(ptr[1]);
360 					pixel[TGA_B] = ctoi(ptr[0]);
361 					if(colorMode == 3) {
362 						pixel[TGA_A] = 255;
363 					}
364 					else {
365 						pixel[TGA_A] = ctoi(ptr[3]);
366 					}
367 					targa-&gt;image[(nn + 0)] = (unsigned char)pixel[TGA_R];
368 					targa-&gt;image[(nn + 1)] = (unsigned char)pixel[TGA_G];
369 					targa-&gt;image[(nn + 2)] = (unsigned char)pixel[TGA_B];
370 					targa-&gt;image[(nn + 3)] = (unsigned char)pixel[TGA_A];
371 					rleId--;
372 					ii++;
373 					nn += 4;
374 					if(nn &gt;= targa-&gt;imageLength) {
375 						break;
376 					}
377 					ptr += colorMode;
378 					if((int)(ptr - data) &gt; dataLength) {
379 						fprintf(stderr, "[%s():%i] error - detected data "
380 								"overrun with %i vs %i.\n", __FUNCTION__,
381 								__LINE__, (int)(ptr - data), dataLength);
382 						return -1;
383 					}
384 				}
385 			}
386 			else {
387 				pixel[TGA_R] = ctoi(ptr[2]);
388 				pixel[TGA_G] = ctoi(ptr[1]);
389 				pixel[TGA_B] = ctoi(ptr[0]);
390 				if(colorMode == 3) {
391 					pixel[TGA_A] = 255;
392 				}
393 				else {
394 					pixel[TGA_A] = ctoi(ptr[3]);
395 				}
396 				ptr += colorMode;
397 				if((int)(ptr - data) &gt; dataLength) {
398 					fprintf(stderr, "[%s():%i] error - detected data overrun "
399 							"with %i vs %i.\n", __FUNCTION__, __LINE__,
400 							(int)(ptr - data), dataLength);
401 					return -1;
402 				}
403 				rleId -= 127;
404 				while(rleId &gt; 0) {
405 					targa-&gt;image[(nn + 0)] = (unsigned char)pixel[TGA_R];
406 					targa-&gt;image[(nn + 1)] = (unsigned char)pixel[TGA_G];
407 					targa-&gt;image[(nn + 2)] = (unsigned char)pixel[TGA_B];
408 					targa-&gt;image[(nn + 3)] = (unsigned char)pixel[TGA_A];
409 					rleId--;
410 					ii++;
411 					nn += 4;
412 					if(nn &gt;= targa-&gt;imageLength) {
413 						break;
414 					}
415 				}
416 			}
417 			if(nn &gt;= targa-&gt;imageLength) {
418 				break;
419 			}
420 		}
421 	}
422 	if(imageId != NULL) {
423 		free(imageId);
424 	}
425 	return 0;
426 }
427 int targa_applyRgbaMask(Targa *targa, int colorType, unsigned char value)
428 {
429 	int ii = 0;
430 	int startPosition = 0;
431 	if((targa == NULL) ||
432 			((colorType != TARGA_COLOR_RED) &amp;&amp;
433 			 (colorType != TARGA_COLOR_GREEN) &amp;&amp;
434 			 (colorType != TARGA_COLOR_BLUE) &amp;&amp;
435 			 (colorType != TARGA_COLOR_ALPHA))) {
436 		fprintf(stderr, "[%s():%i] error - invalid or missing argument(s).\n",
437 				__FUNCTION__, __LINE__);
438 <a name="0"></a>		return -1;
439 	}
440 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>	switch(colorType) {
441 		case TARGA_COLOR_RED:
442 			startPosition = 0;
443 			break;
444 		case TARGA_COLOR_GREEN:
445 			startPosition = 1;
446 			break;
447 		case TARGA_COLOR_BLUE:
448 			startPosition = 2;
449 			break;
450 		case TARGA_COLOR_ALPHA:
451 			startPosition = 3;
452 			break;
453 	}</b></font>
454 	for(ii = startPosition; ii &lt; targa-&gt;imageLength; ii += 4) {
455 		targa-&gt;image[ii] += value;
456 	}
457 	return 0;
458 }
459 int targa_setRgbaChannel(Targa *targa, int colorType, unsigned char value)
460 {
461 	int ii = 0;
462 	int startPosition = 0;
463 	if((targa == NULL) ||
464 			((colorType != TARGA_COLOR_RED) &amp;&amp;
465 			 (colorType != TARGA_COLOR_GREEN) &amp;&amp;
466 			 (colorType != TARGA_COLOR_BLUE) &amp;&amp;
467 			 (colorType != TARGA_COLOR_ALPHA))) {
468 		fprintf(stderr, "[%s():%i] error - invalid or missing argument(s).\n",
469 				__FUNCTION__, __LINE__);
470 		return -1;
471 	}
472 	switch(colorType) {
473 		case TARGA_COLOR_RED:
474 			startPosition = 0;
475 			break;
476 		case TARGA_COLOR_GREEN:
477 			startPosition = 1;
478 			break;
479 		case TARGA_COLOR_BLUE:
480 			startPosition = 2;
481 			break;
482 		case TARGA_COLOR_ALPHA:
483 			startPosition = 3;
484 			break;
485 	}
486 	for(ii = startPosition; ii &lt; targa-&gt;imageLength; ii += 4) {
487 		targa-&gt;image[ii] = value;
488 	}
489 	return 0;
490 }
</pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>CompressorSIMD.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include "TexCompTypes.h"
2 #include "BC7Compressor.h"
3 #include "BC7CompressionModeSIMD.h"
4 #include "RGBAEndpointsSIMD.h"
5 #include "BCLookupTables.h"
6 #include "BitStream.h"
7 #ifdef _MSC_VER
8 #define ALIGN_SSE __declspec( align(16) )
9 #else
10 #define ALIGN_SSE __attribute__((aligned(16)))
11 #endif
12 static const uint32 kNumShapes2 = 64;
13 static const uint16 kShapeMask2[kNumShapes2] = {
14   0xcccc, 0x8888, 0xeeee, 0xecc8, 0xc880, 0xfeec, 0xfec8, 0xec80,
15   0xc800, 0xffec, 0xfe80, 0xe800, 0xffe8, 0xff00, 0xfff0, 0xf000,
16   0xf710, 0x008e, 0x7100, 0x08ce, 0x008c, 0x7310, 0x3100, 0x8cce,
17   0x088c, 0x3110, 0x6666, 0x366c, 0x17e8, 0x0ff0, 0x718e, 0x399c,
18   0xaaaa, 0xf0f0, 0x5a5a, 0x33cc, 0x3c3c, 0x55aa, 0x9696, 0xa55a,
19   0x73ce, 0x13c8, 0x324c, 0x3bdc, 0x6996, 0xc33c, 0x9966, 0x0660,
20   0x0272, 0x04e4, 0x4e40, 0x2720, 0xc936, 0x936c, 0x39c6, 0x639c,
21   0x9336, 0x9cc6, 0x817e, 0xe718, 0xccf0, 0x0fcc, 0x7744, 0xee22
22 };
23 static const int kAnchorIdx2[kNumShapes2] = {
24   15,15,15,15,15,15,15,15,
25   15,15,15,15,15,15,15,15,
26   15, 2, 8, 2, 2, 8, 8,15,
27   2, 8, 2, 2, 8, 8, 2, 2,
28   15,15, 6, 8, 2, 8,15,15,
29   2, 8, 2, 2, 2,15,15, 6,
30   6, 2, 6, 8,15,15, 2, 2,
31   15,15,15,15,15, 2, 2, 15
32 };
33 static const uint32 kNumShapes3 = 64;
34 static const uint16 kShapeMask3[kNumShapes3][2] = {
35   { 0xfecc, 0xf600 }, { 0xffc8, 0x7300 }, { 0xff90, 0x3310 }, { 0xecce, 0x00ce }, { 0xff00, 0xcc00 }, { 0xcccc, 0xcc00 }, { 0xffcc, 0x00cc }, { 0xffcc, 0x3300 },
36   { 0xff00, 0xf000 }, { 0xfff0, 0xf000 }, { 0xfff0, 0xff00 }, { 0xcccc, 0x8888 }, { 0xeeee, 0x8888 }, { 0xeeee, 0xcccc }, { 0xffec, 0xec80 }, { 0x739c, 0x7310 },
37   { 0xfec8, 0xc800 }, { 0x39ce, 0x3100 }, { 0xfff0, 0xccc0 }, { 0xfccc, 0x0ccc }, { 0xeeee, 0xee00 }, { 0xff88, 0x7700 }, { 0xeec0, 0xcc00 }, { 0x7730, 0x3300 },
38   { 0x0cee, 0x00cc }, { 0xffcc, 0xfc88 }, { 0x6ff6, 0x0660 }, { 0xff60, 0x6600 }, { 0xcbbc, 0xc88c }, { 0xf966, 0xf900 }, { 0xceec, 0x0cc0 }, { 0xff10, 0x7310 },
39   { 0xff80, 0xec80 }, { 0xccce, 0x08ce }, { 0xeccc, 0xec80 }, { 0x6666, 0x4444 }, { 0x0ff0, 0x0f00 }, { 0x6db6, 0x4924 }, { 0x6bd6, 0x4294 }, { 0xcf3c, 0x0c30 },
40   { 0xc3fc, 0x03c0 }, { 0xffaa, 0xff00 }, { 0xff00, 0x5500 }, { 0xfcfc, 0xcccc }, { 0xcccc, 0x0c0c }, { 0xf6f6, 0x6666 }, { 0xaffa, 0x0ff0 }, { 0xfff0, 0x5550 },
41   { 0xfaaa, 0xf000 }, { 0xeeee, 0x0e0e }, { 0xf8f8, 0x8888 }, { 0xfff0, 0x9990 }, { 0xeeee, 0xe00e }, { 0x8ff8, 0x8888 }, { 0xf666, 0xf000 }, { 0xff00, 0x9900 },
42   { 0xff66, 0xff00 }, { 0xcccc, 0xc00c }, { 0xcffc, 0xcccc }, { 0xf000, 0x9000 }, { 0x8888, 0x0808 }, { 0xfefe, 0xeeee }, { 0xfffa, 0xfff0 }, { 0x7bde, 0x7310 }
43 };
44 static const uint32 kWMValues[] = { 0x32b92180, 0x32ba3080, 0x31103200, 0x28103c80, 0x32bb3080, 0x25903600, 0x3530b900, 0x3b32b180, 0x34b5b980 };
45 static const uint32 kNumWMVals = sizeof(kWMValues) / sizeof(kWMValues[0]);
46 static uint32 gWMVal = -1;
47 static const int kAnchorIdx3[2][kNumShapes3] = {
48   { 3, 3,15,15, 8, 3,15,15,
49     8, 8, 6, 6, 6, 5, 3, 3,
50     3, 3, 8,15, 3, 3, 6,10,
51     5, 8, 8, 6, 8, 5,15,15,
52     8,15, 3, 5, 6,10, 8,15,
53     15, 3,15, 5,15,15,15,15,
54     3,15, 5, 5, 5, 8, 5,10,
55     5,10, 8,13,15,12, 3, 3 },
56   { 15, 8, 8, 3,15,15, 3, 8,
57     15,15,15,15,15,15,15, 8,
58     15, 8,15, 3,15, 8,15, 8,
59     3,15, 6,10,15,15,10, 8,
60     15, 3,15,10,10, 8, 9,10,
61     6,15, 8,15, 3, 6, 6, 8,
62     15, 3,15,15,15,15,15,15,
63     15,15,15,15, 3,15,15, 8 }
64 };
65 const uint32 kBC7InterpolationValuesScalar[4][16][2] = {
66   { {64, 0}, {33, 31}, {0, 64}, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
67   { {64, 0}, {43, 21}, {21, 43}, {0, 64}, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
68   { {64, 0}, {55, 9}, {46, 18}, {37, 27}, {27, 37}, {18, 46}, {9, 55}, {0, 64}, 0, 0, 0, 0, 0, 0, 0, 0 },
69   { {64, 0}, {60, 4}, {55, 9}, {51, 13}, {47, 17}, {43, 21}, {38, 26}, {34, 30}, {30, 34}, {26, 38}, {21, 43}, {17, 47}, {13, 51}, {9, 55}, {4, 60}, {0, 64} }
70 };
71 static const ALIGN_SSE uint32 kZeroVector[4] = { 0, 0, 0, 0 };
72 const __m128i kBC7InterpolationValuesSIMD[4][16][2] = {
73   { 
74     { _mm_set1_epi32(64), *((const __m128i *)kZeroVector)}, 
75     { _mm_set1_epi32(33), _mm_set1_epi32(31) }, 
76     { *((const __m128i *)kZeroVector), _mm_set1_epi32(64) }, 
77     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 
78   },
79   { 
80     { _mm_set1_epi32(64), *((const __m128i *)kZeroVector)}, 
81     { _mm_set1_epi32(43), _mm_set1_epi32(21)}, 
82     { _mm_set1_epi32(21), _mm_set1_epi32(43)}, 
83     { *((const __m128i *)kZeroVector), _mm_set1_epi32(64)}, 
84     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 
85   },
86   { 
87     { _mm_set1_epi32(64), *((const __m128i *)kZeroVector) }, 
88     { _mm_set1_epi32(55), _mm_set1_epi32(9) }, 
89     { _mm_set1_epi32(46), _mm_set1_epi32(18)}, 
90     { _mm_set1_epi32(37), _mm_set1_epi32(27)}, 
91     { _mm_set1_epi32(27), _mm_set1_epi32(37)}, 
92     { _mm_set1_epi32(18), _mm_set1_epi32(46)}, 
93     { _mm_set1_epi32(9), _mm_set1_epi32(55)}, 
94     { *((const __m128i *)kZeroVector), _mm_set1_epi32(64)}, 
95     0, 0, 0, 0, 0, 0, 0, 0 
96   },
97   { 
98     { _mm_set1_epi32(64), *((const __m128i *)kZeroVector)}, 
99     { _mm_set1_epi32(60), _mm_set1_epi32(4)}, 
100     { _mm_set1_epi32(55), _mm_set1_epi32(9)}, 
101     { _mm_set1_epi32(51), _mm_set1_epi32(13)}, 
102     { _mm_set1_epi32(47), _mm_set1_epi32(17)}, 
103     { _mm_set1_epi32(43), _mm_set1_epi32(21)}, 
104     { _mm_set1_epi32(38), _mm_set1_epi32(26)}, 
105     { _mm_set1_epi32(34), _mm_set1_epi32(30)}, 
106     { _mm_set1_epi32(30), _mm_set1_epi32(34)}, 
107     { _mm_set1_epi32(26), _mm_set1_epi32(38)}, 
108     { _mm_set1_epi32(21), _mm_set1_epi32(43)}, 
109     { _mm_set1_epi32(17), _mm_set1_epi32(47)}, 
110     { _mm_set1_epi32(13), _mm_set1_epi32(51)}, 
111     { _mm_set1_epi32(9), _mm_set1_epi32(55)}, 
112     { _mm_set1_epi32(4), _mm_set1_epi32(60)}, 
113     { *((const __m128i *)kZeroVector), _mm_set1_epi32(64)} 
114   }
115 };
116 static const ALIGN_SSE uint32 kByteValMask[4] = { 0xFF, 0xFF, 0xFF, 0xFF };
117 static inline __m128i sad(const __m128i &amp;a, const __m128i &amp;b) {
118   const __m128i maxab = _mm_max_epu8(a, b);
119   const __m128i minab = _mm_min_epu8(a, b);
120   return _mm_and_si128( *((const __m128i *)kByteValMask), _mm_subs_epu8( maxab, minab ) );
121 }
122 #include &lt;cstdio&gt;
123 #include &lt;cstdlib&gt;
124 #include &lt;cstring&gt;
125 #include &lt;cassert&gt;
126 #include &lt;cfloat&gt;
127 #include &lt;ctime&gt;
128 #ifndef max
129 template &lt;typename T&gt;
130 static T max(const T &amp;a, const T &amp;b) {
131   return (a &gt; b)? a : b; 
132 }
133 #endif
134 #ifndef min
135 template &lt;typename T&gt;
136 static T min(const T &amp;a, const T &amp;b) {
137   return (a &lt; b)? a : b;
138 }
139 #endif
140 int BC7CompressionModeSIMD::MaxAnnealingIterations = 50; int BC7CompressionModeSIMD::NumUses[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };
141 BC7CompressionModeSIMD::Attributes BC7CompressionModeSIMD::kModeAttributes[kNumModes] = {
142   { 0, 4, 3, 3, 4, 4, 4, 0, BC7CompressionModeSIMD::ePBitType_NotShared },
143   { 1, 6, 2, 3, 6, 6, 6, 0, BC7CompressionModeSIMD::ePBitType_Shared },
144   { 2, 6, 3, 2, 5, 5, 5, 0, BC7CompressionModeSIMD::ePBitType_None },
145   { 3, 6, 2, 2, 7, 7, 7, 0, BC7CompressionModeSIMD::ePBitType_NotShared },
146   { 0 },   { 0 },   { 6, 0, 1, 4, 7, 7, 7, 7, BC7CompressionModeSIMD::ePBitType_NotShared },
147   { 7, 6, 2, 2, 5, 5, 5, 5, BC7CompressionModeSIMD::ePBitType_NotShared },
148 };
149 void BC7CompressionModeSIMD::ClampEndpointsToGrid(RGBAVectorSIMD &amp;p1, RGBAVectorSIMD &amp;p2, int &amp;bestPBitCombo) const {
150   const int nPbitCombos = GetNumPbitCombos();
151   const bool hasPbits = nPbitCombos &gt; 1;
152   __m128i qmask;
153   GetQuantizationMask(qmask);
154   ClampEndpoints(p1, p2);
155   float minDist = FLT_MAX;
156   RGBAVectorSIMD bp1, bp2;
157   for(int i = 0; i &lt; nPbitCombos; i++) {
158     __m128i qp1, qp2;
159     if(hasPbits) {
160       qp1 = p1.ToPixel(qmask, GetPBitCombo(i)[0]);
161       qp2 = p2.ToPixel(qmask, GetPBitCombo(i)[1]);
162     }
163     else {
164       qp1 = p1.ToPixel(qmask);
165       qp2 = p2.ToPixel(qmask);
166     }
167     RGBAVectorSIMD np1 = RGBAVectorSIMD( _mm_cvtepi32_ps( qp1 ) );
168     RGBAVectorSIMD np2 = RGBAVectorSIMD( _mm_cvtepi32_ps( qp2 ) );
169     RGBAVectorSIMD d1 = np1 - p1;
170     RGBAVectorSIMD d2 = np2 - p2;
171     float dist = (d1 * d1) + (d2 * d2);
172     if(dist &lt; minDist) {
173       minDist = dist;
174       bp1 = np1; bp2 = np2;
175       bestPBitCombo = i;
176     }
177   }
178   p1 = bp1;
179   p2 = bp2;
180 }
181 int BC7CompressionModeSIMD::GetSubsetForIndex(int idx, const int shapeIdx) const {
182   int subset = 0;
183   const int nSubsets = GetNumberOfSubsets();
184   switch(nSubsets) {
185     case 2:
186     {
187       subset = !!((1 &lt;&lt; idx) &amp; kShapeMask2[shapeIdx]);
188     }
189     break;
190     case 3:
191     {
192       if(1 &lt;&lt; idx &amp; kShapeMask3[shapeIdx][0])
193         subset = 1 + !!((1 &lt;&lt; idx) &amp; kShapeMask3[shapeIdx][1]);
194       else
195         subset = 0;
196     }
197     break;
198     default:
199     break;
200   }
201   return subset;
202 }
203 int BC7CompressionModeSIMD::GetAnchorIndexForSubset(int subset, const int shapeIdx) const {
204   const int nSubsets = GetNumberOfSubsets();
205   int anchorIdx = 0;
206   switch(subset) {
207     case 1:
208     {
209       if(nSubsets == 2) {
210         anchorIdx = kAnchorIdx2[shapeIdx];
211       }
212       else {
213         anchorIdx = kAnchorIdx3[0][shapeIdx];
214       }
215     }
216     break;
217     case 2:
218     {
219       assert(nSubsets == 3);
220       anchorIdx = kAnchorIdx3[1][shapeIdx];
221     }
222     break;
223     default:
224     break;
225   }
226   return anchorIdx;
227 }
228 double BC7CompressionModeSIMD::CompressSingleColor(const RGBAVectorSIMD &amp;p, RGBAVectorSIMD &amp;p1, RGBAVectorSIMD &amp;p2, int &amp;bestPbitCombo) const {
229   const __m128i pixel = p.ToPixel(*((const __m128i *)kByteValMask));
230   uint32 bestDist = 0xFF;
231   bestPbitCombo = -1;
232   for(int pbi = 0; pbi &lt; GetNumPbitCombos(); pbi++) {
233     const int *pbitCombo = GetPBitCombo(pbi);
234     uint32 dist = 0x0;
235     uint32 bestValI[kNumColorChannels] = { -1, -1, -1, -1 };
236     uint32 bestValJ[kNumColorChannels] = { -1, -1, -1, -1 };
237     for(int ci = 0; ci &lt; kNumColorChannels; ci++) {
238 <a name="0"></a>
239       const uint8 val = ((uint8 *)(&amp;pixel))[4*ci];
240       int nBits = 0;
241 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>      switch(ci) {
242         case 0: nBits = GetRedChannelPrecision(); break;
243         case 1: nBits = GetGreenChannelPrecision(); break;
244         case 2: nBits = GetBlueChannelPrecision(); break;
245         case 3: nBits = GetAlphaChannelPrecision(); break;
246       }</b></font>
247       if(nBits == 0) { bestValI[ci] = bestValJ[ci] = 0xFF; continue; }
248       const int nPossVals = (1 &lt;&lt; nBits);
249       int possValsH[256];
250       int possValsL[256];
251       const bool havepbit = GetPBitType() != ePBitType_None;
252       if(havepbit)
253         nBits++;
254       for(int i = 0; i &lt; nPossVals; i++) {
255         int vh = i, vl = i;
256         if(havepbit) {
257           vh &lt;&lt;= 1;
258           vl &lt;&lt;= 1;
259           vh |= pbitCombo[1];
260           vl |= pbitCombo[0];
261         }
262         possValsH[i] = (vh &lt;&lt; (8 - nBits));
263         possValsH[i] |= (possValsH[i] &gt;&gt; nBits);
264         possValsL[i] = (vl &lt;&lt; (8 - nBits));
265         possValsL[i] |= (possValsL[i] &gt;&gt; nBits);
266       }
267       const uint32 interpVal0 = kBC7InterpolationValuesScalar[GetNumberOfBitsPerIndex() - 1][1][0];
268       const uint32 interpVal1 = kBC7InterpolationValuesScalar[GetNumberOfBitsPerIndex() - 1][1][1];
269       uint32 bestChannelDist = 0xFF;
270       for(int i = 0; bestChannelDist &gt; 0 &amp;&amp; i &lt; nPossVals; i++)
271       for(int j = 0; bestChannelDist &gt; 0 &amp;&amp; j &lt; nPossVals; j++) {
272         const uint32 v1 = possValsL[i];
273         const uint32 v2 = possValsH[j];
274         const uint32 combo = (interpVal0*v1 + (interpVal1 * v2) + 32) &gt;&gt; 6;
275         const uint32 err = (combo &gt; val)? combo - val : val - combo;
276         if(err &lt; bestChannelDist) {
277           bestChannelDist = err;
278           bestValI[ci] = v1;
279           bestValJ[ci] = v2;
280         }
281       }
282       dist = max(bestChannelDist, dist);
283     }
284     if(dist &lt; bestDist) {
285       bestDist = dist;
286       bestPbitCombo = pbi;
287       for(int ci = 0; ci &lt; kNumColorChannels; ci++) {
288         p1.c[ci] = float(bestValI[ci]);
289         p2.c[ci] = float(bestValJ[ci]);
290       }
291     }
292   }
293   return bestDist;
294 }
295 static const ALIGN_SSE uint32 kOneVec[4] = { 1, 1, 1, 1 };
296 static uint32 g_seed = uint32(time(NULL));
297 static inline uint32 fastrand() { 
298   g_seed = (214013 * g_seed + 2531011); 
299   return (g_seed&gt;&gt;16) &amp; RAND_MAX; 
300 } 
301 static __m128i cur_seed = _mm_set1_epi32( int(time(NULL)) );     
302 static inline __m128i rand_dir()
303 {
304   static const ALIGN_SSE uint32 mult[4] = { 214013, 17405, 214013, 0 }; 
305   static const ALIGN_SSE uint32 gadd[4] = { 2531011, 10395331, 13737667, 0 }; 
306   static const ALIGN_SSE uint32 masklo[4] = { RAND_MAX, RAND_MAX, RAND_MAX, RAND_MAX };
307   cur_seed = _mm_mullo_epi32( *((const __m128i *)mult), cur_seed );
308   cur_seed = _mm_add_epi32( *((const __m128i *)gadd), cur_seed );
309   const __m128i resShift = _mm_srai_epi32( cur_seed, 16 );
310   const __m128i result = _mm_and_si128( resShift, *((const __m128i *)kOneVec) );
311   return result;
312 } 
313 #define COMPILE_ASSERT(x) extern int __compile_assert_[(int)(x)];
314 COMPILE_ASSERT(RAND_MAX == 0x7FFF)
315 static inline float frand() { 
316   const uint16 r = fastrand();
317   const uint32 m = (r &lt;&lt; 8) | (r &gt;&gt; 7);
318   const uint32 flt = (127 &lt;&lt; 23) | m;
319   return *(reinterpret_cast&lt;const float *&gt;(&amp;flt)) - 1.0f;
320 }
321 static const ALIGN_SSE uint32 kSevenVec[4] = { 7, 7, 7, 7 };
322 static const ALIGN_SSE uint32 kNegOneVec[4] = { 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF };
323 static const ALIGN_SSE uint32 kFloatSignBit[4] = { 0x40000000, 0x40000000, 0x40000000, 0x40000000 };
324 static void ChangePointForDirWithoutPbitChange(RGBAVectorSIMD &amp;v, const __m128 &amp;stepVec) {
325   const __m128i dirBool = rand_dir();
326   const __m128i cmp = _mm_cmpeq_epi32( dirBool, *((const __m128i *)kZeroVector) );
327   const __m128 negStepVec = _mm_sub_ps( _mm_castsi128_ps( *((const __m128i *)kZeroVector) ), stepVec );
328   const __m128 step = _mm_blendv_ps( negStepVec, stepVec, _mm_castsi128_ps( cmp ) );
329   v.vec = _mm_add_ps( v.vec, step );
330 }
331 static void ChangePointForDirWithPbitChange(RGBAVectorSIMD &amp;v, int oldPbit, const __m128 &amp;stepVec) {
332   const __m128i pBitVec = _mm_set1_epi32( oldPbit );
333   const __m128i cmpPBit = _mm_cmpeq_epi32( pBitVec, *((const __m128i *)kZeroVector) );
334   const __m128i notCmpPBit = _mm_xor_si128( cmpPBit, *((const __m128i *)kNegOneVec) );
335   const __m128i dirBool = rand_dir();
336   const __m128i cmpDir = _mm_cmpeq_epi32( dirBool, *((const __m128i *)kOneVec) );
337   const __m128i notCmpDir = _mm_xor_si128( cmpDir, *((const __m128i *)kNegOneVec) );
338   const __m128i shouldDec = _mm_and_si128( cmpDir, cmpPBit );
339   const __m128i shouldInc = _mm_and_si128( notCmpDir, notCmpPBit );
340   const __m128 decStep = _mm_blendv_ps( _mm_castsi128_ps( *((const __m128i *)kZeroVector) ), stepVec, _mm_castsi128_ps( shouldDec ) );
341   v.vec = _mm_sub_ps( v.vec, decStep );
342   const __m128 incStep = _mm_blendv_ps( _mm_castsi128_ps( *((const __m128i *)kZeroVector) ), stepVec, _mm_castsi128_ps( shouldInc ) );
343   v.vec = _mm_add_ps( v.vec, incStep );
344 }
345 void BC7CompressionModeSIMD::PickBestNeighboringEndpoints(const RGBAClusterSIMD &amp;cluster, const RGBAVectorSIMD &amp;p1, const RGBAVectorSIMD &amp;p2, const int curPbitCombo, RGBAVectorSIMD &amp;np1, RGBAVectorSIMD &amp;np2, int &amp;nPbitCombo, const __m128 &amp;stepVec) const {
346   np1 = p1;
347   np2 = p2;
348   const EPBitType pBitType = GetPBitType();
349   if(pBitType != ePBitType_None) {
350     if(pBitType == ePBitType_Shared)
351       nPbitCombo = (curPbitCombo + 1) % 2;
352     else {
353       nPbitCombo = 3 - curPbitCombo;
354     }
355     assert(GetPBitCombo(curPbitCombo)[0] + GetPBitCombo(nPbitCombo)[0] == 1);
356     assert(GetPBitCombo(curPbitCombo)[1] + GetPBitCombo(nPbitCombo)[1] == 1);
357     const int *pBitCombo = GetPBitCombo(curPbitCombo);
358     ChangePointForDirWithPbitChange(np1, pBitCombo[0], stepVec);
359     ChangePointForDirWithPbitChange(np2, pBitCombo[1], stepVec);
360   }
361   else {
362     ChangePointForDirWithoutPbitChange(np1, stepVec);
363     ChangePointForDirWithoutPbitChange(np2, stepVec);
364   }
365   ClampEndpoints(np1, np2);
366 }
367 bool BC7CompressionModeSIMD::AcceptNewEndpointError(float newError, float oldError, float temp) const {
368   const float p = exp((0.15f * (oldError - newError)) / temp);
369   const float r = frand();
370   return r &lt; p;
371 }
372 double BC7CompressionModeSIMD::OptimizeEndpointsForCluster(const RGBAClusterSIMD &amp;cluster, RGBAVectorSIMD &amp;p1, RGBAVectorSIMD &amp;p2, __m128i *bestIndices, int &amp;bestPbitCombo) const {
373   const int nBuckets = (1 &lt;&lt; GetNumberOfBitsPerIndex());
374   const int nPbitCombos = GetNumPbitCombos();
375   __m128i qmask;
376   GetQuantizationMask(qmask);
377   float curError = cluster.QuantizedError(p1, p2, nBuckets, qmask, GetPBitCombo(bestPbitCombo), bestIndices);
378   int curPbitCombo = bestPbitCombo;
379   float bestError = curError;
380   RGBAVectorSIMD bp1 = p1, bp2 = p2;
381   assert(curError == cluster.QuantizedError(p1, p2, nBuckets, qmask, GetPBitCombo(bestPbitCombo)));
382   __m128i precVec = _mm_setr_epi32( GetRedChannelPrecision(), GetGreenChannelPrecision(), GetBlueChannelPrecision(), GetAlphaChannelPrecision() );
383   const __m128i precMask = _mm_xor_si128( _mm_cmpeq_epi32( precVec, *((const __m128i *)kZeroVector) ), *((const __m128i *)kNegOneVec) );
384   precVec = _mm_sub_epi32( *((const __m128i *)kSevenVec), precVec );
385   precVec = _mm_slli_epi32( precVec, 23 );
386   precVec = _mm_or_si128( precVec, *((const __m128i *)kFloatSignBit) );
387   __m128 stepVec = _mm_castsi128_ps( _mm_and_si128( precMask, precVec ) );
388   const int maxEnergy = MaxAnnealingIterations;
389   for(int energy = 0; bestError &gt; 0 &amp;&amp; energy &lt; maxEnergy; energy++) {
390     float temp = float(energy) / float(maxEnergy-1);
391     __m128i indices[kMaxNumDataPoints/4];
392     RGBAVectorSIMD np1, np2;
393     int nPbitCombo;
394     PickBestNeighboringEndpoints(cluster, p1, p2, curPbitCombo, np1, np2, nPbitCombo, stepVec);
395     float error = cluster.QuantizedError(np1, np2, nBuckets, qmask, GetPBitCombo(nPbitCombo), indices);
396     if(AcceptNewEndpointError(error, curError, temp)) {
397       curError = error;
398       p1 = np1;
399       p2 = np2;
400       curPbitCombo = nPbitCombo;
401     }
402     if(error &lt; bestError) {
403       memcpy(bestIndices, indices, sizeof(indices));
404       bp1 = np1;
405       bp2 = np2;
406       bestPbitCombo = nPbitCombo;
407       bestError = error;
408       energy = 0;
409     }
410   }
411   p1 = bp1;
412   p2 = bp2;
413   return bestError;
414 }
415 double BC7CompressionModeSIMD::CompressCluster(const RGBAClusterSIMD &amp;cluster, RGBAVectorSIMD &amp;p1, RGBAVectorSIMD &amp;p2, __m128i *bestIndices, int &amp;bestPbitCombo) const {
416   if(cluster.AllSamePoint()) {
417     const RGBAVectorSIMD &amp;p = cluster.GetPoint(0);
418     double bestErr = CompressSingleColor(p, p1, p2, bestPbitCombo);
419     for(int i = 0; i &lt; 4; i++) {
420       bestIndices[i] = _mm_set1_epi32(1);
421     }
422     return bestErr;
423   }
424   const int nBuckets = (1 &lt;&lt; GetNumberOfBitsPerIndex());
425   const int nPbitCombos = GetNumPbitCombos();
426   RGBAVectorSIMD avg = cluster.GetTotal() / float(cluster.GetNumPoints());
427   RGBADirSIMD axis;
428   ::GetPrincipalAxis(cluster, axis);
429   float mindp = FLT_MAX, maxdp = -FLT_MAX;
430   for(int i = 0 ; i &lt; cluster.GetNumPoints(); i++) {
431     float dp = (cluster.GetPoint(i) - avg) * axis;
432     if(dp &lt; mindp) mindp = dp;
433     if(dp &gt; maxdp) maxdp = dp;
434   }
435   RGBAVectorSIMD pts[1 &lt;&lt; 4];   float numPts[1&lt;&lt;4];
436   assert(nBuckets &lt;= 1 &lt;&lt; 4);
437   p1 = avg + mindp * axis;
438   p2 = avg + maxdp * axis;
439   ClampEndpoints(p1, p2);
440   for(int i = 0; i &lt; nBuckets; i++) {
441     float s = (float(i) / float(nBuckets - 1));
442     pts[i] = (1.0f - s) * p1 + s * p2;
443   }
444   assert(pts[0] == p1);
445   assert(pts[nBuckets - 1] == p2);
446   int bucketIdx[kMaxNumDataPoints];
447   bool fixed = false;
448   while(!fixed) {
449     RGBAVectorSIMD newPts[1 &lt;&lt; 4];
450     for(int i = 0; i &lt; cluster.GetNumPoints(); i++) {
451       int minBucket = -1;
452       float minDist = FLT_MAX;
453       for(int j = 0; j &lt; nBuckets; j++) {
454         RGBAVectorSIMD v = cluster.GetPoint(i) - pts[j];
455         float distSq = v * v;
456         if(distSq &lt; minDist)
457           {
458             minDist = distSq;
459             minBucket = j;
460           }
461       }
462       assert(minBucket &gt;= 0);
463       bucketIdx[i] = minBucket;
464     }
465     for(int i = 0; i &lt; nBuckets; i++) {
466       numPts[i] = 0.0f;
467       newPts[i] = RGBAVectorSIMD(0.0f);
468       for(int j = 0; j &lt; cluster.GetNumPoints(); j++) {
469         if(bucketIdx[j] == i) {
470           numPts[i] += 1.0f;
471           newPts[i] += cluster.GetPoint(j);
472         }
473       }
474       if(0.0f != numPts[i])
475         newPts[i] /= numPts[i];
476     }
477     fixed = true;
478     for(int i = 0; i &lt; nBuckets; i++) {
479       if(pts[i] != newPts[i])
480         fixed = false;
481     }
482     for(int i = 0; i &lt; nBuckets; i++) {
483       pts[i] = newPts[i];
484     }
485   }
486   int numBucketsFilled = 0, lastFilledBucket = -1;
487   for(int i = 0; i &lt; nBuckets; i++) {
488     if(numPts[i] &gt; 0.0f) {
489       numBucketsFilled++;
490       lastFilledBucket = i;
491     }
492   }
493   assert(numBucketsFilled &gt; 0);
494   if(1 == numBucketsFilled) {
495     const RGBAVectorSIMD &amp;p = pts[lastFilledBucket];
496     double bestErr = CompressSingleColor(p, p1, p2, bestPbitCombo);
497     for(int i = 0; i &lt; 4; i++) {
498       bestIndices[i] = _mm_set1_epi32(1);
499     }
500     return bestErr;
501   }
502   float asq = 0.0, bsq = 0.0, ab = 0.0;
503   RGBAVectorSIMD ax(0.0f), bx(0.0f);
504   for(int i = 0; i &lt; nBuckets; i++) {
505     float a = float(nBuckets - 1 - i) / float(nBuckets - 1);
506     float b = float(i) / float(nBuckets - 1);
507     float n = numPts[i];
508     RGBAVectorSIMD x = pts[i];
509     asq += n * a * a;
510     bsq += n * b * b;
511     ab += n * a * b;
512     ax += x * a * n;
513     bx += x * b * n;
514   }
515   float f = 1.0f / (asq * bsq - ab * ab);
516   p1 = f * (ax * bsq - bx * ab);
517   p2 = f * (bx * asq - ax * ab);
518   ClampEndpointsToGrid(p1, p2, bestPbitCombo);
519 #ifdef _DEBUG
520   int pBitCombo = bestPbitCombo;
521   RGBAVectorSIMD tp1 = p1, tp2 = p2;
522   ClampEndpointsToGrid(tp1, tp2, pBitCombo);
523   assert(p1 == tp1);
524   assert(p2 == tp2);
525   assert(pBitCombo == bestPbitCombo);
526 #endif
527   assert(bestPbitCombo &gt;= 0);
528   return OptimizeEndpointsForCluster(cluster, p1, p2, bestIndices, bestPbitCombo);
529 }
530 double BC7CompressionModeSIMD::Compress(BitStream &amp;stream, const int shapeIdx, const RGBAClusterSIMD *clusters) const { 
531   const int kModeNumber = GetModeNumber();
532   const int nPartitionBits = GetNumberOfPartitionBits();
533   const int nSubsets = GetNumberOfSubsets();
534   stream.WriteBits(1 &lt;&lt; kModeNumber, kModeNumber + 1);
535   assert((((1 &lt;&lt; nPartitionBits) - 1) &amp; shapeIdx) == shapeIdx);
536   stream.WriteBits(shapeIdx, nPartitionBits);
537   RGBAVectorSIMD p1[kMaxNumSubsets], p2[kMaxNumSubsets];
538   int bestIndices[kMaxNumSubsets][kMaxNumDataPoints] = {
539     { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
540     { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
541     { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }
542   };
543   int bestPbitCombo[kMaxNumSubsets] = { -1, -1, -1 };
544   double totalErr = 0.0;
545   for(int cidx = 0; cidx &lt; nSubsets; cidx++) {
546     ALIGN_SSE int indices[kMaxNumDataPoints];
547     totalErr += CompressCluster(clusters[cidx], p1[cidx], p2[cidx], (__m128i *)indices, bestPbitCombo[cidx]);
548     int idx = 0;
549     for(int i = 0; i &lt; 16; i++) {
550       int subs = GetSubsetForIndex(i, shapeIdx);
551       if(subs == cidx) {
552         bestIndices[cidx][i] = indices[idx++];
553       }
554     }
555   }
556 #ifdef _DEBUG
557   for(int i = 0; i &lt; kMaxNumDataPoints; i++) {
558     int nSet = 0;
559     for(int j = 0; j &lt; nSubsets; j++) {
560       if(bestIndices[j][i] &gt;= 0)
561         nSet++;
562     }
563     assert(nSet == 1);
564   }
565 #endif
566   __m128i qmask;
567   GetQuantizationMask(qmask);
568   __m128i pixel1[kMaxNumSubsets], pixel2[kMaxNumSubsets];
569   for(int i = 0; i &lt; nSubsets; i++) {
570     switch(GetPBitType()) {
571     default:
572     case ePBitType_None: 
573       pixel1[i] = p1[i].ToPixel(qmask); 
574       pixel2[i] = p2[i].ToPixel(qmask); 
575       break;
576     case ePBitType_Shared: 
577     case ePBitType_NotShared: 
578       pixel1[i] = p1[i].ToPixel(qmask, GetPBitCombo(bestPbitCombo[i])[0]); 
579       pixel2[i] = p2[i].ToPixel(qmask, GetPBitCombo(bestPbitCombo[i])[1]); 
580       break;
581     }
582   }
583   for(int sidx = 0; sidx &lt; nSubsets; sidx++) {
584     int anchorIdx = GetAnchorIndexForSubset(sidx, shapeIdx);
585     assert(bestIndices[sidx][anchorIdx] != -1);
586     int nIndexBits = GetNumberOfBitsPerIndex();
587     if(bestIndices[sidx][anchorIdx] &gt;&gt; (nIndexBits - 1)) {
588       __m128i t = pixel1[sidx]; pixel1[sidx] = pixel2[sidx]; pixel2[sidx] = t;
589       int nIndexVals = 1 &lt;&lt; nIndexBits;
590       for(int i = 0; i &lt; 16; i++) {
591         bestIndices[sidx][i] = (nIndexVals - 1) - bestIndices[sidx][i];
592       }
593     }
594     assert(!(bestIndices[sidx][anchorIdx] &gt;&gt; (nIndexBits - 1)));
595   }
596   uint8 r1[kMaxNumSubsets], g1[kMaxNumSubsets], b1[kMaxNumSubsets], a1[kMaxNumSubsets];
597   uint8 r2[kMaxNumSubsets], g2[kMaxNumSubsets], b2[kMaxNumSubsets], a2[kMaxNumSubsets];
598   for(int i = 0; i &lt; nSubsets; i++) {
599     r1[i] = ((uint8 *)(&amp;(pixel1[i])))[0];
600     r2[i] = ((uint8 *)(&amp;(pixel2[i])))[0];
601     g1[i] = ((uint8 *)(&amp;(pixel1[i])))[4];
602     g2[i] = ((uint8 *)(&amp;(pixel2[i])))[4];
603     b1[i] = ((uint8 *)(&amp;(pixel1[i])))[8];
604     b2[i] = ((uint8 *)(&amp;(pixel2[i])))[8];
605     a1[i] = ((uint8 *)(&amp;(pixel1[i])))[12];
606     a2[i] = ((uint8 *)(&amp;(pixel2[i])))[12];
607   }
608   const int nRedBits = GetRedChannelPrecision();
609   for(int i = 0; i &lt; nSubsets; i++) {
610     stream.WriteBits(r1[i] &gt;&gt; (8 - nRedBits), nRedBits);
611     stream.WriteBits(r2[i] &gt;&gt; (8 - nRedBits), nRedBits);
612   }
613   const int nGreenBits = GetGreenChannelPrecision();
614   for(int i = 0; i &lt; nSubsets; i++) {
615     stream.WriteBits(g1[i] &gt;&gt; (8 - nGreenBits), nGreenBits);
616     stream.WriteBits(g2[i] &gt;&gt; (8 - nGreenBits), nGreenBits);
617   }
618   const int nBlueBits = GetBlueChannelPrecision();
619   for(int i = 0; i &lt; nSubsets; i++) {
620     stream.WriteBits(b1[i] &gt;&gt; (8 - nBlueBits), nBlueBits);
621     stream.WriteBits(b2[i] &gt;&gt; (8 - nBlueBits), nBlueBits);
622   }
623   const int nAlphaBits = GetAlphaChannelPrecision();
624   for(int i = 0; i &lt; nSubsets; i++) {
625     stream.WriteBits(a1[i] &gt;&gt; (8 - nAlphaBits), nAlphaBits);
626     stream.WriteBits(a2[i] &gt;&gt; (8 - nAlphaBits), nAlphaBits);
627   }
628   if(GetPBitType() != ePBitType_None) {
629     for(int s = 0; s &lt; nSubsets; s++) {
630       const int *pbits = GetPBitCombo(bestPbitCombo[s]);
631       stream.WriteBits(pbits[0], 1);
632       if(GetPBitType() != ePBitType_Shared)
633         stream.WriteBits(pbits[1], 1);
634     }
635   }
636   for(int i = 0; i &lt; 16; i++) {
637     const int subs = GetSubsetForIndex(i, shapeIdx);
638     const int idx = bestIndices[subs][i];
639     const int anchorIdx = GetAnchorIndexForSubset(subs, shapeIdx);
640     const int nBitsForIdx = GetNumberOfBitsPerIndex();
641     assert(idx &gt;= 0 &amp;&amp; idx &lt; (1 &lt;&lt; nBitsForIdx));
642     assert(i != anchorIdx || !(idx &gt;&gt; (nBitsForIdx - 1)) || !"Leading bit of anchor index is not zero!");
643     stream.WriteBits(idx, (i == anchorIdx)? nBitsForIdx - 1 : nBitsForIdx);
644   }
645   assert(stream.GetBitsWritten() == 128);
646   return totalErr;
647 }
648 namespace BC7C
649 {
650   static void ExtractBlock(const uint8* inPtr, int width, uint32* colorBlock);
651   static void CompressBC7Block(const uint32 *block, uint8 *outBuf);
652   static bool AllOneColor(const uint32 block[16]) {
653     const uint32 pixel = block[0];
654     for(int i = 1; i &lt; 16; i++) {
655       if( block[i] != pixel )
656         return false;
657     }
658     return true;
659   }
660   static void WriteTransparentBlock(BitStream &amp;stream) {
661     stream.WriteBits(1 &lt;&lt; 6, 7);
662     stream.WriteBits(0, 128-7);
663     assert(stream.GetBitsWritten() == 128);
664   }
665   static void CompressOptimalColorBC7(uint32 pixel, BitStream &amp;stream) {
666     stream.WriteBits(1 &lt;&lt; 5, 6);     stream.WriteBits(0, 2); 
667     uint8 r = pixel &amp; 0xFF;
668     uint8 g = (pixel &gt;&gt; 8) &amp; 0xFF;
669     uint8 b = (pixel &gt;&gt; 16) &amp; 0xFF;
670     uint8 a = (pixel &gt;&gt; 24) &amp; 0xFF;
671     stream.WriteBits(Optimal7CompressBC7Mode5[r][0], 7);
672     stream.WriteBits(Optimal7CompressBC7Mode5[r][1], 7);
673     stream.WriteBits(Optimal7CompressBC7Mode5[g][0], 7);
674     stream.WriteBits(Optimal7CompressBC7Mode5[g][1], 7);
675     stream.WriteBits(Optimal7CompressBC7Mode5[b][0], 7);
676     stream.WriteBits(Optimal7CompressBC7Mode5[b][1], 7);
677     stream.WriteBits(a, 8);
678     stream.WriteBits(a, 8);
679     stream.WriteBits(0xaaaaaaab, 31);
680     stream.WriteBits(kWMValues[gWMVal = (gWMVal+1) % kNumWMVals], 31); 
681   }
682   void CompressImageBC7SIMD(const unsigned char *inBuf, unsigned char *outBuf, unsigned int width, unsigned int height)
683   {
684     ALIGN_SSE uint32 block[16];
685     _MM_SET_ROUNDING_MODE( _MM_ROUND_TOWARD_ZERO );
686     BC7CompressionModeSIMD::ResetNumUses();
687     BC7CompressionModeSIMD::MaxAnnealingIterations = GetQualityLevel();
688     for(int j = 0; j &lt; height; j += 4) {
689       for(int i = 0; i &lt; width; i += 4) {
690         CompressBC7Block((const uint32 *)inBuf, outBuf);
691         outBuf += 16;
692         inBuf += 64;
693       }
694     }
695   }
696   static void ExtractBlock(const uint8* inPtr, int width, uint32* colorBlock)
697   {
698     const int stride = width * 4;
699     _mm_store_si128((__m128i*)colorBlock, _mm_load_si128((__m128i*)inPtr));
700     inPtr += stride;
701     _mm_store_si128((__m128i*)(colorBlock + 4), _mm_load_si128((__m128i*)inPtr));
702     inPtr += stride;
703     _mm_store_si128((__m128i*)(colorBlock + 8), _mm_load_si128((__m128i*)inPtr));
704     inPtr += stride;
705     _mm_store_si128((__m128i*)(colorBlock + 12), _mm_load_si128((__m128i*)inPtr));
706   }
707   static double CompressTwoClusters(int shapeIdx, const RGBAClusterSIMD *clusters, uint8 *outBuf, double estimatedError) {
708     uint8 tempBuf1[16];
709     BitStream tmpStream1(tempBuf1, 128, 0);
710     BC7CompressionModeSIMD compressor1(1, estimatedError);
711     double bestError = compressor1.Compress(tmpStream1, shapeIdx, clusters);
712     memcpy(outBuf, tempBuf1, 16);
713     if(bestError == 0.0) {
714       return 0.0;
715     }
716     uint8 tempBuf3[16];
717     BitStream tmpStream3(tempBuf3, 128, 0);
718     BC7CompressionModeSIMD compressor3(3, estimatedError);
719     double error;
720     if((error = compressor3.Compress(tmpStream3, shapeIdx, clusters)) &lt; bestError) {
721       bestError = error;
722       memcpy(outBuf, tempBuf3, 16);
723       if(bestError == 0.0) {
724         return 0.0;
725       }
726     }
727     return bestError;
728   }
729   static double CompressThreeClusters(int shapeIdx, const RGBAClusterSIMD *clusters, uint8 *outBuf, double estimatedError) {
730     uint8 tempBuf0[16];
731     BitStream tmpStream0(tempBuf0, 128, 0);
732     uint8 tempBuf2[16];
733     BitStream tmpStream2(tempBuf2, 128, 0);
734     BC7CompressionModeSIMD compressor0(0, estimatedError);
735     BC7CompressionModeSIMD compressor2(2, estimatedError);
736     double error, bestError = (shapeIdx &lt; 16)? compressor0.Compress(tmpStream0, shapeIdx, clusters) : DBL_MAX;
737     memcpy(outBuf, tempBuf0, 16);
738     if(bestError == 0.0) {
739       return 0.0;
740     }
741     if((error = compressor2.Compress(tmpStream2, shapeIdx, clusters)) &lt; bestError) {
742       memcpy(outBuf, tempBuf2, 16);
743       return error;
744     }
745     return bestError;
746   }
747   static void PopulateTwoClustersForShape(const RGBAClusterSIMD &amp;points, int shapeIdx, RGBAClusterSIMD *clusters) {
748     const uint16 shape = kShapeMask2[shapeIdx]; 
749     for(int pt = 0; pt &lt; kMaxNumDataPoints; pt++) {
750       const RGBAVectorSIMD &amp;p = points.GetPoint(pt);
751       if((1 &lt;&lt; pt) &amp; shape)
752         clusters[1].AddPoint(p, pt);
753       else
754         clusters[0].AddPoint(p, pt);
755     }
756     assert(!(clusters[0].GetPointBitString() &amp; clusters[1].GetPointBitString()));
757     assert((clusters[0].GetPointBitString() ^ clusters[1].GetPointBitString()) == 0xFFFF);
758     assert((shape &amp; clusters[1].GetPointBitString()) == shape);
759   }
760   static void PopulateThreeClustersForShape(const RGBAClusterSIMD &amp;points, int shapeIdx, RGBAClusterSIMD *clusters) {
761     for(int pt = 0; pt &lt; kMaxNumDataPoints; pt++) {
762       const RGBAVectorSIMD &amp;p = points.GetPoint(pt);
763       if((1 &lt;&lt; pt) &amp; kShapeMask3[shapeIdx][0]) {
764         if((1 &lt;&lt; pt) &amp; kShapeMask3[shapeIdx][1])
765           clusters[2].AddPoint(p, pt);
766         else
767           clusters[1].AddPoint(p, pt);
768       }
769       else
770         clusters[0].AddPoint(p, pt);
771     }
772     assert(!(clusters[0].GetPointBitString() &amp; clusters[1].GetPointBitString()));
773     assert(!(clusters[2].GetPointBitString() &amp; clusters[1].GetPointBitString()));
774     assert(!(clusters[0].GetPointBitString() &amp; clusters[2].GetPointBitString()));
775   }
776   static double EstimateTwoClusterError(RGBAClusterSIMD &amp;c) {
777     RGBAVectorSIMD Min, Max, v;
778     c.GetBoundingBox(Min, Max);
779     v = Max - Min;
780     if(v * v == 0) {
781       return 0.0;
782     }
783     return 0.0001 + c.QuantizedError(Min, Max, 8, _mm_set1_epi32(0xFF));
784   }
785   static double EstimateThreeClusterError(RGBAClusterSIMD &amp;c) {
786     RGBAVectorSIMD Min, Max, v;
787     c.GetBoundingBox(Min, Max);
788     v = Max - Min;
789     if(v * v == 0) {
790       return 0.0;
791     }
792     return 0.0001 + c.QuantizedError(Min, Max, 4, _mm_set1_epi32(0xFF));
793   }
794   void CompressBC7Block(const uint32 *block, uint8 *outBuf) {
795     if(AllOneColor(block)) {
796       BitStream bStrm(outBuf, 128, 0);
797       CompressOptimalColorBC7(*((const uint32 *)block), bStrm);
798       return;
799     }       
800     RGBAClusterSIMD blockCluster;
801     bool opaque = true;
802     bool transparent = true;
803     for(int i = 0; i &lt; kMaxNumDataPoints; i++) {
804       RGBAVectorSIMD p = RGBAVectorSIMD(block[i]);
805       blockCluster.AddPoint(p, i);
806       if(fabs(p.a - 255.0f) &gt; 1e-10)
807         opaque = false;
808       if(p.a &gt; 0.0f)
809         transparent = false;
810     }
811     if(transparent) {
812       BitStream bStrm(outBuf, 128, 0);
813       WriteTransparentBlock(bStrm);
814       return;
815     }
816     double bestError[2] = { DBL_MAX, DBL_MAX };
817     int bestShapeIdx[2] = { -1, -1 };
818     RGBAClusterSIMD bestClusters[2][3];
819     for(int i = 0; i &lt; kNumShapes2; i++) {
820       RGBAClusterSIMD clusters[2];
821       PopulateTwoClustersForShape(blockCluster, i, clusters);
822       double err = 0.0;
823       for(int ci = 0; ci &lt; 2; ci++) {
824         err += EstimateTwoClusterError(clusters[ci]);
825       }
826       if(err &lt; 1e-9) {
827         CompressTwoClusters(i, clusters, outBuf, err);
828         return;
829       }
830       if(err &lt; bestError[0]) {
831         bestError[0] = err;
832         bestShapeIdx[0] = i;
833         bestClusters[0][0] = clusters[0];
834         bestClusters[0][1] = clusters[1];
835       }
836     }
837     if(opaque) {
838       for(int i = 0; i &lt; kNumShapes3; i++) {
839         RGBAClusterSIMD clusters[3];
840         PopulateThreeClustersForShape(blockCluster, i, clusters);
841         double err = 0.0;
842         for(int ci = 0; ci &lt; 3; ci++) {
843           err += EstimateThreeClusterError(clusters[ci]);
844         }
845         if(err &lt; 1e-9) {
846           CompressThreeClusters(i, clusters, outBuf, err);
847           return;
848         }
849         if(err &lt; bestError[1]) {
850           bestError[1] = err;
851           bestShapeIdx[1] = i;
852           bestClusters[1][0] = clusters[0];
853           bestClusters[1][1] = clusters[1];
854           bestClusters[1][2] = clusters[2];
855         }
856       }
857     }
858     if(opaque) {
859       uint8 tempBuf1[16];
860       uint8 tempBuf2[16];
861       BitStream tempStream1 (tempBuf1, 128, 0);
862       BC7CompressionModeSIMD compressor(6, DBL_MAX);
863       double best = compressor.Compress(tempStream1, 0, &amp;blockCluster);
864       if(best == 0.0f) {
865         memcpy(outBuf, tempBuf1, 16);
866         return;
867       }
868       double error = DBL_MAX;
869       if((error = CompressTwoClusters(bestShapeIdx[0], bestClusters[0], tempBuf2, bestError[0])) &lt; best) {
870         best = error;
871         if(error == 0.0f) {
872           memcpy(outBuf, tempBuf2, 16);
873           return;
874         }
875         else {
876           memcpy(tempBuf1, tempBuf2, 16);
877         }
878       }
879       if(CompressThreeClusters(bestShapeIdx[1], bestClusters[1], tempBuf2, bestError[1]) &lt; best) {
880         memcpy(outBuf, tempBuf2, 16);
881         return;
882       }
883       memcpy(outBuf, tempBuf1, 16);
884     }
885     else {
886       assert(!"Don't support alpha yet!");
887     }
888   }
889 }
</pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
