
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 10.647010647010648%, Tokens: 11, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-split.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "split.h"
5  #include "coutln.h"
6  #include "tprintf.h"
7  #include <algorithm>
8  namespace tesseract {
9  const int kCenterGradeCap = 25;
10  const double kBadPriority = 999.0;
11  BOOL_VAR(wordrec_display_splits, 0, "Display splits");
12  void SPLIT::Hide() const {
13    EDGEPT *edgept = point1;
14    do {
15      edgept->Hide();
16      edgept = edgept->next;
17    } while (!edgept->EqualPos(*point2) && edgept != point1);
18    edgept = point2;
19    do {
20      edgept->Hide();
21      edgept = edgept->next;
22    } while (!edgept->EqualPos(*point1) && edgept != point2);
23  }
24  void SPLIT::Reveal() const {
25    EDGEPT *edgept = point1;
26    do {
27      edgept->Reveal();
28      edgept = edgept->next;
29    } while (!edgept->EqualPos(*point2) && edgept != point1);
30    edgept = point2;
31    do {
32      edgept->Reveal();
33      edgept = edgept->next;
34    } while (!edgept->EqualPos(*point1) && edgept != point2);
35  }
36  float SPLIT::FullPriority(int xmin, int xmax, double overlap_knob, int centered_maxwidth,
37                            double center_knob, double width_change_knob) const {
38    TBOX box1 = Box12();
39    TBOX box2 = Box21();
40    int min_left = std::min(box1.left(), box2.left());
41    int max_right = std::max(box1.right(), box2.right());
42    if (xmin < min_left && xmax > max_right) {
43      return kBadPriority;
44    }
<span onclick='openModal()' class='match'>45    float grade = 0.0f;
46    int width1 = box1.width();
47    int width2 = box2.width();
48    int min_width = std::min(width1, width2);
49    int overlap = -box1.x_gap(box2);
50    if (overlap == min_width) {
</span>51      grade += 100.0f; 
52    } else {
53      if (2 * overlap > min_width) {
54        overlap += 2 * overlap - min_width;
55      }
56      if (overlap > 0) {
57        grade += overlap_knob * overlap;
58      }
59    }
60    if (width1 <= centered_maxwidth || width2 <= centered_maxwidth) {
61      grade += std::min(static_cast<double>(kCenterGradeCap), center_knob * abs(width1 - width2));
62    }
63    float width_change_grade = 20 - (max_right - min_left - std::max(width1, width2));
64    if (width_change_grade > 0.0f) {
65      grade += width_change_grade * width_change_knob;
66    }
67    return grade;
68  }
69  bool SPLIT::IsHealthy(const TBLOB &blob, int min_points, int min_area) const {
70    return !IsLittleChunk(min_points, min_area) &&
71           !blob.SegmentCrossesOutline(point1->pos, point2->pos);
72  }
73  bool SPLIT::IsLittleChunk(int min_points, int min_area) const {
74    if (point1->ShortNonCircularSegment(min_points, point2) &&
75        point1->SegmentArea(point2) < min_area) {
76      return true;
77    }
78    if (point2->ShortNonCircularSegment(min_points, point1) &&
79        point2->SegmentArea(point1) < min_area) {
80      return true;
81    }
82    return false;
83  }
84  EDGEPT *make_edgept(TDimension x, TDimension y, EDGEPT *next, EDGEPT *prev) {
85    EDGEPT *this_edgept;
86    this_edgept = new EDGEPT;
87    this_edgept->pos.x = x;
88    this_edgept->pos.y = y;
89    C_OUTLINE *prev_ol = prev->src_outline;
90    if (prev_ol != nullptr && prev->next == next) {
91      FCOORD segment_vec(next->pos.x - prev->pos.x, next->pos.y - prev->pos.y);
92      FCOORD target_vec(x - prev->pos.x, y - prev->pos.y);
93      double cut_fraction = target_vec.length() / segment_vec.length();
94      ICOORD step_start = prev_ol->position_at_index(prev->start_step);
95      int end_step = prev->start_step + prev->step_count;
96      int step_length = prev_ol->pathlength();
97      ICOORD step_end = prev_ol->position_at_index(end_step % step_length);
98      ICOORD step_vec = step_end - step_start;
99      double target_length = step_vec.length() * cut_fraction;
100      int best_step = prev->start_step;
101      ICOORD total_step(0, 0);
102      double best_dist = target_length;
103      for (int s = prev->start_step; s < end_step; ++s) {
104        total_step += prev_ol->step(s % step_length);
105        double dist = fabs(target_length - total_step.length());
106        if (dist < best_dist) {
107          best_dist = dist;
108          best_step = s + 1;
109        }
110      }
111      this_edgept->src_outline = prev_ol;
112      this_edgept->step_count = end_step - best_step;
113      this_edgept->start_step = best_step % step_length;
114      prev->step_count = best_step - prev->start_step;
115    } else {
116      this_edgept->src_outline = nullptr;
117      this_edgept->step_count = 0;
118      this_edgept->start_step = 0;
119    }
120    this_edgept->next = next;
121    this_edgept->prev = prev;
122    prev->next = this_edgept;
123    next->prev = this_edgept;
124    this_edgept->vec.x = this_edgept->next->pos.x - x;
125    this_edgept->vec.y = this_edgept->next->pos.y - y;
126    this_edgept->prev->vec.x = x - this_edgept->prev->pos.x;
127    this_edgept->prev->vec.y = y - this_edgept->prev->pos.y;
128    return this_edgept;
129  }
130  void remove_edgept(EDGEPT *point) {
131    EDGEPT *prev = point->prev;
132    EDGEPT *next = point->next;
133    if (prev->src_outline == point->src_outline && prev->src_outline != nullptr) {
134      prev->step_count += point->step_count;
135    }
136    prev->next = next;
137    next->prev = prev;
138    prev->vec.x = next->pos.x - prev->pos.x;
139    prev->vec.y = next->pos.y - prev->pos.y;
140    delete point;
141  }
142  void SPLIT::Print() const {
143    tprintf("(%d,%d)--(%d,%d)", point1->pos.x, point1->pos.y, point2->pos.x, point2->pos.y);
144  }
145  #ifndef GRAPHICS_DISABLED
146  void SPLIT::Mark(ScrollView *window) const {
147    window->Pen(ScrollView::GREEN);
148    window->Line(point1->pos.x, point1->pos.y, point2->pos.x, point2->pos.y);
149    window->UpdateWindow();
150  }
151  #endif
152  void SPLIT::SplitOutlineList(TESSLINE *outlines) const {
153    SplitOutline();
154    while (outlines->next != nullptr) {
155      outlines = outlines->next;
156    }
157    outlines->next = new TESSLINE;
158    outlines->next->loop = point1;
159    outlines->next->ComputeBoundingBox();
160    outlines = outlines->next;
161    outlines->next = new TESSLINE;
162    outlines->next->loop = point2;
163    outlines->next->ComputeBoundingBox();
164    outlines->next->next = nullptr;
165  }
166  void SPLIT::SplitOutline() const {
167    EDGEPT *temp2 = point2->next;
168    EDGEPT *temp1 = point1->next;
169    EDGEPT *new_point1 = make_edgept(point1->pos.x, point1->pos.y, temp1, point2);
170    EDGEPT *new_point2 = make_edgept(point2->pos.x, point2->pos.y, temp2, point1);
171    new_point1->src_outline = point1->src_outline;
172    new_point1->start_step = point1->start_step;
173    new_point1->step_count = point1->step_count;
174    new_point2->src_outline = point2->src_outline;
175    new_point2->start_step = point2->start_step;
176    new_point2->step_count = point2->step_count;
177    point1->src_outline = nullptr;
178    point1->start_step = 0;
179    point1->step_count = 0;
180    point2->src_outline = nullptr;
181    point2->start_step = 0;
182    point2->step_count = 0;
183  }
184  void SPLIT::UnsplitOutlineList(TBLOB *blob) const {
185    UnsplitOutlines();
186    auto *outline1 = new TESSLINE;
187    outline1->next = blob->outlines;
188    blob->outlines = outline1;
189    outline1->loop = point1;
190    auto *outline2 = new TESSLINE;
191    outline2->next = blob->outlines;
192    blob->outlines = outline2;
193    outline2->loop = point2;
194  }
195  void SPLIT::UnsplitOutlines() const {
196    EDGEPT *tmp1 = point1->next;
197    EDGEPT *tmp2 = point2->next;
198    tmp1->next->prev = point2;
199    tmp2->next->prev = point1;
200    point1->next = tmp2->next;
201    point1->src_outline = tmp2->src_outline;
202    point1->start_step = tmp2->start_step;
203    point1->step_count = tmp2->step_count;
204    point2->next = tmp1->next;
205    point2->src_outline = tmp1->src_outline;
206    point2->start_step = tmp1->start_step;
207    point2->step_count = tmp1->step_count;
208    delete tmp1;
209    delete tmp2;
210    point1->vec.x = point1->next->pos.x - point1->pos.x;
211    point1->vec.y = point1->next->pos.y - point1->pos.y;
212    point2->vec.x = point2->next->pos.x - point2->pos.x;
213    point2->vec.y = point2->next->pos.y - point2->pos.y;
214  }
215  } 
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-blobs.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "blobs.h"
5  #include "ccstruct.h"
6  #include "clst.h"
7  #include "linlsq.h"
8  #include "normalis.h"
9  #include "ocrblock.h"
10  #include "ocrrow.h"
11  #include "points.h"
12  #include "polyaprx.h"
13  #include "werd.h"
14  #include "helpers.h"
15  #include <algorithm>
16  namespace tesseract {
17  const TPOINT kDivisibleVerticalUpright(0, 1);
18  const TPOINT kDivisibleVerticalItalic(1, 5);
19  bool TPOINT::IsCrossed(const TPOINT &a0, const TPOINT &a1, const TPOINT &b0, const TPOINT &b1) {
20    TPOINT b0a1, b0a0, a1b1, b0b1, a1a0;
21    b0a1.x = a1.x - b0.x;
22    b0a0.x = a0.x - b0.x;
23    a1b1.x = b1.x - a1.x;
24    b0b1.x = b1.x - b0.x;
25    a1a0.x = a0.x - a1.x;
26    b0a1.y = a1.y - b0.y;
27    b0a0.y = a0.y - b0.y;
28    a1b1.y = b1.y - a1.y;
29    b0b1.y = b1.y - b0.y;
30    a1a0.y = a0.y - a1.y;
31    int b0a1xb0b1 = b0a1.cross(b0b1);
32    int b0b1xb0a0 = b0b1.cross(b0a0);
33    int a1b1xa1a0 = a1b1.cross(a1a0);
34    int a1a0xa1b0 = -a1a0.cross(b0a1);
35    return ((b0a1xb0b1 > 0 && b0b1xb0a0 > 0) || (b0a1xb0b1 < 0 && b0b1xb0a0 < 0)) &&
36           ((a1b1xa1a0 > 0 && a1a0xa1b0 > 0) || (a1b1xa1a0 < 0 && a1a0xa1b0 < 0));
37  }
38  TESSLINE *TESSLINE::BuildFromOutlineList(EDGEPT *outline) {
39    auto *result = new TESSLINE;
40    result->loop = outline;
41    if (outline->src_outline != nullptr) {
42      EDGEPT *pt = outline;
43      do {
44        pt->step_count = pt->next->start_step - pt->start_step;
45        if (pt->step_count < 0) {
46          pt->step_count += pt->src_outline->pathlength();
47        }
48        pt = pt->next;
49      } while (pt != outline);
50    }
51    result->SetupFromPos();
52    return result;
53  }
54  void TESSLINE::CopyFrom(const TESSLINE &src) {
55    Clear();
56    topleft = src.topleft;
57    botright = src.botright;
58    start = src.start;
59    is_hole = src.is_hole;
60    if (src.loop != nullptr) {
61      EDGEPT *prevpt = nullptr;
62      EDGEPT *newpt = nullptr;
63      EDGEPT *srcpt = src.loop;
64      do {
65        newpt = new EDGEPT(*srcpt);
66        if (prevpt == nullptr) {
67          loop = newpt;
68        } else {
69          newpt->prev = prevpt;
70          prevpt->next = newpt;
71        }
72        prevpt = newpt;
73        srcpt = srcpt->next;
74      } while (srcpt != src.loop);
75      loop->prev = newpt;
76      newpt->next = loop;
77    }
78  }
79  void TESSLINE::Clear() {
80    if (loop == nullptr) {
81      return;
82    }
83    EDGEPT *this_edge = loop;
84    do {
85      EDGEPT *next_edge = this_edge->next;
86      delete this_edge;
87      this_edge = next_edge;
88    } while (this_edge != loop);
89    loop = nullptr;
90  }
91  void TESSLINE::Normalize(const DENORM &denorm) {
92    EDGEPT *pt = loop;
93    do {
94      denorm.LocalNormTransform(pt->pos, &pt->pos);
95      pt = pt->next;
96    } while (pt != loop);
97    SetupFromPos();
98  }
99  void TESSLINE::Rotate(const FCOORD rot) {
100    EDGEPT *pt = loop;
101    do {
102      int tmp = static_cast<int>(floor(pt->pos.x * rot.x() - pt->pos.y * rot.y() + 0.5));
103      pt->pos.y = static_cast<int>(floor(pt->pos.y * rot.x() + pt->pos.x * rot.y() + 0.5));
104      pt->pos.x = tmp;
105      pt = pt->next;
106    } while (pt != loop);
107    SetupFromPos();
108  }
109  void TESSLINE::Move(const ICOORD vec) {
110    EDGEPT *pt = loop;
111    do {
112      pt->pos.x += vec.x();
113      pt->pos.y += vec.y();
114      pt = pt->next;
115    } while (pt != loop);
116    SetupFromPos();
117  }
118  void TESSLINE::Scale(float factor) {
119    EDGEPT *pt = loop;
120    do {
121      pt->pos.x = static_cast<int>(floor(pt->pos.x * factor + 0.5));
122      pt->pos.y = static_cast<int>(floor(pt->pos.y * factor + 0.5));
123      pt = pt->next;
124    } while (pt != loop);
125    SetupFromPos();
126  }
127  void TESSLINE::SetupFromPos() {
128    EDGEPT *pt = loop;
129    do {
130      pt->vec.x = pt->next->pos.x - pt->pos.x;
131      pt->vec.y = pt->next->pos.y - pt->pos.y;
132      pt = pt->next;
133    } while (pt != loop);
134    start = pt->pos;
135    ComputeBoundingBox();
136  }
137  void TESSLINE::ComputeBoundingBox() {
138    int minx = INT32_MAX;
139    int miny = INT32_MAX;
140    int maxx = -INT32_MAX;
141    int maxy = -INT32_MAX;
142    start = loop->pos;
143    EDGEPT *this_edge = loop;
144    do {
145      if (!this_edge->IsHidden() || !this_edge->prev->IsHidden()) {
146        if (this_edge->pos.x < minx) {
147          minx = this_edge->pos.x;
148        }
149        if (this_edge->pos.y < miny) {
150          miny = this_edge->pos.y;
151        }
152        if (this_edge->pos.x > maxx) {
153          maxx = this_edge->pos.x;
154        }
155        if (this_edge->pos.y > maxy) {
156          maxy = this_edge->pos.y;
157        }
158      }
159      this_edge = this_edge->next;
160    } while (this_edge != loop);
161    topleft.x = minx;
162    topleft.y = maxy;
163    botright.x = maxx;
164    botright.y = miny;
165  }
166  void TESSLINE::MinMaxCrossProduct(const TPOINT vec, int *min_xp, int *max_xp) const {
167    *min_xp = INT32_MAX;
168    *max_xp = INT32_MIN;
169    EDGEPT *this_edge = loop;
170    do {
171      if (!this_edge->IsHidden() || !this_edge->prev->IsHidden()) {
172        int product = this_edge->pos.cross(vec);
173        UpdateRange(product, min_xp, max_xp);
174      }
175      this_edge = this_edge->next;
176    } while (this_edge != loop);
177  }
178  TBOX TESSLINE::bounding_box() const {
179    return TBOX(topleft.x, botright.y, botright.x, topleft.y);
180  }
181  #ifndef GRAPHICS_DISABLED
182  void TESSLINE::plot(ScrollView *window, ScrollView::Color color, ScrollView::Color child_color) {
183    if (is_hole) {
184      window->Pen(child_color);
185    } else {
186      window->Pen(color);
187    }
188    window->SetCursor(start.x, start.y);
189    EDGEPT *pt = loop;
190    do {
191      bool prev_hidden = pt->IsHidden();
192      pt = pt->next;
193      if (prev_hidden) {
194        window->SetCursor(pt->pos.x, pt->pos.y);
195      } else {
196        window->DrawTo(pt->pos.x, pt->pos.y);
197      }
198    } while (pt != loop);
199  }
200  #endif 
201  EDGEPT *TESSLINE::FindBestStartPt() const {
202    EDGEPT *best_start = loop;
203    int best_step = loop->start_step;
204    EDGEPT *pt = loop;
205    do {
206      if (pt->IsHidden()) {
207        continue;
208      }
209      if (pt->prev->IsHidden() || pt->prev->src_outline != pt->src_outline) {
210        return pt; 
211      }
212      if (pt->start_step < best_step) {
213        best_step = pt->start_step;
214        best_start = pt;
215      }
216    } while ((pt = pt->next) != loop);
217    return best_start;
218  }
219  static TESSLINE **ApproximateOutlineList(bool allow_detailed_fx, C_OUTLINE_LIST *outlines,
220                                           bool children, TESSLINE **tail) {
221    C_OUTLINE_IT ol_it(outlines);
222    for (ol_it.mark_cycle_pt(); !ol_it.cycled_list(); ol_it.forward()) {
223      C_OUTLINE *outline = ol_it.data();
224      if (outline->pathlength() > 0) {
225        TESSLINE *tessline = ApproximateOutline(allow_detailed_fx, outline);
226        tessline->is_hole = children;
227        *tail = tessline;
228        tail = &tessline->next;
229      }
230      if (!outline->child()->empty()) {
231        tail = ApproximateOutlineList(allow_detailed_fx, outline->child(), true, tail);
232      }
233    }
234    return tail;
235  }
236  TBLOB *TBLOB::PolygonalCopy(bool allow_detailed_fx, C_BLOB *src) {
237    auto *tblob = new TBLOB;
238    ApproximateOutlineList(allow_detailed_fx, src->out_list(), false, &tblob->outlines);
239    return tblob;
240  }
241  TBLOB *TBLOB::ShallowCopy(const TBLOB &src) {
242    auto *blob = new TBLOB;
243    blob->denorm_ = src.denorm_;
244    return blob;
245  }
246  TBLOB *TBLOB::ClassifyNormalizeIfNeeded() const {
247    TBLOB *rotated_blob = nullptr;
248    if (denorm_.block() != nullptr && denorm_.block()->classify_rotation().y() != 0.0) {
249      TBOX box = bounding_box();
250      int x_middle = (box.left() + box.right()) / 2;
251      int y_middle = (box.top() + box.bottom()) / 2;
252      rotated_blob = new TBLOB(*this);
253      const FCOORD &rotation = denorm_.block()->classify_rotation();
254      float target_y =
255          kBlnBaselineOffset + (rotation.y() > 0 ? x_middle - box.left() : box.right() - x_middle);
256      rotated_blob->Normalize(nullptr, &rotation, &denorm_, x_middle, y_middle, 1.0f, 1.0f, 0.0f,
257                              target_y, denorm_.inverse(), denorm_.pix());
258    }
259    return rotated_blob;
260  }
261  void TBLOB::CopyFrom(const TBLOB &src) {
262    Clear();
263    TESSLINE *prev_outline = nullptr;
264    for (TESSLINE *srcline = src.outlines; srcline != nullptr; srcline = srcline->next) {
265      auto *new_outline = new TESSLINE(*srcline);
266      if (outlines == nullptr) {
267        outlines = new_outline;
268      } else {
269        prev_outline->next = new_outline;
270      }
271      prev_outline = new_outline;
272    }
273    denorm_ = src.denorm_;
274  }
275  void TBLOB::Clear() {
276    for (TESSLINE *next_outline = nullptr; outlines != nullptr; outlines = next_outline) {
277      next_outline = outlines->next;
278      delete outlines;
279    }
280  }
281  void TBLOB::Normalize(const BLOCK *block, const FCOORD *rotation, const DENORM *predecessor,
282                        float x_origin, float y_origin, float x_scale, float y_scale,
283                        float final_xshift, float final_yshift, bool inverse, Image pix) {
284    denorm_.SetupNormalization(block, rotation, predecessor, x_origin, y_origin, x_scale, y_scale,
285                               final_xshift, final_yshift);
286    denorm_.set_inverse(inverse);
287    denorm_.set_pix(pix);
288  #if 0
289    for (TESSLINE* outline = outlines; outline != nullptr; outline = outline->next) {
290      outline->Normalize(denorm_);
291    }
292  #else
293    denorm_.LocalNormBlob(this);
294  #endif
295  }
296  void TBLOB::Rotate(const FCOORD rotation) {
297    for (TESSLINE *outline = outlines; outline != nullptr; outline = outline->next) {
298      outline->Rotate(rotation);
299    }
300  }
301  void TBLOB::Move(const ICOORD vec) {
302    for (TESSLINE *outline = outlines; outline != nullptr; outline = outline->next) {
303      outline->Move(vec);
304    }
305  }
306  void TBLOB::Scale(float factor) {
307    for (TESSLINE *outline = outlines; outline != nullptr; outline = outline->next) {
308      outline->Scale(factor);
309    }
310  }
311  void TBLOB::ComputeBoundingBoxes() {
312    for (TESSLINE *outline = outlines; outline != nullptr; outline = outline->next) {
313      outline->ComputeBoundingBox();
314    }
315  }
316  int TBLOB::NumOutlines() const {
317    int result = 0;
318    for (TESSLINE *outline = outlines; outline != nullptr; outline = outline->next) {
319      ++result;
320    }
321    return result;
322  }
323  TBOX TBLOB::bounding_box() const {
324    if (outlines == nullptr) {
325      return TBOX(0, 0, 0, 0);
326    }
327    TESSLINE *outline = outlines;
328    TBOX box = outline->bounding_box();
329    for (outline = outline->next; outline != nullptr; outline = outline->next) {
330      box += outline->bounding_box();
331    }
332    return box;
333  }
334  void TBLOB::EliminateDuplicateOutlines() {
335    for (TESSLINE *outline = outlines; outline != nullptr; outline = outline->next) {
336      TESSLINE *last_outline = outline;
337      for (TESSLINE *other_outline = outline->next; other_outline != nullptr;
338           last_outline = other_outline, other_outline = other_outline->next) {
339        if (outline->SameBox(*other_outline)) {
340          last_outline->next = other_outline->next;
341          other_outline->loop = nullptr;
342          delete other_outline;
343          other_outline = last_outline;
344          outline->is_hole = false;
345        }
346      }
347    }
348  }
349  void TBLOB::CorrectBlobOrder(TBLOB *next) {
350    TBOX box = bounding_box();
351    TBOX next_box = next->bounding_box();
352    if (box.x_middle() > next_box.x_middle()) {
353      std::swap(outlines, next->outlines);
354    }
355  }
356  #ifndef GRAPHICS_DISABLED
357  void TBLOB::plot(ScrollView *window, ScrollView::Color color, ScrollView::Color child_color) {
358    for (TESSLINE *outline = outlines; outline != nullptr; outline = outline->next) {
359      outline->plot(window, color, child_color);
360    }
361  }
362  #endif 
363  int TBLOB::ComputeMoments(FCOORD *center, FCOORD *second_moments) const {
364    LLSQ accumulator;
365    TBOX box = bounding_box();
366    CollectEdges(box, nullptr, &accumulator, nullptr, nullptr);
367    *center = accumulator.mean_point() + box.botleft();
368    double x2nd = sqrt(accumulator.x_variance());
369    double y2nd = sqrt(accumulator.y_variance());
370    if (x2nd < 1.0) {
371      x2nd = 1.0;
372    }
373    if (y2nd < 1.0) {
374      y2nd = 1.0;
375    }
376    second_moments->set_x(x2nd);
377    second_moments->set_y(y2nd);
378    return accumulator.count();
379  }
380  void TBLOB::GetPreciseBoundingBox(TBOX *precise_box) const {
381    TBOX box = bounding_box();
382    *precise_box = TBOX();
383    CollectEdges(box, precise_box, nullptr, nullptr, nullptr);
384    precise_box->move(box.botleft());
385  }
386  void TBLOB::GetEdgeCoords(const TBOX &box, std::vector<std::vector<int>> &x_coords,
387                            std::vector<std::vector<int>> &y_coords) const {
388    x_coords.clear();
389    x_coords.resize(box.height());
390    y_coords.clear();
391    y_coords.resize(box.width());
392    CollectEdges(box, nullptr, nullptr, &x_coords, &y_coords);
393    for (auto &coord : x_coords) {
394      std::sort(coord.begin(), coord.end());
395    }
396    for (auto &coord : y_coords) {
397      std::sort(coord.begin(), coord.end());
398    }
399  }
400  static void SegmentLLSQ(const FCOORD &pt1, const FCOORD &pt2, LLSQ *accumulator) {
401    FCOORD step(pt2);
<span onclick='openModal()' class='match'>402    step -= pt1;
403    int xstart = IntCastRounded(std::min(pt1.x(), pt2.x()));
404    int xend = IntCastRounded(std::max(pt1.x(), pt2.x()));
405    int ystart = IntCastRounded(std::min(pt1.y(), pt2.y()));
406    int yend = IntCastRounded(std::max(pt1.y(), pt2.y()));
407    if (xstart == xend && ystart == yend) {
</span>408      return; 
409    }
410    double weight = step.length() / (xend - xstart + yend - ystart);
411    for (int x = xstart; x < xend; ++x) {
412      double y = pt1.y() + step.y() * (x + 0.5 - pt1.x()) / step.x();
413      accumulator->add(x + 0.5, y, weight);
414    }
415    for (int y = ystart; y < yend; ++y) {
416      double x = pt1.x() + step.x() * (y + 0.5 - pt1.y()) / step.y();
417      accumulator->add(x, y + 0.5, weight);
418    }
419  }
420  static void SegmentCoords(const FCOORD &pt1, const FCOORD &pt2, int x_limit, int y_limit,
421                            std::vector<std::vector<int>> *x_coords,
422                            std::vector<std::vector<int>> *y_coords) {
423    FCOORD step(pt2);
424    step -= pt1;
425    int start = ClipToRange(IntCastRounded(std::min(pt1.x(), pt2.x())), 0, x_limit);
426    int end = ClipToRange(IntCastRounded(std::max(pt1.x(), pt2.x())), 0, x_limit);
427    for (int x = start; x < end; ++x) {
428      int y = IntCastRounded(pt1.y() + step.y() * (x + 0.5 - pt1.x()) / step.x());
429      (*y_coords)[x].push_back(y);
430    }
431    start = ClipToRange(IntCastRounded(std::min(pt1.y(), pt2.y())), 0, y_limit);
432    end = ClipToRange(IntCastRounded(std::max(pt1.y(), pt2.y())), 0, y_limit);
433    for (int y = start; y < end; ++y) {
434      int x = IntCastRounded(pt1.x() + step.x() * (y + 0.5 - pt1.y()) / step.y());
435      (*x_coords)[y].push_back(x);
436    }
437  }
438  static void SegmentBBox(const FCOORD &pt1, const FCOORD &pt2, TBOX *bbox) {
439    FCOORD step(pt2);
440    step -= pt1;
441    int x1 = IntCastRounded(std::min(pt1.x(), pt2.x()));
442    int x2 = IntCastRounded(std::max(pt1.x(), pt2.x()));
443    if (x2 > x1) {
444      int y1 = IntCastRounded(pt1.y() + step.y() * (x1 + 0.5 - pt1.x()) / step.x());
445      int y2 = IntCastRounded(pt1.y() + step.y() * (x2 - 0.5 - pt1.x()) / step.x());
446      TBOX point(x1, std::min(y1, y2), x2, std::max(y1, y2));
447      *bbox += point;
448    }
449    int y1 = IntCastRounded(std::min(pt1.y(), pt2.y()));
450    int y2 = IntCastRounded(std::max(pt1.y(), pt2.y()));
451    if (y2 > y1) {
452      int x1 = IntCastRounded(pt1.x() + step.x() * (y1 + 0.5 - pt1.y()) / step.y());
453      int x2 = IntCastRounded(pt1.x() + step.x() * (y2 - 0.5 - pt1.y()) / step.y());
454      TBOX point(std::min(x1, x2), y1, std::max(x1, x2), y2);
455      *bbox += point;
456    }
457  }
458  static void CollectEdgesOfRun(const EDGEPT *startpt, const EDGEPT *lastpt, const DENORM &denorm,
459                                const TBOX &box, TBOX *bounding_box, LLSQ *accumulator,
460                                std::vector<std::vector<int>> *x_coords,
461                                std::vector<std::vector<int>> *y_coords) {
462    const C_OUTLINE *outline = startpt->src_outline;
463    int x_limit = box.width() - 1;
464    int y_limit = box.height() - 1;
465    if (outline != nullptr) {
466      const DENORM *root_denorm = denorm.RootDenorm();
467      int step_length = outline->pathlength();
468      int start_index = startpt->start_step;
469      int end_index = lastpt->start_step + lastpt->step_count;
470      if (end_index <= start_index) {
471        end_index += step_length;
472      }
473      ICOORD pos = outline->position_at_index(start_index);
474      FCOORD origin(box.left(), box.bottom());
475      FCOORD f_pos = outline->sub_pixel_pos_at_index(pos, start_index);
476      FCOORD prev_normed;
477      denorm.NormTransform(root_denorm, f_pos, &prev_normed);
478      prev_normed -= origin;
479      for (int index = start_index; index < end_index; ++index) {
480        ICOORD step = outline->step(index % step_length);
481        if (outline->edge_strength_at_index(index % step_length) > 0) {
482          FCOORD f_pos = outline->sub_pixel_pos_at_index(pos, index % step_length);
483          FCOORD pos_normed;
484          denorm.NormTransform(root_denorm, f_pos, &pos_normed);
485          pos_normed -= origin;
486          if (bounding_box != nullptr) {
487            SegmentBBox(pos_normed, prev_normed, bounding_box);
488          }
489          if (accumulator != nullptr) {
490            SegmentLLSQ(pos_normed, prev_normed, accumulator);
491          }
492          if (x_coords != nullptr && y_coords != nullptr) {
493            SegmentCoords(pos_normed, prev_normed, x_limit, y_limit, x_coords, y_coords);
494          }
495          prev_normed = pos_normed;
496        }
497        pos += step;
498      }
499    } else {
500      const EDGEPT *endpt = lastpt->next;
501      const EDGEPT *pt = startpt;
502      do {
503        FCOORD next_pos(pt->next->pos.x - box.left(), pt->next->pos.y - box.bottom());
504        FCOORD pos(pt->pos.x - box.left(), pt->pos.y - box.bottom());
505        if (bounding_box != nullptr) {
506          SegmentBBox(next_pos, pos, bounding_box);
507        }
508        if (accumulator != nullptr) {
509          SegmentLLSQ(next_pos, pos, accumulator);
510        }
511        if (x_coords != nullptr && y_coords != nullptr) {
512          SegmentCoords(next_pos, pos, x_limit, y_limit, x_coords, y_coords);
513        }
514      } while ((pt = pt->next) != endpt);
515    }
516  }
517  void TBLOB::CollectEdges(const TBOX &box, TBOX *bounding_box, LLSQ *llsq,
518                           std::vector<std::vector<int>> *x_coords,
519                           std::vector<std::vector<int>> *y_coords) const {
520    for (const TESSLINE *ol = outlines; ol != nullptr; ol = ol->next) {
521      EDGEPT *loop_pt = ol->FindBestStartPt();
522      EDGEPT *pt = loop_pt;
523      if (pt == nullptr) {
524        continue;
525      }
526      do {
527        if (pt->IsHidden()) {
528          continue;
529        }
530        EDGEPT *last_pt = pt;
531        do {
532          last_pt = last_pt->next;
533        } while (last_pt != loop_pt && !last_pt->IsHidden() &&
534                 last_pt->src_outline == pt->src_outline);
535        last_pt = last_pt->prev;
536        CollectEdgesOfRun(pt, last_pt, denorm_, box, bounding_box, llsq, x_coords, y_coords);
537        pt = last_pt;
538      } while ((pt = pt->next) != loop_pt);
539    }
540  }
541  TWERD *TWERD::PolygonalCopy(bool allow_detailed_fx, WERD *src) {
542    auto *tessword = new TWERD;
543    tessword->latin_script = src->flag(W_SCRIPT_IS_LATIN);
544    C_BLOB_IT b_it(src->cblob_list());
545    for (b_it.mark_cycle_pt(); !b_it.cycled_list(); b_it.forward()) {
546      C_BLOB *blob = b_it.data();
547      TBLOB *tblob = TBLOB::PolygonalCopy(allow_detailed_fx, blob);
548      tessword->blobs.push_back(tblob);
549    }
550    return tessword;
551  }
552  void TWERD::BLNormalize(const BLOCK *block, const ROW *row, Image pix, bool inverse, float x_height,
553                          float baseline_shift, bool numeric_mode, tesseract::OcrEngineMode hint,
554                          const TBOX *norm_box, DENORM *word_denorm) {
555    TBOX word_box = bounding_box();
556    if (norm_box != nullptr) {
557      word_box = *norm_box;
558    }
559    float word_middle = (word_box.left() + word_box.right()) / 2.0f;
560    float input_y_offset = 0.0f;
561    auto final_y_offset = static_cast<float>(kBlnBaselineOffset);
562    float scale = kBlnXHeight / x_height;
563    if (row == nullptr) {
564      word_middle = word_box.left();
565      input_y_offset = word_box.bottom();
566      final_y_offset = 0.0f;
567    } else {
568      input_y_offset = row->base_line(word_middle) + baseline_shift;
569    }
570    for (auto blob : blobs) {
571      TBOX blob_box = blob->bounding_box();
572      float mid_x = (blob_box.left() + blob_box.right()) / 2.0f;
573      float baseline = input_y_offset;
574      float blob_scale = scale;
575      if (numeric_mode) {
576        baseline = blob_box.bottom();
577        blob_scale = ClipToRange(kBlnXHeight * 4.0f / (3 * blob_box.height()), scale, scale * 1.5f);
578      } else if (row != nullptr) {
579        baseline = row->base_line(mid_x) + baseline_shift;
580      }
581      blob->Normalize(block, nullptr, nullptr, word_middle, baseline, blob_scale, blob_scale, 0.0f,
582                      final_y_offset, inverse, pix);
583    }
584    if (word_denorm != nullptr) {
585      word_denorm->SetupNormalization(block, nullptr, nullptr, word_middle, input_y_offset, scale,
586                                      scale, 0.0f, final_y_offset);
587      word_denorm->set_inverse(inverse);
588      word_denorm->set_pix(pix);
589    }
590  }
591  void TWERD::CopyFrom(const TWERD &src) {
592    Clear();
593    latin_script = src.latin_script;
594    for (auto blob : src.blobs) {
595      auto *new_blob = new TBLOB(*blob);
596      blobs.push_back(new_blob);
597    }
598  }
599  void TWERD::Clear() {
600    for (auto blob : blobs) {
601      delete blob;
602    }
603    blobs.clear();
604  }
605  void TWERD::ComputeBoundingBoxes() {
606    for (auto &blob : blobs) {
607      blob->ComputeBoundingBoxes();
608    }
609  }
610  TBOX TWERD::bounding_box() const {
611    TBOX result;
612    for (auto blob : blobs) {
613      TBOX box = blob->bounding_box();
614      result += box;
615    }
616    return result;
617  }
618  void TWERD::MergeBlobs(unsigned start, unsigned end) {
619    if (end > blobs.size()) {
620      end = blobs.size();
621    }
622    if (start >= end) {
623      return; 
624    }
625    TESSLINE *outline = blobs[start]->outlines;
626    for (auto i = start + 1; i < end; ++i) {
627      TBLOB *next_blob = blobs[i];
628      if (outline == nullptr) {
629        blobs[start]->outlines = next_blob->outlines;
630        outline = blobs[start]->outlines;
631      } else {
632        while (outline->next != nullptr) {
633          outline = outline->next;
634        }
635        outline->next = next_blob->outlines;
636        next_blob->outlines = nullptr;
637      }
638      delete next_blob;
639      blobs[i] = nullptr;
640    }
641    for (auto i = start + 1; i < end && start + 1 < blobs.size(); ++i) {
642      blobs.erase(blobs.begin() + start + 1);
643    }
644  }
645  #ifndef GRAPHICS_DISABLED
646  void TWERD::plot(ScrollView *window) {
647    ScrollView::Color color = WERD::NextColor(ScrollView::BLACK);
648    for (auto &blob : blobs) {
649      blob->plot(window, color, ScrollView::BROWN);
650      color = WERD::NextColor(color);
651    }
652  }
653  #endif 
654  bool divisible_blob(TBLOB *blob, bool italic_blob, TPOINT *location) {
655    if (blob->outlines == nullptr || blob->outlines->next == nullptr) {
656      return false; 
657    }
658    int max_gap = 0;
659    TPOINT vertical = italic_blob ? kDivisibleVerticalItalic : kDivisibleVerticalUpright;
660    for (TESSLINE *outline1 = blob->outlines; outline1 != nullptr; outline1 = outline1->next) {
661      if (outline1->is_hole) {
662        continue; 
663      }
664      TPOINT mid_pt1((outline1->topleft.x + outline1->botright.x) / 2,
665                     (outline1->topleft.y + outline1->botright.y) / 2);
666      int mid_prod1 = mid_pt1.cross(vertical);
667      int min_prod1, max_prod1;
668      outline1->MinMaxCrossProduct(vertical, &min_prod1, &max_prod1);
669      for (TESSLINE *outline2 = outline1->next; outline2 != nullptr; outline2 = outline2->next) {
670        if (outline2->is_hole) {
671          continue; 
672        }
673        TPOINT mid_pt2((outline2->topleft.x + outline2->botright.x) / 2,
674                       (outline2->topleft.y + outline2->botright.y) / 2);
675        int mid_prod2 = mid_pt2.cross(vertical);
676        int min_prod2, max_prod2;
677        outline2->MinMaxCrossProduct(vertical, &min_prod2, &max_prod2);
678        int mid_gap = abs(mid_prod2 - mid_prod1);
679        int overlap = std::min(max_prod1, max_prod2) - std::max(min_prod1, min_prod2);
680        if (mid_gap - overlap / 4 > max_gap) {
681          max_gap = mid_gap - overlap / 4;
682          *location = mid_pt1;
683          *location += mid_pt2;
684          *location /= 2;
685        }
686      }
687    }
688    return max_gap > vertical.y;
689  }
690  void divide_blobs(TBLOB *blob, TBLOB *other_blob, bool italic_blob, const TPOINT &location) {
691    TPOINT vertical = italic_blob ? kDivisibleVerticalItalic : kDivisibleVerticalUpright;
692    TESSLINE *outline1 = nullptr;
693    TESSLINE *outline2 = nullptr;
694    TESSLINE *outline = blob->outlines;
695    blob->outlines = nullptr;
696    int location_prod = location.cross(vertical);
697    while (outline != nullptr) {
698      TPOINT mid_pt((outline->topleft.x + outline->botright.x) / 2,
699                    (outline->topleft.y + outline->botright.y) / 2);
700      int mid_prod = mid_pt.cross(vertical);
701      if (mid_prod < location_prod) {
702        if (outline1) {
703          outline1->next = outline;
704        } else {
705          blob->outlines = outline;
706        }
707        outline1 = outline;
708      } else {
709        if (outline2) {
710          outline2->next = outline;
711        } else {
712          other_blob->outlines = outline;
713        }
714        outline2 = outline;
715      }
716      outline = outline->next;
717    }
718    if (outline1) {
719      outline1->next = nullptr;
720    }
721    if (outline2) {
722      outline2->next = nullptr;
723    }
724  }
725  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-split.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-blobs.cpp</div>
                </div>
                <div class="column column_space"><pre><code>45    float grade = 0.0f;
46    int width1 = box1.width();
47    int width2 = box2.width();
48    int min_width = std::min(width1, width2);
49    int overlap = -box1.x_gap(box2);
50    if (overlap == min_width) {
</pre></code></div>
                <div class="column column_space"><pre><code>402    step -= pt1;
403    int xstart = IntCastRounded(std::min(pt1.x(), pt2.x()));
404    int xend = IntCastRounded(std::max(pt1.x(), pt2.x()));
405    int ystart = IntCastRounded(std::min(pt1.y(), pt2.y()));
406    int yend = IntCastRounded(std::max(pt1.y(), pt2.y()));
407    if (xstart == xend && ystart == yend) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    