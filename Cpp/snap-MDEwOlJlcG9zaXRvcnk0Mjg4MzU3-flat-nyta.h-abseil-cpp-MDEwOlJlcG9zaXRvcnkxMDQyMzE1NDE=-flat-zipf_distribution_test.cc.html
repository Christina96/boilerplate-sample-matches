
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.6706231454005933%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-nyta.h</h3>
            <pre><code>1  #ifndef nyta_h
2  #define nyta_h
3  #include "base.h"
4  ClassTPV(TNytaDoc, PNytaDoc, TNytaDocV)
5  public:
6    TStr UrlStr;
7    TStr TitleXmlStr;
8    TStr SummaryXmlStr;
9    TStr DateStr;
10    TIntV TopicIdV;
11  public:
12    TNytaDoc():
13      UrlStr(), TitleXmlStr(), SummaryXmlStr(), DateStr(), TopicIdV(){}
14    TNytaDoc(const TNytaDoc& NytaDoc):
15      UrlStr(NytaDoc.UrlStr),
16      TitleXmlStr(NytaDoc.TitleXmlStr), SummaryXmlStr(NytaDoc.SummaryXmlStr),
17      DateStr(NytaDoc.DateStr), TopicIdV(NytaDoc.TopicIdV){}
18    TNytaDoc(const TStr& _UrlStr,
19     const TStr& _TitleXmlStr, const TStr& _SummaryXmlStr,
20     const TStr& _DateStr, const TIntV& _TopicIdV=TIntV()):
21      UrlStr(_UrlStr),
22      TitleXmlStr(_TitleXmlStr), SummaryXmlStr(_SummaryXmlStr),
23      DateStr(_DateStr), TopicIdV(_TopicIdV){}
24    static PNytaDoc New(){
25      return new TNytaDoc();}
26    static PNytaDoc New(const TStr& UrlStr,
27     const TStr& TitleXmlStr, const TStr& SummaryXmlStr,
28     const TStr& DateStr, const TIntV& TopicIdV=TIntV()){
29      return new TNytaDoc(UrlStr, TitleXmlStr, SummaryXmlStr, DateStr, TopicIdV);}
30    ~TNytaDoc(){}
31    TNytaDoc(TSIn& SIn):
32      UrlStr(SIn), TitleXmlStr(SIn), SummaryXmlStr(SIn), DateStr(SIn), TopicIdV(SIn){}
33    static PNytaDoc Load(TSIn& SIn){return new TNytaDoc(SIn);}
34    void Save(TSOut& SOut){
35      UrlStr.Save(SOut);
36      TitleXmlStr.Save(SOut); SummaryXmlStr.Save(SOut);
37      DateStr.Save(SOut); TopicIdV.Save(SOut);}
38    bool operator==(const TNytaDoc& NytaDoc) const {
39      return (DateStr==NytaDoc.DateStr)&&(UrlStr==NytaDoc.UrlStr);}
40    bool operator<(const TNytaDoc& NytaDoc) const {
41      return (DateStr<NytaDoc.DateStr)||
42       ((DateStr==NytaDoc.DateStr)&&(UrlStr<NytaDoc.UrlStr));}
43    TStr GetYMDDateStr() const {
44      return DateStr.GetSubStr(0, 3)+"-"+DateStr.GetSubStr(4, 5)+"-"+
45       DateStr.GetSubStr(6, 7);}
<span onclick='openModal()' class='match'>46    void AddTopicId(const int& TopicId){TopicIdV.AddUnique(TopicId);}
47    int GetTopicIds() const {return TopicIdV.Len();}
48    int GetTopicId(const int& TopicIdN) const {return TopicIdV[TopicIdN];}
</span>49  };
50  class TNytTopic{
51  public:
52    TStrV TopicTagNmV;
53    TIntV DocIdV;
54  public:
55    TNytTopic(): TopicTagNmV(), DocIdV(){}
56    TNytTopic(const TNytTopic& NytTopic):
57      TopicTagNmV(NytTopic.TopicTagNmV), DocIdV(NytTopic.DocIdV){}
58    ~TNytTopic(){}
59    TNytTopic(TSIn& SIn): TopicTagNmV(SIn), DocIdV(SIn){}
60    void Save(TSOut& SOut){TopicTagNmV.Save(SOut); DocIdV.Save(SOut);}
61    TNytTopic& operator=(const TNytTopic& NytTopic){
62      if (this!=&NytTopic){
63        TopicTagNmV=NytTopic.TopicTagNmV; DocIdV=NytTopic.DocIdV;}
64      return *this;}
65    void AddTopicTag(const TStr& TopicTagNm){
66      TopicTagNmV.AddUnique(TopicTagNm);}
67    int GetTopicTags() const {return TopicTagNmV.Len();}
68    TStr GetTopicTagNm(const int& TopicTagN) const {
69      return TopicTagNmV[TopicTagN];}
70  };
71  ClassTPV(TNytaBs, PNytaBs, TNytaBsV)
72  private:
73    TNytaDocV NytaDocV;
74    THash<TStrV, TNytTopic> TokStrVToTopicH;
75    TStrIntVH TopicNmFirstTokStrToToksVH;
76    UndefAssign(TNytaBs);
77  public:
78    TNytaBs(): NytaDocV(){}
79    TNytaBs(const TNytaBs& NytaBs): NytaDocV(NytaBs.NytaDocV){}
80    static PNytaBs New(){return new TNytaBs();}
81    ~TNytaBs(){}
82    TNytaBs(TSIn& SIn): NytaDocV(SIn){}
83    static PNytaBs Load(TSIn& SIn){return new TNytaBs(SIn);}
84    void Save(TSOut& SOut){NytaDocV.Save(SOut);}
85    int GetDocs() const {return NytaDocV.Len();}
86    void AddDoc(const PNytaDoc& NytaDoc){NytaDocV.Add(NytaDoc);}
87    PNytaDoc GetDoc(const int& DocN) const {return NytaDocV[DocN];}
88    void SortDocs(){NytaDocV.Sort();}
89    void LoadNytTopics(const TStr& FPath);
90    void LoadGeoNames(const TStr& FPath);
91    void SaveNytTopicsTxt(const TStr& FNm);
92    void AnnotateWithNytTopics();
93    int AddTopicNm(const TStrV& TopicNmTokStrV,
94     const TStr& TopicTagNm1=TStr(), const TStr& TopicTagNm2=TStr(),
95     const TStr& TopicTagNm3=TStr());
96    int GetTopicNms() const {return TokStrVToTopicH.Len();}
97    TStr GetTopicNm(const int& TopicId) const;
98    bool IsTopic(const TStrV& TopicNmTokStrV, int& TopicId) const {
99      return TokStrVToTopicH.IsKey(TopicNmTokStrV, TopicId);}
100    int GetTopicId(const TStrV& TopicNmTokStrV) const {
101      return TokStrVToTopicH.GetKeyId(TopicNmTokStrV);}
102    void AddTopicDocId(const int& TopicId, const int& DocId){
103      TokStrVToTopicH[TopicId].DocIdV.AddUnique(DocId);}
104    int GetTopicDocIds(const int& TopicId) const {
105      return TokStrVToTopicH[TopicId].DocIdV.Len();}
106    int GetTopicDocId(const int& TopicId, const int& DocIdN) const {
107      return TokStrVToTopicH[TopicId].DocIdV[DocIdN];}
108    int GetTopicTags(const int& TopicId) const {
109      return TokStrVToTopicH[TopicId].TopicTagNmV.Len();}
110    TStr GetTopicTagNm(const int& TopicId, const int& TopicTagN) const {
111      return TokStrVToTopicH[TopicId].TopicTagNmV[TopicTagN];}
112    static PNytaBs LoadBin(const TStr& FNm){
113      TFIn SIn(FNm); return Load(SIn);}
114    void SaveBin(const TStr& FNm){
115      TFOut SOut(FNm); Save(SOut);}
116    void SaveTxt(const TStr& FNm);
117    void SaveR2KXml(const TStr& FNm);
118  };
119  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-zipf_distribution_test.cc</h3>
            <pre><code>1  #include "absl/random/zipf_distribution.h"
2  #include <algorithm>
3  #include <cstddef>
4  #include <cstdint>
5  #include <iterator>
6  #include <random>
7  #include <string>
8  #include <utility>
9  #include <vector>
10  #include "gmock/gmock.h"
11  #include "gtest/gtest.h"
12  #include "absl/log/log.h"
13  #include "absl/random/internal/chi_square.h"
14  #include "absl/random/internal/pcg_engine.h"
15  #include "absl/random/internal/sequence_urbg.h"
16  #include "absl/random/random.h"
17  #include "absl/strings/str_cat.h"
18  #include "absl/strings/str_replace.h"
19  #include "absl/strings/strip.h"
20  namespace {
21  using ::absl::random_internal::kChiSquared;
22  using ::testing::ElementsAre;
23  template <typename IntType>
24  class ZipfDistributionTypedTest : public ::testing::Test {};
25  using IntTypes = ::testing::Types<int, int8_t, int16_t, int32_t, int64_t,
26                                    uint8_t, uint16_t, uint32_t, uint64_t>;
27  TYPED_TEST_SUITE(ZipfDistributionTypedTest, IntTypes);
28  TYPED_TEST(ZipfDistributionTypedTest, SerializeTest) {
29    using param_type = typename absl::zipf_distribution<TypeParam>::param_type;
30    constexpr int kCount = 1000;
31    absl::InsecureBitGen gen;
32    for (const auto& param : {
33             param_type(),
34             param_type(32),
35             param_type(100, 3, 2),
36             param_type(std::numeric_limits<TypeParam>::max(), 4, 3),
37             param_type(std::numeric_limits<TypeParam>::max() / 2),
38         }) {
39      const auto k = param.k();
40      const auto q = param.q();
41      const auto v = param.v();
42      absl::zipf_distribution<TypeParam> before(k, q, v);
43      EXPECT_EQ(before.k(), param.k());
44      EXPECT_EQ(before.q(), param.q());
45      EXPECT_EQ(before.v(), param.v());
46      {
47        absl::zipf_distribution<TypeParam> via_param(param);
48        EXPECT_EQ(via_param, before);
49      }
50      std::stringstream ss;
51      ss << before;
52      absl::zipf_distribution<TypeParam> after(4, 5.5, 4.4);
53      EXPECT_NE(before.k(), after.k());
54      EXPECT_NE(before.q(), after.q());
55      EXPECT_NE(before.v(), after.v());
56      EXPECT_NE(before.param(), after.param());
57      EXPECT_NE(before, after);
58      ss >> after;
59      EXPECT_EQ(before.k(), after.k());
60      EXPECT_EQ(before.q(), after.q());
61      EXPECT_EQ(before.v(), after.v());
62      EXPECT_EQ(before.param(), after.param());
63      EXPECT_EQ(before, after);
64      auto sample_min = after.max();
65      auto sample_max = after.min();
66      for (int i = 0; i < kCount; i++) {
67        auto sample = after(gen);
68        EXPECT_GE(sample, after.min());
69        EXPECT_LE(sample, after.max());
70        if (sample > sample_max) sample_max = sample;
71        if (sample < sample_min) sample_min = sample;
72      }
73      LOG(INFO) << "Range: " << sample_min << ", " << sample_max;
74    }
75  }
76  class ZipfModel {
77   public:
<span onclick='openModal()' class='match'>78    ZipfModel(size_t k, double q, double v) : k_(k), q_(q), v_(v) {}
79    double mean() const { return mean_; }
80    double PMF(size_t i) { return i >= hnq_.size() ? 0.0 : hnq_[i] / sum_hnq_; }
</span>81    double CDF(size_t i) {
82      if (i >= hnq_.size()) {
83        return 1.0;
84      }
85      auto it = std::begin(hnq_);
86      double h = 0.0;
87      for (const auto end = it; it != end; it++) {
88        h += *it;
89      }
90      return h / sum_hnq_;
91    }
92    std::pair<size_t, size_t> InverseCDF(double p) {
93      size_t min = 0;
94      size_t max = hnq_.size();
95      while (max > min + 1) {
96        size_t target = (max + min) >> 1;
97        double x = CDF(target);
98        if (x > p) {
99          max = target;
100        } else {
101          min = target;
102        }
103      }
104      return {min, max};
105    }
106    void Init() {
107      if (!hnq_.empty()) {
108        return;
109      }
110      hnq_.clear();
111      hnq_.reserve(std::min(k_, size_t{1000}));
112      sum_hnq_ = 0;
113      double qm1 = q_ - 1.0;
114      double sum_hnq_m1 = 0;
115      for (size_t i = 0; i < k_; i++) {
116        const double x = v_ + i;
117        const double hnqm1 =
118            (q_ == 2.0) ? (1.0 / x)
119                        : (q_ == 3.0) ? (1.0 / (x * x)) : std::pow(x, -qm1);
120        sum_hnq_m1 += hnqm1;
121        const double hnq =
122            (q_ == 2.0) ? (1.0 / (x * x))
123                        : (q_ == 3.0) ? (1.0 / (x * x * x)) : std::pow(x, -q_);
124        sum_hnq_ += hnq;
125        hnq_.push_back(hnq);
126        if (i > 1000 && hnq <= 1e-10) {
127          break;
128        }
129      }
130      assert(sum_hnq_ > 0);
131      mean_ = sum_hnq_m1 / sum_hnq_;
132    }
133   private:
134    const size_t k_;
135    const double q_;
136    const double v_;
137    double mean_;
138    std::vector<double> hnq_;
139    double sum_hnq_;
140  };
141  using zipf_u64 = absl::zipf_distribution<uint64_t>;
142  class ZipfTest : public testing::TestWithParam<zipf_u64::param_type>,
143                   public ZipfModel {
144   public:
145    ZipfTest() : ZipfModel(GetParam().k(), GetParam().q(), GetParam().v()) {}
146    absl::random_internal::pcg64_2018_engine rng_{0x2B7E151628AED2A6};
147  };
148  TEST_P(ZipfTest, ChiSquaredTest) {
149    const auto& param = GetParam();
150    Init();
151    size_t trials = 10000;
152    std::vector<size_t> points;
153    std::vector<double> expected;
154    {
155      double last_cdf = 0.0;
156      double min_p = 1.0;
157      for (double p = 0.01; p < 1.0; p += 0.01) {
158        auto x = InverseCDF(p);
159        if (points.empty() || points.back() < x.second) {
160          const double p = CDF(x.second);
161          points.push_back(x.second);
162          double q = p - last_cdf;
163          expected.push_back(q);
164          last_cdf = p;
165          if (q < min_p) {
166            min_p = q;
167          }
168        }
169      }
170      if (last_cdf < 0.999) {
171        points.push_back(std::numeric_limits<size_t>::max());
172        double q = 1.0 - last_cdf;
173        expected.push_back(q);
174        if (q < min_p) {
175          min_p = q;
176        }
177      } else {
178        points.back() = std::numeric_limits<size_t>::max();
179        expected.back() += (1.0 - last_cdf);
180      }
181      trials = static_cast<size_t>(8.0 / min_p);
182    }
183    ASSERT_GT(points.size(), 0);
184    std::vector<int64_t> buckets(points.size(), 0);
185    double avg = 0;
186    {
187      zipf_u64 dis(param);
188      for (size_t i = 0; i < trials; i++) {
189        uint64_t x = dis(rng_);
190        ASSERT_LE(x, dis.max());
191        ASSERT_GE(x, dis.min());
192        avg += static_cast<double>(x);
193        auto it = std::upper_bound(std::begin(points), std::end(points),
194                                   static_cast<size_t>(x));
195        buckets[std::distance(std::begin(points), it)]++;
196      }
197      avg = avg / static_cast<double>(trials);
198    }
199    for (auto& e : expected) {
200      e *= trials;
201    }
202    const int dof = static_cast<int>(expected.size()) - 1;
203    const double threshold = absl::random_internal::ChiSquareValue(dof, 0.9999);
204    const double chi_square = absl::random_internal::ChiSquare(
205        std::begin(buckets), std::end(buckets), std::begin(expected),
206        std::end(expected));
207    const double p_actual =
208        absl::random_internal::ChiSquarePValue(chi_square, dof);
209    if (chi_square > threshold) {
210      LOG(INFO) << "values";
211      for (size_t i = 0; i < expected.size(); i++) {
212        LOG(INFO) << points[i] << ": " << buckets[i] << " vs. E=" << expected[i];
213      }
214      LOG(INFO) << "trials " << trials;
215      LOG(INFO) << "mean " << avg << " vs. expected " << mean();
216      LOG(INFO) << kChiSquared << "(data, " << dof << ") = " << chi_square << " ("
217                << p_actual << ")";
218      LOG(INFO) << kChiSquared << " @ 0.9995 = " << threshold;
219      FAIL() << kChiSquared << " value of " << chi_square
220             << " is above the threshold.";
221    }
222  }
223  std::vector<zipf_u64::param_type> GenParams() {
224    using param = zipf_u64::param_type;
225    const auto k = param().k();
226    const auto q = param().q();
227    const auto v = param().v();
228    const uint64_t k2 = 1 << 10;
229    return std::vector<zipf_u64::param_type>{
230        param(k, q, v),
231        param(4, q, v), param(1 << 4, q, v), param(k2, q, v),
232        param(k2, q, 0.5), param(k2, q, 1.5), param(k2, q, 2.5), param(k2, q, 10),
233        param(k2, 1.5, v), param(k2, 3, v), param(k2, 5, v), param(k2, 10, v),
234        param(k2, 1.5, 0.5), param(k2, 3, 1.5), param(k, 10, 10)};
235  }
236  std::string ParamName(
237      const ::testing::TestParamInfo<zipf_u64::param_type>& info) {
238    const auto& p = info.param;
239    std::string name = absl::StrCat("k_", p.k(), "__q_", absl::SixDigits(p.q()),
240                                    "__v_", absl::SixDigits(p.v()));
241    return absl::StrReplaceAll(name, {{"+", "_"}, {"-", "_"}, {".", "_"}});
242  }
243  INSTANTIATE_TEST_SUITE_P(All, ZipfTest, ::testing::ValuesIn(GenParams()),
244                           ParamName);
245  TEST(ZipfDistributionTest, StabilityTest) {
246    absl::random_internal::sequence_urbg urbg(
247        {0x0003eb76f6f7f755ull, 0xFFCEA50FDB2F953Bull, 0xC332DDEFBE6C5AA5ull,
248         0x6558218568AB9702ull, 0x2AEF7DAD5B6E2F84ull, 0x1521B62829076170ull,
249         0xECDD4775619F1510ull, 0x13CCA830EB61BD96ull, 0x0334FE1EAA0363CFull,
250         0xB5735C904C70A239ull, 0xD59E9E0BCBAADE14ull, 0xEECC86BC60622CA7ull});
251    std::vector<int> output(10);
252    {
253      absl::zipf_distribution<int32_t> dist;
254      std::generate(std::begin(output), std::end(output),
255                    [&] { return dist(urbg); });
256      EXPECT_THAT(output, ElementsAre(10031, 0, 0, 3, 6, 0, 7, 47, 0, 0));
257    }
258    urbg.reset();
259    {
260      absl::zipf_distribution<int32_t> dist(std::numeric_limits<int32_t>::max(),
261                                            3.3);
262      std::generate(std::begin(output), std::end(output),
263                    [&] { return dist(urbg); });
264      EXPECT_THAT(output, ElementsAre(44, 0, 0, 0, 0, 1, 0, 1, 3, 0));
265    }
266  }
267  TEST(ZipfDistributionTest, AlgorithmBounds) {
268    absl::zipf_distribution<int32_t> dist;
269    const std::pair<uint64_t, int32_t> kInputs[] = {
270        {0xffffffffffffffff, 0x0}, {0x7fffffffffffffff, 0x0},
271        {0x3ffffffffffffffb, 0x1}, {0x1ffffffffffffffd, 0x4},
272        {0xffffffffffffffe, 0x9},  {0x7ffffffffffffff, 0x12},
273        {0x3ffffffffffffff, 0x25}, {0x1ffffffffffffff, 0x4c},
274        {0xffffffffffffff, 0x99},  {0x7fffffffffffff, 0x132},
275        {0x3fffffffffffff, 0x265}, {0x1fffffffffffff, 0x4cc},
276        {0xfffffffffffff, 0x999},  {0x7ffffffffffff, 0x1332},
277        {0x3ffffffffffff, 0x2665}, {0x1ffffffffffff, 0x4ccc},
278        {0xffffffffffff, 0x9998},  {0x7fffffffffff, 0x1332f},
279        {0x3fffffffffff, 0x2665a}, {0x1fffffffffff, 0x4cc9e},
280        {0xfffffffffff, 0x998e0},  {0x7ffffffffff, 0x133051},
281        {0x3ffffffffff, 0x265ae4}, {0x1ffffffffff, 0x4c9ed3},
282        {0xffffffffff, 0x98e223},  {0x7fffffffff, 0x13058c4},
283        {0x3fffffffff, 0x25b178e}, {0x1fffffffff, 0x4a062b2},
284        {0xfffffffff, 0x8ee23b8},  {0x7ffffffff, 0x10b21642},
285        {0x3ffffffff, 0x1d89d89d}, {0x1ffffffff, 0x2fffffff},
286        {0xffffffff, 0x45d1745d},  {0x7fffffff, 0x5a5a5a5a},
287        {0x3fffffff, 0x69ee5846},  {0x1fffffff, 0x73ecade3},
288        {0xfffffff, 0x79a9d260},   {0x7ffffff, 0x7cc0532b},
289        {0x3ffffff, 0x7e5ad146},   {0x1ffffff, 0x7f2c0bec},
290        {0xffffff, 0x7f95adef},    {0x7fffff, 0x7fcac0da},
291        {0x3fffff, 0x7fe55ae2},    {0x1fffff, 0x7ff2ac0e},
292        {0xfffff, 0x7ff955ae},     {0x7ffff, 0x7ffcaac1},
293        {0x3ffff, 0x7ffe555b},     {0x1ffff, 0x7fff2aac},
294        {0xffff, 0x7fff9556},      {0x7fff, 0x7fffcaab},
295        {0x3fff, 0x7fffe555},      {0x1fff, 0x7ffff2ab},
296        {0xfff, 0x7ffff955},       {0x7ff, 0x7ffffcab},
297        {0x3ff, 0x7ffffe55},       {0x1ff, 0x7fffff2b},
298        {0xff, 0x7fffff95},        {0x7f, 0x7fffffcb},
299        {0x3f, 0x7fffffe5},        {0x1f, 0x7ffffff3},
300        {0xf, 0x7ffffff9},         {0x7, 0x7ffffffd},
301        {0x3, 0x7ffffffe},         {0x1, 0x7fffffff},
302    };
303    for (const auto& instance : kInputs) {
304      absl::random_internal::sequence_urbg urbg({instance.first});
305      EXPECT_EQ(instance.second, dist(urbg));
306    }
307  }
308  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-nyta.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-zipf_distribution_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>46    void AddTopicId(const int& TopicId){TopicIdV.AddUnique(TopicId);}
47    int GetTopicIds() const {return TopicIdV.Len();}
48    int GetTopicId(const int& TopicIdN) const {return TopicIdV[TopicIdN];}
</pre></code></div>
                <div class="column column_space"><pre><code>78    ZipfModel(size_t k, double q, double v) : k_(k), q_(q), v_(v) {}
79    double mean() const { return mean_; }
80    double PMF(size_t i) { return i >= hnq_.size() ? 0.0 : hnq_[i] / sum_hnq_; }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    