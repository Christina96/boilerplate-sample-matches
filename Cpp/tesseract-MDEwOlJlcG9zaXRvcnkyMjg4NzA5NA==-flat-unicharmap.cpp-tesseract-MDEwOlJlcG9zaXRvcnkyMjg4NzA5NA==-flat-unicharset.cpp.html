
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-unicharmap.cpp</h3>
            <pre><code>1  #include "unicharmap.h"
2  #include <tesseract/unichar.h>
3  #include <cassert>
4  namespace tesseract {
5  UNICHARMAP::UNICHARMAP() : nodes(nullptr) {}
6  UNICHARMAP::~UNICHARMAP() {
7    delete[] nodes;
8  }
<span onclick='openModal()' class='match'>9  UNICHAR_ID UNICHARMAP::unichar_to_id(const char *const unichar_repr, int length) const {
10    UNICHARMAP_NODE *current_nodes = nodes;
</span>11    assert(*unichar_repr != '\0');
12    assert(length > 0 && length <= UNICHAR_LEN);
13    int index = 0;
14    if (length <= 0 || unichar_repr[index] == '\0') {
15      return INVALID_UNICHAR_ID;
16    }
17    do {
18      if (index + 1 >= length || unichar_repr[index + 1] == '\0') {
19        return current_nodes[static_cast<unsigned char>(unichar_repr[index])].id;
20      }
21      current_nodes = current_nodes[static_cast<unsigned char>(unichar_repr[index])].children;
22      ++index;
23    } while (true);
24  }
25  void UNICHARMAP::insert(const char *const unichar_repr, UNICHAR_ID id) {
26    const char *current_char = unichar_repr;
27    if (*current_char == '\0') {
28      return;
29    }
30    UNICHARMAP_NODE **current_nodes_pointer = &nodes;
31    do {
32      if (*current_nodes_pointer == nullptr) {
33        *current_nodes_pointer = new UNICHARMAP_NODE[256];
34      }
35      if (current_char[1] == '\0') {
36        (*current_nodes_pointer)[static_cast<unsigned char>(*current_char)].id = id;
37        return;
38      }
39      current_nodes_pointer =
40          &((*current_nodes_pointer)[static_cast<unsigned char>(*current_char)].children);
41      ++current_char;
42    } while (true);
43  }
44  bool UNICHARMAP::contains(const char *const unichar_repr, int length) const {
45    if (unichar_repr == nullptr || *unichar_repr == '\0') {
46      return false;
47    }
48    if (length <= 0 || length > UNICHAR_LEN) {
49      return false;
50    }
51    int index = 0;
52    if (unichar_repr[index] == '\0') {
53      return false;
54    }
55    UNICHARMAP_NODE *current_nodes = nodes;
56    while (current_nodes != nullptr && index + 1 < length && unichar_repr[index + 1] != '\0') {
57      current_nodes = current_nodes[static_cast<unsigned char>(unichar_repr[index])].children;
58      ++index;
59    }
60    return current_nodes != nullptr && (index + 1 >= length || unichar_repr[index + 1] == '\0') &&
61           current_nodes[static_cast<unsigned char>(unichar_repr[index])].id >= 0;
62  }
63  int UNICHARMAP::minmatch(const char *const unichar_repr) const {
64    const char *current_char = unichar_repr;
65    if (*current_char == '\0') {
66      return 0;
67    }
68    UNICHARMAP_NODE *current_nodes = nodes;
69    while (current_nodes != nullptr && *current_char != '\0') {
70      if (current_nodes[static_cast<unsigned char>(*current_char)].id >= 0) {
71        return current_char + 1 - unichar_repr;
72      }
73      current_nodes = current_nodes[static_cast<unsigned char>(*current_char)].children;
74      ++current_char;
75    }
76    return 0;
77  }
78  void UNICHARMAP::clear() {
79    delete[] nodes;
80    nodes = nullptr;
81  }
82  UNICHARMAP::UNICHARMAP_NODE::UNICHARMAP_NODE() : children(nullptr), id(-1) {}
83  UNICHARMAP::UNICHARMAP_NODE::~UNICHARMAP_NODE() {
84    delete[] children;
85  }
86  } 
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-unicharset.cpp</h3>
            <pre><code>1  #include "unicharset.h"
2  #include "params.h"
3  #include <tesseract/unichar.h>
4  #include "serialis.h"
5  #include <algorithm>
6  #include <cassert>
7  #include <cstdio>
8  #include <cstring>
9  #include <iomanip> 
10  #include <locale>  
11  #include <sstream> 
12  namespace tesseract {
13  static const char kSeparator = '|';
14  static const char kNaturalFlag = 'n';
15  static const int ISALPHA_MASK = 0x1;
16  static const int ISLOWER_MASK = 0x2;
17  static const int ISUPPER_MASK = 0x4;
18  static const int ISDIGIT_MASK = 0x8;
19  static const int ISPUNCTUATION_MASK = 0x10;
20  static const int kMeanlineThreshold = 220;
21  const double kMinXHeightFraction = 0.25;
22  const double kMinCapHeightFraction = 0.05;
23  const char *UNICHARSET::kCustomLigatures[][2] = {
24      {"ct", "\uE003"}, 
25      {"ſh", "\uE006"}, 
26      {"ſi", "\uE007"}, 
27      {"ſl", "\uE008"}, 
28      {"ſſ", "\uE009"}, 
29      {nullptr, nullptr}};
30  const char *UNICHARSET::kCleanupMaps[][2] = {
31      {"\u0640", ""},   
32      {"\ufb01", "fi"}, 
33      {"\ufb02", "fl"}, 
34      {nullptr, nullptr}};
35  const char *UNICHARSET::kSpecialUnicharCodes[SPECIAL_UNICHAR_CODES_COUNT] = {
36      " ", "Joined", "|Broken|0|1"};
37  const char *UNICHARSET::null_script = "NULL";
38  UNICHARSET::UNICHAR_PROPERTIES::UNICHAR_PROPERTIES() {
39    Init();
40  }
41  void UNICHARSET::UNICHAR_PROPERTIES::Init() {
42    isalpha = false;
43    islower = false;
44    isupper = false;
45    isdigit = false;
46    ispunctuation = false;
47    isngram = false;
48    enabled = false;
49    SetRangesOpen();
50    script_id = 0;
51    other_case = 0;
52    mirror = 0;
53    normed = "";
54    direction = UNICHARSET::U_LEFT_TO_RIGHT;
55    fragment = nullptr;
56  }
57  void UNICHARSET::UNICHAR_PROPERTIES::SetRangesOpen() {
58    min_bottom = 0;
59    max_bottom = UINT8_MAX;
60    min_top = 0;
61    max_top = UINT8_MAX;
62    width = 0.0f;
63    width_sd = 0.0f;
64    bearing = 0.0f;
65    bearing_sd = 0.0f;
66    advance = 0.0f;
67    advance_sd = 0.0f;
68  }
69  void UNICHARSET::UNICHAR_PROPERTIES::SetRangesEmpty() {
70    min_bottom = UINT8_MAX;
71    max_bottom = 0;
72    min_top = UINT8_MAX;
73    max_top = 0;
74    width = 0.0f;
75    width_sd = 0.0f;
76    bearing = 0.0f;
77    bearing_sd = 0.0f;
78    advance = 0.0f;
79    advance_sd = 0.0f;
80  }
81  bool UNICHARSET::UNICHAR_PROPERTIES::AnyRangeEmpty() const {
82    return width == 0.0f || advance == 0.0f;
83  }
84  void UNICHARSET::UNICHAR_PROPERTIES::ExpandRangesFrom(
85      const UNICHAR_PROPERTIES &src) {
86    UpdateRange(src.min_bottom, &min_bottom, &max_bottom);
87    UpdateRange(src.max_bottom, &min_bottom, &max_bottom);
88    UpdateRange(src.min_top, &min_top, &max_top);
89    UpdateRange(src.max_top, &min_top, &max_top);
90    if (src.width_sd > width_sd) {
91      width = src.width;
92      width_sd = src.width_sd;
93    }
94    if (src.bearing_sd > bearing_sd) {
95      bearing = src.bearing;
96      bearing_sd = src.bearing_sd;
97    }
98    if (src.advance_sd > advance_sd) {
99      advance = src.advance;
100      advance_sd = src.advance_sd;
101    }
102  }
103  void UNICHARSET::UNICHAR_PROPERTIES::CopyFrom(const UNICHAR_PROPERTIES &src) {
104    CHAR_FRAGMENT *saved_fragment = fragment;
105    *this = src; 
106    fragment = saved_fragment;
107  }
108  UNICHARSET::UNICHARSET()
109      : ids(), script_table(nullptr), script_table_size_used(0) {
110    clear();
111    for (int i = 0; i < SPECIAL_UNICHAR_CODES_COUNT; ++i) {
112      unichar_insert(kSpecialUnicharCodes[i]);
113      if (i == UNICHAR_JOINED) {
114        set_isngram(i, true);
115      }
116    }
117  }
118  UNICHARSET::~UNICHARSET() {
119    clear();
120  }
121  UNICHAR_ID
122  UNICHARSET::unichar_to_id(const char *const unichar_repr) const {
123    std::string cleaned =
124        old_style_included_ ? unichar_repr : CleanupString(unichar_repr);
125    return ids.contains(cleaned.data(), cleaned.size())
126               ? ids.unichar_to_id(cleaned.data(), cleaned.size())
127               : INVALID_UNICHAR_ID;
128  }
<span onclick='openModal()' class='match'>129  UNICHAR_ID UNICHARSET::unichar_to_id(const char *const unichar_repr,
130                                       int length) const {
131    assert(length > 0 && length <= UNICHAR_LEN);
</span>132    std::string cleaned(unichar_repr, length);
133    if (!old_style_included_) {
134      cleaned = CleanupString(unichar_repr, length);
135    }
136    return ids.contains(cleaned.data(), cleaned.size())
137               ? ids.unichar_to_id(cleaned.data(), cleaned.size())
138               : INVALID_UNICHAR_ID;
139  }
140  int UNICHARSET::step(const char *str) const {
141    std::vector<UNICHAR_ID> encoding;
142    std::vector<char> lengths;
143    encode_string(str, true, &encoding, &lengths, nullptr);
144    if (encoding.empty() || encoding[0] == INVALID_UNICHAR_ID) {
145      return 0;
146    }
147    return lengths[0];
148  }
149  bool UNICHARSET::encodable_string(const char *str,
150                                    unsigned *first_bad_position) const {
151    std::vector<UNICHAR_ID> encoding;
152    return encode_string(str, true, &encoding, nullptr, first_bad_position);
153  }
154  bool UNICHARSET::encode_string(const char *str, bool give_up_on_failure,
155                                 std::vector<UNICHAR_ID> *encoding,
156                                 std::vector<char> *lengths,
157                                 unsigned *encoded_length) const {
158    std::vector<UNICHAR_ID> working_encoding;
159    std::vector<char> working_lengths;
160    std::vector<char> best_lengths;
161    encoding->clear(); 
162    auto str_length = strlen(str);
163    unsigned str_pos = 0;
164    bool perfect = true;
165    while (str_pos < str_length) {
166      encode_string(str, str_pos, str_length, &working_encoding, &working_lengths,
167                    &str_pos, encoding, &best_lengths);
168      if (str_pos < str_length) {
169        perfect = false;
170        if (give_up_on_failure) {
171          break;
172        }
173        int step = UNICHAR::utf8_step(str + str_pos);
174        if (step == 0) {
175          step = 1;
176        }
177        encoding->push_back(INVALID_UNICHAR_ID);
178        best_lengths.push_back(step);
179        str_pos += step;
180        working_encoding = *encoding;
181        working_lengths = best_lengths;
182      }
183    }
184    if (lengths != nullptr) {
185      *lengths = best_lengths;
186    }
187    if (encoded_length != nullptr) {
188      *encoded_length = str_pos;
189    }
190    return perfect;
191  }
192  const char *UNICHARSET::id_to_unichar(UNICHAR_ID id) const {
193    if (id == INVALID_UNICHAR_ID) {
194      return INVALID_UNICHAR;
195    }
196    ASSERT_HOST(static_cast<unsigned>(id) < this->size());
197    return unichars[id].representation;
198  }
199  const char *UNICHARSET::id_to_unichar_ext(UNICHAR_ID id) const {
200    if (id == INVALID_UNICHAR_ID) {
201      return INVALID_UNICHAR;
202    }
203    ASSERT_HOST(static_cast<unsigned>(id) < this->size());
204    if (get_isprivate(id)) {
205      const char *ch = id_to_unichar(id);
206      for (int i = 0; kCustomLigatures[i][0] != nullptr; ++i) {
207        if (!strcmp(ch, kCustomLigatures[i][1])) {
208          return kCustomLigatures[i][0];
209        }
210      }
211    }
212    return unichars[id].representation;
213  }
214  std::string UNICHARSET::debug_utf8_str(const char *str) {
215    std::string result = str;
216    result += " [";
217    int step = 1;
218    for (int i = 0; str[i] != '\0'; i += step) {
219      char hex[sizeof(int) * 2 + 1];
220      step = UNICHAR::utf8_step(str + i);
221      if (step == 0) {
222        step = 1;
223        snprintf(hex, sizeof(hex), "%x", str[i]);
224      } else {
225        UNICHAR ch(str + i, step);
226        snprintf(hex, sizeof(hex), "%x", ch.first_uni());
227      }
228      result += hex;
229      result += " ";
230    }
231    result += "]";
232    return result;
233  }
234  std::string UNICHARSET::debug_str(UNICHAR_ID id) const {
235    if (id == INVALID_UNICHAR_ID) {
236      return std::string(id_to_unichar(id));
237    }
238    const CHAR_FRAGMENT *fragment = this->get_fragment(id);
239    if (fragment) {
240      return fragment->to_string();
241    }
242    const char *str = id_to_unichar(id);
243    std::string result = debug_utf8_str(str);
244    if (get_isalpha(id)) {
245      if (get_islower(id)) {
246        result += "a";
247      } else if (get_isupper(id)) {
248        result += "A";
249      } else {
250        result += "x";
251      }
252    }
253    if (get_isdigit(id)) {
254      result += "0";
255    }
256    if (get_ispunctuation(id)) {
257      result += "p";
258    }
259    return result;
260  }
261  void UNICHARSET::set_normed_ids(UNICHAR_ID unichar_id) {
262    unichars[unichar_id].properties.normed_ids.clear();
263    if (unichar_id == UNICHAR_SPACE && id_to_unichar(unichar_id)[0] == ' ') {
264      unichars[unichar_id].properties.normed_ids.push_back(UNICHAR_SPACE);
265    } else if (!encode_string(unichars[unichar_id].properties.normed.c_str(),
266                              true, &unichars[unichar_id].properties.normed_ids,
267                              nullptr, nullptr)) {
268      unichars[unichar_id].properties.normed_ids.clear();
269      unichars[unichar_id].properties.normed_ids.push_back(unichar_id);
270    }
271  }
272  bool UNICHARSET::get_isprivate(UNICHAR_ID unichar_id) const {
273    UNICHAR uc(id_to_unichar(unichar_id), -1);
274    int uni = uc.first_uni();
275    return (uni >= 0xE000 && uni <= 0xF8FF);
276  }
277  void UNICHARSET::set_ranges_empty() {
278    for (auto &uc : unichars) {
279      uc.properties.SetRangesEmpty();
280    }
281  }
282  void UNICHARSET::PartialSetPropertiesFromOther(int start_index,
283                                                 const UNICHARSET &src) {
284    for (unsigned ch = start_index; ch < unichars.size(); ++ch) {
285      const char *utf8 = id_to_unichar(ch);
286      UNICHAR_PROPERTIES properties;
287      if (src.GetStrProperties(utf8, &properties)) {
288        const char *script = src.get_script_from_script_id(properties.script_id);
289        properties.script_id = add_script(script);
290        const char *other_case = src.id_to_unichar(properties.other_case);
291        if (contains_unichar(other_case)) {
292          properties.other_case = unichar_to_id(other_case);
293        } else {
294          properties.other_case = ch;
295        }
296        const char *mirror_str = src.id_to_unichar(properties.mirror);
297        if (contains_unichar(mirror_str)) {
298          properties.mirror = unichar_to_id(mirror_str);
299        } else {
300          properties.mirror = ch;
301        }
302        unichars[ch].properties.CopyFrom(properties);
303        set_normed_ids(ch);
304      }
305    }
306  }
307  void UNICHARSET::ExpandRangesFromOther(const UNICHARSET &src) {
308    for (unsigned ch = 0; ch < unichars.size(); ++ch) {
309      const char *utf8 = id_to_unichar(ch);
310      UNICHAR_PROPERTIES properties;
311      if (src.GetStrProperties(utf8, &properties)) {
312        unichars[ch].properties.ExpandRangesFrom(properties);
313      }
314    }
315  }
316  void UNICHARSET::CopyFrom(const UNICHARSET &src) {
317    clear();
318    for (unsigned ch = 0; ch < src.unichars.size(); ++ch) {
319      const UNICHAR_PROPERTIES &src_props = src.unichars[ch].properties;
320      const char *utf8 = src.id_to_unichar(ch);
321      unichar_insert_backwards_compatible(utf8);
322      unichars[ch].properties.ExpandRangesFrom(src_props);
323    }
324    PartialSetPropertiesFromOther(0, src);
325  }
326  void UNICHARSET::AppendOtherUnicharset(const UNICHARSET &src) {
327    int initial_used = unichars.size();
328    for (unsigned ch = 0; ch < src.unichars.size(); ++ch) {
329      const UNICHAR_PROPERTIES &src_props = src.unichars[ch].properties;
330      const char *utf8 = src.id_to_unichar(ch);
331      int id = unichars.size();
332      if (contains_unichar(utf8)) {
333        id = unichar_to_id(utf8);
334        unichars[id].properties.ExpandRangesFrom(src_props);
335      } else {
336        unichar_insert_backwards_compatible(utf8);
337        unichars[id].properties.SetRangesEmpty();
338      }
339    }
340    PartialSetPropertiesFromOther(initial_used, src);
341  }
342  bool UNICHARSET::SizesDistinct(UNICHAR_ID id1, UNICHAR_ID id2) const {
343    int overlap = std::min(unichars[id1].properties.max_top,
344                           unichars[id2].properties.max_top) -
345                  std::max(unichars[id1].properties.min_top,
346                           unichars[id2].properties.min_top);
347    return overlap <= 0;
348  }
349  void UNICHARSET::encode_string(const char *str, int str_index, int str_length,
350                                 std::vector<UNICHAR_ID> *encoding,
351                                 std::vector<char> *lengths,
352                                 unsigned *best_total_length,
353                                 std::vector<UNICHAR_ID> *best_encoding,
354                                 std::vector<char> *best_lengths) const {
355    if (str_index > static_cast<int>(*best_total_length)) {
356      *best_total_length = str_index;
357      *best_encoding = *encoding;
358      if (best_lengths != nullptr) {
359        *best_lengths = *lengths;
360      }
361    }
362    if (str_index == str_length) {
363      return;
364    }
365    int encoding_index = encoding->size();
366    int length = ids.minmatch(str + str_index);
367    if (length == 0 || str_index + length > str_length) {
368      return;
369    }
370    do {
371      if (ids.contains(str + str_index, length)) {
372        UNICHAR_ID id = ids.unichar_to_id(str + str_index, length);
373        encoding->push_back(id);
374        lengths->push_back(length);
375        encode_string(str, str_index + length, str_length, encoding, lengths,
376                      best_total_length, best_encoding, best_lengths);
377        if (static_cast<int>(*best_total_length) == str_length) {
378          return; 
379        }
380        encoding->resize(encoding_index);
381        lengths->resize(encoding_index);
382      }
383      int step = UNICHAR::utf8_step(str + str_index + length);
384      if (step == 0) {
385        step = 1;
386      }
387      length += step;
388    } while (length <= UNICHAR_LEN && str_index + length <= str_length);
389  }
390  bool UNICHARSET::GetStrProperties(const char *utf8_str,
391                                    UNICHAR_PROPERTIES *props) const {
392    props->Init();
393    props->SetRangesEmpty();
394    int total_unicodes = 0;
395    std::vector<UNICHAR_ID> encoding;
396    if (!encode_string(utf8_str, true, &encoding, nullptr, nullptr)) {
397      return false; 
398    }
399    for (auto it : encoding) {
400      int id = it;
401      const UNICHAR_PROPERTIES &src_props = unichars[id].properties;
402      if (src_props.isalpha) {
403        props->isalpha = true;
404      }
405      if (src_props.islower) {
406        props->islower = true;
407      }
408      if (src_props.isupper) {
409        props->isupper = true;
410      }
411      if (src_props.isdigit) {
412        props->isdigit = true;
413      }
414      if (src_props.ispunctuation) {
415        props->ispunctuation = true;
416      }
417      if (src_props.isngram) {
418        props->isngram = true;
419      }
420      if (src_props.enabled) {
421        props->enabled = true;
422      }
423      UpdateRange(src_props.min_bottom, &props->min_bottom, &props->max_bottom);
424      UpdateRange(src_props.max_bottom, &props->min_bottom, &props->max_bottom);
425      UpdateRange(src_props.min_top, &props->min_top, &props->max_top);
426      UpdateRange(src_props.max_top, &props->min_top, &props->max_top);
427      float bearing = props->advance + src_props.bearing;
428      if (total_unicodes == 0 || bearing < props->bearing) {
429        props->bearing = bearing;
430        props->bearing_sd = props->advance_sd + src_props.bearing_sd;
431      }
432      props->advance += src_props.advance;
433      props->advance_sd += src_props.advance_sd;
434      props->width = src_props.width;
435      props->width_sd = src_props.width_sd;
436      if (total_unicodes == 0) {
437        props->script_id = src_props.script_id;
438        props->other_case = src_props.other_case;
439        props->mirror = src_props.mirror;
440        props->direction = src_props.direction;
441      }
442      props->normed += src_props.normed;
443      ++total_unicodes;
444    }
445    if (total_unicodes > 1) {
446      props->width = props->advance - props->bearing;
447      props->width_sd = props->advance_sd + props->bearing_sd;
448    }
449    return total_unicodes > 0;
450  }
451  unsigned int UNICHARSET::get_properties(UNICHAR_ID id) const {
452    unsigned int properties = 0;
453    if (this->get_isalpha(id)) {
454      properties |= ISALPHA_MASK;
455    }
456    if (this->get_islower(id)) {
457      properties |= ISLOWER_MASK;
458    }
459    if (this->get_isupper(id)) {
460      properties |= ISUPPER_MASK;
461    }
462    if (this->get_isdigit(id)) {
463      properties |= ISDIGIT_MASK;
464    }
465    if (this->get_ispunctuation(id)) {
466      properties |= ISPUNCTUATION_MASK;
467    }
468    return properties;
469  }
470  char UNICHARSET::get_chartype(UNICHAR_ID id) const {
471    if (this->get_isupper(id)) {
472      return 'A';
473    }
474    if (this->get_islower(id)) {
475      return 'a';
476    }
477    if (this->get_isalpha(id)) {
478      return 'x';
479    }
480    if (this->get_isdigit(id)) {
481      return '0';
482    }
483    if (this->get_ispunctuation(id)) {
484      return 'p';
485    }
486    return 0;
487  }
488  void UNICHARSET::unichar_insert(const char *const unichar_repr,
489                                  OldUncleanUnichars old_style) {
490    if (old_style == OldUncleanUnichars::kTrue) {
491      old_style_included_ = true;
492    }
493    std::string cleaned =
494        old_style_included_ ? unichar_repr : CleanupString(unichar_repr);
495    if (!cleaned.empty() && !ids.contains(cleaned.data(), cleaned.size())) {
496      const char *str = cleaned.c_str();
497      std::vector<int> encoding;
498      if (!old_style_included_ &&
499          encode_string(str, true, &encoding, nullptr, nullptr)) {
500        return;
501      }
502      unichars.emplace_back();
503      auto &u = unichars.back();
504      int index = 0;
505      do {
506        if (index >= UNICHAR_LEN) {
507          fprintf(stderr, "Utf8 buffer too big, size>%d for %s\n", UNICHAR_LEN,
508                  unichar_repr);
509          return;
510        }
511        u.representation[index++] = *str++;
512      } while (*str != '\0');
513      u.representation[index] = '\0';
514      this->set_script(unichars.size() - 1, null_script);
515      CHAR_FRAGMENT *frag = CHAR_FRAGMENT::parse_from_string(u.representation);
516      u.properties.fragment = frag;
517      if (frag != nullptr && this->contains_unichar(frag->get_unichar())) {
518        u.properties.script_id = this->get_script(frag->get_unichar());
519      }
520      u.properties.enabled = true;
521      ids.insert(u.representation, unichars.size() - 1);
522    }
523  }
524  bool UNICHARSET::contains_unichar(const char *const unichar_repr) const {
525    std::string cleaned =
526        old_style_included_ ? unichar_repr : CleanupString(unichar_repr);
527    return ids.contains(cleaned.data(), cleaned.size());
528  }
529  bool UNICHARSET::contains_unichar(const char *const unichar_repr,
530                                    int length) const {
531    if (length == 0) {
532      return false;
533    }
534    std::string cleaned(unichar_repr, length);
535    if (!old_style_included_) {
536      cleaned = CleanupString(unichar_repr, length);
537    }
538    return ids.contains(cleaned.data(), cleaned.size());
539  }
540  bool UNICHARSET::eq(UNICHAR_ID unichar_id,
541                      const char *const unichar_repr) const {
542    return strcmp(this->id_to_unichar(unichar_id), unichar_repr) == 0;
543  }
544  bool UNICHARSET::save_to_string(std::string &str) const {
545    const int kFileBufSize = 1024;
546    char buffer[kFileBufSize + 1];
547    snprintf(buffer, kFileBufSize, "%zu\n", this->size());
548    str = buffer;
549    for (unsigned id = 0; id < this->size(); ++id) {
550      int min_bottom, max_bottom, min_top, max_top;
551      get_top_bottom(id, &min_bottom, &max_bottom, &min_top, &max_top);
552      float width, width_sd;
553      get_width_stats(id, &width, &width_sd);
554      float bearing, bearing_sd;
555      get_bearing_stats(id, &bearing, &bearing_sd);
556      float advance, advance_sd;
557      get_advance_stats(id, &advance, &advance_sd);
558      unsigned int properties = this->get_properties(id);
559      if (strcmp(this->id_to_unichar(id), " ") == 0) {
560        snprintf(buffer, kFileBufSize, "%s %x %s %d\n", "NULL", properties,
561                 this->get_script_from_script_id(this->get_script(id)),
562                 this->get_other_case(id));
563        str += buffer;
564      } else {
565        std::ostringstream stream;
566        stream.imbue(std::locale::classic());
567        stream << this->id_to_unichar(id) << ' ' << properties << ' '
568               << min_bottom << ',' << max_bottom << ',' << min_top << ','
569               << max_top << ',' << width << ',' << width_sd << ',' << bearing
570               << ',' << bearing_sd << ',' << advance << ',' << advance_sd << ' '
571               << this->get_script_from_script_id(this->get_script(id)) << ' '
572               << this->get_other_case(id) << ' ' << this->get_direction(id)
573               << ' ' << this->get_mirror(id) << ' '
574               << this->get_normed_unichar(id) << "\t# "
575               << this->debug_str(id).c_str() << '\n';
576        str += stream.str().c_str();
577      }
578    }
579    return true;
580  }
581  class LocalFilePointer {
582  public:
583    LocalFilePointer(FILE *stream) : fp_(stream) {}
584    char *fgets(char *dst, int size) {
585      return ::fgets(dst, size, fp_);
586    }
587  private:
588    FILE *fp_;
589  };
590  bool UNICHARSET::load_from_file(FILE *file, bool skip_fragments) {
591    LocalFilePointer lfp(file);
592    using namespace std::placeholders; 
593    std::function<char *(char *, int)> fgets_cb =
594        std::bind(&LocalFilePointer::fgets, &lfp, _1, _2);
595    bool success = load_via_fgets(fgets_cb, skip_fragments);
596    return success;
597  }
598  bool UNICHARSET::load_from_file(tesseract::TFile *file, bool skip_fragments) {
599    using namespace std::placeholders; 
600    std::function<char *(char *, int)> fgets_cb =
601        std::bind(&tesseract::TFile::FGets, file, _1, _2);
602    bool success = load_via_fgets(fgets_cb, skip_fragments);
603    return success;
604  }
605  bool UNICHARSET::load_via_fgets(
606      const std::function<char *(char *, int)> &fgets_cb, bool skip_fragments) {
607    int unicharset_size;
608    char buffer[256];
609    this->clear();
610    if (fgets_cb(buffer, sizeof(buffer)) == nullptr ||
611        sscanf(buffer, "%d", &unicharset_size) != 1) {
612      return false;
613    }
614    for (UNICHAR_ID id = 0; id < unicharset_size; ++id) {
615      char unichar[256];
616      unsigned int properties;
617      char script[64];
618      strncpy(script, null_script, sizeof(script) - 1);
619      int min_bottom = 0;
620      int max_bottom = UINT8_MAX;
621      int min_top = 0;
622      int max_top = UINT8_MAX;
623      float width = 0.0f;
624      float width_sd = 0.0f;
625      float bearing = 0.0f;
626      float bearing_sd = 0.0f;
627      float advance = 0.0f;
628      float advance_sd = 0.0f;
629      int direction = UNICHARSET::U_LEFT_TO_RIGHT;
630      UNICHAR_ID other_case = unicharset_size;
631      UNICHAR_ID mirror = unicharset_size;
632      if (fgets_cb(buffer, sizeof(buffer)) == nullptr) {
633        return false;
634      }
635      char normed[64];
636      normed[0] = '\0';
637      std::istringstream stream(buffer);
638      stream.imbue(std::locale::classic());
639      stream >> std::setw(255) >> unichar >> std::hex >> properties >> std::dec;
640      if (stream.fail()) {
641        fprintf(stderr, "%s:%u failed\n", __FILE__, __LINE__);
642        return false;
643      }
644      auto position = stream.tellg();
645      stream.seekg(position);
646      char c1, c2, c3, c4, c5, c6, c7, c8, c9;
647      stream >> min_bottom >> c1 >> max_bottom >> c2 >> min_top >> c3 >>
648          max_top >> c4 >> width >> c5 >> width_sd >> c6 >> bearing >> c7 >>
649          bearing_sd >> c8 >> advance >> c9 >> advance_sd >> std::setw(63) >>
650          script >> other_case >> direction >> mirror >> std::setw(63) >> normed;
651      if (stream.fail() || c1 != ',' || c2 != ',' || c3 != ',' || c4 != ',' ||
652          c5 != ',' || c6 != ',' || c7 != ',' || c8 != ',' || c9 != ',') {
653        stream.clear();
654        stream.seekg(position);
655        stream >> min_bottom >> c1 >> max_bottom >> c2 >> min_top >> c3 >>
656            max_top >> c4 >> width >> c5 >> width_sd >> c6 >> bearing >> c7 >>
657            bearing_sd >> c8 >> advance >> c9 >> advance_sd >> std::setw(63) >>
658            script >> other_case >> direction >> mirror;
659        if (stream.fail() || c1 != ',' || c2 != ',' || c3 != ',' || c4 != ',' ||
660            c5 != ',' || c6 != ',' || c7 != ',' || c8 != ',' || c9 != ',') {
661          stream.clear();
662          stream.seekg(position);
663          stream >> min_bottom >> c1 >> max_bottom >> c2 >> min_top >> c3 >>
664              max_top >> std::setw(63) >> script >> other_case >> direction >>
665              mirror;
666          if (stream.fail() || c1 != ',' || c2 != ',' || c3 != ',') {
667            stream.clear();
668            stream.seekg(position);
669            stream >> min_bottom >> c1 >> max_bottom >> c2 >> min_top >> c3 >>
670                max_top >> std::setw(63) >> script >> other_case;
671            if (stream.fail() || c1 != ',' || c2 != ',' || c3 != ',') {
672              stream.clear();
673              stream.seekg(position);
674              stream >> std::setw(63) >> script >> other_case;
675              if (stream.fail()) {
676                stream.clear();
677                stream.seekg(position);
678                stream >> std::setw(63) >> script;
679              }
680            }
681          }
682        }
683      }
684      CHAR_FRAGMENT *frag = nullptr;
685      if (skip_fragments && (frag = CHAR_FRAGMENT::parse_from_string(unichar))) {
686        int num_pieces = frag->get_total();
687        delete frag;
688        if (num_pieces > 1) {
689          continue;
690        }
691      }
692      if (strcmp(unichar, "NULL") == 0) {
693        this->unichar_insert(" ");
694      } else {
695        this->unichar_insert_backwards_compatible(unichar);
696      }
697      this->set_isalpha(id, properties & ISALPHA_MASK);
698      this->set_islower(id, properties & ISLOWER_MASK);
699      this->set_isupper(id, properties & ISUPPER_MASK);
700      this->set_isdigit(id, properties & ISDIGIT_MASK);
701      this->set_ispunctuation(id, properties & ISPUNCTUATION_MASK);
702      this->set_isngram(id, false);
703      this->set_script(id, script);
704      this->unichars[id].properties.enabled = true;
705      this->set_top_bottom(id, min_bottom, max_bottom, min_top, max_top);
706      this->set_width_stats(id, width, width_sd);
707      this->set_bearing_stats(id, bearing, bearing_sd);
708      this->set_advance_stats(id, advance, advance_sd);
709      this->set_direction(id, static_cast<UNICHARSET::Direction>(direction));
710      this->set_other_case(id, (other_case < unicharset_size) ? other_case : id);
711      this->set_mirror(id, (mirror < unicharset_size) ? mirror : id);
712      this->set_normed(id, normed[0] != '\0' ? normed : unichar);
713    }
714    post_load_setup();
715    return true;
716  }
717  void UNICHARSET::post_load_setup() {
718    int net_case_alphas = 0;
719    int x_height_alphas = 0;
720    int cap_height_alphas = 0;
721    top_bottom_set_ = false;
722    for (unsigned id = 0; id < unichars.size(); ++id) {
723      int min_bottom = 0;
724      int max_bottom = UINT8_MAX;
725      int min_top = 0;
726      int max_top = UINT8_MAX;
727      get_top_bottom(id, &min_bottom, &max_bottom, &min_top, &max_top);
728      if (min_top > 0) {
729        top_bottom_set_ = true;
730      }
731      if (get_isalpha(id)) {
732        if (get_islower(id) || get_isupper(id)) {
733          ++net_case_alphas;
734        } else {
735          --net_case_alphas;
736        }
737        if (min_top < kMeanlineThreshold && max_top < kMeanlineThreshold) {
738          ++x_height_alphas;
739        } else if (min_top > kMeanlineThreshold && max_top > kMeanlineThreshold) {
740          ++cap_height_alphas;
741        }
742      }
743      set_normed_ids(id);
744    }
745    script_has_upper_lower_ = net_case_alphas > 0;
746    script_has_xheight_ =
747        script_has_upper_lower_ ||
748        (x_height_alphas > cap_height_alphas * kMinXHeightFraction &&
749         cap_height_alphas > x_height_alphas * kMinCapHeightFraction);
750    null_sid_ = get_script_id_from_name(null_script);
751    ASSERT_HOST(null_sid_ == 0);
752    common_sid_ = get_script_id_from_name("Common");
753    latin_sid_ = get_script_id_from_name("Latin");
754    cyrillic_sid_ = get_script_id_from_name("Cyrillic");
755    greek_sid_ = get_script_id_from_name("Greek");
756    han_sid_ = get_script_id_from_name("Han");
757    hiragana_sid_ = get_script_id_from_name("Hiragana");
758    katakana_sid_ = get_script_id_from_name("Katakana");
759    thai_sid_ = get_script_id_from_name("Thai");
760    hangul_sid_ = get_script_id_from_name("Hangul");
761    int *script_counts = new int[script_table_size_used];
762    memset(script_counts, 0, sizeof(*script_counts) * script_table_size_used);
763    for (unsigned id = 0; id < unichars.size(); ++id) {
764      if (get_isalpha(id)) {
765        ++script_counts[get_script(id)];
766      }
767    }
768    default_sid_ = 0;
769    for (int s = 1; s < script_table_size_used; ++s) {
770      if (script_counts[s] > script_counts[default_sid_] && s != common_sid_) {
771        default_sid_ = s;
772      }
773    }
774    delete[] script_counts;
775  }
776  bool UNICHARSET::major_right_to_left() const {
777    int ltr_count = 0;
778    int rtl_count = 0;
779    for (unsigned id = 0; id < unichars.size(); ++id) {
780      int dir = get_direction(id);
781      if (dir == UNICHARSET::U_LEFT_TO_RIGHT) {
782        ltr_count++;
783      }
784      if (dir == UNICHARSET::U_RIGHT_TO_LEFT ||
785          dir == UNICHARSET::U_RIGHT_TO_LEFT_ARABIC ||
786          dir == UNICHARSET::U_ARABIC_NUMBER) {
787        rtl_count++;
788      }
789    }
790    return rtl_count > ltr_count;
791  }
792  void UNICHARSET::set_black_and_whitelist(const char *blacklist,
793                                           const char *whitelist,
794                                           const char *unblacklist) {
795    bool def_enabled = whitelist == nullptr || whitelist[0] == '\0';
796    for (auto &uc : unichars) {
797      uc.properties.enabled = def_enabled;
798    }
799    if (!def_enabled) {
800      std::vector<UNICHAR_ID> encoding;
801      encode_string(whitelist, false, &encoding, nullptr, nullptr);
802      for (auto it : encoding) {
803        if (it != INVALID_UNICHAR_ID) {
804          unichars[it].properties.enabled = true;
805        }
806      }
807    }
808    if (blacklist != nullptr && blacklist[0] != '\0') {
809      std::vector<UNICHAR_ID> encoding;
810      encode_string(blacklist, false, &encoding, nullptr, nullptr);
811      for (auto it : encoding) {
812        if (it != INVALID_UNICHAR_ID) {
813          unichars[it].properties.enabled = false;
814        }
815      }
816    }
817    if (unblacklist != nullptr && unblacklist[0] != '\0') {
818      std::vector<UNICHAR_ID> encoding;
819      encode_string(unblacklist, false, &encoding, nullptr, nullptr);
820      for (auto it : encoding) {
821        if (it != INVALID_UNICHAR_ID) {
822          unichars[it].properties.enabled = true;
823        }
824      }
825    }
826  }
827  bool UNICHARSET::AnyRepeatedUnicodes() const {
828    int start_id = 0;
829    if (has_special_codes()) {
830      start_id = SPECIAL_UNICHAR_CODES_COUNT;
831    }
832    for (unsigned id = start_id; id < unichars.size(); ++id) {
833      std::vector<char32> unicodes = UNICHAR::UTF8ToUTF32(get_normed_unichar(id));
834      for (size_t u = 1; u < unicodes.size(); ++u) {
835        if (unicodes[u - 1] == unicodes[u]) {
836          return true;
837        }
838      }
839    }
840    return false;
841  }
842  int UNICHARSET::add_script(const char *script) {
843    for (int i = 0; i < script_table_size_used; ++i) {
844      if (strcmp(script, script_table[i]) == 0) {
845        return i;
846      }
847    }
848    if (script_table_size_reserved == 0) {
849      script_table_size_reserved = 8;
850      script_table = new char *[script_table_size_reserved];
851    } else if (script_table_size_used >= script_table_size_reserved) {
852      assert(script_table_size_used == script_table_size_reserved);
853      script_table_size_reserved += script_table_size_reserved;
854      char **new_script_table = new char *[script_table_size_reserved];
855      memcpy(new_script_table, script_table,
856             script_table_size_used * sizeof(char *));
857      delete[] script_table;
858      script_table = new_script_table;
859    }
860    script_table[script_table_size_used] = new char[strlen(script) + 1];
861    strcpy(script_table[script_table_size_used], script);
862    return script_table_size_used++;
863  }
864  std::string CHAR_FRAGMENT::to_string(const char *unichar, int pos, int total,
865                                       bool natural) {
866    if (total == 1) {
867      return std::string(unichar);
868    }
869    std::string result;
870    result += kSeparator;
871    result += unichar;
872    char buffer[kMaxLen];
873    snprintf(buffer, kMaxLen, "%c%d%c%d", kSeparator, pos,
874             natural ? kNaturalFlag : kSeparator, total);
875    result += buffer;
876    return result;
877  }
878  CHAR_FRAGMENT *CHAR_FRAGMENT::parse_from_string(const char *string) {
879    const char *ptr = string;
880    int len = strlen(string);
881    if (len < kMinLen || *ptr != kSeparator) {
882      return nullptr; 
883    }
884    ptr++; 
885    int step = 0;
886    while ((ptr + step) < (string + len) && *(ptr + step) != kSeparator) {
887      step += UNICHAR::utf8_step(ptr + step);
888    }
889    if (step == 0 || step > UNICHAR_LEN) {
890      return nullptr; 
891    }
892    char unichar[UNICHAR_LEN + 1];
893    strncpy(unichar, ptr, step);
894    unichar[step] = '\0'; 
895    ptr += step;          
896    int pos = 0;
897    int total = 0;
898    bool natural = false;
899    char *end_ptr = nullptr;
900    for (int i = 0; i < 2; i++) {
901      if (ptr > string + len || *ptr != kSeparator) {
902        if (i == 1 && *ptr == kNaturalFlag) {
903          natural = true;
904        } else {
905          return nullptr; 
906        }
907      }
908      ptr++; 
909      i == 0 ? pos = static_cast<int>(strtol(ptr, &end_ptr, 10))
910             : total = static_cast<int>(strtol(ptr, &end_ptr, 10));
911      ptr = end_ptr;
912    }
913    if (ptr != string + len) {
914      return nullptr; 
915    }
916    auto *fragment = new CHAR_FRAGMENT();
917    fragment->set_all(unichar, pos, total, natural);
918    return fragment;
919  }
920  int UNICHARSET::get_script_id_from_name(const char *script_name) const {
921    for (int i = 0; i < script_table_size_used; ++i) {
922      if (strcmp(script_name, script_table[i]) == 0) {
923        return i;
924      }
925    }
926    return 0; 
927  }
928  std::string UNICHARSET::CleanupString(const char *utf8_str, size_t length) {
929    std::string result;
930    result.reserve(length);
931    char ch;
932    while ((ch = *utf8_str) != '\0' && length-- > 0) {
933      int key_index = 0;
934      const char *key;
935      while ((key = kCleanupMaps[key_index][0]) != nullptr) {
936        int match = 0;
937        while (key[match] != '\0' && key[match] == utf8_str[match]) {
938          ++match;
939        }
940        if (key[match] == '\0') {
941          utf8_str += match;
942          break;
943        }
944        ++key_index;
945      }
946      if (key == nullptr) {
947        result.push_back(ch);
948        ++utf8_str;
949      } else {
950        result.append(kCleanupMaps[key_index][1]);
951      }
952    }
953    return result;
954  }
955  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-unicharmap.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-unicharset.cpp</div>
                </div>
                <div class="column column_space"><pre><code>9  UNICHAR_ID UNICHARMAP::unichar_to_id(const char *const unichar_repr, int length) const {
10    UNICHARMAP_NODE *current_nodes = nodes;
</pre></code></div>
                <div class="column column_space"><pre><code>129  UNICHAR_ID UNICHARSET::unichar_to_id(const char *const unichar_repr,
130                                       int length) const {
131    assert(length > 0 && length <= UNICHAR_LEN);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    