
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 14, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexPascal.cxx</h3>
            <pre><code>1  #include <stdlib.h>
2  #include <string.h>
3  #include <stdio.h>
4  #include <stdarg.h>
5  #include <assert.h>
6  #include <ctype.h>
7  #include <string>
8  #include <string_view>
9  #include "ILexer.h"
10  #include "Scintilla.h"
11  #include "SciLexer.h"
12  #include "WordList.h"
13  #include "LexAccessor.h"
14  #include "Accessor.h"
15  #include "StyleContext.h"
16  #include "CharacterSet.h"
17  #include "LexerModule.h"
18  using namespace Lexilla;
19  static void GetRangeLowered(Sci_PositionU start,
20  		Sci_PositionU end,
21  		Accessor &styler,
22  		char *s,
23  		Sci_PositionU len) {
24  	Sci_PositionU i = 0;
25  	while ((i < end - start + 1) && (i < len-1)) {
26  		s[i] = static_cast<char>(tolower(styler[start + i]));
27  		i++;
28  	}
29  	s[i] = '\0';
30  }
31  static void GetForwardRangeLowered(Sci_PositionU start,
32  		CharacterSet &charSet,
33  		Accessor &styler,
34  		char *s,
35  		Sci_PositionU len) {
36  	Sci_PositionU i = 0;
37  	while ((i < len-1) && charSet.Contains(styler.SafeGetCharAt(start + i))) {
38  		s[i] = static_cast<char>(tolower(styler.SafeGetCharAt(start + i)));
39  		i++;
40  	}
41  	s[i] = '\0';
42  }
43  enum {
44  	stateInAsm = 0x1000,
45  	stateInProperty = 0x2000,
46  	stateInExport = 0x4000,
47  	stateFoldInPreprocessor = 0x0100,
48  	stateFoldInRecord = 0x0200,
49  	stateFoldInPreprocessorLevelMask = 0x00FF,
50  	stateFoldMaskAll = 0x0FFF
51  };
52  static void ClassifyPascalWord(WordList *keywordlists[], StyleContext &sc, int &curLineState, bool bSmartHighlighting) {
53  	WordList& keywords = *keywordlists[0];
54  	char s[100];
55  	sc.GetCurrentLowered(s, sizeof(s));
56  	if (keywords.InList(s)) {
57  		if (curLineState & stateInAsm) {
58  			if (strcmp(s, "end") == 0 && sc.GetRelative(-4) != '@') {
59  				curLineState &= ~stateInAsm;
60  				sc.ChangeState(SCE_PAS_WORD);
61  			} else {
62  				sc.ChangeState(SCE_PAS_ASM);
63  			}
64  		} else {
65  			bool ignoreKeyword = false;
66  			if (strcmp(s, "asm") == 0) {
67  				curLineState |= stateInAsm;
68  			} else if (bSmartHighlighting) {
69  				if (strcmp(s, "property") == 0) {
70  					curLineState |= stateInProperty;
71  				} else if (strcmp(s, "exports") == 0) {
72  					curLineState |= stateInExport;
73  				} else if (!(curLineState & (stateInProperty | stateInExport)) && strcmp(s, "index") == 0) {
74  					ignoreKeyword = true;
75  				} else if (!(curLineState & stateInExport) && strcmp(s, "name") == 0) {
76  					ignoreKeyword = true;
77  				} else if (!(curLineState & stateInProperty) &&
78  					(strcmp(s, "read") == 0 || strcmp(s, "write") == 0 ||
79  					 strcmp(s, "default") == 0 || strcmp(s, "nodefault") == 0 ||
80  					 strcmp(s, "stored") == 0 || strcmp(s, "implements") == 0 ||
81  					 strcmp(s, "readonly") == 0 || strcmp(s, "writeonly") == 0 ||
82  					 strcmp(s, "add") == 0 || strcmp(s, "remove") == 0)) {
83  					ignoreKeyword = true;
84  				}
85  			}
86  			if (!ignoreKeyword) {
87  				sc.ChangeState(SCE_PAS_WORD);
88  			}
89  		}
90  	} else if (curLineState & stateInAsm) {
91  		sc.ChangeState(SCE_PAS_ASM);
92  	}
93  	sc.SetState(SCE_PAS_DEFAULT);
94  }
95  static void ColourisePascalDoc(Sci_PositionU startPos, Sci_Position length, int initStyle, WordList *keywordlists[],
96  		Accessor &styler) {
97  	bool bSmartHighlighting = styler.GetPropertyInt("lexer.pascal.smart.highlighting", 1) != 0;
98  	CharacterSet setWordStart(CharacterSet::setAlpha, "_", 0x80, true);
99  	CharacterSet setWord(CharacterSet::setAlphaNum, "_", 0x80, true);
100  	CharacterSet setNumber(CharacterSet::setDigits, ".-+eE");
101  	CharacterSet setHexNumber(CharacterSet::setDigits, "abcdefABCDEF");
102  	CharacterSet setOperator(CharacterSet::setNone, "#$&'()*+,-./:;<=>@[]^{}");
103  	Sci_Position curLine = styler.GetLine(startPos);
104  	int curLineState = curLine > 0 ? styler.GetLineState(curLine - 1) : 0;
105  	StyleContext sc(startPos, length, initStyle, styler);
106  	for (; sc.More(); sc.Forward()) {
107  		if (sc.atLineEnd) {
108  			curLine = styler.GetLine(sc.currentPos);
109  			styler.SetLineState(curLine, curLineState);
110  		}
111  		switch (sc.state) {
112  			case SCE_PAS_NUMBER:
113  				if (!setNumber.Contains(sc.ch) || (sc.ch == '.' && sc.chNext == '.')) {
114  					sc.SetState(SCE_PAS_DEFAULT);
115  				} else if (sc.ch == '-' || sc.ch == '+') {
116  					if (sc.chPrev != 'E' && sc.chPrev != 'e') {
117  						sc.SetState(SCE_PAS_DEFAULT);
118  					}
119  				}
120  				break;
121  			case SCE_PAS_IDENTIFIER:
122  				if (!setWord.Contains(sc.ch)) {
123  					ClassifyPascalWord(keywordlists, sc, curLineState, bSmartHighlighting);
124  				}
125  				break;
126  			case SCE_PAS_HEXNUMBER:
127  				if (!setHexNumber.Contains(sc.ch)) {
128  					sc.SetState(SCE_PAS_DEFAULT);
129  				}
130  				break;
131  			case SCE_PAS_COMMENT:
132  			case SCE_PAS_PREPROCESSOR:
133  				if (sc.ch == '}') {
134  					sc.ForwardSetState(SCE_PAS_DEFAULT);
135  				}
136  				break;
137  			case SCE_PAS_COMMENT2:
138  			case SCE_PAS_PREPROCESSOR2:
139  				if (sc.Match('*', ')')) {
140  					sc.Forward();
141  					sc.ForwardSetState(SCE_PAS_DEFAULT);
142  				}
143  				break;
144  			case SCE_PAS_COMMENTLINE:
145  				if (sc.atLineStart) {
146  					sc.SetState(SCE_PAS_DEFAULT);
147  				}
148  				break;
149  			case SCE_PAS_STRING:
150  				if (sc.atLineEnd) {
151  					sc.ChangeState(SCE_PAS_STRINGEOL);
152  				} else if (sc.ch == '\'' && sc.chNext == '\'') {
153  					sc.Forward();
154  				} else if (sc.ch == '\'') {
155  					sc.ForwardSetState(SCE_PAS_DEFAULT);
156  				}
157  				break;
158  			case SCE_PAS_STRINGEOL:
159  				if (sc.atLineStart) {
160  					sc.SetState(SCE_PAS_DEFAULT);
161  				}
162  				break;
163  			case SCE_PAS_CHARACTER:
164  				if (!setHexNumber.Contains(sc.ch) && sc.ch != '$') {
165  					sc.SetState(SCE_PAS_DEFAULT);
166  				}
167  				break;
168  			case SCE_PAS_OPERATOR:
169  				if (bSmartHighlighting && sc.chPrev == ';') {
170  					curLineState &= ~(stateInProperty | stateInExport);
171  				}
172  				sc.SetState(SCE_PAS_DEFAULT);
173  				break;
174  			case SCE_PAS_ASM:
175  				sc.SetState(SCE_PAS_DEFAULT);
176  				break;
177  		}
178  		if (sc.state == SCE_PAS_DEFAULT) {
179  			if (IsADigit(sc.ch) && !(curLineState & stateInAsm)) {
180  				sc.SetState(SCE_PAS_NUMBER);
181  			} else if (setWordStart.Contains(sc.ch)) {
182  				sc.SetState(SCE_PAS_IDENTIFIER);
183  			} else if (sc.ch == '$' && !(curLineState & stateInAsm)) {
184  				sc.SetState(SCE_PAS_HEXNUMBER);
185  			} else if (sc.Match('{', '$')) {
186  				sc.SetState(SCE_PAS_PREPROCESSOR);
187  			} else if (sc.ch == '{') {
188  				sc.SetState(SCE_PAS_COMMENT);
189  			} else if (sc.Match("(*$")) {
190  				sc.SetState(SCE_PAS_PREPROCESSOR2);
191  			} else if (sc.Match('(', '*')) {
192  				sc.SetState(SCE_PAS_COMMENT2);
193  				sc.Forward();	
194  			} else if (sc.Match('/', '/')) {
195  				sc.SetState(SCE_PAS_COMMENTLINE);
196  			} else if (sc.ch == '\'') {
197  				sc.SetState(SCE_PAS_STRING);
198  			} else if (sc.ch == '#') {
199  				sc.SetState(SCE_PAS_CHARACTER);
200  			} else if (setOperator.Contains(sc.ch) && !(curLineState & stateInAsm)) {
201  				sc.SetState(SCE_PAS_OPERATOR);
202  			} else if (curLineState & stateInAsm) {
203  				sc.SetState(SCE_PAS_ASM);
204  			}
205  		}
206  	}
207  	if (sc.state == SCE_PAS_IDENTIFIER && setWord.Contains(sc.chPrev)) {
208  		ClassifyPascalWord(keywordlists, sc, curLineState, bSmartHighlighting);
209  	}
210  	sc.Complete();
211  }
212  static bool IsStreamCommentStyle(int style) {
213  	return style == SCE_PAS_COMMENT || style == SCE_PAS_COMMENT2;
214  }
215  static bool IsCommentLine(Sci_Position line, Accessor &styler) {
216  	Sci_Position pos = styler.LineStart(line);
217  	Sci_Position eolPos = styler.LineStart(line + 1) - 1;
218  	for (Sci_Position i = pos; i < eolPos; i++) {
219  		char ch = styler[i];
220  		char chNext = styler.SafeGetCharAt(i + 1);
221  		int style = styler.StyleAt(i);
222  		if (ch == '/' && chNext == '/' && style == SCE_PAS_COMMENTLINE) {
223  			return true;
224  		} else if (!IsASpaceOrTab(ch)) {
225  			return false;
226  		}
227  	}
228  	return false;
229  }
230  static unsigned int GetFoldInPreprocessorLevelFlag(int lineFoldStateCurrent) {
231  	return lineFoldStateCurrent & stateFoldInPreprocessorLevelMask;
232  }
233  static void SetFoldInPreprocessorLevelFlag(int &lineFoldStateCurrent, unsigned int nestLevel) {
234  	lineFoldStateCurrent &= ~stateFoldInPreprocessorLevelMask;
235  	lineFoldStateCurrent |= nestLevel & stateFoldInPreprocessorLevelMask;
236  }
237  static void ClassifyPascalPreprocessorFoldPoint(int &levelCurrent, int &lineFoldStateCurrent,
238  		Sci_PositionU startPos, Accessor &styler) {
239  	CharacterSet setWord(CharacterSet::setAlpha);
240  	char s[11];	
241  	GetForwardRangeLowered(startPos, setWord, styler, s, sizeof(s));
242  	unsigned int nestLevel = GetFoldInPreprocessorLevelFlag(lineFoldStateCurrent);
243  	if (strcmp(s, "if") == 0 ||
244  		strcmp(s, "ifdef") == 0 ||
245  		strcmp(s, "ifndef") == 0 ||
246  		strcmp(s, "ifopt") == 0 ||
247  		strcmp(s, "region") == 0) {
248  		nestLevel++;
<span onclick='openModal()' class='match'>249  		SetFoldInPreprocessorLevelFlag(lineFoldStateCurrent, nestLevel);
250  		lineFoldStateCurrent |= stateFoldInPreprocessor;
251  		levelCurrent++;
252  	} else if (strcmp(s, "endif") == 0 ||
</span>253  		strcmp(s, "ifend") == 0 ||
254  		strcmp(s, "endregion") == 0) {
255  		nestLevel--;
256  		SetFoldInPreprocessorLevelFlag(lineFoldStateCurrent, nestLevel);
257  		if (nestLevel == 0) {
258  			lineFoldStateCurrent &= ~stateFoldInPreprocessor;
259  		}
260  		levelCurrent--;
261  		if (levelCurrent < SC_FOLDLEVELBASE) {
262  			levelCurrent = SC_FOLDLEVELBASE;
263  		}
264  	}
265  }
266  static Sci_PositionU SkipWhiteSpace(Sci_PositionU currentPos, Sci_PositionU endPos,
267  		Accessor &styler, bool includeChars = false) {
268  	CharacterSet setWord(CharacterSet::setAlphaNum, "_");
269  	Sci_PositionU j = currentPos + 1;
270  	char ch = styler.SafeGetCharAt(j);
271  	while ((j < endPos) && (IsASpaceOrTab(ch) || ch == '\r' || ch == '\n' ||
272  		IsStreamCommentStyle(styler.StyleAt(j)) || (includeChars && setWord.Contains(ch)))) {
273  		j++;
274  		ch = styler.SafeGetCharAt(j);
275  	}
276  	return j;
277  }
278  static void ClassifyPascalWordFoldPoint(int &levelCurrent, int &lineFoldStateCurrent,
279  		Sci_Position startPos, Sci_PositionU endPos,
280  		Sci_PositionU lastStart, Sci_PositionU currentPos, Accessor &styler) {
281  	char s[100];
282  	GetRangeLowered(lastStart, currentPos, styler, s, sizeof(s));
283  	if (strcmp(s, "record") == 0) {
284  		lineFoldStateCurrent |= stateFoldInRecord;
285  		levelCurrent++;
286  	} else if (strcmp(s, "begin") == 0 ||
287  		strcmp(s, "asm") == 0 ||
288  		strcmp(s, "try") == 0 ||
289  		(strcmp(s, "case") == 0 && !(lineFoldStateCurrent & stateFoldInRecord))) {
290  		levelCurrent++;
291  	} else if (strcmp(s, "class") == 0 || strcmp(s, "object") == 0) {
292  		bool ignoreKeyword = false;
293  		Sci_PositionU j = SkipWhiteSpace(currentPos, endPos, styler);
294  		if (j < endPos) {
295  			CharacterSet setWordStart(CharacterSet::setAlpha, "_");
296  			CharacterSet setWord(CharacterSet::setAlphaNum, "_");
297  			if (styler.SafeGetCharAt(j) == ';') {
298  				ignoreKeyword = true;
299  			} else if (strcmp(s, "class") == 0) {
300  				if (styler.SafeGetCharAt(j) == '(') {
301  					j = SkipWhiteSpace(j, endPos, styler, true);
302  					if (j < endPos && styler.SafeGetCharAt(j) == ')') {
303  						j = SkipWhiteSpace(j, endPos, styler);
304  						if (j < endPos && styler.SafeGetCharAt(j) == ';') {
305  							ignoreKeyword = true;
306  						}
307  					}
308  				} else if (setWordStart.Contains(styler.SafeGetCharAt(j))) {
309  					char s2[11];	
310  					GetForwardRangeLowered(j, setWord, styler, s2, sizeof(s2));
311  					if (strcmp(s2, "procedure") == 0 ||
312  						strcmp(s2, "function") == 0 ||
313  						strcmp(s2, "of") == 0 ||
314  						strcmp(s2, "var") == 0 ||
315  						strcmp(s2, "property") == 0 ||
316  						strcmp(s2, "operator") == 0) {
317  						ignoreKeyword = true;
318  					}
319  				}
320  			}
321  		}
322  		if (!ignoreKeyword) {
323  			levelCurrent++;
324  		}
325  	} else if (strcmp(s, "interface") == 0) {
326  		bool ignoreKeyword = true;
327  		Sci_Position j = lastStart - 1;
328  		char ch = styler.SafeGetCharAt(j);
329  		while ((j >= startPos) && (IsASpaceOrTab(ch) || ch == '\r' || ch == '\n' ||
330  			IsStreamCommentStyle(styler.StyleAt(j)))) {
331  			j--;
332  			ch = styler.SafeGetCharAt(j);
333  		}
334  		if (j >= startPos && styler.SafeGetCharAt(j) == '=') {
335  			ignoreKeyword = false;
336  		}
337  		if (!ignoreKeyword) {
338  			Sci_PositionU k = SkipWhiteSpace(currentPos, endPos, styler);
339  			if (k < endPos && styler.SafeGetCharAt(k) == ';') {
340  				ignoreKeyword = true;
341  			}
342  		}
343  		if (!ignoreKeyword) {
344  			levelCurrent++;
345  		}
346  	} else if (strcmp(s, "dispinterface") == 0) {
347  		bool ignoreKeyword = false;
348  		Sci_PositionU j = SkipWhiteSpace(currentPos, endPos, styler);
349  		if (j < endPos && styler.SafeGetCharAt(j) == ';') {
350  			ignoreKeyword = true;
351  		}
352  		if (!ignoreKeyword) {
353  			levelCurrent++;
354  		}
355  	} else if (strcmp(s, "end") == 0) {
356  		lineFoldStateCurrent &= ~stateFoldInRecord;
357  		levelCurrent--;
358  		if (levelCurrent < SC_FOLDLEVELBASE) {
359  			levelCurrent = SC_FOLDLEVELBASE;
360  		}
361  	}
362  }
363  static void FoldPascalDoc(Sci_PositionU startPos, Sci_Position length, int initStyle, WordList *[],
364  		Accessor &styler) {
365  	bool foldComment = styler.GetPropertyInt("fold.comment") != 0;
366  	bool foldPreprocessor = styler.GetPropertyInt("fold.preprocessor") != 0;
367  	bool foldCompact = styler.GetPropertyInt("fold.compact", 1) != 0;
368  	Sci_PositionU endPos = startPos + length;
369  	int visibleChars = 0;
370  	Sci_Position lineCurrent = styler.GetLine(startPos);
371  	int levelPrev = styler.LevelAt(lineCurrent) & SC_FOLDLEVELNUMBERMASK;
372  	int levelCurrent = levelPrev;
373  	int lineFoldStateCurrent = lineCurrent > 0 ? styler.GetLineState(lineCurrent - 1) & stateFoldMaskAll : 0;
374  	char chNext = styler[startPos];
375  	int styleNext = styler.StyleAt(startPos);
376  	int style = initStyle;
377  	Sci_Position lastStart = 0;
378  	CharacterSet setWord(CharacterSet::setAlphaNum, "_", 0x80, true);
379  	for (Sci_PositionU i = startPos; i < endPos; i++) {
380  		char ch = chNext;
381  		chNext = styler.SafeGetCharAt(i + 1);
382  		int stylePrev = style;
383  		style = styleNext;
384  		styleNext = styler.StyleAt(i + 1);
385  		bool atEOL = (ch == '\r' && chNext != '\n') || (ch == '\n');
386  		if (foldComment && IsStreamCommentStyle(style)) {
387  			if (!IsStreamCommentStyle(stylePrev)) {
388  				levelCurrent++;
389  			} else if (!IsStreamCommentStyle(styleNext) && !atEOL) {
390  				levelCurrent--;
391  			}
392  		}
393  		if (foldComment && atEOL && IsCommentLine(lineCurrent, styler))
394  		{
395  			if (!IsCommentLine(lineCurrent - 1, styler)
396  			    && IsCommentLine(lineCurrent + 1, styler))
397  				levelCurrent++;
398  			else if (IsCommentLine(lineCurrent - 1, styler)
399  			         && !IsCommentLine(lineCurrent+1, styler))
400  				levelCurrent--;
401  		}
402  		if (foldPreprocessor) {
403  			if (style == SCE_PAS_PREPROCESSOR && ch == '{' && chNext == '$') {
404  				ClassifyPascalPreprocessorFoldPoint(levelCurrent, lineFoldStateCurrent, i + 2, styler);
405  			} else if (style == SCE_PAS_PREPROCESSOR2 && ch == '(' && chNext == '*'
406  			           && styler.SafeGetCharAt(i + 2) == '$') {
407  				ClassifyPascalPreprocessorFoldPoint(levelCurrent, lineFoldStateCurrent, i + 3, styler);
408  			}
409  		}
410  		if (stylePrev != SCE_PAS_WORD && style == SCE_PAS_WORD)
411  		{
412  			lastStart = i;
413  		}
414  		if (stylePrev == SCE_PAS_WORD && !(lineFoldStateCurrent & stateFoldInPreprocessor)) {
415  			if(setWord.Contains(ch) && !setWord.Contains(chNext)) {
416  				ClassifyPascalWordFoldPoint(levelCurrent, lineFoldStateCurrent, startPos, endPos, lastStart, i, styler);
417  			}
418  		}
419  		if (!IsASpace(ch))
420  			visibleChars++;
421  		if (atEOL) {
422  			int lev = levelPrev;
423  			if (visibleChars == 0 && foldCompact)
424  				lev |= SC_FOLDLEVELWHITEFLAG;
425  			if ((levelCurrent > levelPrev) && (visibleChars > 0))
426  				lev |= SC_FOLDLEVELHEADERFLAG;
427  			if (lev != styler.LevelAt(lineCurrent)) {
428  				styler.SetLevel(lineCurrent, lev);
429  			}
430  			int newLineState = (styler.GetLineState(lineCurrent) & ~stateFoldMaskAll) | lineFoldStateCurrent;
431  			styler.SetLineState(lineCurrent, newLineState);
432  			lineCurrent++;
433  			levelPrev = levelCurrent;
434  			visibleChars = 0;
435  		}
436  	}
437  	int lev = levelPrev;
438  	if (visibleChars == 0 && foldCompact)
439  		lev |= SC_FOLDLEVELWHITEFLAG;
440  	styler.SetLevel(lineCurrent, lev);
441  }
442  static const char * const pascalWordListDesc[] = {
443  	"Keywords",
444  	0
445  };
446  LexerModule lmPascal(SCLEX_PASCAL, ColourisePascalDoc, "pascal", FoldPascalDoc, pascalWordListDesc);
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexDataflex.cxx</h3>
            <pre><code>1  #include <stdlib.h>
2  #include <string.h>
3  #include <stdio.h>
4  #include <stdarg.h>
5  #include <assert.h>
6  #include <ctype.h>
7  #include <string>
8  #include <string_view>
9  #include "ILexer.h"
10  #include "Scintilla.h"
11  #include "SciLexer.h"
12  #include "WordList.h"
13  #include "LexAccessor.h"
14  #include "Accessor.h"
15  #include "StyleContext.h"
16  #include "CharacterSet.h"
17  #include "LexerModule.h"
18  using namespace Lexilla;
19  static void GetRangeLowered(Sci_PositionU start,
20  		Sci_PositionU end,
21  		Accessor &styler,
22  		char *s,
23  		Sci_PositionU len) {
24  	Sci_PositionU i = 0;
25  	while ((i < end - start + 1) && (i < len-1)) {
26  		s[i] = static_cast<char>(tolower(styler[start + i]));
27  		i++;
28  	}
29  	s[i] = '\0';
30  }
31  static void GetForwardRangeLowered(Sci_PositionU start,
32  		CharacterSet &charSet,
33  		Accessor &styler,
34  		char *s,
35  		Sci_PositionU len) {
36  	Sci_PositionU i = 0;
37  	while ((i < len-1) && charSet.Contains(styler.SafeGetCharAt(start + i))) {
38  		s[i] = static_cast<char>(tolower(styler.SafeGetCharAt(start + i)));
39  		i++;
40  	}
41  	s[i] = '\0';
42  }
43  enum {
44  	stateInICode = 0x1000,
45  	stateSingleQuoteOpen = 0x2000,
46  	stateDoubleQuoteOpen = 0x4000,
47  	stateFoldInPreprocessor = 0x0100,
48  	stateFoldInCaseStatement = 0x0200,
49  	stateFoldInPreprocessorLevelMask = 0x00FF,
50  	stateFoldMaskAll = 0x0FFF
51  };
52  static bool IsFirstDataFlexWord(Sci_Position pos, Accessor &styler) {
53  	Sci_Position line = styler.GetLine(pos);
54  	Sci_Position start_pos = styler.LineStart(line);
55  	for (Sci_Position i = start_pos; i < pos; i++) {
56  		char ch = styler.SafeGetCharAt(i);
57  		if (!(ch == ' ' || ch == '\t'))
58  			return false;
59  	}
60  	return true;
61  }
62  inline bool IsADataFlexField(int ch) {
63  	return (ch == '.');
64  }
65  static void ClassifyDataFlexWord(WordList *keywordlists[], StyleContext &sc, Accessor &styler) {
66  	WordList& keywords = *keywordlists[0];
67  	WordList& scopeOpen   = *keywordlists[1];
68  	WordList& scopeClosed = *keywordlists[2];
69  	WordList& operators   = *keywordlists[3];
70  	char s[100];
71  	int oldState;
72  	int newState;
73  	size_t tokenlen;
74      oldState = sc.state;
75  	newState = oldState;
76  	sc.GetCurrentLowered(s, sizeof(s));
77  	tokenlen = strnlen(s,sizeof(s));
78  	if (keywords.InList(s)) {
79          if (!IsADataFlexField(sc.GetRelative(-static_cast<int>(tokenlen+1)))) {
80  	      newState = SCE_DF_WORD;
81  	    }
82  	}
83  	if (oldState == newState) {
84  		if ((scopeOpen.InList(s) || scopeClosed.InList(s)) && (strcmp(s, "for") != 0) && (strcmp(s, "repeat") != 0)) {
85  			if (!IsADataFlexField(sc.GetRelative(-static_cast<int>(tokenlen+1)))) {
86  				newState = SCE_DF_SCOPEWORD;
87  			}
88  		} 
89  		if (strcmp(s, "if") == 0 ||  
90  			strcmp(s, "ifnot") == 0 ||
91  			strcmp(s, "case") == 0 ||
92  			strcmp(s, "else") == 0 ) {
93  				newState = SCE_DF_SCOPEWORD;
94  		} 
95  	}
96  	if (oldState != newState && newState == SCE_DF_WORD) {
97  		if ( (strcmp(s, "for") == 0) && (IsFirstDataFlexWord(sc.currentPos-3, styler)) ) {   
98  				newState = SCE_DF_SCOPEWORD;
99  		} 
100  	}
101  	if (oldState != newState && newState == SCE_DF_WORD) {
102  		if ( (strcmp(s, "repeat") == 0) && (IsFirstDataFlexWord(sc.currentPos-6, styler)) ) {   
103  				newState = SCE_DF_SCOPEWORD;
104  		} 
105  	}
106  	if (oldState == newState)  {
107  	  if (operators.InList(s)) {
108  		  newState = SCE_DF_OPERATOR;
109  		} 
110  	}
111  	if (oldState != newState) {
112  		sc.ChangeState(newState);
113  	}
114  	sc.SetState(SCE_DF_DEFAULT);
115  }
116  static void ColouriseDataFlexDoc(Sci_PositionU startPos, Sci_Position length, int initStyle, WordList *keywordlists[],
117  		Accessor &styler) {
118  			CharacterSet setWordStart(CharacterSet::setAlpha, "_$#@", 0x80, true);
119  			CharacterSet setWord(CharacterSet::setAlphaNum, "_$#@", 0x80, true);
120  	CharacterSet setNumber(CharacterSet::setDigits, ".-+eE");
121  	CharacterSet setHexNumber(CharacterSet::setDigits, "abcdefABCDEF");
122  	CharacterSet setOperator(CharacterSet::setNone, "*+-/<=>^");
123  	Sci_Position curLine = styler.GetLine(startPos);
124  	int curLineState = curLine > 0 ? styler.GetLineState(curLine - 1) : 0;
125  	StyleContext sc(startPos, length, initStyle, styler);
126  	for (; sc.More(); sc.Forward()) {
127  		if (sc.atLineEnd) {
128  			curLine = styler.GetLine(sc.currentPos);
129  			styler.SetLineState(curLine, curLineState);
130  		}
131  		switch (sc.state) {
132  			case SCE_DF_NUMBER:
133  				if (!setNumber.Contains(sc.ch) || (sc.ch == '.' && sc.chNext == '.')) {
134  					sc.SetState(SCE_DF_DEFAULT);
135  				} else if (sc.ch == '-' || sc.ch == '+') {
136  					if (sc.chPrev != 'E' && sc.chPrev != 'e') {
137  						sc.SetState(SCE_DF_DEFAULT);
138  					}
139  				}
140  				break;
141  			case SCE_DF_IDENTIFIER:
142  				if (!setWord.Contains(sc.ch)) {
143  					ClassifyDataFlexWord(keywordlists, sc, styler);
144  				}
145  				break;
146  			case SCE_DF_HEXNUMBER:
147  				if (!(setHexNumber.Contains(sc.ch) || sc.ch == 'I') ) { 
148  					sc.SetState(SCE_DF_DEFAULT);
149  				}
150  				break;
151  			case SCE_DF_METATAG:
152  				if (sc.atLineStart || sc.chPrev == '}') {
153  					sc.SetState(SCE_DF_DEFAULT);
154  				}
155  				break;
156  			case SCE_DF_PREPROCESSOR:
157  				if (sc.atLineStart || IsASpaceOrTab(sc.ch)) {
158  					sc.SetState(SCE_DF_DEFAULT);
159  				}
160  				break;
161  			case SCE_DF_IMAGE:
162  				if (sc.atLineStart && sc.Match("&bsol;*")) {
163  					sc.Forward();  
164  					sc.ForwardSetState(SCE_DF_DEFAULT);
165  				}
166  				break;
167  			case SCE_DF_PREPROCESSOR2:
168  				break;
169  			case SCE_DF_COMMENTLINE:
170  				if (sc.atLineStart) {
171  					sc.SetState(SCE_DF_DEFAULT);
172  				}
173  				break;
174  			case SCE_DF_STRING:
175  				if (sc.atLineEnd) {
176  					sc.ChangeState(SCE_DF_STRINGEOL);
177  				} else if (sc.ch == '\'' && sc.chNext == '\'') {
178  					sc.Forward();
179  				} else if (sc.ch == '\"' && sc.chNext == '\"') {
180  					sc.Forward();
181  				} else if (sc.ch == '\'' || sc.ch == '\"') {
182  					if (sc.ch == '\'' && (curLineState & stateSingleQuoteOpen) ) {
183   				    curLineState &= ~(stateSingleQuoteOpen);
184  					sc.ForwardSetState(SCE_DF_DEFAULT);
185  					}
186  					else if (sc.ch == '\"' && (curLineState & stateDoubleQuoteOpen) ) {
187   				    curLineState &= ~(stateDoubleQuoteOpen);
188  					sc.ForwardSetState(SCE_DF_DEFAULT);
189  					}
190  				}
191  				break;
192  			case SCE_DF_STRINGEOL:
193  				if (sc.atLineStart) {
194  					sc.SetState(SCE_DF_DEFAULT);
195  				}
196  				break;
197  			case SCE_DF_SCOPEWORD:
198  				break;
199  			case SCE_DF_OPERATOR:
200  				sc.SetState(SCE_DF_DEFAULT);
201  				break;
202  			case SCE_DF_ICODE:
203  				if (sc.atLineStart || IsASpace(sc.ch) || isoperator(sc.ch)) {
204  				sc.SetState(SCE_DF_DEFAULT);
205  				}
206  				break;
207  		}
208  		if (sc.state == SCE_DF_DEFAULT) {
209  			if (IsADigit(sc.ch)) {
210  				sc.SetState(SCE_DF_NUMBER);
211  			} else if (sc.Match('/', '/') || sc.Match("#REM")) {
212  				sc.SetState(SCE_DF_COMMENTLINE);
213  			} else if ((sc.ch == '#' && !sc.Match("#REM")) && IsFirstDataFlexWord(sc.currentPos, styler)) {
214  				sc.SetState(SCE_DF_PREPROCESSOR);
215  			} else if ((sc.ch == '$' && ((!setWord.Contains(sc.chPrev)) || sc.chPrev == 'I' ) ) || (sc.Match("|CI$")) ) {
216  				sc.SetState(SCE_DF_HEXNUMBER); 
217  			} else if (setWordStart.Contains(sc.ch)) {
218  				sc.SetState(SCE_DF_IDENTIFIER);
219  			} else if (sc.ch == '{') {
220  				sc.SetState(SCE_DF_METATAG);
221  			} else if (sc.ch == '/' && setWord.Contains(sc.chNext) &&  sc.atLineStart) {
222  				sc.SetState(SCE_DF_IMAGE);
223  			} else if (sc.ch == '\'' || sc.ch == '\"') {
224  				if (sc.ch == '\'' && !(curLineState & stateDoubleQuoteOpen)) {
225  				  curLineState |= stateSingleQuoteOpen;
226  				} else if (sc.ch == '\"' && !(curLineState & stateSingleQuoteOpen)) {
227  				  curLineState |= stateDoubleQuoteOpen;
228  				}
229  			    sc.SetState(SCE_DF_STRING);
230  			} else if (setOperator.Contains(sc.ch)) {
231  				sc.SetState(SCE_DF_OPERATOR);
232  			} else if ((sc.ch == '!') && !(sc.ch == '!' && ((sc.chNext == '\"') || (sc.ch == '\'')) )) {
233  				sc.SetState(SCE_DF_ICODE);
234  			}
235  		}
236  	}
237  	if (sc.state == SCE_DF_IDENTIFIER && setWord.Contains(sc.chPrev)) {
238  		ClassifyDataFlexWord(keywordlists, sc, styler);
239  	}
240  	sc.Complete();
241  }
242  static bool IsStreamCommentStyle(int style) {
243  	return style == SCE_DF_IMAGE;
244  }
245  static bool IsCommentLine(Sci_Position line, Accessor &styler) {
246  	Sci_Position pos = styler.LineStart(line);
247  	Sci_Position eolPos = styler.LineStart(line + 1) - 1;
248  	for (Sci_Position i = pos; i < eolPos; i++) {
249  		char ch = styler[i];
250  		char chNext = styler.SafeGetCharAt(i + 1);
251  		int style = styler.StyleAt(i);
252  		if (ch == '/' && chNext == '/' && style == SCE_DF_COMMENTLINE) {
253  			return true;
254  		} else if (!IsASpaceOrTab(ch)) {
255  			return false;
256  		}
257  	}
258  	return false;
259  }
260  static unsigned int GetFoldInPreprocessorLevelFlag(int lineFoldStateCurrent) {
261  	return lineFoldStateCurrent & stateFoldInPreprocessorLevelMask;
262  }
263  static void SetFoldInPreprocessorLevelFlag(int &lineFoldStateCurrent, unsigned int nestLevel) {
264  	lineFoldStateCurrent &= ~stateFoldInPreprocessorLevelMask;
265  	lineFoldStateCurrent |= nestLevel & stateFoldInPreprocessorLevelMask;
266  }
267  static int ClassifyDataFlexPreprocessorFoldPoint(int &levelCurrent, int &lineFoldStateCurrent,
268  		Sci_PositionU startPos, Accessor &styler) {
269  	CharacterSet setWord(CharacterSet::setAlpha);
270  	char s[100];	
271  	GetForwardRangeLowered(startPos, setWord, styler, s, sizeof(s));
272  	size_t iLen = strnlen(s,sizeof(s));
273  	size_t iWordSize = 0;
274  	unsigned int nestLevel = GetFoldInPreprocessorLevelFlag(lineFoldStateCurrent);
275  	if (strcmp(s, "command") == 0 ||
276  		strcmp(s, "header") == 0) {
277  		nestLevel++;
<span onclick='openModal()' class='match'>278  		SetFoldInPreprocessorLevelFlag(lineFoldStateCurrent, nestLevel);
279  		lineFoldStateCurrent |= stateFoldInPreprocessor;
280  		levelCurrent++;
281  		iWordSize = iLen;
</span>282  	} else if (strcmp(s, "endcommand") == 0 ||
283  		strcmp(s, "endheader") == 0) {
284  		nestLevel--;
285  		SetFoldInPreprocessorLevelFlag(lineFoldStateCurrent, nestLevel);
286  		if (nestLevel == 0) {
287  			lineFoldStateCurrent &= ~stateFoldInPreprocessor;
288  		}
289  		levelCurrent--;
290  		iWordSize = iLen;
291  		if (levelCurrent < SC_FOLDLEVELBASE) {
292  			levelCurrent = SC_FOLDLEVELBASE;
293  		}
294  	}
295  	return static_cast<int>(iWordSize);
296  }
297  static void ClassifyDataFlexWordFoldPoint(int &levelCurrent, int &lineFoldStateCurrent,
298  		Sci_PositionU lastStart, Sci_PositionU currentPos, WordList *[], Accessor &styler) {
299  	char s[100];
300  	bool foldPRN = styler.GetPropertyInt("fold.dataflex.compilerlist",0) != 0;
301  	GetRangeLowered(lastStart, currentPos, styler, s, sizeof(s));
302  	if (strcmp(s, "case") == 0) {
303  		lineFoldStateCurrent |= stateFoldInCaseStatement;
304  	} else if (strcmp(s, "begin") == 0) {
305  		levelCurrent++;
306  	} else if (strcmp(s, "for") == 0 ||
307  		strcmp(s, "while") == 0 ||
308  		strcmp(s, "repeat") == 0 ||
309  		strcmp(s, "for_all") == 0 ||
310  		strcmp(s, "struct") == 0 ||
311  		strcmp(s, "type") == 0 ||
312  		strcmp(s, "begin_row") == 0 ||
313  		strcmp(s, "item_list") == 0 ||
314  		strcmp(s, "begin_constraints") == 0 ||
315  		strcmp(s, "begin_transaction") == 0 ||
316  		strcmp(s, "enum_list") == 0 ||
317  		strcmp(s, "class") == 0 || 
318  		strcmp(s, "object") == 0 ||
319  		strcmp(s, "cd_popup_object") == 0 ||
320  		strcmp(s, "procedure") == 0 ||
321  		strcmp(s, "procedure_section") == 0 ||
322  		strcmp(s, "function") == 0 ) {
323  			if ((IsFirstDataFlexWord(lastStart, styler )) || foldPRN) {
324  			levelCurrent++;
325  			}
326  	} else if (strcmp(s, "end") == 0) {  
327  		levelCurrent--;
328  		if (levelCurrent < SC_FOLDLEVELBASE) {
329  			levelCurrent = SC_FOLDLEVELBASE;
330  		}
331  	} else if (strcmp(s, "loop") == 0 ||
332  				   strcmp(s, "until") == 0 ||
333  				   strcmp(s, "end_class") == 0 ||
334  				   strcmp(s, "end_object") == 0 ||
335  				   strcmp(s, "cd_end_object") == 0 ||
336  				   strcmp(s, "end_procedure") == 0 ||
337  				   strcmp(s, "end_function") == 0 ||
338  				   strcmp(s, "end_for_all") == 0 ||
339  				   strcmp(s, "end_struct") == 0 ||
340  				   strcmp(s, "end_type") == 0 ||
341  				   strcmp(s, "end_row") == 0 ||
342  				   strcmp(s, "end_item_list") == 0 ||
343  				   strcmp(s, "end_constraints") == 0 ||
344  				   strcmp(s, "end_transaction") == 0 ||
345  				   strcmp(s, "end_enum_list") == 0 ) {
346  			if ((IsFirstDataFlexWord(lastStart, styler )) || foldPRN) {
347  				levelCurrent--;
348  				if (levelCurrent < SC_FOLDLEVELBASE) {
349  					levelCurrent = SC_FOLDLEVELBASE;
350  				}
351  			}
352  	}
353  }
354  static void ClassifyDataFlexMetaDataFoldPoint(int &levelCurrent, 
355  		Sci_PositionU lastStart, Sci_PositionU currentPos, WordList *[], Accessor &styler) {
356  	char s[100];
357  	GetRangeLowered(lastStart, currentPos, styler, s, sizeof(s));
358      if (strcmp(s, "#beginsection") == 0) {
359  		levelCurrent++;
360  	} else if (strcmp(s, "#endsection") == 0) {
361  			levelCurrent--;
362  			if (levelCurrent < SC_FOLDLEVELBASE) {
363  				levelCurrent = SC_FOLDLEVELBASE;
364  			}
365  	}
366  }
367  static void FoldDataFlexDoc(Sci_PositionU startPos, Sci_Position length, int initStyle, WordList *keywordlists[],
368  		Accessor &styler) {
369  	bool foldComment = styler.GetPropertyInt("fold.comment") != 0;
370  	bool foldPreprocessor = styler.GetPropertyInt("fold.preprocessor") != 0;
371  	bool foldCompact = styler.GetPropertyInt("fold.compact", 1) != 0;
372  	Sci_PositionU endPos = startPos + length;
373  	int visibleChars = 0;
374  	Sci_Position lineCurrent = styler.GetLine(startPos);
375  	int levelPrev = styler.LevelAt(lineCurrent) & SC_FOLDLEVELNUMBERMASK;
376  	int levelCurrent = levelPrev;
377  	int lineFoldStateCurrent = lineCurrent > 0 ? styler.GetLineState(lineCurrent - 1) & stateFoldMaskAll : 0;
378  	char chNext = styler[startPos];
379  	int styleNext = styler.StyleAt(startPos);
380  	int style = initStyle;
381  	int iWordSize;
382  	Sci_Position lastStart = 0;
383  	CharacterSet setWord(CharacterSet::setAlphaNum, "_$#@", 0x80, true);
384  	for (Sci_PositionU i = startPos; i < endPos; i++) {
385  		char ch = chNext;
386  		chNext = styler.SafeGetCharAt(i + 1);
387  		int stylePrev = style;
388  		style = styleNext;
389  		styleNext = styler.StyleAt(i + 1);
390  		bool atEOL = (ch == '\r' && chNext != '\n') || (ch == '\n');
391  		if (foldComment && IsStreamCommentStyle(style)) {
392  			if (!IsStreamCommentStyle(stylePrev)) {
393  				levelCurrent++;
394  			} else if (!IsStreamCommentStyle(styleNext)) {
395  				levelCurrent--;
396  			}
397  		}
398  		if (foldComment && atEOL && IsCommentLine(lineCurrent, styler))
399  		{
400  			if (!IsCommentLine(lineCurrent - 1, styler)
401  			    && IsCommentLine(lineCurrent + 1, styler))
402  				levelCurrent++;
403  			else if (IsCommentLine(lineCurrent - 1, styler)
404  			         && !IsCommentLine(lineCurrent+1, styler))
405  				levelCurrent--;
406  		}
407  		if (foldPreprocessor) {
408  			if (style == SCE_DF_PREPROCESSOR) {
409  				iWordSize = ClassifyDataFlexPreprocessorFoldPoint(levelCurrent, lineFoldStateCurrent, i + 1, styler);
410  				i = i + iWordSize;
411  			}
412  		}
413  		if (stylePrev != SCE_DF_SCOPEWORD && style == SCE_DF_SCOPEWORD)
414  		{
415  			lastStart = i;
416  		}
417  		if (stylePrev == SCE_DF_SCOPEWORD) {
418  			if(setWord.Contains(ch) && !setWord.Contains(chNext)) {
419  				ClassifyDataFlexWordFoldPoint(levelCurrent, lineFoldStateCurrent, lastStart, i, keywordlists, styler);
420  			}
421  		}
422  		if (stylePrev == SCE_DF_METATAG && ch == '#')
423  		{
424  			lastStart = i;
425  		}
426  		if (stylePrev == SCE_DF_METATAG) {
427  			if(setWord.Contains(ch) && !setWord.Contains(chNext)) {
428  				ClassifyDataFlexMetaDataFoldPoint(levelCurrent, lastStart, i, keywordlists, styler);
429  			}
430  		}
431  		if (!IsASpace(ch))
432  			visibleChars++;
433  		if (atEOL) {
434  			int lev = levelPrev;
435  			if (visibleChars == 0 && foldCompact)
436  				lev |= SC_FOLDLEVELWHITEFLAG;
437  			if ((levelCurrent > levelPrev) && (visibleChars > 0))
438  				lev |= SC_FOLDLEVELHEADERFLAG;
439  			if (lev != styler.LevelAt(lineCurrent)) {
440  				styler.SetLevel(lineCurrent, lev);
441  			}
442  			int newLineState = (styler.GetLineState(lineCurrent) & ~stateFoldMaskAll) | lineFoldStateCurrent;
443  			styler.SetLineState(lineCurrent, newLineState);
444  			lineCurrent++;
445  			levelPrev = levelCurrent;
446  			visibleChars = 0;
447  		}
448  	}
449  	int lev = levelPrev;
450  	if (visibleChars == 0 && foldCompact)
451  		lev |= SC_FOLDLEVELWHITEFLAG;
452  	styler.SetLevel(lineCurrent, lev);
453  }
454  static const char * const dataflexWordListDesc[] = {
455  	"Keywords",
456  	"Scope open",
457  	"Scope close",
458  	"Operators",
459  	0
460  };
461  LexerModule lmDataflex(SCLEX_DATAFLEX, ColouriseDataFlexDoc, "dataflex", FoldDataFlexDoc, dataflexWordListDesc);
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexPascal.cxx</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-LexDataflex.cxx</div>
                </div>
                <div class="column column_space"><pre><code>249  		SetFoldInPreprocessorLevelFlag(lineFoldStateCurrent, nestLevel);
250  		lineFoldStateCurrent |= stateFoldInPreprocessor;
251  		levelCurrent++;
252  	} else if (strcmp(s, "endif") == 0 ||
</pre></code></div>
                <div class="column column_space"><pre><code>278  		SetFoldInPreprocessorLevelFlag(lineFoldStateCurrent, nestLevel);
279  		lineFoldStateCurrent |= stateFoldInPreprocessor;
280  		levelCurrent++;
281  		iWordSize = iLen;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    