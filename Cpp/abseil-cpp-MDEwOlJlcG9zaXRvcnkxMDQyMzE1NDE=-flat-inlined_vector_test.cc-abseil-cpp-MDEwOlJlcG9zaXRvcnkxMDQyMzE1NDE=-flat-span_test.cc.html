
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 24, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-inlined_vector_test.cc</h3>
            <pre><code>1  #include "absl/container/inlined_vector.h"
2  #include <algorithm>
3  #include <cstddef>
4  #include <forward_list>
5  #include <iterator>
6  #include <list>
7  #include <memory>
8  #include <scoped_allocator>
9  #include <sstream>
10  #include <stdexcept>
11  #include <string>
12  #include <utility>
13  #include <vector>
14  #include "gmock/gmock.h"
15  #include "gtest/gtest.h"
16  #include "absl/base/attributes.h"
17  #include "absl/base/internal/exception_testing.h"
18  #include "absl/base/macros.h"
19  #include "absl/base/options.h"
20  #include "absl/container/internal/counting_allocator.h"
21  #include "absl/container/internal/test_instance_tracker.h"
22  #include "absl/hash/hash_testing.h"
23  #include "absl/log/check.h"
24  #include "absl/memory/memory.h"
25  #include "absl/strings/str_cat.h"
26  namespace {
27  using absl::container_internal::CountingAllocator;
28  using absl::test_internal::CopyableMovableInstance;
29  using absl::test_internal::CopyableOnlyInstance;
30  using absl::test_internal::InstanceTracker;
31  using testing::AllOf;
32  using testing::Each;
33  using testing::ElementsAre;
34  using testing::ElementsAreArray;
35  using testing::Eq;
36  using testing::Gt;
37  using testing::Pointee;
38  using testing::Pointwise;
39  using testing::PrintToString;
40  using testing::SizeIs;
41  using IntVec = absl::InlinedVector<int, 8>;
42  MATCHER_P(CapacityIs, n, "") {
43    return testing::ExplainMatchResult(n, arg.capacity(), result_listener);
44  }
45  MATCHER_P(ValueIs, e, "") {
46    return testing::ExplainMatchResult(e, arg.value(), result_listener);
47  }
48  template <typename T>
49  class InstanceTest : public ::testing::Test {};
50  TYPED_TEST_SUITE_P(InstanceTest);
51  class RefCounted {
52   public:
53    RefCounted(int value, int* count) : value_(value), count_(count) { Ref(); }
54    RefCounted(const RefCounted& v) : value_(v.value_), count_(v.count_) {
55      Ref();
56    }
57    ~RefCounted() {
58      Unref();
59      count_ = nullptr;
60    }
61    friend void swap(RefCounted& a, RefCounted& b) {
62      using std::swap;
63      swap(a.value_, b.value_);
64      swap(a.count_, b.count_);
65    }
66    RefCounted& operator=(RefCounted v) {
67      using std::swap;
68      swap(*this, v);
69      return *this;
70    }
71    void Ref() const {
72      CHECK_NE(count_, nullptr);
73      ++(*count_);
74    }
75    void Unref() const {
76      --(*count_);
77      CHECK_GE(*count_, 0);
78    }
79    int value_;
80    int* count_;
81  };
82  using RefCountedVec = absl::InlinedVector<RefCounted, 8>;
83  class Dynamic {
84   public:
85    virtual ~Dynamic() {}
86  };
87  using DynamicVec = absl::InlinedVector<Dynamic, 8>;
88  template <typename Container>
89  static void Fill(Container* v, size_t len, int offset = 0) {
90    for (size_t i = 0; i < len; i++) {
91      v->push_back(static_cast<int>(i) + offset);
92    }
93  }
94  static IntVec Fill(size_t len, int offset = 0) {
95    IntVec v;
96    Fill(&v, len, offset);
97    return v;
98  }
99  TEST(IntVec, SimpleOps) {
100    for (size_t len = 0; len < 20; len++) {
101      IntVec v;
102      const IntVec& cv = v;  
103      Fill(&v, len);
104      EXPECT_EQ(len, v.size());
105      EXPECT_LE(len, v.capacity());
106      for (size_t i = 0; i < len; i++) {
107        EXPECT_EQ(static_cast<int>(i), v[i]);
108        EXPECT_EQ(static_cast<int>(i), v.at(i));
109      }
110      EXPECT_EQ(v.begin(), v.data());
111      EXPECT_EQ(cv.begin(), cv.data());
112      size_t counter = 0;
113      for (IntVec::iterator iter = v.begin(); iter != v.end(); ++iter) {
114        EXPECT_EQ(static_cast<int>(counter), *iter);
115        counter++;
116      }
117      EXPECT_EQ(counter, len);
118      counter = 0;
119      for (IntVec::const_iterator iter = v.begin(); iter != v.end(); ++iter) {
120        EXPECT_EQ(static_cast<int>(counter), *iter);
121        counter++;
122      }
123      EXPECT_EQ(counter, len);
124      counter = 0;
125      for (IntVec::const_iterator iter = v.cbegin(); iter != v.cend(); ++iter) {
126        EXPECT_EQ(static_cast<int>(counter), *iter);
127        counter++;
128      }
129      EXPECT_EQ(counter, len);
130      if (len > 0) {
131        EXPECT_EQ(0, v.front());
132        EXPECT_EQ(static_cast<int>(len - 1), v.back());
133        v.pop_back();
134        EXPECT_EQ(len - 1, v.size());
135        for (size_t i = 0; i < v.size(); ++i) {
136          EXPECT_EQ(static_cast<int>(i), v[i]);
137          EXPECT_EQ(static_cast<int>(i), v.at(i));
138        }
139      }
140    }
141  }
142  TEST(IntVec, PopBackNoOverflow) {
143    IntVec v = {1};
144    v.pop_back();
145    EXPECT_EQ(v.size(), 0u);
146  }
147  TEST(IntVec, AtThrows) {
148    IntVec v = {1, 2, 3};
149    EXPECT_EQ(v.at(2), 3);
<span onclick='openModal()' class='match'>150    ABSL_BASE_INTERNAL_EXPECT_FAIL(v.at(3), std::out_of_range,
151                                   "failed bounds check");
152  }
153  TEST(IntVec, ReverseIterator) {
154    for (size_t len = 0; len < 20; len++) {
</span>155      IntVec v;
156      Fill(&v, len);
157      size_t counter = len;
158      for (IntVec::reverse_iterator iter = v.rbegin(); iter != v.rend(); ++iter) {
159        counter--;
160        EXPECT_EQ(static_cast<int>(counter), *iter);
161      }
162      EXPECT_EQ(counter, 0u);
163      counter = len;
164      for (IntVec::const_reverse_iterator iter = v.rbegin(); iter != v.rend();
165           ++iter) {
166        counter--;
167        EXPECT_EQ(static_cast<int>(counter), *iter);
168      }
169      EXPECT_EQ(counter, 0u);
170      counter = len;
171      for (IntVec::const_reverse_iterator iter = v.crbegin(); iter != v.crend();
172           ++iter) {
173        counter--;
174        EXPECT_EQ(static_cast<int>(counter), *iter);
175      }
176      EXPECT_EQ(counter, 0u);
177    }
178  }
179  TEST(IntVec, Erase) {
180    for (size_t len = 1; len < 20; len++) {
181      for (size_t i = 0; i < len; ++i) {
182        IntVec v;
183        Fill(&v, len);
184        v.erase(v.begin() + i);
185        EXPECT_EQ(len - 1, v.size());
186        for (size_t j = 0; j < i; ++j) {
187          EXPECT_EQ(static_cast<int>(j), v[j]);
188        }
189        for (size_t j = i; j < len - 1; ++j) {
190          EXPECT_EQ(static_cast<int>(j + 1), v[j]);
191        }
192      }
193    }
194  }
195  TEST(IntVec, Hardened) {
196    IntVec v;
197    Fill(&v, 10);
198    EXPECT_EQ(v[9], 9);
199  #if !defined(NDEBUG) || ABSL_OPTION_HARDENED
200    EXPECT_DEATH_IF_SUPPORTED(v[10], "");
201    EXPECT_DEATH_IF_SUPPORTED(v[static_cast<size_t>(-1)], "");
202    EXPECT_DEATH_IF_SUPPORTED(v.resize(v.max_size() + 1), "");
203  #endif
204  }
205  TEST(UniquePtr, MoveConstruct) {
206    for (size_t size = 0; size < 16; ++size) {
207      SCOPED_TRACE(size);
208      absl::InlinedVector<std::unique_ptr<size_t>, 2> a;
209      for (size_t i = 0; i < size; ++i) {
210        a.push_back(std::make_unique<size_t>(i));
211      }
212      absl::InlinedVector<std::unique_ptr<size_t>, 2> b(std::move(a));
213      ASSERT_THAT(b, SizeIs(size));
214      for (size_t i = 0; i < size; ++i) {
215        ASSERT_THAT(b[i], Pointee(i));
216      }
217    }
218  }
219  TEST(UniquePtr, MoveAssign) {
220    for (size_t size = 0; size < 16; ++size) {
221      SCOPED_TRACE(size);
222      absl::InlinedVector<std::unique_ptr<size_t>, 2> a;
223      for (size_t i = 0; i < size; ++i) {
224        a.push_back(std::make_unique<size_t>(i));
225      }
226      absl::InlinedVector<std::unique_ptr<size_t>, 2> b;
227      b = std::move(a);
228      ASSERT_THAT(b, SizeIs(size));
229      for (size_t i = 0; i < size; ++i) {
230        ASSERT_THAT(b[i], Pointee(i));
231      }
232    }
233  }
234  TEST(RefCountedVec, EraseBeginEnd) {
235    for (size_t len = 1; len < 20; ++len) {
236      for (size_t erase_begin = 0; erase_begin < len; ++erase_begin) {
237        for (size_t erase_end = erase_begin; erase_end <= len; ++erase_end) {
238          std::vector<int> counts(len, 0);
239          RefCountedVec v;
240          for (size_t i = 0; i < len; ++i) {
241            v.push_back(RefCounted(static_cast<int>(i), &counts[i]));
242          }
243          size_t erase_len = erase_end - erase_begin;
244          v.erase(v.begin() + erase_begin, v.begin() + erase_end);
245          EXPECT_EQ(len - erase_len, v.size());
246          for (size_t i = 0; i < erase_begin; ++i) {
247            EXPECT_EQ(static_cast<int>(i), v[i].value_);
248          }
249          for (size_t i = erase_begin; i < v.size(); ++i) {
250            EXPECT_EQ(static_cast<int>(i + erase_len), v[i].value_);
251          }
252          for (size_t i = 0; i < erase_begin; ++i) {
253            EXPECT_EQ(1, counts[i]);
254          }
255          for (size_t i = erase_begin; i < erase_end; ++i) {
256            EXPECT_EQ(0, counts[i]);
257          }
258          for (size_t i = erase_end; i < len; ++i) {
259            EXPECT_EQ(1, counts[i]);
260          }
261        }
262      }
263    }
264  }
265  struct NoDefaultCtor {
266    explicit NoDefaultCtor(int) {}
267  };
268  struct NoCopy {
269    NoCopy() {}
270    NoCopy(const NoCopy&) = delete;
271  };
272  struct NoAssign {
273    NoAssign() {}
274    NoAssign& operator=(const NoAssign&) = delete;
275  };
276  struct MoveOnly {
277    MoveOnly() {}
278    MoveOnly(MoveOnly&&) = default;
279    MoveOnly& operator=(MoveOnly&&) = default;
280  };
281  TEST(InlinedVectorTest, NoDefaultCtor) {
282    absl::InlinedVector<NoDefaultCtor, 1> v(10, NoDefaultCtor(2));
283    (void)v;
284  }
285  TEST(InlinedVectorTest, NoCopy) {
286    absl::InlinedVector<NoCopy, 1> v(10);
287    (void)v;
288  }
289  TEST(InlinedVectorTest, NoAssign) {
290    absl::InlinedVector<NoAssign, 1> v(10);
291    (void)v;
292  }
293  TEST(InlinedVectorTest, MoveOnly) {
294    absl::InlinedVector<MoveOnly, 2> v;
295    v.push_back(MoveOnly{});
296    v.push_back(MoveOnly{});
297    v.push_back(MoveOnly{});
298    v.erase(v.begin());
299    v.push_back(MoveOnly{});
300    v.erase(v.begin(), v.begin() + 1);
301    v.insert(v.begin(), MoveOnly{});
302    v.emplace(v.begin());
303    v.emplace(v.begin(), MoveOnly{});
304  }
305  TEST(InlinedVectorTest, Noexcept) {
306    EXPECT_TRUE(std::is_nothrow_move_constructible<IntVec>::value);
307    EXPECT_TRUE((std::is_nothrow_move_constructible<
308                 absl::InlinedVector<MoveOnly, 2>>::value));
309    struct MoveCanThrow {
310      MoveCanThrow(MoveCanThrow&&) {}
311    };
312    EXPECT_EQ(absl::default_allocator_is_nothrow::value,
313              (std::is_nothrow_move_constructible<
314                  absl::InlinedVector<MoveCanThrow, 2>>::value));
315  }
316  TEST(InlinedVectorTest, EmplaceBack) {
317    absl::InlinedVector<std::pair<std::string, int>, 1> v;
318    auto& inlined_element = v.emplace_back("answer", 42);
319    EXPECT_EQ(&inlined_element, &v[0]);
320    EXPECT_EQ(inlined_element.first, "answer");
321    EXPECT_EQ(inlined_element.second, 42);
322    auto& allocated_element = v.emplace_back("taxicab", 1729);
323    EXPECT_EQ(&allocated_element, &v[1]);
324    EXPECT_EQ(allocated_element.first, "taxicab");
325    EXPECT_EQ(allocated_element.second, 1729);
326  }
327  TEST(InlinedVectorTest, ShrinkToFitGrowingVector) {
328    absl::InlinedVector<std::pair<std::string, int>, 1> v;
329    v.shrink_to_fit();
330    EXPECT_EQ(v.capacity(), 1u);
331    v.emplace_back("answer", 42);
332    v.shrink_to_fit();
333    EXPECT_EQ(v.capacity(), 1u);
334    v.emplace_back("taxicab", 1729);
335    EXPECT_GE(v.capacity(), 2u);
336    v.shrink_to_fit();
337    EXPECT_EQ(v.capacity(), 2u);
338    v.reserve(100);
339    EXPECT_GE(v.capacity(), 100u);
340    v.shrink_to_fit();
341    EXPECT_EQ(v.capacity(), 2u);
342  }
343  TEST(InlinedVectorTest, ShrinkToFitEdgeCases) {
344    {
345      absl::InlinedVector<std::pair<std::string, int>, 1> v;
346      v.emplace_back("answer", 42);
347      v.emplace_back("taxicab", 1729);
348      EXPECT_GE(v.capacity(), 2u);
349      v.pop_back();
350      v.shrink_to_fit();
351      EXPECT_EQ(v.capacity(), 1u);
352      EXPECT_EQ(v[0].first, "answer");
353      EXPECT_EQ(v[0].second, 42);
354    }
355    {
356      absl::InlinedVector<std::string, 2> v(100);
357      v.resize(0);
358      v.shrink_to_fit();
359      EXPECT_EQ(v.capacity(), 2u);  
360    }
361    {
362      absl::InlinedVector<std::string, 2> v(100);
363      v.resize(1);
364      v.shrink_to_fit();
365      EXPECT_EQ(v.capacity(), 2u);  
366    }
367    {
368      absl::InlinedVector<std::string, 2> v(100);
369      v.resize(2);
370      v.shrink_to_fit();
371      EXPECT_EQ(v.capacity(), 2u);
372    }
373    {
374      absl::InlinedVector<std::string, 2> v(100);
375      v.resize(3);
376      v.shrink_to_fit();
377      EXPECT_EQ(v.capacity(), 3u);
378    }
379  }
380  TEST(IntVec, Insert) {
381    for (size_t len = 0; len < 20; len++) {
382      for (ptrdiff_t pos = 0; pos <= static_cast<ptrdiff_t>(len); pos++) {
383        {
384          std::vector<int> std_v;
385          Fill(&std_v, len);
386          IntVec v;
387          Fill(&v, len);
388          std_v.insert(std_v.begin() + pos, 9999);
389          IntVec::iterator it = v.insert(v.cbegin() + pos, 9999);
390          EXPECT_THAT(v, ElementsAreArray(std_v));
391          EXPECT_EQ(it, v.cbegin() + pos);
392        }
393        {
394          std::vector<int> std_v;
395          Fill(&std_v, len);
396          IntVec v;
397          Fill(&v, len);
398          IntVec::size_type n = 5;
399          std_v.insert(std_v.begin() + pos, n, 9999);
400          IntVec::iterator it = v.insert(v.cbegin() + pos, n, 9999);
401          EXPECT_THAT(v, ElementsAreArray(std_v));
402          EXPECT_EQ(it, v.cbegin() + pos);
403        }
404        {
405          std::vector<int> std_v;
406          Fill(&std_v, len);
407          IntVec v;
408          Fill(&v, len);
409          const std::vector<int> input = {9999, 8888, 7777};
410          std_v.insert(std_v.begin() + pos, input.cbegin(), input.cend());
411          IntVec::iterator it =
412              v.insert(v.cbegin() + pos, input.cbegin(), input.cend());
413          EXPECT_THAT(v, ElementsAreArray(std_v));
414          EXPECT_EQ(it, v.cbegin() + pos);
415        }
416        {
417          std::vector<int> std_v;
418          Fill(&std_v, len);
419          IntVec v;
420          Fill(&v, len);
421          const std::forward_list<int> input = {9999, 8888, 7777};
422          std_v.insert(std_v.begin() + pos, input.cbegin(), input.cend());
423          IntVec::iterator it =
424              v.insert(v.cbegin() + pos, input.cbegin(), input.cend());
425          EXPECT_THAT(v, ElementsAreArray(std_v));
426          EXPECT_EQ(it, v.cbegin() + pos);
427        }
428        {
429          std::vector<int> std_v;
430          Fill(&std_v, len);
431          IntVec v;
432          Fill(&v, len);
433          std_v.insert(std_v.begin() + pos, {9999, 8888, 7777});
434          std::istringstream input("9999 8888 7777");
435          IntVec::iterator it =
436              v.insert(v.cbegin() + pos, std::istream_iterator<int>(input),
437                       std::istream_iterator<int>());
438          EXPECT_THAT(v, ElementsAreArray(std_v));
439          EXPECT_EQ(it, v.cbegin() + pos);
440        }
441        {
442          std::vector<int> std_v;
443          Fill(&std_v, len);
444          IntVec v;
445          Fill(&v, len);
446          std_v.insert(std_v.begin() + pos, {9999, 8888});
447          IntVec::iterator it = v.insert(v.cbegin() + pos, {9999, 8888});
448          EXPECT_THAT(v, ElementsAreArray(std_v));
449          EXPECT_EQ(it, v.cbegin() + pos);
450        }
451      }
452    }
453  }
454  TEST(RefCountedVec, InsertConstructorDestructor) {
455    for (size_t len = 0; len < 20; len++) {
456      SCOPED_TRACE(len);
457      for (size_t pos = 0; pos <= len; pos++) {
458        SCOPED_TRACE(pos);
459        std::vector<int> counts(len, 0);
460        int inserted_count = 0;
461        RefCountedVec v;
462        for (size_t i = 0; i < len; ++i) {
463          SCOPED_TRACE(i);
464          v.push_back(RefCounted(static_cast<int>(i), &counts[i]));
465        }
466        EXPECT_THAT(counts, Each(Eq(1)));
467        RefCounted insert_element(9999, &inserted_count);
468        EXPECT_EQ(1, inserted_count);
469        v.insert(v.begin() + pos, insert_element);
470        EXPECT_EQ(2, inserted_count);
471        EXPECT_THAT(counts, Each(Eq(1)));
472        EXPECT_EQ(2, inserted_count);
473      }
474    }
475  }
476  TEST(IntVec, Resize) {
477    for (size_t len = 0; len < 20; len++) {
478      IntVec v;
479      Fill(&v, len);
480      static const int kResizeElem = 1000000;
481      for (size_t k = 0; k < 10; k++) {
482        v.resize(len + k, kResizeElem);
483        EXPECT_EQ(len + k, v.size());
484        EXPECT_LE(len + k, v.capacity());
485        for (size_t i = 0; i < len + k; i++) {
486          if (i < len) {
487            EXPECT_EQ(static_cast<int>(i), v[i]);
488          } else {
489            EXPECT_EQ(kResizeElem, v[i]);
490          }
491        }
492        v.resize(len, kResizeElem);
493        EXPECT_EQ(len, v.size());
494        EXPECT_LE(len, v.capacity());
495        for (size_t i = 0; i < len; i++) {
496          EXPECT_EQ(static_cast<int>(i), v[i]);
497        }
498      }
499    }
500  }
501  TEST(IntVec, InitWithLength) {
502    for (size_t len = 0; len < 20; len++) {
503      IntVec v(len, 7);
504      EXPECT_EQ(len, v.size());
505      EXPECT_LE(len, v.capacity());
506      for (size_t i = 0; i < len; i++) {
507        EXPECT_EQ(7, v[i]);
508      }
509    }
510  }
511  TEST(IntVec, CopyConstructorAndAssignment) {
512    for (size_t len = 0; len < 20; len++) {
513      IntVec v;
514      Fill(&v, len);
515      EXPECT_EQ(len, v.size());
516      EXPECT_LE(len, v.capacity());
517      IntVec v2(v);
518      EXPECT_TRUE(v == v2) << PrintToString(v) << PrintToString(v2);
519      for (size_t start_len = 0; start_len < 20; start_len++) {
520        IntVec v3;
521        Fill(&v3, start_len, 99);  
522        v3 = v;
523        EXPECT_TRUE(v == v3) << PrintToString(v) << PrintToString(v3);
524      }
525    }
526  }
527  TEST(IntVec, AliasingCopyAssignment) {
528    for (size_t len = 0; len < 20; ++len) {
529      IntVec original;
530      Fill(&original, len);
531      IntVec dup = original;
532      dup = *&dup;
533      EXPECT_EQ(dup, original);
534    }
535  }
536  TEST(IntVec, MoveConstructorAndAssignment) {
537    for (size_t len = 0; len < 20; len++) {
538      IntVec v_in;
539      const size_t inlined_capacity = v_in.capacity();
540      Fill(&v_in, len);
541      EXPECT_EQ(len, v_in.size());
542      EXPECT_LE(len, v_in.capacity());
543      {
544        IntVec v_temp(v_in);
545        auto* old_data = v_temp.data();
546        IntVec v_out(std::move(v_temp));
547        EXPECT_TRUE(v_in == v_out) << PrintToString(v_in) << PrintToString(v_out);
548        if (v_in.size() > inlined_capacity) {
549          EXPECT_TRUE(v_out.data() == old_data);
550        } else {
551          EXPECT_FALSE(v_out.data() == old_data);
552        }
553      }
554      for (size_t start_len = 0; start_len < 20; start_len++) {
555        IntVec v_out;
556        Fill(&v_out, start_len, 99);  
557        IntVec v_temp(v_in);
558        auto* old_data = v_temp.data();
559        v_out = std::move(v_temp);
560        EXPECT_TRUE(v_in == v_out) << PrintToString(v_in) << PrintToString(v_out);
561        if (v_in.size() > inlined_capacity) {
562          EXPECT_TRUE(v_out.data() == old_data);
563        } else {
564          EXPECT_FALSE(v_out.data() == old_data);
565        }
566      }
567    }
568  }
569  class NotTriviallyDestructible {
570   public:
571    NotTriviallyDestructible() : p_(new int(1)) {}
572    explicit NotTriviallyDestructible(int i) : p_(new int(i)) {}
573    NotTriviallyDestructible(const NotTriviallyDestructible& other)
574        : p_(new int(*other.p_)) {}
575    NotTriviallyDestructible& operator=(const NotTriviallyDestructible& other) {
576      p_ = absl::make_unique<int>(*other.p_);
577      return *this;
578    }
579    bool operator==(const NotTriviallyDestructible& other) const {
580      return *p_ == *other.p_;
581    }
582   private:
583    std::unique_ptr<int> p_;
584  };
585  TEST(AliasingTest, Emplace) {
586    for (size_t i = 2; i < 20; ++i) {
587      absl::InlinedVector<NotTriviallyDestructible, 10> vec;
588      for (size_t j = 0; j < i; ++j) {
589        vec.push_back(NotTriviallyDestructible(static_cast<int>(j)));
590      }
591      vec.emplace(vec.begin(), vec[0]);
592      EXPECT_EQ(vec[0], vec[1]);
593      vec.emplace(vec.begin() + i / 2, vec[i / 2]);
594      EXPECT_EQ(vec[i / 2], vec[i / 2 + 1]);
595      vec.emplace(vec.end() - 1, vec.back());
596      EXPECT_EQ(vec[vec.size() - 2], vec.back());
597    }
598  }
599  TEST(AliasingTest, InsertWithCount) {
600    for (size_t i = 1; i < 20; ++i) {
601      absl::InlinedVector<NotTriviallyDestructible, 10> vec;
602      for (size_t j = 0; j < i; ++j) {
603        vec.push_back(NotTriviallyDestructible(static_cast<int>(j)));
604      }
605      for (size_t n = 0; n < 5; ++n) {
606        vec.insert(vec.begin(), n, vec.back());
607        auto b = vec.begin();
608        EXPECT_TRUE(
609            std::all_of(b, b + n, [&vec](const NotTriviallyDestructible& x) {
610              return x == vec.back();
611            }));
612        auto m_idx = vec.size() / 2;
613        vec.insert(vec.begin() + m_idx, n, vec.back());
614        auto m = vec.begin() + m_idx;
615        EXPECT_TRUE(
616            std::all_of(m, m + n, [&vec](const NotTriviallyDestructible& x) {
617              return x == vec.back();
618            }));
619        auto old_e = vec.size() - 1;
620        auto val = vec[old_e];
621        vec.insert(vec.end(), n, vec[old_e]);
622        auto e = vec.begin() + old_e;
623        EXPECT_TRUE(std::all_of(
624            e, e + n,
625            [&val](const NotTriviallyDestructible& x) { return x == val; }));
626      }
627    }
628  }
629  TEST(OverheadTest, Storage) {
630    struct T { void* val; };
631    size_t expected_overhead = sizeof(T);
632    EXPECT_EQ((2 * expected_overhead),
633              sizeof(absl::InlinedVector<T, 1>) - sizeof(T[1]));
634    EXPECT_EQ(expected_overhead,
635              sizeof(absl::InlinedVector<T, 2>) - sizeof(T[2]));
636    EXPECT_EQ(expected_overhead,
637              sizeof(absl::InlinedVector<T, 3>) - sizeof(T[3]));
638    EXPECT_EQ(expected_overhead,
639              sizeof(absl::InlinedVector<T, 4>) - sizeof(T[4]));
640    EXPECT_EQ(expected_overhead,
641              sizeof(absl::InlinedVector<T, 5>) - sizeof(T[5]));
642    EXPECT_EQ(expected_overhead,
643              sizeof(absl::InlinedVector<T, 6>) - sizeof(T[6]));
644    EXPECT_EQ(expected_overhead,
645              sizeof(absl::InlinedVector<T, 7>) - sizeof(T[7]));
646    EXPECT_EQ(expected_overhead,
647              sizeof(absl::InlinedVector<T, 8>) - sizeof(T[8]));
648  }
649  TEST(IntVec, Clear) {
650    for (size_t len = 0; len < 20; len++) {
651      SCOPED_TRACE(len);
652      IntVec v;
653      Fill(&v, len);
654      v.clear();
655      EXPECT_EQ(0u, v.size());
656      EXPECT_EQ(v.begin(), v.end());
657    }
658  }
659  TEST(IntVec, Reserve) {
660    for (size_t len = 0; len < 20; len++) {
661      IntVec v;
662      Fill(&v, len);
663      for (size_t newlen = 0; newlen < 100; newlen++) {
664        const int* start_rep = v.data();
665        v.reserve(newlen);
666        const int* final_rep = v.data();
667        if (newlen <= len) {
668          EXPECT_EQ(start_rep, final_rep);
669        }
670        EXPECT_LE(newlen, v.capacity());
671        while (v.size() < newlen) {
672          v.push_back(0);
673        }
674        EXPECT_EQ(final_rep, v.data());
675      }
676    }
677  }
678  TEST(StringVec, SelfRefPushBack) {
679    std::vector<std::string> std_v;
680    absl::InlinedVector<std::string, 4> v;
681    const std::string s = "A quite long string to ensure heap.";
682    std_v.push_back(s);
683    v.push_back(s);
684    for (int i = 0; i < 20; ++i) {
685      EXPECT_THAT(v, ElementsAreArray(std_v));
686      v.push_back(v.back());
687      std_v.push_back(std_v.back());
688    }
689    EXPECT_THAT(v, ElementsAreArray(std_v));
690  }
691  TEST(StringVec, SelfRefPushBackWithMove) {
692    std::vector<std::string> std_v;
693    absl::InlinedVector<std::string, 4> v;
694    const std::string s = "A quite long string to ensure heap.";
695    std_v.push_back(s);
696    v.push_back(s);
697    for (int i = 0; i < 20; ++i) {
698      EXPECT_EQ(v.back(), std_v.back());
699      v.push_back(std::move(v.back()));
700      std_v.push_back(std::move(std_v.back()));
701    }
702    EXPECT_EQ(v.back(), std_v.back());
703  }
704  TEST(StringVec, SelfMove) {
705    const std::string s = "A quite long string to ensure heap.";
706    for (int len = 0; len < 20; len++) {
707      SCOPED_TRACE(len);
708      absl::InlinedVector<std::string, 8> v;
709      for (int i = 0; i < len; ++i) {
710        SCOPED_TRACE(i);
711        v.push_back(s);
712      }
713      v = std::move(*(&v));
714      std::vector<std::string> copy(v.begin(), v.end());
715    }
716  }
717  TEST(IntVec, Swap) {
718    for (size_t l1 = 0; l1 < 20; l1++) {
719      SCOPED_TRACE(l1);
720      for (size_t l2 = 0; l2 < 20; l2++) {
721        SCOPED_TRACE(l2);
722        IntVec a = Fill(l1, 0);
723        IntVec b = Fill(l2, 100);
724        {
725          using std::swap;
726          swap(a, b);
727        }
728        EXPECT_EQ(l1, b.size());
729        EXPECT_EQ(l2, a.size());
730        for (size_t i = 0; i < l1; i++) {
731          SCOPED_TRACE(i);
732          EXPECT_EQ(static_cast<int>(i), b[i]);
733        }
734        for (size_t i = 0; i < l2; i++) {
735          SCOPED_TRACE(i);
736          EXPECT_EQ(100 + static_cast<int>(i), a[i]);
737        }
738      }
739    }
740  }
741  TYPED_TEST_P(InstanceTest, Swap) {
742    using Instance = TypeParam;
743    using InstanceVec = absl::InlinedVector<Instance, 8>;
744    for (size_t l1 = 0; l1 < 20; l1++) {
745      SCOPED_TRACE(l1);
746      for (size_t l2 = 0; l2 < 20; l2++) {
747        SCOPED_TRACE(l2);
748        InstanceTracker tracker;
749        InstanceVec a, b;
750        const size_t inlined_capacity = a.capacity();
751        auto min_len = std::min(l1, l2);
752        auto max_len = std::max(l1, l2);
753        for (size_t i = 0; i < l1; i++)
754          a.push_back(Instance(static_cast<int>(i)));
755        for (size_t i = 0; i < l2; i++)
756          b.push_back(Instance(100 + static_cast<int>(i)));
757        EXPECT_EQ(tracker.instances(), static_cast<int>(l1 + l2));
758        tracker.ResetCopiesMovesSwaps();
759        {
760          using std::swap;
761          swap(a, b);
762        }
763        EXPECT_EQ(tracker.instances(), static_cast<int>(l1 + l2));
764        if (a.size() > inlined_capacity && b.size() > inlined_capacity) {
765          EXPECT_EQ(tracker.swaps(), 0);  
766          EXPECT_EQ(tracker.moves(), 0);
767        } else if (a.size() <= inlined_capacity && b.size() <= inlined_capacity) {
768          EXPECT_EQ(tracker.swaps(), static_cast<int>(min_len));
769          EXPECT_EQ((tracker.moves() ? tracker.moves() : tracker.copies()),
770                    static_cast<int>(max_len - min_len));
771        } else {
772          EXPECT_EQ(tracker.swaps(), 0);
773          EXPECT_EQ((tracker.moves() ? tracker.moves() : tracker.copies()),
774                    static_cast<int>(min_len));
775        }
776        EXPECT_EQ(l1, b.size());
777        EXPECT_EQ(l2, a.size());
778        for (size_t i = 0; i < l1; i++) {
779          EXPECT_EQ(static_cast<int>(i), b[i].value());
780        }
781        for (size_t i = 0; i < l2; i++) {
782          EXPECT_EQ(100 + static_cast<int>(i), a[i].value());
783        }
784      }
785    }
786  }
787  TEST(IntVec, EqualAndNotEqual) {
788    IntVec a, b;
789    EXPECT_TRUE(a == b);
790    EXPECT_FALSE(a != b);
791    a.push_back(3);
792    EXPECT_FALSE(a == b);
793    EXPECT_TRUE(a != b);
794    b.push_back(3);
795    EXPECT_TRUE(a == b);
796    EXPECT_FALSE(a != b);
797    b.push_back(7);
798    EXPECT_FALSE(a == b);
799    EXPECT_TRUE(a != b);
800    a.push_back(6);
801    EXPECT_FALSE(a == b);
802    EXPECT_TRUE(a != b);
803    a.clear();
804    b.clear();
805    for (size_t i = 0; i < 100; i++) {
806      a.push_back(static_cast<int>(i));
807      b.push_back(static_cast<int>(i));
808      EXPECT_TRUE(a == b);
809      EXPECT_FALSE(a != b);
810      b[i] = b[i] + 1;
811      EXPECT_FALSE(a == b);
812      EXPECT_TRUE(a != b);
813      b[i] = b[i] - 1;  
814      EXPECT_TRUE(a == b);
815      EXPECT_FALSE(a != b);
816    }
817  }
818  TEST(IntVec, RelationalOps) {
819    IntVec a, b;
820    EXPECT_FALSE(a < b);
821    EXPECT_FALSE(b < a);
822    EXPECT_FALSE(a > b);
823    EXPECT_FALSE(b > a);
824    EXPECT_TRUE(a <= b);
825    EXPECT_TRUE(b <= a);
826    EXPECT_TRUE(a >= b);
827    EXPECT_TRUE(b >= a);
828    b.push_back(3);
829    EXPECT_TRUE(a < b);
830    EXPECT_FALSE(b < a);
831    EXPECT_FALSE(a > b);
832    EXPECT_TRUE(b > a);
833    EXPECT_TRUE(a <= b);
834    EXPECT_FALSE(b <= a);
835    EXPECT_FALSE(a >= b);
836    EXPECT_TRUE(b >= a);
837  }
838  TYPED_TEST_P(InstanceTest, CountConstructorsDestructors) {
839    using Instance = TypeParam;
840    using InstanceVec = absl::InlinedVector<Instance, 8>;
841    InstanceTracker tracker;
842    for (size_t len = 0; len < 20; len++) {
843      SCOPED_TRACE(len);
844      tracker.ResetCopiesMovesSwaps();
845      InstanceVec v;
846      const size_t inlined_capacity = v.capacity();
847      for (size_t i = 0; i < len; i++) {
848        v.push_back(Instance(static_cast<int>(i)));
849      }
850      EXPECT_EQ(tracker.instances(), static_cast<int>(len));
851      EXPECT_GE(tracker.copies() + tracker.moves(),
852                static_cast<int>(len));  
853      tracker.ResetCopiesMovesSwaps();
854      tracker.ResetCopiesMovesSwaps();
855      v.resize(len + 10, Instance(100));
856      EXPECT_EQ(tracker.instances(), static_cast<int>(len) + 10);
857      if (len <= inlined_capacity && len + 10 > inlined_capacity) {
858        EXPECT_EQ(tracker.copies() + tracker.moves(), 10 + static_cast<int>(len));
859      } else {
860        EXPECT_GE(tracker.copies() + tracker.moves(),
861                  10);  
862      }
863      tracker.ResetCopiesMovesSwaps();
864      v.resize(len, Instance(100));
865      EXPECT_EQ(tracker.instances(), static_cast<int>(len));
866      EXPECT_EQ(tracker.copies(), 0);
867      EXPECT_EQ(tracker.moves(), 0);
868      SCOPED_TRACE("reserve");
869      v.reserve(len + 1000);
870      EXPECT_EQ(tracker.instances(), static_cast<int>(len));
871      EXPECT_EQ(tracker.copies() + tracker.moves(), static_cast<int>(len));
872      if (len > 0) {
873        tracker.ResetCopiesMovesSwaps();
874        v.pop_back();
875        EXPECT_EQ(tracker.instances(), static_cast<int>(len) - 1);
876        EXPECT_EQ(tracker.copies(), 0);
877        EXPECT_EQ(tracker.moves(), 0);
878        if (!v.empty()) {
879          tracker.ResetCopiesMovesSwaps();
880          v.erase(v.begin());
881          EXPECT_EQ(tracker.instances(), static_cast<int>(len) - 2);
882          EXPECT_EQ(tracker.copies() + tracker.moves(),
883                    static_cast<int>(len) - 2);
884        }
885      }
886      tracker.ResetCopiesMovesSwaps();
887      int instances_before_empty_erase = tracker.instances();
888      v.erase(v.begin(), v.begin());
889      EXPECT_EQ(tracker.instances(), instances_before_empty_erase);
890      EXPECT_EQ(tracker.copies() + tracker.moves(), 0);
891    }
892  }
893  TYPED_TEST_P(InstanceTest, CountConstructorsDestructorsOnCopyConstruction) {
894    using Instance = TypeParam;
895    using InstanceVec = absl::InlinedVector<Instance, 8>;
896    InstanceTracker tracker;
897    for (int len = 0; len < 20; len++) {
898      SCOPED_TRACE(len);
899      tracker.ResetCopiesMovesSwaps();
900      InstanceVec v;
901      for (int i = 0; i < len; i++) {
902        v.push_back(Instance(i));
903      }
904      EXPECT_EQ(tracker.instances(), len);
905      EXPECT_GE(tracker.copies() + tracker.moves(),
906                len);  
907      tracker.ResetCopiesMovesSwaps();
908      {  
909        InstanceVec v_copy(v);
910        EXPECT_EQ(tracker.instances(), len + len);
911        EXPECT_EQ(tracker.copies(), len);
912        EXPECT_EQ(tracker.moves(), 0);
913      }
914      EXPECT_EQ(tracker.instances(), len);
915    }
916  }
917  TYPED_TEST_P(InstanceTest, CountConstructorsDestructorsOnMoveConstruction) {
918    using Instance = TypeParam;
919    using InstanceVec = absl::InlinedVector<Instance, 8>;
920    InstanceTracker tracker;
921    for (int len = 0; len < 20; len++) {
922      SCOPED_TRACE(len);
923      tracker.ResetCopiesMovesSwaps();
924      InstanceVec v;
925      const size_t inlined_capacity = v.capacity();
926      for (int i = 0; i < len; i++) {
927        v.push_back(Instance(i));
928      }
929      EXPECT_EQ(tracker.instances(), len);
930      EXPECT_GE(tracker.copies() + tracker.moves(),
931                len);  
932      tracker.ResetCopiesMovesSwaps();
933      {
934        InstanceVec v_copy(std::move(v));
935        if (static_cast<size_t>(len) > inlined_capacity) {
936          EXPECT_EQ(tracker.instances(), len);
937          EXPECT_EQ(tracker.live_instances(), len);
938          EXPECT_EQ(v.size(), 0u);  
939          EXPECT_EQ(tracker.copies(), 0);
940          EXPECT_EQ(tracker.moves(), 0);
941        } else {
942          EXPECT_EQ(tracker.instances(), len + len);
943          if (Instance::supports_move()) {
944            EXPECT_EQ(tracker.live_instances(), len);
945            EXPECT_EQ(tracker.copies(), 0);
946            EXPECT_EQ(tracker.moves(), len);
947          } else {
948            EXPECT_EQ(tracker.live_instances(), len + len);
949            EXPECT_EQ(tracker.copies(), len);
950            EXPECT_EQ(tracker.moves(), 0);
951          }
952        }
953        EXPECT_EQ(tracker.swaps(), 0);
954      }
955    }
956  }
957  TYPED_TEST_P(InstanceTest, CountConstructorsDestructorsOnAssignment) {
958    using Instance = TypeParam;
959    using InstanceVec = absl::InlinedVector<Instance, 8>;
960    InstanceTracker tracker;
961    for (int len = 0; len < 20; len++) {
962      SCOPED_TRACE(len);
963      for (int longorshort = 0; longorshort <= 1; ++longorshort) {
964        SCOPED_TRACE(longorshort);
965        tracker.ResetCopiesMovesSwaps();
966        InstanceVec longer, shorter;
967        for (int i = 0; i < len; i++) {
968          longer.push_back(Instance(i));
969          shorter.push_back(Instance(i));
970        }
971        longer.push_back(Instance(len));
972        EXPECT_EQ(tracker.instances(), len + len + 1);
973        EXPECT_GE(tracker.copies() + tracker.moves(),
974                  len + len + 1);  
975        tracker.ResetCopiesMovesSwaps();
976        if (longorshort) {
977          shorter = longer;
978          EXPECT_EQ(tracker.instances(), (len + 1) + (len + 1));
979          EXPECT_GE(tracker.copies() + tracker.moves(),
980                    len + 1);  
981        } else {
982          longer = shorter;
983          EXPECT_EQ(tracker.instances(), len + len);
984          EXPECT_EQ(tracker.copies() + tracker.moves(), len);
985        }
986      }
987    }
988  }
989  TYPED_TEST_P(InstanceTest, CountConstructorsDestructorsOnMoveAssignment) {
990    using Instance = TypeParam;
991    using InstanceVec = absl::InlinedVector<Instance, 8>;
992    InstanceTracker tracker;
993    for (int len = 0; len < 20; len++) {
994      SCOPED_TRACE(len);
995      for (int longorshort = 0; longorshort <= 1; ++longorshort) {
996        SCOPED_TRACE(longorshort);
997        tracker.ResetCopiesMovesSwaps();
998        InstanceVec longer, shorter;
999        const size_t inlined_capacity = longer.capacity();
1000        for (int i = 0; i < len; i++) {
1001          longer.push_back(Instance(i));
1002          shorter.push_back(Instance(i));
1003        }
1004        longer.push_back(Instance(len));
1005        EXPECT_EQ(tracker.instances(), len + len + 1);
1006        EXPECT_GE(tracker.copies() + tracker.moves(),
1007                  len + len + 1);  
1008        tracker.ResetCopiesMovesSwaps();
1009        int src_len;
1010        if (longorshort) {
1011          src_len = len + 1;
1012          shorter = std::move(longer);
1013        } else {
1014          src_len = len;
1015          longer = std::move(shorter);
1016        }
1017        if (static_cast<size_t>(src_len) > inlined_capacity) {
1018          EXPECT_EQ(tracker.instances(), src_len);
1019          EXPECT_EQ(tracker.live_instances(), src_len);
1020          EXPECT_EQ(tracker.copies(), 0);
1021          EXPECT_EQ(tracker.moves(), 0);
1022        } else {
1023          EXPECT_EQ(tracker.instances(), src_len + src_len);
1024          if (Instance::supports_move()) {
1025            EXPECT_EQ(tracker.copies(), 0);
1026            EXPECT_EQ(tracker.moves(), src_len);
1027            EXPECT_EQ(tracker.live_instances(), src_len);
1028          } else {
1029            EXPECT_EQ(tracker.copies(), src_len);
1030            EXPECT_EQ(tracker.moves(), 0);
1031            EXPECT_EQ(tracker.live_instances(), src_len + src_len);
1032          }
1033        }
1034        EXPECT_EQ(tracker.swaps(), 0);
1035      }
1036    }
1037  }
1038  TEST(CountElemAssign, SimpleTypeWithInlineBacking) {
1039    const size_t inlined_capacity = absl::InlinedVector<int, 2>().capacity();
1040    for (size_t original_size = 0; original_size <= 5; ++original_size) {
1041      SCOPED_TRACE(original_size);
1042      std::vector<int> original_contents(original_size, 12345);
1043      absl::InlinedVector<int, 2> v(original_contents.begin(),
1044                                    original_contents.end());
1045      v.assign(2, 123);
1046      EXPECT_THAT(v, AllOf(SizeIs(2u), ElementsAre(123, 123)));
1047      if (original_size <= inlined_capacity) {
1048        EXPECT_EQ(v.capacity(), inlined_capacity);
1049      }
1050    }
1051  }
1052  TEST(CountElemAssign, SimpleTypeWithAllocation) {
1053    for (size_t original_size = 0; original_size <= 5; ++original_size) {
1054      SCOPED_TRACE(original_size);
1055      std::vector<int> original_contents(original_size, 12345);
1056      absl::InlinedVector<int, 2> v(original_contents.begin(),
1057                                    original_contents.end());
1058      v.assign(3, 123);
1059      EXPECT_THAT(v, AllOf(SizeIs(3u), ElementsAre(123, 123, 123)));
1060      EXPECT_LE(v.size(), v.capacity());
1061    }
1062  }
1063  TYPED_TEST_P(InstanceTest, CountElemAssignInlineBacking) {
1064    using Instance = TypeParam;
1065    for (size_t original_size = 0; original_size <= 5; ++original_size) {
1066      SCOPED_TRACE(original_size);
1067      std::vector<Instance> original_contents(original_size, Instance(12345));
1068      absl::InlinedVector<Instance, 2> v(original_contents.begin(),
1069                                         original_contents.end());
1070      v.assign(2, Instance(123));
1071      EXPECT_THAT(v, AllOf(SizeIs(2u), ElementsAre(ValueIs(123), ValueIs(123))));
1072      if (original_size <= 2) {
1073        EXPECT_EQ(2u, v.capacity());
1074      }
1075    }
1076  }
1077  template <typename Instance>
1078  void InstanceCountElemAssignWithAllocationTest() {
1079    for (size_t original_size = 0; original_size <= 5; ++original_size) {
1080      SCOPED_TRACE(original_size);
1081      std::vector<Instance> original_contents(original_size, Instance(12345));
1082      absl::InlinedVector<Instance, 2> v(original_contents.begin(),
1083                                         original_contents.end());
1084      v.assign(3, Instance(123));
1085      EXPECT_THAT(v, AllOf(SizeIs(3u), ElementsAre(ValueIs(123), ValueIs(123),
1086                                                   ValueIs(123))));
1087      EXPECT_LE(v.size(), v.capacity());
1088    }
1089  }
1090  TEST(CountElemAssign, WithAllocationCopyableInstance) {
1091    InstanceCountElemAssignWithAllocationTest<CopyableOnlyInstance>();
1092  }
1093  TEST(CountElemAssign, WithAllocationCopyableMovableInstance) {
1094    InstanceCountElemAssignWithAllocationTest<CopyableMovableInstance>();
1095  }
1096  TEST(RangedConstructor, SimpleType) {
1097    std::vector<int> source_v = {4, 5, 6};
1098    absl::InlinedVector<int, 4> v(source_v.begin(), source_v.end());
1099    EXPECT_EQ(3u, v.size());
1100    EXPECT_EQ(4u,
1101              v.capacity());  
1102    EXPECT_EQ(4, v[0]);
1103    EXPECT_EQ(5, v[1]);
1104    EXPECT_EQ(6, v[2]);
1105    absl::InlinedVector<int, 2> realloc_v(source_v.begin(), source_v.end());
1106    EXPECT_EQ(3u, realloc_v.size());
1107    EXPECT_LT(2u, realloc_v.capacity());
1108    EXPECT_EQ(4, realloc_v[0]);
1109    EXPECT_EQ(5, realloc_v[1]);
1110    EXPECT_EQ(6, realloc_v[2]);
1111  }
1112  template <typename Instance, typename SourceContainer, int inlined_capacity>
1113  void InstanceRangedConstructorTestForContainer() {
1114    InstanceTracker tracker;
1115    SourceContainer source_v = {Instance(0), Instance(1)};
1116    tracker.ResetCopiesMovesSwaps();
1117    absl::InlinedVector<Instance, inlined_capacity> v(source_v.begin(),
1118                                                      source_v.end());
1119    EXPECT_EQ(2u, v.size());
1120    EXPECT_LT(1u, v.capacity());
1121    EXPECT_EQ(0, v[0].value());
1122    EXPECT_EQ(1, v[1].value());
1123    EXPECT_EQ(tracker.copies(), 2);
1124    EXPECT_EQ(tracker.moves(), 0);
1125  }
1126  template <typename Instance, int inlined_capacity>
1127  void InstanceRangedConstructorTestWithCapacity() {
1128    {
1129      SCOPED_TRACE("std::list");
1130      InstanceRangedConstructorTestForContainer<Instance, std::list<Instance>,
1131                                                inlined_capacity>();
1132      {
1133        SCOPED_TRACE("const std::list");
1134        InstanceRangedConstructorTestForContainer<
1135            Instance, const std::list<Instance>, inlined_capacity>();
1136      }
1137      {
1138        SCOPED_TRACE("std::vector");
1139        InstanceRangedConstructorTestForContainer<Instance, std::vector<Instance>,
1140                                                  inlined_capacity>();
1141      }
1142      {
1143        SCOPED_TRACE("const std::vector");
1144        InstanceRangedConstructorTestForContainer<
1145            Instance, const std::vector<Instance>, inlined_capacity>();
1146      }
1147    }
1148  }
1149  TYPED_TEST_P(InstanceTest, RangedConstructor) {
1150    using Instance = TypeParam;
1151    SCOPED_TRACE("capacity=1");
1152    InstanceRangedConstructorTestWithCapacity<Instance, 1>();
1153    SCOPED_TRACE("capacity=2");
1154    InstanceRangedConstructorTestWithCapacity<Instance, 2>();
1155  }
1156  TEST(RangedConstructor, ElementsAreConstructed) {
1157    std::vector<std::string> source_v = {"cat", "dog"};
1158    absl::InlinedVector<std::string, 1> v(source_v.begin(), source_v.end());
1159    EXPECT_EQ("cat", v[0]);
1160    EXPECT_EQ("dog", v[1]);
1161  }
1162  TEST(RangedAssign, SimpleType) {
1163    const size_t inlined_capacity = absl::InlinedVector<int, 3>().capacity();
1164    for (size_t original_size = 0; original_size <= 5; ++original_size) {
1165      SCOPED_TRACE(original_size);
1166      std::vector<int> original_contents(original_size, 12345);
1167      for (size_t target_size = 0; target_size <= 5; ++target_size) {
1168        SCOPED_TRACE(target_size);
1169        std::vector<int> new_contents;
1170        for (size_t i = 0; i < target_size; ++i) {
1171          new_contents.push_back(static_cast<int>(i + 3));
1172        }
1173        absl::InlinedVector<int, 3> v(original_contents.begin(),
1174                                      original_contents.end());
1175        v.assign(new_contents.begin(), new_contents.end());
1176        EXPECT_EQ(new_contents.size(), v.size());
1177        EXPECT_LE(new_contents.size(), v.capacity());
1178        if (target_size <= inlined_capacity &&
1179            original_size <= inlined_capacity) {
1180          EXPECT_EQ(v.capacity(), inlined_capacity);
1181        }
1182        EXPECT_THAT(v, ElementsAreArray(new_contents));
1183      }
1184    }
1185  }
1186  template <typename Instance>
1187  static bool InstanceValuesEqual(const Instance& lhs, const Instance& rhs) {
1188    return lhs.value() == rhs.value();
1189  }
1190  template <typename Instance, typename SourceContainer>
1191  void InstanceRangedAssignTestForContainer() {
1192    for (size_t original_size = 0; original_size <= 5; ++original_size) {
1193      SCOPED_TRACE(original_size);
1194      std::vector<Instance> original_contents(original_size, Instance(12345));
1195      for (size_t target_size = 0; target_size <= 5; ++target_size) {
1196        SCOPED_TRACE(target_size);
1197        std::vector<Instance> new_contents_in;
1198        for (size_t i = 0; i < target_size; ++i) {
1199          new_contents_in.push_back(Instance(static_cast<int>(i) + 3));
1200        }
1201        SourceContainer new_contents(new_contents_in.begin(),
1202                                     new_contents_in.end());
1203        absl::InlinedVector<Instance, 3> v(original_contents.begin(),
1204                                           original_contents.end());
1205        v.assign(new_contents.begin(), new_contents.end());
1206        EXPECT_EQ(new_contents.size(), v.size());
1207        EXPECT_LE(new_contents.size(), v.capacity());
1208        if (target_size <= 3 && original_size <= 3) {
1209          EXPECT_EQ(3u, v.capacity());
1210        }
1211        EXPECT_TRUE(std::equal(v.begin(), v.end(), new_contents.begin(),
1212                               InstanceValuesEqual<Instance>));
1213      }
1214    }
1215  }
1216  TYPED_TEST_P(InstanceTest, RangedAssign) {
1217    using Instance = TypeParam;
1218    SCOPED_TRACE("std::list");
1219    InstanceRangedAssignTestForContainer<Instance, std::list<Instance>>();
1220    SCOPED_TRACE("const std::list");
1221    InstanceRangedAssignTestForContainer<Instance, const std::list<Instance>>();
1222    SCOPED_TRACE("std::vector");
1223    InstanceRangedAssignTestForContainer<Instance, std::vector<Instance>>();
1224    SCOPED_TRACE("const std::vector");
1225    InstanceRangedAssignTestForContainer<Instance, const std::vector<Instance>>();
1226  }
1227  TEST(InitializerListConstructor, SimpleTypeWithInlineBacking) {
1228    EXPECT_THAT((absl::InlinedVector<int, 4>{4, 5, 6}),
1229                AllOf(SizeIs(3u), CapacityIs(4u), ElementsAre(4, 5, 6)));
1230  }
1231  TEST(InitializerListConstructor, SimpleTypeWithReallocationRequired) {
1232    EXPECT_THAT((absl::InlinedVector<int, 2>{4, 5, 6}),
1233                AllOf(SizeIs(3u), CapacityIs(Gt(2u)), ElementsAre(4, 5, 6)));
1234  }
1235  TEST(InitializerListConstructor, DisparateTypesInList) {
1236    EXPECT_THAT((absl::InlinedVector<int, 2>{-7, 8ULL}), ElementsAre(-7, 8));
1237    EXPECT_THAT((absl::InlinedVector<std::string, 2>{"foo", std::string("bar")}),
1238                ElementsAre("foo", "bar"));
1239  }
1240  TEST(InitializerListConstructor, ComplexTypeWithInlineBacking) {
1241    const size_t inlined_capacity =
1242        absl::InlinedVector<CopyableMovableInstance, 1>().capacity();
1243    EXPECT_THAT(
1244        (absl::InlinedVector<CopyableMovableInstance, 1>{
1245            CopyableMovableInstance(0)}),
1246        AllOf(SizeIs(1u), CapacityIs(inlined_capacity), ElementsAre(ValueIs(0))));
1247  }
1248  TEST(InitializerListConstructor, ComplexTypeWithReallocationRequired) {
1249    EXPECT_THAT((absl::InlinedVector<CopyableMovableInstance, 1>{
1250                    CopyableMovableInstance(0), CopyableMovableInstance(1)}),
1251                AllOf(SizeIs(2u), CapacityIs(Gt(1u)),
1252                      ElementsAre(ValueIs(0), ValueIs(1))));
1253  }
1254  TEST(InitializerListAssign, SimpleTypeFitsInlineBacking) {
1255    for (size_t original_size = 0; original_size <= 4; ++original_size) {
1256      SCOPED_TRACE(original_size);
1257      absl::InlinedVector<int, 2> v1(original_size, 12345);
1258      const size_t original_capacity_v1 = v1.capacity();
1259      v1.assign({3});
1260      EXPECT_THAT(v1, AllOf(SizeIs(1u), CapacityIs(original_capacity_v1),
1261                            ElementsAre(3)));
1262      absl::InlinedVector<int, 2> v2(original_size, 12345);
1263      const size_t original_capacity_v2 = v2.capacity();
1264      v2 = {3};
1265      EXPECT_THAT(v2, AllOf(SizeIs(1u), CapacityIs(original_capacity_v2),
1266                            ElementsAre(3)));
1267    }
1268  }
1269  TEST(InitializerListAssign, SimpleTypeDoesNotFitInlineBacking) {
1270    for (size_t original_size = 0; original_size <= 4; ++original_size) {
1271      SCOPED_TRACE(original_size);
1272      absl::InlinedVector<int, 2> v1(original_size, 12345);
1273      v1.assign({3, 4, 5});
1274      EXPECT_THAT(v1, AllOf(SizeIs(3u), ElementsAre(3, 4, 5)));
1275      EXPECT_LE(3u, v1.capacity());
1276      absl::InlinedVector<int, 2> v2(original_size, 12345);
1277      v2 = {3, 4, 5};
1278      EXPECT_THAT(v2, AllOf(SizeIs(3u), ElementsAre(3, 4, 5)));
1279      EXPECT_LE(3u, v2.capacity());
1280    }
1281  }
1282  TEST(InitializerListAssign, DisparateTypesInList) {
1283    absl::InlinedVector<int, 2> v_int1;
1284    v_int1.assign({-7, 8ULL});
1285    EXPECT_THAT(v_int1, ElementsAre(-7, 8));
1286    absl::InlinedVector<int, 2> v_int2;
1287    v_int2 = {-7, 8ULL};
1288    EXPECT_THAT(v_int2, ElementsAre(-7, 8));
1289    absl::InlinedVector<std::string, 2> v_string1;
1290    v_string1.assign({"foo", std::string("bar")});
1291    EXPECT_THAT(v_string1, ElementsAre("foo", "bar"));
1292    absl::InlinedVector<std::string, 2> v_string2;
1293    v_string2 = {"foo", std::string("bar")};
1294    EXPECT_THAT(v_string2, ElementsAre("foo", "bar"));
1295  }
1296  TYPED_TEST_P(InstanceTest, InitializerListAssign) {
1297    using Instance = TypeParam;
1298    for (size_t original_size = 0; original_size <= 4; ++original_size) {
1299      SCOPED_TRACE(original_size);
1300      absl::InlinedVector<Instance, 2> v(original_size, Instance(12345));
1301      const size_t original_capacity = v.capacity();
1302      v.assign({Instance(3)});
1303      EXPECT_THAT(v, AllOf(SizeIs(1u), CapacityIs(original_capacity),
1304                           ElementsAre(ValueIs(3))));
1305    }
1306    for (size_t original_size = 0; original_size <= 4; ++original_size) {
1307      SCOPED_TRACE(original_size);
1308      absl::InlinedVector<Instance, 2> v(original_size, Instance(12345));
1309      v.assign({Instance(3), Instance(4), Instance(5)});
1310      EXPECT_THAT(
1311          v, AllOf(SizeIs(3u), ElementsAre(ValueIs(3), ValueIs(4), ValueIs(5))));
1312      EXPECT_LE(3u, v.capacity());
1313    }
1314  }
1315  REGISTER_TYPED_TEST_SUITE_P(InstanceTest, Swap, CountConstructorsDestructors,
1316                              CountConstructorsDestructorsOnCopyConstruction,
1317                              CountConstructorsDestructorsOnMoveConstruction,
1318                              CountConstructorsDestructorsOnAssignment,
1319                              CountConstructorsDestructorsOnMoveAssignment,
1320                              CountElemAssignInlineBacking, RangedConstructor,
1321                              RangedAssign, InitializerListAssign);
1322  using InstanceTypes =
1323      ::testing::Types<CopyableOnlyInstance, CopyableMovableInstance>;
1324  INSTANTIATE_TYPED_TEST_SUITE_P(InstanceTestOnTypes, InstanceTest,
1325                                 InstanceTypes);
1326  TEST(DynamicVec, DynamicVecCompiles) {
1327    DynamicVec v;
1328    (void)v;
1329  }
1330  TEST(AllocatorSupportTest, Constructors) {
1331    using MyAlloc = CountingAllocator<int>;
1332    using AllocVec = absl::InlinedVector<int, 4, MyAlloc>;
1333    const int ia[] = {0, 1, 2, 3, 4, 5, 6, 7};
1334    int64_t allocated = 0;
1335    MyAlloc alloc(&allocated);
1336    { AllocVec ABSL_ATTRIBUTE_UNUSED v; }
1337    { AllocVec ABSL_ATTRIBUTE_UNUSED v(alloc); }
1338    { AllocVec ABSL_ATTRIBUTE_UNUSED v(ia, ia + ABSL_ARRAYSIZE(ia), alloc); }
1339    { AllocVec ABSL_ATTRIBUTE_UNUSED v({1, 2, 3}, alloc); }
1340    AllocVec v2;
1341    { AllocVec ABSL_ATTRIBUTE_UNUSED v(v2, alloc); }
1342    { AllocVec ABSL_ATTRIBUTE_UNUSED v(std::move(v2), alloc); }
1343  }
1344  TEST(AllocatorSupportTest, CountAllocations) {
1345    using MyAlloc = CountingAllocator<int>;
1346    using AllocVec = absl::InlinedVector<int, 4, MyAlloc>;
1347    const int ia[] = {0, 1, 2, 3, 4, 5, 6, 7};
1348    int64_t allocated = 0;
1349    MyAlloc alloc(&allocated);
1350    {
1351      AllocVec ABSL_ATTRIBUTE_UNUSED v(ia, ia + 4, alloc);
1352      EXPECT_THAT(allocated, Eq(0));
1353    }
1354    EXPECT_THAT(allocated, Eq(0));
1355    {
1356      AllocVec ABSL_ATTRIBUTE_UNUSED v(ia, ia + ABSL_ARRAYSIZE(ia), alloc);
1357      EXPECT_THAT(allocated, Eq(static_cast<int64_t>(v.size() * sizeof(int))));
1358    }
1359    EXPECT_THAT(allocated, Eq(0));
1360    {
1361      AllocVec v(4, 1, alloc);
1362      EXPECT_THAT(allocated, Eq(0));
1363      int64_t allocated2 = 0;
1364      MyAlloc alloc2(&allocated2);
1365      AllocVec v2(v, alloc2);
1366      EXPECT_THAT(allocated2, Eq(0));
1367      int64_t allocated3 = 0;
1368      MyAlloc alloc3(&allocated3);
1369      AllocVec v3(std::move(v), alloc3);
1370      EXPECT_THAT(allocated3, Eq(0));
1371    }
1372    EXPECT_THAT(allocated, 0);
1373    {
1374      AllocVec v(8, 2, alloc);
1375      EXPECT_THAT(allocated, Eq(static_cast<int64_t>(v.size() * sizeof(int))));
1376      int64_t allocated2 = 0;
1377      MyAlloc alloc2(&allocated2);
1378      AllocVec v2(v, alloc2);
1379      EXPECT_THAT(allocated2, Eq(static_cast<int64_t>(v2.size() * sizeof(int))));
1380      int64_t allocated3 = 0;
1381      MyAlloc alloc3(&allocated3);
1382      AllocVec v3(std::move(v), alloc3);
1383      EXPECT_THAT(allocated3, Eq(static_cast<int64_t>(v3.size() * sizeof(int))));
1384    }
1385    EXPECT_EQ(allocated, 0);
1386    {
1387      AllocVec v(8, 2, alloc);
1388      EXPECT_EQ(allocated, static_cast<int64_t>(8 * sizeof(int)));
1389      v.resize(5);
1390      EXPECT_EQ(allocated, static_cast<int64_t>(8 * sizeof(int)));
1391      v.shrink_to_fit();
1392      EXPECT_EQ(allocated, static_cast<int64_t>(5 * sizeof(int)));
1393      v.resize(4);
1394      EXPECT_EQ(allocated, static_cast<int64_t>(5 * sizeof(int)));
1395      v.shrink_to_fit();
1396      EXPECT_EQ(allocated, 0);
1397    }
1398  }
1399  TEST(AllocatorSupportTest, SwapBothAllocated) {
1400    using MyAlloc = CountingAllocator<int>;
1401    using AllocVec = absl::InlinedVector<int, 4, MyAlloc>;
1402    int64_t allocated1 = 0;
1403    int64_t allocated2 = 0;
1404    {
1405      const int ia1[] = {0, 1, 2, 3, 4, 5, 6, 7};
1406      const int ia2[] = {0, 1, 2, 3, 4, 5, 6, 7, 8};
1407      MyAlloc a1(&allocated1);
1408      MyAlloc a2(&allocated2);
1409      AllocVec v1(ia1, ia1 + ABSL_ARRAYSIZE(ia1), a1);
1410      AllocVec v2(ia2, ia2 + ABSL_ARRAYSIZE(ia2), a2);
1411      EXPECT_LT(v1.capacity(), v2.capacity());
1412      EXPECT_THAT(allocated1,
1413                  Eq(static_cast<int64_t>(v1.capacity() * sizeof(int))));
1414      EXPECT_THAT(allocated2,
1415                  Eq(static_cast<int64_t>(v2.capacity() * sizeof(int))));
1416      v1.swap(v2);
1417      EXPECT_THAT(v1, ElementsAreArray(ia2));
1418      EXPECT_THAT(v2, ElementsAreArray(ia1));
1419      EXPECT_THAT(allocated1,
1420                  Eq(static_cast<int64_t>(v2.capacity() * sizeof(int))));
1421      EXPECT_THAT(allocated2,
1422                  Eq(static_cast<int64_t>(v1.capacity() * sizeof(int))));
1423    }
1424    EXPECT_THAT(allocated1, 0);
1425    EXPECT_THAT(allocated2, 0);
1426  }
1427  TEST(AllocatorSupportTest, SwapOneAllocated) {
1428    using MyAlloc = CountingAllocator<int>;
1429    using AllocVec = absl::InlinedVector<int, 4, MyAlloc>;
1430    int64_t allocated1 = 0;
1431    int64_t allocated2 = 0;
1432    {
1433      const int ia1[] = {0, 1, 2, 3, 4, 5, 6, 7};
1434      const int ia2[] = {0, 1, 2, 3};
1435      MyAlloc a1(&allocated1);
1436      MyAlloc a2(&allocated2);
1437      AllocVec v1(ia1, ia1 + ABSL_ARRAYSIZE(ia1), a1);
1438      AllocVec v2(ia2, ia2 + ABSL_ARRAYSIZE(ia2), a2);
1439      EXPECT_THAT(allocated1,
1440                  Eq(static_cast<int64_t>(v1.capacity() * sizeof(int))));
1441      EXPECT_THAT(allocated2, Eq(0));
1442      v1.swap(v2);
1443      EXPECT_THAT(v1, ElementsAreArray(ia2));
1444      EXPECT_THAT(v2, ElementsAreArray(ia1));
1445      EXPECT_THAT(allocated1,
1446                  Eq(static_cast<int64_t>(v2.capacity() * sizeof(int))));
1447      EXPECT_THAT(allocated2, Eq(0));
1448      EXPECT_TRUE(v2.get_allocator() == a1);
1449      EXPECT_TRUE(v1.get_allocator() == a2);
1450    }
1451    EXPECT_THAT(allocated1, 0);
1452    EXPECT_THAT(allocated2, 0);
1453  }
1454  TEST(AllocatorSupportTest, ScopedAllocatorWorksInlined) {
1455    using StdVector = std::vector<int, CountingAllocator<int>>;
1456    using Alloc = CountingAllocator<StdVector>;
1457    using ScopedAlloc = std::scoped_allocator_adaptor<Alloc>;
1458    using AllocVec = absl::InlinedVector<StdVector, 1, ScopedAlloc>;
1459    int64_t total_allocated_byte_count = 0;
1460    AllocVec inlined_case(ScopedAlloc(Alloc(+&total_allocated_byte_count)));
1461    inlined_case.emplace_back();
1462    int64_t absl_responsible_for_count = total_allocated_byte_count;
1463  #if !defined(_MSC_VER)
1464    EXPECT_EQ(absl_responsible_for_count, 0);
1465  #endif  
1466    inlined_case[0].emplace_back();
1467    EXPECT_GT(total_allocated_byte_count, absl_responsible_for_count);
1468    inlined_case.clear();
1469    inlined_case.shrink_to_fit();
1470    EXPECT_EQ(total_allocated_byte_count, 0);
1471  }
1472  TEST(AllocatorSupportTest, ScopedAllocatorWorksAllocated) {
1473    using StdVector = std::vector<int, CountingAllocator<int>>;
1474    using Alloc = CountingAllocator<StdVector>;
1475    using ScopedAlloc = std::scoped_allocator_adaptor<Alloc>;
1476    using AllocVec = absl::InlinedVector<StdVector, 1, ScopedAlloc>;
1477    int64_t total_allocated_byte_count = 0;
1478    AllocVec allocated_case(ScopedAlloc(Alloc(+&total_allocated_byte_count)));
1479    allocated_case.emplace_back();
1480    allocated_case.emplace_back();
1481    int64_t absl_responsible_for_count = total_allocated_byte_count;
1482    EXPECT_GT(absl_responsible_for_count, 0);
1483    allocated_case[1].emplace_back();
1484    EXPECT_GT(total_allocated_byte_count, absl_responsible_for_count);
1485    allocated_case.clear();
1486    allocated_case.shrink_to_fit();
1487    EXPECT_EQ(total_allocated_byte_count, 0);
1488  }
1489  TEST(AllocatorSupportTest, SizeAllocConstructor) {
1490    constexpr size_t inlined_size = 4;
1491    using Alloc = CountingAllocator<int>;
1492    using AllocVec = absl::InlinedVector<int, inlined_size, Alloc>;
1493    {
1494      auto len = inlined_size / 2;
1495      int64_t allocated = 0;
1496      auto v = AllocVec(len, Alloc(&allocated));
1497      EXPECT_THAT(allocated, Eq(0));
1498      EXPECT_THAT(v, AllOf(SizeIs(len), Each(0)));
1499    }
1500    {
1501      auto len = inlined_size * 2;
1502      int64_t allocated = 0;
1503      auto v = AllocVec(len, Alloc(&allocated));
1504      EXPECT_THAT(allocated, Eq(static_cast<int64_t>(len * sizeof(int))));
1505      EXPECT_THAT(v, AllOf(SizeIs(len), Each(0)));
1506    }
1507  }
1508  TEST(InlinedVectorTest, MinimumAllocatorCompilesUsingTraits) {
1509    using T = int;
1510    using A = std::allocator<T>;
1511    using ATraits = absl::allocator_traits<A>;
1512    struct MinimumAllocator {
1513      using value_type = T;
1514      value_type* allocate(size_t n) {
1515        A a;
1516        return ATraits::allocate(a, n);
1517      }
1518      void deallocate(value_type* p, size_t n) {
1519        A a;
1520        ATraits::deallocate(a, p, n);
1521      }
1522    };
1523    absl::InlinedVector<T, 1, MinimumAllocator> vec;
1524    vec.emplace_back();
1525    vec.resize(0);
1526  }
1527  TEST(InlinedVectorTest, AbslHashValueWorks) {
1528    using V = absl::InlinedVector<int, 4>;
1529    std::vector<V> cases;
1530    for (size_t i = 0; i < 10; ++i) {
1531      V v;
1532      for (int j = 0; j < static_cast<int>(i); ++j) {
1533        v.push_back(j);
1534      }
1535      cases.push_back(v);
1536      v.resize(i % 4);
1537      cases.push_back(v);
1538    }
1539    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(cases));
1540  }
1541  class MoveConstructibleOnlyInstance
1542      : public absl::test_internal::BaseCountedInstance {
1543   public:
1544    explicit MoveConstructibleOnlyInstance(int x) : BaseCountedInstance(x) {}
1545    MoveConstructibleOnlyInstance(MoveConstructibleOnlyInstance&& other) =
1546        default;
1547    MoveConstructibleOnlyInstance& operator=(
1548        MoveConstructibleOnlyInstance&& other) = delete;
1549  };
1550  MATCHER(HasValue, "") {
1551    return ::testing::get<0>(arg).value() == ::testing::get<1>(arg);
1552  }
1553  TEST(NonAssignableMoveAssignmentTest, AllocatedToInline) {
1554    using X = MoveConstructibleOnlyInstance;
1555    InstanceTracker tracker;
1556    absl::InlinedVector<X, 2> inlined;
1557    inlined.emplace_back(1);
1558    absl::InlinedVector<X, 2> allocated;
1559    allocated.emplace_back(1);
1560    allocated.emplace_back(2);
1561    allocated.emplace_back(3);
1562    tracker.ResetCopiesMovesSwaps();
1563    inlined = std::move(allocated);
1564    EXPECT_EQ(tracker.moves(), 0);
1565    EXPECT_EQ(tracker.live_instances(), 3);
1566    EXPECT_THAT(inlined, Pointwise(HasValue(), {1, 2, 3}));
1567  }
1568  TEST(NonAssignableMoveAssignmentTest, InlineToAllocated) {
1569    using X = MoveConstructibleOnlyInstance;
1570    InstanceTracker tracker;
1571    absl::InlinedVector<X, 2> inlined;
1572    inlined.emplace_back(1);
1573    absl::InlinedVector<X, 2> allocated;
1574    allocated.emplace_back(1);
1575    allocated.emplace_back(2);
1576    allocated.emplace_back(3);
1577    tracker.ResetCopiesMovesSwaps();
1578    allocated = std::move(inlined);
1579    EXPECT_EQ(tracker.moves(), 1);
1580    EXPECT_EQ(tracker.live_instances(), 1);
1581    EXPECT_THAT(allocated, Pointwise(HasValue(), {1}));
1582  }
1583  TEST(NonAssignableMoveAssignmentTest, InlineToInline) {
1584    using X = MoveConstructibleOnlyInstance;
1585    InstanceTracker tracker;
1586    absl::InlinedVector<X, 2> inlined_a;
1587    inlined_a.emplace_back(1);
1588    absl::InlinedVector<X, 2> inlined_b;
1589    inlined_b.emplace_back(1);
1590    tracker.ResetCopiesMovesSwaps();
1591    inlined_a = std::move(inlined_b);
1592    EXPECT_EQ(tracker.moves(), 1);
1593    EXPECT_EQ(tracker.live_instances(), 1);
1594    EXPECT_THAT(inlined_a, Pointwise(HasValue(), {1}));
1595  }
1596  TEST(NonAssignableMoveAssignmentTest, AllocatedToAllocated) {
1597    using X = MoveConstructibleOnlyInstance;
1598    InstanceTracker tracker;
1599    absl::InlinedVector<X, 2> allocated_a;
1600    allocated_a.emplace_back(1);
1601    allocated_a.emplace_back(2);
1602    allocated_a.emplace_back(3);
1603    absl::InlinedVector<X, 2> allocated_b;
1604    allocated_b.emplace_back(4);
1605    allocated_b.emplace_back(5);
1606    allocated_b.emplace_back(6);
1607    allocated_b.emplace_back(7);
1608    tracker.ResetCopiesMovesSwaps();
1609    allocated_a = std::move(allocated_b);
1610    EXPECT_EQ(tracker.moves(), 0);
1611    EXPECT_EQ(tracker.live_instances(), 4);
1612    EXPECT_THAT(allocated_a, Pointwise(HasValue(), {4, 5, 6, 7}));
1613  }
1614  TEST(NonAssignableMoveAssignmentTest, AssignThis) {
1615    using X = MoveConstructibleOnlyInstance;
1616    InstanceTracker tracker;
1617    absl::InlinedVector<X, 2> v;
1618    v.emplace_back(1);
1619    v.emplace_back(2);
1620    v.emplace_back(3);
1621    tracker.ResetCopiesMovesSwaps();
1622    v = std::move(*std::addressof(v));
1623    EXPECT_EQ(tracker.moves(), 0);
1624    EXPECT_EQ(tracker.live_instances(), 3);
1625    EXPECT_THAT(v, Pointwise(HasValue(), {1, 2, 3}));
1626  }
1627  class NonSwappableInstance : public absl::test_internal::BaseCountedInstance {
1628   public:
1629    explicit NonSwappableInstance(int x) : BaseCountedInstance(x) {}
1630    NonSwappableInstance(const NonSwappableInstance& other) = default;
1631    NonSwappableInstance& operator=(const NonSwappableInstance& other) = default;
1632    NonSwappableInstance(NonSwappableInstance&& other) = default;
1633    NonSwappableInstance& operator=(NonSwappableInstance&& other) = default;
1634  };
1635  void swap(NonSwappableInstance&, NonSwappableInstance&) = delete;
1636  TEST(NonSwappableSwapTest, InlineAndAllocatedTransferStorageAndMove) {
1637    using X = NonSwappableInstance;
1638    InstanceTracker tracker;
1639    absl::InlinedVector<X, 2> inlined;
1640    inlined.emplace_back(1);
1641    absl::InlinedVector<X, 2> allocated;
1642    allocated.emplace_back(1);
1643    allocated.emplace_back(2);
1644    allocated.emplace_back(3);
1645    tracker.ResetCopiesMovesSwaps();
1646    inlined.swap(allocated);
1647    EXPECT_EQ(tracker.moves(), 1);
1648    EXPECT_EQ(tracker.live_instances(), 4);
1649    EXPECT_THAT(inlined, Pointwise(HasValue(), {1, 2, 3}));
1650  }
1651  TEST(NonSwappableSwapTest, InlineAndInlineMoveIndividualElements) {
1652    using X = NonSwappableInstance;
1653    InstanceTracker tracker;
1654    absl::InlinedVector<X, 2> inlined_a;
1655    inlined_a.emplace_back(1);
1656    absl::InlinedVector<X, 2> inlined_b;
1657    inlined_b.emplace_back(2);
1658    tracker.ResetCopiesMovesSwaps();
1659    inlined_a.swap(inlined_b);
1660    EXPECT_EQ(tracker.moves(), 3);
1661    EXPECT_EQ(tracker.live_instances(), 2);
1662    EXPECT_THAT(inlined_a, Pointwise(HasValue(), {2}));
1663    EXPECT_THAT(inlined_b, Pointwise(HasValue(), {1}));
1664  }
1665  TEST(NonSwappableSwapTest, AllocatedAndAllocatedOnlyTransferStorage) {
1666    using X = NonSwappableInstance;
1667    InstanceTracker tracker;
1668    absl::InlinedVector<X, 2> allocated_a;
1669    allocated_a.emplace_back(1);
1670    allocated_a.emplace_back(2);
1671    allocated_a.emplace_back(3);
1672    absl::InlinedVector<X, 2> allocated_b;
1673    allocated_b.emplace_back(4);
1674    allocated_b.emplace_back(5);
1675    allocated_b.emplace_back(6);
1676    allocated_b.emplace_back(7);
1677    tracker.ResetCopiesMovesSwaps();
1678    allocated_a.swap(allocated_b);
1679    EXPECT_EQ(tracker.moves(), 0);
1680    EXPECT_EQ(tracker.live_instances(), 7);
1681    EXPECT_THAT(allocated_a, Pointwise(HasValue(), {4, 5, 6, 7}));
1682    EXPECT_THAT(allocated_b, Pointwise(HasValue(), {1, 2, 3}));
1683  }
1684  TEST(NonSwappableSwapTest, SwapThis) {
1685    using X = NonSwappableInstance;
1686    InstanceTracker tracker;
1687    absl::InlinedVector<X, 2> v;
1688    v.emplace_back(1);
1689    v.emplace_back(2);
1690    v.emplace_back(3);
1691    tracker.ResetCopiesMovesSwaps();
1692    v.swap(v);
1693    EXPECT_EQ(tracker.moves(), 0);
1694    EXPECT_EQ(tracker.live_instances(), 3);
1695    EXPECT_THAT(v, Pointwise(HasValue(), {1, 2, 3}));
1696  }
1697  template <size_t N>
1698  using CharVec = absl::InlinedVector<char, N>;
1699  template <typename T>
1700  struct MySpan {
1701    T* data;
1702    size_t size;
1703  };
1704  TEST(StorageTest, InlinedCapacityAutoIncrease) {
1705    EXPECT_GT(CharVec<1>().capacity(), 1);
1706    EXPECT_EQ(CharVec<1>().capacity(), sizeof(MySpan<char>));
1707    EXPECT_EQ(CharVec<1>().capacity(), CharVec<2>().capacity());
1708    EXPECT_EQ(sizeof(CharVec<1>), sizeof(CharVec<2>));
1709    EXPECT_GT((absl::InlinedVector<int, 1>().capacity()), 1);
1710    EXPECT_EQ((absl::InlinedVector<int, 1>().capacity()),
1711              sizeof(MySpan<int>) / sizeof(int));
1712  }
1713  }  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-span_test.cc</h3>
            <pre><code>1  #include "absl/types/span.h"
2  #include <array>
3  #include <initializer_list>
4  #include <numeric>
5  #include <stdexcept>
6  #include <string>
7  #include <type_traits>
8  #include <vector>
9  #include "gmock/gmock.h"
10  #include "gtest/gtest.h"
11  #include "absl/base/attributes.h"
12  #include "absl/base/config.h"
13  #include "absl/base/internal/exception_testing.h"
14  #include "absl/base/options.h"
15  #include "absl/container/fixed_array.h"
16  #include "absl/container/inlined_vector.h"
17  #include "absl/hash/hash_testing.h"
18  #include "absl/strings/str_cat.h"
19  namespace {
20  MATCHER_P(DataIs, data,
21            absl::StrCat("data() ", negation ? "isn't " : "is ",
22                         testing::PrintToString(data))) {
23    return arg.data() == data;
24  }
25  template <typename T>
26  auto SpanIs(T data, size_t size)
27      -> decltype(testing::AllOf(DataIs(data), testing::SizeIs(size))) {
28    return testing::AllOf(DataIs(data), testing::SizeIs(size));
29  }
30  template <typename Container>
31  auto SpanIs(const Container& c) -> decltype(SpanIs(c.data(), c.size())) {
32    return SpanIs(c.data(), c.size());
33  }
34  std::vector<int> MakeRamp(int len, int offset = 0) {
35    std::vector<int> v(len);
36    std::iota(v.begin(), v.end(), offset);
37    return v;
38  }
39  TEST(IntSpan, EmptyCtors) {
40    absl::Span<int> s;
41    EXPECT_THAT(s, SpanIs(nullptr, 0));
42  }
43  TEST(IntSpan, PtrLenCtor) {
44    int a[] = {1, 2, 3};
45    absl::Span<int> s(&a[0], 2);
46    EXPECT_THAT(s, SpanIs(a, 2));
47  }
48  TEST(IntSpan, ArrayCtor) {
49    int a[] = {1, 2, 3};
50    absl::Span<int> s(a);
51    EXPECT_THAT(s, SpanIs(a, 3));
52    EXPECT_TRUE((std::is_constructible<absl::Span<const int>, int[3]>::value));
53    EXPECT_TRUE(
54        (std::is_constructible<absl::Span<const int>, const int[3]>::value));
55    EXPECT_FALSE((std::is_constructible<absl::Span<int>, const int[3]>::value));
56    EXPECT_TRUE((std::is_convertible<int[3], absl::Span<const int>>::value));
57    EXPECT_TRUE(
58        (std::is_convertible<const int[3], absl::Span<const int>>::value));
59  }
60  template <typename T>
61  void TakesGenericSpan(absl::Span<T>) {}
62  TEST(IntSpan, ContainerCtor) {
63    std::vector<int> empty;
64    absl::Span<int> s_empty(empty);
65    EXPECT_THAT(s_empty, SpanIs(empty));
66    std::vector<int> filled{1, 2, 3};
67    absl::Span<int> s_filled(filled);
68    EXPECT_THAT(s_filled, SpanIs(filled));
69    absl::Span<int> s_from_span(filled);
70    EXPECT_THAT(s_from_span, SpanIs(s_filled));
71    absl::Span<const int> const_filled = filled;
72    EXPECT_THAT(const_filled, SpanIs(filled));
73    absl::Span<const int> const_from_span = s_filled;
74    EXPECT_THAT(const_from_span, SpanIs(s_filled));
75    EXPECT_TRUE(
76        (std::is_convertible<std::vector<int>&, absl::Span<const int>>::value));
77    EXPECT_TRUE(
78        (std::is_convertible<absl::Span<int>&, absl::Span<const int>>::value));
79    TakesGenericSpan(absl::Span<int>(filled));
80  }
81  struct ContainerWithShallowConstData {
82    std::vector<int> storage;
83    int* data() const { return const_cast<int*>(storage.data()); }
84    int size() const { return storage.size(); }
85  };
86  TEST(IntSpan, ShallowConstness) {
87    const ContainerWithShallowConstData c{MakeRamp(20)};
88    absl::Span<int> s(
89        c);  
90    s[0] = -1;
91    EXPECT_EQ(c.storage[0], -1);
92  }
93  TEST(CharSpan, StringCtor) {
94    std::string empty = "";
95    absl::Span<char> s_empty(empty);
96    EXPECT_THAT(s_empty, SpanIs(empty));
97    std::string abc = "abc";
98    absl::Span<char> s_abc(abc);
99    EXPECT_THAT(s_abc, SpanIs(abc));
100    absl::Span<const char> s_const_abc = abc;
101    EXPECT_THAT(s_const_abc, SpanIs(abc));
102    EXPECT_FALSE((std::is_constructible<absl::Span<int>, std::string>::value));
103    EXPECT_FALSE(
104        (std::is_constructible<absl::Span<const int>, std::string>::value));
105    EXPECT_TRUE(
106        (std::is_convertible<std::string, absl::Span<const char>>::value));
107  }
108  TEST(IntSpan, FromConstPointer) {
109    EXPECT_TRUE((std::is_constructible<absl::Span<const int* const>,
110                                       std::vector<int*>>::value));
111    EXPECT_TRUE((std::is_constructible<absl::Span<const int* const>,
112                                       std::vector<const int*>>::value));
113    EXPECT_FALSE((
114        std::is_constructible<absl::Span<const int*>, std::vector<int*>>::value));
115    EXPECT_FALSE((
116        std::is_constructible<absl::Span<int*>, std::vector<const int*>>::value));
117  }
118  struct TypeWithMisleadingData {
119    int& data() { return i; }
120    int size() { return 1; }
121    int i;
122  };
123  struct TypeWithMisleadingSize {
124    int* data() { return &i; }
125    const char* size() { return "1"; }
126    int i;
127  };
128  TEST(IntSpan, EvilTypes) {
129    EXPECT_FALSE(
130        (std::is_constructible<absl::Span<int>, TypeWithMisleadingData&>::value));
131    EXPECT_FALSE(
132        (std::is_constructible<absl::Span<int>, TypeWithMisleadingSize&>::value));
133  }
134  struct Base {
135    int* data() { return &i; }
136    int size() { return 1; }
137    int i;
138  };
139  struct Derived : Base {};
140  TEST(IntSpan, SpanOfDerived) {
141    EXPECT_TRUE((std::is_constructible<absl::Span<int>, Base&>::value));
142    EXPECT_TRUE((std::is_constructible<absl::Span<int>, Derived&>::value));
143    EXPECT_FALSE(
144        (std::is_constructible<absl::Span<Base>, std::vector<Derived>>::value));
145  }
146  void TestInitializerList(absl::Span<const int> s, const std::vector<int>& v) {
147    EXPECT_TRUE(std::equal(s.begin(), s.end(), v.begin(), v.end()));
148  }
149  TEST(ConstIntSpan, InitializerListConversion) {
150    TestInitializerList({}, {});
151    TestInitializerList({1}, {1});
152    TestInitializerList({1, 2, 3}, {1, 2, 3});
153    EXPECT_FALSE((std::is_constructible<absl::Span<int>,
154                                        std::initializer_list<int>>::value));
155    EXPECT_FALSE((
156        std::is_convertible<absl::Span<int>, std::initializer_list<int>>::value));
157  }
158  TEST(IntSpan, Data) {
159    int i;
160    absl::Span<int> s(&i, 1);
161    EXPECT_EQ(&i, s.data());
162  }
163  TEST(IntSpan, SizeLengthEmpty) {
164    absl::Span<int> empty;
165    EXPECT_EQ(empty.size(), 0);
166    EXPECT_TRUE(empty.empty());
167    EXPECT_EQ(empty.size(), empty.length());
168    auto v = MakeRamp(10);
169    absl::Span<int> s(v);
170    EXPECT_EQ(s.size(), 10);
171    EXPECT_FALSE(s.empty());
172    EXPECT_EQ(s.size(), s.length());
173  }
174  TEST(IntSpan, ElementAccess) {
175    auto v = MakeRamp(10);
176    absl::Span<int> s(v);
177    for (int i = 0; i < s.size(); ++i) {
178      EXPECT_EQ(s[i], s.at(i));
179    }
180    EXPECT_EQ(s.front(), s[0]);
181    EXPECT_EQ(s.back(), s[9]);
182  #if !defined(NDEBUG) || ABSL_OPTION_HARDENED
183    EXPECT_DEATH_IF_SUPPORTED(s[-1], "");
184    EXPECT_DEATH_IF_SUPPORTED(s[10], "");
185  #endif
186  }
187  TEST(IntSpan, AtThrows) {
188    auto v = MakeRamp(10);
189    absl::Span<int> s(v);
190    EXPECT_EQ(s.at(9), 9);
<span onclick='openModal()' class='match'>191    ABSL_BASE_INTERNAL_EXPECT_FAIL(s.at(10), std::out_of_range,
192                                   "failed bounds check");
193  }
194  TEST(IntSpan, RemovePrefixAndSuffix) {
195    auto v = MakeRamp(20, 1);
</span>196    absl::Span<int> s(v);
197    EXPECT_EQ(s.size(), 20);
198    s.remove_suffix(0);
199    s.remove_prefix(0);
200    EXPECT_EQ(s.size(), 20);
201    s.remove_prefix(1);
202    EXPECT_EQ(s.size(), 19);
203    EXPECT_EQ(s[0], 2);
204    s.remove_suffix(1);
205    EXPECT_EQ(s.size(), 18);
206    EXPECT_EQ(s.back(), 19);
207    s.remove_prefix(7);
208    EXPECT_EQ(s.size(), 11);
209    EXPECT_EQ(s[0], 9);
210    s.remove_suffix(11);
211    EXPECT_EQ(s.size(), 0);
212    EXPECT_EQ(v, MakeRamp(20, 1));
213  #if !defined(NDEBUG) || ABSL_OPTION_HARDENED
214    absl::Span<int> prefix_death(v);
215    EXPECT_DEATH_IF_SUPPORTED(prefix_death.remove_prefix(21), "");
216    absl::Span<int> suffix_death(v);
217    EXPECT_DEATH_IF_SUPPORTED(suffix_death.remove_suffix(21), "");
218  #endif
219  }
220  TEST(IntSpan, Subspan) {
221    std::vector<int> empty;
222    EXPECT_EQ(absl::MakeSpan(empty).subspan(), empty);
223    EXPECT_THAT(absl::MakeSpan(empty).subspan(0, 0), SpanIs(empty));
224    EXPECT_THAT(absl::MakeSpan(empty).subspan(0, absl::Span<const int>::npos),
225                SpanIs(empty));
226    auto ramp = MakeRamp(10);
227    EXPECT_THAT(absl::MakeSpan(ramp).subspan(), SpanIs(ramp));
228    EXPECT_THAT(absl::MakeSpan(ramp).subspan(0, 10), SpanIs(ramp));
229    EXPECT_THAT(absl::MakeSpan(ramp).subspan(0, absl::Span<const int>::npos),
230                SpanIs(ramp));
231    EXPECT_THAT(absl::MakeSpan(ramp).subspan(0, 3), SpanIs(ramp.data(), 3));
232    EXPECT_THAT(absl::MakeSpan(ramp).subspan(5, absl::Span<const int>::npos),
233                SpanIs(ramp.data() + 5, 5));
234    EXPECT_THAT(absl::MakeSpan(ramp).subspan(3, 3), SpanIs(ramp.data() + 3, 3));
235    EXPECT_THAT(absl::MakeSpan(ramp).subspan(10, 5), SpanIs(ramp.data() + 10, 0));
236  #ifdef ABSL_HAVE_EXCEPTIONS
237    EXPECT_THROW(absl::MakeSpan(ramp).subspan(11, 5), std::out_of_range);
238  #else
239    EXPECT_DEATH_IF_SUPPORTED(absl::MakeSpan(ramp).subspan(11, 5), "");
240  #endif
241  }
242  TEST(IntSpan, First) {
243    std::vector<int> empty;
244    EXPECT_THAT(absl::MakeSpan(empty).first(0), SpanIs(empty));
245    auto ramp = MakeRamp(10);
246    EXPECT_THAT(absl::MakeSpan(ramp).first(0), SpanIs(ramp.data(), 0));
247    EXPECT_THAT(absl::MakeSpan(ramp).first(10), SpanIs(ramp));
248    EXPECT_THAT(absl::MakeSpan(ramp).first(3), SpanIs(ramp.data(), 3));
249  #ifdef ABSL_HAVE_EXCEPTIONS
250    EXPECT_THROW(absl::MakeSpan(ramp).first(11), std::out_of_range);
251  #else
252    EXPECT_DEATH_IF_SUPPORTED(absl::MakeSpan(ramp).first(11), "");
253  #endif
254  }
255  TEST(IntSpan, Last) {
256    std::vector<int> empty;
257    EXPECT_THAT(absl::MakeSpan(empty).last(0), SpanIs(empty));
258    auto ramp = MakeRamp(10);
259    EXPECT_THAT(absl::MakeSpan(ramp).last(0), SpanIs(ramp.data() + 10, 0));
260    EXPECT_THAT(absl::MakeSpan(ramp).last(10), SpanIs(ramp));
261    EXPECT_THAT(absl::MakeSpan(ramp).last(3), SpanIs(ramp.data() + 7, 3));
262  #ifdef ABSL_HAVE_EXCEPTIONS
263    EXPECT_THROW(absl::MakeSpan(ramp).last(11), std::out_of_range);
264  #else
265    EXPECT_DEATH_IF_SUPPORTED(absl::MakeSpan(ramp).last(11), "");
266  #endif
267  }
268  TEST(IntSpan, MakeSpanPtrLength) {
269    std::vector<int> empty;
270    auto s_empty = absl::MakeSpan(empty.data(), empty.size());
271    EXPECT_THAT(s_empty, SpanIs(empty));
272    std::array<int, 3> a{{1, 2, 3}};
273    auto s = absl::MakeSpan(a.data(), a.size());
274    EXPECT_THAT(s, SpanIs(a));
275    EXPECT_THAT(absl::MakeConstSpan(empty.data(), empty.size()), SpanIs(s_empty));
276    EXPECT_THAT(absl::MakeConstSpan(a.data(), a.size()), SpanIs(s));
277  }
278  TEST(IntSpan, MakeSpanTwoPtrs) {
279    std::vector<int> empty;
280    auto s_empty = absl::MakeSpan(empty.data(), empty.data());
281    EXPECT_THAT(s_empty, SpanIs(empty));
282    std::vector<int> v{1, 2, 3};
283    auto s = absl::MakeSpan(v.data(), v.data() + 1);
284    EXPECT_THAT(s, SpanIs(v.data(), 1));
285    EXPECT_THAT(absl::MakeConstSpan(empty.data(), empty.data()), SpanIs(s_empty));
286    EXPECT_THAT(absl::MakeConstSpan(v.data(), v.data() + 1), SpanIs(s));
287  }
288  TEST(IntSpan, MakeSpanContainer) {
289    std::vector<int> empty;
290    auto s_empty = absl::MakeSpan(empty);
291    EXPECT_THAT(s_empty, SpanIs(empty));
292    std::vector<int> v{1, 2, 3};
293    auto s = absl::MakeSpan(v);
294    EXPECT_THAT(s, SpanIs(v));
295    EXPECT_THAT(absl::MakeConstSpan(empty), SpanIs(s_empty));
296    EXPECT_THAT(absl::MakeConstSpan(v), SpanIs(s));
297    EXPECT_THAT(absl::MakeSpan(s), SpanIs(s));
298    EXPECT_THAT(absl::MakeConstSpan(s), SpanIs(s));
299  }
300  TEST(CharSpan, MakeSpanString) {
301    std::string empty = "";
302    auto s_empty = absl::MakeSpan(empty);
303    EXPECT_THAT(s_empty, SpanIs(empty));
304    std::string str = "abc";
305    auto s_str = absl::MakeSpan(str);
306    EXPECT_THAT(s_str, SpanIs(str));
307    EXPECT_THAT(absl::MakeConstSpan(empty), SpanIs(s_empty));
308    EXPECT_THAT(absl::MakeConstSpan(str), SpanIs(s_str));
309  }
310  TEST(IntSpan, MakeSpanArray) {
311    int a[] = {1, 2, 3};
312    auto s = absl::MakeSpan(a);
313    EXPECT_THAT(s, SpanIs(a, 3));
314    const int ca[] = {1, 2, 3};
315    auto s_ca = absl::MakeSpan(ca);
316    EXPECT_THAT(s_ca, SpanIs(ca, 3));
317    EXPECT_THAT(absl::MakeConstSpan(a), SpanIs(s));
318    EXPECT_THAT(absl::MakeConstSpan(ca), SpanIs(s_ca));
319  }
320  template <typename Expected, typename T>
321  void CheckType(const T& &bsol;* value */) {
322    testing::StaticAssertTypeEq<Expected, T>();
323  }
324  TEST(IntSpan, MakeSpanTypes) {
325    std::vector<int> vec;
326    const std::vector<int> cvec;
327    int a[1];
328    const int ca[] = {1};
329    int* ip = a;
330    const int* cip = ca;
331    std::string s = "";
332    const std::string cs = "";
333    CheckType<absl::Span<int>>(absl::MakeSpan(vec));
334    CheckType<absl::Span<const int>>(absl::MakeSpan(cvec));
335    CheckType<absl::Span<int>>(absl::MakeSpan(ip, ip + 1));
336    CheckType<absl::Span<int>>(absl::MakeSpan(ip, 1));
337    CheckType<absl::Span<const int>>(absl::MakeSpan(cip, cip + 1));
338    CheckType<absl::Span<const int>>(absl::MakeSpan(cip, 1));
339    CheckType<absl::Span<int>>(absl::MakeSpan(a));
340    CheckType<absl::Span<int>>(absl::MakeSpan(a, a + 1));
341    CheckType<absl::Span<int>>(absl::MakeSpan(a, 1));
342    CheckType<absl::Span<const int>>(absl::MakeSpan(ca));
343    CheckType<absl::Span<const int>>(absl::MakeSpan(ca, ca + 1));
344    CheckType<absl::Span<const int>>(absl::MakeSpan(ca, 1));
345    CheckType<absl::Span<char>>(absl::MakeSpan(s));
346    CheckType<absl::Span<const char>>(absl::MakeSpan(cs));
347  }
348  TEST(ConstIntSpan, MakeConstSpanTypes) {
349    std::vector<int> vec;
350    const std::vector<int> cvec;
351    int array[1];
352    const int carray[] = {0};
353    int* ptr = array;
354    const int* cptr = carray;
355    std::string s = "";
356    std::string cs = "";
357    CheckType<absl::Span<const int>>(absl::MakeConstSpan(vec));
358    CheckType<absl::Span<const int>>(absl::MakeConstSpan(cvec));
359    CheckType<absl::Span<const int>>(absl::MakeConstSpan(ptr, ptr + 1));
360    CheckType<absl::Span<const int>>(absl::MakeConstSpan(ptr, 1));
361    CheckType<absl::Span<const int>>(absl::MakeConstSpan(cptr, cptr + 1));
362    CheckType<absl::Span<const int>>(absl::MakeConstSpan(cptr, 1));
363    CheckType<absl::Span<const int>>(absl::MakeConstSpan(array));
364    CheckType<absl::Span<const int>>(absl::MakeConstSpan(carray));
365    CheckType<absl::Span<const char>>(absl::MakeConstSpan(s));
366    CheckType<absl::Span<const char>>(absl::MakeConstSpan(cs));
367  }
368  TEST(IntSpan, Equality) {
369    const int arr1[] = {1, 2, 3, 4, 5};
370    int arr2[] = {1, 2, 3, 4, 5};
371    std::vector<int> vec1(std::begin(arr1), std::end(arr1));
372    std::vector<int> vec2 = vec1;
373    std::vector<int> other_vec = {2, 4, 6, 8, 10};
374    const absl::Span<const int> from1 = vec1;
375    const absl::Span<const int> from2 = vec2;
376    EXPECT_EQ(from1, from1);
377    EXPECT_FALSE(from1 != from1);
378    EXPECT_EQ(from1, from2);
379    EXPECT_FALSE(from1 != from2);
380    const absl::Span<const int> from_other = other_vec;
381    EXPECT_NE(from1, from_other);
382    EXPECT_FALSE(from1 == from_other);
383    EXPECT_EQ(vec1, from1);
384    EXPECT_FALSE(vec1 != from1);
385    EXPECT_EQ(from1, vec1);
386    EXPECT_FALSE(from1 != vec1);
387    const absl::Span<int> mutable_from1(vec1);
388    const absl::Span<int> mutable_from2(vec2);
389    EXPECT_EQ(from1, mutable_from1);
390    EXPECT_EQ(mutable_from1, from1);
391    EXPECT_EQ(mutable_from1, mutable_from2);
392    EXPECT_EQ(mutable_from2, mutable_from1);
393    EXPECT_EQ(vec1, mutable_from1);
394    EXPECT_FALSE(vec1 != mutable_from1);
395    EXPECT_EQ(mutable_from1, vec1);
396    EXPECT_FALSE(mutable_from1 != vec1);
397    EXPECT_TRUE(arr1 == mutable_from1);
398    EXPECT_FALSE(arr1 != mutable_from1);
399    EXPECT_TRUE(mutable_from1 == arr1);
400    EXPECT_FALSE(mutable_from1 != arr1);
401    EXPECT_TRUE(arr2 == from1);
402    EXPECT_FALSE(arr2 != from1);
403    EXPECT_TRUE(from1 == arr2);
404    EXPECT_FALSE(from1 != arr2);
405    EXPECT_NE(from1, absl::Span<const int>(from1).subspan(0, from1.size() - 1));
406    ++vec2.back();
407    EXPECT_NE(from1, from2);
408  }
409  class IntSpanOrderComparisonTest : public testing::Test {
410   public:
411    IntSpanOrderComparisonTest()
412        : arr_before_{1, 2, 3},
413          arr_after_{1, 2, 4},
414          carr_after_{1, 2, 4},
415          vec_before_(std::begin(arr_before_), std::end(arr_before_)),
416          vec_after_(std::begin(arr_after_), std::end(arr_after_)),
417          before_(vec_before_),
418          after_(vec_after_),
419          cbefore_(vec_before_),
420          cafter_(vec_after_) {}
421   protected:
422    int arr_before_[3], arr_after_[3];
423    const int carr_after_[3];
424    std::vector<int> vec_before_, vec_after_;
425    absl::Span<int> before_, after_;
426    absl::Span<const int> cbefore_, cafter_;
427  };
428  TEST_F(IntSpanOrderComparisonTest, CompareSpans) {
429    EXPECT_TRUE(cbefore_ < cafter_);
430    EXPECT_TRUE(cbefore_ <= cafter_);
431    EXPECT_TRUE(cafter_ > cbefore_);
432    EXPECT_TRUE(cafter_ >= cbefore_);
433    EXPECT_FALSE(cbefore_ > cafter_);
434    EXPECT_FALSE(cafter_ < cbefore_);
435    EXPECT_TRUE(before_ < after_);
436    EXPECT_TRUE(before_ <= after_);
437    EXPECT_TRUE(after_ > before_);
438    EXPECT_TRUE(after_ >= before_);
439    EXPECT_FALSE(before_ > after_);
440    EXPECT_FALSE(after_ < before_);
441    EXPECT_TRUE(cbefore_ < after_);
442    EXPECT_TRUE(cbefore_ <= after_);
443    EXPECT_TRUE(after_ > cbefore_);
444    EXPECT_TRUE(after_ >= cbefore_);
445    EXPECT_FALSE(cbefore_ > after_);
446    EXPECT_FALSE(after_ < cbefore_);
447  }
448  TEST_F(IntSpanOrderComparisonTest, SpanOfConstAndContainer) {
449    EXPECT_TRUE(cbefore_ < vec_after_);
450    EXPECT_TRUE(cbefore_ <= vec_after_);
451    EXPECT_TRUE(vec_after_ > cbefore_);
452    EXPECT_TRUE(vec_after_ >= cbefore_);
453    EXPECT_FALSE(cbefore_ > vec_after_);
454    EXPECT_FALSE(vec_after_ < cbefore_);
455    EXPECT_TRUE(arr_before_ < cafter_);
456    EXPECT_TRUE(arr_before_ <= cafter_);
457    EXPECT_TRUE(cafter_ > arr_before_);
458    EXPECT_TRUE(cafter_ >= arr_before_);
459    EXPECT_FALSE(arr_before_ > cafter_);
460    EXPECT_FALSE(cafter_ < arr_before_);
461  }
462  TEST_F(IntSpanOrderComparisonTest, SpanOfMutableAndContainer) {
463    EXPECT_TRUE(vec_before_ < after_);
464    EXPECT_TRUE(vec_before_ <= after_);
465    EXPECT_TRUE(after_ > vec_before_);
466    EXPECT_TRUE(after_ >= vec_before_);
467    EXPECT_FALSE(vec_before_ > after_);
468    EXPECT_FALSE(after_ < vec_before_);
469    EXPECT_TRUE(before_ < carr_after_);
470    EXPECT_TRUE(before_ <= carr_after_);
471    EXPECT_TRUE(carr_after_ > before_);
472    EXPECT_TRUE(carr_after_ >= before_);
473    EXPECT_FALSE(before_ > carr_after_);
474    EXPECT_FALSE(carr_after_ < before_);
475  }
476  TEST_F(IntSpanOrderComparisonTest, EqualSpans) {
477    EXPECT_FALSE(before_ < before_);
478    EXPECT_TRUE(before_ <= before_);
479    EXPECT_FALSE(before_ > before_);
480    EXPECT_TRUE(before_ >= before_);
481  }
482  TEST_F(IntSpanOrderComparisonTest, Subspans) {
483    auto subspan = before_.subspan(0, 1);
484    EXPECT_TRUE(subspan < before_);
485    EXPECT_TRUE(subspan <= before_);
486    EXPECT_TRUE(before_ > subspan);
487    EXPECT_TRUE(before_ >= subspan);
488    EXPECT_FALSE(subspan > before_);
489    EXPECT_FALSE(before_ < subspan);
490  }
491  TEST_F(IntSpanOrderComparisonTest, EmptySpans) {
492    absl::Span<int> empty;
493    EXPECT_FALSE(empty < empty);
494    EXPECT_TRUE(empty <= empty);
495    EXPECT_FALSE(empty > empty);
496    EXPECT_TRUE(empty >= empty);
497    EXPECT_TRUE(empty < before_);
498    EXPECT_TRUE(empty <= before_);
499    EXPECT_TRUE(before_ > empty);
500    EXPECT_TRUE(before_ >= empty);
501    EXPECT_FALSE(empty > before_);
502    EXPECT_FALSE(before_ < empty);
503  }
504  TEST(IntSpan, ExposesContainerTypesAndConsts) {
505    absl::Span<int> slice;
506    CheckType<absl::Span<int>::iterator>(slice.begin());
507    EXPECT_TRUE((std::is_convertible<decltype(slice.begin()),
508                                     absl::Span<int>::const_iterator>::value));
509    CheckType<absl::Span<int>::const_iterator>(slice.cbegin());
510    EXPECT_TRUE((std::is_convertible<decltype(slice.end()),
511                                     absl::Span<int>::const_iterator>::value));
512    CheckType<absl::Span<int>::const_iterator>(slice.cend());
513    CheckType<absl::Span<int>::reverse_iterator>(slice.rend());
514    EXPECT_TRUE(
515        (std::is_convertible<decltype(slice.rend()),
516                             absl::Span<int>::const_reverse_iterator>::value));
517    CheckType<absl::Span<int>::const_reverse_iterator>(slice.crend());
518    testing::StaticAssertTypeEq<int, absl::Span<int>::value_type>();
519    testing::StaticAssertTypeEq<int, absl::Span<const int>::value_type>();
520    testing::StaticAssertTypeEq<int, absl::Span<int>::element_type>();
521    testing::StaticAssertTypeEq<const int, absl::Span<const int>::element_type>();
522    testing::StaticAssertTypeEq<int*, absl::Span<int>::pointer>();
523    testing::StaticAssertTypeEq<const int*, absl::Span<const int>::pointer>();
524    testing::StaticAssertTypeEq<int&, absl::Span<int>::reference>();
525    testing::StaticAssertTypeEq<const int&, absl::Span<const int>::reference>();
526    testing::StaticAssertTypeEq<const int&, absl::Span<int>::const_reference>();
527    testing::StaticAssertTypeEq<const int&,
528                                absl::Span<const int>::const_reference>();
529    EXPECT_EQ(static_cast<absl::Span<int>::size_type>(-1), absl::Span<int>::npos);
530  }
531  TEST(IntSpan, IteratorsAndReferences) {
532    auto accept_pointer = [](int*) {};
533    auto accept_reference = [](int&) {};
534    auto accept_iterator = [](absl::Span<int>::iterator) {};
535    auto accept_const_iterator = [](absl::Span<int>::const_iterator) {};
536    auto accept_reverse_iterator = [](absl::Span<int>::reverse_iterator) {};
537    auto accept_const_reverse_iterator =
538        [](absl::Span<int>::const_reverse_iterator) {};
539    int a[1];
540    absl::Span<int> s = a;
541    accept_pointer(s.data());
542    accept_iterator(s.begin());
543    accept_const_iterator(s.begin());
544    accept_const_iterator(s.cbegin());
545    accept_iterator(s.end());
546    accept_const_iterator(s.end());
547    accept_const_iterator(s.cend());
548    accept_reverse_iterator(s.rbegin());
549    accept_const_reverse_iterator(s.rbegin());
550    accept_const_reverse_iterator(s.crbegin());
551    accept_reverse_iterator(s.rend());
552    accept_const_reverse_iterator(s.rend());
553    accept_const_reverse_iterator(s.crend());
554    accept_reference(s[0]);
555    accept_reference(s.at(0));
556    accept_reference(s.front());
557    accept_reference(s.back());
558  }
559  TEST(IntSpan, IteratorsAndReferences_Const) {
560    auto accept_pointer = [](int*) {};
561    auto accept_reference = [](int&) {};
562    auto accept_iterator = [](absl::Span<int>::iterator) {};
563    auto accept_const_iterator = [](absl::Span<int>::const_iterator) {};
564    auto accept_reverse_iterator = [](absl::Span<int>::reverse_iterator) {};
565    auto accept_const_reverse_iterator =
566        [](absl::Span<int>::const_reverse_iterator) {};
567    int a[1];
568    const absl::Span<int> s = a;
569    accept_pointer(s.data());
570    accept_iterator(s.begin());
571    accept_const_iterator(s.begin());
572    accept_const_iterator(s.cbegin());
573    accept_iterator(s.end());
574    accept_const_iterator(s.end());
575    accept_const_iterator(s.cend());
576    accept_reverse_iterator(s.rbegin());
577    accept_const_reverse_iterator(s.rbegin());
578    accept_const_reverse_iterator(s.crbegin());
579    accept_reverse_iterator(s.rend());
580    accept_const_reverse_iterator(s.rend());
581    accept_const_reverse_iterator(s.crend());
582    accept_reference(s[0]);
583    accept_reference(s.at(0));
584    accept_reference(s.front());
585    accept_reference(s.back());
586  }
587  TEST(IntSpan, NoexceptTest) {
588    int a[] = {1, 2, 3};
589    std::vector<int> v;
590    EXPECT_TRUE(noexcept(absl::Span<const int>()));
591    EXPECT_TRUE(noexcept(absl::Span<const int>(a, 2)));
592    EXPECT_TRUE(noexcept(absl::Span<const int>(a)));
593    EXPECT_TRUE(noexcept(absl::Span<const int>(v)));
594    EXPECT_TRUE(noexcept(absl::Span<int>(v)));
595    EXPECT_TRUE(noexcept(absl::Span<const int>({1, 2, 3})));
596    EXPECT_TRUE(noexcept(absl::MakeSpan(v)));
597    EXPECT_TRUE(noexcept(absl::MakeSpan(a)));
598    EXPECT_TRUE(noexcept(absl::MakeSpan(a, 2)));
599    EXPECT_TRUE(noexcept(absl::MakeSpan(a, a + 1)));
600    EXPECT_TRUE(noexcept(absl::MakeConstSpan(v)));
601    EXPECT_TRUE(noexcept(absl::MakeConstSpan(a)));
602    EXPECT_TRUE(noexcept(absl::MakeConstSpan(a, 2)));
603    EXPECT_TRUE(noexcept(absl::MakeConstSpan(a, a + 1)));
604    absl::Span<int> s(v);
605    EXPECT_TRUE(noexcept(s.data()));
606    EXPECT_TRUE(noexcept(s.size()));
607    EXPECT_TRUE(noexcept(s.length()));
608    EXPECT_TRUE(noexcept(s.empty()));
609    EXPECT_TRUE(noexcept(s[0]));
610    EXPECT_TRUE(noexcept(s.front()));
611    EXPECT_TRUE(noexcept(s.back()));
612    EXPECT_TRUE(noexcept(s.begin()));
613    EXPECT_TRUE(noexcept(s.cbegin()));
614    EXPECT_TRUE(noexcept(s.end()));
615    EXPECT_TRUE(noexcept(s.cend()));
616    EXPECT_TRUE(noexcept(s.rbegin()));
617    EXPECT_TRUE(noexcept(s.crbegin()));
618    EXPECT_TRUE(noexcept(s.rend()));
619    EXPECT_TRUE(noexcept(s.crend()));
620    EXPECT_TRUE(noexcept(s.remove_prefix(0)));
621    EXPECT_TRUE(noexcept(s.remove_suffix(0)));
622  }
623  template <int i>
624  struct ConstexprTester {};
625  #define ABSL_TEST_CONSTEXPR(expr)                       \
626    do {                                                  \
627      ABSL_ATTRIBUTE_UNUSED ConstexprTester<(expr, 1)> t; \
628    } while (0)
629  struct ContainerWithConstexprMethods {
630    constexpr int size() const { return 1; }
631    constexpr const int* data() const { return &i; }
632    const int i;
633  };
634  TEST(ConstIntSpan, ConstexprTest) {
635    static constexpr int a[] = {1, 2, 3};
636    static constexpr int sized_arr[2] = {1, 2};
637    static constexpr ContainerWithConstexprMethods c{1};
638    ABSL_TEST_CONSTEXPR(absl::Span<const int>());
639    ABSL_TEST_CONSTEXPR(absl::Span<const int>(a, 2));
640    ABSL_TEST_CONSTEXPR(absl::Span<const int>(sized_arr));
641    ABSL_TEST_CONSTEXPR(absl::Span<const int>(c));
642    ABSL_TEST_CONSTEXPR(absl::MakeSpan(&a[0], 1));
643    ABSL_TEST_CONSTEXPR(absl::MakeSpan(c));
644    ABSL_TEST_CONSTEXPR(absl::MakeSpan(a));
645    ABSL_TEST_CONSTEXPR(absl::MakeConstSpan(&a[0], 1));
646    ABSL_TEST_CONSTEXPR(absl::MakeConstSpan(c));
647    ABSL_TEST_CONSTEXPR(absl::MakeConstSpan(a));
648    constexpr absl::Span<const int> span = c;
649    ABSL_TEST_CONSTEXPR(span.data());
650    ABSL_TEST_CONSTEXPR(span.size());
651    ABSL_TEST_CONSTEXPR(span.length());
652    ABSL_TEST_CONSTEXPR(span.empty());
653    ABSL_TEST_CONSTEXPR(span.begin());
654    ABSL_TEST_CONSTEXPR(span.cbegin());
655    ABSL_TEST_CONSTEXPR(span.subspan(0, 0));
656    ABSL_TEST_CONSTEXPR(span.first(1));
657    ABSL_TEST_CONSTEXPR(span.last(1));
658    ABSL_TEST_CONSTEXPR(span[0]);
659  }
660  struct BigStruct {
661    char bytes[10000];
662  };
663  TEST(Span, SpanSize) {
664    EXPECT_LE(sizeof(absl::Span<int>), 2 * sizeof(void*));
665    EXPECT_LE(sizeof(absl::Span<BigStruct>), 2 * sizeof(void*));
666  }
667  TEST(Span, Hash) {
668    int array[] = {1, 2, 3, 4};
669    int array2[] = {1, 2, 3};
670    using T = absl::Span<const int>;
671    EXPECT_TRUE(absl::VerifyTypeImplementsAbslHashCorrectly(
672        {
673         T(), T(nullptr, 0), T(array, 0), T(array2, 0),
674         T(array, 3), T(array2), T({1, 2, 3}),
675         T(array, 1), T(array, 2),
676         T(array + 1, 2), T(array + 2, 2)}));
677  }
678  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-inlined_vector_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-span_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>150    ABSL_BASE_INTERNAL_EXPECT_FAIL(v.at(3), std::out_of_range,
151                                   "failed bounds check");
152  }
153  TEST(IntVec, ReverseIterator) {
154    for (size_t len = 0; len < 20; len++) {
</pre></code></div>
                <div class="column column_space"><pre><code>191    ABSL_BASE_INTERNAL_EXPECT_FAIL(s.at(10), std::out_of_range,
192                                   "failed bounds check");
193  }
194  TEST(IntSpan, RemovePrefixAndSuffix) {
195    auto v = MakeRamp(20, 1);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    