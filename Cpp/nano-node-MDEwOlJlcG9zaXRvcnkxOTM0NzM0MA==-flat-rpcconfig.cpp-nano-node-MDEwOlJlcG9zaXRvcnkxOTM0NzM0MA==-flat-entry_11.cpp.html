
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 19, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-rpcconfig.cpp</h3>
            <pre><code>1  #include <nano/boost/asio/ip/address_v6.hpp>
2  #include <nano/lib/config.hpp>
3  #include <nano/lib/rpcconfig.hpp>
4  #include <nano/lib/tomlconfig.hpp>
5  #include <boost/dll/runtime_symbol_info.hpp>
6  nano::error nano::rpc_secure_config::serialize_toml (nano::tomlconfig & toml) const
7  {
8  	toml.put ("enable", enable, "Enable or disable TLS support.\ntype:bool");
9  	toml.put ("verbose_logging", verbose_logging, "Enable or disable verbose logging.\ntype:bool");
10  	toml.put ("server_key_passphrase", server_key_passphrase, "Server key passphrase.\ntype:string");
11  	toml.put ("server_cert_path", server_cert_path, "Directory containing certificates.\ntype:string,path");
12  	toml.put ("server_key_path", server_key_path, "Path to server key PEM file.\ntype:string,path");
13  	toml.put ("server_dh_path", server_dh_path, "Path to Diffie-Hellman params file.\ntype:string,path");
14  	toml.put ("client_certs_path", client_certs_path, "Directory containing client certificates.\ntype:string");
15  	return toml.get_error ();
16  }
17  nano::error nano::rpc_secure_config::deserialize_toml (nano::tomlconfig & toml)
18  {
19  	toml.get<bool> ("enable", enable);
20  	toml.get<bool> ("verbose_logging", verbose_logging);
21  	toml.get<std::string> ("server_key_passphrase", server_key_passphrase);
22  	toml.get<std::string> ("server_cert_path", server_cert_path);
23  	toml.get<std::string> ("server_key_path", server_key_path);
24  	toml.get<std::string> ("server_dh_path", server_dh_path);
25  	toml.get<std::string> ("client_certs_path", client_certs_path);
26  	return toml.get_error ();
27  }
28  nano::rpc_config::rpc_config (nano::network_constants & network_constants) :
29  	rpc_process{ network_constants },
30  	address{ boost::asio::ip::address_v6::loopback ().to_string () }
31  {
32  }
33  nano::rpc_config::rpc_config (nano::network_constants & network_constants, uint16_t port_a, bool enable_control_a) :
34  	rpc_process{ network_constants },
35  	address{ boost::asio::ip::address_v6::loopback ().to_string () },
36  	port{ port_a },
37  	enable_control{ enable_control_a }
38  {
39  }
40  nano::error nano::rpc_config::serialize_toml (nano::tomlconfig & toml) const
41  {
42  	toml.put ("address", address, "Bind address for the RPC server.\ntype:string,ip");
43  	toml.put ("port", port, "Listening port for the RPC server.\ntype:uint16");
44  	toml.put ("enable_control", enable_control, "Enable or disable control-level requests.\nWARNING: Enabling this gives anyone with RPC access the ability to stop the node and access wallet funds.\ntype:bool");
45  	toml.put ("max_json_depth", max_json_depth, "Maximum number of levels in JSON requests.\ntype:uint8");
46  	toml.put ("max_request_size", max_request_size, "Maximum number of bytes allowed in request bodies.\ntype:uint64");
47  	nano::tomlconfig rpc_process_l;
48  	rpc_process_l.put ("io_threads", rpc_process.io_threads, "Number of threads used to serve IO.\ntype:uint32");
49  	rpc_process_l.put ("ipc_address", rpc_process.ipc_address, "Address of IPC server.\ntype:string,ip");
50  	rpc_process_l.put ("ipc_port", rpc_process.ipc_port, "Listening port of IPC server.\ntype:uint16");
51  	rpc_process_l.put ("num_ipc_connections", rpc_process.num_ipc_connections, "Number of IPC connections to establish.\ntype:uint32");
52  	toml.put_child ("process", rpc_process_l);
53  	nano::tomlconfig rpc_logging_l;
54  	rpc_logging_l.put ("log_rpc", rpc_logging.log_rpc, "Whether to log RPC calls.\ntype:bool");
55  	toml.put_child ("logging", rpc_logging_l);
56  	return toml.get_error ();
57  }
58  nano::error nano::rpc_config::deserialize_toml (nano::tomlconfig & toml)
59  {
60  	if (!toml.empty ())
61  	{
62  		auto rpc_secure_l (toml.get_optional_child ("secure"));
63  		if (rpc_secure_l)
64  		{
65  			return nano::error ("The RPC secure configuration has moved to config-tls.toml. Please update the configuration.");
66  		}
67  		boost::asio::ip::address_v6 address_l;
68  		toml.get_optional<boost::asio::ip::address_v6> ("address", address_l, boost::asio::ip::address_v6::loopback ());
69  		address = address_l.to_string ();
70  		toml.get_optional<uint16_t> ("port", port);
71  		toml.get_optional<bool> ("enable_control", enable_control);
72  		toml.get_optional<uint8_t> ("max_json_depth", max_json_depth);
73  		toml.get_optional<uint64_t> ("max_request_size", max_request_size);
74  		auto rpc_logging_l (toml.get_optional_child ("logging"));
75  		if (rpc_logging_l)
76  		{
77  			rpc_logging_l->get_optional<bool> ("log_rpc", rpc_logging.log_rpc);
78  		}
79  		auto rpc_process_l (toml.get_optional_child ("process"));
80  		if (rpc_process_l)
81  		{
82  			rpc_process_l->get_optional<unsigned> ("io_threads", rpc_process.io_threads);
83  			rpc_process_l->get_optional<uint16_t> ("ipc_port", rpc_process.ipc_port);
84  			boost::asio::ip::address_v6 ipc_address_l;
85  			rpc_process_l->get_optional<boost::asio::ip::address_v6> ("ipc_address", ipc_address_l, boost::asio::ip::address_v6::loopback ());
86  			rpc_process.ipc_address = address_l.to_string ();
87  			rpc_process_l->get_optional<unsigned> ("num_ipc_connections", rpc_process.num_ipc_connections);
88  		}
89  	}
90  	return toml.get_error ();
91  }
92  nano::rpc_process_config::rpc_process_config (nano::network_constants & network_constants) :
93  	network_constants{ network_constants },
94  	ipc_address{ boost::asio::ip::address_v6::loopback ().to_string () }
95  {
96  }
97  namespace nano
98  {
99  nano::error read_rpc_config_toml (boost::filesystem::path const & data_path_a, nano::rpc_config & config_a, std::vector<std::string> const & config_overrides)
100  {
101  	nano::error error;
102  	auto toml_config_path = nano::get_rpc_toml_config_path (data_path_a);
103  	nano::tomlconfig toml;
104  	std::stringstream config_overrides_stream;
105  	for (auto const & entry : config_overrides)
106  	{
107  		config_overrides_stream << entry << std::endl;
108  	}
109  	config_overrides_stream << std::endl;
110  	if (!error)
111  	{
112  		if (boost::filesystem::exists (toml_config_path))
113  		{
114  			error = toml.read (config_overrides_stream, toml_config_path);
115  		}
116  		else
117  		{
118  			error = toml.read (config_overrides_stream);
119  		}
120  	}
121  	if (!error)
122  	{
123  		error = config_a.deserialize_toml (toml);
124  	}
125  	return error;
126  }
127  std::string get_default_rpc_filepath ()
128  {
<span onclick='openModal()' class='match'>129  	boost::system::error_code err;
130  	auto running_executable_filepath = boost::dll::program_location (err);
131  	auto rpc_filepath = running_executable_filepath.parent_path () / "nano_rpc";
</span>132  	if (running_executable_filepath.has_extension ())
133  	{
134  		rpc_filepath.replace_extension (running_executable_filepath.extension ());
135  	}
136  	return rpc_filepath.string ();
137  }
138  }
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-entry_11.cpp</h3>
            <pre><code>1  #include <nano/crypto_lib/random_pool.hpp>
2  #include <nano/lib/cli.hpp>
3  #include <nano/lib/utility.hpp>
4  #include <nano/nano_node/daemon.hpp>
5  #include <nano/node/cli.hpp>
6  #include <nano/node/daemonconfig.hpp>
7  #include <nano/node/ipc/ipc_server.hpp>
8  #include <nano/node/json_handler.hpp>
9  #include <nano/node/node.hpp>
10  #include <nano/node/transport/inproc.hpp>
11  #include <boost/dll/runtime_symbol_info.hpp>
12  #include <boost/filesystem/operations.hpp>
13  #include <boost/format.hpp>
14  #include <boost/lexical_cast.hpp>
15  #include <boost/program_options.hpp>
16  #include <boost/range/adaptor/reversed.hpp>
17  #ifdef _WIN32
18  #ifndef NOMINMAX
19  #define NOMINMAX
20  #endif
21  #endif
22  #include <boost/stacktrace.hpp>
23  #include <boost/unordered_map.hpp>
24  #include <boost/unordered_set.hpp>
25  #include <numeric>
26  #include <sstream>
27  #include <argon2.h>
28  namespace
29  {
30  class uint64_from_hex 
31  {
32  public:
33  	uint64_t value;
34  };
35  std::istream & operator>> (std::istream & in, uint64_from_hex & out_val);
36  class address_library_pair
37  {
38  public:
39  	uint64_t address;
40  	std::string library;
41  	address_library_pair (uint64_t address, std::string library);
42  	bool operator< (const address_library_pair & other) const;
43  	bool operator== (const address_library_pair & other) const;
44  };
45  }
46  int main (int argc, char * const * argv)
47  {
48  	nano::set_umask ();
49  	nano::node_singleton_memory_pool_purge_guard memory_pool_cleanup_guard;
50  	boost::program_options::options_description description ("Command line options");
51  	description.add_options ()
52  		("help", "Print out options")
53  		("version", "Prints out version")
54  		("config", boost::program_options::value<std::vector<nano::config_key_value_pair>>()->multitoken(), "Pass node configuration values. This takes precedence over any values in the configuration file. This option can be repeated multiple times.")
55  		("rpcconfig", boost::program_options::value<std::vector<nano::config_key_value_pair>>()->multitoken(), "Pass rpc configuration values. This takes precedence over any values in the configuration file. This option can be repeated multiple times.")
56  		("daemon", "Start node daemon")
57  		("compare_rep_weights", "Display a summarized comparison between the hardcoded bootstrap weights and representative weights from the ledger. Full comparison is output to logs")
58  		("debug_block_dump", "Display all the blocks in the ledger in text format")
59  		("debug_block_count", "Display the number of blocks")
60  		("debug_bootstrap_generate", "Generate bootstrap sequence of blocks")
61  		("debug_dump_frontier_unchecked_dependents", "Dump frontiers which have matching unchecked keys")
62  		("debug_dump_trended_weight", "Dump trended weights table")
63  		("debug_dump_representatives", "List representatives and weights")
64  		("debug_account_count", "Display the number of accounts")
65  		("debug_profile_generate", "Profile work generation")
66  		("debug_profile_validate", "Profile work validation")
67  		("debug_opencl", "OpenCL work generation")
68  		("debug_profile_kdf", "Profile kdf function")
69  		("debug_output_last_backtrace_dump", "Displays the contents of the latest backtrace in the event of a nano_node crash")
70  		("debug_generate_crash_report", "Consolidates the nano_node_backtrace.dump file. Requires addr2line installed on Linux")
71  		("debug_sys_logging", "Test the system logger")
72  		("debug_verify_profile", "Profile signature verification")
73  		("debug_verify_profile_batch", "Profile batch signature verification")
74  		("debug_profile_bootstrap", "Profile bootstrap style blocks processing (at least 10GB of free storage space required)")
75  		("debug_profile_sign", "Profile signature generation")
76  		("debug_profile_process", "Profile active blocks processing (only for nano_dev_network)")
77  		("debug_profile_votes", "Profile votes processing (only for nano_dev_network)")
78  		("debug_profile_frontiers_confirmation", "Profile frontiers confirmation speed (only for nano_dev_network)")
79  		("debug_random_feed", "Generates output to RNG test suites")
80  		("debug_rpc", "Read an RPC command from stdin and invoke it. Network operations will have no effect.")
81  		("debug_peers", "Display peer IPv6:port connections")
82  		("debug_cemented_block_count", "Displays the number of cemented (confirmed) blocks")
83  		("debug_stacktrace", "Display an example stacktrace")
84  		("debug_account_versions", "Display the total counts of each version for all accounts (including unpocketed)")
85  		("debug_unconfirmed_frontiers", "Displays the account, height (sorted), frontier and cemented frontier for all accounts which are not fully confirmed")
86  		("validate_blocks,debug_validate_blocks", "Check all blocks for correct hash, signature, work value")
87  		("debug_prune", "Prune accounts up to last confirmed blocks (EXPERIMENTAL)")
88  		("platform", boost::program_options::value<std::string> (), "Defines the <platform> for OpenCL commands")
89  		("device", boost::program_options::value<std::string> (), "Defines <device> for OpenCL command")
90  		("threads", boost::program_options::value<std::string> (), "Defines <threads> count for various commands")
91  		("difficulty", boost::program_options::value<std::string> (), "Defines <difficulty> for OpenCL command, HEX")
92  		("multiplier", boost::program_options::value<std::string> (), "Defines <multiplier> for work generation. Overrides <difficulty>")
93  		("count", boost::program_options::value<std::string> (), "Defines <count> for various commands")
94  		("pow_sleep_interval", boost::program_options::value<std::string> (), "Defines the amount to sleep inbetween each pow calculation attempt")
95  		("address_column", boost::program_options::value<std::string> (), "Defines which column the addresses are located, 0 indexed (check --debug_output_last_backtrace_dump output)")
96  		("silent", "Silent command execution");
97  	nano::add_node_options (description);
98  	nano::add_node_flag_options (description);
99  	boost::program_options::variables_map vm;
100  	try
101  	{
102  		boost::program_options::store (boost::program_options::parse_command_line (argc, argv, description), vm);
103  	}
104  	catch (boost::program_options::error const & err)
105  	{
106  		std::cerr << err.what () << std::endl;
107  		return 1;
108  	}
109  	boost::program_options::notify (vm);
110  	int result (0);
111  	auto network (vm.find ("network"));
112  	if (network != vm.end ())
113  	{
114  		auto err (nano::network_constants::set_active_network (network->second.as<std::string> ()));
115  		if (err)
116  		{
117  			std::cerr << nano::network_constants::active_network_err_msg << std::endl;
118  			std::exit (1);
119  		}
120  	}
121  	nano::network_params network_params{ nano::network_constants::active_network };
122  	auto data_path_it = vm.find ("data_path");
123  	boost::filesystem::path data_path ((data_path_it != vm.end ()) ? data_path_it->second.as<std::string> () : nano::working_path ());
124  	auto ec = nano::handle_node_options (vm);
125  	if (ec == nano::error_cli::unknown_command)
126  	{
127  		if (vm.count ("daemon") > 0)
128  		{
129  			nano_daemon::daemon daemon;
130  			nano::node_flags flags;
131  			auto flags_ec = nano::update_flags (flags, vm);
132  			if (flags_ec)
133  			{
134  				std::cerr << flags_ec.message () << std::endl;
135  				std::exit (1);
136  			}
137  			daemon.run (data_path, flags);
138  		}
139  		else if (vm.count ("compare_rep_weights"))
140  		{
141  			if (nano::network_constants::active_network != nano::networks::nano_dev_network)
142  			{
143  				auto node_flags = nano::inactive_node_flag_defaults ();
144  				nano::update_flags (node_flags, vm);
145  				node_flags.generate_cache.reps = true;
146  				nano::inactive_node inactive_node (data_path, node_flags);
147  				auto node = inactive_node.node;
148  				auto const bootstrap_weights = node->get_bootstrap_weights ();
149  				auto const & hardcoded = bootstrap_weights.second;
150  				auto const hardcoded_height = bootstrap_weights.first;
151  				auto const ledger_unfiltered = node->ledger.cache.rep_weights.get_rep_amounts ();
152  				auto const ledger_height = node->ledger.cache.block_count.load ();
153  				auto get_total = [] (decltype (bootstrap_weights.second) const & reps) -> nano::uint128_union {
154  					return std::accumulate (reps.begin (), reps.end (), nano::uint128_t{ 0 }, [] (auto sum, auto const & rep) { return sum + rep.second; });
155  				};
156  				std::remove_const_t<decltype (ledger_unfiltered)> ledger;
157  				{
158  					std::vector<std::pair<nano::account, nano::uint128_t>> sorted;
159  					sorted.reserve (ledger_unfiltered.size ());
160  					std::copy (ledger_unfiltered.begin (), ledger_unfiltered.end (), std::back_inserter (sorted));
161  					std::sort (sorted.begin (), sorted.end (), [] (auto const & left, auto const & right) { return left.second > right.second; });
162  					auto const total_unfiltered = get_total (ledger_unfiltered);
163  					nano::uint128_t sum{ 0 };
164  					auto target = (total_unfiltered.number () / 100) * 99;
165  					for (auto i (sorted.begin ()), n (sorted.end ()); i != n && sum <= target; sum += i->second, ++i)
166  					{
167  						ledger.insert (*i);
168  					}
169  				}
170  				auto const total_ledger = get_total (ledger);
171  				auto const total_hardcoded = get_total (hardcoded);
172  				struct mismatched_t
173  				{
174  					nano::account rep;
175  					nano::uint128_union hardcoded;
176  					nano::uint128_union ledger;
177  					nano::uint128_union diff;
178  					std::string get_entry () const
179  					{
180  						return boost::str (boost::format ("representative %1% hardcoded %2% ledger %3% mismatch %4%")
181  						% rep.to_account () % hardcoded.format_balance (nano::Mxrb_ratio, 0, true) % ledger.format_balance (nano::Mxrb_ratio, 0, true) % diff.format_balance (nano::Mxrb_ratio, 0, true));
182  					}
183  				};
184  				std::vector<mismatched_t> mismatched;
185  				mismatched.reserve (hardcoded.size ());
186  				std::transform (hardcoded.begin (), hardcoded.end (), std::back_inserter (mismatched), [&ledger] (auto const & rep) {
187  					auto ledger_rep (ledger.find (rep.first));
188  					nano::uint128_t ledger_weight = (ledger_rep == ledger.end () ? 0 : ledger_rep->second);
189  					auto absolute = ledger_weight > rep.second ? ledger_weight - rep.second : rep.second - ledger_weight;
190  					return mismatched_t{ rep.first, rep.second, ledger_weight, absolute };
191  				});
192  				std::sort (mismatched.begin (), mismatched.end (), [] (mismatched_t const & left, mismatched_t const & right) { return left.diff > right.diff; });
193  				nano::uint128_union const mismatch_total = std::accumulate (mismatched.begin (), mismatched.end (), nano::uint128_t{ 0 }, [] (auto sum, mismatched_t const & sample) { return sum + sample.diff.number (); });
194  				nano::uint128_union const mismatch_mean = mismatch_total.number () / mismatched.size ();
195  				nano::uint512_union mismatch_variance = std::accumulate (mismatched.begin (), mismatched.end (), nano::uint512_t (0), [M = mismatch_mean.number (), N = mismatched.size ()] (nano::uint512_t sum, mismatched_t const & sample) {
196  					auto x = sample.diff.number ();
197  					nano::uint512_t const mean_diff = x > M ? x - M : M - x;
198  					nano::uint512_t const sqr = mean_diff * mean_diff;
199  					return sum + sqr;
200  				})
201  				/ mismatched.size ();
202  				nano::uint128_union const mismatch_stddev = nano::narrow_cast<nano::uint128_t> (boost::multiprecision::sqrt (mismatch_variance.number ()));
203  				auto const outlier_threshold = std::max (nano::Gxrb_ratio, mismatch_mean.number () + 1 * mismatch_stddev.number ());
204  				decltype (mismatched) outliers;
205  				std::copy_if (mismatched.begin (), mismatched.end (), std::back_inserter (outliers), [outlier_threshold] (mismatched_t const & sample) {
206  					return sample.diff > outlier_threshold;
207  				});
208  				auto const newcomer_threshold = std::max (nano::Gxrb_ratio, mismatch_mean.number ());
209  				std::vector<std::pair<nano::account, nano::uint128_t>> newcomers;
210  				std::copy_if (ledger.begin (), ledger.end (), std::back_inserter (newcomers), [&hardcoded] (auto const & rep) {
211  					return !hardcoded.count (rep.first) && rep.second;
212  				});
213  				std::sort (newcomers.begin (), newcomers.end (), [] (auto const & left, auto const & right) { return left.second > right.second; });
214  				auto newcomer_entry = [] (auto const & rep) {
215  					return boost::str (boost::format ("representative %1% hardcoded --- ledger %2%") % rep.first.to_account () % nano::uint128_union (rep.second).format_balance (nano::Mxrb_ratio, 0, true));
216  				};
217  				std::cout << boost::str (boost::format ("hardcoded weight %1% Mnano at %2% blocks\nledger weight %3% Mnano at %4% blocks\nmismatched\n\tsamples %5%\n\ttotal %6% Mnano\n\tmean %7% Mnano\n\tsigma %8% Mnano\n")
218  				% total_hardcoded.format_balance (nano::Mxrb_ratio, 0, true)
219  				% hardcoded_height
220  				% total_ledger.format_balance (nano::Mxrb_ratio, 0, true)
221  				% ledger_height
222  				% mismatched.size ()
223  				% mismatch_total.format_balance (nano::Mxrb_ratio, 0, true)
224  				% mismatch_mean.format_balance (nano::Mxrb_ratio, 0, true)
225  				% mismatch_stddev.format_balance (nano::Mxrb_ratio, 0, true));
226  				if (!outliers.empty ())
227  				{
228  					std::cout << "outliers\n";
229  					for (auto const & outlier : outliers)
230  					{
231  						std::cout << '\t' << outlier.get_entry () << '\n';
232  					}
233  				}
234  				if (!newcomers.empty ())
235  				{
236  					std::cout << "newcomers\n";
237  					for (auto const & newcomer : newcomers)
238  					{
239  						if (newcomer.second > newcomer_threshold)
240  						{
241  							std::cout << '\t' << newcomer_entry (newcomer) << '\n';
242  						}
243  					}
244  				}
245  				auto const log_threshold = nano::Gxrb_ratio;
246  				for (auto const & sample : mismatched)
247  				{
248  					if (sample.diff > log_threshold)
249  					{
250  						node->logger.always_log (sample.get_entry ());
251  					}
252  				}
253  				for (auto const & newcomer : newcomers)
254  				{
255  					if (newcomer.second > log_threshold)
256  					{
257  						node->logger.always_log (newcomer_entry (newcomer));
258  					}
259  				}
260  			}
261  			else
262  			{
263  				std::cout << "Not available for the test network" << std::endl;
264  				result = -1;
265  			}
266  		}
267  		else if (vm.count ("debug_block_dump"))
268  		{
269  			auto inactive_node = nano::default_inactive_node (data_path, vm);
270  			auto transaction = inactive_node->node->store.tx_begin_read ();
271  			auto i = inactive_node->node->store.block.begin (transaction);
272  			auto end = inactive_node->node->store.block.end ();
273  			for (; i != end; ++i)
274  			{
275  				nano::block_hash hash = i->first;
276  				nano::block_w_sideband sideband = i->second;
277  				std::shared_ptr<nano::block> b = sideband.block;
278  				std::cout << hash.to_string () << std::endl
279  						  << b->to_json ();
280  			}
281  		}
282  		else if (vm.count ("debug_block_count"))
283  		{
284  			auto node_flags = nano::inactive_node_flag_defaults ();
285  			nano::update_flags (node_flags, vm);
286  			node_flags.generate_cache.block_count = true;
287  			nano::inactive_node inactive_node (data_path, node_flags);
288  			auto node = inactive_node.node;
289  			std::cout << boost::str (boost::format ("Block count: %1%\n") % node->ledger.cache.block_count);
290  		}
291  		else if (vm.count ("debug_bootstrap_generate"))
292  		{
293  			auto key_it = vm.find ("key");
294  			if (key_it != vm.end ())
295  			{
296  				nano::uint256_union key;
297  				if (!key.decode_hex (key_it->second.as<std::string> ()))
298  				{
299  					nano::keypair genesis (key.to_string ());
300  					nano::work_pool work{ network_params.network, std::numeric_limits<unsigned>::max () };
301  					std::cout << "Genesis: " << genesis.prv.to_string () << "\n"
302  							  << "Public: " << genesis.pub.to_string () << "\n"
303  							  << "Account: " << genesis.pub.to_account () << "\n";
304  					nano::keypair landing;
305  					std::cout << "Landing: " << landing.prv.to_string () << "\n"
306  							  << "Public: " << landing.pub.to_string () << "\n"
307  							  << "Account: " << landing.pub.to_account () << "\n";
308  					for (auto i (0); i != 32; ++i)
309  					{
310  						nano::keypair rep;
311  						std::cout << "Rep" << i << ": " << rep.prv.to_string () << "\n"
312  								  << "Public: " << rep.pub.to_string () << "\n"
313  								  << "Account: " << rep.pub.to_account () << "\n";
314  					}
315  					nano::uint128_t balance (std::numeric_limits<nano::uint128_t>::max ());
316  					nano::open_block genesis_block (reinterpret_cast<nano::block_hash const &> (genesis.pub), genesis.pub, genesis.pub, genesis.prv, genesis.pub, *work.generate (nano::work_version::work_1, genesis.pub, network_params.work.epoch_1));
317  					std::cout << genesis_block.to_json ();
318  					std::cout.flush ();
319  					nano::block_hash previous (genesis_block.hash ());
320  					for (auto i (0); i != 8; ++i)
321  					{
322  						nano::uint128_t yearly_distribution (nano::uint128_t (1) << (127 - (i == 7 ? 6 : i)));
323  						auto weekly_distribution (yearly_distribution / 52);
324  						for (auto j (0); j != 52; ++j)
325  						{
326  							debug_assert (balance > weekly_distribution);
327  							balance = balance < (weekly_distribution * 2) ? 0 : balance - weekly_distribution;
328  							nano::send_block send (previous, landing.pub, balance, genesis.prv, genesis.pub, *work.generate (nano::work_version::work_1, previous, network_params.work.epoch_1));
329  							previous = send.hash ();
330  							std::cout << send.to_json ();
331  							std::cout.flush ();
332  						}
333  					}
334  				}
335  				else
336  				{
337  					std::cerr << "Invalid key\n";
338  					result = -1;
339  				}
340  			}
341  			else
342  			{
343  				std::cerr << "Bootstrapping requires one <key> option\n";
344  				result = -1;
345  			}
346  		}
347  		else if (vm.count ("debug_dump_trended_weight"))
348  		{
349  			auto inactive_node = nano::default_inactive_node (data_path, vm);
350  			auto node = inactive_node->node;
351  			auto current (node->online_reps.trended ());
352  			std::cout << boost::str (boost::format ("Trended Weight %1%\n") % current);
353  			auto transaction (node->store.tx_begin_read ());
354  			for (auto i (node->store.online_weight.begin (transaction)), n (node->store.online_weight.end ()); i != n; ++i)
355  			{
356  				using time_point = std::chrono::system_clock::time_point;
357  				time_point ts (std::chrono::duration_cast<time_point::duration> (std::chrono::nanoseconds (i->first)));
358  				std::time_t timestamp = std::chrono::system_clock::to_time_t (ts);
359  				std::string weight;
360  				i->second.encode_dec (weight);
361  				std::cout << boost::str (boost::format ("Timestamp %1% Weight %2%\n") % ctime (&timestamp) % weight);
362  			}
363  		}
364  		else if (vm.count ("debug_dump_representatives"))
365  		{
366  			auto node_flags = nano::inactive_node_flag_defaults ();
367  			nano::update_flags (node_flags, vm);
368  			node_flags.generate_cache.reps = true;
369  			nano::inactive_node inactive_node (data_path, node_flags);
370  			auto node = inactive_node.node;
371  			auto transaction (node->store.tx_begin_read ());
372  			nano::uint128_t total;
373  			auto rep_amounts = node->ledger.cache.rep_weights.get_rep_amounts ();
374  			std::map<nano::account, nano::uint128_t> ordered_reps (rep_amounts.begin (), rep_amounts.end ());
375  			for (auto const & rep : ordered_reps)
376  			{
377  				total += rep.second;
378  				std::cout << boost::str (boost::format ("%1% %2% %3%\n") % rep.first.to_account () % rep.second.convert_to<std::string> () % total.convert_to<std::string> ());
379  			}
380  		}
381  		else if (vm.count ("debug_dump_frontier_unchecked_dependents"))
382  		{
383  			auto inactive_node = nano::default_inactive_node (data_path, vm);
384  			auto node = inactive_node->node;
385  			std::cout << "Outputting any frontier hashes which have associated key hashes in the unchecked table (may take some time)...\n";
386  			auto transaction (node->store.tx_begin_read ());
387  			std::unordered_set<nano::block_hash> frontier_hashes;
388  			for (auto i (node->store.account.begin (transaction)), n (node->store.account.end ()); i != n; ++i)
389  			{
390  				frontier_hashes.insert (i->second.head);
391  			}
392  			node->unchecked.for_each ([&frontier_hashes] (nano::unchecked_key const & key, nano::unchecked_info const & info) {
393  				auto it = frontier_hashes.find (key.key ());
394  				if (it != frontier_hashes.cend ())
395  				{
396  					std::cout << it->to_string () << "\n";
397  				}
398  			});
399  		}
400  		else if (vm.count ("debug_account_count"))
401  		{
402  			auto node_flags = nano::inactive_node_flag_defaults ();
403  			nano::update_flags (node_flags, vm);
404  			node_flags.generate_cache.account_count = true;
405  			nano::inactive_node inactive_node (data_path, node_flags);
406  			std::cout << boost::str (boost::format ("Frontier count: %1%\n") % inactive_node.node->ledger.cache.account_count);
407  		}
408  		else if (vm.count ("debug_profile_kdf"))
409  		{
410  			auto inactive_node = nano::default_inactive_node (data_path, vm);
411  			nano::uint256_union result;
412  			nano::uint256_union salt (0);
413  			std::string password ("");
414  			while (true)
415  			{
416  				auto begin1 (std::chrono::high_resolution_clock::now ());
417  				auto success (argon2_hash (1, inactive_node->node->network_params.kdf_work, 1, password.data (), password.size (), salt.bytes.data (), salt.bytes.size (), result.bytes.data (), result.bytes.size (), NULL, 0, Argon2_d, 0x10));
418  				(void)success;
419  				auto end1 (std::chrono::high_resolution_clock::now ());
420  				std::cerr << boost::str (boost::format ("Derivation time: %1%us\n") % std::chrono::duration_cast<std::chrono::microseconds> (end1 - begin1).count ());
421  			}
422  		}
423  		else if (vm.count ("debug_profile_generate"))
424  		{
425  			uint64_t difficulty{ nano::work_thresholds::publish_full.base };
426  			auto multiplier_it = vm.find ("multiplier");
427  			if (multiplier_it != vm.end ())
428  			{
429  				try
430  				{
431  					auto multiplier (boost::lexical_cast<double> (multiplier_it->second.as<std::string> ()));
432  					difficulty = nano::difficulty::from_multiplier (multiplier, difficulty);
433  				}
434  				catch (boost::bad_lexical_cast &)
435  				{
436  					std::cerr << "Invalid multiplier\n";
437  					return -1;
438  				}
439  			}
440  			else
441  			{
442  				auto difficulty_it = vm.find ("difficulty");
443  				if (difficulty_it != vm.end ())
444  				{
445  					if (nano::from_string_hex (difficulty_it->second.as<std::string> (), difficulty))
446  					{
447  						std::cerr << "Invalid difficulty\n";
448  						return -1;
449  					}
450  				}
451  			}
452  			auto pow_rate_limiter = std::chrono::nanoseconds (0);
453  			auto pow_sleep_interval_it = vm.find ("pow_sleep_interval");
454  			if (pow_sleep_interval_it != vm.cend ())
455  			{
456  				pow_rate_limiter = std::chrono::nanoseconds (boost::lexical_cast<uint64_t> (pow_sleep_interval_it->second.as<std::string> ()));
457  			}
458  			nano::work_pool work{ network_params.network, std::numeric_limits<unsigned>::max (), pow_rate_limiter };
459  			nano::change_block block (0, 0, nano::keypair ().prv, 0, 0);
460  			if (!result)
461  			{
462  				std::cerr << boost::str (boost::format ("Starting generation profiling. Difficulty: %1$#x (%2%x from base difficulty %3$#x)\n") % difficulty % nano::to_string (nano::difficulty::to_multiplier (difficulty, nano::work_thresholds::publish_full.base), 4) % nano::work_thresholds::publish_full.base);
463  				while (!result)
464  				{
465  					block.hashables.previous.qwords[0] += 1;
466  					auto begin1 (std::chrono::high_resolution_clock::now ());
467  					block.block_work_set (*work.generate (nano::work_version::work_1, block.root (), difficulty));
468  					auto end1 (std::chrono::high_resolution_clock::now ());
469  					std::cerr << boost::str (boost::format ("%|1$ 12d|\n") % std::chrono::duration_cast<std::chrono::microseconds> (end1 - begin1).count ());
470  				}
471  			}
472  		}
473  		else if (vm.count ("debug_profile_validate"))
474  		{
475  			uint64_t difficulty{ nano::work_thresholds::publish_full.base };
476  			std::cerr << "Starting validation profile" << std::endl;
477  			auto start (std::chrono::steady_clock::now ());
478  			bool valid{ false };
479  			nano::block_hash hash{ 0 };
480  			uint64_t count{ 10000000U }; 
481  			for (uint64_t i (0); i < count; ++i)
482  			{
483  				valid = network_params.work.value (hash, i) > difficulty;
484  			}
485  			std::ostringstream oss (valid ? "true" : "false"); 
486  			auto total_time (std::chrono::duration_cast<std::chrono::nanoseconds> (std::chrono::steady_clock::now () - start).count ());
487  			uint64_t average (total_time / count);
488  			std::cout << "Average validation time: " << std::to_string (average) << " ns (" << std::to_string (static_cast<unsigned> (count * 1e9 / total_time)) << " validations/s)" << std::endl;
489  		}
490  		else if (vm.count ("debug_opencl"))
491  		{
492  			bool error (false);
493  			nano::opencl_environment environment (error);
494  			if (!error)
495  			{
496  				unsigned short platform (0);
497  				auto platform_it = vm.find ("platform");
498  				if (platform_it != vm.end ())
499  				{
500  					try
501  					{
502  						platform = boost::lexical_cast<unsigned short> (platform_it->second.as<std::string> ());
503  					}
504  					catch (boost::bad_lexical_cast &)
505  					{
506  						std::cerr << "Invalid platform id\n";
507  						return -1;
508  					}
509  				}
510  				unsigned short device (0);
511  				auto device_it = vm.find ("device");
512  				if (device_it != vm.end ())
513  				{
514  					try
515  					{
516  						device = boost::lexical_cast<unsigned short> (device_it->second.as<std::string> ());
517  					}
518  					catch (boost::bad_lexical_cast &)
519  					{
520  						std::cerr << "Invalid device id\n";
521  						return -1;
522  					}
523  				}
524  				unsigned threads (1024 * 1024);
525  				auto threads_it = vm.find ("threads");
526  				if (threads_it != vm.end ())
527  				{
528  					try
529  					{
530  						threads = boost::lexical_cast<unsigned> (threads_it->second.as<std::string> ());
531  					}
532  					catch (boost::bad_lexical_cast &)
533  					{
534  						std::cerr << "Invalid threads count\n";
535  						return -1;
536  					}
537  				}
538  				uint64_t difficulty (nano::work_thresholds::publish_full.base);
539  				auto multiplier_it = vm.find ("multiplier");
540  				if (multiplier_it != vm.end ())
541  				{
542  					try
543  					{
544  						auto multiplier (boost::lexical_cast<double> (multiplier_it->second.as<std::string> ()));
545  						difficulty = nano::difficulty::from_multiplier (multiplier, difficulty);
546  					}
547  					catch (boost::bad_lexical_cast &)
548  					{
549  						std::cerr << "Invalid multiplier\n";
550  						return -1;
551  					}
552  				}
553  				else
554  				{
555  					auto difficulty_it = vm.find ("difficulty");
556  					if (difficulty_it != vm.end ())
557  					{
558  						if (nano::from_string_hex (difficulty_it->second.as<std::string> (), difficulty))
559  						{
560  							std::cerr << "Invalid difficulty\n";
561  							return -1;
562  						}
563  					}
564  				}
565  				if (!result)
566  				{
567  					error |= platform >= environment.platforms.size ();
568  					if (!error)
569  					{
570  						error |= device >= environment.platforms[platform].devices.size ();
571  						if (!error)
572  						{
573  							nano::logger_mt logger;
574  							nano::opencl_config config (platform, device, threads);
575  							auto opencl (nano::opencl_work::create (true, config, logger, network_params.work));
576  							nano::work_pool work_pool{ network_params.network, 0, std::chrono::nanoseconds (0), opencl ? [&opencl] (nano::work_version const version_a, nano::root const & root_a, uint64_t difficulty_a, std::atomic<int> &) {
577  														  return opencl->generate_work (version_a, root_a, difficulty_a);
578  													  }
579  																													   : std::function<boost::optional<uint64_t> (nano::work_version const, nano::root const &, uint64_t, std::atomic<int> &)> (nullptr) };
580  							nano::change_block block (0, 0, nano::keypair ().prv, 0, 0);
581  							std::cerr << boost::str (boost::format ("Starting OpenCL generation profiling. Platform: %1%. Device: %2%. Threads: %3%. Difficulty: %4$#x (%5%x from base difficulty %6$#x)\n") % platform % device % threads % difficulty % nano::to_string (nano::difficulty::to_multiplier (difficulty, nano::work_thresholds::publish_full.base), 4) % nano::work_thresholds::publish_full.base);
582  							for (uint64_t i (0); true; ++i)
583  							{
584  								block.hashables.previous.qwords[0] += 1;
585  								auto begin1 (std::chrono::high_resolution_clock::now ());
586  								block.block_work_set (*work_pool.generate (nano::work_version::work_1, block.root (), difficulty));
587  								auto end1 (std::chrono::high_resolution_clock::now ());
588  								std::cerr << boost::str (boost::format ("%|1$ 12d|\n") % std::chrono::duration_cast<std::chrono::microseconds> (end1 - begin1).count ());
589  							}
590  						}
591  						else
592  						{
593  							std::cout << "Not available device id\n"
594  									  << std::endl;
595  							result = -1;
596  						}
597  					}
598  					else
599  					{
600  						std::cout << "Not available platform id\n"
601  								  << std::endl;
602  						result = -1;
603  					}
604  				}
605  			}
606  			else
607  			{
608  				std::cout << "Error initializing OpenCL" << std::endl;
609  				result = -1;
610  			}
611  		}
612  		else if (vm.count ("debug_output_last_backtrace_dump"))
613  		{
614  			if (boost::filesystem::exists ("nano_node_backtrace.dump"))
615  			{
616  				std::ifstream ifs ("nano_node_backtrace.dump");
617  				boost::stacktrace::stacktrace st = boost::stacktrace::stacktrace::from_dump (ifs);
618  				std::cout << "Latest crash backtrace:\n"
619  						  << st << std::endl;
620  			}
621  		}
622  		else if (vm.count ("debug_generate_crash_report"))
623  		{
624  			if (boost::filesystem::exists ("nano_node_backtrace.dump"))
625  			{
626  				std::ifstream ifs ("nano_node_backtrace.dump");
627  				boost::stacktrace::stacktrace st = boost::stacktrace::stacktrace::from_dump (ifs);
628  				std::string crash_report_filename = "nano_node_crash_report.txt";
629  #if defined(_WIN32) || defined(__APPLE__)
630  				std::ofstream ofs (crash_report_filename);
631  				ofs << st;
632  #else
<span onclick='openModal()' class='match'>633  				boost::system::error_code err;
634  				auto running_executable_filepath = boost::dll::program_location (err);
635  				if (!err)
</span>636  				{
637  					auto num = 0;
638  					auto format = boost::format ("nano_node_crash_load_address_dump_%1%.txt");
639  					std::vector<address_library_pair> base_addresses;
640  					uint64_from_hex base_address;
641  					std::string line;
642  					if (boost::filesystem::exists (boost::str (format % num)))
643  					{
644  						std::getline (std::ifstream (boost::str (format % num)), line);
645  						if (boost::conversion::try_lexical_convert (line, base_address))
646  						{
647  							base_addresses.emplace_back (base_address.value, running_executable_filepath.string ());
648  						}
649  					}
650  					++num;
651  					while (boost::filesystem::exists (boost::str (format % num)))
652  					{
653  						std::ifstream ifs_dump_filename (boost::str (format % num));
654  						std::string dynamic_lib_path;
655  						std::getline (ifs_dump_filename, dynamic_lib_path);
656  						std::getline (ifs_dump_filename, line);
657  						if (boost::conversion::try_lexical_convert (line, base_address))
658  						{
659  							base_addresses.emplace_back (base_address.value, dynamic_lib_path);
660  						}
661  						++num;
662  					}
663  					std::sort (base_addresses.begin (), base_addresses.end ());
664  					auto address_column_it = vm.find ("address_column");
665  					auto column = -1;
666  					if (address_column_it != vm.end ())
667  					{
668  						if (!boost::conversion::try_lexical_convert (address_column_it->second.as<std::string> (), column))
669  						{
670  							std::cerr << "Error: Invalid address column\n";
671  							result = -1;
672  						}
673  					}
674  					std::stringstream stacktrace_ss;
675  					stacktrace_ss << st;
676  					std::vector<uint64_t> backtrace_addresses;
677  					while (std::getline (stacktrace_ss, line))
678  					{
679  						std::istringstream iss (line);
680  						std::vector<std::string> results (std::istream_iterator<std::string>{ iss }, std::istream_iterator<std::string> ());
681  						if (column != -1)
682  						{
683  							if (column < results.size ())
684  							{
685  								uint64_from_hex address_hex;
686  								if (boost::conversion::try_lexical_convert (results[column], address_hex))
687  								{
688  									backtrace_addresses.push_back (address_hex.value);
689  								}
690  								else
691  								{
692  									std::cerr << "Error: Address column does not point to valid addresses\n";
693  									result = -1;
694  								}
695  							}
696  							else
697  							{
698  								std::cerr << "Error: Address column too high\n";
699  								result = -1;
700  							}
701  						}
702  						else
703  						{
704  							for (auto const & text : results)
705  							{
706  								uint64_from_hex address_hex;
707  								if (boost::conversion::try_lexical_convert (text, address_hex))
708  								{
709  									backtrace_addresses.push_back (address_hex.value);
710  									break;
711  								}
712  							}
713  						}
714  					}
715  					boost::filesystem::remove (crash_report_filename);
716  					{
717  						std::ofstream ofs (crash_report_filename);
718  						nano::set_secure_perm_file (crash_report_filename);
719  					}
720  					std::vector<int> system_codes;
721  					auto run_addr2line = [&backtrace_addresses, &base_addresses, &system_codes, &crash_report_filename] (bool use_relative_addresses) {
722  						for (auto backtrace_address : backtrace_addresses)
723  						{
724  							for (auto base_address : boost::adaptors::reverse (base_addresses))
725  							{
726  								if (backtrace_address > base_address.address)
727  								{
728  									auto address = use_relative_addresses ? backtrace_address - base_address.address : backtrace_address;
729  									std::stringstream ss;
730  									ss << std::uppercase << std::hex << address;
731  									auto res = std::system (boost::str (boost::format ("addr2line -fCi %1% -e %2% >> %3%") % ss.str () % base_address.library % crash_report_filename).c_str ());
732  									system_codes.push_back (res);
733  									break;
734  								}
735  							}
736  						}
737  					};
738  					run_addr2line (false);
739  					{
740  						std::ofstream ofs (crash_report_filename, std::ios_base::out | std::ios_base::app);
741  						ofs << std::endl
742  							<< "Using relative addresses:" << std::endl; 
743  					}
744  					run_addr2line (true);
745  					if (std::find (system_codes.begin (), system_codes.end (), 0) == system_codes.end ())
746  					{
747  						std::cerr << "Error: Check that addr2line is installed and that nano_node_crash_load_address_dump_*.txt files exist." << std::endl;
748  						result = -1;
749  					}
750  				}
751  				else
752  				{
753  					std::cerr << "Error: Could not determine running executable path" << std::endl;
754  					result = -1;
755  				}
756  #endif
757  				if (result == 0)
758  				{
759  					std::cout << (boost::format ("%1% created") % crash_report_filename).str () << std::endl;
760  				}
761  			}
762  			else
763  			{
764  				std::cerr << "Error: nano_node_backtrace.dump could not be found";
765  				result = -1;
766  			}
767  		}
768  		else if (vm.count ("debug_verify_profile"))
769  		{
770  			nano::keypair key;
771  			nano::uint256_union message;
772  			auto signature = nano::sign_message (key.prv, key.pub, message);
773  			auto begin (std::chrono::high_resolution_clock::now ());
774  			for (auto i (0u); i < 1000; ++i)
775  			{
776  				nano::validate_message (key.pub, message, signature);
777  			}
778  			auto end (std::chrono::high_resolution_clock::now ());
779  			std::cerr << "Signature verifications " << std::chrono::duration_cast<std::chrono::microseconds> (end - begin).count () << std::endl;
780  		}
781  		else if (vm.count ("debug_verify_profile_batch"))
782  		{
783  			nano::keypair key;
784  			size_t batch_count (1000);
785  			nano::uint256_union message;
786  			nano::uint512_union signature (nano::sign_message (key.prv, key.pub, message));
787  			std::vector<unsigned char const *> messages (batch_count, message.bytes.data ());
788  			std::vector<size_t> lengths (batch_count, sizeof (message));
789  			std::vector<unsigned char const *> pub_keys (batch_count, key.pub.bytes.data ());
790  			std::vector<unsigned char const *> signatures (batch_count, signature.bytes.data ());
791  			std::vector<int> verifications;
792  			verifications.resize (batch_count);
793  			auto begin (std::chrono::high_resolution_clock::now ());
794  			nano::validate_message_batch (messages.data (), lengths.data (), pub_keys.data (), signatures.data (), batch_count, verifications.data ());
795  			auto end (std::chrono::high_resolution_clock::now ());
796  			std::cerr << "Batch signature verifications " << std::chrono::duration_cast<std::chrono::microseconds> (end - begin).count () << std::endl;
797  		}
798  		else if (vm.count ("debug_profile_sign"))
799  		{
800  			std::cerr << "Starting blocks signing profiling\n";
801  			while (true)
802  			{
803  				nano::keypair key;
804  				nano::block_builder builder;
805  				nano::block_hash latest (0);
806  				auto begin1 (std::chrono::high_resolution_clock::now ());
807  				for (uint64_t balance (0); balance < 1000; ++balance)
808  				{
809  					auto send = builder
810  								.send ()
811  								.previous (latest)
812  								.destination (key.pub)
813  								.balance (balance)
814  								.sign (key.prv, key.pub)
815  								.work (0)
816  								.build ();
817  					latest = send->hash ();
818  				}
819  				auto end1 (std::chrono::high_resolution_clock::now ());
820  				std::cerr << boost::str (boost::format ("%|1$ 12d|\n") % std::chrono::duration_cast<std::chrono::microseconds> (end1 - begin1).count ());
821  			}
822  		}
823  		else if (vm.count ("debug_profile_process"))
824  		{
825  			nano::block_builder builder;
826  			size_t num_accounts (100000);
827  			size_t num_iterations (5); 
828  			size_t max_blocks (2 * num_accounts * num_iterations + num_accounts * 2); 
829  			std::cout << boost::str (boost::format ("Starting pregenerating %1% blocks\n") % max_blocks);
830  			nano::node_flags node_flags;
831  			nano::update_flags (node_flags, vm);
832  			nano::inactive_node inactive_node (nano::unique_path (), data_path, node_flags);
833  			auto node = inactive_node.node;
834  			nano::block_hash genesis_latest (node->latest (nano::dev::genesis_key.pub));
835  			nano::uint128_t genesis_balance (std::numeric_limits<nano::uint128_t>::max ());
836  			std::vector<nano::keypair> keys (num_accounts);
837  			std::vector<nano::root> frontiers (num_accounts);
838  			std::vector<nano::uint128_t> balances (num_accounts, 1000000000);
839  			std::deque<std::shared_ptr<nano::block>> blocks;
840  			for (auto i (0); i != num_accounts; ++i)
841  			{
842  				genesis_balance = genesis_balance - 1000000000;
843  				auto send = builder.state ()
844  							.account (nano::dev::genesis_key.pub)
845  							.previous (genesis_latest)
846  							.representative (nano::dev::genesis_key.pub)
847  							.balance (genesis_balance)
848  							.link (keys[i].pub)
849  							.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
850  							.work (*node->work.generate (nano::work_version::work_1, genesis_latest, node->network_params.work.epoch_1))
851  							.build ();
852  				genesis_latest = send->hash ();
853  				blocks.push_back (std::move (send));
854  				auto open = builder.state ()
855  							.account (keys[i].pub)
856  							.previous (0)
857  							.representative (keys[i].pub)
858  							.balance (balances[i])
859  							.link (genesis_latest)
860  							.sign (keys[i].prv, keys[i].pub)
861  							.work (*node->work.generate (nano::work_version::work_1, keys[i].pub, node->network_params.work.epoch_1))
862  							.build ();
863  				frontiers[i] = open->hash ();
864  				blocks.push_back (std::move (open));
865  			}
866  			for (auto i (0); i != num_iterations; ++i)
867  			{
868  				for (auto j (0); j != num_accounts; ++j)
869  				{
870  					size_t other (num_accounts - j - 1);
871  					--balances[j];
872  					auto send = builder.state ()
873  								.account (keys[j].pub)
874  								.previous (frontiers[j].as_block_hash ())
875  								.representative (keys[j].pub)
876  								.balance (balances[j])
877  								.link (keys[other].pub)
878  								.sign (keys[j].prv, keys[j].pub)
879  								.work (*node->work.generate (nano::work_version::work_1, frontiers[j], node->network_params.work.epoch_1))
880  								.build ();
881  					frontiers[j] = send->hash ();
882  					blocks.push_back (std::move (send));
883  					++balances[other];
884  					auto receive = builder.state ()
885  								   .account (keys[other].pub)
886  								   .previous (frontiers[other].as_block_hash ())
887  								   .representative (keys[other].pub)
888  								   .balance (balances[other])
889  								   .link (frontiers[j].as_block_hash ())
890  								   .sign (keys[other].prv, keys[other].pub)
891  								   .work (*node->work.generate (nano::work_version::work_1, frontiers[other], node->network_params.work.epoch_1))
892  								   .build ();
893  					frontiers[other] = receive->hash ();
894  					blocks.push_back (std::move (receive));
895  				}
896  			}
897  			std::cout << boost::str (boost::format ("Starting processing %1% blocks\n") % max_blocks);
898  			auto begin (std::chrono::high_resolution_clock::now ());
899  			while (!blocks.empty ())
900  			{
901  				auto block (blocks.front ());
902  				node->process_active (block);
903  				blocks.pop_front ();
904  			}
905  			nano::timer<std::chrono::seconds> timer_l (nano::timer_state::started);
906  			while (node->ledger.cache.block_count != max_blocks + 1)
907  			{
908  				std::this_thread::sleep_for (std::chrono::milliseconds (10));
909  				if (timer_l.after_deadline (std::chrono::seconds (15)))
910  				{
911  					timer_l.restart ();
912  					std::cout << boost::str (boost::format ("%1% (%2%) blocks processed (unchecked), %3% remaining") % node->ledger.cache.block_count % node->unchecked.count () % node->block_processor.size ()) << std::endl;
913  				}
914  			}
915  			node->block_processor.flush ();
916  			auto end (std::chrono::high_resolution_clock::now ());
917  			auto time (std::chrono::duration_cast<std::chrono::microseconds> (end - begin).count ());
918  			node->stop ();
919  			std::cout << boost::str (boost::format ("%|1$ 12d| us \n%2% blocks per second\n") % time % (max_blocks * 1000000 / time));
920  			release_assert (node->ledger.cache.block_count == max_blocks + 1);
921  		}
922  		else if (vm.count ("debug_profile_votes"))
923  		{
924  			nano::block_builder builder;
925  			size_t num_elections (40000);
926  			size_t num_representatives (25);
927  			size_t max_votes (num_elections * num_representatives); 
928  			std::cerr << boost::str (boost::format ("Starting pregenerating %1% votes\n") % max_votes);
929  			nano::node_flags node_flags;
930  			nano::update_flags (node_flags, vm);
931  			nano::node_wrapper node_wrapper (nano::unique_path (), data_path, node_flags);
932  			auto node = node_wrapper.node;
933  			nano::block_hash genesis_latest (node->latest (nano::dev::genesis_key.pub));
934  			nano::uint128_t genesis_balance (std::numeric_limits<nano::uint128_t>::max ());
935  			std::vector<nano::keypair> keys (num_representatives);
936  			nano::uint128_t balance ((node->config.online_weight_minimum.number () / num_representatives) + 1);
937  			for (auto i (0); i != num_representatives; ++i)
938  			{
939  				auto transaction (node->store.tx_begin_write ());
940  				genesis_balance = genesis_balance - balance;
941  				auto send = builder.state ()
942  							.account (nano::dev::genesis_key.pub)
943  							.previous (genesis_latest)
944  							.representative (nano::dev::genesis_key.pub)
945  							.balance (genesis_balance)
946  							.link (keys[i].pub)
947  							.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
948  							.work (*node->work.generate (nano::work_version::work_1, genesis_latest, node->network_params.work.epoch_1))
949  							.build ();
950  				genesis_latest = send->hash ();
951  				node->ledger.process (transaction, *send);
952  				auto open = builder.state ()
953  							.account (keys[i].pub)
954  							.previous (0)
955  							.representative (keys[i].pub)
956  							.balance (balance)
957  							.link (genesis_latest)
958  							.sign (keys[i].prv, keys[i].pub)
959  							.work (*node->work.generate (nano::work_version::work_1, keys[i].pub, node->network_params.work.epoch_1))
960  							.build ();
961  				node->ledger.process (transaction, *open);
962  			}
963  			std::deque<std::shared_ptr<nano::block>> blocks;
964  			for (auto i (0); i != num_elections; ++i)
965  			{
966  				genesis_balance = genesis_balance - 1;
967  				nano::keypair destination;
968  				auto send = builder.state ()
969  							.account (nano::dev::genesis_key.pub)
970  							.previous (genesis_latest)
971  							.representative (nano::dev::genesis_key.pub)
972  							.balance (genesis_balance)
973  							.link (destination.pub)
974  							.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
975  							.work (*node->work.generate (nano::work_version::work_1, genesis_latest, node->network_params.work.epoch_1))
976  							.build ();
977  				genesis_latest = send->hash ();
978  				blocks.push_back (std::move (send));
979  			}
980  			std::deque<std::shared_ptr<nano::vote>> votes;
981  			for (auto j (0); j != num_representatives; ++j)
982  			{
983  				uint64_t sequence (1);
984  				for (auto & i : blocks)
985  				{
986  					auto vote (std::make_shared<nano::vote> (keys[j].pub, keys[j].prv, sequence, 0, std::vector<nano::block_hash> (1, i->hash ())));
987  					votes.push_back (vote);
988  					sequence++;
989  				}
990  			}
991  			while (!blocks.empty ())
992  			{
993  				auto block (blocks.front ());
994  				node->process_active (block);
995  				blocks.pop_front ();
996  			}
997  			node->block_processor.flush ();
998  			std::cerr << boost::str (boost::format ("Starting processing %1% votes\n") % max_votes);
999  			auto begin (std::chrono::high_resolution_clock::now ());
1000  			while (!votes.empty ())
1001  			{
1002  				auto vote (votes.front ());
1003  				auto channel (std::make_shared<nano::transport::inproc::channel> (*node, *node));
1004  				node->vote_processor.vote (vote, channel);
1005  				votes.pop_front ();
1006  			}
1007  			while (!node->active.empty ())
1008  			{
1009  				std::this_thread::sleep_for (std::chrono::milliseconds (100));
1010  			}
1011  			auto end (std::chrono::high_resolution_clock::now ());
1012  			auto time (std::chrono::duration_cast<std::chrono::microseconds> (end - begin).count ());
1013  			node->stop ();
1014  			std::cerr << boost::str (boost::format ("%|1$ 12d| us \n%2% votes per second\n") % time % (max_votes * 1000000 / time));
1015  		}
1016  		else if (vm.count ("debug_profile_frontiers_confirmation"))
1017  		{
1018  			nano::block_builder builder;
1019  			size_t count (32 * 1024);
1020  			auto count_it = vm.find ("count");
1021  			if (count_it != vm.end ())
1022  			{
1023  				try
1024  				{
1025  					count = boost::lexical_cast<size_t> (count_it->second.as<std::string> ());
1026  				}
1027  				catch (boost::bad_lexical_cast &)
1028  				{
1029  					std::cerr << "Invalid count\n";
1030  					return -1;
1031  				}
1032  			}
1033  			std::cout << boost::str (boost::format ("Starting generating %1% blocks...\n") % (count * 2));
1034  			boost::asio::io_context io_ctx1;
1035  			boost::asio::io_context io_ctx2;
1036  			nano::work_pool work{ network_params.network, std::numeric_limits<unsigned>::max () };
1037  			nano::logging logging;
1038  			auto path1 (nano::unique_path ());
1039  			auto path2 (nano::unique_path ());
1040  			logging.init (path1);
1041  			std::vector<std::string> config_overrides;
1042  			auto config (vm.find ("config"));
1043  			if (config != vm.end ())
1044  			{
1045  				config_overrides = nano::config_overrides (config->second.as<std::vector<nano::config_key_value_pair>> ());
1046  			}
1047  			nano::daemon_config daemon_config{ data_path, network_params };
1048  			auto error = nano::read_node_config_toml (data_path, daemon_config, config_overrides);
1049  			nano::node_config config1 = daemon_config.node;
1050  			config1.peering_port = 24000;
1051  			nano::node_flags flags;
1052  			nano::update_flags (flags, vm);
1053  			flags.disable_lazy_bootstrap = true;
1054  			flags.disable_legacy_bootstrap = true;
1055  			flags.disable_wallet_bootstrap = true;
1056  			flags.disable_bootstrap_listener = true;
1057  			auto node1 (std::make_shared<nano::node> (io_ctx1, path1, config1, work, flags, 0));
1058  			nano::block_hash genesis_latest (node1->latest (nano::dev::genesis_key.pub));
1059  			nano::uint128_t genesis_balance (std::numeric_limits<nano::uint128_t>::max ());
1060  			std::deque<std::shared_ptr<nano::block>> blocks;
1061  			for (auto i (0); i != count; ++i)
1062  			{
1063  				nano::keypair key;
1064  				genesis_balance = genesis_balance - 1;
1065  				auto send = builder.state ()
1066  							.account (nano::dev::genesis_key.pub)
1067  							.previous (genesis_latest)
1068  							.representative (nano::dev::genesis_key.pub)
1069  							.balance (genesis_balance)
1070  							.link (key.pub)
1071  							.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1072  							.work (*work.generate (nano::work_version::work_1, genesis_latest, nano::dev::network_params.work.epoch_1))
1073  							.build ();
1074  				genesis_latest = send->hash ();
1075  				auto open = builder.state ()
1076  							.account (key.pub)
1077  							.previous (0)
1078  							.representative (key.pub)
1079  							.balance (1)
1080  							.link (genesis_latest)
1081  							.sign (key.prv, key.pub)
1082  							.work (*work.generate (nano::work_version::work_1, key.pub, nano::dev::network_params.work.epoch_1))
1083  							.build ();
1084  				blocks.push_back (std::move (send));
1085  				blocks.push_back (std::move (open));
1086  				if (i % 20000 == 0 && i != 0)
1087  				{
1088  					std::cout << boost::str (boost::format ("%1% blocks generated\n") % (i * 2));
1089  				}
1090  			}
1091  			node1->start ();
1092  			nano::thread_runner runner1 (io_ctx1, node1->config.io_threads);
1093  			std::cout << boost::str (boost::format ("Processing %1% blocks\n") % (count * 2));
1094  			for (auto & block : blocks)
1095  			{
1096  				node1->block_processor.add (block);
1097  			}
1098  			node1->block_processor.flush ();
1099  			auto iteration (0);
1100  			while (node1->ledger.cache.block_count != count * 2 + 1)
1101  			{
1102  				std::this_thread::sleep_for (std::chrono::milliseconds (500));
1103  				if (++iteration % 60 == 0)
1104  				{
1105  					std::cout << boost::str (boost::format ("%1% blocks processed\n") % node1->ledger.cache.block_count);
1106  				}
1107  			}
1108  			for (auto & block : blocks)
1109  			{
1110  				node1->confirmation_height_processor.add (block);
1111  			}
1112  			while (node1->ledger.cache.cemented_count != node1->ledger.cache.block_count)
1113  			{
1114  				std::this_thread::sleep_for (std::chrono::milliseconds (500));
1115  				if (++iteration % 60 == 0)
1116  				{
1117  					std::cout << boost::str (boost::format ("%1% blocks cemented\n") % node1->ledger.cache.cemented_count);
1118  				}
1119  			}
1120  			nano::node_config config2 = daemon_config.node;
1121  			config1.peering_port = 24001;
1122  			if (error)
1123  			{
1124  				std::cerr << "\n"
1125  						  << error.get_message () << std::endl;
1126  				std::exit (1);
1127  			}
1128  			else
1129  			{
1130  				config2.frontiers_confirmation = daemon_config.node.frontiers_confirmation;
1131  				config2.active_elections_size = daemon_config.node.active_elections_size;
1132  			}
1133  			auto node2 (std::make_shared<nano::node> (io_ctx2, path2, config2, work, flags, 1));
1134  			node2->start ();
1135  			nano::thread_runner runner2 (io_ctx2, node2->config.io_threads);
1136  			std::cout << boost::str (boost::format ("Processing %1% blocks (test node)\n") % (count * 2));
1137  			while (!blocks.empty ())
1138  			{
1139  				auto block (blocks.front ());
1140  				node2->block_processor.add (block);
1141  				blocks.pop_front ();
1142  			}
1143  			node2->block_processor.flush ();
1144  			while (node2->ledger.cache.block_count != count * 2 + 1)
1145  			{
1146  				std::this_thread::sleep_for (std::chrono::milliseconds (500));
1147  				if (++iteration % 60 == 0)
1148  				{
1149  					std::cout << boost::str (boost::format ("%1% blocks processed\n") % node2->ledger.cache.block_count);
1150  				}
1151  			}
1152  			std::cout << "Initializing representative\n";
1153  			auto wallet (node1->wallets.create (nano::random_wallet_id ()));
1154  			wallet->insert_adhoc (nano::dev::genesis_key.prv);
1155  			node2->network.merge_peer (node1->network.endpoint ());
1156  			while (node2->rep_crawler.representative_count () == 0)
1157  			{
1158  				std::this_thread::sleep_for (std::chrono::milliseconds (10));
1159  				if (++iteration % 500 == 0)
1160  				{
1161  					std::cout << "Representative initialization iteration...\n";
1162  				}
1163  			}
1164  			auto begin (std::chrono::high_resolution_clock::now ());
1165  			std::cout << boost::str (boost::format ("Starting confirming %1% frontiers (test node)\n") % (count + 1));
1166  			while (node2->ledger.cache.cemented_count != node2->ledger.cache.block_count)
1167  			{
1168  				std::this_thread::sleep_for (std::chrono::milliseconds (25));
1169  				if (++iteration % 1200 == 0)
1170  				{
1171  					std::cout << boost::str (boost::format ("%1% blocks confirmed\n") % node2->ledger.cache.cemented_count);
1172  				}
1173  			}
1174  			auto end (std::chrono::high_resolution_clock::now ());
1175  			auto time (std::chrono::duration_cast<std::chrono::microseconds> (end - begin).count ());
1176  			std::cout << boost::str (boost::format ("%|1$ 12d| us \n%2% frontiers per second\n") % time % ((count + 1) * 1000000 / time));
1177  			io_ctx1.stop ();
1178  			io_ctx2.stop ();
1179  			runner1.join ();
1180  			runner2.join ();
1181  			node1->stop ();
1182  			node2->stop ();
1183  		}
1184  		else if (vm.count ("debug_random_feed"))
1185  		{
1186  			nano::raw_key seed;
1187  			for (;;)
1188  			{
1189  				nano::random_pool::generate_block (seed.bytes.data (), seed.bytes.size ());
1190  				std::cout.write (reinterpret_cast<char const *> (seed.bytes.data ()), seed.bytes.size ());
1191  			}
1192  		}
1193  		else if (vm.count ("debug_rpc"))
1194  		{
1195  			std::string rpc_input_l;
1196  			std::ostringstream command_l;
1197  			while (std::cin >> rpc_input_l)
1198  			{
1199  				command_l << rpc_input_l;
1200  			}
1201  			auto response_handler_l ([] (std::string const & response_a) {
1202  				std::cout << response_a;
1203  				std::exit (0);
1204  			});
1205  			auto node_flags = nano::inactive_node_flag_defaults ();
1206  			nano::update_flags (node_flags, vm);
1207  			node_flags.generate_cache.enable_all ();
1208  			nano::inactive_node inactive_node_l (data_path, node_flags);
1209  			nano::node_rpc_config config;
1210  			nano::ipc::ipc_server server (*inactive_node_l.node, config);
1211  			auto handler_l (std::make_shared<nano::json_handler> (*inactive_node_l.node, config, command_l.str (), response_handler_l));
1212  			handler_l->process_request ();
1213  		}
1214  		else if (vm.count ("validate_blocks") || vm.count ("debug_validate_blocks"))
1215  		{
1216  			nano::timer<std::chrono::seconds> timer;
1217  			timer.start ();
1218  			auto node_flags = nano::inactive_node_flag_defaults ();
1219  			nano::update_flags (node_flags, vm);
1220  			node_flags.generate_cache.block_count = true;
1221  			nano::inactive_node inactive_node (data_path, node_flags);
1222  			auto node = inactive_node.node;
1223  			bool const silent (vm.count ("silent"));
1224  			unsigned threads_count (1);
1225  			auto threads_it = vm.find ("threads");
1226  			if (threads_it != vm.end ())
1227  			{
1228  				if (!boost::conversion::try_lexical_convert (threads_it->second.as<std::string> (), threads_count))
1229  				{
1230  					std::cerr << "Invalid threads count\n";
1231  					return -1;
1232  				}
1233  			}
1234  			threads_count = std::max (1u, threads_count);
1235  			std::vector<std::thread> threads;
1236  			nano::mutex mutex;
1237  			nano::condition_variable condition;
1238  			std::atomic<bool> finished (false);
1239  			std::deque<std::pair<nano::account, nano::account_info>> accounts;
1240  			std::atomic<size_t> count (0);
1241  			std::atomic<uint64_t> block_count (0);
1242  			std::atomic<uint64_t> errors (0);
1243  			auto print_error_message = [&silent, &errors] (std::string const & error_message_a) {
1244  				if (!silent)
1245  				{
1246  					static nano::mutex cerr_mutex;
1247  					nano::lock_guard<nano::mutex> lock{ cerr_mutex };
1248  					std::cerr << error_message_a;
1249  				}
1250  				++errors;
1251  			};
1252  			auto start_threads = [node, &threads_count, &threads, &mutex, &condition, &finished] (auto const & function_a, auto & deque_a) {
1253  				for (auto i (0U); i < threads_count; ++i)
1254  				{
1255  					threads.emplace_back ([&function_a, node, &mutex, &condition, &finished, &deque_a] () {
1256  						auto transaction (node->store.tx_begin_read ());
1257  						nano::unique_lock<nano::mutex> lock{ mutex };
1258  						while (!deque_a.empty () || !finished)
1259  						{
1260  							while (deque_a.empty () && !finished)
1261  							{
1262  								condition.wait (lock);
1263  							}
1264  							if (!deque_a.empty ())
1265  							{
1266  								auto pair (deque_a.front ());
1267  								deque_a.pop_front ();
1268  								lock.unlock ();
1269  								function_a (node, transaction, pair.first, pair.second);
1270  								lock.lock ();
1271  							}
1272  						}
1273  					});
1274  				}
1275  			};
1276  			auto check_account = [&print_error_message, &silent, &count, &block_count] (std::shared_ptr<nano::node> const & node, nano::read_transaction const & transaction, nano::account const & account, nano::account_info const & info) {
1277  				++count;
1278  				if (!silent && (count % 20000) == 0)
1279  				{
1280  					std::cout << boost::str (boost::format ("%1% accounts validated\n") % count);
1281  				}
1282  				nano::confirmation_height_info confirmation_height_info;
1283  				node->store.confirmation_height.get (transaction, account, confirmation_height_info);
1284  				if (confirmation_height_info.height > info.block_count)
1285  				{
1286  					print_error_message (boost::str (boost::format ("Confirmation height %1% greater than block count %2% for account: %3%\n") % confirmation_height_info.height % info.block_count % account.to_account ()));
1287  				}
1288  				auto hash (info.open_block);
1289  				nano::block_hash calculated_hash (0);
1290  				auto block (node->store.block.get (transaction, hash)); 
1291  				uint64_t height (0);
1292  				if (node->ledger.pruning && confirmation_height_info.height != 0)
1293  				{
1294  					hash = confirmation_height_info.frontier;
1295  					block = node->store.block.get (transaction, hash);
1296  					bool pruned_block (false);
1297  					while (!pruned_block && !block->previous ().is_zero ())
1298  					{
1299  						auto previous_block (node->store.block.get (transaction, block->previous ()));
1300  						if (previous_block != nullptr)
1301  						{
1302  							hash = previous_block->hash ();
1303  							block = previous_block;
1304  						}
1305  						else
1306  						{
1307  							pruned_block = true;
1308  							if (!node->store.pruned.exists (transaction, block->previous ()))
1309  							{
1310  								print_error_message (boost::str (boost::format ("Pruned previous block does not exist %1%\n") % block->previous ().to_string ()));
1311  							}
1312  						}
1313  					}
1314  					calculated_hash = block->previous ();
1315  					height = block->sideband ().height - 1;
1316  					if (!node->ledger.block_or_pruned_exists (transaction, info.open_block))
1317  					{
1318  						print_error_message (boost::str (boost::format ("Open block does not exist %1%\n") % info.open_block.to_string ()));
1319  					}
1320  				}
1321  				uint64_t previous_timestamp (0);
1322  				nano::account calculated_representative{};
1323  				while (!hash.is_zero () && block != nullptr)
1324  				{
1325  					++block_count;
1326  					auto const & sideband (block->sideband ());
1327  					if (block->type () == nano::block_type::open || block->type () == nano::block_type::state)
1328  					{
1329  						if (block->account () != account)
1330  						{
1331  							print_error_message (boost::str (boost::format ("Incorrect account field for block %1%\n") % hash.to_string ()));
1332  						}
1333  					}
1334  					else if (sideband.account != account)
1335  					{
1336  						print_error_message (boost::str (boost::format ("Incorrect sideband account for block %1%\n") % hash.to_string ()));
1337  					}
1338  					if (calculated_hash != block->previous ())
1339  					{
1340  						print_error_message (boost::str (boost::format ("Incorrect previous field for block %1%\n") % hash.to_string ()));
1341  					}
1342  					if (height == 0 && !block->previous ().is_zero ())
1343  					{
1344  						print_error_message (boost::str (boost::format ("Incorrect previous for open block %1%\n") % hash.to_string ()));
1345  					}
1346  					if (height == 0 && block->type () != nano::block_type::open && block->type () != nano::block_type::state)
1347  					{
1348  						print_error_message (boost::str (boost::format ("Incorrect type for open block %1%\n") % hash.to_string ()));
1349  					}
1350  					calculated_hash = block->hash ();
1351  					if (calculated_hash != hash)
1352  					{
1353  						print_error_message (boost::str (boost::format ("Invalid data inside block %1% calculated hash: %2%\n") % hash.to_string () % calculated_hash.to_string ()));
1354  					}
1355  					if (validate_message (account, hash, block->block_signature ()))
1356  					{
1357  						bool invalid (true);
1358  						if (block->type () == nano::block_type::state)
1359  						{
1360  							auto & state_block (static_cast<nano::state_block &> (*block.get ()));
1361  							nano::amount prev_balance (0);
1362  							bool error_or_pruned (false);
1363  							if (!state_block.hashables.previous.is_zero ())
1364  							{
1365  								prev_balance = node->ledger.balance_safe (transaction, state_block.hashables.previous, error_or_pruned);
1366  							}
1367  							if (node->ledger.is_epoch_link (state_block.hashables.link))
1368  							{
1369  								if ((state_block.hashables.balance == prev_balance && !error_or_pruned) || (node->ledger.pruning && error_or_pruned && block->sideband ().details.is_epoch))
1370  								{
1371  									invalid = validate_message (node->ledger.epoch_signer (block->link ()), hash, block->block_signature ());
1372  								}
1373  							}
1374  						}
1375  						if (invalid)
1376  						{
1377  							print_error_message (boost::str (boost::format ("Invalid signature for block %1%\n") % hash.to_string ()));
1378  						}
1379  					}
1380  					bool block_details_error = false;
1381  					if (block->type () != nano::block_type::state)
1382  					{
1383  						block_details_error = sideband.details.is_send || sideband.details.is_receive || sideband.details.is_epoch;
1384  					}
1385  					else
1386  					{
1387  						bool error_or_pruned (false);
1388  						auto prev_balance (node->ledger.balance_safe (transaction, block->previous (), error_or_pruned));
1389  						if (!node->ledger.pruning || !error_or_pruned)
1390  						{
1391  							if (block->balance () < prev_balance)
1392  							{
1393  								block_details_error = !sideband.details.is_send || sideband.details.is_receive || sideband.details.is_epoch;
1394  							}
1395  							else
1396  							{
1397  								if (block->link ().is_zero ())
1398  								{
1399  									block_details_error = sideband.details.is_send || sideband.details.is_receive || sideband.details.is_epoch;
1400  								}
1401  								else if (block->balance () == prev_balance && node->ledger.is_epoch_link (block->link ()))
1402  								{
1403  									block_details_error = !sideband.details.is_epoch || sideband.details.is_send || sideband.details.is_receive;
1404  								}
1405  								else
1406  								{
1407  									block_details_error = !sideband.details.is_receive || sideband.details.is_send || sideband.details.is_epoch;
1408  									block_details_error |= !node->ledger.block_or_pruned_exists (transaction, block->link ().as_block_hash ());
1409  								}
1410  							}
1411  						}
1412  						else if (!node->store.pruned.exists (transaction, block->previous ()))
1413  						{
1414  							print_error_message (boost::str (boost::format ("Previous pruned block does not exist %1%\n") % block->previous ().to_string ()));
1415  						}
1416  					}
1417  					if (block_details_error)
1418  					{
1419  						print_error_message (boost::str (boost::format ("Incorrect sideband block details for block %1%\n") % hash.to_string ()));
1420  					}
1421  					if (sideband.details.is_receive && (!node->ledger.pruning || !node->store.pruned.exists (transaction, block->link ().as_block_hash ())))
1422  					{
1423  						if (sideband.source_epoch != node->store.block.version (transaction, block->link ().as_block_hash ()))
1424  						{
1425  							print_error_message (boost::str (boost::format ("Incorrect source epoch for block %1%\n") % hash.to_string ()));
1426  						}
1427  					}
1428  					if (node->network_params.work.difficulty (*block) < node->network_params.work.threshold (block->work_version (), block->sideband ().details))
1429  					{
1430  						print_error_message (boost::str (boost::format ("Invalid work for block %1% value: %2%\n") % hash.to_string () % nano::to_string_hex (block->block_work ())));
1431  					}
1432  					++height;
1433  					if (sideband.height != height)
1434  					{
1435  						print_error_message (boost::str (boost::format ("Incorrect sideband height for block %1%. Sideband: %2%. Expected: %3%\n") % hash.to_string () % sideband.height % height));
1436  					}
1437  					if (sideband.timestamp < previous_timestamp)
1438  					{
1439  						print_error_message (boost::str (boost::format ("Incorrect sideband timestamp for block %1%\n") % hash.to_string ()));
1440  					}
1441  					previous_timestamp = sideband.timestamp;
1442  					if (block->type () == nano::block_type::open || block->type () == nano::block_type::change || block->type () == nano::block_type::state)
1443  					{
1444  						calculated_representative = block->representative ();
1445  					}
1446  					hash = node->store.block.successor (transaction, hash);
1447  					if (!hash.is_zero ())
1448  					{
1449  						block = node->store.block.get (transaction, hash);
1450  					}
1451  				}
1452  				if (!hash.is_zero () && block == nullptr)
1453  				{
1454  					print_error_message (boost::str (boost::format ("Required block in account %1% chain was not found in ledger: %2%\n") % account.to_account () % hash.to_string ()));
1455  				}
1456  				if (info.block_count != height)
1457  				{
1458  					print_error_message (boost::str (boost::format ("Incorrect block count for account %1%. Actual: %2%. Expected: %3%\n") % account.to_account () % height % info.block_count));
1459  				}
1460  				if (info.head != calculated_hash)
1461  				{
1462  					print_error_message (boost::str (boost::format ("Incorrect frontier for account %1%. Actual: %2%. Expected: %3%\n") % account.to_account () % calculated_hash.to_string () % info.head.to_string ()));
1463  				}
1464  				if (info.representative != calculated_representative)
1465  				{
1466  					print_error_message (boost::str (boost::format ("Incorrect representative for account %1%. Actual: %2%. Expected: %3%\n") % account.to_account () % calculated_representative.to_string () % info.representative.to_string ()));
1467  				}
1468  			};
1469  			start_threads (check_account, accounts);
1470  			if (!silent)
1471  			{
1472  				std::cout << boost::str (boost::format ("Performing %1% threads blocks hash, signature, work validation...\n") % threads_count);
1473  			}
1474  			size_t const accounts_deque_overflow (32 * 1024);
1475  			auto transaction (node->store.tx_begin_read ());
1476  			for (auto i (node->store.account.begin (transaction)), n (node->store.account.end ()); i != n; ++i)
1477  			{
1478  				{
1479  					nano::unique_lock<nano::mutex> lock{ mutex };
1480  					if (accounts.size () > accounts_deque_overflow)
1481  					{
1482  						auto wait_ms (250 * accounts.size () / accounts_deque_overflow);
1483  						auto const wakeup (std::chrono::steady_clock::now () + std::chrono::milliseconds (wait_ms));
1484  						condition.wait_until (lock, wakeup);
1485  					}
1486  					accounts.emplace_back (i->first, i->second);
1487  				}
1488  				condition.notify_all ();
1489  			}
1490  			{
1491  				nano::lock_guard<nano::mutex> lock{ mutex };
1492  				finished = true;
1493  			}
1494  			condition.notify_all ();
1495  			for (auto & thread : threads)
1496  			{
1497  				thread.join ();
1498  			}
1499  			threads.clear ();
1500  			if (!silent)
1501  			{
1502  				std::cout << boost::str (boost::format ("%1% accounts validated\n") % count);
1503  			}
1504  			auto ledger_block_count (node->store.block.count (transaction));
1505  			if (node->flags.enable_pruning)
1506  			{
1507  				block_count += 1; 
1508  			}
1509  			if (block_count != ledger_block_count)
1510  			{
1511  				print_error_message (boost::str (boost::format ("Incorrect total block count. Blocks validated %1%. Block count in database: %2%\n") % block_count % ledger_block_count));
1512  			}
1513  			count = 0;
1514  			finished = false;
1515  			std::deque<std::pair<nano::pending_key, nano::pending_info>> pending;
1516  			auto check_pending = [&print_error_message, &silent, &count] (std::shared_ptr<nano::node> const & node, nano::read_transaction const & transaction, nano::pending_key const & key, nano::pending_info const & info) {
1517  				++count;
1518  				if (!silent && (count % 500000) == 0)
1519  				{
1520  					std::cout << boost::str (boost::format ("%1% pending blocks validated\n") % count);
1521  				}
1522  				auto block (node->store.block.get_no_sideband (transaction, key.hash));
1523  				bool pruned (false);
1524  				if (block == nullptr)
1525  				{
1526  					pruned = node->ledger.pruning && node->store.pruned.exists (transaction, key.hash);
1527  					if (!pruned)
1528  					{
1529  						print_error_message (boost::str (boost::format ("Pending block does not exist %1%\n") % key.hash.to_string ()));
1530  					}
1531  				}
1532  				else
1533  				{
1534  					nano::account destination{};
1535  					bool previous_pruned = node->ledger.pruning && node->store.pruned.exists (transaction, block->previous ());
1536  					if (previous_pruned)
1537  					{
1538  						block = node->store.block.get (transaction, key.hash);
1539  					}
1540  					if (auto state = dynamic_cast<nano::state_block *> (block.get ()))
1541  					{
1542  						if (node->ledger.is_send (transaction, *state))
1543  						{
1544  							destination = state->hashables.link.as_account ();
1545  						}
1546  					}
1547  					else if (auto send = dynamic_cast<nano::send_block *> (block.get ()))
1548  					{
1549  						destination = send->hashables.destination;
1550  					}
1551  					else
1552  					{
1553  						print_error_message (boost::str (boost::format ("Incorrect type for pending block %1%\n") % key.hash.to_string ()));
1554  					}
1555  					if (key.account != destination)
1556  					{
1557  						print_error_message (boost::str (boost::format ("Incorrect destination for pending block %1%\n") % key.hash.to_string ()));
1558  					}
1559  					auto account (node->ledger.account (transaction, key.hash));
1560  					if (info.source != account && !pruned)
1561  					{
1562  						print_error_message (boost::str (boost::format ("Incorrect source for pending block %1%\n") % key.hash.to_string ()));
1563  					}
1564  					if (!pruned && !previous_pruned)
1565  					{
1566  						auto amount (node->ledger.amount (transaction, key.hash));
1567  						if (info.amount != amount)
1568  						{
1569  							print_error_message (boost::str (boost::format ("Incorrect amount for pending block %1%\n") % key.hash.to_string ()));
1570  						}
1571  					}
1572  				}
1573  			};
1574  			start_threads (check_pending, pending);
1575  			size_t const pending_deque_overflow (64 * 1024);
1576  			for (auto i (node->store.pending.begin (transaction)), n (node->store.pending.end ()); i != n; ++i)
1577  			{
1578  				{
1579  					nano::unique_lock<nano::mutex> lock{ mutex };
1580  					if (pending.size () > pending_deque_overflow)
1581  					{
1582  						auto wait_ms (50 * pending.size () / pending_deque_overflow);
1583  						auto const wakeup (std::chrono::steady_clock::now () + std::chrono::milliseconds (wait_ms));
1584  						condition.wait_until (lock, wakeup);
1585  					}
1586  					pending.emplace_back (i->first, i->second);
1587  				}
1588  				condition.notify_all ();
1589  			}
1590  			{
1591  				nano::lock_guard<nano::mutex> lock{ mutex };
1592  				finished = true;
1593  			}
1594  			condition.notify_all ();
1595  			for (auto & thread : threads)
1596  			{
1597  				thread.join ();
1598  			}
1599  			if (!silent)
1600  			{
1601  				std::cout << boost::str (boost::format ("%1% pending blocks validated\n") % count);
1602  				timer.stop ();
1603  				std::cout << boost::str (boost::format ("%1% %2% validation time\n") % timer.value ().count () % timer.unit ());
1604  			}
1605  			if (errors == 0)
1606  			{
1607  				std::cout << "Validation status: Ok\n";
1608  			}
1609  			else
1610  			{
1611  				std::cout << boost::str (boost::format ("Validation status: Failed\n%1% errors found\n") % errors);
1612  			}
1613  		}
1614  		else if (vm.count ("debug_profile_bootstrap"))
1615  		{
1616  			auto node_flags = nano::inactive_node_flag_defaults ();
1617  			node_flags.read_only = false;
1618  			nano::update_flags (node_flags, vm);
1619  			nano::inactive_node node (nano::unique_path (), node_flags);
1620  			auto begin (std::chrono::high_resolution_clock::now ());
1621  			uint64_t block_count (0);
1622  			size_t count (0);
1623  			std::deque<std::shared_ptr<nano::block>> epoch_open_blocks;
1624  			{
1625  				auto node_flags = nano::inactive_node_flag_defaults ();
1626  				nano::update_flags (node_flags, vm);
1627  				node_flags.generate_cache.block_count = true;
1628  				nano::inactive_node inactive_node (data_path, node_flags);
1629  				auto source_node = inactive_node.node;
1630  				auto transaction (source_node->store.tx_begin_read ());
1631  				block_count = source_node->ledger.cache.block_count;
1632  				std::cout << boost::str (boost::format ("Performing bootstrap emulation, %1% blocks in ledger...") % block_count) << std::endl;
1633  				for (auto i (source_node->store.account.begin (transaction)), n (source_node->store.account.end ()); i != n; ++i)
1634  				{
1635  					nano::account const & account (i->first);
1636  					nano::account_info const & info (i->second);
1637  					auto hash (info.head);
1638  					while (!hash.is_zero ())
1639  					{
1640  						auto block (source_node->store.block.get_no_sideband (transaction, hash));
1641  						if (block != nullptr)
1642  						{
1643  							++count;
1644  							if ((count % 500000) == 0)
1645  							{
1646  								std::cout << boost::str (boost::format ("%1% blocks retrieved") % count) << std::endl;
1647  							}
1648  							node.node->block_processor.add (block);
1649  							if (block->type () == nano::block_type::state && block->previous ().is_zero () && source_node->ledger.is_epoch_link (block->link ()))
1650  							{
1651  								epoch_open_blocks.push_back (block);
1652  							}
1653  							hash = block->previous ();
1654  						}
1655  					}
1656  				}
1657  			}
1658  			nano::timer<std::chrono::seconds> timer_l (nano::timer_state::started);
1659  			while (node.node->ledger.cache.block_count != block_count)
1660  			{
1661  				std::this_thread::sleep_for (std::chrono::milliseconds (500));
1662  				if (node.node->block_processor.size () == 0)
1663  				{
1664  					for (auto & block : epoch_open_blocks)
1665  					{
1666  						node.node->block_processor.add (block);
1667  					}
1668  				}
1669  				if (timer_l.after_deadline (std::chrono::seconds (60)))
1670  				{
1671  					timer_l.restart ();
1672  					std::cout << boost::str (boost::format ("%1% (%2%) blocks processed (unchecked)") % node.node->ledger.cache.block_count % node.node->unchecked.count ()) << std::endl;
1673  				}
1674  			}
1675  			node.node->block_processor.flush ();
1676  			auto end (std::chrono::high_resolution_clock::now ());
1677  			auto time (std::chrono::duration_cast<std::chrono::microseconds> (end - begin).count ());
1678  			auto us_in_second (1000000);
1679  			auto seconds (time / us_in_second);
1680  			nano::remove_temporary_directories ();
1681  			std::cout << boost::str (boost::format ("%|1$ 12d| seconds \n%2% blocks per second") % seconds % (block_count * us_in_second / time)) << std::endl;
1682  			release_assert (node.node->ledger.cache.block_count == block_count);
1683  		}
1684  		else if (vm.count ("debug_peers"))
1685  		{
1686  			auto inactive_node = nano::default_inactive_node (data_path, vm);
1687  			auto node = inactive_node->node;
1688  			auto transaction (node->store.tx_begin_read ());
1689  			for (auto i (node->store.peer.begin (transaction)), n (node->store.peer.end ()); i != n; ++i)
1690  			{
1691  				std::cout << boost::str (boost::format ("%1%\n") % nano::endpoint (boost::asio::ip::address_v6 (i->first.address_bytes ()), i->first.port ()));
1692  			}
1693  		}
1694  		else if (vm.count ("debug_cemented_block_count"))
1695  		{
1696  			auto node_flags = nano::inactive_node_flag_defaults ();
1697  			node_flags.generate_cache.cemented_count = true;
1698  			nano::update_flags (node_flags, vm);
1699  			nano::inactive_node node (data_path, node_flags);
1700  			std::cout << "Total cemented block count: " << node.node->ledger.cache.cemented_count << std::endl;
1701  		}
1702  		else if (vm.count ("debug_prune"))
1703  		{
1704  			auto node_flags = nano::inactive_node_flag_defaults ();
1705  			node_flags.read_only = false;
1706  			nano::update_flags (node_flags, vm);
1707  			nano::inactive_node inactive_node (data_path, node_flags);
1708  			auto node = inactive_node.node;
1709  			node->ledger_pruning (node_flags.block_processor_batch_size != 0 ? node_flags.block_processor_batch_size : 16 * 1024, true, true);
1710  		}
1711  		else if (vm.count ("debug_stacktrace"))
1712  		{
1713  			std::cout << boost::stacktrace::stacktrace ();
1714  		}
1715  		else if (vm.count ("debug_sys_logging"))
1716  		{
1717  #ifdef BOOST_WINDOWS
1718  			if (!nano::event_log_reg_entry_exists () && !nano::is_windows_elevated ())
1719  			{
1720  				std::cerr << "The event log requires the HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\EventLog\\Nano\\Nano registry entry, run again as administator to create it.\n";
1721  				return 1;
1722  			}
1723  #endif
1724  			auto inactive_node = nano::default_inactive_node (data_path, vm);
1725  			inactive_node->node->logger.always_log (nano::severity_level::error, "Testing system logger");
1726  		}
1727  		else if (vm.count ("debug_account_versions"))
1728  		{
1729  			auto inactive_node = nano::default_inactive_node (data_path, vm);
1730  			auto node = inactive_node->node;
1731  			auto const epoch_count = nano::normalized_epoch (nano::epoch::max) + static_cast<std::underlying_type<nano::epoch>::type> (1);
1732  			nano::locked<std::vector<boost::unordered_set<nano::account>>> opened_account_versions_shared (epoch_count);
1733  			using opened_account_versions_t = decltype (opened_account_versions_shared)::value_type;
1734  			node->store.account.for_each_par (
1735  			[&opened_account_versions_shared, epoch_count] (nano::read_transaction const & &bsol;*unused*/, nano::store_iterator<nano::account, nano::account_info> i, nano::store_iterator<nano::account, nano::account_info> n) {
1736  				opened_account_versions_t opened_account_versions_l (epoch_count);
1737  				for (; i != n; ++i)
1738  				{
1739  					auto const & account (i->first);
1740  					auto const & account_info (i->second);
1741  					auto epoch_idx = nano::normalized_epoch (account_info.epoch ());
1742  					opened_account_versions_l[epoch_idx].emplace (account);
1743  				}
1744  				auto opened_account_versions = opened_account_versions_shared.lock ();
1745  				debug_assert (opened_account_versions->size () == opened_account_versions_l.size ());
1746  				for (auto idx (0); idx < opened_account_versions_l.size (); ++idx)
1747  				{
1748  					auto & accounts = opened_account_versions->at (idx);
1749  					auto const & accounts_l = opened_account_versions_l.at (idx);
1750  					accounts.insert (accounts_l.begin (), accounts_l.end ());
1751  				}
1752  			});
1753  			boost::unordered_set<nano::account> opened_accounts;
1754  			{
1755  				auto opened_account_versions = opened_account_versions_shared.lock ();
1756  				for (auto const & account_version : *opened_account_versions)
1757  				{
1758  					opened_accounts.insert (account_version.cbegin (), account_version.cend ());
1759  				}
1760  			}
1761  			nano::locked<boost::unordered_map<nano::account, std::underlying_type_t<nano::epoch>>> unopened_highest_pending_shared;
1762  			using unopened_highest_pending_t = decltype (unopened_highest_pending_shared)::value_type;
1763  			node->store.pending.for_each_par (
1764  			[&unopened_highest_pending_shared, &opened_accounts] (nano::read_transaction const & &bsol;*unused*/, nano::store_iterator<nano::pending_key, nano::pending_info> i, nano::store_iterator<nano::pending_key, nano::pending_info> n) {
1765  				unopened_highest_pending_t unopened_highest_pending_l;
1766  				for (; i != n; ++i)
1767  				{
1768  					nano::pending_key const & key (i->first);
1769  					nano::pending_info const & info (i->second);
1770  					auto & account = key.account;
1771  					auto exists = opened_accounts.find (account) != opened_accounts.end ();
1772  					if (!exists)
1773  					{
1774  						auto epoch = nano::normalized_epoch (info.epoch);
1775  						auto & existing_or_new = unopened_highest_pending_l[key.account];
1776  						existing_or_new = std::max (epoch, existing_or_new);
1777  					}
1778  				}
1779  				auto unopened_highest_pending = unopened_highest_pending_shared.lock ();
1780  				for (auto const & [account, epoch] : unopened_highest_pending_l)
1781  				{
1782  					auto & existing_or_new = unopened_highest_pending->operator[] (account);
1783  					existing_or_new = std::max (epoch, existing_or_new);
1784  				}
1785  			});
1786  			auto output_account_version_number = [] (auto version, auto num_accounts) {
1787  				std::cout << "Account version " << version << " num accounts: " << num_accounts << "\n";
1788  			};
1789  			auto const & opened_account_versions = *opened_account_versions_shared.lock ();
1790  			auto const & unopened_highest_pending = *unopened_highest_pending_shared.lock ();
1791  			std::cout << "Opened accounts:\n";
1792  			for (auto i = 0u; i < opened_account_versions.size (); ++i)
1793  			{
1794  				output_account_version_number (i, opened_account_versions[i].size ());
1795  			}
1796  			std::vector<size_t> unopened_account_version_totals (epoch_count);
1797  			for (auto const & [account, epoch] : unopened_highest_pending)
1798  			{
1799  				++unopened_account_version_totals[epoch];
1800  			}
1801  			std::cout << "\nUnopened accounts:\n";
1802  			for (auto i = 0u; i < unopened_account_version_totals.size (); ++i)
1803  			{
1804  				output_account_version_number (i, unopened_account_version_totals[i]);
1805  			}
1806  		}
1807  		else if (vm.count ("debug_unconfirmed_frontiers"))
1808  		{
1809  			auto inactive_node = nano::default_inactive_node (data_path, vm);
1810  			auto node = inactive_node->node;
1811  			auto unconfirmed_frontiers = node->ledger.unconfirmed_frontiers ();
1812  			std::cout << "Account: Height delta | Frontier | Confirmed frontier\n";
1813  			for (auto const & [height_delta, unconfirmed_info] : unconfirmed_frontiers)
1814  			{
1815  				std::cout << (boost::format ("%1%: %2% %3% %4%\n") % unconfirmed_info.account.to_account () % height_delta % unconfirmed_info.frontier.to_string () % unconfirmed_info.cemented_frontier.to_string ()).str ();
1816  			}
1817  			std::cout << "\nNumber of unconfirmed frontiers: " << unconfirmed_frontiers.size () << std::endl;
1818  		}
1819  		else if (vm.count ("version"))
1820  		{
1821  			std::cout << "Version " << NANO_VERSION_STRING << "\n"
1822  					  << "Build Info " << BUILD_INFO << std::endl;
1823  		}
1824  		else
1825  		{
1826  			boost::program_options::options_description sorted_description ("Command line options");
1827  			nano::sort_options_description (description, sorted_description);
1828  			std::cout << sorted_description << std::endl;
1829  			result = -1;
1830  		}
1831  	}
1832  	return result;
1833  }
1834  namespace
1835  {
1836  std::istream & operator>> (std::istream & in, uint64_from_hex & out_val)
1837  {
1838  	in >> std::hex >> out_val.value;
1839  	return in;
1840  }
1841  address_library_pair::address_library_pair (uint64_t address, std::string library) :
1842  	address (address), library (library)
1843  {
1844  }
1845  bool address_library_pair::operator< (const address_library_pair & other) const
1846  {
1847  	return address < other.address;
1848  }
1849  bool address_library_pair::operator== (const address_library_pair & other) const
1850  {
1851  	return address == other.address;
1852  }
1853  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-rpcconfig.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-entry_11.cpp</div>
                </div>
                <div class="column column_space"><pre><code>129  	boost::system::error_code err;
130  	auto running_executable_filepath = boost::dll::program_location (err);
131  	auto rpc_filepath = running_executable_filepath.parent_path () / "nano_rpc";
</pre></code></div>
                <div class="column column_space"><pre><code>633  				boost::system::error_code err;
634  				auto running_executable_filepath = boost::dll::program_location (err);
635  				if (!err)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    