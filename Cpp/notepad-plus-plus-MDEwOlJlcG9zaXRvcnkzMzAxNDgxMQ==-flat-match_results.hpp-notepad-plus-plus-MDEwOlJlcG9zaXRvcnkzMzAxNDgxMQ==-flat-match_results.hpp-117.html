
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 35, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-match_results.hpp</h3>
            <pre><code>1  #ifndef BOOST_REGEX_V5_MATCH_RESULTS_HPP
2  #define BOOST_REGEX_V5_MATCH_RESULTS_HPP
3  namespace boost{
4  #ifdef BOOST_REGEX_MSVC
5  #pragma warning(push)
6  #pragma warning(disable : 4251 4459)
7  #if BOOST_REGEX_MSVC &lt; 1700
8  #     pragma warning(disable : 4231)
9  #endif
10  #  if BOOST_REGEX_MSVC &lt; 1600
11  #     pragma warning(disable : 4660)
12  #  endif
13  #endif
14  namespace BOOST_REGEX_DETAIL_NS{
15  class named_subexpressions;
16  }
17  template &lt;class BidiIterator, class Allocator&gt;
18  class match_results
19  { 
20  private:
21     typedef          std::vector&lt;sub_match&lt;BidiIterator&gt;, Allocator&gt; vector_type;
22  public: 
23     typedef          sub_match&lt;BidiIterator&gt;                         value_type;
24     typedef typename std::allocator_traits&lt;Allocator&gt;::value_type const &amp;    const_reference;
25     typedef          const_reference                                         reference;
26     typedef typename vector_type::const_iterator                             const_iterator;
27     typedef          const_iterator                                          iterator;
28     typedef typename std::iterator_traits&lt;
29                                      BidiIterator&gt;::difference_type          difference_type;
30     typedef typename std::allocator_traits&lt;Allocator&gt;::size_type             size_type;
31     typedef          Allocator                                               allocator_type;
32     typedef typename std::iterator_traits&lt;
33                                      BidiIterator&gt;::value_type               char_type;
34     typedef          std::basic_string&lt;char_type&gt;                            string_type;
35     typedef          BOOST_REGEX_DETAIL_NS::named_subexpressions             named_sub_type;
36     explicit match_results(const Allocator&amp; a = Allocator())
37        : m_subs(a), m_base(), m_null(), m_last_closed_paren(0), m_is_singular(true) {}
38     match_results(const match_results&amp; m)
39        : m_subs(m.m_subs), m_base(), m_null(), m_named_subs(m.m_named_subs), m_last_closed_paren(m.m_last_closed_paren), m_is_singular(m.m_is_singular)
40     {
41        if(!m_is_singular)
42        {
43           m_base = m.m_base;
44           m_null = m.m_null;
45        }
46     }
47     match_results&amp; operator=(const match_results&amp; m)
48     {
49        m_subs = m.m_subs;
50        m_named_subs = m.m_named_subs;
51        m_last_closed_paren = m.m_last_closed_paren;
52        m_is_singular = m.m_is_singular;
53        if(!m_is_singular)
54        {
55           m_base = m.m_base;
56           m_null = m.m_null;
57        }
58        return *this;
59     }
60     ~match_results(){}
61     size_type size() const
62     { return empty() ? 0 : m_subs.size() - 2; }
63     size_type max_size() const
64     { return m_subs.max_size(); }
65     bool empty() const
66     { return m_subs.size() &lt; 2; }
67     difference_type length(int sub = 0) const
68     {
69        if(m_is_singular)
70           raise_logic_error();
71        sub += 2;
72        if((sub &lt; (int)m_subs.size()) &amp;&amp; (sub &gt; 0))
73           return m_subs[sub].length();
74        return 0;
75     }
76     difference_type length(const char_type* sub) const
77     {
78        if(m_is_singular)
79           raise_logic_error();
80        const char_type* sub_end = sub;
81        while(*sub_end) ++sub_end;
82        return length(named_subexpression_index(sub, sub_end));
83     }
84     template &lt;class charT&gt;
85     difference_type length(const charT* sub) const
86     {
87        if(m_is_singular)
88           raise_logic_error();
89        const charT* sub_end = sub;
90        while(*sub_end) ++sub_end;
91        return length(named_subexpression_index(sub, sub_end));
92     }
93     template &lt;class charT, class Traits, class A&gt;
94     difference_type length(const std::basic_string&lt;charT, Traits, A&gt;&amp; sub) const
95     {
96        return length(sub.c_str());
97     }
98     difference_type position(size_type sub = 0) const
99     {
100        if(m_is_singular)
101           raise_logic_error();
102        sub += 2;
103        if(sub &lt; m_subs.size())
104        {
105           const sub_match&lt;BidiIterator&gt;&amp; s = m_subs[sub];
106           if(s.matched || (sub == 2))
107           {
108              return std::distance((BidiIterator)(m_base), (BidiIterator)(s.first));
109           }
110        }
111        return ~static_cast&lt;difference_type&gt;(0);
112     }
113     difference_type position(const char_type* sub) const
114     {
115        const char_type* sub_end = sub;
116        while(*sub_end) ++sub_end;
117        return position(named_subexpression_index(sub, sub_end));
118     }
119     template &lt;class charT&gt;
120     difference_type position(const charT* sub) const
121     {
122        const charT* sub_end = sub;
123        while(*sub_end) ++sub_end;
124        return position(named_subexpression_index(sub, sub_end));
125     }
126     template &lt;class charT, class Traits, class A&gt;
127     difference_type position(const std::basic_string&lt;charT, Traits, A&gt;&amp; sub) const
128     {
129        return position(sub.c_str());
130     }
131     string_type str(int sub = 0) const
132     {
133        if(m_is_singular)
134           raise_logic_error();
135        sub += 2;
136        string_type result;
137        if(sub &lt; (int)m_subs.size() &amp;&amp; (sub &gt; 0))
138        {
139           const sub_match&lt;BidiIterator&gt;&amp; s = m_subs[sub];
140           if(s.matched)
141           {
142              result = s.str();
143           }
144        }
145        return result;
146     }
147     string_type str(const char_type* sub) const
148     {
149        return (*this)[sub].str();
150     }
151     template &lt;class Traits, class A&gt;
152     string_type str(const std::basic_string&lt;char_type, Traits, A&gt;&amp; sub) const
153     {
154        return (*this)[sub].str();
155     }
156     template &lt;class charT&gt;
157     string_type str(const charT* sub) const
158     {
159        return (*this)[sub].str();
160     }
161     template &lt;class charT, class Traits, class A&gt;
162     string_type str(const std::basic_string&lt;charT, Traits, A&gt;&amp; sub) const
163     {
164        return (*this)[sub].str();
165     }
166     const_reference operator[](int sub) const
167     {
168        if(m_is_singular &amp;&amp; m_subs.empty())
169           raise_logic_error();
170        sub += 2;
171        if(sub &lt; (int)m_subs.size() &amp;&amp; (sub &gt;= 0))
172        {
173           return m_subs[sub];
174        }
175        return m_null;
176     }
177     const_reference named_subexpression(const char_type* i, const char_type* j) const
178     {
179        if(m_is_singular)
180           raise_logic_error();
181        BOOST_REGEX_DETAIL_NS::named_subexpressions::range_type r = m_named_subs-&gt;equal_range(i, j);
<span onclick='openModal()' class='match'>182        while((r.first != r.second) &amp;&amp; ((*this)[r.first-&gt;index].matched == false))
183           ++r.first;
184        return r.first != r.second ? (*this)[r.first-&gt;index] : m_null;
</span>185     }
186     template &lt;class charT&gt;
187     const_reference named_subexpression(const charT* i, const charT* j) const
188     {
189        static_assert(sizeof(charT) &lt;= sizeof(char_type), &quot;Failed internal logic&quot;);
190        if(i == j)
191           return m_null;
192        std::vector&lt;char_type&gt; s;
193        while(i != j)
194           s.insert(s.end(), *i++);
195        return named_subexpression(&amp;*s.begin(), &amp;*s.begin() + s.size());
196     }
197     int named_subexpression_index(const char_type* i, const char_type* j) const
198     {
199        if(m_is_singular)
200           raise_logic_error();
201        BOOST_REGEX_DETAIL_NS::named_subexpressions::range_type s, r;
202        s = r = m_named_subs-&gt;equal_range(i, j);
203        while((r.first != r.second) &amp;&amp; ((*this)[r.first-&gt;index].matched == false))
204           ++r.first;
205        if(r.first == r.second)
206           r = s;
207        return r.first != r.second ? r.first-&gt;index : -20;
208     }
209     template &lt;class charT&gt;
210     int named_subexpression_index(const charT* i, const charT* j) const
211     {
212        static_assert(sizeof(charT) &lt;= sizeof(char_type), &quot;Failed internal logic&quot;);
213        if(i == j)
214           return -20;
215        std::vector&lt;char_type&gt; s;
216        while(i != j)
217           s.insert(s.end(), *i++);
218        return named_subexpression_index(&amp;*s.begin(), &amp;*s.begin() + s.size());
219     }
220     template &lt;class Traits, class A&gt;
221     const_reference operator[](const std::basic_string&lt;char_type, Traits, A&gt;&amp; s) const
222     {
223        return named_subexpression(s.c_str(), s.c_str() + s.size());
224     }
225     const_reference operator[](const char_type* p) const
226     {
227        const char_type* e = p;
228        while(*e) ++e;
229        return named_subexpression(p, e);
230     }
231     template &lt;class charT&gt;
232     const_reference operator[](const charT* p) const
233     {
234        static_assert(sizeof(charT) &lt;= sizeof(char_type), &quot;Failed internal logic&quot;);
235        if(*p == 0)
236           return m_null;
237        std::vector&lt;char_type&gt; s;
238        while(*p)
239           s.insert(s.end(), *p++);
240        return named_subexpression(&amp;*s.begin(), &amp;*s.begin() + s.size());
241     }
242     template &lt;class charT, class Traits, class A&gt;
243     const_reference operator[](const std::basic_string&lt;charT, Traits, A&gt;&amp; ns) const
244     {
245        static_assert(sizeof(charT) &lt;= sizeof(char_type), &quot;Failed internal logic&quot;);
246        if(ns.empty())
247           return m_null;
248        std::vector&lt;char_type&gt; s;
249        for(unsigned i = 0; i &lt; ns.size(); ++i)
250           s.insert(s.end(), ns[i]);
251        return named_subexpression(&amp;*s.begin(), &amp;*s.begin() + s.size());
252     }
253     const_reference prefix() const
254     {
255        if(m_is_singular)
256           raise_logic_error();
257        return (*this)[-1];
258     }
259     const_reference suffix() const
260     {
261        if(m_is_singular)
262           raise_logic_error();
263        return (*this)[-2];
264     }
265     const_iterator begin() const
266     {
267        return (m_subs.size() &gt; 2) ? (m_subs.begin() + 2) : m_subs.end();
268     }
269     const_iterator end() const
270     {
271        return m_subs.end();
272     }
273     template &lt;class OutputIterator, class Functor&gt;
274     OutputIterator format(OutputIterator out,
275                           Functor fmt,
276                           match_flag_type flags = format_default) const
277     {
278        if(m_is_singular)
279           raise_logic_error();
280        typedef typename BOOST_REGEX_DETAIL_NS::compute_functor_type&lt;Functor, match_results&lt;BidiIterator, Allocator&gt;, OutputIterator&gt;::type F;
281        F func(fmt);
282        return func(*this, out, flags);
283     }
284     template &lt;class Functor&gt;
285     string_type format(Functor fmt, match_flag_type flags = format_default) const
286     {
287        if(m_is_singular)
288           raise_logic_error();
289        std::basic_string&lt;char_type&gt; result;
290        BOOST_REGEX_DETAIL_NS::string_out_iterator&lt;std::basic_string&lt;char_type&gt; &gt; i(result);
291        typedef typename BOOST_REGEX_DETAIL_NS::compute_functor_type&lt;Functor, match_results&lt;BidiIterator, Allocator&gt;, BOOST_REGEX_DETAIL_NS::string_out_iterator&lt;std::basic_string&lt;char_type&gt; &gt; &gt;::type F;
292        F func(fmt);
293        func(*this, i, flags);
294        return result;
295     }
296     template &lt;class OutputIterator, class Functor, class RegexT&gt;
297     OutputIterator format(OutputIterator out,
298                           Functor fmt,
299                           match_flag_type flags,
300                           const RegexT&amp; re) const
301     {
302        if(m_is_singular)
303           raise_logic_error();
304        typedef ::boost::regex_traits_wrapper&lt;typename RegexT::traits_type&gt; traits_type;
305        typedef typename BOOST_REGEX_DETAIL_NS::compute_functor_type&lt;Functor, match_results&lt;BidiIterator, Allocator&gt;, OutputIterator, traits_type&gt;::type F;
306        F func(fmt);
307        return func(*this, out, flags, re.get_traits());
308     }
309     template &lt;class RegexT, class Functor&gt;
310     string_type format(Functor fmt,
311                        match_flag_type flags,
312                        const RegexT&amp; re) const
313     {
314        if(m_is_singular)
315           raise_logic_error();
316        typedef ::boost::regex_traits_wrapper&lt;typename RegexT::traits_type&gt; traits_type;
317        std::basic_string&lt;char_type&gt; result;
318        BOOST_REGEX_DETAIL_NS::string_out_iterator&lt;std::basic_string&lt;char_type&gt; &gt; i(result);
319        typedef typename BOOST_REGEX_DETAIL_NS::compute_functor_type&lt;Functor, match_results&lt;BidiIterator, Allocator&gt;, BOOST_REGEX_DETAIL_NS::string_out_iterator&lt;std::basic_string&lt;char_type&gt; &gt;, traits_type &gt;::type F;
320        F func(fmt);
321        func(*this, i, flags, re.get_traits());
322        return result;
323     }
324     const_reference get_last_closed_paren()const
325     {
326        if(m_is_singular)
327           raise_logic_error();
328        return m_last_closed_paren == 0 ? m_null : (*this)[m_last_closed_paren];
329     }
330     allocator_type get_allocator() const
331     {
332        return m_subs.get_allocator();
333     }
334     void swap(match_results&amp; that)
335     {
336        std::swap(m_subs, that.m_subs);
337        std::swap(m_named_subs, that.m_named_subs);
338        std::swap(m_last_closed_paren, that.m_last_closed_paren);
339        if(m_is_singular)
340        {
341           if(!that.m_is_singular)
342           {
343              m_base = that.m_base;
344              m_null = that.m_null;
345           }
346        }
347        else if(that.m_is_singular)
348        {
349           that.m_base = m_base;
350           that.m_null = m_null;
351        }
352        else
353        {
354           std::swap(m_base, that.m_base);
355           std::swap(m_null, that.m_null);
356        }
357        std::swap(m_is_singular, that.m_is_singular);
358     }
359     bool operator==(const match_results&amp; that)const
360     {
361        if(m_is_singular)
362        {
363           return that.m_is_singular;
364        }
365        else if(that.m_is_singular)
366        {
367           return false;
368        }
369        return (m_subs == that.m_subs) &amp;&amp; (m_base == that.m_base) &amp;&amp; (m_last_closed_paren == that.m_last_closed_paren);
370     }
371     bool operator!=(const match_results&amp; that)const
372     { return !(*this == that); }
373  #ifdef BOOST_REGEX_MATCH_EXTRA
374     typedef typename sub_match&lt;BidiIterator&gt;::capture_sequence_type capture_sequence_type;
375     const capture_sequence_type&amp; captures(int i)const
376     {
377        if(m_is_singular)
378           raise_logic_error();
379        return (*this)[i].captures();
380     }
381  #endif
382     void  set_second(BidiIterator i)
383     {
384        BOOST_REGEX_ASSERT(m_subs.size() &gt; 2);
385        m_subs[2].second = i;
386        m_subs[2].matched = true;
387        m_subs[0].first = i;
388        m_subs[0].matched = (m_subs[0].first != m_subs[0].second);
389        m_null.first = i;
390        m_null.second = i;
391        m_null.matched = false;
392        m_is_singular = false;
393     }
394     void  set_second(BidiIterator i, size_type pos, bool m = true, bool escape_k = false)
395     {
396        if(pos)
397           m_last_closed_paren = static_cast&lt;int&gt;(pos);
398        pos += 2;
399        BOOST_REGEX_ASSERT(m_subs.size() &gt; pos);
400        m_subs[pos].second = i;
401        m_subs[pos].matched = m;
402        if((pos == 2) &amp;&amp; !escape_k)
403        {
404           m_subs[0].first = i;
405           m_subs[0].matched = (m_subs[0].first != m_subs[0].second);
406           m_null.first = i;
407           m_null.second = i;
408           m_null.matched = false;
409           m_is_singular = false;
410        }
411     }
412     void  set_size(size_type n, BidiIterator i, BidiIterator j)
413     {
414        value_type v(j);
415        size_type len = m_subs.size();
416        if(len &gt; n + 2)
417        {
418           m_subs.erase(m_subs.begin()+n+2, m_subs.end());
419           std::fill(m_subs.begin(), m_subs.end(), v);
420        }
421        else
422        {
423           std::fill(m_subs.begin(), m_subs.end(), v);
424           if(n+2 != len)
425              m_subs.insert(m_subs.end(), n+2-len, v);
426        }
427        m_subs[1].first = i;
428        m_last_closed_paren = 0;
429     }
430     void  set_base(BidiIterator pos)
431     {
432        m_base = pos;
433     }
434     BidiIterator base()const
435     {
436        return m_base;
437     }
438     void  set_first(BidiIterator i)
439     {
440        BOOST_REGEX_ASSERT(m_subs.size() &gt; 2);
441        m_subs[1].second = i;
442        m_subs[1].matched = (m_subs[1].first != i);
443        m_subs[2].first = i;
444        for(size_type n = 3; n &lt; m_subs.size(); ++n)
445        {
446           m_subs[n].first = m_subs[n].second = m_subs[0].second;
447           m_subs[n].matched = false;
448        }
449     }
450     void  set_first(BidiIterator i, size_type pos, bool escape_k = false)
451     {
452        BOOST_REGEX_ASSERT(pos+2 &lt; m_subs.size());
453        if(pos || escape_k)
454        {
455           m_subs[pos+2].first = i;
456           if(escape_k)
457           {
458              m_subs[1].second = i;
459              m_subs[1].matched = (m_subs[1].first != m_subs[1].second);
460           }
461        }
462        else
463           set_first(i);
464     }
465     void  maybe_assign(const match_results&lt;BidiIterator, Allocator&gt;&amp; m);
466     void  set_named_subs(std::shared_ptr&lt;named_sub_type&gt; subs)
467     {
468        m_named_subs = subs;
469     }
470  private:
471     static void raise_logic_error()
472     {
473        std::logic_error e(&quot;Attempt to access an uninitialized boost::match_results&lt;&gt; class.&quot;);
474  #ifndef BOOST_REGEX_STANDALONE
475        boost::throw_exception(e);
476  #else
477        throw e;
478  #endif
479     }
480     vector_type            m_subs;                      
481     BidiIterator   m_base;                              
482     sub_match&lt;BidiIterator&gt; m_null;                     
483     std::shared_ptr&lt;named_sub_type&gt; m_named_subs;     
484     int m_last_closed_paren;                            
485     bool m_is_singular;                                 
486  };
487  template &lt;class BidiIterator, class Allocator&gt;
488  void  match_results&lt;BidiIterator, Allocator&gt;::maybe_assign(const match_results&lt;BidiIterator, Allocator&gt;&amp; m)
489  {
490     if(m_is_singular)
491     {
492        *this = m;
493        return;
494     }
495     const_iterator p1, p2;
496     p1 = begin();
497     p2 = m.begin();
498     BidiIterator l_end = this-&gt;suffix().second;
499     BidiIterator l_base = (p1-&gt;first == l_end) ? this-&gt;prefix().first : (*this)[0].first;
500     difference_type len1 = 0;
501     difference_type len2 = 0;
502     difference_type base1 = 0;
503     difference_type base2 = 0;
504     std::size_t i;
505     for(i = 0; i &lt; size(); ++i, ++p1, ++p2)
506     {
507        if(p1-&gt;first == l_end)
508        {
509           if(p2-&gt;first != l_end)
510           {
511              base1 = 1;
512              base2 = 0;
513              break;
514           }
515           else
516           {
517              if((p1-&gt;matched == false) &amp;&amp; (p2-&gt;matched == true))
518                 break;
519              if((p1-&gt;matched == true) &amp;&amp; (p2-&gt;matched == false))
520                 return;
521              continue;
522           }
523        }
524        else if(p2-&gt;first == l_end)
525        {
526           return;
527        }
528        base1 = std::distance(l_base, p1-&gt;first);
529        base2 = std::distance(l_base, p2-&gt;first);
530        BOOST_REGEX_ASSERT(base1 &gt;= 0);
531        BOOST_REGEX_ASSERT(base2 &gt;= 0);
532        if(base1 &lt; base2) return;
533        if(base2 &lt; base1) break;
534        len1 = std::distance((BidiIterator)p1-&gt;first, (BidiIterator)p1-&gt;second);
535        len2 = std::distance((BidiIterator)p2-&gt;first, (BidiIterator)p2-&gt;second);
536        BOOST_REGEX_ASSERT(len1 &gt;= 0);
537        BOOST_REGEX_ASSERT(len2 &gt;= 0);
538        if((len1 != len2) || ((p1-&gt;matched == false) &amp;&amp; (p2-&gt;matched == true)))
539           break;
540        if((p1-&gt;matched == true) &amp;&amp; (p2-&gt;matched == false))
541           return;
542     }
543     if(i == size())
544        return;
545     if(base2 &lt; base1)
546        *this = m;
547     else if((len2 &gt; len1) || ((p1-&gt;matched == false) &amp;&amp; (p2-&gt;matched == true)) )
548        *this = m;
549  }
550  template &lt;class BidiIterator, class Allocator&gt;
551  void swap(match_results&lt;BidiIterator, Allocator&gt;&amp; a, match_results&lt;BidiIterator, Allocator&gt;&amp; b)
552  {
553     a.swap(b);
554  }
555  template &lt;class charT, class traits, class BidiIterator, class Allocator&gt;
556  std::basic_ostream&lt;charT, traits&gt;&amp;
557     operator &lt;&lt; (std::basic_ostream&lt;charT, traits&gt;&amp; os,
558                  const match_results&lt;BidiIterator, Allocator&gt;&amp; s)
559  {
560     return (os &lt;&lt; s.str());
561  }
562  #ifdef BOOST_REGEX_MSVC
563  #pragma warning(pop)
564  #endif
565  } 
566  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-match_results.hpp</h3>
            <pre><code>1  #ifndef BOOST_REGEX_V5_MATCH_RESULTS_HPP
2  #define BOOST_REGEX_V5_MATCH_RESULTS_HPP
3  namespace boost{
4  #ifdef BOOST_REGEX_MSVC
5  #pragma warning(push)
6  #pragma warning(disable : 4251 4459)
7  #if BOOST_REGEX_MSVC &lt; 1700
8  #     pragma warning(disable : 4231)
9  #endif
10  #  if BOOST_REGEX_MSVC &lt; 1600
11  #     pragma warning(disable : 4660)
12  #  endif
13  #endif
14  namespace BOOST_REGEX_DETAIL_NS{
15  class named_subexpressions;
16  }
17  template &lt;class BidiIterator, class Allocator&gt;
18  class match_results
19  { 
20  private:
21     typedef          std::vector&lt;sub_match&lt;BidiIterator&gt;, Allocator&gt; vector_type;
22  public: 
23     typedef          sub_match&lt;BidiIterator&gt;                         value_type;
24     typedef typename std::allocator_traits&lt;Allocator&gt;::value_type const &amp;    const_reference;
25     typedef          const_reference                                         reference;
26     typedef typename vector_type::const_iterator                             const_iterator;
27     typedef          const_iterator                                          iterator;
28     typedef typename std::iterator_traits&lt;
29                                      BidiIterator&gt;::difference_type          difference_type;
30     typedef typename std::allocator_traits&lt;Allocator&gt;::size_type             size_type;
31     typedef          Allocator                                               allocator_type;
32     typedef typename std::iterator_traits&lt;
33                                      BidiIterator&gt;::value_type               char_type;
34     typedef          std::basic_string&lt;char_type&gt;                            string_type;
35     typedef          BOOST_REGEX_DETAIL_NS::named_subexpressions             named_sub_type;
36     explicit match_results(const Allocator&amp; a = Allocator())
37        : m_subs(a), m_base(), m_null(), m_last_closed_paren(0), m_is_singular(true) {}
38     match_results(const match_results&amp; m)
39        : m_subs(m.m_subs), m_base(), m_null(), m_named_subs(m.m_named_subs), m_last_closed_paren(m.m_last_closed_paren), m_is_singular(m.m_is_singular)
40     {
41        if(!m_is_singular)
42        {
43           m_base = m.m_base;
44           m_null = m.m_null;
45        }
46     }
47     match_results&amp; operator=(const match_results&amp; m)
48     {
49        m_subs = m.m_subs;
50        m_named_subs = m.m_named_subs;
51        m_last_closed_paren = m.m_last_closed_paren;
52        m_is_singular = m.m_is_singular;
53        if(!m_is_singular)
54        {
55           m_base = m.m_base;
56           m_null = m.m_null;
57        }
58        return *this;
59     }
60     ~match_results(){}
61     size_type size() const
62     { return empty() ? 0 : m_subs.size() - 2; }
63     size_type max_size() const
64     { return m_subs.max_size(); }
65     bool empty() const
66     { return m_subs.size() &lt; 2; }
67     difference_type length(int sub = 0) const
68     {
69        if(m_is_singular)
70           raise_logic_error();
71        sub += 2;
72        if((sub &lt; (int)m_subs.size()) &amp;&amp; (sub &gt; 0))
73           return m_subs[sub].length();
74        return 0;
75     }
76     difference_type length(const char_type* sub) const
77     {
78        if(m_is_singular)
79           raise_logic_error();
80        const char_type* sub_end = sub;
81        while(*sub_end) ++sub_end;
82        return length(named_subexpression_index(sub, sub_end));
83     }
84     template &lt;class charT&gt;
85     difference_type length(const charT* sub) const
86     {
87        if(m_is_singular)
88           raise_logic_error();
89        const charT* sub_end = sub;
90        while(*sub_end) ++sub_end;
91        return length(named_subexpression_index(sub, sub_end));
92     }
93     template &lt;class charT, class Traits, class A&gt;
94     difference_type length(const std::basic_string&lt;charT, Traits, A&gt;&amp; sub) const
95     {
96        return length(sub.c_str());
97     }
98     difference_type position(size_type sub = 0) const
99     {
100        if(m_is_singular)
101           raise_logic_error();
102        sub += 2;
103        if(sub &lt; m_subs.size())
104        {
105           const sub_match&lt;BidiIterator&gt;&amp; s = m_subs[sub];
106           if(s.matched || (sub == 2))
107           {
108              return std::distance((BidiIterator)(m_base), (BidiIterator)(s.first));
109           }
110        }
111        return ~static_cast&lt;difference_type&gt;(0);
112     }
113     difference_type position(const char_type* sub) const
114     {
115        const char_type* sub_end = sub;
116        while(*sub_end) ++sub_end;
117        return position(named_subexpression_index(sub, sub_end));
118     }
119     template &lt;class charT&gt;
120     difference_type position(const charT* sub) const
121     {
122        const charT* sub_end = sub;
123        while(*sub_end) ++sub_end;
124        return position(named_subexpression_index(sub, sub_end));
125     }
126     template &lt;class charT, class Traits, class A&gt;
127     difference_type position(const std::basic_string&lt;charT, Traits, A&gt;&amp; sub) const
128     {
129        return position(sub.c_str());
130     }
131     string_type str(int sub = 0) const
132     {
133        if(m_is_singular)
134           raise_logic_error();
135        sub += 2;
136        string_type result;
137        if(sub &lt; (int)m_subs.size() &amp;&amp; (sub &gt; 0))
138        {
139           const sub_match&lt;BidiIterator&gt;&amp; s = m_subs[sub];
140           if(s.matched)
141           {
142              result = s.str();
143           }
144        }
145        return result;
146     }
147     string_type str(const char_type* sub) const
148     {
149        return (*this)[sub].str();
150     }
151     template &lt;class Traits, class A&gt;
152     string_type str(const std::basic_string&lt;char_type, Traits, A&gt;&amp; sub) const
153     {
154        return (*this)[sub].str();
155     }
156     template &lt;class charT&gt;
157     string_type str(const charT* sub) const
158     {
159        return (*this)[sub].str();
160     }
161     template &lt;class charT, class Traits, class A&gt;
162     string_type str(const std::basic_string&lt;charT, Traits, A&gt;&amp; sub) const
163     {
164        return (*this)[sub].str();
165     }
166     const_reference operator[](int sub) const
167     {
168        if(m_is_singular &amp;&amp; m_subs.empty())
169           raise_logic_error();
170        sub += 2;
171        if(sub &lt; (int)m_subs.size() &amp;&amp; (sub &gt;= 0))
172        {
173           return m_subs[sub];
174        }
175        return m_null;
176     }
177     const_reference named_subexpression(const char_type* i, const char_type* j) const
178     {
179        if(m_is_singular)
180           raise_logic_error();
181        BOOST_REGEX_DETAIL_NS::named_subexpressions::range_type r = m_named_subs-&gt;equal_range(i, j);
182        while((r.first != r.second) &amp;&amp; ((*this)[r.first-&gt;index].matched == false))
183           ++r.first;
184        return r.first != r.second ? (*this)[r.first-&gt;index] : m_null;
185     }
186     template &lt;class charT&gt;
187     const_reference named_subexpression(const charT* i, const charT* j) const
188     {
189        static_assert(sizeof(charT) &lt;= sizeof(char_type), &quot;Failed internal logic&quot;);
190        if(i == j)
191           return m_null;
192        std::vector&lt;char_type&gt; s;
193        while(i != j)
194           s.insert(s.end(), *i++);
195        return named_subexpression(&amp;*s.begin(), &amp;*s.begin() + s.size());
196     }
197     int named_subexpression_index(const char_type* i, const char_type* j) const
198     {
199        if(m_is_singular)
200           raise_logic_error();
201        BOOST_REGEX_DETAIL_NS::named_subexpressions::range_type s, r;
202        s = r = m_named_subs-&gt;equal_range(i, j);
<span onclick='openModal()' class='match'>203        while((r.first != r.second) &amp;&amp; ((*this)[r.first-&gt;index].matched == false))
204           ++r.first;
205        if(r.first == r.second)
</span>206           r = s;
207        return r.first != r.second ? r.first-&gt;index : -20;
208     }
209     template &lt;class charT&gt;
210     int named_subexpression_index(const charT* i, const charT* j) const
211     {
212        static_assert(sizeof(charT) &lt;= sizeof(char_type), &quot;Failed internal logic&quot;);
213        if(i == j)
214           return -20;
215        std::vector&lt;char_type&gt; s;
216        while(i != j)
217           s.insert(s.end(), *i++);
218        return named_subexpression_index(&amp;*s.begin(), &amp;*s.begin() + s.size());
219     }
220     template &lt;class Traits, class A&gt;
221     const_reference operator[](const std::basic_string&lt;char_type, Traits, A&gt;&amp; s) const
222     {
223        return named_subexpression(s.c_str(), s.c_str() + s.size());
224     }
225     const_reference operator[](const char_type* p) const
226     {
227        const char_type* e = p;
228        while(*e) ++e;
229        return named_subexpression(p, e);
230     }
231     template &lt;class charT&gt;
232     const_reference operator[](const charT* p) const
233     {
234        static_assert(sizeof(charT) &lt;= sizeof(char_type), &quot;Failed internal logic&quot;);
235        if(*p == 0)
236           return m_null;
237        std::vector&lt;char_type&gt; s;
238        while(*p)
239           s.insert(s.end(), *p++);
240        return named_subexpression(&amp;*s.begin(), &amp;*s.begin() + s.size());
241     }
242     template &lt;class charT, class Traits, class A&gt;
243     const_reference operator[](const std::basic_string&lt;charT, Traits, A&gt;&amp; ns) const
244     {
245        static_assert(sizeof(charT) &lt;= sizeof(char_type), &quot;Failed internal logic&quot;);
246        if(ns.empty())
247           return m_null;
248        std::vector&lt;char_type&gt; s;
249        for(unsigned i = 0; i &lt; ns.size(); ++i)
250           s.insert(s.end(), ns[i]);
251        return named_subexpression(&amp;*s.begin(), &amp;*s.begin() + s.size());
252     }
253     const_reference prefix() const
254     {
255        if(m_is_singular)
256           raise_logic_error();
257        return (*this)[-1];
258     }
259     const_reference suffix() const
260     {
261        if(m_is_singular)
262           raise_logic_error();
263        return (*this)[-2];
264     }
265     const_iterator begin() const
266     {
267        return (m_subs.size() &gt; 2) ? (m_subs.begin() + 2) : m_subs.end();
268     }
269     const_iterator end() const
270     {
271        return m_subs.end();
272     }
273     template &lt;class OutputIterator, class Functor&gt;
274     OutputIterator format(OutputIterator out,
275                           Functor fmt,
276                           match_flag_type flags = format_default) const
277     {
278        if(m_is_singular)
279           raise_logic_error();
280        typedef typename BOOST_REGEX_DETAIL_NS::compute_functor_type&lt;Functor, match_results&lt;BidiIterator, Allocator&gt;, OutputIterator&gt;::type F;
281        F func(fmt);
282        return func(*this, out, flags);
283     }
284     template &lt;class Functor&gt;
285     string_type format(Functor fmt, match_flag_type flags = format_default) const
286     {
287        if(m_is_singular)
288           raise_logic_error();
289        std::basic_string&lt;char_type&gt; result;
290        BOOST_REGEX_DETAIL_NS::string_out_iterator&lt;std::basic_string&lt;char_type&gt; &gt; i(result);
291        typedef typename BOOST_REGEX_DETAIL_NS::compute_functor_type&lt;Functor, match_results&lt;BidiIterator, Allocator&gt;, BOOST_REGEX_DETAIL_NS::string_out_iterator&lt;std::basic_string&lt;char_type&gt; &gt; &gt;::type F;
292        F func(fmt);
293        func(*this, i, flags);
294        return result;
295     }
296     template &lt;class OutputIterator, class Functor, class RegexT&gt;
297     OutputIterator format(OutputIterator out,
298                           Functor fmt,
299                           match_flag_type flags,
300                           const RegexT&amp; re) const
301     {
302        if(m_is_singular)
303           raise_logic_error();
304        typedef ::boost::regex_traits_wrapper&lt;typename RegexT::traits_type&gt; traits_type;
305        typedef typename BOOST_REGEX_DETAIL_NS::compute_functor_type&lt;Functor, match_results&lt;BidiIterator, Allocator&gt;, OutputIterator, traits_type&gt;::type F;
306        F func(fmt);
307        return func(*this, out, flags, re.get_traits());
308     }
309     template &lt;class RegexT, class Functor&gt;
310     string_type format(Functor fmt,
311                        match_flag_type flags,
312                        const RegexT&amp; re) const
313     {
314        if(m_is_singular)
315           raise_logic_error();
316        typedef ::boost::regex_traits_wrapper&lt;typename RegexT::traits_type&gt; traits_type;
317        std::basic_string&lt;char_type&gt; result;
318        BOOST_REGEX_DETAIL_NS::string_out_iterator&lt;std::basic_string&lt;char_type&gt; &gt; i(result);
319        typedef typename BOOST_REGEX_DETAIL_NS::compute_functor_type&lt;Functor, match_results&lt;BidiIterator, Allocator&gt;, BOOST_REGEX_DETAIL_NS::string_out_iterator&lt;std::basic_string&lt;char_type&gt; &gt;, traits_type &gt;::type F;
320        F func(fmt);
321        func(*this, i, flags, re.get_traits());
322        return result;
323     }
324     const_reference get_last_closed_paren()const
325     {
326        if(m_is_singular)
327           raise_logic_error();
328        return m_last_closed_paren == 0 ? m_null : (*this)[m_last_closed_paren];
329     }
330     allocator_type get_allocator() const
331     {
332        return m_subs.get_allocator();
333     }
334     void swap(match_results&amp; that)
335     {
336        std::swap(m_subs, that.m_subs);
337        std::swap(m_named_subs, that.m_named_subs);
338        std::swap(m_last_closed_paren, that.m_last_closed_paren);
339        if(m_is_singular)
340        {
341           if(!that.m_is_singular)
342           {
343              m_base = that.m_base;
344              m_null = that.m_null;
345           }
346        }
347        else if(that.m_is_singular)
348        {
349           that.m_base = m_base;
350           that.m_null = m_null;
351        }
352        else
353        {
354           std::swap(m_base, that.m_base);
355           std::swap(m_null, that.m_null);
356        }
357        std::swap(m_is_singular, that.m_is_singular);
358     }
359     bool operator==(const match_results&amp; that)const
360     {
361        if(m_is_singular)
362        {
363           return that.m_is_singular;
364        }
365        else if(that.m_is_singular)
366        {
367           return false;
368        }
369        return (m_subs == that.m_subs) &amp;&amp; (m_base == that.m_base) &amp;&amp; (m_last_closed_paren == that.m_last_closed_paren);
370     }
371     bool operator!=(const match_results&amp; that)const
372     { return !(*this == that); }
373  #ifdef BOOST_REGEX_MATCH_EXTRA
374     typedef typename sub_match&lt;BidiIterator&gt;::capture_sequence_type capture_sequence_type;
375     const capture_sequence_type&amp; captures(int i)const
376     {
377        if(m_is_singular)
378           raise_logic_error();
379        return (*this)[i].captures();
380     }
381  #endif
382     void  set_second(BidiIterator i)
383     {
384        BOOST_REGEX_ASSERT(m_subs.size() &gt; 2);
385        m_subs[2].second = i;
386        m_subs[2].matched = true;
387        m_subs[0].first = i;
388        m_subs[0].matched = (m_subs[0].first != m_subs[0].second);
389        m_null.first = i;
390        m_null.second = i;
391        m_null.matched = false;
392        m_is_singular = false;
393     }
394     void  set_second(BidiIterator i, size_type pos, bool m = true, bool escape_k = false)
395     {
396        if(pos)
397           m_last_closed_paren = static_cast&lt;int&gt;(pos);
398        pos += 2;
399        BOOST_REGEX_ASSERT(m_subs.size() &gt; pos);
400        m_subs[pos].second = i;
401        m_subs[pos].matched = m;
402        if((pos == 2) &amp;&amp; !escape_k)
403        {
404           m_subs[0].first = i;
405           m_subs[0].matched = (m_subs[0].first != m_subs[0].second);
406           m_null.first = i;
407           m_null.second = i;
408           m_null.matched = false;
409           m_is_singular = false;
410        }
411     }
412     void  set_size(size_type n, BidiIterator i, BidiIterator j)
413     {
414        value_type v(j);
415        size_type len = m_subs.size();
416        if(len &gt; n + 2)
417        {
418           m_subs.erase(m_subs.begin()+n+2, m_subs.end());
419           std::fill(m_subs.begin(), m_subs.end(), v);
420        }
421        else
422        {
423           std::fill(m_subs.begin(), m_subs.end(), v);
424           if(n+2 != len)
425              m_subs.insert(m_subs.end(), n+2-len, v);
426        }
427        m_subs[1].first = i;
428        m_last_closed_paren = 0;
429     }
430     void  set_base(BidiIterator pos)
431     {
432        m_base = pos;
433     }
434     BidiIterator base()const
435     {
436        return m_base;
437     }
438     void  set_first(BidiIterator i)
439     {
440        BOOST_REGEX_ASSERT(m_subs.size() &gt; 2);
441        m_subs[1].second = i;
442        m_subs[1].matched = (m_subs[1].first != i);
443        m_subs[2].first = i;
444        for(size_type n = 3; n &lt; m_subs.size(); ++n)
445        {
446           m_subs[n].first = m_subs[n].second = m_subs[0].second;
447           m_subs[n].matched = false;
448        }
449     }
450     void  set_first(BidiIterator i, size_type pos, bool escape_k = false)
451     {
452        BOOST_REGEX_ASSERT(pos+2 &lt; m_subs.size());
453        if(pos || escape_k)
454        {
455           m_subs[pos+2].first = i;
456           if(escape_k)
457           {
458              m_subs[1].second = i;
459              m_subs[1].matched = (m_subs[1].first != m_subs[1].second);
460           }
461        }
462        else
463           set_first(i);
464     }
465     void  maybe_assign(const match_results&lt;BidiIterator, Allocator&gt;&amp; m);
466     void  set_named_subs(std::shared_ptr&lt;named_sub_type&gt; subs)
467     {
468        m_named_subs = subs;
469     }
470  private:
471     static void raise_logic_error()
472     {
473        std::logic_error e(&quot;Attempt to access an uninitialized boost::match_results&lt;&gt; class.&quot;);
474  #ifndef BOOST_REGEX_STANDALONE
475        boost::throw_exception(e);
476  #else
477        throw e;
478  #endif
479     }
480     vector_type            m_subs;                      
481     BidiIterator   m_base;                              
482     sub_match&lt;BidiIterator&gt; m_null;                     
483     std::shared_ptr&lt;named_sub_type&gt; m_named_subs;     
484     int m_last_closed_paren;                            
485     bool m_is_singular;                                 
486  };
487  template &lt;class BidiIterator, class Allocator&gt;
488  void  match_results&lt;BidiIterator, Allocator&gt;::maybe_assign(const match_results&lt;BidiIterator, Allocator&gt;&amp; m)
489  {
490     if(m_is_singular)
491     {
492        *this = m;
493        return;
494     }
495     const_iterator p1, p2;
496     p1 = begin();
497     p2 = m.begin();
498     BidiIterator l_end = this-&gt;suffix().second;
499     BidiIterator l_base = (p1-&gt;first == l_end) ? this-&gt;prefix().first : (*this)[0].first;
500     difference_type len1 = 0;
501     difference_type len2 = 0;
502     difference_type base1 = 0;
503     difference_type base2 = 0;
504     std::size_t i;
505     for(i = 0; i &lt; size(); ++i, ++p1, ++p2)
506     {
507        if(p1-&gt;first == l_end)
508        {
509           if(p2-&gt;first != l_end)
510           {
511              base1 = 1;
512              base2 = 0;
513              break;
514           }
515           else
516           {
517              if((p1-&gt;matched == false) &amp;&amp; (p2-&gt;matched == true))
518                 break;
519              if((p1-&gt;matched == true) &amp;&amp; (p2-&gt;matched == false))
520                 return;
521              continue;
522           }
523        }
524        else if(p2-&gt;first == l_end)
525        {
526           return;
527        }
528        base1 = std::distance(l_base, p1-&gt;first);
529        base2 = std::distance(l_base, p2-&gt;first);
530        BOOST_REGEX_ASSERT(base1 &gt;= 0);
531        BOOST_REGEX_ASSERT(base2 &gt;= 0);
532        if(base1 &lt; base2) return;
533        if(base2 &lt; base1) break;
534        len1 = std::distance((BidiIterator)p1-&gt;first, (BidiIterator)p1-&gt;second);
535        len2 = std::distance((BidiIterator)p2-&gt;first, (BidiIterator)p2-&gt;second);
536        BOOST_REGEX_ASSERT(len1 &gt;= 0);
537        BOOST_REGEX_ASSERT(len2 &gt;= 0);
538        if((len1 != len2) || ((p1-&gt;matched == false) &amp;&amp; (p2-&gt;matched == true)))
539           break;
540        if((p1-&gt;matched == true) &amp;&amp; (p2-&gt;matched == false))
541           return;
542     }
543     if(i == size())
544        return;
545     if(base2 &lt; base1)
546        *this = m;
547     else if((len2 &gt; len1) || ((p1-&gt;matched == false) &amp;&amp; (p2-&gt;matched == true)) )
548        *this = m;
549  }
550  template &lt;class BidiIterator, class Allocator&gt;
551  void swap(match_results&lt;BidiIterator, Allocator&gt;&amp; a, match_results&lt;BidiIterator, Allocator&gt;&amp; b)
552  {
553     a.swap(b);
554  }
555  template &lt;class charT, class traits, class BidiIterator, class Allocator&gt;
556  std::basic_ostream&lt;charT, traits&gt;&amp;
557     operator &lt;&lt; (std::basic_ostream&lt;charT, traits&gt;&amp; os,
558                  const match_results&lt;BidiIterator, Allocator&gt;&amp; s)
559  {
560     return (os &lt;&lt; s.str());
561  }
562  #ifdef BOOST_REGEX_MSVC
563  #pragma warning(pop)
564  #endif
565  } 
566  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-match_results.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-match_results.hpp</div>
                </div>
                <div class="column column_space"><pre><code>182        while((r.first != r.second) &amp;&amp; ((*this)[r.first-&gt;index].matched == false))
183           ++r.first;
184        return r.first != r.second ? (*this)[r.first-&gt;index] : m_null;
</pre></code></div>
                <div class="column column_space"><pre><code>203        while((r.first != r.second) &amp;&amp; ((*this)[r.first-&gt;index].matched == false))
204           ++r.first;
205        if(r.first == r.second)
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    