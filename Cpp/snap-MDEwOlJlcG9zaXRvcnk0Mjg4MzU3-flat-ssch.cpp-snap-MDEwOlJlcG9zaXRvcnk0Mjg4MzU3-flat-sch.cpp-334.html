
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 25, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-ssch.cpp</h3>
            <pre><code>1  #include &quot;sch.h&quot;
2  TSchTask::TSchTask(const int&amp; _TaskId, const TStrV&amp; _DimObjNmV,
3   const TSecTm&amp; _StartTm, const TSecTm&amp; _EndTm):
4    TaskId(_TaskId), DimObjNmV(_DimObjNmV), StartTm(_StartTm), EndTm(_EndTm){
5    IAssert(StartTm&lt;EndTm);
6  }
7  TStr TSchTask::GetStr() const {
8    TChA ChA;
9    for (int DimN=0; DimN&lt;DimObjNmV.Len(); DimN++){
10      if (DimN&gt;0){ChA+=&#x27; &#x27;;}
11      ChA+=DimObjNmV[DimN];
12    }
13    return ChA;
14  }
15  bool TSchTask::IsCons(const PSchTask&amp; Task1, const PSchTask&amp; Task2){
16    return
17     (Task1-&gt;GetEndTm()&lt;=Task2-&gt;GetStartTm())||
18     (Task2-&gt;GetEndTm()&lt;=Task1-&gt;GetStartTm());
19  }
20  PSchTask TSchTask::LoadTxt(TILx&amp; Lx){
21    PSchTask SchTask=PSchTask(new TSchTask());
22    Lx.GetVar(&quot;SchTask&quot;, true, true);
23    SchTask-&gt;TaskId=Lx.GetVarInt(&quot;TaskId&quot;);
24    Lx.GetVarStrV(&quot;DimObjNmV&quot;, SchTask-&gt;DimObjNmV);
25    SchTask-&gt;StartTm=Lx.GetVarSecTm(&quot;StartTm&quot;);
26    SchTask-&gt;EndTm=Lx.GetVarSecTm(&quot;EndTm&quot;);
27    Lx.GetVarEnd(true, true);
28    return SchTask;
29  }
30  void TSchTask::SaveTxt(TOLx&amp; Lx) const {
31    Lx.PutVar(&quot;SchTask&quot;, true, true);
32    Lx.PutVarInt(&quot;TaskId&quot;, TaskId);
33    Lx.PutVarStrV(&quot;DimObjNmV&quot;, DimObjNmV);
34    Lx.PutVarSecTm(&quot;StartTm&quot;, StartTm);
35    Lx.PutVarSecTm(&quot;EndTm&quot;, EndTm);
36    Lx.PutVarEnd(true, true);
37  }
38  void TSchObj::AddTask(const PSchTask&amp; Task){
39    IAssert(IsTaskOk(Task));
40    TTmTaskKd TmTaskKd(Task-&gt;GetStartTm(), Task);
41    int TaskN=TaskV.AddSorted(TmTaskKd);
42    if (0&lt;TaskN){
43      PSchTask PrevTask=TaskV[TaskN-1].Dat;
44      IAssert(TSchTask::IsCons(PrevTask, Task));
45    }
46    if (TaskN+1&lt;TaskV.Len()){
47      PSchTask NextTask=TaskV[TaskN+1].Dat;
48      IAssert(TSchTask::IsCons(Task, NextTask));
49    }
50  }
51  void TSchObj::DelTask(const PSchTask&amp; Task){
52    TTmTaskKd TmTaskKd(Task-&gt;GetStartTm(), Task);
53    int TaskN=TaskV.SearchBin(TmTaskKd);
54    IAssert(TaskN!=-1);
55    IAssert(Task-&gt;GetTaskId()==TaskV[TaskN].Dat-&gt;GetTaskId());
56    TaskV.Del(TaskN);
57  }
58  bool TSchObj::IsTaskAtTm(const TSecTm&amp; Tm, PSchTask&amp; Task) const {
59    TTmTaskKd TmTaskKd(Tm);
60    int InsTaskN; int TaskN=TaskV.SearchBin(TmTaskKd, InsTaskN);
61    if (TaskN==-1){
62      if (InsTaskN==0){
63        Task=NULL; return false;
64      } else
65      if (TaskV[InsTaskN-1].Dat-&gt;IsTmIn(Tm)){
66        Task=TaskV[InsTaskN-1].Dat; return true;
67      } else {
68        Task=NULL; return false;
69      }
70    } else {
71      Task=TaskV[TaskN].Dat; return true;
72    }
73  }
74  bool TSchObj::IsTaskInTm(
75   const TSecTm&amp; MnTm, const TSecTm&amp; MxTm, PSchTask&amp; Task) const {
76    TTmTaskKd StartTmTaskKd(MnTm);
77    TTmTaskKd EndTmTaskKd(MxTm);
78    int StartInsTaskN; int EndInsTaskN;
79    int StartTaskN=TaskV.SearchBin(StartTmTaskKd, StartInsTaskN);
80    int EndTaskN=TaskV.SearchBin(EndTmTaskKd, EndInsTaskN);
81    if ((StartTaskN==-1)&amp;&amp;(EndTaskN==-1)){
82      if (StartInsTaskN==EndInsTaskN){
83        if (StartInsTaskN==0){
84          Task=NULL; return false;
85        } else
86        if (TaskV[StartInsTaskN-1].Dat-&gt;IsTmIn(MnTm)){
87          Task=TaskV[StartInsTaskN-1].Dat; return true;
88        } else {
<span onclick='openModal()' class='match'>89          Task=NULL; return false;
90        }
91      } else {
92        Task=TaskV[StartInsTaskN].Dat; return true;
93      }
94    } else {
</span>95      if (StartTaskN!=-1){IsTaskAtTm(MnTm, Task);}
96      else if (EndTaskN!=-1){IsTaskAtTm(MxTm, Task);}
97      else {Fail;}
98      IAssert(!Task.Empty());
99      return true;
100    }
101  }
102  PSchObj TSchObj::LoadTxt(TILx&amp; Lx){
103    PSchObj SchObj=PSchObj(new TSchObj());
104    Lx.GetVar(&quot;SchObj&quot;, true, true);
105    SchObj-&gt;Nm=Lx.GetVarStr(&quot;Nm&quot;);
106    Lx.GetVar(&quot;TaskV&quot;, true, true);
107    while (!Lx.PeekVarEnd(true, true)){
108      PSchTask Task=TSchTask::LoadTxt(Lx);
109      SchObj-&gt;TaskV.Add(TTmTaskKd(Task-&gt;GetStartTm(), Task));
110    }
111    Lx.GetVarEnd(true, true);
112    Lx.GetVarEnd(true, true);
113    return SchObj;
114  }
115  void TSchObj::SaveTxt(TOLx&amp; Lx) const {
116    Lx.PutVar(&quot;SchObj&quot;, true, true);
117    Lx.PutVarStr(&quot;Nm&quot;, Nm);
118    Lx.PutVar(&quot;TaskV&quot;, true, true);
119    for (int TaskN=0; TaskN&lt;TaskV.Len(); TaskN++){
120      TaskV[TaskN].Dat-&gt;SaveTxt(Lx);}
121    Lx.PutVarEnd(true, true);
122    Lx.PutVarEnd(true, true);
123  }
124  int TSchDim::AddObj(const TStr&amp; Nm){
125    IAssert(!NmToObjH.IsKey(Nm));
126    PSchObj Obj=PSchObj(new TSchObj(Nm));
127    NmToObjH.AddDat(Nm, Obj);
128    return NmToObjH.GetKeyId(Nm);
129  }
130  TStrV TSchDim::GetObjNmV() const {
131    TStrV NmV(NmToObjH.Len(), 0);
132    int NmToObjP=NmToObjH.FFirstKeyId();
133    while (NmToObjH.FNextKeyId(NmToObjP)){
134      NmV.Add(NmToObjH[NmToObjP]-&gt;GetNm());}
135    return NmV;
136  }
137  void TSchDim::AddTask(const PSchTask&amp; Task){
138    PSchObj Obj=GetObj(Task-&gt;GetDimObjNm(DimN));
139    Obj-&gt;AddTask(Task);
140  }
141  void TSchDim::DelTask(const PSchTask&amp; Task){
142    PSchObj Obj=GetObj(Task-&gt;GetDimObjNm(DimN));
143    Obj-&gt;DelTask(Task);
144  }
145  bool TSchDim::IsTaskOk(const PSchTask&amp; Task, PSchTask&amp; IcTask) const {
146    PSchObj Obj=GetObj(Task-&gt;GetDimObjNm(DimN));
147    return Obj-&gt;IsTaskOk(Task, IcTask);
148  }
149  bool TSchDim::IsTaskInTm(const TStr&amp; ObjNm,
150   const TSecTm&amp; MnTm, const TSecTm&amp; MxTm, PSchTask&amp; Task) const {
151    PSchObj Obj=GetObj(ObjNm);
152    return Obj-&gt;IsTaskInTm(MnTm, MxTm, Task);
153  }
154  PSchDim TSchDim::LoadTxt(TILx&amp; Lx){
155    PSchDim SchDim=PSchDim(new TSchDim());
156    Lx.GetVar(&quot;SchDim&quot;, true, true);
157    SchDim-&gt;DimN=Lx.GetVarInt(&quot;DimN&quot;);
158    SchDim-&gt;Nm=Lx.GetVarStr(&quot;Nm&quot;);
159    Lx.GetVar(&quot;NmToObjH&quot;, true, true);
160    int Ports=Lx.GetVarInt(&quot;Ports&quot;);
161    SchDim-&gt;NmToObjH=TNmToObjH(Ports);
162    while (!Lx.PeekVarEnd(true, true)){
163      PSchObj Obj=TSchObj::LoadTxt(Lx);
164      SchDim-&gt;NmToObjH.AddDat(Obj-&gt;GetNm(), Obj);
165    }
166    Lx.GetVarEnd(true, true);
167    Lx.GetVarEnd(true, true);
168    return SchDim;
169  }
170  void TSchDim::SaveTxt(TOLx&amp; Lx) const {
171    Lx.PutVar(&quot;SchDim&quot;, true, true);
172    Lx.PutVarInt(&quot;DimN&quot;, DimN);
173    Lx.PutVarStr(&quot;Nm&quot;, Nm);
174    Lx.PutVar(&quot;NmToObjH&quot;, true, true);
175    int NmToObjP=NmToObjH.FFirstKeyId();
176    Lx.PutVarInt(&quot;Ports&quot;, NmToObjH.GetPorts());
177    while (NmToObjH.FNextKeyId(NmToObjP)){
178      NmToObjH[NmToObjP]-&gt;SaveTxt(Lx);}
179    Lx.PutVarEnd(true, true);
180    Lx.PutVarEnd(true, true);
181  }
182  TSch::TSch(const TStr&amp; _Nm, const int&amp; Dims,
183   const int&amp; ExpObjs, const int&amp; ExpTasks):
184    Nm(_Nm), DimV(Dims), LastTaskId(0), IdToTaskH(ExpTasks){
185    for (int DimN=0; DimN&lt;Dims; DimN++){
186      DimV[DimN]=PSchDim(new TSchDim(DimN, ExpObjs));}
187  }
188  TStrV TSch::GetDimNmV() const {
189    TStrV DimNmV(GetDims(), 0);
190    for (int DimN=0; DimN&lt;GetDims(); DimN++){
191      DimNmV.Add(GetDimNm(DimN));}
192    return DimNmV;
193  }
194  int TSch::GetDimN(const TStr&amp; DimNm) const {
195    for (int DimN=0; DimN&lt;GetDims(); DimN++){
196      if (GetDimNm(DimN)==DimNm){return DimN;}}
197    return -1;
198  }
199  int TSch::AddTask(
200   const TStrV&amp; DimObjNmV, const TSecTm&amp; StartTm, const TSecTm&amp; EndTm){
201    IAssert(DimObjNmV.Len()==GetDims());
202    int TaskId=GetNewTaskId();
203    PSchTask Task=PSchTask(new TSchTask(TaskId, DimObjNmV, StartTm, EndTm));
204    IdToTaskH.AddDat(TaskId, Task);
205    for (int DimN=0; DimN&lt;GetDims(); DimN++){
206      DimV[DimN]-&gt;AddTask(Task);}
207    return TaskId;
208  }
209  int TSch::AddTask(
210   const TStr&amp; DimObjNm1, const TStr&amp; DimObjNm2, const TStr&amp; DimObjNm3,
211   const TSecTm&amp; StartTm, const TSecTm&amp; EndTm){
212    TStrV DimObjNmV(3, 0);
213    DimObjNmV.Add(DimObjNm1);
214    DimObjNmV.Add(DimObjNm2);
215    DimObjNmV.Add(DimObjNm3);
216    return AddTask(DimObjNmV, StartTm, EndTm);
217  }
218  void TSch::DelTask(const int&amp; TaskId){
219    PSchTask Task=IdToTaskH.GetDat(TaskId);
220    for (int DimN=0; DimN&lt;GetDims(); DimN++){
221      DimV[DimN]-&gt;DelTask(Task);}
222  }
223  bool TSch::IsTask(const int&amp; TaskId, PSchTask&amp; Task) const {
224    int IdToTaskP;
225    if (IdToTaskH.IsKey(TaskId, IdToTaskP)){
226      Task=IdToTaskH[IdToTaskP]; return true;}
227    else {return false;}
228  }
229  bool TSch::IsTaskOk(const PSchTask&amp; Task, TSchTaskV&amp; DimIcTaskV) const {
230    DimIcTaskV.Gen(GetDims(), GetDims());
231    bool Ok=true;
232    for (int DimN=0; DimN&lt;GetDims(); DimN++){
233      PSchTask IcTask;
234      if (!DimV[DimN]-&gt;IsTaskOk(Task, IcTask)){
235        DimIcTaskV[DimN]=IcTask; Ok=false;
236      }
237    }
238    return Ok;
239  }
240  PSch TSch::LoadTxt(TILx&amp; Lx){
241    PSch Sch=PSch(new TSch());
242    Lx.GetVar(&quot;Sch&quot;, true, true);
243    Sch-&gt;Nm=Lx.GetVarStr(&quot;Nm&quot;);
244    Lx.GetVar(&quot;DimV&quot;, true, true);
245    while (!Lx.PeekVarEnd(true, true)){
246      Sch-&gt;DimV.Add(TSchDim::LoadTxt(Lx));}
247    Lx.GetVarEnd(true, true);
248    Sch-&gt;LastTaskId=Lx.GetVarInt(&quot;LastTaskId&quot;);
249    Lx.GetVar(&quot;IdToTaskH&quot;, true, true);
250    int Ports=Lx.GetVarInt(&quot;Ports&quot;);
251    Sch-&gt;IdToTaskH=TIdToTaskH(Ports);
252    while (!Lx.PeekVarEnd(true, true)){
253      PSchTask Task=TSchTask::LoadTxt(Lx);
254      Sch-&gt;IdToTaskH.AddDat(Task-&gt;GetTaskId(), Task);
255    }
256    Lx.GetVarEnd(true, true);
257    Lx.GetVarEnd(true, true);
258    return Sch;
259  }
260  PSch TSch::LoadTxt(const TStr&amp; FNm){
261    PSIn SIn=PSIn(new TFIn(FNm));
262    TILx Lx(SIn, TFSet()|iloRetEoln|iloSigNum|iloCsSens);
263    return LoadTxt(Lx);
264  }
265  void TSch::SaveTxt(TOLx&amp; Lx) const {
266    Lx.PutVar(&quot;Sch&quot;, true, true);
267    Lx.PutVarStr(&quot;Nm&quot;, Nm);
268    Lx.PutVar(&quot;DimV&quot;, true, true);
269    for (int DimN=0; DimN&lt;DimV.Len(); DimN++){
270      DimV[DimN]-&gt;SaveTxt(Lx);}
271    Lx.PutVarEnd(true, true);
272    Lx.PutVarInt(&quot;LastTaskId&quot;, LastTaskId);
273    Lx.PutVar(&quot;IdToTaskH&quot;, true, true);
274    Lx.PutVarInt(&quot;Ports&quot;, IdToTaskH.GetPorts());
275    int IdToTaskP=IdToTaskH.FFirstKeyId();
276    while (IdToTaskH.FNextKeyId(IdToTaskP)){
277      IdToTaskH[IdToTaskP]-&gt;SaveTxt(Lx);}
278    Lx.PutVarEnd(true, true);
279    Lx.PutVarEnd(true, true);
280  }
281  void TSch::SaveTxt(const TStr&amp; FNm) const {
282    PSOut SOut=PSOut(new TFOut(FNm));
283    TOLx Lx(SOut, TFSet()|oloFrcEoln|oloSigNum|oloCsSens|oloVarIndent);
284    SaveTxt(Lx);
285  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-sch.cpp</h3>
            <pre><code>1  #include &quot;sch.h&quot;
2  TSchTask::TSchTask(
3   const int&amp; _TaskId, const TVec&lt;TStrV&gt;&amp; _DimObjVV,
4   const TSecTm&amp; _StartTm, const TSecTm&amp; _EndTm, const bool&amp; _Forced):
5    TaskId(_TaskId), DimObjVV(_DimObjVV),
6    StartTm(_StartTm), EndTm(_EndTm), Forced(_Forced){
7    IAssert(StartTm&lt;EndTm);
8  }
9  TSchTask::TSchTask(
10   const int&amp; _TaskId, const TStrV&amp; DimObjV,
11   const TSecTm&amp; _StartTm, const TSecTm&amp; _EndTm, const bool&amp; _Forced):
12    TaskId(_TaskId), DimObjVV(),
13    StartTm(_StartTm), EndTm(_EndTm), Forced(_Forced){
14    IAssert(StartTm&lt;EndTm);
15    for (int DimObjN=0; DimObjN&lt;DimObjV.Len(); DimObjN++){
16      DimObjVV.Add(); DimObjVV.Last().Add(DimObjV[DimObjN]);
17    }
18  }
19  TStr TSchTask::GetAllDimObjStr(const int&amp; DimN) const {
20    TChA ChA;
21    for (int ObjN=0; ObjN&lt;GetDimObjs(DimN); ObjN++){
22      if (ObjN&gt;0){ChA+=&quot;, &quot;;}
23      ChA+=GetDimObj(DimN, ObjN);
24    }
25    return ChA;
26  }
27  TStr TSchTask::GetStr() const {
28    TChA ChA;
29    if (Forced){ChA+=&quot;F:&quot;;}
30    for (int DimN=0; DimN&lt;GetDims(); DimN++){
31      if (DimN&gt;0){ChA+=&#x27; &#x27;;}
32      ChA+=&#x27;[&#x27;;
33      for (int ObjN=0; ObjN&lt;GetDimObjs(DimN); ObjN++){
34        if (ObjN&gt;0){ChA+=&#x27; &#x27;;}
35        ChA+=DimObjVV[DimN][ObjN];
36      }
37      ChA+=&#x27;]&#x27;;
38    }
39    return ChA;
40  }
41  bool TSchTask::IsCons(const PSchTask&amp; Task1, const PSchTask&amp; Task2){
42    IAssert((!Task1-&gt;IsForced())&amp;&amp;(!Task2-&gt;IsForced()));
43    return
44     (Task1-&gt;GetEndTm()&lt;=Task2-&gt;GetStartTm())||
45     (Task2-&gt;GetEndTm()&lt;=Task1-&gt;GetStartTm());
46  }
47  PSchTask TSchTask::LoadTxt(TILx&amp; Lx){
48    PSchTask SchTask=PSchTask(new TSchTask());
49    Lx.GetVar(&quot;SchTask&quot;, true, true);
50    SchTask-&gt;TaskId=Lx.GetVarInt(&quot;TaskId&quot;);
51    Lx.GetVarStrVV(&quot;DimObjVV&quot;, SchTask-&gt;DimObjVV);
52    SchTask-&gt;StartTm=Lx.GetVarSecTm(&quot;StartTm&quot;);
53    SchTask-&gt;EndTm=Lx.GetVarSecTm(&quot;EndTm&quot;);
54    SchTask-&gt;Forced=Lx.GetVarBool(&quot;Forced&quot;);
55    Lx.GetVarEnd(true, true);
56    return SchTask;
57  }
58  void TSchTask::SaveTxt(TOLx&amp; Lx) const {
59    Lx.PutVar(&quot;SchTask&quot;, true, true);
60    Lx.PutVarInt(&quot;TaskId&quot;, TaskId);
61    Lx.PutVarStrVV(&quot;DimObjVV&quot;, DimObjVV);
62    Lx.PutVarSecTm(&quot;StartTm&quot;, StartTm);
63    Lx.PutVarSecTm(&quot;EndTm&quot;, EndTm);
64    Lx.PutVarBool(&quot;Forced&quot;, Forced);
65    Lx.PutVarEnd(true, true);
66  }
67  void TSchObj::AddTask(const PSchTask&amp; Task, const bool&amp; OverlapCheckP){
68    IAssert(IsTaskOk(Task, OverlapCheckP));
69    if (Task-&gt;IsForced()){
70      FrcTaskV.Add(Task);
71    } else {
72      TTmTaskKd TmTaskKd(Task-&gt;GetStartTm(), Task);
73      int TaskN=TmTaskKdV.AddSorted(TmTaskKd);
74      if (0&lt;TaskN){
75        PSchTask PrevTask=TmTaskKdV[TaskN-1].Dat;
76        if (OverlapCheckP){IAssert(TSchTask::IsCons(PrevTask, Task));}
77      }
78      if (TaskN+1&lt;TmTaskKdV.Len()){
79        PSchTask NextTask=TmTaskKdV[TaskN+1].Dat;
80        if (OverlapCheckP){IAssert(TSchTask::IsCons(Task, NextTask));}
81      }
82    }
83  }
84  void TSchObj::DelTask(const PSchTask&amp; Task){
85    if (Task-&gt;IsForced()){
86      int FrcTaskN=0;
87      while ((FrcTaskN&lt;FrcTaskV.Len())&amp;&amp;
88       (FrcTaskV[FrcTaskN]-&gt;GetTaskId()!=Task-&gt;GetTaskId())){FrcTaskN++;}
89      IAssert(FrcTaskN&lt;FrcTaskV.Len());
90      FrcTaskV.Del(FrcTaskN);
91    } else {
92      TTmTaskKd TmTaskKd(Task-&gt;GetStartTm(), Task);
93      int TaskN=TmTaskKdV.SearchBin(TmTaskKd);
94      IAssert(TaskN!=-1);
95      IAssert(Task-&gt;GetTaskId()==TmTaskKdV[TaskN].Dat-&gt;GetTaskId());
96      TmTaskKdV.Del(TaskN);
97    }
98  }
99  void TSchObj::GetTaskV(TSchTaskV&amp; TaskV){
100    TaskV.Clr();
101    for (int TaskN=0; TaskN&lt;GetTasks(); TaskN++){
102      TaskV.Add(GetTask(TaskN));}
103  }
104  int TSchObj::GetTasks() const {
105    return TmTaskKdV.Len()+FrcTaskV.Len();
106  }
107  PSchTask TSchObj::GetTask(const int&amp; TaskN) const {
108    if (TaskN&lt;TmTaskKdV.Len()){
109      return TmTaskKdV[TaskN].Dat;
110    } else {
111      return FrcTaskV[TaskN-TmTaskKdV.Len()];
112    }
113  }
114  bool TSchObj::IsRegTaskAtTm(const TSecTm&amp; Tm, PSchTask&amp; Task) const {
115    TTmTaskKd TmTaskKd(Tm);
116    int InsTaskN; int TaskN=TmTaskKdV.SearchBin(TmTaskKd, InsTaskN);
117    if (TaskN==-1){
118      if (InsTaskN==0){
119        Task=NULL; return false;
120      } else
121      if (TmTaskKdV[InsTaskN-1].Dat-&gt;IsTmIn(Tm)){
122        Task=TmTaskKdV[InsTaskN-1].Dat; return true;
123      } else {
<span onclick='openModal()' class='match'>124        Task=NULL; return false;
125      }
126    } else {
127      Task=TmTaskKdV[TaskN].Dat; return true;
128    }
129  }
130  bool TSchObj::IsRegTaskInTm(
</span>131   const TSecTm&amp; MnTm, const TSecTm&amp; MxTm, PSchTask&amp; Task) const {
132    TTmTaskKd StartTmTaskKd(MnTm);
133    TTmTaskKd EndTmTaskKd(MxTm);
134    int StartInsTaskN; int EndInsTaskN;
135    int StartTaskN=TmTaskKdV.SearchBin(StartTmTaskKd, StartInsTaskN);
136    int EndTaskN=TmTaskKdV.SearchBin(EndTmTaskKd, EndInsTaskN);
137    if ((StartTaskN==-1)&amp;&amp;(EndTaskN==-1)){
138      if (StartInsTaskN==EndInsTaskN){
139        if (StartInsTaskN==0){
140          Task=NULL; return false;
141        } else
142        if (TmTaskKdV[StartInsTaskN-1].Dat-&gt;IsTmIn(MnTm)){
143          Task=TmTaskKdV[StartInsTaskN-1].Dat; return true;
144        } else {
145          Task=NULL; return false;
146        }
147      } else {
148        Task=TmTaskKdV[StartInsTaskN].Dat; return true;
149      }
150    } else {
151      if (StartTaskN!=-1){IsRegTaskAtTm(MnTm, Task);}
152      else if (EndTaskN!=-1){IsRegTaskAtTm(MxTm, Task);}
153      else {Fail;}
154      IAssert(!Task.Empty());
155      return true;
156    }
157  }
158  bool TSchObj::IsFrcTaskInTm(
159   const TSecTm&amp; MnTm, const TSecTm&amp; MxTm, PSchTask&amp; Task) const {
160    for (int FrcTaskN=0; FrcTaskN&lt;FrcTaskV.Len(); FrcTaskN++){
161      if (FrcTaskV[FrcTaskN]-&gt;IsTmInts(MnTm, MxTm)){
162        Task=FrcTaskV[FrcTaskN]; return true;
163      }
164    }
165    return false;
166  }
167  bool TSchObj::IsTaskInTm(
168   const TSecTm&amp; MnTm, const TSecTm&amp; MxTm, PSchTask&amp; Task) const {
169    return IsRegTaskInTm(MnTm, MxTm, Task) || IsFrcTaskInTm(MnTm, MxTm, Task);
170  }
171  PSchObj TSchObj::LoadTxt(TILx&amp; Lx){
172    PSchObj SchObj=PSchObj(new TSchObj());
173    Lx.GetVar(&quot;SchObj&quot;, true, true);
174    SchObj-&gt;Nm=Lx.GetVarStr(&quot;Nm&quot;);
175    Lx.GetVar(&quot;TmTaskKdV&quot;, true, true);
176    while (!Lx.PeekVarEnd(true, true)){
177      PSchTask Task=TSchTask::LoadTxt(Lx);
178      SchObj-&gt;TmTaskKdV.Add(TTmTaskKd(Task-&gt;GetStartTm(), Task));
179    }
180    Lx.GetVarEnd(true, true);
181    Lx.GetVar(&quot;FrcTaskV&quot;, true, true);
182    while (!Lx.PeekVarEnd(true, true)){
183      PSchTask Task=TSchTask::LoadTxt(Lx);
184      SchObj-&gt;FrcTaskV.Add(Task);
185    }
186    Lx.GetVarEnd(true, true);
187    Lx.GetVarEnd(true, true);
188    return SchObj;
189  }
190  void TSchObj::SaveTxt(TOLx&amp; Lx) const {
191    Lx.PutVar(&quot;SchObj&quot;, true, true);
192    Lx.PutVarStr(&quot;Nm&quot;, Nm);
193    Lx.PutVar(&quot;TmTaskKdV&quot;, true, true);
194    for (int TaskN=0; TaskN&lt;TmTaskKdV.Len(); TaskN++){
195      TmTaskKdV[TaskN].Dat-&gt;SaveTxt(Lx);}
196    Lx.PutVarEnd(true, true);
197    Lx.PutVar(&quot;FrcTaskV&quot;, true, true);
198    for (int FrcTaskN=0; FrcTaskN&lt;FrcTaskV.Len(); FrcTaskN++){
199      FrcTaskV[FrcTaskN]-&gt;SaveTxt(Lx);}
200    Lx.PutVarEnd(true, true);
201    Lx.PutVarEnd(true, true);
202  }
203  void TSchDim::AddObj(const TStr&amp; ObjNm){
204    IAssert((!IsObj(ObjNm))&amp;&amp;(!IsCObj(ObjNm)));
205    PSchObj Obj=PSchObj(new TSchObj(ObjNm));
206    NmToObjH.AddDat(ObjNm, Obj);
207    NmToObjH.GetKeyId(ObjNm);
208  }
209  TStrV TSchDim::GetObjNmV() const {
210    TStrV ObjNmV(NmToObjH.Len(), 0);
211    int NmToObjP=NmToObjH.FFirstKeyId();
212    while (NmToObjH.FNextKeyId(NmToObjP)){
213      ObjNmV.Add(NmToObjH[NmToObjP]-&gt;GetNm());}
214    ObjNmV.Sort();
215    return ObjNmV;
216  }
217  int TSchDim::AddCObj(const TStr&amp; CObjNm, const TStrV&amp; ObjNmV){
218    IAssert((!IsObj(CObjNm))&amp;&amp;(!IsCObj(CObjNm)));
219    for (int ObjNmN=0; ObjNmN&lt;ObjNmV.Len(); ObjNmN++){
220      IAssert(IsObj(ObjNmV[ObjNmN]));}
221    CObjNmToObjNmVH.AddDat(CObjNm, ObjNmV);
222    return NmToObjH.GetKeyId(CObjNm);
223  }
224  void TSchDim::GetCObjFromDesc(
225   const TStr&amp; DescStr, TStr&amp; CObjNm, TStrV&amp; ObjNmV) const {
226    if (DescStr.IsChIn(&#x27;:&#x27;)){
227      TStr ObjNmVStr; DescStr.SplitOnCh(CObjNm, &#x27;:&#x27;, ObjNmVStr);
228      CObjNm=CObjNm.GetTrunc(); ObjNmV.Clr();
229      TChA ObjNm;
230      for (int ChN=0; ChN&lt;=ObjNmVStr.Len(); ChN++){
231        if ((ChN==ObjNmVStr.Len())||(ObjNmVStr[ChN]==&#x27;,&#x27;)){
232          ObjNm.Trunc();
233          if (!ObjNm.Empty()){ObjNmV.Add(ObjNm);}
234          ObjNm.Clr();
235        } else {
236          ObjNm+=ObjNmVStr[ChN];
237        }
238      }
239      ObjNmV.Sort();
240    } else {
241      CObjNm=DescStr.GetTrunc(); ObjNmV.Clr();
242    }
243  }
244  TStrV TSchDim::GetAllObjDescV() const {
245    TStrV DescStrV;
246    DescStrV.AddV(GetObjNmV());
247    TStrV CObjNmV=GetCObjNmV();
248    for (int CObjNmN=0; CObjNmN&lt;CObjNmV.Len(); CObjNmN++){
249      TStrV ObjNmV=GetCObj_ObjNmV(CObjNmV[CObjNmN]);
250      TChA DescChA; DescChA+=CObjNmV[CObjNmN]; DescChA+=&#x27;:&#x27;;
251      for (int ObjNmN=0; ObjNmN&lt;ObjNmV.Len(); ObjNmN++){
252        if (ObjNmN&gt;0){DescChA+=&quot;, &quot;;} DescChA+=ObjNmV[ObjNmN];}
253      DescStrV.Add(DescChA);
254    }
255    DescStrV.Sort();
256    return DescStrV;
257  }
258  void TSchDim::AddTask(const PSchTask&amp; Task){
259    for (int DimObjN=0; DimObjN&lt;Task-&gt;GetDimObjs(DimN); DimObjN++){
260      PSchObj Obj=GetObj(Task-&gt;GetDimObj(DimN, DimObjN));
261      Obj-&gt;AddTask(Task, OverlapCheckP);
262    }
263  }
264  void TSchDim::DelTask(const PSchTask&amp; Task){
265    for (int DimObjN=0; DimObjN&lt;Task-&gt;GetDimObjs(DimN); DimObjN++){
266      PSchObj Obj=GetObj(Task-&gt;GetDimObj(DimN, DimObjN));
267      Obj-&gt;DelTask(Task);
268    }
269  }
270  bool TSchDim::IsTaskOk(const PSchTask&amp; Task, PSchTask&amp; IcTask) const {
271    for (int DimObjN=0; DimObjN&lt;Task-&gt;GetDimObjs(DimN); DimObjN++){
272      PSchObj Obj=GetObj(Task-&gt;GetDimObj(DimN, DimObjN));
273      if (!Obj-&gt;IsTaskOk(Task, IcTask, OverlapCheckP)){return false;}
274    }
275    return true;
276  }
277  bool TSchDim::IsTaskInTm(const TStr&amp; ObjNm,
278   const TSecTm&amp; MnTm, const TSecTm&amp; MxTm, PSchTask&amp; Task) const {
279    PSchObj Obj=GetObj(ObjNm);
280    return Obj-&gt;IsTaskInTm(MnTm, MxTm, Task);
281  }
282  PSchDim TSchDim::LoadTxt(TILx&amp; Lx){
283    PSchDim SchDim=PSchDim(new TSchDim());
284    Lx.GetVar(&quot;SchDim&quot;, true, true);
285    SchDim-&gt;DimN=Lx.GetVarInt(&quot;DimN&quot;);
286    SchDim-&gt;Nm=Lx.GetVarStr(&quot;Nm&quot;);
287    SchDim-&gt;OverlapCheckP=Lx.GetVarBool(&quot;OverlapCheckP&quot;);
288    Lx.GetVar(&quot;NmToObjH&quot;, true, true);
289    int NmToObjH_Ports=Lx.GetVarInt(&quot;Ports&quot;);
290    SchDim-&gt;NmToObjH=TNmToObjH(NmToObjH_Ports);
291    while (!Lx.PeekVarEnd(true, true)){
292      PSchObj Obj=TSchObj::LoadTxt(Lx);
293      SchDim-&gt;NmToObjH.AddDat(Obj-&gt;GetNm(), Obj);
294    }
295    Lx.GetVarEnd(true, true);
296    Lx.GetVar(&quot;CObjNmToObjNmVH&quot;, true, true);
297    int CObjNmToObjNmVH_Ports=Lx.GetVarInt(&quot;Ports&quot;);
298    SchDim-&gt;CObjNmToObjNmVH=TStrStrVH(CObjNmToObjNmVH_Ports);
299    while (!Lx.PeekVarEnd(true, true)){
300      Lx.GetVar(&quot;CObj&quot;, true, true);
301      TStr CObjNm=Lx.GetVarStr(&quot;CObjNm&quot;);
302      TStrV ObjNmV; Lx.GetVarStrV(&quot;ObjNmV&quot;, ObjNmV);
303      SchDim-&gt;CObjNmToObjNmVH.AddDat(CObjNm, ObjNmV);
304      Lx.GetVarEnd(true, true);
305    }
306    Lx.GetVarEnd(true, true);
307    Lx.GetVarEnd(true, true);
308    return SchDim;
309  }
310  void TSchDim::SaveTxt(TOLx&amp; Lx) const {
311    Lx.PutVar(&quot;SchDim&quot;, true, true);
312    Lx.PutVarInt(&quot;DimN&quot;, DimN);
313    Lx.PutVarStr(&quot;Nm&quot;, Nm);
314    Lx.PutVarBool(&quot;OverlapCheckP&quot;, OverlapCheckP);
315    Lx.PutVar(&quot;NmToObjH&quot;, true, true);
316    int NmToObjP=NmToObjH.FFirstKeyId();
317    Lx.PutVarInt(&quot;Ports&quot;, NmToObjH.GetPorts());
318    while (NmToObjH.FNextKeyId(NmToObjP)){
319      NmToObjH[NmToObjP]-&gt;SaveTxt(Lx);}
320    Lx.PutVarEnd(true, true);
321    Lx.PutVar(&quot;CObjNmToObjNmVH&quot;, true, true);
322    int CObjNmToObjNmVP=CObjNmToObjNmVH.FFirstKeyId();
323    Lx.PutVarInt(&quot;Ports&quot;, CObjNmToObjNmVH.GetPorts());
324    while (CObjNmToObjNmVH.FNextKeyId(CObjNmToObjNmVP)){
325      Lx.PutVar(&quot;CObj&quot;, true, true);
326      Lx.PutVarStr(&quot;CObjNm&quot;, CObjNmToObjNmVH.GetKey(CObjNmToObjNmVP));
327      Lx.PutVarStrV(&quot;ObjNmV&quot;, CObjNmToObjNmVH[CObjNmToObjNmVP]);
328      Lx.PutVarEnd(true, true);
329    }
330    Lx.PutVarEnd(true, true);
331    Lx.PutVarEnd(true, true);
332  }
333  PSchRep TSchRep::New(
334   const PSch&amp; Sch, const TStr&amp; DimNm, const TStr&amp; ObjNm, const int&amp; ResMins,
335   const bool&amp; AllTmP, const TSecTm&amp; StartDtTm, const TSecTm&amp; EndDtTm){
336    PSchRep SchRep=PSchRep(new TSchRep());
337    TSecTm EndDayTm=TSecTm::GetZeroTm().AddDays(1);
338    {TSecTm CurDayTm=TSecTm::GetZeroTm();
339    while (CurDayTm&lt;EndDayTm){
340      SchRep-&gt;DayTmV.Add(CurDayTm); CurDayTm.AddMins(ResMins);}}
341    TSecTm NrStartDtTm; TSecTm NrEndDtTm;
342    if (AllTmP){
343      NrStartDtTm=Sch-&gt;GetCal()-&gt;GetStartTm();
344      NrEndDtTm=Sch-&gt;GetCal()-&gt;GetEndTm();
345    } else {
346      NrStartDtTm=StartDtTm; NrEndDtTm=EndDtTm;
347    }
348    if (NrStartDtTm&gt;NrEndDtTm){NrEndDtTm=NrStartDtTm;}
349    if (NrStartDtTm&lt;Sch-&gt;GetCal()-&gt;GetStartTm()){
350      NrStartDtTm=Sch-&gt;GetCal()-&gt;GetStartTm();}
351    if (NrEndDtTm&gt;Sch-&gt;GetCal()-&gt;GetEndTm()){
352      NrEndDtTm=Sch-&gt;GetCal()-&gt;GetEndTm();}
353    TSecTm CurDtTm=NrStartDtTm;
354    PSchTask PrevTask; int TaskN=0-1; int TaskSegN=-1;
355    while (CurDtTm&lt;NrEndDtTm){
356      SchRep-&gt;DtTmV.Add(CurDtTm);
357      SchRep-&gt;TaskNmVV.Add();
358      TSecTm StartTaskTm=CurDtTm;
359      TSecTm EndTaskTm=TSecTm(StartTaskTm).AddMins(ResMins);
360      for (int DayTmN=0; DayTmN&lt;SchRep-&gt;DayTmV.Len(); DayTmN++){
361        PSchTask Task;
362        if (Sch-&gt;IsTaskInTm(DimNm, ObjNm, StartTaskTm, EndTaskTm-1, Task)){
363          if (PrevTask==Task){TaskSegN++;} else {TaskN++; TaskSegN=1;}
364          TStr TaskStr=Task-&gt;GetStr()+&quot; (&quot;+TInt::GetStr(TaskSegN)+&quot;)&quot;;
365          SchRep-&gt;TaskNmVV.Last().Add(TaskStr);
366        } else {
367          SchRep-&gt;TaskNmVV.Last().Add();
368        }
369        PrevTask=Task;
370        StartTaskTm.AddMins(ResMins); EndTaskTm.AddMins(ResMins);
371      }
372      CurDtTm.AddDays(1);
373    }
374    return SchRep;
375  }
376  void TSchRep::SaveHtml(const PSOut&amp; SOut) const {
377    int CurDtTmN=0;
378    while (CurDtTmN&lt;GetDtTms()){
379      int MnDtTmN=CurDtTmN;
380      while ((CurDtTmN&lt;GetDtTms())&amp;&amp;
381       (GetDtTm(CurDtTmN).GetDayOfWeekN()!=TTmInfo::SunN)){CurDtTmN++;}
382      int MxDtTmN=CurDtTmN;
383      CurDtTmN++;
384      SOut-&gt;PutStr(&quot;&lt;table border=1 cellpadding=3&gt;\n&quot;);
385      SOut-&gt;PutStr(&quot;&lt;tr&gt;&quot;);
386      SOut-&gt;PutStr(&quot;&lt;td&gt;&quot;);
387      SOut-&gt;PutStr(&quot;Time&quot;);
388      SOut-&gt;PutStr(&quot;&lt;/td&gt;&quot;);
389      for (int DtTmN=MnDtTmN; DtTmN&lt;MxDtTmN; DtTmN++){
390        SOut-&gt;PutStr(&quot;&lt;td&gt;&quot;);
391        SOut-&gt;PutStr(GetDtTmStr(DtTmN));
392        SOut-&gt;PutStr(&quot;&lt;/td&gt;&quot;);
393      }
394      SOut-&gt;PutStr(&quot;&lt;/tr&gt;&quot;); SOut-&gt;PutLn();
395      for (int DayTmN=0; DayTmN&lt;GetDayTms(); DayTmN++){
396        SOut-&gt;PutStr(&quot;&lt;/tr&gt;&quot;);
397        SOut-&gt;PutStr(&quot;&lt;td&gt;&quot;);
398        SOut-&gt;PutStr(GetDayTmStr(DayTmN));
399        SOut-&gt;PutStr(&quot;&lt;/td&gt;&quot;);
400        for (int DtTmN=MnDtTmN; DtTmN&lt;MxDtTmN; DtTmN++){
401          SOut-&gt;PutStr(&quot;&lt;td&gt;&quot;);
402          if (GetTaskStr(DtTmN, DayTmN).Empty()){
403            SOut-&gt;PutStr(&quot;&amp;nbsp;&quot;);
404          } else {
405            SOut-&gt;PutStr(GetTaskStr(DtTmN, DayTmN));
406          }
407          SOut-&gt;PutStr(&quot;&lt;/td&gt;&quot;);
408        }
409        SOut-&gt;PutStr(&quot;&lt;/tr&gt;&quot;); SOut-&gt;PutLn();
410      }
411      SOut-&gt;PutStr(&quot;&lt;/table&gt;\n&quot;);
412    }
413  }
414  void TSchRep::SaveHtml(const TStr&amp; FNm) const {
415    PSOut SOut=TFOut::New(FNm);
416    SOut-&gt;PutStr(&quot;&lt;html&gt;\n&quot;);
417    SOut-&gt;PutStr(&quot;&lt;head&gt;&lt;title&gt;Urnik&lt;/title&gt;&lt;/head&gt;\n&quot;);
418    SOut-&gt;PutStr(&quot;&lt;body&gt;\n&quot;);
419    SaveHtml(SOut);
420    SOut-&gt;PutStr(&quot;&lt;/body&gt;\n&quot;);
421    SOut-&gt;PutStr(&quot;&lt;/html&gt;\n&quot;);
422  }
423  void TSchRep::SaveTxt(const PSOut&amp; SOut) const {
424    SOut-&gt;PutStr(&quot;Time&quot;);
425    for (int DtTmN=0; DtTmN&lt;GetDtTms(); DtTmN++){
426      SOut-&gt;PutCh(TabCh); SOut-&gt;PutStr(GetDtTmStr(DtTmN));}
427    SOut-&gt;PutLn();
428    for (int DayTmN=0; DayTmN&lt;GetDayTms(); DayTmN++){
429      SOut-&gt;PutStr(GetDayTmStr(DayTmN));
430      for (int DtTmN=0; DtTmN&lt;GetDtTms(); DtTmN++){
431        SOut-&gt;PutCh(TabCh); SOut-&gt;PutStr(GetTaskStr(DtTmN, DayTmN));}
432      SOut-&gt;PutLn();
433    }
434  }
435  void TSchRep::SaveTxt(const TStr&amp; FNm) const {
436    PSOut SOut=TFOut::New(FNm);
437    SaveTxt(SOut);
438  }
439  void TSchRep::SaveStat(const TStr&amp; FNm, const PSch&amp; Sch){
440    PSOut SOut=TFOut::New(FNm);
441    TStr StartTmStr=Sch-&gt;GetCal()-&gt;GetStartTm().GetDtStr(lSi);
442    TStr EndTmStr=Sch-&gt;GetCal()-&gt;GetEndTm().GetDtStr(lSi);
443    SOut-&gt;PutStr(&quot;Zacetek: &quot;); SOut-&gt;PutStr(StartTmStr); SOut-&gt;PutLn();
444    SOut-&gt;PutStr(&quot;Konec: &quot;); SOut-&gt;PutStr(EndTmStr); SOut-&gt;PutLn();
445    for (int DimN=0; DimN&lt;Sch-&gt;GetDims(); DimN++){
446      SOut-&gt;PutStr(&quot;----------------------&quot;); SOut-&gt;PutLn();
447      SOut-&gt;PutStr(TStr(&quot;Dimenzija: &quot;)+Sch-&gt;GetDimNm(DimN)); SOut-&gt;PutLn();
448      TStrV ObjNmV=Sch-&gt;GetObjNmV(DimN);
449      for (int ObjNmN=0; ObjNmN&lt;ObjNmV.Len(); ObjNmN++){
450        TStr ObjNm=ObjNmV[ObjNmN];
451        SOut-&gt;PutStr(ObjNm+&quot;: &quot;);
452        TSchTaskV TaskV; Sch-&gt;GetObjTaskV(DimN, ObjNm, TaskV);
453        int ObjSecs=0;
454        for (int TaskN=0; TaskN&lt;TaskV.Len(); TaskN++){
455          ObjSecs+=TaskV[TaskN]-&gt;GetTmSecs();}
456        SOut-&gt;PutStr(TInt::GetStr(ObjSecs/3600)+&quot;h &quot;);
457        SOut-&gt;PutStr(TInt::GetStr((ObjSecs%3600)/60)+&quot;m &quot;);
458        SOut-&gt;PutStr(TInt::GetStr((ObjSecs%3600*60)/60)+&quot;s&quot;);
459        SOut-&gt;PutLn();
460      }
461    }
462  }
463  void TSchCal::PutScope(const TSchScope&amp; _Scope,
464   const TSecTm&amp; _StartTm, const TSecTm&amp; _EndTm){
465    Scope=_Scope; StartTm=_StartTm; EndTm=_EndTm;
466    switch (Scope){
467      case ssUnlim: IAssert((!StartTm.IsDef())&amp;&amp;(!EndTm.IsDef())); break;
468      case ssLim: IAssert((StartTm.IsDef())&amp;&amp;(EndTm.IsDef())&amp;&amp;(StartTm&lt;=EndTm)); break;
469      case ssWeek:
470        IAssert((!StartTm.IsDef())&amp;&amp;(!EndTm.IsDef()));
471        StartTm=EndTm=TSecTm::GetZeroWeekTm(); EndTm.AddDays(7); break;
472      default: Fail;
473    }
474  }
475  void TSchCal::AddBadDay(const TSecTm&amp; DtTm, const TStr&amp; DescStr){
476    TSecTm NrDtTm=TSecTm::GetDtTm(DtTm);
477    int BadDayN;
478    if (BadDay_DtTmDescStrKdV.IsIn(NrDtTm, BadDayN)){
479      BadDay_DtTmDescStrKdV.Del(BadDayN);}
480    BadDay_DtTmDescStrKdV.AddSorted(TSecTmStrKd(DtTm, DescStr));
481  }
482  void TSchCal::DelBadDay(const TSecTm&amp; DtTm){
483    TSecTm NrDtTm=TSecTm::GetDtTm(DtTm);
484    int BadDayN;
485    if (BadDay_DtTmDescStrKdV.IsIn(NrDtTm, BadDayN)){
486      BadDay_DtTmDescStrKdV.Del(BadDayN);}
487  }
488  bool TSchCal::IsBadDay(const TSecTm&amp; DtTm) const {
489    TSecTm NrDtTm=TSecTm::GetDtTm(DtTm);
490    return BadDay_DtTmDescStrKdV.IsIn(NrDtTm);
491  }
492  PSchCal TSchCal::LoadTxt(TILx&amp; Lx){
493    PSchCal SchCal=TSchCal::New();
494    Lx.GetVar(&quot;SchCal&quot;, true, true);
495    SchCal-&gt;Scope=TSchScope(Lx.GetVarInt(&quot;Scope&quot;));
496    SchCal-&gt;StartTm=Lx.GetVarSecTm(&quot;StartTm&quot;);
497    SchCal-&gt;EndTm=Lx.GetVarSecTm(&quot;EndTm&quot;);
498    Lx.GetVar(&quot;BadDay_DtTmDescStrKdV&quot;, true, true);
499    while (!Lx.PeekVarEnd(true, true)){
500      TSecTm DtTm=Lx.GetVarSecTm(&quot;DtTm&quot;);
501      TStr DescStr=Lx.GetVarStr(&quot;DescStr&quot;);
502      SchCal-&gt;BadDay_DtTmDescStrKdV.Add(TSecTmStrKd(DtTm, DescStr));
503    }
504    Lx.GetVarEnd(true, true);
505    Lx.GetVarEnd(true, true);
506    return SchCal;
507  }
508  void TSchCal::SaveTxt(TOLx&amp; Lx) const {
509    Lx.PutVar(&quot;SchCal&quot;, true, true);
510    Lx.PutVarInt(&quot;Scope&quot;, int(Scope));
511    Lx.PutVarSecTm(&quot;StartTm&quot;, StartTm);
512    Lx.PutVarSecTm(&quot;EndTm&quot;, EndTm);
513    Lx.PutVar(&quot;BadDay_DtTmDescStrKdV&quot;, true, true);
514    for (int BadDayN=0; BadDayN&lt;BadDay_DtTmDescStrKdV.Len(); BadDayN++){
515      Lx.PutVarSecTm(&quot;DtTm&quot;, BadDay_DtTmDescStrKdV[BadDayN].Key);
516      Lx.PutVarStr(&quot;DescStr&quot;, BadDay_DtTmDescStrKdV[BadDayN].Dat);
517    }
518    Lx.PutVarEnd(true, true);
519    Lx.PutVarEnd(true, true);
520  }
521  TSch::TSch(const TStr&amp; _Nm, const int&amp; Dims,
522   const int&amp; ExpObjs, const int&amp; ExpTasks):
523    Nm(_Nm), Cal(TSchCal::New()),
524    DimV(Dims), LastTaskId(0), CpbTask(),
525    IdToTaskH(ExpTasks), NmToPatH(10){
526    for (int DimN=0; DimN&lt;Dims; DimN++){
527      DimV[DimN]=PSchDim(new TSchDim(DimN, ExpObjs));}
528  }
529  TStrV TSch::GetDimNmV() const {
530    TStrV DimNmV(GetDims(), 0);
531    for (int DimN=0; DimN&lt;GetDims(); DimN++){
532      DimNmV.Add(GetDimNm(DimN));}
533    return DimNmV;
534  }
535  int TSch::GetDimN(const TStr&amp; DimNm) const {
536    for (int DimN=0; DimN&lt;GetDims(); DimN++){
537      if (GetDimNm(DimN)==DimNm){return DimN;}}
538    return -1;
539  }
540  void TSch::DelObj(const int&amp; DimN, const TStr&amp; ObjNm){
541    TSchTaskV TaskV; GetObjTaskV(DimN, ObjNm, TaskV);
542    for (int TaskN=0; TaskN&lt;TaskV.Len(); TaskN++){
543      DelTask(TaskV[TaskN]-&gt;GetTaskId());}
544    DimV[DimN]-&gt;DelObj(ObjNm);
545    SyncPatVObj();
546  }
547  bool TSch::IsOkForAddTask(TStr&amp; MsgStr) const {
548    if (GetDims()==0){MsgStr=&quot;Dimenzije niso definirane.&quot;; return false;}
549    for (int DimN=0; DimN&lt;GetDims(); DimN++){
550      if (GetObjs(DimN)==0){
551        MsgStr=&quot;Dimenzija nima objektov.&quot;; return false;}
552    }
553    MsgStr=&quot;Ok.&quot;; return true;
554  }
555  int TSch::AddTask(const PSchTask&amp; Task){
556    IAssert(Task-&gt;GetDims()==GetDims());
557    IdToTaskH.AddDat(Task-&gt;GetTaskId(), Task);
558    for (int DimN=0; DimN&lt;GetDims(); DimN++){
559      DimV[DimN]-&gt;AddTask(Task);}
560    return Task-&gt;GetTaskId();
561  }
562  int TSch::AddTask(
563   const TVec&lt;TStrV&gt;&amp; DimObjVV,
564   const TSecTm&amp; StartTm, const TSecTm&amp; EndTm, const bool&amp; Forced){
565    int TaskId=GetNewTaskId();
566    PSchTask Task=PSchTask(new TSchTask(TaskId, DimObjVV, StartTm, EndTm, Forced));
567    return AddTask(Task);
568  }
569  int TSch::AddTask(
570   const TStr&amp; DimObj1, const TStr&amp; DimObj2, const TStr&amp; DimObj3,
571   const TSecTm&amp; StartTm, const TSecTm&amp; EndTm, const bool&amp; Forced){
572    TVec&lt;TStrV&gt; DimObjVV(3, 0);
573    DimObjVV.Add(); DimObjVV.Last().Add(DimObj1);
574    DimObjVV.Add(); DimObjVV.Last().Add(DimObj2);
575    DimObjVV.Add(); DimObjVV.Last().Add(DimObj3);
576    return AddTask(DimObjVV, StartTm, EndTm, Forced);
577  }
578  int TSch::AddTask(
579   const TStrV&amp; DimObjV,
580   const TSecTm&amp; StartTm, const TSecTm&amp; EndTm, const bool&amp; Forced){
581    TVec&lt;TStrV&gt; DimObjVV(3, 0);
582    DimObjVV.Add(); DimObjVV.Last().Add(DimObjV[0]);
583    DimObjVV.Add(); DimObjVV.Last().Add(DimObjV[1]);
584    DimObjVV.Add(); DimObjVV.Last().Add(DimObjV[2]);
585    return AddTask(DimObjVV, StartTm, EndTm, Forced);
586  }
587  int TSch::AddTask(
588   const TStrV&amp; DimObjV1, const TStrV&amp; DimObjV2, const TStrV&amp; DimObjV3,
589   const TSecTm&amp; StartTm, const TSecTm&amp; EndTm, const bool&amp; Forced){
590    TVec&lt;TStrV&gt; DimObjVV(3, 0);
591    DimObjVV.Add(DimObjV1);
592    DimObjVV.Add(DimObjV2);
593    DimObjVV.Add(DimObjV3);
594    return AddTask(DimObjVV, StartTm, EndTm, Forced);
595  }
596  void TSch::DelTask(const int&amp; TaskId){
597    PSchTask Task=IdToTaskH.GetDat(TaskId);
598    for (int DimN=0; DimN&lt;GetDims(); DimN++){
599      DimV[DimN]-&gt;DelTask(Task);}
600    IdToTaskH.DelKey(TaskId);
601  }
602  void TSch::GetDayTaskV(const TSecTm&amp; DtTm, TIntV&amp; TaskIdV) const {
603    TaskIdV.Clr();
604    int IdToTaskP=IdToTaskH.FFirstKeyId();
605    while (IdToTaskH.FNextKeyId(IdToTaskP)){
606      PSchTask Task=IdToTaskH[IdToTaskP];
607      TSecTm TaskDtTm=TSecTm::GetDtTm(Task-&gt;GetStartTm());
608      if (TaskDtTm==DtTm){
609        TaskIdV.Add(Task-&gt;GetTaskId());}
610    }
611  }
612  bool TSch::IsTask(const int&amp; TaskId, PSchTask&amp; Task) const {
613    int IdToTaskP;
614    if (IdToTaskH.IsKey(TaskId, IdToTaskP)){
615      Task=IdToTaskH[IdToTaskP]; return true;}
616    else {return false;}
617  }
618  bool TSch::IsTaskOk(const PSchTask&amp; Task, TSchTaskV&amp; DimIcTaskV) const {
619    DimIcTaskV.Gen(GetDims(), GetDims());
620    bool Ok=true;
621    for (int DimN=0; DimN&lt;GetDims(); DimN++){
622      PSchTask IcTask;
623      if (!DimV[DimN]-&gt;IsTaskOk(Task, IcTask)){
624        DimIcTaskV[DimN]=IcTask; Ok=false;
625      }
626    }
627    return Ok;
628  }
629  bool TSch::IsTaskSim(const PSchTask&amp; Task, PSchTask&amp; SimTask) const {
630    TVec&lt;TStrV&gt; DimObjVV; Task-&gt;GetDimObjVV(DimObjVV);
631    int IdToTaskP=IdToTaskH.FFirstKeyId();
632    while (IdToTaskH.FNextKeyId(IdToTaskP)){
633      SimTask=IdToTaskH[IdToTaskP];
634      if (
635       (Task-&gt;GetStartTm()==SimTask-&gt;GetStartTm())&amp;&amp;
636       (Task-&gt;GetEndTm()==SimTask-&gt;GetEndTm())&amp;&amp;
637       (Task-&gt;IsForced()==SimTask-&gt;IsForced())){
638        TVec&lt;TStrV&gt; SimDimObjVV; SimTask-&gt;GetDimObjVV(SimDimObjVV);
639        if (DimObjVV==SimDimObjVV){return true;}
640      }
641    }
642    return false;
643  }
644  PSch TSch::AddPat(const TStr&amp; PatNm){
645    IAssert(!IsPat(PatNm));
646    PSch Pat=New(PatNm, GetDims());
647    Pat-&gt;PutNm(PatNm);
648    Pat-&gt;GetCal()-&gt;PutScope(ssWeek);
649    for (int DimN=0; DimN&lt;GetDims(); DimN++){
650      Pat-&gt;PutDimNm(DimN, GetDimNm(DimN));
651      Pat-&gt;AddObjV(DimN, GetObjNmV(DimN));
652      TStrV CObjNmV=GetCObjNmV(DimN);
653      for (int CObjNmN=0; CObjNmN&lt;CObjNmV.Len(); CObjNmN++){
654        TStr CObjNm=CObjNmV[CObjNmN];
655        TStrV ObjNmV=GetCObj_ObjNmV(DimN, CObjNm);
656        Pat-&gt;AddCObj(DimN, CObjNm, ObjNmV);
657      }
658    }
659    NmToPatH.AddDat(PatNm, Pat);
660    return Pat;
661  }
662  void TSch::SyncPatObj(const TStr&amp; PatNm) const {
663    PSch Pat=GetPat(PatNm);
664    for (int DimN=0; DimN&lt;GetDims(); DimN++){
665      {TStrV ObjNmV=GetObjNmV(DimN);
666      for (int ObjNmN=0; ObjNmN&lt;ObjNmV.Len(); ObjNmN++){
667        if (!Pat-&gt;IsObj(DimN, ObjNmV[ObjNmN])){
668          Pat-&gt;AddObj(DimN, ObjNmV[ObjNmN]);}
669      }}
670      {TStrV CObjNmV=GetCObjNmV(DimN);
671      for (int CObjNmN=0; CObjNmN&lt;CObjNmV.Len(); CObjNmN++){
672        TStrV ObjNmV=GetCObj_ObjNmV(DimN, CObjNmV[CObjNmN]);
673        if (!Pat-&gt;IsCObj(DimN, CObjNmV[CObjNmN])){
674          Pat-&gt;AddCObj(DimN, CObjNmV[CObjNmN], ObjNmV);
675        } else {
676          TStrV PatObjNmV=Pat-&gt;GetCObj_ObjNmV(DimN, CObjNmV[CObjNmN]);
677          if (ObjNmV!=PatObjNmV){
678            Pat-&gt;DelCObj(DimN, CObjNmV[CObjNmN]);
679            Pat-&gt;AddCObj(DimN, CObjNmV[CObjNmN], ObjNmV);
680          }
681        }
682      }}
683      {TStrV PatObjNmV=Pat-&gt;GetObjNmV(DimN);
684      for (int PatObjNmN=0; PatObjNmN&lt;PatObjNmV.Len(); PatObjNmN++){
685        if (!IsObj(DimN, PatObjNmV[PatObjNmN])){
686          Pat-&gt;DelObj(DimN, PatObjNmV[PatObjNmN]);}
687      }}
688      {TStrV PatCObjNmV=Pat-&gt;GetCObjNmV(DimN);
689      for (int PatCObjNmN=0; PatCObjNmN&lt;PatCObjNmV.Len(); PatCObjNmN++){
690        TStrV PatObjNmV=Pat-&gt;GetCObj_ObjNmV(DimN, PatCObjNmV[PatCObjNmN]);
691        if (!IsCObj(DimN, PatCObjNmV[PatCObjNmN])){
692          Pat-&gt;DelCObj(DimN, PatCObjNmV[PatCObjNmN]);
693        }
694      }}
695    }
696  }
697  void TSch::SyncPatVObj() const {
698    TStrV PatNmV=GetPatNmV();
699    for (int PatNmN=0; PatNmN&lt;PatNmV.Len(); PatNmN++){
700      SyncPatObj(PatNmV[PatNmN]);}
701  }
702  void TSch::ApplyPatAdd(
703   const PSch&amp; Pat, const TSecTm&amp; StartDtTm, const TSecTm&amp; EndDtTm,
704   const bool&amp; TestOnlyP, TStrV&amp; LogStrV){
705    LogStrV.Clr();
706    LogStrV.Add(TStr(&quot;Adding pattern: &quot;)+Pat-&gt;GetNm());
707    LogStrV.Add(TStr(&quot;Start date: &quot;)+StartDtTm.GetDtStr());
708    LogStrV.Add(TStr(&quot;End date: &quot;)+EndDtTm.GetDtStr());
709    LogStrV.Add(TStr(&quot;Test only: &quot;)+TBool::GetYesNoStr(TestOnlyP));
710    LogStrV.Add(&quot;------------------------&quot;);
711    TSecTm CurSchDtTm=TSecTm::GetDtTm(StartDtTm);
712    if (CurSchDtTm&lt;GetCal()-&gt;GetStartTm()){CurSchDtTm=GetCal()-&gt;GetStartTm();}
713    TSecTm CurPatDtTm=TSecTm::GetDtTm(Pat-&gt;GetCal()-&gt;GetStartTm());
714    while (CurPatDtTm.GetDayOfWeekN()!=CurSchDtTm.GetDayOfWeekN()){
715      CurPatDtTm.AddDays(1);}
716    while ((CurSchDtTm&lt;GetCal()-&gt;GetStartTm())&amp;&amp;(CurSchDtTm&lt;=EndDtTm)){
717      TIntV PatTaskIdV; Pat-&gt;GetDayTaskV(CurPatDtTm, PatTaskIdV);
718      for (int PatTaskIdN=0; PatTaskIdN&lt;PatTaskIdV.Len(); PatTaskIdN++){
719        PSchTask PatTask=Pat-&gt;GetTask(PatTaskIdV[PatTaskIdN]);
720        TSecTm SchTaskStartTm=
721         CurSchDtTm+PatTask-&gt;GetStartTm()-TSecTm::GetDtTm(PatTask-&gt;GetStartTm());
722        TSecTm SchTaskEndTm=
723         CurSchDtTm+PatTask-&gt;GetEndTm()-TSecTm::GetDtTm(PatTask-&gt;GetEndTm());
724        int SchTaskId=GetNewTaskId();
725        TVec&lt;TStrV&gt; SchTaskDimObjVV; PatTask-&gt;GetDimObjVV(SchTaskDimObjVV);
726        bool SchTaskForced=PatTask-&gt;IsForced();
727        PSchTask SchTask=PSchTask(new TSchTask(SchTaskId,
728         SchTaskDimObjVV, SchTaskStartTm, SchTaskEndTm, SchTaskForced));
729        if (IsTaskOk(SchTask)){
730          if (!TestOnlyP){
731            AddTask(SchTask);} 
732          TChA LogChA;
733          LogChA+=&quot;Add &quot;;
734          LogChA+=&#x27;[&#x27;; LogChA+=SchTaskStartTm.GetStr(); LogChA+=&#x27;]&#x27;;
735          LogChA+=&quot; - &quot;;
736          LogChA+=&#x27;[&#x27;; LogChA+=SchTaskEndTm.GetStr(); LogChA+=&#x27;]&#x27;; LogChA+=&quot;  &quot;;
737          LogChA+=SchTask-&gt;GetStr();
738          LogStrV.Add(LogChA);
739        }
740      }
741      CurSchDtTm.AddDays(1);
742      CurPatDtTm.AddDays(1);
743      if (CurPatDtTm&gt;=Pat-&gt;GetCal()-&gt;GetEndTm()){
744        CurPatDtTm=Pat-&gt;GetCal()-&gt;GetStartTm();}
745    }
746  }
747  void TSch::ApplyPatDel(
748   const PSch&amp; Pat, const TSecTm&amp; StartDtTm, const TSecTm&amp; EndDtTm,
749   const bool&amp; TestOnlyP, TStrV&amp; LogStrV){
750    LogStrV.Clr();
751    LogStrV.Add(TStr(&quot;Deleting pattern: &quot;)+Pat-&gt;GetNm());
752    LogStrV.Add(TStr(&quot;Start date: &quot;)+StartDtTm.GetDtStr());
753    LogStrV.Add(TStr(&quot;End date: &quot;)+EndDtTm.GetDtStr());
754    LogStrV.Add(TStr(&quot;Test only: &quot;)+TBool::GetYesNoStr(TestOnlyP));
755    LogStrV.Add(&quot;------------------------&quot;);
756    TSecTm CurSchDtTm=TSecTm::GetDtTm(StartDtTm);
757    if (CurSchDtTm&lt;GetCal()-&gt;GetStartTm()){CurSchDtTm=GetCal()-&gt;GetStartTm();}
758    TSecTm CurPatDtTm=TSecTm::GetDtTm(Pat-&gt;GetCal()-&gt;GetStartTm());
759    while (CurPatDtTm.GetDayOfWeekN()!=CurSchDtTm.GetDayOfWeekN()){
760      CurPatDtTm.AddDays(1);}
761    while ((CurSchDtTm&lt;GetCal()-&gt;GetEndTm())&amp;&amp;(CurSchDtTm&lt;=EndDtTm)){
762      TIntV PatTaskIdV; Pat-&gt;GetDayTaskV(CurPatDtTm, PatTaskIdV);
763      for (int PatTaskIdN=0; PatTaskIdN&lt;PatTaskIdV.Len(); PatTaskIdN++){
764        PSchTask PatTask=Pat-&gt;GetTask(PatTaskIdV[PatTaskIdN]);
765        TSecTm SchTaskStartTm=
766         CurSchDtTm+PatTask-&gt;GetStartTm()-TSecTm::GetDtTm(PatTask-&gt;GetStartTm());
767        TSecTm SchTaskEndTm=
768         CurSchDtTm+PatTask-&gt;GetEndTm()-TSecTm::GetDtTm(PatTask-&gt;GetEndTm());
769        int SchTaskId=GetNewTaskId();
770        TVec&lt;TStrV&gt; SchTaskDimObjVV; PatTask-&gt;GetDimObjVV(SchTaskDimObjVV);
771        bool SchTaskForced=PatTask-&gt;IsForced();
772        PSchTask SchTask=PSchTask(new TSchTask(SchTaskId,
773         SchTaskDimObjVV, SchTaskStartTm, SchTaskEndTm, SchTaskForced));
774        PSchTask SimSchTask;
775        if (IsTaskSim(SchTask, SimSchTask)){
776          if (!TestOnlyP){
777            DelTask(SimSchTask-&gt;GetTaskId()); 
778          }
779          TChA LogChA;
780          LogChA+=&quot;Del &quot;;
781          LogChA+=&#x27;[&#x27;; LogChA+=SchTaskStartTm.GetStr(); LogChA+=&#x27;]&#x27;;
782          LogChA+=&quot; - &quot;;
783          LogChA+=&#x27;[&#x27;; LogChA+=SchTaskEndTm.GetStr(); LogChA+=&#x27;]&#x27;; LogChA+=&quot;  &quot;;
784          LogChA+=SchTask-&gt;GetStr();
785          LogStrV.Add(LogChA);
786        }
787      }
788      CurSchDtTm.AddDays(1);
789      CurPatDtTm.AddDays(1);
790      if (CurPatDtTm&gt;=Pat-&gt;GetCal()-&gt;GetEndTm()){
791        CurPatDtTm=Pat-&gt;GetCal()-&gt;GetStartTm();}
792    }
793  }
794  PSch TSch::LoadTxt(TILx&amp; Lx){
795    PSch Sch=PSch(new TSch());
796    Lx.GetVar(&quot;Sch&quot;, true, true);
797    Sch-&gt;Nm=Lx.GetVarStr(&quot;Nm&quot;);
798    Sch-&gt;Cal=TSchCal::LoadTxt(Lx);
799    Lx.GetVar(&quot;DimV&quot;, true, true);
800    while (!Lx.PeekVarEnd(true, true)){
801      Sch-&gt;DimV.Add(TSchDim::LoadTxt(Lx));}
802    Lx.GetVarEnd(true, true);
803    Sch-&gt;LastTaskId=Lx.GetVarInt(&quot;LastTaskId&quot;);
804    {Lx.GetVar(&quot;IdToTaskH&quot;, true, true);
805    int Ports=Lx.GetVarInt(&quot;Ports&quot;);
806    Sch-&gt;IdToTaskH=TIdToTaskH(Ports);
807    while (!Lx.PeekVarEnd(true, true)){
808      PSchTask Task=TSchTask::LoadTxt(Lx);
809      Sch-&gt;IdToTaskH.AddDat(Task-&gt;GetTaskId(), Task);
810    }
811    Lx.GetVarEnd(true, true);}
812    {Lx.GetVar(&quot;NmToPatH&quot;, true, true);
813    int Ports=Lx.GetVarInt(&quot;Ports&quot;);
814    Sch-&gt;NmToPatH=TNmToPatH(Ports);
815    while (!Lx.PeekVarEnd(true, true)){
816      PSch Pat=TSch::LoadTxt(Lx);
817      Sch-&gt;NmToPatH.AddDat(Pat-&gt;GetNm(), Pat);
818    }
819    Lx.GetVarEnd(true, true);}
820    Lx.GetVarEnd(true, true);
821    return Sch;
822  }
823  PSch TSch::LoadTxt(const TStr&amp; FNm){
824    PSIn SIn=PSIn(new TFIn(FNm));
825    TILx Lx(SIn, TFSet()|iloRetEoln|iloSigNum|iloCsSens);
826    return LoadTxt(Lx);
827  }
828  void TSch::SaveTxt(TOLx&amp; Lx) const {
829    Lx.PutVar(&quot;Sch&quot;, true, true);
830    Lx.PutVarStr(&quot;Nm&quot;, Nm);
831    Cal-&gt;SaveTxt(Lx);
832    Lx.PutVar(&quot;DimV&quot;, true, true);
833    for (int DimN=0; DimN&lt;DimV.Len(); DimN++){
834      DimV[DimN]-&gt;SaveTxt(Lx);}
835    Lx.PutVarEnd(true, true);
836    Lx.PutVarInt(&quot;LastTaskId&quot;, LastTaskId);
837    Lx.PutVar(&quot;IdToTaskH&quot;, true, true);
838    Lx.PutVarInt(&quot;Ports&quot;, IdToTaskH.GetPorts());
839    int IdToTaskP=IdToTaskH.FFirstKeyId();
840    while (IdToTaskH.FNextKeyId(IdToTaskP)){
841      IdToTaskH[IdToTaskP]-&gt;SaveTxt(Lx);}
842    Lx.PutVarEnd(true, true);
843    Lx.PutVar(&quot;NmToPatH&quot;, true, true);
844    Lx.PutVarInt(&quot;Ports&quot;, NmToPatH.GetPorts());
845    int NmToPatP=NmToPatH.FFirstKeyId();
846    while (NmToPatH.FNextKeyId(NmToPatP)){
847      NmToPatH[NmToPatP]-&gt;SaveTxt(Lx);}
848    Lx.PutVarEnd(true, true);
849    Lx.PutVarEnd(true, true);
850  }
851  void TSch::SaveTxt(const TStr&amp; FNm) const {
852    PSOut SOut=PSOut(new TFOut(FNm));
853    TOLx Lx(SOut, TFSet()|oloFrcEoln|oloSigNum|oloCsSens|oloVarIndent);
854    SaveTxt(Lx);
855  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-ssch.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-sch.cpp</div>
                </div>
                <div class="column column_space"><pre><code>89          Task=NULL; return false;
90        }
91      } else {
92        Task=TaskV[StartInsTaskN].Dat; return true;
93      }
94    } else {
</pre></code></div>
                <div class="column column_space"><pre><code>124        Task=NULL; return false;
125      }
126    } else {
127      Task=TmTaskKdV[TaskN].Dat; return true;
128    }
129  }
130  bool TSchObj::IsRegTaskInTm(
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    