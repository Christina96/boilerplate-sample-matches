
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 14, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-intproto.cpp</h3>
            <pre><code>1  #define _USE_MATH_DEFINES 
2  #ifdef HAVE_CONFIG_H
3  #  include "config_auto.h"
4  #endif
5  #include "intproto.h"
6  #include "classify.h"
7  #include "fontinfo.h"
8  #include "mfoutline.h"
9  #include "picofeat.h"
10  #include "points.h"
11  #include "shapetable.h"
12  #ifndef GRAPHICS_DISABLED
13  #include "svmnode.h"
14  #endif
15  #include "helpers.h"
16  #include <algorithm>
17  #include <cassert>
18  #include <cmath> 
19  #include <cstdio>
20  namespace tesseract {
21  #define PROTO_PRUNER_SCALE (4.0)
22  #define INT_DESCENDER (0.0 * INT_CHAR_NORM_RANGE)
23  #define INT_BASELINE (0.25 * INT_CHAR_NORM_RANGE)
24  #define INT_XHEIGHT (0.75 * INT_CHAR_NORM_RANGE)
25  #define INT_CAPHEIGHT (1.0 * INT_CHAR_NORM_RANGE)
26  #define INT_XCENTER (0.5 * INT_CHAR_NORM_RANGE)
27  #define INT_YCENTER (0.5 * INT_CHAR_NORM_RANGE)
28  #define INT_XRADIUS (0.2 * INT_CHAR_NORM_RANGE)
29  #define INT_YRADIUS (0.2 * INT_CHAR_NORM_RANGE)
30  #define INT_MIN_X 0
31  #define INT_MIN_Y 0
32  #define INT_MAX_X INT_CHAR_NORM_RANGE
33  #define INT_MAX_Y INT_CHAR_NORM_RANGE
34  #define HV_TOLERANCE (0.0025) &bsol;* approx 0.9 degrees */
35  typedef enum { StartSwitch, EndSwitch, LastSwitch } SWITCH_TYPE;
36  #define MAX_NUM_SWITCHES 3
37  struct FILL_SWITCH {
38    SWITCH_TYPE Type;
39    int8_t X, Y;
40    int16_t YInit;
41    int16_t Delta;
42  };
43  struct TABLE_FILLER {
44    uint8_t NextSwitch;
45    uint8_t AngleStart, AngleEnd;
46    int8_t X;
47    int16_t YStart, YEnd;
48    int16_t StartDelta, EndDelta;
49    FILL_SWITCH Switch[MAX_NUM_SWITCHES];
50  };
51  struct FILL_SPEC {
52    int8_t X;
53    int8_t YStart, YEnd;
54    uint8_t AngleStart, AngleEnd;
55  };
56  #define OLD_MAX_NUM_CONFIGS 32
57  #define OLD_WERDS_PER_CONFIG_VEC ((OLD_MAX_NUM_CONFIGS + BITS_PER_WERD - 1) / BITS_PER_WERD)
58  #define CircularIncrement(i, r) (((i) < (r)-1) ? ((i)++) : ((i) = 0))
59  #define MapParam(P, O, N) (std::floor(((P) + (O)) * (N)))
60  float BucketStart(int Bucket, float Offset, int NumBuckets);
61  float BucketEnd(int Bucket, float Offset, int NumBuckets);
62  void DoFill(FILL_SPEC *FillSpec, CLASS_PRUNER_STRUCT *Pruner, uint32_t ClassMask,
63              uint32_t ClassCount, uint32_t WordIndex);
64  bool FillerDone(TABLE_FILLER *Filler);
65  void FillPPCircularBits(uint32_t ParamTable[NUM_PP_BUCKETS][WERDS_PER_PP_VECTOR], int Bit,
66                          float Center, float Spread, bool debug);
67  void FillPPLinearBits(uint32_t ParamTable[NUM_PP_BUCKETS][WERDS_PER_PP_VECTOR], int Bit,
68                        float Center, float Spread, bool debug);
69  void GetCPPadsForLevel(int Level, float *EndPad, float *SidePad, float *AnglePad);
70  ScrollView::Color GetMatchColorFor(float Evidence);
71  void GetNextFill(TABLE_FILLER *Filler, FILL_SPEC *Fill);
72  void InitTableFiller(float EndPad, float SidePad, float AnglePad, PROTO_STRUCT *Proto,
73                       TABLE_FILLER *Filler);
74  #ifndef GRAPHICS_DISABLED
75  void RenderIntFeature(ScrollView *window, const INT_FEATURE_STRUCT *Feature,
76                        ScrollView::Color color);
77  void RenderIntProto(ScrollView *window, INT_CLASS_STRUCT *Class, PROTO_ID ProtoId, ScrollView::Color color);
78  #endif 
79  #ifndef GRAPHICS_DISABLED
80  static ScrollView *IntMatchWindow = nullptr;
81  static ScrollView *FeatureDisplayWindow = nullptr;
82  static ScrollView *ProtoDisplayWindow = nullptr;
83  #endif
84  static INT_VAR(classify_num_cp_levels, 3, "Number of Class Pruner Levels");
85  static double_VAR(classify_cp_angle_pad_loose, 45.0, "Class Pruner Angle Pad Loose");
86  static double_VAR(classify_cp_angle_pad_medium, 20.0, "Class Pruner Angle Pad Medium");
87  static double_VAR(classify_cp_angle_pad_tight, 10.0, "CLass Pruner Angle Pad Tight");
88  static double_VAR(classify_cp_end_pad_loose, 0.5, "Class Pruner End Pad Loose");
89  static double_VAR(classify_cp_end_pad_medium, 0.5, "Class Pruner End Pad Medium");
90  static double_VAR(classify_cp_end_pad_tight, 0.5, "Class Pruner End Pad Tight");
91  static double_VAR(classify_cp_side_pad_loose, 2.5, "Class Pruner Side Pad Loose");
92  static double_VAR(classify_cp_side_pad_medium, 1.2, "Class Pruner Side Pad Medium");
93  static double_VAR(classify_cp_side_pad_tight, 0.6, "Class Pruner Side Pad Tight");
94  static double_VAR(classify_pp_angle_pad, 45.0, "Proto Pruner Angle Pad");
95  static double_VAR(classify_pp_end_pad, 0.5, "Proto Prune End Pad");
96  static double_VAR(classify_pp_side_pad, 2.5, "Proto Pruner Side Pad");
97  static int TruncateParam(float Param, int Min, int Max) {
98    int result;
99    if (Param < Min) {
100      result = Min;
101    } else if (Param > Max) {
102      result = Max;
103    } else {
104      result = static_cast<int>(std::floor(Param));
105    }
106    return result;
107  }
108  INT_FEATURE_STRUCT::INT_FEATURE_STRUCT(const FCOORD &pos, uint8_t theta)
109      : X(ClipToRange<int16_t>(static_cast<int16_t>(pos.x() + 0.5), 0, 255))
110      , Y(ClipToRange<int16_t>(static_cast<int16_t>(pos.y() + 0.5), 0, 255))
111      , Theta(theta)
112      , CP_misses(0) {}
113  INT_FEATURE_STRUCT::INT_FEATURE_STRUCT(int x, int y, int theta)
114      : X(static_cast<uint8_t>(ClipToRange<int>(x, 0, UINT8_MAX)))
115      , Y(static_cast<uint8_t>(ClipToRange<int>(y, 0, UINT8_MAX)))
116      , Theta(static_cast<uint8_t>(ClipToRange<int>(theta, 0, UINT8_MAX)))
117      , CP_misses(0) {}
118  void AddIntClass(INT_TEMPLATES_STRUCT *Templates, CLASS_ID ClassId, INT_CLASS_STRUCT *Class) {
119    int Pruner;
120    assert(LegalClassId(ClassId));
121    if (static_cast<unsigned>(ClassId) != Templates->NumClasses) {
122      fprintf(stderr,
123              "Please make sure that classes are added to templates"
124              " in increasing order of ClassIds\n");
125      exit(1);
126    }
127    ClassForClassId(Templates, ClassId) = Class;
128    Templates->NumClasses++;
129    if (Templates->NumClasses > MaxNumClassesIn(Templates)) {
130      Pruner = Templates->NumClassPruners++;
131      Templates->ClassPruners[Pruner] = new CLASS_PRUNER_STRUCT;
132      memset(Templates->ClassPruners[Pruner], 0, sizeof(CLASS_PRUNER_STRUCT));
133    }
134  } &bsol;* AddIntClass */
135  int AddIntConfig(INT_CLASS_STRUCT *Class) {
136    int Index;
137    assert(Class->NumConfigs < MAX_NUM_CONFIGS);
138    Index = Class->NumConfigs++;
139    Class->ConfigLengths[Index] = 0;
140    return Index;
141  } &bsol;* AddIntConfig */
142  int AddIntProto(INT_CLASS_STRUCT *Class) {
143    if (Class->NumProtos >= MAX_NUM_PROTOS) {
144      return (NO_PROTO);
145    }
146    int Index = Class->NumProtos++;
147    if (Class->NumProtos > MaxNumIntProtosIn(Class)) {
148      int ProtoSetId = Class->NumProtoSets++;
149      auto ProtoSet = new PROTO_SET_STRUCT;
150      Class->ProtoSets[ProtoSetId] = ProtoSet;
151      memset(ProtoSet, 0, sizeof(*ProtoSet));
152      Class->ProtoLengths.resize(MaxNumIntProtosIn(Class));
153    }
154    Class->ProtoLengths[Index] = 0;
155    auto Proto = ProtoForProtoId(Class, Index);
156    for (uint32_t *Word = Proto->Configs; Word < Proto->Configs + WERDS_PER_CONFIG_VEC; *Word++ = 0) {
157    }
158    return (Index);
159  }
160  void AddProtoToClassPruner(PROTO_STRUCT *Proto, CLASS_ID ClassId, INT_TEMPLATES_STRUCT *Templates)
161  #define MAX_LEVEL 2
162  {
163    CLASS_PRUNER_STRUCT *Pruner;
164    uint32_t ClassMask;
165    uint32_t ClassCount;
166    uint32_t WordIndex;
167    int Level;
168    float EndPad, SidePad, AnglePad;
169    TABLE_FILLER TableFiller;
170    FILL_SPEC FillSpec;
171    Pruner = CPrunerFor(Templates, ClassId);
172    WordIndex = CPrunerWordIndexFor(ClassId);
173    ClassMask = CPrunerMaskFor(MAX_LEVEL, ClassId);
174    for (Level = classify_num_cp_levels - 1; Level >= 0; Level--) {
175      GetCPPadsForLevel(Level, &EndPad, &SidePad, &AnglePad);
176      ClassCount = CPrunerMaskFor(Level, ClassId);
177      InitTableFiller(EndPad, SidePad, AnglePad, Proto, &TableFiller);
178      while (!FillerDone(&TableFiller)) {
179        GetNextFill(&TableFiller, &FillSpec);
180        DoFill(&FillSpec, Pruner, ClassMask, ClassCount, WordIndex);
181      }
182    }
183  } &bsol;* AddProtoToClassPruner */
184  void AddProtoToProtoPruner(PROTO_STRUCT *Proto, int ProtoId, INT_CLASS_STRUCT *Class, bool debug) {
185    float X, Y, Length;
186    float Pad;
187    if (ProtoId >= Class->NumProtos) {
188      tprintf("AddProtoToProtoPruner:assert failed: %d < %d", ProtoId, Class->NumProtos);
189    }
190    assert(ProtoId < Class->NumProtos);
191    int Index = IndexForProto(ProtoId);
192    auto ProtoSet = Class->ProtoSets[SetForProto(ProtoId)];
193    float Angle = Proto->Angle;
194  #ifndef _WIN32
195    assert(!std::isnan(Angle));
196  #endif
197    FillPPCircularBits(ProtoSet->ProtoPruner[PRUNER_ANGLE], Index, Angle + ANGLE_SHIFT,
198                       classify_pp_angle_pad / 360.0, debug);
199    Angle *= 2.0 * M_PI;
200    Length = Proto->Length;
201    X = Proto->X + X_SHIFT;
202    Pad = std::max(fabs(std::cos(Angle)) * (Length / 2.0 + classify_pp_end_pad * GetPicoFeatureLength()),
203                   fabs(std::sin(Angle)) * (classify_pp_side_pad * GetPicoFeatureLength()));
204    FillPPLinearBits(ProtoSet->ProtoPruner[PRUNER_X], Index, X, Pad, debug);
205    Y = Proto->Y + Y_SHIFT;
206    Pad = std::max(fabs(std::sin(Angle)) * (Length / 2.0 + classify_pp_end_pad * GetPicoFeatureLength()),
207                   fabs(std::cos(Angle)) * (classify_pp_side_pad * GetPicoFeatureLength()));
208    FillPPLinearBits(ProtoSet->ProtoPruner[PRUNER_Y], Index, Y, Pad, debug);
209  } &bsol;* AddProtoToProtoPruner */
210  uint8_t Bucket8For(float param, float offset, int num_buckets) {
211    int bucket = IntCastRounded(MapParam(param, offset, num_buckets));
212    return static_cast<uint8_t>(ClipToRange<int>(bucket, 0, num_buckets - 1));
213  }
214  uint16_t Bucket16For(float param, float offset, int num_buckets) {
215    int bucket = IntCastRounded(MapParam(param, offset, num_buckets));
216    return static_cast<uint16_t>(ClipToRange<int>(bucket, 0, num_buckets - 1));
217  }
218  uint8_t CircBucketFor(float param, float offset, int num_buckets) {
219    int bucket = IntCastRounded(MapParam(param, offset, num_buckets));
220    return static_cast<uint8_t>(Modulo(bucket, num_buckets));
221  } &bsol;* CircBucketFor */
222  #ifndef GRAPHICS_DISABLED
223  void UpdateMatchDisplay() {
224    if (IntMatchWindow != nullptr) {
225      IntMatchWindow->Update();
226    }
227  } &bsol;* ClearMatchDisplay */
228  #endif
229  void ConvertConfig(BIT_VECTOR Config, int ConfigId, INT_CLASS_STRUCT *Class) {
230    int ProtoId;
231    INT_PROTO_STRUCT *Proto;
232    int TotalLength;
233    for (ProtoId = 0, TotalLength = 0; ProtoId < Class->NumProtos; ProtoId++) {
234      if (test_bit(Config, ProtoId)) {
235        Proto = ProtoForProtoId(Class, ProtoId);
236        SET_BIT(Proto->Configs, ConfigId);
237        TotalLength += Class->ProtoLengths[ProtoId];
238      }
239    }
240    Class->ConfigLengths[ConfigId] = TotalLength;
241  } &bsol;* ConvertConfig */
242  void Classify::ConvertProto(PROTO_STRUCT *Proto, int ProtoId, INT_CLASS_STRUCT *Class) {
243    assert(ProtoId < Class->NumProtos);
244    INT_PROTO_STRUCT *P = ProtoForProtoId(Class, ProtoId);
245    float Param = Proto->A * 128;
246    P->A = TruncateParam(Param, -128, 127);
247    Param = -Proto->B * 256;
248    P->B = TruncateParam(Param, 0, 255);
249    Param = Proto->C * 128;
250    P->C = TruncateParam(Param, -128, 127);
251    Param = Proto->Angle * 256;
252    if (Param < 0 || Param >= 256) {
253      P->Angle = 0;
254    } else {
255      P->Angle = static_cast<uint8_t>(Param);
256    }
257    Param = (Proto->Length / GetPicoFeatureLength()) + 0.5;
258    Class->ProtoLengths[ProtoId] = TruncateParam(Param, 1, 255);
259    if (classify_learning_debug_level >= 2) {
260      tprintf("Converted ffeat to (A=%d,B=%d,C=%d,L=%d)", P->A, P->B, P->C,
261              Class->ProtoLengths[ProtoId]);
262    }
263  } &bsol;* ConvertProto */
264  INT_TEMPLATES_STRUCT *Classify::CreateIntTemplates(CLASSES FloatProtos,
265                                             const UNICHARSET &target_unicharset) {
266    CLASS_TYPE FClass;
267    INT_CLASS_STRUCT *IClass;
268    int ProtoId;
269    int ConfigId;
270    auto IntTemplates = new INT_TEMPLATES_STRUCT;
271    for (unsigned ClassId = 0; ClassId < target_unicharset.size(); ClassId++) {
272      FClass = &(FloatProtos[ClassId]);
273      if (FClass->NumProtos == 0 && FClass->NumConfigs == 0 &&
274          strcmp(target_unicharset.id_to_unichar(ClassId), " ") != 0) {
275        tprintf("Warning: no protos/configs for %s in CreateIntTemplates()\n",
276                target_unicharset.id_to_unichar(ClassId));
277      }
278      assert(UnusedClassIdIn(IntTemplates, ClassId));
279      IClass = new INT_CLASS_STRUCT(FClass->NumProtos, FClass->NumConfigs);
280      unsigned fs_size = FClass->font_set.size();
281      FontSet fs;
282      fs.reserve(fs_size);
283      for (unsigned i = 0; i < fs_size; ++i) {
284        fs.push_back(FClass->font_set[i]);
285      }
286      IClass->font_set_id = this->fontset_table_.push_back(fs);
287      AddIntClass(IntTemplates, ClassId, IClass);
288      for (ProtoId = 0; ProtoId < FClass->NumProtos; ProtoId++) {
289        AddIntProto(IClass);
290        ConvertProto(ProtoIn(FClass, ProtoId), ProtoId, IClass);
291        AddProtoToProtoPruner(ProtoIn(FClass, ProtoId), ProtoId, IClass,
292                              classify_learning_debug_level >= 2);
293        AddProtoToClassPruner(ProtoIn(FClass, ProtoId), ClassId, IntTemplates);
294      }
295      for (ConfigId = 0; ConfigId < FClass->NumConfigs; ConfigId++) {
296        AddIntConfig(IClass);
297        ConvertConfig(FClass->Configurations[ConfigId], ConfigId, IClass);
298      }
299    }
300    return (IntTemplates);
301  } &bsol;* CreateIntTemplates */
302  #ifndef GRAPHICS_DISABLED
303  void DisplayIntFeature(const INT_FEATURE_STRUCT *Feature, float Evidence) {
304    ScrollView::Color color = GetMatchColorFor(Evidence);
305    RenderIntFeature(IntMatchWindow, Feature, color);
306    if (FeatureDisplayWindow) {
307      RenderIntFeature(FeatureDisplayWindow, Feature, color);
308    }
309  } &bsol;* DisplayIntFeature */
310  void DisplayIntProto(INT_CLASS_STRUCT *Class, PROTO_ID ProtoId, float Evidence) {
311    ScrollView::Color color = GetMatchColorFor(Evidence);
312    RenderIntProto(IntMatchWindow, Class, ProtoId, color);
313    if (ProtoDisplayWindow) {
314      RenderIntProto(ProtoDisplayWindow, Class, ProtoId, color);
315    }
316  } &bsol;* DisplayIntProto */
317  #endif
318  INT_CLASS_STRUCT::INT_CLASS_STRUCT(int MaxNumProtos, int MaxNumConfigs) :
319    NumProtos(0),
320    NumProtoSets((MaxNumProtos + PROTOS_PER_PROTO_SET - 1) / PROTOS_PER_PROTO_SET),
321    NumConfigs(0),
322    ProtoLengths(MaxNumIntProtosIn(this))
323  {
324    assert(MaxNumConfigs <= MAX_NUM_CONFIGS);
325    assert(NumProtoSets <= MAX_NUM_PROTO_SETS);
326    for (int i = 0; i < NumProtoSets; i++) {
327      auto ProtoSet = new PROTO_SET_STRUCT;
328      memset(ProtoSet, 0, sizeof(*ProtoSet));
329      ProtoSets[i] = ProtoSet;
330    }
331    memset(ConfigLengths, 0, sizeof(ConfigLengths));
332  }
333  INT_CLASS_STRUCT::~INT_CLASS_STRUCT() {
334    for (int i = 0; i < NumProtoSets; i++) {
335      delete ProtoSets[i];
336    }
337  }
338  INT_TEMPLATES_STRUCT::INT_TEMPLATES_STRUCT() {
339    NumClasses = 0;
340    NumClassPruners = 0;
341    for (int i = 0; i < MAX_NUM_CLASSES; i++) {
342      ClassForClassId(this, i) = nullptr;
343    }
344  }
345  INT_TEMPLATES_STRUCT::~INT_TEMPLATES_STRUCT() {
346    for (unsigned i = 0; i < NumClasses; i++) {
347      delete Class[i];
348    }
349    for (unsigned i = 0; i < NumClassPruners; i++) {
350      delete ClassPruners[i];
351    }
352  }
353  INT_TEMPLATES_STRUCT *Classify::ReadIntTemplates(TFile *fp) {
354    int j, w, x, y, z;
355    INT_TEMPLATES_STRUCT *Templates;
356    CLASS_PRUNER_STRUCT *Pruner;
357    INT_CLASS_STRUCT *Class;
358    int b, bit_number, last_cp_bit_number, new_b, new_i, new_w;
359    CLASS_ID class_id, max_class_id;
360    std::vector<CLASS_ID> ClassIdFor(MAX_NUM_CLASSES);
361    std::vector<CLASS_PRUNER_STRUCT *> TempClassPruner(MAX_NUM_CLASS_PRUNERS);
362    uint32_t SetBitsForMask =          
363        (1 << NUM_BITS_PER_CLASS) - 1; 
364    uint32_t Mask, NewMask, ClassBits;
365    unsigned MaxNumConfigs = MAX_NUM_CONFIGS;
366    unsigned WerdsPerConfigVec = WERDS_PER_CONFIG_VEC;
367    Templates = new INT_TEMPLATES_STRUCT;
368    uint32_t unicharset_size;
369    if (fp->FReadEndian(&unicharset_size, sizeof(unicharset_size), 1) != 1) {
370      tprintf("Bad read of inttemp!\n");
371    }
372    int32_t version_id = 0;
373    if (fp->FReadEndian(&version_id, sizeof(version_id), 1) != 1 ||
374        fp->FReadEndian(&Templates->NumClassPruners, sizeof(Templates->NumClassPruners), 1) != 1) {
375      tprintf("Bad read of inttemp!\n");
376    }
377    if (version_id < 0) {
378      version_id = -version_id;
379      if (fp->FReadEndian(&Templates->NumClasses, sizeof(Templates->NumClasses), 1) != 1) {
380        tprintf("Bad read of inttemp!\n");
381      }
382    } else {
383      Templates->NumClasses = version_id;
384    }
385    if (version_id < 3) {
386      MaxNumConfigs = OLD_MAX_NUM_CONFIGS;
387      WerdsPerConfigVec = OLD_WERDS_PER_CONFIG_VEC;
388    }
389    if (version_id < 2) {
390      std::vector<int16_t> IndexFor(MAX_NUM_CLASSES);
391      if (fp->FReadEndian(&IndexFor[0], sizeof(IndexFor[0]), unicharset_size) != unicharset_size) {
392        tprintf("Bad read of inttemp!\n");
393      }
394      if (fp->FReadEndian(&ClassIdFor[0], sizeof(ClassIdFor[0]), Templates->NumClasses) !=
395          Templates->NumClasses) {
396        tprintf("Bad read of inttemp!\n");
397      }
398    }
399    const unsigned kNumBuckets = NUM_CP_BUCKETS * NUM_CP_BUCKETS * NUM_CP_BUCKETS * WERDS_PER_CP_VECTOR;
400    for (unsigned i = 0; i < Templates->NumClassPruners; i++) {
401      Pruner = new CLASS_PRUNER_STRUCT;
402      if (fp->FReadEndian(Pruner, sizeof(Pruner->p[0][0][0][0]), kNumBuckets) != kNumBuckets) {
403        tprintf("Bad read of inttemp!\n");
404      }
405      if (version_id < 2) {
406        TempClassPruner[i] = Pruner;
407      } else {
408        Templates->ClassPruners[i] = Pruner;
409      }
410    }
411    if (version_id < 2) {
412      max_class_id = 0;
413      for (unsigned i = 0; i < Templates->NumClasses; i++) {
414        if (ClassIdFor[i] > max_class_id) {
415          max_class_id = ClassIdFor[i];
416        }
417      }
418      for (int i = 0; i <= CPrunerIdFor(max_class_id); i++) {
419        Templates->ClassPruners[i] = new CLASS_PRUNER_STRUCT;
420        memset(Templates->ClassPruners[i], 0, sizeof(CLASS_PRUNER_STRUCT));
421      }
422      last_cp_bit_number = NUM_BITS_PER_CLASS * Templates->NumClasses - 1;
423      for (unsigned i = 0; i < Templates->NumClassPruners; i++) {
424        for (x = 0; x < NUM_CP_BUCKETS; x++) {
425          for (y = 0; y < NUM_CP_BUCKETS; y++) {
426            for (z = 0; z < NUM_CP_BUCKETS; z++) {
427              for (w = 0; w < WERDS_PER_CP_VECTOR; w++) {
428                if (TempClassPruner[i]->p[x][y][z][w] == 0) {
429                  continue;
430                }
431                for (b = 0; b < BITS_PER_WERD; b += NUM_BITS_PER_CLASS) {
432                  bit_number = i * BITS_PER_CP_VECTOR + w * BITS_PER_WERD + b;
433                  if (bit_number > last_cp_bit_number) {
434                    break; 
435                  }
436                  class_id = ClassIdFor[bit_number / NUM_BITS_PER_CLASS];
437                  Mask = SetBitsForMask << b;
438                  ClassBits = TempClassPruner[i]->p[x][y][z][w] & Mask;
439                  new_i = CPrunerIdFor(class_id);
440                  new_w = CPrunerWordIndexFor(class_id);
441                  new_b = CPrunerBitIndexFor(class_id) * NUM_BITS_PER_CLASS;
442                  if (new_b > b) {
443                    ClassBits <<= (new_b - b);
444                  } else {
445                    ClassBits >>= (b - new_b);
446                  }
447                  NewMask = SetBitsForMask << new_b;
448                  Templates->ClassPruners[new_i]->p[x][y][z][new_w] &= ~NewMask;
449                  Templates->ClassPruners[new_i]->p[x][y][z][new_w] |= ClassBits;
450                }
451              }
452            }
453          }
454        }
455      }
456      for (unsigned i = 0; i < Templates->NumClassPruners; i++) {
457        delete TempClassPruner[i];
458      }
459    }
460    for (unsigned i = 0; i < Templates->NumClasses; i++) {
461      Class = new INT_CLASS_STRUCT;
462      if (fp->FReadEndian(&Class->NumProtos, sizeof(Class->NumProtos), 1) != 1 ||
463          fp->FRead(&Class->NumProtoSets, sizeof(Class->NumProtoSets), 1) != 1 ||
464          fp->FRead(&Class->NumConfigs, sizeof(Class->NumConfigs), 1) != 1) {
465        tprintf("Bad read of inttemp!\n");
466      }
467      if (version_id == 0) {
468        for (j = 0; j < 5; ++j) {
469          int32_t junk;
470          if (fp->FRead(&junk, sizeof(junk), 1) != 1) {
471            tprintf("Bad read of inttemp!\n");
472          }
473        }
474      }
475      unsigned num_configs = version_id < 4 ? MaxNumConfigs : Class->NumConfigs;
476      ASSERT_HOST(num_configs <= MaxNumConfigs);
477      if (fp->FReadEndian(Class->ConfigLengths, sizeof(uint16_t), num_configs) != num_configs) {
478        tprintf("Bad read of inttemp!\n");
479      }
480      if (version_id < 2) {
481        ClassForClassId(Templates, ClassIdFor[i]) = Class;
482      } else {
483        ClassForClassId(Templates, i) = Class;
484      }
485      Class->ProtoLengths.clear();
486      if (MaxNumIntProtosIn(Class) > 0) {
487        Class->ProtoLengths.resize(MaxNumIntProtosIn(Class));
488        if (fp->FRead(&Class->ProtoLengths[0], sizeof(uint8_t), MaxNumIntProtosIn(Class)) !=
489            MaxNumIntProtosIn(Class)) {
490          tprintf("Bad read of inttemp!\n");
491        }
492      }
493      for (j = 0; j < Class->NumProtoSets; j++) {
494        auto ProtoSet = new PROTO_SET_STRUCT;
495        unsigned num_buckets = NUM_PP_PARAMS * NUM_PP_BUCKETS * WERDS_PER_PP_VECTOR;
496        if (fp->FReadEndian(&ProtoSet->ProtoPruner, sizeof(ProtoSet->ProtoPruner[0][0][0]),
497                            num_buckets) != num_buckets) {
498          tprintf("Bad read of inttemp!\n");
499        }
500        for (x = 0; x < PROTOS_PER_PROTO_SET; x++) {
501          if (fp->FRead(&ProtoSet->Protos[x].A, sizeof(ProtoSet->Protos[x].A), 1) != 1 ||
502              fp->FRead(&ProtoSet->Protos[x].B, sizeof(ProtoSet->Protos[x].B), 1) != 1 ||
503              fp->FRead(&ProtoSet->Protos[x].C, sizeof(ProtoSet->Protos[x].C), 1) != 1 ||
504              fp->FRead(&ProtoSet->Protos[x].Angle, sizeof(ProtoSet->Protos[x].Angle), 1) != 1) {
505            tprintf("Bad read of inttemp!\n");
506          }
507          if (fp->FReadEndian(&ProtoSet->Protos[x].Configs, sizeof(ProtoSet->Protos[x].Configs[0]),
508                              WerdsPerConfigVec) != WerdsPerConfigVec) {
509            tprintf("Bad read of inttemp!\n");
510          }
511        }
512        Class->ProtoSets[j] = ProtoSet;
513      }
514      if (version_id < 4) {
515        Class->font_set_id = -1;
516      } else {
517        fp->FReadEndian(&Class->font_set_id, sizeof(Class->font_set_id), 1);
518      }
519    }
520    if (version_id < 2) {
521      assert(UnusedClassIdIn(Templates, 0));
522      ClassForClassId(Templates, 0) = new INT_CLASS_STRUCT(1, 1);
523      ClassForClassId(Templates, 0)->font_set_id = -1;
524      Templates->NumClasses++;
525      for (unsigned i = 0; i < MAX_NUM_CLASSES; i++) {
526        if (i < Templates->NumClasses) {
527          if (ClassForClassId(Templates, i) == nullptr) {
528            fprintf(stderr, "Non-contiguous class ids in inttemp\n");
529            exit(1);
530          }
531        } else {
532          if (ClassForClassId(Templates, i) != nullptr) {
533            fprintf(stderr, "Class id %u exceeds NumClassesIn (Templates) %u\n", i,
534                    Templates->NumClasses);
535            exit(1);
536          }
537        }
538      }
539    }
540    if (version_id >= 4) {
541      using namespace std::placeholders; 
542      this->fontinfo_table_.read(fp, std::bind(read_info, _1, _2));
543      if (version_id >= 5) {
544        this->fontinfo_table_.read(fp, std::bind(read_spacing_info, _1, _2));
545      }
546      this->fontset_table_.read(fp, [](auto *f, auto *fs) { return f->DeSerialize(*fs); } );
547    }
548    return (Templates);
549  } &bsol;* ReadIntTemplates */
550  #ifndef GRAPHICS_DISABLED
551  void Classify::ShowMatchDisplay() {
552    InitIntMatchWindowIfReqd();
553    if (ProtoDisplayWindow) {
554      ProtoDisplayWindow->Clear();
555    }
556    if (FeatureDisplayWindow) {
557      FeatureDisplayWindow->Clear();
558    }
559    ClearFeatureSpaceWindow(static_cast<NORM_METHOD>(static_cast<int>(classify_norm_method)),
560                            IntMatchWindow);
561    IntMatchWindow->ZoomToRectangle(INT_MIN_X, INT_MIN_Y, INT_MAX_X, INT_MAX_Y);
562    if (ProtoDisplayWindow) {
563      ProtoDisplayWindow->ZoomToRectangle(INT_MIN_X, INT_MIN_Y, INT_MAX_X, INT_MAX_Y);
564    }
565    if (FeatureDisplayWindow) {
566      FeatureDisplayWindow->ZoomToRectangle(INT_MIN_X, INT_MIN_Y, INT_MAX_X, INT_MAX_Y);
567    }
568  } &bsol;* ShowMatchDisplay */
569  void ClearFeatureSpaceWindow(NORM_METHOD norm_method, ScrollView *window) {
570    window->Clear();
571    window->Pen(ScrollView::GREY);
572    window->Rectangle(0, 0, INT_MAX_X, INT_MAX_Y);
573    if (norm_method == baseline) {
574      window->SetCursor(0, INT_DESCENDER);
575      window->DrawTo(INT_MAX_X, INT_DESCENDER);
576      window->SetCursor(0, INT_BASELINE);
577      window->DrawTo(INT_MAX_X, INT_BASELINE);
578      window->SetCursor(0, INT_XHEIGHT);
579      window->DrawTo(INT_MAX_X, INT_XHEIGHT);
580      window->SetCursor(0, INT_CAPHEIGHT);
581      window->DrawTo(INT_MAX_X, INT_CAPHEIGHT);
582    } else {
583      window->Rectangle(INT_XCENTER - INT_XRADIUS, INT_YCENTER - INT_YRADIUS,
584                        INT_XCENTER + INT_XRADIUS, INT_YCENTER + INT_YRADIUS);
585    }
586  }
587  #endif
588  void Classify::WriteIntTemplates(FILE *File, INT_TEMPLATES_STRUCT *Templates,
589                                   const UNICHARSET &target_unicharset) {
590    INT_CLASS_STRUCT *Class;
591    uint32_t unicharset_size = target_unicharset.size();
592    int version_id = -5; 
593    if (Templates->NumClasses != unicharset_size) {
594      tprintf(
595          "Warning: executing WriteIntTemplates() with %d classes in"
596          " Templates, while target_unicharset size is %" PRIu32 "\n",
597          Templates->NumClasses, unicharset_size);
598    }
599    fwrite(&unicharset_size, sizeof(unicharset_size), 1, File);
600    fwrite(&version_id, sizeof(version_id), 1, File);
601    fwrite(&Templates->NumClassPruners, sizeof(Templates->NumClassPruners), 1, File);
602    fwrite(&Templates->NumClasses, sizeof(Templates->NumClasses), 1, File);
603    for (unsigned i = 0; i < Templates->NumClassPruners; i++) {
604      fwrite(Templates->ClassPruners[i], sizeof(CLASS_PRUNER_STRUCT), 1, File);
605    }
606    for (unsigned i = 0; i < Templates->NumClasses; i++) {
607      Class = Templates->Class[i];
608      fwrite(&Class->NumProtos, sizeof(Class->NumProtos), 1, File);
609      fwrite(&Class->NumProtoSets, sizeof(Class->NumProtoSets), 1, File);
610      ASSERT_HOST(Class->NumConfigs == this->fontset_table_.at(Class->font_set_id).size());
611      fwrite(&Class->NumConfigs, sizeof(Class->NumConfigs), 1, File);
612      for (int j = 0; j < Class->NumConfigs; ++j) {
613        fwrite(&Class->ConfigLengths[j], sizeof(uint16_t), 1, File);
614      }
615      if (MaxNumIntProtosIn(Class) > 0) {
616        fwrite(&Class->ProtoLengths[0], sizeof(uint8_t), MaxNumIntProtosIn(Class), File);
617      }
618      for (int j = 0; j < Class->NumProtoSets; j++) {
619        fwrite(Class->ProtoSets[j], sizeof(PROTO_SET_STRUCT), 1, File);
620      }
621      fwrite(&Class->font_set_id, sizeof(int), 1, File);
622    }
623    using namespace std::placeholders; 
624    this->fontinfo_table_.write(File, std::bind(write_info, _1, _2));
625    this->fontinfo_table_.write(File, std::bind(write_spacing_info, _1, _2));
626    this->fontset_table_.write(File, std::bind(write_set, _1, _2));
627  } &bsol;* WriteIntTemplates */
628  float BucketStart(int Bucket, float Offset, int NumBuckets) {
629    return static_cast<float>(Bucket) / NumBuckets - Offset;
630  } &bsol;* BucketStart */
631  float BucketEnd(int Bucket, float Offset, int NumBuckets) {
632    return static_cast<float>(Bucket + 1) / NumBuckets - Offset;
633  } &bsol;* BucketEnd */
634  void DoFill(FILL_SPEC *FillSpec, CLASS_PRUNER_STRUCT *Pruner, uint32_t ClassMask,
635              uint32_t ClassCount, uint32_t WordIndex) {
636    int X, Y, Angle;
637    uint32_t OldWord;
638    X = FillSpec->X;
639    if (X < 0) {
640      X = 0;
641    }
642    if (X >= NUM_CP_BUCKETS) {
643      X = NUM_CP_BUCKETS - 1;
644    }
645    if (FillSpec->YStart < 0) {
646      FillSpec->YStart = 0;
647    }
648    if (FillSpec->YEnd >= NUM_CP_BUCKETS) {
649      FillSpec->YEnd = NUM_CP_BUCKETS - 1;
650    }
651    for (Y = FillSpec->YStart; Y <= FillSpec->YEnd; Y++) {
652      for (Angle = FillSpec->AngleStart;; CircularIncrement(Angle, NUM_CP_BUCKETS)) {
653        OldWord = Pruner->p[X][Y][Angle][WordIndex];
654        if (ClassCount > (OldWord & ClassMask)) {
655          OldWord &= ~ClassMask;
656          OldWord |= ClassCount;
657          Pruner->p[X][Y][Angle][WordIndex] = OldWord;
658        }
659        if (Angle == FillSpec->AngleEnd) {
660          break;
661        }
662      }
663    }
664  } &bsol;* DoFill */
665  bool FillerDone(TABLE_FILLER *Filler) {
666    FILL_SWITCH *Next;
667    Next = &(Filler->Switch[Filler->NextSwitch]);
668    return Filler->X > Next->X && Next->Type == LastSwitch;
669  } &bsol;* FillerDone */
670  void FillPPCircularBits(uint32_t ParamTable[NUM_PP_BUCKETS][WERDS_PER_PP_VECTOR], int Bit,
671                          float Center, float Spread, bool debug) {
672    int i, FirstBucket, LastBucket;
673    if (Spread > 0.5) {
674      Spread = 0.5;
675    }
676    FirstBucket = static_cast<int>(std::floor((Center - Spread) * NUM_PP_BUCKETS));
677    if (FirstBucket < 0) {
678      FirstBucket += NUM_PP_BUCKETS;
679    }
680    LastBucket = static_cast<int>(std::floor((Center + Spread) * NUM_PP_BUCKETS));
681    if (LastBucket >= NUM_PP_BUCKETS) {
682      LastBucket -= NUM_PP_BUCKETS;
683    }
684    if (debug) {
685      tprintf("Circular fill from %d to %d", FirstBucket, LastBucket);
686    }
687    for (i = FirstBucket; true; CircularIncrement(i, NUM_PP_BUCKETS)) {
688      SET_BIT(ParamTable[i], Bit);
689      if (i == LastBucket) {
690        break;
691      }
692    }
693  } &bsol;* FillPPCircularBits */
694  void FillPPLinearBits(uint32_t ParamTable[NUM_PP_BUCKETS][WERDS_PER_PP_VECTOR], int Bit,
695                        float Center, float Spread, bool debug) {
696    int i, FirstBucket, LastBucket;
697    FirstBucket = static_cast<int>(std::floor((Center - Spread) * NUM_PP_BUCKETS));
698    if (FirstBucket < 0) {
699      FirstBucket = 0;
700    }
701    LastBucket = static_cast<int>(std::floor((Center + Spread) * NUM_PP_BUCKETS));
702    if (LastBucket >= NUM_PP_BUCKETS) {
703      LastBucket = NUM_PP_BUCKETS - 1;
704    }
705    if (debug) {
706      tprintf("Linear fill from %d to %d", FirstBucket, LastBucket);
707    }
708    for (i = FirstBucket; i <= LastBucket; i++) {
709      SET_BIT(ParamTable[i], Bit);
710    }
711  } &bsol;* FillPPLinearBits */
712  #ifndef GRAPHICS_DISABLED
713  CLASS_ID Classify::GetClassToDebug(const char *Prompt, bool *adaptive_on, bool *pretrained_on,
714                                     int *shape_id) {
715    tprintf("%s\n", Prompt);
716    SVEventType ev_type;
717    int unichar_id = INVALID_UNICHAR_ID;
718    do {
719      auto ev = IntMatchWindow->AwaitEvent(SVET_ANY);
720      ev_type = ev->type;
721      if (ev_type == SVET_POPUP) {
722        if (ev->command_id == IDA_SHAPE_INDEX) {
723          if (shape_table_ != nullptr) {
724            *shape_id = atoi(ev->parameter);
725            *adaptive_on = false;
726            *pretrained_on = true;
727            if (*shape_id >= 0 && static_cast<unsigned>(*shape_id) < shape_table_->NumShapes()) {
728              int font_id;
729              shape_table_->GetFirstUnicharAndFont(*shape_id, &unichar_id, &font_id);
730              tprintf("Shape %d, first unichar=%d, font=%d\n", *shape_id, unichar_id, font_id);
731              return unichar_id;
732            }
733            tprintf("Shape index '%s' not found in shape table\n", ev->parameter);
734          } else {
735            tprintf("No shape table loaded!\n");
736          }
737        } else {
738          if (unicharset.contains_unichar(ev->parameter)) {
739            unichar_id = unicharset.unichar_to_id(ev->parameter);
740            if (ev->command_id == IDA_ADAPTIVE) {
741              *adaptive_on = true;
742              *pretrained_on = false;
743              *shape_id = -1;
744            } else if (ev->command_id == IDA_STATIC) {
745              *adaptive_on = false;
746              *pretrained_on = true;
747            } else {
748              *adaptive_on = true;
749              *pretrained_on = true;
750            }
751            if (ev->command_id == IDA_ADAPTIVE || shape_table_ == nullptr) {
752              *shape_id = -1;
753              return unichar_id;
754            }
755            for (unsigned s = 0; s < shape_table_->NumShapes(); ++s) {
756              if (shape_table_->GetShape(s).ContainsUnichar(unichar_id)) {
757                tprintf("%s\n", shape_table_->DebugStr(s).c_str());
758              }
759            }
760          } else {
761            tprintf("Char class '%s' not found in unicharset", ev->parameter);
762          }
763        }
764      }
765    } while (ev_type != SVET_CLICK);
766    return 0;
767  } &bsol;* GetClassToDebug */
768  #endif
769  void GetCPPadsForLevel(int Level, float *EndPad, float *SidePad, float *AnglePad) {
770    switch (Level) {
771      case 0:
772        *EndPad = classify_cp_end_pad_loose * GetPicoFeatureLength();
773        *SidePad = classify_cp_side_pad_loose * GetPicoFeatureLength();
774        *AnglePad = classify_cp_angle_pad_loose / 360.0;
775        break;
776      case 1:
777        *EndPad = classify_cp_end_pad_medium * GetPicoFeatureLength();
778        *SidePad = classify_cp_side_pad_medium * GetPicoFeatureLength();
779        *AnglePad = classify_cp_angle_pad_medium / 360.0;
780        break;
781      case 2:
782        *EndPad = classify_cp_end_pad_tight * GetPicoFeatureLength();
783        *SidePad = classify_cp_side_pad_tight * GetPicoFeatureLength();
784        *AnglePad = classify_cp_angle_pad_tight / 360.0;
785        break;
786      default:
787        *EndPad = classify_cp_end_pad_tight * GetPicoFeatureLength();
788        *SidePad = classify_cp_side_pad_tight * GetPicoFeatureLength();
789        *AnglePad = classify_cp_angle_pad_tight / 360.0;
790        break;
791    }
792    if (*AnglePad > 0.5) {
793      *AnglePad = 0.5;
794    }
795  } &bsol;* GetCPPadsForLevel */
796  ScrollView::Color GetMatchColorFor(float Evidence) {
797    assert(Evidence >= 0.0);
798    assert(Evidence <= 1.0);
799    if (Evidence >= 0.90) {
800      return ScrollView::WHITE;
801    } else if (Evidence >= 0.75) {
802      return ScrollView::GREEN;
803    } else if (Evidence >= 0.50) {
804      return ScrollView::RED;
805    } else {
806      return ScrollView::BLUE;
807    }
808  } &bsol;* GetMatchColorFor */
809  void GetNextFill(TABLE_FILLER *Filler, FILL_SPEC *Fill) {
810    FILL_SWITCH *Next;
811    Fill->AngleStart = Filler->AngleStart;
812    Fill->AngleEnd = Filler->AngleEnd;
813    Fill->X = Filler->X;
814    Fill->YStart = Filler->YStart >> 8;
815    Fill->YEnd = Filler->YEnd >> 8;
816    Next = &(Filler->Switch[Filler->NextSwitch]);
817    while (Filler->X >= Next->X) {
818      Fill->X = Filler->X = Next->X;
819      if (Next->Type == StartSwitch) {
820        Fill->YStart = Next->Y;
821        Filler->StartDelta = Next->Delta;
822        Filler->YStart = Next->YInit;
823      } else if (Next->Type == EndSwitch) {
824        Fill->YEnd = Next->Y;
825        Filler->EndDelta = Next->Delta;
826        Filler->YEnd = Next->YInit;
827      } else { &bsol;* Type must be LastSwitch */
828        break;
829      }
830      Filler->NextSwitch++;
831      Next = &(Filler->Switch[Filler->NextSwitch]);
832    }
833    Filler->X++;
834    Filler->YStart += Filler->StartDelta;
835    Filler->YEnd += Filler->EndDelta;
836  } &bsol;* GetNextFill */
837  void InitTableFiller(float EndPad, float SidePad, float AnglePad, PROTO_STRUCT *Proto, TABLE_FILLER *Filler)
838  #define XS X_SHIFT
839  #define YS Y_SHIFT
840  #define AS ANGLE_SHIFT
841  #define NB NUM_CP_BUCKETS
842  {
843    float Angle;
844    float X, Y, HalfLength;
845    float Cos, Sin;
846    float XAdjust, YAdjust;
847    FPOINT Start, Switch1, Switch2, End;
848    int S1 = 0;
849    int S2 = 1;
850    Angle = Proto->Angle;
851    X = Proto->X;
852    Y = Proto->Y;
853    HalfLength = Proto->Length / 2.0;
854    Filler->AngleStart = CircBucketFor(Angle - AnglePad, AS, NB);
855    Filler->AngleEnd = CircBucketFor(Angle + AnglePad, AS, NB);
856    Filler->NextSwitch = 0;
857    if (fabs(Angle - 0.0) < HV_TOLERANCE || fabs(Angle - 0.5) < HV_TOLERANCE) {
858      Filler->X = Bucket8For(X - HalfLength - EndPad, XS, NB);
859      Filler->YStart = Bucket16For(Y - SidePad, YS, NB * 256);
860      Filler->YEnd = Bucket16For(Y + SidePad, YS, NB * 256);
861      Filler->StartDelta = 0;
862      Filler->EndDelta = 0;
863      Filler->Switch[0].Type = LastSwitch;
864      Filler->Switch[0].X = Bucket8For(X + HalfLength + EndPad, XS, NB);
865    } else if (fabs(Angle - 0.25) < HV_TOLERANCE || fabs(Angle - 0.75) < HV_TOLERANCE) {
866      Filler->X = Bucket8For(X - SidePad, XS, NB);
867      Filler->YStart = Bucket16For(Y - HalfLength - EndPad, YS, NB * 256);
868      Filler->YEnd = Bucket16For(Y + HalfLength + EndPad, YS, NB * 256);
869      Filler->StartDelta = 0;
870      Filler->EndDelta = 0;
871      Filler->Switch[0].Type = LastSwitch;
872      Filler->Switch[0].X = Bucket8For(X + SidePad, XS, NB);
873    } else {
874      if ((Angle > 0.0 && Angle < 0.25) || (Angle > 0.5 && Angle < 0.75)) {
875        Angle *= 2.0 * M_PI;
876        Cos = fabs(std::cos(Angle));
877        Sin = fabs(std::sin(Angle));
878        Start.x = X - (HalfLength + EndPad) * Cos - SidePad * Sin;
879        Start.y = Y - (HalfLength + EndPad) * Sin + SidePad * Cos;
880        End.x = 2.0 * X - Start.x;
881        End.y = 2.0 * Y - Start.y;
882        Switch1.x = X - (HalfLength + EndPad) * Cos + SidePad * Sin;
883        Switch1.y = Y - (HalfLength + EndPad) * Sin - SidePad * Cos;
884        Switch2.x = 2.0 * X - Switch1.x;
885        Switch2.y = 2.0 * Y - Switch1.y;
886        if (Switch1.x > Switch2.x) {
887          S1 = 1;
888          S2 = 0;
889        }
890        Filler->X = Bucket8For(Start.x, XS, NB);
891        Filler->StartDelta = -static_cast<int16_t>((Cos / Sin) * 256);
892        Filler->EndDelta = static_cast<int16_t>((Sin / Cos) * 256);
893        XAdjust = BucketEnd(Filler->X, XS, NB) - Start.x;
894        YAdjust = XAdjust * Cos / Sin;
895        Filler->YStart = Bucket16For(Start.y - YAdjust, YS, NB * 256);
896        YAdjust = XAdjust * Sin / Cos;
897        Filler->YEnd = Bucket16For(Start.y + YAdjust, YS, NB * 256);
898        Filler->Switch[S1].Type = StartSwitch;
899        Filler->Switch[S1].X = Bucket8For(Switch1.x, XS, NB);
900        Filler->Switch[S1].Y = Bucket8For(Switch1.y, YS, NB);
901        XAdjust = Switch1.x - BucketStart(Filler->Switch[S1].X, XS, NB);
902        YAdjust = XAdjust * Sin / Cos;
903        Filler->Switch[S1].YInit = Bucket16For(Switch1.y - YAdjust, YS, NB * 256);
904        Filler->Switch[S1].Delta = Filler->EndDelta;
905        Filler->Switch[S2].Type = EndSwitch;
906        Filler->Switch[S2].X = Bucket8For(Switch2.x, XS, NB);
907        Filler->Switch[S2].Y = Bucket8For(Switch2.y, YS, NB);
908        XAdjust = Switch2.x - BucketStart(Filler->Switch[S2].X, XS, NB);
909        YAdjust = XAdjust * Cos / Sin;
910        Filler->Switch[S2].YInit = Bucket16For(Switch2.y + YAdjust, YS, NB * 256);
911        Filler->Switch[S2].Delta = Filler->StartDelta;
912        Filler->Switch[2].Type = LastSwitch;
913        Filler->Switch[2].X = Bucket8For(End.x, XS, NB);
914      } else {
915        Angle *= 2.0 * M_PI;
916        Cos = fabs(std::cos(Angle));
917        Sin = fabs(std::sin(Angle));
918        Start.x = X - (HalfLength + EndPad) * Cos - SidePad * Sin;
919        Start.y = Y + (HalfLength + EndPad) * Sin - SidePad * Cos;
920        End.x = 2.0 * X - Start.x;
921        End.y = 2.0 * Y - Start.y;
922        Switch1.x = X - (HalfLength + EndPad) * Cos + SidePad * Sin;
923        Switch1.y = Y + (HalfLength + EndPad) * Sin + SidePad * Cos;
924        Switch2.x = 2.0 * X - Switch1.x;
925        Switch2.y = 2.0 * Y - Switch1.y;
926        if (Switch1.x > Switch2.x) {
927          S1 = 1;
928          S2 = 0;
929        }
930        Filler->X = Bucket8For(Start.x, XS, NB);
931        Filler->StartDelta = static_cast<int16_t>(
932            ClipToRange<int>(-IntCastRounded((Sin / Cos) * 256), INT16_MIN, INT16_MAX));
933        Filler->EndDelta = static_cast<int16_t>(
934            ClipToRange<int>(IntCastRounded((Cos / Sin) * 256), INT16_MIN, INT16_MAX));
935        XAdjust = BucketEnd(Filler->X, XS, NB) - Start.x;
936        YAdjust = XAdjust * Sin / Cos;
937        Filler->YStart = Bucket16For(Start.y - YAdjust, YS, NB * 256);
938        YAdjust = XAdjust * Cos / Sin;
939        Filler->YEnd = Bucket16For(Start.y + YAdjust, YS, NB * 256);
940        Filler->Switch[S1].Type = EndSwitch;
941        Filler->Switch[S1].X = Bucket8For(Switch1.x, XS, NB);
942        Filler->Switch[S1].Y = Bucket8For(Switch1.y, YS, NB);
943        XAdjust = Switch1.x - BucketStart(Filler->Switch[S1].X, XS, NB);
944        YAdjust = XAdjust * Sin / Cos;
945        Filler->Switch[S1].YInit = Bucket16For(Switch1.y + YAdjust, YS, NB * 256);
946        Filler->Switch[S1].Delta = Filler->StartDelta;
947        Filler->Switch[S2].Type = StartSwitch;
948        Filler->Switch[S2].X = Bucket8For(Switch2.x, XS, NB);
949        Filler->Switch[S2].Y = Bucket8For(Switch2.y, YS, NB);
950        XAdjust = Switch2.x - BucketStart(Filler->Switch[S2].X, XS, NB);
951        YAdjust = XAdjust * Cos / Sin;
952        Filler->Switch[S2].YInit = Bucket16For(Switch2.y - YAdjust, YS, NB * 256);
953        Filler->Switch[S2].Delta = Filler->EndDelta;
954        Filler->Switch[2].Type = LastSwitch;
955        Filler->Switch[2].X = Bucket8For(End.x, XS, NB);
956      }
957    }
958  } &bsol;* InitTableFiller */
959  #ifndef GRAPHICS_DISABLED
960  void RenderIntFeature(ScrollView *window, const INT_FEATURE_STRUCT *Feature,
961                        ScrollView::Color color) {
962    float X, Y, Dx, Dy, Length;
963    window->Pen(color);
<span onclick='openModal()' class='match'>964    assert(Feature != nullptr);
965    assert(color != 0);
966    X = Feature->X;
</span>967    Y = Feature->Y;
968    Length = GetPicoFeatureLength() * 0.7 * INT_CHAR_NORM_RANGE;
969    Dx = (Length / 2.0) * cos((Feature->Theta / 256.0) * 2.0 * M_PI - M_PI);
970    Dy = (Length / 2.0) * sin((Feature->Theta / 256.0) * 2.0 * M_PI - M_PI);
971    window->SetCursor(X, Y);
972    window->DrawTo(X + Dx, Y + Dy);
973  } &bsol;* RenderIntFeature */
974  void RenderIntProto(ScrollView *window, INT_CLASS_STRUCT *Class, PROTO_ID ProtoId,
975                      ScrollView::Color color) {
976    INT_PROTO_STRUCT *Proto;
977    int ProtoSetIndex;
978    int ProtoWordIndex;
979    float Length;
980    int Xmin, Xmax, Ymin, Ymax;
981    float X, Y, Dx, Dy;
982    uint32_t ProtoMask;
983    int Bucket;
984    assert(ProtoId >= 0);
985    assert(Class != nullptr);
986    assert(ProtoId < Class->NumProtos);
987    assert(color != 0);
988    window->Pen(color);
989    auto ProtoSet = Class->ProtoSets[SetForProto(ProtoId)];
990    ProtoSetIndex = IndexForProto(ProtoId);
991    Proto = &(ProtoSet->Protos[ProtoSetIndex]);
992    Length = (Class->ProtoLengths[ProtoId] * GetPicoFeatureLength() * INT_CHAR_NORM_RANGE);
993    ProtoMask = PPrunerMaskFor(ProtoId);
994    ProtoWordIndex = PPrunerWordIndexFor(ProtoId);
995    Xmin = Ymin = NUM_PP_BUCKETS;
996    Xmax = Ymax = 0;
997    for (Bucket = 0; Bucket < NUM_PP_BUCKETS; Bucket++) {
998      if (ProtoMask & ProtoSet->ProtoPruner[PRUNER_X][Bucket][ProtoWordIndex]) {
999        UpdateRange(Bucket, &Xmin, &Xmax);
1000      }
1001      if (ProtoMask & ProtoSet->ProtoPruner[PRUNER_Y][Bucket][ProtoWordIndex]) {
1002        UpdateRange(Bucket, &Ymin, &Ymax);
1003      }
1004    }
1005    X = (Xmin + Xmax + 1) / 2.0 * PROTO_PRUNER_SCALE;
1006    Y = (Ymin + Ymax + 1) / 2.0 * PROTO_PRUNER_SCALE;
1007    Dx = (Length / 2.0) * cos((Proto->Angle / 256.0) * 2.0 * M_PI - M_PI);
1008    Dy = (Length / 2.0) * sin((Proto->Angle / 256.0) * 2.0 * M_PI - M_PI);
1009    window->SetCursor(X - Dx, Y - Dy);
1010    window->DrawTo(X + Dx, Y + Dy);
1011  } &bsol;* RenderIntProto */
1012  #endif
1013  #ifndef GRAPHICS_DISABLED
1014  void InitIntMatchWindowIfReqd() {
1015    if (IntMatchWindow == nullptr) {
1016      IntMatchWindow = CreateFeatureSpaceWindow("IntMatchWindow", 50, 200);
1017      auto *popup_menu = new SVMenuNode();
1018      popup_menu->AddChild("Debug Adapted classes", IDA_ADAPTIVE, "x", "Class to debug");
1019      popup_menu->AddChild("Debug Static classes", IDA_STATIC, "x", "Class to debug");
1020      popup_menu->AddChild("Debug Both", IDA_BOTH, "x", "Class to debug");
1021      popup_menu->AddChild("Debug Shape Index", IDA_SHAPE_INDEX, "0", "Index to debug");
1022      popup_menu->BuildMenu(IntMatchWindow, false);
1023    }
1024  }
1025  void InitProtoDisplayWindowIfReqd() {
1026    if (ProtoDisplayWindow == nullptr) {
1027      ProtoDisplayWindow = CreateFeatureSpaceWindow("ProtoDisplayWindow", 550, 200);
1028    }
1029  }
1030  void InitFeatureDisplayWindowIfReqd() {
1031    if (FeatureDisplayWindow == nullptr) {
1032      FeatureDisplayWindow = CreateFeatureSpaceWindow("FeatureDisplayWindow", 50, 700);
1033    }
1034  }
1035  ScrollView *CreateFeatureSpaceWindow(const char *name, int xpos, int ypos) {
1036    return new ScrollView(name, xpos, ypos, 520, 520, 260, 260, true);
1037  }
1038  #endif 
1039  } 
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cord_internal.h</h3>
            <pre><code>1  #ifndef ABSL_STRINGS_INTERNAL_CORD_INTERNAL_H_
2  #define ABSL_STRINGS_INTERNAL_CORD_INTERNAL_H_
3  #include <atomic>
4  #include <cassert>
5  #include <cstddef>
6  #include <cstdint>
7  #include <type_traits>
8  #include "absl/base/attributes.h"
9  #include "absl/base/config.h"
10  #include "absl/base/internal/endian.h"
11  #include "absl/base/internal/invoke.h"
12  #include "absl/base/optimization.h"
13  #include "absl/container/internal/compressed_tuple.h"
14  #include "absl/container/internal/container_memory.h"
15  #include "absl/meta/type_traits.h"
16  #include "absl/strings/string_view.h"
17  #if defined(ABSL_HAVE_CONSTANT_EVALUATED) && \
18      (defined(ABSL_HAVE_ADDRESS_SANITIZER) || \
19       defined(ABSL_HAVE_MEMORY_SANITIZER))
20  #define ABSL_INTERNAL_CORD_HAVE_SANITIZER 1
21  #endif
22  #define ABSL_CORD_INTERNAL_NO_SANITIZE \
23    ABSL_ATTRIBUTE_NO_SANITIZE_ADDRESS ABSL_ATTRIBUTE_NO_SANITIZE_MEMORY
24  namespace absl {
25  ABSL_NAMESPACE_BEGIN
26  namespace cord_internal {
27  struct CordRep;
28  struct CordRepConcat;
29  struct CordRepExternal;
30  struct CordRepFlat;
31  struct CordRepSubstring;
32  struct CordRepCrc;
33  class CordRepRing;
34  class CordRepBtree;
35  class CordzInfo;
36  enum CordFeatureDefaults {
37    kCordEnableRingBufferDefault = false,
38    kCordShallowSubcordsDefault = false
39  };
40  extern std::atomic<bool> cord_ring_buffer_enabled;
41  extern std::atomic<bool> shallow_subcords_enabled;
42  inline void enable_cord_ring_buffer(bool enable) {
43    cord_ring_buffer_enabled.store(enable, std::memory_order_relaxed);
44  }
45  inline void enable_shallow_subcords(bool enable) {
46    shallow_subcords_enabled.store(enable, std::memory_order_relaxed);
47  }
48  enum Constants {
49    kInlinedVectorSize = 47,
50    kMaxBytesToCopy = 511
51  };
52  ABSL_ATTRIBUTE_NORETURN void LogFatalNodeType(CordRep* rep);
53  template <bool nullify_tail = false>
54  inline void SmallMemmove(char* dst, const char* src, size_t n) {
55    if (n >= 8) {
56      assert(n <= 15);
57      uint64_t buf1;
58      uint64_t buf2;
59      memcpy(&buf1, src, 8);
60      memcpy(&buf2, src + n - 8, 8);
61      if (nullify_tail) {
62        memset(dst + 7, 0, 8);
63      }
64      memcpy(dst, &buf1, 8);
65      memcpy(dst + n - 8, &buf2, 8);
66    } else if (n >= 4) {
67      uint32_t buf1;
68      uint32_t buf2;
69      memcpy(&buf1, src, 4);
70      memcpy(&buf2, src + n - 4, 4);
71      if (nullify_tail) {
72        memset(dst + 4, 0, 4);
73        memset(dst + 7, 0, 8);
74      }
75      memcpy(dst, &buf1, 4);
76      memcpy(dst + n - 4, &buf2, 4);
77    } else {
78      if (n != 0) {
79        dst[0] = src[0];
80        dst[n / 2] = src[n / 2];
81        dst[n - 1] = src[n - 1];
82      }
83      if (nullify_tail) {
84        memset(dst + 7, 0, 8);
85        memset(dst + n, 0, 8);
86      }
87    }
88  }
89  class RefcountAndFlags {
90   public:
91    constexpr RefcountAndFlags() : count_{kRefIncrement} {}
92    struct Immortal {};
93    explicit constexpr RefcountAndFlags(Immortal) : count_(kImmortalFlag) {}
94    inline void Increment() {
95      count_.fetch_add(kRefIncrement, std::memory_order_relaxed);
96    }
97    inline bool Decrement() {
98      int32_t refcount = count_.load(std::memory_order_acquire);
99      assert((refcount & kRefcountMask) > 0 || refcount & kImmortalFlag);
100      return refcount != kRefIncrement &&
101             (count_.fetch_sub(kRefIncrement, std::memory_order_acq_rel) &
102              kHighRefcountMask) != 0;
103    }
104    inline bool DecrementExpectHighRefcount() {
105      int32_t refcount =
106          count_.fetch_sub(kRefIncrement, std::memory_order_acq_rel);
107      assert((refcount & kRefcountMask) > 0 || refcount & kImmortalFlag);
108      return (refcount & kHighRefcountMask) != 0;
109    }
110    inline size_t Get() const {
111      return static_cast<size_t>(count_.load(std::memory_order_acquire) >>
112                                 kNumFlags);
113    }
114    inline bool IsOne() {
115      return (count_.load(std::memory_order_acquire) & kRefcountMask) ==
116             kRefIncrement;
117    }
118    bool IsImmortal() const {
119      return (count_.load(std::memory_order_relaxed) & kImmortalFlag) != 0;
120    }
121   private:
122    enum Flags {
123      kNumFlags = 2,
124      kImmortalFlag = 0x1,
125      kReservedFlag = 0x2,
126      kRefIncrement = (1 << kNumFlags),
127      kRefcountMask = ~kReservedFlag,
128      kHighRefcountMask = kRefcountMask & ~kRefIncrement,
129    };
130    std::atomic<int32_t> count_;
131  };
132  enum CordRepKind {
133    UNUSED_0 = 0,
134    SUBSTRING = 1,
135    CRC = 2,
136    BTREE = 3,
137    RING = 4,
138    EXTERNAL = 5,
139    FLAT = 6,
140    MAX_FLAT_TAG = 248
141  };
142  static_assert(RING == BTREE + 1, "BTREE and RING not consecutive");
143  static_assert(EXTERNAL == RING + 1, "BTREE and EXTERNAL not consecutive");
144  static_assert(FLAT == EXTERNAL + 1, "EXTERNAL and FLAT not consecutive");
145  struct CordRep {
146    struct ExtractResult {
147      CordRep* tree;
148      CordRep* extracted;
149    };
150    CordRep() = default;
151    constexpr CordRep(RefcountAndFlags::Immortal immortal, size_t l)
152        : length(l), refcount(immortal), tag(EXTERNAL), storage{} {}
153    size_t length;
154    RefcountAndFlags refcount;
155    uint8_t tag;
156    uint8_t storage[3];
157    constexpr bool IsRing() const { return tag == RING; }
158    constexpr bool IsSubstring() const { return tag == SUBSTRING; }
159    constexpr bool IsCrc() const { return tag == CRC; }
160    constexpr bool IsExternal() const { return tag == EXTERNAL; }
161    constexpr bool IsFlat() const { return tag >= FLAT; }
162    constexpr bool IsBtree() const { return tag == BTREE; }
163    inline CordRepRing* ring();
164    inline const CordRepRing* ring() const;
165    inline CordRepSubstring* substring();
166    inline const CordRepSubstring* substring() const;
167    inline CordRepCrc* crc();
168    inline const CordRepCrc* crc() const;
169    inline CordRepExternal* external();
170    inline const CordRepExternal* external() const;
171    inline CordRepFlat* flat();
172    inline const CordRepFlat* flat() const;
173    inline CordRepBtree* btree();
174    inline const CordRepBtree* btree() const;
175    static void Destroy(CordRep* rep);
176    static inline CordRep* Ref(CordRep* rep);
177    static inline void Unref(CordRep* rep);
178  };
179  struct CordRepSubstring : public CordRep {
180    size_t start;  
181    CordRep* child;
182    static inline CordRepSubstring* Create(CordRep* child, size_t pos, size_t n);
183    static inline CordRep* Substring(CordRep* rep, size_t pos, size_t n);
184  };
185  using ExternalReleaserInvoker = void (*)(CordRepExternal*);
186  struct CordRepExternal : public CordRep {
187    CordRepExternal() = default;
188    explicit constexpr CordRepExternal(absl::string_view str)
189        : CordRep(RefcountAndFlags::Immortal{}, str.size()),
190          base(str.data()),
191          releaser_invoker(nullptr) {}
192    const char* base;
193    ExternalReleaserInvoker releaser_invoker;
194    static void Delete(CordRep* rep);
195  };
196  struct Rank1 {};
197  struct Rank0 : Rank1 {};
198  template <typename Releaser, typename = ::absl::base_internal::invoke_result_t<
199                                   Releaser, absl::string_view>>
200  void InvokeReleaser(Rank0, Releaser&& releaser, absl::string_view data) {
201    ::absl::base_internal::invoke(std::forward<Releaser>(releaser), data);
202  }
203  template <typename Releaser,
204            typename = ::absl::base_internal::invoke_result_t<Releaser>>
205  void InvokeReleaser(Rank1, Releaser&& releaser, absl::string_view) {
206    ::absl::base_internal::invoke(std::forward<Releaser>(releaser));
207  }
208  template <typename Releaser>
209  struct CordRepExternalImpl
210      : public CordRepExternal,
211        public ::absl::container_internal::CompressedTuple<Releaser> {
212    template <typename T>
213    CordRepExternalImpl(T&& releaser, int)
214        : CordRepExternalImpl::CompressedTuple(std::forward<T>(releaser)) {
215      this->releaser_invoker = &Release;
216    }
217    ~CordRepExternalImpl() {
218      InvokeReleaser(Rank0{}, std::move(this->template get<0>()),
219                     absl::string_view(base, length));
220    }
221    static void Release(CordRepExternal* rep) {
222      delete static_cast<CordRepExternalImpl*>(rep);
223    }
224  };
225  inline CordRepSubstring* CordRepSubstring::Create(CordRep* child, size_t pos,
226                                                    size_t n) {
227    assert(child != nullptr);
228    assert(n > 0);
229    assert(n < child->length);
230    assert(pos < child->length);
231    assert(n <= child->length - pos);
232    if (ABSL_PREDICT_FALSE(!(child->IsExternal() || child->IsFlat()))) {
233      LogFatalNodeType(child);
234    }
235    CordRepSubstring* rep = new CordRepSubstring();
236    rep->length = n;
237    rep->tag = SUBSTRING;
238    rep->start = pos;
239    rep->child = child;
240    return rep;
241  }
242  inline CordRep* CordRepSubstring::Substring(CordRep* rep, size_t pos,
243                                              size_t n) {
<span onclick='openModal()' class='match'>244    assert(rep != nullptr);
245    assert(n != 0);
246    assert(pos < rep->length);
</span>247    assert(n <= rep->length - pos);
248    if (n == rep->length) return CordRep::Ref(rep);
249    if (rep->IsSubstring()) {
250      pos += rep->substring()->start;
251      rep = rep->substring()->child;
252    }
253    CordRepSubstring* substr = new CordRepSubstring();
254    substr->length = n;
255    substr->tag = SUBSTRING;
256    substr->start = pos;
257    substr->child = CordRep::Ref(rep);
258    return substr;
259  }
260  inline void CordRepExternal::Delete(CordRep* rep) {
261    assert(rep != nullptr && rep->IsExternal());
262    auto* rep_external = static_cast<CordRepExternal*>(rep);
263    assert(rep_external->releaser_invoker != nullptr);
264    rep_external->releaser_invoker(rep_external);
265  }
266  template <typename Str>
267  struct ConstInitExternalStorage {
268    ABSL_CONST_INIT static CordRepExternal value;
269  };
270  template <typename Str>
271  ABSL_CONST_INIT CordRepExternal
272      ConstInitExternalStorage<Str>::value(Str::value);
273  enum {
274    kMaxInline = 15,
275  };
276  constexpr char GetOrNull(absl::string_view data, size_t pos) {
277    return pos < data.size() ? data[pos] : '\0';
278  }
279  using cordz_info_t = int64_t;
280  static_assert(sizeof(cordz_info_t) * 2 == kMaxInline + 1, "");
281  static_assert(sizeof(cordz_info_t) >= sizeof(intptr_t), "");
282  static constexpr cordz_info_t LittleEndianByte(unsigned char value) {
283  #if defined(ABSL_IS_BIG_ENDIAN)
284    return static_cast<cordz_info_t>(value) << ((sizeof(cordz_info_t) - 1) * 8);
285  #else
286    return value;
287  #endif
288  }
289  class InlineData {
290   public:
291    enum DefaultInitType { kDefaultInit };
292    static constexpr cordz_info_t kNullCordzInfo = LittleEndianByte(1);
293    static constexpr size_t kTagOffset = 0;
294  #ifdef ABSL_INTERNAL_CORD_HAVE_SANITIZER
295    ~InlineData() noexcept { unpoison(); }
296  #endif
297    constexpr InlineData() noexcept { poison_this(); }
298    explicit InlineData(DefaultInitType) noexcept : rep_(kDefaultInit) {
299      poison_this();
300    }
301    explicit InlineData(CordRep* rep) noexcept : rep_(rep) {
302      ABSL_ASSERT(rep != nullptr);
303    }
304    constexpr InlineData(absl::string_view sv, CordRep* rep) noexcept
305        : rep_(rep ? Rep(rep) : Rep(sv)) {
306      poison();
307    }
308    constexpr InlineData(const InlineData& rhs) noexcept;
309    InlineData& operator=(const InlineData& rhs) noexcept;
310    friend bool operator==(const InlineData& lhs, const InlineData& rhs) {
311  #ifdef ABSL_INTERNAL_CORD_HAVE_SANITIZER
312      const Rep l = lhs.rep_.SanitizerSafeCopy();
313      const Rep r = rhs.rep_.SanitizerSafeCopy();
314      return memcmp(&l, &r, sizeof(l)) == 0;
315  #else
316      return memcmp(&lhs, &rhs, sizeof(lhs)) == 0;
317  #endif
318    }
319    friend bool operator!=(const InlineData& lhs, const InlineData& rhs) {
320      return !operator==(lhs, rhs);
321    }
322    constexpr void poison();
323    constexpr void unpoison();
324    constexpr void poison_this();
325    bool is_empty() const { return rep_.tag() == 0; }
326    bool is_tree() const { return (rep_.tag() & 1) != 0; }
327    bool is_profiled() const {
328      assert(is_tree());
329      return rep_.cordz_info() != kNullCordzInfo;
330    }
331    static bool is_either_profiled(const InlineData& data1,
332                                   const InlineData& data2) {
333      assert(data1.is_tree() && data2.is_tree());
334      return (data1.rep_.cordz_info() | data2.rep_.cordz_info()) !=
335             kNullCordzInfo;
336    }
337    CordzInfo* cordz_info() const {
338      assert(is_tree());
339      intptr_t info = static_cast<intptr_t>(absl::little_endian::ToHost64(
340          static_cast<uint64_t>(rep_.cordz_info())));
341      assert(info & 1);
342      return reinterpret_cast<CordzInfo*>(info - 1);
343    }
344    void set_cordz_info(CordzInfo* cordz_info) {
345      assert(is_tree());
346      uintptr_t info = reinterpret_cast<uintptr_t>(cordz_info) | 1;
347      rep_.set_cordz_info(
348          static_cast<cordz_info_t>(absl::little_endian::FromHost64(info)));
349    }
350    void clear_cordz_info() {
351      assert(is_tree());
352      rep_.set_cordz_info(kNullCordzInfo);
353    }
354    const char* as_chars() const {
355      assert(!is_tree());
356      return rep_.as_chars();
357    }
358    char* as_chars() { return rep_.as_chars(); }
359    CordRep* as_tree() const {
360      assert(is_tree());
361      return rep_.tree();
362    }
363    void set_inline_data(const char* data, size_t n) {
364      ABSL_ASSERT(n <= kMaxInline);
365      unpoison();
366      rep_.set_tag(static_cast<int8_t>(n << 1));
367      SmallMemmove<true>(rep_.as_chars(), data, n);
368      poison();
369    }
370    void copy_max_inline_to(char* dst) const {
371      assert(!is_tree());
372      memcpy(dst, rep_.SanitizerSafeCopy().as_chars(), kMaxInline);
373    }
374    void make_tree(CordRep* rep) {
375      unpoison();
376      rep_.make_tree(rep);
377    }
378    void set_tree(CordRep* rep) {
379      assert(is_tree());
380      rep_.set_tree(rep);
381    }
382    size_t inline_size() const { return rep_.inline_size(); }
383    void set_inline_size(size_t size) {
384      unpoison();
385      rep_.set_inline_size(size);
386      poison();
387    }
388    int Compare(const InlineData& rhs) const {
389      return Compare(rep_.SanitizerSafeCopy(), rhs.rep_.SanitizerSafeCopy());
390    }
391   private:
392    struct Rep {
393      struct AsTree {
394        explicit constexpr AsTree(absl::cord_internal::CordRep* tree)
395            : rep(tree) {}
396        cordz_info_t cordz_info = kNullCordzInfo;
397        absl::cord_internal::CordRep* rep;
398      };
399      explicit Rep(DefaultInitType) {}
400      constexpr Rep() : data{0} {}
401      constexpr Rep(const Rep&) = default;
402      constexpr Rep& operator=(const Rep&) = default;
403      explicit constexpr Rep(CordRep* rep) : as_tree(rep) {}
404      explicit constexpr Rep(absl::string_view chars)
405          : data{static_cast<char>((chars.size() << 1)),
406                 GetOrNull(chars, 0),
407                 GetOrNull(chars, 1),
408                 GetOrNull(chars, 2),
409                 GetOrNull(chars, 3),
410                 GetOrNull(chars, 4),
411                 GetOrNull(chars, 5),
412                 GetOrNull(chars, 6),
413                 GetOrNull(chars, 7),
414                 GetOrNull(chars, 8),
415                 GetOrNull(chars, 9),
416                 GetOrNull(chars, 10),
417                 GetOrNull(chars, 11),
418                 GetOrNull(chars, 12),
419                 GetOrNull(chars, 13),
420                 GetOrNull(chars, 14)} {}
421      ABSL_CORD_INTERNAL_NO_SANITIZE
422      int8_t tag() const { return reinterpret_cast<const int8_t*>(this)[0]; }
423      void set_tag(int8_t rhs) { reinterpret_cast<int8_t*>(this)[0] = rhs; }
424      char* as_chars() { return data + 1; }
425      const char* as_chars() const { return data + 1; }
426      bool is_tree() const { return (tag() & 1) != 0; }
427      size_t inline_size() const {
428        ABSL_ASSERT(!is_tree());
429        return static_cast<size_t>(tag()) >> 1;
430      }
431      void set_inline_size(size_t size) {
432        ABSL_ASSERT(size <= kMaxInline);
433        set_tag(static_cast<int8_t>(size << 1));
434      }
435      CordRep* tree() const { return as_tree.rep; }
436      void set_tree(CordRep* rhs) { as_tree.rep = rhs; }
437      cordz_info_t cordz_info() const { return as_tree.cordz_info; }
438      void set_cordz_info(cordz_info_t rhs) { as_tree.cordz_info = rhs; }
439      void make_tree(CordRep* tree) {
440        as_tree.rep = tree;
441        as_tree.cordz_info = kNullCordzInfo;
442      }
443  #ifdef ABSL_INTERNAL_CORD_HAVE_SANITIZER
444      constexpr Rep SanitizerSafeCopy() const {
445        if (!absl::is_constant_evaluated()) {
446          Rep res;
447          if (is_tree()) {
448            res = *this;
449          } else {
450            res.set_tag(tag());
451            memcpy(res.as_chars(), as_chars(), inline_size());
452          }
453          return res;
454        } else {
455          return *this;
456        }
457      }
458  #else
459      constexpr const Rep& SanitizerSafeCopy() const { return *this; }
460  #endif
461      union {
462        char data[kMaxInline + 1];
463        AsTree as_tree;
464      };
465    };
466    static inline int Compare(const Rep& lhs, const Rep& rhs) {
467      uint64_t x, y;
468      memcpy(&x, lhs.as_chars(), sizeof(x));
469      memcpy(&y, rhs.as_chars(), sizeof(y));
470      if (x == y) {
471        memcpy(&x, lhs.as_chars() + 7, sizeof(x));
472        memcpy(&y, rhs.as_chars() + 7, sizeof(y));
473        if (x == y) {
474          if (lhs.inline_size() == rhs.inline_size()) return 0;
475          return lhs.inline_size() < rhs.inline_size() ? -1 : 1;
476        }
477      }
478      x = absl::big_endian::FromHost64(x);
479      y = absl::big_endian::FromHost64(y);
480      return x < y ? -1 : 1;
481    }
482    Rep rep_;
483  };
484  static_assert(sizeof(InlineData) == kMaxInline + 1, "");
485  #ifdef ABSL_INTERNAL_CORD_HAVE_SANITIZER
486  constexpr InlineData::InlineData(const InlineData& rhs) noexcept
487      : rep_(rhs.rep_.SanitizerSafeCopy()) {
488    poison();
489  }
490  inline InlineData& InlineData::operator=(const InlineData& rhs) noexcept {
491    unpoison();
492    rep_ = rhs.rep_.SanitizerSafeCopy();
493    poison();
494    return *this;
495  }
496  constexpr void InlineData::poison_this() {
497    if (!absl::is_constant_evaluated()) {
498      container_internal::SanitizerPoisonObject(this);
499    }
500  }
501  constexpr void InlineData::unpoison() {
502    if (!absl::is_constant_evaluated()) {
503      container_internal::SanitizerUnpoisonObject(this);
504    }
505  }
506  constexpr void InlineData::poison() {
507    if (!absl::is_constant_evaluated()) {
508      if (is_tree()) {
509        container_internal::SanitizerUnpoisonObject(this);
510      } else if (const size_t size = inline_size()) {
511        if (size < kMaxInline) {
512          const char* end = rep_.as_chars() + size;
513          container_internal::SanitizerPoisonMemoryRegion(end, kMaxInline - size);
514        }
515      } else {
516        container_internal::SanitizerPoisonObject(this);
517      }
518    }
519  }
520  #else  
521  constexpr InlineData::InlineData(const InlineData&) noexcept = default;
522  inline InlineData& InlineData::operator=(const InlineData&) noexcept = default;
523  constexpr void InlineData::poison_this() {}
524  constexpr void InlineData::unpoison() {}
525  constexpr void InlineData::poison() {}
526  #endif  
527  inline CordRepSubstring* CordRep::substring() {
528    assert(IsSubstring());
529    return static_cast<CordRepSubstring*>(this);
530  }
531  inline const CordRepSubstring* CordRep::substring() const {
532    assert(IsSubstring());
533    return static_cast<const CordRepSubstring*>(this);
534  }
535  inline CordRepExternal* CordRep::external() {
536    assert(IsExternal());
537    return static_cast<CordRepExternal*>(this);
538  }
539  inline const CordRepExternal* CordRep::external() const {
540    assert(IsExternal());
541    return static_cast<const CordRepExternal*>(this);
542  }
543  inline CordRep* CordRep::Ref(CordRep* rep) {
544    ABSL_ASSUME(rep != nullptr);
545    rep->refcount.Increment();
546    return rep;
547  }
548  inline void CordRep::Unref(CordRep* rep) {
549    assert(rep != nullptr);
550    if (ABSL_PREDICT_FALSE(!rep->refcount.DecrementExpectHighRefcount())) {
551      Destroy(rep);
552    }
553  }
554  }  
555  ABSL_NAMESPACE_END
556  }  
557  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-intproto.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cord_internal.h</div>
                </div>
                <div class="column column_space"><pre><code>964    assert(Feature != nullptr);
965    assert(color != 0);
966    X = Feature->X;
</pre></code></div>
                <div class="column column_space"><pre><code>244    assert(rep != nullptr);
245    assert(n != 0);
246    assert(pos < rep->length);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    