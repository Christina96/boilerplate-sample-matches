
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 72, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-superscript.cpp</h3>
            <pre><code>1  #include "normalis.h"
2  #include "tesseractclass.h"
3  namespace tesseract {
4  static int LeadingUnicharsToChopped(WERD_RES *word, int num_unichars) {
5    int num_chopped = 0;
6    for (int i = 0; i < num_unichars; i++) {
7      num_chopped += word->best_state[i];
8    }
9    return num_chopped;
10  }
11  static int TrailingUnicharsToChopped(WERD_RES *word, int num_unichars) {
12    int num_chopped = 0;
13    for (int i = 0; i < num_unichars; i++) {
14      num_chopped += word->best_state[word->best_state.size() - 1 - i];
15    }
16    return num_chopped;
17  }
18  static void YOutlierPieces(WERD_RES *word, int rebuilt_blob_index, int super_y_bottom,
19                             int sub_y_top, ScriptPos *leading_pos, int *num_leading_outliers,
20                             ScriptPos *trailing_pos, int *num_trailing_outliers) {
21    ScriptPos sp_unused1, sp_unused2;
22    int unused1, unused2;
23    if (!leading_pos) {
24      leading_pos = &sp_unused1;
25    }
26    if (!num_leading_outliers) {
27      num_leading_outliers = &unused1;
28    }
29    if (!trailing_pos) {
30      trailing_pos = &sp_unused2;
31    }
32    if (!num_trailing_outliers) {
33      num_trailing_outliers = &unused2;
34    }
35    *num_leading_outliers = *num_trailing_outliers = 0;
36    *leading_pos = *trailing_pos = SP_NORMAL;
37    int chopped_start = LeadingUnicharsToChopped(word, rebuilt_blob_index);
38    int num_chopped_pieces = word->best_state[rebuilt_blob_index];
39    ScriptPos last_pos = SP_NORMAL;
40    int trailing_outliers = 0;
41    for (int i = 0; i < num_chopped_pieces; i++) {
42      TBOX box = word->chopped_word->blobs[chopped_start + i]->bounding_box();
43      ScriptPos pos = SP_NORMAL;
44      if (box.bottom() >= super_y_bottom) {
45        pos = SP_SUPERSCRIPT;
46      } else if (box.top() <= sub_y_top) {
47        pos = SP_SUBSCRIPT;
48      }
49      if (pos == SP_NORMAL) {
50        if (trailing_outliers == i) {
51          *num_leading_outliers = trailing_outliers;
52          *leading_pos = last_pos;
53        }
54        trailing_outliers = 0;
55      } else {
56        if (pos == last_pos) {
57          trailing_outliers++;
58        } else {
59          trailing_outliers = 1;
60        }
61      }
62      last_pos = pos;
63    }
64    *num_trailing_outliers = trailing_outliers;
65    *trailing_pos = last_pos;
66  }
67  bool Tesseract::SubAndSuperscriptFix(WERD_RES *word) {
68    if (word->tess_failed || word->word->flag(W_REP_CHAR) || !word->best_choice) {
69      return false;
70    }
71    int num_leading, num_trailing;
72    ScriptPos sp_leading, sp_trailing;
73    float leading_certainty, trailing_certainty;
74    float avg_certainty, unlikely_threshold;
75    GetSubAndSuperscriptCandidates(word, &num_leading, &sp_leading, &leading_certainty, &num_trailing,
76                                   &sp_trailing, &trailing_certainty, &avg_certainty,
77                                   &unlikely_threshold);
78    const char *leading_pos = sp_leading == SP_SUBSCRIPT ? "sub" : "super";
79    const char *trailing_pos = sp_trailing == SP_SUBSCRIPT ? "sub" : "super";
80    int num_blobs = word->best_choice->length();
81    int num_remainder_leading = 0, num_remainder_trailing = 0;
82    if (num_leading + num_trailing < num_blobs && unlikely_threshold < 0.0) {
83      int super_y_bottom = kBlnBaselineOffset + kBlnXHeight * superscript_min_y_bottom;
84      int sub_y_top = kBlnBaselineOffset + kBlnXHeight * subscript_max_y_top;
85      int last_word_char = num_blobs - 1 - num_trailing;
86      float last_char_certainty = word->best_choice->certainty(last_word_char);
87      if (word->best_choice->unichar_id(last_word_char) != 0 &&
88          last_char_certainty <= unlikely_threshold) {
89        ScriptPos rpos;
90        YOutlierPieces(word, last_word_char, super_y_bottom, sub_y_top, nullptr, nullptr, &rpos,
91                       &num_remainder_trailing);
92        if (num_trailing > 0 && rpos != sp_trailing) {
93          num_remainder_trailing = 0;
94        }
95        if (num_remainder_trailing > 0 && last_char_certainty < trailing_certainty) {
96          trailing_certainty = last_char_certainty;
97        }
98      }
99      bool another_blob_available =
100          (num_remainder_trailing == 0) || num_leading + num_trailing + 1 < num_blobs;
101      int first_char_certainty = word->best_choice->certainty(num_leading);
102      if (another_blob_available && word->best_choice->unichar_id(num_leading) != 0 &&
103          first_char_certainty <= unlikely_threshold) {
104        ScriptPos lpos;
105        YOutlierPieces(word, num_leading, super_y_bottom, sub_y_top, &lpos, &num_remainder_leading,
106                       nullptr, nullptr);
107        if (num_leading > 0 && lpos != sp_leading) {
108          num_remainder_leading = 0;
109        }
110        if (num_remainder_leading > 0 && first_char_certainty < leading_certainty) {
111          leading_certainty = first_char_certainty;
112        }
113      }
114    }
115    if (num_leading + num_trailing + num_remainder_leading + num_remainder_trailing == 0) {
116      return false;
117    }
118    if (superscript_debug >= 1) {
119      tprintf("Candidate for superscript detection: %s (",
120              word->best_choice->unichar_string().c_str());
121      if (num_leading || num_remainder_leading) {
122        tprintf("%d.%d %s-leading ", num_leading, num_remainder_leading, leading_pos);
123      }
124      if (num_trailing || num_remainder_trailing) {
125        tprintf("%d.%d %s-trailing ", num_trailing, num_remainder_trailing, trailing_pos);
126      }
127      tprintf(")\n");
128    }
129    if (superscript_debug >= 3) {
130      word->best_choice->print();
131    }
132    if (superscript_debug >= 2) {
133      tprintf(" Certainties -- Average: %.2f  Unlikely thresh: %.2f  ", avg_certainty,
134              unlikely_threshold);
135      if (num_leading) {
136        tprintf("Orig. leading (min): %.2f  ", leading_certainty);
137      }
138      if (num_trailing) {
139        tprintf("Orig. trailing (min): %.2f  ", trailing_certainty);
140      }
141      tprintf("\n");
142    }
143    int num_chopped_leading = LeadingUnicharsToChopped(word, num_leading) + num_remainder_leading;
144    int num_chopped_trailing = TrailingUnicharsToChopped(word, num_trailing) + num_remainder_trailing;
145    int retry_leading = 0;
146    int retry_trailing = 0;
147    bool is_good = false;
148    WERD_RES *revised = TrySuperscriptSplits(num_chopped_leading, leading_certainty, sp_leading,
149                                             num_chopped_trailing, trailing_certainty, sp_trailing,
150                                             word, &is_good, &retry_leading, &retry_trailing);
151    if (is_good) {
152      word->ConsumeWordResults(revised);
153    } else if (retry_leading || retry_trailing) {
154      int retry_chopped_leading = LeadingUnicharsToChopped(revised, retry_leading);
155      int retry_chopped_trailing = TrailingUnicharsToChopped(revised, retry_trailing);
156      WERD_RES *revised2 = TrySuperscriptSplits(
157          retry_chopped_leading, leading_certainty, sp_leading, retry_chopped_trailing,
158          trailing_certainty, sp_trailing, revised, &is_good, &retry_leading, &retry_trailing);
159      if (is_good) {
160        word->ConsumeWordResults(revised2);
161      }
162      delete revised2;
163    }
164    delete revised;
165    return is_good;
166  }
167  void Tesseract::GetSubAndSuperscriptCandidates(const WERD_RES *word, int *num_rebuilt_leading,
168                                                 ScriptPos *leading_pos, float *leading_certainty,
169                                                 int *num_rebuilt_trailing, ScriptPos *trailing_pos,
170                                                 float *trailing_certainty, float *avg_certainty,
171                                                 float *unlikely_threshold) {
172    *avg_certainty = *unlikely_threshold = 0.0f;
173    *num_rebuilt_leading = *num_rebuilt_trailing = 0;
174    *leading_certainty = *trailing_certainty = 0.0f;
175    int super_y_bottom = kBlnBaselineOffset + kBlnXHeight * superscript_min_y_bottom;
176    int sub_y_top = kBlnBaselineOffset + kBlnXHeight * subscript_max_y_top;
177    *leading_pos = *trailing_pos = SP_NORMAL;
178    int leading_outliers = 0;
179    int trailing_outliers = 0;
180    int num_normal = 0;
181    float normal_certainty_total = 0.0f;
182    float worst_normal_certainty = 0.0f;
183    ScriptPos last_pos = SP_NORMAL;
184    int num_blobs = word->rebuild_word->NumBlobs();
185    for (int b = 0; b < num_blobs; ++b) {
186      TBOX box = word->rebuild_word->blobs[b]->bounding_box();
187      ScriptPos pos = SP_NORMAL;
188      if (box.bottom() >= super_y_bottom) {
189        pos = SP_SUPERSCRIPT;
190      } else if (box.top() <= sub_y_top) {
191        pos = SP_SUBSCRIPT;
192      }
193      if (pos == SP_NORMAL) {
194        if (word->best_choice->unichar_id(b) != 0) {
195          float char_certainty = word->best_choice->certainty(b);
196          if (char_certainty < worst_normal_certainty) {
197            worst_normal_certainty = char_certainty;
198          }
199          num_normal++;
200          normal_certainty_total += char_certainty;
201        }
202        if (trailing_outliers == b) {
203          leading_outliers = trailing_outliers;
204          *leading_pos = last_pos;
205        }
206        trailing_outliers = 0;
207      } else {
208        if (last_pos == pos) {
209          trailing_outliers++;
210        } else {
211          trailing_outliers = 1;
212        }
213      }
214      last_pos = pos;
215    }
216    *trailing_pos = last_pos;
217    if (num_normal >= 3) { 
218      num_normal--;
219      normal_certainty_total -= worst_normal_certainty;
220    }
221    if (num_normal > 0) {
222      *avg_certainty = normal_certainty_total / num_normal;
223      *unlikely_threshold = superscript_worse_certainty * (*avg_certainty);
224    }
225    if (num_normal == 0 || (leading_outliers == 0 && trailing_outliers == 0)) {
226      return;
227    }
228    for (*leading_certainty = 0.0f, *num_rebuilt_leading = 0; *num_rebuilt_leading < leading_outliers;
229         (*num_rebuilt_leading)++) {
230      float char_certainty = word->best_choice->certainty(*num_rebuilt_leading);
231      if (char_certainty > *unlikely_threshold) {
232        break;
233      }
234      if (char_certainty < *leading_certainty) {
235        *leading_certainty = char_certainty;
236      }
237    }
238    for (*trailing_certainty = 0.0f, *num_rebuilt_trailing = 0;
239         *num_rebuilt_trailing < trailing_outliers; (*num_rebuilt_trailing)++) {
240      int blob_idx = num_blobs - 1 - *num_rebuilt_trailing;
241      float char_certainty = word->best_choice->certainty(blob_idx);
242      if (char_certainty > *unlikely_threshold) {
243        break;
244      }
245      if (char_certainty < *trailing_certainty) {
246        *trailing_certainty = char_certainty;
247      }
248    }
249  }
250  WERD_RES *Tesseract::TrySuperscriptSplits(int num_chopped_leading, float leading_certainty,
251                                            ScriptPos leading_pos, int num_chopped_trailing,
252                                            float trailing_certainty, ScriptPos trailing_pos,
253                                            WERD_RES *word, bool *is_good, int *retry_rebuild_leading,
254                                            int *retry_rebuild_trailing) {
255    int num_chopped = word->chopped_word->NumBlobs();
256    *retry_rebuild_leading = *retry_rebuild_trailing = 0;
257    BlamerBundle *bb0 = nullptr;
258    BlamerBundle *bb1 = nullptr;
259    WERD_RES *prefix = nullptr;
260    WERD_RES *core = nullptr;
261    WERD_RES *suffix = nullptr;
262    if (num_chopped_leading > 0) {
263      prefix = new WERD_RES(*word);
264      split_word(prefix, num_chopped_leading, &core, &bb0);
265    } else {
266      core = new WERD_RES(*word);
267    }
268    if (num_chopped_trailing > 0) {
269      int split_pt = num_chopped - num_chopped_trailing - num_chopped_leading;
270      split_word(core, split_pt, &suffix, &bb1);
271    }
272    int saved_cp_multiplier = classify_class_pruner_multiplier;
273    int saved_im_multiplier = classify_integer_matcher_multiplier;
274    if (prefix) {
275      classify_class_pruner_multiplier.set_value(0);
<span onclick='openModal()' class='match'>276      classify_integer_matcher_multiplier.set_value(0);
277      if (superscript_debug >= 3) {
278        tprintf(" recognizing first %d chopped blobs\n", num_chopped_leading);
279      }
280      recog_word_recursive(prefix);
281      if (superscript_debug >= 2) {
282        tprintf(" The leading bits look like %s %s\n", ScriptPosToString(leading_pos),
283                prefix->best_choice->unichar_string().c_str());
284      }
285      classify_class_pruner_multiplier.set_value(saved_cp_multiplier);
286      classify_integer_matcher_multiplier.set_value(saved_im_multiplier);
287    }
288    if (superscript_debug >= 3) {
</span>289      tprintf(" recognizing middle %d chopped blobs\n",
290              num_chopped - num_chopped_leading - num_chopped_trailing);
291    }
292    if (suffix) {
293      classify_class_pruner_multiplier.set_value(0);
294      classify_integer_matcher_multiplier.set_value(0);
295      if (superscript_debug >= 3) {
296        tprintf(" recognizing last %d chopped blobs\n", num_chopped_trailing);
297      }
298      recog_word_recursive(suffix);
299      if (superscript_debug >= 2) {
300        tprintf(" The trailing bits look like %s %s\n", ScriptPosToString(trailing_pos),
301                suffix->best_choice->unichar_string().c_str());
302      }
303      classify_class_pruner_multiplier.set_value(saved_cp_multiplier);
304      classify_integer_matcher_multiplier.set_value(saved_im_multiplier);
305    }
306    bool good_prefix =
307        !prefix || BelievableSuperscript(superscript_debug >= 1, *prefix,
308                                         superscript_bettered_certainty * leading_certainty,
309                                         retry_rebuild_leading, nullptr);
310    bool good_suffix =
311        !suffix || BelievableSuperscript(superscript_debug >= 1, *suffix,
312                                         superscript_bettered_certainty * trailing_certainty, nullptr,
313                                         retry_rebuild_trailing);
314    *is_good = good_prefix && good_suffix;
315    if (!*is_good && !*retry_rebuild_leading && !*retry_rebuild_trailing) {
316      delete core;
317      delete prefix;
318      delete suffix;
319      delete bb1;
320      return nullptr;
321    }
322    recog_word_recursive(core);
323    if (suffix) {
324      suffix->SetAllScriptPositions(trailing_pos);
325      join_words(core, suffix, bb1);
326    }
327    if (prefix) {
328      prefix->SetAllScriptPositions(leading_pos);
329      join_words(prefix, core, bb0);
330      core = prefix;
331      prefix = nullptr;
332    }
333    if (superscript_debug >= 1) {
334      tprintf("%s superscript fix: %s\n", *is_good ? "ACCEPT" : "REJECT",
335              core->best_choice->unichar_string().c_str());
336    }
337    return core;
338  }
339  bool Tesseract::BelievableSuperscript(bool debug, const WERD_RES &word, float certainty_threshold,
340                                        int *left_ok, int *right_ok) const {
341    unsigned initial_ok_run_count = 0;
342    unsigned ok_run_count = 0;
343    float worst_certainty = 0.0f;
344    const WERD_CHOICE &wc = *word.best_choice;
345    const UnicityTable<FontInfo> &fontinfo_table = get_fontinfo_table();
346    for (unsigned i = 0; i < wc.length(); i++) {
347      TBLOB *blob = word.rebuild_word->blobs[i];
348      UNICHAR_ID unichar_id = wc.unichar_id(i);
349      float char_certainty = wc.certainty(i);
350      bool bad_certainty = char_certainty < certainty_threshold;
351      bool is_punc = wc.unicharset()->get_ispunctuation(unichar_id);
352      bool is_italic = word.fontinfo && word.fontinfo->is_italic();
353      BLOB_CHOICE *choice = word.GetBlobChoice(i);
354      if (choice && fontinfo_table.size() > 0) {
355        int font_id1 = choice->fontinfo_id();
356        bool font1_is_italic = font_id1 >= 0 ? fontinfo_table.at(font_id1).is_italic() : false;
357        int font_id2 = choice->fontinfo_id2();
358        is_italic = font1_is_italic && (font_id2 < 0 || fontinfo_table.at(font_id2).is_italic());
359      }
360      float height_fraction = 1.0f;
361      float char_height = blob->bounding_box().height();
362      float normal_height = char_height;
363      if (wc.unicharset()->top_bottom_useful()) {
364        int min_bot, max_bot, min_top, max_top;
365        wc.unicharset()->get_top_bottom(unichar_id, &min_bot, &max_bot, &min_top, &max_top);
366        float hi_height = max_top - max_bot;
367        float lo_height = min_top - min_bot;
368        normal_height = (hi_height + lo_height) / 2;
369        if (normal_height >= kBlnXHeight) {
370          height_fraction = char_height / normal_height;
371        }
372      }
373      bool bad_height = height_fraction < superscript_scaledown_ratio;
374      if (debug) {
375        if (is_italic) {
376          tprintf(" Rejecting: superscript is italic.\n");
377        }
378        if (is_punc) {
379          tprintf(" Rejecting: punctuation present.\n");
380        }
381        const char *char_str = wc.unicharset()->id_to_unichar(unichar_id);
382        if (bad_certainty) {
383          tprintf(
384              " Rejecting: don't believe character %s with certainty %.2f "
385              "which is less than threshold %.2f\n",
386              char_str, char_certainty, certainty_threshold);
387        }
388        if (bad_height) {
389          tprintf(
390              " Rejecting: character %s seems too small @ %.2f versus "
391              "expected %.2f\n",
392              char_str, char_height, normal_height);
393        }
394      }
395      if (bad_certainty || bad_height || is_punc || is_italic) {
396        if (ok_run_count == i) {
397          initial_ok_run_count = ok_run_count;
398        }
399        ok_run_count = 0;
400      } else {
401        ok_run_count++;
402      }
403      if (char_certainty < worst_certainty) {
404        worst_certainty = char_certainty;
405      }
406    }
407    bool all_ok = ok_run_count == wc.length();
408    if (all_ok && debug) {
409      tprintf(" Accept: worst revised certainty is %.2f\n", worst_certainty);
410    }
411    if (!all_ok) {
412      if (left_ok) {
413        *left_ok = initial_ok_run_count;
414      }
415      if (right_ok) {
416        *right_ok = ok_run_count;
417      }
418    }
419    return all_ok;
420  }
421  } 
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-superscript.cpp</h3>
            <pre><code>1  #include "normalis.h"
2  #include "tesseractclass.h"
3  namespace tesseract {
4  static int LeadingUnicharsToChopped(WERD_RES *word, int num_unichars) {
5    int num_chopped = 0;
6    for (int i = 0; i < num_unichars; i++) {
7      num_chopped += word->best_state[i];
8    }
9    return num_chopped;
10  }
11  static int TrailingUnicharsToChopped(WERD_RES *word, int num_unichars) {
12    int num_chopped = 0;
13    for (int i = 0; i < num_unichars; i++) {
14      num_chopped += word->best_state[word->best_state.size() - 1 - i];
15    }
16    return num_chopped;
17  }
18  static void YOutlierPieces(WERD_RES *word, int rebuilt_blob_index, int super_y_bottom,
19                             int sub_y_top, ScriptPos *leading_pos, int *num_leading_outliers,
20                             ScriptPos *trailing_pos, int *num_trailing_outliers) {
21    ScriptPos sp_unused1, sp_unused2;
22    int unused1, unused2;
23    if (!leading_pos) {
24      leading_pos = &sp_unused1;
25    }
26    if (!num_leading_outliers) {
27      num_leading_outliers = &unused1;
28    }
29    if (!trailing_pos) {
30      trailing_pos = &sp_unused2;
31    }
32    if (!num_trailing_outliers) {
33      num_trailing_outliers = &unused2;
34    }
35    *num_leading_outliers = *num_trailing_outliers = 0;
36    *leading_pos = *trailing_pos = SP_NORMAL;
37    int chopped_start = LeadingUnicharsToChopped(word, rebuilt_blob_index);
38    int num_chopped_pieces = word->best_state[rebuilt_blob_index];
39    ScriptPos last_pos = SP_NORMAL;
40    int trailing_outliers = 0;
41    for (int i = 0; i < num_chopped_pieces; i++) {
42      TBOX box = word->chopped_word->blobs[chopped_start + i]->bounding_box();
43      ScriptPos pos = SP_NORMAL;
44      if (box.bottom() >= super_y_bottom) {
45        pos = SP_SUPERSCRIPT;
46      } else if (box.top() <= sub_y_top) {
47        pos = SP_SUBSCRIPT;
48      }
49      if (pos == SP_NORMAL) {
50        if (trailing_outliers == i) {
51          *num_leading_outliers = trailing_outliers;
52          *leading_pos = last_pos;
53        }
54        trailing_outliers = 0;
55      } else {
56        if (pos == last_pos) {
57          trailing_outliers++;
58        } else {
59          trailing_outliers = 1;
60        }
61      }
62      last_pos = pos;
63    }
64    *num_trailing_outliers = trailing_outliers;
65    *trailing_pos = last_pos;
66  }
67  bool Tesseract::SubAndSuperscriptFix(WERD_RES *word) {
68    if (word->tess_failed || word->word->flag(W_REP_CHAR) || !word->best_choice) {
69      return false;
70    }
71    int num_leading, num_trailing;
72    ScriptPos sp_leading, sp_trailing;
73    float leading_certainty, trailing_certainty;
74    float avg_certainty, unlikely_threshold;
75    GetSubAndSuperscriptCandidates(word, &num_leading, &sp_leading, &leading_certainty, &num_trailing,
76                                   &sp_trailing, &trailing_certainty, &avg_certainty,
77                                   &unlikely_threshold);
78    const char *leading_pos = sp_leading == SP_SUBSCRIPT ? "sub" : "super";
79    const char *trailing_pos = sp_trailing == SP_SUBSCRIPT ? "sub" : "super";
80    int num_blobs = word->best_choice->length();
81    int num_remainder_leading = 0, num_remainder_trailing = 0;
82    if (num_leading + num_trailing < num_blobs && unlikely_threshold < 0.0) {
83      int super_y_bottom = kBlnBaselineOffset + kBlnXHeight * superscript_min_y_bottom;
84      int sub_y_top = kBlnBaselineOffset + kBlnXHeight * subscript_max_y_top;
85      int last_word_char = num_blobs - 1 - num_trailing;
86      float last_char_certainty = word->best_choice->certainty(last_word_char);
87      if (word->best_choice->unichar_id(last_word_char) != 0 &&
88          last_char_certainty <= unlikely_threshold) {
89        ScriptPos rpos;
90        YOutlierPieces(word, last_word_char, super_y_bottom, sub_y_top, nullptr, nullptr, &rpos,
91                       &num_remainder_trailing);
92        if (num_trailing > 0 && rpos != sp_trailing) {
93          num_remainder_trailing = 0;
94        }
95        if (num_remainder_trailing > 0 && last_char_certainty < trailing_certainty) {
96          trailing_certainty = last_char_certainty;
97        }
98      }
99      bool another_blob_available =
100          (num_remainder_trailing == 0) || num_leading + num_trailing + 1 < num_blobs;
101      int first_char_certainty = word->best_choice->certainty(num_leading);
102      if (another_blob_available && word->best_choice->unichar_id(num_leading) != 0 &&
103          first_char_certainty <= unlikely_threshold) {
104        ScriptPos lpos;
105        YOutlierPieces(word, num_leading, super_y_bottom, sub_y_top, &lpos, &num_remainder_leading,
106                       nullptr, nullptr);
107        if (num_leading > 0 && lpos != sp_leading) {
108          num_remainder_leading = 0;
109        }
110        if (num_remainder_leading > 0 && first_char_certainty < leading_certainty) {
111          leading_certainty = first_char_certainty;
112        }
113      }
114    }
115    if (num_leading + num_trailing + num_remainder_leading + num_remainder_trailing == 0) {
116      return false;
117    }
118    if (superscript_debug >= 1) {
119      tprintf("Candidate for superscript detection: %s (",
120              word->best_choice->unichar_string().c_str());
121      if (num_leading || num_remainder_leading) {
122        tprintf("%d.%d %s-leading ", num_leading, num_remainder_leading, leading_pos);
123      }
124      if (num_trailing || num_remainder_trailing) {
125        tprintf("%d.%d %s-trailing ", num_trailing, num_remainder_trailing, trailing_pos);
126      }
127      tprintf(")\n");
128    }
129    if (superscript_debug >= 3) {
130      word->best_choice->print();
131    }
132    if (superscript_debug >= 2) {
133      tprintf(" Certainties -- Average: %.2f  Unlikely thresh: %.2f  ", avg_certainty,
134              unlikely_threshold);
135      if (num_leading) {
136        tprintf("Orig. leading (min): %.2f  ", leading_certainty);
137      }
138      if (num_trailing) {
139        tprintf("Orig. trailing (min): %.2f  ", trailing_certainty);
140      }
141      tprintf("\n");
142    }
143    int num_chopped_leading = LeadingUnicharsToChopped(word, num_leading) + num_remainder_leading;
144    int num_chopped_trailing = TrailingUnicharsToChopped(word, num_trailing) + num_remainder_trailing;
145    int retry_leading = 0;
146    int retry_trailing = 0;
147    bool is_good = false;
148    WERD_RES *revised = TrySuperscriptSplits(num_chopped_leading, leading_certainty, sp_leading,
149                                             num_chopped_trailing, trailing_certainty, sp_trailing,
150                                             word, &is_good, &retry_leading, &retry_trailing);
151    if (is_good) {
152      word->ConsumeWordResults(revised);
153    } else if (retry_leading || retry_trailing) {
154      int retry_chopped_leading = LeadingUnicharsToChopped(revised, retry_leading);
155      int retry_chopped_trailing = TrailingUnicharsToChopped(revised, retry_trailing);
156      WERD_RES *revised2 = TrySuperscriptSplits(
157          retry_chopped_leading, leading_certainty, sp_leading, retry_chopped_trailing,
158          trailing_certainty, sp_trailing, revised, &is_good, &retry_leading, &retry_trailing);
159      if (is_good) {
160        word->ConsumeWordResults(revised2);
161      }
162      delete revised2;
163    }
164    delete revised;
165    return is_good;
166  }
167  void Tesseract::GetSubAndSuperscriptCandidates(const WERD_RES *word, int *num_rebuilt_leading,
168                                                 ScriptPos *leading_pos, float *leading_certainty,
169                                                 int *num_rebuilt_trailing, ScriptPos *trailing_pos,
170                                                 float *trailing_certainty, float *avg_certainty,
171                                                 float *unlikely_threshold) {
172    *avg_certainty = *unlikely_threshold = 0.0f;
173    *num_rebuilt_leading = *num_rebuilt_trailing = 0;
174    *leading_certainty = *trailing_certainty = 0.0f;
175    int super_y_bottom = kBlnBaselineOffset + kBlnXHeight * superscript_min_y_bottom;
176    int sub_y_top = kBlnBaselineOffset + kBlnXHeight * subscript_max_y_top;
177    *leading_pos = *trailing_pos = SP_NORMAL;
178    int leading_outliers = 0;
179    int trailing_outliers = 0;
180    int num_normal = 0;
181    float normal_certainty_total = 0.0f;
182    float worst_normal_certainty = 0.0f;
183    ScriptPos last_pos = SP_NORMAL;
184    int num_blobs = word->rebuild_word->NumBlobs();
185    for (int b = 0; b < num_blobs; ++b) {
186      TBOX box = word->rebuild_word->blobs[b]->bounding_box();
187      ScriptPos pos = SP_NORMAL;
188      if (box.bottom() >= super_y_bottom) {
189        pos = SP_SUPERSCRIPT;
190      } else if (box.top() <= sub_y_top) {
191        pos = SP_SUBSCRIPT;
192      }
193      if (pos == SP_NORMAL) {
194        if (word->best_choice->unichar_id(b) != 0) {
195          float char_certainty = word->best_choice->certainty(b);
196          if (char_certainty < worst_normal_certainty) {
197            worst_normal_certainty = char_certainty;
198          }
199          num_normal++;
200          normal_certainty_total += char_certainty;
201        }
202        if (trailing_outliers == b) {
203          leading_outliers = trailing_outliers;
204          *leading_pos = last_pos;
205        }
206        trailing_outliers = 0;
207      } else {
208        if (last_pos == pos) {
209          trailing_outliers++;
210        } else {
211          trailing_outliers = 1;
212        }
213      }
214      last_pos = pos;
215    }
216    *trailing_pos = last_pos;
217    if (num_normal >= 3) { 
218      num_normal--;
219      normal_certainty_total -= worst_normal_certainty;
220    }
221    if (num_normal > 0) {
222      *avg_certainty = normal_certainty_total / num_normal;
223      *unlikely_threshold = superscript_worse_certainty * (*avg_certainty);
224    }
225    if (num_normal == 0 || (leading_outliers == 0 && trailing_outliers == 0)) {
226      return;
227    }
228    for (*leading_certainty = 0.0f, *num_rebuilt_leading = 0; *num_rebuilt_leading < leading_outliers;
229         (*num_rebuilt_leading)++) {
230      float char_certainty = word->best_choice->certainty(*num_rebuilt_leading);
231      if (char_certainty > *unlikely_threshold) {
232        break;
233      }
234      if (char_certainty < *leading_certainty) {
235        *leading_certainty = char_certainty;
236      }
237    }
238    for (*trailing_certainty = 0.0f, *num_rebuilt_trailing = 0;
239         *num_rebuilt_trailing < trailing_outliers; (*num_rebuilt_trailing)++) {
240      int blob_idx = num_blobs - 1 - *num_rebuilt_trailing;
241      float char_certainty = word->best_choice->certainty(blob_idx);
242      if (char_certainty > *unlikely_threshold) {
243        break;
244      }
245      if (char_certainty < *trailing_certainty) {
246        *trailing_certainty = char_certainty;
247      }
248    }
249  }
250  WERD_RES *Tesseract::TrySuperscriptSplits(int num_chopped_leading, float leading_certainty,
251                                            ScriptPos leading_pos, int num_chopped_trailing,
252                                            float trailing_certainty, ScriptPos trailing_pos,
253                                            WERD_RES *word, bool *is_good, int *retry_rebuild_leading,
254                                            int *retry_rebuild_trailing) {
255    int num_chopped = word->chopped_word->NumBlobs();
256    *retry_rebuild_leading = *retry_rebuild_trailing = 0;
257    BlamerBundle *bb0 = nullptr;
258    BlamerBundle *bb1 = nullptr;
259    WERD_RES *prefix = nullptr;
260    WERD_RES *core = nullptr;
261    WERD_RES *suffix = nullptr;
262    if (num_chopped_leading > 0) {
263      prefix = new WERD_RES(*word);
264      split_word(prefix, num_chopped_leading, &core, &bb0);
265    } else {
266      core = new WERD_RES(*word);
267    }
268    if (num_chopped_trailing > 0) {
269      int split_pt = num_chopped - num_chopped_trailing - num_chopped_leading;
270      split_word(core, split_pt, &suffix, &bb1);
271    }
272    int saved_cp_multiplier = classify_class_pruner_multiplier;
273    int saved_im_multiplier = classify_integer_matcher_multiplier;
274    if (prefix) {
275      classify_class_pruner_multiplier.set_value(0);
276      classify_integer_matcher_multiplier.set_value(0);
277      if (superscript_debug >= 3) {
278        tprintf(" recognizing first %d chopped blobs\n", num_chopped_leading);
279      }
280      recog_word_recursive(prefix);
281      if (superscript_debug >= 2) {
282        tprintf(" The leading bits look like %s %s\n", ScriptPosToString(leading_pos),
283                prefix->best_choice->unichar_string().c_str());
284      }
285      classify_class_pruner_multiplier.set_value(saved_cp_multiplier);
286      classify_integer_matcher_multiplier.set_value(saved_im_multiplier);
287    }
288    if (superscript_debug >= 3) {
289      tprintf(" recognizing middle %d chopped blobs\n",
290              num_chopped - num_chopped_leading - num_chopped_trailing);
291    }
292    if (suffix) {
293      classify_class_pruner_multiplier.set_value(0);
<span onclick='openModal()' class='match'>294      classify_integer_matcher_multiplier.set_value(0);
295      if (superscript_debug >= 3) {
296        tprintf(" recognizing last %d chopped blobs\n", num_chopped_trailing);
297      }
298      recog_word_recursive(suffix);
299      if (superscript_debug >= 2) {
300        tprintf(" The trailing bits look like %s %s\n", ScriptPosToString(trailing_pos),
301                suffix->best_choice->unichar_string().c_str());
302      }
303      classify_class_pruner_multiplier.set_value(saved_cp_multiplier);
304      classify_integer_matcher_multiplier.set_value(saved_im_multiplier);
305    }
306    bool good_prefix =
</span>307        !prefix || BelievableSuperscript(superscript_debug >= 1, *prefix,
308                                         superscript_bettered_certainty * leading_certainty,
309                                         retry_rebuild_leading, nullptr);
310    bool good_suffix =
311        !suffix || BelievableSuperscript(superscript_debug >= 1, *suffix,
312                                         superscript_bettered_certainty * trailing_certainty, nullptr,
313                                         retry_rebuild_trailing);
314    *is_good = good_prefix && good_suffix;
315    if (!*is_good && !*retry_rebuild_leading && !*retry_rebuild_trailing) {
316      delete core;
317      delete prefix;
318      delete suffix;
319      delete bb1;
320      return nullptr;
321    }
322    recog_word_recursive(core);
323    if (suffix) {
324      suffix->SetAllScriptPositions(trailing_pos);
325      join_words(core, suffix, bb1);
326    }
327    if (prefix) {
328      prefix->SetAllScriptPositions(leading_pos);
329      join_words(prefix, core, bb0);
330      core = prefix;
331      prefix = nullptr;
332    }
333    if (superscript_debug >= 1) {
334      tprintf("%s superscript fix: %s\n", *is_good ? "ACCEPT" : "REJECT",
335              core->best_choice->unichar_string().c_str());
336    }
337    return core;
338  }
339  bool Tesseract::BelievableSuperscript(bool debug, const WERD_RES &word, float certainty_threshold,
340                                        int *left_ok, int *right_ok) const {
341    unsigned initial_ok_run_count = 0;
342    unsigned ok_run_count = 0;
343    float worst_certainty = 0.0f;
344    const WERD_CHOICE &wc = *word.best_choice;
345    const UnicityTable<FontInfo> &fontinfo_table = get_fontinfo_table();
346    for (unsigned i = 0; i < wc.length(); i++) {
347      TBLOB *blob = word.rebuild_word->blobs[i];
348      UNICHAR_ID unichar_id = wc.unichar_id(i);
349      float char_certainty = wc.certainty(i);
350      bool bad_certainty = char_certainty < certainty_threshold;
351      bool is_punc = wc.unicharset()->get_ispunctuation(unichar_id);
352      bool is_italic = word.fontinfo && word.fontinfo->is_italic();
353      BLOB_CHOICE *choice = word.GetBlobChoice(i);
354      if (choice && fontinfo_table.size() > 0) {
355        int font_id1 = choice->fontinfo_id();
356        bool font1_is_italic = font_id1 >= 0 ? fontinfo_table.at(font_id1).is_italic() : false;
357        int font_id2 = choice->fontinfo_id2();
358        is_italic = font1_is_italic && (font_id2 < 0 || fontinfo_table.at(font_id2).is_italic());
359      }
360      float height_fraction = 1.0f;
361      float char_height = blob->bounding_box().height();
362      float normal_height = char_height;
363      if (wc.unicharset()->top_bottom_useful()) {
364        int min_bot, max_bot, min_top, max_top;
365        wc.unicharset()->get_top_bottom(unichar_id, &min_bot, &max_bot, &min_top, &max_top);
366        float hi_height = max_top - max_bot;
367        float lo_height = min_top - min_bot;
368        normal_height = (hi_height + lo_height) / 2;
369        if (normal_height >= kBlnXHeight) {
370          height_fraction = char_height / normal_height;
371        }
372      }
373      bool bad_height = height_fraction < superscript_scaledown_ratio;
374      if (debug) {
375        if (is_italic) {
376          tprintf(" Rejecting: superscript is italic.\n");
377        }
378        if (is_punc) {
379          tprintf(" Rejecting: punctuation present.\n");
380        }
381        const char *char_str = wc.unicharset()->id_to_unichar(unichar_id);
382        if (bad_certainty) {
383          tprintf(
384              " Rejecting: don't believe character %s with certainty %.2f "
385              "which is less than threshold %.2f\n",
386              char_str, char_certainty, certainty_threshold);
387        }
388        if (bad_height) {
389          tprintf(
390              " Rejecting: character %s seems too small @ %.2f versus "
391              "expected %.2f\n",
392              char_str, char_height, normal_height);
393        }
394      }
395      if (bad_certainty || bad_height || is_punc || is_italic) {
396        if (ok_run_count == i) {
397          initial_ok_run_count = ok_run_count;
398        }
399        ok_run_count = 0;
400      } else {
401        ok_run_count++;
402      }
403      if (char_certainty < worst_certainty) {
404        worst_certainty = char_certainty;
405      }
406    }
407    bool all_ok = ok_run_count == wc.length();
408    if (all_ok && debug) {
409      tprintf(" Accept: worst revised certainty is %.2f\n", worst_certainty);
410    }
411    if (!all_ok) {
412      if (left_ok) {
413        *left_ok = initial_ok_run_count;
414      }
415      if (right_ok) {
416        *right_ok = ok_run_count;
417      }
418    }
419    return all_ok;
420  }
421  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-superscript.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-superscript.cpp</div>
                </div>
                <div class="column column_space"><pre><code>276      classify_integer_matcher_multiplier.set_value(0);
277      if (superscript_debug >= 3) {
278        tprintf(" recognizing first %d chopped blobs\n", num_chopped_leading);
279      }
280      recog_word_recursive(prefix);
281      if (superscript_debug >= 2) {
282        tprintf(" The leading bits look like %s %s\n", ScriptPosToString(leading_pos),
283                prefix->best_choice->unichar_string().c_str());
284      }
285      classify_class_pruner_multiplier.set_value(saved_cp_multiplier);
286      classify_integer_matcher_multiplier.set_value(saved_im_multiplier);
287    }
288    if (superscript_debug >= 3) {
</pre></code></div>
                <div class="column column_space"><pre><code>294      classify_integer_matcher_multiplier.set_value(0);
295      if (superscript_debug >= 3) {
296        tprintf(" recognizing last %d chopped blobs\n", num_chopped_trailing);
297      }
298      recog_word_recursive(suffix);
299      if (superscript_debug >= 2) {
300        tprintf(" The trailing bits look like %s %s\n", ScriptPosToString(trailing_pos),
301                suffix->best_choice->unichar_string().c_str());
302      }
303      classify_class_pruner_multiplier.set_value(saved_cp_multiplier);
304      classify_integer_matcher_multiplier.set_value(saved_im_multiplier);
305    }
306    bool good_prefix =
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    