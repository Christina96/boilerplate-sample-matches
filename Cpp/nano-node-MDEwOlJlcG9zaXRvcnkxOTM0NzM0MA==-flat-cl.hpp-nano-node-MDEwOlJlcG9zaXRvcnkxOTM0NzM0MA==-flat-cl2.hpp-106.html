
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 28, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-cl.hpp</h3>
            <pre><code>1  #ifndef CL_HPP_
2  #define CL_HPP_
3  #ifdef _WIN32
4  #include &lt;malloc.h&gt;
5  #if defined(USE_DX_INTEROP)
6  #include &lt;CL/cl_d3d10.h&gt;
7  #include &lt;CL/cl_dx9_media_sharing.h&gt;
8  #endif
9  #endif 
10  #if defined(_MSC_VER)
11  #include &lt;intrin.h&gt;
12  #endif 
13  #if defined(USE_CL_DEVICE_FISSION)
14  #include &lt;CL/cl_ext.h&gt;
15  #endif
16  #if defined(__APPLE__) || defined(__MACOSX)
17  #include &lt;OpenCL/opencl.h&gt;
18  #else
19  #include &lt;CL/opencl.h&gt;
20  #endif 
21  #if (_MSC_VER &gt;= 1700) || (__cplusplus &gt;= 201103L)
22  #define CL_HPP_RVALUE_REFERENCES_SUPPORTED
23  #define CL_HPP_CPP11_ATOMICS_SUPPORTED
24  #include &lt;atomic&gt;
25  #endif
26  #if (__cplusplus &gt;= 201103L)
27  #define CL_HPP_NOEXCEPT noexcept
28  #else
29  #define CL_HPP_NOEXCEPT
30  #endif
31  #if defined(CL_VERSION_1_2) &amp;&amp; !defined(CL_USE_DEPRECATED_OPENCL_1_1_APIS)
32  #define __CL_EXPLICIT_CONSTRUCTORS explicit
33  #else 
34  #define __CL_EXPLICIT_CONSTRUCTORS 
35  #endif 
36  #if !defined(CL_EXT_PREFIX__VERSION_1_1_DEPRECATED)
37  #define CL_EXT_PREFIX__VERSION_1_1_DEPRECATED  
38  #endif 
39  #if !defined(CL_EXT_SUFFIX__VERSION_1_1_DEPRECATED)
40  #define CL_EXT_SUFFIX__VERSION_1_1_DEPRECATED
41  #endif 
42  #if !defined(CL_CALLBACK)
43  #define CL_CALLBACK
44  #endif 
45  #include &lt;utility&gt;
46  #include &lt;limits&gt;
47  #include &lt;iterator&gt;
48  #if defined(__CL_ENABLE_EXCEPTIONS)
49  #include &lt;exception&gt;
50  #endif 
51  #if !defined(__NO_STD_VECTOR)
52  #include &lt;vector&gt;
53  #endif
54  #if !defined(__NO_STD_STRING)
55  #include &lt;string&gt;
56  #endif 
57  #if defined(__ANDROID__) || defined(linux) || defined(__APPLE__) || defined(__MACOSX)
58  #include &lt;alloca.h&gt;
59  #endif 
60  #include &lt;cstring&gt;
61  namespace cl {
62  class Memory;
63  #if defined(CL_USE_DEPRECATED_OPENCL_1_1_APIS) || (defined(CL_VERSION_1_1) &amp;&amp; !defined(CL_VERSION_1_2)) 
64  #define __INIT_CL_EXT_FCN_PTR(name) \
65      if(!pfn_##name) { \
66          pfn_##name = (PFN_##name) \
67              clGetExtensionFunctionAddress(#name); \
68          if(!pfn_##name) { \
69          } \
70      }
71  #endif 
72  #if defined(CL_VERSION_1_2)
73  #define __INIT_CL_EXT_FCN_PTR_PLATFORM(platform, name) \
74      if(!pfn_##name) { \
75          pfn_##name = (PFN_##name) \
76              clGetExtensionFunctionAddressForPlatform(platform, #name); \
77          if(!pfn_##name) { \
78          } \
79      }
80  #endif 
81  class Program;
82  class Device;
83  class Context;
84  class CommandQueue;
85  class Memory;
86  class Buffer;
87  #if defined(__CL_ENABLE_EXCEPTIONS)
88  class Error : public std::exception
89  {
90  private:
91      cl_int err_;
92      const char * errStr_;
93  public:
94      Error(cl_int err, const char * errStr = NULL) : err_(err), errStr_(errStr)
95      {}
96      ~Error() throw() {}
97      virtual const char * what() const throw ()
98      {
99          if (errStr_ == NULL) {
100              return &quot;empty&quot;;
101          }
102          else {
103              return errStr_;
104          }
105      }
106      cl_int err(void) const { return err_; }
107  };
108  #define __ERR_STR(x) #x
109  #else
110  #define __ERR_STR(x) NULL
111  #endif 
112  namespace detail
113  {
114  #if defined(__CL_ENABLE_EXCEPTIONS)
115  static inline cl_int errHandler (
116      cl_int err,
117      const char * errStr = NULL)
118  {
119      if (err != CL_SUCCESS) {
120          throw Error(err, errStr);
121      }
122      return err;
123  }
124  #else
125  static inline cl_int errHandler (cl_int err, const char * errStr = NULL)
126  {
127      (void) errStr; 
128      return err;
129  }
130  #endif 
131  }
132  #if !defined(__CL_USER_OVERRIDE_ERROR_STRINGS)
133  #define __GET_DEVICE_INFO_ERR               __ERR_STR(clGetDeviceInfo)
134  #define __GET_PLATFORM_INFO_ERR             __ERR_STR(clGetPlatformInfo)
135  #define __GET_DEVICE_IDS_ERR                __ERR_STR(clGetDeviceIDs)
136  #define __GET_PLATFORM_IDS_ERR              __ERR_STR(clGetPlatformIDs)
137  #define __GET_CONTEXT_INFO_ERR              __ERR_STR(clGetContextInfo)
138  #define __GET_EVENT_INFO_ERR                __ERR_STR(clGetEventInfo)
139  #define __GET_EVENT_PROFILE_INFO_ERR        __ERR_STR(clGetEventProfileInfo)
140  #define __GET_MEM_OBJECT_INFO_ERR           __ERR_STR(clGetMemObjectInfo)
141  #define __GET_IMAGE_INFO_ERR                __ERR_STR(clGetImageInfo)
142  #define __GET_SAMPLER_INFO_ERR              __ERR_STR(clGetSamplerInfo)
143  #define __GET_KERNEL_INFO_ERR               __ERR_STR(clGetKernelInfo)
144  #if defined(CL_VERSION_1_2)
145  #define __GET_KERNEL_ARG_INFO_ERR               __ERR_STR(clGetKernelArgInfo)
146  #endif 
147  #define __GET_KERNEL_WORK_GROUP_INFO_ERR    __ERR_STR(clGetKernelWorkGroupInfo)
148  #define __GET_PROGRAM_INFO_ERR              __ERR_STR(clGetProgramInfo)
149  #define __GET_PROGRAM_BUILD_INFO_ERR        __ERR_STR(clGetProgramBuildInfo)
150  #define __GET_COMMAND_QUEUE_INFO_ERR        __ERR_STR(clGetCommandQueueInfo)
151  #define __CREATE_CONTEXT_ERR                __ERR_STR(clCreateContext)
152  #define __CREATE_CONTEXT_FROM_TYPE_ERR      __ERR_STR(clCreateContextFromType)
153  #define __GET_SUPPORTED_IMAGE_FORMATS_ERR   __ERR_STR(clGetSupportedImageFormats)
154  #define __CREATE_BUFFER_ERR                 __ERR_STR(clCreateBuffer)
155  #define __COPY_ERR                          __ERR_STR(cl::copy)
156  #define __CREATE_SUBBUFFER_ERR              __ERR_STR(clCreateSubBuffer)
157  #define __CREATE_GL_BUFFER_ERR              __ERR_STR(clCreateFromGLBuffer)
158  #define __CREATE_GL_RENDER_BUFFER_ERR       __ERR_STR(clCreateFromGLBuffer)
159  #define __GET_GL_OBJECT_INFO_ERR            __ERR_STR(clGetGLObjectInfo)
160  #if defined(CL_VERSION_1_2)
161  #define __CREATE_IMAGE_ERR                  __ERR_STR(clCreateImage)
162  #define __CREATE_GL_TEXTURE_ERR             __ERR_STR(clCreateFromGLTexture)
163  #define __IMAGE_DIMENSION_ERR               __ERR_STR(Incorrect image dimensions)
164  #endif 
165  #define __CREATE_SAMPLER_ERR                __ERR_STR(clCreateSampler)
166  #define __SET_MEM_OBJECT_DESTRUCTOR_CALLBACK_ERR __ERR_STR(clSetMemObjectDestructorCallback)
167  #define __CREATE_USER_EVENT_ERR             __ERR_STR(clCreateUserEvent)
168  #define __SET_USER_EVENT_STATUS_ERR         __ERR_STR(clSetUserEventStatus)
169  #define __SET_EVENT_CALLBACK_ERR            __ERR_STR(clSetEventCallback)
170  #define __WAIT_FOR_EVENTS_ERR               __ERR_STR(clWaitForEvents)
171  #define __CREATE_KERNEL_ERR                 __ERR_STR(clCreateKernel)
172  #define __SET_KERNEL_ARGS_ERR               __ERR_STR(clSetKernelArg)
173  #define __CREATE_PROGRAM_WITH_SOURCE_ERR    __ERR_STR(clCreateProgramWithSource)
174  #define __CREATE_PROGRAM_WITH_BINARY_ERR    __ERR_STR(clCreateProgramWithBinary)
175  #if defined(CL_VERSION_1_2)
176  #define __CREATE_PROGRAM_WITH_BUILT_IN_KERNELS_ERR    __ERR_STR(clCreateProgramWithBuiltInKernels)
177  #endif 
178  #define __BUILD_PROGRAM_ERR                 __ERR_STR(clBuildProgram)
179  #if defined(CL_VERSION_1_2)
180  #define __COMPILE_PROGRAM_ERR                  __ERR_STR(clCompileProgram)
181  #define __LINK_PROGRAM_ERR                  __ERR_STR(clLinkProgram)
182  #endif 
183  #define __CREATE_KERNELS_IN_PROGRAM_ERR     __ERR_STR(clCreateKernelsInProgram)
184  #define __CREATE_COMMAND_QUEUE_ERR          __ERR_STR(clCreateCommandQueue)
185  #define __SET_COMMAND_QUEUE_PROPERTY_ERR    __ERR_STR(clSetCommandQueueProperty)
186  #define __ENQUEUE_READ_BUFFER_ERR           __ERR_STR(clEnqueueReadBuffer)
187  #define __ENQUEUE_READ_BUFFER_RECT_ERR      __ERR_STR(clEnqueueReadBufferRect)
188  #define __ENQUEUE_WRITE_BUFFER_ERR          __ERR_STR(clEnqueueWriteBuffer)
189  #define __ENQUEUE_WRITE_BUFFER_RECT_ERR     __ERR_STR(clEnqueueWriteBufferRect)
190  #define __ENQEUE_COPY_BUFFER_ERR            __ERR_STR(clEnqueueCopyBuffer)
191  #define __ENQEUE_COPY_BUFFER_RECT_ERR       __ERR_STR(clEnqueueCopyBufferRect)
192  #define __ENQUEUE_FILL_BUFFER_ERR           __ERR_STR(clEnqueueFillBuffer)
193  #define __ENQUEUE_READ_IMAGE_ERR            __ERR_STR(clEnqueueReadImage)
194  #define __ENQUEUE_WRITE_IMAGE_ERR           __ERR_STR(clEnqueueWriteImage)
195  #define __ENQUEUE_COPY_IMAGE_ERR            __ERR_STR(clEnqueueCopyImage)
196  #define __ENQUEUE_FILL_IMAGE_ERR           __ERR_STR(clEnqueueFillImage)
197  #define __ENQUEUE_COPY_IMAGE_TO_BUFFER_ERR  __ERR_STR(clEnqueueCopyImageToBuffer)
198  #define __ENQUEUE_COPY_BUFFER_TO_IMAGE_ERR  __ERR_STR(clEnqueueCopyBufferToImage)
199  #define __ENQUEUE_MAP_BUFFER_ERR            __ERR_STR(clEnqueueMapBuffer)
200  #define __ENQUEUE_MAP_IMAGE_ERR             __ERR_STR(clEnqueueMapImage)
201  #define __ENQUEUE_UNMAP_MEM_OBJECT_ERR      __ERR_STR(clEnqueueUnMapMemObject)
202  #define __ENQUEUE_NDRANGE_KERNEL_ERR        __ERR_STR(clEnqueueNDRangeKernel)
203  #define __ENQUEUE_TASK_ERR                  __ERR_STR(clEnqueueTask)
204  #define __ENQUEUE_NATIVE_KERNEL             __ERR_STR(clEnqueueNativeKernel)
205  #if defined(CL_VERSION_1_2)
206  #define __ENQUEUE_MIGRATE_MEM_OBJECTS_ERR   __ERR_STR(clEnqueueMigrateMemObjects)
207  #endif 
208  #define __ENQUEUE_ACQUIRE_GL_ERR            __ERR_STR(clEnqueueAcquireGLObjects)
209  #define __ENQUEUE_RELEASE_GL_ERR            __ERR_STR(clEnqueueReleaseGLObjects)
210  #define __RETAIN_ERR                        __ERR_STR(Retain Object)
211  #define __RELEASE_ERR                       __ERR_STR(Release Object)
212  #define __FLUSH_ERR                         __ERR_STR(clFlush)
213  #define __FINISH_ERR                        __ERR_STR(clFinish)
214  #define __VECTOR_CAPACITY_ERR               __ERR_STR(Vector capacity error)
215  #if defined(CL_VERSION_1_2)
216  #define __CREATE_SUB_DEVICES                __ERR_STR(clCreateSubDevices)
217  #else
218  #define __CREATE_SUB_DEVICES                __ERR_STR(clCreateSubDevicesEXT)
219  #endif 
220  #if defined(CL_USE_DEPRECATED_OPENCL_1_1_APIS) || (defined(CL_VERSION_1_1) &amp;&amp; !defined(CL_VERSION_1_2)) 
221  #define __ENQUEUE_MARKER_ERR                __ERR_STR(clEnqueueMarker)
222  #define __ENQUEUE_WAIT_FOR_EVENTS_ERR       __ERR_STR(clEnqueueWaitForEvents)
223  #define __ENQUEUE_BARRIER_ERR               __ERR_STR(clEnqueueBarrier)
224  #define __UNLOAD_COMPILER_ERR               __ERR_STR(clUnloadCompiler)
225  #define __CREATE_GL_TEXTURE_2D_ERR          __ERR_STR(clCreateFromGLTexture2D)
226  #define __CREATE_GL_TEXTURE_3D_ERR          __ERR_STR(clCreateFromGLTexture3D)
227  #define __CREATE_IMAGE2D_ERR                __ERR_STR(clCreateImage2D)
228  #define __CREATE_IMAGE3D_ERR                __ERR_STR(clCreateImage3D)
229  #endif 
230  #endif 
231  #if defined(CL_VERSION_1_2)
232  #define __ENQUEUE_MARKER_WAIT_LIST_ERR                __ERR_STR(clEnqueueMarkerWithWaitList)
233  #define __ENQUEUE_BARRIER_WAIT_LIST_ERR               __ERR_STR(clEnqueueBarrierWithWaitList)
234  #endif 
235  #if !defined(__USE_DEV_STRING) &amp;&amp; !defined(__NO_STD_STRING)
236  typedef std::string STRING_CLASS;
237  #elif !defined(__USE_DEV_STRING) 
238  class CL_EXT_PREFIX__VERSION_1_1_DEPRECATED string CL_EXT_SUFFIX__VERSION_1_1_DEPRECATED
239  {
240  private:
241      ::size_t size_;
242      char * str_;
243  public:
244      string(void) : size_(0), str_(NULL)
245      {
246      }
247      string(const char * str, ::size_t size) :
248          size_(size),
249          str_(NULL)
250      {
251          if( size &gt; 0 ) {
252              str_ = new char[size_+1];
253              if (str_ != NULL) {
254                  memcpy(str_, str, size_  * sizeof(char));
255                  str_[size_] = &#x27;\0&#x27;;
256              }
257              else {
258                  size_ = 0;
259              }
260          }
261      }
262      string(const char * str) :
263          size_(0),
264          str_(NULL)
265      {
266          if( str ) {
267              size_= ::strlen(str);
268          }
269          if( size_ &gt; 0 ) {
270              str_ = new char[size_ + 1];
271              if (str_ != NULL) {
272                  memcpy(str_, str, (size_ + 1) * sizeof(char));
273              }
274          }
275      }
276      void resize( ::size_t n )
277      {
278          if( size_ == n ) {
279              return;
280          }
281          if (n == 0) {
282              if( str_ ) {
283                  delete [] str_;
284              }
285              str_ = NULL;
286              size_ = 0;
287          } 
288          else {
289              char *newString = new char[n + 1];
290              ::size_t copySize = n;
291              if( size_ &lt; n ) {
292                  copySize = size_;
293              }
294              size_ = n;
295              if(str_) {
296                  memcpy(newString, str_, (copySize + 1) * sizeof(char));
297              }
298              if( copySize &lt; size_ ) {
299                  memset(newString + copySize, 0, size_ - copySize);
300              }
301              newString[size_] = &#x27;\0&#x27;;
302              delete [] str_;
303              str_ = newString;
304          }
305      }
306      const char&amp; operator[] ( ::size_t pos ) const
307      {
308          return str_[pos];
309      }
310      char&amp; operator[] ( ::size_t pos )
311      {
312          return str_[pos];
313      }
314      string&amp; operator=(const string&amp; rhs)
315      {
316          if (this == &amp;rhs) {
317              return *this;
318          }
319          if( str_ != NULL ) {
320              delete [] str_;
321              str_ = NULL;
322              size_ = 0;
323          }
324          if (rhs.size_ == 0 || rhs.str_ == NULL) {
325              str_ = NULL;
326              size_ = 0;
327          } 
328          else {
329              str_ = new char[rhs.size_ + 1];
330              size_ = rhs.size_;
331              if (str_ != NULL) {
332                  memcpy(str_, rhs.str_, (size_ + 1) * sizeof(char));
333              }
334              else {
335                  size_ = 0;
336              }
337          }
338          return *this;
339      }
340      string(const string&amp; rhs) :
341          size_(0),
342          str_(NULL)
343      {
344          *this = rhs;
345      }
346      ~string()
347      {
348          delete[] str_;
349          str_ = NULL;
350      }
351      ::size_t size(void) const   { return size_; }
352      ::size_t length(void) const { return size(); }
353      const char * c_str(void) const { return (str_) ? str_ : &quot;&quot;;}
354  };
355  typedef cl::string STRING_CLASS;
356  #endif 
357  #if !defined(__USE_DEV_VECTOR) &amp;&amp; !defined(__NO_STD_VECTOR)
358  #define VECTOR_CLASS std::vector
359  #elif !defined(__USE_DEV_VECTOR) 
360  #define VECTOR_CLASS cl::vector 
361  #if !defined(__MAX_DEFAULT_VECTOR_SIZE)
362  #define __MAX_DEFAULT_VECTOR_SIZE 10
363  #endif
364  template &lt;typename T, unsigned int N = __MAX_DEFAULT_VECTOR_SIZE&gt;
365  class CL_EXT_PREFIX__VERSION_1_1_DEPRECATED vector
366  {
367  private:
368      T data_[N];
369      unsigned int size_;
370  public:
371      vector() :  
372          size_(static_cast&lt;unsigned int&gt;(0))
373      {}
374      ~vector() 
375      {
376          clear();
377      }
378      unsigned int size(void) const
379      {
380          return size_;
381      }
382      void clear()
383      {
384          while(!empty()) {
385              pop_back();
386          }
387      }
388      void push_back (const T&amp; x)
389      { 
390          if (size() &lt; N) {
391              new (&amp;data_[size_]) T(x);
392              size_++;
393          } else {
394              detail::errHandler(CL_MEM_OBJECT_ALLOCATION_FAILURE, __VECTOR_CAPACITY_ERR);
395          }
396      }
397      void pop_back(void)
398      {
399          if (size_ != 0) {
400              --size_;
401              data_[size_].~T();
402          } else {
403              detail::errHandler(CL_MEM_OBJECT_ALLOCATION_FAILURE, __VECTOR_CAPACITY_ERR);
404          }
405      }
406      vector(const vector&lt;T, N&gt;&amp; vec) : 
407          size_(vec.size_)
408      {
409          if (size_ != 0) {
410              assign(vec.begin(), vec.end());
411          }
412      } 
413      vector(unsigned int size, const T&amp; val = T()) :
414          size_(0)
415      {
416          for (unsigned int i = 0; i &lt; size; i++) {
417              push_back(val);
418          }
419      }
420      vector&lt;T, N&gt;&amp; operator=(const vector&lt;T, N&gt;&amp; rhs)
421      {
422          if (this == &amp;rhs) {
423              return *this;
424          }
425          if (rhs.size_ != 0) {	
426              assign(rhs.begin(), rhs.end());
427          } else {
428              clear();
429          }
430          return *this;
431      }
432      bool operator==(vector&lt;T,N&gt; &amp;vec)
433      {
434          if (size() != vec.size()) {
435              return false;
436          }
437          for( unsigned int i = 0; i &lt; size(); ++i ) {
438              if( operator[](i) != vec[i] ) {
439                  return false;
440              }
441          }
442          return true;
443      }
444      operator T* ()             { return data_; }
445      operator const T* () const { return data_; }
446      bool empty (void) const
447      {
448          return size_==0;
449      }
450      unsigned int max_size (void) const
451      {
452          return N;
453      }
454      unsigned int capacity () const
455      {
456          return N;
457      }
458      void resize(unsigned int newSize, T fill = T())
459      {
460          if (newSize &gt; N)
461          {
462              detail::errHandler(CL_MEM_OBJECT_ALLOCATION_FAILURE, __VECTOR_CAPACITY_ERR);
463          }
464          else
465          {
466              while (size_ &lt; newSize)
467              {
468                  new (&amp;data_[size_]) T(fill);
469                  size_++;
470              }
471              while (size_ &gt; newSize)
472              {
473                  --size_;
474                  data_[size_].~T();
475              }
476          }
477      }
478      T&amp; operator[](int index)
479      {
480          return data_[index];
481      }
482      const T&amp; operator[](int index) const
483      {
484          return data_[index];
485      }
486      template&lt;class I&gt;
487      void assign(I start, I end)
488      {
489          clear();   
490          while(start != end) {
491              push_back(*start);
492              start++;
493          }
494      }
495      class iterator
496      {
497      private:
498          const vector&lt;T,N&gt; *vec_;
499          int index_;
500          iterator (const vector&lt;T,N&gt; &amp;vec, int index) :
501              vec_(&amp;vec)
502          {            
503              if( !vec.empty() ) {
504                  index_ = index;
505              } else {
506                  index_ = -1;
507              }
508          }
509      public:
510          iterator(void) : 
511              index_(-1),
512              vec_(NULL)
513          {
514          }
515          iterator(const iterator&amp; rhs) :
516              vec_(rhs.vec_),
517              index_(rhs.index_)
518          {
519          }
520          ~iterator(void) {}
521          static iterator begin(const cl::vector&lt;T,N&gt; &amp;vec)
522          {
523              iterator i(vec, 0);
524              return i;
525          }
526          static iterator end(const cl::vector&lt;T,N&gt; &amp;vec)
527          {
528              iterator i(vec, vec.size());
529              return i;
530          }
531          bool operator==(iterator i)
532          {
533              return ((vec_ == i.vec_) &amp;&amp; 
534                      (index_ == i.index_));
535          }
536          bool operator!=(iterator i)
537          {
538              return (!(*this==i));
539          }
540          iterator&amp; operator++()
541          {
542              ++index_;
543              return *this;
544          }
545          iterator operator++(int)
546          {
547              iterator retVal(*this);
548              ++index_;
549              return retVal;
550          }
551          iterator&amp; operator--()
552          {
553              --index_;
554              return *this;
555          }
556          iterator operator--(int)
557          {
558              iterator retVal(*this);
559              --index_;
560              return retVal;
561          }
562          const T&amp; operator *() const
563          {
564              return (*vec_)[index_];
565          }
566      };
567      iterator begin(void)
568      {
569          return iterator::begin(*this);
570      }
571      iterator begin(void) const
572      {
573          return iterator::begin(*this);
574      }
575      iterator end(void)
576      {
577          return iterator::end(*this);
578      }
579      iterator end(void) const
580      {
581          return iterator::end(*this);
582      }
583      T&amp; front(void)
584      {
585          return data_[0];
586      }
587      T&amp; back(void)
588      {
589          return data_[size_];
590      }
591      const T&amp; front(void) const
592      {
593          return data_[0];
594      }
595      const T&amp; back(void) const
596      {
597          return data_[size_-1];
598      }
599  } CL_EXT_SUFFIX__VERSION_1_1_DEPRECATED;
600  #endif 
601  namespace detail {
602  #define __DEFAULT_NOT_INITIALIZED 1 
603  #define __DEFAULT_BEING_INITIALIZED 2
604  #define __DEFAULT_INITIALIZED 4
605  #ifdef CL_HPP_CPP11_ATOMICS_SUPPORTED
606      inline int compare_exchange(std::atomic&lt;int&gt; * dest, int exchange, int comparand)
607  #else 
608      inline int compare_exchange(volatile int * dest, int exchange, int comparand)
609  #endif 
610      {
611  #ifdef CL_HPP_CPP11_ATOMICS_SUPPORTED
612          std::atomic_compare_exchange_strong(dest, &amp;comparand, exchange);
613          return comparand;
614  #elif _MSC_VER
615          return (int)(_InterlockedCompareExchange(
616              (volatile long*)dest,
617              (long)exchange,
618              (long)comparand));
619  #else 
620          return (__sync_val_compare_and_swap(
621              dest,
622              comparand,
623              exchange));
624  #endif 
625      }
626      inline void fence() {
627  #ifdef CL_HPP_CPP11_ATOMICS_SUPPORTED
628          std::atomic_thread_fence(std::memory_order_seq_cst);
629  #elif _MSC_VER 
630          _ReadWriteBarrier();
631  #else 
632          __sync_synchronize();
633  #endif 
634      }
635  } 
636  template &lt;int N&gt;
637  class size_t
638  { 
639  private:
640      ::size_t data_[N];
641  public:
642      size_t()
643      {
644          for( int i = 0; i &lt; N; ++i ) {
645              data_[i] = 0;
646          }
647      }
648      ::size_t&amp; operator[](int index)
649      {
650          return data_[index];
651      }
652      const ::size_t&amp; operator[](int index) const
653      {
654          return data_[index];
655      }
656      operator ::size_t* ()             { return data_; }
657      operator const ::size_t* () const { return data_; }
658  };
659  namespace detail {
660  template&lt;typename Functor, typename T&gt;
661  inline cl_int getInfoHelper(Functor f, cl_uint name, T* param, long)
662  {
663      return f(name, sizeof(T), param, NULL);
664  }
665  template &lt;typename Func, typename T&gt;
666  inline cl_int getInfoHelper(Func f, cl_uint name, VECTOR_CLASS&lt;T&gt;* param, long)
667  {
668      ::size_t required;
669      cl_int err = f(name, 0, NULL, &amp;required);
670      if (err != CL_SUCCESS) {
671          return err;
672      }
673      T* value = (T*) alloca(required);
674      err = f(name, required, value, NULL);
675      if (err != CL_SUCCESS) {
676          return err;
677      }
678      param-&gt;assign(&amp;value[0], &amp;value[required/sizeof(T)]);
679      return CL_SUCCESS;
680  }
681  template &lt;typename Func, typename T&gt;
682  inline cl_int getInfoHelper(Func f, cl_uint name, VECTOR_CLASS&lt;T&gt;* param, int, typename T::cl_type = 0)
683  {
684      ::size_t required;
685      cl_int err = f(name, 0, NULL, &amp;required);
686      if (err != CL_SUCCESS) {
687          return err;
688      }
689      typename T::cl_type * value = (typename T::cl_type *) alloca(required);
690      err = f(name, required, value, NULL);
691      if (err != CL_SUCCESS) {
692          return err;
693      }
694      ::size_t elements = required / sizeof(typename T::cl_type);
695      param-&gt;assign(&amp;value[0], &amp;value[elements]);
696      for (::size_t i = 0; i &lt; elements; i++)
697      {
698          if (value[i] != NULL)
699          {
700              err = (*param)[i].retain();
701              if (err != CL_SUCCESS) {
702                  return err;
703              }
704          }
705      }
706      return CL_SUCCESS;
707  }
708  template &lt;typename Func&gt;
709  inline cl_int getInfoHelper(Func f, cl_uint name, VECTOR_CLASS&lt;char *&gt;* param, int)
710  {
711      cl_int err = f(name, param-&gt;size() * sizeof(char *), &amp;(*param)[0], NULL);
712      if (err != CL_SUCCESS) {
713          return err;
714      }
715      return CL_SUCCESS;
716  }
717  template &lt;typename Func&gt;
718  inline cl_int getInfoHelper(Func f, cl_uint name, STRING_CLASS* param, long)
719  {
720  #if defined(__NO_STD_VECTOR) || defined(__NO_STD_STRING)
721      ::size_t required;
722      cl_int err = f(name, 0, NULL, &amp;required);
723      if (err != CL_SUCCESS) {
724          return err;
725      }
726      char* value = (char*)alloca(required);
727      err = f(name, required, value, NULL);
728      if (err != CL_SUCCESS) {
729          return err;
730      }
731      *param = value;
732      return CL_SUCCESS;
733  #else 
734      ::size_t required;
735      cl_int err = f(name, 0, NULL, &amp;required);
736      if (err != CL_SUCCESS) {
737          return err;
738      }
739      VECTOR_CLASS&lt;char&gt; value(required);
740      err = f(name, required, value.data(), NULL);
741      if (err != CL_SUCCESS) {
742          return err;
743      }
744      if (param) {
745          param-&gt;assign(value.begin(), value.end());
746      }
747  #endif
748      return CL_SUCCESS;
749  }
750  template &lt;typename Func, ::size_t N&gt;
751  inline cl_int getInfoHelper(Func f, cl_uint name, size_t&lt;N&gt;* param, long)
752  {
753      ::size_t required;
754      cl_int err = f(name, 0, NULL, &amp;required);
755      if (err != CL_SUCCESS) {
756          return err;
757      }
758      ::size_t* value = (::size_t*) alloca(required);
759      err = f(name, required, value, NULL);
760      if (err != CL_SUCCESS) {
761          return err;
762      }
763      for(int i = 0; i &lt; N; ++i) {
764          (*param)[i] = value[i];
765      }
766      return CL_SUCCESS;
767  }
768  template&lt;typename T&gt; struct ReferenceHandler;
769  template&lt;typename Func, typename T&gt;
770  inline cl_int getInfoHelper(Func f, cl_uint name, T* param, int, typename T::cl_type = 0)
771  {
772      typename T::cl_type value;
773      cl_int err = f(name, sizeof(value), &amp;value, NULL);
774      if (err != CL_SUCCESS) {
775          return err;
776      }
777      *param = value;
778      if (value != NULL)
779      {
780          err = param-&gt;retain();
781          if (err != CL_SUCCESS) {
782              return err;
783          }
784      }
785      return CL_SUCCESS;
786  }
787  #define __PARAM_NAME_INFO_1_0(F) \
788      F(cl_platform_info, CL_PLATFORM_PROFILE, STRING_CLASS) \
789      F(cl_platform_info, CL_PLATFORM_VERSION, STRING_CLASS) \
790      F(cl_platform_info, CL_PLATFORM_NAME, STRING_CLASS) \
791      F(cl_platform_info, CL_PLATFORM_VENDOR, STRING_CLASS) \
792      F(cl_platform_info, CL_PLATFORM_EXTENSIONS, STRING_CLASS) \
793      \
794      F(cl_device_info, CL_DEVICE_TYPE, cl_device_type) \
795      F(cl_device_info, CL_DEVICE_VENDOR_ID, cl_uint) \
796      F(cl_device_info, CL_DEVICE_MAX_COMPUTE_UNITS, cl_uint) \
797      F(cl_device_info, CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS, cl_uint) \
798      F(cl_device_info, CL_DEVICE_MAX_WORK_GROUP_SIZE, ::size_t) \
799      F(cl_device_info, CL_DEVICE_MAX_WORK_ITEM_SIZES, VECTOR_CLASS&lt; ::size_t&gt;) \
800      F(cl_device_info, CL_DEVICE_PREFERRED_VECTOR_WIDTH_CHAR, cl_uint) \
801      F(cl_device_info, CL_DEVICE_PREFERRED_VECTOR_WIDTH_SHORT, cl_uint) \
802      F(cl_device_info, CL_DEVICE_PREFERRED_VECTOR_WIDTH_INT, cl_uint) \
803      F(cl_device_info, CL_DEVICE_PREFERRED_VECTOR_WIDTH_LONG, cl_uint) \
804      F(cl_device_info, CL_DEVICE_PREFERRED_VECTOR_WIDTH_FLOAT, cl_uint) \
805      F(cl_device_info, CL_DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE, cl_uint) \
806      F(cl_device_info, CL_DEVICE_MAX_CLOCK_FREQUENCY, cl_uint) \
807      F(cl_device_info, CL_DEVICE_ADDRESS_BITS, cl_uint) \
808      F(cl_device_info, CL_DEVICE_MAX_READ_IMAGE_ARGS, cl_uint) \
809      F(cl_device_info, CL_DEVICE_MAX_WRITE_IMAGE_ARGS, cl_uint) \
810      F(cl_device_info, CL_DEVICE_MAX_MEM_ALLOC_SIZE, cl_ulong) \
811      F(cl_device_info, CL_DEVICE_IMAGE2D_MAX_WIDTH, ::size_t) \
812      F(cl_device_info, CL_DEVICE_IMAGE2D_MAX_HEIGHT, ::size_t) \
813      F(cl_device_info, CL_DEVICE_IMAGE3D_MAX_WIDTH, ::size_t) \
814      F(cl_device_info, CL_DEVICE_IMAGE3D_MAX_HEIGHT, ::size_t) \
815      F(cl_device_info, CL_DEVICE_IMAGE3D_MAX_DEPTH, ::size_t) \
816      F(cl_device_info, CL_DEVICE_IMAGE_SUPPORT, cl_bool) \
817      F(cl_device_info, CL_DEVICE_MAX_PARAMETER_SIZE, ::size_t) \
818      F(cl_device_info, CL_DEVICE_MAX_SAMPLERS, cl_uint) \
819      F(cl_device_info, CL_DEVICE_MEM_BASE_ADDR_ALIGN, cl_uint) \
820      F(cl_device_info, CL_DEVICE_MIN_DATA_TYPE_ALIGN_SIZE, cl_uint) \
821      F(cl_device_info, CL_DEVICE_SINGLE_FP_CONFIG, cl_device_fp_config) \
822      F(cl_device_info, CL_DEVICE_GLOBAL_MEM_CACHE_TYPE, cl_device_mem_cache_type) \
823      F(cl_device_info, CL_DEVICE_GLOBAL_MEM_CACHELINE_SIZE, cl_uint)\
824      F(cl_device_info, CL_DEVICE_GLOBAL_MEM_CACHE_SIZE, cl_ulong) \
825      F(cl_device_info, CL_DEVICE_GLOBAL_MEM_SIZE, cl_ulong) \
826      F(cl_device_info, CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE, cl_ulong) \
827      F(cl_device_info, CL_DEVICE_MAX_CONSTANT_ARGS, cl_uint) \
828      F(cl_device_info, CL_DEVICE_LOCAL_MEM_TYPE, cl_device_local_mem_type) \
829      F(cl_device_info, CL_DEVICE_LOCAL_MEM_SIZE, cl_ulong) \
830      F(cl_device_info, CL_DEVICE_ERROR_CORRECTION_SUPPORT, cl_bool) \
831      F(cl_device_info, CL_DEVICE_PROFILING_TIMER_RESOLUTION, ::size_t) \
832      F(cl_device_info, CL_DEVICE_ENDIAN_LITTLE, cl_bool) \
833      F(cl_device_info, CL_DEVICE_AVAILABLE, cl_bool) \
834      F(cl_device_info, CL_DEVICE_COMPILER_AVAILABLE, cl_bool) \
835      F(cl_device_info, CL_DEVICE_EXECUTION_CAPABILITIES, cl_device_exec_capabilities) \
836      F(cl_device_info, CL_DEVICE_QUEUE_PROPERTIES, cl_command_queue_properties) \
837      F(cl_device_info, CL_DEVICE_PLATFORM, cl_platform_id) \
838      F(cl_device_info, CL_DEVICE_NAME, STRING_CLASS) \
839      F(cl_device_info, CL_DEVICE_VENDOR, STRING_CLASS) \
840      F(cl_device_info, CL_DRIVER_VERSION, STRING_CLASS) \
841      F(cl_device_info, CL_DEVICE_PROFILE, STRING_CLASS) \
842      F(cl_device_info, CL_DEVICE_VERSION, STRING_CLASS) \
843      F(cl_device_info, CL_DEVICE_EXTENSIONS, STRING_CLASS) \
844      \
845      F(cl_context_info, CL_CONTEXT_REFERENCE_COUNT, cl_uint) \
846      F(cl_context_info, CL_CONTEXT_DEVICES, VECTOR_CLASS&lt;Device&gt;) \
847      F(cl_context_info, CL_CONTEXT_PROPERTIES, VECTOR_CLASS&lt;cl_context_properties&gt;) \
848      \
849      F(cl_event_info, CL_EVENT_COMMAND_QUEUE, cl::CommandQueue) \
850      F(cl_event_info, CL_EVENT_COMMAND_TYPE, cl_command_type) \
851      F(cl_event_info, CL_EVENT_REFERENCE_COUNT, cl_uint) \
852      F(cl_event_info, CL_EVENT_COMMAND_EXECUTION_STATUS, cl_int) \
853      \
854      F(cl_profiling_info, CL_PROFILING_COMMAND_QUEUED, cl_ulong) \
855      F(cl_profiling_info, CL_PROFILING_COMMAND_SUBMIT, cl_ulong) \
856      F(cl_profiling_info, CL_PROFILING_COMMAND_START, cl_ulong) \
857      F(cl_profiling_info, CL_PROFILING_COMMAND_END, cl_ulong) \
858      \
859      F(cl_mem_info, CL_MEM_TYPE, cl_mem_object_type) \
860      F(cl_mem_info, CL_MEM_FLAGS, cl_mem_flags) \
861      F(cl_mem_info, CL_MEM_SIZE, ::size_t) \
862      F(cl_mem_info, CL_MEM_HOST_PTR, void*) \
863      F(cl_mem_info, CL_MEM_MAP_COUNT, cl_uint) \
864      F(cl_mem_info, CL_MEM_REFERENCE_COUNT, cl_uint) \
865      F(cl_mem_info, CL_MEM_CONTEXT, cl::Context) \
866      \
867      F(cl_image_info, CL_IMAGE_FORMAT, cl_image_format) \
868      F(cl_image_info, CL_IMAGE_ELEMENT_SIZE, ::size_t) \
869      F(cl_image_info, CL_IMAGE_ROW_PITCH, ::size_t) \
870      F(cl_image_info, CL_IMAGE_SLICE_PITCH, ::size_t) \
871      F(cl_image_info, CL_IMAGE_WIDTH, ::size_t) \
872      F(cl_image_info, CL_IMAGE_HEIGHT, ::size_t) \
873      F(cl_image_info, CL_IMAGE_DEPTH, ::size_t) \
874      \
875      F(cl_sampler_info, CL_SAMPLER_REFERENCE_COUNT, cl_uint) \
876      F(cl_sampler_info, CL_SAMPLER_CONTEXT, cl::Context) \
877      F(cl_sampler_info, CL_SAMPLER_NORMALIZED_COORDS, cl_bool) \
878      F(cl_sampler_info, CL_SAMPLER_ADDRESSING_MODE, cl_addressing_mode) \
879      F(cl_sampler_info, CL_SAMPLER_FILTER_MODE, cl_filter_mode) \
880      \
881      F(cl_program_info, CL_PROGRAM_REFERENCE_COUNT, cl_uint) \
882      F(cl_program_info, CL_PROGRAM_CONTEXT, cl::Context) \
883      F(cl_program_info, CL_PROGRAM_NUM_DEVICES, cl_uint) \
884      F(cl_program_info, CL_PROGRAM_DEVICES, VECTOR_CLASS&lt;Device&gt;) \
885      F(cl_program_info, CL_PROGRAM_SOURCE, STRING_CLASS) \
886      F(cl_program_info, CL_PROGRAM_BINARY_SIZES, VECTOR_CLASS&lt; ::size_t&gt;) \
887      F(cl_program_info, CL_PROGRAM_BINARIES, VECTOR_CLASS&lt;char *&gt;) \
888      \
889      F(cl_program_build_info, CL_PROGRAM_BUILD_STATUS, cl_build_status) \
890      F(cl_program_build_info, CL_PROGRAM_BUILD_OPTIONS, STRING_CLASS) \
891      F(cl_program_build_info, CL_PROGRAM_BUILD_LOG, STRING_CLASS) \
892      \
893      F(cl_kernel_info, CL_KERNEL_FUNCTION_NAME, STRING_CLASS) \
894      F(cl_kernel_info, CL_KERNEL_NUM_ARGS, cl_uint) \
895      F(cl_kernel_info, CL_KERNEL_REFERENCE_COUNT, cl_uint) \
896      F(cl_kernel_info, CL_KERNEL_CONTEXT, cl::Context) \
897      F(cl_kernel_info, CL_KERNEL_PROGRAM, cl::Program) \
898      \
899      F(cl_kernel_work_group_info, CL_KERNEL_WORK_GROUP_SIZE, ::size_t) \
900      F(cl_kernel_work_group_info, CL_KERNEL_COMPILE_WORK_GROUP_SIZE, cl::size_t&lt;3&gt;) \
901      F(cl_kernel_work_group_info, CL_KERNEL_LOCAL_MEM_SIZE, cl_ulong) \
902      \
903      F(cl_command_queue_info, CL_QUEUE_CONTEXT, cl::Context) \
904      F(cl_command_queue_info, CL_QUEUE_DEVICE, cl::Device) \
905      F(cl_command_queue_info, CL_QUEUE_REFERENCE_COUNT, cl_uint) \
906      F(cl_command_queue_info, CL_QUEUE_PROPERTIES, cl_command_queue_properties)
907  #if defined(CL_VERSION_1_1)
908  #define __PARAM_NAME_INFO_1_1(F) \
909      F(cl_context_info, CL_CONTEXT_NUM_DEVICES, cl_uint)\
910      F(cl_device_info, CL_DEVICE_PREFERRED_VECTOR_WIDTH_HALF, cl_uint) \
911      F(cl_device_info, CL_DEVICE_NATIVE_VECTOR_WIDTH_CHAR, cl_uint) \
912      F(cl_device_info, CL_DEVICE_NATIVE_VECTOR_WIDTH_SHORT, cl_uint) \
913      F(cl_device_info, CL_DEVICE_NATIVE_VECTOR_WIDTH_INT, cl_uint) \
914      F(cl_device_info, CL_DEVICE_NATIVE_VECTOR_WIDTH_LONG, cl_uint) \
915      F(cl_device_info, CL_DEVICE_NATIVE_VECTOR_WIDTH_FLOAT, cl_uint) \
916      F(cl_device_info, CL_DEVICE_NATIVE_VECTOR_WIDTH_DOUBLE, cl_uint) \
917      F(cl_device_info, CL_DEVICE_NATIVE_VECTOR_WIDTH_HALF, cl_uint) \
918      F(cl_device_info, CL_DEVICE_DOUBLE_FP_CONFIG, cl_device_fp_config) \
919      F(cl_device_info, CL_DEVICE_HALF_FP_CONFIG, cl_device_fp_config) \
920      F(cl_device_info, CL_DEVICE_HOST_UNIFIED_MEMORY, cl_bool) \
921      F(cl_device_info, CL_DEVICE_OPENCL_C_VERSION, STRING_CLASS) \
922      \
923      F(cl_mem_info, CL_MEM_ASSOCIATED_MEMOBJECT, cl::Memory) \
924      F(cl_mem_info, CL_MEM_OFFSET, ::size_t) \
925      \
926      F(cl_kernel_work_group_info, CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE, ::size_t) \
927      F(cl_kernel_work_group_info, CL_KERNEL_PRIVATE_MEM_SIZE, cl_ulong) \
928      \
929      F(cl_event_info, CL_EVENT_CONTEXT, cl::Context)
930  #endif 
931  #if defined(CL_VERSION_1_2)
932  #define __PARAM_NAME_INFO_1_2(F) \
933      F(cl_image_info, CL_IMAGE_BUFFER, cl::Buffer) \
934      \
935      F(cl_program_info, CL_PROGRAM_NUM_KERNELS, ::size_t) \
936      F(cl_program_info, CL_PROGRAM_KERNEL_NAMES, STRING_CLASS) \
937      \
938      F(cl_program_build_info, CL_PROGRAM_BINARY_TYPE, cl_program_binary_type) \
939      \
940      F(cl_kernel_info, CL_KERNEL_ATTRIBUTES, STRING_CLASS) \
941      \
942      F(cl_kernel_arg_info, CL_KERNEL_ARG_ADDRESS_QUALIFIER, cl_kernel_arg_address_qualifier) \
943      F(cl_kernel_arg_info, CL_KERNEL_ARG_ACCESS_QUALIFIER, cl_kernel_arg_access_qualifier) \
944      F(cl_kernel_arg_info, CL_KERNEL_ARG_TYPE_NAME, STRING_CLASS) \
945      F(cl_kernel_arg_info, CL_KERNEL_ARG_NAME, STRING_CLASS) \
946      F(cl_kernel_arg_info, CL_KERNEL_ARG_TYPE_QUALIFIER, cl_kernel_arg_type_qualifier) \
947      \
948      F(cl_device_info, CL_DEVICE_PARENT_DEVICE, cl_device_id) \
949      F(cl_device_info, CL_DEVICE_PARTITION_PROPERTIES, VECTOR_CLASS&lt;cl_device_partition_property&gt;) \
950      F(cl_device_info, CL_DEVICE_PARTITION_TYPE, VECTOR_CLASS&lt;cl_device_partition_property&gt;)  \
951      F(cl_device_info, CL_DEVICE_REFERENCE_COUNT, cl_uint) \
952      F(cl_device_info, CL_DEVICE_PREFERRED_INTEROP_USER_SYNC, ::size_t) \
953      F(cl_device_info, CL_DEVICE_PARTITION_AFFINITY_DOMAIN, cl_device_affinity_domain) \
954      F(cl_device_info, CL_DEVICE_BUILT_IN_KERNELS, STRING_CLASS)
955  #endif 
956  #if defined(USE_CL_DEVICE_FISSION)
957  #define __PARAM_NAME_DEVICE_FISSION(F) \
958      F(cl_device_info, CL_DEVICE_PARENT_DEVICE_EXT, cl_device_id) \
959      F(cl_device_info, CL_DEVICE_PARTITION_TYPES_EXT, VECTOR_CLASS&lt;cl_device_partition_property_ext&gt;) \
960      F(cl_device_info, CL_DEVICE_AFFINITY_DOMAINS_EXT, VECTOR_CLASS&lt;cl_device_partition_property_ext&gt;) \
961      F(cl_device_info, CL_DEVICE_REFERENCE_COUNT_EXT , cl_uint) \
962      F(cl_device_info, CL_DEVICE_PARTITION_STYLE_EXT, VECTOR_CLASS&lt;cl_device_partition_property_ext&gt;)
963  #endif 
964  template &lt;typename enum_type, cl_int Name&gt;
965  struct param_traits {};
966  #define __CL_DECLARE_PARAM_TRAITS(token, param_name, T) \
967  struct token;                                        \
968  template&lt;&gt;                                           \
969  struct param_traits&lt;detail:: token,param_name&gt;       \
970  {                                                    \
971      enum { value = param_name };                     \
972      typedef T param_type;                            \
973  };
974  __PARAM_NAME_INFO_1_0(__CL_DECLARE_PARAM_TRAITS)
975  #if defined(CL_VERSION_1_1)
976  __PARAM_NAME_INFO_1_1(__CL_DECLARE_PARAM_TRAITS)
977  #endif 
978  #if defined(CL_VERSION_1_2)
979  __PARAM_NAME_INFO_1_2(__CL_DECLARE_PARAM_TRAITS)
980  #endif 
981  #if defined(USE_CL_DEVICE_FISSION)
982  __PARAM_NAME_DEVICE_FISSION(__CL_DECLARE_PARAM_TRAITS);
983  #endif 
984  #ifdef CL_PLATFORM_ICD_SUFFIX_KHR
985  __CL_DECLARE_PARAM_TRAITS(cl_platform_info, CL_PLATFORM_ICD_SUFFIX_KHR, STRING_CLASS)
986  #endif
987  #ifdef CL_DEVICE_PROFILING_TIMER_OFFSET_AMD
988  __CL_DECLARE_PARAM_TRAITS(cl_device_info, CL_DEVICE_PROFILING_TIMER_OFFSET_AMD, cl_ulong)
989  #endif
990  #ifdef CL_DEVICE_GLOBAL_FREE_MEMORY_AMD
991  __CL_DECLARE_PARAM_TRAITS(cl_device_info, CL_DEVICE_GLOBAL_FREE_MEMORY_AMD, VECTOR_CLASS&lt; ::size_t&gt;)
992  #endif
993  #ifdef CL_DEVICE_SIMD_PER_COMPUTE_UNIT_AMD
994  __CL_DECLARE_PARAM_TRAITS(cl_device_info, CL_DEVICE_SIMD_PER_COMPUTE_UNIT_AMD, cl_uint)
995  #endif
996  #ifdef CL_DEVICE_SIMD_WIDTH_AMD
997  __CL_DECLARE_PARAM_TRAITS(cl_device_info, CL_DEVICE_SIMD_WIDTH_AMD, cl_uint)
998  #endif
999  #ifdef CL_DEVICE_SIMD_INSTRUCTION_WIDTH_AMD
1000  __CL_DECLARE_PARAM_TRAITS(cl_device_info, CL_DEVICE_SIMD_INSTRUCTION_WIDTH_AMD, cl_uint)
1001  #endif
1002  #ifdef CL_DEVICE_WAVEFRONT_WIDTH_AMD
1003  __CL_DECLARE_PARAM_TRAITS(cl_device_info, CL_DEVICE_WAVEFRONT_WIDTH_AMD, cl_uint)
1004  #endif
1005  #ifdef CL_DEVICE_GLOBAL_MEM_CHANNELS_AMD
1006  __CL_DECLARE_PARAM_TRAITS(cl_device_info, CL_DEVICE_GLOBAL_MEM_CHANNELS_AMD, cl_uint)
1007  #endif
1008  #ifdef CL_DEVICE_GLOBAL_MEM_CHANNEL_BANKS_AMD
1009  __CL_DECLARE_PARAM_TRAITS(cl_device_info, CL_DEVICE_GLOBAL_MEM_CHANNEL_BANKS_AMD, cl_uint)
1010  #endif
1011  #ifdef CL_DEVICE_GLOBAL_MEM_CHANNEL_BANK_WIDTH_AMD
1012  __CL_DECLARE_PARAM_TRAITS(cl_device_info, CL_DEVICE_GLOBAL_MEM_CHANNEL_BANK_WIDTH_AMD, cl_uint)
1013  #endif
1014  #ifdef CL_DEVICE_LOCAL_MEM_SIZE_PER_COMPUTE_UNIT_AMD
1015  __CL_DECLARE_PARAM_TRAITS(cl_device_info, CL_DEVICE_LOCAL_MEM_SIZE_PER_COMPUTE_UNIT_AMD, cl_uint)
1016  #endif
1017  #ifdef CL_DEVICE_LOCAL_MEM_BANKS_AMD
1018  __CL_DECLARE_PARAM_TRAITS(cl_device_info, CL_DEVICE_LOCAL_MEM_BANKS_AMD, cl_uint)
1019  #endif
1020  #ifdef CL_DEVICE_COMPUTE_CAPABILITY_MAJOR_NV
1021  __CL_DECLARE_PARAM_TRAITS(cl_device_info, CL_DEVICE_COMPUTE_CAPABILITY_MAJOR_NV, cl_uint)
1022  #endif
1023  #ifdef CL_DEVICE_COMPUTE_CAPABILITY_MINOR_NV
1024  __CL_DECLARE_PARAM_TRAITS(cl_device_info, CL_DEVICE_COMPUTE_CAPABILITY_MINOR_NV, cl_uint)
1025  #endif
1026  #ifdef CL_DEVICE_REGISTERS_PER_BLOCK_NV
1027  __CL_DECLARE_PARAM_TRAITS(cl_device_info, CL_DEVICE_REGISTERS_PER_BLOCK_NV, cl_uint)
1028  #endif
1029  #ifdef CL_DEVICE_WARP_SIZE_NV
1030  __CL_DECLARE_PARAM_TRAITS(cl_device_info, CL_DEVICE_WARP_SIZE_NV, cl_uint)
1031  #endif
1032  #ifdef CL_DEVICE_GPU_OVERLAP_NV
1033  __CL_DECLARE_PARAM_TRAITS(cl_device_info, CL_DEVICE_GPU_OVERLAP_NV, cl_bool)
1034  #endif
1035  #ifdef CL_DEVICE_KERNEL_EXEC_TIMEOUT_NV
1036  __CL_DECLARE_PARAM_TRAITS(cl_device_info, CL_DEVICE_KERNEL_EXEC_TIMEOUT_NV, cl_bool)
1037  #endif
1038  #ifdef CL_DEVICE_INTEGRATED_MEMORY_NV
1039  __CL_DECLARE_PARAM_TRAITS(cl_device_info, CL_DEVICE_INTEGRATED_MEMORY_NV, cl_bool)
1040  #endif
1041  template &lt;typename Func, typename T&gt;
1042  inline cl_int
1043  getInfo(Func f, cl_uint name, T* param)
1044  {
1045      return getInfoHelper(f, name, param, 0);
1046  }
1047  template &lt;typename Func, typename Arg0&gt;
1048  struct GetInfoFunctor0
1049  {
1050      Func f_; const Arg0&amp; arg0_;
1051      cl_int operator ()(
1052          cl_uint param, ::size_t size, void* value, ::size_t* size_ret)
1053      { return f_(arg0_, param, size, value, size_ret); }
1054  };
1055  template &lt;typename Func, typename Arg0, typename Arg1&gt;
1056  struct GetInfoFunctor1
1057  {
1058      Func f_; const Arg0&amp; arg0_; const Arg1&amp; arg1_;
1059      cl_int operator ()(
1060          cl_uint param, ::size_t size, void* value, ::size_t* size_ret)
1061      { return f_(arg0_, arg1_, param, size, value, size_ret); }
1062  };
1063  template &lt;typename Func, typename Arg0, typename T&gt;
1064  inline cl_int
1065  getInfo(Func f, const Arg0&amp; arg0, cl_uint name, T* param)
1066  {
1067      GetInfoFunctor0&lt;Func, Arg0&gt; f0 = { f, arg0 };
1068      return getInfoHelper(f0, name, param, 0);
1069  }
1070  template &lt;typename Func, typename Arg0, typename Arg1, typename T&gt;
1071  inline cl_int
1072  getInfo(Func f, const Arg0&amp; arg0, const Arg1&amp; arg1, cl_uint name, T* param)
1073  {
1074      GetInfoFunctor1&lt;Func, Arg0, Arg1&gt; f0 = { f, arg0, arg1 };
1075      return getInfoHelper(f0, name, param, 0);
1076  }
1077  template&lt;typename T&gt;
1078  struct ReferenceHandler
1079  { };
1080  #if defined(CL_VERSION_1_2)
1081  template &lt;&gt;
1082  struct ReferenceHandler&lt;cl_device_id&gt;
1083  {
1084      static cl_int retain(cl_device_id device)
1085      { return ::clRetainDevice(device); }
1086      static cl_int release(cl_device_id device)
1087      { return ::clReleaseDevice(device); }
1088  };
1089  #else 
1090  template &lt;&gt;
1091  struct ReferenceHandler&lt;cl_device_id&gt;
1092  {
1093      static cl_int retain(cl_device_id)
1094      { return CL_SUCCESS; }
1095      static cl_int release(cl_device_id)
1096      { return CL_SUCCESS; }
1097  };
1098  #endif 
1099  template &lt;&gt;
1100  struct ReferenceHandler&lt;cl_platform_id&gt;
1101  {
1102      static cl_int retain(cl_platform_id)
1103      { return CL_SUCCESS; }
1104      static cl_int release(cl_platform_id)
1105      { return CL_SUCCESS; }
1106  };
1107  template &lt;&gt;
1108  struct ReferenceHandler&lt;cl_context&gt;
1109  {
1110      static cl_int retain(cl_context context)
1111      { return ::clRetainContext(context); }
1112      static cl_int release(cl_context context)
1113      { return ::clReleaseContext(context); }
1114  };
1115  template &lt;&gt;
1116  struct ReferenceHandler&lt;cl_command_queue&gt;
1117  {
1118      static cl_int retain(cl_command_queue queue)
1119      { return ::clRetainCommandQueue(queue); }
1120      static cl_int release(cl_command_queue queue)
1121      { return ::clReleaseCommandQueue(queue); }
1122  };
1123  template &lt;&gt;
1124  struct ReferenceHandler&lt;cl_mem&gt;
1125  {
1126      static cl_int retain(cl_mem memory)
1127      { return ::clRetainMemObject(memory); }
1128      static cl_int release(cl_mem memory)
1129      { return ::clReleaseMemObject(memory); }
1130  };
1131  template &lt;&gt;
1132  struct ReferenceHandler&lt;cl_sampler&gt;
1133  {
1134      static cl_int retain(cl_sampler sampler)
1135      { return ::clRetainSampler(sampler); }
1136      static cl_int release(cl_sampler sampler)
1137      { return ::clReleaseSampler(sampler); }
1138  };
1139  template &lt;&gt;
1140  struct ReferenceHandler&lt;cl_program&gt;
1141  {
1142      static cl_int retain(cl_program program)
1143      { return ::clRetainProgram(program); }
1144      static cl_int release(cl_program program)
1145      { return ::clReleaseProgram(program); }
1146  };
1147  template &lt;&gt;
1148  struct ReferenceHandler&lt;cl_kernel&gt;
1149  {
1150      static cl_int retain(cl_kernel kernel)
1151      { return ::clRetainKernel(kernel); }
1152      static cl_int release(cl_kernel kernel)
1153      { return ::clReleaseKernel(kernel); }
1154  };
1155  template &lt;&gt;
1156  struct ReferenceHandler&lt;cl_event&gt;
1157  {
1158      static cl_int retain(cl_event event)
1159      { return ::clRetainEvent(event); }
1160      static cl_int release(cl_event event)
1161      { return ::clReleaseEvent(event); }
1162  };
1163  static cl_uint getVersion(const char *versionInfo)
1164  {
1165      int highVersion = 0;
1166      int lowVersion = 0;
1167      int index = 7;
1168      while(versionInfo[index] != &#x27;.&#x27; ) {
1169          highVersion *= 10;
1170          highVersion += versionInfo[index]-&#x27;0&#x27;;
1171          ++index;
1172      }
1173      ++index;
1174      while(versionInfo[index] != &#x27; &#x27; &amp;&amp;  versionInfo[index] != &#x27;\0&#x27;) {
1175          lowVersion *= 10;
1176          lowVersion += versionInfo[index]-&#x27;0&#x27;;
1177          ++index;
1178      }
1179      return (highVersion &lt;&lt; 16) | lowVersion;
1180  }
1181  static cl_uint getPlatformVersion(cl_platform_id platform)
1182  {
1183      ::size_t size = 0;
1184      clGetPlatformInfo(platform, CL_PLATFORM_VERSION, 0, NULL, &amp;size);
1185      char *versionInfo = (char *) alloca(size);
1186      clGetPlatformInfo(platform, CL_PLATFORM_VERSION, size, &amp;versionInfo[0], &amp;size);
1187      return getVersion(versionInfo);
1188  }
1189  static cl_uint getDevicePlatformVersion(cl_device_id device)
1190  {
1191      cl_platform_id platform;
1192      clGetDeviceInfo(device, CL_DEVICE_PLATFORM, sizeof(platform), &amp;platform, NULL);
1193      return getPlatformVersion(platform);
1194  }
1195  #if defined(CL_VERSION_1_2) &amp;&amp; defined(CL_USE_DEPRECATED_OPENCL_1_1_APIS)
1196  static cl_uint getContextPlatformVersion(cl_context context)
1197  {
1198      ::size_t size = 0;
1199      clGetContextInfo(context, CL_CONTEXT_DEVICES, 0, NULL, &amp;size);
1200      if (size == 0)
1201          return 0;
1202      cl_device_id *devices = (cl_device_id *) alloca(size);
1203      clGetContextInfo(context, CL_CONTEXT_DEVICES, size, devices, NULL);
1204      return getDevicePlatformVersion(devices[0]);
1205  }
1206  #endif 
1207  template &lt;typename T&gt;
1208  class Wrapper
1209  {
1210  public:
1211      typedef T cl_type;
1212  protected:
1213      cl_type object_;
1214  public:
1215      Wrapper() : object_(NULL) { }
1216      Wrapper(const cl_type &amp;obj) : object_(obj) { }
1217      ~Wrapper()
1218      {
1219          if (object_ != NULL) { release(); }
1220      }
1221      Wrapper(const Wrapper&lt;cl_type&gt;&amp; rhs)
1222      {
1223          object_ = rhs.object_;
1224          if (object_ != NULL) { detail::errHandler(retain(), __RETAIN_ERR); }
1225      }
1226  #if defined(CL_HPP_RVALUE_REFERENCES_SUPPORTED)
1227      Wrapper(Wrapper&lt;cl_type&gt;&amp;&amp; rhs) CL_HPP_NOEXCEPT
1228      {
1229          object_ = rhs.object_;
1230          rhs.object_ = NULL;
1231      }
1232  #endif
1233      Wrapper&lt;cl_type&gt;&amp; operator = (const Wrapper&lt;cl_type&gt;&amp; rhs)
1234      {
1235          if (this != &amp;rhs) {
1236              if (object_ != NULL) { detail::errHandler(release(), __RELEASE_ERR); }
1237              object_ = rhs.object_;
1238              if (object_ != NULL) { detail::errHandler(retain(), __RETAIN_ERR); }
1239          }
1240          return *this;
1241      }
1242  #if defined(CL_HPP_RVALUE_REFERENCES_SUPPORTED)
1243      Wrapper&lt;cl_type&gt;&amp; operator = (Wrapper&lt;cl_type&gt;&amp;&amp; rhs)
1244      {
1245          if (this != &amp;rhs) {
1246              if (object_ != NULL) { detail::errHandler(release(), __RELEASE_ERR); }
1247              object_ = rhs.object_;
1248              rhs.object_ = NULL;
1249          }
1250          return *this;
1251      }
1252  #endif
1253      Wrapper&lt;cl_type&gt;&amp; operator = (const cl_type &amp;rhs)
1254      {
1255          if (object_ != NULL) { detail::errHandler(release(), __RELEASE_ERR); }
1256          object_ = rhs;
1257          return *this;
1258      }
1259      cl_type operator ()() const { return object_; }
1260      cl_type&amp; operator ()() { return object_; }
1261  protected:
1262      template&lt;typename Func, typename U&gt;
1263      friend inline cl_int getInfoHelper(Func, cl_uint, U*, int, typename U::cl_type);
1264      cl_int retain() const
1265      {
1266          return ReferenceHandler&lt;cl_type&gt;::retain(object_);
1267      }
1268      cl_int release() const
1269      {
1270          return ReferenceHandler&lt;cl_type&gt;::release(object_);
1271      }
1272  };
1273  template &lt;&gt;
1274  class Wrapper&lt;cl_device_id&gt;
1275  {
1276  public:
1277      typedef cl_device_id cl_type;
1278  protected:
1279      cl_type object_;
1280      bool referenceCountable_;
1281      static bool isReferenceCountable(cl_device_id device)
1282      {
1283          bool retVal = false;
1284          if (device != NULL) {
1285              int version = getDevicePlatformVersion(device);
1286              if(version &gt; ((1 &lt;&lt; 16) + 1)) {
1287                  retVal = true;
1288              }
1289          }
1290          return retVal;
1291      }
1292  public:
1293      Wrapper() : object_(NULL), referenceCountable_(false) 
1294      { 
1295      }
1296      Wrapper(const cl_type &amp;obj) : object_(obj), referenceCountable_(false) 
1297      {
1298          referenceCountable_ = isReferenceCountable(obj); 
1299      }
1300      ~Wrapper()
1301      {
1302          if (object_ != NULL) { release(); }
1303      }
1304      Wrapper(const Wrapper&lt;cl_type&gt;&amp; rhs)
1305      {
1306          object_ = rhs.object_;
1307          referenceCountable_ = isReferenceCountable(object_); 
1308          if (object_ != NULL) { detail::errHandler(retain(), __RETAIN_ERR); }
1309      }
1310  #if defined(CL_HPP_RVALUE_REFERENCES_SUPPORTED)
1311      Wrapper(Wrapper&lt;cl_type&gt;&amp;&amp; rhs) CL_HPP_NOEXCEPT
1312      {
1313          object_ = rhs.object_;
1314          referenceCountable_ = rhs.referenceCountable_;
1315          rhs.object_ = NULL;
1316          rhs.referenceCountable_ = false;
1317      }
1318  #endif
1319      Wrapper&lt;cl_type&gt;&amp; operator = (const Wrapper&lt;cl_type&gt;&amp; rhs)
1320      {
1321          if (this != &amp;rhs) {
1322              if (object_ != NULL) { detail::errHandler(release(), __RELEASE_ERR); }
1323              object_ = rhs.object_;
1324              referenceCountable_ = rhs.referenceCountable_;
1325              if (object_ != NULL) { detail::errHandler(retain(), __RETAIN_ERR); }
1326          }
1327          return *this;
1328      }
1329  #if defined(CL_HPP_RVALUE_REFERENCES_SUPPORTED)
1330      Wrapper&lt;cl_type&gt;&amp; operator = (Wrapper&lt;cl_type&gt;&amp;&amp; rhs)
1331      {
1332          if (this != &amp;rhs) {
1333              if (object_ != NULL) { detail::errHandler(release(), __RELEASE_ERR); }
1334              object_ = rhs.object_;
1335              referenceCountable_ = rhs.referenceCountable_;
1336              rhs.object_ = NULL;
1337              rhs.referenceCountable_ = false;
1338          }
1339          return *this;
1340      }
1341  #endif
1342      Wrapper&lt;cl_type&gt;&amp; operator = (const cl_type &amp;rhs)
1343      {
1344          if (object_ != NULL) { detail::errHandler(release(), __RELEASE_ERR); }
1345          object_ = rhs;
1346          referenceCountable_ = isReferenceCountable(object_); 
1347          return *this;
1348      }
1349      cl_type operator ()() const { return object_; }
1350      cl_type&amp; operator ()() { return object_; }
1351  protected:
1352      template&lt;typename Func, typename U&gt;
1353      friend inline cl_int getInfoHelper(Func, cl_uint, U*, int, typename U::cl_type);
1354      template&lt;typename Func, typename U&gt;
1355      friend inline cl_int getInfoHelper(Func, cl_uint, VECTOR_CLASS&lt;U&gt;*, int, typename U::cl_type);
1356      cl_int retain() const
1357      {
1358          if( referenceCountable_ ) {
1359              return ReferenceHandler&lt;cl_type&gt;::retain(object_);
1360          }
1361          else {
1362              return CL_SUCCESS;
1363          }
1364      }
1365      cl_int release() const
1366      {
1367          if( referenceCountable_ ) {
1368              return ReferenceHandler&lt;cl_type&gt;::release(object_);
1369          }
1370          else {
1371              return CL_SUCCESS;
1372          }
1373      }
1374  };
1375  } 
1376  struct ImageFormat : public cl_image_format
1377  {
1378      ImageFormat(){}
1379      ImageFormat(cl_channel_order order, cl_channel_type type)
1380      {
1381          image_channel_order = order;
1382          image_channel_data_type = type;
1383      }
1384      ImageFormat&amp; operator = (const ImageFormat&amp; rhs)
1385      {
1386          if (this != &amp;rhs) {
1387              this-&gt;image_channel_data_type = rhs.image_channel_data_type;
1388              this-&gt;image_channel_order     = rhs.image_channel_order;
1389          }
1390          return *this;
1391      }
1392  };
1393  class Device : public detail::Wrapper&lt;cl_device_id&gt;
1394  {
1395  public:
1396      Device() : detail::Wrapper&lt;cl_type&gt;() { }
1397      __CL_EXPLICIT_CONSTRUCTORS Device(const cl_device_id &amp;device) : detail::Wrapper&lt;cl_type&gt;(device) { }
1398      static Device getDefault(cl_int * err = NULL);
1399      Device&amp; operator = (const cl_device_id&amp; rhs)
1400      {
1401          detail::Wrapper&lt;cl_type&gt;::operator=(rhs);
1402          return *this;
1403      }
1404      Device(const Device&amp; dev) : detail::Wrapper&lt;cl_type&gt;(dev) {}
1405      Device&amp; operator = (const Device &amp;dev)
1406      {
1407          detail::Wrapper&lt;cl_type&gt;::operator=(dev);
1408          return *this;
1409      }
1410  #if defined(CL_HPP_RVALUE_REFERENCES_SUPPORTED)
1411      Device(Device&amp;&amp; dev) CL_HPP_NOEXCEPT : detail::Wrapper&lt;cl_type&gt;(std::move(dev)) {}
1412      Device&amp; operator = (Device &amp;&amp;dev)
1413      {
1414          detail::Wrapper&lt;cl_type&gt;::operator=(std::move(dev));
1415          return *this;
1416      }
1417  #endif 
1418      template &lt;typename T&gt;
1419      cl_int getInfo(cl_device_info name, T* param) const
1420      {
1421          return detail::errHandler(
1422              detail::getInfo(&amp;::clGetDeviceInfo, object_, name, param),
1423              __GET_DEVICE_INFO_ERR);
1424      }
1425      template &lt;cl_int name&gt; typename
1426      detail::param_traits&lt;detail::cl_device_info, name&gt;::param_type
1427      getInfo(cl_int* err = NULL) const
1428      {
1429          typename detail::param_traits&lt;
1430              detail::cl_device_info, name&gt;::param_type param;
1431          cl_int result = getInfo(name, &amp;param);
1432          if (err != NULL) {
1433              *err = result;
1434          }
1435          return param;
1436      }
1437  #if defined(CL_VERSION_1_2)
1438      cl_int createSubDevices(
1439          const cl_device_partition_property * properties,
1440          VECTOR_CLASS&lt;Device&gt;* devices)
1441      {
1442          cl_uint n = 0;
1443          cl_int err = clCreateSubDevices(object_, properties, 0, NULL, &amp;n);
1444          if (err != CL_SUCCESS) {
1445              return detail::errHandler(err, __CREATE_SUB_DEVICES);
1446          }
1447          cl_device_id* ids = (cl_device_id*) alloca(n * sizeof(cl_device_id));
1448          err = clCreateSubDevices(object_, properties, n, ids, NULL);
1449          if (err != CL_SUCCESS) {
1450              return detail::errHandler(err, __CREATE_SUB_DEVICES);
1451          }
1452          devices-&gt;assign(&amp;ids[0], &amp;ids[n]);
1453          return CL_SUCCESS;
1454      }
1455  #endif 
1456  #if defined(CL_VERSION_1_1)
1457  #if defined(USE_CL_DEVICE_FISSION)
1458      cl_int createSubDevices(
1459          const cl_device_partition_property_ext * properties,
1460          VECTOR_CLASS&lt;Device&gt;* devices)
1461      {
1462          typedef CL_API_ENTRY cl_int 
1463              ( CL_API_CALL * PFN_clCreateSubDevicesEXT)(
1464                  cl_device_id &amp;bsol;*in_device*/,
1465                  const cl_device_partition_property_ext * &amp;bsol;* properties */,
1466                  cl_uint &amp;bsol;*num_entries*/,
1467                  cl_device_id * &amp;bsol;*out_devices*/,
1468                  cl_uint * &amp;bsol;*num_devices*/ ) CL_EXT_SUFFIX__VERSION_1_1;
1469          static PFN_clCreateSubDevicesEXT pfn_clCreateSubDevicesEXT = NULL;
1470          __INIT_CL_EXT_FCN_PTR(clCreateSubDevicesEXT);
1471          cl_uint n = 0;
1472          cl_int err = pfn_clCreateSubDevicesEXT(object_, properties, 0, NULL, &amp;n);
1473          if (err != CL_SUCCESS) {
1474              return detail::errHandler(err, __CREATE_SUB_DEVICES);
1475          }
1476          cl_device_id* ids = (cl_device_id*) alloca(n * sizeof(cl_device_id));
1477          err = pfn_clCreateSubDevicesEXT(object_, properties, n, ids, NULL);
1478          if (err != CL_SUCCESS) {
1479              return detail::errHandler(err, __CREATE_SUB_DEVICES);
1480          }
1481          devices-&gt;assign(&amp;ids[0], &amp;ids[n]);
1482          return CL_SUCCESS;
1483      }
1484  #endif 
1485  #endif 
1486  };
1487  class Platform : public detail::Wrapper&lt;cl_platform_id&gt;
1488  {
1489  public:
1490      Platform() : detail::Wrapper&lt;cl_type&gt;()  { }
1491      __CL_EXPLICIT_CONSTRUCTORS Platform(const cl_platform_id &amp;platform) : detail::Wrapper&lt;cl_type&gt;(platform) { }
1492      Platform&amp; operator = (const cl_platform_id&amp; rhs)
1493      {
1494          detail::Wrapper&lt;cl_type&gt;::operator=(rhs);
1495          return *this;
1496      }
1497      cl_int getInfo(cl_platform_info name, STRING_CLASS* param) const
1498      {
1499          return detail::errHandler(
1500              detail::getInfo(&amp;::clGetPlatformInfo, object_, name, param),
1501              __GET_PLATFORM_INFO_ERR);
1502      }
1503      template &lt;cl_int name&gt; typename
1504      detail::param_traits&lt;detail::cl_platform_info, name&gt;::param_type
1505      getInfo(cl_int* err = NULL) const
1506      {
1507          typename detail::param_traits&lt;
1508              detail::cl_platform_info, name&gt;::param_type param;
1509          cl_int result = getInfo(name, &amp;param);
1510          if (err != NULL) {
1511              *err = result;
1512          }
1513          return param;
1514      }
1515      cl_int getDevices(
1516          cl_device_type type,
1517          VECTOR_CLASS&lt;Device&gt;* devices) const
1518      {
1519          cl_uint n = 0;
1520          if( devices == NULL ) {
1521              return detail::errHandler(CL_INVALID_ARG_VALUE, __GET_DEVICE_IDS_ERR);
1522          }
1523          cl_int err = ::clGetDeviceIDs(object_, type, 0, NULL, &amp;n);
1524          if (err != CL_SUCCESS) {
1525              return detail::errHandler(err, __GET_DEVICE_IDS_ERR);
1526          }
1527          cl_device_id* ids = (cl_device_id*) alloca(n * sizeof(cl_device_id));
1528          err = ::clGetDeviceIDs(object_, type, n, ids, NULL);
1529          if (err != CL_SUCCESS) {
1530              return detail::errHandler(err, __GET_DEVICE_IDS_ERR);
1531          }
1532          devices-&gt;assign(&amp;ids[0], &amp;ids[n]);
1533          return CL_SUCCESS;
1534      }
1535  #if defined(USE_DX_INTEROP)
1536      cl_int getDevices(
1537          cl_d3d10_device_source_khr d3d_device_source,
1538          void *                     d3d_object,
1539          cl_d3d10_device_set_khr    d3d_device_set,
1540          VECTOR_CLASS&lt;Device&gt;* devices) const
1541      {
1542          typedef CL_API_ENTRY cl_int (CL_API_CALL *PFN_clGetDeviceIDsFromD3D10KHR)(
1543              cl_platform_id platform, 
1544              cl_d3d10_device_source_khr d3d_device_source, 
1545              void * d3d_object,
1546              cl_d3d10_device_set_khr d3d_device_set,
1547              cl_uint num_entries,
1548              cl_device_id * devices,
1549              cl_uint* num_devices);
1550          if( devices == NULL ) {
1551              return detail::errHandler(CL_INVALID_ARG_VALUE, __GET_DEVICE_IDS_ERR);
1552          }
1553          static PFN_clGetDeviceIDsFromD3D10KHR pfn_clGetDeviceIDsFromD3D10KHR = NULL;
1554          __INIT_CL_EXT_FCN_PTR_PLATFORM(object_, clGetDeviceIDsFromD3D10KHR);
1555          cl_uint n = 0;
1556          cl_int err = pfn_clGetDeviceIDsFromD3D10KHR(
1557              object_, 
1558              d3d_device_source, 
1559              d3d_object,
1560              d3d_device_set, 
1561              0, 
1562              NULL, 
1563              &amp;n);
1564          if (err != CL_SUCCESS) {
1565              return detail::errHandler(err, __GET_DEVICE_IDS_ERR);
1566          }
1567          cl_device_id* ids = (cl_device_id*) alloca(n * sizeof(cl_device_id));
1568          err = pfn_clGetDeviceIDsFromD3D10KHR(
1569              object_, 
1570              d3d_device_source, 
1571              d3d_object,
1572              d3d_device_set,
1573              n, 
1574              ids, 
1575              NULL);
1576          if (err != CL_SUCCESS) {
1577              return detail::errHandler(err, __GET_DEVICE_IDS_ERR);
1578          }
1579          devices-&gt;assign(&amp;ids[0], &amp;ids[n]);
1580          return CL_SUCCESS;
1581      }
1582  #endif
1583      static cl_int get(
1584          VECTOR_CLASS&lt;Platform&gt;* platforms)
1585      {
1586          cl_uint n = 0;
1587          if( platforms == NULL ) {
1588              return detail::errHandler(CL_INVALID_ARG_VALUE, __GET_PLATFORM_IDS_ERR);
1589          }
1590          cl_int err = ::clGetPlatformIDs(0, NULL, &amp;n);
1591          if (err != CL_SUCCESS) {
1592              return detail::errHandler(err, __GET_PLATFORM_IDS_ERR);
1593          }
1594          cl_platform_id* ids = (cl_platform_id*) alloca(
1595              n * sizeof(cl_platform_id));
1596          err = ::clGetPlatformIDs(n, ids, NULL);
1597          if (err != CL_SUCCESS) {
1598              return detail::errHandler(err, __GET_PLATFORM_IDS_ERR);
1599          }
1600          platforms-&gt;assign(&amp;ids[0], &amp;ids[n]);
1601          return CL_SUCCESS;
1602      }
1603      static cl_int get(
1604          Platform * platform)
1605      {
1606          cl_uint n = 0;
1607          if( platform == NULL ) {
1608              return detail::errHandler(CL_INVALID_ARG_VALUE, __GET_PLATFORM_IDS_ERR);
1609          }
1610          cl_int err = ::clGetPlatformIDs(0, NULL, &amp;n);
1611          if (err != CL_SUCCESS) {
1612              return detail::errHandler(err, __GET_PLATFORM_IDS_ERR);
1613          }
1614          cl_platform_id* ids = (cl_platform_id*) alloca(
1615              n * sizeof(cl_platform_id));
1616          err = ::clGetPlatformIDs(n, ids, NULL);
1617          if (err != CL_SUCCESS) {
1618              return detail::errHandler(err, __GET_PLATFORM_IDS_ERR);
1619          }
1620          *platform = ids[0];
1621          return CL_SUCCESS;
1622      }
1623      static Platform get(
1624          cl_int * errResult = NULL)
1625      {
1626          Platform platform;
1627          cl_uint n = 0;
1628          cl_int err = ::clGetPlatformIDs(0, NULL, &amp;n);
1629          if (err != CL_SUCCESS) {
1630              detail::errHandler(err, __GET_PLATFORM_IDS_ERR);
1631              if (errResult != NULL) {
1632                  *errResult = err;
1633              }
1634              return Platform();
1635          }
1636          cl_platform_id* ids = (cl_platform_id*) alloca(
1637              n * sizeof(cl_platform_id));
1638          err = ::clGetPlatformIDs(n, ids, NULL);
1639          if (err != CL_SUCCESS) {
1640              detail::errHandler(err, __GET_PLATFORM_IDS_ERR);
1641              if (errResult != NULL) {
1642                  *errResult = err;
1643              }
1644              return Platform();
1645          }
1646          return Platform(ids[0]);
1647      }
1648      static Platform getDefault( 
1649          cl_int *errResult = NULL )
1650      {
1651          return get(errResult);
1652      }
1653  #if defined(CL_VERSION_1_2)
1654      cl_int
1655      unloadCompiler()
1656      {
1657          return ::clUnloadPlatformCompiler(object_);
1658      }
1659  #endif 
1660  }; 
1661  #if defined(CL_USE_DEPRECATED_OPENCL_1_1_APIS) || (defined(CL_VERSION_1_1) &amp;&amp; !defined(CL_VERSION_1_2))
1662  inline CL_EXT_PREFIX__VERSION_1_1_DEPRECATED cl_int
1663  UnloadCompiler() CL_EXT_SUFFIX__VERSION_1_1_DEPRECATED;
1664  inline cl_int
1665  UnloadCompiler()
1666  {
1667      return ::clUnloadCompiler();
1668  }
1669  #endif 
1670  class Context 
1671      : public detail::Wrapper&lt;cl_context&gt;
1672  {
1673  private:
1674  #ifdef CL_HPP_CPP11_ATOMICS_SUPPORTED
1675      static std::atomic&lt;int&gt; default_initialized_;
1676  #else 
1677      static volatile int default_initialized_;
1678  #endif 
1679      static Context default_;
1680      static volatile cl_int default_error_;
1681  public:
1682      Context(
1683          const VECTOR_CLASS&lt;Device&gt;&amp; devices,
1684          cl_context_properties* properties = NULL,
1685          void (CL_CALLBACK * notifyFptr)(
1686              const char *,
1687              const void *,
1688              ::size_t,
1689              void *) = NULL,
1690          void* data = NULL,
1691          cl_int* err = NULL)
1692      {
1693          cl_int error;
1694          ::size_t numDevices = devices.size();
1695          cl_device_id* deviceIDs = (cl_device_id*) alloca(numDevices * sizeof(cl_device_id));
1696          for( ::size_t deviceIndex = 0; deviceIndex &lt; numDevices; ++deviceIndex ) {
1697              deviceIDs[deviceIndex] = (devices[deviceIndex])();
1698          }
1699          object_ = ::clCreateContext(
1700              properties, (cl_uint) numDevices,
1701              deviceIDs,
1702              notifyFptr, data, &amp;error);
1703          detail::errHandler(error, __CREATE_CONTEXT_ERR);
1704          if (err != NULL) {
1705              *err = error;
1706          }
1707      }
<span onclick='openModal()' class='match'>1708      Context(
1709          const Device&amp; device,
1710          cl_context_properties* properties = NULL,
1711          void (CL_CALLBACK * notifyFptr)(
1712              const char *,
1713              const void *,
1714              ::size_t,
</span>1715              void *) = NULL,
1716          void* data = NULL,
1717          cl_int* err = NULL)
1718      {
1719          cl_int error;
1720          cl_device_id deviceID = device();
1721          object_ = ::clCreateContext(
1722              properties, 1,
1723              &amp;deviceID,
1724              notifyFptr, data, &amp;error);
1725          detail::errHandler(error, __CREATE_CONTEXT_ERR);
1726          if (err != NULL) {
1727              *err = error;
1728          }
1729      }
1730      Context(
1731          cl_device_type type,
1732          cl_context_properties* properties = NULL,
1733          void (CL_CALLBACK * notifyFptr)(
1734              const char *,
1735              const void *,
1736              ::size_t,
1737              void *) = NULL,
1738          void* data = NULL,
1739          cl_int* err = NULL)
1740      {
1741          cl_int error;
1742  #if !defined(__APPLE__) &amp;&amp; !defined(__MACOS)
1743          cl_context_properties prop[4] = {CL_CONTEXT_PLATFORM, 0, 0, 0 };
1744          if (properties == NULL) {
1745              VECTOR_CLASS&lt;Platform&gt; platforms;
1746              error = Platform::get(&amp;platforms);
1747              if (error != CL_SUCCESS) {
1748                  detail::errHandler(error, __CREATE_CONTEXT_FROM_TYPE_ERR);
1749                  if (err != NULL) {
1750                      *err = error;
1751                  }
1752                  return;
1753              }
1754              cl_context_properties platform_id = 0;
1755              for (unsigned int i = 0; i &lt; platforms.size(); i++) {
1756                  VECTOR_CLASS&lt;Device&gt; devices;
1757  #if defined(__CL_ENABLE_EXCEPTIONS)
1758                  try {
1759  #endif
1760                      error = platforms[i].getDevices(type, &amp;devices);
1761  #if defined(__CL_ENABLE_EXCEPTIONS)
1762                  } catch (Error) {}
1763  #endif
1764                  if (error != CL_SUCCESS &amp;&amp; error != CL_DEVICE_NOT_FOUND) {
1765                      detail::errHandler(error, __CREATE_CONTEXT_FROM_TYPE_ERR);
1766                      if (err != NULL) {
1767                          *err = error;
1768                      }
1769                  }
1770                  if (devices.size() &gt; 0) {
1771                      platform_id = (cl_context_properties)platforms[i]();
1772                      break;
1773                  }
1774              }
1775              if (platform_id == 0) {
1776                  detail::errHandler(CL_DEVICE_NOT_FOUND, __CREATE_CONTEXT_FROM_TYPE_ERR);
1777                  if (err != NULL) {
1778                      *err = CL_DEVICE_NOT_FOUND;
1779                  }
1780                  return;
1781              }
1782              prop[1] = platform_id;
1783              properties = &amp;prop[0];
1784          }
1785  #endif
1786          object_ = ::clCreateContextFromType(
1787              properties, type, notifyFptr, data, &amp;error);
1788          detail::errHandler(error, __CREATE_CONTEXT_FROM_TYPE_ERR);
1789          if (err != NULL) {
1790              *err = error;
1791          }
1792      }
1793      Context(const Context&amp; ctx) : detail::Wrapper&lt;cl_type&gt;(ctx) {}
1794      Context&amp; operator = (const Context &amp;ctx)
1795      {
1796          detail::Wrapper&lt;cl_type&gt;::operator=(ctx);
1797          return *this;
1798      }
1799  #if defined(CL_HPP_RVALUE_REFERENCES_SUPPORTED)
1800      Context(Context&amp;&amp; ctx) CL_HPP_NOEXCEPT : detail::Wrapper&lt;cl_type&gt;(std::move(ctx)) {}
1801      Context&amp; operator = (Context &amp;&amp;ctx)
1802      {
1803          detail::Wrapper&lt;cl_type&gt;::operator=(std::move(ctx));
1804          return *this;
1805      }
1806  #endif 
1807      static Context getDefault(cl_int * err = NULL) 
1808      {
1809          int state = detail::compare_exchange(
1810              &amp;default_initialized_, 
1811              __DEFAULT_BEING_INITIALIZED, __DEFAULT_NOT_INITIALIZED);
1812          if (state &amp; __DEFAULT_INITIALIZED) {
1813              if (err != NULL) {
1814                  *err = default_error_;
1815              }
1816              return default_;
1817          }
1818          if (state &amp; __DEFAULT_BEING_INITIALIZED) {
1819                while(default_initialized_ != __DEFAULT_INITIALIZED) {
1820                    detail::fence();
1821                }
1822              if (err != NULL) {
1823                  *err = default_error_;
1824              }
1825              return default_;
1826          }
1827          cl_int error;
1828          default_ = Context(
1829              CL_DEVICE_TYPE_DEFAULT,
1830              NULL,
1831              NULL,
1832              NULL,
1833              &amp;error);
1834          detail::fence();
1835          default_error_ = error;
1836          default_initialized_ = __DEFAULT_INITIALIZED;
1837          detail::fence();
1838          if (err != NULL) {
1839              *err = default_error_;
1840          }
1841          return default_;
1842      }
1843      Context() : detail::Wrapper&lt;cl_type&gt;() { }
1844      __CL_EXPLICIT_CONSTRUCTORS Context(const cl_context&amp; context) : detail::Wrapper&lt;cl_type&gt;(context) { }
1845      Context&amp; operator = (const cl_context&amp; rhs)
1846      {
1847          detail::Wrapper&lt;cl_type&gt;::operator=(rhs);
1848          return *this;
1849      }
1850      template &lt;typename T&gt;
1851      cl_int getInfo(cl_context_info name, T* param) const
1852      {
1853          return detail::errHandler(
1854              detail::getInfo(&amp;::clGetContextInfo, object_, name, param),
1855              __GET_CONTEXT_INFO_ERR);
1856      }
1857      template &lt;cl_int name&gt; typename
1858      detail::param_traits&lt;detail::cl_context_info, name&gt;::param_type
1859      getInfo(cl_int* err = NULL) const
1860      {
1861          typename detail::param_traits&lt;
1862              detail::cl_context_info, name&gt;::param_type param;
1863          cl_int result = getInfo(name, &amp;param);
1864          if (err != NULL) {
1865              *err = result;
1866          }
1867          return param;
1868      }
1869      cl_int getSupportedImageFormats(
1870          cl_mem_flags flags,
1871          cl_mem_object_type type,
1872          VECTOR_CLASS&lt;ImageFormat&gt;* formats) const
1873      {
1874          cl_uint numEntries;
1875          if (!formats) {
1876              return CL_SUCCESS;
1877          }
1878          cl_int err = ::clGetSupportedImageFormats(
1879              object_,
1880              flags,
1881              type,
1882              0,
1883              NULL,
1884              &amp;numEntries);
1885          if (err != CL_SUCCESS) {
1886              return detail::errHandler(err, __GET_SUPPORTED_IMAGE_FORMATS_ERR);
1887          }
1888          if (numEntries &gt; 0) {
1889              ImageFormat* value = (ImageFormat*)
1890                  alloca(numEntries * sizeof(ImageFormat));
1891              err = ::clGetSupportedImageFormats(
1892                  object_,
1893                  flags,
1894                  type,
1895                  numEntries,
1896                  (cl_image_format*)value,
1897                  NULL);
1898              if (err != CL_SUCCESS) {
1899                  return detail::errHandler(err, __GET_SUPPORTED_IMAGE_FORMATS_ERR);
1900              }
1901              formats-&gt;assign(&amp;value[0], &amp;value[numEntries]);
1902          }
1903          else {
1904              formats-&gt;clear();
1905          }
1906          return CL_SUCCESS;
1907      }
1908  };
1909  inline Device Device::getDefault(cl_int * err)
1910  {
1911      cl_int error;
1912      Device device;
1913      Context context = Context::getDefault(&amp;error);
1914      detail::errHandler(error, __CREATE_CONTEXT_ERR);
1915      if (error != CL_SUCCESS) {
1916          if (err != NULL) {
1917              *err = error;
1918          }
1919      }
1920      else {
1921          device = context.getInfo&lt;CL_CONTEXT_DEVICES&gt;()[0];
1922          if (err != NULL) {
1923              *err = CL_SUCCESS;
1924          }
1925      }
1926      return device;
1927  }
1928  #ifdef _WIN32
1929  #ifdef CL_HPP_CPP11_ATOMICS_SUPPORTED
1930  __declspec(selectany) std::atomic&lt;int&gt; Context::default_initialized_;
1931  #else 
1932  __declspec(selectany) volatile int Context::default_initialized_ = __DEFAULT_NOT_INITIALIZED;
1933  #endif 
1934  __declspec(selectany) Context Context::default_;
1935  __declspec(selectany) volatile cl_int Context::default_error_ = CL_SUCCESS;
1936  #else 
1937  #ifdef CL_HPP_CPP11_ATOMICS_SUPPORTED
1938  __attribute__((weak)) std::atomic&lt;int&gt; Context::default_initialized_;
1939  #else 
1940  __attribute__((weak)) volatile int Context::default_initialized_ = __DEFAULT_NOT_INITIALIZED;
1941  #endif 
1942  __attribute__((weak)) Context Context::default_;
1943  __attribute__((weak)) volatile cl_int Context::default_error_ = CL_SUCCESS;
1944  #endif 
1945  class Event : public detail::Wrapper&lt;cl_event&gt;
1946  {
1947  public:
1948      Event() : detail::Wrapper&lt;cl_type&gt;() { }
1949      __CL_EXPLICIT_CONSTRUCTORS Event(const cl_event&amp; event) : detail::Wrapper&lt;cl_type&gt;(event) { }
1950      Event&amp; operator = (const cl_event&amp; rhs)
1951      {
1952          detail::Wrapper&lt;cl_type&gt;::operator=(rhs);
1953          return *this;
1954      }
1955      template &lt;typename T&gt;
1956      cl_int getInfo(cl_event_info name, T* param) const
1957      {
1958          return detail::errHandler(
1959              detail::getInfo(&amp;::clGetEventInfo, object_, name, param),
1960              __GET_EVENT_INFO_ERR);
1961      }
1962      template &lt;cl_int name&gt; typename
1963      detail::param_traits&lt;detail::cl_event_info, name&gt;::param_type
1964      getInfo(cl_int* err = NULL) const
1965      {
1966          typename detail::param_traits&lt;
1967              detail::cl_event_info, name&gt;::param_type param;
1968          cl_int result = getInfo(name, &amp;param);
1969          if (err != NULL) {
1970              *err = result;
1971          }
1972          return param;
1973      }
1974      template &lt;typename T&gt;
1975      cl_int getProfilingInfo(cl_profiling_info name, T* param) const
1976      {
1977          return detail::errHandler(detail::getInfo(
1978              &amp;::clGetEventProfilingInfo, object_, name, param),
1979              __GET_EVENT_PROFILE_INFO_ERR);
1980      }
1981      template &lt;cl_int name&gt; typename
1982      detail::param_traits&lt;detail::cl_profiling_info, name&gt;::param_type
1983      getProfilingInfo(cl_int* err = NULL) const
1984      {
1985          typename detail::param_traits&lt;
1986              detail::cl_profiling_info, name&gt;::param_type param;
1987          cl_int result = getProfilingInfo(name, &amp;param);
1988          if (err != NULL) {
1989              *err = result;
1990          }
1991          return param;
1992      }
1993      cl_int wait() const
1994      {
1995          return detail::errHandler(
1996              ::clWaitForEvents(1, &amp;object_),
1997              __WAIT_FOR_EVENTS_ERR);
1998      }
1999  #if defined(CL_VERSION_1_1)
2000      cl_int setCallback(
2001          cl_int type,
2002          void (CL_CALLBACK * pfn_notify)(cl_event, cl_int, void *),		
2003          void * user_data = NULL)
2004      {
2005          return detail::errHandler(
2006              ::clSetEventCallback(
2007                  object_,
2008                  type,
2009                  pfn_notify,
2010                  user_data), 
2011              __SET_EVENT_CALLBACK_ERR);
2012      }
2013  #endif
2014      static cl_int
2015      waitForEvents(const VECTOR_CLASS&lt;Event&gt;&amp; events)
2016      {
2017          return detail::errHandler(
2018              ::clWaitForEvents(
2019                  (cl_uint) events.size(), (events.size() &gt; 0) ? (cl_event*)&amp;events.front() : NULL),
2020              __WAIT_FOR_EVENTS_ERR);
2021      }
2022  };
2023  #if defined(CL_VERSION_1_1)
2024  class UserEvent : public Event
2025  {
2026  public:
2027      UserEvent(
2028          const Context&amp; context,
2029          cl_int * err = NULL)
2030      {
2031          cl_int error;
2032          object_ = ::clCreateUserEvent(
2033              context(),
2034              &amp;error);
2035          detail::errHandler(error, __CREATE_USER_EVENT_ERR);
2036          if (err != NULL) {
2037              *err = error;
2038          }
2039      }
2040      UserEvent() : Event() { }
2041      cl_int setStatus(cl_int status)
2042      {
2043          return detail::errHandler(
2044              ::clSetUserEventStatus(object_,status), 
2045              __SET_USER_EVENT_STATUS_ERR);
2046      }
2047  };
2048  #endif
2049  inline static cl_int
2050  WaitForEvents(const VECTOR_CLASS&lt;Event&gt;&amp; events)
2051  {
2052      return detail::errHandler(
2053          ::clWaitForEvents(
2054              (cl_uint) events.size(), (events.size() &gt; 0) ? (cl_event*)&amp;events.front() : NULL),
2055          __WAIT_FOR_EVENTS_ERR);
2056  }
2057  class Memory : public detail::Wrapper&lt;cl_mem&gt;
2058  {
2059  public:
2060      Memory() : detail::Wrapper&lt;cl_type&gt;() { }
2061      __CL_EXPLICIT_CONSTRUCTORS Memory(const cl_mem&amp; memory) : detail::Wrapper&lt;cl_type&gt;(memory) { }
2062      Memory&amp; operator = (const cl_mem&amp; rhs)
2063      {
2064          detail::Wrapper&lt;cl_type&gt;::operator=(rhs);
2065          return *this;
2066      }
2067      Memory(const Memory&amp; mem) : detail::Wrapper&lt;cl_type&gt;(mem) {}
2068      Memory&amp; operator = (const Memory &amp;mem)
2069      {
2070          detail::Wrapper&lt;cl_type&gt;::operator=(mem);
2071          return *this;
2072      }
2073  #if defined(CL_HPP_RVALUE_REFERENCES_SUPPORTED)
2074      Memory(Memory&amp;&amp; mem) CL_HPP_NOEXCEPT : detail::Wrapper&lt;cl_type&gt;(std::move(mem)) {}
2075      Memory&amp; operator = (Memory &amp;&amp;mem)
2076      {
2077          detail::Wrapper&lt;cl_type&gt;::operator=(std::move(mem));
2078          return *this;
2079      }
2080  #endif 
2081      template &lt;typename T&gt;
2082      cl_int getInfo(cl_mem_info name, T* param) const
2083      {
2084          return detail::errHandler(
2085              detail::getInfo(&amp;::clGetMemObjectInfo, object_, name, param),
2086              __GET_MEM_OBJECT_INFO_ERR);
2087      }
2088      template &lt;cl_int name&gt; typename
2089      detail::param_traits&lt;detail::cl_mem_info, name&gt;::param_type
2090      getInfo(cl_int* err = NULL) const
2091      {
2092          typename detail::param_traits&lt;
2093              detail::cl_mem_info, name&gt;::param_type param;
2094          cl_int result = getInfo(name, &amp;param);
2095          if (err != NULL) {
2096              *err = result;
2097          }
2098          return param;
2099      }
2100  #if defined(CL_VERSION_1_1)
2101      cl_int setDestructorCallback(
2102          void (CL_CALLBACK * pfn_notify)(cl_mem, void *),		
2103          void * user_data = NULL)
2104      {
2105          return detail::errHandler(
2106              ::clSetMemObjectDestructorCallback(
2107                  object_,
2108                  pfn_notify,
2109                  user_data), 
2110              __SET_MEM_OBJECT_DESTRUCTOR_CALLBACK_ERR);
2111      }
2112  #endif
2113  };
2114  class Buffer;
2115  template&lt; typename IteratorType &gt;
2116  cl_int copy( IteratorType startIterator, IteratorType endIterator, cl::Buffer &amp;buffer );
2117  template&lt; typename IteratorType &gt;
2118  cl_int copy( const cl::Buffer &amp;buffer, IteratorType startIterator, IteratorType endIterator );
2119  template&lt; typename IteratorType &gt;
2120  cl_int copy( const CommandQueue &amp;queue, IteratorType startIterator, IteratorType endIterator, cl::Buffer &amp;buffer );
2121  template&lt; typename IteratorType &gt;
2122  cl_int copy( const CommandQueue &amp;queue, const cl::Buffer &amp;buffer, IteratorType startIterator, IteratorType endIterator );
2123  class Buffer : public Memory
2124  {
2125  public:
2126      Buffer(
2127          const Context&amp; context,
2128          cl_mem_flags flags,
2129          ::size_t size,
2130          void* host_ptr = NULL,
2131          cl_int* err = NULL)
2132      {
2133          cl_int error;
2134          object_ = ::clCreateBuffer(context(), flags, size, host_ptr, &amp;error);
2135          detail::errHandler(error, __CREATE_BUFFER_ERR);
2136          if (err != NULL) {
2137              *err = error;
2138          }
2139      }
2140      Buffer(
2141           cl_mem_flags flags,
2142          ::size_t size,
2143          void* host_ptr = NULL,
2144          cl_int* err = NULL)
2145      {
2146          cl_int error;
2147          Context context = Context::getDefault(err);
2148          object_ = ::clCreateBuffer(context(), flags, size, host_ptr, &amp;error);
2149          detail::errHandler(error, __CREATE_BUFFER_ERR);
2150          if (err != NULL) {
2151              *err = error;
2152          }
2153      }
2154      template&lt; typename IteratorType &gt;
2155      Buffer(
2156          IteratorType startIterator,
2157          IteratorType endIterator,
2158          bool readOnly,
2159          bool useHostPtr = false,
2160          cl_int* err = NULL)
2161      {
2162          typedef typename std::iterator_traits&lt;IteratorType&gt;::value_type DataType;
2163          cl_int error;
2164          cl_mem_flags flags = 0;
2165          if( readOnly ) {
2166              flags |= CL_MEM_READ_ONLY;
2167          }
2168          else {
2169              flags |= CL_MEM_READ_WRITE;
2170          }
2171          if( useHostPtr ) {
2172              flags |= CL_MEM_USE_HOST_PTR;
2173          }
2174          ::size_t size = sizeof(DataType)*(endIterator - startIterator);
2175          Context context = Context::getDefault(err);
2176          if( useHostPtr ) {
2177              object_ = ::clCreateBuffer(context(), flags, size, static_cast&lt;DataType*&gt;(&amp;*startIterator), &amp;error);
2178          } else {
2179              object_ = ::clCreateBuffer(context(), flags, size, 0, &amp;error);
2180          }
2181          detail::errHandler(error, __CREATE_BUFFER_ERR);
2182          if (err != NULL) {
2183              *err = error;
2184          }
2185          if( !useHostPtr ) {
2186              error = cl::copy(startIterator, endIterator, *this);
2187              detail::errHandler(error, __CREATE_BUFFER_ERR);
2188              if (err != NULL) {
2189                  *err = error;
2190              }
2191          }
2192      }
2193      template&lt; typename IteratorType &gt;
2194      Buffer(const Context &amp;context, IteratorType startIterator, IteratorType endIterator,
2195          bool readOnly, bool useHostPtr = false, cl_int* err = NULL);
2196      template&lt; typename IteratorType &gt;
2197      Buffer(const CommandQueue &amp;queue, IteratorType startIterator, IteratorType endIterator,
2198          bool readOnly, bool useHostPtr = false, cl_int* err = NULL);
2199      Buffer() : Memory() { }
2200      __CL_EXPLICIT_CONSTRUCTORS Buffer(const cl_mem&amp; buffer) : Memory(buffer) { }
2201      Buffer&amp; operator = (const cl_mem&amp; rhs)
2202      {
2203          Memory::operator=(rhs);
2204          return *this;
2205      }
2206      Buffer(const Buffer&amp; buf) : Memory(buf) {}
2207      Buffer&amp; operator = (const Buffer &amp;buf)
2208      {
2209          Memory::operator=(buf);
2210          return *this;
2211      }
2212  #if defined(CL_HPP_RVALUE_REFERENCES_SUPPORTED)
2213      Buffer(Buffer&amp;&amp; buf) CL_HPP_NOEXCEPT : Memory(std::move(buf)) {}
2214      Buffer&amp; operator = (Buffer &amp;&amp;buf)
2215      {
2216          Memory::operator=(std::move(buf));
2217          return *this;
2218      }
2219  #endif 
2220  #if defined(CL_VERSION_1_1)
2221      Buffer createSubBuffer(
2222          cl_mem_flags flags,
2223          cl_buffer_create_type buffer_create_type,
2224          const void * buffer_create_info,
2225          cl_int * err = NULL)
2226      {
2227          Buffer result;
2228          cl_int error;
2229          result.object_ = ::clCreateSubBuffer(
2230              object_, 
2231              flags, 
2232              buffer_create_type, 
2233              buffer_create_info, 
2234              &amp;error);
2235          detail::errHandler(error, __CREATE_SUBBUFFER_ERR);
2236          if (err != NULL) {
2237              *err = error;
2238          }
2239          return result;
2240      }		
2241  #endif
2242  };
2243  #if defined (USE_DX_INTEROP)
2244  class BufferD3D10 : public Buffer
2245  {
2246  public:
2247      typedef CL_API_ENTRY cl_mem (CL_API_CALL *PFN_clCreateFromD3D10BufferKHR)(
2248      cl_context context, cl_mem_flags flags, ID3D10Buffer*  buffer,
2249      cl_int* errcode_ret);
2250      BufferD3D10(
2251          const Context&amp; context,
2252          cl_mem_flags flags,
2253          ID3D10Buffer* bufobj,
2254          cl_int * err = NULL)
2255      {
2256          static PFN_clCreateFromD3D10BufferKHR pfn_clCreateFromD3D10BufferKHR = NULL;
2257  #if defined(CL_VERSION_1_2)
2258          vector&lt;cl_context_properties&gt; props = context.getInfo&lt;CL_CONTEXT_PROPERTIES&gt;();
2259          cl_platform platform = -1;
2260          for( int i = 0; i &lt; props.size(); ++i ) {
2261              if( props[i] == CL_CONTEXT_PLATFORM ) {
2262                  platform = props[i+1];
2263              }
2264          }
2265          __INIT_CL_EXT_FCN_PTR_PLATFORM(platform, clCreateFromD3D10BufferKHR);
2266  #endif
2267  #if defined(CL_VERSION_1_1)
2268          __INIT_CL_EXT_FCN_PTR(clCreateFromD3D10BufferKHR);
2269  #endif
2270          cl_int error;
2271          object_ = pfn_clCreateFromD3D10BufferKHR(
2272              context(),
2273              flags,
2274              bufobj,
2275              &amp;error);
2276          detail::errHandler(error, __CREATE_GL_BUFFER_ERR);
2277          if (err != NULL) {
2278              *err = error;
2279          }
2280      }
2281      BufferD3D10() : Buffer() { }
2282      __CL_EXPLICIT_CONSTRUCTORS BufferD3D10(const cl_mem&amp; buffer) : Buffer(buffer) { }
2283      BufferD3D10&amp; operator = (const cl_mem&amp; rhs)
2284      {
2285          Buffer::operator=(rhs);
2286          return *this;
2287      }
2288      BufferD3D10(const BufferD3D10&amp; buf) : Buffer(buf) {}
2289      BufferD3D10&amp; operator = (const BufferD3D10 &amp;buf)
2290      {
2291          Buffer::operator=(buf);
2292          return *this;
2293      }
2294  #if defined(CL_HPP_RVALUE_REFERENCES_SUPPORTED)
2295      BufferD3D10(BufferD3D10&amp;&amp; buf) CL_HPP_NOEXCEPT : Buffer(std::move(buf)) {}
2296      BufferD3D10&amp; operator = (BufferD3D10 &amp;&amp;buf)
2297      {
2298          Buffer::operator=(std::move(buf));
2299          return *this;
2300      }
2301  #endif 
2302  };
2303  #endif
2304  class BufferGL : public Buffer
2305  {
2306  public:
2307      BufferGL(
2308          const Context&amp; context,
2309          cl_mem_flags flags,
2310          cl_GLuint bufobj,
2311          cl_int * err = NULL)
2312      {
2313          cl_int error;
2314          object_ = ::clCreateFromGLBuffer(
2315              context(),
2316              flags,
2317              bufobj,
2318              &amp;error);
2319          detail::errHandler(error, __CREATE_GL_BUFFER_ERR);
2320          if (err != NULL) {
2321              *err = error;
2322          }
2323      }
2324      BufferGL() : Buffer() { }
2325      __CL_EXPLICIT_CONSTRUCTORS BufferGL(const cl_mem&amp; buffer) : Buffer(buffer) { }
2326      BufferGL&amp; operator = (const cl_mem&amp; rhs)
2327      {
2328          Buffer::operator=(rhs);
2329          return *this;
2330      }
2331      BufferGL(const BufferGL&amp; buf) : Buffer(buf) {}
2332      BufferGL&amp; operator = (const BufferGL &amp;buf)
2333      {
2334          Buffer::operator=(buf);
2335          return *this;
2336      }
2337  #if defined(CL_HPP_RVALUE_REFERENCES_SUPPORTED)
2338      BufferGL(BufferGL&amp;&amp; buf) CL_HPP_NOEXCEPT : Buffer(std::move(buf)) {}
2339      BufferGL&amp; operator = (BufferGL &amp;&amp;buf)
2340      {
2341          Buffer::operator=(std::move(buf));
2342          return *this;
2343      }
2344  #endif 
2345      cl_int getObjectInfo(
2346          cl_gl_object_type *type,
2347          cl_GLuint * gl_object_name)
2348      {
2349          return detail::errHandler(
2350              ::clGetGLObjectInfo(object_,type,gl_object_name),
2351              __GET_GL_OBJECT_INFO_ERR);
2352      }
2353  };
2354  class Image : public Memory
2355  {
2356  protected:
2357      Image() : Memory() { }
2358      __CL_EXPLICIT_CONSTRUCTORS Image(const cl_mem&amp; image) : Memory(image) { }
2359      Image&amp; operator = (const cl_mem&amp; rhs)
2360      {
2361          Memory::operator=(rhs);
2362          return *this;
2363      }
2364      Image(const Image&amp; img) : Memory(img) {}
2365      Image&amp; operator = (const Image &amp;img)
2366      {
2367          Memory::operator=(img);
2368          return *this;
2369      }
2370  #if defined(CL_HPP_RVALUE_REFERENCES_SUPPORTED)
2371      Image(Image&amp;&amp; img) CL_HPP_NOEXCEPT : Memory(std::move(img)) {}
2372      Image&amp; operator = (Image &amp;&amp;img)
2373      {
2374          Memory::operator=(std::move(img));
2375          return *this;
2376      }
2377  #endif 
2378  public:
2379      template &lt;typename T&gt;
2380      cl_int getImageInfo(cl_image_info name, T* param) const
2381      {
2382          return detail::errHandler(
2383              detail::getInfo(&amp;::clGetImageInfo, object_, name, param),
2384              __GET_IMAGE_INFO_ERR);
2385      }
2386      template &lt;cl_int name&gt; typename
2387      detail::param_traits&lt;detail::cl_image_info, name&gt;::param_type
2388      getImageInfo(cl_int* err = NULL) const
2389      {
2390          typename detail::param_traits&lt;
2391              detail::cl_image_info, name&gt;::param_type param;
2392          cl_int result = getImageInfo(name, &amp;param);
2393          if (err != NULL) {
2394              *err = result;
2395          }
2396          return param;
2397      }
2398  };
2399  #if defined(CL_VERSION_1_2)
2400  class Image1D : public Image
2401  {
2402  public:
2403      Image1D(
2404          const Context&amp; context,
2405          cl_mem_flags flags,
2406          ImageFormat format,
2407          ::size_t width,
2408          void* host_ptr = NULL,
2409          cl_int* err = NULL)
2410      {
2411          cl_int error;
2412          cl_image_desc desc =
2413          {
2414              CL_MEM_OBJECT_IMAGE1D,
2415              width,
2416              0, 0, 0, 0, 0, 0, 0, 0
2417          };
2418          object_ = ::clCreateImage(
2419              context(), 
2420              flags, 
2421              &amp;format, 
2422              &amp;desc, 
2423              host_ptr, 
2424              &amp;error);
2425          detail::errHandler(error, __CREATE_IMAGE_ERR);
2426          if (err != NULL) {
2427              *err = error;
2428          }
2429      }
2430      Image1D() { }
2431      __CL_EXPLICIT_CONSTRUCTORS Image1D(const cl_mem&amp; image1D) : Image(image1D) { }
2432      Image1D&amp; operator = (const cl_mem&amp; rhs)
2433      {
2434          Image::operator=(rhs);
2435          return *this;
2436      }
2437      Image1D(const Image1D&amp; img) : Image(img) {}
2438      Image1D&amp; operator = (const Image1D &amp;img)
2439      {
2440          Image::operator=(img);
2441          return *this;
2442      }
2443  #if defined(CL_HPP_RVALUE_REFERENCES_SUPPORTED)
2444      Image1D(Image1D&amp;&amp; img) CL_HPP_NOEXCEPT : Image(std::move(img)) {}
2445      Image1D&amp; operator = (Image1D &amp;&amp;img)
2446      {
2447          Image::operator=(std::move(img));
2448          return *this;
2449      }
2450  #endif 
2451  };
2452  class Image1DBuffer : public Image
2453  {
2454  public:
2455      Image1DBuffer(
2456          const Context&amp; context,
2457          cl_mem_flags flags,
2458          ImageFormat format,
2459          ::size_t width,
2460          const Buffer &amp;buffer,
2461          cl_int* err = NULL)
2462      {
2463          cl_int error;
2464          cl_image_desc desc =
2465          {
2466              CL_MEM_OBJECT_IMAGE1D_BUFFER,
2467              width,
2468              0, 0, 0, 0, 0, 0, 0,
2469              buffer()
2470          };
2471          object_ = ::clCreateImage(
2472              context(), 
2473              flags, 
2474              &amp;format, 
2475              &amp;desc, 
2476              NULL, 
2477              &amp;error);
2478          detail::errHandler(error, __CREATE_IMAGE_ERR);
2479          if (err != NULL) {
2480              *err = error;
2481          }
2482      }
2483      Image1DBuffer() { }
2484      __CL_EXPLICIT_CONSTRUCTORS Image1DBuffer(const cl_mem&amp; image1D) : Image(image1D) { }
2485      Image1DBuffer&amp; operator = (const cl_mem&amp; rhs)
2486      {
2487          Image::operator=(rhs);
2488          return *this;
2489      }
2490      Image1DBuffer(const Image1DBuffer&amp; img) : Image(img) {}
2491      Image1DBuffer&amp; operator = (const Image1DBuffer &amp;img)
2492      {
2493          Image::operator=(img);
2494          return *this;
2495      }
2496  #if defined(CL_HPP_RVALUE_REFERENCES_SUPPORTED)
2497      Image1DBuffer(Image1DBuffer&amp;&amp; img) CL_HPP_NOEXCEPT : Image(std::move(img)) {}
2498      Image1DBuffer&amp; operator = (Image1DBuffer &amp;&amp;img)
2499      {
2500          Image::operator=(std::move(img));
2501          return *this;
2502      }
2503  #endif 
2504  };
2505  class Image1DArray : public Image
2506  {
2507  public:
2508      Image1DArray(
2509          const Context&amp; context,
2510          cl_mem_flags flags,
2511          ImageFormat format,
2512          ::size_t arraySize,
2513          ::size_t width,
2514          ::size_t rowPitch,
2515          void* host_ptr = NULL,
2516          cl_int* err = NULL)
2517      {
2518          cl_int error;
2519          cl_image_desc desc =
2520          {
2521              CL_MEM_OBJECT_IMAGE1D_ARRAY,
2522              width,
2523              0, 0,  
2524              arraySize,
2525              rowPitch,
2526              0, 0, 0, 0
2527          };
2528          object_ = ::clCreateImage(
2529              context(), 
2530              flags, 
2531              &amp;format, 
2532              &amp;desc, 
2533              host_ptr, 
2534              &amp;error);
2535          detail::errHandler(error, __CREATE_IMAGE_ERR);
2536          if (err != NULL) {
2537              *err = error;
2538          }
2539      }
2540      Image1DArray() { }
2541      __CL_EXPLICIT_CONSTRUCTORS Image1DArray(const cl_mem&amp; imageArray) : Image(imageArray) { }
2542      Image1DArray&amp; operator = (const cl_mem&amp; rhs)
2543      {
2544          Image::operator=(rhs);
2545          return *this;
2546      }
2547      Image1DArray(const Image1DArray&amp; img) : Image(img) {}
2548      Image1DArray&amp; operator = (const Image1DArray &amp;img)
2549      {
2550          Image::operator=(img);
2551          return *this;
2552      }
2553  #if defined(CL_HPP_RVALUE_REFERENCES_SUPPORTED)
2554      Image1DArray(Image1DArray&amp;&amp; img) CL_HPP_NOEXCEPT : Image(std::move(img)) {}
2555      Image1DArray&amp; operator = (Image1DArray &amp;&amp;img)
2556      {
2557          Image::operator=(std::move(img));
2558          return *this;
2559      }
2560  #endif 
2561  };
2562  #endif 
2563  class Image2D : public Image
2564  {
2565  public:
2566      Image2D(
2567          const Context&amp; context,
2568          cl_mem_flags flags,
2569          ImageFormat format,
2570          ::size_t width,
2571          ::size_t height,
2572          ::size_t row_pitch = 0,
2573          void* host_ptr = NULL,
2574          cl_int* err = NULL)
2575      {
2576          cl_int error;
2577          bool useCreateImage;
2578  #if defined(CL_VERSION_1_2) &amp;&amp; defined(CL_USE_DEPRECATED_OPENCL_1_1_APIS)
2579          {
2580              cl_uint version = detail::getContextPlatformVersion(context());
2581              useCreateImage = (version &gt;= 0x10002); 
2582          }
2583  #elif defined(CL_VERSION_1_2)
2584          useCreateImage = true;
2585  #else
2586          useCreateImage = false;
2587  #endif
2588  #if defined(CL_VERSION_1_2)
2589          if (useCreateImage)
2590          {
2591              cl_image_desc desc =
2592              {
2593                  CL_MEM_OBJECT_IMAGE2D,
2594                  width,
2595                  height,
2596                  0, 0, 
2597                  row_pitch,
2598                  0, 0, 0, 0
2599              };
2600              object_ = ::clCreateImage(
2601                  context(),
2602                  flags,
2603                  &amp;format,
2604                  &amp;desc,
2605                  host_ptr,
2606                  &amp;error);
2607              detail::errHandler(error, __CREATE_IMAGE_ERR);
2608              if (err != NULL) {
2609                  *err = error;
2610              }
2611          }
2612  #endif 
2613  #if !defined(CL_VERSION_1_2) || defined(CL_USE_DEPRECATED_OPENCL_1_1_APIS)
2614          if (!useCreateImage)
2615          {
2616              object_ = ::clCreateImage2D(
2617                  context(), flags,&amp;format, width, height, row_pitch, host_ptr, &amp;error);
2618              detail::errHandler(error, __CREATE_IMAGE2D_ERR);
2619              if (err != NULL) {
2620                  *err = error;
2621              }
2622          }
2623  #endif 
2624      }
2625      Image2D() { }
2626      __CL_EXPLICIT_CONSTRUCTORS Image2D(const cl_mem&amp; image2D) : Image(image2D) { }
2627      Image2D&amp; operator = (const cl_mem&amp; rhs)
2628      {
2629          Image::operator=(rhs);
2630          return *this;
2631      }
2632      Image2D(const Image2D&amp; img) : Image(img) {}
2633      Image2D&amp; operator = (const Image2D &amp;img)
2634      {
2635          Image::operator=(img);
2636          return *this;
2637      }
2638  #if defined(CL_HPP_RVALUE_REFERENCES_SUPPORTED)
2639      Image2D(Image2D&amp;&amp; img) CL_HPP_NOEXCEPT : Image(std::move(img)) {}
2640      Image2D&amp; operator = (Image2D &amp;&amp;img)
2641      {
2642          Image::operator=(std::move(img));
2643          return *this;
2644      }
2645  #endif 
2646  };
2647  #if !defined(CL_VERSION_1_2)
2648  class CL_EXT_PREFIX__VERSION_1_1_DEPRECATED Image2DGL CL_EXT_SUFFIX__VERSION_1_1_DEPRECATED : public Image2D
2649  {
2650  public:
2651      Image2DGL(
2652          const Context&amp; context,
2653          cl_mem_flags flags,
2654          cl_GLenum target,
2655          cl_GLint  miplevel,
2656          cl_GLuint texobj,
2657          cl_int * err = NULL)
2658      {
2659          cl_int error;
2660          object_ = ::clCreateFromGLTexture2D(
2661              context(),
2662              flags,
2663              target,
2664              miplevel,
2665              texobj,
2666              &amp;error);
2667          detail::errHandler(error, __CREATE_GL_TEXTURE_2D_ERR);
2668          if (err != NULL) {
2669              *err = error;
2670          }
2671      }
2672      Image2DGL() : Image2D() { }
2673      __CL_EXPLICIT_CONSTRUCTORS Image2DGL(const cl_mem&amp; image) : Image2D(image) { }
2674      Image2DGL&amp; operator = (const cl_mem&amp; rhs)
2675      {
2676          Image2D::operator=(rhs);
2677          return *this;
2678      }
2679      Image2DGL(const Image2DGL&amp; img) : Image2D(img) {}
2680      Image2DGL&amp; operator = (const Image2DGL &amp;img)
2681      {
2682          Image2D::operator=(img);
2683          return *this;
2684      }
2685  #if defined(CL_HPP_RVALUE_REFERENCES_SUPPORTED)
2686      Image2DGL(Image2DGL&amp;&amp; img) CL_HPP_NOEXCEPT : Image2D(std::move(img)) {}
2687      Image2DGL&amp; operator = (Image2DGL &amp;&amp;img)
2688      {
2689          Image2D::operator=(std::move(img));
2690          return *this;
2691      }
2692  #endif 
2693  };
2694  #endif 
2695  #if defined(CL_VERSION_1_2)
2696  class Image2DArray : public Image
2697  {
2698  public:
2699      Image2DArray(
2700          const Context&amp; context,
2701          cl_mem_flags flags,
2702          ImageFormat format,
2703          ::size_t arraySize,
2704          ::size_t width,
2705          ::size_t height,
2706          ::size_t rowPitch,
2707          ::size_t slicePitch,
2708          void* host_ptr = NULL,
2709          cl_int* err = NULL)
2710      {
2711          cl_int error;
2712          cl_image_desc desc =
2713          {
2714              CL_MEM_OBJECT_IMAGE2D_ARRAY,
2715              width,
2716              height,
2717              0,       
2718              arraySize,
2719              rowPitch,
2720              slicePitch,
2721              0, 0, 0
2722          };
2723          object_ = ::clCreateImage(
2724              context(), 
2725              flags, 
2726              &amp;format, 
2727              &amp;desc, 
2728              host_ptr, 
2729              &amp;error);
2730          detail::errHandler(error, __CREATE_IMAGE_ERR);
2731          if (err != NULL) {
2732              *err = error;
2733          }
2734      }
2735      Image2DArray() { }
2736      __CL_EXPLICIT_CONSTRUCTORS Image2DArray(const cl_mem&amp; imageArray) : Image(imageArray) { }
2737      Image2DArray&amp; operator = (const cl_mem&amp; rhs)
2738      {
2739          Image::operator=(rhs);
2740          return *this;
2741      }
2742      Image2DArray(const Image2DArray&amp; img) : Image(img) {}
2743      Image2DArray&amp; operator = (const Image2DArray &amp;img)
2744      {
2745          Image::operator=(img);
2746          return *this;
2747      }
2748  #if defined(CL_HPP_RVALUE_REFERENCES_SUPPORTED)
2749      Image2DArray(Image2DArray&amp;&amp; img) CL_HPP_NOEXCEPT : Image(std::move(img)) {}
2750      Image2DArray&amp; operator = (Image2DArray &amp;&amp;img)
2751      {
2752          Image::operator=(std::move(img));
2753          return *this;
2754      }
2755  #endif 
2756  };
2757  #endif 
2758  class Image3D : public Image
2759  {
2760  public:
2761      Image3D(
2762          const Context&amp; context,
2763          cl_mem_flags flags,
2764          ImageFormat format,
2765          ::size_t width,
2766          ::size_t height,
2767          ::size_t depth,
2768          ::size_t row_pitch = 0,
2769          ::size_t slice_pitch = 0,
2770          void* host_ptr = NULL,
2771          cl_int* err = NULL)
2772      {
2773          cl_int error;
2774          bool useCreateImage;
2775  #if defined(CL_VERSION_1_2) &amp;&amp; defined(CL_USE_DEPRECATED_OPENCL_1_1_APIS)
2776          {
2777              cl_uint version = detail::getContextPlatformVersion(context());
2778              useCreateImage = (version &gt;= 0x10002); 
2779          }
2780  #elif defined(CL_VERSION_1_2)
2781          useCreateImage = true;
2782  #else
2783          useCreateImage = false;
2784  #endif
2785  #if defined(CL_VERSION_1_2)
2786          if (useCreateImage)
2787          {
2788              cl_image_desc desc =
2789              {
2790                  CL_MEM_OBJECT_IMAGE3D,
2791                  width,
2792                  height,
2793                  depth,
2794                  0,      
2795                  row_pitch,
2796                  slice_pitch,
2797                  0, 0, 0
2798              };
2799              object_ = ::clCreateImage(
2800                  context(), 
2801                  flags, 
2802                  &amp;format, 
2803                  &amp;desc, 
2804                  host_ptr, 
2805                  &amp;error);
2806              detail::errHandler(error, __CREATE_IMAGE_ERR);
2807              if (err != NULL) {
2808                  *err = error;
2809              }
2810          }
2811  #endif  
2812  #if !defined(CL_VERSION_1_2) || defined(CL_USE_DEPRECATED_OPENCL_1_1_APIS)
2813          if (!useCreateImage)
2814          {
2815              object_ = ::clCreateImage3D(
2816                  context(), flags, &amp;format, width, height, depth, row_pitch,
2817                  slice_pitch, host_ptr, &amp;error);
2818              detail::errHandler(error, __CREATE_IMAGE3D_ERR);
2819              if (err != NULL) {
2820                  *err = error;
2821              }
2822          }
2823  #endif 
2824      }
2825      Image3D() : Image() { }
2826      __CL_EXPLICIT_CONSTRUCTORS Image3D(const cl_mem&amp; image3D) : Image(image3D) { }
2827      Image3D&amp; operator = (const cl_mem&amp; rhs)
2828      {
2829          Image::operator=(rhs);
2830          return *this;
2831      }
2832      Image3D(const Image3D&amp; img) : Image(img) {}
2833      Image3D&amp; operator = (const Image3D &amp;img)
2834      {
2835          Image::operator=(img);
2836          return *this;
2837      }
2838  #if defined(CL_HPP_RVALUE_REFERENCES_SUPPORTED)
2839      Image3D(Image3D&amp;&amp; img) CL_HPP_NOEXCEPT : Image(std::move(img)) {}
2840      Image3D&amp; operator = (Image3D &amp;&amp;img)
2841      {
2842          Image::operator=(std::move(img));
2843          return *this;
2844      }
2845  #endif 
2846  };
2847  #if !defined(CL_VERSION_1_2)
2848  class Image3DGL : public Image3D
2849  {
2850  public:
2851      Image3DGL(
2852          const Context&amp; context,
2853          cl_mem_flags flags,
2854          cl_GLenum target,
2855          cl_GLint  miplevel,
2856          cl_GLuint texobj,
2857          cl_int * err = NULL)
2858      {
2859          cl_int error;
2860          object_ = ::clCreateFromGLTexture3D(
2861              context(),
2862              flags,
2863              target,
2864              miplevel,
2865              texobj,
2866              &amp;error);
2867          detail::errHandler(error, __CREATE_GL_TEXTURE_3D_ERR);
2868          if (err != NULL) {
2869              *err = error;
2870          }
2871      }
2872      Image3DGL() : Image3D() { }
2873      __CL_EXPLICIT_CONSTRUCTORS Image3DGL(const cl_mem&amp; image) : Image3D(image) { }
2874      Image3DGL&amp; operator = (const cl_mem&amp; rhs)
2875      {
2876          Image3D::operator=(rhs);
2877          return *this;
2878      }
2879      Image3DGL(const Image3DGL&amp; img) : Image3D(img) {}
2880      Image3DGL&amp; operator = (const Image3DGL &amp;img)
2881      {
2882          Image3D::operator=(img);
2883          return *this;
2884      }
2885  #if defined(CL_HPP_RVALUE_REFERENCES_SUPPORTED)
2886      Image3DGL(Image3DGL&amp;&amp; img) CL_HPP_NOEXCEPT : Image3D(std::move(img)) {}
2887      Image3DGL&amp; operator = (Image3DGL &amp;&amp;img)
2888      {
2889          Image3D::operator=(std::move(img));
2890          return *this;
2891      }
2892  #endif 
2893  };
2894  #endif 
2895  #if defined(CL_VERSION_1_2)
2896  class ImageGL : public Image
2897  {
2898  public:
2899      ImageGL(
2900          const Context&amp; context,
2901          cl_mem_flags flags,
2902          cl_GLenum target,
2903          cl_GLint  miplevel,
2904          cl_GLuint texobj,
2905          cl_int * err = NULL)
2906      {
2907          cl_int error;
2908          object_ = ::clCreateFromGLTexture(
2909              context(), 
2910              flags, 
2911              target,
2912              miplevel,
2913              texobj,
2914              &amp;error);
2915          detail::errHandler(error, __CREATE_GL_TEXTURE_ERR);
2916          if (err != NULL) {
2917              *err = error;
2918          }
2919      }
2920      ImageGL() : Image() { }
2921      __CL_EXPLICIT_CONSTRUCTORS ImageGL(const cl_mem&amp; image) : Image(image) { }
2922      ImageGL&amp; operator = (const cl_mem&amp; rhs)
2923      {
2924          Image::operator=(rhs);
2925          return *this;
2926      }
2927      ImageGL(const ImageGL&amp; img) : Image(img) {}
2928      ImageGL&amp; operator = (const ImageGL &amp;img)
2929      {
2930          Image::operator=(img);
2931          return *this;
2932      }
2933  #if defined(CL_HPP_RVALUE_REFERENCES_SUPPORTED)
2934      ImageGL(ImageGL&amp;&amp; img) CL_HPP_NOEXCEPT : Image(std::move(img)) {}
2935      ImageGL&amp; operator = (ImageGL &amp;&amp;img)
2936      {
2937          Image::operator=(std::move(img));
2938          return *this;
2939      }
2940  #endif 
2941  };
2942  #endif 
2943  class BufferRenderGL : 
2944  #if defined(CL_VERSION_1_2)
2945      public ImageGL
2946  #else 
2947      public Image2DGL
2948  #endif 
2949  {
2950  public:
2951      BufferRenderGL(
2952          const Context&amp; context,
2953          cl_mem_flags flags,
2954          cl_GLuint bufobj,
2955          cl_int * err = NULL)
2956      {
2957          cl_int error;
2958          object_ = ::clCreateFromGLRenderbuffer(
2959              context(),
2960              flags,
2961              bufobj,
2962              &amp;error);
2963          detail::errHandler(error, __CREATE_GL_RENDER_BUFFER_ERR);
2964          if (err != NULL) {
2965              *err = error;
2966          }
2967      }
2968  #if defined(CL_VERSION_1_2)
2969      BufferRenderGL() : ImageGL() {};
2970  #else 
2971      BufferRenderGL() : Image2DGL() {};
2972  #endif 
2973  #if defined(CL_VERSION_1_2)
2974      __CL_EXPLICIT_CONSTRUCTORS BufferRenderGL(const cl_mem&amp; buffer) : ImageGL(buffer) { }
2975  #else 
2976      __CL_EXPLICIT_CONSTRUCTORS BufferRenderGL(const cl_mem&amp; buffer) : Image2DGL(buffer) { }
2977  #endif 
2978      BufferRenderGL&amp; operator = (const cl_mem&amp; rhs)
2979      {
2980  #if defined(CL_VERSION_1_2)
2981          ImageGL::operator=(rhs);
2982  #else 
2983          Image2DGL::operator=(rhs);
2984  #endif 
2985          return *this;
2986      }
2987  #if defined(CL_VERSION_1_2)
2988      BufferRenderGL(const BufferRenderGL&amp; buf) : ImageGL(buf) {}
2989  #else 
2990      BufferRenderGL(const BufferRenderGL&amp; buf) : Image2DGL(buf) {}
2991  #endif 
2992      BufferRenderGL&amp; operator = (const BufferRenderGL &amp;rhs)
2993      {
2994  #if defined(CL_VERSION_1_2)
2995          ImageGL::operator=(rhs);
2996  #else 
2997          Image2DGL::operator=(rhs);
2998  #endif 
2999          return *this;
3000      }
3001  #if defined(CL_HPP_RVALUE_REFERENCES_SUPPORTED)
3002  #if defined(CL_VERSION_1_2)
3003      BufferRenderGL(BufferRenderGL&amp;&amp; buf) CL_HPP_NOEXCEPT : ImageGL(std::move(buf)) {}
3004  #else 
3005      BufferRenderGL(BufferRenderGL&amp;&amp; buf) CL_HPP_NOEXCEPT : Image2DGL(std::move(buf)) {}
3006  #endif 
3007      BufferRenderGL&amp; operator = (BufferRenderGL &amp;&amp;buf)
3008      {
3009  #if defined(CL_VERSION_1_2)
3010          ImageGL::operator=(std::move(buf));
3011  #else 
3012          Image2DGL::operator=(std::move(buf));
3013  #endif 
3014          return *this;
3015      }
3016  #endif 
3017      cl_int getObjectInfo(
3018          cl_gl_object_type *type,
3019          cl_GLuint * gl_object_name)
3020      {
3021          return detail::errHandler(
3022              ::clGetGLObjectInfo(object_, type, gl_object_name),
3023              __GET_GL_OBJECT_INFO_ERR);
3024      }
3025  };
3026  class Sampler : public detail::Wrapper&lt;cl_sampler&gt;
3027  {
3028  public:
3029      Sampler() { }
3030      Sampler(
3031          const Context&amp; context,
3032          cl_bool normalized_coords,
3033          cl_addressing_mode addressing_mode,
3034          cl_filter_mode filter_mode,
3035          cl_int* err = NULL)
3036      {
3037          cl_int error;
3038          object_ = ::clCreateSampler(
3039              context(), 
3040              normalized_coords,
3041              addressing_mode,
3042              filter_mode,
3043              &amp;error);
3044          detail::errHandler(error, __CREATE_SAMPLER_ERR);
3045          if (err != NULL) {
3046              *err = error;
3047          }
3048      }
3049      __CL_EXPLICIT_CONSTRUCTORS Sampler(const cl_sampler&amp; sampler) : detail::Wrapper&lt;cl_type&gt;(sampler) { }
3050      Sampler&amp; operator = (const cl_sampler&amp; rhs)
3051      {
3052          detail::Wrapper&lt;cl_type&gt;::operator=(rhs);
3053          return *this;
3054      }
3055      Sampler(const Sampler&amp; sam) : detail::Wrapper&lt;cl_type&gt;(sam) {}
3056      Sampler&amp; operator = (const Sampler &amp;sam)
3057      {
3058          detail::Wrapper&lt;cl_type&gt;::operator=(sam);
3059          return *this;
3060      }
3061  #if defined(CL_HPP_RVALUE_REFERENCES_SUPPORTED)
3062      Sampler(Sampler&amp;&amp; sam) CL_HPP_NOEXCEPT : detail::Wrapper&lt;cl_type&gt;(std::move(sam)) {}
3063      Sampler&amp; operator = (Sampler &amp;&amp;sam)
3064      {
3065          detail::Wrapper&lt;cl_type&gt;::operator=(std::move(sam));
3066          return *this;
3067      }
3068  #endif 
3069      template &lt;typename T&gt;
3070      cl_int getInfo(cl_sampler_info name, T* param) const
3071      {
3072          return detail::errHandler(
3073              detail::getInfo(&amp;::clGetSamplerInfo, object_, name, param),
3074              __GET_SAMPLER_INFO_ERR);
3075      }
3076      template &lt;cl_int name&gt; typename
3077      detail::param_traits&lt;detail::cl_sampler_info, name&gt;::param_type
3078      getInfo(cl_int* err = NULL) const
3079      {
3080          typename detail::param_traits&lt;
3081              detail::cl_sampler_info, name&gt;::param_type param;
3082          cl_int result = getInfo(name, &amp;param);
3083          if (err != NULL) {
3084              *err = result;
3085          }
3086          return param;
3087      }
3088  };
3089  class Program;
3090  class CommandQueue;
3091  class Kernel;
3092  class NDRange
3093  {
3094  private:
3095      size_t&lt;3&gt; sizes_;
3096      cl_uint dimensions_;
3097  public:
3098      NDRange()
3099          : dimensions_(0)
3100      { }
3101      NDRange(::size_t size0)
3102          : dimensions_(1)
3103      {
3104          sizes_[0] = size0;
3105      }
3106      NDRange(::size_t size0, ::size_t size1)
3107          : dimensions_(2)
3108      {
3109          sizes_[0] = size0;
3110          sizes_[1] = size1;
3111      }
3112      NDRange(::size_t size0, ::size_t size1, ::size_t size2)
3113          : dimensions_(3)
3114      {
3115          sizes_[0] = size0;
3116          sizes_[1] = size1;
3117          sizes_[2] = size2;
3118      }
3119      operator const ::size_t*() const { 
3120          return (const ::size_t*) sizes_; 
3121      }
3122      ::size_t dimensions() const { return dimensions_; }
3123  };
3124  static const NDRange NullRange;
3125  struct LocalSpaceArg
3126  {
3127      ::size_t size_;
3128  };
3129  namespace detail {
3130  template &lt;typename T&gt;
3131  struct KernelArgumentHandler
3132  {
3133      static ::size_t size(const T&amp;) { return sizeof(T); }
3134      static const T* ptr(const T&amp; value) { return &amp;value; }
3135  };
3136  template &lt;&gt;
3137  struct KernelArgumentHandler&lt;LocalSpaceArg&gt;
3138  {
3139      static ::size_t size(const LocalSpaceArg&amp; value) { return value.size_; }
3140      static const void* ptr(const LocalSpaceArg&amp;) { return NULL; }
3141  };
3142  } 
3143  inline CL_EXT_PREFIX__VERSION_1_1_DEPRECATED LocalSpaceArg
3144  __local(::size_t size) CL_EXT_SUFFIX__VERSION_1_1_DEPRECATED;
3145  inline LocalSpaceArg
3146  __local(::size_t size)
3147  {
3148      LocalSpaceArg ret = { size };
3149      return ret;
3150  }
3151  inline LocalSpaceArg
3152  Local(::size_t size)
3153  {
3154      LocalSpaceArg ret = { size };
3155      return ret;
3156  }
3157  class Kernel : public detail::Wrapper&lt;cl_kernel&gt;
3158  {
3159  public:
3160      inline Kernel(const Program&amp; program, const char* name, cl_int* err = NULL);
3161      Kernel() { }
3162      __CL_EXPLICIT_CONSTRUCTORS Kernel(const cl_kernel&amp; kernel) : detail::Wrapper&lt;cl_type&gt;(kernel) { }
3163      Kernel&amp; operator = (const cl_kernel&amp; rhs)
3164      {
3165          detail::Wrapper&lt;cl_type&gt;::operator=(rhs);
3166          return *this;
3167      }
3168      Kernel(const Kernel&amp; kernel) : detail::Wrapper&lt;cl_type&gt;(kernel) {}
3169      Kernel&amp; operator = (const Kernel &amp;kernel)
3170      {
3171          detail::Wrapper&lt;cl_type&gt;::operator=(kernel);
3172          return *this;
3173      }
3174  #if defined(CL_HPP_RVALUE_REFERENCES_SUPPORTED)
3175      Kernel(Kernel&amp;&amp; kernel) CL_HPP_NOEXCEPT : detail::Wrapper&lt;cl_type&gt;(std::move(kernel)) {}
3176      Kernel&amp; operator = (Kernel &amp;&amp;kernel)
3177      {
3178          detail::Wrapper&lt;cl_type&gt;::operator=(std::move(kernel));
3179          return *this;
3180      }
3181  #endif 
3182      template &lt;typename T&gt;
3183      cl_int getInfo(cl_kernel_info name, T* param) const
3184      {
3185          return detail::errHandler(
3186              detail::getInfo(&amp;::clGetKernelInfo, object_, name, param),
3187              __GET_KERNEL_INFO_ERR);
3188      }
3189      template &lt;cl_int name&gt; typename
3190      detail::param_traits&lt;detail::cl_kernel_info, name&gt;::param_type
3191      getInfo(cl_int* err = NULL) const
3192      {
3193          typename detail::param_traits&lt;
3194              detail::cl_kernel_info, name&gt;::param_type param;
3195          cl_int result = getInfo(name, &amp;param);
3196          if (err != NULL) {
3197              *err = result;
3198          }
3199          return param;
3200      }
3201  #if defined(CL_VERSION_1_2)
3202      template &lt;typename T&gt;
3203      cl_int getArgInfo(cl_uint argIndex, cl_kernel_arg_info name, T* param) const
3204      {
3205          return detail::errHandler(
3206              detail::getInfo(&amp;::clGetKernelArgInfo, object_, argIndex, name, param),
3207              __GET_KERNEL_ARG_INFO_ERR);
3208      }
3209      template &lt;cl_int name&gt; typename
3210      detail::param_traits&lt;detail::cl_kernel_arg_info, name&gt;::param_type
3211      getArgInfo(cl_uint argIndex, cl_int* err = NULL) const
3212      {
3213          typename detail::param_traits&lt;
3214              detail::cl_kernel_arg_info, name&gt;::param_type param;
3215          cl_int result = getArgInfo(argIndex, name, &amp;param);
3216          if (err != NULL) {
3217              *err = result;
3218          }
3219          return param;
3220      }
3221  #endif 
3222      template &lt;typename T&gt;
3223      cl_int getWorkGroupInfo(
3224          const Device&amp; device, cl_kernel_work_group_info name, T* param) const
3225      {
3226          return detail::errHandler(
3227              detail::getInfo(
3228                  &amp;::clGetKernelWorkGroupInfo, object_, device(), name, param),
3229                  __GET_KERNEL_WORK_GROUP_INFO_ERR);
3230      }
3231      template &lt;cl_int name&gt; typename
3232      detail::param_traits&lt;detail::cl_kernel_work_group_info, name&gt;::param_type
3233          getWorkGroupInfo(const Device&amp; device, cl_int* err = NULL) const
3234      {
3235          typename detail::param_traits&lt;
3236          detail::cl_kernel_work_group_info, name&gt;::param_type param;
3237          cl_int result = getWorkGroupInfo(device, name, &amp;param);
3238          if (err != NULL) {
3239              *err = result;
3240          }
3241          return param;
3242      }
3243      template &lt;typename T&gt;
3244      cl_int setArg(cl_uint index, const T &amp;value)
3245      {
3246          return detail::errHandler(
3247              ::clSetKernelArg(
3248                  object_,
3249                  index,
3250                  detail::KernelArgumentHandler&lt;T&gt;::size(value),
3251                  detail::KernelArgumentHandler&lt;T&gt;::ptr(value)),
3252              __SET_KERNEL_ARGS_ERR);
3253      }
3254      cl_int setArg(cl_uint index, ::size_t size, const void* argPtr)
3255      {
3256          return detail::errHandler(
3257              ::clSetKernelArg(object_, index, size, argPtr),
3258              __SET_KERNEL_ARGS_ERR);
3259      }
3260  };
3261  class Program : public detail::Wrapper&lt;cl_program&gt;
3262  {
3263  public:
3264      typedef VECTOR_CLASS&lt;std::pair&lt;const void*, ::size_t&gt; &gt; Binaries;
3265      typedef VECTOR_CLASS&lt;std::pair&lt;const char*, ::size_t&gt; &gt; Sources;
3266      Program(
3267          const STRING_CLASS&amp; source,
3268          bool build = false,
3269          cl_int* err = NULL)
3270      {
3271          cl_int error;
3272          const char * strings = source.c_str();
3273          const ::size_t length  = source.size();
3274          Context context = Context::getDefault(err);
3275          object_ = ::clCreateProgramWithSource(
3276              context(), (cl_uint)1, &amp;strings, &amp;length, &amp;error);
3277          detail::errHandler(error, __CREATE_PROGRAM_WITH_SOURCE_ERR);
3278          if (error == CL_SUCCESS &amp;&amp; build) {
3279              error = ::clBuildProgram(
3280                  object_,
3281                  0,
3282                  NULL,
3283                  &quot;&quot;,
3284                  NULL,
3285                  NULL);
3286              detail::errHandler(error, __BUILD_PROGRAM_ERR);
3287          }
3288          if (err != NULL) {
3289              *err = error;
3290          }
3291      }
3292      Program(
3293          const Context&amp; context,
3294          const STRING_CLASS&amp; source,
3295          bool build = false,
3296          cl_int* err = NULL)
3297      {
3298          cl_int error;
3299          const char * strings = source.c_str();
3300          const ::size_t length  = source.size();
3301          object_ = ::clCreateProgramWithSource(
3302              context(), (cl_uint)1, &amp;strings, &amp;length, &amp;error);
3303          detail::errHandler(error, __CREATE_PROGRAM_WITH_SOURCE_ERR);
3304          if (error == CL_SUCCESS &amp;&amp; build) {
3305              error = ::clBuildProgram(
3306                  object_,
3307                  0,
3308                  NULL,
3309                  &quot;&quot;,
3310                  NULL,
3311                  NULL);
3312              detail::errHandler(error, __BUILD_PROGRAM_ERR);
3313          }
3314          if (err != NULL) {
3315              *err = error;
3316          }
3317      }
3318      Program(
3319          const Context&amp; context,
3320          const Sources&amp; sources,
3321          cl_int* err = NULL)
3322      {
3323          cl_int error;
3324          const ::size_t n = (::size_t)sources.size();
3325          ::size_t* lengths = (::size_t*) alloca(n * sizeof(::size_t));
3326          const char** strings = (const char**) alloca(n * sizeof(const char*));
3327          for (::size_t i = 0; i &lt; n; ++i) {
3328              strings[i] = sources[(int)i].first;
3329              lengths[i] = sources[(int)i].second;
3330          }
3331          object_ = ::clCreateProgramWithSource(
3332              context(), (cl_uint)n, strings, lengths, &amp;error);
3333          detail::errHandler(error, __CREATE_PROGRAM_WITH_SOURCE_ERR);
3334          if (err != NULL) {
3335              *err = error;
3336          }
3337      }
3338      Program(
3339          const Context&amp; context,
3340          const VECTOR_CLASS&lt;Device&gt;&amp; devices,
3341          const Binaries&amp; binaries,
3342          VECTOR_CLASS&lt;cl_int&gt;* binaryStatus = NULL,
3343          cl_int* err = NULL)
3344      {
3345          cl_int error;
3346          const ::size_t numDevices = devices.size();
3347          if(binaries.size() != numDevices) {
3348              error = CL_INVALID_VALUE;
3349              detail::errHandler(error, __CREATE_PROGRAM_WITH_BINARY_ERR);
3350              if (err != NULL) {
3351                  *err = error;
3352              }
3353              return;
3354          }
3355          ::size_t* lengths = (::size_t*) alloca(numDevices * sizeof(::size_t));
3356          const unsigned char** images = (const unsigned char**) alloca(numDevices * sizeof(const unsigned char**));
3357          for (::size_t i = 0; i &lt; numDevices; ++i) {
3358              images[i] = (const unsigned char*)binaries[i].first;
3359              lengths[i] = binaries[(int)i].second;
3360          }
3361          cl_device_id* deviceIDs = (cl_device_id*) alloca(numDevices * sizeof(cl_device_id));
3362          for( ::size_t deviceIndex = 0; deviceIndex &lt; numDevices; ++deviceIndex ) {
3363              deviceIDs[deviceIndex] = (devices[deviceIndex])();
3364          }
3365          if(binaryStatus) {
3366              binaryStatus-&gt;resize(numDevices);
3367          }
3368          object_ = ::clCreateProgramWithBinary(
3369              context(), (cl_uint) devices.size(),
3370              deviceIDs,
3371              lengths, images, (binaryStatus != NULL &amp;&amp; numDevices &gt; 0)
3372                 ? &amp;binaryStatus-&gt;front()
3373                 : NULL, &amp;error);
3374          detail::errHandler(error, __CREATE_PROGRAM_WITH_BINARY_ERR);
3375          if (err != NULL) {
3376              *err = error;
3377          }
3378      }
3379  #if defined(CL_VERSION_1_2)
3380      Program(
3381          const Context&amp; context,
3382          const VECTOR_CLASS&lt;Device&gt;&amp; devices,
3383          const STRING_CLASS&amp; kernelNames,
3384          cl_int* err = NULL)
3385      {
3386          cl_int error;
3387          ::size_t numDevices = devices.size();
3388          cl_device_id* deviceIDs = (cl_device_id*) alloca(numDevices * sizeof(cl_device_id));
3389          for( ::size_t deviceIndex = 0; deviceIndex &lt; numDevices; ++deviceIndex ) {
3390              deviceIDs[deviceIndex] = (devices[deviceIndex])();
3391          }
3392          object_ = ::clCreateProgramWithBuiltInKernels(
3393              context(), 
3394              (cl_uint) devices.size(),
3395              deviceIDs,
3396              kernelNames.c_str(), 
3397              &amp;error);
3398          detail::errHandler(error, __CREATE_PROGRAM_WITH_BUILT_IN_KERNELS_ERR);
3399          if (err != NULL) {
3400              *err = error;
3401          }
3402      }
3403  #endif 
3404      Program() { }
3405      __CL_EXPLICIT_CONSTRUCTORS Program(const cl_program&amp; program) : detail::Wrapper&lt;cl_type&gt;(program) { }
3406      Program&amp; operator = (const cl_program&amp; rhs)
3407      {
3408          detail::Wrapper&lt;cl_type&gt;::operator=(rhs);
3409          return *this;
3410      }
3411      Program(const Program&amp; program) : detail::Wrapper&lt;cl_type&gt;(program) {}
3412      Program&amp; operator = (const Program &amp;program)
3413      {
3414          detail::Wrapper&lt;cl_type&gt;::operator=(program);
3415          return *this;
3416      }
3417  #if defined(CL_HPP_RVALUE_REFERENCES_SUPPORTED)
3418      Program(Program&amp;&amp; program) CL_HPP_NOEXCEPT : detail::Wrapper&lt;cl_type&gt;(std::move(program)) {}
3419      Program&amp; operator = (Program &amp;&amp;program)
3420      {
3421          detail::Wrapper&lt;cl_type&gt;::operator=(std::move(program));
3422          return *this;
3423      }
3424  #endif 
3425      cl_int build(
3426          const VECTOR_CLASS&lt;Device&gt;&amp; devices,
3427          const char* options = NULL,
3428          void (CL_CALLBACK * notifyFptr)(cl_program, void *) = NULL,
3429          void* data = NULL) const
3430      {
3431          ::size_t numDevices = devices.size();
3432          cl_device_id* deviceIDs = (cl_device_id*) alloca(numDevices * sizeof(cl_device_id));
3433          for( ::size_t deviceIndex = 0; deviceIndex &lt; numDevices; ++deviceIndex ) {
3434              deviceIDs[deviceIndex] = (devices[deviceIndex])();
3435          }
3436          return detail::errHandler(
3437              ::clBuildProgram(
3438                  object_,
3439                  (cl_uint)
3440                  devices.size(),
3441                  deviceIDs,
3442                  options,
3443                  notifyFptr,
3444                  data),
3445                  __BUILD_PROGRAM_ERR);
3446      }
3447      cl_int build(
3448          const char* options = NULL,
3449          void (CL_CALLBACK * notifyFptr)(cl_program, void *) = NULL,
3450          void* data = NULL) const
3451      {
3452          return detail::errHandler(
3453              ::clBuildProgram(
3454                  object_,
3455                  0,
3456                  NULL,
3457                  options,
3458                  notifyFptr,
3459                  data),
3460                  __BUILD_PROGRAM_ERR);
3461      }
3462  #if defined(CL_VERSION_1_2)
3463      cl_int compile(
3464          const char* options = NULL,
3465          void (CL_CALLBACK * notifyFptr)(cl_program, void *) = NULL,
3466          void* data = NULL) const
3467      {
3468          return detail::errHandler(
3469              ::clCompileProgram(
3470                  object_,
3471                  0,
3472                  NULL,
3473                  options,
3474                  0,
3475                  NULL,
3476                  NULL,
3477                  notifyFptr,
3478                  data),
3479                  __COMPILE_PROGRAM_ERR);
3480      }
3481  #endif
3482      template &lt;typename T&gt;
3483      cl_int getInfo(cl_program_info name, T* param) const
3484      {
3485          return detail::errHandler(
3486              detail::getInfo(&amp;::clGetProgramInfo, object_, name, param),
3487              __GET_PROGRAM_INFO_ERR);
3488      }
3489      template &lt;cl_int name&gt; typename
3490      detail::param_traits&lt;detail::cl_program_info, name&gt;::param_type
3491      getInfo(cl_int* err = NULL) const
3492      {
3493          typename detail::param_traits&lt;
3494              detail::cl_program_info, name&gt;::param_type param;
3495          cl_int result = getInfo(name, &amp;param);
3496          if (err != NULL) {
3497              *err = result;
3498          }
3499          return param;
3500      }
3501      template &lt;typename T&gt;
3502      cl_int getBuildInfo(
3503          const Device&amp; device, cl_program_build_info name, T* param) const
3504      {
3505          return detail::errHandler(
3506              detail::getInfo(
3507                  &amp;::clGetProgramBuildInfo, object_, device(), name, param),
3508                  __GET_PROGRAM_BUILD_INFO_ERR);
3509      }
3510      template &lt;cl_int name&gt; typename
3511      detail::param_traits&lt;detail::cl_program_build_info, name&gt;::param_type
3512      getBuildInfo(const Device&amp; device, cl_int* err = NULL) const
3513      {
3514          typename detail::param_traits&lt;
3515              detail::cl_program_build_info, name&gt;::param_type param;
3516          cl_int result = getBuildInfo(device, name, &amp;param);
3517          if (err != NULL) {
3518              *err = result;
3519          }
3520          return param;
3521      }
3522      cl_int createKernels(VECTOR_CLASS&lt;Kernel&gt;* kernels)
3523      {
3524          cl_uint numKernels;
3525          cl_int err = ::clCreateKernelsInProgram(object_, 0, NULL, &amp;numKernels);
3526          if (err != CL_SUCCESS) {
3527              return detail::errHandler(err, __CREATE_KERNELS_IN_PROGRAM_ERR);
3528          }
3529          Kernel* value = (Kernel*) alloca(numKernels * sizeof(Kernel));
3530          err = ::clCreateKernelsInProgram(
3531              object_, numKernels, (cl_kernel*) value, NULL);
3532          if (err != CL_SUCCESS) {
3533              return detail::errHandler(err, __CREATE_KERNELS_IN_PROGRAM_ERR);
3534          }
3535          kernels-&gt;assign(&amp;value[0], &amp;value[numKernels]);
3536          return CL_SUCCESS;
3537      }
3538  };
3539  #if defined(CL_VERSION_1_2)
3540  inline Program linkProgram(
3541      Program input1,
3542      Program input2,
3543      const char* options = NULL,
3544      void (CL_CALLBACK * notifyFptr)(cl_program, void *) = NULL,
3545      void* data = NULL,
3546      cl_int* err = NULL) 
3547  {
3548      cl_int error_local = CL_SUCCESS;
3549      cl_program programs[2] = { input1(), input2() };
3550      Context ctx = input1.getInfo&lt;CL_PROGRAM_CONTEXT&gt;(&amp;error_local);
3551      if(error_local!=CL_SUCCESS) {
3552          detail::errHandler(error_local, __LINK_PROGRAM_ERR);
3553      }
3554      cl_program prog = ::clLinkProgram(
3555          ctx(),
3556          0,
3557          NULL,
3558          options,
3559          2,
3560          programs,
3561          notifyFptr,
3562          data,
3563          &amp;error_local);
3564      detail::errHandler(error_local,__COMPILE_PROGRAM_ERR);
3565      if (err != NULL) {
3566          *err = error_local;
3567      }
3568      return Program(prog);
3569  }
3570  inline Program linkProgram(
3571      VECTOR_CLASS&lt;Program&gt; inputPrograms,
3572      const char* options = NULL,
3573      void (CL_CALLBACK * notifyFptr)(cl_program, void *) = NULL,
3574      void* data = NULL,
3575      cl_int* err = NULL) 
3576  {
3577      cl_int error_local = CL_SUCCESS;
3578      cl_program * programs = (cl_program*) alloca(inputPrograms.size() * sizeof(cl_program));
3579      if (programs != NULL) {
3580          for (unsigned int i = 0; i &lt; inputPrograms.size(); i++) {
3581            programs[i] = inputPrograms[i]();
3582          }
3583      } 
3584      Context ctx;
3585      if(inputPrograms.size() &gt; 0) {
3586          ctx = inputPrograms[0].getInfo&lt;CL_PROGRAM_CONTEXT&gt;(&amp;error_local);
3587          if(error_local!=CL_SUCCESS) {
3588              detail::errHandler(error_local, __LINK_PROGRAM_ERR);
3589          }
3590      }
3591      cl_program prog = ::clLinkProgram(
3592          ctx(),
3593          0,
3594          NULL,
3595          options,
3596          (cl_uint)inputPrograms.size(),
3597          programs,
3598          notifyFptr,
3599          data,
3600          &amp;error_local);
3601      detail::errHandler(error_local,__COMPILE_PROGRAM_ERR);
3602      if (err != NULL) {
3603          *err = error_local;
3604      }
3605      return Program(prog);
3606  }
3607  #endif
3608  template&lt;&gt;
3609  inline VECTOR_CLASS&lt;char *&gt; cl::Program::getInfo&lt;CL_PROGRAM_BINARIES&gt;(cl_int* err) const
3610  {
3611      VECTOR_CLASS&lt; ::size_t&gt; sizes = getInfo&lt;CL_PROGRAM_BINARY_SIZES&gt;();
3612      VECTOR_CLASS&lt;char *&gt; binaries;
3613      for (VECTOR_CLASS&lt; ::size_t&gt;::iterator s = sizes.begin(); s != sizes.end(); ++s) 
3614      {
3615          char *ptr = NULL;
3616          if (*s != 0) 
3617              ptr = new char[*s];
3618          binaries.push_back(ptr);
3619      }
3620      cl_int result = getInfo(CL_PROGRAM_BINARIES, &amp;binaries);
3621      if (err != NULL) {
3622          *err = result;
3623      }
3624      return binaries;
3625  }
3626  inline Kernel::Kernel(const Program&amp; program, const char* name, cl_int* err)
3627  {
3628      cl_int error;
3629      object_ = ::clCreateKernel(program(), name, &amp;error);
3630      detail::errHandler(error, __CREATE_KERNEL_ERR);
3631      if (err != NULL) {
3632          *err = error;
3633      }
3634  }
3635  class CommandQueue : public detail::Wrapper&lt;cl_command_queue&gt;
3636  {
3637  private:
3638  #ifdef CL_HPP_CPP11_ATOMICS_SUPPORTED
3639      static std::atomic&lt;int&gt; default_initialized_;
3640  #else 
3641      static volatile int default_initialized_;
3642  #endif 
3643      static CommandQueue default_;
3644      static volatile cl_int default_error_;
3645  public:
3646     CommandQueue(
3647          cl_command_queue_properties properties,
3648          cl_int* err = NULL)
3649      {
3650          cl_int error;
3651          Context context = Context::getDefault(&amp;error);
3652          detail::errHandler(error, __CREATE_CONTEXT_ERR);
3653          if (error != CL_SUCCESS) {
3654              if (err != NULL) {
3655                  *err = error;
3656              }
3657          }
3658          else {
3659              Device device = context.getInfo&lt;CL_CONTEXT_DEVICES&gt;()[0];
3660              object_ = ::clCreateCommandQueue(
3661                  context(), device(), properties, &amp;error);
3662              detail::errHandler(error, __CREATE_COMMAND_QUEUE_ERR);
3663              if (err != NULL) {
3664                  *err = error;
3665              }
3666          }
3667      }
3668      explicit CommandQueue(
3669          const Context&amp; context,
3670          cl_command_queue_properties properties = 0,
3671          cl_int* err = NULL)
3672      {
3673          cl_int error;
3674          VECTOR_CLASS&lt;cl::Device&gt; devices;
3675          error = context.getInfo(CL_CONTEXT_DEVICES, &amp;devices);
3676          detail::errHandler(error, __CREATE_CONTEXT_ERR);
3677          if (error != CL_SUCCESS)
3678          {
3679              if (err != NULL) {
3680                  *err = error;
3681              }
3682              return;
3683          }
3684          object_ = ::clCreateCommandQueue(context(), devices[0](), properties, &amp;error);
3685          detail::errHandler(error, __CREATE_COMMAND_QUEUE_ERR);
3686          if (err != NULL) {
3687              *err = error;
3688          }
3689      }
3690      CommandQueue(
3691          const Context&amp; context,
3692          const Device&amp; device,
3693          cl_command_queue_properties properties = 0,
3694          cl_int* err = NULL)
3695      {
3696          cl_int error;
3697          object_ = ::clCreateCommandQueue(
3698              context(), device(), properties, &amp;error);
3699          detail::errHandler(error, __CREATE_COMMAND_QUEUE_ERR);
3700          if (err != NULL) {
3701              *err = error;
3702          }
3703      }
3704      CommandQueue(const CommandQueue&amp; queue) : detail::Wrapper&lt;cl_type&gt;(queue) {}
3705      CommandQueue&amp; operator = (const CommandQueue &amp;queue)
3706      {
3707          detail::Wrapper&lt;cl_type&gt;::operator=(queue);
3708          return *this;
3709      }
3710  #if defined(CL_HPP_RVALUE_REFERENCES_SUPPORTED)
3711      CommandQueue(CommandQueue&amp;&amp; queue) CL_HPP_NOEXCEPT : detail::Wrapper&lt;cl_type&gt;(std::move(queue)) {}
3712      CommandQueue&amp; operator = (CommandQueue &amp;&amp;queue)
3713      {
3714          detail::Wrapper&lt;cl_type&gt;::operator=(std::move(queue));
3715          return *this;
3716      }
3717  #endif 
3718      static CommandQueue getDefault(cl_int * err = NULL) 
3719      {
3720          int state = detail::compare_exchange(
3721              &amp;default_initialized_, 
3722              __DEFAULT_BEING_INITIALIZED, __DEFAULT_NOT_INITIALIZED);
3723          if (state &amp; __DEFAULT_INITIALIZED) {
3724              if (err != NULL) {
3725                  *err = default_error_;
3726              }
3727              return default_;
3728          }
3729          if (state &amp; __DEFAULT_BEING_INITIALIZED) {
3730                while(default_initialized_ != __DEFAULT_INITIALIZED) {
3731                    detail::fence();
3732                }
3733              if (err != NULL) {
3734                  *err = default_error_;
3735              }
3736              return default_;
3737          }
3738          cl_int error;
3739          Context context = Context::getDefault(&amp;error);
3740          detail::errHandler(error, __CREATE_COMMAND_QUEUE_ERR);
3741          if (error != CL_SUCCESS) {
3742              if (err != NULL) {
3743                  *err = error;
3744              }
3745          }
3746          else {
3747              Device device = context.getInfo&lt;CL_CONTEXT_DEVICES&gt;()[0];
3748              default_ = CommandQueue(context, device, 0, &amp;error);
3749              detail::errHandler(error, __CREATE_COMMAND_QUEUE_ERR);
3750              if (err != NULL) {
3751                  *err = error;
3752              }
3753          }
3754          detail::fence();
3755          default_error_ = error;
3756          default_initialized_ = __DEFAULT_INITIALIZED;
3757          detail::fence();
3758          if (err != NULL) {
3759              *err = default_error_;
3760          }
3761          return default_;
3762      }
3763      CommandQueue() { }
3764      __CL_EXPLICIT_CONSTRUCTORS CommandQueue(const cl_command_queue&amp; commandQueue) : detail::Wrapper&lt;cl_type&gt;(commandQueue) { }
3765      CommandQueue&amp; operator = (const cl_command_queue&amp; rhs)
3766      {
3767          detail::Wrapper&lt;cl_type&gt;::operator=(rhs);
3768          return *this;
3769      }
3770      template &lt;typename T&gt;
3771      cl_int getInfo(cl_command_queue_info name, T* param) const
3772      {
3773          return detail::errHandler(
3774              detail::getInfo(
3775                  &amp;::clGetCommandQueueInfo, object_, name, param),
3776                  __GET_COMMAND_QUEUE_INFO_ERR);
3777      }
3778      template &lt;cl_int name&gt; typename
3779      detail::param_traits&lt;detail::cl_command_queue_info, name&gt;::param_type
3780      getInfo(cl_int* err = NULL) const
3781      {
3782          typename detail::param_traits&lt;
3783              detail::cl_command_queue_info, name&gt;::param_type param;
3784          cl_int result = getInfo(name, &amp;param);
3785          if (err != NULL) {
3786              *err = result;
3787          }
3788          return param;
3789      }
3790      cl_int enqueueReadBuffer(
3791          const Buffer&amp; buffer,
3792          cl_bool blocking,
3793          ::size_t offset,
3794          ::size_t size,
3795          void* ptr,
3796          const VECTOR_CLASS&lt;Event&gt;* events = NULL,
3797          Event* event = NULL) const
3798      {
3799          cl_event tmp;
3800          cl_int err = detail::errHandler(
3801              ::clEnqueueReadBuffer(
3802                  object_, buffer(), blocking, offset, size,
3803                  ptr,
3804                  (events != NULL) ? (cl_uint) events-&gt;size() : 0,
3805                  (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
3806                  (event != NULL) ? &amp;tmp : NULL),
3807              __ENQUEUE_READ_BUFFER_ERR);
3808          if (event != NULL &amp;&amp; err == CL_SUCCESS)
3809              *event = tmp;
3810          return err;
3811      }
3812      cl_int enqueueWriteBuffer(
3813          const Buffer&amp; buffer,
3814          cl_bool blocking,
3815          ::size_t offset,
3816          ::size_t size,
3817          const void* ptr,
3818          const VECTOR_CLASS&lt;Event&gt;* events = NULL,
3819          Event* event = NULL) const
3820      {
3821          cl_event tmp;
3822          cl_int err = detail::errHandler(
3823              ::clEnqueueWriteBuffer(
3824                  object_, buffer(), blocking, offset, size,
3825                  ptr,
3826                  (events != NULL) ? (cl_uint) events-&gt;size() : 0,
3827                  (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
3828                  (event != NULL) ? &amp;tmp : NULL),
3829                  __ENQUEUE_WRITE_BUFFER_ERR);
3830          if (event != NULL &amp;&amp; err == CL_SUCCESS)
3831              *event = tmp;
3832          return err;
3833      }
3834      cl_int enqueueCopyBuffer(
3835          const Buffer&amp; src,
3836          const Buffer&amp; dst,
3837          ::size_t src_offset,
3838          ::size_t dst_offset,
3839          ::size_t size,
3840          const VECTOR_CLASS&lt;Event&gt;* events = NULL,
3841          Event* event = NULL) const
3842      {
3843          cl_event tmp;
3844          cl_int err = detail::errHandler(
3845              ::clEnqueueCopyBuffer(
3846                  object_, src(), dst(), src_offset, dst_offset, size,
3847                  (events != NULL) ? (cl_uint) events-&gt;size() : 0,
3848                  (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
3849                  (event != NULL) ? &amp;tmp : NULL),
3850              __ENQEUE_COPY_BUFFER_ERR);
3851          if (event != NULL &amp;&amp; err == CL_SUCCESS)
3852              *event = tmp;
3853          return err;
3854      }
3855      cl_int enqueueReadBufferRect(
3856          const Buffer&amp; buffer,
3857          cl_bool blocking,
3858          const size_t&lt;3&gt;&amp; buffer_offset,
3859          const size_t&lt;3&gt;&amp; host_offset,
3860          const size_t&lt;3&gt;&amp; region,
3861          ::size_t buffer_row_pitch,
3862          ::size_t buffer_slice_pitch,
3863          ::size_t host_row_pitch,
3864          ::size_t host_slice_pitch,
3865          void *ptr,
3866          const VECTOR_CLASS&lt;Event&gt;* events = NULL,
3867          Event* event = NULL) const
3868      {
3869          cl_event tmp;
3870          cl_int err = detail::errHandler(
3871              ::clEnqueueReadBufferRect(
3872                  object_, 
3873                  buffer(), 
3874                  blocking, 
3875                  (const ::size_t *)buffer_offset,
3876                  (const ::size_t *)host_offset,
3877                  (const ::size_t *)region,
3878                  buffer_row_pitch,
3879                  buffer_slice_pitch,
3880                  host_row_pitch,
3881                  host_slice_pitch,
3882                  ptr,
3883                  (events != NULL) ? (cl_uint) events-&gt;size() : 0,
3884                  (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
3885                  (event != NULL) ? &amp;tmp : NULL),
3886                  __ENQUEUE_READ_BUFFER_RECT_ERR);
3887          if (event != NULL &amp;&amp; err == CL_SUCCESS)
3888              *event = tmp;
3889          return err;
3890      }
3891      cl_int enqueueWriteBufferRect(
3892          const Buffer&amp; buffer,
3893          cl_bool blocking,
3894          const size_t&lt;3&gt;&amp; buffer_offset,
3895          const size_t&lt;3&gt;&amp; host_offset,
3896          const size_t&lt;3&gt;&amp; region,
3897          ::size_t buffer_row_pitch,
3898          ::size_t buffer_slice_pitch,
3899          ::size_t host_row_pitch,
3900          ::size_t host_slice_pitch,
3901          void *ptr,
3902          const VECTOR_CLASS&lt;Event&gt;* events = NULL,
3903          Event* event = NULL) const
3904      {
3905          cl_event tmp;
3906          cl_int err = detail::errHandler(
3907              ::clEnqueueWriteBufferRect(
3908                  object_, 
3909                  buffer(), 
3910                  blocking, 
3911                  (const ::size_t *)buffer_offset,
3912                  (const ::size_t *)host_offset,
3913                  (const ::size_t *)region,
3914                  buffer_row_pitch,
3915                  buffer_slice_pitch,
3916                  host_row_pitch,
3917                  host_slice_pitch,
3918                  ptr,
3919                  (events != NULL) ? (cl_uint) events-&gt;size() : 0,
3920                  (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
3921                  (event != NULL) ? &amp;tmp : NULL),
3922                  __ENQUEUE_WRITE_BUFFER_RECT_ERR);
3923          if (event != NULL &amp;&amp; err == CL_SUCCESS)
3924              *event = tmp;
3925          return err;
3926      }
3927      cl_int enqueueCopyBufferRect(
3928          const Buffer&amp; src,
3929          const Buffer&amp; dst,
3930          const size_t&lt;3&gt;&amp; src_origin,
3931          const size_t&lt;3&gt;&amp; dst_origin,
3932          const size_t&lt;3&gt;&amp; region,
3933          ::size_t src_row_pitch,
3934          ::size_t src_slice_pitch,
3935          ::size_t dst_row_pitch,
3936          ::size_t dst_slice_pitch,
3937          const VECTOR_CLASS&lt;Event&gt;* events = NULL,
3938          Event* event = NULL) const
3939      {
3940          cl_event tmp;
3941          cl_int err = detail::errHandler(
3942              ::clEnqueueCopyBufferRect(
3943                  object_, 
3944                  src(), 
3945                  dst(), 
3946                  (const ::size_t *)src_origin, 
3947                  (const ::size_t *)dst_origin, 
3948                  (const ::size_t *)region,
3949                  src_row_pitch,
3950                  src_slice_pitch,
3951                  dst_row_pitch,
3952                  dst_slice_pitch,
3953                  (events != NULL) ? (cl_uint) events-&gt;size() : 0,
3954                  (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
3955                  (event != NULL) ? &amp;tmp : NULL),
3956              __ENQEUE_COPY_BUFFER_RECT_ERR);
3957          if (event != NULL &amp;&amp; err == CL_SUCCESS)
3958              *event = tmp;
3959          return err;
3960      }
3961  #if defined(CL_VERSION_1_2)
3962      template&lt;typename PatternType&gt;
3963      cl_int enqueueFillBuffer(
3964          const Buffer&amp; buffer,
3965          PatternType pattern,
3966          ::size_t offset,
3967          ::size_t size,
3968          const VECTOR_CLASS&lt;Event&gt;* events = NULL,
3969          Event* event = NULL) const
3970      {
3971          cl_event tmp;
3972          cl_int err = detail::errHandler(
3973              ::clEnqueueFillBuffer(
3974                  object_, 
3975                  buffer(),
3976                  static_cast&lt;void*&gt;(&amp;pattern),
3977                  sizeof(PatternType), 
3978                  offset, 
3979                  size,
3980                  (events != NULL) ? (cl_uint) events-&gt;size() : 0,
3981                  (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
3982                  (event != NULL) ? &amp;tmp : NULL),
3983                  __ENQUEUE_FILL_BUFFER_ERR);
3984          if (event != NULL &amp;&amp; err == CL_SUCCESS)
3985              *event = tmp;
3986          return err;
3987      }
3988  #endif 
3989      cl_int enqueueReadImage(
3990          const Image&amp; image,
3991          cl_bool blocking,
3992          const size_t&lt;3&gt;&amp; origin,
3993          const size_t&lt;3&gt;&amp; region,
3994          ::size_t row_pitch,
3995          ::size_t slice_pitch,
3996          void* ptr,
3997          const VECTOR_CLASS&lt;Event&gt;* events = NULL,
3998          Event* event = NULL) const
3999      {
4000          cl_event tmp;
4001          cl_int err = detail::errHandler(
4002              ::clEnqueueReadImage(
4003                  object_, image(), blocking, (const ::size_t *) origin,
4004                  (const ::size_t *) region, row_pitch, slice_pitch, ptr,
4005                  (events != NULL) ? (cl_uint) events-&gt;size() : 0,
4006                  (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
4007                  (event != NULL) ? &amp;tmp : NULL),
4008              __ENQUEUE_READ_IMAGE_ERR);
4009          if (event != NULL &amp;&amp; err == CL_SUCCESS)
4010              *event = tmp;
4011          return err;
4012      }
4013      cl_int enqueueWriteImage(
4014          const Image&amp; image,
4015          cl_bool blocking,
4016          const size_t&lt;3&gt;&amp; origin,
4017          const size_t&lt;3&gt;&amp; region,
4018          ::size_t row_pitch,
4019          ::size_t slice_pitch,
4020          void* ptr,
4021          const VECTOR_CLASS&lt;Event&gt;* events = NULL,
4022          Event* event = NULL) const
4023      {
4024          cl_event tmp;
4025          cl_int err = detail::errHandler(
4026              ::clEnqueueWriteImage(
4027                  object_, image(), blocking, (const ::size_t *) origin,
4028                  (const ::size_t *) region, row_pitch, slice_pitch, ptr,
4029                  (events != NULL) ? (cl_uint) events-&gt;size() : 0,
4030                  (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
4031                  (event != NULL) ? &amp;tmp : NULL),
4032              __ENQUEUE_WRITE_IMAGE_ERR);
4033          if (event != NULL &amp;&amp; err == CL_SUCCESS)
4034              *event = tmp;
4035          return err;
4036      }
4037      cl_int enqueueCopyImage(
4038          const Image&amp; src,
4039          const Image&amp; dst,
4040          const size_t&lt;3&gt;&amp; src_origin,
4041          const size_t&lt;3&gt;&amp; dst_origin,
4042          const size_t&lt;3&gt;&amp; region,
4043          const VECTOR_CLASS&lt;Event&gt;* events = NULL,
4044          Event* event = NULL) const
4045      {
4046          cl_event tmp;
4047          cl_int err = detail::errHandler(
4048              ::clEnqueueCopyImage(
4049                  object_, src(), dst(), (const ::size_t *) src_origin,
4050                  (const ::size_t *)dst_origin, (const ::size_t *) region,
4051                  (events != NULL) ? (cl_uint) events-&gt;size() : 0,
4052                  (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
4053                  (event != NULL) ? &amp;tmp : NULL),
4054              __ENQUEUE_COPY_IMAGE_ERR);
4055          if (event != NULL &amp;&amp; err == CL_SUCCESS)
4056              *event = tmp;
4057          return err;
4058      }
4059  #if defined(CL_VERSION_1_2)
4060      cl_int enqueueFillImage(
4061          const Image&amp; image,
4062          cl_float4 fillColor,
4063          const size_t&lt;3&gt;&amp; origin,
4064          const size_t&lt;3&gt;&amp; region,
4065          const VECTOR_CLASS&lt;Event&gt;* events = NULL,
4066          Event* event = NULL) const
4067      {
4068          cl_event tmp;
4069          cl_int err = detail::errHandler(
4070              ::clEnqueueFillImage(
4071                  object_, 
4072                  image(),
4073                  static_cast&lt;void*&gt;(&amp;fillColor), 
4074                  (const ::size_t *) origin, 
4075                  (const ::size_t *) region,
4076                  (events != NULL) ? (cl_uint) events-&gt;size() : 0,
4077                  (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
4078                  (event != NULL) ? &amp;tmp : NULL),
4079                  __ENQUEUE_FILL_IMAGE_ERR);
4080          if (event != NULL &amp;&amp; err == CL_SUCCESS)
4081              *event = tmp;
4082          return err;
4083      }
4084      cl_int enqueueFillImage(
4085          const Image&amp; image,
4086          cl_int4 fillColor,
4087          const size_t&lt;3&gt;&amp; origin,
4088          const size_t&lt;3&gt;&amp; region,
4089          const VECTOR_CLASS&lt;Event&gt;* events = NULL,
4090          Event* event = NULL) const
4091      {
4092          cl_event tmp;
4093          cl_int err = detail::errHandler(
4094              ::clEnqueueFillImage(
4095                  object_, 
4096                  image(),
4097                  static_cast&lt;void*&gt;(&amp;fillColor), 
4098                  (const ::size_t *) origin, 
4099                  (const ::size_t *) region,
4100                  (events != NULL) ? (cl_uint) events-&gt;size() : 0,
4101                  (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
4102                  (event != NULL) ? &amp;tmp : NULL),
4103                  __ENQUEUE_FILL_IMAGE_ERR);
4104          if (event != NULL &amp;&amp; err == CL_SUCCESS)
4105              *event = tmp;
4106          return err;
4107      }
4108      cl_int enqueueFillImage(
4109          const Image&amp; image,
4110          cl_uint4 fillColor,
4111          const size_t&lt;3&gt;&amp; origin,
4112          const size_t&lt;3&gt;&amp; region,
4113          const VECTOR_CLASS&lt;Event&gt;* events = NULL,
4114          Event* event = NULL) const
4115      {
4116          cl_event tmp;
4117          cl_int err = detail::errHandler(
4118              ::clEnqueueFillImage(
4119                  object_, 
4120                  image(),
4121                  static_cast&lt;void*&gt;(&amp;fillColor), 
4122                  (const ::size_t *) origin, 
4123                  (const ::size_t *) region,
4124                  (events != NULL) ? (cl_uint) events-&gt;size() : 0,
4125                  (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
4126                  (event != NULL) ? &amp;tmp : NULL),
4127                  __ENQUEUE_FILL_IMAGE_ERR);
4128          if (event != NULL &amp;&amp; err == CL_SUCCESS)
4129              *event = tmp;
4130          return err;
4131      }
4132  #endif 
4133      cl_int enqueueCopyImageToBuffer(
4134          const Image&amp; src,
4135          const Buffer&amp; dst,
4136          const size_t&lt;3&gt;&amp; src_origin,
4137          const size_t&lt;3&gt;&amp; region,
4138          ::size_t dst_offset,
4139          const VECTOR_CLASS&lt;Event&gt;* events = NULL,
4140          Event* event = NULL) const
4141      {
4142          cl_event tmp;
4143          cl_int err = detail::errHandler(
4144              ::clEnqueueCopyImageToBuffer(
4145                  object_, src(), dst(), (const ::size_t *) src_origin,
4146                  (const ::size_t *) region, dst_offset,
4147                  (events != NULL) ? (cl_uint) events-&gt;size() : 0,
4148                  (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
4149                  (event != NULL) ? &amp;tmp : NULL),
4150              __ENQUEUE_COPY_IMAGE_TO_BUFFER_ERR);
4151          if (event != NULL &amp;&amp; err == CL_SUCCESS)
4152              *event = tmp;
4153          return err;
4154      }
4155      cl_int enqueueCopyBufferToImage(
4156          const Buffer&amp; src,
4157          const Image&amp; dst,
4158          ::size_t src_offset,
4159          const size_t&lt;3&gt;&amp; dst_origin,
4160          const size_t&lt;3&gt;&amp; region,
4161          const VECTOR_CLASS&lt;Event&gt;* events = NULL,
4162          Event* event = NULL) const
4163      {
4164          cl_event tmp;
4165          cl_int err = detail::errHandler(
4166              ::clEnqueueCopyBufferToImage(
4167                  object_, src(), dst(), src_offset,
4168                  (const ::size_t *) dst_origin, (const ::size_t *) region,
4169                  (events != NULL) ? (cl_uint) events-&gt;size() : 0,
4170                  (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
4171                  (event != NULL) ? &amp;tmp : NULL),
4172              __ENQUEUE_COPY_BUFFER_TO_IMAGE_ERR);
4173          if (event != NULL &amp;&amp; err == CL_SUCCESS)
4174              *event = tmp;
4175          return err;
4176      }
4177      void* enqueueMapBuffer(
4178          const Buffer&amp; buffer,
4179          cl_bool blocking,
4180          cl_map_flags flags,
4181          ::size_t offset,
4182          ::size_t size,
4183          const VECTOR_CLASS&lt;Event&gt;* events = NULL,
4184          Event* event = NULL,
4185          cl_int* err = NULL) const
4186      {
4187          cl_event tmp;
4188          cl_int error;
4189          void * result = ::clEnqueueMapBuffer(
4190              object_, buffer(), blocking, flags, offset, size,
4191              (events != NULL) ? (cl_uint) events-&gt;size() : 0,
4192              (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
4193              (event != NULL) ? &amp;tmp : NULL,
4194              &amp;error);
4195          detail::errHandler(error, __ENQUEUE_MAP_BUFFER_ERR);
4196          if (err != NULL) {
4197              *err = error;
4198          }
4199          if (event != NULL &amp;&amp; error == CL_SUCCESS)
4200              *event = tmp;
4201          return result;
4202      }
4203      void* enqueueMapImage(
4204          const Image&amp; buffer,
4205          cl_bool blocking,
4206          cl_map_flags flags,
4207          const size_t&lt;3&gt;&amp; origin,
4208          const size_t&lt;3&gt;&amp; region,
4209          ::size_t * row_pitch,
4210          ::size_t * slice_pitch,
4211          const VECTOR_CLASS&lt;Event&gt;* events = NULL,
4212          Event* event = NULL,
4213          cl_int* err = NULL) const
4214      {
4215          cl_event tmp;
4216          cl_int error;
4217          void * result = ::clEnqueueMapImage(
4218              object_, buffer(), blocking, flags,
4219              (const ::size_t *) origin, (const ::size_t *) region,
4220              row_pitch, slice_pitch,
4221              (events != NULL) ? (cl_uint) events-&gt;size() : 0,
4222              (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
4223              (event != NULL) ? &amp;tmp : NULL,
4224              &amp;error);
4225          detail::errHandler(error, __ENQUEUE_MAP_IMAGE_ERR);
4226          if (err != NULL) {
4227                *err = error;
4228          }
4229          if (event != NULL &amp;&amp; error == CL_SUCCESS)
4230              *event = tmp;
4231          return result;
4232      }
4233      cl_int enqueueUnmapMemObject(
4234          const Memory&amp; memory,
4235          void* mapped_ptr,
4236          const VECTOR_CLASS&lt;Event&gt;* events = NULL,
4237          Event* event = NULL) const
4238      {
4239          cl_event tmp;
4240          cl_int err = detail::errHandler(
4241              ::clEnqueueUnmapMemObject(
4242                  object_, memory(), mapped_ptr,
4243                  (events != NULL) ? (cl_uint) events-&gt;size() : 0,
4244                  (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
4245                  (event != NULL) ? &amp;tmp : NULL),
4246              __ENQUEUE_UNMAP_MEM_OBJECT_ERR);
4247          if (event != NULL &amp;&amp; err == CL_SUCCESS)
4248              *event = tmp;
4249          return err;
4250      }
4251  #if defined(CL_VERSION_1_2)
4252      cl_int enqueueMarkerWithWaitList(
4253          const VECTOR_CLASS&lt;Event&gt; *events = 0,
4254          Event *event = 0)
4255      {
4256          cl_event tmp;
4257          cl_int err = detail::errHandler(
4258              ::clEnqueueMarkerWithWaitList(
4259                  object_,
4260                  (events != NULL) ? (cl_uint) events-&gt;size() : 0,
4261                  (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
4262                  (event != NULL) ? &amp;tmp : NULL),
4263              __ENQUEUE_MARKER_WAIT_LIST_ERR);
4264          if (event != NULL &amp;&amp; err == CL_SUCCESS)
4265              *event = tmp;
4266          return err;
4267      }
4268      cl_int enqueueBarrierWithWaitList(
4269          const VECTOR_CLASS&lt;Event&gt; *events = 0,
4270          Event *event = 0)
4271      {
4272          cl_event tmp;
4273          cl_int err = detail::errHandler(
4274              ::clEnqueueBarrierWithWaitList(
4275                  object_,
4276                  (events != NULL) ? (cl_uint) events-&gt;size() : 0,
4277                  (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
4278                  (event != NULL) ? &amp;tmp : NULL),
4279              __ENQUEUE_BARRIER_WAIT_LIST_ERR);
4280          if (event != NULL &amp;&amp; err == CL_SUCCESS)
4281              *event = tmp;
4282          return err;
4283      }
4284      cl_int enqueueMigrateMemObjects(
4285          const VECTOR_CLASS&lt;Memory&gt; &amp;memObjects,
4286          cl_mem_migration_flags flags,
4287          const VECTOR_CLASS&lt;Event&gt;* events = NULL,
4288          Event* event = NULL
4289          )
4290      {
4291          cl_event tmp;
4292          cl_mem* localMemObjects = static_cast&lt;cl_mem*&gt;(alloca(memObjects.size() * sizeof(cl_mem)));
4293          for( int i = 0; i &lt; (int)memObjects.size(); ++i ) {
4294              localMemObjects[i] = memObjects[i]();
4295          }
4296          cl_int err = detail::errHandler(
4297              ::clEnqueueMigrateMemObjects(
4298                  object_, 
4299                  (cl_uint)memObjects.size(), 
4300                  static_cast&lt;const cl_mem*&gt;(localMemObjects),
4301                  flags,
4302                  (events != NULL) ? (cl_uint) events-&gt;size() : 0,
4303                  (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
4304                  (event != NULL) ? &amp;tmp : NULL),
4305              __ENQUEUE_UNMAP_MEM_OBJECT_ERR);
4306          if (event != NULL &amp;&amp; err == CL_SUCCESS)
4307              *event = tmp;
4308          return err;
4309      }
4310  #endif 
4311      cl_int enqueueNDRangeKernel(
4312          const Kernel&amp; kernel,
4313          const NDRange&amp; offset,
4314          const NDRange&amp; global,
4315          const NDRange&amp; local = NullRange,
4316          const VECTOR_CLASS&lt;Event&gt;* events = NULL,
4317          Event* event = NULL) const
4318      {
4319          cl_event tmp;
4320          cl_int err = detail::errHandler(
4321              ::clEnqueueNDRangeKernel(
4322                  object_, kernel(), (cl_uint) global.dimensions(),
4323                  offset.dimensions() != 0 ? (const ::size_t*) offset : NULL,
4324                  (const ::size_t*) global,
4325                  local.dimensions() != 0 ? (const ::size_t*) local : NULL,
4326                  (events != NULL) ? (cl_uint) events-&gt;size() : 0,
4327                  (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
4328                  (event != NULL) ? &amp;tmp : NULL),
4329              __ENQUEUE_NDRANGE_KERNEL_ERR);
4330          if (event != NULL &amp;&amp; err == CL_SUCCESS)
4331              *event = tmp;
4332          return err;
4333      }
4334      cl_int enqueueTask(
4335          const Kernel&amp; kernel,
4336          const VECTOR_CLASS&lt;Event&gt;* events = NULL,
4337          Event* event = NULL) const
4338      {
4339          cl_event tmp;
4340          cl_int err = detail::errHandler(
4341              ::clEnqueueTask(
4342                  object_, kernel(),
4343                  (events != NULL) ? (cl_uint) events-&gt;size() : 0,
4344                  (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
4345                  (event != NULL) ? &amp;tmp : NULL),
4346              __ENQUEUE_TASK_ERR);
4347          if (event != NULL &amp;&amp; err == CL_SUCCESS)
4348              *event = tmp;
4349          return err;
4350      }
4351      cl_int enqueueNativeKernel(
4352          void (CL_CALLBACK *userFptr)(void *),
4353          std::pair&lt;void*, ::size_t&gt; args,
4354          const VECTOR_CLASS&lt;Memory&gt;* mem_objects = NULL,
4355          const VECTOR_CLASS&lt;const void*&gt;* mem_locs = NULL,
4356          const VECTOR_CLASS&lt;Event&gt;* events = NULL,
4357          Event* event = NULL) const
4358      {
4359          cl_mem * mems = (mem_objects != NULL &amp;&amp; mem_objects-&gt;size() &gt; 0) 
4360              ? (cl_mem*) alloca(mem_objects-&gt;size() * sizeof(cl_mem))
4361              : NULL;
4362          if (mems != NULL) {
4363              for (unsigned int i = 0; i &lt; mem_objects-&gt;size(); i++) {
4364                  mems[i] = ((*mem_objects)[i])();
4365              }
4366          }
4367          cl_event tmp;
4368          cl_int err = detail::errHandler(
4369              ::clEnqueueNativeKernel(
4370                  object_, userFptr, args.first, args.second,
4371                  (mem_objects != NULL) ? (cl_uint) mem_objects-&gt;size() : 0,
4372                  mems,
4373                  (mem_locs != NULL &amp;&amp; mem_locs-&gt;size() &gt; 0) ? (const void **) &amp;mem_locs-&gt;front() : NULL,
4374                  (events != NULL) ? (cl_uint) events-&gt;size() : 0,
4375                  (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
4376                  (event != NULL) ? &amp;tmp : NULL),
4377              __ENQUEUE_NATIVE_KERNEL);
4378          if (event != NULL &amp;&amp; err == CL_SUCCESS)
4379              *event = tmp;
4380          return err;
4381      }
4382  #if defined(CL_USE_DEPRECATED_OPENCL_1_1_APIS) || (defined(CL_VERSION_1_1) &amp;&amp; !defined(CL_VERSION_1_2)) 
4383      CL_EXT_PREFIX__VERSION_1_1_DEPRECATED 
4384      cl_int enqueueMarker(Event* event = NULL) const CL_EXT_SUFFIX__VERSION_1_1_DEPRECATED
4385      {
4386          cl_event tmp;
4387          cl_int err = detail::errHandler(
4388              ::clEnqueueMarker(
4389                  object_, 
4390                  (event != NULL) ? &amp;tmp : NULL),
4391              __ENQUEUE_MARKER_ERR);
4392          if (event != NULL &amp;&amp; err == CL_SUCCESS)
4393              *event = tmp;
4394          return err;
4395      }
4396      CL_EXT_PREFIX__VERSION_1_1_DEPRECATED
4397      cl_int enqueueWaitForEvents(const VECTOR_CLASS&lt;Event&gt;&amp; events) const CL_EXT_SUFFIX__VERSION_1_1_DEPRECATED
4398      {
4399          return detail::errHandler(
4400              ::clEnqueueWaitForEvents(
4401                  object_,
4402                  (cl_uint) events.size(),
4403                  events.size() &gt; 0 ? (const cl_event*) &amp;events.front() : NULL),
4404              __ENQUEUE_WAIT_FOR_EVENTS_ERR);
4405      }
4406  #endif 
4407      cl_int enqueueAcquireGLObjects(
4408           const VECTOR_CLASS&lt;Memory&gt;* mem_objects = NULL,
4409           const VECTOR_CLASS&lt;Event&gt;* events = NULL,
4410           Event* event = NULL) const
4411       {
4412          cl_event tmp;
4413          cl_int err = detail::errHandler(
4414               ::clEnqueueAcquireGLObjects(
4415                   object_,
4416                   (mem_objects != NULL) ? (cl_uint) mem_objects-&gt;size() : 0,
4417                   (mem_objects != NULL &amp;&amp; mem_objects-&gt;size() &gt; 0) ? (const cl_mem *) &amp;mem_objects-&gt;front(): NULL,
4418                   (events != NULL) ? (cl_uint) events-&gt;size() : 0,
4419                   (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
4420                   (event != NULL) ? &amp;tmp : NULL),
4421               __ENQUEUE_ACQUIRE_GL_ERR);
4422          if (event != NULL &amp;&amp; err == CL_SUCCESS)
4423              *event = tmp;
4424          return err;
4425       }
4426      cl_int enqueueReleaseGLObjects(
4427           const VECTOR_CLASS&lt;Memory&gt;* mem_objects = NULL,
4428           const VECTOR_CLASS&lt;Event&gt;* events = NULL,
4429           Event* event = NULL) const
4430       {
4431          cl_event tmp;
4432          cl_int err = detail::errHandler(
4433               ::clEnqueueReleaseGLObjects(
4434                   object_,
4435                   (mem_objects != NULL) ? (cl_uint) mem_objects-&gt;size() : 0,
4436                   (mem_objects != NULL &amp;&amp; mem_objects-&gt;size() &gt; 0) ? (const cl_mem *) &amp;mem_objects-&gt;front(): NULL,
4437                   (events != NULL) ? (cl_uint) events-&gt;size() : 0,
4438                   (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
4439                   (event != NULL) ? &amp;tmp : NULL),
4440               __ENQUEUE_RELEASE_GL_ERR);
4441          if (event != NULL &amp;&amp; err == CL_SUCCESS)
4442              *event = tmp;
4443          return err;
4444       }
4445  #if defined (USE_DX_INTEROP)
4446  typedef CL_API_ENTRY cl_int (CL_API_CALL *PFN_clEnqueueAcquireD3D10ObjectsKHR)(
4447      cl_command_queue command_queue, cl_uint num_objects,
4448      const cl_mem* mem_objects, cl_uint num_events_in_wait_list,
4449      const cl_event* event_wait_list, cl_event* event);
4450  typedef CL_API_ENTRY cl_int (CL_API_CALL *PFN_clEnqueueReleaseD3D10ObjectsKHR)(
4451      cl_command_queue command_queue, cl_uint num_objects,
4452      const cl_mem* mem_objects,  cl_uint num_events_in_wait_list,
4453      const cl_event* event_wait_list, cl_event* event);
4454      cl_int enqueueAcquireD3D10Objects(
4455           const VECTOR_CLASS&lt;Memory&gt;* mem_objects = NULL,
4456           const VECTOR_CLASS&lt;Event&gt;* events = NULL,
4457           Event* event = NULL) const
4458      {
4459          static PFN_clEnqueueAcquireD3D10ObjectsKHR pfn_clEnqueueAcquireD3D10ObjectsKHR = NULL;
4460  #if defined(CL_VERSION_1_2)
4461          cl_context context = getInfo&lt;CL_QUEUE_CONTEXT&gt;();
4462          cl::Device device(getInfo&lt;CL_QUEUE_DEVICE&gt;());
4463          cl_platform_id platform = device.getInfo&lt;CL_DEVICE_PLATFORM&gt;();
4464          __INIT_CL_EXT_FCN_PTR_PLATFORM(platform, clEnqueueAcquireD3D10ObjectsKHR);
4465  #endif
4466  #if defined(CL_VERSION_1_1)
4467          __INIT_CL_EXT_FCN_PTR(clEnqueueAcquireD3D10ObjectsKHR);
4468  #endif
4469          cl_event tmp;
4470          cl_int err = detail::errHandler(
4471               pfn_clEnqueueAcquireD3D10ObjectsKHR(
4472                   object_,
4473                   (mem_objects != NULL) ? (cl_uint) mem_objects-&gt;size() : 0,
4474                   (mem_objects != NULL &amp;&amp; mem_objects-&gt;size() &gt; 0) ? (const cl_mem *) &amp;mem_objects-&gt;front(): NULL,
4475                   (events != NULL) ? (cl_uint) events-&gt;size() : 0,
4476                   (events != NULL) ? (cl_event*) &amp;events-&gt;front() : NULL,
4477                   (event != NULL) ? &amp;tmp : NULL),
4478               __ENQUEUE_ACQUIRE_GL_ERR);
4479          if (event != NULL &amp;&amp; err == CL_SUCCESS)
4480              *event = tmp;
4481          return err;
4482       }
4483      cl_int enqueueReleaseD3D10Objects(
4484           const VECTOR_CLASS&lt;Memory&gt;* mem_objects = NULL,
4485           const VECTOR_CLASS&lt;Event&gt;* events = NULL,
4486           Event* event = NULL) const
4487      {
4488          static PFN_clEnqueueReleaseD3D10ObjectsKHR pfn_clEnqueueReleaseD3D10ObjectsKHR = NULL;
4489  #if defined(CL_VERSION_1_2)
4490          cl_context context = getInfo&lt;CL_QUEUE_CONTEXT&gt;();
4491          cl::Device device(getInfo&lt;CL_QUEUE_DEVICE&gt;());
4492          cl_platform_id platform = device.getInfo&lt;CL_DEVICE_PLATFORM&gt;();
4493          __INIT_CL_EXT_FCN_PTR_PLATFORM(platform, clEnqueueReleaseD3D10ObjectsKHR);
4494  #endif 
4495  #if defined(CL_VERSION_1_1)
4496          __INIT_CL_EXT_FCN_PTR(clEnqueueReleaseD3D10ObjectsKHR);
4497  #endif 
4498          cl_event tmp;
4499          cl_int err = detail::errHandler(
4500              pfn_clEnqueueReleaseD3D10ObjectsKHR(
4501                  object_,
4502                  (mem_objects != NULL) ? (cl_uint) mem_objects-&gt;size() : 0,
4503                  (mem_objects != NULL &amp;&amp; mem_objects-&gt;size() &gt; 0) ? (const cl_mem *) &amp;mem_objects-&gt;front(): NULL,
4504                  (events != NULL) ? (cl_uint) events-&gt;size() : 0,
4505                  (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
4506                  (event != NULL) ? &amp;tmp : NULL),
4507              __ENQUEUE_RELEASE_GL_ERR);
4508          if (event != NULL &amp;&amp; err == CL_SUCCESS)
4509              *event = tmp;
4510          return err;
4511      }
4512  #endif
4513  #if defined(CL_USE_DEPRECATED_OPENCL_1_1_APIS) || (defined(CL_VERSION_1_1) &amp;&amp; !defined(CL_VERSION_1_2)) 
4514      CL_EXT_PREFIX__VERSION_1_1_DEPRECATED
4515      cl_int enqueueBarrier() const CL_EXT_SUFFIX__VERSION_1_1_DEPRECATED
4516      {
4517          return detail::errHandler(
4518              ::clEnqueueBarrier(object_),
4519              __ENQUEUE_BARRIER_ERR);
4520      }
4521  #endif 
4522      cl_int flush() const
4523      {
4524          return detail::errHandler(::clFlush(object_), __FLUSH_ERR);
4525      }
4526      cl_int finish() const
4527      {
4528          return detail::errHandler(::clFinish(object_), __FINISH_ERR);
4529      }
4530  };
4531  #ifdef _WIN32
4532  #ifdef CL_HPP_CPP11_ATOMICS_SUPPORTED
4533  __declspec(selectany) std::atomic&lt;int&gt; CommandQueue::default_initialized_;
4534  #else 
4535  __declspec(selectany) volatile int CommandQueue::default_initialized_ = __DEFAULT_NOT_INITIALIZED;
4536  #endif 
4537  __declspec(selectany) CommandQueue CommandQueue::default_;
4538  __declspec(selectany) volatile cl_int CommandQueue::default_error_ = CL_SUCCESS;
4539  #else 
4540  #ifdef CL_HPP_CPP11_ATOMICS_SUPPORTED
4541  __attribute__((weak)) std::atomic&lt;int&gt; CommandQueue::default_initialized_;
4542  #else 
4543  __attribute__((weak)) volatile int CommandQueue::default_initialized_ = __DEFAULT_NOT_INITIALIZED;
4544  #endif 
4545  __attribute__((weak)) CommandQueue CommandQueue::default_;
4546  __attribute__((weak)) volatile cl_int CommandQueue::default_error_ = CL_SUCCESS;
4547  #endif 
4548  template&lt; typename IteratorType &gt;
4549  Buffer::Buffer(
4550      const Context &amp;context,
4551      IteratorType startIterator,
4552      IteratorType endIterator,
4553      bool readOnly,
4554      bool useHostPtr,
4555      cl_int* err)
4556  {
4557      typedef typename std::iterator_traits&lt;IteratorType&gt;::value_type DataType;
4558      cl_int error;
4559      cl_mem_flags flags = 0;
4560      if( readOnly ) {
4561          flags |= CL_MEM_READ_ONLY;
4562      }
4563      else {
4564          flags |= CL_MEM_READ_WRITE;
4565      }
4566      if( useHostPtr ) {
4567          flags |= CL_MEM_USE_HOST_PTR;
4568      }
4569      ::size_t size = sizeof(DataType)*(endIterator - startIterator);
4570      if( useHostPtr ) {
4571          object_ = ::clCreateBuffer(context(), flags, size, static_cast&lt;DataType*&gt;(&amp;*startIterator), &amp;error);
4572      } else {
4573          object_ = ::clCreateBuffer(context(), flags, size, 0, &amp;error);
4574      }
4575      detail::errHandler(error, __CREATE_BUFFER_ERR);
4576      if (err != NULL) {
4577          *err = error;
4578      }
4579      if( !useHostPtr ) {
4580          CommandQueue queue(context, 0, &amp;error);
4581          detail::errHandler(error, __CREATE_BUFFER_ERR);
4582          if (err != NULL) {
4583              *err = error;
4584          }
4585          error = cl::copy(queue, startIterator, endIterator, *this);
4586          detail::errHandler(error, __CREATE_BUFFER_ERR);
4587          if (err != NULL) {
4588              *err = error;
4589          }
4590      }
4591  }
4592  template&lt; typename IteratorType &gt;
4593  Buffer::Buffer(
4594      const CommandQueue &amp;queue,
4595      IteratorType startIterator,
4596      IteratorType endIterator,
4597      bool readOnly,
4598      bool useHostPtr,
4599      cl_int* err)
4600  {
4601      typedef typename std::iterator_traits&lt;IteratorType&gt;::value_type DataType;
4602      cl_int error;
4603      cl_mem_flags flags = 0;
4604      if (readOnly) {
4605          flags |= CL_MEM_READ_ONLY;
4606      }
4607      else {
4608          flags |= CL_MEM_READ_WRITE;
4609      }
4610      if (useHostPtr) {
4611          flags |= CL_MEM_USE_HOST_PTR;
4612      }
4613      ::size_t size = sizeof(DataType)*(endIterator - startIterator);
4614      Context context = queue.getInfo&lt;CL_QUEUE_CONTEXT&gt;();
4615      if (useHostPtr) {
4616          object_ = ::clCreateBuffer(context(), flags, size, static_cast&lt;DataType*&gt;(&amp;*startIterator), &amp;error);
4617      }
4618      else {
4619          object_ = ::clCreateBuffer(context(), flags, size, 0, &amp;error);
4620      }
4621      detail::errHandler(error, __CREATE_BUFFER_ERR);
4622      if (err != NULL) {
4623          *err = error;
4624      }
4625      if (!useHostPtr) {
4626          error = cl::copy(queue, startIterator, endIterator, *this);
4627          detail::errHandler(error, __CREATE_BUFFER_ERR);
4628          if (err != NULL) {
4629              *err = error;
4630          }
4631      }
4632  }
4633  inline cl_int enqueueReadBuffer(
4634      const Buffer&amp; buffer,
4635      cl_bool blocking,
4636      ::size_t offset,
4637      ::size_t size,
4638      void* ptr,
4639      const VECTOR_CLASS&lt;Event&gt;* events = NULL,
4640      Event* event = NULL)
4641  {
4642      cl_int error;
4643      CommandQueue queue = CommandQueue::getDefault(&amp;error);
4644      if (error != CL_SUCCESS) {
4645          return error;
4646      }
4647      return queue.enqueueReadBuffer(buffer, blocking, offset, size, ptr, events, event);
4648  }
4649  inline cl_int enqueueWriteBuffer(
4650          const Buffer&amp; buffer,
4651          cl_bool blocking,
4652          ::size_t offset,
4653          ::size_t size,
4654          const void* ptr,
4655          const VECTOR_CLASS&lt;Event&gt;* events = NULL,
4656          Event* event = NULL)
4657  {
4658      cl_int error;
4659      CommandQueue queue = CommandQueue::getDefault(&amp;error);
4660      if (error != CL_SUCCESS) {
4661          return error;
4662      }
4663      return queue.enqueueWriteBuffer(buffer, blocking, offset, size, ptr, events, event);
4664  }
4665  inline void* enqueueMapBuffer(
4666          const Buffer&amp; buffer,
4667          cl_bool blocking,
4668          cl_map_flags flags,
4669          ::size_t offset,
4670          ::size_t size,
4671          const VECTOR_CLASS&lt;Event&gt;* events = NULL,
4672          Event* event = NULL,
4673          cl_int* err = NULL)
4674  {
4675      cl_int error;
4676      CommandQueue queue = CommandQueue::getDefault(&amp;error);
4677      detail::errHandler(error, __ENQUEUE_MAP_BUFFER_ERR);
4678      if (err != NULL) {
4679          *err = error;
4680      }
4681      void * result = ::clEnqueueMapBuffer(
4682              queue(), buffer(), blocking, flags, offset, size,
4683              (events != NULL) ? (cl_uint) events-&gt;size() : 0,
4684              (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
4685              (cl_event*) event,
4686              &amp;error);
4687      detail::errHandler(error, __ENQUEUE_MAP_BUFFER_ERR);
4688      if (err != NULL) {
4689          *err = error;
4690      }
4691      return result;
4692  }
4693  inline cl_int enqueueUnmapMemObject(
4694      const Memory&amp; memory,
4695      void* mapped_ptr,
4696      const VECTOR_CLASS&lt;Event&gt;* events = NULL,
4697      Event* event = NULL)
4698  {
4699      cl_int error;
4700      CommandQueue queue = CommandQueue::getDefault(&amp;error);
4701      detail::errHandler(error, __ENQUEUE_MAP_BUFFER_ERR);
4702      if (error != CL_SUCCESS) {
4703          return error;
4704      }
4705      cl_event tmp;
4706      cl_int err = detail::errHandler(
4707          ::clEnqueueUnmapMemObject(
4708              queue(), memory(), mapped_ptr,
4709              (events != NULL) ? (cl_uint) events-&gt;size() : 0,
4710              (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
4711              (event != NULL) ? &amp;tmp : NULL),
4712          __ENQUEUE_UNMAP_MEM_OBJECT_ERR);
4713      if (event != NULL &amp;&amp; err == CL_SUCCESS)
4714          *event = tmp;
4715      return err;
4716  }
4717  inline cl_int enqueueCopyBuffer(
4718          const Buffer&amp; src,
4719          const Buffer&amp; dst,
4720          ::size_t src_offset,
4721          ::size_t dst_offset,
4722          ::size_t size,
4723          const VECTOR_CLASS&lt;Event&gt;* events = NULL,
4724          Event* event = NULL)
4725  {
4726      cl_int error;
4727      CommandQueue queue = CommandQueue::getDefault(&amp;error);
4728      if (error != CL_SUCCESS) {
4729          return error;
4730      }
4731      return queue.enqueueCopyBuffer(src, dst, src_offset, dst_offset, size, events, event);
4732  }
4733  template&lt; typename IteratorType &gt;
4734  inline cl_int copy( IteratorType startIterator, IteratorType endIterator, cl::Buffer &amp;buffer )
4735  {
4736      cl_int error;
4737      CommandQueue queue = CommandQueue::getDefault(&amp;error);
4738      if (error != CL_SUCCESS)
4739          return error;
4740      return cl::copy(queue, startIterator, endIterator, buffer);
4741  }
4742  template&lt; typename IteratorType &gt;
4743  inline cl_int copy( const cl::Buffer &amp;buffer, IteratorType startIterator, IteratorType endIterator )
4744  {
4745      cl_int error;
4746      CommandQueue queue = CommandQueue::getDefault(&amp;error);
4747      if (error != CL_SUCCESS)
4748          return error;
4749      return cl::copy(queue, buffer, startIterator, endIterator);
4750  }
4751  template&lt; typename IteratorType &gt;
4752  inline cl_int copy( const CommandQueue &amp;queue, IteratorType startIterator, IteratorType endIterator, cl::Buffer &amp;buffer )
4753  {
4754      typedef typename std::iterator_traits&lt;IteratorType&gt;::value_type DataType;
4755      cl_int error;
4756      ::size_t length = endIterator-startIterator;
4757      ::size_t byteLength = length*sizeof(DataType);
4758      DataType *pointer = 
4759          static_cast&lt;DataType*&gt;(queue.enqueueMapBuffer(buffer, CL_TRUE, CL_MAP_WRITE, 0, byteLength, 0, 0, &amp;error));
4760      if( error != CL_SUCCESS ) {
4761          return error;
4762      }
4763  #if defined(_MSC_VER)
4764      std::copy(
4765          startIterator, 
4766          endIterator, 
4767          stdext::checked_array_iterator&lt;DataType*&gt;(
4768              pointer, length));
4769  #else
4770      std::copy(startIterator, endIterator, pointer);
4771  #endif
4772      Event endEvent;
4773      error = queue.enqueueUnmapMemObject(buffer, pointer, 0, &amp;endEvent);
4774      if( error != CL_SUCCESS ) { 
4775          return error;
4776      }
4777      endEvent.wait();
4778      return CL_SUCCESS;
4779  }
4780  template&lt; typename IteratorType &gt;
4781  inline cl_int copy( const CommandQueue &amp;queue, const cl::Buffer &amp;buffer, IteratorType startIterator, IteratorType endIterator )
4782  {
4783      typedef typename std::iterator_traits&lt;IteratorType&gt;::value_type DataType;
4784      cl_int error;
4785      ::size_t length = endIterator-startIterator;
4786      ::size_t byteLength = length*sizeof(DataType);
4787      DataType *pointer = 
4788          static_cast&lt;DataType*&gt;(queue.enqueueMapBuffer(buffer, CL_TRUE, CL_MAP_READ, 0, byteLength, 0, 0, &amp;error));
4789      if( error != CL_SUCCESS ) {
4790          return error;
4791      }
4792      std::copy(pointer, pointer + length, startIterator);
4793      Event endEvent;
4794      error = queue.enqueueUnmapMemObject(buffer, pointer, 0, &amp;endEvent);
4795      if( error != CL_SUCCESS ) { 
4796          return error;
4797      }
4798      endEvent.wait();
4799      return CL_SUCCESS;
4800  }
4801  #if defined(CL_VERSION_1_1)
4802  inline cl_int enqueueReadBufferRect(
4803      const Buffer&amp; buffer,
4804      cl_bool blocking,
4805      const size_t&lt;3&gt;&amp; buffer_offset,
4806      const size_t&lt;3&gt;&amp; host_offset,
4807      const size_t&lt;3&gt;&amp; region,
4808      ::size_t buffer_row_pitch,
4809      ::size_t buffer_slice_pitch,
4810      ::size_t host_row_pitch,
4811      ::size_t host_slice_pitch,
4812      void *ptr,
4813      const VECTOR_CLASS&lt;Event&gt;* events = NULL,
4814      Event* event = NULL)
4815  {
4816      cl_int error;
4817      CommandQueue queue = CommandQueue::getDefault(&amp;error);
4818      if (error != CL_SUCCESS) {
4819          return error;
4820      }
4821      return queue.enqueueReadBufferRect(
4822          buffer, 
4823          blocking, 
4824          buffer_offset, 
4825          host_offset,
4826          region,
4827          buffer_row_pitch,
4828          buffer_slice_pitch,
4829          host_row_pitch,
4830          host_slice_pitch,
4831          ptr, 
4832          events, 
4833          event);
4834  }
4835  inline cl_int enqueueWriteBufferRect(
4836      const Buffer&amp; buffer,
4837      cl_bool blocking,
4838      const size_t&lt;3&gt;&amp; buffer_offset,
4839      const size_t&lt;3&gt;&amp; host_offset,
4840      const size_t&lt;3&gt;&amp; region,
4841      ::size_t buffer_row_pitch,
4842      ::size_t buffer_slice_pitch,
4843      ::size_t host_row_pitch,
4844      ::size_t host_slice_pitch,
4845      void *ptr,
4846      const VECTOR_CLASS&lt;Event&gt;* events = NULL,
4847      Event* event = NULL)
4848  {
4849      cl_int error;
4850      CommandQueue queue = CommandQueue::getDefault(&amp;error);
4851      if (error != CL_SUCCESS) {
4852          return error;
4853      }
4854      return queue.enqueueWriteBufferRect(
4855          buffer, 
4856          blocking, 
4857          buffer_offset, 
4858          host_offset,
4859          region,
4860          buffer_row_pitch,
4861          buffer_slice_pitch,
4862          host_row_pitch,
4863          host_slice_pitch,
4864          ptr, 
4865          events, 
4866          event);
4867  }
4868  inline cl_int enqueueCopyBufferRect(
4869      const Buffer&amp; src,
4870      const Buffer&amp; dst,
4871      const size_t&lt;3&gt;&amp; src_origin,
4872      const size_t&lt;3&gt;&amp; dst_origin,
4873      const size_t&lt;3&gt;&amp; region,
4874      ::size_t src_row_pitch,
4875      ::size_t src_slice_pitch,
4876      ::size_t dst_row_pitch,
4877      ::size_t dst_slice_pitch,
4878      const VECTOR_CLASS&lt;Event&gt;* events = NULL,
4879      Event* event = NULL)
4880  {
4881      cl_int error;
4882      CommandQueue queue = CommandQueue::getDefault(&amp;error);
4883      if (error != CL_SUCCESS) {
4884          return error;
4885      }
4886      return queue.enqueueCopyBufferRect(
4887          src,
4888          dst,
4889          src_origin,
4890          dst_origin,
4891          region,
4892          src_row_pitch,
4893          src_slice_pitch,
4894          dst_row_pitch,
4895          dst_slice_pitch,
4896          events, 
4897          event);
4898  }
4899  #endif
4900  inline cl_int enqueueReadImage(
4901      const Image&amp; image,
4902      cl_bool blocking,
4903      const size_t&lt;3&gt;&amp; origin,
4904      const size_t&lt;3&gt;&amp; region,
4905      ::size_t row_pitch,
4906      ::size_t slice_pitch,
4907      void* ptr,
4908      const VECTOR_CLASS&lt;Event&gt;* events = NULL,
4909      Event* event = NULL) 
4910  {
4911      cl_int error;
4912      CommandQueue queue = CommandQueue::getDefault(&amp;error);
4913      if (error != CL_SUCCESS) {
4914          return error;
4915      }
4916      return queue.enqueueReadImage(
4917          image,
4918          blocking,
4919          origin,
4920          region,
4921          row_pitch,
4922          slice_pitch,
4923          ptr,
4924          events, 
4925          event);
4926  }
4927  inline cl_int enqueueWriteImage(
4928      const Image&amp; image,
4929      cl_bool blocking,
4930      const size_t&lt;3&gt;&amp; origin,
4931      const size_t&lt;3&gt;&amp; region,
4932      ::size_t row_pitch,
4933      ::size_t slice_pitch,
4934      void* ptr,
4935      const VECTOR_CLASS&lt;Event&gt;* events = NULL,
4936      Event* event = NULL)
4937  {
4938      cl_int error;
4939      CommandQueue queue = CommandQueue::getDefault(&amp;error);
4940      if (error != CL_SUCCESS) {
4941          return error;
4942      }
4943      return queue.enqueueWriteImage(
4944          image,
4945          blocking,
4946          origin,
4947          region,
4948          row_pitch,
4949          slice_pitch,
4950          ptr,
4951          events, 
4952          event);
4953  }
4954  inline cl_int enqueueCopyImage(
4955      const Image&amp; src,
4956      const Image&amp; dst,
4957      const size_t&lt;3&gt;&amp; src_origin,
4958      const size_t&lt;3&gt;&amp; dst_origin,
4959      const size_t&lt;3&gt;&amp; region,
4960      const VECTOR_CLASS&lt;Event&gt;* events = NULL,
4961      Event* event = NULL)
4962  {
4963      cl_int error;
4964      CommandQueue queue = CommandQueue::getDefault(&amp;error);
4965      if (error != CL_SUCCESS) {
4966          return error;
4967      }
4968      return queue.enqueueCopyImage(
4969          src,
4970          dst,
4971          src_origin,
4972          dst_origin,
4973          region,
4974          events,
4975          event);
4976  }
4977  inline cl_int enqueueCopyImageToBuffer(
4978      const Image&amp; src,
4979      const Buffer&amp; dst,
4980      const size_t&lt;3&gt;&amp; src_origin,
4981      const size_t&lt;3&gt;&amp; region,
4982      ::size_t dst_offset,
4983      const VECTOR_CLASS&lt;Event&gt;* events = NULL,
4984      Event* event = NULL)
4985  {
4986      cl_int error;
4987      CommandQueue queue = CommandQueue::getDefault(&amp;error);
4988      if (error != CL_SUCCESS) {
4989          return error;
4990      }
4991      return queue.enqueueCopyImageToBuffer(
4992          src,
4993          dst,
4994          src_origin,
4995          region,
4996          dst_offset,
4997          events,
4998          event);
4999  }
5000  inline cl_int enqueueCopyBufferToImage(
5001      const Buffer&amp; src,
5002      const Image&amp; dst,
5003      ::size_t src_offset,
5004      const size_t&lt;3&gt;&amp; dst_origin,
5005      const size_t&lt;3&gt;&amp; region,
5006      const VECTOR_CLASS&lt;Event&gt;* events = NULL,
5007      Event* event = NULL)
5008  {
5009      cl_int error;
5010      CommandQueue queue = CommandQueue::getDefault(&amp;error);
5011      if (error != CL_SUCCESS) {
5012          return error;
5013      }
5014      return queue.enqueueCopyBufferToImage(
5015          src,
5016          dst,
5017          src_offset,
5018          dst_origin,
5019          region,
5020          events,
5021          event);
5022  }
5023  inline cl_int flush(void)
5024  {
5025      cl_int error;
5026      CommandQueue queue = CommandQueue::getDefault(&amp;error);
5027      if (error != CL_SUCCESS) {
5028          return error;
5029      }
5030      return queue.flush();
5031  }
5032  inline cl_int finish(void)
5033  {
5034      cl_int error;
5035      CommandQueue queue = CommandQueue::getDefault(&amp;error);
5036      if (error != CL_SUCCESS) {
5037          return error;
5038      } 
5039      return queue.finish();
5040  }
5041  struct EnqueueArgs
5042  {
5043      CommandQueue queue_;
5044      const NDRange offset_;
5045      const NDRange global_;
5046      const NDRange local_;
5047      VECTOR_CLASS&lt;Event&gt; events_;
5048      EnqueueArgs(NDRange global) : 
5049        queue_(CommandQueue::getDefault()),
5050        offset_(NullRange), 
5051        global_(global),
5052        local_(NullRange)
5053      {
5054      }
5055      EnqueueArgs(NDRange global, NDRange local) : 
5056        queue_(CommandQueue::getDefault()),
5057        offset_(NullRange), 
5058        global_(global),
5059        local_(local)
5060      {
5061      }
5062      EnqueueArgs(NDRange offset, NDRange global, NDRange local) : 
5063        queue_(CommandQueue::getDefault()),
5064        offset_(offset), 
5065        global_(global),
5066        local_(local)
5067      {
5068      }
5069      EnqueueArgs(Event e, NDRange global) : 
5070        queue_(CommandQueue::getDefault()),
5071        offset_(NullRange), 
5072        global_(global),
5073        local_(NullRange)
5074      {
5075          events_.push_back(e);
5076      }
5077      EnqueueArgs(Event e, NDRange global, NDRange local) : 
5078        queue_(CommandQueue::getDefault()),
5079        offset_(NullRange), 
5080        global_(global),
5081        local_(local)
5082      {
5083          events_.push_back(e);
5084      }
5085      EnqueueArgs(Event e, NDRange offset, NDRange global, NDRange local) : 
5086        queue_(CommandQueue::getDefault()),
5087        offset_(offset), 
5088        global_(global),
5089        local_(local)
5090      {
5091          events_.push_back(e);
5092      }
5093      EnqueueArgs(const VECTOR_CLASS&lt;Event&gt; &amp;events, NDRange global) : 
5094        queue_(CommandQueue::getDefault()),
5095        offset_(NullRange), 
5096        global_(global),
5097        local_(NullRange),
5098        events_(events)
5099      {
5100      }
5101      EnqueueArgs(const VECTOR_CLASS&lt;Event&gt; &amp;events, NDRange global, NDRange local) : 
5102        queue_(CommandQueue::getDefault()),
5103        offset_(NullRange), 
5104        global_(global),
5105        local_(local),
5106        events_(events)
5107      {
5108      }
5109      EnqueueArgs(const VECTOR_CLASS&lt;Event&gt; &amp;events, NDRange offset, NDRange global, NDRange local) : 
5110        queue_(CommandQueue::getDefault()),
5111        offset_(offset), 
5112        global_(global),
5113        local_(local),
5114        events_(events)
5115      {
5116      }
5117      EnqueueArgs(CommandQueue &amp;queue, NDRange global) : 
5118        queue_(queue),
5119        offset_(NullRange), 
5120        global_(global),
5121        local_(NullRange)
5122      {
5123      }
5124      EnqueueArgs(CommandQueue &amp;queue, NDRange global, NDRange local) : 
5125        queue_(queue),
5126        offset_(NullRange), 
5127        global_(global),
5128        local_(local)
5129      {
5130      }
5131      EnqueueArgs(CommandQueue &amp;queue, NDRange offset, NDRange global, NDRange local) : 
5132        queue_(queue),
5133        offset_(offset), 
5134        global_(global),
5135        local_(local)
5136      {
5137      }
5138      EnqueueArgs(CommandQueue &amp;queue, Event e, NDRange global) : 
5139        queue_(queue),
5140        offset_(NullRange), 
5141        global_(global),
5142        local_(NullRange)
5143      {
5144          events_.push_back(e);
5145      }
5146      EnqueueArgs(CommandQueue &amp;queue, Event e, NDRange global, NDRange local) : 
5147        queue_(queue),
5148        offset_(NullRange), 
5149        global_(global),
5150        local_(local)
5151      {
5152          events_.push_back(e);
5153      }
5154      EnqueueArgs(CommandQueue &amp;queue, Event e, NDRange offset, NDRange global, NDRange local) : 
5155        queue_(queue),
5156        offset_(offset), 
5157        global_(global),
5158        local_(local)
5159      {
5160          events_.push_back(e);
5161      }
5162      EnqueueArgs(CommandQueue &amp;queue, const VECTOR_CLASS&lt;Event&gt; &amp;events, NDRange global) : 
5163        queue_(queue),
5164        offset_(NullRange), 
5165        global_(global),
5166        local_(NullRange),
5167        events_(events)
5168      {
5169      }
5170      EnqueueArgs(CommandQueue &amp;queue, const VECTOR_CLASS&lt;Event&gt; &amp;events, NDRange global, NDRange local) : 
5171        queue_(queue),
5172        offset_(NullRange), 
5173        global_(global),
5174        local_(local),
5175        events_(events)
5176      {
5177      }
5178      EnqueueArgs(CommandQueue &amp;queue, const VECTOR_CLASS&lt;Event&gt; &amp;events, NDRange offset, NDRange global, NDRange local) : 
5179        queue_(queue),
5180        offset_(offset), 
5181        global_(global),
5182        local_(local),
5183        events_(events)
5184      {
5185      }
5186  };
5187  namespace detail {
5188  class NullType {};
5189  template&lt;int index, typename T0&gt;
5190  struct SetArg
5191  {
5192      static void set (Kernel kernel, T0 arg)
5193      {
5194          kernel.setArg(index, arg);
5195      }
5196  };  
5197  template&lt;int index&gt;
5198  struct SetArg&lt;index, NullType&gt;
5199  {
5200      static void set (Kernel, NullType)
5201      { 
5202      }
5203  };
5204  template &lt;
5205     typename T0,   typename T1,   typename T2,   typename T3,
5206     typename T4,   typename T5,   typename T6,   typename T7,
5207     typename T8,   typename T9,   typename T10,   typename T11,
5208     typename T12,   typename T13,   typename T14,   typename T15,
5209     typename T16,   typename T17,   typename T18,   typename T19,
5210     typename T20,   typename T21,   typename T22,   typename T23,
5211     typename T24,   typename T25,   typename T26,   typename T27,
5212     typename T28,   typename T29,   typename T30,   typename T31
5213  &gt;
5214  class KernelFunctorGlobal
5215  {
5216  private:
5217      Kernel kernel_;
5218  public:
5219     KernelFunctorGlobal(
5220          Kernel kernel) :
5221              kernel_(kernel)
5222      {}
5223     KernelFunctorGlobal(
5224          const Program&amp; program,
5225          const STRING_CLASS name,
5226          cl_int * err = NULL) :
5227              kernel_(program, name.c_str(), err)
5228      {}
5229      Event operator() (
5230          const EnqueueArgs&amp; args,
5231          T0 t0,
5232          T1 t1 = NullType(),
5233          T2 t2 = NullType(),
5234          T3 t3 = NullType(),
5235          T4 t4 = NullType(),
5236          T5 t5 = NullType(),
5237          T6 t6 = NullType(),
5238          T7 t7 = NullType(),
5239          T8 t8 = NullType(),
5240          T9 t9 = NullType(),
5241          T10 t10 = NullType(),
5242          T11 t11 = NullType(),
5243          T12 t12 = NullType(),
5244          T13 t13 = NullType(),
5245          T14 t14 = NullType(),
5246          T15 t15 = NullType(),
5247          T16 t16 = NullType(),
5248          T17 t17 = NullType(),
5249          T18 t18 = NullType(),
5250          T19 t19 = NullType(),
5251          T20 t20 = NullType(),
5252          T21 t21 = NullType(),
5253          T22 t22 = NullType(),
5254          T23 t23 = NullType(),
5255          T24 t24 = NullType(),
5256          T25 t25 = NullType(),
5257          T26 t26 = NullType(),
5258          T27 t27 = NullType(),
5259          T28 t28 = NullType(),
5260          T29 t29 = NullType(),
5261          T30 t30 = NullType(),
5262          T31 t31 = NullType()
5263          )
5264      {
5265          Event event;
5266          SetArg&lt;0, T0&gt;::set(kernel_, t0);
5267          SetArg&lt;1, T1&gt;::set(kernel_, t1);
5268          SetArg&lt;2, T2&gt;::set(kernel_, t2);
5269          SetArg&lt;3, T3&gt;::set(kernel_, t3);
5270          SetArg&lt;4, T4&gt;::set(kernel_, t4);
5271          SetArg&lt;5, T5&gt;::set(kernel_, t5);
5272          SetArg&lt;6, T6&gt;::set(kernel_, t6);
5273          SetArg&lt;7, T7&gt;::set(kernel_, t7);
5274          SetArg&lt;8, T8&gt;::set(kernel_, t8);
5275          SetArg&lt;9, T9&gt;::set(kernel_, t9);
5276          SetArg&lt;10, T10&gt;::set(kernel_, t10);
5277          SetArg&lt;11, T11&gt;::set(kernel_, t11);
5278          SetArg&lt;12, T12&gt;::set(kernel_, t12);
5279          SetArg&lt;13, T13&gt;::set(kernel_, t13);
5280          SetArg&lt;14, T14&gt;::set(kernel_, t14);
5281          SetArg&lt;15, T15&gt;::set(kernel_, t15);
5282          SetArg&lt;16, T16&gt;::set(kernel_, t16);
5283          SetArg&lt;17, T17&gt;::set(kernel_, t17);
5284          SetArg&lt;18, T18&gt;::set(kernel_, t18);
5285          SetArg&lt;19, T19&gt;::set(kernel_, t19);
5286          SetArg&lt;20, T20&gt;::set(kernel_, t20);
5287          SetArg&lt;21, T21&gt;::set(kernel_, t21);
5288          SetArg&lt;22, T22&gt;::set(kernel_, t22);
5289          SetArg&lt;23, T23&gt;::set(kernel_, t23);
5290          SetArg&lt;24, T24&gt;::set(kernel_, t24);
5291          SetArg&lt;25, T25&gt;::set(kernel_, t25);
5292          SetArg&lt;26, T26&gt;::set(kernel_, t26);
5293          SetArg&lt;27, T27&gt;::set(kernel_, t27);
5294          SetArg&lt;28, T28&gt;::set(kernel_, t28);
5295          SetArg&lt;29, T29&gt;::set(kernel_, t29);
5296          SetArg&lt;30, T30&gt;::set(kernel_, t30);
5297          SetArg&lt;31, T31&gt;::set(kernel_, t31);
5298          args.queue_.enqueueNDRangeKernel(
5299              kernel_,
5300              args.offset_,
5301              args.global_,
5302              args.local_,
5303              &amp;args.events_,
5304              &amp;event);
5305          return event;
5306      }
5307  };
5308  template&lt;
5309  	typename T0,
5310  	typename T1,
5311  	typename T2,
5312  	typename T3,
5313  	typename T4,
5314  	typename T5,
5315  	typename T6,
5316  	typename T7,
5317  	typename T8,
5318  	typename T9,
5319  	typename T10,
5320  	typename T11,
5321  	typename T12,
5322  	typename T13,
5323  	typename T14,
5324  	typename T15,
5325  	typename T16,
5326  	typename T17,
5327  	typename T18,
5328  	typename T19,
5329  	typename T20,
5330  	typename T21,
5331  	typename T22,
5332  	typename T23,
5333  	typename T24,
5334  	typename T25,
5335  	typename T26,
5336  	typename T27,
5337  	typename T28,
5338  	typename T29,
5339  	typename T30,
5340  	typename T31&gt;
5341  struct functionImplementation_
5342  {
5343  	typedef detail::KernelFunctorGlobal&lt;
5344  		T0,
5345  		T1,
5346  		T2,
5347  		T3,
5348  		T4,
5349  		T5,
5350  		T6,
5351  		T7,
5352  		T8,
5353  		T9,
5354  		T10,
5355  		T11,
5356  		T12,
5357  		T13,
5358  		T14,
5359  		T15,
5360  		T16,
5361  		T17,
5362  		T18,
5363  		T19,
5364  		T20,
5365  		T21,
5366  		T22,
5367  		T23,
5368  		T24,
5369  		T25,
5370  		T26,
5371  		T27,
5372  		T28,
5373  		T29,
5374  		T30,
5375  		T31&gt; FunctorType;
5376      FunctorType functor_;
5377      functionImplementation_(const FunctorType &amp;functor) :
5378          functor_(functor)
5379      {
5380          #if (defined(_WIN32) &amp;&amp; defined(_VARIADIC_MAX) &amp;&amp; (_VARIADIC_MAX &lt; 32))
5381          static_assert(0, &quot;Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.&quot;);
5382          #endif
5383      }
5384  	typedef Event result_type;
5385  	typedef Event type_(
5386  		const EnqueueArgs&amp;,
5387  		T0,
5388  		T1,
5389  		T2,
5390  		T3,
5391  		T4,
5392  		T5,
5393  		T6,
5394  		T7,
5395  		T8,
5396  		T9,
5397  		T10,
5398  		T11,
5399  		T12,
5400  		T13,
5401  		T14,
5402  		T15,
5403  		T16,
5404  		T17,
5405  		T18,
5406  		T19,
5407  		T20,
5408  		T21,
5409  		T22,
5410  		T23,
5411  		T24,
5412  		T25,
5413  		T26,
5414  		T27,
5415  		T28,
5416  		T29,
5417  		T30,
5418  		T31);
5419  	Event operator()(
5420  		const EnqueueArgs&amp; enqueueArgs,
5421  		T0 arg0,
5422  		T1 arg1,
5423  		T2 arg2,
5424  		T3 arg3,
5425  		T4 arg4,
5426  		T5 arg5,
5427  		T6 arg6,
5428  		T7 arg7,
5429  		T8 arg8,
5430  		T9 arg9,
5431  		T10 arg10,
5432  		T11 arg11,
5433  		T12 arg12,
5434  		T13 arg13,
5435  		T14 arg14,
5436  		T15 arg15,
5437  		T16 arg16,
5438  		T17 arg17,
5439  		T18 arg18,
5440  		T19 arg19,
5441  		T20 arg20,
5442  		T21 arg21,
5443  		T22 arg22,
5444  		T23 arg23,
5445  		T24 arg24,
5446  		T25 arg25,
5447  		T26 arg26,
5448  		T27 arg27,
5449  		T28 arg28,
5450  		T29 arg29,
5451  		T30 arg30,
5452  		T31 arg31)
5453  	{
5454  		return functor_(
5455  			enqueueArgs,
5456  			arg0,
5457  			arg1,
5458  			arg2,
5459  			arg3,
5460  			arg4,
5461  			arg5,
5462  			arg6,
5463  			arg7,
5464  			arg8,
5465  			arg9,
5466  			arg10,
5467  			arg11,
5468  			arg12,
5469  			arg13,
5470  			arg14,
5471  			arg15,
5472  			arg16,
5473  			arg17,
5474  			arg18,
5475  			arg19,
5476  			arg20,
5477  			arg21,
5478  			arg22,
5479  			arg23,
5480  			arg24,
5481  			arg25,
5482  			arg26,
5483  			arg27,
5484  			arg28,
5485  			arg29,
5486  			arg30,
5487  			arg31);
5488  	}
5489  };
5490  template&lt;
5491  	typename T0,
5492  	typename T1,
5493  	typename T2,
5494  	typename T3,
5495  	typename T4,
5496  	typename T5,
5497  	typename T6,
5498  	typename T7,
5499  	typename T8,
5500  	typename T9,
5501  	typename T10,
5502  	typename T11,
5503  	typename T12,
5504  	typename T13,
5505  	typename T14,
5506  	typename T15,
5507  	typename T16,
5508  	typename T17,
5509  	typename T18,
5510  	typename T19,
5511  	typename T20,
5512  	typename T21,
5513  	typename T22,
5514  	typename T23,
5515  	typename T24,
5516  	typename T25,
5517  	typename T26,
5518  	typename T27,
5519  	typename T28,
5520  	typename T29,
5521  	typename T30&gt;
5522  struct functionImplementation_
5523  &lt;	T0,
5524  	T1,
5525  	T2,
5526  	T3,
5527  	T4,
5528  	T5,
5529  	T6,
5530  	T7,
5531  	T8,
5532  	T9,
5533  	T10,
5534  	T11,
5535  	T12,
5536  	T13,
5537  	T14,
5538  	T15,
5539  	T16,
5540  	T17,
5541  	T18,
5542  	T19,
5543  	T20,
5544  	T21,
5545  	T22,
5546  	T23,
5547  	T24,
5548  	T25,
5549  	T26,
5550  	T27,
5551  	T28,
5552  	T29,
5553  	T30,
5554  	NullType&gt;
5555  {
5556  	typedef detail::KernelFunctorGlobal&lt;
5557  		T0,
5558  		T1,
5559  		T2,
5560  		T3,
5561  		T4,
5562  		T5,
5563  		T6,
5564  		T7,
5565  		T8,
5566  		T9,
5567  		T10,
5568  		T11,
5569  		T12,
5570  		T13,
5571  		T14,
5572  		T15,
5573  		T16,
5574  		T17,
5575  		T18,
5576  		T19,
5577  		T20,
5578  		T21,
5579  		T22,
5580  		T23,
5581  		T24,
5582  		T25,
5583  		T26,
5584  		T27,
5585  		T28,
5586  		T29,
5587  		T30,
5588  		NullType&gt; FunctorType;
5589      FunctorType functor_;
5590      functionImplementation_(const FunctorType &amp;functor) :
5591          functor_(functor)
5592      {
5593          #if (defined(_WIN32) &amp;&amp; defined(_VARIADIC_MAX) &amp;&amp; (_VARIADIC_MAX &lt; 31))
5594          static_assert(0, &quot;Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.&quot;);
5595          #endif
5596      }
5597  	typedef Event result_type;
5598  	typedef Event type_(
5599  		const EnqueueArgs&amp;,
5600  		T0,
5601  		T1,
5602  		T2,
5603  		T3,
5604  		T4,
5605  		T5,
5606  		T6,
5607  		T7,
5608  		T8,
5609  		T9,
5610  		T10,
5611  		T11,
5612  		T12,
5613  		T13,
5614  		T14,
5615  		T15,
5616  		T16,
5617  		T17,
5618  		T18,
5619  		T19,
5620  		T20,
5621  		T21,
5622  		T22,
5623  		T23,
5624  		T24,
5625  		T25,
5626  		T26,
5627  		T27,
5628  		T28,
5629  		T29,
5630  		T30);
5631  	Event operator()(
5632  		const EnqueueArgs&amp; enqueueArgs,
5633  		T0 arg0,
5634  		T1 arg1,
5635  		T2 arg2,
5636  		T3 arg3,
5637  		T4 arg4,
5638  		T5 arg5,
5639  		T6 arg6,
5640  		T7 arg7,
5641  		T8 arg8,
5642  		T9 arg9,
5643  		T10 arg10,
5644  		T11 arg11,
5645  		T12 arg12,
5646  		T13 arg13,
5647  		T14 arg14,
5648  		T15 arg15,
5649  		T16 arg16,
5650  		T17 arg17,
5651  		T18 arg18,
5652  		T19 arg19,
5653  		T20 arg20,
5654  		T21 arg21,
5655  		T22 arg22,
5656  		T23 arg23,
5657  		T24 arg24,
5658  		T25 arg25,
5659  		T26 arg26,
5660  		T27 arg27,
5661  		T28 arg28,
5662  		T29 arg29,
5663  		T30 arg30)
5664  	{
5665  		return functor_(
5666  			enqueueArgs,
5667  			arg0,
5668  			arg1,
5669  			arg2,
5670  			arg3,
5671  			arg4,
5672  			arg5,
5673  			arg6,
5674  			arg7,
5675  			arg8,
5676  			arg9,
5677  			arg10,
5678  			arg11,
5679  			arg12,
5680  			arg13,
5681  			arg14,
5682  			arg15,
5683  			arg16,
5684  			arg17,
5685  			arg18,
5686  			arg19,
5687  			arg20,
5688  			arg21,
5689  			arg22,
5690  			arg23,
5691  			arg24,
5692  			arg25,
5693  			arg26,
5694  			arg27,
5695  			arg28,
5696  			arg29,
5697  			arg30);
5698  	}
5699  };
5700  template&lt;
5701  	typename T0,
5702  	typename T1,
5703  	typename T2,
5704  	typename T3,
5705  	typename T4,
5706  	typename T5,
5707  	typename T6,
5708  	typename T7,
5709  	typename T8,
5710  	typename T9,
5711  	typename T10,
5712  	typename T11,
5713  	typename T12,
5714  	typename T13,
5715  	typename T14,
5716  	typename T15,
5717  	typename T16,
5718  	typename T17,
5719  	typename T18,
5720  	typename T19,
5721  	typename T20,
5722  	typename T21,
5723  	typename T22,
5724  	typename T23,
5725  	typename T24,
5726  	typename T25,
5727  	typename T26,
5728  	typename T27,
5729  	typename T28,
5730  	typename T29&gt;
5731  struct functionImplementation_
5732  &lt;	T0,
5733  	T1,
5734  	T2,
5735  	T3,
5736  	T4,
5737  	T5,
5738  	T6,
5739  	T7,
5740  	T8,
5741  	T9,
5742  	T10,
5743  	T11,
5744  	T12,
5745  	T13,
5746  	T14,
5747  	T15,
5748  	T16,
5749  	T17,
5750  	T18,
5751  	T19,
5752  	T20,
5753  	T21,
5754  	T22,
5755  	T23,
5756  	T24,
5757  	T25,
5758  	T26,
5759  	T27,
5760  	T28,
5761  	T29,
5762  	NullType,
5763  	NullType&gt;
5764  {
5765  	typedef detail::KernelFunctorGlobal&lt;
5766  		T0,
5767  		T1,
5768  		T2,
5769  		T3,
5770  		T4,
5771  		T5,
5772  		T6,
5773  		T7,
5774  		T8,
5775  		T9,
5776  		T10,
5777  		T11,
5778  		T12,
5779  		T13,
5780  		T14,
5781  		T15,
5782  		T16,
5783  		T17,
5784  		T18,
5785  		T19,
5786  		T20,
5787  		T21,
5788  		T22,
5789  		T23,
5790  		T24,
5791  		T25,
5792  		T26,
5793  		T27,
5794  		T28,
5795  		T29,
5796  		NullType,
5797  		NullType&gt; FunctorType;
5798      FunctorType functor_;
5799      functionImplementation_(const FunctorType &amp;functor) :
5800          functor_(functor)
5801      {
5802          #if (defined(_WIN32) &amp;&amp; defined(_VARIADIC_MAX) &amp;&amp; (_VARIADIC_MAX &lt; 30))
5803          static_assert(0, &quot;Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.&quot;);
5804          #endif
5805      }
5806  	typedef Event result_type;
5807  	typedef Event type_(
5808  		const EnqueueArgs&amp;,
5809  		T0,
5810  		T1,
5811  		T2,
5812  		T3,
5813  		T4,
5814  		T5,
5815  		T6,
5816  		T7,
5817  		T8,
5818  		T9,
5819  		T10,
5820  		T11,
5821  		T12,
5822  		T13,
5823  		T14,
5824  		T15,
5825  		T16,
5826  		T17,
5827  		T18,
5828  		T19,
5829  		T20,
5830  		T21,
5831  		T22,
5832  		T23,
5833  		T24,
5834  		T25,
5835  		T26,
5836  		T27,
5837  		T28,
5838  		T29);
5839  	Event operator()(
5840  		const EnqueueArgs&amp; enqueueArgs,
5841  		T0 arg0,
5842  		T1 arg1,
5843  		T2 arg2,
5844  		T3 arg3,
5845  		T4 arg4,
5846  		T5 arg5,
5847  		T6 arg6,
5848  		T7 arg7,
5849  		T8 arg8,
5850  		T9 arg9,
5851  		T10 arg10,
5852  		T11 arg11,
5853  		T12 arg12,
5854  		T13 arg13,
5855  		T14 arg14,
5856  		T15 arg15,
5857  		T16 arg16,
5858  		T17 arg17,
5859  		T18 arg18,
5860  		T19 arg19,
5861  		T20 arg20,
5862  		T21 arg21,
5863  		T22 arg22,
5864  		T23 arg23,
5865  		T24 arg24,
5866  		T25 arg25,
5867  		T26 arg26,
5868  		T27 arg27,
5869  		T28 arg28,
5870  		T29 arg29)
5871  	{
5872  		return functor_(
5873  			enqueueArgs,
5874  			arg0,
5875  			arg1,
5876  			arg2,
5877  			arg3,
5878  			arg4,
5879  			arg5,
5880  			arg6,
5881  			arg7,
5882  			arg8,
5883  			arg9,
5884  			arg10,
5885  			arg11,
5886  			arg12,
5887  			arg13,
5888  			arg14,
5889  			arg15,
5890  			arg16,
5891  			arg17,
5892  			arg18,
5893  			arg19,
5894  			arg20,
5895  			arg21,
5896  			arg22,
5897  			arg23,
5898  			arg24,
5899  			arg25,
5900  			arg26,
5901  			arg27,
5902  			arg28,
5903  			arg29);
5904  	}
5905  };
5906  template&lt;
5907  	typename T0,
5908  	typename T1,
5909  	typename T2,
5910  	typename T3,
5911  	typename T4,
5912  	typename T5,
5913  	typename T6,
5914  	typename T7,
5915  	typename T8,
5916  	typename T9,
5917  	typename T10,
5918  	typename T11,
5919  	typename T12,
5920  	typename T13,
5921  	typename T14,
5922  	typename T15,
5923  	typename T16,
5924  	typename T17,
5925  	typename T18,
5926  	typename T19,
5927  	typename T20,
5928  	typename T21,
5929  	typename T22,
5930  	typename T23,
5931  	typename T24,
5932  	typename T25,
5933  	typename T26,
5934  	typename T27,
5935  	typename T28&gt;
5936  struct functionImplementation_
5937  &lt;	T0,
5938  	T1,
5939  	T2,
5940  	T3,
5941  	T4,
5942  	T5,
5943  	T6,
5944  	T7,
5945  	T8,
5946  	T9,
5947  	T10,
5948  	T11,
5949  	T12,
5950  	T13,
5951  	T14,
5952  	T15,
5953  	T16,
5954  	T17,
5955  	T18,
5956  	T19,
5957  	T20,
5958  	T21,
5959  	T22,
5960  	T23,
5961  	T24,
5962  	T25,
5963  	T26,
5964  	T27,
5965  	T28,
5966  	NullType,
5967  	NullType,
5968  	NullType&gt;
5969  {
5970  	typedef detail::KernelFunctorGlobal&lt;
5971  		T0,
5972  		T1,
5973  		T2,
5974  		T3,
5975  		T4,
5976  		T5,
5977  		T6,
5978  		T7,
5979  		T8,
5980  		T9,
5981  		T10,
5982  		T11,
5983  		T12,
5984  		T13,
5985  		T14,
5986  		T15,
5987  		T16,
5988  		T17,
5989  		T18,
5990  		T19,
5991  		T20,
5992  		T21,
5993  		T22,
5994  		T23,
5995  		T24,
5996  		T25,
5997  		T26,
5998  		T27,
5999  		T28,
6000  		NullType,
6001  		NullType,
6002  		NullType&gt; FunctorType;
6003      FunctorType functor_;
6004      functionImplementation_(const FunctorType &amp;functor) :
6005          functor_(functor)
6006      {
6007          #if (defined(_WIN32) &amp;&amp; defined(_VARIADIC_MAX) &amp;&amp; (_VARIADIC_MAX &lt; 29))
6008          static_assert(0, &quot;Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.&quot;);
6009          #endif
6010      }
6011  	typedef Event result_type;
6012  	typedef Event type_(
6013  		const EnqueueArgs&amp;,
6014  		T0,
6015  		T1,
6016  		T2,
6017  		T3,
6018  		T4,
6019  		T5,
6020  		T6,
6021  		T7,
6022  		T8,
6023  		T9,
6024  		T10,
6025  		T11,
6026  		T12,
6027  		T13,
6028  		T14,
6029  		T15,
6030  		T16,
6031  		T17,
6032  		T18,
6033  		T19,
6034  		T20,
6035  		T21,
6036  		T22,
6037  		T23,
6038  		T24,
6039  		T25,
6040  		T26,
6041  		T27,
6042  		T28);
6043  	Event operator()(
6044  		const EnqueueArgs&amp; enqueueArgs,
6045  		T0 arg0,
6046  		T1 arg1,
6047  		T2 arg2,
6048  		T3 arg3,
6049  		T4 arg4,
6050  		T5 arg5,
6051  		T6 arg6,
6052  		T7 arg7,
6053  		T8 arg8,
6054  		T9 arg9,
6055  		T10 arg10,
6056  		T11 arg11,
6057  		T12 arg12,
6058  		T13 arg13,
6059  		T14 arg14,
6060  		T15 arg15,
6061  		T16 arg16,
6062  		T17 arg17,
6063  		T18 arg18,
6064  		T19 arg19,
6065  		T20 arg20,
6066  		T21 arg21,
6067  		T22 arg22,
6068  		T23 arg23,
6069  		T24 arg24,
6070  		T25 arg25,
6071  		T26 arg26,
6072  		T27 arg27,
6073  		T28 arg28)
6074  	{
6075  		return functor_(
6076  			enqueueArgs,
6077  			arg0,
6078  			arg1,
6079  			arg2,
6080  			arg3,
6081  			arg4,
6082  			arg5,
6083  			arg6,
6084  			arg7,
6085  			arg8,
6086  			arg9,
6087  			arg10,
6088  			arg11,
6089  			arg12,
6090  			arg13,
6091  			arg14,
6092  			arg15,
6093  			arg16,
6094  			arg17,
6095  			arg18,
6096  			arg19,
6097  			arg20,
6098  			arg21,
6099  			arg22,
6100  			arg23,
6101  			arg24,
6102  			arg25,
6103  			arg26,
6104  			arg27,
6105  			arg28);
6106  	}
6107  };
6108  template&lt;
6109  	typename T0,
6110  	typename T1,
6111  	typename T2,
6112  	typename T3,
6113  	typename T4,
6114  	typename T5,
6115  	typename T6,
6116  	typename T7,
6117  	typename T8,
6118  	typename T9,
6119  	typename T10,
6120  	typename T11,
6121  	typename T12,
6122  	typename T13,
6123  	typename T14,
6124  	typename T15,
6125  	typename T16,
6126  	typename T17,
6127  	typename T18,
6128  	typename T19,
6129  	typename T20,
6130  	typename T21,
6131  	typename T22,
6132  	typename T23,
6133  	typename T24,
6134  	typename T25,
6135  	typename T26,
6136  	typename T27&gt;
6137  struct functionImplementation_
6138  &lt;	T0,
6139  	T1,
6140  	T2,
6141  	T3,
6142  	T4,
6143  	T5,
6144  	T6,
6145  	T7,
6146  	T8,
6147  	T9,
6148  	T10,
6149  	T11,
6150  	T12,
6151  	T13,
6152  	T14,
6153  	T15,
6154  	T16,
6155  	T17,
6156  	T18,
6157  	T19,
6158  	T20,
6159  	T21,
6160  	T22,
6161  	T23,
6162  	T24,
6163  	T25,
6164  	T26,
6165  	T27,
6166  	NullType,
6167  	NullType,
6168  	NullType,
6169  	NullType&gt;
6170  {
6171  	typedef detail::KernelFunctorGlobal&lt;
6172  		T0,
6173  		T1,
6174  		T2,
6175  		T3,
6176  		T4,
6177  		T5,
6178  		T6,
6179  		T7,
6180  		T8,
6181  		T9,
6182  		T10,
6183  		T11,
6184  		T12,
6185  		T13,
6186  		T14,
6187  		T15,
6188  		T16,
6189  		T17,
6190  		T18,
6191  		T19,
6192  		T20,
6193  		T21,
6194  		T22,
6195  		T23,
6196  		T24,
6197  		T25,
6198  		T26,
6199  		T27,
6200  		NullType,
6201  		NullType,
6202  		NullType,
6203  		NullType&gt; FunctorType;
6204      FunctorType functor_;
6205      functionImplementation_(const FunctorType &amp;functor) :
6206          functor_(functor)
6207      {
6208          #if (defined(_WIN32) &amp;&amp; defined(_VARIADIC_MAX) &amp;&amp; (_VARIADIC_MAX &lt; 28))
6209          static_assert(0, &quot;Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.&quot;);
6210          #endif
6211      }
6212  	typedef Event result_type;
6213  	typedef Event type_(
6214  		const EnqueueArgs&amp;,
6215  		T0,
6216  		T1,
6217  		T2,
6218  		T3,
6219  		T4,
6220  		T5,
6221  		T6,
6222  		T7,
6223  		T8,
6224  		T9,
6225  		T10,
6226  		T11,
6227  		T12,
6228  		T13,
6229  		T14,
6230  		T15,
6231  		T16,
6232  		T17,
6233  		T18,
6234  		T19,
6235  		T20,
6236  		T21,
6237  		T22,
6238  		T23,
6239  		T24,
6240  		T25,
6241  		T26,
6242  		T27);
6243  	Event operator()(
6244  		const EnqueueArgs&amp; enqueueArgs,
6245  		T0 arg0,
6246  		T1 arg1,
6247  		T2 arg2,
6248  		T3 arg3,
6249  		T4 arg4,
6250  		T5 arg5,
6251  		T6 arg6,
6252  		T7 arg7,
6253  		T8 arg8,
6254  		T9 arg9,
6255  		T10 arg10,
6256  		T11 arg11,
6257  		T12 arg12,
6258  		T13 arg13,
6259  		T14 arg14,
6260  		T15 arg15,
6261  		T16 arg16,
6262  		T17 arg17,
6263  		T18 arg18,
6264  		T19 arg19,
6265  		T20 arg20,
6266  		T21 arg21,
6267  		T22 arg22,
6268  		T23 arg23,
6269  		T24 arg24,
6270  		T25 arg25,
6271  		T26 arg26,
6272  		T27 arg27)
6273  	{
6274  		return functor_(
6275  			enqueueArgs,
6276  			arg0,
6277  			arg1,
6278  			arg2,
6279  			arg3,
6280  			arg4,
6281  			arg5,
6282  			arg6,
6283  			arg7,
6284  			arg8,
6285  			arg9,
6286  			arg10,
6287  			arg11,
6288  			arg12,
6289  			arg13,
6290  			arg14,
6291  			arg15,
6292  			arg16,
6293  			arg17,
6294  			arg18,
6295  			arg19,
6296  			arg20,
6297  			arg21,
6298  			arg22,
6299  			arg23,
6300  			arg24,
6301  			arg25,
6302  			arg26,
6303  			arg27);
6304  	}
6305  };
6306  template&lt;
6307  	typename T0,
6308  	typename T1,
6309  	typename T2,
6310  	typename T3,
6311  	typename T4,
6312  	typename T5,
6313  	typename T6,
6314  	typename T7,
6315  	typename T8,
6316  	typename T9,
6317  	typename T10,
6318  	typename T11,
6319  	typename T12,
6320  	typename T13,
6321  	typename T14,
6322  	typename T15,
6323  	typename T16,
6324  	typename T17,
6325  	typename T18,
6326  	typename T19,
6327  	typename T20,
6328  	typename T21,
6329  	typename T22,
6330  	typename T23,
6331  	typename T24,
6332  	typename T25,
6333  	typename T26&gt;
6334  struct functionImplementation_
6335  &lt;	T0,
6336  	T1,
6337  	T2,
6338  	T3,
6339  	T4,
6340  	T5,
6341  	T6,
6342  	T7,
6343  	T8,
6344  	T9,
6345  	T10,
6346  	T11,
6347  	T12,
6348  	T13,
6349  	T14,
6350  	T15,
6351  	T16,
6352  	T17,
6353  	T18,
6354  	T19,
6355  	T20,
6356  	T21,
6357  	T22,
6358  	T23,
6359  	T24,
6360  	T25,
6361  	T26,
6362  	NullType,
6363  	NullType,
6364  	NullType,
6365  	NullType,
6366  	NullType&gt;
6367  {
6368  	typedef detail::KernelFunctorGlobal&lt;
6369  		T0,
6370  		T1,
6371  		T2,
6372  		T3,
6373  		T4,
6374  		T5,
6375  		T6,
6376  		T7,
6377  		T8,
6378  		T9,
6379  		T10,
6380  		T11,
6381  		T12,
6382  		T13,
6383  		T14,
6384  		T15,
6385  		T16,
6386  		T17,
6387  		T18,
6388  		T19,
6389  		T20,
6390  		T21,
6391  		T22,
6392  		T23,
6393  		T24,
6394  		T25,
6395  		T26,
6396  		NullType,
6397  		NullType,
6398  		NullType,
6399  		NullType,
6400  		NullType&gt; FunctorType;
6401      FunctorType functor_;
6402      functionImplementation_(const FunctorType &amp;functor) :
6403          functor_(functor)
6404      {
6405          #if (defined(_WIN32) &amp;&amp; defined(_VARIADIC_MAX) &amp;&amp; (_VARIADIC_MAX &lt; 27))
6406          static_assert(0, &quot;Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.&quot;);
6407          #endif
6408      }
6409  	typedef Event result_type;
6410  	typedef Event type_(
6411  		const EnqueueArgs&amp;,
6412  		T0,
6413  		T1,
6414  		T2,
6415  		T3,
6416  		T4,
6417  		T5,
6418  		T6,
6419  		T7,
6420  		T8,
6421  		T9,
6422  		T10,
6423  		T11,
6424  		T12,
6425  		T13,
6426  		T14,
6427  		T15,
6428  		T16,
6429  		T17,
6430  		T18,
6431  		T19,
6432  		T20,
6433  		T21,
6434  		T22,
6435  		T23,
6436  		T24,
6437  		T25,
6438  		T26);
6439  	Event operator()(
6440  		const EnqueueArgs&amp; enqueueArgs,
6441  		T0 arg0,
6442  		T1 arg1,
6443  		T2 arg2,
6444  		T3 arg3,
6445  		T4 arg4,
6446  		T5 arg5,
6447  		T6 arg6,
6448  		T7 arg7,
6449  		T8 arg8,
6450  		T9 arg9,
6451  		T10 arg10,
6452  		T11 arg11,
6453  		T12 arg12,
6454  		T13 arg13,
6455  		T14 arg14,
6456  		T15 arg15,
6457  		T16 arg16,
6458  		T17 arg17,
6459  		T18 arg18,
6460  		T19 arg19,
6461  		T20 arg20,
6462  		T21 arg21,
6463  		T22 arg22,
6464  		T23 arg23,
6465  		T24 arg24,
6466  		T25 arg25,
6467  		T26 arg26)
6468  	{
6469  		return functor_(
6470  			enqueueArgs,
6471  			arg0,
6472  			arg1,
6473  			arg2,
6474  			arg3,
6475  			arg4,
6476  			arg5,
6477  			arg6,
6478  			arg7,
6479  			arg8,
6480  			arg9,
6481  			arg10,
6482  			arg11,
6483  			arg12,
6484  			arg13,
6485  			arg14,
6486  			arg15,
6487  			arg16,
6488  			arg17,
6489  			arg18,
6490  			arg19,
6491  			arg20,
6492  			arg21,
6493  			arg22,
6494  			arg23,
6495  			arg24,
6496  			arg25,
6497  			arg26);
6498  	}
6499  };
6500  template&lt;
6501  	typename T0,
6502  	typename T1,
6503  	typename T2,
6504  	typename T3,
6505  	typename T4,
6506  	typename T5,
6507  	typename T6,
6508  	typename T7,
6509  	typename T8,
6510  	typename T9,
6511  	typename T10,
6512  	typename T11,
6513  	typename T12,
6514  	typename T13,
6515  	typename T14,
6516  	typename T15,
6517  	typename T16,
6518  	typename T17,
6519  	typename T18,
6520  	typename T19,
6521  	typename T20,
6522  	typename T21,
6523  	typename T22,
6524  	typename T23,
6525  	typename T24,
6526  	typename T25&gt;
6527  struct functionImplementation_
6528  &lt;	T0,
6529  	T1,
6530  	T2,
6531  	T3,
6532  	T4,
6533  	T5,
6534  	T6,
6535  	T7,
6536  	T8,
6537  	T9,
6538  	T10,
6539  	T11,
6540  	T12,
6541  	T13,
6542  	T14,
6543  	T15,
6544  	T16,
6545  	T17,
6546  	T18,
6547  	T19,
6548  	T20,
6549  	T21,
6550  	T22,
6551  	T23,
6552  	T24,
6553  	T25,
6554  	NullType,
6555  	NullType,
6556  	NullType,
6557  	NullType,
6558  	NullType,
6559  	NullType&gt;
6560  {
6561  	typedef detail::KernelFunctorGlobal&lt;
6562  		T0,
6563  		T1,
6564  		T2,
6565  		T3,
6566  		T4,
6567  		T5,
6568  		T6,
6569  		T7,
6570  		T8,
6571  		T9,
6572  		T10,
6573  		T11,
6574  		T12,
6575  		T13,
6576  		T14,
6577  		T15,
6578  		T16,
6579  		T17,
6580  		T18,
6581  		T19,
6582  		T20,
6583  		T21,
6584  		T22,
6585  		T23,
6586  		T24,
6587  		T25,
6588  		NullType,
6589  		NullType,
6590  		NullType,
6591  		NullType,
6592  		NullType,
6593  		NullType&gt; FunctorType;
6594      FunctorType functor_;
6595      functionImplementation_(const FunctorType &amp;functor) :
6596          functor_(functor)
6597      {
6598          #if (defined(_WIN32) &amp;&amp; defined(_VARIADIC_MAX) &amp;&amp; (_VARIADIC_MAX &lt; 26))
6599          static_assert(0, &quot;Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.&quot;);
6600          #endif
6601      }
6602  	typedef Event result_type;
6603  	typedef Event type_(
6604  		const EnqueueArgs&amp;,
6605  		T0,
6606  		T1,
6607  		T2,
6608  		T3,
6609  		T4,
6610  		T5,
6611  		T6,
6612  		T7,
6613  		T8,
6614  		T9,
6615  		T10,
6616  		T11,
6617  		T12,
6618  		T13,
6619  		T14,
6620  		T15,
6621  		T16,
6622  		T17,
6623  		T18,
6624  		T19,
6625  		T20,
6626  		T21,
6627  		T22,
6628  		T23,
6629  		T24,
6630  		T25);
6631  	Event operator()(
6632  		const EnqueueArgs&amp; enqueueArgs,
6633  		T0 arg0,
6634  		T1 arg1,
6635  		T2 arg2,
6636  		T3 arg3,
6637  		T4 arg4,
6638  		T5 arg5,
6639  		T6 arg6,
6640  		T7 arg7,
6641  		T8 arg8,
6642  		T9 arg9,
6643  		T10 arg10,
6644  		T11 arg11,
6645  		T12 arg12,
6646  		T13 arg13,
6647  		T14 arg14,
6648  		T15 arg15,
6649  		T16 arg16,
6650  		T17 arg17,
6651  		T18 arg18,
6652  		T19 arg19,
6653  		T20 arg20,
6654  		T21 arg21,
6655  		T22 arg22,
6656  		T23 arg23,
6657  		T24 arg24,
6658  		T25 arg25)
6659  	{
6660  		return functor_(
6661  			enqueueArgs,
6662  			arg0,
6663  			arg1,
6664  			arg2,
6665  			arg3,
6666  			arg4,
6667  			arg5,
6668  			arg6,
6669  			arg7,
6670  			arg8,
6671  			arg9,
6672  			arg10,
6673  			arg11,
6674  			arg12,
6675  			arg13,
6676  			arg14,
6677  			arg15,
6678  			arg16,
6679  			arg17,
6680  			arg18,
6681  			arg19,
6682  			arg20,
6683  			arg21,
6684  			arg22,
6685  			arg23,
6686  			arg24,
6687  			arg25);
6688  	}
6689  };
6690  template&lt;
6691  	typename T0,
6692  	typename T1,
6693  	typename T2,
6694  	typename T3,
6695  	typename T4,
6696  	typename T5,
6697  	typename T6,
6698  	typename T7,
6699  	typename T8,
6700  	typename T9,
6701  	typename T10,
6702  	typename T11,
6703  	typename T12,
6704  	typename T13,
6705  	typename T14,
6706  	typename T15,
6707  	typename T16,
6708  	typename T17,
6709  	typename T18,
6710  	typename T19,
6711  	typename T20,
6712  	typename T21,
6713  	typename T22,
6714  	typename T23,
6715  	typename T24&gt;
6716  struct functionImplementation_
6717  &lt;	T0,
6718  	T1,
6719  	T2,
6720  	T3,
6721  	T4,
6722  	T5,
6723  	T6,
6724  	T7,
6725  	T8,
6726  	T9,
6727  	T10,
6728  	T11,
6729  	T12,
6730  	T13,
6731  	T14,
6732  	T15,
6733  	T16,
6734  	T17,
6735  	T18,
6736  	T19,
6737  	T20,
6738  	T21,
6739  	T22,
6740  	T23,
6741  	T24,
6742  	NullType,
6743  	NullType,
6744  	NullType,
6745  	NullType,
6746  	NullType,
6747  	NullType,
6748  	NullType&gt;
6749  {
6750  	typedef detail::KernelFunctorGlobal&lt;
6751  		T0,
6752  		T1,
6753  		T2,
6754  		T3,
6755  		T4,
6756  		T5,
6757  		T6,
6758  		T7,
6759  		T8,
6760  		T9,
6761  		T10,
6762  		T11,
6763  		T12,
6764  		T13,
6765  		T14,
6766  		T15,
6767  		T16,
6768  		T17,
6769  		T18,
6770  		T19,
6771  		T20,
6772  		T21,
6773  		T22,
6774  		T23,
6775  		T24,
6776  		NullType,
6777  		NullType,
6778  		NullType,
6779  		NullType,
6780  		NullType,
6781  		NullType,
6782  		NullType&gt; FunctorType;
6783      FunctorType functor_;
6784      functionImplementation_(const FunctorType &amp;functor) :
6785          functor_(functor)
6786      {
6787          #if (defined(_WIN32) &amp;&amp; defined(_VARIADIC_MAX) &amp;&amp; (_VARIADIC_MAX &lt; 25))
6788          static_assert(0, &quot;Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.&quot;);
6789          #endif
6790      }
6791  	typedef Event result_type;
6792  	typedef Event type_(
6793  		const EnqueueArgs&amp;,
6794  		T0,
6795  		T1,
6796  		T2,
6797  		T3,
6798  		T4,
6799  		T5,
6800  		T6,
6801  		T7,
6802  		T8,
6803  		T9,
6804  		T10,
6805  		T11,
6806  		T12,
6807  		T13,
6808  		T14,
6809  		T15,
6810  		T16,
6811  		T17,
6812  		T18,
6813  		T19,
6814  		T20,
6815  		T21,
6816  		T22,
6817  		T23,
6818  		T24);
6819  	Event operator()(
6820  		const EnqueueArgs&amp; enqueueArgs,
6821  		T0 arg0,
6822  		T1 arg1,
6823  		T2 arg2,
6824  		T3 arg3,
6825  		T4 arg4,
6826  		T5 arg5,
6827  		T6 arg6,
6828  		T7 arg7,
6829  		T8 arg8,
6830  		T9 arg9,
6831  		T10 arg10,
6832  		T11 arg11,
6833  		T12 arg12,
6834  		T13 arg13,
6835  		T14 arg14,
6836  		T15 arg15,
6837  		T16 arg16,
6838  		T17 arg17,
6839  		T18 arg18,
6840  		T19 arg19,
6841  		T20 arg20,
6842  		T21 arg21,
6843  		T22 arg22,
6844  		T23 arg23,
6845  		T24 arg24)
6846  	{
6847  		return functor_(
6848  			enqueueArgs,
6849  			arg0,
6850  			arg1,
6851  			arg2,
6852  			arg3,
6853  			arg4,
6854  			arg5,
6855  			arg6,
6856  			arg7,
6857  			arg8,
6858  			arg9,
6859  			arg10,
6860  			arg11,
6861  			arg12,
6862  			arg13,
6863  			arg14,
6864  			arg15,
6865  			arg16,
6866  			arg17,
6867  			arg18,
6868  			arg19,
6869  			arg20,
6870  			arg21,
6871  			arg22,
6872  			arg23,
6873  			arg24);
6874  	}
6875  };
6876  template&lt;
6877  	typename T0,
6878  	typename T1,
6879  	typename T2,
6880  	typename T3,
6881  	typename T4,
6882  	typename T5,
6883  	typename T6,
6884  	typename T7,
6885  	typename T8,
6886  	typename T9,
6887  	typename T10,
6888  	typename T11,
6889  	typename T12,
6890  	typename T13,
6891  	typename T14,
6892  	typename T15,
6893  	typename T16,
6894  	typename T17,
6895  	typename T18,
6896  	typename T19,
6897  	typename T20,
6898  	typename T21,
6899  	typename T22,
6900  	typename T23&gt;
6901  struct functionImplementation_
6902  &lt;	T0,
6903  	T1,
6904  	T2,
6905  	T3,
6906  	T4,
6907  	T5,
6908  	T6,
6909  	T7,
6910  	T8,
6911  	T9,
6912  	T10,
6913  	T11,
6914  	T12,
6915  	T13,
6916  	T14,
6917  	T15,
6918  	T16,
6919  	T17,
6920  	T18,
6921  	T19,
6922  	T20,
6923  	T21,
6924  	T22,
6925  	T23,
6926  	NullType,
6927  	NullType,
6928  	NullType,
6929  	NullType,
6930  	NullType,
6931  	NullType,
6932  	NullType,
6933  	NullType&gt;
6934  {
6935  	typedef detail::KernelFunctorGlobal&lt;
6936  		T0,
6937  		T1,
6938  		T2,
6939  		T3,
6940  		T4,
6941  		T5,
6942  		T6,
6943  		T7,
6944  		T8,
6945  		T9,
6946  		T10,
6947  		T11,
6948  		T12,
6949  		T13,
6950  		T14,
6951  		T15,
6952  		T16,
6953  		T17,
6954  		T18,
6955  		T19,
6956  		T20,
6957  		T21,
6958  		T22,
6959  		T23,
6960  		NullType,
6961  		NullType,
6962  		NullType,
6963  		NullType,
6964  		NullType,
6965  		NullType,
6966  		NullType,
6967  		NullType&gt; FunctorType;
6968      FunctorType functor_;
6969      functionImplementation_(const FunctorType &amp;functor) :
6970          functor_(functor)
6971      {
6972          #if (defined(_WIN32) &amp;&amp; defined(_VARIADIC_MAX) &amp;&amp; (_VARIADIC_MAX &lt; 24))
6973          static_assert(0, &quot;Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.&quot;);
6974          #endif
6975      }
6976  	typedef Event result_type;
6977  	typedef Event type_(
6978  		const EnqueueArgs&amp;,
6979  		T0,
6980  		T1,
6981  		T2,
6982  		T3,
6983  		T4,
6984  		T5,
6985  		T6,
6986  		T7,
6987  		T8,
6988  		T9,
6989  		T10,
6990  		T11,
6991  		T12,
6992  		T13,
6993  		T14,
6994  		T15,
6995  		T16,
6996  		T17,
6997  		T18,
6998  		T19,
6999  		T20,
7000  		T21,
7001  		T22,
7002  		T23);
7003  	Event operator()(
7004  		const EnqueueArgs&amp; enqueueArgs,
7005  		T0 arg0,
7006  		T1 arg1,
7007  		T2 arg2,
7008  		T3 arg3,
7009  		T4 arg4,
7010  		T5 arg5,
7011  		T6 arg6,
7012  		T7 arg7,
7013  		T8 arg8,
7014  		T9 arg9,
7015  		T10 arg10,
7016  		T11 arg11,
7017  		T12 arg12,
7018  		T13 arg13,
7019  		T14 arg14,
7020  		T15 arg15,
7021  		T16 arg16,
7022  		T17 arg17,
7023  		T18 arg18,
7024  		T19 arg19,
7025  		T20 arg20,
7026  		T21 arg21,
7027  		T22 arg22,
7028  		T23 arg23)
7029  	{
7030  		return functor_(
7031  			enqueueArgs,
7032  			arg0,
7033  			arg1,
7034  			arg2,
7035  			arg3,
7036  			arg4,
7037  			arg5,
7038  			arg6,
7039  			arg7,
7040  			arg8,
7041  			arg9,
7042  			arg10,
7043  			arg11,
7044  			arg12,
7045  			arg13,
7046  			arg14,
7047  			arg15,
7048  			arg16,
7049  			arg17,
7050  			arg18,
7051  			arg19,
7052  			arg20,
7053  			arg21,
7054  			arg22,
7055  			arg23);
7056  	}
7057  };
7058  template&lt;
7059  	typename T0,
7060  	typename T1,
7061  	typename T2,
7062  	typename T3,
7063  	typename T4,
7064  	typename T5,
7065  	typename T6,
7066  	typename T7,
7067  	typename T8,
7068  	typename T9,
7069  	typename T10,
7070  	typename T11,
7071  	typename T12,
7072  	typename T13,
7073  	typename T14,
7074  	typename T15,
7075  	typename T16,
7076  	typename T17,
7077  	typename T18,
7078  	typename T19,
7079  	typename T20,
7080  	typename T21,
7081  	typename T22&gt;
7082  struct functionImplementation_
7083  &lt;	T0,
7084  	T1,
7085  	T2,
7086  	T3,
7087  	T4,
7088  	T5,
7089  	T6,
7090  	T7,
7091  	T8,
7092  	T9,
7093  	T10,
7094  	T11,
7095  	T12,
7096  	T13,
7097  	T14,
7098  	T15,
7099  	T16,
7100  	T17,
7101  	T18,
7102  	T19,
7103  	T20,
7104  	T21,
7105  	T22,
7106  	NullType,
7107  	NullType,
7108  	NullType,
7109  	NullType,
7110  	NullType,
7111  	NullType,
7112  	NullType,
7113  	NullType,
7114  	NullType&gt;
7115  {
7116  	typedef detail::KernelFunctorGlobal&lt;
7117  		T0,
7118  		T1,
7119  		T2,
7120  		T3,
7121  		T4,
7122  		T5,
7123  		T6,
7124  		T7,
7125  		T8,
7126  		T9,
7127  		T10,
7128  		T11,
7129  		T12,
7130  		T13,
7131  		T14,
7132  		T15,
7133  		T16,
7134  		T17,
7135  		T18,
7136  		T19,
7137  		T20,
7138  		T21,
7139  		T22,
7140  		NullType,
7141  		NullType,
7142  		NullType,
7143  		NullType,
7144  		NullType,
7145  		NullType,
7146  		NullType,
7147  		NullType,
7148  		NullType&gt; FunctorType;
7149      FunctorType functor_;
7150      functionImplementation_(const FunctorType &amp;functor) :
7151          functor_(functor)
7152      {
7153          #if (defined(_WIN32) &amp;&amp; defined(_VARIADIC_MAX) &amp;&amp; (_VARIADIC_MAX &lt; 23))
7154          static_assert(0, &quot;Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.&quot;);
7155          #endif
7156      }
7157  	typedef Event result_type;
7158  	typedef Event type_(
7159  		const EnqueueArgs&amp;,
7160  		T0,
7161  		T1,
7162  		T2,
7163  		T3,
7164  		T4,
7165  		T5,
7166  		T6,
7167  		T7,
7168  		T8,
7169  		T9,
7170  		T10,
7171  		T11,
7172  		T12,
7173  		T13,
7174  		T14,
7175  		T15,
7176  		T16,
7177  		T17,
7178  		T18,
7179  		T19,
7180  		T20,
7181  		T21,
7182  		T22);
7183  	Event operator()(
7184  		const EnqueueArgs&amp; enqueueArgs,
7185  		T0 arg0,
7186  		T1 arg1,
7187  		T2 arg2,
7188  		T3 arg3,
7189  		T4 arg4,
7190  		T5 arg5,
7191  		T6 arg6,
7192  		T7 arg7,
7193  		T8 arg8,
7194  		T9 arg9,
7195  		T10 arg10,
7196  		T11 arg11,
7197  		T12 arg12,
7198  		T13 arg13,
7199  		T14 arg14,
7200  		T15 arg15,
7201  		T16 arg16,
7202  		T17 arg17,
7203  		T18 arg18,
7204  		T19 arg19,
7205  		T20 arg20,
7206  		T21 arg21,
7207  		T22 arg22)
7208  	{
7209  		return functor_(
7210  			enqueueArgs,
7211  			arg0,
7212  			arg1,
7213  			arg2,
7214  			arg3,
7215  			arg4,
7216  			arg5,
7217  			arg6,
7218  			arg7,
7219  			arg8,
7220  			arg9,
7221  			arg10,
7222  			arg11,
7223  			arg12,
7224  			arg13,
7225  			arg14,
7226  			arg15,
7227  			arg16,
7228  			arg17,
7229  			arg18,
7230  			arg19,
7231  			arg20,
7232  			arg21,
7233  			arg22);
7234  	}
7235  };
7236  template&lt;
7237  	typename T0,
7238  	typename T1,
7239  	typename T2,
7240  	typename T3,
7241  	typename T4,
7242  	typename T5,
7243  	typename T6,
7244  	typename T7,
7245  	typename T8,
7246  	typename T9,
7247  	typename T10,
7248  	typename T11,
7249  	typename T12,
7250  	typename T13,
7251  	typename T14,
7252  	typename T15,
7253  	typename T16,
7254  	typename T17,
7255  	typename T18,
7256  	typename T19,
7257  	typename T20,
7258  	typename T21&gt;
7259  struct functionImplementation_
7260  &lt;	T0,
7261  	T1,
7262  	T2,
7263  	T3,
7264  	T4,
7265  	T5,
7266  	T6,
7267  	T7,
7268  	T8,
7269  	T9,
7270  	T10,
7271  	T11,
7272  	T12,
7273  	T13,
7274  	T14,
7275  	T15,
7276  	T16,
7277  	T17,
7278  	T18,
7279  	T19,
7280  	T20,
7281  	T21,
7282  	NullType,
7283  	NullType,
7284  	NullType,
7285  	NullType,
7286  	NullType,
7287  	NullType,
7288  	NullType,
7289  	NullType,
7290  	NullType,
7291  	NullType&gt;
7292  {
7293  	typedef detail::KernelFunctorGlobal&lt;
7294  		T0,
7295  		T1,
7296  		T2,
7297  		T3,
7298  		T4,
7299  		T5,
7300  		T6,
7301  		T7,
7302  		T8,
7303  		T9,
7304  		T10,
7305  		T11,
7306  		T12,
7307  		T13,
7308  		T14,
7309  		T15,
7310  		T16,
7311  		T17,
7312  		T18,
7313  		T19,
7314  		T20,
7315  		T21,
7316  		NullType,
7317  		NullType,
7318  		NullType,
7319  		NullType,
7320  		NullType,
7321  		NullType,
7322  		NullType,
7323  		NullType,
7324  		NullType,
7325  		NullType&gt; FunctorType;
7326      FunctorType functor_;
7327      functionImplementation_(const FunctorType &amp;functor) :
7328          functor_(functor)
7329      {
7330          #if (defined(_WIN32) &amp;&amp; defined(_VARIADIC_MAX) &amp;&amp; (_VARIADIC_MAX &lt; 22))
7331          static_assert(0, &quot;Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.&quot;);
7332          #endif
7333      }
7334  	typedef Event result_type;
7335  	typedef Event type_(
7336  		const EnqueueArgs&amp;,
7337  		T0,
7338  		T1,
7339  		T2,
7340  		T3,
7341  		T4,
7342  		T5,
7343  		T6,
7344  		T7,
7345  		T8,
7346  		T9,
7347  		T10,
7348  		T11,
7349  		T12,
7350  		T13,
7351  		T14,
7352  		T15,
7353  		T16,
7354  		T17,
7355  		T18,
7356  		T19,
7357  		T20,
7358  		T21);
7359  	Event operator()(
7360  		const EnqueueArgs&amp; enqueueArgs,
7361  		T0 arg0,
7362  		T1 arg1,
7363  		T2 arg2,
7364  		T3 arg3,
7365  		T4 arg4,
7366  		T5 arg5,
7367  		T6 arg6,
7368  		T7 arg7,
7369  		T8 arg8,
7370  		T9 arg9,
7371  		T10 arg10,
7372  		T11 arg11,
7373  		T12 arg12,
7374  		T13 arg13,
7375  		T14 arg14,
7376  		T15 arg15,
7377  		T16 arg16,
7378  		T17 arg17,
7379  		T18 arg18,
7380  		T19 arg19,
7381  		T20 arg20,
7382  		T21 arg21)
7383  	{
7384  		return functor_(
7385  			enqueueArgs,
7386  			arg0,
7387  			arg1,
7388  			arg2,
7389  			arg3,
7390  			arg4,
7391  			arg5,
7392  			arg6,
7393  			arg7,
7394  			arg8,
7395  			arg9,
7396  			arg10,
7397  			arg11,
7398  			arg12,
7399  			arg13,
7400  			arg14,
7401  			arg15,
7402  			arg16,
7403  			arg17,
7404  			arg18,
7405  			arg19,
7406  			arg20,
7407  			arg21);
7408  	}
7409  };
7410  template&lt;
7411  	typename T0,
7412  	typename T1,
7413  	typename T2,
7414  	typename T3,
7415  	typename T4,
7416  	typename T5,
7417  	typename T6,
7418  	typename T7,
7419  	typename T8,
7420  	typename T9,
7421  	typename T10,
7422  	typename T11,
7423  	typename T12,
7424  	typename T13,
7425  	typename T14,
7426  	typename T15,
7427  	typename T16,
7428  	typename T17,
7429  	typename T18,
7430  	typename T19,
7431  	typename T20&gt;
7432  struct functionImplementation_
7433  &lt;	T0,
7434  	T1,
7435  	T2,
7436  	T3,
7437  	T4,
7438  	T5,
7439  	T6,
7440  	T7,
7441  	T8,
7442  	T9,
7443  	T10,
7444  	T11,
7445  	T12,
7446  	T13,
7447  	T14,
7448  	T15,
7449  	T16,
7450  	T17,
7451  	T18,
7452  	T19,
7453  	T20,
7454  	NullType,
7455  	NullType,
7456  	NullType,
7457  	NullType,
7458  	NullType,
7459  	NullType,
7460  	NullType,
7461  	NullType,
7462  	NullType,
7463  	NullType,
7464  	NullType&gt;
7465  {
7466  	typedef detail::KernelFunctorGlobal&lt;
7467  		T0,
7468  		T1,
7469  		T2,
7470  		T3,
7471  		T4,
7472  		T5,
7473  		T6,
7474  		T7,
7475  		T8,
7476  		T9,
7477  		T10,
7478  		T11,
7479  		T12,
7480  		T13,
7481  		T14,
7482  		T15,
7483  		T16,
7484  		T17,
7485  		T18,
7486  		T19,
7487  		T20,
7488  		NullType,
7489  		NullType,
7490  		NullType,
7491  		NullType,
7492  		NullType,
7493  		NullType,
7494  		NullType,
7495  		NullType,
7496  		NullType,
7497  		NullType,
7498  		NullType&gt; FunctorType;
7499      FunctorType functor_;
7500      functionImplementation_(const FunctorType &amp;functor) :
7501          functor_(functor)
7502      {
7503          #if (defined(_WIN32) &amp;&amp; defined(_VARIADIC_MAX) &amp;&amp; (_VARIADIC_MAX &lt; 21))
7504          static_assert(0, &quot;Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.&quot;);
7505          #endif
7506      }
7507  	typedef Event result_type;
7508  	typedef Event type_(
7509  		const EnqueueArgs&amp;,
7510  		T0,
7511  		T1,
7512  		T2,
7513  		T3,
7514  		T4,
7515  		T5,
7516  		T6,
7517  		T7,
7518  		T8,
7519  		T9,
7520  		T10,
7521  		T11,
7522  		T12,
7523  		T13,
7524  		T14,
7525  		T15,
7526  		T16,
7527  		T17,
7528  		T18,
7529  		T19,
7530  		T20);
7531  	Event operator()(
7532  		const EnqueueArgs&amp; enqueueArgs,
7533  		T0 arg0,
7534  		T1 arg1,
7535  		T2 arg2,
7536  		T3 arg3,
7537  		T4 arg4,
7538  		T5 arg5,
7539  		T6 arg6,
7540  		T7 arg7,
7541  		T8 arg8,
7542  		T9 arg9,
7543  		T10 arg10,
7544  		T11 arg11,
7545  		T12 arg12,
7546  		T13 arg13,
7547  		T14 arg14,
7548  		T15 arg15,
7549  		T16 arg16,
7550  		T17 arg17,
7551  		T18 arg18,
7552  		T19 arg19,
7553  		T20 arg20)
7554  	{
7555  		return functor_(
7556  			enqueueArgs,
7557  			arg0,
7558  			arg1,
7559  			arg2,
7560  			arg3,
7561  			arg4,
7562  			arg5,
7563  			arg6,
7564  			arg7,
7565  			arg8,
7566  			arg9,
7567  			arg10,
7568  			arg11,
7569  			arg12,
7570  			arg13,
7571  			arg14,
7572  			arg15,
7573  			arg16,
7574  			arg17,
7575  			arg18,
7576  			arg19,
7577  			arg20);
7578  	}
7579  };
7580  template&lt;
7581  	typename T0,
7582  	typename T1,
7583  	typename T2,
7584  	typename T3,
7585  	typename T4,
7586  	typename T5,
7587  	typename T6,
7588  	typename T7,
7589  	typename T8,
7590  	typename T9,
7591  	typename T10,
7592  	typename T11,
7593  	typename T12,
7594  	typename T13,
7595  	typename T14,
7596  	typename T15,
7597  	typename T16,
7598  	typename T17,
7599  	typename T18,
7600  	typename T19&gt;
7601  struct functionImplementation_
7602  &lt;	T0,
7603  	T1,
7604  	T2,
7605  	T3,
7606  	T4,
7607  	T5,
7608  	T6,
7609  	T7,
7610  	T8,
7611  	T9,
7612  	T10,
7613  	T11,
7614  	T12,
7615  	T13,
7616  	T14,
7617  	T15,
7618  	T16,
7619  	T17,
7620  	T18,
7621  	T19,
7622  	NullType,
7623  	NullType,
7624  	NullType,
7625  	NullType,
7626  	NullType,
7627  	NullType,
7628  	NullType,
7629  	NullType,
7630  	NullType,
7631  	NullType,
7632  	NullType,
7633  	NullType&gt;
7634  {
7635  	typedef detail::KernelFunctorGlobal&lt;
7636  		T0,
7637  		T1,
7638  		T2,
7639  		T3,
7640  		T4,
7641  		T5,
7642  		T6,
7643  		T7,
7644  		T8,
7645  		T9,
7646  		T10,
7647  		T11,
7648  		T12,
7649  		T13,
7650  		T14,
7651  		T15,
7652  		T16,
7653  		T17,
7654  		T18,
7655  		T19,
7656  		NullType,
7657  		NullType,
7658  		NullType,
7659  		NullType,
7660  		NullType,
7661  		NullType,
7662  		NullType,
7663  		NullType,
7664  		NullType,
7665  		NullType,
7666  		NullType,
7667  		NullType&gt; FunctorType;
7668      FunctorType functor_;
7669      functionImplementation_(const FunctorType &amp;functor) :
7670          functor_(functor)
7671      {
7672          #if (defined(_WIN32) &amp;&amp; defined(_VARIADIC_MAX) &amp;&amp; (_VARIADIC_MAX &lt; 20))
7673          static_assert(0, &quot;Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.&quot;);
7674          #endif
7675      }
7676  	typedef Event result_type;
7677  	typedef Event type_(
7678  		const EnqueueArgs&amp;,
7679  		T0,
7680  		T1,
7681  		T2,
7682  		T3,
7683  		T4,
7684  		T5,
7685  		T6,
7686  		T7,
7687  		T8,
7688  		T9,
7689  		T10,
7690  		T11,
7691  		T12,
7692  		T13,
7693  		T14,
7694  		T15,
7695  		T16,
7696  		T17,
7697  		T18,
7698  		T19);
7699  	Event operator()(
7700  		const EnqueueArgs&amp; enqueueArgs,
7701  		T0 arg0,
7702  		T1 arg1,
7703  		T2 arg2,
7704  		T3 arg3,
7705  		T4 arg4,
7706  		T5 arg5,
7707  		T6 arg6,
7708  		T7 arg7,
7709  		T8 arg8,
7710  		T9 arg9,
7711  		T10 arg10,
7712  		T11 arg11,
7713  		T12 arg12,
7714  		T13 arg13,
7715  		T14 arg14,
7716  		T15 arg15,
7717  		T16 arg16,
7718  		T17 arg17,
7719  		T18 arg18,
7720  		T19 arg19)
7721  	{
7722  		return functor_(
7723  			enqueueArgs,
7724  			arg0,
7725  			arg1,
7726  			arg2,
7727  			arg3,
7728  			arg4,
7729  			arg5,
7730  			arg6,
7731  			arg7,
7732  			arg8,
7733  			arg9,
7734  			arg10,
7735  			arg11,
7736  			arg12,
7737  			arg13,
7738  			arg14,
7739  			arg15,
7740  			arg16,
7741  			arg17,
7742  			arg18,
7743  			arg19);
7744  	}
7745  };
7746  template&lt;
7747  	typename T0,
7748  	typename T1,
7749  	typename T2,
7750  	typename T3,
7751  	typename T4,
7752  	typename T5,
7753  	typename T6,
7754  	typename T7,
7755  	typename T8,
7756  	typename T9,
7757  	typename T10,
7758  	typename T11,
7759  	typename T12,
7760  	typename T13,
7761  	typename T14,
7762  	typename T15,
7763  	typename T16,
7764  	typename T17,
7765  	typename T18&gt;
7766  struct functionImplementation_
7767  &lt;	T0,
7768  	T1,
7769  	T2,
7770  	T3,
7771  	T4,
7772  	T5,
7773  	T6,
7774  	T7,
7775  	T8,
7776  	T9,
7777  	T10,
7778  	T11,
7779  	T12,
7780  	T13,
7781  	T14,
7782  	T15,
7783  	T16,
7784  	T17,
7785  	T18,
7786  	NullType,
7787  	NullType,
7788  	NullType,
7789  	NullType,
7790  	NullType,
7791  	NullType,
7792  	NullType,
7793  	NullType,
7794  	NullType,
7795  	NullType,
7796  	NullType,
7797  	NullType,
7798  	NullType&gt;
7799  {
7800  	typedef detail::KernelFunctorGlobal&lt;
7801  		T0,
7802  		T1,
7803  		T2,
7804  		T3,
7805  		T4,
7806  		T5,
7807  		T6,
7808  		T7,
7809  		T8,
7810  		T9,
7811  		T10,
7812  		T11,
7813  		T12,
7814  		T13,
7815  		T14,
7816  		T15,
7817  		T16,
7818  		T17,
7819  		T18,
7820  		NullType,
7821  		NullType,
7822  		NullType,
7823  		NullType,
7824  		NullType,
7825  		NullType,
7826  		NullType,
7827  		NullType,
7828  		NullType,
7829  		NullType,
7830  		NullType,
7831  		NullType,
7832  		NullType&gt; FunctorType;
7833      FunctorType functor_;
7834      functionImplementation_(const FunctorType &amp;functor) :
7835          functor_(functor)
7836      {
7837          #if (defined(_WIN32) &amp;&amp; defined(_VARIADIC_MAX) &amp;&amp; (_VARIADIC_MAX &lt; 19))
7838          static_assert(0, &quot;Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.&quot;);
7839          #endif
7840      }
7841  	typedef Event result_type;
7842  	typedef Event type_(
7843  		const EnqueueArgs&amp;,
7844  		T0,
7845  		T1,
7846  		T2,
7847  		T3,
7848  		T4,
7849  		T5,
7850  		T6,
7851  		T7,
7852  		T8,
7853  		T9,
7854  		T10,
7855  		T11,
7856  		T12,
7857  		T13,
7858  		T14,
7859  		T15,
7860  		T16,
7861  		T17,
7862  		T18);
7863  	Event operator()(
7864  		const EnqueueArgs&amp; enqueueArgs,
7865  		T0 arg0,
7866  		T1 arg1,
7867  		T2 arg2,
7868  		T3 arg3,
7869  		T4 arg4,
7870  		T5 arg5,
7871  		T6 arg6,
7872  		T7 arg7,
7873  		T8 arg8,
7874  		T9 arg9,
7875  		T10 arg10,
7876  		T11 arg11,
7877  		T12 arg12,
7878  		T13 arg13,
7879  		T14 arg14,
7880  		T15 arg15,
7881  		T16 arg16,
7882  		T17 arg17,
7883  		T18 arg18)
7884  	{
7885  		return functor_(
7886  			enqueueArgs,
7887  			arg0,
7888  			arg1,
7889  			arg2,
7890  			arg3,
7891  			arg4,
7892  			arg5,
7893  			arg6,
7894  			arg7,
7895  			arg8,
7896  			arg9,
7897  			arg10,
7898  			arg11,
7899  			arg12,
7900  			arg13,
7901  			arg14,
7902  			arg15,
7903  			arg16,
7904  			arg17,
7905  			arg18);
7906  	}
7907  };
7908  template&lt;
7909  	typename T0,
7910  	typename T1,
7911  	typename T2,
7912  	typename T3,
7913  	typename T4,
7914  	typename T5,
7915  	typename T6,
7916  	typename T7,
7917  	typename T8,
7918  	typename T9,
7919  	typename T10,
7920  	typename T11,
7921  	typename T12,
7922  	typename T13,
7923  	typename T14,
7924  	typename T15,
7925  	typename T16,
7926  	typename T17&gt;
7927  struct functionImplementation_
7928  &lt;	T0,
7929  	T1,
7930  	T2,
7931  	T3,
7932  	T4,
7933  	T5,
7934  	T6,
7935  	T7,
7936  	T8,
7937  	T9,
7938  	T10,
7939  	T11,
7940  	T12,
7941  	T13,
7942  	T14,
7943  	T15,
7944  	T16,
7945  	T17,
7946  	NullType,
7947  	NullType,
7948  	NullType,
7949  	NullType,
7950  	NullType,
7951  	NullType,
7952  	NullType,
7953  	NullType,
7954  	NullType,
7955  	NullType,
7956  	NullType,
7957  	NullType,
7958  	NullType,
7959  	NullType&gt;
7960  {
7961  	typedef detail::KernelFunctorGlobal&lt;
7962  		T0,
7963  		T1,
7964  		T2,
7965  		T3,
7966  		T4,
7967  		T5,
7968  		T6,
7969  		T7,
7970  		T8,
7971  		T9,
7972  		T10,
7973  		T11,
7974  		T12,
7975  		T13,
7976  		T14,
7977  		T15,
7978  		T16,
7979  		T17,
7980  		NullType,
7981  		NullType,
7982  		NullType,
7983  		NullType,
7984  		NullType,
7985  		NullType,
7986  		NullType,
7987  		NullType,
7988  		NullType,
7989  		NullType,
7990  		NullType,
7991  		NullType,
7992  		NullType,
7993  		NullType&gt; FunctorType;
7994      FunctorType functor_;
7995      functionImplementation_(const FunctorType &amp;functor) :
7996          functor_(functor)
7997      {
7998          #if (defined(_WIN32) &amp;&amp; defined(_VARIADIC_MAX) &amp;&amp; (_VARIADIC_MAX &lt; 18))
7999          static_assert(0, &quot;Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.&quot;);
8000          #endif
8001      }
8002  	typedef Event result_type;
8003  	typedef Event type_(
8004  		const EnqueueArgs&amp;,
8005  		T0,
8006  		T1,
8007  		T2,
8008  		T3,
8009  		T4,
8010  		T5,
8011  		T6,
8012  		T7,
8013  		T8,
8014  		T9,
8015  		T10,
8016  		T11,
8017  		T12,
8018  		T13,
8019  		T14,
8020  		T15,
8021  		T16,
8022  		T17);
8023  	Event operator()(
8024  		const EnqueueArgs&amp; enqueueArgs,
8025  		T0 arg0,
8026  		T1 arg1,
8027  		T2 arg2,
8028  		T3 arg3,
8029  		T4 arg4,
8030  		T5 arg5,
8031  		T6 arg6,
8032  		T7 arg7,
8033  		T8 arg8,
8034  		T9 arg9,
8035  		T10 arg10,
8036  		T11 arg11,
8037  		T12 arg12,
8038  		T13 arg13,
8039  		T14 arg14,
8040  		T15 arg15,
8041  		T16 arg16,
8042  		T17 arg17)
8043  	{
8044  		return functor_(
8045  			enqueueArgs,
8046  			arg0,
8047  			arg1,
8048  			arg2,
8049  			arg3,
8050  			arg4,
8051  			arg5,
8052  			arg6,
8053  			arg7,
8054  			arg8,
8055  			arg9,
8056  			arg10,
8057  			arg11,
8058  			arg12,
8059  			arg13,
8060  			arg14,
8061  			arg15,
8062  			arg16,
8063  			arg17);
8064  	}
8065  };
8066  template&lt;
8067  	typename T0,
8068  	typename T1,
8069  	typename T2,
8070  	typename T3,
8071  	typename T4,
8072  	typename T5,
8073  	typename T6,
8074  	typename T7,
8075  	typename T8,
8076  	typename T9,
8077  	typename T10,
8078  	typename T11,
8079  	typename T12,
8080  	typename T13,
8081  	typename T14,
8082  	typename T15,
8083  	typename T16&gt;
8084  struct functionImplementation_
8085  &lt;	T0,
8086  	T1,
8087  	T2,
8088  	T3,
8089  	T4,
8090  	T5,
8091  	T6,
8092  	T7,
8093  	T8,
8094  	T9,
8095  	T10,
8096  	T11,
8097  	T12,
8098  	T13,
8099  	T14,
8100  	T15,
8101  	T16,
8102  	NullType,
8103  	NullType,
8104  	NullType,
8105  	NullType,
8106  	NullType,
8107  	NullType,
8108  	NullType,
8109  	NullType,
8110  	NullType,
8111  	NullType,
8112  	NullType,
8113  	NullType,
8114  	NullType,
8115  	NullType,
8116  	NullType&gt;
8117  {
8118  	typedef detail::KernelFunctorGlobal&lt;
8119  		T0,
8120  		T1,
8121  		T2,
8122  		T3,
8123  		T4,
8124  		T5,
8125  		T6,
8126  		T7,
8127  		T8,
8128  		T9,
8129  		T10,
8130  		T11,
8131  		T12,
8132  		T13,
8133  		T14,
8134  		T15,
8135  		T16,
8136  		NullType,
8137  		NullType,
8138  		NullType,
8139  		NullType,
8140  		NullType,
8141  		NullType,
8142  		NullType,
8143  		NullType,
8144  		NullType,
8145  		NullType,
8146  		NullType,
8147  		NullType,
8148  		NullType,
8149  		NullType,
8150  		NullType&gt; FunctorType;
8151      FunctorType functor_;
8152      functionImplementation_(const FunctorType &amp;functor) :
8153          functor_(functor)
8154      {
8155          #if (defined(_WIN32) &amp;&amp; defined(_VARIADIC_MAX) &amp;&amp; (_VARIADIC_MAX &lt; 17))
8156          static_assert(0, &quot;Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.&quot;);
8157          #endif
8158      }
8159  	typedef Event result_type;
8160  	typedef Event type_(
8161  		const EnqueueArgs&amp;,
8162  		T0,
8163  		T1,
8164  		T2,
8165  		T3,
8166  		T4,
8167  		T5,
8168  		T6,
8169  		T7,
8170  		T8,
8171  		T9,
8172  		T10,
8173  		T11,
8174  		T12,
8175  		T13,
8176  		T14,
8177  		T15,
8178  		T16);
8179  	Event operator()(
8180  		const EnqueueArgs&amp; enqueueArgs,
8181  		T0 arg0,
8182  		T1 arg1,
8183  		T2 arg2,
8184  		T3 arg3,
8185  		T4 arg4,
8186  		T5 arg5,
8187  		T6 arg6,
8188  		T7 arg7,
8189  		T8 arg8,
8190  		T9 arg9,
8191  		T10 arg10,
8192  		T11 arg11,
8193  		T12 arg12,
8194  		T13 arg13,
8195  		T14 arg14,
8196  		T15 arg15,
8197  		T16 arg16)
8198  	{
8199  		return functor_(
8200  			enqueueArgs,
8201  			arg0,
8202  			arg1,
8203  			arg2,
8204  			arg3,
8205  			arg4,
8206  			arg5,
8207  			arg6,
8208  			arg7,
8209  			arg8,
8210  			arg9,
8211  			arg10,
8212  			arg11,
8213  			arg12,
8214  			arg13,
8215  			arg14,
8216  			arg15,
8217  			arg16);
8218  	}
8219  };
8220  template&lt;
8221  	typename T0,
8222  	typename T1,
8223  	typename T2,
8224  	typename T3,
8225  	typename T4,
8226  	typename T5,
8227  	typename T6,
8228  	typename T7,
8229  	typename T8,
8230  	typename T9,
8231  	typename T10,
8232  	typename T11,
8233  	typename T12,
8234  	typename T13,
8235  	typename T14,
8236  	typename T15&gt;
8237  struct functionImplementation_
8238  &lt;	T0,
8239  	T1,
8240  	T2,
8241  	T3,
8242  	T4,
8243  	T5,
8244  	T6,
8245  	T7,
8246  	T8,
8247  	T9,
8248  	T10,
8249  	T11,
8250  	T12,
8251  	T13,
8252  	T14,
8253  	T15,
8254  	NullType,
8255  	NullType,
8256  	NullType,
8257  	NullType,
8258  	NullType,
8259  	NullType,
8260  	NullType,
8261  	NullType,
8262  	NullType,
8263  	NullType,
8264  	NullType,
8265  	NullType,
8266  	NullType,
8267  	NullType,
8268  	NullType,
8269  	NullType&gt;
8270  {
8271  	typedef detail::KernelFunctorGlobal&lt;
8272  		T0,
8273  		T1,
8274  		T2,
8275  		T3,
8276  		T4,
8277  		T5,
8278  		T6,
8279  		T7,
8280  		T8,
8281  		T9,
8282  		T10,
8283  		T11,
8284  		T12,
8285  		T13,
8286  		T14,
8287  		T15,
8288  		NullType,
8289  		NullType,
8290  		NullType,
8291  		NullType,
8292  		NullType,
8293  		NullType,
8294  		NullType,
8295  		NullType,
8296  		NullType,
8297  		NullType,
8298  		NullType,
8299  		NullType,
8300  		NullType,
8301  		NullType,
8302  		NullType,
8303  		NullType&gt; FunctorType;
8304      FunctorType functor_;
8305      functionImplementation_(const FunctorType &amp;functor) :
8306          functor_(functor)
8307      {
8308          #if (defined(_WIN32) &amp;&amp; defined(_VARIADIC_MAX) &amp;&amp; (_VARIADIC_MAX &lt; 16))
8309          static_assert(0, &quot;Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.&quot;);
8310          #endif
8311      }
8312  	typedef Event result_type;
8313  	typedef Event type_(
8314  		const EnqueueArgs&amp;,
8315  		T0,
8316  		T1,
8317  		T2,
8318  		T3,
8319  		T4,
8320  		T5,
8321  		T6,
8322  		T7,
8323  		T8,
8324  		T9,
8325  		T10,
8326  		T11,
8327  		T12,
8328  		T13,
8329  		T14,
8330  		T15);
8331  	Event operator()(
8332  		const EnqueueArgs&amp; enqueueArgs,
8333  		T0 arg0,
8334  		T1 arg1,
8335  		T2 arg2,
8336  		T3 arg3,
8337  		T4 arg4,
8338  		T5 arg5,
8339  		T6 arg6,
8340  		T7 arg7,
8341  		T8 arg8,
8342  		T9 arg9,
8343  		T10 arg10,
8344  		T11 arg11,
8345  		T12 arg12,
8346  		T13 arg13,
8347  		T14 arg14,
8348  		T15 arg15)
8349  	{
8350  		return functor_(
8351  			enqueueArgs,
8352  			arg0,
8353  			arg1,
8354  			arg2,
8355  			arg3,
8356  			arg4,
8357  			arg5,
8358  			arg6,
8359  			arg7,
8360  			arg8,
8361  			arg9,
8362  			arg10,
8363  			arg11,
8364  			arg12,
8365  			arg13,
8366  			arg14,
8367  			arg15);
8368  	}
8369  };
8370  template&lt;
8371  	typename T0,
8372  	typename T1,
8373  	typename T2,
8374  	typename T3,
8375  	typename T4,
8376  	typename T5,
8377  	typename T6,
8378  	typename T7,
8379  	typename T8,
8380  	typename T9,
8381  	typename T10,
8382  	typename T11,
8383  	typename T12,
8384  	typename T13,
8385  	typename T14&gt;
8386  struct functionImplementation_
8387  &lt;	T0,
8388  	T1,
8389  	T2,
8390  	T3,
8391  	T4,
8392  	T5,
8393  	T6,
8394  	T7,
8395  	T8,
8396  	T9,
8397  	T10,
8398  	T11,
8399  	T12,
8400  	T13,
8401  	T14,
8402  	NullType,
8403  	NullType,
8404  	NullType,
8405  	NullType,
8406  	NullType,
8407  	NullType,
8408  	NullType,
8409  	NullType,
8410  	NullType,
8411  	NullType,
8412  	NullType,
8413  	NullType,
8414  	NullType,
8415  	NullType,
8416  	NullType,
8417  	NullType,
8418  	NullType&gt;
8419  {
8420  	typedef detail::KernelFunctorGlobal&lt;
8421  		T0,
8422  		T1,
8423  		T2,
8424  		T3,
8425  		T4,
8426  		T5,
8427  		T6,
8428  		T7,
8429  		T8,
8430  		T9,
8431  		T10,
8432  		T11,
8433  		T12,
8434  		T13,
8435  		T14,
8436  		NullType,
8437  		NullType,
8438  		NullType,
8439  		NullType,
8440  		NullType,
8441  		NullType,
8442  		NullType,
8443  		NullType,
8444  		NullType,
8445  		NullType,
8446  		NullType,
8447  		NullType,
8448  		NullType,
8449  		NullType,
8450  		NullType,
8451  		NullType,
8452  		NullType&gt; FunctorType;
8453      FunctorType functor_;
8454      functionImplementation_(const FunctorType &amp;functor) :
8455          functor_(functor)
8456      {
8457          #if (defined(_WIN32) &amp;&amp; defined(_VARIADIC_MAX) &amp;&amp; (_VARIADIC_MAX &lt; 15))
8458          static_assert(0, &quot;Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.&quot;);
8459          #endif
8460      }
8461  	typedef Event result_type;
8462  	typedef Event type_(
8463  		const EnqueueArgs&amp;,
8464  		T0,
8465  		T1,
8466  		T2,
8467  		T3,
8468  		T4,
8469  		T5,
8470  		T6,
8471  		T7,
8472  		T8,
8473  		T9,
8474  		T10,
8475  		T11,
8476  		T12,
8477  		T13,
8478  		T14);
8479  	Event operator()(
8480  		const EnqueueArgs&amp; enqueueArgs,
8481  		T0 arg0,
8482  		T1 arg1,
8483  		T2 arg2,
8484  		T3 arg3,
8485  		T4 arg4,
8486  		T5 arg5,
8487  		T6 arg6,
8488  		T7 arg7,
8489  		T8 arg8,
8490  		T9 arg9,
8491  		T10 arg10,
8492  		T11 arg11,
8493  		T12 arg12,
8494  		T13 arg13,
8495  		T14 arg14)
8496  	{
8497  		return functor_(
8498  			enqueueArgs,
8499  			arg0,
8500  			arg1,
8501  			arg2,
8502  			arg3,
8503  			arg4,
8504  			arg5,
8505  			arg6,
8506  			arg7,
8507  			arg8,
8508  			arg9,
8509  			arg10,
8510  			arg11,
8511  			arg12,
8512  			arg13,
8513  			arg14);
8514  	}
8515  };
8516  template&lt;
8517  	typename T0,
8518  	typename T1,
8519  	typename T2,
8520  	typename T3,
8521  	typename T4,
8522  	typename T5,
8523  	typename T6,
8524  	typename T7,
8525  	typename T8,
8526  	typename T9,
8527  	typename T10,
8528  	typename T11,
8529  	typename T12,
8530  	typename T13&gt;
8531  struct functionImplementation_
8532  &lt;	T0,
8533  	T1,
8534  	T2,
8535  	T3,
8536  	T4,
8537  	T5,
8538  	T6,
8539  	T7,
8540  	T8,
8541  	T9,
8542  	T10,
8543  	T11,
8544  	T12,
8545  	T13,
8546  	NullType,
8547  	NullType,
8548  	NullType,
8549  	NullType,
8550  	NullType,
8551  	NullType,
8552  	NullType,
8553  	NullType,
8554  	NullType,
8555  	NullType,
8556  	NullType,
8557  	NullType,
8558  	NullType,
8559  	NullType,
8560  	NullType,
8561  	NullType,
8562  	NullType,
8563  	NullType&gt;
8564  {
8565  	typedef detail::KernelFunctorGlobal&lt;
8566  		T0,
8567  		T1,
8568  		T2,
8569  		T3,
8570  		T4,
8571  		T5,
8572  		T6,
8573  		T7,
8574  		T8,
8575  		T9,
8576  		T10,
8577  		T11,
8578  		T12,
8579  		T13,
8580  		NullType,
8581  		NullType,
8582  		NullType,
8583  		NullType,
8584  		NullType,
8585  		NullType,
8586  		NullType,
8587  		NullType,
8588  		NullType,
8589  		NullType,
8590  		NullType,
8591  		NullType,
8592  		NullType,
8593  		NullType,
8594  		NullType,
8595  		NullType,
8596  		NullType,
8597  		NullType&gt; FunctorType;
8598      FunctorType functor_;
8599      functionImplementation_(const FunctorType &amp;functor) :
8600          functor_(functor)
8601      {
8602          #if (defined(_WIN32) &amp;&amp; defined(_VARIADIC_MAX) &amp;&amp; (_VARIADIC_MAX &lt; 14))
8603          static_assert(0, &quot;Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.&quot;);
8604          #endif
8605      }
8606  	typedef Event result_type;
8607  	typedef Event type_(
8608  		const EnqueueArgs&amp;,
8609  		T0,
8610  		T1,
8611  		T2,
8612  		T3,
8613  		T4,
8614  		T5,
8615  		T6,
8616  		T7,
8617  		T8,
8618  		T9,
8619  		T10,
8620  		T11,
8621  		T12,
8622  		T13);
8623  	Event operator()(
8624  		const EnqueueArgs&amp; enqueueArgs,
8625  		T0 arg0,
8626  		T1 arg1,
8627  		T2 arg2,
8628  		T3 arg3,
8629  		T4 arg4,
8630  		T5 arg5,
8631  		T6 arg6,
8632  		T7 arg7,
8633  		T8 arg8,
8634  		T9 arg9,
8635  		T10 arg10,
8636  		T11 arg11,
8637  		T12 arg12,
8638  		T13 arg13)
8639  	{
8640  		return functor_(
8641  			enqueueArgs,
8642  			arg0,
8643  			arg1,
8644  			arg2,
8645  			arg3,
8646  			arg4,
8647  			arg5,
8648  			arg6,
8649  			arg7,
8650  			arg8,
8651  			arg9,
8652  			arg10,
8653  			arg11,
8654  			arg12,
8655  			arg13);
8656  	}
8657  };
8658  template&lt;
8659  	typename T0,
8660  	typename T1,
8661  	typename T2,
8662  	typename T3,
8663  	typename T4,
8664  	typename T5,
8665  	typename T6,
8666  	typename T7,
8667  	typename T8,
8668  	typename T9,
8669  	typename T10,
8670  	typename T11,
8671  	typename T12&gt;
8672  struct functionImplementation_
8673  &lt;	T0,
8674  	T1,
8675  	T2,
8676  	T3,
8677  	T4,
8678  	T5,
8679  	T6,
8680  	T7,
8681  	T8,
8682  	T9,
8683  	T10,
8684  	T11,
8685  	T12,
8686  	NullType,
8687  	NullType,
8688  	NullType,
8689  	NullType,
8690  	NullType,
8691  	NullType,
8692  	NullType,
8693  	NullType,
8694  	NullType,
8695  	NullType,
8696  	NullType,
8697  	NullType,
8698  	NullType,
8699  	NullType,
8700  	NullType,
8701  	NullType,
8702  	NullType,
8703  	NullType,
8704  	NullType&gt;
8705  {
8706  	typedef detail::KernelFunctorGlobal&lt;
8707  		T0,
8708  		T1,
8709  		T2,
8710  		T3,
8711  		T4,
8712  		T5,
8713  		T6,
8714  		T7,
8715  		T8,
8716  		T9,
8717  		T10,
8718  		T11,
8719  		T12,
8720  		NullType,
8721  		NullType,
8722  		NullType,
8723  		NullType,
8724  		NullType,
8725  		NullType,
8726  		NullType,
8727  		NullType,
8728  		NullType,
8729  		NullType,
8730  		NullType,
8731  		NullType,
8732  		NullType,
8733  		NullType,
8734  		NullType,
8735  		NullType,
8736  		NullType,
8737  		NullType,
8738  		NullType&gt; FunctorType;
8739      FunctorType functor_;
8740      functionImplementation_(const FunctorType &amp;functor) :
8741          functor_(functor)
8742      {
8743          #if (defined(_WIN32) &amp;&amp; defined(_VARIADIC_MAX) &amp;&amp; (_VARIADIC_MAX &lt; 13))
8744          static_assert(0, &quot;Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.&quot;);
8745          #endif
8746      }
8747  	typedef Event result_type;
8748  	typedef Event type_(
8749  		const EnqueueArgs&amp;,
8750  		T0,
8751  		T1,
8752  		T2,
8753  		T3,
8754  		T4,
8755  		T5,
8756  		T6,
8757  		T7,
8758  		T8,
8759  		T9,
8760  		T10,
8761  		T11,
8762  		T12);
8763  	Event operator()(
8764  		const EnqueueArgs&amp; enqueueArgs,
8765  		T0 arg0,
8766  		T1 arg1,
8767  		T2 arg2,
8768  		T3 arg3,
8769  		T4 arg4,
8770  		T5 arg5,
8771  		T6 arg6,
8772  		T7 arg7,
8773  		T8 arg8,
8774  		T9 arg9,
8775  		T10 arg10,
8776  		T11 arg11,
8777  		T12 arg12)
8778  	{
8779  		return functor_(
8780  			enqueueArgs,
8781  			arg0,
8782  			arg1,
8783  			arg2,
8784  			arg3,
8785  			arg4,
8786  			arg5,
8787  			arg6,
8788  			arg7,
8789  			arg8,
8790  			arg9,
8791  			arg10,
8792  			arg11,
8793  			arg12);
8794  	}
8795  };
8796  template&lt;
8797  	typename T0,
8798  	typename T1,
8799  	typename T2,
8800  	typename T3,
8801  	typename T4,
8802  	typename T5,
8803  	typename T6,
8804  	typename T7,
8805  	typename T8,
8806  	typename T9,
8807  	typename T10,
8808  	typename T11&gt;
8809  struct functionImplementation_
8810  &lt;	T0,
8811  	T1,
8812  	T2,
8813  	T3,
8814  	T4,
8815  	T5,
8816  	T6,
8817  	T7,
8818  	T8,
8819  	T9,
8820  	T10,
8821  	T11,
8822  	NullType,
8823  	NullType,
8824  	NullType,
8825  	NullType,
8826  	NullType,
8827  	NullType,
8828  	NullType,
8829  	NullType,
8830  	NullType,
8831  	NullType,
8832  	NullType,
8833  	NullType,
8834  	NullType,
8835  	NullType,
8836  	NullType,
8837  	NullType,
8838  	NullType,
8839  	NullType,
8840  	NullType,
8841  	NullType&gt;
8842  {
8843  	typedef detail::KernelFunctorGlobal&lt;
8844  		T0,
8845  		T1,
8846  		T2,
8847  		T3,
8848  		T4,
8849  		T5,
8850  		T6,
8851  		T7,
8852  		T8,
8853  		T9,
8854  		T10,
8855  		T11,
8856  		NullType,
8857  		NullType,
8858  		NullType,
8859  		NullType,
8860  		NullType,
8861  		NullType,
8862  		NullType,
8863  		NullType,
8864  		NullType,
8865  		NullType,
8866  		NullType,
8867  		NullType,
8868  		NullType,
8869  		NullType,
8870  		NullType,
8871  		NullType,
8872  		NullType,
8873  		NullType,
8874  		NullType,
8875  		NullType&gt; FunctorType;
8876      FunctorType functor_;
8877      functionImplementation_(const FunctorType &amp;functor) :
8878          functor_(functor)
8879      {
8880          #if (defined(_WIN32) &amp;&amp; defined(_VARIADIC_MAX) &amp;&amp; (_VARIADIC_MAX &lt; 12))
8881          static_assert(0, &quot;Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.&quot;);
8882          #endif
8883      }
8884  	typedef Event result_type;
8885  	typedef Event type_(
8886  		const EnqueueArgs&amp;,
8887  		T0,
8888  		T1,
8889  		T2,
8890  		T3,
8891  		T4,
8892  		T5,
8893  		T6,
8894  		T7,
8895  		T8,
8896  		T9,
8897  		T10,
8898  		T11);
8899  	Event operator()(
8900  		const EnqueueArgs&amp; enqueueArgs,
8901  		T0 arg0,
8902  		T1 arg1,
8903  		T2 arg2,
8904  		T3 arg3,
8905  		T4 arg4,
8906  		T5 arg5,
8907  		T6 arg6,
8908  		T7 arg7,
8909  		T8 arg8,
8910  		T9 arg9,
8911  		T10 arg10,
8912  		T11 arg11)
8913  	{
8914  		return functor_(
8915  			enqueueArgs,
8916  			arg0,
8917  			arg1,
8918  			arg2,
8919  			arg3,
8920  			arg4,
8921  			arg5,
8922  			arg6,
8923  			arg7,
8924  			arg8,
8925  			arg9,
8926  			arg10,
8927  			arg11);
8928  	}
8929  };
8930  template&lt;
8931  	typename T0,
8932  	typename T1,
8933  	typename T2,
8934  	typename T3,
8935  	typename T4,
8936  	typename T5,
8937  	typename T6,
8938  	typename T7,
8939  	typename T8,
8940  	typename T9,
8941  	typename T10&gt;
8942  struct functionImplementation_
8943  &lt;	T0,
8944  	T1,
8945  	T2,
8946  	T3,
8947  	T4,
8948  	T5,
8949  	T6,
8950  	T7,
8951  	T8,
8952  	T9,
8953  	T10,
8954  	NullType,
8955  	NullType,
8956  	NullType,
8957  	NullType,
8958  	NullType,
8959  	NullType,
8960  	NullType,
8961  	NullType,
8962  	NullType,
8963  	NullType,
8964  	NullType,
8965  	NullType,
8966  	NullType,
8967  	NullType,
8968  	NullType,
8969  	NullType,
8970  	NullType,
8971  	NullType,
8972  	NullType,
8973  	NullType,
8974  	NullType&gt;
8975  {
8976  	typedef detail::KernelFunctorGlobal&lt;
8977  		T0,
8978  		T1,
8979  		T2,
8980  		T3,
8981  		T4,
8982  		T5,
8983  		T6,
8984  		T7,
8985  		T8,
8986  		T9,
8987  		T10,
8988  		NullType,
8989  		NullType,
8990  		NullType,
8991  		NullType,
8992  		NullType,
8993  		NullType,
8994  		NullType,
8995  		NullType,
8996  		NullType,
8997  		NullType,
8998  		NullType,
8999  		NullType,
9000  		NullType,
9001  		NullType,
9002  		NullType,
9003  		NullType,
9004  		NullType,
9005  		NullType,
9006  		NullType,
9007  		NullType,
9008  		NullType&gt; FunctorType;
9009      FunctorType functor_;
9010      functionImplementation_(const FunctorType &amp;functor) :
9011          functor_(functor)
9012      {
9013          #if (defined(_WIN32) &amp;&amp; defined(_VARIADIC_MAX) &amp;&amp; (_VARIADIC_MAX &lt; 11))
9014          static_assert(0, &quot;Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.&quot;);
9015          #endif
9016      }
9017  	typedef Event result_type;
9018  	typedef Event type_(
9019  		const EnqueueArgs&amp;,
9020  		T0,
9021  		T1,
9022  		T2,
9023  		T3,
9024  		T4,
9025  		T5,
9026  		T6,
9027  		T7,
9028  		T8,
9029  		T9,
9030  		T10);
9031  	Event operator()(
9032  		const EnqueueArgs&amp; enqueueArgs,
9033  		T0 arg0,
9034  		T1 arg1,
9035  		T2 arg2,
9036  		T3 arg3,
9037  		T4 arg4,
9038  		T5 arg5,
9039  		T6 arg6,
9040  		T7 arg7,
9041  		T8 arg8,
9042  		T9 arg9,
9043  		T10 arg10)
9044  	{
9045  		return functor_(
9046  			enqueueArgs,
9047  			arg0,
9048  			arg1,
9049  			arg2,
9050  			arg3,
9051  			arg4,
9052  			arg5,
9053  			arg6,
9054  			arg7,
9055  			arg8,
9056  			arg9,
9057  			arg10);
9058  	}
9059  };
9060  template&lt;
9061  	typename T0,
9062  	typename T1,
9063  	typename T2,
9064  	typename T3,
9065  	typename T4,
9066  	typename T5,
9067  	typename T6,
9068  	typename T7,
9069  	typename T8,
9070  	typename T9&gt;
9071  struct functionImplementation_
9072  &lt;	T0,
9073  	T1,
9074  	T2,
9075  	T3,
9076  	T4,
9077  	T5,
9078  	T6,
9079  	T7,
9080  	T8,
9081  	T9,
9082  	NullType,
9083  	NullType,
9084  	NullType,
9085  	NullType,
9086  	NullType,
9087  	NullType,
9088  	NullType,
9089  	NullType,
9090  	NullType,
9091  	NullType,
9092  	NullType,
9093  	NullType,
9094  	NullType,
9095  	NullType,
9096  	NullType,
9097  	NullType,
9098  	NullType,
9099  	NullType,
9100  	NullType,
9101  	NullType,
9102  	NullType,
9103  	NullType&gt;
9104  {
9105  	typedef detail::KernelFunctorGlobal&lt;
9106  		T0,
9107  		T1,
9108  		T2,
9109  		T3,
9110  		T4,
9111  		T5,
9112  		T6,
9113  		T7,
9114  		T8,
9115  		T9,
9116  		NullType,
9117  		NullType,
9118  		NullType,
9119  		NullType,
9120  		NullType,
9121  		NullType,
9122  		NullType,
9123  		NullType,
9124  		NullType,
9125  		NullType,
9126  		NullType,
9127  		NullType,
9128  		NullType,
9129  		NullType,
9130  		NullType,
9131  		NullType,
9132  		NullType,
9133  		NullType,
9134  		NullType,
9135  		NullType,
9136  		NullType,
9137  		NullType&gt; FunctorType;
9138      FunctorType functor_;
9139      functionImplementation_(const FunctorType &amp;functor) :
9140          functor_(functor)
9141      {
9142          #if (defined(_WIN32) &amp;&amp; defined(_VARIADIC_MAX) &amp;&amp; (_VARIADIC_MAX &lt; 10))
9143          static_assert(0, &quot;Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.&quot;);
9144          #endif
9145      }
9146  	typedef Event result_type;
9147  	typedef Event type_(
9148  		const EnqueueArgs&amp;,
9149  		T0,
9150  		T1,
9151  		T2,
9152  		T3,
9153  		T4,
9154  		T5,
9155  		T6,
9156  		T7,
9157  		T8,
9158  		T9);
9159  	Event operator()(
9160  		const EnqueueArgs&amp; enqueueArgs,
9161  		T0 arg0,
9162  		T1 arg1,
9163  		T2 arg2,
9164  		T3 arg3,
9165  		T4 arg4,
9166  		T5 arg5,
9167  		T6 arg6,
9168  		T7 arg7,
9169  		T8 arg8,
9170  		T9 arg9)
9171  	{
9172  		return functor_(
9173  			enqueueArgs,
9174  			arg0,
9175  			arg1,
9176  			arg2,
9177  			arg3,
9178  			arg4,
9179  			arg5,
9180  			arg6,
9181  			arg7,
9182  			arg8,
9183  			arg9);
9184  	}
9185  };
9186  template&lt;
9187  	typename T0,
9188  	typename T1,
9189  	typename T2,
9190  	typename T3,
9191  	typename T4,
9192  	typename T5,
9193  	typename T6,
9194  	typename T7,
9195  	typename T8&gt;
9196  struct functionImplementation_
9197  &lt;	T0,
9198  	T1,
9199  	T2,
9200  	T3,
9201  	T4,
9202  	T5,
9203  	T6,
9204  	T7,
9205  	T8,
9206  	NullType,
9207  	NullType,
9208  	NullType,
9209  	NullType,
9210  	NullType,
9211  	NullType,
9212  	NullType,
9213  	NullType,
9214  	NullType,
9215  	NullType,
9216  	NullType,
9217  	NullType,
9218  	NullType,
9219  	NullType,
9220  	NullType,
9221  	NullType,
9222  	NullType,
9223  	NullType,
9224  	NullType,
9225  	NullType,
9226  	NullType,
9227  	NullType,
9228  	NullType&gt;
9229  {
9230  	typedef detail::KernelFunctorGlobal&lt;
9231  		T0,
9232  		T1,
9233  		T2,
9234  		T3,
9235  		T4,
9236  		T5,
9237  		T6,
9238  		T7,
9239  		T8,
9240  		NullType,
9241  		NullType,
9242  		NullType,
9243  		NullType,
9244  		NullType,
9245  		NullType,
9246  		NullType,
9247  		NullType,
9248  		NullType,
9249  		NullType,
9250  		NullType,
9251  		NullType,
9252  		NullType,
9253  		NullType,
9254  		NullType,
9255  		NullType,
9256  		NullType,
9257  		NullType,
9258  		NullType,
9259  		NullType,
9260  		NullType,
9261  		NullType,
9262  		NullType&gt; FunctorType;
9263      FunctorType functor_;
9264      functionImplementation_(const FunctorType &amp;functor) :
9265          functor_(functor)
9266      {
9267          #if (defined(_WIN32) &amp;&amp; defined(_VARIADIC_MAX) &amp;&amp; (_VARIADIC_MAX &lt; 9))
9268          static_assert(0, &quot;Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.&quot;);
9269          #endif
9270      }
9271  	typedef Event result_type;
9272  	typedef Event type_(
9273  		const EnqueueArgs&amp;,
9274  		T0,
9275  		T1,
9276  		T2,
9277  		T3,
9278  		T4,
9279  		T5,
9280  		T6,
9281  		T7,
9282  		T8);
9283  	Event operator()(
9284  		const EnqueueArgs&amp; enqueueArgs,
9285  		T0 arg0,
9286  		T1 arg1,
9287  		T2 arg2,
9288  		T3 arg3,
9289  		T4 arg4,
9290  		T5 arg5,
9291  		T6 arg6,
9292  		T7 arg7,
9293  		T8 arg8)
9294  	{
9295  		return functor_(
9296  			enqueueArgs,
9297  			arg0,
9298  			arg1,
9299  			arg2,
9300  			arg3,
9301  			arg4,
9302  			arg5,
9303  			arg6,
9304  			arg7,
9305  			arg8);
9306  	}
9307  };
9308  template&lt;
9309  	typename T0,
9310  	typename T1,
9311  	typename T2,
9312  	typename T3,
9313  	typename T4,
9314  	typename T5,
9315  	typename T6,
9316  	typename T7&gt;
9317  struct functionImplementation_
9318  &lt;	T0,
9319  	T1,
9320  	T2,
9321  	T3,
9322  	T4,
9323  	T5,
9324  	T6,
9325  	T7,
9326  	NullType,
9327  	NullType,
9328  	NullType,
9329  	NullType,
9330  	NullType,
9331  	NullType,
9332  	NullType,
9333  	NullType,
9334  	NullType,
9335  	NullType,
9336  	NullType,
9337  	NullType,
9338  	NullType,
9339  	NullType,
9340  	NullType,
9341  	NullType,
9342  	NullType,
9343  	NullType,
9344  	NullType,
9345  	NullType,
9346  	NullType,
9347  	NullType,
9348  	NullType,
9349  	NullType&gt;
9350  {
9351  	typedef detail::KernelFunctorGlobal&lt;
9352  		T0,
9353  		T1,
9354  		T2,
9355  		T3,
9356  		T4,
9357  		T5,
9358  		T6,
9359  		T7,
9360  		NullType,
9361  		NullType,
9362  		NullType,
9363  		NullType,
9364  		NullType,
9365  		NullType,
9366  		NullType,
9367  		NullType,
9368  		NullType,
9369  		NullType,
9370  		NullType,
9371  		NullType,
9372  		NullType,
9373  		NullType,
9374  		NullType,
9375  		NullType,
9376  		NullType,
9377  		NullType,
9378  		NullType,
9379  		NullType,
9380  		NullType,
9381  		NullType,
9382  		NullType,
9383  		NullType&gt; FunctorType;
9384      FunctorType functor_;
9385      functionImplementation_(const FunctorType &amp;functor) :
9386          functor_(functor)
9387      {
9388          #if (defined(_WIN32) &amp;&amp; defined(_VARIADIC_MAX) &amp;&amp; (_VARIADIC_MAX &lt; 8))
9389          static_assert(0, &quot;Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.&quot;);
9390          #endif
9391      }
9392  	typedef Event result_type;
9393  	typedef Event type_(
9394  		const EnqueueArgs&amp;,
9395  		T0,
9396  		T1,
9397  		T2,
9398  		T3,
9399  		T4,
9400  		T5,
9401  		T6,
9402  		T7);
9403  	Event operator()(
9404  		const EnqueueArgs&amp; enqueueArgs,
9405  		T0 arg0,
9406  		T1 arg1,
9407  		T2 arg2,
9408  		T3 arg3,
9409  		T4 arg4,
9410  		T5 arg5,
9411  		T6 arg6,
9412  		T7 arg7)
9413  	{
9414  		return functor_(
9415  			enqueueArgs,
9416  			arg0,
9417  			arg1,
9418  			arg2,
9419  			arg3,
9420  			arg4,
9421  			arg5,
9422  			arg6,
9423  			arg7);
9424  	}
9425  };
9426  template&lt;
9427  	typename T0,
9428  	typename T1,
9429  	typename T2,
9430  	typename T3,
9431  	typename T4,
9432  	typename T5,
9433  	typename T6&gt;
9434  struct functionImplementation_
9435  &lt;	T0,
9436  	T1,
9437  	T2,
9438  	T3,
9439  	T4,
9440  	T5,
9441  	T6,
9442  	NullType,
9443  	NullType,
9444  	NullType,
9445  	NullType,
9446  	NullType,
9447  	NullType,
9448  	NullType,
9449  	NullType,
9450  	NullType,
9451  	NullType,
9452  	NullType,
9453  	NullType,
9454  	NullType,
9455  	NullType,
9456  	NullType,
9457  	NullType,
9458  	NullType,
9459  	NullType,
9460  	NullType,
9461  	NullType,
9462  	NullType,
9463  	NullType,
9464  	NullType,
9465  	NullType,
9466  	NullType&gt;
9467  {
9468  	typedef detail::KernelFunctorGlobal&lt;
9469  		T0,
9470  		T1,
9471  		T2,
9472  		T3,
9473  		T4,
9474  		T5,
9475  		T6,
9476  		NullType,
9477  		NullType,
9478  		NullType,
9479  		NullType,
9480  		NullType,
9481  		NullType,
9482  		NullType,
9483  		NullType,
9484  		NullType,
9485  		NullType,
9486  		NullType,
9487  		NullType,
9488  		NullType,
9489  		NullType,
9490  		NullType,
9491  		NullType,
9492  		NullType,
9493  		NullType,
9494  		NullType,
9495  		NullType,
9496  		NullType,
9497  		NullType,
9498  		NullType,
9499  		NullType,
9500  		NullType&gt; FunctorType;
9501      FunctorType functor_;
9502      functionImplementation_(const FunctorType &amp;functor) :
9503          functor_(functor)
9504      {
9505          #if (defined(_WIN32) &amp;&amp; defined(_VARIADIC_MAX) &amp;&amp; (_VARIADIC_MAX &lt; 7))
9506          static_assert(0, &quot;Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.&quot;);
9507          #endif
9508      }
9509  	typedef Event result_type;
9510  	typedef Event type_(
9511  		const EnqueueArgs&amp;,
9512  		T0,
9513  		T1,
9514  		T2,
9515  		T3,
9516  		T4,
9517  		T5,
9518  		T6);
9519  	Event operator()(
9520  		const EnqueueArgs&amp; enqueueArgs,
9521  		T0 arg0,
9522  		T1 arg1,
9523  		T2 arg2,
9524  		T3 arg3,
9525  		T4 arg4,
9526  		T5 arg5,
9527  		T6 arg6)
9528  	{
9529  		return functor_(
9530  			enqueueArgs,
9531  			arg0,
9532  			arg1,
9533  			arg2,
9534  			arg3,
9535  			arg4,
9536  			arg5,
9537  			arg6);
9538  	}
9539  };
9540  template&lt;
9541  	typename T0,
9542  	typename T1,
9543  	typename T2,
9544  	typename T3,
9545  	typename T4,
9546  	typename T5&gt;
9547  struct functionImplementation_
9548  &lt;	T0,
9549  	T1,
9550  	T2,
9551  	T3,
9552  	T4,
9553  	T5,
9554  	NullType,
9555  	NullType,
9556  	NullType,
9557  	NullType,
9558  	NullType,
9559  	NullType,
9560  	NullType,
9561  	NullType,
9562  	NullType,
9563  	NullType,
9564  	NullType,
9565  	NullType,
9566  	NullType,
9567  	NullType,
9568  	NullType,
9569  	NullType,
9570  	NullType,
9571  	NullType,
9572  	NullType,
9573  	NullType,
9574  	NullType,
9575  	NullType,
9576  	NullType,
9577  	NullType,
9578  	NullType,
9579  	NullType&gt;
9580  {
9581  	typedef detail::KernelFunctorGlobal&lt;
9582  		T0,
9583  		T1,
9584  		T2,
9585  		T3,
9586  		T4,
9587  		T5,
9588  		NullType,
9589  		NullType,
9590  		NullType,
9591  		NullType,
9592  		NullType,
9593  		NullType,
9594  		NullType,
9595  		NullType,
9596  		NullType,
9597  		NullType,
9598  		NullType,
9599  		NullType,
9600  		NullType,
9601  		NullType,
9602  		NullType,
9603  		NullType,
9604  		NullType,
9605  		NullType,
9606  		NullType,
9607  		NullType,
9608  		NullType,
9609  		NullType,
9610  		NullType,
9611  		NullType,
9612  		NullType,
9613  		NullType&gt; FunctorType;
9614      FunctorType functor_;
9615      functionImplementation_(const FunctorType &amp;functor) :
9616          functor_(functor)
9617      {
9618          #if (defined(_WIN32) &amp;&amp; defined(_VARIADIC_MAX) &amp;&amp; (_VARIADIC_MAX &lt; 6))
9619          static_assert(0, &quot;Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.&quot;);
9620          #endif
9621      }
9622  	typedef Event result_type;
9623  	typedef Event type_(
9624  		const EnqueueArgs&amp;,
9625  		T0,
9626  		T1,
9627  		T2,
9628  		T3,
9629  		T4,
9630  		T5);
9631  	Event operator()(
9632  		const EnqueueArgs&amp; enqueueArgs,
9633  		T0 arg0,
9634  		T1 arg1,
9635  		T2 arg2,
9636  		T3 arg3,
9637  		T4 arg4,
9638  		T5 arg5)
9639  	{
9640  		return functor_(
9641  			enqueueArgs,
9642  			arg0,
9643  			arg1,
9644  			arg2,
9645  			arg3,
9646  			arg4,
9647  			arg5);
9648  	}
9649  };
9650  template&lt;
9651  	typename T0,
9652  	typename T1,
9653  	typename T2,
9654  	typename T3,
9655  	typename T4&gt;
9656  struct functionImplementation_
9657  &lt;	T0,
9658  	T1,
9659  	T2,
9660  	T3,
9661  	T4,
9662  	NullType,
9663  	NullType,
9664  	NullType,
9665  	NullType,
9666  	NullType,
9667  	NullType,
9668  	NullType,
9669  	NullType,
9670  	NullType,
9671  	NullType,
9672  	NullType,
9673  	NullType,
9674  	NullType,
9675  	NullType,
9676  	NullType,
9677  	NullType,
9678  	NullType,
9679  	NullType,
9680  	NullType,
9681  	NullType,
9682  	NullType,
9683  	NullType,
9684  	NullType,
9685  	NullType,
9686  	NullType,
9687  	NullType,
9688  	NullType&gt;
9689  {
9690  	typedef detail::KernelFunctorGlobal&lt;
9691  		T0,
9692  		T1,
9693  		T2,
9694  		T3,
9695  		T4,
9696  		NullType,
9697  		NullType,
9698  		NullType,
9699  		NullType,
9700  		NullType,
9701  		NullType,
9702  		NullType,
9703  		NullType,
9704  		NullType,
9705  		NullType,
9706  		NullType,
9707  		NullType,
9708  		NullType,
9709  		NullType,
9710  		NullType,
9711  		NullType,
9712  		NullType,
9713  		NullType,
9714  		NullType,
9715  		NullType,
9716  		NullType,
9717  		NullType,
9718  		NullType,
9719  		NullType,
9720  		NullType,
9721  		NullType,
9722  		NullType&gt; FunctorType;
9723      FunctorType functor_;
9724      functionImplementation_(const FunctorType &amp;functor) :
9725          functor_(functor)
9726      {
9727          #if (defined(_WIN32) &amp;&amp; defined(_VARIADIC_MAX) &amp;&amp; (_VARIADIC_MAX &lt; 5))
9728          static_assert(0, &quot;Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.&quot;);
9729          #endif
9730      }
9731  	typedef Event result_type;
9732  	typedef Event type_(
9733  		const EnqueueArgs&amp;,
9734  		T0,
9735  		T1,
9736  		T2,
9737  		T3,
9738  		T4);
9739  	Event operator()(
9740  		const EnqueueArgs&amp; enqueueArgs,
9741  		T0 arg0,
9742  		T1 arg1,
9743  		T2 arg2,
9744  		T3 arg3,
9745  		T4 arg4)
9746  	{
9747  		return functor_(
9748  			enqueueArgs,
9749  			arg0,
9750  			arg1,
9751  			arg2,
9752  			arg3,
9753  			arg4);
9754  	}
9755  };
9756  template&lt;
9757  	typename T0,
9758  	typename T1,
9759  	typename T2,
9760  	typename T3&gt;
9761  struct functionImplementation_
9762  &lt;	T0,
9763  	T1,
9764  	T2,
9765  	T3,
9766  	NullType,
9767  	NullType,
9768  	NullType,
9769  	NullType,
9770  	NullType,
9771  	NullType,
9772  	NullType,
9773  	NullType,
9774  	NullType,
9775  	NullType,
9776  	NullType,
9777  	NullType,
9778  	NullType,
9779  	NullType,
9780  	NullType,
9781  	NullType,
9782  	NullType,
9783  	NullType,
9784  	NullType,
9785  	NullType,
9786  	NullType,
9787  	NullType,
9788  	NullType,
9789  	NullType,
9790  	NullType,
9791  	NullType,
9792  	NullType,
9793  	NullType&gt;
9794  {
9795  	typedef detail::KernelFunctorGlobal&lt;
9796  		T0,
9797  		T1,
9798  		T2,
9799  		T3,
9800  		NullType,
9801  		NullType,
9802  		NullType,
9803  		NullType,
9804  		NullType,
9805  		NullType,
9806  		NullType,
9807  		NullType,
9808  		NullType,
9809  		NullType,
9810  		NullType,
9811  		NullType,
9812  		NullType,
9813  		NullType,
9814  		NullType,
9815  		NullType,
9816  		NullType,
9817  		NullType,
9818  		NullType,
9819  		NullType,
9820  		NullType,
9821  		NullType,
9822  		NullType,
9823  		NullType,
9824  		NullType,
9825  		NullType,
9826  		NullType,
9827  		NullType&gt; FunctorType;
9828      FunctorType functor_;
9829      functionImplementation_(const FunctorType &amp;functor) :
9830          functor_(functor)
9831      {
9832          #if (defined(_WIN32) &amp;&amp; defined(_VARIADIC_MAX) &amp;&amp; (_VARIADIC_MAX &lt; 4))
9833          static_assert(0, &quot;Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.&quot;);
9834          #endif
9835      }
9836  	typedef Event result_type;
9837  	typedef Event type_(
9838  		const EnqueueArgs&amp;,
9839  		T0,
9840  		T1,
9841  		T2,
9842  		T3);
9843  	Event operator()(
9844  		const EnqueueArgs&amp; enqueueArgs,
9845  		T0 arg0,
9846  		T1 arg1,
9847  		T2 arg2,
9848  		T3 arg3)
9849  	{
9850  		return functor_(
9851  			enqueueArgs,
9852  			arg0,
9853  			arg1,
9854  			arg2,
9855  			arg3);
9856  	}
9857  };
9858  template&lt;
9859  	typename T0,
9860  	typename T1,
9861  	typename T2&gt;
9862  struct functionImplementation_
9863  &lt;	T0,
9864  	T1,
9865  	T2,
9866  	NullType,
9867  	NullType,
9868  	NullType,
9869  	NullType,
9870  	NullType,
9871  	NullType,
9872  	NullType,
9873  	NullType,
9874  	NullType,
9875  	NullType,
9876  	NullType,
9877  	NullType,
9878  	NullType,
9879  	NullType,
9880  	NullType,
9881  	NullType,
9882  	NullType,
9883  	NullType,
9884  	NullType,
9885  	NullType,
9886  	NullType,
9887  	NullType,
9888  	NullType,
9889  	NullType,
9890  	NullType,
9891  	NullType,
9892  	NullType,
9893  	NullType,
9894  	NullType&gt;
9895  {
9896  	typedef detail::KernelFunctorGlobal&lt;
9897  		T0,
9898  		T1,
9899  		T2,
9900  		NullType,
9901  		NullType,
9902  		NullType,
9903  		NullType,
9904  		NullType,
9905  		NullType,
9906  		NullType,
9907  		NullType,
9908  		NullType,
9909  		NullType,
9910  		NullType,
9911  		NullType,
9912  		NullType,
9913  		NullType,
9914  		NullType,
9915  		NullType,
9916  		NullType,
9917  		NullType,
9918  		NullType,
9919  		NullType,
9920  		NullType,
9921  		NullType,
9922  		NullType,
9923  		NullType,
9924  		NullType,
9925  		NullType,
9926  		NullType,
9927  		NullType,
9928  		NullType&gt; FunctorType;
9929      FunctorType functor_;
9930      functionImplementation_(const FunctorType &amp;functor) :
9931          functor_(functor)
9932      {
9933          #if (defined(_WIN32) &amp;&amp; defined(_VARIADIC_MAX) &amp;&amp; (_VARIADIC_MAX &lt; 3))
9934          static_assert(0, &quot;Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.&quot;);
9935          #endif
9936      }
9937  	typedef Event result_type;
9938  	typedef Event type_(
9939  		const EnqueueArgs&amp;,
9940  		T0,
9941  		T1,
9942  		T2);
9943  	Event operator()(
9944  		const EnqueueArgs&amp; enqueueArgs,
9945  		T0 arg0,
9946  		T1 arg1,
9947  		T2 arg2)
9948  	{
9949  		return functor_(
9950  			enqueueArgs,
9951  			arg0,
9952  			arg1,
9953  			arg2);
9954  	}
9955  };
9956  template&lt;
9957  	typename T0,
9958  	typename T1&gt;
9959  struct functionImplementation_
9960  &lt;	T0,
9961  	T1,
9962  	NullType,
9963  	NullType,
9964  	NullType,
9965  	NullType,
9966  	NullType,
9967  	NullType,
9968  	NullType,
9969  	NullType,
9970  	NullType,
9971  	NullType,
9972  	NullType,
9973  	NullType,
9974  	NullType,
9975  	NullType,
9976  	NullType,
9977  	NullType,
9978  	NullType,
9979  	NullType,
9980  	NullType,
9981  	NullType,
9982  	NullType,
9983  	NullType,
9984  	NullType,
9985  	NullType,
9986  	NullType,
9987  	NullType,
9988  	NullType,
9989  	NullType,
9990  	NullType,
9991  	NullType&gt;
9992  {
9993  	typedef detail::KernelFunctorGlobal&lt;
9994  		T0,
9995  		T1,
9996  		NullType,
9997  		NullType,
9998  		NullType,
9999  		NullType,
10000  		NullType,
10001  		NullType,
10002  		NullType,
10003  		NullType,
10004  		NullType,
10005  		NullType,
10006  		NullType,
10007  		NullType,
10008  		NullType,
10009  		NullType,
10010  		NullType,
10011  		NullType,
10012  		NullType,
10013  		NullType,
10014  		NullType,
10015  		NullType,
10016  		NullType,
10017  		NullType,
10018  		NullType,
10019  		NullType,
10020  		NullType,
10021  		NullType,
10022  		NullType,
10023  		NullType,
10024  		NullType,
10025  		NullType&gt; FunctorType;
10026      FunctorType functor_;
10027      functionImplementation_(const FunctorType &amp;functor) :
10028          functor_(functor)
10029      {
10030          #if (defined(_WIN32) &amp;&amp; defined(_VARIADIC_MAX) &amp;&amp; (_VARIADIC_MAX &lt; 2))
10031          static_assert(0, &quot;Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.&quot;);
10032          #endif
10033      }
10034  	typedef Event result_type;
10035  	typedef Event type_(
10036  		const EnqueueArgs&amp;,
10037  		T0,
10038  		T1);
10039  	Event operator()(
10040  		const EnqueueArgs&amp; enqueueArgs,
10041  		T0 arg0,
10042  		T1 arg1)
10043  	{
10044  		return functor_(
10045  			enqueueArgs,
10046  			arg0,
10047  			arg1);
10048  	}
10049  };
10050  template&lt;
10051  	typename T0&gt;
10052  struct functionImplementation_
10053  &lt;	T0,
10054  	NullType,
10055  	NullType,
10056  	NullType,
10057  	NullType,
10058  	NullType,
10059  	NullType,
10060  	NullType,
10061  	NullType,
10062  	NullType,
10063  	NullType,
10064  	NullType,
10065  	NullType,
10066  	NullType,
10067  	NullType,
10068  	NullType,
10069  	NullType,
10070  	NullType,
10071  	NullType,
10072  	NullType,
10073  	NullType,
10074  	NullType,
10075  	NullType,
10076  	NullType,
10077  	NullType,
10078  	NullType,
10079  	NullType,
10080  	NullType,
10081  	NullType,
10082  	NullType,
10083  	NullType,
10084  	NullType&gt;
10085  {
10086  	typedef detail::KernelFunctorGlobal&lt;
10087  		T0,
10088  		NullType,
10089  		NullType,
10090  		NullType,
10091  		NullType,
10092  		NullType,
10093  		NullType,
10094  		NullType,
10095  		NullType,
10096  		NullType,
10097  		NullType,
10098  		NullType,
10099  		NullType,
10100  		NullType,
10101  		NullType,
10102  		NullType,
10103  		NullType,
10104  		NullType,
10105  		NullType,
10106  		NullType,
10107  		NullType,
10108  		NullType,
10109  		NullType,
10110  		NullType,
10111  		NullType,
10112  		NullType,
10113  		NullType,
10114  		NullType,
10115  		NullType,
10116  		NullType,
10117  		NullType,
10118  		NullType&gt; FunctorType;
10119      FunctorType functor_;
10120      functionImplementation_(const FunctorType &amp;functor) :
10121          functor_(functor)
10122      {
10123          #if (defined(_WIN32) &amp;&amp; defined(_VARIADIC_MAX) &amp;&amp; (_VARIADIC_MAX &lt; 1))
10124          static_assert(0, &quot;Visual Studio has a hard limit of argument count for a std::function expansion. Please define _VARIADIC_MAX to be 10. If you need more arguments than that VC12 and below cannot support it.&quot;);
10125          #endif
10126      }
10127  	typedef Event result_type;
10128  	typedef Event type_(
10129  		const EnqueueArgs&amp;,
10130  		T0);
10131  	Event operator()(
10132  		const EnqueueArgs&amp; enqueueArgs,
10133  		T0 arg0)
10134  	{
10135  		return functor_(
10136  			enqueueArgs,
10137  			arg0);
10138  	}
10139  };
10140  } 
10141  template &lt;
10142     typename T0,   typename T1 = detail::NullType,   typename T2 = detail::NullType,
10143     typename T3 = detail::NullType,   typename T4 = detail::NullType,
10144     typename T5 = detail::NullType,   typename T6 = detail::NullType,
10145     typename T7 = detail::NullType,   typename T8 = detail::NullType,
10146     typename T9 = detail::NullType,   typename T10 = detail::NullType,
10147     typename T11 = detail::NullType,   typename T12 = detail::NullType,
10148     typename T13 = detail::NullType,   typename T14 = detail::NullType,
10149     typename T15 = detail::NullType,   typename T16 = detail::NullType,
10150     typename T17 = detail::NullType,   typename T18 = detail::NullType,
10151     typename T19 = detail::NullType,   typename T20 = detail::NullType,
10152     typename T21 = detail::NullType,   typename T22 = detail::NullType,
10153     typename T23 = detail::NullType,   typename T24 = detail::NullType,
10154     typename T25 = detail::NullType,   typename T26 = detail::NullType,
10155     typename T27 = detail::NullType,   typename T28 = detail::NullType,
10156     typename T29 = detail::NullType,   typename T30 = detail::NullType,
10157     typename T31 = detail::NullType
10158  &gt;
10159  struct make_kernel :
10160      public detail::functionImplementation_&lt;
10161                 T0,   T1,   T2,   T3,
10162                 T4,   T5,   T6,   T7,
10163                 T8,   T9,   T10,   T11,
10164                 T12,   T13,   T14,   T15,
10165                 T16,   T17,   T18,   T19,
10166                 T20,   T21,   T22,   T23,
10167                 T24,   T25,   T26,   T27,
10168                 T28,   T29,   T30,   T31
10169      &gt;
10170  {
10171  public:
10172      typedef detail::KernelFunctorGlobal&lt;             
10173                 T0,   T1,   T2,   T3,
10174                 T4,   T5,   T6,   T7,
10175                 T8,   T9,   T10,   T11,
10176                 T12,   T13,   T14,   T15,
10177                 T16,   T17,   T18,   T19,
10178                 T20,   T21,   T22,   T23,
10179                 T24,   T25,   T26,   T27,
10180                 T28,   T29,   T30,   T31
10181      &gt; FunctorType;
10182      make_kernel(
10183          const Program&amp; program,
10184          const STRING_CLASS name,
10185          cl_int * err = NULL) :
10186             detail::functionImplementation_&lt;
10187                      T0,   T1,   T2,   T3,
10188                         T4,   T5,   T6,   T7,
10189                         T8,   T9,   T10,   T11,
10190                         T12,   T13,   T14,   T15,
10191                         T16,   T17,   T18,   T19,
10192                         T20,   T21,   T22,   T23,
10193                         T24,   T25,   T26,   T27,
10194                         T28,   T29,   T30,   T31
10195             &gt;(
10196              FunctorType(program, name, err)) 
10197      {}
10198      make_kernel(
10199          const Kernel kernel) :
10200             detail::functionImplementation_&lt;
10201                      T0,   T1,   T2,   T3,
10202                         T4,   T5,   T6,   T7,
10203                         T8,   T9,   T10,   T11,
10204                         T12,   T13,   T14,   T15,
10205                         T16,   T17,   T18,   T19,
10206                         T20,   T21,   T22,   T23,
10207                         T24,   T25,   T26,   T27,
10208                         T28,   T29,   T30,   T31
10209             &gt;(
10210              FunctorType(kernel)) 
10211      {}    
10212  };
10213  #undef __ERR_STR
10214  #if !defined(__CL_USER_OVERRIDE_ERROR_STRINGS)
10215  #undef __GET_DEVICE_INFO_ERR
10216  #undef __GET_PLATFORM_INFO_ERR
10217  #undef __GET_DEVICE_IDS_ERR
10218  #undef __GET_CONTEXT_INFO_ERR
10219  #undef __GET_EVENT_INFO_ERR
10220  #undef __GET_EVENT_PROFILE_INFO_ERR
10221  #undef __GET_MEM_OBJECT_INFO_ERR
10222  #undef __GET_IMAGE_INFO_ERR
10223  #undef __GET_SAMPLER_INFO_ERR
10224  #undef __GET_KERNEL_INFO_ERR
10225  #undef __GET_KERNEL_ARG_INFO_ERR
10226  #undef __GET_KERNEL_WORK_GROUP_INFO_ERR
10227  #undef __GET_PROGRAM_INFO_ERR
10228  #undef __GET_PROGRAM_BUILD_INFO_ERR
10229  #undef __GET_COMMAND_QUEUE_INFO_ERR
10230  #undef __CREATE_CONTEXT_ERR
10231  #undef __CREATE_CONTEXT_FROM_TYPE_ERR
10232  #undef __GET_SUPPORTED_IMAGE_FORMATS_ERR
10233  #undef __CREATE_BUFFER_ERR
10234  #undef __CREATE_SUBBUFFER_ERR
10235  #undef __CREATE_IMAGE2D_ERR
10236  #undef __CREATE_IMAGE3D_ERR
10237  #undef __CREATE_SAMPLER_ERR
10238  #undef __SET_MEM_OBJECT_DESTRUCTOR_CALLBACK_ERR
10239  #undef __CREATE_USER_EVENT_ERR
10240  #undef __SET_USER_EVENT_STATUS_ERR
10241  #undef __SET_EVENT_CALLBACK_ERR
10242  #undef __SET_PRINTF_CALLBACK_ERR
10243  #undef __WAIT_FOR_EVENTS_ERR
10244  #undef __CREATE_KERNEL_ERR
10245  #undef __SET_KERNEL_ARGS_ERR
10246  #undef __CREATE_PROGRAM_WITH_SOURCE_ERR
10247  #undef __CREATE_PROGRAM_WITH_BINARY_ERR
10248  #undef __CREATE_PROGRAM_WITH_BUILT_IN_KERNELS_ERR
10249  #undef __BUILD_PROGRAM_ERR
10250  #undef __CREATE_KERNELS_IN_PROGRAM_ERR
10251  #undef __CREATE_COMMAND_QUEUE_ERR
10252  #undef __SET_COMMAND_QUEUE_PROPERTY_ERR
10253  #undef __ENQUEUE_READ_BUFFER_ERR
10254  #undef __ENQUEUE_WRITE_BUFFER_ERR
10255  #undef __ENQUEUE_READ_BUFFER_RECT_ERR
10256  #undef __ENQUEUE_WRITE_BUFFER_RECT_ERR
10257  #undef __ENQEUE_COPY_BUFFER_ERR
10258  #undef __ENQEUE_COPY_BUFFER_RECT_ERR
10259  #undef __ENQUEUE_READ_IMAGE_ERR
10260  #undef __ENQUEUE_WRITE_IMAGE_ERR
10261  #undef __ENQUEUE_COPY_IMAGE_ERR
10262  #undef __ENQUEUE_COPY_IMAGE_TO_BUFFER_ERR
10263  #undef __ENQUEUE_COPY_BUFFER_TO_IMAGE_ERR
10264  #undef __ENQUEUE_MAP_BUFFER_ERR
10265  #undef __ENQUEUE_MAP_IMAGE_ERR
10266  #undef __ENQUEUE_UNMAP_MEM_OBJECT_ERR
10267  #undef __ENQUEUE_NDRANGE_KERNEL_ERR
10268  #undef __ENQUEUE_TASK_ERR
10269  #undef __ENQUEUE_NATIVE_KERNEL
10270  #undef __CL_EXPLICIT_CONSTRUCTORS
10271  #undef __UNLOAD_COMPILER_ERR
10272  #endif 
10273  #undef __CL_FUNCTION_TYPE
10274  #if defined(CL_VERSION_1_1)
10275  #undef __INIT_CL_EXT_FCN_PTR
10276  #endif 
10277  #undef __CREATE_SUB_DEVICES
10278  #if defined(USE_CL_DEVICE_FISSION)
10279  #undef __PARAM_NAME_DEVICE_FISSION
10280  #endif 
10281  #undef __DEFAULT_NOT_INITIALIZED 
10282  #undef __DEFAULT_BEING_INITIALIZED 
10283  #undef __DEFAULT_INITIALIZED
10284  #undef CL_HPP_RVALUE_REFERENCES_SUPPORTED
10285  #undef CL_HPP_NOEXCEPT
10286  } 
10287  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-cl2.hpp</h3>
            <pre><code>1  #ifndef CL_HPP_
2  #define CL_HPP_
3  #if !defined(CL_HPP_USE_DX_INTEROP) &amp;&amp; defined(USE_DX_INTEROP)
4  # pragma message(&quot;cl2.hpp: USE_DX_INTEROP is deprecated. Define CL_HPP_USE_DX_INTEROP instead&quot;)
5  # define CL_HPP_USE_DX_INTEROP
6  #endif
7  #if !defined(CL_HPP_USE_CL_DEVICE_FISSION) &amp;&amp; defined(USE_CL_DEVICE_FISSION)
8  # pragma message(&quot;cl2.hpp: USE_CL_DEVICE_FISSION is deprecated. Define CL_HPP_USE_CL_DEVICE_FISSION instead&quot;)
9  # define CL_HPP_USE_CL_DEVICE_FISSION
10  #endif
11  #if !defined(CL_HPP_ENABLE_EXCEPTIONS) &amp;&amp; defined(__CL_ENABLE_EXCEPTIONS)
12  # pragma message(&quot;cl2.hpp: __CL_ENABLE_EXCEPTIONS is deprecated. Define CL_HPP_ENABLE_EXCEPTIONS instead&quot;)
13  # define CL_HPP_ENABLE_EXCEPTIONS
14  #endif
15  #if !defined(CL_HPP_NO_STD_VECTOR) &amp;&amp; defined(__NO_STD_VECTOR)
16  # pragma message(&quot;cl2.hpp: __NO_STD_VECTOR is deprecated. Define CL_HPP_NO_STD_VECTOR instead&quot;)
17  # define CL_HPP_NO_STD_VECTOR
18  #endif
19  #if !defined(CL_HPP_NO_STD_STRING) &amp;&amp; defined(__NO_STD_STRING)
20  # pragma message(&quot;cl2.hpp: __NO_STD_STRING is deprecated. Define CL_HPP_NO_STD_STRING instead&quot;)
21  # define CL_HPP_NO_STD_STRING
22  #endif
23  #if defined(VECTOR_CLASS)
24  # pragma message(&quot;cl2.hpp: VECTOR_CLASS is deprecated. Alias cl::vector instead&quot;)
25  #endif
26  #if defined(STRING_CLASS)
27  # pragma message(&quot;cl2.hpp: STRING_CLASS is deprecated. Alias cl::string instead.&quot;)
28  #endif
29  #if !defined(CL_HPP_USER_OVERRIDE_ERROR_STRINGS) &amp;&amp; defined(__CL_USER_OVERRIDE_ERROR_STRINGS)
30  # pragma message(&quot;cl2.hpp: __CL_USER_OVERRIDE_ERROR_STRINGS is deprecated. Define CL_HPP_USER_OVERRIDE_ERROR_STRINGS instead&quot;)
31  # define CL_HPP_USER_OVERRIDE_ERROR_STRINGS
32  #endif
33  #if defined(__USE_DEV_VECTOR)
34  # pragma message(&quot;cl2.hpp: __USE_DEV_VECTOR is no longer supported. Expect compilation errors&quot;)
35  #endif
36  #if defined(__USE_DEV_STRING)
37  # pragma message(&quot;cl2.hpp: __USE_DEV_STRING is no longer supported. Expect compilation errors&quot;)
38  #endif
39  #if !defined(CL_HPP_TARGET_OPENCL_VERSION)
40  # pragma message(&quot;cl2.hpp: CL_HPP_TARGET_OPENCL_VERSION is not defined. It will default to 200 (OpenCL 2.0)&quot;)
41  # define CL_HPP_TARGET_OPENCL_VERSION 200
42  #endif
43  #if CL_HPP_TARGET_OPENCL_VERSION != 100 &amp;&amp; CL_HPP_TARGET_OPENCL_VERSION != 110 &amp;&amp; CL_HPP_TARGET_OPENCL_VERSION != 120 &amp;&amp; CL_HPP_TARGET_OPENCL_VERSION != 200
44  # pragma message(&quot;cl2.hpp: CL_HPP_TARGET_OPENCL_VERSION is not a valid value (100, 110, 120 or 200). It will be set to 200&quot;)
45  # undef CL_HPP_TARGET_OPENCL_VERSION
46  # define CL_HPP_TARGET_OPENCL_VERSION 200
47  #endif
48  #if !defined(CL_HPP_MINIMUM_OPENCL_VERSION)
49  # define CL_HPP_MINIMUM_OPENCL_VERSION 200
50  #endif
51  #if CL_HPP_MINIMUM_OPENCL_VERSION != 100 &amp;&amp; CL_HPP_MINIMUM_OPENCL_VERSION != 110 &amp;&amp; CL_HPP_MINIMUM_OPENCL_VERSION != 120 &amp;&amp; CL_HPP_MINIMUM_OPENCL_VERSION != 200
52  # pragma message(&quot;cl2.hpp: CL_HPP_MINIMUM_OPENCL_VERSION is not a valid value (100, 110, 120 or 200). It will be set to 100&quot;)
53  # undef CL_HPP_MINIMUM_OPENCL_VERSION
54  # define CL_HPP_MINIMUM_OPENCL_VERSION 100
55  #endif
56  #if CL_HPP_MINIMUM_OPENCL_VERSION &gt; CL_HPP_TARGET_OPENCL_VERSION
57  # error &quot;CL_HPP_MINIMUM_OPENCL_VERSION must not be greater than CL_HPP_TARGET_OPENCL_VERSION&quot;
58  #endif
59  #if CL_HPP_MINIMUM_OPENCL_VERSION &lt;= 100 &amp;&amp; !defined(CL_USE_DEPRECATED_OPENCL_1_0_APIS)
60  # define CL_USE_DEPRECATED_OPENCL_1_0_APIS
61  #endif
62  #if CL_HPP_MINIMUM_OPENCL_VERSION &lt;= 110 &amp;&amp; !defined(CL_USE_DEPRECATED_OPENCL_1_1_APIS)
63  # define CL_USE_DEPRECATED_OPENCL_1_1_APIS
64  #endif
65  #if CL_HPP_MINIMUM_OPENCL_VERSION &lt;= 120 &amp;&amp; !defined(CL_USE_DEPRECATED_OPENCL_1_2_APIS)
66  # define CL_USE_DEPRECATED_OPENCL_1_2_APIS
67  #endif
68  #if CL_HPP_MINIMUM_OPENCL_VERSION &lt;= 200 &amp;&amp; !defined(CL_USE_DEPRECATED_OPENCL_2_0_APIS)
69  # define CL_USE_DEPRECATED_OPENCL_2_0_APIS
70  #endif
71  #ifdef _WIN32
72  #include &lt;malloc.h&gt;
73  #if defined(CL_HPP_USE_DX_INTEROP)
74  #include &lt;CL/cl_d3d10.h&gt;
75  #include &lt;CL/cl_dx9_media_sharing.h&gt;
76  #endif
77  #endif 
78  #if defined(_MSC_VER)
79  #include &lt;intrin.h&gt;
80  #endif 
81  #if (!defined(_MSC_VER) &amp;&amp; __cplusplus &lt; 201103L) || (defined(_MSC_VER) &amp;&amp; _MSC_VER &lt; 1700)
82  #error Visual studio 2013 or another C++11-supporting compiler required
83  #endif
84  #if defined(CL_HPP_USE_CL_DEVICE_FISSION) || defined(CL_HPP_USE_CL_SUB_GROUPS_KHR)
85  #include &lt;CL/cl_ext.h&gt;
86  #endif
87  #if defined(__APPLE__) || defined(__MACOSX)
88  #include &lt;OpenCL/opencl.h&gt;
89  #else
90  #include &lt;CL/opencl.h&gt;
91  #endif 
92  #if (__cplusplus &gt;= 201103L)
93  #define CL_HPP_NOEXCEPT_ noexcept
94  #else
95  #define CL_HPP_NOEXCEPT_
96  #endif
97  #if defined(_MSC_VER)
98  # define CL_HPP_DEFINE_STATIC_MEMBER_ __declspec(selectany)
99  #else
100  # define CL_HPP_DEFINE_STATIC_MEMBER_ __attribute__((weak))
101  #endif 
102  #if !defined(CL_EXT_PREFIX__VERSION_1_1_DEPRECATED)
103  #define CL_EXT_PREFIX__VERSION_1_1_DEPRECATED  
104  #endif 
105  #if !defined(CL_EXT_SUFFIX__VERSION_1_1_DEPRECATED)
106  #define CL_EXT_SUFFIX__VERSION_1_1_DEPRECATED
107  #endif 
108  #if !defined(CL_EXT_PREFIX__VERSION_1_2_DEPRECATED)
109  #define CL_EXT_PREFIX__VERSION_1_2_DEPRECATED  
110  #endif 
111  #if !defined(CL_EXT_SUFFIX__VERSION_1_2_DEPRECATED)
112  #define CL_EXT_SUFFIX__VERSION_1_2_DEPRECATED
113  #endif 
114  #if !defined(CL_CALLBACK)
115  #define CL_CALLBACK
116  #endif 
117  #include &lt;utility&gt;
118  #include &lt;limits&gt;
119  #include &lt;iterator&gt;
120  #include &lt;mutex&gt;
121  #include &lt;cstring&gt;
122  #include &lt;functional&gt;
123  #if defined(CL_HPP_ENABLE_SIZE_T_COMPATIBILITY)
124  namespace cl {
125      using size_type = ::size_t;
126  } 
127  #else 
128  namespace cl {
129      using size_type = size_t;
130  } 
131  #endif 
132  #if defined(CL_HPP_ENABLE_EXCEPTIONS)
133  #include &lt;exception&gt;
134  #endif 
135  #if !defined(CL_HPP_NO_STD_VECTOR)
136  #include &lt;vector&gt;
137  namespace cl {
138      template &lt; class T, class Alloc = std::allocator&lt;T&gt; &gt;
139      using vector = std::vector&lt;T, Alloc&gt;;
140  } 
141  #endif 
142  #if !defined(CL_HPP_NO_STD_STRING)
143  #include &lt;string&gt;
144  namespace cl {
145      using string = std::string;
146  } 
147  #endif 
148  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 200
149  #if !defined(CL_HPP_NO_STD_UNIQUE_PTR)
150  #include &lt;memory&gt;
151  namespace cl {
152      template&lt;class T, class D&gt;
153      using pointer = std::unique_ptr&lt;T, D&gt;;
154  } 
155  #endif 
156  #endif 
157  #if !defined(CL_HPP_NO_STD_ARRAY)
158  #include &lt;array&gt;
159  namespace cl {
160      template &lt; class T, size_type N &gt;
161      using array = std::array&lt;T, N&gt;;
162  } 
163  #endif 
164  #if defined(CL_HPP_ENABLE_SIZE_T_COMPATIBILITY)
165  namespace cl {
166      namespace compatibility {
167          template &lt;int N&gt;
168          class size_t
169          {
170          private:
171              size_type data_[N];
172          public:
173              size_t()
174              {
175                  for (int i = 0; i &lt; N; ++i) {
176                      data_[i] = 0;
177                  }
178              }
179              size_t(const array&lt;size_type, N&gt; &amp;rhs)
180              {
181                  for (int i = 0; i &lt; N; ++i) {
182                      data_[i] = rhs[i];
183                  }
184              }
185              size_type&amp; operator[](int index)
186              {
187                  return data_[index];
188              }
189              const size_type&amp; operator[](int index) const
190              {
191                  return data_[index];
192              }
193              operator size_type* ()             { return data_; }
194              operator const size_type* () const { return data_; }
195              operator array&lt;size_type, N&gt;() const
196              {
197                  array&lt;size_type, N&gt; ret;
198                  for (int i = 0; i &lt; N; ++i) {
199                      ret[i] = data_[i];
200                  }
201                  return ret;
202              }
203          };
204      } 
205      template&lt;int N&gt;
206      using size_t = compatibility::size_t&lt;N&gt;;
207  } 
208  #endif 
209  namespace cl {
210      namespace detail {
211          using size_t_array = array&lt;size_type, 3&gt;;
212      } 
213  } 
214  namespace cl {
215      class Memory;
216  #define CL_HPP_INIT_CL_EXT_FCN_PTR_(name) \
217      if (!pfn_##name) {    \
218      pfn_##name = (PFN_##name) \
219      clGetExtensionFunctionAddress(#name); \
220      if (!pfn_##name) {    \
221      } \
222      }
223  #define CL_HPP_INIT_CL_EXT_FCN_PTR_PLATFORM_(platform, name) \
224      if (!pfn_##name) {    \
225      pfn_##name = (PFN_##name) \
226      clGetExtensionFunctionAddressForPlatform(platform, #name); \
227      if (!pfn_##name) {    \
228      } \
229      }
230      class Program;
231      class Device;
232      class Context;
233      class CommandQueue;
234      class DeviceCommandQueue;
235      class Memory;
236      class Buffer;
237      class Pipe;
238  #if defined(CL_HPP_ENABLE_EXCEPTIONS)
239      class Error : public std::exception
240      {
241      private:
242          cl_int err_;
243          const char * errStr_;
244      public:
245          Error(cl_int err, const char * errStr = NULL) : err_(err), errStr_(errStr)
246          {}
247          ~Error() throw() {}
248          virtual const char * what() const throw ()
249          {
250              if (errStr_ == NULL) {
251                  return &quot;empty&quot;;
252              }
253              else {
254                  return errStr_;
255              }
256          }
257          cl_int err(void) const { return err_; }
258      };
259  #define CL_HPP_ERR_STR_(x) #x
260  #else
261  #define CL_HPP_ERR_STR_(x) NULL
262  #endif 
263  namespace detail
264  {
265  #if defined(CL_HPP_ENABLE_EXCEPTIONS)
266  static inline cl_int errHandler (
267      cl_int err,
268      const char * errStr = NULL)
269  {
270      if (err != CL_SUCCESS) {
271          throw Error(err, errStr);
272      }
273      return err;
274  }
275  #else
276  static inline cl_int errHandler (cl_int err, const char * errStr = NULL)
277  {
278      (void) errStr; 
279      return err;
280  }
281  #endif 
282  }
283  #if !defined(CL_HPP_USER_OVERRIDE_ERROR_STRINGS)
284  #define __GET_DEVICE_INFO_ERR               CL_HPP_ERR_STR_(clGetDeviceInfo)
285  #define __GET_PLATFORM_INFO_ERR             CL_HPP_ERR_STR_(clGetPlatformInfo)
286  #define __GET_DEVICE_IDS_ERR                CL_HPP_ERR_STR_(clGetDeviceIDs)
287  #define __GET_PLATFORM_IDS_ERR              CL_HPP_ERR_STR_(clGetPlatformIDs)
288  #define __GET_CONTEXT_INFO_ERR              CL_HPP_ERR_STR_(clGetContextInfo)
289  #define __GET_EVENT_INFO_ERR                CL_HPP_ERR_STR_(clGetEventInfo)
290  #define __GET_EVENT_PROFILE_INFO_ERR        CL_HPP_ERR_STR_(clGetEventProfileInfo)
291  #define __GET_MEM_OBJECT_INFO_ERR           CL_HPP_ERR_STR_(clGetMemObjectInfo)
292  #define __GET_IMAGE_INFO_ERR                CL_HPP_ERR_STR_(clGetImageInfo)
293  #define __GET_SAMPLER_INFO_ERR              CL_HPP_ERR_STR_(clGetSamplerInfo)
294  #define __GET_KERNEL_INFO_ERR               CL_HPP_ERR_STR_(clGetKernelInfo)
295  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 120
296  #define __GET_KERNEL_ARG_INFO_ERR           CL_HPP_ERR_STR_(clGetKernelArgInfo)
297  #endif 
298  #define __GET_KERNEL_WORK_GROUP_INFO_ERR    CL_HPP_ERR_STR_(clGetKernelWorkGroupInfo)
299  #define __GET_PROGRAM_INFO_ERR              CL_HPP_ERR_STR_(clGetProgramInfo)
300  #define __GET_PROGRAM_BUILD_INFO_ERR        CL_HPP_ERR_STR_(clGetProgramBuildInfo)
301  #define __GET_COMMAND_QUEUE_INFO_ERR        CL_HPP_ERR_STR_(clGetCommandQueueInfo)
302  #define __CREATE_CONTEXT_ERR                CL_HPP_ERR_STR_(clCreateContext)
303  #define __CREATE_CONTEXT_FROM_TYPE_ERR      CL_HPP_ERR_STR_(clCreateContextFromType)
304  #define __GET_SUPPORTED_IMAGE_FORMATS_ERR   CL_HPP_ERR_STR_(clGetSupportedImageFormats)
305  #define __CREATE_BUFFER_ERR                 CL_HPP_ERR_STR_(clCreateBuffer)
306  #define __COPY_ERR                          CL_HPP_ERR_STR_(cl::copy)
307  #define __CREATE_SUBBUFFER_ERR              CL_HPP_ERR_STR_(clCreateSubBuffer)
308  #define __CREATE_GL_BUFFER_ERR              CL_HPP_ERR_STR_(clCreateFromGLBuffer)
309  #define __CREATE_GL_RENDER_BUFFER_ERR       CL_HPP_ERR_STR_(clCreateFromGLBuffer)
310  #define __GET_GL_OBJECT_INFO_ERR            CL_HPP_ERR_STR_(clGetGLObjectInfo)
311  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 120
312  #define __CREATE_IMAGE_ERR                  CL_HPP_ERR_STR_(clCreateImage)
313  #define __CREATE_GL_TEXTURE_ERR             CL_HPP_ERR_STR_(clCreateFromGLTexture)
314  #define __IMAGE_DIMENSION_ERR               CL_HPP_ERR_STR_(Incorrect image dimensions)
315  #endif 
316  #define __SET_MEM_OBJECT_DESTRUCTOR_CALLBACK_ERR CL_HPP_ERR_STR_(clSetMemObjectDestructorCallback)
317  #define __CREATE_USER_EVENT_ERR             CL_HPP_ERR_STR_(clCreateUserEvent)
318  #define __SET_USER_EVENT_STATUS_ERR         CL_HPP_ERR_STR_(clSetUserEventStatus)
319  #define __SET_EVENT_CALLBACK_ERR            CL_HPP_ERR_STR_(clSetEventCallback)
320  #define __WAIT_FOR_EVENTS_ERR               CL_HPP_ERR_STR_(clWaitForEvents)
321  #define __CREATE_KERNEL_ERR                 CL_HPP_ERR_STR_(clCreateKernel)
322  #define __SET_KERNEL_ARGS_ERR               CL_HPP_ERR_STR_(clSetKernelArg)
323  #define __CREATE_PROGRAM_WITH_SOURCE_ERR    CL_HPP_ERR_STR_(clCreateProgramWithSource)
324  #define __CREATE_PROGRAM_WITH_BINARY_ERR    CL_HPP_ERR_STR_(clCreateProgramWithBinary)
325  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 120
326  #define __CREATE_PROGRAM_WITH_BUILT_IN_KERNELS_ERR    CL_HPP_ERR_STR_(clCreateProgramWithBuiltInKernels)
327  #endif 
328  #define __BUILD_PROGRAM_ERR                 CL_HPP_ERR_STR_(clBuildProgram)
329  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 120
330  #define __COMPILE_PROGRAM_ERR               CL_HPP_ERR_STR_(clCompileProgram)
331  #define __LINK_PROGRAM_ERR                  CL_HPP_ERR_STR_(clLinkProgram)
332  #endif 
333  #define __CREATE_KERNELS_IN_PROGRAM_ERR     CL_HPP_ERR_STR_(clCreateKernelsInProgram)
334  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 200
335  #define __CREATE_COMMAND_QUEUE_WITH_PROPERTIES_ERR          CL_HPP_ERR_STR_(clCreateCommandQueueWithProperties)
336  #define __CREATE_SAMPLER_WITH_PROPERTIES_ERR                CL_HPP_ERR_STR_(clCreateSamplerWithProperties)
337  #endif 
338  #define __SET_COMMAND_QUEUE_PROPERTY_ERR    CL_HPP_ERR_STR_(clSetCommandQueueProperty)
339  #define __ENQUEUE_READ_BUFFER_ERR           CL_HPP_ERR_STR_(clEnqueueReadBuffer)
340  #define __ENQUEUE_READ_BUFFER_RECT_ERR      CL_HPP_ERR_STR_(clEnqueueReadBufferRect)
341  #define __ENQUEUE_WRITE_BUFFER_ERR          CL_HPP_ERR_STR_(clEnqueueWriteBuffer)
342  #define __ENQUEUE_WRITE_BUFFER_RECT_ERR     CL_HPP_ERR_STR_(clEnqueueWriteBufferRect)
343  #define __ENQEUE_COPY_BUFFER_ERR            CL_HPP_ERR_STR_(clEnqueueCopyBuffer)
344  #define __ENQEUE_COPY_BUFFER_RECT_ERR       CL_HPP_ERR_STR_(clEnqueueCopyBufferRect)
345  #define __ENQUEUE_FILL_BUFFER_ERR           CL_HPP_ERR_STR_(clEnqueueFillBuffer)
346  #define __ENQUEUE_READ_IMAGE_ERR            CL_HPP_ERR_STR_(clEnqueueReadImage)
347  #define __ENQUEUE_WRITE_IMAGE_ERR           CL_HPP_ERR_STR_(clEnqueueWriteImage)
348  #define __ENQUEUE_COPY_IMAGE_ERR            CL_HPP_ERR_STR_(clEnqueueCopyImage)
349  #define __ENQUEUE_FILL_IMAGE_ERR            CL_HPP_ERR_STR_(clEnqueueFillImage)
350  #define __ENQUEUE_COPY_IMAGE_TO_BUFFER_ERR  CL_HPP_ERR_STR_(clEnqueueCopyImageToBuffer)
351  #define __ENQUEUE_COPY_BUFFER_TO_IMAGE_ERR  CL_HPP_ERR_STR_(clEnqueueCopyBufferToImage)
352  #define __ENQUEUE_MAP_BUFFER_ERR            CL_HPP_ERR_STR_(clEnqueueMapBuffer)
353  #define __ENQUEUE_MAP_IMAGE_ERR             CL_HPP_ERR_STR_(clEnqueueMapImage)
354  #define __ENQUEUE_UNMAP_MEM_OBJECT_ERR      CL_HPP_ERR_STR_(clEnqueueUnMapMemObject)
355  #define __ENQUEUE_NDRANGE_KERNEL_ERR        CL_HPP_ERR_STR_(clEnqueueNDRangeKernel)
356  #define __ENQUEUE_NATIVE_KERNEL             CL_HPP_ERR_STR_(clEnqueueNativeKernel)
357  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 120
358  #define __ENQUEUE_MIGRATE_MEM_OBJECTS_ERR   CL_HPP_ERR_STR_(clEnqueueMigrateMemObjects)
359  #endif 
360  #define __ENQUEUE_ACQUIRE_GL_ERR            CL_HPP_ERR_STR_(clEnqueueAcquireGLObjects)
361  #define __ENQUEUE_RELEASE_GL_ERR            CL_HPP_ERR_STR_(clEnqueueReleaseGLObjects)
362  #define __CREATE_PIPE_ERR             CL_HPP_ERR_STR_(clCreatePipe)
363  #define __GET_PIPE_INFO_ERR           CL_HPP_ERR_STR_(clGetPipeInfo)
364  #define __RETAIN_ERR                        CL_HPP_ERR_STR_(Retain Object)
365  #define __RELEASE_ERR                       CL_HPP_ERR_STR_(Release Object)
366  #define __FLUSH_ERR                         CL_HPP_ERR_STR_(clFlush)
367  #define __FINISH_ERR                        CL_HPP_ERR_STR_(clFinish)
368  #define __VECTOR_CAPACITY_ERR               CL_HPP_ERR_STR_(Vector capacity error)
369  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 120
370  #define __CREATE_SUB_DEVICES_ERR            CL_HPP_ERR_STR_(clCreateSubDevices)
371  #else
372  #define __CREATE_SUB_DEVICES_ERR            CL_HPP_ERR_STR_(clCreateSubDevicesEXT)
373  #endif 
374  #if defined(CL_USE_DEPRECATED_OPENCL_1_1_APIS)
375  #define __ENQUEUE_MARKER_ERR                CL_HPP_ERR_STR_(clEnqueueMarker)
376  #define __ENQUEUE_WAIT_FOR_EVENTS_ERR       CL_HPP_ERR_STR_(clEnqueueWaitForEvents)
377  #define __ENQUEUE_BARRIER_ERR               CL_HPP_ERR_STR_(clEnqueueBarrier)
378  #define __UNLOAD_COMPILER_ERR               CL_HPP_ERR_STR_(clUnloadCompiler)
379  #define __CREATE_GL_TEXTURE_2D_ERR          CL_HPP_ERR_STR_(clCreateFromGLTexture2D)
380  #define __CREATE_GL_TEXTURE_3D_ERR          CL_HPP_ERR_STR_(clCreateFromGLTexture3D)
381  #define __CREATE_IMAGE2D_ERR                CL_HPP_ERR_STR_(clCreateImage2D)
382  #define __CREATE_IMAGE3D_ERR                CL_HPP_ERR_STR_(clCreateImage3D)
383  #endif 
384  #if defined(CL_USE_DEPRECATED_OPENCL_1_2_APIS)
385  #define __CREATE_COMMAND_QUEUE_ERR          CL_HPP_ERR_STR_(clCreateCommandQueue)
386  #define __ENQUEUE_TASK_ERR                  CL_HPP_ERR_STR_(clEnqueueTask)
387  #define __CREATE_SAMPLER_ERR                CL_HPP_ERR_STR_(clCreateSampler)
388  #endif 
389  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 120
390  #define __ENQUEUE_MARKER_WAIT_LIST_ERR                CL_HPP_ERR_STR_(clEnqueueMarkerWithWaitList)
391  #define __ENQUEUE_BARRIER_WAIT_LIST_ERR               CL_HPP_ERR_STR_(clEnqueueBarrierWithWaitList)
392  #endif 
393  #endif 
394  namespace detail {
395  template&lt;typename Functor, typename T&gt;
396  inline cl_int getInfoHelper(Functor f, cl_uint name, T* param, long)
397  {
398      return f(name, sizeof(T), param, NULL);
399  }
400  template &lt;typename Func&gt;
401  inline cl_int getInfoHelper(Func f, cl_uint name, vector&lt;vector&lt;unsigned char&gt;&gt;* param, int)
402  {
403      if (name != CL_PROGRAM_BINARIES) {
404          return CL_INVALID_VALUE;
405      }
406      if (param) {
407          size_type numBinaries = param-&gt;size();
408          vector&lt;unsigned char*&gt; binariesPointers(numBinaries);
409          size_type totalSize = 0;
410          for (size_type i = 0; i &lt; numBinaries; ++i)
411          {
412              binariesPointers[i] = (*param)[i].data();
413              totalSize += (*param)[i].size();
414          }
415          cl_int err = f(name, totalSize, binariesPointers.data(), NULL);
416          if (err != CL_SUCCESS) {
417              return err;
418          }
419      }
420      return CL_SUCCESS;
421  }
422  template &lt;typename Func, typename T&gt;
423  inline cl_int getInfoHelper(Func f, cl_uint name, vector&lt;T&gt;* param, long)
424  {
425      size_type required;
426      cl_int err = f(name, 0, NULL, &amp;required);
427      if (err != CL_SUCCESS) {
428          return err;
429      }
430      const size_type elements = required / sizeof(T);
431      vector&lt;T&gt; localData(elements);
432      err = f(name, required, localData.data(), NULL);
433      if (err != CL_SUCCESS) {
434          return err;
435      }
436      if (param) {
437          *param = std::move(localData);
438      }
439      return CL_SUCCESS;
440  }
441  template &lt;typename Func, typename T&gt;
442  inline cl_int getInfoHelper(
443      Func f, cl_uint name, vector&lt;T&gt;* param, int, typename T::cl_type = 0)
444  {
445      size_type required;
446      cl_int err = f(name, 0, NULL, &amp;required);
447      if (err != CL_SUCCESS) {
448          return err;
449      }
450      const size_type elements = required / sizeof(typename T::cl_type);
451      vector&lt;typename T::cl_type&gt; value(elements);
452      err = f(name, required, value.data(), NULL);
453      if (err != CL_SUCCESS) {
454          return err;
455      }
456      if (param) {
457          param-&gt;resize(elements);
458          for (size_type i = 0; i &lt; elements; i++) {
459              (*param)[i] = T(value[i], true);
460          }
461      }
462      return CL_SUCCESS;
463  }
464  template &lt;typename Func&gt;
465  inline cl_int getInfoHelper(Func f, cl_uint name, string* param, long)
466  {
467      size_type required;
468      cl_int err = f(name, 0, NULL, &amp;required);
469      if (err != CL_SUCCESS) {
470          return err;
471      }
472      if (required &gt; 0) {
473          vector&lt;char&gt; value(required);
474          err = f(name, required, value.data(), NULL);
475          if (err != CL_SUCCESS) {
476              return err;
477          }
478          if (param) {
479              param-&gt;assign(begin(value), prev(end(value)));
480          }
481      }
482      else if (param) {
483          param-&gt;assign(&quot;&quot;);
484      }
485      return CL_SUCCESS;
486  }
487  template &lt;typename Func, size_type N&gt;
488  inline cl_int getInfoHelper(Func f, cl_uint name, array&lt;size_type, N&gt;* param, long)
489  {
490      size_type required;
491      cl_int err = f(name, 0, NULL, &amp;required);
492      if (err != CL_SUCCESS) {
493          return err;
494      }
495      size_type elements = required / sizeof(size_type);
496      vector&lt;size_type&gt; value(elements, 0);
497      err = f(name, required, value.data(), NULL);
498      if (err != CL_SUCCESS) {
499          return err;
500      }
501      if (elements &gt; N) {
502          elements = N;
503      }
504      for (size_type i = 0; i &lt; elements; ++i) {
505          (*param)[i] = value[i];
506      }
507      return CL_SUCCESS;
508  }
509  template&lt;typename T&gt; struct ReferenceHandler;
510  template&lt;typename Func, typename T&gt;
511  inline cl_int getInfoHelper(Func f, cl_uint name, T* param, int, typename T::cl_type = 0)
512  {
513      typename T::cl_type value;
514      cl_int err = f(name, sizeof(value), &amp;value, NULL);
515      if (err != CL_SUCCESS) {
516          return err;
517      }
518      *param = value;
519      if (value != NULL)
520      {
521          err = param-&gt;retain();
522          if (err != CL_SUCCESS) {
523              return err;
524          }
525      }
526      return CL_SUCCESS;
527  }
528  #define CL_HPP_PARAM_NAME_INFO_1_0_(F) \
529      F(cl_platform_info, CL_PLATFORM_PROFILE, string) \
530      F(cl_platform_info, CL_PLATFORM_VERSION, string) \
531      F(cl_platform_info, CL_PLATFORM_NAME, string) \
532      F(cl_platform_info, CL_PLATFORM_VENDOR, string) \
533      F(cl_platform_info, CL_PLATFORM_EXTENSIONS, string) \
534      \
535      F(cl_device_info, CL_DEVICE_TYPE, cl_device_type) \
536      F(cl_device_info, CL_DEVICE_VENDOR_ID, cl_uint) \
537      F(cl_device_info, CL_DEVICE_MAX_COMPUTE_UNITS, cl_uint) \
538      F(cl_device_info, CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS, cl_uint) \
539      F(cl_device_info, CL_DEVICE_MAX_WORK_GROUP_SIZE, size_type) \
540      F(cl_device_info, CL_DEVICE_MAX_WORK_ITEM_SIZES, cl::vector&lt;size_type&gt;) \
541      F(cl_device_info, CL_DEVICE_PREFERRED_VECTOR_WIDTH_CHAR, cl_uint) \
542      F(cl_device_info, CL_DEVICE_PREFERRED_VECTOR_WIDTH_SHORT, cl_uint) \
543      F(cl_device_info, CL_DEVICE_PREFERRED_VECTOR_WIDTH_INT, cl_uint) \
544      F(cl_device_info, CL_DEVICE_PREFERRED_VECTOR_WIDTH_LONG, cl_uint) \
545      F(cl_device_info, CL_DEVICE_PREFERRED_VECTOR_WIDTH_FLOAT, cl_uint) \
546      F(cl_device_info, CL_DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE, cl_uint) \
547      F(cl_device_info, CL_DEVICE_MAX_CLOCK_FREQUENCY, cl_uint) \
548      F(cl_device_info, CL_DEVICE_ADDRESS_BITS, cl_uint) \
549      F(cl_device_info, CL_DEVICE_MAX_READ_IMAGE_ARGS, cl_uint) \
550      F(cl_device_info, CL_DEVICE_MAX_WRITE_IMAGE_ARGS, cl_uint) \
551      F(cl_device_info, CL_DEVICE_MAX_MEM_ALLOC_SIZE, cl_ulong) \
552      F(cl_device_info, CL_DEVICE_IMAGE2D_MAX_WIDTH, size_type) \
553      F(cl_device_info, CL_DEVICE_IMAGE2D_MAX_HEIGHT, size_type) \
554      F(cl_device_info, CL_DEVICE_IMAGE3D_MAX_WIDTH, size_type) \
555      F(cl_device_info, CL_DEVICE_IMAGE3D_MAX_HEIGHT, size_type) \
556      F(cl_device_info, CL_DEVICE_IMAGE3D_MAX_DEPTH, size_type) \
557      F(cl_device_info, CL_DEVICE_IMAGE_SUPPORT, cl_bool) \
558      F(cl_device_info, CL_DEVICE_MAX_PARAMETER_SIZE, size_type) \
559      F(cl_device_info, CL_DEVICE_MAX_SAMPLERS, cl_uint) \
560      F(cl_device_info, CL_DEVICE_MEM_BASE_ADDR_ALIGN, cl_uint) \
561      F(cl_device_info, CL_DEVICE_MIN_DATA_TYPE_ALIGN_SIZE, cl_uint) \
562      F(cl_device_info, CL_DEVICE_SINGLE_FP_CONFIG, cl_device_fp_config) \
563      F(cl_device_info, CL_DEVICE_GLOBAL_MEM_CACHE_TYPE, cl_device_mem_cache_type) \
564      F(cl_device_info, CL_DEVICE_GLOBAL_MEM_CACHELINE_SIZE, cl_uint)\
565      F(cl_device_info, CL_DEVICE_GLOBAL_MEM_CACHE_SIZE, cl_ulong) \
566      F(cl_device_info, CL_DEVICE_GLOBAL_MEM_SIZE, cl_ulong) \
567      F(cl_device_info, CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE, cl_ulong) \
568      F(cl_device_info, CL_DEVICE_MAX_CONSTANT_ARGS, cl_uint) \
569      F(cl_device_info, CL_DEVICE_LOCAL_MEM_TYPE, cl_device_local_mem_type) \
570      F(cl_device_info, CL_DEVICE_LOCAL_MEM_SIZE, cl_ulong) \
571      F(cl_device_info, CL_DEVICE_ERROR_CORRECTION_SUPPORT, cl_bool) \
572      F(cl_device_info, CL_DEVICE_PROFILING_TIMER_RESOLUTION, size_type) \
573      F(cl_device_info, CL_DEVICE_ENDIAN_LITTLE, cl_bool) \
574      F(cl_device_info, CL_DEVICE_AVAILABLE, cl_bool) \
575      F(cl_device_info, CL_DEVICE_COMPILER_AVAILABLE, cl_bool) \
576      F(cl_device_info, CL_DEVICE_EXECUTION_CAPABILITIES, cl_device_exec_capabilities) \
577      F(cl_device_info, CL_DEVICE_PLATFORM, cl_platform_id) \
578      F(cl_device_info, CL_DEVICE_NAME, string) \
579      F(cl_device_info, CL_DEVICE_VENDOR, string) \
580      F(cl_device_info, CL_DRIVER_VERSION, string) \
581      F(cl_device_info, CL_DEVICE_PROFILE, string) \
582      F(cl_device_info, CL_DEVICE_VERSION, string) \
583      F(cl_device_info, CL_DEVICE_EXTENSIONS, string) \
584      \
585      F(cl_context_info, CL_CONTEXT_REFERENCE_COUNT, cl_uint) \
586      F(cl_context_info, CL_CONTEXT_DEVICES, cl::vector&lt;Device&gt;) \
587      F(cl_context_info, CL_CONTEXT_PROPERTIES, cl::vector&lt;cl_context_properties&gt;) \
588      \
589      F(cl_event_info, CL_EVENT_COMMAND_QUEUE, cl::CommandQueue) \
590      F(cl_event_info, CL_EVENT_COMMAND_TYPE, cl_command_type) \
591      F(cl_event_info, CL_EVENT_REFERENCE_COUNT, cl_uint) \
592      F(cl_event_info, CL_EVENT_COMMAND_EXECUTION_STATUS, cl_int) \
593      \
594      F(cl_profiling_info, CL_PROFILING_COMMAND_QUEUED, cl_ulong) \
595      F(cl_profiling_info, CL_PROFILING_COMMAND_SUBMIT, cl_ulong) \
596      F(cl_profiling_info, CL_PROFILING_COMMAND_START, cl_ulong) \
597      F(cl_profiling_info, CL_PROFILING_COMMAND_END, cl_ulong) \
598      \
599      F(cl_mem_info, CL_MEM_TYPE, cl_mem_object_type) \
600      F(cl_mem_info, CL_MEM_FLAGS, cl_mem_flags) \
601      F(cl_mem_info, CL_MEM_SIZE, size_type) \
602      F(cl_mem_info, CL_MEM_HOST_PTR, void*) \
603      F(cl_mem_info, CL_MEM_MAP_COUNT, cl_uint) \
604      F(cl_mem_info, CL_MEM_REFERENCE_COUNT, cl_uint) \
605      F(cl_mem_info, CL_MEM_CONTEXT, cl::Context) \
606      \
607      F(cl_image_info, CL_IMAGE_FORMAT, cl_image_format) \
608      F(cl_image_info, CL_IMAGE_ELEMENT_SIZE, size_type) \
609      F(cl_image_info, CL_IMAGE_ROW_PITCH, size_type) \
610      F(cl_image_info, CL_IMAGE_SLICE_PITCH, size_type) \
611      F(cl_image_info, CL_IMAGE_WIDTH, size_type) \
612      F(cl_image_info, CL_IMAGE_HEIGHT, size_type) \
613      F(cl_image_info, CL_IMAGE_DEPTH, size_type) \
614      F(cl_image_info, CL_IMAGE_ARRAY_SIZE, size_type) \
615      F(cl_image_info, CL_IMAGE_NUM_MIP_LEVELS, cl_uint) \
616      F(cl_image_info, CL_IMAGE_NUM_SAMPLES, cl_uint) \
617      \
618      F(cl_sampler_info, CL_SAMPLER_REFERENCE_COUNT, cl_uint) \
619      F(cl_sampler_info, CL_SAMPLER_CONTEXT, cl::Context) \
620      F(cl_sampler_info, CL_SAMPLER_NORMALIZED_COORDS, cl_bool) \
621      F(cl_sampler_info, CL_SAMPLER_ADDRESSING_MODE, cl_addressing_mode) \
622      F(cl_sampler_info, CL_SAMPLER_FILTER_MODE, cl_filter_mode) \
623      \
624      F(cl_program_info, CL_PROGRAM_REFERENCE_COUNT, cl_uint) \
625      F(cl_program_info, CL_PROGRAM_CONTEXT, cl::Context) \
626      F(cl_program_info, CL_PROGRAM_NUM_DEVICES, cl_uint) \
627      F(cl_program_info, CL_PROGRAM_DEVICES, cl::vector&lt;Device&gt;) \
628      F(cl_program_info, CL_PROGRAM_SOURCE, string) \
629      F(cl_program_info, CL_PROGRAM_BINARY_SIZES, cl::vector&lt;size_type&gt;) \
630      F(cl_program_info, CL_PROGRAM_BINARIES, cl::vector&lt;cl::vector&lt;unsigned char&gt;&gt;) \
631      \
632      F(cl_program_build_info, CL_PROGRAM_BUILD_STATUS, cl_build_status) \
633      F(cl_program_build_info, CL_PROGRAM_BUILD_OPTIONS, string) \
634      F(cl_program_build_info, CL_PROGRAM_BUILD_LOG, string) \
635      \
636      F(cl_kernel_info, CL_KERNEL_FUNCTION_NAME, string) \
637      F(cl_kernel_info, CL_KERNEL_NUM_ARGS, cl_uint) \
638      F(cl_kernel_info, CL_KERNEL_REFERENCE_COUNT, cl_uint) \
639      F(cl_kernel_info, CL_KERNEL_CONTEXT, cl::Context) \
640      F(cl_kernel_info, CL_KERNEL_PROGRAM, cl::Program) \
641      \
642      F(cl_kernel_work_group_info, CL_KERNEL_WORK_GROUP_SIZE, size_type) \
643      F(cl_kernel_work_group_info, CL_KERNEL_COMPILE_WORK_GROUP_SIZE, cl::detail::size_t_array) \
644      F(cl_kernel_work_group_info, CL_KERNEL_LOCAL_MEM_SIZE, cl_ulong) \
645      \
646      F(cl_command_queue_info, CL_QUEUE_CONTEXT, cl::Context) \
647      F(cl_command_queue_info, CL_QUEUE_DEVICE, cl::Device) \
648      F(cl_command_queue_info, CL_QUEUE_REFERENCE_COUNT, cl_uint) \
649      F(cl_command_queue_info, CL_QUEUE_PROPERTIES, cl_command_queue_properties)
650  #define CL_HPP_PARAM_NAME_INFO_1_1_(F) \
651      F(cl_context_info, CL_CONTEXT_NUM_DEVICES, cl_uint)\
652      F(cl_device_info, CL_DEVICE_PREFERRED_VECTOR_WIDTH_HALF, cl_uint) \
653      F(cl_device_info, CL_DEVICE_NATIVE_VECTOR_WIDTH_CHAR, cl_uint) \
654      F(cl_device_info, CL_DEVICE_NATIVE_VECTOR_WIDTH_SHORT, cl_uint) \
655      F(cl_device_info, CL_DEVICE_NATIVE_VECTOR_WIDTH_INT, cl_uint) \
656      F(cl_device_info, CL_DEVICE_NATIVE_VECTOR_WIDTH_LONG, cl_uint) \
657      F(cl_device_info, CL_DEVICE_NATIVE_VECTOR_WIDTH_FLOAT, cl_uint) \
658      F(cl_device_info, CL_DEVICE_NATIVE_VECTOR_WIDTH_DOUBLE, cl_uint) \
659      F(cl_device_info, CL_DEVICE_NATIVE_VECTOR_WIDTH_HALF, cl_uint) \
660      F(cl_device_info, CL_DEVICE_DOUBLE_FP_CONFIG, cl_device_fp_config) \
661      F(cl_device_info, CL_DEVICE_HALF_FP_CONFIG, cl_device_fp_config) \
662      F(cl_device_info, CL_DEVICE_OPENCL_C_VERSION, string) \
663      \
664      F(cl_mem_info, CL_MEM_ASSOCIATED_MEMOBJECT, cl::Memory) \
665      F(cl_mem_info, CL_MEM_OFFSET, size_type) \
666      \
667      F(cl_kernel_work_group_info, CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE, size_type) \
668      F(cl_kernel_work_group_info, CL_KERNEL_PRIVATE_MEM_SIZE, cl_ulong) \
669      \
670      F(cl_event_info, CL_EVENT_CONTEXT, cl::Context)
671  #define CL_HPP_PARAM_NAME_INFO_1_2_(F) \
672      F(cl_program_info, CL_PROGRAM_NUM_KERNELS, size_type) \
673      F(cl_program_info, CL_PROGRAM_KERNEL_NAMES, string) \
674      \
675      F(cl_program_build_info, CL_PROGRAM_BINARY_TYPE, cl_program_binary_type) \
676      \
677      F(cl_kernel_info, CL_KERNEL_ATTRIBUTES, string) \
678      \
679      F(cl_kernel_arg_info, CL_KERNEL_ARG_ADDRESS_QUALIFIER, cl_kernel_arg_address_qualifier) \
680      F(cl_kernel_arg_info, CL_KERNEL_ARG_ACCESS_QUALIFIER, cl_kernel_arg_access_qualifier) \
681      F(cl_kernel_arg_info, CL_KERNEL_ARG_TYPE_NAME, string) \
682      F(cl_kernel_arg_info, CL_KERNEL_ARG_NAME, string) \
683      F(cl_kernel_arg_info, CL_KERNEL_ARG_TYPE_QUALIFIER, cl_kernel_arg_type_qualifier) \
684      \
685      F(cl_device_info, CL_DEVICE_PARENT_DEVICE, cl::Device) \
686      F(cl_device_info, CL_DEVICE_PARTITION_PROPERTIES, cl::vector&lt;cl_device_partition_property&gt;) \
687      F(cl_device_info, CL_DEVICE_PARTITION_TYPE, cl::vector&lt;cl_device_partition_property&gt;)  \
688      F(cl_device_info, CL_DEVICE_REFERENCE_COUNT, cl_uint) \
689      F(cl_device_info, CL_DEVICE_PREFERRED_INTEROP_USER_SYNC, size_type) \
690      F(cl_device_info, CL_DEVICE_PARTITION_AFFINITY_DOMAIN, cl_device_affinity_domain) \
691      F(cl_device_info, CL_DEVICE_BUILT_IN_KERNELS, string)
692  #define CL_HPP_PARAM_NAME_INFO_2_0_(F) \
693      F(cl_device_info, CL_DEVICE_QUEUE_ON_HOST_PROPERTIES, cl_command_queue_properties) \
694      F(cl_device_info, CL_DEVICE_QUEUE_ON_DEVICE_PROPERTIES, cl_command_queue_properties) \
695      F(cl_device_info, CL_DEVICE_QUEUE_ON_DEVICE_PREFERRED_SIZE, cl_uint) \
696      F(cl_device_info, CL_DEVICE_QUEUE_ON_DEVICE_MAX_SIZE, cl_uint) \
697      F(cl_device_info, CL_DEVICE_MAX_ON_DEVICE_QUEUES, cl_uint) \
698      F(cl_device_info, CL_DEVICE_MAX_ON_DEVICE_EVENTS, cl_uint) \
699      F(cl_device_info, CL_DEVICE_MAX_PIPE_ARGS, cl_uint) \
700      F(cl_device_info, CL_DEVICE_PIPE_MAX_ACTIVE_RESERVATIONS, cl_uint) \
701      F(cl_device_info, CL_DEVICE_PIPE_MAX_PACKET_SIZE, cl_uint) \
702      F(cl_device_info, CL_DEVICE_SVM_CAPABILITIES, cl_device_svm_capabilities) \
703      F(cl_device_info, CL_DEVICE_PREFERRED_PLATFORM_ATOMIC_ALIGNMENT, cl_uint) \
704      F(cl_device_info, CL_DEVICE_PREFERRED_GLOBAL_ATOMIC_ALIGNMENT, cl_uint) \
705      F(cl_device_info, CL_DEVICE_PREFERRED_LOCAL_ATOMIC_ALIGNMENT, cl_uint) \
706      F(cl_command_queue_info, CL_QUEUE_SIZE, cl_uint) \
707      F(cl_mem_info, CL_MEM_USES_SVM_POINTER, cl_bool) \
708      F(cl_program_build_info, CL_PROGRAM_BUILD_GLOBAL_VARIABLE_TOTAL_SIZE, size_type) \
709      F(cl_pipe_info, CL_PIPE_PACKET_SIZE, cl_uint) \
710      F(cl_pipe_info, CL_PIPE_MAX_PACKETS, cl_uint)
711  #define CL_HPP_PARAM_NAME_DEVICE_FISSION_(F) \
712      F(cl_device_info, CL_DEVICE_PARENT_DEVICE_EXT, cl_device_id) \
713      F(cl_device_info, CL_DEVICE_PARTITION_TYPES_EXT, cl::vector&lt;cl_device_partition_property_ext&gt;) \
714      F(cl_device_info, CL_DEVICE_AFFINITY_DOMAINS_EXT, cl::vector&lt;cl_device_partition_property_ext&gt;) \
715      F(cl_device_info, CL_DEVICE_REFERENCE_COUNT_EXT , cl_uint) \
716      F(cl_device_info, CL_DEVICE_PARTITION_STYLE_EXT, cl::vector&lt;cl_device_partition_property_ext&gt;)
717  template &lt;typename enum_type, cl_int Name&gt;
718  struct param_traits {};
719  #define CL_HPP_DECLARE_PARAM_TRAITS_(token, param_name, T) \
720  struct token;                                        \
721  template&lt;&gt;                                           \
722  struct param_traits&lt;detail:: token,param_name&gt;       \
723  {                                                    \
724      enum { value = param_name };                     \
725      typedef T param_type;                            \
726  };
727  CL_HPP_PARAM_NAME_INFO_1_0_(CL_HPP_DECLARE_PARAM_TRAITS_)
728  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 110
729  CL_HPP_PARAM_NAME_INFO_1_1_(CL_HPP_DECLARE_PARAM_TRAITS_)
730  #endif 
731  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 120
732  CL_HPP_PARAM_NAME_INFO_1_2_(CL_HPP_DECLARE_PARAM_TRAITS_)
733  #endif 
734  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 200
735  CL_HPP_PARAM_NAME_INFO_2_0_(CL_HPP_DECLARE_PARAM_TRAITS_)
736  #endif 
737  #define CL_HPP_PARAM_NAME_INFO_1_0_DEPRECATED_IN_2_0_(F) \
738      F(cl_device_info, CL_DEVICE_QUEUE_PROPERTIES, cl_command_queue_properties)
739  #define CL_HPP_PARAM_NAME_INFO_1_1_DEPRECATED_IN_2_0_(F) \
740      F(cl_device_info, CL_DEVICE_HOST_UNIFIED_MEMORY, cl_bool)
741  #define CL_HPP_PARAM_NAME_INFO_1_2_DEPRECATED_IN_2_0_(F) \
742      F(cl_image_info, CL_IMAGE_BUFFER, cl::Buffer)
743  #if CL_HPP_TARGET_OPENCL_VERSION &gt; 100 &amp;&amp; CL_HPP_MINIMUM_OPENCL_VERSION &lt; 200 &amp;&amp; CL_HPP_TARGET_OPENCL_VERSION &lt; 200
744  CL_HPP_PARAM_NAME_INFO_1_0_DEPRECATED_IN_2_0_(CL_HPP_DECLARE_PARAM_TRAITS_)
745  #endif 
746  #if CL_HPP_TARGET_OPENCL_VERSION &gt; 110 &amp;&amp; CL_HPP_MINIMUM_OPENCL_VERSION &lt; 200
747  CL_HPP_PARAM_NAME_INFO_1_1_DEPRECATED_IN_2_0_(CL_HPP_DECLARE_PARAM_TRAITS_)
748  #endif 
749  #if CL_HPP_TARGET_OPENCL_VERSION &gt; 120 &amp;&amp; CL_HPP_MINIMUM_OPENCL_VERSION &lt; 200
750  CL_HPP_PARAM_NAME_INFO_1_2_DEPRECATED_IN_2_0_(CL_HPP_DECLARE_PARAM_TRAITS_)
751  #endif 
752  #if defined(CL_HPP_USE_CL_DEVICE_FISSION)
753  CL_HPP_PARAM_NAME_DEVICE_FISSION_(CL_HPP_DECLARE_PARAM_TRAITS_);
754  #endif 
755  #ifdef CL_PLATFORM_ICD_SUFFIX_KHR
756  CL_HPP_DECLARE_PARAM_TRAITS_(cl_platform_info, CL_PLATFORM_ICD_SUFFIX_KHR, string)
757  #endif
758  #ifdef CL_DEVICE_PROFILING_TIMER_OFFSET_AMD
759  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_PROFILING_TIMER_OFFSET_AMD, cl_ulong)
760  #endif
761  #ifdef CL_DEVICE_GLOBAL_FREE_MEMORY_AMD
762  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_GLOBAL_FREE_MEMORY_AMD, vector&lt;size_type&gt;)
763  #endif
764  #ifdef CL_DEVICE_SIMD_PER_COMPUTE_UNIT_AMD
765  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_SIMD_PER_COMPUTE_UNIT_AMD, cl_uint)
766  #endif
767  #ifdef CL_DEVICE_SIMD_WIDTH_AMD
768  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_SIMD_WIDTH_AMD, cl_uint)
769  #endif
770  #ifdef CL_DEVICE_SIMD_INSTRUCTION_WIDTH_AMD
771  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_SIMD_INSTRUCTION_WIDTH_AMD, cl_uint)
772  #endif
773  #ifdef CL_DEVICE_WAVEFRONT_WIDTH_AMD
774  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_WAVEFRONT_WIDTH_AMD, cl_uint)
775  #endif
776  #ifdef CL_DEVICE_GLOBAL_MEM_CHANNELS_AMD
777  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_GLOBAL_MEM_CHANNELS_AMD, cl_uint)
778  #endif
779  #ifdef CL_DEVICE_GLOBAL_MEM_CHANNEL_BANKS_AMD
780  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_GLOBAL_MEM_CHANNEL_BANKS_AMD, cl_uint)
781  #endif
782  #ifdef CL_DEVICE_GLOBAL_MEM_CHANNEL_BANK_WIDTH_AMD
783  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_GLOBAL_MEM_CHANNEL_BANK_WIDTH_AMD, cl_uint)
784  #endif
785  #ifdef CL_DEVICE_LOCAL_MEM_SIZE_PER_COMPUTE_UNIT_AMD
786  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_LOCAL_MEM_SIZE_PER_COMPUTE_UNIT_AMD, cl_uint)
787  #endif
788  #ifdef CL_DEVICE_LOCAL_MEM_BANKS_AMD
789  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_LOCAL_MEM_BANKS_AMD, cl_uint)
790  #endif
791  #ifdef CL_DEVICE_COMPUTE_CAPABILITY_MAJOR_NV
792  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_COMPUTE_CAPABILITY_MAJOR_NV, cl_uint)
793  #endif
794  #ifdef CL_DEVICE_COMPUTE_CAPABILITY_MINOR_NV
795  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_COMPUTE_CAPABILITY_MINOR_NV, cl_uint)
796  #endif
797  #ifdef CL_DEVICE_REGISTERS_PER_BLOCK_NV
798  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_REGISTERS_PER_BLOCK_NV, cl_uint)
799  #endif
800  #ifdef CL_DEVICE_WARP_SIZE_NV
801  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_WARP_SIZE_NV, cl_uint)
802  #endif
803  #ifdef CL_DEVICE_GPU_OVERLAP_NV
804  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_GPU_OVERLAP_NV, cl_bool)
805  #endif
806  #ifdef CL_DEVICE_KERNEL_EXEC_TIMEOUT_NV
807  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_KERNEL_EXEC_TIMEOUT_NV, cl_bool)
808  #endif
809  #ifdef CL_DEVICE_INTEGRATED_MEMORY_NV
810  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_INTEGRATED_MEMORY_NV, cl_bool)
811  #endif
812  template &lt;typename Func, typename T&gt;
813  inline cl_int
814  getInfo(Func f, cl_uint name, T* param)
815  {
816      return getInfoHelper(f, name, param, 0);
817  }
818  template &lt;typename Func, typename Arg0&gt;
819  struct GetInfoFunctor0
820  {
821      Func f_; const Arg0&amp; arg0_;
822      cl_int operator ()(
823          cl_uint param, size_type size, void* value, size_type* size_ret)
824      { return f_(arg0_, param, size, value, size_ret); }
825  };
826  template &lt;typename Func, typename Arg0, typename Arg1&gt;
827  struct GetInfoFunctor1
828  {
829      Func f_; const Arg0&amp; arg0_; const Arg1&amp; arg1_;
830      cl_int operator ()(
831          cl_uint param, size_type size, void* value, size_type* size_ret)
832      { return f_(arg0_, arg1_, param, size, value, size_ret); }
833  };
834  template &lt;typename Func, typename Arg0, typename T&gt;
835  inline cl_int
836  getInfo(Func f, const Arg0&amp; arg0, cl_uint name, T* param)
837  {
838      GetInfoFunctor0&lt;Func, Arg0&gt; f0 = { f, arg0 };
839      return getInfoHelper(f0, name, param, 0);
840  }
841  template &lt;typename Func, typename Arg0, typename Arg1, typename T&gt;
842  inline cl_int
843  getInfo(Func f, const Arg0&amp; arg0, const Arg1&amp; arg1, cl_uint name, T* param)
844  {
845      GetInfoFunctor1&lt;Func, Arg0, Arg1&gt; f0 = { f, arg0, arg1 };
846      return getInfoHelper(f0, name, param, 0);
847  }
848  template&lt;typename T&gt;
849  struct ReferenceHandler
850  { };
851  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 120
852  template &lt;&gt;
853  struct ReferenceHandler&lt;cl_device_id&gt;
854  {
855      static cl_int retain(cl_device_id device)
856      { return ::clRetainDevice(device); }
857      static cl_int release(cl_device_id device)
858      { return ::clReleaseDevice(device); }
859  };
860  #else 
861  template &lt;&gt;
862  struct ReferenceHandler&lt;cl_device_id&gt;
863  {
864      static cl_int retain(cl_device_id)
865      { return CL_SUCCESS; }
866      static cl_int release(cl_device_id)
867      { return CL_SUCCESS; }
868  };
869  #endif 
870  template &lt;&gt;
871  struct ReferenceHandler&lt;cl_platform_id&gt;
872  {
873      static cl_int retain(cl_platform_id)
874      { return CL_SUCCESS; }
875      static cl_int release(cl_platform_id)
876      { return CL_SUCCESS; }
877  };
878  template &lt;&gt;
879  struct ReferenceHandler&lt;cl_context&gt;
880  {
881      static cl_int retain(cl_context context)
882      { return ::clRetainContext(context); }
883      static cl_int release(cl_context context)
884      { return ::clReleaseContext(context); }
885  };
886  template &lt;&gt;
887  struct ReferenceHandler&lt;cl_command_queue&gt;
888  {
889      static cl_int retain(cl_command_queue queue)
890      { return ::clRetainCommandQueue(queue); }
891      static cl_int release(cl_command_queue queue)
892      { return ::clReleaseCommandQueue(queue); }
893  };
894  template &lt;&gt;
895  struct ReferenceHandler&lt;cl_mem&gt;
896  {
897      static cl_int retain(cl_mem memory)
898      { return ::clRetainMemObject(memory); }
899      static cl_int release(cl_mem memory)
900      { return ::clReleaseMemObject(memory); }
901  };
902  template &lt;&gt;
903  struct ReferenceHandler&lt;cl_sampler&gt;
904  {
905      static cl_int retain(cl_sampler sampler)
906      { return ::clRetainSampler(sampler); }
907      static cl_int release(cl_sampler sampler)
908      { return ::clReleaseSampler(sampler); }
909  };
910  template &lt;&gt;
911  struct ReferenceHandler&lt;cl_program&gt;
912  {
913      static cl_int retain(cl_program program)
914      { return ::clRetainProgram(program); }
915      static cl_int release(cl_program program)
916      { return ::clReleaseProgram(program); }
917  };
918  template &lt;&gt;
919  struct ReferenceHandler&lt;cl_kernel&gt;
920  {
921      static cl_int retain(cl_kernel kernel)
922      { return ::clRetainKernel(kernel); }
923      static cl_int release(cl_kernel kernel)
924      { return ::clReleaseKernel(kernel); }
925  };
926  template &lt;&gt;
927  struct ReferenceHandler&lt;cl_event&gt;
928  {
929      static cl_int retain(cl_event event)
930      { return ::clRetainEvent(event); }
931      static cl_int release(cl_event event)
932      { return ::clReleaseEvent(event); }
933  };
934  static cl_uint getVersion(const vector&lt;char&gt; &amp;versionInfo)
935  {
936      int highVersion = 0;
937      int lowVersion = 0;
938      int index = 7;
939      while(versionInfo[index] != &#x27;.&#x27; ) {
940          highVersion *= 10;
941          highVersion += versionInfo[index]-&#x27;0&#x27;;
942          ++index;
943      }
944      ++index;
945      while(versionInfo[index] != &#x27; &#x27; &amp;&amp;  versionInfo[index] != &#x27;\0&#x27;) {
946          lowVersion *= 10;
947          lowVersion += versionInfo[index]-&#x27;0&#x27;;
948          ++index;
949      }
950      return (highVersion &lt;&lt; 16) | lowVersion;
951  }
952  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 120 &amp;&amp; CL_HPP_MINIMUM_OPENCL_VERSION &lt; 120
953  static cl_uint getPlatformVersion(cl_platform_id platform)
954  {
955      size_type size = 0;
956      clGetPlatformInfo(platform, CL_PLATFORM_VERSION, 0, NULL, &amp;size);
957      vector&lt;char&gt; versionInfo(size);
958      clGetPlatformInfo(platform, CL_PLATFORM_VERSION, size, versionInfo.data(), &amp;size);
959      return getVersion(versionInfo);
960  }
961  static cl_uint getDevicePlatformVersion(cl_device_id device)
962  {
963      cl_platform_id platform;
964      clGetDeviceInfo(device, CL_DEVICE_PLATFORM, sizeof(platform), &amp;platform, NULL);
965      return getPlatformVersion(platform);
966  }
967  static cl_uint getContextPlatformVersion(cl_context context)
968  {
969      size_type size = 0;
970      clGetContextInfo(context, CL_CONTEXT_DEVICES, 0, NULL, &amp;size);
971      if (size == 0)
972          return 0;
973      vector&lt;cl_device_id&gt; devices(size/sizeof(cl_device_id));
974      clGetContextInfo(context, CL_CONTEXT_DEVICES, size, devices.data(), NULL);
975      return getDevicePlatformVersion(devices[0]);
976  }
977  #endif 
978  template &lt;typename T&gt;
979  class Wrapper
980  {
981  public:
982      typedef T cl_type;
983  protected:
984      cl_type object_;
985  public:
986      Wrapper() : object_(NULL) { }
987      Wrapper(const cl_type &amp;obj, bool retainObject) : object_(obj) 
988      {
989          if (retainObject) { 
990              detail::errHandler(retain(), __RETAIN_ERR); 
991          }
992      }
993      ~Wrapper()
994      {
995          if (object_ != NULL) { release(); }
996      }
997      Wrapper(const Wrapper&lt;cl_type&gt;&amp; rhs)
998      {
999          object_ = rhs.object_;
1000          detail::errHandler(retain(), __RETAIN_ERR);
1001      }
1002      Wrapper(Wrapper&lt;cl_type&gt;&amp;&amp; rhs) CL_HPP_NOEXCEPT_
1003      {
1004          object_ = rhs.object_;
1005          rhs.object_ = NULL;
1006      }
1007      Wrapper&lt;cl_type&gt;&amp; operator = (const Wrapper&lt;cl_type&gt;&amp; rhs)
1008      {
1009          if (this != &amp;rhs) {
1010              detail::errHandler(release(), __RELEASE_ERR);
1011              object_ = rhs.object_;
1012              detail::errHandler(retain(), __RETAIN_ERR);
1013          }
1014          return *this;
1015      }
1016      Wrapper&lt;cl_type&gt;&amp; operator = (Wrapper&lt;cl_type&gt;&amp;&amp; rhs)
1017      {
1018          if (this != &amp;rhs) {
1019              detail::errHandler(release(), __RELEASE_ERR);
1020              object_ = rhs.object_;
1021              rhs.object_ = NULL;
1022          }
1023          return *this;
1024      }
1025      Wrapper&lt;cl_type&gt;&amp; operator = (const cl_type &amp;rhs)
1026      {
1027          detail::errHandler(release(), __RELEASE_ERR);
1028          object_ = rhs;
1029          return *this;
1030      }
1031      const cl_type&amp; operator ()() const { return object_; }
1032      cl_type&amp; operator ()() { return object_; }
1033      const cl_type get() const { return object_; }
1034      cl_type get() { return object_; }
1035  protected:
1036      template&lt;typename Func, typename U&gt;
1037      friend inline cl_int getInfoHelper(Func, cl_uint, U*, int, typename U::cl_type);
1038      cl_int retain() const
1039      {
1040          if (object_ != nullptr) {
1041              return ReferenceHandler&lt;cl_type&gt;::retain(object_);
1042          }
1043          else {
1044              return CL_SUCCESS;
1045          }
1046      }
1047      cl_int release() const
1048      {
1049          if (object_ != nullptr) {
1050              return ReferenceHandler&lt;cl_type&gt;::release(object_);
1051          }
1052          else {
1053              return CL_SUCCESS;
1054          }
1055      }
1056  };
1057  template &lt;&gt;
1058  class Wrapper&lt;cl_device_id&gt;
1059  {
1060  public:
1061      typedef cl_device_id cl_type;
1062  protected:
1063      cl_type object_;
1064      bool referenceCountable_;
1065      static bool isReferenceCountable(cl_device_id device)
1066      {
1067          bool retVal = false;
1068  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 120
1069  #if CL_HPP_MINIMUM_OPENCL_VERSION &lt; 120
1070          if (device != NULL) {
1071              int version = getDevicePlatformVersion(device);
1072              if(version &gt; ((1 &lt;&lt; 16) + 1)) {
1073                  retVal = true;
1074              }
1075          }
1076  #else 
1077          retVal = true;
1078  #endif 
1079  #endif 
1080          return retVal;
1081      }
1082  public:
1083      Wrapper() : object_(NULL), referenceCountable_(false) 
1084      { 
1085      }
1086      Wrapper(const cl_type &amp;obj, bool retainObject) : 
1087          object_(obj), 
1088          referenceCountable_(false) 
1089      {
1090          referenceCountable_ = isReferenceCountable(obj); 
1091          if (retainObject) {
1092              detail::errHandler(retain(), __RETAIN_ERR);
1093          }
1094      }
1095      ~Wrapper()
1096      {
1097          release();
1098      }
1099      Wrapper(const Wrapper&lt;cl_type&gt;&amp; rhs)
1100      {
1101          object_ = rhs.object_;
1102          referenceCountable_ = isReferenceCountable(object_); 
1103          detail::errHandler(retain(), __RETAIN_ERR);
1104      }
1105      Wrapper(Wrapper&lt;cl_type&gt;&amp;&amp; rhs) CL_HPP_NOEXCEPT_
1106      {
1107          object_ = rhs.object_;
1108          referenceCountable_ = rhs.referenceCountable_;
1109          rhs.object_ = NULL;
1110          rhs.referenceCountable_ = false;
1111      }
1112      Wrapper&lt;cl_type&gt;&amp; operator = (const Wrapper&lt;cl_type&gt;&amp; rhs)
1113      {
1114          if (this != &amp;rhs) {
1115              detail::errHandler(release(), __RELEASE_ERR);
1116              object_ = rhs.object_;
1117              referenceCountable_ = rhs.referenceCountable_;
1118              detail::errHandler(retain(), __RETAIN_ERR);
1119          }
1120          return *this;
1121      }
1122      Wrapper&lt;cl_type&gt;&amp; operator = (Wrapper&lt;cl_type&gt;&amp;&amp; rhs)
1123      {
1124          if (this != &amp;rhs) {
1125              detail::errHandler(release(), __RELEASE_ERR);
1126              object_ = rhs.object_;
1127              referenceCountable_ = rhs.referenceCountable_;
1128              rhs.object_ = NULL;
1129              rhs.referenceCountable_ = false;
1130          }
1131          return *this;
1132      }
1133      Wrapper&lt;cl_type&gt;&amp; operator = (const cl_type &amp;rhs)
1134      {
1135          detail::errHandler(release(), __RELEASE_ERR);
1136          object_ = rhs;
1137          referenceCountable_ = isReferenceCountable(object_); 
1138          return *this;
1139      }
1140      const cl_type&amp; operator ()() const { return object_; }
1141      cl_type&amp; operator ()() { return object_; }
1142      const cl_type get() const { return object_; }
1143      cl_type get() { return object_; }
1144  protected:
1145      template&lt;typename Func, typename U&gt;
1146      friend inline cl_int getInfoHelper(Func, cl_uint, U*, int, typename U::cl_type);
1147      template&lt;typename Func, typename U&gt;
1148      friend inline cl_int getInfoHelper(Func, cl_uint, vector&lt;U&gt;*, int, typename U::cl_type);
1149      cl_int retain() const
1150      {
1151          if( object_ != nullptr &amp;&amp; referenceCountable_ ) {
1152              return ReferenceHandler&lt;cl_type&gt;::retain(object_);
1153          }
1154          else {
1155              return CL_SUCCESS;
1156          }
1157      }
1158      cl_int release() const
1159      {
1160          if (object_ != nullptr &amp;&amp; referenceCountable_) {
1161              return ReferenceHandler&lt;cl_type&gt;::release(object_);
1162          }
1163          else {
1164              return CL_SUCCESS;
1165          }
1166      }
1167  };
1168  template &lt;typename T&gt;
1169  inline bool operator==(const Wrapper&lt;T&gt; &amp;lhs, const Wrapper&lt;T&gt; &amp;rhs)
1170  {
1171      return lhs() == rhs();
1172  }
1173  template &lt;typename T&gt;
1174  inline bool operator!=(const Wrapper&lt;T&gt; &amp;lhs, const Wrapper&lt;T&gt; &amp;rhs)
1175  {
1176      return !operator==(lhs, rhs);
1177  }
1178  } 
1179  using BuildLogType = vector&lt;std::pair&lt;cl::Device, typename detail::param_traits&lt;detail::cl_program_build_info, CL_PROGRAM_BUILD_LOG&gt;::param_type&gt;&gt;;
1180  #if defined(CL_HPP_ENABLE_EXCEPTIONS)
1181  class BuildError : public Error
1182  {
1183  private:
1184      BuildLogType buildLogs;
1185  public:
1186      BuildError(cl_int err, const char * errStr, const BuildLogType &amp;vec) : Error(err, errStr), buildLogs(vec)
1187      {
1188      }
1189      BuildLogType getBuildLog() const
1190      {
1191          return buildLogs;
1192      }
1193  };
1194  namespace detail {
1195      static inline cl_int buildErrHandler(
1196          cl_int err,
1197          const char * errStr,
1198          const BuildLogType &amp;buildLogs)
1199      {
1200          if (err != CL_SUCCESS) {
1201              throw BuildError(err, errStr, buildLogs);
1202          }
1203          return err;
1204      }
1205  } 
1206  #else
1207  namespace detail {
1208      static inline cl_int buildErrHandler(
1209          cl_int err,
1210          const char * errStr,
1211          const BuildLogType &amp;buildLogs)
1212      {
1213          (void)buildLogs; 
1214          (void)errStr;
1215          return err;
1216      }
1217  } 
1218  #endif 
1219  struct ImageFormat : public cl_image_format
1220  {
1221      ImageFormat(){}
1222      ImageFormat(cl_channel_order order, cl_channel_type type)
1223      {
1224          image_channel_order = order;
1225          image_channel_data_type = type;
1226      }
1227      ImageFormat&amp; operator = (const ImageFormat&amp; rhs)
1228      {
1229          if (this != &amp;rhs) {
1230              this-&gt;image_channel_data_type = rhs.image_channel_data_type;
1231              this-&gt;image_channel_order     = rhs.image_channel_order;
1232          }
1233          return *this;
1234      }
1235  };
1236  class Device : public detail::Wrapper&lt;cl_device_id&gt;
1237  {
1238  private:
1239      static std::once_flag default_initialized_;
1240      static Device default_;
1241      static cl_int default_error_;
1242      static void makeDefault();
1243      static void makeDefaultProvided(const Device &amp;p) {
1244          default_ = p;
1245      }
1246  public:
1247  #ifdef CL_HPP_UNIT_TEST_ENABLE
1248      static void unitTestClearDefault() {
1249          default_ = Device();
1250      }
1251  #endif 
1252      Device() : detail::Wrapper&lt;cl_type&gt;() { }
1253      explicit Device(const cl_device_id &amp;device, bool retainObject = false) : 
1254          detail::Wrapper&lt;cl_type&gt;(device, retainObject) { }
1255      static Device getDefault(
1256          cl_int *errResult = NULL)
1257      {
1258          std::call_once(default_initialized_, makeDefault);
1259          detail::errHandler(default_error_);
1260          if (errResult != NULL) {
1261              *errResult = default_error_;
1262          }
1263          return default_;
1264      }
1265      static Device setDefault(const Device &amp;default_device)
1266      {
1267          std::call_once(default_initialized_, makeDefaultProvided, std::cref(default_device));
1268          detail::errHandler(default_error_);
1269          return default_;
1270      }
1271      Device&amp; operator = (const cl_device_id&amp; rhs)
1272      {
1273          detail::Wrapper&lt;cl_type&gt;::operator=(rhs);
1274          return *this;
1275      }
1276      Device(const Device&amp; dev) : detail::Wrapper&lt;cl_type&gt;(dev) {}
1277      Device&amp; operator = (const Device &amp;dev)
1278      {
1279          detail::Wrapper&lt;cl_type&gt;::operator=(dev);
1280          return *this;
1281      }
1282      Device(Device&amp;&amp; dev) CL_HPP_NOEXCEPT_ : detail::Wrapper&lt;cl_type&gt;(std::move(dev)) {}
1283      Device&amp; operator = (Device &amp;&amp;dev)
1284      {
1285          detail::Wrapper&lt;cl_type&gt;::operator=(std::move(dev));
1286          return *this;
1287      }
1288      template &lt;typename T&gt;
1289      cl_int getInfo(cl_device_info name, T* param) const
1290      {
1291          return detail::errHandler(
1292              detail::getInfo(&amp;::clGetDeviceInfo, object_, name, param),
1293              __GET_DEVICE_INFO_ERR);
1294      }
1295      template &lt;cl_int name&gt; typename
1296      detail::param_traits&lt;detail::cl_device_info, name&gt;::param_type
1297      getInfo(cl_int* err = NULL) const
1298      {
1299          typename detail::param_traits&lt;
1300              detail::cl_device_info, name&gt;::param_type param;
1301          cl_int result = getInfo(name, &amp;param);
1302          if (err != NULL) {
1303              *err = result;
1304          }
1305          return param;
1306      }
1307  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 120
1308      cl_int createSubDevices(
1309          const cl_device_partition_property * properties,
1310          vector&lt;Device&gt;* devices)
1311      {
1312          cl_uint n = 0;
1313          cl_int err = clCreateSubDevices(object_, properties, 0, NULL, &amp;n);
1314          if (err != CL_SUCCESS) {
1315              return detail::errHandler(err, __CREATE_SUB_DEVICES_ERR);
1316          }
1317          vector&lt;cl_device_id&gt; ids(n);
1318          err = clCreateSubDevices(object_, properties, n, ids.data(), NULL);
1319          if (err != CL_SUCCESS) {
1320              return detail::errHandler(err, __CREATE_SUB_DEVICES_ERR);
1321          }
1322          if (devices) {
1323              devices-&gt;resize(ids.size());
1324              for (size_type i = 0; i &lt; ids.size(); i++) {
1325                  (*devices)[i] = Device(ids[i], false);
1326              }
1327          }
1328          return CL_SUCCESS;
1329      }
1330  #elif defined(CL_HPP_USE_CL_DEVICE_FISSION)
1331      cl_int createSubDevices(
1332          const cl_device_partition_property_ext * properties,
1333          vector&lt;Device&gt;* devices)
1334      {
1335          typedef CL_API_ENTRY cl_int 
1336              ( CL_API_CALL * PFN_clCreateSubDevicesEXT)(
1337                  cl_device_id &amp;bsol;*in_device*/,
1338                  const cl_device_partition_property_ext * &amp;bsol;* properties */,
1339                  cl_uint &amp;bsol;*num_entries*/,
1340                  cl_device_id * &amp;bsol;*out_devices*/,
1341                  cl_uint * &amp;bsol;*num_devices*/ ) CL_EXT_SUFFIX__VERSION_1_1;
1342          static PFN_clCreateSubDevicesEXT pfn_clCreateSubDevicesEXT = NULL;
1343          CL_HPP_INIT_CL_EXT_FCN_PTR_(clCreateSubDevicesEXT);
1344          cl_uint n = 0;
1345          cl_int err = pfn_clCreateSubDevicesEXT(object_, properties, 0, NULL, &amp;n);
1346          if (err != CL_SUCCESS) {
1347              return detail::errHandler(err, __CREATE_SUB_DEVICES_ERR);
1348          }
1349          vector&lt;cl_device_id&gt; ids(n);
1350          err = pfn_clCreateSubDevicesEXT(object_, properties, n, ids.data(), NULL);
1351          if (err != CL_SUCCESS) {
1352              return detail::errHandler(err, __CREATE_SUB_DEVICES_ERR);
1353          }
1354          if (devices) {
1355              devices-&gt;resize(ids.size());
1356              for (size_type i = 0; i &lt; ids.size(); i++) {
1357                  (*devices)[i] = Device(ids[i], false);
1358              }
1359          }
1360          return CL_SUCCESS;
1361      }
1362  #endif 
1363  };
1364  CL_HPP_DEFINE_STATIC_MEMBER_ std::once_flag Device::default_initialized_;
1365  CL_HPP_DEFINE_STATIC_MEMBER_ Device Device::default_;
1366  CL_HPP_DEFINE_STATIC_MEMBER_ cl_int Device::default_error_ = CL_SUCCESS;
1367  class Platform : public detail::Wrapper&lt;cl_platform_id&gt;
1368  {
1369  private:
1370      static std::once_flag default_initialized_;
1371      static Platform default_;
1372      static cl_int default_error_;
1373      static void makeDefault() {
1374  #if defined(CL_HPP_ENABLE_EXCEPTIONS)
1375          try
1376  #endif
1377          {
1378              cl_uint n = 0;
1379              cl_int err = ::clGetPlatformIDs(0, NULL, &amp;n);
1380              if (err != CL_SUCCESS) {
1381                  default_error_ = err;
1382                  return;
1383              }
1384              if (n == 0) {
1385                  default_error_ = CL_INVALID_PLATFORM;
1386                  return;
1387              }
1388              vector&lt;cl_platform_id&gt; ids(n);
1389              err = ::clGetPlatformIDs(n, ids.data(), NULL);
1390              if (err != CL_SUCCESS) {
1391                  default_error_ = err;
1392                  return;
1393              }
1394              default_ = Platform(ids[0]);
1395          }
1396  #if defined(CL_HPP_ENABLE_EXCEPTIONS)
1397          catch (cl::Error &amp;e) {
1398              default_error_ = e.err();
1399          }
1400  #endif
1401      }
1402      static void makeDefaultProvided(const Platform &amp;p) {
1403         default_ = p;
1404      }
1405  public:
1406  #ifdef CL_HPP_UNIT_TEST_ENABLE
1407      static void unitTestClearDefault() {
1408          default_ = Platform();
1409      }
1410  #endif 
1411      Platform() : detail::Wrapper&lt;cl_type&gt;()  { }
1412      explicit Platform(const cl_platform_id &amp;platform, bool retainObject = false) : 
1413          detail::Wrapper&lt;cl_type&gt;(platform, retainObject) { }
1414      Platform&amp; operator = (const cl_platform_id&amp; rhs)
1415      {
1416          detail::Wrapper&lt;cl_type&gt;::operator=(rhs);
1417          return *this;
1418      }
1419      static Platform getDefault(
1420          cl_int *errResult = NULL)
1421      {
1422          std::call_once(default_initialized_, makeDefault);
1423          detail::errHandler(default_error_);
1424          if (errResult != NULL) {
1425              *errResult = default_error_;
1426          }
1427          return default_;
1428      }
1429      static Platform setDefault(const Platform &amp;default_platform)
1430      {
1431          std::call_once(default_initialized_, makeDefaultProvided, std::cref(default_platform));
1432          detail::errHandler(default_error_);
1433          return default_;
1434      }
1435      cl_int getInfo(cl_platform_info name, string* param) const
1436      {
1437          return detail::errHandler(
1438              detail::getInfo(&amp;::clGetPlatformInfo, object_, name, param),
1439              __GET_PLATFORM_INFO_ERR);
1440      }
1441      template &lt;cl_int name&gt; typename
1442      detail::param_traits&lt;detail::cl_platform_info, name&gt;::param_type
1443      getInfo(cl_int* err = NULL) const
1444      {
1445          typename detail::param_traits&lt;
1446              detail::cl_platform_info, name&gt;::param_type param;
1447          cl_int result = getInfo(name, &amp;param);
1448          if (err != NULL) {
1449              *err = result;
1450          }
1451          return param;
1452      }
1453      cl_int getDevices(
1454          cl_device_type type,
1455          vector&lt;Device&gt;* devices) const
1456      {
1457          cl_uint n = 0;
1458          if( devices == NULL ) {
1459              return detail::errHandler(CL_INVALID_ARG_VALUE, __GET_DEVICE_IDS_ERR);
1460          }
1461          cl_int err = ::clGetDeviceIDs(object_, type, 0, NULL, &amp;n);
1462          if (err != CL_SUCCESS) {
1463              return detail::errHandler(err, __GET_DEVICE_IDS_ERR);
1464          }
1465          vector&lt;cl_device_id&gt; ids(n);
1466          err = ::clGetDeviceIDs(object_, type, n, ids.data(), NULL);
1467          if (err != CL_SUCCESS) {
1468              return detail::errHandler(err, __GET_DEVICE_IDS_ERR);
1469          }
1470          if (devices) {
1471              devices-&gt;resize(ids.size());
1472              for (size_type i = 0; i &lt; ids.size(); i++) {
1473                  (*devices)[i] = Device(ids[i], true);
1474              }
1475          }
1476          return CL_SUCCESS;
1477      }
1478  #if defined(CL_HPP_USE_DX_INTEROP)
1479      cl_int getDevices(
1480          cl_d3d10_device_source_khr d3d_device_source,
1481          void *                     d3d_object,
1482          cl_d3d10_device_set_khr    d3d_device_set,
1483          vector&lt;Device&gt;* devices) const
1484      {
1485          typedef CL_API_ENTRY cl_int (CL_API_CALL *PFN_clGetDeviceIDsFromD3D10KHR)(
1486              cl_platform_id platform, 
1487              cl_d3d10_device_source_khr d3d_device_source, 
1488              void * d3d_object,
1489              cl_d3d10_device_set_khr d3d_device_set,
1490              cl_uint num_entries,
1491              cl_device_id * devices,
1492              cl_uint* num_devices);
1493          if( devices == NULL ) {
1494              return detail::errHandler(CL_INVALID_ARG_VALUE, __GET_DEVICE_IDS_ERR);
1495          }
1496          static PFN_clGetDeviceIDsFromD3D10KHR pfn_clGetDeviceIDsFromD3D10KHR = NULL;
1497          CL_HPP_INIT_CL_EXT_FCN_PTR_PLATFORM_(object_, clGetDeviceIDsFromD3D10KHR);
1498          cl_uint n = 0;
1499          cl_int err = pfn_clGetDeviceIDsFromD3D10KHR(
1500              object_, 
1501              d3d_device_source, 
1502              d3d_object,
1503              d3d_device_set, 
1504              0, 
1505              NULL, 
1506              &amp;n);
1507          if (err != CL_SUCCESS) {
1508              return detail::errHandler(err, __GET_DEVICE_IDS_ERR);
1509          }
1510          vector&lt;cl_device_id&gt; ids(n);
1511          err = pfn_clGetDeviceIDsFromD3D10KHR(
1512              object_, 
1513              d3d_device_source, 
1514              d3d_object,
1515              d3d_device_set,
1516              n, 
1517              ids.data(), 
1518              NULL);
1519          if (err != CL_SUCCESS) {
1520              return detail::errHandler(err, __GET_DEVICE_IDS_ERR);
1521          }
1522          if (devices) {
1523              devices-&gt;resize(ids.size());
1524              for (size_type i = 0; i &lt; ids.size(); i++) {
1525                  (*devices)[i] = Device(ids[i], true);
1526              }
1527          }
1528          return CL_SUCCESS;
1529      }
1530  #endif
1531      static cl_int get(
1532          vector&lt;Platform&gt;* platforms)
1533      {
1534          cl_uint n = 0;
1535          if( platforms == NULL ) {
1536              return detail::errHandler(CL_INVALID_ARG_VALUE, __GET_PLATFORM_IDS_ERR);
1537          }
1538          cl_int err = ::clGetPlatformIDs(0, NULL, &amp;n);
1539          if (err != CL_SUCCESS) {
1540              return detail::errHandler(err, __GET_PLATFORM_IDS_ERR);
1541          }
1542          vector&lt;cl_platform_id&gt; ids(n);
1543          err = ::clGetPlatformIDs(n, ids.data(), NULL);
1544          if (err != CL_SUCCESS) {
1545              return detail::errHandler(err, __GET_PLATFORM_IDS_ERR);
1546          }
1547          if (platforms) {
1548              platforms-&gt;resize(ids.size());
1549              for (size_type i = 0; i &lt; ids.size(); i++) {
1550                  (*platforms)[i] = Platform(ids[i]);
1551              }
1552          }
1553          return CL_SUCCESS;
1554      }
1555      static cl_int get(
1556          Platform * platform)
1557      {
1558          cl_int err;
1559          Platform default_platform = Platform::getDefault(&amp;err);
1560          if (platform) {
1561              *platform = default_platform;
1562          }
1563          return err;
1564      }
1565      static Platform get(
1566          cl_int * errResult = NULL)
1567      {
1568          cl_int err;
1569          Platform default_platform = Platform::getDefault(&amp;err);
1570          if (errResult) {
1571              *errResult = err;
1572          }
1573          return default_platform;
1574      }    
1575  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 120
1576      cl_int
1577      unloadCompiler()
1578      {
1579          return ::clUnloadPlatformCompiler(object_);
1580      }
1581  #endif 
1582  }; 
1583  CL_HPP_DEFINE_STATIC_MEMBER_ std::once_flag Platform::default_initialized_;
1584  CL_HPP_DEFINE_STATIC_MEMBER_ Platform Platform::default_;
1585  CL_HPP_DEFINE_STATIC_MEMBER_ cl_int Platform::default_error_ = CL_SUCCESS;
1586  #if defined(CL_USE_DEPRECATED_OPENCL_1_1_APIS)
1587  inline CL_EXT_PREFIX__VERSION_1_1_DEPRECATED cl_int
1588  UnloadCompiler() CL_EXT_SUFFIX__VERSION_1_1_DEPRECATED;
1589  inline cl_int
1590  UnloadCompiler()
1591  {
1592      return ::clUnloadCompiler();
1593  }
1594  #endif 
1595  class Context 
1596      : public detail::Wrapper&lt;cl_context&gt;
1597  {
1598  private:
1599      static std::once_flag default_initialized_;
1600      static Context default_;
1601      static cl_int default_error_;
1602      static void makeDefault() {
1603  #if defined(CL_HPP_ENABLE_EXCEPTIONS)
1604          try
1605  #endif
1606          {
1607  #if !defined(__APPLE__) &amp;&amp; !defined(__MACOS)
1608              const Platform &amp;p = Platform::getDefault();
1609              cl_platform_id defaultPlatform = p();
1610              cl_context_properties properties[3] = {
1611                  CL_CONTEXT_PLATFORM, (cl_context_properties)defaultPlatform, 0
1612              };
1613  #else 
1614              cl_context_properties *properties = nullptr;
1615  #endif 
1616              default_ = Context(
1617                  CL_DEVICE_TYPE_DEFAULT,
1618                  properties,
1619                  NULL,
1620                  NULL,
1621                  &amp;default_error_);
1622          }
1623  #if defined(CL_HPP_ENABLE_EXCEPTIONS)
1624          catch (cl::Error &amp;e) {
1625              default_error_ = e.err();
1626          }
1627  #endif
1628      }
1629      static void makeDefaultProvided(const Context &amp;c) {
1630          default_ = c;
1631      }
1632  public:
1633  #ifdef CL_HPP_UNIT_TEST_ENABLE
1634      static void unitTestClearDefault() {
1635          default_ = Context();
1636      }
1637  #endif 
1638      Context(
1639          const vector&lt;Device&gt;&amp; devices,
1640          cl_context_properties* properties = NULL,
1641          void (CL_CALLBACK * notifyFptr)(
1642              const char *,
1643              const void *,
1644              size_type,
1645              void *) = NULL,
1646          void* data = NULL,
1647          cl_int* err = NULL)
1648      {
1649          cl_int error;
1650          size_type numDevices = devices.size();
1651          vector&lt;cl_device_id&gt; deviceIDs(numDevices);
1652          for( size_type deviceIndex = 0; deviceIndex &lt; numDevices; ++deviceIndex ) {
1653              deviceIDs[deviceIndex] = (devices[deviceIndex])();
1654          }
1655          object_ = ::clCreateContext(
1656              properties, (cl_uint) numDevices,
1657              deviceIDs.data(),
1658              notifyFptr, data, &amp;error);
1659          detail::errHandler(error, __CREATE_CONTEXT_ERR);
1660          if (err != NULL) {
1661              *err = error;
1662          }
1663      }
<span onclick='openModal()' class='match'>1664      Context(
1665          const Device&amp; device,
1666          cl_context_properties* properties = NULL,
1667          void (CL_CALLBACK * notifyFptr)(
1668              const char *,
1669              const void *,
1670              size_type,
</span>1671              void *) = NULL,
1672          void* data = NULL,
1673          cl_int* err = NULL)
1674      {
1675          cl_int error;
1676          cl_device_id deviceID = device();
1677          object_ = ::clCreateContext(
1678              properties, 1,
1679              &amp;deviceID,
1680              notifyFptr, data, &amp;error);
1681          detail::errHandler(error, __CREATE_CONTEXT_ERR);
1682          if (err != NULL) {
1683              *err = error;
1684          }
1685      }
1686      Context(
1687          cl_device_type type,
1688          cl_context_properties* properties = NULL,
1689          void (CL_CALLBACK * notifyFptr)(
1690              const char *,
1691              const void *,
1692              size_type,
1693              void *) = NULL,
1694          void* data = NULL,
1695          cl_int* err = NULL)
1696      {
1697          cl_int error;
1698  #if !defined(__APPLE__) &amp;&amp; !defined(__MACOS)
1699          cl_context_properties prop[4] = {CL_CONTEXT_PLATFORM, 0, 0, 0 };
1700          if (properties == NULL) {
1701              vector&lt;Platform&gt; platforms;
1702              error = Platform::get(&amp;platforms);
1703              if (error != CL_SUCCESS) {
1704                  detail::errHandler(error, __CREATE_CONTEXT_FROM_TYPE_ERR);
1705                  if (err != NULL) {
1706                      *err = error;
1707                  }
1708                  return;
1709              }
1710              cl_context_properties platform_id = 0;
1711              for (unsigned int i = 0; i &lt; platforms.size(); i++) {
1712                  vector&lt;Device&gt; devices;
1713  #if defined(CL_HPP_ENABLE_EXCEPTIONS)
1714                  try {
1715  #endif
1716                      error = platforms[i].getDevices(type, &amp;devices);
1717  #if defined(CL_HPP_ENABLE_EXCEPTIONS)
1718                  } catch (Error) {}
1719  #endif
1720                  if (error != CL_SUCCESS &amp;&amp; error != CL_DEVICE_NOT_FOUND) {
1721                      detail::errHandler(error, __CREATE_CONTEXT_FROM_TYPE_ERR);
1722                      if (err != NULL) {
1723                          *err = error;
1724                      }
1725                  }
1726                  if (devices.size() &gt; 0) {
1727                      platform_id = (cl_context_properties)platforms[i]();
1728                      break;
1729                  }
1730              }
1731              if (platform_id == 0) {
1732                  detail::errHandler(CL_DEVICE_NOT_FOUND, __CREATE_CONTEXT_FROM_TYPE_ERR);
1733                  if (err != NULL) {
1734                      *err = CL_DEVICE_NOT_FOUND;
1735                  }
1736                  return;
1737              }
1738              prop[1] = platform_id;
1739              properties = &amp;prop[0];
1740          }
1741  #endif
1742          object_ = ::clCreateContextFromType(
1743              properties, type, notifyFptr, data, &amp;error);
1744          detail::errHandler(error, __CREATE_CONTEXT_FROM_TYPE_ERR);
1745          if (err != NULL) {
1746              *err = error;
1747          }
1748      }
1749      Context(const Context&amp; ctx) : detail::Wrapper&lt;cl_type&gt;(ctx) {}
1750      Context&amp; operator = (const Context &amp;ctx)
1751      {
1752          detail::Wrapper&lt;cl_type&gt;::operator=(ctx);
1753          return *this;
1754      }
1755      Context(Context&amp;&amp; ctx) CL_HPP_NOEXCEPT_ : detail::Wrapper&lt;cl_type&gt;(std::move(ctx)) {}
1756      Context&amp; operator = (Context &amp;&amp;ctx)
1757      {
1758          detail::Wrapper&lt;cl_type&gt;::operator=(std::move(ctx));
1759          return *this;
1760      }
1761      static Context getDefault(cl_int * err = NULL) 
1762      {
1763          std::call_once(default_initialized_, makeDefault);
1764          detail::errHandler(default_error_);
1765          if (err != NULL) {
1766              *err = default_error_;
1767          }
1768          return default_;
1769      }
1770      static Context setDefault(const Context &amp;default_context)
1771      {
1772          std::call_once(default_initialized_, makeDefaultProvided, std::cref(default_context));
1773          detail::errHandler(default_error_);
1774          return default_;
1775      }
1776      Context() : detail::Wrapper&lt;cl_type&gt;() { }
1777      explicit Context(const cl_context&amp; context, bool retainObject = false) : 
1778          detail::Wrapper&lt;cl_type&gt;(context, retainObject) { }
1779      Context&amp; operator = (const cl_context&amp; rhs)
1780      {
1781          detail::Wrapper&lt;cl_type&gt;::operator=(rhs);
1782          return *this;
1783      }
1784      template &lt;typename T&gt;
1785      cl_int getInfo(cl_context_info name, T* param) const
1786      {
1787          return detail::errHandler(
1788              detail::getInfo(&amp;::clGetContextInfo, object_, name, param),
1789              __GET_CONTEXT_INFO_ERR);
1790      }
1791      template &lt;cl_int name&gt; typename
1792      detail::param_traits&lt;detail::cl_context_info, name&gt;::param_type
1793      getInfo(cl_int* err = NULL) const
1794      {
1795          typename detail::param_traits&lt;
1796              detail::cl_context_info, name&gt;::param_type param;
1797          cl_int result = getInfo(name, &amp;param);
1798          if (err != NULL) {
1799              *err = result;
1800          }
1801          return param;
1802      }
1803      cl_int getSupportedImageFormats(
1804          cl_mem_flags flags,
1805          cl_mem_object_type type,
1806          vector&lt;ImageFormat&gt;* formats) const
1807      {
1808          cl_uint numEntries;
1809          if (!formats) {
1810              return CL_SUCCESS;
1811          }
1812          cl_int err = ::clGetSupportedImageFormats(
1813             object_, 
1814             flags,
1815             type, 
1816             0, 
1817             NULL, 
1818             &amp;numEntries);
1819          if (err != CL_SUCCESS) {
1820              return detail::errHandler(err, __GET_SUPPORTED_IMAGE_FORMATS_ERR);
1821          }
1822          if (numEntries &gt; 0) {
1823              vector&lt;ImageFormat&gt; value(numEntries);
1824              err = ::clGetSupportedImageFormats(
1825                  object_,
1826                  flags,
1827                  type,
1828                  numEntries,
1829                  (cl_image_format*)value.data(),
1830                  NULL);
1831              if (err != CL_SUCCESS) {
1832                  return detail::errHandler(err, __GET_SUPPORTED_IMAGE_FORMATS_ERR);
1833              }
1834              formats-&gt;assign(begin(value), end(value));
1835          }
1836          else {
1837              formats-&gt;clear();
1838          }
1839          return CL_SUCCESS;
1840      }
1841  };
1842  inline void Device::makeDefault()
1843  {
1844  #if defined(CL_HPP_ENABLE_EXCEPTIONS)
1845      try
1846  #endif
1847      {
1848          cl_int error = 0;
1849          Context context = Context::getDefault(&amp;error);
1850          detail::errHandler(error, __CREATE_CONTEXT_ERR);
1851          if (error != CL_SUCCESS) {
1852              default_error_ = error;
1853          }
1854          else {
1855              default_ = context.getInfo&lt;CL_CONTEXT_DEVICES&gt;()[0];
1856              default_error_ = CL_SUCCESS;
1857          }
1858      }
1859  #if defined(CL_HPP_ENABLE_EXCEPTIONS)
1860      catch (cl::Error &amp;e) {
1861          default_error_ = e.err();
1862      }
1863  #endif
1864  }
1865  CL_HPP_DEFINE_STATIC_MEMBER_ std::once_flag Context::default_initialized_;
1866  CL_HPP_DEFINE_STATIC_MEMBER_ Context Context::default_;
1867  CL_HPP_DEFINE_STATIC_MEMBER_ cl_int Context::default_error_ = CL_SUCCESS;
1868  class Event : public detail::Wrapper&lt;cl_event&gt;
1869  {
1870  public:
1871      Event() : detail::Wrapper&lt;cl_type&gt;() { }
1872      explicit Event(const cl_event&amp; event, bool retainObject = false) : 
1873          detail::Wrapper&lt;cl_type&gt;(event, retainObject) { }
1874      Event&amp; operator = (const cl_event&amp; rhs)
1875      {
1876          detail::Wrapper&lt;cl_type&gt;::operator=(rhs);
1877          return *this;
1878      }
1879      template &lt;typename T&gt;
1880      cl_int getInfo(cl_event_info name, T* param) const
1881      {
1882          return detail::errHandler(
1883              detail::getInfo(&amp;::clGetEventInfo, object_, name, param),
1884              __GET_EVENT_INFO_ERR);
1885      }
1886      template &lt;cl_int name&gt; typename
1887      detail::param_traits&lt;detail::cl_event_info, name&gt;::param_type
1888      getInfo(cl_int* err = NULL) const
1889      {
1890          typename detail::param_traits&lt;
1891              detail::cl_event_info, name&gt;::param_type param;
1892          cl_int result = getInfo(name, &amp;param);
1893          if (err != NULL) {
1894              *err = result;
1895          }
1896          return param;
1897      }
1898      template &lt;typename T&gt;
1899      cl_int getProfilingInfo(cl_profiling_info name, T* param) const
1900      {
1901          return detail::errHandler(detail::getInfo(
1902              &amp;::clGetEventProfilingInfo, object_, name, param),
1903              __GET_EVENT_PROFILE_INFO_ERR);
1904      }
1905      template &lt;cl_int name&gt; typename
1906      detail::param_traits&lt;detail::cl_profiling_info, name&gt;::param_type
1907      getProfilingInfo(cl_int* err = NULL) const
1908      {
1909          typename detail::param_traits&lt;
1910              detail::cl_profiling_info, name&gt;::param_type param;
1911          cl_int result = getProfilingInfo(name, &amp;param);
1912          if (err != NULL) {
1913              *err = result;
1914          }
1915          return param;
1916      }
1917      cl_int wait() const
1918      {
1919          return detail::errHandler(
1920              ::clWaitForEvents(1, &amp;object_),
1921              __WAIT_FOR_EVENTS_ERR);
1922      }
1923  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 110
1924      cl_int setCallback(
1925          cl_int type,
1926          void (CL_CALLBACK * pfn_notify)(cl_event, cl_int, void *),		
1927          void * user_data = NULL)
1928      {
1929          return detail::errHandler(
1930              ::clSetEventCallback(
1931                  object_,
1932                  type,
1933                  pfn_notify,
1934                  user_data), 
1935              __SET_EVENT_CALLBACK_ERR);
1936      }
1937  #endif 
1938      static cl_int
1939      waitForEvents(const vector&lt;Event&gt;&amp; events)
1940      {
1941          return detail::errHandler(
1942              ::clWaitForEvents(
1943                  (cl_uint) events.size(), (events.size() &gt; 0) ? (cl_event*)&amp;events.front() : NULL),
1944              __WAIT_FOR_EVENTS_ERR);
1945      }
1946  };
1947  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 110
1948  class UserEvent : public Event
1949  {
1950  public:
1951      UserEvent(
1952          const Context&amp; context,
1953          cl_int * err = NULL)
1954      {
1955          cl_int error;
1956          object_ = ::clCreateUserEvent(
1957              context(),
1958              &amp;error);
1959          detail::errHandler(error, __CREATE_USER_EVENT_ERR);
1960          if (err != NULL) {
1961              *err = error;
1962          }
1963      }
1964      UserEvent() : Event() { }
1965      cl_int setStatus(cl_int status)
1966      {
1967          return detail::errHandler(
1968              ::clSetUserEventStatus(object_,status), 
1969              __SET_USER_EVENT_STATUS_ERR);
1970      }
1971  };
1972  #endif 
1973  inline static cl_int
1974  WaitForEvents(const vector&lt;Event&gt;&amp; events)
1975  {
1976      return detail::errHandler(
1977          ::clWaitForEvents(
1978              (cl_uint) events.size(), (events.size() &gt; 0) ? (cl_event*)&amp;events.front() : NULL),
1979          __WAIT_FOR_EVENTS_ERR);
1980  }
1981  class Memory : public detail::Wrapper&lt;cl_mem&gt;
1982  {
1983  public:
1984      Memory() : detail::Wrapper&lt;cl_type&gt;() { }
1985      explicit Memory(const cl_mem&amp; memory, bool retainObject) :
1986          detail::Wrapper&lt;cl_type&gt;(memory, retainObject) { }
1987      Memory&amp; operator = (const cl_mem&amp; rhs)
1988      {
1989          detail::Wrapper&lt;cl_type&gt;::operator=(rhs);
1990          return *this;
1991      }
1992      Memory(const Memory&amp; mem) : detail::Wrapper&lt;cl_type&gt;(mem) {}
1993      Memory&amp; operator = (const Memory &amp;mem)
1994      {
1995          detail::Wrapper&lt;cl_type&gt;::operator=(mem);
1996          return *this;
1997      }
1998      Memory(Memory&amp;&amp; mem) CL_HPP_NOEXCEPT_ : detail::Wrapper&lt;cl_type&gt;(std::move(mem)) {}
1999      Memory&amp; operator = (Memory &amp;&amp;mem)
2000      {
2001          detail::Wrapper&lt;cl_type&gt;::operator=(std::move(mem));
2002          return *this;
2003      }
2004      template &lt;typename T&gt;
2005      cl_int getInfo(cl_mem_info name, T* param) const
2006      {
2007          return detail::errHandler(
2008              detail::getInfo(&amp;::clGetMemObjectInfo, object_, name, param),
2009              __GET_MEM_OBJECT_INFO_ERR);
2010      }
2011      template &lt;cl_int name&gt; typename
2012      detail::param_traits&lt;detail::cl_mem_info, name&gt;::param_type
2013      getInfo(cl_int* err = NULL) const
2014      {
2015          typename detail::param_traits&lt;
2016              detail::cl_mem_info, name&gt;::param_type param;
2017          cl_int result = getInfo(name, &amp;param);
2018          if (err != NULL) {
2019              *err = result;
2020          }
2021          return param;
2022      }
2023  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 110
2024      cl_int setDestructorCallback(
2025          void (CL_CALLBACK * pfn_notify)(cl_mem, void *),		
2026          void * user_data = NULL)
2027      {
2028          return detail::errHandler(
2029              ::clSetMemObjectDestructorCallback(
2030                  object_,
2031                  pfn_notify,
2032                  user_data), 
2033              __SET_MEM_OBJECT_DESTRUCTOR_CALLBACK_ERR);
2034      }
2035  #endif 
2036  };
2037  class Buffer;
2038  template&lt; typename IteratorType &gt;
2039  cl_int copy( IteratorType startIterator, IteratorType endIterator, cl::Buffer &amp;buffer );
2040  template&lt; typename IteratorType &gt;
2041  cl_int copy( const cl::Buffer &amp;buffer, IteratorType startIterator, IteratorType endIterator );
2042  template&lt; typename IteratorType &gt;
2043  cl_int copy( const CommandQueue &amp;queue, IteratorType startIterator, IteratorType endIterator, cl::Buffer &amp;buffer );
2044  template&lt; typename IteratorType &gt;
2045  cl_int copy( const CommandQueue &amp;queue, const cl::Buffer &amp;buffer, IteratorType startIterator, IteratorType endIterator );
2046  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 200
2047  namespace detail
2048  {
2049      class SVMTraitNull
2050      {
2051      public:
2052          static cl_svm_mem_flags getSVMMemFlags()
2053          {
2054              return 0;
2055          }
2056      };
2057  } 
2058  template&lt;class Trait = detail::SVMTraitNull&gt;
2059  class SVMTraitReadWrite
2060  {
2061  public:
2062      static cl_svm_mem_flags getSVMMemFlags()
2063      {
2064          return CL_MEM_READ_WRITE |
2065              Trait::getSVMMemFlags();
2066      }
2067  };
2068  template&lt;class Trait = detail::SVMTraitNull&gt;
2069  class SVMTraitReadOnly
2070  {
2071  public:
2072      static cl_svm_mem_flags getSVMMemFlags()
2073      {
2074          return CL_MEM_READ_ONLY |
2075              Trait::getSVMMemFlags();
2076      }
2077  };
2078  template&lt;class Trait = detail::SVMTraitNull&gt;
2079  class SVMTraitWriteOnly
2080  {
2081  public:
2082      static cl_svm_mem_flags getSVMMemFlags()
2083      {
2084          return CL_MEM_WRITE_ONLY |
2085              Trait::getSVMMemFlags();
2086      }
2087  };
2088  template&lt;class Trait = SVMTraitReadWrite&lt;&gt;&gt;
2089  class SVMTraitCoarse
2090  {
2091  public:
2092      static cl_svm_mem_flags getSVMMemFlags()
2093      {
2094          return Trait::getSVMMemFlags();
2095      }
2096  };
2097  template&lt;class Trait = SVMTraitReadWrite&lt;&gt;&gt;
2098  class SVMTraitFine
2099  {
2100  public:
2101      static cl_svm_mem_flags getSVMMemFlags()
2102      {
2103          return CL_MEM_SVM_FINE_GRAIN_BUFFER |
2104              Trait::getSVMMemFlags();
2105      }
2106  };
2107  template&lt;class Trait = SVMTraitReadWrite&lt;&gt;&gt;
2108  class SVMTraitAtomic
2109  {
2110  public:
2111      static cl_svm_mem_flags getSVMMemFlags()
2112      {
2113          return
2114              CL_MEM_SVM_FINE_GRAIN_BUFFER |
2115              CL_MEM_SVM_ATOMICS |
2116              Trait::getSVMMemFlags();
2117      }
2118  };
2119  template&lt;typename T&gt;
2120  inline cl_int enqueueMapSVM(
2121      T* ptr,
2122      cl_bool blocking,
2123      cl_map_flags flags,
2124      size_type size,
2125      const vector&lt;Event&gt;* events = NULL,
2126      Event* event = NULL);
2127  template&lt;typename T, class SVMTrait&gt;
2128  class SVMAllocator {
2129  private:
2130      Context context_;
2131  public:
2132      typedef T value_type;
2133      typedef value_type* pointer;
2134      typedef const value_type* const_pointer;
2135      typedef value_type&amp; reference;
2136      typedef const value_type&amp; const_reference;
2137      typedef std::size_t size_type;
2138      typedef std::ptrdiff_t difference_type;
2139      template&lt;typename U&gt;
2140      struct rebind
2141      {
2142          typedef SVMAllocator&lt;U, SVMTrait&gt; other;
2143      };
2144      template&lt;typename U, typename V&gt;
2145      friend class SVMAllocator;
2146      SVMAllocator() :
2147          context_(Context::getDefault())
2148      {
2149      }
2150      explicit SVMAllocator(cl::Context context) :
2151          context_(context)
2152      {
2153      }
2154      SVMAllocator(const SVMAllocator &amp;other) :
2155          context_(other.context_)
2156      {
2157      }
2158      template&lt;typename U&gt;
2159      SVMAllocator(const SVMAllocator&lt;U, SVMTrait&gt; &amp;other) :
2160          context_(other.context_)
2161      {
2162      }
2163      ~SVMAllocator()
2164      {
2165      }
2166      pointer address(reference r) CL_HPP_NOEXCEPT_
2167      {
2168          return std::addressof(r);
2169      }
2170      const_pointer address(const_reference r) CL_HPP_NOEXCEPT_
2171      {
2172          return std::addressof(r);
2173      }
2174      pointer allocate(
2175          size_type size,
2176          typename cl::SVMAllocator&lt;void, SVMTrait&gt;::const_pointer = 0)
2177      {
2178          void* voidPointer =
2179              clSVMAlloc(
2180              context_(),
2181              SVMTrait::getSVMMemFlags(),
2182              size*sizeof(T),
2183              sizeof(T));
2184          pointer retValue = reinterpret_cast&lt;pointer&gt;(
2185              voidPointer);
2186  #if defined(CL_HPP_ENABLE_EXCEPTIONS)
2187          if (!retValue) {
2188              std::bad_alloc excep;
2189              throw excep;
2190          }
2191  #endif 
2192          if (!(SVMTrait::getSVMMemFlags() &amp; CL_MEM_SVM_FINE_GRAIN_BUFFER)) {
2193              cl_int err = enqueueMapSVM(retValue, CL_TRUE, CL_MAP_READ | CL_MAP_WRITE, size*sizeof(T));
2194              if (err != CL_SUCCESS) {
2195                  std::bad_alloc excep;
2196                  throw excep;
2197              }
2198          }
2199          return retValue;
2200      }
2201      void deallocate(pointer p, size_type)
2202      {
2203          clSVMFree(context_(), p);
2204      }
2205      size_type max_size() const CL_HPP_NOEXCEPT_
2206      {
2207          size_type maxSize = std::numeric_limits&lt;size_type&gt;::max() / sizeof(T);
2208          for (Device &amp;d : context_.getInfo&lt;CL_CONTEXT_DEVICES&gt;()) {
2209              maxSize = std::min(
2210                  maxSize, 
2211                  static_cast&lt;size_type&gt;(d.getInfo&lt;CL_DEVICE_MAX_MEM_ALLOC_SIZE&gt;()));
2212          }
2213          return maxSize;
2214      }
2215      template&lt; class U, class... Args &gt;
2216      void construct(U* p, Args&amp;&amp;... args)
2217      {
2218          new(p)T(args...);
2219      }
2220      template&lt; class U &gt;
2221      void destroy(U* p)
2222      {
2223          p-&gt;~U();
2224      }
2225      inline bool operator==(SVMAllocator const&amp; rhs)
2226      {
2227          return (context_==rhs.context_);
2228      }
2229      inline bool operator!=(SVMAllocator const&amp; a)
2230      {
2231          return !operator==(a);
2232      }
2233  }; 
2234  template&lt;class SVMTrait&gt;
2235  class SVMAllocator&lt;void, SVMTrait&gt; {
2236  public:
2237      typedef void value_type;
2238      typedef value_type* pointer;
2239      typedef const value_type* const_pointer;
2240      template&lt;typename U&gt;
2241      struct rebind
2242      {
2243          typedef SVMAllocator&lt;U, SVMTrait&gt; other;
2244      };
2245      template&lt;typename U, typename V&gt;
2246      friend class SVMAllocator;
2247  };
2248  #if !defined(CL_HPP_NO_STD_UNIQUE_PTR)
2249  namespace detail
2250  {
2251      template&lt;class Alloc&gt;
2252      class Deleter {
2253      private:
2254          Alloc alloc_;
2255          size_type copies_;
2256      public:
2257          typedef typename std::allocator_traits&lt;Alloc&gt;::pointer pointer;
2258          Deleter(const Alloc &amp;alloc, size_type copies) : alloc_{ alloc }, copies_{ copies }
2259          {
2260          }
2261          void operator()(pointer ptr) const {
2262              Alloc tmpAlloc{ alloc_ };
2263              std::allocator_traits&lt;Alloc&gt;::destroy(tmpAlloc, std::addressof(*ptr));
2264              std::allocator_traits&lt;Alloc&gt;::deallocate(tmpAlloc, ptr, copies_);
2265          }
2266      };
2267  } 
2268  template &lt;class T, class Alloc, class... Args&gt;
2269  cl::pointer&lt;T, detail::Deleter&lt;Alloc&gt;&gt; allocate_pointer(const Alloc &amp;alloc_, Args&amp;&amp;... args)
2270  {
2271      Alloc alloc(alloc_);
2272      static const size_t copies = 1;
2273      T* tmp = std::allocator_traits&lt;Alloc&gt;::allocate(alloc, copies);
2274      if (!tmp) {
2275          std::bad_alloc excep;
2276          throw excep;
2277      }
2278      try {
2279          std::allocator_traits&lt;Alloc&gt;::construct(
2280              alloc,
2281              std::addressof(*tmp),
2282              std::forward&lt;Args&gt;(args)...);
2283          return cl::pointer&lt;T, detail::Deleter&lt;Alloc&gt;&gt;(tmp, detail::Deleter&lt;Alloc&gt;{alloc, copies});
2284      }
2285      catch (std::bad_alloc b)
2286      {
2287          std::allocator_traits&lt;Alloc&gt;::deallocate(alloc, tmp, copies);
2288          throw;
2289      }
2290  }
2291  template&lt; class T, class SVMTrait, class... Args &gt;
2292  cl::pointer&lt;T, detail::Deleter&lt;SVMAllocator&lt;T, SVMTrait&gt;&gt;&gt; allocate_svm(Args... args)
2293  {
2294      SVMAllocator&lt;T, SVMTrait&gt; alloc;
2295      return cl::allocate_pointer&lt;T&gt;(alloc, args...);
2296  }
2297  template&lt; class T, class SVMTrait, class... Args &gt;
2298  cl::pointer&lt;T, detail::Deleter&lt;SVMAllocator&lt;T, SVMTrait&gt;&gt;&gt; allocate_svm(const cl::Context &amp;c, Args... args)
2299  {
2300      SVMAllocator&lt;T, SVMTrait&gt; alloc(c);
2301      return cl::allocate_pointer&lt;T&gt;(alloc, args...);
2302  }
2303  #endif 
2304  template &lt; class T &gt;
2305  using coarse_svm_vector = vector&lt;T, cl::SVMAllocator&lt;int, cl::SVMTraitCoarse&lt;&gt;&gt;&gt;;
2306  template &lt; class T &gt;
2307  using fine_svm_vector = vector&lt;T, cl::SVMAllocator&lt;int, cl::SVMTraitFine&lt;&gt;&gt;&gt;;
2308  template &lt; class T &gt;
2309  using atomic_svm_vector = vector&lt;T, cl::SVMAllocator&lt;int, cl::SVMTraitAtomic&lt;&gt;&gt;&gt;;
2310  #endif 
2311  class Buffer : public Memory
2312  {
2313  public:
2314      Buffer(
2315          const Context&amp; context,
2316          cl_mem_flags flags,
2317          size_type size,
2318          void* host_ptr = NULL,
2319          cl_int* err = NULL)
2320      {
2321          cl_int error;
2322          object_ = ::clCreateBuffer(context(), flags, size, host_ptr, &amp;error);
2323          detail::errHandler(error, __CREATE_BUFFER_ERR);
2324          if (err != NULL) {
2325              *err = error;
2326          }
2327      }
2328      Buffer(
2329           cl_mem_flags flags,
2330          size_type size,
2331          void* host_ptr = NULL,
2332          cl_int* err = NULL)
2333      {
2334          cl_int error;
2335          Context context = Context::getDefault(err);
2336          object_ = ::clCreateBuffer(context(), flags, size, host_ptr, &amp;error);
2337          detail::errHandler(error, __CREATE_BUFFER_ERR);
2338          if (err != NULL) {
2339              *err = error;
2340          }
2341      }
2342      template&lt; typename IteratorType &gt;
2343      Buffer(
2344          IteratorType startIterator,
2345          IteratorType endIterator,
2346          bool readOnly,
2347          bool useHostPtr = false,
2348          cl_int* err = NULL)
2349      {
2350          typedef typename std::iterator_traits&lt;IteratorType&gt;::value_type DataType;
2351          cl_int error;
2352          cl_mem_flags flags = 0;
2353          if( readOnly ) {
2354              flags |= CL_MEM_READ_ONLY;
2355          }
2356          else {
2357              flags |= CL_MEM_READ_WRITE;
2358          }
2359          if( useHostPtr ) {
2360              flags |= CL_MEM_USE_HOST_PTR;
2361          }
2362          size_type size = sizeof(DataType)*(endIterator - startIterator);
2363          Context context = Context::getDefault(err);
2364          if( useHostPtr ) {
2365              object_ = ::clCreateBuffer(context(), flags, size, static_cast&lt;DataType*&gt;(&amp;*startIterator), &amp;error);
2366          } else {
2367              object_ = ::clCreateBuffer(context(), flags, size, 0, &amp;error);
2368          }
2369          detail::errHandler(error, __CREATE_BUFFER_ERR);
2370          if (err != NULL) {
2371              *err = error;
2372          }
2373          if( !useHostPtr ) {
2374              error = cl::copy(startIterator, endIterator, *this);
2375              detail::errHandler(error, __CREATE_BUFFER_ERR);
2376              if (err != NULL) {
2377                  *err = error;
2378              }
2379          }
2380      }
2381      template&lt; typename IteratorType &gt;
2382      Buffer(const Context &amp;context, IteratorType startIterator, IteratorType endIterator,
2383          bool readOnly, bool useHostPtr = false, cl_int* err = NULL);
2384      template&lt; typename IteratorType &gt;
2385      Buffer(const CommandQueue &amp;queue, IteratorType startIterator, IteratorType endIterator,
2386          bool readOnly, bool useHostPtr = false, cl_int* err = NULL);
2387      Buffer() : Memory() { }
2388      explicit Buffer(const cl_mem&amp; buffer, bool retainObject = false) :
2389          Memory(buffer, retainObject) { }
2390      Buffer&amp; operator = (const cl_mem&amp; rhs)
2391      {
2392          Memory::operator=(rhs);
2393          return *this;
2394      }
2395      Buffer(const Buffer&amp; buf) : Memory(buf) {}
2396      Buffer&amp; operator = (const Buffer &amp;buf)
2397      {
2398          Memory::operator=(buf);
2399          return *this;
2400      }
2401      Buffer(Buffer&amp;&amp; buf) CL_HPP_NOEXCEPT_ : Memory(std::move(buf)) {}
2402      Buffer&amp; operator = (Buffer &amp;&amp;buf)
2403      {
2404          Memory::operator=(std::move(buf));
2405          return *this;
2406      }
2407  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 110
2408      Buffer createSubBuffer(
2409          cl_mem_flags flags,
2410          cl_buffer_create_type buffer_create_type,
2411          const void * buffer_create_info,
2412          cl_int * err = NULL)
2413      {
2414          Buffer result;
2415          cl_int error;
2416          result.object_ = ::clCreateSubBuffer(
2417              object_, 
2418              flags, 
2419              buffer_create_type, 
2420              buffer_create_info, 
2421              &amp;error);
2422          detail::errHandler(error, __CREATE_SUBBUFFER_ERR);
2423          if (err != NULL) {
2424              *err = error;
2425          }
2426          return result;
2427      }		
2428  #endif 
2429  };
2430  #if defined (CL_HPP_USE_DX_INTEROP)
2431  class BufferD3D10 : public Buffer
2432  {
2433  public:
2434      BufferD3D10(
2435          const Context&amp; context,
2436          cl_mem_flags flags,
2437          ID3D10Buffer* bufobj,
2438          cl_int * err = NULL) : pfn_clCreateFromD3D10BufferKHR(nullptr)
2439      {
2440          typedef CL_API_ENTRY cl_mem (CL_API_CALL *PFN_clCreateFromD3D10BufferKHR)(
2441              cl_context context, cl_mem_flags flags, ID3D10Buffer*  buffer,
2442              cl_int* errcode_ret);
2443          PFN_clCreateFromD3D10BufferKHR pfn_clCreateFromD3D10BufferKHR;
2444  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 120
2445          vector&lt;cl_context_properties&gt; props = context.getInfo&lt;CL_CONTEXT_PROPERTIES&gt;();
2446          cl_platform platform = -1;
2447          for( int i = 0; i &lt; props.size(); ++i ) {
2448              if( props[i] == CL_CONTEXT_PLATFORM ) {
2449                  platform = props[i+1];
2450              }
2451          }
2452          CL_HPP_INIT_CL_EXT_FCN_PTR_PLATFORM_(platform, clCreateFromD3D10BufferKHR);
2453  #elif CL_HPP_TARGET_OPENCL_VERSION &gt;= 110
2454          CL_HPP_INIT_CL_EXT_FCN_PTR_(clCreateFromD3D10BufferKHR);
2455  #endif
2456          cl_int error;
2457          object_ = pfn_clCreateFromD3D10BufferKHR(
2458              context(),
2459              flags,
2460              bufobj,
2461              &amp;error);
2462          detail::errHandler(error, __CREATE_GL_BUFFER_ERR);
2463          if (err != NULL) {
2464              *err = error;
2465          }
2466      }
2467      BufferD3D10() : Buffer() { }
2468      explicit BufferD3D10(const cl_mem&amp; buffer, bool retainObject = false) : 
2469          Buffer(buffer, retainObject) { }
2470      BufferD3D10&amp; operator = (const cl_mem&amp; rhs)
2471      {
2472          Buffer::operator=(rhs);
2473          return *this;
2474      }
2475      BufferD3D10(const BufferD3D10&amp; buf) : 
2476          Buffer(buf) {}
2477      BufferD3D10&amp; operator = (const BufferD3D10 &amp;buf)
2478      {
2479          Buffer::operator=(buf);
2480          return *this;
2481      }
2482      BufferD3D10(BufferD3D10&amp;&amp; buf) CL_HPP_NOEXCEPT_ : Buffer(std::move(buf)) {}
2483      BufferD3D10&amp; operator = (BufferD3D10 &amp;&amp;buf)
2484      {
2485          Buffer::operator=(std::move(buf));
2486          return *this;
2487      }
2488  };
2489  #endif
2490  class BufferGL : public Buffer
2491  {
2492  public:
2493      BufferGL(
2494          const Context&amp; context,
2495          cl_mem_flags flags,
2496          cl_GLuint bufobj,
2497          cl_int * err = NULL)
2498      {
2499          cl_int error;
2500          object_ = ::clCreateFromGLBuffer(
2501              context(),
2502              flags,
2503              bufobj,
2504              &amp;error);
2505          detail::errHandler(error, __CREATE_GL_BUFFER_ERR);
2506          if (err != NULL) {
2507              *err = error;
2508          }
2509      }
2510      BufferGL() : Buffer() { }
2511      explicit BufferGL(const cl_mem&amp; buffer, bool retainObject = false) :
2512          Buffer(buffer, retainObject) { }
2513      BufferGL&amp; operator = (const cl_mem&amp; rhs)
2514      {
2515          Buffer::operator=(rhs);
2516          return *this;
2517      }
2518      BufferGL(const BufferGL&amp; buf) : Buffer(buf) {}
2519      BufferGL&amp; operator = (const BufferGL &amp;buf)
2520      {
2521          Buffer::operator=(buf);
2522          return *this;
2523      }
2524      BufferGL(BufferGL&amp;&amp; buf) CL_HPP_NOEXCEPT_ : Buffer(std::move(buf)) {}
2525      BufferGL&amp; operator = (BufferGL &amp;&amp;buf)
2526      {
2527          Buffer::operator=(std::move(buf));
2528          return *this;
2529      }
2530      cl_int getObjectInfo(
2531          cl_gl_object_type *type,
2532          cl_GLuint * gl_object_name)
2533      {
2534          return detail::errHandler(
2535              ::clGetGLObjectInfo(object_,type,gl_object_name),
2536              __GET_GL_OBJECT_INFO_ERR);
2537      }
2538  };
2539  class BufferRenderGL : public Buffer
2540  {
2541  public:
2542      BufferRenderGL(
2543          const Context&amp; context,
2544          cl_mem_flags flags,
2545          cl_GLuint bufobj,
2546          cl_int * err = NULL)
2547      {
2548          cl_int error;
2549          object_ = ::clCreateFromGLRenderbuffer(
2550              context(),
2551              flags,
2552              bufobj,
2553              &amp;error);
2554          detail::errHandler(error, __CREATE_GL_RENDER_BUFFER_ERR);
2555          if (err != NULL) {
2556              *err = error;
2557          }
2558      }
2559      BufferRenderGL() : Buffer() { }
2560      explicit BufferRenderGL(const cl_mem&amp; buffer, bool retainObject = false) :
2561          Buffer(buffer, retainObject) { }
2562      BufferRenderGL&amp; operator = (const cl_mem&amp; rhs)
2563      {
2564          Buffer::operator=(rhs);
2565          return *this;
2566      }
2567      BufferRenderGL(const BufferRenderGL&amp; buf) : Buffer(buf) {}
2568      BufferRenderGL&amp; operator = (const BufferRenderGL &amp;buf)
2569      {
2570          Buffer::operator=(buf);
2571          return *this;
2572      }
2573      BufferRenderGL(BufferRenderGL&amp;&amp; buf) CL_HPP_NOEXCEPT_ : Buffer(std::move(buf)) {}
2574      BufferRenderGL&amp; operator = (BufferRenderGL &amp;&amp;buf)
2575      {
2576          Buffer::operator=(std::move(buf));
2577          return *this;
2578      }
2579      cl_int getObjectInfo(
2580          cl_gl_object_type *type,
2581          cl_GLuint * gl_object_name)
2582      {
2583          return detail::errHandler(
2584              ::clGetGLObjectInfo(object_,type,gl_object_name),
2585              __GET_GL_OBJECT_INFO_ERR);
2586      }
2587  };
2588  class Image : public Memory
2589  {
2590  protected:
2591      Image() : Memory() { }
2592      explicit Image(const cl_mem&amp; image, bool retainObject = false) :
2593          Memory(image, retainObject) { }
2594      Image&amp; operator = (const cl_mem&amp; rhs)
2595      {
2596          Memory::operator=(rhs);
2597          return *this;
2598      }
2599      Image(const Image&amp; img) : Memory(img) {}
2600      Image&amp; operator = (const Image &amp;img)
2601      {
2602          Memory::operator=(img);
2603          return *this;
2604      }
2605      Image(Image&amp;&amp; img) CL_HPP_NOEXCEPT_ : Memory(std::move(img)) {}
2606      Image&amp; operator = (Image &amp;&amp;img)
2607      {
2608          Memory::operator=(std::move(img));
2609          return *this;
2610      }
2611  public:
2612      template &lt;typename T&gt;
2613      cl_int getImageInfo(cl_image_info name, T* param) const
2614      {
2615          return detail::errHandler(
2616              detail::getInfo(&amp;::clGetImageInfo, object_, name, param),
2617              __GET_IMAGE_INFO_ERR);
2618      }
2619      template &lt;cl_int name&gt; typename
2620      detail::param_traits&lt;detail::cl_image_info, name&gt;::param_type
2621      getImageInfo(cl_int* err = NULL) const
2622      {
2623          typename detail::param_traits&lt;
2624              detail::cl_image_info, name&gt;::param_type param;
2625          cl_int result = getImageInfo(name, &amp;param);
2626          if (err != NULL) {
2627              *err = result;
2628          }
2629          return param;
2630      }
2631  };
2632  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 120
2633  class Image1D : public Image
2634  {
2635  public:
2636      Image1D(
2637          const Context&amp; context,
2638          cl_mem_flags flags,
2639          ImageFormat format,
2640          size_type width,
2641          void* host_ptr = NULL,
2642          cl_int* err = NULL)
2643      {
2644          cl_int error;
2645          cl_image_desc desc =
2646          {
2647              CL_MEM_OBJECT_IMAGE1D,
2648              width,
2649              0, 0, 0, 0, 0, 0, 0, 0
2650          };
2651          object_ = ::clCreateImage(
2652              context(), 
2653              flags, 
2654              &amp;format, 
2655              &amp;desc, 
2656              host_ptr, 
2657              &amp;error);
2658          detail::errHandler(error, __CREATE_IMAGE_ERR);
2659          if (err != NULL) {
2660              *err = error;
2661          }
2662      }
2663      Image1D() { }
2664      explicit Image1D(const cl_mem&amp; image1D, bool retainObject = false) :
2665          Image(image1D, retainObject) { }
2666      Image1D&amp; operator = (const cl_mem&amp; rhs)
2667      {
2668          Image::operator=(rhs);
2669          return *this;
2670      }
2671      Image1D(const Image1D&amp; img) : Image(img) {}
2672      Image1D&amp; operator = (const Image1D &amp;img)
2673      {
2674          Image::operator=(img);
2675          return *this;
2676      }
2677      Image1D(Image1D&amp;&amp; img) CL_HPP_NOEXCEPT_ : Image(std::move(img)) {}
2678      Image1D&amp; operator = (Image1D &amp;&amp;img)
2679      {
2680          Image::operator=(std::move(img));
2681          return *this;
2682      }
2683  };
2684  class Image1DBuffer : public Image
2685  {
2686  public:
2687      Image1DBuffer(
2688          const Context&amp; context,
2689          cl_mem_flags flags,
2690          ImageFormat format,
2691          size_type width,
2692          const Buffer &amp;buffer,
2693          cl_int* err = NULL)
2694      {
2695          cl_int error;
2696          cl_image_desc desc =
2697          {
2698              CL_MEM_OBJECT_IMAGE1D_BUFFER,
2699              width,
2700              0, 0, 0, 0, 0, 0, 0,
2701              buffer()
2702          };
2703          object_ = ::clCreateImage(
2704              context(), 
2705              flags, 
2706              &amp;format, 
2707              &amp;desc, 
2708              NULL, 
2709              &amp;error);
2710          detail::errHandler(error, __CREATE_IMAGE_ERR);
2711          if (err != NULL) {
2712              *err = error;
2713          }
2714      }
2715      Image1DBuffer() { }
2716      explicit Image1DBuffer(const cl_mem&amp; image1D, bool retainObject = false) :
2717          Image(image1D, retainObject) { }
2718      Image1DBuffer&amp; operator = (const cl_mem&amp; rhs)
2719      {
2720          Image::operator=(rhs);
2721          return *this;
2722      }
2723      Image1DBuffer(const Image1DBuffer&amp; img) : Image(img) {}
2724      Image1DBuffer&amp; operator = (const Image1DBuffer &amp;img)
2725      {
2726          Image::operator=(img);
2727          return *this;
2728      }
2729      Image1DBuffer(Image1DBuffer&amp;&amp; img) CL_HPP_NOEXCEPT_ : Image(std::move(img)) {}
2730      Image1DBuffer&amp; operator = (Image1DBuffer &amp;&amp;img)
2731      {
2732          Image::operator=(std::move(img));
2733          return *this;
2734      }
2735  };
2736  class Image1DArray : public Image
2737  {
2738  public:
2739      Image1DArray(
2740          const Context&amp; context,
2741          cl_mem_flags flags,
2742          ImageFormat format,
2743          size_type arraySize,
2744          size_type width,
2745          size_type rowPitch,
2746          void* host_ptr = NULL,
2747          cl_int* err = NULL)
2748      {
2749          cl_int error;
2750          cl_image_desc desc =
2751          {
2752              CL_MEM_OBJECT_IMAGE1D_ARRAY,
2753              width,
2754              0, 0,  
2755              arraySize,
2756              rowPitch,
2757              0, 0, 0, 0
2758          };
2759          object_ = ::clCreateImage(
2760              context(), 
2761              flags, 
2762              &amp;format, 
2763              &amp;desc, 
2764              host_ptr, 
2765              &amp;error);
2766          detail::errHandler(error, __CREATE_IMAGE_ERR);
2767          if (err != NULL) {
2768              *err = error;
2769          }
2770      }
2771      Image1DArray() { }
2772      explicit Image1DArray(const cl_mem&amp; imageArray, bool retainObject = false) :
2773          Image(imageArray, retainObject) { }
2774      Image1DArray&amp; operator = (const cl_mem&amp; rhs)
2775      {
2776          Image::operator=(rhs);
2777          return *this;
2778      }
2779      Image1DArray(const Image1DArray&amp; img) : Image(img) {}
2780      Image1DArray&amp; operator = (const Image1DArray &amp;img)
2781      {
2782          Image::operator=(img);
2783          return *this;
2784      }
2785      Image1DArray(Image1DArray&amp;&amp; img) CL_HPP_NOEXCEPT_ : Image(std::move(img)) {}
2786      Image1DArray&amp; operator = (Image1DArray &amp;&amp;img)
2787      {
2788          Image::operator=(std::move(img));
2789          return *this;
2790      }
2791  };
2792  #endif 
2793  class Image2D : public Image
2794  {
2795  public:
2796      Image2D(
2797          const Context&amp; context,
2798          cl_mem_flags flags,
2799          ImageFormat format,
2800          size_type width,
2801          size_type height,
2802          size_type row_pitch = 0,
2803          void* host_ptr = NULL,
2804          cl_int* err = NULL)
2805      {
2806          cl_int error;
2807          bool useCreateImage;
2808  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 120 &amp;&amp; CL_HPP_MINIMUM_OPENCL_VERSION &lt; 120
2809          {
2810              cl_uint version = detail::getContextPlatformVersion(context());
2811              useCreateImage = (version &gt;= 0x10002); 
2812          }
2813  #elif CL_HPP_TARGET_OPENCL_VERSION &gt;= 120
2814          useCreateImage = true;
2815  #else
2816          useCreateImage = false;
2817  #endif
2818  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 120
2819          if (useCreateImage)
2820          {
2821              cl_image_desc desc =
2822              {
2823                  CL_MEM_OBJECT_IMAGE2D,
2824                  width,
2825                  height,
2826                  0, 0, 
2827                  row_pitch,
2828                  0, 0, 0, 0
2829              };
2830              object_ = ::clCreateImage(
2831                  context(),
2832                  flags,
2833                  &amp;format,
2834                  &amp;desc,
2835                  host_ptr,
2836                  &amp;error);
2837              detail::errHandler(error, __CREATE_IMAGE_ERR);
2838              if (err != NULL) {
2839                  *err = error;
2840              }
2841          }
2842  #endif 
2843  #if CL_HPP_MINIMUM_OPENCL_VERSION &lt; 120
2844          if (!useCreateImage)
2845          {
2846              object_ = ::clCreateImage2D(
2847                  context(), flags,&amp;format, width, height, row_pitch, host_ptr, &amp;error);
2848              detail::errHandler(error, __CREATE_IMAGE2D_ERR);
2849              if (err != NULL) {
2850                  *err = error;
2851              }
2852          }
2853  #endif 
2854      }
2855  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 200
2856      Image2D(
2857          const Context&amp; context,
2858          ImageFormat format,
2859          const Buffer &amp;sourceBuffer,
2860          size_type width,
2861          size_type height,
2862          size_type row_pitch = 0,
2863          cl_int* err = nullptr)
2864      {
2865          cl_int error;
2866          cl_image_desc desc =
2867          {
2868              CL_MEM_OBJECT_IMAGE2D,
2869              width,
2870              height,
2871              0, 0, 
2872              row_pitch,
2873              0, 0, 0,
2874              sourceBuffer()
2875          };
2876          object_ = ::clCreateImage(
2877              context(),
2878              0, 
2879              &amp;format,
2880              &amp;desc,
2881              nullptr,
2882              &amp;error);
2883          detail::errHandler(error, __CREATE_IMAGE_ERR);
2884          if (err != nullptr) {
2885              *err = error;
2886          }
2887      }
2888  #endif 
2889  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 200
2890      Image2D(
2891          const Context&amp; context,
2892          cl_channel_order order,
2893          const Image &amp;sourceImage,
2894          cl_int* err = nullptr)
2895      {
2896          cl_int error;
2897          size_type sourceWidth = 
2898              sourceImage.getImageInfo&lt;CL_IMAGE_WIDTH&gt;();
2899          size_type sourceHeight = 
2900              sourceImage.getImageInfo&lt;CL_IMAGE_HEIGHT&gt;();
2901          size_type sourceRowPitch =
2902              sourceImage.getImageInfo&lt;CL_IMAGE_ROW_PITCH&gt;();
2903          cl_uint sourceNumMIPLevels =
2904              sourceImage.getImageInfo&lt;CL_IMAGE_NUM_MIP_LEVELS&gt;();
2905          cl_uint sourceNumSamples =
2906              sourceImage.getImageInfo&lt;CL_IMAGE_NUM_SAMPLES&gt;();
2907          cl_image_format sourceFormat =
2908              sourceImage.getImageInfo&lt;CL_IMAGE_FORMAT&gt;();
2909          sourceFormat.image_channel_order = order;
2910          cl_image_desc desc =
2911          {
2912              CL_MEM_OBJECT_IMAGE2D,
2913              sourceWidth,
2914              sourceHeight,
2915              0, 0, 
2916              sourceRowPitch,
2917              0, 
2918              sourceNumMIPLevels,
2919              sourceNumSamples,
2920              sourceImage()
2921          };
2922          object_ = ::clCreateImage(
2923              context(),
2924              0, 
2925              &amp;sourceFormat,
2926              &amp;desc,
2927              nullptr,
2928              &amp;error);
2929          detail::errHandler(error, __CREATE_IMAGE_ERR);
2930          if (err != nullptr) {
2931              *err = error;
2932          }
2933      }
2934  #endif 
2935      Image2D() { }
2936      explicit Image2D(const cl_mem&amp; image2D, bool retainObject = false) :
2937          Image(image2D, retainObject) { }
2938      Image2D&amp; operator = (const cl_mem&amp; rhs)
2939      {
2940          Image::operator=(rhs);
2941          return *this;
2942      }
2943      Image2D(const Image2D&amp; img) : Image(img) {}
2944      Image2D&amp; operator = (const Image2D &amp;img)
2945      {
2946          Image::operator=(img);
2947          return *this;
2948      }
2949      Image2D(Image2D&amp;&amp; img) CL_HPP_NOEXCEPT_ : Image(std::move(img)) {}
2950      Image2D&amp; operator = (Image2D &amp;&amp;img)
2951      {
2952          Image::operator=(std::move(img));
2953          return *this;
2954      }
2955  };
2956  #if defined(CL_USE_DEPRECATED_OPENCL_1_1_APIS)
2957  class CL_EXT_PREFIX__VERSION_1_1_DEPRECATED Image2DGL : public Image2D 
2958  {
2959  public:
2960      Image2DGL(
2961          const Context&amp; context,
2962          cl_mem_flags flags,
2963          cl_GLenum target,
2964          cl_GLint  miplevel,
2965          cl_GLuint texobj,
2966          cl_int * err = NULL)
2967      {
2968          cl_int error;
2969          object_ = ::clCreateFromGLTexture2D(
2970              context(),
2971              flags,
2972              target,
2973              miplevel,
2974              texobj,
2975              &amp;error);
2976          detail::errHandler(error, __CREATE_GL_TEXTURE_2D_ERR);
2977          if (err != NULL) {
2978              *err = error;
2979          }
2980      }
2981      Image2DGL() : Image2D() { }
2982      explicit Image2DGL(const cl_mem&amp; image, bool retainObject = false) : 
2983          Image2D(image, retainObject) { }
2984      Image2DGL&amp; operator = (const cl_mem&amp; rhs)
2985      {
2986          Image2D::operator=(rhs);
2987          return *this;
2988      }
2989      Image2DGL(const Image2DGL&amp; img) : Image2D(img) {}
2990      Image2DGL&amp; operator = (const Image2DGL &amp;img)
2991      {
2992          Image2D::operator=(img);
2993          return *this;
2994      }
2995      Image2DGL(Image2DGL&amp;&amp; img) CL_HPP_NOEXCEPT_ : Image2D(std::move(img)) {}
2996      Image2DGL&amp; operator = (Image2DGL &amp;&amp;img)
2997      {
2998          Image2D::operator=(std::move(img));
2999          return *this;
3000      }
3001  } CL_EXT_SUFFIX__VERSION_1_1_DEPRECATED;
3002  #endif 
3003  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 120
3004  class Image2DArray : public Image
3005  {
3006  public:
3007      Image2DArray(
3008          const Context&amp; context,
3009          cl_mem_flags flags,
3010          ImageFormat format,
3011          size_type arraySize,
3012          size_type width,
3013          size_type height,
3014          size_type rowPitch,
3015          size_type slicePitch,
3016          void* host_ptr = NULL,
3017          cl_int* err = NULL)
3018      {
3019          cl_int error;
3020          cl_image_desc desc =
3021          {
3022              CL_MEM_OBJECT_IMAGE2D_ARRAY,
3023              width,
3024              height,
3025              0,       
3026              arraySize,
3027              rowPitch,
3028              slicePitch,
3029              0, 0, 0
3030          };
3031          object_ = ::clCreateImage(
3032              context(), 
3033              flags, 
3034              &amp;format, 
3035              &amp;desc, 
3036              host_ptr, 
3037              &amp;error);
3038          detail::errHandler(error, __CREATE_IMAGE_ERR);
3039          if (err != NULL) {
3040              *err = error;
3041          }
3042      }
3043      Image2DArray() { }
3044      explicit Image2DArray(const cl_mem&amp; imageArray, bool retainObject = false) : Image(imageArray, retainObject) { }
3045      Image2DArray&amp; operator = (const cl_mem&amp; rhs)
3046      {
3047          Image::operator=(rhs);
3048          return *this;
3049      }
3050      Image2DArray(const Image2DArray&amp; img) : Image(img) {}
3051      Image2DArray&amp; operator = (const Image2DArray &amp;img)
3052      {
3053          Image::operator=(img);
3054          return *this;
3055      }
3056      Image2DArray(Image2DArray&amp;&amp; img) CL_HPP_NOEXCEPT_ : Image(std::move(img)) {}
3057      Image2DArray&amp; operator = (Image2DArray &amp;&amp;img)
3058      {
3059          Image::operator=(std::move(img));
3060          return *this;
3061      }
3062  };
3063  #endif 
3064  class Image3D : public Image
3065  {
3066  public:
3067      Image3D(
3068          const Context&amp; context,
3069          cl_mem_flags flags,
3070          ImageFormat format,
3071          size_type width,
3072          size_type height,
3073          size_type depth,
3074          size_type row_pitch = 0,
3075          size_type slice_pitch = 0,
3076          void* host_ptr = NULL,
3077          cl_int* err = NULL)
3078      {
3079          cl_int error;
3080          bool useCreateImage;
3081  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 120 &amp;&amp; CL_HPP_MINIMUM_OPENCL_VERSION &lt; 120
3082          {
3083              cl_uint version = detail::getContextPlatformVersion(context());
3084              useCreateImage = (version &gt;= 0x10002); 
3085          }
3086  #elif CL_HPP_TARGET_OPENCL_VERSION &gt;= 120
3087          useCreateImage = true;
3088  #else
3089          useCreateImage = false;
3090  #endif
3091  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 120
3092          if (useCreateImage)
3093          {
3094              cl_image_desc desc =
3095              {
3096                  CL_MEM_OBJECT_IMAGE3D,
3097                  width,
3098                  height,
3099                  depth,
3100                  0,      
3101                  row_pitch,
3102                  slice_pitch,
3103                  0, 0, 0
3104              };
3105              object_ = ::clCreateImage(
3106                  context(), 
3107                  flags, 
3108                  &amp;format, 
3109                  &amp;desc, 
3110                  host_ptr, 
3111                  &amp;error);
3112              detail::errHandler(error, __CREATE_IMAGE_ERR);
3113              if (err != NULL) {
3114                  *err = error;
3115              }
3116          }
3117  #endif  
3118  #if CL_HPP_MINIMUM_OPENCL_VERSION &lt; 120
3119          if (!useCreateImage)
3120          {
3121              object_ = ::clCreateImage3D(
3122                  context(), flags, &amp;format, width, height, depth, row_pitch,
3123                  slice_pitch, host_ptr, &amp;error);
3124              detail::errHandler(error, __CREATE_IMAGE3D_ERR);
3125              if (err != NULL) {
3126                  *err = error;
3127              }
3128          }
3129  #endif 
3130      }
3131      Image3D() : Image() { }
3132      explicit Image3D(const cl_mem&amp; image3D, bool retainObject = false) : 
3133          Image(image3D, retainObject) { }
3134      Image3D&amp; operator = (const cl_mem&amp; rhs)
3135      {
3136          Image::operator=(rhs);
3137          return *this;
3138      }
3139      Image3D(const Image3D&amp; img) : Image(img) {}
3140      Image3D&amp; operator = (const Image3D &amp;img)
3141      {
3142          Image::operator=(img);
3143          return *this;
3144      }
3145      Image3D(Image3D&amp;&amp; img) CL_HPP_NOEXCEPT_ : Image(std::move(img)) {}
3146      Image3D&amp; operator = (Image3D &amp;&amp;img)
3147      {
3148          Image::operator=(std::move(img));
3149          return *this;
3150      }
3151  };
3152  #if defined(CL_USE_DEPRECATED_OPENCL_1_1_APIS)
3153  class Image3DGL : public Image3D
3154  {
3155  public:
3156      Image3DGL(
3157          const Context&amp; context,
3158          cl_mem_flags flags,
3159          cl_GLenum target,
3160          cl_GLint  miplevel,
3161          cl_GLuint texobj,
3162          cl_int * err = NULL)
3163      {
3164          cl_int error;
3165          object_ = ::clCreateFromGLTexture3D(
3166              context(),
3167              flags,
3168              target,
3169              miplevel,
3170              texobj,
3171              &amp;error);
3172          detail::errHandler(error, __CREATE_GL_TEXTURE_3D_ERR);
3173          if (err != NULL) {
3174              *err = error;
3175          }
3176      }
3177      Image3DGL() : Image3D() { }
3178      explicit Image3DGL(const cl_mem&amp; image, bool retainObject = false) : 
3179          Image3D(image, retainObject) { }
3180      Image3DGL&amp; operator = (const cl_mem&amp; rhs)
3181      {
3182          Image3D::operator=(rhs);
3183          return *this;
3184      }
3185      Image3DGL(const Image3DGL&amp; img) : Image3D(img) {}
3186      Image3DGL&amp; operator = (const Image3DGL &amp;img)
3187      {
3188          Image3D::operator=(img);
3189          return *this;
3190      }
3191      Image3DGL(Image3DGL&amp;&amp; img) CL_HPP_NOEXCEPT_ : Image3D(std::move(img)) {}
3192      Image3DGL&amp; operator = (Image3DGL &amp;&amp;img)
3193      {
3194          Image3D::operator=(std::move(img));
3195          return *this;
3196      }
3197  };
3198  #endif 
3199  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 120
3200  class ImageGL : public Image
3201  {
3202  public:
3203      ImageGL(
3204          const Context&amp; context,
3205          cl_mem_flags flags,
3206          cl_GLenum target,
3207          cl_GLint  miplevel,
3208          cl_GLuint texobj,
3209          cl_int * err = NULL)
3210      {
3211          cl_int error;
3212          object_ = ::clCreateFromGLTexture(
3213              context(), 
3214              flags, 
3215              target,
3216              miplevel,
3217              texobj,
3218              &amp;error);
3219          detail::errHandler(error, __CREATE_GL_TEXTURE_ERR);
3220          if (err != NULL) {
3221              *err = error;
3222          }
3223      }
3224      ImageGL() : Image() { }
3225      explicit ImageGL(const cl_mem&amp; image, bool retainObject = false) : 
3226          Image(image, retainObject) { }
3227      ImageGL&amp; operator = (const cl_mem&amp; rhs)
3228      {
3229          Image::operator=(rhs);
3230          return *this;
3231      }
3232      ImageGL(const ImageGL&amp; img) : Image(img) {}
3233      ImageGL&amp; operator = (const ImageGL &amp;img)
3234      {
3235          Image::operator=(img);
3236          return *this;
3237      }
3238      ImageGL(ImageGL&amp;&amp; img) CL_HPP_NOEXCEPT_ : Image(std::move(img)) {}
3239      ImageGL&amp; operator = (ImageGL &amp;&amp;img)
3240      {
3241          Image::operator=(std::move(img));
3242          return *this;
3243      }
3244  };
3245  #endif 
3246  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 200
3247  class Pipe : public Memory
3248  {
3249  public:
3250      Pipe(
3251          const Context&amp; context,
3252          cl_uint packet_size,
3253          cl_uint max_packets,
3254          cl_int* err = NULL)
3255      {
3256          cl_int error;
3257          cl_mem_flags flags = CL_MEM_READ_WRITE | CL_MEM_HOST_NO_ACCESS;
3258          object_ = ::clCreatePipe(context(), flags, packet_size, max_packets, nullptr, &amp;error);
3259          detail::errHandler(error, __CREATE_PIPE_ERR);
3260          if (err != NULL) {
3261              *err = error;
3262          }
3263      }
3264      Pipe(
3265          cl_uint packet_size,
3266          cl_uint max_packets,
3267          cl_int* err = NULL)
3268      {
3269          cl_int error;
3270          Context context = Context::getDefault(err);
3271          cl_mem_flags flags = CL_MEM_READ_WRITE | CL_MEM_HOST_NO_ACCESS;
3272          object_ = ::clCreatePipe(context(), flags, packet_size, max_packets, nullptr, &amp;error);
3273          detail::errHandler(error, __CREATE_PIPE_ERR);
3274          if (err != NULL) {
3275              *err = error;
3276          }
3277      }
3278      Pipe() : Memory() { }
3279      explicit Pipe(const cl_mem&amp; pipe, bool retainObject = false) :
3280          Memory(pipe, retainObject) { }
3281      Pipe&amp; operator = (const cl_mem&amp; rhs)
3282      {
3283          Memory::operator=(rhs);
3284          return *this;
3285      }
3286      Pipe(const Pipe&amp; pipe) : Memory(pipe) {}
3287      Pipe&amp; operator = (const Pipe &amp;pipe)
3288      {
3289          Memory::operator=(pipe);
3290          return *this;
3291      }
3292      Pipe(Pipe&amp;&amp; pipe) CL_HPP_NOEXCEPT_ : Memory(std::move(pipe)) {}
3293      Pipe&amp; operator = (Pipe &amp;&amp;pipe)
3294      {
3295          Memory::operator=(std::move(pipe));
3296          return *this;
3297      }
3298      template &lt;typename T&gt;
3299      cl_int getInfo(cl_pipe_info name, T* param) const
3300      {
3301          return detail::errHandler(
3302              detail::getInfo(&amp;::clGetPipeInfo, object_, name, param),
3303              __GET_PIPE_INFO_ERR);
3304      }
3305      template &lt;cl_int name&gt; typename
3306          detail::param_traits&lt;detail::cl_pipe_info, name&gt;::param_type
3307          getInfo(cl_int* err = NULL) const
3308      {
3309          typename detail::param_traits&lt;
3310              detail::cl_pipe_info, name&gt;::param_type param;
3311          cl_int result = getInfo(name, &amp;param);
3312          if (err != NULL) {
3313              *err = result;
3314          }
3315          return param;
3316      }
3317  }; 
3318  #endif 
3319  class Sampler : public detail::Wrapper&lt;cl_sampler&gt;
3320  {
3321  public:
3322      Sampler() { }
3323      Sampler(
3324          const Context&amp; context,
3325          cl_bool normalized_coords,
3326          cl_addressing_mode addressing_mode,
3327          cl_filter_mode filter_mode,
3328          cl_int* err = NULL)
3329      {
3330          cl_int error;
3331  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 200
3332          cl_sampler_properties sampler_properties[] = {
3333              CL_SAMPLER_NORMALIZED_COORDS, normalized_coords,
3334              CL_SAMPLER_ADDRESSING_MODE, addressing_mode,
3335              CL_SAMPLER_FILTER_MODE, filter_mode,
3336              0 };
3337          object_ = ::clCreateSamplerWithProperties(
3338              context(),
3339              sampler_properties,
3340              &amp;error);
3341          detail::errHandler(error, __CREATE_SAMPLER_WITH_PROPERTIES_ERR);
3342          if (err != NULL) {
3343              *err = error;
3344          }
3345  #else
3346          object_ = ::clCreateSampler(
3347              context(),
3348              normalized_coords,
3349              addressing_mode,
3350              filter_mode,
3351              &amp;error);
3352          detail::errHandler(error, __CREATE_SAMPLER_ERR);
3353          if (err != NULL) {
3354              *err = error;
3355          }
3356  #endif        
3357      }
3358      explicit Sampler(const cl_sampler&amp; sampler, bool retainObject = false) : 
3359          detail::Wrapper&lt;cl_type&gt;(sampler, retainObject) { }
3360      Sampler&amp; operator = (const cl_sampler&amp; rhs)
3361      {
3362          detail::Wrapper&lt;cl_type&gt;::operator=(rhs);
3363          return *this;
3364      }
3365      Sampler(const Sampler&amp; sam) : detail::Wrapper&lt;cl_type&gt;(sam) {}
3366      Sampler&amp; operator = (const Sampler &amp;sam)
3367      {
3368          detail::Wrapper&lt;cl_type&gt;::operator=(sam);
3369          return *this;
3370      }
3371      Sampler(Sampler&amp;&amp; sam) CL_HPP_NOEXCEPT_ : detail::Wrapper&lt;cl_type&gt;(std::move(sam)) {}
3372      Sampler&amp; operator = (Sampler &amp;&amp;sam)
3373      {
3374          detail::Wrapper&lt;cl_type&gt;::operator=(std::move(sam));
3375          return *this;
3376      }
3377      template &lt;typename T&gt;
3378      cl_int getInfo(cl_sampler_info name, T* param) const
3379      {
3380          return detail::errHandler(
3381              detail::getInfo(&amp;::clGetSamplerInfo, object_, name, param),
3382              __GET_SAMPLER_INFO_ERR);
3383      }
3384      template &lt;cl_int name&gt; typename
3385      detail::param_traits&lt;detail::cl_sampler_info, name&gt;::param_type
3386      getInfo(cl_int* err = NULL) const
3387      {
3388          typename detail::param_traits&lt;
3389              detail::cl_sampler_info, name&gt;::param_type param;
3390          cl_int result = getInfo(name, &amp;param);
3391          if (err != NULL) {
3392              *err = result;
3393          }
3394          return param;
3395      }
3396  };
3397  class Program;
3398  class CommandQueue;
3399  class DeviceCommandQueue;
3400  class Kernel;
3401  class NDRange
3402  {
3403  private:
3404      size_type sizes_[3];
3405      cl_uint dimensions_;
3406  public:
3407      NDRange()
3408          : dimensions_(0)
3409      {
3410          sizes_[0] = 0;
3411          sizes_[1] = 0;
3412          sizes_[2] = 0;
3413      }
3414      NDRange(size_type size0)
3415          : dimensions_(1)
3416      {
3417          sizes_[0] = size0;
3418          sizes_[1] = 1;
3419          sizes_[2] = 1;
3420      }
3421      NDRange(size_type size0, size_type size1)
3422          : dimensions_(2)
3423      {
3424          sizes_[0] = size0;
3425          sizes_[1] = size1;
3426          sizes_[2] = 1;
3427      }
3428      NDRange(size_type size0, size_type size1, size_type size2)
3429          : dimensions_(3)
3430      {
3431          sizes_[0] = size0;
3432          sizes_[1] = size1;
3433          sizes_[2] = size2;
3434      }
3435      operator const size_type*() const { 
3436          return sizes_; 
3437      }
3438      size_type dimensions() const 
3439      { 
3440          return dimensions_; 
3441      }
3442      size_type size() const
3443      {
3444          return dimensions_*sizeof(size_type);
3445      }
3446      size_type* get()
3447      {
3448          return sizes_;
3449      }
3450      const size_type* get() const
3451      {
3452          return sizes_;
3453      }
3454  };
3455  static const NDRange NullRange;
3456  struct LocalSpaceArg
3457  {
3458      size_type size_;
3459  };
3460  namespace detail {
3461  template &lt;typename T, class Enable = void&gt;
3462  struct KernelArgumentHandler;
3463  template &lt;typename T&gt;
3464  struct KernelArgumentHandler&lt;T, typename std::enable_if&lt;!std::is_base_of&lt;cl::Memory, T&gt;::value&gt;::type&gt;
3465  {
3466      static size_type size(const T&amp;) { return sizeof(T); }
3467      static const T* ptr(const T&amp; value) { return &amp;value; }
3468  };
3469  template &lt;typename T&gt;
3470  struct KernelArgumentHandler&lt;T, typename std::enable_if&lt;std::is_base_of&lt;cl::Memory, T&gt;::value&gt;::type&gt;
3471  {
3472      static size_type size(const T&amp;) { return sizeof(cl_mem); }
3473      static const cl_mem* ptr(const T&amp; value) { return &amp;(value()); }
3474  };
3475  template &lt;&gt;
3476  struct KernelArgumentHandler&lt;LocalSpaceArg, void&gt;
3477  {
3478      static size_type size(const LocalSpaceArg&amp; value) { return value.size_; }
3479      static const void* ptr(const LocalSpaceArg&amp;) { return NULL; }
3480  };
3481  } 
3482  inline LocalSpaceArg
3483  Local(size_type size)
3484  {
3485      LocalSpaceArg ret = { size };
3486      return ret;
3487  }
3488  class Kernel : public detail::Wrapper&lt;cl_kernel&gt;
3489  {
3490  public:
3491      inline Kernel(const Program&amp; program, const char* name, cl_int* err = NULL);
3492      Kernel() { }
3493      explicit Kernel(const cl_kernel&amp; kernel, bool retainObject = false) : 
3494          detail::Wrapper&lt;cl_type&gt;(kernel, retainObject) { }
3495      Kernel&amp; operator = (const cl_kernel&amp; rhs)
3496      {
3497          detail::Wrapper&lt;cl_type&gt;::operator=(rhs);
3498          return *this;
3499      }
3500      Kernel(const Kernel&amp; kernel) : detail::Wrapper&lt;cl_type&gt;(kernel) {}
3501      Kernel&amp; operator = (const Kernel &amp;kernel)
3502      {
3503          detail::Wrapper&lt;cl_type&gt;::operator=(kernel);
3504          return *this;
3505      }
3506      Kernel(Kernel&amp;&amp; kernel) CL_HPP_NOEXCEPT_ : detail::Wrapper&lt;cl_type&gt;(std::move(kernel)) {}
3507      Kernel&amp; operator = (Kernel &amp;&amp;kernel)
3508      {
3509          detail::Wrapper&lt;cl_type&gt;::operator=(std::move(kernel));
3510          return *this;
3511      }
3512      template &lt;typename T&gt;
3513      cl_int getInfo(cl_kernel_info name, T* param) const
3514      {
3515          return detail::errHandler(
3516              detail::getInfo(&amp;::clGetKernelInfo, object_, name, param),
3517              __GET_KERNEL_INFO_ERR);
3518      }
3519      template &lt;cl_int name&gt; typename
3520      detail::param_traits&lt;detail::cl_kernel_info, name&gt;::param_type
3521      getInfo(cl_int* err = NULL) const
3522      {
3523          typename detail::param_traits&lt;
3524              detail::cl_kernel_info, name&gt;::param_type param;
3525          cl_int result = getInfo(name, &amp;param);
3526          if (err != NULL) {
3527              *err = result;
3528          }
3529          return param;
3530      }
3531  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 120
3532      template &lt;typename T&gt;
3533      cl_int getArgInfo(cl_uint argIndex, cl_kernel_arg_info name, T* param) const
3534      {
3535          return detail::errHandler(
3536              detail::getInfo(&amp;::clGetKernelArgInfo, object_, argIndex, name, param),
3537              __GET_KERNEL_ARG_INFO_ERR);
3538      }
3539      template &lt;cl_int name&gt; typename
3540      detail::param_traits&lt;detail::cl_kernel_arg_info, name&gt;::param_type
3541      getArgInfo(cl_uint argIndex, cl_int* err = NULL) const
3542      {
3543          typename detail::param_traits&lt;
3544              detail::cl_kernel_arg_info, name&gt;::param_type param;
3545          cl_int result = getArgInfo(argIndex, name, &amp;param);
3546          if (err != NULL) {
3547              *err = result;
3548          }
3549          return param;
3550      }
3551  #endif 
3552      template &lt;typename T&gt;
3553      cl_int getWorkGroupInfo(
3554          const Device&amp; device, cl_kernel_work_group_info name, T* param) const
3555      {
3556          return detail::errHandler(
3557              detail::getInfo(
3558                  &amp;::clGetKernelWorkGroupInfo, object_, device(), name, param),
3559                  __GET_KERNEL_WORK_GROUP_INFO_ERR);
3560      }
3561      template &lt;cl_int name&gt; typename
3562      detail::param_traits&lt;detail::cl_kernel_work_group_info, name&gt;::param_type
3563          getWorkGroupInfo(const Device&amp; device, cl_int* err = NULL) const
3564      {
3565          typename detail::param_traits&lt;
3566          detail::cl_kernel_work_group_info, name&gt;::param_type param;
3567          cl_int result = getWorkGroupInfo(device, name, &amp;param);
3568          if (err != NULL) {
3569              *err = result;
3570          }
3571          return param;
3572      }
3573  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 200
3574  #if defined(CL_HPP_USE_CL_SUB_GROUPS_KHR)
3575      cl_int getSubGroupInfo(const cl::Device &amp;dev, cl_kernel_sub_group_info name, const cl::NDRange &amp;range, size_type* param) const
3576      {
3577          typedef clGetKernelSubGroupInfoKHR_fn PFN_clGetKernelSubGroupInfoKHR;
3578          static PFN_clGetKernelSubGroupInfoKHR pfn_clGetKernelSubGroupInfoKHR = NULL;
3579          CL_HPP_INIT_CL_EXT_FCN_PTR_(clGetKernelSubGroupInfoKHR);
3580          return detail::errHandler(
3581              pfn_clGetKernelSubGroupInfoKHR(object_, dev(), name, range.size(), range.get(), sizeof(size_type), param, nullptr),
3582              __GET_KERNEL_ARG_INFO_ERR);
3583      }
3584      template &lt;cl_int name&gt;
3585          size_type getSubGroupInfo(const cl::Device &amp;dev, const cl::NDRange &amp;range, cl_int* err = NULL) const
3586      {
3587          size_type param;
3588          cl_int result = getSubGroupInfo(dev, name, range, &amp;param);
3589          if (err != NULL) {
3590              *err = result;
3591          }
3592          return param;
3593      }
3594  #endif 
3595  #endif 
3596  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 200
3597      template&lt;typename T, class D&gt;
3598      cl_int setArg(cl_uint index, const cl::pointer&lt;T, D&gt; &amp;argPtr)
3599      {
3600          return detail::errHandler(
3601              ::clSetKernelArgSVMPointer(object_, index, argPtr.get()),
3602              __SET_KERNEL_ARGS_ERR);
3603      }
3604      template&lt;typename T, class Alloc&gt;
3605      cl_int setArg(cl_uint index, const cl::vector&lt;T, Alloc&gt; &amp;argPtr)
3606      {
3607          return detail::errHandler(
3608              ::clSetKernelArgSVMPointer(object_, index, argPtr.data()),
3609              __SET_KERNEL_ARGS_ERR);
3610      }
3611      template&lt;typename T&gt;
3612      typename std::enable_if&lt;std::is_pointer&lt;T&gt;::value, cl_int&gt;::type
3613          setArg(cl_uint index, const T argPtr)
3614      {
3615          return detail::errHandler(
3616              ::clSetKernelArgSVMPointer(object_, index, argPtr),
3617              __SET_KERNEL_ARGS_ERR);
3618      }
3619  #endif 
3620      template &lt;typename T&gt;
3621      typename std::enable_if&lt;!std::is_pointer&lt;T&gt;::value, cl_int&gt;::type
3622          setArg(cl_uint index, const T &amp;value)
3623      {
3624          return detail::errHandler(
3625              ::clSetKernelArg(
3626                  object_,
3627                  index,
3628                  detail::KernelArgumentHandler&lt;T&gt;::size(value),
3629                  detail::KernelArgumentHandler&lt;T&gt;::ptr(value)),
3630              __SET_KERNEL_ARGS_ERR);
3631      }
3632      cl_int setArg(cl_uint index, size_type size, const void* argPtr)
3633      {
3634          return detail::errHandler(
3635              ::clSetKernelArg(object_, index, size, argPtr),
3636              __SET_KERNEL_ARGS_ERR);
3637      }
3638  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 200
3639      cl_int setSVMPointers(const vector&lt;void*&gt; &amp;pointerList)
3640      {
3641          return detail::errHandler(
3642              ::clSetKernelExecInfo(
3643                  object_,
3644                  CL_KERNEL_EXEC_INFO_SVM_PTRS,
3645                  sizeof(void*)*pointerList.size(),
3646                  pointerList.data()));
3647      }
3648      template&lt;int ArrayLength&gt;
3649      cl_int setSVMPointers(const std::array&lt;void*, ArrayLength&gt; &amp;pointerList)
3650      {
3651          return detail::errHandler(
3652              ::clSetKernelExecInfo(
3653                  object_,
3654                  CL_KERNEL_EXEC_INFO_SVM_PTRS,
3655                  sizeof(void*)*pointerList.size(),
3656                  pointerList.data()));
3657      }
3658      cl_int enableFineGrainedSystemSVM(bool svmEnabled)
3659      {
3660          cl_bool svmEnabled_ = svmEnabled ? CL_TRUE : CL_FALSE;
3661          return detail::errHandler(
3662              ::clSetKernelExecInfo(
3663                  object_,
3664                  CL_KERNEL_EXEC_INFO_SVM_FINE_GRAIN_SYSTEM,
3665                  sizeof(cl_bool),
3666                  &amp;svmEnabled_
3667                  )
3668              );
3669      }
3670      template&lt;int index, int ArrayLength, class D, typename T0, typename... Ts&gt;
3671      void setSVMPointersHelper(std::array&lt;void*, ArrayLength&gt; &amp;pointerList, const pointer&lt;T0, D&gt; &amp;t0, Ts... ts)
3672      {
3673          pointerList[index] = static_cast&lt;void*&gt;(t0.get());
3674          setSVMPointersHelper&lt;index + 1, Ts...&gt;(ts...);
3675      }
3676      template&lt;int index, int ArrayLength, typename T0, typename... Ts&gt;
3677      typename std::enable_if&lt;std::is_pointer&lt;T0&gt;::value, void&gt;::type
3678      setSVMPointersHelper(std::array&lt;void*, ArrayLength&gt; &amp;pointerList, T0 t0, Ts... ts)
3679      {
3680          pointerList[index] = static_cast&lt;void*&gt;(t0);
3681          setSVMPointersHelper&lt;index + 1, Ts...&gt;(ts...);
3682      }
3683      template&lt;int index, int ArrayLength, typename T0, class D&gt;
3684      void setSVMPointersHelper(std::array&lt;void*, ArrayLength&gt; &amp;pointerList, const pointer&lt;T0, D&gt; &amp;t0)
3685      {
3686          pointerList[index] = static_cast&lt;void*&gt;(t0.get());
3687      }
3688      template&lt;int index, int ArrayLength, typename T0&gt;
3689      typename std::enable_if&lt;std::is_pointer&lt;T0&gt;::value, void&gt;::type
3690      setSVMPointersHelper(std::array&lt;void*, ArrayLength&gt; &amp;pointerList, T0 t0)
3691      {
3692          pointerList[index] = static_cast&lt;void*&gt;(t0);
3693      }
3694      template&lt;typename T0, typename... Ts&gt;
3695      cl_int setSVMPointers(const T0 &amp;t0, Ts... ts)
3696      {
3697          std::array&lt;void*, 1 + sizeof...(Ts)&gt; pointerList;
3698          setSVMPointersHelper&lt;0, 1 + sizeof...(Ts)&gt;(pointerList, t0, ts...);
3699          return detail::errHandler(
3700              ::clSetKernelExecInfo(
3701              object_,
3702              CL_KERNEL_EXEC_INFO_SVM_PTRS,
3703              sizeof(void*)*(1 + sizeof...(Ts)),
3704              pointerList.data()));
3705      }
3706  #endif 
3707  };
3708  class Program : public detail::Wrapper&lt;cl_program&gt;
3709  {
3710  public:
3711  #if !defined(CL_HPP_ENABLE_PROGRAM_CONSTRUCTION_FROM_ARRAY_COMPATIBILITY)
3712      typedef vector&lt;vector&lt;unsigned char&gt;&gt; Binaries;
3713      typedef vector&lt;string&gt; Sources;
3714  #else 
3715      typedef vector&lt;std::pair&lt;const void*, size_type&gt; &gt; Binaries;
3716      typedef vector&lt;std::pair&lt;const char*, size_type&gt; &gt; Sources;
3717  #endif 
3718      Program(
3719          const string&amp; source,
3720          bool build = false,
3721          cl_int* err = NULL)
3722      {
3723          cl_int error;
3724          const char * strings = source.c_str();
3725          const size_type length  = source.size();
3726          Context context = Context::getDefault(err);
3727          object_ = ::clCreateProgramWithSource(
3728              context(), (cl_uint)1, &amp;strings, &amp;length, &amp;error);
3729          detail::errHandler(error, __CREATE_PROGRAM_WITH_SOURCE_ERR);
3730          if (error == CL_SUCCESS &amp;&amp; build) {
3731              error = ::clBuildProgram(
3732                  object_,
3733                  0,
3734                  NULL,
3735  #if !defined(CL_HPP_CL_1_2_DEFAULT_BUILD)
3736                  &quot;-cl-std=CL2.0&quot;,
3737  #else
3738                  &quot;&quot;,
3739  #endif 
3740                  NULL,
3741                  NULL);
3742              detail::buildErrHandler(error, __BUILD_PROGRAM_ERR, getBuildInfo&lt;CL_PROGRAM_BUILD_LOG&gt;());
3743          }
3744          if (err != NULL) {
3745              *err = error;
3746          }
3747      }
3748      Program(
3749          const Context&amp; context,
3750          const string&amp; source,
3751          bool build = false,
3752          cl_int* err = NULL)
3753      {
3754          cl_int error;
3755          const char * strings = source.c_str();
3756          const size_type length  = source.size();
3757          object_ = ::clCreateProgramWithSource(
3758              context(), (cl_uint)1, &amp;strings, &amp;length, &amp;error);
3759          detail::errHandler(error, __CREATE_PROGRAM_WITH_SOURCE_ERR);
3760          if (error == CL_SUCCESS &amp;&amp; build) {
3761              error = ::clBuildProgram(
3762                  object_,
3763                  0,
3764                  NULL,
3765  #if !defined(CL_HPP_CL_1_2_DEFAULT_BUILD)
3766                  &quot;-cl-std=CL2.0&quot;,
3767  #else
3768                  &quot;&quot;,
3769  #endif 
3770                  NULL,
3771                  NULL);
3772              detail::buildErrHandler(error, __BUILD_PROGRAM_ERR, getBuildInfo&lt;CL_PROGRAM_BUILD_LOG&gt;());
3773          }
3774          if (err != NULL) {
3775              *err = error;
3776          }
3777      }
3778      Program(
3779          const Sources&amp; sources,
3780          cl_int* err = NULL)
3781      {
3782          cl_int error;
3783          Context context = Context::getDefault(err);
3784          const size_type n = (size_type)sources.size();
3785          vector&lt;size_type&gt; lengths(n);
3786          vector&lt;const char*&gt; strings(n);
3787          for (size_type i = 0; i &lt; n; ++i) {
3788  #if !defined(CL_HPP_ENABLE_PROGRAM_CONSTRUCTION_FROM_ARRAY_COMPATIBILITY)
3789              strings[i] = sources[(int)i].data();
3790              lengths[i] = sources[(int)i].length();
3791  #else 
3792              strings[i] = sources[(int)i].first;
3793              lengths[i] = sources[(int)i].second;
3794  #endif 
3795          }
3796          object_ = ::clCreateProgramWithSource(
3797              context(), (cl_uint)n, strings.data(), lengths.data(), &amp;error);
3798          detail::errHandler(error, __CREATE_PROGRAM_WITH_SOURCE_ERR);
3799          if (err != NULL) {
3800              *err = error;
3801          }
3802      }
3803      Program(
3804          const Context&amp; context,
3805          const Sources&amp; sources,
3806          cl_int* err = NULL)
3807      {
3808          cl_int error;
3809          const size_type n = (size_type)sources.size();
3810          vector&lt;size_type&gt; lengths(n);
3811          vector&lt;const char*&gt; strings(n);
3812          for (size_type i = 0; i &lt; n; ++i) {
3813  #if !defined(CL_HPP_ENABLE_PROGRAM_CONSTRUCTION_FROM_ARRAY_COMPATIBILITY)
3814              strings[i] = sources[(int)i].data();
3815              lengths[i] = sources[(int)i].length();
3816  #else 
3817              strings[i] = sources[(int)i].first;
3818              lengths[i] = sources[(int)i].second;
3819  #endif 
3820          }
3821          object_ = ::clCreateProgramWithSource(
3822              context(), (cl_uint)n, strings.data(), lengths.data(), &amp;error);
3823          detail::errHandler(error, __CREATE_PROGRAM_WITH_SOURCE_ERR);
3824          if (err != NULL) {
3825              *err = error;
3826          }
3827      }
3828      Program(
3829          const Context&amp; context,
3830          const vector&lt;Device&gt;&amp; devices,
3831          const Binaries&amp; binaries,
3832          vector&lt;cl_int&gt;* binaryStatus = NULL,
3833          cl_int* err = NULL)
3834      {
3835          cl_int error;
3836          const size_type numDevices = devices.size();
3837          if(binaries.size() != numDevices) {
3838              error = CL_INVALID_VALUE;
3839              detail::errHandler(error, __CREATE_PROGRAM_WITH_BINARY_ERR);
3840              if (err != NULL) {
3841                  *err = error;
3842              }
3843              return;
3844          }
3845          vector&lt;size_type&gt; lengths(numDevices);
3846          vector&lt;const unsigned char*&gt; images(numDevices);
3847  #if !defined(CL_HPP_ENABLE_PROGRAM_CONSTRUCTION_FROM_ARRAY_COMPATIBILITY)
3848          for (size_type i = 0; i &lt; numDevices; ++i) {
3849              images[i] = binaries[i].data();
3850              lengths[i] = binaries[(int)i].size();
3851          }
3852  #else 
3853          for (size_type i = 0; i &lt; numDevices; ++i) {
3854              images[i] = (const unsigned char*)binaries[i].first;
3855              lengths[i] = binaries[(int)i].second;
3856          }
3857  #endif 
3858          vector&lt;cl_device_id&gt; deviceIDs(numDevices);
3859          for( size_type deviceIndex = 0; deviceIndex &lt; numDevices; ++deviceIndex ) {
3860              deviceIDs[deviceIndex] = (devices[deviceIndex])();
3861          }
3862          if(binaryStatus) {
3863              binaryStatus-&gt;resize(numDevices);
3864          }
3865          object_ = ::clCreateProgramWithBinary(
3866              context(), (cl_uint) devices.size(),
3867              deviceIDs.data(),
3868              lengths.data(), images.data(), (binaryStatus != NULL &amp;&amp; numDevices &gt; 0)
3869                 ? &amp;binaryStatus-&gt;front()
3870                 : NULL, &amp;error);
3871          detail::errHandler(error, __CREATE_PROGRAM_WITH_BINARY_ERR);
3872          if (err != NULL) {
3873              *err = error;
3874          }
3875      }
3876  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 120
3877      Program(
3878          const Context&amp; context,
3879          const vector&lt;Device&gt;&amp; devices,
3880          const string&amp; kernelNames,
3881          cl_int* err = NULL)
3882      {
3883          cl_int error;
3884          size_type numDevices = devices.size();
3885          vector&lt;cl_device_id&gt; deviceIDs(numDevices);
3886          for( size_type deviceIndex = 0; deviceIndex &lt; numDevices; ++deviceIndex ) {
3887              deviceIDs[deviceIndex] = (devices[deviceIndex])();
3888          }
3889          object_ = ::clCreateProgramWithBuiltInKernels(
3890              context(), 
3891              (cl_uint) devices.size(),
3892              deviceIDs.data(),
3893              kernelNames.c_str(), 
3894              &amp;error);
3895          detail::errHandler(error, __CREATE_PROGRAM_WITH_BUILT_IN_KERNELS_ERR);
3896          if (err != NULL) {
3897              *err = error;
3898          }
3899      }
3900  #endif 
3901      Program() { }
3902      explicit Program(const cl_program&amp; program, bool retainObject = false) : 
3903          detail::Wrapper&lt;cl_type&gt;(program, retainObject) { }
3904      Program&amp; operator = (const cl_program&amp; rhs)
3905      {
3906          detail::Wrapper&lt;cl_type&gt;::operator=(rhs);
3907          return *this;
3908      }
3909      Program(const Program&amp; program) : detail::Wrapper&lt;cl_type&gt;(program) {}
3910      Program&amp; operator = (const Program &amp;program)
3911      {
3912          detail::Wrapper&lt;cl_type&gt;::operator=(program);
3913          return *this;
3914      }
3915      Program(Program&amp;&amp; program) CL_HPP_NOEXCEPT_ : detail::Wrapper&lt;cl_type&gt;(std::move(program)) {}
3916      Program&amp; operator = (Program &amp;&amp;program)
3917      {
3918          detail::Wrapper&lt;cl_type&gt;::operator=(std::move(program));
3919          return *this;
3920      }
3921      cl_int build(
3922          const vector&lt;Device&gt;&amp; devices,
3923          const char* options = NULL,
3924          void (CL_CALLBACK * notifyFptr)(cl_program, void *) = NULL,
3925          void* data = NULL) const
3926      {
3927          size_type numDevices = devices.size();
3928          vector&lt;cl_device_id&gt; deviceIDs(numDevices);
3929          for( size_type deviceIndex = 0; deviceIndex &lt; numDevices; ++deviceIndex ) {
3930              deviceIDs[deviceIndex] = (devices[deviceIndex])();
3931          }
3932          cl_int buildError = ::clBuildProgram(
3933              object_,
3934              (cl_uint)
3935              devices.size(),
3936              deviceIDs.data(),
3937              options,
3938              notifyFptr,
3939              data);
3940          return detail::buildErrHandler(buildError, __BUILD_PROGRAM_ERR, getBuildInfo&lt;CL_PROGRAM_BUILD_LOG&gt;());
3941      }
3942      cl_int build(
3943          const char* options = NULL,
3944          void (CL_CALLBACK * notifyFptr)(cl_program, void *) = NULL,
3945          void* data = NULL) const
3946      {
3947          cl_int buildError = ::clBuildProgram(
3948              object_,
3949              0,
3950              NULL,
3951              options,
3952              notifyFptr,
3953              data);
3954          return detail::buildErrHandler(buildError, __BUILD_PROGRAM_ERR, getBuildInfo&lt;CL_PROGRAM_BUILD_LOG&gt;());
3955      }
3956  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 120
3957      cl_int compile(
3958          const char* options = NULL,
3959          void (CL_CALLBACK * notifyFptr)(cl_program, void *) = NULL,
3960          void* data = NULL) const
3961      {
3962          cl_int error = ::clCompileProgram(
3963              object_,
3964              0,
3965              NULL,
3966              options,
3967              0,
3968              NULL,
3969              NULL,
3970              notifyFptr,
3971              data);
3972          return detail::buildErrHandler(error, __COMPILE_PROGRAM_ERR, getBuildInfo&lt;CL_PROGRAM_BUILD_LOG&gt;());
3973      }
3974  #endif 
3975      template &lt;typename T&gt;
3976      cl_int getInfo(cl_program_info name, T* param) const
3977      {
3978          return detail::errHandler(
3979              detail::getInfo(&amp;::clGetProgramInfo, object_, name, param),
3980              __GET_PROGRAM_INFO_ERR);
3981      }
3982      template &lt;cl_int name&gt; typename
3983      detail::param_traits&lt;detail::cl_program_info, name&gt;::param_type
3984      getInfo(cl_int* err = NULL) const
3985      {
3986          typename detail::param_traits&lt;
3987              detail::cl_program_info, name&gt;::param_type param;
3988          cl_int result = getInfo(name, &amp;param);
3989          if (err != NULL) {
3990              *err = result;
3991          }
3992          return param;
3993      }
3994      template &lt;typename T&gt;
3995      cl_int getBuildInfo(
3996          const Device&amp; device, cl_program_build_info name, T* param) const
3997      {
3998          return detail::errHandler(
3999              detail::getInfo(
4000                  &amp;::clGetProgramBuildInfo, object_, device(), name, param),
4001                  __GET_PROGRAM_BUILD_INFO_ERR);
4002      }
4003      template &lt;cl_int name&gt; typename
4004      detail::param_traits&lt;detail::cl_program_build_info, name&gt;::param_type
4005      getBuildInfo(const Device&amp; device, cl_int* err = NULL) const
4006      {
4007          typename detail::param_traits&lt;
4008              detail::cl_program_build_info, name&gt;::param_type param;
4009          cl_int result = getBuildInfo(device, name, &amp;param);
4010          if (err != NULL) {
4011              *err = result;
4012          }
4013          return param;
4014      }
4015      template &lt;cl_int name&gt;
4016      vector&lt;std::pair&lt;cl::Device, typename detail::param_traits&lt;detail::cl_program_build_info, name&gt;::param_type&gt;&gt;
4017          getBuildInfo(cl_int *err = NULL) const
4018      {
4019          cl_int result = CL_SUCCESS;
4020          auto devs = getInfo&lt;CL_PROGRAM_DEVICES&gt;(&amp;result);
4021          vector&lt;std::pair&lt;cl::Device, typename detail::param_traits&lt;detail::cl_program_build_info, name&gt;::param_type&gt;&gt;
4022              devInfo;
4023          if (result != CL_SUCCESS) {
4024              if (err != NULL) {
4025                  *err = result;
4026              }
4027              return devInfo;
4028          }
4029          for (cl::Device d : devs) {
4030              typename detail::param_traits&lt;
4031                  detail::cl_program_build_info, name&gt;::param_type param;
4032              result = getBuildInfo(d, name, &amp;param);
4033              devInfo.push_back(
4034                  std::pair&lt;cl::Device, typename detail::param_traits&lt;detail::cl_program_build_info, name&gt;::param_type&gt;
4035                  (d, param));
4036              if (result != CL_SUCCESS) {
4037                  break;
4038              }
4039          }
4040          if (err != NULL) {
4041              *err = result;
4042          }
4043          if (result != CL_SUCCESS) {
4044              devInfo.clear();
4045          }
4046          return devInfo;
4047      }
4048      cl_int createKernels(vector&lt;Kernel&gt;* kernels)
4049      {
4050          cl_uint numKernels;
4051          cl_int err = ::clCreateKernelsInProgram(object_, 0, NULL, &amp;numKernels);
4052          if (err != CL_SUCCESS) {
4053              return detail::errHandler(err, __CREATE_KERNELS_IN_PROGRAM_ERR);
4054          }
4055          vector&lt;cl_kernel&gt; value(numKernels);
4056          err = ::clCreateKernelsInProgram(
4057              object_, numKernels, value.data(), NULL);
4058          if (err != CL_SUCCESS) {
4059              return detail::errHandler(err, __CREATE_KERNELS_IN_PROGRAM_ERR);
4060          }
4061          if (kernels) {
4062              kernels-&gt;resize(value.size());
4063              for (size_type i = 0; i &lt; value.size(); i++) {
4064                  (*kernels)[i] = Kernel(value[i], false);
4065              }
4066          }
4067          return CL_SUCCESS;
4068      }
4069  };
4070  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 120
4071  inline Program linkProgram(
4072      Program input1,
4073      Program input2,
4074      const char* options = NULL,
4075      void (CL_CALLBACK * notifyFptr)(cl_program, void *) = NULL,
4076      void* data = NULL,
4077      cl_int* err = NULL) 
4078  {
4079      cl_int error_local = CL_SUCCESS;
4080      cl_program programs[2] = { input1(), input2() };
4081      Context ctx = input1.getInfo&lt;CL_PROGRAM_CONTEXT&gt;(&amp;error_local);
4082      if(error_local!=CL_SUCCESS) {
4083          detail::errHandler(error_local, __LINK_PROGRAM_ERR);
4084      }
4085      cl_program prog = ::clLinkProgram(
4086          ctx(),
4087          0,
4088          NULL,
4089          options,
4090          2,
4091          programs,
4092          notifyFptr,
4093          data,
4094          &amp;error_local);
4095      detail::errHandler(error_local,__COMPILE_PROGRAM_ERR);
4096      if (err != NULL) {
4097          *err = error_local;
4098      }
4099      return Program(prog);
4100  }
4101  inline Program linkProgram(
4102      vector&lt;Program&gt; inputPrograms,
4103      const char* options = NULL,
4104      void (CL_CALLBACK * notifyFptr)(cl_program, void *) = NULL,
4105      void* data = NULL,
4106      cl_int* err = NULL) 
4107  {
4108      cl_int error_local = CL_SUCCESS;
4109      vector&lt;cl_program&gt; programs(inputPrograms.size());
4110      for (unsigned int i = 0; i &lt; inputPrograms.size(); i++) {
4111          programs[i] = inputPrograms[i]();
4112      }
4113      Context ctx;
4114      if(inputPrograms.size() &gt; 0) {
4115          ctx = inputPrograms[0].getInfo&lt;CL_PROGRAM_CONTEXT&gt;(&amp;error_local);
4116          if(error_local!=CL_SUCCESS) {
4117              detail::errHandler(error_local, __LINK_PROGRAM_ERR);
4118          }
4119      }
4120      cl_program prog = ::clLinkProgram(
4121          ctx(),
4122          0,
4123          NULL,
4124          options,
4125          (cl_uint)inputPrograms.size(),
4126          programs.data(),
4127          notifyFptr,
4128          data,
4129          &amp;error_local);
4130      detail::errHandler(error_local,__COMPILE_PROGRAM_ERR);
4131      if (err != NULL) {
4132          *err = error_local;
4133      }
4134      return Program(prog, false);
4135  }
4136  #endif 
4137  template &lt;&gt;
4138  inline cl_int cl::Program::getInfo(cl_program_info name, vector&lt;vector&lt;unsigned char&gt;&gt;* param) const
4139  {
4140      if (name != CL_PROGRAM_BINARIES) {
4141          return CL_INVALID_VALUE;
4142      }
4143      if (param) {
4144          vector&lt;size_type&gt; sizes = getInfo&lt;CL_PROGRAM_BINARY_SIZES&gt;();
4145          size_type numBinaries = sizes.size();
4146          param-&gt;resize(numBinaries);
4147          for (int i = 0; i &lt; numBinaries; ++i) {
4148              (*param)[i].resize(sizes[i]);
4149          }
4150          return detail::errHandler(
4151              detail::getInfo(&amp;::clGetProgramInfo, object_, name, param),
4152              __GET_PROGRAM_INFO_ERR);
4153      }
4154      return CL_SUCCESS;
4155  }
4156  template&lt;&gt;
4157  inline vector&lt;vector&lt;unsigned char&gt;&gt; cl::Program::getInfo&lt;CL_PROGRAM_BINARIES&gt;(cl_int* err) const
4158  {
4159      vector&lt;vector&lt;unsigned char&gt;&gt; binariesVectors;
4160      cl_int result = getInfo(CL_PROGRAM_BINARIES, &amp;binariesVectors);
4161      if (err != NULL) {
4162          *err = result;
4163      }
4164      return binariesVectors;
4165  }
4166  inline Kernel::Kernel(const Program&amp; program, const char* name, cl_int* err)
4167  {
4168      cl_int error;
4169      object_ = ::clCreateKernel(program(), name, &amp;error);
4170      detail::errHandler(error, __CREATE_KERNEL_ERR);
4171      if (err != NULL) {
4172          *err = error;
4173      }
4174  }
4175  enum class QueueProperties : cl_command_queue_properties
4176  {
4177      None = 0,
4178      Profiling = CL_QUEUE_PROFILING_ENABLE,
4179      OutOfOrder = CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE,
4180  };
4181  QueueProperties operator|(QueueProperties lhs, QueueProperties rhs)
4182  {
4183      return static_cast&lt;QueueProperties&gt;(static_cast&lt;cl_command_queue_properties&gt;(lhs) | static_cast&lt;cl_command_queue_properties&gt;(rhs));
4184  }
4185  class CommandQueue : public detail::Wrapper&lt;cl_command_queue&gt;
4186  {
4187  private:
4188      static std::once_flag default_initialized_;
4189      static CommandQueue default_;
4190      static cl_int default_error_;
4191      static void makeDefault()
4192      {
4193  #if defined(CL_HPP_ENABLE_EXCEPTIONS)
4194          try
4195  #endif
4196          {
4197              int error;
4198              Context context = Context::getDefault(&amp;error);
4199              if (error != CL_SUCCESS) {
4200                  default_error_ = error;
4201              }
4202              else {
4203                  Device device = Device::getDefault();
4204                  default_ = CommandQueue(context, device, 0, &amp;default_error_);
4205              }
4206          }
4207  #if defined(CL_HPP_ENABLE_EXCEPTIONS)
4208          catch (cl::Error &amp;e) {
4209              default_error_ = e.err();
4210          }
4211  #endif
4212      }
4213      static void makeDefaultProvided(const CommandQueue &amp;c) {
4214          default_ = c;
4215      }
4216  public:
4217  #ifdef CL_HPP_UNIT_TEST_ENABLE
4218      static void unitTestClearDefault() {
4219          default_ = CommandQueue();
4220      }
4221  #endif 
4222     CommandQueue(
4223          cl_command_queue_properties properties,
4224          cl_int* err = NULL)
4225      {
4226          cl_int error;
4227          Context context = Context::getDefault(&amp;error);
4228          detail::errHandler(error, __CREATE_CONTEXT_ERR);
4229          if (error != CL_SUCCESS) {
4230              if (err != NULL) {
4231                  *err = error;
4232              }
4233          }
4234          else {
4235              Device device = context.getInfo&lt;CL_CONTEXT_DEVICES&gt;()[0];
4236  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 200
4237              cl_queue_properties queue_properties[] = {
4238                  CL_QUEUE_PROPERTIES, properties, 0 };
4239              if ((properties &amp; CL_QUEUE_ON_DEVICE) == 0) {
4240                  object_ = ::clCreateCommandQueueWithProperties(
4241                      context(), device(), queue_properties, &amp;error);
4242              }
4243              else {
4244                  error = CL_INVALID_QUEUE_PROPERTIES;
4245              }
4246              detail::errHandler(error, __CREATE_COMMAND_QUEUE_WITH_PROPERTIES_ERR);
4247              if (err != NULL) {
4248                  *err = error;
4249              }
4250  #else
4251              object_ = ::clCreateCommandQueue(
4252                  context(), device(), properties, &amp;error);
4253              detail::errHandler(error, __CREATE_COMMAND_QUEUE_ERR);
4254              if (err != NULL) {
4255                  *err = error;
4256              }
4257  #endif
4258          }
4259      }
4260     CommandQueue(
4261         QueueProperties properties,
4262         cl_int* err = NULL)
4263     {
4264         cl_int error;
4265         Context context = Context::getDefault(&amp;error);
4266         detail::errHandler(error, __CREATE_CONTEXT_ERR);
4267         if (error != CL_SUCCESS) {
4268             if (err != NULL) {
4269                 *err = error;
4270             }
4271         }
4272         else {
4273             Device device = context.getInfo&lt;CL_CONTEXT_DEVICES&gt;()[0];
4274  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 200
4275             cl_queue_properties queue_properties[] = {
4276                 CL_QUEUE_PROPERTIES, static_cast&lt;cl_queue_properties&gt;(properties), 0 };
4277             object_ = ::clCreateCommandQueueWithProperties(
4278                 context(), device(), queue_properties, &amp;error);
4279             detail::errHandler(error, __CREATE_COMMAND_QUEUE_WITH_PROPERTIES_ERR);
4280             if (err != NULL) {
4281                 *err = error;
4282             }
4283  #else
4284             object_ = ::clCreateCommandQueue(
4285                 context(), device(), static_cast&lt;cl_command_queue_properties&gt;(properties), &amp;error);
4286             detail::errHandler(error, __CREATE_COMMAND_QUEUE_ERR);
4287             if (err != NULL) {
4288                 *err = error;
4289             }
4290  #endif
4291         }
4292     }
4293      explicit CommandQueue(
4294          const Context&amp; context,
4295          cl_command_queue_properties properties = 0,
4296          cl_int* err = NULL)
4297      {
4298          cl_int error;
4299          vector&lt;cl::Device&gt; devices;
4300          error = context.getInfo(CL_CONTEXT_DEVICES, &amp;devices);
4301          detail::errHandler(error, __CREATE_CONTEXT_ERR);
4302          if (error != CL_SUCCESS)
4303          {
4304              if (err != NULL) {
4305                  *err = error;
4306              }
4307              return;
4308          }
4309  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 200
4310          cl_queue_properties queue_properties[] = {
4311              CL_QUEUE_PROPERTIES, properties, 0 };
4312          if ((properties &amp; CL_QUEUE_ON_DEVICE) == 0) {
4313              object_ = ::clCreateCommandQueueWithProperties(
4314                  context(), devices[0](), queue_properties, &amp;error);
4315          }
4316          else {
4317              error = CL_INVALID_QUEUE_PROPERTIES;
4318          }
4319          detail::errHandler(error, __CREATE_COMMAND_QUEUE_WITH_PROPERTIES_ERR);
4320          if (err != NULL) {
4321              *err = error;
4322          }
4323  #else
4324          object_ = ::clCreateCommandQueue(
4325              context(), devices[0](), properties, &amp;error);
4326          detail::errHandler(error, __CREATE_COMMAND_QUEUE_ERR);
4327          if (err != NULL) {
4328              *err = error;
4329          }
4330  #endif
4331      }
4332      explicit CommandQueue(
4333          const Context&amp; context,
4334          QueueProperties properties,
4335          cl_int* err = NULL)
4336      {
4337          cl_int error;
4338          vector&lt;cl::Device&gt; devices;
4339          error = context.getInfo(CL_CONTEXT_DEVICES, &amp;devices);
4340          detail::errHandler(error, __CREATE_CONTEXT_ERR);
4341          if (error != CL_SUCCESS)
4342          {
4343              if (err != NULL) {
4344                  *err = error;
4345              }
4346              return;
4347          }
4348  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 200
4349          cl_queue_properties queue_properties[] = {
4350              CL_QUEUE_PROPERTIES, static_cast&lt;cl_queue_properties&gt;(properties), 0 };
4351          object_ = ::clCreateCommandQueueWithProperties(
4352              context(), devices[0](), queue_properties, &amp;error);
4353          detail::errHandler(error, __CREATE_COMMAND_QUEUE_WITH_PROPERTIES_ERR);
4354          if (err != NULL) {
4355              *err = error;
4356          }
4357  #else
4358          object_ = ::clCreateCommandQueue(
4359              context(), devices[0](), static_cast&lt;cl_command_queue_properties&gt;(properties), &amp;error);
4360          detail::errHandler(error, __CREATE_COMMAND_QUEUE_ERR);
4361          if (err != NULL) {
4362              *err = error;
4363          }
4364  #endif
4365      }
4366      CommandQueue(
4367          const Context&amp; context,
4368          const Device&amp; device,
4369          cl_command_queue_properties properties = 0,
4370          cl_int* err = NULL)
4371      {
4372          cl_int error;
4373  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 200
4374          cl_queue_properties queue_properties[] = {
4375              CL_QUEUE_PROPERTIES, properties, 0 };
4376          object_ = ::clCreateCommandQueueWithProperties(
4377              context(), device(), queue_properties, &amp;error);
4378          detail::errHandler(error, __CREATE_COMMAND_QUEUE_WITH_PROPERTIES_ERR);
4379          if (err != NULL) {
4380              *err = error;
4381          }
4382  #else
4383          object_ = ::clCreateCommandQueue(
4384              context(), device(), properties, &amp;error);
4385          detail::errHandler(error, __CREATE_COMMAND_QUEUE_ERR);
4386          if (err != NULL) {
4387              *err = error;
4388          }
4389  #endif
4390      }
4391      CommandQueue(
4392          const Context&amp; context,
4393          const Device&amp; device,
4394          QueueProperties properties,
4395          cl_int* err = NULL)
4396      {
4397              cl_int error;
4398  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 200
4399              cl_queue_properties queue_properties[] = {
4400                  CL_QUEUE_PROPERTIES, static_cast&lt;cl_queue_properties&gt;(properties), 0 };
4401              object_ = ::clCreateCommandQueueWithProperties(
4402                  context(), device(), queue_properties, &amp;error);
4403              detail::errHandler(error, __CREATE_COMMAND_QUEUE_WITH_PROPERTIES_ERR);
4404              if (err != NULL) {
4405                  *err = error;
4406              }
4407  #else
4408              object_ = ::clCreateCommandQueue(
4409                  context(), device(), static_cast&lt;cl_command_queue_properties&gt;(properties), &amp;error);
4410              detail::errHandler(error, __CREATE_COMMAND_QUEUE_ERR);
4411              if (err != NULL) {
4412                  *err = error;
4413              }
4414  #endif
4415          }
4416      static CommandQueue getDefault(cl_int * err = NULL) 
4417      {
4418          std::call_once(default_initialized_, makeDefault);
4419  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 200
4420          detail::errHandler(default_error_, __CREATE_COMMAND_QUEUE_WITH_PROPERTIES_ERR);
4421  #else 
4422          detail::errHandler(default_error_, __CREATE_COMMAND_QUEUE_ERR);
4423  #endif 
4424          if (err != NULL) {
4425              *err = default_error_;
4426          }
4427          return default_;
4428      }
4429      static CommandQueue setDefault(const CommandQueue &amp;default_queue)
4430      {
4431          std::call_once(default_initialized_, makeDefaultProvided, std::cref(default_queue));
4432          detail::errHandler(default_error_);
4433          return default_;
4434      }
4435      CommandQueue() { }
4436      explicit CommandQueue(const cl_command_queue&amp; commandQueue, bool retainObject = false) : 
4437          detail::Wrapper&lt;cl_type&gt;(commandQueue, retainObject) { }
4438      CommandQueue&amp; operator = (const cl_command_queue&amp; rhs)
4439      {
4440          detail::Wrapper&lt;cl_type&gt;::operator=(rhs);
4441          return *this;
4442      }
4443      CommandQueue(const CommandQueue&amp; queue) : detail::Wrapper&lt;cl_type&gt;(queue) {}
4444      CommandQueue&amp; operator = (const CommandQueue &amp;queue)
4445      {
4446          detail::Wrapper&lt;cl_type&gt;::operator=(queue);
4447          return *this;
4448      }
4449      CommandQueue(CommandQueue&amp;&amp; queue) CL_HPP_NOEXCEPT_ : detail::Wrapper&lt;cl_type&gt;(std::move(queue)) {}
4450      CommandQueue&amp; operator = (CommandQueue &amp;&amp;queue)
4451      {
4452          detail::Wrapper&lt;cl_type&gt;::operator=(std::move(queue));
4453          return *this;
4454      }
4455      template &lt;typename T&gt;
4456      cl_int getInfo(cl_command_queue_info name, T* param) const
4457      {
4458          return detail::errHandler(
4459              detail::getInfo(
4460                  &amp;::clGetCommandQueueInfo, object_, name, param),
4461                  __GET_COMMAND_QUEUE_INFO_ERR);
4462      }
4463      template &lt;cl_int name&gt; typename
4464      detail::param_traits&lt;detail::cl_command_queue_info, name&gt;::param_type
4465      getInfo(cl_int* err = NULL) const
4466      {
4467          typename detail::param_traits&lt;
4468              detail::cl_command_queue_info, name&gt;::param_type param;
4469          cl_int result = getInfo(name, &amp;param);
4470          if (err != NULL) {
4471              *err = result;
4472          }
4473          return param;
4474      }
4475      cl_int enqueueReadBuffer(
4476          const Buffer&amp; buffer,
4477          cl_bool blocking,
4478          size_type offset,
4479          size_type size,
4480          void* ptr,
4481          const vector&lt;Event&gt;* events = NULL,
4482          Event* event = NULL) const
4483      {
4484          cl_event tmp;
4485          cl_int err = detail::errHandler(
4486              ::clEnqueueReadBuffer(
4487                  object_, buffer(), blocking, offset, size,
4488                  ptr,
4489                  (events != NULL) ? (cl_uint) events-&gt;size() : 0,
4490                  (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
4491                  (event != NULL) ? &amp;tmp : NULL),
4492              __ENQUEUE_READ_BUFFER_ERR);
4493          if (event != NULL &amp;&amp; err == CL_SUCCESS)
4494              *event = tmp;
4495          return err;
4496      }
4497      cl_int enqueueWriteBuffer(
4498          const Buffer&amp; buffer,
4499          cl_bool blocking,
4500          size_type offset,
4501          size_type size,
4502          const void* ptr,
4503          const vector&lt;Event&gt;* events = NULL,
4504          Event* event = NULL) const
4505      {
4506          cl_event tmp;
4507          cl_int err = detail::errHandler(
4508              ::clEnqueueWriteBuffer(
4509                  object_, buffer(), blocking, offset, size,
4510                  ptr,
4511                  (events != NULL) ? (cl_uint) events-&gt;size() : 0,
4512                  (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
4513                  (event != NULL) ? &amp;tmp : NULL),
4514                  __ENQUEUE_WRITE_BUFFER_ERR);
4515          if (event != NULL &amp;&amp; err == CL_SUCCESS)
4516              *event = tmp;
4517          return err;
4518      }
4519      cl_int enqueueCopyBuffer(
4520          const Buffer&amp; src,
4521          const Buffer&amp; dst,
4522          size_type src_offset,
4523          size_type dst_offset,
4524          size_type size,
4525          const vector&lt;Event&gt;* events = NULL,
4526          Event* event = NULL) const
4527      {
4528          cl_event tmp;
4529          cl_int err = detail::errHandler(
4530              ::clEnqueueCopyBuffer(
4531                  object_, src(), dst(), src_offset, dst_offset, size,
4532                  (events != NULL) ? (cl_uint) events-&gt;size() : 0,
4533                  (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
4534                  (event != NULL) ? &amp;tmp : NULL),
4535              __ENQEUE_COPY_BUFFER_ERR);
4536          if (event != NULL &amp;&amp; err == CL_SUCCESS)
4537              *event = tmp;
4538          return err;
4539      }
4540      cl_int enqueueReadBufferRect(
4541          const Buffer&amp; buffer,
4542          cl_bool blocking,
4543          const array&lt;size_type, 3&gt;&amp; buffer_offset,
4544          const array&lt;size_type, 3&gt;&amp; host_offset,
4545          const array&lt;size_type, 3&gt;&amp; region,
4546          size_type buffer_row_pitch,
4547          size_type buffer_slice_pitch,
4548          size_type host_row_pitch,
4549          size_type host_slice_pitch,
4550          void *ptr,
4551          const vector&lt;Event&gt;* events = NULL,
4552          Event* event = NULL) const
4553      {
4554          cl_event tmp;
4555          cl_int err = detail::errHandler(
4556              ::clEnqueueReadBufferRect(
4557                  object_, 
4558                  buffer(), 
4559                  blocking,
4560                  buffer_offset.data(),
4561                  host_offset.data(),
4562                  region.data(),
4563                  buffer_row_pitch,
4564                  buffer_slice_pitch,
4565                  host_row_pitch,
4566                  host_slice_pitch,
4567                  ptr,
4568                  (events != NULL) ? (cl_uint) events-&gt;size() : 0,
4569                  (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
4570                  (event != NULL) ? &amp;tmp : NULL),
4571                  __ENQUEUE_READ_BUFFER_RECT_ERR);
4572          if (event != NULL &amp;&amp; err == CL_SUCCESS)
4573              *event = tmp;
4574          return err;
4575      }
4576      cl_int enqueueWriteBufferRect(
4577          const Buffer&amp; buffer,
4578          cl_bool blocking,
4579          const array&lt;size_type, 3&gt;&amp; buffer_offset,
4580          const array&lt;size_type, 3&gt;&amp; host_offset,
4581          const array&lt;size_type, 3&gt;&amp; region,
4582          size_type buffer_row_pitch,
4583          size_type buffer_slice_pitch,
4584          size_type host_row_pitch,
4585          size_type host_slice_pitch,
4586          void *ptr,
4587          const vector&lt;Event&gt;* events = NULL,
4588          Event* event = NULL) const
4589      {
4590          cl_event tmp;
4591          cl_int err = detail::errHandler(
4592              ::clEnqueueWriteBufferRect(
4593                  object_, 
4594                  buffer(), 
4595                  blocking,
4596                  buffer_offset.data(),
4597                  host_offset.data(),
4598                  region.data(),
4599                  buffer_row_pitch,
4600                  buffer_slice_pitch,
4601                  host_row_pitch,
4602                  host_slice_pitch,
4603                  ptr,
4604                  (events != NULL) ? (cl_uint) events-&gt;size() : 0,
4605                  (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
4606                  (event != NULL) ? &amp;tmp : NULL),
4607                  __ENQUEUE_WRITE_BUFFER_RECT_ERR);
4608          if (event != NULL &amp;&amp; err == CL_SUCCESS)
4609              *event = tmp;
4610          return err;
4611      }
4612      cl_int enqueueCopyBufferRect(
4613          const Buffer&amp; src,
4614          const Buffer&amp; dst,
4615          const array&lt;size_type, 3&gt;&amp; src_origin,
4616          const array&lt;size_type, 3&gt;&amp; dst_origin,
4617          const array&lt;size_type, 3&gt;&amp; region,
4618          size_type src_row_pitch,
4619          size_type src_slice_pitch,
4620          size_type dst_row_pitch,
4621          size_type dst_slice_pitch,
4622          const vector&lt;Event&gt;* events = NULL,
4623          Event* event = NULL) const
4624      {
4625          cl_event tmp;
4626          cl_int err = detail::errHandler(
4627              ::clEnqueueCopyBufferRect(
4628                  object_, 
4629                  src(), 
4630                  dst(), 
4631                  src_origin.data(),
4632                  dst_origin.data(),
4633                  region.data(),
4634                  src_row_pitch,
4635                  src_slice_pitch,
4636                  dst_row_pitch,
4637                  dst_slice_pitch,
4638                  (events != NULL) ? (cl_uint) events-&gt;size() : 0,
4639                  (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
4640                  (event != NULL) ? &amp;tmp : NULL),
4641              __ENQEUE_COPY_BUFFER_RECT_ERR);
4642          if (event != NULL &amp;&amp; err == CL_SUCCESS)
4643              *event = tmp;
4644          return err;
4645      }
4646  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 120
4647      template&lt;typename PatternType&gt;
4648      cl_int enqueueFillBuffer(
4649          const Buffer&amp; buffer,
4650          PatternType pattern,
4651          size_type offset,
4652          size_type size,
4653          const vector&lt;Event&gt;* events = NULL,
4654          Event* event = NULL) const
4655      {
4656          cl_event tmp;
4657          cl_int err = detail::errHandler(
4658              ::clEnqueueFillBuffer(
4659                  object_, 
4660                  buffer(),
4661                  static_cast&lt;void*&gt;(&amp;pattern),
4662                  sizeof(PatternType), 
4663                  offset, 
4664                  size,
4665                  (events != NULL) ? (cl_uint) events-&gt;size() : 0,
4666                  (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
4667                  (event != NULL) ? &amp;tmp : NULL),
4668                  __ENQUEUE_FILL_BUFFER_ERR);
4669          if (event != NULL &amp;&amp; err == CL_SUCCESS)
4670              *event = tmp;
4671          return err;
4672      }
4673  #endif 
4674      cl_int enqueueReadImage(
4675          const Image&amp; image,
4676          cl_bool blocking,
4677          const array&lt;size_type, 3&gt;&amp; origin,
4678          const array&lt;size_type, 3&gt;&amp; region,
4679          size_type row_pitch,
4680          size_type slice_pitch,
4681          void* ptr,
4682          const vector&lt;Event&gt;* events = NULL,
4683          Event* event = NULL) const
4684      {
4685          cl_event tmp;
4686          cl_int err = detail::errHandler(
4687              ::clEnqueueReadImage(
4688                  object_, 
4689                  image(), 
4690                  blocking, 
4691                  origin.data(),
4692                  region.data(), 
4693                  row_pitch, 
4694                  slice_pitch, 
4695                  ptr,
4696                  (events != NULL) ? (cl_uint) events-&gt;size() : 0,
4697                  (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
4698                  (event != NULL) ? &amp;tmp : NULL),
4699              __ENQUEUE_READ_IMAGE_ERR);
4700          if (event != NULL &amp;&amp; err == CL_SUCCESS)
4701              *event = tmp;
4702          return err;
4703      }
4704      cl_int enqueueWriteImage(
4705          const Image&amp; image,
4706          cl_bool blocking,
4707          const array&lt;size_type, 3&gt;&amp; origin,
4708          const array&lt;size_type, 3&gt;&amp; region,
4709          size_type row_pitch,
4710          size_type slice_pitch,
4711          void* ptr,
4712          const vector&lt;Event&gt;* events = NULL,
4713          Event* event = NULL) const
4714      {
4715          cl_event tmp;
4716          cl_int err = detail::errHandler(
4717              ::clEnqueueWriteImage(
4718                  object_, 
4719                  image(), 
4720                  blocking, 
4721                  origin.data(),
4722                  region.data(), 
4723                  row_pitch, 
4724                  slice_pitch, 
4725                  ptr,
4726                  (events != NULL) ? (cl_uint) events-&gt;size() : 0,
4727                  (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
4728                  (event != NULL) ? &amp;tmp : NULL),
4729              __ENQUEUE_WRITE_IMAGE_ERR);
4730          if (event != NULL &amp;&amp; err == CL_SUCCESS)
4731              *event = tmp;
4732          return err;
4733      }
4734      cl_int enqueueCopyImage(
4735          const Image&amp; src,
4736          const Image&amp; dst,
4737          const array&lt;size_type, 3&gt;&amp; src_origin,
4738          const array&lt;size_type, 3&gt;&amp; dst_origin,
4739          const array&lt;size_type, 3&gt;&amp; region,
4740          const vector&lt;Event&gt;* events = NULL,
4741          Event* event = NULL) const
4742      {
4743          cl_event tmp;
4744          cl_int err = detail::errHandler(
4745              ::clEnqueueCopyImage(
4746                  object_, 
4747                  src(), 
4748                  dst(), 
4749                  src_origin.data(),
4750                  dst_origin.data(), 
4751                  region.data(),
4752                  (events != NULL) ? (cl_uint) events-&gt;size() : 0,
4753                  (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
4754                  (event != NULL) ? &amp;tmp : NULL),
4755              __ENQUEUE_COPY_IMAGE_ERR);
4756          if (event != NULL &amp;&amp; err == CL_SUCCESS)
4757              *event = tmp;
4758          return err;
4759      }
4760  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 120
4761      cl_int enqueueFillImage(
4762          const Image&amp; image,
4763          cl_float4 fillColor,
4764          const array&lt;size_type, 3&gt;&amp; origin,
4765          const array&lt;size_type, 3&gt;&amp; region,
4766          const vector&lt;Event&gt;* events = NULL,
4767          Event* event = NULL) const
4768      {
4769          cl_event tmp;
4770          cl_int err = detail::errHandler(
4771              ::clEnqueueFillImage(
4772                  object_, 
4773                  image(),
4774                  static_cast&lt;void*&gt;(&amp;fillColor), 
4775                  origin.data(),
4776                  region.data(),
4777                  (events != NULL) ? (cl_uint) events-&gt;size() : 0,
4778                  (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
4779                  (event != NULL) ? &amp;tmp : NULL),
4780                  __ENQUEUE_FILL_IMAGE_ERR);
4781          if (event != NULL &amp;&amp; err == CL_SUCCESS)
4782              *event = tmp;
4783          return err;
4784      }
4785      cl_int enqueueFillImage(
4786          const Image&amp; image,
4787          cl_int4 fillColor,
4788          const array&lt;size_type, 3&gt;&amp; origin,
4789          const array&lt;size_type, 3&gt;&amp; region,
4790          const vector&lt;Event&gt;* events = NULL,
4791          Event* event = NULL) const
4792      {
4793          cl_event tmp;
4794          cl_int err = detail::errHandler(
4795              ::clEnqueueFillImage(
4796                  object_, 
4797                  image(),
4798                  static_cast&lt;void*&gt;(&amp;fillColor), 
4799                  origin.data(),
4800                  region.data(),
4801                  (events != NULL) ? (cl_uint) events-&gt;size() : 0,
4802                  (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
4803                  (event != NULL) ? &amp;tmp : NULL),
4804                  __ENQUEUE_FILL_IMAGE_ERR);
4805          if (event != NULL &amp;&amp; err == CL_SUCCESS)
4806              *event = tmp;
4807          return err;
4808      }
4809      cl_int enqueueFillImage(
4810          const Image&amp; image,
4811          cl_uint4 fillColor,
4812          const array&lt;size_type, 3&gt;&amp; origin,
4813          const array&lt;size_type, 3&gt;&amp; region,
4814          const vector&lt;Event&gt;* events = NULL,
4815          Event* event = NULL) const
4816      {
4817          cl_event tmp;
4818          cl_int err = detail::errHandler(
4819              ::clEnqueueFillImage(
4820                  object_, 
4821                  image(),
4822                  static_cast&lt;void*&gt;(&amp;fillColor), 
4823                  origin.data(),
4824                  region.data(),
4825                  (events != NULL) ? (cl_uint) events-&gt;size() : 0,
4826                  (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
4827                  (event != NULL) ? &amp;tmp : NULL),
4828                  __ENQUEUE_FILL_IMAGE_ERR);
4829          if (event != NULL &amp;&amp; err == CL_SUCCESS)
4830              *event = tmp;
4831          return err;
4832      }
4833  #endif 
4834      cl_int enqueueCopyImageToBuffer(
4835          const Image&amp; src,
4836          const Buffer&amp; dst,
4837          const array&lt;size_type, 3&gt;&amp; src_origin,
4838          const array&lt;size_type, 3&gt;&amp; region,
4839          size_type dst_offset,
4840          const vector&lt;Event&gt;* events = NULL,
4841          Event* event = NULL) const
4842      {
4843          cl_event tmp;
4844          cl_int err = detail::errHandler(
4845              ::clEnqueueCopyImageToBuffer(
4846                  object_, 
4847                  src(), 
4848                  dst(), 
4849                  src_origin.data(),
4850                  region.data(), 
4851                  dst_offset,
4852                  (events != NULL) ? (cl_uint) events-&gt;size() : 0,
4853                  (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
4854                  (event != NULL) ? &amp;tmp : NULL),
4855              __ENQUEUE_COPY_IMAGE_TO_BUFFER_ERR);
4856          if (event != NULL &amp;&amp; err == CL_SUCCESS)
4857              *event = tmp;
4858          return err;
4859      }
4860      cl_int enqueueCopyBufferToImage(
4861          const Buffer&amp; src,
4862          const Image&amp; dst,
4863          size_type src_offset,
4864          const array&lt;size_type, 3&gt;&amp; dst_origin,
4865          const array&lt;size_type, 3&gt;&amp; region,
4866          const vector&lt;Event&gt;* events = NULL,
4867          Event* event = NULL) const
4868      {
4869          cl_event tmp;
4870          cl_int err = detail::errHandler(
4871              ::clEnqueueCopyBufferToImage(
4872                  object_, 
4873                  src(), 
4874                  dst(), 
4875                  src_offset,
4876                  dst_origin.data(), 
4877                  region.data(),
4878                  (events != NULL) ? (cl_uint) events-&gt;size() : 0,
4879                  (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
4880                  (event != NULL) ? &amp;tmp : NULL),
4881              __ENQUEUE_COPY_BUFFER_TO_IMAGE_ERR);
4882          if (event != NULL &amp;&amp; err == CL_SUCCESS)
4883              *event = tmp;
4884          return err;
4885      }
4886      void* enqueueMapBuffer(
4887          const Buffer&amp; buffer,
4888          cl_bool blocking,
4889          cl_map_flags flags,
4890          size_type offset,
4891          size_type size,
4892          const vector&lt;Event&gt;* events = NULL,
4893          Event* event = NULL,
4894          cl_int* err = NULL) const
4895      {
4896          cl_event tmp;
4897          cl_int error;
4898          void * result = ::clEnqueueMapBuffer(
4899              object_, buffer(), blocking, flags, offset, size,
4900              (events != NULL) ? (cl_uint) events-&gt;size() : 0,
4901              (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
4902              (event != NULL) ? &amp;tmp : NULL,
4903              &amp;error);
4904          detail::errHandler(error, __ENQUEUE_MAP_BUFFER_ERR);
4905          if (err != NULL) {
4906              *err = error;
4907          }
4908          if (event != NULL &amp;&amp; error == CL_SUCCESS)
4909              *event = tmp;
4910          return result;
4911      }
4912      void* enqueueMapImage(
4913          const Image&amp; buffer,
4914          cl_bool blocking,
4915          cl_map_flags flags,
4916          const array&lt;size_type, 3&gt;&amp; origin,
4917          const array&lt;size_type, 3&gt;&amp; region,
4918          size_type * row_pitch,
4919          size_type * slice_pitch,
4920          const vector&lt;Event&gt;* events = NULL,
4921          Event* event = NULL,
4922          cl_int* err = NULL) const
4923      {
4924          cl_event tmp;
4925          cl_int error;
4926          void * result = ::clEnqueueMapImage(
4927              object_, buffer(), blocking, flags,
4928              origin.data(), 
4929              region.data(),
4930              row_pitch, slice_pitch,
4931              (events != NULL) ? (cl_uint) events-&gt;size() : 0,
4932              (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
4933              (event != NULL) ? &amp;tmp : NULL,
4934              &amp;error);
4935          detail::errHandler(error, __ENQUEUE_MAP_IMAGE_ERR);
4936          if (err != NULL) {
4937                *err = error;
4938          }
4939          if (event != NULL &amp;&amp; error == CL_SUCCESS)
4940              *event = tmp;
4941          return result;
4942      }
4943  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 200
4944      template&lt;typename T&gt;
4945      cl_int enqueueMapSVM(
4946          T* ptr,
4947          cl_bool blocking,
4948          cl_map_flags flags,
4949          size_type size,
4950          const vector&lt;Event&gt;* events = NULL,
4951          Event* event = NULL) const
4952      {
4953          cl_event tmp;
4954          cl_int err = detail::errHandler(::clEnqueueSVMMap(
4955              object_, blocking, flags, static_cast&lt;void*&gt;(ptr), size,
4956              (events != NULL) ? (cl_uint)events-&gt;size() : 0,
4957              (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*)&amp;events-&gt;front() : NULL,
4958              (event != NULL) ? &amp;tmp : NULL),
4959              __ENQUEUE_MAP_BUFFER_ERR);
4960          if (event != NULL &amp;&amp; err == CL_SUCCESS)
4961              *event = tmp;
4962          return err;
4963      }
4964      template&lt;typename T, class D&gt;
4965      cl_int enqueueMapSVM(
4966          cl::pointer&lt;T, D&gt; &amp;ptr,
4967          cl_bool blocking,
4968          cl_map_flags flags,
4969          size_type size,
4970          const vector&lt;Event&gt;* events = NULL,
4971          Event* event = NULL) const
4972      {
4973          cl_event tmp;
4974          cl_int err = detail::errHandler(::clEnqueueSVMMap(
4975              object_, blocking, flags, static_cast&lt;void*&gt;(ptr.get()), size,
4976              (events != NULL) ? (cl_uint)events-&gt;size() : 0,
4977              (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*)&amp;events-&gt;front() : NULL,
4978              (event != NULL) ? &amp;tmp : NULL),
4979              __ENQUEUE_MAP_BUFFER_ERR);
4980          if (event != NULL &amp;&amp; err == CL_SUCCESS)
4981              *event = tmp;
4982          return err;
4983      }
4984      template&lt;typename T, class Alloc&gt;
4985      cl_int enqueueMapSVM(
4986          cl::vector&lt;T, Alloc&gt; &amp;container,
4987          cl_bool blocking,
4988          cl_map_flags flags,
4989          const vector&lt;Event&gt;* events = NULL,
4990          Event* event = NULL) const
4991      {
4992          cl_event tmp;
4993          cl_int err = detail::errHandler(::clEnqueueSVMMap(
4994              object_, blocking, flags, static_cast&lt;void*&gt;(container.data()), container.size(),
4995              (events != NULL) ? (cl_uint)events-&gt;size() : 0,
4996              (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*)&amp;events-&gt;front() : NULL,
4997              (event != NULL) ? &amp;tmp : NULL),
4998              __ENQUEUE_MAP_BUFFER_ERR);
4999          if (event != NULL &amp;&amp; err == CL_SUCCESS)
5000              *event = tmp;
5001          return err;
5002      }
5003  #endif 
5004      cl_int enqueueUnmapMemObject(
5005          const Memory&amp; memory,
5006          void* mapped_ptr,
5007          const vector&lt;Event&gt;* events = NULL,
5008          Event* event = NULL) const
5009      {
5010          cl_event tmp;
5011          cl_int err = detail::errHandler(
5012              ::clEnqueueUnmapMemObject(
5013                  object_, memory(), mapped_ptr,
5014                  (events != NULL) ? (cl_uint) events-&gt;size() : 0,
5015                  (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
5016                  (event != NULL) ? &amp;tmp : NULL),
5017              __ENQUEUE_UNMAP_MEM_OBJECT_ERR);
5018          if (event != NULL &amp;&amp; err == CL_SUCCESS)
5019              *event = tmp;
5020          return err;
5021      }
5022  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 200
5023      template&lt;typename T&gt;
5024      cl_int enqueueUnmapSVM(
5025          T* ptr,
5026          const vector&lt;Event&gt;* events = NULL,
5027          Event* event = NULL) const
5028      {
5029          cl_event tmp;
5030          cl_int err = detail::errHandler(
5031              ::clEnqueueSVMUnmap(
5032              object_, static_cast&lt;void*&gt;(ptr),
5033              (events != NULL) ? (cl_uint)events-&gt;size() : 0,
5034              (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*)&amp;events-&gt;front() : NULL,
5035              (event != NULL) ? &amp;tmp : NULL),
5036              __ENQUEUE_UNMAP_MEM_OBJECT_ERR);
5037          if (event != NULL &amp;&amp; err == CL_SUCCESS)
5038              *event = tmp;
5039          return err;
5040      }
5041      template&lt;typename T, class D&gt;
5042      cl_int enqueueUnmapSVM(
5043          cl::pointer&lt;T, D&gt; &amp;ptr,
5044          const vector&lt;Event&gt;* events = NULL,
5045          Event* event = NULL) const
5046      {
5047          cl_event tmp;
5048          cl_int err = detail::errHandler(
5049              ::clEnqueueSVMUnmap(
5050              object_, static_cast&lt;void*&gt;(ptr.get()),
5051              (events != NULL) ? (cl_uint)events-&gt;size() : 0,
5052              (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*)&amp;events-&gt;front() : NULL,
5053              (event != NULL) ? &amp;tmp : NULL),
5054              __ENQUEUE_UNMAP_MEM_OBJECT_ERR);
5055          if (event != NULL &amp;&amp; err == CL_SUCCESS)
5056              *event = tmp;
5057          return err;
5058      }
5059      template&lt;typename T, class Alloc&gt;
5060      cl_int enqueueUnmapSVM(
5061          cl::vector&lt;T, Alloc&gt; &amp;container,
5062          const vector&lt;Event&gt;* events = NULL,
5063          Event* event = NULL) const
5064      {
5065          cl_event tmp;
5066          cl_int err = detail::errHandler(
5067              ::clEnqueueSVMUnmap(
5068              object_, static_cast&lt;void*&gt;(container.data()),
5069              (events != NULL) ? (cl_uint)events-&gt;size() : 0,
5070              (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*)&amp;events-&gt;front() : NULL,
5071              (event != NULL) ? &amp;tmp : NULL),
5072              __ENQUEUE_UNMAP_MEM_OBJECT_ERR);
5073          if (event != NULL &amp;&amp; err == CL_SUCCESS)
5074              *event = tmp;
5075          return err;
5076      }
5077  #endif 
5078  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 120
5079      cl_int enqueueMarkerWithWaitList(
5080          const vector&lt;Event&gt; *events = 0,
5081          Event *event = 0)
5082      {
5083          cl_event tmp;
5084          cl_int err = detail::errHandler(
5085              ::clEnqueueMarkerWithWaitList(
5086                  object_,
5087                  (events != NULL) ? (cl_uint) events-&gt;size() : 0,
5088                  (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
5089                  (event != NULL) ? &amp;tmp : NULL),
5090              __ENQUEUE_MARKER_WAIT_LIST_ERR);
5091          if (event != NULL &amp;&amp; err == CL_SUCCESS)
5092              *event = tmp;
5093          return err;
5094      }
5095      cl_int enqueueBarrierWithWaitList(
5096          const vector&lt;Event&gt; *events = 0,
5097          Event *event = 0)
5098      {
5099          cl_event tmp;
5100          cl_int err = detail::errHandler(
5101              ::clEnqueueBarrierWithWaitList(
5102                  object_,
5103                  (events != NULL) ? (cl_uint) events-&gt;size() : 0,
5104                  (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
5105                  (event != NULL) ? &amp;tmp : NULL),
5106              __ENQUEUE_BARRIER_WAIT_LIST_ERR);
5107          if (event != NULL &amp;&amp; err == CL_SUCCESS)
5108              *event = tmp;
5109          return err;
5110      }
5111      cl_int enqueueMigrateMemObjects(
5112          const vector&lt;Memory&gt; &amp;memObjects,
5113          cl_mem_migration_flags flags,
5114          const vector&lt;Event&gt;* events = NULL,
5115          Event* event = NULL
5116          )
5117      {
5118          cl_event tmp;
5119          vector&lt;cl_mem&gt; localMemObjects(memObjects.size());
5120          for( int i = 0; i &lt; (int)memObjects.size(); ++i ) {
5121              localMemObjects[i] = memObjects[i]();
5122          }
5123          cl_int err = detail::errHandler(
5124              ::clEnqueueMigrateMemObjects(
5125                  object_, 
5126                  (cl_uint)memObjects.size(), 
5127                  localMemObjects.data(),
5128                  flags,
5129                  (events != NULL) ? (cl_uint) events-&gt;size() : 0,
5130                  (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
5131                  (event != NULL) ? &amp;tmp : NULL),
5132              __ENQUEUE_UNMAP_MEM_OBJECT_ERR);
5133          if (event != NULL &amp;&amp; err == CL_SUCCESS)
5134              *event = tmp;
5135          return err;
5136      }
5137  #endif 
5138      cl_int enqueueNDRangeKernel(
5139          const Kernel&amp; kernel,
5140          const NDRange&amp; offset,
5141          const NDRange&amp; global,
5142          const NDRange&amp; local = NullRange,
5143          const vector&lt;Event&gt;* events = NULL,
5144          Event* event = NULL) const
5145      {
5146          cl_event tmp;
5147          cl_int err = detail::errHandler(
5148              ::clEnqueueNDRangeKernel(
5149                  object_, kernel(), (cl_uint) global.dimensions(),
5150                  offset.dimensions() != 0 ? (const size_type*) offset : NULL,
5151                  (const size_type*) global,
5152                  local.dimensions() != 0 ? (const size_type*) local : NULL,
5153                  (events != NULL) ? (cl_uint) events-&gt;size() : 0,
5154                  (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
5155                  (event != NULL) ? &amp;tmp : NULL),
5156              __ENQUEUE_NDRANGE_KERNEL_ERR);
5157          if (event != NULL &amp;&amp; err == CL_SUCCESS)
5158              *event = tmp;
5159          return err;
5160      }
5161  #if defined(CL_USE_DEPRECATED_OPENCL_1_2_APIS)
5162      CL_EXT_PREFIX__VERSION_1_2_DEPRECATED cl_int enqueueTask(
5163          const Kernel&amp; kernel,
5164          const vector&lt;Event&gt;* events = NULL,
5165          Event* event = NULL) CL_EXT_SUFFIX__VERSION_1_2_DEPRECATED const
5166      {
5167          cl_event tmp;
5168          cl_int err = detail::errHandler(
5169              ::clEnqueueTask(
5170                  object_, kernel(),
5171                  (events != NULL) ? (cl_uint) events-&gt;size() : 0,
5172                  (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
5173                  (event != NULL) ? &amp;tmp : NULL),
5174              __ENQUEUE_TASK_ERR);
5175          if (event != NULL &amp;&amp; err == CL_SUCCESS)
5176              *event = tmp;
5177          return err;
5178      }
5179  #endif 
5180      cl_int enqueueNativeKernel(
5181          void (CL_CALLBACK *userFptr)(void *),
5182          std::pair&lt;void*, size_type&gt; args,
5183          const vector&lt;Memory&gt;* mem_objects = NULL,
5184          const vector&lt;const void*&gt;* mem_locs = NULL,
5185          const vector&lt;Event&gt;* events = NULL,
5186          Event* event = NULL) const
5187      {
5188          size_type elements = 0;
5189          if (mem_objects != NULL) {
5190              elements = mem_objects-&gt;size();
5191          }
5192          vector&lt;cl_mem&gt; mems(elements);
5193          for (unsigned int i = 0; i &lt; elements; i++) {
5194              mems[i] = ((*mem_objects)[i])();
5195          }
5196          cl_event tmp;
5197          cl_int err = detail::errHandler(
5198              ::clEnqueueNativeKernel(
5199                  object_, userFptr, args.first, args.second,
5200                  (mem_objects != NULL) ? (cl_uint) mem_objects-&gt;size() : 0,
5201                  mems.data(),
5202                  (mem_locs != NULL &amp;&amp; mem_locs-&gt;size() &gt; 0) ? (const void **) &amp;mem_locs-&gt;front() : NULL,
5203                  (events != NULL) ? (cl_uint) events-&gt;size() : 0,
5204                  (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
5205                  (event != NULL) ? &amp;tmp : NULL),
5206              __ENQUEUE_NATIVE_KERNEL);
5207          if (event != NULL &amp;&amp; err == CL_SUCCESS)
5208              *event = tmp;
5209          return err;
5210      }
5211  #if defined(CL_USE_DEPRECATED_OPENCL_1_1_APIS)
5212      CL_EXT_PREFIX__VERSION_1_1_DEPRECATED 
5213      cl_int enqueueMarker(Event* event = NULL) const CL_EXT_SUFFIX__VERSION_1_1_DEPRECATED
5214      {
5215          cl_event tmp;
5216          cl_int err = detail::errHandler(
5217              ::clEnqueueMarker(
5218                  object_, 
5219                  (event != NULL) ? &amp;tmp : NULL),
5220              __ENQUEUE_MARKER_ERR);
5221          if (event != NULL &amp;&amp; err == CL_SUCCESS)
5222              *event = tmp;
5223          return err;
5224      }
5225      CL_EXT_PREFIX__VERSION_1_1_DEPRECATED
5226      cl_int enqueueWaitForEvents(const vector&lt;Event&gt;&amp; events) const CL_EXT_SUFFIX__VERSION_1_1_DEPRECATED
5227      {
5228          return detail::errHandler(
5229              ::clEnqueueWaitForEvents(
5230                  object_,
5231                  (cl_uint) events.size(),
5232                  events.size() &gt; 0 ? (const cl_event*) &amp;events.front() : NULL),
5233              __ENQUEUE_WAIT_FOR_EVENTS_ERR);
5234      }
5235  #endif 
5236      cl_int enqueueAcquireGLObjects(
5237           const vector&lt;Memory&gt;* mem_objects = NULL,
5238           const vector&lt;Event&gt;* events = NULL,
5239           Event* event = NULL) const
5240       {
5241          cl_event tmp;
5242          cl_int err = detail::errHandler(
5243               ::clEnqueueAcquireGLObjects(
5244                   object_,
5245                   (mem_objects != NULL) ? (cl_uint) mem_objects-&gt;size() : 0,
5246                   (mem_objects != NULL &amp;&amp; mem_objects-&gt;size() &gt; 0) ? (const cl_mem *) &amp;mem_objects-&gt;front(): NULL,
5247                   (events != NULL) ? (cl_uint) events-&gt;size() : 0,
5248                   (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
5249                   (event != NULL) ? &amp;tmp : NULL),
5250               __ENQUEUE_ACQUIRE_GL_ERR);
5251          if (event != NULL &amp;&amp; err == CL_SUCCESS)
5252              *event = tmp;
5253          return err;
5254       }
5255      cl_int enqueueReleaseGLObjects(
5256           const vector&lt;Memory&gt;* mem_objects = NULL,
5257           const vector&lt;Event&gt;* events = NULL,
5258           Event* event = NULL) const
5259       {
5260          cl_event tmp;
5261          cl_int err = detail::errHandler(
5262               ::clEnqueueReleaseGLObjects(
5263                   object_,
5264                   (mem_objects != NULL) ? (cl_uint) mem_objects-&gt;size() : 0,
5265                   (mem_objects != NULL &amp;&amp; mem_objects-&gt;size() &gt; 0) ? (const cl_mem *) &amp;mem_objects-&gt;front(): NULL,
5266                   (events != NULL) ? (cl_uint) events-&gt;size() : 0,
5267                   (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
5268                   (event != NULL) ? &amp;tmp : NULL),
5269               __ENQUEUE_RELEASE_GL_ERR);
5270          if (event != NULL &amp;&amp; err == CL_SUCCESS)
5271              *event = tmp;
5272          return err;
5273       }
5274  #if defined (CL_HPP_USE_DX_INTEROP)
5275  typedef CL_API_ENTRY cl_int (CL_API_CALL *PFN_clEnqueueAcquireD3D10ObjectsKHR)(
5276      cl_command_queue command_queue, cl_uint num_objects,
5277      const cl_mem* mem_objects, cl_uint num_events_in_wait_list,
5278      const cl_event* event_wait_list, cl_event* event);
5279  typedef CL_API_ENTRY cl_int (CL_API_CALL *PFN_clEnqueueReleaseD3D10ObjectsKHR)(
5280      cl_command_queue command_queue, cl_uint num_objects,
5281      const cl_mem* mem_objects,  cl_uint num_events_in_wait_list,
5282      const cl_event* event_wait_list, cl_event* event);
5283      cl_int enqueueAcquireD3D10Objects(
5284           const vector&lt;Memory&gt;* mem_objects = NULL,
5285           const vector&lt;Event&gt;* events = NULL,
5286           Event* event = NULL) const
5287      {
5288          static PFN_clEnqueueAcquireD3D10ObjectsKHR pfn_clEnqueueAcquireD3D10ObjectsKHR = NULL;
5289  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 120
5290          cl_context context = getInfo&lt;CL_QUEUE_CONTEXT&gt;();
5291          cl::Device device(getInfo&lt;CL_QUEUE_DEVICE&gt;());
5292          cl_platform_id platform = device.getInfo&lt;CL_DEVICE_PLATFORM&gt;();
5293          CL_HPP_INIT_CL_EXT_FCN_PTR_PLATFORM_(platform, clEnqueueAcquireD3D10ObjectsKHR);
5294  #endif
5295  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 110
5296          CL_HPP_INIT_CL_EXT_FCN_PTR_(clEnqueueAcquireD3D10ObjectsKHR);
5297  #endif
5298          cl_event tmp;
5299          cl_int err = detail::errHandler(
5300               pfn_clEnqueueAcquireD3D10ObjectsKHR(
5301                   object_,
5302                   (mem_objects != NULL) ? (cl_uint) mem_objects-&gt;size() : 0,
5303                   (mem_objects != NULL &amp;&amp; mem_objects-&gt;size() &gt; 0) ? (const cl_mem *) &amp;mem_objects-&gt;front(): NULL,
5304                   (events != NULL) ? (cl_uint) events-&gt;size() : 0,
5305                   (events != NULL) ? (cl_event*) &amp;events-&gt;front() : NULL,
5306                   (event != NULL) ? &amp;tmp : NULL),
5307               __ENQUEUE_ACQUIRE_GL_ERR);
5308          if (event != NULL &amp;&amp; err == CL_SUCCESS)
5309              *event = tmp;
5310          return err;
5311       }
5312      cl_int enqueueReleaseD3D10Objects(
5313           const vector&lt;Memory&gt;* mem_objects = NULL,
5314           const vector&lt;Event&gt;* events = NULL,
5315           Event* event = NULL) const
5316      {
5317          static PFN_clEnqueueReleaseD3D10ObjectsKHR pfn_clEnqueueReleaseD3D10ObjectsKHR = NULL;
5318  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 120
5319          cl_context context = getInfo&lt;CL_QUEUE_CONTEXT&gt;();
5320          cl::Device device(getInfo&lt;CL_QUEUE_DEVICE&gt;());
5321          cl_platform_id platform = device.getInfo&lt;CL_DEVICE_PLATFORM&gt;();
5322          CL_HPP_INIT_CL_EXT_FCN_PTR_PLATFORM_(platform, clEnqueueReleaseD3D10ObjectsKHR);
5323  #endif 
5324  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 110
5325          CL_HPP_INIT_CL_EXT_FCN_PTR_(clEnqueueReleaseD3D10ObjectsKHR);
5326  #endif 
5327          cl_event tmp;
5328          cl_int err = detail::errHandler(
5329              pfn_clEnqueueReleaseD3D10ObjectsKHR(
5330                  object_,
5331                  (mem_objects != NULL) ? (cl_uint) mem_objects-&gt;size() : 0,
5332                  (mem_objects != NULL &amp;&amp; mem_objects-&gt;size() &gt; 0) ? (const cl_mem *) &amp;mem_objects-&gt;front(): NULL,
5333                  (events != NULL) ? (cl_uint) events-&gt;size() : 0,
5334                  (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
5335                  (event != NULL) ? &amp;tmp : NULL),
5336              __ENQUEUE_RELEASE_GL_ERR);
5337          if (event != NULL &amp;&amp; err == CL_SUCCESS)
5338              *event = tmp;
5339          return err;
5340      }
5341  #endif
5342  #if defined(CL_USE_DEPRECATED_OPENCL_1_1_APIS)
5343      CL_EXT_PREFIX__VERSION_1_1_DEPRECATED
5344      cl_int enqueueBarrier() const CL_EXT_SUFFIX__VERSION_1_1_DEPRECATED
5345      {
5346          return detail::errHandler(
5347              ::clEnqueueBarrier(object_),
5348              __ENQUEUE_BARRIER_ERR);
5349      }
5350  #endif 
5351      cl_int flush() const
5352      {
5353          return detail::errHandler(::clFlush(object_), __FLUSH_ERR);
5354      }
5355      cl_int finish() const
5356      {
5357          return detail::errHandler(::clFinish(object_), __FINISH_ERR);
5358      }
5359  }; 
5360  CL_HPP_DEFINE_STATIC_MEMBER_ std::once_flag CommandQueue::default_initialized_;
5361  CL_HPP_DEFINE_STATIC_MEMBER_ CommandQueue CommandQueue::default_;
5362  CL_HPP_DEFINE_STATIC_MEMBER_ cl_int CommandQueue::default_error_ = CL_SUCCESS;
5363  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 200
5364  enum class DeviceQueueProperties : cl_command_queue_properties
5365  {
5366      None = 0,
5367      Profiling = CL_QUEUE_PROFILING_ENABLE,
5368  };
5369  DeviceQueueProperties  operator|(DeviceQueueProperties  lhs, DeviceQueueProperties  rhs)
5370  {
5371      return static_cast&lt;DeviceQueueProperties&gt;(static_cast&lt;cl_command_queue_properties&gt;(lhs) | static_cast&lt;cl_command_queue_properties&gt;(rhs));
5372  }
5373  class DeviceCommandQueue : public detail::Wrapper&lt;cl_command_queue&gt;
5374  {
5375  public:
5376      DeviceCommandQueue() { }
5377      DeviceCommandQueue(DeviceQueueProperties properties, cl_int* err = NULL)
5378      {
5379          cl_int error;
5380          cl::Context context = cl::Context::getDefault();
5381          cl::Device device = cl::Device::getDefault();
5382          cl_command_queue_properties mergedProperties =
5383              CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE | CL_QUEUE_ON_DEVICE | static_cast&lt;cl_command_queue_properties&gt;(properties);
5384          cl_queue_properties queue_properties[] = {
5385              CL_QUEUE_PROPERTIES, mergedProperties, 0 };
5386          object_ = ::clCreateCommandQueueWithProperties(
5387              context(), device(), queue_properties, &amp;error);
5388          detail::errHandler(error, __CREATE_COMMAND_QUEUE_WITH_PROPERTIES_ERR);
5389          if (err != NULL) {
5390              *err = error;
5391          }
5392      }
5393      DeviceCommandQueue(
5394          const Context&amp; context,
5395          const Device&amp; device,
5396          DeviceQueueProperties properties = DeviceQueueProperties::None,
5397          cl_int* err = NULL)
5398      {
5399          cl_int error;
5400          cl_command_queue_properties mergedProperties =
5401              CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE | CL_QUEUE_ON_DEVICE | static_cast&lt;cl_command_queue_properties&gt;(properties);
5402          cl_queue_properties queue_properties[] = {
5403              CL_QUEUE_PROPERTIES, mergedProperties, 0 };
5404          object_ = ::clCreateCommandQueueWithProperties(
5405              context(), device(), queue_properties, &amp;error);
5406          detail::errHandler(error, __CREATE_COMMAND_QUEUE_WITH_PROPERTIES_ERR);
5407          if (err != NULL) {
5408              *err = error;
5409          }
5410      }
5411      DeviceCommandQueue(
5412          const Context&amp; context,
5413          const Device&amp; device,
5414          cl_uint queueSize,
5415          DeviceQueueProperties properties = DeviceQueueProperties::None,
5416          cl_int* err = NULL)
5417      {
5418          cl_int error;
5419          cl_command_queue_properties mergedProperties =
5420              CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE | CL_QUEUE_ON_DEVICE | static_cast&lt;cl_command_queue_properties&gt;(properties);
5421          cl_queue_properties queue_properties[] = {
5422              CL_QUEUE_PROPERTIES, mergedProperties,
5423              CL_QUEUE_SIZE, queueSize, 
5424              0 };
5425          object_ = ::clCreateCommandQueueWithProperties(
5426              context(), device(), queue_properties, &amp;error);
5427          detail::errHandler(error, __CREATE_COMMAND_QUEUE_WITH_PROPERTIES_ERR);
5428          if (err != NULL) {
5429              *err = error;
5430          }
5431      }
5432      explicit DeviceCommandQueue(const cl_command_queue&amp; commandQueue, bool retainObject = false) :
5433          detail::Wrapper&lt;cl_type&gt;(commandQueue, retainObject) { }
5434      DeviceCommandQueue&amp; operator = (const cl_command_queue&amp; rhs)
5435      {
5436          detail::Wrapper&lt;cl_type&gt;::operator=(rhs);
5437          return *this;
5438      }
5439      DeviceCommandQueue(const DeviceCommandQueue&amp; queue) : detail::Wrapper&lt;cl_type&gt;(queue) {}
5440      DeviceCommandQueue&amp; operator = (const DeviceCommandQueue &amp;queue)
5441      {
5442          detail::Wrapper&lt;cl_type&gt;::operator=(queue);
5443          return *this;
5444      }
5445      DeviceCommandQueue(DeviceCommandQueue&amp;&amp; queue) CL_HPP_NOEXCEPT_ : detail::Wrapper&lt;cl_type&gt;(std::move(queue)) {}
5446      DeviceCommandQueue&amp; operator = (DeviceCommandQueue &amp;&amp;queue)
5447      {
5448          detail::Wrapper&lt;cl_type&gt;::operator=(std::move(queue));
5449          return *this;
5450      }
5451      template &lt;typename T&gt;
5452      cl_int getInfo(cl_command_queue_info name, T* param) const
5453      {
5454          return detail::errHandler(
5455              detail::getInfo(
5456              &amp;::clGetCommandQueueInfo, object_, name, param),
5457              __GET_COMMAND_QUEUE_INFO_ERR);
5458      }
5459      template &lt;cl_int name&gt; typename
5460          detail::param_traits&lt;detail::cl_command_queue_info, name&gt;::param_type
5461          getInfo(cl_int* err = NULL) const
5462      {
5463          typename detail::param_traits&lt;
5464              detail::cl_command_queue_info, name&gt;::param_type param;
5465          cl_int result = getInfo(name, &amp;param);
5466          if (err != NULL) {
5467              *err = result;
5468          }
5469          return param;
5470      }
5471      static DeviceCommandQueue makeDefault(
5472          cl_int *err = nullptr)
5473      {
5474          cl_int error;
5475          cl::Context context = cl::Context::getDefault();
5476          cl::Device device = cl::Device::getDefault();
5477          cl_command_queue_properties properties =
5478              CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE | CL_QUEUE_ON_DEVICE | CL_QUEUE_ON_DEVICE_DEFAULT;
5479          cl_queue_properties queue_properties[] = {
5480              CL_QUEUE_PROPERTIES, properties,
5481              0 };
5482          DeviceCommandQueue deviceQueue(
5483              ::clCreateCommandQueueWithProperties(
5484              context(), device(), queue_properties, &amp;error));
5485          detail::errHandler(error, __CREATE_COMMAND_QUEUE_WITH_PROPERTIES_ERR);
5486          if (err != NULL) {
5487              *err = error;
5488          }
5489          return deviceQueue;
5490      }
5491      static DeviceCommandQueue makeDefault(
5492          const Context &amp;context, const Device &amp;device, cl_int *err = nullptr)
5493      {
5494          cl_int error;
5495          cl_command_queue_properties properties =
5496              CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE | CL_QUEUE_ON_DEVICE | CL_QUEUE_ON_DEVICE_DEFAULT;
5497          cl_queue_properties queue_properties[] = {
5498              CL_QUEUE_PROPERTIES, properties,
5499              0 };
5500          DeviceCommandQueue deviceQueue(
5501              ::clCreateCommandQueueWithProperties(
5502              context(), device(), queue_properties, &amp;error));
5503          detail::errHandler(error, __CREATE_COMMAND_QUEUE_WITH_PROPERTIES_ERR);
5504          if (err != NULL) {
5505              *err = error;
5506          }
5507          return deviceQueue;
5508      }
5509      static DeviceCommandQueue makeDefault(
5510          const Context &amp;context, const Device &amp;device, cl_uint queueSize, cl_int *err = nullptr)
5511      {
5512          cl_int error;
5513          cl_command_queue_properties properties =
5514              CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE | CL_QUEUE_ON_DEVICE | CL_QUEUE_ON_DEVICE_DEFAULT;
5515          cl_queue_properties queue_properties[] = {
5516              CL_QUEUE_PROPERTIES, properties,
5517              CL_QUEUE_SIZE, queueSize,
5518              0 };
5519          DeviceCommandQueue deviceQueue(
5520              ::clCreateCommandQueueWithProperties(
5521                  context(), device(), queue_properties, &amp;error));
5522          detail::errHandler(error, __CREATE_COMMAND_QUEUE_WITH_PROPERTIES_ERR);
5523          if (err != NULL) {
5524              *err = error;
5525          }
5526          return deviceQueue;
5527      }
5528  }; 
5529  namespace detail
5530  {
5531      template &lt;&gt;
5532      struct KernelArgumentHandler&lt;cl::DeviceCommandQueue, void&gt;
5533      {
5534          static size_type size(const cl::DeviceCommandQueue&amp;) { return sizeof(cl_command_queue); }
5535          static const cl_command_queue* ptr(const cl::DeviceCommandQueue&amp; value) { return &amp;(value()); }
5536      };
5537  } 
5538  #endif 
5539  template&lt; typename IteratorType &gt;
5540  Buffer::Buffer(
5541      const Context &amp;context,
5542      IteratorType startIterator,
5543      IteratorType endIterator,
5544      bool readOnly,
5545      bool useHostPtr,
5546      cl_int* err)
5547  {
5548      typedef typename std::iterator_traits&lt;IteratorType&gt;::value_type DataType;
5549      cl_int error;
5550      cl_mem_flags flags = 0;
5551      if( readOnly ) {
5552          flags |= CL_MEM_READ_ONLY;
5553      }
5554      else {
5555          flags |= CL_MEM_READ_WRITE;
5556      }
5557      if( useHostPtr ) {
5558          flags |= CL_MEM_USE_HOST_PTR;
5559      }
5560      size_type size = sizeof(DataType)*(endIterator - startIterator);
5561      if( useHostPtr ) {
5562          object_ = ::clCreateBuffer(context(), flags, size, static_cast&lt;DataType*&gt;(&amp;*startIterator), &amp;error);
5563      } else {
5564          object_ = ::clCreateBuffer(context(), flags, size, 0, &amp;error);
5565      }
5566      detail::errHandler(error, __CREATE_BUFFER_ERR);
5567      if (err != NULL) {
5568          *err = error;
5569      }
5570      if( !useHostPtr ) {
5571          CommandQueue queue(context, 0, &amp;error);
5572          detail::errHandler(error, __CREATE_BUFFER_ERR);
5573          if (err != NULL) {
5574              *err = error;
5575          }
5576          error = cl::copy(queue, startIterator, endIterator, *this);
5577          detail::errHandler(error, __CREATE_BUFFER_ERR);
5578          if (err != NULL) {
5579              *err = error;
5580          }
5581      }
5582  }
5583  template&lt; typename IteratorType &gt;
5584  Buffer::Buffer(
5585      const CommandQueue &amp;queue,
5586      IteratorType startIterator,
5587      IteratorType endIterator,
5588      bool readOnly,
5589      bool useHostPtr,
5590      cl_int* err)
5591  {
5592      typedef typename std::iterator_traits&lt;IteratorType&gt;::value_type DataType;
5593      cl_int error;
5594      cl_mem_flags flags = 0;
5595      if (readOnly) {
5596          flags |= CL_MEM_READ_ONLY;
5597      }
5598      else {
5599          flags |= CL_MEM_READ_WRITE;
5600      }
5601      if (useHostPtr) {
5602          flags |= CL_MEM_USE_HOST_PTR;
5603      }
5604      size_type size = sizeof(DataType)*(endIterator - startIterator);
5605      Context context = queue.getInfo&lt;CL_QUEUE_CONTEXT&gt;();
5606      if (useHostPtr) {
5607          object_ = ::clCreateBuffer(context(), flags, size, static_cast&lt;DataType*&gt;(&amp;*startIterator), &amp;error);
5608      }
5609      else {
5610          object_ = ::clCreateBuffer(context(), flags, size, 0, &amp;error);
5611      }
5612      detail::errHandler(error, __CREATE_BUFFER_ERR);
5613      if (err != NULL) {
5614          *err = error;
5615      }
5616      if (!useHostPtr) {
5617          error = cl::copy(queue, startIterator, endIterator, *this);
5618          detail::errHandler(error, __CREATE_BUFFER_ERR);
5619          if (err != NULL) {
5620              *err = error;
5621          }
5622      }
5623  }
5624  inline cl_int enqueueReadBuffer(
5625      const Buffer&amp; buffer,
5626      cl_bool blocking,
5627      size_type offset,
5628      size_type size,
5629      void* ptr,
5630      const vector&lt;Event&gt;* events = NULL,
5631      Event* event = NULL)
5632  {
5633      cl_int error;
5634      CommandQueue queue = CommandQueue::getDefault(&amp;error);
5635      if (error != CL_SUCCESS) {
5636          return error;
5637      }
5638      return queue.enqueueReadBuffer(buffer, blocking, offset, size, ptr, events, event);
5639  }
5640  inline cl_int enqueueWriteBuffer(
5641          const Buffer&amp; buffer,
5642          cl_bool blocking,
5643          size_type offset,
5644          size_type size,
5645          const void* ptr,
5646          const vector&lt;Event&gt;* events = NULL,
5647          Event* event = NULL)
5648  {
5649      cl_int error;
5650      CommandQueue queue = CommandQueue::getDefault(&amp;error);
5651      if (error != CL_SUCCESS) {
5652          return error;
5653      }
5654      return queue.enqueueWriteBuffer(buffer, blocking, offset, size, ptr, events, event);
5655  }
5656  inline void* enqueueMapBuffer(
5657          const Buffer&amp; buffer,
5658          cl_bool blocking,
5659          cl_map_flags flags,
5660          size_type offset,
5661          size_type size,
5662          const vector&lt;Event&gt;* events = NULL,
5663          Event* event = NULL,
5664          cl_int* err = NULL)
5665  {
5666      cl_int error;
5667      CommandQueue queue = CommandQueue::getDefault(&amp;error);
5668      detail::errHandler(error, __ENQUEUE_MAP_BUFFER_ERR);
5669      if (err != NULL) {
5670          *err = error;
5671      }
5672      void * result = ::clEnqueueMapBuffer(
5673              queue(), buffer(), blocking, flags, offset, size,
5674              (events != NULL) ? (cl_uint) events-&gt;size() : 0,
5675              (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*) &amp;events-&gt;front() : NULL,
5676              (cl_event*) event,
5677              &amp;error);
5678      detail::errHandler(error, __ENQUEUE_MAP_BUFFER_ERR);
5679      if (err != NULL) {
5680          *err = error;
5681      }
5682      return result;
5683  }
5684  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 200
5685  template&lt;typename T&gt;
5686  inline cl_int enqueueMapSVM(
5687      T* ptr,
5688      cl_bool blocking,
5689      cl_map_flags flags,
5690      size_type size,
5691      const vector&lt;Event&gt;* events,
5692      Event* event)
5693  {
5694      cl_int error;
5695      CommandQueue queue = CommandQueue::getDefault(&amp;error);
5696      if (error != CL_SUCCESS) {
5697          return detail::errHandler(error, __ENQUEUE_MAP_BUFFER_ERR);
5698      }
5699      return queue.enqueueMapSVM(
5700          ptr, blocking, flags, size, events, event);
5701  }
5702  template&lt;typename T, class D&gt;
5703  inline cl_int enqueueMapSVM(
5704      cl::pointer&lt;T, D&gt; ptr,
5705      cl_bool blocking,
5706      cl_map_flags flags,
5707      size_type size,
5708      const vector&lt;Event&gt;* events = NULL,
5709      Event* event = NULL)
5710  {
5711      cl_int error;
5712      CommandQueue queue = CommandQueue::getDefault(&amp;error);
5713      if (error != CL_SUCCESS) {
5714          return detail::errHandler(error, __ENQUEUE_MAP_BUFFER_ERR);
5715      }
5716      return queue.enqueueMapSVM(
5717          ptr, blocking, flags, size, events, event);
5718  }
5719  template&lt;typename T, class Alloc&gt;
5720  inline cl_int enqueueMapSVM(
5721      cl::vector&lt;T, Alloc&gt; container,
5722      cl_bool blocking,
5723      cl_map_flags flags,
5724      const vector&lt;Event&gt;* events = NULL,
5725      Event* event = NULL)
5726  {
5727      cl_int error;
5728      CommandQueue queue = CommandQueue::getDefault(&amp;error);
5729      if (error != CL_SUCCESS) {
5730          return detail::errHandler(error, __ENQUEUE_MAP_BUFFER_ERR);
5731      }
5732      return queue.enqueueMapSVM(
5733          container, blocking, flags, events, event);
5734  }
5735  #endif 
5736  inline cl_int enqueueUnmapMemObject(
5737      const Memory&amp; memory,
5738      void* mapped_ptr,
5739      const vector&lt;Event&gt;* events = NULL,
5740      Event* event = NULL)
5741  {
5742      cl_int error;
5743      CommandQueue queue = CommandQueue::getDefault(&amp;error);
5744      detail::errHandler(error, __ENQUEUE_MAP_BUFFER_ERR);
5745      if (error != CL_SUCCESS) {
5746          return error;
5747      }
5748      cl_event tmp;
5749      cl_int err = detail::errHandler(
5750          ::clEnqueueUnmapMemObject(
5751          queue(), memory(), mapped_ptr,
5752          (events != NULL) ? (cl_uint)events-&gt;size() : 0,
5753          (events != NULL &amp;&amp; events-&gt;size() &gt; 0) ? (cl_event*)&amp;events-&gt;front() : NULL,
5754          (event != NULL) ? &amp;tmp : NULL),
5755          __ENQUEUE_UNMAP_MEM_OBJECT_ERR);
5756      if (event != NULL &amp;&amp; err == CL_SUCCESS)
5757          *event = tmp;
5758      return err;
5759  }
5760  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 200
5761  template&lt;typename T&gt;
5762  inline cl_int enqueueUnmapSVM(
5763      T* ptr,
5764      const vector&lt;Event&gt;* events = NULL,
5765      Event* event = NULL)
5766  {
5767      cl_int error;
5768      CommandQueue queue = CommandQueue::getDefault(&amp;error);
5769      if (error != CL_SUCCESS) {
5770          return detail::errHandler(error, __ENQUEUE_UNMAP_MEM_OBJECT_ERR);
5771      }
5772      return detail::errHandler(queue.enqueueUnmapSVM(ptr, events, event), 
5773          __ENQUEUE_UNMAP_MEM_OBJECT_ERR);
5774  }
5775  template&lt;typename T, class D&gt;
5776  inline cl_int enqueueUnmapSVM(
5777      cl::pointer&lt;T, D&gt; &amp;ptr,
5778      const vector&lt;Event&gt;* events = NULL,
5779      Event* event = NULL)
5780  {
5781      cl_int error;
5782      CommandQueue queue = CommandQueue::getDefault(&amp;error);
5783      if (error != CL_SUCCESS) {
5784          return detail::errHandler(error, __ENQUEUE_UNMAP_MEM_OBJECT_ERR);
5785      }
5786      return detail::errHandler(queue.enqueueUnmapSVM(ptr, events, event),
5787          __ENQUEUE_UNMAP_MEM_OBJECT_ERR);
5788  }
5789  template&lt;typename T, class Alloc&gt;
5790  inline cl_int enqueueUnmapSVM(
5791      cl::vector&lt;T, Alloc&gt; &amp;container,
5792      const vector&lt;Event&gt;* events = NULL,
5793      Event* event = NULL)
5794  {
5795      cl_int error;
5796      CommandQueue queue = CommandQueue::getDefault(&amp;error);
5797      if (error != CL_SUCCESS) {
5798          return detail::errHandler(error, __ENQUEUE_UNMAP_MEM_OBJECT_ERR);
5799      }
5800      return detail::errHandler(queue.enqueueUnmapSVM(container, events, event),
5801          __ENQUEUE_UNMAP_MEM_OBJECT_ERR);
5802  }
5803  #endif 
5804  inline cl_int enqueueCopyBuffer(
5805          const Buffer&amp; src,
5806          const Buffer&amp; dst,
5807          size_type src_offset,
5808          size_type dst_offset,
5809          size_type size,
5810          const vector&lt;Event&gt;* events = NULL,
5811          Event* event = NULL)
5812  {
5813      cl_int error;
5814      CommandQueue queue = CommandQueue::getDefault(&amp;error);
5815      if (error != CL_SUCCESS) {
5816          return error;
5817      }
5818      return queue.enqueueCopyBuffer(src, dst, src_offset, dst_offset, size, events, event);
5819  }
5820  template&lt; typename IteratorType &gt;
5821  inline cl_int copy( IteratorType startIterator, IteratorType endIterator, cl::Buffer &amp;buffer )
5822  {
5823      cl_int error;
5824      CommandQueue queue = CommandQueue::getDefault(&amp;error);
5825      if (error != CL_SUCCESS)
5826          return error;
5827      return cl::copy(queue, startIterator, endIterator, buffer);
5828  }
5829  template&lt; typename IteratorType &gt;
5830  inline cl_int copy( const cl::Buffer &amp;buffer, IteratorType startIterator, IteratorType endIterator )
5831  {
5832      cl_int error;
5833      CommandQueue queue = CommandQueue::getDefault(&amp;error);
5834      if (error != CL_SUCCESS)
5835          return error;
5836      return cl::copy(queue, buffer, startIterator, endIterator);
5837  }
5838  template&lt; typename IteratorType &gt;
5839  inline cl_int copy( const CommandQueue &amp;queue, IteratorType startIterator, IteratorType endIterator, cl::Buffer &amp;buffer )
5840  {
5841      typedef typename std::iterator_traits&lt;IteratorType&gt;::value_type DataType;
5842      cl_int error;
5843      size_type length = endIterator-startIterator;
5844      size_type byteLength = length*sizeof(DataType);
5845      DataType *pointer = 
5846          static_cast&lt;DataType*&gt;(queue.enqueueMapBuffer(buffer, CL_TRUE, CL_MAP_WRITE, 0, byteLength, 0, 0, &amp;error));
5847      if( error != CL_SUCCESS ) {
5848          return error;
5849      }
5850  #if defined(_MSC_VER)
5851      std::copy(
5852          startIterator, 
5853          endIterator, 
5854          stdext::checked_array_iterator&lt;DataType*&gt;(
5855              pointer, length));
5856  #else
5857      std::copy(startIterator, endIterator, pointer);
5858  #endif
5859      Event endEvent;
5860      error = queue.enqueueUnmapMemObject(buffer, pointer, 0, &amp;endEvent);
5861      if( error != CL_SUCCESS ) { 
5862          return error;
5863      }
5864      endEvent.wait();
5865      return CL_SUCCESS;
5866  }
5867  template&lt; typename IteratorType &gt;
5868  inline cl_int copy( const CommandQueue &amp;queue, const cl::Buffer &amp;buffer, IteratorType startIterator, IteratorType endIterator )
5869  {
5870      typedef typename std::iterator_traits&lt;IteratorType&gt;::value_type DataType;
5871      cl_int error;
5872      size_type length = endIterator-startIterator;
5873      size_type byteLength = length*sizeof(DataType);
5874      DataType *pointer = 
5875          static_cast&lt;DataType*&gt;(queue.enqueueMapBuffer(buffer, CL_TRUE, CL_MAP_READ, 0, byteLength, 0, 0, &amp;error));
5876      if( error != CL_SUCCESS ) {
5877          return error;
5878      }
5879      std::copy(pointer, pointer + length, startIterator);
5880      Event endEvent;
5881      error = queue.enqueueUnmapMemObject(buffer, pointer, 0, &amp;endEvent);
5882      if( error != CL_SUCCESS ) { 
5883          return error;
5884      }
5885      endEvent.wait();
5886      return CL_SUCCESS;
5887  }
5888  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 200
5889  template&lt;typename T, class Alloc&gt;
5890  inline cl_int mapSVM(cl::vector&lt;T, Alloc&gt; &amp;container)
5891  {
5892      return enqueueMapSVM(container, CL_TRUE, CL_MAP_READ | CL_MAP_WRITE);
5893  }
5894  template&lt;typename T, class Alloc&gt;
5895  inline cl_int unmapSVM(cl::vector&lt;T, Alloc&gt; &amp;container)
5896  {
5897      return enqueueUnmapSVM(container);
5898  }
5899  #endif 
5900  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 110
5901  inline cl_int enqueueReadBufferRect(
5902      const Buffer&amp; buffer,
5903      cl_bool blocking,
5904      const array&lt;size_type, 3&gt;&amp; buffer_offset,
5905      const array&lt;size_type, 3&gt;&amp; host_offset,
5906      const array&lt;size_type, 3&gt;&amp; region,
5907      size_type buffer_row_pitch,
5908      size_type buffer_slice_pitch,
5909      size_type host_row_pitch,
5910      size_type host_slice_pitch,
5911      void *ptr,
5912      const vector&lt;Event&gt;* events = NULL,
5913      Event* event = NULL)
5914  {
5915      cl_int error;
5916      CommandQueue queue = CommandQueue::getDefault(&amp;error);
5917      if (error != CL_SUCCESS) {
5918          return error;
5919      }
5920      return queue.enqueueReadBufferRect(
5921          buffer, 
5922          blocking, 
5923          buffer_offset, 
5924          host_offset,
5925          region,
5926          buffer_row_pitch,
5927          buffer_slice_pitch,
5928          host_row_pitch,
5929          host_slice_pitch,
5930          ptr, 
5931          events, 
5932          event);
5933  }
5934  inline cl_int enqueueWriteBufferRect(
5935      const Buffer&amp; buffer,
5936      cl_bool blocking,
5937      const array&lt;size_type, 3&gt;&amp; buffer_offset,
5938      const array&lt;size_type, 3&gt;&amp; host_offset,
5939      const array&lt;size_type, 3&gt;&amp; region,
5940      size_type buffer_row_pitch,
5941      size_type buffer_slice_pitch,
5942      size_type host_row_pitch,
5943      size_type host_slice_pitch,
5944      void *ptr,
5945      const vector&lt;Event&gt;* events = NULL,
5946      Event* event = NULL)
5947  {
5948      cl_int error;
5949      CommandQueue queue = CommandQueue::getDefault(&amp;error);
5950      if (error != CL_SUCCESS) {
5951          return error;
5952      }
5953      return queue.enqueueWriteBufferRect(
5954          buffer, 
5955          blocking, 
5956          buffer_offset, 
5957          host_offset,
5958          region,
5959          buffer_row_pitch,
5960          buffer_slice_pitch,
5961          host_row_pitch,
5962          host_slice_pitch,
5963          ptr, 
5964          events, 
5965          event);
5966  }
5967  inline cl_int enqueueCopyBufferRect(
5968      const Buffer&amp; src,
5969      const Buffer&amp; dst,
5970      const array&lt;size_type, 3&gt;&amp; src_origin,
5971      const array&lt;size_type, 3&gt;&amp; dst_origin,
5972      const array&lt;size_type, 3&gt;&amp; region,
5973      size_type src_row_pitch,
5974      size_type src_slice_pitch,
5975      size_type dst_row_pitch,
5976      size_type dst_slice_pitch,
5977      const vector&lt;Event&gt;* events = NULL,
5978      Event* event = NULL)
5979  {
5980      cl_int error;
5981      CommandQueue queue = CommandQueue::getDefault(&amp;error);
5982      if (error != CL_SUCCESS) {
5983          return error;
5984      }
5985      return queue.enqueueCopyBufferRect(
5986          src,
5987          dst,
5988          src_origin,
5989          dst_origin,
5990          region,
5991          src_row_pitch,
5992          src_slice_pitch,
5993          dst_row_pitch,
5994          dst_slice_pitch,
5995          events, 
5996          event);
5997  }
5998  #endif 
5999  inline cl_int enqueueReadImage(
6000      const Image&amp; image,
6001      cl_bool blocking,
6002      const array&lt;size_type, 3&gt;&amp; origin,
6003      const array&lt;size_type, 3&gt;&amp; region,
6004      size_type row_pitch,
6005      size_type slice_pitch,
6006      void* ptr,
6007      const vector&lt;Event&gt;* events = NULL,
6008      Event* event = NULL) 
6009  {
6010      cl_int error;
6011      CommandQueue queue = CommandQueue::getDefault(&amp;error);
6012      if (error != CL_SUCCESS) {
6013          return error;
6014      }
6015      return queue.enqueueReadImage(
6016          image,
6017          blocking,
6018          origin,
6019          region,
6020          row_pitch,
6021          slice_pitch,
6022          ptr,
6023          events, 
6024          event);
6025  }
6026  inline cl_int enqueueWriteImage(
6027      const Image&amp; image,
6028      cl_bool blocking,
6029      const array&lt;size_type, 3&gt;&amp; origin,
6030      const array&lt;size_type, 3&gt;&amp; region,
6031      size_type row_pitch,
6032      size_type slice_pitch,
6033      void* ptr,
6034      const vector&lt;Event&gt;* events = NULL,
6035      Event* event = NULL)
6036  {
6037      cl_int error;
6038      CommandQueue queue = CommandQueue::getDefault(&amp;error);
6039      if (error != CL_SUCCESS) {
6040          return error;
6041      }
6042      return queue.enqueueWriteImage(
6043          image,
6044          blocking,
6045          origin,
6046          region,
6047          row_pitch,
6048          slice_pitch,
6049          ptr,
6050          events, 
6051          event);
6052  }
6053  inline cl_int enqueueCopyImage(
6054      const Image&amp; src,
6055      const Image&amp; dst,
6056      const array&lt;size_type, 3&gt;&amp; src_origin,
6057      const array&lt;size_type, 3&gt;&amp; dst_origin,
6058      const array&lt;size_type, 3&gt;&amp; region,
6059      const vector&lt;Event&gt;* events = NULL,
6060      Event* event = NULL)
6061  {
6062      cl_int error;
6063      CommandQueue queue = CommandQueue::getDefault(&amp;error);
6064      if (error != CL_SUCCESS) {
6065          return error;
6066      }
6067      return queue.enqueueCopyImage(
6068          src,
6069          dst,
6070          src_origin,
6071          dst_origin,
6072          region,
6073          events,
6074          event);
6075  }
6076  inline cl_int enqueueCopyImageToBuffer(
6077      const Image&amp; src,
6078      const Buffer&amp; dst,
6079      const array&lt;size_type, 3&gt;&amp; src_origin,
6080      const array&lt;size_type, 3&gt;&amp; region,
6081      size_type dst_offset,
6082      const vector&lt;Event&gt;* events = NULL,
6083      Event* event = NULL)
6084  {
6085      cl_int error;
6086      CommandQueue queue = CommandQueue::getDefault(&amp;error);
6087      if (error != CL_SUCCESS) {
6088          return error;
6089      }
6090      return queue.enqueueCopyImageToBuffer(
6091          src,
6092          dst,
6093          src_origin,
6094          region,
6095          dst_offset,
6096          events,
6097          event);
6098  }
6099  inline cl_int enqueueCopyBufferToImage(
6100      const Buffer&amp; src,
6101      const Image&amp; dst,
6102      size_type src_offset,
6103      const array&lt;size_type, 3&gt;&amp; dst_origin,
6104      const array&lt;size_type, 3&gt;&amp; region,
6105      const vector&lt;Event&gt;* events = NULL,
6106      Event* event = NULL)
6107  {
6108      cl_int error;
6109      CommandQueue queue = CommandQueue::getDefault(&amp;error);
6110      if (error != CL_SUCCESS) {
6111          return error;
6112      }
6113      return queue.enqueueCopyBufferToImage(
6114          src,
6115          dst,
6116          src_offset,
6117          dst_origin,
6118          region,
6119          events,
6120          event);
6121  }
6122  inline cl_int flush(void)
6123  {
6124      cl_int error;
6125      CommandQueue queue = CommandQueue::getDefault(&amp;error);
6126      if (error != CL_SUCCESS) {
6127          return error;
6128      }
6129      return queue.flush();
6130  }
6131  inline cl_int finish(void)
6132  {
6133      cl_int error;
6134      CommandQueue queue = CommandQueue::getDefault(&amp;error);
6135      if (error != CL_SUCCESS) {
6136          return error;
6137      } 
6138      return queue.finish();
6139  }
6140  class EnqueueArgs
6141  {
6142  private:
6143      CommandQueue queue_;
6144      const NDRange offset_;
6145      const NDRange global_;
6146      const NDRange local_;
6147      vector&lt;Event&gt; events_;
6148      template&lt;typename... Ts&gt;
6149      friend class KernelFunctor;
6150  public:
6151      EnqueueArgs(NDRange global) : 
6152        queue_(CommandQueue::getDefault()),
6153        offset_(NullRange), 
6154        global_(global),
6155        local_(NullRange)
6156      {
6157      }
6158      EnqueueArgs(NDRange global, NDRange local) : 
6159        queue_(CommandQueue::getDefault()),
6160        offset_(NullRange), 
6161        global_(global),
6162        local_(local)
6163      {
6164      }
6165      EnqueueArgs(NDRange offset, NDRange global, NDRange local) : 
6166        queue_(CommandQueue::getDefault()),
6167        offset_(offset), 
6168        global_(global),
6169        local_(local)
6170      {
6171      }
6172      EnqueueArgs(Event e, NDRange global) : 
6173        queue_(CommandQueue::getDefault()),
6174        offset_(NullRange), 
6175        global_(global),
6176        local_(NullRange)
6177      {
6178          events_.push_back(e);
6179      }
6180      EnqueueArgs(Event e, NDRange global, NDRange local) : 
6181        queue_(CommandQueue::getDefault()),
6182        offset_(NullRange), 
6183        global_(global),
6184        local_(local)
6185      {
6186          events_.push_back(e);
6187      }
6188      EnqueueArgs(Event e, NDRange offset, NDRange global, NDRange local) : 
6189        queue_(CommandQueue::getDefault()),
6190        offset_(offset), 
6191        global_(global),
6192        local_(local)
6193      {
6194          events_.push_back(e);
6195      }
6196      EnqueueArgs(const vector&lt;Event&gt; &amp;events, NDRange global) : 
6197        queue_(CommandQueue::getDefault()),
6198        offset_(NullRange), 
6199        global_(global),
6200        local_(NullRange),
6201        events_(events)
6202      {
6203      }
6204      EnqueueArgs(const vector&lt;Event&gt; &amp;events, NDRange global, NDRange local) : 
6205        queue_(CommandQueue::getDefault()),
6206        offset_(NullRange), 
6207        global_(global),
6208        local_(local),
6209        events_(events)
6210      {
6211      }
6212      EnqueueArgs(const vector&lt;Event&gt; &amp;events, NDRange offset, NDRange global, NDRange local) : 
6213        queue_(CommandQueue::getDefault()),
6214        offset_(offset), 
6215        global_(global),
6216        local_(local),
6217        events_(events)
6218      {
6219      }
6220      EnqueueArgs(CommandQueue &amp;queue, NDRange global) : 
6221        queue_(queue),
6222        offset_(NullRange), 
6223        global_(global),
6224        local_(NullRange)
6225      {
6226      }
6227      EnqueueArgs(CommandQueue &amp;queue, NDRange global, NDRange local) : 
6228        queue_(queue),
6229        offset_(NullRange), 
6230        global_(global),
6231        local_(local)
6232      {
6233      }
6234      EnqueueArgs(CommandQueue &amp;queue, NDRange offset, NDRange global, NDRange local) : 
6235        queue_(queue),
6236        offset_(offset), 
6237        global_(global),
6238        local_(local)
6239      {
6240      }
6241      EnqueueArgs(CommandQueue &amp;queue, Event e, NDRange global) : 
6242        queue_(queue),
6243        offset_(NullRange), 
6244        global_(global),
6245        local_(NullRange)
6246      {
6247          events_.push_back(e);
6248      }
6249      EnqueueArgs(CommandQueue &amp;queue, Event e, NDRange global, NDRange local) : 
6250        queue_(queue),
6251        offset_(NullRange), 
6252        global_(global),
6253        local_(local)
6254      {
6255          events_.push_back(e);
6256      }
6257      EnqueueArgs(CommandQueue &amp;queue, Event e, NDRange offset, NDRange global, NDRange local) : 
6258        queue_(queue),
6259        offset_(offset), 
6260        global_(global),
6261        local_(local)
6262      {
6263          events_.push_back(e);
6264      }
6265      EnqueueArgs(CommandQueue &amp;queue, const vector&lt;Event&gt; &amp;events, NDRange global) : 
6266        queue_(queue),
6267        offset_(NullRange), 
6268        global_(global),
6269        local_(NullRange),
6270        events_(events)
6271      {
6272      }
6273      EnqueueArgs(CommandQueue &amp;queue, const vector&lt;Event&gt; &amp;events, NDRange global, NDRange local) : 
6274        queue_(queue),
6275        offset_(NullRange), 
6276        global_(global),
6277        local_(local),
6278        events_(events)
6279      {
6280      }
6281      EnqueueArgs(CommandQueue &amp;queue, const vector&lt;Event&gt; &amp;events, NDRange offset, NDRange global, NDRange local) : 
6282        queue_(queue),
6283        offset_(offset), 
6284        global_(global),
6285        local_(local),
6286        events_(events)
6287      {
6288      }
6289  };
6290  template&lt;typename... Ts&gt;
6291  class KernelFunctor
6292  {
6293  private:
6294      Kernel kernel_;
6295      template&lt;int index, typename T0, typename... T1s&gt;
6296      void setArgs(T0&amp;&amp; t0, T1s&amp;&amp;... t1s)
6297      {
6298          kernel_.setArg(index, t0);
6299          setArgs&lt;index + 1, T1s...&gt;(std::forward&lt;T1s&gt;(t1s)...);
6300      }
6301      template&lt;int index, typename T0&gt;
6302      void setArgs(T0&amp;&amp; t0)
6303      {
6304          kernel_.setArg(index, t0);
6305      }
6306      template&lt;int index&gt;
6307      void setArgs()
6308      {
6309      }
6310  public:
6311      KernelFunctor(Kernel kernel) : kernel_(kernel)
6312      {}
6313      KernelFunctor(
6314          const Program&amp; program,
6315          const string name,
6316          cl_int * err = NULL) :
6317          kernel_(program, name.c_str(), err)
6318      {}
6319      typedef Event result_type;
6320      Event operator() (
6321          const EnqueueArgs&amp; args,
6322          Ts... ts)
6323      {
6324          Event event;
6325          setArgs&lt;0&gt;(std::forward&lt;Ts&gt;(ts)...);
6326          args.queue_.enqueueNDRangeKernel(
6327              kernel_,
6328              args.offset_,
6329              args.global_,
6330              args.local_,
6331              &amp;args.events_,
6332              &amp;event);
6333          return event;
6334      }
6335      Event operator() (
6336          const EnqueueArgs&amp; args,
6337          Ts... ts,
6338          cl_int &amp;error)
6339      {
6340          Event event;
6341          setArgs&lt;0&gt;(std::forward&lt;Ts&gt;(ts)...);
6342          error = args.queue_.enqueueNDRangeKernel(
6343              kernel_,
6344              args.offset_,
6345              args.global_,
6346              args.local_,
6347              &amp;args.events_,
6348              &amp;event);
6349          return event;
6350      }
6351  #if CL_HPP_TARGET_OPENCL_VERSION &gt;= 200
6352      cl_int setSVMPointers(const vector&lt;void*&gt; &amp;pointerList)
6353      {
6354          return kernel_.setSVMPointers(pointerList);
6355      }
6356      template&lt;typename T0, typename... T1s&gt;
6357      cl_int setSVMPointers(const T0 &amp;t0, T1s... ts)
6358      {
6359          return kernel_.setSVMPointers(t0, ts...);
6360      }
6361  #endif 
6362      Kernel getKernel()
6363      {
6364          return kernel_;
6365      }
6366  };
6367  namespace compatibility {
6368      template&lt;typename... Ts&gt;
6369      struct make_kernel
6370      {
6371          typedef KernelFunctor&lt;Ts...&gt; FunctorType;
6372          FunctorType functor_;
6373          make_kernel(
6374              const Program&amp; program,
6375              const string name,
6376              cl_int * err = NULL) :
6377              functor_(FunctorType(program, name, err))
6378          {}
6379          make_kernel(
6380              const Kernel kernel) :
6381              functor_(FunctorType(kernel))
6382          {}
6383          typedef Event result_type;
6384          typedef Event type_(
6385              const EnqueueArgs&amp;,
6386              Ts...);
6387          Event operator()(
6388              const EnqueueArgs&amp; enqueueArgs,
6389              Ts... args)
6390          {
6391              return functor_(
6392                  enqueueArgs, args...);
6393          }
6394      };
6395  } 
6396  #undef CL_HPP_ERR_STR_
6397  #if !defined(CL_HPP_USER_OVERRIDE_ERROR_STRINGS)
6398  #undef __GET_DEVICE_INFO_ERR
6399  #undef __GET_PLATFORM_INFO_ERR
6400  #undef __GET_DEVICE_IDS_ERR
6401  #undef __GET_CONTEXT_INFO_ERR
6402  #undef __GET_EVENT_INFO_ERR
6403  #undef __GET_EVENT_PROFILE_INFO_ERR
6404  #undef __GET_MEM_OBJECT_INFO_ERR
6405  #undef __GET_IMAGE_INFO_ERR
6406  #undef __GET_SAMPLER_INFO_ERR
6407  #undef __GET_KERNEL_INFO_ERR
6408  #undef __GET_KERNEL_ARG_INFO_ERR
6409  #undef __GET_KERNEL_WORK_GROUP_INFO_ERR
6410  #undef __GET_PROGRAM_INFO_ERR
6411  #undef __GET_PROGRAM_BUILD_INFO_ERR
6412  #undef __GET_COMMAND_QUEUE_INFO_ERR
6413  #undef __CREATE_CONTEXT_ERR
6414  #undef __CREATE_CONTEXT_FROM_TYPE_ERR
6415  #undef __GET_SUPPORTED_IMAGE_FORMATS_ERR
6416  #undef __CREATE_BUFFER_ERR
6417  #undef __CREATE_SUBBUFFER_ERR
6418  #undef __CREATE_IMAGE2D_ERR
6419  #undef __CREATE_IMAGE3D_ERR
6420  #undef __CREATE_SAMPLER_ERR
6421  #undef __SET_MEM_OBJECT_DESTRUCTOR_CALLBACK_ERR
6422  #undef __CREATE_USER_EVENT_ERR
6423  #undef __SET_USER_EVENT_STATUS_ERR
6424  #undef __SET_EVENT_CALLBACK_ERR
6425  #undef __SET_PRINTF_CALLBACK_ERR
6426  #undef __WAIT_FOR_EVENTS_ERR
6427  #undef __CREATE_KERNEL_ERR
6428  #undef __SET_KERNEL_ARGS_ERR
6429  #undef __CREATE_PROGRAM_WITH_SOURCE_ERR
6430  #undef __CREATE_PROGRAM_WITH_BINARY_ERR
6431  #undef __CREATE_PROGRAM_WITH_BUILT_IN_KERNELS_ERR
6432  #undef __BUILD_PROGRAM_ERR
6433  #undef __CREATE_KERNELS_IN_PROGRAM_ERR
6434  #undef __CREATE_COMMAND_QUEUE_ERR
6435  #undef __SET_COMMAND_QUEUE_PROPERTY_ERR
6436  #undef __ENQUEUE_READ_BUFFER_ERR
6437  #undef __ENQUEUE_WRITE_BUFFER_ERR
6438  #undef __ENQUEUE_READ_BUFFER_RECT_ERR
6439  #undef __ENQUEUE_WRITE_BUFFER_RECT_ERR
6440  #undef __ENQEUE_COPY_BUFFER_ERR
6441  #undef __ENQEUE_COPY_BUFFER_RECT_ERR
6442  #undef __ENQUEUE_READ_IMAGE_ERR
6443  #undef __ENQUEUE_WRITE_IMAGE_ERR
6444  #undef __ENQUEUE_COPY_IMAGE_ERR
6445  #undef __ENQUEUE_COPY_IMAGE_TO_BUFFER_ERR
6446  #undef __ENQUEUE_COPY_BUFFER_TO_IMAGE_ERR
6447  #undef __ENQUEUE_MAP_BUFFER_ERR
6448  #undef __ENQUEUE_MAP_IMAGE_ERR
6449  #undef __ENQUEUE_UNMAP_MEM_OBJECT_ERR
6450  #undef __ENQUEUE_NDRANGE_KERNEL_ERR
6451  #undef __ENQUEUE_TASK_ERR
6452  #undef __ENQUEUE_NATIVE_KERNEL
6453  #undef __UNLOAD_COMPILER_ERR
6454  #undef __CREATE_SUB_DEVICES_ERR
6455  #undef __CREATE_PIPE_ERR
6456  #undef __GET_PIPE_INFO_ERR
6457  #endif 
6458  #undef CL_HPP_INIT_CL_EXT_FCN_PTR_
6459  #undef CL_HPP_INIT_CL_EXT_FCN_PTR_PLATFORM_
6460  #if defined(CL_HPP_USE_CL_DEVICE_FISSION)
6461  #undef CL_HPP_PARAM_NAME_DEVICE_FISSION_
6462  #endif 
6463  #undef CL_HPP_NOEXCEPT_
6464  #undef CL_HPP_DEFINE_STATIC_MEMBER_
6465  } 
6466  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-cl.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-cl2.hpp</div>
                </div>
                <div class="column column_space"><pre><code>1708      Context(
1709          const Device&amp; device,
1710          cl_context_properties* properties = NULL,
1711          void (CL_CALLBACK * notifyFptr)(
1712              const char *,
1713              const void *,
1714              ::size_t,
</pre></code></div>
                <div class="column column_space"><pre><code>1664      Context(
1665          const Device&amp; device,
1666          cl_context_properties* properties = NULL,
1667          void (CL_CALLBACK * notifyFptr)(
1668              const char *,
1669              const void *,
1670              size_type,
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    