
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.543307086614173%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-entry_2.cpp</h3>
            <pre><code>1  #include <nano/boost/process/child.hpp>
2  #include <nano/crypto_lib/random_pool.hpp>
3  #include <nano/lib/cli.hpp>
4  #include <nano/lib/errors.hpp>
5  #include <nano/lib/rpcconfig.hpp>
6  #include <nano/lib/threading.hpp>
7  #include <nano/lib/tlsconfig.hpp>
8  #include <nano/lib/tomlconfig.hpp>
9  #include <nano/lib/utility.hpp>
10  #include <nano/lib/walletconfig.hpp>
11  #include <nano/nano_wallet/icon.hpp>
12  #include <nano/node/cli.hpp>
13  #include <nano/node/daemonconfig.hpp>
14  #include <nano/node/ipc/ipc_server.hpp>
15  #include <nano/node/json_handler.hpp>
16  #include <nano/node/node_rpc_config.hpp>
17  #include <nano/qt/qt.hpp>
18  #include <nano/rpc/rpc.hpp>
19  #include <nano/secure/working.hpp>
20  #include <boost/make_shared.hpp>
21  #include <boost/program_options.hpp>
22  #include <boost/property_tree/json_parser.hpp>
23  #include <boost/property_tree/ptree.hpp>
24  namespace
25  {
26  void show_error (std::string const & message_a)
27  {
28  	QMessageBox message (QMessageBox::Critical, "Error starting Nano", message_a.c_str ());
29  	message.setModal (true);
30  	message.show ();
31  	message.exec ();
32  }
33  void show_help (std::string const & message_a)
34  {
35  	QMessageBox message (QMessageBox::NoIcon, "Help", "see <a href=\"https:&bsol;&bsol;docs.nano.org/commands/command-line-interface/#launch-options\">launch options</a> ");
36  	message.setStyleSheet ("QLabel {min-width: 450px}");
37  	message.setDetailedText (message_a.c_str ());
38  	message.show ();
39  	message.exec ();
40  }
41  nano::error write_wallet_config (nano::wallet_config & config_a, boost::filesystem::path const & data_path_a)
42  {
43  	nano::tomlconfig wallet_config_toml;
44  	auto wallet_path (nano::get_qtwallet_toml_config_path (data_path_a));
45  	config_a.serialize_toml (wallet_config_toml);
46  	wallet_config_toml.write (wallet_path);
47  	return wallet_config_toml.get_error ();
48  }
49  nano::error read_wallet_config (nano::wallet_config & config_a, boost::filesystem::path const & data_path_a)
50  {
51  	nano::tomlconfig wallet_config_toml;
52  	auto wallet_path (nano::get_qtwallet_toml_config_path (data_path_a));
53  	if (!boost::filesystem::exists (wallet_path))
54  	{
55  		write_wallet_config (config_a, data_path_a);
56  	}
57  	wallet_config_toml.read (wallet_path);
58  	config_a.deserialize_toml (wallet_config_toml);
59  	return wallet_config_toml.get_error ();
60  }
61  }
62  int run_wallet (QApplication & application, int argc, char * const * argv, boost::filesystem::path const & data_path, nano::node_flags const & flags)
63  {
64  	int result (0);
65  	nano_qt::eventloop_processor processor;
66  	boost::system::error_code error_chmod;
67  	boost::filesystem::create_directories (data_path);
68  	nano::set_secure_perm_directory (data_path, error_chmod);
69  	QPixmap pixmap (":/logo.png");
70  	auto * splash = new QSplashScreen (pixmap);
71  	splash->show ();
72  	QApplication::processEvents ();
73  	splash->showMessage (QSplashScreen::tr ("Remember - Back Up Your Wallet Seed"), Qt::AlignBottom | Qt::AlignHCenter, Qt::darkGray);
74  	QApplication::processEvents ();
75  	nano::network_params network_params{ nano::network_constants::active_network };
76  	nano::daemon_config config{ data_path, network_params };
77  	nano::wallet_config wallet_config;
78  	auto error = nano::read_node_config_toml (data_path, config, flags.config_overrides);
79  	if (!error)
80  	{
81  		error = read_wallet_config (wallet_config, data_path);
82  	}
83  	if (!error)
84  	{
85  		error = nano::flags_config_conflicts (flags, config.node);
86  	}
87  	if (!error)
88  	{
89  		nano::set_use_memory_pools (config.node.use_memory_pools);
90  		config.node.logging.init (data_path);
91  		nano::logger_mt logger{ config.node.logging.min_time_between_log_output };
92  		auto tls_config (std::make_shared<nano::tls_config> ());
93  		error = nano::read_tls_config_toml (data_path, *tls_config, logger);
94  		if (error)
95  		{
96  			splash->hide ();
97  			show_error (error.get_message ());
98  			std::exit (1);
99  		}
100  		else
101  		{
102  			config.node.websocket_config.tls_config = tls_config;
103  		}
104  		boost::asio::io_context io_ctx;
105  		nano::thread_runner runner (io_ctx, config.node.io_threads);
106  		std::shared_ptr<nano::node> node;
107  		std::shared_ptr<nano_qt::wallet> gui;
108  		nano::set_application_icon (application);
109  		auto opencl (nano::opencl_work::create (config.opencl_enable, config.opencl, logger, config.node.network_params.work));
110  		nano::work_pool work{ config.node.network_params.network, config.node.work_threads, config.node.pow_sleep_interval, opencl ? [&opencl] (nano::work_version const version_a, nano::root const & root_a, uint64_t difficulty_a, std::atomic<int> &) {
111  								 return opencl->generate_work (version_a, root_a, difficulty_a);
112  							 }
113  																																   : std::function<boost::optional<uint64_t> (nano::work_version const, nano::root const &, uint64_t, std::atomic<int> &)> (nullptr) };
114  		node = std::make_shared<nano::node> (io_ctx, data_path, config.node, work, flags);
115  		if (!node->init_error ())
116  		{
117  			auto wallet (node->wallets.open (wallet_config.wallet));
118  			if (wallet == nullptr)
119  			{
120  				auto existing (node->wallets.items.begin ());
121  				if (existing != node->wallets.items.end ())
122  				{
123  					wallet = existing->second;
124  					wallet_config.wallet = existing->first;
125  				}
126  				else
127  				{
128  					wallet = node->wallets.create (wallet_config.wallet);
129  				}
130  			}
131  			if (wallet_config.account.is_zero () || !wallet->exists (wallet_config.account))
132  			{
133  				auto transaction (wallet->wallets.tx_begin_write ());
134  				auto existing (wallet->store.begin (transaction));
<span onclick='openModal()' class='match'>135  				if (existing != wallet->store.end ())
136  				{
137  					wallet_config.account = existing->first;
138  				}
139  				else
140  				{
141  					wallet_config.account = wallet->deterministic_insert (transaction);
142  				}
143  			}
</span>144  			debug_assert (wallet->exists (wallet_config.account));
145  			write_wallet_config (wallet_config, data_path);
146  			node->start ();
147  			nano::ipc::ipc_server ipc (*node, config.rpc);
148  			std::unique_ptr<boost::process::child> rpc_process;
149  			std::unique_ptr<nano::rpc> rpc;
150  			std::unique_ptr<nano::rpc_handler_interface> rpc_handler;
151  			if (config.rpc_enable)
152  			{
153  				if (!config.rpc.child_process.enable)
154  				{
155  					nano::rpc_config rpc_config{ config.node.network_params.network };
156  					error = nano::read_rpc_config_toml (data_path, rpc_config, flags.rpc_config_overrides);
157  					if (error)
158  					{
159  						splash->hide ();
160  						show_error (error.get_message ());
161  						std::exit (1);
162  					}
163  					rpc_config.tls_config = tls_config;
164  					rpc_handler = std::make_unique<nano::inprocess_rpc_handler> (*node, ipc, config.rpc);
165  					rpc = nano::get_rpc (io_ctx, rpc_config, *rpc_handler);
166  					rpc->start ();
167  				}
168  				else
169  				{
170  					if (!boost::filesystem::exists (config.rpc.child_process.rpc_path))
171  					{
172  						throw std::runtime_error (std::string ("RPC is configured to spawn a new process however the file cannot be found at: ") + config.rpc.child_process.rpc_path);
173  					}
174  					auto network = node->network_params.network.get_current_network_as_string ();
175  					rpc_process = std::make_unique<boost::process::child> (config.rpc.child_process.rpc_path, "--daemon", "--data_path", data_path, "--network", network);
176  				}
177  			}
178  			QObject::connect (&application, &QApplication::aboutToQuit, [&] () {
179  				ipc.stop ();
180  				node->stop ();
181  				if (rpc)
182  				{
183  					rpc->stop ();
184  				}
185  #if USE_BOOST_PROCESS
186  				if (rpc_process)
187  				{
188  					rpc_process->terminate ();
189  				}
190  #endif
191  				runner.stop_event_processing ();
192  			});
193  			QApplication::postEvent (&processor, new nano_qt::eventloop_event ([&] () {
194  				gui = std::make_shared<nano_qt::wallet> (application, processor, *node, wallet, wallet_config.account);
195  				splash->close ();
196  				gui->start ();
197  				gui->client_window->show ();
198  			}));
199  			result = QApplication::exec ();
200  			runner.join ();
201  		}
202  		else
203  		{
204  			splash->hide ();
205  			show_error ("Error initializing node");
206  		}
207  		write_wallet_config (wallet_config, data_path);
208  	}
209  	else
210  	{
211  		splash->hide ();
212  		show_error ("Error deserializing config: " + error.get_message ());
213  	}
214  	return result;
215  }
216  int main (int argc, char * const * argv)
217  {
218  	nano::set_umask ();
219  	nano::node_singleton_memory_pool_purge_guard memory_pool_cleanup_guard;
220  	QApplication application (argc, const_cast<char **> (argv));
221  	try
222  	{
223  		boost::program_options::options_description description ("Command line options");
224  		description.add_options()
225  			("help", "Print out options")
226  			("config", boost::program_options::value<std::vector<nano::config_key_value_pair>>()->multitoken(), "Pass configuration values. This takes precedence over any values in the node configuration file. This option can be repeated multiple times.")
227  			("rpcconfig", boost::program_options::value<std::vector<nano::config_key_value_pair>>()->multitoken(), "Pass RPC configuration values. This takes precedence over any values in the RPC configuration file. This option can be repeated multiple times.");
228  		nano::add_node_flag_options (description);
229  		nano::add_node_options (description);
230  		boost::program_options::variables_map vm;
231  		try
232  		{
233  			boost::program_options::store (boost::program_options::parse_command_line (argc, argv, description), vm);
234  		}
235  		catch (boost::program_options::error const & err)
236  		{
237  			show_error (err.what ());
238  			return 1;
239  		}
240  		boost::program_options::notify (vm);
241  		int result (0);
242  		auto network (vm.find ("network"));
243  		if (network != vm.end ())
244  		{
245  			auto err (nano::network_constants::set_active_network (network->second.as<std::string> ()));
246  			if (err)
247  			{
248  				show_error (nano::network_constants::active_network_err_msg);
249  				std::exit (1);
250  			}
251  		}
252  		std::vector<std::string> config_overrides;
253  		const auto configItr = vm.find ("config");
254  		if (configItr != vm.cend ())
255  		{
256  			config_overrides = nano::config_overrides (configItr->second.as<std::vector<nano::config_key_value_pair>> ());
257  		}
258  		auto ec = nano::handle_node_options (vm);
259  		if (ec == nano::error_cli::unknown_command)
260  		{
261  			if (vm.count ("help") != 0)
262  			{
263  				std::ostringstream outstream;
264  				description.print (outstream);
265  				std::string helpstring = outstream.str ();
266  				show_help (helpstring);
267  				return 1;
268  			}
269  			else
270  			{
271  				try
272  				{
273  					boost::filesystem::path data_path;
274  					if (vm.count ("data_path"))
275  					{
276  						auto name (vm["data_path"].as<std::string> ());
277  						data_path = boost::filesystem::path (name);
278  					}
279  					else
280  					{
281  						data_path = nano::working_path ();
282  					}
283  					nano::node_flags flags;
284  					auto flags_ec = nano::update_flags (flags, vm);
285  					if (flags_ec)
286  					{
287  						throw std::runtime_error (flags_ec.message ());
288  					}
289  					result = run_wallet (application, argc, argv, data_path, flags);
290  				}
291  				catch (std::exception const & e)
292  				{
293  					show_error (boost::str (boost::format ("Exception while running wallet: %1%") % e.what ()));
294  				}
295  				catch (...)
296  				{
297  					show_error ("Unknown exception while running wallet");
298  				}
299  			}
300  		}
301  		return result;
302  	}
303  	catch (std::exception const & e)
304  	{
305  		show_error (boost::str (boost::format ("Exception while initializing %1%") % e.what ()));
306  	}
307  	catch (...)
308  	{
309  		show_error (boost::str (boost::format ("Unknown exception while initializing")));
310  	}
311  	return 1;
312  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-webnetobj.cpp</h3>
            <pre><code>1  void TWebNetTimer::OnTimeOut(){
2    WebNetClt->OnCheckTimeOut();
3  }
4  TWebNetSrv::TWebNetSrv(
5   const int& PortN, const bool& FixedPortNP, const PNotify& _Notify):
6    TNetSrv(PortN, FixedPortNP), Notify(_Notify) {
7  }
8  void TWebNetSrv::OnNetObj(const PNetObj& NetObj){
9    TStr NetObjTypeNm=GetTypeNm(*NetObj);
10    if (NetObjTypeNm==TTypeNm<TNetClose>()){
11      OnHttpRqError(NetObj->GetSockId(), "Connection Closed by Client");
12    } else
13    if (NetObjTypeNm==TTypeNm<TNetErr>()){
14      TNetErr& NetErr=*(TNetErr*)NetObj();
15      OnHttpRqError(NetObj->GetSockId(), TStr("Error: ")+NetErr.GetMsgStr());
16    } else
17    if (NetObjTypeNm==TTypeNm<TNetMem>()){
18      OnNetMem(NetObj);
19    }
20  }
21  void TWebNetSrv::OnNetMem(const PNetObj& NetObj){
22    TNetMem& NetMem=*(TNetMem*)NetObj();
23    const TMem& Mem=NetMem.GetMem();
24    PSIn MemIn=TMemIn::New(Mem);
25    PHttpRq HttpRq=THttpRq::New(MemIn);
26    OnHttpRq(NetObj->GetSockId(), HttpRq);
27  }
28  void TWebNetSrv::SendHttpResp(const int& SockId, const PHttpResp& HttpResp){
29    TMem Mem; HttpResp->GetAsMem(Mem);
30    PNetObj NetObj=PNetObj(new TNetMem(Mem));
31    SendNetObj(SockId, NetObj);
32  }
33  TWebNetClt::TWebNetClt(
34   const TStr& HostNm, const int& PortN,
35    TWebNetCltV* _WebNetCltV, const TStr& _IdStr, const PNotify& _Notify):
36    TNetClt(HostNm, PortN),
37    ConnIdStr(_IdStr),
38    Notify(_Notify),
39    WebNetCltV(_WebNetCltV),
40    ConnectedP(false),
41    Wait_FetchIdHttpRqCreateTmTrQ(),
42    Timer(){
43    Timer=TWebNetTimer::New(this);
44  }
45  TWebNetClt::~TWebNetClt(){}
46  void TWebNetClt::OnNetObj(const PNetObj& NetObj){
47    TStr NetObjTypeNm=GetTypeNm(*NetObj);
48    TNotify::OnNotify(Notify, ntInfo, TStr("TWebNetClt: ")+NetObj->GetStr());
49    if (NetObjTypeNm==TTypeNm<TNetConn>()){
50      ConnectedP=true; SendWaitQ();
51    } else
52    if (NetObjTypeNm==TTypeNm<TNetClose>()){
53      OnDisconn("Socket closed.");
54    } else
55    if (NetObjTypeNm==TTypeNm<TNetErr>()){
56      TNetErr& NetErr=*(TNetErr*)NetObj();
57      OnDisconn(TStr("Error: ")+NetErr.GetMsgStr());
58    } else
59    if (NetObjTypeNm==TTypeNm<TNetMem>()){
60      OnNetMem(NetObj);
61    } else {Fail;}
62  }
63  void TWebNetClt::OnNetMem(const PNetObj& NetObj){
64    TNetMem& NetMem=*(TNetMem*)NetObj();
65    const TMem& Mem=NetMem.GetMem();
66    IAssert("Screwed NetMem"&&!memchr(Mem(),0,Mem.Len()));
67    PSIn MemIn=TMemIn::New(Mem);
68    PHttpResp HttpResp=THttpResp::New(MemIn);
69    OnHttpResp(HttpResp);
70  }
71  void TWebNetClt::OnHttpResp(const PHttpResp& HttpResp){
72    IAssert(HttpResp->IsOk());
73    TStr FetchIdStr=HttpResp->GetFldVal(THttp::FetchIdFldNm);
74    int FetchId=FetchIdStr.GetInt(-1);
75    if (IsSentQEmpty()){return;} 
76    int TopFetchId; TTm TopCreateTm; TopFromSentQ(TopFetchId, TopCreateTm);
77    IAssert(FetchId==TopFetchId);
78    PopFromSentQ();
79    int StatusCd=HttpResp->GetStatusCd();
80    if (StatusCd/100==2){ 
81      WebNetCltV->OnHttpResp(FetchId, HttpResp);
82    } else
83    if (StatusCd/100==3){ 
84      TStr RedirUrlStr=HttpResp->GetFldVal("Location");
85      PUrl RedirUrl=TUrl::New(RedirUrlStr);
<span onclick='openModal()' class='match'>86      if (RedirUrl->IsOk(usHttp)){
87        TStr Host=HttpResp->GetFldVal(THttp::HostFldNm);
88        WebNetCltV->FetchUrl(RedirUrl, FetchId, Host);
89      } else {
90        TStr MsgStr=TStr("Invalid Redirection URL (")+RedirUrlStr+")";
91        WebNetCltV->OnHttpRespError(FetchId, MsgStr);
92      }
93    } else { 
</span>94      TStr MsgStr=TStr("Http Error (")+
95       TInt::GetStr(StatusCd)+"/"+HttpResp->GetReasonPhrase()+")";
96      WebNetCltV->OnHttpRespError(FetchId, MsgStr);
97    }
98  }
99  void TWebNetClt::SendHttpRq(const PHttpRq& HttpRq){
100    int FetchId=HttpRq->GetFldVal(THttp::FetchIdFldNm).GetInt(-1);
101    IAssert(FetchId!=-1);
102    TMem Mem; HttpRq->GetAsMem(Mem);
103    IAssert("Screwed NetMem"&&!memchr(Mem(),0,Mem.Len()));
104    PNetObj NetObj=PNetObj(new TNetMem(Mem));
105    SendNetObj(NetObj);
106    PushToSentQ(FetchId);
107  }
108  void TWebNetClt::SendWaitQ(){
109    while (!IsWaitQEmpty()){
110      int FetchId; PHttpRq HttpRq; TTm CreateTm;
111      PopFromWaitQ(FetchId, HttpRq, CreateTm);
112      IAssert(FetchId!=-1);
113      SendHttpRq(HttpRq);
114    }
115  }
116  void TWebNetClt::OnCheckTimeOut(){
117    TTm CurTm=TTm::GetCurUniTm();
118    int Timeout=WebNetCltV->GetCltTimeout();
119    bool DisconnP=false;
120    if (!IsSentQEmpty()){
121      int FetchId; TTm CreateTm;
122      TopFromSentQ(FetchId, CreateTm);
123      uint64 DiffMSecs=TTm::GetDiffMSecs(CurTm, CreateTm);
124      DisconnP = DiffMSecs>Timeout;
125    }
126    if (!IsWaitQEmpty()){
127      int FetchId; PHttpRq HttpRq; TTm CreateTm;
128      TopFromWaitQ(FetchId, HttpRq, CreateTm);
129      uint64 DiffMSecs=TTm::GetDiffMSecs(CurTm, CreateTm);
130      DisconnP |= DiffMSecs>Timeout;
131    }
132    if (DisconnP){
133      OnDisconn("Timeout.");
134    }
135  }
136  void TWebNetClt::OnDisconn(const TStr& MsgStr){
137    PWebNetClt KeepRef=this;
138    WebNetCltV->DelIfWebNetClt(GetConnIdStr());
139    while (!IsSentQEmpty()){
140      int FetchId; TTm CreateTm;
141      PopFromSentQ(FetchId, CreateTm);
142      WebNetCltV->OnHttpRespError(FetchId,MsgStr);
143    }
144    while (!IsWaitQEmpty()){
145      int FetchId; PHttpRq HttpRq; TTm CreateTm;
146      PopFromWaitQ(FetchId, HttpRq, CreateTm);
147      WebNetCltV->OnHttpRespError(FetchId,MsgStr);
148    }
149  }
150  TWebNetCltV::TWebNetCltV(const PNotify& _Notify):
151    Notify(_Notify),
152    ConnIdStrToWebNetCltH(),
153    LastFetchId(0),
154    CltTimeout(TWebNetCltV::DfCltTimeout) {
155  }
156  void TWebNetCltV::SendHttpRq(const TStr& ConnIdStr, const PHttpRq& HttpRq){
157    PWebNetClt WebNetClt=ConnIdStrToWebNetCltH.GetDat(ConnIdStr);
158    WebNetClt->SendHttpRq(HttpRq);
159  }
160  int TWebNetCltV::FetchUrl(const PUrl& Url, const int& _FetchId, TStr ConnUid){
161    IAssert(Url->IsOk(usHttp));
162    int FetchId=_FetchId;
163    if (_FetchId==-1){
164      FetchId=GetNextFetchId();}
165    PHttpRq HttpRq=THttpRq::New(Url, FetchId);
166    TStr HostNm=Url->GetHostNm();
167    int PortN=Url->GetPortN();
168    TStr ConnIdStr=TWebNetClt::GetConnIdStr(HostNm, PortN, ConnUid);
169    PWebNetClt WebNetClt;
170    if (IsGetWebNetClt(ConnIdStr, WebNetClt)){
171      if (WebNetClt->IsConnected()){
172        WebNetClt->SendHttpRq(HttpRq);
173      } else {
174        WebNetClt->PushToWaitQ(FetchId, HttpRq);
175      }
176    } else {
177      WebNetClt=TWebNetClt::New(HostNm, PortN, this, ConnIdStr, Notify);
178      AddWebNetClt(ConnIdStr, WebNetClt);
179      WebNetClt->PushToWaitQ(FetchId, HttpRq);
180    }
181    return FetchId;
182  }
183  void TProxyConn::SendHttpResp(TWebNetSrv &WebNetSrv, PHttpResp HttpResp) {
184    if (WebNetSrv.IsCltSock(RqSockId)) {
185      HttpResp->AddFldVal(THttp::FetchIdFldNm,TInt(RqFetchId).GetStr());
186      WebNetSrv.SendHttpResp(RqSockId, HttpResp);
187    }
188  }
189  void TWebNetProxy::OnHttpRq(const int& SockId, const PHttpRq& HttpRq) {
190    TStr RqFetchIdStr=HttpRq->GetFldVal(THttp::FetchIdFldNm);
191    int RqFetchId=RqFetchIdStr.GetInt(-1);
192    TStr Host;
193    if (Host.Empty() || (Host=="Tralala")) Host = DfSrv;
194    if (Host.Empty()) {OnHttpRqError(SockId,"Missing proxy target."); return;}
195    if (RqFetchId==-1) {OnHttpRqError(SockId,"Missing fetch-id."); return;}
196    TStr RelUrlStr=HttpRq->GetUrl()->GetRelUrlStr();
197    PUrl RedirUrl=TUrl::New(Host+RelUrlStr);
198    int RespFetchId = FetchUrl(RedirUrl);
199    PProxyConn Conn = new TProxyConn(SockId,RqFetchId,RespFetchId);
200    RqSockIdToProxyH.AddDat(SockId,Conn);
201    RespFetchIdToProxyH.AddDat(RespFetchId,Conn);
202  };
203  void TWebNetProxy::OnHttpRqError(const int& SockId, const TStr& MsgStr) {
204    SaveToErrLog((TStr("ProxyRequestError: ")+MsgStr).CStr());
205    PProxyConn Conn;
206    if (RqSockIdToProxyH.IsKeyGetDat(SockId,Conn)) {
207      PHttpResp HttpResp=THttpResp::New(503, "", false, NULL, TStr());
208      Conn->SendHttpResp(*this,HttpResp);
209      RqSockIdToProxyH.DelIfKey(SockId);
210      RespFetchIdToProxyH.DelIfKey(Conn->GetRespFetchId());
211    }
212  }
213  void TWebNetProxy::OnHttpResp(const int& RespFetchId, const PHttpResp& HttpResp) {
214    PProxyConn Conn;
215    if (RespFetchIdToProxyH.IsKeyGetDat(RespFetchId,Conn)) {
216      Conn->SendHttpResp(*this,HttpResp);
217      RespFetchIdToProxyH.DelKey(RespFetchId);
218      RqSockIdToProxyH.DelIfKey(Conn->GetRqSockId());
219    }
220  }
221  void TWebNetProxy::OnHttpRespError(const int& RespFetchId, const TStr& MsgStr) {
222    SaveToErrLog((TStr("ProxyRequestFailed: ")+MsgStr).CStr());
223    PProxyConn Conn;
224    if (RespFetchIdToProxyH.IsKeyGetDat(RespFetchId,Conn)) {
225      PHttpResp HttpResp=THttpResp::New(503, "", false, NULL, TStr());
226      Conn->SendHttpResp(*this,HttpResp);
227      RespFetchIdToProxyH.DelKey(RespFetchId);
228      RqSockIdToProxyH.DelIfKey(Conn->GetRqSockId());
229    }
230  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-entry_2.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-webnetobj.cpp</div>
                </div>
                <div class="column column_space"><pre><code>135  				if (existing != wallet->store.end ())
136  				{
137  					wallet_config.account = existing->first;
138  				}
139  				else
140  				{
141  					wallet_config.account = wallet->deterministic_insert (transaction);
142  				}
143  			}
</pre></code></div>
                <div class="column column_space"><pre><code>86      if (RedirUrl->IsOk(usHttp)){
87        TStr Host=HttpResp->GetFldVal(THttp::HostFldNm);
88        WebNetCltV->FetchUrl(RedirUrl, FetchId, Host);
89      } else {
90        TStr MsgStr=TStr("Invalid Redirection URL (")+RedirUrlStr+")";
91        WebNetCltV->OnHttpRespError(FetchId, MsgStr);
92      }
93    } else { 
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    