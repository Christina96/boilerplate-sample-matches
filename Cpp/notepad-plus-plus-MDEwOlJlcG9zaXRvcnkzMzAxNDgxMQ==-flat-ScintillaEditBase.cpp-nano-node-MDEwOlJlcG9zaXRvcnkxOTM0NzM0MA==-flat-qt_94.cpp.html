
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 14, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ScintillaEditBase.cpp</h3>
            <pre><code>1  #include "ScintillaEditBase.h"
2  #include "ScintillaQt.h"
3  #include "PlatQt.h"
4  #include <QApplication>
5  #if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)
6  #include <QInputContext>
7  #endif
8  #include <QPainter>
9  #include <QVarLengthArray>
10  #include <QScrollBar>
11  #include <QTextFormat>
12  constexpr int IndicatorInput = static_cast<int>(Scintilla::IndicatorNumbers::Ime);
13  constexpr int IndicatorTarget = IndicatorInput + 1;
14  constexpr int IndicatorConverted = IndicatorInput + 2;
15  constexpr int IndicatorUnknown = IndicatorInput + 3;
16  #if QT_VERSION >= QT_VERSION_CHECK(5, 0, 0)
17  #ifdef Q_OS_MAC
18  #define Q_WS_MAC 1
19  #endif
20  #if !defined(Q_OS_MAC) && !defined(Q_OS_WIN)
21  #define Q_WS_X11 1
22  #endif
23  #endif 
24  using namespace Scintilla;
25  using namespace Scintilla::Internal;
26  ScintillaEditBase::ScintillaEditBase(QWidget *parent)
27  : QAbstractScrollArea(parent), sqt(new ScintillaQt(this)), preeditPos(-1), wheelDelta(0)
28  {
29  	time.start();
30  	setAcceptDrops(true);
31  	setMouseTracking(true);
32  	setAutoFillBackground(false);
33  	setFrameStyle(QFrame::NoFrame);
34  	setFocusPolicy(Qt::StrongFocus);
35  	setAttribute(Qt::WA_StaticContents);
36  	viewport()->setAutoFillBackground(false);
37  	setAttribute(Qt::WA_KeyCompression);
38  	setAttribute(Qt::WA_InputMethodEnabled);
39  	const ColourRGBA colourIME(0, 0, UCHAR_MAX);
40  	sqt->vs.indicators[IndicatorUnknown] = Indicator(IndicatorStyle::Hidden, colourIME);
41  	sqt->vs.indicators[IndicatorInput] = Indicator(IndicatorStyle::Dots, colourIME);
42  	sqt->vs.indicators[IndicatorConverted] = Indicator(IndicatorStyle::CompositionThick, colourIME);
43  	sqt->vs.indicators[IndicatorTarget] = Indicator(IndicatorStyle::StraightBox, colourIME);
44  	connect(sqt, SIGNAL(notifyParent(Scintilla::NotificationData)),
45  		this, SLOT(notifyParent(Scintilla::NotificationData)));
46  	connect(verticalScrollBar(), SIGNAL(valueChanged(int)),
47  	        this, SLOT(scrollVertical(int)));
48  	connect(horizontalScrollBar(), SIGNAL(valueChanged(int)),
49  	        this, SLOT(scrollHorizontal(int)));
50  	connect(sqt, SIGNAL(horizontalRangeChanged(int,int)),
51  	        this, SIGNAL(horizontalRangeChanged(int,int)));
52  	connect(sqt, SIGNAL(verticalRangeChanged(int,int)),
53  	        this, SIGNAL(verticalRangeChanged(int,int)));
54  	connect(sqt, SIGNAL(horizontalScrolled(int)),
55  	        this, SIGNAL(horizontalScrolled(int)));
56  	connect(sqt, SIGNAL(verticalScrolled(int)),
57  	        this, SIGNAL(verticalScrolled(int)));
58  	connect(sqt, SIGNAL(notifyChange()),
59  	        this, SIGNAL(notifyChange()));
60  	connect(sqt, SIGNAL(command(Scintilla::uptr_t,Scintilla::sptr_t)),
61  		this, SLOT(event_command(Scintilla::uptr_t,Scintilla::sptr_t)));
62  	connect(sqt, SIGNAL(aboutToCopy(QMimeData*)),
63  		this, SIGNAL(aboutToCopy(QMimeData*)));
64  }
65  ScintillaEditBase::~ScintillaEditBase() = default;
66  sptr_t ScintillaEditBase::send(
67  	unsigned int iMessage,
68  	uptr_t wParam,
69  	sptr_t lParam) const
70  {
71  	return sqt->WndProc(static_cast<Message>(iMessage), wParam, lParam);
72  }
73  sptr_t ScintillaEditBase::sends(
74      unsigned int iMessage,
75      uptr_t wParam,
76      const char *s) const
77  {
78  	return sqt->WndProc(static_cast<Message>(iMessage), wParam, reinterpret_cast<sptr_t>(s));
79  }
80  void ScintillaEditBase::scrollHorizontal(int value)
81  {
82  	sqt->HorizontalScrollTo(value);
83  }
84  void ScintillaEditBase::scrollVertical(int value)
85  {
86  	sqt->ScrollTo(value);
87  }
88  bool ScintillaEditBase::event(QEvent *event)
89  {
90  	bool result = false;
91  	if (event->type() == QEvent::KeyPress) {
92  		keyPressEvent(static_cast<QKeyEvent *>(event));
93  		result = event->isAccepted();
94  	} else if (event->type() == QEvent::Show) {
95  		setMouseTracking(true);
96  		result = QAbstractScrollArea::event(event);
97  	} else if (event->type() == QEvent::Hide) {
98  		setMouseTracking(false);
99  		result = QAbstractScrollArea::event(event);
100  	} else {
101  		result = QAbstractScrollArea::event(event);
102  	}
103  	return result;
104  }
105  void ScintillaEditBase::paintEvent(QPaintEvent *event)
106  {
107  	sqt->PartialPaint(PRectFromQRect(event->rect()));
108  }
109  namespace {
110  bool isWheelEventHorizontal(QWheelEvent *event) {
111  #if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
112  	return event->angleDelta().y() == 0;
113  #else
114  	return event->orientation() == Qt::Horizontal;
115  #endif
116  }
117  int wheelEventYDelta(QWheelEvent *event) {
118  #if QT_VERSION >= QT_VERSION_CHECK(5, 15, 0)
119  	return event->angleDelta().y();
120  #else
121  	return event->delta();
122  #endif
123  }
124  }
125  void ScintillaEditBase::wheelEvent(QWheelEvent *event)
126  {
127  	if (isWheelEventHorizontal(event)) {
128  		QAbstractScrollArea::wheelEvent(event);
129  	} else {
130  		if (QApplication::keyboardModifiers() & Qt::ControlModifier) {
131  			if (wheelEventYDelta(event) > 0) {
132  				sqt->KeyCommand(Message::ZoomIn);
133  			} else {
134  				sqt->KeyCommand(Message::ZoomOut);
135  			}
136  		} else {
137  			QAbstractScrollArea::wheelEvent(event);
138  		}
139  	}
140  }
141  void ScintillaEditBase::focusInEvent(QFocusEvent *event)
142  {
143  	sqt->SetFocusState(true);
144  	QAbstractScrollArea::focusInEvent(event);
145  }
146  void ScintillaEditBase::focusOutEvent(QFocusEvent *event)
147  {
148  	sqt->SetFocusState(false);
149  	QAbstractScrollArea::focusOutEvent(event);
150  }
151  void ScintillaEditBase::resizeEvent(QResizeEvent *)
152  {
153  	sqt->ChangeSize();
154  	emit resized();
155  }
156  void ScintillaEditBase::keyPressEvent(QKeyEvent *event)
157  {
158  	if (QApplication::keyboardModifiers() & Qt::MetaModifier) {
159  		QAbstractScrollArea::keyPressEvent(event);
160  		emit keyPressed(event);
161  		return;
162  	}
163  	int key = 0;
164  	switch (event->key()) {
165  		case Qt::Key_Down:          key = SCK_DOWN;     break;
166  		case Qt::Key_Up:            key = SCK_UP;       break;
167  		case Qt::Key_Left:          key = SCK_LEFT;     break;
168  		case Qt::Key_Right:         key = SCK_RIGHT;    break;
169  		case Qt::Key_Home:          key = SCK_HOME;     break;
170  		case Qt::Key_End:           key = SCK_END;      break;
171  		case Qt::Key_PageUp:        key = SCK_PRIOR;    break;
172  		case Qt::Key_PageDown:      key = SCK_NEXT;     break;
173  		case Qt::Key_Delete:        key = SCK_DELETE;   break;
174  		case Qt::Key_Insert:        key = SCK_INSERT;   break;
175  		case Qt::Key_Escape:        key = SCK_ESCAPE;   break;
176  		case Qt::Key_Backspace:     key = SCK_BACK;     break;
177  		case Qt::Key_Plus:          key = SCK_ADD;      break;
178  		case Qt::Key_Minus:         key = SCK_SUBTRACT; break;
179  		case Qt::Key_Backtab:       
180  		case Qt::Key_Tab:           key = SCK_TAB;      break;
181  		case Qt::Key_Enter:         
182  		case Qt::Key_Return:        key = SCK_RETURN;   break;
183  		case Qt::Key_Control:       key = 0;            break;
184  		case Qt::Key_Alt:           key = 0;            break;
185  		case Qt::Key_Shift:         key = 0;            break;
186  		case Qt::Key_Meta:          key = 0;            break;
187  		default:                    key = event->key(); break;
188  	}
189  	bool shift = QApplication::keyboardModifiers() & Qt::ShiftModifier;
190  	bool ctrl  = QApplication::keyboardModifiers() & Qt::ControlModifier;
191  	bool alt   = QApplication::keyboardModifiers() & Qt::AltModifier;
192  	bool consumed = false;
193  	bool added = sqt->KeyDownWithModifiers(static_cast<Keys>(key),
194  					       ModifierFlags(shift, ctrl, alt),
195  					       &consumed) != 0;
196  	if (!consumed)
197  		consumed = added;
198  	if (!consumed) {
199  		bool input = (!ctrl || alt);
200  #ifndef Q_WS_MAC
201  		input &= (!alt || ctrl);
202  #endif
203  		QString text = event->text();
204  		if (input && !text.isEmpty() && text[0].isPrint()) {
205  			const int strLen = text.length();
206  			for (int i = 0; i < strLen;) {
207  				const int ucWidth = text.at(i).isHighSurrogate() ? 2 : 1;
208  				const QString oneCharUTF16 = text.mid(i, ucWidth);
209  				const QByteArray oneChar = sqt->BytesForDocument(oneCharUTF16);
210  				sqt->InsertCharacter(std::string_view(oneChar.data(), oneChar.length()), CharacterSource::DirectInput);
211  				i += ucWidth;
212  			}
213  		} else {
214  			event->ignore();
215  		}
216  	}
217  	emit keyPressed(event);
218  }
219  static int modifierTranslated(int sciModifier)
220  {
221  	switch (sciModifier) {
222  		case SCMOD_SHIFT:
223  			return Qt::ShiftModifier;
224  		case SCMOD_CTRL:
225  			return Qt::ControlModifier;
226  		case SCMOD_ALT:
227  			return Qt::AltModifier;
228  		case SCMOD_SUPER:
229  			return Qt::MetaModifier;
230  		default:
231  			return 0;
232  	}
233  }
234  void ScintillaEditBase::mousePressEvent(QMouseEvent *event)
235  {
236  	Point pos = PointFromQPoint(event->pos());
237  	emit buttonPressed(event);
238  	if (event->button() == Qt::MiddleButton &&
239  	    QApplication::clipboard()->supportsSelection()) {
240  		SelectionPosition selPos = sqt->SPositionFromLocation(
241  					pos, false, false, sqt->UserVirtualSpace());
242  		sqt->sel.Clear();
243  		sqt->SetSelection(selPos, selPos);
244  		sqt->PasteFromMode(QClipboard::Selection);
245  		return;
246  	}
247  	if (event->button() == Qt::LeftButton) {
248  		bool shift = QApplication::keyboardModifiers() & Qt::ShiftModifier;
249  		bool ctrl  = QApplication::keyboardModifiers() & Qt::ControlModifier;
250  		bool alt   = QApplication::keyboardModifiers() & modifierTranslated(sqt->rectangularSelectionModifier);
251  		sqt->ButtonDownWithModifiers(pos, time.elapsed(), ModifierFlags(shift, ctrl, alt));
252  	}
253  	if (event->button() == Qt::RightButton) {
254  		sqt->RightButtonDownWithModifiers(pos, time.elapsed(), ModifiersOfKeyboard());
255  	}
256  }
257  void ScintillaEditBase::mouseReleaseEvent(QMouseEvent *event)
258  {
259  	const QPoint point = event->pos();
260  	if (event->button() == Qt::LeftButton)
261  		sqt->ButtonUpWithModifiers(PointFromQPoint(point), time.elapsed(), ModifiersOfKeyboard());
262  	const sptr_t pos = send(SCI_POSITIONFROMPOINT, point.x(), point.y());
263  	const sptr_t line = send(SCI_LINEFROMPOSITION, pos);
264  	int modifiers = QApplication::keyboardModifiers();
265  	emit textAreaClicked(line, modifiers);
266  	emit buttonReleased(event);
267  }
268  void ScintillaEditBase::mouseDoubleClickEvent(QMouseEvent *event)
269  {
270  	mousePressEvent(event);
271  }
272  void ScintillaEditBase::mouseMoveEvent(QMouseEvent *event)
273  {
274  	Point pos = PointFromQPoint(event->pos());
275  	bool shift = QApplication::keyboardModifiers() & Qt::ShiftModifier;
276  	bool ctrl  = QApplication::keyboardModifiers() & Qt::ControlModifier;
277  	bool alt   = QApplication::keyboardModifiers() & modifierTranslated(sqt->rectangularSelectionModifier);
278  	const KeyMod modifiers = ModifierFlags(shift, ctrl, alt);
279  	sqt->ButtonMoveWithModifiers(pos, time.elapsed(), modifiers);
280  }
281  void ScintillaEditBase::contextMenuEvent(QContextMenuEvent *event)
282  {
283  	Point pos = PointFromQPoint(event->globalPos());
284  	Point pt = PointFromQPoint(event->pos());
285  	if (!sqt->PointInSelection(pt)) {
286  		sqt->SetEmptySelection(sqt->PositionFromLocation(pt));
287  	}
288  	if (sqt->ShouldDisplayPopup(pt)) {
289  		sqt->ContextMenu(pos);
290  	}
291  }
292  void ScintillaEditBase::dragEnterEvent(QDragEnterEvent *event)
293  {
294  	if (event->mimeData()->hasUrls()) {
295  		event->acceptProposedAction();
296  	} else if (event->mimeData()->hasText()) {
297  		event->acceptProposedAction();
298  		Point point = PointFromQPoint(event->pos());
299  		sqt->DragEnter(point);
300  	} else {
301  		event->ignore();
302  	}
303  }
304  void ScintillaEditBase::dragLeaveEvent(QDragLeaveEvent * &bsol;* event */)
305  {
306  	sqt->DragLeave();
307  }
308  void ScintillaEditBase::dragMoveEvent(QDragMoveEvent *event)
309  {
310  	if (event->mimeData()->hasUrls()) {
311  		event->acceptProposedAction();
312  	} else if (event->mimeData()->hasText()) {
313  		event->acceptProposedAction();
314  		Point point = PointFromQPoint(event->pos());
315  		sqt->DragMove(point);
316  	} else {
317  		event->ignore();
318  	}
319  }
320  void ScintillaEditBase::dropEvent(QDropEvent *event)
321  {
322  	if (event->mimeData()->hasUrls()) {
323  		event->acceptProposedAction();
324  		sqt->DropUrls(event->mimeData());
325  	} else if (event->mimeData()->hasText()) {
326  		event->acceptProposedAction();
327  		Point point = PointFromQPoint(event->pos());
328  		bool move = (event->source() == this &&
329                   event->proposedAction() == Qt::MoveAction);
330  		sqt->Drop(point, event->mimeData(), move);
331  	} else {
332  		event->ignore();
333  	}
334  }
335  bool ScintillaEditBase::IsHangul(const QChar qchar)
336  {
337  	unsigned int unicode = qchar.unicode();
338  	const bool HangulJamo = (0x1100 <= unicode && unicode <= 0x11FF);
339  	const bool HangulCompatibleJamo = (0x3130 <= unicode && unicode <= 0x318F);
340  	const bool HangulJamoExtendedA = (0xA960 <= unicode && unicode <= 0xA97F);
341  	const bool HangulJamoExtendedB = (0xD7B0 <= unicode && unicode <= 0xD7FF);
342  	const bool HangulSyllable = (0xAC00 <= unicode && unicode <= 0xD7A3);
343  	return HangulJamo || HangulCompatibleJamo  || HangulSyllable ||
344  				HangulJamoExtendedA || HangulJamoExtendedB;
345  }
346  void ScintillaEditBase::MoveImeCarets(Scintilla::Position offset)
347  {
348  	for (size_t r=0; r < sqt->sel.Count(); r++) {
349  		const Sci::Position positionInsert = sqt->sel.Range(r).Start().Position();
350  		sqt->sel.Range(r).caret.SetPosition(positionInsert + offset);
351  		sqt->sel.Range(r).anchor.SetPosition(positionInsert + offset);
352   	}
353  }
354  void ScintillaEditBase::DrawImeIndicator(int indicator, int len)
355  {
356  	if (indicator < INDICATOR_CONTAINER || indicator > INDICATOR_MAX) {
357  		return;
358  	}
359  	sqt->pdoc->DecorationSetCurrentIndicator(indicator);
360  	for (size_t r=0; r< sqt-> sel.Count(); r++) {
361  		const Sci::Position positionInsert = sqt->sel.Range(r).Start().Position();
362  		sqt->pdoc->DecorationFillRange(positionInsert - len, 1, len);
363  	}
364  }
365  static int GetImeCaretPos(QInputMethodEvent *event)
366  {
367  	foreach (QInputMethodEvent::Attribute attr, event->attributes()) {
368  		if (attr.type == QInputMethodEvent::Cursor)
369  			return attr.start;
370  	}
371  	return 0;
372  }
373  static std::vector<int> MapImeIndicators(QInputMethodEvent *event)
374  {
375  	std::vector<int> imeIndicator(event->preeditString().size(), IndicatorUnknown);
376  	foreach (QInputMethodEvent::Attribute attr, event->attributes()) {
377  		if (attr.type == QInputMethodEvent::TextFormat) {
378  			QTextFormat format = attr.value.value<QTextFormat>();
379  			QTextCharFormat charFormat = format.toCharFormat();
380  			int indicator = IndicatorUnknown;
381  			switch (charFormat.underlineStyle()) {
382  				case QTextCharFormat::NoUnderline: 
383  				case QTextCharFormat::SingleUnderline: 
384  				case QTextCharFormat::DashUnderline: 
385  					indicator = IndicatorInput;
386  					break;
387  				case QTextCharFormat::DotLine:
388  				case QTextCharFormat::DashDotLine:
389  				case QTextCharFormat::WaveUnderline:
390  				case QTextCharFormat::SpellCheckUnderline:
391  					indicator = IndicatorConverted;
392  					break;
393  				default:
394  					indicator = IndicatorUnknown;
395  			}
396  			if (format.hasProperty(QTextFormat::BackgroundBrush)) 
397  				indicator = IndicatorTarget;
398  #ifdef Q_OS_OSX
399  			if (charFormat.underlineStyle() == QTextCharFormat::SingleUnderline) {
400  				QColor uc = charFormat.underlineColor();
401  				if (uc.lightness() < 2) { 
402  					indicator = IndicatorTarget;
403  				}
404  			}
405  #endif
406  			for (int i = attr.start; i < attr.start+attr.length; i++) {
407  				imeIndicator[i] = indicator;
408  			}
409  		}
410  	}
411  	return imeIndicator;
412  }
413  void ScintillaEditBase::inputMethodEvent(QInputMethodEvent *event)
414  {
415  	if (sqt->pdoc->IsReadOnly() || sqt->SelectionContainsProtected()) {
416  		return;
417  	}
418  	bool initialCompose = false;
419  	if (sqt->pdoc->TentativeActive()) {
420  		sqt->pdoc->TentativeUndo();
421  	} else {
422  		initialCompose = true;
423  	}
424  	sqt->view.imeCaretBlockOverride = false;
425  	preeditPos = -1; 
426  	if (!event->commitString().isEmpty()) {
427  		const QString &commitStr = event->commitString();
428  		const int commitStrLen = commitStr.length();
429  		for (int i = 0; i < commitStrLen;) {
430  			const int ucWidth = commitStr.at(i).isHighSurrogate() ? 2 : 1;
431  			const QString oneCharUTF16 = commitStr.mid(i, ucWidth);
432  			const QByteArray oneChar = sqt->BytesForDocument(oneCharUTF16);
433  			sqt->InsertCharacter(std::string_view(oneChar.data(), oneChar.length()), CharacterSource::DirectInput);
434  			i += ucWidth;
435  		}
436  	} else if (!event->preeditString().isEmpty()) {
437  		const QString preeditStr = event->preeditString();
438  		const int preeditStrLen = preeditStr.length();
439  		if (preeditStrLen == 0) {
440  			sqt->ShowCaretAtCurrentPosition();
441  			return;
442  		}
443  		if (initialCompose)
<span onclick='openModal()' class='match'>444  			sqt->ClearBeforeTentativeStart();
445  		sqt->pdoc->TentativeStart(); 
446  		preeditPos = sqt->CurrentPosition();
</span>447  		std::vector<int> imeIndicator = MapImeIndicators(event);
448  		for (int i = 0; i < preeditStrLen;) {
449  			const int ucWidth = preeditStr.at(i).isHighSurrogate() ? 2 : 1;
450  			const QString oneCharUTF16 = preeditStr.mid(i, ucWidth);
451  			const QByteArray oneChar = sqt->BytesForDocument(oneCharUTF16);
452  			const int oneCharLen = oneChar.length();
453  			sqt->InsertCharacter(std::string_view(oneChar.data(), oneCharLen), CharacterSource::TentativeInput);
454  			DrawImeIndicator(imeIndicator[i], oneCharLen);
455  			i += ucWidth;
456  		}
457  		int imeCaretPos = GetImeCaretPos(event);
458  		int imeEndToImeCaretU16 = imeCaretPos - preeditStrLen;
459  		const Sci::Position imeCaretPosDoc = sqt->pdoc->GetRelativePositionUTF16(sqt->CurrentPosition(), imeEndToImeCaretU16);
460  		MoveImeCarets(- sqt->CurrentPosition() + imeCaretPosDoc);
461  		if (IsHangul(preeditStr.at(0))) {
462  #ifndef Q_OS_WIN
463  			if (imeCaretPos > 0) {
464  				int oneCharBefore = sqt->pdoc->GetRelativePosition(sqt->CurrentPosition(), -1);
465  				MoveImeCarets(- sqt->CurrentPosition() + oneCharBefore);
466  			}
467  #endif
468  			sqt->view.imeCaretBlockOverride = true;
469  		}
470  		const bool targetAny = std::any_of(imeIndicator.begin(), imeIndicator.end(), [](int i) noexcept {
471  			return i == IndicatorTarget;
472  		});
473  		if (targetAny)
474  			preeditPos = sqt->CurrentPosition();
475  		sqt->EnsureCaretVisible();
476  	}
477  	sqt->ShowCaretAtCurrentPosition();
478  }
479  QVariant ScintillaEditBase::inputMethodQuery(Qt::InputMethodQuery query) const
480  {
481  	const Scintilla::Position pos = send(SCI_GETCURRENTPOS);
482  	const Scintilla::Position line = send(SCI_LINEFROMPOSITION, pos);
483  	switch (query) {
484  #if QT_VERSION >= QT_VERSION_CHECK(5, 14, 0)
485  		case Qt::ImCursorRectangle:
486  		{
487  			const Scintilla::Position startPos = (preeditPos >= 0) ? preeditPos : pos;
488  			const Point pt = sqt->LocationFromPosition(startPos);
489  			const int width = static_cast<int>(send(SCI_GETCARETWIDTH));
490  			const int height = static_cast<int>(send(SCI_TEXTHEIGHT, line));
491  			return QRectF(pt.x, pt.y, width, height).toRect();
492  		}
493  #else
494  		case Qt::ImMicroFocus:
495  		{
496  			const Scintilla::Position startPos = (preeditPos >= 0) ? preeditPos : pos;
497  			const Point pt = sqt->LocationFromPosition(startPos);
498  			const int width = static_cast<int>(send(SCI_GETCARETWIDTH));
499  			const int height = static_cast<int>(send(SCI_TEXTHEIGHT, line));
500  			return QRect(pt.x, pt.y, width, height);
501  		}
502  #endif
503  		case Qt::ImFont:
504  		{
505  			char fontName[64];
506  			const sptr_t style = send(SCI_GETSTYLEAT, pos);
507  			const int len = static_cast<int>(sends(SCI_STYLEGETFONT, style, fontName));
508  			const int size = static_cast<int>(send(SCI_STYLEGETSIZE, style));
509  			const bool italic = send(SCI_STYLEGETITALIC, style);
510  			const int weight = send(SCI_STYLEGETBOLD, style) ? QFont::Bold : -1;
511  			return QFont(QString::fromUtf8(fontName, len), size, weight, italic);
512  		}
513  		case Qt::ImCursorPosition:
514  		{
515  			const Scintilla::Position paraStart = sqt->pdoc->ParaUp(pos);
516  			return static_cast<int>(sqt->pdoc->CountUTF16(paraStart, pos));
517  		}
518  		case Qt::ImSurroundingText:
519  		{
520  			const Scintilla::Position paraStart = sqt->pdoc->ParaUp(pos);
521  			const Scintilla::Position paraEnd = sqt->pdoc->ParaDown(pos);
522  			const std::string buffer = sqt->RangeText(paraStart, paraEnd);
523  			return sqt->StringFromDocument(buffer.c_str());
524  		}
525  		case Qt::ImCurrentSelection:
526  		{
527  			QVarLengthArray<char,1024> buffer(send(SCI_GETSELTEXT));
528  			sends(SCI_GETSELTEXT, 0, buffer.data());
529  			return sqt->StringFromDocument(buffer.constData());
530  		}
531  		default:
532  			return QVariant();
533  	}
534  }
535  void ScintillaEditBase::notifyParent(NotificationData scn)
536  {
537  	emit notify(&scn);
538  	switch (scn.nmhdr.code) {
539  		case Notification::StyleNeeded:
540  			emit styleNeeded(scn.position);
541  			break;
542  		case Notification::CharAdded:
543  			emit charAdded(scn.ch);
544  			break;
545  		case Notification::SavePointReached:
546  			emit savePointChanged(false);
547  			break;
548  		case Notification::SavePointLeft:
549  			emit savePointChanged(true);
550  			break;
551  		case Notification::ModifyAttemptRO:
552  			emit modifyAttemptReadOnly();
553  			break;
554  		case Notification::Key:
555  			emit key(scn.ch);
556  			break;
557  		case Notification::DoubleClick:
558  			emit doubleClick(scn.position, scn.line);
559  			break;
560  		case Notification::UpdateUI:
561  			emit updateUi(scn.updated);
562  			break;
563  		case Notification::Modified:
564  		{
565  			const bool added = FlagSet(scn.modificationType, ModificationFlags::InsertText);
566  			const bool deleted = FlagSet(scn.modificationType, ModificationFlags::DeleteText);
567  			const Scintilla::Position length = send(SCI_GETTEXTLENGTH);
568  			bool firstLineAdded = (added && length == 1) ||
569  			                      (deleted && length == 0);
570  			if (scn.linesAdded != 0) {
571  				emit linesAdded(scn.linesAdded);
572  			} else if (firstLineAdded) {
573  				emit linesAdded(added ? 1 : -1);
574  			}
575  			const QByteArray bytes = QByteArray::fromRawData(scn.text, scn.text ? scn.length : 0);
576  			emit modified(scn.modificationType, scn.position, scn.length,
577  			              scn.linesAdded, bytes, scn.line,
578  			              scn.foldLevelNow, scn.foldLevelPrev);
579  			break;
580  		}
581  		case Notification::MacroRecord:
582  			emit macroRecord(scn.message, scn.wParam, scn.lParam);
583  			break;
584  		case Notification::MarginClick:
585  			emit marginClicked(scn.position, scn.modifiers, scn.margin);
586  			break;
587  		case Notification::NeedShown:
588  			emit needShown(scn.position, scn.length);
589  			break;
590  		case Notification::Painted:
591  			emit painted();
592  			break;
593  		case Notification::UserListSelection:
594  			emit userListSelection();
595  			break;
596  		case Notification::URIDropped:
597  			emit uriDropped(QString::fromUtf8(scn.text));
598  			break;
599  		case Notification::DwellStart:
600  			emit dwellStart(scn.x, scn.y);
601  			break;
602  		case Notification::DwellEnd:
603  			emit dwellEnd(scn.x, scn.y);
604  			break;
605  		case Notification::Zoom:
606  			emit zoom(send(SCI_GETZOOM));
607  			break;
608  		case Notification::HotSpotClick:
609  			emit hotSpotClick(scn.position, scn.modifiers);
610  			break;
611  		case Notification::HotSpotDoubleClick:
612  			emit hotSpotDoubleClick(scn.position, scn.modifiers);
613  			break;
614  		case Notification::CallTipClick:
615  			emit callTipClick();
616  			break;
617  		case Notification::AutoCSelection:
618  			emit autoCompleteSelection(scn.lParam, QString::fromUtf8(scn.text));
619  			break;
620  		case Notification::AutoCCancelled:
621  			emit autoCompleteCancelled();
622  			break;
623  		case Notification::FocusIn:
624  			emit focusChanged(true);
625  			break;
626  		case Notification::FocusOut:
627  			emit focusChanged(false);
628  			break;
629  		default:
630  			return;
631  	}
632  }
633  void ScintillaEditBase::event_command(uptr_t wParam, sptr_t lParam)
634  {
635  	emit command(wParam, lParam);
636  }
637  KeyMod ScintillaEditBase::ModifiersOfKeyboard()
638  {
639  	const bool shift = QApplication::keyboardModifiers() & Qt::ShiftModifier;
640  	const bool ctrl  = QApplication::keyboardModifiers() & Qt::ControlModifier;
641  	const bool alt   = QApplication::keyboardModifiers() & Qt::AltModifier;
642  	return ModifierFlags(shift, ctrl, alt);
643  }
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-qt_94.cpp</h3>
            <pre><code>1  #include <nano/qt/qt.hpp>
2  #include <nano/test_common/network.hpp>
3  #include <nano/test_common/system.hpp>
4  #include <nano/test_common/testutil.hpp>
5  #include <gtest/gtest.h>
6  #include <boost/property_tree/json_parser.hpp>
7  #include <algorithm>
8  #include <nano/qt_test/QTest>
9  #include <thread>
10  using namespace std::chrono_literals;
11  extern QApplication * test_application;
12  TEST (wallet, construction)
13  {
14  	nano_qt::eventloop_processor processor;
15  	nano::test::system system (1);
16  	auto wallet_l (system.nodes[0]->wallets.create (nano::random_wallet_id ()));
17  	auto key (wallet_l->deterministic_insert ());
18  	auto wallet (std::make_shared<nano_qt::wallet> (*test_application, processor, *system.nodes[0], wallet_l, key));
19  	wallet->start ();
20  	std::string account (key.to_account ());
21  	ASSERT_EQ (account, wallet->self.account_text->text ().toStdString ());
22  	ASSERT_EQ (1, wallet->accounts.model->rowCount ());
23  	auto item1 (wallet->accounts.model->item (0, 1));
24  	ASSERT_EQ (key.to_account (), item1->text ().toStdString ());
25  }
26  TEST (wallet, DISABLED_status)
27  {
28  	nano_qt::eventloop_processor processor;
29  	nano::test::system system (1);
30  	auto wallet_l (system.nodes[0]->wallets.create (nano::random_wallet_id ()));
31  	nano::keypair key;
32  	wallet_l->insert_adhoc (key.prv);
33  	auto wallet (std::make_shared<nano_qt::wallet> (*test_application, processor, *system.nodes[0], wallet_l, key.pub));
34  	wallet->start ();
35  	auto wallet_has = [wallet] (nano_qt::status_types status_ty) {
36  		return wallet->active_status.active.find (status_ty) != wallet->active_status.active.end ();
37  	};
38  	ASSERT_EQ ("Status: Disconnected, Blocks: 1", wallet->status->text ().toStdString ());
39  	auto outer_node = nano::test::add_outer_node (system);
40  	nano::test::establish_tcp (system, *system.nodes[0], outer_node->network.endpoint ());
41  	ASSERT_FALSE (wallet_has (nano_qt::status_types::synchronizing));
42  	system.deadline_set (25s);
43  	while (!wallet_has (nano_qt::status_types::synchronizing))
44  	{
45  		test_application->processEvents ();
46  		ASSERT_NO_ERROR (system.poll ());
47  	}
48  	system.nodes[0]->network.cleanup (std::chrono::steady_clock::now () + std::chrono::seconds (5));
49  	while (wallet_has (nano_qt::status_types::synchronizing))
50  	{
51  		test_application->processEvents ();
52  	}
53  	ASSERT_TRUE (wallet_has (nano_qt::status_types::disconnected));
54  }
55  TEST (wallet, status_with_peer)
56  {
57  	nano_qt::eventloop_processor processor;
58  	nano::test::system system (2);
59  	auto wallet_l = system.nodes[0]->wallets.create (nano::random_wallet_id ());
60  	nano::keypair key;
61  	wallet_l->insert_adhoc (key.prv);
62  	auto wallet = std::make_shared<nano_qt::wallet> (*test_application, processor, *system.nodes[0], wallet_l, key.pub);
63  	wallet->start ();
64  	auto wallet_has = [wallet] (nano_qt::status_types status_ty) {
65  		return wallet->active_status.active.find (status_ty) != wallet->active_status.active.end ();
66  	};
67  	ASSERT_FALSE (wallet_has (nano_qt::status_types::synchronizing));
68  	system.deadline_set (25s);
69  	while (!wallet_has (nano_qt::status_types::synchronizing))
70  	{
71  		test_application->processEvents ();
72  		ASSERT_NO_ERROR (system.poll ());
73  	}
74  	system.nodes[0]->network.cleanup (std::chrono::steady_clock::now () + std::chrono::seconds (5));
75  	while (wallet_has (nano_qt::status_types::synchronizing))
76  	{
77  		test_application->processEvents ();
78  		ASSERT_NO_ERROR (system.poll ());
79  	}
80  	ASSERT_TRUE (wallet_has (nano_qt::status_types::nominal));
81  }
82  TEST (wallet, startup_balance)
83  {
84  	nano_qt::eventloop_processor processor;
85  	nano::test::system system (1);
86  	auto wallet_l (system.nodes[0]->wallets.create (nano::random_wallet_id ()));
87  	nano::keypair key;
88  	wallet_l->insert_adhoc (key.prv);
89  	auto wallet (std::make_shared<nano_qt::wallet> (*test_application, processor, *system.nodes[0], wallet_l, key.pub));
90  	wallet->needs_balance_refresh = true;
91  	wallet->start ();
92  	wallet->application.processEvents (QEventLoop::AllEvents);
93  	ASSERT_EQ ("Balance: 0 nano", wallet->self.balance_label->text ().toStdString ());
94  }
95  TEST (wallet, select_account)
96  {
97  	nano_qt::eventloop_processor processor;
98  	nano::test::system system (1);
99  	auto wallet_l (system.nodes[0]->wallets.create (nano::random_wallet_id ()));
100  	nano::public_key key1 (wallet_l->deterministic_insert ());
101  	nano::public_key key2 (wallet_l->deterministic_insert ());
102  	auto wallet (std::make_shared<nano_qt::wallet> (*test_application, processor, *system.nodes[0], wallet_l, key1));
103  	wallet->start ();
104  	ASSERT_EQ (key1, wallet->account);
105  	QTest::mouseClick (wallet->show_advanced, Qt::LeftButton);
106  	QTest::mouseClick (wallet->accounts_button, Qt::LeftButton);
107  	wallet->accounts.view->selectionModel ()->setCurrentIndex (wallet->accounts.model->index (0, 0), QItemSelectionModel::SelectionFlag::Select);
108  	QTest::mouseClick (wallet->accounts.use_account, Qt::LeftButton);
109  	auto key3 (wallet->account);
110  	wallet->accounts.view->selectionModel ()->setCurrentIndex (wallet->accounts.model->index (1, 0), QItemSelectionModel::SelectionFlag::Select);
111  	QTest::mouseClick (wallet->accounts.use_account, Qt::LeftButton);
112  	auto key4 (wallet->account);
113  	ASSERT_NE (key3, key4);
114  	if (key1 < key2)
115  	{
116  		ASSERT_EQ (key2, key4);
117  	}
118  	else
119  	{
120  		ASSERT_EQ (key1, key4);
121  	}
122  }
123  TEST (wallet, main)
124  {
125  	nano_qt::eventloop_processor processor;
126  	nano::test::system system (1);
127  	auto wallet_l (system.nodes[0]->wallets.create (nano::random_wallet_id ()));
128  	nano::keypair key;
129  	wallet_l->insert_adhoc (key.prv);
130  	auto wallet (std::make_shared<nano_qt::wallet> (*test_application, processor, *system.nodes[0], wallet_l, key.pub));
131  	wallet->start ();
132  	ASSERT_EQ (wallet->entry_window, wallet->main_stack->currentWidget ());
133  	QTest::mouseClick (wallet->send_blocks, Qt::LeftButton);
134  	ASSERT_EQ (wallet->send_blocks_window, wallet->main_stack->currentWidget ());
135  	QTest::mouseClick (wallet->send_blocks_back, Qt::LeftButton);
136  	QTest::mouseClick (wallet->settings_button, Qt::LeftButton);
137  	ASSERT_EQ (wallet->settings.window, wallet->main_stack->currentWidget ());
138  	QTest::mouseClick (wallet->settings.back, Qt::LeftButton);
139  	ASSERT_EQ (wallet->entry_window, wallet->main_stack->currentWidget ());
140  	QTest::mouseClick (wallet->show_advanced, Qt::LeftButton);
141  	ASSERT_EQ (wallet->advanced.window, wallet->main_stack->currentWidget ());
142  	QTest::mouseClick (wallet->advanced.show_ledger, Qt::LeftButton);
143  	ASSERT_EQ (wallet->advanced.ledger_window, wallet->main_stack->currentWidget ());
144  	QTest::mouseClick (wallet->advanced.ledger_back, Qt::LeftButton);
145  	ASSERT_EQ (wallet->advanced.window, wallet->main_stack->currentWidget ());
146  	QTest::mouseClick (wallet->advanced.show_peers, Qt::LeftButton);
147  	ASSERT_EQ (wallet->advanced.peers_window, wallet->main_stack->currentWidget ());
148  	QTest::mouseClick (wallet->advanced.peers_back, Qt::LeftButton);
149  	ASSERT_EQ (wallet->advanced.window, wallet->main_stack->currentWidget ());
150  	QTest::mouseClick (wallet->advanced.back, Qt::LeftButton);
151  	ASSERT_EQ (wallet->entry_window, wallet->main_stack->currentWidget ());
152  }
153  TEST (wallet, password_change)
154  {
155  	nano_qt::eventloop_processor processor;
156  	nano::test::system system (1);
157  	nano::account account;
158  	system.wallet (0)->insert_adhoc (nano::keypair ().prv);
159  	{
160  		auto transaction (system.nodes[0]->wallets.tx_begin_read ());
161  		account = system.account (transaction, 0);
162  	}
163  	auto wallet (std::make_shared<nano_qt::wallet> (*test_application, processor, *system.nodes[0], system.wallet (0), account));
164  	wallet->start ();
165  	QTest::mouseClick (wallet->settings_button, Qt::LeftButton);
166  	{
167  		auto transaction (system.nodes[0]->wallets.tx_begin_read ());
168  		nano::raw_key password1;
169  		nano::raw_key password2;
170  		system.wallet (0)->store.derive_key (password1, transaction, "1");
171  		system.wallet (0)->store.password.value (password2);
172  		ASSERT_NE (password1, password2);
173  	}
174  	QTest::keyClicks (wallet->settings.new_password, "1");
175  	QTest::keyClicks (wallet->settings.retype_password, "1");
176  	QTest::mouseClick (wallet->settings.change, Qt::LeftButton);
177  	{
178  		auto transaction (system.nodes[0]->wallets.tx_begin_read ());
179  		nano::raw_key password1;
180  		nano::raw_key password2;
181  		system.wallet (0)->store.derive_key (password1, transaction, "1");
182  		system.wallet (0)->store.password.value (password2);
183  		ASSERT_EQ (password1, password2);
184  	}
185  	ASSERT_EQ ("", wallet->settings.new_password->text ());
186  	ASSERT_EQ ("", wallet->settings.retype_password->text ());
187  }
188  TEST (client, password_nochange)
189  {
190  	nano_qt::eventloop_processor processor;
191  	nano::test::system system (1);
192  	nano::account account;
193  	system.wallet (0)->insert_adhoc (nano::keypair ().prv);
194  	{
195  		auto transaction (system.nodes[0]->wallets.tx_begin_read ());
196  		account = system.account (transaction, 0);
197  	}
198  	auto wallet (std::make_shared<nano_qt::wallet> (*test_application, processor, *system.nodes[0], system.wallet (0), account));
199  	wallet->start ();
200  	QTest::mouseClick (wallet->settings_button, Qt::LeftButton);
201  	nano::raw_key password;
202  	password.clear ();
203  	system.deadline_set (10s);
204  	while (password == 0)
205  	{
206  		ASSERT_NO_ERROR (system.poll ());
207  		system.wallet (0)->store.password.value (password);
208  	}
209  	{
210  		auto transaction (system.nodes[0]->wallets.tx_begin_read ());
211  		nano::raw_key password1;
212  		system.wallet (0)->store.derive_key (password1, transaction, "");
213  		nano::raw_key password2;
214  		system.wallet (0)->store.password.value (password2);
215  		ASSERT_EQ (password1, password2);
216  	}
217  	QTest::keyClicks (wallet->settings.new_password, "1");
218  	QTest::keyClicks (wallet->settings.retype_password, "2");
219  	QTest::mouseClick (wallet->settings.change, Qt::LeftButton);
220  	{
221  		auto transaction (system.nodes[0]->wallets.tx_begin_read ());
222  		nano::raw_key password1;
223  		system.wallet (0)->store.derive_key (password1, transaction, "");
224  		nano::raw_key password2;
225  		system.wallet (0)->store.password.value (password2);
226  		ASSERT_EQ (password1, password2);
227  	}
228  	ASSERT_EQ ("1", wallet->settings.new_password->text ());
229  	ASSERT_EQ ("", wallet->settings.retype_password->text ());
230  }
231  TEST (wallet, enter_password)
232  {
233  	nano_qt::eventloop_processor processor;
234  	nano::test::system system (2);
235  	nano::account account;
236  	system.wallet (0)->insert_adhoc (nano::keypair ().prv);
237  	{
238  		auto transaction (system.nodes[0]->wallets.tx_begin_read ());
239  		account = system.account (transaction, 0);
240  	}
241  	auto wallet (std::make_shared<nano_qt::wallet> (*test_application, processor, *system.nodes[0], system.wallet (0), account));
242  	wallet->start ();
243  	ASSERT_NE (-1, wallet->settings.layout->indexOf (wallet->settings.password));
244  	ASSERT_NE (-1, wallet->settings.layout->indexOf (wallet->settings.lock_toggle));
245  	ASSERT_NE (-1, wallet->settings.layout->indexOf (wallet->settings.back));
246  	QTest::mouseClick (wallet->settings.lock_toggle, Qt::LeftButton);
247  	QTest::mouseClick (wallet->settings.lock_toggle, Qt::LeftButton);
248  	test_application->processEvents ();
249  	ASSERT_NE (wallet->status->text ().toStdString ().rfind ("Status: Wallet password empty", 0), std::string::npos);
250  	{
251  		auto transaction (system.nodes[0]->wallets.tx_begin_write ());
252  		ASSERT_FALSE (system.wallet (0)->store.rekey (transaction, "abc"));
253  	}
254  	QTest::mouseClick (wallet->settings_button, Qt::LeftButton);
255  	QTest::mouseClick (wallet->settings.lock_toggle, Qt::LeftButton);
256  	test_application->processEvents ();
257  	ASSERT_NE (wallet->status->text ().toStdString ().rfind ("Status: Wallet locked", 0), std::string::npos);
258  	wallet->settings.new_password->setText ("");
259  	QTest::keyClicks (wallet->settings.password, "abc");
260  	QTest::mouseClick (wallet->settings.lock_toggle, Qt::LeftButton);
261  	test_application->processEvents ();
262  	ASSERT_NE (wallet->status->text ().toStdString ().rfind ("Status: Running", 0), std::string::npos);
263  	ASSERT_EQ ("", wallet->settings.password->text ());
264  }
265  TEST (wallet, send)
266  {
267  	nano_qt::eventloop_processor processor;
268  	nano::test::system system (2);
269  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
270  	nano::public_key key1 (system.wallet (1)->insert_adhoc (nano::keypair ().prv));
271  	auto account (nano::dev::genesis_key.pub);
272  	auto wallet (std::make_shared<nano_qt::wallet> (*test_application, processor, *system.nodes[0], system.wallet (0), account));
273  	wallet->start ();
274  	ASSERT_NE (wallet->rendering_ratio, nano::raw_ratio);
275  	QTest::mouseClick (wallet->send_blocks, Qt::LeftButton);
276  	QTest::keyClicks (wallet->send_account, key1.to_account ().c_str ());
277  	QTest::keyClicks (wallet->send_count, "2.03");
278  	QTest::mouseClick (wallet->send_blocks_send, Qt::LeftButton);
279  	system.deadline_set (10s);
280  	while (wallet->node.balance (key1).is_zero ())
281  	{
282  		ASSERT_NO_ERROR (system.poll ());
283  	}
284  	nano::uint128_t amount (wallet->node.balance (key1));
285  	ASSERT_EQ (2 * wallet->rendering_ratio + (3 * wallet->rendering_ratio / 100), amount);
286  	QTest::mouseClick (wallet->send_blocks_back, Qt::LeftButton);
287  	QTest::mouseClick (wallet->show_advanced, Qt::LeftButton);
288  	QTest::mouseClick (wallet->advanced.show_ledger, Qt::LeftButton);
289  	QTest::mouseClick (wallet->advanced.ledger_refresh, Qt::LeftButton);
290  	ASSERT_EQ (2, wallet->advanced.ledger_model->rowCount ());
291  	ASSERT_EQ (3, wallet->advanced.ledger_model->columnCount ());
292  	auto item (wallet->advanced.ledger_model->itemFromIndex (wallet->advanced.ledger_model->index (0, 1)));
293  	auto other_item (wallet->advanced.ledger_model->itemFromIndex (wallet->advanced.ledger_model->index (1, 1)));
294  	ASSERT_TRUE (("2" == item->text ()) || ("2" == other_item->text ()));
295  }
296  TEST (wallet, send_locked)
297  {
298  	nano_qt::eventloop_processor processor;
299  	nano::test::system system (1);
300  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
301  	nano::keypair key1;
302  	{
303  		auto transaction (system.wallet (0)->wallets.tx_begin_write ());
304  		system.wallet (0)->enter_password (transaction, "0");
305  	}
306  	auto account (nano::dev::genesis_key.pub);
307  	auto wallet (std::make_shared<nano_qt::wallet> (*test_application, processor, *system.nodes[0], system.wallet (0), account));
308  	wallet->start ();
309  	QTest::mouseClick (wallet->send_blocks, Qt::LeftButton);
310  	QTest::keyClicks (wallet->send_account, key1.pub.to_account ().c_str ());
311  	QTest::keyClicks (wallet->send_count, "2");
312  	QTest::mouseClick (wallet->send_blocks_send, Qt::LeftButton);
313  	system.deadline_set (10s);
314  	while (!wallet->send_blocks_send->isEnabled ())
315  	{
316  		test_application->processEvents ();
317  		ASSERT_NO_ERROR (system.poll ());
318  	}
319  }
320  TEST (wallet, DISABLED_process_block)
321  {
322  	nano_qt::eventloop_processor processor;
323  	nano::test::system system (1);
324  	nano::account account;
325  	nano::block_hash latest (system.nodes[0]->latest (nano::dev::genesis->account ()));
326  	system.wallet (0)->insert_adhoc (nano::keypair ().prv);
327  	{
328  		auto transaction (system.nodes[0]->wallets.tx_begin_read ());
329  		account = system.account (transaction, 0);
330  	}
331  	auto wallet (std::make_shared<nano_qt::wallet> (*test_application, processor, *system.nodes[0], system.wallet (0), account));
332  	wallet->start ();
333  	ASSERT_EQ ("Process", wallet->block_entry.process->text ());
334  	ASSERT_EQ ("Back", wallet->block_entry.back->text ());
335  	nano::keypair key1;
336  	ASSERT_EQ (wallet->entry_window, wallet->main_stack->currentWidget ());
337  	QTest::mouseClick (wallet->show_advanced, Qt::LeftButton);
338  	QTest::mouseClick (wallet->advanced.enter_block, Qt::LeftButton);
339  	ASSERT_EQ (wallet->block_entry.window, wallet->main_stack->currentWidget ());
340  	nano::send_block send (latest, key1.pub, 0, nano::dev::genesis_key.prv, nano::dev::genesis_key.pub, *system.work.generate (latest));
341  	std::string previous;
342  	send.hashables.previous.encode_hex (previous);
343  	std::string balance;
344  	send.hashables.balance.encode_hex (balance);
345  	std::string signature;
346  	send.signature.encode_hex (signature);
347  	std::string block_json;
348  	send.serialize_json (block_json);
349  	block_json.erase (std::remove (block_json.begin (), block_json.end (), '\n'), block_json.end ());
350  	QTest::keyClicks (wallet->block_entry.block, QString::fromStdString (block_json));
351  	QTest::mouseClick (wallet->block_entry.process, Qt::LeftButton);
352  	{
353  		auto transaction (system.nodes[0]->store.tx_begin_read ());
354  		system.deadline_set (10s);
355  		while (system.nodes[0]->store.block.exists (transaction, send.hash ()))
356  		{
357  			ASSERT_NO_ERROR (system.poll ());
358  		}
359  	}
360  	QTest::mouseClick (wallet->block_entry.back, Qt::LeftButton);
361  	ASSERT_EQ (wallet->advanced.window, wallet->main_stack->currentWidget ());
362  }
363  TEST (wallet, create_send)
364  {
365  	nano_qt::eventloop_processor processor;
366  	nano::keypair key;
367  	nano::test::system system (1);
368  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
369  	system.wallet (0)->insert_adhoc (key.prv);
370  	auto account (nano::dev::genesis_key.pub);
371  	auto wallet (std::make_shared<nano_qt::wallet> (*test_application, processor, *system.nodes[0], system.wallet (0), account));
372  	wallet->start ();
373  	wallet->client_window->show ();
374  	QTest::mouseClick (wallet->show_advanced, Qt::LeftButton);
375  	QTest::mouseClick (wallet->advanced.create_block, Qt::LeftButton);
376  	QTest::mouseClick (wallet->block_creation.send, Qt::LeftButton);
377  	QTest::keyClicks (wallet->block_creation.account, nano::dev::genesis_key.pub.to_account ().c_str ());
378  	QTest::keyClicks (wallet->block_creation.amount, "100000000000000000000");
379  	QTest::keyClicks (wallet->block_creation.destination, key.pub.to_account ().c_str ());
380  	QTest::mouseClick (wallet->block_creation.create, Qt::LeftButton);
381  	std::string json (wallet->block_creation.block->toPlainText ().toStdString ());
382  	ASSERT_FALSE (json.empty ());
383  	boost::property_tree::ptree tree1;
384  	std::stringstream istream (json);
385  	boost::property_tree::read_json (istream, tree1);
386  	bool error (false);
387  	nano::state_block send (error, tree1);
388  	ASSERT_FALSE (error);
389  	ASSERT_EQ (nano::process_result::progress, system.nodes[0]->process (send).code);
390  	ASSERT_EQ (nano::process_result::old, system.nodes[0]->process (send).code);
391  }
392  TEST (wallet, create_open_receive)
393  {
394  	nano_qt::eventloop_processor processor;
395  	nano::keypair key;
396  	nano::test::system system (1);
397  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
398  	system.wallet (0)->send_action (nano::dev::genesis_key.pub, key.pub, 100);
399  	nano::block_hash latest1 (system.nodes[0]->latest (nano::dev::genesis_key.pub));
400  	system.wallet (0)->send_action (nano::dev::genesis_key.pub, key.pub, 100);
401  	nano::block_hash latest2 (system.nodes[0]->latest (nano::dev::genesis_key.pub));
402  	ASSERT_NE (latest1, latest2);
403  	system.wallet (0)->insert_adhoc (key.prv);
404  	auto account (nano::dev::genesis_key.pub);
405  	auto wallet (std::make_shared<nano_qt::wallet> (*test_application, processor, *system.nodes[0], system.wallet (0), account));
406  	wallet->start ();
407  	wallet->client_window->show ();
408  	QTest::mouseClick (wallet->show_advanced, Qt::LeftButton);
409  	QTest::mouseClick (wallet->advanced.create_block, Qt::LeftButton);
410  	wallet->block_creation.open->click ();
411  	QTest::keyClicks (wallet->block_creation.source, latest1.to_string ().c_str ());
412  	QTest::keyClicks (wallet->block_creation.representative, nano::dev::genesis_key.pub.to_account ().c_str ());
413  	QTest::mouseClick (wallet->block_creation.create, Qt::LeftButton);
414  	std::string json1 (wallet->block_creation.block->toPlainText ().toStdString ());
415  	ASSERT_FALSE (json1.empty ());
416  	boost::property_tree::ptree tree1;
417  	std::stringstream istream1 (json1);
418  	boost::property_tree::read_json (istream1, tree1);
419  	bool error (false);
420  	nano::state_block open (error, tree1);
421  	ASSERT_FALSE (error);
422  	ASSERT_EQ (nano::process_result::progress, system.nodes[0]->process (open).code);
423  	ASSERT_EQ (nano::process_result::old, system.nodes[0]->process (open).code);
424  	wallet->block_creation.block->clear ();
425  	wallet->block_creation.source->clear ();
426  	wallet->block_creation.receive->click ();
427  	QTest::keyClicks (wallet->block_creation.source, latest2.to_string ().c_str ());
428  	QTest::mouseClick (wallet->block_creation.create, Qt::LeftButton);
429  	std::string json2 (wallet->block_creation.block->toPlainText ().toStdString ());
430  	ASSERT_FALSE (json2.empty ());
431  	boost::property_tree::ptree tree2;
432  	std::stringstream istream2 (json2);
433  	boost::property_tree::read_json (istream2, tree2);
434  	bool error2 (false);
435  	nano::state_block receive (error2, tree2);
436  	ASSERT_FALSE (error2);
437  	ASSERT_EQ (nano::process_result::progress, system.nodes[0]->process (receive).code);
438  	ASSERT_EQ (nano::process_result::old, system.nodes[0]->process (receive).code);
439  }
440  TEST (wallet, create_change)
441  {
442  	nano_qt::eventloop_processor processor;
443  	nano::keypair key;
444  	nano::test::system system (1);
445  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
446  	auto account (nano::dev::genesis_key.pub);
447  	auto wallet (std::make_shared<nano_qt::wallet> (*test_application, processor, *system.nodes[0], system.wallet (0), account));
<span onclick='openModal()' class='match'>448  	wallet->start ();
449  	wallet->client_window->show ();
450  	QTest::mouseClick (wallet->show_advanced, Qt::LeftButton);
</span>451  	QTest::mouseClick (wallet->advanced.create_block, Qt::LeftButton);
452  	wallet->block_creation.change->click ();
453  	QTest::keyClicks (wallet->block_creation.account, nano::dev::genesis_key.pub.to_account ().c_str ());
454  	QTest::keyClicks (wallet->block_creation.representative, key.pub.to_account ().c_str ());
455  	wallet->block_creation.create->click ();
456  	std::string json (wallet->block_creation.block->toPlainText ().toStdString ());
457  	ASSERT_FALSE (json.empty ());
458  	boost::property_tree::ptree tree1;
459  	std::stringstream istream (json);
460  	boost::property_tree::read_json (istream, tree1);
461  	bool error (false);
462  	nano::state_block change (error, tree1);
463  	ASSERT_FALSE (error);
464  	ASSERT_EQ (nano::process_result::progress, system.nodes[0]->process (change).code);
465  	ASSERT_EQ (nano::process_result::old, system.nodes[0]->process (change).code);
466  }
467  TEST (history, short_text)
468  {
469  	if (nano::rocksdb_config::using_rocksdb_in_tests ())
470  	{
471  		return;
472  	}
473  	nano_qt::eventloop_processor processor;
474  	nano::keypair key;
475  	nano::test::system system (1);
476  	system.wallet (0)->insert_adhoc (key.prv);
477  	nano::account account;
478  	{
479  		auto transaction (system.nodes[0]->wallets.tx_begin_read ());
480  		account = system.account (transaction, 0);
481  	}
482  	auto wallet (std::make_shared<nano_qt::wallet> (*test_application, processor, *system.nodes[0], system.wallet (0), account));
483  	auto store = nano::make_store (system.nodes[0]->logger, nano::unique_path (), nano::dev::constants);
484  	ASSERT_TRUE (!store->init_error ());
485  	nano::ledger ledger (*store, system.nodes[0]->stats, nano::dev::constants);
486  	{
487  		auto transaction (store->tx_begin_write ());
488  		store->initialize (transaction, ledger.cache, ledger.constants);
489  		nano::keypair key;
490  		auto latest (ledger.latest (transaction, nano::dev::genesis_key.pub));
491  		nano::send_block send (latest, nano::dev::genesis_key.pub, 0, nano::dev::genesis_key.prv, nano::dev::genesis_key.pub, *system.work.generate (latest));
492  		ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, send).code);
493  		nano::receive_block receive (send.hash (), send.hash (), nano::dev::genesis_key.prv, nano::dev::genesis_key.pub, *system.work.generate (send.hash ()));
494  		ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, receive).code);
495  		nano::change_block change (receive.hash (), key.pub, nano::dev::genesis_key.prv, nano::dev::genesis_key.pub, *system.work.generate (receive.hash ()));
496  		ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, change).code);
497  	}
498  	nano_qt::history history (ledger, nano::dev::genesis_key.pub, *wallet);
499  	history.refresh ();
500  	ASSERT_EQ (4, history.model->rowCount ());
501  }
502  TEST (history, pruned_source)
503  {
504  	if (nano::rocksdb_config::using_rocksdb_in_tests ())
505  	{
506  		return;
507  	}
508  	nano_qt::eventloop_processor processor;
509  	nano::keypair key;
510  	nano::test::system system (1);
511  	system.wallet (0)->insert_adhoc (key.prv);
512  	nano::account account;
513  	{
514  		auto transaction (system.nodes[0]->wallets.tx_begin_read ());
515  		account = system.account (transaction, 0);
516  	}
517  	auto wallet (std::make_shared<nano_qt::wallet> (*test_application, processor, *system.nodes[0], system.wallet (0), account));
518  	auto store = nano::make_store (system.nodes[0]->logger, nano::unique_path (), nano::dev::constants);
519  	ASSERT_TRUE (!store->init_error ());
520  	nano::ledger ledger (*store, system.nodes[0]->stats, nano::dev::constants);
521  	ledger.pruning = true;
522  	nano::block_hash next_pruning;
523  	{
524  		auto transaction (store->tx_begin_write ());
525  		store->initialize (transaction, ledger.cache, nano::dev::constants);
526  		auto latest (ledger.latest (transaction, nano::dev::genesis_key.pub));
527  		nano::send_block send1 (latest, nano::dev::genesis_key.pub, nano::dev::constants.genesis_amount - 100, nano::dev::genesis_key.prv, nano::dev::genesis_key.pub, *system.work.generate (latest));
528  		ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, send1).code);
529  		nano::send_block send2 (send1.hash (), key.pub, nano::dev::constants.genesis_amount - 200, nano::dev::genesis_key.prv, nano::dev::genesis_key.pub, *system.work.generate (send1.hash ()));
530  		ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, send2).code);
531  		nano::receive_block receive (send2.hash (), send1.hash (), nano::dev::genesis_key.prv, nano::dev::genesis_key.pub, *system.work.generate (send2.hash ()));
532  		ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, receive).code);
533  		nano::open_block open (send2.hash (), key.pub, key.pub, key.prv, key.pub, *system.work.generate (key.pub));
534  		ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, open).code);
535  		ASSERT_EQ (1, ledger.pruning_action (transaction, send1.hash (), 2));
536  		next_pruning = send2.hash ();
537  	}
538  	nano_qt::history history1 (ledger, nano::dev::genesis_key.pub, *wallet);
539  	history1.refresh ();
540  	ASSERT_EQ (2, history1.model->rowCount ());
541  	nano_qt::history history2 (ledger, key.pub, *wallet);
542  	history2.refresh ();
543  	ASSERT_EQ (1, history2.model->rowCount ());
544  	{
545  		auto transaction (store->tx_begin_write ());
546  		ASSERT_EQ (1, ledger.pruning_action (transaction, next_pruning, 2));
547  	}
548  	history1.refresh ();
549  	ASSERT_EQ (1, history1.model->rowCount ());
550  	history2.refresh ();
551  	ASSERT_EQ (1, history2.model->rowCount ());
552  	{
553  		auto transaction (store->tx_begin_write ());
554  		auto latest (ledger.latest (transaction, nano::dev::genesis_key.pub));
555  		nano::state_block send (nano::dev::genesis_key.pub, latest, nano::dev::genesis_key.pub, nano::dev::constants.genesis_amount - 200, key.pub, nano::dev::genesis_key.prv, nano::dev::genesis_key.pub, *system.work.generate (latest));
556  		ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, send).code);
557  		auto latest_key (ledger.latest (transaction, key.pub));
558  		nano::state_block receive (key.pub, latest_key, key.pub, 200, send.hash (), key.prv, key.pub, *system.work.generate (latest_key));
559  		ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, receive).code);
560  		ASSERT_EQ (1, ledger.pruning_action (transaction, latest, 2));
561  		ASSERT_EQ (1, ledger.pruning_action (transaction, latest_key, 2));
562  	}
563  	history1.refresh ();
564  	ASSERT_EQ (1, history1.model->rowCount ());
565  	history2.refresh ();
566  	ASSERT_EQ (1, history2.model->rowCount ());
567  }
568  TEST (wallet, startup_work)
569  {
570  	nano_qt::eventloop_processor processor;
571  	nano::keypair key;
572  	nano::test::system system (1);
573  	system.wallet (0)->insert_adhoc (key.prv);
574  	nano::account account;
575  	{
576  		auto transaction (system.nodes[0]->wallets.tx_begin_read ());
577  		account = system.account (transaction, 0);
578  	}
579  	auto wallet (std::make_shared<nano_qt::wallet> (*test_application, processor, *system.nodes[0], system.wallet (0), account));
580  	wallet->start ();
581  	QTest::mouseClick (wallet->show_advanced, Qt::LeftButton);
582  	uint64_t work1;
583  	{
584  		auto transaction (system.nodes[0]->wallets.tx_begin_read ());
585  		ASSERT_TRUE (wallet->wallet_m->store.work_get (transaction, nano::dev::genesis_key.pub, work1));
586  	}
587  	QTest::mouseClick (wallet->accounts_button, Qt::LeftButton);
588  	QTest::keyClicks (wallet->accounts.account_key_line, "34F0A37AAD20F4A260F0A5B3CB3D7FB50673212263E58A380BC10474BB039CE4");
589  	QTest::mouseClick (wallet->accounts.account_key_button, Qt::LeftButton);
590  	system.deadline_set (10s);
591  	auto again (true);
592  	while (again)
593  	{
594  		ASSERT_NO_ERROR (system.poll ());
595  		auto transaction (system.nodes[0]->wallets.tx_begin_read ());
596  		again = wallet->wallet_m->store.work_get (transaction, nano::dev::genesis_key.pub, work1);
597  	}
598  }
599  TEST (wallet, block_viewer)
600  {
601  	nano_qt::eventloop_processor processor;
602  	nano::keypair key;
603  	nano::test::system system (1);
604  	system.wallet (0)->insert_adhoc (key.prv);
605  	nano::account account;
606  	{
607  		auto transaction (system.nodes[0]->wallets.tx_begin_read ());
608  		account = system.account (transaction, 0);
609  	}
610  	auto wallet (std::make_shared<nano_qt::wallet> (*test_application, processor, *system.nodes[0], system.wallet (0), account));
611  	wallet->start ();
612  	QTest::mouseClick (wallet->show_advanced, Qt::LeftButton);
613  	ASSERT_NE (-1, wallet->advanced.layout->indexOf (wallet->advanced.block_viewer));
614  	QTest::mouseClick (wallet->advanced.block_viewer, Qt::LeftButton);
615  	ASSERT_EQ (wallet->block_viewer.window, wallet->main_stack->currentWidget ());
616  	nano::block_hash latest (system.nodes[0]->latest (nano::dev::genesis->account ()));
617  	QTest::keyClicks (wallet->block_viewer.hash, latest.to_string ().c_str ());
618  	QTest::mouseClick (wallet->block_viewer.retrieve, Qt::LeftButton);
619  	ASSERT_FALSE (wallet->block_viewer.block->toPlainText ().toStdString ().empty ());
620  	QTest::mouseClick (wallet->block_viewer.back, Qt::LeftButton);
621  	ASSERT_EQ (wallet->advanced.window, wallet->main_stack->currentWidget ());
622  }
623  TEST (wallet, import)
624  {
625  	nano_qt::eventloop_processor processor;
626  	nano::test::system system (2);
627  	std::string json;
628  	nano::keypair key1;
629  	nano::keypair key2;
630  	system.wallet (0)->insert_adhoc (key1.prv);
631  	{
632  		auto transaction (system.nodes[0]->wallets.tx_begin_read ());
633  		system.wallet (0)->store.serialize_json (transaction, json);
634  	}
635  	system.wallet (1)->insert_adhoc (key2.prv);
636  	auto path (nano::unique_path ());
637  	{
638  		std::ofstream stream;
639  		stream.open (path.string ().c_str ());
640  		stream << json;
641  	}
642  	auto wallet (std::make_shared<nano_qt::wallet> (*test_application, processor, *system.nodes[1], system.wallet (1), key2.pub));
643  	wallet->start ();
644  	QTest::mouseClick (wallet->show_advanced, Qt::LeftButton);
645  	ASSERT_EQ (wallet->advanced.window, wallet->main_stack->currentWidget ());
646  	QTest::mouseClick (wallet->accounts_button, Qt::LeftButton);
647  	ASSERT_EQ (wallet->accounts.window, wallet->main_stack->currentWidget ());
648  	QTest::mouseClick (wallet->accounts.import_wallet, Qt::LeftButton);
649  	ASSERT_EQ (wallet->import.window, wallet->main_stack->currentWidget ());
650  	QTest::keyClicks (wallet->import.filename, path.string ().c_str ());
651  	QTest::keyClicks (wallet->import.password, "");
652  	ASSERT_FALSE (system.wallet (1)->exists (key1.pub));
653  	QTest::mouseClick (wallet->import.perform, Qt::LeftButton);
654  	ASSERT_TRUE (system.wallet (1)->exists (key1.pub));
655  }
656  TEST (wallet, republish)
657  {
658  	nano_qt::eventloop_processor processor;
659  	nano::test::system system (2);
660  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
661  	nano::keypair key;
662  	nano::block_hash hash;
663  	{
664  		auto transaction (system.nodes[0]->store.tx_begin_write ());
665  		auto latest (system.nodes[0]->ledger.latest (transaction, nano::dev::genesis_key.pub));
666  		nano::send_block block (latest, key.pub, 0, nano::dev::genesis_key.prv, nano::dev::genesis_key.pub, *system.work.generate (latest));
667  		hash = block.hash ();
668  		ASSERT_EQ (nano::process_result::progress, system.nodes[0]->ledger.process (transaction, block).code);
669  	}
670  	auto account (nano::dev::genesis_key.pub);
671  	auto wallet (std::make_shared<nano_qt::wallet> (*test_application, processor, *system.nodes[0], system.wallet (0), account));
672  	wallet->start ();
673  	QTest::mouseClick (wallet->show_advanced, Qt::LeftButton);
674  	ASSERT_EQ (wallet->advanced.window, wallet->main_stack->currentWidget ());
675  	QTest::mouseClick (wallet->advanced.block_viewer, Qt::LeftButton);
676  	ASSERT_EQ (wallet->block_viewer.window, wallet->main_stack->currentWidget ());
677  	QTest::keyClicks (wallet->block_viewer.hash, hash.to_string ().c_str ());
678  	QTest::mouseClick (wallet->block_viewer.rebroadcast, Qt::LeftButton);
679  	ASSERT_FALSE (system.nodes[1]->balance (nano::dev::genesis_key.pub).is_zero ());
680  	system.deadline_set (10s);
681  	while (system.nodes[1]->balance (nano::dev::genesis_key.pub).is_zero ())
682  	{
683  		ASSERT_NO_ERROR (system.poll ());
684  	}
685  }
686  TEST (wallet, ignore_empty_adhoc)
687  {
688  	nano_qt::eventloop_processor processor;
689  	nano::test::system system (1);
690  	nano::keypair key1;
691  	system.wallet (0)->insert_adhoc (key1.prv);
692  	auto wallet (std::make_shared<nano_qt::wallet> (*test_application, processor, *system.nodes[0], system.wallet (0), key1.pub));
693  	wallet->start ();
694  	QTest::mouseClick (wallet->show_advanced, Qt::LeftButton);
695  	ASSERT_EQ (wallet->advanced.window, wallet->main_stack->currentWidget ());
696  	QTest::mouseClick (wallet->accounts_button, Qt::LeftButton);
697  	ASSERT_EQ (wallet->accounts.window, wallet->main_stack->currentWidget ());
698  	QTest::keyClicks (wallet->accounts.account_key_line, nano::dev::genesis_key.prv.to_string ().c_str ());
699  	QTest::mouseClick (wallet->accounts.account_key_button, Qt::LeftButton);
700  	ASSERT_EQ (1, wallet->accounts.model->rowCount ());
701  	ASSERT_EQ (0, wallet->accounts.account_key_line->text ().length ());
702  	nano::keypair key;
703  	QTest::keyClicks (wallet->accounts.account_key_line, key.prv.to_string ().c_str ());
704  	QTest::mouseClick (wallet->accounts.account_key_button, Qt::LeftButton);
705  	ASSERT_EQ (1, wallet->accounts.model->rowCount ());
706  	ASSERT_EQ (0, wallet->accounts.account_key_line->text ().length ());
707  	QTest::mouseClick (wallet->accounts.create_account, Qt::LeftButton);
708  	test_application->processEvents ();
709  	test_application->processEvents ();
710  	ASSERT_EQ (2, wallet->accounts.model->rowCount ());
711  }
712  TEST (wallet, change_seed)
713  {
714  	nano_qt::eventloop_processor processor;
715  	nano::test::system system (1);
716  	auto key1 (system.wallet (0)->deterministic_insert ());
717  	system.wallet (0)->deterministic_insert ();
718  	nano::raw_key seed3;
719  	{
720  		auto transaction (system.wallet (0)->wallets.tx_begin_read ());
721  		system.wallet (0)->store.seed (seed3, transaction);
722  	}
723  	auto wallet_key (key1);
724  	auto wallet (std::make_shared<nano_qt::wallet> (*test_application, processor, *system.nodes[0], system.wallet (0), wallet_key));
725  	wallet->start ();
726  	QTest::mouseClick (wallet->show_advanced, Qt::LeftButton);
727  	ASSERT_EQ (wallet->advanced.window, wallet->main_stack->currentWidget ());
728  	QTest::mouseClick (wallet->accounts_button, Qt::LeftButton);
729  	ASSERT_EQ (wallet->accounts.window, wallet->main_stack->currentWidget ());
730  	QTest::mouseClick (wallet->accounts.import_wallet, Qt::LeftButton);
731  	ASSERT_EQ (wallet->import.window, wallet->main_stack->currentWidget ());
732  	nano::raw_key seed;
733  	seed.clear ();
734  	QTest::keyClicks (wallet->import.seed, seed.to_string ().c_str ());
735  	nano::raw_key seed1;
736  	{
737  		auto transaction (system.wallet (0)->wallets.tx_begin_read ());
738  		system.wallet (0)->store.seed (seed1, transaction);
739  	}
740  	ASSERT_NE (seed, seed1);
741  	ASSERT_TRUE (system.wallet (0)->exists (key1));
742  	ASSERT_EQ (2, wallet->accounts.model->rowCount ());
743  	QTest::mouseClick (wallet->import.import_seed, Qt::LeftButton);
744  	ASSERT_EQ (2, wallet->accounts.model->rowCount ());
745  	QTest::keyClicks (wallet->import.clear_line, "clear keys");
746  	QTest::mouseClick (wallet->import.import_seed, Qt::LeftButton);
747  	ASSERT_EQ (1, wallet->accounts.model->rowCount ());
748  	ASSERT_TRUE (wallet->import.clear_line->text ().toStdString ().empty ());
749  	nano::raw_key seed2;
750  	auto transaction (system.wallet (0)->wallets.tx_begin_read ());
751  	system.wallet (0)->store.seed (seed2, transaction);
752  	ASSERT_EQ (seed, seed2);
753  	ASSERT_FALSE (system.wallet (0)->exists (key1));
754  	ASSERT_NE (key1, wallet->account);
755  	auto key2 (wallet->account);
756  	ASSERT_TRUE (system.wallet (0)->exists (key2));
757  	QTest::keyClicks (wallet->import.seed, seed3.to_string ().c_str ());
758  	QTest::keyClicks (wallet->import.clear_line, "clear keys");
759  	QTest::mouseClick (wallet->import.import_seed, Qt::LeftButton);
760  	ASSERT_EQ (key1, wallet->account);
761  	ASSERT_FALSE (system.wallet (0)->exists (key2));
762  	ASSERT_TRUE (system.wallet (0)->exists (key1));
763  }
764  TEST (wallet, seed_work_generation)
765  {
766  	nano_qt::eventloop_processor processor;
767  	nano::test::system system (1);
768  	auto key1 (system.wallet (0)->deterministic_insert ());
769  	auto wallet (std::make_shared<nano_qt::wallet> (*test_application, processor, *system.nodes[0], system.wallet (0), key1));
770  	wallet->start ();
771  	QTest::mouseClick (wallet->show_advanced, Qt::LeftButton);
772  	ASSERT_EQ (wallet->advanced.window, wallet->main_stack->currentWidget ());
773  	QTest::mouseClick (wallet->accounts_button, Qt::LeftButton);
774  	ASSERT_EQ (wallet->accounts.window, wallet->main_stack->currentWidget ());
775  	QTest::mouseClick (wallet->accounts.import_wallet, Qt::LeftButton);
776  	ASSERT_EQ (wallet->import.window, wallet->main_stack->currentWidget ());
777  	nano::raw_key seed;
778  	auto prv = nano::deterministic_key (seed, 0);
779  	auto pub (nano::pub_key (prv));
780  	QTest::keyClicks (wallet->import.seed, seed.to_string ().c_str ());
781  	QTest::keyClicks (wallet->import.clear_line, "clear keys");
782  	uint64_t work (0);
783  	QTest::mouseClick (wallet->import.import_seed, Qt::LeftButton);
784  	system.deadline_set (10s);
785  	while (work == 0)
786  	{
787  		auto ec = system.poll ();
788  		auto transaction (system.wallet (0)->wallets.tx_begin_read ());
789  		system.wallet (0)->store.work_get (transaction, pub, work);
790  		ASSERT_NO_ERROR (ec);
791  	}
792  	auto transaction (system.nodes[0]->store.tx_begin_read ());
793  	ASSERT_GE (nano::dev::network_params.work.difficulty (nano::work_version::work_1, system.nodes[0]->ledger.latest_root (transaction, pub), work), system.nodes[0]->default_difficulty (nano::work_version::work_1));
794  }
795  TEST (wallet, backup_seed)
796  {
797  	nano_qt::eventloop_processor processor;
798  	nano::test::system system (1);
799  	auto key1 (system.wallet (0)->deterministic_insert ());
800  	auto wallet (std::make_shared<nano_qt::wallet> (*test_application, processor, *system.nodes[0], system.wallet (0), key1));
801  	wallet->start ();
802  	QTest::mouseClick (wallet->show_advanced, Qt::LeftButton);
803  	ASSERT_EQ (wallet->advanced.window, wallet->main_stack->currentWidget ());
804  	QTest::mouseClick (wallet->accounts_button, Qt::LeftButton);
805  	ASSERT_EQ (wallet->accounts.window, wallet->main_stack->currentWidget ());
806  	QTest::mouseClick (wallet->accounts.backup_seed, Qt::LeftButton);
807  	nano::raw_key seed;
808  	auto transaction (system.wallet (0)->wallets.tx_begin_read ());
809  	system.wallet (0)->store.seed (seed, transaction);
810  	ASSERT_EQ (seed.to_string (), test_application->clipboard ()->text ().toStdString ());
811  }
812  TEST (wallet, import_locked)
813  {
814  	nano_qt::eventloop_processor processor;
815  	nano::test::system system (1);
816  	auto key1 (system.wallet (0)->deterministic_insert ());
817  	{
818  		auto transaction (system.wallet (0)->wallets.tx_begin_write ());
819  		system.wallet (0)->store.rekey (transaction, "1");
820  	}
821  	auto wallet (std::make_shared<nano_qt::wallet> (*test_application, processor, *system.nodes[0], system.wallet (0), key1));
822  	wallet->start ();
823  	QTest::mouseClick (wallet->show_advanced, Qt::LeftButton);
824  	ASSERT_EQ (wallet->advanced.window, wallet->main_stack->currentWidget ());
825  	QTest::mouseClick (wallet->accounts_button, Qt::LeftButton);
826  	ASSERT_EQ (wallet->accounts.window, wallet->main_stack->currentWidget ());
827  	nano::raw_key seed1;
828  	seed1.clear ();
829  	QTest::keyClicks (wallet->import.seed, seed1.to_string ().c_str ());
830  	QTest::keyClicks (wallet->import.clear_line, "clear keys");
831  	{
832  		auto transaction (system.wallet (0)->wallets.tx_begin_write ());
833  		system.wallet (0)->enter_password (transaction, "");
834  	}
835  	QTest::mouseClick (wallet->import.import_seed, Qt::LeftButton);
836  	nano::raw_key seed2;
837  	{
838  		auto transaction (system.wallet (0)->wallets.tx_begin_write ());
839  		system.wallet (0)->store.seed (seed2, transaction);
840  		ASSERT_NE (seed1, seed2);
841  		system.wallet (0)->enter_password (transaction, "1");
842  	}
843  	QTest::mouseClick (wallet->import.import_seed, Qt::LeftButton);
844  	nano::raw_key seed3;
845  	auto transaction (system.wallet (0)->wallets.tx_begin_read ());
846  	system.wallet (0)->store.seed (seed3, transaction);
847  	ASSERT_EQ (seed1, seed3);
848  }
849  TEST (wallet, DISABLED_synchronizing)
850  {
851  	nano_qt::eventloop_processor processor;
852  	nano::test::system system0 (1);
853  	nano::test::system system1 (1);
854  	auto key1 (system0.wallet (0)->deterministic_insert ());
855  	auto wallet (std::make_shared<nano_qt::wallet> (*test_application, processor, *system0.nodes[0], system0.wallet (0), key1));
856  	wallet->start ();
857  	{
858  		auto transaction (system1.nodes[0]->store.tx_begin_write ());
859  		auto latest (system1.nodes[0]->ledger.latest (transaction, nano::dev::genesis->account ()));
860  		nano::send_block send (latest, key1, 0, nano::dev::genesis_key.prv, nano::dev::genesis_key.pub, *system1.work.generate (latest));
861  		system1.nodes[0]->ledger.process (transaction, send);
862  	}
863  	ASSERT_EQ (0, wallet->active_status.active.count (nano_qt::status_types::synchronizing));
864  	system0.nodes[0]->bootstrap_initiator.bootstrap (system1.nodes[0]->network.endpoint ());
865  	system1.deadline_set (10s);
866  	while (wallet->active_status.active.count (nano_qt::status_types::synchronizing) == 0)
867  	{
868  		ASSERT_NO_ERROR (system0.poll ());
869  		ASSERT_NO_ERROR (system1.poll ());
870  		test_application->processEvents ();
871  	}
872  	system1.deadline_set (25s);
873  	while (wallet->active_status.active.count (nano_qt::status_types::synchronizing) == 1)
874  	{
875  		ASSERT_NO_ERROR (system0.poll ());
876  		ASSERT_NO_ERROR (system1.poll ());
877  		test_application->processEvents ();
878  	}
879  }
880  TEST (wallet, epoch_2_validation)
881  {
882  	nano_qt::eventloop_processor processor;
883  	nano::test::system system (1);
884  	auto & node = system.nodes[0];
885  	ASSERT_NE (nullptr, system.upgrade_genesis_epoch (*node, nano::epoch::epoch_1));
886  	ASSERT_NE (nullptr, system.upgrade_genesis_epoch (*node, nano::epoch::epoch_2));
887  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
888  	auto account (nano::dev::genesis_key.pub);
889  	auto wallet (std::make_shared<nano_qt::wallet> (*test_application, processor, *node, system.wallet (0), account));
890  	wallet->start ();
891  	wallet->client_window->show ();
892  	QTest::mouseClick (wallet->show_advanced, Qt::LeftButton);
893  	QTest::mouseClick (wallet->advanced.create_block, Qt::LeftButton);
894  	auto create_and_process = [&] () -> nano::block_hash {
895  		wallet->block_creation.create->click ();
896  		std::string json (wallet->block_creation.block->toPlainText ().toStdString ());
897  		EXPECT_FALSE (json.empty ());
898  		boost::property_tree::ptree tree1;
899  		std::stringstream istream (json);
900  		boost::property_tree::read_json (istream, tree1);
901  		bool error (false);
902  		nano::state_block block (error, tree1);
903  		EXPECT_FALSE (error);
904  		EXPECT_EQ (nano::process_result::progress, node->process (block).code);
905  		return block.hash ();
906  	};
907  	auto do_send = [&] (nano::public_key const & destination) -> nano::block_hash {
908  		wallet->block_creation.send->click ();
909  		wallet->block_creation.account->setText (nano::dev::genesis_key.pub.to_account ().c_str ());
910  		wallet->block_creation.amount->setText ("1");
911  		wallet->block_creation.destination->setText (destination.to_account ().c_str ());
912  		return create_and_process ();
913  	};
914  	auto do_open = [&] (nano::block_hash const & source, nano::public_key const & account) -> nano::block_hash {
915  		wallet->block_creation.open->click ();
916  		wallet->block_creation.source->setText (source.to_string ().c_str ());
917  		wallet->block_creation.representative->setText (account.to_account ().c_str ());
918  		return create_and_process ();
919  	};
920  	auto do_receive = [&] (nano::block_hash const & source) -> nano::block_hash {
921  		wallet->block_creation.receive->click ();
922  		wallet->block_creation.source->setText (source.to_string ().c_str ());
923  		return create_and_process ();
924  	};
925  	auto do_change = [&] (nano::public_key const & account, nano::public_key const & representative) -> nano::block_hash {
926  		wallet->block_creation.change->click ();
927  		wallet->block_creation.account->setText (account.to_account ().c_str ());
928  		wallet->block_creation.representative->setText (representative.to_account ().c_str ());
929  		return create_and_process ();
930  	};
931  	auto tries = 0;
932  	auto max_tries = 20;
933  	while (++tries < max_tries)
934  	{
935  		nano::keypair key;
936  		system.wallet (0)->insert_adhoc (key.prv);
937  		auto send1 = do_send (key.pub);
938  		do_open (send1, key.pub);
939  		auto send2 = do_send (key.pub);
940  		do_receive (send2);
941  		do_change (key.pub, nano::dev::genesis_key.pub);
942  	}
943  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ScintillaEditBase.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-qt_94.cpp</div>
                </div>
                <div class="column column_space"><pre><code>444  			sqt->ClearBeforeTentativeStart();
445  		sqt->pdoc->TentativeStart(); 
446  		preeditPos = sqt->CurrentPosition();
</pre></code></div>
                <div class="column column_space"><pre><code>448  	wallet->start ();
449  	wallet->client_window->show ();
450  	QTest::mouseClick (wallet->show_advanced, Qt::LeftButton);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    