
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.522504892367906%, Tokens: 9</h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-atomic_hook.h</h3>
            <pre><code>1  #ifndef ABSL_BASE_INTERNAL_ATOMIC_HOOK_H_
2  #define ABSL_BASE_INTERNAL_ATOMIC_HOOK_H_
3  #include <atomic>
4  #include <cassert>
5  #include <cstdint>
6  #include <utility>
7  #include "absl/base/attributes.h"
8  #include "absl/base/config.h"
9  #if defined(_MSC_VER) && !defined(__clang__)
10  #define ABSL_HAVE_WORKING_CONSTEXPR_STATIC_INIT 0
11  #else
12  #define ABSL_HAVE_WORKING_CONSTEXPR_STATIC_INIT 1
13  #endif
14  #if defined(_MSC_VER)
15  #define ABSL_HAVE_WORKING_ATOMIC_POINTER 0
16  #else
17  #define ABSL_HAVE_WORKING_ATOMIC_POINTER 1
18  #endif
19  namespace absl {
20  ABSL_NAMESPACE_BEGIN
21  namespace base_internal {
22  template <typename T>
23  class AtomicHook;
24  #if ABSL_HAVE_WORKING_CONSTEXPR_STATIC_INIT
25  #define ABSL_INTERNAL_ATOMIC_HOOK_ATTRIBUTES ABSL_CONST_INIT
26  #else
27  #define ABSL_INTERNAL_ATOMIC_HOOK_ATTRIBUTES
28  #endif
29  template <typename ReturnType, typename... Args>
30  class AtomicHook<ReturnType (*)(Args...)> {
31   public:
32    using FnPtr = ReturnType (*)(Args...);
<span onclick='openModal()' class='match'>33    constexpr AtomicHook() : AtomicHook(DummyFunction) {}
34  #if ABSL_HAVE_WORKING_ATOMIC_POINTER && ABSL_HAVE_WORKING_CONSTEXPR_STATIC_INIT
35    explicit constexpr AtomicHook(FnPtr default_fn)
36        : hook_(default_fn), default_fn_(default_fn) {}
37  #elif ABSL_HAVE_WORKING_CONSTEXPR_STATIC_INIT
38    explicit constexpr AtomicHook(FnPtr default_fn)
39        : hook_(kUninitialized), default_fn_(default_fn) {}
40  #else
41    explicit constexpr AtomicHook(FnPtr default_fn)
42        : &bsol;* hook_(deliberately omitted), */ default_fn_(default_fn) {
43      static_assert(kUninitialized == 0, "here we rely on zero-initialization");
44    }
45  #endif
46    void Store(FnPtr fn) {
</span>47      bool success = DoStore(fn);
48      static_cast<void>(success);
49      assert(success);
50    }
51    template <typename... CallArgs>
52    ReturnType operator()(CallArgs&&... args) const {
53      return DoLoad()(std::forward<CallArgs>(args)...);
54    }
55    FnPtr Load() const {
56      FnPtr ptr = DoLoad();
57      return (ptr == DummyFunction) ? nullptr : ptr;
58    }
59   private:
60    static ReturnType DummyFunction(Args...) {
61      return ReturnType();
62    }
63  #if ABSL_HAVE_WORKING_ATOMIC_POINTER
64    FnPtr DoLoad() const { return hook_.load(std::memory_order_acquire); }
65    bool DoStore(FnPtr fn) {
66      assert(fn);
67      FnPtr expected = default_fn_;
68      const bool store_succeeded = hook_.compare_exchange_strong(
69          expected, fn, std::memory_order_acq_rel, std::memory_order_acquire);
70      const bool same_value_already_stored = (expected == fn);
71      return store_succeeded || same_value_already_stored;
72    }
73    std::atomic<FnPtr> hook_;
74  #else  
75    static constexpr intptr_t kUninitialized = 0;
76    static_assert(sizeof(intptr_t) >= sizeof(FnPtr),
77                  "intptr_t can't contain a function pointer");
78    FnPtr DoLoad() const {
79      const intptr_t value = hook_.load(std::memory_order_acquire);
80      if (value == kUninitialized) {
81        return default_fn_;
82      }
83      return reinterpret_cast<FnPtr>(value);
84    }
85    bool DoStore(FnPtr fn) {
86      assert(fn);
87      const auto value = reinterpret_cast<intptr_t>(fn);
88      intptr_t expected = kUninitialized;
89      const bool store_succeeded = hook_.compare_exchange_strong(
90          expected, value, std::memory_order_acq_rel, std::memory_order_acquire);
91      const bool same_value_already_stored = (expected == value);
92      return store_succeeded || same_value_already_stored;
93    }
94    std::atomic<intptr_t> hook_;
95  #endif
96    const FnPtr default_fn_;
97  };
98  #undef ABSL_HAVE_WORKING_ATOMIC_POINTER
99  #undef ABSL_HAVE_WORKING_CONSTEXPR_STATIC_INIT
100  }  
101  ABSL_NAMESPACE_END
102  }  
103  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-service.cpp</h3>
            <pre><code>1  #include <nano/lib/stats_enums.hpp>
2  #include <nano/node/blockprocessor.hpp>
3  #include <nano/node/bootstrap_ascending/service.hpp>
4  #include <nano/node/network.hpp>
5  #include <nano/node/nodeconfig.hpp>
6  #include <nano/node/transport/transport.hpp>
7  #include <nano/secure/common.hpp>
8  #include <nano/secure/ledger.hpp>
9  #include <nano/secure/store.hpp>
10  using namespace std::chrono_literals;
11  nano::bootstrap_ascending::service::service (nano::node_config & config_a, nano::block_processor & block_processor_a, nano::ledger & ledger_a, nano::network & network_a, nano::stats & stat_a) :
<span onclick='openModal()' class='match'>12  	config{ config_a },
13  	network_consts{ config.network_params.network },
14  	block_processor{ block_processor_a },
15  	ledger{ ledger_a },
16  	network{ network_a },
</span>17  	stats{ stat_a },
18  	accounts{ stats },
19  	iterator{ ledger.store },
20  	throttle{ compute_throttle_size () },
21  	scoring{ config.bootstrap_ascending, config.network_params.network },
22  	database_limiter{ config.bootstrap_ascending.database_requests_limit, 1.0 }
23  {
24  	block_processor.batch_processed.add ([this] (auto const & batch) {
25  		{
26  			nano::lock_guard<nano::mutex> lock{ mutex };
27  			auto transaction = ledger.store.tx_begin_read ();
28  			for (auto const & [result, block] : batch)
29  			{
30  				debug_assert (block != nullptr);
31  				inspect (transaction, result, *block);
32  			}
33  		}
34  		condition.notify_all ();
35  	});
36  }
37  nano::bootstrap_ascending::service::~service ()
38  {
39  	debug_assert (!thread.joinable ());
40  	debug_assert (!timeout_thread.joinable ());
41  }
42  void nano::bootstrap_ascending::service::start ()
43  {
44  	debug_assert (!thread.joinable ());
45  	debug_assert (!timeout_thread.joinable ());
46  	thread = std::thread ([this] () {
47  		nano::thread_role::set (nano::thread_role::name::ascending_bootstrap);
48  		run ();
49  	});
50  	timeout_thread = std::thread ([this] () {
51  		nano::thread_role::set (nano::thread_role::name::ascending_bootstrap);
52  		run_timeouts ();
53  	});
54  }
55  void nano::bootstrap_ascending::service::stop ()
56  {
57  	nano::unique_lock<nano::mutex> lock{ mutex };
58  	stopped = true;
59  	lock.unlock ();
60  	condition.notify_all ();
61  	nano::join_or_pass (thread);
62  	nano::join_or_pass (timeout_thread);
63  }
64  void nano::bootstrap_ascending::service::send (std::shared_ptr<nano::transport::channel> channel, async_tag tag)
65  {
66  	debug_assert (tag.type == async_tag::query_type::blocks_by_hash || tag.type == async_tag::query_type::blocks_by_account);
67  	nano::asc_pull_req request{ network_consts };
68  	request.id = tag.id;
69  	request.type = nano::asc_pull_type::blocks;
70  	nano::asc_pull_req::blocks_payload request_payload;
71  	request_payload.start = tag.start;
72  	request_payload.count = config.bootstrap_ascending.pull_count;
73  	request_payload.start_type = (tag.type == async_tag::query_type::blocks_by_hash) ? nano::asc_pull_req::hash_type::block : nano::asc_pull_req::hash_type::account;
74  	request.payload = request_payload;
75  	request.update_header ();
76  	stats.inc (nano::stat::type::bootstrap_ascending, nano::stat::detail::request, nano::stat::dir::out);
77  	channel->send (
78  	request, nullptr,
79  	nano::transport::buffer_drop_policy::limiter, nano::transport::traffic_type::bootstrap);
80  }
81  std::size_t nano::bootstrap_ascending::service::priority_size () const
82  {
83  	nano::lock_guard<nano::mutex> lock{ mutex };
84  	return accounts.priority_size ();
85  }
86  std::size_t nano::bootstrap_ascending::service::blocked_size () const
87  {
88  	nano::lock_guard<nano::mutex> lock{ mutex };
89  	return accounts.blocked_size ();
90  }
91  std::size_t nano::bootstrap_ascending::service::score_size () const
92  {
93  	nano::lock_guard<nano::mutex> lock{ mutex };
94  	return scoring.size ();
95  }
96  void nano::bootstrap_ascending::service::inspect (nano::transaction const & tx, nano::process_return const & result, nano::block const & block)
97  {
98  	auto const hash = block.hash ();
99  	switch (result.code)
100  	{
101  		case nano::process_result::progress:
102  		{
103  			const auto account = ledger.account (tx, hash);
104  			const auto is_send = ledger.is_send (tx, block);
105  			accounts.unblock (account);
106  			accounts.priority_up (account);
107  			accounts.timestamp (account, &bsol;* reset timestamp */ true);
108  			if (is_send)
109  			{
110  				nano::account destination{ 0 };
111  				switch (block.type ())
112  				{
113  					case nano::block_type::send:
114  						destination = block.destination ();
115  						break;
116  					case nano::block_type::state:
117  						destination = block.link ().as_account ();
118  						break;
119  					default:
120  						debug_assert (false, "unexpected block type");
121  						break;
122  				}
123  				if (!destination.is_zero ())
124  				{
125  					accounts.unblock (destination, hash); 
126  					accounts.priority_up (destination);
127  				}
128  			}
129  		}
130  		break;
131  		case nano::process_result::gap_source:
132  		{
133  			const auto account = block.previous ().is_zero () ? block.account () : ledger.account (tx, block.previous ());
134  			const auto source = block.source ().is_zero () ? block.link ().as_block_hash () : block.source ();
135  			accounts.block (account, source);
136  		}
137  		break;
138  		case nano::process_result::old:
139  		{
140  		}
141  		break;
142  		case nano::process_result::gap_previous:
143  		{
144  		}
145  		break;
146  		default: 
147  			break;
148  	}
149  }
150  void nano::bootstrap_ascending::service::wait_blockprocessor ()
151  {
152  	nano::unique_lock<nano::mutex> lock{ mutex };
153  	while (!stopped && block_processor.half_full ())
154  	{
155  		condition.wait_for (lock, 500ms, [this] () { return stopped; }); 
156  	}
157  }
158  std::shared_ptr<nano::transport::channel> nano::bootstrap_ascending::service::wait_available_channel ()
159  {
160  	std::shared_ptr<nano::transport::channel> channel;
161  	nano::unique_lock<nano::mutex> lock{ mutex };
162  	while (!stopped && !(channel = scoring.channel ()))
163  	{
164  		condition.wait_for (lock, 100ms, [this] () { return stopped; });
165  	}
166  	return channel;
167  }
168  nano::account nano::bootstrap_ascending::service::available_account ()
169  {
170  	{
171  		auto account = accounts.next ();
172  		if (!account.is_zero ())
173  		{
174  			stats.inc (nano::stat::type::bootstrap_ascending, nano::stat::detail::next_priority);
175  			return account;
176  		}
177  	}
178  	if (database_limiter.should_pass (1))
179  	{
180  		auto account = iterator.next ();
181  		if (!account.is_zero ())
182  		{
183  			stats.inc (nano::stat::type::bootstrap_ascending, nano::stat::detail::next_database);
184  			return account;
185  		}
186  	}
187  	stats.inc (nano::stat::type::bootstrap_ascending, nano::stat::detail::next_none);
188  	return { 0 };
189  }
190  nano::account nano::bootstrap_ascending::service::wait_available_account ()
191  {
192  	nano::unique_lock<nano::mutex> lock{ mutex };
193  	while (!stopped)
194  	{
195  		auto account = available_account ();
196  		if (!account.is_zero ())
197  		{
198  			accounts.timestamp (account);
199  			return account;
200  		}
201  		else
202  		{
203  			condition.wait_for (lock, 100ms);
204  		}
205  	}
206  	return { 0 };
207  }
208  bool nano::bootstrap_ascending::service::request (nano::account & account, std::shared_ptr<nano::transport::channel> & channel)
209  {
210  	async_tag tag{};
211  	tag.id = nano::bootstrap_ascending::generate_id ();
212  	tag.account = account;
213  	tag.time = nano::milliseconds_since_epoch ();
214  	auto info = ledger.store.account.get (ledger.store.tx_begin_read (), account);
215  	if (info)
216  	{
217  		tag.type = async_tag::query_type::blocks_by_hash;
218  		tag.start = info->head;
219  	}
220  	else
221  	{
222  		tag.type = async_tag::query_type::blocks_by_account;
223  		tag.start = account;
224  	}
225  	on_request.notify (tag, channel);
226  	track (tag);
227  	send (channel, tag);
228  	return true; 
229  }
230  bool nano::bootstrap_ascending::service::run_one ()
231  {
232  	wait_blockprocessor ();
233  	auto account = wait_available_account ();
234  	if (account.is_zero ())
235  	{
236  		return false;
237  	}
238  	auto channel = wait_available_channel ();
239  	if (!channel)
240  	{
241  		return false;
242  	}
243  	bool success = request (account, channel);
244  	return success;
245  }
246  void nano::bootstrap_ascending::service::throttle_if_needed (nano::unique_lock<nano::mutex> & lock)
247  {
248  	debug_assert (lock.owns_lock ());
249  	if (!iterator.warmup () && throttle.throttled ())
250  	{
251  		stats.inc (nano::stat::type::bootstrap_ascending, nano::stat::detail::throttled);
252  		condition.wait_for (lock, std::chrono::milliseconds{ config.bootstrap_ascending.throttle_wait }, [this] () { return stopped; });
253  	}
254  }
255  void nano::bootstrap_ascending::service::run ()
256  {
257  	nano::unique_lock<nano::mutex> lock{ mutex };
258  	while (!stopped)
259  	{
260  		lock.unlock ();
261  		stats.inc (nano::stat::type::bootstrap_ascending, nano::stat::detail::loop);
262  		run_one ();
263  		lock.lock ();
264  		throttle_if_needed (lock);
265  	}
266  }
267  void nano::bootstrap_ascending::service::run_timeouts ()
268  {
269  	nano::unique_lock<nano::mutex> lock{ mutex };
270  	while (!stopped)
271  	{
272  		scoring.sync (network.list ());
273  		scoring.timeout ();
274  		throttle.resize (compute_throttle_size ());
275  		auto & tags_by_order = tags.get<tag_sequenced> ();
276  		while (!tags_by_order.empty () && nano::time_difference (tags_by_order.front ().time, nano::milliseconds_since_epoch ()) > config.bootstrap_ascending.timeout)
277  		{
278  			auto tag = tags_by_order.front ();
279  			tags_by_order.pop_front ();
280  			on_timeout.notify (tag);
281  			stats.inc (nano::stat::type::bootstrap_ascending, nano::stat::detail::timeout);
282  		}
283  		condition.wait_for (lock, 1s, [this] () { return stopped; });
284  	}
285  }
286  void nano::bootstrap_ascending::service::process (nano::asc_pull_ack const & message, std::shared_ptr<nano::transport::channel> channel)
287  {
288  	nano::unique_lock<nano::mutex> lock{ mutex };
289  	auto & tags_by_id = tags.get<tag_id> ();
290  	if (tags_by_id.count (message.id) > 0)
291  	{
292  		auto iterator = tags_by_id.find (message.id);
293  		auto tag = *iterator;
294  		tags_by_id.erase (iterator);
295  		scoring.received_message (channel);
296  		lock.unlock ();
297  		on_reply.notify (tag);
298  		condition.notify_all ();
299  		std::visit ([this, &tag] (auto && request) { return process (request, tag); }, message.payload);
300  	}
301  	else
302  	{
303  		stats.inc (nano::stat::type::bootstrap_ascending, nano::stat::detail::missing_tag);
304  	}
305  }
306  void nano::bootstrap_ascending::service::process (const nano::asc_pull_ack::blocks_payload & response, const nano::bootstrap_ascending::service::async_tag & tag)
307  {
308  	stats.inc (nano::stat::type::bootstrap_ascending, nano::stat::detail::reply);
309  	auto result = verify (response, tag);
310  	switch (result)
311  	{
312  		case verify_result::ok:
313  		{
314  			stats.add (nano::stat::type::bootstrap_ascending, nano::stat::detail::blocks, nano::stat::dir::in, response.blocks.size ());
315  			for (auto & block : response.blocks)
316  			{
317  				block_processor.add (block);
318  			}
319  			nano::lock_guard<nano::mutex> lock{ mutex };
320  			throttle.add (true);
321  		}
322  		break;
323  		case verify_result::nothing_new:
324  		{
325  			stats.inc (nano::stat::type::bootstrap_ascending, nano::stat::detail::nothing_new);
326  			nano::lock_guard<nano::mutex> lock{ mutex };
327  			accounts.priority_down (tag.account);
328  			throttle.add (false);
329  		}
330  		break;
331  		case verify_result::invalid:
332  		{
333  			stats.inc (nano::stat::type::bootstrap_ascending, nano::stat::detail::invalid);
334  		}
335  		break;
336  	}
337  }
338  void nano::bootstrap_ascending::service::process (const nano::asc_pull_ack::account_info_payload & response, const nano::bootstrap_ascending::service::async_tag & tag)
339  {
340  }
341  void nano::bootstrap_ascending::service::process (const nano::empty_payload & response, const nano::bootstrap_ascending::service::async_tag & tag)
342  {
343  	debug_assert (false, "empty payload");
344  }
345  nano::bootstrap_ascending::service::verify_result nano::bootstrap_ascending::service::verify (const nano::asc_pull_ack::blocks_payload & response, const nano::bootstrap_ascending::service::async_tag & tag) const
346  {
347  	auto const & blocks = response.blocks;
348  	if (blocks.empty ())
349  	{
350  		return verify_result::nothing_new;
351  	}
352  	if (blocks.size () == 1 && blocks.front ()->hash () == tag.start.as_block_hash ())
353  	{
354  		return verify_result::nothing_new;
355  	}
356  	auto const & first = blocks.front ();
357  	switch (tag.type)
358  	{
359  		case async_tag::query_type::blocks_by_hash:
360  		{
361  			if (first->hash () != tag.start.as_block_hash ())
362  			{
363  				return verify_result::invalid;
364  			}
365  		}
366  		break;
367  		case async_tag::query_type::blocks_by_account:
368  		{
369  			if (first->account () != tag.start.as_account ())
370  			{
371  				return verify_result::invalid;
372  			}
373  		}
374  		break;
375  		default:
376  			return verify_result::invalid;
377  	}
378  	nano::block_hash previous_hash = blocks.front ()->hash ();
379  	for (int n = 1; n < blocks.size (); ++n)
380  	{
381  		auto & block = blocks[n];
382  		if (block->previous () != previous_hash)
383  		{
384  			return verify_result::invalid; 
385  		}
386  		previous_hash = block->hash ();
387  	}
388  	return verify_result::ok;
389  }
390  void nano::bootstrap_ascending::service::track (async_tag const & tag)
391  {
392  	stats.inc (nano::stat::type::bootstrap_ascending, nano::stat::detail::track);
393  	nano::lock_guard<nano::mutex> lock{ mutex };
394  	debug_assert (tags.get<tag_id> ().count (tag.id) == 0);
395  	tags.get<tag_id> ().insert (tag);
396  }
397  auto nano::bootstrap_ascending::service::info () const -> nano::bootstrap_ascending::account_sets::info_t
398  {
399  	nano::lock_guard<nano::mutex> lock{ mutex };
400  	return accounts.info ();
401  }
402  std::size_t nano::bootstrap_ascending::service::compute_throttle_size () const
403  {
404  	std::size_t size_new = config.bootstrap_ascending.throttle_coefficient * std::sqrt (ledger.cache.block_count.load ());
405  	return size_new == 0 ? 16 : size_new;
406  }
407  std::unique_ptr<nano::container_info_component> nano::bootstrap_ascending::service::collect_container_info (std::string const & name)
408  {
409  	nano::lock_guard<nano::mutex> lock{ mutex };
410  	auto composite = std::make_unique<container_info_composite> (name);
411  	composite->add_component (std::make_unique<container_info_leaf> (container_info{ "tags", tags.size (), sizeof (decltype (tags)::value_type) }));
412  	composite->add_component (accounts.collect_container_info ("accounts"));
413  	return composite;
414  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-atomic_hook.h</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-service.cpp</div>
                <div class="column column_space"><pre><code>33    constexpr AtomicHook() : AtomicHook(DummyFunction) {}
34  #if ABSL_HAVE_WORKING_ATOMIC_POINTER && ABSL_HAVE_WORKING_CONSTEXPR_STATIC_INIT
35    explicit constexpr AtomicHook(FnPtr default_fn)
36        : hook_(default_fn), default_fn_(default_fn) {}
37  #elif ABSL_HAVE_WORKING_CONSTEXPR_STATIC_INIT
38    explicit constexpr AtomicHook(FnPtr default_fn)
39        : hook_(kUninitialized), default_fn_(default_fn) {}
40  #else
41    explicit constexpr AtomicHook(FnPtr default_fn)
42        : &bsol;* hook_(deliberately omitted), */ default_fn_(default_fn) {
43      static_assert(kUninitialized == 0, "here we rely on zero-initialization");
44    }
45  #endif
46    void Store(FnPtr fn) {
</pre></code></div>
                <div class="column column_space"><pre><code>12  	config{ config_a },
13  	network_consts{ config.network_params.network },
14  	block_processor{ block_processor_a },
15  	ledger{ ledger_a },
16  	network{ network_a },
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    