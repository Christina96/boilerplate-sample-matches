
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 31, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-svmmodels.cpp</h3>
            <pre><code>1  void TCrossValid::PrepareFolds(const int& Folds, TIntV& DIdV,
2          const int& Seed, TVec<TIntV>& DIdVFoldV) {
3      IAssert(Folds > 1);
4      IAssertR(DIdV.Len()/Folds > 1,
5          TStr::Fmt("To little documents per fold (%d/%d)", DIdV.Len(), Folds));
6      DIdVFoldV.Gen(Folds);
7      const int Len = DIdV.Len();
8      for (int FoldN = 0; FoldN < Folds; FoldN++)
9          DIdVFoldV[FoldN].Gen(Len/Folds, 0);
10      int DocN = 0;
11      TRnd Rnd(Seed); DIdV.Shuffle(Rnd);
12      while (DocN < Len) {
13          int FoldN = 0;
14          while (DocN < Len && FoldN < Folds) {
15              DIdVFoldV[FoldN].Add(DIdV[DocN]);
16              FoldN++; DocN++;
17          }
18      }
19      DIdV.Sort();
20      for (int FoldN = 0; FoldN < Folds; FoldN++) {
21          DIdVFoldV[FoldN].Sort();
22      }
23  }
24  void TCrossValid::PrepareSplit(const int& FoldN, const TVec<TIntV>& DIdVFoldV,
25                                 TIntV& TrainSubDIdV, TIntV& TestSubDIdV) {
26      TrainSubDIdV.Clr(); TestSubDIdV.Clr();
27      for (int n = 0; n < DIdVFoldV.Len(); n++) {
28          if (n == FoldN) {
29              TestSubDIdV.AddV(DIdVFoldV[n]);
30          } else {
31              TrainSubDIdV.AddV(DIdVFoldV[n]);
32          }
33      }
34      TrainSubDIdV.Sort(); TestSubDIdV.Sort();
35  }
36  void TCrossValid::PrepareSubDIdV(const TIntV& SubSet, const int& DataSetLen, TIntV& DIdV) {
37      if (SubSet.Empty()) {
38          DIdV.Gen(DataSetLen, 0);
39          for (int i = 0; i < DataSetLen; i++) DIdV.Add(i);
40      } else {
41          DIdV = SubSet;
42      }
43  }
44  bool TSparseTrainSet::IsReg=TSparseTrainSet::MkReg();
45  TSparseTrainSet::TSparseTrainSet(const TIntV& VecIdV, const int& _MaxDim, const TFltV& _ClsV,
46          const TFltV& _NormV, const TVec<TIntFltKdV>& _TrainV): TSVMTrainSet(ststSparse) {
47      if (VecIdV.Empty()) {
48          MaxDim = _MaxDim; ClsV = _ClsV;
49          NormV = _NormV; TrainV = _TrainV;
50      } else {
51          MaxDim = _MaxDim;
52          const int Vecs = VecIdV.Len();
53          ClsV.Gen(Vecs, 0); NormV.Gen(Vecs, 0); TrainV.Gen(Vecs, 0);
54          for (int VecN = 0; VecN < Vecs; VecN++) {
55              const int VecId = VecIdV[VecN];
56              ClsV.Add(_ClsV[VecId]);
57              NormV.Add(_NormV[VecId]);
58              TrainV.Add(_TrainV[VecId]);
59          }
60      }
61  }
62  void TSparseTrainSet::SaveTxt(const TStr& OutFNm) const {
63      PSOut SOut = TFOut::New(OutFNm);
64      for (int VecN = 0; VecN < TrainV.Len(); VecN++) {
65          const TIntFltKdV& AttrV = TrainV[VecN];
66          SOut->PutStr(TStr::Fmt("%f", GetVecParam(VecN)));
67          for (int a = 0; a < AttrV.Len(); a++) {
68              SOut->PutStr(TStr::Fmt(" %d:%f", AttrV[a].Key(), AttrV[a].Dat()));
69          }
70          SOut->PutLn();
71      }
72      SOut->Flush();
73  }
74  void TSparseTrainSet::SaveMatlab(const TStr& FName) const {
75      PSOut out = TFOut::New(FName);
76      int ColN = Len();
77      for (int ColId = 0; ColId < ColN; ColId++) {
78          const TIntFltKdV& Vec = TrainV[ColId];
79          for (int RowId = 0, RowN = Vec.Len(); RowId < RowN; RowId++) {
80              out->PutStr(TInt::GetStr(Vec[RowId].Key + 1) + TStr(" ") + TInt::GetStr(ColId + 1) + TStr(" "));
81              out->PutStr(TFlt::GetStr(Vec[RowId].Dat, 20, 18));
82              out->PutCh('\n');
83          }
84      }
85  }
86  double TSparseTrainSet::DotProduct(const int& VecId1, double* vec2, const int& n) const {
87      double Res = 0.0;
88      const TIntFltKdV& V1 = TrainV[VecId1];
89      for (int i = 0; i < V1.Len(); i++) {
90          const int key = V1[i].Key;
91          if (key < n) Res += V1[i].Dat * vec2[key];
92      }
93      return Res;
94  }
95  void TSparseTrainSet::AddVec(const int& VecId1, double* vec2,
96          const int& n, const double& K) const {
97      const TIntFltKdV& V1 = TrainV[VecId1];
98      for (int i = 0; i < V1.Len(); i++) {
99          Assert(V1[i].Key < n);
100          vec2[V1[i].Key] += K * V1[i].Dat;
101      }
102  }
103  int TSparseTrainSet::AddAttrV(const TIntFltKdV& AttrV,
104          const double& Cls, const bool& Normalize) {
105      double Norm = TLinAlg::Norm2(AttrV);
106      IAssertR(Norm >= 0.0, TStr::Fmt("%g (len = %d)", Norm, AttrV.Len()));
107      NormV.Add(Norm); TrainV.Add(AttrV); TrainV.Last().Pack(); ClsV.Add(Cls);
108      if (AttrV.Empty()) {
109          TrainV.Last().Add(TIntFltKd(1, 0.0));
110      } else {
111          MaxDim = TInt::GetMx(int(MaxDim), AttrV.Last().Key+1);
112          if (Normalize) { TLinAlg::Normalize(TrainV.Last()); }
113      }
114      return TrainV.Len()-1;
115  }
116  void TSparseTrainSet::Shuffle(TRnd& Rnd) {
117      const int Vals = TrainV.Len();
118      for (int ValN=0; ValN<Vals-1; ValN++) {
119          const int NewValN = ValN+Rnd.GetUniDevInt(Vals-ValN);
120          TrainV.Swap(ValN, NewValN);
121          ClsV.Swap(ValN, NewValN);
122          NormV.Swap(ValN, NewValN);
123      }
124  }
125  PSVMTrainSet TSparseTrainSet::LoadTxt(PSIn SIn, const bool& Normalize, const int& verbosity) {
126      TMem buffer;
127      TMem::LoadMem(SIn, buffer);
128      if (buffer[buffer.Len()-1] != '\n') buffer += '\n';  
129      int len = buffer.Len(), n = 0;
130      char ch, *s; int vecsP = 0, vecsM = 0, line = 0;
131      double cls; TIntFltKdV vec;
132      PSVMTrainSet docs = TSparseTrainSet::New();
133      if (len == 0) return docs;
134      ch = buffer[n++];
135      while (n < len) {
136          line++;
137          vec.Clr(false);
138          if (ch != '#') {
139              while (ch == ' ') ch = buffer[n++]; 
140              TChA clsChA;
141              while (ch != ' ' && ch != '\r' && ch != '\n') {
142                  clsChA += ch;
143                  ch = buffer[n++];
144              }
145              if (clsChA.Len() > 0) {
146                  cls = strtod(clsChA.CStr(), &s);
147                  int part = 0;
148                  TChA idChA, valChA;
149                  while (ch != '\r' && ch != '\n' && ch != '#') {
150                      if (part == 0 && ch == ' ') {
151                      } else if (part == 0 && ch != ' ') {
152                          part = 1;     
153                          Assert('0' <= ch && ch <= '9');
154                          idChA += ch;
155                      } else if (part == 1 && ch != ':') {
156                          Assert('0' <= ch && ch <= '9');
157                          idChA += ch;  
158                      } else if (part == 1 && ch == ':') {
159                          part = 2;     
160                      } else if (part == 2 && ch != ' ') {
161                          Assert(('0' <= ch && ch <= '9') || ch == '.');
162                          valChA += ch; 
163                      } else if (part == 2 && ch == ' ') {
164                          int id = strtol(idChA.CStr(), &s, 10);
165                          double val = strtod(valChA.CStr(), &s);
166                          vec.Add(TIntFltKd(id, val));
167                          idChA.Clr(); valChA.Clr();
168                          part = 0;
169                      } else {
170                          printf("error in %d, unexpected charater %c!\n", line, ch);
171                          Assert(false);
172                      }
173                      ch = buffer[n++];
174                      if (part == 2 && (ch == '\r' || ch == '\n' || ch == '#')) {
175                          int id = strtol(idChA.CStr(), &s, 10);
176                          double val = strtod(valChA.CStr(), &s);
177                          vec.Add(TIntFltKd(id, val));
178                          idChA.Clr(); valChA.Clr();
179                          part = 0;
180                      }
181                  } 
182                  if (part != 0) printf("unexpected end of line %d\n", line);
183                  Assert(part == 0); 
184                  docs->AddAttrV(vec, cls, Normalize);
185                  if (cls > 0) vecsP++;
186                  else vecsM++;
187                  if (verbosity > 0 && (vecsP + vecsM)%100 == 0) printf("%d\r", vecsP + vecsM);
188                  while (ch != '\n') ch = buffer[n++]; 
189              }
190          } else {
191              while (ch != '\n') ch = buffer[n++];
192          }
193          if (n < len) ch = buffer[n++];
194      }
195      printf("\n");
196      if (verbosity > 1)
197          printf("\ninput: %d = %d + %d vectors\n", vecsP + vecsM, vecsP, vecsM);
198      else if (verbosity > 0)
199          printf("\n");
200      return docs;
201  }
202  bool TDenseTrainSet::IsReg=TDenseTrainSet::MkReg();
203  TDenseTrainSet::TDenseTrainSet(const TIntV& VecIdV, const int& _MaxDim, const TFltV& _ClsV,
204          const TFltV& _NormV, const TVec<TFltV>& _TrainV): TSVMTrainSet(ststDense) {
205      if (VecIdV.Empty()) {
206          MaxDim = _MaxDim; ClsV = _ClsV;
207          NormV = _NormV; TrainV = _TrainV;
208      } else {
209          MaxDim = _MaxDim;
210          const int Vecs = VecIdV.Len();
211          ClsV.Gen(Vecs, 0); NormV.Gen(Vecs, 0); TrainV.Gen(Vecs, 0);
212          for (int VecN = 0; VecN < Vecs; VecN++) {
213              const int VecId = VecIdV[VecN];
214              ClsV.Add(_ClsV[VecId]);
215              NormV.Add(_NormV[VecId]);
216              TrainV.Add(_TrainV[VecId]);
217          }
218      }
219  }
220  PSVMTrainSet TDenseTrainSet::LoadFromSparse(PSVMTrainSet SparseSet) {
221      const int Vecs = SparseSet->Len();
222      const int Dims = SparseSet->Dim();
223      PSVMTrainSet DenseSet = TDenseTrainSet::New(Vecs);
224      TFltV AttrDenseV(Dims);
225      for (int VecN = 0; VecN < SparseSet->Len(); VecN++) {
226          const TIntFltKdV& AttrSparseV = SparseSet->GetAttrSparseV(VecN);
227          AttrDenseV.PutAll(0.0);
228          TLinAlg::AddVec(1.0, AttrSparseV, AttrDenseV);
229          DenseSet->AddAttrV(AttrDenseV, SparseSet->GetVecParam(VecN), false);
230      }
231      return DenseSet;
232  }
233  void TDenseTrainSet::SaveTxt(const TStr& OutFNm) const {
234      PSOut SOut = TFOut::New(OutFNm);
235      for (int VecN = 0; VecN < TrainV.Len(); VecN++) {
236          const TFltV& AttrV = TrainV[VecN];
237          SOut->PutStr(TStr::Fmt("%f", GetVecParam(VecN)));
238          for (int a = 0; a < AttrV.Len(); a++) {
239              SOut->PutStr(TStr::Fmt(" %d:%f", a+1, AttrV[a]()));
240          }
241          SOut->PutLn();
242      }
243      SOut->Flush();
244  }
245  int TDenseTrainSet::AddAttrV(const TFltV& AttrV, const double& Cls, const bool& Normalize) {
246      IAssert(!AttrV.Empty());
247      IAssert(MaxDim == 0 || AttrV.Len() == MaxDim);
248      MaxDim = AttrV.Len();
249      double Norm = TLinAlg::Norm2(AttrV); NormV.Add(Norm);
250      TrainV.Add(AttrV); TrainV.Last().Pack(); ClsV.Add(Cls);
251      if (Normalize) { TLinAlg::Normalize(TrainV.Last()); }
252      return TrainV.Len()-1;
253  }
254  double TDenseTrainSet::DotProduct(const int& VecId1, double* vec2, const int& n) const {
255      IAssert(n == MaxDim);
256      const TFltV& V1 = TrainV[VecId1];
257      double Res = V1[0]*vec2[0];
258      for (int i = 1; i < MaxDim; i++)
259          Res += V1[i]*vec2[i];
260      return Res;
261  }
262  void TDenseTrainSet::AddVec(const int& VecId1, double* vec2,
263                              const int& n, const double& K) const {
264      IAssert(n == MaxDim);
265      const TFltV& V1 = TrainV[VecId1];
266      for (int i = 0; i < MaxDim; i++)
267          vec2[i] += K*V1[i];
268  }
269  void TDenseTrainSet::Shuffle(TRnd& Rnd) {
270      const int Vals = TrainV.Len();
271      for (int ValN=0; ValN<Vals-1; ValN++) {
272          const int NewValN = ValN+Rnd.GetUniDevInt(Vals-ValN);
273          TrainV.Swap(ValN, NewValN);
274          ClsV.Swap(ValN, NewValN);
275          NormV.Swap(ValN, NewValN);
276      }
277  }
278  PSVMTrainSet TDenseTrainSet::ProjectLin(PSVMTrainSet Set,
279          const TFltVV& Basis, const bool& Normalize, const int& NewDim) {
280      IAssert(NewDim == -1 || (NewDim >= 0 && NewDim <= Basis.GetYDim()));
281      const int Dim = (NewDim == -1) ? Basis.GetYDim() : NewDim; 
282      const int Len = Basis.GetXDim();
283      TVec<TFltV> NewBasis(Dim);
284      for (int VecC = 0; VecC < Dim; VecC++) {
285          NewBasis[VecC].Gen(Len,0);
286          for (int i = 0; i < Len; i++) {
287              NewBasis[VecC].Add(Basis(i, VecC));
288          }
289      }
290      return ProjectLin(Set, NewBasis, Normalize);
291  }
292  PSVMTrainSet TDenseTrainSet::ProjectLin(PSVMTrainSet Set,
293          const TVec<TFltV>& Basis, const bool& Normalize, const int& NewDim) {
294      IAssert(NewDim == -1 || (NewDim >= 0 && NewDim <= Basis.Len()));
295      const int VecN = Set->Len(); 
296      const int Dim = (NewDim == -1) ? Basis.Len() : NewDim; 
297      PSVMTrainSet NewSet = TDenseTrainSet::New(VecN);
298      for (int VecC = 0; VecC < VecN; VecC++) {
299          if (VecC % 100 == 0) printf("%d\r", VecC);
300          TFltV Vec(Dim, 0);
301          for (int i = 0; i < Dim; i++) {
302              Vec.Add(Set->DotProduct(VecC, Basis[i]));
303          }
304          NewSet->AddAttrV(Vec, Set->GetVecParam(VecC), Normalize);
305      }
306      printf("\n");
307      return NewSet;
308  }
309  bool TBowTrainSet::IsReg=TBowTrainSet::MkReg();
310  TBowTrainSet::TBowTrainSet(const TIntV& VecIdV, const int& _MaxDim, const TIntV& _DIdV,
311          const TVec<PBowSpV>& _TrainV, const TFltV& _ClsV): TSVMTrainSet(ststBow) {
312      if (VecIdV.Empty()) {
313          MaxDim = _MaxDim; DIdV = _DIdV;
314          TrainV = _TrainV; ClsV = _ClsV;
315      } else {
316          MaxDim = _MaxDim;
317          const int Vecs = VecIdV.Len();
318          DIdV.Gen(Vecs, 0); TrainV.Gen(Vecs, 0); ClsV.Gen(Vecs, 0);
319          for (int VecN = 0; VecN < Vecs; VecN++) {
320              const int VecId = VecIdV[VecN];
321              DIdV.Add(_DIdV[VecId]);
322              TrainV.Add(_TrainV[VecId]);
323              ClsV.Add(_ClsV[VecId]);
324          }
325      }
326  }
327  void TBowTrainSet::SaveTxt(const TStr& OutFNm) const {
328      PSOut SOut = TFOut::New(OutFNm);
329      for (int VecN = 0; VecN < TrainV.Len(); VecN++) {
330          PBowSpV AttrV = TrainV[VecN];
331          SOut->PutStr(TStr::Fmt("%f", GetVecParam(VecN)));
332          for (int a = 0; a < AttrV->Len(); a++) {
333              SOut->PutStr(TStr::Fmt(" %d:%f", AttrV->GetWId(a), AttrV->GetWgt(a).Val));
334          }
335          SOut->PutLn();
336      }
337      SOut->Flush();
338  }
339  double TBowTrainSet::DotProduct(const int& VecId1, double* vec2, const int& n) const {
340      double res = 0.0;
341      TBowWIdWgtKd* vec1 = TrainV[VecId1]->BegI();
342      int len1 = TrainV[VecId1]->Len();
343      for (int i = 0; i < len1; i++) {
344          Assert(vec1[i].Key < n);
345          res += vec2[vec1[i].Key] * vec1[i].Dat;
346      }
347      return res;
348  }
349  void TBowTrainSet::AddVec(const int& VecId1, double* vec2,
350                            const int& n, const double& K) const {
351      TBowWIdWgtKd* vec1 = TrainV[VecId1]->BegI();
352      int len1 = TrainV[VecId1]->Len();
353      for (int i = 0; i < len1; i++) {
354          Assert(vec1[i].Key < n);
355          vec2[vec1[i].Key] += K * vec1[i].Dat;
356      }
357  }
358  void TBowTrainSet::AddVec(const int& VecId1, TFltV& vec2, const double& K) const {
359      PBowSpV vec1 = TrainV[VecId1]; int len1 = vec1->Len();
360      for (int i = 0; i < len1; i++) {
361          Assert(vec1->GetWId(i) < vec2.Len());
362          vec2[vec1->GetWId(i)] += K * vec1->GetWgt(i);
363      }
364  }
365  int TBowTrainSet::AddAttrV(const int& DId, PBowSpV SpVec, const double& Cls) {
366      DIdV.Add(DId); TrainV.Add(SpVec); ClsV.Add(Cls);
367      if (SpVec->GetWIds() > 0) {
368          int VecDim = SpVec->GetWId(SpVec->GetWIds()-1);
369          MaxDim = MaxDim > VecDim ? MaxDim() : VecDim + 1;
370      }
371      return TrainV.Len()-1;
372  }
373  void TBowTrainSet::Shuffle(TRnd& Rnd) {
374      const int Vals = TrainV.Len();
375      for (int ValN=0; ValN<Vals-1; ValN++) {
376          const int NewValN = ValN+Rnd.GetUniDevInt(Vals-ValN);
377          DIdV.Swap(ValN, NewValN);
378          TrainV.Swap(ValN, NewValN);
379          ClsV.Swap(ValN, NewValN);
380      }
381  }
382  bool TStringTrainSet::IsReg=TStringTrainSet::MkReg();
383  void TStringTrainSet::UpdateAlphN(const TIntV& Vec) {
384      for (int i = 0, l = Vec.Len(); i < l; i++)
385          AlphN = TInt::GetMx(AlphN, Vec[i]+1);
386      StrKer->UpdateAlphN(AlphN);
387  }
388  TStringTrainSet::TStringTrainSet(const TIntV& VecIdV, const TFltV& _ClsV,
389          const TFltV& _NormV, const TVec<TIntV>& _TrainV, PStrParser _Parser,
390          const int& _AlphN, PStringKernel _StrKer): TSVMTrainSet(ststString) {
391      if (VecIdV.Empty()) {
392          ClsV = _ClsV; NormV = _NormV; TrainV = _TrainV;
393          Parser = _Parser; AlphN = _AlphN; StrKer = _StrKer;
394      } else {
395          const int Vecs = VecIdV.Len();
396          ClsV.Gen(Vecs, 0); NormV.Gen(Vecs, 0); TrainV.Gen(Vecs, 0);
397          for (int VecN = 0; VecN < Vecs; VecN++) {
398              const int VecId = VecIdV[VecN];
399              ClsV.Add(_ClsV[VecId]);
400              NormV.Add(_NormV[VecId]);
401              TrainV.Add(_TrainV[VecId]);
402          }
403          Parser = _Parser; AlphN = _AlphN; StrKer = _StrKer;
404      }
405      printf("AlphN = [%d => %d]\n", _AlphN, AlphN.Val);
406  }
407  int TStringTrainSet::AddAttrV(const TStr& AttrV, const double& Cls) {
408      TIntV ParsedAttrV; Parser->ProcessDocStr(AttrV, ParsedAttrV);
409      return AddAttrV(ParsedAttrV, Cls);
410  }
411  int TStringTrainSet::AddAttrV(const TIntV& AttrV, const double& Cls) {
412      IAssert(!AttrV.Empty());
413      UpdateAlphN(AttrV);
414      const double Norm = StrKer->CalcKernel(AttrV, AttrV);
415      ClsV.Add(Cls); NormV.Add(Norm);
416      TrainV.Add(AttrV); TrainV.Last().Pack();
417      return TrainV.Len()-1;
418  }
419  double TStringTrainSet::DotProduct(const int& VecId1, const TStr& Vec2) const {
420      TIntV ParsedVec2; Parser->ProcessDocStr(Vec2, ParsedVec2);
421      return DotProduct(VecId1, ParsedVec2);
422  }
423  double TStringTrainSet::DotProduct(const int& VecId1, const TIntV& Vec2) const {
424      const double Norm = StrKer->CalcKernel(Vec2, Vec2);
425      return StrKer->CalcKernel(TrainV[VecId1],Vec2) / sqrt(NormV[VecId1]*Norm);
426  }
427  void TStringTrainSet::Shuffle(TRnd& Rnd) {
428      const int Vals = TrainV.Len();
429      for (int ValN=0; ValN<Vals-1; ValN++) {
430          const int NewValN = ValN+Rnd.GetUniDevInt(Vals-ValN);
431          TrainV.Swap(ValN, NewValN);
432          ClsV.Swap(ValN, NewValN);
433          NormV.Swap(ValN, NewValN);
434      }
435  }
436  TSimMatrixTrainSet::TSimMatrixTrainSet(const TIntV& VecIdV,
437          const TFltV& _ClsV, const TFltVV& _SimMatrix): TSVMTrainSet(ststSimMatrix) {
438      const int Vecs = VecIdV.Len();
439      SimMatrix.Gen(Vecs, Vecs); ClsV.Gen(Vecs, 0);
440      for (int i = 0; i < Vecs; i++) {
441          const int VecId1 = VecIdV[i];
442          ClsV.Add(_ClsV[VecId1]);
443          for (int j = 0; j < Vecs; j++) {
444              const int VecId2 = VecIdV[j];
445              SimMatrix(i, j) = _SimMatrix(VecId1, VecId2);
446          }
447      }
448  }
449  TSimMatrixTrainSet::TSimMatrixTrainSet(const TFltVV& _SimMatrix,
450          const TFltV& _ClsV): TSVMTrainSet(ststSimMatrix), SimMatrix(_SimMatrix) {
451      if (_ClsV.Empty()) {
452          ClsV.Gen(SimMatrix.GetXDim());
453          ClsV.PutAll(0.0);
454      } else {
455          ClsV = _ClsV;
456          Assert(ClsV.Len() == SimMatrix.GetXDim());
457      }
458  }
459  void TBowDocBs2TrainSet::MakeSpVec(PBowSpV BowVec, TIntFltKdV& SpVec) {
460      const int BowVecLen = BowVec->GetWIds(); SpVec.Gen(BowVecLen, 0);
461      for (int WgtC = 0, WgtN = BowVecLen; WgtC < WgtN; WgtC++) {
462          SpVec.Add(TIntFltKd(BowVec->GetWId(WgtC), BowVec->GetWgt(WgtC).Val));
463      }
464  }
465  PSVMTrainSet TBowDocBs2TrainSet::NewBowNoCat(
466          const TVec<PBowSpV>& BowSpV, const double& DefParam) {
467      int DocN = BowSpV.Len();
468      PSVMTrainSet docs = TBowTrainSet::New(DocN);
469      for (int DocC = 0; DocC < DocN; DocC++) {
470          docs->AddAttrV(DocC, BowSpV[DocC], DefParam);
471      }
472      return docs;
473  }
474  PSVMTrainSet TBowDocBs2TrainSet::NewBowNoCat(PBowDocWgtBs BowDocWgtBs,
475          const TIntV& DIdV, const double& DefParam) {
476      int DocN = DIdV.Len();
477      PSVMTrainSet docs = TBowTrainSet::New(DocN);
478      for (int DocC = 0; DocC < DocN; DocC++) {
479          int DId = DIdV[DocC];
480          PBowSpV SpV = BowDocWgtBs->GetSpV(DId);
481          docs->AddAttrV(DId, SpV, DefParam);
482      }
483      return docs;
484  }
485  PSVMTrainSet TBowDocBs2TrainSet::NewSparseNoCat(
486          const TVec<PBowSpV>& BowSpV, const double& DefParam) {
487      int DocN = BowSpV.Len();
488      PSVMTrainSet Set = TSparseTrainSet::New(DocN); TIntFltKdV SpVec;
489      for (int DocC = 0; DocC < DocN; DocC++) {
490          MakeSpVec(BowSpV[DocC], SpVec);
491          Set->AddAttrV(SpVec, DefParam, false);
492      }
493      return Set;
494  }
495  PSVMTrainSet TBowDocBs2TrainSet::NewSparseNoCat(PBowDocWgtBs BowDocWgtBs,
496          const TIntV& DIdV, const double& DefParam) {
497      int DocN=DIdV.Len();
498      PSVMTrainSet Set = TSparseTrainSet::New(DocN); TIntFltKdV SpVec;
499      for (int DocC = 0; DocC < DocN; DocC++) {
500          int DId = DIdV[DocC];
501          MakeSpVec(BowDocWgtBs->GetSpV(DId), SpVec);
502          Set->AddAttrV(SpVec, DefParam, false);
503      }
504      return Set;
505  }
506  PSVMTrainSet TBowDocBs2TrainSet::NewBowOneCat(const PBowDocBs& BowDocBs,
507          PBowDocWgtBs BowDocWgtBs, const int& CatId, const TIntV& DIdV) {
508      int DocN = DIdV.Len();
509      PSVMTrainSet docs = TBowTrainSet::New(DocN);
510      for (int DocC = 0; DocC < DocN; DocC++) {
511          int DId = DIdV[DocC];
512          if (BowDocBs->IsCatInDoc(DId, CatId)) {
513              PBowSpV SpV = BowDocWgtBs->GetSpV(DId);
514              docs->AddAttrV(DId, SpV, 1.0);
515          }
516      }
517      return docs;
518  }
519  PSVMTrainSet TBowDocBs2TrainSet::NewSparseOneCat(const PBowDocBs& BowDocBs,
520          PBowDocWgtBs BowDocWgtBs, const int& CatId, const TIntV& DIdV) {
521      int DocN=DIdV.Len();
522      PSVMTrainSet Set = TSparseTrainSet::New(DocN); TIntFltKdV SpVec;
523      for (int DocC = 0; DocC < DocN; DocC++) {
524          int DId = DIdV[DocC];
525          if (BowDocBs->IsCatInDoc(DId, CatId)) {
526              MakeSpVec(BowDocWgtBs->GetSpV(DId), SpVec);
527              Set->AddAttrV(SpVec, 1.0, false);
528          }
529      }
530      return Set;
531  }
532  PSVMTrainSet TBowDocBs2TrainSet::NewStringOneCat(const PBowDocBs& BowDocBs,
533          const int& CatId, const TIntV& DIdV, PStrParser Parser, PStringKernel StrKer) {
534      int DocN=DIdV.Len();
535      PSVMTrainSet Set = TStringTrainSet::New(Parser, StrKer, DocN); TIntFltKdV SpVec;
536      for (int DocC = 0; DocC < DocN; DocC++) {
537          int DId = DIdV[DocC];
538          if (BowDocBs->IsCatInDoc(DId, CatId)) {
539              TStr DocStr = BowDocBs->GetDocStr(DId);
540              Set->AddAttrV(DocStr, 1.0);
541          }
542      }
543      return Set;
544  }
545  PSVMTrainSet TBowDocBs2TrainSet::NewBowAllCat(const PBowDocBs& BowDocBs,
546          PBowDocWgtBs BowDocWgtBs, const int& CatId, const TIntV& DIdV,
547          const double& SampleNegP) {
548      int Docs = DIdV.Len();
549      TIntV PosDIdV, NegDIdV;
550      for (int DocN = 0; DocN < Docs; DocN++) {
551          const int DId = DIdV[DocN];
552          if(BowDocBs->IsCatInDoc(DId, CatId)) {
553              PosDIdV.Add(DId);
554          } else {
555              NegDIdV.Add(DId);
556          }
557      }
558      const int SampleSize = TFlt::Round(PosDIdV.Len() * SampleNegP);
559      if ((SampleSize > 0) && (NegDIdV.Len() > SampleSize)) {
560          TRnd Rnd(1); NegDIdV.Shuffle(Rnd); NegDIdV.Trunc(SampleSize);
561      }
562      PSVMTrainSet docs = TBowTrainSet::New(NegDIdV.Len() + PosDIdV.Len());
563      for (int PosDocN = 0; PosDocN < PosDIdV.Len(); PosDocN++) {
564          const int DId = PosDIdV[PosDocN]; docs->AddAttrV(DId, BowDocWgtBs->GetSpV(DId), 1.0); }
565      for (int NegDocN = 0; NegDocN < NegDIdV.Len(); NegDocN++) {
566          const int DId = NegDIdV[NegDocN]; docs->AddAttrV(DId, BowDocWgtBs->GetSpV(DId), -1.0); }
567      return docs;
568  }
569  PSVMTrainSet TBowDocBs2TrainSet::NewSparseAllCat(const PBowDocBs& BowDocBs,
570          PBowDocWgtBs BowDocWgtBs, const int& CatId, const TIntV& DIdV) {
571      int DocN = DIdV.Len();
572      PSVMTrainSet Set = TSparseTrainSet::New(DocN); TIntFltKdV SpVec;
573      for (int DocC = 0; DocC < DocN; DocC++) {
574          int DId = DIdV[DocC];
575          double param = BowDocBs->IsCatInDoc(DId, CatId) ? 1.0 : -1.0;
576          MakeSpVec(BowDocWgtBs->GetSpV(DId), SpVec);
577          Set->AddAttrV(SpVec, param, false);
578      }
579      return Set;
580  }
581  PSVMTrainSet TBowDocBs2TrainSet::NewStringAllCat(const PBowDocBs& BowDocBs,
582          const int& CatId, const TIntV& DIdV, PStrParser Parser, PStringKernel StrKer) {
583      int DocN = DIdV.Len();
584      PSVMTrainSet Set = TStringTrainSet::New(Parser, StrKer, DocN); TIntFltKdV SpVec;
585      for (int DocC = 0; DocC < DocN; DocC++) {
586          int DId = DIdV[DocC];
587          double DocParam = BowDocBs->IsCatInDoc(DId, CatId) ? 1.0 : -1.0;
588          TStr DocStr = BowDocBs->GetDocStr(DId);
589          Set->AddAttrV(DocStr, DocParam);
590      }
591      return Set;
592  }
593  PSVMTrainSet TBowDocBs2TrainSet::NewBowAllCatV(PBowDocWgtBs BowDocWgtBs,
594          const TIntV& AllDIdV, const TIntV& CatDIdV) {
595      int DocN = AllDIdV.Len();
596      PSVMTrainSet docs = TBowTrainSet::New(DocN);
597      for (int DocC = 0; DocC < DocN; DocC++) {
598          int DId = AllDIdV[DocC];
599          double param = CatDIdV.SearchBin(DId) == -1 ? -1.0 : 1.0;
600          PBowSpV SpV = BowDocWgtBs->GetSpV(DId);
601          docs->AddAttrV(DId, SpV, param);
602      }
603      return docs;
604  }
605  PSVMTrainSet TBowDocBs2TrainSet::NewSparseAllCatV(PBowDocWgtBs BowDocWgtBs,
606          const TIntV& AllDIdV, const TIntV& CatDIdV) {
607      int DocN = AllDIdV.Len();
608      PSVMTrainSet Set = TSparseTrainSet::New(DocN); TIntFltKdV SpVec;
609      for (int DocC = 0; DocC < DocN; DocC++) {
610          int DId = AllDIdV[DocC];
611          double param = CatDIdV.SearchBin(DId) == -1 ? -1.0 : 1.0;
612          MakeSpVec(BowDocWgtBs->GetSpV(DId), SpVec);
613          Set->AddAttrV(SpVec, param, false);
614      }
615      return Set;
616  }
617  PSVMTrainSet TBowDocBs2TrainSet::NewBowFromCat(const PBowDocBs& BowDocBs,
618          PBowDocWgtBs BowDocWgtBs, const TIntV& AllDIdV) {
619      Fail; return NULL;
620  }
621  PSVMTrainSet TBowDocBs2TrainSet::NewSparseFromCat(const PBowDocBs& BowDocBs,
622          PBowDocWgtBs BowDocWgtBs, const TIntV& AllDIdV) {
623      Fail; return NULL;
624  }
625  PSVMTrainSet TBowDocBs2TrainSet::NewBow(PBowDocPart BowDocPart) {
626      int Clusts = BowDocPart->GetClusts();
627      PSVMTrainSet Set = TBowTrainSet::New(Clusts);
628      for (int ClustN = 0; ClustN < Clusts; ClustN++) {
629          IAssert(BowDocPart->GetClust(ClustN)->IsConceptSpV());
630          Set->AddAttrV(ClustN, BowDocPart->GetClust(ClustN)->GetConceptSpV(), 1.0);
631      }
632      return Set;
633  }
634  PSVMTrainSet TBowDocBs2TrainSet::NewSparse(PBowDocPart BowDocPart) {
635      int Clusts = BowDocPart->GetClusts();
636      PSVMTrainSet Set = TSparseTrainSet::New(Clusts); TIntFltKdV SpVec;
637      for (int ClustN = 0; ClustN < Clusts; ClustN++) {
638          IAssert(BowDocPart->GetClust(ClustN)->IsConceptSpV());
639          MakeSpVec(BowDocPart->GetClust(ClustN)->GetConceptSpV(), SpVec);
640          Set->AddAttrV(SpVec, 1.0, false);
641      }
642      return Set;
643  }
644  PSVMModel TSVMModel::MakeModel(const bool& Linear,
645          const PKernel& ker, const PSVMTrainSet& TrainSet,
646          const TIntV& SubSet, const TSVMModelParam& ModelParam,
647          const TSVMLearnParam& LearnParam) {
648      PSVMModel Model = TSVMModel::New();
649      Model->Linear = Linear;
650      TIntV DIdV; int Len;
651      if (SubSet.Len() != 0) {
652          TSVMFactory::train(Model->AlphaV, Model->Thresh.Val, Linear, ker,
653              TSVMTrainSubSet::New(TrainSet(), SubSet), ModelParam, LearnParam);
654          DIdV = SubSet; Len = SubSet.Len();
655      } else {
656          TSVMFactory::train(Model->AlphaV, Model->Thresh.Val,
657              Linear, ker, TrainSet(), ModelParam, LearnParam);
658          Len = TrainSet->Len(); DIdV.Gen(Len);
659          for (int i = 0; i < Len; i++) { DIdV[i] = i; }
660      }
661      if (ModelParam.ModelType == smtClassifier) {
662          for (int i = 0; i < Len; i++) {
663              Model->AlphaV[i] = TrainSet->GetVecParam(DIdV[i]) * Model->AlphaV[i];
664          }
665      } else if (ModelParam.ModelType == smtRegression) {
666          IAssert(Model->AlphaV.Len() == 2*Len);
667          for (int i = 0; i < Len; i++) {
668              Model->AlphaV[i] = Model->AlphaV[i+Len] - Model->AlphaV[i];
669          }
670          Model->AlphaV.Trunc(Len);
671          Model->Thresh = -1.0 * Model->Thresh;
672      }
673      if (Linear) {
674          TrainSet->LinComb(DIdV, Model->AlphaV, Model->WgtV);
675      } else {
676          if (TrainSet->Type() != ststSimMatrix) {
677              TFltV NewAlphaV; TIntV VecIdV;
678              for (int VecN = 0; VecN < Len; VecN++) {
679                  if (TFlt::Abs(Model->AlphaV[VecN]) > EPSILON) {
680                      NewAlphaV.Add(Model->AlphaV[VecN]);
681                      VecIdV.Add(DIdV[VecN]);
682                  }
683              }
684              Model->AlphaV = NewAlphaV; 
685              Model->SupVecs = TrainSet->Clone(VecIdV);
686          } else {
687              TFltV NewAlphaV(TrainSet->Len()); NewAlphaV.PutAll(0.0);
688              for (int VecN = 0; VecN < Len; VecN++) {
689                  NewAlphaV[DIdV[VecN]] = Model->AlphaV[VecN];
690              }
691              Model->AlphaV = NewAlphaV; 
692              Model->SupVecs = TrainSet;
693          }
694          Model->Kernel = ker;
695      }
696      Model->AlphaV.Pack();
697      return Model;
698  }
699  TCfyRes TSVMModel::CrossValidation(const int& Folds, const int&Seed, const bool& Linear,
700          const PKernel& ker, const PSVMTrainSet& TrainSet, const TIntV& SubSet,
701          const TSVMModelParam& ModelParam, const TSVMLearnParam& LearnParam) {
702      TIntV DIdV; TCrossValid::PrepareSubDIdV(SubSet, TrainSet->Len(), DIdV);
703      TVec<TIntV> DIdVFoldV; TCrossValid::PrepareFolds(Folds, DIdV, Seed, DIdVFoldV);
704      TIntV TrainSubDIdV, TestSubDIdV; TCfyRes CfyRes;
705      double MarginSum = 0.0;
706      for (int FoldN = 0; FoldN < Folds; FoldN++) {
707          printf("%d.. ", FoldN);
708          TCrossValid::PrepareSplit(FoldN, DIdVFoldV, TrainSubDIdV, TestSubDIdV);
709          if (ModelParam.ModelType == smtOneClass) {
710              TIntV PosTrainSubDIdV;
711              for (int DIdN = 0; DIdN < TrainSubDIdV.Len(); DIdN++) {
712                  const int DId = TrainSubDIdV[DIdN];
713                  if (TrainSet->GetVecParam(DId) > 0.0) {
714                      PosTrainSubDIdV.Add(DId);
715                  }
716              }
717              TrainSubDIdV = PosTrainSubDIdV;
718          }
719          PSVMModel FoldModel = MakeModel(Linear, ker,
720              TrainSet, TrainSubDIdV, ModelParam, LearnParam);
721          TCfyRes FoldCfyRes = FoldModel->Test(TrainSet, TestSubDIdV);
722          MarginSum += FoldModel->GetMargin();
723          CfyRes.Add(FoldCfyRes);
724      } printf("\n");
725      CfyRes.Def();
726      CfyRes.AddStat("AvgMargin", MarginSum / Folds);
727      return CfyRes;
728  }
729  TSVMModel::TSVMModel(TSIn& SIn) {
730      AlphaV.Load(SIn);
731      Thresh.Load(SIn);
732      Linear.Load(SIn);
733      if (Linear) {
734          WgtV.Load(SIn);
735      } else {
736          SupVecs = TSVMTrainSet::Load(SIn);
737          Kernel = TKernel::Load(SIn);
738      }
739  }
740  void TSVMModel::Save(TSOut& SOut) {
741      AlphaV.Save(SOut);
742      Thresh.Save(SOut);
743      Linear.Save(SOut);
744      if (Linear) {
745          WgtV.Save(SOut);
746      } else {
747          SupVecs->Save(SOut);
748          Kernel->Save(SOut);
749      }
750  }
751  double TSVMModel::GetRes(const TIntFltKdV& Vec) const {
752      double Result = Thresh;
753      if (Linear) {
754          Result += TLinAlg::DotProduct(WgtV, Vec);
755      } else {
756          IAssert(!SupVecs.Empty() && ! Kernel.Empty());
757          IAssert(SupVecs->Len() == AlphaV.Len());
758          const double Norm2 = TLinAlg::Norm2(Vec);
759          for (int i = 0; i < AlphaV.Len(); i++) {
760              Result += AlphaV[i] * Kernel->Calc(
761                  SupVecs->DotProduct(i, Vec),
762                  Norm2, SupVecs->GetNorm2(i));
763          }
764      }
765      return Result;
766  }
767  double TSVMModel::GetRes(const TFltV& Vec) const {
768      double Result = Thresh;
769      if (Linear) {
770          Result += TLinAlg::DotProduct(WgtV, Vec);
771      } else {
772          IAssert(!SupVecs.Empty() && ! Kernel.Empty());
773          IAssert(SupVecs->Len() == AlphaV.Len());
774          const double Norm2 = TLinAlg::Norm2(Vec);
775          for (int i = 0; i < AlphaV.Len(); i++) {
776              Result += AlphaV[i] * Kernel->Calc(
777                  SupVecs->DotProduct(i, Vec),
778                  Norm2, SupVecs->GetNorm2(i));
779          }
780      }
781      return Result;
782  }
783  double TSVMModel::GetRes(const TStr& Vec) const {
784      IAssert(!Linear); 
785      IAssert(!SupVecs.Empty() && ! Kernel.Empty());
786      IAssert(SupVecs->Len() == AlphaV.Len());
787      IAssert(SupVecs->Type() == ststString);
788      double Result = Thresh;
789      const double Norm2 = 1.0; 
790      for (int i = 0; i < AlphaV.Len(); i++) {
791          Result += AlphaV[i] * Kernel->Calc(
792              SupVecs->DotProduct(i, Vec),
793              Norm2, SupVecs->GetNorm2(i));
794      }
795      return Result;
796  }
797  double TSVMModel::GetRes(const TIntV& Vec) const {
798      IAssert(!Linear); 
799      IAssert(!SupVecs.Empty() && ! Kernel.Empty());
800      IAssert(SupVecs->Len() == AlphaV.Len());
801      IAssert(SupVecs->Type() == ststString);
802      double Result = Thresh;
803      const double Norm2 = 1.0; 
804      for (int i = 0; i < AlphaV.Len(); i++) {
805          Result += AlphaV[i] * Kernel->Calc(
806              SupVecs->DotProduct(i, Vec),
807              Norm2, SupVecs->GetNorm2(i));
808      }
809      return Result;
810  }
811  double TSVMModel::GetRes(PBowSpV Vec) const {
812      double Result = Thresh;
813      if (Linear) {
814          Result += TBowLinAlg::DotProduct(WgtV, Vec);
815      } else {
816          IAssert(!SupVecs.Empty() && ! Kernel.Empty());
817          IAssert(SupVecs->Len() == AlphaV.Len());
818          IAssert(SupVecs->Type() == ststBow);
819          const double Norm2 = TMath::Sqr(Vec->GetNorm());
820          for (int i = 0; i < AlphaV.Len(); i++) {
821              Result += AlphaV[i] * Kernel->Calc(
822                  SupVecs->DotProduct(i, Vec),
823                  Norm2, SupVecs->GetNorm2(i));
824          }
825      }
826      return Result;
827  }
828  double TSVMModel::GetRes(const int& VecId) const {
829      IAssert(!Linear); 
830      IAssert(!SupVecs.Empty() && ! Kernel.Empty());
831      IAssert(SupVecs->Len() == AlphaV.Len());
832      IAssert(0 <= VecId && VecId < AlphaV.Len());
833      IAssert(SupVecs->Type() == ststSimMatrix);
834      double Result = Thresh;
835      const double Norm2 = SupVecs->GetNorm2(VecId);
836      for (int i = 0; i < AlphaV.Len(); i++) {
837          Result += AlphaV[i] * Kernel->Calc(
838              SupVecs->DotProduct(i, VecId),
839              Norm2, SupVecs->GetNorm2(i));
840      }
841      return Result;
842  }
843  TCfyRes TSVMModel::Test(const PSVMTrainSet& TestSet, const TIntV& SubSet) const {
844      TIntV DIdV; TCrossValid::PrepareSubDIdV(SubSet, TestSet->Len(), DIdV);
845      int Len = DIdV.Len(); TCountCfyRes Result;
846      for (int DocC = 0; DocC < Len; DocC++) {
847          if (TestSet->Type() == ststSparse) {
848              Result.Add(GetRes(TestSet->GetAttrSparseV(DIdV[DocC])),
849                  TestSet->GetVecParam(DIdV[DocC]));
850          } else if (TestSet->Type() == ststDense) {
851              Result.Add(GetRes(TestSet->GetAttrDenseV(DIdV[DocC])),
852                  TestSet->GetVecParam(DIdV[DocC]));
853          } else if (TestSet->Type() == ststBow) {
854              Result.Add(GetRes(TestSet->GetAttrBowV(DIdV[DocC])),
855                  TestSet->GetVecParam(DIdV[DocC]));
856          } else if (TestSet->Type() == ststString) {
857              Result.Add(GetRes(TestSet->GetAttrStringV(DIdV[DocC])),
858                  TestSet->GetVecParam(DIdV[DocC]));
859          } else if (TestSet->Type() == ststSimMatrix) {
860              Result.Add(GetRes(DIdV[DocC]), TestSet->GetVecParam(DIdV[DocC]));
861          }
862      }
863      return Result.ToTCfyRes();
864  }
865  void TSVMModel::MakeProb(const PSVMTrainSet& TrainSet, const TIntV& SubSet) {
866      TIntV DIdV; TCrossValid::PrepareSubDIdV(SubSet, TrainSet->Len(), DIdV);
867      int Docs = DIdV.Len();
868      TFltIntKdV DistParamV(Docs, 0);
869      for (int DocC = 0; DocC < Docs; DocC++) {
870          double DistToHyperplane = 0.0;
871          if (TrainSet->Type() == ststSparse) {
872              DistToHyperplane = GetRes(TrainSet->GetAttrSparseV(DIdV[DocC]));
873          } else if (TrainSet->Type() == ststDense) {
874              DistToHyperplane = GetRes(TrainSet->GetAttrDenseV(DIdV[DocC]));
875          } else if (TrainSet->Type() == ststBow) {
876              DistToHyperplane = GetRes(TrainSet->GetAttrBowV(DIdV[DocC]));
877          } else if (TrainSet->Type() == ststString) {
878              DistToHyperplane = GetRes(TrainSet->GetAttrStringV(DIdV[DocC]));
879          } else if (TrainSet->Type() == ststSimMatrix) {
880              DistToHyperplane = GetRes(DIdV[DocC]);
881          }
882          DistParamV.Add(TFltIntKd(DistToHyperplane,
883              TFlt::Round(TrainSet->GetVecParam(DIdV[DocC]))));
884      }
885      Sigmoid = TSigmoid(DistParamV);
886      IsSigDef = true;
887  }
888  double TSVMModel::GetMargin() const {
889      if (IsLinear()) {
890          const double WgtNorm = TLinAlg::Norm(WgtV);
891          if (WgtNorm > 0.0) { return 1.0 / WgtNorm; }
892          else { return 0.0; }
893      } else {
894          double WgtNorm2 = 0.0;
895          for (int i = 0; i < AlphaV.Len(); i++) {
896              for (int j = 0; j < AlphaV.Len(); j++) {
897                  WgtNorm2 += AlphaV[i]*AlphaV[j] * Kernel->CalcSet(SupVecs, i, j);
898              }
899          }
900          if (WgtNorm2 > 0.0) { return 1.0 / sqrt(WgtNorm2); }
901          else { return 0.0; }
902      }
903  }
904  bool TBowSVMMd::IsReg=TBowSVMMd::MkReg();
905  TBowSVMMd::TBowSVMMd(TSIn& SIn): TBowMd(SIn) {
906      CatNm.Load(SIn);
907      Model = TSVMModel::Load(SIn);
908  }
909  void TBowSVMMd::Save(TSOut &SOut) {
910      TBowMd::Save(SOut);
911      CatNm.Save(SOut);
912      Model->Save(SOut);
913  }
914  void TBowSVMMd::GetLinComb(
915   const PBowDocBs& BowDocBs, TFltStrPrV& WgtStrPrV, double& Tsh) const {
916    IAssert(IsLinComb());
917    TFltV WgtV; Model->GetWgtV(WgtV);
918    for (int WordId=0; WordId<WgtV.Len(); WordId++){
919      if (WgtV[WordId]!=0.0){
920        if (BowDocBs.Empty()){
921          WgtStrPrV.Add(TFltStrPr(WgtV[WordId], TInt::GetStr(WordId)));
922        } else {
923          TStr Str=BowDocBs->GetWordStr(WordId);
924          WgtStrPrV.Add(TFltStrPr(WgtV[WordId], Str));
925        }
926      }
927    }
928    Tsh=Model->GetThresh();
929  }
930  PSVMTrainSet TBowSVMMd::PrepareClsTrainSet(PBowDocBs BowDocBs,
931          PBowDocWgtBs BowDocWgtBs, const TStr& CatNm, const TIntV& TrainDIdV,
932          const double& SampleNegP) {
933      IAssertR(BowDocBs->IsCatNm(CatNm), CatNm);
934      const int CId = BowDocBs->GetCId(CatNm);
935      return TBowDocBs2TrainSet::NewBowAllCat(BowDocBs,
936          BowDocWgtBs, CId, TrainDIdV, SampleNegP);
937  }
938  PSVMTrainSet TBowSVMMd::PrepareOneClassTrainSet(PBowDocBs BowDocBs,
939          PBowDocWgtBs BowDocWgtBs, const TStr& CatNm, const TIntV& TrainDIdV) {
940      IAssertR(BowDocBs->IsCatNm(CatNm), CatNm);
941      const int CId = BowDocBs->GetCId(CatNm);
942      return TBowDocBs2TrainSet::NewBowOneCat(BowDocBs, BowDocWgtBs, CId, TrainDIdV);
943  }
944  inline PSVMTrainSet TBowSVMMd::PrepareClsTrainSet(PBowDocBs BowDocBs,
945          PBowDocWgtBs BowDocWgtBs, const TIntV& AllDIdV, const TIntV& CatDIdV) {
946      return TBowDocBs2TrainSet::NewSparseAllCatV(BowDocWgtBs, AllDIdV, CatDIdV);
947  }
948  PBowSpV TBowSVMMd::GetKeywords(const PSVMTrainSet& TrainSet,
949          const PSVMModel& SVMModel, const int WdN,
950          const double& VecSign, const double& WgtSign, const bool& AvgOverSet) {
951      TFltV NormalV; SVMModel->GetWgtV(NormalV);
952      TIntFltKdV WIdWgtKdV;
953      TrainSet->GetKeywords(NormalV, WIdWgtKdV,
954          TIntV(), WdN, VecSign, WgtSign, AvgOverSet);
955      PBowSpV BowSpV = TBowSpV::New(-1, WIdWgtKdV.Len());
956      for (int WdN = 0; WdN < WIdWgtKdV.Len(); WdN++) {
957          BowSpV->AddWIdWgt(WIdWgtKdV[WdN].Key, WIdWgtKdV[WdN].Dat);
958      }
959      return BowSpV;
960  }
961  inline void TBowSVMMd::GetCfy(const PBowSpV& QueryBowSpV, TFltStrPrV& WgtCatNmPrV) {
962      WgtCatNmPrV = TFltStrPrV::GetV(TFltStrPr(Model->IsProb() ?
963          Model->GetProbCfy(QueryBowSpV) : Model->GetRes(QueryBowSpV), CatNm));
964  }
965  TCfyRes TBowSVMMd::Test(PBowMd BowMd, PBowDocBs BowDocBs,
966          PBowDocWgtBs BowDocWgtBs, const TIntV& DIdV, const TStr& CatNm) {
967      TCountCfyRes Result; TFltStrPrV ResV;
968      IAssertR(BowDocBs->IsCatNm(CatNm), CatNm);
969      const int CId = BowDocBs->GetCId(CatNm);
970      for (int VecC = 0, VecN = DIdV.Len(); VecC < VecN; VecC++) {
971          PBowSpV DocSpV = BowDocWgtBs->GetSpV(DIdV[VecC]);
972          ResV.Clr(); BowMd->GetCfy(DocSpV, ResV);
973          double PredCls = ResV.Len() > 0 ? ResV[0].Val1() : -1.0;
974          double TrueCls = BowDocBs->IsCatInDoc(DIdV[VecC], CId) ? 1.0 : -1.0;
975          Result.Add(PredCls, TrueCls);
976      }
977      return Result.ToTCfyRes();
978  }
979  void TBowSVMMd::SaveTxt(const TStr& FNm, const PBowDocBs& BowDocBs,
980          const PBowDocWgtBs& BowDocWgtBs) {
981      PSOut SOut = TFOut::New(FNm);
982      TIntV DIdV; BowDocBs->GetAllDIdV(DIdV);
983      TCfyRes Res = Test(this, BowDocBs, BowDocWgtBs, DIdV, this->GetCatNm());
984      Res.PrStat("Results on the training data", SOut);
985      SOut->PutLn();
986  }
987  PBowMd TBowSVMMd::NewClsLinear(const PBowDocBs& BowDocBs, PBowDocWgtBs BowDocWgtBs,
988          const TStr& CatNm, const TIntV& TrainDIdV, const double& C, const double& j,
989          const bool& ProbabilisticP, const TSVMLearnParam& LearnParam) {
990      PSVMTrainSet TrainSet = PrepareClsTrainSet(BowDocBs, BowDocWgtBs, CatNm, TrainDIdV);
991      PSVMModel Model = TSVMModel::NewClsLinear(TrainSet, C, j, TIntV(), LearnParam);
992      if (ProbabilisticP) Model->MakeProb(TrainSet);
993      return TBowSVMMd::New(BowDocBs, CatNm, Model);
994  }
995  PBowMd TBowSVMMd::NewClsLinear(const PBowDocBs& BowDocBs, PBowDocWgtBs BowDocWgtBs,
996          const TIntV& TrainDIdV, const TIntV& CatDIdV, const double& C, const double& j,
997          const bool& ProbabilisticP, const TSVMLearnParam& LearnParam) {
998      PSVMTrainSet TrainSet = PrepareClsTrainSet(BowDocBs, BowDocWgtBs, TrainDIdV, CatDIdV);
999      PSVMModel Model = TSVMModel::NewClsLinear(TrainSet, C, j, TIntV(), LearnParam);
1000      if (ProbabilisticP) Model->MakeProb(TrainSet);
1001      return TBowSVMMd::New(BowDocBs, "unknown", Model);
1002  }
1003  PBowMd TBowSVMMd::NewCls(const PKernel& ker, const PBowDocBs& BowDocBs,
1004          PBowDocWgtBs BowDocWgtBs, const TStr& CatNm, const TIntV& TrainDIdV,
1005          const double& C, const double& j, const bool& ProbabilisticP,
1006          const TSVMLearnParam& LearnParam) {
1007      PSVMTrainSet TrainSet = PrepareClsTrainSet(BowDocBs, BowDocWgtBs, CatNm, TrainDIdV);
1008      PSVMModel Model = TSVMModel::NewCls(TrainSet, ker, C, j, TIntV(), LearnParam);
1009      if (ProbabilisticP) Model->MakeProb(TrainSet);
1010      return TBowSVMMd::New(BowDocBs, CatNm, Model);
1011  }
1012  TCfyRes TBowSVMMd::CrossValidClsLinear(const int& Folds, const int&Seed,
1013          const PBowDocBs& BowDocBs, PBowDocWgtBs BowDocWgtBs, const TStr& CatNm,
1014          const TIntV& TrainDIdV, const double& C, const double& j,
1015          const TSVMLearnParam& LearnParam) {
1016      PSVMTrainSet TrainSet = PrepareClsTrainSet(BowDocBs, BowDocWgtBs, CatNm, TrainDIdV);
1017      return TSVMModel::CrossValidClsLinear(Folds, Seed, TrainSet, C, j, TIntV(), LearnParam);
1018  }
1019  TCfyRes TBowSVMMd::CrossValidClsLinear(const int& Folds, const int&Seed,
1020          const PBowDocBs& BowDocBs, PBowDocWgtBs BowDocWgtBs, const TIntV& TrainDIdV,
1021          const TIntV& CatDIdV, const double& C, const double& j,
1022          const TSVMLearnParam& LearnParam) {
1023      PSVMTrainSet TrainSet = PrepareClsTrainSet(BowDocBs, BowDocWgtBs, TrainDIdV, CatDIdV);
1024      return TSVMModel::CrossValidClsLinear(Folds, Seed, TrainSet, C, j, TIntV(), LearnParam);
1025  }
1026  TCfyRes TBowSVMMd::CrossValidCls(const int& Folds, const int&Seed,
1027          const PKernel& ker, const PBowDocBs& BowDocBs, PBowDocWgtBs BowDocWgtBs,
1028          const TStr& CatNm, const TIntV& TrainDIdV, const double& C,
1029          const double& j, const TSVMLearnParam& LearnParam) {
1030      PSVMTrainSet TrainSet = PrepareClsTrainSet(BowDocBs, BowDocWgtBs, CatNm, TrainDIdV);
1031      return TSVMModel::CrossValidCls(Folds, Seed, TrainSet, ker, C, j, TIntV(), LearnParam);
1032  }
1033  PBowMd TBowSVMMd::NewMultiClsLinear(const PBowDocBs& BowDocBs, PBowDocWgtBs BowDocWgtBs,
1034          const TIntV& TrainDIdV, const double& C, const double& j,
1035          const bool& SampleNegP, const TSVMLearnParam& LearnParam) {
1036      const int Cats = BowDocBs->GetCats(); TBowMdV BowMdV(Cats, 0);
1037      for (int CatN = 0; CatN < Cats; CatN++) {
1038          const TStr& CatNm = BowDocBs->GetCatNm(CatN);
1039          PSVMTrainSet TrainSet = PrepareClsTrainSet(BowDocBs,
1040              BowDocWgtBs, CatNm, TrainDIdV, (SampleNegP ? j : -1.0));
1041          printf("(%4d/ %4d (Docs: %9d\r) ", CatN+1, Cats, TrainSet->Len());
1042          PSVMModel Model = TSVMModel::NewClsLinear(
1043              TrainSet, C, j, TIntV(), LearnParam);
1044          Model->MakeProb(TrainSet);
1045          BowMdV.Add(TBowSVMMd::New(BowDocBs, CatNm, Model));
1046      } printf("\n");
1047      return new TBowMultiMd(BowDocBs, BowMdV);
1048  }
1049  TCfyRes TBowSVMMd::CrossValidMultiClsLinear(const int& Folds, const int& Seed,
1050          const PBowDocBs& BowDocBs, PBowDocWgtBs BowDocWgtBs, const double& C,
1051          const double& j, const bool& SampleNegP, const TSVMLearnParam& LearnParam) {
1052      TIntV AllDIdV; BowDocBs->GetAllDIdV(AllDIdV); AllDIdV.Sort();
1053      TIntPrV CIdDIdV; const int DIds = AllDIdV.Len();
1054      for (int DIdN = 0; DIdN < DIds; DIdN++) {
1055          const int DId = AllDIdV[DIdN];
1056          const int CIds = BowDocBs->GetDocCIds(DId);
1057          for (int CIdN = 0; CIdN < CIds; CIdN++) {
1058              const int CId = BowDocBs->GetDocCId(DId, CIdN);
1059              CIdDIdV.Add(TIntPr(CId, DId));
1060          }
1061      }
1062      CIdDIdV.Sort();
1063      TVec<TIntV> FoldV(Folds); int FoldN = 0;
1064      for (int CIdDIdN = 0; CIdDIdN < CIdDIdV.Len(); CIdDIdN++) {
1065          const int DId = CIdDIdV[CIdDIdN].Val2;
1066          FoldV[FoldN].Add(DId);
1067          FoldN++;
1068          if (FoldN >= Folds) { FoldN = 0; }
1069      }
1070      for (int FoldN = 0; FoldN < Folds; FoldN++) { FoldV[FoldN].Sort(); }
1071      const int Cats = BowDocBs->GetCats(); TBowMdV BowMdV(Cats, 0);
1072      TVec<TCountCfyRes> CatCfyResV(Cats);
1073      for (int FoldN = 0; FoldN < Folds; FoldN++) {
1074          printf("Fold %d ...\n", FoldN+1);
1075          TIntV TestDIdV = FoldV[FoldN];
1076          TIntV TrainDIdV; AllDIdV.Minus(TestDIdV, TrainDIdV);
1077          PBowMd FoldBowMd = TBowSVMMd::NewMultiClsLinear(BowDocBs,
1078              BowDocWgtBs, TrainDIdV, C, j, SampleNegP, LearnParam);
1079          for (int TestDIdN = 0; TestDIdN < TestDIdV.Len(); TestDIdN++) {
1080              const int TestDId = TestDIdV[TestDIdN];
1081              TFltStrPrV WgtCatNmV;
1082              FoldBowMd->GetCfy(BowDocWgtBs->GetSpV(TestDId), WgtCatNmV);
1083              TIntH PredCIdH;
1084              if (!WgtCatNmV.Empty()) {
1085                  PredCIdH.AddKey(BowDocBs->GetCId(WgtCatNmV[0].Val2)); }
1086              const int CIds = BowDocBs->GetDocCIds(TestDId);
1087              for (int CIdN = 0; CIdN < CIds; CIdN++) {
1088                  const int CId = BowDocBs->GetDocCId(TestDId, CIdN);
1089                  if (PredCIdH.IsKey(CId)) {
1090                      CatCfyResV[CId].Add(1.0, 1.0);
1091                      PredCIdH.DelKey(CId);
1092                  } else {
1093                      CatCfyResV[CId].Add(-1.0, 1.0);
1094                  }
1095              }
1096              if (!PredCIdH.Empty()) {
1097                  int KeyId = PredCIdH.FFirstKeyId();
1098                  while (PredCIdH.FNextKeyId(KeyId)) {
1099                      const int CId = PredCIdH.GetKey(KeyId);
1100                      CatCfyResV[CId].Add(1.0, -1.0);
1101                  }
1102              }
1103          }
1104      }
1105      return TCountCfyRes::ToMacroTCfyRes(CatCfyResV);
1106  }
1107  PBowMd TBowSVMMd::NewOneClassLinear(const PBowDocBs& BowDocBs,
1108          PBowDocWgtBs BowDocWgtBs, const TStr& CatNm, const TIntV& TrainDIdV,
1109          const double& nu, const TSVMLearnParam& LearnParam) {
1110      PSVMTrainSet TrainSet = PrepareOneClassTrainSet(BowDocBs, BowDocWgtBs, CatNm, TrainDIdV);
1111      PSVMModel Model = TSVMModel::NewOneClassLinear(TrainSet, nu, TIntV(), LearnParam);
1112      return TBowSVMMd::New(BowDocBs, CatNm, Model);
1113  }
1114  PBowMd TBowSVMMd::NewOneClass(const PKernel& ker, const PBowDocBs& BowDocBs,
1115          PBowDocWgtBs BowDocWgtBs, const TStr& CatNm, const TIntV& TrainDIdV,
1116          const double& nu, const TSVMLearnParam& LearnParam) {
1117      PSVMTrainSet TrainSet = PrepareOneClassTrainSet(BowDocBs, BowDocWgtBs, CatNm, TrainDIdV);
1118      PSVMModel Model = TSVMModel::NewOneClass(TrainSet, ker, nu, TIntV(), LearnParam);
1119      return TBowSVMMd::New(BowDocBs, CatNm, Model);
1120  }
1121  TCfyRes TBowSVMMd::CrossValidOneClassLinear(const int& Folds, const int&Seed,
1122          const PBowDocBs& BowDocBs, PBowDocWgtBs BowDocWgtBs, const TStr& CatNm,
1123          const TIntV& TrainDIdV, const double& nu, const TSVMLearnParam& LearnParam) {
1124      PSVMTrainSet TrainSet = PrepareClsTrainSet(BowDocBs, BowDocWgtBs, CatNm, TrainDIdV);
1125      return TSVMModel::CrossValidOneClassLinear(Folds, Seed, TrainSet, nu, TIntV(), LearnParam);
1126  }
1127  TCfyRes TBowSVMMd::CrossValidOneClass(const int& Folds, const int&Seed,
1128          const PKernel& ker, const PBowDocBs& BowDocBs, PBowDocWgtBs BowDocWgtBs,
1129          const TStr& CatNm, const TIntV& TrainDIdV, const double& nu,
1130          const TSVMLearnParam& LearnParam) {
1131      PSVMTrainSet TrainSet = PrepareClsTrainSet(BowDocBs, BowDocWgtBs, CatNm, TrainDIdV);
1132      return TSVMModel::CrossValidOneClass(Folds, Seed, TrainSet, ker, nu, TIntV(), LearnParam);
1133  }
1134  PBowSpV TBowSVMMd::GetKeywords(const PBowDocBs& BowDocBs, const TIntV& TrainDIdV,
1135          const TIntV& CatDIdV, const int WdN, const double& C, const double& j,
1136          const int& Time, const TBowWordWgtType& SvmWordWgtType, const double& VecSign,
1137          const double& WgtSign, const bool& AvgOverSet) {
1138      PBowDocWgtBs BowDocWgtBs = TBowDocWgtBs::New(BowDocBs, SvmWordWgtType);
1139      PSVMTrainSet TrainSet = PrepareClsTrainSet(BowDocBs, BowDocWgtBs, TrainDIdV, CatDIdV);
1140      PSVMModel Model = TSVMModel::NewClsLinear(TrainSet, C, j, TIntV(), TSVMLearnParam::Lin(Time));
1141      return GetKeywords(TrainSet, Model, WdN, VecSign, WgtSign, AvgOverSet);
1142  }
1143  PBowSpV TBowSVMMd::GetKeywords(const PBowDocBs& BowDocBs, PBowDocWgtBs BowDocWgtBs,
1144          const TIntV& TrainDIdV, const TIntV& CatDIdV, const int WdN, const double& C,
1145          const double& j, const int& Time, const double& VecSign, const double& WgtSign,
1146          const bool& AvgOverSet) {
1147      PSVMTrainSet TrainSet = PrepareClsTrainSet(BowDocBs, BowDocWgtBs, TrainDIdV, CatDIdV);
1148      PSVMModel Model = TSVMModel::NewClsLinear(TrainSet, C, j, TIntV(), TSVMLearnParam::Lin(Time));
1149      return GetKeywords(TrainSet, Model, WdN, VecSign, WgtSign, AvgOverSet);
1150  }
1151  PBowSpV TBowSVMMd::GetKeywords(const PBowDocBs& BowDocBs, const TIntV& TrainDIdV,
1152          const TStr& CatNm, const int WdN, const double& C, const double& j,
1153          const int& Time, const TBowWordWgtType& SvmWordWgtType, const double& VecSign,
1154          const double& WgtSign, const bool& AvgOverSet) {
1155      PBowDocWgtBs BowDocWgtBs = TBowDocWgtBs::New(BowDocBs, SvmWordWgtType);
1156      PSVMTrainSet TrainSet = PrepareClsTrainSet(BowDocBs, BowDocWgtBs, CatNm, TrainDIdV);
1157      PSVMModel Model = TSVMModel::NewClsLinear(TrainSet, C, j, TIntV(), TSVMLearnParam::Lin(Time));
1158      return GetKeywords(TrainSet, Model, WdN, VecSign, WgtSign, AvgOverSet);
1159  }
1160  PBowSpV TBowSVMMd::GetKeywords(const PBowDocBs& BowDocBs, PBowDocWgtBs BowDocWgtBs,
1161          const TIntV& TrainDIdV, const TStr& CatNm, const int WdN, const double& C,
1162          const double& j, const int& Time, const double& VecSign, const double& WgtSign,
1163          const bool& AvgOverSet) {
1164      PSVMTrainSet TrainSet = PrepareClsTrainSet(BowDocBs, BowDocWgtBs, CatNm, TrainDIdV);
1165      PSVMModel Model = TSVMModel::NewClsLinear(TrainSet, C, j, TIntV(), TSVMLearnParam::Lin(Time));
1166      return GetKeywords(TrainSet, Model, WdN, VecSign, WgtSign, AvgOverSet);
1167  }
1168  void TSVMTrainSetCsv::TFtrGen::AddWds(const TStr& Prefix,
1169          const PBowDocBs& BowDocBs, int& Offset) const {
1170      const int Vals = GetVals();
1171      for (int ValN = 0; ValN < Vals; ValN++) {
1172          const int WId = BowDocBs->AddWordStr(
1173              TStr::Fmt("%s-%s", Prefix.CStr(), GetVal(ValN).CStr()));
1174          IAssert(Offset == WId); Offset++;
1175      }
1176  }
1177  TStr TSVMTrainSetCsv::TFtrGenNumeric::Type = "NUM";
1178  double TSVMTrainSetCsv::TFtrGenNumeric::Trans(const double& Val) const {
1179          return MnVal != MxVal ? (double(Val) - MnVal) / (MxVal - MnVal) : 0.0;
1180  }
1181  double TSVMTrainSetCsv::TFtrGenNumeric::GetFlt(const TStr& Str) const {
1182      double Val = 0.0;
1183      if (!Str.IsFlt(Val)) {
1184          TExcept::Throw(TStr::Fmt("Number expected  but '%s' found!", Str.CStr())); }
1185      return Val;
1186  }
1187  void TSVMTrainSetCsv::TFtrGenNumeric::Update(const TStr& Val) {
1188      double Flt = GetFlt(Val);
1189      MnVal = TFlt::GetMn(MnVal, Flt);
1190      MxVal = TFlt::GetMx(MxVal, Flt);
1191  }
1192  void TSVMTrainSetCsv::TFtrGenNumeric::Add(
1193          const TStr& Val, TIntFltKdV& SpV, int& Offset) const {
1194      double Flt = GetFlt(Val);
1195      SpV.Add(TIntFltKd(Offset, Trans(Flt)));
1196      Offset++;
1197  }
1198  TStr TSVMTrainSetCsv::TFtrGenNominal::Type = "NOM";
1199  void TSVMTrainSetCsv::TFtrGenNominal::Update(const TStr& Val) {
1200      if (!Val.Empty()) { ValH.AddKey(Val); }
1201  }
1202  void TSVMTrainSetCsv::TFtrGenNominal::Add(
1203          const TStr& Val, TIntFltKdV& SpV, int& Offset) const {
1204      if (ValH.IsKey(Val)) {
1205          SpV.Add(TIntFltKd(Offset + ValH.GetKeyId(Val), 1.0));
1206      }
1207      Offset += ValH.Len();
1208  }
1209  TStr TSVMTrainSetCsv::TFtrGenToken::Type = "TOK";
1210  void TSVMTrainSetCsv::TFtrGenToken::GetTokenV(
1211          const TStr& Str, TStrV& TokenStrV) const {
1212      THtmlLx HtmlLx(TStrIn::New(Str));
1213      while (HtmlLx.Sym != hsyEof){
1214          if (HtmlLx.Sym == hsyStr){
1215              TStr TokenStr = HtmlLx.UcChA;
1216              if (SwSet.Empty() || !SwSet->IsIn(TokenStr)) {
1217                  if (!Stemmer.Empty()) {
1218                      TokenStr = Stemmer->GetStem(TokenStr); }
1219                  TokenStrV.Add(TokenStr);
1220              }
1221          }
1222          HtmlLx.GetSym();
1223      }
1224  }
1225  void TSVMTrainSetCsv::TFtrGenToken::Update(const TStr& Val) {
1226      TStrV TokenStrV; GetTokenV(Val, TokenStrV);
1227      for (int TokenStrN = 0; TokenStrN < TokenStrV.Len(); TokenStrN++) {
1228          const TStr& TokenStr = TokenStrV[TokenStrN];
1229          TokenH.AddDat(TokenStr)++;
1230      }
1231      Docs++;
1232  }
1233  void TSVMTrainSetCsv::TFtrGenToken::Add(
1234          const TStr& Val, TIntFltKdV& SpV, int& Offset) const {
1235      TStrV TokenStrV; GetTokenV(Val, TokenStrV);
1236      TIntH TokenFqH;
1237      for (int TokenStrN = 0; TokenStrN < TokenStrV.Len(); TokenStrN++) {
1238          const TStr& TokenStr = TokenStrV[TokenStrN];
1239          if (TokenH.IsKey(TokenStr)) {
1240              const int TokenId = TokenH.GetKeyId(TokenStr);
1241              TokenFqH.AddDat(TokenId)++;
1242          }
1243      }
1244      TIntFltKdV ValSpV(TokenFqH.Len(), 0);
1245      int KeyId = TokenFqH.FFirstKeyId();
1246      while (TokenFqH.FNextKeyId(KeyId)) {
1247          const int TokenId = TokenFqH.GetKey(KeyId);
1248          const int TokenFq = TokenFqH[KeyId];
1249          const int TokenDocFq = TokenH[TokenId];
1250          const double IDF = log(double(Docs) / double(TokenDocFq));
1251          ValSpV.Add(TIntFltKd(TokenId, double(TokenFq) * IDF));
1252      }
1253      ValSpV.Sort(); TLinAlg::NormalizeL1(ValSpV);
1254      for (int ValSpN = 0; ValSpN < ValSpV.Len(); ValSpN++) {
1255          const int Key = ValSpV[ValSpN].Key + Offset;
1256          const double Dat = ValSpV[ValSpN].Dat;
1257          SpV.Add(TIntFltKd(Key, Dat));
1258      }
1259      Offset += TokenH.Len();
1260  }
1261  TStr TSVMTrainSetCsv::TFtrGenSparseNumeric::Type = "SP-NUM";
1262  void TSVMTrainSetCsv::TFtrGenSparseNumeric::Split(
1263          const TStr& Str, int& Id, TStr& Val) const {
1264      if (!Str.IsChIn(':')) { TExcept::Throw("Wrong sparse numeric '" + Str + "'!"); }
1265      TStr IdStr; Str.SplitOnCh(IdStr, ':', Val);
1266      if (!IdStr.IsInt(Id)) { TExcept::Throw("Wrong sparse numeric '" + Str + "'!"); }
1267  }
1268  void TSVMTrainSetCsv::TFtrGenSparseNumeric::Update(const TStr& Str) {
1269      TStrV EltV; Str.SplitOnAllCh(';', EltV);
1270      for (int EltN = 0; EltN < EltV.Len(); EltN++) {
1271          int Id; TStr Val; Split(EltV[EltN], Id, Val);
1272          MxId = TInt::GetMx(Id, MxId);
1273          FtrGen.Update(Val);
1274      }
1275  }
1276  void TSVMTrainSetCsv::TFtrGenSparseNumeric::Add(
1277          const TStr& Str, TIntFltKdV& SpV, int& Offset) const {
1278      TStrV EltV; Str.SplitOnAllCh(';', EltV); TIntH UsedIdH;
1279      for (int EltN = 0; EltN < EltV.Len(); EltN++) {
1280          int Id; TStr Val; Split(EltV[EltN], Id, Val);
1281          EAssertR(!UsedIdH.IsKey(Id), "Field ID repeated in '" + Str + "'!");
1282          int TmpOffset = Offset + Id;
1283          FtrGen.Add(Val, SpV, TmpOffset);
1284          UsedIdH.AddKey(Id);
1285      }
1286      Offset += GetVals();
1287  }
1288  TStr TSVMTrainSetCsv::TFtrGenSparseNumeric::GetVal(const int& ValN) const {
1289      const int FtrGenId = ValN / FtrGen.GetVals();
1290      const int FtrGenValN = ValN % FtrGen.GetVals();
1291      return TStr::Fmt("SP-%d-%d-%s", FtrGenId,
1292          FtrGenValN, FtrGen.GetVal(FtrGenValN).CStr());
1293  }
1294  TStr TSVMTrainSetCsv::TFtrGenMultiNom::Type = "MULTI-NOM";
1295  void TSVMTrainSetCsv::TFtrGenMultiNom::Update(const TStr& Str) {
<span onclick='openModal()' class='match'>1296      TStrV EltV; Str.SplitOnAllCh(';', EltV);
1297      for (int EltN = 0; EltN < EltV.Len(); EltN++) {
1298          FtrGen.Update(EltV[EltN]);
</span>1299      }
1300  }
1301  void TSVMTrainSetCsv::TFtrGenMultiNom::Add(
1302          const TStr& Str, TIntFltKdV& SpV, int& Offset) const {
1303      TStrV EltV; Str.SplitOnAllCh(';', EltV);
1304      for (int EltN = 0; EltN < EltV.Len(); EltN++) {
1305          int TmpOffset = Offset;
1306          FtrGen.Add(EltV[EltN], SpV, TmpOffset);
1307      }
1308      Offset += GetVals();
1309  }
1310  TStr TSVMTrainSetCsv::TFtrGenMultiNom::GetVal(const int& ValN) const {
1311      return TStr::Fmt("MULTI-%d-%s", ValN, FtrGen.GetVal(ValN).CStr());
1312  }
1313  void TSVMTrainSetCsv::TFtrGenMultiNom::GetValV(const TStr& Str, TStrV& ValV) const {
1314      TStrV EltV; Str.SplitOnAllCh(';', EltV); ValV.Clr();
1315      for (int EltN = 0; EltN < EltV.Len(); EltN++) {
1316          const TStr& Val = EltV[EltN];
1317          TStrV SubValV; FtrGen.GetValV(Val, SubValV);
1318          ValV.AddV(SubValV);
1319      }
1320  }
1321  PBowDocBs TSVMTrainSetCsv::LoadCsv(TStr& FNm, const int& ClassId,
1322          const TIntV& IgnoreIdV, const int& TrainLen) {
1323      THash<TInt, PFtrGen> FtrGenH;
1324      PFtrGen ClassFtrGen;
1325      PSIn SIn = TFIn::New(FNm);
1326      char SsCh = ' '; TStrV FldValV;
1327      TSs::LoadTxtFldV(ssfCommaSep, SIn, SsCh, FldValV, false);
1328      for (int FldValN = 0; FldValN < FldValV.Len(); FldValN++) {
1329          const TStr& FldVal = FldValV[FldValN];
1330          if (FldValN == ClassId) {
1331              if (FldVal == "NOM") {
1332                  ClassFtrGen = TFtrGenNominal::New();
1333              } else if (FldVal == "MULTI-NOM") {
1334                  ClassFtrGen = TFtrGenMultiNom::New();
1335              } else {
1336                  TExcept::Throw("Wrong class type '" + FldVal + "', should be NOM or MULTI-NOM!");
1337              }
1338          } else if (!IgnoreIdV.IsIn(FldValN)) {
1339              if (FldVal == TFtrGenNumeric::Type) {
1340                  FtrGenH.AddDat(FldValN, TFtrGenNumeric::New());
1341              } else if (FldVal == TFtrGenNominal::Type) {
1342                  FtrGenH.AddDat(FldValN, TFtrGenNominal::New());
1343              } else if (FldVal == TFtrGenToken::Type) {
1344                  FtrGenH.AddDat(FldValN, TFtrGenToken::New(
1345                      TSwSet::New(swstNone), TStemmer::New(stmtNone)));
1346              } else if (FldVal == TFtrGenSparseNumeric::Type) {
1347                  FtrGenH.AddDat(FldValN, TFtrGenSparseNumeric::New());
1348              } else if (FldVal == TFtrGenMultiNom::Type) {
1349                  FtrGenH.AddDat(FldValN, TFtrGenMultiNom::New());
1350              } else {
1351                  TExcept::Throw("Wrong type '" + FldVal + "'!");
1352              }
1353          }
1354      }
1355      const int Flds = FldValV.Len();
1356      int Recs = 0;
1357      while (!SIn->Eof()) {
1358          if (Recs == TrainLen) { break; }
1359          Recs++; printf("%7d\r", Recs);
1360          TSs::LoadTxtFldV(ssfCommaSep, SIn, SsCh, FldValV, false);
1361          EAssertR(FldValV.Len() == Flds,
1362              TStr::Fmt("Wrong number of fields in line %d! Found %d and expected %d!",
1363              Recs + 1, FldValV.Len(), Flds));
1364          try {
1365              for (int FldValN = 0; FldValN < FldValV.Len(); FldValN++) {
1366                  const TStr& FldVal = FldValV[FldValN];
1367                  if (FldValN == ClassId) {
1368                      ClassFtrGen->Update(FldVal);
1369                  } else if (FtrGenH.IsKey(FldValN)) {
1370                      PFtrGen FtrGen = FtrGenH.GetDat(FldValN);
1371                      FtrGen->Update(FldVal);
1372                  }
1373              }
1374          } catch (PExcept Ex) {
1375              TExcept::Throw(TStr::Fmt("Error in line %d: '%s'!",
1376                  Recs+1, Ex->GetMsgStr().CStr()));
1377          }
1378      }
1379      PBowDocBs BowDocBs = TBowDocBs::New();
1380      int WdsOffset = 0;
1381      for (int FtrGenId = 0; FtrGenId < FtrGenH.Len(); FtrGenId++) {
1382          PFtrGen FtrGen = FtrGenH[FtrGenId];
1383          TStr Prefix = FtrGenH.GetKey(FtrGenId).GetStr();
1384          FtrGen->AddWds(Prefix, BowDocBs, WdsOffset);
1385      }
1386      SIn = TFIn::New(FNm); SsCh = ' ';
1387      TSs::LoadTxtFldV(ssfCommaSep, SIn, SsCh, FldValV, false);
1388      Recs = 0;
1389      while (!SIn->Eof()){
1390          Recs++; printf("%7d\r", Recs);
1391          TSs::LoadTxtFldV(ssfCommaSep, SIn, SsCh, FldValV, false);
1392          EAssertR(FldValV.Len() == Flds,
1393              TStr::Fmt("Wrong number of fields in line %s! Found %d and expected %d!",
1394              Recs + 1, FldValV.Len(), Flds));
1395          TIntFltKdV FtrSpV; TStrV CatNmV; int Offset = 0;
1396          try {
1397              for (int FldValN = 0; FldValN < FldValV.Len(); FldValN++) {
1398                  const TStr& FldVal = FldValV[FldValN];
1399                  if (FldValN == ClassId) {
1400                      ClassFtrGen->GetValV(FldVal, CatNmV);
1401                  } else if (FtrGenH.IsKey(FldValN)) {
1402                      PFtrGen FtrGen = FtrGenH.GetDat(FldValN);
1403                      FtrGen->Add(FldVal, FtrSpV, Offset);
1404                  }
1405              }
1406          } catch (PExcept Ex) {
1407              TExcept::Throw(TStr::Fmt("Error in line %d: '%s'!",
1408                  Recs+1, Ex->GetMsgStr().CStr()));
1409          }
1410          const int WIds = FtrSpV.Len();
1411          TIntFltPrV WIdWgtPrV(WIds, 0);
1412          for (int WIdN = 0; WIdN < WIds; WIdN++) {
1413              WIdWgtPrV.Add(TIntFltPr(FtrSpV[WIdN].Key, FtrSpV[WIdN].Dat));
1414          }
1415          BowDocBs->AddDoc(TStr::Fmt("Line-%d", Recs), CatNmV, WIdWgtPrV);
1416      }
1417      return BowDocBs;
1418  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-vizmapgks.cpp</h3>
            <pre><code>1  #include "vizmapgks.h"
2  #include <gkswf.h>
3  TGksColor TVizMapContext::ColorLandscapeAbove = TGksColor(54, 92, 120);
4  TGksColor TVizMapContext::ColorAddFirstLevel = TGksColor(9, 7, 6);
5  TGksColor TVizMapContext::ColorAddSecondLevel = TGksColor(18, 14, 12);
6  TGksColor TVizMapContext::ColorLegendGridColor = TGksColor(192, 255, 255, 255);
7  TGksColor TVizMapContext::ColorPointCross = TGksColor(255, 220, 0);
8  TGksColor TVizMapContext::ColorSelPointCross = TGksColor(255, 145, 145);
9  TGksColor TVizMapContext::ColorPointFont = TGksColor(255, 220, 0);
10  TGksColor TVizMapContext::ColorSelPointFont = TGksColor(255, 255, 30);
11  TGksColor TVizMapContext::ColorLink = TGksColor(100, 100, 255, 100);
12  TGksColor TVizMapContext::ColorKeyWdFont = TGksColor(240,240,255);
13  TGksColor TVizMapContext::ColorCatNmFont = TGksColor(255,240,255);
14  TGksColor TVizMapContext::ColorZoomRect = TGksColor(100, 0, 0, 0); 
15  TGksColor TVizMapContext::ColorMgGlass = TGksColor(50, 0, 0, 0);
16  TGksColor TVizMapContext::ColorMgGlassWnd = TGksColor(192, 255, 255, 255);
17  TGksColor TVizMapContext::ColorMgGlassWndFrm = TGksColor(100, 0, 0, 0); 
18  TGksColor TVizMapContext::ColorMgGlassWndShadow = TGksColor(50, 0, 0, 0);
19  int TVizMapContext::SizePointCross = 2;
20  int TVizMapContext::PointNmWidth = 100;
21  int TVizMapContext::PointNmMxLines = 3;
22  double TVizMapContext::PointNmFontScale = 20.0;
23  int TVizMapContext::MgGlassWindowWidth = 150;
24  int TVizMapContext::RndKeyWdN = 3000;
25  double TVizMapContext::RelRadius = 0.2;
26  int TVizMapContext::KeyWdCandidates = 10;
27  double TVizMapContext::RelMnRptDist = 0.1;
28  double TVizMapContext::RelSparsity = 0.05;
29  void TVizMapContext::LoadColor() {
30      LandscapeCatColorV.Clr();
31      LandscapeCatColorV.Add(TGksColor(43, 76, 115));
32      LandscapeCatColorV.Add(TGksColor(53, 46, 115));
33      LandscapeCatColorV.Add(TGksColor(33, 106, 115));
34      LandscapeCatColorV.Add(TGksColor(63, 80, 170));
35      LandscapeCatColorV.Add(TGksColor(61, 106, 200));
36      LandscapeCatColorV.Add(TGksColor(71, 106, 190));
37      LandscapeCatColorV.Add(TGksColor(51, 106, 210));
38      LandscapeCatColorV.Add(TGksColor(81, 106, 180));
39      LandscapeCatColorV.Add(TGksColor(43, 91, 125));
40      LandscapeCatColorV.Add(TGksColor(43, 91, 135));
41      LandscapeCatColorV.Add(TGksColor(43, 91, 145));
42      LandscapeCatColorV.Add(TGksColor(43, 91, 155));
43      LandscapeCatColorV.Add(TGksColor(43, 106, 125));
44      LandscapeCatColorV.Add(TGksColor(43, 106, 135));
45      LandscapeCatColorV.Add(TGksColor(43, 106, 145));
46      LandscapeCatColorV.Add(TGksColor(43, 106, 155));
47  }
48  void TVizMapContext::LoadCatFullNms() {
49      CatFullNmH.AddDat("1POL", "CURRENT NEWS - POLITICS");
50      CatFullNmH.AddDat("2ECO", "CURRENT NEWS - ECONOMICS");
51      CatFullNmH.AddDat("3SPO", "CURRENT NEWS - SPORT");
52      CatFullNmH.AddDat("4GEN", "CURRENT NEWS - GENERAL");
53      CatFullNmH.AddDat("6INS", "CURRENT NEWS - INSURANCE");
54      CatFullNmH.AddDat("7RSK", "CURRENT NEWS - RISK NEWS");
55      CatFullNmH.AddDat("8YDB", "TEMPORARY");
56      CatFullNmH.AddDat("9BNX", "TEMPORARY");
57      CatFullNmH.AddDat("ADS10", "CURRENT NEWS - ADVERTISING");
58      CatFullNmH.AddDat("BNW14", "CURRENT NEWS - BUSINESS NEWS");
59      CatFullNmH.AddDat("BRP11", "CURRENT NEWS - BRANDS");
60      CatFullNmH.AddDat("C11", "STRATEGY/PLANS");
61      CatFullNmH.AddDat("C12", "LEGAL/JUDICIAL");
62      CatFullNmH.AddDat("C13", "REGULATION/POLICY");
63      CatFullNmH.AddDat("C14", "SHARE LISTINGS");
64      CatFullNmH.AddDat("C15", "PERFORMANCE");
65      CatFullNmH.AddDat("C151", "ACCOUNTS/EARNINGS");
66      CatFullNmH.AddDat("C1511", "ANNUAL RESULTS");
67      CatFullNmH.AddDat("C152", "COMMENT/FORECASTS");
68      CatFullNmH.AddDat("C16", "INSOLVENCY/LIQUIDITY");
69      CatFullNmH.AddDat("C17", "FUNDING/CAPITAL");
70      CatFullNmH.AddDat("C171", "SHARE CAPITAL");
71      CatFullNmH.AddDat("C172", "BONDS/DEBT ISSUES");
72      CatFullNmH.AddDat("C173", "LOANS/CREDITS");
73      CatFullNmH.AddDat("C174", "CREDIT RATINGS");
74      CatFullNmH.AddDat("C18", "OWNERSHIP CHANGES");
75      CatFullNmH.AddDat("C181", "MERGERS/ACQUISITIONS");
76      CatFullNmH.AddDat("C182", "ASSET TRANSFERS");
77      CatFullNmH.AddDat("C183", "PRIVATISATIONS");
78      CatFullNmH.AddDat("C21", "PRODUCTION/SERVICES");
79      CatFullNmH.AddDat("C22", "NEW PRODUCTS/SERVICES");
80      CatFullNmH.AddDat("C23", "RESEARCH/DEVELOPMENT");
81      CatFullNmH.AddDat("C24", "CAPACITY/FACILITIES");
82      CatFullNmH.AddDat("C31", "MARKETS/MARKETING");
83      CatFullNmH.AddDat("C311", "DOMESTIC MARKETS");
84      CatFullNmH.AddDat("C312", "EXTERNAL MARKETS");
85      CatFullNmH.AddDat("C313", "MARKET SHARE");
86      CatFullNmH.AddDat("C32", "ADVERTISING/PROMOTION");
87      CatFullNmH.AddDat("C33", "CONTRACTS/ORDERS");
88      CatFullNmH.AddDat("C331", "DEFENCE CONTRACTS");
89      CatFullNmH.AddDat("C34", "MONOPOLIES/COMPETITION");
90      CatFullNmH.AddDat("C41", "MANAGEMENT");
91      CatFullNmH.AddDat("C411", "MANAGEMENT MOVES");
92      CatFullNmH.AddDat("C42", "LABOUR");
93      CatFullNmH.AddDat("CCAT", "CORPORATE/INDUSTRIAL");
94      CatFullNmH.AddDat("E11", "ECONOMIC PERFORMANCE");
95      CatFullNmH.AddDat("E12", "MONETARY/ECONOMIC");
96      CatFullNmH.AddDat("E121", "MONEY SUPPLY");
97      CatFullNmH.AddDat("E13", "INFLATION/PRICES");
98      CatFullNmH.AddDat("E131", "CONSUMER PRICES");
99      CatFullNmH.AddDat("E132", "WHOLESALE PRICES");
100      CatFullNmH.AddDat("E14", "CONSUMER FINANCE");
101      CatFullNmH.AddDat("E141", "PERSONAL INCOME");
102      CatFullNmH.AddDat("E142", "CONSUMER CREDIT");
103      CatFullNmH.AddDat("E143", "RETAIL SALES");
104      CatFullNmH.AddDat("E21", "GOVERNMENT FINANCE");
105      CatFullNmH.AddDat("E211", "EXPENDITURE/REVENUE");
106      CatFullNmH.AddDat("E212", "GOVERNMENT BORROWING");
107      CatFullNmH.AddDat("E31", "OUTPUT/CAPACITY");
108      CatFullNmH.AddDat("E311", "INDUSTRIAL PRODUCTION");
109      CatFullNmH.AddDat("E312", "CAPACITY UTILIZATION");
110      CatFullNmH.AddDat("E313", "INVENTORIES");
111      CatFullNmH.AddDat("E41", "EMPLOYMENT/LABOUR");
112      CatFullNmH.AddDat("E411", "UNEMPLOYMENT");
113      CatFullNmH.AddDat("E51", "TRADE/RESERVES");
114      CatFullNmH.AddDat("E511", "BALANCE OF PAYMENTS");
115      CatFullNmH.AddDat("E512", "MERCHANDISE TRADE");
116      CatFullNmH.AddDat("E513", "RESERVES");
117      CatFullNmH.AddDat("E61", "HOUSING STARTS");
118      CatFullNmH.AddDat("E71", "LEADING INDICATORS");
119      CatFullNmH.AddDat("ECAT", "ECONOMICS");
120      CatFullNmH.AddDat("ENT12", "CURRENT NEWS - ENTERTAINMENT");
121      CatFullNmH.AddDat("G11", "SOCIAL AFFAIRS");
122      CatFullNmH.AddDat("G111", "HEALTH/SAFETY");
123      CatFullNmH.AddDat("G112", "SOCIAL SECURITY");
124      CatFullNmH.AddDat("G113", "EDUCATION/RESEARCH");
125      CatFullNmH.AddDat("G12", "INTERNAL POLITICS");
126      CatFullNmH.AddDat("G13", "INTERNATIONAL RELATIONS");
127      CatFullNmH.AddDat("G131", "DEFENCE");
128      CatFullNmH.AddDat("G14", "ENVIRONMENT");
129      CatFullNmH.AddDat("G15", "EUROPEAN COMMUNITY");
130      CatFullNmH.AddDat("G151", "EC INTERNAL MARKET");
131      CatFullNmH.AddDat("G152", "EC CORPORATE POLICY");
132      CatFullNmH.AddDat("G153", "EC AGRICULTURE POLICY");
133      CatFullNmH.AddDat("G154", "EC MONETARY/ECONOMIC");
134      CatFullNmH.AddDat("G155", "EC INSTITUTIONS");
135      CatFullNmH.AddDat("G156", "EC ENVIRONMENT ISSUES");
136      CatFullNmH.AddDat("G157", "EC COMPETITION/SUBSIDY");
137      CatFullNmH.AddDat("G158", "EC EXTERNAL RELATIONS");
138      CatFullNmH.AddDat("G159", "EC GENERAL");
139      CatFullNmH.AddDat("GCAT", "GOVERNMENT/SOCIAL");
140      CatFullNmH.AddDat("GCRIM", "CRIME, LAW ENFORCEMENT");
141      CatFullNmH.AddDat("GDEF", "DEFENCE");
142      CatFullNmH.AddDat("GDIP", "INTERNATIONAL RELATIONS");
143      CatFullNmH.AddDat("GDIS", "DISASTERS AND ACCIDENTS");
144      CatFullNmH.AddDat("GEDU", "EDUCATION");
145      CatFullNmH.AddDat("GENT", "ARTS, CULTURE, ENTERTAINMENT");
146      CatFullNmH.AddDat("GENV", "ENVIRONMENT AND NATURAL WORLD");
147      CatFullNmH.AddDat("GFAS", "FASHION");
148      CatFullNmH.AddDat("GHEA", "HEALTH");
149      CatFullNmH.AddDat("GJOB", "LABOUR ISSUES");
150      CatFullNmH.AddDat("GMIL", "MILLENNIUM ISSUES");
151      CatFullNmH.AddDat("GOBIT", "OBITUARIES");
152      CatFullNmH.AddDat("GODD", "HUMAN INTEREST");
153      CatFullNmH.AddDat("GPOL", "DOMESTIC POLITICS");
154      CatFullNmH.AddDat("GPRO", "BIOGRAPHIES, PERSONALITIES, PEOPLE");
155      CatFullNmH.AddDat("GREL", "RELIGION");
156      CatFullNmH.AddDat("GSCI", "SCIENCE AND TECHNOLOGY");
157      CatFullNmH.AddDat("GSPO", "SPORTS");
158      CatFullNmH.AddDat("GTOUR", "TRAVEL AND TOURISM");
159      CatFullNmH.AddDat("GVIO", "WAR, CIVIL WAR");
160      CatFullNmH.AddDat("GVOTE", "ELECTIONS");
161      CatFullNmH.AddDat("GWEA", "WEATHER");
162      CatFullNmH.AddDat("GWELF", "WELFARE, SOCIAL SERVICES");
163      CatFullNmH.AddDat("M11", "EQUITY MARKETS");
164      CatFullNmH.AddDat("M12", "BOND MARKETS");
165      CatFullNmH.AddDat("M13", "MONEY MARKETS");
166      CatFullNmH.AddDat("M131", "INTERBANK MARKETS");
167      CatFullNmH.AddDat("M132", "FOREX MARKETS");
168      CatFullNmH.AddDat("M14", "COMMODITY MARKETS");
169      CatFullNmH.AddDat("M141", "SOFT COMMODITIES");
170      CatFullNmH.AddDat("M142", "METALS TRADING");
171      CatFullNmH.AddDat("M143", "ENERGY MARKETS");
172      CatFullNmH.AddDat("MCAT", "MARKETS");
173      CatFullNmH.AddDat("MEUR", "EURO CURRENCY");
174      CatFullNmH.AddDat("PRB13", "CURRENT NEWS - PRESS RELEASE WIRES");
175  }
176  TFltRect TVizMapContext::GetZoomRect() {
177      if (!ZoomS.Empty()) {
178          return ZoomS.Top();
179      } else {
180          return TFltRect(0.0, 0.0, 1.0, 1.0);
181      }
182  }
183  void TVizMapContext::RenderLandscapeBmp() {
184      if (SelLandscape.Empty()) return;
185      TFltRect ZoomRect = GetZoomRect();
186      const int MaxWidth = SelLandscape->GetXDim();
187      const int MaxHeight = SelLandscape->GetYDim();
188      const int Width = TFlt::Round(ZoomRect.GetXLen()*MaxWidth);
189      const int Height = TFlt::Round(ZoomRect.GetYLen()*MaxHeight);
190      const int LeftX = TFlt::Round(ZoomRect.GetMnX()*MaxWidth);
191      const int TopY = TFlt::Round(ZoomRect.GetMnY()*MaxHeight);
192      if (Width > 0 && Height > 0) {        
193          const TSFltVV& HeightVV = SelLandscape->HeightVV();
194              Assert(SelLandscape->GetLevels() == 2);
195              const double First = SelLandscape->GetLevel(0);
196              const double Second = SelLandscape->GetLevel(1);
197              LandscapeBmp = TGksBitmap::New(Width, Height, ColorLandscapeAbove);
198              for (int X = 0; X < Width; X++) {
199                  for (int Y = 0; Y < Height; Y++) {
200                      double Val = HeightVV(LeftX+X, TopY+Y);
201                      if (Val > Second) { Val = Second + 3*(Val - Second); }
202                      TGksColor PixelColor = ColorLandscapeAbove.Add(
203                          TFlt::Round(Val*34), TFlt::Round(Val*28), TFlt::Round(Val*24));
204                      if (Val > Second) { PixelColor = PixelColor.Add(ColorAddSecondLevel); } 
205                      if (Val > First) { PixelColor = PixelColor.Add(ColorAddFirstLevel); }
206                      LandscapeBmp->SetPixel(X, Y, PixelColor);
207                  }
208              }
209      } else {
210          LandscapeBmp = TGksBitmap::New(1, 1, ColorLandscapeAbove);
211      }
212  }
213  void TVizMapContext::ResetMgGlassSize() { 
214      TFltRect ZoomRect = GetZoomRect();
215      MgGlassSize = 0.2 * TFlt::GetMn(ZoomRect.GetXLen(), ZoomRect.GetYLen()); 
216  }
217  void TVizMapContext::ResetMgGlassKeyWd(const int& MgGlassKeyWds) {
218      MgGlassPoints = VizMapFrame->GenKeyWd(TFltV::GetV(MouseX, MouseY), 
219          MgGlassSize, MgGlassKeyWds, MgGlassKeyWdV, false, false);
220  }
221  void TVizMapContext::ResetKeyWd() {
222      TFltRect ZoomRect = GetZoomRect();
223      const double MnZoomRectSize = TFlt::GetMn(ZoomRect.GetXLen(), ZoomRect.GetYLen());
224      const double Radius = RelRadius * MnZoomRectSize; 
225      VizMapFrame->GenKeyWds(RndKeyWdN, Radius, KeyWdCandidates, 0, ZoomRect); 
226  }
227  void TVizMapContext::ResetNearPointN() {
228      double MnDist = TFlt::Mx;
229      NearPointN = -1;
230      int Points = VizMapFrame->GetPoints();
231      for (int PointN = 0; PointN < Points; PointN++) {
232          PVizMapPoint Point = VizMapFrame->GetPoint(PointN);
233          const double PointX = Point->GetPointX(), PointY = Point->GetPointY();
234          const double Dist = TMath::Sqr(PointX - MouseX) + 
235              TMath::Sqr(PointY - MouseY);
236          if (Dist < MnDist) { MnDist = Dist; NearPointN = PointN; }
237      }
238      if (TMath::Sqrt(MnDist) > 0.1) { NearPointN = -1; }
239  }
240  inline double TVizMapContext::GetMapCoord(const int& ScreenCoord, 
241          const int& ScreenLen, const double& MapMn, const double& MapLen) {
242      return MapMn + MapLen*(double(ScreenCoord)/double(ScreenLen));
243  }
244  inline int TVizMapContext::GetScreenCoord(const double& MapCoord, const double& MapMn, 
245          const double& MapLen, const int& ScreenLen) {
246      return TFlt::Round(ScreenLen * ((MapCoord - MapMn)/MapLen));
247  }
248  int TVizMapContext::GetEncoderClsid(const TStr& EncoderType, CLSID* pClsid) {
249      const int StrLen = EncoderType.Len() + 1;
250      WCHAR* format = new WCHAR[StrLen];
251      const int Res = MultiByteToWideChar(CP_ACP, 0, 
252          EncoderType.CStr(), StrLen, format, StrLen);
253      UINT  num = 0;          
254      UINT  size = 0;         
255      Gdiplus::ImageCodecInfo* pImageCodecInfo = NULL;
256      Gdiplus::GetImageEncodersSize(&num, &size);
257      if (size == 0) { return -1; } 
258      pImageCodecInfo = (Gdiplus::ImageCodecInfo*)(malloc(size));
259      if(pImageCodecInfo == NULL) { return -1; } 
260      Gdiplus::GetImageEncoders(num, size, pImageCodecInfo);
261      for(UINT j = 0; j < num; ++j) {
262          if (wcscmp(pImageCodecInfo[j].MimeType, format) == 0) {
263              *pClsid = pImageCodecInfo[j].Clsid;
264              free(pImageCodecInfo);
265              return j;  
266          }    
267      }
268      free(pImageCodecInfo);
269      return -1;  
270  }
271  void TVizMapContext::ResetFrame() {
272      if (VizMapFrame->GetLandscapes() > 0) {
273          SelLandscape = VizMapFrame->GetLandscape(0); 
274          RenderLandscapeBmp();
275      }
276      ResetKeyWd(); SelPointV.Clr();
277  }
278  TVizMapContext::TVizMapContext(PVizMap _VizMap): 
279          VizMap(_VizMap), VizMapFrameN(0),
280          VizMapFrame(_VizMap->GetFirst()), SelMode(vmsmZoom), 
281          MgGlassPoints(0), MouseInP(false), LeftButtonDownP(false), 
282          MgGlassSize(0.2), NearPointN(-1) { 
283      LoadColor();
284      LoadCatFullNms();
285      ResetFrame();
286  }
287  void TVizMapContext::SetVizMapFrame(const int& NewVizMapFrameN) {
288      VizMapFrameN = NewVizMapFrameN;
289      VizMapFrame = VizMap->GetVizMapFrame(VizMapFrameN);
290      ResetFrame();
291  }
292  void TVizMapContext::SaveVrml(const TStr& VrmlFNm, bool ShowPointNmP, bool ShowKeyWdP) {    
293      VizMapFrame->SaveVrml(VrmlFNm, SelLandscape, ShowPointNmP, !ShowPointNmP,  ShowKeyWdP);
294  }
295  void TVizMapContext::PaintEmpty(PGks Gks) {
296      Gks->SetBrush(TGksBrush::New(ColorLandscapeAbove));
297      Gks->FillRect(-1, -1, Gks->GetWidth()+1, Gks->GetHeight()+1);
298  }
299  void TVizMapContext::Paint(PGks Gks, const bool& ShowPointNmP, const int& PointFontSize,
300          const int& PointNmFontScale, const double& PointWgtThreshold, const int& CatId,
301          const bool& ShowCatNmP, const bool& ShowKeyWdP, const int& KeyWdFontSize, 
302          const bool& ShowMgGlassP, const int& LegendGridWidth, const int& LegendGridHeight) {
303      if (!SelLandscape.Empty()) { PaintLandscape(Gks); } 
304      else { PaintEmpty(Gks); }
305      PaintLegendGrid(Gks, LegendGridWidth, LegendGridHeight);
306      PaintLinks(Gks);
307      TVec<TFltRect> PointNmRectV;
308      if (ShowPointNmP) { 
309          PaintPoints(Gks, PointFontSize, PointNmFontScale, 
310              PointWgtThreshold, CatId, ShowMgGlassP, PointNmRectV); 
311      } else { 
312          PaintPoints(Gks, PointFontSize, PointNmFontScale, 
313              TFlt::Mx, CatId, ShowMgGlassP, PointNmRectV); 
314      }
315      if (ShowCatNmP && !SelLandscape.Empty()) { 
316          PaintCatNms(Gks, KeyWdFontSize, PointNmRectV); };
317      if (ShowKeyWdP) { PaintKeyWds(Gks, KeyWdFontSize, PointNmRectV); }
318      if (LeftButtonDownP) { PaintZoomRect(Gks); }
319      else if (MouseInP && ShowMgGlassP) { PaintMgGlass(Gks, KeyWdFontSize); }
320  }
321  void TVizMapContext::PaintLandscape(PGks Gks){
322      Gks->Bitmap(LandscapeBmp, -1, -1, Gks->GetWidth()+1, Gks->GetHeight()+1);
323  }
324  void TVizMapContext::PaintLegendGrid(PGks Gks, 
325          const int& LegendGridWidth, const int& LegendGridHeight) {
326      Gks->SetPen(TGksPen::New(ColorLegendGridColor));
327      for (int LineN = 1; LineN < LegendGridWidth; LineN++) {
328          const double RelativeWidth = double(LineN) / double(LegendGridWidth);
329          const int X = TFlt::Round(RelativeWidth * Gks->GetWidth());
330          Gks->Line(X, -1, X, Gks->GetHeight());
331      }
332      for (int LineN = 1; LineN < LegendGridHeight; LineN++) {
333          const double RelativeHeight = double(LineN) / double(LegendGridHeight);
334          const int Y = TFlt::Round(RelativeHeight * Gks->GetHeight());
335          Gks->Line(-1, Y, Gks->GetWidth(), Y);
336      }
337  }
338  void TVizMapContext::PaintLinks(PGks Gks) {
339      int Links = VizMapFrame->GetLinks();
340      TFltRect ZoomRect = GetZoomRect();
341      for (int LinkN = 0; LinkN < Links; LinkN++) {
342          PVizMapLink Link = VizMapFrame->GetLink(LinkN);
343          PVizMapPoint SrcPoint = VizMapFrame->GetPoint(Link->GetSrcPointN());
344          PVizMapPoint DstPoint = VizMapFrame->GetPoint(Link->GetDstPointN());
345          const double SrcPointX = SrcPoint->GetPointX(), SrcPointY = SrcPoint->GetPointY();
346          const double DstPointX = DstPoint->GetPointX(), DstPointY = DstPoint->GetPointY();
347          const int SrcX = GetScreenCoord(SrcPointX, ZoomRect.GetMnX(), 
348              ZoomRect.GetXLen(), Gks->GetWidth());
349          const int SrcY = GetScreenCoord(SrcPointY, ZoomRect.GetMnY(), 
350              ZoomRect.GetYLen(), Gks->GetHeight());
351          const int DstX = GetScreenCoord(DstPointX, ZoomRect.GetMnX(), 
352              ZoomRect.GetXLen(), Gks->GetWidth());
353          const int DstY = GetScreenCoord(DstPointY, ZoomRect.GetMnY(), 
354              ZoomRect.GetYLen(), Gks->GetHeight());
355          PaintArrow(Gks, SrcX, SrcY, DstX, DstY, 3);
356      }
357  }
358  void TVizMapContext::PaintArrow(PGks Gks, const int& SrcX, const int& SrcY, 
359          const int& DstX, const int& DstY, const int& Width) {
360      Gks->SetPen(TGksPen::New(ColorLink, gpmCopy, gpsSolid, Width));
361      Gks->Line(SrcX, SrcY, DstX, DstY);
362      TFltV DirectionV = TFltV::GetV(DstX - SrcX, DstY - SrcY); 
363      TLinAlg::Normalize(DirectionV);
364      const int HeadSize = TFlt::Round(2.5*Width); 
365      const double AngleRad = 0.75*TMath::Pi;
366      const int dX1 = TFlt::Round(HeadSize*DirectionV[0]);
367      const int dY1 = TFlt::Round(HeadSize*DirectionV[1]);
368      double dxx, dyy;
369      TLinAlg::Rotate(DirectionV[0], DirectionV[1], AngleRad, dxx, dyy);
370      const int dX2 = TFlt::Round(HeadSize*dxx);
371      const int dY2 = TFlt::Round(HeadSize*dyy);
372      TLinAlg::Rotate(DirectionV[0], DirectionV[1], -AngleRad, dxx, dyy);
373      const int dX3 = TFlt::Round(HeadSize*dxx);
374      const int dY3 = TFlt::Round(HeadSize*dyy);
375      TGksSPointV HeadPointV(3, 0);
376      HeadPointV.Add(TGksSPoint(DstX, DstY));
377      HeadPointV.Add(TGksSPoint(DstX-dX1+dX2, DstY-dY1+dY2));
378      HeadPointV.Add(TGksSPoint(DstX-dX1+dX3, DstY-dY1+dY3)); 
379      Gks->SetBrush(TGksBrush::New(ColorLink));
380      Gks->Polygon(HeadPointV);
381  }
382  void TVizMapContext::PaintPoints(PGks Gks, const int& PointFontSize, 
383          const int& PointNmFontScale, const double& PointWgtThreshold, 
384          const int& CatId, const bool& ShowMgGlassP,
385          TVec<TFltRect>& PointNmRectV) {
386      int Points = VizMapFrame->GetPoints();
387      TFltRect ZoomRect = GetZoomRect();
388      for (int PointN = 0; PointN < Points; PointN++) {
389          PVizMapPoint Point = VizMapFrame->GetPoint(PointN);
390          bool IsSelPointP = SelPointV.IsInBin(PointN);
391          if (IsSelPointP || ((NearPointN == PointN) && !ShowMgGlassP)) { continue; }
392          const double PointX = Point->GetPointX(), PointY = Point->GetPointY();
393          if (ZoomRect.IsXYIn(PointX, PointY)) {
394              const int X = GetScreenCoord(PointX, ZoomRect.GetMnX(), 
395                  ZoomRect.GetXLen(), Gks->GetWidth());
396              const int Y = GetScreenCoord(PointY, ZoomRect.GetMnY(), 
397                  ZoomRect.GetYLen(), Gks->GetHeight());
398              bool IsCatP = Point->IsCatId(CatId);
399              if (Point->IsPointNm() && 
400                  ((Point->GetWgt() > PointWgtThreshold) || IsSelPointP)) {
401                  PointNmRectV.Add(PaintPointNm(Gks, Point, X, Y, 
402                      PointFontSize, PointNmFontScale, IsSelPointP, IsCatP));
403              } else {
404                  PaintPointCross(Gks, X, Y, IsSelPointP, IsCatP);
405              }
406          }
407      }
408      for (int SelPointN = 0; SelPointN < SelPointV.Len(); SelPointN++) {
409          const int PointN = SelPointV[SelPointN];
410          if ((NearPointN == PointN) && !ShowMgGlassP) { continue; }
411          PVizMapPoint Point = VizMapFrame->GetPoint(PointN);
412          const double PointX = Point->GetPointX(), PointY = Point->GetPointY();
413          if (ZoomRect.IsXYIn(PointX, PointY)) {
414              const int X = GetScreenCoord(PointX, ZoomRect.GetMnX(), 
415                  ZoomRect.GetXLen(), Gks->GetWidth());
416              const int Y = GetScreenCoord(PointY, ZoomRect.GetMnY(), 
417                  ZoomRect.GetYLen(), Gks->GetHeight());
418              bool IsCatP = Point->IsCatId(CatId);
419              if (Point->IsPointNm()) {
420                  PointNmRectV.Add(PaintPointNm(Gks, Point, X, Y, 
421                      PointFontSize, PointNmFontScale, true, IsCatP));
422              } else {
423                  PaintPointCross(Gks, X, Y, true, IsCatP);
424              }
425          }
426      }
427      if (!ShowMgGlassP && (NearPointN != -1)) {
428          PVizMapPoint Point = VizMapFrame->GetPoint(NearPointN);
429          const double PointX = Point->GetPointX(), PointY = Point->GetPointY();
430          if (ZoomRect.IsXYIn(PointX, PointY)) {
431              const int X = GetScreenCoord(PointX, ZoomRect.GetMnX(), 
432                  ZoomRect.GetXLen(), Gks->GetWidth());
433              const int Y = GetScreenCoord(PointY, ZoomRect.GetMnY(), 
434                  ZoomRect.GetYLen(), Gks->GetHeight());
435              bool IsCatP = Point->IsCatId(CatId);
436              bool IsSelPointP = SelPointV.IsInBin(NearPointN);
437              if (Point->IsPointNm()) {
438                  PointNmRectV.Add(PaintPointNm(Gks, Point, X, Y, 
439                      PointFontSize, PointNmFontScale, IsSelPointP, IsCatP));
440              } else {
441                  PaintPointCross(Gks, X, Y, IsSelPointP, IsCatP);
442              }
443          }
444      }
445  }
446  void TVizMapContext::PaintPointCross(PGks Gks, const int& X, 
447          const int& Y, const bool& SelPointP, const bool& IsCatP) {
448      Gks->SetPen(TGksPen::New(SelPointP ? ColorSelPointCross : ColorPointCross));
449      Gks->Line(X - SizePointCross, Y - SizePointCross, 
450                X + SizePointCross, Y + SizePointCross);
451      Gks->Line(X - SizePointCross, Y + SizePointCross, 
452                X + SizePointCross, Y - SizePointCross);
453      if (IsCatP) {
454          Gks->Line(X - SizePointCross + 1, Y - SizePointCross, 
455                    X + SizePointCross + 1, Y + SizePointCross);
456          Gks->Line(X - SizePointCross + 1, Y + SizePointCross, 
457                    X + SizePointCross + 1, Y - SizePointCross);
458      }
459  }
460  TFltRect TVizMapContext::PaintPointNm(PGks Gks, PVizMapPoint Point, const int& X, 
461          const int& Y, const int& PointFontSize, const int& PointNmFontScale, 
462          const bool& SelPointP, const bool& IsCatP) {
463      TStr PointNm = Point->GetPointNm(); 
464      PointNm.ChangeChAll('_', ' ');
465      if (PointNm.IsStrIn("[[")) {
466          const int StartPos = PointNm.SearchStr("[[");
467          PointNm = PointNm.Left(StartPos - 1);
468      }
469      TGksColor FontColor = SelPointP ? ColorSelPointFont : ColorPointFont;
470      const int FontSize = PointFontSize + TFlt::Round(Point->GetWgt()*PointNmFontScale);
471      Gks->SetFont(TGksFont::New("ARIAL", FontSize, FontColor));
472      TStr ScreenPointNm = Gks->BreakTxt(PointNm, " ", "", PointNmWidth, PointNmMxLines);
473      const int HalfTxtWidth = Gks->GetTxtWidth(ScreenPointNm) / 2;
474      const int HalfTxtHeight = Gks->GetTxtHeight(ScreenPointNm) / 2;
475      const int MnX = X - HalfTxtWidth;
476      int CurrY = Y - HalfTxtHeight;
<span onclick='openModal()' class='match'>477      TStrV LineV; ScreenPointNm.SplitOnAllCh('\n', LineV);
478      for (int LineN = 0; LineN < LineV.Len(); LineN++) {
479          const int HalfLineWidth = Gks->GetTxtWidth(LineV[LineN]) / 2;
</span>480          const int LineHeight = Gks->GetTxtHeight(LineV[LineN]);
481          Gks->PutTxt(LineV[LineN], MnX + (HalfTxtWidth - HalfLineWidth), CurrY);
482          CurrY += LineHeight-3;
483      }
484      return TFltRect(X - HalfTxtWidth, Y - HalfTxtHeight,
485          X + HalfTxtWidth, Y + HalfTxtHeight - LineV.Len()*3);
486  }
487  void TVizMapContext::PaintCatNms(PGks Gks, const int& KeyWdFontSize, 
488          TVec<TFltRect>& PointNmRectV) {
489      TIntH CatH; TIntFltPrH CatPosH;
490      PBowDocBs BowDocBs = VizMapFrame->GetKeyWdBow();
491      const int Points = VizMapFrame->GetPoints();
492      for (int PointN = 0; PointN < Points; PointN++) {
493          PVizMapPoint Point = VizMapFrame->GetPoint(PointN);
494          const int DId = Point->GetDocId();
495          const int CIds = BowDocBs->GetDocCIds(DId);
496          for (int CIdN = 0; CIdN < CIds; CIdN++) {
497              const int CId = BowDocBs->GetDocCId(DId, CIdN);
498              CatH.AddDat(CId)++;
499              CatPosH.AddDat(CId).Val1 += Point->GetPointX();
500              CatPosH.AddDat(CId).Val2 += Point->GetPointY();
501          }
502      }
503      CatH.SortByDat(false); 
504      const int TopCats = Points > 100 ? 6 : 4; 
505      TFltRect ZoomRect = GetZoomRect();    
506      Gks->SetFont(TGksFont::New("ARIAL", KeyWdFontSize + 3, ColorCatNmFont));
507      TVec<TFltRect> CatNmRectV; TVec<TFltV> CatNmPosV;
508      const int MnSize = TInt::GetMn(Gks->GetWidth(), Gks->GetHeight());
509      const int MnDist = TFlt::Round(0.3 * double(MnSize));
510      int Cats = 0, CatKeyId = CatH.FFirstKeyId();
511      while (CatH.FNextKeyId(CatKeyId)) {
512          if (Cats == TopCats) { break; } 
513          if (double(CatH[CatKeyId]) / double(Points) < 0.05) { break; } 
514          const int CId = CatH.GetKey(CatKeyId);
515          TStr CatNm = BowDocBs->GetCatNm(CId);
516          if (CatFullNmH.IsKey(CatNm)) {
517              CatNm = CatFullNmH.GetDat(CatNm);
518          } else { continue; }
519          TFltPr CatPos = CatPosH.GetDat(CId);
520          const int CatCount = CatH.GetDat(CId); IAssert(CatCount > 0);
521          const double CatX = CatPos.Val1 / double(CatCount);
522          const double CatY = CatPos.Val2 / double(CatCount);
523          if (!ZoomRect.IsXYIn(CatX, CatY)) { continue; }
524          const int HalfTxtWidth = Gks->GetTxtWidth(CatNm) / 2;
525          const int HalfTxtHeight = Gks->GetTxtHeight(CatNm) / 2;
526          const int X = GetScreenCoord(CatX , ZoomRect.GetMnX(), 
527              ZoomRect.GetXLen(), Gks->GetWidth());
528          const int Y = GetScreenCoord(CatY, ZoomRect.GetMnY(), 
529              ZoomRect.GetYLen(), Gks->GetHeight());
530          int CatNmDist = MnSize; TFltV CatNmPos = TFltV::GetV(double(X), double(Y));
531          for (int CatNmPosN = 0; CatNmPosN < CatNmPosV.Len(); CatNmPosN++) {
532              const double Dist = TLinAlg::EuclDist(CatNmPosV[CatNmPosN], CatNmPos);
533              CatNmDist = TInt::GetMn(TFlt::Round(Dist), CatNmDist);
534          }
535          if (CatNmDist < MnDist) { continue; }
536          TFltRect CatNmRect(X - HalfTxtWidth, Y - HalfTxtHeight,
537              X + HalfTxtWidth, Y + HalfTxtHeight);
538          bool DoDraw = true; const int Rects = CatNmRectV.Len();
539          for (int RectN = 0; (RectN < Rects) && DoDraw; RectN++) {
540              DoDraw = !TFltRect::Intersection(CatNmRect, CatNmRectV[RectN]); }
541          if (!DoDraw) { continue; }
542          Gks->PutTxt(CatNm, X - HalfTxtWidth, Y - HalfTxtHeight); 
543          CatNmRectV.Add(CatNmRect); Cats++;
544          CatNmPosV.Add(CatNmPos);
545      }
546      PointNmRectV.AddV(CatNmRectV);
547  }
548  void TVizMapContext::PaintKeyWds(PGks Gks, const int& KeyWdFontSize, 
549          TVec<TFltRect>& PointNmRectV) {
550      Gks->SetFont(TGksFont::New("ARIAL", KeyWdFontSize, ColorKeyWdFont));
551      TFltRect ZoomRect = GetZoomRect();    
552      const double MnZoomRectSize = TFlt::GetMn(ZoomRect.GetXLen(), ZoomRect.GetYLen());
553      const double MnRptDist = RelMnRptDist * MnZoomRectSize;
554      const double Sparsity = RelSparsity * MnZoomRectSize;
555      TVizMapKeyWdV OkKeyWdV;
556      int KeyWds = VizMapFrame->GetKeyWds();
557      for (int KeyWdN = 0; KeyWdN < KeyWds; KeyWdN++) {
558          PVizMapKeyWd KeyWd = VizMapFrame->GetKeyWd(KeyWdN);
559          TStr KeyWdStr = KeyWd->GetKeyWdStr().GetLc();
560          const double KeyWdX = KeyWd->GetKeyWdX();
561          const double KeyWdY = KeyWd->GetKeyWdY();
562          if (ZoomRect.IsXYIn(KeyWdX, KeyWdY)) {
563              const int X = GetScreenCoord(KeyWdX, ZoomRect.GetMnX(), 
564                  ZoomRect.GetXLen(), Gks->GetWidth());
565              const int Y = GetScreenCoord(KeyWdY, ZoomRect.GetMnY(), 
566                  ZoomRect.GetYLen(), Gks->GetHeight());
567              const int HalfTxtWidth = Gks->GetTxtWidth(KeyWdStr) / 2;
568              const int HalfTxtHeight = Gks->GetTxtHeight(KeyWdStr) / 2;
569              TFltRect KeyWdRect(X - HalfTxtWidth, Y - HalfTxtHeight,
570                  X + HalfTxtWidth, Y + HalfTxtHeight);
571              bool DoDrawP = true; const int Rects = PointNmRectV.Len();
572              for (int RectN = 0; RectN < Rects; RectN++) {
573                  if (TFltRect::Intersection(KeyWdRect, PointNmRectV[RectN])) { 
574                      DoDrawP = false; break; }
575              }
576              if (!DoDrawP) { continue; } 
577              TFltV KeyWdCoodV = TFltV::GetV(KeyWdX, KeyWdY);
578              const int OkKeyWds = OkKeyWdV.Len(); bool KeyWdOkP = true;
579              for (int OkKeyWdN = 0; OkKeyWdN < OkKeyWds; OkKeyWdN++) {
580                  PVizMapKeyWd OkKeyWd = OkKeyWdV[OkKeyWdN];
581                  TStr OkKeyWdStr = OkKeyWd->GetKeyWdStr().GetLc();
582                  const double Dist = TLinAlg::EuclDist(KeyWdCoodV, OkKeyWd->GetCoordV());
583                  if (Dist < Sparsity) { KeyWdOkP = false; break; }
584                  if (OkKeyWdStr == KeyWdStr) {
585                      if (Dist < MnRptDist) { KeyWdOkP = false; break; }
586                  }
587              }
588              if (!KeyWdOkP) { continue; } 
589              Gks->PutTxt(KeyWdStr, X - HalfTxtWidth, Y - HalfTxtHeight); 
590              PointNmRectV.Add(KeyWdRect); OkKeyWdV.Add(KeyWd);
591          }
592      }
593  }
594  void TVizMapContext::PaintZoomRect(PGks Gks) {
595      Gks->SetPen(TGksPen::New(ColorZoomRect, gpmCopy, gpsSolid, 2));
596      Gks->FrameRect(DownX, DownY, ScreenX, ScreenY);
597  }
598  void TVizMapContext::PaintMgGlass(PGks Gks, const int& KeyWdFontSize) {
599      TFltRect ZoomRect = GetZoomRect();
600      int SizeX = TFlt::Round((MgGlassSize/ZoomRect.GetXLen()) * Gks->GetWidth());
601      int SizeY = TFlt::Round((MgGlassSize/ZoomRect.GetYLen()) * Gks->GetHeight());
602      Gks->SetBrush(TGksBrush::New(ColorMgGlass));
603      Gks->FillEllipse(ScreenX-SizeX, ScreenY-SizeY, ScreenX+SizeX, ScreenY+SizeY);
604      if (MgGlassKeyWdV.Len() > 0) {
605          Gks->SetFont(TGksFont::New("ARIAL", KeyWdFontSize, TGksColor::GetBlack(), TFSet()|gfsBold));
606          TStr KeyWdStr = Gks->BreakTxt(MgGlassKeyWdV, ", ", ",", MgGlassWindowWidth);       
607          TStr NearPointStr;
608          if (NearPointN != -1) {
609              PVizMapPoint NearPoint = VizMapFrame->GetPoint(NearPointN);
610              if (NearPoint->IsPointNm()) {
611                  TStr NearPointNm = NearPoint->GetPointNm();
612                  if (NearPointNm.IsStrIn("[[")) {
613                      const int StartPos = NearPointNm.SearchStr("[[");
614                      NearPointNm = NearPointNm.Left(StartPos - 1);
615                  }
616                  NearPointStr = Gks->BreakTxt(NearPointNm, 
617                      " ", "", MgGlassWindowWidth, 1);
618                  NearPointStr.DelChAll('\n');
619                  NearPointStr += "\n";
620              }
621          }
622          TStr DocCountStr = "#documents = " + MgGlassPoints.GetStr() + "\n";
623          KeyWdStr = NearPointStr + DocCountStr + KeyWdStr;
624          int WndWidth = Gks->GetTxtWidth(KeyWdStr) + 6;
625          int WndHeight = Gks->GetTxtHeight(KeyWdStr) + 6;
626          int PosX = ScreenX + 20, PosY = ScreenY + 20;
627          if (PosX + WndWidth > Gks->GetWidth()) {
628              PosX = ScreenX - 20 - WndWidth; }
629          if (PosY + WndHeight > Gks->GetHeight()) {
630              PosY = ScreenY - 20 - WndHeight; }
631          Gks->SetBrush(TGksBrush::New(ColorMgGlassWndShadow));
632          Gks->FillRect(PosX + 5, PosY + 5, 
633              PosX + WndWidth + 5, PosY + WndHeight + 5);
634          Gks->SetBrush(TGksBrush::New(ColorMgGlassWnd));
635          Gks->SetPen(TGksPen::New(ColorMgGlassWndFrm));
636          Gks->Rectangle(PosX, PosY, 
637              PosX + WndWidth, PosY + WndHeight);
638          Gks->PutTxt(KeyWdStr, PosX+3, PosY+3);
639      }
640  }
641  void TVizMapContext::Export(const TStr& FNm, const TStr& EncoderType, const int& Width, 
642          const int& Height, const bool& ShowPointNmP, const int& PointFontSize, 
643          const int& PointNmFontScale, const double& PointWgtThreshold, const bool& ShowCatNmP,
644          const bool& ShowKeyWdP, const int& KeyWdFontSize, const bool& ShowMgGlassP, 
645          const int& LegendGridWidth, const int& LegendGridHeight) {
646      Gdiplus::Bitmap* Bmp = new Gdiplus::Bitmap(Width, Height);
647      Gdiplus::Graphics* g = Gdiplus::Graphics::FromImage(Bmp);
648      PGks BmpGks = TWfGks::New();
649      HDC HdcHandle = g->GetHDC(); BmpGks->BeginPaint(HdcHandle);
650      Paint(BmpGks, ShowPointNmP, PointFontSize, PointNmFontScale,
651          PointWgtThreshold, -1, ShowCatNmP, ShowKeyWdP, KeyWdFontSize, ShowMgGlassP, 
652          LegendGridWidth, LegendGridHeight);
653      BmpGks->EndPaint(); g->ReleaseHDC(HdcHandle);
654      WCHAR* FNmWChar = new WCHAR[FNm.Len() + 1];
655      const int Res = MultiByteToWideChar(CP_ACP, 0, 
656          FNm.CStr(), FNm.Len() + 1, FNmWChar, FNm.Len() + 1);
657      CLSID pngClsid; GetEncoderClsid(EncoderType, &pngClsid);
658      Bmp->Save(FNmWChar, &pngClsid, NULL);
659      delete FNmWChar; delete Bmp; delete g;
660  }
661  bool TVizMapContext::MouseMove(const int& X, const int& Y, 
662          const int& Width, const int& Height, const int& MgGlassKeyWds) {
663      const int MoveDiff = TInt::Abs(X - ScreenX) + TInt::Abs(Y - ScreenY);
664      ScreenX = X; ScreenY = Y;
665      TFltRect ZoomRect = GetZoomRect();
666      MouseX = GetMapCoord(X, Width, ZoomRect.GetMnX(), ZoomRect.GetXLen());
667      MouseY = GetMapCoord(Y, Height, ZoomRect.GetMnY(), ZoomRect.GetYLen());
668      if (!LeftButtonDownP && (MoveDiff > 0)) { 
669          ResetMgGlassKeyWd(MgGlassKeyWds);
670          ResetNearPointN();
671      }
672      return (MoveDiff > 0);
673  }
674  void TVizMapContext::MouseLeftDown(const int& X, 
675          const int& Y, const int& Width, const int& Height) {
676      LeftButtonDownP = true;
677      DownX = X; DownY = Y;
678  }
679  void TVizMapContext::MouseLeftUp(const int& X, 
680          const int& Y, const int& Width, const int& Height) {
681      LeftButtonDownP = false;
682      TFltRect ZoomRect = GetZoomRect();
683      MouseX = GetMapCoord(X, Width, ZoomRect.GetMnX(), ZoomRect.GetXLen());
684      MouseY = GetMapCoord(Y, Height, ZoomRect.GetMnY(), ZoomRect.GetYLen());
685      if (TInt::Abs(DownX - X) > 10 && TInt::Abs(DownY - Y) > 10) {
686          const double StartX = GetMapCoord(DownX, Width, ZoomRect.GetMnX(), ZoomRect.GetXLen());
687          const double StartY = GetMapCoord(DownY, Height, ZoomRect.GetMnY(), ZoomRect.GetYLen());
688          if (IsZoomMode()) { 
689              ZoomIn(StartX, StartY, MouseX, MouseY); 
690          } else if (IsSelectMode()) {
691              Select(StartX, StartY, MouseX, MouseY);
692          }
693      } else {
694          SelectDoc(MouseX, MouseY);
695      }
696  }
697  void TVizMapContext::MouseWheel(const int& Degree, const int& MgGlassKeyWds) { 
698      MgGlassSize *= pow(TMath::E / 2, Degree); 
699      if (!LeftButtonDownP) { ResetMgGlassKeyWd(MgGlassKeyWds); }
700  }
701  void TVizMapContext::ZoomIn(const double& X1, const double& Y1, const double& X2, const double& Y2) { 
702      ZoomIn(TFltRect(TFlt::GetMn(X1, X2), TFlt::GetMn(Y1, Y2),
703                      TFlt::GetMx(X1, X2), TFlt::GetMx(Y1, Y2))); 
704  }
705  void TVizMapContext::ZoomIn(const TFltRect& ZoomInRect) { 
706      ZoomS.Push(ZoomInRect); 
707      RenderLandscapeBmp();
708      ResetMgGlassSize();
709      ResetKeyWd();
710  }
711  bool TVizMapContext::ZoomOut() { 
712      if (!ZoomS.Empty()) { 
713          ZoomS.Pop(); 
714          RenderLandscapeBmp(); 
715          ResetMgGlassSize();
716          ResetKeyWd();
717          return true;
718      } 
719      return false;
720  }
721  bool TVizMapContext::ZoomAll() { 
722      if (!ZoomS.Empty()) { 
723          ZoomS.Clr(); 
724          RenderLandscapeBmp(); 
725          ResetMgGlassSize();
726          ResetKeyWd();
727          return true;
728      }
729      return false;
730  }
731  void TVizMapContext::Select(const double& X1, const double& Y1, const double& X2, const double& Y2) {
732      Select(TFltRect(TFlt::GetMn(X1, X2), TFlt::GetMn(Y1, Y2),
733                      TFlt::GetMx(X1, X2), TFlt::GetMx(Y1, Y2)));
734  }
735  void TVizMapContext::Select(const TFltRect& SelRect) {
736      TIntV NewSelPointV; 
737      if (VizMapFrame->GetRectPointV(SelRect, NewSelPointV) > 0) {
738          SelPointV.Union(NewSelPointV);
739      }
740  }
741  void TVizMapContext::Select(const int& DocId) {
742      SelPointV.Clr();
743      int Points = VizMapFrame->GetPoints();
744      for (int PointN = 0; PointN < Points; PointN++) {
745          PVizMapPoint Point = VizMapFrame->GetPoint(PointN);
746          if (Point->IsDocId() && Point->GetDocId() == DocId) {
747              SelPointV.Add(PointN); break;
748          }
749      }
750      if (SelPointV.Empty()) {
751          const int Frames = VizMap->GetVizMapFrames();
752          for (int FrameN = 0; FrameN < Frames; FrameN++) {
753              if (FrameN == VizMapFrameN) { continue; }
754              PVizMapFrame OtherFrame = VizMap->GetVizMapFrame(FrameN);
755              int Points = OtherFrame->GetPoints();
756              for (int PointN = 0; PointN < Points; PointN++) {
757                  PVizMapPoint Point = OtherFrame->GetPoint(PointN);
758                  if (Point->IsDocId() && Point->GetDocId() == DocId) {
759                      SelPointV.Add(PointN); SetVizMapFrame(FrameN); break;
760                  }
761              }
762          }
763      }
764  }
765  void TVizMapContext::GetSelectDIdV(TIntV& DIdV) {
766      DIdV.Gen(SelPointV.Len(), 0);
767      const int SelPoints = SelPointV.Len();
768      for (int SelPointN = 0; SelPointN < SelPoints; SelPointN++) {
769          DIdV.Add(VizMapFrame->GetPoint(SelPointV[SelPointN])->GetDocId());
770      }
771  }
772  void TVizMapContext::UnselectAll() {
773      SelPointV.Clr();
774  }
775  void TVizMapContext::SelectDoc(const double& DocX, const double& DocY) {
776      const int PointN = VizMapFrame->GetPointN(TFltV::GetV(DocX, DocY), 1.5);
777      if (IsZoomMode()) { 
778          if (PointN != -1) { 
779              SelPointV = TIntV::GetV(PointN); 
780          } else { 
781              SelPointV.Clr(); 
782          }
783      } else if (IsSelectMode()) {
784          if (PointN != -1) { 
785              if (SelPointV.IsInBin(PointN)) {
786                  SelPointV.DelIfIn(PointN);
787              } else {
788                  SelPointV.AddSorted(PointN); 
789              }
790          }
791      }
792  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-svmmodels.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-vizmapgks.cpp</div>
                </div>
                <div class="column column_space"><pre><code>1296      TStrV EltV; Str.SplitOnAllCh(';', EltV);
1297      for (int EltN = 0; EltN < EltV.Len(); EltN++) {
1298          FtrGen.Update(EltV[EltN]);
</pre></code></div>
                <div class="column column_space"><pre><code>477      TStrV LineV; ScreenPointNm.SplitOnAllCh('\n', LineV);
478      for (int LineN = 0; LineN < LineV.Len(); LineN++) {
479          const int HalfLineWidth = Gks->GetTxtWidth(LineV[LineN]) / 2;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    