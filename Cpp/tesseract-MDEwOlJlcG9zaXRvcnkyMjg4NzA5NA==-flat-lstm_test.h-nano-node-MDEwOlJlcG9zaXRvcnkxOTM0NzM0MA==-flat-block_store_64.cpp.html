
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 5.641025641025641%, Tokens: 11</h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-lstm_test.h</h3>
            <pre><code>1  #ifndef TESSERACT_UNITTEST_LSTM_TEST_H_
2  #define TESSERACT_UNITTEST_LSTM_TEST_H_
3  #include <memory>
4  #include <string>
5  #include <utility>
6  #include "include_gunit.h"
7  #include "helpers.h"
8  #include "tprintf.h"
9  #include "functions.h"
10  #include "lang_model_helpers.h"
11  #include "log.h" 
12  #include "lstmtrainer.h"
13  #include "unicharset.h"
14  namespace tesseract {
15  #if DEBUG_DETAIL == 0
16  const int kTrainerIterations = 600;
17  const int kBatchIterations = 100;
18  #else
19  const int kTrainerIterations = 2;
20  const int kBatchIterations = 1;
21  #endif
22  class LSTMTrainerTest : public testing::Test {
23  protected:
24    void SetUp() override {
25      std::locale::global(std::locale(""));
26      file::MakeTmpdir();
27    }
28    LSTMTrainerTest() = default;
29    std::string TestDataNameToPath(const std::string &name) {
30      return file::JoinPath(TESTDATA_DIR, "" + name);
31    }
<span onclick='openModal()' class='match'>32    std::string TessDataNameToPath(const std::string &name) {
33      return file::JoinPath(TESSDATA_DIR, "" + name);
34    }
35    std::string TestingNameToPath(const std::string &name) {
36      return file::JoinPath(TESTING_DIR, "" + name);
37    }
38    void SetupTrainerEng(const std::string &network_spec, const std::string &model_name, bool recode,
39                         bool adam) {
</span>40      SetupTrainer(network_spec, model_name, "eng/eng.unicharset", "eng.Arial.exp0.lstmf", recode,
41                   adam, 5e-4, false, "eng");
42    }
43    void SetupTrainer(const std::string &network_spec, const std::string &model_name,
44                      const std::string &unicharset_file, const std::string &lstmf_file, bool recode,
45                      bool adam, float learning_rate, bool layer_specific, const std::string &kLang) {
46      std::string unicharset_name = TestDataNameToPath(unicharset_file);
47      UNICHARSET unicharset;
48      ASSERT_TRUE(unicharset.load_from_file(unicharset_name.c_str(), false));
49      std::string script_dir = file::JoinPath(LANGDATA_DIR, "");
50      std::vector<std::string> words;
51      EXPECT_EQ(0, CombineLangModel(unicharset, script_dir, "", FLAGS_test_tmpdir, kLang, !recode,
52                                    words, words, words, false, nullptr, nullptr));
53      std::string model_path = file::JoinPath(FLAGS_test_tmpdir, model_name);
54      std::string checkpoint_path = model_path + "_checkpoint";
55      trainer_ = std::make_unique<LSTMTrainer>(model_path.c_str(), checkpoint_path.c_str(), 0, 0);
56      trainer_->InitCharSet(
57          file::JoinPath(FLAGS_test_tmpdir, kLang, kLang) + ".traineddata");
58      int net_mode = adam ? NF_ADAM : 0;
59      if (adam) {
60        learning_rate *= 20.0f;
61      }
62      if (layer_specific) {
63        net_mode |= NF_LAYER_SPECIFIC_LR;
64      }
65      EXPECT_TRUE(
66          trainer_->InitNetwork(network_spec.c_str(), -1, net_mode, 0.1, learning_rate, 0.9, 0.999));
67      std::vector<std::string> filenames;
68      filenames.emplace_back(TestDataNameToPath(lstmf_file).c_str());
69      EXPECT_TRUE(trainer_->LoadAllTrainingData(filenames, CS_SEQUENTIAL, false));
70      LOG(INFO) << "Setup network:" << model_name << "\n";
71    }
72    double TrainIterations(int max_iterations) {
73      int iteration = trainer_->training_iteration();
74      int iteration_limit = iteration + max_iterations;
75      double best_error = 100.0;
76      do {
77        std::stringstream log_str;
78        int target_iteration = iteration + kBatchIterations;
79        double mean_error = 0.0;
80        while (iteration < target_iteration && iteration < iteration_limit) {
81          trainer_->TrainOnLine(trainer_.get(), false);
82          iteration = trainer_->training_iteration();
83          mean_error += trainer_->LastSingleError(ET_CHAR_ERROR);
84        }
85        trainer_->MaintainCheckpoints(nullptr, log_str);
86        iteration = trainer_->training_iteration();
87        mean_error *= 100.0 / kBatchIterations;
88        if (mean_error < best_error) {
89          best_error = mean_error;
90        }
91      } while (iteration < iteration_limit);
92      LOG(INFO) << "Trainer error rate = " << best_error << "\n";
93      return best_error;
94    }
95    double TestIterations(int max_iterations) {
96      CHECK_GT(max_iterations, 0);
97      int iteration = trainer_->sample_iteration();
98      double mean_error = 0.0;
99      int error_count = 0;
100      while (error_count < max_iterations) {
101        const ImageData &trainingdata =
102            *trainer_->mutable_training_data()->GetPageBySerial(iteration);
103        NetworkIO fwd_outputs, targets;
104        if (trainer_->PrepareForBackward(&trainingdata, &fwd_outputs, &targets) != UNENCODABLE) {
105          mean_error += trainer_->NewSingleError(ET_CHAR_ERROR);
106          ++error_count;
107        }
108        trainer_->SetIteration(++iteration);
109      }
110      mean_error *= 100.0 / max_iterations;
111      LOG(INFO) << "Tester error rate = " << mean_error << "\n";
112      return mean_error;
113    }
114    double TestIntMode(int test_iterations) {
115      std::vector<char> trainer_data;
116      EXPECT_TRUE(trainer_->SaveTrainingDump(NO_BEST_TRAINER, *trainer_, &trainer_data));
117      double float_err = TestIterations(test_iterations);
118      EXPECT_TRUE(trainer_->ReadTrainingDump(trainer_data, *trainer_));
119      trainer_->ConvertToInt();
120      double int_err = TestIterations(test_iterations);
121      EXPECT_LT(int_err, float_err + 1.0);
122      return int_err - float_err;
123    }
124    void TestEncodeDecode(const std::string &lang, const std::string &str, bool recode) {
125      std::string unicharset_name = lang + "/" + lang + ".unicharset";
126      std::string lstmf_name = lang + ".Arial_Unicode_MS.exp0.lstmf";
127      SetupTrainer("[1,1,0,32 Lbx100 O1c1]", "bidi-lstm", unicharset_name, lstmf_name, recode, true,
128                   5e-4f, true, lang);
129      std::vector<int> labels;
130      EXPECT_TRUE(trainer_->EncodeString(str.c_str(), &labels));
131      std::string decoded = trainer_->DecodeLabels(labels);
132      std::string decoded_str(&decoded[0], decoded.length());
133      EXPECT_EQ(str, decoded_str);
134    }
135    void TestEncodeDecodeBoth(const std::string &lang, const std::string &str) {
136      TestEncodeDecode(lang, str, false);
137      TestEncodeDecode(lang, str, true);
138    }
139    std::unique_ptr<LSTMTrainer> trainer_;
140  };
141  } 
142  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-block_store_64.cpp</h3>
            <pre><code>1  #include <nano/node/rocksdb/block_store.hpp>
2  #include <nano/node/rocksdb/rocksdb.hpp>
3  #include <nano/secure/parallel_traversal.hpp>
4  namespace nano
5  {
6  class block_predecessor_rocksdb_set : public nano::block_visitor
7  {
8  public:
9  	block_predecessor_rocksdb_set (nano::write_transaction const & transaction_a, nano::rocksdb::block_store & block_store_a);
10  	virtual ~block_predecessor_rocksdb_set () = default;
11  	void fill_value (nano::block const & block_a);
12  	void send_block (nano::send_block const & block_a) override;
13  	void receive_block (nano::receive_block const & block_a) override;
14  	void open_block (nano::open_block const & block_a) override;
15  	void change_block (nano::change_block const & block_a) override;
16  	void state_block (nano::state_block const & block_a) override;
17  	nano::write_transaction const & transaction;
18  	nano::rocksdb::block_store & block_store;
19  };
20  }
21  nano::rocksdb::block_store::block_store (nano::rocksdb::store & store_a) :
22  	store{ store_a } {};
23  void nano::rocksdb::block_store::put (nano::write_transaction const & transaction, nano::block_hash const & hash, nano::block const & block)
24  {
25  	debug_assert (block.sideband ().successor.is_zero () || exists (transaction, block.sideband ().successor));
26  	std::vector<uint8_t> vector;
27  	{
28  		nano::vectorstream stream (vector);
29  		nano::serialize_block (stream, block);
30  		block.sideband ().serialize (stream, block.type ());
31  	}
32  	raw_put (transaction, vector, hash);
33  	block_predecessor_rocksdb_set predecessor (transaction, *this);
34  	block.visit (predecessor);
35  	debug_assert (block.previous ().is_zero () || successor (transaction, block.previous ()) == hash);
36  }
37  void nano::rocksdb::block_store::raw_put (nano::write_transaction const & transaction_a, std::vector<uint8_t> const & data, nano::block_hash const & hash_a)
38  {
39  	nano::rocksdb_val value{ data.size (), (void *)data.data () };
40  	auto status = store.put (transaction_a, tables::blocks, hash_a, value);
41  	store.release_assert_success (status);
42  }
43  nano::block_hash nano::rocksdb::block_store::successor (nano::transaction const & transaction_a, nano::block_hash const & hash_a) const
44  {
45  	nano::rocksdb_val value;
46  	block_raw_get (transaction_a, hash_a, value);
47  	nano::block_hash result;
48  	if (value.size () != 0)
49  	{
50  		debug_assert (value.size () >= result.bytes.size ());
51  		auto type = block_type_from_raw (value.data ());
52  		nano::bufferstream stream (reinterpret_cast<uint8_t const *> (value.data ()) + block_successor_offset (transaction_a, value.size (), type), result.bytes.size ());
53  		auto error (nano::try_read (stream, result.bytes));
54  		(void)error;
55  		debug_assert (!error);
56  	}
57  	else
58  	{
59  		result.clear ();
60  	}
61  	return result;
62  }
63  void nano::rocksdb::block_store::successor_clear (nano::write_transaction const & transaction, nano::block_hash const & hash)
64  {
65  	nano::rocksdb_val value;
66  	block_raw_get (transaction, hash, value);
67  	debug_assert (value.size () != 0);
68  	auto type = block_type_from_raw (value.data ());
69  	std::vector<uint8_t> data (static_cast<uint8_t *> (value.data ()), static_cast<uint8_t *> (value.data ()) + value.size ());
70  	std::fill_n (data.begin () + block_successor_offset (transaction, value.size (), type), sizeof (nano::block_hash), uint8_t{ 0 });
71  	raw_put (transaction, data, hash);
72  }
73  std::shared_ptr<nano::block> nano::rocksdb::block_store::get (nano::transaction const & transaction, nano::block_hash const & hash) const
74  {
75  	nano::rocksdb_val value;
76  	block_raw_get (transaction, hash, value);
77  	std::shared_ptr<nano::block> result;
78  	if (value.size () != 0)
79  	{
80  		nano::bufferstream stream (reinterpret_cast<uint8_t const *> (value.data ()), value.size ());
81  		nano::block_type type;
82  		auto error (try_read (stream, type));
83  		release_assert (!error);
84  		result = nano::deserialize_block (stream, type);
85  		release_assert (result != nullptr);
86  		nano::block_sideband sideband;
87  		error = (sideband.deserialize (stream, type));
88  		release_assert (!error);
89  		result->sideband_set (sideband);
90  	}
91  	return result;
92  }
93  std::shared_ptr<nano::block> nano::rocksdb::block_store::get_no_sideband (nano::transaction const & transaction, nano::block_hash const & hash) const
94  {
95  	nano::rocksdb_val value;
96  	block_raw_get (transaction, hash, value);
97  	std::shared_ptr<nano::block> result;
98  	if (value.size () != 0)
99  	{
100  		nano::bufferstream stream (reinterpret_cast<uint8_t const *> (value.data ()), value.size ());
101  		result = nano::deserialize_block (stream);
102  		debug_assert (result != nullptr);
103  	}
104  	return result;
105  }
106  std::shared_ptr<nano::block> nano::rocksdb::block_store::random (nano::transaction const & transaction)
107  {
108  	nano::block_hash hash;
109  	nano::random_pool::generate_block (hash.bytes.data (), hash.bytes.size ());
110  	auto existing = begin (transaction, hash);
111  	if (existing == end ())
112  	{
113  		existing = begin (transaction);
114  	}
115  	debug_assert (existing != end ());
116  	return existing->second.block;
117  }
118  void nano::rocksdb::block_store::del (nano::write_transaction const & transaction_a, nano::block_hash const & hash_a)
119  {
120  	auto status = store.del (transaction_a, tables::blocks, hash_a);
121  	store.release_assert_success (status);
122  }
123  bool nano::rocksdb::block_store::exists (nano::transaction const & transaction, nano::block_hash const & hash)
124  {
125  	nano::rocksdb_val junk;
126  	block_raw_get (transaction, hash, junk);
127  	return junk.size () != 0;
128  }
129  uint64_t nano::rocksdb::block_store::count (nano::transaction const & transaction_a)
130  {
131  	return store.count (transaction_a, tables::blocks);
132  }
133  nano::account nano::rocksdb::block_store::account (nano::transaction const & transaction_a, nano::block_hash const & hash_a) const
134  {
135  	auto block (get (transaction_a, hash_a));
136  	debug_assert (block != nullptr);
137  	return account_calculated (*block);
138  }
139  nano::account nano::rocksdb::block_store::account_calculated (nano::block const & block_a) const
140  {
141  	debug_assert (block_a.has_sideband ());
142  	nano::account result (block_a.account ());
143  	if (result.is_zero ())
144  	{
145  		result = block_a.sideband ().account;
146  	}
147  	debug_assert (!result.is_zero ());
148  	return result;
149  }
150  nano::store_iterator<nano::block_hash, nano::block_w_sideband> nano::rocksdb::block_store::begin (nano::transaction const & transaction) const
151  {
152  	return store.make_iterator<nano::block_hash, nano::block_w_sideband> (transaction, tables::blocks);
153  }
<span onclick='openModal()' class='match'>154  nano::store_iterator<nano::block_hash, nano::block_w_sideband> nano::rocksdb::block_store::begin (nano::transaction const & transaction, nano::block_hash const & hash) const
155  {
156  	return store.make_iterator<nano::block_hash, nano::block_w_sideband> (transaction, tables::blocks, hash);
157  }
158  nano::store_iterator<nano::block_hash, nano::block_w_sideband> nano::rocksdb::block_store::end () const
159  {
160  	return nano::store_iterator<nano::block_hash, nano::block_w_sideband> (nullptr);
161  }
162  nano::uint128_t nano::rocksdb::block_store::balance (nano::transaction const & transaction_a, nano::block_hash const & hash_a)
163  {
</span>164  	auto block (get (transaction_a, hash_a));
165  	release_assert (block);
166  	nano::uint128_t result (balance_calculated (block));
167  	return result;
168  }
169  nano::uint128_t nano::rocksdb::block_store::balance_calculated (std::shared_ptr<nano::block> const & block_a) const
170  {
171  	nano::uint128_t result;
172  	switch (block_a->type ())
173  	{
174  		case nano::block_type::open:
175  		case nano::block_type::receive:
176  		case nano::block_type::change:
177  			result = block_a->sideband ().balance.number ();
178  			break;
179  		case nano::block_type::send:
180  			result = boost::polymorphic_downcast<nano::send_block *> (block_a.get ())->hashables.balance.number ();
181  			break;
182  		case nano::block_type::state:
183  			result = boost::polymorphic_downcast<nano::state_block *> (block_a.get ())->hashables.balance.number ();
184  			break;
185  		case nano::block_type::invalid:
186  		case nano::block_type::not_a_block:
187  			release_assert (false);
188  			break;
189  	}
190  	return result;
191  }
192  nano::epoch nano::rocksdb::block_store::version (nano::transaction const & transaction_a, nano::block_hash const & hash_a)
193  {
194  	auto block = get (transaction_a, hash_a);
195  	if (block && block->type () == nano::block_type::state)
196  	{
197  		return block->sideband ().details.epoch;
198  	}
199  	return nano::epoch::epoch_0;
200  }
201  void nano::rocksdb::block_store::for_each_par (std::function<void (nano::read_transaction const &, nano::store_iterator<nano::block_hash, block_w_sideband>, nano::store_iterator<nano::block_hash, block_w_sideband>)> const & action_a) const
202  {
203  	parallel_traversal<nano::uint256_t> (
204  	[&action_a, this] (nano::uint256_t const & start, nano::uint256_t const & end, bool const is_last) {
205  		auto transaction (this->store.tx_begin_read ());
206  		action_a (transaction, this->begin (transaction, start), !is_last ? this->begin (transaction, end) : this->end ());
207  	});
208  }
209  uint64_t nano::rocksdb::block_store::account_height (nano::transaction const & transaction_a, nano::block_hash const & hash_a) const
210  {
211  	auto block = get (transaction_a, hash_a);
212  	return block->sideband ().height;
213  }
214  void nano::rocksdb::block_store::block_raw_get (nano::transaction const & transaction, nano::block_hash const & hash, nano::rocksdb_val & value) const
215  {
216  	auto status = store.get (transaction, tables::blocks, hash, value);
217  	release_assert (store.success (status) || store.not_found (status));
218  }
219  size_t nano::rocksdb::block_store::block_successor_offset (nano::transaction const & transaction_a, size_t entry_size_a, nano::block_type type_a) const
220  {
221  	return entry_size_a - nano::block_sideband::size (type_a);
222  }
223  nano::block_type nano::rocksdb::block_store::block_type_from_raw (void * data_a)
224  {
225  	return static_cast<nano::block_type> ((reinterpret_cast<uint8_t const *> (data_a))[0]);
226  }
227  nano::block_predecessor_rocksdb_set::block_predecessor_rocksdb_set (nano::write_transaction const & transaction_a, nano::rocksdb::block_store & block_store_a) :
228  	transaction{ transaction_a },
229  	block_store{ block_store_a }
230  {
231  }
232  void nano::block_predecessor_rocksdb_set::fill_value (nano::block const & block_a)
233  {
234  	auto hash = block_a.hash ();
235  	nano::rocksdb_val value;
236  	block_store.block_raw_get (transaction, block_a.previous (), value);
237  	debug_assert (value.size () != 0);
238  	auto type = block_store.block_type_from_raw (value.data ());
239  	std::vector<uint8_t> data (static_cast<uint8_t *> (value.data ()), static_cast<uint8_t *> (value.data ()) + value.size ());
240  	std::copy (hash.bytes.begin (), hash.bytes.end (), data.begin () + block_store.block_successor_offset (transaction, value.size (), type));
241  	block_store.raw_put (transaction, data, block_a.previous ());
242  }
243  void nano::block_predecessor_rocksdb_set::send_block (nano::send_block const & block_a)
244  {
245  	fill_value (block_a);
246  }
247  void nano::block_predecessor_rocksdb_set::receive_block (nano::receive_block const & block_a)
248  {
249  	fill_value (block_a);
250  }
251  void nano::block_predecessor_rocksdb_set::open_block (nano::open_block const & block_a)
252  {
253  }
254  void nano::block_predecessor_rocksdb_set::change_block (nano::change_block const & block_a)
255  {
256  	fill_value (block_a);
257  }
258  void nano::block_predecessor_rocksdb_set::state_block (nano::state_block const & block_a)
259  {
260  	if (!block_a.previous ().is_zero ())
261  	{
262  		fill_value (block_a);
263  	}
264  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-lstm_test.h</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-block_store_64.cpp</div>
                <div class="column column_space"><pre><code>32    std::string TessDataNameToPath(const std::string &name) {
33      return file::JoinPath(TESSDATA_DIR, "" + name);
34    }
35    std::string TestingNameToPath(const std::string &name) {
36      return file::JoinPath(TESTING_DIR, "" + name);
37    }
38    void SetupTrainerEng(const std::string &network_spec, const std::string &model_name, bool recode,
39                         bool adam) {
</pre></code></div>
                <div class="column column_space"><pre><code>154  nano::store_iterator<nano::block_hash, nano::block_w_sideband> nano::rocksdb::block_store::begin (nano::transaction const & transaction, nano::block_hash const & hash) const
155  {
156  	return store.make_iterator<nano::block_hash, nano::block_w_sideband> (transaction, tables::blocks, hash);
157  }
158  nano::store_iterator<nano::block_hash, nano::block_w_sideband> nano::rocksdb::block_store::end () const
159  {
160  	return nano::store_iterator<nano::block_hash, nano::block_w_sideband> (nullptr);
161  }
162  nano::uint128_t nano::rocksdb::block_store::balance (nano::transaction const & transaction_a, nano::block_hash const & hash_a)
163  {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    