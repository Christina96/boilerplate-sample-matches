
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-interfaces.cpp</h3>
            <pre><code>1  #include &lt;iostream&gt;
2  #include &lt;string&gt;
3  #include &lt;mutex&gt;
4  #include &lt;numeric&gt;
5  #include &lt;inja.hpp&gt;
6  #include &lt;yaml-cpp/yaml.h&gt;
7  #include &quot;../config/binding.h&quot;
8  #include &quot;../generator/config/nodemanip.h&quot;
9  #include &quot;../generator/config/ruleconvert.h&quot;
10  #include &quot;../generator/config/subexport.h&quot;
11  #include &quot;../generator/template/templates.h&quot;
12  #include &quot;../script/cron.h&quot;
13  #include &quot;../script/script_quickjs.h&quot;
14  #include &quot;../server/webserver.h&quot;
15  #include &quot;../utils/base64/base64.h&quot;
16  #include &quot;../utils/file_extra.h&quot;
17  #include &quot;../utils/ini_reader/ini_reader.h&quot;
18  #include &quot;../utils/logger.h&quot;
19  #include &quot;../utils/network.h&quot;
20  #include &quot;../utils/regexp.h&quot;
21  #include &quot;../utils/stl_extra.h&quot;
22  #include &quot;../utils/string.h&quot;
23  #include &quot;../utils/string_hash.h&quot;
24  #include &quot;../utils/system.h&quot;
25  #include &quot;../utils/system.h&quot;
26  #include &quot;../utils/urlencode.h&quot;
27  #include &quot;../utils/yamlcpp_extra.h&quot;
28  #include &quot;interfaces.h&quot;
29  #include &quot;multithread.h&quot;
30  #include &quot;settings.h&quot;
31  #include &quot;upload.h&quot;
32  #include &quot;webget.h&quot;
33  extern WebServer webServer;
34  string_array gRegexBlacklist = {&quot;(.*)*&quot;};
35  void refreshRulesets(RulesetConfigs &amp;ruleset_list, std::vector&lt;RulesetContent&gt; &amp;ruleset_content_array);
36  std::string parseProxy(const std::string &amp;source)
37  {
38      std::string proxy = source;
39      if(source == &quot;SYSTEM&quot;)
40          proxy = getSystemProxy();
41      else if(source == &quot;NONE&quot;)
42          proxy = &quot;&quot;;
43      return proxy;
44  }
45  extern string_array ClashRuleTypes, SurgeRuleTypes, QuanXRuleTypes;
46  struct UAProfile
47  {
48      std::string head;
49      std::string version_match;
50      std::string version_target;
51      std::string target;
52      tribool clash_new_name = tribool();
53      int surge_ver = -1;
54  };
55  const std::vector&lt;UAProfile&gt; UAMatchList = {
56      {&quot;ClashForAndroid&quot;,&quot;\\/([0-9.]+)&quot;,&quot;2.0&quot;,&quot;clash&quot;,true},
57      {&quot;ClashForAndroid&quot;,&quot;\\/([0-9.]+)R&quot;,&quot;&quot;,&quot;clashr&quot;,false},
58      {&quot;ClashForAndroid&quot;,&quot;&quot;,&quot;&quot;,&quot;clash&quot;,false},
59      {&quot;ClashforWindows&quot;,&quot;\\/([0-9.]+)&quot;,&quot;0.11&quot;,&quot;clash&quot;,true},
60      {&quot;ClashforWindows&quot;,&quot;&quot;,&quot;&quot;,&quot;clash&quot;,false},
61      {&quot;ClashX Pro&quot;,&quot;&quot;,&quot;&quot;,&quot;clash&quot;,true},
62      {&quot;ClashX&quot;,&quot;\\/([0-9.]+)&quot;,&quot;0.13&quot;,&quot;clash&quot;,true},
63      {&quot;Clash&quot;,&quot;&quot;,&quot;&quot;,&quot;clash&quot;,true},
64      {&quot;Kitsunebi&quot;,&quot;&quot;,&quot;&quot;,&quot;v2ray&quot;},
65      {&quot;Loon&quot;,&quot;&quot;,&quot;&quot;,&quot;loon&quot;},
66      {&quot;Pharos&quot;,&quot;&quot;,&quot;&quot;,&quot;mixed&quot;},
67      {&quot;Potatso&quot;,&quot;&quot;,&quot;&quot;,&quot;mixed&quot;},
68      {&quot;Quantumult%20X&quot;,&quot;&quot;,&quot;&quot;,&quot;quanx&quot;},
69      {&quot;Quantumult&quot;,&quot;&quot;,&quot;&quot;,&quot;quan&quot;},
70      {&quot;Qv2ray&quot;,&quot;&quot;,&quot;&quot;,&quot;v2ray&quot;},
71      {&quot;Shadowrocket&quot;,&quot;&quot;,&quot;&quot;,&quot;mixed&quot;},
72      {&quot;Surfboard&quot;,&quot;&quot;,&quot;&quot;,&quot;surfboard&quot;},
73      {&quot;Surge&quot;,&quot;\\/([0-9.]+).*x86&quot;,&quot;906&quot;,&quot;surge&quot;,false,4}, 
74      {&quot;Surge&quot;,&quot;\\/([0-9.]+).*x86&quot;,&quot;368&quot;,&quot;surge&quot;,false,3}, 
75      {&quot;Surge&quot;,&quot;\\/([0-9.]+)&quot;,&quot;1419&quot;,&quot;surge&quot;,false,4}, 
76      {&quot;Surge&quot;,&quot;\\/([0-9.]+)&quot;,&quot;900&quot;,&quot;surge&quot;,false,3}, 
77      {&quot;Surge&quot;,&quot;&quot;,&quot;&quot;,&quot;surge&quot;,false,2}, 
78      {&quot;Trojan-Qt5&quot;,&quot;&quot;,&quot;&quot;,&quot;trojan&quot;},
79      {&quot;V2rayU&quot;,&quot;&quot;,&quot;&quot;,&quot;v2ray&quot;},
80      {&quot;V2RayX&quot;,&quot;&quot;,&quot;&quot;,&quot;v2ray&quot;}
81  };
82  bool verGreaterEqual(const std::string &amp;src_ver, const std::string &amp;target_ver)
83  {
84      string_size src_pos_beg = 0, src_pos_end, target_pos_beg = 0, target_pos_end;
85      while(true)
86      {
87          src_pos_end = src_ver.find(&#x27;.&#x27;, src_pos_beg);
88          if(src_pos_end == src_ver.npos)
89              src_pos_end = src_ver.size();
90          int part_src = std::stoi(src_ver.substr(src_pos_beg, src_pos_end - src_pos_beg));
91          target_pos_end = target_ver.find(&#x27;.&#x27;, target_pos_beg);
92          if(target_pos_end == target_ver.npos)
93              target_pos_end = target_ver.size();
94          int part_target = std::stoi(target_ver.substr(target_pos_beg, target_pos_end - target_pos_beg));
95          if(part_src &gt; part_target)
96              break;
97          else if(part_src &lt; part_target)
98              return false;
99          else if(src_pos_end &gt;= src_ver.size() - 1 || target_pos_end &gt;= target_ver.size() - 1)
100              break;
101          src_pos_beg = src_pos_end + 1;
102          target_pos_beg = target_pos_end + 1;
103      }
104      return true;
105  }
106  void matchUserAgent(const std::string &amp;user_agent, std::string &amp;target, tribool &amp;clash_new_name, int &amp;surge_ver)
107  {
108      if(user_agent.empty())
109          return;
110      for(const UAProfile &amp;x : UAMatchList)
111      {
112          if(startsWith(user_agent, x.head))
113          {
114              if(!x.version_match.empty())
115              {
116                  std::string version;
117                  if(regGetMatch(user_agent, x.version_match, 2, 0, &amp;version))
118                      continue;
119                  if(!x.version_target.empty() &amp;&amp; !verGreaterEqual(version, x.version_target))
120                      continue;
121              }
122              target = x.target;
123              clash_new_name = x.clash_new_name;
124              if(x.surge_ver != -1)
125                  surge_ver = x.surge_ver;
126              return;
127          }
128      }
129      return;
130  }
131  std::string getConvertedRuleset(RESPONSE_CALLBACK_ARGS)
132  {
133      std::string url = urlDecode(getUrlArg(request.argument, &quot;url&quot;)), type = getUrlArg(request.argument, &quot;type&quot;);
134      return convertRuleset(fetchFile(url, parseProxy(global.proxyRuleset), global.cacheRuleset), to_int(type));
135  }
136  std::string getRuleset(RESPONSE_CALLBACK_ARGS)
137  {
138      std::string &amp;argument = request.argument;
139      int *status_code = &amp;response.status_code;
140      std::string url = urlSafeBase64Decode(getUrlArg(argument, &quot;url&quot;)), type = getUrlArg(argument, &quot;type&quot;), group = urlSafeBase64Decode(getUrlArg(argument, &quot;group&quot;));
141      std::string output_content, dummy;
142      int type_int = to_int(type, 0);
143      if(!url.size() || !type.size() || (type_int == 2 &amp;&amp; !group.size()) || (type_int &lt; 1 || type_int &gt; 6))
144      {
145          *status_code = 400;
146          return &quot;Invalid request!&quot;;
147      }
148      std::string proxy = parseProxy(global.proxyRuleset);
149      string_array vArray = split(url, &quot;|&quot;);
150      for(std::string &amp;x : vArray)
151          x.insert(0, &quot;ruleset,&quot;);
152      std::vector&lt;RulesetContent&gt; rca;
153      RulesetConfigs confs = INIBinding::from&lt;RulesetConfig&gt;::from_ini(vArray);
154      refreshRulesets(confs, rca);
155      for(RulesetContent &amp;x : rca)
156      {
157          std::string content = x.rule_content.get();
158          output_content += convertRuleset(content, x.rule_type);
159      }
160      if(!output_content.size())
161      {
162          *status_code = 400;
163          return &quot;Invalid request!&quot;;
164      }
165      std::string strLine;
166      std::stringstream ss;
167      const std::string rule_match_regex = &quot;^(.*?,.*?)(,.*)(,.*)$&quot;;
168      ss &lt;&lt; output_content;
169      char delimiter = getLineBreak(output_content);
170      std::string::size_type lineSize, posb, pose;
171      auto filterLine = [&amp;]()
172      {
173          posb = 0;
174          pose = strLine.find(&#x27;,&#x27;);
175          if(pose == strLine.npos)
176              return 1;
177          posb = pose + 1;
178          pose = strLine.find(&#x27;,&#x27;, posb);
179          if(pose == strLine.npos)
180          {
181              pose = strLine.size();
182              if(strLine[pose - 1] == &#x27;\r&#x27;)
183                  pose--;
184          }
185          pose -= posb;
186          return 0;
187      };
188      lineSize = output_content.size();
189      output_content.clear();
190      output_content.reserve(lineSize);
191      if(type_int == 3 || type_int == 4 || type_int == 6)
192          output_content = &quot;payload:\n&quot;;
193      while(getline(ss, strLine, delimiter))
194      {
195          if(strFind(strLine, &quot;&amp;bsol;&amp;bsol;&quot;))
196          {
197              strLine.erase(strLine.find(&quot;&amp;bsol;&amp;bsol;&quot;));
198              strLine = trimWhitespace(strLine);
199          }
200          switch(type_int)
201          {
202          case 2:
203              if(!std::any_of(QuanXRuleTypes.begin(), QuanXRuleTypes.end(), [&amp;strLine](std::string type){return startsWith(strLine, type);}))
204                  continue;
205              break;
206          case 1:
207              if(!std::any_of(SurgeRuleTypes.begin(), SurgeRuleTypes.end(), [&amp;strLine](std::string type){return startsWith(strLine, type);}))
208                  continue;
209              break;
210          case 3:
211              if(!startsWith(strLine, &quot;DOMAIN-SUFFIX,&quot;) &amp;&amp; !startsWith(strLine, &quot;DOMAIN,&quot;))
212                  continue;
213              if(filterLine())
214                  continue;
215              output_content += &quot;  - &#x27;&quot;;
216              if(strLine[posb - 2] == &#x27;X&#x27;)
217                  output_content += &quot;+.&quot;;
218              output_content += strLine.substr(posb, pose);
219              output_content += &quot;&#x27;\n&quot;;
220              continue;
221          case 4:
222              if(!startsWith(strLine, &quot;IP-CIDR,&quot;) &amp;&amp; !startsWith(strLine, &quot;IP-CIDR6,&quot;))
223                  continue;
224              if(filterLine())
225                  continue;
226              output_content += &quot;  - &#x27;&quot;;
227              output_content += strLine.substr(posb, pose);
228              output_content += &quot;&#x27;\n&quot;;
229              continue;
230          case 5:
231              if(!startsWith(strLine, &quot;DOMAIN-SUFFIX,&quot;) &amp;&amp; !startsWith(strLine, &quot;DOMAIN,&quot;))
232                  continue;
233              if(filterLine())
234                  continue;
235              output_content += strLine.substr(posb, pose);
236              output_content += &#x27;\n&#x27;;
237              continue;
238          case 6:
239              if(!std::any_of(ClashRuleTypes.begin(), ClashRuleTypes.end(), [&amp;strLine](std::string type){return startsWith(strLine, type);}))
240                  continue;
241              output_content += &quot;  - &quot;;
242          }
243          lineSize = strLine.size();
244          if(lineSize &amp;&amp; strLine[lineSize - 1] == &#x27;\r&#x27;) 
245              strLine.erase(--lineSize);
246          if(!strLine.empty() &amp;&amp; (strLine[0] != &#x27;;&#x27; &amp;&amp; strLine[0] != &#x27;#&#x27; &amp;&amp; !(lineSize &gt;= 2 &amp;&amp; strLine[0] == &#x27;/&#x27; &amp;&amp; strLine[1] == &#x27;/&#x27;)))
247          {
248              if(type_int == 2)
249              {
250                  if(startsWith(strLine, &quot;IP-CIDR6&quot;))
251                      strLine.replace(0, 8, &quot;IP6-CIDR&quot;);
252                  strLine += &quot;,&quot; + group;
253                  if(count_least(strLine, &#x27;,&#x27;, 3) &amp;&amp; regReplace(strLine, rule_match_regex, &quot;$2&quot;) == &quot;,no-resolve&quot;)
254                      strLine = regReplace(strLine, rule_match_regex, &quot;$1$3$2&quot;);
255                  else
256                      strLine = regReplace(strLine, rule_match_regex, &quot;$1$3&quot;);
257              }
258          }
259          output_content += strLine;
260          output_content += &#x27;\n&#x27;;
261      }
262      if(output_content == &quot;payload:\n&quot;)
263      {
264          switch(type_int)
265          {
266          case 3:
267              output_content += &quot;  - &#x27;--placeholder--&#x27;&quot;;
268              break;
269          case 4:
270              output_content += &quot;  - &#x27;0.0.0.0/32&#x27;&quot;;
271              break;
272          case 6:
273              output_content += &quot;  - &#x27;DOMAIN,--placeholder--&#x27;&quot;;
274              break;
275          }
276      }
277      return output_content;
278  }
279  void checkExternalBase(const std::string &amp;path, std::string &amp;dest)
280  {
281      if(isLink(path) || (startsWith(path, global.basePath) &amp;&amp; fileExist(path)))
282          dest = path;
283  }
284  std::string subconverter(RESPONSE_CALLBACK_ARGS)
285  {
286      std::string &amp;argument = request.argument;
287      int *status_code = &amp;response.status_code;
288      std::string argTarget = getUrlArg(argument, &quot;target&quot;), argSurgeVer = getUrlArg(argument, &quot;ver&quot;);
289      tribool argClashNewField = getUrlArg(argument, &quot;new_name&quot;);
290      int intSurgeVer = argSurgeVer.size() ? to_int(argSurgeVer, 3) : 3;
291      if(argTarget == &quot;auto&quot;)
292          matchUserAgent(request.headers[&quot;User-Agent&quot;], argTarget, argClashNewField, intSurgeVer);
293      bool lSimpleSubscription = false;
294      switch(hash_(argTarget))
295      {
296      case &quot;ss&quot;_hash: case &quot;ssd&quot;_hash: case &quot;ssr&quot;_hash: case &quot;sssub&quot;_hash: case &quot;v2ray&quot;_hash: case &quot;trojan&quot;_hash: case &quot;mixed&quot;_hash:
297          lSimpleSubscription = true;
298          break;
299      case &quot;clash&quot;_hash: case &quot;clashr&quot;_hash: case &quot;surge&quot;_hash: case &quot;quan&quot;_hash: case &quot;quanx&quot;_hash: case &quot;loon&quot;_hash: case &quot;surfboard&quot;_hash: case &quot;mellow&quot;_hash:
300          break;
301      default:
302          *status_code = 400;
303          return &quot;Invalid target!&quot;;
304      }
305      if((!global.APIMode || global.CFWChildProcess) &amp;&amp; !global.generatorMode)
306          readConf();
307      std::string argUrl = urlDecode(getUrlArg(argument, &quot;url&quot;));
308      std::string argGroupName = urlDecode(getUrlArg(argument, &quot;group&quot;)), argUploadPath = getUrlArg(argument, &quot;upload_path&quot;);
309      std::string argIncludeRemark = urlDecode(getUrlArg(argument, &quot;include&quot;)), argExcludeRemark = urlDecode(getUrlArg(argument, &quot;exclude&quot;));
310      std::string argCustomGroups = urlSafeBase64Decode(getUrlArg(argument, &quot;groups&quot;)), argCustomRulesets = urlSafeBase64Decode(getUrlArg(argument, &quot;ruleset&quot;)), argExternalConfig = urlDecode(getUrlArg(argument, &quot;config&quot;));
311      std::string argDeviceID = getUrlArg(argument, &quot;dev_id&quot;), argFilename = urlDecode(getUrlArg(argument, &quot;filename&quot;)), argUpdateInterval = getUrlArg(argument, &quot;interval&quot;), argUpdateStrict = getUrlArg(argument, &quot;strict&quot;);
312      std::string argRenames = urlDecode(getUrlArg(argument, &quot;rename&quot;)), argFilterScript = urlDecode(getUrlArg(argument, &quot;filter_script&quot;));
313      tribool argUpload = getUrlArg(argument, &quot;upload&quot;), argEmoji = getUrlArg(argument, &quot;emoji&quot;), argAddEmoji = getUrlArg(argument, &quot;add_emoji&quot;), argRemoveEmoji = getUrlArg(argument, &quot;remove_emoji&quot;);
314      tribool argAppendType = getUrlArg(argument, &quot;append_type&quot;), argTFO = getUrlArg(argument, &quot;tfo&quot;), argUDP = getUrlArg(argument, &quot;udp&quot;), argGenNodeList = getUrlArg(argument, &quot;list&quot;);
315      tribool argSort = getUrlArg(argument, &quot;sort&quot;), argUseSortScript = getUrlArg(argument, &quot;sort_script&quot;);
316      tribool argGenClashScript = getUrlArg(argument, &quot;script&quot;), argEnableInsert = getUrlArg(argument, &quot;insert&quot;);
317      tribool argSkipCertVerify = getUrlArg(argument, &quot;scv&quot;), argFilterDeprecated = getUrlArg(argument, &quot;fdn&quot;), argExpandRulesets = getUrlArg(argument, &quot;expand&quot;), argAppendUserinfo = getUrlArg(argument, &quot;append_info&quot;);
318      tribool argPrependInsert = getUrlArg(argument, &quot;prepend&quot;), argGenClassicalRuleProvider = getUrlArg(argument, &quot;classic&quot;), argTLS13 = getUrlArg(argument, &quot;tls13&quot;);
319      std::string base_content, output_content;
320      ProxyGroupConfigs lCustomProxyGroups = global.customProxyGroups;
321      RulesetConfigs lCustomRulesets = global.customRulesets;
322      string_array lIncludeRemarks = global.includeRemarks, lExcludeRemarks = global.excludeRemarks;
323      std::vector&lt;RulesetContent&gt; lRulesetContent;
324      extra_settings ext;
325      std::string subInfo, dummy;
326      int interval = argUpdateInterval.size() ? to_int(argUpdateInterval, global.updateInterval) : global.updateInterval;
327      bool authorized = !global.APIMode || getUrlArg(argument, &quot;token&quot;) == global.accessToken, strict = argUpdateStrict.size() ? argUpdateStrict == &quot;true&quot; : global.updateStrict;
328      if(std::find(gRegexBlacklist.cbegin(), gRegexBlacklist.cend(), argIncludeRemark) != gRegexBlacklist.cend() || std::find(gRegexBlacklist.cbegin(), gRegexBlacklist.cend(), argExcludeRemark) != gRegexBlacklist.cend())
329          return &quot;Invalid request!&quot;;
330      std::string lClashBase = global.clashBase, lSurgeBase = global.surgeBase, lMellowBase = global.mellowBase, lSurfboardBase = global.surfboardBase;
331      std::string lQuanBase = global.quanBase, lQuanXBase = global.quanXBase, lLoonBase = global.loonBase, lSSSubBase = global.SSSubBase;
332      argEnableInsert.define(global.enableInsert);
333      if(!argUrl.size() &amp;&amp; (!global.APIMode || authorized))
334          argUrl = global.defaultUrls;
335      if((!argUrl.size() &amp;&amp; !(global.insertUrls.size() &amp;&amp; argEnableInsert)) || !argTarget.size())
336      {
337          *status_code = 400;
338          return &quot;Invalid request!&quot;;
339      }
340      string_array req_args = split(argument, &quot;&amp;&quot;);
341      string_map req_arg_map;
342      for(std::string &amp;x : req_args)
343      {
344          string_size pos = x.find(&quot;=&quot;);
345          if(pos == x.npos)
346          {
347              req_arg_map[x] = &quot;&quot;;
348              continue;
349          }
350          if(x.substr(0, pos) == &quot;token&quot;)
351              continue;
352          req_arg_map[x.substr(0, pos)] = x.substr(pos + 1);
353      }
354      req_arg_map[&quot;target&quot;] = argTarget;
355      req_arg_map[&quot;ver&quot;] = std::to_string(intSurgeVer);
356      template_args tpl_args;
357      tpl_args.global_vars = global.templateVars;
358      tpl_args.request_params = req_arg_map;
359      std::string proxy = parseProxy(global.proxySubscription);
360      ext.authorized = authorized;
361      ext.append_proxy_type = argAppendType.get(global.appendType);
362      if((argTarget == &quot;clash&quot; || argTarget == &quot;clashr&quot;) &amp;&amp; argGenClashScript.is_undef())
363          argExpandRulesets.define(true);
364      ext.clash_proxies_style = global.clashProxiesStyle;
365      ext.tfo.define(argTFO).define(global.TFOFlag);
366      ext.udp.define(argUDP).define(global.UDPFlag);
367      ext.skip_cert_verify.define(argSkipCertVerify).define(global.skipCertVerify);
368      ext.tls13.define(argTLS13).define(global.TLS13Flag);
369      ext.sort_flag = argSort.get(global.enableSort);
370      argUseSortScript.define(global.sortScript.size() != 0);
371      if(ext.sort_flag &amp;&amp; argUseSortScript)
372          ext.sort_script = global.sortScript;
373      ext.filter_deprecated = argFilterDeprecated.get(global.filterDeprecated);
374      ext.clash_new_field_name = argClashNewField.get(global.clashUseNewField);
375      ext.clash_script = argGenClashScript.get();
376      ext.clash_classical_ruleset = argGenClassicalRuleProvider.get();
377      if(!argExpandRulesets)
378          ext.clash_new_field_name = true;
379      else
380          ext.clash_script = false;
381      ext.nodelist = argGenNodeList;
382      ext.surge_ssr_path = global.surgeSSRPath;
383      ext.quanx_dev_id = argDeviceID.size() ? argDeviceID : global.quanXDevID;
384      ext.enable_rule_generator = global.enableRuleGen;
385      ext.overwrite_original_rules = global.overwriteOriginalRules;
386      if(!argExpandRulesets)
387          ext.managed_config_prefix = global.managedConfigPrefix;
388      if(argExternalConfig.empty())
389          argExternalConfig = global.defaultExtConfig;
390      if(argExternalConfig.size())
391      {
392          writeLog(0, &quot;External configuration file provided. Loading...&quot;, LOG_LEVEL_INFO);
393          ExternalConfig extconf;
394          extconf.tpl_args = &amp;tpl_args;
395          if(loadExternalConfig(argExternalConfig, extconf) == 0)
396          {
397              if(!ext.nodelist)
398              {
399                  checkExternalBase(extconf.sssub_rule_base, lSSSubBase);
400                  if(!lSimpleSubscription)
401                  {
402                      checkExternalBase(extconf.clash_rule_base, lClashBase);
403                      checkExternalBase(extconf.surge_rule_base, lSurgeBase);
404                      checkExternalBase(extconf.surfboard_rule_base, lSurfboardBase);
405                      checkExternalBase(extconf.mellow_rule_base, lMellowBase);
406                      checkExternalBase(extconf.quan_rule_base, lQuanBase);
407                      checkExternalBase(extconf.quanx_rule_base, lQuanXBase);
408                      checkExternalBase(extconf.loon_rule_base, lLoonBase);
409                      if(extconf.surge_ruleset.size())
410                          lCustomRulesets = extconf.surge_ruleset;
411                      if(extconf.custom_proxy_group.size())
412                          lCustomProxyGroups = extconf.custom_proxy_group;
413                      ext.enable_rule_generator = extconf.enable_rule_generator;
414                      ext.overwrite_original_rules = extconf.overwrite_original_rules;
415                  }
416              }
417              if(extconf.rename.size())
418                  ext.rename_array = extconf.rename;
419              if(extconf.emoji.size())
420                  ext.emoji_array = extconf.emoji;
421              if(extconf.include.size())
422                  lIncludeRemarks = extconf.include;
423              if(extconf.exclude.size())
424                  lExcludeRemarks = extconf.exclude;
425              argAddEmoji.define(extconf.add_emoji);
426              argRemoveEmoji.define(extconf.remove_old_emoji);
427          }
428      }
429      else
430      {
431          if(!lSimpleSubscription)
432          {
433              if(argCustomGroups.size() &amp;&amp; !ext.nodelist)
434              {
435                  string_array vArray = split(argCustomGroups, &quot;@&quot;);
<span onclick='openModal()' class='match'>436                  lCustomProxyGroups = INIBinding::from&lt;ProxyGroupConfig&gt;::from_ini(vArray);
437              }
438              if(argCustomRulesets.size() &amp;&amp; !ext.nodelist)
</span>439              {
440                  string_array vArray = split(argCustomRulesets, &quot;@&quot;);
441                  lCustomRulesets = INIBinding::from&lt;RulesetConfig&gt;::from_ini(vArray);
442              }
443          }
444      }
445      if(ext.enable_rule_generator &amp;&amp; !ext.nodelist &amp;&amp; !lSimpleSubscription)
446      {
447          if(lCustomRulesets != global.customRulesets)
448              refreshRulesets(lCustomRulesets, lRulesetContent);
449          else
450          {
451              if(global.updateRulesetOnRequest)
452                  refreshRulesets(global.customRulesets, global.rulesetsContent);
453              lRulesetContent = global.rulesetsContent;
454          }
455      }
456      if(!argEmoji.is_undef())
457      {
458          argAddEmoji.set(argEmoji);
459          argRemoveEmoji.set(true);
460      }
461      ext.add_emoji = argAddEmoji.get(global.addEmoji);
462      ext.remove_emoji = argRemoveEmoji.get(global.removeEmoji);
463      if(ext.add_emoji &amp;&amp; ext.emoji_array.empty())
464          ext.emoji_array = safe_get_emojis();
465      if(argRenames.size())
466          ext.rename_array = INIBinding::from&lt;RegexMatchConfig&gt;::from_ini(split(argRenames, &quot;`&quot;), &quot;@&quot;);
467      else if(ext.rename_array.empty())
468          ext.rename_array = safe_get_renames();
469      if(argIncludeRemark.size() &amp;&amp; regValid(argIncludeRemark))
470          lIncludeRemarks = string_array{argIncludeRemark};
471      if(argExcludeRemark.size() &amp;&amp; regValid(argExcludeRemark))
472          lExcludeRemarks = string_array{argExcludeRemark};
473      if(authorized &amp;&amp; !global.scriptCleanContext)
474      {
475          ext.js_runtime = new qjs::Runtime();
476          script_runtime_init(*ext.js_runtime);
477          ext.js_context = new qjs::Context(*ext.js_runtime);
478          script_context_init(*ext.js_context);
479      }
480      RegexMatchConfigs stream_temp = safe_get_streams(), time_temp = safe_get_times();
481      string_array urls;
482      std::vector&lt;Proxy&gt; nodes, insert_nodes;
483      int groupID = 0;
484      parse_settings parse_set;
485      parse_set.proxy = &amp;proxy;
486      parse_set.exclude_remarks = &amp;lExcludeRemarks;
487      parse_set.include_remarks = &amp;lIncludeRemarks;
488      parse_set.stream_rules = &amp;stream_temp;
489      parse_set.time_rules = &amp;time_temp;
490      parse_set.sub_info = &amp;subInfo;
491      parse_set.authorized = authorized;
492      parse_set.request_header = &amp;request.headers;
493      parse_set.js_runtime = ext.js_runtime;
494      parse_set.js_context = ext.js_context;
495      if(global.insertUrls.size() &amp;&amp; argEnableInsert)
496      {
497          groupID = -1;
498          urls = split(global.insertUrls, &quot;|&quot;);
499          importItems(urls, true);
500          for(std::string &amp;x : urls)
501          {
502              x = regTrim(x);
503              writeLog(0, &quot;Fetching node data from url &#x27;&quot; + x + &quot;&#x27;.&quot;, LOG_LEVEL_INFO);
504              if(addNodes(x, insert_nodes, groupID, parse_set) == -1)
505              {
506                  if(global.skipFailedLinks)
507                      writeLog(0, &quot;The following link doesn&#x27;t contain any valid node info: &quot; + x, LOG_LEVEL_WARNING);
508                  else
509                  {
510                      *status_code = 400;
511                      return &quot;The following link doesn&#x27;t contain any valid node info: &quot; + x;
512                  }
513              }
514              groupID--;
515          }
516      }
517      urls = split(argUrl, &quot;|&quot;);
518      importItems(urls, true);
519      groupID = 0;
520      for(std::string &amp;x : urls)
521      {
522          x = regTrim(x);
523          writeLog(0, &quot;Fetching node data from url &#x27;&quot; + x + &quot;&#x27;.&quot;, LOG_LEVEL_INFO);
524          if(addNodes(x, nodes, groupID, parse_set) == -1)
525          {
526              if(global.skipFailedLinks)
527                  writeLog(0, &quot;The following link doesn&#x27;t contain any valid node info: &quot; + x, LOG_LEVEL_WARNING);
528              else
529              {
530                  *status_code = 400;
531                  return &quot;The following link doesn&#x27;t contain any valid node info: &quot; + x;
532              }
533          }
534          groupID++;
535      }
536      if(!nodes.size() &amp;&amp; !insert_nodes.size())
537      {
538          *status_code = 400;
539          return &quot;No nodes were found!&quot;;
540      }
541      if(subInfo.size() &amp;&amp; argAppendUserinfo.get(global.appendUserinfo))
542          response.headers.emplace(&quot;Subscription-UserInfo&quot;, subInfo);
543      if(request.method == &quot;HEAD&quot;)
544          return &quot;&quot;;
545      argPrependInsert.define(global.prependInsert);
546      if(argPrependInsert)
547      {
548          std::move(nodes.begin(), nodes.end(), std::back_inserter(insert_nodes));
549          nodes.swap(insert_nodes);
550      }
551      else
552      {
553          std::move(insert_nodes.begin(), insert_nodes.end(), std::back_inserter(nodes));
554      }
555      std::string filterScript = global.filterScript;
556      if(authorized &amp;&amp; !argFilterScript.empty())
557          filterScript = argFilterScript;
558      if(filterScript.size())
559      {
560          if(startsWith(filterScript, &quot;path:&quot;))
561              filterScript = fileGet(filterScript.substr(5), false);
562          script_safe_runner(ext.js_runtime, ext.js_context, [&amp;](qjs::Context &amp;ctx)
563          {
564              try
565              {
566                  ctx.eval(filterScript);
567                  auto filter = (std::function&lt;bool(const Proxy&amp;)&gt;) ctx.eval(&quot;filter&quot;);
568                  nodes.erase(std::remove_if(nodes.begin(), nodes.end(), filter), nodes.end());
569              }
570              catch(qjs::exception)
571              {
572                  script_print_stack(ctx);
573              }
574          }, global.scriptCleanContext);
575      }
576      if(argGroupName.size())
577          for(Proxy &amp;x : nodes)
578              x.Group = argGroupName;
579      preprocessNodes(nodes, ext);
580      ProxyGroupConfigs dummy_group;
581      std::vector&lt;RulesetContent&gt; dummy_ruleset;
582      std::string managed_url = base64Decode(urlDecode(getUrlArg(argument, &quot;profile_data&quot;)));
583      if(managed_url.empty())
584          managed_url = global.managedConfigPrefix + &quot;/sub?&quot; + argument;
585      proxy = parseProxy(global.proxyConfig);
586      switch(hash_(argTarget))
587      {
588      case &quot;clash&quot;_hash: case &quot;clashr&quot;_hash:
589          writeLog(0, argTarget == &quot;clashr&quot; ? &quot;Generate target: ClashR&quot; : &quot;Generate target: Clash&quot;, LOG_LEVEL_INFO);
590          tpl_args.local_vars[&quot;clash.new_field_name&quot;] = ext.clash_new_field_name ? &quot;true&quot; : &quot;false&quot;;
591          response.headers[&quot;profile-update-interval&quot;] = std::to_string(interval / 3600);
592          if(ext.nodelist)
593          {
594              YAML::Node yamlnode;
595              proxyToClash(nodes, yamlnode, dummy_group, argTarget == &quot;clashr&quot;, ext);
596              output_content = YAML::Dump(yamlnode);
597          }
598          else
599          {
600              if(render_template(fetchFile(lClashBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)
601              {
602                  *status_code = 400;
603                  return base_content;
604              }
605              output_content = proxyToClash(nodes, base_content, lRulesetContent, lCustomProxyGroups, argTarget == &quot;clashr&quot;, ext);
606          }
607          if(argUpload)
608              uploadGist(argTarget, argUploadPath, output_content, false);
609          break;
610      case &quot;surge&quot;_hash:
611          writeLog(0, &quot;Generate target: Surge &quot; + std::to_string(intSurgeVer), LOG_LEVEL_INFO);
612          if(ext.nodelist)
613          {
614              output_content = proxyToSurge(nodes, base_content, dummy_ruleset, dummy_group, intSurgeVer, ext);
615              if(argUpload)
616                  uploadGist(&quot;surge&quot; + argSurgeVer + &quot;list&quot;, argUploadPath, output_content, true);
617          }
618          else
619          {
620              if(render_template(fetchFile(lSurgeBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)
621              {
622                  *status_code = 400;
623                  return base_content;
624              }
625              output_content = proxyToSurge(nodes, base_content, lRulesetContent, lCustomProxyGroups, intSurgeVer, ext);
626              if(argUpload)
627                  uploadGist(&quot;surge&quot; + argSurgeVer, argUploadPath, output_content, true);
628              if(global.writeManagedConfig &amp;&amp; global.managedConfigPrefix.size())
629                  output_content = &quot;#!MANAGED-CONFIG &quot; + managed_url + (interval ? &quot; interval=&quot; + std::to_string(interval) : &quot;&quot;) \
630                   + &quot; strict=&quot; + std::string(strict ? &quot;true&quot; : &quot;false&quot;) + &quot;\n\n&quot; + output_content;
631          }
632          break;
633      case &quot;surfboard&quot;_hash:
634          writeLog(0, &quot;Generate target: Surfboard&quot;, LOG_LEVEL_INFO);
635          if(render_template(fetchFile(lSurfboardBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)
636          {
637              *status_code = 400;
638              return base_content;
639          }
640          output_content = proxyToSurge(nodes, base_content, lRulesetContent, lCustomProxyGroups, -3, ext);
641          if(argUpload)
642              uploadGist(&quot;surfboard&quot;, argUploadPath, output_content, true);
643          if(global.writeManagedConfig &amp;&amp; global.managedConfigPrefix.size())
644              output_content = &quot;#!MANAGED-CONFIG &quot; + managed_url + (interval ? &quot; interval=&quot; + std::to_string(interval) : &quot;&quot;) \
645                   + &quot; strict=&quot; + std::string(strict ? &quot;true&quot; : &quot;false&quot;) + &quot;\n\n&quot; + output_content;
646          break;
647      case &quot;mellow&quot;_hash:
648          writeLog(0, &quot;Generate target: Mellow&quot;, LOG_LEVEL_INFO);
649          if(render_template(fetchFile(lMellowBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)
650          {
651              *status_code = 400;
652              return base_content;
653          }
654          output_content = proxyToMellow(nodes, base_content, lRulesetContent, lCustomProxyGroups, ext);
655          if(argUpload)
656              uploadGist(&quot;mellow&quot;, argUploadPath, output_content, true);
657          break;
658      case &quot;sssub&quot;_hash:
659          writeLog(0, &quot;Generate target: SS Subscription&quot;, LOG_LEVEL_INFO);
660          if(render_template(fetchFile(lSSSubBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)
661          {
662              *status_code = 400;
663              return base_content;
664          }
665          output_content = proxyToSSSub(base_content, nodes, ext);
666          if(argUpload)
667              uploadGist(&quot;sssub&quot;, argUploadPath, output_content, false);
668          break;
669      case &quot;ss&quot;_hash:
670          writeLog(0, &quot;Generate target: SS&quot;, LOG_LEVEL_INFO);
671          output_content = proxyToSingle(nodes, 1, ext);
672          if(argUpload)
673              uploadGist(&quot;ss&quot;, argUploadPath, output_content, false);
674          break;
675      case &quot;ssr&quot;_hash:
676          writeLog(0, &quot;Generate target: SSR&quot;, LOG_LEVEL_INFO);
677          output_content = proxyToSingle(nodes, 2, ext);
678          if(argUpload)
679              uploadGist(&quot;ssr&quot;, argUploadPath, output_content, false);
680          break;
681      case &quot;v2ray&quot;_hash:
682          writeLog(0, &quot;Generate target: v2rayN&quot;, LOG_LEVEL_INFO);
683          output_content = proxyToSingle(nodes, 4, ext);
684          if(argUpload)
685              uploadGist(&quot;v2ray&quot;, argUploadPath, output_content, false);
686          break;
687      case &quot;trojan&quot;_hash:
688          writeLog(0, &quot;Generate target: Trojan&quot;, LOG_LEVEL_INFO);
689          output_content = proxyToSingle(nodes, 8, ext);
690          if(argUpload)
691              uploadGist(&quot;trojan&quot;, argUploadPath, output_content, false);
692          break;
693      case &quot;mixed&quot;_hash:
694          writeLog(0, &quot;Generate target: Standard Subscription&quot;, LOG_LEVEL_INFO);
695          output_content = proxyToSingle(nodes, 15, ext);
696          if(argUpload)
697              uploadGist(&quot;sub&quot;, argUploadPath, output_content, false);
698          break;
699      case &quot;quan&quot;_hash:
700          writeLog(0, &quot;Generate target: Quantumult&quot;, LOG_LEVEL_INFO);
701          if(!ext.nodelist)
702          {
703              if(render_template(fetchFile(lQuanBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)
704              {
705                  *status_code = 400;
706                  return base_content;
707              }
708          }
709          output_content = proxyToQuan(nodes, base_content, lRulesetContent, lCustomProxyGroups, ext);
710          if(argUpload)
711              uploadGist(&quot;quan&quot;, argUploadPath, output_content, false);
712          break;
713      case &quot;quanx&quot;_hash:
714          writeLog(0, &quot;Generate target: Quantumult X&quot;, LOG_LEVEL_INFO);
715          if(!ext.nodelist)
716          {
717              if(render_template(fetchFile(lQuanXBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)
718              {
719                  *status_code = 400;
720                  return base_content;
721              }
722          }
723          output_content = proxyToQuanX(nodes, base_content, lRulesetContent, lCustomProxyGroups, ext);
724          if(argUpload)
725              uploadGist(&quot;quanx&quot;, argUploadPath, output_content, false);
726          break;
727      case &quot;loon&quot;_hash:
728          writeLog(0, &quot;Generate target: Loon&quot;, LOG_LEVEL_INFO);
729          if(!ext.nodelist)
730          {
731              if(render_template(fetchFile(lLoonBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)
732              {
733                  *status_code = 400;
734                  return base_content;
735              }
736          }
737          output_content = proxyToLoon(nodes, base_content, lRulesetContent, lCustomProxyGroups, ext);
738          if(argUpload)
739              uploadGist(&quot;loon&quot;, argUploadPath, output_content, false);
740          break;
741      case &quot;ssd&quot;_hash:
742          writeLog(0, &quot;Generate target: SSD&quot;, LOG_LEVEL_INFO);
743          output_content = proxyToSSD(nodes, argGroupName, subInfo, ext);
744          if(argUpload)
745              uploadGist(&quot;ssd&quot;, argUploadPath, output_content, false);
746          break;
747      default:
748          writeLog(0, &quot;Generate target: Unspecified&quot;, LOG_LEVEL_INFO);
749          *status_code = 500;
750          return &quot;Unrecognized target&quot;;
751      }
752      writeLog(0, &quot;Generate completed.&quot;, LOG_LEVEL_INFO);
753      if(argFilename.size())
754          response.headers.emplace(&quot;Content-Disposition&quot;, &quot;attachment; filename=\&quot;&quot; + argFilename + &quot;\&quot;; filename*=utf-8&#x27;&#x27;&quot; + urlEncode(argFilename));
755      return output_content;
756  }
757  std::string simpleToClashR(RESPONSE_CALLBACK_ARGS)
758  {
759      std::string &amp;argument = request.argument;
760      int *status_code = &amp;response.status_code;
761      std::string url = argument.size() &lt;= 8 ? &quot;&quot; : argument.substr(8);
762      if(!url.size() || argument.substr(0, 8) != &quot;sublink=&quot;)
763      {
764          *status_code = 400;
765          return &quot;Invalid request!&quot;;
766      }
767      if(url == &quot;sublink&quot;)
768      {
769          *status_code = 400;
770          return &quot;Please insert your subscription link instead of clicking the default link.&quot;;
771      }
772      request.argument = &quot;target=clashr&amp;url=&quot; + urlEncode(url);
773      return subconverter(request, response);
774  }
775  std::string surgeConfToClash(RESPONSE_CALLBACK_ARGS)
776  {
777      std::string &amp;argument = request.argument;
778      int *status_code = &amp;response.status_code;
779      INIReader ini;
780      string_array dummy_str_array;
781      std::vector&lt;Proxy&gt; nodes;
782      std::string base_content, url = argument.size() &lt;= 5 ? &quot;&quot; : argument.substr(5);
783      const std::string proxygroup_name = global.clashUseNewField ? &quot;proxy-groups&quot; : &quot;Proxy Group&quot;, rule_name = global.clashUseNewField ? &quot;rules&quot; : &quot;Rule&quot;;
784      ini.store_any_line = true;
785      if(!url.size())
786          url = global.defaultUrls;
787      if(!url.size() || argument.substr(0, 5) != &quot;link=&quot;)
788      {
789          *status_code = 400;
790          return &quot;Invalid request!&quot;;
791      }
792      if(url == &quot;link&quot;)
793      {
794          *status_code = 400;
795          return &quot;Please insert your subscription link instead of clicking the default link.&quot;;
796      }
797      writeLog(0, &quot;SurgeConfToClash called with url &#x27;&quot; + url + &quot;&#x27;.&quot;, LOG_LEVEL_INFO);
798      std::string proxy = parseProxy(global.proxyConfig);
799      YAML::Node clash;
800      template_args tpl_args;
801      tpl_args.global_vars = global.templateVars;
802      tpl_args.local_vars[&quot;clash.new_field_name&quot;] = global.clashUseNewField ? &quot;true&quot; : &quot;false&quot;;
803      tpl_args.request_params[&quot;target&quot;] = &quot;clash&quot;;
804      tpl_args.request_params[&quot;url&quot;] = url;
805      if(render_template(fetchFile(global.clashBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)
806      {
807          *status_code = 400;
808          return base_content;
809      }
810      clash = YAML::Load(base_content);
811      base_content = fetchFile(url, proxy, global.cacheConfig);
812      if(ini.Parse(base_content) != INIREADER_EXCEPTION_NONE)
813      {
814          std::string errmsg = &quot;Parsing Surge config failed! Reason: &quot; + ini.GetLastError();
815          writeLog(0, errmsg, LOG_LEVEL_ERROR);
816          *status_code = 400;
817          return errmsg;
818      }
819      if(!ini.SectionExist(&quot;Proxy&quot;) || !ini.SectionExist(&quot;Proxy Group&quot;) || !ini.SectionExist(&quot;Rule&quot;))
820      {
821          std::string errmsg = &quot;Incomplete surge config! Missing critical sections!&quot;;
822          writeLog(0, errmsg, LOG_LEVEL_ERROR);
823          *status_code = 400;
824          return errmsg;
825      }
826      string_multimap section;
827      ini.GetItems(&quot;Proxy Group&quot;, section);
828      std::string name, type, content;
829      string_array links;
830      links.emplace_back(url);
831      YAML::Node singlegroup;
832      for(auto &amp;x : section)
833      {
834          singlegroup.reset();
835          name = x.first;
836          content = x.second;
837          dummy_str_array = split(content, &quot;,&quot;);
838          if(!dummy_str_array.size())
839              continue;
840          type = dummy_str_array[0];
841          if(!(type == &quot;select&quot; || type == &quot;url-test&quot; || type == &quot;fallback&quot; || type == &quot;load-balance&quot;)) 
842              continue;
843          singlegroup[&quot;name&quot;] = name;
844          singlegroup[&quot;type&quot;] = type;
845          for(unsigned int i = 1; i &lt; dummy_str_array.size(); i++)
846          {
847              if(startsWith(dummy_str_array[i], &quot;url&quot;))
848                  singlegroup[&quot;url&quot;] = trim(dummy_str_array[i].substr(dummy_str_array[i].find(&quot;=&quot;) + 1));
849              else if(startsWith(dummy_str_array[i], &quot;interval&quot;))
850                  singlegroup[&quot;interval&quot;] = trim(dummy_str_array[i].substr(dummy_str_array[i].find(&quot;=&quot;) + 1));
851              else if(startsWith(dummy_str_array[i], &quot;policy-path&quot;))
852                  links.emplace_back(trim(dummy_str_array[i].substr(dummy_str_array[i].find(&quot;=&quot;) + 1)));
853              else
854                  singlegroup[&quot;proxies&quot;].push_back(trim(dummy_str_array[i]));
855          }
856          clash[proxygroup_name].push_back(singlegroup);
857      }
858      proxy = parseProxy(global.proxySubscription);
859      eraseElements(dummy_str_array);
860      RegexMatchConfigs dummy_regex_array;
861      std::string subInfo;
862      parse_settings parse_set;
863      parse_set.proxy = &amp;proxy;
864      parse_set.exclude_remarks = parse_set.include_remarks = &amp;dummy_str_array;
865      parse_set.stream_rules = parse_set.time_rules = &amp;dummy_regex_array;
866      parse_set.request_header = &amp;request.headers;
867      parse_set.sub_info = &amp;subInfo;
868      parse_set.authorized = !global.APIMode;
869      for(std::string &amp;x : links)
870      {
871          writeLog(0, &quot;Fetching node data from url &#x27;&quot; + x + &quot;&#x27;.&quot;, LOG_LEVEL_INFO);
872          if(addNodes(x, nodes, 0, parse_set) == -1)
873          {
874              if(global.skipFailedLinks)
875                  writeLog(0, &quot;The following link doesn&#x27;t contain any valid node info: &quot; + x, LOG_LEVEL_WARNING);
876              else
877              {
878                  *status_code = 400;
879                  return &quot;The following link doesn&#x27;t contain any valid node info: &quot; + x;
880              }
881          }
882      }
883      if(!nodes.size())
884      {
885          *status_code = 400;
886          return &quot;No nodes were found!&quot;;
887      }
888      extra_settings ext;
889      ext.sort_flag = global.enableSort;
890      ext.filter_deprecated = global.filterDeprecated;
891      ext.clash_new_field_name = global.clashUseNewField;
892      ext.udp = global.UDPFlag;
893      ext.tfo = global.TFOFlag;
894      ext.skip_cert_verify = global.skipCertVerify;
895      ext.tls13 = global.TLS13Flag;
896      ext.clash_proxies_style = global.clashProxiesStyle;
897      ProxyGroupConfigs dummy_groups;
898      proxyToClash(nodes, clash, dummy_groups, false, ext);
899      section.clear();
900      ini.GetItems(&quot;Proxy&quot;, section);
901      for(auto &amp;x : section)
902      {
903          singlegroup.reset();
904          name = x.first;
905          content = x.second;
906          dummy_str_array = split(content, &quot;,&quot;);
907          if(!dummy_str_array.size())
908              continue;
909          content = trim(dummy_str_array[0]);
910          switch(hash_(content))
911          {
912          case &quot;direct&quot;_hash:
913              singlegroup[&quot;name&quot;] = name;
914              singlegroup[&quot;type&quot;] = &quot;select&quot;;
915              singlegroup[&quot;proxies&quot;].push_back(&quot;DIRECT&quot;);
916              break;
917          case &quot;reject&quot;_hash:
918          case &quot;reject-tinygif&quot;_hash:
919              singlegroup[&quot;name&quot;] = name;
920              singlegroup[&quot;type&quot;] = &quot;select&quot;;
921              singlegroup[&quot;proxies&quot;].push_back(&quot;REJECT&quot;);
922              break;
923          default:
924              continue;
925          }
926          clash[proxygroup_name].push_back(singlegroup);
927      }
928      eraseElements(dummy_str_array);
929      ini.GetAll(&quot;Rule&quot;, &quot;{NONAME}&quot;, dummy_str_array);
930      YAML::Node rule;
931      string_array strArray;
932      std::string strLine;
933      std::stringstream ss;
934      std::string::size_type lineSize;
935      for(std::string &amp;x : dummy_str_array)
936      {
937          if(startsWith(x, &quot;RULE-SET&quot;))
938          {
939              strArray = split(x, &quot;,&quot;);
940              if(strArray.size() != 3)
941                  continue;
942              content = webGet(strArray[1], proxy, global.cacheRuleset);
943              if(!content.size())
944                  continue;
945              ss &lt;&lt; content;
946              char delimiter = getLineBreak(content);
947              while(getline(ss, strLine, delimiter))
948              {
949                  lineSize = strLine.size();
950                  if(lineSize &amp;&amp; strLine[lineSize - 1] == &#x27;\r&#x27;) 
951                      strLine.erase(--lineSize);
952                  if(!lineSize || strLine[0] == &#x27;;&#x27; || strLine[0] == &#x27;#&#x27; || (lineSize &gt;= 2 &amp;&amp; strLine[0] == &#x27;/&#x27; &amp;&amp; strLine[1] == &#x27;/&#x27;)) 
953                      continue;
954                  else if(!std::any_of(ClashRuleTypes.begin(), ClashRuleTypes.end(), [&amp;strLine](std::string type){return startsWith(strLine, type);})) 
955                      continue;
956                  strLine += strArray[2];
957                  if(count_least(strLine, &#x27;,&#x27;, 3))
958                      strLine = regReplace(strLine, &quot;^(.*?,.*?)(,.*)(,.*)$&quot;, &quot;$1$3$2&quot;);
959                  rule.push_back(strLine);
960              }
961              ss.clear();
962              continue;
963          }
964          else if(!std::any_of(ClashRuleTypes.begin(), ClashRuleTypes.end(), [&amp;strLine](std::string type){return startsWith(strLine, type);}))
965              continue;
966          rule.push_back(x);
967      }
968      clash[rule_name] = rule;
969      response.headers[&quot;profile-update-interval&quot;] = std::to_string(global.updateInterval / 3600);
970      writeLog(0, &quot;Conversion completed.&quot;, LOG_LEVEL_INFO);
971      return YAML::Dump(clash);
972  }
973  std::string getProfile(RESPONSE_CALLBACK_ARGS)
974  {
975      std::string &amp;argument = request.argument;
976      int *status_code = &amp;response.status_code;
977      std::string name = urlDecode(getUrlArg(argument, &quot;name&quot;)), token = urlDecode(getUrlArg(argument, &quot;token&quot;));
978      string_array profiles = split(name, &quot;|&quot;);
979      name = profiles[0];
980      if(token.empty() || name.empty())
981      {
982          *status_code = 403;
983          return &quot;Forbidden&quot;;
984      }
985      std::string profile_content;
986      if(fileExist(name))
987      {
988          profile_content = fileGet(name, true);
989      }
990      else
991      {
992          *status_code = 404;
993          return &quot;Profile not found&quot;;
994      }
995      writeLog(0, &quot;Trying to load profile &#x27;&quot; + name + &quot;&#x27;.&quot;, LOG_LEVEL_INFO);
996      INIReader ini;
997      if(ini.Parse(profile_content) != INIREADER_EXCEPTION_NONE &amp;&amp; !ini.SectionExist(&quot;Profile&quot;))
998      {
999          writeLog(0, &quot;Load profile failed! Reason: &quot; + ini.GetLastError(), LOG_LEVEL_ERROR);
1000          *status_code = 500;
1001          return &quot;Broken profile!&quot;;
1002      }
1003      writeLog(0, &quot;Trying to parse profile &#x27;&quot; + name + &quot;&#x27;.&quot;, LOG_LEVEL_INFO);
1004      string_multimap contents;
1005      ini.GetItems(&quot;Profile&quot;, contents);
1006      if(!contents.size())
1007      {
1008          writeLog(0, &quot;Load profile failed! Reason: Empty Profile section&quot;, LOG_LEVEL_ERROR);
1009          *status_code = 500;
1010          return &quot;Broken profile!&quot;;
1011      }
1012      auto profile_token = contents.find(&quot;profile_token&quot;);
1013      if(profiles.size() == 1 &amp;&amp; profile_token != contents.end())
1014      {
1015          if(token != profile_token-&gt;second)
1016          {
1017              *status_code = 403;
1018              return &quot;Forbidden&quot;;
1019          }
1020          token = global.accessToken;
1021      }
1022      else
1023      {
1024          if(token != global.accessToken)
1025          {
1026              *status_code = 403;
1027              return &quot;Forbidden&quot;;
1028          }
1029      }
1030      if(profiles.size() &gt; 1)
1031      {
1032          writeLog(0, &quot;Multiple profiles are provided. Trying to combine profiles...&quot;, LOG_TYPE_INFO);
1033          std::string all_urls, url;
1034          auto iter = contents.find(&quot;url&quot;);
1035          if(iter != contents.end())
1036              all_urls = iter-&gt;second;
1037          for(size_t i = 1; i &lt; profiles.size(); i++)
1038          {
1039              name = profiles[i];
1040              if(!fileExist(name))
1041              {
1042                  writeLog(0, &quot;Ignoring non-exist profile &#x27;&quot; + name + &quot;&#x27;...&quot;, LOG_LEVEL_WARNING);
1043                  continue;
1044              }
1045              if(ini.ParseFile(name) != INIREADER_EXCEPTION_NONE &amp;&amp; !ini.SectionExist(&quot;Profile&quot;))
1046              {
1047                  writeLog(0, &quot;Ignoring broken profile &#x27;&quot; + name + &quot;&#x27;...&quot;, LOG_LEVEL_WARNING);
1048                  continue;
1049              }
1050              url = ini.Get(&quot;Profile&quot;, &quot;url&quot;);
1051              if(url.size())
1052              {
1053                  all_urls += &quot;|&quot; + url;
1054                  writeLog(0, &quot;Profile url from &#x27;&quot; + name + &quot;&#x27; added.&quot;, LOG_LEVEL_INFO);
1055              }
1056              else
1057              {
1058                  writeLog(0, &quot;Profile &#x27;&quot; + name + &quot;&#x27; does not have url key. Skipping...&quot;, LOG_LEVEL_INFO);
1059              }
1060          }
1061          iter-&gt;second = all_urls;
1062      }
1063      contents.emplace(&quot;token&quot;, token);
1064      contents.emplace(&quot;profile_data&quot;, base64Encode(global.managedConfigPrefix + &quot;/getprofile?&quot; + argument));
1065      std::string query = std::accumulate(contents.begin(), contents.end(), std::string(), [](const std::string &amp;x, auto y){ return x + y.first + &quot;=&quot; + urlEncode(y.second) + &quot;&amp;&quot;; });
1066      query += argument;
1067      request.argument = query;
1068      return subconverter(request, response);
1069  }
1070  inline std::string intToStream(unsigned long long stream)
1071  {
1072      char chrs[16] = {}, units[6] = {&#x27; &#x27;, &#x27;K&#x27;, &#x27;M&#x27;, &#x27;G&#x27;, &#x27;T&#x27;, &#x27;P&#x27;};
1073      double streamval = stream;
1074      unsigned int level = 0;
1075      while(streamval &gt; 1024.0)
1076      {
1077          if(level &gt;= 5)
1078              break;
1079          level++;
1080          streamval /= 1024.0;
1081      }
1082      snprintf(chrs, 15, &quot;%.2f %cB&quot;, streamval, units[level]);
1083      return std::string(chrs);
1084  }
1085  std::string subInfoToMessage(std::string subinfo)
1086  {
1087      using ull = unsigned long long;
1088      subinfo = replaceAllDistinct(subinfo, &quot;; &quot;, &quot;&amp;&quot;);
1089      std::string retdata, useddata = &quot;N/A&quot;, totaldata = &quot;N/A&quot;, expirydata = &quot;N/A&quot;;
1090      std::string upload = getUrlArg(subinfo, &quot;upload&quot;), download = getUrlArg(subinfo, &quot;download&quot;), total = getUrlArg(subinfo, &quot;total&quot;), expire = getUrlArg(subinfo, &quot;expire&quot;);
1091      ull used = to_number&lt;ull&gt;(upload, 0) + to_number&lt;ull&gt;(download, 0), tot = to_number&lt;ull&gt;(total, 0);
1092      time_t expiry = to_number&lt;time_t&gt;(expire, 0);
1093      if(used != 0)
1094          useddata = intToStream(used);
1095      if(tot != 0)
1096          totaldata = intToStream(tot);
1097      if(expiry != 0)
1098      {
1099          char buffer[30];
1100          struct tm *dt = localtime(&amp;expiry);
1101          strftime(buffer, sizeof(buffer), &quot;%Y-%m-%d %H:%M&quot;, dt);
1102          expirydata.assign(buffer);
1103      }
1104      if(useddata == &quot;N/A&quot; &amp;&amp; totaldata == &quot;N/A&quot; &amp;&amp; expirydata == &quot;N/A&quot;)
1105          retdata = &quot;Not Available&quot;;
1106      else
1107          retdata += &quot;Stream Used: &quot; + useddata + &quot; Stream Total: &quot; + totaldata + &quot; Expiry Time: &quot; + expirydata;
1108      return retdata;
1109  }
1110  int simpleGenerator()
1111  {
1112      writeLog(0, &quot;Reading generator configuration...&quot;, LOG_LEVEL_INFO);
1113      std::string config = fileGet(&quot;generate.ini&quot;), path, profile, arguments, content;
1114      if(config.empty())
1115      {
1116          writeLog(0, &quot;Generator configuration not found or empty!&quot;, LOG_LEVEL_ERROR);
1117          return -1;
1118      }
1119      INIReader ini;
1120      if(ini.Parse(config) != INIREADER_EXCEPTION_NONE)
1121      {
1122          writeLog(0, &quot;Generator configuration broken! Reason:&quot; + ini.GetLastError(), LOG_LEVEL_ERROR);
1123          return -2;
1124      }
1125      writeLog(0, &quot;Read generator configuration completed.\n&quot;, LOG_LEVEL_INFO);
1126      string_array sections = ini.GetSections();
1127      if(global.generateProfiles.size())
1128      {
1129          writeLog(0, &quot;Generating with specific artifacts: \&quot;&quot; + global.generateProfiles + &quot;\&quot;...&quot;, LOG_LEVEL_INFO);
1130          string_array targets = split(global.generateProfiles, &quot;,&quot;), new_targets;
1131          for(std::string &amp;x : targets)
1132          {
1133              x = trim(x);
1134              if(std::find(sections.cbegin(), sections.cend(), x) != sections.cend())
1135                  new_targets.emplace_back(std::move(x));
1136              else
1137              {
1138                  writeLog(0, &quot;Artifact \&quot;&quot; + x + &quot;\&quot; not found in generator settings!&quot;, LOG_LEVEL_ERROR);
1139                  return -3;
1140              }
1141          }
1142          sections = new_targets;
1143          sections.shrink_to_fit();
1144      }
1145      else
1146          writeLog(0, &quot;Generating all artifacts...&quot;, LOG_LEVEL_INFO);
1147      string_multimap allItems;
1148      std::string proxy = parseProxy(global.proxySubscription);
1149      Request request;
1150      Response response;
1151      for(std::string &amp;x : sections)
1152      {
1153          arguments.clear();
1154          response.status_code = 200;
1155          writeLog(0, &quot;Generating artifact &#x27;&quot; + x + &quot;&#x27;...&quot;, LOG_LEVEL_INFO);
1156          ini.EnterSection(x);
1157          if(ini.ItemExist(&quot;path&quot;))
1158              path = ini.Get(&quot;path&quot;);
1159          else
1160          {
1161              writeLog(0, &quot;Artifact &#x27;&quot; + x + &quot;&#x27; output path missing! Skipping...\n&quot;, LOG_LEVEL_ERROR);
1162              continue;
1163          }
1164          if(ini.ItemExist(&quot;profile&quot;))
1165          {
1166              profile = ini.Get(&quot;profile&quot;);
1167              request.argument = &quot;name=&quot; + urlEncode(profile) + &quot;&amp;token=&quot; + global.accessToken + &quot;&amp;expand=true&quot;;
1168              content = getProfile(request, response);
1169          }
1170          else
1171          {
1172              if(ini.GetBool(&quot;direct&quot;) == true)
1173              {
1174                  std::string url = ini.Get(&quot;url&quot;);
1175                  content = fetchFile(url, proxy, global.cacheSubscription);
1176                  if(content.empty())
1177                  {
1178                      writeLog(0, &quot;Artifact &#x27;&quot; + x + &quot;&#x27; generate ERROR! Please check your link.\n&quot;, LOG_LEVEL_ERROR);
1179                      if(sections.size() == 1)
1180                          return -1;
1181                  }
1182                  fileWrite(path, &quot;\xEF\xBB\xBF&quot; + content, true);
1183                  continue;
1184              }
1185              ini.GetItems(allItems);
1186              allItems.emplace(&quot;expand&quot;, &quot;true&quot;);
1187              for(auto &amp;y : allItems)
1188              {
1189                  if(y.first == &quot;path&quot;)
1190                      continue;
1191                  arguments += y.first + &quot;=&quot; + urlEncode(y.second) + &quot;&amp;&quot;;
1192              }
1193              arguments.erase(arguments.size() - 1);
1194              request.argument = arguments;
1195              content = subconverter(request, response);
1196          }
1197          if(response.status_code != 200)
1198          {
1199              writeLog(0, &quot;Artifact &#x27;&quot; + x + &quot;&#x27; generate ERROR! Reason: &quot; + content + &quot;\n&quot;, LOG_LEVEL_ERROR);
1200              if(sections.size() == 1)
1201                  return -1;
1202              continue;
1203          }
1204          fileWrite(path, content, true);
1205          auto iter = std::find_if(response.headers.begin(), response.headers.end(), [](auto y){ return y.first == &quot;Subscription-UserInfo&quot;; });
1206          if(iter != response.headers.end())
1207              writeLog(0, &quot;User Info for artifact &#x27;&quot; + x + &quot;&#x27;: &quot; + subInfoToMessage(iter-&gt;second), LOG_LEVEL_INFO);
1208          writeLog(0, &quot;Artifact &#x27;&quot; + x + &quot;&#x27; generate SUCCESS!\n&quot;, LOG_LEVEL_INFO);
1209          eraseElements(response.headers);
1210      }
1211      writeLog(0, &quot;All artifact generated. Exiting...&quot;, LOG_LEVEL_INFO);
1212      return 0;
1213  }
1214  std::string renderTemplate(RESPONSE_CALLBACK_ARGS)
1215  {
1216      std::string &amp;argument = request.argument;
1217      int *status_code = &amp;response.status_code;
1218      std::string path = urlDecode(getUrlArg(argument, &quot;path&quot;));
1219      writeLog(0, &quot;Trying to render template &#x27;&quot; + path + &quot;&#x27;...&quot;, LOG_LEVEL_INFO);
1220      if(!startsWith(path, global.templatePath) || !fileExist(path))
1221      {
1222          *status_code = 404;
1223          return &quot;Not found&quot;;
1224      }
1225      std::string template_content = fetchFile(path, parseProxy(global.proxyConfig), global.cacheConfig);
1226      if(template_content.empty())
1227      {
1228          *status_code = 400;
1229          return &quot;File empty or out of scope&quot;;
1230      }
1231      template_args tpl_args;
1232      tpl_args.global_vars = global.templateVars;
1233      string_array req_args = split(argument, &quot;&amp;&quot;);
1234      string_size pos;
1235      string_map req_arg_map;
1236      for(std::string &amp;x : req_args)
1237      {
1238          pos = x.find(&quot;=&quot;);
1239          if(pos == x.npos)
1240              req_arg_map[x] = &quot;&quot;;
1241          else
1242              req_arg_map[x.substr(0, pos)] = x.substr(pos + 1);
1243      }
1244      tpl_args.request_params = req_arg_map;
1245      std::string output_content;
1246      if(render_template(template_content, tpl_args, output_content, global.templatePath) != 0)
1247      {
1248          *status_code = 400;
1249          writeLog(0, &quot;Render failed with error.&quot;, LOG_LEVEL_WARNING);
1250      }
1251      else
1252          writeLog(0, &quot;Render completed.&quot;, LOG_LEVEL_INFO);
1253      return output_content;
1254  }
</code></pre>
        </div>
        <div class="column">
            <h3>subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-interfaces.cpp</h3>
            <pre><code>1  #include &lt;iostream&gt;
2  #include &lt;string&gt;
3  #include &lt;mutex&gt;
4  #include &lt;numeric&gt;
5  #include &lt;inja.hpp&gt;
6  #include &lt;yaml-cpp/yaml.h&gt;
7  #include &quot;../config/binding.h&quot;
8  #include &quot;../generator/config/nodemanip.h&quot;
9  #include &quot;../generator/config/ruleconvert.h&quot;
10  #include &quot;../generator/config/subexport.h&quot;
11  #include &quot;../generator/template/templates.h&quot;
12  #include &quot;../script/cron.h&quot;
13  #include &quot;../script/script_quickjs.h&quot;
14  #include &quot;../server/webserver.h&quot;
15  #include &quot;../utils/base64/base64.h&quot;
16  #include &quot;../utils/file_extra.h&quot;
17  #include &quot;../utils/ini_reader/ini_reader.h&quot;
18  #include &quot;../utils/logger.h&quot;
19  #include &quot;../utils/network.h&quot;
20  #include &quot;../utils/regexp.h&quot;
21  #include &quot;../utils/stl_extra.h&quot;
22  #include &quot;../utils/string.h&quot;
23  #include &quot;../utils/string_hash.h&quot;
24  #include &quot;../utils/system.h&quot;
25  #include &quot;../utils/system.h&quot;
26  #include &quot;../utils/urlencode.h&quot;
27  #include &quot;../utils/yamlcpp_extra.h&quot;
28  #include &quot;interfaces.h&quot;
29  #include &quot;multithread.h&quot;
30  #include &quot;settings.h&quot;
31  #include &quot;upload.h&quot;
32  #include &quot;webget.h&quot;
33  extern WebServer webServer;
34  string_array gRegexBlacklist = {&quot;(.*)*&quot;};
35  void refreshRulesets(RulesetConfigs &amp;ruleset_list, std::vector&lt;RulesetContent&gt; &amp;ruleset_content_array);
36  std::string parseProxy(const std::string &amp;source)
37  {
38      std::string proxy = source;
39      if(source == &quot;SYSTEM&quot;)
40          proxy = getSystemProxy();
41      else if(source == &quot;NONE&quot;)
42          proxy = &quot;&quot;;
43      return proxy;
44  }
45  extern string_array ClashRuleTypes, SurgeRuleTypes, QuanXRuleTypes;
46  struct UAProfile
47  {
48      std::string head;
49      std::string version_match;
50      std::string version_target;
51      std::string target;
52      tribool clash_new_name = tribool();
53      int surge_ver = -1;
54  };
55  const std::vector&lt;UAProfile&gt; UAMatchList = {
56      {&quot;ClashForAndroid&quot;,&quot;\\/([0-9.]+)&quot;,&quot;2.0&quot;,&quot;clash&quot;,true},
57      {&quot;ClashForAndroid&quot;,&quot;\\/([0-9.]+)R&quot;,&quot;&quot;,&quot;clashr&quot;,false},
58      {&quot;ClashForAndroid&quot;,&quot;&quot;,&quot;&quot;,&quot;clash&quot;,false},
59      {&quot;ClashforWindows&quot;,&quot;\\/([0-9.]+)&quot;,&quot;0.11&quot;,&quot;clash&quot;,true},
60      {&quot;ClashforWindows&quot;,&quot;&quot;,&quot;&quot;,&quot;clash&quot;,false},
61      {&quot;ClashX Pro&quot;,&quot;&quot;,&quot;&quot;,&quot;clash&quot;,true},
62      {&quot;ClashX&quot;,&quot;\\/([0-9.]+)&quot;,&quot;0.13&quot;,&quot;clash&quot;,true},
63      {&quot;Clash&quot;,&quot;&quot;,&quot;&quot;,&quot;clash&quot;,true},
64      {&quot;Kitsunebi&quot;,&quot;&quot;,&quot;&quot;,&quot;v2ray&quot;},
65      {&quot;Loon&quot;,&quot;&quot;,&quot;&quot;,&quot;loon&quot;},
66      {&quot;Pharos&quot;,&quot;&quot;,&quot;&quot;,&quot;mixed&quot;},
67      {&quot;Potatso&quot;,&quot;&quot;,&quot;&quot;,&quot;mixed&quot;},
68      {&quot;Quantumult%20X&quot;,&quot;&quot;,&quot;&quot;,&quot;quanx&quot;},
69      {&quot;Quantumult&quot;,&quot;&quot;,&quot;&quot;,&quot;quan&quot;},
70      {&quot;Qv2ray&quot;,&quot;&quot;,&quot;&quot;,&quot;v2ray&quot;},
71      {&quot;Shadowrocket&quot;,&quot;&quot;,&quot;&quot;,&quot;mixed&quot;},
72      {&quot;Surfboard&quot;,&quot;&quot;,&quot;&quot;,&quot;surfboard&quot;},
73      {&quot;Surge&quot;,&quot;\\/([0-9.]+).*x86&quot;,&quot;906&quot;,&quot;surge&quot;,false,4}, 
74      {&quot;Surge&quot;,&quot;\\/([0-9.]+).*x86&quot;,&quot;368&quot;,&quot;surge&quot;,false,3}, 
75      {&quot;Surge&quot;,&quot;\\/([0-9.]+)&quot;,&quot;1419&quot;,&quot;surge&quot;,false,4}, 
76      {&quot;Surge&quot;,&quot;\\/([0-9.]+)&quot;,&quot;900&quot;,&quot;surge&quot;,false,3}, 
77      {&quot;Surge&quot;,&quot;&quot;,&quot;&quot;,&quot;surge&quot;,false,2}, 
78      {&quot;Trojan-Qt5&quot;,&quot;&quot;,&quot;&quot;,&quot;trojan&quot;},
79      {&quot;V2rayU&quot;,&quot;&quot;,&quot;&quot;,&quot;v2ray&quot;},
80      {&quot;V2RayX&quot;,&quot;&quot;,&quot;&quot;,&quot;v2ray&quot;}
81  };
82  bool verGreaterEqual(const std::string &amp;src_ver, const std::string &amp;target_ver)
83  {
84      string_size src_pos_beg = 0, src_pos_end, target_pos_beg = 0, target_pos_end;
85      while(true)
86      {
87          src_pos_end = src_ver.find(&#x27;.&#x27;, src_pos_beg);
88          if(src_pos_end == src_ver.npos)
89              src_pos_end = src_ver.size();
90          int part_src = std::stoi(src_ver.substr(src_pos_beg, src_pos_end - src_pos_beg));
91          target_pos_end = target_ver.find(&#x27;.&#x27;, target_pos_beg);
92          if(target_pos_end == target_ver.npos)
93              target_pos_end = target_ver.size();
94          int part_target = std::stoi(target_ver.substr(target_pos_beg, target_pos_end - target_pos_beg));
95          if(part_src &gt; part_target)
96              break;
97          else if(part_src &lt; part_target)
98              return false;
99          else if(src_pos_end &gt;= src_ver.size() - 1 || target_pos_end &gt;= target_ver.size() - 1)
100              break;
101          src_pos_beg = src_pos_end + 1;
102          target_pos_beg = target_pos_end + 1;
103      }
104      return true;
105  }
106  void matchUserAgent(const std::string &amp;user_agent, std::string &amp;target, tribool &amp;clash_new_name, int &amp;surge_ver)
107  {
108      if(user_agent.empty())
109          return;
110      for(const UAProfile &amp;x : UAMatchList)
111      {
112          if(startsWith(user_agent, x.head))
113          {
114              if(!x.version_match.empty())
115              {
116                  std::string version;
117                  if(regGetMatch(user_agent, x.version_match, 2, 0, &amp;version))
118                      continue;
119                  if(!x.version_target.empty() &amp;&amp; !verGreaterEqual(version, x.version_target))
120                      continue;
121              }
122              target = x.target;
123              clash_new_name = x.clash_new_name;
124              if(x.surge_ver != -1)
125                  surge_ver = x.surge_ver;
126              return;
127          }
128      }
129      return;
130  }
131  std::string getConvertedRuleset(RESPONSE_CALLBACK_ARGS)
132  {
133      std::string url = urlDecode(getUrlArg(request.argument, &quot;url&quot;)), type = getUrlArg(request.argument, &quot;type&quot;);
134      return convertRuleset(fetchFile(url, parseProxy(global.proxyRuleset), global.cacheRuleset), to_int(type));
135  }
136  std::string getRuleset(RESPONSE_CALLBACK_ARGS)
137  {
138      std::string &amp;argument = request.argument;
139      int *status_code = &amp;response.status_code;
140      std::string url = urlSafeBase64Decode(getUrlArg(argument, &quot;url&quot;)), type = getUrlArg(argument, &quot;type&quot;), group = urlSafeBase64Decode(getUrlArg(argument, &quot;group&quot;));
141      std::string output_content, dummy;
142      int type_int = to_int(type, 0);
143      if(!url.size() || !type.size() || (type_int == 2 &amp;&amp; !group.size()) || (type_int &lt; 1 || type_int &gt; 6))
144      {
145          *status_code = 400;
146          return &quot;Invalid request!&quot;;
147      }
148      std::string proxy = parseProxy(global.proxyRuleset);
149      string_array vArray = split(url, &quot;|&quot;);
150      for(std::string &amp;x : vArray)
151          x.insert(0, &quot;ruleset,&quot;);
152      std::vector&lt;RulesetContent&gt; rca;
153      RulesetConfigs confs = INIBinding::from&lt;RulesetConfig&gt;::from_ini(vArray);
154      refreshRulesets(confs, rca);
155      for(RulesetContent &amp;x : rca)
156      {
157          std::string content = x.rule_content.get();
158          output_content += convertRuleset(content, x.rule_type);
159      }
160      if(!output_content.size())
161      {
162          *status_code = 400;
163          return &quot;Invalid request!&quot;;
164      }
165      std::string strLine;
166      std::stringstream ss;
167      const std::string rule_match_regex = &quot;^(.*?,.*?)(,.*)(,.*)$&quot;;
168      ss &lt;&lt; output_content;
169      char delimiter = getLineBreak(output_content);
170      std::string::size_type lineSize, posb, pose;
171      auto filterLine = [&amp;]()
172      {
173          posb = 0;
174          pose = strLine.find(&#x27;,&#x27;);
175          if(pose == strLine.npos)
176              return 1;
177          posb = pose + 1;
178          pose = strLine.find(&#x27;,&#x27;, posb);
179          if(pose == strLine.npos)
180          {
181              pose = strLine.size();
182              if(strLine[pose - 1] == &#x27;\r&#x27;)
183                  pose--;
184          }
185          pose -= posb;
186          return 0;
187      };
188      lineSize = output_content.size();
189      output_content.clear();
190      output_content.reserve(lineSize);
191      if(type_int == 3 || type_int == 4 || type_int == 6)
192          output_content = &quot;payload:\n&quot;;
193      while(getline(ss, strLine, delimiter))
194      {
195          if(strFind(strLine, &quot;&amp;bsol;&amp;bsol;&quot;))
196          {
197              strLine.erase(strLine.find(&quot;&amp;bsol;&amp;bsol;&quot;));
198              strLine = trimWhitespace(strLine);
199          }
200          switch(type_int)
201          {
202          case 2:
203              if(!std::any_of(QuanXRuleTypes.begin(), QuanXRuleTypes.end(), [&amp;strLine](std::string type){return startsWith(strLine, type);}))
204                  continue;
205              break;
206          case 1:
207              if(!std::any_of(SurgeRuleTypes.begin(), SurgeRuleTypes.end(), [&amp;strLine](std::string type){return startsWith(strLine, type);}))
208                  continue;
209              break;
210          case 3:
211              if(!startsWith(strLine, &quot;DOMAIN-SUFFIX,&quot;) &amp;&amp; !startsWith(strLine, &quot;DOMAIN,&quot;))
212                  continue;
213              if(filterLine())
214                  continue;
215              output_content += &quot;  - &#x27;&quot;;
216              if(strLine[posb - 2] == &#x27;X&#x27;)
217                  output_content += &quot;+.&quot;;
218              output_content += strLine.substr(posb, pose);
219              output_content += &quot;&#x27;\n&quot;;
220              continue;
221          case 4:
222              if(!startsWith(strLine, &quot;IP-CIDR,&quot;) &amp;&amp; !startsWith(strLine, &quot;IP-CIDR6,&quot;))
223                  continue;
224              if(filterLine())
225                  continue;
226              output_content += &quot;  - &#x27;&quot;;
227              output_content += strLine.substr(posb, pose);
228              output_content += &quot;&#x27;\n&quot;;
229              continue;
230          case 5:
231              if(!startsWith(strLine, &quot;DOMAIN-SUFFIX,&quot;) &amp;&amp; !startsWith(strLine, &quot;DOMAIN,&quot;))
232                  continue;
233              if(filterLine())
234                  continue;
235              output_content += strLine.substr(posb, pose);
236              output_content += &#x27;\n&#x27;;
237              continue;
238          case 6:
239              if(!std::any_of(ClashRuleTypes.begin(), ClashRuleTypes.end(), [&amp;strLine](std::string type){return startsWith(strLine, type);}))
240                  continue;
241              output_content += &quot;  - &quot;;
242          }
243          lineSize = strLine.size();
244          if(lineSize &amp;&amp; strLine[lineSize - 1] == &#x27;\r&#x27;) 
245              strLine.erase(--lineSize);
246          if(!strLine.empty() &amp;&amp; (strLine[0] != &#x27;;&#x27; &amp;&amp; strLine[0] != &#x27;#&#x27; &amp;&amp; !(lineSize &gt;= 2 &amp;&amp; strLine[0] == &#x27;/&#x27; &amp;&amp; strLine[1] == &#x27;/&#x27;)))
247          {
248              if(type_int == 2)
249              {
250                  if(startsWith(strLine, &quot;IP-CIDR6&quot;))
251                      strLine.replace(0, 8, &quot;IP6-CIDR&quot;);
252                  strLine += &quot;,&quot; + group;
253                  if(count_least(strLine, &#x27;,&#x27;, 3) &amp;&amp; regReplace(strLine, rule_match_regex, &quot;$2&quot;) == &quot;,no-resolve&quot;)
254                      strLine = regReplace(strLine, rule_match_regex, &quot;$1$3$2&quot;);
255                  else
256                      strLine = regReplace(strLine, rule_match_regex, &quot;$1$3&quot;);
257              }
258          }
259          output_content += strLine;
260          output_content += &#x27;\n&#x27;;
261      }
262      if(output_content == &quot;payload:\n&quot;)
263      {
264          switch(type_int)
265          {
266          case 3:
267              output_content += &quot;  - &#x27;--placeholder--&#x27;&quot;;
268              break;
269          case 4:
270              output_content += &quot;  - &#x27;0.0.0.0/32&#x27;&quot;;
271              break;
272          case 6:
273              output_content += &quot;  - &#x27;DOMAIN,--placeholder--&#x27;&quot;;
274              break;
275          }
276      }
277      return output_content;
278  }
279  void checkExternalBase(const std::string &amp;path, std::string &amp;dest)
280  {
281      if(isLink(path) || (startsWith(path, global.basePath) &amp;&amp; fileExist(path)))
282          dest = path;
283  }
284  std::string subconverter(RESPONSE_CALLBACK_ARGS)
285  {
286      std::string &amp;argument = request.argument;
287      int *status_code = &amp;response.status_code;
288      std::string argTarget = getUrlArg(argument, &quot;target&quot;), argSurgeVer = getUrlArg(argument, &quot;ver&quot;);
289      tribool argClashNewField = getUrlArg(argument, &quot;new_name&quot;);
290      int intSurgeVer = argSurgeVer.size() ? to_int(argSurgeVer, 3) : 3;
291      if(argTarget == &quot;auto&quot;)
292          matchUserAgent(request.headers[&quot;User-Agent&quot;], argTarget, argClashNewField, intSurgeVer);
293      bool lSimpleSubscription = false;
294      switch(hash_(argTarget))
295      {
296      case &quot;ss&quot;_hash: case &quot;ssd&quot;_hash: case &quot;ssr&quot;_hash: case &quot;sssub&quot;_hash: case &quot;v2ray&quot;_hash: case &quot;trojan&quot;_hash: case &quot;mixed&quot;_hash:
297          lSimpleSubscription = true;
298          break;
299      case &quot;clash&quot;_hash: case &quot;clashr&quot;_hash: case &quot;surge&quot;_hash: case &quot;quan&quot;_hash: case &quot;quanx&quot;_hash: case &quot;loon&quot;_hash: case &quot;surfboard&quot;_hash: case &quot;mellow&quot;_hash:
300          break;
301      default:
302          *status_code = 400;
303          return &quot;Invalid target!&quot;;
304      }
305      if((!global.APIMode || global.CFWChildProcess) &amp;&amp; !global.generatorMode)
306          readConf();
307      std::string argUrl = urlDecode(getUrlArg(argument, &quot;url&quot;));
308      std::string argGroupName = urlDecode(getUrlArg(argument, &quot;group&quot;)), argUploadPath = getUrlArg(argument, &quot;upload_path&quot;);
309      std::string argIncludeRemark = urlDecode(getUrlArg(argument, &quot;include&quot;)), argExcludeRemark = urlDecode(getUrlArg(argument, &quot;exclude&quot;));
310      std::string argCustomGroups = urlSafeBase64Decode(getUrlArg(argument, &quot;groups&quot;)), argCustomRulesets = urlSafeBase64Decode(getUrlArg(argument, &quot;ruleset&quot;)), argExternalConfig = urlDecode(getUrlArg(argument, &quot;config&quot;));
311      std::string argDeviceID = getUrlArg(argument, &quot;dev_id&quot;), argFilename = urlDecode(getUrlArg(argument, &quot;filename&quot;)), argUpdateInterval = getUrlArg(argument, &quot;interval&quot;), argUpdateStrict = getUrlArg(argument, &quot;strict&quot;);
312      std::string argRenames = urlDecode(getUrlArg(argument, &quot;rename&quot;)), argFilterScript = urlDecode(getUrlArg(argument, &quot;filter_script&quot;));
313      tribool argUpload = getUrlArg(argument, &quot;upload&quot;), argEmoji = getUrlArg(argument, &quot;emoji&quot;), argAddEmoji = getUrlArg(argument, &quot;add_emoji&quot;), argRemoveEmoji = getUrlArg(argument, &quot;remove_emoji&quot;);
314      tribool argAppendType = getUrlArg(argument, &quot;append_type&quot;), argTFO = getUrlArg(argument, &quot;tfo&quot;), argUDP = getUrlArg(argument, &quot;udp&quot;), argGenNodeList = getUrlArg(argument, &quot;list&quot;);
315      tribool argSort = getUrlArg(argument, &quot;sort&quot;), argUseSortScript = getUrlArg(argument, &quot;sort_script&quot;);
316      tribool argGenClashScript = getUrlArg(argument, &quot;script&quot;), argEnableInsert = getUrlArg(argument, &quot;insert&quot;);
317      tribool argSkipCertVerify = getUrlArg(argument, &quot;scv&quot;), argFilterDeprecated = getUrlArg(argument, &quot;fdn&quot;), argExpandRulesets = getUrlArg(argument, &quot;expand&quot;), argAppendUserinfo = getUrlArg(argument, &quot;append_info&quot;);
318      tribool argPrependInsert = getUrlArg(argument, &quot;prepend&quot;), argGenClassicalRuleProvider = getUrlArg(argument, &quot;classic&quot;), argTLS13 = getUrlArg(argument, &quot;tls13&quot;);
319      std::string base_content, output_content;
320      ProxyGroupConfigs lCustomProxyGroups = global.customProxyGroups;
321      RulesetConfigs lCustomRulesets = global.customRulesets;
322      string_array lIncludeRemarks = global.includeRemarks, lExcludeRemarks = global.excludeRemarks;
323      std::vector&lt;RulesetContent&gt; lRulesetContent;
324      extra_settings ext;
325      std::string subInfo, dummy;
326      int interval = argUpdateInterval.size() ? to_int(argUpdateInterval, global.updateInterval) : global.updateInterval;
327      bool authorized = !global.APIMode || getUrlArg(argument, &quot;token&quot;) == global.accessToken, strict = argUpdateStrict.size() ? argUpdateStrict == &quot;true&quot; : global.updateStrict;
328      if(std::find(gRegexBlacklist.cbegin(), gRegexBlacklist.cend(), argIncludeRemark) != gRegexBlacklist.cend() || std::find(gRegexBlacklist.cbegin(), gRegexBlacklist.cend(), argExcludeRemark) != gRegexBlacklist.cend())
329          return &quot;Invalid request!&quot;;
330      std::string lClashBase = global.clashBase, lSurgeBase = global.surgeBase, lMellowBase = global.mellowBase, lSurfboardBase = global.surfboardBase;
331      std::string lQuanBase = global.quanBase, lQuanXBase = global.quanXBase, lLoonBase = global.loonBase, lSSSubBase = global.SSSubBase;
332      argEnableInsert.define(global.enableInsert);
333      if(!argUrl.size() &amp;&amp; (!global.APIMode || authorized))
334          argUrl = global.defaultUrls;
335      if((!argUrl.size() &amp;&amp; !(global.insertUrls.size() &amp;&amp; argEnableInsert)) || !argTarget.size())
336      {
337          *status_code = 400;
338          return &quot;Invalid request!&quot;;
339      }
340      string_array req_args = split(argument, &quot;&amp;&quot;);
341      string_map req_arg_map;
342      for(std::string &amp;x : req_args)
343      {
344          string_size pos = x.find(&quot;=&quot;);
345          if(pos == x.npos)
346          {
347              req_arg_map[x] = &quot;&quot;;
348              continue;
349          }
350          if(x.substr(0, pos) == &quot;token&quot;)
351              continue;
352          req_arg_map[x.substr(0, pos)] = x.substr(pos + 1);
353      }
354      req_arg_map[&quot;target&quot;] = argTarget;
355      req_arg_map[&quot;ver&quot;] = std::to_string(intSurgeVer);
356      template_args tpl_args;
357      tpl_args.global_vars = global.templateVars;
358      tpl_args.request_params = req_arg_map;
359      std::string proxy = parseProxy(global.proxySubscription);
360      ext.authorized = authorized;
361      ext.append_proxy_type = argAppendType.get(global.appendType);
362      if((argTarget == &quot;clash&quot; || argTarget == &quot;clashr&quot;) &amp;&amp; argGenClashScript.is_undef())
363          argExpandRulesets.define(true);
364      ext.clash_proxies_style = global.clashProxiesStyle;
365      ext.tfo.define(argTFO).define(global.TFOFlag);
366      ext.udp.define(argUDP).define(global.UDPFlag);
367      ext.skip_cert_verify.define(argSkipCertVerify).define(global.skipCertVerify);
368      ext.tls13.define(argTLS13).define(global.TLS13Flag);
369      ext.sort_flag = argSort.get(global.enableSort);
370      argUseSortScript.define(global.sortScript.size() != 0);
371      if(ext.sort_flag &amp;&amp; argUseSortScript)
372          ext.sort_script = global.sortScript;
373      ext.filter_deprecated = argFilterDeprecated.get(global.filterDeprecated);
374      ext.clash_new_field_name = argClashNewField.get(global.clashUseNewField);
375      ext.clash_script = argGenClashScript.get();
376      ext.clash_classical_ruleset = argGenClassicalRuleProvider.get();
377      if(!argExpandRulesets)
378          ext.clash_new_field_name = true;
379      else
380          ext.clash_script = false;
381      ext.nodelist = argGenNodeList;
382      ext.surge_ssr_path = global.surgeSSRPath;
383      ext.quanx_dev_id = argDeviceID.size() ? argDeviceID : global.quanXDevID;
384      ext.enable_rule_generator = global.enableRuleGen;
385      ext.overwrite_original_rules = global.overwriteOriginalRules;
386      if(!argExpandRulesets)
387          ext.managed_config_prefix = global.managedConfigPrefix;
388      if(argExternalConfig.empty())
389          argExternalConfig = global.defaultExtConfig;
390      if(argExternalConfig.size())
391      {
392          writeLog(0, &quot;External configuration file provided. Loading...&quot;, LOG_LEVEL_INFO);
393          ExternalConfig extconf;
394          extconf.tpl_args = &amp;tpl_args;
395          if(loadExternalConfig(argExternalConfig, extconf) == 0)
396          {
397              if(!ext.nodelist)
398              {
399                  checkExternalBase(extconf.sssub_rule_base, lSSSubBase);
400                  if(!lSimpleSubscription)
401                  {
402                      checkExternalBase(extconf.clash_rule_base, lClashBase);
403                      checkExternalBase(extconf.surge_rule_base, lSurgeBase);
404                      checkExternalBase(extconf.surfboard_rule_base, lSurfboardBase);
405                      checkExternalBase(extconf.mellow_rule_base, lMellowBase);
406                      checkExternalBase(extconf.quan_rule_base, lQuanBase);
407                      checkExternalBase(extconf.quanx_rule_base, lQuanXBase);
408                      checkExternalBase(extconf.loon_rule_base, lLoonBase);
409                      if(extconf.surge_ruleset.size())
410                          lCustomRulesets = extconf.surge_ruleset;
411                      if(extconf.custom_proxy_group.size())
412                          lCustomProxyGroups = extconf.custom_proxy_group;
413                      ext.enable_rule_generator = extconf.enable_rule_generator;
414                      ext.overwrite_original_rules = extconf.overwrite_original_rules;
415                  }
416              }
417              if(extconf.rename.size())
418                  ext.rename_array = extconf.rename;
419              if(extconf.emoji.size())
420                  ext.emoji_array = extconf.emoji;
421              if(extconf.include.size())
422                  lIncludeRemarks = extconf.include;
423              if(extconf.exclude.size())
424                  lExcludeRemarks = extconf.exclude;
425              argAddEmoji.define(extconf.add_emoji);
426              argRemoveEmoji.define(extconf.remove_old_emoji);
427          }
428      }
429      else
430      {
431          if(!lSimpleSubscription)
432          {
433              if(argCustomGroups.size() &amp;&amp; !ext.nodelist)
434              {
435                  string_array vArray = split(argCustomGroups, &quot;@&quot;);
436                  lCustomProxyGroups = INIBinding::from&lt;ProxyGroupConfig&gt;::from_ini(vArray);
437              }
438              if(argCustomRulesets.size() &amp;&amp; !ext.nodelist)
439              {
440                  string_array vArray = split(argCustomRulesets, &quot;@&quot;);
<span onclick='openModal()' class='match'>441                  lCustomRulesets = INIBinding::from&lt;RulesetConfig&gt;::from_ini(vArray);
442              }
443          }
</span>444      }
445      if(ext.enable_rule_generator &amp;&amp; !ext.nodelist &amp;&amp; !lSimpleSubscription)
446      {
447          if(lCustomRulesets != global.customRulesets)
448              refreshRulesets(lCustomRulesets, lRulesetContent);
449          else
450          {
451              if(global.updateRulesetOnRequest)
452                  refreshRulesets(global.customRulesets, global.rulesetsContent);
453              lRulesetContent = global.rulesetsContent;
454          }
455      }
456      if(!argEmoji.is_undef())
457      {
458          argAddEmoji.set(argEmoji);
459          argRemoveEmoji.set(true);
460      }
461      ext.add_emoji = argAddEmoji.get(global.addEmoji);
462      ext.remove_emoji = argRemoveEmoji.get(global.removeEmoji);
463      if(ext.add_emoji &amp;&amp; ext.emoji_array.empty())
464          ext.emoji_array = safe_get_emojis();
465      if(argRenames.size())
466          ext.rename_array = INIBinding::from&lt;RegexMatchConfig&gt;::from_ini(split(argRenames, &quot;`&quot;), &quot;@&quot;);
467      else if(ext.rename_array.empty())
468          ext.rename_array = safe_get_renames();
469      if(argIncludeRemark.size() &amp;&amp; regValid(argIncludeRemark))
470          lIncludeRemarks = string_array{argIncludeRemark};
471      if(argExcludeRemark.size() &amp;&amp; regValid(argExcludeRemark))
472          lExcludeRemarks = string_array{argExcludeRemark};
473      if(authorized &amp;&amp; !global.scriptCleanContext)
474      {
475          ext.js_runtime = new qjs::Runtime();
476          script_runtime_init(*ext.js_runtime);
477          ext.js_context = new qjs::Context(*ext.js_runtime);
478          script_context_init(*ext.js_context);
479      }
480      RegexMatchConfigs stream_temp = safe_get_streams(), time_temp = safe_get_times();
481      string_array urls;
482      std::vector&lt;Proxy&gt; nodes, insert_nodes;
483      int groupID = 0;
484      parse_settings parse_set;
485      parse_set.proxy = &amp;proxy;
486      parse_set.exclude_remarks = &amp;lExcludeRemarks;
487      parse_set.include_remarks = &amp;lIncludeRemarks;
488      parse_set.stream_rules = &amp;stream_temp;
489      parse_set.time_rules = &amp;time_temp;
490      parse_set.sub_info = &amp;subInfo;
491      parse_set.authorized = authorized;
492      parse_set.request_header = &amp;request.headers;
493      parse_set.js_runtime = ext.js_runtime;
494      parse_set.js_context = ext.js_context;
495      if(global.insertUrls.size() &amp;&amp; argEnableInsert)
496      {
497          groupID = -1;
498          urls = split(global.insertUrls, &quot;|&quot;);
499          importItems(urls, true);
500          for(std::string &amp;x : urls)
501          {
502              x = regTrim(x);
503              writeLog(0, &quot;Fetching node data from url &#x27;&quot; + x + &quot;&#x27;.&quot;, LOG_LEVEL_INFO);
504              if(addNodes(x, insert_nodes, groupID, parse_set) == -1)
505              {
506                  if(global.skipFailedLinks)
507                      writeLog(0, &quot;The following link doesn&#x27;t contain any valid node info: &quot; + x, LOG_LEVEL_WARNING);
508                  else
509                  {
510                      *status_code = 400;
511                      return &quot;The following link doesn&#x27;t contain any valid node info: &quot; + x;
512                  }
513              }
514              groupID--;
515          }
516      }
517      urls = split(argUrl, &quot;|&quot;);
518      importItems(urls, true);
519      groupID = 0;
520      for(std::string &amp;x : urls)
521      {
522          x = regTrim(x);
523          writeLog(0, &quot;Fetching node data from url &#x27;&quot; + x + &quot;&#x27;.&quot;, LOG_LEVEL_INFO);
524          if(addNodes(x, nodes, groupID, parse_set) == -1)
525          {
526              if(global.skipFailedLinks)
527                  writeLog(0, &quot;The following link doesn&#x27;t contain any valid node info: &quot; + x, LOG_LEVEL_WARNING);
528              else
529              {
530                  *status_code = 400;
531                  return &quot;The following link doesn&#x27;t contain any valid node info: &quot; + x;
532              }
533          }
534          groupID++;
535      }
536      if(!nodes.size() &amp;&amp; !insert_nodes.size())
537      {
538          *status_code = 400;
539          return &quot;No nodes were found!&quot;;
540      }
541      if(subInfo.size() &amp;&amp; argAppendUserinfo.get(global.appendUserinfo))
542          response.headers.emplace(&quot;Subscription-UserInfo&quot;, subInfo);
543      if(request.method == &quot;HEAD&quot;)
544          return &quot;&quot;;
545      argPrependInsert.define(global.prependInsert);
546      if(argPrependInsert)
547      {
548          std::move(nodes.begin(), nodes.end(), std::back_inserter(insert_nodes));
549          nodes.swap(insert_nodes);
550      }
551      else
552      {
553          std::move(insert_nodes.begin(), insert_nodes.end(), std::back_inserter(nodes));
554      }
555      std::string filterScript = global.filterScript;
556      if(authorized &amp;&amp; !argFilterScript.empty())
557          filterScript = argFilterScript;
558      if(filterScript.size())
559      {
560          if(startsWith(filterScript, &quot;path:&quot;))
561              filterScript = fileGet(filterScript.substr(5), false);
562          script_safe_runner(ext.js_runtime, ext.js_context, [&amp;](qjs::Context &amp;ctx)
563          {
564              try
565              {
566                  ctx.eval(filterScript);
567                  auto filter = (std::function&lt;bool(const Proxy&amp;)&gt;) ctx.eval(&quot;filter&quot;);
568                  nodes.erase(std::remove_if(nodes.begin(), nodes.end(), filter), nodes.end());
569              }
570              catch(qjs::exception)
571              {
572                  script_print_stack(ctx);
573              }
574          }, global.scriptCleanContext);
575      }
576      if(argGroupName.size())
577          for(Proxy &amp;x : nodes)
578              x.Group = argGroupName;
579      preprocessNodes(nodes, ext);
580      ProxyGroupConfigs dummy_group;
581      std::vector&lt;RulesetContent&gt; dummy_ruleset;
582      std::string managed_url = base64Decode(urlDecode(getUrlArg(argument, &quot;profile_data&quot;)));
583      if(managed_url.empty())
584          managed_url = global.managedConfigPrefix + &quot;/sub?&quot; + argument;
585      proxy = parseProxy(global.proxyConfig);
586      switch(hash_(argTarget))
587      {
588      case &quot;clash&quot;_hash: case &quot;clashr&quot;_hash:
589          writeLog(0, argTarget == &quot;clashr&quot; ? &quot;Generate target: ClashR&quot; : &quot;Generate target: Clash&quot;, LOG_LEVEL_INFO);
590          tpl_args.local_vars[&quot;clash.new_field_name&quot;] = ext.clash_new_field_name ? &quot;true&quot; : &quot;false&quot;;
591          response.headers[&quot;profile-update-interval&quot;] = std::to_string(interval / 3600);
592          if(ext.nodelist)
593          {
594              YAML::Node yamlnode;
595              proxyToClash(nodes, yamlnode, dummy_group, argTarget == &quot;clashr&quot;, ext);
596              output_content = YAML::Dump(yamlnode);
597          }
598          else
599          {
600              if(render_template(fetchFile(lClashBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)
601              {
602                  *status_code = 400;
603                  return base_content;
604              }
605              output_content = proxyToClash(nodes, base_content, lRulesetContent, lCustomProxyGroups, argTarget == &quot;clashr&quot;, ext);
606          }
607          if(argUpload)
608              uploadGist(argTarget, argUploadPath, output_content, false);
609          break;
610      case &quot;surge&quot;_hash:
611          writeLog(0, &quot;Generate target: Surge &quot; + std::to_string(intSurgeVer), LOG_LEVEL_INFO);
612          if(ext.nodelist)
613          {
614              output_content = proxyToSurge(nodes, base_content, dummy_ruleset, dummy_group, intSurgeVer, ext);
615              if(argUpload)
616                  uploadGist(&quot;surge&quot; + argSurgeVer + &quot;list&quot;, argUploadPath, output_content, true);
617          }
618          else
619          {
620              if(render_template(fetchFile(lSurgeBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)
621              {
622                  *status_code = 400;
623                  return base_content;
624              }
625              output_content = proxyToSurge(nodes, base_content, lRulesetContent, lCustomProxyGroups, intSurgeVer, ext);
626              if(argUpload)
627                  uploadGist(&quot;surge&quot; + argSurgeVer, argUploadPath, output_content, true);
628              if(global.writeManagedConfig &amp;&amp; global.managedConfigPrefix.size())
629                  output_content = &quot;#!MANAGED-CONFIG &quot; + managed_url + (interval ? &quot; interval=&quot; + std::to_string(interval) : &quot;&quot;) \
630                   + &quot; strict=&quot; + std::string(strict ? &quot;true&quot; : &quot;false&quot;) + &quot;\n\n&quot; + output_content;
631          }
632          break;
633      case &quot;surfboard&quot;_hash:
634          writeLog(0, &quot;Generate target: Surfboard&quot;, LOG_LEVEL_INFO);
635          if(render_template(fetchFile(lSurfboardBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)
636          {
637              *status_code = 400;
638              return base_content;
639          }
640          output_content = proxyToSurge(nodes, base_content, lRulesetContent, lCustomProxyGroups, -3, ext);
641          if(argUpload)
642              uploadGist(&quot;surfboard&quot;, argUploadPath, output_content, true);
643          if(global.writeManagedConfig &amp;&amp; global.managedConfigPrefix.size())
644              output_content = &quot;#!MANAGED-CONFIG &quot; + managed_url + (interval ? &quot; interval=&quot; + std::to_string(interval) : &quot;&quot;) \
645                   + &quot; strict=&quot; + std::string(strict ? &quot;true&quot; : &quot;false&quot;) + &quot;\n\n&quot; + output_content;
646          break;
647      case &quot;mellow&quot;_hash:
648          writeLog(0, &quot;Generate target: Mellow&quot;, LOG_LEVEL_INFO);
649          if(render_template(fetchFile(lMellowBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)
650          {
651              *status_code = 400;
652              return base_content;
653          }
654          output_content = proxyToMellow(nodes, base_content, lRulesetContent, lCustomProxyGroups, ext);
655          if(argUpload)
656              uploadGist(&quot;mellow&quot;, argUploadPath, output_content, true);
657          break;
658      case &quot;sssub&quot;_hash:
659          writeLog(0, &quot;Generate target: SS Subscription&quot;, LOG_LEVEL_INFO);
660          if(render_template(fetchFile(lSSSubBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)
661          {
662              *status_code = 400;
663              return base_content;
664          }
665          output_content = proxyToSSSub(base_content, nodes, ext);
666          if(argUpload)
667              uploadGist(&quot;sssub&quot;, argUploadPath, output_content, false);
668          break;
669      case &quot;ss&quot;_hash:
670          writeLog(0, &quot;Generate target: SS&quot;, LOG_LEVEL_INFO);
671          output_content = proxyToSingle(nodes, 1, ext);
672          if(argUpload)
673              uploadGist(&quot;ss&quot;, argUploadPath, output_content, false);
674          break;
675      case &quot;ssr&quot;_hash:
676          writeLog(0, &quot;Generate target: SSR&quot;, LOG_LEVEL_INFO);
677          output_content = proxyToSingle(nodes, 2, ext);
678          if(argUpload)
679              uploadGist(&quot;ssr&quot;, argUploadPath, output_content, false);
680          break;
681      case &quot;v2ray&quot;_hash:
682          writeLog(0, &quot;Generate target: v2rayN&quot;, LOG_LEVEL_INFO);
683          output_content = proxyToSingle(nodes, 4, ext);
684          if(argUpload)
685              uploadGist(&quot;v2ray&quot;, argUploadPath, output_content, false);
686          break;
687      case &quot;trojan&quot;_hash:
688          writeLog(0, &quot;Generate target: Trojan&quot;, LOG_LEVEL_INFO);
689          output_content = proxyToSingle(nodes, 8, ext);
690          if(argUpload)
691              uploadGist(&quot;trojan&quot;, argUploadPath, output_content, false);
692          break;
693      case &quot;mixed&quot;_hash:
694          writeLog(0, &quot;Generate target: Standard Subscription&quot;, LOG_LEVEL_INFO);
695          output_content = proxyToSingle(nodes, 15, ext);
696          if(argUpload)
697              uploadGist(&quot;sub&quot;, argUploadPath, output_content, false);
698          break;
699      case &quot;quan&quot;_hash:
700          writeLog(0, &quot;Generate target: Quantumult&quot;, LOG_LEVEL_INFO);
701          if(!ext.nodelist)
702          {
703              if(render_template(fetchFile(lQuanBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)
704              {
705                  *status_code = 400;
706                  return base_content;
707              }
708          }
709          output_content = proxyToQuan(nodes, base_content, lRulesetContent, lCustomProxyGroups, ext);
710          if(argUpload)
711              uploadGist(&quot;quan&quot;, argUploadPath, output_content, false);
712          break;
713      case &quot;quanx&quot;_hash:
714          writeLog(0, &quot;Generate target: Quantumult X&quot;, LOG_LEVEL_INFO);
715          if(!ext.nodelist)
716          {
717              if(render_template(fetchFile(lQuanXBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)
718              {
719                  *status_code = 400;
720                  return base_content;
721              }
722          }
723          output_content = proxyToQuanX(nodes, base_content, lRulesetContent, lCustomProxyGroups, ext);
724          if(argUpload)
725              uploadGist(&quot;quanx&quot;, argUploadPath, output_content, false);
726          break;
727      case &quot;loon&quot;_hash:
728          writeLog(0, &quot;Generate target: Loon&quot;, LOG_LEVEL_INFO);
729          if(!ext.nodelist)
730          {
731              if(render_template(fetchFile(lLoonBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)
732              {
733                  *status_code = 400;
734                  return base_content;
735              }
736          }
737          output_content = proxyToLoon(nodes, base_content, lRulesetContent, lCustomProxyGroups, ext);
738          if(argUpload)
739              uploadGist(&quot;loon&quot;, argUploadPath, output_content, false);
740          break;
741      case &quot;ssd&quot;_hash:
742          writeLog(0, &quot;Generate target: SSD&quot;, LOG_LEVEL_INFO);
743          output_content = proxyToSSD(nodes, argGroupName, subInfo, ext);
744          if(argUpload)
745              uploadGist(&quot;ssd&quot;, argUploadPath, output_content, false);
746          break;
747      default:
748          writeLog(0, &quot;Generate target: Unspecified&quot;, LOG_LEVEL_INFO);
749          *status_code = 500;
750          return &quot;Unrecognized target&quot;;
751      }
752      writeLog(0, &quot;Generate completed.&quot;, LOG_LEVEL_INFO);
753      if(argFilename.size())
754          response.headers.emplace(&quot;Content-Disposition&quot;, &quot;attachment; filename=\&quot;&quot; + argFilename + &quot;\&quot;; filename*=utf-8&#x27;&#x27;&quot; + urlEncode(argFilename));
755      return output_content;
756  }
757  std::string simpleToClashR(RESPONSE_CALLBACK_ARGS)
758  {
759      std::string &amp;argument = request.argument;
760      int *status_code = &amp;response.status_code;
761      std::string url = argument.size() &lt;= 8 ? &quot;&quot; : argument.substr(8);
762      if(!url.size() || argument.substr(0, 8) != &quot;sublink=&quot;)
763      {
764          *status_code = 400;
765          return &quot;Invalid request!&quot;;
766      }
767      if(url == &quot;sublink&quot;)
768      {
769          *status_code = 400;
770          return &quot;Please insert your subscription link instead of clicking the default link.&quot;;
771      }
772      request.argument = &quot;target=clashr&amp;url=&quot; + urlEncode(url);
773      return subconverter(request, response);
774  }
775  std::string surgeConfToClash(RESPONSE_CALLBACK_ARGS)
776  {
777      std::string &amp;argument = request.argument;
778      int *status_code = &amp;response.status_code;
779      INIReader ini;
780      string_array dummy_str_array;
781      std::vector&lt;Proxy&gt; nodes;
782      std::string base_content, url = argument.size() &lt;= 5 ? &quot;&quot; : argument.substr(5);
783      const std::string proxygroup_name = global.clashUseNewField ? &quot;proxy-groups&quot; : &quot;Proxy Group&quot;, rule_name = global.clashUseNewField ? &quot;rules&quot; : &quot;Rule&quot;;
784      ini.store_any_line = true;
785      if(!url.size())
786          url = global.defaultUrls;
787      if(!url.size() || argument.substr(0, 5) != &quot;link=&quot;)
788      {
789          *status_code = 400;
790          return &quot;Invalid request!&quot;;
791      }
792      if(url == &quot;link&quot;)
793      {
794          *status_code = 400;
795          return &quot;Please insert your subscription link instead of clicking the default link.&quot;;
796      }
797      writeLog(0, &quot;SurgeConfToClash called with url &#x27;&quot; + url + &quot;&#x27;.&quot;, LOG_LEVEL_INFO);
798      std::string proxy = parseProxy(global.proxyConfig);
799      YAML::Node clash;
800      template_args tpl_args;
801      tpl_args.global_vars = global.templateVars;
802      tpl_args.local_vars[&quot;clash.new_field_name&quot;] = global.clashUseNewField ? &quot;true&quot; : &quot;false&quot;;
803      tpl_args.request_params[&quot;target&quot;] = &quot;clash&quot;;
804      tpl_args.request_params[&quot;url&quot;] = url;
805      if(render_template(fetchFile(global.clashBase, proxy, global.cacheConfig), tpl_args, base_content, global.templatePath) != 0)
806      {
807          *status_code = 400;
808          return base_content;
809      }
810      clash = YAML::Load(base_content);
811      base_content = fetchFile(url, proxy, global.cacheConfig);
812      if(ini.Parse(base_content) != INIREADER_EXCEPTION_NONE)
813      {
814          std::string errmsg = &quot;Parsing Surge config failed! Reason: &quot; + ini.GetLastError();
815          writeLog(0, errmsg, LOG_LEVEL_ERROR);
816          *status_code = 400;
817          return errmsg;
818      }
819      if(!ini.SectionExist(&quot;Proxy&quot;) || !ini.SectionExist(&quot;Proxy Group&quot;) || !ini.SectionExist(&quot;Rule&quot;))
820      {
821          std::string errmsg = &quot;Incomplete surge config! Missing critical sections!&quot;;
822          writeLog(0, errmsg, LOG_LEVEL_ERROR);
823          *status_code = 400;
824          return errmsg;
825      }
826      string_multimap section;
827      ini.GetItems(&quot;Proxy Group&quot;, section);
828      std::string name, type, content;
829      string_array links;
830      links.emplace_back(url);
831      YAML::Node singlegroup;
832      for(auto &amp;x : section)
833      {
834          singlegroup.reset();
835          name = x.first;
836          content = x.second;
837          dummy_str_array = split(content, &quot;,&quot;);
838          if(!dummy_str_array.size())
839              continue;
840          type = dummy_str_array[0];
841          if(!(type == &quot;select&quot; || type == &quot;url-test&quot; || type == &quot;fallback&quot; || type == &quot;load-balance&quot;)) 
842              continue;
843          singlegroup[&quot;name&quot;] = name;
844          singlegroup[&quot;type&quot;] = type;
845          for(unsigned int i = 1; i &lt; dummy_str_array.size(); i++)
846          {
847              if(startsWith(dummy_str_array[i], &quot;url&quot;))
848                  singlegroup[&quot;url&quot;] = trim(dummy_str_array[i].substr(dummy_str_array[i].find(&quot;=&quot;) + 1));
849              else if(startsWith(dummy_str_array[i], &quot;interval&quot;))
850                  singlegroup[&quot;interval&quot;] = trim(dummy_str_array[i].substr(dummy_str_array[i].find(&quot;=&quot;) + 1));
851              else if(startsWith(dummy_str_array[i], &quot;policy-path&quot;))
852                  links.emplace_back(trim(dummy_str_array[i].substr(dummy_str_array[i].find(&quot;=&quot;) + 1)));
853              else
854                  singlegroup[&quot;proxies&quot;].push_back(trim(dummy_str_array[i]));
855          }
856          clash[proxygroup_name].push_back(singlegroup);
857      }
858      proxy = parseProxy(global.proxySubscription);
859      eraseElements(dummy_str_array);
860      RegexMatchConfigs dummy_regex_array;
861      std::string subInfo;
862      parse_settings parse_set;
863      parse_set.proxy = &amp;proxy;
864      parse_set.exclude_remarks = parse_set.include_remarks = &amp;dummy_str_array;
865      parse_set.stream_rules = parse_set.time_rules = &amp;dummy_regex_array;
866      parse_set.request_header = &amp;request.headers;
867      parse_set.sub_info = &amp;subInfo;
868      parse_set.authorized = !global.APIMode;
869      for(std::string &amp;x : links)
870      {
871          writeLog(0, &quot;Fetching node data from url &#x27;&quot; + x + &quot;&#x27;.&quot;, LOG_LEVEL_INFO);
872          if(addNodes(x, nodes, 0, parse_set) == -1)
873          {
874              if(global.skipFailedLinks)
875                  writeLog(0, &quot;The following link doesn&#x27;t contain any valid node info: &quot; + x, LOG_LEVEL_WARNING);
876              else
877              {
878                  *status_code = 400;
879                  return &quot;The following link doesn&#x27;t contain any valid node info: &quot; + x;
880              }
881          }
882      }
883      if(!nodes.size())
884      {
885          *status_code = 400;
886          return &quot;No nodes were found!&quot;;
887      }
888      extra_settings ext;
889      ext.sort_flag = global.enableSort;
890      ext.filter_deprecated = global.filterDeprecated;
891      ext.clash_new_field_name = global.clashUseNewField;
892      ext.udp = global.UDPFlag;
893      ext.tfo = global.TFOFlag;
894      ext.skip_cert_verify = global.skipCertVerify;
895      ext.tls13 = global.TLS13Flag;
896      ext.clash_proxies_style = global.clashProxiesStyle;
897      ProxyGroupConfigs dummy_groups;
898      proxyToClash(nodes, clash, dummy_groups, false, ext);
899      section.clear();
900      ini.GetItems(&quot;Proxy&quot;, section);
901      for(auto &amp;x : section)
902      {
903          singlegroup.reset();
904          name = x.first;
905          content = x.second;
906          dummy_str_array = split(content, &quot;,&quot;);
907          if(!dummy_str_array.size())
908              continue;
909          content = trim(dummy_str_array[0]);
910          switch(hash_(content))
911          {
912          case &quot;direct&quot;_hash:
913              singlegroup[&quot;name&quot;] = name;
914              singlegroup[&quot;type&quot;] = &quot;select&quot;;
915              singlegroup[&quot;proxies&quot;].push_back(&quot;DIRECT&quot;);
916              break;
917          case &quot;reject&quot;_hash:
918          case &quot;reject-tinygif&quot;_hash:
919              singlegroup[&quot;name&quot;] = name;
920              singlegroup[&quot;type&quot;] = &quot;select&quot;;
921              singlegroup[&quot;proxies&quot;].push_back(&quot;REJECT&quot;);
922              break;
923          default:
924              continue;
925          }
926          clash[proxygroup_name].push_back(singlegroup);
927      }
928      eraseElements(dummy_str_array);
929      ini.GetAll(&quot;Rule&quot;, &quot;{NONAME}&quot;, dummy_str_array);
930      YAML::Node rule;
931      string_array strArray;
932      std::string strLine;
933      std::stringstream ss;
934      std::string::size_type lineSize;
935      for(std::string &amp;x : dummy_str_array)
936      {
937          if(startsWith(x, &quot;RULE-SET&quot;))
938          {
939              strArray = split(x, &quot;,&quot;);
940              if(strArray.size() != 3)
941                  continue;
942              content = webGet(strArray[1], proxy, global.cacheRuleset);
943              if(!content.size())
944                  continue;
945              ss &lt;&lt; content;
946              char delimiter = getLineBreak(content);
947              while(getline(ss, strLine, delimiter))
948              {
949                  lineSize = strLine.size();
950                  if(lineSize &amp;&amp; strLine[lineSize - 1] == &#x27;\r&#x27;) 
951                      strLine.erase(--lineSize);
952                  if(!lineSize || strLine[0] == &#x27;;&#x27; || strLine[0] == &#x27;#&#x27; || (lineSize &gt;= 2 &amp;&amp; strLine[0] == &#x27;/&#x27; &amp;&amp; strLine[1] == &#x27;/&#x27;)) 
953                      continue;
954                  else if(!std::any_of(ClashRuleTypes.begin(), ClashRuleTypes.end(), [&amp;strLine](std::string type){return startsWith(strLine, type);})) 
955                      continue;
956                  strLine += strArray[2];
957                  if(count_least(strLine, &#x27;,&#x27;, 3))
958                      strLine = regReplace(strLine, &quot;^(.*?,.*?)(,.*)(,.*)$&quot;, &quot;$1$3$2&quot;);
959                  rule.push_back(strLine);
960              }
961              ss.clear();
962              continue;
963          }
964          else if(!std::any_of(ClashRuleTypes.begin(), ClashRuleTypes.end(), [&amp;strLine](std::string type){return startsWith(strLine, type);}))
965              continue;
966          rule.push_back(x);
967      }
968      clash[rule_name] = rule;
969      response.headers[&quot;profile-update-interval&quot;] = std::to_string(global.updateInterval / 3600);
970      writeLog(0, &quot;Conversion completed.&quot;, LOG_LEVEL_INFO);
971      return YAML::Dump(clash);
972  }
973  std::string getProfile(RESPONSE_CALLBACK_ARGS)
974  {
975      std::string &amp;argument = request.argument;
976      int *status_code = &amp;response.status_code;
977      std::string name = urlDecode(getUrlArg(argument, &quot;name&quot;)), token = urlDecode(getUrlArg(argument, &quot;token&quot;));
978      string_array profiles = split(name, &quot;|&quot;);
979      name = profiles[0];
980      if(token.empty() || name.empty())
981      {
982          *status_code = 403;
983          return &quot;Forbidden&quot;;
984      }
985      std::string profile_content;
986      if(fileExist(name))
987      {
988          profile_content = fileGet(name, true);
989      }
990      else
991      {
992          *status_code = 404;
993          return &quot;Profile not found&quot;;
994      }
995      writeLog(0, &quot;Trying to load profile &#x27;&quot; + name + &quot;&#x27;.&quot;, LOG_LEVEL_INFO);
996      INIReader ini;
997      if(ini.Parse(profile_content) != INIREADER_EXCEPTION_NONE &amp;&amp; !ini.SectionExist(&quot;Profile&quot;))
998      {
999          writeLog(0, &quot;Load profile failed! Reason: &quot; + ini.GetLastError(), LOG_LEVEL_ERROR);
1000          *status_code = 500;
1001          return &quot;Broken profile!&quot;;
1002      }
1003      writeLog(0, &quot;Trying to parse profile &#x27;&quot; + name + &quot;&#x27;.&quot;, LOG_LEVEL_INFO);
1004      string_multimap contents;
1005      ini.GetItems(&quot;Profile&quot;, contents);
1006      if(!contents.size())
1007      {
1008          writeLog(0, &quot;Load profile failed! Reason: Empty Profile section&quot;, LOG_LEVEL_ERROR);
1009          *status_code = 500;
1010          return &quot;Broken profile!&quot;;
1011      }
1012      auto profile_token = contents.find(&quot;profile_token&quot;);
1013      if(profiles.size() == 1 &amp;&amp; profile_token != contents.end())
1014      {
1015          if(token != profile_token-&gt;second)
1016          {
1017              *status_code = 403;
1018              return &quot;Forbidden&quot;;
1019          }
1020          token = global.accessToken;
1021      }
1022      else
1023      {
1024          if(token != global.accessToken)
1025          {
1026              *status_code = 403;
1027              return &quot;Forbidden&quot;;
1028          }
1029      }
1030      if(profiles.size() &gt; 1)
1031      {
1032          writeLog(0, &quot;Multiple profiles are provided. Trying to combine profiles...&quot;, LOG_TYPE_INFO);
1033          std::string all_urls, url;
1034          auto iter = contents.find(&quot;url&quot;);
1035          if(iter != contents.end())
1036              all_urls = iter-&gt;second;
1037          for(size_t i = 1; i &lt; profiles.size(); i++)
1038          {
1039              name = profiles[i];
1040              if(!fileExist(name))
1041              {
1042                  writeLog(0, &quot;Ignoring non-exist profile &#x27;&quot; + name + &quot;&#x27;...&quot;, LOG_LEVEL_WARNING);
1043                  continue;
1044              }
1045              if(ini.ParseFile(name) != INIREADER_EXCEPTION_NONE &amp;&amp; !ini.SectionExist(&quot;Profile&quot;))
1046              {
1047                  writeLog(0, &quot;Ignoring broken profile &#x27;&quot; + name + &quot;&#x27;...&quot;, LOG_LEVEL_WARNING);
1048                  continue;
1049              }
1050              url = ini.Get(&quot;Profile&quot;, &quot;url&quot;);
1051              if(url.size())
1052              {
1053                  all_urls += &quot;|&quot; + url;
1054                  writeLog(0, &quot;Profile url from &#x27;&quot; + name + &quot;&#x27; added.&quot;, LOG_LEVEL_INFO);
1055              }
1056              else
1057              {
1058                  writeLog(0, &quot;Profile &#x27;&quot; + name + &quot;&#x27; does not have url key. Skipping...&quot;, LOG_LEVEL_INFO);
1059              }
1060          }
1061          iter-&gt;second = all_urls;
1062      }
1063      contents.emplace(&quot;token&quot;, token);
1064      contents.emplace(&quot;profile_data&quot;, base64Encode(global.managedConfigPrefix + &quot;/getprofile?&quot; + argument));
1065      std::string query = std::accumulate(contents.begin(), contents.end(), std::string(), [](const std::string &amp;x, auto y){ return x + y.first + &quot;=&quot; + urlEncode(y.second) + &quot;&amp;&quot;; });
1066      query += argument;
1067      request.argument = query;
1068      return subconverter(request, response);
1069  }
1070  inline std::string intToStream(unsigned long long stream)
1071  {
1072      char chrs[16] = {}, units[6] = {&#x27; &#x27;, &#x27;K&#x27;, &#x27;M&#x27;, &#x27;G&#x27;, &#x27;T&#x27;, &#x27;P&#x27;};
1073      double streamval = stream;
1074      unsigned int level = 0;
1075      while(streamval &gt; 1024.0)
1076      {
1077          if(level &gt;= 5)
1078              break;
1079          level++;
1080          streamval /= 1024.0;
1081      }
1082      snprintf(chrs, 15, &quot;%.2f %cB&quot;, streamval, units[level]);
1083      return std::string(chrs);
1084  }
1085  std::string subInfoToMessage(std::string subinfo)
1086  {
1087      using ull = unsigned long long;
1088      subinfo = replaceAllDistinct(subinfo, &quot;; &quot;, &quot;&amp;&quot;);
1089      std::string retdata, useddata = &quot;N/A&quot;, totaldata = &quot;N/A&quot;, expirydata = &quot;N/A&quot;;
1090      std::string upload = getUrlArg(subinfo, &quot;upload&quot;), download = getUrlArg(subinfo, &quot;download&quot;), total = getUrlArg(subinfo, &quot;total&quot;), expire = getUrlArg(subinfo, &quot;expire&quot;);
1091      ull used = to_number&lt;ull&gt;(upload, 0) + to_number&lt;ull&gt;(download, 0), tot = to_number&lt;ull&gt;(total, 0);
1092      time_t expiry = to_number&lt;time_t&gt;(expire, 0);
1093      if(used != 0)
1094          useddata = intToStream(used);
1095      if(tot != 0)
1096          totaldata = intToStream(tot);
1097      if(expiry != 0)
1098      {
1099          char buffer[30];
1100          struct tm *dt = localtime(&amp;expiry);
1101          strftime(buffer, sizeof(buffer), &quot;%Y-%m-%d %H:%M&quot;, dt);
1102          expirydata.assign(buffer);
1103      }
1104      if(useddata == &quot;N/A&quot; &amp;&amp; totaldata == &quot;N/A&quot; &amp;&amp; expirydata == &quot;N/A&quot;)
1105          retdata = &quot;Not Available&quot;;
1106      else
1107          retdata += &quot;Stream Used: &quot; + useddata + &quot; Stream Total: &quot; + totaldata + &quot; Expiry Time: &quot; + expirydata;
1108      return retdata;
1109  }
1110  int simpleGenerator()
1111  {
1112      writeLog(0, &quot;Reading generator configuration...&quot;, LOG_LEVEL_INFO);
1113      std::string config = fileGet(&quot;generate.ini&quot;), path, profile, arguments, content;
1114      if(config.empty())
1115      {
1116          writeLog(0, &quot;Generator configuration not found or empty!&quot;, LOG_LEVEL_ERROR);
1117          return -1;
1118      }
1119      INIReader ini;
1120      if(ini.Parse(config) != INIREADER_EXCEPTION_NONE)
1121      {
1122          writeLog(0, &quot;Generator configuration broken! Reason:&quot; + ini.GetLastError(), LOG_LEVEL_ERROR);
1123          return -2;
1124      }
1125      writeLog(0, &quot;Read generator configuration completed.\n&quot;, LOG_LEVEL_INFO);
1126      string_array sections = ini.GetSections();
1127      if(global.generateProfiles.size())
1128      {
1129          writeLog(0, &quot;Generating with specific artifacts: \&quot;&quot; + global.generateProfiles + &quot;\&quot;...&quot;, LOG_LEVEL_INFO);
1130          string_array targets = split(global.generateProfiles, &quot;,&quot;), new_targets;
1131          for(std::string &amp;x : targets)
1132          {
1133              x = trim(x);
1134              if(std::find(sections.cbegin(), sections.cend(), x) != sections.cend())
1135                  new_targets.emplace_back(std::move(x));
1136              else
1137              {
1138                  writeLog(0, &quot;Artifact \&quot;&quot; + x + &quot;\&quot; not found in generator settings!&quot;, LOG_LEVEL_ERROR);
1139                  return -3;
1140              }
1141          }
1142          sections = new_targets;
1143          sections.shrink_to_fit();
1144      }
1145      else
1146          writeLog(0, &quot;Generating all artifacts...&quot;, LOG_LEVEL_INFO);
1147      string_multimap allItems;
1148      std::string proxy = parseProxy(global.proxySubscription);
1149      Request request;
1150      Response response;
1151      for(std::string &amp;x : sections)
1152      {
1153          arguments.clear();
1154          response.status_code = 200;
1155          writeLog(0, &quot;Generating artifact &#x27;&quot; + x + &quot;&#x27;...&quot;, LOG_LEVEL_INFO);
1156          ini.EnterSection(x);
1157          if(ini.ItemExist(&quot;path&quot;))
1158              path = ini.Get(&quot;path&quot;);
1159          else
1160          {
1161              writeLog(0, &quot;Artifact &#x27;&quot; + x + &quot;&#x27; output path missing! Skipping...\n&quot;, LOG_LEVEL_ERROR);
1162              continue;
1163          }
1164          if(ini.ItemExist(&quot;profile&quot;))
1165          {
1166              profile = ini.Get(&quot;profile&quot;);
1167              request.argument = &quot;name=&quot; + urlEncode(profile) + &quot;&amp;token=&quot; + global.accessToken + &quot;&amp;expand=true&quot;;
1168              content = getProfile(request, response);
1169          }
1170          else
1171          {
1172              if(ini.GetBool(&quot;direct&quot;) == true)
1173              {
1174                  std::string url = ini.Get(&quot;url&quot;);
1175                  content = fetchFile(url, proxy, global.cacheSubscription);
1176                  if(content.empty())
1177                  {
1178                      writeLog(0, &quot;Artifact &#x27;&quot; + x + &quot;&#x27; generate ERROR! Please check your link.\n&quot;, LOG_LEVEL_ERROR);
1179                      if(sections.size() == 1)
1180                          return -1;
1181                  }
1182                  fileWrite(path, &quot;\xEF\xBB\xBF&quot; + content, true);
1183                  continue;
1184              }
1185              ini.GetItems(allItems);
1186              allItems.emplace(&quot;expand&quot;, &quot;true&quot;);
1187              for(auto &amp;y : allItems)
1188              {
1189                  if(y.first == &quot;path&quot;)
1190                      continue;
1191                  arguments += y.first + &quot;=&quot; + urlEncode(y.second) + &quot;&amp;&quot;;
1192              }
1193              arguments.erase(arguments.size() - 1);
1194              request.argument = arguments;
1195              content = subconverter(request, response);
1196          }
1197          if(response.status_code != 200)
1198          {
1199              writeLog(0, &quot;Artifact &#x27;&quot; + x + &quot;&#x27; generate ERROR! Reason: &quot; + content + &quot;\n&quot;, LOG_LEVEL_ERROR);
1200              if(sections.size() == 1)
1201                  return -1;
1202              continue;
1203          }
1204          fileWrite(path, content, true);
1205          auto iter = std::find_if(response.headers.begin(), response.headers.end(), [](auto y){ return y.first == &quot;Subscription-UserInfo&quot;; });
1206          if(iter != response.headers.end())
1207              writeLog(0, &quot;User Info for artifact &#x27;&quot; + x + &quot;&#x27;: &quot; + subInfoToMessage(iter-&gt;second), LOG_LEVEL_INFO);
1208          writeLog(0, &quot;Artifact &#x27;&quot; + x + &quot;&#x27; generate SUCCESS!\n&quot;, LOG_LEVEL_INFO);
1209          eraseElements(response.headers);
1210      }
1211      writeLog(0, &quot;All artifact generated. Exiting...&quot;, LOG_LEVEL_INFO);
1212      return 0;
1213  }
1214  std::string renderTemplate(RESPONSE_CALLBACK_ARGS)
1215  {
1216      std::string &amp;argument = request.argument;
1217      int *status_code = &amp;response.status_code;
1218      std::string path = urlDecode(getUrlArg(argument, &quot;path&quot;));
1219      writeLog(0, &quot;Trying to render template &#x27;&quot; + path + &quot;&#x27;...&quot;, LOG_LEVEL_INFO);
1220      if(!startsWith(path, global.templatePath) || !fileExist(path))
1221      {
1222          *status_code = 404;
1223          return &quot;Not found&quot;;
1224      }
1225      std::string template_content = fetchFile(path, parseProxy(global.proxyConfig), global.cacheConfig);
1226      if(template_content.empty())
1227      {
1228          *status_code = 400;
1229          return &quot;File empty or out of scope&quot;;
1230      }
1231      template_args tpl_args;
1232      tpl_args.global_vars = global.templateVars;
1233      string_array req_args = split(argument, &quot;&amp;&quot;);
1234      string_size pos;
1235      string_map req_arg_map;
1236      for(std::string &amp;x : req_args)
1237      {
1238          pos = x.find(&quot;=&quot;);
1239          if(pos == x.npos)
1240              req_arg_map[x] = &quot;&quot;;
1241          else
1242              req_arg_map[x.substr(0, pos)] = x.substr(pos + 1);
1243      }
1244      tpl_args.request_params = req_arg_map;
1245      std::string output_content;
1246      if(render_template(template_content, tpl_args, output_content, global.templatePath) != 0)
1247      {
1248          *status_code = 400;
1249          writeLog(0, &quot;Render failed with error.&quot;, LOG_LEVEL_WARNING);
1250      }
1251      else
1252          writeLog(0, &quot;Render completed.&quot;, LOG_LEVEL_INFO);
1253      return output_content;
1254  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-interfaces.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from subconverter-MDEwOlJlcG9zaXRvcnkyMTg2ODY3NjM=-flat-interfaces.cpp</div>
                </div>
                <div class="column column_space"><pre><code>436                  lCustomProxyGroups = INIBinding::from&lt;ProxyGroupConfig&gt;::from_ini(vArray);
437              }
438              if(argCustomRulesets.size() &amp;&amp; !ext.nodelist)
</pre></code></div>
                <div class="column column_space"><pre><code>441                  lCustomRulesets = INIBinding::from&lt;RulesetConfig&gt;::from_ini(vArray);
442              }
443          }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    