
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 84, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>MMKV-MDEwOlJlcG9zaXRvcnkxNDkxMTE4MTM=-flat-MMKV_IO.cpp</h3>
            <pre><code>1  #include "MMKV_IO.h"
2  #include "CodedInputData.h"
3  #include "CodedOutputData.h"
4  #include "InterProcessLock.h"
5  #include "MMBuffer.h"
6  #include "MMKVLog.h"
7  #include "MMKVMetaInfo.hpp"
8  #include "MemoryFile.h"
9  #include "MiniPBCoder.h"
10  #include "PBUtility.h"
11  #include "ScopedLock.hpp"
12  #include "ThreadLock.h"
13  #include "aes/AESCrypt.h"
14  #include "aes/openssl/openssl_aes.h"
15  #include "aes/openssl/openssl_md5.h"
16  #include "crc32/Checksum.h"
17  #include <algorithm>
18  #include <cassert>
19  #include <cstring>
20  #include <ctime>
21  #ifdef MMKV_IOS
22  #    include "MMKV_OSX.h"
23  #endif
24  #ifdef MMKV_APPLE
25  #    if __has_feature(objc_arc)
26  #        error This file must be compiled with MRC. Use -fno-objc-arc flag.
27  #    endif
28  #endif 
29  using namespace std;
30  using namespace mmkv;
31  using KVHolderRet_t = std::pair<bool, KeyValueHolder>;
32  MMKV_NAMESPACE_BEGIN
33  void MMKV::loadFromFile() {
34      loadMetaInfoAndCheck();
35  #ifndef MMKV_DISABLE_CRYPT
36      if (m_crypter) {
37          if (m_metaInfo->m_version >= MMKVVersionRandomIV) {
38              m_crypter->resetIV(m_metaInfo->m_vector, sizeof(m_metaInfo->m_vector));
39          }
40      }
41  #endif
42      if (!m_file->isFileValid()) {
43          m_file->reloadFromFile();
44      }
45      if (!m_file->isFileValid()) {
46          MMKVError("file [%s] not valid", m_path.c_str());
47      } else {
48          bool loadFromFile = false, needFullWriteback = false;
49          checkDataValid(loadFromFile, needFullWriteback);
50          MMKVInfo("loading [%s] with %zu actual size, file size %zu, InterProcess %d, meta info "
51                   "version:%u",
52                   m_mmapID.c_str(), m_actualSize, m_file->getFileSize(), m_isInterProcess, m_metaInfo->m_version);
53          auto ptr = (uint8_t *) m_file->getMemory();
54          if (loadFromFile && m_actualSize > 0) {
55              MMKVInfo("loading [%s] with crc %u sequence %u version %u", m_mmapID.c_str(), m_metaInfo->m_crcDigest,
56                       m_metaInfo->m_sequence, m_metaInfo->m_version);
57              MMBuffer inputBuffer(ptr + Fixed32Size, m_actualSize, MMBufferNoCopy);
58              if (m_crypter) {
59                  clearDictionary(m_dicCrypt);
60              } else {
61                  clearDictionary(m_dic);
62              }
63              if (needFullWriteback) {
64  #ifndef MMKV_DISABLE_CRYPT
65                  if (m_crypter) {
66                      MiniPBCoder::greedyDecodeMap(*m_dicCrypt, inputBuffer, m_crypter);
67                  } else
68  #endif
69                  {
70                      MiniPBCoder::greedyDecodeMap(*m_dic, inputBuffer);
71                  }
72              } else {
73  #ifndef MMKV_DISABLE_CRYPT
74                  if (m_crypter) {
75                      MiniPBCoder::decodeMap(*m_dicCrypt, inputBuffer, m_crypter);
76                  } else
77  #endif
78                  {
79                      MiniPBCoder::decodeMap(*m_dic, inputBuffer);
80                  }
81              }
82              m_output = new CodedOutputData(ptr + Fixed32Size, m_file->getFileSize() - Fixed32Size);
83              m_output->seek(m_actualSize);
84              if (needFullWriteback) {
85                  fullWriteback();
86              }
87          } else {
88              SCOPED_LOCK(m_exclusiveProcessLock);
89              m_output = new CodedOutputData(ptr + Fixed32Size, m_file->getFileSize() - Fixed32Size);
90              if (m_actualSize > 0) {
91                  writeActualSize(0, 0, nullptr, IncreaseSequence);
92                  sync(MMKV_SYNC);
93              } else {
94                  writeActualSize(0, 0, nullptr, KeepSequence);
95              }
96          }
97          auto count = m_crypter ? m_dicCrypt->size() : m_dic->size();
98          MMKVInfo("loaded [%s] with %zu key-values", m_mmapID.c_str(), count);
99      }
100      m_needLoadFromFile = false;
101  }
102  void MMKV::partialLoadFromFile() {
103      m_metaInfo->read(m_metaFile->getMemory());
104      size_t oldActualSize = m_actualSize;
105      m_actualSize = readActualSize();
106      auto fileSize = m_file->getFileSize();
107      MMKVDebug("loading [%s] with file size %zu, oldActualSize %zu, newActualSize %zu", m_mmapID.c_str(), fileSize,
108                oldActualSize, m_actualSize);
109      if (m_actualSize > 0) {
110          if (m_actualSize < fileSize && m_actualSize + Fixed32Size <= fileSize) {
111              if (m_actualSize > oldActualSize) {
112                  auto position = oldActualSize;
113                  size_t addedSize = m_actualSize - position;
114                  auto basePtr = (uint8_t *) m_file->getMemory() + Fixed32Size;
115                  m_crcDigest = (uint32_t) CRC32(m_crcDigest, basePtr + position, addedSize);
116                  if (m_crcDigest == m_metaInfo->m_crcDigest) {
117                      MMBuffer inputBuffer(basePtr, m_actualSize, MMBufferNoCopy);
118  #ifndef MMKV_DISABLE_CRYPT
119                      if (m_crypter) {
120                          MiniPBCoder::greedyDecodeMap(*m_dicCrypt, inputBuffer, m_crypter, position);
121                      } else
122  #endif
123                      {
124                          MiniPBCoder::greedyDecodeMap(*m_dic, inputBuffer, position);
125                      }
126                      m_output->seek(addedSize);
127                      m_hasFullWriteback = false;
128                      [[maybe_unused]] auto count = m_crypter ? m_dicCrypt->size() : m_dic->size();
129                      MMKVDebug("partial loaded [%s] with %zu values", m_mmapID.c_str(), count);
130                      return;
131                  } else {
132                      MMKVError("m_crcDigest[%u] != m_metaInfo->m_crcDigest[%u]", m_crcDigest, m_metaInfo->m_crcDigest);
133                  }
134              }
135          }
136      }
137      clearMemoryCache();
138      loadFromFile();
139  }
140  void MMKV::loadMetaInfoAndCheck() {
141      if (!m_metaFile->isFileValid()) {
142          m_metaFile->reloadFromFile();
143      }
144      if (!m_metaFile->isFileValid()) {
145          MMKVError("file [%s] not valid", m_metaFile->getPath().c_str());
146          return;
147      }
148      m_metaInfo->read(m_metaFile->getMemory());
149      if (m_metaInfo->m_version >= MMKVVersionHolder) {
150          MMKVWarning("meta file [%s] in specious state, version %u, flags 0x%llx", m_mmapID.c_str(), m_metaInfo->m_version, m_metaInfo->m_flags);
151          m_metaInfo->m_version = MMKVVersionActualSize;
152          m_metaInfo->m_flags = 0;
153          m_metaInfo->write(m_metaFile->getMemory());
154      }
155      if (m_metaInfo->m_version >= MMKVVersionFlag) {
156          m_enableKeyExpire = m_metaInfo->hasFlag(MMKVMetaInfo::EnableKeyExipre);
157          MMKVInfo("meta file [%s] has flag [%llu]", m_mmapID.c_str(), m_metaInfo->m_flags);
158      } else {
159          if (m_metaInfo->m_flags != 0) {
160              m_metaInfo->m_flags = 0;
161              m_metaInfo->write(m_metaFile->getMemory());
162          }
163      }
164  }
165  void MMKV::checkDataValid(bool &loadFromFile, bool &needFullWriteback) {
166      auto fileSize = m_file->getFileSize();
167      auto checkLastConfirmedInfo = [&] {
168          if (m_metaInfo->m_version >= MMKVVersionActualSize) {
169              uint32_t oldStyleActualSize = 0;
170              memcpy(&oldStyleActualSize, m_file->getMemory(), Fixed32Size);
171              if (oldStyleActualSize != m_actualSize) {
172                  MMKVWarning("oldStyleActualSize %u not equal to meta actual size %lu", oldStyleActualSize,
173                              m_actualSize);
174                  if (oldStyleActualSize < fileSize && (oldStyleActualSize + Fixed32Size) <= fileSize) {
175                      if (checkFileCRCValid(oldStyleActualSize, m_metaInfo->m_crcDigest)) {
176                          MMKVInfo("looks like [%s] been downgrade & upgrade again", m_mmapID.c_str());
177                          loadFromFile = true;
178                          writeActualSize(oldStyleActualSize, m_metaInfo->m_crcDigest, nullptr, KeepSequence);
179                          return;
180                      }
181                  } else {
182                      MMKVWarning("oldStyleActualSize %u greater than file size %lu", oldStyleActualSize, fileSize);
183                  }
184              }
185              auto lastActualSize = m_metaInfo->m_lastConfirmedMetaInfo.lastActualSize;
186              if (lastActualSize < fileSize && (lastActualSize + Fixed32Size) <= fileSize) {
187                  auto lastCRCDigest = m_metaInfo->m_lastConfirmedMetaInfo.lastCRCDigest;
188                  if (checkFileCRCValid(lastActualSize, lastCRCDigest)) {
189                      loadFromFile = true;
190                      writeActualSize(lastActualSize, lastCRCDigest, nullptr, KeepSequence);
191                  } else {
192                      MMKVError("check [%s] error: lastActualSize %u, lastActualCRC %u", m_mmapID.c_str(), lastActualSize,
193                                lastCRCDigest);
194                  }
195              } else {
196                  MMKVError("check [%s] error: lastActualSize %u, file size is %u", m_mmapID.c_str(), lastActualSize,
197                            fileSize);
198              }
199          }
200      };
201      m_actualSize = readActualSize();
202      if (m_actualSize < fileSize && (m_actualSize + Fixed32Size) <= fileSize) {
203          if (checkFileCRCValid(m_actualSize, m_metaInfo->m_crcDigest)) {
204              loadFromFile = true;
205          } else {
206              checkLastConfirmedInfo();
207              if (!loadFromFile) {
208                  auto strategic = onMMKVCRCCheckFail(m_mmapID);
209                  if (strategic == OnErrorRecover) {
210                      loadFromFile = true;
211                      needFullWriteback = true;
212                  }
213                  MMKVInfo("recover strategic for [%s] is %d", m_mmapID.c_str(), strategic);
214              }
215          }
216      } else {
217          MMKVError("check [%s] error: %zu size in total, file size is %zu", m_mmapID.c_str(), m_actualSize, fileSize);
218          checkLastConfirmedInfo();
219          if (!loadFromFile) {
220              auto strategic = onMMKVFileLengthError(m_mmapID);
221              if (strategic == OnErrorRecover) {
222                  m_actualSize = fileSize - Fixed32Size;
223                  loadFromFile = true;
224                  needFullWriteback = true;
225              }
226              MMKVInfo("recover strategic for [%s] is %d", m_mmapID.c_str(), strategic);
227          }
228      }
229  }
230  void MMKV::checkLoadData() {
231      if (m_needLoadFromFile) {
232          SCOPED_LOCK(m_sharedProcessLock);
233          m_needLoadFromFile = false;
234          loadFromFile();
235          return;
236      }
237      if (!m_isInterProcess) {
238          return;
239      }
240      if (!m_metaFile->isFileValid()) {
241          return;
242      }
243      SCOPED_LOCK(m_sharedProcessLock);
244      MMKVMetaInfo metaInfo;
245      metaInfo.read(m_metaFile->getMemory());
246      if (m_metaInfo->m_sequence != metaInfo.m_sequence) {
247          MMKVInfo("[%s] oldSeq %u, newSeq %u", m_mmapID.c_str(), m_metaInfo->m_sequence, metaInfo.m_sequence);
248          SCOPED_LOCK(m_sharedProcessLock);
249          clearMemoryCache();
250          loadFromFile();
251          notifyContentChanged();
252      } else if (m_metaInfo->m_crcDigest != metaInfo.m_crcDigest) {
253          MMKVDebug("[%s] oldCrc %u, newCrc %u, new actualSize %u", m_mmapID.c_str(), m_metaInfo->m_crcDigest,
254                    metaInfo.m_crcDigest, metaInfo.m_actualSize);
255          SCOPED_LOCK(m_sharedProcessLock);
256          size_t fileSize = m_file->getActualFileSize();
257          if (m_file->getFileSize() != fileSize) {
258              MMKVInfo("file size has changed [%s] from %zu to %zu", m_mmapID.c_str(), m_file->getFileSize(), fileSize);
259              clearMemoryCache();
260              loadFromFile();
261          } else {
262              partialLoadFromFile();
263          }
264          notifyContentChanged();
265      }
266  }
267  constexpr uint32_t ItemSizeHolder = 0x00ffffff;
268  constexpr uint32_t ItemSizeHolderSize = 4;
269  static pair<MMBuffer, size_t> prepareEncode(const MMKVMap &dic) {
270      size_t totalSize = ItemSizeHolderSize;
271      for (auto &itr : dic) {
272          auto &kvHolder = itr.second;
273          totalSize += kvHolder.computedKVSize + kvHolder.valueSize;
274      }
275      return make_pair(MMBuffer(), totalSize);
276  }
277  #ifndef MMKV_DISABLE_CRYPT
278  static pair<MMBuffer, size_t> prepareEncode(const MMKVMapCrypt &dic) {
279      MMKVVector vec;
280      size_t totalSize = 0;
281      uint32_t smallestOffet = 5 + 1; 
282      for (auto &itr : dic) {
283          auto &kvHolder = itr.second;
284          if (kvHolder.type == KeyValueHolderType_Offset) {
285              totalSize += kvHolder.pbKeyValueSize + kvHolder.keySize + kvHolder.valueSize;
286              smallestOffet = min(smallestOffet, kvHolder.offset);
287          } else {
288              vec.emplace_back(itr.first, kvHolder.toMMBuffer(nullptr, nullptr));
289          }
290      }
291      if (smallestOffet > 5) {
292          smallestOffet = ItemSizeHolderSize;
293      }
294      totalSize += smallestOffet;
295      if (vec.empty()) {
296          return make_pair(MMBuffer(), totalSize);
297      }
298      auto buffer = MiniPBCoder::encodeDataWithObject(vec);
299      auto sizeOfMap = CodedInputData(buffer.getPtr(), buffer.length()).readUInt32();
300      totalSize += sizeOfMap;
301      return make_pair(std::move(buffer), totalSize);
302  }
303  #endif
304  static pair<MMBuffer, size_t> prepareEncode(MMKVVector &&vec) {
305      size_t totalSize = ItemSizeHolderSize;
306      auto buffer = MiniPBCoder::encodeDataWithObject(vec);
307      auto sizeOfMap = CodedInputData(buffer.getPtr(), buffer.length()).readUInt32();
308      totalSize += sizeOfMap;
309      return make_pair(std::move(buffer), totalSize);
310  }
311  bool MMKV::ensureMemorySize(size_t newSize) {
312      if (!isFileValid()) {
313          MMKVWarning("[%s] file not valid", m_mmapID.c_str());
314          return false;
315      }
316      if (newSize >= m_output->spaceLeft() || (m_crypter ? m_dicCrypt->empty() : m_dic->empty())) {
317          if (m_enableKeyExpire) {
318              filterExpiredKeys();
319          }
320          auto preparedData = m_crypter ? prepareEncode(*m_dicCrypt) : prepareEncode(*m_dic);
321          return expandAndWriteBack(newSize, std::move(preparedData));
322      }
323      return true;
324  }
325  bool MMKV::expandAndWriteBack(size_t newSize, std::pair<mmkv::MMBuffer, size_t> preparedData) {
326      auto fileSize = m_file->getFileSize();
327      auto sizeOfDic = preparedData.second;
328      size_t lenNeeded = sizeOfDic + Fixed32Size + newSize;
329      size_t dicCount = m_crypter ? m_dicCrypt->size() : m_dic->size();
330      size_t avgItemSize = lenNeeded / std::max<size_t>(1, dicCount);
331      size_t futureUsage = avgItemSize * std::max<size_t>(8, (dicCount + 1) / 2);
332      if (lenNeeded >= fileSize || (lenNeeded + futureUsage) >= fileSize) {
333          size_t oldSize = fileSize;
334          do {
335              fileSize *= 2;
336          } while (lenNeeded + futureUsage >= fileSize);
337          MMKVInfo("extending [%s] file size from %zu to %zu, incoming size:%zu, future usage:%zu", m_mmapID.c_str(),
338                   oldSize, fileSize, newSize, futureUsage);
339          if (!m_file->truncate(fileSize)) {
340              return false;
341          }
342          if (!isFileValid()) {
343              MMKVWarning("[%s] file not valid", m_mmapID.c_str());
344              return false;
345          }
346      }
347      return doFullWriteBack(std::move(preparedData), nullptr);
348  }
349  size_t MMKV::readActualSize() {
350      MMKV_ASSERT(m_file->getMemory());
351      MMKV_ASSERT(m_metaFile->isFileValid());
352      uint32_t actualSize = 0;
353      memcpy(&actualSize, m_file->getMemory(), Fixed32Size);
354      if (m_metaInfo->m_version >= MMKVVersionActualSize) {
355          if (m_metaInfo->m_actualSize != actualSize) {
356              MMKVWarning("[%s] actual size %u, meta actual size %u", m_mmapID.c_str(), actualSize,
357                          m_metaInfo->m_actualSize);
358          }
359          return m_metaInfo->m_actualSize;
360      } else {
361          return actualSize;
362      }
363  }
364  void MMKV::oldStyleWriteActualSize(size_t actualSize) {
365      MMKV_ASSERT(m_file->getMemory());
366      m_actualSize = actualSize;
367  #ifdef MMKV_IOS
368      auto ret = guardForBackgroundWriting(m_file->getMemory(), Fixed32Size);
369      if (!ret.first) {
370          return;
371      }
372  #endif
373      memcpy(m_file->getMemory(), &actualSize, Fixed32Size);
374  }
375  bool MMKV::writeActualSize(size_t size, uint32_t crcDigest, const void *iv, bool increaseSequence) {
376      oldStyleWriteActualSize(size);
377      if (!m_metaFile->isFileValid()) {
378          return false;
379      }
380      bool needsFullWrite = false;
381      m_actualSize = size;
382      m_metaInfo->m_actualSize = static_cast<uint32_t>(size);
383      m_crcDigest = crcDigest;
384      m_metaInfo->m_crcDigest = crcDigest;
385      if (m_metaInfo->m_version < MMKVVersionSequence) {
386          m_metaInfo->m_version = MMKVVersionSequence;
387          needsFullWrite = true;
388      }
389  #ifndef MMKV_DISABLE_CRYPT
390      if (unlikely(iv)) {
391          memcpy(m_metaInfo->m_vector, iv, sizeof(m_metaInfo->m_vector));
392          if (m_metaInfo->m_version < MMKVVersionRandomIV) {
393              m_metaInfo->m_version = MMKVVersionRandomIV;
394          }
395          needsFullWrite = true;
396      }
397  #endif
398      if (unlikely(increaseSequence)) {
399          m_metaInfo->m_sequence++;
400          m_metaInfo->m_lastConfirmedMetaInfo.lastActualSize = static_cast<uint32_t>(size);
401          m_metaInfo->m_lastConfirmedMetaInfo.lastCRCDigest = crcDigest;
402          if (m_metaInfo->m_version < MMKVVersionActualSize) {
403              m_metaInfo->m_version = MMKVVersionActualSize;
404          }
405          needsFullWrite = true;
406          MMKVInfo("[%s] increase sequence to %u, crc %u, actualSize %u", m_mmapID.c_str(), m_metaInfo->m_sequence,
407                   m_metaInfo->m_crcDigest, m_metaInfo->m_actualSize);
408      }
409      if (m_metaInfo->m_version < MMKVVersionFlag) {
410          m_metaInfo->m_flags = 0;
411          m_metaInfo->m_version = MMKVVersionFlag;
412          needsFullWrite = true;
413      }
414  #ifdef MMKV_IOS
415      auto ret = guardForBackgroundWriting(m_metaFile->getMemory(), sizeof(MMKVMetaInfo));
416      if (!ret.first) {
417          return false;
418      }
419  #endif
420      if (unlikely(needsFullWrite)) {
421          m_metaInfo->write(m_metaFile->getMemory());
422      } else {
423          m_metaInfo->writeCRCAndActualSizeOnly(m_metaFile->getMemory());
424      }
425      return true;
426  }
427  MMBuffer MMKV::getRawDataForKey(MMKVKey_t key) {
428      checkLoadData();
429  #ifndef MMKV_DISABLE_CRYPT
430      if (m_crypter) {
431          auto itr = m_dicCrypt->find(key);
432          if (itr != m_dicCrypt->end()) {
433              auto basePtr = (uint8_t *) (m_file->getMemory()) + Fixed32Size;
434              return itr->second.toMMBuffer(basePtr, m_crypter);
435          }
436      } else
437  #endif
438      {
439          auto itr = m_dic->find(key);
440          if (itr != m_dic->end()) {
441              auto basePtr = (uint8_t *) (m_file->getMemory()) + Fixed32Size;
442              return itr->second.toMMBuffer(basePtr);
443          }
444      }
445      MMBuffer nan;
446      return nan;
447  }
448  mmkv::MMBuffer MMKV::getDataForKey(MMKVKey_t key) {
449      if (unlikely(m_enableKeyExpire)) {
450          return getDataWithoutMTimeForKey(key);
451      }
452      return getRawDataForKey(key);
453  }
454  #ifndef MMKV_DISABLE_CRYPT
455  #    if defined(TARGET_OS_SIMULATOR) && defined(TARGET_CPU_X86)
456  static AESCryptStatus t_status;
457  #    else
458  thread_local AESCryptStatus t_status;
459  #    endif
460  #endif 
461  bool MMKV::setDataForKey(MMBuffer &&data, MMKVKey_t key, bool isDataHolder) {
462      if ((!isDataHolder && data.length() == 0) || isKeyEmpty(key)) {
463          return false;
464      }
465      SCOPED_LOCK(m_lock);
466      SCOPED_LOCK(m_exclusiveProcessLock);
467      checkLoadData();
468  #ifndef MMKV_DISABLE_CRYPT
469      if (m_crypter) {
470          if (isDataHolder) {
471              auto sizeNeededForData = pbRawVarint32Size((uint32_t) data.length()) + data.length();
472              if (!KeyValueHolderCrypt::isValueStoredAsOffset(sizeNeededForData)) {
473                  data = MiniPBCoder::encodeDataWithObject(data);
474                  isDataHolder = false;
475              }
476          }
477          auto itr = m_dicCrypt->find(key);
478          if (itr != m_dicCrypt->end()) {
479  #    ifdef MMKV_APPLE
480              auto ret = appendDataWithKey(data, key, itr->second, isDataHolder);
481  #    else
482              auto ret = appendDataWithKey(data, key, isDataHolder);
483  #    endif
484              if (!ret.first) {
485                  return false;
486              }
487              KeyValueHolderCrypt kvHolder;
488              if (KeyValueHolderCrypt::isValueStoredAsOffset(ret.second.valueSize)) {
489                  kvHolder = KeyValueHolderCrypt(ret.second.keySize, ret.second.valueSize, ret.second.offset);
490                  memcpy(&kvHolder.cryptStatus, &t_status, sizeof(t_status));
491              } else {
492                  kvHolder = KeyValueHolderCrypt(std::move(data));
493              }
494              if (likely(!m_enableKeyExpire)) {
495                  itr->second = std::move(kvHolder);
496              } else {
497                  itr = m_dicCrypt->find(key);
498                  if (itr != m_dicCrypt->end()) {
499                      itr->second = std::move(kvHolder);
500                  } else {
501                      m_dicCrypt->emplace(key, std::move(kvHolder));
502                      retain_key(key);
503                  }
504              }
505          } else {
506              auto ret = appendDataWithKey(data, key, isDataHolder);
507              if (!ret.first) {
508                  return false;
509              }
510              if (KeyValueHolderCrypt::isValueStoredAsOffset(ret.second.valueSize)) {
511                  auto r = m_dicCrypt->emplace(
512                      key, KeyValueHolderCrypt(ret.second.keySize, ret.second.valueSize, ret.second.offset));
513                  if (r.second) {
514                      memcpy(&(r.first->second.cryptStatus), &t_status, sizeof(t_status));
515                  }
516              } else {
517                  m_dicCrypt->emplace(key, KeyValueHolderCrypt(std::move(data)));
518              }
519              retain_key(key);
520          }
521      } else
522  #endif 
523      {
524          auto itr = m_dic->find(key);
525          if (itr != m_dic->end()) {
526              if (likely(!m_enableKeyExpire)) {
527                  auto ret = appendDataWithKey(data, itr->second, isDataHolder);
528                  if (!ret.first) {
529                      return false;
530                  }
531                  itr->second = std::move(ret.second);
532              } else {
533                  auto ret = appendDataWithKey(data, key, isDataHolder);
534                  if (!ret.first) {
535                      return false;
536                  }
537                  itr = m_dic->find(key);
538                  if (itr != m_dic->end()) {
539                      itr->second = std::move(ret.second);
540                  } else {
541                      m_dic->emplace(key, std::move(ret.second));
542                      retain_key(key);
543                  }
544              }
545          } else {
546              auto ret = appendDataWithKey(data, key, isDataHolder);
547              if (!ret.first) {
548                  return false;
549              }
550              m_dic->emplace(key, std::move(ret.second));
551              retain_key(key);
552          }
553      }
554      m_hasFullWriteback = false;
555      return true;
556  }
557  bool MMKV::removeDataForKey(MMKVKey_t key) {
558      if (isKeyEmpty(key)) {
559          return false;
560      }
561  #ifndef MMKV_DISABLE_CRYPT
562      if (m_crypter) {
563          auto itr = m_dicCrypt->find(key);
564          if (itr != m_dicCrypt->end()) {
565              m_hasFullWriteback = false;
566              static MMBuffer nan;
567  #    ifdef MMKV_APPLE
568              auto ret = appendDataWithKey(nan, key, itr->second);
569              if (ret.first) {
570                  if (unlikely(m_enableKeyExpire)) {
571                      itr = m_dicCrypt->find(key);
572                      if (itr == m_dicCrypt->end()) {
573                          return true;
574                      }
575                  }
576                  auto oldKey = itr->first;
577                  m_dicCrypt->erase(itr);
578                  [oldKey release];
579              }
580  #    else
581              auto ret = appendDataWithKey(nan, key);
582              if (ret.first) {
583                  if (unlikely(m_enableKeyExpire)) {
584                      m_dicCrypt->erase(key);
585                  } else {
586                      m_dicCrypt->erase(itr);
587                  }
588              }
589  #    endif
590              return ret.first;
591          }
592      } else
593  #endif 
594      {
595          auto itr = m_dic->find(key);
596          if (itr != m_dic->end()) {
597              m_hasFullWriteback = false;
598              static MMBuffer nan;
599              auto ret = likely(!m_enableKeyExpire) ? appendDataWithKey(nan, itr->second) : appendDataWithKey(nan, key);
600              if (ret.first) {
601  #ifdef MMKV_APPLE
602                  if (unlikely(m_enableKeyExpire)) {
603                      itr = m_dic->find(key);
604                      if (itr == m_dic->end()) {
605                          return true;
606                      }
607                  }
608                  auto oldKey = itr->first;
609                  m_dic->erase(itr);
610                  [oldKey release];
611  #else
612                  if (unlikely(m_enableKeyExpire)) {
613                      m_dic->erase(key);
614                  } else {
615                      m_dic->erase(itr);
616                  }
617  #endif
618              }
619              return ret.first;
620          }
621      }
622      return false;
623  }
624  KVHolderRet_t
625  MMKV::doAppendDataWithKey(const MMBuffer &data, const MMBuffer &keyData, bool isDataHolder, uint32_t originKeyLength) {
626      auto isKeyEncoded = (originKeyLength < keyData.length());
627      auto keyLength = static_cast<uint32_t>(keyData.length());
628      auto valueLength = static_cast<uint32_t>(data.length());
629      if (isDataHolder) {
630          valueLength += pbRawVarint32Size(valueLength);
631      }
632      size_t size = isKeyEncoded ? keyLength : (keyLength + pbRawVarint32Size(keyLength));
633      size += valueLength + pbRawVarint32Size(valueLength);
634      SCOPED_LOCK(m_exclusiveProcessLock);
635      bool hasEnoughSize = ensureMemorySize(size);
636      if (!hasEnoughSize || !isFileValid()) {
637          return make_pair(false, KeyValueHolder());
638      }
639  #ifdef MMKV_IOS
640      auto ret = guardForBackgroundWriting(m_output->curWritePointer(), size);
641      if (!ret.first) {
642          return make_pair(false, KeyValueHolder());
643      }
644  #endif
645  #ifndef MMKV_DISABLE_CRYPT
646      if (m_crypter) {
647          if (KeyValueHolderCrypt::isValueStoredAsOffset(valueLength)) {
648              m_crypter->getCurStatus(t_status);
649          }
650      }
651  #endif
652      try {
653          if (isKeyEncoded) {
654              m_output->writeRawData(keyData);
655          } else {
656              m_output->writeData(keyData);
657          }
658          if (isDataHolder) {
659              m_output->writeRawVarint32((int32_t) valueLength);
660          }
661          m_output->writeData(data); 
662      } catch (std::exception &e) {
663          MMKVError("%s", e.what());
664          return make_pair(false, KeyValueHolder());
665      }
666      auto offset = static_cast<uint32_t>(m_actualSize);
667      auto ptr = (uint8_t *) m_file->getMemory() + Fixed32Size + m_actualSize;
668  #ifndef MMKV_DISABLE_CRYPT
669      if (m_crypter) {
670          m_crypter->encrypt(ptr, ptr, size);
671      }
672  #endif
673      m_actualSize += size;
674      updateCRCDigest(ptr, size);
675      return make_pair(true, KeyValueHolder(originKeyLength, valueLength, offset));
676  }
677  KVHolderRet_t MMKV::appendDataWithKey(const MMBuffer &data, MMKVKey_t key, bool isDataHolder) {
678  #ifdef MMKV_APPLE
679      auto oData = [key dataUsingEncoding:NSUTF8StringEncoding];
680      auto keyData = MMBuffer(oData, MMBufferNoCopy);
681  #else
682      auto keyData = MMBuffer((void *) key.data(), key.size(), MMBufferNoCopy);
683  #endif
684      return doAppendDataWithKey(data, keyData, isDataHolder, static_cast<uint32_t>(keyData.length()));
685  }
686  KVHolderRet_t MMKV::appendDataWithKey(const MMBuffer &data, const KeyValueHolder &kvHolder, bool isDataHolder) {
687      SCOPED_LOCK(m_exclusiveProcessLock);
688      uint32_t keyLength = kvHolder.keySize;
689      size_t rawKeySize = keyLength + pbRawVarint32Size(keyLength);
690      {
691          auto valueLength = static_cast<uint32_t>(data.length());
692          if (isDataHolder) {
693              valueLength += pbRawVarint32Size(valueLength);
694          }
695          auto size = rawKeySize + valueLength + pbRawVarint32Size(valueLength);
696          bool hasEnoughSize = ensureMemorySize(size);
697          if (!hasEnoughSize) {
698              return make_pair(false, KeyValueHolder());
699          }
700      }
701      auto basePtr = (uint8_t *) m_file->getMemory() + Fixed32Size;
702      MMBuffer keyData(basePtr + kvHolder.offset, rawKeySize, MMBufferNoCopy);
703      return doAppendDataWithKey(data, keyData, isDataHolder, keyLength);
704  }
705  bool MMKV::fullWriteback(AESCrypt *newCrypter) {
706      if (m_hasFullWriteback) {
707          return true;
708      }
709      if (m_needLoadFromFile) {
710          return true;
711      }
712      if (!isFileValid()) {
713          MMKVWarning("[%s] file not valid", m_mmapID.c_str());
714          return false;
715      }
716      if (unlikely(m_enableKeyExpire)) {
717          filterExpiredKeys();
718      }
719      if (m_crypter ? m_dicCrypt->empty() : m_dic->empty()) {
720          clearAll();
721          return true;
722      }
723      SCOPED_LOCK(m_exclusiveProcessLock);
724      auto preparedData = m_crypter ? prepareEncode(*m_dicCrypt) : prepareEncode(*m_dic);
725      auto sizeOfDic = preparedData.second;
726      if (sizeOfDic > 0) {
727          auto fileSize = m_file->getFileSize();
728          if (sizeOfDic + Fixed32Size <= fileSize) {
729              return doFullWriteBack(std::move(preparedData), newCrypter);
730          } else {
731              assert(0);
732              assert(newCrypter == nullptr);
733              auto newSize = sizeOfDic + Fixed32Size - fileSize;
734              return expandAndWriteBack(newSize, std::move(preparedData));
735          }
736      }
737      return false;
738  }
739  static void
740  memmoveDictionary(MMKVMap &dic, CodedOutputData *output, uint8_t *ptr, AESCrypt *encrypter, size_t totalSize) {
741      auto originOutputPtr = output->curWritePointer();
742      auto writePtr = originOutputPtr + ItemSizeHolderSize;
743      if (!dic.empty()) {
744          vector<KeyValueHolder *> vec;
745          vec.reserve(dic.size());
746          for (auto &itr : dic) {
747              vec.push_back(&itr.second);
748          }
749          sort(vec.begin(), vec.end(), [](const auto &left, const auto &right) { return left->offset < right->offset; });
750          vector<pair<uint32_t, uint32_t>> dataSections; 
751          dataSections.emplace_back(vec.front()->offset, vec.front()->computedKVSize + vec.front()->valueSize);
752          for (size_t index = 1, total = vec.size(); index < total; index++) {
753              auto kvHolder = vec[index];
754              auto &lastSection = dataSections.back();
755              if (kvHolder->offset == lastSection.first + lastSection.second) {
756                  lastSection.second += kvHolder->computedKVSize + kvHolder->valueSize;
757              } else {
758                  dataSections.emplace_back(kvHolder->offset, kvHolder->computedKVSize + kvHolder->valueSize);
759              }
760          }
761          auto basePtr = ptr + Fixed32Size;
762          for (auto &section : dataSections) {
763              memmove(writePtr, basePtr + section.first, section.second);
764              writePtr += section.second;
765          }
766          if (!encrypter) {
767              auto offset = ItemSizeHolderSize;
768              for (auto kvHolder : vec) {
769                  kvHolder->offset = offset;
770                  offset += kvHolder->computedKVSize + kvHolder->valueSize;
771              }
772          }
773      }
774      output->writeRawVarint32(ItemSizeHolder);
775      auto writtenSize = static_cast<size_t>(writePtr - originOutputPtr);
776  #ifndef MMKV_DISABLE_CRYPT
777      if (encrypter) {
778          encrypter->encrypt(originOutputPtr, originOutputPtr, writtenSize);
779      }
780  #endif
781      assert(writtenSize == totalSize);
782      output->seek(writtenSize - ItemSizeHolderSize);
783  }
784  #ifndef MMKV_DISABLE_CRYPT
785  static void memmoveDictionary(MMKVMapCrypt &dic,
786                                CodedOutputData *output,
787                                uint8_t *ptr,
788                                AESCrypt *decrypter,
789                                AESCrypt *encrypter,
790                                pair<MMBuffer, size_t> &preparedData) {
791      vector<KeyValueHolderCrypt *> vec;
792      if (!dic.empty()) {
793          vec.reserve(dic.size());
794          for (auto &itr : dic) {
795              if (itr.second.type == KeyValueHolderType_Offset) {
796                  vec.push_back(&itr.second);
797              }
798          }
799          sort(vec.begin(), vec.end(), [](auto left, auto right) { return left->offset < right->offset; });
800      }
801      auto sizeHolder = ItemSizeHolder, sizeHolderSize = ItemSizeHolderSize;
802      if (!vec.empty()) {
803          auto smallestOffset = vec.front()->offset;
804          if (smallestOffset != ItemSizeHolderSize && smallestOffset <= 5) {
805              sizeHolderSize = smallestOffset;
806              assert(sizeHolderSize != 0);
807              static const uint32_t ItemSizeHolders[] = {0, 0x0f, 0xff, 0xffff, 0xffffff, 0xffffffff};
808              sizeHolder = ItemSizeHolders[sizeHolderSize];
809          }
810      }
811      output->writeRawVarint32(static_cast<int32_t>(sizeHolder));
812      auto writePtr = output->curWritePointer();
813      if (encrypter) {
814          encrypter->encrypt(writePtr - sizeHolderSize, writePtr - sizeHolderSize, sizeHolderSize);
815      }
816      if (!vec.empty()) {
817          vector<tuple<uint32_t, uint32_t, AESCryptStatus *>> dataSections; 
818          dataSections.push_back(vec.front()->toTuple());
819          for (size_t index = 1, total = vec.size(); index < total; index++) {
820              auto kvHolder = vec[index];
821              auto &lastSection = dataSections.back();
822              if (kvHolder->offset == get<0>(lastSection) + get<1>(lastSection)) {
823                  get<1>(lastSection) += kvHolder->pbKeyValueSize + kvHolder->keySize + kvHolder->valueSize;
824              } else {
825                  dataSections.push_back(kvHolder->toTuple());
826              }
827          }
828          auto basePtr = ptr + Fixed32Size;
829          for (auto &section : dataSections) {
830              auto crypter = decrypter->cloneWithStatus(*get<2>(section));
831              crypter.decrypt(basePtr + get<0>(section), writePtr, get<1>(section));
832              writePtr += get<1>(section);
833          }
834          if (encrypter) {
835              auto offset = sizeHolderSize;
836              for (auto kvHolder : vec) {
837                  kvHolder->offset = offset;
838                  auto size = kvHolder->pbKeyValueSize + kvHolder->keySize + kvHolder->valueSize;
839                  encrypter->getCurStatus(kvHolder->cryptStatus);
840                  encrypter->encrypt(basePtr + offset, basePtr + offset, size);
841                  offset += size;
842              }
843          }
844      }
845      auto &data = preparedData.first;
846      if (data.length() > 0) {
847          auto dataSize = CodedInputData(data.getPtr(), data.length()).readUInt32();
848          if (dataSize > 0) {
849              auto dataPtr = (uint8_t *) data.getPtr() + pbRawVarint32Size(dataSize);
850              if (encrypter) {
851                  encrypter->encrypt(dataPtr, writePtr, dataSize);
852              } else {
853                  memcpy(writePtr, dataPtr, dataSize);
854              }
855              writePtr += dataSize;
856          }
857      }
858      auto writtenSize = static_cast<size_t>(writePtr - output->curWritePointer());
859      assert(writtenSize + sizeHolderSize == preparedData.second);
860      output->seek(writtenSize);
861  }
862  #    define InvalidCryptPtr ((AESCrypt *) (void *) (1))
863  #endif 
864  static void fullWriteBackWholeData(MMBuffer allData, size_t totalSize, CodedOutputData *output) {
865      auto originOutputPtr = output->curWritePointer();
866      output->writeRawVarint32(ItemSizeHolder);
867      if (allData.length() > 0) {
868          auto dataSize = CodedInputData(allData.getPtr(), allData.length()).readUInt32();
869          if (dataSize > 0) {
870              auto dataPtr = (uint8_t *)allData.getPtr() + pbRawVarint32Size(dataSize);
871              memcpy(output->curWritePointer(), dataPtr, dataSize);
872              output->seek(dataSize);
873          }
874      }
875      [[maybe_unused]] auto writtenSize = (size_t) (output->curWritePointer() - originOutputPtr);
876      assert(writtenSize == totalSize);
877  }
878  #ifndef MMKV_DISABLE_CRYPT
879  bool MMKV::doFullWriteBack(pair<MMBuffer, size_t> prepared, AESCrypt *newCrypter) {
880      auto ptr = (uint8_t *) m_file->getMemory();
881      auto totalSize = prepared.second;
882  #ifdef MMKV_IOS
883      auto ret = guardForBackgroundWriting(ptr + Fixed32Size, totalSize);
884      if (!ret.first) {
885          return false;
886      }
887  #endif
888      uint8_t newIV[AES_KEY_LEN];
889      auto encrypter = (newCrypter == InvalidCryptPtr) ? nullptr : (newCrypter ? newCrypter : m_crypter);
890      if (encrypter) {
891          AESCrypt::fillRandomIV(newIV);
892          encrypter->resetIV(newIV, sizeof(newIV));
893      }
894      delete m_output;
895      m_output = new CodedOutputData(ptr + Fixed32Size, m_file->getFileSize() - Fixed32Size);
896      if (m_crypter) {
897          auto decrypter = m_crypter;
898          memmoveDictionary(*m_dicCrypt, m_output, ptr, decrypter, encrypter, prepared);
899      } else if (prepared.first.length() != 0) {
900          auto &preparedData = prepared.first;
901          fullWriteBackWholeData(std::move(preparedData), totalSize, m_output);
902          if (encrypter) {
903              encrypter->encrypt(ptr + Fixed32Size, ptr + Fixed32Size, totalSize);
904          }
905      } else {
906          memmoveDictionary(*m_dic, m_output, ptr, encrypter, totalSize);
907      }
908      m_actualSize = totalSize;
909      if (encrypter) {
910          recaculateCRCDigestWithIV(newIV);
911      } else {
912          recaculateCRCDigestWithIV(nullptr);
913      }
914      m_hasFullWriteback = true;
915      sync(MMKV_SYNC);
916      return true;
917  }
918  #else 
919  bool MMKV::doFullWriteBack(pair<MMBuffer, size_t> prepared, AESCrypt *) {
920      auto ptr = (uint8_t *) m_file->getMemory();
921      auto totalSize = prepared.second;
922  #ifdef MMKV_IOS
923      auto ret = guardForBackgroundWriting(ptr + Fixed32Size, totalSize);
924      if (!ret.first) {
925          return false;
926      }
927  #endif
928      delete m_output;
929      m_output = new CodedOutputData(ptr + Fixed32Size, m_file->getFileSize() - Fixed32Size);
930      if (prepared.first.length() != 0) {
931          auto &preparedData = prepared.first;
932          fullWriteBackWholeData(std::move(preparedData), totalSize, m_output);
933      } else {
934          constexpr AESCrypt *encrypter = nullptr;
935          memmoveDictionary(*m_dic, m_output, ptr, encrypter, totalSize);
936      }
937      m_actualSize = totalSize;
938      recaculateCRCDigestWithIV(nullptr);
939      m_hasFullWriteback = true;
940      sync(MMKV_SYNC);
941      return true;
942  }
943  #endif 
944  #ifndef MMKV_DISABLE_CRYPT
945  bool MMKV::reKey(const string &cryptKey) {
946      SCOPED_LOCK(m_lock);
947      SCOPED_LOCK(m_exclusiveProcessLock);
948      checkLoadData();
949      bool ret = false;
950      if (m_crypter) {
951          if (cryptKey.length() > 0) {
952              string oldKey = this->cryptKey();
953              if (cryptKey == oldKey) {
954                  return true;
955              } else {
956                  MMKVInfo("reKey with new aes key");
957                  auto newCrypt = new AESCrypt(cryptKey.data(), cryptKey.length());
958                  m_hasFullWriteback = false;
959                  ret = fullWriteback(newCrypt);
960                  if (ret) {
961                      delete m_crypter;
962                      m_crypter = newCrypt;
963                  } else {
964                      delete newCrypt;
965                  }
966              }
967          } else {
968              MMKVInfo("reKey to no aes key");
969              m_hasFullWriteback = false;
970              ret = fullWriteback(InvalidCryptPtr);
971              if (ret) {
972                  delete m_crypter;
973                  m_crypter = nullptr;
974                  if (!m_dic) {
975                      m_dic = new MMKVMap();
976                  }
977              }
978          }
979      } else {
980          if (cryptKey.length() > 0) {
981              MMKVInfo("reKey to a aes key");
982              m_hasFullWriteback = false;
983              auto newCrypt = new AESCrypt(cryptKey.data(), cryptKey.length());
984              ret = fullWriteback(newCrypt);
985              if (ret) {
986                  m_crypter = newCrypt;
987                  if (!m_dicCrypt) {
988                      m_dicCrypt = new MMKVMapCrypt();
989                  }
990              } else {
991                  delete newCrypt;
992              }
993          } else {
994              return true;
995          }
996      }
997      if (ret) {
998          clearMemoryCache();
999      }
1000      return ret;
1001  }
1002  #endif
1003  void MMKV::trim() {
1004      SCOPED_LOCK(m_lock);
1005      MMKVInfo("prepare to trim %s", m_mmapID.c_str());
1006      checkLoadData();
1007      if (m_actualSize == 0) {
1008          clearAll();
1009          return;
1010      } else if (m_file->getFileSize() <= DEFAULT_MMAP_SIZE) {
1011          return;
1012      }
1013      SCOPED_LOCK(m_exclusiveProcessLock);
1014      fullWriteback();
1015      auto oldSize = m_file->getFileSize();
1016      auto fileSize = oldSize;
1017      while (fileSize > (m_actualSize + Fixed32Size) * 2) {
1018          fileSize /= 2;
1019      }
1020      fileSize = std::max<size_t>(fileSize, DEFAULT_MMAP_SIZE);
1021      if (oldSize == fileSize) {
1022          MMKVInfo("there's no need to trim %s with size %zu, actualSize %zu", m_mmapID.c_str(), fileSize, m_actualSize);
1023          return;
1024      }
1025      MMKVInfo("trimming %s from %zu to %zu, actualSize %zu", m_mmapID.c_str(), oldSize, fileSize, m_actualSize);
1026      if (!m_file->truncate(fileSize)) {
1027          return;
1028      }
1029      fileSize = m_file->getFileSize();
1030      auto ptr = (uint8_t *) m_file->getMemory();
1031      delete m_output;
1032      m_output = new CodedOutputData(ptr + pbFixed32Size(), fileSize - Fixed32Size);
1033      m_output->seek(m_actualSize);
1034      MMKVInfo("finish trim %s from %zu to %zu", m_mmapID.c_str(), oldSize, fileSize);
1035  }
1036  void MMKV::clearAll() {
1037      MMKVInfo("cleaning all key-values from [%s]", m_mmapID.c_str());
1038      SCOPED_LOCK(m_lock);
1039      SCOPED_LOCK(m_exclusiveProcessLock);
1040      checkLoadData();
1041      if (m_file->getFileSize() == DEFAULT_MMAP_SIZE && m_actualSize == 0) {
1042          MMKVInfo("nothing to clear for [%s]", m_mmapID.c_str());
1043          return;
1044      }
1045      m_file->truncate(DEFAULT_MMAP_SIZE);
1046  #ifndef MMKV_DISABLE_CRYPT
1047      uint8_t newIV[AES_KEY_LEN];
1048      AESCrypt::fillRandomIV(newIV);
1049      if (m_crypter) {
1050          m_crypter->resetIV(newIV, sizeof(newIV));
1051      }
1052      writeActualSize(0, 0, newIV, IncreaseSequence);
1053  #else
1054      writeActualSize(0, 0, nullptr, IncreaseSequence);
1055  #endif
1056      m_metaFile->msync(MMKV_SYNC);
1057      clearMemoryCache();
1058      loadFromFile();
1059  }
1060  bool MMKV::isFileValid(const string &mmapID, MMKVPath_t *relatePath) {
1061      MMKVPath_t kvPath = mappedKVPathWithID(mmapID, MMKV_SINGLE_PROCESS, relatePath);
1062      if (!isFileExist(kvPath)) {
1063          return true;
1064      }
1065      MMKVPath_t crcPath = crcPathWithID(mmapID, MMKV_SINGLE_PROCESS, relatePath);
1066      if (!isFileExist(crcPath)) {
1067          return false;
1068      }
1069      uint32_t crcFile = 0;
1070      MMBuffer *data = readWholeFile(crcPath);
1071      if (data) {
1072          if (data->getPtr()) {
1073              MMKVMetaInfo metaInfo;
1074              metaInfo.read(data->getPtr());
1075              crcFile = metaInfo.m_crcDigest;
1076          }
1077          delete data;
1078      } else {
1079          return false;
1080      }
1081      uint32_t crcDigest = 0;
1082      MMBuffer *fileData = readWholeFile(kvPath);
1083      if (fileData) {
1084          if (fileData->getPtr() && (fileData->length() >= Fixed32Size)) {
1085              uint32_t actualSize = 0;
1086              memcpy(&actualSize, fileData->getPtr(), Fixed32Size);
1087              if (actualSize > (fileData->length() - Fixed32Size)) {
1088                  delete fileData;
1089                  return false;
1090              }
1091              crcDigest = (uint32_t) CRC32(0, (const uint8_t *) fileData->getPtr() + Fixed32Size, (uint32_t) actualSize);
1092          }
1093          delete fileData;
1094          return crcFile == crcDigest;
1095      } else {
1096          return false;
1097      }
1098  }
1099  uint32_t MMKV::getCurrentTimeInSecond() {
1100      auto time = ::time(nullptr);
1101      return static_cast<uint32_t>(time);
1102  }
1103  bool MMKV::doFullWriteBack(MMKVVector &&vec) {
1104      auto preparedData = prepareEncode(std::move(vec));
1105      if (m_crypter) {
1106          clearDictionary(m_dicCrypt);
1107      } else {
1108          clearDictionary(m_dic);
1109      }
1110      bool ret = false;
1111      auto sizeOfDic = preparedData.second;
1112      auto fileSize = m_file->getFileSize();
1113      if (sizeOfDic + Fixed32Size <= fileSize) {
1114          ret = doFullWriteBack(std::move(preparedData), nullptr);
1115      } else {
1116          auto newSize = sizeOfDic + Fixed32Size - fileSize;
1117          ret = expandAndWriteBack(newSize, std::move(preparedData));
1118      }
1119      clearMemoryCache();
1120      return ret;
1121  }
1122  bool MMKV::enableAutoKeyExpire(uint32_t expiredInSeconds) {
1123      SCOPED_LOCK(m_lock);
1124      SCOPED_LOCK(m_exclusiveProcessLock);
1125      checkLoadData();
1126      if (m_expiredInSeconds != expiredInSeconds) {
1127          MMKVInfo("expiredInSeconds: %u", expiredInSeconds);
1128          m_expiredInSeconds = expiredInSeconds;
1129      }
1130      m_enableKeyExpire = true;
1131      if (m_metaInfo->hasFlag(MMKVMetaInfo::EnableKeyExipre)) {
1132          return true;
1133      }
1134      auto autoRecordExpireTime = (m_expiredInSeconds != 0);
1135      auto time = autoRecordExpireTime ? getCurrentTimeInSecond() + m_expiredInSeconds : 0;
1136      MMKVInfo("turn on recording expire date for all keys inside [%s] from now %u", m_mmapID.c_str(), time);
<span onclick='openModal()' class='match'>1137      m_metaInfo->setFlag(MMKVMetaInfo::EnableKeyExipre);
1138      m_metaInfo->m_version = MMKVVersionFlag;
1139      if (m_file->getFileSize() == DEFAULT_MMAP_SIZE && m_actualSize == 0) {
1140          MMKVInfo("file is new, don't need a full writeback [%s], just update meta file", m_mmapID.c_str());
1141          writeActualSize(0, 0, nullptr, IncreaseSequence);
1142          m_metaFile->msync(MMKV_SYNC);
1143          return true;
1144      }
1145      MMKVVector vec;
1146      auto packKeyValue = [&](const MMKVKey_t &key, const MMBuffer &value) {
1147          MMBuffer data(value.length() + Fixed32Size);
</span>1148          auto ptr = (uint8_t *)data.getPtr();
1149          memcpy(ptr, value.getPtr(), value.length());
1150          memcpy(ptr + value.length(), &time, Fixed32Size);
1151          vec.emplace_back(key, std::move(data));
1152      };
1153      auto basePtr = (uint8_t *) (m_file->getMemory()) + Fixed32Size;
1154  #ifndef MMKV_DISABLE_CRYPT
1155      if (m_crypter) {
1156          for (auto &pair : *m_dicCrypt) {
1157              auto &key = pair.first;
1158              auto &value = pair.second;
1159              auto buffer = value.toMMBuffer(basePtr, m_crypter);
1160              packKeyValue(key, buffer);
1161          }
1162      } else
1163  #endif
1164      {
1165          for (auto &pair : *m_dic) {
1166              auto &key = pair.first;
1167              auto &value = pair.second;
1168              auto buffer = value.toMMBuffer(basePtr);
1169              packKeyValue(key, buffer);
1170          }
1171      }
1172      return doFullWriteBack(std::move(vec));
1173  }
1174  bool MMKV::disableAutoKeyExpire() {
1175      SCOPED_LOCK(m_lock);
1176      SCOPED_LOCK(m_exclusiveProcessLock);
1177      checkLoadData();
1178      m_expiredInSeconds = 0;
1179      m_enableKeyExpire = false;
1180      if (!m_metaInfo->hasFlag(MMKVMetaInfo::EnableKeyExipre)) {
1181          return true;
1182      }
1183      MMKVInfo("erase previous recorded expire date for all keys inside [%s]", m_mmapID.c_str());
1184      m_metaInfo->unsetFlag(MMKVMetaInfo::EnableKeyExipre);
1185      m_metaInfo->m_version = MMKVVersionFlag;
1186      if (m_file->getFileSize() == DEFAULT_MMAP_SIZE && m_actualSize == 0) {
1187          MMKVInfo("file is new, don't need a full write-back [%s], just update meta file", m_mmapID.c_str());
1188          writeActualSize(0, 0, nullptr, IncreaseSequence);
1189          m_metaFile->msync(MMKV_SYNC);
1190          return true;
1191      }
1192      MMKVVector vec;
1193      auto packKeyValue = [&](const MMKVKey_t &key, const MMBuffer &value) {
1194          assert(value.length() >= Fixed32Size);
1195          MMBuffer data(value.length() - Fixed32Size);
1196          auto ptr = (uint8_t *)data.getPtr();
1197          memcpy(ptr, value.getPtr(), value.length() - Fixed32Size);
1198          vec.emplace_back(key, std::move(data));
1199      };
1200      auto basePtr = (uint8_t *) (m_file->getMemory()) + Fixed32Size;
1201  #ifndef MMKV_DISABLE_CRYPT
1202      if (m_crypter) {
1203          for (auto &pair : *m_dicCrypt) {
1204              auto &key = pair.first;
1205              auto &value = pair.second;
1206              auto buffer = value.toMMBuffer(basePtr, m_crypter);
1207              packKeyValue(key, buffer);
1208          }
1209      } else
1210  #endif
1211      {
1212          for (auto &pair : *m_dic) {
1213              auto &key = pair.first;
1214              auto &value = pair.second;
1215              auto buffer = value.toMMBuffer(basePtr);
1216              packKeyValue(key, buffer);
1217          }
1218      }
1219      return doFullWriteBack(std::move(vec));
1220  }
1221  uint32_t MMKV::getExpireTimeForKey(MMKVKey_t key) {
1222      SCOPED_LOCK(m_lock);
1223      SCOPED_LOCK(m_sharedProcessLock);
1224      checkLoadData();
1225      if (!m_enableKeyExpire || key_length(key) == 0) {
1226          return 0;
1227      }
1228      auto raw = getRawDataForKey(key);
1229      assert(raw.length() == 0 || raw.length() >= Fixed32Size);
1230      if (raw.length() < Fixed32Size) {
1231          return 0;
1232      }
1233      auto ptr = (const uint8_t *)raw.getPtr() + raw.length() - Fixed32Size;
1234      auto time = *(const uint32_t *)ptr;
1235      return time;
1236  }
1237  mmkv::MMBuffer MMKV::getDataWithoutMTimeForKey(MMKVKey_t key) {
1238      SCOPED_LOCK(m_lock);
1239      SCOPED_LOCK(m_sharedProcessLock);
1240      checkLoadData();
1241      auto raw = getRawDataForKey(key);
1242      assert(raw.length() == 0 || raw.length() >= Fixed32Size);
1243      if (raw.length() < Fixed32Size) {
1244          return raw;
1245      }
1246      auto newLength = raw.length() - Fixed32Size;
1247      if (m_enableKeyExpire) {
1248          auto ptr = (const uint8_t *)raw.getPtr() + newLength;
1249          auto time = *(const uint32_t *)ptr;
1250          if (time != ExpireNever && time <= getCurrentTimeInSecond()) {
1251  #ifdef MMKV_APPLE
1252              MMKVInfo("deleting expired key [%@] in mmkv [%s], due date %u", key, m_mmapID.c_str(), time);
1253  #else
1254              MMKVInfo("deleting expired key [%s] in mmkv [%s], due date %u", key.c_str(), m_mmapID.c_str(), time);
1255  #endif
1256              removeValueForKey(key);
1257              return MMBuffer();
1258          }
1259      }
1260      return MMBuffer(std::move(raw), newLength);
1261  }
1262  #define NOOP ((void)0)
1263  size_t MMKV::filterExpiredKeys() {
1264      if (!m_enableKeyExpire || (m_crypter ? m_dicCrypt->empty() : m_dic->empty())) {
1265          return 0;
1266      }
1267      auto now = getCurrentTimeInSecond();
1268      MMKVInfo("filtering expired keys inside [%s] now: %u, m_expiredInSeconds: %u", m_mmapID.c_str(), now, m_expiredInSeconds);
1269      size_t count = 0;
1270      auto basePtr = (uint8_t *)(m_file->getMemory()) + Fixed32Size;
1271  #ifndef MMKV_DISABLE_CRYPT
1272      if (m_crypter) {
1273          for (auto itr = m_dicCrypt->begin(); itr != m_dicCrypt->end(); NOOP) {
1274              auto &kvHolder = itr->second;
1275              assert(kvHolder.realValueSize() >= Fixed32Size);
1276              auto buffer = kvHolder.toMMBuffer(basePtr, m_crypter);
1277              auto ptr = (uint8_t*) buffer.getPtr();
1278              ptr += buffer.length() - Fixed32Size;
1279              auto time = *(const uint32_t *)ptr;
1280              if (time != ExpireNever && time <= now) {
1281                  auto oldKey = itr->first;
1282                  itr = m_dicCrypt->erase(itr);
1283  #ifdef MMKV_APPLE
1284                  MMKVInfo("deleting expired key [%@], due date %u", oldKey, time);
1285                  [oldKey release];
1286  #else
1287                  MMKVInfo("deleting expired key [%s], due date %u", oldKey.c_str(), time);
1288  #endif
1289                  count++;
1290              } else {
1291                  itr++;
1292              }
1293          }
1294      } else
1295  #endif 
1296      {
1297          for (auto itr = m_dic->begin(); itr != m_dic->end(); NOOP) {
1298              auto &kvHolder = itr->second;
1299              assert(kvHolder.valueSize >= Fixed32Size);
1300              auto ptr = basePtr + kvHolder.offset + kvHolder.computedKVSize;
1301              ptr += kvHolder.valueSize - Fixed32Size;
1302              auto time = *(const uint32_t *)ptr;
1303              if (time != ExpireNever && time <= now) {
1304                  auto oldKey = itr->first;
1305                  itr = m_dic->erase(itr);
1306  #ifdef MMKV_APPLE
1307                  MMKVInfo("deleting expired key [%@], due date %u", oldKey, time);
1308                  [oldKey release];
1309  #else
1310                  MMKVInfo("deleting expired key [%s], due date %u", oldKey.c_str(), time);
1311  #endif
1312                  count++;
1313              } else {
1314                  itr++;
1315              }
1316          }
1317      }
1318      MMKVInfo("deleted %zu expired keys inside [%s]", count, m_mmapID.c_str());
1319      return count;
1320  }
1321  MMKV_NAMESPACE_END
</code></pre>
        </div>
        <div class="column">
            <h3>MMKV-MDEwOlJlcG9zaXRvcnkxNDkxMTE4MTM=-flat-MMKV_IO.cpp</h3>
            <pre><code>1  #include "MMKV_IO.h"
2  #include "CodedInputData.h"
3  #include "CodedOutputData.h"
4  #include "InterProcessLock.h"
5  #include "MMBuffer.h"
6  #include "MMKVLog.h"
7  #include "MMKVMetaInfo.hpp"
8  #include "MemoryFile.h"
9  #include "MiniPBCoder.h"
10  #include "PBUtility.h"
11  #include "ScopedLock.hpp"
12  #include "ThreadLock.h"
13  #include "aes/AESCrypt.h"
14  #include "aes/openssl/openssl_aes.h"
15  #include "aes/openssl/openssl_md5.h"
16  #include "crc32/Checksum.h"
17  #include <algorithm>
18  #include <cassert>
19  #include <cstring>
20  #include <ctime>
21  #ifdef MMKV_IOS
22  #    include "MMKV_OSX.h"
23  #endif
24  #ifdef MMKV_APPLE
25  #    if __has_feature(objc_arc)
26  #        error This file must be compiled with MRC. Use -fno-objc-arc flag.
27  #    endif
28  #endif 
29  using namespace std;
30  using namespace mmkv;
31  using KVHolderRet_t = std::pair<bool, KeyValueHolder>;
32  MMKV_NAMESPACE_BEGIN
33  void MMKV::loadFromFile() {
34      loadMetaInfoAndCheck();
35  #ifndef MMKV_DISABLE_CRYPT
36      if (m_crypter) {
37          if (m_metaInfo->m_version >= MMKVVersionRandomIV) {
38              m_crypter->resetIV(m_metaInfo->m_vector, sizeof(m_metaInfo->m_vector));
39          }
40      }
41  #endif
42      if (!m_file->isFileValid()) {
43          m_file->reloadFromFile();
44      }
45      if (!m_file->isFileValid()) {
46          MMKVError("file [%s] not valid", m_path.c_str());
47      } else {
48          bool loadFromFile = false, needFullWriteback = false;
49          checkDataValid(loadFromFile, needFullWriteback);
50          MMKVInfo("loading [%s] with %zu actual size, file size %zu, InterProcess %d, meta info "
51                   "version:%u",
52                   m_mmapID.c_str(), m_actualSize, m_file->getFileSize(), m_isInterProcess, m_metaInfo->m_version);
53          auto ptr = (uint8_t *) m_file->getMemory();
54          if (loadFromFile && m_actualSize > 0) {
55              MMKVInfo("loading [%s] with crc %u sequence %u version %u", m_mmapID.c_str(), m_metaInfo->m_crcDigest,
56                       m_metaInfo->m_sequence, m_metaInfo->m_version);
57              MMBuffer inputBuffer(ptr + Fixed32Size, m_actualSize, MMBufferNoCopy);
58              if (m_crypter) {
59                  clearDictionary(m_dicCrypt);
60              } else {
61                  clearDictionary(m_dic);
62              }
63              if (needFullWriteback) {
64  #ifndef MMKV_DISABLE_CRYPT
65                  if (m_crypter) {
66                      MiniPBCoder::greedyDecodeMap(*m_dicCrypt, inputBuffer, m_crypter);
67                  } else
68  #endif
69                  {
70                      MiniPBCoder::greedyDecodeMap(*m_dic, inputBuffer);
71                  }
72              } else {
73  #ifndef MMKV_DISABLE_CRYPT
74                  if (m_crypter) {
75                      MiniPBCoder::decodeMap(*m_dicCrypt, inputBuffer, m_crypter);
76                  } else
77  #endif
78                  {
79                      MiniPBCoder::decodeMap(*m_dic, inputBuffer);
80                  }
81              }
82              m_output = new CodedOutputData(ptr + Fixed32Size, m_file->getFileSize() - Fixed32Size);
83              m_output->seek(m_actualSize);
84              if (needFullWriteback) {
85                  fullWriteback();
86              }
87          } else {
88              SCOPED_LOCK(m_exclusiveProcessLock);
89              m_output = new CodedOutputData(ptr + Fixed32Size, m_file->getFileSize() - Fixed32Size);
90              if (m_actualSize > 0) {
91                  writeActualSize(0, 0, nullptr, IncreaseSequence);
92                  sync(MMKV_SYNC);
93              } else {
94                  writeActualSize(0, 0, nullptr, KeepSequence);
95              }
96          }
97          auto count = m_crypter ? m_dicCrypt->size() : m_dic->size();
98          MMKVInfo("loaded [%s] with %zu key-values", m_mmapID.c_str(), count);
99      }
100      m_needLoadFromFile = false;
101  }
102  void MMKV::partialLoadFromFile() {
103      m_metaInfo->read(m_metaFile->getMemory());
104      size_t oldActualSize = m_actualSize;
105      m_actualSize = readActualSize();
106      auto fileSize = m_file->getFileSize();
107      MMKVDebug("loading [%s] with file size %zu, oldActualSize %zu, newActualSize %zu", m_mmapID.c_str(), fileSize,
108                oldActualSize, m_actualSize);
109      if (m_actualSize > 0) {
110          if (m_actualSize < fileSize && m_actualSize + Fixed32Size <= fileSize) {
111              if (m_actualSize > oldActualSize) {
112                  auto position = oldActualSize;
113                  size_t addedSize = m_actualSize - position;
114                  auto basePtr = (uint8_t *) m_file->getMemory() + Fixed32Size;
115                  m_crcDigest = (uint32_t) CRC32(m_crcDigest, basePtr + position, addedSize);
116                  if (m_crcDigest == m_metaInfo->m_crcDigest) {
117                      MMBuffer inputBuffer(basePtr, m_actualSize, MMBufferNoCopy);
118  #ifndef MMKV_DISABLE_CRYPT
119                      if (m_crypter) {
120                          MiniPBCoder::greedyDecodeMap(*m_dicCrypt, inputBuffer, m_crypter, position);
121                      } else
122  #endif
123                      {
124                          MiniPBCoder::greedyDecodeMap(*m_dic, inputBuffer, position);
125                      }
126                      m_output->seek(addedSize);
127                      m_hasFullWriteback = false;
128                      [[maybe_unused]] auto count = m_crypter ? m_dicCrypt->size() : m_dic->size();
129                      MMKVDebug("partial loaded [%s] with %zu values", m_mmapID.c_str(), count);
130                      return;
131                  } else {
132                      MMKVError("m_crcDigest[%u] != m_metaInfo->m_crcDigest[%u]", m_crcDigest, m_metaInfo->m_crcDigest);
133                  }
134              }
135          }
136      }
137      clearMemoryCache();
138      loadFromFile();
139  }
140  void MMKV::loadMetaInfoAndCheck() {
141      if (!m_metaFile->isFileValid()) {
142          m_metaFile->reloadFromFile();
143      }
144      if (!m_metaFile->isFileValid()) {
145          MMKVError("file [%s] not valid", m_metaFile->getPath().c_str());
146          return;
147      }
148      m_metaInfo->read(m_metaFile->getMemory());
149      if (m_metaInfo->m_version >= MMKVVersionHolder) {
150          MMKVWarning("meta file [%s] in specious state, version %u, flags 0x%llx", m_mmapID.c_str(), m_metaInfo->m_version, m_metaInfo->m_flags);
151          m_metaInfo->m_version = MMKVVersionActualSize;
152          m_metaInfo->m_flags = 0;
153          m_metaInfo->write(m_metaFile->getMemory());
154      }
155      if (m_metaInfo->m_version >= MMKVVersionFlag) {
156          m_enableKeyExpire = m_metaInfo->hasFlag(MMKVMetaInfo::EnableKeyExipre);
157          MMKVInfo("meta file [%s] has flag [%llu]", m_mmapID.c_str(), m_metaInfo->m_flags);
158      } else {
159          if (m_metaInfo->m_flags != 0) {
160              m_metaInfo->m_flags = 0;
161              m_metaInfo->write(m_metaFile->getMemory());
162          }
163      }
164  }
165  void MMKV::checkDataValid(bool &loadFromFile, bool &needFullWriteback) {
166      auto fileSize = m_file->getFileSize();
167      auto checkLastConfirmedInfo = [&] {
168          if (m_metaInfo->m_version >= MMKVVersionActualSize) {
169              uint32_t oldStyleActualSize = 0;
170              memcpy(&oldStyleActualSize, m_file->getMemory(), Fixed32Size);
171              if (oldStyleActualSize != m_actualSize) {
172                  MMKVWarning("oldStyleActualSize %u not equal to meta actual size %lu", oldStyleActualSize,
173                              m_actualSize);
174                  if (oldStyleActualSize < fileSize && (oldStyleActualSize + Fixed32Size) <= fileSize) {
175                      if (checkFileCRCValid(oldStyleActualSize, m_metaInfo->m_crcDigest)) {
176                          MMKVInfo("looks like [%s] been downgrade & upgrade again", m_mmapID.c_str());
177                          loadFromFile = true;
178                          writeActualSize(oldStyleActualSize, m_metaInfo->m_crcDigest, nullptr, KeepSequence);
179                          return;
180                      }
181                  } else {
182                      MMKVWarning("oldStyleActualSize %u greater than file size %lu", oldStyleActualSize, fileSize);
183                  }
184              }
185              auto lastActualSize = m_metaInfo->m_lastConfirmedMetaInfo.lastActualSize;
186              if (lastActualSize < fileSize && (lastActualSize + Fixed32Size) <= fileSize) {
187                  auto lastCRCDigest = m_metaInfo->m_lastConfirmedMetaInfo.lastCRCDigest;
188                  if (checkFileCRCValid(lastActualSize, lastCRCDigest)) {
189                      loadFromFile = true;
190                      writeActualSize(lastActualSize, lastCRCDigest, nullptr, KeepSequence);
191                  } else {
192                      MMKVError("check [%s] error: lastActualSize %u, lastActualCRC %u", m_mmapID.c_str(), lastActualSize,
193                                lastCRCDigest);
194                  }
195              } else {
196                  MMKVError("check [%s] error: lastActualSize %u, file size is %u", m_mmapID.c_str(), lastActualSize,
197                            fileSize);
198              }
199          }
200      };
201      m_actualSize = readActualSize();
202      if (m_actualSize < fileSize && (m_actualSize + Fixed32Size) <= fileSize) {
203          if (checkFileCRCValid(m_actualSize, m_metaInfo->m_crcDigest)) {
204              loadFromFile = true;
205          } else {
206              checkLastConfirmedInfo();
207              if (!loadFromFile) {
208                  auto strategic = onMMKVCRCCheckFail(m_mmapID);
209                  if (strategic == OnErrorRecover) {
210                      loadFromFile = true;
211                      needFullWriteback = true;
212                  }
213                  MMKVInfo("recover strategic for [%s] is %d", m_mmapID.c_str(), strategic);
214              }
215          }
216      } else {
217          MMKVError("check [%s] error: %zu size in total, file size is %zu", m_mmapID.c_str(), m_actualSize, fileSize);
218          checkLastConfirmedInfo();
219          if (!loadFromFile) {
220              auto strategic = onMMKVFileLengthError(m_mmapID);
221              if (strategic == OnErrorRecover) {
222                  m_actualSize = fileSize - Fixed32Size;
223                  loadFromFile = true;
224                  needFullWriteback = true;
225              }
226              MMKVInfo("recover strategic for [%s] is %d", m_mmapID.c_str(), strategic);
227          }
228      }
229  }
230  void MMKV::checkLoadData() {
231      if (m_needLoadFromFile) {
232          SCOPED_LOCK(m_sharedProcessLock);
233          m_needLoadFromFile = false;
234          loadFromFile();
235          return;
236      }
237      if (!m_isInterProcess) {
238          return;
239      }
240      if (!m_metaFile->isFileValid()) {
241          return;
242      }
243      SCOPED_LOCK(m_sharedProcessLock);
244      MMKVMetaInfo metaInfo;
245      metaInfo.read(m_metaFile->getMemory());
246      if (m_metaInfo->m_sequence != metaInfo.m_sequence) {
247          MMKVInfo("[%s] oldSeq %u, newSeq %u", m_mmapID.c_str(), m_metaInfo->m_sequence, metaInfo.m_sequence);
248          SCOPED_LOCK(m_sharedProcessLock);
249          clearMemoryCache();
250          loadFromFile();
251          notifyContentChanged();
252      } else if (m_metaInfo->m_crcDigest != metaInfo.m_crcDigest) {
253          MMKVDebug("[%s] oldCrc %u, newCrc %u, new actualSize %u", m_mmapID.c_str(), m_metaInfo->m_crcDigest,
254                    metaInfo.m_crcDigest, metaInfo.m_actualSize);
255          SCOPED_LOCK(m_sharedProcessLock);
256          size_t fileSize = m_file->getActualFileSize();
257          if (m_file->getFileSize() != fileSize) {
258              MMKVInfo("file size has changed [%s] from %zu to %zu", m_mmapID.c_str(), m_file->getFileSize(), fileSize);
259              clearMemoryCache();
260              loadFromFile();
261          } else {
262              partialLoadFromFile();
263          }
264          notifyContentChanged();
265      }
266  }
267  constexpr uint32_t ItemSizeHolder = 0x00ffffff;
268  constexpr uint32_t ItemSizeHolderSize = 4;
269  static pair<MMBuffer, size_t> prepareEncode(const MMKVMap &dic) {
270      size_t totalSize = ItemSizeHolderSize;
271      for (auto &itr : dic) {
272          auto &kvHolder = itr.second;
273          totalSize += kvHolder.computedKVSize + kvHolder.valueSize;
274      }
275      return make_pair(MMBuffer(), totalSize);
276  }
277  #ifndef MMKV_DISABLE_CRYPT
278  static pair<MMBuffer, size_t> prepareEncode(const MMKVMapCrypt &dic) {
279      MMKVVector vec;
280      size_t totalSize = 0;
281      uint32_t smallestOffet = 5 + 1; 
282      for (auto &itr : dic) {
283          auto &kvHolder = itr.second;
284          if (kvHolder.type == KeyValueHolderType_Offset) {
285              totalSize += kvHolder.pbKeyValueSize + kvHolder.keySize + kvHolder.valueSize;
286              smallestOffet = min(smallestOffet, kvHolder.offset);
287          } else {
288              vec.emplace_back(itr.first, kvHolder.toMMBuffer(nullptr, nullptr));
289          }
290      }
291      if (smallestOffet > 5) {
292          smallestOffet = ItemSizeHolderSize;
293      }
294      totalSize += smallestOffet;
295      if (vec.empty()) {
296          return make_pair(MMBuffer(), totalSize);
297      }
298      auto buffer = MiniPBCoder::encodeDataWithObject(vec);
299      auto sizeOfMap = CodedInputData(buffer.getPtr(), buffer.length()).readUInt32();
300      totalSize += sizeOfMap;
301      return make_pair(std::move(buffer), totalSize);
302  }
303  #endif
304  static pair<MMBuffer, size_t> prepareEncode(MMKVVector &&vec) {
305      size_t totalSize = ItemSizeHolderSize;
306      auto buffer = MiniPBCoder::encodeDataWithObject(vec);
307      auto sizeOfMap = CodedInputData(buffer.getPtr(), buffer.length()).readUInt32();
308      totalSize += sizeOfMap;
309      return make_pair(std::move(buffer), totalSize);
310  }
311  bool MMKV::ensureMemorySize(size_t newSize) {
312      if (!isFileValid()) {
313          MMKVWarning("[%s] file not valid", m_mmapID.c_str());
314          return false;
315      }
316      if (newSize >= m_output->spaceLeft() || (m_crypter ? m_dicCrypt->empty() : m_dic->empty())) {
317          if (m_enableKeyExpire) {
318              filterExpiredKeys();
319          }
320          auto preparedData = m_crypter ? prepareEncode(*m_dicCrypt) : prepareEncode(*m_dic);
321          return expandAndWriteBack(newSize, std::move(preparedData));
322      }
323      return true;
324  }
325  bool MMKV::expandAndWriteBack(size_t newSize, std::pair<mmkv::MMBuffer, size_t> preparedData) {
326      auto fileSize = m_file->getFileSize();
327      auto sizeOfDic = preparedData.second;
328      size_t lenNeeded = sizeOfDic + Fixed32Size + newSize;
329      size_t dicCount = m_crypter ? m_dicCrypt->size() : m_dic->size();
330      size_t avgItemSize = lenNeeded / std::max<size_t>(1, dicCount);
331      size_t futureUsage = avgItemSize * std::max<size_t>(8, (dicCount + 1) / 2);
332      if (lenNeeded >= fileSize || (lenNeeded + futureUsage) >= fileSize) {
333          size_t oldSize = fileSize;
334          do {
335              fileSize *= 2;
336          } while (lenNeeded + futureUsage >= fileSize);
337          MMKVInfo("extending [%s] file size from %zu to %zu, incoming size:%zu, future usage:%zu", m_mmapID.c_str(),
338                   oldSize, fileSize, newSize, futureUsage);
339          if (!m_file->truncate(fileSize)) {
340              return false;
341          }
342          if (!isFileValid()) {
343              MMKVWarning("[%s] file not valid", m_mmapID.c_str());
344              return false;
345          }
346      }
347      return doFullWriteBack(std::move(preparedData), nullptr);
348  }
349  size_t MMKV::readActualSize() {
350      MMKV_ASSERT(m_file->getMemory());
351      MMKV_ASSERT(m_metaFile->isFileValid());
352      uint32_t actualSize = 0;
353      memcpy(&actualSize, m_file->getMemory(), Fixed32Size);
354      if (m_metaInfo->m_version >= MMKVVersionActualSize) {
355          if (m_metaInfo->m_actualSize != actualSize) {
356              MMKVWarning("[%s] actual size %u, meta actual size %u", m_mmapID.c_str(), actualSize,
357                          m_metaInfo->m_actualSize);
358          }
359          return m_metaInfo->m_actualSize;
360      } else {
361          return actualSize;
362      }
363  }
364  void MMKV::oldStyleWriteActualSize(size_t actualSize) {
365      MMKV_ASSERT(m_file->getMemory());
366      m_actualSize = actualSize;
367  #ifdef MMKV_IOS
368      auto ret = guardForBackgroundWriting(m_file->getMemory(), Fixed32Size);
369      if (!ret.first) {
370          return;
371      }
372  #endif
373      memcpy(m_file->getMemory(), &actualSize, Fixed32Size);
374  }
375  bool MMKV::writeActualSize(size_t size, uint32_t crcDigest, const void *iv, bool increaseSequence) {
376      oldStyleWriteActualSize(size);
377      if (!m_metaFile->isFileValid()) {
378          return false;
379      }
380      bool needsFullWrite = false;
381      m_actualSize = size;
382      m_metaInfo->m_actualSize = static_cast<uint32_t>(size);
383      m_crcDigest = crcDigest;
384      m_metaInfo->m_crcDigest = crcDigest;
385      if (m_metaInfo->m_version < MMKVVersionSequence) {
386          m_metaInfo->m_version = MMKVVersionSequence;
387          needsFullWrite = true;
388      }
389  #ifndef MMKV_DISABLE_CRYPT
390      if (unlikely(iv)) {
391          memcpy(m_metaInfo->m_vector, iv, sizeof(m_metaInfo->m_vector));
392          if (m_metaInfo->m_version < MMKVVersionRandomIV) {
393              m_metaInfo->m_version = MMKVVersionRandomIV;
394          }
395          needsFullWrite = true;
396      }
397  #endif
398      if (unlikely(increaseSequence)) {
399          m_metaInfo->m_sequence++;
400          m_metaInfo->m_lastConfirmedMetaInfo.lastActualSize = static_cast<uint32_t>(size);
401          m_metaInfo->m_lastConfirmedMetaInfo.lastCRCDigest = crcDigest;
402          if (m_metaInfo->m_version < MMKVVersionActualSize) {
403              m_metaInfo->m_version = MMKVVersionActualSize;
404          }
405          needsFullWrite = true;
406          MMKVInfo("[%s] increase sequence to %u, crc %u, actualSize %u", m_mmapID.c_str(), m_metaInfo->m_sequence,
407                   m_metaInfo->m_crcDigest, m_metaInfo->m_actualSize);
408      }
409      if (m_metaInfo->m_version < MMKVVersionFlag) {
410          m_metaInfo->m_flags = 0;
411          m_metaInfo->m_version = MMKVVersionFlag;
412          needsFullWrite = true;
413      }
414  #ifdef MMKV_IOS
415      auto ret = guardForBackgroundWriting(m_metaFile->getMemory(), sizeof(MMKVMetaInfo));
416      if (!ret.first) {
417          return false;
418      }
419  #endif
420      if (unlikely(needsFullWrite)) {
421          m_metaInfo->write(m_metaFile->getMemory());
422      } else {
423          m_metaInfo->writeCRCAndActualSizeOnly(m_metaFile->getMemory());
424      }
425      return true;
426  }
427  MMBuffer MMKV::getRawDataForKey(MMKVKey_t key) {
428      checkLoadData();
429  #ifndef MMKV_DISABLE_CRYPT
430      if (m_crypter) {
431          auto itr = m_dicCrypt->find(key);
432          if (itr != m_dicCrypt->end()) {
433              auto basePtr = (uint8_t *) (m_file->getMemory()) + Fixed32Size;
434              return itr->second.toMMBuffer(basePtr, m_crypter);
435          }
436      } else
437  #endif
438      {
439          auto itr = m_dic->find(key);
440          if (itr != m_dic->end()) {
441              auto basePtr = (uint8_t *) (m_file->getMemory()) + Fixed32Size;
442              return itr->second.toMMBuffer(basePtr);
443          }
444      }
445      MMBuffer nan;
446      return nan;
447  }
448  mmkv::MMBuffer MMKV::getDataForKey(MMKVKey_t key) {
449      if (unlikely(m_enableKeyExpire)) {
450          return getDataWithoutMTimeForKey(key);
451      }
452      return getRawDataForKey(key);
453  }
454  #ifndef MMKV_DISABLE_CRYPT
455  #    if defined(TARGET_OS_SIMULATOR) && defined(TARGET_CPU_X86)
456  static AESCryptStatus t_status;
457  #    else
458  thread_local AESCryptStatus t_status;
459  #    endif
460  #endif 
461  bool MMKV::setDataForKey(MMBuffer &&data, MMKVKey_t key, bool isDataHolder) {
462      if ((!isDataHolder && data.length() == 0) || isKeyEmpty(key)) {
463          return false;
464      }
465      SCOPED_LOCK(m_lock);
466      SCOPED_LOCK(m_exclusiveProcessLock);
467      checkLoadData();
468  #ifndef MMKV_DISABLE_CRYPT
469      if (m_crypter) {
470          if (isDataHolder) {
471              auto sizeNeededForData = pbRawVarint32Size((uint32_t) data.length()) + data.length();
472              if (!KeyValueHolderCrypt::isValueStoredAsOffset(sizeNeededForData)) {
473                  data = MiniPBCoder::encodeDataWithObject(data);
474                  isDataHolder = false;
475              }
476          }
477          auto itr = m_dicCrypt->find(key);
478          if (itr != m_dicCrypt->end()) {
479  #    ifdef MMKV_APPLE
480              auto ret = appendDataWithKey(data, key, itr->second, isDataHolder);
481  #    else
482              auto ret = appendDataWithKey(data, key, isDataHolder);
483  #    endif
484              if (!ret.first) {
485                  return false;
486              }
487              KeyValueHolderCrypt kvHolder;
488              if (KeyValueHolderCrypt::isValueStoredAsOffset(ret.second.valueSize)) {
489                  kvHolder = KeyValueHolderCrypt(ret.second.keySize, ret.second.valueSize, ret.second.offset);
490                  memcpy(&kvHolder.cryptStatus, &t_status, sizeof(t_status));
491              } else {
492                  kvHolder = KeyValueHolderCrypt(std::move(data));
493              }
494              if (likely(!m_enableKeyExpire)) {
495                  itr->second = std::move(kvHolder);
496              } else {
497                  itr = m_dicCrypt->find(key);
498                  if (itr != m_dicCrypt->end()) {
499                      itr->second = std::move(kvHolder);
500                  } else {
501                      m_dicCrypt->emplace(key, std::move(kvHolder));
502                      retain_key(key);
503                  }
504              }
505          } else {
506              auto ret = appendDataWithKey(data, key, isDataHolder);
507              if (!ret.first) {
508                  return false;
509              }
510              if (KeyValueHolderCrypt::isValueStoredAsOffset(ret.second.valueSize)) {
511                  auto r = m_dicCrypt->emplace(
512                      key, KeyValueHolderCrypt(ret.second.keySize, ret.second.valueSize, ret.second.offset));
513                  if (r.second) {
514                      memcpy(&(r.first->second.cryptStatus), &t_status, sizeof(t_status));
515                  }
516              } else {
517                  m_dicCrypt->emplace(key, KeyValueHolderCrypt(std::move(data)));
518              }
519              retain_key(key);
520          }
521      } else
522  #endif 
523      {
524          auto itr = m_dic->find(key);
525          if (itr != m_dic->end()) {
526              if (likely(!m_enableKeyExpire)) {
527                  auto ret = appendDataWithKey(data, itr->second, isDataHolder);
528                  if (!ret.first) {
529                      return false;
530                  }
531                  itr->second = std::move(ret.second);
532              } else {
533                  auto ret = appendDataWithKey(data, key, isDataHolder);
534                  if (!ret.first) {
535                      return false;
536                  }
537                  itr = m_dic->find(key);
538                  if (itr != m_dic->end()) {
539                      itr->second = std::move(ret.second);
540                  } else {
541                      m_dic->emplace(key, std::move(ret.second));
542                      retain_key(key);
543                  }
544              }
545          } else {
546              auto ret = appendDataWithKey(data, key, isDataHolder);
547              if (!ret.first) {
548                  return false;
549              }
550              m_dic->emplace(key, std::move(ret.second));
551              retain_key(key);
552          }
553      }
554      m_hasFullWriteback = false;
555      return true;
556  }
557  bool MMKV::removeDataForKey(MMKVKey_t key) {
558      if (isKeyEmpty(key)) {
559          return false;
560      }
561  #ifndef MMKV_DISABLE_CRYPT
562      if (m_crypter) {
563          auto itr = m_dicCrypt->find(key);
564          if (itr != m_dicCrypt->end()) {
565              m_hasFullWriteback = false;
566              static MMBuffer nan;
567  #    ifdef MMKV_APPLE
568              auto ret = appendDataWithKey(nan, key, itr->second);
569              if (ret.first) {
570                  if (unlikely(m_enableKeyExpire)) {
571                      itr = m_dicCrypt->find(key);
572                      if (itr == m_dicCrypt->end()) {
573                          return true;
574                      }
575                  }
576                  auto oldKey = itr->first;
577                  m_dicCrypt->erase(itr);
578                  [oldKey release];
579              }
580  #    else
581              auto ret = appendDataWithKey(nan, key);
582              if (ret.first) {
583                  if (unlikely(m_enableKeyExpire)) {
584                      m_dicCrypt->erase(key);
585                  } else {
586                      m_dicCrypt->erase(itr);
587                  }
588              }
589  #    endif
590              return ret.first;
591          }
592      } else
593  #endif 
594      {
595          auto itr = m_dic->find(key);
596          if (itr != m_dic->end()) {
597              m_hasFullWriteback = false;
598              static MMBuffer nan;
599              auto ret = likely(!m_enableKeyExpire) ? appendDataWithKey(nan, itr->second) : appendDataWithKey(nan, key);
600              if (ret.first) {
601  #ifdef MMKV_APPLE
602                  if (unlikely(m_enableKeyExpire)) {
603                      itr = m_dic->find(key);
604                      if (itr == m_dic->end()) {
605                          return true;
606                      }
607                  }
608                  auto oldKey = itr->first;
609                  m_dic->erase(itr);
610                  [oldKey release];
611  #else
612                  if (unlikely(m_enableKeyExpire)) {
613                      m_dic->erase(key);
614                  } else {
615                      m_dic->erase(itr);
616                  }
617  #endif
618              }
619              return ret.first;
620          }
621      }
622      return false;
623  }
624  KVHolderRet_t
625  MMKV::doAppendDataWithKey(const MMBuffer &data, const MMBuffer &keyData, bool isDataHolder, uint32_t originKeyLength) {
626      auto isKeyEncoded = (originKeyLength < keyData.length());
627      auto keyLength = static_cast<uint32_t>(keyData.length());
628      auto valueLength = static_cast<uint32_t>(data.length());
629      if (isDataHolder) {
630          valueLength += pbRawVarint32Size(valueLength);
631      }
632      size_t size = isKeyEncoded ? keyLength : (keyLength + pbRawVarint32Size(keyLength));
633      size += valueLength + pbRawVarint32Size(valueLength);
634      SCOPED_LOCK(m_exclusiveProcessLock);
635      bool hasEnoughSize = ensureMemorySize(size);
636      if (!hasEnoughSize || !isFileValid()) {
637          return make_pair(false, KeyValueHolder());
638      }
639  #ifdef MMKV_IOS
640      auto ret = guardForBackgroundWriting(m_output->curWritePointer(), size);
641      if (!ret.first) {
642          return make_pair(false, KeyValueHolder());
643      }
644  #endif
645  #ifndef MMKV_DISABLE_CRYPT
646      if (m_crypter) {
647          if (KeyValueHolderCrypt::isValueStoredAsOffset(valueLength)) {
648              m_crypter->getCurStatus(t_status);
649          }
650      }
651  #endif
652      try {
653          if (isKeyEncoded) {
654              m_output->writeRawData(keyData);
655          } else {
656              m_output->writeData(keyData);
657          }
658          if (isDataHolder) {
659              m_output->writeRawVarint32((int32_t) valueLength);
660          }
661          m_output->writeData(data); 
662      } catch (std::exception &e) {
663          MMKVError("%s", e.what());
664          return make_pair(false, KeyValueHolder());
665      }
666      auto offset = static_cast<uint32_t>(m_actualSize);
667      auto ptr = (uint8_t *) m_file->getMemory() + Fixed32Size + m_actualSize;
668  #ifndef MMKV_DISABLE_CRYPT
669      if (m_crypter) {
670          m_crypter->encrypt(ptr, ptr, size);
671      }
672  #endif
673      m_actualSize += size;
674      updateCRCDigest(ptr, size);
675      return make_pair(true, KeyValueHolder(originKeyLength, valueLength, offset));
676  }
677  KVHolderRet_t MMKV::appendDataWithKey(const MMBuffer &data, MMKVKey_t key, bool isDataHolder) {
678  #ifdef MMKV_APPLE
679      auto oData = [key dataUsingEncoding:NSUTF8StringEncoding];
680      auto keyData = MMBuffer(oData, MMBufferNoCopy);
681  #else
682      auto keyData = MMBuffer((void *) key.data(), key.size(), MMBufferNoCopy);
683  #endif
684      return doAppendDataWithKey(data, keyData, isDataHolder, static_cast<uint32_t>(keyData.length()));
685  }
686  KVHolderRet_t MMKV::appendDataWithKey(const MMBuffer &data, const KeyValueHolder &kvHolder, bool isDataHolder) {
687      SCOPED_LOCK(m_exclusiveProcessLock);
688      uint32_t keyLength = kvHolder.keySize;
689      size_t rawKeySize = keyLength + pbRawVarint32Size(keyLength);
690      {
691          auto valueLength = static_cast<uint32_t>(data.length());
692          if (isDataHolder) {
693              valueLength += pbRawVarint32Size(valueLength);
694          }
695          auto size = rawKeySize + valueLength + pbRawVarint32Size(valueLength);
696          bool hasEnoughSize = ensureMemorySize(size);
697          if (!hasEnoughSize) {
698              return make_pair(false, KeyValueHolder());
699          }
700      }
701      auto basePtr = (uint8_t *) m_file->getMemory() + Fixed32Size;
702      MMBuffer keyData(basePtr + kvHolder.offset, rawKeySize, MMBufferNoCopy);
703      return doAppendDataWithKey(data, keyData, isDataHolder, keyLength);
704  }
705  bool MMKV::fullWriteback(AESCrypt *newCrypter) {
706      if (m_hasFullWriteback) {
707          return true;
708      }
709      if (m_needLoadFromFile) {
710          return true;
711      }
712      if (!isFileValid()) {
713          MMKVWarning("[%s] file not valid", m_mmapID.c_str());
714          return false;
715      }
716      if (unlikely(m_enableKeyExpire)) {
717          filterExpiredKeys();
718      }
719      if (m_crypter ? m_dicCrypt->empty() : m_dic->empty()) {
720          clearAll();
721          return true;
722      }
723      SCOPED_LOCK(m_exclusiveProcessLock);
724      auto preparedData = m_crypter ? prepareEncode(*m_dicCrypt) : prepareEncode(*m_dic);
725      auto sizeOfDic = preparedData.second;
726      if (sizeOfDic > 0) {
727          auto fileSize = m_file->getFileSize();
728          if (sizeOfDic + Fixed32Size <= fileSize) {
729              return doFullWriteBack(std::move(preparedData), newCrypter);
730          } else {
731              assert(0);
732              assert(newCrypter == nullptr);
733              auto newSize = sizeOfDic + Fixed32Size - fileSize;
734              return expandAndWriteBack(newSize, std::move(preparedData));
735          }
736      }
737      return false;
738  }
739  static void
740  memmoveDictionary(MMKVMap &dic, CodedOutputData *output, uint8_t *ptr, AESCrypt *encrypter, size_t totalSize) {
741      auto originOutputPtr = output->curWritePointer();
742      auto writePtr = originOutputPtr + ItemSizeHolderSize;
743      if (!dic.empty()) {
744          vector<KeyValueHolder *> vec;
745          vec.reserve(dic.size());
746          for (auto &itr : dic) {
747              vec.push_back(&itr.second);
748          }
749          sort(vec.begin(), vec.end(), [](const auto &left, const auto &right) { return left->offset < right->offset; });
750          vector<pair<uint32_t, uint32_t>> dataSections; 
751          dataSections.emplace_back(vec.front()->offset, vec.front()->computedKVSize + vec.front()->valueSize);
752          for (size_t index = 1, total = vec.size(); index < total; index++) {
753              auto kvHolder = vec[index];
754              auto &lastSection = dataSections.back();
755              if (kvHolder->offset == lastSection.first + lastSection.second) {
756                  lastSection.second += kvHolder->computedKVSize + kvHolder->valueSize;
757              } else {
758                  dataSections.emplace_back(kvHolder->offset, kvHolder->computedKVSize + kvHolder->valueSize);
759              }
760          }
761          auto basePtr = ptr + Fixed32Size;
762          for (auto &section : dataSections) {
763              memmove(writePtr, basePtr + section.first, section.second);
764              writePtr += section.second;
765          }
766          if (!encrypter) {
767              auto offset = ItemSizeHolderSize;
768              for (auto kvHolder : vec) {
769                  kvHolder->offset = offset;
770                  offset += kvHolder->computedKVSize + kvHolder->valueSize;
771              }
772          }
773      }
774      output->writeRawVarint32(ItemSizeHolder);
775      auto writtenSize = static_cast<size_t>(writePtr - originOutputPtr);
776  #ifndef MMKV_DISABLE_CRYPT
777      if (encrypter) {
778          encrypter->encrypt(originOutputPtr, originOutputPtr, writtenSize);
779      }
780  #endif
781      assert(writtenSize == totalSize);
782      output->seek(writtenSize - ItemSizeHolderSize);
783  }
784  #ifndef MMKV_DISABLE_CRYPT
785  static void memmoveDictionary(MMKVMapCrypt &dic,
786                                CodedOutputData *output,
787                                uint8_t *ptr,
788                                AESCrypt *decrypter,
789                                AESCrypt *encrypter,
790                                pair<MMBuffer, size_t> &preparedData) {
791      vector<KeyValueHolderCrypt *> vec;
792      if (!dic.empty()) {
793          vec.reserve(dic.size());
794          for (auto &itr : dic) {
795              if (itr.second.type == KeyValueHolderType_Offset) {
796                  vec.push_back(&itr.second);
797              }
798          }
799          sort(vec.begin(), vec.end(), [](auto left, auto right) { return left->offset < right->offset; });
800      }
801      auto sizeHolder = ItemSizeHolder, sizeHolderSize = ItemSizeHolderSize;
802      if (!vec.empty()) {
803          auto smallestOffset = vec.front()->offset;
804          if (smallestOffset != ItemSizeHolderSize && smallestOffset <= 5) {
805              sizeHolderSize = smallestOffset;
806              assert(sizeHolderSize != 0);
807              static const uint32_t ItemSizeHolders[] = {0, 0x0f, 0xff, 0xffff, 0xffffff, 0xffffffff};
808              sizeHolder = ItemSizeHolders[sizeHolderSize];
809          }
810      }
811      output->writeRawVarint32(static_cast<int32_t>(sizeHolder));
812      auto writePtr = output->curWritePointer();
813      if (encrypter) {
814          encrypter->encrypt(writePtr - sizeHolderSize, writePtr - sizeHolderSize, sizeHolderSize);
815      }
816      if (!vec.empty()) {
817          vector<tuple<uint32_t, uint32_t, AESCryptStatus *>> dataSections; 
818          dataSections.push_back(vec.front()->toTuple());
819          for (size_t index = 1, total = vec.size(); index < total; index++) {
820              auto kvHolder = vec[index];
821              auto &lastSection = dataSections.back();
822              if (kvHolder->offset == get<0>(lastSection) + get<1>(lastSection)) {
823                  get<1>(lastSection) += kvHolder->pbKeyValueSize + kvHolder->keySize + kvHolder->valueSize;
824              } else {
825                  dataSections.push_back(kvHolder->toTuple());
826              }
827          }
828          auto basePtr = ptr + Fixed32Size;
829          for (auto &section : dataSections) {
830              auto crypter = decrypter->cloneWithStatus(*get<2>(section));
831              crypter.decrypt(basePtr + get<0>(section), writePtr, get<1>(section));
832              writePtr += get<1>(section);
833          }
834          if (encrypter) {
835              auto offset = sizeHolderSize;
836              for (auto kvHolder : vec) {
837                  kvHolder->offset = offset;
838                  auto size = kvHolder->pbKeyValueSize + kvHolder->keySize + kvHolder->valueSize;
839                  encrypter->getCurStatus(kvHolder->cryptStatus);
840                  encrypter->encrypt(basePtr + offset, basePtr + offset, size);
841                  offset += size;
842              }
843          }
844      }
845      auto &data = preparedData.first;
846      if (data.length() > 0) {
847          auto dataSize = CodedInputData(data.getPtr(), data.length()).readUInt32();
848          if (dataSize > 0) {
849              auto dataPtr = (uint8_t *) data.getPtr() + pbRawVarint32Size(dataSize);
850              if (encrypter) {
851                  encrypter->encrypt(dataPtr, writePtr, dataSize);
852              } else {
853                  memcpy(writePtr, dataPtr, dataSize);
854              }
855              writePtr += dataSize;
856          }
857      }
858      auto writtenSize = static_cast<size_t>(writePtr - output->curWritePointer());
859      assert(writtenSize + sizeHolderSize == preparedData.second);
860      output->seek(writtenSize);
861  }
862  #    define InvalidCryptPtr ((AESCrypt *) (void *) (1))
863  #endif 
864  static void fullWriteBackWholeData(MMBuffer allData, size_t totalSize, CodedOutputData *output) {
865      auto originOutputPtr = output->curWritePointer();
866      output->writeRawVarint32(ItemSizeHolder);
867      if (allData.length() > 0) {
868          auto dataSize = CodedInputData(allData.getPtr(), allData.length()).readUInt32();
869          if (dataSize > 0) {
870              auto dataPtr = (uint8_t *)allData.getPtr() + pbRawVarint32Size(dataSize);
871              memcpy(output->curWritePointer(), dataPtr, dataSize);
872              output->seek(dataSize);
873          }
874      }
875      [[maybe_unused]] auto writtenSize = (size_t) (output->curWritePointer() - originOutputPtr);
876      assert(writtenSize == totalSize);
877  }
878  #ifndef MMKV_DISABLE_CRYPT
879  bool MMKV::doFullWriteBack(pair<MMBuffer, size_t> prepared, AESCrypt *newCrypter) {
880      auto ptr = (uint8_t *) m_file->getMemory();
881      auto totalSize = prepared.second;
882  #ifdef MMKV_IOS
883      auto ret = guardForBackgroundWriting(ptr + Fixed32Size, totalSize);
884      if (!ret.first) {
885          return false;
886      }
887  #endif
888      uint8_t newIV[AES_KEY_LEN];
889      auto encrypter = (newCrypter == InvalidCryptPtr) ? nullptr : (newCrypter ? newCrypter : m_crypter);
890      if (encrypter) {
891          AESCrypt::fillRandomIV(newIV);
892          encrypter->resetIV(newIV, sizeof(newIV));
893      }
894      delete m_output;
895      m_output = new CodedOutputData(ptr + Fixed32Size, m_file->getFileSize() - Fixed32Size);
896      if (m_crypter) {
897          auto decrypter = m_crypter;
898          memmoveDictionary(*m_dicCrypt, m_output, ptr, decrypter, encrypter, prepared);
899      } else if (prepared.first.length() != 0) {
900          auto &preparedData = prepared.first;
901          fullWriteBackWholeData(std::move(preparedData), totalSize, m_output);
902          if (encrypter) {
903              encrypter->encrypt(ptr + Fixed32Size, ptr + Fixed32Size, totalSize);
904          }
905      } else {
906          memmoveDictionary(*m_dic, m_output, ptr, encrypter, totalSize);
907      }
908      m_actualSize = totalSize;
909      if (encrypter) {
910          recaculateCRCDigestWithIV(newIV);
911      } else {
912          recaculateCRCDigestWithIV(nullptr);
913      }
914      m_hasFullWriteback = true;
915      sync(MMKV_SYNC);
916      return true;
917  }
918  #else 
919  bool MMKV::doFullWriteBack(pair<MMBuffer, size_t> prepared, AESCrypt *) {
920      auto ptr = (uint8_t *) m_file->getMemory();
921      auto totalSize = prepared.second;
922  #ifdef MMKV_IOS
923      auto ret = guardForBackgroundWriting(ptr + Fixed32Size, totalSize);
924      if (!ret.first) {
925          return false;
926      }
927  #endif
928      delete m_output;
929      m_output = new CodedOutputData(ptr + Fixed32Size, m_file->getFileSize() - Fixed32Size);
930      if (prepared.first.length() != 0) {
931          auto &preparedData = prepared.first;
932          fullWriteBackWholeData(std::move(preparedData), totalSize, m_output);
933      } else {
934          constexpr AESCrypt *encrypter = nullptr;
935          memmoveDictionary(*m_dic, m_output, ptr, encrypter, totalSize);
936      }
937      m_actualSize = totalSize;
938      recaculateCRCDigestWithIV(nullptr);
939      m_hasFullWriteback = true;
940      sync(MMKV_SYNC);
941      return true;
942  }
943  #endif 
944  #ifndef MMKV_DISABLE_CRYPT
945  bool MMKV::reKey(const string &cryptKey) {
946      SCOPED_LOCK(m_lock);
947      SCOPED_LOCK(m_exclusiveProcessLock);
948      checkLoadData();
949      bool ret = false;
950      if (m_crypter) {
951          if (cryptKey.length() > 0) {
952              string oldKey = this->cryptKey();
953              if (cryptKey == oldKey) {
954                  return true;
955              } else {
956                  MMKVInfo("reKey with new aes key");
957                  auto newCrypt = new AESCrypt(cryptKey.data(), cryptKey.length());
958                  m_hasFullWriteback = false;
959                  ret = fullWriteback(newCrypt);
960                  if (ret) {
961                      delete m_crypter;
962                      m_crypter = newCrypt;
963                  } else {
964                      delete newCrypt;
965                  }
966              }
967          } else {
968              MMKVInfo("reKey to no aes key");
969              m_hasFullWriteback = false;
970              ret = fullWriteback(InvalidCryptPtr);
971              if (ret) {
972                  delete m_crypter;
973                  m_crypter = nullptr;
974                  if (!m_dic) {
975                      m_dic = new MMKVMap();
976                  }
977              }
978          }
979      } else {
980          if (cryptKey.length() > 0) {
981              MMKVInfo("reKey to a aes key");
982              m_hasFullWriteback = false;
983              auto newCrypt = new AESCrypt(cryptKey.data(), cryptKey.length());
984              ret = fullWriteback(newCrypt);
985              if (ret) {
986                  m_crypter = newCrypt;
987                  if (!m_dicCrypt) {
988                      m_dicCrypt = new MMKVMapCrypt();
989                  }
990              } else {
991                  delete newCrypt;
992              }
993          } else {
994              return true;
995          }
996      }
997      if (ret) {
998          clearMemoryCache();
999      }
1000      return ret;
1001  }
1002  #endif
1003  void MMKV::trim() {
1004      SCOPED_LOCK(m_lock);
1005      MMKVInfo("prepare to trim %s", m_mmapID.c_str());
1006      checkLoadData();
1007      if (m_actualSize == 0) {
1008          clearAll();
1009          return;
1010      } else if (m_file->getFileSize() <= DEFAULT_MMAP_SIZE) {
1011          return;
1012      }
1013      SCOPED_LOCK(m_exclusiveProcessLock);
1014      fullWriteback();
1015      auto oldSize = m_file->getFileSize();
1016      auto fileSize = oldSize;
1017      while (fileSize > (m_actualSize + Fixed32Size) * 2) {
1018          fileSize /= 2;
1019      }
1020      fileSize = std::max<size_t>(fileSize, DEFAULT_MMAP_SIZE);
1021      if (oldSize == fileSize) {
1022          MMKVInfo("there's no need to trim %s with size %zu, actualSize %zu", m_mmapID.c_str(), fileSize, m_actualSize);
1023          return;
1024      }
1025      MMKVInfo("trimming %s from %zu to %zu, actualSize %zu", m_mmapID.c_str(), oldSize, fileSize, m_actualSize);
1026      if (!m_file->truncate(fileSize)) {
1027          return;
1028      }
1029      fileSize = m_file->getFileSize();
1030      auto ptr = (uint8_t *) m_file->getMemory();
1031      delete m_output;
1032      m_output = new CodedOutputData(ptr + pbFixed32Size(), fileSize - Fixed32Size);
1033      m_output->seek(m_actualSize);
1034      MMKVInfo("finish trim %s from %zu to %zu", m_mmapID.c_str(), oldSize, fileSize);
1035  }
1036  void MMKV::clearAll() {
1037      MMKVInfo("cleaning all key-values from [%s]", m_mmapID.c_str());
1038      SCOPED_LOCK(m_lock);
1039      SCOPED_LOCK(m_exclusiveProcessLock);
1040      checkLoadData();
1041      if (m_file->getFileSize() == DEFAULT_MMAP_SIZE && m_actualSize == 0) {
1042          MMKVInfo("nothing to clear for [%s]", m_mmapID.c_str());
1043          return;
1044      }
1045      m_file->truncate(DEFAULT_MMAP_SIZE);
1046  #ifndef MMKV_DISABLE_CRYPT
1047      uint8_t newIV[AES_KEY_LEN];
1048      AESCrypt::fillRandomIV(newIV);
1049      if (m_crypter) {
1050          m_crypter->resetIV(newIV, sizeof(newIV));
1051      }
1052      writeActualSize(0, 0, newIV, IncreaseSequence);
1053  #else
1054      writeActualSize(0, 0, nullptr, IncreaseSequence);
1055  #endif
1056      m_metaFile->msync(MMKV_SYNC);
1057      clearMemoryCache();
1058      loadFromFile();
1059  }
1060  bool MMKV::isFileValid(const string &mmapID, MMKVPath_t *relatePath) {
1061      MMKVPath_t kvPath = mappedKVPathWithID(mmapID, MMKV_SINGLE_PROCESS, relatePath);
1062      if (!isFileExist(kvPath)) {
1063          return true;
1064      }
1065      MMKVPath_t crcPath = crcPathWithID(mmapID, MMKV_SINGLE_PROCESS, relatePath);
1066      if (!isFileExist(crcPath)) {
1067          return false;
1068      }
1069      uint32_t crcFile = 0;
1070      MMBuffer *data = readWholeFile(crcPath);
1071      if (data) {
1072          if (data->getPtr()) {
1073              MMKVMetaInfo metaInfo;
1074              metaInfo.read(data->getPtr());
1075              crcFile = metaInfo.m_crcDigest;
1076          }
1077          delete data;
1078      } else {
1079          return false;
1080      }
1081      uint32_t crcDigest = 0;
1082      MMBuffer *fileData = readWholeFile(kvPath);
1083      if (fileData) {
1084          if (fileData->getPtr() && (fileData->length() >= Fixed32Size)) {
1085              uint32_t actualSize = 0;
1086              memcpy(&actualSize, fileData->getPtr(), Fixed32Size);
1087              if (actualSize > (fileData->length() - Fixed32Size)) {
1088                  delete fileData;
1089                  return false;
1090              }
1091              crcDigest = (uint32_t) CRC32(0, (const uint8_t *) fileData->getPtr() + Fixed32Size, (uint32_t) actualSize);
1092          }
1093          delete fileData;
1094          return crcFile == crcDigest;
1095      } else {
1096          return false;
1097      }
1098  }
1099  uint32_t MMKV::getCurrentTimeInSecond() {
1100      auto time = ::time(nullptr);
1101      return static_cast<uint32_t>(time);
1102  }
1103  bool MMKV::doFullWriteBack(MMKVVector &&vec) {
1104      auto preparedData = prepareEncode(std::move(vec));
1105      if (m_crypter) {
1106          clearDictionary(m_dicCrypt);
1107      } else {
1108          clearDictionary(m_dic);
1109      }
1110      bool ret = false;
1111      auto sizeOfDic = preparedData.second;
1112      auto fileSize = m_file->getFileSize();
1113      if (sizeOfDic + Fixed32Size <= fileSize) {
1114          ret = doFullWriteBack(std::move(preparedData), nullptr);
1115      } else {
1116          auto newSize = sizeOfDic + Fixed32Size - fileSize;
1117          ret = expandAndWriteBack(newSize, std::move(preparedData));
1118      }
1119      clearMemoryCache();
1120      return ret;
1121  }
1122  bool MMKV::enableAutoKeyExpire(uint32_t expiredInSeconds) {
1123      SCOPED_LOCK(m_lock);
1124      SCOPED_LOCK(m_exclusiveProcessLock);
1125      checkLoadData();
1126      if (m_expiredInSeconds != expiredInSeconds) {
1127          MMKVInfo("expiredInSeconds: %u", expiredInSeconds);
1128          m_expiredInSeconds = expiredInSeconds;
1129      }
1130      m_enableKeyExpire = true;
1131      if (m_metaInfo->hasFlag(MMKVMetaInfo::EnableKeyExipre)) {
1132          return true;
1133      }
1134      auto autoRecordExpireTime = (m_expiredInSeconds != 0);
1135      auto time = autoRecordExpireTime ? getCurrentTimeInSecond() + m_expiredInSeconds : 0;
1136      MMKVInfo("turn on recording expire date for all keys inside [%s] from now %u", m_mmapID.c_str(), time);
<span onclick='openModal()' class='match'>1137      m_metaInfo->setFlag(MMKVMetaInfo::EnableKeyExipre);
1138      m_metaInfo->m_version = MMKVVersionFlag;
1139      if (m_file->getFileSize() == DEFAULT_MMAP_SIZE && m_actualSize == 0) {
1140          MMKVInfo("file is new, don't need a full writeback [%s], just update meta file", m_mmapID.c_str());
1141          writeActualSize(0, 0, nullptr, IncreaseSequence);
1142          m_metaFile->msync(MMKV_SYNC);
1143          return true;
1144      }
1145      MMKVVector vec;
1146      auto packKeyValue = [&](const MMKVKey_t &key, const MMBuffer &value) {
1147          MMBuffer data(value.length() + Fixed32Size);
</span>1148          auto ptr = (uint8_t *)data.getPtr();
1149          memcpy(ptr, value.getPtr(), value.length());
1150          memcpy(ptr + value.length(), &time, Fixed32Size);
1151          vec.emplace_back(key, std::move(data));
1152      };
1153      auto basePtr = (uint8_t *) (m_file->getMemory()) + Fixed32Size;
1154  #ifndef MMKV_DISABLE_CRYPT
1155      if (m_crypter) {
1156          for (auto &pair : *m_dicCrypt) {
1157              auto &key = pair.first;
1158              auto &value = pair.second;
1159              auto buffer = value.toMMBuffer(basePtr, m_crypter);
1160              packKeyValue(key, buffer);
1161          }
1162      } else
1163  #endif
1164      {
1165          for (auto &pair : *m_dic) {
1166              auto &key = pair.first;
1167              auto &value = pair.second;
1168              auto buffer = value.toMMBuffer(basePtr);
1169              packKeyValue(key, buffer);
1170          }
1171      }
1172      return doFullWriteBack(std::move(vec));
1173  }
1174  bool MMKV::disableAutoKeyExpire() {
1175      SCOPED_LOCK(m_lock);
1176      SCOPED_LOCK(m_exclusiveProcessLock);
1177      checkLoadData();
1178      m_expiredInSeconds = 0;
1179      m_enableKeyExpire = false;
1180      if (!m_metaInfo->hasFlag(MMKVMetaInfo::EnableKeyExipre)) {
1181          return true;
1182      }
1183      MMKVInfo("erase previous recorded expire date for all keys inside [%s]", m_mmapID.c_str());
1184      m_metaInfo->unsetFlag(MMKVMetaInfo::EnableKeyExipre);
1185      m_metaInfo->m_version = MMKVVersionFlag;
1186      if (m_file->getFileSize() == DEFAULT_MMAP_SIZE && m_actualSize == 0) {
1187          MMKVInfo("file is new, don't need a full write-back [%s], just update meta file", m_mmapID.c_str());
1188          writeActualSize(0, 0, nullptr, IncreaseSequence);
1189          m_metaFile->msync(MMKV_SYNC);
1190          return true;
1191      }
1192      MMKVVector vec;
1193      auto packKeyValue = [&](const MMKVKey_t &key, const MMBuffer &value) {
1194          assert(value.length() >= Fixed32Size);
1195          MMBuffer data(value.length() - Fixed32Size);
1196          auto ptr = (uint8_t *)data.getPtr();
1197          memcpy(ptr, value.getPtr(), value.length() - Fixed32Size);
1198          vec.emplace_back(key, std::move(data));
1199      };
1200      auto basePtr = (uint8_t *) (m_file->getMemory()) + Fixed32Size;
1201  #ifndef MMKV_DISABLE_CRYPT
1202      if (m_crypter) {
1203          for (auto &pair : *m_dicCrypt) {
1204              auto &key = pair.first;
1205              auto &value = pair.second;
1206              auto buffer = value.toMMBuffer(basePtr, m_crypter);
1207              packKeyValue(key, buffer);
1208          }
1209      } else
1210  #endif
1211      {
1212          for (auto &pair : *m_dic) {
1213              auto &key = pair.first;
1214              auto &value = pair.second;
1215              auto buffer = value.toMMBuffer(basePtr);
1216              packKeyValue(key, buffer);
1217          }
1218      }
1219      return doFullWriteBack(std::move(vec));
1220  }
1221  uint32_t MMKV::getExpireTimeForKey(MMKVKey_t key) {
1222      SCOPED_LOCK(m_lock);
1223      SCOPED_LOCK(m_sharedProcessLock);
1224      checkLoadData();
1225      if (!m_enableKeyExpire || key_length(key) == 0) {
1226          return 0;
1227      }
1228      auto raw = getRawDataForKey(key);
1229      assert(raw.length() == 0 || raw.length() >= Fixed32Size);
1230      if (raw.length() < Fixed32Size) {
1231          return 0;
1232      }
1233      auto ptr = (const uint8_t *)raw.getPtr() + raw.length() - Fixed32Size;
1234      auto time = *(const uint32_t *)ptr;
1235      return time;
1236  }
1237  mmkv::MMBuffer MMKV::getDataWithoutMTimeForKey(MMKVKey_t key) {
1238      SCOPED_LOCK(m_lock);
1239      SCOPED_LOCK(m_sharedProcessLock);
1240      checkLoadData();
1241      auto raw = getRawDataForKey(key);
1242      assert(raw.length() == 0 || raw.length() >= Fixed32Size);
1243      if (raw.length() < Fixed32Size) {
1244          return raw;
1245      }
1246      auto newLength = raw.length() - Fixed32Size;
1247      if (m_enableKeyExpire) {
1248          auto ptr = (const uint8_t *)raw.getPtr() + newLength;
1249          auto time = *(const uint32_t *)ptr;
1250          if (time != ExpireNever && time <= getCurrentTimeInSecond()) {
1251  #ifdef MMKV_APPLE
1252              MMKVInfo("deleting expired key [%@] in mmkv [%s], due date %u", key, m_mmapID.c_str(), time);
1253  #else
1254              MMKVInfo("deleting expired key [%s] in mmkv [%s], due date %u", key.c_str(), m_mmapID.c_str(), time);
1255  #endif
1256              removeValueForKey(key);
1257              return MMBuffer();
1258          }
1259      }
1260      return MMBuffer(std::move(raw), newLength);
1261  }
1262  #define NOOP ((void)0)
1263  size_t MMKV::filterExpiredKeys() {
1264      if (!m_enableKeyExpire || (m_crypter ? m_dicCrypt->empty() : m_dic->empty())) {
1265          return 0;
1266      }
1267      auto now = getCurrentTimeInSecond();
1268      MMKVInfo("filtering expired keys inside [%s] now: %u, m_expiredInSeconds: %u", m_mmapID.c_str(), now, m_expiredInSeconds);
1269      size_t count = 0;
1270      auto basePtr = (uint8_t *)(m_file->getMemory()) + Fixed32Size;
1271  #ifndef MMKV_DISABLE_CRYPT
1272      if (m_crypter) {
1273          for (auto itr = m_dicCrypt->begin(); itr != m_dicCrypt->end(); NOOP) {
1274              auto &kvHolder = itr->second;
1275              assert(kvHolder.realValueSize() >= Fixed32Size);
1276              auto buffer = kvHolder.toMMBuffer(basePtr, m_crypter);
1277              auto ptr = (uint8_t*) buffer.getPtr();
1278              ptr += buffer.length() - Fixed32Size;
1279              auto time = *(const uint32_t *)ptr;
1280              if (time != ExpireNever && time <= now) {
1281                  auto oldKey = itr->first;
1282                  itr = m_dicCrypt->erase(itr);
1283  #ifdef MMKV_APPLE
1284                  MMKVInfo("deleting expired key [%@], due date %u", oldKey, time);
1285                  [oldKey release];
1286  #else
1287                  MMKVInfo("deleting expired key [%s], due date %u", oldKey.c_str(), time);
1288  #endif
1289                  count++;
1290              } else {
1291                  itr++;
1292              }
1293          }
1294      } else
1295  #endif 
1296      {
1297          for (auto itr = m_dic->begin(); itr != m_dic->end(); NOOP) {
1298              auto &kvHolder = itr->second;
1299              assert(kvHolder.valueSize >= Fixed32Size);
1300              auto ptr = basePtr + kvHolder.offset + kvHolder.computedKVSize;
1301              ptr += kvHolder.valueSize - Fixed32Size;
1302              auto time = *(const uint32_t *)ptr;
1303              if (time != ExpireNever && time <= now) {
1304                  auto oldKey = itr->first;
1305                  itr = m_dic->erase(itr);
1306  #ifdef MMKV_APPLE
1307                  MMKVInfo("deleting expired key [%@], due date %u", oldKey, time);
1308                  [oldKey release];
1309  #else
1310                  MMKVInfo("deleting expired key [%s], due date %u", oldKey.c_str(), time);
1311  #endif
1312                  count++;
1313              } else {
1314                  itr++;
1315              }
1316          }
1317      }
1318      MMKVInfo("deleted %zu expired keys inside [%s]", count, m_mmapID.c_str());
1319      return count;
1320  }
1321  MMKV_NAMESPACE_END
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from MMKV-MDEwOlJlcG9zaXRvcnkxNDkxMTE4MTM=-flat-MMKV_IO.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from MMKV-MDEwOlJlcG9zaXRvcnkxNDkxMTE4MTM=-flat-MMKV_IO.cpp</div>
                </div>
                <div class="column column_space"><pre><code>1137      m_metaInfo->setFlag(MMKVMetaInfo::EnableKeyExipre);
1138      m_metaInfo->m_version = MMKVVersionFlag;
1139      if (m_file->getFileSize() == DEFAULT_MMAP_SIZE && m_actualSize == 0) {
1140          MMKVInfo("file is new, don't need a full writeback [%s], just update meta file", m_mmapID.c_str());
1141          writeActualSize(0, 0, nullptr, IncreaseSequence);
1142          m_metaFile->msync(MMKV_SYNC);
1143          return true;
1144      }
1145      MMKVVector vec;
1146      auto packKeyValue = [&](const MMKVKey_t &key, const MMBuffer &value) {
1147          MMBuffer data(value.length() + Fixed32Size);
</pre></code></div>
                <div class="column column_space"><pre><code>1137      m_metaInfo->setFlag(MMKVMetaInfo::EnableKeyExipre);
1138      m_metaInfo->m_version = MMKVVersionFlag;
1139      if (m_file->getFileSize() == DEFAULT_MMAP_SIZE && m_actualSize == 0) {
1140          MMKVInfo("file is new, don't need a full writeback [%s], just update meta file", m_mmapID.c_str());
1141          writeActualSize(0, 0, nullptr, IncreaseSequence);
1142          m_metaFile->msync(MMKV_SYNC);
1143          return true;
1144      }
1145      MMKVVector vec;
1146      auto packKeyValue = [&](const MMKVKey_t &key, const MMBuffer &value) {
1147          MMBuffer data(value.length() + Fixed32Size);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    