
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 4.226918798665183%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-DocTabView.cpp</h3>
            <pre><code>1  #include "DocTabView.h"
2  #include "ScintillaEditView.h"
3  #ifndef _WIN32_IE
4  #define _WIN32_IE	0x0600
5  #endif 
6  bool DocTabView::_hideTabBarStatus = false;
7  void DocTabView::addBuffer(BufferID buffer)
8  {
9  	if (buffer == BUFFER_INVALID)	
10  		return;
11  	if (getIndexByBuffer(buffer) != -1)	
12  		return;
13  	Buffer * buf = MainFileManager.getBufferByID(buffer);
14  	TCITEM tie{};
15  	tie.mask = TCIF_TEXT | TCIF_IMAGE | TCIF_PARAM;
16  	int index = -1;
17  	if (_hasImgLst)
18  		index = 0;
19  	tie.iImage = index;
20  	tie.pszText = const_cast<TCHAR *>(buf->getFileName());
21  	tie.lParam = reinterpret_cast<LPARAM>(buffer);
22  	::SendMessage(_hSelf, TCM_INSERTITEM, _nbItem++, reinterpret_cast<LPARAM>(&tie));
23  	bufferUpdated(buf, BufferChangeMask);
24  	::SendMessage(_hParent, WM_SIZE, 0, 0);
25  }
26  void DocTabView::closeBuffer(BufferID buffer)
27  {
28  	int indexToClose = getIndexByBuffer(buffer);
29  	deletItemAt((size_t)indexToClose);
30  	::SendMessage(_hParent, WM_SIZE, 0, 0);
31  }
32  void DocTabView::setIndividualTabColour(BufferID bufferId, int colorId)
33  {
34  	bufferId->setDocColorId(colorId);
35  }
36  int DocTabView::getIndividualTabColour(int tabIndex)
37  {
38  	BufferID bufferId = getBufferByIndex(tabIndex);
39  	return bufferId->getDocColorId();
40  }
41  bool DocTabView::activateBuffer(BufferID buffer)
42  {
43  	int indexToActivate = getIndexByBuffer(buffer);
44  	if (indexToActivate == -1)
45  		return false;	
46  	activateAt(indexToActivate);
47  	return true;
48  }
49  BufferID DocTabView::activeBuffer()
50  {
51  	int index = getCurrentTabIndex();
52  	return getBufferByIndex(index);
53  }
54  BufferID DocTabView::findBufferByName(const TCHAR * fullfilename) 
55  {
56  	TCITEM tie{};
57  	tie.lParam = -1;
58  	tie.mask = TCIF_PARAM;
59  	for (size_t i = 0; i < _nbItem; ++i)
60  	{
61  		::SendMessage(_hSelf, TCM_GETITEM, i, reinterpret_cast<LPARAM>(&tie));
62  		BufferID id = reinterpret_cast<BufferID>(tie.lParam);
63  		Buffer * buf = MainFileManager.getBufferByID(id);
64  		if (OrdinalIgnoreCaseCompareStrings(fullfilename, buf->getFullPathName()) == 0)
65  		{
66  			return id;
67  		}
68  	}
69  	return BUFFER_INVALID;
70  }
71  int DocTabView::getIndexByBuffer(BufferID id)
72  {
73  	TCITEM tie{};
74  	tie.lParam = -1;
75  	tie.mask = TCIF_PARAM;
76  	for (size_t i = 0; i < _nbItem; ++i)
77  	{
78  		::SendMessage(_hSelf, TCM_GETITEM, i, reinterpret_cast<LPARAM>(&tie));
79  		if (reinterpret_cast<BufferID>(tie.lParam) == id)
80  			return static_cast<int>(i);
81  	}
82  	return -1;
83  }
84  BufferID DocTabView::getBufferByIndex(size_t index)
85  {
86  	TCITEM tie{};
87  	tie.lParam = -1;
88  	tie.mask = TCIF_PARAM;
89  	::SendMessage(_hSelf, TCM_GETITEM, index, reinterpret_cast<LPARAM>(&tie));
90  	return reinterpret_cast<BufferID>(tie.lParam);
91  }
92  void DocTabView::bufferUpdated(Buffer * buffer, int mask)
93  {
94  	int index = getIndexByBuffer(buffer->getID());
95  	if (index == -1)
96  		return;
97  	TCITEM tie{};
98  	tie.lParam = -1;
99  	tie.mask = 0;
100  	if (mask & BufferChangeReadonly || mask & BufferChangeDirty)
101  	{
102  		tie.mask |= TCIF_IMAGE;
103  		tie.iImage = buffer->isDirty()?UNSAVED_IMG_INDEX:SAVED_IMG_INDEX;
<span onclick='openModal()' class='match'>104  		if (buffer->isMonitoringOn())
105  		{
106  			tie.iImage = MONITORING_IMG_INDEX;
107  		}
108  		else if (buffer->isReadOnly())
109  		{
110  			tie.iImage = REDONLY_IMG_INDEX;
111  		}
</span>112  	}
113  	TCHAR encodedLabel[2 * MAX_PATH] = { '\0' };
114  	if (mask & BufferChangeFilename)
115  	{
116  		tie.mask |= TCIF_TEXT;
117  		tie.pszText = encodedLabel;
118  		{
119  			const TCHAR* in = buffer->getFileName();
120  			TCHAR* out = encodedLabel;
121  			while (*in != 0)
122  			if (*in == '&')
123  			{
124  				*out++ = '&';
125  				*out++ = '&';
126  				while (*(++in) == '&')
127  					*out++ = '&';
128  			}
129  			else
130  				*out++ = *in++;
131  			*out = '\0';
132  		}
133  	}
134  	::SendMessage(_hSelf, TCM_SETITEM, index, reinterpret_cast<LPARAM>(&tie));
135  	if (mask & BufferChangeRecentTag)
136  		::SendMessage(_hParent, WM_SIZE, 0, 0);
137  }
138  void DocTabView::setBuffer(size_t index, BufferID id)
139  {
140  	if (index >= _nbItem)
141  		return;
142  	TCITEM tie{};
143  	tie.lParam = reinterpret_cast<LPARAM>(id);
144  	tie.mask = TCIF_PARAM;
145  	::SendMessage(_hSelf, TCM_SETITEM, index, reinterpret_cast<LPARAM>(&tie));
146  	bufferUpdated(MainFileManager.getBufferByID(id), BufferChangeMask);	
147  	::SendMessage(_hParent, WM_SIZE, 0, 0);
148  }
149  void DocTabView::reSizeTo(RECT & rc)
150  {
151  	int borderWidth = ((NppParameters::getInstance()).getSVP())._borderWidth;
152  	if (_hideTabBarStatus)
153  	{
154  		RECT rcTmp = rc;
155  		TabBar::reSizeTo(rcTmp);
156  		_pView->reSizeTo(rc);
157  	}
158  	else
159  	{
160  		TabBar::reSizeTo(rc);
161  		rc.left	 += borderWidth;
162  		rc.right -= borderWidth * 2;
163  		rc.top   += borderWidth;
164  		rc.bottom -= (borderWidth * 2);
165  		_pView->reSizeTo(rc);
166  	}
167  	SendMessage(_hParent, NPPM_INTERNAL_UPDATECLICKABLELINKS, reinterpret_cast<WPARAM>(_pView), 0);
168  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-url.cpp</h3>
            <pre><code>1  class TUrlLxChDef{
2  private:
3    TBoolV IsLoAlphaV, IsHiAlphaV, IsAlphaV;
4    TBoolV IsDigitV, IsSafeV, IsExtraV;
5    TBoolV IsNationalV, IsPunctuationV;
6    TBoolV IsReservedV, IsHexV;
7    TBoolV IsUnreservedV, IsUCharV, IsXCharV;
8    TBoolV IsSchemeV, IsHostV, IsHSegmentV;
9    void InclCh(TBoolV& BoolV, const char& Ch);
10    void InclStr(TBoolV& BoolV, const TStr& Str);
11    void InclBoolV(TBoolV& BoolV, const TBoolV& OrBoolV);
12  public:
13    static const char EofCh;
14    static const char EscCh;
15    TUrlLxChDef();
16    bool IsDigitCh(const char& Ch) const {return (Ch>=0)&&IsDigitV[Ch];}
17    bool IsSchemeCh(const char& Ch) const {return (Ch>=0)&&IsSchemeV[Ch];}
18    bool IsHostCh(const char& Ch) const {return (Ch>=0)&&IsHostV[Ch];}
19    bool IsHSegmentCh(const char& Ch) const {
20      return (Ch<0)||((Ch>=0)&&IsHSegmentV[Ch]);}
21  };
22  const char TUrlLxChDef::EofCh=0;
23  const char TUrlLxChDef::EscCh='%';
24  void TUrlLxChDef::InclCh(TBoolV& BoolV, const char& Ch){BoolV[Ch]=true;}
25  void TUrlLxChDef::InclStr(TBoolV& BoolV, const TStr& Str){
26    for (int CC=0; CC<Str.Len(); CC++){BoolV[Str.GetCh(CC)]=true;}}
27  void TUrlLxChDef::InclBoolV(TBoolV& BoolV, const TBoolV& OrBoolV){
28    for (int BoolN=0; BoolN<BoolV.Len(); BoolN++){
29      BoolV[BoolN]=BoolV[BoolN]||OrBoolV[BoolN];}}
30  TUrlLxChDef::TUrlLxChDef():
31    IsLoAlphaV(TCh::Vals), IsHiAlphaV(TCh::Vals), IsAlphaV(TCh::Vals),
32    IsDigitV(TCh::Vals), IsSafeV(TCh::Vals), IsExtraV(TCh::Vals),
33    IsNationalV(TCh::Vals), IsPunctuationV(TCh::Vals),
34    IsReservedV(TCh::Vals), IsHexV(TCh::Vals),
35    IsUnreservedV(TCh::Vals), IsUCharV(TCh::Vals), IsXCharV(TCh::Vals),
36    IsSchemeV(TCh::Vals), IsHostV(TCh::Vals), IsHSegmentV(TCh::Vals){
37    InclStr(IsLoAlphaV, "abcdefghijklmnopqrstuvwxyz");
38    InclStr(IsHiAlphaV, "ABCDEFGHIJKLMNOPQRSTUVWXYZ");
39    InclBoolV(IsAlphaV, IsLoAlphaV); InclBoolV(IsAlphaV, IsHiAlphaV);
40    InclStr(IsDigitV, "0123456789");
41    InclStr(IsSafeV, "$-_.+");
42    InclStr(IsExtraV, "!*'(),");
43    InclStr(IsNationalV, "{}|\\^~[]`");
44    InclStr(IsPunctuationV, "<>#%\"");
45    InclStr(IsReservedV, ";/?:@&=");
46    InclBoolV(IsHexV, IsDigitV); InclStr(IsHexV, "ABCDEFabcdef");
47    InclBoolV(IsUnreservedV, IsAlphaV); InclBoolV(IsUnreservedV, IsDigitV);
48    InclBoolV(IsUnreservedV, IsSafeV); InclBoolV(IsUnreservedV, IsExtraV);
49    InclBoolV(IsUCharV, IsUnreservedV); InclStr(IsUCharV, TStr(EscCh));
50    InclBoolV(IsXCharV, IsUnreservedV); InclBoolV(IsXCharV, IsReservedV);
51    InclStr(IsXCharV, TStr(EscCh));
52    InclBoolV(IsSchemeV, IsAlphaV); InclBoolV(IsSchemeV, IsDigitV);
53    InclStr(IsSchemeV, "+-.");
54    InclBoolV(IsHostV, IsAlphaV); InclBoolV(IsHostV, IsDigitV);
55    InclStr(IsHostV, "-_");
56    InclBoolV(IsHSegmentV, IsUCharV); InclStr(IsHSegmentV, ";:@&=");
57    InclBoolV(IsHSegmentV, IsNationalV); InclStr(IsHSegmentV, " ");
58  }
59  class TUrlLx{
60  private:
61    static const char EofCh;
62    TChA Bf;
63    int BfC;
64  public:
65    static const TUrlLxChDef ChDef;
66    TUrlLx(const TStr& _Str): Bf(_Str), BfC(0){}
67    bool Eof() const {return BfC==Bf.Len();};
68    char GetCh(){if (Eof()){return EofCh;} else {return Bf[BfC++];}}
69    char PeekCh() const {if (Eof()){return EofCh;} else {return Bf[BfC];}}
70    char GetCh(const char& Ch){EAssertR(GetCh()==Ch, ""); return Ch;}
71    TStr GetStr(const TStr& Str){
72      for (int ChN=0; ChN<Str.Len(); ChN++){GetCh(Str[ChN]);} return Str;}
73    const char* GetStr(const char *Str){
74  	int Len = (int) strlen(Str);
75      for (int ChN=0; ChN<Len; ChN++){GetCh(Str[ChN]);} 
76  	return Str;
77    }
78    bool IsSchemeCh() const {return ChDef.IsSchemeCh(PeekCh());}
79    char GetSchemeCh(){EAssertR(IsSchemeCh(), ""); return GetCh();}
80    bool IsDigitCh() const {return ChDef.IsDigitCh(PeekCh());}
81    char GetDigitCh(){EAssertR(IsDigitCh(), ""); return GetCh();}
82    bool IsHSegmentCh() const {return ChDef.IsHSegmentCh(PeekCh());}
83    char GetHSegmentCh(){EAssertR(IsHSegmentCh(), ""); return GetCh();}
84    TStr GetToCh(const char& Ch=TUrlLxChDef::EofCh){TChA Str;
85      while ((PeekCh()!=EofCh)&&(PeekCh()!=Ch)){Str+=GetCh();} return Str;}
86    TStr GetScheme(){TChA Str;
87      Str+=GetSchemeCh(); while (IsSchemeCh()){Str+=GetCh();}
88      Str.ToLc(); return Str;}
89    TStr GetHost();
90    TStr GetDigits(){TChA Str;
91      do {Str+=GetDigitCh();} while (IsDigitCh()); return Str;}
92    TStr GetHostPort(TStr& HostNm, TStr& PortStr, int& PortN);
93    TStr GetHPath(TStrV& PathSegV);
94    TStr GetSearch(){return GetToCh('#');}
95  };
96  const TUrlLxChDef TUrlLx::ChDef;
97  const char TUrlLx::EofCh=TUrlLxChDef::EofCh;
98  TStr TUrlLx::GetHost(){TChA Str;
99    EAssertR(ChDef.IsHostCh(PeekCh()), "");
100    do {
101      while (ChDef.IsHostCh(PeekCh())){Str+=GetCh();}
102      if (PeekCh()=='.'){Str+=GetCh('.');}
103      else if (PeekCh()=='@'){GetCh('@'); Str.Clr();} 
104    } while (ChDef.IsHostCh(PeekCh()));
105    Str.ToLc();
106    return Str;
107  }
108  TStr TUrlLx::GetHostPort(TStr& HostNm, TStr& PortStr, int& PortN){TChA Str;
109    Str+=HostNm=GetHost();
110    if (PeekCh()==':'){
111      Str+=GetCh(':');
112      if (IsDigitCh()){Str+=PortStr=GetDigits(); PortN=PortStr.GetInt();}
113    }
114    return Str;
115  }
116  TStr TUrlLx::GetHPath(TStrV& PathSegV){TChA Str; TChA HSegStr; bool Cont;
117    do {
118      while (PeekCh()=='/'){GetCh('/');} 
119      HSegStr.Clr(); while (IsHSegmentCh()){HSegStr+=GetHSegmentCh();}
120      Str+=HSegStr; PathSegV.Add(HSegStr);
121      Cont=(PeekCh()=='/'); if (Cont){Str+=GetCh('/');}
122    } while (Cont);
123    return Str;
124  }
125  const TStr TUrl::UrlHttpPrefixStr="http:";
126  const TStr TUrl::UrlHttpAbsPrefixStr="http:&bsol;&bsol;";
127  void TUrl::GetAbs(const TStr& AbsUrlStr){
128    EAssertR(IsAbs(AbsUrlStr), AbsUrlStr);
129    TUrlLx Lx(AbsUrlStr); TChA Str;
130    Str+=SchemeNm=Lx.GetScheme(); Str+=Lx.GetCh(':');
131    if (SchemeNm=="http"){
132      Scheme=usHttp;
133      const char *DbSlashStr="&bsol;&bsol;";
134      Str+=Lx.GetStr(DbSlashStr);
135      Str+=Lx.GetHostPort(HostNm, PortStr, PortN);
136      if (PortN==-1){PortN=THttp::DfPortN; PortStr.Clr();}
137      else if (PortN==THttp::DfPortN){PortStr.Clr();}
138      /&bsol;**if (!PortStr.Empty()){Str+=':'; Str+=PortStr;}
139      if (Lx.PeekCh()=='/'){
140        PathStr=Lx.GetCh('/'); PathStr+=Lx.GetHPath(PathSegV); Str+=PathStr;}
141      if (PathStr.Empty()){PathStr="/"; Str+=PathStr;}
142      if (Lx.PeekCh()=='?'){
143        SearchStr=Lx.GetCh('?'); SearchStr+=Lx.GetSearch(); Str+=SearchStr;}
144    } else {
145      Scheme=usOther; Str+=Lx.GetToCh();
146    }
147    while (Lx.PeekCh()==' '){Lx.GetCh();}
148    if (Lx.PeekCh()=='#'){
149      FragIdStr=Lx.GetCh('#'); FragIdStr+=Lx.GetToCh();
150    }
151    EAssertR(Lx.Eof(), "");
152    UrlStr=Str;
153  }
154  void TUrl::GetAbsFromBase(const TStr& RelUrlStr, const TStr& BaseUrlStr){
155    EAssertR(!BaseUrlStr.Empty(), "");
156    PUrl Url=TUrl::New(BaseUrlStr); EAssertR(Url->IsOk(), "");
157    EAssertR(IsAbs(BaseUrlStr), "");
158    TStr AbsUrlStr=BaseUrlStr;
159    TStr NrRelUrlStr=RelUrlStr;
160    if (NrRelUrlStr.GetLc().IsPrefix(UrlHttpPrefixStr)){
161      NrRelUrlStr.DelSubStr(0, UrlHttpPrefixStr.Len()-1);}
162    if (NrRelUrlStr.Len()>0){
163      if (NrRelUrlStr[0]=='/'){
164        TStr SlashStr; int SlashChN=0;
165        while ((SlashChN<NrRelUrlStr.Len())&&(NrRelUrlStr[SlashChN]=='/')){
166          SlashChN++; SlashStr+="/";}
167        int ChN=0; bool Found=false;
168        while ((!Found)&&((ChN=AbsUrlStr.SearchStr(SlashStr, ChN))!=-1)){
169          TStr Str=AbsUrlStr.GetSubStr(ChN-1, ChN+SlashStr.Len()-1+1);
170          Found=((ChN==0)||(Str[0]!='/'))&&
171           ((ChN+SlashStr.Len()-1==AbsUrlStr.Len()-1)||(Str[Str.Len()-1]!='/'));
172          if (!Found){ChN++;}
173        }
174        if (Found){
175          AbsUrlStr.DelSubStr(ChN, AbsUrlStr.Len()-1);
176          AbsUrlStr+=NrRelUrlStr;
177        }
178      } else {
179        int ChN=AbsUrlStr.Len()-1;
180        while ((ChN>=0)&&(AbsUrlStr[ChN]!='/')){ChN--;}
181        AbsUrlStr.DelSubStr(ChN+1, AbsUrlStr.Len()-1);
182        AbsUrlStr+=NrRelUrlStr;
183      }
184    }
185    const char *PrevDirStr="/../";
186    {int ChN;
187    while ((ChN=AbsUrlStr.SearchStr(PrevDirStr))!=-1){
188      int BChN=ChN; int EChN=ChN+(int) strlen(PrevDirStr)-1;
189      while ((BChN-1>=0)&&(AbsUrlStr[BChN-1]!='/')){BChN--;}
190      AbsUrlStr.DelSubStr(BChN, EChN);
191    }}
192    const char *CurDirStr="/.";
193    while (AbsUrlStr.DelStr(CurDirStr)){}
194    GetAbs(AbsUrlStr);
195  }
196  TUrl::TUrl(const TStr& _RelUrlStr, const TStr& _BaseUrlStr):
197    Scheme(usUndef),
198    UrlStr(), RelUrlStr(_RelUrlStr), BaseUrlStr(_BaseUrlStr),
199    SchemeNm(), HostNm(),
200    PortStr(), PathStr(), SearchStr(), FragIdStr(),
201    PortN(-1), PathSegV(),
202    IpNum(),
203    FinalUrlStr(), FinalHostNm(),
204    HttpRqStr(){
205    RelUrlStr.ToTrunc();
206    RelUrlStr.ChangeStrAll(" ", "%20");
207    try {
208      if (IsAbs(RelUrlStr)){
209        GetAbs(RelUrlStr);
210      } else
211      if (IsAbs(BaseUrlStr)){
212        GetAbsFromBase(RelUrlStr, BaseUrlStr);
213      } else {
214        Scheme=usUndef;
215      }
216    }
217    catch (PExcept&){Scheme=usUndef;}
218    /&bsol;** old version
219  }
220  TStr TUrl::GetDmNm(const int& MxDmSegs) const {
221    EAssert(IsOk());
222    TChA DmChA; int DmSegs=0;
223    for (int ChN=HostNm.Len()-1; ChN>=0; ChN--){
224      if (HostNm[ChN]=='.'){
225        DmSegs++;
226        if (DmSegs==MxDmSegs){break;} else {DmChA+='.';}
227      } else {
228        DmChA+=HostNm[ChN];
229      }
230    }
231    DmChA.Reverse();
232    return DmChA;
233  }
234  void TUrl::DefFinalUrl(const TStr& _FinalHostNm){
235    EAssert(IsOk(usHttp));
236    EAssert(!IsDefFinalUrl());
237    FinalHostNm=_FinalHostNm.GetLc();
238    if (HostNm==FinalHostNm){
239      FinalUrlStr=UrlStr;
240    } else {
241      TChA FinalUrlChA;
242      FinalUrlChA+=SchemeNm; FinalUrlChA+=":&bsol;&bsol;";
243      FinalUrlChA+=FinalHostNm;
244      if (!PortStr.Empty()){
245        FinalUrlChA+=":"; FinalUrlChA+=PortStr;}
246      FinalUrlChA+=PathStr;
247      FinalUrlChA+=SearchStr;
248      FinalUrlStr=FinalUrlChA;
249    }
250  }
251  void TUrl::ToLcPath(){
252    if (!PathStr.IsLc()){
253      PathStr.ToLc();
254      for (int PathSegN=0; PathSegN<PathSegV.Len(); PathSegN++){
255        PathSegV[PathSegN].ToLc();}
256      TChA UrlChA;
257      UrlChA+=SchemeNm; UrlChA+=":&bsol;&bsol;";
258      UrlChA+=HostNm;
259      if (!PortStr.Empty()){
260        UrlChA+=":"; UrlChA+=PortStr;}
261      UrlChA+=PathStr;
262      UrlChA+=SearchStr;
263      UrlStr=UrlChA;
264      if (IsDefFinalUrl()){
265        FinalUrlStr.Clr(); DefFinalUrl(FinalHostNm);}
266    }
267  }
268  bool TUrl::IsAbs(const TStr& UrlStr){
269    if (UrlStr.GetLc().IsPrefix(UrlHttpPrefixStr)){
270      return UrlStr.GetLc().IsPrefix(UrlHttpAbsPrefixStr);
271    } else {
272      int ColonChN=UrlStr.SearchCh(':'); int SlashChN=UrlStr.SearchCh('/');
273      return (ColonChN!=-1)&&((SlashChN==-1)||((SlashChN!=-1)&&(ColonChN<SlashChN)));
274    }
275  }
276  bool TUrl::IsScript(const TStr& UrlStr){
277    return UrlStr.IsChIn('?');
278  }
279  bool TUrl::IsSite(const TStr& UrlStr){
280    PUrl Url=TUrl::New(UrlStr);
281    return Url->IsOk(usHttp) && (Url->GetPathStr()=="/") &&
282     Url->GetSearchStr().Empty() && Url->GetFragIdStr().Empty();
283  }
284  PUrl TUrl::GetUrlFromShortcut(const TStr& ShortcutUrlStr,
285   const TStr& DfHostNmPrefix, const TStr& DfHostNmSufix){
286    TStr UrlStr=ShortcutUrlStr;
287    PUrl Url=TUrl::New(UrlStr);
288    if (Url->IsOk()){return Url;}
289    if (ShortcutUrlStr.IsChIn('.')){
290      UrlStr=TUrl::UrlHttpAbsPrefixStr+ShortcutUrlStr;
291      Url=TUrl::New(UrlStr);
292      if (Url->IsOk()){return Url;}
293    }
294    if (ShortcutUrlStr.IsChIn('.')){
295      UrlStr=TUrl::UrlHttpAbsPrefixStr+ShortcutUrlStr+"/";
296      Url=TUrl::New(UrlStr);
297      if (Url->IsOk()){return Url;}
298    }
299    UrlStr=UrlHttpAbsPrefixStr+
300     DfHostNmPrefix+"."+ShortcutUrlStr+"."+DfHostNmSufix+"/";
301    Url=TUrl::New(UrlStr);
302    return Url;
303  }
304  TStr TUrl::GetUrlSearchStr(const TStr& Str){
305    TChA InChA=Str; TChA OutChA;
306    for (int ChN=0; ChN<InChA.Len(); ChN++){
307      char Ch=InChA[ChN];
<span onclick='openModal()' class='match'>308      if (Ch==' '){
309        OutChA+='+';
310      } else
311      if ((' '<Ch)&&(Ch<='~')&&(Ch!='+')&&(Ch!='&')&&(Ch!='%')){
312        OutChA+=Ch;
313      } else {
</span>314        OutChA+='%';
315        OutChA+=TInt::GetHexStr(uchar(Ch)/16);
316        OutChA+=TInt::GetHexStr(uchar(Ch)%16);
317      }
318    }
319    return OutChA;
320  }
321  TStr TUrl::DecodeUrlStr(const TStr& UrlStr) {
322    TChA InChA=UrlStr; TChA OutChA;
323    for (int ChN=0; ChN<InChA.Len(); ChN++){
324      char Ch=InChA[ChN];
325      if (Ch=='+'){
326        OutChA+=' ';
327      } else if (Ch=='%') {
328        ChN++; if (ChN==InChA.Len()) { break; }
329        char FirstCh = InChA[ChN];
330        if (!TCh::IsHex(FirstCh)) { break; }
331        ChN++; if (ChN==InChA.Len()) { break; }
332        char SecondCh = InChA[ChN];
333        if (!TCh::IsHex(SecondCh)) { break; }
334        OutChA+=char(TCh::GetHex(FirstCh)*16 + TCh::GetHex(SecondCh));
335      } else {
336        OutChA+=Ch;
337      }
338    }
339    return OutChA;
340  }
341  TStr TUrl::GetDocStrFromUrlStr(const TStr& UrlStr, const int& Copies){
342    TStrV StrV; UrlStr.SplitOnNonAlNum(StrV);
343    TChA DocChA;
344    for (int StrN=0; StrN<StrV.Len(); StrN++){
345      TStr UcStr=StrV[StrN].GetUc();
346      if ((UcStr.Len()>3)&&(UcStr!="HTTP")&&(UcStr!="HTML")&&(UcStr!="INDEX")&&(UcStr!="DEFAULT")){
347        for (int CopyN=0; CopyN<Copies; CopyN++){
348          if (!DocChA.Empty()){DocChA+=' ';} DocChA+=StrV[StrN];
349        }
350      }
351    }
352    return DocChA;
353  }
354  TStr TUrl::GetTopDownDocNm(
355   const TStr& UrlStr, const int& MxLen, const bool& HostOnlyP){
356    PUrl Url=TUrl::New(UrlStr);
357    TChA DocNm;
358    if (Url->IsOk()){
359      TStr HostNm=Url->GetHostNm().GetLc();
360      TStrV HostNmSegV; HostNm.SplitOnAllCh('.', HostNmSegV, false);
361      for (int HostNmSegN=0; HostNmSegN<HostNmSegV.Len(); HostNmSegN++){
362        if (HostNmSegN>0){DocNm+='.';}
363        DocNm+=HostNmSegV[HostNmSegV.Len()-HostNmSegN-1];
364      }
365      if (!HostOnlyP){
366        DocNm+=Url->GetPathStr().GetLc();
367      }
368    } else {
369      DocNm=UrlStr.GetLc();
370    }
371    if (MxLen!=-1){
372      DocNm.Trunc(MxLen);}
373    return DocNm;
374  }
375  TStr TUrlEnv::GetFullUrlStr() const {
376    if (GetKeys()==0){return TStr();}
377    TChA SearchChA;
378    SearchChA+=BaseUrlStr;
379    SearchChA+="?";
380    int KeyVals=0;
381    for (int KeyN=0; KeyN<GetKeys(); KeyN++){
382      TStr KeyNm=GetKeyNm(KeyN);
383      TStrV ValStrV=KeyNmToValH.GetDat(KeyNm);
384      for (int ValStrN=0; ValStrN<ValStrV.Len(); ValStrN++){
385        if (KeyVals>0){SearchChA+="&";}
386        SearchChA+=TUrl::GetUrlSearchStr(KeyNm);
387        SearchChA+='=';
388        SearchChA+=TUrl::GetUrlSearchStr(ValStrV[ValStrN]);
389        KeyVals++;
390      }
391    }
392    return SearchChA;
393  }
394  PUrlEnv TUrlEnv::MkClone(const PUrlEnv& UrlEnv){
395    PUrlEnv CloneUrlEnv=
396     PUrlEnv(new TUrlEnv(*UrlEnv));
397    return CloneUrlEnv;
398  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-DocTabView.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-url.cpp</div>
                </div>
                <div class="column column_space"><pre><code>104  		if (buffer->isMonitoringOn())
105  		{
106  			tie.iImage = MONITORING_IMG_INDEX;
107  		}
108  		else if (buffer->isReadOnly())
109  		{
110  			tie.iImage = REDONLY_IMG_INDEX;
111  		}
</pre></code></div>
                <div class="column column_space"><pre><code>308      if (Ch==' '){
309        OutChA+='+';
310      } else
311      if ((' '<Ch)&&(Ch<='~')&&(Ch!='+')&&(Ch!='&')&&(Ch!='%')){
312        OutChA+=Ch;
313      } else {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    