
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 47, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-rpc.cpp</h3>
            <pre><code>1  #include <nano/boost/beast/core/flat_buffer.hpp>
2  #include <nano/boost/beast/http.hpp>
3  #include <nano/lib/rpcconfig.hpp>
4  #include <nano/lib/threading.hpp>
5  #include <nano/node/ipc/ipc_server.hpp>
6  #include <nano/node/json_handler.hpp>
7  #include <nano/node/node_rpc_config.hpp>
8  #include <nano/node/scheduler/buckets.hpp>
9  #include <nano/node/scheduler/component.hpp>
10  #include <nano/rpc/rpc.hpp>
11  #include <nano/rpc/rpc_request_processor.hpp>
12  #include <nano/rpc_test/common.hpp>
13  #include <nano/test_common/network.hpp>
14  #include <nano/test_common/system.hpp>
15  #include <nano/test_common/telemetry.hpp>
16  #include <nano/test_common/testutil.hpp>
17  #include <gtest/gtest.h>
18  #include <boost/property_tree/json_parser.hpp>
19  #include <algorithm>
20  #include <map>
21  #include <tuple>
22  #include <utility>
23  using namespace std::chrono_literals;
24  using namespace nano::test;
25  TEST (rpc, wrapped_task)
26  {
27  	nano::test::system system;
28  	auto & node = *add_ipc_enabled_node (system);
29  	nano::node_rpc_config node_rpc_config;
30  	std::atomic<bool> response (false);
31  	auto response_handler_l ([&response] (std::string const & response_a) {
32  		std::stringstream istream (response_a);
33  		boost::property_tree::ptree json_l;
34  		ASSERT_NO_THROW (boost::property_tree::read_json (istream, json_l));
35  		ASSERT_EQ (1, json_l.count ("error"));
36  		ASSERT_EQ ("Unable to parse JSON", json_l.get<std::string> ("error"));
37  		response = true;
38  	});
39  	auto handler_l (std::make_shared<nano::json_handler> (node, node_rpc_config, "", response_handler_l));
40  	auto task (handler_l->create_worker_task ([] (std::shared_ptr<nano::json_handler> const &) {
41  		throw std::runtime_error ("");
42  	}));
43  	system.nodes[0]->workers.push_task (task);
44  	ASSERT_TIMELY (5s, response == true);
45  }
46  TEST (rpc, account_balance)
47  {
48  	nano::test::system system;
49  	auto node = add_ipc_enabled_node (system);
50  	nano::state_block_builder builder;
51  	auto send1 = builder.make_block ()
52  				 .account (nano::dev::genesis_key.pub)
53  				 .previous (nano::dev::genesis->hash ())
54  				 .representative (nano::dev::genesis_key.pub)
55  				 .balance (nano::dev::constants.genesis_amount - 1)
56  				 .link (nano::dev::genesis_key.pub)
57  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
58  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
59  				 .build ();
60  	ASSERT_EQ (nano::process_result::progress, node->process (*send1).code);
61  	ASSERT_TIMELY (5s, !node->active.active (*send1));
62  	auto const rpc_ctx = add_rpc (system, node);
63  	boost::property_tree::ptree request;
64  	request.put ("action", "account_balance");
65  	request.put ("account", nano::dev::genesis_key.pub.to_account ());
66  	{
67  		auto response (wait_response (system, rpc_ctx, request));
68  		std::string balance_text (response.get<std::string> ("balance"));
69  		ASSERT_EQ ("340282366920938463463374607431768211455", balance_text);
70  		std::string pending_text (response.get<std::string> ("pending"));
71  		ASSERT_EQ ("0", pending_text);
72  	}
73  	request.put ("include_only_confirmed", false);
74  	{
75  		auto response (wait_response (system, rpc_ctx, request));
76  		std::string balance_text (response.get<std::string> ("balance"));
77  		ASSERT_EQ ("340282366920938463463374607431768211454", balance_text);
78  		std::string pending_text (response.get<std::string> ("pending"));
79  		ASSERT_EQ ("1", pending_text);
80  	}
81  }
82  TEST (rpc, account_block_count)
83  {
84  	nano::test::system system;
85  	auto node = add_ipc_enabled_node (system);
86  	auto const rpc_ctx = add_rpc (system, node);
87  	boost::property_tree::ptree request;
88  	request.put ("action", "account_block_count");
89  	request.put ("account", nano::dev::genesis_key.pub.to_account ());
90  	auto response (wait_response (system, rpc_ctx, request));
91  	std::string block_count_text (response.get<std::string> ("block_count"));
92  	ASSERT_EQ ("1", block_count_text);
93  }
94  TEST (rpc, account_create)
95  {
96  	nano::test::system system;
97  	auto node = add_ipc_enabled_node (system);
98  	auto const rpc_ctx = add_rpc (system, node);
99  	boost::property_tree::ptree request;
100  	request.put ("action", "account_create");
101  	request.put ("wallet", node->wallets.items.begin ()->first.to_string ());
102  	auto response0 (wait_response (system, rpc_ctx, request));
103  	auto account_text0 (response0.get<std::string> ("account"));
104  	nano::account account0;
105  	ASSERT_FALSE (account0.decode_account (account_text0));
106  	ASSERT_TRUE (system.wallet (0)->exists (account0));
107  	constexpr uint64_t max_index (std::numeric_limits<uint32_t>::max ());
108  	request.put ("index", max_index);
109  	auto response1 (wait_response (system, rpc_ctx, request, 10s));
110  	auto account_text1 (response1.get<std::string> ("account"));
111  	nano::account account1;
112  	ASSERT_FALSE (account1.decode_account (account_text1));
113  	ASSERT_TRUE (system.wallet (0)->exists (account1));
114  	request.put ("index", max_index + 1);
115  	auto response2 (wait_response (system, rpc_ctx, request));
116  	ASSERT_EQ (std::error_code (nano::error_common::invalid_index).message (), response2.get<std::string> ("error"));
117  }
118  TEST (rpc, account_weight)
119  {
120  	nano::keypair key;
121  	nano::test::system system;
122  	auto node1 = add_ipc_enabled_node (system);
123  	nano::block_hash latest (node1->latest (nano::dev::genesis_key.pub));
124  	nano::block_builder builder;
125  	auto block = builder
126  				 .change ()
127  				 .previous (latest)
128  				 .representative (key.pub)
129  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
130  				 .work (*node1->work_generate_blocking (latest))
131  				 .build ();
132  	ASSERT_EQ (nano::process_result::progress, node1->process (*block).code);
133  	auto const rpc_ctx = add_rpc (system, node1);
134  	boost::property_tree::ptree request;
135  	request.put ("action", "account_weight");
136  	request.put ("account", key.pub.to_account ());
137  	auto response (wait_response (system, rpc_ctx, request));
138  	std::string balance_text (response.get<std::string> ("weight"));
139  	ASSERT_EQ ("340282366920938463463374607431768211455", balance_text);
140  }
141  TEST (rpc, wallet_contains)
142  {
143  	nano::test::system system;
144  	auto node = add_ipc_enabled_node (system);
145  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
146  	auto const rpc_ctx = add_rpc (system, node);
147  	boost::property_tree::ptree request;
148  	std::string wallet;
149  	node->wallets.items.begin ()->first.encode_hex (wallet);
150  	request.put ("wallet", wallet);
151  	request.put ("action", "wallet_contains");
152  	request.put ("account", nano::dev::genesis_key.pub.to_account ());
153  	auto response (wait_response (system, rpc_ctx, request));
154  	std::string exists_text (response.get<std::string> ("exists"));
155  	ASSERT_EQ ("1", exists_text);
156  }
157  TEST (rpc, wallet_doesnt_contain)
158  {
159  	nano::test::system system;
160  	auto node = add_ipc_enabled_node (system);
161  	auto const rpc_ctx = add_rpc (system, node);
162  	boost::property_tree::ptree request;
163  	std::string wallet;
164  	node->wallets.items.begin ()->first.encode_hex (wallet);
165  	request.put ("wallet", wallet);
166  	request.put ("action", "wallet_contains");
167  	request.put ("account", nano::dev::genesis_key.pub.to_account ());
168  	auto response (wait_response (system, rpc_ctx, request));
169  	std::string exists_text (response.get<std::string> ("exists"));
170  	ASSERT_EQ ("0", exists_text);
171  }
172  TEST (rpc, validate_account_number)
173  {
174  	nano::test::system system;
175  	auto node = add_ipc_enabled_node (system);
176  	auto const rpc_ctx = add_rpc (system, node);
177  	boost::property_tree::ptree request;
178  	request.put ("action", "validate_account_number");
179  	request.put ("account", nano::dev::genesis_key.pub.to_account ());
180  	auto response (wait_response (system, rpc_ctx, request));
181  	std::string exists_text (response.get<std::string> ("valid"));
182  	ASSERT_EQ ("1", exists_text);
183  }
184  TEST (rpc, validate_account_invalid)
185  {
186  	nano::test::system system;
187  	auto node = add_ipc_enabled_node (system);
188  	auto const rpc_ctx = add_rpc (system, node);
189  	std::string account;
190  	nano::dev::genesis_key.pub.encode_account (account);
191  	account[0] ^= 0x1;
192  	boost::property_tree::ptree request;
193  	request.put ("action", "validate_account_number");
194  	request.put ("account", account);
195  	auto response (wait_response (system, rpc_ctx, request));
196  	std::string exists_text (response.get<std::string> ("valid"));
197  	ASSERT_EQ ("0", exists_text);
198  }
199  TEST (rpc, send)
200  {
201  	nano::test::system system;
202  	auto node = add_ipc_enabled_node (system);
203  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
204  	auto const rpc_ctx = add_rpc (system, node);
205  	boost::property_tree::ptree request;
206  	std::string wallet;
207  	node->wallets.items.begin ()->first.encode_hex (wallet);
208  	request.put ("wallet", wallet);
209  	request.put ("action", "send");
210  	request.put ("source", nano::dev::genesis_key.pub.to_account ());
211  	request.put ("destination", nano::dev::genesis_key.pub.to_account ());
212  	request.put ("amount", "100");
213  	ASSERT_EQ (node->balance (nano::dev::genesis_key.pub), nano::dev::constants.genesis_amount);
214  	auto response (wait_response (system, rpc_ctx, request, 10s));
215  	std::string block_text (response.get<std::string> ("block"));
216  	nano::block_hash block;
217  	ASSERT_FALSE (block.decode_hex (block_text));
218  	ASSERT_TRUE (node->ledger.block_or_pruned_exists (block));
219  	ASSERT_EQ (node->latest (nano::dev::genesis_key.pub), block);
220  	ASSERT_NE (node->balance (nano::dev::genesis_key.pub), nano::dev::constants.genesis_amount);
221  }
222  TEST (rpc, send_fail)
223  {
224  	nano::test::system system;
225  	auto node = add_ipc_enabled_node (system);
226  	auto const rpc_ctx = add_rpc (system, node);
227  	boost::property_tree::ptree request;
228  	std::string wallet;
229  	node->wallets.items.begin ()->first.encode_hex (wallet);
230  	request.put ("wallet", wallet);
231  	request.put ("action", "send");
232  	request.put ("source", nano::dev::genesis_key.pub.to_account ());
233  	request.put ("destination", nano::dev::genesis_key.pub.to_account ());
234  	request.put ("amount", "100");
235  	auto response (wait_response (system, rpc_ctx, request, 10s));
236  	ASSERT_EQ (std::error_code (nano::error_common::account_not_found_wallet).message (), response.get<std::string> ("error"));
237  }
238  TEST (rpc, send_work)
239  {
240  	nano::test::system system;
241  	auto node = add_ipc_enabled_node (system);
242  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
243  	auto const rpc_ctx = add_rpc (system, node);
244  	boost::property_tree::ptree request;
245  	std::string wallet;
246  	node->wallets.items.begin ()->first.encode_hex (wallet);
247  	request.put ("wallet", wallet);
248  	request.put ("action", "send");
249  	request.put ("source", nano::dev::genesis_key.pub.to_account ());
250  	request.put ("destination", nano::dev::genesis_key.pub.to_account ());
251  	request.put ("amount", "100");
252  	request.put ("work", "1");
253  	auto response (wait_response (system, rpc_ctx, request, 10s));
254  	ASSERT_EQ (std::error_code (nano::error_common::invalid_work).message (), response.get<std::string> ("error"));
255  	request.erase ("work");
256  	request.put ("work", nano::to_string_hex (*node->work_generate_blocking (node->latest (nano::dev::genesis_key.pub))));
257  	auto response2 (wait_response (system, rpc_ctx, request, 10s));
258  	std::string block_text (response2.get<std::string> ("block"));
259  	nano::block_hash block;
260  	ASSERT_FALSE (block.decode_hex (block_text));
261  	ASSERT_TRUE (node->ledger.block_or_pruned_exists (block));
262  	ASSERT_EQ (node->latest (nano::dev::genesis_key.pub), block);
263  }
264  TEST (rpc, send_work_disabled)
265  {
266  	nano::test::system system;
267  	nano::node_config node_config = system.default_config ();
268  	node_config.work_threads = 0;
269  	auto node = add_ipc_enabled_node (system, node_config);
270  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
271  	auto const rpc_ctx = add_rpc (system, node);
272  	boost::property_tree::ptree request;
273  	std::string wallet;
274  	node->wallets.items.begin ()->first.encode_hex (wallet);
275  	request.put ("wallet", wallet);
276  	request.put ("action", "send");
277  	request.put ("source", nano::dev::genesis_key.pub.to_account ());
278  	request.put ("destination", nano::dev::genesis_key.pub.to_account ());
279  	request.put ("amount", "100");
280  	auto response (wait_response (system, rpc_ctx, request, 10s));
281  	ASSERT_EQ (std::error_code (nano::error_common::disabled_work_generation).message (), response.get<std::string> ("error"));
282  }
283  TEST (rpc, send_idempotent)
284  {
285  	nano::test::system system;
286  	auto node = add_ipc_enabled_node (system);
287  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
288  	auto const rpc_ctx = add_rpc (system, node);
289  	boost::property_tree::ptree request;
290  	std::string wallet;
291  	node->wallets.items.begin ()->first.encode_hex (wallet);
292  	request.put ("wallet", wallet);
293  	request.put ("action", "send");
294  	request.put ("source", nano::dev::genesis_key.pub.to_account ());
295  	request.put ("destination", nano::account{}.to_account ());
296  	request.put ("amount", (nano::dev::constants.genesis_amount - (nano::dev::constants.genesis_amount / 4)).convert_to<std::string> ());
297  	request.put ("id", "123abc");
298  	auto response (wait_response (system, rpc_ctx, request));
299  	std::string block_text (response.get<std::string> ("block"));
300  	nano::block_hash block;
301  	ASSERT_FALSE (block.decode_hex (block_text));
302  	ASSERT_TRUE (node->ledger.block_or_pruned_exists (block));
303  	ASSERT_EQ (node->balance (nano::dev::genesis_key.pub), nano::dev::constants.genesis_amount / 4);
304  	auto response2 (wait_response (system, rpc_ctx, request));
305  	ASSERT_EQ ("", response2.get<std::string> ("error", ""));
306  	ASSERT_EQ (block_text, response2.get<std::string> ("block"));
307  	ASSERT_EQ (node->balance (nano::dev::genesis_key.pub), nano::dev::constants.genesis_amount / 4);
308  	request.erase ("id");
309  	request.put ("id", "456def");
310  	auto response3 (wait_response (system, rpc_ctx, request));
311  	ASSERT_EQ (std::error_code (nano::error_common::insufficient_balance).message (), response3.get<std::string> ("error"));
312  }
313  TEST (rpc, DISABLED_send_epoch_2)
314  {
315  	nano::test::system system;
316  	auto node = add_ipc_enabled_node (system);
317  	ASSERT_NE (nullptr, system.upgrade_genesis_epoch (*node, nano::epoch::epoch_1));
318  	ASSERT_NE (nullptr, system.upgrade_genesis_epoch (*node, nano::epoch::epoch_2));
319  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv, false);
320  	auto target_difficulty = nano::dev::network_params.work.threshold (nano::work_version::work_1, nano::block_details (nano::epoch::epoch_2, true, false, false));
321  	ASSERT_LT (node->network_params.work.entry, target_difficulty);
322  	auto min_difficulty = node->network_params.work.entry;
323  	auto const rpc_ctx = add_rpc (system, node);
324  	boost::property_tree::ptree request;
325  	std::string wallet;
326  	node->wallets.items.begin ()->first.encode_hex (wallet);
327  	request.put ("wallet", wallet);
328  	request.put ("action", "send");
329  	request.put ("source", nano::dev::genesis_key.pub.to_account ());
330  	request.put ("destination", nano::keypair ().pub.to_account ());
331  	request.put ("amount", "1");
332  	auto insufficient = system.work_generate_limited (nano::dev::genesis->hash (), min_difficulty, target_difficulty);
333  	request.put ("work", nano::to_string_hex (insufficient));
334  	{
335  		auto response (wait_response (system, rpc_ctx, request));
336  		std::error_code ec (nano::error_common::invalid_work);
337  		ASSERT_EQ (1, response.count ("error"));
338  		ASSERT_EQ (response.get<std::string> ("error"), ec.message ());
339  	}
340  }
341  TEST (rpc, send_ipc_random_id)
342  {
343  	nano::test::system system;
344  	auto node = add_ipc_enabled_node (system);
345  	auto const rpc_ctx = add_rpc (system, node);
346  	std::atomic<bool> got_request{ false };
347  	rpc_ctx.node_rpc_config->set_request_callback ([&got_request] (boost::property_tree::ptree const & request_a) {
348  		EXPECT_TRUE (request_a.count ("id"));
349  		got_request = true;
350  	});
351  	boost::property_tree::ptree request;
352  	request.put ("action", "send");
353  	auto response (wait_response (system, rpc_ctx, request, 10s));
354  	ASSERT_EQ (1, response.count ("error"));
355  	ASSERT_EQ ("Unable to parse JSON", response.get<std::string> ("error"));
356  	ASSERT_TRUE (got_request);
357  }
358  TEST (rpc, stop)
359  {
360  	nano::test::system system;
361  	auto node = add_ipc_enabled_node (system);
362  	auto const rpc_ctx = add_rpc (system, node);
363  	boost::property_tree::ptree request;
364  	request.put ("action", "stop");
365  	auto response (wait_response (system, rpc_ctx, request));
366  }
367  TEST (rpc, wallet_add)
368  {
369  	nano::test::system system;
370  	auto node = add_ipc_enabled_node (system);
371  	auto const rpc_ctx = add_rpc (system, node);
372  	nano::keypair key1;
373  	std::string key_text;
374  	key1.prv.encode_hex (key_text);
375  	boost::property_tree::ptree request;
376  	std::string wallet;
377  	node->wallets.items.begin ()->first.encode_hex (wallet);
378  	request.put ("wallet", wallet);
379  	request.put ("action", "wallet_add");
380  	request.put ("key", key_text);
381  	auto response (wait_response (system, rpc_ctx, request));
382  	std::string account_text1 (response.get<std::string> ("account"));
383  	ASSERT_EQ (account_text1, key1.pub.to_account ());
384  	ASSERT_TRUE (system.wallet (0)->exists (key1.pub));
385  }
386  TEST (rpc, wallet_password_valid)
387  {
388  	nano::test::system system;
389  	auto node = add_ipc_enabled_node (system);
390  	auto const rpc_ctx = add_rpc (system, node);
391  	boost::property_tree::ptree request;
392  	std::string wallet;
393  	node->wallets.items.begin ()->first.encode_hex (wallet);
394  	request.put ("wallet", wallet);
395  	request.put ("action", "password_valid");
396  	auto response (wait_response (system, rpc_ctx, request));
397  	std::string account_text1 (response.get<std::string> ("valid"));
398  	ASSERT_EQ (account_text1, "1");
399  }
400  TEST (rpc, wallet_password_change)
401  {
402  	nano::test::system system;
403  	auto node = add_ipc_enabled_node (system);
404  	auto const rpc_ctx = add_rpc (system, node);
405  	boost::property_tree::ptree request;
406  	std::string wallet;
407  	node->wallets.items.begin ()->first.encode_hex (wallet);
408  	request.put ("wallet", wallet);
409  	request.put ("action", "password_change");
410  	request.put ("password", "test");
411  	auto response (wait_response (system, rpc_ctx, request));
412  	std::string account_text1 (response.get<std::string> ("changed"));
413  	ASSERT_EQ (account_text1, "1");
414  	auto transaction (system.wallet (0)->wallets.tx_begin_write ());
415  	ASSERT_TRUE (system.wallet (0)->store.valid_password (transaction));
416  	ASSERT_TRUE (system.wallet (0)->enter_password (transaction, ""));
417  	ASSERT_FALSE (system.wallet (0)->store.valid_password (transaction));
418  	ASSERT_FALSE (system.wallet (0)->enter_password (transaction, "test"));
419  	ASSERT_TRUE (system.wallet (0)->store.valid_password (transaction));
420  }
421  TEST (rpc, wallet_password_enter)
422  {
423  	nano::test::system system;
424  	auto node = add_ipc_enabled_node (system);
425  	auto const rpc_ctx = add_rpc (system, node);
426  	nano::raw_key password_l;
427  	password_l.clear ();
428  	system.deadline_set (10s);
429  	while (password_l == 0)
430  	{
431  		ASSERT_NO_ERROR (system.poll ());
432  		system.wallet (0)->store.password.value (password_l);
433  	}
434  	boost::property_tree::ptree request;
435  	std::string wallet;
436  	node->wallets.items.begin ()->first.encode_hex (wallet);
437  	request.put ("wallet", wallet);
438  	request.put ("action", "password_enter");
439  	request.put ("password", "");
440  	auto response (wait_response (system, rpc_ctx, request));
441  	std::string account_text1 (response.get<std::string> ("valid"));
442  	ASSERT_EQ (account_text1, "1");
443  }
444  TEST (rpc, wallet_representative)
445  {
446  	nano::test::system system;
447  	auto node = add_ipc_enabled_node (system);
448  	auto const rpc_ctx = add_rpc (system, node);
449  	boost::property_tree::ptree request;
450  	std::string wallet;
451  	node->wallets.items.begin ()->first.encode_hex (wallet);
452  	request.put ("wallet", wallet);
453  	request.put ("action", "wallet_representative");
454  	auto response (wait_response (system, rpc_ctx, request));
455  	std::string account_text1 (response.get<std::string> ("representative"));
456  	ASSERT_EQ (account_text1, nano::dev::genesis->account ().to_account ());
457  }
458  TEST (rpc, wallet_representative_set)
459  {
460  	nano::test::system system;
461  	auto node = add_ipc_enabled_node (system);
462  	auto const rpc_ctx = add_rpc (system, node);
463  	boost::property_tree::ptree request;
464  	std::string wallet;
465  	node->wallets.items.begin ()->first.encode_hex (wallet);
466  	request.put ("wallet", wallet);
467  	nano::keypair key;
468  	request.put ("action", "wallet_representative_set");
469  	request.put ("representative", key.pub.to_account ());
470  	auto response (wait_response (system, rpc_ctx, request));
471  	auto transaction (node->wallets.tx_begin_read ());
472  	ASSERT_EQ (key.pub, node->wallets.items.begin ()->second->store.representative (transaction));
473  }
474  TEST (rpc, wallet_representative_set_force)
475  {
476  	nano::test::system system;
477  	auto node = add_ipc_enabled_node (system);
478  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
479  	auto const rpc_ctx = add_rpc (system, node);
480  	boost::property_tree::ptree request;
481  	std::string wallet;
482  	node->wallets.items.begin ()->first.encode_hex (wallet);
483  	request.put ("wallet", wallet);
484  	nano::keypair key;
485  	request.put ("action", "wallet_representative_set");
486  	request.put ("representative", key.pub.to_account ());
487  	request.put ("update_existing_accounts", true);
488  	auto response (wait_response (system, rpc_ctx, request));
489  	{
490  		auto transaction (node->wallets.tx_begin_read ());
491  		ASSERT_EQ (key.pub, node->wallets.items.begin ()->second->store.representative (transaction));
492  	}
493  	nano::account representative{};
494  	while (representative != key.pub)
495  	{
496  		auto transaction (node->store.tx_begin_read ());
497  		auto info = node->ledger.account_info (transaction, nano::dev::genesis_key.pub);
498  		if (info)
499  		{
500  			representative = info->representative;
501  		}
502  		ASSERT_NO_ERROR (system.poll ());
503  	}
504  }
505  TEST (rpc, account_list)
506  {
507  	nano::test::system system;
508  	auto node = add_ipc_enabled_node (system);
509  	nano::keypair key2;
510  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
511  	system.wallet (0)->insert_adhoc (key2.prv);
512  	auto const rpc_ctx = add_rpc (system, node);
513  	boost::property_tree::ptree request;
514  	std::string wallet;
515  	node->wallets.items.begin ()->first.encode_hex (wallet);
516  	request.put ("wallet", wallet);
517  	request.put ("action", "account_list");
518  	auto response (wait_response (system, rpc_ctx, request));
519  	auto & accounts_node (response.get_child ("accounts"));
520  	std::vector<nano::account> accounts;
521  	for (auto i (accounts_node.begin ()), j (accounts_node.end ()); i != j; ++i)
522  	{
523  		auto account (i->second.get<std::string> (""));
524  		nano::account number;
525  		ASSERT_FALSE (number.decode_account (account));
526  		accounts.push_back (number);
527  	}
528  	ASSERT_EQ (2, accounts.size ());
529  	for (auto i (accounts.begin ()), j (accounts.end ()); i != j; ++i)
530  	{
531  		ASSERT_TRUE (system.wallet (0)->exists (*i));
532  	}
533  }
534  TEST (rpc, wallet_key_valid)
535  {
536  	nano::test::system system;
537  	auto node = add_ipc_enabled_node (system);
538  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
539  	auto const rpc_ctx = add_rpc (system, node);
540  	boost::property_tree::ptree request;
541  	std::string wallet;
542  	node->wallets.items.begin ()->first.encode_hex (wallet);
543  	request.put ("wallet", wallet);
544  	request.put ("action", "wallet_key_valid");
545  	auto response (wait_response (system, rpc_ctx, request));
546  	std::string exists_text (response.get<std::string> ("valid"));
547  	ASSERT_EQ ("1", exists_text);
548  }
549  TEST (rpc, wallet_create)
550  {
551  	nano::test::system system;
552  	auto node = add_ipc_enabled_node (system);
553  	auto const rpc_ctx = add_rpc (system, node);
554  	boost::property_tree::ptree request;
555  	request.put ("action", "wallet_create");
556  	auto response (wait_response (system, rpc_ctx, request));
557  	std::string wallet_text (response.get<std::string> ("wallet"));
558  	nano::wallet_id wallet_id;
559  	ASSERT_FALSE (wallet_id.decode_hex (wallet_text));
560  	ASSERT_NE (node->wallets.items.end (), node->wallets.items.find (wallet_id));
561  }
562  TEST (rpc, wallet_create_seed)
563  {
564  	nano::test::system system;
565  	auto node = add_ipc_enabled_node (system);
566  	nano::raw_key seed;
567  	nano::random_pool::generate_block (seed.bytes.data (), seed.bytes.size ());
568  	auto prv = nano::deterministic_key (seed, 0);
569  	auto pub (nano::pub_key (prv));
570  	auto const rpc_ctx = add_rpc (system, node);
571  	boost::property_tree::ptree request;
572  	request.put ("action", "wallet_create");
573  	request.put ("seed", seed.to_string ());
574  	auto response (wait_response (system, rpc_ctx, request, 10s));
575  	std::string wallet_text (response.get<std::string> ("wallet"));
576  	nano::wallet_id wallet_id;
577  	ASSERT_FALSE (wallet_id.decode_hex (wallet_text));
578  	auto existing (node->wallets.items.find (wallet_id));
579  	ASSERT_NE (node->wallets.items.end (), existing);
580  	{
581  		auto transaction (node->wallets.tx_begin_read ());
582  		nano::raw_key seed0;
583  		existing->second->store.seed (seed0, transaction);
584  		ASSERT_EQ (seed, seed0);
585  	}
586  	auto account_text (response.get<std::string> ("last_restored_account"));
587  	nano::account account;
588  	ASSERT_FALSE (account.decode_account (account_text));
589  	ASSERT_TRUE (existing->second->exists (account));
590  	ASSERT_EQ (pub, account);
591  	ASSERT_EQ ("1", response.get<std::string> ("restored_count"));
592  }
593  TEST (rpc, wallet_export)
594  {
595  	nano::test::system system;
596  	auto node = add_ipc_enabled_node (system);
597  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
598  	auto const rpc_ctx = add_rpc (system, node);
599  	boost::property_tree::ptree request;
600  	request.put ("action", "wallet_export");
601  	request.put ("wallet", node->wallets.items.begin ()->first.to_string ());
602  	auto response (wait_response (system, rpc_ctx, request));
603  	std::string wallet_json (response.get<std::string> ("json"));
604  	bool error (false);
605  	auto transaction (node->wallets.tx_begin_write ());
606  	nano::kdf kdf{ nano::dev::network_params.kdf_work };
607  	nano::wallet_store store (error, kdf, transaction, nano::dev::genesis->account (), 1, "0", wallet_json);
608  	ASSERT_FALSE (error);
609  	ASSERT_TRUE (store.exists (transaction, nano::dev::genesis_key.pub));
610  }
611  TEST (rpc, wallet_destroy)
612  {
613  	nano::test::system system;
614  	auto node = add_ipc_enabled_node (system);
615  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
616  	auto const rpc_ctx = add_rpc (system, node);
617  	auto wallet_id (node->wallets.items.begin ()->first);
618  	boost::property_tree::ptree request;
619  	request.put ("action", "wallet_destroy");
620  	request.put ("wallet", wallet_id.to_string ());
621  	auto response (wait_response (system, rpc_ctx, request));
622  	ASSERT_EQ (node->wallets.items.end (), node->wallets.items.find (wallet_id));
623  }
624  TEST (rpc, account_move)
625  {
626  	nano::test::system system;
627  	auto node = add_ipc_enabled_node (system);
628  	auto wallet_id (node->wallets.items.begin ()->first);
629  	auto destination (system.wallet (0));
630  	destination->insert_adhoc (nano::dev::genesis_key.prv);
631  	nano::keypair key;
632  	auto source_id = nano::random_wallet_id ();
633  	auto source (node->wallets.create (source_id));
634  	source->insert_adhoc (key.prv);
635  	auto const rpc_ctx = add_rpc (system, node);
636  	boost::property_tree::ptree request;
637  	request.put ("action", "account_move");
638  	request.put ("wallet", wallet_id.to_string ());
639  	request.put ("source", source_id.to_string ());
640  	boost::property_tree::ptree keys;
641  	boost::property_tree::ptree entry;
642  	entry.put ("", key.pub.to_account ());
643  	keys.push_back (std::make_pair ("", entry));
644  	request.add_child ("accounts", keys);
645  	auto response (wait_response (system, rpc_ctx, request));
646  	ASSERT_EQ ("1", response.get<std::string> ("moved"));
647  	ASSERT_TRUE (destination->exists (key.pub));
648  	ASSERT_TRUE (destination->exists (nano::dev::genesis_key.pub));
649  	auto transaction (node->wallets.tx_begin_read ());
650  	ASSERT_EQ (source->store.end (), source->store.begin (transaction));
651  }
652  TEST (rpc, block)
653  {
654  	nano::test::system system;
655  	auto node = add_ipc_enabled_node (system);
656  	auto const rpc_ctx = add_rpc (system, node);
657  	boost::property_tree::ptree request;
658  	request.put ("action", "block");
659  	request.put ("hash", node->latest (nano::dev::genesis->account ()).to_string ());
660  	auto response (wait_response (system, rpc_ctx, request));
661  	auto contents (response.get<std::string> ("contents"));
662  	ASSERT_FALSE (contents.empty ());
663  	ASSERT_TRUE (response.get<bool> ("confirmed")); 
664  }
665  TEST (rpc, block_account)
666  {
667  	nano::test::system system;
668  	auto node = add_ipc_enabled_node (system);
669  	auto const rpc_ctx = add_rpc (system, node);
670  	boost::property_tree::ptree request;
671  	request.put ("action", "block_account");
672  	request.put ("hash", nano::dev::genesis->hash ().to_string ());
673  	auto response (wait_response (system, rpc_ctx, request));
674  	std::string account_text (response.get<std::string> ("account"));
675  	nano::account account;
676  	ASSERT_FALSE (account.decode_account (account_text));
677  }
678  TEST (rpc, chain)
679  {
680  	nano::test::system system;
681  	auto node = add_ipc_enabled_node (system);
682  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
683  	nano::keypair key;
684  	auto genesis (node->latest (nano::dev::genesis_key.pub));
685  	ASSERT_FALSE (genesis.is_zero ());
686  	auto block (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key.pub, 1));
687  	ASSERT_NE (nullptr, block);
688  	auto const rpc_ctx = add_rpc (system, node);
689  	boost::property_tree::ptree request;
690  	request.put ("action", "chain");
691  	request.put ("block", block->hash ().to_string ());
692  	request.put ("count", std::to_string (std::numeric_limits<uint64_t>::max ()));
693  	auto response (wait_response (system, rpc_ctx, request));
694  	auto & blocks_node (response.get_child ("blocks"));
695  	std::vector<nano::block_hash> blocks;
696  	for (auto i (blocks_node.begin ()), n (blocks_node.end ()); i != n; ++i)
697  	{
698  		blocks.push_back (nano::block_hash (i->second.get<std::string> ("")));
699  	}
700  	ASSERT_EQ (2, blocks.size ());
701  	ASSERT_EQ (block->hash (), blocks[0]);
702  	ASSERT_EQ (genesis, blocks[1]);
703  }
704  TEST (rpc, chain_limit)
705  {
706  	nano::test::system system;
707  	auto node = add_ipc_enabled_node (system);
708  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
709  	nano::keypair key;
710  	auto genesis (node->latest (nano::dev::genesis_key.pub));
711  	ASSERT_FALSE (genesis.is_zero ());
712  	auto block (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key.pub, 1));
713  	ASSERT_NE (nullptr, block);
714  	auto const rpc_ctx = add_rpc (system, node);
715  	boost::property_tree::ptree request;
716  	request.put ("action", "chain");
717  	request.put ("block", block->hash ().to_string ());
718  	request.put ("count", 1);
719  	auto response (wait_response (system, rpc_ctx, request));
720  	auto & blocks_node (response.get_child ("blocks"));
721  	std::vector<nano::block_hash> blocks;
722  	for (auto i (blocks_node.begin ()), n (blocks_node.end ()); i != n; ++i)
723  	{
724  		blocks.push_back (nano::block_hash (i->second.get<std::string> ("")));
725  	}
726  	ASSERT_EQ (1, blocks.size ());
727  	ASSERT_EQ (block->hash (), blocks[0]);
728  }
729  TEST (rpc, chain_offset)
730  {
731  	nano::test::system system;
732  	auto node = add_ipc_enabled_node (system);
733  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
734  	nano::keypair key;
735  	auto genesis (node->latest (nano::dev::genesis_key.pub));
736  	ASSERT_FALSE (genesis.is_zero ());
737  	auto block (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key.pub, 1));
738  	ASSERT_NE (nullptr, block);
739  	auto const rpc_ctx = add_rpc (system, node);
740  	boost::property_tree::ptree request;
741  	request.put ("action", "chain");
742  	request.put ("block", block->hash ().to_string ());
743  	request.put ("count", std::to_string (std::numeric_limits<uint64_t>::max ()));
744  	request.put ("offset", 1);
745  	auto response (wait_response (system, rpc_ctx, request));
746  	auto & blocks_node (response.get_child ("blocks"));
747  	std::vector<nano::block_hash> blocks;
748  	for (auto i (blocks_node.begin ()), n (blocks_node.end ()); i != n; ++i)
749  	{
750  		blocks.push_back (nano::block_hash (i->second.get<std::string> ("")));
751  	}
752  	ASSERT_EQ (1, blocks.size ());
753  	ASSERT_EQ (genesis, blocks[0]);
754  }
755  TEST (rpc, frontier)
756  {
757  	nano::test::system system;
758  	auto node = add_ipc_enabled_node (system);
759  	std::unordered_map<nano::account, nano::block_hash> source;
760  	{
761  		auto transaction (node->store.tx_begin_write ());
762  		for (auto i (0); i < 1000; ++i)
763  		{
764  			nano::keypair key;
765  			nano::block_hash hash;
766  			nano::random_pool::generate_block (hash.bytes.data (), hash.bytes.size ());
767  			source[key.pub] = hash;
768  			node->store.confirmation_height.put (transaction, key.pub, { 0, nano::block_hash (0) });
769  			node->store.account.put (transaction, key.pub, nano::account_info (hash, 0, 0, 0, 0, 0, nano::epoch::epoch_0));
770  		}
771  	}
772  	nano::keypair key;
773  	auto const rpc_ctx = add_rpc (system, node);
774  	boost::property_tree::ptree request;
775  	request.put ("action", "frontiers");
776  	request.put ("account", nano::account{}.to_account ());
777  	request.put ("count", std::to_string (std::numeric_limits<uint64_t>::max ()));
778  	auto response (wait_response (system, rpc_ctx, request));
779  	auto & frontiers_node (response.get_child ("frontiers"));
780  	std::unordered_map<nano::account, nano::block_hash> frontiers;
781  	for (auto i (frontiers_node.begin ()), j (frontiers_node.end ()); i != j; ++i)
782  	{
783  		nano::account account;
784  		account.decode_account (i->first);
785  		nano::block_hash frontier;
786  		frontier.decode_hex (i->second.get<std::string> (""));
787  		frontiers[account] = frontier;
788  	}
789  	ASSERT_EQ (1, frontiers.erase (nano::dev::genesis_key.pub));
790  	ASSERT_EQ (source, frontiers);
791  }
792  TEST (rpc, frontier_limited)
793  {
794  	nano::test::system system;
795  	auto node = add_ipc_enabled_node (system);
796  	std::unordered_map<nano::account, nano::block_hash> source;
797  	{
798  		auto transaction (node->store.tx_begin_write ());
799  		for (auto i (0); i < 1000; ++i)
800  		{
801  			nano::keypair key;
802  			nano::block_hash hash;
803  			nano::random_pool::generate_block (hash.bytes.data (), hash.bytes.size ());
804  			source[key.pub] = hash;
805  			node->store.confirmation_height.put (transaction, key.pub, { 0, nano::block_hash (0) });
806  			node->store.account.put (transaction, key.pub, nano::account_info (hash, 0, 0, 0, 0, 0, nano::epoch::epoch_0));
807  		}
808  	}
809  	nano::keypair key;
810  	auto const rpc_ctx = add_rpc (system, node);
811  	boost::property_tree::ptree request;
812  	request.put ("action", "frontiers");
813  	request.put ("account", nano::account{}.to_account ());
814  	request.put ("count", std::to_string (100));
815  	auto response (wait_response (system, rpc_ctx, request));
816  	auto & frontiers_node (response.get_child ("frontiers"));
817  	ASSERT_EQ (100, frontiers_node.size ());
818  }
819  TEST (rpc, frontier_startpoint)
820  {
821  	nano::test::system system;
822  	auto node = add_ipc_enabled_node (system);
823  	std::unordered_map<nano::account, nano::block_hash> source;
824  	{
825  		auto transaction (node->store.tx_begin_write ());
826  		for (auto i (0); i < 1000; ++i)
827  		{
828  			nano::keypair key;
829  			nano::block_hash hash;
830  			nano::random_pool::generate_block (hash.bytes.data (), hash.bytes.size ());
831  			source[key.pub] = hash;
832  			node->store.confirmation_height.put (transaction, key.pub, { 0, nano::block_hash (0) });
833  			node->store.account.put (transaction, key.pub, nano::account_info (hash, 0, 0, 0, 0, 0, nano::epoch::epoch_0));
834  		}
835  	}
836  	nano::keypair key;
837  	auto const rpc_ctx = add_rpc (system, node);
838  	boost::property_tree::ptree request;
839  	request.put ("action", "frontiers");
840  	request.put ("account", source.begin ()->first.to_account ());
841  	request.put ("count", std::to_string (1));
842  	auto response (wait_response (system, rpc_ctx, request));
843  	auto & frontiers_node (response.get_child ("frontiers"));
844  	ASSERT_EQ (1, frontiers_node.size ());
845  	ASSERT_EQ (source.begin ()->first.to_account (), frontiers_node.begin ()->first);
846  }
847  TEST (rpc, history)
848  {
849  	nano::test::system system;
850  	auto node0 = add_ipc_enabled_node (system);
851  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
852  	auto change (system.wallet (0)->change_action (nano::dev::genesis_key.pub, nano::dev::genesis_key.pub));
853  	ASSERT_NE (nullptr, change);
854  	auto send (system.wallet (0)->send_action (nano::dev::genesis_key.pub, nano::dev::genesis_key.pub, node0->config.receive_minimum.number ()));
855  	ASSERT_NE (nullptr, send);
856  	auto receive (system.wallet (0)->receive_action (send->hash (), nano::dev::genesis_key.pub, node0->config.receive_minimum.number (), send->link ().as_account ()));
857  	ASSERT_NE (nullptr, receive);
858  	nano::block_builder builder;
859  	auto usend = builder
860  				 .state ()
861  				 .account (nano::dev::genesis->account ())
862  				 .previous (node0->latest (nano::dev::genesis->account ()))
863  				 .representative (nano::dev::genesis->account ())
864  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
865  				 .link (nano::dev::genesis->account ())
866  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
867  				 .work (*node0->work_generate_blocking (node0->latest (nano::dev::genesis->account ())))
868  				 .build ();
869  	auto ureceive = builder
870  					.state ()
871  					.account (nano::dev::genesis->account ())
872  					.previous (usend->hash ())
873  					.representative (nano::dev::genesis->account ())
874  					.balance (nano::dev::constants.genesis_amount)
875  					.link (usend->hash ())
876  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
877  					.work (*node0->work_generate_blocking (usend->hash ()))
878  					.build ();
879  	auto uchange = builder
880  				   .state ()
881  				   .account (nano::dev::genesis->account ())
882  				   .previous (ureceive->hash ())
883  				   .representative (nano::keypair ().pub)
884  				   .balance (nano::dev::constants.genesis_amount)
885  				   .link (0)
886  				   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
887  				   .work (*node0->work_generate_blocking (ureceive->hash ()))
888  				   .build ();
889  	{
890  		auto transaction (node0->store.tx_begin_write ());
891  		ASSERT_EQ (nano::process_result::progress, node0->ledger.process (transaction, *usend).code);
892  		ASSERT_EQ (nano::process_result::progress, node0->ledger.process (transaction, *ureceive).code);
893  		ASSERT_EQ (nano::process_result::progress, node0->ledger.process (transaction, *uchange).code);
894  	}
895  	auto const rpc_ctx = add_rpc (system, node0);
896  	boost::property_tree::ptree request;
897  	request.put ("action", "history");
898  	request.put ("hash", uchange->hash ().to_string ());
899  	request.put ("count", 100);
900  	auto response (wait_response (system, rpc_ctx, request));
901  	std::vector<std::tuple<std::string, std::string, std::string, std::string>> history_l;
902  	auto & history_node (response.get_child ("history"));
903  	for (auto i (history_node.begin ()), n (history_node.end ()); i != n; ++i)
904  	{
905  		history_l.push_back (std::make_tuple (i->second.get<std::string> ("type"), i->second.get<std::string> ("account"), i->second.get<std::string> ("amount"), i->second.get<std::string> ("hash")));
906  	}
907  	ASSERT_EQ (5, history_l.size ());
908  	ASSERT_EQ ("receive", std::get<0> (history_l[0]));
909  	ASSERT_EQ (ureceive->hash ().to_string (), std::get<3> (history_l[0]));
910  	ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), std::get<1> (history_l[0]));
911  	ASSERT_EQ (nano::Gxrb_ratio.convert_to<std::string> (), std::get<2> (history_l[0]));
912  	ASSERT_EQ (5, history_l.size ());
913  	ASSERT_EQ ("send", std::get<0> (history_l[1]));
914  	ASSERT_EQ (usend->hash ().to_string (), std::get<3> (history_l[1]));
915  	ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), std::get<1> (history_l[1]));
916  	ASSERT_EQ (nano::Gxrb_ratio.convert_to<std::string> (), std::get<2> (history_l[1]));
917  	ASSERT_EQ ("receive", std::get<0> (history_l[2]));
918  	ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), std::get<1> (history_l[2]));
919  	ASSERT_EQ (node0->config.receive_minimum.to_string_dec (), std::get<2> (history_l[2]));
920  	ASSERT_EQ (receive->hash ().to_string (), std::get<3> (history_l[2]));
921  	ASSERT_EQ ("send", std::get<0> (history_l[3]));
922  	ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), std::get<1> (history_l[3]));
923  	ASSERT_EQ (node0->config.receive_minimum.to_string_dec (), std::get<2> (history_l[3]));
924  	ASSERT_EQ (send->hash ().to_string (), std::get<3> (history_l[3]));
925  	ASSERT_EQ ("receive", std::get<0> (history_l[4]));
926  	ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), std::get<1> (history_l[4]));
927  	ASSERT_EQ (nano::dev::constants.genesis_amount.convert_to<std::string> (), std::get<2> (history_l[4]));
928  	ASSERT_EQ (nano::dev::genesis->hash ().to_string (), std::get<3> (history_l[4]));
929  }
930  TEST (rpc, account_history)
931  {
932  	nano::test::system system;
933  	auto node0 = add_ipc_enabled_node (system);
934  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
935  	auto change (system.wallet (0)->change_action (nano::dev::genesis_key.pub, nano::dev::genesis_key.pub));
936  	ASSERT_NE (nullptr, change);
937  	auto send (system.wallet (0)->send_action (nano::dev::genesis_key.pub, nano::dev::genesis_key.pub, node0->config.receive_minimum.number ()));
938  	ASSERT_NE (nullptr, send);
939  	auto receive (system.wallet (0)->receive_action (send->hash (), nano::dev::genesis_key.pub, node0->config.receive_minimum.number (), send->link ().as_account ()));
940  	ASSERT_NE (nullptr, receive);
941  	nano::block_builder builder;
942  	auto usend = builder
943  				 .state ()
944  				 .account (nano::dev::genesis->account ())
945  				 .previous (node0->latest (nano::dev::genesis->account ()))
946  				 .representative (nano::dev::genesis->account ())
947  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
948  				 .link (nano::dev::genesis->account ())
949  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
950  				 .work (*node0->work_generate_blocking (node0->latest (nano::dev::genesis->account ())))
951  				 .build ();
952  	auto ureceive = builder
953  					.state ()
954  					.account (nano::dev::genesis->account ())
955  					.previous (usend->hash ())
956  					.representative (nano::dev::genesis->account ())
957  					.balance (nano::dev::constants.genesis_amount)
958  					.link (usend->hash ())
959  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
960  					.work (*node0->work_generate_blocking (usend->hash ()))
961  					.build ();
962  	auto uchange = builder
963  				   .state ()
964  				   .account (nano::dev::genesis->account ())
965  				   .previous (ureceive->hash ())
966  				   .representative (nano::keypair ().pub)
967  				   .balance (nano::dev::constants.genesis_amount)
968  				   .link (0)
969  				   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
970  				   .work (*node0->work_generate_blocking (ureceive->hash ()))
971  				   .build ();
972  	{
973  		auto transaction (node0->store.tx_begin_write ());
974  		ASSERT_EQ (nano::process_result::progress, node0->ledger.process (transaction, *usend).code);
975  		ASSERT_EQ (nano::process_result::progress, node0->ledger.process (transaction, *ureceive).code);
976  		ASSERT_EQ (nano::process_result::progress, node0->ledger.process (transaction, *uchange).code);
977  	}
978  	auto const rpc_ctx = add_rpc (system, node0);
979  	{
980  		boost::property_tree::ptree request;
981  		request.put ("action", "account_history");
982  		request.put ("account", nano::dev::genesis->account ().to_account ());
983  		request.put ("count", 100);
984  		auto response (wait_response (system, rpc_ctx, request, 10s));
985  		std::vector<std::tuple<std::string, std::string, std::string, std::string, std::string, bool>> history_l;
986  		auto & history_node (response.get_child ("history"));
987  		for (auto i (history_node.begin ()), n (history_node.end ()); i != n; ++i)
988  		{
989  			history_l.push_back (std::make_tuple (i->second.get<std::string> ("type"), i->second.get<std::string> ("account"), i->second.get<std::string> ("amount"), i->second.get<std::string> ("hash"), i->second.get<std::string> ("height"), i->second.get<bool> ("confirmed")));
990  		}
991  		ASSERT_EQ (5, history_l.size ());
992  		ASSERT_EQ ("receive", std::get<0> (history_l[0]));
993  		ASSERT_EQ (ureceive->hash ().to_string (), std::get<3> (history_l[0]));
994  		ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), std::get<1> (history_l[0]));
995  		ASSERT_EQ (nano::Gxrb_ratio.convert_to<std::string> (), std::get<2> (history_l[0]));
996  		ASSERT_EQ ("6", std::get<4> (history_l[0])); 
997  		ASSERT_FALSE (std::get<5> (history_l[0]));
998  		ASSERT_EQ ("send", std::get<0> (history_l[1]));
999  		ASSERT_EQ (usend->hash ().to_string (), std::get<3> (history_l[1]));
1000  		ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), std::get<1> (history_l[1]));
1001  		ASSERT_EQ (nano::Gxrb_ratio.convert_to<std::string> (), std::get<2> (history_l[1]));
1002  		ASSERT_EQ ("5", std::get<4> (history_l[1]));
1003  		ASSERT_FALSE (std::get<5> (history_l[1]));
1004  		ASSERT_EQ ("receive", std::get<0> (history_l[2]));
1005  		ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), std::get<1> (history_l[2]));
1006  		ASSERT_EQ (node0->config.receive_minimum.to_string_dec (), std::get<2> (history_l[2]));
1007  		ASSERT_EQ (receive->hash ().to_string (), std::get<3> (history_l[2]));
1008  		ASSERT_EQ ("4", std::get<4> (history_l[2]));
1009  		ASSERT_FALSE (std::get<5> (history_l[2]));
1010  		ASSERT_EQ ("send", std::get<0> (history_l[3]));
1011  		ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), std::get<1> (history_l[3]));
1012  		ASSERT_EQ (node0->config.receive_minimum.to_string_dec (), std::get<2> (history_l[3]));
1013  		ASSERT_EQ (send->hash ().to_string (), std::get<3> (history_l[3]));
1014  		ASSERT_EQ ("3", std::get<4> (history_l[3]));
1015  		ASSERT_FALSE (std::get<5> (history_l[3]));
1016  		ASSERT_EQ ("receive", std::get<0> (history_l[4]));
1017  		ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), std::get<1> (history_l[4]));
1018  		ASSERT_EQ (nano::dev::constants.genesis_amount.convert_to<std::string> (), std::get<2> (history_l[4]));
1019  		ASSERT_EQ (nano::dev::genesis->hash ().to_string (), std::get<3> (history_l[4]));
1020  		ASSERT_EQ ("1", std::get<4> (history_l[4])); 
1021  		ASSERT_TRUE (std::get<5> (history_l[4]));
1022  	}
1023  	{
1024  		boost::property_tree::ptree request;
1025  		request.put ("action", "account_history");
1026  		request.put ("account", nano::dev::genesis->account ().to_account ());
1027  		request.put ("reverse", true);
1028  		request.put ("count", 1);
1029  		auto response (wait_response (system, rpc_ctx, request, 10s));
1030  		auto & history_node (response.get_child ("history"));
1031  		ASSERT_EQ (1, history_node.size ());
1032  		ASSERT_EQ ("1", history_node.begin ()->second.get<std::string> ("height"));
1033  		ASSERT_EQ (change->hash ().to_string (), response.get<std::string> ("next"));
1034  	}
1035  	auto account2 (system.wallet (0)->deterministic_insert ());
1036  	auto send2 (system.wallet (0)->send_action (nano::dev::genesis_key.pub, account2, node0->config.receive_minimum.number ()));
1037  	ASSERT_NE (nullptr, send2);
1038  	auto receive2 (system.wallet (0)->receive_action (send2->hash (), account2, node0->config.receive_minimum.number (), send2->link ().as_account ()));
1039  	ASSERT_NE (nullptr, receive2);
1040  	{
1041  		boost::property_tree::ptree request;
1042  		request.put ("action", "account_history");
1043  		request.put ("account", nano::dev::genesis_key.pub.to_account ());
1044  		boost::property_tree::ptree other_account;
1045  		other_account.put ("", account2.to_account ());
1046  		boost::property_tree::ptree filtered_accounts;
1047  		filtered_accounts.push_back (std::make_pair ("", other_account));
1048  		request.add_child ("account_filter", filtered_accounts);
1049  		request.put ("count", 100);
1050  		auto response (wait_response (system, rpc_ctx, request));
1051  		auto history_node (response.get_child ("history"));
1052  		ASSERT_EQ (history_node.size (), 2);
1053  	}
1054  	{
1055  		boost::property_tree::ptree request;
1056  		request.put ("action", "account_history");
1057  		request.put ("account", account2.to_account ());
1058  		boost::property_tree::ptree other_account;
1059  		other_account.put ("", nano::dev::genesis_key.pub.to_account ());
1060  		boost::property_tree::ptree filtered_accounts;
1061  		filtered_accounts.push_back (std::make_pair ("", other_account));
1062  		request.add_child ("account_filter", filtered_accounts);
1063  		request.put ("count", 100);
1064  		auto response (wait_response (system, rpc_ctx, request));
1065  		auto history_node (response.get_child ("history"));
1066  		ASSERT_EQ (history_node.size (), 1);
1067  	}
1068  }
1069  TEST (rpc, history_count)
1070  {
1071  	nano::test::system system;
1072  	auto node = add_ipc_enabled_node (system);
1073  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
1074  	auto change (system.wallet (0)->change_action (nano::dev::genesis_key.pub, nano::dev::genesis_key.pub));
1075  	ASSERT_NE (nullptr, change);
1076  	auto send (system.wallet (0)->send_action (nano::dev::genesis_key.pub, nano::dev::genesis_key.pub, node->config.receive_minimum.number ()));
1077  	ASSERT_NE (nullptr, send);
1078  	auto receive (system.wallet (0)->receive_action (send->hash (), nano::dev::genesis_key.pub, node->config.receive_minimum.number (), send->link ().as_account ()));
1079  	ASSERT_NE (nullptr, receive);
1080  	auto const rpc_ctx = add_rpc (system, node);
1081  	boost::property_tree::ptree request;
1082  	request.put ("action", "history");
1083  	request.put ("hash", receive->hash ().to_string ());
1084  	request.put ("count", 1);
1085  	auto response (wait_response (system, rpc_ctx, request));
1086  	auto & history_node (response.get_child ("history"));
1087  	ASSERT_EQ (1, history_node.size ());
1088  }
1089  TEST (rpc, history_pruning)
1090  {
1091  	nano::test::system system;
1092  	nano::node_config node_config = system.default_config ();
1093  	node_config.enable_voting = false; 
1094  	nano::node_flags node_flags;
1095  	node_flags.enable_pruning = true;
1096  	auto node0 = add_ipc_enabled_node (system, node_config, node_flags);
1097  	std::vector<std::shared_ptr<nano::block>> blocks;
1098  	nano::block_builder builder;
1099  	auto change = builder
1100  				  .change ()
1101  				  .previous (nano::dev::genesis->hash ())
1102  				  .representative (nano::dev::genesis_key.pub)
1103  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1104  				  .work (*node0->work.generate (nano::dev::genesis->hash ()))
1105  				  .build_shared ();
1106  	blocks.push_back (change);
1107  	auto send = builder
1108  				.send ()
1109  				.previous (change->hash ())
1110  				.destination (nano::dev::genesis_key.pub)
1111  				.balance (nano::dev::constants.genesis_amount - node0->config.receive_minimum.number ())
1112  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1113  				.work (*node0->work.generate (change->hash ()))
1114  				.build_shared ();
1115  	blocks.push_back (send);
1116  	auto receive = builder
1117  				   .receive ()
1118  				   .previous (send->hash ())
1119  				   .source (send->hash ())
1120  				   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1121  				   .work (*node0->work.generate (send->hash ()))
1122  				   .build_shared ();
1123  	blocks.push_back (receive);
1124  	auto usend = builder
1125  				 .state ()
1126  				 .account (nano::dev::genesis->account ())
1127  				 .previous (receive->hash ())
1128  				 .representative (nano::dev::genesis->account ())
1129  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
1130  				 .link (nano::dev::genesis->account ())
1131  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1132  				 .work (*node0->work_generate_blocking (receive->hash ()))
1133  				 .build_shared ();
1134  	blocks.push_back (usend);
1135  	auto ureceive = builder
1136  					.state ()
1137  					.account (nano::dev::genesis->account ())
1138  					.previous (usend->hash ())
1139  					.representative (nano::dev::genesis->account ())
1140  					.balance (nano::dev::constants.genesis_amount)
1141  					.link (usend->hash ())
1142  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1143  					.work (*node0->work_generate_blocking (usend->hash ()))
1144  					.build_shared ();
1145  	blocks.push_back (ureceive);
1146  	auto uchange = builder
1147  				   .state ()
1148  				   .account (nano::dev::genesis->account ())
1149  				   .previous (ureceive->hash ())
1150  				   .representative (nano::keypair ().pub)
1151  				   .balance (nano::dev::constants.genesis_amount)
1152  				   .link (0)
1153  				   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1154  				   .work (*node0->work_generate_blocking (ureceive->hash ()))
1155  				   .build_shared ();
1156  	blocks.push_back (uchange);
1157  	nano::test::process_live (*node0, blocks);
1158  	ASSERT_TIMELY (5s, nano::test::exists (*node0, blocks));
1159  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
1160  	ASSERT_TIMELY (5s, nano::test::confirm (*node0, blocks));
1161  	ASSERT_TIMELY (5s, node0->block_confirmed (uchange->hash ()));
1162  	nano::confirmation_height_info confirmation_height_info;
1163  	node0->store.confirmation_height.get (node0->store.tx_begin_read (), nano::dev::genesis_key.pub, confirmation_height_info);
1164  	ASSERT_EQ (7, confirmation_height_info.height);
1165  	{
1166  		auto transaction (node0->store.tx_begin_write ());
1167  		ASSERT_EQ (1, node0->ledger.pruning_action (transaction, change->hash (), 1));
1168  	}
1169  	auto const rpc_ctx = add_rpc (system, node0);
1170  	boost::property_tree::ptree request;
1171  	request.put ("action", "history");
1172  	request.put ("hash", send->hash ().to_string ());
1173  	request.put ("count", 100);
1174  	auto response = wait_response (system, rpc_ctx, request);
1175  	auto history_node = response.get_child ("history");
1176  	ASSERT_EQ (history_node.size (), 1);
1177  	auto entry = (*history_node.begin ()).second;
1178  	ASSERT_EQ ("send", entry.get<std::string> ("type"));
1179  	ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), entry.get<std::string> ("account", "N/A"));
1180  	ASSERT_EQ ("N/A", entry.get<std::string> ("amount", "N/A"));
1181  	ASSERT_EQ (send->hash ().to_string (), entry.get<std::string> ("hash"));
1182  	{
1183  		auto transaction (node0->store.tx_begin_write ());
1184  		ASSERT_EQ (1, node0->ledger.pruning_action (transaction, send->hash (), 1));
1185  	}
1186  	boost::property_tree::ptree request2;
1187  	request2.put ("action", "history");
1188  	request2.put ("hash", receive->hash ().to_string ());
1189  	request2.put ("count", 100);
1190  	response = wait_response (system, rpc_ctx, request2);
1191  	history_node = response.get_child ("history");
1192  	ASSERT_EQ (history_node.size (), 1);
1193  	entry = (*history_node.begin ()).second;
1194  	ASSERT_EQ ("receive", entry.get<std::string> ("type"));
1195  	ASSERT_EQ ("N/A", entry.get<std::string> ("account", "N/A"));
1196  	ASSERT_EQ ("N/A", entry.get<std::string> ("amount", "N/A"));
1197  	ASSERT_EQ (receive->hash ().to_string (), entry.get<std::string> ("hash"));
1198  	{
1199  		auto transaction (node0->store.tx_begin_write ());
1200  		ASSERT_EQ (1, node0->ledger.pruning_action (transaction, receive->hash (), 1));
1201  	}
1202  	boost::property_tree::ptree request3;
1203  	request3.put ("action", "history");
1204  	request3.put ("hash", uchange->hash ().to_string ());
1205  	request3.put ("count", 100);
1206  	response = wait_response (system, rpc_ctx, request3);
1207  	history_node = response.get_child ("history");
1208  	ASSERT_EQ (history_node.size (), 2);
1209  	entry = (*history_node.begin ()).second;
1210  	ASSERT_EQ ("receive", entry.get<std::string> ("type"));
1211  	ASSERT_EQ (ureceive->hash ().to_string (), entry.get<std::string> ("hash"));
1212  	ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), entry.get<std::string> ("account", "N/A"));
1213  	ASSERT_EQ (nano::Gxrb_ratio.convert_to<std::string> (), entry.get<std::string> ("amount", "N/A"));
1214  	entry = (*(++history_node.begin ())).second;
1215  	ASSERT_EQ ("unknown", entry.get<std::string> ("type"));
1216  	ASSERT_EQ ("N/A", entry.get<std::string> ("account", "N/A"));
1217  	ASSERT_EQ ("N/A", entry.get<std::string> ("amount", "N/A"));
1218  	ASSERT_EQ (usend->hash ().to_string (), entry.get<std::string> ("hash"));
1219  }
1220  TEST (rpc, process_block)
1221  {
1222  	nano::test::system system;
1223  	auto node1 = add_ipc_enabled_node (system);
1224  	auto const rpc_ctx = add_rpc (system, node1);
1225  	nano::keypair key;
1226  	auto latest (node1->latest (nano::dev::genesis_key.pub));
1227  	nano::block_builder builder;
1228  	auto send = builder
1229  				.send ()
1230  				.previous (latest)
1231  				.destination (key.pub)
1232  				.balance (100)
1233  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1234  				.work (*node1->work_generate_blocking (latest))
1235  				.build ();
1236  	boost::property_tree::ptree request;
1237  	request.put ("action", "process");
1238  	std::string json;
1239  	send->serialize_json (json);
1240  	request.put ("block", json);
1241  	{
1242  		auto response (wait_response (system, rpc_ctx, request));
1243  		ASSERT_TIMELY (10s, node1->latest (nano::dev::genesis_key.pub) == send->hash ());
1244  		std::string send_hash (response.get<std::string> ("hash"));
1245  		ASSERT_EQ (send->hash ().to_string (), send_hash);
1246  	}
1247  	request.put ("json_block", true);
1248  	{
1249  		auto response (wait_response (system, rpc_ctx, request));
1250  		std::error_code ec (nano::error_blocks::invalid_block);
1251  		ASSERT_EQ (ec.message (), response.get<std::string> ("error"));
1252  	}
1253  }
1254  TEST (rpc, process_json_block)
1255  {
1256  	nano::test::system system;
1257  	auto node1 = add_ipc_enabled_node (system);
1258  	auto const rpc_ctx = add_rpc (system, node1);
1259  	nano::keypair key;
1260  	auto latest (node1->latest (nano::dev::genesis_key.pub));
1261  	nano::block_builder builder;
1262  	auto send = builder
1263  				.send ()
1264  				.previous (latest)
1265  				.destination (key.pub)
1266  				.balance (100)
1267  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1268  				.work (*node1->work_generate_blocking (latest))
1269  				.build ();
1270  	boost::property_tree::ptree request;
1271  	request.put ("action", "process");
1272  	boost::property_tree::ptree block_node;
1273  	send->serialize_json (block_node);
1274  	request.add_child ("block", block_node);
1275  	{
1276  		auto response (wait_response (system, rpc_ctx, request));
1277  		std::error_code ec (nano::error_blocks::invalid_block);
1278  		ASSERT_EQ (ec.message (), response.get<std::string> ("error"));
1279  	}
1280  	request.put ("json_block", true);
1281  	{
1282  		auto response (wait_response (system, rpc_ctx, request));
1283  		ASSERT_TIMELY (10s, node1->latest (nano::dev::genesis_key.pub) == send->hash ());
1284  		std::string send_hash (response.get<std::string> ("hash"));
1285  		ASSERT_EQ (send->hash ().to_string (), send_hash);
1286  	}
1287  }
1288  TEST (rpc, process_block_async)
1289  {
1290  	nano::test::system system;
1291  	auto node1 = add_ipc_enabled_node (system);
1292  	auto const rpc_ctx = add_rpc (system, node1);
1293  	nano::keypair key;
1294  	auto latest (node1->latest (nano::dev::genesis_key.pub));
1295  	nano::block_builder builder;
1296  	auto send = builder
1297  				.send ()
1298  				.previous (latest)
1299  				.destination (key.pub)
1300  				.balance (100)
1301  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1302  				.work (*node1->work_generate_blocking (latest))
1303  				.build ();
1304  	boost::property_tree::ptree request;
1305  	request.put ("action", "process");
1306  	request.put ("async", "true");
1307  	std::string json;
1308  	send->serialize_json (json);
1309  	request.put ("block", json);
1310  	request.put ("json_block", true);
1311  	{
1312  		auto response (wait_response (system, rpc_ctx, request));
1313  		std::error_code ec (nano::error_blocks::invalid_block);
1314  		ASSERT_EQ (ec.message (), response.get<std::string> ("error"));
1315  	}
1316  	request.put ("json_block", false);
1317  	{
1318  		auto response (wait_response (system, rpc_ctx, request));
1319  		std::error_code ec (nano::error_common::is_not_state_block);
1320  		ASSERT_EQ (ec.message (), response.get<std::string> ("error"));
1321  	}
1322  	auto state_send = builder
1323  					  .state ()
1324  					  .account (nano::dev::genesis_key.pub)
1325  					  .previous (latest)
1326  					  .representative (nano::dev::genesis_key.pub)
1327  					  .balance (nano::dev::constants.genesis_amount - 100)
1328  					  .link (nano::dev::genesis_key.pub)
1329  					  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1330  					  .work (*system.work.generate (latest))
1331  					  .build_shared ();
1332  	std::string json1;
1333  	state_send->serialize_json (json1);
1334  	request.put ("block", json1);
1335  	{
1336  		auto response (wait_response (system, rpc_ctx, request));
1337  		ASSERT_EQ ("1", response.get<std::string> ("started"));
1338  		ASSERT_TIMELY (10s, node1->latest (nano::dev::genesis_key.pub) == state_send->hash ());
1339  	}
1340  }
1341  TEST (rpc, process_block_no_work)
1342  {
1343  	nano::test::system system;
1344  	auto node1 = add_ipc_enabled_node (system);
1345  	auto const rpc_ctx = add_rpc (system, node1);
1346  	nano::keypair key;
1347  	auto latest (node1->latest (nano::dev::genesis_key.pub));
1348  	nano::block_builder builder;
1349  	auto send = builder
1350  				.send ()
1351  				.previous (latest)
1352  				.destination (key.pub)
1353  				.balance (100)
1354  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1355  				.work (*node1->work_generate_blocking (latest))
1356  				.build ();
1357  	send->block_work_set (0);
1358  	boost::property_tree::ptree request;
1359  	request.put ("action", "process");
1360  	std::string json;
1361  	send->serialize_json (json);
1362  	request.put ("block", json);
1363  	auto response (wait_response (system, rpc_ctx, request));
1364  	ASSERT_FALSE (response.get<std::string> ("error", "").empty ());
1365  }
1366  TEST (rpc, process_republish)
1367  {
1368  	nano::test::system system (2);
1369  	auto & node1 (*system.nodes[0]);
1370  	auto & node2 (*system.nodes[1]);
1371  	auto node3 = add_ipc_enabled_node (system);
1372  	auto const rpc_ctx = add_rpc (system, node3);
1373  	nano::keypair key;
1374  	auto latest (node1.latest (nano::dev::genesis_key.pub));
1375  	nano::block_builder builder;
1376  	auto send = builder
1377  				.send ()
1378  				.previous (latest)
1379  				.destination (key.pub)
1380  				.balance (100)
1381  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1382  				.work (*node3->work_generate_blocking (latest))
1383  				.build ();
1384  	boost::property_tree::ptree request;
1385  	request.put ("action", "process");
1386  	std::string json;
1387  	send->serialize_json (json);
1388  	request.put ("block", json);
1389  	auto response (wait_response (system, rpc_ctx, request));
1390  	ASSERT_TIMELY (10s, node2.latest (nano::dev::genesis_key.pub) == send->hash ());
1391  }
1392  TEST (rpc, process_subtype_send)
1393  {
1394  	nano::test::system system;
1395  	auto node1 = add_ipc_enabled_node (system);
1396  	system.add_node ();
1397  	auto const rpc_ctx = add_rpc (system, node1);
1398  	nano::keypair key;
1399  	auto latest (node1->latest (nano::dev::genesis_key.pub));
1400  	nano::block_builder builder;
1401  	auto send = builder
1402  				.state ()
1403  				.account (nano::dev::genesis->account ())
1404  				.previous (latest)
1405  				.representative (nano::dev::genesis->account ())
1406  				.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
1407  				.link (key.pub)
1408  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1409  				.work (*node1->work_generate_blocking (latest))
1410  				.build ();
1411  	boost::property_tree::ptree request;
1412  	request.put ("action", "process");
1413  	std::string json;
1414  	send->serialize_json (json);
1415  	request.put ("block", json);
1416  	request.put ("subtype", "receive");
1417  	auto response (wait_response (system, rpc_ctx, request));
1418  	std::error_code ec (nano::error_rpc::invalid_subtype_balance);
1419  	ASSERT_EQ (response.get<std::string> ("error"), ec.message ());
1420  	request.put ("subtype", "change");
1421  	auto response2 (wait_response (system, rpc_ctx, request));
1422  	ASSERT_EQ (response2.get<std::string> ("error"), ec.message ());
1423  	request.put ("subtype", "send");
1424  	auto response3 (wait_response (system, rpc_ctx, request));
1425  	ASSERT_EQ (send->hash ().to_string (), response3.get<std::string> ("hash"));
1426  	ASSERT_TIMELY (10s, system.nodes[1]->latest (nano::dev::genesis_key.pub) == send->hash ());
1427  }
1428  TEST (rpc, process_subtype_open)
1429  {
1430  	nano::test::system system;
1431  	auto node1 = add_ipc_enabled_node (system);
1432  	auto & node2 = *system.add_node ();
1433  	nano::keypair key;
1434  	auto latest (node1->latest (nano::dev::genesis_key.pub));
1435  	nano::block_builder builder;
1436  	auto send = builder
1437  				.state ()
1438  				.account (nano::dev::genesis->account ())
1439  				.previous (latest)
1440  				.representative (nano::dev::genesis->account ())
1441  				.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
1442  				.link (key.pub)
1443  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1444  				.work (*node1->work_generate_blocking (latest))
1445  				.build_shared ();
1446  	ASSERT_EQ (nano::process_result::progress, node1->process (*send).code);
1447  	ASSERT_EQ (nano::process_result::progress, node2.process (*send).code);
1448  	auto const rpc_ctx = add_rpc (system, node1);
1449  	node1->scheduler.buckets.manual (send);
1450  	auto open = builder
1451  				.state ()
1452  				.account (key.pub)
1453  				.previous (0)
1454  				.representative (key.pub)
1455  				.balance (nano::Gxrb_ratio)
1456  				.link (send->hash ())
1457  				.sign (key.prv, key.pub)
1458  				.work (*node1->work_generate_blocking (key.pub))
1459  				.build ();
1460  	boost::property_tree::ptree request;
1461  	request.put ("action", "process");
1462  	std::string json;
1463  	open->serialize_json (json);
1464  	request.put ("block", json);
1465  	request.put ("subtype", "send");
1466  	auto response (wait_response (system, rpc_ctx, request));
1467  	std::error_code ec (nano::error_rpc::invalid_subtype_balance);
1468  	ASSERT_EQ (response.get<std::string> ("error"), ec.message ());
1469  	request.put ("subtype", "epoch");
1470  	auto response2 (wait_response (system, rpc_ctx, request));
1471  	ASSERT_EQ (response2.get<std::string> ("error"), ec.message ());
1472  	request.put ("subtype", "open");
1473  	auto response3 (wait_response (system, rpc_ctx, request));
1474  	ASSERT_EQ (open->hash ().to_string (), response3.get<std::string> ("hash"));
1475  	ASSERT_TIMELY (10s, node2.latest (key.pub) == open->hash ());
1476  }
1477  TEST (rpc, process_subtype_receive)
1478  {
1479  	nano::test::system system;
1480  	auto node1 = add_ipc_enabled_node (system);
1481  	auto & node2 = *system.add_node ();
1482  	auto latest (node1->latest (nano::dev::genesis_key.pub));
1483  	nano::block_builder builder;
1484  	auto send = builder
1485  				.state ()
1486  				.account (nano::dev::genesis->account ())
1487  				.previous (latest)
1488  				.representative (nano::dev::genesis->account ())
1489  				.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
1490  				.link (nano::dev::genesis_key.pub)
1491  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1492  				.work (*node1->work_generate_blocking (latest))
1493  				.build_shared ();
1494  	ASSERT_EQ (nano::process_result::progress, node1->process (*send).code);
1495  	ASSERT_EQ (nano::process_result::progress, node2.process (*send).code);
1496  	auto const rpc_ctx = add_rpc (system, node1);
1497  	node1->scheduler.buckets.manual (send);
1498  	auto receive = builder
1499  				   .state ()
1500  				   .account (nano::dev::genesis_key.pub)
1501  				   .previous (send->hash ())
1502  				   .representative (nano::dev::genesis_key.pub)
1503  				   .balance (nano::dev::constants.genesis_amount)
1504  				   .link (send->hash ())
1505  				   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1506  				   .work (*node1->work_generate_blocking (send->hash ()))
1507  				   .build ();
1508  	boost::property_tree::ptree request;
1509  	request.put ("action", "process");
1510  	std::string json;
1511  	receive->serialize_json (json);
1512  	request.put ("block", json);
1513  	request.put ("subtype", "send");
1514  	auto response (wait_response (system, rpc_ctx, request));
1515  	std::error_code ec (nano::error_rpc::invalid_subtype_balance);
1516  	ASSERT_EQ (response.get<std::string> ("error"), ec.message ());
1517  	request.put ("subtype", "open");
1518  	auto response2 (wait_response (system, rpc_ctx, request));
1519  	ec = nano::error_rpc::invalid_subtype_previous;
1520  	ASSERT_EQ (response2.get<std::string> ("error"), ec.message ());
1521  	request.put ("subtype", "receive");
1522  	auto response3 (wait_response (system, rpc_ctx, request));
1523  	ASSERT_EQ (receive->hash ().to_string (), response3.get<std::string> ("hash"));
1524  	ASSERT_TIMELY (10s, node2.latest (nano::dev::genesis_key.pub) == receive->hash ());
1525  }
1526  TEST (rpc, process_ledger_insufficient_work)
1527  {
1528  	nano::test::system system;
1529  	auto node = add_ipc_enabled_node (system);
1530  	auto const rpc_ctx = add_rpc (system, node);
1531  	ASSERT_LT (node->network_params.work.entry, node->network_params.work.epoch_1);
1532  	auto latest (node->latest (nano::dev::genesis_key.pub));
1533  	auto min_difficulty = node->network_params.work.entry;
1534  	auto max_difficulty = node->network_params.work.epoch_1;
1535  	nano::block_builder builder;
1536  	auto send = builder
1537  				.state ()
1538  				.account (nano::dev::genesis->account ())
1539  				.previous (latest)
1540  				.representative (nano::dev::genesis->account ())
1541  				.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
1542  				.link (nano::dev::genesis_key.pub)
1543  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1544  				.work (system.work_generate_limited (latest, min_difficulty, max_difficulty))
1545  				.build ();
1546  	ASSERT_LT (nano::dev::network_params.work.difficulty (*send), max_difficulty);
1547  	ASSERT_GE (nano::dev::network_params.work.difficulty (*send), min_difficulty);
1548  	boost::property_tree::ptree request;
1549  	request.put ("action", "process");
1550  	std::string json;
1551  	send->serialize_json (json);
1552  	request.put ("block", json);
1553  	request.put ("subtype", "send");
1554  	auto response (wait_response (system, rpc_ctx, request));
1555  	std::error_code ec (nano::error_process::insufficient_work);
1556  	ASSERT_EQ (1, response.count ("error"));
1557  	ASSERT_EQ (response.get<std::string> ("error"), ec.message ());
1558  }
1559  TEST (rpc, keepalive)
1560  {
1561  	nano::test::system system;
1562  	auto node0 = add_ipc_enabled_node (system);
1563  	auto node1 (std::make_shared<nano::node> (system.io_ctx, system.get_available_port (), nano::unique_path (), system.logging, system.work));
1564  	node1->start ();
1565  	system.nodes.push_back (node1);
1566  	auto const rpc_ctx = add_rpc (system, node0);
1567  	boost::property_tree::ptree request;
1568  	request.put ("action", "keepalive");
1569  	auto address (boost::str (boost::format ("%1%") % node1->network.endpoint ().address ()));
1570  	auto port (boost::str (boost::format ("%1%") % node1->network.endpoint ().port ()));
1571  	request.put ("address", address);
1572  	request.put ("port", port);
1573  	ASSERT_EQ (nullptr, node0->network.tcp_channels.find_node_id (node1->get_node_id ()));
1574  	ASSERT_EQ (0, node0->network.size ());
1575  	auto response (wait_response (system, rpc_ctx, request));
1576  	system.deadline_set (10s);
1577  	while (node0->network.find_node_id (node1->get_node_id ()) == nullptr)
1578  	{
1579  		ASSERT_EQ (0, node0->network.size ());
1580  		ASSERT_NO_ERROR (system.poll ());
1581  	}
1582  	node1->stop ();
1583  }
1584  TEST (rpc, peers)
1585  {
1586  	nano::test::system system;
1587  	auto node = add_ipc_enabled_node (system);
1588  	auto const node2 = system.add_node ();
1589  	auto const rpc_ctx = add_rpc (system, node);
1590  	boost::property_tree::ptree request;
1591  	request.put ("action", "peers");
1592  	auto response (wait_response (system, rpc_ctx, request));
1593  	auto & peers_node (response.get_child ("peers"));
1594  	ASSERT_EQ (1, peers_node.size ());
1595  	ASSERT_EQ (std::to_string (node->network_params.network.protocol_version), peers_node.get<std::string> ((boost::format ("[::1]:%1%") % node2->network.endpoint ().port ()).str ()));
1596  }
1597  TEST (rpc, peers_node_id)
1598  {
1599  	nano::test::system system;
1600  	auto node = add_ipc_enabled_node (system);
1601  	auto const node2 = system.add_node ();
1602  	auto const rpc_ctx = add_rpc (system, node);
1603  	boost::property_tree::ptree request;
1604  	request.put ("action", "peers");
1605  	request.put ("peer_details", true);
1606  	auto response (wait_response (system, rpc_ctx, request));
1607  	auto & peers_node (response.get_child ("peers"));
1608  	ASSERT_EQ (1, peers_node.size ());
1609  	auto tree1 (peers_node.get_child ((boost::format ("[::1]:%1%") % node2->network.endpoint ().port ()).str ()));
1610  	ASSERT_EQ (std::to_string (node->network_params.network.protocol_version), tree1.get<std::string> ("protocol_version"));
1611  	ASSERT_EQ (system.nodes[1]->node_id.pub.to_node_id (), tree1.get<std::string> ("node_id"));
1612  }
1613  TEST (rpc, version)
1614  {
1615  	nano::test::system system;
1616  	auto node1 = add_ipc_enabled_node (system);
1617  	auto const rpc_ctx = add_rpc (system, node1);
1618  	boost::property_tree::ptree request1;
1619  	request1.put ("action", "version");
1620  	test_response response1 (request1, rpc_ctx.rpc->listening_port (), system.io_ctx);
1621  	ASSERT_TIMELY (5s, response1.status != 0);
1622  	ASSERT_EQ (200, response1.status);
1623  	ASSERT_EQ ("1", response1.json.get<std::string> ("rpc_version"));
1624  	{
1625  		auto transaction (node1->store.tx_begin_read ());
1626  		ASSERT_EQ (std::to_string (node1->store.version.get (transaction)), response1.json.get<std::string> ("store_version"));
1627  	}
1628  	ASSERT_EQ (std::to_string (node1->network_params.network.protocol_version), response1.json.get<std::string> ("protocol_version"));
1629  	ASSERT_EQ (boost::str (boost::format ("Nano %1%") % NANO_VERSION_STRING), response1.json.get<std::string> ("node_vendor"));
1630  	ASSERT_EQ (node1->store.vendor_get (), response1.json.get<std::string> ("store_vendor"));
1631  	auto network_label (node1->network_params.network.get_current_network_as_string ());
1632  	ASSERT_EQ (network_label, response1.json.get<std::string> ("network"));
1633  	auto genesis_open (node1->latest (nano::dev::genesis_key.pub));
1634  	ASSERT_EQ (genesis_open.to_string (), response1.json.get<std::string> ("network_identifier"));
1635  	ASSERT_EQ (BUILD_INFO, response1.json.get<std::string> ("build_info"));
1636  	auto headers (response1.resp.base ());
1637  	auto allow (headers.at ("Allow"));
1638  	auto content_type (headers.at ("Content-Type"));
1639  	auto access_control_allow_origin (headers.at ("Access-Control-Allow-Origin"));
1640  	auto access_control_allow_methods (headers.at ("Access-Control-Allow-Methods"));
1641  	auto access_control_allow_headers (headers.at ("Access-Control-Allow-Headers"));
1642  	auto connection (headers.at ("Connection"));
1643  	ASSERT_EQ ("POST, OPTIONS", allow);
1644  	ASSERT_EQ ("application/json", content_type);
1645  	ASSERT_EQ ("*", access_control_allow_origin);
1646  	ASSERT_EQ (allow, access_control_allow_methods);
1647  	ASSERT_EQ ("Accept, Accept-Language, Content-Language, Content-Type", access_control_allow_headers);
1648  	ASSERT_EQ ("close", connection);
1649  }
1650  TEST (rpc, work_generate)
1651  {
1652  	nano::test::system system;
1653  	auto node = add_ipc_enabled_node (system);
1654  	auto const rpc_ctx = add_rpc (system, node);
1655  	nano::block_hash hash (1);
1656  	boost::property_tree::ptree request;
1657  	request.put ("action", "work_generate");
1658  	request.put ("hash", hash.to_string ());
1659  	auto verify_response = [&node, &rpc_ctx, &system] (auto & request, auto & hash) {
1660  		auto response (wait_response (system, rpc_ctx, request));
1661  		ASSERT_EQ (hash.to_string (), response.template get<std::string> ("hash"));
1662  		auto work_text (response.template get<std::string> ("work"));
1663  		uint64_t work;
1664  		ASSERT_FALSE (nano::from_string_hex (work_text, work));
1665  		auto result_difficulty (nano::dev::network_params.work.difficulty (nano::work_version::work_1, hash, work));
1666  		auto response_difficulty_text (response.template get<std::string> ("difficulty"));
1667  		uint64_t response_difficulty;
1668  		ASSERT_FALSE (nano::from_string_hex (response_difficulty_text, response_difficulty));
1669  		ASSERT_EQ (result_difficulty, response_difficulty);
1670  		auto multiplier = response.template get<double> ("multiplier");
1671  		ASSERT_NEAR (nano::difficulty::to_multiplier (result_difficulty, node->default_difficulty (nano::work_version::work_1)), multiplier, 1e-6);
1672  	};
1673  	verify_response (request, hash);
1674  	request.put ("use_peers", "true");
1675  	verify_response (request, hash);
1676  }
1677  TEST (rpc, work_generate_difficulty)
1678  {
1679  	nano::test::system system;
1680  	nano::node_config node_config = system.default_config ();
1681  	node_config.max_work_generate_multiplier = 1000;
1682  	auto node = add_ipc_enabled_node (system);
1683  	auto const rpc_ctx = add_rpc (system, node);
1684  	nano::block_hash hash (1);
1685  	boost::property_tree::ptree request;
1686  	request.put ("action", "work_generate");
1687  	request.put ("hash", hash.to_string ());
1688  	{
1689  		uint64_t difficulty (0xfff0000000000000);
1690  		request.put ("difficulty", nano::to_string_hex (difficulty));
1691  		auto response (wait_response (system, rpc_ctx, request, 10s));
1692  		auto work_text (response.get<std::string> ("work"));
1693  		uint64_t work;
1694  		ASSERT_FALSE (nano::from_string_hex (work_text, work));
1695  		auto result_difficulty (nano::dev::network_params.work.difficulty (nano::work_version::work_1, hash, work));
1696  		auto response_difficulty_text (response.get<std::string> ("difficulty"));
1697  		uint64_t response_difficulty;
1698  		ASSERT_FALSE (nano::from_string_hex (response_difficulty_text, response_difficulty));
1699  		ASSERT_EQ (result_difficulty, response_difficulty);
1700  		auto multiplier = response.get<double> ("multiplier");
1701  		ASSERT_NEAR (nano::difficulty::to_multiplier (result_difficulty, node->default_difficulty (nano::work_version::work_1)), multiplier, 1e-10);
1702  		ASSERT_GE (result_difficulty, difficulty);
1703  	}
1704  	{
1705  		uint64_t difficulty (0xffff000000000000);
1706  		request.put ("difficulty", nano::to_string_hex (difficulty));
1707  		auto response (wait_response (system, rpc_ctx, request));
1708  		auto work_text (response.get<std::string> ("work"));
1709  		uint64_t work;
1710  		ASSERT_FALSE (nano::from_string_hex (work_text, work));
1711  		auto result_difficulty (nano::dev::network_params.work.difficulty (nano::work_version::work_1, hash, work));
1712  		ASSERT_GE (result_difficulty, difficulty);
1713  	}
1714  	{
1715  		uint64_t difficulty (node->max_work_generate_difficulty (nano::work_version::work_1) + 1);
1716  		request.put ("difficulty", nano::to_string_hex (difficulty));
1717  		auto response (wait_response (system, rpc_ctx, request));
1718  		std::error_code ec (nano::error_rpc::difficulty_limit);
1719  		ASSERT_EQ (response.get<std::string> ("error"), ec.message ());
1720  	}
1721  }
1722  TEST (rpc, work_generate_multiplier)
1723  {
1724  	nano::test::system system;
1725  	nano::node_config node_config = system.default_config ();
1726  	node_config.max_work_generate_multiplier = 100;
1727  	auto node = add_ipc_enabled_node (system, node_config);
1728  	auto const rpc_ctx = add_rpc (system, node);
1729  	nano::block_hash hash (1);
1730  	boost::property_tree::ptree request;
1731  	request.put ("action", "work_generate");
1732  	request.put ("hash", hash.to_string ());
1733  	{
1734  		request.put ("difficulty", nano::to_string_hex (static_cast<uint64_t> (0xff00000000000000)));
1735  		double multiplier{ 100.0 };
1736  		request.put ("multiplier", multiplier);
1737  		auto response (wait_response (system, rpc_ctx, request, 10s));
1738  		auto work_text (response.get_optional<std::string> ("work"));
1739  		ASSERT_TRUE (work_text.is_initialized ());
1740  		uint64_t work;
1741  		ASSERT_FALSE (nano::from_string_hex (*work_text, work));
1742  		auto result_difficulty (nano::dev::network_params.work.difficulty (nano::work_version::work_1, hash, work));
1743  		auto response_difficulty_text (response.get<std::string> ("difficulty"));
1744  		uint64_t response_difficulty;
1745  		ASSERT_FALSE (nano::from_string_hex (response_difficulty_text, response_difficulty));
1746  		ASSERT_EQ (result_difficulty, response_difficulty);
1747  		auto result_multiplier = response.get<double> ("multiplier");
1748  		ASSERT_GE (result_multiplier, multiplier);
1749  	}
1750  	{
1751  		request.put ("multiplier", -1.5);
1752  		auto response (wait_response (system, rpc_ctx, request));
1753  		std::error_code ec (nano::error_rpc::bad_multiplier_format);
1754  		ASSERT_EQ (response.get<std::string> ("error"), ec.message ());
1755  	}
1756  	{
1757  		double max_multiplier (nano::difficulty::to_multiplier (node->max_work_generate_difficulty (nano::work_version::work_1), node->default_difficulty (nano::work_version::work_1)));
1758  		request.put ("multiplier", max_multiplier + 1);
1759  		auto response (wait_response (system, rpc_ctx, request));
1760  		std::error_code ec (nano::error_rpc::difficulty_limit);
1761  		ASSERT_EQ (response.get<std::string> ("error"), ec.message ());
1762  	}
1763  }
1764  TEST (rpc, work_generate_block_high)
1765  {
1766  	nano::test::system system;
1767  	auto node = add_ipc_enabled_node (system);
1768  	auto const rpc_ctx = add_rpc (system, node);
1769  	nano::keypair key;
1770  	nano::block_builder builder;
1771  	auto block = builder
1772  				 .state ()
1773  				 .account (key.pub)
1774  				 .previous (0)
1775  				 .representative (nano::dev::genesis_key.pub)
1776  				 .balance (nano::Gxrb_ratio)
1777  				 .link (123)
1778  				 .sign (key.prv, key.pub)
1779  				 .work (*node->work_generate_blocking (key.pub))
1780  				 .build ();
1781  	nano::block_hash hash (block->root ().as_block_hash ());
1782  	auto block_difficulty (nano::dev::network_params.work.difficulty (nano::work_version::work_1, hash, block->block_work ()));
1783  	boost::property_tree::ptree request;
1784  	request.put ("action", "work_generate");
1785  	request.put ("hash", hash.to_string ());
1786  	request.put ("json_block", "true");
1787  	boost::property_tree::ptree json;
1788  	block->serialize_json (json);
1789  	request.add_child ("block", json);
1790  	{
1791  		auto response (wait_response (system, rpc_ctx, request));
1792  		ASSERT_EQ (1, response.count ("error"));
1793  		ASSERT_EQ (std::error_code (nano::error_rpc::block_work_enough).message (), response.get<std::string> ("error"));
1794  	}
1795  }
1796  TEST (rpc, work_generate_block_low)
1797  {
1798  	nano::test::system system;
1799  	auto node = add_ipc_enabled_node (system);
1800  	auto const rpc_ctx = add_rpc (system, node);
1801  	nano::keypair key;
1802  	nano::block_builder builder;
1803  	auto block = builder
1804  				 .state ()
1805  				 .account (key.pub)
1806  				 .previous (0)
1807  				 .representative (nano::dev::genesis_key.pub)
1808  				 .balance (nano::Gxrb_ratio)
1809  				 .link (123)
1810  				 .sign (key.prv, key.pub)
1811  				 .work (0)
1812  				 .build ();
1813  	auto threshold (node->default_difficulty (block->work_version ()));
1814  	block->block_work_set (system.work_generate_limited (block->root ().as_block_hash (), threshold, nano::difficulty::from_multiplier (node->config.max_work_generate_multiplier / 10, threshold)));
1815  	nano::block_hash hash (block->root ().as_block_hash ());
1816  	auto block_difficulty (nano::dev::network_params.work.difficulty (*block));
1817  	boost::property_tree::ptree request;
1818  	request.put ("action", "work_generate");
1819  	request.put ("hash", hash.to_string ());
1820  	request.put ("difficulty", nano::to_string_hex (block_difficulty + 1));
1821  	request.put ("json_block", "false");
1822  	std::string json;
1823  	block->serialize_json (json);
1824  	request.put ("block", json);
1825  	{
1826  		auto response (wait_response (system, rpc_ctx, request, 10s));
1827  		auto work_text (response.get_optional<std::string> ("work"));
1828  		ASSERT_TRUE (work_text.is_initialized ());
1829  		uint64_t work;
1830  		ASSERT_FALSE (nano::from_string_hex (*work_text, work));
1831  		ASSERT_NE (block->block_work (), work);
1832  		auto result_difficulty (nano::dev::network_params.work.difficulty (nano::work_version::work_1, hash, work));
1833  		auto response_difficulty_text (response.get<std::string> ("difficulty"));
1834  		uint64_t response_difficulty;
1835  		ASSERT_FALSE (nano::from_string_hex (response_difficulty_text, response_difficulty));
1836  		ASSERT_EQ (result_difficulty, response_difficulty);
1837  		ASSERT_LT (block_difficulty, result_difficulty);
1838  	}
1839  }
1840  TEST (rpc, work_generate_block_root_mismatch)
1841  {
1842  	nano::test::system system;
1843  	auto node = add_ipc_enabled_node (system);
1844  	auto const rpc_ctx = add_rpc (system, node);
1845  	nano::keypair key;
1846  	nano::block_builder builder;
1847  	auto block = builder
1848  				 .state ()
1849  				 .account (key.pub)
1850  				 .previous (0)
1851  				 .representative (nano::dev::genesis_key.pub)
1852  				 .balance (nano::Gxrb_ratio)
1853  				 .link (123)
1854  				 .sign (key.prv, key.pub)
1855  				 .work (*node->work_generate_blocking (key.pub))
1856  				 .build ();
1857  	nano::block_hash hash (1);
1858  	boost::property_tree::ptree request;
1859  	request.put ("action", "work_generate");
1860  	request.put ("hash", hash.to_string ());
1861  	request.put ("json_block", "false");
1862  	std::string json;
1863  	block->serialize_json (json);
1864  	request.put ("block", json);
1865  	{
1866  		auto response (wait_response (system, rpc_ctx, request));
1867  		ASSERT_EQ (1, response.count ("error"));
1868  		ASSERT_EQ (std::error_code (nano::error_rpc::block_root_mismatch).message (), response.get<std::string> ("error"));
1869  	}
1870  }
1871  TEST (rpc, work_generate_block_ledger_epoch_2)
1872  {
1873  	nano::test::system system;
1874  	auto node = add_ipc_enabled_node (system);
1875  	auto epoch1 = system.upgrade_genesis_epoch (*node, nano::epoch::epoch_1);
1876  	ASSERT_NE (nullptr, epoch1);
1877  	auto epoch2 = system.upgrade_genesis_epoch (*node, nano::epoch::epoch_2);
1878  	ASSERT_NE (nullptr, epoch2);
1879  	nano::keypair key;
1880  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
1881  	auto send_block (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key.pub, nano::Gxrb_ratio));
1882  	ASSERT_NE (nullptr, send_block);
1883  	nano::block_builder builder;
1884  	auto block = builder
1885  				 .state ()
1886  				 .account (key.pub)
1887  				 .previous (0)
1888  				 .representative (nano::dev::genesis_key.pub)
1889  				 .balance (nano::Gxrb_ratio)
1890  				 .link (send_block->hash ())
1891  				 .sign (key.prv, key.pub)
1892  				 .work (0)
1893  				 .build ();
1894  	auto threshold (nano::dev::network_params.work.threshold (block->work_version (), nano::block_details (nano::epoch::epoch_2, false, true, false)));
1895  	block->block_work_set (system.work_generate_limited (block->root ().as_block_hash (), 1, threshold - 1));
1896  	nano::block_hash hash (block->root ().as_block_hash ());
1897  	auto const rpc_ctx = add_rpc (system, node);
1898  	boost::property_tree::ptree request;
1899  	request.put ("action", "work_generate");
1900  	request.put ("hash", hash.to_string ());
1901  	request.put ("json_block", "false");
1902  	std::string json;
1903  	block->serialize_json (json);
1904  	request.put ("block", json);
1905  	bool finished (false);
1906  	auto iteration (0);
1907  	while (!finished)
1908  	{
1909  		auto response (wait_response (system, rpc_ctx, request, 10s));
1910  		auto work_text (response.get_optional<std::string> ("work"));
1911  		ASSERT_TRUE (work_text.is_initialized ());
1912  		uint64_t work;
1913  		ASSERT_FALSE (nano::from_string_hex (*work_text, work));
1914  		auto result_difficulty (nano::dev::network_params.work.difficulty (nano::work_version::work_1, hash, work));
1915  		auto response_difficulty_text (response.get<std::string> ("difficulty"));
1916  		uint64_t response_difficulty;
1917  		ASSERT_FALSE (nano::from_string_hex (response_difficulty_text, response_difficulty));
1918  		ASSERT_EQ (result_difficulty, response_difficulty);
1919  		ASSERT_GE (result_difficulty, node->network_params.work.epoch_2_receive);
1920  		finished = result_difficulty < node->network_params.work.epoch_1;
1921  		ASSERT_LT (++iteration, 200);
1922  	}
1923  }
1924  TEST (rpc, work_cancel)
1925  {
1926  	nano::test::system system;
1927  	auto node1 = add_ipc_enabled_node (system);
1928  	auto const rpc_ctx = add_rpc (system, node1);
1929  	nano::block_hash hash1 (1);
1930  	boost::property_tree::ptree request1;
1931  	request1.put ("action", "work_cancel");
1932  	request1.put ("hash", hash1.to_string ());
1933  	std::atomic<bool> done (false);
1934  	system.deadline_set (10s);
1935  	while (!done)
1936  	{
1937  		system.work.generate (nano::work_version::work_1, hash1, node1->network_params.work.base, [&done] (boost::optional<uint64_t> work_a) {
1938  			done = !work_a;
1939  		});
1940  		auto response1 (wait_response (system, rpc_ctx, request1));
1941  		std::error_code ec;
1942  		ASSERT_NO_ERROR (ec);
1943  		std::string success (response1.get<std::string> ("success"));
1944  		ASSERT_TRUE (success.empty ());
1945  	}
1946  }
1947  TEST (rpc, work_peer_bad)
1948  {
1949  	nano::test::system system;
1950  	auto node1 = add_ipc_enabled_node (system);
1951  	auto & node2 = *system.add_node ();
1952  	node2.config.work_peers.emplace_back (boost::asio::ip::address_v6::any ().to_string (), 0);
1953  	auto const rpc_ctx = add_rpc (system, node1);
1954  	nano::block_hash hash1 (1);
1955  	std::atomic<uint64_t> work (0);
1956  	node2.work_generate (nano::work_version::work_1, hash1, node2.network_params.work.base, [&work] (boost::optional<uint64_t> work_a) {
1957  		ASSERT_TRUE (work_a.is_initialized ());
1958  		work = *work_a;
1959  	});
1960  	ASSERT_TIMELY (5s, nano::dev::network_params.work.difficulty (nano::work_version::work_1, hash1, work) >= nano::dev::network_params.work.threshold_base (nano::work_version::work_1));
1961  }
1962  TEST (rpc, DISABLED_work_peer_one)
1963  {
1964  	nano::test::system system;
1965  	auto node1 = add_ipc_enabled_node (system);
1966  	auto & node2 = *system.add_node ();
1967  	auto const rpc_ctx = add_rpc (system, node1);
1968  	node2.config.work_peers.emplace_back (node1->network.endpoint ().address ().to_string (), rpc_ctx.rpc->listening_port ());
1969  	nano::keypair key1;
1970  	std::atomic<uint64_t> work (0);
1971  	node2.work_generate (nano::work_version::work_1, key1.pub, node1->network_params.work.base, [&work] (boost::optional<uint64_t> work_a) {
1972  		ASSERT_TRUE (work_a.is_initialized ());
1973  		work = *work_a;
1974  	});
1975  	ASSERT_TIMELY (5s, nano::dev::network_params.work.difficulty (nano::work_version::work_1, key1.pub, work) >= nano::dev::network_params.work.threshold_base (nano::work_version::work_1));
1976  }
1977  TEST (rpc, DISABLED_work_peer_many)
1978  {
1979  	nano::test::system system1 (1);
1980  	nano::test::system system2;
1981  	nano::test::system system3 (1);
1982  	nano::test::system system4 (1);
1983  	auto & node1 (*system1.nodes[0]);
1984  	auto node2 = add_ipc_enabled_node (system2);
1985  	auto node3 = add_ipc_enabled_node (system3);
1986  	auto node4 = add_ipc_enabled_node (system4);
1987  	const auto rpc_ctx_2 = add_rpc (system2, node2);
1988  	const auto rpc_ctx_3 = add_rpc (system3, node3);
1989  	const auto rpc_ctx_4 = add_rpc (system4, node4);
1990  	node1.config.work_peers.emplace_back (node2->network.endpoint ().address ().to_string (), rpc_ctx_2.rpc->listening_port ());
1991  	node1.config.work_peers.emplace_back (node3->network.endpoint ().address ().to_string (), rpc_ctx_3.rpc->listening_port ());
1992  	node1.config.work_peers.emplace_back (node4->network.endpoint ().address ().to_string (), rpc_ctx_4.rpc->listening_port ());
1993  	std::array<std::atomic<uint64_t>, 10> works{};
1994  	for (auto & work : works)
1995  	{
1996  		nano::keypair key1;
1997  		node1.work_generate (nano::work_version::work_1, key1.pub, node1.network_params.work.base, [&work] (boost::optional<uint64_t> work_a) {
1998  			work = *work_a;
1999  		});
2000  		while (nano::dev::network_params.work.difficulty (nano::work_version::work_1, key1.pub, work) < nano::dev::network_params.work.threshold_base (nano::work_version::work_1))
2001  		{
2002  			system1.poll ();
2003  			system2.poll ();
2004  			system3.poll ();
2005  			system4.poll ();
2006  		}
2007  	}
2008  	node1.stop ();
2009  }
2010  TEST (rpc, DISABLED_work_version_invalid)
2011  {
2012  	nano::test::system system;
2013  	auto node = add_ipc_enabled_node (system);
2014  	auto const rpc_ctx = add_rpc (system, node);
2015  	nano::block_hash hash (1);
2016  	boost::property_tree::ptree request;
2017  	request.put ("action", "work_generate");
2018  	request.put ("hash", hash.to_string ());
2019  	request.put ("version", "work_invalid");
2020  	{
2021  		auto response (wait_response (system, rpc_ctx, request));
2022  		ASSERT_EQ (1, response.count ("error"));
2023  		ASSERT_EQ (std::error_code (nano::error_rpc::bad_work_version).message (), response.get<std::string> ("error"));
2024  	}
2025  	request.put ("action", "work_validate");
2026  	{
2027  		auto response (wait_response (system, rpc_ctx, request));
2028  		ASSERT_EQ (1, response.count ("error"));
2029  		ASSERT_EQ (std::error_code (nano::error_rpc::bad_work_version).message (), response.get<std::string> ("error"));
2030  	}
2031  }
2032  TEST (rpc, block_count)
2033  {
2034  	{
2035  		nano::test::system system;
2036  		auto node1 = add_ipc_enabled_node (system);
2037  		auto const rpc_ctx = add_rpc (system, node1);
2038  		boost::property_tree::ptree request1;
2039  		request1.put ("action", "block_count");
2040  		{
2041  			auto response1 (wait_response (system, rpc_ctx, request1));
2042  			ASSERT_EQ ("1", response1.get<std::string> ("count"));
2043  			ASSERT_EQ ("0", response1.get<std::string> ("unchecked"));
2044  			ASSERT_EQ ("1", response1.get<std::string> ("cemented"));
2045  		}
2046  	}
2047  	{
2048  		nano::test::system system;
2049  		auto node1 = add_ipc_enabled_node (system);
2050  		auto const rpc_ctx = add_rpc (system, node1);
2051  		boost::property_tree::ptree request1;
2052  		request1.put ("action", "block_count");
2053  		{
2054  			auto response1 (wait_response (system, rpc_ctx, request1));
2055  			ASSERT_EQ ("1", response1.get<std::string> ("count"));
2056  			ASSERT_EQ ("0", response1.get<std::string> ("unchecked"));
2057  			ASSERT_EQ ("1", response1.get<std::string> ("cemented"));
2058  		}
2059  	}
2060  }
2061  TEST (rpc, block_count_pruning)
2062  {
2063  	nano::test::system system;
2064  	auto & node0 = *system.add_node ();
2065  	nano::node_config node_config = system.default_config ();
2066  	node_config.enable_voting = false; 
2067  	nano::node_flags node_flags;
2068  	node_flags.enable_pruning = true;
2069  	auto node1 = add_ipc_enabled_node (system, node_config, node_flags);
2070  	auto latest (node1->latest (nano::dev::genesis_key.pub));
2071  	nano::block_builder builder;
2072  	auto send1 = builder
2073  				 .send ()
2074  				 .previous (latest)
2075  				 .destination (nano::dev::genesis_key.pub)
2076  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
2077  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2078  				 .work (*node1->work_generate_blocking (latest))
2079  				 .build_shared ();
2080  	node1->process_active (send1);
2081  	auto receive1 = builder
2082  					.receive ()
2083  					.previous (send1->hash ())
2084  					.source (send1->hash ())
2085  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2086  					.work (*node1->work_generate_blocking (send1->hash ()))
2087  					.build_shared ();
2088  	node1->process_active (receive1);
2089  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
2090  	ASSERT_TIMELY (5s, node1->block_confirmed (receive1->hash ()));
2091  	{
2092  		auto transaction (node1->store.tx_begin_write ());
2093  		ASSERT_EQ (1, node1->ledger.pruning_action (transaction, send1->hash (), 1));
2094  	}
2095  	auto const rpc_ctx = add_rpc (system, node1);
2096  	boost::property_tree::ptree request1;
2097  	request1.put ("action", "block_count");
2098  	{
2099  		auto response1 (wait_response (system, rpc_ctx, request1));
2100  		ASSERT_EQ ("3", response1.get<std::string> ("count"));
2101  		ASSERT_EQ ("0", response1.get<std::string> ("unchecked"));
2102  		ASSERT_EQ ("3", response1.get<std::string> ("cemented"));
2103  		ASSERT_EQ ("2", response1.get<std::string> ("full"));
2104  		ASSERT_EQ ("1", response1.get<std::string> ("pruned"));
2105  	}
2106  }
2107  TEST (rpc, frontier_count)
2108  {
2109  	nano::test::system system;
2110  	auto node1 = add_ipc_enabled_node (system);
2111  	auto const rpc_ctx = add_rpc (system, node1);
2112  	boost::property_tree::ptree request1;
2113  	request1.put ("action", "frontier_count");
2114  	auto response1 (wait_response (system, rpc_ctx, request1));
2115  	ASSERT_EQ ("1", response1.get<std::string> ("count"));
2116  }
2117  TEST (rpc, account_count)
2118  {
2119  	nano::test::system system;
2120  	auto node1 = add_ipc_enabled_node (system);
2121  	auto const rpc_ctx = add_rpc (system, node1);
2122  	boost::property_tree::ptree request1;
2123  	request1.put ("action", "account_count");
2124  	auto response1 (wait_response (system, rpc_ctx, request1));
2125  	ASSERT_EQ ("1", response1.get<std::string> ("count"));
2126  }
2127  TEST (rpc, available_supply)
2128  {
2129  	nano::test::system system;
2130  	auto node1 = add_ipc_enabled_node (system);
2131  	auto const rpc_ctx = add_rpc (system, node1);
2132  	boost::property_tree::ptree request1;
2133  	request1.put ("action", "available_supply");
2134  	auto response1 (wait_response (system, rpc_ctx, request1));
2135  	ASSERT_EQ ("0", response1.get<std::string> ("available"));
2136  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
2137  	nano::keypair key;
2138  	auto block (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key.pub, 1));
2139  	auto response2 (wait_response (system, rpc_ctx, request1));
2140  	ASSERT_EQ ("1", response2.get<std::string> ("available"));
2141  	auto block2 (system.wallet (0)->send_action (nano::dev::genesis_key.pub, 0, 100)); 
2142  	auto response3 (wait_response (system, rpc_ctx, request1, 10s));
2143  	ASSERT_EQ ("1", response3.get<std::string> ("available"));
2144  }
2145  TEST (rpc, mrai_to_raw)
2146  {
2147  	nano::test::system system;
2148  	auto node1 = add_ipc_enabled_node (system);
2149  	auto const rpc_ctx = add_rpc (system, node1);
2150  	boost::property_tree::ptree request1;
2151  	request1.put ("action", "mrai_to_raw");
2152  	request1.put ("amount", "1");
2153  	auto response1 (wait_response (system, rpc_ctx, request1));
2154  	ASSERT_EQ (nano::Mxrb_ratio.convert_to<std::string> (), response1.get<std::string> ("amount"));
2155  }
2156  TEST (rpc, mrai_from_raw)
2157  {
2158  	nano::test::system system;
2159  	auto node1 = add_ipc_enabled_node (system);
2160  	auto const rpc_ctx = add_rpc (system, node1);
2161  	boost::property_tree::ptree request1;
2162  	request1.put ("action", "mrai_from_raw");
2163  	request1.put ("amount", nano::Mxrb_ratio.convert_to<std::string> ());
2164  	auto response1 (wait_response (system, rpc_ctx, request1));
2165  	ASSERT_EQ ("1", response1.get<std::string> ("amount"));
2166  }
2167  TEST (rpc, krai_to_raw)
2168  {
2169  	nano::test::system system;
2170  	auto node1 = add_ipc_enabled_node (system);
2171  	auto const rpc_ctx = add_rpc (system, node1);
2172  	boost::property_tree::ptree request1;
2173  	request1.put ("action", "krai_to_raw");
2174  	request1.put ("amount", "1");
2175  	auto response1 (wait_response (system, rpc_ctx, request1));
2176  	ASSERT_EQ (nano::kxrb_ratio.convert_to<std::string> (), response1.get<std::string> ("amount"));
2177  }
2178  TEST (rpc, krai_from_raw)
2179  {
2180  	nano::test::system system;
2181  	auto node1 = add_ipc_enabled_node (system);
2182  	auto const rpc_ctx = add_rpc (system, node1);
2183  	boost::property_tree::ptree request1;
2184  	request1.put ("action", "krai_from_raw");
2185  	request1.put ("amount", nano::kxrb_ratio.convert_to<std::string> ());
2186  	auto response1 (wait_response (system, rpc_ctx, request1));
2187  	ASSERT_EQ ("1", response1.get<std::string> ("amount"));
2188  }
2189  TEST (rpc, nano_to_raw)
2190  {
2191  	nano::test::system system;
2192  	auto node1 = add_ipc_enabled_node (system);
2193  	auto const rpc_ctx = add_rpc (system, node1);
2194  	boost::property_tree::ptree request1;
2195  	request1.put ("action", "nano_to_raw");
2196  	request1.put ("amount", "1");
2197  	auto response1 (wait_response (system, rpc_ctx, request1));
2198  	ASSERT_EQ (nano::Mxrb_ratio.convert_to<std::string> (), response1.get<std::string> ("amount"));
2199  }
2200  TEST (rpc, raw_to_nano)
2201  {
2202  	nano::test::system system;
2203  	auto node1 = add_ipc_enabled_node (system);
2204  	auto const rpc_ctx = add_rpc (system, node1);
2205  	boost::property_tree::ptree request1;
2206  	request1.put ("action", "raw_to_nano");
2207  	request1.put ("amount", nano::Mxrb_ratio.convert_to<std::string> ());
2208  	auto response1 (wait_response (system, rpc_ctx, request1));
2209  	ASSERT_EQ ("1", response1.get<std::string> ("amount"));
2210  }
2211  TEST (rpc, account_representative)
2212  {
2213  	nano::test::system system;
2214  	auto node = add_ipc_enabled_node (system);
2215  	auto const rpc_ctx = add_rpc (system, node);
2216  	boost::property_tree::ptree request;
2217  	request.put ("account", nano::dev::genesis->account ().to_account ());
2218  	request.put ("action", "account_representative");
2219  	auto response (wait_response (system, rpc_ctx, request));
2220  	std::string account_text1 (response.get<std::string> ("representative"));
2221  	ASSERT_EQ (account_text1, nano::dev::genesis->account ().to_account ());
2222  }
2223  TEST (rpc, account_representative_set)
2224  {
2225  	nano::test::system system;
2226  	auto node = add_ipc_enabled_node (system);
2227  	auto & wallet = *system.wallet (0);
2228  	wallet.insert_adhoc (nano::dev::genesis_key.prv);
2229  	nano::keypair key2;
2230  	wallet.insert_adhoc (key2.prv);
2231  	auto key2_open_block_hash = wallet.send_sync (nano::dev::genesis_key.pub, key2.pub, node->config.receive_minimum.number ());
2232  	ASSERT_TIMELY (5s, node->ledger.block_confirmed (node->store.tx_begin_read (), key2_open_block_hash));
2233  	auto key2_open_block = node->store.block.get (node->store.tx_begin_read (), key2_open_block_hash);
2234  	ASSERT_EQ (nano::dev::genesis_key.pub, key2_open_block->representative ());
2235  	auto const rpc_ctx = add_rpc (system, node);
2236  	boost::property_tree::ptree request;
2237  	request.put ("account", key2.pub.to_account ());
2238  	request.put ("representative", key2.pub.to_account ());
2239  	request.put ("wallet", node->wallets.items.begin ()->first.to_string ());
2240  	request.put ("action", "account_representative_set");
2241  	auto response (wait_response (system, rpc_ctx, request));
2242  	std::string block_text1 (response.get<std::string> ("block"));
2243  	nano::block_hash hash;
2244  	ASSERT_FALSE (hash.decode_hex (block_text1));
2245  	ASSERT_FALSE (hash.is_zero ());
2246  	auto block = node->store.block.get (node->store.tx_begin_read (), hash);
2247  	ASSERT_NE (block, nullptr);
2248  	ASSERT_TIMELY (5s, node->ledger.block_confirmed (node->store.tx_begin_read (), hash));
2249  	ASSERT_EQ (key2.pub, block->representative ());
2250  }
2251  TEST (rpc, account_representative_set_work_disabled)
2252  {
2253  	nano::test::system system;
2254  	nano::node_config node_config = system.default_config ();
2255  	node_config.work_threads = 0;
2256  	auto node = add_ipc_enabled_node (system, node_config);
2257  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
2258  	auto const rpc_ctx = add_rpc (system, node);
2259  	boost::property_tree::ptree request;
2260  	nano::keypair rep;
2261  	request.put ("account", nano::dev::genesis->account ().to_account ());
2262  	request.put ("representative", rep.pub.to_account ());
2263  	request.put ("wallet", node->wallets.items.begin ()->first.to_string ());
2264  	request.put ("action", "account_representative_set");
2265  	{
2266  		auto response (wait_response (system, rpc_ctx, request, 10s));
2267  		ASSERT_EQ (std::error_code (nano::error_common::disabled_work_generation).message (), response.get<std::string> ("error"));
2268  	}
2269  }
2270  TEST (rpc, account_representative_set_epoch_2_insufficient_work)
2271  {
2272  	nano::test::system system;
2273  	auto node = add_ipc_enabled_node (system);
2274  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv, false);
2275  	ASSERT_NE (nullptr, system.upgrade_genesis_epoch (*node, nano::epoch::epoch_1));
2276  	ASSERT_NE (nullptr, system.upgrade_genesis_epoch (*node, nano::epoch::epoch_2));
2277  	node->scheduler.buckets.activate (nano::dev::genesis_key.pub, node->store.tx_begin_read ());
2278  	ASSERT_TIMELY (5s, node->get_confirmation_height (node->store.tx_begin_read (), nano::dev::genesis_key.pub) == 3);
2279  	auto target_difficulty = nano::dev::network_params.work.threshold (nano::work_version::work_1, nano::block_details (nano::epoch::epoch_2, false, false, false));
2280  	ASSERT_LT (node->network_params.work.entry, target_difficulty);
2281  	auto min_difficulty = node->network_params.work.entry;
2282  	auto const rpc_ctx = add_rpc (system, node);
2283  	boost::property_tree::ptree request;
2284  	std::string wallet;
2285  	node->wallets.items.begin ()->first.encode_hex (wallet);
2286  	request.put ("wallet", wallet);
2287  	request.put ("action", "account_representative_set");
2288  	request.put ("account", nano::dev::genesis_key.pub.to_account ());
2289  	request.put ("representative", nano::keypair ().pub.to_account ());
2290  	auto latest = node->ledger.latest (node->store.tx_begin_read (), nano::dev::genesis_key.pub);
2291  	auto insufficient = system.work_generate_limited (latest, min_difficulty, target_difficulty);
2292  	request.put ("work", nano::to_string_hex (insufficient));
2293  	{
2294  		auto response (wait_response (system, rpc_ctx, request));
2295  		std::error_code ec (nano::error_common::invalid_work);
2296  		ASSERT_EQ (1, response.count ("error"));
2297  		ASSERT_EQ (response.get<std::string> ("error"), ec.message ());
2298  	}
2299  }
2300  TEST (rpc, bootstrap)
2301  {
2302  	nano::test::system system0;
2303  	auto node = add_ipc_enabled_node (system0);
2304  	nano::test::system system1 (1);
2305  	auto node1 = system1.nodes[0];
2306  	auto latest (node1->latest (nano::dev::genesis_key.pub));
2307  	nano::block_builder builder;
2308  	auto send = builder
2309  				.send ()
2310  				.previous (latest)
2311  				.destination (nano::dev::genesis->account ())
2312  				.balance (100)
2313  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2314  				.work (*node1->work_generate_blocking (latest))
2315  				.build ();
2316  	{
2317  		auto transaction (node1->store.tx_begin_write ());
2318  		ASSERT_EQ (nano::process_result::progress, node1->ledger.process (transaction, *send).code);
2319  	}
2320  	auto const rpc_ctx = add_rpc (system0, node);
2321  	boost::property_tree::ptree request;
2322  	request.put ("action", "bootstrap");
2323  	request.put ("address", "::ffff:127.0.0.1");
2324  	request.put ("port", node1->network.endpoint ().port ());
2325  	test_response response (request, rpc_ctx.rpc->listening_port (), system0.io_ctx);
2326  	while (response.status == 0)
2327  	{
2328  		system0.poll ();
2329  	}
2330  	system1.deadline_set (10s);
2331  	while (node->latest (nano::dev::genesis->account ()) != node1->latest (nano::dev::genesis->account ()))
2332  	{
2333  		ASSERT_NO_ERROR (system0.poll ());
2334  		ASSERT_NO_ERROR (system1.poll ());
2335  	}
2336  }
2337  TEST (rpc, account_remove)
2338  {
2339  	nano::test::system system0;
2340  	auto node = add_ipc_enabled_node (system0);
2341  	auto key1 (system0.wallet (0)->deterministic_insert ());
2342  	ASSERT_TRUE (system0.wallet (0)->exists (key1));
2343  	auto const rpc_ctx = add_rpc (system0, node);
2344  	boost::property_tree::ptree request;
2345  	request.put ("action", "account_remove");
2346  	request.put ("wallet", node->wallets.items.begin ()->first.to_string ());
2347  	request.put ("account", key1.to_account ());
2348  	auto response (wait_response (system0, rpc_ctx, request));
2349  	ASSERT_FALSE (system0.wallet (0)->exists (key1));
2350  }
2351  TEST (rpc, representatives)
2352  {
2353  	nano::test::system system0;
2354  	auto node = add_ipc_enabled_node (system0);
2355  	auto const rpc_ctx = add_rpc (system0, node);
2356  	boost::property_tree::ptree request;
2357  	request.put ("action", "representatives");
2358  	auto response (wait_response (system0, rpc_ctx, request));
2359  	auto & representatives_node (response.get_child ("representatives"));
2360  	std::vector<nano::account> representatives;
2361  	for (auto i (representatives_node.begin ()), n (representatives_node.end ()); i != n; ++i)
2362  	{
2363  		nano::account account;
2364  		ASSERT_FALSE (account.decode_account (i->first));
2365  		representatives.push_back (account);
2366  	}
2367  	ASSERT_EQ (1, representatives.size ());
2368  	ASSERT_EQ (nano::dev::genesis->account (), representatives[0]);
2369  }
2370  TEST (rpc, wallet_seed)
2371  {
2372  	nano::test::system system;
2373  	auto node = add_ipc_enabled_node (system);
2374  	auto const rpc_ctx = add_rpc (system, node);
2375  	nano::raw_key seed;
2376  	{
2377  		auto transaction (node->wallets.tx_begin_read ());
2378  		system.wallet (0)->store.seed (seed, transaction);
2379  	}
2380  	boost::property_tree::ptree request;
2381  	request.put ("action", "wallet_seed");
2382  	request.put ("wallet", node->wallets.items.begin ()->first.to_string ());
2383  	auto response (wait_response (system, rpc_ctx, request));
2384  	{
2385  		std::string seed_text (response.get<std::string> ("seed"));
2386  		ASSERT_EQ (seed.to_string (), seed_text);
2387  	}
2388  }
2389  TEST (rpc, wallet_change_seed)
2390  {
2391  	nano::test::system system0;
2392  	auto node = add_ipc_enabled_node (system0);
2393  	auto const rpc_ctx = add_rpc (system0, node);
2394  	nano::raw_key seed;
2395  	nano::random_pool::generate_block (seed.bytes.data (), seed.bytes.size ());
2396  	{
2397  		auto transaction (node->wallets.tx_begin_read ());
2398  		nano::raw_key seed0;
2399  		nano::random_pool::generate_block (seed0.bytes.data (), seed0.bytes.size ());
2400  		system0.wallet (0)->store.seed (seed0, transaction);
2401  		ASSERT_NE (seed, seed0);
2402  	}
2403  	auto prv = nano::deterministic_key (seed, 0);
2404  	auto pub (nano::pub_key (prv));
2405  	boost::property_tree::ptree request;
2406  	request.put ("action", "wallet_change_seed");
2407  	request.put ("wallet", node->wallets.items.begin ()->first.to_string ());
2408  	request.put ("seed", seed.to_string ());
2409  	auto response (wait_response (system0, rpc_ctx, request));
2410  	{
2411  		auto transaction (node->wallets.tx_begin_read ());
2412  		nano::raw_key seed0;
2413  		system0.wallet (0)->store.seed (seed0, transaction);
2414  		ASSERT_EQ (seed, seed0);
2415  	}
2416  	auto account_text (response.get<std::string> ("last_restored_account"));
2417  	nano::account account;
2418  	ASSERT_FALSE (account.decode_account (account_text));
2419  	ASSERT_TRUE (system0.wallet (0)->exists (account));
2420  	ASSERT_EQ (pub, account);
2421  	ASSERT_EQ ("1", response.get<std::string> ("restored_count"));
2422  }
2423  TEST (rpc, wallet_frontiers)
2424  {
2425  	nano::test::system system0;
2426  	auto node = add_ipc_enabled_node (system0);
2427  	system0.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
2428  	auto const rpc_ctx = add_rpc (system0, node);
2429  	boost::property_tree::ptree request;
2430  	request.put ("action", "wallet_frontiers");
2431  	request.put ("wallet", node->wallets.items.begin ()->first.to_string ());
2432  	auto response (wait_response (system0, rpc_ctx, request));
2433  	auto & frontiers_node (response.get_child ("frontiers"));
2434  	std::vector<nano::account> frontiers;
2435  	for (auto i (frontiers_node.begin ()), n (frontiers_node.end ()); i != n; ++i)
2436  	{
2437  		frontiers.push_back (nano::account (i->second.get<std::string> ("")));
2438  	}
2439  	ASSERT_EQ (1, frontiers.size ());
2440  	ASSERT_EQ (node->latest (nano::dev::genesis->account ()), frontiers[0]);
2441  }
2442  TEST (rpc, work_validate)
2443  {
2444  	nano::test::system system;
2445  	auto node1 = add_ipc_enabled_node (system);
2446  	auto const rpc_ctx = add_rpc (system, node1);
2447  	nano::block_hash hash (1);
2448  	uint64_t work1 (*node1->work_generate_blocking (hash));
2449  	boost::property_tree::ptree request;
2450  	request.put ("action", "work_validate");
2451  	request.put ("hash", hash.to_string ());
2452  	request.put ("work", nano::to_string_hex (work1));
2453  	{
2454  		auto response (wait_response (system, rpc_ctx, request));
2455  		ASSERT_EQ (0, response.count ("valid"));
2456  		ASSERT_TRUE (response.get<bool> ("valid_all"));
2457  		ASSERT_TRUE (response.get<bool> ("valid_receive"));
2458  		std::string difficulty_text (response.get<std::string> ("difficulty"));
2459  		uint64_t difficulty;
2460  		ASSERT_FALSE (nano::from_string_hex (difficulty_text, difficulty));
2461  		ASSERT_GE (difficulty, node1->default_difficulty (nano::work_version::work_1));
2462  		double multiplier (response.get<double> ("multiplier"));
2463  		ASSERT_NEAR (multiplier, nano::difficulty::to_multiplier (difficulty, node1->default_difficulty (nano::work_version::work_1)), 1e-6);
2464  	}
2465  	uint64_t work2 (0);
2466  	request.put ("work", nano::to_string_hex (work2));
2467  	{
2468  		auto response (wait_response (system, rpc_ctx, request));
2469  		ASSERT_EQ (0, response.count ("valid"));
2470  		ASSERT_FALSE (response.get<bool> ("valid_all"));
2471  		ASSERT_FALSE (response.get<bool> ("valid_receive"));
2472  		std::string difficulty_text (response.get<std::string> ("difficulty"));
2473  		uint64_t difficulty;
2474  		ASSERT_FALSE (nano::from_string_hex (difficulty_text, difficulty));
2475  		ASSERT_GE (node1->default_difficulty (nano::work_version::work_1), difficulty);
2476  		double multiplier (response.get<double> ("multiplier"));
2477  		ASSERT_NEAR (multiplier, nano::difficulty::to_multiplier (difficulty, node1->default_difficulty (nano::work_version::work_1)), 1e-6);
2478  	}
2479  	auto result_difficulty (nano::dev::network_params.work.difficulty (nano::work_version::work_1, hash, work1));
2480  	ASSERT_GE (result_difficulty, node1->default_difficulty (nano::work_version::work_1));
2481  	request.put ("work", nano::to_string_hex (work1));
2482  	request.put ("difficulty", nano::to_string_hex (result_difficulty));
2483  	{
2484  		auto response (wait_response (system, rpc_ctx, request));
2485  		ASSERT_TRUE (response.get<bool> ("valid"));
2486  		ASSERT_TRUE (response.get<bool> ("valid_all"));
2487  		ASSERT_TRUE (response.get<bool> ("valid_receive"));
2488  	}
2489  	uint64_t difficulty4 (0xfff0000000000000);
2490  	request.put ("work", nano::to_string_hex (work1));
2491  	request.put ("difficulty", nano::to_string_hex (difficulty4));
2492  	{
2493  		auto response (wait_response (system, rpc_ctx, request));
2494  		ASSERT_EQ (result_difficulty >= difficulty4, response.get<bool> ("valid"));
2495  		ASSERT_EQ (result_difficulty >= node1->default_difficulty (nano::work_version::work_1), response.get<bool> ("valid_all"));
2496  		ASSERT_EQ (result_difficulty >= node1->network_params.work.epoch_2_receive, response.get<bool> ("valid_all"));
2497  	}
2498  	uint64_t work3 (*node1->work_generate_blocking (hash, difficulty4));
2499  	request.put ("work", nano::to_string_hex (work3));
2500  	{
2501  		auto response (wait_response (system, rpc_ctx, request));
2502  		ASSERT_TRUE (response.get<bool> ("valid"));
2503  		ASSERT_TRUE (response.get<bool> ("valid_all"));
2504  		ASSERT_TRUE (response.get<bool> ("valid_receive"));
2505  	}
2506  }
2507  TEST (rpc, work_validate_epoch_2)
2508  {
2509  	nano::test::system system;
2510  	auto node = add_ipc_enabled_node (system);
2511  	auto epoch1 = system.upgrade_genesis_epoch (*node, nano::epoch::epoch_1);
2512  	ASSERT_NE (nullptr, epoch1);
2513  	ASSERT_EQ (node->network_params.work.epoch_2, node->network_params.work.base);
2514  	auto work = system.work_generate_limited (epoch1->hash (), node->network_params.work.epoch_1, node->network_params.work.base);
2515  	auto const rpc_ctx = add_rpc (system, node);
2516  	boost::property_tree::ptree request;
2517  	request.put ("action", "work_validate");
2518  	request.put ("hash", epoch1->hash ().to_string ());
2519  	request.put ("work", nano::to_string_hex (work));
2520  	{
2521  		auto response (wait_response (system, rpc_ctx, request));
2522  		ASSERT_EQ (0, response.count ("valid"));
2523  		ASSERT_FALSE (response.get<bool> ("valid_all"));
2524  		ASSERT_TRUE (response.get<bool> ("valid_receive"));
2525  		std::string difficulty_text (response.get<std::string> ("difficulty"));
2526  		uint64_t difficulty{ 0 };
2527  		ASSERT_FALSE (nano::from_string_hex (difficulty_text, difficulty));
2528  		double multiplier (response.get<double> ("multiplier"));
2529  		ASSERT_NEAR (multiplier, nano::difficulty::to_multiplier (difficulty, node->network_params.work.epoch_2), 1e-6);
2530  	};
2531  	ASSERT_NE (nullptr, system.upgrade_genesis_epoch (*node, nano::epoch::epoch_2));
2532  	{
2533  		auto response (wait_response (system, rpc_ctx, request));
2534  		ASSERT_EQ (0, response.count ("valid"));
2535  		ASSERT_FALSE (response.get<bool> ("valid_all"));
2536  		ASSERT_TRUE (response.get<bool> ("valid_receive"));
2537  		std::string difficulty_text (response.get<std::string> ("difficulty"));
2538  		uint64_t difficulty{ 0 };
2539  		ASSERT_FALSE (nano::from_string_hex (difficulty_text, difficulty));
2540  		double multiplier (response.get<double> ("multiplier"));
2541  		ASSERT_NEAR (multiplier, nano::difficulty::to_multiplier (difficulty, node->default_difficulty (nano::work_version::work_1)), 1e-6);
2542  	};
2543  }
2544  TEST (rpc, successors)
2545  {
2546  	nano::test::system system;
2547  	auto node = add_ipc_enabled_node (system);
2548  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
2549  	nano::keypair key;
2550  	auto genesis (node->latest (nano::dev::genesis_key.pub));
2551  	ASSERT_FALSE (genesis.is_zero ());
2552  	auto block (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key.pub, 1));
2553  	ASSERT_NE (nullptr, block);
2554  	auto const rpc_ctx = add_rpc (system, node);
2555  	boost::property_tree::ptree request;
2556  	request.put ("action", "successors");
2557  	request.put ("block", genesis.to_string ());
2558  	request.put ("count", std::to_string (std::numeric_limits<uint64_t>::max ()));
2559  	auto response (wait_response (system, rpc_ctx, request));
2560  	auto & blocks_node (response.get_child ("blocks"));
2561  	std::vector<nano::block_hash> blocks;
2562  	for (auto i (blocks_node.begin ()), n (blocks_node.end ()); i != n; ++i)
2563  	{
2564  		blocks.push_back (nano::block_hash (i->second.get<std::string> ("")));
2565  	}
2566  	ASSERT_EQ (2, blocks.size ());
2567  	ASSERT_EQ (genesis, blocks[0]);
2568  	ASSERT_EQ (block->hash (), blocks[1]);
2569  	request.put ("action", "chain");
2570  	request.put ("reverse", "true");
2571  	auto response2 (wait_response (system, rpc_ctx, request, 10s));
2572  	ASSERT_EQ (response, response2);
2573  }
2574  TEST (rpc, bootstrap_any)
2575  {
2576  	nano::test::system system0;
2577  	auto node = add_ipc_enabled_node (system0);
2578  	nano::test::system system1 (1);
2579  	auto latest (system1.nodes[0]->latest (nano::dev::genesis_key.pub));
2580  	nano::block_builder builder;
2581  	auto send = builder
2582  				.send ()
2583  				.previous (latest)
2584  				.destination (nano::dev::genesis->account ())
2585  				.balance (100)
2586  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2587  				.work (*system1.nodes[0]->work_generate_blocking (latest))
2588  				.build ();
2589  	{
2590  		auto transaction (system1.nodes[0]->store.tx_begin_write ());
2591  		ASSERT_EQ (nano::process_result::progress, system1.nodes[0]->ledger.process (transaction, *send).code);
2592  	}
2593  	auto const rpc_ctx = add_rpc (system0, node);
2594  	boost::property_tree::ptree request;
2595  	request.put ("action", "bootstrap_any");
2596  	auto response (wait_response (system0, rpc_ctx, request));
2597  	std::string success (response.get<std::string> ("success"));
2598  	ASSERT_TRUE (success.empty ());
2599  }
2600  TEST (rpc, republish)
2601  {
2602  	nano::test::system system;
2603  	nano::keypair key;
2604  	auto node1 = add_ipc_enabled_node (system);
2605  	system.add_node ();
2606  	auto latest (node1->latest (nano::dev::genesis_key.pub));
2607  	nano::block_builder builder;
2608  	auto send = builder
2609  				.send ()
2610  				.previous (latest)
2611  				.destination (key.pub)
2612  				.balance (100)
2613  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2614  				.work (*node1->work_generate_blocking (latest))
2615  				.build ();
2616  	ASSERT_EQ (nano::process_result::progress, node1->process (*send).code);
2617  	auto open = builder
2618  				.open ()
2619  				.source (send->hash ())
2620  				.representative (key.pub)
2621  				.account (key.pub)
2622  				.sign (key.prv, key.pub)
2623  				.work (*node1->work_generate_blocking (key.pub))
2624  				.build ();
2625  	ASSERT_EQ (nano::process_result::progress, node1->process (*open).code);
2626  	auto const rpc_ctx = add_rpc (system, node1);
2627  	boost::property_tree::ptree request;
2628  	request.put ("action", "republish");
2629  	request.put ("hash", send->hash ().to_string ());
2630  	auto response (wait_response (system, rpc_ctx, request));
2631  	ASSERT_TIMELY (10s, system.nodes[1]->balance (nano::dev::genesis_key.pub) != nano::dev::constants.genesis_amount);
2632  	auto & blocks_node (response.get_child ("blocks"));
2633  	std::vector<nano::block_hash> blocks;
2634  	for (auto i (blocks_node.begin ()), n (blocks_node.end ()); i != n; ++i)
2635  	{
2636  		blocks.push_back (nano::block_hash (i->second.get<std::string> ("")));
2637  	}
2638  	ASSERT_EQ (1, blocks.size ());
2639  	ASSERT_EQ (send->hash (), blocks[0]);
2640  	request.put ("hash", nano::dev::genesis->hash ().to_string ());
2641  	request.put ("count", 1);
2642  	auto response1 (wait_response (system, rpc_ctx, request));
2643  	blocks_node = response1.get_child ("blocks");
2644  	blocks.clear ();
2645  	for (auto i (blocks_node.begin ()), n (blocks_node.end ()); i != n; ++i)
2646  	{
2647  		blocks.push_back (nano::block_hash (i->second.get<std::string> ("")));
2648  	}
2649  	ASSERT_EQ (1, blocks.size ());
2650  	ASSERT_EQ (nano::dev::genesis->hash (), blocks[0]);
2651  	request.put ("hash", open->hash ().to_string ());
2652  	request.put ("sources", 2);
2653  	auto response2 (wait_response (system, rpc_ctx, request));
2654  	blocks_node = response2.get_child ("blocks");
2655  	blocks.clear ();
2656  	for (auto i (blocks_node.begin ()), n (blocks_node.end ()); i != n; ++i)
2657  	{
2658  		blocks.push_back (nano::block_hash (i->second.get<std::string> ("")));
2659  	}
2660  	ASSERT_EQ (3, blocks.size ());
2661  	ASSERT_EQ (nano::dev::genesis->hash (), blocks[0]);
2662  	ASSERT_EQ (send->hash (), blocks[1]);
2663  	ASSERT_EQ (open->hash (), blocks[2]);
2664  }
2665  TEST (rpc, deterministic_key)
2666  {
2667  	nano::test::system system0;
2668  	auto node = add_ipc_enabled_node (system0);
2669  	nano::raw_key seed;
2670  	{
2671  		auto transaction (system0.nodes[0]->wallets.tx_begin_read ());
2672  		system0.wallet (0)->store.seed (seed, transaction);
2673  	}
2674  	nano::account account0 (system0.wallet (0)->deterministic_insert ());
2675  	nano::account account1 (system0.wallet (0)->deterministic_insert ());
2676  	nano::account account2 (system0.wallet (0)->deterministic_insert ());
2677  	auto const rpc_ctx = add_rpc (system0, node);
2678  	boost::property_tree::ptree request;
2679  	request.put ("action", "deterministic_key");
2680  	request.put ("seed", seed.to_string ());
2681  	request.put ("index", "0");
2682  	auto response0 (wait_response (system0, rpc_ctx, request));
2683  	std::string validate_text (response0.get<std::string> ("account"));
2684  	ASSERT_EQ (account0.to_account (), validate_text);
2685  	request.put ("index", "2");
2686  	auto response1 (wait_response (system0, rpc_ctx, request));
2687  	validate_text = response1.get<std::string> ("account");
2688  	ASSERT_NE (account1.to_account (), validate_text);
2689  	ASSERT_EQ (account2.to_account (), validate_text);
2690  }
2691  TEST (rpc, accounts_balances)
2692  {
2693  	nano::test::system system;
2694  	auto node = add_ipc_enabled_node (system);
2695  	auto const rpc_ctx = add_rpc (system, node);
2696  	boost::property_tree::ptree request;
2697  	request.put ("action", "accounts_balances");
2698  	boost::property_tree::ptree accounts_l;
2699  	boost::property_tree::ptree entry1;
2700  	entry1.put ("", nano::dev::genesis_key.pub.to_account ());
2701  	accounts_l.push_back (std::make_pair ("", entry1));
2702  	boost::property_tree::ptree entry2;
2703  	auto const account_not_found = "nano_1os6txqxyuesnxrtshnfb5or1hesc1647wpk9rsr84pmki6eairwha79hk3j";
2704  	entry2.put ("", account_not_found);
2705  	accounts_l.push_back (std::make_pair ("", entry2));
2706  	request.add_child ("accounts", accounts_l);
2707  	auto response (wait_response (system, rpc_ctx, request));
2708  	auto genesis_entry = response.get_child (boost::str (boost::format ("balances.%1%") % nano::dev::genesis_key.pub.to_account ()));
2709  	auto balance_text = genesis_entry.get<std::string> ("balance");
2710  	ASSERT_EQ ("340282366920938463463374607431768211455", balance_text);
2711  	auto receivable_text = genesis_entry.get<std::string> ("receivable");
2712  	ASSERT_EQ ("0", receivable_text);
2713  	auto account_not_found_entry = response.get_child (boost::str (boost::format ("balances.%1%") % account_not_found));
2714  	auto account_balance_text = account_not_found_entry.get<std::string> ("balance");
2715  	ASSERT_EQ ("0", account_balance_text);
2716  	auto account_receivable_text = account_not_found_entry.get<std::string> ("receivable");
2717  	ASSERT_EQ ("0", account_receivable_text);
2718  	auto balances = response.get_child ("balances");
2719  	ASSERT_EQ (2, balances.size ());
2720  	auto errors = response.get_child_optional ("errors");
2721  	ASSERT_FALSE (errors.has_value ());
2722  }
2723  TEST (rpc, accounts_balances_with_errors)
2724  {
2725  	nano::test::system system;
2726  	auto node = add_ipc_enabled_node (system);
2727  	auto const rpc_ctx = add_rpc (system, node);
2728  	boost::property_tree::ptree request;
2729  	request.put ("action", "accounts_balances");
2730  	boost::property_tree::ptree accounts_l;
2731  	boost::property_tree::ptree entry;
2732  	auto const bad_account_number = "nano_3e3j5tkog48pnny9dmfzj1r16pg8t1e76dz5tmac6iq689wyjfpiij4txtd1";
2733  	entry.put ("", bad_account_number);
2734  	accounts_l.push_back (std::make_pair ("", entry));
2735  	request.add_child ("accounts", accounts_l);
2736  	auto response (wait_response (system, rpc_ctx, request));
2737  	auto balances = response.get_child_optional ("balances");
2738  	ASSERT_FALSE (balances.has_value ());
2739  	auto get_error_message = [] (nano::error_common error_common) -> std::string {
2740  		std::error_code ec = error_common;
2741  		return ec.message ();
2742  	};
2743  	auto errors = response.get_child ("errors");
2744  	ASSERT_EQ (1, errors.size ());
2745  	ASSERT_EQ (1, errors.count (bad_account_number));
2746  	auto bad_account_number_error_text = errors.get<std::string> (bad_account_number);
2747  	ASSERT_EQ (get_error_message (nano::error_common::bad_account_number), bad_account_number_error_text);
2748  }
2749  TEST (rpc, accounts_balances_unopened_account_with_receivables)
2750  {
2751  	nano::test::system system;
2752  	nano::node_config config;
2753  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
2754  	auto node = add_ipc_enabled_node (system, config);
2755  	nano::keypair unopened_account;
2756  	auto send = nano::state_block_builder{}
2757  				.account (nano::dev::genesis_key.pub)
2758  				.previous (nano::dev::genesis->hash ())
2759  				.representative (nano::dev::genesis_key.pub)
2760  				.balance (nano::dev::constants.genesis_amount - 1)
2761  				.link (unopened_account.pub)
2762  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2763  				.work (*node->work_generate_blocking (nano::dev::genesis->hash ()))
2764  				.build_shared ();
2765  	{
2766  		auto transaction = node->store.tx_begin_write ();
2767  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *send).code);
2768  	}
2769  	ASSERT_TIMELY (5s, node->block (send->hash ()));
2770  	ASSERT_TIMELY (5s, !node->active.active (*send));
2771  	auto const rpc_ctx = add_rpc (system, node);
2772  	boost::property_tree::ptree request;
2773  	boost::property_tree::ptree accounts_l;
2774  	boost::property_tree::ptree entry;
2775  	entry.put ("", unopened_account.pub.to_account ());
2776  	accounts_l.push_back (std::make_pair ("", entry));
2777  	request.add_child ("accounts", accounts_l);
2778  	request.put ("action", "accounts_balances");
2779  	auto response = wait_response (system, rpc_ctx, request);
2780  	auto response_entry = response.get_child ("balances." + unopened_account.pub.to_account ());
2781  	ASSERT_EQ ("0", response_entry.get<std::string> ("balance"));
2782  	ASSERT_EQ ("0", response_entry.get<std::string> ("receivable"));
2783  	request.put ("include_only_confirmed", "false");
2784  	response = wait_response (system, rpc_ctx, request);
2785  	response_entry = response.get_child ("balances." + unopened_account.pub.to_account ());
2786  	ASSERT_EQ ("0", response_entry.get<std::string> ("balance"));
2787  	ASSERT_EQ ("1", response_entry.get<std::string> ("receivable"));
2788  	request.put ("include_only_confirmed", "true");
2789  	response = wait_response (system, rpc_ctx, request);
2790  	response_entry = response.get_child ("balances." + unopened_account.pub.to_account ());
2791  	ASSERT_EQ ("0", response_entry.get<std::string> ("balance"));
2792  	ASSERT_EQ ("0", response_entry.get<std::string> ("receivable"));
2793  }
2794  TEST (rpc, accounts_representatives)
2795  {
2796  	nano::test::system system;
2797  	auto node = add_ipc_enabled_node (system);
2798  	auto const rpc_ctx = add_rpc (system, node);
2799  	boost::property_tree::ptree request;
2800  	request.put ("action", "accounts_representatives");
2801  	boost::property_tree::ptree entry;
2802  	boost::property_tree::ptree accounts;
2803  	entry.put ("", nano::dev::genesis_key.pub.to_account ());
2804  	accounts.push_back (std::make_pair ("", entry));
2805  	request.add_child ("accounts", accounts);
2806  	auto response (wait_response (system, rpc_ctx, request));
2807  	auto response_representative (response.get_child ("representatives").get<std::string> (nano::dev::genesis->account ().to_account ()));
2808  	ASSERT_EQ (response_representative, nano::dev::genesis->account ().to_account ());
2809  	ASSERT_EQ (response.count ("errors"), 0);
2810  }
2811  TEST (rpc, accounts_representatives_with_errors)
2812  {
2813  	nano::test::system system;
2814  	auto node = add_ipc_enabled_node (system);
2815  	auto const rpc_ctx = add_rpc (system, node);
2816  	boost::property_tree::ptree request;
2817  	request.put ("action", "accounts_representatives");
2818  	boost::property_tree::ptree entry1, entry2, entry3;
2819  	boost::property_tree::ptree accounts_l;
2820  	entry1.put ("", nano::dev::genesis_key.pub.to_account ());
2821  	accounts_l.push_back (std::make_pair ("", entry1));
2822  	auto const bad_account_number = "nano_36uccgpjzhjsdbj44wm1y5hyz8gefx3wjpp1jircxt84nopxkxti5bzq1rnz";
2823  	entry2.put ("", bad_account_number);
2824  	accounts_l.push_back (std::make_pair ("", entry2));
2825  	auto const account_not_found = "nano_1hrts7hcoozxccnffoq9hqhngnn9jz783usapejm57ejtqcyz9dpso1bibuy";
2826  	entry3.put ("", account_not_found);
2827  	accounts_l.push_back (std::make_pair ("", entry3));
2828  	request.add_child ("accounts", accounts_l);
2829  	auto response (wait_response (system, rpc_ctx, request));
2830  	ASSERT_EQ (response.count ("representatives"), 1);
2831  	ASSERT_EQ (response.get_child ("representatives").size (), 1);
2832  	ASSERT_EQ (response.get_child ("representatives").count (nano::dev::genesis_key.pub.to_account ()), 1);
2833  	auto rep_text = response.get_child ("representatives").get<std::string> (nano::dev::genesis_key.pub.to_account ());
2834  	ASSERT_EQ (rep_text, nano::dev::genesis->account ().to_account ());
2835  	ASSERT_EQ (response.count ("errors"), 1);
2836  	ASSERT_EQ (response.get_child ("errors").size (), 2);
2837  	ASSERT_EQ (response.get_child ("errors").count (bad_account_number), 1);
2838  	ASSERT_EQ (response.get_child ("errors").count (account_not_found), 1);
2839  	ASSERT_EQ (response.get_child ("errors").get<std::string> (bad_account_number), make_error_code (nano::error_common::bad_account_number).message ());
2840  	ASSERT_EQ (response.get_child ("errors").get<std::string> (account_not_found), make_error_code (nano::error_common::account_not_found).message ());
2841  }
2842  TEST (rpc, accounts_frontiers)
2843  {
2844  	nano::test::system system;
2845  	auto node = add_ipc_enabled_node (system);
2846  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
2847  	auto const rpc_ctx = add_rpc (system, node);
2848  	boost::property_tree::ptree request;
2849  	request.put ("action", "accounts_frontiers");
2850  	boost::property_tree::ptree accounts_l;
2851  	boost::property_tree::ptree entry1;
2852  	entry1.put ("", nano::dev::genesis_key.pub.to_account ());
2853  	accounts_l.push_back (std::make_pair ("", entry1));
2854  	request.add_child ("accounts", accounts_l);
2855  	auto response (wait_response (system, rpc_ctx, request));
2856  	ASSERT_EQ (response.count ("frontiers"), 1);
2857  	ASSERT_EQ (response.get_child ("frontiers").size (), 1);
2858  	ASSERT_EQ (response.get_child ("frontiers").count (nano::dev::genesis_key.pub.to_account ()), 1);
2859  	auto frontier_text = response.get_child ("frontiers").get<std::string> (nano::dev::genesis_key.pub.to_account ());
2860  	ASSERT_EQ (nano::block_hash{ frontier_text }, node->latest (nano::dev::genesis->account ()));
2861  	ASSERT_EQ (response.count ("errors"), 0);
2862  }
2863  TEST (rpc, accounts_frontiers_with_errors)
2864  {
2865  	nano::test::system system;
2866  	auto node = add_ipc_enabled_node (system);
2867  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
2868  	auto const rpc_ctx = add_rpc (system, node);
2869  	boost::property_tree::ptree request;
2870  	request.put ("action", "accounts_frontiers");
2871  	boost::property_tree::ptree accounts_l;
2872  	boost::property_tree::ptree entry1;
2873  	entry1.put ("", nano::dev::genesis_key.pub.to_account ());
2874  	accounts_l.push_back (std::make_pair ("", entry1));
2875  	boost::property_tree::ptree entry2;
2876  	auto const bad_account_number = "nano_3e3j5tkog48pnny9dmfzj1r16pg8t1e76dz5tmac6iq689wyjfpiij4txtd1";
2877  	entry2.put ("", bad_account_number);
2878  	accounts_l.push_back (std::make_pair ("", entry2));
2879  	boost::property_tree::ptree entry3;
2880  	auto const account_not_found = "nano_1os6txqxyuesnxrtshnfb5or1hesc1647wpk9rsr84pmki6eairwha79hk3j";
2881  	entry3.put ("", account_not_found);
2882  	accounts_l.push_back (std::make_pair ("", entry3));
2883  	request.add_child ("accounts", accounts_l);
2884  	auto response (wait_response (system, rpc_ctx, request));
2885  	ASSERT_EQ (response.count ("frontiers"), 1);
2886  	ASSERT_EQ (response.get_child ("frontiers").size (), 1);
2887  	ASSERT_EQ (response.get_child ("frontiers").count (nano::dev::genesis_key.pub.to_account ()), 1);
2888  	auto frontier_text = response.get_child ("frontiers").get<std::string> (nano::dev::genesis_key.pub.to_account ());
2889  	ASSERT_EQ (nano::block_hash{ frontier_text }, node->latest (nano::dev::genesis->account ()));
2890  	ASSERT_EQ (response.count ("errors"), 1);
2891  	ASSERT_EQ (response.get_child ("errors").size (), 2);
2892  	ASSERT_EQ (response.get_child ("errors").count (bad_account_number), 1);
2893  	ASSERT_EQ (response.get_child ("errors").count (account_not_found), 1);
2894  	ASSERT_EQ (response.get_child ("errors").get<std::string> (bad_account_number), make_error_code (nano::error_common::bad_account_number).message ());
2895  	ASSERT_EQ (response.get_child ("errors").get<std::string> (account_not_found), make_error_code (nano::error_common::account_not_found).message ());
2896  }
2897  TEST (rpc, blocks)
2898  {
2899  	nano::test::system system;
2900  	auto node = add_ipc_enabled_node (system);
2901  	auto const rpc_ctx = add_rpc (system, node);
2902  	boost::property_tree::ptree request;
2903  	request.put ("action", "blocks");
2904  	boost::property_tree::ptree entry;
2905  	boost::property_tree::ptree peers_l;
2906  	entry.put ("", node->latest (nano::dev::genesis->account ()).to_string ());
2907  	peers_l.push_back (std::make_pair ("", entry));
2908  	request.add_child ("hashes", peers_l);
2909  	auto response (wait_response (system, rpc_ctx, request));
2910  	for (auto & blocks : response.get_child ("blocks"))
2911  	{
2912  		std::string hash_text (blocks.first);
2913  		ASSERT_EQ (node->latest (nano::dev::genesis->account ()).to_string (), hash_text);
2914  		std::string blocks_text (blocks.second.get<std::string> (""));
2915  		ASSERT_FALSE (blocks_text.empty ());
2916  	}
2917  }
2918  TEST (rpc, wallet_info)
2919  {
2920  	nano::test::system system;
2921  	nano::node_config node_config = system.default_config ();
2922  	node_config.enable_voting = true;
2923  	auto node = add_ipc_enabled_node (system, node_config);
2924  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
2925  	nano::keypair key;
2926  	system.wallet (0)->insert_adhoc (key.prv);
2927  	auto send (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key.pub, nano::Gxrb_ratio));
2928  	ASSERT_TIMELY (5s, node->block_confirmed (send->hash ())); 
2929  	ASSERT_TIMELY (5s, !node->latest (key.pub).is_zero ()); 
2930  	ASSERT_TIMELY (5s, node->block_confirmed (node->latest (key.pub))); 
2931  	auto send2 (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key.pub, 1));
2932  	ASSERT_TIMELY (5s, node->block_confirmed (send2->hash ()));
2933  	nano::account account (system.wallet (0)->deterministic_insert ());
2934  	{
2935  		auto transaction (node->wallets.tx_begin_write ());
2936  		system.wallet (0)->store.erase (transaction, account);
2937  	}
2938  	account = system.wallet (0)->deterministic_insert ();
2939  	auto const rpc_ctx = add_rpc (system, node);
2940  	boost::property_tree::ptree request;
2941  	request.put ("action", "wallet_info");
2942  	request.put ("wallet", node->wallets.items.begin ()->first.to_string ());
2943  	auto response (wait_response (system, rpc_ctx, request));
2944  	std::string balance_text (response.get<std::string> ("balance"));
2945  	ASSERT_EQ ("340282366920938463463374607431768211454", balance_text);
2946  	std::string pending_text (response.get<std::string> ("pending"));
2947  	ASSERT_EQ ("1", pending_text);
2948  	std::string count_text (response.get<std::string> ("accounts_count"));
2949  	ASSERT_EQ ("3", count_text);
2950  	std::string block_count_text (response.get<std::string> ("accounts_block_count"));
2951  	ASSERT_EQ ("4", block_count_text);
2952  	std::string cemented_block_count_text (response.get<std::string> ("accounts_cemented_block_count"));
2953  	ASSERT_EQ ("4", cemented_block_count_text);
2954  	std::string adhoc_count (response.get<std::string> ("adhoc_count"));
2955  	ASSERT_EQ ("2", adhoc_count);
2956  	std::string deterministic_count (response.get<std::string> ("deterministic_count"));
2957  	ASSERT_EQ ("1", deterministic_count);
2958  	std::string index_text (response.get<std::string> ("deterministic_index"));
2959  	ASSERT_EQ ("2", index_text);
2960  }
2961  TEST (rpc, wallet_balances)
2962  {
2963  	nano::test::system system0;
2964  	auto node = add_ipc_enabled_node (system0);
2965  	system0.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
2966  	auto const rpc_ctx = add_rpc (system0, node);
2967  	boost::property_tree::ptree request;
2968  	request.put ("action", "wallet_balances");
2969  	request.put ("wallet", node->wallets.items.begin ()->first.to_string ());
2970  	auto response (wait_response (system0, rpc_ctx, request));
2971  	for (auto & balances : response.get_child ("balances"))
2972  	{
2973  		std::string account_text (balances.first);
2974  		ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), account_text);
2975  		std::string balance_text (balances.second.get<std::string> ("balance"));
2976  		ASSERT_EQ ("340282366920938463463374607431768211455", balance_text);
2977  		std::string pending_text (balances.second.get<std::string> ("pending"));
2978  		ASSERT_EQ ("0", pending_text);
2979  	}
2980  	nano::keypair key;
2981  	system0.wallet (0)->insert_adhoc (key.prv);
2982  	auto send (system0.wallet (0)->send_action (nano::dev::genesis_key.pub, key.pub, 1));
2983  	request.put ("threshold", "2");
2984  	auto response1 (wait_response (system0, rpc_ctx, request));
2985  	for (auto & balances : response1.get_child ("balances"))
2986  	{
2987  		std::string account_text (balances.first);
2988  		ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), account_text);
2989  		std::string balance_text (balances.second.get<std::string> ("balance"));
2990  		ASSERT_EQ ("340282366920938463463374607431768211454", balance_text);
2991  		std::string pending_text (balances.second.get<std::string> ("pending"));
2992  		ASSERT_EQ ("0", pending_text);
2993  	}
2994  }
2995  TEST (rpc, pending_exists)
2996  {
2997  	nano::test::system system;
2998  	nano::node_config config;
2999  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
3000  	auto node = add_ipc_enabled_node (system, config);
3001  	nano::keypair key1;
3002  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
3003  	auto hash0 (node->latest (nano::dev::genesis->account ()));
3004  	auto block1 (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key1.pub, 100));
3005  	ASSERT_TIMELY (5s, node->block_confirmed (block1->hash ()));
3006  	ASSERT_TIMELY (5s, !node->active.active (*block1));
3007  	auto const rpc_ctx = add_rpc (system, node);
3008  	boost::property_tree::ptree request;
3009  	auto pending_exists = [&system, &rpc_ctx, &request] (char const * exists_a) {
3010  		auto response0 (wait_response (system, rpc_ctx, request));
3011  		std::string exists_text (response0.get<std::string> ("exists"));
3012  		return exists_a == exists_text;
3013  	};
3014  	request.put ("action", "pending_exists");
3015  	request.put ("hash", hash0.to_string ());
3016  	ASSERT_TRUE (pending_exists ("0"));
3017  	node->store.pending.exists (node->store.tx_begin_read (), nano::pending_key (nano::dev::genesis_key.pub, block1->hash ()));
3018  	request.put ("hash", block1->hash ().to_string ());
3019  	ASSERT_TRUE (pending_exists ("1"));
3020  	ASSERT_TRUE (pending_exists ("1"));
3021  	reset_confirmation_height (node->store, block1->account ());
3022  	ASSERT_TRUE (pending_exists ("0"));
3023  	request.put ("include_only_confirmed", "false");
3024  	ASSERT_TRUE (pending_exists ("1"));
3025  }
3026  TEST (rpc, wallet_pending)
3027  {
3028  	nano::test::system system;
3029  	auto node = add_ipc_enabled_node (system);
3030  	nano::keypair key1;
3031  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
3032  	system.wallet (0)->insert_adhoc (key1.prv);
3033  	auto block1 = system.wallet (0)->send_action (nano::dev::genesis_key.pub, key1.pub, 100);
3034  	ASSERT_TIMELY (5s, node->get_confirmation_height (node->store.tx_begin_read (), nano::dev::genesis_key.pub) == 2);
3035  	auto const rpc_ctx = add_rpc (system, node);
3036  	boost::property_tree::ptree request;
3037  	request.put ("action", "wallet_pending");
3038  	request.put ("wallet", node->wallets.items.begin ()->first.to_string ());
3039  	auto response (wait_response (system, rpc_ctx, request));
3040  	ASSERT_EQ ("1", response.get<std::string> ("deprecated"));
3041  	ASSERT_EQ (1, response.get_child ("blocks").size ());
3042  	auto pending = response.get_child ("blocks").front ();
3043  	ASSERT_EQ (key1.pub.to_account (), pending.first);
3044  	nano::block_hash hash1{ pending.second.begin ()->second.get<std::string> ("") };
3045  	ASSERT_EQ (block1->hash (), hash1);
3046  }
3047  TEST (rpc, wallet_receivable)
3048  {
3049  	nano::test::system system;
3050  	nano::node_config config;
3051  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
3052  	auto node = add_ipc_enabled_node (system, config);
3053  	nano::keypair key1;
3054  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
3055  	system.wallet (0)->insert_adhoc (key1.prv);
3056  	auto iterations (0);
3057  	auto block1 (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key1.pub, 100));
3058  	ASSERT_TIMELY (5s, node->block_confirmed (block1->hash ()));
3059  	ASSERT_TIMELY (5s, !node->active.active (*block1));
3060  	auto const rpc_ctx = add_rpc (system, node);
3061  	boost::property_tree::ptree request;
3062  	request.put ("action", "wallet_receivable");
3063  	request.put ("wallet", node->wallets.items.begin ()->first.to_string ());
3064  	request.put ("count", "100");
3065  	auto response (wait_response (system, rpc_ctx, request));
3066  	ASSERT_EQ (1, response.get_child ("blocks").size ());
3067  	for (auto & pending : response.get_child ("blocks"))
3068  	{
3069  		std::string account_text (pending.first);
3070  		ASSERT_EQ (key1.pub.to_account (), account_text);
3071  		nano::block_hash hash1 (pending.second.begin ()->second.get<std::string> (""));
3072  		ASSERT_EQ (block1->hash (), hash1);
3073  	}
3074  	request.put ("threshold", "100"); 
3075  	auto response0 (wait_response (system, rpc_ctx, request));
3076  	std::unordered_map<nano::block_hash, nano::uint128_union> blocks;
3077  	ASSERT_EQ (1, response0.get_child ("blocks").size ());
3078  	for (auto & pending : response0.get_child ("blocks"))
3079  	{
3080  		std::string account_text (pending.first);
3081  		ASSERT_EQ (key1.pub.to_account (), account_text);
3082  		for (auto i (pending.second.begin ()), j (pending.second.end ()); i != j; ++i)
3083  		{
3084  			nano::block_hash hash;
3085  			hash.decode_hex (i->first);
3086  			nano::uint128_union amount;
3087  			amount.decode_dec (i->second.get<std::string> (""));
3088  			blocks[hash] = amount;
3089  			boost::optional<std::string> source (i->second.get_optional<std::string> ("source"));
3090  			ASSERT_FALSE (source.is_initialized ());
3091  			boost::optional<uint8_t> min_version (i->second.get_optional<uint8_t> ("min_version"));
3092  			ASSERT_FALSE (min_version.is_initialized ());
3093  		}
3094  	}
3095  	ASSERT_EQ (blocks[block1->hash ()], 100);
3096  	request.put ("threshold", "101");
3097  	auto response1 (wait_response (system, rpc_ctx, request));
3098  	auto & pending1 (response1.get_child ("blocks"));
3099  	ASSERT_EQ (0, pending1.size ());
3100  	request.put ("threshold", "0");
3101  	request.put ("source", "true");
3102  	request.put ("min_version", "true");
3103  	auto response2 (wait_response (system, rpc_ctx, request));
3104  	std::unordered_map<nano::block_hash, nano::uint128_union> amounts;
3105  	std::unordered_map<nano::block_hash, nano::account> sources;
3106  	ASSERT_EQ (1, response2.get_child ("blocks").size ());
3107  	for (auto & pending : response2.get_child ("blocks"))
3108  	{
3109  		std::string account_text (pending.first);
3110  		ASSERT_EQ (key1.pub.to_account (), account_text);
3111  		for (auto i (pending.second.begin ()), j (pending.second.end ()); i != j; ++i)
3112  		{
3113  			nano::block_hash hash;
3114  			hash.decode_hex (i->first);
3115  			amounts[hash].decode_dec (i->second.get<std::string> ("amount"));
3116  			sources[hash].decode_account (i->second.get<std::string> ("source"));
3117  			ASSERT_EQ (i->second.get<uint8_t> ("min_version"), 0);
3118  		}
3119  	}
3120  	ASSERT_EQ (amounts[block1->hash ()], 100);
3121  	ASSERT_EQ (sources[block1->hash ()], nano::dev::genesis_key.pub);
3122  	ASSERT_TRUE (check_block_response_count (system, rpc_ctx, request, 1));
3123  	reset_confirmation_height (system.nodes.front ()->store, block1->account ());
3124  	ASSERT_TRUE (check_block_response_count (system, rpc_ctx, request, 0));
3125  	request.put ("include_only_confirmed", "false");
3126  	ASSERT_TRUE (check_block_response_count (system, rpc_ctx, request, 1));
3127  }
3128  TEST (rpc, receive_minimum)
3129  {
3130  	nano::test::system system;
3131  	auto node = add_ipc_enabled_node (system);
3132  	auto const rpc_ctx = add_rpc (system, node);
3133  	boost::property_tree::ptree request;
3134  	request.put ("action", "receive_minimum");
3135  	auto response (wait_response (system, rpc_ctx, request));
3136  	std::string amount (response.get<std::string> ("amount"));
3137  	ASSERT_EQ (node->config.receive_minimum.to_string_dec (), amount);
3138  }
3139  TEST (rpc, receive_minimum_set)
3140  {
3141  	nano::test::system system;
3142  	auto node = add_ipc_enabled_node (system);
3143  	auto const rpc_ctx = add_rpc (system, node);
3144  	boost::property_tree::ptree request;
3145  	request.put ("action", "receive_minimum_set");
3146  	request.put ("amount", "100");
3147  	ASSERT_NE (node->config.receive_minimum.to_string_dec (), "100");
3148  	auto response (wait_response (system, rpc_ctx, request));
3149  	std::string success (response.get<std::string> ("success"));
3150  	ASSERT_TRUE (success.empty ());
3151  	ASSERT_EQ (node->config.receive_minimum.to_string_dec (), "100");
3152  }
3153  TEST (rpc, work_get)
3154  {
3155  	nano::test::system system;
3156  	auto node = add_ipc_enabled_node (system);
3157  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
3158  	system.wallet (0)->work_cache_blocking (nano::dev::genesis_key.pub, node->latest (nano::dev::genesis_key.pub));
3159  	auto const rpc_ctx = add_rpc (system, node);
3160  	boost::property_tree::ptree request;
3161  	request.put ("action", "work_get");
3162  	request.put ("wallet", node->wallets.items.begin ()->first.to_string ());
3163  	request.put ("account", nano::dev::genesis_key.pub.to_account ());
3164  	auto response (wait_response (system, rpc_ctx, request));
3165  	std::string work_text (response.get<std::string> ("work"));
3166  	uint64_t work (1);
3167  	auto transaction (node->wallets.tx_begin_read ());
3168  	node->wallets.items.begin ()->second->store.work_get (transaction, nano::dev::genesis->account (), work);
3169  	ASSERT_EQ (nano::to_string_hex (work), work_text);
3170  }
3171  TEST (rpc, wallet_work_get)
3172  {
3173  	nano::test::system system;
3174  	auto node = add_ipc_enabled_node (system);
3175  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
3176  	system.wallet (0)->work_cache_blocking (nano::dev::genesis_key.pub, node->latest (nano::dev::genesis_key.pub));
3177  	auto const rpc_ctx = add_rpc (system, node);
3178  	boost::property_tree::ptree request;
3179  	request.put ("action", "wallet_work_get");
3180  	request.put ("wallet", node->wallets.items.begin ()->first.to_string ());
3181  	auto response (wait_response (system, rpc_ctx, request));
3182  	auto transaction (node->wallets.tx_begin_read ());
3183  	for (auto & works : response.get_child ("works"))
3184  	{
3185  		std::string account_text (works.first);
3186  		ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), account_text);
3187  		std::string work_text (works.second.get<std::string> (""));
3188  		uint64_t work (1);
3189  		node->wallets.items.begin ()->second->store.work_get (transaction, nano::dev::genesis->account (), work);
3190  		ASSERT_EQ (nano::to_string_hex (work), work_text);
3191  	}
3192  }
3193  TEST (rpc, work_set)
3194  {
3195  	nano::test::system system;
3196  	auto node = add_ipc_enabled_node (system);
3197  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
3198  	auto const rpc_ctx = add_rpc (system, node);
3199  	uint64_t work0 (100);
3200  	boost::property_tree::ptree request;
3201  	request.put ("action", "work_set");
3202  	request.put ("wallet", node->wallets.items.begin ()->first.to_string ());
3203  	request.put ("account", nano::dev::genesis_key.pub.to_account ());
3204  	request.put ("work", nano::to_string_hex (work0));
3205  	auto response (wait_response (system, rpc_ctx, request));
3206  	std::string success (response.get<std::string> ("success"));
3207  	ASSERT_TRUE (success.empty ());
3208  	uint64_t work1 (1);
3209  	auto transaction (node->wallets.tx_begin_read ());
3210  	node->wallets.items.begin ()->second->store.work_get (transaction, nano::dev::genesis->account (), work1);
3211  	ASSERT_EQ (work1, work0);
3212  }
3213  TEST (rpc, search_receivable_all)
3214  {
3215  	nano::test::system system;
3216  	auto node = add_ipc_enabled_node (system);
3217  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
3218  	auto latest (node->latest (nano::dev::genesis_key.pub));
3219  	nano::block_builder builder;
3220  	auto block = builder
3221  				 .send ()
3222  				 .previous (latest)
3223  				 .destination (nano::dev::genesis_key.pub)
3224  				 .balance (nano::dev::constants.genesis_amount - node->config.receive_minimum.number ())
3225  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3226  				 .work (*node->work_generate_blocking (latest))
3227  				 .build ();
3228  	{
3229  		auto transaction (node->store.tx_begin_write ());
3230  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *block).code);
3231  	}
3232  	auto const rpc_ctx = add_rpc (system, node);
3233  	boost::property_tree::ptree request;
3234  	request.put ("action", "search_receivable_all");
3235  	auto response (wait_response (system, rpc_ctx, request));
3236  	ASSERT_TIMELY (10s, node->balance (nano::dev::genesis_key.pub) == nano::dev::constants.genesis_amount);
3237  }
3238  TEST (rpc, wallet_republish)
3239  {
3240  	nano::test::system system;
3241  	auto node1 = add_ipc_enabled_node (system);
3242  	nano::keypair key;
3243  	while (key.pub < nano::dev::genesis_key.pub)
3244  	{
3245  		nano::keypair key1;
3246  		key.pub = key1.pub;
3247  		key.prv = key1.prv;
3248  	}
3249  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
3250  	system.wallet (0)->insert_adhoc (key.prv);
3251  	auto latest (node1->latest (nano::dev::genesis_key.pub));
3252  	nano::block_builder builder;
3253  	auto send = builder
3254  				.send ()
3255  				.previous (latest)
3256  				.destination (key.pub)
3257  				.balance (100)
3258  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3259  				.work (*node1->work_generate_blocking (latest))
3260  				.build ();
3261  	ASSERT_EQ (nano::process_result::progress, node1->process (*send).code);
3262  	auto open = builder
3263  				.open ()
3264  				.source (send->hash ())
3265  				.representative (key.pub)
3266  				.account (key.pub)
3267  				.sign (key.prv, key.pub)
3268  				.work (*node1->work_generate_blocking (key.pub))
3269  				.build ();
3270  	ASSERT_EQ (nano::process_result::progress, node1->process (*open).code);
3271  	auto const rpc_ctx = add_rpc (system, node1);
3272  	boost::property_tree::ptree request;
3273  	request.put ("action", "wallet_republish");
3274  	request.put ("wallet", node1->wallets.items.begin ()->first.to_string ());
3275  	request.put ("count", 1);
3276  	auto response (wait_response (system, rpc_ctx, request));
3277  	auto & blocks_node (response.get_child ("blocks"));
3278  	std::vector<nano::block_hash> blocks;
3279  	for (auto i (blocks_node.begin ()), n (blocks_node.end ()); i != n; ++i)
3280  	{
3281  		blocks.emplace_back (i->second.get<std::string> (""));
3282  	}
3283  	ASSERT_EQ (2, blocks.size ());
3284  	ASSERT_EQ (send->hash (), blocks[0]);
3285  	ASSERT_EQ (open->hash (), blocks[1]);
3286  }
3287  TEST (rpc, delegators)
3288  {
3289  	nano::test::system system;
3290  	auto node1 = add_ipc_enabled_node (system);
3291  	nano::keypair key;
3292  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
3293  	system.wallet (0)->insert_adhoc (key.prv);
3294  	auto latest (node1->latest (nano::dev::genesis_key.pub));
3295  	nano::block_builder builder;
3296  	auto send = builder
3297  				.send ()
3298  				.previous (latest)
3299  				.destination (key.pub)
3300  				.balance (100)
3301  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3302  				.work (*node1->work_generate_blocking (latest))
3303  				.build ();
3304  	ASSERT_EQ (nano::process_result::progress, node1->process (*send).code);
3305  	auto open = builder
3306  				.open ()
3307  				.source (send->hash ())
3308  				.representative (nano::dev::genesis_key.pub)
3309  				.account (key.pub)
3310  				.sign (key.prv, key.pub)
3311  				.work (*node1->work_generate_blocking (key.pub))
3312  				.build ();
3313  	ASSERT_EQ (nano::process_result::progress, node1->process (*open).code);
3314  	auto const rpc_ctx = add_rpc (system, node1);
3315  	boost::property_tree::ptree request;
3316  	request.put ("action", "delegators");
3317  	request.put ("account", nano::dev::genesis_key.pub.to_account ());
3318  	auto response (wait_response (system, rpc_ctx, request));
3319  	auto & delegators_node (response.get_child ("delegators"));
3320  	boost::property_tree::ptree delegators;
3321  	for (auto i (delegators_node.begin ()), n (delegators_node.end ()); i != n; ++i)
3322  	{
3323  		delegators.put ((i->first), (i->second.get<std::string> ("")));
3324  	}
3325  	ASSERT_EQ (2, delegators.size ());
3326  	ASSERT_EQ ("100", delegators.get<std::string> (nano::dev::genesis_key.pub.to_account ()));
3327  	ASSERT_EQ ("340282366920938463463374607431768211355", delegators.get<std::string> (key.pub.to_account ()));
3328  }
3329  TEST (rpc, delegators_parameters)
3330  {
3331  	nano::test::system system;
3332  	auto node1 = add_ipc_enabled_node (system);
3333  	nano::keypair key;
3334  	auto latest (node1->latest (nano::dev::genesis_key.pub));
3335  	nano::block_builder builder;
3336  	auto send = builder
3337  				.send ()
3338  				.previous (latest)
3339  				.destination (key.pub)
3340  				.balance (100)
3341  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3342  				.work (*node1->work_generate_blocking (latest))
3343  				.build ();
3344  	ASSERT_EQ (nano::process_result::progress, node1->process (*send).code);
3345  	auto open = builder
3346  				.open ()
3347  				.source (send->hash ())
3348  				.representative (nano::dev::genesis_key.pub)
3349  				.account (key.pub)
3350  				.sign (key.prv, key.pub)
3351  				.work (*node1->work_generate_blocking (key.pub))
3352  				.build ();
3353  	ASSERT_EQ (nano::process_result::progress, node1->process (*open).code);
3354  	auto const rpc_ctx = add_rpc (system, node1);
3355  	boost::property_tree::ptree request;
3356  	request.put ("action", "delegators");
3357  	request.put ("account", nano::dev::genesis_key.pub.to_account ());
3358  	request.put ("count", 2);
3359  	auto response (wait_response (system, rpc_ctx, request));
3360  	auto & delegators_node (response.get_child ("delegators"));
3361  	boost::property_tree::ptree delegators;
3362  	for (auto i (delegators_node.begin ()), n (delegators_node.end ()); i != n; ++i)
3363  	{
3364  		delegators.put ((i->first), (i->second.get<std::string> ("")));
3365  	}
3366  	ASSERT_EQ (2, delegators.size ());
3367  	ASSERT_EQ ("100", delegators.get<std::string> (nano::dev::genesis_key.pub.to_account ()));
3368  	ASSERT_EQ ("340282366920938463463374607431768211355", delegators.get<std::string> (key.pub.to_account ()));
3369  	request.put ("count", 1);
3370  	auto response2 (wait_response (system, rpc_ctx, request));
3371  	auto & delegators_node2 (response2.get_child ("delegators"));
3372  	boost::property_tree::ptree delegators2;
3373  	for (auto i (delegators_node2.begin ()), n (delegators_node2.end ()); i != n; ++i)
3374  	{
3375  		delegators2.put ((i->first), (i->second.get<std::string> ("")));
3376  	}
3377  	ASSERT_EQ (1, delegators2.size ());
3378  	if (nano::dev::genesis_key.pub.number () < key.pub.number ())
3379  	{
3380  		ASSERT_EQ ("100", delegators2.get<std::string> (nano::dev::genesis_key.pub.to_account ()));
3381  	}
3382  	else
3383  	{
3384  		ASSERT_EQ ("340282366920938463463374607431768211355", delegators2.get<std::string> (key.pub.to_account ()));
3385  	}
3386  	request.put ("count", 1024);
3387  	request.put ("threshold", 101); 
3388  	auto response3 (wait_response (system, rpc_ctx, request));
3389  	auto & delegators_node3 (response3.get_child ("delegators"));
3390  	boost::property_tree::ptree delegators3;
3391  	for (auto i (delegators_node3.begin ()), n (delegators_node3.end ()); i != n; ++i)
3392  	{
3393  		delegators3.put ((i->first), (i->second.get<std::string> ("")));
3394  	}
3395  	ASSERT_EQ (1, delegators3.size ());
3396  	ASSERT_EQ ("340282366920938463463374607431768211355", delegators3.get<std::string> (key.pub.to_account ()));
3397  	request.put ("threshold", 0);
3398  	auto last_account (key.pub);
3399  	if (nano::dev::genesis_key.pub.number () > key.pub.number ())
3400  	{
3401  		last_account = nano::dev::genesis_key.pub;
3402  	}
3403  	request.put ("start", nano::account (last_account.number () - 1).to_account ());
3404  	auto response4 (wait_response (system, rpc_ctx, request));
3405  	auto & delegators_node4 (response4.get_child ("delegators"));
3406  	boost::property_tree::ptree delegators4;
3407  	for (auto i (delegators_node4.begin ()), n (delegators_node4.end ()); i != n; ++i)
3408  	{
3409  		delegators4.put ((i->first), (i->second.get<std::string> ("")));
3410  	}
3411  	ASSERT_EQ (1, delegators4.size ());
3412  	boost::optional<std::string> balance (delegators4.get_optional<std::string> (last_account.to_account ()));
3413  	ASSERT_TRUE (balance.is_initialized ());
3414  	request.put ("start", last_account.to_account ());
3415  	auto response5 (wait_response (system, rpc_ctx, request));
3416  	auto & delegators_node5 (response5.get_child ("delegators"));
3417  	boost::property_tree::ptree delegators5;
3418  	for (auto i (delegators_node5.begin ()), n (delegators_node5.end ()); i != n; ++i)
3419  	{
3420  		delegators5.put ((i->first), (i->second.get<std::string> ("")));
3421  	}
3422  	ASSERT_EQ (0, delegators5.size ());
3423  }
3424  TEST (rpc, delegators_count)
3425  {
3426  	nano::test::system system;
3427  	auto node1 = add_ipc_enabled_node (system);
3428  	nano::keypair key;
3429  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
3430  	system.wallet (0)->insert_adhoc (key.prv);
3431  	auto latest (node1->latest (nano::dev::genesis_key.pub));
3432  	nano::block_builder builder;
3433  	auto send = builder
3434  				.send ()
3435  				.previous (latest)
3436  				.destination (key.pub)
3437  				.balance (100)
3438  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3439  				.work (*node1->work_generate_blocking (latest))
3440  				.build ();
3441  	ASSERT_EQ (nano::process_result::progress, node1->process (*send).code);
3442  	auto open = builder
3443  				.open ()
3444  				.source (send->hash ())
3445  				.representative (nano::dev::genesis_key.pub)
3446  				.account (key.pub)
3447  				.sign (key.prv, key.pub)
3448  				.work (*node1->work_generate_blocking (key.pub))
3449  				.build ();
3450  	ASSERT_EQ (nano::process_result::progress, node1->process (*open).code);
3451  	auto const rpc_ctx = add_rpc (system, node1);
3452  	boost::property_tree::ptree request;
3453  	request.put ("action", "delegators_count");
3454  	request.put ("account", nano::dev::genesis_key.pub.to_account ());
3455  	auto response (wait_response (system, rpc_ctx, request));
3456  	std::string count (response.get<std::string> ("count"));
3457  	ASSERT_EQ ("2", count);
3458  }
3459  TEST (rpc, account_info)
3460  {
3461  	nano::test::system system;
3462  	nano::keypair key;
3463  	auto node1 = add_ipc_enabled_node (system);
3464  	auto const rpc_ctx = add_rpc (system, node1);
3465  	boost::property_tree::ptree request;
3466  	request.put ("action", "account_info");
3467  	request.put ("account", nano::account ().to_account ());
3468  	{
3469  		auto response (wait_response (system, rpc_ctx, request));
3470  		auto error (response.get_optional<std::string> ("error"));
3471  		ASSERT_TRUE (error.is_initialized ());
3472  		ASSERT_EQ (error.get (), std::error_code (nano::error_common::account_not_found).message ());
3473  	}
3474  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
3475  	system.wallet (0)->insert_adhoc (key.prv);
3476  	auto latest (node1->latest (nano::dev::genesis_key.pub));
3477  	nano::block_builder builder;
3478  	auto send = builder
3479  				.send ()
3480  				.previous (latest)
3481  				.destination (key.pub)
3482  				.balance (100)
3483  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3484  				.work (*node1->work_generate_blocking (latest))
3485  				.build ();
3486  	ASSERT_EQ (nano::process_result::progress, node1->process (*send).code);
3487  	auto time = nano::seconds_since_epoch ();
3488  	{
3489  		auto transaction = node1->store.tx_begin_write ();
3490  		node1->store.confirmation_height.put (transaction, nano::dev::genesis_key.pub, { 1, nano::dev::genesis->hash () });
3491  	}
3492  	request.put ("account", nano::dev::genesis_key.pub.to_account ());
3493  	{
3494  		auto response (wait_response (system, rpc_ctx, request));
3495  		std::string frontier (response.get<std::string> ("frontier"));
3496  		ASSERT_EQ (send->hash ().to_string (), frontier);
3497  		std::string open_block (response.get<std::string> ("open_block"));
3498  		ASSERT_EQ (nano::dev::genesis->hash ().to_string (), open_block);
3499  		std::string representative_block (response.get<std::string> ("representative_block"));
3500  		ASSERT_EQ (nano::dev::genesis->hash ().to_string (), representative_block);
3501  		std::string balance (response.get<std::string> ("balance"));
3502  		ASSERT_EQ ("100", balance);
3503  		std::string modified_timestamp (response.get<std::string> ("modified_timestamp"));
3504  		ASSERT_LT (std::abs ((long)time - stol (modified_timestamp)), 5);
3505  		std::string block_count (response.get<std::string> ("block_count"));
3506  		ASSERT_EQ ("2", block_count);
3507  		std::string confirmation_height (response.get<std::string> ("confirmation_height"));
3508  		ASSERT_EQ ("1", confirmation_height);
3509  		std::string confirmation_height_frontier (response.get<std::string> ("confirmation_height_frontier"));
3510  		ASSERT_EQ (nano::dev::genesis->hash ().to_string (), confirmation_height_frontier);
3511  		ASSERT_EQ (0, response.get<uint8_t> ("account_version"));
3512  		boost::optional<std::string> weight (response.get_optional<std::string> ("weight"));
3513  		ASSERT_FALSE (weight.is_initialized ());
3514  		boost::optional<std::string> receivable (response.get_optional<std::string> ("receivable"));
3515  		ASSERT_FALSE (receivable.is_initialized ());
3516  		boost::optional<std::string> representative (response.get_optional<std::string> ("representative"));
3517  		ASSERT_FALSE (representative.is_initialized ());
3518  	}
3519  	request.put ("weight", "true");
3520  	request.put ("receivable", "1");
3521  	request.put ("representative", "1");
3522  	{
3523  		auto response (wait_response (system, rpc_ctx, request));
3524  		ASSERT_EQ ("100", response.get<std::string> ("weight"));
3525  		ASSERT_EQ ("0", response.get<std::string> ("receivable"));
3526  		std::string representative2 (response.get<std::string> ("representative"));
3527  		ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), representative2);
3528  	}
3529  	nano::keypair key1;
3530  	{
3531  		latest = node1->latest (nano::dev::genesis_key.pub);
3532  		auto send1 = builder
3533  					 .send ()
3534  					 .previous (latest)
3535  					 .destination (key1.pub)
3536  					 .balance (50)
3537  					 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3538  					 .work (*node1->work_generate_blocking (latest))
3539  					 .build ();
3540  		ASSERT_EQ (nano::process_result::progress, node1->process (*send1).code);
3541  		auto send2 = builder
3542  					 .send ()
3543  					 .previous (send1->hash ())
3544  					 .destination (key1.pub)
3545  					 .balance (25)
3546  					 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3547  					 .work (*node1->work_generate_blocking (send1->hash ()))
3548  					 .build ();
3549  		ASSERT_EQ (nano::process_result::progress, node1->process (*send2).code);
3550  		auto state_change = builder
3551  							.state ()
3552  							.account (nano::dev::genesis_key.pub)
3553  							.previous (send2->hash ())
3554  							.representative (key1.pub)
3555  							.balance (25)
3556  							.link (0)
3557  							.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3558  							.work (*node1->work_generate_blocking (send2->hash ()))
3559  							.build ();
3560  		ASSERT_EQ (nano::process_result::progress, node1->process (*state_change).code);
3561  		auto open = builder
3562  					.open ()
3563  					.source (send1->hash ())
3564  					.representative (nano::dev::genesis_key.pub)
3565  					.account (key1.pub)
3566  					.sign (key1.prv, key1.pub)
3567  					.work (*node1->work_generate_blocking (key1.pub))
3568  					.build ();
3569  		ASSERT_EQ (nano::process_result::progress, node1->process (*open).code);
3570  		ASSERT_TIMELY (5s, !node1->active.active (*state_change));
3571  		ASSERT_TIMELY (5s, !node1->active.active (*open));
3572  	}
3573  	{
3574  		auto response (wait_response (system, rpc_ctx, request));
3575  		std::string balance (response.get<std::string> ("balance"));
3576  		ASSERT_EQ ("25", balance);
3577  	}
3578  	request.put ("include_confirmed", true);
3579  	{
3580  		auto response (wait_response (system, rpc_ctx, request));
3581  		auto balance (response.get<std::string> ("balance"));
3582  		ASSERT_EQ ("25", balance);
3583  		auto confirmed_balance (response.get<std::string> ("confirmed_balance"));
3584  		ASSERT_EQ ("340282366920938463463374607431768211455", confirmed_balance);
3585  		auto representative (response.get<std::string> ("representative"));
3586  		ASSERT_EQ (representative, key1.pub.to_account ());
3587  		auto confirmed_representative (response.get<std::string> ("confirmed_representative"));
3588  		ASSERT_EQ (confirmed_representative, nano::dev::genesis_key.pub.to_account ());
3589  		auto confirmed_frontier (response.get<std::string> ("confirmed_frontier"));
3590  		ASSERT_EQ (nano::dev::genesis->hash ().to_string (), confirmed_frontier);
3591  		auto confirmed_height (response.get<uint64_t> ("confirmed_height"));
3592  		ASSERT_EQ (1, confirmed_height);
3593  	}
3594  	request.put ("account", key1.pub.to_account ());
3595  	{
3596  		auto response (wait_response (system, rpc_ctx, request));
3597  		ASSERT_EQ ("25", response.get<std::string> ("receivable"));
3598  		ASSERT_EQ ("0", response.get<std::string> ("confirmed_receivable"));
3599  	}
3600  	request.put ("include_confirmed", false);
3601  	{
3602  		auto response (wait_response (system, rpc_ctx, request));
3603  		ASSERT_EQ ("25", response.get<std::string> ("receivable"));
3604  		auto confirmed_balance (response.get_optional<std::string> ("confirmed_balance"));
3605  		ASSERT_FALSE (confirmed_balance.is_initialized ());
3606  		auto confirmed_receivable (response.get_optional<std::string> ("confirmed_receivable"));
3607  		ASSERT_FALSE (confirmed_receivable.is_initialized ());
3608  		auto confirmed_representative (response.get_optional<std::string> ("confirmed_representative"));
3609  		ASSERT_FALSE (confirmed_representative.is_initialized ());
3610  		auto confirmed_frontier (response.get_optional<std::string> ("confirmed_frontier"));
3611  		ASSERT_FALSE (confirmed_frontier.is_initialized ());
3612  		auto confirmed_height (response.get_optional<uint64_t> ("confirmed_height"));
3613  		ASSERT_FALSE (confirmed_height.is_initialized ());
3614  	}
3615  }
3616  TEST (rpc, json_block_input)
3617  {
3618  	nano::test::system system;
3619  	auto node1 = add_ipc_enabled_node (system);
3620  	nano::keypair key;
3621  	system.wallet (0)->insert_adhoc (key.prv);
3622  	nano::block_builder builder;
3623  	auto send = builder
3624  				.state ()
3625  				.account (nano::dev::genesis->account ())
3626  				.previous (node1->latest (nano::dev::genesis_key.pub))
3627  				.representative (nano::dev::genesis->account ())
3628  				.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
3629  				.link (key.pub)
3630  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3631  				.work (0)
3632  				.build ();
3633  	auto const rpc_ctx = add_rpc (system, node1);
3634  	boost::property_tree::ptree request;
3635  	request.put ("action", "sign");
3636  	request.put ("json_block", "true");
3637  	std::string wallet;
3638  	node1->wallets.items.begin ()->first.encode_hex (wallet);
3639  	request.put ("wallet", wallet);
3640  	request.put ("account", key.pub.to_account ());
3641  	boost::property_tree::ptree json;
3642  	send->serialize_json (json);
3643  	request.add_child ("block", json);
3644  	auto response (wait_response (system, rpc_ctx, request, 10s));
3645  	bool json_error{ false };
3646  	nano::state_block block (json_error, response.get_child ("block"));
3647  	ASSERT_FALSE (json_error);
3648  	ASSERT_FALSE (nano::validate_message (key.pub, send->hash (), block.block_signature ()));
3649  	ASSERT_NE (block.block_signature (), send->block_signature ());
3650  	ASSERT_EQ (block.hash (), send->hash ());
3651  }
3652  TEST (rpc, json_block_output)
3653  {
3654  	nano::test::system system;
3655  	auto node1 = add_ipc_enabled_node (system);
3656  	nano::keypair key;
3657  	auto latest (node1->latest (nano::dev::genesis_key.pub));
3658  	nano::block_builder builder;
3659  	auto send = builder
3660  				.send ()
3661  				.previous (latest)
3662  				.destination (key.pub)
3663  				.balance (100)
3664  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3665  				.work (*node1->work_generate_blocking (latest))
3666  				.build ();
3667  	ASSERT_EQ (nano::process_result::progress, node1->process (*send).code);
3668  	auto const rpc_ctx = add_rpc (system, node1);
3669  	boost::property_tree::ptree request;
3670  	request.put ("action", "block_info");
3671  	request.put ("json_block", "true");
3672  	request.put ("hash", send->hash ().to_string ());
3673  	auto response (wait_response (system, rpc_ctx, request));
3674  	bool json_error{ false };
3675  	nano::send_block send_from_json (json_error, response.get_child ("contents"));
3676  	ASSERT_FALSE (json_error);
3677  }
3678  TEST (rpc, blocks_info)
3679  {
3680  	nano::test::system system;
3681  	auto node = add_ipc_enabled_node (system);
3682  	auto const rpc_ctx = add_rpc (system, node);
3683  	auto check_blocks = [node] (boost::property_tree::ptree & response) {
3684  		for (auto & blocks : response.get_child ("blocks"))
3685  		{
3686  			std::string hash_text (blocks.first);
3687  			ASSERT_EQ (node->latest (nano::dev::genesis->account ()).to_string (), hash_text);
3688  			std::string account_text (blocks.second.get<std::string> ("block_account"));
3689  			ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), account_text);
3690  			std::string amount_text (blocks.second.get<std::string> ("amount"));
3691  			ASSERT_EQ (nano::dev::constants.genesis_amount.convert_to<std::string> (), amount_text);
3692  			std::string blocks_text (blocks.second.get<std::string> ("contents"));
3693  			ASSERT_FALSE (blocks_text.empty ());
3694  			boost::optional<std::string> receivable (blocks.second.get_optional<std::string> ("receivable"));
3695  			ASSERT_FALSE (receivable.is_initialized ());
3696  			boost::optional<std::string> receive_hash (blocks.second.get_optional<std::string> ("receive_hash"));
3697  			ASSERT_FALSE (receive_hash.is_initialized ());
3698  			boost::optional<std::string> source (blocks.second.get_optional<std::string> ("source_account"));
3699  			ASSERT_FALSE (source.is_initialized ());
3700  			std::string balance_text (blocks.second.get<std::string> ("balance"));
3701  			ASSERT_EQ (nano::dev::constants.genesis_amount.convert_to<std::string> (), balance_text);
3702  			ASSERT_TRUE (blocks.second.get<bool> ("confirmed")); 
3703  			std::string successor_text (blocks.second.get<std::string> ("successor"));
3704  			ASSERT_EQ (nano::block_hash (0).to_string (), successor_text); 
3705  		}
3706  	};
3707  	boost::property_tree::ptree request;
3708  	request.put ("action", "blocks_info");
3709  	boost::property_tree::ptree entry;
3710  	boost::property_tree::ptree hashes;
3711  	entry.put ("", node->latest (nano::dev::genesis->account ()).to_string ());
3712  	hashes.push_back (std::make_pair ("", entry));
3713  	request.add_child ("hashes", hashes);
3714  	{
3715  		auto response (wait_response (system, rpc_ctx, request));
3716  		check_blocks (response);
3717  	}
3718  	std::string random_hash = nano::block_hash ().to_string ();
3719  	entry.put ("", random_hash);
3720  	hashes.push_back (std::make_pair ("", entry));
3721  	request.erase ("hashes");
3722  	request.add_child ("hashes", hashes);
3723  	{
3724  		auto response (wait_response (system, rpc_ctx, request));
3725  		ASSERT_EQ (std::error_code (nano::error_blocks::not_found).message (), response.get<std::string> ("error"));
3726  	}
3727  	request.put ("include_not_found", "true");
3728  	{
3729  		auto response (wait_response (system, rpc_ctx, request));
3730  		check_blocks (response);
3731  		auto & blocks_not_found (response.get_child ("blocks_not_found"));
3732  		ASSERT_EQ (1, blocks_not_found.size ());
3733  		ASSERT_EQ (random_hash, blocks_not_found.begin ()->second.get<std::string> (""));
3734  	}
3735  	request.put ("source", "true");
3736  	request.put ("receivable", "1");
3737  	request.put ("receive_hash", "1");
3738  	{
3739  		auto response (wait_response (system, rpc_ctx, request));
3740  		for (auto & blocks : response.get_child ("blocks"))
3741  		{
3742  			ASSERT_EQ ("0", blocks.second.get<std::string> ("source_account"));
3743  			ASSERT_EQ ("0", blocks.second.get<std::string> ("receivable"));
3744  			std::string receive_hash (blocks.second.get<std::string> ("receive_hash"));
3745  			ASSERT_EQ (nano::block_hash (0).to_string (), receive_hash);
3746  		}
3747  	}
3748  }
3749  TEST (rpc, blocks_info_receive_hash)
3750  {
3751  	nano::test::system system;
3752  	auto node = add_ipc_enabled_node (system);
3753  	nano::keypair key1;
3754  	system.wallet (0)->insert_adhoc (key1.prv);
3755  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
3756  	auto send1 = system.wallet (0)->send_action (nano::dev::genesis_key.pub, key1.pub, 1);
3757  	auto send2 = system.wallet (0)->send_action (nano::dev::genesis_key.pub, key1.pub, 2);
3758  	auto send3 = system.wallet (0)->send_action (nano::dev::genesis_key.pub, key1.pub, 3);
3759  	auto send4 = system.wallet (0)->send_action (nano::dev::genesis_key.pub, key1.pub, 4);
3760  	auto recv1 (system.wallet (0)->receive_action (send1->hash (), key1.pub, node->config.receive_minimum.number (), send1->link ().as_account ()));
3761  	auto recv4 (system.wallet (0)->receive_action (send4->hash (), key1.pub, node->config.receive_minimum.number (), send4->link ().as_account ()));
3762  	auto recv3 (system.wallet (0)->receive_action (send3->hash (), key1.pub, node->config.receive_minimum.number (), send3->link ().as_account ()));
3763  	auto recv2 (system.wallet (0)->receive_action (send2->hash (), key1.pub, node->config.receive_minimum.number (), send2->link ().as_account ()));
3764  	auto all_blocks_cemented = [node, &key1] () -> bool {
3765  		nano::confirmation_height_info info;
3766  		if (node->store.confirmation_height.get (node->store.tx_begin_read (), key1.pub, info))
3767  		{
3768  			return false;
3769  		}
3770  		return info.height == 4;
3771  	};
3772  	ASSERT_TIMELY (5s, all_blocks_cemented ());
3773  	ASSERT_EQ (node->ledger.account_balance (node->store.tx_begin_read (), key1.pub, true), 10);
3774  	boost::property_tree::ptree request;
3775  	boost::property_tree::ptree hashes;
3776  	boost::property_tree::ptree child;
3777  	child.put ("", send1->hash ().to_string ());
3778  	hashes.push_back (std::make_pair ("", child));
3779  	child.put ("", send2->hash ().to_string ());
3780  	hashes.push_back (std::make_pair ("", child));
3781  	child.put ("", send3->hash ().to_string ());
3782  	hashes.push_back (std::make_pair ("", child));
3783  	child.put ("", send4->hash ().to_string ());
3784  	hashes.push_back (std::make_pair ("", child));
3785  	request.put ("action", "blocks_info");
3786  	request.add_child ("hashes", hashes);
3787  	request.put ("receive_hash", "true");
3788  	request.put ("json_block", "true");
3789  	auto const rpc_ctx = add_rpc (system, node);
3790  	auto response = wait_response (system, rpc_ctx, request);
3791  	std::map<std::string, std::string> send_recv_map{
3792  		{ send1->hash ().to_string (), recv1->hash ().to_string () },
3793  		{ send2->hash ().to_string (), recv2->hash ().to_string () },
3794  		{ send3->hash ().to_string (), recv3->hash ().to_string () },
3795  		{ send4->hash ().to_string (), recv4->hash ().to_string () },
3796  	};
3797  	for (auto & blocks : response.get_child ("blocks"))
3798  	{
3799  		auto hash = blocks.first;
3800  		std::string receive_hash = blocks.second.get<std::string> ("receive_hash");
3801  		ASSERT_EQ (receive_hash, send_recv_map[hash]);
3802  		send_recv_map.erase (hash);
3803  	}
3804  	ASSERT_EQ (send_recv_map.size (), 0);
3805  }
3806  TEST (rpc, blocks_info_subtype)
3807  {
3808  	nano::test::system system;
3809  	auto node1 = add_ipc_enabled_node (system);
3810  	nano::keypair key;
3811  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
3812  	system.wallet (0)->insert_adhoc (key.prv);
3813  	auto send (system.wallet (0)->send_action (nano::dev::genesis_key.pub, nano::dev::genesis_key.pub, nano::Gxrb_ratio));
3814  	ASSERT_NE (nullptr, send);
3815  	auto receive (system.wallet (0)->receive_action (send->hash (), key.pub, nano::Gxrb_ratio, send->link ().as_account ()));
3816  	ASSERT_NE (nullptr, receive);
3817  	auto change (system.wallet (0)->change_action (nano::dev::genesis_key.pub, key.pub));
3818  	ASSERT_NE (nullptr, change);
3819  	auto const rpc_ctx = add_rpc (system, node1);
3820  	boost::property_tree::ptree request;
3821  	request.put ("action", "blocks_info");
3822  	boost::property_tree::ptree hashes;
3823  	boost::property_tree::ptree entry;
3824  	entry.put ("", send->hash ().to_string ());
3825  	hashes.push_back (std::make_pair ("", entry));
3826  	entry.put ("", receive->hash ().to_string ());
3827  	hashes.push_back (std::make_pair ("", entry));
3828  	entry.put ("", change->hash ().to_string ());
3829  	hashes.push_back (std::make_pair ("", entry));
3830  	request.add_child ("hashes", hashes);
3831  	auto response (wait_response (system, rpc_ctx, request));
3832  	auto & blocks (response.get_child ("blocks"));
3833  	ASSERT_EQ (3, blocks.size ());
3834  	auto send_subtype (blocks.get_child (send->hash ().to_string ()).get<std::string> ("subtype"));
3835  	ASSERT_EQ (send_subtype, "send");
3836  	auto receive_subtype (blocks.get_child (receive->hash ().to_string ()).get<std::string> ("subtype"));
3837  	ASSERT_EQ (receive_subtype, "receive");
3838  	auto change_subtype (blocks.get_child (change->hash ().to_string ()).get<std::string> ("subtype"));
3839  	ASSERT_EQ (change_subtype, "change");
3840  	auto send_successor (blocks.get_child (send->hash ().to_string ()).get<std::string> ("successor"));
3841  	ASSERT_EQ (send_successor, receive->hash ().to_string ());
3842  	auto receive_successor (blocks.get_child (receive->hash ().to_string ()).get<std::string> ("successor"));
3843  	ASSERT_EQ (receive_successor, change->hash ().to_string ());
3844  	auto change_successor (blocks.get_child (change->hash ().to_string ()).get<std::string> ("successor"));
3845  	ASSERT_EQ (change_successor, nano::block_hash (0).to_string ()); 
3846  }
3847  TEST (rpc, block_info_successor)
3848  {
3849  	nano::test::system system;
3850  	auto node1 = add_ipc_enabled_node (system);
3851  	nano::keypair key;
3852  	auto latest (node1->latest (nano::dev::genesis_key.pub));
3853  	nano::block_builder builder;
3854  	auto send = builder
3855  				.send ()
3856  				.previous (latest)
3857  				.destination (key.pub)
3858  				.balance (100)
3859  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3860  				.work (*node1->work_generate_blocking (latest))
3861  				.build ();
3862  	ASSERT_EQ (nano::process_result::progress, node1->process (*send).code);
3863  	auto const rpc_ctx = add_rpc (system, node1);
3864  	boost::property_tree::ptree request;
3865  	request.put ("action", "block_info");
3866  	request.put ("hash", latest.to_string ());
3867  	auto response (wait_response (system, rpc_ctx, request));
3868  	std::string successor_text (response.get<std::string> ("successor"));
3869  	ASSERT_EQ (successor_text, send->hash ().to_string ());
3870  	std::string account_text (response.get<std::string> ("block_account"));
3871  	ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), account_text);
3872  	std::string amount_text (response.get<std::string> ("amount"));
3873  	ASSERT_EQ (nano::dev::constants.genesis_amount.convert_to<std::string> (), amount_text);
3874  }
3875  TEST (rpc, block_info_pruning)
3876  {
3877  	nano::test::system system;
3878  	nano::node_config node_config0 = system.default_config ();
3879  	node_config0.receive_minimum = nano::dev::constants.genesis_amount; 
3880  	auto & node0 = *system.add_node (node_config0);
3881  	nano::node_config node_config1 = system.default_config ();
3882  	node_config1.enable_voting = false; 
3883  	nano::node_flags node_flags;
3884  	node_flags.enable_pruning = true;
3885  	auto node1 = add_ipc_enabled_node (system, node_config1, node_flags);
3886  	auto latest (node1->latest (nano::dev::genesis_key.pub));
3887  	nano::block_builder builder;
3888  	auto send1 = builder
3889  				 .send ()
3890  				 .previous (latest)
3891  				 .destination (nano::dev::genesis_key.pub)
3892  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
3893  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3894  				 .work (*node1->work_generate_blocking (latest))
3895  				 .build_shared ();
3896  	node1->process_active (send1);
3897  	auto receive1 = builder
3898  					.receive ()
3899  					.previous (send1->hash ())
3900  					.source (send1->hash ())
3901  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3902  					.work (*node1->work_generate_blocking (send1->hash ()))
3903  					.build_shared ();
3904  	node1->process_active (receive1);
3905  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
3906  	ASSERT_TIMELY (5s, node1->block_confirmed (receive1->hash ()));
3907  	{
3908  		auto transaction (node1->store.tx_begin_write ());
3909  		ASSERT_EQ (1, node1->ledger.pruning_action (transaction, send1->hash (), 1));
3910  		ASSERT_TRUE (node1->store.block.exists (transaction, receive1->hash ()));
3911  	}
3912  	auto const rpc_ctx = add_rpc (system, node1);
3913  	boost::property_tree::ptree request;
3914  	request.put ("action", "block_info");
3915  	request.put ("hash", send1->hash ().to_string ());
3916  	auto response (wait_response (system, rpc_ctx, request));
3917  	ASSERT_EQ (std::error_code (nano::error_blocks::not_found).message (), response.get<std::string> ("error"));
3918  	boost::property_tree::ptree request2;
3919  	request2.put ("action", "block_info");
3920  	request2.put ("json_block", "true");
3921  	request2.put ("hash", receive1->hash ().to_string ());
3922  	auto response2 (wait_response (system, rpc_ctx, request2));
3923  	std::string account_text (response2.get<std::string> ("block_account"));
3924  	ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), account_text);
3925  	boost::optional<std::string> amount (response2.get_optional<std::string> ("amount"));
3926  	ASSERT_FALSE (amount.is_initialized ()); 
3927  	bool json_error{ false };
3928  	nano::receive_block receive_from_json (json_error, response2.get_child ("contents"));
3929  	ASSERT_FALSE (json_error);
3930  	ASSERT_EQ (receive1->full_hash (), receive_from_json.full_hash ());
3931  	std::string balance_text (response2.get<std::string> ("balance"));
3932  	ASSERT_EQ (nano::dev::constants.genesis_amount.convert_to<std::string> (), balance_text);
3933  	ASSERT_TRUE (response2.get<bool> ("confirmed"));
3934  	std::string successor_text (response2.get<std::string> ("successor"));
3935  	ASSERT_EQ (successor_text, nano::block_hash (0).to_string ()); 
3936  }
3937  TEST (rpc, pruned_exists)
3938  {
3939  	nano::test::system system;
3940  	nano::node_config node_config0 = system.default_config ();
3941  	node_config0.receive_minimum = nano::dev::constants.genesis_amount; 
3942  	auto & node0 = *system.add_node (node_config0);
3943  	nano::node_config node_config1 = system.default_config ();
3944  	node_config1.enable_voting = false; 
3945  	nano::node_flags node_flags;
3946  	node_flags.enable_pruning = true;
3947  	auto node1 = add_ipc_enabled_node (system, node_config1, node_flags);
3948  	auto latest (node1->latest (nano::dev::genesis_key.pub));
3949  	nano::block_builder builder;
3950  	auto send1 = builder
3951  				 .send ()
3952  				 .previous (latest)
3953  				 .destination (nano::dev::genesis_key.pub)
3954  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
3955  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3956  				 .work (*node1->work_generate_blocking (latest))
3957  				 .build_shared ();
3958  	node1->process_active (send1);
3959  	auto receive1 = builder
3960  					.receive ()
3961  					.previous (send1->hash ())
3962  					.source (send1->hash ())
3963  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3964  					.work (*node1->work_generate_blocking (send1->hash ()))
3965  					.build_shared ();
3966  	node1->process_active (receive1);
3967  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
3968  	ASSERT_TIMELY (5s, node1->block_confirmed (receive1->hash ()));
3969  	{
3970  		auto transaction (node1->store.tx_begin_write ());
3971  		ASSERT_EQ (1, node1->ledger.pruning_action (transaction, send1->hash (), 1));
3972  		ASSERT_TRUE (node1->store.block.exists (transaction, receive1->hash ()));
3973  	}
3974  	auto const rpc_ctx = add_rpc (system, node1);
3975  	boost::property_tree::ptree request;
3976  	request.put ("action", "pruned_exists");
3977  	request.put ("hash", send1->hash ().to_string ());
3978  	auto response (wait_response (system, rpc_ctx, request));
3979  	ASSERT_TRUE (response.get<bool> ("exists"));
3980  	boost::property_tree::ptree request2;
3981  	request2.put ("action", "pruned_exists");
3982  	request2.put ("hash", receive1->hash ().to_string ());
3983  	auto response2 (wait_response (system, rpc_ctx, request2));
3984  	ASSERT_FALSE (response2.get<bool> ("exists"));
3985  }
3986  TEST (rpc, work_peers_all)
3987  {
3988  	nano::test::system system;
3989  	auto node1 = add_ipc_enabled_node (system);
3990  	auto const rpc_ctx = add_rpc (system, node1);
3991  	boost::property_tree::ptree request;
3992  	request.put ("action", "work_peer_add");
3993  	request.put ("address", "::1");
3994  	request.put ("port", "0");
3995  	auto response (wait_response (system, rpc_ctx, request));
3996  	std::string success (response.get<std::string> ("success", ""));
3997  	ASSERT_TRUE (success.empty ());
3998  	boost::property_tree::ptree request1;
3999  	request1.put ("action", "work_peers");
4000  	auto response1 (wait_response (system, rpc_ctx, request1));
4001  	auto & peers_node (response1.get_child ("work_peers"));
4002  	std::vector<std::string> peers;
4003  	for (auto i (peers_node.begin ()), n (peers_node.end ()); i != n; ++i)
4004  	{
4005  		peers.push_back (i->second.get<std::string> (""));
4006  	}
4007  	ASSERT_EQ (1, peers.size ());
4008  	ASSERT_EQ ("::1:0", peers[0]);
4009  	boost::property_tree::ptree request2;
4010  	request2.put ("action", "work_peers_clear");
4011  	auto response2 (wait_response (system, rpc_ctx, request2));
4012  	success = response2.get<std::string> ("success", "");
4013  	ASSERT_TRUE (success.empty ());
4014  	auto response3 (wait_response (system, rpc_ctx, request1, 10s));
4015  	peers_node = response3.get_child ("work_peers");
4016  	ASSERT_EQ (0, peers_node.size ());
4017  }
4018  TEST (rpc, populate_backlog)
4019  {
4020  	nano::test::system system;
4021  	nano::node_config node_config = system.default_config ();
4022  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
4023  	auto node = add_ipc_enabled_node (system, node_config);
4024  	nano::keypair key;
4025  	nano::block_builder builder;
4026  	auto latest (node->latest (nano::dev::genesis_key.pub));
4027  	auto genesis_balance (nano::dev::constants.genesis_amount);
4028  	auto send_amount (genesis_balance - 100);
4029  	auto send = builder
4030  				.send ()
4031  				.previous (latest)
4032  				.destination (key.pub)
4033  				.balance (genesis_balance)
4034  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
4035  				.work (*node->work_generate_blocking (latest))
4036  				.build ();
4037  	ASSERT_EQ (nano::process_result::progress, node->process (*send).code);
4038  	ASSERT_FALSE (node->block_arrival.recent (send->hash ()));
4039  	auto const rpc_ctx = add_rpc (system, node);
4040  	boost::property_tree::ptree request;
4041  	request.put ("action", "populate_backlog");
4042  	auto response (wait_response (system, rpc_ctx, request));
4043  	std::string success (response.get<std::string> ("success", ""));
4044  	ASSERT_TRUE (success.empty ());
4045  	ASSERT_TIMELY (5s, node->active.active (*send));
4046  }
4047  TEST (rpc, ledger)
4048  {
4049  	nano::test::system system;
4050  	auto node = add_ipc_enabled_node (system);
4051  	nano::keypair key;
4052  	auto latest (node->latest (nano::dev::genesis_key.pub));
4053  	auto genesis_balance (nano::dev::constants.genesis_amount);
4054  	auto send_amount (genesis_balance - 100);
4055  	genesis_balance -= send_amount;
4056  	nano::block_builder builder;
4057  	auto send = builder
4058  				.send ()
4059  				.previous (latest)
4060  				.destination (key.pub)
4061  				.balance (genesis_balance)
4062  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
4063  				.work (*node->work_generate_blocking (latest))
4064  				.build ();
4065  	ASSERT_EQ (nano::process_result::progress, node->process (*send).code);
4066  	auto open = builder
4067  				.open ()
4068  				.source (send->hash ())
4069  				.representative (nano::dev::genesis_key.pub)
4070  				.account (key.pub)
4071  				.sign (key.prv, key.pub)
4072  				.work (*node->work_generate_blocking (key.pub))
4073  				.build ();
4074  	ASSERT_EQ (nano::process_result::progress, node->process (*open).code);
4075  	auto time = nano::seconds_since_epoch ();
4076  	auto const rpc_ctx = add_rpc (system, node);
4077  	boost::property_tree::ptree request;
4078  	request.put ("action", "ledger");
4079  	request.put ("sorting", true);
4080  	request.put ("count", "1");
4081  	{
4082  		auto response (wait_response (system, rpc_ctx, request));
4083  		for (auto & account : response.get_child ("accounts"))
4084  		{
4085  			std::string account_text (account.first);
4086  			ASSERT_EQ (key.pub.to_account (), account_text);
4087  			std::string frontier (account.second.get<std::string> ("frontier"));
4088  			ASSERT_EQ (open->hash ().to_string (), frontier);
4089  			std::string open_block (account.second.get<std::string> ("open_block"));
4090  			ASSERT_EQ (open->hash ().to_string (), open_block);
4091  			std::string representative_block (account.second.get<std::string> ("representative_block"));
4092  			ASSERT_EQ (open->hash ().to_string (), representative_block);
4093  			std::string balance_text (account.second.get<std::string> ("balance"));
4094  			ASSERT_EQ (send_amount.convert_to<std::string> (), balance_text);
4095  			std::string modified_timestamp (account.second.get<std::string> ("modified_timestamp"));
4096  			ASSERT_LT (std::abs ((long)time - stol (modified_timestamp)), 5);
4097  			std::string block_count (account.second.get<std::string> ("block_count"));
4098  			ASSERT_EQ ("1", block_count);
4099  			boost::optional<std::string> weight (account.second.get_optional<std::string> ("weight"));
4100  			ASSERT_FALSE (weight.is_initialized ());
4101  			boost::optional<std::string> pending (account.second.get_optional<std::string> ("pending"));
4102  			ASSERT_FALSE (pending.is_initialized ());
4103  			boost::optional<std::string> representative (account.second.get_optional<std::string> ("representative"));
4104  			ASSERT_FALSE (representative.is_initialized ());
4105  		}
4106  	}
4107  	request.put ("weight", true);
4108  	request.put ("pending", true);
4109  	request.put ("representative", true);
4110  	{
4111  		auto response (wait_response (system, rpc_ctx, request));
4112  		for (auto & account : response.get_child ("accounts"))
4113  		{
4114  			boost::optional<std::string> weight (account.second.get_optional<std::string> ("weight"));
4115  			ASSERT_TRUE (weight.is_initialized ());
4116  			ASSERT_EQ ("0", weight.get ());
4117  			boost::optional<std::string> pending (account.second.get_optional<std::string> ("pending"));
4118  			ASSERT_TRUE (pending.is_initialized ());
4119  			ASSERT_EQ ("0", pending.get ());
4120  			boost::optional<std::string> representative (account.second.get_optional<std::string> ("representative"));
4121  			ASSERT_TRUE (representative.is_initialized ());
4122  			ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), representative.get ());
4123  		}
4124  	}
4125  	request.put ("count", 2);
4126  	request.put ("threshold", genesis_balance + 1);
4127  	{
4128  		auto response (wait_response (system, rpc_ctx, request));
4129  		auto & accounts (response.get_child ("accounts"));
4130  		ASSERT_EQ (1, accounts.size ());
4131  		auto account (accounts.begin ());
4132  		ASSERT_EQ (key.pub.to_account (), account->first);
4133  		std::string balance_text (account->second.get<std::string> ("balance"));
4134  		ASSERT_EQ (send_amount.convert_to<std::string> (), balance_text);
4135  	}
4136  	auto send2_amount (50);
4137  	genesis_balance -= send2_amount;
4138  	auto send2 = builder
4139  				 .send ()
4140  				 .previous (send->hash ())
4141  				 .destination (key.pub)
4142  				 .balance (genesis_balance)
4143  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
4144  				 .work (*node->work_generate_blocking (send->hash ()))
4145  				 .build ();
4146  	ASSERT_EQ (nano::process_result::progress, node->process (*send2).code);
4147  	request.put ("count", 2);
4148  	request.put ("threshold", (send_amount + send2_amount).convert_to<std::string> ());
4149  	request.put ("pending", true);
4150  	{
4151  		auto response (wait_response (system, rpc_ctx, request));
4152  		auto & accounts (response.get_child ("accounts"));
4153  		ASSERT_EQ (1, accounts.size ());
4154  		auto account (accounts.begin ());
4155  		ASSERT_EQ (key.pub.to_account (), account->first);
4156  		std::string balance_text (account->second.get<std::string> ("balance"));
4157  		ASSERT_EQ (send_amount.convert_to<std::string> (), balance_text);
4158  		std::string pending_text (account->second.get<std::string> ("pending"));
4159  		ASSERT_EQ (std::to_string (send2_amount), pending_text);
4160  	}
4161  }
4162  TEST (rpc, accounts_create)
4163  {
4164  	nano::test::system system;
4165  	auto node = add_ipc_enabled_node (system);
4166  	auto const rpc_ctx = add_rpc (system, node);
4167  	boost::property_tree::ptree request;
4168  	request.put ("action", "accounts_create");
4169  	request.put ("wallet", node->wallets.items.begin ()->first.to_string ());
4170  	request.put ("count", "8");
4171  	auto response (wait_response (system, rpc_ctx, request));
4172  	auto & accounts (response.get_child ("accounts"));
4173  	for (auto i (accounts.begin ()), n (accounts.end ()); i != n; ++i)
4174  	{
4175  		std::string account_text (i->second.get<std::string> (""));
4176  		nano::account account;
4177  		ASSERT_FALSE (account.decode_account (account_text));
4178  		ASSERT_TRUE (system.wallet (0)->exists (account));
4179  	}
4180  	ASSERT_EQ (8, accounts.size ());
4181  }
4182  TEST (rpc, block_create)
4183  {
4184  	nano::test::system system;
4185  	auto node1 = add_ipc_enabled_node (system);
4186  	nano::keypair key;
4187  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
4188  	system.wallet (0)->insert_adhoc (key.prv);
4189  	auto latest (node1->latest (nano::dev::genesis_key.pub));
4190  	auto send_work = *node1->work_generate_blocking (latest);
4191  	nano::block_builder builder;
4192  	auto send = builder
4193  				.send ()
4194  				.previous (latest)
4195  				.destination (key.pub)
4196  				.balance (100)
4197  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
4198  				.work (send_work)
4199  				.build ();
4200  	auto open_work = *node1->work_generate_blocking (key.pub);
4201  	auto open = builder
4202  				.open ()
4203  				.source (send->hash ())
4204  				.representative (nano::dev::genesis_key.pub)
4205  				.account (key.pub)
4206  				.sign (key.prv, key.pub)
4207  				.work (open_work)
4208  				.build ();
4209  	auto const rpc_ctx = add_rpc (system, node1);
4210  	boost::property_tree::ptree request;
4211  	request.put ("action", "block_create");
4212  	request.put ("type", "send");
4213  	request.put ("wallet", node1->wallets.items.begin ()->first.to_string ());
4214  	request.put ("account", nano::dev::genesis_key.pub.to_account ());
4215  	request.put ("previous", latest.to_string ());
4216  	request.put ("amount", "340282366920938463463374607431768211355");
4217  	request.put ("destination", key.pub.to_account ());
4218  	request.put ("work", nano::to_string_hex (send_work));
4219  	auto response (wait_response (system, rpc_ctx, request));
4220  	std::string send_hash (response.get<std::string> ("hash"));
4221  	ASSERT_EQ (send->hash ().to_string (), send_hash);
4222  	std::string send_difficulty (response.get<std::string> ("difficulty"));
4223  	ASSERT_EQ (nano::to_string_hex (nano::dev::network_params.work.difficulty (*send)), send_difficulty);
4224  	auto send_text (response.get<std::string> ("block"));
4225  	boost::property_tree::ptree block_l;
4226  	std::stringstream block_stream (send_text);
4227  	boost::property_tree::read_json (block_stream, block_l);
4228  	auto send_block (nano::deserialize_block_json (block_l));
4229  	ASSERT_EQ (send->hash (), send_block->hash ());
4230  	ASSERT_EQ (nano::process_result::progress, node1->process (*send).code);
4231  	boost::property_tree::ptree request1;
4232  	request1.put ("action", "block_create");
4233  	request1.put ("type", "open");
4234  	std::string key_text;
4235  	key.prv.encode_hex (key_text);
4236  	request1.put ("key", key_text);
4237  	request1.put ("representative", nano::dev::genesis_key.pub.to_account ());
4238  	request1.put ("source", send->hash ().to_string ());
4239  	request1.put ("work", nano::to_string_hex (open_work));
4240  	auto response1 (wait_response (system, rpc_ctx, request1));
4241  	std::string open_hash (response1.get<std::string> ("hash"));
4242  	ASSERT_EQ (open->hash ().to_string (), open_hash);
4243  	auto open_text (response1.get<std::string> ("block"));
4244  	std::stringstream block_stream1 (open_text);
4245  	boost::property_tree::read_json (block_stream1, block_l);
4246  	auto open_block (nano::deserialize_block_json (block_l));
4247  	ASSERT_EQ (open->hash (), open_block->hash ());
4248  	ASSERT_EQ (nano::process_result::progress, node1->process (*open).code);
4249  	request1.put ("representative", key.pub.to_account ());
4250  	auto response2 (wait_response (system, rpc_ctx, request1));
4251  	std::string open2_hash (response2.get<std::string> ("hash"));
4252  	ASSERT_NE (open->hash ().to_string (), open2_hash); 
4253  	auto change_work = *node1->work_generate_blocking (open->hash ());
4254  	auto change = builder
4255  				  .change ()
4256  				  .previous (open->hash ())
4257  				  .representative (key.pub)
4258  				  .sign (key.prv, key.pub)
4259  				  .work (change_work)
4260  				  .build ();
4261  	request1.put ("type", "change");
4262  	request1.put ("work", nano::to_string_hex (change_work));
4263  	auto response4 (wait_response (system, rpc_ctx, request1));
4264  	std::string change_hash (response4.get<std::string> ("hash"));
4265  	ASSERT_EQ (change->hash ().to_string (), change_hash);
4266  	auto change_text (response4.get<std::string> ("block"));
4267  	std::stringstream block_stream4 (change_text);
4268  	boost::property_tree::read_json (block_stream4, block_l);
4269  	auto change_block (nano::deserialize_block_json (block_l));
4270  	ASSERT_EQ (change->hash (), change_block->hash ());
4271  	ASSERT_EQ (nano::process_result::progress, node1->process (*change).code);
4272  	auto send2 = builder
4273  				 .send ()
4274  				 .previous (send->hash ())
4275  				 .destination (key.pub)
4276  				 .balance (0)
4277  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
4278  				 .work (*node1->work_generate_blocking (send->hash ()))
4279  				 .build ();
4280  	ASSERT_EQ (nano::process_result::progress, node1->process (*send2).code);
4281  	boost::property_tree::ptree request2;
4282  	request2.put ("action", "block_create");
4283  	request2.put ("type", "receive");
4284  	request2.put ("wallet", node1->wallets.items.begin ()->first.to_string ());
4285  	request2.put ("account", key.pub.to_account ());
4286  	request2.put ("source", send2->hash ().to_string ());
4287  	request2.put ("previous", change->hash ().to_string ());
4288  	request2.put ("work", nano::to_string_hex (*node1->work_generate_blocking (change->hash ())));
4289  	auto response5 (wait_response (system, rpc_ctx, request2));
4290  	std::string receive_hash (response4.get<std::string> ("hash"));
4291  	auto receive_text (response5.get<std::string> ("block"));
4292  	std::stringstream block_stream5 (change_text);
4293  	boost::property_tree::read_json (block_stream5, block_l);
4294  	auto receive_block (nano::deserialize_block_json (block_l));
4295  	ASSERT_EQ (receive_hash, receive_block->hash ().to_string ());
4296  	node1->process_active (std::move (receive_block));
4297  	latest = node1->latest (key.pub);
4298  	ASSERT_EQ (receive_hash, latest.to_string ());
4299  }
4300  TEST (rpc, block_create_state)
4301  {
4302  	nano::test::system system;
4303  	auto node = add_ipc_enabled_node (system);
4304  	nano::keypair key;
4305  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
4306  	auto const rpc_ctx = add_rpc (system, node);
4307  	boost::property_tree::ptree request;
4308  	request.put ("action", "block_create");
4309  	request.put ("type", "state");
4310  	request.put ("wallet", node->wallets.items.begin ()->first.to_string ());
4311  	request.put ("account", nano::dev::genesis_key.pub.to_account ());
4312  	request.put ("previous", nano::dev::genesis->hash ().to_string ());
4313  	request.put ("representative", nano::dev::genesis_key.pub.to_account ());
4314  	request.put ("balance", (nano::dev::constants.genesis_amount - nano::Gxrb_ratio).convert_to<std::string> ());
4315  	request.put ("link", key.pub.to_account ());
4316  	request.put ("work", nano::to_string_hex (*node->work_generate_blocking (nano::dev::genesis->hash ())));
4317  	auto response (wait_response (system, rpc_ctx, request));
4318  	std::string state_hash (response.get<std::string> ("hash"));
4319  	auto state_text (response.get<std::string> ("block"));
4320  	std::stringstream block_stream (state_text);
4321  	boost::property_tree::ptree block_l;
4322  	boost::property_tree::read_json (block_stream, block_l);
4323  	auto state_block (nano::deserialize_block_json (block_l));
4324  	ASSERT_NE (nullptr, state_block);
4325  	ASSERT_EQ (nano::block_type::state, state_block->type ());
4326  	ASSERT_EQ (state_hash, state_block->hash ().to_string ());
4327  	auto process_result (node->process (*state_block));
4328  	ASSERT_EQ (nano::process_result::progress, process_result.code);
4329  }
4330  TEST (rpc, block_create_state_open)
4331  {
4332  	nano::test::system system;
4333  	auto node = add_ipc_enabled_node (system);
4334  	nano::keypair key;
4335  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
4336  	auto send_block (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key.pub, nano::Gxrb_ratio));
4337  	ASSERT_NE (nullptr, send_block);
4338  	auto const rpc_ctx = add_rpc (system, node);
4339  	boost::property_tree::ptree request;
4340  	request.put ("action", "block_create");
4341  	request.put ("type", "state");
4342  	request.put ("key", key.prv.to_string ());
4343  	request.put ("account", key.pub.to_account ());
4344  	request.put ("previous", 0);
4345  	request.put ("representative", nano::dev::genesis_key.pub.to_account ());
4346  	request.put ("balance", nano::Gxrb_ratio.convert_to<std::string> ());
4347  	request.put ("link", send_block->hash ().to_string ());
4348  	request.put ("work", nano::to_string_hex (*node->work_generate_blocking (key.pub)));
4349  	auto response (wait_response (system, rpc_ctx, request));
4350  	std::string state_hash (response.get<std::string> ("hash"));
4351  	auto state_text (response.get<std::string> ("block"));
4352  	std::stringstream block_stream (state_text);
4353  	boost::property_tree::ptree block_l;
4354  	boost::property_tree::read_json (block_stream, block_l);
4355  	auto state_block (nano::deserialize_block_json (block_l));
4356  	ASSERT_NE (nullptr, state_block);
4357  	ASSERT_EQ (nano::block_type::state, state_block->type ());
4358  	ASSERT_EQ (state_hash, state_block->hash ().to_string ());
4359  	auto difficulty (nano::dev::network_params.work.difficulty (*state_block));
4360  	ASSERT_GT (difficulty, nano::dev::network_params.work.threshold (state_block->work_version (), nano::block_details (nano::epoch::epoch_0, false, true, false)));
4361  	ASSERT_TRUE (node->latest (key.pub).is_zero ());
4362  	auto process_result (node->process (*state_block));
4363  	ASSERT_EQ (nano::process_result::progress, process_result.code);
4364  	ASSERT_EQ (state_block->sideband ().details.epoch, nano::epoch::epoch_0);
4365  	ASSERT_TRUE (state_block->sideband ().details.is_receive);
4366  	ASSERT_FALSE (node->latest (key.pub).is_zero ());
4367  }
4368  TEST (rpc, block_create_state_request_work)
4369  {
4370  	std::unique_ptr<nano::state_block> epoch2;
4371  	{
4372  		nano::test::system system (1);
4373  		system.upgrade_genesis_epoch (*system.nodes.front (), nano::epoch::epoch_1);
4374  		epoch2 = system.upgrade_genesis_epoch (*system.nodes.front (), nano::epoch::epoch_2);
4375  	}
4376  	std::vector<std::string> previous_test_input{ epoch2->hash ().to_string (), std::string ("0") };
4377  	for (auto previous : previous_test_input)
4378  	{
4379  		nano::test::system system;
4380  		auto node = add_ipc_enabled_node (system);
4381  		nano::keypair key;
4382  		system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
4383  		auto const rpc_ctx = add_rpc (system, node);
4384  		boost::property_tree::ptree request;
4385  		request.put ("action", "block_create");
4386  		request.put ("type", "state");
4387  		request.put ("wallet", node->wallets.items.begin ()->first.to_string ());
4388  		request.put ("account", nano::dev::genesis_key.pub.to_account ());
4389  		request.put ("representative", nano::dev::genesis_key.pub.to_account ());
4390  		request.put ("balance", (nano::dev::constants.genesis_amount - nano::Gxrb_ratio).convert_to<std::string> ());
4391  		request.put ("link", key.pub.to_account ());
4392  		request.put ("previous", previous);
4393  		auto response (wait_response (system, rpc_ctx, request));
4394  		boost::property_tree::ptree block_l;
4395  		std::stringstream block_stream (response.get<std::string> ("block"));
4396  		boost::property_tree::read_json (block_stream, block_l);
4397  		auto block (nano::deserialize_block_json (block_l));
4398  		ASSERT_NE (nullptr, block);
4399  		ASSERT_GE (nano::dev::network_params.work.difficulty (*block), node->default_difficulty (nano::work_version::work_1));
4400  	}
4401  }
4402  TEST (rpc, block_create_open_epoch_v2)
4403  {
4404  	nano::test::system system;
4405  	auto node = add_ipc_enabled_node (system);
4406  	nano::keypair key;
4407  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
4408  	ASSERT_NE (nullptr, system.upgrade_genesis_epoch (*node, nano::epoch::epoch_1));
4409  	ASSERT_NE (nullptr, system.upgrade_genesis_epoch (*node, nano::epoch::epoch_2));
4410  	auto send_block (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key.pub, nano::Gxrb_ratio));
4411  	ASSERT_NE (nullptr, send_block);
4412  	auto const rpc_ctx = add_rpc (system, node);
4413  	boost::property_tree::ptree request;
4414  	request.put ("action", "block_create");
4415  	request.put ("type", "state");
4416  	request.put ("key", key.prv.to_string ());
4417  	request.put ("account", key.pub.to_account ());
4418  	request.put ("previous", 0);
4419  	request.put ("representative", nano::dev::genesis_key.pub.to_account ());
4420  	request.put ("balance", nano::Gxrb_ratio.convert_to<std::string> ());
4421  	request.put ("link", send_block->hash ().to_string ());
4422  	auto response (wait_response (system, rpc_ctx, request));
4423  	std::string state_hash (response.get<std::string> ("hash"));
4424  	auto state_text (response.get<std::string> ("block"));
4425  	std::stringstream block_stream (state_text);
4426  	boost::property_tree::ptree block_l;
4427  	boost::property_tree::read_json (block_stream, block_l);
4428  	auto state_block (nano::deserialize_block_json (block_l));
4429  	ASSERT_NE (nullptr, state_block);
4430  	ASSERT_EQ (nano::block_type::state, state_block->type ());
4431  	ASSERT_EQ (state_hash, state_block->hash ().to_string ());
4432  	auto difficulty (nano::dev::network_params.work.difficulty (*state_block));
4433  	ASSERT_GT (difficulty, nano::dev::network_params.work.threshold (state_block->work_version (), nano::block_details (nano::epoch::epoch_2, false, true, false)));
4434  	ASSERT_TRUE (node->latest (key.pub).is_zero ());
4435  	auto process_result (node->process (*state_block));
4436  	ASSERT_EQ (nano::process_result::progress, process_result.code);
4437  	ASSERT_EQ (state_block->sideband ().details.epoch, nano::epoch::epoch_2);
4438  	ASSERT_TRUE (state_block->sideband ().details.is_receive);
4439  	ASSERT_FALSE (node->latest (key.pub).is_zero ());
4440  }
4441  TEST (rpc, block_create_receive_epoch_v2)
4442  {
4443  	nano::test::system system;
4444  	auto node = add_ipc_enabled_node (system);
4445  	nano::keypair key;
4446  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
4447  	ASSERT_NE (nullptr, system.upgrade_genesis_epoch (*node, nano::epoch::epoch_1));
4448  	auto send_block (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key.pub, nano::Gxrb_ratio));
4449  	ASSERT_NE (nullptr, send_block);
4450  	nano::block_builder builder;
4451  	auto open = builder
4452  				.state ()
4453  				.account (key.pub)
4454  				.previous (0)
4455  				.representative (nano::dev::genesis_key.pub)
4456  				.balance (nano::Gxrb_ratio)
4457  				.link (send_block->hash ())
4458  				.sign (key.prv, key.pub)
4459  				.work (*node->work_generate_blocking (key.pub))
4460  				.build ();
4461  	ASSERT_EQ (nano::process_result::progress, node->process (*open).code);
4462  	ASSERT_NE (nullptr, system.upgrade_genesis_epoch (*node, nano::epoch::epoch_2));
4463  	auto send_block_2 (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key.pub, nano::Gxrb_ratio));
4464  	auto const rpc_ctx = add_rpc (system, node);
4465  	boost::property_tree::ptree request;
4466  	request.put ("action", "block_create");
4467  	request.put ("type", "state");
4468  	request.put ("key", key.prv.to_string ());
4469  	request.put ("account", key.pub.to_account ());
4470  	request.put ("previous", open->hash ().to_string ());
4471  	request.put ("representative", nano::dev::genesis_key.pub.to_account ());
4472  	request.put ("balance", (2 * nano::Gxrb_ratio).convert_to<std::string> ());
4473  	request.put ("link", send_block_2->hash ().to_string ());
4474  	auto response (wait_response (system, rpc_ctx, request));
4475  	std::string state_hash (response.get<std::string> ("hash"));
4476  	auto state_text (response.get<std::string> ("block"));
4477  	std::stringstream block_stream (state_text);
4478  	boost::property_tree::ptree block_l;
4479  	boost::property_tree::read_json (block_stream, block_l);
4480  	auto state_block (nano::deserialize_block_json (block_l));
4481  	ASSERT_NE (nullptr, state_block);
4482  	ASSERT_EQ (nano::block_type::state, state_block->type ());
4483  	ASSERT_EQ (state_hash, state_block->hash ().to_string ());
4484  	auto difficulty (nano::dev::network_params.work.difficulty (*state_block));
4485  	ASSERT_GT (difficulty, nano::dev::network_params.work.threshold (state_block->work_version (), nano::block_details (nano::epoch::epoch_2, false, true, false)));
4486  	auto process_result (node->process (*state_block));
4487  	ASSERT_EQ (nano::process_result::progress, process_result.code);
4488  	ASSERT_EQ (state_block->sideband ().details.epoch, nano::epoch::epoch_2);
4489  	ASSERT_TRUE (state_block->sideband ().details.is_receive);
4490  	ASSERT_FALSE (node->latest (key.pub).is_zero ());
4491  }
4492  TEST (rpc, block_create_send_epoch_v2)
4493  {
4494  	nano::test::system system;
4495  	auto node = add_ipc_enabled_node (system);
4496  	nano::keypair key;
4497  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
4498  	ASSERT_NE (nullptr, system.upgrade_genesis_epoch (*node, nano::epoch::epoch_1));
4499  	ASSERT_NE (nullptr, system.upgrade_genesis_epoch (*node, nano::epoch::epoch_2));
4500  	auto send_block (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key.pub, nano::Gxrb_ratio));
4501  	ASSERT_NE (nullptr, send_block);
4502  	nano::block_builder builder;
4503  	auto open = builder
4504  				.state ()
4505  				.account (key.pub)
4506  				.previous (0)
4507  				.representative (nano::dev::genesis_key.pub)
4508  				.balance (nano::Gxrb_ratio)
4509  				.link (send_block->hash ())
4510  				.sign (key.prv, key.pub)
4511  				.work (*node->work_generate_blocking (key.pub))
4512  				.build ();
4513  	ASSERT_EQ (nano::process_result::progress, node->process (*open).code);
4514  	auto const rpc_ctx = add_rpc (system, node);
4515  	boost::property_tree::ptree request;
4516  	request.put ("action", "block_create");
4517  	request.put ("type", "state");
4518  	request.put ("key", key.prv.to_string ());
4519  	request.put ("account", key.pub.to_account ());
4520  	request.put ("previous", open->hash ().to_string ());
4521  	request.put ("representative", nano::dev::genesis_key.pub.to_account ());
4522  	request.put ("balance", 0);
4523  	request.put ("link", nano::dev::genesis_key.pub.to_string ());
4524  	auto response (wait_response (system, rpc_ctx, request));
4525  	std::string state_hash (response.get<std::string> ("hash"));
4526  	auto state_text (response.get<std::string> ("block"));
4527  	std::stringstream block_stream (state_text);
4528  	boost::property_tree::ptree block_l;
4529  	boost::property_tree::read_json (block_stream, block_l);
4530  	auto state_block (nano::deserialize_block_json (block_l));
4531  	ASSERT_NE (nullptr, state_block);
4532  	ASSERT_EQ (nano::block_type::state, state_block->type ());
4533  	ASSERT_EQ (state_hash, state_block->hash ().to_string ());
4534  	auto difficulty (nano::dev::network_params.work.difficulty (*state_block));
4535  	ASSERT_GT (difficulty, nano::dev::network_params.work.threshold (state_block->work_version (), nano::block_details (nano::epoch::epoch_2, true, false, false)));
4536  	auto process_result (node->process (*state_block));
4537  	ASSERT_EQ (nano::process_result::progress, process_result.code);
4538  	ASSERT_EQ (state_block->sideband ().details.epoch, nano::epoch::epoch_2);
4539  	ASSERT_TRUE (state_block->sideband ().details.is_send);
4540  	ASSERT_FALSE (node->latest (key.pub).is_zero ());
4541  }
4542  TEST (rpc, block_hash)
4543  {
4544  	nano::test::system system;
4545  	auto node1 = add_ipc_enabled_node (system);
4546  	auto const rpc_ctx = add_rpc (system, node1);
4547  	nano::keypair key;
4548  	auto latest (node1->latest (nano::dev::genesis_key.pub));
4549  	nano::block_builder builder;
4550  	auto send = builder
4551  				.send ()
4552  				.previous (latest)
4553  				.destination (key.pub)
4554  				.balance (100)
4555  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
4556  				.work (*node1->work_generate_blocking (latest))
4557  				.build ();
4558  	boost::property_tree::ptree request;
4559  	request.put ("action", "block_hash");
4560  	std::string json;
4561  	send->serialize_json (json);
4562  	request.put ("block", json);
4563  	auto response (wait_response (system, rpc_ctx, request));
4564  	std::string send_hash (response.get<std::string> ("hash"));
4565  	ASSERT_EQ (send->hash ().to_string (), send_hash);
4566  }
4567  TEST (rpc, wallet_lock)
4568  {
4569  	nano::test::system system;
4570  	auto node = add_ipc_enabled_node (system);
4571  	auto const rpc_ctx = add_rpc (system, node);
4572  	boost::property_tree::ptree request;
4573  	std::string wallet;
4574  	node->wallets.items.begin ()->first.encode_hex (wallet);
4575  	{
4576  		auto transaction (system.wallet (0)->wallets.tx_begin_read ());
4577  		ASSERT_TRUE (system.wallet (0)->store.valid_password (transaction));
4578  	}
4579  	request.put ("wallet", wallet);
4580  	request.put ("action", "wallet_lock");
4581  	auto response (wait_response (system, rpc_ctx, request));
4582  	std::string account_text1 (response.get<std::string> ("locked"));
4583  	ASSERT_EQ (account_text1, "1");
4584  	auto transaction (system.wallet (0)->wallets.tx_begin_read ());
4585  	ASSERT_FALSE (system.wallet (0)->store.valid_password (transaction));
4586  }
4587  TEST (rpc, wallet_locked)
4588  {
4589  	nano::test::system system;
4590  	auto node = add_ipc_enabled_node (system);
4591  	auto const rpc_ctx = add_rpc (system, node);
4592  	boost::property_tree::ptree request;
4593  	std::string wallet;
4594  	node->wallets.items.begin ()->first.encode_hex (wallet);
4595  	request.put ("wallet", wallet);
4596  	request.put ("action", "wallet_locked");
4597  	auto response (wait_response (system, rpc_ctx, request));
4598  	std::string account_text1 (response.get<std::string> ("locked"));
4599  	ASSERT_EQ (account_text1, "0");
4600  }
4601  TEST (rpc, wallet_create_fail)
4602  {
4603  	nano::test::system system;
4604  	auto node = add_ipc_enabled_node (system);
4605  	for (int i = 0; i < 127; i++)
4606  	{
4607  		node->wallets.create (nano::random_wallet_id ());
4608  	}
4609  	auto const rpc_ctx = add_rpc (system, node);
4610  	boost::property_tree::ptree request;
4611  	request.put ("action", "wallet_create");
4612  	auto response (wait_response (system, rpc_ctx, request));
4613  	ASSERT_EQ (std::error_code (nano::error_common::wallet_lmdb_max_dbs).message (), response.get<std::string> ("error"));
4614  }
4615  TEST (rpc, wallet_ledger)
4616  {
4617  	nano::test::system system;
4618  	auto node1 = add_ipc_enabled_node (system);
4619  	nano::keypair key;
4620  	system.wallet (0)->insert_adhoc (key.prv);
4621  	auto latest (node1->latest (nano::dev::genesis_key.pub));
4622  	nano::block_builder builder;
4623  	auto send = builder
4624  				.send ()
4625  				.previous (latest)
4626  				.destination (key.pub)
4627  				.balance (100)
4628  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
4629  				.work (*node1->work_generate_blocking (latest))
4630  				.build ();
4631  	ASSERT_EQ (nano::process_result::progress, node1->process (*send).code);
4632  	auto open = builder
4633  				.open ()
4634  				.source (send->hash ())
4635  				.representative (nano::dev::genesis_key.pub)
4636  				.account (key.pub)
4637  				.sign (key.prv, key.pub)
4638  				.work (*node1->work_generate_blocking (key.pub))
4639  				.build ();
4640  	ASSERT_EQ (nano::process_result::progress, node1->process (*open).code);
4641  	auto time = nano::seconds_since_epoch ();
4642  	auto const rpc_ctx = add_rpc (system, node1);
4643  	boost::property_tree::ptree request;
4644  	request.put ("action", "wallet_ledger");
4645  	request.put ("wallet", node1->wallets.items.begin ()->first.to_string ());
4646  	request.put ("sorting", "1");
4647  	request.put ("count", "1");
4648  	auto response (wait_response (system, rpc_ctx, request));
4649  	for (auto & accounts : response.get_child ("accounts"))
4650  	{
4651  		std::string account_text (accounts.first);
4652  		ASSERT_EQ (key.pub.to_account (), account_text);
4653  		std::string frontier (accounts.second.get<std::string> ("frontier"));
4654  		ASSERT_EQ (open->hash ().to_string (), frontier);
4655  		std::string open_block (accounts.second.get<std::string> ("open_block"));
4656  		ASSERT_EQ (open->hash ().to_string (), open_block);
4657  		std::string representative_block (accounts.second.get<std::string> ("representative_block"));
4658  		ASSERT_EQ (open->hash ().to_string (), representative_block);
4659  		std::string balance_text (accounts.second.get<std::string> ("balance"));
4660  		ASSERT_EQ ("340282366920938463463374607431768211355", balance_text);
4661  		std::string modified_timestamp (accounts.second.get<std::string> ("modified_timestamp"));
4662  		ASSERT_LT (std::abs ((long)time - stol (modified_timestamp)), 5);
4663  		std::string block_count (accounts.second.get<std::string> ("block_count"));
4664  		ASSERT_EQ ("1", block_count);
4665  		boost::optional<std::string> weight (accounts.second.get_optional<std::string> ("weight"));
4666  		ASSERT_FALSE (weight.is_initialized ());
4667  		boost::optional<std::string> pending (accounts.second.get_optional<std::string> ("pending"));
4668  		ASSERT_FALSE (pending.is_initialized ());
4669  		boost::optional<std::string> representative (accounts.second.get_optional<std::string> ("representative"));
4670  		ASSERT_FALSE (representative.is_initialized ());
4671  	}
4672  	request.put ("weight", "true");
4673  	request.put ("pending", "1");
4674  	request.put ("representative", "false");
4675  	auto response2 (wait_response (system, rpc_ctx, request));
4676  	for (auto & accounts : response2.get_child ("accounts"))
4677  	{
4678  		boost::optional<std::string> weight (accounts.second.get_optional<std::string> ("weight"));
4679  		ASSERT_TRUE (weight.is_initialized ());
4680  		ASSERT_EQ ("0", weight.get ());
4681  		boost::optional<std::string> pending (accounts.second.get_optional<std::string> ("pending"));
4682  		ASSERT_TRUE (pending.is_initialized ());
4683  		ASSERT_EQ ("0", pending.get ());
4684  		boost::optional<std::string> representative (accounts.second.get_optional<std::string> ("representative"));
4685  		ASSERT_FALSE (representative.is_initialized ());
4686  	}
4687  }
4688  TEST (rpc, wallet_add_watch)
4689  {
4690  	nano::test::system system;
4691  	auto node = add_ipc_enabled_node (system);
4692  	auto const rpc_ctx = add_rpc (system, node);
4693  	boost::property_tree::ptree request;
4694  	std::string wallet;
4695  	node->wallets.items.begin ()->first.encode_hex (wallet);
4696  	request.put ("wallet", wallet);
4697  	request.put ("action", "wallet_add_watch");
4698  	boost::property_tree::ptree entry;
4699  	boost::property_tree::ptree peers_l;
4700  	entry.put ("", nano::dev::genesis_key.pub.to_account ());
4701  	peers_l.push_back (std::make_pair ("", entry));
4702  	request.add_child ("accounts", peers_l);
4703  	auto response (wait_response (system, rpc_ctx, request));
4704  	std::string success (response.get<std::string> ("success"));
4705  	ASSERT_TRUE (success.empty ());
4706  	ASSERT_TRUE (system.wallet (0)->exists (nano::dev::genesis_key.pub));
4707  	nano::public_key bad_key (1);
4708  	entry.put ("", bad_key.to_account ());
4709  	peers_l.push_back (std::make_pair ("", entry));
4710  	request.erase ("accounts");
4711  	request.add_child ("accounts", peers_l);
4712  	auto response_error (wait_response (system, rpc_ctx, request));
4713  	std::error_code ec (nano::error_common::bad_public_key);
4714  	ASSERT_EQ (response_error.get<std::string> ("error"), ec.message ());
4715  }
4716  TEST (rpc, online_reps)
4717  {
4718  	nano::test::system system (1);
4719  	auto node1 (system.nodes[0]);
4720  	auto node2 = add_ipc_enabled_node (system);
4721  	nano::keypair key;
4722  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
4723  	ASSERT_EQ (node2->online_reps.online (), 0);
4724  	auto send_block (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key.pub, nano::Gxrb_ratio));
4725  	ASSERT_NE (nullptr, send_block);
4726  	ASSERT_TIMELY (10s, !node2->online_reps.list ().empty ());
4727  	ASSERT_EQ (node2->online_reps.online (), nano::dev::constants.genesis_amount - nano::Gxrb_ratio);
4728  	auto const rpc_ctx = add_rpc (system, node2);
4729  	boost::property_tree::ptree request;
4730  	request.put ("action", "representatives_online");
4731  	auto response (wait_response (system, rpc_ctx, request));
4732  	auto representatives (response.get_child ("representatives"));
4733  	auto item (representatives.begin ());
4734  	ASSERT_NE (representatives.end (), item);
4735  	ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), item->second.get<std::string> (""));
4736  	boost::optional<std::string> weight (item->second.get_optional<std::string> ("weight"));
4737  	ASSERT_FALSE (weight.is_initialized ());
4738  	ASSERT_TIMELY (5s, node2->block (send_block->hash ()));
4739  	request.put ("weight", "true");
4740  	auto response2 (wait_response (system, rpc_ctx, request));
4741  	auto representatives2 (response2.get_child ("representatives"));
4742  	auto item2 (representatives2.begin ());
4743  	ASSERT_NE (representatives2.end (), item2);
4744  	ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), item2->first);
4745  	auto weight2 (item2->second.get<std::string> ("weight"));
4746  	ASSERT_EQ (node2->weight (nano::dev::genesis_key.pub).convert_to<std::string> (), weight2);
4747  	auto new_rep (system.wallet (1)->deterministic_insert ());
4748  	auto send (system.wallet (0)->send_action (nano::dev::genesis_key.pub, new_rep, node1->config.receive_minimum.number ()));
4749  	ASSERT_NE (nullptr, send);
4750  	ASSERT_TIMELY (10s, node2->block (send->hash ()));
4751  	auto receive (system.wallet (1)->receive_action (send->hash (), new_rep, node1->config.receive_minimum.number (), send->link ().as_account ()));
4752  	ASSERT_NE (nullptr, receive);
4753  	ASSERT_TIMELY (5s, node2->block (receive->hash ()));
4754  	auto change (system.wallet (0)->change_action (nano::dev::genesis_key.pub, new_rep));
4755  	ASSERT_NE (nullptr, change);
4756  	ASSERT_TIMELY (5s, node2->block (change->hash ()));
4757  	ASSERT_TIMELY (5s, node2->online_reps.list ().size () == 2);
4758  	boost::property_tree::ptree child_rep;
4759  	child_rep.put ("", new_rep.to_account ());
4760  	boost::property_tree::ptree filtered_accounts;
4761  	filtered_accounts.push_back (std::make_pair ("", child_rep));
4762  	request.add_child ("accounts", filtered_accounts);
4763  	auto response3 (wait_response (system, rpc_ctx, request, 10s));
4764  	auto representatives3 (response3.get_child ("representatives"));
4765  	auto item3 (representatives3.begin ());
4766  	ASSERT_NE (representatives3.end (), item3);
4767  	ASSERT_EQ (new_rep.to_account (), item3->first);
4768  	ASSERT_EQ (representatives3.size (), 1);
4769  	node2->stop ();
4770  }
4771  TEST (rpc, confirmation_height_currently_processing)
4772  {
4773  	nano::test::system system;
4774  	nano::node_flags node_flags;
4775  	node_flags.force_use_write_database_queue = true;
4776  	nano::node_config node_config = system.default_config ();
4777  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
4778  	auto node = add_ipc_enabled_node (system, node_config, node_flags);
4779  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
4780  	auto previous_genesis_chain_hash = node->latest (nano::dev::genesis_key.pub);
4781  	{
4782  		auto transaction = node->store.tx_begin_write ();
4783  		nano::keypair key1;
4784  		nano::block_builder builder;
4785  		auto send = builder
4786  					.send ()
4787  					.previous (previous_genesis_chain_hash)
4788  					.destination (key1.pub)
4789  					.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio - 1)
4790  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
4791  					.work (*system.work.generate (previous_genesis_chain_hash))
4792  					.build ();
4793  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *send).code);
4794  		previous_genesis_chain_hash = send->hash ();
4795  	}
4796  	std::shared_ptr<nano::block> frontier;
4797  	{
4798  		auto transaction = node->store.tx_begin_read ();
4799  		frontier = node->store.block.get (transaction, previous_genesis_chain_hash);
4800  	}
4801  	boost::property_tree::ptree request;
4802  	request.put ("action", "confirmation_height_currently_processing");
4803  	auto const rpc_ctx = add_rpc (system, node);
4804  	{
4805  		auto write_guard = node->write_database_queue.wait (nano::writer::testing);
4806  		nano::test::start_election (system, *node, frontier->hash ());
4807  		ASSERT_TIMELY (5s, node->confirmation_height_processor.current () == frontier->hash ());
4808  		{
4809  			auto response (wait_response (system, rpc_ctx, request, 10s));
4810  			auto hash (response.get<std::string> ("hash"));
4811  			ASSERT_EQ (frontier->hash ().to_string (), hash);
4812  		}
4813  	}
4814  	ASSERT_TIMELY (10s, node->confirmation_height_processor.current ().is_zero () && node->confirmation_height_processor.awaiting_processing_size () == 0);
4815  	{
4816  		auto response (wait_response (system, rpc_ctx, request, 10s));
4817  		std::error_code ec (nano::error_rpc::confirmation_height_not_processing);
4818  		ASSERT_EQ (response.get<std::string> ("error"), ec.message ());
4819  	}
4820  }
4821  TEST (rpc, confirmation_history)
4822  {
4823  	nano::test::system system;
4824  	auto node = add_ipc_enabled_node (system);
4825  	nano::keypair key;
4826  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
<span onclick='openModal()' class='match'>4827  	ASSERT_TRUE (node->active.recently_cemented.list ().empty ());
4828  	auto block (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key.pub, nano::Gxrb_ratio));
4829  	ASSERT_TIMELY (10s, !node->active.recently_cemented.list ().empty ());
</span>4830  	auto const rpc_ctx = add_rpc (system, node);
4831  	boost::property_tree::ptree request;
4832  	request.put ("action", "confirmation_history");
4833  	auto response (wait_response (system, rpc_ctx, request));
4834  	auto representatives (response.get_child ("confirmations"));
4835  	auto item (representatives.begin ());
4836  	ASSERT_NE (representatives.end (), item);
4837  	auto hash (item->second.get<std::string> ("hash"));
4838  	auto tally (item->second.get<std::string> ("tally"));
4839  	auto final_tally (item->second.get<std::string> ("final"));
4840  	ASSERT_EQ (1, item->second.count ("duration"));
4841  	ASSERT_EQ (1, item->second.count ("time"));
4842  	ASSERT_EQ (1, item->second.count ("request_count"));
4843  	ASSERT_EQ (1, item->second.count ("voters"));
4844  	ASSERT_GE (1U, item->second.get<unsigned> ("blocks"));
4845  	ASSERT_EQ (block->hash ().to_string (), hash);
4846  	nano::amount tally_num;
4847  	tally_num.decode_dec (tally);
4848  	debug_assert (tally_num == nano::dev::constants.genesis_amount || tally_num == (nano::dev::constants.genesis_amount - nano::Gxrb_ratio));
4849  	system.stop ();
4850  }
4851  TEST (rpc, confirmation_history_hash)
4852  {
4853  	nano::test::system system;
4854  	auto node = add_ipc_enabled_node (system);
4855  	nano::keypair key;
4856  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
4857  	ASSERT_TRUE (node->active.recently_cemented.list ().empty ());
4858  	auto send1 (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key.pub, nano::Gxrb_ratio));
4859  	auto send2 (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key.pub, nano::Gxrb_ratio));
4860  	auto send3 (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key.pub, nano::Gxrb_ratio));
4861  	ASSERT_TIMELY (10s, node->active.recently_cemented.list ().size () == 3);
4862  	auto const rpc_ctx = add_rpc (system, node);
4863  	boost::property_tree::ptree request;
4864  	request.put ("action", "confirmation_history");
4865  	request.put ("hash", send2->hash ().to_string ());
4866  	auto response (wait_response (system, rpc_ctx, request));
4867  	auto representatives (response.get_child ("confirmations"));
4868  	ASSERT_EQ (representatives.size (), 1);
4869  	auto item (representatives.begin ());
4870  	ASSERT_NE (representatives.end (), item);
4871  	auto hash (item->second.get<std::string> ("hash"));
4872  	auto tally (item->second.get<std::string> ("tally"));
4873  	ASSERT_FALSE (item->second.get<std::string> ("duration", "").empty ());
4874  	ASSERT_FALSE (item->second.get<std::string> ("time", "").empty ());
4875  	ASSERT_EQ (send2->hash ().to_string (), hash);
4876  	nano::amount tally_num;
4877  	tally_num.decode_dec (tally);
4878  	debug_assert (tally_num == nano::dev::constants.genesis_amount || tally_num == (nano::dev::constants.genesis_amount - nano::Gxrb_ratio) || tally_num == (nano::dev::constants.genesis_amount - 2 * nano::Gxrb_ratio) || tally_num == (nano::dev::constants.genesis_amount - 3 * nano::Gxrb_ratio));
4879  	system.stop ();
4880  }
4881  TEST (rpc, block_confirm)
4882  {
4883  	nano::test::system system;
4884  	auto node = add_ipc_enabled_node (system);
4885  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
4886  	nano::block_builder builder;
4887  	auto send1 = builder
4888  				 .state ()
4889  				 .account (nano::dev::genesis_key.pub)
4890  				 .previous (nano::dev::genesis->hash ())
4891  				 .representative (nano::dev::genesis_key.pub)
4892  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
4893  				 .link (nano::dev::genesis_key.pub)
4894  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
4895  				 .work (*node->work_generate_blocking (nano::dev::genesis->hash ()))
4896  				 .build_shared ();
4897  	{
4898  		auto transaction (node->store.tx_begin_write ());
4899  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *send1).code);
4900  	}
4901  	auto const rpc_ctx = add_rpc (system, node);
4902  	boost::property_tree::ptree request;
4903  	request.put ("action", "block_confirm");
4904  	request.put ("hash", send1->hash ().to_string ());
4905  	auto response (wait_response (system, rpc_ctx, request));
4906  	ASSERT_EQ ("1", response.get<std::string> ("started"));
4907  }
4908  TEST (rpc, block_confirm_absent)
4909  {
4910  	nano::test::system system;
4911  	auto node = add_ipc_enabled_node (system);
4912  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
4913  	auto const rpc_ctx = add_rpc (system, node);
4914  	boost::property_tree::ptree request;
4915  	request.put ("action", "block_confirm");
4916  	request.put ("hash", "0");
4917  	auto response (wait_response (system, rpc_ctx, request));
4918  	ASSERT_EQ (std::error_code (nano::error_blocks::not_found).message (), response.get<std::string> ("error"));
4919  }
4920  TEST (rpc, block_confirm_confirmed)
4921  {
4922  	nano::test::system system (1);
4923  	auto path (nano::unique_path ());
4924  	nano::node_config config;
4925  	config.peering_port = system.get_available_port ();
4926  	config.callback_address = "localhost";
4927  	config.callback_port = system.get_available_port ();
4928  	config.callback_target = "/";
4929  	config.logging.init (path);
4930  	auto node = add_ipc_enabled_node (system, config);
4931  	{
4932  		auto transaction (node->store.tx_begin_read ());
4933  		ASSERT_TRUE (node->ledger.block_confirmed (transaction, nano::dev::genesis->hash ()));
4934  	}
4935  	ASSERT_EQ (0, node->stats.count (nano::stat::type::error, nano::stat::detail::http_callback, nano::stat::dir::out));
4936  	auto const rpc_ctx = add_rpc (system, node);
4937  	boost::property_tree::ptree request;
4938  	request.put ("action", "block_confirm");
4939  	request.put ("hash", nano::dev::genesis->hash ().to_string ());
4940  	auto response (wait_response (system, rpc_ctx, request));
4941  	ASSERT_EQ ("1", response.get<std::string> ("started"));
4942  	auto confirmed (node->active.recently_cemented.list ());
4943  	ASSERT_EQ (1, confirmed.size ());
4944  	ASSERT_EQ (nano::dev::genesis->hash (), confirmed.begin ()->winner->hash ());
4945  	ASSERT_TIMELY (10s, node->stats.count (nano::stat::type::error, nano::stat::detail::http_callback, nano::stat::dir::out) != 0);
4946  	ASSERT_EQ (1, node->stats.count (nano::stat::type::error, nano::stat::detail::http_callback, nano::stat::dir::out));
4947  	node->stop ();
4948  }
4949  TEST (rpc, node_id)
4950  {
4951  	nano::test::system system;
4952  	auto node = add_ipc_enabled_node (system);
4953  	auto const rpc_ctx = add_rpc (system, node);
4954  	boost::property_tree::ptree request;
4955  	request.put ("action", "node_id");
4956  	auto response (wait_response (system, rpc_ctx, request));
4957  	ASSERT_EQ (node->node_id.prv.to_string (), response.get<std::string> ("private"));
4958  	ASSERT_EQ (node->node_id.pub.to_account (), response.get<std::string> ("as_account"));
4959  	ASSERT_EQ (node->node_id.pub.to_node_id (), response.get<std::string> ("node_id"));
4960  }
4961  TEST (rpc, stats_clear)
4962  {
4963  	nano::test::system system;
4964  	auto node = add_ipc_enabled_node (system);
4965  	auto const rpc_ctx = add_rpc (system, node);
4966  	nano::keypair key;
4967  	node->stats.inc (nano::stat::type::ledger, nano::stat::dir::in);
4968  	ASSERT_EQ (1, node->stats.count (nano::stat::type::ledger, nano::stat::dir::in));
4969  	boost::property_tree::ptree request;
4970  	request.put ("action", "stats_clear");
4971  	auto response (wait_response (system, rpc_ctx, request));
4972  	std::string success (response.get<std::string> ("success"));
4973  	ASSERT_TRUE (success.empty ());
4974  	ASSERT_EQ (0, node->stats.count (nano::stat::type::ledger, nano::stat::dir::in));
4975  	ASSERT_LE (node->stats.last_reset ().count (), 5);
4976  }
4977  TEST (rpc, unchecked)
4978  {
4979  	nano::test::system system{};
4980  	auto node = add_ipc_enabled_node (system);
4981  	auto const rpc_ctx = add_rpc (system, node);
4982  	nano::keypair key{};
4983  	nano::block_builder builder;
4984  	auto open = builder
4985  				.state ()
4986  				.account (key.pub)
4987  				.previous (0)
4988  				.representative (key.pub)
4989  				.balance (1)
4990  				.link (key.pub)
4991  				.sign (key.prv, key.pub)
4992  				.work (*system.work.generate (key.pub))
4993  				.build_shared ();
4994  	auto open2 = builder
4995  				 .state ()
4996  				 .account (key.pub)
4997  				 .previous (0)
4998  				 .representative (key.pub)
4999  				 .balance (2)
5000  				 .link (key.pub)
5001  				 .sign (key.prv, key.pub)
5002  				 .work (*system.work.generate (key.pub))
5003  				 .build_shared ();
5004  	node->process_active (open);
5005  	node->process_active (open2);
5006  	ASSERT_TIMELY (10s, 2 == node->unchecked.count ());
5007  	boost::property_tree::ptree request;
5008  	request.put ("action", "unchecked");
5009  	request.put ("count", 2);
5010  	{
5011  		auto response (wait_response (system, rpc_ctx, request));
5012  		auto & blocks (response.get_child ("blocks"));
5013  		ASSERT_EQ (2, blocks.size ());
5014  		ASSERT_EQ (1, blocks.count (open->hash ().to_string ()));
5015  		ASSERT_EQ (1, blocks.count (open2->hash ().to_string ()));
5016  	}
5017  	request.put ("json_block", true);
5018  	{
5019  		auto response (wait_response (system, rpc_ctx, request));
5020  		auto & blocks (response.get_child ("blocks"));
5021  		ASSERT_EQ (2, blocks.size ());
5022  		auto & open_block (blocks.get_child (open->hash ().to_string ()));
5023  		ASSERT_EQ ("state", open_block.get<std::string> ("type"));
5024  	}
5025  }
5026  TEST (rpc, unchecked_get)
5027  {
5028  	nano::test::system system{};
5029  	auto node = add_ipc_enabled_node (system);
5030  	auto const rpc_ctx = add_rpc (system, node);
5031  	nano::keypair key{};
5032  	nano::block_builder builder;
5033  	auto open = builder
5034  				.state ()
5035  				.account (key.pub)
5036  				.previous (0)
5037  				.representative (key.pub)
5038  				.balance (1)
5039  				.link (key.pub)
5040  				.sign (key.prv, key.pub)
5041  				.work (*system.work.generate (key.pub))
5042  				.build_shared ();
5043  	node->process_active (open);
5044  	ASSERT_TIMELY (10s, 1 == node->unchecked.count ());
5045  	boost::property_tree::ptree request{};
5046  	request.put ("action", "unchecked_get");
5047  	request.put ("hash", open->hash ().to_string ());
5048  	{
5049  		auto response (wait_response (system, rpc_ctx, request));
5050  		ASSERT_EQ (1, response.count ("contents"));
5051  		auto timestamp (response.get<nano::seconds_t> ("modified_timestamp"));
5052  		ASSERT_LE (timestamp, nano::seconds_since_epoch ());
5053  	}
5054  	request.put ("json_block", true);
5055  	{
5056  		auto response (wait_response (system, rpc_ctx, request));
5057  		auto & contents (response.get_child ("contents"));
5058  		ASSERT_EQ ("state", contents.get<std::string> ("type"));
5059  		auto timestamp (response.get<nano::seconds_t> ("modified_timestamp"));
5060  		ASSERT_LE (timestamp, nano::seconds_since_epoch ());
5061  	}
5062  }
5063  TEST (rpc, unchecked_clear)
5064  {
5065  	nano::test::system system{};
5066  	auto node = add_ipc_enabled_node (system);
5067  	auto const rpc_ctx = add_rpc (system, node);
5068  	nano::keypair key{};
5069  	nano::block_builder builder;
5070  	auto open = builder
5071  				.state ()
5072  				.account (key.pub)
5073  				.previous (0)
5074  				.representative (key.pub)
5075  				.balance (1)
5076  				.link (key.pub)
5077  				.sign (key.prv, key.pub)
5078  				.work (*system.work.generate (key.pub))
5079  				.build_shared ();
5080  	node->process_active (open);
5081  	boost::property_tree::ptree request{};
5082  	ASSERT_TIMELY (10s, 1 == node->unchecked.count ());
5083  	request.put ("action", "unchecked_clear");
5084  	auto response = wait_response (system, rpc_ctx, request);
5085  	ASSERT_TIMELY (10s, 0 == node->unchecked.count ());
5086  }
5087  TEST (rpc, unopened)
5088  {
5089  	nano::test::system system;
5090  	auto node = add_ipc_enabled_node (system);
5091  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
5092  	nano::account account1 (1), account2 (account1.number () + 1);
5093  	auto genesis (node->latest (nano::dev::genesis_key.pub));
5094  	ASSERT_FALSE (genesis.is_zero ());
5095  	auto send (system.wallet (0)->send_action (nano::dev::genesis_key.pub, account1, 1));
5096  	ASSERT_NE (nullptr, send);
5097  	auto send2 (system.wallet (0)->send_action (nano::dev::genesis_key.pub, account2, 10));
5098  	ASSERT_NE (nullptr, send2);
5099  	auto const rpc_ctx = add_rpc (system, node);
5100  	{
5101  		boost::property_tree::ptree request;
5102  		request.put ("action", "unopened");
5103  		auto response (wait_response (system, rpc_ctx, request));
5104  		auto & accounts (response.get_child ("accounts"));
5105  		ASSERT_EQ (2, accounts.size ());
5106  		ASSERT_EQ ("1", accounts.get<std::string> (account1.to_account ()));
5107  		ASSERT_EQ ("10", accounts.get<std::string> (account2.to_account ()));
5108  	}
5109  	{
5110  		boost::property_tree::ptree request;
5111  		request.put ("action", "unopened");
5112  		request.put ("account", account2.to_account ());
5113  		auto response (wait_response (system, rpc_ctx, request));
5114  		auto & accounts (response.get_child ("accounts"));
5115  		ASSERT_EQ (1, accounts.size ());
5116  		ASSERT_EQ ("10", accounts.get<std::string> (account2.to_account ()));
5117  	}
5118  	{
5119  		boost::property_tree::ptree request;
5120  		request.put ("action", "unopened");
5121  		request.put ("account", nano::account (account2.number () + 1).to_account ());
5122  		auto response (wait_response (system, rpc_ctx, request));
5123  		auto & accounts (response.get_child ("accounts"));
5124  		ASSERT_EQ (0, accounts.size ());
5125  	}
5126  	{
5127  		boost::property_tree::ptree request;
5128  		request.put ("action", "unopened");
5129  		request.put ("count", "1");
5130  		auto response (wait_response (system, rpc_ctx, request));
5131  		auto & accounts (response.get_child ("accounts"));
5132  		ASSERT_EQ (1, accounts.size ());
5133  		ASSERT_EQ ("1", accounts.get<std::string> (account1.to_account ()));
5134  	}
5135  	{
5136  		boost::property_tree::ptree request;
5137  		request.put ("action", "unopened");
5138  		request.put ("threshold", 5);
5139  		auto response (wait_response (system, rpc_ctx, request));
5140  		auto & accounts (response.get_child ("accounts"));
5141  		ASSERT_EQ (1, accounts.size ());
5142  		ASSERT_EQ ("10", accounts.get<std::string> (account2.to_account ()));
5143  	}
5144  }
5145  TEST (rpc, unopened_burn)
5146  {
5147  	nano::test::system system;
5148  	auto node = add_ipc_enabled_node (system);
5149  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
5150  	auto genesis (node->latest (nano::dev::genesis_key.pub));
5151  	ASSERT_FALSE (genesis.is_zero ());
5152  	auto send (system.wallet (0)->send_action (nano::dev::genesis_key.pub, nano::dev::constants.burn_account, 1));
5153  	ASSERT_NE (nullptr, send);
5154  	auto const rpc_ctx = add_rpc (system, node);
5155  	boost::property_tree::ptree request;
5156  	request.put ("action", "unopened");
5157  	auto response (wait_response (system, rpc_ctx, request));
5158  	auto & accounts (response.get_child ("accounts"));
5159  	ASSERT_EQ (0, accounts.size ());
5160  }
5161  TEST (rpc, unopened_no_accounts)
5162  {
5163  	nano::test::system system;
5164  	auto node = add_ipc_enabled_node (system);
5165  	auto const rpc_ctx = add_rpc (system, node);
5166  	boost::property_tree::ptree request;
5167  	request.put ("action", "unopened");
5168  	auto response (wait_response (system, rpc_ctx, request));
5169  	auto & accounts (response.get_child ("accounts"));
5170  	ASSERT_EQ (0, accounts.size ());
5171  }
5172  TEST (rpc, uptime)
5173  {
5174  	nano::test::system system;
5175  	auto node = add_ipc_enabled_node (system);
5176  	auto const rpc_ctx = add_rpc (system, node);
5177  	boost::property_tree::ptree request;
5178  	request.put ("action", "uptime");
5179  	std::this_thread::sleep_for (std::chrono::seconds (1));
5180  	auto response (wait_response (system, rpc_ctx, request));
5181  	ASSERT_LE (1, response.get<int> ("seconds"));
5182  }
5183  TEST (rpc, DISABLED_wallet_history)
5184  {
5185  	nano::test::system system;
5186  	nano::node_config node_config = system.default_config ();
5187  	node_config.enable_voting = false;
5188  	auto node = add_ipc_enabled_node (system, node_config);
5189  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
5190  	auto timestamp1 = nano::seconds_since_epoch ();
5191  	auto send (system.wallet (0)->send_action (nano::dev::genesis_key.pub, nano::dev::genesis_key.pub, node->config.receive_minimum.number ()));
5192  	ASSERT_NE (nullptr, send);
5193  	auto timestamp2 = nano::seconds_since_epoch ();
5194  	auto receive (system.wallet (0)->receive_action (send->hash (), nano::dev::genesis_key.pub, node->config.receive_minimum.number (), send->link ().as_account ()));
5195  	ASSERT_NE (nullptr, receive);
5196  	nano::keypair key;
5197  	auto timestamp3 = nano::seconds_since_epoch ();
5198  	auto send2 (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key.pub, node->config.receive_minimum.number ()));
5199  	ASSERT_NE (nullptr, send2);
5200  	system.deadline_set (10s);
5201  	auto const rpc_ctx = add_rpc (system, node);
5202  	boost::property_tree::ptree request;
5203  	request.put ("action", "wallet_history");
5204  	request.put ("wallet", node->wallets.items.begin ()->first.to_string ());
5205  	auto response (wait_response (system, rpc_ctx, request));
5206  	std::vector<std::tuple<std::string, std::string, std::string, std::string, std::string, std::string>> history_l;
5207  	auto & history_node (response.get_child ("history"));
5208  	for (auto i (history_node.begin ()), n (history_node.end ()); i != n; ++i)
5209  	{
5210  		history_l.emplace_back (i->second.get<std::string> ("type"), i->second.get<std::string> ("account"), i->second.get<std::string> ("amount"), i->second.get<std::string> ("hash"), i->second.get<std::string> ("block_account"), i->second.get<std::string> ("local_timestamp"));
5211  	}
5212  	ASSERT_EQ (4, history_l.size ());
5213  	ASSERT_EQ ("send", std::get<0> (history_l[0]));
5214  	ASSERT_EQ (key.pub.to_account (), std::get<1> (history_l[0]));
5215  	ASSERT_EQ (node->config.receive_minimum.to_string_dec (), std::get<2> (history_l[0]));
5216  	ASSERT_EQ (send2->hash ().to_string (), std::get<3> (history_l[0]));
5217  	ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), std::get<4> (history_l[0]));
5218  	ASSERT_EQ (std::to_string (timestamp3), std::get<5> (history_l[0]));
5219  	ASSERT_EQ ("receive", std::get<0> (history_l[1]));
5220  	ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), std::get<1> (history_l[1]));
5221  	ASSERT_EQ (node->config.receive_minimum.to_string_dec (), std::get<2> (history_l[1]));
5222  	ASSERT_EQ (receive->hash ().to_string (), std::get<3> (history_l[1]));
5223  	ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), std::get<4> (history_l[1]));
5224  	ASSERT_EQ (std::to_string (timestamp2), std::get<5> (history_l[1]));
5225  	ASSERT_EQ ("send", std::get<0> (history_l[2]));
5226  	ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), std::get<1> (history_l[2]));
5227  	ASSERT_EQ (node->config.receive_minimum.to_string_dec (), std::get<2> (history_l[2]));
5228  	ASSERT_EQ (send->hash ().to_string (), std::get<3> (history_l[2]));
5229  	ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), std::get<4> (history_l[2]));
5230  	ASSERT_EQ (std::to_string (timestamp1), std::get<5> (history_l[2]));
5231  	ASSERT_EQ ("receive", std::get<0> (history_l[3]));
5232  	ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), std::get<1> (history_l[3]));
5233  	ASSERT_EQ (nano::dev::constants.genesis_amount.convert_to<std::string> (), std::get<2> (history_l[3]));
5234  	ASSERT_EQ (nano::dev::genesis->hash ().to_string (), std::get<3> (history_l[3]));
5235  	ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), std::get<4> (history_l[3]));
5236  }
5237  TEST (rpc, sign_hash)
5238  {
5239  	nano::test::system system;
5240  	auto node1 = add_ipc_enabled_node (system);
5241  	nano::keypair key;
5242  	nano::block_builder builder;
5243  	auto send = builder
5244  				.state ()
5245  				.account (nano::dev::genesis->account ())
5246  				.previous (node1->latest (nano::dev::genesis_key.pub))
5247  				.representative (nano::dev::genesis->account ())
5248  				.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
5249  				.link (key.pub)
5250  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
5251  				.work (0)
5252  				.build ();
5253  	auto const rpc_ctx = add_rpc (system, node1);
5254  	boost::property_tree::ptree request;
5255  	request.put ("action", "sign");
5256  	request.put ("hash", send->hash ().to_string ());
5257  	request.put ("key", key.prv.to_string ());
5258  	auto response (wait_response (system, rpc_ctx, request, 10s));
5259  	std::error_code ec (nano::error_rpc::sign_hash_disabled);
5260  	ASSERT_EQ (response.get<std::string> ("error"), ec.message ());
5261  	rpc_ctx.node_rpc_config->enable_sign_hash = true;
5262  	auto response2 (wait_response (system, rpc_ctx, request, 10s));
5263  	nano::signature signature;
5264  	std::string signature_text (response2.get<std::string> ("signature"));
5265  	ASSERT_FALSE (signature.decode_hex (signature_text));
5266  	ASSERT_FALSE (nano::validate_message (key.pub, send->hash (), signature));
5267  }
5268  TEST (rpc, sign_block)
5269  {
5270  	nano::test::system system;
5271  	auto node1 = add_ipc_enabled_node (system);
5272  	nano::keypair key;
5273  	system.wallet (0)->insert_adhoc (key.prv);
5274  	nano::block_builder builder;
5275  	auto send = builder
5276  				.state ()
5277  				.account (nano::dev::genesis->account ())
5278  				.previous (node1->latest (nano::dev::genesis_key.pub))
5279  				.representative (nano::dev::genesis->account ())
5280  				.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
5281  				.link (key.pub)
5282  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
5283  				.work (0)
5284  				.build ();
5285  	auto const rpc_ctx = add_rpc (system, node1);
5286  	boost::property_tree::ptree request;
5287  	request.put ("action", "sign");
5288  	std::string wallet;
5289  	node1->wallets.items.begin ()->first.encode_hex (wallet);
5290  	request.put ("wallet", wallet);
5291  	request.put ("account", key.pub.to_account ());
5292  	std::string json;
5293  	send->serialize_json (json);
5294  	request.put ("block", json);
5295  	auto response (wait_response (system, rpc_ctx, request, 10s));
5296  	auto contents (response.get<std::string> ("block"));
5297  	boost::property_tree::ptree block_l;
5298  	std::stringstream block_stream (contents);
5299  	boost::property_tree::read_json (block_stream, block_l);
5300  	auto block (nano::deserialize_block_json (block_l));
5301  	ASSERT_FALSE (nano::validate_message (key.pub, send->hash (), block->block_signature ()));
5302  	ASSERT_NE (block->block_signature (), send->block_signature ());
5303  	ASSERT_EQ (block->hash (), send->hash ());
5304  }
5305  TEST (rpc, memory_stats)
5306  {
5307  	nano::test::system system;
5308  	auto node = add_ipc_enabled_node (system);
5309  	auto const rpc_ctx = add_rpc (system, node);
5310  	nano::keypair key;
5311  	nano::block_builder builder;
5312  	auto block = builder
5313  				 .state ()
5314  				 .account (0)
5315  				 .previous (0)
5316  				 .representative (0)
5317  				 .balance (0)
5318  				 .link (0)
5319  				 .sign (key.prv, key.pub)
5320  				 .work (0)
5321  				 .build_shared ();
5322  	std::vector<nano::block_hash> hashes;
5323  	hashes.push_back (block->hash ());
5324  	auto vote (std::make_shared<nano::vote> (key.pub, key.prv, 0, 0, hashes));
5325  	node->vote_uniquer.unique (vote);
5326  	boost::property_tree::ptree request;
5327  	request.put ("action", "stats");
5328  	request.put ("type", "objects");
5329  	{
5330  		auto response (wait_response (system, rpc_ctx, request));
5331  		ASSERT_EQ (response.get_child ("node").get_child ("vote_uniquer").get_child ("votes").get<std::string> ("count"), "1");
5332  	}
5333  	request.put ("type", "database");
5334  	{
5335  		auto response (wait_response (system, rpc_ctx, request));
5336  		ASSERT_TRUE (!response.empty ());
5337  	}
5338  }
5339  TEST (rpc, block_confirmed)
5340  {
5341  	nano::test::system system;
5342  	auto node = add_ipc_enabled_node (system);
5343  	auto const rpc_ctx = add_rpc (system, node);
5344  	boost::property_tree::ptree request;
5345  	request.put ("action", "block_info");
5346  	request.put ("hash", "bad_hash1337");
5347  	auto response (wait_response (system, rpc_ctx, request));
5348  	ASSERT_EQ (std::error_code (nano::error_blocks::invalid_block_hash).message (), response.get<std::string> ("error"));
5349  	request.put ("hash", "0");
5350  	auto response1 (wait_response (system, rpc_ctx, request));
5351  	ASSERT_EQ (std::error_code (nano::error_blocks::not_found).message (), response1.get<std::string> ("error"));
5352  	nano::keypair key;
5353  	nano::block_builder builder;
5354  	{
5355  		auto transaction = node->store.tx_begin_write ();
5356  		nano::block_hash latest (node->latest (nano::dev::genesis_key.pub));
5357  		auto send1 = builder
5358  					 .send ()
5359  					 .previous (latest)
5360  					 .destination (key.pub)
5361  					 .balance (300)
5362  					 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
5363  					 .work (*system.work.generate (latest))
5364  					 .build ();
5365  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *send1).code);
5366  		auto open1 = builder
5367  					 .open ()
5368  					 .source (send1->hash ())
5369  					 .representative (nano::dev::genesis->account ())
5370  					 .account (key.pub)
5371  					 .sign (key.prv, key.pub)
5372  					 .work (*system.work.generate (key.pub))
5373  					 .build ();
5374  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *open1).code);
5375  	}
5376  	nano::block_hash latest (node->latest (nano::dev::genesis_key.pub));
5377  	request.put ("hash", latest.to_string ());
5378  	auto response2 (wait_response (system, rpc_ctx, request));
5379  	ASSERT_FALSE (response2.get<bool> ("confirmed"));
5380  	auto send = builder
5381  				.send ()
5382  				.previous (latest)
5383  				.destination (key.pub)
5384  				.balance (10)
5385  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
5386  				.work (*system.work.generate (latest))
5387  				.build_shared ();
5388  	node->process_active (send);
5389  	ASSERT_TIMELY (5s, nano::test::confirm (*node, { send }));
5390  	ASSERT_TIMELY (5s, node->ledger.block_confirmed (node->store.tx_begin_read (), send->hash ()) && !node->confirmation_height_processor.is_processing_block (send->hash ()));
5391  	request.put ("hash", send->hash ().to_string ());
5392  	auto response3 (wait_response (system, rpc_ctx, request));
5393  	ASSERT_TRUE (response3.get<bool> ("confirmed"));
5394  }
5395  TEST (rpc, database_txn_tracker)
5396  {
5397  	if (nano::rocksdb_config::using_rocksdb_in_tests ())
5398  	{
5399  		return;
5400  	}
5401  	{
5402  		nano::test::system system;
5403  		auto node = add_ipc_enabled_node (system);
5404  		auto const rpc_ctx = add_rpc (system, node);
5405  		boost::property_tree::ptree request;
5406  		request.put ("action", "database_txn_tracker");
5407  		{
5408  			auto response (wait_response (system, rpc_ctx, request));
5409  			std::error_code ec (nano::error_common::tracking_not_enabled);
5410  			ASSERT_EQ (response.get<std::string> ("error"), ec.message ());
5411  		}
5412  	}
5413  	nano::test::system system;
5414  	nano::node_config node_config = system.default_config ();
5415  	node_config.diagnostics_config.txn_tracking.enable = true;
5416  	auto node = add_ipc_enabled_node (system, node_config);
5417  	auto const rpc_ctx = add_rpc (system, node);
5418  	boost::property_tree::ptree request;
5419  	auto check_not_correct_amount = [&system, &rpc_ctx, &request] () {
5420  		auto response (wait_response (system, rpc_ctx, request));
5421  		std::error_code ec (nano::error_common::invalid_amount);
5422  		ASSERT_EQ (response.get<std::string> ("error"), ec.message ());
5423  	};
5424  	request.put ("action", "database_txn_tracker");
5425  	request.put ("min_read_time", "not a time");
5426  	check_not_correct_amount ();
5427  	request.put ("min_read_time", "1000");
5428  	request.put ("min_write_time", "bad time");
5429  	check_not_correct_amount ();
5430  	request.put ("min_read_time", "1000000");
5431  	request.put ("min_write_time", "1000000");
5432  	std::promise<void> keep_txn_alive_promise;
5433  	std::promise<void> txn_created_promise;
5434  	std::thread thread ([&store = node->store, &keep_txn_alive_promise, &txn_created_promise] () {
5435  		nano::thread_role::set (nano::thread_role::name::rpc_process_container);
5436  		auto read_tx = store.tx_begin_read ();
5437  		std::this_thread::sleep_for (1s);
5438  		txn_created_promise.set_value ();
5439  		keep_txn_alive_promise.get_future ().wait ();
5440  	});
5441  	txn_created_promise.get_future ().wait ();
5442  	request.put ("min_read_time", "1000");
5443  	auto response (wait_response (system, rpc_ctx, request, 60s));
5444  	keep_txn_alive_promise.set_value ();
5445  	std::vector<std::tuple<std::string, std::string, std::string, std::vector<std::tuple<std::string, std::string, std::string, std::string>>>> json_l;
5446  	auto & json_node (response.get_child ("txn_tracking"));
5447  	for (auto & stat : json_node)
5448  	{
5449  		auto & stack_trace = stat.second.get_child ("stacktrace");
5450  		std::vector<std::tuple<std::string, std::string, std::string, std::string>> frames_json_l;
5451  		for (auto & frame : stack_trace)
5452  		{
5453  			frames_json_l.emplace_back (frame.second.get<std::string> ("name"), frame.second.get<std::string> ("address"), frame.second.get<std::string> ("source_file"), frame.second.get<std::string> ("source_line"));
5454  		}
5455  		json_l.emplace_back (stat.second.get<std::string> ("thread"), stat.second.get<std::string> ("time_held_open"), stat.second.get<std::string> ("write"), std::move (frames_json_l));
5456  	}
5457  	ASSERT_EQ (1, json_l.size ());
5458  	auto thread_name = nano::thread_role::get_string (nano::thread_role::name::rpc_process_container);
5459  	ASSERT_EQ (thread_name, std::get<0> (json_l.front ()));
5460  	ASSERT_LE (1000u, boost::lexical_cast<unsigned> (std::get<1> (json_l.front ())));
5461  	ASSERT_EQ ("false", std::get<2> (json_l.front ()));
5462  	ASSERT_TRUE (!std::get<3> (json_l.front ()).empty ());
5463  	thread.join ();
5464  }
5465  TEST (rpc, active_difficulty)
5466  {
5467  	nano::test::system system;
5468  	auto node = add_ipc_enabled_node (system);
5469  	auto const rpc_ctx = add_rpc (system, node);
5470  	ASSERT_EQ (node->default_difficulty (nano::work_version::work_1), node->network_params.work.epoch_2);
5471  	boost::property_tree::ptree request;
5472  	request.put ("action", "active_difficulty");
5473  	auto expected_multiplier{ 1.0 };
5474  	{
5475  		auto response (wait_response (system, rpc_ctx, request));
5476  		auto network_minimum_text (response.get<std::string> ("network_minimum"));
5477  		uint64_t network_minimum;
5478  		ASSERT_FALSE (nano::from_string_hex (network_minimum_text, network_minimum));
5479  		ASSERT_EQ (node->default_difficulty (nano::work_version::work_1), network_minimum);
5480  		auto network_receive_minimum_text (response.get<std::string> ("network_receive_minimum"));
5481  		uint64_t network_receive_minimum;
5482  		ASSERT_FALSE (nano::from_string_hex (network_receive_minimum_text, network_receive_minimum));
5483  		ASSERT_EQ (node->default_receive_difficulty (nano::work_version::work_1), network_receive_minimum);
5484  		auto multiplier (response.get<double> ("multiplier"));
5485  		ASSERT_NEAR (expected_multiplier, multiplier, 1e-6);
5486  		auto network_current_text (response.get<std::string> ("network_current"));
5487  		uint64_t network_current;
5488  		ASSERT_FALSE (nano::from_string_hex (network_current_text, network_current));
5489  		ASSERT_EQ (nano::difficulty::from_multiplier (expected_multiplier, node->default_difficulty (nano::work_version::work_1)), network_current);
5490  		auto network_receive_current_text (response.get<std::string> ("network_receive_current"));
5491  		uint64_t network_receive_current;
5492  		ASSERT_FALSE (nano::from_string_hex (network_receive_current_text, network_receive_current));
5493  		auto network_receive_current_multiplier (nano::difficulty::to_multiplier (network_receive_current, network_receive_minimum));
5494  		auto network_receive_current_normalized_multiplier (nano::dev::network_params.work.normalized_multiplier (network_receive_current_multiplier, network_receive_minimum));
5495  		ASSERT_NEAR (network_receive_current_normalized_multiplier, multiplier, 1e-6);
5496  		ASSERT_EQ (response.not_found (), response.find ("difficulty_trend"));
5497  	}
5498  	request.put ("include_trend", true);
5499  	{
5500  		auto response (wait_response (system, rpc_ctx, request));
5501  		auto trend_opt (response.get_child_optional ("difficulty_trend"));
5502  		ASSERT_TRUE (trend_opt.is_initialized ());
5503  		auto & trend (trend_opt.get ());
5504  		ASSERT_EQ (1, trend.size ());
5505  	}
5506  }
5507  TEST (rpc, simultaneous_calls)
5508  {
5509  	nano::test::system system;
5510  	auto node = add_ipc_enabled_node (system);
5511  	nano::thread_runner runner (system.io_ctx, node->config.io_threads);
5512  	nano::node_rpc_config node_rpc_config;
5513  	nano::ipc::ipc_server ipc_server (*node, node_rpc_config);
5514  	nano::rpc_config rpc_config{ nano::dev::network_params.network, system.get_available_port (), true };
5515  	const auto ipc_tcp_port = ipc_server.listening_tcp_port ();
5516  	ASSERT_TRUE (ipc_tcp_port.has_value ());
5517  	rpc_config.rpc_process.num_ipc_connections = 8;
5518  	nano::ipc_rpc_processor ipc_rpc_processor (system.io_ctx, rpc_config, ipc_tcp_port.value ());
5519  	nano::rpc rpc (system.io_ctx, rpc_config, ipc_rpc_processor);
5520  	rpc.start ();
5521  	boost::property_tree::ptree request;
5522  	request.put ("action", "account_block_count");
5523  	request.put ("account", nano::dev::genesis_key.pub.to_account ());
5524  	constexpr auto num = 100;
5525  	std::array<std::unique_ptr<test_response>, num> test_responses;
5526  	for (int i = 0; i < num; ++i)
5527  	{
5528  		test_responses[i] = std::make_unique<test_response> (request, system.io_ctx);
5529  	}
5530  	std::promise<void> promise;
5531  	std::atomic<int> count{ num };
5532  	for (int i = 0; i < num; ++i)
5533  	{
5534  		std::thread ([&test_responses, &promise, &count, i, port = rpc.listening_port ()] () {
5535  			test_responses[i]->run (port);
5536  			if (--count == 0)
5537  			{
5538  				promise.set_value ();
5539  			}
5540  		})
5541  		.detach ();
5542  	}
5543  	promise.get_future ().wait ();
5544  	ASSERT_TIMELY (60s, std::all_of (test_responses.begin (), test_responses.end (), [] (auto const & test_response) { return test_response->status != 0; }));
5545  	for (int i = 0; i < num; ++i)
5546  	{
5547  		ASSERT_EQ (200, test_responses[i]->status);
5548  		std::string block_count_text (test_responses[i]->json.get<std::string> ("block_count"));
5549  		ASSERT_EQ ("1", block_count_text);
5550  	}
5551  	rpc.stop ();
5552  	system.stop ();
5553  	ipc_server.stop ();
5554  	system.io_ctx.stop ();
5555  	runner.join ();
5556  }
5557  TEST (rpc, in_process)
5558  {
5559  	nano::test::system system;
5560  	auto node = add_ipc_enabled_node (system);
5561  	auto const rpc_ctx = add_rpc (system, node);
5562  	boost::property_tree::ptree request;
5563  	request.put ("action", "account_balance");
5564  	request.put ("account", nano::dev::genesis_key.pub.to_account ());
5565  	auto response (wait_response (system, rpc_ctx, request));
5566  	std::string balance_text (response.get<std::string> ("balance"));
5567  	ASSERT_EQ ("340282366920938463463374607431768211455", balance_text);
5568  	std::string pending_text (response.get<std::string> ("pending"));
5569  	ASSERT_EQ ("0", pending_text);
5570  }
5571  TEST (rpc, deprecated_account_format)
5572  {
5573  	nano::test::system system;
5574  	auto node = add_ipc_enabled_node (system);
5575  	auto const rpc_ctx = add_rpc (system, node);
5576  	boost::property_tree::ptree request;
5577  	request.put ("action", "account_info");
5578  	request.put ("account", nano::dev::genesis_key.pub.to_account ());
5579  	auto response (wait_response (system, rpc_ctx, request));
5580  	boost::optional<std::string> deprecated_account_format (response.get_optional<std::string> ("deprecated_account_format"));
5581  	ASSERT_FALSE (deprecated_account_format.is_initialized ());
5582  	std::string account_text (nano::dev::genesis_key.pub.to_account ());
5583  	account_text[4] = '-';
5584  	request.put ("account", account_text);
5585  	auto response2 (wait_response (system, rpc_ctx, request));
5586  	std::string frontier (response2.get<std::string> ("frontier"));
5587  	ASSERT_EQ (nano::dev::genesis->hash ().to_string (), frontier);
5588  	boost::optional<std::string> deprecated_account_format2 (response2.get_optional<std::string> ("deprecated_account_format"));
5589  	ASSERT_TRUE (deprecated_account_format2.is_initialized ());
5590  }
5591  TEST (rpc, epoch_upgrade)
5592  {
5593  	nano::test::system system;
5594  	auto node = add_ipc_enabled_node (system);
5595  	nano::keypair key1, key2, key3;
5596  	nano::keypair epoch_signer (nano::dev::genesis_key);
5597  	nano::block_builder builder;
5598  	auto send1 = builder
5599  				 .state ()
5600  				 .account (nano::dev::genesis_key.pub)
5601  				 .previous (nano::dev::genesis->hash ())
5602  				 .representative (nano::dev::genesis_key.pub)
5603  				 .balance (nano::dev::constants.genesis_amount - 1)
5604  				 .link (key1.pub)
5605  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
5606  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
5607  				 .build_shared (); 
5608  	ASSERT_EQ (nano::process_result::progress, node->process (*send1).code);
5609  	auto send2 = builder
5610  				 .state ()
5611  				 .account (nano::dev::genesis_key.pub)
5612  				 .previous (send1->hash ())
5613  				 .representative (nano::dev::genesis_key.pub)
5614  				 .balance (nano::dev::constants.genesis_amount - 2)
5615  				 .link (key2.pub)
5616  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
5617  				 .work (*system.work.generate (send1->hash ()))
5618  				 .build_shared (); 
5619  	ASSERT_EQ (nano::process_result::progress, node->process (*send2).code);
5620  	auto send3 = builder
5621  				 .state ()
5622  				 .account (nano::dev::genesis_key.pub)
5623  				 .previous (send2->hash ())
5624  				 .representative (nano::dev::genesis_key.pub)
5625  				 .balance (nano::dev::constants.genesis_amount - 3)
5626  				 .link (0)
5627  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
5628  				 .work (*system.work.generate (send2->hash ()))
5629  				 .build_shared (); 
5630  	ASSERT_EQ (nano::process_result::progress, node->process (*send3).code);
5631  	nano::account max_account (std::numeric_limits<nano::uint256_t>::max ());
5632  	auto send4 = builder
5633  				 .state ()
5634  				 .account (nano::dev::genesis_key.pub)
5635  				 .previous (send3->hash ())
5636  				 .representative (nano::dev::genesis_key.pub)
5637  				 .balance (nano::dev::constants.genesis_amount - 4)
5638  				 .link (max_account)
5639  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
5640  				 .work (*system.work.generate (send3->hash ()))
5641  				 .build_shared (); 
5642  	ASSERT_EQ (nano::process_result::progress, node->process (*send4).code);
5643  	auto open = builder
5644  				.state ()
5645  				.account (key1.pub)
5646  				.previous (0)
5647  				.representative (key1.pub)
5648  				.balance (1)
5649  				.link (send1->hash ())
5650  				.sign (key1.prv, key1.pub)
5651  				.work (*system.work.generate (key1.pub))
5652  				.build_shared ();
5653  	ASSERT_EQ (nano::process_result::progress, node->process (*open).code);
5654  	{
5655  		auto transaction (node->store.tx_begin_read ());
5656  		ASSERT_EQ (2, node->store.account.count (transaction));
5657  		for (auto i (node->store.account.begin (transaction)); i != node->store.account.end (); ++i)
5658  		{
5659  			nano::account_info info (i->second);
5660  			ASSERT_EQ (info.epoch (), nano::epoch::epoch_0);
5661  		}
5662  	}
5663  	auto const rpc_ctx = add_rpc (system, node);
5664  	boost::property_tree::ptree request;
5665  	request.put ("action", "epoch_upgrade");
5666  	request.put ("epoch", 1);
5667  	request.put ("key", epoch_signer.prv.to_string ());
5668  	auto response (wait_response (system, rpc_ctx, request));
5669  	ASSERT_EQ ("1", response.get<std::string> ("started"));
5670  	ASSERT_TIMELY (10s, 4 == node->store.account.count (node->store.tx_begin_read ()));
5671  	{
5672  		auto transaction (node->store.tx_begin_read ());
5673  		ASSERT_EQ (4, node->store.account.count (transaction));
5674  		for (auto i (node->store.account.begin (transaction)); i != node->store.account.end (); ++i)
5675  		{
5676  			nano::account_info info (i->second);
5677  			ASSERT_EQ (info.epoch (), nano::epoch::epoch_1);
5678  		}
5679  		ASSERT_TRUE (node->store.account.exists (transaction, key1.pub));
5680  		ASSERT_TRUE (node->store.account.exists (transaction, key2.pub));
5681  		ASSERT_TRUE (node->store.account.exists (transaction, std::numeric_limits<nano::uint256_t>::max ()));
5682  		ASSERT_FALSE (node->store.account.exists (transaction, 0));
5683  	}
5684  	auto genesis_latest (node->latest (nano::dev::genesis_key.pub));
5685  	auto send5 = builder
5686  				 .state ()
5687  				 .account (nano::dev::genesis_key.pub)
5688  				 .previous (genesis_latest)
5689  				 .representative (nano::dev::genesis_key.pub)
5690  				 .balance (nano::dev::constants.genesis_amount - 5)
5691  				 .link (0)
5692  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
5693  				 .work (*system.work.generate (genesis_latest))
5694  				 .build_shared (); 
5695  	ASSERT_EQ (nano::process_result::progress, node->process (*send5).code);
5696  	auto send6 = builder
5697  				 .state ()
5698  				 .account (nano::dev::genesis_key.pub)
5699  				 .previous (send5->hash ())
5700  				 .representative (nano::dev::genesis_key.pub)
5701  				 .balance (nano::dev::constants.genesis_amount - 6)
5702  				 .link (key1.pub)
5703  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
5704  				 .work (*system.work.generate (send5->hash ()))
5705  				 .build_shared (); 
5706  	ASSERT_EQ (nano::process_result::progress, node->process (*send6).code);
5707  	auto key1_latest (node->latest (key1.pub));
5708  	auto send7 = builder
5709  				 .state ()
5710  				 .account (key1.pub)
5711  				 .previous (key1_latest)
5712  				 .representative (key1.pub)
5713  				 .balance (0)
5714  				 .link (key3.pub)
5715  				 .sign (key1.prv, key1.pub)
5716  				 .work (*system.work.generate (key1_latest))
5717  				 .build_shared (); 
5718  	ASSERT_EQ (nano::process_result::progress, node->process (*send7).code);
5719  	{
5720  		auto transaction (node->store.tx_begin_read ());
5721  		auto info = node->ledger.pending_info (transaction, nano::pending_key (key3.pub, send7->hash ()));
5722  		ASSERT_TRUE (info);
5723  		ASSERT_EQ (nano::epoch::epoch_1, info->epoch);
5724  	}
5725  	request.put ("epoch", 2);
5726  	auto response2 (wait_response (system, rpc_ctx, request));
5727  	ASSERT_EQ ("1", response2.get<std::string> ("started"));
5728  	ASSERT_TIMELY (10s, 5 == node->store.account.count (node->store.tx_begin_read ()));
5729  	{
5730  		auto transaction (node->store.tx_begin_read ());
5731  		ASSERT_EQ (5, node->store.account.count (transaction));
5732  		for (auto i (node->store.account.begin (transaction)); i != node->store.account.end (); ++i)
5733  		{
5734  			nano::account_info info (i->second);
5735  			ASSERT_EQ (info.epoch (), nano::epoch::epoch_2);
5736  		}
5737  		ASSERT_TRUE (node->store.account.exists (transaction, key1.pub));
5738  		ASSERT_TRUE (node->store.account.exists (transaction, key2.pub));
5739  		ASSERT_TRUE (node->store.account.exists (transaction, key3.pub));
5740  		ASSERT_TRUE (node->store.account.exists (transaction, std::numeric_limits<nano::uint256_t>::max ()));
5741  		ASSERT_FALSE (node->store.account.exists (transaction, 0));
5742  	}
5743  }
5744  TEST (rpc, epoch_upgrade_multithreaded)
5745  {
5746  	nano::test::system system;
5747  	nano::node_config node_config = system.default_config ();
5748  	node_config.work_threads = 4;
5749  	auto node = add_ipc_enabled_node (system, node_config);
5750  	nano::keypair key1, key2, key3;
5751  	nano::keypair epoch_signer (nano::dev::genesis_key);
5752  	nano::block_builder builder;
5753  	auto send1 = builder
5754  				 .state ()
5755  				 .account (nano::dev::genesis_key.pub)
5756  				 .previous (nano::dev::genesis->hash ())
5757  				 .representative (nano::dev::genesis_key.pub)
5758  				 .balance (nano::dev::constants.genesis_amount - 1)
5759  				 .link (key1.pub)
5760  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
5761  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
5762  				 .build_shared (); 
5763  	ASSERT_EQ (nano::process_result::progress, node->process (*send1).code);
5764  	auto send2 = builder
5765  				 .state ()
5766  				 .account (nano::dev::genesis_key.pub)
5767  				 .previous (send1->hash ())
5768  				 .representative (nano::dev::genesis_key.pub)
5769  				 .balance (nano::dev::constants.genesis_amount - 2)
5770  				 .link (key2.pub)
5771  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
5772  				 .work (*system.work.generate (send1->hash ()))
5773  				 .build_shared (); 
5774  	ASSERT_EQ (nano::process_result::progress, node->process (*send2).code);
5775  	auto send3 = builder
5776  				 .state ()
5777  				 .account (nano::dev::genesis_key.pub)
5778  				 .previous (send2->hash ())
5779  				 .representative (nano::dev::genesis_key.pub)
5780  				 .balance (nano::dev::constants.genesis_amount - 3)
5781  				 .link (0)
5782  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
5783  				 .work (*system.work.generate (send2->hash ()))
5784  				 .build_shared (); 
5785  	ASSERT_EQ (nano::process_result::progress, node->process (*send3).code);
5786  	nano::account max_account (std::numeric_limits<nano::uint256_t>::max ());
5787  	auto send4 = builder
5788  				 .state ()
5789  				 .account (nano::dev::genesis_key.pub)
5790  				 .previous (send3->hash ())
5791  				 .representative (nano::dev::genesis_key.pub)
5792  				 .balance (nano::dev::constants.genesis_amount - 4)
5793  				 .link (max_account)
5794  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
5795  				 .work (*system.work.generate (send3->hash ()))
5796  				 .build_shared (); 
5797  	ASSERT_EQ (nano::process_result::progress, node->process (*send4).code);
5798  	auto open = builder
5799  				.state ()
5800  				.account (key1.pub)
5801  				.previous (0)
5802  				.representative (key1.pub)
5803  				.balance (1)
5804  				.link (send1->hash ())
5805  				.sign (key1.prv, key1.pub)
5806  				.work (*system.work.generate (key1.pub))
5807  				.build_shared ();
5808  	ASSERT_EQ (nano::process_result::progress, node->process (*open).code);
5809  	{
5810  		auto transaction (node->store.tx_begin_read ());
5811  		ASSERT_EQ (2, node->store.account.count (transaction));
5812  		for (auto i (node->store.account.begin (transaction)); i != node->store.account.end (); ++i)
5813  		{
5814  			nano::account_info info (i->second);
5815  			ASSERT_EQ (info.epoch (), nano::epoch::epoch_0);
5816  		}
5817  	}
5818  	auto const rpc_ctx = add_rpc (system, node);
5819  	boost::property_tree::ptree request;
5820  	request.put ("action", "epoch_upgrade");
5821  	request.put ("threads", 2);
5822  	request.put ("epoch", 1);
5823  	request.put ("key", epoch_signer.prv.to_string ());
5824  	auto response (wait_response (system, rpc_ctx, request));
5825  	ASSERT_EQ ("1", response.get<std::string> ("started"));
5826  	ASSERT_TIMELY (5s, 4 == node->store.account.count (node->store.tx_begin_read ()));
5827  	{
5828  		auto transaction (node->store.tx_begin_read ());
5829  		ASSERT_EQ (4, node->store.account.count (transaction));
5830  		for (auto i (node->store.account.begin (transaction)); i != node->store.account.end (); ++i)
5831  		{
5832  			nano::account_info info (i->second);
5833  			ASSERT_EQ (info.epoch (), nano::epoch::epoch_1);
5834  		}
5835  		ASSERT_TRUE (node->store.account.exists (transaction, key1.pub));
5836  		ASSERT_TRUE (node->store.account.exists (transaction, key2.pub));
5837  		ASSERT_TRUE (node->store.account.exists (transaction, std::numeric_limits<nano::uint256_t>::max ()));
5838  		ASSERT_FALSE (node->store.account.exists (transaction, 0));
5839  	}
5840  	auto genesis_latest (node->latest (nano::dev::genesis_key.pub));
5841  	auto send5 = builder
5842  				 .state ()
5843  				 .account (nano::dev::genesis_key.pub)
5844  				 .previous (genesis_latest)
5845  				 .representative (nano::dev::genesis_key.pub)
5846  				 .balance (nano::dev::constants.genesis_amount - 5)
5847  				 .link (0)
5848  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
5849  				 .work (*system.work.generate (genesis_latest))
5850  				 .build_shared (); 
5851  	ASSERT_EQ (nano::process_result::progress, node->process (*send5).code);
5852  	auto send6 = builder
5853  				 .state ()
5854  				 .account (nano::dev::genesis_key.pub)
5855  				 .previous (send5->hash ())
5856  				 .representative (nano::dev::genesis_key.pub)
5857  				 .balance (nano::dev::constants.genesis_amount - 6)
5858  				 .link (key1.pub)
5859  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
5860  				 .work (*system.work.generate (send5->hash ()))
5861  				 .build_shared (); 
5862  	ASSERT_EQ (nano::process_result::progress, node->process (*send6).code);
5863  	auto key1_latest (node->latest (key1.pub));
5864  	auto send7 = builder
5865  				 .state ()
5866  				 .account (key1.pub)
5867  				 .previous (key1_latest)
5868  				 .representative (key1.pub)
5869  				 .balance (0)
5870  				 .link (key3.pub)
5871  				 .sign (key1.prv, key1.pub)
5872  				 .work (*system.work.generate (key1_latest))
5873  				 .build_shared (); 
5874  	ASSERT_EQ (nano::process_result::progress, node->process (*send7).code);
5875  	{
5876  		auto transaction (node->store.tx_begin_read ());
5877  		auto info = node->ledger.pending_info (transaction, nano::pending_key (key3.pub, send7->hash ()));
5878  		ASSERT_TRUE (info);
5879  		ASSERT_EQ (nano::epoch::epoch_1, info->epoch);
5880  	}
5881  	request.put ("epoch", 2);
5882  	auto response2 (wait_response (system, rpc_ctx, request));
5883  	ASSERT_EQ ("1", response2.get<std::string> ("started"));
5884  	ASSERT_TIMELY (5s, 5 == node->store.account.count (node->store.tx_begin_read ()));
5885  	{
5886  		auto transaction (node->store.tx_begin_read ());
5887  		ASSERT_EQ (5, node->store.account.count (transaction));
5888  		for (auto i (node->store.account.begin (transaction)); i != node->store.account.end (); ++i)
5889  		{
5890  			nano::account_info info (i->second);
5891  			ASSERT_EQ (info.epoch (), nano::epoch::epoch_2);
5892  		}
5893  		ASSERT_TRUE (node->store.account.exists (transaction, key1.pub));
5894  		ASSERT_TRUE (node->store.account.exists (transaction, key2.pub));
5895  		ASSERT_TRUE (node->store.account.exists (transaction, key3.pub));
5896  		ASSERT_TRUE (node->store.account.exists (transaction, std::numeric_limits<nano::uint256_t>::max ()));
5897  		ASSERT_FALSE (node->store.account.exists (transaction, 0));
5898  	}
5899  }
5900  TEST (rpc, account_lazy_start)
5901  {
5902  	nano::test::system system{};
5903  	nano::node_flags node_flags{};
5904  	node_flags.disable_legacy_bootstrap = true;
5905  	auto node1 = system.add_node (node_flags);
5906  	nano::keypair key{};
5907  	nano::block_builder builder;
5908  	auto send1 = builder
5909  				 .state ()
5910  				 .account (nano::dev::genesis_key.pub)
5911  				 .previous (nano::dev::genesis->hash ())
5912  				 .representative (nano::dev::genesis_key.pub)
5913  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
5914  				 .link (key.pub)
5915  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
5916  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
5917  				 .build_shared ();
5918  	ASSERT_EQ (nano::process_result::progress, node1->process (*send1).code);
5919  	auto open = builder
5920  				.open ()
5921  				.source (send1->hash ())
5922  				.representative (key.pub)
5923  				.account (key.pub)
5924  				.sign (key.prv, key.pub)
5925  				.work (*system.work.generate (key.pub))
5926  				.build_shared ();
5927  	ASSERT_EQ (nano::process_result::progress, node1->process (*open).code);
5928  	nano::node_config node_config = system.default_config ();
5929  	node_config.ipc_config.transport_tcp.enabled = true;
5930  	node_config.ipc_config.transport_tcp.port = system.get_available_port ();
5931  	auto node2 = system.add_node (node_config, node_flags);
5932  	nano::test::establish_tcp (system, *node2, node1->network.endpoint ());
5933  	auto const rpc_ctx = add_rpc (system, node2);
5934  	boost::property_tree::ptree request;
5935  	request.put ("action", "account_info");
5936  	request.put ("account", key.pub.to_account ());
5937  	auto response = wait_response (system, rpc_ctx, request);
5938  	boost::optional<std::string> account_error{ response.get_optional<std::string> ("error") };
5939  	ASSERT_TRUE (account_error.is_initialized ());
5940  	ASSERT_TIMELY (10s, !node2->bootstrap_initiator.in_progress ());
5941  	ASSERT_TIMELY (10s, node2->ledger.block_or_pruned_exists (send1->hash ()));
5942  	ASSERT_TIMELY (10s, node2->ledger.block_or_pruned_exists (open->hash ()));
5943  }
5944  TEST (rpc, receive)
5945  {
5946  	nano::test::system system;
5947  	auto node = add_ipc_enabled_node (system);
5948  	auto wallet = system.wallet (0);
5949  	std::string wallet_text;
5950  	node->wallets.items.begin ()->first.encode_hex (wallet_text);
5951  	wallet->insert_adhoc (nano::dev::genesis_key.prv);
5952  	nano::keypair key1;
5953  	wallet->insert_adhoc (key1.prv);
5954  	auto send1 (wallet->send_action (nano::dev::genesis_key.pub, key1.pub, node->config.receive_minimum.number (), *node->work_generate_blocking (nano::dev::genesis->hash ())));
5955  	ASSERT_TIMELY (5s, node->balance (nano::dev::genesis_key.pub) != nano::dev::constants.genesis_amount);
5956  	ASSERT_TIMELY (10s, !node->store.account.exists (node->store.tx_begin_read (), key1.pub));
5957  	auto send2 (wallet->send_action (nano::dev::genesis_key.pub, key1.pub, node->config.receive_minimum.number () - 1, *node->work_generate_blocking (send1->hash ())));
5958  	auto const rpc_ctx = add_rpc (system, node);
5959  	boost::property_tree::ptree request;
5960  	request.put ("action", "receive");
5961  	request.put ("wallet", wallet_text);
5962  	request.put ("account", key1.pub.to_account ());
5963  	request.put ("block", send2->hash ().to_string ());
5964  	{
5965  		auto response (wait_response (system, rpc_ctx, request));
5966  		auto receive_text (response.get<std::string> ("block"));
5967  		auto info = node->ledger.account_info (node->store.tx_begin_read (), key1.pub);
5968  		ASSERT_TRUE (info);
5969  		ASSERT_EQ (info->head, nano::block_hash{ receive_text });
5970  	}
5971  	{
5972  		auto response (wait_response (system, rpc_ctx, request));
5973  		ASSERT_EQ (std::error_code (nano::error_process::unreceivable).message (), response.get<std::string> ("error"));
5974  	}
5975  	request.put ("block", nano::block_hash (send2->hash ().number () + 1).to_string ());
5976  	{
5977  		auto response (wait_response (system, rpc_ctx, request));
5978  		ASSERT_EQ (std::error_code (nano::error_blocks::not_found).message (), response.get<std::string> ("error"));
5979  	}
5980  }
5981  TEST (rpc, receive_unopened)
5982  {
5983  	nano::test::system system;
5984  	auto node = add_ipc_enabled_node (system);
5985  	auto wallet = system.wallet (0);
5986  	std::string wallet_text;
5987  	node->wallets.items.begin ()->first.encode_hex (wallet_text);
5988  	wallet->insert_adhoc (nano::dev::genesis_key.prv);
5989  	nano::keypair key1;
5990  	auto send1 (wallet->send_action (nano::dev::genesis_key.pub, key1.pub, node->config.receive_minimum.number () - 1, *node->work_generate_blocking (nano::dev::genesis->hash ())));
5991  	ASSERT_TIMELY (5s, !node->balance (nano::dev::genesis_key.pub) != nano::dev::constants.genesis_amount);
5992  	ASSERT_FALSE (node->store.account.exists (node->store.tx_begin_read (), key1.pub));
5993  	ASSERT_TRUE (node->store.block.exists (node->store.tx_begin_read (), send1->hash ()));
5994  	wallet->insert_adhoc (key1.prv); 
5995  	auto const rpc_ctx = add_rpc (system, node);
5996  	boost::property_tree::ptree request;
5997  	request.put ("action", "receive");
5998  	request.put ("wallet", wallet_text);
5999  	request.put ("account", key1.pub.to_account ());
6000  	request.put ("block", send1->hash ().to_string ());
6001  	{
6002  		auto response (wait_response (system, rpc_ctx, request));
6003  		auto receive_text (response.get<std::string> ("block"));
6004  		auto info = node->ledger.account_info (node->store.tx_begin_read (), key1.pub);
6005  		ASSERT_TRUE (info);
6006  		ASSERT_EQ (info->head, info->open_block);
6007  		ASSERT_EQ (info->head.to_string (), receive_text);
6008  		ASSERT_EQ (info->representative, nano::dev::genesis_key.pub);
6009  	}
6010  	nano::keypair key2;
6011  	auto prev_amount (node->balance (nano::dev::genesis_key.pub));
6012  	auto send2 (wallet->send_action (nano::dev::genesis_key.pub, key2.pub, node->config.receive_minimum.number () - 1, *node->work_generate_blocking (send1->hash ())));
6013  	ASSERT_TIMELY (5s, !node->balance (nano::dev::genesis_key.pub) != prev_amount);
6014  	ASSERT_FALSE (node->store.account.exists (node->store.tx_begin_read (), key2.pub));
6015  	ASSERT_TRUE (node->store.block.exists (node->store.tx_begin_read (), send2->hash ()));
6016  	nano::public_key rep;
6017  	wallet->store.representative_set (node->wallets.tx_begin_write (), rep);
6018  	wallet->insert_adhoc (key2.prv); 
6019  	request.put ("account", key2.pub.to_account ());
6020  	request.put ("block", send2->hash ().to_string ());
6021  	{
6022  		auto response (wait_response (system, rpc_ctx, request));
6023  		auto receive_text (response.get<std::string> ("block"));
6024  		auto info = node->ledger.account_info (node->store.tx_begin_read (), key2.pub);
6025  		ASSERT_TRUE (info);
6026  		ASSERT_EQ (info->head, info->open_block);
6027  		ASSERT_EQ (info->head.to_string (), receive_text);
6028  		ASSERT_EQ (info->representative, rep);
6029  	}
6030  }
6031  TEST (rpc, receive_work_disabled)
6032  {
6033  	nano::test::system system;
6034  	nano::node_config config = system.default_config ();
6035  	auto & worker_node = *system.add_node (config);
6036  	config.peering_port = system.get_available_port ();
6037  	config.work_threads = 0;
6038  	auto node = add_ipc_enabled_node (system, config);
6039  	auto wallet = system.wallet (1);
6040  	std::string wallet_text;
6041  	node->wallets.items.begin ()->first.encode_hex (wallet_text);
6042  	wallet->insert_adhoc (nano::dev::genesis_key.prv);
6043  	nano::keypair key1;
6044  	ASSERT_TRUE (worker_node.work_generation_enabled ());
6045  	auto send1 (wallet->send_action (nano::dev::genesis_key.pub, key1.pub, node->config.receive_minimum.number () - 1, *worker_node.work_generate_blocking (nano::dev::genesis->hash ()), false));
6046  	ASSERT_TRUE (send1 != nullptr);
6047  	ASSERT_TIMELY (5s, node->balance (nano::dev::genesis_key.pub) != nano::dev::constants.genesis_amount);
6048  	ASSERT_FALSE (node->store.account.exists (node->store.tx_begin_read (), key1.pub));
6049  	ASSERT_TRUE (node->store.block.exists (node->store.tx_begin_read (), send1->hash ()));
6050  	wallet->insert_adhoc (key1.prv);
6051  	auto const rpc_ctx = add_rpc (system, node);
6052  	boost::property_tree::ptree request;
6053  	request.put ("action", "receive");
6054  	request.put ("wallet", wallet_text);
6055  	request.put ("account", key1.pub.to_account ());
6056  	request.put ("block", send1->hash ().to_string ());
6057  	{
6058  		auto response (wait_response (system, rpc_ctx, request));
6059  		ASSERT_EQ (std::error_code (nano::error_common::disabled_work_generation).message (), response.get<std::string> ("error"));
6060  	}
6061  }
6062  TEST (rpc, receive_pruned)
6063  {
6064  	nano::test::system system;
6065  	auto & node1 = *system.add_node ();
6066  	nano::node_config node_config = system.default_config ();
6067  	node_config.enable_voting = false; 
6068  	nano::node_flags node_flags;
6069  	node_flags.enable_pruning = true;
6070  	auto node2 = add_ipc_enabled_node (system, node_config, node_flags);
6071  	auto wallet1 = system.wallet (0);
6072  	auto wallet2 = system.wallet (1);
6073  	std::string wallet_text;
6074  	node2->wallets.items.begin ()->first.encode_hex (wallet_text);
6075  	wallet1->insert_adhoc (nano::dev::genesis_key.prv);
6076  	nano::keypair key1;
6077  	wallet2->insert_adhoc (key1.prv);
6078  	auto send1 (wallet1->send_action (nano::dev::genesis_key.pub, key1.pub, node2->config.receive_minimum.number (), *node2->work_generate_blocking (nano::dev::genesis->hash ())));
6079  	ASSERT_TIMELY (5s, node2->balance (nano::dev::genesis_key.pub) != nano::dev::constants.genesis_amount);
6080  	ASSERT_TIMELY (10s, !node2->store.account.exists (node2->store.tx_begin_read (), key1.pub));
6081  	auto send2 (wallet1->send_action (nano::dev::genesis_key.pub, key1.pub, node2->config.receive_minimum.number () - 1, *node2->work_generate_blocking (send1->hash ())));
6082  	auto send3 (wallet1->send_action (nano::dev::genesis_key.pub, key1.pub, node2->config.receive_minimum.number (), *node2->work_generate_blocking (send1->hash ())));
6083  	ASSERT_TIMELY (5s, node2->block_confirmed (send3->hash ()));
6084  	{
6085  		auto transaction (node2->store.tx_begin_write ());
6086  		ASSERT_EQ (2, node2->ledger.pruning_action (transaction, send2->hash (), 1));
6087  	}
6088  	ASSERT_EQ (2, node2->ledger.cache.pruned_count);
6089  	ASSERT_TRUE (node2->ledger.block_or_pruned_exists (send1->hash ()));
6090  	ASSERT_FALSE (node2->store.block.exists (node2->store.tx_begin_read (), send1->hash ()));
6091  	ASSERT_TRUE (node2->ledger.block_or_pruned_exists (send2->hash ()));
6092  	ASSERT_FALSE (node2->store.block.exists (node2->store.tx_begin_read (), send2->hash ()));
6093  	ASSERT_TRUE (node2->ledger.block_or_pruned_exists (send3->hash ()));
6094  	auto const rpc_ctx = add_rpc (system, node2);
6095  	boost::property_tree::ptree request;
6096  	request.put ("action", "receive");
6097  	request.put ("wallet", wallet_text);
6098  	request.put ("account", key1.pub.to_account ());
6099  	request.put ("block", send2->hash ().to_string ());
6100  	{
6101  		auto response (wait_response (system, rpc_ctx, request));
6102  		auto receive_text (response.get<std::string> ("block"));
6103  		auto info = node2->ledger.account_info (node2->store.tx_begin_read (), key1.pub);
6104  		ASSERT_TRUE (info);
6105  		ASSERT_EQ (info->head, nano::block_hash{ receive_text });
6106  	}
6107  	{
6108  		auto response (wait_response (system, rpc_ctx, request));
6109  		ASSERT_EQ (std::error_code (nano::error_process::unreceivable).message (), response.get<std::string> ("error"));
6110  	}
6111  	request.put ("block", nano::block_hash (send2->hash ().number () + 1).to_string ());
6112  	{
6113  		auto response (wait_response (system, rpc_ctx, request));
6114  		ASSERT_EQ (std::error_code (nano::error_blocks::not_found).message (), response.get<std::string> ("error"));
6115  	}
6116  }
6117  TEST (rpc, telemetry_single)
6118  {
6119  	nano::test::system system (1);
6120  	auto node1 = add_ipc_enabled_node (system);
6121  	auto const rpc_ctx = add_rpc (system, node1);
6122  	auto peers_stored = false;
6123  	ASSERT_TIMELY (10s, node1->store.peer.count (node1->store.tx_begin_read ()) != 0);
6124  	boost::property_tree::ptree request;
6125  	auto node = system.nodes.front ();
6126  	request.put ("action", "telemetry");
6127  	request.put ("address", "not_a_valid_address");
6128  	{
6129  		auto response (wait_response (system, rpc_ctx, request, 10s));
6130  		ASSERT_EQ (std::error_code (nano::error_rpc::requires_port_and_address).message (), response.get<std::string> ("error"));
6131  	}
6132  	request.erase ("address");
6133  	request.put ("port", 65);
6134  	{
6135  		auto response (wait_response (system, rpc_ctx, request, 10s));
6136  		ASSERT_EQ (std::error_code (nano::error_rpc::requires_port_and_address).message (), response.get<std::string> ("error"));
6137  	}
6138  	request.put ("address", "not_a_valid_address");
6139  	request.put ("port", 65);
6140  	{
6141  		auto response (wait_response (system, rpc_ctx, request, 10s));
6142  		ASSERT_EQ (std::error_code (nano::error_common::invalid_ip_address).message (), response.get<std::string> ("error"));
6143  	}
6144  	request.put ("address", (boost::format ("%1%") % node->network.endpoint ().address ()).str ());
6145  	request.put ("port", "invalid port");
6146  	{
6147  		auto response (wait_response (system, rpc_ctx, request, 10s));
6148  		ASSERT_EQ (std::error_code (nano::error_common::invalid_port).message (), response.get<std::string> ("error"));
6149  	}
6150  	request.put ("port", node->network.endpoint ().port ());
6151  	{
6152  		auto response (wait_response (system, rpc_ctx, request, 10s));
6153  		nano::jsonconfig config (response);
6154  		nano::telemetry_data telemetry_data;
6155  		auto const should_ignore_identification_metrics = false;
6156  		ASSERT_FALSE (telemetry_data.deserialize_json (config, should_ignore_identification_metrics));
6157  		ASSERT_TRUE (nano::test::compare_telemetry (telemetry_data, *node));
6158  	}
6159  }
6160  TEST (rpc, telemetry_all)
6161  {
6162  	nano::test::system system (1);
6163  	auto node1 = add_ipc_enabled_node (system);
6164  	auto const rpc_ctx = add_rpc (system, node1);
6165  	ASSERT_TIMELY (10s, node1->store.peer.count (node1->store.tx_begin_read ()) != 0);
6166  	auto node = system.nodes.front ();
6167  	auto channel = node1->network.find_node_id (node->get_node_id ());
6168  	ASSERT_TRUE (channel);
6169  	ASSERT_TIMELY (10s, node1->telemetry.get_telemetry (channel->get_endpoint ()));
6170  	boost::property_tree::ptree request;
6171  	request.put ("action", "telemetry");
6172  	{
6173  		auto response (wait_response (system, rpc_ctx, request, 10s));
6174  		nano::jsonconfig config (response);
6175  		nano::telemetry_data telemetry_data;
6176  		auto const should_ignore_identification_metrics = true;
6177  		ASSERT_FALSE (telemetry_data.deserialize_json (config, should_ignore_identification_metrics));
6178  		ASSERT_TRUE (nano::test::compare_telemetry_data (telemetry_data, node->local_telemetry ()));
6179  		ASSERT_FALSE (response.get_optional<std::string> ("node_id").is_initialized ());
6180  		ASSERT_FALSE (response.get_optional<std::string> ("signature").is_initialized ());
6181  	}
6182  	request.put ("raw", "true");
6183  	auto response (wait_response (system, rpc_ctx, request, 10s));
6184  	auto & all_metrics = response.get_child ("metrics");
6185  	auto & metrics = all_metrics.front ().second;
6186  	ASSERT_EQ (1, all_metrics.size ());
6187  	nano::jsonconfig config (metrics);
6188  	nano::telemetry_data data;
6189  	auto const should_ignore_identification_metrics = false;
6190  	ASSERT_FALSE (data.deserialize_json (config, should_ignore_identification_metrics));
6191  	ASSERT_TRUE (nano::test::compare_telemetry (data, *node));
6192  	ASSERT_EQ (node->network.endpoint ().address ().to_string (), metrics.get<std::string> ("address"));
6193  	ASSERT_EQ (node->network.endpoint ().port (), metrics.get<uint16_t> ("port"));
6194  	ASSERT_TRUE (node1->network.find_node_id (data.node_id));
6195  }
6196  TEST (rpc, telemetry_self)
6197  {
6198  	nano::test::system system{ 1 };
6199  	auto node1 = add_ipc_enabled_node (system);
6200  	auto const rpc_ctx = add_rpc (system, node1);
6201  	auto outer_node = system.nodes[0];
6202  	nano::test::establish_tcp (system, *node1, outer_node->network.endpoint ());
6203  	boost::property_tree::ptree request;
6204  	request.put ("action", "telemetry");
6205  	request.put ("address", "::1");
6206  	request.put ("port", node1->network.endpoint ().port ());
6207  	auto const should_ignore_identification_metrics = false;
6208  	{
6209  		auto response (wait_response (system, rpc_ctx, request, 10s));
6210  		nano::telemetry_data data;
6211  		nano::jsonconfig config (response);
6212  		ASSERT_FALSE (data.deserialize_json (config, should_ignore_identification_metrics));
6213  		ASSERT_TRUE (nano::test::compare_telemetry (data, *node1));
6214  	}
6215  	request.put ("address", "[::1]");
6216  	{
6217  		auto response (wait_response (system, rpc_ctx, request, 10s));
6218  		nano::telemetry_data data;
6219  		nano::jsonconfig config (response);
6220  		ASSERT_FALSE (data.deserialize_json (config, should_ignore_identification_metrics));
6221  		ASSERT_TRUE (nano::test::compare_telemetry (data, *node1));
6222  	}
6223  	request.put ("address", "127.0.0.1");
6224  	{
6225  		auto response (wait_response (system, rpc_ctx, request, 10s));
6226  		nano::telemetry_data data;
6227  		nano::jsonconfig config (response);
6228  		ASSERT_FALSE (data.deserialize_json (config, should_ignore_identification_metrics));
6229  		ASSERT_TRUE (nano::test::compare_telemetry (data, *node1));
6230  	}
6231  	request.put ("port", "0");
6232  	{
6233  		auto response (wait_response (system, rpc_ctx, request, 10s));
6234  		ASSERT_EQ (std::error_code (nano::error_rpc::peer_not_found).message (), response.get<std::string> ("error"));
6235  	}
6236  }
6237  TEST (rpc, confirmation_active)
6238  {
6239  	nano::test::system system;
6240  	nano::node_config node_config;
6241  	node_config.ipc_config.transport_tcp.enabled = true;
6242  	node_config.ipc_config.transport_tcp.port = system.get_available_port ();
6243  	nano::node_flags node_flags;
6244  	node_flags.disable_request_loop = true;
6245  	auto node1 (system.add_node (node_config, node_flags));
6246  	auto const rpc_ctx = add_rpc (system, node1);
6247  	nano::block_builder builder;
6248  	auto send1 = builder
6249  				 .send ()
6250  				 .previous (nano::dev::genesis->hash ())
6251  				 .destination (nano::public_key ())
6252  				 .balance (nano::dev::constants.genesis_amount - 100)
6253  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
6254  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
6255  				 .build_shared ();
6256  	auto send2 = builder
6257  				 .send ()
6258  				 .previous (send1->hash ())
6259  				 .destination (nano::public_key ())
6260  				 .balance (nano::dev::constants.genesis_amount - 200)
6261  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
6262  				 .work (*system.work.generate (send1->hash ()))
6263  				 .build_shared ();
6264  	node1->process_active (send1);
6265  	node1->process_active (send2);
6266  	nano::test::start_elections (system, *node1, { send1, send2 });
6267  	ASSERT_EQ (2, node1->active.size ());
6268  	auto election (node1->active.election (send1->qualified_root ()));
6269  	ASSERT_NE (nullptr, election);
6270  	election->force_confirm ();
6271  	ASSERT_TIMELY (5s, election->confirmed ());
6272  	boost::property_tree::ptree request;
6273  	request.put ("action", "confirmation_active");
6274  	{
6275  		auto response (wait_response (system, rpc_ctx, request));
6276  		auto & confirmations (response.get_child ("confirmations"));
6277  		ASSERT_EQ (1, confirmations.size ());
6278  		ASSERT_EQ (send2->qualified_root ().to_string (), confirmations.front ().second.get<std::string> (""));
6279  		ASSERT_EQ (1, response.get<unsigned> ("unconfirmed"));
6280  		ASSERT_EQ (1, response.get<unsigned> ("confirmed"));
6281  	}
6282  }
6283  TEST (rpc, confirmation_info)
6284  {
6285  	nano::test::system system;
6286  	auto node1 = add_ipc_enabled_node (system);
6287  	auto const rpc_ctx = add_rpc (system, node1);
6288  	nano::block_builder builder;
6289  	auto send = builder
6290  				.send ()
6291  				.previous (nano::dev::genesis->hash ())
6292  				.destination (nano::public_key ())
6293  				.balance (nano::dev::constants.genesis_amount - 100)
6294  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
6295  				.work (*system.work.generate (nano::dev::genesis->hash ()))
6296  				.build_shared ();
6297  	node1->process_active (send);
6298  	ASSERT_TIMELY (5s, !node1->active.empty ());
6299  	boost::property_tree::ptree request;
6300  	request.put ("action", "confirmation_info");
6301  	request.put ("root", send->qualified_root ().to_string ());
6302  	request.put ("representatives", "true");
6303  	request.put ("json_block", "true");
6304  	{
6305  		auto response (wait_response (system, rpc_ctx, request));
6306  		ASSERT_EQ (1, response.count ("announcements"));
6307  		ASSERT_EQ (1, response.get<unsigned> ("voters"));
6308  		ASSERT_EQ (send->hash ().to_string (), response.get<std::string> ("last_winner"));
6309  		auto & blocks (response.get_child ("blocks"));
6310  		ASSERT_EQ (1, blocks.size ());
6311  		auto & representatives (blocks.front ().second.get_child ("representatives"));
6312  		ASSERT_EQ (1, representatives.size ());
6313  		ASSERT_EQ (0, response.get<unsigned> ("total_tally"));
6314  	}
6315  }
6316  TEST (node, election_scheduler_container_info)
6317  {
6318  	nano::test::system system;
6319  	nano::node_config node_config;
6320  	node_config.active_elections_size = 0;
6321  	nano::node_flags node_flags;
6322  	auto node = add_ipc_enabled_node (system, node_config);
6323  	auto const rpc_ctx = add_rpc (system, node);
6324  	auto send1 = nano::state_block_builder ()
6325  				 .account (nano::dev::genesis_key.pub)
6326  				 .previous (nano::dev::genesis->hash ())
6327  				 .representative (nano::dev::genesis_key.pub)
6328  				 .balance (nano::dev::constants.genesis_amount - 1)
6329  				 .link (nano::public_key ())
6330  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
6331  				 .work (*node->work_generate_blocking (nano::dev::genesis->hash ()))
6332  				 .build_shared ();
6333  	node->process_active (send1);
6334  	ASSERT_TIMELY (10s, node->scheduler.buckets.size () == 1);
6335  	boost::property_tree::ptree request;
6336  	request.put ("action", "stats");
6337  	request.put ("type", "objects");
6338  	auto response = wait_response (system, rpc_ctx, request);
6339  	auto es = response.get_child ("node").get_child ("election_scheduler");
6340  }
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-rpc.cpp</h3>
            <pre><code>1  #include <nano/boost/beast/core/flat_buffer.hpp>
2  #include <nano/boost/beast/http.hpp>
3  #include <nano/lib/rpcconfig.hpp>
4  #include <nano/lib/threading.hpp>
5  #include <nano/node/ipc/ipc_server.hpp>
6  #include <nano/node/json_handler.hpp>
7  #include <nano/node/node_rpc_config.hpp>
8  #include <nano/node/scheduler/buckets.hpp>
9  #include <nano/node/scheduler/component.hpp>
10  #include <nano/rpc/rpc.hpp>
11  #include <nano/rpc/rpc_request_processor.hpp>
12  #include <nano/rpc_test/common.hpp>
13  #include <nano/test_common/network.hpp>
14  #include <nano/test_common/system.hpp>
15  #include <nano/test_common/telemetry.hpp>
16  #include <nano/test_common/testutil.hpp>
17  #include <gtest/gtest.h>
18  #include <boost/property_tree/json_parser.hpp>
19  #include <algorithm>
20  #include <map>
21  #include <tuple>
22  #include <utility>
23  using namespace std::chrono_literals;
24  using namespace nano::test;
25  TEST (rpc, wrapped_task)
26  {
27  	nano::test::system system;
28  	auto & node = *add_ipc_enabled_node (system);
29  	nano::node_rpc_config node_rpc_config;
30  	std::atomic<bool> response (false);
31  	auto response_handler_l ([&response] (std::string const & response_a) {
32  		std::stringstream istream (response_a);
33  		boost::property_tree::ptree json_l;
34  		ASSERT_NO_THROW (boost::property_tree::read_json (istream, json_l));
35  		ASSERT_EQ (1, json_l.count ("error"));
36  		ASSERT_EQ ("Unable to parse JSON", json_l.get<std::string> ("error"));
37  		response = true;
38  	});
39  	auto handler_l (std::make_shared<nano::json_handler> (node, node_rpc_config, "", response_handler_l));
40  	auto task (handler_l->create_worker_task ([] (std::shared_ptr<nano::json_handler> const &) {
41  		throw std::runtime_error ("");
42  	}));
43  	system.nodes[0]->workers.push_task (task);
44  	ASSERT_TIMELY (5s, response == true);
45  }
46  TEST (rpc, account_balance)
47  {
48  	nano::test::system system;
49  	auto node = add_ipc_enabled_node (system);
50  	nano::state_block_builder builder;
51  	auto send1 = builder.make_block ()
52  				 .account (nano::dev::genesis_key.pub)
53  				 .previous (nano::dev::genesis->hash ())
54  				 .representative (nano::dev::genesis_key.pub)
55  				 .balance (nano::dev::constants.genesis_amount - 1)
56  				 .link (nano::dev::genesis_key.pub)
57  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
58  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
59  				 .build ();
60  	ASSERT_EQ (nano::process_result::progress, node->process (*send1).code);
61  	ASSERT_TIMELY (5s, !node->active.active (*send1));
62  	auto const rpc_ctx = add_rpc (system, node);
63  	boost::property_tree::ptree request;
64  	request.put ("action", "account_balance");
65  	request.put ("account", nano::dev::genesis_key.pub.to_account ());
66  	{
67  		auto response (wait_response (system, rpc_ctx, request));
68  		std::string balance_text (response.get<std::string> ("balance"));
69  		ASSERT_EQ ("340282366920938463463374607431768211455", balance_text);
70  		std::string pending_text (response.get<std::string> ("pending"));
71  		ASSERT_EQ ("0", pending_text);
72  	}
73  	request.put ("include_only_confirmed", false);
74  	{
75  		auto response (wait_response (system, rpc_ctx, request));
76  		std::string balance_text (response.get<std::string> ("balance"));
77  		ASSERT_EQ ("340282366920938463463374607431768211454", balance_text);
78  		std::string pending_text (response.get<std::string> ("pending"));
79  		ASSERT_EQ ("1", pending_text);
80  	}
81  }
82  TEST (rpc, account_block_count)
83  {
84  	nano::test::system system;
85  	auto node = add_ipc_enabled_node (system);
86  	auto const rpc_ctx = add_rpc (system, node);
87  	boost::property_tree::ptree request;
88  	request.put ("action", "account_block_count");
89  	request.put ("account", nano::dev::genesis_key.pub.to_account ());
90  	auto response (wait_response (system, rpc_ctx, request));
91  	std::string block_count_text (response.get<std::string> ("block_count"));
92  	ASSERT_EQ ("1", block_count_text);
93  }
94  TEST (rpc, account_create)
95  {
96  	nano::test::system system;
97  	auto node = add_ipc_enabled_node (system);
98  	auto const rpc_ctx = add_rpc (system, node);
99  	boost::property_tree::ptree request;
100  	request.put ("action", "account_create");
101  	request.put ("wallet", node->wallets.items.begin ()->first.to_string ());
102  	auto response0 (wait_response (system, rpc_ctx, request));
103  	auto account_text0 (response0.get<std::string> ("account"));
104  	nano::account account0;
105  	ASSERT_FALSE (account0.decode_account (account_text0));
106  	ASSERT_TRUE (system.wallet (0)->exists (account0));
107  	constexpr uint64_t max_index (std::numeric_limits<uint32_t>::max ());
108  	request.put ("index", max_index);
109  	auto response1 (wait_response (system, rpc_ctx, request, 10s));
110  	auto account_text1 (response1.get<std::string> ("account"));
111  	nano::account account1;
112  	ASSERT_FALSE (account1.decode_account (account_text1));
113  	ASSERT_TRUE (system.wallet (0)->exists (account1));
114  	request.put ("index", max_index + 1);
115  	auto response2 (wait_response (system, rpc_ctx, request));
116  	ASSERT_EQ (std::error_code (nano::error_common::invalid_index).message (), response2.get<std::string> ("error"));
117  }
118  TEST (rpc, account_weight)
119  {
120  	nano::keypair key;
121  	nano::test::system system;
122  	auto node1 = add_ipc_enabled_node (system);
123  	nano::block_hash latest (node1->latest (nano::dev::genesis_key.pub));
124  	nano::block_builder builder;
125  	auto block = builder
126  				 .change ()
127  				 .previous (latest)
128  				 .representative (key.pub)
129  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
130  				 .work (*node1->work_generate_blocking (latest))
131  				 .build ();
132  	ASSERT_EQ (nano::process_result::progress, node1->process (*block).code);
133  	auto const rpc_ctx = add_rpc (system, node1);
134  	boost::property_tree::ptree request;
135  	request.put ("action", "account_weight");
136  	request.put ("account", key.pub.to_account ());
137  	auto response (wait_response (system, rpc_ctx, request));
138  	std::string balance_text (response.get<std::string> ("weight"));
139  	ASSERT_EQ ("340282366920938463463374607431768211455", balance_text);
140  }
141  TEST (rpc, wallet_contains)
142  {
143  	nano::test::system system;
144  	auto node = add_ipc_enabled_node (system);
145  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
146  	auto const rpc_ctx = add_rpc (system, node);
147  	boost::property_tree::ptree request;
148  	std::string wallet;
149  	node->wallets.items.begin ()->first.encode_hex (wallet);
150  	request.put ("wallet", wallet);
151  	request.put ("action", "wallet_contains");
152  	request.put ("account", nano::dev::genesis_key.pub.to_account ());
153  	auto response (wait_response (system, rpc_ctx, request));
154  	std::string exists_text (response.get<std::string> ("exists"));
155  	ASSERT_EQ ("1", exists_text);
156  }
157  TEST (rpc, wallet_doesnt_contain)
158  {
159  	nano::test::system system;
160  	auto node = add_ipc_enabled_node (system);
161  	auto const rpc_ctx = add_rpc (system, node);
162  	boost::property_tree::ptree request;
163  	std::string wallet;
164  	node->wallets.items.begin ()->first.encode_hex (wallet);
165  	request.put ("wallet", wallet);
166  	request.put ("action", "wallet_contains");
167  	request.put ("account", nano::dev::genesis_key.pub.to_account ());
168  	auto response (wait_response (system, rpc_ctx, request));
169  	std::string exists_text (response.get<std::string> ("exists"));
170  	ASSERT_EQ ("0", exists_text);
171  }
172  TEST (rpc, validate_account_number)
173  {
174  	nano::test::system system;
175  	auto node = add_ipc_enabled_node (system);
176  	auto const rpc_ctx = add_rpc (system, node);
177  	boost::property_tree::ptree request;
178  	request.put ("action", "validate_account_number");
179  	request.put ("account", nano::dev::genesis_key.pub.to_account ());
180  	auto response (wait_response (system, rpc_ctx, request));
181  	std::string exists_text (response.get<std::string> ("valid"));
182  	ASSERT_EQ ("1", exists_text);
183  }
184  TEST (rpc, validate_account_invalid)
185  {
186  	nano::test::system system;
187  	auto node = add_ipc_enabled_node (system);
188  	auto const rpc_ctx = add_rpc (system, node);
189  	std::string account;
190  	nano::dev::genesis_key.pub.encode_account (account);
191  	account[0] ^= 0x1;
192  	boost::property_tree::ptree request;
193  	request.put ("action", "validate_account_number");
194  	request.put ("account", account);
195  	auto response (wait_response (system, rpc_ctx, request));
196  	std::string exists_text (response.get<std::string> ("valid"));
197  	ASSERT_EQ ("0", exists_text);
198  }
199  TEST (rpc, send)
200  {
201  	nano::test::system system;
202  	auto node = add_ipc_enabled_node (system);
203  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
204  	auto const rpc_ctx = add_rpc (system, node);
205  	boost::property_tree::ptree request;
206  	std::string wallet;
207  	node->wallets.items.begin ()->first.encode_hex (wallet);
208  	request.put ("wallet", wallet);
209  	request.put ("action", "send");
210  	request.put ("source", nano::dev::genesis_key.pub.to_account ());
211  	request.put ("destination", nano::dev::genesis_key.pub.to_account ());
212  	request.put ("amount", "100");
213  	ASSERT_EQ (node->balance (nano::dev::genesis_key.pub), nano::dev::constants.genesis_amount);
214  	auto response (wait_response (system, rpc_ctx, request, 10s));
215  	std::string block_text (response.get<std::string> ("block"));
216  	nano::block_hash block;
217  	ASSERT_FALSE (block.decode_hex (block_text));
218  	ASSERT_TRUE (node->ledger.block_or_pruned_exists (block));
219  	ASSERT_EQ (node->latest (nano::dev::genesis_key.pub), block);
220  	ASSERT_NE (node->balance (nano::dev::genesis_key.pub), nano::dev::constants.genesis_amount);
221  }
222  TEST (rpc, send_fail)
223  {
224  	nano::test::system system;
225  	auto node = add_ipc_enabled_node (system);
226  	auto const rpc_ctx = add_rpc (system, node);
227  	boost::property_tree::ptree request;
228  	std::string wallet;
229  	node->wallets.items.begin ()->first.encode_hex (wallet);
230  	request.put ("wallet", wallet);
231  	request.put ("action", "send");
232  	request.put ("source", nano::dev::genesis_key.pub.to_account ());
233  	request.put ("destination", nano::dev::genesis_key.pub.to_account ());
234  	request.put ("amount", "100");
235  	auto response (wait_response (system, rpc_ctx, request, 10s));
236  	ASSERT_EQ (std::error_code (nano::error_common::account_not_found_wallet).message (), response.get<std::string> ("error"));
237  }
238  TEST (rpc, send_work)
239  {
240  	nano::test::system system;
241  	auto node = add_ipc_enabled_node (system);
242  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
243  	auto const rpc_ctx = add_rpc (system, node);
244  	boost::property_tree::ptree request;
245  	std::string wallet;
246  	node->wallets.items.begin ()->first.encode_hex (wallet);
247  	request.put ("wallet", wallet);
248  	request.put ("action", "send");
249  	request.put ("source", nano::dev::genesis_key.pub.to_account ());
250  	request.put ("destination", nano::dev::genesis_key.pub.to_account ());
251  	request.put ("amount", "100");
252  	request.put ("work", "1");
253  	auto response (wait_response (system, rpc_ctx, request, 10s));
254  	ASSERT_EQ (std::error_code (nano::error_common::invalid_work).message (), response.get<std::string> ("error"));
255  	request.erase ("work");
256  	request.put ("work", nano::to_string_hex (*node->work_generate_blocking (node->latest (nano::dev::genesis_key.pub))));
257  	auto response2 (wait_response (system, rpc_ctx, request, 10s));
258  	std::string block_text (response2.get<std::string> ("block"));
259  	nano::block_hash block;
260  	ASSERT_FALSE (block.decode_hex (block_text));
261  	ASSERT_TRUE (node->ledger.block_or_pruned_exists (block));
262  	ASSERT_EQ (node->latest (nano::dev::genesis_key.pub), block);
263  }
264  TEST (rpc, send_work_disabled)
265  {
266  	nano::test::system system;
267  	nano::node_config node_config = system.default_config ();
268  	node_config.work_threads = 0;
269  	auto node = add_ipc_enabled_node (system, node_config);
270  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
271  	auto const rpc_ctx = add_rpc (system, node);
272  	boost::property_tree::ptree request;
273  	std::string wallet;
274  	node->wallets.items.begin ()->first.encode_hex (wallet);
275  	request.put ("wallet", wallet);
276  	request.put ("action", "send");
277  	request.put ("source", nano::dev::genesis_key.pub.to_account ());
278  	request.put ("destination", nano::dev::genesis_key.pub.to_account ());
279  	request.put ("amount", "100");
280  	auto response (wait_response (system, rpc_ctx, request, 10s));
281  	ASSERT_EQ (std::error_code (nano::error_common::disabled_work_generation).message (), response.get<std::string> ("error"));
282  }
283  TEST (rpc, send_idempotent)
284  {
285  	nano::test::system system;
286  	auto node = add_ipc_enabled_node (system);
287  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
288  	auto const rpc_ctx = add_rpc (system, node);
289  	boost::property_tree::ptree request;
290  	std::string wallet;
291  	node->wallets.items.begin ()->first.encode_hex (wallet);
292  	request.put ("wallet", wallet);
293  	request.put ("action", "send");
294  	request.put ("source", nano::dev::genesis_key.pub.to_account ());
295  	request.put ("destination", nano::account{}.to_account ());
296  	request.put ("amount", (nano::dev::constants.genesis_amount - (nano::dev::constants.genesis_amount / 4)).convert_to<std::string> ());
297  	request.put ("id", "123abc");
298  	auto response (wait_response (system, rpc_ctx, request));
299  	std::string block_text (response.get<std::string> ("block"));
300  	nano::block_hash block;
301  	ASSERT_FALSE (block.decode_hex (block_text));
302  	ASSERT_TRUE (node->ledger.block_or_pruned_exists (block));
303  	ASSERT_EQ (node->balance (nano::dev::genesis_key.pub), nano::dev::constants.genesis_amount / 4);
304  	auto response2 (wait_response (system, rpc_ctx, request));
305  	ASSERT_EQ ("", response2.get<std::string> ("error", ""));
306  	ASSERT_EQ (block_text, response2.get<std::string> ("block"));
307  	ASSERT_EQ (node->balance (nano::dev::genesis_key.pub), nano::dev::constants.genesis_amount / 4);
308  	request.erase ("id");
309  	request.put ("id", "456def");
310  	auto response3 (wait_response (system, rpc_ctx, request));
311  	ASSERT_EQ (std::error_code (nano::error_common::insufficient_balance).message (), response3.get<std::string> ("error"));
312  }
313  TEST (rpc, DISABLED_send_epoch_2)
314  {
315  	nano::test::system system;
316  	auto node = add_ipc_enabled_node (system);
317  	ASSERT_NE (nullptr, system.upgrade_genesis_epoch (*node, nano::epoch::epoch_1));
318  	ASSERT_NE (nullptr, system.upgrade_genesis_epoch (*node, nano::epoch::epoch_2));
319  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv, false);
320  	auto target_difficulty = nano::dev::network_params.work.threshold (nano::work_version::work_1, nano::block_details (nano::epoch::epoch_2, true, false, false));
321  	ASSERT_LT (node->network_params.work.entry, target_difficulty);
322  	auto min_difficulty = node->network_params.work.entry;
323  	auto const rpc_ctx = add_rpc (system, node);
324  	boost::property_tree::ptree request;
325  	std::string wallet;
326  	node->wallets.items.begin ()->first.encode_hex (wallet);
327  	request.put ("wallet", wallet);
328  	request.put ("action", "send");
329  	request.put ("source", nano::dev::genesis_key.pub.to_account ());
330  	request.put ("destination", nano::keypair ().pub.to_account ());
331  	request.put ("amount", "1");
332  	auto insufficient = system.work_generate_limited (nano::dev::genesis->hash (), min_difficulty, target_difficulty);
333  	request.put ("work", nano::to_string_hex (insufficient));
334  	{
335  		auto response (wait_response (system, rpc_ctx, request));
336  		std::error_code ec (nano::error_common::invalid_work);
337  		ASSERT_EQ (1, response.count ("error"));
338  		ASSERT_EQ (response.get<std::string> ("error"), ec.message ());
339  	}
340  }
341  TEST (rpc, send_ipc_random_id)
342  {
343  	nano::test::system system;
344  	auto node = add_ipc_enabled_node (system);
345  	auto const rpc_ctx = add_rpc (system, node);
346  	std::atomic<bool> got_request{ false };
347  	rpc_ctx.node_rpc_config->set_request_callback ([&got_request] (boost::property_tree::ptree const & request_a) {
348  		EXPECT_TRUE (request_a.count ("id"));
349  		got_request = true;
350  	});
351  	boost::property_tree::ptree request;
352  	request.put ("action", "send");
353  	auto response (wait_response (system, rpc_ctx, request, 10s));
354  	ASSERT_EQ (1, response.count ("error"));
355  	ASSERT_EQ ("Unable to parse JSON", response.get<std::string> ("error"));
356  	ASSERT_TRUE (got_request);
357  }
358  TEST (rpc, stop)
359  {
360  	nano::test::system system;
361  	auto node = add_ipc_enabled_node (system);
362  	auto const rpc_ctx = add_rpc (system, node);
363  	boost::property_tree::ptree request;
364  	request.put ("action", "stop");
365  	auto response (wait_response (system, rpc_ctx, request));
366  }
367  TEST (rpc, wallet_add)
368  {
369  	nano::test::system system;
370  	auto node = add_ipc_enabled_node (system);
371  	auto const rpc_ctx = add_rpc (system, node);
372  	nano::keypair key1;
373  	std::string key_text;
374  	key1.prv.encode_hex (key_text);
375  	boost::property_tree::ptree request;
376  	std::string wallet;
377  	node->wallets.items.begin ()->first.encode_hex (wallet);
378  	request.put ("wallet", wallet);
379  	request.put ("action", "wallet_add");
380  	request.put ("key", key_text);
381  	auto response (wait_response (system, rpc_ctx, request));
382  	std::string account_text1 (response.get<std::string> ("account"));
383  	ASSERT_EQ (account_text1, key1.pub.to_account ());
384  	ASSERT_TRUE (system.wallet (0)->exists (key1.pub));
385  }
386  TEST (rpc, wallet_password_valid)
387  {
388  	nano::test::system system;
389  	auto node = add_ipc_enabled_node (system);
390  	auto const rpc_ctx = add_rpc (system, node);
391  	boost::property_tree::ptree request;
392  	std::string wallet;
393  	node->wallets.items.begin ()->first.encode_hex (wallet);
394  	request.put ("wallet", wallet);
395  	request.put ("action", "password_valid");
396  	auto response (wait_response (system, rpc_ctx, request));
397  	std::string account_text1 (response.get<std::string> ("valid"));
398  	ASSERT_EQ (account_text1, "1");
399  }
400  TEST (rpc, wallet_password_change)
401  {
402  	nano::test::system system;
403  	auto node = add_ipc_enabled_node (system);
404  	auto const rpc_ctx = add_rpc (system, node);
405  	boost::property_tree::ptree request;
406  	std::string wallet;
407  	node->wallets.items.begin ()->first.encode_hex (wallet);
408  	request.put ("wallet", wallet);
409  	request.put ("action", "password_change");
410  	request.put ("password", "test");
411  	auto response (wait_response (system, rpc_ctx, request));
412  	std::string account_text1 (response.get<std::string> ("changed"));
413  	ASSERT_EQ (account_text1, "1");
414  	auto transaction (system.wallet (0)->wallets.tx_begin_write ());
415  	ASSERT_TRUE (system.wallet (0)->store.valid_password (transaction));
416  	ASSERT_TRUE (system.wallet (0)->enter_password (transaction, ""));
417  	ASSERT_FALSE (system.wallet (0)->store.valid_password (transaction));
418  	ASSERT_FALSE (system.wallet (0)->enter_password (transaction, "test"));
419  	ASSERT_TRUE (system.wallet (0)->store.valid_password (transaction));
420  }
421  TEST (rpc, wallet_password_enter)
422  {
423  	nano::test::system system;
424  	auto node = add_ipc_enabled_node (system);
425  	auto const rpc_ctx = add_rpc (system, node);
426  	nano::raw_key password_l;
427  	password_l.clear ();
428  	system.deadline_set (10s);
429  	while (password_l == 0)
430  	{
431  		ASSERT_NO_ERROR (system.poll ());
432  		system.wallet (0)->store.password.value (password_l);
433  	}
434  	boost::property_tree::ptree request;
435  	std::string wallet;
436  	node->wallets.items.begin ()->first.encode_hex (wallet);
437  	request.put ("wallet", wallet);
438  	request.put ("action", "password_enter");
439  	request.put ("password", "");
440  	auto response (wait_response (system, rpc_ctx, request));
441  	std::string account_text1 (response.get<std::string> ("valid"));
442  	ASSERT_EQ (account_text1, "1");
443  }
444  TEST (rpc, wallet_representative)
445  {
446  	nano::test::system system;
447  	auto node = add_ipc_enabled_node (system);
448  	auto const rpc_ctx = add_rpc (system, node);
449  	boost::property_tree::ptree request;
450  	std::string wallet;
451  	node->wallets.items.begin ()->first.encode_hex (wallet);
452  	request.put ("wallet", wallet);
453  	request.put ("action", "wallet_representative");
454  	auto response (wait_response (system, rpc_ctx, request));
455  	std::string account_text1 (response.get<std::string> ("representative"));
456  	ASSERT_EQ (account_text1, nano::dev::genesis->account ().to_account ());
457  }
458  TEST (rpc, wallet_representative_set)
459  {
460  	nano::test::system system;
461  	auto node = add_ipc_enabled_node (system);
462  	auto const rpc_ctx = add_rpc (system, node);
463  	boost::property_tree::ptree request;
464  	std::string wallet;
465  	node->wallets.items.begin ()->first.encode_hex (wallet);
466  	request.put ("wallet", wallet);
467  	nano::keypair key;
468  	request.put ("action", "wallet_representative_set");
469  	request.put ("representative", key.pub.to_account ());
470  	auto response (wait_response (system, rpc_ctx, request));
471  	auto transaction (node->wallets.tx_begin_read ());
472  	ASSERT_EQ (key.pub, node->wallets.items.begin ()->second->store.representative (transaction));
473  }
474  TEST (rpc, wallet_representative_set_force)
475  {
476  	nano::test::system system;
477  	auto node = add_ipc_enabled_node (system);
478  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
479  	auto const rpc_ctx = add_rpc (system, node);
480  	boost::property_tree::ptree request;
481  	std::string wallet;
482  	node->wallets.items.begin ()->first.encode_hex (wallet);
483  	request.put ("wallet", wallet);
484  	nano::keypair key;
485  	request.put ("action", "wallet_representative_set");
486  	request.put ("representative", key.pub.to_account ());
487  	request.put ("update_existing_accounts", true);
488  	auto response (wait_response (system, rpc_ctx, request));
489  	{
490  		auto transaction (node->wallets.tx_begin_read ());
491  		ASSERT_EQ (key.pub, node->wallets.items.begin ()->second->store.representative (transaction));
492  	}
493  	nano::account representative{};
494  	while (representative != key.pub)
495  	{
496  		auto transaction (node->store.tx_begin_read ());
497  		auto info = node->ledger.account_info (transaction, nano::dev::genesis_key.pub);
498  		if (info)
499  		{
500  			representative = info->representative;
501  		}
502  		ASSERT_NO_ERROR (system.poll ());
503  	}
504  }
505  TEST (rpc, account_list)
506  {
507  	nano::test::system system;
508  	auto node = add_ipc_enabled_node (system);
509  	nano::keypair key2;
510  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
511  	system.wallet (0)->insert_adhoc (key2.prv);
512  	auto const rpc_ctx = add_rpc (system, node);
513  	boost::property_tree::ptree request;
514  	std::string wallet;
515  	node->wallets.items.begin ()->first.encode_hex (wallet);
516  	request.put ("wallet", wallet);
517  	request.put ("action", "account_list");
518  	auto response (wait_response (system, rpc_ctx, request));
519  	auto & accounts_node (response.get_child ("accounts"));
520  	std::vector<nano::account> accounts;
521  	for (auto i (accounts_node.begin ()), j (accounts_node.end ()); i != j; ++i)
522  	{
523  		auto account (i->second.get<std::string> (""));
524  		nano::account number;
525  		ASSERT_FALSE (number.decode_account (account));
526  		accounts.push_back (number);
527  	}
528  	ASSERT_EQ (2, accounts.size ());
529  	for (auto i (accounts.begin ()), j (accounts.end ()); i != j; ++i)
530  	{
531  		ASSERT_TRUE (system.wallet (0)->exists (*i));
532  	}
533  }
534  TEST (rpc, wallet_key_valid)
535  {
536  	nano::test::system system;
537  	auto node = add_ipc_enabled_node (system);
538  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
539  	auto const rpc_ctx = add_rpc (system, node);
540  	boost::property_tree::ptree request;
541  	std::string wallet;
542  	node->wallets.items.begin ()->first.encode_hex (wallet);
543  	request.put ("wallet", wallet);
544  	request.put ("action", "wallet_key_valid");
545  	auto response (wait_response (system, rpc_ctx, request));
546  	std::string exists_text (response.get<std::string> ("valid"));
547  	ASSERT_EQ ("1", exists_text);
548  }
549  TEST (rpc, wallet_create)
550  {
551  	nano::test::system system;
552  	auto node = add_ipc_enabled_node (system);
553  	auto const rpc_ctx = add_rpc (system, node);
554  	boost::property_tree::ptree request;
555  	request.put ("action", "wallet_create");
556  	auto response (wait_response (system, rpc_ctx, request));
557  	std::string wallet_text (response.get<std::string> ("wallet"));
558  	nano::wallet_id wallet_id;
559  	ASSERT_FALSE (wallet_id.decode_hex (wallet_text));
560  	ASSERT_NE (node->wallets.items.end (), node->wallets.items.find (wallet_id));
561  }
562  TEST (rpc, wallet_create_seed)
563  {
564  	nano::test::system system;
565  	auto node = add_ipc_enabled_node (system);
566  	nano::raw_key seed;
567  	nano::random_pool::generate_block (seed.bytes.data (), seed.bytes.size ());
568  	auto prv = nano::deterministic_key (seed, 0);
569  	auto pub (nano::pub_key (prv));
570  	auto const rpc_ctx = add_rpc (system, node);
571  	boost::property_tree::ptree request;
572  	request.put ("action", "wallet_create");
573  	request.put ("seed", seed.to_string ());
574  	auto response (wait_response (system, rpc_ctx, request, 10s));
575  	std::string wallet_text (response.get<std::string> ("wallet"));
576  	nano::wallet_id wallet_id;
577  	ASSERT_FALSE (wallet_id.decode_hex (wallet_text));
578  	auto existing (node->wallets.items.find (wallet_id));
579  	ASSERT_NE (node->wallets.items.end (), existing);
580  	{
581  		auto transaction (node->wallets.tx_begin_read ());
582  		nano::raw_key seed0;
583  		existing->second->store.seed (seed0, transaction);
584  		ASSERT_EQ (seed, seed0);
585  	}
586  	auto account_text (response.get<std::string> ("last_restored_account"));
587  	nano::account account;
588  	ASSERT_FALSE (account.decode_account (account_text));
589  	ASSERT_TRUE (existing->second->exists (account));
590  	ASSERT_EQ (pub, account);
591  	ASSERT_EQ ("1", response.get<std::string> ("restored_count"));
592  }
593  TEST (rpc, wallet_export)
594  {
595  	nano::test::system system;
596  	auto node = add_ipc_enabled_node (system);
597  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
598  	auto const rpc_ctx = add_rpc (system, node);
599  	boost::property_tree::ptree request;
600  	request.put ("action", "wallet_export");
601  	request.put ("wallet", node->wallets.items.begin ()->first.to_string ());
602  	auto response (wait_response (system, rpc_ctx, request));
603  	std::string wallet_json (response.get<std::string> ("json"));
604  	bool error (false);
605  	auto transaction (node->wallets.tx_begin_write ());
606  	nano::kdf kdf{ nano::dev::network_params.kdf_work };
607  	nano::wallet_store store (error, kdf, transaction, nano::dev::genesis->account (), 1, "0", wallet_json);
608  	ASSERT_FALSE (error);
609  	ASSERT_TRUE (store.exists (transaction, nano::dev::genesis_key.pub));
610  }
611  TEST (rpc, wallet_destroy)
612  {
613  	nano::test::system system;
614  	auto node = add_ipc_enabled_node (system);
615  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
616  	auto const rpc_ctx = add_rpc (system, node);
617  	auto wallet_id (node->wallets.items.begin ()->first);
618  	boost::property_tree::ptree request;
619  	request.put ("action", "wallet_destroy");
620  	request.put ("wallet", wallet_id.to_string ());
621  	auto response (wait_response (system, rpc_ctx, request));
622  	ASSERT_EQ (node->wallets.items.end (), node->wallets.items.find (wallet_id));
623  }
624  TEST (rpc, account_move)
625  {
626  	nano::test::system system;
627  	auto node = add_ipc_enabled_node (system);
628  	auto wallet_id (node->wallets.items.begin ()->first);
629  	auto destination (system.wallet (0));
630  	destination->insert_adhoc (nano::dev::genesis_key.prv);
631  	nano::keypair key;
632  	auto source_id = nano::random_wallet_id ();
633  	auto source (node->wallets.create (source_id));
634  	source->insert_adhoc (key.prv);
635  	auto const rpc_ctx = add_rpc (system, node);
636  	boost::property_tree::ptree request;
637  	request.put ("action", "account_move");
638  	request.put ("wallet", wallet_id.to_string ());
639  	request.put ("source", source_id.to_string ());
640  	boost::property_tree::ptree keys;
641  	boost::property_tree::ptree entry;
642  	entry.put ("", key.pub.to_account ());
643  	keys.push_back (std::make_pair ("", entry));
644  	request.add_child ("accounts", keys);
645  	auto response (wait_response (system, rpc_ctx, request));
646  	ASSERT_EQ ("1", response.get<std::string> ("moved"));
647  	ASSERT_TRUE (destination->exists (key.pub));
648  	ASSERT_TRUE (destination->exists (nano::dev::genesis_key.pub));
649  	auto transaction (node->wallets.tx_begin_read ());
650  	ASSERT_EQ (source->store.end (), source->store.begin (transaction));
651  }
652  TEST (rpc, block)
653  {
654  	nano::test::system system;
655  	auto node = add_ipc_enabled_node (system);
656  	auto const rpc_ctx = add_rpc (system, node);
657  	boost::property_tree::ptree request;
658  	request.put ("action", "block");
659  	request.put ("hash", node->latest (nano::dev::genesis->account ()).to_string ());
660  	auto response (wait_response (system, rpc_ctx, request));
661  	auto contents (response.get<std::string> ("contents"));
662  	ASSERT_FALSE (contents.empty ());
663  	ASSERT_TRUE (response.get<bool> ("confirmed")); 
664  }
665  TEST (rpc, block_account)
666  {
667  	nano::test::system system;
668  	auto node = add_ipc_enabled_node (system);
669  	auto const rpc_ctx = add_rpc (system, node);
670  	boost::property_tree::ptree request;
671  	request.put ("action", "block_account");
672  	request.put ("hash", nano::dev::genesis->hash ().to_string ());
673  	auto response (wait_response (system, rpc_ctx, request));
674  	std::string account_text (response.get<std::string> ("account"));
675  	nano::account account;
676  	ASSERT_FALSE (account.decode_account (account_text));
677  }
678  TEST (rpc, chain)
679  {
680  	nano::test::system system;
681  	auto node = add_ipc_enabled_node (system);
682  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
683  	nano::keypair key;
684  	auto genesis (node->latest (nano::dev::genesis_key.pub));
685  	ASSERT_FALSE (genesis.is_zero ());
686  	auto block (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key.pub, 1));
687  	ASSERT_NE (nullptr, block);
688  	auto const rpc_ctx = add_rpc (system, node);
689  	boost::property_tree::ptree request;
690  	request.put ("action", "chain");
691  	request.put ("block", block->hash ().to_string ());
692  	request.put ("count", std::to_string (std::numeric_limits<uint64_t>::max ()));
693  	auto response (wait_response (system, rpc_ctx, request));
694  	auto & blocks_node (response.get_child ("blocks"));
695  	std::vector<nano::block_hash> blocks;
696  	for (auto i (blocks_node.begin ()), n (blocks_node.end ()); i != n; ++i)
697  	{
698  		blocks.push_back (nano::block_hash (i->second.get<std::string> ("")));
699  	}
700  	ASSERT_EQ (2, blocks.size ());
701  	ASSERT_EQ (block->hash (), blocks[0]);
702  	ASSERT_EQ (genesis, blocks[1]);
703  }
704  TEST (rpc, chain_limit)
705  {
706  	nano::test::system system;
707  	auto node = add_ipc_enabled_node (system);
708  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
709  	nano::keypair key;
710  	auto genesis (node->latest (nano::dev::genesis_key.pub));
711  	ASSERT_FALSE (genesis.is_zero ());
712  	auto block (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key.pub, 1));
713  	ASSERT_NE (nullptr, block);
714  	auto const rpc_ctx = add_rpc (system, node);
715  	boost::property_tree::ptree request;
716  	request.put ("action", "chain");
717  	request.put ("block", block->hash ().to_string ());
718  	request.put ("count", 1);
719  	auto response (wait_response (system, rpc_ctx, request));
720  	auto & blocks_node (response.get_child ("blocks"));
721  	std::vector<nano::block_hash> blocks;
722  	for (auto i (blocks_node.begin ()), n (blocks_node.end ()); i != n; ++i)
723  	{
724  		blocks.push_back (nano::block_hash (i->second.get<std::string> ("")));
725  	}
726  	ASSERT_EQ (1, blocks.size ());
727  	ASSERT_EQ (block->hash (), blocks[0]);
728  }
729  TEST (rpc, chain_offset)
730  {
731  	nano::test::system system;
732  	auto node = add_ipc_enabled_node (system);
733  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
734  	nano::keypair key;
735  	auto genesis (node->latest (nano::dev::genesis_key.pub));
736  	ASSERT_FALSE (genesis.is_zero ());
737  	auto block (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key.pub, 1));
738  	ASSERT_NE (nullptr, block);
739  	auto const rpc_ctx = add_rpc (system, node);
740  	boost::property_tree::ptree request;
741  	request.put ("action", "chain");
742  	request.put ("block", block->hash ().to_string ());
743  	request.put ("count", std::to_string (std::numeric_limits<uint64_t>::max ()));
744  	request.put ("offset", 1);
745  	auto response (wait_response (system, rpc_ctx, request));
746  	auto & blocks_node (response.get_child ("blocks"));
747  	std::vector<nano::block_hash> blocks;
748  	for (auto i (blocks_node.begin ()), n (blocks_node.end ()); i != n; ++i)
749  	{
750  		blocks.push_back (nano::block_hash (i->second.get<std::string> ("")));
751  	}
752  	ASSERT_EQ (1, blocks.size ());
753  	ASSERT_EQ (genesis, blocks[0]);
754  }
755  TEST (rpc, frontier)
756  {
757  	nano::test::system system;
758  	auto node = add_ipc_enabled_node (system);
759  	std::unordered_map<nano::account, nano::block_hash> source;
760  	{
761  		auto transaction (node->store.tx_begin_write ());
762  		for (auto i (0); i < 1000; ++i)
763  		{
764  			nano::keypair key;
765  			nano::block_hash hash;
766  			nano::random_pool::generate_block (hash.bytes.data (), hash.bytes.size ());
767  			source[key.pub] = hash;
768  			node->store.confirmation_height.put (transaction, key.pub, { 0, nano::block_hash (0) });
769  			node->store.account.put (transaction, key.pub, nano::account_info (hash, 0, 0, 0, 0, 0, nano::epoch::epoch_0));
770  		}
771  	}
772  	nano::keypair key;
773  	auto const rpc_ctx = add_rpc (system, node);
774  	boost::property_tree::ptree request;
775  	request.put ("action", "frontiers");
776  	request.put ("account", nano::account{}.to_account ());
777  	request.put ("count", std::to_string (std::numeric_limits<uint64_t>::max ()));
778  	auto response (wait_response (system, rpc_ctx, request));
779  	auto & frontiers_node (response.get_child ("frontiers"));
780  	std::unordered_map<nano::account, nano::block_hash> frontiers;
781  	for (auto i (frontiers_node.begin ()), j (frontiers_node.end ()); i != j; ++i)
782  	{
783  		nano::account account;
784  		account.decode_account (i->first);
785  		nano::block_hash frontier;
786  		frontier.decode_hex (i->second.get<std::string> (""));
787  		frontiers[account] = frontier;
788  	}
789  	ASSERT_EQ (1, frontiers.erase (nano::dev::genesis_key.pub));
790  	ASSERT_EQ (source, frontiers);
791  }
792  TEST (rpc, frontier_limited)
793  {
794  	nano::test::system system;
795  	auto node = add_ipc_enabled_node (system);
796  	std::unordered_map<nano::account, nano::block_hash> source;
797  	{
798  		auto transaction (node->store.tx_begin_write ());
799  		for (auto i (0); i < 1000; ++i)
800  		{
801  			nano::keypair key;
802  			nano::block_hash hash;
803  			nano::random_pool::generate_block (hash.bytes.data (), hash.bytes.size ());
804  			source[key.pub] = hash;
805  			node->store.confirmation_height.put (transaction, key.pub, { 0, nano::block_hash (0) });
806  			node->store.account.put (transaction, key.pub, nano::account_info (hash, 0, 0, 0, 0, 0, nano::epoch::epoch_0));
807  		}
808  	}
809  	nano::keypair key;
810  	auto const rpc_ctx = add_rpc (system, node);
811  	boost::property_tree::ptree request;
812  	request.put ("action", "frontiers");
813  	request.put ("account", nano::account{}.to_account ());
814  	request.put ("count", std::to_string (100));
815  	auto response (wait_response (system, rpc_ctx, request));
816  	auto & frontiers_node (response.get_child ("frontiers"));
817  	ASSERT_EQ (100, frontiers_node.size ());
818  }
819  TEST (rpc, frontier_startpoint)
820  {
821  	nano::test::system system;
822  	auto node = add_ipc_enabled_node (system);
823  	std::unordered_map<nano::account, nano::block_hash> source;
824  	{
825  		auto transaction (node->store.tx_begin_write ());
826  		for (auto i (0); i < 1000; ++i)
827  		{
828  			nano::keypair key;
829  			nano::block_hash hash;
830  			nano::random_pool::generate_block (hash.bytes.data (), hash.bytes.size ());
831  			source[key.pub] = hash;
832  			node->store.confirmation_height.put (transaction, key.pub, { 0, nano::block_hash (0) });
833  			node->store.account.put (transaction, key.pub, nano::account_info (hash, 0, 0, 0, 0, 0, nano::epoch::epoch_0));
834  		}
835  	}
836  	nano::keypair key;
837  	auto const rpc_ctx = add_rpc (system, node);
838  	boost::property_tree::ptree request;
839  	request.put ("action", "frontiers");
840  	request.put ("account", source.begin ()->first.to_account ());
841  	request.put ("count", std::to_string (1));
842  	auto response (wait_response (system, rpc_ctx, request));
843  	auto & frontiers_node (response.get_child ("frontiers"));
844  	ASSERT_EQ (1, frontiers_node.size ());
845  	ASSERT_EQ (source.begin ()->first.to_account (), frontiers_node.begin ()->first);
846  }
847  TEST (rpc, history)
848  {
849  	nano::test::system system;
850  	auto node0 = add_ipc_enabled_node (system);
851  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
852  	auto change (system.wallet (0)->change_action (nano::dev::genesis_key.pub, nano::dev::genesis_key.pub));
853  	ASSERT_NE (nullptr, change);
854  	auto send (system.wallet (0)->send_action (nano::dev::genesis_key.pub, nano::dev::genesis_key.pub, node0->config.receive_minimum.number ()));
855  	ASSERT_NE (nullptr, send);
856  	auto receive (system.wallet (0)->receive_action (send->hash (), nano::dev::genesis_key.pub, node0->config.receive_minimum.number (), send->link ().as_account ()));
857  	ASSERT_NE (nullptr, receive);
858  	nano::block_builder builder;
859  	auto usend = builder
860  				 .state ()
861  				 .account (nano::dev::genesis->account ())
862  				 .previous (node0->latest (nano::dev::genesis->account ()))
863  				 .representative (nano::dev::genesis->account ())
864  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
865  				 .link (nano::dev::genesis->account ())
866  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
867  				 .work (*node0->work_generate_blocking (node0->latest (nano::dev::genesis->account ())))
868  				 .build ();
869  	auto ureceive = builder
870  					.state ()
871  					.account (nano::dev::genesis->account ())
872  					.previous (usend->hash ())
873  					.representative (nano::dev::genesis->account ())
874  					.balance (nano::dev::constants.genesis_amount)
875  					.link (usend->hash ())
876  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
877  					.work (*node0->work_generate_blocking (usend->hash ()))
878  					.build ();
879  	auto uchange = builder
880  				   .state ()
881  				   .account (nano::dev::genesis->account ())
882  				   .previous (ureceive->hash ())
883  				   .representative (nano::keypair ().pub)
884  				   .balance (nano::dev::constants.genesis_amount)
885  				   .link (0)
886  				   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
887  				   .work (*node0->work_generate_blocking (ureceive->hash ()))
888  				   .build ();
889  	{
890  		auto transaction (node0->store.tx_begin_write ());
891  		ASSERT_EQ (nano::process_result::progress, node0->ledger.process (transaction, *usend).code);
892  		ASSERT_EQ (nano::process_result::progress, node0->ledger.process (transaction, *ureceive).code);
893  		ASSERT_EQ (nano::process_result::progress, node0->ledger.process (transaction, *uchange).code);
894  	}
895  	auto const rpc_ctx = add_rpc (system, node0);
896  	boost::property_tree::ptree request;
897  	request.put ("action", "history");
898  	request.put ("hash", uchange->hash ().to_string ());
899  	request.put ("count", 100);
900  	auto response (wait_response (system, rpc_ctx, request));
901  	std::vector<std::tuple<std::string, std::string, std::string, std::string>> history_l;
902  	auto & history_node (response.get_child ("history"));
903  	for (auto i (history_node.begin ()), n (history_node.end ()); i != n; ++i)
904  	{
905  		history_l.push_back (std::make_tuple (i->second.get<std::string> ("type"), i->second.get<std::string> ("account"), i->second.get<std::string> ("amount"), i->second.get<std::string> ("hash")));
906  	}
907  	ASSERT_EQ (5, history_l.size ());
908  	ASSERT_EQ ("receive", std::get<0> (history_l[0]));
909  	ASSERT_EQ (ureceive->hash ().to_string (), std::get<3> (history_l[0]));
910  	ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), std::get<1> (history_l[0]));
911  	ASSERT_EQ (nano::Gxrb_ratio.convert_to<std::string> (), std::get<2> (history_l[0]));
912  	ASSERT_EQ (5, history_l.size ());
913  	ASSERT_EQ ("send", std::get<0> (history_l[1]));
914  	ASSERT_EQ (usend->hash ().to_string (), std::get<3> (history_l[1]));
915  	ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), std::get<1> (history_l[1]));
916  	ASSERT_EQ (nano::Gxrb_ratio.convert_to<std::string> (), std::get<2> (history_l[1]));
917  	ASSERT_EQ ("receive", std::get<0> (history_l[2]));
918  	ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), std::get<1> (history_l[2]));
919  	ASSERT_EQ (node0->config.receive_minimum.to_string_dec (), std::get<2> (history_l[2]));
920  	ASSERT_EQ (receive->hash ().to_string (), std::get<3> (history_l[2]));
921  	ASSERT_EQ ("send", std::get<0> (history_l[3]));
922  	ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), std::get<1> (history_l[3]));
923  	ASSERT_EQ (node0->config.receive_minimum.to_string_dec (), std::get<2> (history_l[3]));
924  	ASSERT_EQ (send->hash ().to_string (), std::get<3> (history_l[3]));
925  	ASSERT_EQ ("receive", std::get<0> (history_l[4]));
926  	ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), std::get<1> (history_l[4]));
927  	ASSERT_EQ (nano::dev::constants.genesis_amount.convert_to<std::string> (), std::get<2> (history_l[4]));
928  	ASSERT_EQ (nano::dev::genesis->hash ().to_string (), std::get<3> (history_l[4]));
929  }
930  TEST (rpc, account_history)
931  {
932  	nano::test::system system;
933  	auto node0 = add_ipc_enabled_node (system);
934  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
935  	auto change (system.wallet (0)->change_action (nano::dev::genesis_key.pub, nano::dev::genesis_key.pub));
936  	ASSERT_NE (nullptr, change);
937  	auto send (system.wallet (0)->send_action (nano::dev::genesis_key.pub, nano::dev::genesis_key.pub, node0->config.receive_minimum.number ()));
938  	ASSERT_NE (nullptr, send);
939  	auto receive (system.wallet (0)->receive_action (send->hash (), nano::dev::genesis_key.pub, node0->config.receive_minimum.number (), send->link ().as_account ()));
940  	ASSERT_NE (nullptr, receive);
941  	nano::block_builder builder;
942  	auto usend = builder
943  				 .state ()
944  				 .account (nano::dev::genesis->account ())
945  				 .previous (node0->latest (nano::dev::genesis->account ()))
946  				 .representative (nano::dev::genesis->account ())
947  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
948  				 .link (nano::dev::genesis->account ())
949  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
950  				 .work (*node0->work_generate_blocking (node0->latest (nano::dev::genesis->account ())))
951  				 .build ();
952  	auto ureceive = builder
953  					.state ()
954  					.account (nano::dev::genesis->account ())
955  					.previous (usend->hash ())
956  					.representative (nano::dev::genesis->account ())
957  					.balance (nano::dev::constants.genesis_amount)
958  					.link (usend->hash ())
959  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
960  					.work (*node0->work_generate_blocking (usend->hash ()))
961  					.build ();
962  	auto uchange = builder
963  				   .state ()
964  				   .account (nano::dev::genesis->account ())
965  				   .previous (ureceive->hash ())
966  				   .representative (nano::keypair ().pub)
967  				   .balance (nano::dev::constants.genesis_amount)
968  				   .link (0)
969  				   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
970  				   .work (*node0->work_generate_blocking (ureceive->hash ()))
971  				   .build ();
972  	{
973  		auto transaction (node0->store.tx_begin_write ());
974  		ASSERT_EQ (nano::process_result::progress, node0->ledger.process (transaction, *usend).code);
975  		ASSERT_EQ (nano::process_result::progress, node0->ledger.process (transaction, *ureceive).code);
976  		ASSERT_EQ (nano::process_result::progress, node0->ledger.process (transaction, *uchange).code);
977  	}
978  	auto const rpc_ctx = add_rpc (system, node0);
979  	{
980  		boost::property_tree::ptree request;
981  		request.put ("action", "account_history");
982  		request.put ("account", nano::dev::genesis->account ().to_account ());
983  		request.put ("count", 100);
984  		auto response (wait_response (system, rpc_ctx, request, 10s));
985  		std::vector<std::tuple<std::string, std::string, std::string, std::string, std::string, bool>> history_l;
986  		auto & history_node (response.get_child ("history"));
987  		for (auto i (history_node.begin ()), n (history_node.end ()); i != n; ++i)
988  		{
989  			history_l.push_back (std::make_tuple (i->second.get<std::string> ("type"), i->second.get<std::string> ("account"), i->second.get<std::string> ("amount"), i->second.get<std::string> ("hash"), i->second.get<std::string> ("height"), i->second.get<bool> ("confirmed")));
990  		}
991  		ASSERT_EQ (5, history_l.size ());
992  		ASSERT_EQ ("receive", std::get<0> (history_l[0]));
993  		ASSERT_EQ (ureceive->hash ().to_string (), std::get<3> (history_l[0]));
994  		ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), std::get<1> (history_l[0]));
995  		ASSERT_EQ (nano::Gxrb_ratio.convert_to<std::string> (), std::get<2> (history_l[0]));
996  		ASSERT_EQ ("6", std::get<4> (history_l[0])); 
997  		ASSERT_FALSE (std::get<5> (history_l[0]));
998  		ASSERT_EQ ("send", std::get<0> (history_l[1]));
999  		ASSERT_EQ (usend->hash ().to_string (), std::get<3> (history_l[1]));
1000  		ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), std::get<1> (history_l[1]));
1001  		ASSERT_EQ (nano::Gxrb_ratio.convert_to<std::string> (), std::get<2> (history_l[1]));
1002  		ASSERT_EQ ("5", std::get<4> (history_l[1]));
1003  		ASSERT_FALSE (std::get<5> (history_l[1]));
1004  		ASSERT_EQ ("receive", std::get<0> (history_l[2]));
1005  		ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), std::get<1> (history_l[2]));
1006  		ASSERT_EQ (node0->config.receive_minimum.to_string_dec (), std::get<2> (history_l[2]));
1007  		ASSERT_EQ (receive->hash ().to_string (), std::get<3> (history_l[2]));
1008  		ASSERT_EQ ("4", std::get<4> (history_l[2]));
1009  		ASSERT_FALSE (std::get<5> (history_l[2]));
1010  		ASSERT_EQ ("send", std::get<0> (history_l[3]));
1011  		ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), std::get<1> (history_l[3]));
1012  		ASSERT_EQ (node0->config.receive_minimum.to_string_dec (), std::get<2> (history_l[3]));
1013  		ASSERT_EQ (send->hash ().to_string (), std::get<3> (history_l[3]));
1014  		ASSERT_EQ ("3", std::get<4> (history_l[3]));
1015  		ASSERT_FALSE (std::get<5> (history_l[3]));
1016  		ASSERT_EQ ("receive", std::get<0> (history_l[4]));
1017  		ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), std::get<1> (history_l[4]));
1018  		ASSERT_EQ (nano::dev::constants.genesis_amount.convert_to<std::string> (), std::get<2> (history_l[4]));
1019  		ASSERT_EQ (nano::dev::genesis->hash ().to_string (), std::get<3> (history_l[4]));
1020  		ASSERT_EQ ("1", std::get<4> (history_l[4])); 
1021  		ASSERT_TRUE (std::get<5> (history_l[4]));
1022  	}
1023  	{
1024  		boost::property_tree::ptree request;
1025  		request.put ("action", "account_history");
1026  		request.put ("account", nano::dev::genesis->account ().to_account ());
1027  		request.put ("reverse", true);
1028  		request.put ("count", 1);
1029  		auto response (wait_response (system, rpc_ctx, request, 10s));
1030  		auto & history_node (response.get_child ("history"));
1031  		ASSERT_EQ (1, history_node.size ());
1032  		ASSERT_EQ ("1", history_node.begin ()->second.get<std::string> ("height"));
1033  		ASSERT_EQ (change->hash ().to_string (), response.get<std::string> ("next"));
1034  	}
1035  	auto account2 (system.wallet (0)->deterministic_insert ());
1036  	auto send2 (system.wallet (0)->send_action (nano::dev::genesis_key.pub, account2, node0->config.receive_minimum.number ()));
1037  	ASSERT_NE (nullptr, send2);
1038  	auto receive2 (system.wallet (0)->receive_action (send2->hash (), account2, node0->config.receive_minimum.number (), send2->link ().as_account ()));
1039  	ASSERT_NE (nullptr, receive2);
1040  	{
1041  		boost::property_tree::ptree request;
1042  		request.put ("action", "account_history");
1043  		request.put ("account", nano::dev::genesis_key.pub.to_account ());
1044  		boost::property_tree::ptree other_account;
1045  		other_account.put ("", account2.to_account ());
1046  		boost::property_tree::ptree filtered_accounts;
1047  		filtered_accounts.push_back (std::make_pair ("", other_account));
1048  		request.add_child ("account_filter", filtered_accounts);
1049  		request.put ("count", 100);
1050  		auto response (wait_response (system, rpc_ctx, request));
1051  		auto history_node (response.get_child ("history"));
1052  		ASSERT_EQ (history_node.size (), 2);
1053  	}
1054  	{
1055  		boost::property_tree::ptree request;
1056  		request.put ("action", "account_history");
1057  		request.put ("account", account2.to_account ());
1058  		boost::property_tree::ptree other_account;
1059  		other_account.put ("", nano::dev::genesis_key.pub.to_account ());
1060  		boost::property_tree::ptree filtered_accounts;
1061  		filtered_accounts.push_back (std::make_pair ("", other_account));
1062  		request.add_child ("account_filter", filtered_accounts);
1063  		request.put ("count", 100);
1064  		auto response (wait_response (system, rpc_ctx, request));
1065  		auto history_node (response.get_child ("history"));
1066  		ASSERT_EQ (history_node.size (), 1);
1067  	}
1068  }
1069  TEST (rpc, history_count)
1070  {
1071  	nano::test::system system;
1072  	auto node = add_ipc_enabled_node (system);
1073  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
1074  	auto change (system.wallet (0)->change_action (nano::dev::genesis_key.pub, nano::dev::genesis_key.pub));
1075  	ASSERT_NE (nullptr, change);
1076  	auto send (system.wallet (0)->send_action (nano::dev::genesis_key.pub, nano::dev::genesis_key.pub, node->config.receive_minimum.number ()));
1077  	ASSERT_NE (nullptr, send);
1078  	auto receive (system.wallet (0)->receive_action (send->hash (), nano::dev::genesis_key.pub, node->config.receive_minimum.number (), send->link ().as_account ()));
1079  	ASSERT_NE (nullptr, receive);
1080  	auto const rpc_ctx = add_rpc (system, node);
1081  	boost::property_tree::ptree request;
1082  	request.put ("action", "history");
1083  	request.put ("hash", receive->hash ().to_string ());
1084  	request.put ("count", 1);
1085  	auto response (wait_response (system, rpc_ctx, request));
1086  	auto & history_node (response.get_child ("history"));
1087  	ASSERT_EQ (1, history_node.size ());
1088  }
1089  TEST (rpc, history_pruning)
1090  {
1091  	nano::test::system system;
1092  	nano::node_config node_config = system.default_config ();
1093  	node_config.enable_voting = false; 
1094  	nano::node_flags node_flags;
1095  	node_flags.enable_pruning = true;
1096  	auto node0 = add_ipc_enabled_node (system, node_config, node_flags);
1097  	std::vector<std::shared_ptr<nano::block>> blocks;
1098  	nano::block_builder builder;
1099  	auto change = builder
1100  				  .change ()
1101  				  .previous (nano::dev::genesis->hash ())
1102  				  .representative (nano::dev::genesis_key.pub)
1103  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1104  				  .work (*node0->work.generate (nano::dev::genesis->hash ()))
1105  				  .build_shared ();
1106  	blocks.push_back (change);
1107  	auto send = builder
1108  				.send ()
1109  				.previous (change->hash ())
1110  				.destination (nano::dev::genesis_key.pub)
1111  				.balance (nano::dev::constants.genesis_amount - node0->config.receive_minimum.number ())
1112  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1113  				.work (*node0->work.generate (change->hash ()))
1114  				.build_shared ();
1115  	blocks.push_back (send);
1116  	auto receive = builder
1117  				   .receive ()
1118  				   .previous (send->hash ())
1119  				   .source (send->hash ())
1120  				   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1121  				   .work (*node0->work.generate (send->hash ()))
1122  				   .build_shared ();
1123  	blocks.push_back (receive);
1124  	auto usend = builder
1125  				 .state ()
1126  				 .account (nano::dev::genesis->account ())
1127  				 .previous (receive->hash ())
1128  				 .representative (nano::dev::genesis->account ())
1129  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
1130  				 .link (nano::dev::genesis->account ())
1131  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1132  				 .work (*node0->work_generate_blocking (receive->hash ()))
1133  				 .build_shared ();
1134  	blocks.push_back (usend);
1135  	auto ureceive = builder
1136  					.state ()
1137  					.account (nano::dev::genesis->account ())
1138  					.previous (usend->hash ())
1139  					.representative (nano::dev::genesis->account ())
1140  					.balance (nano::dev::constants.genesis_amount)
1141  					.link (usend->hash ())
1142  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1143  					.work (*node0->work_generate_blocking (usend->hash ()))
1144  					.build_shared ();
1145  	blocks.push_back (ureceive);
1146  	auto uchange = builder
1147  				   .state ()
1148  				   .account (nano::dev::genesis->account ())
1149  				   .previous (ureceive->hash ())
1150  				   .representative (nano::keypair ().pub)
1151  				   .balance (nano::dev::constants.genesis_amount)
1152  				   .link (0)
1153  				   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1154  				   .work (*node0->work_generate_blocking (ureceive->hash ()))
1155  				   .build_shared ();
1156  	blocks.push_back (uchange);
1157  	nano::test::process_live (*node0, blocks);
1158  	ASSERT_TIMELY (5s, nano::test::exists (*node0, blocks));
1159  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
1160  	ASSERT_TIMELY (5s, nano::test::confirm (*node0, blocks));
1161  	ASSERT_TIMELY (5s, node0->block_confirmed (uchange->hash ()));
1162  	nano::confirmation_height_info confirmation_height_info;
1163  	node0->store.confirmation_height.get (node0->store.tx_begin_read (), nano::dev::genesis_key.pub, confirmation_height_info);
1164  	ASSERT_EQ (7, confirmation_height_info.height);
1165  	{
1166  		auto transaction (node0->store.tx_begin_write ());
1167  		ASSERT_EQ (1, node0->ledger.pruning_action (transaction, change->hash (), 1));
1168  	}
1169  	auto const rpc_ctx = add_rpc (system, node0);
1170  	boost::property_tree::ptree request;
1171  	request.put ("action", "history");
1172  	request.put ("hash", send->hash ().to_string ());
1173  	request.put ("count", 100);
1174  	auto response = wait_response (system, rpc_ctx, request);
1175  	auto history_node = response.get_child ("history");
1176  	ASSERT_EQ (history_node.size (), 1);
1177  	auto entry = (*history_node.begin ()).second;
1178  	ASSERT_EQ ("send", entry.get<std::string> ("type"));
1179  	ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), entry.get<std::string> ("account", "N/A"));
1180  	ASSERT_EQ ("N/A", entry.get<std::string> ("amount", "N/A"));
1181  	ASSERT_EQ (send->hash ().to_string (), entry.get<std::string> ("hash"));
1182  	{
1183  		auto transaction (node0->store.tx_begin_write ());
1184  		ASSERT_EQ (1, node0->ledger.pruning_action (transaction, send->hash (), 1));
1185  	}
1186  	boost::property_tree::ptree request2;
1187  	request2.put ("action", "history");
1188  	request2.put ("hash", receive->hash ().to_string ());
1189  	request2.put ("count", 100);
1190  	response = wait_response (system, rpc_ctx, request2);
1191  	history_node = response.get_child ("history");
1192  	ASSERT_EQ (history_node.size (), 1);
1193  	entry = (*history_node.begin ()).second;
1194  	ASSERT_EQ ("receive", entry.get<std::string> ("type"));
1195  	ASSERT_EQ ("N/A", entry.get<std::string> ("account", "N/A"));
1196  	ASSERT_EQ ("N/A", entry.get<std::string> ("amount", "N/A"));
1197  	ASSERT_EQ (receive->hash ().to_string (), entry.get<std::string> ("hash"));
1198  	{
1199  		auto transaction (node0->store.tx_begin_write ());
1200  		ASSERT_EQ (1, node0->ledger.pruning_action (transaction, receive->hash (), 1));
1201  	}
1202  	boost::property_tree::ptree request3;
1203  	request3.put ("action", "history");
1204  	request3.put ("hash", uchange->hash ().to_string ());
1205  	request3.put ("count", 100);
1206  	response = wait_response (system, rpc_ctx, request3);
1207  	history_node = response.get_child ("history");
1208  	ASSERT_EQ (history_node.size (), 2);
1209  	entry = (*history_node.begin ()).second;
1210  	ASSERT_EQ ("receive", entry.get<std::string> ("type"));
1211  	ASSERT_EQ (ureceive->hash ().to_string (), entry.get<std::string> ("hash"));
1212  	ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), entry.get<std::string> ("account", "N/A"));
1213  	ASSERT_EQ (nano::Gxrb_ratio.convert_to<std::string> (), entry.get<std::string> ("amount", "N/A"));
1214  	entry = (*(++history_node.begin ())).second;
1215  	ASSERT_EQ ("unknown", entry.get<std::string> ("type"));
1216  	ASSERT_EQ ("N/A", entry.get<std::string> ("account", "N/A"));
1217  	ASSERT_EQ ("N/A", entry.get<std::string> ("amount", "N/A"));
1218  	ASSERT_EQ (usend->hash ().to_string (), entry.get<std::string> ("hash"));
1219  }
1220  TEST (rpc, process_block)
1221  {
1222  	nano::test::system system;
1223  	auto node1 = add_ipc_enabled_node (system);
1224  	auto const rpc_ctx = add_rpc (system, node1);
1225  	nano::keypair key;
1226  	auto latest (node1->latest (nano::dev::genesis_key.pub));
1227  	nano::block_builder builder;
1228  	auto send = builder
1229  				.send ()
1230  				.previous (latest)
1231  				.destination (key.pub)
1232  				.balance (100)
1233  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1234  				.work (*node1->work_generate_blocking (latest))
1235  				.build ();
1236  	boost::property_tree::ptree request;
1237  	request.put ("action", "process");
1238  	std::string json;
1239  	send->serialize_json (json);
1240  	request.put ("block", json);
1241  	{
1242  		auto response (wait_response (system, rpc_ctx, request));
1243  		ASSERT_TIMELY (10s, node1->latest (nano::dev::genesis_key.pub) == send->hash ());
1244  		std::string send_hash (response.get<std::string> ("hash"));
1245  		ASSERT_EQ (send->hash ().to_string (), send_hash);
1246  	}
1247  	request.put ("json_block", true);
1248  	{
1249  		auto response (wait_response (system, rpc_ctx, request));
1250  		std::error_code ec (nano::error_blocks::invalid_block);
1251  		ASSERT_EQ (ec.message (), response.get<std::string> ("error"));
1252  	}
1253  }
1254  TEST (rpc, process_json_block)
1255  {
1256  	nano::test::system system;
1257  	auto node1 = add_ipc_enabled_node (system);
1258  	auto const rpc_ctx = add_rpc (system, node1);
1259  	nano::keypair key;
1260  	auto latest (node1->latest (nano::dev::genesis_key.pub));
1261  	nano::block_builder builder;
1262  	auto send = builder
1263  				.send ()
1264  				.previous (latest)
1265  				.destination (key.pub)
1266  				.balance (100)
1267  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1268  				.work (*node1->work_generate_blocking (latest))
1269  				.build ();
1270  	boost::property_tree::ptree request;
1271  	request.put ("action", "process");
1272  	boost::property_tree::ptree block_node;
1273  	send->serialize_json (block_node);
1274  	request.add_child ("block", block_node);
1275  	{
1276  		auto response (wait_response (system, rpc_ctx, request));
1277  		std::error_code ec (nano::error_blocks::invalid_block);
1278  		ASSERT_EQ (ec.message (), response.get<std::string> ("error"));
1279  	}
1280  	request.put ("json_block", true);
1281  	{
1282  		auto response (wait_response (system, rpc_ctx, request));
1283  		ASSERT_TIMELY (10s, node1->latest (nano::dev::genesis_key.pub) == send->hash ());
1284  		std::string send_hash (response.get<std::string> ("hash"));
1285  		ASSERT_EQ (send->hash ().to_string (), send_hash);
1286  	}
1287  }
1288  TEST (rpc, process_block_async)
1289  {
1290  	nano::test::system system;
1291  	auto node1 = add_ipc_enabled_node (system);
1292  	auto const rpc_ctx = add_rpc (system, node1);
1293  	nano::keypair key;
1294  	auto latest (node1->latest (nano::dev::genesis_key.pub));
1295  	nano::block_builder builder;
1296  	auto send = builder
1297  				.send ()
1298  				.previous (latest)
1299  				.destination (key.pub)
1300  				.balance (100)
1301  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1302  				.work (*node1->work_generate_blocking (latest))
1303  				.build ();
1304  	boost::property_tree::ptree request;
1305  	request.put ("action", "process");
1306  	request.put ("async", "true");
1307  	std::string json;
1308  	send->serialize_json (json);
1309  	request.put ("block", json);
1310  	request.put ("json_block", true);
1311  	{
1312  		auto response (wait_response (system, rpc_ctx, request));
1313  		std::error_code ec (nano::error_blocks::invalid_block);
1314  		ASSERT_EQ (ec.message (), response.get<std::string> ("error"));
1315  	}
1316  	request.put ("json_block", false);
1317  	{
1318  		auto response (wait_response (system, rpc_ctx, request));
1319  		std::error_code ec (nano::error_common::is_not_state_block);
1320  		ASSERT_EQ (ec.message (), response.get<std::string> ("error"));
1321  	}
1322  	auto state_send = builder
1323  					  .state ()
1324  					  .account (nano::dev::genesis_key.pub)
1325  					  .previous (latest)
1326  					  .representative (nano::dev::genesis_key.pub)
1327  					  .balance (nano::dev::constants.genesis_amount - 100)
1328  					  .link (nano::dev::genesis_key.pub)
1329  					  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1330  					  .work (*system.work.generate (latest))
1331  					  .build_shared ();
1332  	std::string json1;
1333  	state_send->serialize_json (json1);
1334  	request.put ("block", json1);
1335  	{
1336  		auto response (wait_response (system, rpc_ctx, request));
1337  		ASSERT_EQ ("1", response.get<std::string> ("started"));
1338  		ASSERT_TIMELY (10s, node1->latest (nano::dev::genesis_key.pub) == state_send->hash ());
1339  	}
1340  }
1341  TEST (rpc, process_block_no_work)
1342  {
1343  	nano::test::system system;
1344  	auto node1 = add_ipc_enabled_node (system);
1345  	auto const rpc_ctx = add_rpc (system, node1);
1346  	nano::keypair key;
1347  	auto latest (node1->latest (nano::dev::genesis_key.pub));
1348  	nano::block_builder builder;
1349  	auto send = builder
1350  				.send ()
1351  				.previous (latest)
1352  				.destination (key.pub)
1353  				.balance (100)
1354  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1355  				.work (*node1->work_generate_blocking (latest))
1356  				.build ();
1357  	send->block_work_set (0);
1358  	boost::property_tree::ptree request;
1359  	request.put ("action", "process");
1360  	std::string json;
1361  	send->serialize_json (json);
1362  	request.put ("block", json);
1363  	auto response (wait_response (system, rpc_ctx, request));
1364  	ASSERT_FALSE (response.get<std::string> ("error", "").empty ());
1365  }
1366  TEST (rpc, process_republish)
1367  {
1368  	nano::test::system system (2);
1369  	auto & node1 (*system.nodes[0]);
1370  	auto & node2 (*system.nodes[1]);
1371  	auto node3 = add_ipc_enabled_node (system);
1372  	auto const rpc_ctx = add_rpc (system, node3);
1373  	nano::keypair key;
1374  	auto latest (node1.latest (nano::dev::genesis_key.pub));
1375  	nano::block_builder builder;
1376  	auto send = builder
1377  				.send ()
1378  				.previous (latest)
1379  				.destination (key.pub)
1380  				.balance (100)
1381  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1382  				.work (*node3->work_generate_blocking (latest))
1383  				.build ();
1384  	boost::property_tree::ptree request;
1385  	request.put ("action", "process");
1386  	std::string json;
1387  	send->serialize_json (json);
1388  	request.put ("block", json);
1389  	auto response (wait_response (system, rpc_ctx, request));
1390  	ASSERT_TIMELY (10s, node2.latest (nano::dev::genesis_key.pub) == send->hash ());
1391  }
1392  TEST (rpc, process_subtype_send)
1393  {
1394  	nano::test::system system;
1395  	auto node1 = add_ipc_enabled_node (system);
1396  	system.add_node ();
1397  	auto const rpc_ctx = add_rpc (system, node1);
1398  	nano::keypair key;
1399  	auto latest (node1->latest (nano::dev::genesis_key.pub));
1400  	nano::block_builder builder;
1401  	auto send = builder
1402  				.state ()
1403  				.account (nano::dev::genesis->account ())
1404  				.previous (latest)
1405  				.representative (nano::dev::genesis->account ())
1406  				.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
1407  				.link (key.pub)
1408  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1409  				.work (*node1->work_generate_blocking (latest))
1410  				.build ();
1411  	boost::property_tree::ptree request;
1412  	request.put ("action", "process");
1413  	std::string json;
1414  	send->serialize_json (json);
1415  	request.put ("block", json);
1416  	request.put ("subtype", "receive");
1417  	auto response (wait_response (system, rpc_ctx, request));
1418  	std::error_code ec (nano::error_rpc::invalid_subtype_balance);
1419  	ASSERT_EQ (response.get<std::string> ("error"), ec.message ());
1420  	request.put ("subtype", "change");
1421  	auto response2 (wait_response (system, rpc_ctx, request));
1422  	ASSERT_EQ (response2.get<std::string> ("error"), ec.message ());
1423  	request.put ("subtype", "send");
1424  	auto response3 (wait_response (system, rpc_ctx, request));
1425  	ASSERT_EQ (send->hash ().to_string (), response3.get<std::string> ("hash"));
1426  	ASSERT_TIMELY (10s, system.nodes[1]->latest (nano::dev::genesis_key.pub) == send->hash ());
1427  }
1428  TEST (rpc, process_subtype_open)
1429  {
1430  	nano::test::system system;
1431  	auto node1 = add_ipc_enabled_node (system);
1432  	auto & node2 = *system.add_node ();
1433  	nano::keypair key;
1434  	auto latest (node1->latest (nano::dev::genesis_key.pub));
1435  	nano::block_builder builder;
1436  	auto send = builder
1437  				.state ()
1438  				.account (nano::dev::genesis->account ())
1439  				.previous (latest)
1440  				.representative (nano::dev::genesis->account ())
1441  				.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
1442  				.link (key.pub)
1443  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1444  				.work (*node1->work_generate_blocking (latest))
1445  				.build_shared ();
1446  	ASSERT_EQ (nano::process_result::progress, node1->process (*send).code);
1447  	ASSERT_EQ (nano::process_result::progress, node2.process (*send).code);
1448  	auto const rpc_ctx = add_rpc (system, node1);
1449  	node1->scheduler.buckets.manual (send);
1450  	auto open = builder
1451  				.state ()
1452  				.account (key.pub)
1453  				.previous (0)
1454  				.representative (key.pub)
1455  				.balance (nano::Gxrb_ratio)
1456  				.link (send->hash ())
1457  				.sign (key.prv, key.pub)
1458  				.work (*node1->work_generate_blocking (key.pub))
1459  				.build ();
1460  	boost::property_tree::ptree request;
1461  	request.put ("action", "process");
1462  	std::string json;
1463  	open->serialize_json (json);
1464  	request.put ("block", json);
1465  	request.put ("subtype", "send");
1466  	auto response (wait_response (system, rpc_ctx, request));
1467  	std::error_code ec (nano::error_rpc::invalid_subtype_balance);
1468  	ASSERT_EQ (response.get<std::string> ("error"), ec.message ());
1469  	request.put ("subtype", "epoch");
1470  	auto response2 (wait_response (system, rpc_ctx, request));
1471  	ASSERT_EQ (response2.get<std::string> ("error"), ec.message ());
1472  	request.put ("subtype", "open");
1473  	auto response3 (wait_response (system, rpc_ctx, request));
1474  	ASSERT_EQ (open->hash ().to_string (), response3.get<std::string> ("hash"));
1475  	ASSERT_TIMELY (10s, node2.latest (key.pub) == open->hash ());
1476  }
1477  TEST (rpc, process_subtype_receive)
1478  {
1479  	nano::test::system system;
1480  	auto node1 = add_ipc_enabled_node (system);
1481  	auto & node2 = *system.add_node ();
1482  	auto latest (node1->latest (nano::dev::genesis_key.pub));
1483  	nano::block_builder builder;
1484  	auto send = builder
1485  				.state ()
1486  				.account (nano::dev::genesis->account ())
1487  				.previous (latest)
1488  				.representative (nano::dev::genesis->account ())
1489  				.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
1490  				.link (nano::dev::genesis_key.pub)
1491  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1492  				.work (*node1->work_generate_blocking (latest))
1493  				.build_shared ();
1494  	ASSERT_EQ (nano::process_result::progress, node1->process (*send).code);
1495  	ASSERT_EQ (nano::process_result::progress, node2.process (*send).code);
1496  	auto const rpc_ctx = add_rpc (system, node1);
1497  	node1->scheduler.buckets.manual (send);
1498  	auto receive = builder
1499  				   .state ()
1500  				   .account (nano::dev::genesis_key.pub)
1501  				   .previous (send->hash ())
1502  				   .representative (nano::dev::genesis_key.pub)
1503  				   .balance (nano::dev::constants.genesis_amount)
1504  				   .link (send->hash ())
1505  				   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1506  				   .work (*node1->work_generate_blocking (send->hash ()))
1507  				   .build ();
1508  	boost::property_tree::ptree request;
1509  	request.put ("action", "process");
1510  	std::string json;
1511  	receive->serialize_json (json);
1512  	request.put ("block", json);
1513  	request.put ("subtype", "send");
1514  	auto response (wait_response (system, rpc_ctx, request));
1515  	std::error_code ec (nano::error_rpc::invalid_subtype_balance);
1516  	ASSERT_EQ (response.get<std::string> ("error"), ec.message ());
1517  	request.put ("subtype", "open");
1518  	auto response2 (wait_response (system, rpc_ctx, request));
1519  	ec = nano::error_rpc::invalid_subtype_previous;
1520  	ASSERT_EQ (response2.get<std::string> ("error"), ec.message ());
1521  	request.put ("subtype", "receive");
1522  	auto response3 (wait_response (system, rpc_ctx, request));
1523  	ASSERT_EQ (receive->hash ().to_string (), response3.get<std::string> ("hash"));
1524  	ASSERT_TIMELY (10s, node2.latest (nano::dev::genesis_key.pub) == receive->hash ());
1525  }
1526  TEST (rpc, process_ledger_insufficient_work)
1527  {
1528  	nano::test::system system;
1529  	auto node = add_ipc_enabled_node (system);
1530  	auto const rpc_ctx = add_rpc (system, node);
1531  	ASSERT_LT (node->network_params.work.entry, node->network_params.work.epoch_1);
1532  	auto latest (node->latest (nano::dev::genesis_key.pub));
1533  	auto min_difficulty = node->network_params.work.entry;
1534  	auto max_difficulty = node->network_params.work.epoch_1;
1535  	nano::block_builder builder;
1536  	auto send = builder
1537  				.state ()
1538  				.account (nano::dev::genesis->account ())
1539  				.previous (latest)
1540  				.representative (nano::dev::genesis->account ())
1541  				.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
1542  				.link (nano::dev::genesis_key.pub)
1543  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1544  				.work (system.work_generate_limited (latest, min_difficulty, max_difficulty))
1545  				.build ();
1546  	ASSERT_LT (nano::dev::network_params.work.difficulty (*send), max_difficulty);
1547  	ASSERT_GE (nano::dev::network_params.work.difficulty (*send), min_difficulty);
1548  	boost::property_tree::ptree request;
1549  	request.put ("action", "process");
1550  	std::string json;
1551  	send->serialize_json (json);
1552  	request.put ("block", json);
1553  	request.put ("subtype", "send");
1554  	auto response (wait_response (system, rpc_ctx, request));
1555  	std::error_code ec (nano::error_process::insufficient_work);
1556  	ASSERT_EQ (1, response.count ("error"));
1557  	ASSERT_EQ (response.get<std::string> ("error"), ec.message ());
1558  }
1559  TEST (rpc, keepalive)
1560  {
1561  	nano::test::system system;
1562  	auto node0 = add_ipc_enabled_node (system);
1563  	auto node1 (std::make_shared<nano::node> (system.io_ctx, system.get_available_port (), nano::unique_path (), system.logging, system.work));
1564  	node1->start ();
1565  	system.nodes.push_back (node1);
1566  	auto const rpc_ctx = add_rpc (system, node0);
1567  	boost::property_tree::ptree request;
1568  	request.put ("action", "keepalive");
1569  	auto address (boost::str (boost::format ("%1%") % node1->network.endpoint ().address ()));
1570  	auto port (boost::str (boost::format ("%1%") % node1->network.endpoint ().port ()));
1571  	request.put ("address", address);
1572  	request.put ("port", port);
1573  	ASSERT_EQ (nullptr, node0->network.tcp_channels.find_node_id (node1->get_node_id ()));
1574  	ASSERT_EQ (0, node0->network.size ());
1575  	auto response (wait_response (system, rpc_ctx, request));
1576  	system.deadline_set (10s);
1577  	while (node0->network.find_node_id (node1->get_node_id ()) == nullptr)
1578  	{
1579  		ASSERT_EQ (0, node0->network.size ());
1580  		ASSERT_NO_ERROR (system.poll ());
1581  	}
1582  	node1->stop ();
1583  }
1584  TEST (rpc, peers)
1585  {
1586  	nano::test::system system;
1587  	auto node = add_ipc_enabled_node (system);
1588  	auto const node2 = system.add_node ();
1589  	auto const rpc_ctx = add_rpc (system, node);
1590  	boost::property_tree::ptree request;
1591  	request.put ("action", "peers");
1592  	auto response (wait_response (system, rpc_ctx, request));
1593  	auto & peers_node (response.get_child ("peers"));
1594  	ASSERT_EQ (1, peers_node.size ());
1595  	ASSERT_EQ (std::to_string (node->network_params.network.protocol_version), peers_node.get<std::string> ((boost::format ("[::1]:%1%") % node2->network.endpoint ().port ()).str ()));
1596  }
1597  TEST (rpc, peers_node_id)
1598  {
1599  	nano::test::system system;
1600  	auto node = add_ipc_enabled_node (system);
1601  	auto const node2 = system.add_node ();
1602  	auto const rpc_ctx = add_rpc (system, node);
1603  	boost::property_tree::ptree request;
1604  	request.put ("action", "peers");
1605  	request.put ("peer_details", true);
1606  	auto response (wait_response (system, rpc_ctx, request));
1607  	auto & peers_node (response.get_child ("peers"));
1608  	ASSERT_EQ (1, peers_node.size ());
1609  	auto tree1 (peers_node.get_child ((boost::format ("[::1]:%1%") % node2->network.endpoint ().port ()).str ()));
1610  	ASSERT_EQ (std::to_string (node->network_params.network.protocol_version), tree1.get<std::string> ("protocol_version"));
1611  	ASSERT_EQ (system.nodes[1]->node_id.pub.to_node_id (), tree1.get<std::string> ("node_id"));
1612  }
1613  TEST (rpc, version)
1614  {
1615  	nano::test::system system;
1616  	auto node1 = add_ipc_enabled_node (system);
1617  	auto const rpc_ctx = add_rpc (system, node1);
1618  	boost::property_tree::ptree request1;
1619  	request1.put ("action", "version");
1620  	test_response response1 (request1, rpc_ctx.rpc->listening_port (), system.io_ctx);
1621  	ASSERT_TIMELY (5s, response1.status != 0);
1622  	ASSERT_EQ (200, response1.status);
1623  	ASSERT_EQ ("1", response1.json.get<std::string> ("rpc_version"));
1624  	{
1625  		auto transaction (node1->store.tx_begin_read ());
1626  		ASSERT_EQ (std::to_string (node1->store.version.get (transaction)), response1.json.get<std::string> ("store_version"));
1627  	}
1628  	ASSERT_EQ (std::to_string (node1->network_params.network.protocol_version), response1.json.get<std::string> ("protocol_version"));
1629  	ASSERT_EQ (boost::str (boost::format ("Nano %1%") % NANO_VERSION_STRING), response1.json.get<std::string> ("node_vendor"));
1630  	ASSERT_EQ (node1->store.vendor_get (), response1.json.get<std::string> ("store_vendor"));
1631  	auto network_label (node1->network_params.network.get_current_network_as_string ());
1632  	ASSERT_EQ (network_label, response1.json.get<std::string> ("network"));
1633  	auto genesis_open (node1->latest (nano::dev::genesis_key.pub));
1634  	ASSERT_EQ (genesis_open.to_string (), response1.json.get<std::string> ("network_identifier"));
1635  	ASSERT_EQ (BUILD_INFO, response1.json.get<std::string> ("build_info"));
1636  	auto headers (response1.resp.base ());
1637  	auto allow (headers.at ("Allow"));
1638  	auto content_type (headers.at ("Content-Type"));
1639  	auto access_control_allow_origin (headers.at ("Access-Control-Allow-Origin"));
1640  	auto access_control_allow_methods (headers.at ("Access-Control-Allow-Methods"));
1641  	auto access_control_allow_headers (headers.at ("Access-Control-Allow-Headers"));
1642  	auto connection (headers.at ("Connection"));
1643  	ASSERT_EQ ("POST, OPTIONS", allow);
1644  	ASSERT_EQ ("application/json", content_type);
1645  	ASSERT_EQ ("*", access_control_allow_origin);
1646  	ASSERT_EQ (allow, access_control_allow_methods);
1647  	ASSERT_EQ ("Accept, Accept-Language, Content-Language, Content-Type", access_control_allow_headers);
1648  	ASSERT_EQ ("close", connection);
1649  }
1650  TEST (rpc, work_generate)
1651  {
1652  	nano::test::system system;
1653  	auto node = add_ipc_enabled_node (system);
1654  	auto const rpc_ctx = add_rpc (system, node);
1655  	nano::block_hash hash (1);
1656  	boost::property_tree::ptree request;
1657  	request.put ("action", "work_generate");
1658  	request.put ("hash", hash.to_string ());
1659  	auto verify_response = [&node, &rpc_ctx, &system] (auto & request, auto & hash) {
1660  		auto response (wait_response (system, rpc_ctx, request));
1661  		ASSERT_EQ (hash.to_string (), response.template get<std::string> ("hash"));
1662  		auto work_text (response.template get<std::string> ("work"));
1663  		uint64_t work;
1664  		ASSERT_FALSE (nano::from_string_hex (work_text, work));
1665  		auto result_difficulty (nano::dev::network_params.work.difficulty (nano::work_version::work_1, hash, work));
1666  		auto response_difficulty_text (response.template get<std::string> ("difficulty"));
1667  		uint64_t response_difficulty;
1668  		ASSERT_FALSE (nano::from_string_hex (response_difficulty_text, response_difficulty));
1669  		ASSERT_EQ (result_difficulty, response_difficulty);
1670  		auto multiplier = response.template get<double> ("multiplier");
1671  		ASSERT_NEAR (nano::difficulty::to_multiplier (result_difficulty, node->default_difficulty (nano::work_version::work_1)), multiplier, 1e-6);
1672  	};
1673  	verify_response (request, hash);
1674  	request.put ("use_peers", "true");
1675  	verify_response (request, hash);
1676  }
1677  TEST (rpc, work_generate_difficulty)
1678  {
1679  	nano::test::system system;
1680  	nano::node_config node_config = system.default_config ();
1681  	node_config.max_work_generate_multiplier = 1000;
1682  	auto node = add_ipc_enabled_node (system);
1683  	auto const rpc_ctx = add_rpc (system, node);
1684  	nano::block_hash hash (1);
1685  	boost::property_tree::ptree request;
1686  	request.put ("action", "work_generate");
1687  	request.put ("hash", hash.to_string ());
1688  	{
1689  		uint64_t difficulty (0xfff0000000000000);
1690  		request.put ("difficulty", nano::to_string_hex (difficulty));
1691  		auto response (wait_response (system, rpc_ctx, request, 10s));
1692  		auto work_text (response.get<std::string> ("work"));
1693  		uint64_t work;
1694  		ASSERT_FALSE (nano::from_string_hex (work_text, work));
1695  		auto result_difficulty (nano::dev::network_params.work.difficulty (nano::work_version::work_1, hash, work));
1696  		auto response_difficulty_text (response.get<std::string> ("difficulty"));
1697  		uint64_t response_difficulty;
1698  		ASSERT_FALSE (nano::from_string_hex (response_difficulty_text, response_difficulty));
1699  		ASSERT_EQ (result_difficulty, response_difficulty);
1700  		auto multiplier = response.get<double> ("multiplier");
1701  		ASSERT_NEAR (nano::difficulty::to_multiplier (result_difficulty, node->default_difficulty (nano::work_version::work_1)), multiplier, 1e-10);
1702  		ASSERT_GE (result_difficulty, difficulty);
1703  	}
1704  	{
1705  		uint64_t difficulty (0xffff000000000000);
1706  		request.put ("difficulty", nano::to_string_hex (difficulty));
1707  		auto response (wait_response (system, rpc_ctx, request));
1708  		auto work_text (response.get<std::string> ("work"));
1709  		uint64_t work;
1710  		ASSERT_FALSE (nano::from_string_hex (work_text, work));
1711  		auto result_difficulty (nano::dev::network_params.work.difficulty (nano::work_version::work_1, hash, work));
1712  		ASSERT_GE (result_difficulty, difficulty);
1713  	}
1714  	{
1715  		uint64_t difficulty (node->max_work_generate_difficulty (nano::work_version::work_1) + 1);
1716  		request.put ("difficulty", nano::to_string_hex (difficulty));
1717  		auto response (wait_response (system, rpc_ctx, request));
1718  		std::error_code ec (nano::error_rpc::difficulty_limit);
1719  		ASSERT_EQ (response.get<std::string> ("error"), ec.message ());
1720  	}
1721  }
1722  TEST (rpc, work_generate_multiplier)
1723  {
1724  	nano::test::system system;
1725  	nano::node_config node_config = system.default_config ();
1726  	node_config.max_work_generate_multiplier = 100;
1727  	auto node = add_ipc_enabled_node (system, node_config);
1728  	auto const rpc_ctx = add_rpc (system, node);
1729  	nano::block_hash hash (1);
1730  	boost::property_tree::ptree request;
1731  	request.put ("action", "work_generate");
1732  	request.put ("hash", hash.to_string ());
1733  	{
1734  		request.put ("difficulty", nano::to_string_hex (static_cast<uint64_t> (0xff00000000000000)));
1735  		double multiplier{ 100.0 };
1736  		request.put ("multiplier", multiplier);
1737  		auto response (wait_response (system, rpc_ctx, request, 10s));
1738  		auto work_text (response.get_optional<std::string> ("work"));
1739  		ASSERT_TRUE (work_text.is_initialized ());
1740  		uint64_t work;
1741  		ASSERT_FALSE (nano::from_string_hex (*work_text, work));
1742  		auto result_difficulty (nano::dev::network_params.work.difficulty (nano::work_version::work_1, hash, work));
1743  		auto response_difficulty_text (response.get<std::string> ("difficulty"));
1744  		uint64_t response_difficulty;
1745  		ASSERT_FALSE (nano::from_string_hex (response_difficulty_text, response_difficulty));
1746  		ASSERT_EQ (result_difficulty, response_difficulty);
1747  		auto result_multiplier = response.get<double> ("multiplier");
1748  		ASSERT_GE (result_multiplier, multiplier);
1749  	}
1750  	{
1751  		request.put ("multiplier", -1.5);
1752  		auto response (wait_response (system, rpc_ctx, request));
1753  		std::error_code ec (nano::error_rpc::bad_multiplier_format);
1754  		ASSERT_EQ (response.get<std::string> ("error"), ec.message ());
1755  	}
1756  	{
1757  		double max_multiplier (nano::difficulty::to_multiplier (node->max_work_generate_difficulty (nano::work_version::work_1), node->default_difficulty (nano::work_version::work_1)));
1758  		request.put ("multiplier", max_multiplier + 1);
1759  		auto response (wait_response (system, rpc_ctx, request));
1760  		std::error_code ec (nano::error_rpc::difficulty_limit);
1761  		ASSERT_EQ (response.get<std::string> ("error"), ec.message ());
1762  	}
1763  }
1764  TEST (rpc, work_generate_block_high)
1765  {
1766  	nano::test::system system;
1767  	auto node = add_ipc_enabled_node (system);
1768  	auto const rpc_ctx = add_rpc (system, node);
1769  	nano::keypair key;
1770  	nano::block_builder builder;
1771  	auto block = builder
1772  				 .state ()
1773  				 .account (key.pub)
1774  				 .previous (0)
1775  				 .representative (nano::dev::genesis_key.pub)
1776  				 .balance (nano::Gxrb_ratio)
1777  				 .link (123)
1778  				 .sign (key.prv, key.pub)
1779  				 .work (*node->work_generate_blocking (key.pub))
1780  				 .build ();
1781  	nano::block_hash hash (block->root ().as_block_hash ());
1782  	auto block_difficulty (nano::dev::network_params.work.difficulty (nano::work_version::work_1, hash, block->block_work ()));
1783  	boost::property_tree::ptree request;
1784  	request.put ("action", "work_generate");
1785  	request.put ("hash", hash.to_string ());
1786  	request.put ("json_block", "true");
1787  	boost::property_tree::ptree json;
1788  	block->serialize_json (json);
1789  	request.add_child ("block", json);
1790  	{
1791  		auto response (wait_response (system, rpc_ctx, request));
1792  		ASSERT_EQ (1, response.count ("error"));
1793  		ASSERT_EQ (std::error_code (nano::error_rpc::block_work_enough).message (), response.get<std::string> ("error"));
1794  	}
1795  }
1796  TEST (rpc, work_generate_block_low)
1797  {
1798  	nano::test::system system;
1799  	auto node = add_ipc_enabled_node (system);
1800  	auto const rpc_ctx = add_rpc (system, node);
1801  	nano::keypair key;
1802  	nano::block_builder builder;
1803  	auto block = builder
1804  				 .state ()
1805  				 .account (key.pub)
1806  				 .previous (0)
1807  				 .representative (nano::dev::genesis_key.pub)
1808  				 .balance (nano::Gxrb_ratio)
1809  				 .link (123)
1810  				 .sign (key.prv, key.pub)
1811  				 .work (0)
1812  				 .build ();
1813  	auto threshold (node->default_difficulty (block->work_version ()));
1814  	block->block_work_set (system.work_generate_limited (block->root ().as_block_hash (), threshold, nano::difficulty::from_multiplier (node->config.max_work_generate_multiplier / 10, threshold)));
1815  	nano::block_hash hash (block->root ().as_block_hash ());
1816  	auto block_difficulty (nano::dev::network_params.work.difficulty (*block));
1817  	boost::property_tree::ptree request;
1818  	request.put ("action", "work_generate");
1819  	request.put ("hash", hash.to_string ());
1820  	request.put ("difficulty", nano::to_string_hex (block_difficulty + 1));
1821  	request.put ("json_block", "false");
1822  	std::string json;
1823  	block->serialize_json (json);
1824  	request.put ("block", json);
1825  	{
1826  		auto response (wait_response (system, rpc_ctx, request, 10s));
1827  		auto work_text (response.get_optional<std::string> ("work"));
1828  		ASSERT_TRUE (work_text.is_initialized ());
1829  		uint64_t work;
1830  		ASSERT_FALSE (nano::from_string_hex (*work_text, work));
1831  		ASSERT_NE (block->block_work (), work);
1832  		auto result_difficulty (nano::dev::network_params.work.difficulty (nano::work_version::work_1, hash, work));
1833  		auto response_difficulty_text (response.get<std::string> ("difficulty"));
1834  		uint64_t response_difficulty;
1835  		ASSERT_FALSE (nano::from_string_hex (response_difficulty_text, response_difficulty));
1836  		ASSERT_EQ (result_difficulty, response_difficulty);
1837  		ASSERT_LT (block_difficulty, result_difficulty);
1838  	}
1839  }
1840  TEST (rpc, work_generate_block_root_mismatch)
1841  {
1842  	nano::test::system system;
1843  	auto node = add_ipc_enabled_node (system);
1844  	auto const rpc_ctx = add_rpc (system, node);
1845  	nano::keypair key;
1846  	nano::block_builder builder;
1847  	auto block = builder
1848  				 .state ()
1849  				 .account (key.pub)
1850  				 .previous (0)
1851  				 .representative (nano::dev::genesis_key.pub)
1852  				 .balance (nano::Gxrb_ratio)
1853  				 .link (123)
1854  				 .sign (key.prv, key.pub)
1855  				 .work (*node->work_generate_blocking (key.pub))
1856  				 .build ();
1857  	nano::block_hash hash (1);
1858  	boost::property_tree::ptree request;
1859  	request.put ("action", "work_generate");
1860  	request.put ("hash", hash.to_string ());
1861  	request.put ("json_block", "false");
1862  	std::string json;
1863  	block->serialize_json (json);
1864  	request.put ("block", json);
1865  	{
1866  		auto response (wait_response (system, rpc_ctx, request));
1867  		ASSERT_EQ (1, response.count ("error"));
1868  		ASSERT_EQ (std::error_code (nano::error_rpc::block_root_mismatch).message (), response.get<std::string> ("error"));
1869  	}
1870  }
1871  TEST (rpc, work_generate_block_ledger_epoch_2)
1872  {
1873  	nano::test::system system;
1874  	auto node = add_ipc_enabled_node (system);
1875  	auto epoch1 = system.upgrade_genesis_epoch (*node, nano::epoch::epoch_1);
1876  	ASSERT_NE (nullptr, epoch1);
1877  	auto epoch2 = system.upgrade_genesis_epoch (*node, nano::epoch::epoch_2);
1878  	ASSERT_NE (nullptr, epoch2);
1879  	nano::keypair key;
1880  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
1881  	auto send_block (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key.pub, nano::Gxrb_ratio));
1882  	ASSERT_NE (nullptr, send_block);
1883  	nano::block_builder builder;
1884  	auto block = builder
1885  				 .state ()
1886  				 .account (key.pub)
1887  				 .previous (0)
1888  				 .representative (nano::dev::genesis_key.pub)
1889  				 .balance (nano::Gxrb_ratio)
1890  				 .link (send_block->hash ())
1891  				 .sign (key.prv, key.pub)
1892  				 .work (0)
1893  				 .build ();
1894  	auto threshold (nano::dev::network_params.work.threshold (block->work_version (), nano::block_details (nano::epoch::epoch_2, false, true, false)));
1895  	block->block_work_set (system.work_generate_limited (block->root ().as_block_hash (), 1, threshold - 1));
1896  	nano::block_hash hash (block->root ().as_block_hash ());
1897  	auto const rpc_ctx = add_rpc (system, node);
1898  	boost::property_tree::ptree request;
1899  	request.put ("action", "work_generate");
1900  	request.put ("hash", hash.to_string ());
1901  	request.put ("json_block", "false");
1902  	std::string json;
1903  	block->serialize_json (json);
1904  	request.put ("block", json);
1905  	bool finished (false);
1906  	auto iteration (0);
1907  	while (!finished)
1908  	{
1909  		auto response (wait_response (system, rpc_ctx, request, 10s));
1910  		auto work_text (response.get_optional<std::string> ("work"));
1911  		ASSERT_TRUE (work_text.is_initialized ());
1912  		uint64_t work;
1913  		ASSERT_FALSE (nano::from_string_hex (*work_text, work));
1914  		auto result_difficulty (nano::dev::network_params.work.difficulty (nano::work_version::work_1, hash, work));
1915  		auto response_difficulty_text (response.get<std::string> ("difficulty"));
1916  		uint64_t response_difficulty;
1917  		ASSERT_FALSE (nano::from_string_hex (response_difficulty_text, response_difficulty));
1918  		ASSERT_EQ (result_difficulty, response_difficulty);
1919  		ASSERT_GE (result_difficulty, node->network_params.work.epoch_2_receive);
1920  		finished = result_difficulty < node->network_params.work.epoch_1;
1921  		ASSERT_LT (++iteration, 200);
1922  	}
1923  }
1924  TEST (rpc, work_cancel)
1925  {
1926  	nano::test::system system;
1927  	auto node1 = add_ipc_enabled_node (system);
1928  	auto const rpc_ctx = add_rpc (system, node1);
1929  	nano::block_hash hash1 (1);
1930  	boost::property_tree::ptree request1;
1931  	request1.put ("action", "work_cancel");
1932  	request1.put ("hash", hash1.to_string ());
1933  	std::atomic<bool> done (false);
1934  	system.deadline_set (10s);
1935  	while (!done)
1936  	{
1937  		system.work.generate (nano::work_version::work_1, hash1, node1->network_params.work.base, [&done] (boost::optional<uint64_t> work_a) {
1938  			done = !work_a;
1939  		});
1940  		auto response1 (wait_response (system, rpc_ctx, request1));
1941  		std::error_code ec;
1942  		ASSERT_NO_ERROR (ec);
1943  		std::string success (response1.get<std::string> ("success"));
1944  		ASSERT_TRUE (success.empty ());
1945  	}
1946  }
1947  TEST (rpc, work_peer_bad)
1948  {
1949  	nano::test::system system;
1950  	auto node1 = add_ipc_enabled_node (system);
1951  	auto & node2 = *system.add_node ();
1952  	node2.config.work_peers.emplace_back (boost::asio::ip::address_v6::any ().to_string (), 0);
1953  	auto const rpc_ctx = add_rpc (system, node1);
1954  	nano::block_hash hash1 (1);
1955  	std::atomic<uint64_t> work (0);
1956  	node2.work_generate (nano::work_version::work_1, hash1, node2.network_params.work.base, [&work] (boost::optional<uint64_t> work_a) {
1957  		ASSERT_TRUE (work_a.is_initialized ());
1958  		work = *work_a;
1959  	});
1960  	ASSERT_TIMELY (5s, nano::dev::network_params.work.difficulty (nano::work_version::work_1, hash1, work) >= nano::dev::network_params.work.threshold_base (nano::work_version::work_1));
1961  }
1962  TEST (rpc, DISABLED_work_peer_one)
1963  {
1964  	nano::test::system system;
1965  	auto node1 = add_ipc_enabled_node (system);
1966  	auto & node2 = *system.add_node ();
1967  	auto const rpc_ctx = add_rpc (system, node1);
1968  	node2.config.work_peers.emplace_back (node1->network.endpoint ().address ().to_string (), rpc_ctx.rpc->listening_port ());
1969  	nano::keypair key1;
1970  	std::atomic<uint64_t> work (0);
1971  	node2.work_generate (nano::work_version::work_1, key1.pub, node1->network_params.work.base, [&work] (boost::optional<uint64_t> work_a) {
1972  		ASSERT_TRUE (work_a.is_initialized ());
1973  		work = *work_a;
1974  	});
1975  	ASSERT_TIMELY (5s, nano::dev::network_params.work.difficulty (nano::work_version::work_1, key1.pub, work) >= nano::dev::network_params.work.threshold_base (nano::work_version::work_1));
1976  }
1977  TEST (rpc, DISABLED_work_peer_many)
1978  {
1979  	nano::test::system system1 (1);
1980  	nano::test::system system2;
1981  	nano::test::system system3 (1);
1982  	nano::test::system system4 (1);
1983  	auto & node1 (*system1.nodes[0]);
1984  	auto node2 = add_ipc_enabled_node (system2);
1985  	auto node3 = add_ipc_enabled_node (system3);
1986  	auto node4 = add_ipc_enabled_node (system4);
1987  	const auto rpc_ctx_2 = add_rpc (system2, node2);
1988  	const auto rpc_ctx_3 = add_rpc (system3, node3);
1989  	const auto rpc_ctx_4 = add_rpc (system4, node4);
1990  	node1.config.work_peers.emplace_back (node2->network.endpoint ().address ().to_string (), rpc_ctx_2.rpc->listening_port ());
1991  	node1.config.work_peers.emplace_back (node3->network.endpoint ().address ().to_string (), rpc_ctx_3.rpc->listening_port ());
1992  	node1.config.work_peers.emplace_back (node4->network.endpoint ().address ().to_string (), rpc_ctx_4.rpc->listening_port ());
1993  	std::array<std::atomic<uint64_t>, 10> works{};
1994  	for (auto & work : works)
1995  	{
1996  		nano::keypair key1;
1997  		node1.work_generate (nano::work_version::work_1, key1.pub, node1.network_params.work.base, [&work] (boost::optional<uint64_t> work_a) {
1998  			work = *work_a;
1999  		});
2000  		while (nano::dev::network_params.work.difficulty (nano::work_version::work_1, key1.pub, work) < nano::dev::network_params.work.threshold_base (nano::work_version::work_1))
2001  		{
2002  			system1.poll ();
2003  			system2.poll ();
2004  			system3.poll ();
2005  			system4.poll ();
2006  		}
2007  	}
2008  	node1.stop ();
2009  }
2010  TEST (rpc, DISABLED_work_version_invalid)
2011  {
2012  	nano::test::system system;
2013  	auto node = add_ipc_enabled_node (system);
2014  	auto const rpc_ctx = add_rpc (system, node);
2015  	nano::block_hash hash (1);
2016  	boost::property_tree::ptree request;
2017  	request.put ("action", "work_generate");
2018  	request.put ("hash", hash.to_string ());
2019  	request.put ("version", "work_invalid");
2020  	{
2021  		auto response (wait_response (system, rpc_ctx, request));
2022  		ASSERT_EQ (1, response.count ("error"));
2023  		ASSERT_EQ (std::error_code (nano::error_rpc::bad_work_version).message (), response.get<std::string> ("error"));
2024  	}
2025  	request.put ("action", "work_validate");
2026  	{
2027  		auto response (wait_response (system, rpc_ctx, request));
2028  		ASSERT_EQ (1, response.count ("error"));
2029  		ASSERT_EQ (std::error_code (nano::error_rpc::bad_work_version).message (), response.get<std::string> ("error"));
2030  	}
2031  }
2032  TEST (rpc, block_count)
2033  {
2034  	{
2035  		nano::test::system system;
2036  		auto node1 = add_ipc_enabled_node (system);
2037  		auto const rpc_ctx = add_rpc (system, node1);
2038  		boost::property_tree::ptree request1;
2039  		request1.put ("action", "block_count");
2040  		{
2041  			auto response1 (wait_response (system, rpc_ctx, request1));
2042  			ASSERT_EQ ("1", response1.get<std::string> ("count"));
2043  			ASSERT_EQ ("0", response1.get<std::string> ("unchecked"));
2044  			ASSERT_EQ ("1", response1.get<std::string> ("cemented"));
2045  		}
2046  	}
2047  	{
2048  		nano::test::system system;
2049  		auto node1 = add_ipc_enabled_node (system);
2050  		auto const rpc_ctx = add_rpc (system, node1);
2051  		boost::property_tree::ptree request1;
2052  		request1.put ("action", "block_count");
2053  		{
2054  			auto response1 (wait_response (system, rpc_ctx, request1));
2055  			ASSERT_EQ ("1", response1.get<std::string> ("count"));
2056  			ASSERT_EQ ("0", response1.get<std::string> ("unchecked"));
2057  			ASSERT_EQ ("1", response1.get<std::string> ("cemented"));
2058  		}
2059  	}
2060  }
2061  TEST (rpc, block_count_pruning)
2062  {
2063  	nano::test::system system;
2064  	auto & node0 = *system.add_node ();
2065  	nano::node_config node_config = system.default_config ();
2066  	node_config.enable_voting = false; 
2067  	nano::node_flags node_flags;
2068  	node_flags.enable_pruning = true;
2069  	auto node1 = add_ipc_enabled_node (system, node_config, node_flags);
2070  	auto latest (node1->latest (nano::dev::genesis_key.pub));
2071  	nano::block_builder builder;
2072  	auto send1 = builder
2073  				 .send ()
2074  				 .previous (latest)
2075  				 .destination (nano::dev::genesis_key.pub)
2076  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
2077  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2078  				 .work (*node1->work_generate_blocking (latest))
2079  				 .build_shared ();
2080  	node1->process_active (send1);
2081  	auto receive1 = builder
2082  					.receive ()
2083  					.previous (send1->hash ())
2084  					.source (send1->hash ())
2085  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2086  					.work (*node1->work_generate_blocking (send1->hash ()))
2087  					.build_shared ();
2088  	node1->process_active (receive1);
2089  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
2090  	ASSERT_TIMELY (5s, node1->block_confirmed (receive1->hash ()));
2091  	{
2092  		auto transaction (node1->store.tx_begin_write ());
2093  		ASSERT_EQ (1, node1->ledger.pruning_action (transaction, send1->hash (), 1));
2094  	}
2095  	auto const rpc_ctx = add_rpc (system, node1);
2096  	boost::property_tree::ptree request1;
2097  	request1.put ("action", "block_count");
2098  	{
2099  		auto response1 (wait_response (system, rpc_ctx, request1));
2100  		ASSERT_EQ ("3", response1.get<std::string> ("count"));
2101  		ASSERT_EQ ("0", response1.get<std::string> ("unchecked"));
2102  		ASSERT_EQ ("3", response1.get<std::string> ("cemented"));
2103  		ASSERT_EQ ("2", response1.get<std::string> ("full"));
2104  		ASSERT_EQ ("1", response1.get<std::string> ("pruned"));
2105  	}
2106  }
2107  TEST (rpc, frontier_count)
2108  {
2109  	nano::test::system system;
2110  	auto node1 = add_ipc_enabled_node (system);
2111  	auto const rpc_ctx = add_rpc (system, node1);
2112  	boost::property_tree::ptree request1;
2113  	request1.put ("action", "frontier_count");
2114  	auto response1 (wait_response (system, rpc_ctx, request1));
2115  	ASSERT_EQ ("1", response1.get<std::string> ("count"));
2116  }
2117  TEST (rpc, account_count)
2118  {
2119  	nano::test::system system;
2120  	auto node1 = add_ipc_enabled_node (system);
2121  	auto const rpc_ctx = add_rpc (system, node1);
2122  	boost::property_tree::ptree request1;
2123  	request1.put ("action", "account_count");
2124  	auto response1 (wait_response (system, rpc_ctx, request1));
2125  	ASSERT_EQ ("1", response1.get<std::string> ("count"));
2126  }
2127  TEST (rpc, available_supply)
2128  {
2129  	nano::test::system system;
2130  	auto node1 = add_ipc_enabled_node (system);
2131  	auto const rpc_ctx = add_rpc (system, node1);
2132  	boost::property_tree::ptree request1;
2133  	request1.put ("action", "available_supply");
2134  	auto response1 (wait_response (system, rpc_ctx, request1));
2135  	ASSERT_EQ ("0", response1.get<std::string> ("available"));
2136  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
2137  	nano::keypair key;
2138  	auto block (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key.pub, 1));
2139  	auto response2 (wait_response (system, rpc_ctx, request1));
2140  	ASSERT_EQ ("1", response2.get<std::string> ("available"));
2141  	auto block2 (system.wallet (0)->send_action (nano::dev::genesis_key.pub, 0, 100)); 
2142  	auto response3 (wait_response (system, rpc_ctx, request1, 10s));
2143  	ASSERT_EQ ("1", response3.get<std::string> ("available"));
2144  }
2145  TEST (rpc, mrai_to_raw)
2146  {
2147  	nano::test::system system;
2148  	auto node1 = add_ipc_enabled_node (system);
2149  	auto const rpc_ctx = add_rpc (system, node1);
2150  	boost::property_tree::ptree request1;
2151  	request1.put ("action", "mrai_to_raw");
2152  	request1.put ("amount", "1");
2153  	auto response1 (wait_response (system, rpc_ctx, request1));
2154  	ASSERT_EQ (nano::Mxrb_ratio.convert_to<std::string> (), response1.get<std::string> ("amount"));
2155  }
2156  TEST (rpc, mrai_from_raw)
2157  {
2158  	nano::test::system system;
2159  	auto node1 = add_ipc_enabled_node (system);
2160  	auto const rpc_ctx = add_rpc (system, node1);
2161  	boost::property_tree::ptree request1;
2162  	request1.put ("action", "mrai_from_raw");
2163  	request1.put ("amount", nano::Mxrb_ratio.convert_to<std::string> ());
2164  	auto response1 (wait_response (system, rpc_ctx, request1));
2165  	ASSERT_EQ ("1", response1.get<std::string> ("amount"));
2166  }
2167  TEST (rpc, krai_to_raw)
2168  {
2169  	nano::test::system system;
2170  	auto node1 = add_ipc_enabled_node (system);
2171  	auto const rpc_ctx = add_rpc (system, node1);
2172  	boost::property_tree::ptree request1;
2173  	request1.put ("action", "krai_to_raw");
2174  	request1.put ("amount", "1");
2175  	auto response1 (wait_response (system, rpc_ctx, request1));
2176  	ASSERT_EQ (nano::kxrb_ratio.convert_to<std::string> (), response1.get<std::string> ("amount"));
2177  }
2178  TEST (rpc, krai_from_raw)
2179  {
2180  	nano::test::system system;
2181  	auto node1 = add_ipc_enabled_node (system);
2182  	auto const rpc_ctx = add_rpc (system, node1);
2183  	boost::property_tree::ptree request1;
2184  	request1.put ("action", "krai_from_raw");
2185  	request1.put ("amount", nano::kxrb_ratio.convert_to<std::string> ());
2186  	auto response1 (wait_response (system, rpc_ctx, request1));
2187  	ASSERT_EQ ("1", response1.get<std::string> ("amount"));
2188  }
2189  TEST (rpc, nano_to_raw)
2190  {
2191  	nano::test::system system;
2192  	auto node1 = add_ipc_enabled_node (system);
2193  	auto const rpc_ctx = add_rpc (system, node1);
2194  	boost::property_tree::ptree request1;
2195  	request1.put ("action", "nano_to_raw");
2196  	request1.put ("amount", "1");
2197  	auto response1 (wait_response (system, rpc_ctx, request1));
2198  	ASSERT_EQ (nano::Mxrb_ratio.convert_to<std::string> (), response1.get<std::string> ("amount"));
2199  }
2200  TEST (rpc, raw_to_nano)
2201  {
2202  	nano::test::system system;
2203  	auto node1 = add_ipc_enabled_node (system);
2204  	auto const rpc_ctx = add_rpc (system, node1);
2205  	boost::property_tree::ptree request1;
2206  	request1.put ("action", "raw_to_nano");
2207  	request1.put ("amount", nano::Mxrb_ratio.convert_to<std::string> ());
2208  	auto response1 (wait_response (system, rpc_ctx, request1));
2209  	ASSERT_EQ ("1", response1.get<std::string> ("amount"));
2210  }
2211  TEST (rpc, account_representative)
2212  {
2213  	nano::test::system system;
2214  	auto node = add_ipc_enabled_node (system);
2215  	auto const rpc_ctx = add_rpc (system, node);
2216  	boost::property_tree::ptree request;
2217  	request.put ("account", nano::dev::genesis->account ().to_account ());
2218  	request.put ("action", "account_representative");
2219  	auto response (wait_response (system, rpc_ctx, request));
2220  	std::string account_text1 (response.get<std::string> ("representative"));
2221  	ASSERT_EQ (account_text1, nano::dev::genesis->account ().to_account ());
2222  }
2223  TEST (rpc, account_representative_set)
2224  {
2225  	nano::test::system system;
2226  	auto node = add_ipc_enabled_node (system);
2227  	auto & wallet = *system.wallet (0);
2228  	wallet.insert_adhoc (nano::dev::genesis_key.prv);
2229  	nano::keypair key2;
2230  	wallet.insert_adhoc (key2.prv);
2231  	auto key2_open_block_hash = wallet.send_sync (nano::dev::genesis_key.pub, key2.pub, node->config.receive_minimum.number ());
2232  	ASSERT_TIMELY (5s, node->ledger.block_confirmed (node->store.tx_begin_read (), key2_open_block_hash));
2233  	auto key2_open_block = node->store.block.get (node->store.tx_begin_read (), key2_open_block_hash);
2234  	ASSERT_EQ (nano::dev::genesis_key.pub, key2_open_block->representative ());
2235  	auto const rpc_ctx = add_rpc (system, node);
2236  	boost::property_tree::ptree request;
2237  	request.put ("account", key2.pub.to_account ());
2238  	request.put ("representative", key2.pub.to_account ());
2239  	request.put ("wallet", node->wallets.items.begin ()->first.to_string ());
2240  	request.put ("action", "account_representative_set");
2241  	auto response (wait_response (system, rpc_ctx, request));
2242  	std::string block_text1 (response.get<std::string> ("block"));
2243  	nano::block_hash hash;
2244  	ASSERT_FALSE (hash.decode_hex (block_text1));
2245  	ASSERT_FALSE (hash.is_zero ());
2246  	auto block = node->store.block.get (node->store.tx_begin_read (), hash);
2247  	ASSERT_NE (block, nullptr);
2248  	ASSERT_TIMELY (5s, node->ledger.block_confirmed (node->store.tx_begin_read (), hash));
2249  	ASSERT_EQ (key2.pub, block->representative ());
2250  }
2251  TEST (rpc, account_representative_set_work_disabled)
2252  {
2253  	nano::test::system system;
2254  	nano::node_config node_config = system.default_config ();
2255  	node_config.work_threads = 0;
2256  	auto node = add_ipc_enabled_node (system, node_config);
2257  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
2258  	auto const rpc_ctx = add_rpc (system, node);
2259  	boost::property_tree::ptree request;
2260  	nano::keypair rep;
2261  	request.put ("account", nano::dev::genesis->account ().to_account ());
2262  	request.put ("representative", rep.pub.to_account ());
2263  	request.put ("wallet", node->wallets.items.begin ()->first.to_string ());
2264  	request.put ("action", "account_representative_set");
2265  	{
2266  		auto response (wait_response (system, rpc_ctx, request, 10s));
2267  		ASSERT_EQ (std::error_code (nano::error_common::disabled_work_generation).message (), response.get<std::string> ("error"));
2268  	}
2269  }
2270  TEST (rpc, account_representative_set_epoch_2_insufficient_work)
2271  {
2272  	nano::test::system system;
2273  	auto node = add_ipc_enabled_node (system);
2274  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv, false);
2275  	ASSERT_NE (nullptr, system.upgrade_genesis_epoch (*node, nano::epoch::epoch_1));
2276  	ASSERT_NE (nullptr, system.upgrade_genesis_epoch (*node, nano::epoch::epoch_2));
2277  	node->scheduler.buckets.activate (nano::dev::genesis_key.pub, node->store.tx_begin_read ());
2278  	ASSERT_TIMELY (5s, node->get_confirmation_height (node->store.tx_begin_read (), nano::dev::genesis_key.pub) == 3);
2279  	auto target_difficulty = nano::dev::network_params.work.threshold (nano::work_version::work_1, nano::block_details (nano::epoch::epoch_2, false, false, false));
2280  	ASSERT_LT (node->network_params.work.entry, target_difficulty);
2281  	auto min_difficulty = node->network_params.work.entry;
2282  	auto const rpc_ctx = add_rpc (system, node);
2283  	boost::property_tree::ptree request;
2284  	std::string wallet;
2285  	node->wallets.items.begin ()->first.encode_hex (wallet);
2286  	request.put ("wallet", wallet);
2287  	request.put ("action", "account_representative_set");
2288  	request.put ("account", nano::dev::genesis_key.pub.to_account ());
2289  	request.put ("representative", nano::keypair ().pub.to_account ());
2290  	auto latest = node->ledger.latest (node->store.tx_begin_read (), nano::dev::genesis_key.pub);
2291  	auto insufficient = system.work_generate_limited (latest, min_difficulty, target_difficulty);
2292  	request.put ("work", nano::to_string_hex (insufficient));
2293  	{
2294  		auto response (wait_response (system, rpc_ctx, request));
2295  		std::error_code ec (nano::error_common::invalid_work);
2296  		ASSERT_EQ (1, response.count ("error"));
2297  		ASSERT_EQ (response.get<std::string> ("error"), ec.message ());
2298  	}
2299  }
2300  TEST (rpc, bootstrap)
2301  {
2302  	nano::test::system system0;
2303  	auto node = add_ipc_enabled_node (system0);
2304  	nano::test::system system1 (1);
2305  	auto node1 = system1.nodes[0];
2306  	auto latest (node1->latest (nano::dev::genesis_key.pub));
2307  	nano::block_builder builder;
2308  	auto send = builder
2309  				.send ()
2310  				.previous (latest)
2311  				.destination (nano::dev::genesis->account ())
2312  				.balance (100)
2313  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2314  				.work (*node1->work_generate_blocking (latest))
2315  				.build ();
2316  	{
2317  		auto transaction (node1->store.tx_begin_write ());
2318  		ASSERT_EQ (nano::process_result::progress, node1->ledger.process (transaction, *send).code);
2319  	}
2320  	auto const rpc_ctx = add_rpc (system0, node);
2321  	boost::property_tree::ptree request;
2322  	request.put ("action", "bootstrap");
2323  	request.put ("address", "::ffff:127.0.0.1");
2324  	request.put ("port", node1->network.endpoint ().port ());
2325  	test_response response (request, rpc_ctx.rpc->listening_port (), system0.io_ctx);
2326  	while (response.status == 0)
2327  	{
2328  		system0.poll ();
2329  	}
2330  	system1.deadline_set (10s);
2331  	while (node->latest (nano::dev::genesis->account ()) != node1->latest (nano::dev::genesis->account ()))
2332  	{
2333  		ASSERT_NO_ERROR (system0.poll ());
2334  		ASSERT_NO_ERROR (system1.poll ());
2335  	}
2336  }
2337  TEST (rpc, account_remove)
2338  {
2339  	nano::test::system system0;
2340  	auto node = add_ipc_enabled_node (system0);
2341  	auto key1 (system0.wallet (0)->deterministic_insert ());
2342  	ASSERT_TRUE (system0.wallet (0)->exists (key1));
2343  	auto const rpc_ctx = add_rpc (system0, node);
2344  	boost::property_tree::ptree request;
2345  	request.put ("action", "account_remove");
2346  	request.put ("wallet", node->wallets.items.begin ()->first.to_string ());
2347  	request.put ("account", key1.to_account ());
2348  	auto response (wait_response (system0, rpc_ctx, request));
2349  	ASSERT_FALSE (system0.wallet (0)->exists (key1));
2350  }
2351  TEST (rpc, representatives)
2352  {
2353  	nano::test::system system0;
2354  	auto node = add_ipc_enabled_node (system0);
2355  	auto const rpc_ctx = add_rpc (system0, node);
2356  	boost::property_tree::ptree request;
2357  	request.put ("action", "representatives");
2358  	auto response (wait_response (system0, rpc_ctx, request));
2359  	auto & representatives_node (response.get_child ("representatives"));
2360  	std::vector<nano::account> representatives;
2361  	for (auto i (representatives_node.begin ()), n (representatives_node.end ()); i != n; ++i)
2362  	{
2363  		nano::account account;
2364  		ASSERT_FALSE (account.decode_account (i->first));
2365  		representatives.push_back (account);
2366  	}
2367  	ASSERT_EQ (1, representatives.size ());
2368  	ASSERT_EQ (nano::dev::genesis->account (), representatives[0]);
2369  }
2370  TEST (rpc, wallet_seed)
2371  {
2372  	nano::test::system system;
2373  	auto node = add_ipc_enabled_node (system);
2374  	auto const rpc_ctx = add_rpc (system, node);
2375  	nano::raw_key seed;
2376  	{
2377  		auto transaction (node->wallets.tx_begin_read ());
2378  		system.wallet (0)->store.seed (seed, transaction);
2379  	}
2380  	boost::property_tree::ptree request;
2381  	request.put ("action", "wallet_seed");
2382  	request.put ("wallet", node->wallets.items.begin ()->first.to_string ());
2383  	auto response (wait_response (system, rpc_ctx, request));
2384  	{
2385  		std::string seed_text (response.get<std::string> ("seed"));
2386  		ASSERT_EQ (seed.to_string (), seed_text);
2387  	}
2388  }
2389  TEST (rpc, wallet_change_seed)
2390  {
2391  	nano::test::system system0;
2392  	auto node = add_ipc_enabled_node (system0);
2393  	auto const rpc_ctx = add_rpc (system0, node);
2394  	nano::raw_key seed;
2395  	nano::random_pool::generate_block (seed.bytes.data (), seed.bytes.size ());
2396  	{
2397  		auto transaction (node->wallets.tx_begin_read ());
2398  		nano::raw_key seed0;
2399  		nano::random_pool::generate_block (seed0.bytes.data (), seed0.bytes.size ());
2400  		system0.wallet (0)->store.seed (seed0, transaction);
2401  		ASSERT_NE (seed, seed0);
2402  	}
2403  	auto prv = nano::deterministic_key (seed, 0);
2404  	auto pub (nano::pub_key (prv));
2405  	boost::property_tree::ptree request;
2406  	request.put ("action", "wallet_change_seed");
2407  	request.put ("wallet", node->wallets.items.begin ()->first.to_string ());
2408  	request.put ("seed", seed.to_string ());
2409  	auto response (wait_response (system0, rpc_ctx, request));
2410  	{
2411  		auto transaction (node->wallets.tx_begin_read ());
2412  		nano::raw_key seed0;
2413  		system0.wallet (0)->store.seed (seed0, transaction);
2414  		ASSERT_EQ (seed, seed0);
2415  	}
2416  	auto account_text (response.get<std::string> ("last_restored_account"));
2417  	nano::account account;
2418  	ASSERT_FALSE (account.decode_account (account_text));
2419  	ASSERT_TRUE (system0.wallet (0)->exists (account));
2420  	ASSERT_EQ (pub, account);
2421  	ASSERT_EQ ("1", response.get<std::string> ("restored_count"));
2422  }
2423  TEST (rpc, wallet_frontiers)
2424  {
2425  	nano::test::system system0;
2426  	auto node = add_ipc_enabled_node (system0);
2427  	system0.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
2428  	auto const rpc_ctx = add_rpc (system0, node);
2429  	boost::property_tree::ptree request;
2430  	request.put ("action", "wallet_frontiers");
2431  	request.put ("wallet", node->wallets.items.begin ()->first.to_string ());
2432  	auto response (wait_response (system0, rpc_ctx, request));
2433  	auto & frontiers_node (response.get_child ("frontiers"));
2434  	std::vector<nano::account> frontiers;
2435  	for (auto i (frontiers_node.begin ()), n (frontiers_node.end ()); i != n; ++i)
2436  	{
2437  		frontiers.push_back (nano::account (i->second.get<std::string> ("")));
2438  	}
2439  	ASSERT_EQ (1, frontiers.size ());
2440  	ASSERT_EQ (node->latest (nano::dev::genesis->account ()), frontiers[0]);
2441  }
2442  TEST (rpc, work_validate)
2443  {
2444  	nano::test::system system;
2445  	auto node1 = add_ipc_enabled_node (system);
2446  	auto const rpc_ctx = add_rpc (system, node1);
2447  	nano::block_hash hash (1);
2448  	uint64_t work1 (*node1->work_generate_blocking (hash));
2449  	boost::property_tree::ptree request;
2450  	request.put ("action", "work_validate");
2451  	request.put ("hash", hash.to_string ());
2452  	request.put ("work", nano::to_string_hex (work1));
2453  	{
2454  		auto response (wait_response (system, rpc_ctx, request));
2455  		ASSERT_EQ (0, response.count ("valid"));
2456  		ASSERT_TRUE (response.get<bool> ("valid_all"));
2457  		ASSERT_TRUE (response.get<bool> ("valid_receive"));
2458  		std::string difficulty_text (response.get<std::string> ("difficulty"));
2459  		uint64_t difficulty;
2460  		ASSERT_FALSE (nano::from_string_hex (difficulty_text, difficulty));
2461  		ASSERT_GE (difficulty, node1->default_difficulty (nano::work_version::work_1));
2462  		double multiplier (response.get<double> ("multiplier"));
2463  		ASSERT_NEAR (multiplier, nano::difficulty::to_multiplier (difficulty, node1->default_difficulty (nano::work_version::work_1)), 1e-6);
2464  	}
2465  	uint64_t work2 (0);
2466  	request.put ("work", nano::to_string_hex (work2));
2467  	{
2468  		auto response (wait_response (system, rpc_ctx, request));
2469  		ASSERT_EQ (0, response.count ("valid"));
2470  		ASSERT_FALSE (response.get<bool> ("valid_all"));
2471  		ASSERT_FALSE (response.get<bool> ("valid_receive"));
2472  		std::string difficulty_text (response.get<std::string> ("difficulty"));
2473  		uint64_t difficulty;
2474  		ASSERT_FALSE (nano::from_string_hex (difficulty_text, difficulty));
2475  		ASSERT_GE (node1->default_difficulty (nano::work_version::work_1), difficulty);
2476  		double multiplier (response.get<double> ("multiplier"));
2477  		ASSERT_NEAR (multiplier, nano::difficulty::to_multiplier (difficulty, node1->default_difficulty (nano::work_version::work_1)), 1e-6);
2478  	}
2479  	auto result_difficulty (nano::dev::network_params.work.difficulty (nano::work_version::work_1, hash, work1));
2480  	ASSERT_GE (result_difficulty, node1->default_difficulty (nano::work_version::work_1));
2481  	request.put ("work", nano::to_string_hex (work1));
2482  	request.put ("difficulty", nano::to_string_hex (result_difficulty));
2483  	{
2484  		auto response (wait_response (system, rpc_ctx, request));
2485  		ASSERT_TRUE (response.get<bool> ("valid"));
2486  		ASSERT_TRUE (response.get<bool> ("valid_all"));
2487  		ASSERT_TRUE (response.get<bool> ("valid_receive"));
2488  	}
2489  	uint64_t difficulty4 (0xfff0000000000000);
2490  	request.put ("work", nano::to_string_hex (work1));
2491  	request.put ("difficulty", nano::to_string_hex (difficulty4));
2492  	{
2493  		auto response (wait_response (system, rpc_ctx, request));
2494  		ASSERT_EQ (result_difficulty >= difficulty4, response.get<bool> ("valid"));
2495  		ASSERT_EQ (result_difficulty >= node1->default_difficulty (nano::work_version::work_1), response.get<bool> ("valid_all"));
2496  		ASSERT_EQ (result_difficulty >= node1->network_params.work.epoch_2_receive, response.get<bool> ("valid_all"));
2497  	}
2498  	uint64_t work3 (*node1->work_generate_blocking (hash, difficulty4));
2499  	request.put ("work", nano::to_string_hex (work3));
2500  	{
2501  		auto response (wait_response (system, rpc_ctx, request));
2502  		ASSERT_TRUE (response.get<bool> ("valid"));
2503  		ASSERT_TRUE (response.get<bool> ("valid_all"));
2504  		ASSERT_TRUE (response.get<bool> ("valid_receive"));
2505  	}
2506  }
2507  TEST (rpc, work_validate_epoch_2)
2508  {
2509  	nano::test::system system;
2510  	auto node = add_ipc_enabled_node (system);
2511  	auto epoch1 = system.upgrade_genesis_epoch (*node, nano::epoch::epoch_1);
2512  	ASSERT_NE (nullptr, epoch1);
2513  	ASSERT_EQ (node->network_params.work.epoch_2, node->network_params.work.base);
2514  	auto work = system.work_generate_limited (epoch1->hash (), node->network_params.work.epoch_1, node->network_params.work.base);
2515  	auto const rpc_ctx = add_rpc (system, node);
2516  	boost::property_tree::ptree request;
2517  	request.put ("action", "work_validate");
2518  	request.put ("hash", epoch1->hash ().to_string ());
2519  	request.put ("work", nano::to_string_hex (work));
2520  	{
2521  		auto response (wait_response (system, rpc_ctx, request));
2522  		ASSERT_EQ (0, response.count ("valid"));
2523  		ASSERT_FALSE (response.get<bool> ("valid_all"));
2524  		ASSERT_TRUE (response.get<bool> ("valid_receive"));
2525  		std::string difficulty_text (response.get<std::string> ("difficulty"));
2526  		uint64_t difficulty{ 0 };
2527  		ASSERT_FALSE (nano::from_string_hex (difficulty_text, difficulty));
2528  		double multiplier (response.get<double> ("multiplier"));
2529  		ASSERT_NEAR (multiplier, nano::difficulty::to_multiplier (difficulty, node->network_params.work.epoch_2), 1e-6);
2530  	};
2531  	ASSERT_NE (nullptr, system.upgrade_genesis_epoch (*node, nano::epoch::epoch_2));
2532  	{
2533  		auto response (wait_response (system, rpc_ctx, request));
2534  		ASSERT_EQ (0, response.count ("valid"));
2535  		ASSERT_FALSE (response.get<bool> ("valid_all"));
2536  		ASSERT_TRUE (response.get<bool> ("valid_receive"));
2537  		std::string difficulty_text (response.get<std::string> ("difficulty"));
2538  		uint64_t difficulty{ 0 };
2539  		ASSERT_FALSE (nano::from_string_hex (difficulty_text, difficulty));
2540  		double multiplier (response.get<double> ("multiplier"));
2541  		ASSERT_NEAR (multiplier, nano::difficulty::to_multiplier (difficulty, node->default_difficulty (nano::work_version::work_1)), 1e-6);
2542  	};
2543  }
2544  TEST (rpc, successors)
2545  {
2546  	nano::test::system system;
2547  	auto node = add_ipc_enabled_node (system);
2548  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
2549  	nano::keypair key;
2550  	auto genesis (node->latest (nano::dev::genesis_key.pub));
2551  	ASSERT_FALSE (genesis.is_zero ());
2552  	auto block (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key.pub, 1));
2553  	ASSERT_NE (nullptr, block);
2554  	auto const rpc_ctx = add_rpc (system, node);
2555  	boost::property_tree::ptree request;
2556  	request.put ("action", "successors");
2557  	request.put ("block", genesis.to_string ());
2558  	request.put ("count", std::to_string (std::numeric_limits<uint64_t>::max ()));
2559  	auto response (wait_response (system, rpc_ctx, request));
2560  	auto & blocks_node (response.get_child ("blocks"));
2561  	std::vector<nano::block_hash> blocks;
2562  	for (auto i (blocks_node.begin ()), n (blocks_node.end ()); i != n; ++i)
2563  	{
2564  		blocks.push_back (nano::block_hash (i->second.get<std::string> ("")));
2565  	}
2566  	ASSERT_EQ (2, blocks.size ());
2567  	ASSERT_EQ (genesis, blocks[0]);
2568  	ASSERT_EQ (block->hash (), blocks[1]);
2569  	request.put ("action", "chain");
2570  	request.put ("reverse", "true");
2571  	auto response2 (wait_response (system, rpc_ctx, request, 10s));
2572  	ASSERT_EQ (response, response2);
2573  }
2574  TEST (rpc, bootstrap_any)
2575  {
2576  	nano::test::system system0;
2577  	auto node = add_ipc_enabled_node (system0);
2578  	nano::test::system system1 (1);
2579  	auto latest (system1.nodes[0]->latest (nano::dev::genesis_key.pub));
2580  	nano::block_builder builder;
2581  	auto send = builder
2582  				.send ()
2583  				.previous (latest)
2584  				.destination (nano::dev::genesis->account ())
2585  				.balance (100)
2586  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2587  				.work (*system1.nodes[0]->work_generate_blocking (latest))
2588  				.build ();
2589  	{
2590  		auto transaction (system1.nodes[0]->store.tx_begin_write ());
2591  		ASSERT_EQ (nano::process_result::progress, system1.nodes[0]->ledger.process (transaction, *send).code);
2592  	}
2593  	auto const rpc_ctx = add_rpc (system0, node);
2594  	boost::property_tree::ptree request;
2595  	request.put ("action", "bootstrap_any");
2596  	auto response (wait_response (system0, rpc_ctx, request));
2597  	std::string success (response.get<std::string> ("success"));
2598  	ASSERT_TRUE (success.empty ());
2599  }
2600  TEST (rpc, republish)
2601  {
2602  	nano::test::system system;
2603  	nano::keypair key;
2604  	auto node1 = add_ipc_enabled_node (system);
2605  	system.add_node ();
2606  	auto latest (node1->latest (nano::dev::genesis_key.pub));
2607  	nano::block_builder builder;
2608  	auto send = builder
2609  				.send ()
2610  				.previous (latest)
2611  				.destination (key.pub)
2612  				.balance (100)
2613  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2614  				.work (*node1->work_generate_blocking (latest))
2615  				.build ();
2616  	ASSERT_EQ (nano::process_result::progress, node1->process (*send).code);
2617  	auto open = builder
2618  				.open ()
2619  				.source (send->hash ())
2620  				.representative (key.pub)
2621  				.account (key.pub)
2622  				.sign (key.prv, key.pub)
2623  				.work (*node1->work_generate_blocking (key.pub))
2624  				.build ();
2625  	ASSERT_EQ (nano::process_result::progress, node1->process (*open).code);
2626  	auto const rpc_ctx = add_rpc (system, node1);
2627  	boost::property_tree::ptree request;
2628  	request.put ("action", "republish");
2629  	request.put ("hash", send->hash ().to_string ());
2630  	auto response (wait_response (system, rpc_ctx, request));
2631  	ASSERT_TIMELY (10s, system.nodes[1]->balance (nano::dev::genesis_key.pub) != nano::dev::constants.genesis_amount);
2632  	auto & blocks_node (response.get_child ("blocks"));
2633  	std::vector<nano::block_hash> blocks;
2634  	for (auto i (blocks_node.begin ()), n (blocks_node.end ()); i != n; ++i)
2635  	{
2636  		blocks.push_back (nano::block_hash (i->second.get<std::string> ("")));
2637  	}
2638  	ASSERT_EQ (1, blocks.size ());
2639  	ASSERT_EQ (send->hash (), blocks[0]);
2640  	request.put ("hash", nano::dev::genesis->hash ().to_string ());
2641  	request.put ("count", 1);
2642  	auto response1 (wait_response (system, rpc_ctx, request));
2643  	blocks_node = response1.get_child ("blocks");
2644  	blocks.clear ();
2645  	for (auto i (blocks_node.begin ()), n (blocks_node.end ()); i != n; ++i)
2646  	{
2647  		blocks.push_back (nano::block_hash (i->second.get<std::string> ("")));
2648  	}
2649  	ASSERT_EQ (1, blocks.size ());
2650  	ASSERT_EQ (nano::dev::genesis->hash (), blocks[0]);
2651  	request.put ("hash", open->hash ().to_string ());
2652  	request.put ("sources", 2);
2653  	auto response2 (wait_response (system, rpc_ctx, request));
2654  	blocks_node = response2.get_child ("blocks");
2655  	blocks.clear ();
2656  	for (auto i (blocks_node.begin ()), n (blocks_node.end ()); i != n; ++i)
2657  	{
2658  		blocks.push_back (nano::block_hash (i->second.get<std::string> ("")));
2659  	}
2660  	ASSERT_EQ (3, blocks.size ());
2661  	ASSERT_EQ (nano::dev::genesis->hash (), blocks[0]);
2662  	ASSERT_EQ (send->hash (), blocks[1]);
2663  	ASSERT_EQ (open->hash (), blocks[2]);
2664  }
2665  TEST (rpc, deterministic_key)
2666  {
2667  	nano::test::system system0;
2668  	auto node = add_ipc_enabled_node (system0);
2669  	nano::raw_key seed;
2670  	{
2671  		auto transaction (system0.nodes[0]->wallets.tx_begin_read ());
2672  		system0.wallet (0)->store.seed (seed, transaction);
2673  	}
2674  	nano::account account0 (system0.wallet (0)->deterministic_insert ());
2675  	nano::account account1 (system0.wallet (0)->deterministic_insert ());
2676  	nano::account account2 (system0.wallet (0)->deterministic_insert ());
2677  	auto const rpc_ctx = add_rpc (system0, node);
2678  	boost::property_tree::ptree request;
2679  	request.put ("action", "deterministic_key");
2680  	request.put ("seed", seed.to_string ());
2681  	request.put ("index", "0");
2682  	auto response0 (wait_response (system0, rpc_ctx, request));
2683  	std::string validate_text (response0.get<std::string> ("account"));
2684  	ASSERT_EQ (account0.to_account (), validate_text);
2685  	request.put ("index", "2");
2686  	auto response1 (wait_response (system0, rpc_ctx, request));
2687  	validate_text = response1.get<std::string> ("account");
2688  	ASSERT_NE (account1.to_account (), validate_text);
2689  	ASSERT_EQ (account2.to_account (), validate_text);
2690  }
2691  TEST (rpc, accounts_balances)
2692  {
2693  	nano::test::system system;
2694  	auto node = add_ipc_enabled_node (system);
2695  	auto const rpc_ctx = add_rpc (system, node);
2696  	boost::property_tree::ptree request;
2697  	request.put ("action", "accounts_balances");
2698  	boost::property_tree::ptree accounts_l;
2699  	boost::property_tree::ptree entry1;
2700  	entry1.put ("", nano::dev::genesis_key.pub.to_account ());
2701  	accounts_l.push_back (std::make_pair ("", entry1));
2702  	boost::property_tree::ptree entry2;
2703  	auto const account_not_found = "nano_1os6txqxyuesnxrtshnfb5or1hesc1647wpk9rsr84pmki6eairwha79hk3j";
2704  	entry2.put ("", account_not_found);
2705  	accounts_l.push_back (std::make_pair ("", entry2));
2706  	request.add_child ("accounts", accounts_l);
2707  	auto response (wait_response (system, rpc_ctx, request));
2708  	auto genesis_entry = response.get_child (boost::str (boost::format ("balances.%1%") % nano::dev::genesis_key.pub.to_account ()));
2709  	auto balance_text = genesis_entry.get<std::string> ("balance");
2710  	ASSERT_EQ ("340282366920938463463374607431768211455", balance_text);
2711  	auto receivable_text = genesis_entry.get<std::string> ("receivable");
2712  	ASSERT_EQ ("0", receivable_text);
2713  	auto account_not_found_entry = response.get_child (boost::str (boost::format ("balances.%1%") % account_not_found));
2714  	auto account_balance_text = account_not_found_entry.get<std::string> ("balance");
2715  	ASSERT_EQ ("0", account_balance_text);
2716  	auto account_receivable_text = account_not_found_entry.get<std::string> ("receivable");
2717  	ASSERT_EQ ("0", account_receivable_text);
2718  	auto balances = response.get_child ("balances");
2719  	ASSERT_EQ (2, balances.size ());
2720  	auto errors = response.get_child_optional ("errors");
2721  	ASSERT_FALSE (errors.has_value ());
2722  }
2723  TEST (rpc, accounts_balances_with_errors)
2724  {
2725  	nano::test::system system;
2726  	auto node = add_ipc_enabled_node (system);
2727  	auto const rpc_ctx = add_rpc (system, node);
2728  	boost::property_tree::ptree request;
2729  	request.put ("action", "accounts_balances");
2730  	boost::property_tree::ptree accounts_l;
2731  	boost::property_tree::ptree entry;
2732  	auto const bad_account_number = "nano_3e3j5tkog48pnny9dmfzj1r16pg8t1e76dz5tmac6iq689wyjfpiij4txtd1";
2733  	entry.put ("", bad_account_number);
2734  	accounts_l.push_back (std::make_pair ("", entry));
2735  	request.add_child ("accounts", accounts_l);
2736  	auto response (wait_response (system, rpc_ctx, request));
2737  	auto balances = response.get_child_optional ("balances");
2738  	ASSERT_FALSE (balances.has_value ());
2739  	auto get_error_message = [] (nano::error_common error_common) -> std::string {
2740  		std::error_code ec = error_common;
2741  		return ec.message ();
2742  	};
2743  	auto errors = response.get_child ("errors");
2744  	ASSERT_EQ (1, errors.size ());
2745  	ASSERT_EQ (1, errors.count (bad_account_number));
2746  	auto bad_account_number_error_text = errors.get<std::string> (bad_account_number);
2747  	ASSERT_EQ (get_error_message (nano::error_common::bad_account_number), bad_account_number_error_text);
2748  }
2749  TEST (rpc, accounts_balances_unopened_account_with_receivables)
2750  {
2751  	nano::test::system system;
2752  	nano::node_config config;
2753  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
2754  	auto node = add_ipc_enabled_node (system, config);
2755  	nano::keypair unopened_account;
2756  	auto send = nano::state_block_builder{}
2757  				.account (nano::dev::genesis_key.pub)
2758  				.previous (nano::dev::genesis->hash ())
2759  				.representative (nano::dev::genesis_key.pub)
2760  				.balance (nano::dev::constants.genesis_amount - 1)
2761  				.link (unopened_account.pub)
2762  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2763  				.work (*node->work_generate_blocking (nano::dev::genesis->hash ()))
2764  				.build_shared ();
2765  	{
2766  		auto transaction = node->store.tx_begin_write ();
2767  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *send).code);
2768  	}
2769  	ASSERT_TIMELY (5s, node->block (send->hash ()));
2770  	ASSERT_TIMELY (5s, !node->active.active (*send));
2771  	auto const rpc_ctx = add_rpc (system, node);
2772  	boost::property_tree::ptree request;
2773  	boost::property_tree::ptree accounts_l;
2774  	boost::property_tree::ptree entry;
2775  	entry.put ("", unopened_account.pub.to_account ());
2776  	accounts_l.push_back (std::make_pair ("", entry));
2777  	request.add_child ("accounts", accounts_l);
2778  	request.put ("action", "accounts_balances");
2779  	auto response = wait_response (system, rpc_ctx, request);
2780  	auto response_entry = response.get_child ("balances." + unopened_account.pub.to_account ());
2781  	ASSERT_EQ ("0", response_entry.get<std::string> ("balance"));
2782  	ASSERT_EQ ("0", response_entry.get<std::string> ("receivable"));
2783  	request.put ("include_only_confirmed", "false");
2784  	response = wait_response (system, rpc_ctx, request);
2785  	response_entry = response.get_child ("balances." + unopened_account.pub.to_account ());
2786  	ASSERT_EQ ("0", response_entry.get<std::string> ("balance"));
2787  	ASSERT_EQ ("1", response_entry.get<std::string> ("receivable"));
2788  	request.put ("include_only_confirmed", "true");
2789  	response = wait_response (system, rpc_ctx, request);
2790  	response_entry = response.get_child ("balances." + unopened_account.pub.to_account ());
2791  	ASSERT_EQ ("0", response_entry.get<std::string> ("balance"));
2792  	ASSERT_EQ ("0", response_entry.get<std::string> ("receivable"));
2793  }
2794  TEST (rpc, accounts_representatives)
2795  {
2796  	nano::test::system system;
2797  	auto node = add_ipc_enabled_node (system);
2798  	auto const rpc_ctx = add_rpc (system, node);
2799  	boost::property_tree::ptree request;
2800  	request.put ("action", "accounts_representatives");
2801  	boost::property_tree::ptree entry;
2802  	boost::property_tree::ptree accounts;
2803  	entry.put ("", nano::dev::genesis_key.pub.to_account ());
2804  	accounts.push_back (std::make_pair ("", entry));
2805  	request.add_child ("accounts", accounts);
2806  	auto response (wait_response (system, rpc_ctx, request));
2807  	auto response_representative (response.get_child ("representatives").get<std::string> (nano::dev::genesis->account ().to_account ()));
2808  	ASSERT_EQ (response_representative, nano::dev::genesis->account ().to_account ());
2809  	ASSERT_EQ (response.count ("errors"), 0);
2810  }
2811  TEST (rpc, accounts_representatives_with_errors)
2812  {
2813  	nano::test::system system;
2814  	auto node = add_ipc_enabled_node (system);
2815  	auto const rpc_ctx = add_rpc (system, node);
2816  	boost::property_tree::ptree request;
2817  	request.put ("action", "accounts_representatives");
2818  	boost::property_tree::ptree entry1, entry2, entry3;
2819  	boost::property_tree::ptree accounts_l;
2820  	entry1.put ("", nano::dev::genesis_key.pub.to_account ());
2821  	accounts_l.push_back (std::make_pair ("", entry1));
2822  	auto const bad_account_number = "nano_36uccgpjzhjsdbj44wm1y5hyz8gefx3wjpp1jircxt84nopxkxti5bzq1rnz";
2823  	entry2.put ("", bad_account_number);
2824  	accounts_l.push_back (std::make_pair ("", entry2));
2825  	auto const account_not_found = "nano_1hrts7hcoozxccnffoq9hqhngnn9jz783usapejm57ejtqcyz9dpso1bibuy";
2826  	entry3.put ("", account_not_found);
2827  	accounts_l.push_back (std::make_pair ("", entry3));
2828  	request.add_child ("accounts", accounts_l);
2829  	auto response (wait_response (system, rpc_ctx, request));
2830  	ASSERT_EQ (response.count ("representatives"), 1);
2831  	ASSERT_EQ (response.get_child ("representatives").size (), 1);
2832  	ASSERT_EQ (response.get_child ("representatives").count (nano::dev::genesis_key.pub.to_account ()), 1);
2833  	auto rep_text = response.get_child ("representatives").get<std::string> (nano::dev::genesis_key.pub.to_account ());
2834  	ASSERT_EQ (rep_text, nano::dev::genesis->account ().to_account ());
2835  	ASSERT_EQ (response.count ("errors"), 1);
2836  	ASSERT_EQ (response.get_child ("errors").size (), 2);
2837  	ASSERT_EQ (response.get_child ("errors").count (bad_account_number), 1);
2838  	ASSERT_EQ (response.get_child ("errors").count (account_not_found), 1);
2839  	ASSERT_EQ (response.get_child ("errors").get<std::string> (bad_account_number), make_error_code (nano::error_common::bad_account_number).message ());
2840  	ASSERT_EQ (response.get_child ("errors").get<std::string> (account_not_found), make_error_code (nano::error_common::account_not_found).message ());
2841  }
2842  TEST (rpc, accounts_frontiers)
2843  {
2844  	nano::test::system system;
2845  	auto node = add_ipc_enabled_node (system);
2846  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
2847  	auto const rpc_ctx = add_rpc (system, node);
2848  	boost::property_tree::ptree request;
2849  	request.put ("action", "accounts_frontiers");
2850  	boost::property_tree::ptree accounts_l;
2851  	boost::property_tree::ptree entry1;
2852  	entry1.put ("", nano::dev::genesis_key.pub.to_account ());
2853  	accounts_l.push_back (std::make_pair ("", entry1));
2854  	request.add_child ("accounts", accounts_l);
2855  	auto response (wait_response (system, rpc_ctx, request));
2856  	ASSERT_EQ (response.count ("frontiers"), 1);
2857  	ASSERT_EQ (response.get_child ("frontiers").size (), 1);
2858  	ASSERT_EQ (response.get_child ("frontiers").count (nano::dev::genesis_key.pub.to_account ()), 1);
2859  	auto frontier_text = response.get_child ("frontiers").get<std::string> (nano::dev::genesis_key.pub.to_account ());
2860  	ASSERT_EQ (nano::block_hash{ frontier_text }, node->latest (nano::dev::genesis->account ()));
2861  	ASSERT_EQ (response.count ("errors"), 0);
2862  }
2863  TEST (rpc, accounts_frontiers_with_errors)
2864  {
2865  	nano::test::system system;
2866  	auto node = add_ipc_enabled_node (system);
2867  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
2868  	auto const rpc_ctx = add_rpc (system, node);
2869  	boost::property_tree::ptree request;
2870  	request.put ("action", "accounts_frontiers");
2871  	boost::property_tree::ptree accounts_l;
2872  	boost::property_tree::ptree entry1;
2873  	entry1.put ("", nano::dev::genesis_key.pub.to_account ());
2874  	accounts_l.push_back (std::make_pair ("", entry1));
2875  	boost::property_tree::ptree entry2;
2876  	auto const bad_account_number = "nano_3e3j5tkog48pnny9dmfzj1r16pg8t1e76dz5tmac6iq689wyjfpiij4txtd1";
2877  	entry2.put ("", bad_account_number);
2878  	accounts_l.push_back (std::make_pair ("", entry2));
2879  	boost::property_tree::ptree entry3;
2880  	auto const account_not_found = "nano_1os6txqxyuesnxrtshnfb5or1hesc1647wpk9rsr84pmki6eairwha79hk3j";
2881  	entry3.put ("", account_not_found);
2882  	accounts_l.push_back (std::make_pair ("", entry3));
2883  	request.add_child ("accounts", accounts_l);
2884  	auto response (wait_response (system, rpc_ctx, request));
2885  	ASSERT_EQ (response.count ("frontiers"), 1);
2886  	ASSERT_EQ (response.get_child ("frontiers").size (), 1);
2887  	ASSERT_EQ (response.get_child ("frontiers").count (nano::dev::genesis_key.pub.to_account ()), 1);
2888  	auto frontier_text = response.get_child ("frontiers").get<std::string> (nano::dev::genesis_key.pub.to_account ());
2889  	ASSERT_EQ (nano::block_hash{ frontier_text }, node->latest (nano::dev::genesis->account ()));
2890  	ASSERT_EQ (response.count ("errors"), 1);
2891  	ASSERT_EQ (response.get_child ("errors").size (), 2);
2892  	ASSERT_EQ (response.get_child ("errors").count (bad_account_number), 1);
2893  	ASSERT_EQ (response.get_child ("errors").count (account_not_found), 1);
2894  	ASSERT_EQ (response.get_child ("errors").get<std::string> (bad_account_number), make_error_code (nano::error_common::bad_account_number).message ());
2895  	ASSERT_EQ (response.get_child ("errors").get<std::string> (account_not_found), make_error_code (nano::error_common::account_not_found).message ());
2896  }
2897  TEST (rpc, blocks)
2898  {
2899  	nano::test::system system;
2900  	auto node = add_ipc_enabled_node (system);
2901  	auto const rpc_ctx = add_rpc (system, node);
2902  	boost::property_tree::ptree request;
2903  	request.put ("action", "blocks");
2904  	boost::property_tree::ptree entry;
2905  	boost::property_tree::ptree peers_l;
2906  	entry.put ("", node->latest (nano::dev::genesis->account ()).to_string ());
2907  	peers_l.push_back (std::make_pair ("", entry));
2908  	request.add_child ("hashes", peers_l);
2909  	auto response (wait_response (system, rpc_ctx, request));
2910  	for (auto & blocks : response.get_child ("blocks"))
2911  	{
2912  		std::string hash_text (blocks.first);
2913  		ASSERT_EQ (node->latest (nano::dev::genesis->account ()).to_string (), hash_text);
2914  		std::string blocks_text (blocks.second.get<std::string> (""));
2915  		ASSERT_FALSE (blocks_text.empty ());
2916  	}
2917  }
2918  TEST (rpc, wallet_info)
2919  {
2920  	nano::test::system system;
2921  	nano::node_config node_config = system.default_config ();
2922  	node_config.enable_voting = true;
2923  	auto node = add_ipc_enabled_node (system, node_config);
2924  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
2925  	nano::keypair key;
2926  	system.wallet (0)->insert_adhoc (key.prv);
2927  	auto send (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key.pub, nano::Gxrb_ratio));
2928  	ASSERT_TIMELY (5s, node->block_confirmed (send->hash ())); 
2929  	ASSERT_TIMELY (5s, !node->latest (key.pub).is_zero ()); 
2930  	ASSERT_TIMELY (5s, node->block_confirmed (node->latest (key.pub))); 
2931  	auto send2 (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key.pub, 1));
2932  	ASSERT_TIMELY (5s, node->block_confirmed (send2->hash ()));
2933  	nano::account account (system.wallet (0)->deterministic_insert ());
2934  	{
2935  		auto transaction (node->wallets.tx_begin_write ());
2936  		system.wallet (0)->store.erase (transaction, account);
2937  	}
2938  	account = system.wallet (0)->deterministic_insert ();
2939  	auto const rpc_ctx = add_rpc (system, node);
2940  	boost::property_tree::ptree request;
2941  	request.put ("action", "wallet_info");
2942  	request.put ("wallet", node->wallets.items.begin ()->first.to_string ());
2943  	auto response (wait_response (system, rpc_ctx, request));
2944  	std::string balance_text (response.get<std::string> ("balance"));
2945  	ASSERT_EQ ("340282366920938463463374607431768211454", balance_text);
2946  	std::string pending_text (response.get<std::string> ("pending"));
2947  	ASSERT_EQ ("1", pending_text);
2948  	std::string count_text (response.get<std::string> ("accounts_count"));
2949  	ASSERT_EQ ("3", count_text);
2950  	std::string block_count_text (response.get<std::string> ("accounts_block_count"));
2951  	ASSERT_EQ ("4", block_count_text);
2952  	std::string cemented_block_count_text (response.get<std::string> ("accounts_cemented_block_count"));
2953  	ASSERT_EQ ("4", cemented_block_count_text);
2954  	std::string adhoc_count (response.get<std::string> ("adhoc_count"));
2955  	ASSERT_EQ ("2", adhoc_count);
2956  	std::string deterministic_count (response.get<std::string> ("deterministic_count"));
2957  	ASSERT_EQ ("1", deterministic_count);
2958  	std::string index_text (response.get<std::string> ("deterministic_index"));
2959  	ASSERT_EQ ("2", index_text);
2960  }
2961  TEST (rpc, wallet_balances)
2962  {
2963  	nano::test::system system0;
2964  	auto node = add_ipc_enabled_node (system0);
2965  	system0.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
2966  	auto const rpc_ctx = add_rpc (system0, node);
2967  	boost::property_tree::ptree request;
2968  	request.put ("action", "wallet_balances");
2969  	request.put ("wallet", node->wallets.items.begin ()->first.to_string ());
2970  	auto response (wait_response (system0, rpc_ctx, request));
2971  	for (auto & balances : response.get_child ("balances"))
2972  	{
2973  		std::string account_text (balances.first);
2974  		ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), account_text);
2975  		std::string balance_text (balances.second.get<std::string> ("balance"));
2976  		ASSERT_EQ ("340282366920938463463374607431768211455", balance_text);
2977  		std::string pending_text (balances.second.get<std::string> ("pending"));
2978  		ASSERT_EQ ("0", pending_text);
2979  	}
2980  	nano::keypair key;
2981  	system0.wallet (0)->insert_adhoc (key.prv);
2982  	auto send (system0.wallet (0)->send_action (nano::dev::genesis_key.pub, key.pub, 1));
2983  	request.put ("threshold", "2");
2984  	auto response1 (wait_response (system0, rpc_ctx, request));
2985  	for (auto & balances : response1.get_child ("balances"))
2986  	{
2987  		std::string account_text (balances.first);
2988  		ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), account_text);
2989  		std::string balance_text (balances.second.get<std::string> ("balance"));
2990  		ASSERT_EQ ("340282366920938463463374607431768211454", balance_text);
2991  		std::string pending_text (balances.second.get<std::string> ("pending"));
2992  		ASSERT_EQ ("0", pending_text);
2993  	}
2994  }
2995  TEST (rpc, pending_exists)
2996  {
2997  	nano::test::system system;
2998  	nano::node_config config;
2999  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
3000  	auto node = add_ipc_enabled_node (system, config);
3001  	nano::keypair key1;
3002  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
3003  	auto hash0 (node->latest (nano::dev::genesis->account ()));
3004  	auto block1 (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key1.pub, 100));
3005  	ASSERT_TIMELY (5s, node->block_confirmed (block1->hash ()));
3006  	ASSERT_TIMELY (5s, !node->active.active (*block1));
3007  	auto const rpc_ctx = add_rpc (system, node);
3008  	boost::property_tree::ptree request;
3009  	auto pending_exists = [&system, &rpc_ctx, &request] (char const * exists_a) {
3010  		auto response0 (wait_response (system, rpc_ctx, request));
3011  		std::string exists_text (response0.get<std::string> ("exists"));
3012  		return exists_a == exists_text;
3013  	};
3014  	request.put ("action", "pending_exists");
3015  	request.put ("hash", hash0.to_string ());
3016  	ASSERT_TRUE (pending_exists ("0"));
3017  	node->store.pending.exists (node->store.tx_begin_read (), nano::pending_key (nano::dev::genesis_key.pub, block1->hash ()));
3018  	request.put ("hash", block1->hash ().to_string ());
3019  	ASSERT_TRUE (pending_exists ("1"));
3020  	ASSERT_TRUE (pending_exists ("1"));
3021  	reset_confirmation_height (node->store, block1->account ());
3022  	ASSERT_TRUE (pending_exists ("0"));
3023  	request.put ("include_only_confirmed", "false");
3024  	ASSERT_TRUE (pending_exists ("1"));
3025  }
3026  TEST (rpc, wallet_pending)
3027  {
3028  	nano::test::system system;
3029  	auto node = add_ipc_enabled_node (system);
3030  	nano::keypair key1;
3031  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
3032  	system.wallet (0)->insert_adhoc (key1.prv);
3033  	auto block1 = system.wallet (0)->send_action (nano::dev::genesis_key.pub, key1.pub, 100);
3034  	ASSERT_TIMELY (5s, node->get_confirmation_height (node->store.tx_begin_read (), nano::dev::genesis_key.pub) == 2);
3035  	auto const rpc_ctx = add_rpc (system, node);
3036  	boost::property_tree::ptree request;
3037  	request.put ("action", "wallet_pending");
3038  	request.put ("wallet", node->wallets.items.begin ()->first.to_string ());
3039  	auto response (wait_response (system, rpc_ctx, request));
3040  	ASSERT_EQ ("1", response.get<std::string> ("deprecated"));
3041  	ASSERT_EQ (1, response.get_child ("blocks").size ());
3042  	auto pending = response.get_child ("blocks").front ();
3043  	ASSERT_EQ (key1.pub.to_account (), pending.first);
3044  	nano::block_hash hash1{ pending.second.begin ()->second.get<std::string> ("") };
3045  	ASSERT_EQ (block1->hash (), hash1);
3046  }
3047  TEST (rpc, wallet_receivable)
3048  {
3049  	nano::test::system system;
3050  	nano::node_config config;
3051  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
3052  	auto node = add_ipc_enabled_node (system, config);
3053  	nano::keypair key1;
3054  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
3055  	system.wallet (0)->insert_adhoc (key1.prv);
3056  	auto iterations (0);
3057  	auto block1 (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key1.pub, 100));
3058  	ASSERT_TIMELY (5s, node->block_confirmed (block1->hash ()));
3059  	ASSERT_TIMELY (5s, !node->active.active (*block1));
3060  	auto const rpc_ctx = add_rpc (system, node);
3061  	boost::property_tree::ptree request;
3062  	request.put ("action", "wallet_receivable");
3063  	request.put ("wallet", node->wallets.items.begin ()->first.to_string ());
3064  	request.put ("count", "100");
3065  	auto response (wait_response (system, rpc_ctx, request));
3066  	ASSERT_EQ (1, response.get_child ("blocks").size ());
3067  	for (auto & pending : response.get_child ("blocks"))
3068  	{
3069  		std::string account_text (pending.first);
3070  		ASSERT_EQ (key1.pub.to_account (), account_text);
3071  		nano::block_hash hash1 (pending.second.begin ()->second.get<std::string> (""));
3072  		ASSERT_EQ (block1->hash (), hash1);
3073  	}
3074  	request.put ("threshold", "100"); 
3075  	auto response0 (wait_response (system, rpc_ctx, request));
3076  	std::unordered_map<nano::block_hash, nano::uint128_union> blocks;
3077  	ASSERT_EQ (1, response0.get_child ("blocks").size ());
3078  	for (auto & pending : response0.get_child ("blocks"))
3079  	{
3080  		std::string account_text (pending.first);
3081  		ASSERT_EQ (key1.pub.to_account (), account_text);
3082  		for (auto i (pending.second.begin ()), j (pending.second.end ()); i != j; ++i)
3083  		{
3084  			nano::block_hash hash;
3085  			hash.decode_hex (i->first);
3086  			nano::uint128_union amount;
3087  			amount.decode_dec (i->second.get<std::string> (""));
3088  			blocks[hash] = amount;
3089  			boost::optional<std::string> source (i->second.get_optional<std::string> ("source"));
3090  			ASSERT_FALSE (source.is_initialized ());
3091  			boost::optional<uint8_t> min_version (i->second.get_optional<uint8_t> ("min_version"));
3092  			ASSERT_FALSE (min_version.is_initialized ());
3093  		}
3094  	}
3095  	ASSERT_EQ (blocks[block1->hash ()], 100);
3096  	request.put ("threshold", "101");
3097  	auto response1 (wait_response (system, rpc_ctx, request));
3098  	auto & pending1 (response1.get_child ("blocks"));
3099  	ASSERT_EQ (0, pending1.size ());
3100  	request.put ("threshold", "0");
3101  	request.put ("source", "true");
3102  	request.put ("min_version", "true");
3103  	auto response2 (wait_response (system, rpc_ctx, request));
3104  	std::unordered_map<nano::block_hash, nano::uint128_union> amounts;
3105  	std::unordered_map<nano::block_hash, nano::account> sources;
3106  	ASSERT_EQ (1, response2.get_child ("blocks").size ());
3107  	for (auto & pending : response2.get_child ("blocks"))
3108  	{
3109  		std::string account_text (pending.first);
3110  		ASSERT_EQ (key1.pub.to_account (), account_text);
3111  		for (auto i (pending.second.begin ()), j (pending.second.end ()); i != j; ++i)
3112  		{
3113  			nano::block_hash hash;
3114  			hash.decode_hex (i->first);
3115  			amounts[hash].decode_dec (i->second.get<std::string> ("amount"));
3116  			sources[hash].decode_account (i->second.get<std::string> ("source"));
3117  			ASSERT_EQ (i->second.get<uint8_t> ("min_version"), 0);
3118  		}
3119  	}
3120  	ASSERT_EQ (amounts[block1->hash ()], 100);
3121  	ASSERT_EQ (sources[block1->hash ()], nano::dev::genesis_key.pub);
3122  	ASSERT_TRUE (check_block_response_count (system, rpc_ctx, request, 1));
3123  	reset_confirmation_height (system.nodes.front ()->store, block1->account ());
3124  	ASSERT_TRUE (check_block_response_count (system, rpc_ctx, request, 0));
3125  	request.put ("include_only_confirmed", "false");
3126  	ASSERT_TRUE (check_block_response_count (system, rpc_ctx, request, 1));
3127  }
3128  TEST (rpc, receive_minimum)
3129  {
3130  	nano::test::system system;
3131  	auto node = add_ipc_enabled_node (system);
3132  	auto const rpc_ctx = add_rpc (system, node);
3133  	boost::property_tree::ptree request;
3134  	request.put ("action", "receive_minimum");
3135  	auto response (wait_response (system, rpc_ctx, request));
3136  	std::string amount (response.get<std::string> ("amount"));
3137  	ASSERT_EQ (node->config.receive_minimum.to_string_dec (), amount);
3138  }
3139  TEST (rpc, receive_minimum_set)
3140  {
3141  	nano::test::system system;
3142  	auto node = add_ipc_enabled_node (system);
3143  	auto const rpc_ctx = add_rpc (system, node);
3144  	boost::property_tree::ptree request;
3145  	request.put ("action", "receive_minimum_set");
3146  	request.put ("amount", "100");
3147  	ASSERT_NE (node->config.receive_minimum.to_string_dec (), "100");
3148  	auto response (wait_response (system, rpc_ctx, request));
3149  	std::string success (response.get<std::string> ("success"));
3150  	ASSERT_TRUE (success.empty ());
3151  	ASSERT_EQ (node->config.receive_minimum.to_string_dec (), "100");
3152  }
3153  TEST (rpc, work_get)
3154  {
3155  	nano::test::system system;
3156  	auto node = add_ipc_enabled_node (system);
3157  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
3158  	system.wallet (0)->work_cache_blocking (nano::dev::genesis_key.pub, node->latest (nano::dev::genesis_key.pub));
3159  	auto const rpc_ctx = add_rpc (system, node);
3160  	boost::property_tree::ptree request;
3161  	request.put ("action", "work_get");
3162  	request.put ("wallet", node->wallets.items.begin ()->first.to_string ());
3163  	request.put ("account", nano::dev::genesis_key.pub.to_account ());
3164  	auto response (wait_response (system, rpc_ctx, request));
3165  	std::string work_text (response.get<std::string> ("work"));
3166  	uint64_t work (1);
3167  	auto transaction (node->wallets.tx_begin_read ());
3168  	node->wallets.items.begin ()->second->store.work_get (transaction, nano::dev::genesis->account (), work);
3169  	ASSERT_EQ (nano::to_string_hex (work), work_text);
3170  }
3171  TEST (rpc, wallet_work_get)
3172  {
3173  	nano::test::system system;
3174  	auto node = add_ipc_enabled_node (system);
3175  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
3176  	system.wallet (0)->work_cache_blocking (nano::dev::genesis_key.pub, node->latest (nano::dev::genesis_key.pub));
3177  	auto const rpc_ctx = add_rpc (system, node);
3178  	boost::property_tree::ptree request;
3179  	request.put ("action", "wallet_work_get");
3180  	request.put ("wallet", node->wallets.items.begin ()->first.to_string ());
3181  	auto response (wait_response (system, rpc_ctx, request));
3182  	auto transaction (node->wallets.tx_begin_read ());
3183  	for (auto & works : response.get_child ("works"))
3184  	{
3185  		std::string account_text (works.first);
3186  		ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), account_text);
3187  		std::string work_text (works.second.get<std::string> (""));
3188  		uint64_t work (1);
3189  		node->wallets.items.begin ()->second->store.work_get (transaction, nano::dev::genesis->account (), work);
3190  		ASSERT_EQ (nano::to_string_hex (work), work_text);
3191  	}
3192  }
3193  TEST (rpc, work_set)
3194  {
3195  	nano::test::system system;
3196  	auto node = add_ipc_enabled_node (system);
3197  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
3198  	auto const rpc_ctx = add_rpc (system, node);
3199  	uint64_t work0 (100);
3200  	boost::property_tree::ptree request;
3201  	request.put ("action", "work_set");
3202  	request.put ("wallet", node->wallets.items.begin ()->first.to_string ());
3203  	request.put ("account", nano::dev::genesis_key.pub.to_account ());
3204  	request.put ("work", nano::to_string_hex (work0));
3205  	auto response (wait_response (system, rpc_ctx, request));
3206  	std::string success (response.get<std::string> ("success"));
3207  	ASSERT_TRUE (success.empty ());
3208  	uint64_t work1 (1);
3209  	auto transaction (node->wallets.tx_begin_read ());
3210  	node->wallets.items.begin ()->second->store.work_get (transaction, nano::dev::genesis->account (), work1);
3211  	ASSERT_EQ (work1, work0);
3212  }
3213  TEST (rpc, search_receivable_all)
3214  {
3215  	nano::test::system system;
3216  	auto node = add_ipc_enabled_node (system);
3217  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
3218  	auto latest (node->latest (nano::dev::genesis_key.pub));
3219  	nano::block_builder builder;
3220  	auto block = builder
3221  				 .send ()
3222  				 .previous (latest)
3223  				 .destination (nano::dev::genesis_key.pub)
3224  				 .balance (nano::dev::constants.genesis_amount - node->config.receive_minimum.number ())
3225  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3226  				 .work (*node->work_generate_blocking (latest))
3227  				 .build ();
3228  	{
3229  		auto transaction (node->store.tx_begin_write ());
3230  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *block).code);
3231  	}
3232  	auto const rpc_ctx = add_rpc (system, node);
3233  	boost::property_tree::ptree request;
3234  	request.put ("action", "search_receivable_all");
3235  	auto response (wait_response (system, rpc_ctx, request));
3236  	ASSERT_TIMELY (10s, node->balance (nano::dev::genesis_key.pub) == nano::dev::constants.genesis_amount);
3237  }
3238  TEST (rpc, wallet_republish)
3239  {
3240  	nano::test::system system;
3241  	auto node1 = add_ipc_enabled_node (system);
3242  	nano::keypair key;
3243  	while (key.pub < nano::dev::genesis_key.pub)
3244  	{
3245  		nano::keypair key1;
3246  		key.pub = key1.pub;
3247  		key.prv = key1.prv;
3248  	}
3249  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
3250  	system.wallet (0)->insert_adhoc (key.prv);
3251  	auto latest (node1->latest (nano::dev::genesis_key.pub));
3252  	nano::block_builder builder;
3253  	auto send = builder
3254  				.send ()
3255  				.previous (latest)
3256  				.destination (key.pub)
3257  				.balance (100)
3258  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3259  				.work (*node1->work_generate_blocking (latest))
3260  				.build ();
3261  	ASSERT_EQ (nano::process_result::progress, node1->process (*send).code);
3262  	auto open = builder
3263  				.open ()
3264  				.source (send->hash ())
3265  				.representative (key.pub)
3266  				.account (key.pub)
3267  				.sign (key.prv, key.pub)
3268  				.work (*node1->work_generate_blocking (key.pub))
3269  				.build ();
3270  	ASSERT_EQ (nano::process_result::progress, node1->process (*open).code);
3271  	auto const rpc_ctx = add_rpc (system, node1);
3272  	boost::property_tree::ptree request;
3273  	request.put ("action", "wallet_republish");
3274  	request.put ("wallet", node1->wallets.items.begin ()->first.to_string ());
3275  	request.put ("count", 1);
3276  	auto response (wait_response (system, rpc_ctx, request));
3277  	auto & blocks_node (response.get_child ("blocks"));
3278  	std::vector<nano::block_hash> blocks;
3279  	for (auto i (blocks_node.begin ()), n (blocks_node.end ()); i != n; ++i)
3280  	{
3281  		blocks.emplace_back (i->second.get<std::string> (""));
3282  	}
3283  	ASSERT_EQ (2, blocks.size ());
3284  	ASSERT_EQ (send->hash (), blocks[0]);
3285  	ASSERT_EQ (open->hash (), blocks[1]);
3286  }
3287  TEST (rpc, delegators)
3288  {
3289  	nano::test::system system;
3290  	auto node1 = add_ipc_enabled_node (system);
3291  	nano::keypair key;
3292  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
3293  	system.wallet (0)->insert_adhoc (key.prv);
3294  	auto latest (node1->latest (nano::dev::genesis_key.pub));
3295  	nano::block_builder builder;
3296  	auto send = builder
3297  				.send ()
3298  				.previous (latest)
3299  				.destination (key.pub)
3300  				.balance (100)
3301  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3302  				.work (*node1->work_generate_blocking (latest))
3303  				.build ();
3304  	ASSERT_EQ (nano::process_result::progress, node1->process (*send).code);
3305  	auto open = builder
3306  				.open ()
3307  				.source (send->hash ())
3308  				.representative (nano::dev::genesis_key.pub)
3309  				.account (key.pub)
3310  				.sign (key.prv, key.pub)
3311  				.work (*node1->work_generate_blocking (key.pub))
3312  				.build ();
3313  	ASSERT_EQ (nano::process_result::progress, node1->process (*open).code);
3314  	auto const rpc_ctx = add_rpc (system, node1);
3315  	boost::property_tree::ptree request;
3316  	request.put ("action", "delegators");
3317  	request.put ("account", nano::dev::genesis_key.pub.to_account ());
3318  	auto response (wait_response (system, rpc_ctx, request));
3319  	auto & delegators_node (response.get_child ("delegators"));
3320  	boost::property_tree::ptree delegators;
3321  	for (auto i (delegators_node.begin ()), n (delegators_node.end ()); i != n; ++i)
3322  	{
3323  		delegators.put ((i->first), (i->second.get<std::string> ("")));
3324  	}
3325  	ASSERT_EQ (2, delegators.size ());
3326  	ASSERT_EQ ("100", delegators.get<std::string> (nano::dev::genesis_key.pub.to_account ()));
3327  	ASSERT_EQ ("340282366920938463463374607431768211355", delegators.get<std::string> (key.pub.to_account ()));
3328  }
3329  TEST (rpc, delegators_parameters)
3330  {
3331  	nano::test::system system;
3332  	auto node1 = add_ipc_enabled_node (system);
3333  	nano::keypair key;
3334  	auto latest (node1->latest (nano::dev::genesis_key.pub));
3335  	nano::block_builder builder;
3336  	auto send = builder
3337  				.send ()
3338  				.previous (latest)
3339  				.destination (key.pub)
3340  				.balance (100)
3341  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3342  				.work (*node1->work_generate_blocking (latest))
3343  				.build ();
3344  	ASSERT_EQ (nano::process_result::progress, node1->process (*send).code);
3345  	auto open = builder
3346  				.open ()
3347  				.source (send->hash ())
3348  				.representative (nano::dev::genesis_key.pub)
3349  				.account (key.pub)
3350  				.sign (key.prv, key.pub)
3351  				.work (*node1->work_generate_blocking (key.pub))
3352  				.build ();
3353  	ASSERT_EQ (nano::process_result::progress, node1->process (*open).code);
3354  	auto const rpc_ctx = add_rpc (system, node1);
3355  	boost::property_tree::ptree request;
3356  	request.put ("action", "delegators");
3357  	request.put ("account", nano::dev::genesis_key.pub.to_account ());
3358  	request.put ("count", 2);
3359  	auto response (wait_response (system, rpc_ctx, request));
3360  	auto & delegators_node (response.get_child ("delegators"));
3361  	boost::property_tree::ptree delegators;
3362  	for (auto i (delegators_node.begin ()), n (delegators_node.end ()); i != n; ++i)
3363  	{
3364  		delegators.put ((i->first), (i->second.get<std::string> ("")));
3365  	}
3366  	ASSERT_EQ (2, delegators.size ());
3367  	ASSERT_EQ ("100", delegators.get<std::string> (nano::dev::genesis_key.pub.to_account ()));
3368  	ASSERT_EQ ("340282366920938463463374607431768211355", delegators.get<std::string> (key.pub.to_account ()));
3369  	request.put ("count", 1);
3370  	auto response2 (wait_response (system, rpc_ctx, request));
3371  	auto & delegators_node2 (response2.get_child ("delegators"));
3372  	boost::property_tree::ptree delegators2;
3373  	for (auto i (delegators_node2.begin ()), n (delegators_node2.end ()); i != n; ++i)
3374  	{
3375  		delegators2.put ((i->first), (i->second.get<std::string> ("")));
3376  	}
3377  	ASSERT_EQ (1, delegators2.size ());
3378  	if (nano::dev::genesis_key.pub.number () < key.pub.number ())
3379  	{
3380  		ASSERT_EQ ("100", delegators2.get<std::string> (nano::dev::genesis_key.pub.to_account ()));
3381  	}
3382  	else
3383  	{
3384  		ASSERT_EQ ("340282366920938463463374607431768211355", delegators2.get<std::string> (key.pub.to_account ()));
3385  	}
3386  	request.put ("count", 1024);
3387  	request.put ("threshold", 101); 
3388  	auto response3 (wait_response (system, rpc_ctx, request));
3389  	auto & delegators_node3 (response3.get_child ("delegators"));
3390  	boost::property_tree::ptree delegators3;
3391  	for (auto i (delegators_node3.begin ()), n (delegators_node3.end ()); i != n; ++i)
3392  	{
3393  		delegators3.put ((i->first), (i->second.get<std::string> ("")));
3394  	}
3395  	ASSERT_EQ (1, delegators3.size ());
3396  	ASSERT_EQ ("340282366920938463463374607431768211355", delegators3.get<std::string> (key.pub.to_account ()));
3397  	request.put ("threshold", 0);
3398  	auto last_account (key.pub);
3399  	if (nano::dev::genesis_key.pub.number () > key.pub.number ())
3400  	{
3401  		last_account = nano::dev::genesis_key.pub;
3402  	}
3403  	request.put ("start", nano::account (last_account.number () - 1).to_account ());
3404  	auto response4 (wait_response (system, rpc_ctx, request));
3405  	auto & delegators_node4 (response4.get_child ("delegators"));
3406  	boost::property_tree::ptree delegators4;
3407  	for (auto i (delegators_node4.begin ()), n (delegators_node4.end ()); i != n; ++i)
3408  	{
3409  		delegators4.put ((i->first), (i->second.get<std::string> ("")));
3410  	}
3411  	ASSERT_EQ (1, delegators4.size ());
3412  	boost::optional<std::string> balance (delegators4.get_optional<std::string> (last_account.to_account ()));
3413  	ASSERT_TRUE (balance.is_initialized ());
3414  	request.put ("start", last_account.to_account ());
3415  	auto response5 (wait_response (system, rpc_ctx, request));
3416  	auto & delegators_node5 (response5.get_child ("delegators"));
3417  	boost::property_tree::ptree delegators5;
3418  	for (auto i (delegators_node5.begin ()), n (delegators_node5.end ()); i != n; ++i)
3419  	{
3420  		delegators5.put ((i->first), (i->second.get<std::string> ("")));
3421  	}
3422  	ASSERT_EQ (0, delegators5.size ());
3423  }
3424  TEST (rpc, delegators_count)
3425  {
3426  	nano::test::system system;
3427  	auto node1 = add_ipc_enabled_node (system);
3428  	nano::keypair key;
3429  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
3430  	system.wallet (0)->insert_adhoc (key.prv);
3431  	auto latest (node1->latest (nano::dev::genesis_key.pub));
3432  	nano::block_builder builder;
3433  	auto send = builder
3434  				.send ()
3435  				.previous (latest)
3436  				.destination (key.pub)
3437  				.balance (100)
3438  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3439  				.work (*node1->work_generate_blocking (latest))
3440  				.build ();
3441  	ASSERT_EQ (nano::process_result::progress, node1->process (*send).code);
3442  	auto open = builder
3443  				.open ()
3444  				.source (send->hash ())
3445  				.representative (nano::dev::genesis_key.pub)
3446  				.account (key.pub)
3447  				.sign (key.prv, key.pub)
3448  				.work (*node1->work_generate_blocking (key.pub))
3449  				.build ();
3450  	ASSERT_EQ (nano::process_result::progress, node1->process (*open).code);
3451  	auto const rpc_ctx = add_rpc (system, node1);
3452  	boost::property_tree::ptree request;
3453  	request.put ("action", "delegators_count");
3454  	request.put ("account", nano::dev::genesis_key.pub.to_account ());
3455  	auto response (wait_response (system, rpc_ctx, request));
3456  	std::string count (response.get<std::string> ("count"));
3457  	ASSERT_EQ ("2", count);
3458  }
3459  TEST (rpc, account_info)
3460  {
3461  	nano::test::system system;
3462  	nano::keypair key;
3463  	auto node1 = add_ipc_enabled_node (system);
3464  	auto const rpc_ctx = add_rpc (system, node1);
3465  	boost::property_tree::ptree request;
3466  	request.put ("action", "account_info");
3467  	request.put ("account", nano::account ().to_account ());
3468  	{
3469  		auto response (wait_response (system, rpc_ctx, request));
3470  		auto error (response.get_optional<std::string> ("error"));
3471  		ASSERT_TRUE (error.is_initialized ());
3472  		ASSERT_EQ (error.get (), std::error_code (nano::error_common::account_not_found).message ());
3473  	}
3474  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
3475  	system.wallet (0)->insert_adhoc (key.prv);
3476  	auto latest (node1->latest (nano::dev::genesis_key.pub));
3477  	nano::block_builder builder;
3478  	auto send = builder
3479  				.send ()
3480  				.previous (latest)
3481  				.destination (key.pub)
3482  				.balance (100)
3483  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3484  				.work (*node1->work_generate_blocking (latest))
3485  				.build ();
3486  	ASSERT_EQ (nano::process_result::progress, node1->process (*send).code);
3487  	auto time = nano::seconds_since_epoch ();
3488  	{
3489  		auto transaction = node1->store.tx_begin_write ();
3490  		node1->store.confirmation_height.put (transaction, nano::dev::genesis_key.pub, { 1, nano::dev::genesis->hash () });
3491  	}
3492  	request.put ("account", nano::dev::genesis_key.pub.to_account ());
3493  	{
3494  		auto response (wait_response (system, rpc_ctx, request));
3495  		std::string frontier (response.get<std::string> ("frontier"));
3496  		ASSERT_EQ (send->hash ().to_string (), frontier);
3497  		std::string open_block (response.get<std::string> ("open_block"));
3498  		ASSERT_EQ (nano::dev::genesis->hash ().to_string (), open_block);
3499  		std::string representative_block (response.get<std::string> ("representative_block"));
3500  		ASSERT_EQ (nano::dev::genesis->hash ().to_string (), representative_block);
3501  		std::string balance (response.get<std::string> ("balance"));
3502  		ASSERT_EQ ("100", balance);
3503  		std::string modified_timestamp (response.get<std::string> ("modified_timestamp"));
3504  		ASSERT_LT (std::abs ((long)time - stol (modified_timestamp)), 5);
3505  		std::string block_count (response.get<std::string> ("block_count"));
3506  		ASSERT_EQ ("2", block_count);
3507  		std::string confirmation_height (response.get<std::string> ("confirmation_height"));
3508  		ASSERT_EQ ("1", confirmation_height);
3509  		std::string confirmation_height_frontier (response.get<std::string> ("confirmation_height_frontier"));
3510  		ASSERT_EQ (nano::dev::genesis->hash ().to_string (), confirmation_height_frontier);
3511  		ASSERT_EQ (0, response.get<uint8_t> ("account_version"));
3512  		boost::optional<std::string> weight (response.get_optional<std::string> ("weight"));
3513  		ASSERT_FALSE (weight.is_initialized ());
3514  		boost::optional<std::string> receivable (response.get_optional<std::string> ("receivable"));
3515  		ASSERT_FALSE (receivable.is_initialized ());
3516  		boost::optional<std::string> representative (response.get_optional<std::string> ("representative"));
3517  		ASSERT_FALSE (representative.is_initialized ());
3518  	}
3519  	request.put ("weight", "true");
3520  	request.put ("receivable", "1");
3521  	request.put ("representative", "1");
3522  	{
3523  		auto response (wait_response (system, rpc_ctx, request));
3524  		ASSERT_EQ ("100", response.get<std::string> ("weight"));
3525  		ASSERT_EQ ("0", response.get<std::string> ("receivable"));
3526  		std::string representative2 (response.get<std::string> ("representative"));
3527  		ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), representative2);
3528  	}
3529  	nano::keypair key1;
3530  	{
3531  		latest = node1->latest (nano::dev::genesis_key.pub);
3532  		auto send1 = builder
3533  					 .send ()
3534  					 .previous (latest)
3535  					 .destination (key1.pub)
3536  					 .balance (50)
3537  					 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3538  					 .work (*node1->work_generate_blocking (latest))
3539  					 .build ();
3540  		ASSERT_EQ (nano::process_result::progress, node1->process (*send1).code);
3541  		auto send2 = builder
3542  					 .send ()
3543  					 .previous (send1->hash ())
3544  					 .destination (key1.pub)
3545  					 .balance (25)
3546  					 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3547  					 .work (*node1->work_generate_blocking (send1->hash ()))
3548  					 .build ();
3549  		ASSERT_EQ (nano::process_result::progress, node1->process (*send2).code);
3550  		auto state_change = builder
3551  							.state ()
3552  							.account (nano::dev::genesis_key.pub)
3553  							.previous (send2->hash ())
3554  							.representative (key1.pub)
3555  							.balance (25)
3556  							.link (0)
3557  							.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3558  							.work (*node1->work_generate_blocking (send2->hash ()))
3559  							.build ();
3560  		ASSERT_EQ (nano::process_result::progress, node1->process (*state_change).code);
3561  		auto open = builder
3562  					.open ()
3563  					.source (send1->hash ())
3564  					.representative (nano::dev::genesis_key.pub)
3565  					.account (key1.pub)
3566  					.sign (key1.prv, key1.pub)
3567  					.work (*node1->work_generate_blocking (key1.pub))
3568  					.build ();
3569  		ASSERT_EQ (nano::process_result::progress, node1->process (*open).code);
3570  		ASSERT_TIMELY (5s, !node1->active.active (*state_change));
3571  		ASSERT_TIMELY (5s, !node1->active.active (*open));
3572  	}
3573  	{
3574  		auto response (wait_response (system, rpc_ctx, request));
3575  		std::string balance (response.get<std::string> ("balance"));
3576  		ASSERT_EQ ("25", balance);
3577  	}
3578  	request.put ("include_confirmed", true);
3579  	{
3580  		auto response (wait_response (system, rpc_ctx, request));
3581  		auto balance (response.get<std::string> ("balance"));
3582  		ASSERT_EQ ("25", balance);
3583  		auto confirmed_balance (response.get<std::string> ("confirmed_balance"));
3584  		ASSERT_EQ ("340282366920938463463374607431768211455", confirmed_balance);
3585  		auto representative (response.get<std::string> ("representative"));
3586  		ASSERT_EQ (representative, key1.pub.to_account ());
3587  		auto confirmed_representative (response.get<std::string> ("confirmed_representative"));
3588  		ASSERT_EQ (confirmed_representative, nano::dev::genesis_key.pub.to_account ());
3589  		auto confirmed_frontier (response.get<std::string> ("confirmed_frontier"));
3590  		ASSERT_EQ (nano::dev::genesis->hash ().to_string (), confirmed_frontier);
3591  		auto confirmed_height (response.get<uint64_t> ("confirmed_height"));
3592  		ASSERT_EQ (1, confirmed_height);
3593  	}
3594  	request.put ("account", key1.pub.to_account ());
3595  	{
3596  		auto response (wait_response (system, rpc_ctx, request));
3597  		ASSERT_EQ ("25", response.get<std::string> ("receivable"));
3598  		ASSERT_EQ ("0", response.get<std::string> ("confirmed_receivable"));
3599  	}
3600  	request.put ("include_confirmed", false);
3601  	{
3602  		auto response (wait_response (system, rpc_ctx, request));
3603  		ASSERT_EQ ("25", response.get<std::string> ("receivable"));
3604  		auto confirmed_balance (response.get_optional<std::string> ("confirmed_balance"));
3605  		ASSERT_FALSE (confirmed_balance.is_initialized ());
3606  		auto confirmed_receivable (response.get_optional<std::string> ("confirmed_receivable"));
3607  		ASSERT_FALSE (confirmed_receivable.is_initialized ());
3608  		auto confirmed_representative (response.get_optional<std::string> ("confirmed_representative"));
3609  		ASSERT_FALSE (confirmed_representative.is_initialized ());
3610  		auto confirmed_frontier (response.get_optional<std::string> ("confirmed_frontier"));
3611  		ASSERT_FALSE (confirmed_frontier.is_initialized ());
3612  		auto confirmed_height (response.get_optional<uint64_t> ("confirmed_height"));
3613  		ASSERT_FALSE (confirmed_height.is_initialized ());
3614  	}
3615  }
3616  TEST (rpc, json_block_input)
3617  {
3618  	nano::test::system system;
3619  	auto node1 = add_ipc_enabled_node (system);
3620  	nano::keypair key;
3621  	system.wallet (0)->insert_adhoc (key.prv);
3622  	nano::block_builder builder;
3623  	auto send = builder
3624  				.state ()
3625  				.account (nano::dev::genesis->account ())
3626  				.previous (node1->latest (nano::dev::genesis_key.pub))
3627  				.representative (nano::dev::genesis->account ())
3628  				.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
3629  				.link (key.pub)
3630  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3631  				.work (0)
3632  				.build ();
3633  	auto const rpc_ctx = add_rpc (system, node1);
3634  	boost::property_tree::ptree request;
3635  	request.put ("action", "sign");
3636  	request.put ("json_block", "true");
3637  	std::string wallet;
3638  	node1->wallets.items.begin ()->first.encode_hex (wallet);
3639  	request.put ("wallet", wallet);
3640  	request.put ("account", key.pub.to_account ());
3641  	boost::property_tree::ptree json;
3642  	send->serialize_json (json);
3643  	request.add_child ("block", json);
3644  	auto response (wait_response (system, rpc_ctx, request, 10s));
3645  	bool json_error{ false };
3646  	nano::state_block block (json_error, response.get_child ("block"));
3647  	ASSERT_FALSE (json_error);
3648  	ASSERT_FALSE (nano::validate_message (key.pub, send->hash (), block.block_signature ()));
3649  	ASSERT_NE (block.block_signature (), send->block_signature ());
3650  	ASSERT_EQ (block.hash (), send->hash ());
3651  }
3652  TEST (rpc, json_block_output)
3653  {
3654  	nano::test::system system;
3655  	auto node1 = add_ipc_enabled_node (system);
3656  	nano::keypair key;
3657  	auto latest (node1->latest (nano::dev::genesis_key.pub));
3658  	nano::block_builder builder;
3659  	auto send = builder
3660  				.send ()
3661  				.previous (latest)
3662  				.destination (key.pub)
3663  				.balance (100)
3664  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3665  				.work (*node1->work_generate_blocking (latest))
3666  				.build ();
3667  	ASSERT_EQ (nano::process_result::progress, node1->process (*send).code);
3668  	auto const rpc_ctx = add_rpc (system, node1);
3669  	boost::property_tree::ptree request;
3670  	request.put ("action", "block_info");
3671  	request.put ("json_block", "true");
3672  	request.put ("hash", send->hash ().to_string ());
3673  	auto response (wait_response (system, rpc_ctx, request));
3674  	bool json_error{ false };
3675  	nano::send_block send_from_json (json_error, response.get_child ("contents"));
3676  	ASSERT_FALSE (json_error);
3677  }
3678  TEST (rpc, blocks_info)
3679  {
3680  	nano::test::system system;
3681  	auto node = add_ipc_enabled_node (system);
3682  	auto const rpc_ctx = add_rpc (system, node);
3683  	auto check_blocks = [node] (boost::property_tree::ptree & response) {
3684  		for (auto & blocks : response.get_child ("blocks"))
3685  		{
3686  			std::string hash_text (blocks.first);
3687  			ASSERT_EQ (node->latest (nano::dev::genesis->account ()).to_string (), hash_text);
3688  			std::string account_text (blocks.second.get<std::string> ("block_account"));
3689  			ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), account_text);
3690  			std::string amount_text (blocks.second.get<std::string> ("amount"));
3691  			ASSERT_EQ (nano::dev::constants.genesis_amount.convert_to<std::string> (), amount_text);
3692  			std::string blocks_text (blocks.second.get<std::string> ("contents"));
3693  			ASSERT_FALSE (blocks_text.empty ());
3694  			boost::optional<std::string> receivable (blocks.second.get_optional<std::string> ("receivable"));
3695  			ASSERT_FALSE (receivable.is_initialized ());
3696  			boost::optional<std::string> receive_hash (blocks.second.get_optional<std::string> ("receive_hash"));
3697  			ASSERT_FALSE (receive_hash.is_initialized ());
3698  			boost::optional<std::string> source (blocks.second.get_optional<std::string> ("source_account"));
3699  			ASSERT_FALSE (source.is_initialized ());
3700  			std::string balance_text (blocks.second.get<std::string> ("balance"));
3701  			ASSERT_EQ (nano::dev::constants.genesis_amount.convert_to<std::string> (), balance_text);
3702  			ASSERT_TRUE (blocks.second.get<bool> ("confirmed")); 
3703  			std::string successor_text (blocks.second.get<std::string> ("successor"));
3704  			ASSERT_EQ (nano::block_hash (0).to_string (), successor_text); 
3705  		}
3706  	};
3707  	boost::property_tree::ptree request;
3708  	request.put ("action", "blocks_info");
3709  	boost::property_tree::ptree entry;
3710  	boost::property_tree::ptree hashes;
3711  	entry.put ("", node->latest (nano::dev::genesis->account ()).to_string ());
3712  	hashes.push_back (std::make_pair ("", entry));
3713  	request.add_child ("hashes", hashes);
3714  	{
3715  		auto response (wait_response (system, rpc_ctx, request));
3716  		check_blocks (response);
3717  	}
3718  	std::string random_hash = nano::block_hash ().to_string ();
3719  	entry.put ("", random_hash);
3720  	hashes.push_back (std::make_pair ("", entry));
3721  	request.erase ("hashes");
3722  	request.add_child ("hashes", hashes);
3723  	{
3724  		auto response (wait_response (system, rpc_ctx, request));
3725  		ASSERT_EQ (std::error_code (nano::error_blocks::not_found).message (), response.get<std::string> ("error"));
3726  	}
3727  	request.put ("include_not_found", "true");
3728  	{
3729  		auto response (wait_response (system, rpc_ctx, request));
3730  		check_blocks (response);
3731  		auto & blocks_not_found (response.get_child ("blocks_not_found"));
3732  		ASSERT_EQ (1, blocks_not_found.size ());
3733  		ASSERT_EQ (random_hash, blocks_not_found.begin ()->second.get<std::string> (""));
3734  	}
3735  	request.put ("source", "true");
3736  	request.put ("receivable", "1");
3737  	request.put ("receive_hash", "1");
3738  	{
3739  		auto response (wait_response (system, rpc_ctx, request));
3740  		for (auto & blocks : response.get_child ("blocks"))
3741  		{
3742  			ASSERT_EQ ("0", blocks.second.get<std::string> ("source_account"));
3743  			ASSERT_EQ ("0", blocks.second.get<std::string> ("receivable"));
3744  			std::string receive_hash (blocks.second.get<std::string> ("receive_hash"));
3745  			ASSERT_EQ (nano::block_hash (0).to_string (), receive_hash);
3746  		}
3747  	}
3748  }
3749  TEST (rpc, blocks_info_receive_hash)
3750  {
3751  	nano::test::system system;
3752  	auto node = add_ipc_enabled_node (system);
3753  	nano::keypair key1;
3754  	system.wallet (0)->insert_adhoc (key1.prv);
3755  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
3756  	auto send1 = system.wallet (0)->send_action (nano::dev::genesis_key.pub, key1.pub, 1);
3757  	auto send2 = system.wallet (0)->send_action (nano::dev::genesis_key.pub, key1.pub, 2);
3758  	auto send3 = system.wallet (0)->send_action (nano::dev::genesis_key.pub, key1.pub, 3);
3759  	auto send4 = system.wallet (0)->send_action (nano::dev::genesis_key.pub, key1.pub, 4);
3760  	auto recv1 (system.wallet (0)->receive_action (send1->hash (), key1.pub, node->config.receive_minimum.number (), send1->link ().as_account ()));
3761  	auto recv4 (system.wallet (0)->receive_action (send4->hash (), key1.pub, node->config.receive_minimum.number (), send4->link ().as_account ()));
3762  	auto recv3 (system.wallet (0)->receive_action (send3->hash (), key1.pub, node->config.receive_minimum.number (), send3->link ().as_account ()));
3763  	auto recv2 (system.wallet (0)->receive_action (send2->hash (), key1.pub, node->config.receive_minimum.number (), send2->link ().as_account ()));
3764  	auto all_blocks_cemented = [node, &key1] () -> bool {
3765  		nano::confirmation_height_info info;
3766  		if (node->store.confirmation_height.get (node->store.tx_begin_read (), key1.pub, info))
3767  		{
3768  			return false;
3769  		}
3770  		return info.height == 4;
3771  	};
3772  	ASSERT_TIMELY (5s, all_blocks_cemented ());
3773  	ASSERT_EQ (node->ledger.account_balance (node->store.tx_begin_read (), key1.pub, true), 10);
3774  	boost::property_tree::ptree request;
3775  	boost::property_tree::ptree hashes;
3776  	boost::property_tree::ptree child;
3777  	child.put ("", send1->hash ().to_string ());
3778  	hashes.push_back (std::make_pair ("", child));
3779  	child.put ("", send2->hash ().to_string ());
3780  	hashes.push_back (std::make_pair ("", child));
3781  	child.put ("", send3->hash ().to_string ());
3782  	hashes.push_back (std::make_pair ("", child));
3783  	child.put ("", send4->hash ().to_string ());
3784  	hashes.push_back (std::make_pair ("", child));
3785  	request.put ("action", "blocks_info");
3786  	request.add_child ("hashes", hashes);
3787  	request.put ("receive_hash", "true");
3788  	request.put ("json_block", "true");
3789  	auto const rpc_ctx = add_rpc (system, node);
3790  	auto response = wait_response (system, rpc_ctx, request);
3791  	std::map<std::string, std::string> send_recv_map{
3792  		{ send1->hash ().to_string (), recv1->hash ().to_string () },
3793  		{ send2->hash ().to_string (), recv2->hash ().to_string () },
3794  		{ send3->hash ().to_string (), recv3->hash ().to_string () },
3795  		{ send4->hash ().to_string (), recv4->hash ().to_string () },
3796  	};
3797  	for (auto & blocks : response.get_child ("blocks"))
3798  	{
3799  		auto hash = blocks.first;
3800  		std::string receive_hash = blocks.second.get<std::string> ("receive_hash");
3801  		ASSERT_EQ (receive_hash, send_recv_map[hash]);
3802  		send_recv_map.erase (hash);
3803  	}
3804  	ASSERT_EQ (send_recv_map.size (), 0);
3805  }
3806  TEST (rpc, blocks_info_subtype)
3807  {
3808  	nano::test::system system;
3809  	auto node1 = add_ipc_enabled_node (system);
3810  	nano::keypair key;
3811  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
3812  	system.wallet (0)->insert_adhoc (key.prv);
3813  	auto send (system.wallet (0)->send_action (nano::dev::genesis_key.pub, nano::dev::genesis_key.pub, nano::Gxrb_ratio));
3814  	ASSERT_NE (nullptr, send);
3815  	auto receive (system.wallet (0)->receive_action (send->hash (), key.pub, nano::Gxrb_ratio, send->link ().as_account ()));
3816  	ASSERT_NE (nullptr, receive);
3817  	auto change (system.wallet (0)->change_action (nano::dev::genesis_key.pub, key.pub));
3818  	ASSERT_NE (nullptr, change);
3819  	auto const rpc_ctx = add_rpc (system, node1);
3820  	boost::property_tree::ptree request;
3821  	request.put ("action", "blocks_info");
3822  	boost::property_tree::ptree hashes;
3823  	boost::property_tree::ptree entry;
3824  	entry.put ("", send->hash ().to_string ());
3825  	hashes.push_back (std::make_pair ("", entry));
3826  	entry.put ("", receive->hash ().to_string ());
3827  	hashes.push_back (std::make_pair ("", entry));
3828  	entry.put ("", change->hash ().to_string ());
3829  	hashes.push_back (std::make_pair ("", entry));
3830  	request.add_child ("hashes", hashes);
3831  	auto response (wait_response (system, rpc_ctx, request));
3832  	auto & blocks (response.get_child ("blocks"));
3833  	ASSERT_EQ (3, blocks.size ());
3834  	auto send_subtype (blocks.get_child (send->hash ().to_string ()).get<std::string> ("subtype"));
3835  	ASSERT_EQ (send_subtype, "send");
3836  	auto receive_subtype (blocks.get_child (receive->hash ().to_string ()).get<std::string> ("subtype"));
3837  	ASSERT_EQ (receive_subtype, "receive");
3838  	auto change_subtype (blocks.get_child (change->hash ().to_string ()).get<std::string> ("subtype"));
3839  	ASSERT_EQ (change_subtype, "change");
3840  	auto send_successor (blocks.get_child (send->hash ().to_string ()).get<std::string> ("successor"));
3841  	ASSERT_EQ (send_successor, receive->hash ().to_string ());
3842  	auto receive_successor (blocks.get_child (receive->hash ().to_string ()).get<std::string> ("successor"));
3843  	ASSERT_EQ (receive_successor, change->hash ().to_string ());
3844  	auto change_successor (blocks.get_child (change->hash ().to_string ()).get<std::string> ("successor"));
3845  	ASSERT_EQ (change_successor, nano::block_hash (0).to_string ()); 
3846  }
3847  TEST (rpc, block_info_successor)
3848  {
3849  	nano::test::system system;
3850  	auto node1 = add_ipc_enabled_node (system);
3851  	nano::keypair key;
3852  	auto latest (node1->latest (nano::dev::genesis_key.pub));
3853  	nano::block_builder builder;
3854  	auto send = builder
3855  				.send ()
3856  				.previous (latest)
3857  				.destination (key.pub)
3858  				.balance (100)
3859  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3860  				.work (*node1->work_generate_blocking (latest))
3861  				.build ();
3862  	ASSERT_EQ (nano::process_result::progress, node1->process (*send).code);
3863  	auto const rpc_ctx = add_rpc (system, node1);
3864  	boost::property_tree::ptree request;
3865  	request.put ("action", "block_info");
3866  	request.put ("hash", latest.to_string ());
3867  	auto response (wait_response (system, rpc_ctx, request));
3868  	std::string successor_text (response.get<std::string> ("successor"));
3869  	ASSERT_EQ (successor_text, send->hash ().to_string ());
3870  	std::string account_text (response.get<std::string> ("block_account"));
3871  	ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), account_text);
3872  	std::string amount_text (response.get<std::string> ("amount"));
3873  	ASSERT_EQ (nano::dev::constants.genesis_amount.convert_to<std::string> (), amount_text);
3874  }
3875  TEST (rpc, block_info_pruning)
3876  {
3877  	nano::test::system system;
3878  	nano::node_config node_config0 = system.default_config ();
3879  	node_config0.receive_minimum = nano::dev::constants.genesis_amount; 
3880  	auto & node0 = *system.add_node (node_config0);
3881  	nano::node_config node_config1 = system.default_config ();
3882  	node_config1.enable_voting = false; 
3883  	nano::node_flags node_flags;
3884  	node_flags.enable_pruning = true;
3885  	auto node1 = add_ipc_enabled_node (system, node_config1, node_flags);
3886  	auto latest (node1->latest (nano::dev::genesis_key.pub));
3887  	nano::block_builder builder;
3888  	auto send1 = builder
3889  				 .send ()
3890  				 .previous (latest)
3891  				 .destination (nano::dev::genesis_key.pub)
3892  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
3893  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3894  				 .work (*node1->work_generate_blocking (latest))
3895  				 .build_shared ();
3896  	node1->process_active (send1);
3897  	auto receive1 = builder
3898  					.receive ()
3899  					.previous (send1->hash ())
3900  					.source (send1->hash ())
3901  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3902  					.work (*node1->work_generate_blocking (send1->hash ()))
3903  					.build_shared ();
3904  	node1->process_active (receive1);
3905  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
3906  	ASSERT_TIMELY (5s, node1->block_confirmed (receive1->hash ()));
3907  	{
3908  		auto transaction (node1->store.tx_begin_write ());
3909  		ASSERT_EQ (1, node1->ledger.pruning_action (transaction, send1->hash (), 1));
3910  		ASSERT_TRUE (node1->store.block.exists (transaction, receive1->hash ()));
3911  	}
3912  	auto const rpc_ctx = add_rpc (system, node1);
3913  	boost::property_tree::ptree request;
3914  	request.put ("action", "block_info");
3915  	request.put ("hash", send1->hash ().to_string ());
3916  	auto response (wait_response (system, rpc_ctx, request));
3917  	ASSERT_EQ (std::error_code (nano::error_blocks::not_found).message (), response.get<std::string> ("error"));
3918  	boost::property_tree::ptree request2;
3919  	request2.put ("action", "block_info");
3920  	request2.put ("json_block", "true");
3921  	request2.put ("hash", receive1->hash ().to_string ());
3922  	auto response2 (wait_response (system, rpc_ctx, request2));
3923  	std::string account_text (response2.get<std::string> ("block_account"));
3924  	ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), account_text);
3925  	boost::optional<std::string> amount (response2.get_optional<std::string> ("amount"));
3926  	ASSERT_FALSE (amount.is_initialized ()); 
3927  	bool json_error{ false };
3928  	nano::receive_block receive_from_json (json_error, response2.get_child ("contents"));
3929  	ASSERT_FALSE (json_error);
3930  	ASSERT_EQ (receive1->full_hash (), receive_from_json.full_hash ());
3931  	std::string balance_text (response2.get<std::string> ("balance"));
3932  	ASSERT_EQ (nano::dev::constants.genesis_amount.convert_to<std::string> (), balance_text);
3933  	ASSERT_TRUE (response2.get<bool> ("confirmed"));
3934  	std::string successor_text (response2.get<std::string> ("successor"));
3935  	ASSERT_EQ (successor_text, nano::block_hash (0).to_string ()); 
3936  }
3937  TEST (rpc, pruned_exists)
3938  {
3939  	nano::test::system system;
3940  	nano::node_config node_config0 = system.default_config ();
3941  	node_config0.receive_minimum = nano::dev::constants.genesis_amount; 
3942  	auto & node0 = *system.add_node (node_config0);
3943  	nano::node_config node_config1 = system.default_config ();
3944  	node_config1.enable_voting = false; 
3945  	nano::node_flags node_flags;
3946  	node_flags.enable_pruning = true;
3947  	auto node1 = add_ipc_enabled_node (system, node_config1, node_flags);
3948  	auto latest (node1->latest (nano::dev::genesis_key.pub));
3949  	nano::block_builder builder;
3950  	auto send1 = builder
3951  				 .send ()
3952  				 .previous (latest)
3953  				 .destination (nano::dev::genesis_key.pub)
3954  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
3955  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3956  				 .work (*node1->work_generate_blocking (latest))
3957  				 .build_shared ();
3958  	node1->process_active (send1);
3959  	auto receive1 = builder
3960  					.receive ()
3961  					.previous (send1->hash ())
3962  					.source (send1->hash ())
3963  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3964  					.work (*node1->work_generate_blocking (send1->hash ()))
3965  					.build_shared ();
3966  	node1->process_active (receive1);
3967  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
3968  	ASSERT_TIMELY (5s, node1->block_confirmed (receive1->hash ()));
3969  	{
3970  		auto transaction (node1->store.tx_begin_write ());
3971  		ASSERT_EQ (1, node1->ledger.pruning_action (transaction, send1->hash (), 1));
3972  		ASSERT_TRUE (node1->store.block.exists (transaction, receive1->hash ()));
3973  	}
3974  	auto const rpc_ctx = add_rpc (system, node1);
3975  	boost::property_tree::ptree request;
3976  	request.put ("action", "pruned_exists");
3977  	request.put ("hash", send1->hash ().to_string ());
3978  	auto response (wait_response (system, rpc_ctx, request));
3979  	ASSERT_TRUE (response.get<bool> ("exists"));
3980  	boost::property_tree::ptree request2;
3981  	request2.put ("action", "pruned_exists");
3982  	request2.put ("hash", receive1->hash ().to_string ());
3983  	auto response2 (wait_response (system, rpc_ctx, request2));
3984  	ASSERT_FALSE (response2.get<bool> ("exists"));
3985  }
3986  TEST (rpc, work_peers_all)
3987  {
3988  	nano::test::system system;
3989  	auto node1 = add_ipc_enabled_node (system);
3990  	auto const rpc_ctx = add_rpc (system, node1);
3991  	boost::property_tree::ptree request;
3992  	request.put ("action", "work_peer_add");
3993  	request.put ("address", "::1");
3994  	request.put ("port", "0");
3995  	auto response (wait_response (system, rpc_ctx, request));
3996  	std::string success (response.get<std::string> ("success", ""));
3997  	ASSERT_TRUE (success.empty ());
3998  	boost::property_tree::ptree request1;
3999  	request1.put ("action", "work_peers");
4000  	auto response1 (wait_response (system, rpc_ctx, request1));
4001  	auto & peers_node (response1.get_child ("work_peers"));
4002  	std::vector<std::string> peers;
4003  	for (auto i (peers_node.begin ()), n (peers_node.end ()); i != n; ++i)
4004  	{
4005  		peers.push_back (i->second.get<std::string> (""));
4006  	}
4007  	ASSERT_EQ (1, peers.size ());
4008  	ASSERT_EQ ("::1:0", peers[0]);
4009  	boost::property_tree::ptree request2;
4010  	request2.put ("action", "work_peers_clear");
4011  	auto response2 (wait_response (system, rpc_ctx, request2));
4012  	success = response2.get<std::string> ("success", "");
4013  	ASSERT_TRUE (success.empty ());
4014  	auto response3 (wait_response (system, rpc_ctx, request1, 10s));
4015  	peers_node = response3.get_child ("work_peers");
4016  	ASSERT_EQ (0, peers_node.size ());
4017  }
4018  TEST (rpc, populate_backlog)
4019  {
4020  	nano::test::system system;
4021  	nano::node_config node_config = system.default_config ();
4022  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
4023  	auto node = add_ipc_enabled_node (system, node_config);
4024  	nano::keypair key;
4025  	nano::block_builder builder;
4026  	auto latest (node->latest (nano::dev::genesis_key.pub));
4027  	auto genesis_balance (nano::dev::constants.genesis_amount);
4028  	auto send_amount (genesis_balance - 100);
4029  	auto send = builder
4030  				.send ()
4031  				.previous (latest)
4032  				.destination (key.pub)
4033  				.balance (genesis_balance)
4034  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
4035  				.work (*node->work_generate_blocking (latest))
4036  				.build ();
4037  	ASSERT_EQ (nano::process_result::progress, node->process (*send).code);
4038  	ASSERT_FALSE (node->block_arrival.recent (send->hash ()));
4039  	auto const rpc_ctx = add_rpc (system, node);
4040  	boost::property_tree::ptree request;
4041  	request.put ("action", "populate_backlog");
4042  	auto response (wait_response (system, rpc_ctx, request));
4043  	std::string success (response.get<std::string> ("success", ""));
4044  	ASSERT_TRUE (success.empty ());
4045  	ASSERT_TIMELY (5s, node->active.active (*send));
4046  }
4047  TEST (rpc, ledger)
4048  {
4049  	nano::test::system system;
4050  	auto node = add_ipc_enabled_node (system);
4051  	nano::keypair key;
4052  	auto latest (node->latest (nano::dev::genesis_key.pub));
4053  	auto genesis_balance (nano::dev::constants.genesis_amount);
4054  	auto send_amount (genesis_balance - 100);
4055  	genesis_balance -= send_amount;
4056  	nano::block_builder builder;
4057  	auto send = builder
4058  				.send ()
4059  				.previous (latest)
4060  				.destination (key.pub)
4061  				.balance (genesis_balance)
4062  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
4063  				.work (*node->work_generate_blocking (latest))
4064  				.build ();
4065  	ASSERT_EQ (nano::process_result::progress, node->process (*send).code);
4066  	auto open = builder
4067  				.open ()
4068  				.source (send->hash ())
4069  				.representative (nano::dev::genesis_key.pub)
4070  				.account (key.pub)
4071  				.sign (key.prv, key.pub)
4072  				.work (*node->work_generate_blocking (key.pub))
4073  				.build ();
4074  	ASSERT_EQ (nano::process_result::progress, node->process (*open).code);
4075  	auto time = nano::seconds_since_epoch ();
4076  	auto const rpc_ctx = add_rpc (system, node);
4077  	boost::property_tree::ptree request;
4078  	request.put ("action", "ledger");
4079  	request.put ("sorting", true);
4080  	request.put ("count", "1");
4081  	{
4082  		auto response (wait_response (system, rpc_ctx, request));
4083  		for (auto & account : response.get_child ("accounts"))
4084  		{
4085  			std::string account_text (account.first);
4086  			ASSERT_EQ (key.pub.to_account (), account_text);
4087  			std::string frontier (account.second.get<std::string> ("frontier"));
4088  			ASSERT_EQ (open->hash ().to_string (), frontier);
4089  			std::string open_block (account.second.get<std::string> ("open_block"));
4090  			ASSERT_EQ (open->hash ().to_string (), open_block);
4091  			std::string representative_block (account.second.get<std::string> ("representative_block"));
4092  			ASSERT_EQ (open->hash ().to_string (), representative_block);
4093  			std::string balance_text (account.second.get<std::string> ("balance"));
4094  			ASSERT_EQ (send_amount.convert_to<std::string> (), balance_text);
4095  			std::string modified_timestamp (account.second.get<std::string> ("modified_timestamp"));
4096  			ASSERT_LT (std::abs ((long)time - stol (modified_timestamp)), 5);
4097  			std::string block_count (account.second.get<std::string> ("block_count"));
4098  			ASSERT_EQ ("1", block_count);
4099  			boost::optional<std::string> weight (account.second.get_optional<std::string> ("weight"));
4100  			ASSERT_FALSE (weight.is_initialized ());
4101  			boost::optional<std::string> pending (account.second.get_optional<std::string> ("pending"));
4102  			ASSERT_FALSE (pending.is_initialized ());
4103  			boost::optional<std::string> representative (account.second.get_optional<std::string> ("representative"));
4104  			ASSERT_FALSE (representative.is_initialized ());
4105  		}
4106  	}
4107  	request.put ("weight", true);
4108  	request.put ("pending", true);
4109  	request.put ("representative", true);
4110  	{
4111  		auto response (wait_response (system, rpc_ctx, request));
4112  		for (auto & account : response.get_child ("accounts"))
4113  		{
4114  			boost::optional<std::string> weight (account.second.get_optional<std::string> ("weight"));
4115  			ASSERT_TRUE (weight.is_initialized ());
4116  			ASSERT_EQ ("0", weight.get ());
4117  			boost::optional<std::string> pending (account.second.get_optional<std::string> ("pending"));
4118  			ASSERT_TRUE (pending.is_initialized ());
4119  			ASSERT_EQ ("0", pending.get ());
4120  			boost::optional<std::string> representative (account.second.get_optional<std::string> ("representative"));
4121  			ASSERT_TRUE (representative.is_initialized ());
4122  			ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), representative.get ());
4123  		}
4124  	}
4125  	request.put ("count", 2);
4126  	request.put ("threshold", genesis_balance + 1);
4127  	{
4128  		auto response (wait_response (system, rpc_ctx, request));
4129  		auto & accounts (response.get_child ("accounts"));
4130  		ASSERT_EQ (1, accounts.size ());
4131  		auto account (accounts.begin ());
4132  		ASSERT_EQ (key.pub.to_account (), account->first);
4133  		std::string balance_text (account->second.get<std::string> ("balance"));
4134  		ASSERT_EQ (send_amount.convert_to<std::string> (), balance_text);
4135  	}
4136  	auto send2_amount (50);
4137  	genesis_balance -= send2_amount;
4138  	auto send2 = builder
4139  				 .send ()
4140  				 .previous (send->hash ())
4141  				 .destination (key.pub)
4142  				 .balance (genesis_balance)
4143  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
4144  				 .work (*node->work_generate_blocking (send->hash ()))
4145  				 .build ();
4146  	ASSERT_EQ (nano::process_result::progress, node->process (*send2).code);
4147  	request.put ("count", 2);
4148  	request.put ("threshold", (send_amount + send2_amount).convert_to<std::string> ());
4149  	request.put ("pending", true);
4150  	{
4151  		auto response (wait_response (system, rpc_ctx, request));
4152  		auto & accounts (response.get_child ("accounts"));
4153  		ASSERT_EQ (1, accounts.size ());
4154  		auto account (accounts.begin ());
4155  		ASSERT_EQ (key.pub.to_account (), account->first);
4156  		std::string balance_text (account->second.get<std::string> ("balance"));
4157  		ASSERT_EQ (send_amount.convert_to<std::string> (), balance_text);
4158  		std::string pending_text (account->second.get<std::string> ("pending"));
4159  		ASSERT_EQ (std::to_string (send2_amount), pending_text);
4160  	}
4161  }
4162  TEST (rpc, accounts_create)
4163  {
4164  	nano::test::system system;
4165  	auto node = add_ipc_enabled_node (system);
4166  	auto const rpc_ctx = add_rpc (system, node);
4167  	boost::property_tree::ptree request;
4168  	request.put ("action", "accounts_create");
4169  	request.put ("wallet", node->wallets.items.begin ()->first.to_string ());
4170  	request.put ("count", "8");
4171  	auto response (wait_response (system, rpc_ctx, request));
4172  	auto & accounts (response.get_child ("accounts"));
4173  	for (auto i (accounts.begin ()), n (accounts.end ()); i != n; ++i)
4174  	{
4175  		std::string account_text (i->second.get<std::string> (""));
4176  		nano::account account;
4177  		ASSERT_FALSE (account.decode_account (account_text));
4178  		ASSERT_TRUE (system.wallet (0)->exists (account));
4179  	}
4180  	ASSERT_EQ (8, accounts.size ());
4181  }
4182  TEST (rpc, block_create)
4183  {
4184  	nano::test::system system;
4185  	auto node1 = add_ipc_enabled_node (system);
4186  	nano::keypair key;
4187  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
4188  	system.wallet (0)->insert_adhoc (key.prv);
4189  	auto latest (node1->latest (nano::dev::genesis_key.pub));
4190  	auto send_work = *node1->work_generate_blocking (latest);
4191  	nano::block_builder builder;
4192  	auto send = builder
4193  				.send ()
4194  				.previous (latest)
4195  				.destination (key.pub)
4196  				.balance (100)
4197  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
4198  				.work (send_work)
4199  				.build ();
4200  	auto open_work = *node1->work_generate_blocking (key.pub);
4201  	auto open = builder
4202  				.open ()
4203  				.source (send->hash ())
4204  				.representative (nano::dev::genesis_key.pub)
4205  				.account (key.pub)
4206  				.sign (key.prv, key.pub)
4207  				.work (open_work)
4208  				.build ();
4209  	auto const rpc_ctx = add_rpc (system, node1);
4210  	boost::property_tree::ptree request;
4211  	request.put ("action", "block_create");
4212  	request.put ("type", "send");
4213  	request.put ("wallet", node1->wallets.items.begin ()->first.to_string ());
4214  	request.put ("account", nano::dev::genesis_key.pub.to_account ());
4215  	request.put ("previous", latest.to_string ());
4216  	request.put ("amount", "340282366920938463463374607431768211355");
4217  	request.put ("destination", key.pub.to_account ());
4218  	request.put ("work", nano::to_string_hex (send_work));
4219  	auto response (wait_response (system, rpc_ctx, request));
4220  	std::string send_hash (response.get<std::string> ("hash"));
4221  	ASSERT_EQ (send->hash ().to_string (), send_hash);
4222  	std::string send_difficulty (response.get<std::string> ("difficulty"));
4223  	ASSERT_EQ (nano::to_string_hex (nano::dev::network_params.work.difficulty (*send)), send_difficulty);
4224  	auto send_text (response.get<std::string> ("block"));
4225  	boost::property_tree::ptree block_l;
4226  	std::stringstream block_stream (send_text);
4227  	boost::property_tree::read_json (block_stream, block_l);
4228  	auto send_block (nano::deserialize_block_json (block_l));
4229  	ASSERT_EQ (send->hash (), send_block->hash ());
4230  	ASSERT_EQ (nano::process_result::progress, node1->process (*send).code);
4231  	boost::property_tree::ptree request1;
4232  	request1.put ("action", "block_create");
4233  	request1.put ("type", "open");
4234  	std::string key_text;
4235  	key.prv.encode_hex (key_text);
4236  	request1.put ("key", key_text);
4237  	request1.put ("representative", nano::dev::genesis_key.pub.to_account ());
4238  	request1.put ("source", send->hash ().to_string ());
4239  	request1.put ("work", nano::to_string_hex (open_work));
4240  	auto response1 (wait_response (system, rpc_ctx, request1));
4241  	std::string open_hash (response1.get<std::string> ("hash"));
4242  	ASSERT_EQ (open->hash ().to_string (), open_hash);
4243  	auto open_text (response1.get<std::string> ("block"));
4244  	std::stringstream block_stream1 (open_text);
4245  	boost::property_tree::read_json (block_stream1, block_l);
4246  	auto open_block (nano::deserialize_block_json (block_l));
4247  	ASSERT_EQ (open->hash (), open_block->hash ());
4248  	ASSERT_EQ (nano::process_result::progress, node1->process (*open).code);
4249  	request1.put ("representative", key.pub.to_account ());
4250  	auto response2 (wait_response (system, rpc_ctx, request1));
4251  	std::string open2_hash (response2.get<std::string> ("hash"));
4252  	ASSERT_NE (open->hash ().to_string (), open2_hash); 
4253  	auto change_work = *node1->work_generate_blocking (open->hash ());
4254  	auto change = builder
4255  				  .change ()
4256  				  .previous (open->hash ())
4257  				  .representative (key.pub)
4258  				  .sign (key.prv, key.pub)
4259  				  .work (change_work)
4260  				  .build ();
4261  	request1.put ("type", "change");
4262  	request1.put ("work", nano::to_string_hex (change_work));
4263  	auto response4 (wait_response (system, rpc_ctx, request1));
4264  	std::string change_hash (response4.get<std::string> ("hash"));
4265  	ASSERT_EQ (change->hash ().to_string (), change_hash);
4266  	auto change_text (response4.get<std::string> ("block"));
4267  	std::stringstream block_stream4 (change_text);
4268  	boost::property_tree::read_json (block_stream4, block_l);
4269  	auto change_block (nano::deserialize_block_json (block_l));
4270  	ASSERT_EQ (change->hash (), change_block->hash ());
4271  	ASSERT_EQ (nano::process_result::progress, node1->process (*change).code);
4272  	auto send2 = builder
4273  				 .send ()
4274  				 .previous (send->hash ())
4275  				 .destination (key.pub)
4276  				 .balance (0)
4277  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
4278  				 .work (*node1->work_generate_blocking (send->hash ()))
4279  				 .build ();
4280  	ASSERT_EQ (nano::process_result::progress, node1->process (*send2).code);
4281  	boost::property_tree::ptree request2;
4282  	request2.put ("action", "block_create");
4283  	request2.put ("type", "receive");
4284  	request2.put ("wallet", node1->wallets.items.begin ()->first.to_string ());
4285  	request2.put ("account", key.pub.to_account ());
4286  	request2.put ("source", send2->hash ().to_string ());
4287  	request2.put ("previous", change->hash ().to_string ());
4288  	request2.put ("work", nano::to_string_hex (*node1->work_generate_blocking (change->hash ())));
4289  	auto response5 (wait_response (system, rpc_ctx, request2));
4290  	std::string receive_hash (response4.get<std::string> ("hash"));
4291  	auto receive_text (response5.get<std::string> ("block"));
4292  	std::stringstream block_stream5 (change_text);
4293  	boost::property_tree::read_json (block_stream5, block_l);
4294  	auto receive_block (nano::deserialize_block_json (block_l));
4295  	ASSERT_EQ (receive_hash, receive_block->hash ().to_string ());
4296  	node1->process_active (std::move (receive_block));
4297  	latest = node1->latest (key.pub);
4298  	ASSERT_EQ (receive_hash, latest.to_string ());
4299  }
4300  TEST (rpc, block_create_state)
4301  {
4302  	nano::test::system system;
4303  	auto node = add_ipc_enabled_node (system);
4304  	nano::keypair key;
4305  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
4306  	auto const rpc_ctx = add_rpc (system, node);
4307  	boost::property_tree::ptree request;
4308  	request.put ("action", "block_create");
4309  	request.put ("type", "state");
4310  	request.put ("wallet", node->wallets.items.begin ()->first.to_string ());
4311  	request.put ("account", nano::dev::genesis_key.pub.to_account ());
4312  	request.put ("previous", nano::dev::genesis->hash ().to_string ());
4313  	request.put ("representative", nano::dev::genesis_key.pub.to_account ());
4314  	request.put ("balance", (nano::dev::constants.genesis_amount - nano::Gxrb_ratio).convert_to<std::string> ());
4315  	request.put ("link", key.pub.to_account ());
4316  	request.put ("work", nano::to_string_hex (*node->work_generate_blocking (nano::dev::genesis->hash ())));
4317  	auto response (wait_response (system, rpc_ctx, request));
4318  	std::string state_hash (response.get<std::string> ("hash"));
4319  	auto state_text (response.get<std::string> ("block"));
4320  	std::stringstream block_stream (state_text);
4321  	boost::property_tree::ptree block_l;
4322  	boost::property_tree::read_json (block_stream, block_l);
4323  	auto state_block (nano::deserialize_block_json (block_l));
4324  	ASSERT_NE (nullptr, state_block);
4325  	ASSERT_EQ (nano::block_type::state, state_block->type ());
4326  	ASSERT_EQ (state_hash, state_block->hash ().to_string ());
4327  	auto process_result (node->process (*state_block));
4328  	ASSERT_EQ (nano::process_result::progress, process_result.code);
4329  }
4330  TEST (rpc, block_create_state_open)
4331  {
4332  	nano::test::system system;
4333  	auto node = add_ipc_enabled_node (system);
4334  	nano::keypair key;
4335  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
4336  	auto send_block (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key.pub, nano::Gxrb_ratio));
4337  	ASSERT_NE (nullptr, send_block);
4338  	auto const rpc_ctx = add_rpc (system, node);
4339  	boost::property_tree::ptree request;
4340  	request.put ("action", "block_create");
4341  	request.put ("type", "state");
4342  	request.put ("key", key.prv.to_string ());
4343  	request.put ("account", key.pub.to_account ());
4344  	request.put ("previous", 0);
4345  	request.put ("representative", nano::dev::genesis_key.pub.to_account ());
4346  	request.put ("balance", nano::Gxrb_ratio.convert_to<std::string> ());
4347  	request.put ("link", send_block->hash ().to_string ());
4348  	request.put ("work", nano::to_string_hex (*node->work_generate_blocking (key.pub)));
4349  	auto response (wait_response (system, rpc_ctx, request));
4350  	std::string state_hash (response.get<std::string> ("hash"));
4351  	auto state_text (response.get<std::string> ("block"));
4352  	std::stringstream block_stream (state_text);
4353  	boost::property_tree::ptree block_l;
4354  	boost::property_tree::read_json (block_stream, block_l);
4355  	auto state_block (nano::deserialize_block_json (block_l));
4356  	ASSERT_NE (nullptr, state_block);
4357  	ASSERT_EQ (nano::block_type::state, state_block->type ());
4358  	ASSERT_EQ (state_hash, state_block->hash ().to_string ());
4359  	auto difficulty (nano::dev::network_params.work.difficulty (*state_block));
4360  	ASSERT_GT (difficulty, nano::dev::network_params.work.threshold (state_block->work_version (), nano::block_details (nano::epoch::epoch_0, false, true, false)));
4361  	ASSERT_TRUE (node->latest (key.pub).is_zero ());
4362  	auto process_result (node->process (*state_block));
4363  	ASSERT_EQ (nano::process_result::progress, process_result.code);
4364  	ASSERT_EQ (state_block->sideband ().details.epoch, nano::epoch::epoch_0);
4365  	ASSERT_TRUE (state_block->sideband ().details.is_receive);
4366  	ASSERT_FALSE (node->latest (key.pub).is_zero ());
4367  }
4368  TEST (rpc, block_create_state_request_work)
4369  {
4370  	std::unique_ptr<nano::state_block> epoch2;
4371  	{
4372  		nano::test::system system (1);
4373  		system.upgrade_genesis_epoch (*system.nodes.front (), nano::epoch::epoch_1);
4374  		epoch2 = system.upgrade_genesis_epoch (*system.nodes.front (), nano::epoch::epoch_2);
4375  	}
4376  	std::vector<std::string> previous_test_input{ epoch2->hash ().to_string (), std::string ("0") };
4377  	for (auto previous : previous_test_input)
4378  	{
4379  		nano::test::system system;
4380  		auto node = add_ipc_enabled_node (system);
4381  		nano::keypair key;
4382  		system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
4383  		auto const rpc_ctx = add_rpc (system, node);
4384  		boost::property_tree::ptree request;
4385  		request.put ("action", "block_create");
4386  		request.put ("type", "state");
4387  		request.put ("wallet", node->wallets.items.begin ()->first.to_string ());
4388  		request.put ("account", nano::dev::genesis_key.pub.to_account ());
4389  		request.put ("representative", nano::dev::genesis_key.pub.to_account ());
4390  		request.put ("balance", (nano::dev::constants.genesis_amount - nano::Gxrb_ratio).convert_to<std::string> ());
4391  		request.put ("link", key.pub.to_account ());
4392  		request.put ("previous", previous);
4393  		auto response (wait_response (system, rpc_ctx, request));
4394  		boost::property_tree::ptree block_l;
4395  		std::stringstream block_stream (response.get<std::string> ("block"));
4396  		boost::property_tree::read_json (block_stream, block_l);
4397  		auto block (nano::deserialize_block_json (block_l));
4398  		ASSERT_NE (nullptr, block);
4399  		ASSERT_GE (nano::dev::network_params.work.difficulty (*block), node->default_difficulty (nano::work_version::work_1));
4400  	}
4401  }
4402  TEST (rpc, block_create_open_epoch_v2)
4403  {
4404  	nano::test::system system;
4405  	auto node = add_ipc_enabled_node (system);
4406  	nano::keypair key;
4407  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
4408  	ASSERT_NE (nullptr, system.upgrade_genesis_epoch (*node, nano::epoch::epoch_1));
4409  	ASSERT_NE (nullptr, system.upgrade_genesis_epoch (*node, nano::epoch::epoch_2));
4410  	auto send_block (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key.pub, nano::Gxrb_ratio));
4411  	ASSERT_NE (nullptr, send_block);
4412  	auto const rpc_ctx = add_rpc (system, node);
4413  	boost::property_tree::ptree request;
4414  	request.put ("action", "block_create");
4415  	request.put ("type", "state");
4416  	request.put ("key", key.prv.to_string ());
4417  	request.put ("account", key.pub.to_account ());
4418  	request.put ("previous", 0);
4419  	request.put ("representative", nano::dev::genesis_key.pub.to_account ());
4420  	request.put ("balance", nano::Gxrb_ratio.convert_to<std::string> ());
4421  	request.put ("link", send_block->hash ().to_string ());
4422  	auto response (wait_response (system, rpc_ctx, request));
4423  	std::string state_hash (response.get<std::string> ("hash"));
4424  	auto state_text (response.get<std::string> ("block"));
4425  	std::stringstream block_stream (state_text);
4426  	boost::property_tree::ptree block_l;
4427  	boost::property_tree::read_json (block_stream, block_l);
4428  	auto state_block (nano::deserialize_block_json (block_l));
4429  	ASSERT_NE (nullptr, state_block);
4430  	ASSERT_EQ (nano::block_type::state, state_block->type ());
4431  	ASSERT_EQ (state_hash, state_block->hash ().to_string ());
4432  	auto difficulty (nano::dev::network_params.work.difficulty (*state_block));
4433  	ASSERT_GT (difficulty, nano::dev::network_params.work.threshold (state_block->work_version (), nano::block_details (nano::epoch::epoch_2, false, true, false)));
4434  	ASSERT_TRUE (node->latest (key.pub).is_zero ());
4435  	auto process_result (node->process (*state_block));
4436  	ASSERT_EQ (nano::process_result::progress, process_result.code);
4437  	ASSERT_EQ (state_block->sideband ().details.epoch, nano::epoch::epoch_2);
4438  	ASSERT_TRUE (state_block->sideband ().details.is_receive);
4439  	ASSERT_FALSE (node->latest (key.pub).is_zero ());
4440  }
4441  TEST (rpc, block_create_receive_epoch_v2)
4442  {
4443  	nano::test::system system;
4444  	auto node = add_ipc_enabled_node (system);
4445  	nano::keypair key;
4446  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
4447  	ASSERT_NE (nullptr, system.upgrade_genesis_epoch (*node, nano::epoch::epoch_1));
4448  	auto send_block (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key.pub, nano::Gxrb_ratio));
4449  	ASSERT_NE (nullptr, send_block);
4450  	nano::block_builder builder;
4451  	auto open = builder
4452  				.state ()
4453  				.account (key.pub)
4454  				.previous (0)
4455  				.representative (nano::dev::genesis_key.pub)
4456  				.balance (nano::Gxrb_ratio)
4457  				.link (send_block->hash ())
4458  				.sign (key.prv, key.pub)
4459  				.work (*node->work_generate_blocking (key.pub))
4460  				.build ();
4461  	ASSERT_EQ (nano::process_result::progress, node->process (*open).code);
4462  	ASSERT_NE (nullptr, system.upgrade_genesis_epoch (*node, nano::epoch::epoch_2));
4463  	auto send_block_2 (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key.pub, nano::Gxrb_ratio));
4464  	auto const rpc_ctx = add_rpc (system, node);
4465  	boost::property_tree::ptree request;
4466  	request.put ("action", "block_create");
4467  	request.put ("type", "state");
4468  	request.put ("key", key.prv.to_string ());
4469  	request.put ("account", key.pub.to_account ());
4470  	request.put ("previous", open->hash ().to_string ());
4471  	request.put ("representative", nano::dev::genesis_key.pub.to_account ());
4472  	request.put ("balance", (2 * nano::Gxrb_ratio).convert_to<std::string> ());
4473  	request.put ("link", send_block_2->hash ().to_string ());
4474  	auto response (wait_response (system, rpc_ctx, request));
4475  	std::string state_hash (response.get<std::string> ("hash"));
4476  	auto state_text (response.get<std::string> ("block"));
4477  	std::stringstream block_stream (state_text);
4478  	boost::property_tree::ptree block_l;
4479  	boost::property_tree::read_json (block_stream, block_l);
4480  	auto state_block (nano::deserialize_block_json (block_l));
4481  	ASSERT_NE (nullptr, state_block);
4482  	ASSERT_EQ (nano::block_type::state, state_block->type ());
4483  	ASSERT_EQ (state_hash, state_block->hash ().to_string ());
4484  	auto difficulty (nano::dev::network_params.work.difficulty (*state_block));
4485  	ASSERT_GT (difficulty, nano::dev::network_params.work.threshold (state_block->work_version (), nano::block_details (nano::epoch::epoch_2, false, true, false)));
4486  	auto process_result (node->process (*state_block));
4487  	ASSERT_EQ (nano::process_result::progress, process_result.code);
4488  	ASSERT_EQ (state_block->sideband ().details.epoch, nano::epoch::epoch_2);
4489  	ASSERT_TRUE (state_block->sideband ().details.is_receive);
4490  	ASSERT_FALSE (node->latest (key.pub).is_zero ());
4491  }
4492  TEST (rpc, block_create_send_epoch_v2)
4493  {
4494  	nano::test::system system;
4495  	auto node = add_ipc_enabled_node (system);
4496  	nano::keypair key;
4497  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
4498  	ASSERT_NE (nullptr, system.upgrade_genesis_epoch (*node, nano::epoch::epoch_1));
4499  	ASSERT_NE (nullptr, system.upgrade_genesis_epoch (*node, nano::epoch::epoch_2));
4500  	auto send_block (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key.pub, nano::Gxrb_ratio));
4501  	ASSERT_NE (nullptr, send_block);
4502  	nano::block_builder builder;
4503  	auto open = builder
4504  				.state ()
4505  				.account (key.pub)
4506  				.previous (0)
4507  				.representative (nano::dev::genesis_key.pub)
4508  				.balance (nano::Gxrb_ratio)
4509  				.link (send_block->hash ())
4510  				.sign (key.prv, key.pub)
4511  				.work (*node->work_generate_blocking (key.pub))
4512  				.build ();
4513  	ASSERT_EQ (nano::process_result::progress, node->process (*open).code);
4514  	auto const rpc_ctx = add_rpc (system, node);
4515  	boost::property_tree::ptree request;
4516  	request.put ("action", "block_create");
4517  	request.put ("type", "state");
4518  	request.put ("key", key.prv.to_string ());
4519  	request.put ("account", key.pub.to_account ());
4520  	request.put ("previous", open->hash ().to_string ());
4521  	request.put ("representative", nano::dev::genesis_key.pub.to_account ());
4522  	request.put ("balance", 0);
4523  	request.put ("link", nano::dev::genesis_key.pub.to_string ());
4524  	auto response (wait_response (system, rpc_ctx, request));
4525  	std::string state_hash (response.get<std::string> ("hash"));
4526  	auto state_text (response.get<std::string> ("block"));
4527  	std::stringstream block_stream (state_text);
4528  	boost::property_tree::ptree block_l;
4529  	boost::property_tree::read_json (block_stream, block_l);
4530  	auto state_block (nano::deserialize_block_json (block_l));
4531  	ASSERT_NE (nullptr, state_block);
4532  	ASSERT_EQ (nano::block_type::state, state_block->type ());
4533  	ASSERT_EQ (state_hash, state_block->hash ().to_string ());
4534  	auto difficulty (nano::dev::network_params.work.difficulty (*state_block));
4535  	ASSERT_GT (difficulty, nano::dev::network_params.work.threshold (state_block->work_version (), nano::block_details (nano::epoch::epoch_2, true, false, false)));
4536  	auto process_result (node->process (*state_block));
4537  	ASSERT_EQ (nano::process_result::progress, process_result.code);
4538  	ASSERT_EQ (state_block->sideband ().details.epoch, nano::epoch::epoch_2);
4539  	ASSERT_TRUE (state_block->sideband ().details.is_send);
4540  	ASSERT_FALSE (node->latest (key.pub).is_zero ());
4541  }
4542  TEST (rpc, block_hash)
4543  {
4544  	nano::test::system system;
4545  	auto node1 = add_ipc_enabled_node (system);
4546  	auto const rpc_ctx = add_rpc (system, node1);
4547  	nano::keypair key;
4548  	auto latest (node1->latest (nano::dev::genesis_key.pub));
4549  	nano::block_builder builder;
4550  	auto send = builder
4551  				.send ()
4552  				.previous (latest)
4553  				.destination (key.pub)
4554  				.balance (100)
4555  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
4556  				.work (*node1->work_generate_blocking (latest))
4557  				.build ();
4558  	boost::property_tree::ptree request;
4559  	request.put ("action", "block_hash");
4560  	std::string json;
4561  	send->serialize_json (json);
4562  	request.put ("block", json);
4563  	auto response (wait_response (system, rpc_ctx, request));
4564  	std::string send_hash (response.get<std::string> ("hash"));
4565  	ASSERT_EQ (send->hash ().to_string (), send_hash);
4566  }
4567  TEST (rpc, wallet_lock)
4568  {
4569  	nano::test::system system;
4570  	auto node = add_ipc_enabled_node (system);
4571  	auto const rpc_ctx = add_rpc (system, node);
4572  	boost::property_tree::ptree request;
4573  	std::string wallet;
4574  	node->wallets.items.begin ()->first.encode_hex (wallet);
4575  	{
4576  		auto transaction (system.wallet (0)->wallets.tx_begin_read ());
4577  		ASSERT_TRUE (system.wallet (0)->store.valid_password (transaction));
4578  	}
4579  	request.put ("wallet", wallet);
4580  	request.put ("action", "wallet_lock");
4581  	auto response (wait_response (system, rpc_ctx, request));
4582  	std::string account_text1 (response.get<std::string> ("locked"));
4583  	ASSERT_EQ (account_text1, "1");
4584  	auto transaction (system.wallet (0)->wallets.tx_begin_read ());
4585  	ASSERT_FALSE (system.wallet (0)->store.valid_password (transaction));
4586  }
4587  TEST (rpc, wallet_locked)
4588  {
4589  	nano::test::system system;
4590  	auto node = add_ipc_enabled_node (system);
4591  	auto const rpc_ctx = add_rpc (system, node);
4592  	boost::property_tree::ptree request;
4593  	std::string wallet;
4594  	node->wallets.items.begin ()->first.encode_hex (wallet);
4595  	request.put ("wallet", wallet);
4596  	request.put ("action", "wallet_locked");
4597  	auto response (wait_response (system, rpc_ctx, request));
4598  	std::string account_text1 (response.get<std::string> ("locked"));
4599  	ASSERT_EQ (account_text1, "0");
4600  }
4601  TEST (rpc, wallet_create_fail)
4602  {
4603  	nano::test::system system;
4604  	auto node = add_ipc_enabled_node (system);
4605  	for (int i = 0; i < 127; i++)
4606  	{
4607  		node->wallets.create (nano::random_wallet_id ());
4608  	}
4609  	auto const rpc_ctx = add_rpc (system, node);
4610  	boost::property_tree::ptree request;
4611  	request.put ("action", "wallet_create");
4612  	auto response (wait_response (system, rpc_ctx, request));
4613  	ASSERT_EQ (std::error_code (nano::error_common::wallet_lmdb_max_dbs).message (), response.get<std::string> ("error"));
4614  }
4615  TEST (rpc, wallet_ledger)
4616  {
4617  	nano::test::system system;
4618  	auto node1 = add_ipc_enabled_node (system);
4619  	nano::keypair key;
4620  	system.wallet (0)->insert_adhoc (key.prv);
4621  	auto latest (node1->latest (nano::dev::genesis_key.pub));
4622  	nano::block_builder builder;
4623  	auto send = builder
4624  				.send ()
4625  				.previous (latest)
4626  				.destination (key.pub)
4627  				.balance (100)
4628  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
4629  				.work (*node1->work_generate_blocking (latest))
4630  				.build ();
4631  	ASSERT_EQ (nano::process_result::progress, node1->process (*send).code);
4632  	auto open = builder
4633  				.open ()
4634  				.source (send->hash ())
4635  				.representative (nano::dev::genesis_key.pub)
4636  				.account (key.pub)
4637  				.sign (key.prv, key.pub)
4638  				.work (*node1->work_generate_blocking (key.pub))
4639  				.build ();
4640  	ASSERT_EQ (nano::process_result::progress, node1->process (*open).code);
4641  	auto time = nano::seconds_since_epoch ();
4642  	auto const rpc_ctx = add_rpc (system, node1);
4643  	boost::property_tree::ptree request;
4644  	request.put ("action", "wallet_ledger");
4645  	request.put ("wallet", node1->wallets.items.begin ()->first.to_string ());
4646  	request.put ("sorting", "1");
4647  	request.put ("count", "1");
4648  	auto response (wait_response (system, rpc_ctx, request));
4649  	for (auto & accounts : response.get_child ("accounts"))
4650  	{
4651  		std::string account_text (accounts.first);
4652  		ASSERT_EQ (key.pub.to_account (), account_text);
4653  		std::string frontier (accounts.second.get<std::string> ("frontier"));
4654  		ASSERT_EQ (open->hash ().to_string (), frontier);
4655  		std::string open_block (accounts.second.get<std::string> ("open_block"));
4656  		ASSERT_EQ (open->hash ().to_string (), open_block);
4657  		std::string representative_block (accounts.second.get<std::string> ("representative_block"));
4658  		ASSERT_EQ (open->hash ().to_string (), representative_block);
4659  		std::string balance_text (accounts.second.get<std::string> ("balance"));
4660  		ASSERT_EQ ("340282366920938463463374607431768211355", balance_text);
4661  		std::string modified_timestamp (accounts.second.get<std::string> ("modified_timestamp"));
4662  		ASSERT_LT (std::abs ((long)time - stol (modified_timestamp)), 5);
4663  		std::string block_count (accounts.second.get<std::string> ("block_count"));
4664  		ASSERT_EQ ("1", block_count);
4665  		boost::optional<std::string> weight (accounts.second.get_optional<std::string> ("weight"));
4666  		ASSERT_FALSE (weight.is_initialized ());
4667  		boost::optional<std::string> pending (accounts.second.get_optional<std::string> ("pending"));
4668  		ASSERT_FALSE (pending.is_initialized ());
4669  		boost::optional<std::string> representative (accounts.second.get_optional<std::string> ("representative"));
4670  		ASSERT_FALSE (representative.is_initialized ());
4671  	}
4672  	request.put ("weight", "true");
4673  	request.put ("pending", "1");
4674  	request.put ("representative", "false");
4675  	auto response2 (wait_response (system, rpc_ctx, request));
4676  	for (auto & accounts : response2.get_child ("accounts"))
4677  	{
4678  		boost::optional<std::string> weight (accounts.second.get_optional<std::string> ("weight"));
4679  		ASSERT_TRUE (weight.is_initialized ());
4680  		ASSERT_EQ ("0", weight.get ());
4681  		boost::optional<std::string> pending (accounts.second.get_optional<std::string> ("pending"));
4682  		ASSERT_TRUE (pending.is_initialized ());
4683  		ASSERT_EQ ("0", pending.get ());
4684  		boost::optional<std::string> representative (accounts.second.get_optional<std::string> ("representative"));
4685  		ASSERT_FALSE (representative.is_initialized ());
4686  	}
4687  }
4688  TEST (rpc, wallet_add_watch)
4689  {
4690  	nano::test::system system;
4691  	auto node = add_ipc_enabled_node (system);
4692  	auto const rpc_ctx = add_rpc (system, node);
4693  	boost::property_tree::ptree request;
4694  	std::string wallet;
4695  	node->wallets.items.begin ()->first.encode_hex (wallet);
4696  	request.put ("wallet", wallet);
4697  	request.put ("action", "wallet_add_watch");
4698  	boost::property_tree::ptree entry;
4699  	boost::property_tree::ptree peers_l;
4700  	entry.put ("", nano::dev::genesis_key.pub.to_account ());
4701  	peers_l.push_back (std::make_pair ("", entry));
4702  	request.add_child ("accounts", peers_l);
4703  	auto response (wait_response (system, rpc_ctx, request));
4704  	std::string success (response.get<std::string> ("success"));
4705  	ASSERT_TRUE (success.empty ());
4706  	ASSERT_TRUE (system.wallet (0)->exists (nano::dev::genesis_key.pub));
4707  	nano::public_key bad_key (1);
4708  	entry.put ("", bad_key.to_account ());
4709  	peers_l.push_back (std::make_pair ("", entry));
4710  	request.erase ("accounts");
4711  	request.add_child ("accounts", peers_l);
4712  	auto response_error (wait_response (system, rpc_ctx, request));
4713  	std::error_code ec (nano::error_common::bad_public_key);
4714  	ASSERT_EQ (response_error.get<std::string> ("error"), ec.message ());
4715  }
4716  TEST (rpc, online_reps)
4717  {
4718  	nano::test::system system (1);
4719  	auto node1 (system.nodes[0]);
4720  	auto node2 = add_ipc_enabled_node (system);
4721  	nano::keypair key;
4722  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
4723  	ASSERT_EQ (node2->online_reps.online (), 0);
4724  	auto send_block (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key.pub, nano::Gxrb_ratio));
4725  	ASSERT_NE (nullptr, send_block);
4726  	ASSERT_TIMELY (10s, !node2->online_reps.list ().empty ());
4727  	ASSERT_EQ (node2->online_reps.online (), nano::dev::constants.genesis_amount - nano::Gxrb_ratio);
4728  	auto const rpc_ctx = add_rpc (system, node2);
4729  	boost::property_tree::ptree request;
4730  	request.put ("action", "representatives_online");
4731  	auto response (wait_response (system, rpc_ctx, request));
4732  	auto representatives (response.get_child ("representatives"));
4733  	auto item (representatives.begin ());
4734  	ASSERT_NE (representatives.end (), item);
4735  	ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), item->second.get<std::string> (""));
4736  	boost::optional<std::string> weight (item->second.get_optional<std::string> ("weight"));
4737  	ASSERT_FALSE (weight.is_initialized ());
4738  	ASSERT_TIMELY (5s, node2->block (send_block->hash ()));
4739  	request.put ("weight", "true");
4740  	auto response2 (wait_response (system, rpc_ctx, request));
4741  	auto representatives2 (response2.get_child ("representatives"));
4742  	auto item2 (representatives2.begin ());
4743  	ASSERT_NE (representatives2.end (), item2);
4744  	ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), item2->first);
4745  	auto weight2 (item2->second.get<std::string> ("weight"));
4746  	ASSERT_EQ (node2->weight (nano::dev::genesis_key.pub).convert_to<std::string> (), weight2);
4747  	auto new_rep (system.wallet (1)->deterministic_insert ());
4748  	auto send (system.wallet (0)->send_action (nano::dev::genesis_key.pub, new_rep, node1->config.receive_minimum.number ()));
4749  	ASSERT_NE (nullptr, send);
4750  	ASSERT_TIMELY (10s, node2->block (send->hash ()));
4751  	auto receive (system.wallet (1)->receive_action (send->hash (), new_rep, node1->config.receive_minimum.number (), send->link ().as_account ()));
4752  	ASSERT_NE (nullptr, receive);
4753  	ASSERT_TIMELY (5s, node2->block (receive->hash ()));
4754  	auto change (system.wallet (0)->change_action (nano::dev::genesis_key.pub, new_rep));
4755  	ASSERT_NE (nullptr, change);
4756  	ASSERT_TIMELY (5s, node2->block (change->hash ()));
4757  	ASSERT_TIMELY (5s, node2->online_reps.list ().size () == 2);
4758  	boost::property_tree::ptree child_rep;
4759  	child_rep.put ("", new_rep.to_account ());
4760  	boost::property_tree::ptree filtered_accounts;
4761  	filtered_accounts.push_back (std::make_pair ("", child_rep));
4762  	request.add_child ("accounts", filtered_accounts);
4763  	auto response3 (wait_response (system, rpc_ctx, request, 10s));
4764  	auto representatives3 (response3.get_child ("representatives"));
4765  	auto item3 (representatives3.begin ());
4766  	ASSERT_NE (representatives3.end (), item3);
4767  	ASSERT_EQ (new_rep.to_account (), item3->first);
4768  	ASSERT_EQ (representatives3.size (), 1);
4769  	node2->stop ();
4770  }
4771  TEST (rpc, confirmation_height_currently_processing)
4772  {
4773  	nano::test::system system;
4774  	nano::node_flags node_flags;
4775  	node_flags.force_use_write_database_queue = true;
4776  	nano::node_config node_config = system.default_config ();
4777  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
4778  	auto node = add_ipc_enabled_node (system, node_config, node_flags);
4779  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
4780  	auto previous_genesis_chain_hash = node->latest (nano::dev::genesis_key.pub);
4781  	{
4782  		auto transaction = node->store.tx_begin_write ();
4783  		nano::keypair key1;
4784  		nano::block_builder builder;
4785  		auto send = builder
4786  					.send ()
4787  					.previous (previous_genesis_chain_hash)
4788  					.destination (key1.pub)
4789  					.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio - 1)
4790  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
4791  					.work (*system.work.generate (previous_genesis_chain_hash))
4792  					.build ();
4793  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *send).code);
4794  		previous_genesis_chain_hash = send->hash ();
4795  	}
4796  	std::shared_ptr<nano::block> frontier;
4797  	{
4798  		auto transaction = node->store.tx_begin_read ();
4799  		frontier = node->store.block.get (transaction, previous_genesis_chain_hash);
4800  	}
4801  	boost::property_tree::ptree request;
4802  	request.put ("action", "confirmation_height_currently_processing");
4803  	auto const rpc_ctx = add_rpc (system, node);
4804  	{
4805  		auto write_guard = node->write_database_queue.wait (nano::writer::testing);
4806  		nano::test::start_election (system, *node, frontier->hash ());
4807  		ASSERT_TIMELY (5s, node->confirmation_height_processor.current () == frontier->hash ());
4808  		{
4809  			auto response (wait_response (system, rpc_ctx, request, 10s));
4810  			auto hash (response.get<std::string> ("hash"));
4811  			ASSERT_EQ (frontier->hash ().to_string (), hash);
4812  		}
4813  	}
4814  	ASSERT_TIMELY (10s, node->confirmation_height_processor.current ().is_zero () && node->confirmation_height_processor.awaiting_processing_size () == 0);
4815  	{
4816  		auto response (wait_response (system, rpc_ctx, request, 10s));
4817  		std::error_code ec (nano::error_rpc::confirmation_height_not_processing);
4818  		ASSERT_EQ (response.get<std::string> ("error"), ec.message ());
4819  	}
4820  }
4821  TEST (rpc, confirmation_history)
4822  {
4823  	nano::test::system system;
4824  	auto node = add_ipc_enabled_node (system);
4825  	nano::keypair key;
4826  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
4827  	ASSERT_TRUE (node->active.recently_cemented.list ().empty ());
4828  	auto block (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key.pub, nano::Gxrb_ratio));
4829  	ASSERT_TIMELY (10s, !node->active.recently_cemented.list ().empty ());
4830  	auto const rpc_ctx = add_rpc (system, node);
4831  	boost::property_tree::ptree request;
4832  	request.put ("action", "confirmation_history");
4833  	auto response (wait_response (system, rpc_ctx, request));
4834  	auto representatives (response.get_child ("confirmations"));
4835  	auto item (representatives.begin ());
4836  	ASSERT_NE (representatives.end (), item);
4837  	auto hash (item->second.get<std::string> ("hash"));
4838  	auto tally (item->second.get<std::string> ("tally"));
4839  	auto final_tally (item->second.get<std::string> ("final"));
4840  	ASSERT_EQ (1, item->second.count ("duration"));
4841  	ASSERT_EQ (1, item->second.count ("time"));
4842  	ASSERT_EQ (1, item->second.count ("request_count"));
4843  	ASSERT_EQ (1, item->second.count ("voters"));
4844  	ASSERT_GE (1U, item->second.get<unsigned> ("blocks"));
4845  	ASSERT_EQ (block->hash ().to_string (), hash);
4846  	nano::amount tally_num;
4847  	tally_num.decode_dec (tally);
4848  	debug_assert (tally_num == nano::dev::constants.genesis_amount || tally_num == (nano::dev::constants.genesis_amount - nano::Gxrb_ratio));
4849  	system.stop ();
4850  }
4851  TEST (rpc, confirmation_history_hash)
4852  {
4853  	nano::test::system system;
4854  	auto node = add_ipc_enabled_node (system);
4855  	nano::keypair key;
4856  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
<span onclick='openModal()' class='match'>4857  	ASSERT_TRUE (node->active.recently_cemented.list ().empty ());
4858  	auto send1 (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key.pub, nano::Gxrb_ratio));
4859  	auto send2 (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key.pub, nano::Gxrb_ratio));
</span>4860  	auto send3 (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key.pub, nano::Gxrb_ratio));
4861  	ASSERT_TIMELY (10s, node->active.recently_cemented.list ().size () == 3);
4862  	auto const rpc_ctx = add_rpc (system, node);
4863  	boost::property_tree::ptree request;
4864  	request.put ("action", "confirmation_history");
4865  	request.put ("hash", send2->hash ().to_string ());
4866  	auto response (wait_response (system, rpc_ctx, request));
4867  	auto representatives (response.get_child ("confirmations"));
4868  	ASSERT_EQ (representatives.size (), 1);
4869  	auto item (representatives.begin ());
4870  	ASSERT_NE (representatives.end (), item);
4871  	auto hash (item->second.get<std::string> ("hash"));
4872  	auto tally (item->second.get<std::string> ("tally"));
4873  	ASSERT_FALSE (item->second.get<std::string> ("duration", "").empty ());
4874  	ASSERT_FALSE (item->second.get<std::string> ("time", "").empty ());
4875  	ASSERT_EQ (send2->hash ().to_string (), hash);
4876  	nano::amount tally_num;
4877  	tally_num.decode_dec (tally);
4878  	debug_assert (tally_num == nano::dev::constants.genesis_amount || tally_num == (nano::dev::constants.genesis_amount - nano::Gxrb_ratio) || tally_num == (nano::dev::constants.genesis_amount - 2 * nano::Gxrb_ratio) || tally_num == (nano::dev::constants.genesis_amount - 3 * nano::Gxrb_ratio));
4879  	system.stop ();
4880  }
4881  TEST (rpc, block_confirm)
4882  {
4883  	nano::test::system system;
4884  	auto node = add_ipc_enabled_node (system);
4885  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
4886  	nano::block_builder builder;
4887  	auto send1 = builder
4888  				 .state ()
4889  				 .account (nano::dev::genesis_key.pub)
4890  				 .previous (nano::dev::genesis->hash ())
4891  				 .representative (nano::dev::genesis_key.pub)
4892  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
4893  				 .link (nano::dev::genesis_key.pub)
4894  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
4895  				 .work (*node->work_generate_blocking (nano::dev::genesis->hash ()))
4896  				 .build_shared ();
4897  	{
4898  		auto transaction (node->store.tx_begin_write ());
4899  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *send1).code);
4900  	}
4901  	auto const rpc_ctx = add_rpc (system, node);
4902  	boost::property_tree::ptree request;
4903  	request.put ("action", "block_confirm");
4904  	request.put ("hash", send1->hash ().to_string ());
4905  	auto response (wait_response (system, rpc_ctx, request));
4906  	ASSERT_EQ ("1", response.get<std::string> ("started"));
4907  }
4908  TEST (rpc, block_confirm_absent)
4909  {
4910  	nano::test::system system;
4911  	auto node = add_ipc_enabled_node (system);
4912  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
4913  	auto const rpc_ctx = add_rpc (system, node);
4914  	boost::property_tree::ptree request;
4915  	request.put ("action", "block_confirm");
4916  	request.put ("hash", "0");
4917  	auto response (wait_response (system, rpc_ctx, request));
4918  	ASSERT_EQ (std::error_code (nano::error_blocks::not_found).message (), response.get<std::string> ("error"));
4919  }
4920  TEST (rpc, block_confirm_confirmed)
4921  {
4922  	nano::test::system system (1);
4923  	auto path (nano::unique_path ());
4924  	nano::node_config config;
4925  	config.peering_port = system.get_available_port ();
4926  	config.callback_address = "localhost";
4927  	config.callback_port = system.get_available_port ();
4928  	config.callback_target = "/";
4929  	config.logging.init (path);
4930  	auto node = add_ipc_enabled_node (system, config);
4931  	{
4932  		auto transaction (node->store.tx_begin_read ());
4933  		ASSERT_TRUE (node->ledger.block_confirmed (transaction, nano::dev::genesis->hash ()));
4934  	}
4935  	ASSERT_EQ (0, node->stats.count (nano::stat::type::error, nano::stat::detail::http_callback, nano::stat::dir::out));
4936  	auto const rpc_ctx = add_rpc (system, node);
4937  	boost::property_tree::ptree request;
4938  	request.put ("action", "block_confirm");
4939  	request.put ("hash", nano::dev::genesis->hash ().to_string ());
4940  	auto response (wait_response (system, rpc_ctx, request));
4941  	ASSERT_EQ ("1", response.get<std::string> ("started"));
4942  	auto confirmed (node->active.recently_cemented.list ());
4943  	ASSERT_EQ (1, confirmed.size ());
4944  	ASSERT_EQ (nano::dev::genesis->hash (), confirmed.begin ()->winner->hash ());
4945  	ASSERT_TIMELY (10s, node->stats.count (nano::stat::type::error, nano::stat::detail::http_callback, nano::stat::dir::out) != 0);
4946  	ASSERT_EQ (1, node->stats.count (nano::stat::type::error, nano::stat::detail::http_callback, nano::stat::dir::out));
4947  	node->stop ();
4948  }
4949  TEST (rpc, node_id)
4950  {
4951  	nano::test::system system;
4952  	auto node = add_ipc_enabled_node (system);
4953  	auto const rpc_ctx = add_rpc (system, node);
4954  	boost::property_tree::ptree request;
4955  	request.put ("action", "node_id");
4956  	auto response (wait_response (system, rpc_ctx, request));
4957  	ASSERT_EQ (node->node_id.prv.to_string (), response.get<std::string> ("private"));
4958  	ASSERT_EQ (node->node_id.pub.to_account (), response.get<std::string> ("as_account"));
4959  	ASSERT_EQ (node->node_id.pub.to_node_id (), response.get<std::string> ("node_id"));
4960  }
4961  TEST (rpc, stats_clear)
4962  {
4963  	nano::test::system system;
4964  	auto node = add_ipc_enabled_node (system);
4965  	auto const rpc_ctx = add_rpc (system, node);
4966  	nano::keypair key;
4967  	node->stats.inc (nano::stat::type::ledger, nano::stat::dir::in);
4968  	ASSERT_EQ (1, node->stats.count (nano::stat::type::ledger, nano::stat::dir::in));
4969  	boost::property_tree::ptree request;
4970  	request.put ("action", "stats_clear");
4971  	auto response (wait_response (system, rpc_ctx, request));
4972  	std::string success (response.get<std::string> ("success"));
4973  	ASSERT_TRUE (success.empty ());
4974  	ASSERT_EQ (0, node->stats.count (nano::stat::type::ledger, nano::stat::dir::in));
4975  	ASSERT_LE (node->stats.last_reset ().count (), 5);
4976  }
4977  TEST (rpc, unchecked)
4978  {
4979  	nano::test::system system{};
4980  	auto node = add_ipc_enabled_node (system);
4981  	auto const rpc_ctx = add_rpc (system, node);
4982  	nano::keypair key{};
4983  	nano::block_builder builder;
4984  	auto open = builder
4985  				.state ()
4986  				.account (key.pub)
4987  				.previous (0)
4988  				.representative (key.pub)
4989  				.balance (1)
4990  				.link (key.pub)
4991  				.sign (key.prv, key.pub)
4992  				.work (*system.work.generate (key.pub))
4993  				.build_shared ();
4994  	auto open2 = builder
4995  				 .state ()
4996  				 .account (key.pub)
4997  				 .previous (0)
4998  				 .representative (key.pub)
4999  				 .balance (2)
5000  				 .link (key.pub)
5001  				 .sign (key.prv, key.pub)
5002  				 .work (*system.work.generate (key.pub))
5003  				 .build_shared ();
5004  	node->process_active (open);
5005  	node->process_active (open2);
5006  	ASSERT_TIMELY (10s, 2 == node->unchecked.count ());
5007  	boost::property_tree::ptree request;
5008  	request.put ("action", "unchecked");
5009  	request.put ("count", 2);
5010  	{
5011  		auto response (wait_response (system, rpc_ctx, request));
5012  		auto & blocks (response.get_child ("blocks"));
5013  		ASSERT_EQ (2, blocks.size ());
5014  		ASSERT_EQ (1, blocks.count (open->hash ().to_string ()));
5015  		ASSERT_EQ (1, blocks.count (open2->hash ().to_string ()));
5016  	}
5017  	request.put ("json_block", true);
5018  	{
5019  		auto response (wait_response (system, rpc_ctx, request));
5020  		auto & blocks (response.get_child ("blocks"));
5021  		ASSERT_EQ (2, blocks.size ());
5022  		auto & open_block (blocks.get_child (open->hash ().to_string ()));
5023  		ASSERT_EQ ("state", open_block.get<std::string> ("type"));
5024  	}
5025  }
5026  TEST (rpc, unchecked_get)
5027  {
5028  	nano::test::system system{};
5029  	auto node = add_ipc_enabled_node (system);
5030  	auto const rpc_ctx = add_rpc (system, node);
5031  	nano::keypair key{};
5032  	nano::block_builder builder;
5033  	auto open = builder
5034  				.state ()
5035  				.account (key.pub)
5036  				.previous (0)
5037  				.representative (key.pub)
5038  				.balance (1)
5039  				.link (key.pub)
5040  				.sign (key.prv, key.pub)
5041  				.work (*system.work.generate (key.pub))
5042  				.build_shared ();
5043  	node->process_active (open);
5044  	ASSERT_TIMELY (10s, 1 == node->unchecked.count ());
5045  	boost::property_tree::ptree request{};
5046  	request.put ("action", "unchecked_get");
5047  	request.put ("hash", open->hash ().to_string ());
5048  	{
5049  		auto response (wait_response (system, rpc_ctx, request));
5050  		ASSERT_EQ (1, response.count ("contents"));
5051  		auto timestamp (response.get<nano::seconds_t> ("modified_timestamp"));
5052  		ASSERT_LE (timestamp, nano::seconds_since_epoch ());
5053  	}
5054  	request.put ("json_block", true);
5055  	{
5056  		auto response (wait_response (system, rpc_ctx, request));
5057  		auto & contents (response.get_child ("contents"));
5058  		ASSERT_EQ ("state", contents.get<std::string> ("type"));
5059  		auto timestamp (response.get<nano::seconds_t> ("modified_timestamp"));
5060  		ASSERT_LE (timestamp, nano::seconds_since_epoch ());
5061  	}
5062  }
5063  TEST (rpc, unchecked_clear)
5064  {
5065  	nano::test::system system{};
5066  	auto node = add_ipc_enabled_node (system);
5067  	auto const rpc_ctx = add_rpc (system, node);
5068  	nano::keypair key{};
5069  	nano::block_builder builder;
5070  	auto open = builder
5071  				.state ()
5072  				.account (key.pub)
5073  				.previous (0)
5074  				.representative (key.pub)
5075  				.balance (1)
5076  				.link (key.pub)
5077  				.sign (key.prv, key.pub)
5078  				.work (*system.work.generate (key.pub))
5079  				.build_shared ();
5080  	node->process_active (open);
5081  	boost::property_tree::ptree request{};
5082  	ASSERT_TIMELY (10s, 1 == node->unchecked.count ());
5083  	request.put ("action", "unchecked_clear");
5084  	auto response = wait_response (system, rpc_ctx, request);
5085  	ASSERT_TIMELY (10s, 0 == node->unchecked.count ());
5086  }
5087  TEST (rpc, unopened)
5088  {
5089  	nano::test::system system;
5090  	auto node = add_ipc_enabled_node (system);
5091  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
5092  	nano::account account1 (1), account2 (account1.number () + 1);
5093  	auto genesis (node->latest (nano::dev::genesis_key.pub));
5094  	ASSERT_FALSE (genesis.is_zero ());
5095  	auto send (system.wallet (0)->send_action (nano::dev::genesis_key.pub, account1, 1));
5096  	ASSERT_NE (nullptr, send);
5097  	auto send2 (system.wallet (0)->send_action (nano::dev::genesis_key.pub, account2, 10));
5098  	ASSERT_NE (nullptr, send2);
5099  	auto const rpc_ctx = add_rpc (system, node);
5100  	{
5101  		boost::property_tree::ptree request;
5102  		request.put ("action", "unopened");
5103  		auto response (wait_response (system, rpc_ctx, request));
5104  		auto & accounts (response.get_child ("accounts"));
5105  		ASSERT_EQ (2, accounts.size ());
5106  		ASSERT_EQ ("1", accounts.get<std::string> (account1.to_account ()));
5107  		ASSERT_EQ ("10", accounts.get<std::string> (account2.to_account ()));
5108  	}
5109  	{
5110  		boost::property_tree::ptree request;
5111  		request.put ("action", "unopened");
5112  		request.put ("account", account2.to_account ());
5113  		auto response (wait_response (system, rpc_ctx, request));
5114  		auto & accounts (response.get_child ("accounts"));
5115  		ASSERT_EQ (1, accounts.size ());
5116  		ASSERT_EQ ("10", accounts.get<std::string> (account2.to_account ()));
5117  	}
5118  	{
5119  		boost::property_tree::ptree request;
5120  		request.put ("action", "unopened");
5121  		request.put ("account", nano::account (account2.number () + 1).to_account ());
5122  		auto response (wait_response (system, rpc_ctx, request));
5123  		auto & accounts (response.get_child ("accounts"));
5124  		ASSERT_EQ (0, accounts.size ());
5125  	}
5126  	{
5127  		boost::property_tree::ptree request;
5128  		request.put ("action", "unopened");
5129  		request.put ("count", "1");
5130  		auto response (wait_response (system, rpc_ctx, request));
5131  		auto & accounts (response.get_child ("accounts"));
5132  		ASSERT_EQ (1, accounts.size ());
5133  		ASSERT_EQ ("1", accounts.get<std::string> (account1.to_account ()));
5134  	}
5135  	{
5136  		boost::property_tree::ptree request;
5137  		request.put ("action", "unopened");
5138  		request.put ("threshold", 5);
5139  		auto response (wait_response (system, rpc_ctx, request));
5140  		auto & accounts (response.get_child ("accounts"));
5141  		ASSERT_EQ (1, accounts.size ());
5142  		ASSERT_EQ ("10", accounts.get<std::string> (account2.to_account ()));
5143  	}
5144  }
5145  TEST (rpc, unopened_burn)
5146  {
5147  	nano::test::system system;
5148  	auto node = add_ipc_enabled_node (system);
5149  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
5150  	auto genesis (node->latest (nano::dev::genesis_key.pub));
5151  	ASSERT_FALSE (genesis.is_zero ());
5152  	auto send (system.wallet (0)->send_action (nano::dev::genesis_key.pub, nano::dev::constants.burn_account, 1));
5153  	ASSERT_NE (nullptr, send);
5154  	auto const rpc_ctx = add_rpc (system, node);
5155  	boost::property_tree::ptree request;
5156  	request.put ("action", "unopened");
5157  	auto response (wait_response (system, rpc_ctx, request));
5158  	auto & accounts (response.get_child ("accounts"));
5159  	ASSERT_EQ (0, accounts.size ());
5160  }
5161  TEST (rpc, unopened_no_accounts)
5162  {
5163  	nano::test::system system;
5164  	auto node = add_ipc_enabled_node (system);
5165  	auto const rpc_ctx = add_rpc (system, node);
5166  	boost::property_tree::ptree request;
5167  	request.put ("action", "unopened");
5168  	auto response (wait_response (system, rpc_ctx, request));
5169  	auto & accounts (response.get_child ("accounts"));
5170  	ASSERT_EQ (0, accounts.size ());
5171  }
5172  TEST (rpc, uptime)
5173  {
5174  	nano::test::system system;
5175  	auto node = add_ipc_enabled_node (system);
5176  	auto const rpc_ctx = add_rpc (system, node);
5177  	boost::property_tree::ptree request;
5178  	request.put ("action", "uptime");
5179  	std::this_thread::sleep_for (std::chrono::seconds (1));
5180  	auto response (wait_response (system, rpc_ctx, request));
5181  	ASSERT_LE (1, response.get<int> ("seconds"));
5182  }
5183  TEST (rpc, DISABLED_wallet_history)
5184  {
5185  	nano::test::system system;
5186  	nano::node_config node_config = system.default_config ();
5187  	node_config.enable_voting = false;
5188  	auto node = add_ipc_enabled_node (system, node_config);
5189  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
5190  	auto timestamp1 = nano::seconds_since_epoch ();
5191  	auto send (system.wallet (0)->send_action (nano::dev::genesis_key.pub, nano::dev::genesis_key.pub, node->config.receive_minimum.number ()));
5192  	ASSERT_NE (nullptr, send);
5193  	auto timestamp2 = nano::seconds_since_epoch ();
5194  	auto receive (system.wallet (0)->receive_action (send->hash (), nano::dev::genesis_key.pub, node->config.receive_minimum.number (), send->link ().as_account ()));
5195  	ASSERT_NE (nullptr, receive);
5196  	nano::keypair key;
5197  	auto timestamp3 = nano::seconds_since_epoch ();
5198  	auto send2 (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key.pub, node->config.receive_minimum.number ()));
5199  	ASSERT_NE (nullptr, send2);
5200  	system.deadline_set (10s);
5201  	auto const rpc_ctx = add_rpc (system, node);
5202  	boost::property_tree::ptree request;
5203  	request.put ("action", "wallet_history");
5204  	request.put ("wallet", node->wallets.items.begin ()->first.to_string ());
5205  	auto response (wait_response (system, rpc_ctx, request));
5206  	std::vector<std::tuple<std::string, std::string, std::string, std::string, std::string, std::string>> history_l;
5207  	auto & history_node (response.get_child ("history"));
5208  	for (auto i (history_node.begin ()), n (history_node.end ()); i != n; ++i)
5209  	{
5210  		history_l.emplace_back (i->second.get<std::string> ("type"), i->second.get<std::string> ("account"), i->second.get<std::string> ("amount"), i->second.get<std::string> ("hash"), i->second.get<std::string> ("block_account"), i->second.get<std::string> ("local_timestamp"));
5211  	}
5212  	ASSERT_EQ (4, history_l.size ());
5213  	ASSERT_EQ ("send", std::get<0> (history_l[0]));
5214  	ASSERT_EQ (key.pub.to_account (), std::get<1> (history_l[0]));
5215  	ASSERT_EQ (node->config.receive_minimum.to_string_dec (), std::get<2> (history_l[0]));
5216  	ASSERT_EQ (send2->hash ().to_string (), std::get<3> (history_l[0]));
5217  	ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), std::get<4> (history_l[0]));
5218  	ASSERT_EQ (std::to_string (timestamp3), std::get<5> (history_l[0]));
5219  	ASSERT_EQ ("receive", std::get<0> (history_l[1]));
5220  	ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), std::get<1> (history_l[1]));
5221  	ASSERT_EQ (node->config.receive_minimum.to_string_dec (), std::get<2> (history_l[1]));
5222  	ASSERT_EQ (receive->hash ().to_string (), std::get<3> (history_l[1]));
5223  	ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), std::get<4> (history_l[1]));
5224  	ASSERT_EQ (std::to_string (timestamp2), std::get<5> (history_l[1]));
5225  	ASSERT_EQ ("send", std::get<0> (history_l[2]));
5226  	ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), std::get<1> (history_l[2]));
5227  	ASSERT_EQ (node->config.receive_minimum.to_string_dec (), std::get<2> (history_l[2]));
5228  	ASSERT_EQ (send->hash ().to_string (), std::get<3> (history_l[2]));
5229  	ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), std::get<4> (history_l[2]));
5230  	ASSERT_EQ (std::to_string (timestamp1), std::get<5> (history_l[2]));
5231  	ASSERT_EQ ("receive", std::get<0> (history_l[3]));
5232  	ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), std::get<1> (history_l[3]));
5233  	ASSERT_EQ (nano::dev::constants.genesis_amount.convert_to<std::string> (), std::get<2> (history_l[3]));
5234  	ASSERT_EQ (nano::dev::genesis->hash ().to_string (), std::get<3> (history_l[3]));
5235  	ASSERT_EQ (nano::dev::genesis_key.pub.to_account (), std::get<4> (history_l[3]));
5236  }
5237  TEST (rpc, sign_hash)
5238  {
5239  	nano::test::system system;
5240  	auto node1 = add_ipc_enabled_node (system);
5241  	nano::keypair key;
5242  	nano::block_builder builder;
5243  	auto send = builder
5244  				.state ()
5245  				.account (nano::dev::genesis->account ())
5246  				.previous (node1->latest (nano::dev::genesis_key.pub))
5247  				.representative (nano::dev::genesis->account ())
5248  				.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
5249  				.link (key.pub)
5250  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
5251  				.work (0)
5252  				.build ();
5253  	auto const rpc_ctx = add_rpc (system, node1);
5254  	boost::property_tree::ptree request;
5255  	request.put ("action", "sign");
5256  	request.put ("hash", send->hash ().to_string ());
5257  	request.put ("key", key.prv.to_string ());
5258  	auto response (wait_response (system, rpc_ctx, request, 10s));
5259  	std::error_code ec (nano::error_rpc::sign_hash_disabled);
5260  	ASSERT_EQ (response.get<std::string> ("error"), ec.message ());
5261  	rpc_ctx.node_rpc_config->enable_sign_hash = true;
5262  	auto response2 (wait_response (system, rpc_ctx, request, 10s));
5263  	nano::signature signature;
5264  	std::string signature_text (response2.get<std::string> ("signature"));
5265  	ASSERT_FALSE (signature.decode_hex (signature_text));
5266  	ASSERT_FALSE (nano::validate_message (key.pub, send->hash (), signature));
5267  }
5268  TEST (rpc, sign_block)
5269  {
5270  	nano::test::system system;
5271  	auto node1 = add_ipc_enabled_node (system);
5272  	nano::keypair key;
5273  	system.wallet (0)->insert_adhoc (key.prv);
5274  	nano::block_builder builder;
5275  	auto send = builder
5276  				.state ()
5277  				.account (nano::dev::genesis->account ())
5278  				.previous (node1->latest (nano::dev::genesis_key.pub))
5279  				.representative (nano::dev::genesis->account ())
5280  				.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
5281  				.link (key.pub)
5282  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
5283  				.work (0)
5284  				.build ();
5285  	auto const rpc_ctx = add_rpc (system, node1);
5286  	boost::property_tree::ptree request;
5287  	request.put ("action", "sign");
5288  	std::string wallet;
5289  	node1->wallets.items.begin ()->first.encode_hex (wallet);
5290  	request.put ("wallet", wallet);
5291  	request.put ("account", key.pub.to_account ());
5292  	std::string json;
5293  	send->serialize_json (json);
5294  	request.put ("block", json);
5295  	auto response (wait_response (system, rpc_ctx, request, 10s));
5296  	auto contents (response.get<std::string> ("block"));
5297  	boost::property_tree::ptree block_l;
5298  	std::stringstream block_stream (contents);
5299  	boost::property_tree::read_json (block_stream, block_l);
5300  	auto block (nano::deserialize_block_json (block_l));
5301  	ASSERT_FALSE (nano::validate_message (key.pub, send->hash (), block->block_signature ()));
5302  	ASSERT_NE (block->block_signature (), send->block_signature ());
5303  	ASSERT_EQ (block->hash (), send->hash ());
5304  }
5305  TEST (rpc, memory_stats)
5306  {
5307  	nano::test::system system;
5308  	auto node = add_ipc_enabled_node (system);
5309  	auto const rpc_ctx = add_rpc (system, node);
5310  	nano::keypair key;
5311  	nano::block_builder builder;
5312  	auto block = builder
5313  				 .state ()
5314  				 .account (0)
5315  				 .previous (0)
5316  				 .representative (0)
5317  				 .balance (0)
5318  				 .link (0)
5319  				 .sign (key.prv, key.pub)
5320  				 .work (0)
5321  				 .build_shared ();
5322  	std::vector<nano::block_hash> hashes;
5323  	hashes.push_back (block->hash ());
5324  	auto vote (std::make_shared<nano::vote> (key.pub, key.prv, 0, 0, hashes));
5325  	node->vote_uniquer.unique (vote);
5326  	boost::property_tree::ptree request;
5327  	request.put ("action", "stats");
5328  	request.put ("type", "objects");
5329  	{
5330  		auto response (wait_response (system, rpc_ctx, request));
5331  		ASSERT_EQ (response.get_child ("node").get_child ("vote_uniquer").get_child ("votes").get<std::string> ("count"), "1");
5332  	}
5333  	request.put ("type", "database");
5334  	{
5335  		auto response (wait_response (system, rpc_ctx, request));
5336  		ASSERT_TRUE (!response.empty ());
5337  	}
5338  }
5339  TEST (rpc, block_confirmed)
5340  {
5341  	nano::test::system system;
5342  	auto node = add_ipc_enabled_node (system);
5343  	auto const rpc_ctx = add_rpc (system, node);
5344  	boost::property_tree::ptree request;
5345  	request.put ("action", "block_info");
5346  	request.put ("hash", "bad_hash1337");
5347  	auto response (wait_response (system, rpc_ctx, request));
5348  	ASSERT_EQ (std::error_code (nano::error_blocks::invalid_block_hash).message (), response.get<std::string> ("error"));
5349  	request.put ("hash", "0");
5350  	auto response1 (wait_response (system, rpc_ctx, request));
5351  	ASSERT_EQ (std::error_code (nano::error_blocks::not_found).message (), response1.get<std::string> ("error"));
5352  	nano::keypair key;
5353  	nano::block_builder builder;
5354  	{
5355  		auto transaction = node->store.tx_begin_write ();
5356  		nano::block_hash latest (node->latest (nano::dev::genesis_key.pub));
5357  		auto send1 = builder
5358  					 .send ()
5359  					 .previous (latest)
5360  					 .destination (key.pub)
5361  					 .balance (300)
5362  					 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
5363  					 .work (*system.work.generate (latest))
5364  					 .build ();
5365  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *send1).code);
5366  		auto open1 = builder
5367  					 .open ()
5368  					 .source (send1->hash ())
5369  					 .representative (nano::dev::genesis->account ())
5370  					 .account (key.pub)
5371  					 .sign (key.prv, key.pub)
5372  					 .work (*system.work.generate (key.pub))
5373  					 .build ();
5374  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *open1).code);
5375  	}
5376  	nano::block_hash latest (node->latest (nano::dev::genesis_key.pub));
5377  	request.put ("hash", latest.to_string ());
5378  	auto response2 (wait_response (system, rpc_ctx, request));
5379  	ASSERT_FALSE (response2.get<bool> ("confirmed"));
5380  	auto send = builder
5381  				.send ()
5382  				.previous (latest)
5383  				.destination (key.pub)
5384  				.balance (10)
5385  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
5386  				.work (*system.work.generate (latest))
5387  				.build_shared ();
5388  	node->process_active (send);
5389  	ASSERT_TIMELY (5s, nano::test::confirm (*node, { send }));
5390  	ASSERT_TIMELY (5s, node->ledger.block_confirmed (node->store.tx_begin_read (), send->hash ()) && !node->confirmation_height_processor.is_processing_block (send->hash ()));
5391  	request.put ("hash", send->hash ().to_string ());
5392  	auto response3 (wait_response (system, rpc_ctx, request));
5393  	ASSERT_TRUE (response3.get<bool> ("confirmed"));
5394  }
5395  TEST (rpc, database_txn_tracker)
5396  {
5397  	if (nano::rocksdb_config::using_rocksdb_in_tests ())
5398  	{
5399  		return;
5400  	}
5401  	{
5402  		nano::test::system system;
5403  		auto node = add_ipc_enabled_node (system);
5404  		auto const rpc_ctx = add_rpc (system, node);
5405  		boost::property_tree::ptree request;
5406  		request.put ("action", "database_txn_tracker");
5407  		{
5408  			auto response (wait_response (system, rpc_ctx, request));
5409  			std::error_code ec (nano::error_common::tracking_not_enabled);
5410  			ASSERT_EQ (response.get<std::string> ("error"), ec.message ());
5411  		}
5412  	}
5413  	nano::test::system system;
5414  	nano::node_config node_config = system.default_config ();
5415  	node_config.diagnostics_config.txn_tracking.enable = true;
5416  	auto node = add_ipc_enabled_node (system, node_config);
5417  	auto const rpc_ctx = add_rpc (system, node);
5418  	boost::property_tree::ptree request;
5419  	auto check_not_correct_amount = [&system, &rpc_ctx, &request] () {
5420  		auto response (wait_response (system, rpc_ctx, request));
5421  		std::error_code ec (nano::error_common::invalid_amount);
5422  		ASSERT_EQ (response.get<std::string> ("error"), ec.message ());
5423  	};
5424  	request.put ("action", "database_txn_tracker");
5425  	request.put ("min_read_time", "not a time");
5426  	check_not_correct_amount ();
5427  	request.put ("min_read_time", "1000");
5428  	request.put ("min_write_time", "bad time");
5429  	check_not_correct_amount ();
5430  	request.put ("min_read_time", "1000000");
5431  	request.put ("min_write_time", "1000000");
5432  	std::promise<void> keep_txn_alive_promise;
5433  	std::promise<void> txn_created_promise;
5434  	std::thread thread ([&store = node->store, &keep_txn_alive_promise, &txn_created_promise] () {
5435  		nano::thread_role::set (nano::thread_role::name::rpc_process_container);
5436  		auto read_tx = store.tx_begin_read ();
5437  		std::this_thread::sleep_for (1s);
5438  		txn_created_promise.set_value ();
5439  		keep_txn_alive_promise.get_future ().wait ();
5440  	});
5441  	txn_created_promise.get_future ().wait ();
5442  	request.put ("min_read_time", "1000");
5443  	auto response (wait_response (system, rpc_ctx, request, 60s));
5444  	keep_txn_alive_promise.set_value ();
5445  	std::vector<std::tuple<std::string, std::string, std::string, std::vector<std::tuple<std::string, std::string, std::string, std::string>>>> json_l;
5446  	auto & json_node (response.get_child ("txn_tracking"));
5447  	for (auto & stat : json_node)
5448  	{
5449  		auto & stack_trace = stat.second.get_child ("stacktrace");
5450  		std::vector<std::tuple<std::string, std::string, std::string, std::string>> frames_json_l;
5451  		for (auto & frame : stack_trace)
5452  		{
5453  			frames_json_l.emplace_back (frame.second.get<std::string> ("name"), frame.second.get<std::string> ("address"), frame.second.get<std::string> ("source_file"), frame.second.get<std::string> ("source_line"));
5454  		}
5455  		json_l.emplace_back (stat.second.get<std::string> ("thread"), stat.second.get<std::string> ("time_held_open"), stat.second.get<std::string> ("write"), std::move (frames_json_l));
5456  	}
5457  	ASSERT_EQ (1, json_l.size ());
5458  	auto thread_name = nano::thread_role::get_string (nano::thread_role::name::rpc_process_container);
5459  	ASSERT_EQ (thread_name, std::get<0> (json_l.front ()));
5460  	ASSERT_LE (1000u, boost::lexical_cast<unsigned> (std::get<1> (json_l.front ())));
5461  	ASSERT_EQ ("false", std::get<2> (json_l.front ()));
5462  	ASSERT_TRUE (!std::get<3> (json_l.front ()).empty ());
5463  	thread.join ();
5464  }
5465  TEST (rpc, active_difficulty)
5466  {
5467  	nano::test::system system;
5468  	auto node = add_ipc_enabled_node (system);
5469  	auto const rpc_ctx = add_rpc (system, node);
5470  	ASSERT_EQ (node->default_difficulty (nano::work_version::work_1), node->network_params.work.epoch_2);
5471  	boost::property_tree::ptree request;
5472  	request.put ("action", "active_difficulty");
5473  	auto expected_multiplier{ 1.0 };
5474  	{
5475  		auto response (wait_response (system, rpc_ctx, request));
5476  		auto network_minimum_text (response.get<std::string> ("network_minimum"));
5477  		uint64_t network_minimum;
5478  		ASSERT_FALSE (nano::from_string_hex (network_minimum_text, network_minimum));
5479  		ASSERT_EQ (node->default_difficulty (nano::work_version::work_1), network_minimum);
5480  		auto network_receive_minimum_text (response.get<std::string> ("network_receive_minimum"));
5481  		uint64_t network_receive_minimum;
5482  		ASSERT_FALSE (nano::from_string_hex (network_receive_minimum_text, network_receive_minimum));
5483  		ASSERT_EQ (node->default_receive_difficulty (nano::work_version::work_1), network_receive_minimum);
5484  		auto multiplier (response.get<double> ("multiplier"));
5485  		ASSERT_NEAR (expected_multiplier, multiplier, 1e-6);
5486  		auto network_current_text (response.get<std::string> ("network_current"));
5487  		uint64_t network_current;
5488  		ASSERT_FALSE (nano::from_string_hex (network_current_text, network_current));
5489  		ASSERT_EQ (nano::difficulty::from_multiplier (expected_multiplier, node->default_difficulty (nano::work_version::work_1)), network_current);
5490  		auto network_receive_current_text (response.get<std::string> ("network_receive_current"));
5491  		uint64_t network_receive_current;
5492  		ASSERT_FALSE (nano::from_string_hex (network_receive_current_text, network_receive_current));
5493  		auto network_receive_current_multiplier (nano::difficulty::to_multiplier (network_receive_current, network_receive_minimum));
5494  		auto network_receive_current_normalized_multiplier (nano::dev::network_params.work.normalized_multiplier (network_receive_current_multiplier, network_receive_minimum));
5495  		ASSERT_NEAR (network_receive_current_normalized_multiplier, multiplier, 1e-6);
5496  		ASSERT_EQ (response.not_found (), response.find ("difficulty_trend"));
5497  	}
5498  	request.put ("include_trend", true);
5499  	{
5500  		auto response (wait_response (system, rpc_ctx, request));
5501  		auto trend_opt (response.get_child_optional ("difficulty_trend"));
5502  		ASSERT_TRUE (trend_opt.is_initialized ());
5503  		auto & trend (trend_opt.get ());
5504  		ASSERT_EQ (1, trend.size ());
5505  	}
5506  }
5507  TEST (rpc, simultaneous_calls)
5508  {
5509  	nano::test::system system;
5510  	auto node = add_ipc_enabled_node (system);
5511  	nano::thread_runner runner (system.io_ctx, node->config.io_threads);
5512  	nano::node_rpc_config node_rpc_config;
5513  	nano::ipc::ipc_server ipc_server (*node, node_rpc_config);
5514  	nano::rpc_config rpc_config{ nano::dev::network_params.network, system.get_available_port (), true };
5515  	const auto ipc_tcp_port = ipc_server.listening_tcp_port ();
5516  	ASSERT_TRUE (ipc_tcp_port.has_value ());
5517  	rpc_config.rpc_process.num_ipc_connections = 8;
5518  	nano::ipc_rpc_processor ipc_rpc_processor (system.io_ctx, rpc_config, ipc_tcp_port.value ());
5519  	nano::rpc rpc (system.io_ctx, rpc_config, ipc_rpc_processor);
5520  	rpc.start ();
5521  	boost::property_tree::ptree request;
5522  	request.put ("action", "account_block_count");
5523  	request.put ("account", nano::dev::genesis_key.pub.to_account ());
5524  	constexpr auto num = 100;
5525  	std::array<std::unique_ptr<test_response>, num> test_responses;
5526  	for (int i = 0; i < num; ++i)
5527  	{
5528  		test_responses[i] = std::make_unique<test_response> (request, system.io_ctx);
5529  	}
5530  	std::promise<void> promise;
5531  	std::atomic<int> count{ num };
5532  	for (int i = 0; i < num; ++i)
5533  	{
5534  		std::thread ([&test_responses, &promise, &count, i, port = rpc.listening_port ()] () {
5535  			test_responses[i]->run (port);
5536  			if (--count == 0)
5537  			{
5538  				promise.set_value ();
5539  			}
5540  		})
5541  		.detach ();
5542  	}
5543  	promise.get_future ().wait ();
5544  	ASSERT_TIMELY (60s, std::all_of (test_responses.begin (), test_responses.end (), [] (auto const & test_response) { return test_response->status != 0; }));
5545  	for (int i = 0; i < num; ++i)
5546  	{
5547  		ASSERT_EQ (200, test_responses[i]->status);
5548  		std::string block_count_text (test_responses[i]->json.get<std::string> ("block_count"));
5549  		ASSERT_EQ ("1", block_count_text);
5550  	}
5551  	rpc.stop ();
5552  	system.stop ();
5553  	ipc_server.stop ();
5554  	system.io_ctx.stop ();
5555  	runner.join ();
5556  }
5557  TEST (rpc, in_process)
5558  {
5559  	nano::test::system system;
5560  	auto node = add_ipc_enabled_node (system);
5561  	auto const rpc_ctx = add_rpc (system, node);
5562  	boost::property_tree::ptree request;
5563  	request.put ("action", "account_balance");
5564  	request.put ("account", nano::dev::genesis_key.pub.to_account ());
5565  	auto response (wait_response (system, rpc_ctx, request));
5566  	std::string balance_text (response.get<std::string> ("balance"));
5567  	ASSERT_EQ ("340282366920938463463374607431768211455", balance_text);
5568  	std::string pending_text (response.get<std::string> ("pending"));
5569  	ASSERT_EQ ("0", pending_text);
5570  }
5571  TEST (rpc, deprecated_account_format)
5572  {
5573  	nano::test::system system;
5574  	auto node = add_ipc_enabled_node (system);
5575  	auto const rpc_ctx = add_rpc (system, node);
5576  	boost::property_tree::ptree request;
5577  	request.put ("action", "account_info");
5578  	request.put ("account", nano::dev::genesis_key.pub.to_account ());
5579  	auto response (wait_response (system, rpc_ctx, request));
5580  	boost::optional<std::string> deprecated_account_format (response.get_optional<std::string> ("deprecated_account_format"));
5581  	ASSERT_FALSE (deprecated_account_format.is_initialized ());
5582  	std::string account_text (nano::dev::genesis_key.pub.to_account ());
5583  	account_text[4] = '-';
5584  	request.put ("account", account_text);
5585  	auto response2 (wait_response (system, rpc_ctx, request));
5586  	std::string frontier (response2.get<std::string> ("frontier"));
5587  	ASSERT_EQ (nano::dev::genesis->hash ().to_string (), frontier);
5588  	boost::optional<std::string> deprecated_account_format2 (response2.get_optional<std::string> ("deprecated_account_format"));
5589  	ASSERT_TRUE (deprecated_account_format2.is_initialized ());
5590  }
5591  TEST (rpc, epoch_upgrade)
5592  {
5593  	nano::test::system system;
5594  	auto node = add_ipc_enabled_node (system);
5595  	nano::keypair key1, key2, key3;
5596  	nano::keypair epoch_signer (nano::dev::genesis_key);
5597  	nano::block_builder builder;
5598  	auto send1 = builder
5599  				 .state ()
5600  				 .account (nano::dev::genesis_key.pub)
5601  				 .previous (nano::dev::genesis->hash ())
5602  				 .representative (nano::dev::genesis_key.pub)
5603  				 .balance (nano::dev::constants.genesis_amount - 1)
5604  				 .link (key1.pub)
5605  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
5606  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
5607  				 .build_shared (); 
5608  	ASSERT_EQ (nano::process_result::progress, node->process (*send1).code);
5609  	auto send2 = builder
5610  				 .state ()
5611  				 .account (nano::dev::genesis_key.pub)
5612  				 .previous (send1->hash ())
5613  				 .representative (nano::dev::genesis_key.pub)
5614  				 .balance (nano::dev::constants.genesis_amount - 2)
5615  				 .link (key2.pub)
5616  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
5617  				 .work (*system.work.generate (send1->hash ()))
5618  				 .build_shared (); 
5619  	ASSERT_EQ (nano::process_result::progress, node->process (*send2).code);
5620  	auto send3 = builder
5621  				 .state ()
5622  				 .account (nano::dev::genesis_key.pub)
5623  				 .previous (send2->hash ())
5624  				 .representative (nano::dev::genesis_key.pub)
5625  				 .balance (nano::dev::constants.genesis_amount - 3)
5626  				 .link (0)
5627  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
5628  				 .work (*system.work.generate (send2->hash ()))
5629  				 .build_shared (); 
5630  	ASSERT_EQ (nano::process_result::progress, node->process (*send3).code);
5631  	nano::account max_account (std::numeric_limits<nano::uint256_t>::max ());
5632  	auto send4 = builder
5633  				 .state ()
5634  				 .account (nano::dev::genesis_key.pub)
5635  				 .previous (send3->hash ())
5636  				 .representative (nano::dev::genesis_key.pub)
5637  				 .balance (nano::dev::constants.genesis_amount - 4)
5638  				 .link (max_account)
5639  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
5640  				 .work (*system.work.generate (send3->hash ()))
5641  				 .build_shared (); 
5642  	ASSERT_EQ (nano::process_result::progress, node->process (*send4).code);
5643  	auto open = builder
5644  				.state ()
5645  				.account (key1.pub)
5646  				.previous (0)
5647  				.representative (key1.pub)
5648  				.balance (1)
5649  				.link (send1->hash ())
5650  				.sign (key1.prv, key1.pub)
5651  				.work (*system.work.generate (key1.pub))
5652  				.build_shared ();
5653  	ASSERT_EQ (nano::process_result::progress, node->process (*open).code);
5654  	{
5655  		auto transaction (node->store.tx_begin_read ());
5656  		ASSERT_EQ (2, node->store.account.count (transaction));
5657  		for (auto i (node->store.account.begin (transaction)); i != node->store.account.end (); ++i)
5658  		{
5659  			nano::account_info info (i->second);
5660  			ASSERT_EQ (info.epoch (), nano::epoch::epoch_0);
5661  		}
5662  	}
5663  	auto const rpc_ctx = add_rpc (system, node);
5664  	boost::property_tree::ptree request;
5665  	request.put ("action", "epoch_upgrade");
5666  	request.put ("epoch", 1);
5667  	request.put ("key", epoch_signer.prv.to_string ());
5668  	auto response (wait_response (system, rpc_ctx, request));
5669  	ASSERT_EQ ("1", response.get<std::string> ("started"));
5670  	ASSERT_TIMELY (10s, 4 == node->store.account.count (node->store.tx_begin_read ()));
5671  	{
5672  		auto transaction (node->store.tx_begin_read ());
5673  		ASSERT_EQ (4, node->store.account.count (transaction));
5674  		for (auto i (node->store.account.begin (transaction)); i != node->store.account.end (); ++i)
5675  		{
5676  			nano::account_info info (i->second);
5677  			ASSERT_EQ (info.epoch (), nano::epoch::epoch_1);
5678  		}
5679  		ASSERT_TRUE (node->store.account.exists (transaction, key1.pub));
5680  		ASSERT_TRUE (node->store.account.exists (transaction, key2.pub));
5681  		ASSERT_TRUE (node->store.account.exists (transaction, std::numeric_limits<nano::uint256_t>::max ()));
5682  		ASSERT_FALSE (node->store.account.exists (transaction, 0));
5683  	}
5684  	auto genesis_latest (node->latest (nano::dev::genesis_key.pub));
5685  	auto send5 = builder
5686  				 .state ()
5687  				 .account (nano::dev::genesis_key.pub)
5688  				 .previous (genesis_latest)
5689  				 .representative (nano::dev::genesis_key.pub)
5690  				 .balance (nano::dev::constants.genesis_amount - 5)
5691  				 .link (0)
5692  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
5693  				 .work (*system.work.generate (genesis_latest))
5694  				 .build_shared (); 
5695  	ASSERT_EQ (nano::process_result::progress, node->process (*send5).code);
5696  	auto send6 = builder
5697  				 .state ()
5698  				 .account (nano::dev::genesis_key.pub)
5699  				 .previous (send5->hash ())
5700  				 .representative (nano::dev::genesis_key.pub)
5701  				 .balance (nano::dev::constants.genesis_amount - 6)
5702  				 .link (key1.pub)
5703  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
5704  				 .work (*system.work.generate (send5->hash ()))
5705  				 .build_shared (); 
5706  	ASSERT_EQ (nano::process_result::progress, node->process (*send6).code);
5707  	auto key1_latest (node->latest (key1.pub));
5708  	auto send7 = builder
5709  				 .state ()
5710  				 .account (key1.pub)
5711  				 .previous (key1_latest)
5712  				 .representative (key1.pub)
5713  				 .balance (0)
5714  				 .link (key3.pub)
5715  				 .sign (key1.prv, key1.pub)
5716  				 .work (*system.work.generate (key1_latest))
5717  				 .build_shared (); 
5718  	ASSERT_EQ (nano::process_result::progress, node->process (*send7).code);
5719  	{
5720  		auto transaction (node->store.tx_begin_read ());
5721  		auto info = node->ledger.pending_info (transaction, nano::pending_key (key3.pub, send7->hash ()));
5722  		ASSERT_TRUE (info);
5723  		ASSERT_EQ (nano::epoch::epoch_1, info->epoch);
5724  	}
5725  	request.put ("epoch", 2);
5726  	auto response2 (wait_response (system, rpc_ctx, request));
5727  	ASSERT_EQ ("1", response2.get<std::string> ("started"));
5728  	ASSERT_TIMELY (10s, 5 == node->store.account.count (node->store.tx_begin_read ()));
5729  	{
5730  		auto transaction (node->store.tx_begin_read ());
5731  		ASSERT_EQ (5, node->store.account.count (transaction));
5732  		for (auto i (node->store.account.begin (transaction)); i != node->store.account.end (); ++i)
5733  		{
5734  			nano::account_info info (i->second);
5735  			ASSERT_EQ (info.epoch (), nano::epoch::epoch_2);
5736  		}
5737  		ASSERT_TRUE (node->store.account.exists (transaction, key1.pub));
5738  		ASSERT_TRUE (node->store.account.exists (transaction, key2.pub));
5739  		ASSERT_TRUE (node->store.account.exists (transaction, key3.pub));
5740  		ASSERT_TRUE (node->store.account.exists (transaction, std::numeric_limits<nano::uint256_t>::max ()));
5741  		ASSERT_FALSE (node->store.account.exists (transaction, 0));
5742  	}
5743  }
5744  TEST (rpc, epoch_upgrade_multithreaded)
5745  {
5746  	nano::test::system system;
5747  	nano::node_config node_config = system.default_config ();
5748  	node_config.work_threads = 4;
5749  	auto node = add_ipc_enabled_node (system, node_config);
5750  	nano::keypair key1, key2, key3;
5751  	nano::keypair epoch_signer (nano::dev::genesis_key);
5752  	nano::block_builder builder;
5753  	auto send1 = builder
5754  				 .state ()
5755  				 .account (nano::dev::genesis_key.pub)
5756  				 .previous (nano::dev::genesis->hash ())
5757  				 .representative (nano::dev::genesis_key.pub)
5758  				 .balance (nano::dev::constants.genesis_amount - 1)
5759  				 .link (key1.pub)
5760  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
5761  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
5762  				 .build_shared (); 
5763  	ASSERT_EQ (nano::process_result::progress, node->process (*send1).code);
5764  	auto send2 = builder
5765  				 .state ()
5766  				 .account (nano::dev::genesis_key.pub)
5767  				 .previous (send1->hash ())
5768  				 .representative (nano::dev::genesis_key.pub)
5769  				 .balance (nano::dev::constants.genesis_amount - 2)
5770  				 .link (key2.pub)
5771  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
5772  				 .work (*system.work.generate (send1->hash ()))
5773  				 .build_shared (); 
5774  	ASSERT_EQ (nano::process_result::progress, node->process (*send2).code);
5775  	auto send3 = builder
5776  				 .state ()
5777  				 .account (nano::dev::genesis_key.pub)
5778  				 .previous (send2->hash ())
5779  				 .representative (nano::dev::genesis_key.pub)
5780  				 .balance (nano::dev::constants.genesis_amount - 3)
5781  				 .link (0)
5782  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
5783  				 .work (*system.work.generate (send2->hash ()))
5784  				 .build_shared (); 
5785  	ASSERT_EQ (nano::process_result::progress, node->process (*send3).code);
5786  	nano::account max_account (std::numeric_limits<nano::uint256_t>::max ());
5787  	auto send4 = builder
5788  				 .state ()
5789  				 .account (nano::dev::genesis_key.pub)
5790  				 .previous (send3->hash ())
5791  				 .representative (nano::dev::genesis_key.pub)
5792  				 .balance (nano::dev::constants.genesis_amount - 4)
5793  				 .link (max_account)
5794  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
5795  				 .work (*system.work.generate (send3->hash ()))
5796  				 .build_shared (); 
5797  	ASSERT_EQ (nano::process_result::progress, node->process (*send4).code);
5798  	auto open = builder
5799  				.state ()
5800  				.account (key1.pub)
5801  				.previous (0)
5802  				.representative (key1.pub)
5803  				.balance (1)
5804  				.link (send1->hash ())
5805  				.sign (key1.prv, key1.pub)
5806  				.work (*system.work.generate (key1.pub))
5807  				.build_shared ();
5808  	ASSERT_EQ (nano::process_result::progress, node->process (*open).code);
5809  	{
5810  		auto transaction (node->store.tx_begin_read ());
5811  		ASSERT_EQ (2, node->store.account.count (transaction));
5812  		for (auto i (node->store.account.begin (transaction)); i != node->store.account.end (); ++i)
5813  		{
5814  			nano::account_info info (i->second);
5815  			ASSERT_EQ (info.epoch (), nano::epoch::epoch_0);
5816  		}
5817  	}
5818  	auto const rpc_ctx = add_rpc (system, node);
5819  	boost::property_tree::ptree request;
5820  	request.put ("action", "epoch_upgrade");
5821  	request.put ("threads", 2);
5822  	request.put ("epoch", 1);
5823  	request.put ("key", epoch_signer.prv.to_string ());
5824  	auto response (wait_response (system, rpc_ctx, request));
5825  	ASSERT_EQ ("1", response.get<std::string> ("started"));
5826  	ASSERT_TIMELY (5s, 4 == node->store.account.count (node->store.tx_begin_read ()));
5827  	{
5828  		auto transaction (node->store.tx_begin_read ());
5829  		ASSERT_EQ (4, node->store.account.count (transaction));
5830  		for (auto i (node->store.account.begin (transaction)); i != node->store.account.end (); ++i)
5831  		{
5832  			nano::account_info info (i->second);
5833  			ASSERT_EQ (info.epoch (), nano::epoch::epoch_1);
5834  		}
5835  		ASSERT_TRUE (node->store.account.exists (transaction, key1.pub));
5836  		ASSERT_TRUE (node->store.account.exists (transaction, key2.pub));
5837  		ASSERT_TRUE (node->store.account.exists (transaction, std::numeric_limits<nano::uint256_t>::max ()));
5838  		ASSERT_FALSE (node->store.account.exists (transaction, 0));
5839  	}
5840  	auto genesis_latest (node->latest (nano::dev::genesis_key.pub));
5841  	auto send5 = builder
5842  				 .state ()
5843  				 .account (nano::dev::genesis_key.pub)
5844  				 .previous (genesis_latest)
5845  				 .representative (nano::dev::genesis_key.pub)
5846  				 .balance (nano::dev::constants.genesis_amount - 5)
5847  				 .link (0)
5848  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
5849  				 .work (*system.work.generate (genesis_latest))
5850  				 .build_shared (); 
5851  	ASSERT_EQ (nano::process_result::progress, node->process (*send5).code);
5852  	auto send6 = builder
5853  				 .state ()
5854  				 .account (nano::dev::genesis_key.pub)
5855  				 .previous (send5->hash ())
5856  				 .representative (nano::dev::genesis_key.pub)
5857  				 .balance (nano::dev::constants.genesis_amount - 6)
5858  				 .link (key1.pub)
5859  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
5860  				 .work (*system.work.generate (send5->hash ()))
5861  				 .build_shared (); 
5862  	ASSERT_EQ (nano::process_result::progress, node->process (*send6).code);
5863  	auto key1_latest (node->latest (key1.pub));
5864  	auto send7 = builder
5865  				 .state ()
5866  				 .account (key1.pub)
5867  				 .previous (key1_latest)
5868  				 .representative (key1.pub)
5869  				 .balance (0)
5870  				 .link (key3.pub)
5871  				 .sign (key1.prv, key1.pub)
5872  				 .work (*system.work.generate (key1_latest))
5873  				 .build_shared (); 
5874  	ASSERT_EQ (nano::process_result::progress, node->process (*send7).code);
5875  	{
5876  		auto transaction (node->store.tx_begin_read ());
5877  		auto info = node->ledger.pending_info (transaction, nano::pending_key (key3.pub, send7->hash ()));
5878  		ASSERT_TRUE (info);
5879  		ASSERT_EQ (nano::epoch::epoch_1, info->epoch);
5880  	}
5881  	request.put ("epoch", 2);
5882  	auto response2 (wait_response (system, rpc_ctx, request));
5883  	ASSERT_EQ ("1", response2.get<std::string> ("started"));
5884  	ASSERT_TIMELY (5s, 5 == node->store.account.count (node->store.tx_begin_read ()));
5885  	{
5886  		auto transaction (node->store.tx_begin_read ());
5887  		ASSERT_EQ (5, node->store.account.count (transaction));
5888  		for (auto i (node->store.account.begin (transaction)); i != node->store.account.end (); ++i)
5889  		{
5890  			nano::account_info info (i->second);
5891  			ASSERT_EQ (info.epoch (), nano::epoch::epoch_2);
5892  		}
5893  		ASSERT_TRUE (node->store.account.exists (transaction, key1.pub));
5894  		ASSERT_TRUE (node->store.account.exists (transaction, key2.pub));
5895  		ASSERT_TRUE (node->store.account.exists (transaction, key3.pub));
5896  		ASSERT_TRUE (node->store.account.exists (transaction, std::numeric_limits<nano::uint256_t>::max ()));
5897  		ASSERT_FALSE (node->store.account.exists (transaction, 0));
5898  	}
5899  }
5900  TEST (rpc, account_lazy_start)
5901  {
5902  	nano::test::system system{};
5903  	nano::node_flags node_flags{};
5904  	node_flags.disable_legacy_bootstrap = true;
5905  	auto node1 = system.add_node (node_flags);
5906  	nano::keypair key{};
5907  	nano::block_builder builder;
5908  	auto send1 = builder
5909  				 .state ()
5910  				 .account (nano::dev::genesis_key.pub)
5911  				 .previous (nano::dev::genesis->hash ())
5912  				 .representative (nano::dev::genesis_key.pub)
5913  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
5914  				 .link (key.pub)
5915  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
5916  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
5917  				 .build_shared ();
5918  	ASSERT_EQ (nano::process_result::progress, node1->process (*send1).code);
5919  	auto open = builder
5920  				.open ()
5921  				.source (send1->hash ())
5922  				.representative (key.pub)
5923  				.account (key.pub)
5924  				.sign (key.prv, key.pub)
5925  				.work (*system.work.generate (key.pub))
5926  				.build_shared ();
5927  	ASSERT_EQ (nano::process_result::progress, node1->process (*open).code);
5928  	nano::node_config node_config = system.default_config ();
5929  	node_config.ipc_config.transport_tcp.enabled = true;
5930  	node_config.ipc_config.transport_tcp.port = system.get_available_port ();
5931  	auto node2 = system.add_node (node_config, node_flags);
5932  	nano::test::establish_tcp (system, *node2, node1->network.endpoint ());
5933  	auto const rpc_ctx = add_rpc (system, node2);
5934  	boost::property_tree::ptree request;
5935  	request.put ("action", "account_info");
5936  	request.put ("account", key.pub.to_account ());
5937  	auto response = wait_response (system, rpc_ctx, request);
5938  	boost::optional<std::string> account_error{ response.get_optional<std::string> ("error") };
5939  	ASSERT_TRUE (account_error.is_initialized ());
5940  	ASSERT_TIMELY (10s, !node2->bootstrap_initiator.in_progress ());
5941  	ASSERT_TIMELY (10s, node2->ledger.block_or_pruned_exists (send1->hash ()));
5942  	ASSERT_TIMELY (10s, node2->ledger.block_or_pruned_exists (open->hash ()));
5943  }
5944  TEST (rpc, receive)
5945  {
5946  	nano::test::system system;
5947  	auto node = add_ipc_enabled_node (system);
5948  	auto wallet = system.wallet (0);
5949  	std::string wallet_text;
5950  	node->wallets.items.begin ()->first.encode_hex (wallet_text);
5951  	wallet->insert_adhoc (nano::dev::genesis_key.prv);
5952  	nano::keypair key1;
5953  	wallet->insert_adhoc (key1.prv);
5954  	auto send1 (wallet->send_action (nano::dev::genesis_key.pub, key1.pub, node->config.receive_minimum.number (), *node->work_generate_blocking (nano::dev::genesis->hash ())));
5955  	ASSERT_TIMELY (5s, node->balance (nano::dev::genesis_key.pub) != nano::dev::constants.genesis_amount);
5956  	ASSERT_TIMELY (10s, !node->store.account.exists (node->store.tx_begin_read (), key1.pub));
5957  	auto send2 (wallet->send_action (nano::dev::genesis_key.pub, key1.pub, node->config.receive_minimum.number () - 1, *node->work_generate_blocking (send1->hash ())));
5958  	auto const rpc_ctx = add_rpc (system, node);
5959  	boost::property_tree::ptree request;
5960  	request.put ("action", "receive");
5961  	request.put ("wallet", wallet_text);
5962  	request.put ("account", key1.pub.to_account ());
5963  	request.put ("block", send2->hash ().to_string ());
5964  	{
5965  		auto response (wait_response (system, rpc_ctx, request));
5966  		auto receive_text (response.get<std::string> ("block"));
5967  		auto info = node->ledger.account_info (node->store.tx_begin_read (), key1.pub);
5968  		ASSERT_TRUE (info);
5969  		ASSERT_EQ (info->head, nano::block_hash{ receive_text });
5970  	}
5971  	{
5972  		auto response (wait_response (system, rpc_ctx, request));
5973  		ASSERT_EQ (std::error_code (nano::error_process::unreceivable).message (), response.get<std::string> ("error"));
5974  	}
5975  	request.put ("block", nano::block_hash (send2->hash ().number () + 1).to_string ());
5976  	{
5977  		auto response (wait_response (system, rpc_ctx, request));
5978  		ASSERT_EQ (std::error_code (nano::error_blocks::not_found).message (), response.get<std::string> ("error"));
5979  	}
5980  }
5981  TEST (rpc, receive_unopened)
5982  {
5983  	nano::test::system system;
5984  	auto node = add_ipc_enabled_node (system);
5985  	auto wallet = system.wallet (0);
5986  	std::string wallet_text;
5987  	node->wallets.items.begin ()->first.encode_hex (wallet_text);
5988  	wallet->insert_adhoc (nano::dev::genesis_key.prv);
5989  	nano::keypair key1;
5990  	auto send1 (wallet->send_action (nano::dev::genesis_key.pub, key1.pub, node->config.receive_minimum.number () - 1, *node->work_generate_blocking (nano::dev::genesis->hash ())));
5991  	ASSERT_TIMELY (5s, !node->balance (nano::dev::genesis_key.pub) != nano::dev::constants.genesis_amount);
5992  	ASSERT_FALSE (node->store.account.exists (node->store.tx_begin_read (), key1.pub));
5993  	ASSERT_TRUE (node->store.block.exists (node->store.tx_begin_read (), send1->hash ()));
5994  	wallet->insert_adhoc (key1.prv); 
5995  	auto const rpc_ctx = add_rpc (system, node);
5996  	boost::property_tree::ptree request;
5997  	request.put ("action", "receive");
5998  	request.put ("wallet", wallet_text);
5999  	request.put ("account", key1.pub.to_account ());
6000  	request.put ("block", send1->hash ().to_string ());
6001  	{
6002  		auto response (wait_response (system, rpc_ctx, request));
6003  		auto receive_text (response.get<std::string> ("block"));
6004  		auto info = node->ledger.account_info (node->store.tx_begin_read (), key1.pub);
6005  		ASSERT_TRUE (info);
6006  		ASSERT_EQ (info->head, info->open_block);
6007  		ASSERT_EQ (info->head.to_string (), receive_text);
6008  		ASSERT_EQ (info->representative, nano::dev::genesis_key.pub);
6009  	}
6010  	nano::keypair key2;
6011  	auto prev_amount (node->balance (nano::dev::genesis_key.pub));
6012  	auto send2 (wallet->send_action (nano::dev::genesis_key.pub, key2.pub, node->config.receive_minimum.number () - 1, *node->work_generate_blocking (send1->hash ())));
6013  	ASSERT_TIMELY (5s, !node->balance (nano::dev::genesis_key.pub) != prev_amount);
6014  	ASSERT_FALSE (node->store.account.exists (node->store.tx_begin_read (), key2.pub));
6015  	ASSERT_TRUE (node->store.block.exists (node->store.tx_begin_read (), send2->hash ()));
6016  	nano::public_key rep;
6017  	wallet->store.representative_set (node->wallets.tx_begin_write (), rep);
6018  	wallet->insert_adhoc (key2.prv); 
6019  	request.put ("account", key2.pub.to_account ());
6020  	request.put ("block", send2->hash ().to_string ());
6021  	{
6022  		auto response (wait_response (system, rpc_ctx, request));
6023  		auto receive_text (response.get<std::string> ("block"));
6024  		auto info = node->ledger.account_info (node->store.tx_begin_read (), key2.pub);
6025  		ASSERT_TRUE (info);
6026  		ASSERT_EQ (info->head, info->open_block);
6027  		ASSERT_EQ (info->head.to_string (), receive_text);
6028  		ASSERT_EQ (info->representative, rep);
6029  	}
6030  }
6031  TEST (rpc, receive_work_disabled)
6032  {
6033  	nano::test::system system;
6034  	nano::node_config config = system.default_config ();
6035  	auto & worker_node = *system.add_node (config);
6036  	config.peering_port = system.get_available_port ();
6037  	config.work_threads = 0;
6038  	auto node = add_ipc_enabled_node (system, config);
6039  	auto wallet = system.wallet (1);
6040  	std::string wallet_text;
6041  	node->wallets.items.begin ()->first.encode_hex (wallet_text);
6042  	wallet->insert_adhoc (nano::dev::genesis_key.prv);
6043  	nano::keypair key1;
6044  	ASSERT_TRUE (worker_node.work_generation_enabled ());
6045  	auto send1 (wallet->send_action (nano::dev::genesis_key.pub, key1.pub, node->config.receive_minimum.number () - 1, *worker_node.work_generate_blocking (nano::dev::genesis->hash ()), false));
6046  	ASSERT_TRUE (send1 != nullptr);
6047  	ASSERT_TIMELY (5s, node->balance (nano::dev::genesis_key.pub) != nano::dev::constants.genesis_amount);
6048  	ASSERT_FALSE (node->store.account.exists (node->store.tx_begin_read (), key1.pub));
6049  	ASSERT_TRUE (node->store.block.exists (node->store.tx_begin_read (), send1->hash ()));
6050  	wallet->insert_adhoc (key1.prv);
6051  	auto const rpc_ctx = add_rpc (system, node);
6052  	boost::property_tree::ptree request;
6053  	request.put ("action", "receive");
6054  	request.put ("wallet", wallet_text);
6055  	request.put ("account", key1.pub.to_account ());
6056  	request.put ("block", send1->hash ().to_string ());
6057  	{
6058  		auto response (wait_response (system, rpc_ctx, request));
6059  		ASSERT_EQ (std::error_code (nano::error_common::disabled_work_generation).message (), response.get<std::string> ("error"));
6060  	}
6061  }
6062  TEST (rpc, receive_pruned)
6063  {
6064  	nano::test::system system;
6065  	auto & node1 = *system.add_node ();
6066  	nano::node_config node_config = system.default_config ();
6067  	node_config.enable_voting = false; 
6068  	nano::node_flags node_flags;
6069  	node_flags.enable_pruning = true;
6070  	auto node2 = add_ipc_enabled_node (system, node_config, node_flags);
6071  	auto wallet1 = system.wallet (0);
6072  	auto wallet2 = system.wallet (1);
6073  	std::string wallet_text;
6074  	node2->wallets.items.begin ()->first.encode_hex (wallet_text);
6075  	wallet1->insert_adhoc (nano::dev::genesis_key.prv);
6076  	nano::keypair key1;
6077  	wallet2->insert_adhoc (key1.prv);
6078  	auto send1 (wallet1->send_action (nano::dev::genesis_key.pub, key1.pub, node2->config.receive_minimum.number (), *node2->work_generate_blocking (nano::dev::genesis->hash ())));
6079  	ASSERT_TIMELY (5s, node2->balance (nano::dev::genesis_key.pub) != nano::dev::constants.genesis_amount);
6080  	ASSERT_TIMELY (10s, !node2->store.account.exists (node2->store.tx_begin_read (), key1.pub));
6081  	auto send2 (wallet1->send_action (nano::dev::genesis_key.pub, key1.pub, node2->config.receive_minimum.number () - 1, *node2->work_generate_blocking (send1->hash ())));
6082  	auto send3 (wallet1->send_action (nano::dev::genesis_key.pub, key1.pub, node2->config.receive_minimum.number (), *node2->work_generate_blocking (send1->hash ())));
6083  	ASSERT_TIMELY (5s, node2->block_confirmed (send3->hash ()));
6084  	{
6085  		auto transaction (node2->store.tx_begin_write ());
6086  		ASSERT_EQ (2, node2->ledger.pruning_action (transaction, send2->hash (), 1));
6087  	}
6088  	ASSERT_EQ (2, node2->ledger.cache.pruned_count);
6089  	ASSERT_TRUE (node2->ledger.block_or_pruned_exists (send1->hash ()));
6090  	ASSERT_FALSE (node2->store.block.exists (node2->store.tx_begin_read (), send1->hash ()));
6091  	ASSERT_TRUE (node2->ledger.block_or_pruned_exists (send2->hash ()));
6092  	ASSERT_FALSE (node2->store.block.exists (node2->store.tx_begin_read (), send2->hash ()));
6093  	ASSERT_TRUE (node2->ledger.block_or_pruned_exists (send3->hash ()));
6094  	auto const rpc_ctx = add_rpc (system, node2);
6095  	boost::property_tree::ptree request;
6096  	request.put ("action", "receive");
6097  	request.put ("wallet", wallet_text);
6098  	request.put ("account", key1.pub.to_account ());
6099  	request.put ("block", send2->hash ().to_string ());
6100  	{
6101  		auto response (wait_response (system, rpc_ctx, request));
6102  		auto receive_text (response.get<std::string> ("block"));
6103  		auto info = node2->ledger.account_info (node2->store.tx_begin_read (), key1.pub);
6104  		ASSERT_TRUE (info);
6105  		ASSERT_EQ (info->head, nano::block_hash{ receive_text });
6106  	}
6107  	{
6108  		auto response (wait_response (system, rpc_ctx, request));
6109  		ASSERT_EQ (std::error_code (nano::error_process::unreceivable).message (), response.get<std::string> ("error"));
6110  	}
6111  	request.put ("block", nano::block_hash (send2->hash ().number () + 1).to_string ());
6112  	{
6113  		auto response (wait_response (system, rpc_ctx, request));
6114  		ASSERT_EQ (std::error_code (nano::error_blocks::not_found).message (), response.get<std::string> ("error"));
6115  	}
6116  }
6117  TEST (rpc, telemetry_single)
6118  {
6119  	nano::test::system system (1);
6120  	auto node1 = add_ipc_enabled_node (system);
6121  	auto const rpc_ctx = add_rpc (system, node1);
6122  	auto peers_stored = false;
6123  	ASSERT_TIMELY (10s, node1->store.peer.count (node1->store.tx_begin_read ()) != 0);
6124  	boost::property_tree::ptree request;
6125  	auto node = system.nodes.front ();
6126  	request.put ("action", "telemetry");
6127  	request.put ("address", "not_a_valid_address");
6128  	{
6129  		auto response (wait_response (system, rpc_ctx, request, 10s));
6130  		ASSERT_EQ (std::error_code (nano::error_rpc::requires_port_and_address).message (), response.get<std::string> ("error"));
6131  	}
6132  	request.erase ("address");
6133  	request.put ("port", 65);
6134  	{
6135  		auto response (wait_response (system, rpc_ctx, request, 10s));
6136  		ASSERT_EQ (std::error_code (nano::error_rpc::requires_port_and_address).message (), response.get<std::string> ("error"));
6137  	}
6138  	request.put ("address", "not_a_valid_address");
6139  	request.put ("port", 65);
6140  	{
6141  		auto response (wait_response (system, rpc_ctx, request, 10s));
6142  		ASSERT_EQ (std::error_code (nano::error_common::invalid_ip_address).message (), response.get<std::string> ("error"));
6143  	}
6144  	request.put ("address", (boost::format ("%1%") % node->network.endpoint ().address ()).str ());
6145  	request.put ("port", "invalid port");
6146  	{
6147  		auto response (wait_response (system, rpc_ctx, request, 10s));
6148  		ASSERT_EQ (std::error_code (nano::error_common::invalid_port).message (), response.get<std::string> ("error"));
6149  	}
6150  	request.put ("port", node->network.endpoint ().port ());
6151  	{
6152  		auto response (wait_response (system, rpc_ctx, request, 10s));
6153  		nano::jsonconfig config (response);
6154  		nano::telemetry_data telemetry_data;
6155  		auto const should_ignore_identification_metrics = false;
6156  		ASSERT_FALSE (telemetry_data.deserialize_json (config, should_ignore_identification_metrics));
6157  		ASSERT_TRUE (nano::test::compare_telemetry (telemetry_data, *node));
6158  	}
6159  }
6160  TEST (rpc, telemetry_all)
6161  {
6162  	nano::test::system system (1);
6163  	auto node1 = add_ipc_enabled_node (system);
6164  	auto const rpc_ctx = add_rpc (system, node1);
6165  	ASSERT_TIMELY (10s, node1->store.peer.count (node1->store.tx_begin_read ()) != 0);
6166  	auto node = system.nodes.front ();
6167  	auto channel = node1->network.find_node_id (node->get_node_id ());
6168  	ASSERT_TRUE (channel);
6169  	ASSERT_TIMELY (10s, node1->telemetry.get_telemetry (channel->get_endpoint ()));
6170  	boost::property_tree::ptree request;
6171  	request.put ("action", "telemetry");
6172  	{
6173  		auto response (wait_response (system, rpc_ctx, request, 10s));
6174  		nano::jsonconfig config (response);
6175  		nano::telemetry_data telemetry_data;
6176  		auto const should_ignore_identification_metrics = true;
6177  		ASSERT_FALSE (telemetry_data.deserialize_json (config, should_ignore_identification_metrics));
6178  		ASSERT_TRUE (nano::test::compare_telemetry_data (telemetry_data, node->local_telemetry ()));
6179  		ASSERT_FALSE (response.get_optional<std::string> ("node_id").is_initialized ());
6180  		ASSERT_FALSE (response.get_optional<std::string> ("signature").is_initialized ());
6181  	}
6182  	request.put ("raw", "true");
6183  	auto response (wait_response (system, rpc_ctx, request, 10s));
6184  	auto & all_metrics = response.get_child ("metrics");
6185  	auto & metrics = all_metrics.front ().second;
6186  	ASSERT_EQ (1, all_metrics.size ());
6187  	nano::jsonconfig config (metrics);
6188  	nano::telemetry_data data;
6189  	auto const should_ignore_identification_metrics = false;
6190  	ASSERT_FALSE (data.deserialize_json (config, should_ignore_identification_metrics));
6191  	ASSERT_TRUE (nano::test::compare_telemetry (data, *node));
6192  	ASSERT_EQ (node->network.endpoint ().address ().to_string (), metrics.get<std::string> ("address"));
6193  	ASSERT_EQ (node->network.endpoint ().port (), metrics.get<uint16_t> ("port"));
6194  	ASSERT_TRUE (node1->network.find_node_id (data.node_id));
6195  }
6196  TEST (rpc, telemetry_self)
6197  {
6198  	nano::test::system system{ 1 };
6199  	auto node1 = add_ipc_enabled_node (system);
6200  	auto const rpc_ctx = add_rpc (system, node1);
6201  	auto outer_node = system.nodes[0];
6202  	nano::test::establish_tcp (system, *node1, outer_node->network.endpoint ());
6203  	boost::property_tree::ptree request;
6204  	request.put ("action", "telemetry");
6205  	request.put ("address", "::1");
6206  	request.put ("port", node1->network.endpoint ().port ());
6207  	auto const should_ignore_identification_metrics = false;
6208  	{
6209  		auto response (wait_response (system, rpc_ctx, request, 10s));
6210  		nano::telemetry_data data;
6211  		nano::jsonconfig config (response);
6212  		ASSERT_FALSE (data.deserialize_json (config, should_ignore_identification_metrics));
6213  		ASSERT_TRUE (nano::test::compare_telemetry (data, *node1));
6214  	}
6215  	request.put ("address", "[::1]");
6216  	{
6217  		auto response (wait_response (system, rpc_ctx, request, 10s));
6218  		nano::telemetry_data data;
6219  		nano::jsonconfig config (response);
6220  		ASSERT_FALSE (data.deserialize_json (config, should_ignore_identification_metrics));
6221  		ASSERT_TRUE (nano::test::compare_telemetry (data, *node1));
6222  	}
6223  	request.put ("address", "127.0.0.1");
6224  	{
6225  		auto response (wait_response (system, rpc_ctx, request, 10s));
6226  		nano::telemetry_data data;
6227  		nano::jsonconfig config (response);
6228  		ASSERT_FALSE (data.deserialize_json (config, should_ignore_identification_metrics));
6229  		ASSERT_TRUE (nano::test::compare_telemetry (data, *node1));
6230  	}
6231  	request.put ("port", "0");
6232  	{
6233  		auto response (wait_response (system, rpc_ctx, request, 10s));
6234  		ASSERT_EQ (std::error_code (nano::error_rpc::peer_not_found).message (), response.get<std::string> ("error"));
6235  	}
6236  }
6237  TEST (rpc, confirmation_active)
6238  {
6239  	nano::test::system system;
6240  	nano::node_config node_config;
6241  	node_config.ipc_config.transport_tcp.enabled = true;
6242  	node_config.ipc_config.transport_tcp.port = system.get_available_port ();
6243  	nano::node_flags node_flags;
6244  	node_flags.disable_request_loop = true;
6245  	auto node1 (system.add_node (node_config, node_flags));
6246  	auto const rpc_ctx = add_rpc (system, node1);
6247  	nano::block_builder builder;
6248  	auto send1 = builder
6249  				 .send ()
6250  				 .previous (nano::dev::genesis->hash ())
6251  				 .destination (nano::public_key ())
6252  				 .balance (nano::dev::constants.genesis_amount - 100)
6253  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
6254  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
6255  				 .build_shared ();
6256  	auto send2 = builder
6257  				 .send ()
6258  				 .previous (send1->hash ())
6259  				 .destination (nano::public_key ())
6260  				 .balance (nano::dev::constants.genesis_amount - 200)
6261  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
6262  				 .work (*system.work.generate (send1->hash ()))
6263  				 .build_shared ();
6264  	node1->process_active (send1);
6265  	node1->process_active (send2);
6266  	nano::test::start_elections (system, *node1, { send1, send2 });
6267  	ASSERT_EQ (2, node1->active.size ());
6268  	auto election (node1->active.election (send1->qualified_root ()));
6269  	ASSERT_NE (nullptr, election);
6270  	election->force_confirm ();
6271  	ASSERT_TIMELY (5s, election->confirmed ());
6272  	boost::property_tree::ptree request;
6273  	request.put ("action", "confirmation_active");
6274  	{
6275  		auto response (wait_response (system, rpc_ctx, request));
6276  		auto & confirmations (response.get_child ("confirmations"));
6277  		ASSERT_EQ (1, confirmations.size ());
6278  		ASSERT_EQ (send2->qualified_root ().to_string (), confirmations.front ().second.get<std::string> (""));
6279  		ASSERT_EQ (1, response.get<unsigned> ("unconfirmed"));
6280  		ASSERT_EQ (1, response.get<unsigned> ("confirmed"));
6281  	}
6282  }
6283  TEST (rpc, confirmation_info)
6284  {
6285  	nano::test::system system;
6286  	auto node1 = add_ipc_enabled_node (system);
6287  	auto const rpc_ctx = add_rpc (system, node1);
6288  	nano::block_builder builder;
6289  	auto send = builder
6290  				.send ()
6291  				.previous (nano::dev::genesis->hash ())
6292  				.destination (nano::public_key ())
6293  				.balance (nano::dev::constants.genesis_amount - 100)
6294  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
6295  				.work (*system.work.generate (nano::dev::genesis->hash ()))
6296  				.build_shared ();
6297  	node1->process_active (send);
6298  	ASSERT_TIMELY (5s, !node1->active.empty ());
6299  	boost::property_tree::ptree request;
6300  	request.put ("action", "confirmation_info");
6301  	request.put ("root", send->qualified_root ().to_string ());
6302  	request.put ("representatives", "true");
6303  	request.put ("json_block", "true");
6304  	{
6305  		auto response (wait_response (system, rpc_ctx, request));
6306  		ASSERT_EQ (1, response.count ("announcements"));
6307  		ASSERT_EQ (1, response.get<unsigned> ("voters"));
6308  		ASSERT_EQ (send->hash ().to_string (), response.get<std::string> ("last_winner"));
6309  		auto & blocks (response.get_child ("blocks"));
6310  		ASSERT_EQ (1, blocks.size ());
6311  		auto & representatives (blocks.front ().second.get_child ("representatives"));
6312  		ASSERT_EQ (1, representatives.size ());
6313  		ASSERT_EQ (0, response.get<unsigned> ("total_tally"));
6314  	}
6315  }
6316  TEST (node, election_scheduler_container_info)
6317  {
6318  	nano::test::system system;
6319  	nano::node_config node_config;
6320  	node_config.active_elections_size = 0;
6321  	nano::node_flags node_flags;
6322  	auto node = add_ipc_enabled_node (system, node_config);
6323  	auto const rpc_ctx = add_rpc (system, node);
6324  	auto send1 = nano::state_block_builder ()
6325  				 .account (nano::dev::genesis_key.pub)
6326  				 .previous (nano::dev::genesis->hash ())
6327  				 .representative (nano::dev::genesis_key.pub)
6328  				 .balance (nano::dev::constants.genesis_amount - 1)
6329  				 .link (nano::public_key ())
6330  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
6331  				 .work (*node->work_generate_blocking (nano::dev::genesis->hash ()))
6332  				 .build_shared ();
6333  	node->process_active (send1);
6334  	ASSERT_TIMELY (10s, node->scheduler.buckets.size () == 1);
6335  	boost::property_tree::ptree request;
6336  	request.put ("action", "stats");
6337  	request.put ("type", "objects");
6338  	auto response = wait_response (system, rpc_ctx, request);
6339  	auto es = response.get_child ("node").get_child ("election_scheduler");
6340  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-rpc.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-rpc.cpp</div>
                </div>
                <div class="column column_space"><pre><code>4827  	ASSERT_TRUE (node->active.recently_cemented.list ().empty ());
4828  	auto block (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key.pub, nano::Gxrb_ratio));
4829  	ASSERT_TIMELY (10s, !node->active.recently_cemented.list ().empty ());
</pre></code></div>
                <div class="column column_space"><pre><code>4857  	ASSERT_TRUE (node->active.recently_cemented.list ().empty ());
4858  	auto send1 (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key.pub, nano::Gxrb_ratio));
4859  	auto send2 (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key.pub, nano::Gxrb_ratio));
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    