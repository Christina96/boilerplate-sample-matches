
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 24, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-cl2.hpp</h3>
            <pre><code>1  #ifndef CL_HPP_
2  #define CL_HPP_
3  #if !defined(CL_HPP_USE_DX_INTEROP) && defined(USE_DX_INTEROP)
4  # pragma message("cl2.hpp: USE_DX_INTEROP is deprecated. Define CL_HPP_USE_DX_INTEROP instead")
5  # define CL_HPP_USE_DX_INTEROP
6  #endif
7  #if !defined(CL_HPP_USE_CL_DEVICE_FISSION) && defined(USE_CL_DEVICE_FISSION)
8  # pragma message("cl2.hpp: USE_CL_DEVICE_FISSION is deprecated. Define CL_HPP_USE_CL_DEVICE_FISSION instead")
9  # define CL_HPP_USE_CL_DEVICE_FISSION
10  #endif
11  #if !defined(CL_HPP_ENABLE_EXCEPTIONS) && defined(__CL_ENABLE_EXCEPTIONS)
12  # pragma message("cl2.hpp: __CL_ENABLE_EXCEPTIONS is deprecated. Define CL_HPP_ENABLE_EXCEPTIONS instead")
13  # define CL_HPP_ENABLE_EXCEPTIONS
14  #endif
15  #if !defined(CL_HPP_NO_STD_VECTOR) && defined(__NO_STD_VECTOR)
16  # pragma message("cl2.hpp: __NO_STD_VECTOR is deprecated. Define CL_HPP_NO_STD_VECTOR instead")
17  # define CL_HPP_NO_STD_VECTOR
18  #endif
19  #if !defined(CL_HPP_NO_STD_STRING) && defined(__NO_STD_STRING)
20  # pragma message("cl2.hpp: __NO_STD_STRING is deprecated. Define CL_HPP_NO_STD_STRING instead")
21  # define CL_HPP_NO_STD_STRING
22  #endif
23  #if defined(VECTOR_CLASS)
24  # pragma message("cl2.hpp: VECTOR_CLASS is deprecated. Alias cl::vector instead")
25  #endif
26  #if defined(STRING_CLASS)
27  # pragma message("cl2.hpp: STRING_CLASS is deprecated. Alias cl::string instead.")
28  #endif
29  #if !defined(CL_HPP_USER_OVERRIDE_ERROR_STRINGS) && defined(__CL_USER_OVERRIDE_ERROR_STRINGS)
30  # pragma message("cl2.hpp: __CL_USER_OVERRIDE_ERROR_STRINGS is deprecated. Define CL_HPP_USER_OVERRIDE_ERROR_STRINGS instead")
31  # define CL_HPP_USER_OVERRIDE_ERROR_STRINGS
32  #endif
33  #if defined(__USE_DEV_VECTOR)
34  # pragma message("cl2.hpp: __USE_DEV_VECTOR is no longer supported. Expect compilation errors")
35  #endif
36  #if defined(__USE_DEV_STRING)
37  # pragma message("cl2.hpp: __USE_DEV_STRING is no longer supported. Expect compilation errors")
38  #endif
39  #if !defined(CL_HPP_TARGET_OPENCL_VERSION)
40  # pragma message("cl2.hpp: CL_HPP_TARGET_OPENCL_VERSION is not defined. It will default to 200 (OpenCL 2.0)")
41  # define CL_HPP_TARGET_OPENCL_VERSION 200
42  #endif
43  #if CL_HPP_TARGET_OPENCL_VERSION != 100 && CL_HPP_TARGET_OPENCL_VERSION != 110 && CL_HPP_TARGET_OPENCL_VERSION != 120 && CL_HPP_TARGET_OPENCL_VERSION != 200
44  # pragma message("cl2.hpp: CL_HPP_TARGET_OPENCL_VERSION is not a valid value (100, 110, 120 or 200). It will be set to 200")
45  # undef CL_HPP_TARGET_OPENCL_VERSION
46  # define CL_HPP_TARGET_OPENCL_VERSION 200
47  #endif
48  #if !defined(CL_HPP_MINIMUM_OPENCL_VERSION)
49  # define CL_HPP_MINIMUM_OPENCL_VERSION 200
50  #endif
51  #if CL_HPP_MINIMUM_OPENCL_VERSION != 100 && CL_HPP_MINIMUM_OPENCL_VERSION != 110 && CL_HPP_MINIMUM_OPENCL_VERSION != 120 && CL_HPP_MINIMUM_OPENCL_VERSION != 200
52  # pragma message("cl2.hpp: CL_HPP_MINIMUM_OPENCL_VERSION is not a valid value (100, 110, 120 or 200). It will be set to 100")
53  # undef CL_HPP_MINIMUM_OPENCL_VERSION
54  # define CL_HPP_MINIMUM_OPENCL_VERSION 100
55  #endif
56  #if CL_HPP_MINIMUM_OPENCL_VERSION > CL_HPP_TARGET_OPENCL_VERSION
57  # error "CL_HPP_MINIMUM_OPENCL_VERSION must not be greater than CL_HPP_TARGET_OPENCL_VERSION"
58  #endif
59  #if CL_HPP_MINIMUM_OPENCL_VERSION <= 100 && !defined(CL_USE_DEPRECATED_OPENCL_1_0_APIS)
60  # define CL_USE_DEPRECATED_OPENCL_1_0_APIS
61  #endif
62  #if CL_HPP_MINIMUM_OPENCL_VERSION <= 110 && !defined(CL_USE_DEPRECATED_OPENCL_1_1_APIS)
63  # define CL_USE_DEPRECATED_OPENCL_1_1_APIS
64  #endif
65  #if CL_HPP_MINIMUM_OPENCL_VERSION <= 120 && !defined(CL_USE_DEPRECATED_OPENCL_1_2_APIS)
66  # define CL_USE_DEPRECATED_OPENCL_1_2_APIS
67  #endif
68  #if CL_HPP_MINIMUM_OPENCL_VERSION <= 200 && !defined(CL_USE_DEPRECATED_OPENCL_2_0_APIS)
69  # define CL_USE_DEPRECATED_OPENCL_2_0_APIS
70  #endif
71  #ifdef _WIN32
72  #include <malloc.h>
73  #if defined(CL_HPP_USE_DX_INTEROP)
74  #include <CL/cl_d3d10.h>
75  #include <CL/cl_dx9_media_sharing.h>
76  #endif
77  #endif 
78  #if defined(_MSC_VER)
79  #include <intrin.h>
80  #endif 
81  #if (!defined(_MSC_VER) && __cplusplus < 201103L) || (defined(_MSC_VER) && _MSC_VER < 1700)
82  #error Visual studio 2013 or another C++11-supporting compiler required
83  #endif
84  #if defined(CL_HPP_USE_CL_DEVICE_FISSION) || defined(CL_HPP_USE_CL_SUB_GROUPS_KHR)
85  #include <CL/cl_ext.h>
86  #endif
87  #if defined(__APPLE__) || defined(__MACOSX)
88  #include <OpenCL/opencl.h>
89  #else
90  #include <CL/opencl.h>
91  #endif 
92  #if (__cplusplus >= 201103L)
93  #define CL_HPP_NOEXCEPT_ noexcept
94  #else
95  #define CL_HPP_NOEXCEPT_
96  #endif
97  #if defined(_MSC_VER)
98  # define CL_HPP_DEFINE_STATIC_MEMBER_ __declspec(selectany)
99  #else
100  # define CL_HPP_DEFINE_STATIC_MEMBER_ __attribute__((weak))
101  #endif 
102  #if !defined(CL_EXT_PREFIX__VERSION_1_1_DEPRECATED)
103  #define CL_EXT_PREFIX__VERSION_1_1_DEPRECATED  
104  #endif 
105  #if !defined(CL_EXT_SUFFIX__VERSION_1_1_DEPRECATED)
106  #define CL_EXT_SUFFIX__VERSION_1_1_DEPRECATED
107  #endif 
108  #if !defined(CL_EXT_PREFIX__VERSION_1_2_DEPRECATED)
109  #define CL_EXT_PREFIX__VERSION_1_2_DEPRECATED  
110  #endif 
111  #if !defined(CL_EXT_SUFFIX__VERSION_1_2_DEPRECATED)
112  #define CL_EXT_SUFFIX__VERSION_1_2_DEPRECATED
113  #endif 
114  #if !defined(CL_CALLBACK)
115  #define CL_CALLBACK
116  #endif 
117  #include <utility>
118  #include <limits>
119  #include <iterator>
120  #include <mutex>
121  #include <cstring>
122  #include <functional>
123  #if defined(CL_HPP_ENABLE_SIZE_T_COMPATIBILITY)
124  namespace cl {
125      using size_type = ::size_t;
126  } 
127  #else 
128  namespace cl {
129      using size_type = size_t;
130  } 
131  #endif 
132  #if defined(CL_HPP_ENABLE_EXCEPTIONS)
133  #include <exception>
134  #endif 
135  #if !defined(CL_HPP_NO_STD_VECTOR)
136  #include <vector>
137  namespace cl {
138      template < class T, class Alloc = std::allocator<T> >
139      using vector = std::vector<T, Alloc>;
140  } 
141  #endif 
142  #if !defined(CL_HPP_NO_STD_STRING)
143  #include <string>
144  namespace cl {
145      using string = std::string;
146  } 
147  #endif 
148  #if CL_HPP_TARGET_OPENCL_VERSION >= 200
149  #if !defined(CL_HPP_NO_STD_UNIQUE_PTR)
150  #include <memory>
151  namespace cl {
152      template<class T, class D>
153      using pointer = std::unique_ptr<T, D>;
154  } 
155  #endif 
156  #endif 
157  #if !defined(CL_HPP_NO_STD_ARRAY)
158  #include <array>
159  namespace cl {
160      template < class T, size_type N >
161      using array = std::array<T, N>;
162  } 
163  #endif 
164  #if defined(CL_HPP_ENABLE_SIZE_T_COMPATIBILITY)
165  namespace cl {
166      namespace compatibility {
167          template <int N>
168          class size_t
169          {
170          private:
171              size_type data_[N];
172          public:
173              size_t()
174              {
175                  for (int i = 0; i < N; ++i) {
176                      data_[i] = 0;
177                  }
178              }
179              size_t(const array<size_type, N> &rhs)
180              {
181                  for (int i = 0; i < N; ++i) {
182                      data_[i] = rhs[i];
183                  }
184              }
185              size_type& operator[](int index)
186              {
187                  return data_[index];
188              }
189              const size_type& operator[](int index) const
190              {
191                  return data_[index];
192              }
193              operator size_type* ()             { return data_; }
194              operator const size_type* () const { return data_; }
195              operator array<size_type, N>() const
196              {
197                  array<size_type, N> ret;
198                  for (int i = 0; i < N; ++i) {
199                      ret[i] = data_[i];
200                  }
201                  return ret;
202              }
203          };
204      } 
205      template<int N>
206      using size_t = compatibility::size_t<N>;
207  } 
208  #endif 
209  namespace cl {
210      namespace detail {
211          using size_t_array = array<size_type, 3>;
212      } 
213  } 
214  namespace cl {
215      class Memory;
216  #define CL_HPP_INIT_CL_EXT_FCN_PTR_(name) \
217      if (!pfn_##name) {    \
218      pfn_##name = (PFN_##name) \
219      clGetExtensionFunctionAddress(#name); \
220      if (!pfn_##name) {    \
221      } \
222      }
223  #define CL_HPP_INIT_CL_EXT_FCN_PTR_PLATFORM_(platform, name) \
224      if (!pfn_##name) {    \
225      pfn_##name = (PFN_##name) \
226      clGetExtensionFunctionAddressForPlatform(platform, #name); \
227      if (!pfn_##name) {    \
228      } \
229      }
230      class Program;
231      class Device;
232      class Context;
233      class CommandQueue;
234      class DeviceCommandQueue;
235      class Memory;
236      class Buffer;
237      class Pipe;
238  #if defined(CL_HPP_ENABLE_EXCEPTIONS)
239      class Error : public std::exception
240      {
241      private:
242          cl_int err_;
243          const char * errStr_;
244      public:
245          Error(cl_int err, const char * errStr = NULL) : err_(err), errStr_(errStr)
246          {}
247          ~Error() throw() {}
248          virtual const char * what() const throw ()
249          {
250              if (errStr_ == NULL) {
251                  return "empty";
252              }
253              else {
254                  return errStr_;
255              }
256          }
257          cl_int err(void) const { return err_; }
258      };
259  #define CL_HPP_ERR_STR_(x) #x
260  #else
261  #define CL_HPP_ERR_STR_(x) NULL
262  #endif 
263  namespace detail
264  {
265  #if defined(CL_HPP_ENABLE_EXCEPTIONS)
266  static inline cl_int errHandler (
267      cl_int err,
268      const char * errStr = NULL)
269  {
270      if (err != CL_SUCCESS) {
271          throw Error(err, errStr);
272      }
273      return err;
274  }
275  #else
276  static inline cl_int errHandler (cl_int err, const char * errStr = NULL)
277  {
278      (void) errStr; 
279      return err;
280  }
281  #endif 
282  }
283  #if !defined(CL_HPP_USER_OVERRIDE_ERROR_STRINGS)
284  #define __GET_DEVICE_INFO_ERR               CL_HPP_ERR_STR_(clGetDeviceInfo)
285  #define __GET_PLATFORM_INFO_ERR             CL_HPP_ERR_STR_(clGetPlatformInfo)
286  #define __GET_DEVICE_IDS_ERR                CL_HPP_ERR_STR_(clGetDeviceIDs)
287  #define __GET_PLATFORM_IDS_ERR              CL_HPP_ERR_STR_(clGetPlatformIDs)
288  #define __GET_CONTEXT_INFO_ERR              CL_HPP_ERR_STR_(clGetContextInfo)
289  #define __GET_EVENT_INFO_ERR                CL_HPP_ERR_STR_(clGetEventInfo)
290  #define __GET_EVENT_PROFILE_INFO_ERR        CL_HPP_ERR_STR_(clGetEventProfileInfo)
291  #define __GET_MEM_OBJECT_INFO_ERR           CL_HPP_ERR_STR_(clGetMemObjectInfo)
292  #define __GET_IMAGE_INFO_ERR                CL_HPP_ERR_STR_(clGetImageInfo)
293  #define __GET_SAMPLER_INFO_ERR              CL_HPP_ERR_STR_(clGetSamplerInfo)
294  #define __GET_KERNEL_INFO_ERR               CL_HPP_ERR_STR_(clGetKernelInfo)
295  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
296  #define __GET_KERNEL_ARG_INFO_ERR           CL_HPP_ERR_STR_(clGetKernelArgInfo)
297  #endif 
298  #define __GET_KERNEL_WORK_GROUP_INFO_ERR    CL_HPP_ERR_STR_(clGetKernelWorkGroupInfo)
299  #define __GET_PROGRAM_INFO_ERR              CL_HPP_ERR_STR_(clGetProgramInfo)
300  #define __GET_PROGRAM_BUILD_INFO_ERR        CL_HPP_ERR_STR_(clGetProgramBuildInfo)
301  #define __GET_COMMAND_QUEUE_INFO_ERR        CL_HPP_ERR_STR_(clGetCommandQueueInfo)
302  #define __CREATE_CONTEXT_ERR                CL_HPP_ERR_STR_(clCreateContext)
303  #define __CREATE_CONTEXT_FROM_TYPE_ERR      CL_HPP_ERR_STR_(clCreateContextFromType)
304  #define __GET_SUPPORTED_IMAGE_FORMATS_ERR   CL_HPP_ERR_STR_(clGetSupportedImageFormats)
305  #define __CREATE_BUFFER_ERR                 CL_HPP_ERR_STR_(clCreateBuffer)
306  #define __COPY_ERR                          CL_HPP_ERR_STR_(cl::copy)
307  #define __CREATE_SUBBUFFER_ERR              CL_HPP_ERR_STR_(clCreateSubBuffer)
308  #define __CREATE_GL_BUFFER_ERR              CL_HPP_ERR_STR_(clCreateFromGLBuffer)
309  #define __CREATE_GL_RENDER_BUFFER_ERR       CL_HPP_ERR_STR_(clCreateFromGLBuffer)
310  #define __GET_GL_OBJECT_INFO_ERR            CL_HPP_ERR_STR_(clGetGLObjectInfo)
311  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
312  #define __CREATE_IMAGE_ERR                  CL_HPP_ERR_STR_(clCreateImage)
313  #define __CREATE_GL_TEXTURE_ERR             CL_HPP_ERR_STR_(clCreateFromGLTexture)
314  #define __IMAGE_DIMENSION_ERR               CL_HPP_ERR_STR_(Incorrect image dimensions)
315  #endif 
316  #define __SET_MEM_OBJECT_DESTRUCTOR_CALLBACK_ERR CL_HPP_ERR_STR_(clSetMemObjectDestructorCallback)
317  #define __CREATE_USER_EVENT_ERR             CL_HPP_ERR_STR_(clCreateUserEvent)
318  #define __SET_USER_EVENT_STATUS_ERR         CL_HPP_ERR_STR_(clSetUserEventStatus)
319  #define __SET_EVENT_CALLBACK_ERR            CL_HPP_ERR_STR_(clSetEventCallback)
320  #define __WAIT_FOR_EVENTS_ERR               CL_HPP_ERR_STR_(clWaitForEvents)
321  #define __CREATE_KERNEL_ERR                 CL_HPP_ERR_STR_(clCreateKernel)
322  #define __SET_KERNEL_ARGS_ERR               CL_HPP_ERR_STR_(clSetKernelArg)
323  #define __CREATE_PROGRAM_WITH_SOURCE_ERR    CL_HPP_ERR_STR_(clCreateProgramWithSource)
324  #define __CREATE_PROGRAM_WITH_BINARY_ERR    CL_HPP_ERR_STR_(clCreateProgramWithBinary)
325  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
326  #define __CREATE_PROGRAM_WITH_BUILT_IN_KERNELS_ERR    CL_HPP_ERR_STR_(clCreateProgramWithBuiltInKernels)
327  #endif 
328  #define __BUILD_PROGRAM_ERR                 CL_HPP_ERR_STR_(clBuildProgram)
329  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
330  #define __COMPILE_PROGRAM_ERR               CL_HPP_ERR_STR_(clCompileProgram)
331  #define __LINK_PROGRAM_ERR                  CL_HPP_ERR_STR_(clLinkProgram)
332  #endif 
333  #define __CREATE_KERNELS_IN_PROGRAM_ERR     CL_HPP_ERR_STR_(clCreateKernelsInProgram)
334  #if CL_HPP_TARGET_OPENCL_VERSION >= 200
335  #define __CREATE_COMMAND_QUEUE_WITH_PROPERTIES_ERR          CL_HPP_ERR_STR_(clCreateCommandQueueWithProperties)
336  #define __CREATE_SAMPLER_WITH_PROPERTIES_ERR                CL_HPP_ERR_STR_(clCreateSamplerWithProperties)
337  #endif 
338  #define __SET_COMMAND_QUEUE_PROPERTY_ERR    CL_HPP_ERR_STR_(clSetCommandQueueProperty)
339  #define __ENQUEUE_READ_BUFFER_ERR           CL_HPP_ERR_STR_(clEnqueueReadBuffer)
340  #define __ENQUEUE_READ_BUFFER_RECT_ERR      CL_HPP_ERR_STR_(clEnqueueReadBufferRect)
341  #define __ENQUEUE_WRITE_BUFFER_ERR          CL_HPP_ERR_STR_(clEnqueueWriteBuffer)
342  #define __ENQUEUE_WRITE_BUFFER_RECT_ERR     CL_HPP_ERR_STR_(clEnqueueWriteBufferRect)
343  #define __ENQEUE_COPY_BUFFER_ERR            CL_HPP_ERR_STR_(clEnqueueCopyBuffer)
344  #define __ENQEUE_COPY_BUFFER_RECT_ERR       CL_HPP_ERR_STR_(clEnqueueCopyBufferRect)
345  #define __ENQUEUE_FILL_BUFFER_ERR           CL_HPP_ERR_STR_(clEnqueueFillBuffer)
346  #define __ENQUEUE_READ_IMAGE_ERR            CL_HPP_ERR_STR_(clEnqueueReadImage)
347  #define __ENQUEUE_WRITE_IMAGE_ERR           CL_HPP_ERR_STR_(clEnqueueWriteImage)
348  #define __ENQUEUE_COPY_IMAGE_ERR            CL_HPP_ERR_STR_(clEnqueueCopyImage)
349  #define __ENQUEUE_FILL_IMAGE_ERR            CL_HPP_ERR_STR_(clEnqueueFillImage)
350  #define __ENQUEUE_COPY_IMAGE_TO_BUFFER_ERR  CL_HPP_ERR_STR_(clEnqueueCopyImageToBuffer)
351  #define __ENQUEUE_COPY_BUFFER_TO_IMAGE_ERR  CL_HPP_ERR_STR_(clEnqueueCopyBufferToImage)
352  #define __ENQUEUE_MAP_BUFFER_ERR            CL_HPP_ERR_STR_(clEnqueueMapBuffer)
353  #define __ENQUEUE_MAP_IMAGE_ERR             CL_HPP_ERR_STR_(clEnqueueMapImage)
354  #define __ENQUEUE_UNMAP_MEM_OBJECT_ERR      CL_HPP_ERR_STR_(clEnqueueUnMapMemObject)
355  #define __ENQUEUE_NDRANGE_KERNEL_ERR        CL_HPP_ERR_STR_(clEnqueueNDRangeKernel)
356  #define __ENQUEUE_NATIVE_KERNEL             CL_HPP_ERR_STR_(clEnqueueNativeKernel)
357  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
358  #define __ENQUEUE_MIGRATE_MEM_OBJECTS_ERR   CL_HPP_ERR_STR_(clEnqueueMigrateMemObjects)
359  #endif 
360  #define __ENQUEUE_ACQUIRE_GL_ERR            CL_HPP_ERR_STR_(clEnqueueAcquireGLObjects)
361  #define __ENQUEUE_RELEASE_GL_ERR            CL_HPP_ERR_STR_(clEnqueueReleaseGLObjects)
362  #define __CREATE_PIPE_ERR             CL_HPP_ERR_STR_(clCreatePipe)
363  #define __GET_PIPE_INFO_ERR           CL_HPP_ERR_STR_(clGetPipeInfo)
364  #define __RETAIN_ERR                        CL_HPP_ERR_STR_(Retain Object)
365  #define __RELEASE_ERR                       CL_HPP_ERR_STR_(Release Object)
366  #define __FLUSH_ERR                         CL_HPP_ERR_STR_(clFlush)
367  #define __FINISH_ERR                        CL_HPP_ERR_STR_(clFinish)
368  #define __VECTOR_CAPACITY_ERR               CL_HPP_ERR_STR_(Vector capacity error)
369  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
370  #define __CREATE_SUB_DEVICES_ERR            CL_HPP_ERR_STR_(clCreateSubDevices)
371  #else
372  #define __CREATE_SUB_DEVICES_ERR            CL_HPP_ERR_STR_(clCreateSubDevicesEXT)
373  #endif 
374  #if defined(CL_USE_DEPRECATED_OPENCL_1_1_APIS)
375  #define __ENQUEUE_MARKER_ERR                CL_HPP_ERR_STR_(clEnqueueMarker)
376  #define __ENQUEUE_WAIT_FOR_EVENTS_ERR       CL_HPP_ERR_STR_(clEnqueueWaitForEvents)
377  #define __ENQUEUE_BARRIER_ERR               CL_HPP_ERR_STR_(clEnqueueBarrier)
378  #define __UNLOAD_COMPILER_ERR               CL_HPP_ERR_STR_(clUnloadCompiler)
379  #define __CREATE_GL_TEXTURE_2D_ERR          CL_HPP_ERR_STR_(clCreateFromGLTexture2D)
380  #define __CREATE_GL_TEXTURE_3D_ERR          CL_HPP_ERR_STR_(clCreateFromGLTexture3D)
381  #define __CREATE_IMAGE2D_ERR                CL_HPP_ERR_STR_(clCreateImage2D)
382  #define __CREATE_IMAGE3D_ERR                CL_HPP_ERR_STR_(clCreateImage3D)
383  #endif 
384  #if defined(CL_USE_DEPRECATED_OPENCL_1_2_APIS)
385  #define __CREATE_COMMAND_QUEUE_ERR          CL_HPP_ERR_STR_(clCreateCommandQueue)
386  #define __ENQUEUE_TASK_ERR                  CL_HPP_ERR_STR_(clEnqueueTask)
387  #define __CREATE_SAMPLER_ERR                CL_HPP_ERR_STR_(clCreateSampler)
388  #endif 
389  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
390  #define __ENQUEUE_MARKER_WAIT_LIST_ERR                CL_HPP_ERR_STR_(clEnqueueMarkerWithWaitList)
391  #define __ENQUEUE_BARRIER_WAIT_LIST_ERR               CL_HPP_ERR_STR_(clEnqueueBarrierWithWaitList)
392  #endif 
393  #endif 
394  namespace detail {
395  template<typename Functor, typename T>
396  inline cl_int getInfoHelper(Functor f, cl_uint name, T* param, long)
397  {
398      return f(name, sizeof(T), param, NULL);
399  }
400  template <typename Func>
401  inline cl_int getInfoHelper(Func f, cl_uint name, vector<vector<unsigned char>>* param, int)
402  {
403      if (name != CL_PROGRAM_BINARIES) {
404          return CL_INVALID_VALUE;
405      }
406      if (param) {
407          size_type numBinaries = param->size();
408          vector<unsigned char*> binariesPointers(numBinaries);
409          size_type totalSize = 0;
410          for (size_type i = 0; i < numBinaries; ++i)
411          {
412              binariesPointers[i] = (*param)[i].data();
413              totalSize += (*param)[i].size();
414          }
415          cl_int err = f(name, totalSize, binariesPointers.data(), NULL);
416          if (err != CL_SUCCESS) {
417              return err;
418          }
419      }
420      return CL_SUCCESS;
421  }
422  template <typename Func, typename T>
423  inline cl_int getInfoHelper(Func f, cl_uint name, vector<T>* param, long)
424  {
425      size_type required;
426      cl_int err = f(name, 0, NULL, &required);
427      if (err != CL_SUCCESS) {
428          return err;
429      }
430      const size_type elements = required / sizeof(T);
431      vector<T> localData(elements);
432      err = f(name, required, localData.data(), NULL);
433      if (err != CL_SUCCESS) {
434          return err;
435      }
436      if (param) {
437          *param = std::move(localData);
438      }
439      return CL_SUCCESS;
440  }
441  template <typename Func, typename T>
442  inline cl_int getInfoHelper(
443      Func f, cl_uint name, vector<T>* param, int, typename T::cl_type = 0)
444  {
445      size_type required;
446      cl_int err = f(name, 0, NULL, &required);
447      if (err != CL_SUCCESS) {
448          return err;
449      }
450      const size_type elements = required / sizeof(typename T::cl_type);
451      vector<typename T::cl_type> value(elements);
452      err = f(name, required, value.data(), NULL);
453      if (err != CL_SUCCESS) {
454          return err;
455      }
456      if (param) {
457          param->resize(elements);
458          for (size_type i = 0; i < elements; i++) {
459              (*param)[i] = T(value[i], true);
460          }
461      }
462      return CL_SUCCESS;
463  }
464  template <typename Func>
465  inline cl_int getInfoHelper(Func f, cl_uint name, string* param, long)
466  {
467      size_type required;
468      cl_int err = f(name, 0, NULL, &required);
469      if (err != CL_SUCCESS) {
470          return err;
471      }
472      if (required > 0) {
473          vector<char> value(required);
474          err = f(name, required, value.data(), NULL);
475          if (err != CL_SUCCESS) {
476              return err;
477          }
478          if (param) {
479              param->assign(begin(value), prev(end(value)));
480          }
481      }
482      else if (param) {
483          param->assign("");
484      }
485      return CL_SUCCESS;
486  }
487  template <typename Func, size_type N>
488  inline cl_int getInfoHelper(Func f, cl_uint name, array<size_type, N>* param, long)
489  {
490      size_type required;
491      cl_int err = f(name, 0, NULL, &required);
492      if (err != CL_SUCCESS) {
493          return err;
494      }
495      size_type elements = required / sizeof(size_type);
496      vector<size_type> value(elements, 0);
497      err = f(name, required, value.data(), NULL);
498      if (err != CL_SUCCESS) {
499          return err;
500      }
501      if (elements > N) {
502          elements = N;
503      }
504      for (size_type i = 0; i < elements; ++i) {
505          (*param)[i] = value[i];
506      }
507      return CL_SUCCESS;
508  }
509  template<typename T> struct ReferenceHandler;
510  template<typename Func, typename T>
511  inline cl_int getInfoHelper(Func f, cl_uint name, T* param, int, typename T::cl_type = 0)
512  {
513      typename T::cl_type value;
514      cl_int err = f(name, sizeof(value), &value, NULL);
515      if (err != CL_SUCCESS) {
516          return err;
517      }
518      *param = value;
519      if (value != NULL)
520      {
521          err = param->retain();
522          if (err != CL_SUCCESS) {
523              return err;
524          }
525      }
526      return CL_SUCCESS;
527  }
528  #define CL_HPP_PARAM_NAME_INFO_1_0_(F) \
529      F(cl_platform_info, CL_PLATFORM_PROFILE, string) \
530      F(cl_platform_info, CL_PLATFORM_VERSION, string) \
531      F(cl_platform_info, CL_PLATFORM_NAME, string) \
532      F(cl_platform_info, CL_PLATFORM_VENDOR, string) \
533      F(cl_platform_info, CL_PLATFORM_EXTENSIONS, string) \
534      \
535      F(cl_device_info, CL_DEVICE_TYPE, cl_device_type) \
536      F(cl_device_info, CL_DEVICE_VENDOR_ID, cl_uint) \
537      F(cl_device_info, CL_DEVICE_MAX_COMPUTE_UNITS, cl_uint) \
538      F(cl_device_info, CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS, cl_uint) \
539      F(cl_device_info, CL_DEVICE_MAX_WORK_GROUP_SIZE, size_type) \
540      F(cl_device_info, CL_DEVICE_MAX_WORK_ITEM_SIZES, cl::vector<size_type>) \
541      F(cl_device_info, CL_DEVICE_PREFERRED_VECTOR_WIDTH_CHAR, cl_uint) \
542      F(cl_device_info, CL_DEVICE_PREFERRED_VECTOR_WIDTH_SHORT, cl_uint) \
543      F(cl_device_info, CL_DEVICE_PREFERRED_VECTOR_WIDTH_INT, cl_uint) \
544      F(cl_device_info, CL_DEVICE_PREFERRED_VECTOR_WIDTH_LONG, cl_uint) \
545      F(cl_device_info, CL_DEVICE_PREFERRED_VECTOR_WIDTH_FLOAT, cl_uint) \
546      F(cl_device_info, CL_DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE, cl_uint) \
547      F(cl_device_info, CL_DEVICE_MAX_CLOCK_FREQUENCY, cl_uint) \
548      F(cl_device_info, CL_DEVICE_ADDRESS_BITS, cl_uint) \
549      F(cl_device_info, CL_DEVICE_MAX_READ_IMAGE_ARGS, cl_uint) \
550      F(cl_device_info, CL_DEVICE_MAX_WRITE_IMAGE_ARGS, cl_uint) \
551      F(cl_device_info, CL_DEVICE_MAX_MEM_ALLOC_SIZE, cl_ulong) \
552      F(cl_device_info, CL_DEVICE_IMAGE2D_MAX_WIDTH, size_type) \
553      F(cl_device_info, CL_DEVICE_IMAGE2D_MAX_HEIGHT, size_type) \
554      F(cl_device_info, CL_DEVICE_IMAGE3D_MAX_WIDTH, size_type) \
555      F(cl_device_info, CL_DEVICE_IMAGE3D_MAX_HEIGHT, size_type) \
556      F(cl_device_info, CL_DEVICE_IMAGE3D_MAX_DEPTH, size_type) \
557      F(cl_device_info, CL_DEVICE_IMAGE_SUPPORT, cl_bool) \
558      F(cl_device_info, CL_DEVICE_MAX_PARAMETER_SIZE, size_type) \
559      F(cl_device_info, CL_DEVICE_MAX_SAMPLERS, cl_uint) \
560      F(cl_device_info, CL_DEVICE_MEM_BASE_ADDR_ALIGN, cl_uint) \
561      F(cl_device_info, CL_DEVICE_MIN_DATA_TYPE_ALIGN_SIZE, cl_uint) \
562      F(cl_device_info, CL_DEVICE_SINGLE_FP_CONFIG, cl_device_fp_config) \
563      F(cl_device_info, CL_DEVICE_GLOBAL_MEM_CACHE_TYPE, cl_device_mem_cache_type) \
564      F(cl_device_info, CL_DEVICE_GLOBAL_MEM_CACHELINE_SIZE, cl_uint)\
565      F(cl_device_info, CL_DEVICE_GLOBAL_MEM_CACHE_SIZE, cl_ulong) \
566      F(cl_device_info, CL_DEVICE_GLOBAL_MEM_SIZE, cl_ulong) \
567      F(cl_device_info, CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE, cl_ulong) \
568      F(cl_device_info, CL_DEVICE_MAX_CONSTANT_ARGS, cl_uint) \
569      F(cl_device_info, CL_DEVICE_LOCAL_MEM_TYPE, cl_device_local_mem_type) \
570      F(cl_device_info, CL_DEVICE_LOCAL_MEM_SIZE, cl_ulong) \
571      F(cl_device_info, CL_DEVICE_ERROR_CORRECTION_SUPPORT, cl_bool) \
572      F(cl_device_info, CL_DEVICE_PROFILING_TIMER_RESOLUTION, size_type) \
573      F(cl_device_info, CL_DEVICE_ENDIAN_LITTLE, cl_bool) \
574      F(cl_device_info, CL_DEVICE_AVAILABLE, cl_bool) \
575      F(cl_device_info, CL_DEVICE_COMPILER_AVAILABLE, cl_bool) \
576      F(cl_device_info, CL_DEVICE_EXECUTION_CAPABILITIES, cl_device_exec_capabilities) \
577      F(cl_device_info, CL_DEVICE_PLATFORM, cl_platform_id) \
578      F(cl_device_info, CL_DEVICE_NAME, string) \
579      F(cl_device_info, CL_DEVICE_VENDOR, string) \
580      F(cl_device_info, CL_DRIVER_VERSION, string) \
581      F(cl_device_info, CL_DEVICE_PROFILE, string) \
582      F(cl_device_info, CL_DEVICE_VERSION, string) \
583      F(cl_device_info, CL_DEVICE_EXTENSIONS, string) \
584      \
585      F(cl_context_info, CL_CONTEXT_REFERENCE_COUNT, cl_uint) \
586      F(cl_context_info, CL_CONTEXT_DEVICES, cl::vector<Device>) \
587      F(cl_context_info, CL_CONTEXT_PROPERTIES, cl::vector<cl_context_properties>) \
588      \
589      F(cl_event_info, CL_EVENT_COMMAND_QUEUE, cl::CommandQueue) \
590      F(cl_event_info, CL_EVENT_COMMAND_TYPE, cl_command_type) \
591      F(cl_event_info, CL_EVENT_REFERENCE_COUNT, cl_uint) \
592      F(cl_event_info, CL_EVENT_COMMAND_EXECUTION_STATUS, cl_int) \
593      \
594      F(cl_profiling_info, CL_PROFILING_COMMAND_QUEUED, cl_ulong) \
595      F(cl_profiling_info, CL_PROFILING_COMMAND_SUBMIT, cl_ulong) \
596      F(cl_profiling_info, CL_PROFILING_COMMAND_START, cl_ulong) \
597      F(cl_profiling_info, CL_PROFILING_COMMAND_END, cl_ulong) \
598      \
599      F(cl_mem_info, CL_MEM_TYPE, cl_mem_object_type) \
600      F(cl_mem_info, CL_MEM_FLAGS, cl_mem_flags) \
601      F(cl_mem_info, CL_MEM_SIZE, size_type) \
602      F(cl_mem_info, CL_MEM_HOST_PTR, void*) \
603      F(cl_mem_info, CL_MEM_MAP_COUNT, cl_uint) \
604      F(cl_mem_info, CL_MEM_REFERENCE_COUNT, cl_uint) \
605      F(cl_mem_info, CL_MEM_CONTEXT, cl::Context) \
606      \
607      F(cl_image_info, CL_IMAGE_FORMAT, cl_image_format) \
608      F(cl_image_info, CL_IMAGE_ELEMENT_SIZE, size_type) \
609      F(cl_image_info, CL_IMAGE_ROW_PITCH, size_type) \
610      F(cl_image_info, CL_IMAGE_SLICE_PITCH, size_type) \
611      F(cl_image_info, CL_IMAGE_WIDTH, size_type) \
612      F(cl_image_info, CL_IMAGE_HEIGHT, size_type) \
613      F(cl_image_info, CL_IMAGE_DEPTH, size_type) \
614      F(cl_image_info, CL_IMAGE_ARRAY_SIZE, size_type) \
615      F(cl_image_info, CL_IMAGE_NUM_MIP_LEVELS, cl_uint) \
616      F(cl_image_info, CL_IMAGE_NUM_SAMPLES, cl_uint) \
617      \
618      F(cl_sampler_info, CL_SAMPLER_REFERENCE_COUNT, cl_uint) \
619      F(cl_sampler_info, CL_SAMPLER_CONTEXT, cl::Context) \
620      F(cl_sampler_info, CL_SAMPLER_NORMALIZED_COORDS, cl_bool) \
621      F(cl_sampler_info, CL_SAMPLER_ADDRESSING_MODE, cl_addressing_mode) \
622      F(cl_sampler_info, CL_SAMPLER_FILTER_MODE, cl_filter_mode) \
623      \
624      F(cl_program_info, CL_PROGRAM_REFERENCE_COUNT, cl_uint) \
625      F(cl_program_info, CL_PROGRAM_CONTEXT, cl::Context) \
626      F(cl_program_info, CL_PROGRAM_NUM_DEVICES, cl_uint) \
627      F(cl_program_info, CL_PROGRAM_DEVICES, cl::vector<Device>) \
628      F(cl_program_info, CL_PROGRAM_SOURCE, string) \
629      F(cl_program_info, CL_PROGRAM_BINARY_SIZES, cl::vector<size_type>) \
630      F(cl_program_info, CL_PROGRAM_BINARIES, cl::vector<cl::vector<unsigned char>>) \
631      \
632      F(cl_program_build_info, CL_PROGRAM_BUILD_STATUS, cl_build_status) \
633      F(cl_program_build_info, CL_PROGRAM_BUILD_OPTIONS, string) \
634      F(cl_program_build_info, CL_PROGRAM_BUILD_LOG, string) \
635      \
636      F(cl_kernel_info, CL_KERNEL_FUNCTION_NAME, string) \
637      F(cl_kernel_info, CL_KERNEL_NUM_ARGS, cl_uint) \
638      F(cl_kernel_info, CL_KERNEL_REFERENCE_COUNT, cl_uint) \
639      F(cl_kernel_info, CL_KERNEL_CONTEXT, cl::Context) \
640      F(cl_kernel_info, CL_KERNEL_PROGRAM, cl::Program) \
641      \
642      F(cl_kernel_work_group_info, CL_KERNEL_WORK_GROUP_SIZE, size_type) \
643      F(cl_kernel_work_group_info, CL_KERNEL_COMPILE_WORK_GROUP_SIZE, cl::detail::size_t_array) \
644      F(cl_kernel_work_group_info, CL_KERNEL_LOCAL_MEM_SIZE, cl_ulong) \
645      \
646      F(cl_command_queue_info, CL_QUEUE_CONTEXT, cl::Context) \
647      F(cl_command_queue_info, CL_QUEUE_DEVICE, cl::Device) \
648      F(cl_command_queue_info, CL_QUEUE_REFERENCE_COUNT, cl_uint) \
649      F(cl_command_queue_info, CL_QUEUE_PROPERTIES, cl_command_queue_properties)
650  #define CL_HPP_PARAM_NAME_INFO_1_1_(F) \
651      F(cl_context_info, CL_CONTEXT_NUM_DEVICES, cl_uint)\
652      F(cl_device_info, CL_DEVICE_PREFERRED_VECTOR_WIDTH_HALF, cl_uint) \
653      F(cl_device_info, CL_DEVICE_NATIVE_VECTOR_WIDTH_CHAR, cl_uint) \
654      F(cl_device_info, CL_DEVICE_NATIVE_VECTOR_WIDTH_SHORT, cl_uint) \
655      F(cl_device_info, CL_DEVICE_NATIVE_VECTOR_WIDTH_INT, cl_uint) \
656      F(cl_device_info, CL_DEVICE_NATIVE_VECTOR_WIDTH_LONG, cl_uint) \
657      F(cl_device_info, CL_DEVICE_NATIVE_VECTOR_WIDTH_FLOAT, cl_uint) \
658      F(cl_device_info, CL_DEVICE_NATIVE_VECTOR_WIDTH_DOUBLE, cl_uint) \
659      F(cl_device_info, CL_DEVICE_NATIVE_VECTOR_WIDTH_HALF, cl_uint) \
660      F(cl_device_info, CL_DEVICE_DOUBLE_FP_CONFIG, cl_device_fp_config) \
661      F(cl_device_info, CL_DEVICE_HALF_FP_CONFIG, cl_device_fp_config) \
662      F(cl_device_info, CL_DEVICE_OPENCL_C_VERSION, string) \
663      \
664      F(cl_mem_info, CL_MEM_ASSOCIATED_MEMOBJECT, cl::Memory) \
665      F(cl_mem_info, CL_MEM_OFFSET, size_type) \
666      \
667      F(cl_kernel_work_group_info, CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE, size_type) \
668      F(cl_kernel_work_group_info, CL_KERNEL_PRIVATE_MEM_SIZE, cl_ulong) \
669      \
670      F(cl_event_info, CL_EVENT_CONTEXT, cl::Context)
671  #define CL_HPP_PARAM_NAME_INFO_1_2_(F) \
672      F(cl_program_info, CL_PROGRAM_NUM_KERNELS, size_type) \
673      F(cl_program_info, CL_PROGRAM_KERNEL_NAMES, string) \
674      \
675      F(cl_program_build_info, CL_PROGRAM_BINARY_TYPE, cl_program_binary_type) \
676      \
677      F(cl_kernel_info, CL_KERNEL_ATTRIBUTES, string) \
678      \
679      F(cl_kernel_arg_info, CL_KERNEL_ARG_ADDRESS_QUALIFIER, cl_kernel_arg_address_qualifier) \
680      F(cl_kernel_arg_info, CL_KERNEL_ARG_ACCESS_QUALIFIER, cl_kernel_arg_access_qualifier) \
681      F(cl_kernel_arg_info, CL_KERNEL_ARG_TYPE_NAME, string) \
682      F(cl_kernel_arg_info, CL_KERNEL_ARG_NAME, string) \
683      F(cl_kernel_arg_info, CL_KERNEL_ARG_TYPE_QUALIFIER, cl_kernel_arg_type_qualifier) \
684      \
685      F(cl_device_info, CL_DEVICE_PARENT_DEVICE, cl::Device) \
686      F(cl_device_info, CL_DEVICE_PARTITION_PROPERTIES, cl::vector<cl_device_partition_property>) \
687      F(cl_device_info, CL_DEVICE_PARTITION_TYPE, cl::vector<cl_device_partition_property>)  \
688      F(cl_device_info, CL_DEVICE_REFERENCE_COUNT, cl_uint) \
689      F(cl_device_info, CL_DEVICE_PREFERRED_INTEROP_USER_SYNC, size_type) \
690      F(cl_device_info, CL_DEVICE_PARTITION_AFFINITY_DOMAIN, cl_device_affinity_domain) \
691      F(cl_device_info, CL_DEVICE_BUILT_IN_KERNELS, string)
692  #define CL_HPP_PARAM_NAME_INFO_2_0_(F) \
693      F(cl_device_info, CL_DEVICE_QUEUE_ON_HOST_PROPERTIES, cl_command_queue_properties) \
694      F(cl_device_info, CL_DEVICE_QUEUE_ON_DEVICE_PROPERTIES, cl_command_queue_properties) \
695      F(cl_device_info, CL_DEVICE_QUEUE_ON_DEVICE_PREFERRED_SIZE, cl_uint) \
696      F(cl_device_info, CL_DEVICE_QUEUE_ON_DEVICE_MAX_SIZE, cl_uint) \
697      F(cl_device_info, CL_DEVICE_MAX_ON_DEVICE_QUEUES, cl_uint) \
698      F(cl_device_info, CL_DEVICE_MAX_ON_DEVICE_EVENTS, cl_uint) \
699      F(cl_device_info, CL_DEVICE_MAX_PIPE_ARGS, cl_uint) \
700      F(cl_device_info, CL_DEVICE_PIPE_MAX_ACTIVE_RESERVATIONS, cl_uint) \
701      F(cl_device_info, CL_DEVICE_PIPE_MAX_PACKET_SIZE, cl_uint) \
702      F(cl_device_info, CL_DEVICE_SVM_CAPABILITIES, cl_device_svm_capabilities) \
703      F(cl_device_info, CL_DEVICE_PREFERRED_PLATFORM_ATOMIC_ALIGNMENT, cl_uint) \
704      F(cl_device_info, CL_DEVICE_PREFERRED_GLOBAL_ATOMIC_ALIGNMENT, cl_uint) \
705      F(cl_device_info, CL_DEVICE_PREFERRED_LOCAL_ATOMIC_ALIGNMENT, cl_uint) \
706      F(cl_command_queue_info, CL_QUEUE_SIZE, cl_uint) \
707      F(cl_mem_info, CL_MEM_USES_SVM_POINTER, cl_bool) \
708      F(cl_program_build_info, CL_PROGRAM_BUILD_GLOBAL_VARIABLE_TOTAL_SIZE, size_type) \
709      F(cl_pipe_info, CL_PIPE_PACKET_SIZE, cl_uint) \
710      F(cl_pipe_info, CL_PIPE_MAX_PACKETS, cl_uint)
711  #define CL_HPP_PARAM_NAME_DEVICE_FISSION_(F) \
712      F(cl_device_info, CL_DEVICE_PARENT_DEVICE_EXT, cl_device_id) \
713      F(cl_device_info, CL_DEVICE_PARTITION_TYPES_EXT, cl::vector<cl_device_partition_property_ext>) \
714      F(cl_device_info, CL_DEVICE_AFFINITY_DOMAINS_EXT, cl::vector<cl_device_partition_property_ext>) \
715      F(cl_device_info, CL_DEVICE_REFERENCE_COUNT_EXT , cl_uint) \
716      F(cl_device_info, CL_DEVICE_PARTITION_STYLE_EXT, cl::vector<cl_device_partition_property_ext>)
717  template <typename enum_type, cl_int Name>
718  struct param_traits {};
719  #define CL_HPP_DECLARE_PARAM_TRAITS_(token, param_name, T) \
720  struct token;                                        \
721  template<>                                           \
722  struct param_traits<detail:: token,param_name>       \
723  {                                                    \
724      enum { value = param_name };                     \
725      typedef T param_type;                            \
726  };
727  CL_HPP_PARAM_NAME_INFO_1_0_(CL_HPP_DECLARE_PARAM_TRAITS_)
728  #if CL_HPP_TARGET_OPENCL_VERSION >= 110
729  CL_HPP_PARAM_NAME_INFO_1_1_(CL_HPP_DECLARE_PARAM_TRAITS_)
730  #endif 
731  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
732  CL_HPP_PARAM_NAME_INFO_1_2_(CL_HPP_DECLARE_PARAM_TRAITS_)
733  #endif 
734  #if CL_HPP_TARGET_OPENCL_VERSION >= 200
735  CL_HPP_PARAM_NAME_INFO_2_0_(CL_HPP_DECLARE_PARAM_TRAITS_)
736  #endif 
737  #define CL_HPP_PARAM_NAME_INFO_1_0_DEPRECATED_IN_2_0_(F) \
738      F(cl_device_info, CL_DEVICE_QUEUE_PROPERTIES, cl_command_queue_properties)
739  #define CL_HPP_PARAM_NAME_INFO_1_1_DEPRECATED_IN_2_0_(F) \
740      F(cl_device_info, CL_DEVICE_HOST_UNIFIED_MEMORY, cl_bool)
741  #define CL_HPP_PARAM_NAME_INFO_1_2_DEPRECATED_IN_2_0_(F) \
742      F(cl_image_info, CL_IMAGE_BUFFER, cl::Buffer)
743  #if CL_HPP_TARGET_OPENCL_VERSION > 100 && CL_HPP_MINIMUM_OPENCL_VERSION < 200 && CL_HPP_TARGET_OPENCL_VERSION < 200
744  CL_HPP_PARAM_NAME_INFO_1_0_DEPRECATED_IN_2_0_(CL_HPP_DECLARE_PARAM_TRAITS_)
745  #endif 
746  #if CL_HPP_TARGET_OPENCL_VERSION > 110 && CL_HPP_MINIMUM_OPENCL_VERSION < 200
747  CL_HPP_PARAM_NAME_INFO_1_1_DEPRECATED_IN_2_0_(CL_HPP_DECLARE_PARAM_TRAITS_)
748  #endif 
749  #if CL_HPP_TARGET_OPENCL_VERSION > 120 && CL_HPP_MINIMUM_OPENCL_VERSION < 200
750  CL_HPP_PARAM_NAME_INFO_1_2_DEPRECATED_IN_2_0_(CL_HPP_DECLARE_PARAM_TRAITS_)
751  #endif 
752  #if defined(CL_HPP_USE_CL_DEVICE_FISSION)
753  CL_HPP_PARAM_NAME_DEVICE_FISSION_(CL_HPP_DECLARE_PARAM_TRAITS_);
754  #endif 
755  #ifdef CL_PLATFORM_ICD_SUFFIX_KHR
756  CL_HPP_DECLARE_PARAM_TRAITS_(cl_platform_info, CL_PLATFORM_ICD_SUFFIX_KHR, string)
757  #endif
758  #ifdef CL_DEVICE_PROFILING_TIMER_OFFSET_AMD
759  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_PROFILING_TIMER_OFFSET_AMD, cl_ulong)
760  #endif
761  #ifdef CL_DEVICE_GLOBAL_FREE_MEMORY_AMD
762  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_GLOBAL_FREE_MEMORY_AMD, vector<size_type>)
763  #endif
764  #ifdef CL_DEVICE_SIMD_PER_COMPUTE_UNIT_AMD
765  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_SIMD_PER_COMPUTE_UNIT_AMD, cl_uint)
766  #endif
767  #ifdef CL_DEVICE_SIMD_WIDTH_AMD
768  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_SIMD_WIDTH_AMD, cl_uint)
769  #endif
770  #ifdef CL_DEVICE_SIMD_INSTRUCTION_WIDTH_AMD
771  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_SIMD_INSTRUCTION_WIDTH_AMD, cl_uint)
772  #endif
773  #ifdef CL_DEVICE_WAVEFRONT_WIDTH_AMD
774  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_WAVEFRONT_WIDTH_AMD, cl_uint)
775  #endif
776  #ifdef CL_DEVICE_GLOBAL_MEM_CHANNELS_AMD
777  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_GLOBAL_MEM_CHANNELS_AMD, cl_uint)
778  #endif
779  #ifdef CL_DEVICE_GLOBAL_MEM_CHANNEL_BANKS_AMD
780  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_GLOBAL_MEM_CHANNEL_BANKS_AMD, cl_uint)
781  #endif
782  #ifdef CL_DEVICE_GLOBAL_MEM_CHANNEL_BANK_WIDTH_AMD
783  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_GLOBAL_MEM_CHANNEL_BANK_WIDTH_AMD, cl_uint)
784  #endif
785  #ifdef CL_DEVICE_LOCAL_MEM_SIZE_PER_COMPUTE_UNIT_AMD
786  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_LOCAL_MEM_SIZE_PER_COMPUTE_UNIT_AMD, cl_uint)
787  #endif
788  #ifdef CL_DEVICE_LOCAL_MEM_BANKS_AMD
789  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_LOCAL_MEM_BANKS_AMD, cl_uint)
790  #endif
791  #ifdef CL_DEVICE_COMPUTE_CAPABILITY_MAJOR_NV
792  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_COMPUTE_CAPABILITY_MAJOR_NV, cl_uint)
793  #endif
794  #ifdef CL_DEVICE_COMPUTE_CAPABILITY_MINOR_NV
795  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_COMPUTE_CAPABILITY_MINOR_NV, cl_uint)
796  #endif
797  #ifdef CL_DEVICE_REGISTERS_PER_BLOCK_NV
798  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_REGISTERS_PER_BLOCK_NV, cl_uint)
799  #endif
800  #ifdef CL_DEVICE_WARP_SIZE_NV
801  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_WARP_SIZE_NV, cl_uint)
802  #endif
803  #ifdef CL_DEVICE_GPU_OVERLAP_NV
804  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_GPU_OVERLAP_NV, cl_bool)
805  #endif
806  #ifdef CL_DEVICE_KERNEL_EXEC_TIMEOUT_NV
807  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_KERNEL_EXEC_TIMEOUT_NV, cl_bool)
808  #endif
809  #ifdef CL_DEVICE_INTEGRATED_MEMORY_NV
810  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_INTEGRATED_MEMORY_NV, cl_bool)
811  #endif
812  template <typename Func, typename T>
813  inline cl_int
814  getInfo(Func f, cl_uint name, T* param)
815  {
816      return getInfoHelper(f, name, param, 0);
817  }
818  template <typename Func, typename Arg0>
819  struct GetInfoFunctor0
820  {
821      Func f_; const Arg0& arg0_;
822      cl_int operator ()(
823          cl_uint param, size_type size, void* value, size_type* size_ret)
824      { return f_(arg0_, param, size, value, size_ret); }
825  };
826  template <typename Func, typename Arg0, typename Arg1>
827  struct GetInfoFunctor1
828  {
829      Func f_; const Arg0& arg0_; const Arg1& arg1_;
830      cl_int operator ()(
831          cl_uint param, size_type size, void* value, size_type* size_ret)
832      { return f_(arg0_, arg1_, param, size, value, size_ret); }
833  };
834  template <typename Func, typename Arg0, typename T>
835  inline cl_int
836  getInfo(Func f, const Arg0& arg0, cl_uint name, T* param)
837  {
838      GetInfoFunctor0<Func, Arg0> f0 = { f, arg0 };
839      return getInfoHelper(f0, name, param, 0);
840  }
841  template <typename Func, typename Arg0, typename Arg1, typename T>
842  inline cl_int
843  getInfo(Func f, const Arg0& arg0, const Arg1& arg1, cl_uint name, T* param)
844  {
845      GetInfoFunctor1<Func, Arg0, Arg1> f0 = { f, arg0, arg1 };
846      return getInfoHelper(f0, name, param, 0);
847  }
848  template<typename T>
849  struct ReferenceHandler
850  { };
851  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
852  template <>
853  struct ReferenceHandler<cl_device_id>
854  {
855      static cl_int retain(cl_device_id device)
856      { return ::clRetainDevice(device); }
857      static cl_int release(cl_device_id device)
858      { return ::clReleaseDevice(device); }
859  };
860  #else 
861  template <>
862  struct ReferenceHandler<cl_device_id>
863  {
864      static cl_int retain(cl_device_id)
865      { return CL_SUCCESS; }
866      static cl_int release(cl_device_id)
867      { return CL_SUCCESS; }
868  };
869  #endif 
870  template <>
871  struct ReferenceHandler<cl_platform_id>
872  {
873      static cl_int retain(cl_platform_id)
874      { return CL_SUCCESS; }
875      static cl_int release(cl_platform_id)
876      { return CL_SUCCESS; }
877  };
878  template <>
879  struct ReferenceHandler<cl_context>
880  {
881      static cl_int retain(cl_context context)
882      { return ::clRetainContext(context); }
883      static cl_int release(cl_context context)
884      { return ::clReleaseContext(context); }
885  };
886  template <>
887  struct ReferenceHandler<cl_command_queue>
888  {
889      static cl_int retain(cl_command_queue queue)
890      { return ::clRetainCommandQueue(queue); }
891      static cl_int release(cl_command_queue queue)
892      { return ::clReleaseCommandQueue(queue); }
893  };
894  template <>
895  struct ReferenceHandler<cl_mem>
896  {
897      static cl_int retain(cl_mem memory)
898      { return ::clRetainMemObject(memory); }
899      static cl_int release(cl_mem memory)
900      { return ::clReleaseMemObject(memory); }
901  };
902  template <>
903  struct ReferenceHandler<cl_sampler>
904  {
905      static cl_int retain(cl_sampler sampler)
906      { return ::clRetainSampler(sampler); }
907      static cl_int release(cl_sampler sampler)
908      { return ::clReleaseSampler(sampler); }
909  };
910  template <>
911  struct ReferenceHandler<cl_program>
912  {
913      static cl_int retain(cl_program program)
914      { return ::clRetainProgram(program); }
915      static cl_int release(cl_program program)
916      { return ::clReleaseProgram(program); }
917  };
918  template <>
919  struct ReferenceHandler<cl_kernel>
920  {
921      static cl_int retain(cl_kernel kernel)
922      { return ::clRetainKernel(kernel); }
923      static cl_int release(cl_kernel kernel)
924      { return ::clReleaseKernel(kernel); }
925  };
926  template <>
927  struct ReferenceHandler<cl_event>
928  {
929      static cl_int retain(cl_event event)
930      { return ::clRetainEvent(event); }
931      static cl_int release(cl_event event)
932      { return ::clReleaseEvent(event); }
933  };
934  static cl_uint getVersion(const vector<char> &versionInfo)
935  {
936      int highVersion = 0;
937      int lowVersion = 0;
938      int index = 7;
939      while(versionInfo[index] != '.' ) {
940          highVersion *= 10;
941          highVersion += versionInfo[index]-'0';
942          ++index;
943      }
944      ++index;
945      while(versionInfo[index] != ' ' &&  versionInfo[index] != '\0') {
946          lowVersion *= 10;
947          lowVersion += versionInfo[index]-'0';
948          ++index;
949      }
950      return (highVersion << 16) | lowVersion;
951  }
952  #if CL_HPP_TARGET_OPENCL_VERSION >= 120 && CL_HPP_MINIMUM_OPENCL_VERSION < 120
953  static cl_uint getPlatformVersion(cl_platform_id platform)
954  {
955      size_type size = 0;
956      clGetPlatformInfo(platform, CL_PLATFORM_VERSION, 0, NULL, &size);
957      vector<char> versionInfo(size);
958      clGetPlatformInfo(platform, CL_PLATFORM_VERSION, size, versionInfo.data(), &size);
959      return getVersion(versionInfo);
960  }
961  static cl_uint getDevicePlatformVersion(cl_device_id device)
962  {
963      cl_platform_id platform;
964      clGetDeviceInfo(device, CL_DEVICE_PLATFORM, sizeof(platform), &platform, NULL);
965      return getPlatformVersion(platform);
966  }
967  static cl_uint getContextPlatformVersion(cl_context context)
968  {
969      size_type size = 0;
970      clGetContextInfo(context, CL_CONTEXT_DEVICES, 0, NULL, &size);
971      if (size == 0)
972          return 0;
973      vector<cl_device_id> devices(size/sizeof(cl_device_id));
974      clGetContextInfo(context, CL_CONTEXT_DEVICES, size, devices.data(), NULL);
975      return getDevicePlatformVersion(devices[0]);
976  }
977  #endif 
978  template <typename T>
979  class Wrapper
980  {
981  public:
982      typedef T cl_type;
983  protected:
984      cl_type object_;
985  public:
986      Wrapper() : object_(NULL) { }
987      Wrapper(const cl_type &obj, bool retainObject) : object_(obj) 
988      {
989          if (retainObject) { 
990              detail::errHandler(retain(), __RETAIN_ERR); 
991          }
992      }
993      ~Wrapper()
994      {
995          if (object_ != NULL) { release(); }
996      }
997      Wrapper(const Wrapper<cl_type>& rhs)
998      {
999          object_ = rhs.object_;
1000          detail::errHandler(retain(), __RETAIN_ERR);
1001      }
1002      Wrapper(Wrapper<cl_type>&& rhs) CL_HPP_NOEXCEPT_
1003      {
1004          object_ = rhs.object_;
1005          rhs.object_ = NULL;
1006      }
1007      Wrapper<cl_type>& operator = (const Wrapper<cl_type>& rhs)
1008      {
1009          if (this != &rhs) {
1010              detail::errHandler(release(), __RELEASE_ERR);
1011              object_ = rhs.object_;
1012              detail::errHandler(retain(), __RETAIN_ERR);
1013          }
1014          return *this;
1015      }
1016      Wrapper<cl_type>& operator = (Wrapper<cl_type>&& rhs)
1017      {
1018          if (this != &rhs) {
1019              detail::errHandler(release(), __RELEASE_ERR);
1020              object_ = rhs.object_;
1021              rhs.object_ = NULL;
1022          }
1023          return *this;
1024      }
1025      Wrapper<cl_type>& operator = (const cl_type &rhs)
1026      {
1027          detail::errHandler(release(), __RELEASE_ERR);
1028          object_ = rhs;
1029          return *this;
1030      }
1031      const cl_type& operator ()() const { return object_; }
1032      cl_type& operator ()() { return object_; }
1033      const cl_type get() const { return object_; }
1034      cl_type get() { return object_; }
1035  protected:
1036      template<typename Func, typename U>
1037      friend inline cl_int getInfoHelper(Func, cl_uint, U*, int, typename U::cl_type);
1038      cl_int retain() const
1039      {
1040          if (object_ != nullptr) {
1041              return ReferenceHandler<cl_type>::retain(object_);
1042          }
1043          else {
1044              return CL_SUCCESS;
1045          }
1046      }
1047      cl_int release() const
1048      {
1049          if (object_ != nullptr) {
1050              return ReferenceHandler<cl_type>::release(object_);
1051          }
1052          else {
1053              return CL_SUCCESS;
1054          }
1055      }
1056  };
1057  template <>
1058  class Wrapper<cl_device_id>
1059  {
1060  public:
1061      typedef cl_device_id cl_type;
1062  protected:
1063      cl_type object_;
1064      bool referenceCountable_;
1065      static bool isReferenceCountable(cl_device_id device)
1066      {
1067          bool retVal = false;
1068  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
1069  #if CL_HPP_MINIMUM_OPENCL_VERSION < 120
1070          if (device != NULL) {
1071              int version = getDevicePlatformVersion(device);
1072              if(version > ((1 << 16) + 1)) {
1073                  retVal = true;
1074              }
1075          }
1076  #else 
1077          retVal = true;
1078  #endif 
1079  #endif 
1080          return retVal;
1081      }
1082  public:
1083      Wrapper() : object_(NULL), referenceCountable_(false) 
1084      { 
1085      }
1086      Wrapper(const cl_type &obj, bool retainObject) : 
1087          object_(obj), 
1088          referenceCountable_(false) 
1089      {
1090          referenceCountable_ = isReferenceCountable(obj); 
1091          if (retainObject) {
1092              detail::errHandler(retain(), __RETAIN_ERR);
1093          }
1094      }
1095      ~Wrapper()
1096      {
1097          release();
1098      }
1099      Wrapper(const Wrapper<cl_type>& rhs)
1100      {
1101          object_ = rhs.object_;
1102          referenceCountable_ = isReferenceCountable(object_); 
1103          detail::errHandler(retain(), __RETAIN_ERR);
1104      }
1105      Wrapper(Wrapper<cl_type>&& rhs) CL_HPP_NOEXCEPT_
1106      {
1107          object_ = rhs.object_;
1108          referenceCountable_ = rhs.referenceCountable_;
1109          rhs.object_ = NULL;
1110          rhs.referenceCountable_ = false;
1111      }
1112      Wrapper<cl_type>& operator = (const Wrapper<cl_type>& rhs)
1113      {
1114          if (this != &rhs) {
1115              detail::errHandler(release(), __RELEASE_ERR);
1116              object_ = rhs.object_;
1117              referenceCountable_ = rhs.referenceCountable_;
1118              detail::errHandler(retain(), __RETAIN_ERR);
1119          }
1120          return *this;
1121      }
1122      Wrapper<cl_type>& operator = (Wrapper<cl_type>&& rhs)
1123      {
1124          if (this != &rhs) {
1125              detail::errHandler(release(), __RELEASE_ERR);
1126              object_ = rhs.object_;
1127              referenceCountable_ = rhs.referenceCountable_;
1128              rhs.object_ = NULL;
1129              rhs.referenceCountable_ = false;
1130          }
1131          return *this;
1132      }
1133      Wrapper<cl_type>& operator = (const cl_type &rhs)
1134      {
1135          detail::errHandler(release(), __RELEASE_ERR);
1136          object_ = rhs;
1137          referenceCountable_ = isReferenceCountable(object_); 
1138          return *this;
1139      }
1140      const cl_type& operator ()() const { return object_; }
1141      cl_type& operator ()() { return object_; }
1142      const cl_type get() const { return object_; }
1143      cl_type get() { return object_; }
1144  protected:
1145      template<typename Func, typename U>
1146      friend inline cl_int getInfoHelper(Func, cl_uint, U*, int, typename U::cl_type);
1147      template<typename Func, typename U>
1148      friend inline cl_int getInfoHelper(Func, cl_uint, vector<U>*, int, typename U::cl_type);
1149      cl_int retain() const
1150      {
1151          if( object_ != nullptr && referenceCountable_ ) {
1152              return ReferenceHandler<cl_type>::retain(object_);
1153          }
1154          else {
1155              return CL_SUCCESS;
1156          }
1157      }
1158      cl_int release() const
1159      {
1160          if (object_ != nullptr && referenceCountable_) {
1161              return ReferenceHandler<cl_type>::release(object_);
1162          }
1163          else {
1164              return CL_SUCCESS;
1165          }
1166      }
1167  };
1168  template <typename T>
1169  inline bool operator==(const Wrapper<T> &lhs, const Wrapper<T> &rhs)
1170  {
1171      return lhs() == rhs();
1172  }
1173  template <typename T>
1174  inline bool operator!=(const Wrapper<T> &lhs, const Wrapper<T> &rhs)
1175  {
1176      return !operator==(lhs, rhs);
1177  }
1178  } 
1179  using BuildLogType = vector<std::pair<cl::Device, typename detail::param_traits<detail::cl_program_build_info, CL_PROGRAM_BUILD_LOG>::param_type>>;
1180  #if defined(CL_HPP_ENABLE_EXCEPTIONS)
1181  class BuildError : public Error
1182  {
1183  private:
1184      BuildLogType buildLogs;
1185  public:
1186      BuildError(cl_int err, const char * errStr, const BuildLogType &vec) : Error(err, errStr), buildLogs(vec)
1187      {
1188      }
1189      BuildLogType getBuildLog() const
1190      {
1191          return buildLogs;
1192      }
1193  };
1194  namespace detail {
1195      static inline cl_int buildErrHandler(
1196          cl_int err,
1197          const char * errStr,
1198          const BuildLogType &buildLogs)
1199      {
1200          if (err != CL_SUCCESS) {
1201              throw BuildError(err, errStr, buildLogs);
1202          }
1203          return err;
1204      }
1205  } 
1206  #else
1207  namespace detail {
1208      static inline cl_int buildErrHandler(
1209          cl_int err,
1210          const char * errStr,
1211          const BuildLogType &buildLogs)
1212      {
1213          (void)buildLogs; 
1214          (void)errStr;
1215          return err;
1216      }
1217  } 
1218  #endif 
1219  struct ImageFormat : public cl_image_format
1220  {
1221      ImageFormat(){}
1222      ImageFormat(cl_channel_order order, cl_channel_type type)
1223      {
1224          image_channel_order = order;
1225          image_channel_data_type = type;
1226      }
1227      ImageFormat& operator = (const ImageFormat& rhs)
1228      {
1229          if (this != &rhs) {
1230              this->image_channel_data_type = rhs.image_channel_data_type;
1231              this->image_channel_order     = rhs.image_channel_order;
1232          }
1233          return *this;
1234      }
1235  };
1236  class Device : public detail::Wrapper<cl_device_id>
1237  {
1238  private:
1239      static std::once_flag default_initialized_;
1240      static Device default_;
1241      static cl_int default_error_;
1242      static void makeDefault();
1243      static void makeDefaultProvided(const Device &p) {
1244          default_ = p;
1245      }
1246  public:
1247  #ifdef CL_HPP_UNIT_TEST_ENABLE
1248      static void unitTestClearDefault() {
1249          default_ = Device();
1250      }
1251  #endif 
1252      Device() : detail::Wrapper<cl_type>() { }
1253      explicit Device(const cl_device_id &device, bool retainObject = false) : 
1254          detail::Wrapper<cl_type>(device, retainObject) { }
1255      static Device getDefault(
1256          cl_int *errResult = NULL)
1257      {
1258          std::call_once(default_initialized_, makeDefault);
1259          detail::errHandler(default_error_);
1260          if (errResult != NULL) {
1261              *errResult = default_error_;
1262          }
1263          return default_;
1264      }
1265      static Device setDefault(const Device &default_device)
1266      {
1267          std::call_once(default_initialized_, makeDefaultProvided, std::cref(default_device));
1268          detail::errHandler(default_error_);
1269          return default_;
1270      }
1271      Device& operator = (const cl_device_id& rhs)
1272      {
1273          detail::Wrapper<cl_type>::operator=(rhs);
1274          return *this;
1275      }
1276      Device(const Device& dev) : detail::Wrapper<cl_type>(dev) {}
1277      Device& operator = (const Device &dev)
1278      {
1279          detail::Wrapper<cl_type>::operator=(dev);
1280          return *this;
1281      }
1282      Device(Device&& dev) CL_HPP_NOEXCEPT_ : detail::Wrapper<cl_type>(std::move(dev)) {}
1283      Device& operator = (Device &&dev)
1284      {
1285          detail::Wrapper<cl_type>::operator=(std::move(dev));
1286          return *this;
1287      }
1288      template <typename T>
1289      cl_int getInfo(cl_device_info name, T* param) const
1290      {
1291          return detail::errHandler(
1292              detail::getInfo(&::clGetDeviceInfo, object_, name, param),
1293              __GET_DEVICE_INFO_ERR);
1294      }
1295      template <cl_int name> typename
1296      detail::param_traits<detail::cl_device_info, name>::param_type
1297      getInfo(cl_int* err = NULL) const
1298      {
1299          typename detail::param_traits<
1300              detail::cl_device_info, name>::param_type param;
1301          cl_int result = getInfo(name, &param);
1302          if (err != NULL) {
1303              *err = result;
1304          }
1305          return param;
1306      }
1307  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
1308      cl_int createSubDevices(
1309          const cl_device_partition_property * properties,
1310          vector<Device>* devices)
1311      {
1312          cl_uint n = 0;
1313          cl_int err = clCreateSubDevices(object_, properties, 0, NULL, &n);
1314          if (err != CL_SUCCESS) {
1315              return detail::errHandler(err, __CREATE_SUB_DEVICES_ERR);
1316          }
1317          vector<cl_device_id> ids(n);
1318          err = clCreateSubDevices(object_, properties, n, ids.data(), NULL);
1319          if (err != CL_SUCCESS) {
1320              return detail::errHandler(err, __CREATE_SUB_DEVICES_ERR);
1321          }
1322          if (devices) {
1323              devices->resize(ids.size());
1324              for (size_type i = 0; i < ids.size(); i++) {
1325                  (*devices)[i] = Device(ids[i], false);
1326              }
1327          }
1328          return CL_SUCCESS;
1329      }
1330  #elif defined(CL_HPP_USE_CL_DEVICE_FISSION)
1331      cl_int createSubDevices(
1332          const cl_device_partition_property_ext * properties,
1333          vector<Device>* devices)
1334      {
1335          typedef CL_API_ENTRY cl_int 
1336              ( CL_API_CALL * PFN_clCreateSubDevicesEXT)(
1337                  cl_device_id &bsol;*in_device*/,
1338                  const cl_device_partition_property_ext * &bsol;* properties */,
1339                  cl_uint &bsol;*num_entries*/,
1340                  cl_device_id * &bsol;*out_devices*/,
1341                  cl_uint * &bsol;*num_devices*/ ) CL_EXT_SUFFIX__VERSION_1_1;
1342          static PFN_clCreateSubDevicesEXT pfn_clCreateSubDevicesEXT = NULL;
1343          CL_HPP_INIT_CL_EXT_FCN_PTR_(clCreateSubDevicesEXT);
1344          cl_uint n = 0;
1345          cl_int err = pfn_clCreateSubDevicesEXT(object_, properties, 0, NULL, &n);
1346          if (err != CL_SUCCESS) {
1347              return detail::errHandler(err, __CREATE_SUB_DEVICES_ERR);
1348          }
1349          vector<cl_device_id> ids(n);
1350          err = pfn_clCreateSubDevicesEXT(object_, properties, n, ids.data(), NULL);
1351          if (err != CL_SUCCESS) {
1352              return detail::errHandler(err, __CREATE_SUB_DEVICES_ERR);
1353          }
1354          if (devices) {
1355              devices->resize(ids.size());
1356              for (size_type i = 0; i < ids.size(); i++) {
1357                  (*devices)[i] = Device(ids[i], false);
1358              }
1359          }
1360          return CL_SUCCESS;
1361      }
1362  #endif 
1363  };
1364  CL_HPP_DEFINE_STATIC_MEMBER_ std::once_flag Device::default_initialized_;
1365  CL_HPP_DEFINE_STATIC_MEMBER_ Device Device::default_;
1366  CL_HPP_DEFINE_STATIC_MEMBER_ cl_int Device::default_error_ = CL_SUCCESS;
1367  class Platform : public detail::Wrapper<cl_platform_id>
1368  {
1369  private:
1370      static std::once_flag default_initialized_;
1371      static Platform default_;
1372      static cl_int default_error_;
1373      static void makeDefault() {
1374  #if defined(CL_HPP_ENABLE_EXCEPTIONS)
1375          try
1376  #endif
1377          {
1378              cl_uint n = 0;
1379              cl_int err = ::clGetPlatformIDs(0, NULL, &n);
1380              if (err != CL_SUCCESS) {
1381                  default_error_ = err;
1382                  return;
1383              }
1384              if (n == 0) {
1385                  default_error_ = CL_INVALID_PLATFORM;
1386                  return;
1387              }
1388              vector<cl_platform_id> ids(n);
1389              err = ::clGetPlatformIDs(n, ids.data(), NULL);
1390              if (err != CL_SUCCESS) {
1391                  default_error_ = err;
1392                  return;
1393              }
1394              default_ = Platform(ids[0]);
1395          }
1396  #if defined(CL_HPP_ENABLE_EXCEPTIONS)
1397          catch (cl::Error &e) {
1398              default_error_ = e.err();
1399          }
1400  #endif
1401      }
1402      static void makeDefaultProvided(const Platform &p) {
1403         default_ = p;
1404      }
1405  public:
1406  #ifdef CL_HPP_UNIT_TEST_ENABLE
1407      static void unitTestClearDefault() {
1408          default_ = Platform();
1409      }
1410  #endif 
1411      Platform() : detail::Wrapper<cl_type>()  { }
1412      explicit Platform(const cl_platform_id &platform, bool retainObject = false) : 
1413          detail::Wrapper<cl_type>(platform, retainObject) { }
1414      Platform& operator = (const cl_platform_id& rhs)
1415      {
1416          detail::Wrapper<cl_type>::operator=(rhs);
1417          return *this;
1418      }
1419      static Platform getDefault(
1420          cl_int *errResult = NULL)
1421      {
1422          std::call_once(default_initialized_, makeDefault);
1423          detail::errHandler(default_error_);
1424          if (errResult != NULL) {
1425              *errResult = default_error_;
1426          }
1427          return default_;
1428      }
1429      static Platform setDefault(const Platform &default_platform)
1430      {
1431          std::call_once(default_initialized_, makeDefaultProvided, std::cref(default_platform));
1432          detail::errHandler(default_error_);
1433          return default_;
1434      }
1435      cl_int getInfo(cl_platform_info name, string* param) const
1436      {
1437          return detail::errHandler(
1438              detail::getInfo(&::clGetPlatformInfo, object_, name, param),
1439              __GET_PLATFORM_INFO_ERR);
1440      }
1441      template <cl_int name> typename
1442      detail::param_traits<detail::cl_platform_info, name>::param_type
1443      getInfo(cl_int* err = NULL) const
1444      {
1445          typename detail::param_traits<
1446              detail::cl_platform_info, name>::param_type param;
1447          cl_int result = getInfo(name, &param);
1448          if (err != NULL) {
1449              *err = result;
1450          }
1451          return param;
1452      }
1453      cl_int getDevices(
1454          cl_device_type type,
1455          vector<Device>* devices) const
1456      {
1457          cl_uint n = 0;
1458          if( devices == NULL ) {
1459              return detail::errHandler(CL_INVALID_ARG_VALUE, __GET_DEVICE_IDS_ERR);
1460          }
1461          cl_int err = ::clGetDeviceIDs(object_, type, 0, NULL, &n);
1462          if (err != CL_SUCCESS) {
1463              return detail::errHandler(err, __GET_DEVICE_IDS_ERR);
1464          }
1465          vector<cl_device_id> ids(n);
1466          err = ::clGetDeviceIDs(object_, type, n, ids.data(), NULL);
1467          if (err != CL_SUCCESS) {
1468              return detail::errHandler(err, __GET_DEVICE_IDS_ERR);
1469          }
1470          if (devices) {
1471              devices->resize(ids.size());
1472              for (size_type i = 0; i < ids.size(); i++) {
1473                  (*devices)[i] = Device(ids[i], true);
1474              }
1475          }
1476          return CL_SUCCESS;
1477      }
1478  #if defined(CL_HPP_USE_DX_INTEROP)
1479      cl_int getDevices(
1480          cl_d3d10_device_source_khr d3d_device_source,
1481          void *                     d3d_object,
1482          cl_d3d10_device_set_khr    d3d_device_set,
1483          vector<Device>* devices) const
1484      {
1485          typedef CL_API_ENTRY cl_int (CL_API_CALL *PFN_clGetDeviceIDsFromD3D10KHR)(
1486              cl_platform_id platform, 
1487              cl_d3d10_device_source_khr d3d_device_source, 
1488              void * d3d_object,
1489              cl_d3d10_device_set_khr d3d_device_set,
1490              cl_uint num_entries,
1491              cl_device_id * devices,
1492              cl_uint* num_devices);
1493          if( devices == NULL ) {
1494              return detail::errHandler(CL_INVALID_ARG_VALUE, __GET_DEVICE_IDS_ERR);
1495          }
1496          static PFN_clGetDeviceIDsFromD3D10KHR pfn_clGetDeviceIDsFromD3D10KHR = NULL;
1497          CL_HPP_INIT_CL_EXT_FCN_PTR_PLATFORM_(object_, clGetDeviceIDsFromD3D10KHR);
1498          cl_uint n = 0;
1499          cl_int err = pfn_clGetDeviceIDsFromD3D10KHR(
1500              object_, 
1501              d3d_device_source, 
1502              d3d_object,
1503              d3d_device_set, 
1504              0, 
1505              NULL, 
1506              &n);
1507          if (err != CL_SUCCESS) {
1508              return detail::errHandler(err, __GET_DEVICE_IDS_ERR);
1509          }
1510          vector<cl_device_id> ids(n);
1511          err = pfn_clGetDeviceIDsFromD3D10KHR(
1512              object_, 
1513              d3d_device_source, 
1514              d3d_object,
1515              d3d_device_set,
1516              n, 
1517              ids.data(), 
1518              NULL);
1519          if (err != CL_SUCCESS) {
1520              return detail::errHandler(err, __GET_DEVICE_IDS_ERR);
1521          }
1522          if (devices) {
1523              devices->resize(ids.size());
1524              for (size_type i = 0; i < ids.size(); i++) {
1525                  (*devices)[i] = Device(ids[i], true);
1526              }
1527          }
1528          return CL_SUCCESS;
1529      }
1530  #endif
1531      static cl_int get(
1532          vector<Platform>* platforms)
1533      {
1534          cl_uint n = 0;
1535          if( platforms == NULL ) {
1536              return detail::errHandler(CL_INVALID_ARG_VALUE, __GET_PLATFORM_IDS_ERR);
1537          }
1538          cl_int err = ::clGetPlatformIDs(0, NULL, &n);
1539          if (err != CL_SUCCESS) {
1540              return detail::errHandler(err, __GET_PLATFORM_IDS_ERR);
1541          }
1542          vector<cl_platform_id> ids(n);
1543          err = ::clGetPlatformIDs(n, ids.data(), NULL);
1544          if (err != CL_SUCCESS) {
1545              return detail::errHandler(err, __GET_PLATFORM_IDS_ERR);
1546          }
1547          if (platforms) {
1548              platforms->resize(ids.size());
1549              for (size_type i = 0; i < ids.size(); i++) {
1550                  (*platforms)[i] = Platform(ids[i]);
1551              }
1552          }
1553          return CL_SUCCESS;
1554      }
1555      static cl_int get(
1556          Platform * platform)
1557      {
1558          cl_int err;
1559          Platform default_platform = Platform::getDefault(&err);
1560          if (platform) {
1561              *platform = default_platform;
1562          }
1563          return err;
1564      }
1565      static Platform get(
1566          cl_int * errResult = NULL)
1567      {
1568          cl_int err;
1569          Platform default_platform = Platform::getDefault(&err);
1570          if (errResult) {
1571              *errResult = err;
1572          }
1573          return default_platform;
1574      }    
1575  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
1576      cl_int
1577      unloadCompiler()
1578      {
1579          return ::clUnloadPlatformCompiler(object_);
1580      }
1581  #endif 
1582  }; 
1583  CL_HPP_DEFINE_STATIC_MEMBER_ std::once_flag Platform::default_initialized_;
1584  CL_HPP_DEFINE_STATIC_MEMBER_ Platform Platform::default_;
1585  CL_HPP_DEFINE_STATIC_MEMBER_ cl_int Platform::default_error_ = CL_SUCCESS;
1586  #if defined(CL_USE_DEPRECATED_OPENCL_1_1_APIS)
1587  inline CL_EXT_PREFIX__VERSION_1_1_DEPRECATED cl_int
1588  UnloadCompiler() CL_EXT_SUFFIX__VERSION_1_1_DEPRECATED;
1589  inline cl_int
1590  UnloadCompiler()
1591  {
1592      return ::clUnloadCompiler();
1593  }
1594  #endif 
1595  class Context 
1596      : public detail::Wrapper<cl_context>
1597  {
1598  private:
1599      static std::once_flag default_initialized_;
1600      static Context default_;
1601      static cl_int default_error_;
1602      static void makeDefault() {
1603  #if defined(CL_HPP_ENABLE_EXCEPTIONS)
1604          try
1605  #endif
1606          {
1607  #if !defined(__APPLE__) && !defined(__MACOS)
1608              const Platform &p = Platform::getDefault();
1609              cl_platform_id defaultPlatform = p();
1610              cl_context_properties properties[3] = {
1611                  CL_CONTEXT_PLATFORM, (cl_context_properties)defaultPlatform, 0
1612              };
1613  #else 
1614              cl_context_properties *properties = nullptr;
1615  #endif 
1616              default_ = Context(
1617                  CL_DEVICE_TYPE_DEFAULT,
1618                  properties,
1619                  NULL,
1620                  NULL,
1621                  &default_error_);
1622          }
1623  #if defined(CL_HPP_ENABLE_EXCEPTIONS)
1624          catch (cl::Error &e) {
1625              default_error_ = e.err();
1626          }
1627  #endif
1628      }
1629      static void makeDefaultProvided(const Context &c) {
1630          default_ = c;
1631      }
1632  public:
1633  #ifdef CL_HPP_UNIT_TEST_ENABLE
1634      static void unitTestClearDefault() {
1635          default_ = Context();
1636      }
1637  #endif 
1638      Context(
1639          const vector<Device>& devices,
1640          cl_context_properties* properties = NULL,
1641          void (CL_CALLBACK * notifyFptr)(
1642              const char *,
1643              const void *,
1644              size_type,
1645              void *) = NULL,
1646          void* data = NULL,
1647          cl_int* err = NULL)
1648      {
1649          cl_int error;
1650          size_type numDevices = devices.size();
1651          vector<cl_device_id> deviceIDs(numDevices);
1652          for( size_type deviceIndex = 0; deviceIndex < numDevices; ++deviceIndex ) {
1653              deviceIDs[deviceIndex] = (devices[deviceIndex])();
1654          }
1655          object_ = ::clCreateContext(
1656              properties, (cl_uint) numDevices,
1657              deviceIDs.data(),
1658              notifyFptr, data, &error);
1659          detail::errHandler(error, __CREATE_CONTEXT_ERR);
1660          if (err != NULL) {
1661              *err = error;
1662          }
1663      }
1664      Context(
1665          const Device& device,
1666          cl_context_properties* properties = NULL,
1667          void (CL_CALLBACK * notifyFptr)(
1668              const char *,
1669              const void *,
1670              size_type,
1671              void *) = NULL,
1672          void* data = NULL,
1673          cl_int* err = NULL)
1674      {
1675          cl_int error;
1676          cl_device_id deviceID = device();
1677          object_ = ::clCreateContext(
1678              properties, 1,
1679              &deviceID,
1680              notifyFptr, data, &error);
1681          detail::errHandler(error, __CREATE_CONTEXT_ERR);
1682          if (err != NULL) {
1683              *err = error;
1684          }
1685      }
1686      Context(
1687          cl_device_type type,
1688          cl_context_properties* properties = NULL,
1689          void (CL_CALLBACK * notifyFptr)(
1690              const char *,
1691              const void *,
1692              size_type,
1693              void *) = NULL,
1694          void* data = NULL,
1695          cl_int* err = NULL)
1696      {
1697          cl_int error;
1698  #if !defined(__APPLE__) && !defined(__MACOS)
1699          cl_context_properties prop[4] = {CL_CONTEXT_PLATFORM, 0, 0, 0 };
1700          if (properties == NULL) {
1701              vector<Platform> platforms;
1702              error = Platform::get(&platforms);
1703              if (error != CL_SUCCESS) {
1704                  detail::errHandler(error, __CREATE_CONTEXT_FROM_TYPE_ERR);
1705                  if (err != NULL) {
1706                      *err = error;
1707                  }
1708                  return;
1709              }
1710              cl_context_properties platform_id = 0;
1711              for (unsigned int i = 0; i < platforms.size(); i++) {
1712                  vector<Device> devices;
1713  #if defined(CL_HPP_ENABLE_EXCEPTIONS)
1714                  try {
1715  #endif
1716                      error = platforms[i].getDevices(type, &devices);
1717  #if defined(CL_HPP_ENABLE_EXCEPTIONS)
1718                  } catch (Error) {}
1719  #endif
1720                  if (error != CL_SUCCESS && error != CL_DEVICE_NOT_FOUND) {
1721                      detail::errHandler(error, __CREATE_CONTEXT_FROM_TYPE_ERR);
1722                      if (err != NULL) {
1723                          *err = error;
1724                      }
1725                  }
1726                  if (devices.size() > 0) {
1727                      platform_id = (cl_context_properties)platforms[i]();
1728                      break;
1729                  }
1730              }
1731              if (platform_id == 0) {
1732                  detail::errHandler(CL_DEVICE_NOT_FOUND, __CREATE_CONTEXT_FROM_TYPE_ERR);
1733                  if (err != NULL) {
1734                      *err = CL_DEVICE_NOT_FOUND;
1735                  }
1736                  return;
1737              }
1738              prop[1] = platform_id;
1739              properties = &prop[0];
1740          }
1741  #endif
1742          object_ = ::clCreateContextFromType(
1743              properties, type, notifyFptr, data, &error);
1744          detail::errHandler(error, __CREATE_CONTEXT_FROM_TYPE_ERR);
1745          if (err != NULL) {
1746              *err = error;
1747          }
1748      }
1749      Context(const Context& ctx) : detail::Wrapper<cl_type>(ctx) {}
1750      Context& operator = (const Context &ctx)
1751      {
1752          detail::Wrapper<cl_type>::operator=(ctx);
1753          return *this;
1754      }
1755      Context(Context&& ctx) CL_HPP_NOEXCEPT_ : detail::Wrapper<cl_type>(std::move(ctx)) {}
1756      Context& operator = (Context &&ctx)
1757      {
1758          detail::Wrapper<cl_type>::operator=(std::move(ctx));
1759          return *this;
1760      }
1761      static Context getDefault(cl_int * err = NULL) 
1762      {
1763          std::call_once(default_initialized_, makeDefault);
1764          detail::errHandler(default_error_);
1765          if (err != NULL) {
1766              *err = default_error_;
1767          }
1768          return default_;
1769      }
1770      static Context setDefault(const Context &default_context)
1771      {
1772          std::call_once(default_initialized_, makeDefaultProvided, std::cref(default_context));
1773          detail::errHandler(default_error_);
1774          return default_;
1775      }
1776      Context() : detail::Wrapper<cl_type>() { }
1777      explicit Context(const cl_context& context, bool retainObject = false) : 
1778          detail::Wrapper<cl_type>(context, retainObject) { }
1779      Context& operator = (const cl_context& rhs)
1780      {
1781          detail::Wrapper<cl_type>::operator=(rhs);
1782          return *this;
1783      }
1784      template <typename T>
1785      cl_int getInfo(cl_context_info name, T* param) const
1786      {
1787          return detail::errHandler(
1788              detail::getInfo(&::clGetContextInfo, object_, name, param),
1789              __GET_CONTEXT_INFO_ERR);
1790      }
1791      template <cl_int name> typename
1792      detail::param_traits<detail::cl_context_info, name>::param_type
1793      getInfo(cl_int* err = NULL) const
1794      {
1795          typename detail::param_traits<
1796              detail::cl_context_info, name>::param_type param;
1797          cl_int result = getInfo(name, &param);
1798          if (err != NULL) {
1799              *err = result;
1800          }
1801          return param;
1802      }
1803      cl_int getSupportedImageFormats(
1804          cl_mem_flags flags,
1805          cl_mem_object_type type,
1806          vector<ImageFormat>* formats) const
1807      {
1808          cl_uint numEntries;
1809          if (!formats) {
1810              return CL_SUCCESS;
1811          }
1812          cl_int err = ::clGetSupportedImageFormats(
1813             object_, 
1814             flags,
1815             type, 
1816             0, 
1817             NULL, 
1818             &numEntries);
1819          if (err != CL_SUCCESS) {
1820              return detail::errHandler(err, __GET_SUPPORTED_IMAGE_FORMATS_ERR);
1821          }
1822          if (numEntries > 0) {
1823              vector<ImageFormat> value(numEntries);
1824              err = ::clGetSupportedImageFormats(
1825                  object_,
1826                  flags,
1827                  type,
1828                  numEntries,
1829                  (cl_image_format*)value.data(),
1830                  NULL);
1831              if (err != CL_SUCCESS) {
1832                  return detail::errHandler(err, __GET_SUPPORTED_IMAGE_FORMATS_ERR);
1833              }
1834              formats->assign(begin(value), end(value));
1835          }
1836          else {
1837              formats->clear();
1838          }
1839          return CL_SUCCESS;
1840      }
1841  };
1842  inline void Device::makeDefault()
1843  {
1844  #if defined(CL_HPP_ENABLE_EXCEPTIONS)
1845      try
1846  #endif
1847      {
1848          cl_int error = 0;
1849          Context context = Context::getDefault(&error);
1850          detail::errHandler(error, __CREATE_CONTEXT_ERR);
1851          if (error != CL_SUCCESS) {
1852              default_error_ = error;
1853          }
1854          else {
1855              default_ = context.getInfo<CL_CONTEXT_DEVICES>()[0];
1856              default_error_ = CL_SUCCESS;
1857          }
1858      }
1859  #if defined(CL_HPP_ENABLE_EXCEPTIONS)
1860      catch (cl::Error &e) {
1861          default_error_ = e.err();
1862      }
1863  #endif
1864  }
1865  CL_HPP_DEFINE_STATIC_MEMBER_ std::once_flag Context::default_initialized_;
1866  CL_HPP_DEFINE_STATIC_MEMBER_ Context Context::default_;
1867  CL_HPP_DEFINE_STATIC_MEMBER_ cl_int Context::default_error_ = CL_SUCCESS;
1868  class Event : public detail::Wrapper<cl_event>
1869  {
1870  public:
1871      Event() : detail::Wrapper<cl_type>() { }
1872      explicit Event(const cl_event& event, bool retainObject = false) : 
1873          detail::Wrapper<cl_type>(event, retainObject) { }
1874      Event& operator = (const cl_event& rhs)
1875      {
1876          detail::Wrapper<cl_type>::operator=(rhs);
1877          return *this;
1878      }
1879      template <typename T>
1880      cl_int getInfo(cl_event_info name, T* param) const
1881      {
1882          return detail::errHandler(
1883              detail::getInfo(&::clGetEventInfo, object_, name, param),
1884              __GET_EVENT_INFO_ERR);
1885      }
1886      template <cl_int name> typename
1887      detail::param_traits<detail::cl_event_info, name>::param_type
1888      getInfo(cl_int* err = NULL) const
1889      {
1890          typename detail::param_traits<
1891              detail::cl_event_info, name>::param_type param;
1892          cl_int result = getInfo(name, &param);
1893          if (err != NULL) {
1894              *err = result;
1895          }
1896          return param;
1897      }
1898      template <typename T>
1899      cl_int getProfilingInfo(cl_profiling_info name, T* param) const
1900      {
1901          return detail::errHandler(detail::getInfo(
1902              &::clGetEventProfilingInfo, object_, name, param),
1903              __GET_EVENT_PROFILE_INFO_ERR);
1904      }
1905      template <cl_int name> typename
1906      detail::param_traits<detail::cl_profiling_info, name>::param_type
1907      getProfilingInfo(cl_int* err = NULL) const
1908      {
1909          typename detail::param_traits<
1910              detail::cl_profiling_info, name>::param_type param;
1911          cl_int result = getProfilingInfo(name, &param);
1912          if (err != NULL) {
1913              *err = result;
1914          }
1915          return param;
1916      }
1917      cl_int wait() const
1918      {
1919          return detail::errHandler(
1920              ::clWaitForEvents(1, &object_),
1921              __WAIT_FOR_EVENTS_ERR);
1922      }
1923  #if CL_HPP_TARGET_OPENCL_VERSION >= 110
1924      cl_int setCallback(
1925          cl_int type,
1926          void (CL_CALLBACK * pfn_notify)(cl_event, cl_int, void *),		
1927          void * user_data = NULL)
1928      {
1929          return detail::errHandler(
1930              ::clSetEventCallback(
1931                  object_,
1932                  type,
1933                  pfn_notify,
1934                  user_data), 
1935              __SET_EVENT_CALLBACK_ERR);
1936      }
1937  #endif 
1938      static cl_int
1939      waitForEvents(const vector<Event>& events)
1940      {
1941          return detail::errHandler(
1942              ::clWaitForEvents(
1943                  (cl_uint) events.size(), (events.size() > 0) ? (cl_event*)&events.front() : NULL),
1944              __WAIT_FOR_EVENTS_ERR);
1945      }
1946  };
1947  #if CL_HPP_TARGET_OPENCL_VERSION >= 110
1948  class UserEvent : public Event
1949  {
1950  public:
1951      UserEvent(
1952          const Context& context,
1953          cl_int * err = NULL)
1954      {
1955          cl_int error;
1956          object_ = ::clCreateUserEvent(
1957              context(),
1958              &error);
1959          detail::errHandler(error, __CREATE_USER_EVENT_ERR);
1960          if (err != NULL) {
1961              *err = error;
1962          }
1963      }
1964      UserEvent() : Event() { }
1965      cl_int setStatus(cl_int status)
1966      {
1967          return detail::errHandler(
1968              ::clSetUserEventStatus(object_,status), 
1969              __SET_USER_EVENT_STATUS_ERR);
1970      }
1971  };
1972  #endif 
1973  inline static cl_int
1974  WaitForEvents(const vector<Event>& events)
1975  {
1976      return detail::errHandler(
1977          ::clWaitForEvents(
1978              (cl_uint) events.size(), (events.size() > 0) ? (cl_event*)&events.front() : NULL),
1979          __WAIT_FOR_EVENTS_ERR);
1980  }
1981  class Memory : public detail::Wrapper<cl_mem>
1982  {
1983  public:
1984      Memory() : detail::Wrapper<cl_type>() { }
1985      explicit Memory(const cl_mem& memory, bool retainObject) :
1986          detail::Wrapper<cl_type>(memory, retainObject) { }
1987      Memory& operator = (const cl_mem& rhs)
1988      {
1989          detail::Wrapper<cl_type>::operator=(rhs);
1990          return *this;
1991      }
1992      Memory(const Memory& mem) : detail::Wrapper<cl_type>(mem) {}
1993      Memory& operator = (const Memory &mem)
1994      {
1995          detail::Wrapper<cl_type>::operator=(mem);
1996          return *this;
1997      }
1998      Memory(Memory&& mem) CL_HPP_NOEXCEPT_ : detail::Wrapper<cl_type>(std::move(mem)) {}
1999      Memory& operator = (Memory &&mem)
2000      {
2001          detail::Wrapper<cl_type>::operator=(std::move(mem));
2002          return *this;
2003      }
2004      template <typename T>
2005      cl_int getInfo(cl_mem_info name, T* param) const
2006      {
2007          return detail::errHandler(
2008              detail::getInfo(&::clGetMemObjectInfo, object_, name, param),
2009              __GET_MEM_OBJECT_INFO_ERR);
2010      }
2011      template <cl_int name> typename
2012      detail::param_traits<detail::cl_mem_info, name>::param_type
2013      getInfo(cl_int* err = NULL) const
2014      {
2015          typename detail::param_traits<
2016              detail::cl_mem_info, name>::param_type param;
2017          cl_int result = getInfo(name, &param);
2018          if (err != NULL) {
2019              *err = result;
2020          }
2021          return param;
2022      }
2023  #if CL_HPP_TARGET_OPENCL_VERSION >= 110
2024      cl_int setDestructorCallback(
2025          void (CL_CALLBACK * pfn_notify)(cl_mem, void *),		
2026          void * user_data = NULL)
2027      {
2028          return detail::errHandler(
2029              ::clSetMemObjectDestructorCallback(
2030                  object_,
2031                  pfn_notify,
2032                  user_data), 
2033              __SET_MEM_OBJECT_DESTRUCTOR_CALLBACK_ERR);
2034      }
2035  #endif 
2036  };
2037  class Buffer;
2038  template< typename IteratorType >
2039  cl_int copy( IteratorType startIterator, IteratorType endIterator, cl::Buffer &buffer );
2040  template< typename IteratorType >
2041  cl_int copy( const cl::Buffer &buffer, IteratorType startIterator, IteratorType endIterator );
2042  template< typename IteratorType >
2043  cl_int copy( const CommandQueue &queue, IteratorType startIterator, IteratorType endIterator, cl::Buffer &buffer );
2044  template< typename IteratorType >
2045  cl_int copy( const CommandQueue &queue, const cl::Buffer &buffer, IteratorType startIterator, IteratorType endIterator );
2046  #if CL_HPP_TARGET_OPENCL_VERSION >= 200
2047  namespace detail
2048  {
2049      class SVMTraitNull
2050      {
2051      public:
2052          static cl_svm_mem_flags getSVMMemFlags()
2053          {
2054              return 0;
2055          }
2056      };
2057  } 
2058  template<class Trait = detail::SVMTraitNull>
2059  class SVMTraitReadWrite
2060  {
2061  public:
2062      static cl_svm_mem_flags getSVMMemFlags()
2063      {
2064          return CL_MEM_READ_WRITE |
2065              Trait::getSVMMemFlags();
2066      }
2067  };
2068  template<class Trait = detail::SVMTraitNull>
2069  class SVMTraitReadOnly
2070  {
2071  public:
2072      static cl_svm_mem_flags getSVMMemFlags()
2073      {
2074          return CL_MEM_READ_ONLY |
2075              Trait::getSVMMemFlags();
2076      }
2077  };
2078  template<class Trait = detail::SVMTraitNull>
2079  class SVMTraitWriteOnly
2080  {
2081  public:
2082      static cl_svm_mem_flags getSVMMemFlags()
2083      {
2084          return CL_MEM_WRITE_ONLY |
2085              Trait::getSVMMemFlags();
2086      }
2087  };
2088  template<class Trait = SVMTraitReadWrite<>>
2089  class SVMTraitCoarse
2090  {
2091  public:
2092      static cl_svm_mem_flags getSVMMemFlags()
2093      {
2094          return Trait::getSVMMemFlags();
2095      }
2096  };
2097  template<class Trait = SVMTraitReadWrite<>>
2098  class SVMTraitFine
2099  {
2100  public:
2101      static cl_svm_mem_flags getSVMMemFlags()
2102      {
2103          return CL_MEM_SVM_FINE_GRAIN_BUFFER |
2104              Trait::getSVMMemFlags();
2105      }
2106  };
2107  template<class Trait = SVMTraitReadWrite<>>
2108  class SVMTraitAtomic
2109  {
2110  public:
2111      static cl_svm_mem_flags getSVMMemFlags()
2112      {
2113          return
2114              CL_MEM_SVM_FINE_GRAIN_BUFFER |
2115              CL_MEM_SVM_ATOMICS |
2116              Trait::getSVMMemFlags();
2117      }
2118  };
2119  template<typename T>
2120  inline cl_int enqueueMapSVM(
2121      T* ptr,
2122      cl_bool blocking,
2123      cl_map_flags flags,
2124      size_type size,
2125      const vector<Event>* events = NULL,
2126      Event* event = NULL);
2127  template<typename T, class SVMTrait>
2128  class SVMAllocator {
2129  private:
2130      Context context_;
2131  public:
2132      typedef T value_type;
2133      typedef value_type* pointer;
2134      typedef const value_type* const_pointer;
2135      typedef value_type& reference;
2136      typedef const value_type& const_reference;
2137      typedef std::size_t size_type;
2138      typedef std::ptrdiff_t difference_type;
2139      template<typename U>
2140      struct rebind
2141      {
2142          typedef SVMAllocator<U, SVMTrait> other;
2143      };
2144      template<typename U, typename V>
2145      friend class SVMAllocator;
2146      SVMAllocator() :
2147          context_(Context::getDefault())
2148      {
2149      }
2150      explicit SVMAllocator(cl::Context context) :
2151          context_(context)
2152      {
2153      }
2154      SVMAllocator(const SVMAllocator &other) :
2155          context_(other.context_)
2156      {
2157      }
2158      template<typename U>
2159      SVMAllocator(const SVMAllocator<U, SVMTrait> &other) :
2160          context_(other.context_)
2161      {
2162      }
2163      ~SVMAllocator()
2164      {
2165      }
2166      pointer address(reference r) CL_HPP_NOEXCEPT_
2167      {
2168          return std::addressof(r);
2169      }
2170      const_pointer address(const_reference r) CL_HPP_NOEXCEPT_
2171      {
2172          return std::addressof(r);
2173      }
2174      pointer allocate(
2175          size_type size,
2176          typename cl::SVMAllocator<void, SVMTrait>::const_pointer = 0)
2177      {
2178          void* voidPointer =
2179              clSVMAlloc(
2180              context_(),
2181              SVMTrait::getSVMMemFlags(),
2182              size*sizeof(T),
2183              sizeof(T));
2184          pointer retValue = reinterpret_cast<pointer>(
2185              voidPointer);
2186  #if defined(CL_HPP_ENABLE_EXCEPTIONS)
2187          if (!retValue) {
2188              std::bad_alloc excep;
2189              throw excep;
2190          }
2191  #endif 
2192          if (!(SVMTrait::getSVMMemFlags() & CL_MEM_SVM_FINE_GRAIN_BUFFER)) {
2193              cl_int err = enqueueMapSVM(retValue, CL_TRUE, CL_MAP_READ | CL_MAP_WRITE, size*sizeof(T));
2194              if (err != CL_SUCCESS) {
2195                  std::bad_alloc excep;
2196                  throw excep;
2197              }
2198          }
2199          return retValue;
2200      }
2201      void deallocate(pointer p, size_type)
2202      {
2203          clSVMFree(context_(), p);
2204      }
2205      size_type max_size() const CL_HPP_NOEXCEPT_
2206      {
2207          size_type maxSize = std::numeric_limits<size_type>::max() / sizeof(T);
2208          for (Device &d : context_.getInfo<CL_CONTEXT_DEVICES>()) {
2209              maxSize = std::min(
2210                  maxSize, 
2211                  static_cast<size_type>(d.getInfo<CL_DEVICE_MAX_MEM_ALLOC_SIZE>()));
2212          }
2213          return maxSize;
2214      }
2215      template< class U, class... Args >
2216      void construct(U* p, Args&&... args)
2217      {
2218          new(p)T(args...);
2219      }
2220      template< class U >
2221      void destroy(U* p)
2222      {
2223          p->~U();
2224      }
2225      inline bool operator==(SVMAllocator const& rhs)
2226      {
2227          return (context_==rhs.context_);
2228      }
2229      inline bool operator!=(SVMAllocator const& a)
2230      {
2231          return !operator==(a);
2232      }
2233  }; 
2234  template<class SVMTrait>
2235  class SVMAllocator<void, SVMTrait> {
2236  public:
2237      typedef void value_type;
2238      typedef value_type* pointer;
2239      typedef const value_type* const_pointer;
2240      template<typename U>
2241      struct rebind
2242      {
2243          typedef SVMAllocator<U, SVMTrait> other;
2244      };
2245      template<typename U, typename V>
2246      friend class SVMAllocator;
2247  };
2248  #if !defined(CL_HPP_NO_STD_UNIQUE_PTR)
2249  namespace detail
2250  {
2251      template<class Alloc>
2252      class Deleter {
2253      private:
2254          Alloc alloc_;
2255          size_type copies_;
2256      public:
2257          typedef typename std::allocator_traits<Alloc>::pointer pointer;
2258          Deleter(const Alloc &alloc, size_type copies) : alloc_{ alloc }, copies_{ copies }
2259          {
2260          }
2261          void operator()(pointer ptr) const {
2262              Alloc tmpAlloc{ alloc_ };
2263              std::allocator_traits<Alloc>::destroy(tmpAlloc, std::addressof(*ptr));
2264              std::allocator_traits<Alloc>::deallocate(tmpAlloc, ptr, copies_);
2265          }
2266      };
2267  } 
2268  template <class T, class Alloc, class... Args>
2269  cl::pointer<T, detail::Deleter<Alloc>> allocate_pointer(const Alloc &alloc_, Args&&... args)
2270  {
2271      Alloc alloc(alloc_);
2272      static const size_t copies = 1;
2273      T* tmp = std::allocator_traits<Alloc>::allocate(alloc, copies);
2274      if (!tmp) {
2275          std::bad_alloc excep;
2276          throw excep;
2277      }
2278      try {
2279          std::allocator_traits<Alloc>::construct(
2280              alloc,
2281              std::addressof(*tmp),
2282              std::forward<Args>(args)...);
2283          return cl::pointer<T, detail::Deleter<Alloc>>(tmp, detail::Deleter<Alloc>{alloc, copies});
2284      }
2285      catch (std::bad_alloc b)
2286      {
2287          std::allocator_traits<Alloc>::deallocate(alloc, tmp, copies);
2288          throw;
2289      }
2290  }
2291  template< class T, class SVMTrait, class... Args >
2292  cl::pointer<T, detail::Deleter<SVMAllocator<T, SVMTrait>>> allocate_svm(Args... args)
2293  {
2294      SVMAllocator<T, SVMTrait> alloc;
2295      return cl::allocate_pointer<T>(alloc, args...);
2296  }
2297  template< class T, class SVMTrait, class... Args >
2298  cl::pointer<T, detail::Deleter<SVMAllocator<T, SVMTrait>>> allocate_svm(const cl::Context &c, Args... args)
2299  {
2300      SVMAllocator<T, SVMTrait> alloc(c);
2301      return cl::allocate_pointer<T>(alloc, args...);
2302  }
2303  #endif 
2304  template < class T >
2305  using coarse_svm_vector = vector<T, cl::SVMAllocator<int, cl::SVMTraitCoarse<>>>;
2306  template < class T >
2307  using fine_svm_vector = vector<T, cl::SVMAllocator<int, cl::SVMTraitFine<>>>;
2308  template < class T >
2309  using atomic_svm_vector = vector<T, cl::SVMAllocator<int, cl::SVMTraitAtomic<>>>;
2310  #endif 
2311  class Buffer : public Memory
2312  {
2313  public:
2314      Buffer(
2315          const Context& context,
2316          cl_mem_flags flags,
2317          size_type size,
2318          void* host_ptr = NULL,
2319          cl_int* err = NULL)
2320      {
2321          cl_int error;
2322          object_ = ::clCreateBuffer(context(), flags, size, host_ptr, &error);
2323          detail::errHandler(error, __CREATE_BUFFER_ERR);
2324          if (err != NULL) {
2325              *err = error;
2326          }
2327      }
2328      Buffer(
2329           cl_mem_flags flags,
2330          size_type size,
2331          void* host_ptr = NULL,
2332          cl_int* err = NULL)
2333      {
2334          cl_int error;
2335          Context context = Context::getDefault(err);
2336          object_ = ::clCreateBuffer(context(), flags, size, host_ptr, &error);
2337          detail::errHandler(error, __CREATE_BUFFER_ERR);
2338          if (err != NULL) {
2339              *err = error;
2340          }
2341      }
2342      template< typename IteratorType >
2343      Buffer(
2344          IteratorType startIterator,
2345          IteratorType endIterator,
2346          bool readOnly,
2347          bool useHostPtr = false,
2348          cl_int* err = NULL)
2349      {
2350          typedef typename std::iterator_traits<IteratorType>::value_type DataType;
2351          cl_int error;
2352          cl_mem_flags flags = 0;
2353          if( readOnly ) {
2354              flags |= CL_MEM_READ_ONLY;
2355          }
2356          else {
2357              flags |= CL_MEM_READ_WRITE;
2358          }
2359          if( useHostPtr ) {
2360              flags |= CL_MEM_USE_HOST_PTR;
2361          }
2362          size_type size = sizeof(DataType)*(endIterator - startIterator);
2363          Context context = Context::getDefault(err);
2364          if( useHostPtr ) {
2365              object_ = ::clCreateBuffer(context(), flags, size, static_cast<DataType*>(&*startIterator), &error);
2366          } else {
2367              object_ = ::clCreateBuffer(context(), flags, size, 0, &error);
2368          }
2369          detail::errHandler(error, __CREATE_BUFFER_ERR);
2370          if (err != NULL) {
2371              *err = error;
2372          }
2373          if( !useHostPtr ) {
2374              error = cl::copy(startIterator, endIterator, *this);
2375              detail::errHandler(error, __CREATE_BUFFER_ERR);
2376              if (err != NULL) {
2377                  *err = error;
2378              }
2379          }
2380      }
2381      template< typename IteratorType >
2382      Buffer(const Context &context, IteratorType startIterator, IteratorType endIterator,
2383          bool readOnly, bool useHostPtr = false, cl_int* err = NULL);
2384      template< typename IteratorType >
2385      Buffer(const CommandQueue &queue, IteratorType startIterator, IteratorType endIterator,
2386          bool readOnly, bool useHostPtr = false, cl_int* err = NULL);
2387      Buffer() : Memory() { }
2388      explicit Buffer(const cl_mem& buffer, bool retainObject = false) :
2389          Memory(buffer, retainObject) { }
2390      Buffer& operator = (const cl_mem& rhs)
2391      {
2392          Memory::operator=(rhs);
2393          return *this;
2394      }
2395      Buffer(const Buffer& buf) : Memory(buf) {}
2396      Buffer& operator = (const Buffer &buf)
2397      {
2398          Memory::operator=(buf);
2399          return *this;
2400      }
2401      Buffer(Buffer&& buf) CL_HPP_NOEXCEPT_ : Memory(std::move(buf)) {}
2402      Buffer& operator = (Buffer &&buf)
2403      {
2404          Memory::operator=(std::move(buf));
2405          return *this;
2406      }
2407  #if CL_HPP_TARGET_OPENCL_VERSION >= 110
2408      Buffer createSubBuffer(
2409          cl_mem_flags flags,
2410          cl_buffer_create_type buffer_create_type,
2411          const void * buffer_create_info,
2412          cl_int * err = NULL)
2413      {
2414          Buffer result;
2415          cl_int error;
2416          result.object_ = ::clCreateSubBuffer(
2417              object_, 
2418              flags, 
2419              buffer_create_type, 
2420              buffer_create_info, 
2421              &error);
2422          detail::errHandler(error, __CREATE_SUBBUFFER_ERR);
2423          if (err != NULL) {
2424              *err = error;
2425          }
2426          return result;
2427      }		
2428  #endif 
2429  };
2430  #if defined (CL_HPP_USE_DX_INTEROP)
2431  class BufferD3D10 : public Buffer
2432  {
2433  public:
2434      BufferD3D10(
2435          const Context& context,
2436          cl_mem_flags flags,
2437          ID3D10Buffer* bufobj,
2438          cl_int * err = NULL) : pfn_clCreateFromD3D10BufferKHR(nullptr)
2439      {
2440          typedef CL_API_ENTRY cl_mem (CL_API_CALL *PFN_clCreateFromD3D10BufferKHR)(
2441              cl_context context, cl_mem_flags flags, ID3D10Buffer*  buffer,
2442              cl_int* errcode_ret);
2443          PFN_clCreateFromD3D10BufferKHR pfn_clCreateFromD3D10BufferKHR;
2444  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
2445          vector<cl_context_properties> props = context.getInfo<CL_CONTEXT_PROPERTIES>();
2446          cl_platform platform = -1;
2447          for( int i = 0; i < props.size(); ++i ) {
2448              if( props[i] == CL_CONTEXT_PLATFORM ) {
2449                  platform = props[i+1];
2450              }
2451          }
2452          CL_HPP_INIT_CL_EXT_FCN_PTR_PLATFORM_(platform, clCreateFromD3D10BufferKHR);
2453  #elif CL_HPP_TARGET_OPENCL_VERSION >= 110
2454          CL_HPP_INIT_CL_EXT_FCN_PTR_(clCreateFromD3D10BufferKHR);
2455  #endif
2456          cl_int error;
2457          object_ = pfn_clCreateFromD3D10BufferKHR(
2458              context(),
2459              flags,
2460              bufobj,
2461              &error);
2462          detail::errHandler(error, __CREATE_GL_BUFFER_ERR);
2463          if (err != NULL) {
2464              *err = error;
2465          }
2466      }
2467      BufferD3D10() : Buffer() { }
2468      explicit BufferD3D10(const cl_mem& buffer, bool retainObject = false) : 
2469          Buffer(buffer, retainObject) { }
2470      BufferD3D10& operator = (const cl_mem& rhs)
2471      {
2472          Buffer::operator=(rhs);
2473          return *this;
2474      }
2475      BufferD3D10(const BufferD3D10& buf) : 
2476          Buffer(buf) {}
2477      BufferD3D10& operator = (const BufferD3D10 &buf)
2478      {
2479          Buffer::operator=(buf);
2480          return *this;
2481      }
2482      BufferD3D10(BufferD3D10&& buf) CL_HPP_NOEXCEPT_ : Buffer(std::move(buf)) {}
2483      BufferD3D10& operator = (BufferD3D10 &&buf)
2484      {
2485          Buffer::operator=(std::move(buf));
2486          return *this;
2487      }
2488  };
2489  #endif
2490  class BufferGL : public Buffer
2491  {
2492  public:
2493      BufferGL(
2494          const Context& context,
2495          cl_mem_flags flags,
2496          cl_GLuint bufobj,
2497          cl_int * err = NULL)
2498      {
2499          cl_int error;
2500          object_ = ::clCreateFromGLBuffer(
2501              context(),
2502              flags,
2503              bufobj,
2504              &error);
2505          detail::errHandler(error, __CREATE_GL_BUFFER_ERR);
2506          if (err != NULL) {
2507              *err = error;
2508          }
2509      }
2510      BufferGL() : Buffer() { }
2511      explicit BufferGL(const cl_mem& buffer, bool retainObject = false) :
2512          Buffer(buffer, retainObject) { }
2513      BufferGL& operator = (const cl_mem& rhs)
2514      {
2515          Buffer::operator=(rhs);
2516          return *this;
2517      }
2518      BufferGL(const BufferGL& buf) : Buffer(buf) {}
2519      BufferGL& operator = (const BufferGL &buf)
2520      {
2521          Buffer::operator=(buf);
2522          return *this;
2523      }
2524      BufferGL(BufferGL&& buf) CL_HPP_NOEXCEPT_ : Buffer(std::move(buf)) {}
2525      BufferGL& operator = (BufferGL &&buf)
2526      {
2527          Buffer::operator=(std::move(buf));
2528          return *this;
2529      }
2530      cl_int getObjectInfo(
2531          cl_gl_object_type *type,
2532          cl_GLuint * gl_object_name)
2533      {
2534          return detail::errHandler(
2535              ::clGetGLObjectInfo(object_,type,gl_object_name),
2536              __GET_GL_OBJECT_INFO_ERR);
2537      }
2538  };
2539  class BufferRenderGL : public Buffer
2540  {
2541  public:
2542      BufferRenderGL(
2543          const Context& context,
2544          cl_mem_flags flags,
2545          cl_GLuint bufobj,
2546          cl_int * err = NULL)
2547      {
2548          cl_int error;
2549          object_ = ::clCreateFromGLRenderbuffer(
2550              context(),
2551              flags,
2552              bufobj,
2553              &error);
2554          detail::errHandler(error, __CREATE_GL_RENDER_BUFFER_ERR);
2555          if (err != NULL) {
2556              *err = error;
2557          }
2558      }
2559      BufferRenderGL() : Buffer() { }
2560      explicit BufferRenderGL(const cl_mem& buffer, bool retainObject = false) :
2561          Buffer(buffer, retainObject) { }
2562      BufferRenderGL& operator = (const cl_mem& rhs)
2563      {
2564          Buffer::operator=(rhs);
2565          return *this;
2566      }
2567      BufferRenderGL(const BufferRenderGL& buf) : Buffer(buf) {}
2568      BufferRenderGL& operator = (const BufferRenderGL &buf)
2569      {
2570          Buffer::operator=(buf);
2571          return *this;
2572      }
2573      BufferRenderGL(BufferRenderGL&& buf) CL_HPP_NOEXCEPT_ : Buffer(std::move(buf)) {}
2574      BufferRenderGL& operator = (BufferRenderGL &&buf)
2575      {
2576          Buffer::operator=(std::move(buf));
2577          return *this;
2578      }
2579      cl_int getObjectInfo(
2580          cl_gl_object_type *type,
2581          cl_GLuint * gl_object_name)
2582      {
2583          return detail::errHandler(
2584              ::clGetGLObjectInfo(object_,type,gl_object_name),
2585              __GET_GL_OBJECT_INFO_ERR);
2586      }
2587  };
2588  class Image : public Memory
2589  {
2590  protected:
2591      Image() : Memory() { }
2592      explicit Image(const cl_mem& image, bool retainObject = false) :
2593          Memory(image, retainObject) { }
2594      Image& operator = (const cl_mem& rhs)
2595      {
2596          Memory::operator=(rhs);
2597          return *this;
2598      }
2599      Image(const Image& img) : Memory(img) {}
2600      Image& operator = (const Image &img)
2601      {
2602          Memory::operator=(img);
2603          return *this;
2604      }
2605      Image(Image&& img) CL_HPP_NOEXCEPT_ : Memory(std::move(img)) {}
2606      Image& operator = (Image &&img)
2607      {
2608          Memory::operator=(std::move(img));
2609          return *this;
2610      }
2611  public:
2612      template <typename T>
2613      cl_int getImageInfo(cl_image_info name, T* param) const
2614      {
2615          return detail::errHandler(
2616              detail::getInfo(&::clGetImageInfo, object_, name, param),
2617              __GET_IMAGE_INFO_ERR);
2618      }
2619      template <cl_int name> typename
2620      detail::param_traits<detail::cl_image_info, name>::param_type
2621      getImageInfo(cl_int* err = NULL) const
2622      {
2623          typename detail::param_traits<
2624              detail::cl_image_info, name>::param_type param;
2625          cl_int result = getImageInfo(name, &param);
2626          if (err != NULL) {
2627              *err = result;
2628          }
2629          return param;
2630      }
2631  };
2632  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
2633  class Image1D : public Image
2634  {
2635  public:
2636      Image1D(
2637          const Context& context,
2638          cl_mem_flags flags,
2639          ImageFormat format,
2640          size_type width,
2641          void* host_ptr = NULL,
2642          cl_int* err = NULL)
2643      {
2644          cl_int error;
2645          cl_image_desc desc =
2646          {
2647              CL_MEM_OBJECT_IMAGE1D,
2648              width,
2649              0, 0, 0, 0, 0, 0, 0, 0
2650          };
2651          object_ = ::clCreateImage(
2652              context(), 
2653              flags, 
2654              &format, 
2655              &desc, 
2656              host_ptr, 
2657              &error);
2658          detail::errHandler(error, __CREATE_IMAGE_ERR);
2659          if (err != NULL) {
2660              *err = error;
2661          }
2662      }
2663      Image1D() { }
2664      explicit Image1D(const cl_mem& image1D, bool retainObject = false) :
2665          Image(image1D, retainObject) { }
2666      Image1D& operator = (const cl_mem& rhs)
2667      {
2668          Image::operator=(rhs);
2669          return *this;
2670      }
2671      Image1D(const Image1D& img) : Image(img) {}
2672      Image1D& operator = (const Image1D &img)
2673      {
2674          Image::operator=(img);
2675          return *this;
2676      }
2677      Image1D(Image1D&& img) CL_HPP_NOEXCEPT_ : Image(std::move(img)) {}
2678      Image1D& operator = (Image1D &&img)
2679      {
2680          Image::operator=(std::move(img));
2681          return *this;
2682      }
2683  };
2684  class Image1DBuffer : public Image
2685  {
2686  public:
2687      Image1DBuffer(
2688          const Context& context,
2689          cl_mem_flags flags,
2690          ImageFormat format,
2691          size_type width,
2692          const Buffer &buffer,
2693          cl_int* err = NULL)
2694      {
2695          cl_int error;
2696          cl_image_desc desc =
2697          {
2698              CL_MEM_OBJECT_IMAGE1D_BUFFER,
2699              width,
2700              0, 0, 0, 0, 0, 0, 0,
2701              buffer()
2702          };
2703          object_ = ::clCreateImage(
2704              context(), 
2705              flags, 
2706              &format, 
2707              &desc, 
2708              NULL, 
2709              &error);
2710          detail::errHandler(error, __CREATE_IMAGE_ERR);
2711          if (err != NULL) {
2712              *err = error;
2713          }
2714      }
2715      Image1DBuffer() { }
2716      explicit Image1DBuffer(const cl_mem& image1D, bool retainObject = false) :
2717          Image(image1D, retainObject) { }
2718      Image1DBuffer& operator = (const cl_mem& rhs)
2719      {
2720          Image::operator=(rhs);
2721          return *this;
2722      }
2723      Image1DBuffer(const Image1DBuffer& img) : Image(img) {}
2724      Image1DBuffer& operator = (const Image1DBuffer &img)
2725      {
2726          Image::operator=(img);
2727          return *this;
2728      }
2729      Image1DBuffer(Image1DBuffer&& img) CL_HPP_NOEXCEPT_ : Image(std::move(img)) {}
2730      Image1DBuffer& operator = (Image1DBuffer &&img)
2731      {
2732          Image::operator=(std::move(img));
2733          return *this;
2734      }
2735  };
2736  class Image1DArray : public Image
2737  {
2738  public:
2739      Image1DArray(
2740          const Context& context,
2741          cl_mem_flags flags,
2742          ImageFormat format,
2743          size_type arraySize,
2744          size_type width,
2745          size_type rowPitch,
2746          void* host_ptr = NULL,
2747          cl_int* err = NULL)
2748      {
2749          cl_int error;
2750          cl_image_desc desc =
2751          {
2752              CL_MEM_OBJECT_IMAGE1D_ARRAY,
2753              width,
2754              0, 0,  
2755              arraySize,
2756              rowPitch,
2757              0, 0, 0, 0
2758          };
2759          object_ = ::clCreateImage(
2760              context(), 
2761              flags, 
2762              &format, 
2763              &desc, 
2764              host_ptr, 
2765              &error);
2766          detail::errHandler(error, __CREATE_IMAGE_ERR);
2767          if (err != NULL) {
2768              *err = error;
2769          }
2770      }
2771      Image1DArray() { }
2772      explicit Image1DArray(const cl_mem& imageArray, bool retainObject = false) :
2773          Image(imageArray, retainObject) { }
2774      Image1DArray& operator = (const cl_mem& rhs)
2775      {
2776          Image::operator=(rhs);
2777          return *this;
2778      }
2779      Image1DArray(const Image1DArray& img) : Image(img) {}
2780      Image1DArray& operator = (const Image1DArray &img)
2781      {
2782          Image::operator=(img);
2783          return *this;
2784      }
2785      Image1DArray(Image1DArray&& img) CL_HPP_NOEXCEPT_ : Image(std::move(img)) {}
2786      Image1DArray& operator = (Image1DArray &&img)
2787      {
2788          Image::operator=(std::move(img));
2789          return *this;
2790      }
2791  };
2792  #endif 
2793  class Image2D : public Image
2794  {
2795  public:
2796      Image2D(
2797          const Context& context,
2798          cl_mem_flags flags,
2799          ImageFormat format,
2800          size_type width,
2801          size_type height,
2802          size_type row_pitch = 0,
2803          void* host_ptr = NULL,
2804          cl_int* err = NULL)
2805      {
2806          cl_int error;
2807          bool useCreateImage;
2808  #if CL_HPP_TARGET_OPENCL_VERSION >= 120 && CL_HPP_MINIMUM_OPENCL_VERSION < 120
2809          {
2810              cl_uint version = detail::getContextPlatformVersion(context());
2811              useCreateImage = (version >= 0x10002); 
2812          }
2813  #elif CL_HPP_TARGET_OPENCL_VERSION >= 120
2814          useCreateImage = true;
2815  #else
2816          useCreateImage = false;
2817  #endif
2818  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
2819          if (useCreateImage)
2820          {
2821              cl_image_desc desc =
2822              {
2823                  CL_MEM_OBJECT_IMAGE2D,
2824                  width,
2825                  height,
2826                  0, 0, 
2827                  row_pitch,
2828                  0, 0, 0, 0
2829              };
2830              object_ = ::clCreateImage(
2831                  context(),
2832                  flags,
2833                  &format,
2834                  &desc,
2835                  host_ptr,
2836                  &error);
2837              detail::errHandler(error, __CREATE_IMAGE_ERR);
2838              if (err != NULL) {
2839                  *err = error;
2840              }
2841          }
2842  #endif 
2843  #if CL_HPP_MINIMUM_OPENCL_VERSION < 120
2844          if (!useCreateImage)
2845          {
2846              object_ = ::clCreateImage2D(
2847                  context(), flags,&format, width, height, row_pitch, host_ptr, &error);
2848              detail::errHandler(error, __CREATE_IMAGE2D_ERR);
2849              if (err != NULL) {
2850                  *err = error;
2851              }
2852          }
2853  #endif 
2854      }
2855  #if CL_HPP_TARGET_OPENCL_VERSION >= 200
2856      Image2D(
2857          const Context& context,
2858          ImageFormat format,
2859          const Buffer &sourceBuffer,
2860          size_type width,
2861          size_type height,
2862          size_type row_pitch = 0,
2863          cl_int* err = nullptr)
2864      {
2865          cl_int error;
2866          cl_image_desc desc =
2867          {
2868              CL_MEM_OBJECT_IMAGE2D,
2869              width,
2870              height,
2871              0, 0, 
2872              row_pitch,
2873              0, 0, 0,
2874              sourceBuffer()
2875          };
2876          object_ = ::clCreateImage(
2877              context(),
2878              0, 
2879              &format,
2880              &desc,
2881              nullptr,
2882              &error);
2883          detail::errHandler(error, __CREATE_IMAGE_ERR);
2884          if (err != nullptr) {
2885              *err = error;
2886          }
2887      }
2888  #endif 
2889  #if CL_HPP_TARGET_OPENCL_VERSION >= 200
2890      Image2D(
2891          const Context& context,
2892          cl_channel_order order,
2893          const Image &sourceImage,
2894          cl_int* err = nullptr)
2895      {
2896          cl_int error;
2897          size_type sourceWidth = 
2898              sourceImage.getImageInfo<CL_IMAGE_WIDTH>();
2899          size_type sourceHeight = 
2900              sourceImage.getImageInfo<CL_IMAGE_HEIGHT>();
2901          size_type sourceRowPitch =
2902              sourceImage.getImageInfo<CL_IMAGE_ROW_PITCH>();
2903          cl_uint sourceNumMIPLevels =
2904              sourceImage.getImageInfo<CL_IMAGE_NUM_MIP_LEVELS>();
2905          cl_uint sourceNumSamples =
2906              sourceImage.getImageInfo<CL_IMAGE_NUM_SAMPLES>();
2907          cl_image_format sourceFormat =
2908              sourceImage.getImageInfo<CL_IMAGE_FORMAT>();
2909          sourceFormat.image_channel_order = order;
2910          cl_image_desc desc =
2911          {
2912              CL_MEM_OBJECT_IMAGE2D,
2913              sourceWidth,
2914              sourceHeight,
2915              0, 0, 
2916              sourceRowPitch,
2917              0, 
2918              sourceNumMIPLevels,
2919              sourceNumSamples,
2920              sourceImage()
2921          };
2922          object_ = ::clCreateImage(
2923              context(),
2924              0, 
2925              &sourceFormat,
2926              &desc,
2927              nullptr,
2928              &error);
2929          detail::errHandler(error, __CREATE_IMAGE_ERR);
2930          if (err != nullptr) {
2931              *err = error;
2932          }
2933      }
2934  #endif 
2935      Image2D() { }
2936      explicit Image2D(const cl_mem& image2D, bool retainObject = false) :
2937          Image(image2D, retainObject) { }
2938      Image2D& operator = (const cl_mem& rhs)
2939      {
2940          Image::operator=(rhs);
2941          return *this;
2942      }
2943      Image2D(const Image2D& img) : Image(img) {}
2944      Image2D& operator = (const Image2D &img)
2945      {
2946          Image::operator=(img);
2947          return *this;
2948      }
2949      Image2D(Image2D&& img) CL_HPP_NOEXCEPT_ : Image(std::move(img)) {}
2950      Image2D& operator = (Image2D &&img)
2951      {
2952          Image::operator=(std::move(img));
2953          return *this;
2954      }
2955  };
2956  #if defined(CL_USE_DEPRECATED_OPENCL_1_1_APIS)
2957  class CL_EXT_PREFIX__VERSION_1_1_DEPRECATED Image2DGL : public Image2D 
2958  {
2959  public:
2960      Image2DGL(
2961          const Context& context,
2962          cl_mem_flags flags,
2963          cl_GLenum target,
2964          cl_GLint  miplevel,
2965          cl_GLuint texobj,
2966          cl_int * err = NULL)
2967      {
2968          cl_int error;
2969          object_ = ::clCreateFromGLTexture2D(
2970              context(),
2971              flags,
2972              target,
2973              miplevel,
2974              texobj,
2975              &error);
2976          detail::errHandler(error, __CREATE_GL_TEXTURE_2D_ERR);
2977          if (err != NULL) {
2978              *err = error;
2979          }
2980      }
2981      Image2DGL() : Image2D() { }
2982      explicit Image2DGL(const cl_mem& image, bool retainObject = false) : 
2983          Image2D(image, retainObject) { }
2984      Image2DGL& operator = (const cl_mem& rhs)
2985      {
2986          Image2D::operator=(rhs);
2987          return *this;
2988      }
2989      Image2DGL(const Image2DGL& img) : Image2D(img) {}
2990      Image2DGL& operator = (const Image2DGL &img)
2991      {
2992          Image2D::operator=(img);
2993          return *this;
2994      }
2995      Image2DGL(Image2DGL&& img) CL_HPP_NOEXCEPT_ : Image2D(std::move(img)) {}
2996      Image2DGL& operator = (Image2DGL &&img)
2997      {
2998          Image2D::operator=(std::move(img));
2999          return *this;
3000      }
3001  } CL_EXT_SUFFIX__VERSION_1_1_DEPRECATED;
3002  #endif 
3003  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
3004  class Image2DArray : public Image
3005  {
3006  public:
3007      Image2DArray(
3008          const Context& context,
3009          cl_mem_flags flags,
3010          ImageFormat format,
3011          size_type arraySize,
3012          size_type width,
3013          size_type height,
3014          size_type rowPitch,
3015          size_type slicePitch,
3016          void* host_ptr = NULL,
3017          cl_int* err = NULL)
3018      {
3019          cl_int error;
3020          cl_image_desc desc =
3021          {
3022              CL_MEM_OBJECT_IMAGE2D_ARRAY,
3023              width,
3024              height,
3025              0,       
3026              arraySize,
3027              rowPitch,
3028              slicePitch,
3029              0, 0, 0
3030          };
3031          object_ = ::clCreateImage(
3032              context(), 
3033              flags, 
3034              &format, 
3035              &desc, 
3036              host_ptr, 
3037              &error);
3038          detail::errHandler(error, __CREATE_IMAGE_ERR);
3039          if (err != NULL) {
3040              *err = error;
3041          }
3042      }
3043      Image2DArray() { }
3044      explicit Image2DArray(const cl_mem& imageArray, bool retainObject = false) : Image(imageArray, retainObject) { }
3045      Image2DArray& operator = (const cl_mem& rhs)
3046      {
3047          Image::operator=(rhs);
3048          return *this;
3049      }
3050      Image2DArray(const Image2DArray& img) : Image(img) {}
3051      Image2DArray& operator = (const Image2DArray &img)
3052      {
3053          Image::operator=(img);
3054          return *this;
3055      }
3056      Image2DArray(Image2DArray&& img) CL_HPP_NOEXCEPT_ : Image(std::move(img)) {}
3057      Image2DArray& operator = (Image2DArray &&img)
3058      {
3059          Image::operator=(std::move(img));
3060          return *this;
3061      }
3062  };
3063  #endif 
3064  class Image3D : public Image
3065  {
3066  public:
3067      Image3D(
3068          const Context& context,
3069          cl_mem_flags flags,
3070          ImageFormat format,
3071          size_type width,
3072          size_type height,
3073          size_type depth,
3074          size_type row_pitch = 0,
3075          size_type slice_pitch = 0,
3076          void* host_ptr = NULL,
3077          cl_int* err = NULL)
3078      {
3079          cl_int error;
3080          bool useCreateImage;
3081  #if CL_HPP_TARGET_OPENCL_VERSION >= 120 && CL_HPP_MINIMUM_OPENCL_VERSION < 120
3082          {
3083              cl_uint version = detail::getContextPlatformVersion(context());
3084              useCreateImage = (version >= 0x10002); 
3085          }
3086  #elif CL_HPP_TARGET_OPENCL_VERSION >= 120
3087          useCreateImage = true;
3088  #else
3089          useCreateImage = false;
3090  #endif
3091  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
3092          if (useCreateImage)
3093          {
3094              cl_image_desc desc =
3095              {
3096                  CL_MEM_OBJECT_IMAGE3D,
3097                  width,
3098                  height,
3099                  depth,
3100                  0,      
3101                  row_pitch,
3102                  slice_pitch,
3103                  0, 0, 0
3104              };
3105              object_ = ::clCreateImage(
3106                  context(), 
3107                  flags, 
3108                  &format, 
3109                  &desc, 
3110                  host_ptr, 
3111                  &error);
3112              detail::errHandler(error, __CREATE_IMAGE_ERR);
3113              if (err != NULL) {
3114                  *err = error;
3115              }
3116          }
3117  #endif  
3118  #if CL_HPP_MINIMUM_OPENCL_VERSION < 120
3119          if (!useCreateImage)
3120          {
3121              object_ = ::clCreateImage3D(
3122                  context(), flags, &format, width, height, depth, row_pitch,
3123                  slice_pitch, host_ptr, &error);
3124              detail::errHandler(error, __CREATE_IMAGE3D_ERR);
3125              if (err != NULL) {
3126                  *err = error;
3127              }
3128          }
3129  #endif 
3130      }
3131      Image3D() : Image() { }
3132      explicit Image3D(const cl_mem& image3D, bool retainObject = false) : 
3133          Image(image3D, retainObject) { }
3134      Image3D& operator = (const cl_mem& rhs)
3135      {
3136          Image::operator=(rhs);
3137          return *this;
3138      }
3139      Image3D(const Image3D& img) : Image(img) {}
3140      Image3D& operator = (const Image3D &img)
3141      {
3142          Image::operator=(img);
3143          return *this;
3144      }
3145      Image3D(Image3D&& img) CL_HPP_NOEXCEPT_ : Image(std::move(img)) {}
3146      Image3D& operator = (Image3D &&img)
3147      {
3148          Image::operator=(std::move(img));
3149          return *this;
3150      }
3151  };
3152  #if defined(CL_USE_DEPRECATED_OPENCL_1_1_APIS)
3153  class Image3DGL : public Image3D
3154  {
3155  public:
3156      Image3DGL(
3157          const Context& context,
3158          cl_mem_flags flags,
3159          cl_GLenum target,
3160          cl_GLint  miplevel,
3161          cl_GLuint texobj,
3162          cl_int * err = NULL)
3163      {
3164          cl_int error;
3165          object_ = ::clCreateFromGLTexture3D(
3166              context(),
3167              flags,
3168              target,
3169              miplevel,
3170              texobj,
3171              &error);
3172          detail::errHandler(error, __CREATE_GL_TEXTURE_3D_ERR);
3173          if (err != NULL) {
3174              *err = error;
3175          }
3176      }
3177      Image3DGL() : Image3D() { }
3178      explicit Image3DGL(const cl_mem& image, bool retainObject = false) : 
3179          Image3D(image, retainObject) { }
3180      Image3DGL& operator = (const cl_mem& rhs)
3181      {
3182          Image3D::operator=(rhs);
3183          return *this;
3184      }
3185      Image3DGL(const Image3DGL& img) : Image3D(img) {}
3186      Image3DGL& operator = (const Image3DGL &img)
3187      {
3188          Image3D::operator=(img);
3189          return *this;
3190      }
3191      Image3DGL(Image3DGL&& img) CL_HPP_NOEXCEPT_ : Image3D(std::move(img)) {}
3192      Image3DGL& operator = (Image3DGL &&img)
3193      {
3194          Image3D::operator=(std::move(img));
3195          return *this;
3196      }
3197  };
3198  #endif 
3199  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
3200  class ImageGL : public Image
3201  {
3202  public:
3203      ImageGL(
3204          const Context& context,
3205          cl_mem_flags flags,
3206          cl_GLenum target,
3207          cl_GLint  miplevel,
3208          cl_GLuint texobj,
3209          cl_int * err = NULL)
3210      {
3211          cl_int error;
3212          object_ = ::clCreateFromGLTexture(
3213              context(), 
3214              flags, 
3215              target,
3216              miplevel,
3217              texobj,
3218              &error);
3219          detail::errHandler(error, __CREATE_GL_TEXTURE_ERR);
3220          if (err != NULL) {
3221              *err = error;
3222          }
3223      }
3224      ImageGL() : Image() { }
3225      explicit ImageGL(const cl_mem& image, bool retainObject = false) : 
3226          Image(image, retainObject) { }
3227      ImageGL& operator = (const cl_mem& rhs)
3228      {
3229          Image::operator=(rhs);
3230          return *this;
3231      }
3232      ImageGL(const ImageGL& img) : Image(img) {}
3233      ImageGL& operator = (const ImageGL &img)
3234      {
3235          Image::operator=(img);
3236          return *this;
3237      }
3238      ImageGL(ImageGL&& img) CL_HPP_NOEXCEPT_ : Image(std::move(img)) {}
3239      ImageGL& operator = (ImageGL &&img)
3240      {
3241          Image::operator=(std::move(img));
3242          return *this;
3243      }
3244  };
3245  #endif 
3246  #if CL_HPP_TARGET_OPENCL_VERSION >= 200
3247  class Pipe : public Memory
3248  {
3249  public:
3250      Pipe(
3251          const Context& context,
3252          cl_uint packet_size,
3253          cl_uint max_packets,
3254          cl_int* err = NULL)
3255      {
3256          cl_int error;
3257          cl_mem_flags flags = CL_MEM_READ_WRITE | CL_MEM_HOST_NO_ACCESS;
3258          object_ = ::clCreatePipe(context(), flags, packet_size, max_packets, nullptr, &error);
3259          detail::errHandler(error, __CREATE_PIPE_ERR);
3260          if (err != NULL) {
3261              *err = error;
3262          }
3263      }
3264      Pipe(
3265          cl_uint packet_size,
3266          cl_uint max_packets,
3267          cl_int* err = NULL)
3268      {
3269          cl_int error;
3270          Context context = Context::getDefault(err);
3271          cl_mem_flags flags = CL_MEM_READ_WRITE | CL_MEM_HOST_NO_ACCESS;
3272          object_ = ::clCreatePipe(context(), flags, packet_size, max_packets, nullptr, &error);
3273          detail::errHandler(error, __CREATE_PIPE_ERR);
3274          if (err != NULL) {
3275              *err = error;
3276          }
3277      }
3278      Pipe() : Memory() { }
3279      explicit Pipe(const cl_mem& pipe, bool retainObject = false) :
3280          Memory(pipe, retainObject) { }
3281      Pipe& operator = (const cl_mem& rhs)
3282      {
3283          Memory::operator=(rhs);
3284          return *this;
3285      }
3286      Pipe(const Pipe& pipe) : Memory(pipe) {}
3287      Pipe& operator = (const Pipe &pipe)
3288      {
3289          Memory::operator=(pipe);
3290          return *this;
3291      }
3292      Pipe(Pipe&& pipe) CL_HPP_NOEXCEPT_ : Memory(std::move(pipe)) {}
3293      Pipe& operator = (Pipe &&pipe)
3294      {
3295          Memory::operator=(std::move(pipe));
3296          return *this;
3297      }
3298      template <typename T>
3299      cl_int getInfo(cl_pipe_info name, T* param) const
3300      {
3301          return detail::errHandler(
3302              detail::getInfo(&::clGetPipeInfo, object_, name, param),
3303              __GET_PIPE_INFO_ERR);
3304      }
3305      template <cl_int name> typename
3306          detail::param_traits<detail::cl_pipe_info, name>::param_type
3307          getInfo(cl_int* err = NULL) const
3308      {
3309          typename detail::param_traits<
3310              detail::cl_pipe_info, name>::param_type param;
3311          cl_int result = getInfo(name, &param);
3312          if (err != NULL) {
3313              *err = result;
3314          }
3315          return param;
3316      }
3317  }; 
3318  #endif 
3319  class Sampler : public detail::Wrapper<cl_sampler>
3320  {
3321  public:
3322      Sampler() { }
3323      Sampler(
3324          const Context& context,
3325          cl_bool normalized_coords,
3326          cl_addressing_mode addressing_mode,
<span onclick='openModal()' class='match'>3327          cl_filter_mode filter_mode,
3328          cl_int* err = NULL)
3329      {
3330          cl_int error;
3331  #if CL_HPP_TARGET_OPENCL_VERSION >= 200
3332          cl_sampler_properties sampler_properties[] = {
3333              CL_SAMPLER_NORMALIZED_COORDS, normalized_coords,
</span>3334              CL_SAMPLER_ADDRESSING_MODE, addressing_mode,
3335              CL_SAMPLER_FILTER_MODE, filter_mode,
3336              0 };
3337          object_ = ::clCreateSamplerWithProperties(
3338              context(),
3339              sampler_properties,
3340              &error);
3341          detail::errHandler(error, __CREATE_SAMPLER_WITH_PROPERTIES_ERR);
3342          if (err != NULL) {
3343              *err = error;
3344          }
3345  #else
3346          object_ = ::clCreateSampler(
3347              context(),
3348              normalized_coords,
3349              addressing_mode,
3350              filter_mode,
3351              &error);
3352          detail::errHandler(error, __CREATE_SAMPLER_ERR);
3353          if (err != NULL) {
3354              *err = error;
3355          }
3356  #endif        
3357      }
3358      explicit Sampler(const cl_sampler& sampler, bool retainObject = false) : 
3359          detail::Wrapper<cl_type>(sampler, retainObject) { }
3360      Sampler& operator = (const cl_sampler& rhs)
3361      {
3362          detail::Wrapper<cl_type>::operator=(rhs);
3363          return *this;
3364      }
3365      Sampler(const Sampler& sam) : detail::Wrapper<cl_type>(sam) {}
3366      Sampler& operator = (const Sampler &sam)
3367      {
3368          detail::Wrapper<cl_type>::operator=(sam);
3369          return *this;
3370      }
3371      Sampler(Sampler&& sam) CL_HPP_NOEXCEPT_ : detail::Wrapper<cl_type>(std::move(sam)) {}
3372      Sampler& operator = (Sampler &&sam)
3373      {
3374          detail::Wrapper<cl_type>::operator=(std::move(sam));
3375          return *this;
3376      }
3377      template <typename T>
3378      cl_int getInfo(cl_sampler_info name, T* param) const
3379      {
3380          return detail::errHandler(
3381              detail::getInfo(&::clGetSamplerInfo, object_, name, param),
3382              __GET_SAMPLER_INFO_ERR);
3383      }
3384      template <cl_int name> typename
3385      detail::param_traits<detail::cl_sampler_info, name>::param_type
3386      getInfo(cl_int* err = NULL) const
3387      {
3388          typename detail::param_traits<
3389              detail::cl_sampler_info, name>::param_type param;
3390          cl_int result = getInfo(name, &param);
3391          if (err != NULL) {
3392              *err = result;
3393          }
3394          return param;
3395      }
3396  };
3397  class Program;
3398  class CommandQueue;
3399  class DeviceCommandQueue;
3400  class Kernel;
3401  class NDRange
3402  {
3403  private:
3404      size_type sizes_[3];
3405      cl_uint dimensions_;
3406  public:
3407      NDRange()
3408          : dimensions_(0)
3409      {
3410          sizes_[0] = 0;
3411          sizes_[1] = 0;
3412          sizes_[2] = 0;
3413      }
3414      NDRange(size_type size0)
3415          : dimensions_(1)
3416      {
3417          sizes_[0] = size0;
3418          sizes_[1] = 1;
3419          sizes_[2] = 1;
3420      }
3421      NDRange(size_type size0, size_type size1)
3422          : dimensions_(2)
3423      {
3424          sizes_[0] = size0;
3425          sizes_[1] = size1;
3426          sizes_[2] = 1;
3427      }
3428      NDRange(size_type size0, size_type size1, size_type size2)
3429          : dimensions_(3)
3430      {
3431          sizes_[0] = size0;
3432          sizes_[1] = size1;
3433          sizes_[2] = size2;
3434      }
3435      operator const size_type*() const { 
3436          return sizes_; 
3437      }
3438      size_type dimensions() const 
3439      { 
3440          return dimensions_; 
3441      }
3442      size_type size() const
3443      {
3444          return dimensions_*sizeof(size_type);
3445      }
3446      size_type* get()
3447      {
3448          return sizes_;
3449      }
3450      const size_type* get() const
3451      {
3452          return sizes_;
3453      }
3454  };
3455  static const NDRange NullRange;
3456  struct LocalSpaceArg
3457  {
3458      size_type size_;
3459  };
3460  namespace detail {
3461  template <typename T, class Enable = void>
3462  struct KernelArgumentHandler;
3463  template <typename T>
3464  struct KernelArgumentHandler<T, typename std::enable_if<!std::is_base_of<cl::Memory, T>::value>::type>
3465  {
3466      static size_type size(const T&) { return sizeof(T); }
3467      static const T* ptr(const T& value) { return &value; }
3468  };
3469  template <typename T>
3470  struct KernelArgumentHandler<T, typename std::enable_if<std::is_base_of<cl::Memory, T>::value>::type>
3471  {
3472      static size_type size(const T&) { return sizeof(cl_mem); }
3473      static const cl_mem* ptr(const T& value) { return &(value()); }
3474  };
3475  template <>
3476  struct KernelArgumentHandler<LocalSpaceArg, void>
3477  {
3478      static size_type size(const LocalSpaceArg& value) { return value.size_; }
3479      static const void* ptr(const LocalSpaceArg&) { return NULL; }
3480  };
3481  } 
3482  inline LocalSpaceArg
3483  Local(size_type size)
3484  {
3485      LocalSpaceArg ret = { size };
3486      return ret;
3487  }
3488  class Kernel : public detail::Wrapper<cl_kernel>
3489  {
3490  public:
3491      inline Kernel(const Program& program, const char* name, cl_int* err = NULL);
3492      Kernel() { }
3493      explicit Kernel(const cl_kernel& kernel, bool retainObject = false) : 
3494          detail::Wrapper<cl_type>(kernel, retainObject) { }
3495      Kernel& operator = (const cl_kernel& rhs)
3496      {
3497          detail::Wrapper<cl_type>::operator=(rhs);
3498          return *this;
3499      }
3500      Kernel(const Kernel& kernel) : detail::Wrapper<cl_type>(kernel) {}
3501      Kernel& operator = (const Kernel &kernel)
3502      {
3503          detail::Wrapper<cl_type>::operator=(kernel);
3504          return *this;
3505      }
3506      Kernel(Kernel&& kernel) CL_HPP_NOEXCEPT_ : detail::Wrapper<cl_type>(std::move(kernel)) {}
3507      Kernel& operator = (Kernel &&kernel)
3508      {
3509          detail::Wrapper<cl_type>::operator=(std::move(kernel));
3510          return *this;
3511      }
3512      template <typename T>
3513      cl_int getInfo(cl_kernel_info name, T* param) const
3514      {
3515          return detail::errHandler(
3516              detail::getInfo(&::clGetKernelInfo, object_, name, param),
3517              __GET_KERNEL_INFO_ERR);
3518      }
3519      template <cl_int name> typename
3520      detail::param_traits<detail::cl_kernel_info, name>::param_type
3521      getInfo(cl_int* err = NULL) const
3522      {
3523          typename detail::param_traits<
3524              detail::cl_kernel_info, name>::param_type param;
3525          cl_int result = getInfo(name, &param);
3526          if (err != NULL) {
3527              *err = result;
3528          }
3529          return param;
3530      }
3531  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
3532      template <typename T>
3533      cl_int getArgInfo(cl_uint argIndex, cl_kernel_arg_info name, T* param) const
3534      {
3535          return detail::errHandler(
3536              detail::getInfo(&::clGetKernelArgInfo, object_, argIndex, name, param),
3537              __GET_KERNEL_ARG_INFO_ERR);
3538      }
3539      template <cl_int name> typename
3540      detail::param_traits<detail::cl_kernel_arg_info, name>::param_type
3541      getArgInfo(cl_uint argIndex, cl_int* err = NULL) const
3542      {
3543          typename detail::param_traits<
3544              detail::cl_kernel_arg_info, name>::param_type param;
3545          cl_int result = getArgInfo(argIndex, name, &param);
3546          if (err != NULL) {
3547              *err = result;
3548          }
3549          return param;
3550      }
3551  #endif 
3552      template <typename T>
3553      cl_int getWorkGroupInfo(
3554          const Device& device, cl_kernel_work_group_info name, T* param) const
3555      {
3556          return detail::errHandler(
3557              detail::getInfo(
3558                  &::clGetKernelWorkGroupInfo, object_, device(), name, param),
3559                  __GET_KERNEL_WORK_GROUP_INFO_ERR);
3560      }
3561      template <cl_int name> typename
3562      detail::param_traits<detail::cl_kernel_work_group_info, name>::param_type
3563          getWorkGroupInfo(const Device& device, cl_int* err = NULL) const
3564      {
3565          typename detail::param_traits<
3566          detail::cl_kernel_work_group_info, name>::param_type param;
3567          cl_int result = getWorkGroupInfo(device, name, &param);
3568          if (err != NULL) {
3569              *err = result;
3570          }
3571          return param;
3572      }
3573  #if CL_HPP_TARGET_OPENCL_VERSION >= 200
3574  #if defined(CL_HPP_USE_CL_SUB_GROUPS_KHR)
3575      cl_int getSubGroupInfo(const cl::Device &dev, cl_kernel_sub_group_info name, const cl::NDRange &range, size_type* param) const
3576      {
3577          typedef clGetKernelSubGroupInfoKHR_fn PFN_clGetKernelSubGroupInfoKHR;
3578          static PFN_clGetKernelSubGroupInfoKHR pfn_clGetKernelSubGroupInfoKHR = NULL;
3579          CL_HPP_INIT_CL_EXT_FCN_PTR_(clGetKernelSubGroupInfoKHR);
3580          return detail::errHandler(
3581              pfn_clGetKernelSubGroupInfoKHR(object_, dev(), name, range.size(), range.get(), sizeof(size_type), param, nullptr),
3582              __GET_KERNEL_ARG_INFO_ERR);
3583      }
3584      template <cl_int name>
3585          size_type getSubGroupInfo(const cl::Device &dev, const cl::NDRange &range, cl_int* err = NULL) const
3586      {
3587          size_type param;
3588          cl_int result = getSubGroupInfo(dev, name, range, &param);
3589          if (err != NULL) {
3590              *err = result;
3591          }
3592          return param;
3593      }
3594  #endif 
3595  #endif 
3596  #if CL_HPP_TARGET_OPENCL_VERSION >= 200
3597      template<typename T, class D>
3598      cl_int setArg(cl_uint index, const cl::pointer<T, D> &argPtr)
3599      {
3600          return detail::errHandler(
3601              ::clSetKernelArgSVMPointer(object_, index, argPtr.get()),
3602              __SET_KERNEL_ARGS_ERR);
3603      }
3604      template<typename T, class Alloc>
3605      cl_int setArg(cl_uint index, const cl::vector<T, Alloc> &argPtr)
3606      {
3607          return detail::errHandler(
3608              ::clSetKernelArgSVMPointer(object_, index, argPtr.data()),
3609              __SET_KERNEL_ARGS_ERR);
3610      }
3611      template<typename T>
3612      typename std::enable_if<std::is_pointer<T>::value, cl_int>::type
3613          setArg(cl_uint index, const T argPtr)
3614      {
3615          return detail::errHandler(
3616              ::clSetKernelArgSVMPointer(object_, index, argPtr),
3617              __SET_KERNEL_ARGS_ERR);
3618      }
3619  #endif 
3620      template <typename T>
3621      typename std::enable_if<!std::is_pointer<T>::value, cl_int>::type
3622          setArg(cl_uint index, const T &value)
3623      {
3624          return detail::errHandler(
3625              ::clSetKernelArg(
3626                  object_,
3627                  index,
3628                  detail::KernelArgumentHandler<T>::size(value),
3629                  detail::KernelArgumentHandler<T>::ptr(value)),
3630              __SET_KERNEL_ARGS_ERR);
3631      }
3632      cl_int setArg(cl_uint index, size_type size, const void* argPtr)
3633      {
3634          return detail::errHandler(
3635              ::clSetKernelArg(object_, index, size, argPtr),
3636              __SET_KERNEL_ARGS_ERR);
3637      }
3638  #if CL_HPP_TARGET_OPENCL_VERSION >= 200
3639      cl_int setSVMPointers(const vector<void*> &pointerList)
3640      {
3641          return detail::errHandler(
3642              ::clSetKernelExecInfo(
3643                  object_,
3644                  CL_KERNEL_EXEC_INFO_SVM_PTRS,
3645                  sizeof(void*)*pointerList.size(),
3646                  pointerList.data()));
3647      }
3648      template<int ArrayLength>
3649      cl_int setSVMPointers(const std::array<void*, ArrayLength> &pointerList)
3650      {
3651          return detail::errHandler(
3652              ::clSetKernelExecInfo(
3653                  object_,
3654                  CL_KERNEL_EXEC_INFO_SVM_PTRS,
3655                  sizeof(void*)*pointerList.size(),
3656                  pointerList.data()));
3657      }
3658      cl_int enableFineGrainedSystemSVM(bool svmEnabled)
3659      {
3660          cl_bool svmEnabled_ = svmEnabled ? CL_TRUE : CL_FALSE;
3661          return detail::errHandler(
3662              ::clSetKernelExecInfo(
3663                  object_,
3664                  CL_KERNEL_EXEC_INFO_SVM_FINE_GRAIN_SYSTEM,
3665                  sizeof(cl_bool),
3666                  &svmEnabled_
3667                  )
3668              );
3669      }
3670      template<int index, int ArrayLength, class D, typename T0, typename... Ts>
3671      void setSVMPointersHelper(std::array<void*, ArrayLength> &pointerList, const pointer<T0, D> &t0, Ts... ts)
3672      {
3673          pointerList[index] = static_cast<void*>(t0.get());
3674          setSVMPointersHelper<index + 1, Ts...>(ts...);
3675      }
3676      template<int index, int ArrayLength, typename T0, typename... Ts>
3677      typename std::enable_if<std::is_pointer<T0>::value, void>::type
3678      setSVMPointersHelper(std::array<void*, ArrayLength> &pointerList, T0 t0, Ts... ts)
3679      {
3680          pointerList[index] = static_cast<void*>(t0);
3681          setSVMPointersHelper<index + 1, Ts...>(ts...);
3682      }
3683      template<int index, int ArrayLength, typename T0, class D>
3684      void setSVMPointersHelper(std::array<void*, ArrayLength> &pointerList, const pointer<T0, D> &t0)
3685      {
3686          pointerList[index] = static_cast<void*>(t0.get());
3687      }
3688      template<int index, int ArrayLength, typename T0>
3689      typename std::enable_if<std::is_pointer<T0>::value, void>::type
3690      setSVMPointersHelper(std::array<void*, ArrayLength> &pointerList, T0 t0)
3691      {
3692          pointerList[index] = static_cast<void*>(t0);
3693      }
3694      template<typename T0, typename... Ts>
3695      cl_int setSVMPointers(const T0 &t0, Ts... ts)
3696      {
3697          std::array<void*, 1 + sizeof...(Ts)> pointerList;
3698          setSVMPointersHelper<0, 1 + sizeof...(Ts)>(pointerList, t0, ts...);
3699          return detail::errHandler(
3700              ::clSetKernelExecInfo(
3701              object_,
3702              CL_KERNEL_EXEC_INFO_SVM_PTRS,
3703              sizeof(void*)*(1 + sizeof...(Ts)),
3704              pointerList.data()));
3705      }
3706  #endif 
3707  };
3708  class Program : public detail::Wrapper<cl_program>
3709  {
3710  public:
3711  #if !defined(CL_HPP_ENABLE_PROGRAM_CONSTRUCTION_FROM_ARRAY_COMPATIBILITY)
3712      typedef vector<vector<unsigned char>> Binaries;
3713      typedef vector<string> Sources;
3714  #else 
3715      typedef vector<std::pair<const void*, size_type> > Binaries;
3716      typedef vector<std::pair<const char*, size_type> > Sources;
3717  #endif 
3718      Program(
3719          const string& source,
3720          bool build = false,
3721          cl_int* err = NULL)
3722      {
3723          cl_int error;
3724          const char * strings = source.c_str();
3725          const size_type length  = source.size();
3726          Context context = Context::getDefault(err);
3727          object_ = ::clCreateProgramWithSource(
3728              context(), (cl_uint)1, &strings, &length, &error);
3729          detail::errHandler(error, __CREATE_PROGRAM_WITH_SOURCE_ERR);
3730          if (error == CL_SUCCESS && build) {
3731              error = ::clBuildProgram(
3732                  object_,
3733                  0,
3734                  NULL,
3735  #if !defined(CL_HPP_CL_1_2_DEFAULT_BUILD)
3736                  "-cl-std=CL2.0",
3737  #else
3738                  "",
3739  #endif 
3740                  NULL,
3741                  NULL);
3742              detail::buildErrHandler(error, __BUILD_PROGRAM_ERR, getBuildInfo<CL_PROGRAM_BUILD_LOG>());
3743          }
3744          if (err != NULL) {
3745              *err = error;
3746          }
3747      }
3748      Program(
3749          const Context& context,
3750          const string& source,
3751          bool build = false,
3752          cl_int* err = NULL)
3753      {
3754          cl_int error;
3755          const char * strings = source.c_str();
3756          const size_type length  = source.size();
3757          object_ = ::clCreateProgramWithSource(
3758              context(), (cl_uint)1, &strings, &length, &error);
3759          detail::errHandler(error, __CREATE_PROGRAM_WITH_SOURCE_ERR);
3760          if (error == CL_SUCCESS && build) {
3761              error = ::clBuildProgram(
3762                  object_,
3763                  0,
3764                  NULL,
3765  #if !defined(CL_HPP_CL_1_2_DEFAULT_BUILD)
3766                  "-cl-std=CL2.0",
3767  #else
3768                  "",
3769  #endif 
3770                  NULL,
3771                  NULL);
3772              detail::buildErrHandler(error, __BUILD_PROGRAM_ERR, getBuildInfo<CL_PROGRAM_BUILD_LOG>());
3773          }
3774          if (err != NULL) {
3775              *err = error;
3776          }
3777      }
3778      Program(
3779          const Sources& sources,
3780          cl_int* err = NULL)
3781      {
3782          cl_int error;
3783          Context context = Context::getDefault(err);
3784          const size_type n = (size_type)sources.size();
3785          vector<size_type> lengths(n);
3786          vector<const char*> strings(n);
3787          for (size_type i = 0; i < n; ++i) {
3788  #if !defined(CL_HPP_ENABLE_PROGRAM_CONSTRUCTION_FROM_ARRAY_COMPATIBILITY)
3789              strings[i] = sources[(int)i].data();
3790              lengths[i] = sources[(int)i].length();
3791  #else 
3792              strings[i] = sources[(int)i].first;
3793              lengths[i] = sources[(int)i].second;
3794  #endif 
3795          }
3796          object_ = ::clCreateProgramWithSource(
3797              context(), (cl_uint)n, strings.data(), lengths.data(), &error);
3798          detail::errHandler(error, __CREATE_PROGRAM_WITH_SOURCE_ERR);
3799          if (err != NULL) {
3800              *err = error;
3801          }
3802      }
3803      Program(
3804          const Context& context,
3805          const Sources& sources,
3806          cl_int* err = NULL)
3807      {
3808          cl_int error;
3809          const size_type n = (size_type)sources.size();
3810          vector<size_type> lengths(n);
3811          vector<const char*> strings(n);
3812          for (size_type i = 0; i < n; ++i) {
3813  #if !defined(CL_HPP_ENABLE_PROGRAM_CONSTRUCTION_FROM_ARRAY_COMPATIBILITY)
3814              strings[i] = sources[(int)i].data();
3815              lengths[i] = sources[(int)i].length();
3816  #else 
3817              strings[i] = sources[(int)i].first;
3818              lengths[i] = sources[(int)i].second;
3819  #endif 
3820          }
3821          object_ = ::clCreateProgramWithSource(
3822              context(), (cl_uint)n, strings.data(), lengths.data(), &error);
3823          detail::errHandler(error, __CREATE_PROGRAM_WITH_SOURCE_ERR);
3824          if (err != NULL) {
3825              *err = error;
3826          }
3827      }
3828      Program(
3829          const Context& context,
3830          const vector<Device>& devices,
3831          const Binaries& binaries,
3832          vector<cl_int>* binaryStatus = NULL,
3833          cl_int* err = NULL)
3834      {
3835          cl_int error;
3836          const size_type numDevices = devices.size();
3837          if(binaries.size() != numDevices) {
3838              error = CL_INVALID_VALUE;
3839              detail::errHandler(error, __CREATE_PROGRAM_WITH_BINARY_ERR);
3840              if (err != NULL) {
3841                  *err = error;
3842              }
3843              return;
3844          }
3845          vector<size_type> lengths(numDevices);
3846          vector<const unsigned char*> images(numDevices);
3847  #if !defined(CL_HPP_ENABLE_PROGRAM_CONSTRUCTION_FROM_ARRAY_COMPATIBILITY)
3848          for (size_type i = 0; i < numDevices; ++i) {
3849              images[i] = binaries[i].data();
3850              lengths[i] = binaries[(int)i].size();
3851          }
3852  #else 
3853          for (size_type i = 0; i < numDevices; ++i) {
3854              images[i] = (const unsigned char*)binaries[i].first;
3855              lengths[i] = binaries[(int)i].second;
3856          }
3857  #endif 
3858          vector<cl_device_id> deviceIDs(numDevices);
3859          for( size_type deviceIndex = 0; deviceIndex < numDevices; ++deviceIndex ) {
3860              deviceIDs[deviceIndex] = (devices[deviceIndex])();
3861          }
3862          if(binaryStatus) {
3863              binaryStatus->resize(numDevices);
3864          }
3865          object_ = ::clCreateProgramWithBinary(
3866              context(), (cl_uint) devices.size(),
3867              deviceIDs.data(),
3868              lengths.data(), images.data(), (binaryStatus != NULL && numDevices > 0)
3869                 ? &binaryStatus->front()
3870                 : NULL, &error);
3871          detail::errHandler(error, __CREATE_PROGRAM_WITH_BINARY_ERR);
3872          if (err != NULL) {
3873              *err = error;
3874          }
3875      }
3876  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
3877      Program(
3878          const Context& context,
3879          const vector<Device>& devices,
3880          const string& kernelNames,
3881          cl_int* err = NULL)
3882      {
3883          cl_int error;
3884          size_type numDevices = devices.size();
3885          vector<cl_device_id> deviceIDs(numDevices);
3886          for( size_type deviceIndex = 0; deviceIndex < numDevices; ++deviceIndex ) {
3887              deviceIDs[deviceIndex] = (devices[deviceIndex])();
3888          }
3889          object_ = ::clCreateProgramWithBuiltInKernels(
3890              context(), 
3891              (cl_uint) devices.size(),
3892              deviceIDs.data(),
3893              kernelNames.c_str(), 
3894              &error);
3895          detail::errHandler(error, __CREATE_PROGRAM_WITH_BUILT_IN_KERNELS_ERR);
3896          if (err != NULL) {
3897              *err = error;
3898          }
3899      }
3900  #endif 
3901      Program() { }
3902      explicit Program(const cl_program& program, bool retainObject = false) : 
3903          detail::Wrapper<cl_type>(program, retainObject) { }
3904      Program& operator = (const cl_program& rhs)
3905      {
3906          detail::Wrapper<cl_type>::operator=(rhs);
3907          return *this;
3908      }
3909      Program(const Program& program) : detail::Wrapper<cl_type>(program) {}
3910      Program& operator = (const Program &program)
3911      {
3912          detail::Wrapper<cl_type>::operator=(program);
3913          return *this;
3914      }
3915      Program(Program&& program) CL_HPP_NOEXCEPT_ : detail::Wrapper<cl_type>(std::move(program)) {}
3916      Program& operator = (Program &&program)
3917      {
3918          detail::Wrapper<cl_type>::operator=(std::move(program));
3919          return *this;
3920      }
3921      cl_int build(
3922          const vector<Device>& devices,
3923          const char* options = NULL,
3924          void (CL_CALLBACK * notifyFptr)(cl_program, void *) = NULL,
3925          void* data = NULL) const
3926      {
3927          size_type numDevices = devices.size();
3928          vector<cl_device_id> deviceIDs(numDevices);
3929          for( size_type deviceIndex = 0; deviceIndex < numDevices; ++deviceIndex ) {
3930              deviceIDs[deviceIndex] = (devices[deviceIndex])();
3931          }
3932          cl_int buildError = ::clBuildProgram(
3933              object_,
3934              (cl_uint)
3935              devices.size(),
3936              deviceIDs.data(),
3937              options,
3938              notifyFptr,
3939              data);
3940          return detail::buildErrHandler(buildError, __BUILD_PROGRAM_ERR, getBuildInfo<CL_PROGRAM_BUILD_LOG>());
3941      }
3942      cl_int build(
3943          const char* options = NULL,
3944          void (CL_CALLBACK * notifyFptr)(cl_program, void *) = NULL,
3945          void* data = NULL) const
3946      {
3947          cl_int buildError = ::clBuildProgram(
3948              object_,
3949              0,
3950              NULL,
3951              options,
3952              notifyFptr,
3953              data);
3954          return detail::buildErrHandler(buildError, __BUILD_PROGRAM_ERR, getBuildInfo<CL_PROGRAM_BUILD_LOG>());
3955      }
3956  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
3957      cl_int compile(
3958          const char* options = NULL,
3959          void (CL_CALLBACK * notifyFptr)(cl_program, void *) = NULL,
3960          void* data = NULL) const
3961      {
3962          cl_int error = ::clCompileProgram(
3963              object_,
3964              0,
3965              NULL,
3966              options,
3967              0,
3968              NULL,
3969              NULL,
3970              notifyFptr,
3971              data);
3972          return detail::buildErrHandler(error, __COMPILE_PROGRAM_ERR, getBuildInfo<CL_PROGRAM_BUILD_LOG>());
3973      }
3974  #endif 
3975      template <typename T>
3976      cl_int getInfo(cl_program_info name, T* param) const
3977      {
3978          return detail::errHandler(
3979              detail::getInfo(&::clGetProgramInfo, object_, name, param),
3980              __GET_PROGRAM_INFO_ERR);
3981      }
3982      template <cl_int name> typename
3983      detail::param_traits<detail::cl_program_info, name>::param_type
3984      getInfo(cl_int* err = NULL) const
3985      {
3986          typename detail::param_traits<
3987              detail::cl_program_info, name>::param_type param;
3988          cl_int result = getInfo(name, &param);
3989          if (err != NULL) {
3990              *err = result;
3991          }
3992          return param;
3993      }
3994      template <typename T>
3995      cl_int getBuildInfo(
3996          const Device& device, cl_program_build_info name, T* param) const
3997      {
3998          return detail::errHandler(
3999              detail::getInfo(
4000                  &::clGetProgramBuildInfo, object_, device(), name, param),
4001                  __GET_PROGRAM_BUILD_INFO_ERR);
4002      }
4003      template <cl_int name> typename
4004      detail::param_traits<detail::cl_program_build_info, name>::param_type
4005      getBuildInfo(const Device& device, cl_int* err = NULL) const
4006      {
4007          typename detail::param_traits<
4008              detail::cl_program_build_info, name>::param_type param;
4009          cl_int result = getBuildInfo(device, name, &param);
4010          if (err != NULL) {
4011              *err = result;
4012          }
4013          return param;
4014      }
4015      template <cl_int name>
4016      vector<std::pair<cl::Device, typename detail::param_traits<detail::cl_program_build_info, name>::param_type>>
4017          getBuildInfo(cl_int *err = NULL) const
4018      {
4019          cl_int result = CL_SUCCESS;
4020          auto devs = getInfo<CL_PROGRAM_DEVICES>(&result);
4021          vector<std::pair<cl::Device, typename detail::param_traits<detail::cl_program_build_info, name>::param_type>>
4022              devInfo;
4023          if (result != CL_SUCCESS) {
4024              if (err != NULL) {
4025                  *err = result;
4026              }
4027              return devInfo;
4028          }
4029          for (cl::Device d : devs) {
4030              typename detail::param_traits<
4031                  detail::cl_program_build_info, name>::param_type param;
4032              result = getBuildInfo(d, name, &param);
4033              devInfo.push_back(
4034                  std::pair<cl::Device, typename detail::param_traits<detail::cl_program_build_info, name>::param_type>
4035                  (d, param));
4036              if (result != CL_SUCCESS) {
4037                  break;
4038              }
4039          }
4040          if (err != NULL) {
4041              *err = result;
4042          }
4043          if (result != CL_SUCCESS) {
4044              devInfo.clear();
4045          }
4046          return devInfo;
4047      }
4048      cl_int createKernels(vector<Kernel>* kernels)
4049      {
4050          cl_uint numKernels;
4051          cl_int err = ::clCreateKernelsInProgram(object_, 0, NULL, &numKernels);
4052          if (err != CL_SUCCESS) {
4053              return detail::errHandler(err, __CREATE_KERNELS_IN_PROGRAM_ERR);
4054          }
4055          vector<cl_kernel> value(numKernels);
4056          err = ::clCreateKernelsInProgram(
4057              object_, numKernels, value.data(), NULL);
4058          if (err != CL_SUCCESS) {
4059              return detail::errHandler(err, __CREATE_KERNELS_IN_PROGRAM_ERR);
4060          }
4061          if (kernels) {
4062              kernels->resize(value.size());
4063              for (size_type i = 0; i < value.size(); i++) {
4064                  (*kernels)[i] = Kernel(value[i], false);
4065              }
4066          }
4067          return CL_SUCCESS;
4068      }
4069  };
4070  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
4071  inline Program linkProgram(
4072      Program input1,
4073      Program input2,
4074      const char* options = NULL,
4075      void (CL_CALLBACK * notifyFptr)(cl_program, void *) = NULL,
4076      void* data = NULL,
4077      cl_int* err = NULL) 
4078  {
4079      cl_int error_local = CL_SUCCESS;
4080      cl_program programs[2] = { input1(), input2() };
4081      Context ctx = input1.getInfo<CL_PROGRAM_CONTEXT>(&error_local);
4082      if(error_local!=CL_SUCCESS) {
4083          detail::errHandler(error_local, __LINK_PROGRAM_ERR);
4084      }
4085      cl_program prog = ::clLinkProgram(
4086          ctx(),
4087          0,
4088          NULL,
4089          options,
4090          2,
4091          programs,
4092          notifyFptr,
4093          data,
4094          &error_local);
4095      detail::errHandler(error_local,__COMPILE_PROGRAM_ERR);
4096      if (err != NULL) {
4097          *err = error_local;
4098      }
4099      return Program(prog);
4100  }
4101  inline Program linkProgram(
4102      vector<Program> inputPrograms,
4103      const char* options = NULL,
4104      void (CL_CALLBACK * notifyFptr)(cl_program, void *) = NULL,
4105      void* data = NULL,
4106      cl_int* err = NULL) 
4107  {
4108      cl_int error_local = CL_SUCCESS;
4109      vector<cl_program> programs(inputPrograms.size());
4110      for (unsigned int i = 0; i < inputPrograms.size(); i++) {
4111          programs[i] = inputPrograms[i]();
4112      }
4113      Context ctx;
4114      if(inputPrograms.size() > 0) {
4115          ctx = inputPrograms[0].getInfo<CL_PROGRAM_CONTEXT>(&error_local);
4116          if(error_local!=CL_SUCCESS) {
4117              detail::errHandler(error_local, __LINK_PROGRAM_ERR);
4118          }
4119      }
4120      cl_program prog = ::clLinkProgram(
4121          ctx(),
4122          0,
4123          NULL,
4124          options,
4125          (cl_uint)inputPrograms.size(),
4126          programs.data(),
4127          notifyFptr,
4128          data,
4129          &error_local);
4130      detail::errHandler(error_local,__COMPILE_PROGRAM_ERR);
4131      if (err != NULL) {
4132          *err = error_local;
4133      }
4134      return Program(prog, false);
4135  }
4136  #endif 
4137  template <>
4138  inline cl_int cl::Program::getInfo(cl_program_info name, vector<vector<unsigned char>>* param) const
4139  {
4140      if (name != CL_PROGRAM_BINARIES) {
4141          return CL_INVALID_VALUE;
4142      }
4143      if (param) {
4144          vector<size_type> sizes = getInfo<CL_PROGRAM_BINARY_SIZES>();
4145          size_type numBinaries = sizes.size();
4146          param->resize(numBinaries);
4147          for (int i = 0; i < numBinaries; ++i) {
4148              (*param)[i].resize(sizes[i]);
4149          }
4150          return detail::errHandler(
4151              detail::getInfo(&::clGetProgramInfo, object_, name, param),
4152              __GET_PROGRAM_INFO_ERR);
4153      }
4154      return CL_SUCCESS;
4155  }
4156  template<>
4157  inline vector<vector<unsigned char>> cl::Program::getInfo<CL_PROGRAM_BINARIES>(cl_int* err) const
4158  {
4159      vector<vector<unsigned char>> binariesVectors;
4160      cl_int result = getInfo(CL_PROGRAM_BINARIES, &binariesVectors);
4161      if (err != NULL) {
4162          *err = result;
4163      }
4164      return binariesVectors;
4165  }
4166  inline Kernel::Kernel(const Program& program, const char* name, cl_int* err)
4167  {
4168      cl_int error;
4169      object_ = ::clCreateKernel(program(), name, &error);
4170      detail::errHandler(error, __CREATE_KERNEL_ERR);
4171      if (err != NULL) {
4172          *err = error;
4173      }
4174  }
4175  enum class QueueProperties : cl_command_queue_properties
4176  {
4177      None = 0,
4178      Profiling = CL_QUEUE_PROFILING_ENABLE,
4179      OutOfOrder = CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE,
4180  };
4181  QueueProperties operator|(QueueProperties lhs, QueueProperties rhs)
4182  {
4183      return static_cast<QueueProperties>(static_cast<cl_command_queue_properties>(lhs) | static_cast<cl_command_queue_properties>(rhs));
4184  }
4185  class CommandQueue : public detail::Wrapper<cl_command_queue>
4186  {
4187  private:
4188      static std::once_flag default_initialized_;
4189      static CommandQueue default_;
4190      static cl_int default_error_;
4191      static void makeDefault()
4192      {
4193  #if defined(CL_HPP_ENABLE_EXCEPTIONS)
4194          try
4195  #endif
4196          {
4197              int error;
4198              Context context = Context::getDefault(&error);
4199              if (error != CL_SUCCESS) {
4200                  default_error_ = error;
4201              }
4202              else {
4203                  Device device = Device::getDefault();
4204                  default_ = CommandQueue(context, device, 0, &default_error_);
4205              }
4206          }
4207  #if defined(CL_HPP_ENABLE_EXCEPTIONS)
4208          catch (cl::Error &e) {
4209              default_error_ = e.err();
4210          }
4211  #endif
4212      }
4213      static void makeDefaultProvided(const CommandQueue &c) {
4214          default_ = c;
4215      }
4216  public:
4217  #ifdef CL_HPP_UNIT_TEST_ENABLE
4218      static void unitTestClearDefault() {
4219          default_ = CommandQueue();
4220      }
4221  #endif 
4222     CommandQueue(
4223          cl_command_queue_properties properties,
4224          cl_int* err = NULL)
4225      {
4226          cl_int error;
4227          Context context = Context::getDefault(&error);
4228          detail::errHandler(error, __CREATE_CONTEXT_ERR);
4229          if (error != CL_SUCCESS) {
4230              if (err != NULL) {
4231                  *err = error;
4232              }
4233          }
4234          else {
4235              Device device = context.getInfo<CL_CONTEXT_DEVICES>()[0];
4236  #if CL_HPP_TARGET_OPENCL_VERSION >= 200
4237              cl_queue_properties queue_properties[] = {
4238                  CL_QUEUE_PROPERTIES, properties, 0 };
4239              if ((properties & CL_QUEUE_ON_DEVICE) == 0) {
4240                  object_ = ::clCreateCommandQueueWithProperties(
4241                      context(), device(), queue_properties, &error);
4242              }
4243              else {
4244                  error = CL_INVALID_QUEUE_PROPERTIES;
4245              }
4246              detail::errHandler(error, __CREATE_COMMAND_QUEUE_WITH_PROPERTIES_ERR);
4247              if (err != NULL) {
4248                  *err = error;
4249              }
4250  #else
4251              object_ = ::clCreateCommandQueue(
4252                  context(), device(), properties, &error);
4253              detail::errHandler(error, __CREATE_COMMAND_QUEUE_ERR);
4254              if (err != NULL) {
4255                  *err = error;
4256              }
4257  #endif
4258          }
4259      }
4260     CommandQueue(
4261         QueueProperties properties,
4262         cl_int* err = NULL)
4263     {
4264         cl_int error;
4265         Context context = Context::getDefault(&error);
4266         detail::errHandler(error, __CREATE_CONTEXT_ERR);
4267         if (error != CL_SUCCESS) {
4268             if (err != NULL) {
4269                 *err = error;
4270             }
4271         }
4272         else {
4273             Device device = context.getInfo<CL_CONTEXT_DEVICES>()[0];
4274  #if CL_HPP_TARGET_OPENCL_VERSION >= 200
4275             cl_queue_properties queue_properties[] = {
4276                 CL_QUEUE_PROPERTIES, static_cast<cl_queue_properties>(properties), 0 };
4277             object_ = ::clCreateCommandQueueWithProperties(
4278                 context(), device(), queue_properties, &error);
4279             detail::errHandler(error, __CREATE_COMMAND_QUEUE_WITH_PROPERTIES_ERR);
4280             if (err != NULL) {
4281                 *err = error;
4282             }
4283  #else
4284             object_ = ::clCreateCommandQueue(
4285                 context(), device(), static_cast<cl_command_queue_properties>(properties), &error);
4286             detail::errHandler(error, __CREATE_COMMAND_QUEUE_ERR);
4287             if (err != NULL) {
4288                 *err = error;
4289             }
4290  #endif
4291         }
4292     }
4293      explicit CommandQueue(
4294          const Context& context,
4295          cl_command_queue_properties properties = 0,
4296          cl_int* err = NULL)
4297      {
4298          cl_int error;
4299          vector<cl::Device> devices;
4300          error = context.getInfo(CL_CONTEXT_DEVICES, &devices);
4301          detail::errHandler(error, __CREATE_CONTEXT_ERR);
4302          if (error != CL_SUCCESS)
4303          {
4304              if (err != NULL) {
4305                  *err = error;
4306              }
4307              return;
4308          }
4309  #if CL_HPP_TARGET_OPENCL_VERSION >= 200
4310          cl_queue_properties queue_properties[] = {
4311              CL_QUEUE_PROPERTIES, properties, 0 };
4312          if ((properties & CL_QUEUE_ON_DEVICE) == 0) {
4313              object_ = ::clCreateCommandQueueWithProperties(
4314                  context(), devices[0](), queue_properties, &error);
4315          }
4316          else {
4317              error = CL_INVALID_QUEUE_PROPERTIES;
4318          }
4319          detail::errHandler(error, __CREATE_COMMAND_QUEUE_WITH_PROPERTIES_ERR);
4320          if (err != NULL) {
4321              *err = error;
4322          }
4323  #else
4324          object_ = ::clCreateCommandQueue(
4325              context(), devices[0](), properties, &error);
4326          detail::errHandler(error, __CREATE_COMMAND_QUEUE_ERR);
4327          if (err != NULL) {
4328              *err = error;
4329          }
4330  #endif
4331      }
4332      explicit CommandQueue(
4333          const Context& context,
4334          QueueProperties properties,
4335          cl_int* err = NULL)
4336      {
4337          cl_int error;
4338          vector<cl::Device> devices;
4339          error = context.getInfo(CL_CONTEXT_DEVICES, &devices);
4340          detail::errHandler(error, __CREATE_CONTEXT_ERR);
4341          if (error != CL_SUCCESS)
4342          {
4343              if (err != NULL) {
4344                  *err = error;
4345              }
4346              return;
4347          }
4348  #if CL_HPP_TARGET_OPENCL_VERSION >= 200
4349          cl_queue_properties queue_properties[] = {
4350              CL_QUEUE_PROPERTIES, static_cast<cl_queue_properties>(properties), 0 };
4351          object_ = ::clCreateCommandQueueWithProperties(
4352              context(), devices[0](), queue_properties, &error);
4353          detail::errHandler(error, __CREATE_COMMAND_QUEUE_WITH_PROPERTIES_ERR);
4354          if (err != NULL) {
4355              *err = error;
4356          }
4357  #else
4358          object_ = ::clCreateCommandQueue(
4359              context(), devices[0](), static_cast<cl_command_queue_properties>(properties), &error);
4360          detail::errHandler(error, __CREATE_COMMAND_QUEUE_ERR);
4361          if (err != NULL) {
4362              *err = error;
4363          }
4364  #endif
4365      }
4366      CommandQueue(
4367          const Context& context,
4368          const Device& device,
4369          cl_command_queue_properties properties = 0,
4370          cl_int* err = NULL)
4371      {
4372          cl_int error;
4373  #if CL_HPP_TARGET_OPENCL_VERSION >= 200
4374          cl_queue_properties queue_properties[] = {
4375              CL_QUEUE_PROPERTIES, properties, 0 };
4376          object_ = ::clCreateCommandQueueWithProperties(
4377              context(), device(), queue_properties, &error);
4378          detail::errHandler(error, __CREATE_COMMAND_QUEUE_WITH_PROPERTIES_ERR);
4379          if (err != NULL) {
4380              *err = error;
4381          }
4382  #else
4383          object_ = ::clCreateCommandQueue(
4384              context(), device(), properties, &error);
4385          detail::errHandler(error, __CREATE_COMMAND_QUEUE_ERR);
4386          if (err != NULL) {
4387              *err = error;
4388          }
4389  #endif
4390      }
4391      CommandQueue(
4392          const Context& context,
4393          const Device& device,
4394          QueueProperties properties,
4395          cl_int* err = NULL)
4396      {
4397              cl_int error;
4398  #if CL_HPP_TARGET_OPENCL_VERSION >= 200
4399              cl_queue_properties queue_properties[] = {
4400                  CL_QUEUE_PROPERTIES, static_cast<cl_queue_properties>(properties), 0 };
4401              object_ = ::clCreateCommandQueueWithProperties(
4402                  context(), device(), queue_properties, &error);
4403              detail::errHandler(error, __CREATE_COMMAND_QUEUE_WITH_PROPERTIES_ERR);
4404              if (err != NULL) {
4405                  *err = error;
4406              }
4407  #else
4408              object_ = ::clCreateCommandQueue(
4409                  context(), device(), static_cast<cl_command_queue_properties>(properties), &error);
4410              detail::errHandler(error, __CREATE_COMMAND_QUEUE_ERR);
4411              if (err != NULL) {
4412                  *err = error;
4413              }
4414  #endif
4415          }
4416      static CommandQueue getDefault(cl_int * err = NULL) 
4417      {
4418          std::call_once(default_initialized_, makeDefault);
4419  #if CL_HPP_TARGET_OPENCL_VERSION >= 200
4420          detail::errHandler(default_error_, __CREATE_COMMAND_QUEUE_WITH_PROPERTIES_ERR);
4421  #else 
4422          detail::errHandler(default_error_, __CREATE_COMMAND_QUEUE_ERR);
4423  #endif 
4424          if (err != NULL) {
4425              *err = default_error_;
4426          }
4427          return default_;
4428      }
4429      static CommandQueue setDefault(const CommandQueue &default_queue)
4430      {
4431          std::call_once(default_initialized_, makeDefaultProvided, std::cref(default_queue));
4432          detail::errHandler(default_error_);
4433          return default_;
4434      }
4435      CommandQueue() { }
4436      explicit CommandQueue(const cl_command_queue& commandQueue, bool retainObject = false) : 
4437          detail::Wrapper<cl_type>(commandQueue, retainObject) { }
4438      CommandQueue& operator = (const cl_command_queue& rhs)
4439      {
4440          detail::Wrapper<cl_type>::operator=(rhs);
4441          return *this;
4442      }
4443      CommandQueue(const CommandQueue& queue) : detail::Wrapper<cl_type>(queue) {}
4444      CommandQueue& operator = (const CommandQueue &queue)
4445      {
4446          detail::Wrapper<cl_type>::operator=(queue);
4447          return *this;
4448      }
4449      CommandQueue(CommandQueue&& queue) CL_HPP_NOEXCEPT_ : detail::Wrapper<cl_type>(std::move(queue)) {}
4450      CommandQueue& operator = (CommandQueue &&queue)
4451      {
4452          detail::Wrapper<cl_type>::operator=(std::move(queue));
4453          return *this;
4454      }
4455      template <typename T>
4456      cl_int getInfo(cl_command_queue_info name, T* param) const
4457      {
4458          return detail::errHandler(
4459              detail::getInfo(
4460                  &::clGetCommandQueueInfo, object_, name, param),
4461                  __GET_COMMAND_QUEUE_INFO_ERR);
4462      }
4463      template <cl_int name> typename
4464      detail::param_traits<detail::cl_command_queue_info, name>::param_type
4465      getInfo(cl_int* err = NULL) const
4466      {
4467          typename detail::param_traits<
4468              detail::cl_command_queue_info, name>::param_type param;
4469          cl_int result = getInfo(name, &param);
4470          if (err != NULL) {
4471              *err = result;
4472          }
4473          return param;
4474      }
4475      cl_int enqueueReadBuffer(
4476          const Buffer& buffer,
4477          cl_bool blocking,
4478          size_type offset,
4479          size_type size,
4480          void* ptr,
4481          const vector<Event>* events = NULL,
4482          Event* event = NULL) const
4483      {
4484          cl_event tmp;
4485          cl_int err = detail::errHandler(
4486              ::clEnqueueReadBuffer(
4487                  object_, buffer(), blocking, offset, size,
4488                  ptr,
4489                  (events != NULL) ? (cl_uint) events->size() : 0,
4490                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4491                  (event != NULL) ? &tmp : NULL),
4492              __ENQUEUE_READ_BUFFER_ERR);
4493          if (event != NULL && err == CL_SUCCESS)
4494              *event = tmp;
4495          return err;
4496      }
4497      cl_int enqueueWriteBuffer(
4498          const Buffer& buffer,
4499          cl_bool blocking,
4500          size_type offset,
4501          size_type size,
4502          const void* ptr,
4503          const vector<Event>* events = NULL,
4504          Event* event = NULL) const
4505      {
4506          cl_event tmp;
4507          cl_int err = detail::errHandler(
4508              ::clEnqueueWriteBuffer(
4509                  object_, buffer(), blocking, offset, size,
4510                  ptr,
4511                  (events != NULL) ? (cl_uint) events->size() : 0,
4512                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4513                  (event != NULL) ? &tmp : NULL),
4514                  __ENQUEUE_WRITE_BUFFER_ERR);
4515          if (event != NULL && err == CL_SUCCESS)
4516              *event = tmp;
4517          return err;
4518      }
4519      cl_int enqueueCopyBuffer(
4520          const Buffer& src,
4521          const Buffer& dst,
4522          size_type src_offset,
4523          size_type dst_offset,
4524          size_type size,
4525          const vector<Event>* events = NULL,
4526          Event* event = NULL) const
4527      {
4528          cl_event tmp;
4529          cl_int err = detail::errHandler(
4530              ::clEnqueueCopyBuffer(
4531                  object_, src(), dst(), src_offset, dst_offset, size,
4532                  (events != NULL) ? (cl_uint) events->size() : 0,
4533                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4534                  (event != NULL) ? &tmp : NULL),
4535              __ENQEUE_COPY_BUFFER_ERR);
4536          if (event != NULL && err == CL_SUCCESS)
4537              *event = tmp;
4538          return err;
4539      }
4540      cl_int enqueueReadBufferRect(
4541          const Buffer& buffer,
4542          cl_bool blocking,
4543          const array<size_type, 3>& buffer_offset,
4544          const array<size_type, 3>& host_offset,
4545          const array<size_type, 3>& region,
4546          size_type buffer_row_pitch,
4547          size_type buffer_slice_pitch,
4548          size_type host_row_pitch,
4549          size_type host_slice_pitch,
4550          void *ptr,
4551          const vector<Event>* events = NULL,
4552          Event* event = NULL) const
4553      {
4554          cl_event tmp;
4555          cl_int err = detail::errHandler(
4556              ::clEnqueueReadBufferRect(
4557                  object_, 
4558                  buffer(), 
4559                  blocking,
4560                  buffer_offset.data(),
4561                  host_offset.data(),
4562                  region.data(),
4563                  buffer_row_pitch,
4564                  buffer_slice_pitch,
4565                  host_row_pitch,
4566                  host_slice_pitch,
4567                  ptr,
4568                  (events != NULL) ? (cl_uint) events->size() : 0,
4569                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4570                  (event != NULL) ? &tmp : NULL),
4571                  __ENQUEUE_READ_BUFFER_RECT_ERR);
4572          if (event != NULL && err == CL_SUCCESS)
4573              *event = tmp;
4574          return err;
4575      }
4576      cl_int enqueueWriteBufferRect(
4577          const Buffer& buffer,
4578          cl_bool blocking,
4579          const array<size_type, 3>& buffer_offset,
4580          const array<size_type, 3>& host_offset,
4581          const array<size_type, 3>& region,
4582          size_type buffer_row_pitch,
4583          size_type buffer_slice_pitch,
4584          size_type host_row_pitch,
4585          size_type host_slice_pitch,
4586          void *ptr,
4587          const vector<Event>* events = NULL,
4588          Event* event = NULL) const
4589      {
4590          cl_event tmp;
4591          cl_int err = detail::errHandler(
4592              ::clEnqueueWriteBufferRect(
4593                  object_, 
4594                  buffer(), 
4595                  blocking,
4596                  buffer_offset.data(),
4597                  host_offset.data(),
4598                  region.data(),
4599                  buffer_row_pitch,
4600                  buffer_slice_pitch,
4601                  host_row_pitch,
4602                  host_slice_pitch,
4603                  ptr,
4604                  (events != NULL) ? (cl_uint) events->size() : 0,
4605                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4606                  (event != NULL) ? &tmp : NULL),
4607                  __ENQUEUE_WRITE_BUFFER_RECT_ERR);
4608          if (event != NULL && err == CL_SUCCESS)
4609              *event = tmp;
4610          return err;
4611      }
4612      cl_int enqueueCopyBufferRect(
4613          const Buffer& src,
4614          const Buffer& dst,
4615          const array<size_type, 3>& src_origin,
4616          const array<size_type, 3>& dst_origin,
4617          const array<size_type, 3>& region,
4618          size_type src_row_pitch,
4619          size_type src_slice_pitch,
4620          size_type dst_row_pitch,
4621          size_type dst_slice_pitch,
4622          const vector<Event>* events = NULL,
4623          Event* event = NULL) const
4624      {
4625          cl_event tmp;
4626          cl_int err = detail::errHandler(
4627              ::clEnqueueCopyBufferRect(
4628                  object_, 
4629                  src(), 
4630                  dst(), 
4631                  src_origin.data(),
4632                  dst_origin.data(),
4633                  region.data(),
4634                  src_row_pitch,
4635                  src_slice_pitch,
4636                  dst_row_pitch,
4637                  dst_slice_pitch,
4638                  (events != NULL) ? (cl_uint) events->size() : 0,
4639                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4640                  (event != NULL) ? &tmp : NULL),
4641              __ENQEUE_COPY_BUFFER_RECT_ERR);
4642          if (event != NULL && err == CL_SUCCESS)
4643              *event = tmp;
4644          return err;
4645      }
4646  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
4647      template<typename PatternType>
4648      cl_int enqueueFillBuffer(
4649          const Buffer& buffer,
4650          PatternType pattern,
4651          size_type offset,
4652          size_type size,
4653          const vector<Event>* events = NULL,
4654          Event* event = NULL) const
4655      {
4656          cl_event tmp;
4657          cl_int err = detail::errHandler(
4658              ::clEnqueueFillBuffer(
4659                  object_, 
4660                  buffer(),
4661                  static_cast<void*>(&pattern),
4662                  sizeof(PatternType), 
4663                  offset, 
4664                  size,
4665                  (events != NULL) ? (cl_uint) events->size() : 0,
4666                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4667                  (event != NULL) ? &tmp : NULL),
4668                  __ENQUEUE_FILL_BUFFER_ERR);
4669          if (event != NULL && err == CL_SUCCESS)
4670              *event = tmp;
4671          return err;
4672      }
4673  #endif 
4674      cl_int enqueueReadImage(
4675          const Image& image,
4676          cl_bool blocking,
4677          const array<size_type, 3>& origin,
4678          const array<size_type, 3>& region,
4679          size_type row_pitch,
4680          size_type slice_pitch,
4681          void* ptr,
4682          const vector<Event>* events = NULL,
4683          Event* event = NULL) const
4684      {
4685          cl_event tmp;
4686          cl_int err = detail::errHandler(
4687              ::clEnqueueReadImage(
4688                  object_, 
4689                  image(), 
4690                  blocking, 
4691                  origin.data(),
4692                  region.data(), 
4693                  row_pitch, 
4694                  slice_pitch, 
4695                  ptr,
4696                  (events != NULL) ? (cl_uint) events->size() : 0,
4697                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4698                  (event != NULL) ? &tmp : NULL),
4699              __ENQUEUE_READ_IMAGE_ERR);
4700          if (event != NULL && err == CL_SUCCESS)
4701              *event = tmp;
4702          return err;
4703      }
4704      cl_int enqueueWriteImage(
4705          const Image& image,
4706          cl_bool blocking,
4707          const array<size_type, 3>& origin,
4708          const array<size_type, 3>& region,
4709          size_type row_pitch,
4710          size_type slice_pitch,
4711          void* ptr,
4712          const vector<Event>* events = NULL,
4713          Event* event = NULL) const
4714      {
4715          cl_event tmp;
4716          cl_int err = detail::errHandler(
4717              ::clEnqueueWriteImage(
4718                  object_, 
4719                  image(), 
4720                  blocking, 
4721                  origin.data(),
4722                  region.data(), 
4723                  row_pitch, 
4724                  slice_pitch, 
4725                  ptr,
4726                  (events != NULL) ? (cl_uint) events->size() : 0,
4727                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4728                  (event != NULL) ? &tmp : NULL),
4729              __ENQUEUE_WRITE_IMAGE_ERR);
4730          if (event != NULL && err == CL_SUCCESS)
4731              *event = tmp;
4732          return err;
4733      }
4734      cl_int enqueueCopyImage(
4735          const Image& src,
4736          const Image& dst,
4737          const array<size_type, 3>& src_origin,
4738          const array<size_type, 3>& dst_origin,
4739          const array<size_type, 3>& region,
4740          const vector<Event>* events = NULL,
4741          Event* event = NULL) const
4742      {
4743          cl_event tmp;
4744          cl_int err = detail::errHandler(
4745              ::clEnqueueCopyImage(
4746                  object_, 
4747                  src(), 
4748                  dst(), 
4749                  src_origin.data(),
4750                  dst_origin.data(), 
4751                  region.data(),
4752                  (events != NULL) ? (cl_uint) events->size() : 0,
4753                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4754                  (event != NULL) ? &tmp : NULL),
4755              __ENQUEUE_COPY_IMAGE_ERR);
4756          if (event != NULL && err == CL_SUCCESS)
4757              *event = tmp;
4758          return err;
4759      }
4760  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
4761      cl_int enqueueFillImage(
4762          const Image& image,
4763          cl_float4 fillColor,
4764          const array<size_type, 3>& origin,
4765          const array<size_type, 3>& region,
4766          const vector<Event>* events = NULL,
4767          Event* event = NULL) const
4768      {
4769          cl_event tmp;
4770          cl_int err = detail::errHandler(
4771              ::clEnqueueFillImage(
4772                  object_, 
4773                  image(),
4774                  static_cast<void*>(&fillColor), 
4775                  origin.data(),
4776                  region.data(),
4777                  (events != NULL) ? (cl_uint) events->size() : 0,
4778                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4779                  (event != NULL) ? &tmp : NULL),
4780                  __ENQUEUE_FILL_IMAGE_ERR);
4781          if (event != NULL && err == CL_SUCCESS)
4782              *event = tmp;
4783          return err;
4784      }
4785      cl_int enqueueFillImage(
4786          const Image& image,
4787          cl_int4 fillColor,
4788          const array<size_type, 3>& origin,
4789          const array<size_type, 3>& region,
4790          const vector<Event>* events = NULL,
4791          Event* event = NULL) const
4792      {
4793          cl_event tmp;
4794          cl_int err = detail::errHandler(
4795              ::clEnqueueFillImage(
4796                  object_, 
4797                  image(),
4798                  static_cast<void*>(&fillColor), 
4799                  origin.data(),
4800                  region.data(),
4801                  (events != NULL) ? (cl_uint) events->size() : 0,
4802                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4803                  (event != NULL) ? &tmp : NULL),
4804                  __ENQUEUE_FILL_IMAGE_ERR);
4805          if (event != NULL && err == CL_SUCCESS)
4806              *event = tmp;
4807          return err;
4808      }
4809      cl_int enqueueFillImage(
4810          const Image& image,
4811          cl_uint4 fillColor,
4812          const array<size_type, 3>& origin,
4813          const array<size_type, 3>& region,
4814          const vector<Event>* events = NULL,
4815          Event* event = NULL) const
4816      {
4817          cl_event tmp;
4818          cl_int err = detail::errHandler(
4819              ::clEnqueueFillImage(
4820                  object_, 
4821                  image(),
4822                  static_cast<void*>(&fillColor), 
4823                  origin.data(),
4824                  region.data(),
4825                  (events != NULL) ? (cl_uint) events->size() : 0,
4826                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4827                  (event != NULL) ? &tmp : NULL),
4828                  __ENQUEUE_FILL_IMAGE_ERR);
4829          if (event != NULL && err == CL_SUCCESS)
4830              *event = tmp;
4831          return err;
4832      }
4833  #endif 
4834      cl_int enqueueCopyImageToBuffer(
4835          const Image& src,
4836          const Buffer& dst,
4837          const array<size_type, 3>& src_origin,
4838          const array<size_type, 3>& region,
4839          size_type dst_offset,
4840          const vector<Event>* events = NULL,
4841          Event* event = NULL) const
4842      {
4843          cl_event tmp;
4844          cl_int err = detail::errHandler(
4845              ::clEnqueueCopyImageToBuffer(
4846                  object_, 
4847                  src(), 
4848                  dst(), 
4849                  src_origin.data(),
4850                  region.data(), 
4851                  dst_offset,
4852                  (events != NULL) ? (cl_uint) events->size() : 0,
4853                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4854                  (event != NULL) ? &tmp : NULL),
4855              __ENQUEUE_COPY_IMAGE_TO_BUFFER_ERR);
4856          if (event != NULL && err == CL_SUCCESS)
4857              *event = tmp;
4858          return err;
4859      }
4860      cl_int enqueueCopyBufferToImage(
4861          const Buffer& src,
4862          const Image& dst,
4863          size_type src_offset,
4864          const array<size_type, 3>& dst_origin,
4865          const array<size_type, 3>& region,
4866          const vector<Event>* events = NULL,
4867          Event* event = NULL) const
4868      {
4869          cl_event tmp;
4870          cl_int err = detail::errHandler(
4871              ::clEnqueueCopyBufferToImage(
4872                  object_, 
4873                  src(), 
4874                  dst(), 
4875                  src_offset,
4876                  dst_origin.data(), 
4877                  region.data(),
4878                  (events != NULL) ? (cl_uint) events->size() : 0,
4879                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4880                  (event != NULL) ? &tmp : NULL),
4881              __ENQUEUE_COPY_BUFFER_TO_IMAGE_ERR);
4882          if (event != NULL && err == CL_SUCCESS)
4883              *event = tmp;
4884          return err;
4885      }
4886      void* enqueueMapBuffer(
4887          const Buffer& buffer,
4888          cl_bool blocking,
4889          cl_map_flags flags,
4890          size_type offset,
4891          size_type size,
4892          const vector<Event>* events = NULL,
4893          Event* event = NULL,
4894          cl_int* err = NULL) const
4895      {
4896          cl_event tmp;
4897          cl_int error;
4898          void * result = ::clEnqueueMapBuffer(
4899              object_, buffer(), blocking, flags, offset, size,
4900              (events != NULL) ? (cl_uint) events->size() : 0,
4901              (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4902              (event != NULL) ? &tmp : NULL,
4903              &error);
4904          detail::errHandler(error, __ENQUEUE_MAP_BUFFER_ERR);
4905          if (err != NULL) {
4906              *err = error;
4907          }
4908          if (event != NULL && error == CL_SUCCESS)
4909              *event = tmp;
4910          return result;
4911      }
4912      void* enqueueMapImage(
4913          const Image& buffer,
4914          cl_bool blocking,
4915          cl_map_flags flags,
4916          const array<size_type, 3>& origin,
4917          const array<size_type, 3>& region,
4918          size_type * row_pitch,
4919          size_type * slice_pitch,
4920          const vector<Event>* events = NULL,
4921          Event* event = NULL,
4922          cl_int* err = NULL) const
4923      {
4924          cl_event tmp;
4925          cl_int error;
4926          void * result = ::clEnqueueMapImage(
4927              object_, buffer(), blocking, flags,
4928              origin.data(), 
4929              region.data(),
4930              row_pitch, slice_pitch,
4931              (events != NULL) ? (cl_uint) events->size() : 0,
4932              (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4933              (event != NULL) ? &tmp : NULL,
4934              &error);
4935          detail::errHandler(error, __ENQUEUE_MAP_IMAGE_ERR);
4936          if (err != NULL) {
4937                *err = error;
4938          }
4939          if (event != NULL && error == CL_SUCCESS)
4940              *event = tmp;
4941          return result;
4942      }
4943  #if CL_HPP_TARGET_OPENCL_VERSION >= 200
4944      template<typename T>
4945      cl_int enqueueMapSVM(
4946          T* ptr,
4947          cl_bool blocking,
4948          cl_map_flags flags,
4949          size_type size,
4950          const vector<Event>* events = NULL,
4951          Event* event = NULL) const
4952      {
4953          cl_event tmp;
4954          cl_int err = detail::errHandler(::clEnqueueSVMMap(
4955              object_, blocking, flags, static_cast<void*>(ptr), size,
4956              (events != NULL) ? (cl_uint)events->size() : 0,
4957              (events != NULL && events->size() > 0) ? (cl_event*)&events->front() : NULL,
4958              (event != NULL) ? &tmp : NULL),
4959              __ENQUEUE_MAP_BUFFER_ERR);
4960          if (event != NULL && err == CL_SUCCESS)
4961              *event = tmp;
4962          return err;
4963      }
4964      template<typename T, class D>
4965      cl_int enqueueMapSVM(
4966          cl::pointer<T, D> &ptr,
4967          cl_bool blocking,
4968          cl_map_flags flags,
4969          size_type size,
4970          const vector<Event>* events = NULL,
4971          Event* event = NULL) const
4972      {
4973          cl_event tmp;
4974          cl_int err = detail::errHandler(::clEnqueueSVMMap(
4975              object_, blocking, flags, static_cast<void*>(ptr.get()), size,
4976              (events != NULL) ? (cl_uint)events->size() : 0,
4977              (events != NULL && events->size() > 0) ? (cl_event*)&events->front() : NULL,
4978              (event != NULL) ? &tmp : NULL),
4979              __ENQUEUE_MAP_BUFFER_ERR);
4980          if (event != NULL && err == CL_SUCCESS)
4981              *event = tmp;
4982          return err;
4983      }
4984      template<typename T, class Alloc>
4985      cl_int enqueueMapSVM(
4986          cl::vector<T, Alloc> &container,
4987          cl_bool blocking,
4988          cl_map_flags flags,
4989          const vector<Event>* events = NULL,
4990          Event* event = NULL) const
4991      {
4992          cl_event tmp;
4993          cl_int err = detail::errHandler(::clEnqueueSVMMap(
4994              object_, blocking, flags, static_cast<void*>(container.data()), container.size(),
4995              (events != NULL) ? (cl_uint)events->size() : 0,
4996              (events != NULL && events->size() > 0) ? (cl_event*)&events->front() : NULL,
4997              (event != NULL) ? &tmp : NULL),
4998              __ENQUEUE_MAP_BUFFER_ERR);
4999          if (event != NULL && err == CL_SUCCESS)
5000              *event = tmp;
5001          return err;
5002      }
5003  #endif 
5004      cl_int enqueueUnmapMemObject(
5005          const Memory& memory,
5006          void* mapped_ptr,
5007          const vector<Event>* events = NULL,
5008          Event* event = NULL) const
5009      {
5010          cl_event tmp;
5011          cl_int err = detail::errHandler(
5012              ::clEnqueueUnmapMemObject(
5013                  object_, memory(), mapped_ptr,
5014                  (events != NULL) ? (cl_uint) events->size() : 0,
5015                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
5016                  (event != NULL) ? &tmp : NULL),
5017              __ENQUEUE_UNMAP_MEM_OBJECT_ERR);
5018          if (event != NULL && err == CL_SUCCESS)
5019              *event = tmp;
5020          return err;
5021      }
5022  #if CL_HPP_TARGET_OPENCL_VERSION >= 200
5023      template<typename T>
5024      cl_int enqueueUnmapSVM(
5025          T* ptr,
5026          const vector<Event>* events = NULL,
5027          Event* event = NULL) const
5028      {
5029          cl_event tmp;
5030          cl_int err = detail::errHandler(
5031              ::clEnqueueSVMUnmap(
5032              object_, static_cast<void*>(ptr),
5033              (events != NULL) ? (cl_uint)events->size() : 0,
5034              (events != NULL && events->size() > 0) ? (cl_event*)&events->front() : NULL,
5035              (event != NULL) ? &tmp : NULL),
5036              __ENQUEUE_UNMAP_MEM_OBJECT_ERR);
5037          if (event != NULL && err == CL_SUCCESS)
5038              *event = tmp;
5039          return err;
5040      }
5041      template<typename T, class D>
5042      cl_int enqueueUnmapSVM(
5043          cl::pointer<T, D> &ptr,
5044          const vector<Event>* events = NULL,
5045          Event* event = NULL) const
5046      {
5047          cl_event tmp;
5048          cl_int err = detail::errHandler(
5049              ::clEnqueueSVMUnmap(
5050              object_, static_cast<void*>(ptr.get()),
5051              (events != NULL) ? (cl_uint)events->size() : 0,
5052              (events != NULL && events->size() > 0) ? (cl_event*)&events->front() : NULL,
5053              (event != NULL) ? &tmp : NULL),
5054              __ENQUEUE_UNMAP_MEM_OBJECT_ERR);
5055          if (event != NULL && err == CL_SUCCESS)
5056              *event = tmp;
5057          return err;
5058      }
5059      template<typename T, class Alloc>
5060      cl_int enqueueUnmapSVM(
5061          cl::vector<T, Alloc> &container,
5062          const vector<Event>* events = NULL,
5063          Event* event = NULL) const
5064      {
5065          cl_event tmp;
5066          cl_int err = detail::errHandler(
5067              ::clEnqueueSVMUnmap(
5068              object_, static_cast<void*>(container.data()),
5069              (events != NULL) ? (cl_uint)events->size() : 0,
5070              (events != NULL && events->size() > 0) ? (cl_event*)&events->front() : NULL,
5071              (event != NULL) ? &tmp : NULL),
5072              __ENQUEUE_UNMAP_MEM_OBJECT_ERR);
5073          if (event != NULL && err == CL_SUCCESS)
5074              *event = tmp;
5075          return err;
5076      }
5077  #endif 
5078  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
5079      cl_int enqueueMarkerWithWaitList(
5080          const vector<Event> *events = 0,
5081          Event *event = 0)
5082      {
5083          cl_event tmp;
5084          cl_int err = detail::errHandler(
5085              ::clEnqueueMarkerWithWaitList(
5086                  object_,
5087                  (events != NULL) ? (cl_uint) events->size() : 0,
5088                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
5089                  (event != NULL) ? &tmp : NULL),
5090              __ENQUEUE_MARKER_WAIT_LIST_ERR);
5091          if (event != NULL && err == CL_SUCCESS)
5092              *event = tmp;
5093          return err;
5094      }
5095      cl_int enqueueBarrierWithWaitList(
5096          const vector<Event> *events = 0,
5097          Event *event = 0)
5098      {
5099          cl_event tmp;
5100          cl_int err = detail::errHandler(
5101              ::clEnqueueBarrierWithWaitList(
5102                  object_,
5103                  (events != NULL) ? (cl_uint) events->size() : 0,
5104                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
5105                  (event != NULL) ? &tmp : NULL),
5106              __ENQUEUE_BARRIER_WAIT_LIST_ERR);
5107          if (event != NULL && err == CL_SUCCESS)
5108              *event = tmp;
5109          return err;
5110      }
5111      cl_int enqueueMigrateMemObjects(
5112          const vector<Memory> &memObjects,
5113          cl_mem_migration_flags flags,
5114          const vector<Event>* events = NULL,
5115          Event* event = NULL
5116          )
5117      {
5118          cl_event tmp;
5119          vector<cl_mem> localMemObjects(memObjects.size());
5120          for( int i = 0; i < (int)memObjects.size(); ++i ) {
5121              localMemObjects[i] = memObjects[i]();
5122          }
5123          cl_int err = detail::errHandler(
5124              ::clEnqueueMigrateMemObjects(
5125                  object_, 
5126                  (cl_uint)memObjects.size(), 
5127                  localMemObjects.data(),
5128                  flags,
5129                  (events != NULL) ? (cl_uint) events->size() : 0,
5130                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
5131                  (event != NULL) ? &tmp : NULL),
5132              __ENQUEUE_UNMAP_MEM_OBJECT_ERR);
5133          if (event != NULL && err == CL_SUCCESS)
5134              *event = tmp;
5135          return err;
5136      }
5137  #endif 
5138      cl_int enqueueNDRangeKernel(
5139          const Kernel& kernel,
5140          const NDRange& offset,
5141          const NDRange& global,
5142          const NDRange& local = NullRange,
5143          const vector<Event>* events = NULL,
5144          Event* event = NULL) const
5145      {
5146          cl_event tmp;
5147          cl_int err = detail::errHandler(
5148              ::clEnqueueNDRangeKernel(
5149                  object_, kernel(), (cl_uint) global.dimensions(),
5150                  offset.dimensions() != 0 ? (const size_type*) offset : NULL,
5151                  (const size_type*) global,
5152                  local.dimensions() != 0 ? (const size_type*) local : NULL,
5153                  (events != NULL) ? (cl_uint) events->size() : 0,
5154                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
5155                  (event != NULL) ? &tmp : NULL),
5156              __ENQUEUE_NDRANGE_KERNEL_ERR);
5157          if (event != NULL && err == CL_SUCCESS)
5158              *event = tmp;
5159          return err;
5160      }
5161  #if defined(CL_USE_DEPRECATED_OPENCL_1_2_APIS)
5162      CL_EXT_PREFIX__VERSION_1_2_DEPRECATED cl_int enqueueTask(
5163          const Kernel& kernel,
5164          const vector<Event>* events = NULL,
5165          Event* event = NULL) CL_EXT_SUFFIX__VERSION_1_2_DEPRECATED const
5166      {
5167          cl_event tmp;
5168          cl_int err = detail::errHandler(
5169              ::clEnqueueTask(
5170                  object_, kernel(),
5171                  (events != NULL) ? (cl_uint) events->size() : 0,
5172                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
5173                  (event != NULL) ? &tmp : NULL),
5174              __ENQUEUE_TASK_ERR);
5175          if (event != NULL && err == CL_SUCCESS)
5176              *event = tmp;
5177          return err;
5178      }
5179  #endif 
5180      cl_int enqueueNativeKernel(
5181          void (CL_CALLBACK *userFptr)(void *),
5182          std::pair<void*, size_type> args,
5183          const vector<Memory>* mem_objects = NULL,
5184          const vector<const void*>* mem_locs = NULL,
5185          const vector<Event>* events = NULL,
5186          Event* event = NULL) const
5187      {
5188          size_type elements = 0;
5189          if (mem_objects != NULL) {
5190              elements = mem_objects->size();
5191          }
5192          vector<cl_mem> mems(elements);
5193          for (unsigned int i = 0; i < elements; i++) {
5194              mems[i] = ((*mem_objects)[i])();
5195          }
5196          cl_event tmp;
5197          cl_int err = detail::errHandler(
5198              ::clEnqueueNativeKernel(
5199                  object_, userFptr, args.first, args.second,
5200                  (mem_objects != NULL) ? (cl_uint) mem_objects->size() : 0,
5201                  mems.data(),
5202                  (mem_locs != NULL && mem_locs->size() > 0) ? (const void **) &mem_locs->front() : NULL,
5203                  (events != NULL) ? (cl_uint) events->size() : 0,
5204                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
5205                  (event != NULL) ? &tmp : NULL),
5206              __ENQUEUE_NATIVE_KERNEL);
5207          if (event != NULL && err == CL_SUCCESS)
5208              *event = tmp;
5209          return err;
5210      }
5211  #if defined(CL_USE_DEPRECATED_OPENCL_1_1_APIS)
5212      CL_EXT_PREFIX__VERSION_1_1_DEPRECATED 
5213      cl_int enqueueMarker(Event* event = NULL) const CL_EXT_SUFFIX__VERSION_1_1_DEPRECATED
5214      {
5215          cl_event tmp;
5216          cl_int err = detail::errHandler(
5217              ::clEnqueueMarker(
5218                  object_, 
5219                  (event != NULL) ? &tmp : NULL),
5220              __ENQUEUE_MARKER_ERR);
5221          if (event != NULL && err == CL_SUCCESS)
5222              *event = tmp;
5223          return err;
5224      }
5225      CL_EXT_PREFIX__VERSION_1_1_DEPRECATED
5226      cl_int enqueueWaitForEvents(const vector<Event>& events) const CL_EXT_SUFFIX__VERSION_1_1_DEPRECATED
5227      {
5228          return detail::errHandler(
5229              ::clEnqueueWaitForEvents(
5230                  object_,
5231                  (cl_uint) events.size(),
5232                  events.size() > 0 ? (const cl_event*) &events.front() : NULL),
5233              __ENQUEUE_WAIT_FOR_EVENTS_ERR);
5234      }
5235  #endif 
5236      cl_int enqueueAcquireGLObjects(
5237           const vector<Memory>* mem_objects = NULL,
5238           const vector<Event>* events = NULL,
5239           Event* event = NULL) const
5240       {
5241          cl_event tmp;
5242          cl_int err = detail::errHandler(
5243               ::clEnqueueAcquireGLObjects(
5244                   object_,
5245                   (mem_objects != NULL) ? (cl_uint) mem_objects->size() : 0,
5246                   (mem_objects != NULL && mem_objects->size() > 0) ? (const cl_mem *) &mem_objects->front(): NULL,
5247                   (events != NULL) ? (cl_uint) events->size() : 0,
5248                   (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
5249                   (event != NULL) ? &tmp : NULL),
5250               __ENQUEUE_ACQUIRE_GL_ERR);
5251          if (event != NULL && err == CL_SUCCESS)
5252              *event = tmp;
5253          return err;
5254       }
5255      cl_int enqueueReleaseGLObjects(
5256           const vector<Memory>* mem_objects = NULL,
5257           const vector<Event>* events = NULL,
5258           Event* event = NULL) const
5259       {
5260          cl_event tmp;
5261          cl_int err = detail::errHandler(
5262               ::clEnqueueReleaseGLObjects(
5263                   object_,
5264                   (mem_objects != NULL) ? (cl_uint) mem_objects->size() : 0,
5265                   (mem_objects != NULL && mem_objects->size() > 0) ? (const cl_mem *) &mem_objects->front(): NULL,
5266                   (events != NULL) ? (cl_uint) events->size() : 0,
5267                   (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
5268                   (event != NULL) ? &tmp : NULL),
5269               __ENQUEUE_RELEASE_GL_ERR);
5270          if (event != NULL && err == CL_SUCCESS)
5271              *event = tmp;
5272          return err;
5273       }
5274  #if defined (CL_HPP_USE_DX_INTEROP)
5275  typedef CL_API_ENTRY cl_int (CL_API_CALL *PFN_clEnqueueAcquireD3D10ObjectsKHR)(
5276      cl_command_queue command_queue, cl_uint num_objects,
5277      const cl_mem* mem_objects, cl_uint num_events_in_wait_list,
5278      const cl_event* event_wait_list, cl_event* event);
5279  typedef CL_API_ENTRY cl_int (CL_API_CALL *PFN_clEnqueueReleaseD3D10ObjectsKHR)(
5280      cl_command_queue command_queue, cl_uint num_objects,
5281      const cl_mem* mem_objects,  cl_uint num_events_in_wait_list,
5282      const cl_event* event_wait_list, cl_event* event);
5283      cl_int enqueueAcquireD3D10Objects(
5284           const vector<Memory>* mem_objects = NULL,
5285           const vector<Event>* events = NULL,
5286           Event* event = NULL) const
5287      {
5288          static PFN_clEnqueueAcquireD3D10ObjectsKHR pfn_clEnqueueAcquireD3D10ObjectsKHR = NULL;
5289  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
5290          cl_context context = getInfo<CL_QUEUE_CONTEXT>();
5291          cl::Device device(getInfo<CL_QUEUE_DEVICE>());
5292          cl_platform_id platform = device.getInfo<CL_DEVICE_PLATFORM>();
5293          CL_HPP_INIT_CL_EXT_FCN_PTR_PLATFORM_(platform, clEnqueueAcquireD3D10ObjectsKHR);
5294  #endif
5295  #if CL_HPP_TARGET_OPENCL_VERSION >= 110
5296          CL_HPP_INIT_CL_EXT_FCN_PTR_(clEnqueueAcquireD3D10ObjectsKHR);
5297  #endif
5298          cl_event tmp;
5299          cl_int err = detail::errHandler(
5300               pfn_clEnqueueAcquireD3D10ObjectsKHR(
5301                   object_,
5302                   (mem_objects != NULL) ? (cl_uint) mem_objects->size() : 0,
5303                   (mem_objects != NULL && mem_objects->size() > 0) ? (const cl_mem *) &mem_objects->front(): NULL,
5304                   (events != NULL) ? (cl_uint) events->size() : 0,
5305                   (events != NULL) ? (cl_event*) &events->front() : NULL,
5306                   (event != NULL) ? &tmp : NULL),
5307               __ENQUEUE_ACQUIRE_GL_ERR);
5308          if (event != NULL && err == CL_SUCCESS)
5309              *event = tmp;
5310          return err;
5311       }
5312      cl_int enqueueReleaseD3D10Objects(
5313           const vector<Memory>* mem_objects = NULL,
5314           const vector<Event>* events = NULL,
5315           Event* event = NULL) const
5316      {
5317          static PFN_clEnqueueReleaseD3D10ObjectsKHR pfn_clEnqueueReleaseD3D10ObjectsKHR = NULL;
5318  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
5319          cl_context context = getInfo<CL_QUEUE_CONTEXT>();
5320          cl::Device device(getInfo<CL_QUEUE_DEVICE>());
5321          cl_platform_id platform = device.getInfo<CL_DEVICE_PLATFORM>();
5322          CL_HPP_INIT_CL_EXT_FCN_PTR_PLATFORM_(platform, clEnqueueReleaseD3D10ObjectsKHR);
5323  #endif 
5324  #if CL_HPP_TARGET_OPENCL_VERSION >= 110
5325          CL_HPP_INIT_CL_EXT_FCN_PTR_(clEnqueueReleaseD3D10ObjectsKHR);
5326  #endif 
5327          cl_event tmp;
5328          cl_int err = detail::errHandler(
5329              pfn_clEnqueueReleaseD3D10ObjectsKHR(
5330                  object_,
5331                  (mem_objects != NULL) ? (cl_uint) mem_objects->size() : 0,
5332                  (mem_objects != NULL && mem_objects->size() > 0) ? (const cl_mem *) &mem_objects->front(): NULL,
5333                  (events != NULL) ? (cl_uint) events->size() : 0,
5334                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
5335                  (event != NULL) ? &tmp : NULL),
5336              __ENQUEUE_RELEASE_GL_ERR);
5337          if (event != NULL && err == CL_SUCCESS)
5338              *event = tmp;
5339          return err;
5340      }
5341  #endif
5342  #if defined(CL_USE_DEPRECATED_OPENCL_1_1_APIS)
5343      CL_EXT_PREFIX__VERSION_1_1_DEPRECATED
5344      cl_int enqueueBarrier() const CL_EXT_SUFFIX__VERSION_1_1_DEPRECATED
5345      {
5346          return detail::errHandler(
5347              ::clEnqueueBarrier(object_),
5348              __ENQUEUE_BARRIER_ERR);
5349      }
5350  #endif 
5351      cl_int flush() const
5352      {
5353          return detail::errHandler(::clFlush(object_), __FLUSH_ERR);
5354      }
5355      cl_int finish() const
5356      {
5357          return detail::errHandler(::clFinish(object_), __FINISH_ERR);
5358      }
5359  }; 
5360  CL_HPP_DEFINE_STATIC_MEMBER_ std::once_flag CommandQueue::default_initialized_;
5361  CL_HPP_DEFINE_STATIC_MEMBER_ CommandQueue CommandQueue::default_;
5362  CL_HPP_DEFINE_STATIC_MEMBER_ cl_int CommandQueue::default_error_ = CL_SUCCESS;
5363  #if CL_HPP_TARGET_OPENCL_VERSION >= 200
5364  enum class DeviceQueueProperties : cl_command_queue_properties
5365  {
5366      None = 0,
5367      Profiling = CL_QUEUE_PROFILING_ENABLE,
5368  };
5369  DeviceQueueProperties  operator|(DeviceQueueProperties  lhs, DeviceQueueProperties  rhs)
5370  {
5371      return static_cast<DeviceQueueProperties>(static_cast<cl_command_queue_properties>(lhs) | static_cast<cl_command_queue_properties>(rhs));
5372  }
5373  class DeviceCommandQueue : public detail::Wrapper<cl_command_queue>
5374  {
5375  public:
5376      DeviceCommandQueue() { }
5377      DeviceCommandQueue(DeviceQueueProperties properties, cl_int* err = NULL)
5378      {
5379          cl_int error;
5380          cl::Context context = cl::Context::getDefault();
5381          cl::Device device = cl::Device::getDefault();
5382          cl_command_queue_properties mergedProperties =
5383              CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE | CL_QUEUE_ON_DEVICE | static_cast<cl_command_queue_properties>(properties);
5384          cl_queue_properties queue_properties[] = {
5385              CL_QUEUE_PROPERTIES, mergedProperties, 0 };
5386          object_ = ::clCreateCommandQueueWithProperties(
5387              context(), device(), queue_properties, &error);
5388          detail::errHandler(error, __CREATE_COMMAND_QUEUE_WITH_PROPERTIES_ERR);
5389          if (err != NULL) {
5390              *err = error;
5391          }
5392      }
5393      DeviceCommandQueue(
5394          const Context& context,
5395          const Device& device,
5396          DeviceQueueProperties properties = DeviceQueueProperties::None,
5397          cl_int* err = NULL)
5398      {
5399          cl_int error;
5400          cl_command_queue_properties mergedProperties =
5401              CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE | CL_QUEUE_ON_DEVICE | static_cast<cl_command_queue_properties>(properties);
5402          cl_queue_properties queue_properties[] = {
5403              CL_QUEUE_PROPERTIES, mergedProperties, 0 };
5404          object_ = ::clCreateCommandQueueWithProperties(
5405              context(), device(), queue_properties, &error);
5406          detail::errHandler(error, __CREATE_COMMAND_QUEUE_WITH_PROPERTIES_ERR);
5407          if (err != NULL) {
5408              *err = error;
5409          }
5410      }
5411      DeviceCommandQueue(
5412          const Context& context,
5413          const Device& device,
5414          cl_uint queueSize,
5415          DeviceQueueProperties properties = DeviceQueueProperties::None,
5416          cl_int* err = NULL)
5417      {
5418          cl_int error;
5419          cl_command_queue_properties mergedProperties =
5420              CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE | CL_QUEUE_ON_DEVICE | static_cast<cl_command_queue_properties>(properties);
5421          cl_queue_properties queue_properties[] = {
5422              CL_QUEUE_PROPERTIES, mergedProperties,
5423              CL_QUEUE_SIZE, queueSize, 
5424              0 };
5425          object_ = ::clCreateCommandQueueWithProperties(
5426              context(), device(), queue_properties, &error);
5427          detail::errHandler(error, __CREATE_COMMAND_QUEUE_WITH_PROPERTIES_ERR);
5428          if (err != NULL) {
5429              *err = error;
5430          }
5431      }
5432      explicit DeviceCommandQueue(const cl_command_queue& commandQueue, bool retainObject = false) :
5433          detail::Wrapper<cl_type>(commandQueue, retainObject) { }
5434      DeviceCommandQueue& operator = (const cl_command_queue& rhs)
5435      {
5436          detail::Wrapper<cl_type>::operator=(rhs);
5437          return *this;
5438      }
5439      DeviceCommandQueue(const DeviceCommandQueue& queue) : detail::Wrapper<cl_type>(queue) {}
5440      DeviceCommandQueue& operator = (const DeviceCommandQueue &queue)
5441      {
5442          detail::Wrapper<cl_type>::operator=(queue);
5443          return *this;
5444      }
5445      DeviceCommandQueue(DeviceCommandQueue&& queue) CL_HPP_NOEXCEPT_ : detail::Wrapper<cl_type>(std::move(queue)) {}
5446      DeviceCommandQueue& operator = (DeviceCommandQueue &&queue)
5447      {
5448          detail::Wrapper<cl_type>::operator=(std::move(queue));
5449          return *this;
5450      }
5451      template <typename T>
5452      cl_int getInfo(cl_command_queue_info name, T* param) const
5453      {
5454          return detail::errHandler(
5455              detail::getInfo(
5456              &::clGetCommandQueueInfo, object_, name, param),
5457              __GET_COMMAND_QUEUE_INFO_ERR);
5458      }
5459      template <cl_int name> typename
5460          detail::param_traits<detail::cl_command_queue_info, name>::param_type
5461          getInfo(cl_int* err = NULL) const
5462      {
5463          typename detail::param_traits<
5464              detail::cl_command_queue_info, name>::param_type param;
5465          cl_int result = getInfo(name, &param);
5466          if (err != NULL) {
5467              *err = result;
5468          }
5469          return param;
5470      }
5471      static DeviceCommandQueue makeDefault(
5472          cl_int *err = nullptr)
5473      {
5474          cl_int error;
5475          cl::Context context = cl::Context::getDefault();
5476          cl::Device device = cl::Device::getDefault();
5477          cl_command_queue_properties properties =
5478              CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE | CL_QUEUE_ON_DEVICE | CL_QUEUE_ON_DEVICE_DEFAULT;
5479          cl_queue_properties queue_properties[] = {
5480              CL_QUEUE_PROPERTIES, properties,
5481              0 };
5482          DeviceCommandQueue deviceQueue(
5483              ::clCreateCommandQueueWithProperties(
5484              context(), device(), queue_properties, &error));
5485          detail::errHandler(error, __CREATE_COMMAND_QUEUE_WITH_PROPERTIES_ERR);
5486          if (err != NULL) {
5487              *err = error;
5488          }
5489          return deviceQueue;
5490      }
5491      static DeviceCommandQueue makeDefault(
5492          const Context &context, const Device &device, cl_int *err = nullptr)
5493      {
5494          cl_int error;
5495          cl_command_queue_properties properties =
5496              CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE | CL_QUEUE_ON_DEVICE | CL_QUEUE_ON_DEVICE_DEFAULT;
5497          cl_queue_properties queue_properties[] = {
5498              CL_QUEUE_PROPERTIES, properties,
5499              0 };
5500          DeviceCommandQueue deviceQueue(
5501              ::clCreateCommandQueueWithProperties(
5502              context(), device(), queue_properties, &error));
5503          detail::errHandler(error, __CREATE_COMMAND_QUEUE_WITH_PROPERTIES_ERR);
5504          if (err != NULL) {
5505              *err = error;
5506          }
5507          return deviceQueue;
5508      }
5509      static DeviceCommandQueue makeDefault(
5510          const Context &context, const Device &device, cl_uint queueSize, cl_int *err = nullptr)
5511      {
5512          cl_int error;
5513          cl_command_queue_properties properties =
5514              CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE | CL_QUEUE_ON_DEVICE | CL_QUEUE_ON_DEVICE_DEFAULT;
5515          cl_queue_properties queue_properties[] = {
5516              CL_QUEUE_PROPERTIES, properties,
5517              CL_QUEUE_SIZE, queueSize,
5518              0 };
5519          DeviceCommandQueue deviceQueue(
5520              ::clCreateCommandQueueWithProperties(
5521                  context(), device(), queue_properties, &error));
5522          detail::errHandler(error, __CREATE_COMMAND_QUEUE_WITH_PROPERTIES_ERR);
5523          if (err != NULL) {
5524              *err = error;
5525          }
5526          return deviceQueue;
5527      }
5528  }; 
5529  namespace detail
5530  {
5531      template <>
5532      struct KernelArgumentHandler<cl::DeviceCommandQueue, void>
5533      {
5534          static size_type size(const cl::DeviceCommandQueue&) { return sizeof(cl_command_queue); }
5535          static const cl_command_queue* ptr(const cl::DeviceCommandQueue& value) { return &(value()); }
5536      };
5537  } 
5538  #endif 
5539  template< typename IteratorType >
5540  Buffer::Buffer(
5541      const Context &context,
5542      IteratorType startIterator,
5543      IteratorType endIterator,
5544      bool readOnly,
5545      bool useHostPtr,
5546      cl_int* err)
5547  {
5548      typedef typename std::iterator_traits<IteratorType>::value_type DataType;
5549      cl_int error;
5550      cl_mem_flags flags = 0;
5551      if( readOnly ) {
5552          flags |= CL_MEM_READ_ONLY;
5553      }
5554      else {
5555          flags |= CL_MEM_READ_WRITE;
5556      }
5557      if( useHostPtr ) {
5558          flags |= CL_MEM_USE_HOST_PTR;
5559      }
5560      size_type size = sizeof(DataType)*(endIterator - startIterator);
5561      if( useHostPtr ) {
5562          object_ = ::clCreateBuffer(context(), flags, size, static_cast<DataType*>(&*startIterator), &error);
5563      } else {
5564          object_ = ::clCreateBuffer(context(), flags, size, 0, &error);
5565      }
5566      detail::errHandler(error, __CREATE_BUFFER_ERR);
5567      if (err != NULL) {
5568          *err = error;
5569      }
5570      if( !useHostPtr ) {
5571          CommandQueue queue(context, 0, &error);
5572          detail::errHandler(error, __CREATE_BUFFER_ERR);
5573          if (err != NULL) {
5574              *err = error;
5575          }
5576          error = cl::copy(queue, startIterator, endIterator, *this);
5577          detail::errHandler(error, __CREATE_BUFFER_ERR);
5578          if (err != NULL) {
5579              *err = error;
5580          }
5581      }
5582  }
5583  template< typename IteratorType >
5584  Buffer::Buffer(
5585      const CommandQueue &queue,
5586      IteratorType startIterator,
5587      IteratorType endIterator,
5588      bool readOnly,
5589      bool useHostPtr,
5590      cl_int* err)
5591  {
5592      typedef typename std::iterator_traits<IteratorType>::value_type DataType;
5593      cl_int error;
5594      cl_mem_flags flags = 0;
5595      if (readOnly) {
5596          flags |= CL_MEM_READ_ONLY;
5597      }
5598      else {
5599          flags |= CL_MEM_READ_WRITE;
5600      }
5601      if (useHostPtr) {
5602          flags |= CL_MEM_USE_HOST_PTR;
5603      }
5604      size_type size = sizeof(DataType)*(endIterator - startIterator);
5605      Context context = queue.getInfo<CL_QUEUE_CONTEXT>();
5606      if (useHostPtr) {
5607          object_ = ::clCreateBuffer(context(), flags, size, static_cast<DataType*>(&*startIterator), &error);
5608      }
5609      else {
5610          object_ = ::clCreateBuffer(context(), flags, size, 0, &error);
5611      }
5612      detail::errHandler(error, __CREATE_BUFFER_ERR);
5613      if (err != NULL) {
5614          *err = error;
5615      }
5616      if (!useHostPtr) {
5617          error = cl::copy(queue, startIterator, endIterator, *this);
5618          detail::errHandler(error, __CREATE_BUFFER_ERR);
5619          if (err != NULL) {
5620              *err = error;
5621          }
5622      }
5623  }
5624  inline cl_int enqueueReadBuffer(
5625      const Buffer& buffer,
5626      cl_bool blocking,
5627      size_type offset,
5628      size_type size,
5629      void* ptr,
5630      const vector<Event>* events = NULL,
5631      Event* event = NULL)
5632  {
5633      cl_int error;
5634      CommandQueue queue = CommandQueue::getDefault(&error);
5635      if (error != CL_SUCCESS) {
5636          return error;
5637      }
5638      return queue.enqueueReadBuffer(buffer, blocking, offset, size, ptr, events, event);
5639  }
5640  inline cl_int enqueueWriteBuffer(
5641          const Buffer& buffer,
5642          cl_bool blocking,
5643          size_type offset,
5644          size_type size,
5645          const void* ptr,
5646          const vector<Event>* events = NULL,
5647          Event* event = NULL)
5648  {
5649      cl_int error;
5650      CommandQueue queue = CommandQueue::getDefault(&error);
5651      if (error != CL_SUCCESS) {
5652          return error;
5653      }
5654      return queue.enqueueWriteBuffer(buffer, blocking, offset, size, ptr, events, event);
5655  }
5656  inline void* enqueueMapBuffer(
5657          const Buffer& buffer,
5658          cl_bool blocking,
5659          cl_map_flags flags,
5660          size_type offset,
5661          size_type size,
5662          const vector<Event>* events = NULL,
5663          Event* event = NULL,
5664          cl_int* err = NULL)
5665  {
5666      cl_int error;
5667      CommandQueue queue = CommandQueue::getDefault(&error);
5668      detail::errHandler(error, __ENQUEUE_MAP_BUFFER_ERR);
5669      if (err != NULL) {
5670          *err = error;
5671      }
5672      void * result = ::clEnqueueMapBuffer(
5673              queue(), buffer(), blocking, flags, offset, size,
5674              (events != NULL) ? (cl_uint) events->size() : 0,
5675              (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
5676              (cl_event*) event,
5677              &error);
5678      detail::errHandler(error, __ENQUEUE_MAP_BUFFER_ERR);
5679      if (err != NULL) {
5680          *err = error;
5681      }
5682      return result;
5683  }
5684  #if CL_HPP_TARGET_OPENCL_VERSION >= 200
5685  template<typename T>
5686  inline cl_int enqueueMapSVM(
5687      T* ptr,
5688      cl_bool blocking,
5689      cl_map_flags flags,
5690      size_type size,
5691      const vector<Event>* events,
5692      Event* event)
5693  {
5694      cl_int error;
5695      CommandQueue queue = CommandQueue::getDefault(&error);
5696      if (error != CL_SUCCESS) {
5697          return detail::errHandler(error, __ENQUEUE_MAP_BUFFER_ERR);
5698      }
5699      return queue.enqueueMapSVM(
5700          ptr, blocking, flags, size, events, event);
5701  }
5702  template<typename T, class D>
5703  inline cl_int enqueueMapSVM(
5704      cl::pointer<T, D> ptr,
5705      cl_bool blocking,
5706      cl_map_flags flags,
5707      size_type size,
5708      const vector<Event>* events = NULL,
5709      Event* event = NULL)
5710  {
5711      cl_int error;
5712      CommandQueue queue = CommandQueue::getDefault(&error);
5713      if (error != CL_SUCCESS) {
5714          return detail::errHandler(error, __ENQUEUE_MAP_BUFFER_ERR);
5715      }
5716      return queue.enqueueMapSVM(
5717          ptr, blocking, flags, size, events, event);
5718  }
5719  template<typename T, class Alloc>
5720  inline cl_int enqueueMapSVM(
5721      cl::vector<T, Alloc> container,
5722      cl_bool blocking,
5723      cl_map_flags flags,
5724      const vector<Event>* events = NULL,
5725      Event* event = NULL)
5726  {
5727      cl_int error;
5728      CommandQueue queue = CommandQueue::getDefault(&error);
5729      if (error != CL_SUCCESS) {
5730          return detail::errHandler(error, __ENQUEUE_MAP_BUFFER_ERR);
5731      }
5732      return queue.enqueueMapSVM(
5733          container, blocking, flags, events, event);
5734  }
5735  #endif 
5736  inline cl_int enqueueUnmapMemObject(
5737      const Memory& memory,
5738      void* mapped_ptr,
5739      const vector<Event>* events = NULL,
5740      Event* event = NULL)
5741  {
5742      cl_int error;
5743      CommandQueue queue = CommandQueue::getDefault(&error);
5744      detail::errHandler(error, __ENQUEUE_MAP_BUFFER_ERR);
5745      if (error != CL_SUCCESS) {
5746          return error;
5747      }
5748      cl_event tmp;
5749      cl_int err = detail::errHandler(
5750          ::clEnqueueUnmapMemObject(
5751          queue(), memory(), mapped_ptr,
5752          (events != NULL) ? (cl_uint)events->size() : 0,
5753          (events != NULL && events->size() > 0) ? (cl_event*)&events->front() : NULL,
5754          (event != NULL) ? &tmp : NULL),
5755          __ENQUEUE_UNMAP_MEM_OBJECT_ERR);
5756      if (event != NULL && err == CL_SUCCESS)
5757          *event = tmp;
5758      return err;
5759  }
5760  #if CL_HPP_TARGET_OPENCL_VERSION >= 200
5761  template<typename T>
5762  inline cl_int enqueueUnmapSVM(
5763      T* ptr,
5764      const vector<Event>* events = NULL,
5765      Event* event = NULL)
5766  {
5767      cl_int error;
5768      CommandQueue queue = CommandQueue::getDefault(&error);
5769      if (error != CL_SUCCESS) {
5770          return detail::errHandler(error, __ENQUEUE_UNMAP_MEM_OBJECT_ERR);
5771      }
5772      return detail::errHandler(queue.enqueueUnmapSVM(ptr, events, event), 
5773          __ENQUEUE_UNMAP_MEM_OBJECT_ERR);
5774  }
5775  template<typename T, class D>
5776  inline cl_int enqueueUnmapSVM(
5777      cl::pointer<T, D> &ptr,
5778      const vector<Event>* events = NULL,
5779      Event* event = NULL)
5780  {
5781      cl_int error;
5782      CommandQueue queue = CommandQueue::getDefault(&error);
5783      if (error != CL_SUCCESS) {
5784          return detail::errHandler(error, __ENQUEUE_UNMAP_MEM_OBJECT_ERR);
5785      }
5786      return detail::errHandler(queue.enqueueUnmapSVM(ptr, events, event),
5787          __ENQUEUE_UNMAP_MEM_OBJECT_ERR);
5788  }
5789  template<typename T, class Alloc>
5790  inline cl_int enqueueUnmapSVM(
5791      cl::vector<T, Alloc> &container,
5792      const vector<Event>* events = NULL,
5793      Event* event = NULL)
5794  {
5795      cl_int error;
5796      CommandQueue queue = CommandQueue::getDefault(&error);
5797      if (error != CL_SUCCESS) {
5798          return detail::errHandler(error, __ENQUEUE_UNMAP_MEM_OBJECT_ERR);
5799      }
5800      return detail::errHandler(queue.enqueueUnmapSVM(container, events, event),
5801          __ENQUEUE_UNMAP_MEM_OBJECT_ERR);
5802  }
5803  #endif 
5804  inline cl_int enqueueCopyBuffer(
5805          const Buffer& src,
5806          const Buffer& dst,
5807          size_type src_offset,
5808          size_type dst_offset,
5809          size_type size,
5810          const vector<Event>* events = NULL,
5811          Event* event = NULL)
5812  {
5813      cl_int error;
5814      CommandQueue queue = CommandQueue::getDefault(&error);
5815      if (error != CL_SUCCESS) {
5816          return error;
5817      }
5818      return queue.enqueueCopyBuffer(src, dst, src_offset, dst_offset, size, events, event);
5819  }
5820  template< typename IteratorType >
5821  inline cl_int copy( IteratorType startIterator, IteratorType endIterator, cl::Buffer &buffer )
5822  {
5823      cl_int error;
5824      CommandQueue queue = CommandQueue::getDefault(&error);
5825      if (error != CL_SUCCESS)
5826          return error;
5827      return cl::copy(queue, startIterator, endIterator, buffer);
5828  }
5829  template< typename IteratorType >
5830  inline cl_int copy( const cl::Buffer &buffer, IteratorType startIterator, IteratorType endIterator )
5831  {
5832      cl_int error;
5833      CommandQueue queue = CommandQueue::getDefault(&error);
5834      if (error != CL_SUCCESS)
5835          return error;
5836      return cl::copy(queue, buffer, startIterator, endIterator);
5837  }
5838  template< typename IteratorType >
5839  inline cl_int copy( const CommandQueue &queue, IteratorType startIterator, IteratorType endIterator, cl::Buffer &buffer )
5840  {
5841      typedef typename std::iterator_traits<IteratorType>::value_type DataType;
5842      cl_int error;
5843      size_type length = endIterator-startIterator;
5844      size_type byteLength = length*sizeof(DataType);
5845      DataType *pointer = 
5846          static_cast<DataType*>(queue.enqueueMapBuffer(buffer, CL_TRUE, CL_MAP_WRITE, 0, byteLength, 0, 0, &error));
5847      if( error != CL_SUCCESS ) {
5848          return error;
5849      }
5850  #if defined(_MSC_VER)
5851      std::copy(
5852          startIterator, 
5853          endIterator, 
5854          stdext::checked_array_iterator<DataType*>(
5855              pointer, length));
5856  #else
5857      std::copy(startIterator, endIterator, pointer);
5858  #endif
5859      Event endEvent;
5860      error = queue.enqueueUnmapMemObject(buffer, pointer, 0, &endEvent);
5861      if( error != CL_SUCCESS ) { 
5862          return error;
5863      }
5864      endEvent.wait();
5865      return CL_SUCCESS;
5866  }
5867  template< typename IteratorType >
5868  inline cl_int copy( const CommandQueue &queue, const cl::Buffer &buffer, IteratorType startIterator, IteratorType endIterator )
5869  {
5870      typedef typename std::iterator_traits<IteratorType>::value_type DataType;
5871      cl_int error;
5872      size_type length = endIterator-startIterator;
5873      size_type byteLength = length*sizeof(DataType);
5874      DataType *pointer = 
5875          static_cast<DataType*>(queue.enqueueMapBuffer(buffer, CL_TRUE, CL_MAP_READ, 0, byteLength, 0, 0, &error));
5876      if( error != CL_SUCCESS ) {
5877          return error;
5878      }
5879      std::copy(pointer, pointer + length, startIterator);
5880      Event endEvent;
5881      error = queue.enqueueUnmapMemObject(buffer, pointer, 0, &endEvent);
5882      if( error != CL_SUCCESS ) { 
5883          return error;
5884      }
5885      endEvent.wait();
5886      return CL_SUCCESS;
5887  }
5888  #if CL_HPP_TARGET_OPENCL_VERSION >= 200
5889  template<typename T, class Alloc>
5890  inline cl_int mapSVM(cl::vector<T, Alloc> &container)
5891  {
5892      return enqueueMapSVM(container, CL_TRUE, CL_MAP_READ | CL_MAP_WRITE);
5893  }
5894  template<typename T, class Alloc>
5895  inline cl_int unmapSVM(cl::vector<T, Alloc> &container)
5896  {
5897      return enqueueUnmapSVM(container);
5898  }
5899  #endif 
5900  #if CL_HPP_TARGET_OPENCL_VERSION >= 110
5901  inline cl_int enqueueReadBufferRect(
5902      const Buffer& buffer,
5903      cl_bool blocking,
5904      const array<size_type, 3>& buffer_offset,
5905      const array<size_type, 3>& host_offset,
5906      const array<size_type, 3>& region,
5907      size_type buffer_row_pitch,
5908      size_type buffer_slice_pitch,
5909      size_type host_row_pitch,
5910      size_type host_slice_pitch,
5911      void *ptr,
5912      const vector<Event>* events = NULL,
5913      Event* event = NULL)
5914  {
5915      cl_int error;
5916      CommandQueue queue = CommandQueue::getDefault(&error);
5917      if (error != CL_SUCCESS) {
5918          return error;
5919      }
5920      return queue.enqueueReadBufferRect(
5921          buffer, 
5922          blocking, 
5923          buffer_offset, 
5924          host_offset,
5925          region,
5926          buffer_row_pitch,
5927          buffer_slice_pitch,
5928          host_row_pitch,
5929          host_slice_pitch,
5930          ptr, 
5931          events, 
5932          event);
5933  }
5934  inline cl_int enqueueWriteBufferRect(
5935      const Buffer& buffer,
5936      cl_bool blocking,
5937      const array<size_type, 3>& buffer_offset,
5938      const array<size_type, 3>& host_offset,
5939      const array<size_type, 3>& region,
5940      size_type buffer_row_pitch,
5941      size_type buffer_slice_pitch,
5942      size_type host_row_pitch,
5943      size_type host_slice_pitch,
5944      void *ptr,
5945      const vector<Event>* events = NULL,
5946      Event* event = NULL)
5947  {
5948      cl_int error;
5949      CommandQueue queue = CommandQueue::getDefault(&error);
5950      if (error != CL_SUCCESS) {
5951          return error;
5952      }
5953      return queue.enqueueWriteBufferRect(
5954          buffer, 
5955          blocking, 
5956          buffer_offset, 
5957          host_offset,
5958          region,
5959          buffer_row_pitch,
5960          buffer_slice_pitch,
5961          host_row_pitch,
5962          host_slice_pitch,
5963          ptr, 
5964          events, 
5965          event);
5966  }
5967  inline cl_int enqueueCopyBufferRect(
5968      const Buffer& src,
5969      const Buffer& dst,
5970      const array<size_type, 3>& src_origin,
5971      const array<size_type, 3>& dst_origin,
5972      const array<size_type, 3>& region,
5973      size_type src_row_pitch,
5974      size_type src_slice_pitch,
5975      size_type dst_row_pitch,
5976      size_type dst_slice_pitch,
5977      const vector<Event>* events = NULL,
5978      Event* event = NULL)
5979  {
5980      cl_int error;
5981      CommandQueue queue = CommandQueue::getDefault(&error);
5982      if (error != CL_SUCCESS) {
5983          return error;
5984      }
5985      return queue.enqueueCopyBufferRect(
5986          src,
5987          dst,
5988          src_origin,
5989          dst_origin,
5990          region,
5991          src_row_pitch,
5992          src_slice_pitch,
5993          dst_row_pitch,
5994          dst_slice_pitch,
5995          events, 
5996          event);
5997  }
5998  #endif 
5999  inline cl_int enqueueReadImage(
6000      const Image& image,
6001      cl_bool blocking,
6002      const array<size_type, 3>& origin,
6003      const array<size_type, 3>& region,
6004      size_type row_pitch,
6005      size_type slice_pitch,
6006      void* ptr,
6007      const vector<Event>* events = NULL,
6008      Event* event = NULL) 
6009  {
6010      cl_int error;
6011      CommandQueue queue = CommandQueue::getDefault(&error);
6012      if (error != CL_SUCCESS) {
6013          return error;
6014      }
6015      return queue.enqueueReadImage(
6016          image,
6017          blocking,
6018          origin,
6019          region,
6020          row_pitch,
6021          slice_pitch,
6022          ptr,
6023          events, 
6024          event);
6025  }
6026  inline cl_int enqueueWriteImage(
6027      const Image& image,
6028      cl_bool blocking,
6029      const array<size_type, 3>& origin,
6030      const array<size_type, 3>& region,
6031      size_type row_pitch,
6032      size_type slice_pitch,
6033      void* ptr,
6034      const vector<Event>* events = NULL,
6035      Event* event = NULL)
6036  {
6037      cl_int error;
6038      CommandQueue queue = CommandQueue::getDefault(&error);
6039      if (error != CL_SUCCESS) {
6040          return error;
6041      }
6042      return queue.enqueueWriteImage(
6043          image,
6044          blocking,
6045          origin,
6046          region,
6047          row_pitch,
6048          slice_pitch,
6049          ptr,
6050          events, 
6051          event);
6052  }
6053  inline cl_int enqueueCopyImage(
6054      const Image& src,
6055      const Image& dst,
6056      const array<size_type, 3>& src_origin,
6057      const array<size_type, 3>& dst_origin,
6058      const array<size_type, 3>& region,
6059      const vector<Event>* events = NULL,
6060      Event* event = NULL)
6061  {
6062      cl_int error;
6063      CommandQueue queue = CommandQueue::getDefault(&error);
6064      if (error != CL_SUCCESS) {
6065          return error;
6066      }
6067      return queue.enqueueCopyImage(
6068          src,
6069          dst,
6070          src_origin,
6071          dst_origin,
6072          region,
6073          events,
6074          event);
6075  }
6076  inline cl_int enqueueCopyImageToBuffer(
6077      const Image& src,
6078      const Buffer& dst,
6079      const array<size_type, 3>& src_origin,
6080      const array<size_type, 3>& region,
6081      size_type dst_offset,
6082      const vector<Event>* events = NULL,
6083      Event* event = NULL)
6084  {
6085      cl_int error;
6086      CommandQueue queue = CommandQueue::getDefault(&error);
6087      if (error != CL_SUCCESS) {
6088          return error;
6089      }
6090      return queue.enqueueCopyImageToBuffer(
6091          src,
6092          dst,
6093          src_origin,
6094          region,
6095          dst_offset,
6096          events,
6097          event);
6098  }
6099  inline cl_int enqueueCopyBufferToImage(
6100      const Buffer& src,
6101      const Image& dst,
6102      size_type src_offset,
6103      const array<size_type, 3>& dst_origin,
6104      const array<size_type, 3>& region,
6105      const vector<Event>* events = NULL,
6106      Event* event = NULL)
6107  {
6108      cl_int error;
6109      CommandQueue queue = CommandQueue::getDefault(&error);
6110      if (error != CL_SUCCESS) {
6111          return error;
6112      }
6113      return queue.enqueueCopyBufferToImage(
6114          src,
6115          dst,
6116          src_offset,
6117          dst_origin,
6118          region,
6119          events,
6120          event);
6121  }
6122  inline cl_int flush(void)
6123  {
6124      cl_int error;
6125      CommandQueue queue = CommandQueue::getDefault(&error);
6126      if (error != CL_SUCCESS) {
6127          return error;
6128      }
6129      return queue.flush();
6130  }
6131  inline cl_int finish(void)
6132  {
6133      cl_int error;
6134      CommandQueue queue = CommandQueue::getDefault(&error);
6135      if (error != CL_SUCCESS) {
6136          return error;
6137      } 
6138      return queue.finish();
6139  }
6140  class EnqueueArgs
6141  {
6142  private:
6143      CommandQueue queue_;
6144      const NDRange offset_;
6145      const NDRange global_;
6146      const NDRange local_;
6147      vector<Event> events_;
6148      template<typename... Ts>
6149      friend class KernelFunctor;
6150  public:
6151      EnqueueArgs(NDRange global) : 
6152        queue_(CommandQueue::getDefault()),
6153        offset_(NullRange), 
6154        global_(global),
6155        local_(NullRange)
6156      {
6157      }
6158      EnqueueArgs(NDRange global, NDRange local) : 
6159        queue_(CommandQueue::getDefault()),
6160        offset_(NullRange), 
6161        global_(global),
6162        local_(local)
6163      {
6164      }
6165      EnqueueArgs(NDRange offset, NDRange global, NDRange local) : 
6166        queue_(CommandQueue::getDefault()),
6167        offset_(offset), 
6168        global_(global),
6169        local_(local)
6170      {
6171      }
6172      EnqueueArgs(Event e, NDRange global) : 
6173        queue_(CommandQueue::getDefault()),
6174        offset_(NullRange), 
6175        global_(global),
6176        local_(NullRange)
6177      {
6178          events_.push_back(e);
6179      }
6180      EnqueueArgs(Event e, NDRange global, NDRange local) : 
6181        queue_(CommandQueue::getDefault()),
6182        offset_(NullRange), 
6183        global_(global),
6184        local_(local)
6185      {
6186          events_.push_back(e);
6187      }
6188      EnqueueArgs(Event e, NDRange offset, NDRange global, NDRange local) : 
6189        queue_(CommandQueue::getDefault()),
6190        offset_(offset), 
6191        global_(global),
6192        local_(local)
6193      {
6194          events_.push_back(e);
6195      }
6196      EnqueueArgs(const vector<Event> &events, NDRange global) : 
6197        queue_(CommandQueue::getDefault()),
6198        offset_(NullRange), 
6199        global_(global),
6200        local_(NullRange),
6201        events_(events)
6202      {
6203      }
6204      EnqueueArgs(const vector<Event> &events, NDRange global, NDRange local) : 
6205        queue_(CommandQueue::getDefault()),
6206        offset_(NullRange), 
6207        global_(global),
6208        local_(local),
6209        events_(events)
6210      {
6211      }
6212      EnqueueArgs(const vector<Event> &events, NDRange offset, NDRange global, NDRange local) : 
6213        queue_(CommandQueue::getDefault()),
6214        offset_(offset), 
6215        global_(global),
6216        local_(local),
6217        events_(events)
6218      {
6219      }
6220      EnqueueArgs(CommandQueue &queue, NDRange global) : 
6221        queue_(queue),
6222        offset_(NullRange), 
6223        global_(global),
6224        local_(NullRange)
6225      {
6226      }
6227      EnqueueArgs(CommandQueue &queue, NDRange global, NDRange local) : 
6228        queue_(queue),
6229        offset_(NullRange), 
6230        global_(global),
6231        local_(local)
6232      {
6233      }
6234      EnqueueArgs(CommandQueue &queue, NDRange offset, NDRange global, NDRange local) : 
6235        queue_(queue),
6236        offset_(offset), 
6237        global_(global),
6238        local_(local)
6239      {
6240      }
6241      EnqueueArgs(CommandQueue &queue, Event e, NDRange global) : 
6242        queue_(queue),
6243        offset_(NullRange), 
6244        global_(global),
6245        local_(NullRange)
6246      {
6247          events_.push_back(e);
6248      }
6249      EnqueueArgs(CommandQueue &queue, Event e, NDRange global, NDRange local) : 
6250        queue_(queue),
6251        offset_(NullRange), 
6252        global_(global),
6253        local_(local)
6254      {
6255          events_.push_back(e);
6256      }
6257      EnqueueArgs(CommandQueue &queue, Event e, NDRange offset, NDRange global, NDRange local) : 
6258        queue_(queue),
6259        offset_(offset), 
6260        global_(global),
6261        local_(local)
6262      {
6263          events_.push_back(e);
6264      }
6265      EnqueueArgs(CommandQueue &queue, const vector<Event> &events, NDRange global) : 
6266        queue_(queue),
6267        offset_(NullRange), 
6268        global_(global),
6269        local_(NullRange),
6270        events_(events)
6271      {
6272      }
6273      EnqueueArgs(CommandQueue &queue, const vector<Event> &events, NDRange global, NDRange local) : 
6274        queue_(queue),
6275        offset_(NullRange), 
6276        global_(global),
6277        local_(local),
6278        events_(events)
6279      {
6280      }
6281      EnqueueArgs(CommandQueue &queue, const vector<Event> &events, NDRange offset, NDRange global, NDRange local) : 
6282        queue_(queue),
6283        offset_(offset), 
6284        global_(global),
6285        local_(local),
6286        events_(events)
6287      {
6288      }
6289  };
6290  template<typename... Ts>
6291  class KernelFunctor
6292  {
6293  private:
6294      Kernel kernel_;
6295      template<int index, typename T0, typename... T1s>
6296      void setArgs(T0&& t0, T1s&&... t1s)
6297      {
6298          kernel_.setArg(index, t0);
6299          setArgs<index + 1, T1s...>(std::forward<T1s>(t1s)...);
6300      }
6301      template<int index, typename T0>
6302      void setArgs(T0&& t0)
6303      {
6304          kernel_.setArg(index, t0);
6305      }
6306      template<int index>
6307      void setArgs()
6308      {
6309      }
6310  public:
6311      KernelFunctor(Kernel kernel) : kernel_(kernel)
6312      {}
6313      KernelFunctor(
6314          const Program& program,
6315          const string name,
6316          cl_int * err = NULL) :
6317          kernel_(program, name.c_str(), err)
6318      {}
6319      typedef Event result_type;
6320      Event operator() (
6321          const EnqueueArgs& args,
6322          Ts... ts)
6323      {
6324          Event event;
6325          setArgs<0>(std::forward<Ts>(ts)...);
6326          args.queue_.enqueueNDRangeKernel(
6327              kernel_,
6328              args.offset_,
6329              args.global_,
6330              args.local_,
6331              &args.events_,
6332              &event);
6333          return event;
6334      }
6335      Event operator() (
6336          const EnqueueArgs& args,
6337          Ts... ts,
6338          cl_int &error)
6339      {
6340          Event event;
6341          setArgs<0>(std::forward<Ts>(ts)...);
6342          error = args.queue_.enqueueNDRangeKernel(
6343              kernel_,
6344              args.offset_,
6345              args.global_,
6346              args.local_,
6347              &args.events_,
6348              &event);
6349          return event;
6350      }
6351  #if CL_HPP_TARGET_OPENCL_VERSION >= 200
6352      cl_int setSVMPointers(const vector<void*> &pointerList)
6353      {
6354          return kernel_.setSVMPointers(pointerList);
6355      }
6356      template<typename T0, typename... T1s>
6357      cl_int setSVMPointers(const T0 &t0, T1s... ts)
6358      {
6359          return kernel_.setSVMPointers(t0, ts...);
6360      }
6361  #endif 
6362      Kernel getKernel()
6363      {
6364          return kernel_;
6365      }
6366  };
6367  namespace compatibility {
6368      template<typename... Ts>
6369      struct make_kernel
6370      {
6371          typedef KernelFunctor<Ts...> FunctorType;
6372          FunctorType functor_;
6373          make_kernel(
6374              const Program& program,
6375              const string name,
6376              cl_int * err = NULL) :
6377              functor_(FunctorType(program, name, err))
6378          {}
6379          make_kernel(
6380              const Kernel kernel) :
6381              functor_(FunctorType(kernel))
6382          {}
6383          typedef Event result_type;
6384          typedef Event type_(
6385              const EnqueueArgs&,
6386              Ts...);
6387          Event operator()(
6388              const EnqueueArgs& enqueueArgs,
6389              Ts... args)
6390          {
6391              return functor_(
6392                  enqueueArgs, args...);
6393          }
6394      };
6395  } 
6396  #undef CL_HPP_ERR_STR_
6397  #if !defined(CL_HPP_USER_OVERRIDE_ERROR_STRINGS)
6398  #undef __GET_DEVICE_INFO_ERR
6399  #undef __GET_PLATFORM_INFO_ERR
6400  #undef __GET_DEVICE_IDS_ERR
6401  #undef __GET_CONTEXT_INFO_ERR
6402  #undef __GET_EVENT_INFO_ERR
6403  #undef __GET_EVENT_PROFILE_INFO_ERR
6404  #undef __GET_MEM_OBJECT_INFO_ERR
6405  #undef __GET_IMAGE_INFO_ERR
6406  #undef __GET_SAMPLER_INFO_ERR
6407  #undef __GET_KERNEL_INFO_ERR
6408  #undef __GET_KERNEL_ARG_INFO_ERR
6409  #undef __GET_KERNEL_WORK_GROUP_INFO_ERR
6410  #undef __GET_PROGRAM_INFO_ERR
6411  #undef __GET_PROGRAM_BUILD_INFO_ERR
6412  #undef __GET_COMMAND_QUEUE_INFO_ERR
6413  #undef __CREATE_CONTEXT_ERR
6414  #undef __CREATE_CONTEXT_FROM_TYPE_ERR
6415  #undef __GET_SUPPORTED_IMAGE_FORMATS_ERR
6416  #undef __CREATE_BUFFER_ERR
6417  #undef __CREATE_SUBBUFFER_ERR
6418  #undef __CREATE_IMAGE2D_ERR
6419  #undef __CREATE_IMAGE3D_ERR
6420  #undef __CREATE_SAMPLER_ERR
6421  #undef __SET_MEM_OBJECT_DESTRUCTOR_CALLBACK_ERR
6422  #undef __CREATE_USER_EVENT_ERR
6423  #undef __SET_USER_EVENT_STATUS_ERR
6424  #undef __SET_EVENT_CALLBACK_ERR
6425  #undef __SET_PRINTF_CALLBACK_ERR
6426  #undef __WAIT_FOR_EVENTS_ERR
6427  #undef __CREATE_KERNEL_ERR
6428  #undef __SET_KERNEL_ARGS_ERR
6429  #undef __CREATE_PROGRAM_WITH_SOURCE_ERR
6430  #undef __CREATE_PROGRAM_WITH_BINARY_ERR
6431  #undef __CREATE_PROGRAM_WITH_BUILT_IN_KERNELS_ERR
6432  #undef __BUILD_PROGRAM_ERR
6433  #undef __CREATE_KERNELS_IN_PROGRAM_ERR
6434  #undef __CREATE_COMMAND_QUEUE_ERR
6435  #undef __SET_COMMAND_QUEUE_PROPERTY_ERR
6436  #undef __ENQUEUE_READ_BUFFER_ERR
6437  #undef __ENQUEUE_WRITE_BUFFER_ERR
6438  #undef __ENQUEUE_READ_BUFFER_RECT_ERR
6439  #undef __ENQUEUE_WRITE_BUFFER_RECT_ERR
6440  #undef __ENQEUE_COPY_BUFFER_ERR
6441  #undef __ENQEUE_COPY_BUFFER_RECT_ERR
6442  #undef __ENQUEUE_READ_IMAGE_ERR
6443  #undef __ENQUEUE_WRITE_IMAGE_ERR
6444  #undef __ENQUEUE_COPY_IMAGE_ERR
6445  #undef __ENQUEUE_COPY_IMAGE_TO_BUFFER_ERR
6446  #undef __ENQUEUE_COPY_BUFFER_TO_IMAGE_ERR
6447  #undef __ENQUEUE_MAP_BUFFER_ERR
6448  #undef __ENQUEUE_MAP_IMAGE_ERR
6449  #undef __ENQUEUE_UNMAP_MEM_OBJECT_ERR
6450  #undef __ENQUEUE_NDRANGE_KERNEL_ERR
6451  #undef __ENQUEUE_TASK_ERR
6452  #undef __ENQUEUE_NATIVE_KERNEL
6453  #undef __UNLOAD_COMPILER_ERR
6454  #undef __CREATE_SUB_DEVICES_ERR
6455  #undef __CREATE_PIPE_ERR
6456  #undef __GET_PIPE_INFO_ERR
6457  #endif 
6458  #undef CL_HPP_INIT_CL_EXT_FCN_PTR_
6459  #undef CL_HPP_INIT_CL_EXT_FCN_PTR_PLATFORM_
6460  #if defined(CL_HPP_USE_CL_DEVICE_FISSION)
6461  #undef CL_HPP_PARAM_NAME_DEVICE_FISSION_
6462  #endif 
6463  #undef CL_HPP_NOEXCEPT_
6464  #undef CL_HPP_DEFINE_STATIC_MEMBER_
6465  } 
6466  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-cl2.hpp</h3>
            <pre><code>1  #ifndef CL_HPP_
2  #define CL_HPP_
3  #if !defined(CL_HPP_USE_DX_INTEROP) && defined(USE_DX_INTEROP)
4  # pragma message("cl2.hpp: USE_DX_INTEROP is deprecated. Define CL_HPP_USE_DX_INTEROP instead")
5  # define CL_HPP_USE_DX_INTEROP
6  #endif
7  #if !defined(CL_HPP_USE_CL_DEVICE_FISSION) && defined(USE_CL_DEVICE_FISSION)
8  # pragma message("cl2.hpp: USE_CL_DEVICE_FISSION is deprecated. Define CL_HPP_USE_CL_DEVICE_FISSION instead")
9  # define CL_HPP_USE_CL_DEVICE_FISSION
10  #endif
11  #if !defined(CL_HPP_ENABLE_EXCEPTIONS) && defined(__CL_ENABLE_EXCEPTIONS)
12  # pragma message("cl2.hpp: __CL_ENABLE_EXCEPTIONS is deprecated. Define CL_HPP_ENABLE_EXCEPTIONS instead")
13  # define CL_HPP_ENABLE_EXCEPTIONS
14  #endif
15  #if !defined(CL_HPP_NO_STD_VECTOR) && defined(__NO_STD_VECTOR)
16  # pragma message("cl2.hpp: __NO_STD_VECTOR is deprecated. Define CL_HPP_NO_STD_VECTOR instead")
17  # define CL_HPP_NO_STD_VECTOR
18  #endif
19  #if !defined(CL_HPP_NO_STD_STRING) && defined(__NO_STD_STRING)
20  # pragma message("cl2.hpp: __NO_STD_STRING is deprecated. Define CL_HPP_NO_STD_STRING instead")
21  # define CL_HPP_NO_STD_STRING
22  #endif
23  #if defined(VECTOR_CLASS)
24  # pragma message("cl2.hpp: VECTOR_CLASS is deprecated. Alias cl::vector instead")
25  #endif
26  #if defined(STRING_CLASS)
27  # pragma message("cl2.hpp: STRING_CLASS is deprecated. Alias cl::string instead.")
28  #endif
29  #if !defined(CL_HPP_USER_OVERRIDE_ERROR_STRINGS) && defined(__CL_USER_OVERRIDE_ERROR_STRINGS)
30  # pragma message("cl2.hpp: __CL_USER_OVERRIDE_ERROR_STRINGS is deprecated. Define CL_HPP_USER_OVERRIDE_ERROR_STRINGS instead")
31  # define CL_HPP_USER_OVERRIDE_ERROR_STRINGS
32  #endif
33  #if defined(__USE_DEV_VECTOR)
34  # pragma message("cl2.hpp: __USE_DEV_VECTOR is no longer supported. Expect compilation errors")
35  #endif
36  #if defined(__USE_DEV_STRING)
37  # pragma message("cl2.hpp: __USE_DEV_STRING is no longer supported. Expect compilation errors")
38  #endif
39  #if !defined(CL_HPP_TARGET_OPENCL_VERSION)
40  # pragma message("cl2.hpp: CL_HPP_TARGET_OPENCL_VERSION is not defined. It will default to 200 (OpenCL 2.0)")
41  # define CL_HPP_TARGET_OPENCL_VERSION 200
42  #endif
43  #if CL_HPP_TARGET_OPENCL_VERSION != 100 && CL_HPP_TARGET_OPENCL_VERSION != 110 && CL_HPP_TARGET_OPENCL_VERSION != 120 && CL_HPP_TARGET_OPENCL_VERSION != 200
44  # pragma message("cl2.hpp: CL_HPP_TARGET_OPENCL_VERSION is not a valid value (100, 110, 120 or 200). It will be set to 200")
45  # undef CL_HPP_TARGET_OPENCL_VERSION
46  # define CL_HPP_TARGET_OPENCL_VERSION 200
47  #endif
48  #if !defined(CL_HPP_MINIMUM_OPENCL_VERSION)
49  # define CL_HPP_MINIMUM_OPENCL_VERSION 200
50  #endif
51  #if CL_HPP_MINIMUM_OPENCL_VERSION != 100 && CL_HPP_MINIMUM_OPENCL_VERSION != 110 && CL_HPP_MINIMUM_OPENCL_VERSION != 120 && CL_HPP_MINIMUM_OPENCL_VERSION != 200
52  # pragma message("cl2.hpp: CL_HPP_MINIMUM_OPENCL_VERSION is not a valid value (100, 110, 120 or 200). It will be set to 100")
53  # undef CL_HPP_MINIMUM_OPENCL_VERSION
54  # define CL_HPP_MINIMUM_OPENCL_VERSION 100
55  #endif
56  #if CL_HPP_MINIMUM_OPENCL_VERSION > CL_HPP_TARGET_OPENCL_VERSION
57  # error "CL_HPP_MINIMUM_OPENCL_VERSION must not be greater than CL_HPP_TARGET_OPENCL_VERSION"
58  #endif
59  #if CL_HPP_MINIMUM_OPENCL_VERSION <= 100 && !defined(CL_USE_DEPRECATED_OPENCL_1_0_APIS)
60  # define CL_USE_DEPRECATED_OPENCL_1_0_APIS
61  #endif
62  #if CL_HPP_MINIMUM_OPENCL_VERSION <= 110 && !defined(CL_USE_DEPRECATED_OPENCL_1_1_APIS)
63  # define CL_USE_DEPRECATED_OPENCL_1_1_APIS
64  #endif
65  #if CL_HPP_MINIMUM_OPENCL_VERSION <= 120 && !defined(CL_USE_DEPRECATED_OPENCL_1_2_APIS)
66  # define CL_USE_DEPRECATED_OPENCL_1_2_APIS
67  #endif
68  #if CL_HPP_MINIMUM_OPENCL_VERSION <= 200 && !defined(CL_USE_DEPRECATED_OPENCL_2_0_APIS)
69  # define CL_USE_DEPRECATED_OPENCL_2_0_APIS
70  #endif
71  #ifdef _WIN32
72  #include <malloc.h>
73  #if defined(CL_HPP_USE_DX_INTEROP)
74  #include <CL/cl_d3d10.h>
75  #include <CL/cl_dx9_media_sharing.h>
76  #endif
77  #endif 
78  #if defined(_MSC_VER)
79  #include <intrin.h>
80  #endif 
81  #if (!defined(_MSC_VER) && __cplusplus < 201103L) || (defined(_MSC_VER) && _MSC_VER < 1700)
82  #error Visual studio 2013 or another C++11-supporting compiler required
83  #endif
84  #if defined(CL_HPP_USE_CL_DEVICE_FISSION) || defined(CL_HPP_USE_CL_SUB_GROUPS_KHR)
85  #include <CL/cl_ext.h>
86  #endif
87  #if defined(__APPLE__) || defined(__MACOSX)
88  #include <OpenCL/opencl.h>
89  #else
90  #include <CL/opencl.h>
91  #endif 
92  #if (__cplusplus >= 201103L)
93  #define CL_HPP_NOEXCEPT_ noexcept
94  #else
95  #define CL_HPP_NOEXCEPT_
96  #endif
97  #if defined(_MSC_VER)
98  # define CL_HPP_DEFINE_STATIC_MEMBER_ __declspec(selectany)
99  #else
100  # define CL_HPP_DEFINE_STATIC_MEMBER_ __attribute__((weak))
101  #endif 
102  #if !defined(CL_EXT_PREFIX__VERSION_1_1_DEPRECATED)
103  #define CL_EXT_PREFIX__VERSION_1_1_DEPRECATED  
104  #endif 
105  #if !defined(CL_EXT_SUFFIX__VERSION_1_1_DEPRECATED)
106  #define CL_EXT_SUFFIX__VERSION_1_1_DEPRECATED
107  #endif 
108  #if !defined(CL_EXT_PREFIX__VERSION_1_2_DEPRECATED)
109  #define CL_EXT_PREFIX__VERSION_1_2_DEPRECATED  
110  #endif 
111  #if !defined(CL_EXT_SUFFIX__VERSION_1_2_DEPRECATED)
112  #define CL_EXT_SUFFIX__VERSION_1_2_DEPRECATED
113  #endif 
114  #if !defined(CL_CALLBACK)
115  #define CL_CALLBACK
116  #endif 
117  #include <utility>
118  #include <limits>
119  #include <iterator>
120  #include <mutex>
121  #include <cstring>
122  #include <functional>
123  #if defined(CL_HPP_ENABLE_SIZE_T_COMPATIBILITY)
124  namespace cl {
125      using size_type = ::size_t;
126  } 
127  #else 
128  namespace cl {
129      using size_type = size_t;
130  } 
131  #endif 
132  #if defined(CL_HPP_ENABLE_EXCEPTIONS)
133  #include <exception>
134  #endif 
135  #if !defined(CL_HPP_NO_STD_VECTOR)
136  #include <vector>
137  namespace cl {
138      template < class T, class Alloc = std::allocator<T> >
139      using vector = std::vector<T, Alloc>;
140  } 
141  #endif 
142  #if !defined(CL_HPP_NO_STD_STRING)
143  #include <string>
144  namespace cl {
145      using string = std::string;
146  } 
147  #endif 
148  #if CL_HPP_TARGET_OPENCL_VERSION >= 200
149  #if !defined(CL_HPP_NO_STD_UNIQUE_PTR)
150  #include <memory>
151  namespace cl {
152      template<class T, class D>
153      using pointer = std::unique_ptr<T, D>;
154  } 
155  #endif 
156  #endif 
157  #if !defined(CL_HPP_NO_STD_ARRAY)
158  #include <array>
159  namespace cl {
160      template < class T, size_type N >
161      using array = std::array<T, N>;
162  } 
163  #endif 
164  #if defined(CL_HPP_ENABLE_SIZE_T_COMPATIBILITY)
165  namespace cl {
166      namespace compatibility {
167          template <int N>
168          class size_t
169          {
170          private:
171              size_type data_[N];
172          public:
173              size_t()
174              {
175                  for (int i = 0; i < N; ++i) {
176                      data_[i] = 0;
177                  }
178              }
179              size_t(const array<size_type, N> &rhs)
180              {
181                  for (int i = 0; i < N; ++i) {
182                      data_[i] = rhs[i];
183                  }
184              }
185              size_type& operator[](int index)
186              {
187                  return data_[index];
188              }
189              const size_type& operator[](int index) const
190              {
191                  return data_[index];
192              }
193              operator size_type* ()             { return data_; }
194              operator const size_type* () const { return data_; }
195              operator array<size_type, N>() const
196              {
197                  array<size_type, N> ret;
198                  for (int i = 0; i < N; ++i) {
199                      ret[i] = data_[i];
200                  }
201                  return ret;
202              }
203          };
204      } 
205      template<int N>
206      using size_t = compatibility::size_t<N>;
207  } 
208  #endif 
209  namespace cl {
210      namespace detail {
211          using size_t_array = array<size_type, 3>;
212      } 
213  } 
214  namespace cl {
215      class Memory;
216  #define CL_HPP_INIT_CL_EXT_FCN_PTR_(name) \
217      if (!pfn_##name) {    \
218      pfn_##name = (PFN_##name) \
219      clGetExtensionFunctionAddress(#name); \
220      if (!pfn_##name) {    \
221      } \
222      }
223  #define CL_HPP_INIT_CL_EXT_FCN_PTR_PLATFORM_(platform, name) \
224      if (!pfn_##name) {    \
225      pfn_##name = (PFN_##name) \
226      clGetExtensionFunctionAddressForPlatform(platform, #name); \
227      if (!pfn_##name) {    \
228      } \
229      }
230      class Program;
231      class Device;
232      class Context;
233      class CommandQueue;
234      class DeviceCommandQueue;
235      class Memory;
236      class Buffer;
237      class Pipe;
238  #if defined(CL_HPP_ENABLE_EXCEPTIONS)
239      class Error : public std::exception
240      {
241      private:
242          cl_int err_;
243          const char * errStr_;
244      public:
245          Error(cl_int err, const char * errStr = NULL) : err_(err), errStr_(errStr)
246          {}
247          ~Error() throw() {}
248          virtual const char * what() const throw ()
249          {
250              if (errStr_ == NULL) {
251                  return "empty";
252              }
253              else {
254                  return errStr_;
255              }
256          }
257          cl_int err(void) const { return err_; }
258      };
259  #define CL_HPP_ERR_STR_(x) #x
260  #else
261  #define CL_HPP_ERR_STR_(x) NULL
262  #endif 
263  namespace detail
264  {
265  #if defined(CL_HPP_ENABLE_EXCEPTIONS)
266  static inline cl_int errHandler (
267      cl_int err,
268      const char * errStr = NULL)
269  {
270      if (err != CL_SUCCESS) {
271          throw Error(err, errStr);
272      }
273      return err;
274  }
275  #else
276  static inline cl_int errHandler (cl_int err, const char * errStr = NULL)
277  {
278      (void) errStr; 
279      return err;
280  }
281  #endif 
282  }
283  #if !defined(CL_HPP_USER_OVERRIDE_ERROR_STRINGS)
284  #define __GET_DEVICE_INFO_ERR               CL_HPP_ERR_STR_(clGetDeviceInfo)
285  #define __GET_PLATFORM_INFO_ERR             CL_HPP_ERR_STR_(clGetPlatformInfo)
286  #define __GET_DEVICE_IDS_ERR                CL_HPP_ERR_STR_(clGetDeviceIDs)
287  #define __GET_PLATFORM_IDS_ERR              CL_HPP_ERR_STR_(clGetPlatformIDs)
288  #define __GET_CONTEXT_INFO_ERR              CL_HPP_ERR_STR_(clGetContextInfo)
289  #define __GET_EVENT_INFO_ERR                CL_HPP_ERR_STR_(clGetEventInfo)
290  #define __GET_EVENT_PROFILE_INFO_ERR        CL_HPP_ERR_STR_(clGetEventProfileInfo)
291  #define __GET_MEM_OBJECT_INFO_ERR           CL_HPP_ERR_STR_(clGetMemObjectInfo)
292  #define __GET_IMAGE_INFO_ERR                CL_HPP_ERR_STR_(clGetImageInfo)
293  #define __GET_SAMPLER_INFO_ERR              CL_HPP_ERR_STR_(clGetSamplerInfo)
294  #define __GET_KERNEL_INFO_ERR               CL_HPP_ERR_STR_(clGetKernelInfo)
295  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
296  #define __GET_KERNEL_ARG_INFO_ERR           CL_HPP_ERR_STR_(clGetKernelArgInfo)
297  #endif 
298  #define __GET_KERNEL_WORK_GROUP_INFO_ERR    CL_HPP_ERR_STR_(clGetKernelWorkGroupInfo)
299  #define __GET_PROGRAM_INFO_ERR              CL_HPP_ERR_STR_(clGetProgramInfo)
300  #define __GET_PROGRAM_BUILD_INFO_ERR        CL_HPP_ERR_STR_(clGetProgramBuildInfo)
301  #define __GET_COMMAND_QUEUE_INFO_ERR        CL_HPP_ERR_STR_(clGetCommandQueueInfo)
302  #define __CREATE_CONTEXT_ERR                CL_HPP_ERR_STR_(clCreateContext)
303  #define __CREATE_CONTEXT_FROM_TYPE_ERR      CL_HPP_ERR_STR_(clCreateContextFromType)
304  #define __GET_SUPPORTED_IMAGE_FORMATS_ERR   CL_HPP_ERR_STR_(clGetSupportedImageFormats)
305  #define __CREATE_BUFFER_ERR                 CL_HPP_ERR_STR_(clCreateBuffer)
306  #define __COPY_ERR                          CL_HPP_ERR_STR_(cl::copy)
307  #define __CREATE_SUBBUFFER_ERR              CL_HPP_ERR_STR_(clCreateSubBuffer)
308  #define __CREATE_GL_BUFFER_ERR              CL_HPP_ERR_STR_(clCreateFromGLBuffer)
309  #define __CREATE_GL_RENDER_BUFFER_ERR       CL_HPP_ERR_STR_(clCreateFromGLBuffer)
310  #define __GET_GL_OBJECT_INFO_ERR            CL_HPP_ERR_STR_(clGetGLObjectInfo)
311  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
312  #define __CREATE_IMAGE_ERR                  CL_HPP_ERR_STR_(clCreateImage)
313  #define __CREATE_GL_TEXTURE_ERR             CL_HPP_ERR_STR_(clCreateFromGLTexture)
314  #define __IMAGE_DIMENSION_ERR               CL_HPP_ERR_STR_(Incorrect image dimensions)
315  #endif 
316  #define __SET_MEM_OBJECT_DESTRUCTOR_CALLBACK_ERR CL_HPP_ERR_STR_(clSetMemObjectDestructorCallback)
317  #define __CREATE_USER_EVENT_ERR             CL_HPP_ERR_STR_(clCreateUserEvent)
318  #define __SET_USER_EVENT_STATUS_ERR         CL_HPP_ERR_STR_(clSetUserEventStatus)
319  #define __SET_EVENT_CALLBACK_ERR            CL_HPP_ERR_STR_(clSetEventCallback)
320  #define __WAIT_FOR_EVENTS_ERR               CL_HPP_ERR_STR_(clWaitForEvents)
321  #define __CREATE_KERNEL_ERR                 CL_HPP_ERR_STR_(clCreateKernel)
322  #define __SET_KERNEL_ARGS_ERR               CL_HPP_ERR_STR_(clSetKernelArg)
323  #define __CREATE_PROGRAM_WITH_SOURCE_ERR    CL_HPP_ERR_STR_(clCreateProgramWithSource)
324  #define __CREATE_PROGRAM_WITH_BINARY_ERR    CL_HPP_ERR_STR_(clCreateProgramWithBinary)
325  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
326  #define __CREATE_PROGRAM_WITH_BUILT_IN_KERNELS_ERR    CL_HPP_ERR_STR_(clCreateProgramWithBuiltInKernels)
327  #endif 
328  #define __BUILD_PROGRAM_ERR                 CL_HPP_ERR_STR_(clBuildProgram)
329  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
330  #define __COMPILE_PROGRAM_ERR               CL_HPP_ERR_STR_(clCompileProgram)
331  #define __LINK_PROGRAM_ERR                  CL_HPP_ERR_STR_(clLinkProgram)
332  #endif 
333  #define __CREATE_KERNELS_IN_PROGRAM_ERR     CL_HPP_ERR_STR_(clCreateKernelsInProgram)
334  #if CL_HPP_TARGET_OPENCL_VERSION >= 200
335  #define __CREATE_COMMAND_QUEUE_WITH_PROPERTIES_ERR          CL_HPP_ERR_STR_(clCreateCommandQueueWithProperties)
336  #define __CREATE_SAMPLER_WITH_PROPERTIES_ERR                CL_HPP_ERR_STR_(clCreateSamplerWithProperties)
337  #endif 
338  #define __SET_COMMAND_QUEUE_PROPERTY_ERR    CL_HPP_ERR_STR_(clSetCommandQueueProperty)
339  #define __ENQUEUE_READ_BUFFER_ERR           CL_HPP_ERR_STR_(clEnqueueReadBuffer)
340  #define __ENQUEUE_READ_BUFFER_RECT_ERR      CL_HPP_ERR_STR_(clEnqueueReadBufferRect)
341  #define __ENQUEUE_WRITE_BUFFER_ERR          CL_HPP_ERR_STR_(clEnqueueWriteBuffer)
342  #define __ENQUEUE_WRITE_BUFFER_RECT_ERR     CL_HPP_ERR_STR_(clEnqueueWriteBufferRect)
343  #define __ENQEUE_COPY_BUFFER_ERR            CL_HPP_ERR_STR_(clEnqueueCopyBuffer)
344  #define __ENQEUE_COPY_BUFFER_RECT_ERR       CL_HPP_ERR_STR_(clEnqueueCopyBufferRect)
345  #define __ENQUEUE_FILL_BUFFER_ERR           CL_HPP_ERR_STR_(clEnqueueFillBuffer)
346  #define __ENQUEUE_READ_IMAGE_ERR            CL_HPP_ERR_STR_(clEnqueueReadImage)
347  #define __ENQUEUE_WRITE_IMAGE_ERR           CL_HPP_ERR_STR_(clEnqueueWriteImage)
348  #define __ENQUEUE_COPY_IMAGE_ERR            CL_HPP_ERR_STR_(clEnqueueCopyImage)
349  #define __ENQUEUE_FILL_IMAGE_ERR            CL_HPP_ERR_STR_(clEnqueueFillImage)
350  #define __ENQUEUE_COPY_IMAGE_TO_BUFFER_ERR  CL_HPP_ERR_STR_(clEnqueueCopyImageToBuffer)
351  #define __ENQUEUE_COPY_BUFFER_TO_IMAGE_ERR  CL_HPP_ERR_STR_(clEnqueueCopyBufferToImage)
352  #define __ENQUEUE_MAP_BUFFER_ERR            CL_HPP_ERR_STR_(clEnqueueMapBuffer)
353  #define __ENQUEUE_MAP_IMAGE_ERR             CL_HPP_ERR_STR_(clEnqueueMapImage)
354  #define __ENQUEUE_UNMAP_MEM_OBJECT_ERR      CL_HPP_ERR_STR_(clEnqueueUnMapMemObject)
355  #define __ENQUEUE_NDRANGE_KERNEL_ERR        CL_HPP_ERR_STR_(clEnqueueNDRangeKernel)
356  #define __ENQUEUE_NATIVE_KERNEL             CL_HPP_ERR_STR_(clEnqueueNativeKernel)
357  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
358  #define __ENQUEUE_MIGRATE_MEM_OBJECTS_ERR   CL_HPP_ERR_STR_(clEnqueueMigrateMemObjects)
359  #endif 
360  #define __ENQUEUE_ACQUIRE_GL_ERR            CL_HPP_ERR_STR_(clEnqueueAcquireGLObjects)
361  #define __ENQUEUE_RELEASE_GL_ERR            CL_HPP_ERR_STR_(clEnqueueReleaseGLObjects)
362  #define __CREATE_PIPE_ERR             CL_HPP_ERR_STR_(clCreatePipe)
363  #define __GET_PIPE_INFO_ERR           CL_HPP_ERR_STR_(clGetPipeInfo)
364  #define __RETAIN_ERR                        CL_HPP_ERR_STR_(Retain Object)
365  #define __RELEASE_ERR                       CL_HPP_ERR_STR_(Release Object)
366  #define __FLUSH_ERR                         CL_HPP_ERR_STR_(clFlush)
367  #define __FINISH_ERR                        CL_HPP_ERR_STR_(clFinish)
368  #define __VECTOR_CAPACITY_ERR               CL_HPP_ERR_STR_(Vector capacity error)
369  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
370  #define __CREATE_SUB_DEVICES_ERR            CL_HPP_ERR_STR_(clCreateSubDevices)
371  #else
372  #define __CREATE_SUB_DEVICES_ERR            CL_HPP_ERR_STR_(clCreateSubDevicesEXT)
373  #endif 
374  #if defined(CL_USE_DEPRECATED_OPENCL_1_1_APIS)
375  #define __ENQUEUE_MARKER_ERR                CL_HPP_ERR_STR_(clEnqueueMarker)
376  #define __ENQUEUE_WAIT_FOR_EVENTS_ERR       CL_HPP_ERR_STR_(clEnqueueWaitForEvents)
377  #define __ENQUEUE_BARRIER_ERR               CL_HPP_ERR_STR_(clEnqueueBarrier)
378  #define __UNLOAD_COMPILER_ERR               CL_HPP_ERR_STR_(clUnloadCompiler)
379  #define __CREATE_GL_TEXTURE_2D_ERR          CL_HPP_ERR_STR_(clCreateFromGLTexture2D)
380  #define __CREATE_GL_TEXTURE_3D_ERR          CL_HPP_ERR_STR_(clCreateFromGLTexture3D)
381  #define __CREATE_IMAGE2D_ERR                CL_HPP_ERR_STR_(clCreateImage2D)
382  #define __CREATE_IMAGE3D_ERR                CL_HPP_ERR_STR_(clCreateImage3D)
383  #endif 
384  #if defined(CL_USE_DEPRECATED_OPENCL_1_2_APIS)
385  #define __CREATE_COMMAND_QUEUE_ERR          CL_HPP_ERR_STR_(clCreateCommandQueue)
386  #define __ENQUEUE_TASK_ERR                  CL_HPP_ERR_STR_(clEnqueueTask)
387  #define __CREATE_SAMPLER_ERR                CL_HPP_ERR_STR_(clCreateSampler)
388  #endif 
389  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
390  #define __ENQUEUE_MARKER_WAIT_LIST_ERR                CL_HPP_ERR_STR_(clEnqueueMarkerWithWaitList)
391  #define __ENQUEUE_BARRIER_WAIT_LIST_ERR               CL_HPP_ERR_STR_(clEnqueueBarrierWithWaitList)
392  #endif 
393  #endif 
394  namespace detail {
395  template<typename Functor, typename T>
396  inline cl_int getInfoHelper(Functor f, cl_uint name, T* param, long)
397  {
398      return f(name, sizeof(T), param, NULL);
399  }
400  template <typename Func>
401  inline cl_int getInfoHelper(Func f, cl_uint name, vector<vector<unsigned char>>* param, int)
402  {
403      if (name != CL_PROGRAM_BINARIES) {
404          return CL_INVALID_VALUE;
405      }
406      if (param) {
407          size_type numBinaries = param->size();
408          vector<unsigned char*> binariesPointers(numBinaries);
409          size_type totalSize = 0;
410          for (size_type i = 0; i < numBinaries; ++i)
411          {
412              binariesPointers[i] = (*param)[i].data();
413              totalSize += (*param)[i].size();
414          }
415          cl_int err = f(name, totalSize, binariesPointers.data(), NULL);
416          if (err != CL_SUCCESS) {
417              return err;
418          }
419      }
420      return CL_SUCCESS;
421  }
422  template <typename Func, typename T>
423  inline cl_int getInfoHelper(Func f, cl_uint name, vector<T>* param, long)
424  {
425      size_type required;
426      cl_int err = f(name, 0, NULL, &required);
427      if (err != CL_SUCCESS) {
428          return err;
429      }
430      const size_type elements = required / sizeof(T);
431      vector<T> localData(elements);
432      err = f(name, required, localData.data(), NULL);
433      if (err != CL_SUCCESS) {
434          return err;
435      }
436      if (param) {
437          *param = std::move(localData);
438      }
439      return CL_SUCCESS;
440  }
441  template <typename Func, typename T>
442  inline cl_int getInfoHelper(
443      Func f, cl_uint name, vector<T>* param, int, typename T::cl_type = 0)
444  {
445      size_type required;
446      cl_int err = f(name, 0, NULL, &required);
447      if (err != CL_SUCCESS) {
448          return err;
449      }
450      const size_type elements = required / sizeof(typename T::cl_type);
451      vector<typename T::cl_type> value(elements);
452      err = f(name, required, value.data(), NULL);
453      if (err != CL_SUCCESS) {
454          return err;
455      }
456      if (param) {
457          param->resize(elements);
458          for (size_type i = 0; i < elements; i++) {
459              (*param)[i] = T(value[i], true);
460          }
461      }
462      return CL_SUCCESS;
463  }
464  template <typename Func>
465  inline cl_int getInfoHelper(Func f, cl_uint name, string* param, long)
466  {
467      size_type required;
468      cl_int err = f(name, 0, NULL, &required);
469      if (err != CL_SUCCESS) {
470          return err;
471      }
472      if (required > 0) {
473          vector<char> value(required);
474          err = f(name, required, value.data(), NULL);
475          if (err != CL_SUCCESS) {
476              return err;
477          }
478          if (param) {
479              param->assign(begin(value), prev(end(value)));
480          }
481      }
482      else if (param) {
483          param->assign("");
484      }
485      return CL_SUCCESS;
486  }
487  template <typename Func, size_type N>
488  inline cl_int getInfoHelper(Func f, cl_uint name, array<size_type, N>* param, long)
489  {
490      size_type required;
491      cl_int err = f(name, 0, NULL, &required);
492      if (err != CL_SUCCESS) {
493          return err;
494      }
495      size_type elements = required / sizeof(size_type);
496      vector<size_type> value(elements, 0);
497      err = f(name, required, value.data(), NULL);
498      if (err != CL_SUCCESS) {
499          return err;
500      }
501      if (elements > N) {
502          elements = N;
503      }
504      for (size_type i = 0; i < elements; ++i) {
505          (*param)[i] = value[i];
506      }
507      return CL_SUCCESS;
508  }
509  template<typename T> struct ReferenceHandler;
510  template<typename Func, typename T>
511  inline cl_int getInfoHelper(Func f, cl_uint name, T* param, int, typename T::cl_type = 0)
512  {
513      typename T::cl_type value;
514      cl_int err = f(name, sizeof(value), &value, NULL);
515      if (err != CL_SUCCESS) {
516          return err;
517      }
518      *param = value;
519      if (value != NULL)
520      {
521          err = param->retain();
522          if (err != CL_SUCCESS) {
523              return err;
524          }
525      }
526      return CL_SUCCESS;
527  }
528  #define CL_HPP_PARAM_NAME_INFO_1_0_(F) \
529      F(cl_platform_info, CL_PLATFORM_PROFILE, string) \
530      F(cl_platform_info, CL_PLATFORM_VERSION, string) \
531      F(cl_platform_info, CL_PLATFORM_NAME, string) \
532      F(cl_platform_info, CL_PLATFORM_VENDOR, string) \
533      F(cl_platform_info, CL_PLATFORM_EXTENSIONS, string) \
534      \
535      F(cl_device_info, CL_DEVICE_TYPE, cl_device_type) \
536      F(cl_device_info, CL_DEVICE_VENDOR_ID, cl_uint) \
537      F(cl_device_info, CL_DEVICE_MAX_COMPUTE_UNITS, cl_uint) \
538      F(cl_device_info, CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS, cl_uint) \
539      F(cl_device_info, CL_DEVICE_MAX_WORK_GROUP_SIZE, size_type) \
540      F(cl_device_info, CL_DEVICE_MAX_WORK_ITEM_SIZES, cl::vector<size_type>) \
541      F(cl_device_info, CL_DEVICE_PREFERRED_VECTOR_WIDTH_CHAR, cl_uint) \
542      F(cl_device_info, CL_DEVICE_PREFERRED_VECTOR_WIDTH_SHORT, cl_uint) \
543      F(cl_device_info, CL_DEVICE_PREFERRED_VECTOR_WIDTH_INT, cl_uint) \
544      F(cl_device_info, CL_DEVICE_PREFERRED_VECTOR_WIDTH_LONG, cl_uint) \
545      F(cl_device_info, CL_DEVICE_PREFERRED_VECTOR_WIDTH_FLOAT, cl_uint) \
546      F(cl_device_info, CL_DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE, cl_uint) \
547      F(cl_device_info, CL_DEVICE_MAX_CLOCK_FREQUENCY, cl_uint) \
548      F(cl_device_info, CL_DEVICE_ADDRESS_BITS, cl_uint) \
549      F(cl_device_info, CL_DEVICE_MAX_READ_IMAGE_ARGS, cl_uint) \
550      F(cl_device_info, CL_DEVICE_MAX_WRITE_IMAGE_ARGS, cl_uint) \
551      F(cl_device_info, CL_DEVICE_MAX_MEM_ALLOC_SIZE, cl_ulong) \
552      F(cl_device_info, CL_DEVICE_IMAGE2D_MAX_WIDTH, size_type) \
553      F(cl_device_info, CL_DEVICE_IMAGE2D_MAX_HEIGHT, size_type) \
554      F(cl_device_info, CL_DEVICE_IMAGE3D_MAX_WIDTH, size_type) \
555      F(cl_device_info, CL_DEVICE_IMAGE3D_MAX_HEIGHT, size_type) \
556      F(cl_device_info, CL_DEVICE_IMAGE3D_MAX_DEPTH, size_type) \
557      F(cl_device_info, CL_DEVICE_IMAGE_SUPPORT, cl_bool) \
558      F(cl_device_info, CL_DEVICE_MAX_PARAMETER_SIZE, size_type) \
559      F(cl_device_info, CL_DEVICE_MAX_SAMPLERS, cl_uint) \
560      F(cl_device_info, CL_DEVICE_MEM_BASE_ADDR_ALIGN, cl_uint) \
561      F(cl_device_info, CL_DEVICE_MIN_DATA_TYPE_ALIGN_SIZE, cl_uint) \
562      F(cl_device_info, CL_DEVICE_SINGLE_FP_CONFIG, cl_device_fp_config) \
563      F(cl_device_info, CL_DEVICE_GLOBAL_MEM_CACHE_TYPE, cl_device_mem_cache_type) \
564      F(cl_device_info, CL_DEVICE_GLOBAL_MEM_CACHELINE_SIZE, cl_uint)\
565      F(cl_device_info, CL_DEVICE_GLOBAL_MEM_CACHE_SIZE, cl_ulong) \
566      F(cl_device_info, CL_DEVICE_GLOBAL_MEM_SIZE, cl_ulong) \
567      F(cl_device_info, CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE, cl_ulong) \
568      F(cl_device_info, CL_DEVICE_MAX_CONSTANT_ARGS, cl_uint) \
569      F(cl_device_info, CL_DEVICE_LOCAL_MEM_TYPE, cl_device_local_mem_type) \
570      F(cl_device_info, CL_DEVICE_LOCAL_MEM_SIZE, cl_ulong) \
571      F(cl_device_info, CL_DEVICE_ERROR_CORRECTION_SUPPORT, cl_bool) \
572      F(cl_device_info, CL_DEVICE_PROFILING_TIMER_RESOLUTION, size_type) \
573      F(cl_device_info, CL_DEVICE_ENDIAN_LITTLE, cl_bool) \
574      F(cl_device_info, CL_DEVICE_AVAILABLE, cl_bool) \
575      F(cl_device_info, CL_DEVICE_COMPILER_AVAILABLE, cl_bool) \
576      F(cl_device_info, CL_DEVICE_EXECUTION_CAPABILITIES, cl_device_exec_capabilities) \
577      F(cl_device_info, CL_DEVICE_PLATFORM, cl_platform_id) \
578      F(cl_device_info, CL_DEVICE_NAME, string) \
579      F(cl_device_info, CL_DEVICE_VENDOR, string) \
580      F(cl_device_info, CL_DRIVER_VERSION, string) \
581      F(cl_device_info, CL_DEVICE_PROFILE, string) \
582      F(cl_device_info, CL_DEVICE_VERSION, string) \
583      F(cl_device_info, CL_DEVICE_EXTENSIONS, string) \
584      \
585      F(cl_context_info, CL_CONTEXT_REFERENCE_COUNT, cl_uint) \
586      F(cl_context_info, CL_CONTEXT_DEVICES, cl::vector<Device>) \
587      F(cl_context_info, CL_CONTEXT_PROPERTIES, cl::vector<cl_context_properties>) \
588      \
589      F(cl_event_info, CL_EVENT_COMMAND_QUEUE, cl::CommandQueue) \
590      F(cl_event_info, CL_EVENT_COMMAND_TYPE, cl_command_type) \
591      F(cl_event_info, CL_EVENT_REFERENCE_COUNT, cl_uint) \
592      F(cl_event_info, CL_EVENT_COMMAND_EXECUTION_STATUS, cl_int) \
593      \
594      F(cl_profiling_info, CL_PROFILING_COMMAND_QUEUED, cl_ulong) \
595      F(cl_profiling_info, CL_PROFILING_COMMAND_SUBMIT, cl_ulong) \
596      F(cl_profiling_info, CL_PROFILING_COMMAND_START, cl_ulong) \
597      F(cl_profiling_info, CL_PROFILING_COMMAND_END, cl_ulong) \
598      \
599      F(cl_mem_info, CL_MEM_TYPE, cl_mem_object_type) \
600      F(cl_mem_info, CL_MEM_FLAGS, cl_mem_flags) \
601      F(cl_mem_info, CL_MEM_SIZE, size_type) \
602      F(cl_mem_info, CL_MEM_HOST_PTR, void*) \
603      F(cl_mem_info, CL_MEM_MAP_COUNT, cl_uint) \
604      F(cl_mem_info, CL_MEM_REFERENCE_COUNT, cl_uint) \
605      F(cl_mem_info, CL_MEM_CONTEXT, cl::Context) \
606      \
607      F(cl_image_info, CL_IMAGE_FORMAT, cl_image_format) \
608      F(cl_image_info, CL_IMAGE_ELEMENT_SIZE, size_type) \
609      F(cl_image_info, CL_IMAGE_ROW_PITCH, size_type) \
610      F(cl_image_info, CL_IMAGE_SLICE_PITCH, size_type) \
611      F(cl_image_info, CL_IMAGE_WIDTH, size_type) \
612      F(cl_image_info, CL_IMAGE_HEIGHT, size_type) \
613      F(cl_image_info, CL_IMAGE_DEPTH, size_type) \
614      F(cl_image_info, CL_IMAGE_ARRAY_SIZE, size_type) \
615      F(cl_image_info, CL_IMAGE_NUM_MIP_LEVELS, cl_uint) \
616      F(cl_image_info, CL_IMAGE_NUM_SAMPLES, cl_uint) \
617      \
618      F(cl_sampler_info, CL_SAMPLER_REFERENCE_COUNT, cl_uint) \
619      F(cl_sampler_info, CL_SAMPLER_CONTEXT, cl::Context) \
620      F(cl_sampler_info, CL_SAMPLER_NORMALIZED_COORDS, cl_bool) \
621      F(cl_sampler_info, CL_SAMPLER_ADDRESSING_MODE, cl_addressing_mode) \
622      F(cl_sampler_info, CL_SAMPLER_FILTER_MODE, cl_filter_mode) \
623      \
624      F(cl_program_info, CL_PROGRAM_REFERENCE_COUNT, cl_uint) \
625      F(cl_program_info, CL_PROGRAM_CONTEXT, cl::Context) \
626      F(cl_program_info, CL_PROGRAM_NUM_DEVICES, cl_uint) \
627      F(cl_program_info, CL_PROGRAM_DEVICES, cl::vector<Device>) \
628      F(cl_program_info, CL_PROGRAM_SOURCE, string) \
629      F(cl_program_info, CL_PROGRAM_BINARY_SIZES, cl::vector<size_type>) \
630      F(cl_program_info, CL_PROGRAM_BINARIES, cl::vector<cl::vector<unsigned char>>) \
631      \
632      F(cl_program_build_info, CL_PROGRAM_BUILD_STATUS, cl_build_status) \
633      F(cl_program_build_info, CL_PROGRAM_BUILD_OPTIONS, string) \
634      F(cl_program_build_info, CL_PROGRAM_BUILD_LOG, string) \
635      \
636      F(cl_kernel_info, CL_KERNEL_FUNCTION_NAME, string) \
637      F(cl_kernel_info, CL_KERNEL_NUM_ARGS, cl_uint) \
638      F(cl_kernel_info, CL_KERNEL_REFERENCE_COUNT, cl_uint) \
639      F(cl_kernel_info, CL_KERNEL_CONTEXT, cl::Context) \
640      F(cl_kernel_info, CL_KERNEL_PROGRAM, cl::Program) \
641      \
642      F(cl_kernel_work_group_info, CL_KERNEL_WORK_GROUP_SIZE, size_type) \
643      F(cl_kernel_work_group_info, CL_KERNEL_COMPILE_WORK_GROUP_SIZE, cl::detail::size_t_array) \
644      F(cl_kernel_work_group_info, CL_KERNEL_LOCAL_MEM_SIZE, cl_ulong) \
645      \
646      F(cl_command_queue_info, CL_QUEUE_CONTEXT, cl::Context) \
647      F(cl_command_queue_info, CL_QUEUE_DEVICE, cl::Device) \
648      F(cl_command_queue_info, CL_QUEUE_REFERENCE_COUNT, cl_uint) \
649      F(cl_command_queue_info, CL_QUEUE_PROPERTIES, cl_command_queue_properties)
650  #define CL_HPP_PARAM_NAME_INFO_1_1_(F) \
651      F(cl_context_info, CL_CONTEXT_NUM_DEVICES, cl_uint)\
652      F(cl_device_info, CL_DEVICE_PREFERRED_VECTOR_WIDTH_HALF, cl_uint) \
653      F(cl_device_info, CL_DEVICE_NATIVE_VECTOR_WIDTH_CHAR, cl_uint) \
654      F(cl_device_info, CL_DEVICE_NATIVE_VECTOR_WIDTH_SHORT, cl_uint) \
655      F(cl_device_info, CL_DEVICE_NATIVE_VECTOR_WIDTH_INT, cl_uint) \
656      F(cl_device_info, CL_DEVICE_NATIVE_VECTOR_WIDTH_LONG, cl_uint) \
657      F(cl_device_info, CL_DEVICE_NATIVE_VECTOR_WIDTH_FLOAT, cl_uint) \
658      F(cl_device_info, CL_DEVICE_NATIVE_VECTOR_WIDTH_DOUBLE, cl_uint) \
659      F(cl_device_info, CL_DEVICE_NATIVE_VECTOR_WIDTH_HALF, cl_uint) \
660      F(cl_device_info, CL_DEVICE_DOUBLE_FP_CONFIG, cl_device_fp_config) \
661      F(cl_device_info, CL_DEVICE_HALF_FP_CONFIG, cl_device_fp_config) \
662      F(cl_device_info, CL_DEVICE_OPENCL_C_VERSION, string) \
663      \
664      F(cl_mem_info, CL_MEM_ASSOCIATED_MEMOBJECT, cl::Memory) \
665      F(cl_mem_info, CL_MEM_OFFSET, size_type) \
666      \
667      F(cl_kernel_work_group_info, CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE, size_type) \
668      F(cl_kernel_work_group_info, CL_KERNEL_PRIVATE_MEM_SIZE, cl_ulong) \
669      \
670      F(cl_event_info, CL_EVENT_CONTEXT, cl::Context)
671  #define CL_HPP_PARAM_NAME_INFO_1_2_(F) \
672      F(cl_program_info, CL_PROGRAM_NUM_KERNELS, size_type) \
673      F(cl_program_info, CL_PROGRAM_KERNEL_NAMES, string) \
674      \
675      F(cl_program_build_info, CL_PROGRAM_BINARY_TYPE, cl_program_binary_type) \
676      \
677      F(cl_kernel_info, CL_KERNEL_ATTRIBUTES, string) \
678      \
679      F(cl_kernel_arg_info, CL_KERNEL_ARG_ADDRESS_QUALIFIER, cl_kernel_arg_address_qualifier) \
680      F(cl_kernel_arg_info, CL_KERNEL_ARG_ACCESS_QUALIFIER, cl_kernel_arg_access_qualifier) \
681      F(cl_kernel_arg_info, CL_KERNEL_ARG_TYPE_NAME, string) \
682      F(cl_kernel_arg_info, CL_KERNEL_ARG_NAME, string) \
683      F(cl_kernel_arg_info, CL_KERNEL_ARG_TYPE_QUALIFIER, cl_kernel_arg_type_qualifier) \
684      \
685      F(cl_device_info, CL_DEVICE_PARENT_DEVICE, cl::Device) \
686      F(cl_device_info, CL_DEVICE_PARTITION_PROPERTIES, cl::vector<cl_device_partition_property>) \
687      F(cl_device_info, CL_DEVICE_PARTITION_TYPE, cl::vector<cl_device_partition_property>)  \
688      F(cl_device_info, CL_DEVICE_REFERENCE_COUNT, cl_uint) \
689      F(cl_device_info, CL_DEVICE_PREFERRED_INTEROP_USER_SYNC, size_type) \
690      F(cl_device_info, CL_DEVICE_PARTITION_AFFINITY_DOMAIN, cl_device_affinity_domain) \
691      F(cl_device_info, CL_DEVICE_BUILT_IN_KERNELS, string)
692  #define CL_HPP_PARAM_NAME_INFO_2_0_(F) \
693      F(cl_device_info, CL_DEVICE_QUEUE_ON_HOST_PROPERTIES, cl_command_queue_properties) \
694      F(cl_device_info, CL_DEVICE_QUEUE_ON_DEVICE_PROPERTIES, cl_command_queue_properties) \
695      F(cl_device_info, CL_DEVICE_QUEUE_ON_DEVICE_PREFERRED_SIZE, cl_uint) \
696      F(cl_device_info, CL_DEVICE_QUEUE_ON_DEVICE_MAX_SIZE, cl_uint) \
697      F(cl_device_info, CL_DEVICE_MAX_ON_DEVICE_QUEUES, cl_uint) \
698      F(cl_device_info, CL_DEVICE_MAX_ON_DEVICE_EVENTS, cl_uint) \
699      F(cl_device_info, CL_DEVICE_MAX_PIPE_ARGS, cl_uint) \
700      F(cl_device_info, CL_DEVICE_PIPE_MAX_ACTIVE_RESERVATIONS, cl_uint) \
701      F(cl_device_info, CL_DEVICE_PIPE_MAX_PACKET_SIZE, cl_uint) \
702      F(cl_device_info, CL_DEVICE_SVM_CAPABILITIES, cl_device_svm_capabilities) \
703      F(cl_device_info, CL_DEVICE_PREFERRED_PLATFORM_ATOMIC_ALIGNMENT, cl_uint) \
704      F(cl_device_info, CL_DEVICE_PREFERRED_GLOBAL_ATOMIC_ALIGNMENT, cl_uint) \
705      F(cl_device_info, CL_DEVICE_PREFERRED_LOCAL_ATOMIC_ALIGNMENT, cl_uint) \
706      F(cl_command_queue_info, CL_QUEUE_SIZE, cl_uint) \
707      F(cl_mem_info, CL_MEM_USES_SVM_POINTER, cl_bool) \
708      F(cl_program_build_info, CL_PROGRAM_BUILD_GLOBAL_VARIABLE_TOTAL_SIZE, size_type) \
709      F(cl_pipe_info, CL_PIPE_PACKET_SIZE, cl_uint) \
710      F(cl_pipe_info, CL_PIPE_MAX_PACKETS, cl_uint)
711  #define CL_HPP_PARAM_NAME_DEVICE_FISSION_(F) \
712      F(cl_device_info, CL_DEVICE_PARENT_DEVICE_EXT, cl_device_id) \
713      F(cl_device_info, CL_DEVICE_PARTITION_TYPES_EXT, cl::vector<cl_device_partition_property_ext>) \
714      F(cl_device_info, CL_DEVICE_AFFINITY_DOMAINS_EXT, cl::vector<cl_device_partition_property_ext>) \
715      F(cl_device_info, CL_DEVICE_REFERENCE_COUNT_EXT , cl_uint) \
716      F(cl_device_info, CL_DEVICE_PARTITION_STYLE_EXT, cl::vector<cl_device_partition_property_ext>)
717  template <typename enum_type, cl_int Name>
718  struct param_traits {};
719  #define CL_HPP_DECLARE_PARAM_TRAITS_(token, param_name, T) \
720  struct token;                                        \
721  template<>                                           \
722  struct param_traits<detail:: token,param_name>       \
723  {                                                    \
724      enum { value = param_name };                     \
725      typedef T param_type;                            \
726  };
727  CL_HPP_PARAM_NAME_INFO_1_0_(CL_HPP_DECLARE_PARAM_TRAITS_)
728  #if CL_HPP_TARGET_OPENCL_VERSION >= 110
729  CL_HPP_PARAM_NAME_INFO_1_1_(CL_HPP_DECLARE_PARAM_TRAITS_)
730  #endif 
731  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
732  CL_HPP_PARAM_NAME_INFO_1_2_(CL_HPP_DECLARE_PARAM_TRAITS_)
733  #endif 
734  #if CL_HPP_TARGET_OPENCL_VERSION >= 200
735  CL_HPP_PARAM_NAME_INFO_2_0_(CL_HPP_DECLARE_PARAM_TRAITS_)
736  #endif 
737  #define CL_HPP_PARAM_NAME_INFO_1_0_DEPRECATED_IN_2_0_(F) \
738      F(cl_device_info, CL_DEVICE_QUEUE_PROPERTIES, cl_command_queue_properties)
739  #define CL_HPP_PARAM_NAME_INFO_1_1_DEPRECATED_IN_2_0_(F) \
740      F(cl_device_info, CL_DEVICE_HOST_UNIFIED_MEMORY, cl_bool)
741  #define CL_HPP_PARAM_NAME_INFO_1_2_DEPRECATED_IN_2_0_(F) \
742      F(cl_image_info, CL_IMAGE_BUFFER, cl::Buffer)
743  #if CL_HPP_TARGET_OPENCL_VERSION > 100 && CL_HPP_MINIMUM_OPENCL_VERSION < 200 && CL_HPP_TARGET_OPENCL_VERSION < 200
744  CL_HPP_PARAM_NAME_INFO_1_0_DEPRECATED_IN_2_0_(CL_HPP_DECLARE_PARAM_TRAITS_)
745  #endif 
746  #if CL_HPP_TARGET_OPENCL_VERSION > 110 && CL_HPP_MINIMUM_OPENCL_VERSION < 200
747  CL_HPP_PARAM_NAME_INFO_1_1_DEPRECATED_IN_2_0_(CL_HPP_DECLARE_PARAM_TRAITS_)
748  #endif 
749  #if CL_HPP_TARGET_OPENCL_VERSION > 120 && CL_HPP_MINIMUM_OPENCL_VERSION < 200
750  CL_HPP_PARAM_NAME_INFO_1_2_DEPRECATED_IN_2_0_(CL_HPP_DECLARE_PARAM_TRAITS_)
751  #endif 
752  #if defined(CL_HPP_USE_CL_DEVICE_FISSION)
753  CL_HPP_PARAM_NAME_DEVICE_FISSION_(CL_HPP_DECLARE_PARAM_TRAITS_);
754  #endif 
755  #ifdef CL_PLATFORM_ICD_SUFFIX_KHR
756  CL_HPP_DECLARE_PARAM_TRAITS_(cl_platform_info, CL_PLATFORM_ICD_SUFFIX_KHR, string)
757  #endif
758  #ifdef CL_DEVICE_PROFILING_TIMER_OFFSET_AMD
759  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_PROFILING_TIMER_OFFSET_AMD, cl_ulong)
760  #endif
761  #ifdef CL_DEVICE_GLOBAL_FREE_MEMORY_AMD
762  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_GLOBAL_FREE_MEMORY_AMD, vector<size_type>)
763  #endif
764  #ifdef CL_DEVICE_SIMD_PER_COMPUTE_UNIT_AMD
765  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_SIMD_PER_COMPUTE_UNIT_AMD, cl_uint)
766  #endif
767  #ifdef CL_DEVICE_SIMD_WIDTH_AMD
768  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_SIMD_WIDTH_AMD, cl_uint)
769  #endif
770  #ifdef CL_DEVICE_SIMD_INSTRUCTION_WIDTH_AMD
771  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_SIMD_INSTRUCTION_WIDTH_AMD, cl_uint)
772  #endif
773  #ifdef CL_DEVICE_WAVEFRONT_WIDTH_AMD
774  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_WAVEFRONT_WIDTH_AMD, cl_uint)
775  #endif
776  #ifdef CL_DEVICE_GLOBAL_MEM_CHANNELS_AMD
777  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_GLOBAL_MEM_CHANNELS_AMD, cl_uint)
778  #endif
779  #ifdef CL_DEVICE_GLOBAL_MEM_CHANNEL_BANKS_AMD
780  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_GLOBAL_MEM_CHANNEL_BANKS_AMD, cl_uint)
781  #endif
782  #ifdef CL_DEVICE_GLOBAL_MEM_CHANNEL_BANK_WIDTH_AMD
783  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_GLOBAL_MEM_CHANNEL_BANK_WIDTH_AMD, cl_uint)
784  #endif
785  #ifdef CL_DEVICE_LOCAL_MEM_SIZE_PER_COMPUTE_UNIT_AMD
786  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_LOCAL_MEM_SIZE_PER_COMPUTE_UNIT_AMD, cl_uint)
787  #endif
788  #ifdef CL_DEVICE_LOCAL_MEM_BANKS_AMD
789  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_LOCAL_MEM_BANKS_AMD, cl_uint)
790  #endif
791  #ifdef CL_DEVICE_COMPUTE_CAPABILITY_MAJOR_NV
792  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_COMPUTE_CAPABILITY_MAJOR_NV, cl_uint)
793  #endif
794  #ifdef CL_DEVICE_COMPUTE_CAPABILITY_MINOR_NV
795  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_COMPUTE_CAPABILITY_MINOR_NV, cl_uint)
796  #endif
797  #ifdef CL_DEVICE_REGISTERS_PER_BLOCK_NV
798  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_REGISTERS_PER_BLOCK_NV, cl_uint)
799  #endif
800  #ifdef CL_DEVICE_WARP_SIZE_NV
801  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_WARP_SIZE_NV, cl_uint)
802  #endif
803  #ifdef CL_DEVICE_GPU_OVERLAP_NV
804  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_GPU_OVERLAP_NV, cl_bool)
805  #endif
806  #ifdef CL_DEVICE_KERNEL_EXEC_TIMEOUT_NV
807  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_KERNEL_EXEC_TIMEOUT_NV, cl_bool)
808  #endif
809  #ifdef CL_DEVICE_INTEGRATED_MEMORY_NV
810  CL_HPP_DECLARE_PARAM_TRAITS_(cl_device_info, CL_DEVICE_INTEGRATED_MEMORY_NV, cl_bool)
811  #endif
812  template <typename Func, typename T>
813  inline cl_int
814  getInfo(Func f, cl_uint name, T* param)
815  {
816      return getInfoHelper(f, name, param, 0);
817  }
818  template <typename Func, typename Arg0>
819  struct GetInfoFunctor0
820  {
821      Func f_; const Arg0& arg0_;
822      cl_int operator ()(
823          cl_uint param, size_type size, void* value, size_type* size_ret)
824      { return f_(arg0_, param, size, value, size_ret); }
825  };
826  template <typename Func, typename Arg0, typename Arg1>
827  struct GetInfoFunctor1
828  {
829      Func f_; const Arg0& arg0_; const Arg1& arg1_;
830      cl_int operator ()(
831          cl_uint param, size_type size, void* value, size_type* size_ret)
832      { return f_(arg0_, arg1_, param, size, value, size_ret); }
833  };
834  template <typename Func, typename Arg0, typename T>
835  inline cl_int
836  getInfo(Func f, const Arg0& arg0, cl_uint name, T* param)
837  {
838      GetInfoFunctor0<Func, Arg0> f0 = { f, arg0 };
839      return getInfoHelper(f0, name, param, 0);
840  }
841  template <typename Func, typename Arg0, typename Arg1, typename T>
842  inline cl_int
843  getInfo(Func f, const Arg0& arg0, const Arg1& arg1, cl_uint name, T* param)
844  {
845      GetInfoFunctor1<Func, Arg0, Arg1> f0 = { f, arg0, arg1 };
846      return getInfoHelper(f0, name, param, 0);
847  }
848  template<typename T>
849  struct ReferenceHandler
850  { };
851  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
852  template <>
853  struct ReferenceHandler<cl_device_id>
854  {
855      static cl_int retain(cl_device_id device)
856      { return ::clRetainDevice(device); }
857      static cl_int release(cl_device_id device)
858      { return ::clReleaseDevice(device); }
859  };
860  #else 
861  template <>
862  struct ReferenceHandler<cl_device_id>
863  {
864      static cl_int retain(cl_device_id)
865      { return CL_SUCCESS; }
866      static cl_int release(cl_device_id)
867      { return CL_SUCCESS; }
868  };
869  #endif 
870  template <>
871  struct ReferenceHandler<cl_platform_id>
872  {
873      static cl_int retain(cl_platform_id)
874      { return CL_SUCCESS; }
875      static cl_int release(cl_platform_id)
876      { return CL_SUCCESS; }
877  };
878  template <>
879  struct ReferenceHandler<cl_context>
880  {
881      static cl_int retain(cl_context context)
882      { return ::clRetainContext(context); }
883      static cl_int release(cl_context context)
884      { return ::clReleaseContext(context); }
885  };
886  template <>
887  struct ReferenceHandler<cl_command_queue>
888  {
889      static cl_int retain(cl_command_queue queue)
890      { return ::clRetainCommandQueue(queue); }
891      static cl_int release(cl_command_queue queue)
892      { return ::clReleaseCommandQueue(queue); }
893  };
894  template <>
895  struct ReferenceHandler<cl_mem>
896  {
897      static cl_int retain(cl_mem memory)
898      { return ::clRetainMemObject(memory); }
899      static cl_int release(cl_mem memory)
900      { return ::clReleaseMemObject(memory); }
901  };
902  template <>
903  struct ReferenceHandler<cl_sampler>
904  {
905      static cl_int retain(cl_sampler sampler)
906      { return ::clRetainSampler(sampler); }
907      static cl_int release(cl_sampler sampler)
908      { return ::clReleaseSampler(sampler); }
909  };
910  template <>
911  struct ReferenceHandler<cl_program>
912  {
913      static cl_int retain(cl_program program)
914      { return ::clRetainProgram(program); }
915      static cl_int release(cl_program program)
916      { return ::clReleaseProgram(program); }
917  };
918  template <>
919  struct ReferenceHandler<cl_kernel>
920  {
921      static cl_int retain(cl_kernel kernel)
922      { return ::clRetainKernel(kernel); }
923      static cl_int release(cl_kernel kernel)
924      { return ::clReleaseKernel(kernel); }
925  };
926  template <>
927  struct ReferenceHandler<cl_event>
928  {
929      static cl_int retain(cl_event event)
930      { return ::clRetainEvent(event); }
931      static cl_int release(cl_event event)
932      { return ::clReleaseEvent(event); }
933  };
934  static cl_uint getVersion(const vector<char> &versionInfo)
935  {
936      int highVersion = 0;
937      int lowVersion = 0;
938      int index = 7;
939      while(versionInfo[index] != '.' ) {
940          highVersion *= 10;
941          highVersion += versionInfo[index]-'0';
942          ++index;
943      }
944      ++index;
945      while(versionInfo[index] != ' ' &&  versionInfo[index] != '\0') {
946          lowVersion *= 10;
947          lowVersion += versionInfo[index]-'0';
948          ++index;
949      }
950      return (highVersion << 16) | lowVersion;
951  }
952  #if CL_HPP_TARGET_OPENCL_VERSION >= 120 && CL_HPP_MINIMUM_OPENCL_VERSION < 120
953  static cl_uint getPlatformVersion(cl_platform_id platform)
954  {
955      size_type size = 0;
956      clGetPlatformInfo(platform, CL_PLATFORM_VERSION, 0, NULL, &size);
957      vector<char> versionInfo(size);
958      clGetPlatformInfo(platform, CL_PLATFORM_VERSION, size, versionInfo.data(), &size);
959      return getVersion(versionInfo);
960  }
961  static cl_uint getDevicePlatformVersion(cl_device_id device)
962  {
963      cl_platform_id platform;
964      clGetDeviceInfo(device, CL_DEVICE_PLATFORM, sizeof(platform), &platform, NULL);
965      return getPlatformVersion(platform);
966  }
967  static cl_uint getContextPlatformVersion(cl_context context)
968  {
969      size_type size = 0;
970      clGetContextInfo(context, CL_CONTEXT_DEVICES, 0, NULL, &size);
971      if (size == 0)
972          return 0;
973      vector<cl_device_id> devices(size/sizeof(cl_device_id));
974      clGetContextInfo(context, CL_CONTEXT_DEVICES, size, devices.data(), NULL);
975      return getDevicePlatformVersion(devices[0]);
976  }
977  #endif 
978  template <typename T>
979  class Wrapper
980  {
981  public:
982      typedef T cl_type;
983  protected:
984      cl_type object_;
985  public:
986      Wrapper() : object_(NULL) { }
987      Wrapper(const cl_type &obj, bool retainObject) : object_(obj) 
988      {
989          if (retainObject) { 
990              detail::errHandler(retain(), __RETAIN_ERR); 
991          }
992      }
993      ~Wrapper()
994      {
995          if (object_ != NULL) { release(); }
996      }
997      Wrapper(const Wrapper<cl_type>& rhs)
998      {
999          object_ = rhs.object_;
1000          detail::errHandler(retain(), __RETAIN_ERR);
1001      }
1002      Wrapper(Wrapper<cl_type>&& rhs) CL_HPP_NOEXCEPT_
1003      {
1004          object_ = rhs.object_;
1005          rhs.object_ = NULL;
1006      }
1007      Wrapper<cl_type>& operator = (const Wrapper<cl_type>& rhs)
1008      {
1009          if (this != &rhs) {
1010              detail::errHandler(release(), __RELEASE_ERR);
1011              object_ = rhs.object_;
1012              detail::errHandler(retain(), __RETAIN_ERR);
1013          }
1014          return *this;
1015      }
1016      Wrapper<cl_type>& operator = (Wrapper<cl_type>&& rhs)
1017      {
1018          if (this != &rhs) {
1019              detail::errHandler(release(), __RELEASE_ERR);
1020              object_ = rhs.object_;
1021              rhs.object_ = NULL;
1022          }
1023          return *this;
1024      }
1025      Wrapper<cl_type>& operator = (const cl_type &rhs)
1026      {
1027          detail::errHandler(release(), __RELEASE_ERR);
1028          object_ = rhs;
1029          return *this;
1030      }
1031      const cl_type& operator ()() const { return object_; }
1032      cl_type& operator ()() { return object_; }
1033      const cl_type get() const { return object_; }
1034      cl_type get() { return object_; }
1035  protected:
1036      template<typename Func, typename U>
1037      friend inline cl_int getInfoHelper(Func, cl_uint, U*, int, typename U::cl_type);
1038      cl_int retain() const
1039      {
1040          if (object_ != nullptr) {
1041              return ReferenceHandler<cl_type>::retain(object_);
1042          }
1043          else {
1044              return CL_SUCCESS;
1045          }
1046      }
1047      cl_int release() const
1048      {
1049          if (object_ != nullptr) {
1050              return ReferenceHandler<cl_type>::release(object_);
1051          }
1052          else {
1053              return CL_SUCCESS;
1054          }
1055      }
1056  };
1057  template <>
1058  class Wrapper<cl_device_id>
1059  {
1060  public:
1061      typedef cl_device_id cl_type;
1062  protected:
1063      cl_type object_;
1064      bool referenceCountable_;
1065      static bool isReferenceCountable(cl_device_id device)
1066      {
1067          bool retVal = false;
1068  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
1069  #if CL_HPP_MINIMUM_OPENCL_VERSION < 120
1070          if (device != NULL) {
1071              int version = getDevicePlatformVersion(device);
1072              if(version > ((1 << 16) + 1)) {
1073                  retVal = true;
1074              }
1075          }
1076  #else 
1077          retVal = true;
1078  #endif 
1079  #endif 
1080          return retVal;
1081      }
1082  public:
1083      Wrapper() : object_(NULL), referenceCountable_(false) 
1084      { 
1085      }
1086      Wrapper(const cl_type &obj, bool retainObject) : 
1087          object_(obj), 
1088          referenceCountable_(false) 
1089      {
1090          referenceCountable_ = isReferenceCountable(obj); 
1091          if (retainObject) {
1092              detail::errHandler(retain(), __RETAIN_ERR);
1093          }
1094      }
1095      ~Wrapper()
1096      {
1097          release();
1098      }
1099      Wrapper(const Wrapper<cl_type>& rhs)
1100      {
1101          object_ = rhs.object_;
1102          referenceCountable_ = isReferenceCountable(object_); 
1103          detail::errHandler(retain(), __RETAIN_ERR);
1104      }
1105      Wrapper(Wrapper<cl_type>&& rhs) CL_HPP_NOEXCEPT_
1106      {
1107          object_ = rhs.object_;
1108          referenceCountable_ = rhs.referenceCountable_;
1109          rhs.object_ = NULL;
1110          rhs.referenceCountable_ = false;
1111      }
1112      Wrapper<cl_type>& operator = (const Wrapper<cl_type>& rhs)
1113      {
1114          if (this != &rhs) {
1115              detail::errHandler(release(), __RELEASE_ERR);
1116              object_ = rhs.object_;
1117              referenceCountable_ = rhs.referenceCountable_;
1118              detail::errHandler(retain(), __RETAIN_ERR);
1119          }
1120          return *this;
1121      }
1122      Wrapper<cl_type>& operator = (Wrapper<cl_type>&& rhs)
1123      {
1124          if (this != &rhs) {
1125              detail::errHandler(release(), __RELEASE_ERR);
1126              object_ = rhs.object_;
1127              referenceCountable_ = rhs.referenceCountable_;
1128              rhs.object_ = NULL;
1129              rhs.referenceCountable_ = false;
1130          }
1131          return *this;
1132      }
1133      Wrapper<cl_type>& operator = (const cl_type &rhs)
1134      {
1135          detail::errHandler(release(), __RELEASE_ERR);
1136          object_ = rhs;
1137          referenceCountable_ = isReferenceCountable(object_); 
1138          return *this;
1139      }
1140      const cl_type& operator ()() const { return object_; }
1141      cl_type& operator ()() { return object_; }
1142      const cl_type get() const { return object_; }
1143      cl_type get() { return object_; }
1144  protected:
1145      template<typename Func, typename U>
1146      friend inline cl_int getInfoHelper(Func, cl_uint, U*, int, typename U::cl_type);
1147      template<typename Func, typename U>
1148      friend inline cl_int getInfoHelper(Func, cl_uint, vector<U>*, int, typename U::cl_type);
1149      cl_int retain() const
1150      {
1151          if( object_ != nullptr && referenceCountable_ ) {
1152              return ReferenceHandler<cl_type>::retain(object_);
1153          }
1154          else {
1155              return CL_SUCCESS;
1156          }
1157      }
1158      cl_int release() const
1159      {
1160          if (object_ != nullptr && referenceCountable_) {
1161              return ReferenceHandler<cl_type>::release(object_);
1162          }
1163          else {
1164              return CL_SUCCESS;
1165          }
1166      }
1167  };
1168  template <typename T>
1169  inline bool operator==(const Wrapper<T> &lhs, const Wrapper<T> &rhs)
1170  {
1171      return lhs() == rhs();
1172  }
1173  template <typename T>
1174  inline bool operator!=(const Wrapper<T> &lhs, const Wrapper<T> &rhs)
1175  {
1176      return !operator==(lhs, rhs);
1177  }
1178  } 
1179  using BuildLogType = vector<std::pair<cl::Device, typename detail::param_traits<detail::cl_program_build_info, CL_PROGRAM_BUILD_LOG>::param_type>>;
1180  #if defined(CL_HPP_ENABLE_EXCEPTIONS)
1181  class BuildError : public Error
1182  {
1183  private:
1184      BuildLogType buildLogs;
1185  public:
1186      BuildError(cl_int err, const char * errStr, const BuildLogType &vec) : Error(err, errStr), buildLogs(vec)
1187      {
1188      }
1189      BuildLogType getBuildLog() const
1190      {
1191          return buildLogs;
1192      }
1193  };
1194  namespace detail {
1195      static inline cl_int buildErrHandler(
1196          cl_int err,
1197          const char * errStr,
1198          const BuildLogType &buildLogs)
1199      {
1200          if (err != CL_SUCCESS) {
1201              throw BuildError(err, errStr, buildLogs);
1202          }
1203          return err;
1204      }
1205  } 
1206  #else
1207  namespace detail {
1208      static inline cl_int buildErrHandler(
1209          cl_int err,
1210          const char * errStr,
1211          const BuildLogType &buildLogs)
1212      {
1213          (void)buildLogs; 
1214          (void)errStr;
1215          return err;
1216      }
1217  } 
1218  #endif 
1219  struct ImageFormat : public cl_image_format
1220  {
1221      ImageFormat(){}
1222      ImageFormat(cl_channel_order order, cl_channel_type type)
1223      {
1224          image_channel_order = order;
1225          image_channel_data_type = type;
1226      }
1227      ImageFormat& operator = (const ImageFormat& rhs)
1228      {
1229          if (this != &rhs) {
1230              this->image_channel_data_type = rhs.image_channel_data_type;
1231              this->image_channel_order     = rhs.image_channel_order;
1232          }
1233          return *this;
1234      }
1235  };
1236  class Device : public detail::Wrapper<cl_device_id>
1237  {
1238  private:
1239      static std::once_flag default_initialized_;
1240      static Device default_;
1241      static cl_int default_error_;
1242      static void makeDefault();
1243      static void makeDefaultProvided(const Device &p) {
1244          default_ = p;
1245      }
1246  public:
1247  #ifdef CL_HPP_UNIT_TEST_ENABLE
1248      static void unitTestClearDefault() {
1249          default_ = Device();
1250      }
1251  #endif 
1252      Device() : detail::Wrapper<cl_type>() { }
1253      explicit Device(const cl_device_id &device, bool retainObject = false) : 
1254          detail::Wrapper<cl_type>(device, retainObject) { }
1255      static Device getDefault(
1256          cl_int *errResult = NULL)
1257      {
1258          std::call_once(default_initialized_, makeDefault);
1259          detail::errHandler(default_error_);
1260          if (errResult != NULL) {
1261              *errResult = default_error_;
1262          }
1263          return default_;
1264      }
1265      static Device setDefault(const Device &default_device)
1266      {
1267          std::call_once(default_initialized_, makeDefaultProvided, std::cref(default_device));
1268          detail::errHandler(default_error_);
1269          return default_;
1270      }
1271      Device& operator = (const cl_device_id& rhs)
1272      {
1273          detail::Wrapper<cl_type>::operator=(rhs);
1274          return *this;
1275      }
1276      Device(const Device& dev) : detail::Wrapper<cl_type>(dev) {}
1277      Device& operator = (const Device &dev)
1278      {
1279          detail::Wrapper<cl_type>::operator=(dev);
1280          return *this;
1281      }
1282      Device(Device&& dev) CL_HPP_NOEXCEPT_ : detail::Wrapper<cl_type>(std::move(dev)) {}
1283      Device& operator = (Device &&dev)
1284      {
1285          detail::Wrapper<cl_type>::operator=(std::move(dev));
1286          return *this;
1287      }
1288      template <typename T>
1289      cl_int getInfo(cl_device_info name, T* param) const
1290      {
1291          return detail::errHandler(
1292              detail::getInfo(&::clGetDeviceInfo, object_, name, param),
1293              __GET_DEVICE_INFO_ERR);
1294      }
1295      template <cl_int name> typename
1296      detail::param_traits<detail::cl_device_info, name>::param_type
1297      getInfo(cl_int* err = NULL) const
1298      {
1299          typename detail::param_traits<
1300              detail::cl_device_info, name>::param_type param;
1301          cl_int result = getInfo(name, &param);
1302          if (err != NULL) {
1303              *err = result;
1304          }
1305          return param;
1306      }
1307  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
1308      cl_int createSubDevices(
1309          const cl_device_partition_property * properties,
1310          vector<Device>* devices)
1311      {
1312          cl_uint n = 0;
1313          cl_int err = clCreateSubDevices(object_, properties, 0, NULL, &n);
1314          if (err != CL_SUCCESS) {
1315              return detail::errHandler(err, __CREATE_SUB_DEVICES_ERR);
1316          }
1317          vector<cl_device_id> ids(n);
1318          err = clCreateSubDevices(object_, properties, n, ids.data(), NULL);
1319          if (err != CL_SUCCESS) {
1320              return detail::errHandler(err, __CREATE_SUB_DEVICES_ERR);
1321          }
1322          if (devices) {
1323              devices->resize(ids.size());
1324              for (size_type i = 0; i < ids.size(); i++) {
1325                  (*devices)[i] = Device(ids[i], false);
1326              }
1327          }
1328          return CL_SUCCESS;
1329      }
1330  #elif defined(CL_HPP_USE_CL_DEVICE_FISSION)
1331      cl_int createSubDevices(
1332          const cl_device_partition_property_ext * properties,
1333          vector<Device>* devices)
1334      {
1335          typedef CL_API_ENTRY cl_int 
1336              ( CL_API_CALL * PFN_clCreateSubDevicesEXT)(
1337                  cl_device_id &bsol;*in_device*/,
1338                  const cl_device_partition_property_ext * &bsol;* properties */,
1339                  cl_uint &bsol;*num_entries*/,
1340                  cl_device_id * &bsol;*out_devices*/,
1341                  cl_uint * &bsol;*num_devices*/ ) CL_EXT_SUFFIX__VERSION_1_1;
1342          static PFN_clCreateSubDevicesEXT pfn_clCreateSubDevicesEXT = NULL;
1343          CL_HPP_INIT_CL_EXT_FCN_PTR_(clCreateSubDevicesEXT);
1344          cl_uint n = 0;
1345          cl_int err = pfn_clCreateSubDevicesEXT(object_, properties, 0, NULL, &n);
1346          if (err != CL_SUCCESS) {
1347              return detail::errHandler(err, __CREATE_SUB_DEVICES_ERR);
1348          }
1349          vector<cl_device_id> ids(n);
1350          err = pfn_clCreateSubDevicesEXT(object_, properties, n, ids.data(), NULL);
1351          if (err != CL_SUCCESS) {
1352              return detail::errHandler(err, __CREATE_SUB_DEVICES_ERR);
1353          }
1354          if (devices) {
1355              devices->resize(ids.size());
1356              for (size_type i = 0; i < ids.size(); i++) {
1357                  (*devices)[i] = Device(ids[i], false);
1358              }
1359          }
1360          return CL_SUCCESS;
1361      }
1362  #endif 
1363  };
1364  CL_HPP_DEFINE_STATIC_MEMBER_ std::once_flag Device::default_initialized_;
1365  CL_HPP_DEFINE_STATIC_MEMBER_ Device Device::default_;
1366  CL_HPP_DEFINE_STATIC_MEMBER_ cl_int Device::default_error_ = CL_SUCCESS;
1367  class Platform : public detail::Wrapper<cl_platform_id>
1368  {
1369  private:
1370      static std::once_flag default_initialized_;
1371      static Platform default_;
1372      static cl_int default_error_;
1373      static void makeDefault() {
1374  #if defined(CL_HPP_ENABLE_EXCEPTIONS)
1375          try
1376  #endif
1377          {
1378              cl_uint n = 0;
1379              cl_int err = ::clGetPlatformIDs(0, NULL, &n);
1380              if (err != CL_SUCCESS) {
1381                  default_error_ = err;
1382                  return;
1383              }
1384              if (n == 0) {
1385                  default_error_ = CL_INVALID_PLATFORM;
1386                  return;
1387              }
1388              vector<cl_platform_id> ids(n);
1389              err = ::clGetPlatformIDs(n, ids.data(), NULL);
1390              if (err != CL_SUCCESS) {
1391                  default_error_ = err;
1392                  return;
1393              }
1394              default_ = Platform(ids[0]);
1395          }
1396  #if defined(CL_HPP_ENABLE_EXCEPTIONS)
1397          catch (cl::Error &e) {
1398              default_error_ = e.err();
1399          }
1400  #endif
1401      }
1402      static void makeDefaultProvided(const Platform &p) {
1403         default_ = p;
1404      }
1405  public:
1406  #ifdef CL_HPP_UNIT_TEST_ENABLE
1407      static void unitTestClearDefault() {
1408          default_ = Platform();
1409      }
1410  #endif 
1411      Platform() : detail::Wrapper<cl_type>()  { }
1412      explicit Platform(const cl_platform_id &platform, bool retainObject = false) : 
1413          detail::Wrapper<cl_type>(platform, retainObject) { }
1414      Platform& operator = (const cl_platform_id& rhs)
1415      {
1416          detail::Wrapper<cl_type>::operator=(rhs);
1417          return *this;
1418      }
1419      static Platform getDefault(
1420          cl_int *errResult = NULL)
1421      {
1422          std::call_once(default_initialized_, makeDefault);
1423          detail::errHandler(default_error_);
1424          if (errResult != NULL) {
1425              *errResult = default_error_;
1426          }
1427          return default_;
1428      }
1429      static Platform setDefault(const Platform &default_platform)
1430      {
1431          std::call_once(default_initialized_, makeDefaultProvided, std::cref(default_platform));
1432          detail::errHandler(default_error_);
1433          return default_;
1434      }
1435      cl_int getInfo(cl_platform_info name, string* param) const
1436      {
1437          return detail::errHandler(
1438              detail::getInfo(&::clGetPlatformInfo, object_, name, param),
1439              __GET_PLATFORM_INFO_ERR);
1440      }
1441      template <cl_int name> typename
1442      detail::param_traits<detail::cl_platform_info, name>::param_type
1443      getInfo(cl_int* err = NULL) const
1444      {
1445          typename detail::param_traits<
1446              detail::cl_platform_info, name>::param_type param;
1447          cl_int result = getInfo(name, &param);
1448          if (err != NULL) {
1449              *err = result;
1450          }
1451          return param;
1452      }
1453      cl_int getDevices(
1454          cl_device_type type,
1455          vector<Device>* devices) const
1456      {
1457          cl_uint n = 0;
1458          if( devices == NULL ) {
1459              return detail::errHandler(CL_INVALID_ARG_VALUE, __GET_DEVICE_IDS_ERR);
1460          }
1461          cl_int err = ::clGetDeviceIDs(object_, type, 0, NULL, &n);
1462          if (err != CL_SUCCESS) {
1463              return detail::errHandler(err, __GET_DEVICE_IDS_ERR);
1464          }
1465          vector<cl_device_id> ids(n);
1466          err = ::clGetDeviceIDs(object_, type, n, ids.data(), NULL);
1467          if (err != CL_SUCCESS) {
1468              return detail::errHandler(err, __GET_DEVICE_IDS_ERR);
1469          }
1470          if (devices) {
1471              devices->resize(ids.size());
1472              for (size_type i = 0; i < ids.size(); i++) {
1473                  (*devices)[i] = Device(ids[i], true);
1474              }
1475          }
1476          return CL_SUCCESS;
1477      }
1478  #if defined(CL_HPP_USE_DX_INTEROP)
1479      cl_int getDevices(
1480          cl_d3d10_device_source_khr d3d_device_source,
1481          void *                     d3d_object,
1482          cl_d3d10_device_set_khr    d3d_device_set,
1483          vector<Device>* devices) const
1484      {
1485          typedef CL_API_ENTRY cl_int (CL_API_CALL *PFN_clGetDeviceIDsFromD3D10KHR)(
1486              cl_platform_id platform, 
1487              cl_d3d10_device_source_khr d3d_device_source, 
1488              void * d3d_object,
1489              cl_d3d10_device_set_khr d3d_device_set,
1490              cl_uint num_entries,
1491              cl_device_id * devices,
1492              cl_uint* num_devices);
1493          if( devices == NULL ) {
1494              return detail::errHandler(CL_INVALID_ARG_VALUE, __GET_DEVICE_IDS_ERR);
1495          }
1496          static PFN_clGetDeviceIDsFromD3D10KHR pfn_clGetDeviceIDsFromD3D10KHR = NULL;
1497          CL_HPP_INIT_CL_EXT_FCN_PTR_PLATFORM_(object_, clGetDeviceIDsFromD3D10KHR);
1498          cl_uint n = 0;
1499          cl_int err = pfn_clGetDeviceIDsFromD3D10KHR(
1500              object_, 
1501              d3d_device_source, 
1502              d3d_object,
1503              d3d_device_set, 
1504              0, 
1505              NULL, 
1506              &n);
1507          if (err != CL_SUCCESS) {
1508              return detail::errHandler(err, __GET_DEVICE_IDS_ERR);
1509          }
1510          vector<cl_device_id> ids(n);
1511          err = pfn_clGetDeviceIDsFromD3D10KHR(
1512              object_, 
1513              d3d_device_source, 
1514              d3d_object,
1515              d3d_device_set,
1516              n, 
1517              ids.data(), 
1518              NULL);
1519          if (err != CL_SUCCESS) {
1520              return detail::errHandler(err, __GET_DEVICE_IDS_ERR);
1521          }
1522          if (devices) {
1523              devices->resize(ids.size());
1524              for (size_type i = 0; i < ids.size(); i++) {
1525                  (*devices)[i] = Device(ids[i], true);
1526              }
1527          }
1528          return CL_SUCCESS;
1529      }
1530  #endif
1531      static cl_int get(
1532          vector<Platform>* platforms)
1533      {
1534          cl_uint n = 0;
1535          if( platforms == NULL ) {
1536              return detail::errHandler(CL_INVALID_ARG_VALUE, __GET_PLATFORM_IDS_ERR);
1537          }
1538          cl_int err = ::clGetPlatformIDs(0, NULL, &n);
1539          if (err != CL_SUCCESS) {
1540              return detail::errHandler(err, __GET_PLATFORM_IDS_ERR);
1541          }
1542          vector<cl_platform_id> ids(n);
1543          err = ::clGetPlatformIDs(n, ids.data(), NULL);
1544          if (err != CL_SUCCESS) {
1545              return detail::errHandler(err, __GET_PLATFORM_IDS_ERR);
1546          }
1547          if (platforms) {
1548              platforms->resize(ids.size());
1549              for (size_type i = 0; i < ids.size(); i++) {
1550                  (*platforms)[i] = Platform(ids[i]);
1551              }
1552          }
1553          return CL_SUCCESS;
1554      }
1555      static cl_int get(
1556          Platform * platform)
1557      {
1558          cl_int err;
1559          Platform default_platform = Platform::getDefault(&err);
1560          if (platform) {
1561              *platform = default_platform;
1562          }
1563          return err;
1564      }
1565      static Platform get(
1566          cl_int * errResult = NULL)
1567      {
1568          cl_int err;
1569          Platform default_platform = Platform::getDefault(&err);
1570          if (errResult) {
1571              *errResult = err;
1572          }
1573          return default_platform;
1574      }    
1575  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
1576      cl_int
1577      unloadCompiler()
1578      {
1579          return ::clUnloadPlatformCompiler(object_);
1580      }
1581  #endif 
1582  }; 
1583  CL_HPP_DEFINE_STATIC_MEMBER_ std::once_flag Platform::default_initialized_;
1584  CL_HPP_DEFINE_STATIC_MEMBER_ Platform Platform::default_;
1585  CL_HPP_DEFINE_STATIC_MEMBER_ cl_int Platform::default_error_ = CL_SUCCESS;
1586  #if defined(CL_USE_DEPRECATED_OPENCL_1_1_APIS)
1587  inline CL_EXT_PREFIX__VERSION_1_1_DEPRECATED cl_int
1588  UnloadCompiler() CL_EXT_SUFFIX__VERSION_1_1_DEPRECATED;
1589  inline cl_int
1590  UnloadCompiler()
1591  {
1592      return ::clUnloadCompiler();
1593  }
1594  #endif 
1595  class Context 
1596      : public detail::Wrapper<cl_context>
1597  {
1598  private:
1599      static std::once_flag default_initialized_;
1600      static Context default_;
1601      static cl_int default_error_;
1602      static void makeDefault() {
1603  #if defined(CL_HPP_ENABLE_EXCEPTIONS)
1604          try
1605  #endif
1606          {
1607  #if !defined(__APPLE__) && !defined(__MACOS)
1608              const Platform &p = Platform::getDefault();
1609              cl_platform_id defaultPlatform = p();
1610              cl_context_properties properties[3] = {
1611                  CL_CONTEXT_PLATFORM, (cl_context_properties)defaultPlatform, 0
1612              };
1613  #else 
1614              cl_context_properties *properties = nullptr;
1615  #endif 
1616              default_ = Context(
1617                  CL_DEVICE_TYPE_DEFAULT,
1618                  properties,
1619                  NULL,
1620                  NULL,
1621                  &default_error_);
1622          }
1623  #if defined(CL_HPP_ENABLE_EXCEPTIONS)
1624          catch (cl::Error &e) {
1625              default_error_ = e.err();
1626          }
1627  #endif
1628      }
1629      static void makeDefaultProvided(const Context &c) {
1630          default_ = c;
1631      }
1632  public:
1633  #ifdef CL_HPP_UNIT_TEST_ENABLE
1634      static void unitTestClearDefault() {
1635          default_ = Context();
1636      }
1637  #endif 
1638      Context(
1639          const vector<Device>& devices,
1640          cl_context_properties* properties = NULL,
1641          void (CL_CALLBACK * notifyFptr)(
1642              const char *,
1643              const void *,
1644              size_type,
1645              void *) = NULL,
1646          void* data = NULL,
1647          cl_int* err = NULL)
1648      {
1649          cl_int error;
1650          size_type numDevices = devices.size();
1651          vector<cl_device_id> deviceIDs(numDevices);
1652          for( size_type deviceIndex = 0; deviceIndex < numDevices; ++deviceIndex ) {
1653              deviceIDs[deviceIndex] = (devices[deviceIndex])();
1654          }
1655          object_ = ::clCreateContext(
1656              properties, (cl_uint) numDevices,
1657              deviceIDs.data(),
1658              notifyFptr, data, &error);
1659          detail::errHandler(error, __CREATE_CONTEXT_ERR);
1660          if (err != NULL) {
1661              *err = error;
1662          }
1663      }
1664      Context(
1665          const Device& device,
1666          cl_context_properties* properties = NULL,
1667          void (CL_CALLBACK * notifyFptr)(
1668              const char *,
1669              const void *,
1670              size_type,
1671              void *) = NULL,
1672          void* data = NULL,
1673          cl_int* err = NULL)
1674      {
1675          cl_int error;
1676          cl_device_id deviceID = device();
1677          object_ = ::clCreateContext(
1678              properties, 1,
1679              &deviceID,
1680              notifyFptr, data, &error);
1681          detail::errHandler(error, __CREATE_CONTEXT_ERR);
1682          if (err != NULL) {
1683              *err = error;
1684          }
1685      }
1686      Context(
1687          cl_device_type type,
1688          cl_context_properties* properties = NULL,
1689          void (CL_CALLBACK * notifyFptr)(
1690              const char *,
1691              const void *,
1692              size_type,
1693              void *) = NULL,
1694          void* data = NULL,
1695          cl_int* err = NULL)
1696      {
1697          cl_int error;
1698  #if !defined(__APPLE__) && !defined(__MACOS)
1699          cl_context_properties prop[4] = {CL_CONTEXT_PLATFORM, 0, 0, 0 };
1700          if (properties == NULL) {
1701              vector<Platform> platforms;
1702              error = Platform::get(&platforms);
1703              if (error != CL_SUCCESS) {
1704                  detail::errHandler(error, __CREATE_CONTEXT_FROM_TYPE_ERR);
1705                  if (err != NULL) {
1706                      *err = error;
1707                  }
1708                  return;
1709              }
1710              cl_context_properties platform_id = 0;
1711              for (unsigned int i = 0; i < platforms.size(); i++) {
1712                  vector<Device> devices;
1713  #if defined(CL_HPP_ENABLE_EXCEPTIONS)
1714                  try {
1715  #endif
1716                      error = platforms[i].getDevices(type, &devices);
1717  #if defined(CL_HPP_ENABLE_EXCEPTIONS)
1718                  } catch (Error) {}
1719  #endif
1720                  if (error != CL_SUCCESS && error != CL_DEVICE_NOT_FOUND) {
1721                      detail::errHandler(error, __CREATE_CONTEXT_FROM_TYPE_ERR);
1722                      if (err != NULL) {
1723                          *err = error;
1724                      }
1725                  }
1726                  if (devices.size() > 0) {
1727                      platform_id = (cl_context_properties)platforms[i]();
1728                      break;
1729                  }
1730              }
1731              if (platform_id == 0) {
1732                  detail::errHandler(CL_DEVICE_NOT_FOUND, __CREATE_CONTEXT_FROM_TYPE_ERR);
1733                  if (err != NULL) {
1734                      *err = CL_DEVICE_NOT_FOUND;
1735                  }
1736                  return;
1737              }
1738              prop[1] = platform_id;
1739              properties = &prop[0];
1740          }
1741  #endif
1742          object_ = ::clCreateContextFromType(
1743              properties, type, notifyFptr, data, &error);
1744          detail::errHandler(error, __CREATE_CONTEXT_FROM_TYPE_ERR);
1745          if (err != NULL) {
1746              *err = error;
1747          }
1748      }
1749      Context(const Context& ctx) : detail::Wrapper<cl_type>(ctx) {}
1750      Context& operator = (const Context &ctx)
1751      {
1752          detail::Wrapper<cl_type>::operator=(ctx);
1753          return *this;
1754      }
1755      Context(Context&& ctx) CL_HPP_NOEXCEPT_ : detail::Wrapper<cl_type>(std::move(ctx)) {}
1756      Context& operator = (Context &&ctx)
1757      {
1758          detail::Wrapper<cl_type>::operator=(std::move(ctx));
1759          return *this;
1760      }
1761      static Context getDefault(cl_int * err = NULL) 
1762      {
1763          std::call_once(default_initialized_, makeDefault);
1764          detail::errHandler(default_error_);
1765          if (err != NULL) {
1766              *err = default_error_;
1767          }
1768          return default_;
1769      }
1770      static Context setDefault(const Context &default_context)
1771      {
1772          std::call_once(default_initialized_, makeDefaultProvided, std::cref(default_context));
1773          detail::errHandler(default_error_);
1774          return default_;
1775      }
1776      Context() : detail::Wrapper<cl_type>() { }
1777      explicit Context(const cl_context& context, bool retainObject = false) : 
1778          detail::Wrapper<cl_type>(context, retainObject) { }
1779      Context& operator = (const cl_context& rhs)
1780      {
1781          detail::Wrapper<cl_type>::operator=(rhs);
1782          return *this;
1783      }
1784      template <typename T>
1785      cl_int getInfo(cl_context_info name, T* param) const
1786      {
1787          return detail::errHandler(
1788              detail::getInfo(&::clGetContextInfo, object_, name, param),
1789              __GET_CONTEXT_INFO_ERR);
1790      }
1791      template <cl_int name> typename
1792      detail::param_traits<detail::cl_context_info, name>::param_type
1793      getInfo(cl_int* err = NULL) const
1794      {
1795          typename detail::param_traits<
1796              detail::cl_context_info, name>::param_type param;
1797          cl_int result = getInfo(name, &param);
1798          if (err != NULL) {
1799              *err = result;
1800          }
1801          return param;
1802      }
1803      cl_int getSupportedImageFormats(
1804          cl_mem_flags flags,
1805          cl_mem_object_type type,
1806          vector<ImageFormat>* formats) const
1807      {
1808          cl_uint numEntries;
1809          if (!formats) {
1810              return CL_SUCCESS;
1811          }
1812          cl_int err = ::clGetSupportedImageFormats(
1813             object_, 
1814             flags,
1815             type, 
1816             0, 
1817             NULL, 
1818             &numEntries);
1819          if (err != CL_SUCCESS) {
1820              return detail::errHandler(err, __GET_SUPPORTED_IMAGE_FORMATS_ERR);
1821          }
1822          if (numEntries > 0) {
1823              vector<ImageFormat> value(numEntries);
1824              err = ::clGetSupportedImageFormats(
1825                  object_,
1826                  flags,
1827                  type,
1828                  numEntries,
1829                  (cl_image_format*)value.data(),
1830                  NULL);
1831              if (err != CL_SUCCESS) {
1832                  return detail::errHandler(err, __GET_SUPPORTED_IMAGE_FORMATS_ERR);
1833              }
1834              formats->assign(begin(value), end(value));
1835          }
1836          else {
1837              formats->clear();
1838          }
1839          return CL_SUCCESS;
1840      }
1841  };
1842  inline void Device::makeDefault()
1843  {
1844  #if defined(CL_HPP_ENABLE_EXCEPTIONS)
1845      try
1846  #endif
1847      {
1848          cl_int error = 0;
1849          Context context = Context::getDefault(&error);
1850          detail::errHandler(error, __CREATE_CONTEXT_ERR);
1851          if (error != CL_SUCCESS) {
1852              default_error_ = error;
1853          }
1854          else {
1855              default_ = context.getInfo<CL_CONTEXT_DEVICES>()[0];
1856              default_error_ = CL_SUCCESS;
1857          }
1858      }
1859  #if defined(CL_HPP_ENABLE_EXCEPTIONS)
1860      catch (cl::Error &e) {
1861          default_error_ = e.err();
1862      }
1863  #endif
1864  }
1865  CL_HPP_DEFINE_STATIC_MEMBER_ std::once_flag Context::default_initialized_;
1866  CL_HPP_DEFINE_STATIC_MEMBER_ Context Context::default_;
1867  CL_HPP_DEFINE_STATIC_MEMBER_ cl_int Context::default_error_ = CL_SUCCESS;
1868  class Event : public detail::Wrapper<cl_event>
1869  {
1870  public:
1871      Event() : detail::Wrapper<cl_type>() { }
1872      explicit Event(const cl_event& event, bool retainObject = false) : 
1873          detail::Wrapper<cl_type>(event, retainObject) { }
1874      Event& operator = (const cl_event& rhs)
1875      {
1876          detail::Wrapper<cl_type>::operator=(rhs);
1877          return *this;
1878      }
1879      template <typename T>
1880      cl_int getInfo(cl_event_info name, T* param) const
1881      {
1882          return detail::errHandler(
1883              detail::getInfo(&::clGetEventInfo, object_, name, param),
1884              __GET_EVENT_INFO_ERR);
1885      }
1886      template <cl_int name> typename
1887      detail::param_traits<detail::cl_event_info, name>::param_type
1888      getInfo(cl_int* err = NULL) const
1889      {
1890          typename detail::param_traits<
1891              detail::cl_event_info, name>::param_type param;
1892          cl_int result = getInfo(name, &param);
1893          if (err != NULL) {
1894              *err = result;
1895          }
1896          return param;
1897      }
1898      template <typename T>
1899      cl_int getProfilingInfo(cl_profiling_info name, T* param) const
1900      {
1901          return detail::errHandler(detail::getInfo(
1902              &::clGetEventProfilingInfo, object_, name, param),
1903              __GET_EVENT_PROFILE_INFO_ERR);
1904      }
1905      template <cl_int name> typename
1906      detail::param_traits<detail::cl_profiling_info, name>::param_type
1907      getProfilingInfo(cl_int* err = NULL) const
1908      {
1909          typename detail::param_traits<
1910              detail::cl_profiling_info, name>::param_type param;
1911          cl_int result = getProfilingInfo(name, &param);
1912          if (err != NULL) {
1913              *err = result;
1914          }
1915          return param;
1916      }
1917      cl_int wait() const
1918      {
1919          return detail::errHandler(
1920              ::clWaitForEvents(1, &object_),
1921              __WAIT_FOR_EVENTS_ERR);
1922      }
1923  #if CL_HPP_TARGET_OPENCL_VERSION >= 110
1924      cl_int setCallback(
1925          cl_int type,
1926          void (CL_CALLBACK * pfn_notify)(cl_event, cl_int, void *),		
1927          void * user_data = NULL)
1928      {
1929          return detail::errHandler(
1930              ::clSetEventCallback(
1931                  object_,
1932                  type,
1933                  pfn_notify,
1934                  user_data), 
1935              __SET_EVENT_CALLBACK_ERR);
1936      }
1937  #endif 
1938      static cl_int
1939      waitForEvents(const vector<Event>& events)
1940      {
1941          return detail::errHandler(
1942              ::clWaitForEvents(
1943                  (cl_uint) events.size(), (events.size() > 0) ? (cl_event*)&events.front() : NULL),
1944              __WAIT_FOR_EVENTS_ERR);
1945      }
1946  };
1947  #if CL_HPP_TARGET_OPENCL_VERSION >= 110
1948  class UserEvent : public Event
1949  {
1950  public:
1951      UserEvent(
1952          const Context& context,
1953          cl_int * err = NULL)
1954      {
1955          cl_int error;
1956          object_ = ::clCreateUserEvent(
1957              context(),
1958              &error);
1959          detail::errHandler(error, __CREATE_USER_EVENT_ERR);
1960          if (err != NULL) {
1961              *err = error;
1962          }
1963      }
1964      UserEvent() : Event() { }
1965      cl_int setStatus(cl_int status)
1966      {
1967          return detail::errHandler(
1968              ::clSetUserEventStatus(object_,status), 
1969              __SET_USER_EVENT_STATUS_ERR);
1970      }
1971  };
1972  #endif 
1973  inline static cl_int
1974  WaitForEvents(const vector<Event>& events)
1975  {
1976      return detail::errHandler(
1977          ::clWaitForEvents(
1978              (cl_uint) events.size(), (events.size() > 0) ? (cl_event*)&events.front() : NULL),
1979          __WAIT_FOR_EVENTS_ERR);
1980  }
1981  class Memory : public detail::Wrapper<cl_mem>
1982  {
1983  public:
1984      Memory() : detail::Wrapper<cl_type>() { }
1985      explicit Memory(const cl_mem& memory, bool retainObject) :
1986          detail::Wrapper<cl_type>(memory, retainObject) { }
1987      Memory& operator = (const cl_mem& rhs)
1988      {
1989          detail::Wrapper<cl_type>::operator=(rhs);
1990          return *this;
1991      }
1992      Memory(const Memory& mem) : detail::Wrapper<cl_type>(mem) {}
1993      Memory& operator = (const Memory &mem)
1994      {
1995          detail::Wrapper<cl_type>::operator=(mem);
1996          return *this;
1997      }
1998      Memory(Memory&& mem) CL_HPP_NOEXCEPT_ : detail::Wrapper<cl_type>(std::move(mem)) {}
1999      Memory& operator = (Memory &&mem)
2000      {
2001          detail::Wrapper<cl_type>::operator=(std::move(mem));
2002          return *this;
2003      }
2004      template <typename T>
2005      cl_int getInfo(cl_mem_info name, T* param) const
2006      {
2007          return detail::errHandler(
2008              detail::getInfo(&::clGetMemObjectInfo, object_, name, param),
2009              __GET_MEM_OBJECT_INFO_ERR);
2010      }
2011      template <cl_int name> typename
2012      detail::param_traits<detail::cl_mem_info, name>::param_type
2013      getInfo(cl_int* err = NULL) const
2014      {
2015          typename detail::param_traits<
2016              detail::cl_mem_info, name>::param_type param;
2017          cl_int result = getInfo(name, &param);
2018          if (err != NULL) {
2019              *err = result;
2020          }
2021          return param;
2022      }
2023  #if CL_HPP_TARGET_OPENCL_VERSION >= 110
2024      cl_int setDestructorCallback(
2025          void (CL_CALLBACK * pfn_notify)(cl_mem, void *),		
2026          void * user_data = NULL)
2027      {
2028          return detail::errHandler(
2029              ::clSetMemObjectDestructorCallback(
2030                  object_,
2031                  pfn_notify,
2032                  user_data), 
2033              __SET_MEM_OBJECT_DESTRUCTOR_CALLBACK_ERR);
2034      }
2035  #endif 
2036  };
2037  class Buffer;
2038  template< typename IteratorType >
2039  cl_int copy( IteratorType startIterator, IteratorType endIterator, cl::Buffer &buffer );
2040  template< typename IteratorType >
2041  cl_int copy( const cl::Buffer &buffer, IteratorType startIterator, IteratorType endIterator );
2042  template< typename IteratorType >
2043  cl_int copy( const CommandQueue &queue, IteratorType startIterator, IteratorType endIterator, cl::Buffer &buffer );
2044  template< typename IteratorType >
2045  cl_int copy( const CommandQueue &queue, const cl::Buffer &buffer, IteratorType startIterator, IteratorType endIterator );
2046  #if CL_HPP_TARGET_OPENCL_VERSION >= 200
2047  namespace detail
2048  {
2049      class SVMTraitNull
2050      {
2051      public:
2052          static cl_svm_mem_flags getSVMMemFlags()
2053          {
2054              return 0;
2055          }
2056      };
2057  } 
2058  template<class Trait = detail::SVMTraitNull>
2059  class SVMTraitReadWrite
2060  {
2061  public:
2062      static cl_svm_mem_flags getSVMMemFlags()
2063      {
2064          return CL_MEM_READ_WRITE |
2065              Trait::getSVMMemFlags();
2066      }
2067  };
2068  template<class Trait = detail::SVMTraitNull>
2069  class SVMTraitReadOnly
2070  {
2071  public:
2072      static cl_svm_mem_flags getSVMMemFlags()
2073      {
2074          return CL_MEM_READ_ONLY |
2075              Trait::getSVMMemFlags();
2076      }
2077  };
2078  template<class Trait = detail::SVMTraitNull>
2079  class SVMTraitWriteOnly
2080  {
2081  public:
2082      static cl_svm_mem_flags getSVMMemFlags()
2083      {
2084          return CL_MEM_WRITE_ONLY |
2085              Trait::getSVMMemFlags();
2086      }
2087  };
2088  template<class Trait = SVMTraitReadWrite<>>
2089  class SVMTraitCoarse
2090  {
2091  public:
2092      static cl_svm_mem_flags getSVMMemFlags()
2093      {
2094          return Trait::getSVMMemFlags();
2095      }
2096  };
2097  template<class Trait = SVMTraitReadWrite<>>
2098  class SVMTraitFine
2099  {
2100  public:
2101      static cl_svm_mem_flags getSVMMemFlags()
2102      {
2103          return CL_MEM_SVM_FINE_GRAIN_BUFFER |
2104              Trait::getSVMMemFlags();
2105      }
2106  };
2107  template<class Trait = SVMTraitReadWrite<>>
2108  class SVMTraitAtomic
2109  {
2110  public:
2111      static cl_svm_mem_flags getSVMMemFlags()
2112      {
2113          return
2114              CL_MEM_SVM_FINE_GRAIN_BUFFER |
2115              CL_MEM_SVM_ATOMICS |
2116              Trait::getSVMMemFlags();
2117      }
2118  };
2119  template<typename T>
2120  inline cl_int enqueueMapSVM(
2121      T* ptr,
2122      cl_bool blocking,
2123      cl_map_flags flags,
2124      size_type size,
2125      const vector<Event>* events = NULL,
2126      Event* event = NULL);
2127  template<typename T, class SVMTrait>
2128  class SVMAllocator {
2129  private:
2130      Context context_;
2131  public:
2132      typedef T value_type;
2133      typedef value_type* pointer;
2134      typedef const value_type* const_pointer;
2135      typedef value_type& reference;
2136      typedef const value_type& const_reference;
2137      typedef std::size_t size_type;
2138      typedef std::ptrdiff_t difference_type;
2139      template<typename U>
2140      struct rebind
2141      {
2142          typedef SVMAllocator<U, SVMTrait> other;
2143      };
2144      template<typename U, typename V>
2145      friend class SVMAllocator;
2146      SVMAllocator() :
2147          context_(Context::getDefault())
2148      {
2149      }
2150      explicit SVMAllocator(cl::Context context) :
2151          context_(context)
2152      {
2153      }
2154      SVMAllocator(const SVMAllocator &other) :
2155          context_(other.context_)
2156      {
2157      }
2158      template<typename U>
2159      SVMAllocator(const SVMAllocator<U, SVMTrait> &other) :
2160          context_(other.context_)
2161      {
2162      }
2163      ~SVMAllocator()
2164      {
2165      }
2166      pointer address(reference r) CL_HPP_NOEXCEPT_
2167      {
2168          return std::addressof(r);
2169      }
2170      const_pointer address(const_reference r) CL_HPP_NOEXCEPT_
2171      {
2172          return std::addressof(r);
2173      }
2174      pointer allocate(
2175          size_type size,
2176          typename cl::SVMAllocator<void, SVMTrait>::const_pointer = 0)
2177      {
2178          void* voidPointer =
2179              clSVMAlloc(
2180              context_(),
2181              SVMTrait::getSVMMemFlags(),
2182              size*sizeof(T),
2183              sizeof(T));
2184          pointer retValue = reinterpret_cast<pointer>(
2185              voidPointer);
2186  #if defined(CL_HPP_ENABLE_EXCEPTIONS)
2187          if (!retValue) {
2188              std::bad_alloc excep;
2189              throw excep;
2190          }
2191  #endif 
2192          if (!(SVMTrait::getSVMMemFlags() & CL_MEM_SVM_FINE_GRAIN_BUFFER)) {
2193              cl_int err = enqueueMapSVM(retValue, CL_TRUE, CL_MAP_READ | CL_MAP_WRITE, size*sizeof(T));
2194              if (err != CL_SUCCESS) {
2195                  std::bad_alloc excep;
2196                  throw excep;
2197              }
2198          }
2199          return retValue;
2200      }
2201      void deallocate(pointer p, size_type)
2202      {
2203          clSVMFree(context_(), p);
2204      }
2205      size_type max_size() const CL_HPP_NOEXCEPT_
2206      {
2207          size_type maxSize = std::numeric_limits<size_type>::max() / sizeof(T);
2208          for (Device &d : context_.getInfo<CL_CONTEXT_DEVICES>()) {
2209              maxSize = std::min(
2210                  maxSize, 
2211                  static_cast<size_type>(d.getInfo<CL_DEVICE_MAX_MEM_ALLOC_SIZE>()));
2212          }
2213          return maxSize;
2214      }
2215      template< class U, class... Args >
2216      void construct(U* p, Args&&... args)
2217      {
2218          new(p)T(args...);
2219      }
2220      template< class U >
2221      void destroy(U* p)
2222      {
2223          p->~U();
2224      }
2225      inline bool operator==(SVMAllocator const& rhs)
2226      {
2227          return (context_==rhs.context_);
2228      }
2229      inline bool operator!=(SVMAllocator const& a)
2230      {
2231          return !operator==(a);
2232      }
2233  }; 
2234  template<class SVMTrait>
2235  class SVMAllocator<void, SVMTrait> {
2236  public:
2237      typedef void value_type;
2238      typedef value_type* pointer;
2239      typedef const value_type* const_pointer;
2240      template<typename U>
2241      struct rebind
2242      {
2243          typedef SVMAllocator<U, SVMTrait> other;
2244      };
2245      template<typename U, typename V>
2246      friend class SVMAllocator;
2247  };
2248  #if !defined(CL_HPP_NO_STD_UNIQUE_PTR)
2249  namespace detail
2250  {
2251      template<class Alloc>
2252      class Deleter {
2253      private:
2254          Alloc alloc_;
2255          size_type copies_;
2256      public:
2257          typedef typename std::allocator_traits<Alloc>::pointer pointer;
2258          Deleter(const Alloc &alloc, size_type copies) : alloc_{ alloc }, copies_{ copies }
2259          {
2260          }
2261          void operator()(pointer ptr) const {
2262              Alloc tmpAlloc{ alloc_ };
2263              std::allocator_traits<Alloc>::destroy(tmpAlloc, std::addressof(*ptr));
2264              std::allocator_traits<Alloc>::deallocate(tmpAlloc, ptr, copies_);
2265          }
2266      };
2267  } 
2268  template <class T, class Alloc, class... Args>
2269  cl::pointer<T, detail::Deleter<Alloc>> allocate_pointer(const Alloc &alloc_, Args&&... args)
2270  {
2271      Alloc alloc(alloc_);
2272      static const size_t copies = 1;
2273      T* tmp = std::allocator_traits<Alloc>::allocate(alloc, copies);
2274      if (!tmp) {
2275          std::bad_alloc excep;
2276          throw excep;
2277      }
2278      try {
2279          std::allocator_traits<Alloc>::construct(
2280              alloc,
2281              std::addressof(*tmp),
2282              std::forward<Args>(args)...);
2283          return cl::pointer<T, detail::Deleter<Alloc>>(tmp, detail::Deleter<Alloc>{alloc, copies});
2284      }
2285      catch (std::bad_alloc b)
2286      {
2287          std::allocator_traits<Alloc>::deallocate(alloc, tmp, copies);
2288          throw;
2289      }
2290  }
2291  template< class T, class SVMTrait, class... Args >
2292  cl::pointer<T, detail::Deleter<SVMAllocator<T, SVMTrait>>> allocate_svm(Args... args)
2293  {
2294      SVMAllocator<T, SVMTrait> alloc;
2295      return cl::allocate_pointer<T>(alloc, args...);
2296  }
2297  template< class T, class SVMTrait, class... Args >
2298  cl::pointer<T, detail::Deleter<SVMAllocator<T, SVMTrait>>> allocate_svm(const cl::Context &c, Args... args)
2299  {
2300      SVMAllocator<T, SVMTrait> alloc(c);
2301      return cl::allocate_pointer<T>(alloc, args...);
2302  }
2303  #endif 
2304  template < class T >
2305  using coarse_svm_vector = vector<T, cl::SVMAllocator<int, cl::SVMTraitCoarse<>>>;
2306  template < class T >
2307  using fine_svm_vector = vector<T, cl::SVMAllocator<int, cl::SVMTraitFine<>>>;
2308  template < class T >
2309  using atomic_svm_vector = vector<T, cl::SVMAllocator<int, cl::SVMTraitAtomic<>>>;
2310  #endif 
2311  class Buffer : public Memory
2312  {
2313  public:
2314      Buffer(
2315          const Context& context,
2316          cl_mem_flags flags,
2317          size_type size,
2318          void* host_ptr = NULL,
2319          cl_int* err = NULL)
2320      {
2321          cl_int error;
2322          object_ = ::clCreateBuffer(context(), flags, size, host_ptr, &error);
2323          detail::errHandler(error, __CREATE_BUFFER_ERR);
2324          if (err != NULL) {
2325              *err = error;
2326          }
2327      }
2328      Buffer(
2329           cl_mem_flags flags,
2330          size_type size,
2331          void* host_ptr = NULL,
2332          cl_int* err = NULL)
2333      {
2334          cl_int error;
2335          Context context = Context::getDefault(err);
2336          object_ = ::clCreateBuffer(context(), flags, size, host_ptr, &error);
2337          detail::errHandler(error, __CREATE_BUFFER_ERR);
2338          if (err != NULL) {
2339              *err = error;
2340          }
2341      }
2342      template< typename IteratorType >
2343      Buffer(
2344          IteratorType startIterator,
2345          IteratorType endIterator,
2346          bool readOnly,
2347          bool useHostPtr = false,
2348          cl_int* err = NULL)
2349      {
2350          typedef typename std::iterator_traits<IteratorType>::value_type DataType;
2351          cl_int error;
2352          cl_mem_flags flags = 0;
2353          if( readOnly ) {
2354              flags |= CL_MEM_READ_ONLY;
2355          }
2356          else {
2357              flags |= CL_MEM_READ_WRITE;
2358          }
2359          if( useHostPtr ) {
2360              flags |= CL_MEM_USE_HOST_PTR;
2361          }
2362          size_type size = sizeof(DataType)*(endIterator - startIterator);
2363          Context context = Context::getDefault(err);
2364          if( useHostPtr ) {
2365              object_ = ::clCreateBuffer(context(), flags, size, static_cast<DataType*>(&*startIterator), &error);
2366          } else {
2367              object_ = ::clCreateBuffer(context(), flags, size, 0, &error);
2368          }
2369          detail::errHandler(error, __CREATE_BUFFER_ERR);
2370          if (err != NULL) {
2371              *err = error;
2372          }
2373          if( !useHostPtr ) {
2374              error = cl::copy(startIterator, endIterator, *this);
2375              detail::errHandler(error, __CREATE_BUFFER_ERR);
2376              if (err != NULL) {
2377                  *err = error;
2378              }
2379          }
2380      }
2381      template< typename IteratorType >
2382      Buffer(const Context &context, IteratorType startIterator, IteratorType endIterator,
2383          bool readOnly, bool useHostPtr = false, cl_int* err = NULL);
2384      template< typename IteratorType >
2385      Buffer(const CommandQueue &queue, IteratorType startIterator, IteratorType endIterator,
2386          bool readOnly, bool useHostPtr = false, cl_int* err = NULL);
2387      Buffer() : Memory() { }
2388      explicit Buffer(const cl_mem& buffer, bool retainObject = false) :
2389          Memory(buffer, retainObject) { }
2390      Buffer& operator = (const cl_mem& rhs)
2391      {
2392          Memory::operator=(rhs);
2393          return *this;
2394      }
2395      Buffer(const Buffer& buf) : Memory(buf) {}
2396      Buffer& operator = (const Buffer &buf)
2397      {
2398          Memory::operator=(buf);
2399          return *this;
2400      }
2401      Buffer(Buffer&& buf) CL_HPP_NOEXCEPT_ : Memory(std::move(buf)) {}
2402      Buffer& operator = (Buffer &&buf)
2403      {
2404          Memory::operator=(std::move(buf));
2405          return *this;
2406      }
2407  #if CL_HPP_TARGET_OPENCL_VERSION >= 110
2408      Buffer createSubBuffer(
2409          cl_mem_flags flags,
2410          cl_buffer_create_type buffer_create_type,
2411          const void * buffer_create_info,
2412          cl_int * err = NULL)
2413      {
2414          Buffer result;
2415          cl_int error;
2416          result.object_ = ::clCreateSubBuffer(
2417              object_, 
2418              flags, 
2419              buffer_create_type, 
2420              buffer_create_info, 
2421              &error);
2422          detail::errHandler(error, __CREATE_SUBBUFFER_ERR);
2423          if (err != NULL) {
2424              *err = error;
2425          }
2426          return result;
2427      }		
2428  #endif 
2429  };
2430  #if defined (CL_HPP_USE_DX_INTEROP)
2431  class BufferD3D10 : public Buffer
2432  {
2433  public:
2434      BufferD3D10(
2435          const Context& context,
2436          cl_mem_flags flags,
2437          ID3D10Buffer* bufobj,
2438          cl_int * err = NULL) : pfn_clCreateFromD3D10BufferKHR(nullptr)
2439      {
2440          typedef CL_API_ENTRY cl_mem (CL_API_CALL *PFN_clCreateFromD3D10BufferKHR)(
2441              cl_context context, cl_mem_flags flags, ID3D10Buffer*  buffer,
2442              cl_int* errcode_ret);
2443          PFN_clCreateFromD3D10BufferKHR pfn_clCreateFromD3D10BufferKHR;
2444  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
2445          vector<cl_context_properties> props = context.getInfo<CL_CONTEXT_PROPERTIES>();
2446          cl_platform platform = -1;
2447          for( int i = 0; i < props.size(); ++i ) {
2448              if( props[i] == CL_CONTEXT_PLATFORM ) {
2449                  platform = props[i+1];
2450              }
2451          }
2452          CL_HPP_INIT_CL_EXT_FCN_PTR_PLATFORM_(platform, clCreateFromD3D10BufferKHR);
2453  #elif CL_HPP_TARGET_OPENCL_VERSION >= 110
2454          CL_HPP_INIT_CL_EXT_FCN_PTR_(clCreateFromD3D10BufferKHR);
2455  #endif
2456          cl_int error;
2457          object_ = pfn_clCreateFromD3D10BufferKHR(
2458              context(),
2459              flags,
2460              bufobj,
2461              &error);
2462          detail::errHandler(error, __CREATE_GL_BUFFER_ERR);
2463          if (err != NULL) {
2464              *err = error;
2465          }
2466      }
2467      BufferD3D10() : Buffer() { }
2468      explicit BufferD3D10(const cl_mem& buffer, bool retainObject = false) : 
2469          Buffer(buffer, retainObject) { }
2470      BufferD3D10& operator = (const cl_mem& rhs)
2471      {
2472          Buffer::operator=(rhs);
2473          return *this;
2474      }
2475      BufferD3D10(const BufferD3D10& buf) : 
2476          Buffer(buf) {}
2477      BufferD3D10& operator = (const BufferD3D10 &buf)
2478      {
2479          Buffer::operator=(buf);
2480          return *this;
2481      }
2482      BufferD3D10(BufferD3D10&& buf) CL_HPP_NOEXCEPT_ : Buffer(std::move(buf)) {}
2483      BufferD3D10& operator = (BufferD3D10 &&buf)
2484      {
2485          Buffer::operator=(std::move(buf));
2486          return *this;
2487      }
2488  };
2489  #endif
2490  class BufferGL : public Buffer
2491  {
2492  public:
2493      BufferGL(
2494          const Context& context,
2495          cl_mem_flags flags,
2496          cl_GLuint bufobj,
2497          cl_int * err = NULL)
2498      {
2499          cl_int error;
2500          object_ = ::clCreateFromGLBuffer(
2501              context(),
2502              flags,
2503              bufobj,
2504              &error);
2505          detail::errHandler(error, __CREATE_GL_BUFFER_ERR);
2506          if (err != NULL) {
2507              *err = error;
2508          }
2509      }
2510      BufferGL() : Buffer() { }
2511      explicit BufferGL(const cl_mem& buffer, bool retainObject = false) :
2512          Buffer(buffer, retainObject) { }
2513      BufferGL& operator = (const cl_mem& rhs)
2514      {
2515          Buffer::operator=(rhs);
2516          return *this;
2517      }
2518      BufferGL(const BufferGL& buf) : Buffer(buf) {}
2519      BufferGL& operator = (const BufferGL &buf)
2520      {
2521          Buffer::operator=(buf);
2522          return *this;
2523      }
2524      BufferGL(BufferGL&& buf) CL_HPP_NOEXCEPT_ : Buffer(std::move(buf)) {}
2525      BufferGL& operator = (BufferGL &&buf)
2526      {
2527          Buffer::operator=(std::move(buf));
2528          return *this;
2529      }
2530      cl_int getObjectInfo(
2531          cl_gl_object_type *type,
2532          cl_GLuint * gl_object_name)
2533      {
2534          return detail::errHandler(
2535              ::clGetGLObjectInfo(object_,type,gl_object_name),
2536              __GET_GL_OBJECT_INFO_ERR);
2537      }
2538  };
2539  class BufferRenderGL : public Buffer
2540  {
2541  public:
2542      BufferRenderGL(
2543          const Context& context,
2544          cl_mem_flags flags,
2545          cl_GLuint bufobj,
2546          cl_int * err = NULL)
2547      {
2548          cl_int error;
2549          object_ = ::clCreateFromGLRenderbuffer(
2550              context(),
2551              flags,
2552              bufobj,
2553              &error);
2554          detail::errHandler(error, __CREATE_GL_RENDER_BUFFER_ERR);
2555          if (err != NULL) {
2556              *err = error;
2557          }
2558      }
2559      BufferRenderGL() : Buffer() { }
2560      explicit BufferRenderGL(const cl_mem& buffer, bool retainObject = false) :
2561          Buffer(buffer, retainObject) { }
2562      BufferRenderGL& operator = (const cl_mem& rhs)
2563      {
2564          Buffer::operator=(rhs);
2565          return *this;
2566      }
2567      BufferRenderGL(const BufferRenderGL& buf) : Buffer(buf) {}
2568      BufferRenderGL& operator = (const BufferRenderGL &buf)
2569      {
2570          Buffer::operator=(buf);
2571          return *this;
2572      }
2573      BufferRenderGL(BufferRenderGL&& buf) CL_HPP_NOEXCEPT_ : Buffer(std::move(buf)) {}
2574      BufferRenderGL& operator = (BufferRenderGL &&buf)
2575      {
2576          Buffer::operator=(std::move(buf));
2577          return *this;
2578      }
2579      cl_int getObjectInfo(
2580          cl_gl_object_type *type,
2581          cl_GLuint * gl_object_name)
2582      {
2583          return detail::errHandler(
2584              ::clGetGLObjectInfo(object_,type,gl_object_name),
2585              __GET_GL_OBJECT_INFO_ERR);
2586      }
2587  };
2588  class Image : public Memory
2589  {
2590  protected:
2591      Image() : Memory() { }
2592      explicit Image(const cl_mem& image, bool retainObject = false) :
2593          Memory(image, retainObject) { }
2594      Image& operator = (const cl_mem& rhs)
2595      {
2596          Memory::operator=(rhs);
2597          return *this;
2598      }
2599      Image(const Image& img) : Memory(img) {}
2600      Image& operator = (const Image &img)
2601      {
2602          Memory::operator=(img);
2603          return *this;
2604      }
2605      Image(Image&& img) CL_HPP_NOEXCEPT_ : Memory(std::move(img)) {}
2606      Image& operator = (Image &&img)
2607      {
2608          Memory::operator=(std::move(img));
2609          return *this;
2610      }
2611  public:
2612      template <typename T>
2613      cl_int getImageInfo(cl_image_info name, T* param) const
2614      {
2615          return detail::errHandler(
2616              detail::getInfo(&::clGetImageInfo, object_, name, param),
2617              __GET_IMAGE_INFO_ERR);
2618      }
2619      template <cl_int name> typename
2620      detail::param_traits<detail::cl_image_info, name>::param_type
2621      getImageInfo(cl_int* err = NULL) const
2622      {
2623          typename detail::param_traits<
2624              detail::cl_image_info, name>::param_type param;
2625          cl_int result = getImageInfo(name, &param);
2626          if (err != NULL) {
2627              *err = result;
2628          }
2629          return param;
2630      }
2631  };
2632  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
2633  class Image1D : public Image
2634  {
2635  public:
2636      Image1D(
2637          const Context& context,
2638          cl_mem_flags flags,
2639          ImageFormat format,
2640          size_type width,
2641          void* host_ptr = NULL,
2642          cl_int* err = NULL)
2643      {
2644          cl_int error;
2645          cl_image_desc desc =
2646          {
2647              CL_MEM_OBJECT_IMAGE1D,
2648              width,
2649              0, 0, 0, 0, 0, 0, 0, 0
2650          };
2651          object_ = ::clCreateImage(
2652              context(), 
2653              flags, 
2654              &format, 
2655              &desc, 
2656              host_ptr, 
2657              &error);
2658          detail::errHandler(error, __CREATE_IMAGE_ERR);
2659          if (err != NULL) {
2660              *err = error;
2661          }
2662      }
2663      Image1D() { }
2664      explicit Image1D(const cl_mem& image1D, bool retainObject = false) :
2665          Image(image1D, retainObject) { }
2666      Image1D& operator = (const cl_mem& rhs)
2667      {
2668          Image::operator=(rhs);
2669          return *this;
2670      }
2671      Image1D(const Image1D& img) : Image(img) {}
2672      Image1D& operator = (const Image1D &img)
2673      {
2674          Image::operator=(img);
2675          return *this;
2676      }
2677      Image1D(Image1D&& img) CL_HPP_NOEXCEPT_ : Image(std::move(img)) {}
2678      Image1D& operator = (Image1D &&img)
2679      {
2680          Image::operator=(std::move(img));
2681          return *this;
2682      }
2683  };
2684  class Image1DBuffer : public Image
2685  {
2686  public:
2687      Image1DBuffer(
2688          const Context& context,
2689          cl_mem_flags flags,
2690          ImageFormat format,
2691          size_type width,
2692          const Buffer &buffer,
2693          cl_int* err = NULL)
2694      {
2695          cl_int error;
2696          cl_image_desc desc =
2697          {
2698              CL_MEM_OBJECT_IMAGE1D_BUFFER,
2699              width,
2700              0, 0, 0, 0, 0, 0, 0,
2701              buffer()
2702          };
2703          object_ = ::clCreateImage(
2704              context(), 
2705              flags, 
2706              &format, 
2707              &desc, 
2708              NULL, 
2709              &error);
2710          detail::errHandler(error, __CREATE_IMAGE_ERR);
2711          if (err != NULL) {
2712              *err = error;
2713          }
2714      }
2715      Image1DBuffer() { }
2716      explicit Image1DBuffer(const cl_mem& image1D, bool retainObject = false) :
2717          Image(image1D, retainObject) { }
2718      Image1DBuffer& operator = (const cl_mem& rhs)
2719      {
2720          Image::operator=(rhs);
2721          return *this;
2722      }
2723      Image1DBuffer(const Image1DBuffer& img) : Image(img) {}
2724      Image1DBuffer& operator = (const Image1DBuffer &img)
2725      {
2726          Image::operator=(img);
2727          return *this;
2728      }
2729      Image1DBuffer(Image1DBuffer&& img) CL_HPP_NOEXCEPT_ : Image(std::move(img)) {}
2730      Image1DBuffer& operator = (Image1DBuffer &&img)
2731      {
2732          Image::operator=(std::move(img));
2733          return *this;
2734      }
2735  };
2736  class Image1DArray : public Image
2737  {
2738  public:
2739      Image1DArray(
2740          const Context& context,
2741          cl_mem_flags flags,
2742          ImageFormat format,
2743          size_type arraySize,
2744          size_type width,
2745          size_type rowPitch,
2746          void* host_ptr = NULL,
2747          cl_int* err = NULL)
2748      {
2749          cl_int error;
2750          cl_image_desc desc =
2751          {
2752              CL_MEM_OBJECT_IMAGE1D_ARRAY,
2753              width,
2754              0, 0,  
2755              arraySize,
2756              rowPitch,
2757              0, 0, 0, 0
2758          };
2759          object_ = ::clCreateImage(
2760              context(), 
2761              flags, 
2762              &format, 
2763              &desc, 
2764              host_ptr, 
2765              &error);
2766          detail::errHandler(error, __CREATE_IMAGE_ERR);
2767          if (err != NULL) {
2768              *err = error;
2769          }
2770      }
2771      Image1DArray() { }
2772      explicit Image1DArray(const cl_mem& imageArray, bool retainObject = false) :
2773          Image(imageArray, retainObject) { }
2774      Image1DArray& operator = (const cl_mem& rhs)
2775      {
2776          Image::operator=(rhs);
2777          return *this;
2778      }
2779      Image1DArray(const Image1DArray& img) : Image(img) {}
2780      Image1DArray& operator = (const Image1DArray &img)
2781      {
2782          Image::operator=(img);
2783          return *this;
2784      }
2785      Image1DArray(Image1DArray&& img) CL_HPP_NOEXCEPT_ : Image(std::move(img)) {}
2786      Image1DArray& operator = (Image1DArray &&img)
2787      {
2788          Image::operator=(std::move(img));
2789          return *this;
2790      }
2791  };
2792  #endif 
2793  class Image2D : public Image
2794  {
2795  public:
2796      Image2D(
2797          const Context& context,
2798          cl_mem_flags flags,
2799          ImageFormat format,
2800          size_type width,
2801          size_type height,
2802          size_type row_pitch = 0,
2803          void* host_ptr = NULL,
2804          cl_int* err = NULL)
2805      {
2806          cl_int error;
2807          bool useCreateImage;
2808  #if CL_HPP_TARGET_OPENCL_VERSION >= 120 && CL_HPP_MINIMUM_OPENCL_VERSION < 120
2809          {
2810              cl_uint version = detail::getContextPlatformVersion(context());
2811              useCreateImage = (version >= 0x10002); 
2812          }
2813  #elif CL_HPP_TARGET_OPENCL_VERSION >= 120
2814          useCreateImage = true;
2815  #else
2816          useCreateImage = false;
2817  #endif
2818  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
2819          if (useCreateImage)
2820          {
2821              cl_image_desc desc =
2822              {
2823                  CL_MEM_OBJECT_IMAGE2D,
2824                  width,
2825                  height,
2826                  0, 0, 
2827                  row_pitch,
2828                  0, 0, 0, 0
2829              };
2830              object_ = ::clCreateImage(
2831                  context(),
2832                  flags,
2833                  &format,
2834                  &desc,
2835                  host_ptr,
2836                  &error);
2837              detail::errHandler(error, __CREATE_IMAGE_ERR);
2838              if (err != NULL) {
2839                  *err = error;
2840              }
2841          }
2842  #endif 
2843  #if CL_HPP_MINIMUM_OPENCL_VERSION < 120
2844          if (!useCreateImage)
2845          {
2846              object_ = ::clCreateImage2D(
2847                  context(), flags,&format, width, height, row_pitch, host_ptr, &error);
2848              detail::errHandler(error, __CREATE_IMAGE2D_ERR);
2849              if (err != NULL) {
2850                  *err = error;
2851              }
2852          }
2853  #endif 
2854      }
2855  #if CL_HPP_TARGET_OPENCL_VERSION >= 200
2856      Image2D(
2857          const Context& context,
2858          ImageFormat format,
2859          const Buffer &sourceBuffer,
2860          size_type width,
2861          size_type height,
2862          size_type row_pitch = 0,
2863          cl_int* err = nullptr)
2864      {
2865          cl_int error;
2866          cl_image_desc desc =
2867          {
2868              CL_MEM_OBJECT_IMAGE2D,
2869              width,
2870              height,
2871              0, 0, 
2872              row_pitch,
2873              0, 0, 0,
2874              sourceBuffer()
2875          };
2876          object_ = ::clCreateImage(
2877              context(),
2878              0, 
2879              &format,
2880              &desc,
2881              nullptr,
2882              &error);
2883          detail::errHandler(error, __CREATE_IMAGE_ERR);
2884          if (err != nullptr) {
2885              *err = error;
2886          }
2887      }
2888  #endif 
2889  #if CL_HPP_TARGET_OPENCL_VERSION >= 200
2890      Image2D(
2891          const Context& context,
2892          cl_channel_order order,
2893          const Image &sourceImage,
2894          cl_int* err = nullptr)
2895      {
2896          cl_int error;
2897          size_type sourceWidth = 
2898              sourceImage.getImageInfo<CL_IMAGE_WIDTH>();
2899          size_type sourceHeight = 
2900              sourceImage.getImageInfo<CL_IMAGE_HEIGHT>();
2901          size_type sourceRowPitch =
2902              sourceImage.getImageInfo<CL_IMAGE_ROW_PITCH>();
2903          cl_uint sourceNumMIPLevels =
2904              sourceImage.getImageInfo<CL_IMAGE_NUM_MIP_LEVELS>();
2905          cl_uint sourceNumSamples =
2906              sourceImage.getImageInfo<CL_IMAGE_NUM_SAMPLES>();
2907          cl_image_format sourceFormat =
2908              sourceImage.getImageInfo<CL_IMAGE_FORMAT>();
2909          sourceFormat.image_channel_order = order;
2910          cl_image_desc desc =
2911          {
2912              CL_MEM_OBJECT_IMAGE2D,
2913              sourceWidth,
2914              sourceHeight,
2915              0, 0, 
2916              sourceRowPitch,
2917              0, 
2918              sourceNumMIPLevels,
2919              sourceNumSamples,
2920              sourceImage()
2921          };
2922          object_ = ::clCreateImage(
2923              context(),
2924              0, 
2925              &sourceFormat,
2926              &desc,
2927              nullptr,
2928              &error);
2929          detail::errHandler(error, __CREATE_IMAGE_ERR);
2930          if (err != nullptr) {
2931              *err = error;
2932          }
2933      }
2934  #endif 
2935      Image2D() { }
2936      explicit Image2D(const cl_mem& image2D, bool retainObject = false) :
2937          Image(image2D, retainObject) { }
2938      Image2D& operator = (const cl_mem& rhs)
2939      {
2940          Image::operator=(rhs);
2941          return *this;
2942      }
2943      Image2D(const Image2D& img) : Image(img) {}
2944      Image2D& operator = (const Image2D &img)
2945      {
2946          Image::operator=(img);
2947          return *this;
2948      }
2949      Image2D(Image2D&& img) CL_HPP_NOEXCEPT_ : Image(std::move(img)) {}
2950      Image2D& operator = (Image2D &&img)
2951      {
2952          Image::operator=(std::move(img));
2953          return *this;
2954      }
2955  };
2956  #if defined(CL_USE_DEPRECATED_OPENCL_1_1_APIS)
2957  class CL_EXT_PREFIX__VERSION_1_1_DEPRECATED Image2DGL : public Image2D 
2958  {
2959  public:
2960      Image2DGL(
2961          const Context& context,
2962          cl_mem_flags flags,
2963          cl_GLenum target,
2964          cl_GLint  miplevel,
2965          cl_GLuint texobj,
2966          cl_int * err = NULL)
2967      {
2968          cl_int error;
2969          object_ = ::clCreateFromGLTexture2D(
2970              context(),
2971              flags,
2972              target,
2973              miplevel,
2974              texobj,
2975              &error);
2976          detail::errHandler(error, __CREATE_GL_TEXTURE_2D_ERR);
2977          if (err != NULL) {
2978              *err = error;
2979          }
2980      }
2981      Image2DGL() : Image2D() { }
2982      explicit Image2DGL(const cl_mem& image, bool retainObject = false) : 
2983          Image2D(image, retainObject) { }
2984      Image2DGL& operator = (const cl_mem& rhs)
2985      {
2986          Image2D::operator=(rhs);
2987          return *this;
2988      }
2989      Image2DGL(const Image2DGL& img) : Image2D(img) {}
2990      Image2DGL& operator = (const Image2DGL &img)
2991      {
2992          Image2D::operator=(img);
2993          return *this;
2994      }
2995      Image2DGL(Image2DGL&& img) CL_HPP_NOEXCEPT_ : Image2D(std::move(img)) {}
2996      Image2DGL& operator = (Image2DGL &&img)
2997      {
2998          Image2D::operator=(std::move(img));
2999          return *this;
3000      }
3001  } CL_EXT_SUFFIX__VERSION_1_1_DEPRECATED;
3002  #endif 
3003  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
3004  class Image2DArray : public Image
3005  {
3006  public:
3007      Image2DArray(
3008          const Context& context,
3009          cl_mem_flags flags,
3010          ImageFormat format,
3011          size_type arraySize,
3012          size_type width,
3013          size_type height,
3014          size_type rowPitch,
3015          size_type slicePitch,
3016          void* host_ptr = NULL,
3017          cl_int* err = NULL)
3018      {
3019          cl_int error;
3020          cl_image_desc desc =
3021          {
3022              CL_MEM_OBJECT_IMAGE2D_ARRAY,
3023              width,
3024              height,
3025              0,       
3026              arraySize,
3027              rowPitch,
3028              slicePitch,
3029              0, 0, 0
3030          };
3031          object_ = ::clCreateImage(
3032              context(), 
3033              flags, 
3034              &format, 
3035              &desc, 
3036              host_ptr, 
3037              &error);
3038          detail::errHandler(error, __CREATE_IMAGE_ERR);
3039          if (err != NULL) {
3040              *err = error;
3041          }
3042      }
3043      Image2DArray() { }
3044      explicit Image2DArray(const cl_mem& imageArray, bool retainObject = false) : Image(imageArray, retainObject) { }
3045      Image2DArray& operator = (const cl_mem& rhs)
3046      {
3047          Image::operator=(rhs);
3048          return *this;
3049      }
3050      Image2DArray(const Image2DArray& img) : Image(img) {}
3051      Image2DArray& operator = (const Image2DArray &img)
3052      {
3053          Image::operator=(img);
3054          return *this;
3055      }
3056      Image2DArray(Image2DArray&& img) CL_HPP_NOEXCEPT_ : Image(std::move(img)) {}
3057      Image2DArray& operator = (Image2DArray &&img)
3058      {
3059          Image::operator=(std::move(img));
3060          return *this;
3061      }
3062  };
3063  #endif 
3064  class Image3D : public Image
3065  {
3066  public:
3067      Image3D(
3068          const Context& context,
3069          cl_mem_flags flags,
3070          ImageFormat format,
3071          size_type width,
3072          size_type height,
3073          size_type depth,
3074          size_type row_pitch = 0,
3075          size_type slice_pitch = 0,
3076          void* host_ptr = NULL,
3077          cl_int* err = NULL)
3078      {
3079          cl_int error;
3080          bool useCreateImage;
3081  #if CL_HPP_TARGET_OPENCL_VERSION >= 120 && CL_HPP_MINIMUM_OPENCL_VERSION < 120
3082          {
3083              cl_uint version = detail::getContextPlatformVersion(context());
3084              useCreateImage = (version >= 0x10002); 
3085          }
3086  #elif CL_HPP_TARGET_OPENCL_VERSION >= 120
3087          useCreateImage = true;
3088  #else
3089          useCreateImage = false;
3090  #endif
3091  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
3092          if (useCreateImage)
3093          {
3094              cl_image_desc desc =
3095              {
3096                  CL_MEM_OBJECT_IMAGE3D,
3097                  width,
3098                  height,
3099                  depth,
3100                  0,      
3101                  row_pitch,
3102                  slice_pitch,
3103                  0, 0, 0
3104              };
3105              object_ = ::clCreateImage(
3106                  context(), 
3107                  flags, 
3108                  &format, 
3109                  &desc, 
3110                  host_ptr, 
3111                  &error);
3112              detail::errHandler(error, __CREATE_IMAGE_ERR);
3113              if (err != NULL) {
3114                  *err = error;
3115              }
3116          }
3117  #endif  
3118  #if CL_HPP_MINIMUM_OPENCL_VERSION < 120
3119          if (!useCreateImage)
3120          {
3121              object_ = ::clCreateImage3D(
3122                  context(), flags, &format, width, height, depth, row_pitch,
3123                  slice_pitch, host_ptr, &error);
3124              detail::errHandler(error, __CREATE_IMAGE3D_ERR);
3125              if (err != NULL) {
3126                  *err = error;
3127              }
3128          }
3129  #endif 
3130      }
3131      Image3D() : Image() { }
3132      explicit Image3D(const cl_mem& image3D, bool retainObject = false) : 
3133          Image(image3D, retainObject) { }
3134      Image3D& operator = (const cl_mem& rhs)
3135      {
3136          Image::operator=(rhs);
3137          return *this;
3138      }
3139      Image3D(const Image3D& img) : Image(img) {}
3140      Image3D& operator = (const Image3D &img)
3141      {
3142          Image::operator=(img);
3143          return *this;
3144      }
3145      Image3D(Image3D&& img) CL_HPP_NOEXCEPT_ : Image(std::move(img)) {}
3146      Image3D& operator = (Image3D &&img)
3147      {
3148          Image::operator=(std::move(img));
3149          return *this;
3150      }
3151  };
3152  #if defined(CL_USE_DEPRECATED_OPENCL_1_1_APIS)
3153  class Image3DGL : public Image3D
3154  {
3155  public:
3156      Image3DGL(
3157          const Context& context,
3158          cl_mem_flags flags,
3159          cl_GLenum target,
3160          cl_GLint  miplevel,
3161          cl_GLuint texobj,
3162          cl_int * err = NULL)
3163      {
3164          cl_int error;
3165          object_ = ::clCreateFromGLTexture3D(
3166              context(),
3167              flags,
3168              target,
3169              miplevel,
3170              texobj,
3171              &error);
3172          detail::errHandler(error, __CREATE_GL_TEXTURE_3D_ERR);
3173          if (err != NULL) {
3174              *err = error;
3175          }
3176      }
3177      Image3DGL() : Image3D() { }
3178      explicit Image3DGL(const cl_mem& image, bool retainObject = false) : 
3179          Image3D(image, retainObject) { }
3180      Image3DGL& operator = (const cl_mem& rhs)
3181      {
3182          Image3D::operator=(rhs);
3183          return *this;
3184      }
3185      Image3DGL(const Image3DGL& img) : Image3D(img) {}
3186      Image3DGL& operator = (const Image3DGL &img)
3187      {
3188          Image3D::operator=(img);
3189          return *this;
3190      }
3191      Image3DGL(Image3DGL&& img) CL_HPP_NOEXCEPT_ : Image3D(std::move(img)) {}
3192      Image3DGL& operator = (Image3DGL &&img)
3193      {
3194          Image3D::operator=(std::move(img));
3195          return *this;
3196      }
3197  };
3198  #endif 
3199  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
3200  class ImageGL : public Image
3201  {
3202  public:
3203      ImageGL(
3204          const Context& context,
3205          cl_mem_flags flags,
3206          cl_GLenum target,
3207          cl_GLint  miplevel,
3208          cl_GLuint texobj,
3209          cl_int * err = NULL)
3210      {
3211          cl_int error;
3212          object_ = ::clCreateFromGLTexture(
3213              context(), 
3214              flags, 
3215              target,
3216              miplevel,
3217              texobj,
3218              &error);
3219          detail::errHandler(error, __CREATE_GL_TEXTURE_ERR);
3220          if (err != NULL) {
3221              *err = error;
3222          }
3223      }
3224      ImageGL() : Image() { }
3225      explicit ImageGL(const cl_mem& image, bool retainObject = false) : 
3226          Image(image, retainObject) { }
3227      ImageGL& operator = (const cl_mem& rhs)
3228      {
3229          Image::operator=(rhs);
3230          return *this;
3231      }
3232      ImageGL(const ImageGL& img) : Image(img) {}
3233      ImageGL& operator = (const ImageGL &img)
3234      {
3235          Image::operator=(img);
3236          return *this;
3237      }
3238      ImageGL(ImageGL&& img) CL_HPP_NOEXCEPT_ : Image(std::move(img)) {}
3239      ImageGL& operator = (ImageGL &&img)
3240      {
3241          Image::operator=(std::move(img));
3242          return *this;
3243      }
3244  };
3245  #endif 
3246  #if CL_HPP_TARGET_OPENCL_VERSION >= 200
3247  class Pipe : public Memory
3248  {
3249  public:
3250      Pipe(
3251          const Context& context,
3252          cl_uint packet_size,
3253          cl_uint max_packets,
3254          cl_int* err = NULL)
3255      {
3256          cl_int error;
3257          cl_mem_flags flags = CL_MEM_READ_WRITE | CL_MEM_HOST_NO_ACCESS;
3258          object_ = ::clCreatePipe(context(), flags, packet_size, max_packets, nullptr, &error);
3259          detail::errHandler(error, __CREATE_PIPE_ERR);
3260          if (err != NULL) {
3261              *err = error;
3262          }
3263      }
3264      Pipe(
3265          cl_uint packet_size,
3266          cl_uint max_packets,
3267          cl_int* err = NULL)
3268      {
3269          cl_int error;
3270          Context context = Context::getDefault(err);
3271          cl_mem_flags flags = CL_MEM_READ_WRITE | CL_MEM_HOST_NO_ACCESS;
3272          object_ = ::clCreatePipe(context(), flags, packet_size, max_packets, nullptr, &error);
3273          detail::errHandler(error, __CREATE_PIPE_ERR);
3274          if (err != NULL) {
3275              *err = error;
3276          }
3277      }
3278      Pipe() : Memory() { }
3279      explicit Pipe(const cl_mem& pipe, bool retainObject = false) :
3280          Memory(pipe, retainObject) { }
3281      Pipe& operator = (const cl_mem& rhs)
3282      {
3283          Memory::operator=(rhs);
3284          return *this;
3285      }
3286      Pipe(const Pipe& pipe) : Memory(pipe) {}
3287      Pipe& operator = (const Pipe &pipe)
3288      {
3289          Memory::operator=(pipe);
3290          return *this;
3291      }
3292      Pipe(Pipe&& pipe) CL_HPP_NOEXCEPT_ : Memory(std::move(pipe)) {}
3293      Pipe& operator = (Pipe &&pipe)
3294      {
3295          Memory::operator=(std::move(pipe));
3296          return *this;
3297      }
3298      template <typename T>
3299      cl_int getInfo(cl_pipe_info name, T* param) const
3300      {
3301          return detail::errHandler(
3302              detail::getInfo(&::clGetPipeInfo, object_, name, param),
3303              __GET_PIPE_INFO_ERR);
3304      }
3305      template <cl_int name> typename
3306          detail::param_traits<detail::cl_pipe_info, name>::param_type
3307          getInfo(cl_int* err = NULL) const
3308      {
3309          typename detail::param_traits<
3310              detail::cl_pipe_info, name>::param_type param;
3311          cl_int result = getInfo(name, &param);
3312          if (err != NULL) {
3313              *err = result;
3314          }
3315          return param;
3316      }
3317  }; 
3318  #endif 
3319  class Sampler : public detail::Wrapper<cl_sampler>
3320  {
3321  public:
3322      Sampler() { }
3323      Sampler(
3324          const Context& context,
3325          cl_bool normalized_coords,
3326          cl_addressing_mode addressing_mode,
3327          cl_filter_mode filter_mode,
3328          cl_int* err = NULL)
3329      {
3330          cl_int error;
3331  #if CL_HPP_TARGET_OPENCL_VERSION >= 200
3332          cl_sampler_properties sampler_properties[] = {
3333              CL_SAMPLER_NORMALIZED_COORDS, normalized_coords,
3334              CL_SAMPLER_ADDRESSING_MODE, addressing_mode,
3335              CL_SAMPLER_FILTER_MODE, filter_mode,
3336              0 };
3337          object_ = ::clCreateSamplerWithProperties(
3338              context(),
3339              sampler_properties,
3340              &error);
3341          detail::errHandler(error, __CREATE_SAMPLER_WITH_PROPERTIES_ERR);
3342          if (err != NULL) {
3343              *err = error;
3344          }
3345  #else
3346          object_ = ::clCreateSampler(
3347              context(),
3348              normalized_coords,
3349              addressing_mode,
3350              filter_mode,
3351              &error);
3352          detail::errHandler(error, __CREATE_SAMPLER_ERR);
3353          if (err != NULL) {
3354              *err = error;
3355          }
3356  #endif        
3357      }
3358      explicit Sampler(const cl_sampler& sampler, bool retainObject = false) : 
3359          detail::Wrapper<cl_type>(sampler, retainObject) { }
3360      Sampler& operator = (const cl_sampler& rhs)
3361      {
3362          detail::Wrapper<cl_type>::operator=(rhs);
3363          return *this;
3364      }
3365      Sampler(const Sampler& sam) : detail::Wrapper<cl_type>(sam) {}
3366      Sampler& operator = (const Sampler &sam)
3367      {
3368          detail::Wrapper<cl_type>::operator=(sam);
3369          return *this;
3370      }
3371      Sampler(Sampler&& sam) CL_HPP_NOEXCEPT_ : detail::Wrapper<cl_type>(std::move(sam)) {}
3372      Sampler& operator = (Sampler &&sam)
3373      {
3374          detail::Wrapper<cl_type>::operator=(std::move(sam));
3375          return *this;
3376      }
3377      template <typename T>
3378      cl_int getInfo(cl_sampler_info name, T* param) const
3379      {
3380          return detail::errHandler(
3381              detail::getInfo(&::clGetSamplerInfo, object_, name, param),
3382              __GET_SAMPLER_INFO_ERR);
3383      }
3384      template <cl_int name> typename
3385      detail::param_traits<detail::cl_sampler_info, name>::param_type
3386      getInfo(cl_int* err = NULL) const
3387      {
3388          typename detail::param_traits<
3389              detail::cl_sampler_info, name>::param_type param;
3390          cl_int result = getInfo(name, &param);
3391          if (err != NULL) {
3392              *err = result;
3393          }
3394          return param;
3395      }
3396  };
3397  class Program;
3398  class CommandQueue;
3399  class DeviceCommandQueue;
3400  class Kernel;
3401  class NDRange
3402  {
3403  private:
3404      size_type sizes_[3];
3405      cl_uint dimensions_;
3406  public:
3407      NDRange()
3408          : dimensions_(0)
3409      {
3410          sizes_[0] = 0;
3411          sizes_[1] = 0;
3412          sizes_[2] = 0;
3413      }
3414      NDRange(size_type size0)
3415          : dimensions_(1)
3416      {
3417          sizes_[0] = size0;
3418          sizes_[1] = 1;
3419          sizes_[2] = 1;
3420      }
3421      NDRange(size_type size0, size_type size1)
3422          : dimensions_(2)
3423      {
3424          sizes_[0] = size0;
3425          sizes_[1] = size1;
3426          sizes_[2] = 1;
3427      }
3428      NDRange(size_type size0, size_type size1, size_type size2)
3429          : dimensions_(3)
3430      {
3431          sizes_[0] = size0;
3432          sizes_[1] = size1;
3433          sizes_[2] = size2;
3434      }
3435      operator const size_type*() const { 
3436          return sizes_; 
3437      }
3438      size_type dimensions() const 
3439      { 
3440          return dimensions_; 
3441      }
3442      size_type size() const
3443      {
3444          return dimensions_*sizeof(size_type);
3445      }
3446      size_type* get()
3447      {
3448          return sizes_;
3449      }
3450      const size_type* get() const
3451      {
3452          return sizes_;
3453      }
3454  };
3455  static const NDRange NullRange;
3456  struct LocalSpaceArg
3457  {
3458      size_type size_;
3459  };
3460  namespace detail {
3461  template <typename T, class Enable = void>
3462  struct KernelArgumentHandler;
3463  template <typename T>
3464  struct KernelArgumentHandler<T, typename std::enable_if<!std::is_base_of<cl::Memory, T>::value>::type>
3465  {
3466      static size_type size(const T&) { return sizeof(T); }
3467      static const T* ptr(const T& value) { return &value; }
3468  };
3469  template <typename T>
3470  struct KernelArgumentHandler<T, typename std::enable_if<std::is_base_of<cl::Memory, T>::value>::type>
3471  {
3472      static size_type size(const T&) { return sizeof(cl_mem); }
3473      static const cl_mem* ptr(const T& value) { return &(value()); }
3474  };
3475  template <>
3476  struct KernelArgumentHandler<LocalSpaceArg, void>
3477  {
3478      static size_type size(const LocalSpaceArg& value) { return value.size_; }
3479      static const void* ptr(const LocalSpaceArg&) { return NULL; }
3480  };
3481  } 
3482  inline LocalSpaceArg
3483  Local(size_type size)
3484  {
3485      LocalSpaceArg ret = { size };
3486      return ret;
3487  }
3488  class Kernel : public detail::Wrapper<cl_kernel>
3489  {
3490  public:
3491      inline Kernel(const Program& program, const char* name, cl_int* err = NULL);
3492      Kernel() { }
3493      explicit Kernel(const cl_kernel& kernel, bool retainObject = false) : 
3494          detail::Wrapper<cl_type>(kernel, retainObject) { }
3495      Kernel& operator = (const cl_kernel& rhs)
3496      {
3497          detail::Wrapper<cl_type>::operator=(rhs);
3498          return *this;
3499      }
3500      Kernel(const Kernel& kernel) : detail::Wrapper<cl_type>(kernel) {}
3501      Kernel& operator = (const Kernel &kernel)
3502      {
3503          detail::Wrapper<cl_type>::operator=(kernel);
3504          return *this;
3505      }
3506      Kernel(Kernel&& kernel) CL_HPP_NOEXCEPT_ : detail::Wrapper<cl_type>(std::move(kernel)) {}
3507      Kernel& operator = (Kernel &&kernel)
3508      {
3509          detail::Wrapper<cl_type>::operator=(std::move(kernel));
3510          return *this;
3511      }
3512      template <typename T>
3513      cl_int getInfo(cl_kernel_info name, T* param) const
3514      {
3515          return detail::errHandler(
3516              detail::getInfo(&::clGetKernelInfo, object_, name, param),
3517              __GET_KERNEL_INFO_ERR);
3518      }
3519      template <cl_int name> typename
3520      detail::param_traits<detail::cl_kernel_info, name>::param_type
3521      getInfo(cl_int* err = NULL) const
3522      {
3523          typename detail::param_traits<
3524              detail::cl_kernel_info, name>::param_type param;
3525          cl_int result = getInfo(name, &param);
3526          if (err != NULL) {
3527              *err = result;
3528          }
3529          return param;
3530      }
3531  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
3532      template <typename T>
3533      cl_int getArgInfo(cl_uint argIndex, cl_kernel_arg_info name, T* param) const
3534      {
3535          return detail::errHandler(
3536              detail::getInfo(&::clGetKernelArgInfo, object_, argIndex, name, param),
3537              __GET_KERNEL_ARG_INFO_ERR);
3538      }
3539      template <cl_int name> typename
3540      detail::param_traits<detail::cl_kernel_arg_info, name>::param_type
3541      getArgInfo(cl_uint argIndex, cl_int* err = NULL) const
3542      {
3543          typename detail::param_traits<
3544              detail::cl_kernel_arg_info, name>::param_type param;
3545          cl_int result = getArgInfo(argIndex, name, &param);
3546          if (err != NULL) {
3547              *err = result;
3548          }
3549          return param;
3550      }
3551  #endif 
3552      template <typename T>
3553      cl_int getWorkGroupInfo(
3554          const Device& device, cl_kernel_work_group_info name, T* param) const
3555      {
3556          return detail::errHandler(
3557              detail::getInfo(
3558                  &::clGetKernelWorkGroupInfo, object_, device(), name, param),
3559                  __GET_KERNEL_WORK_GROUP_INFO_ERR);
3560      }
3561      template <cl_int name> typename
3562      detail::param_traits<detail::cl_kernel_work_group_info, name>::param_type
3563          getWorkGroupInfo(const Device& device, cl_int* err = NULL) const
3564      {
3565          typename detail::param_traits<
3566          detail::cl_kernel_work_group_info, name>::param_type param;
3567          cl_int result = getWorkGroupInfo(device, name, &param);
3568          if (err != NULL) {
3569              *err = result;
3570          }
3571          return param;
3572      }
3573  #if CL_HPP_TARGET_OPENCL_VERSION >= 200
3574  #if defined(CL_HPP_USE_CL_SUB_GROUPS_KHR)
3575      cl_int getSubGroupInfo(const cl::Device &dev, cl_kernel_sub_group_info name, const cl::NDRange &range, size_type* param) const
3576      {
3577          typedef clGetKernelSubGroupInfoKHR_fn PFN_clGetKernelSubGroupInfoKHR;
3578          static PFN_clGetKernelSubGroupInfoKHR pfn_clGetKernelSubGroupInfoKHR = NULL;
3579          CL_HPP_INIT_CL_EXT_FCN_PTR_(clGetKernelSubGroupInfoKHR);
3580          return detail::errHandler(
3581              pfn_clGetKernelSubGroupInfoKHR(object_, dev(), name, range.size(), range.get(), sizeof(size_type), param, nullptr),
3582              __GET_KERNEL_ARG_INFO_ERR);
3583      }
3584      template <cl_int name>
3585          size_type getSubGroupInfo(const cl::Device &dev, const cl::NDRange &range, cl_int* err = NULL) const
3586      {
3587          size_type param;
3588          cl_int result = getSubGroupInfo(dev, name, range, &param);
3589          if (err != NULL) {
3590              *err = result;
3591          }
3592          return param;
3593      }
3594  #endif 
3595  #endif 
3596  #if CL_HPP_TARGET_OPENCL_VERSION >= 200
3597      template<typename T, class D>
3598      cl_int setArg(cl_uint index, const cl::pointer<T, D> &argPtr)
3599      {
3600          return detail::errHandler(
3601              ::clSetKernelArgSVMPointer(object_, index, argPtr.get()),
3602              __SET_KERNEL_ARGS_ERR);
3603      }
3604      template<typename T, class Alloc>
3605      cl_int setArg(cl_uint index, const cl::vector<T, Alloc> &argPtr)
3606      {
3607          return detail::errHandler(
3608              ::clSetKernelArgSVMPointer(object_, index, argPtr.data()),
3609              __SET_KERNEL_ARGS_ERR);
3610      }
3611      template<typename T>
3612      typename std::enable_if<std::is_pointer<T>::value, cl_int>::type
3613          setArg(cl_uint index, const T argPtr)
3614      {
3615          return detail::errHandler(
3616              ::clSetKernelArgSVMPointer(object_, index, argPtr),
3617              __SET_KERNEL_ARGS_ERR);
3618      }
3619  #endif 
3620      template <typename T>
3621      typename std::enable_if<!std::is_pointer<T>::value, cl_int>::type
3622          setArg(cl_uint index, const T &value)
3623      {
3624          return detail::errHandler(
3625              ::clSetKernelArg(
3626                  object_,
3627                  index,
3628                  detail::KernelArgumentHandler<T>::size(value),
3629                  detail::KernelArgumentHandler<T>::ptr(value)),
3630              __SET_KERNEL_ARGS_ERR);
3631      }
3632      cl_int setArg(cl_uint index, size_type size, const void* argPtr)
3633      {
3634          return detail::errHandler(
3635              ::clSetKernelArg(object_, index, size, argPtr),
3636              __SET_KERNEL_ARGS_ERR);
3637      }
3638  #if CL_HPP_TARGET_OPENCL_VERSION >= 200
3639      cl_int setSVMPointers(const vector<void*> &pointerList)
3640      {
3641          return detail::errHandler(
3642              ::clSetKernelExecInfo(
3643                  object_,
3644                  CL_KERNEL_EXEC_INFO_SVM_PTRS,
3645                  sizeof(void*)*pointerList.size(),
3646                  pointerList.data()));
3647      }
3648      template<int ArrayLength>
3649      cl_int setSVMPointers(const std::array<void*, ArrayLength> &pointerList)
3650      {
3651          return detail::errHandler(
3652              ::clSetKernelExecInfo(
3653                  object_,
3654                  CL_KERNEL_EXEC_INFO_SVM_PTRS,
3655                  sizeof(void*)*pointerList.size(),
3656                  pointerList.data()));
3657      }
3658      cl_int enableFineGrainedSystemSVM(bool svmEnabled)
3659      {
3660          cl_bool svmEnabled_ = svmEnabled ? CL_TRUE : CL_FALSE;
3661          return detail::errHandler(
3662              ::clSetKernelExecInfo(
3663                  object_,
3664                  CL_KERNEL_EXEC_INFO_SVM_FINE_GRAIN_SYSTEM,
3665                  sizeof(cl_bool),
3666                  &svmEnabled_
3667                  )
3668              );
3669      }
3670      template<int index, int ArrayLength, class D, typename T0, typename... Ts>
3671      void setSVMPointersHelper(std::array<void*, ArrayLength> &pointerList, const pointer<T0, D> &t0, Ts... ts)
3672      {
3673          pointerList[index] = static_cast<void*>(t0.get());
3674          setSVMPointersHelper<index + 1, Ts...>(ts...);
3675      }
3676      template<int index, int ArrayLength, typename T0, typename... Ts>
3677      typename std::enable_if<std::is_pointer<T0>::value, void>::type
3678      setSVMPointersHelper(std::array<void*, ArrayLength> &pointerList, T0 t0, Ts... ts)
3679      {
3680          pointerList[index] = static_cast<void*>(t0);
3681          setSVMPointersHelper<index + 1, Ts...>(ts...);
3682      }
3683      template<int index, int ArrayLength, typename T0, class D>
3684      void setSVMPointersHelper(std::array<void*, ArrayLength> &pointerList, const pointer<T0, D> &t0)
3685      {
3686          pointerList[index] = static_cast<void*>(t0.get());
3687      }
3688      template<int index, int ArrayLength, typename T0>
3689      typename std::enable_if<std::is_pointer<T0>::value, void>::type
3690      setSVMPointersHelper(std::array<void*, ArrayLength> &pointerList, T0 t0)
3691      {
3692          pointerList[index] = static_cast<void*>(t0);
3693      }
3694      template<typename T0, typename... Ts>
3695      cl_int setSVMPointers(const T0 &t0, Ts... ts)
3696      {
3697          std::array<void*, 1 + sizeof...(Ts)> pointerList;
3698          setSVMPointersHelper<0, 1 + sizeof...(Ts)>(pointerList, t0, ts...);
3699          return detail::errHandler(
3700              ::clSetKernelExecInfo(
3701              object_,
3702              CL_KERNEL_EXEC_INFO_SVM_PTRS,
3703              sizeof(void*)*(1 + sizeof...(Ts)),
3704              pointerList.data()));
3705      }
3706  #endif 
3707  };
3708  class Program : public detail::Wrapper<cl_program>
3709  {
3710  public:
3711  #if !defined(CL_HPP_ENABLE_PROGRAM_CONSTRUCTION_FROM_ARRAY_COMPATIBILITY)
3712      typedef vector<vector<unsigned char>> Binaries;
3713      typedef vector<string> Sources;
3714  #else 
3715      typedef vector<std::pair<const void*, size_type> > Binaries;
3716      typedef vector<std::pair<const char*, size_type> > Sources;
3717  #endif 
3718      Program(
3719          const string& source,
3720          bool build = false,
3721          cl_int* err = NULL)
3722      {
3723          cl_int error;
3724          const char * strings = source.c_str();
3725          const size_type length  = source.size();
3726          Context context = Context::getDefault(err);
3727          object_ = ::clCreateProgramWithSource(
3728              context(), (cl_uint)1, &strings, &length, &error);
3729          detail::errHandler(error, __CREATE_PROGRAM_WITH_SOURCE_ERR);
3730          if (error == CL_SUCCESS && build) {
3731              error = ::clBuildProgram(
3732                  object_,
3733                  0,
3734                  NULL,
3735  #if !defined(CL_HPP_CL_1_2_DEFAULT_BUILD)
3736                  "-cl-std=CL2.0",
3737  #else
3738                  "",
3739  #endif 
3740                  NULL,
3741                  NULL);
3742              detail::buildErrHandler(error, __BUILD_PROGRAM_ERR, getBuildInfo<CL_PROGRAM_BUILD_LOG>());
3743          }
3744          if (err != NULL) {
3745              *err = error;
3746          }
3747      }
3748      Program(
3749          const Context& context,
3750          const string& source,
3751          bool build = false,
3752          cl_int* err = NULL)
3753      {
3754          cl_int error;
3755          const char * strings = source.c_str();
3756          const size_type length  = source.size();
3757          object_ = ::clCreateProgramWithSource(
3758              context(), (cl_uint)1, &strings, &length, &error);
3759          detail::errHandler(error, __CREATE_PROGRAM_WITH_SOURCE_ERR);
3760          if (error == CL_SUCCESS && build) {
3761              error = ::clBuildProgram(
3762                  object_,
3763                  0,
3764                  NULL,
3765  #if !defined(CL_HPP_CL_1_2_DEFAULT_BUILD)
3766                  "-cl-std=CL2.0",
3767  #else
3768                  "",
3769  #endif 
3770                  NULL,
3771                  NULL);
3772              detail::buildErrHandler(error, __BUILD_PROGRAM_ERR, getBuildInfo<CL_PROGRAM_BUILD_LOG>());
3773          }
3774          if (err != NULL) {
3775              *err = error;
3776          }
3777      }
3778      Program(
3779          const Sources& sources,
3780          cl_int* err = NULL)
3781      {
3782          cl_int error;
3783          Context context = Context::getDefault(err);
3784          const size_type n = (size_type)sources.size();
3785          vector<size_type> lengths(n);
3786          vector<const char*> strings(n);
3787          for (size_type i = 0; i < n; ++i) {
3788  #if !defined(CL_HPP_ENABLE_PROGRAM_CONSTRUCTION_FROM_ARRAY_COMPATIBILITY)
3789              strings[i] = sources[(int)i].data();
3790              lengths[i] = sources[(int)i].length();
3791  #else 
3792              strings[i] = sources[(int)i].first;
3793              lengths[i] = sources[(int)i].second;
3794  #endif 
3795          }
3796          object_ = ::clCreateProgramWithSource(
3797              context(), (cl_uint)n, strings.data(), lengths.data(), &error);
3798          detail::errHandler(error, __CREATE_PROGRAM_WITH_SOURCE_ERR);
3799          if (err != NULL) {
3800              *err = error;
3801          }
3802      }
3803      Program(
3804          const Context& context,
3805          const Sources& sources,
3806          cl_int* err = NULL)
3807      {
3808          cl_int error;
3809          const size_type n = (size_type)sources.size();
3810          vector<size_type> lengths(n);
3811          vector<const char*> strings(n);
3812          for (size_type i = 0; i < n; ++i) {
3813  #if !defined(CL_HPP_ENABLE_PROGRAM_CONSTRUCTION_FROM_ARRAY_COMPATIBILITY)
3814              strings[i] = sources[(int)i].data();
3815              lengths[i] = sources[(int)i].length();
3816  #else 
3817              strings[i] = sources[(int)i].first;
3818              lengths[i] = sources[(int)i].second;
3819  #endif 
3820          }
3821          object_ = ::clCreateProgramWithSource(
3822              context(), (cl_uint)n, strings.data(), lengths.data(), &error);
3823          detail::errHandler(error, __CREATE_PROGRAM_WITH_SOURCE_ERR);
3824          if (err != NULL) {
3825              *err = error;
3826          }
3827      }
3828      Program(
3829          const Context& context,
3830          const vector<Device>& devices,
3831          const Binaries& binaries,
3832          vector<cl_int>* binaryStatus = NULL,
3833          cl_int* err = NULL)
3834      {
3835          cl_int error;
3836          const size_type numDevices = devices.size();
3837          if(binaries.size() != numDevices) {
3838              error = CL_INVALID_VALUE;
3839              detail::errHandler(error, __CREATE_PROGRAM_WITH_BINARY_ERR);
3840              if (err != NULL) {
3841                  *err = error;
3842              }
3843              return;
3844          }
3845          vector<size_type> lengths(numDevices);
3846          vector<const unsigned char*> images(numDevices);
3847  #if !defined(CL_HPP_ENABLE_PROGRAM_CONSTRUCTION_FROM_ARRAY_COMPATIBILITY)
3848          for (size_type i = 0; i < numDevices; ++i) {
3849              images[i] = binaries[i].data();
3850              lengths[i] = binaries[(int)i].size();
3851          }
3852  #else 
3853          for (size_type i = 0; i < numDevices; ++i) {
3854              images[i] = (const unsigned char*)binaries[i].first;
3855              lengths[i] = binaries[(int)i].second;
3856          }
3857  #endif 
3858          vector<cl_device_id> deviceIDs(numDevices);
3859          for( size_type deviceIndex = 0; deviceIndex < numDevices; ++deviceIndex ) {
3860              deviceIDs[deviceIndex] = (devices[deviceIndex])();
3861          }
3862          if(binaryStatus) {
3863              binaryStatus->resize(numDevices);
3864          }
3865          object_ = ::clCreateProgramWithBinary(
3866              context(), (cl_uint) devices.size(),
3867              deviceIDs.data(),
3868              lengths.data(), images.data(), (binaryStatus != NULL && numDevices > 0)
3869                 ? &binaryStatus->front()
3870                 : NULL, &error);
3871          detail::errHandler(error, __CREATE_PROGRAM_WITH_BINARY_ERR);
3872          if (err != NULL) {
3873              *err = error;
3874          }
3875      }
3876  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
3877      Program(
3878          const Context& context,
3879          const vector<Device>& devices,
3880          const string& kernelNames,
3881          cl_int* err = NULL)
3882      {
3883          cl_int error;
3884          size_type numDevices = devices.size();
3885          vector<cl_device_id> deviceIDs(numDevices);
3886          for( size_type deviceIndex = 0; deviceIndex < numDevices; ++deviceIndex ) {
3887              deviceIDs[deviceIndex] = (devices[deviceIndex])();
3888          }
3889          object_ = ::clCreateProgramWithBuiltInKernels(
3890              context(), 
3891              (cl_uint) devices.size(),
3892              deviceIDs.data(),
3893              kernelNames.c_str(), 
3894              &error);
3895          detail::errHandler(error, __CREATE_PROGRAM_WITH_BUILT_IN_KERNELS_ERR);
3896          if (err != NULL) {
3897              *err = error;
3898          }
3899      }
3900  #endif 
3901      Program() { }
3902      explicit Program(const cl_program& program, bool retainObject = false) : 
3903          detail::Wrapper<cl_type>(program, retainObject) { }
3904      Program& operator = (const cl_program& rhs)
3905      {
3906          detail::Wrapper<cl_type>::operator=(rhs);
3907          return *this;
3908      }
3909      Program(const Program& program) : detail::Wrapper<cl_type>(program) {}
3910      Program& operator = (const Program &program)
3911      {
3912          detail::Wrapper<cl_type>::operator=(program);
3913          return *this;
3914      }
3915      Program(Program&& program) CL_HPP_NOEXCEPT_ : detail::Wrapper<cl_type>(std::move(program)) {}
3916      Program& operator = (Program &&program)
3917      {
3918          detail::Wrapper<cl_type>::operator=(std::move(program));
3919          return *this;
3920      }
3921      cl_int build(
3922          const vector<Device>& devices,
3923          const char* options = NULL,
3924          void (CL_CALLBACK * notifyFptr)(cl_program, void *) = NULL,
3925          void* data = NULL) const
3926      {
3927          size_type numDevices = devices.size();
3928          vector<cl_device_id> deviceIDs(numDevices);
3929          for( size_type deviceIndex = 0; deviceIndex < numDevices; ++deviceIndex ) {
3930              deviceIDs[deviceIndex] = (devices[deviceIndex])();
3931          }
3932          cl_int buildError = ::clBuildProgram(
3933              object_,
3934              (cl_uint)
3935              devices.size(),
3936              deviceIDs.data(),
3937              options,
3938              notifyFptr,
3939              data);
3940          return detail::buildErrHandler(buildError, __BUILD_PROGRAM_ERR, getBuildInfo<CL_PROGRAM_BUILD_LOG>());
3941      }
3942      cl_int build(
3943          const char* options = NULL,
3944          void (CL_CALLBACK * notifyFptr)(cl_program, void *) = NULL,
3945          void* data = NULL) const
3946      {
3947          cl_int buildError = ::clBuildProgram(
3948              object_,
3949              0,
3950              NULL,
3951              options,
3952              notifyFptr,
3953              data);
3954          return detail::buildErrHandler(buildError, __BUILD_PROGRAM_ERR, getBuildInfo<CL_PROGRAM_BUILD_LOG>());
3955      }
3956  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
3957      cl_int compile(
3958          const char* options = NULL,
3959          void (CL_CALLBACK * notifyFptr)(cl_program, void *) = NULL,
3960          void* data = NULL) const
3961      {
3962          cl_int error = ::clCompileProgram(
3963              object_,
3964              0,
3965              NULL,
3966              options,
3967              0,
3968              NULL,
3969              NULL,
3970              notifyFptr,
3971              data);
3972          return detail::buildErrHandler(error, __COMPILE_PROGRAM_ERR, getBuildInfo<CL_PROGRAM_BUILD_LOG>());
3973      }
3974  #endif 
3975      template <typename T>
3976      cl_int getInfo(cl_program_info name, T* param) const
3977      {
3978          return detail::errHandler(
3979              detail::getInfo(&::clGetProgramInfo, object_, name, param),
3980              __GET_PROGRAM_INFO_ERR);
3981      }
3982      template <cl_int name> typename
3983      detail::param_traits<detail::cl_program_info, name>::param_type
3984      getInfo(cl_int* err = NULL) const
3985      {
3986          typename detail::param_traits<
3987              detail::cl_program_info, name>::param_type param;
3988          cl_int result = getInfo(name, &param);
3989          if (err != NULL) {
3990              *err = result;
3991          }
3992          return param;
3993      }
3994      template <typename T>
3995      cl_int getBuildInfo(
3996          const Device& device, cl_program_build_info name, T* param) const
3997      {
3998          return detail::errHandler(
3999              detail::getInfo(
4000                  &::clGetProgramBuildInfo, object_, device(), name, param),
4001                  __GET_PROGRAM_BUILD_INFO_ERR);
4002      }
4003      template <cl_int name> typename
4004      detail::param_traits<detail::cl_program_build_info, name>::param_type
4005      getBuildInfo(const Device& device, cl_int* err = NULL) const
4006      {
4007          typename detail::param_traits<
4008              detail::cl_program_build_info, name>::param_type param;
4009          cl_int result = getBuildInfo(device, name, &param);
4010          if (err != NULL) {
4011              *err = result;
4012          }
4013          return param;
4014      }
4015      template <cl_int name>
4016      vector<std::pair<cl::Device, typename detail::param_traits<detail::cl_program_build_info, name>::param_type>>
4017          getBuildInfo(cl_int *err = NULL) const
4018      {
4019          cl_int result = CL_SUCCESS;
4020          auto devs = getInfo<CL_PROGRAM_DEVICES>(&result);
4021          vector<std::pair<cl::Device, typename detail::param_traits<detail::cl_program_build_info, name>::param_type>>
4022              devInfo;
4023          if (result != CL_SUCCESS) {
4024              if (err != NULL) {
4025                  *err = result;
4026              }
4027              return devInfo;
4028          }
4029          for (cl::Device d : devs) {
4030              typename detail::param_traits<
4031                  detail::cl_program_build_info, name>::param_type param;
4032              result = getBuildInfo(d, name, &param);
4033              devInfo.push_back(
4034                  std::pair<cl::Device, typename detail::param_traits<detail::cl_program_build_info, name>::param_type>
4035                  (d, param));
4036              if (result != CL_SUCCESS) {
4037                  break;
4038              }
4039          }
4040          if (err != NULL) {
4041              *err = result;
4042          }
4043          if (result != CL_SUCCESS) {
4044              devInfo.clear();
4045          }
4046          return devInfo;
4047      }
4048      cl_int createKernels(vector<Kernel>* kernels)
4049      {
4050          cl_uint numKernels;
4051          cl_int err = ::clCreateKernelsInProgram(object_, 0, NULL, &numKernels);
4052          if (err != CL_SUCCESS) {
4053              return detail::errHandler(err, __CREATE_KERNELS_IN_PROGRAM_ERR);
4054          }
4055          vector<cl_kernel> value(numKernels);
4056          err = ::clCreateKernelsInProgram(
4057              object_, numKernels, value.data(), NULL);
4058          if (err != CL_SUCCESS) {
4059              return detail::errHandler(err, __CREATE_KERNELS_IN_PROGRAM_ERR);
4060          }
4061          if (kernels) {
4062              kernels->resize(value.size());
4063              for (size_type i = 0; i < value.size(); i++) {
4064                  (*kernels)[i] = Kernel(value[i], false);
4065              }
4066          }
4067          return CL_SUCCESS;
4068      }
4069  };
4070  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
4071  inline Program linkProgram(
4072      Program input1,
4073      Program input2,
4074      const char* options = NULL,
4075      void (CL_CALLBACK * notifyFptr)(cl_program, void *) = NULL,
4076      void* data = NULL,
4077      cl_int* err = NULL) 
4078  {
4079      cl_int error_local = CL_SUCCESS;
4080      cl_program programs[2] = { input1(), input2() };
4081      Context ctx = input1.getInfo<CL_PROGRAM_CONTEXT>(&error_local);
4082      if(error_local!=CL_SUCCESS) {
4083          detail::errHandler(error_local, __LINK_PROGRAM_ERR);
4084      }
4085      cl_program prog = ::clLinkProgram(
4086          ctx(),
4087          0,
4088          NULL,
4089          options,
4090          2,
4091          programs,
4092          notifyFptr,
4093          data,
4094          &error_local);
4095      detail::errHandler(error_local,__COMPILE_PROGRAM_ERR);
4096      if (err != NULL) {
4097          *err = error_local;
4098      }
4099      return Program(prog);
4100  }
4101  inline Program linkProgram(
4102      vector<Program> inputPrograms,
4103      const char* options = NULL,
4104      void (CL_CALLBACK * notifyFptr)(cl_program, void *) = NULL,
4105      void* data = NULL,
4106      cl_int* err = NULL) 
4107  {
4108      cl_int error_local = CL_SUCCESS;
4109      vector<cl_program> programs(inputPrograms.size());
4110      for (unsigned int i = 0; i < inputPrograms.size(); i++) {
4111          programs[i] = inputPrograms[i]();
4112      }
4113      Context ctx;
4114      if(inputPrograms.size() > 0) {
4115          ctx = inputPrograms[0].getInfo<CL_PROGRAM_CONTEXT>(&error_local);
4116          if(error_local!=CL_SUCCESS) {
4117              detail::errHandler(error_local, __LINK_PROGRAM_ERR);
4118          }
4119      }
4120      cl_program prog = ::clLinkProgram(
4121          ctx(),
4122          0,
4123          NULL,
4124          options,
4125          (cl_uint)inputPrograms.size(),
4126          programs.data(),
4127          notifyFptr,
4128          data,
4129          &error_local);
4130      detail::errHandler(error_local,__COMPILE_PROGRAM_ERR);
4131      if (err != NULL) {
4132          *err = error_local;
4133      }
4134      return Program(prog, false);
4135  }
4136  #endif 
4137  template <>
4138  inline cl_int cl::Program::getInfo(cl_program_info name, vector<vector<unsigned char>>* param) const
4139  {
4140      if (name != CL_PROGRAM_BINARIES) {
4141          return CL_INVALID_VALUE;
4142      }
4143      if (param) {
4144          vector<size_type> sizes = getInfo<CL_PROGRAM_BINARY_SIZES>();
4145          size_type numBinaries = sizes.size();
4146          param->resize(numBinaries);
4147          for (int i = 0; i < numBinaries; ++i) {
4148              (*param)[i].resize(sizes[i]);
4149          }
4150          return detail::errHandler(
4151              detail::getInfo(&::clGetProgramInfo, object_, name, param),
4152              __GET_PROGRAM_INFO_ERR);
4153      }
4154      return CL_SUCCESS;
4155  }
4156  template<>
4157  inline vector<vector<unsigned char>> cl::Program::getInfo<CL_PROGRAM_BINARIES>(cl_int* err) const
4158  {
4159      vector<vector<unsigned char>> binariesVectors;
4160      cl_int result = getInfo(CL_PROGRAM_BINARIES, &binariesVectors);
4161      if (err != NULL) {
4162          *err = result;
4163      }
4164      return binariesVectors;
4165  }
4166  inline Kernel::Kernel(const Program& program, const char* name, cl_int* err)
4167  {
4168      cl_int error;
4169      object_ = ::clCreateKernel(program(), name, &error);
4170      detail::errHandler(error, __CREATE_KERNEL_ERR);
4171      if (err != NULL) {
4172          *err = error;
4173      }
4174  }
4175  enum class QueueProperties : cl_command_queue_properties
4176  {
4177      None = 0,
4178      Profiling = CL_QUEUE_PROFILING_ENABLE,
4179      OutOfOrder = CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE,
4180  };
4181  QueueProperties operator|(QueueProperties lhs, QueueProperties rhs)
4182  {
4183      return static_cast<QueueProperties>(static_cast<cl_command_queue_properties>(lhs) | static_cast<cl_command_queue_properties>(rhs));
4184  }
4185  class CommandQueue : public detail::Wrapper<cl_command_queue>
4186  {
4187  private:
4188      static std::once_flag default_initialized_;
4189      static CommandQueue default_;
4190      static cl_int default_error_;
4191      static void makeDefault()
4192      {
4193  #if defined(CL_HPP_ENABLE_EXCEPTIONS)
4194          try
4195  #endif
4196          {
4197              int error;
4198              Context context = Context::getDefault(&error);
4199              if (error != CL_SUCCESS) {
4200                  default_error_ = error;
4201              }
4202              else {
4203                  Device device = Device::getDefault();
4204                  default_ = CommandQueue(context, device, 0, &default_error_);
4205              }
4206          }
4207  #if defined(CL_HPP_ENABLE_EXCEPTIONS)
4208          catch (cl::Error &e) {
4209              default_error_ = e.err();
4210          }
4211  #endif
4212      }
4213      static void makeDefaultProvided(const CommandQueue &c) {
4214          default_ = c;
4215      }
4216  public:
4217  #ifdef CL_HPP_UNIT_TEST_ENABLE
4218      static void unitTestClearDefault() {
4219          default_ = CommandQueue();
4220      }
4221  #endif 
4222     CommandQueue(
4223          cl_command_queue_properties properties,
4224          cl_int* err = NULL)
4225      {
4226          cl_int error;
4227          Context context = Context::getDefault(&error);
4228          detail::errHandler(error, __CREATE_CONTEXT_ERR);
4229          if (error != CL_SUCCESS) {
4230              if (err != NULL) {
4231                  *err = error;
4232              }
4233          }
4234          else {
4235              Device device = context.getInfo<CL_CONTEXT_DEVICES>()[0];
4236  #if CL_HPP_TARGET_OPENCL_VERSION >= 200
4237              cl_queue_properties queue_properties[] = {
4238                  CL_QUEUE_PROPERTIES, properties, 0 };
4239              if ((properties & CL_QUEUE_ON_DEVICE) == 0) {
4240                  object_ = ::clCreateCommandQueueWithProperties(
4241                      context(), device(), queue_properties, &error);
4242              }
4243              else {
4244                  error = CL_INVALID_QUEUE_PROPERTIES;
4245              }
4246              detail::errHandler(error, __CREATE_COMMAND_QUEUE_WITH_PROPERTIES_ERR);
4247              if (err != NULL) {
4248                  *err = error;
4249              }
4250  #else
4251              object_ = ::clCreateCommandQueue(
4252                  context(), device(), properties, &error);
4253              detail::errHandler(error, __CREATE_COMMAND_QUEUE_ERR);
4254              if (err != NULL) {
4255                  *err = error;
4256              }
4257  #endif
4258          }
4259      }
4260     CommandQueue(
4261         QueueProperties properties,
4262         cl_int* err = NULL)
4263     {
4264         cl_int error;
4265         Context context = Context::getDefault(&error);
4266         detail::errHandler(error, __CREATE_CONTEXT_ERR);
4267         if (error != CL_SUCCESS) {
4268             if (err != NULL) {
4269                 *err = error;
4270             }
4271         }
4272         else {
4273             Device device = context.getInfo<CL_CONTEXT_DEVICES>()[0];
4274  #if CL_HPP_TARGET_OPENCL_VERSION >= 200
4275             cl_queue_properties queue_properties[] = {
4276                 CL_QUEUE_PROPERTIES, static_cast<cl_queue_properties>(properties), 0 };
4277             object_ = ::clCreateCommandQueueWithProperties(
4278                 context(), device(), queue_properties, &error);
4279             detail::errHandler(error, __CREATE_COMMAND_QUEUE_WITH_PROPERTIES_ERR);
4280             if (err != NULL) {
4281                 *err = error;
4282             }
4283  #else
4284             object_ = ::clCreateCommandQueue(
4285                 context(), device(), static_cast<cl_command_queue_properties>(properties), &error);
4286             detail::errHandler(error, __CREATE_COMMAND_QUEUE_ERR);
4287             if (err != NULL) {
4288                 *err = error;
4289             }
4290  #endif
4291         }
4292     }
4293      explicit CommandQueue(
4294          const Context& context,
4295          cl_command_queue_properties properties = 0,
4296          cl_int* err = NULL)
4297      {
4298          cl_int error;
4299          vector<cl::Device> devices;
4300          error = context.getInfo(CL_CONTEXT_DEVICES, &devices);
4301          detail::errHandler(error, __CREATE_CONTEXT_ERR);
4302          if (error != CL_SUCCESS)
4303          {
4304              if (err != NULL) {
4305                  *err = error;
4306              }
4307              return;
4308          }
4309  #if CL_HPP_TARGET_OPENCL_VERSION >= 200
4310          cl_queue_properties queue_properties[] = {
4311              CL_QUEUE_PROPERTIES, properties, 0 };
4312          if ((properties & CL_QUEUE_ON_DEVICE) == 0) {
4313              object_ = ::clCreateCommandQueueWithProperties(
4314                  context(), devices[0](), queue_properties, &error);
4315          }
4316          else {
4317              error = CL_INVALID_QUEUE_PROPERTIES;
4318          }
4319          detail::errHandler(error, __CREATE_COMMAND_QUEUE_WITH_PROPERTIES_ERR);
4320          if (err != NULL) {
4321              *err = error;
4322          }
4323  #else
4324          object_ = ::clCreateCommandQueue(
4325              context(), devices[0](), properties, &error);
4326          detail::errHandler(error, __CREATE_COMMAND_QUEUE_ERR);
4327          if (err != NULL) {
4328              *err = error;
4329          }
4330  #endif
4331      }
4332      explicit CommandQueue(
4333          const Context& context,
4334          QueueProperties properties,
4335          cl_int* err = NULL)
4336      {
4337          cl_int error;
4338          vector<cl::Device> devices;
4339          error = context.getInfo(CL_CONTEXT_DEVICES, &devices);
4340          detail::errHandler(error, __CREATE_CONTEXT_ERR);
4341          if (error != CL_SUCCESS)
4342          {
4343              if (err != NULL) {
4344                  *err = error;
4345              }
4346              return;
4347          }
4348  #if CL_HPP_TARGET_OPENCL_VERSION >= 200
4349          cl_queue_properties queue_properties[] = {
4350              CL_QUEUE_PROPERTIES, static_cast<cl_queue_properties>(properties), 0 };
4351          object_ = ::clCreateCommandQueueWithProperties(
4352              context(), devices[0](), queue_properties, &error);
4353          detail::errHandler(error, __CREATE_COMMAND_QUEUE_WITH_PROPERTIES_ERR);
4354          if (err != NULL) {
4355              *err = error;
4356          }
4357  #else
4358          object_ = ::clCreateCommandQueue(
4359              context(), devices[0](), static_cast<cl_command_queue_properties>(properties), &error);
4360          detail::errHandler(error, __CREATE_COMMAND_QUEUE_ERR);
4361          if (err != NULL) {
4362              *err = error;
4363          }
4364  #endif
4365      }
4366      CommandQueue(
4367          const Context& context,
4368          const Device& device,
4369          cl_command_queue_properties properties = 0,
4370          cl_int* err = NULL)
4371      {
4372          cl_int error;
4373  #if CL_HPP_TARGET_OPENCL_VERSION >= 200
4374          cl_queue_properties queue_properties[] = {
4375              CL_QUEUE_PROPERTIES, properties, 0 };
4376          object_ = ::clCreateCommandQueueWithProperties(
4377              context(), device(), queue_properties, &error);
4378          detail::errHandler(error, __CREATE_COMMAND_QUEUE_WITH_PROPERTIES_ERR);
4379          if (err != NULL) {
4380              *err = error;
4381          }
4382  #else
4383          object_ = ::clCreateCommandQueue(
4384              context(), device(), properties, &error);
4385          detail::errHandler(error, __CREATE_COMMAND_QUEUE_ERR);
4386          if (err != NULL) {
4387              *err = error;
4388          }
4389  #endif
4390      }
4391      CommandQueue(
4392          const Context& context,
4393          const Device& device,
<span onclick='openModal()' class='match'>4394          QueueProperties properties,
4395          cl_int* err = NULL)
4396      {
4397              cl_int error;
4398  #if CL_HPP_TARGET_OPENCL_VERSION >= 200
4399              cl_queue_properties queue_properties[] = {
4400                  CL_QUEUE_PROPERTIES, static_cast<cl_queue_properties>(properties), 0 };
</span>4401              object_ = ::clCreateCommandQueueWithProperties(
4402                  context(), device(), queue_properties, &error);
4403              detail::errHandler(error, __CREATE_COMMAND_QUEUE_WITH_PROPERTIES_ERR);
4404              if (err != NULL) {
4405                  *err = error;
4406              }
4407  #else
4408              object_ = ::clCreateCommandQueue(
4409                  context(), device(), static_cast<cl_command_queue_properties>(properties), &error);
4410              detail::errHandler(error, __CREATE_COMMAND_QUEUE_ERR);
4411              if (err != NULL) {
4412                  *err = error;
4413              }
4414  #endif
4415          }
4416      static CommandQueue getDefault(cl_int * err = NULL) 
4417      {
4418          std::call_once(default_initialized_, makeDefault);
4419  #if CL_HPP_TARGET_OPENCL_VERSION >= 200
4420          detail::errHandler(default_error_, __CREATE_COMMAND_QUEUE_WITH_PROPERTIES_ERR);
4421  #else 
4422          detail::errHandler(default_error_, __CREATE_COMMAND_QUEUE_ERR);
4423  #endif 
4424          if (err != NULL) {
4425              *err = default_error_;
4426          }
4427          return default_;
4428      }
4429      static CommandQueue setDefault(const CommandQueue &default_queue)
4430      {
4431          std::call_once(default_initialized_, makeDefaultProvided, std::cref(default_queue));
4432          detail::errHandler(default_error_);
4433          return default_;
4434      }
4435      CommandQueue() { }
4436      explicit CommandQueue(const cl_command_queue& commandQueue, bool retainObject = false) : 
4437          detail::Wrapper<cl_type>(commandQueue, retainObject) { }
4438      CommandQueue& operator = (const cl_command_queue& rhs)
4439      {
4440          detail::Wrapper<cl_type>::operator=(rhs);
4441          return *this;
4442      }
4443      CommandQueue(const CommandQueue& queue) : detail::Wrapper<cl_type>(queue) {}
4444      CommandQueue& operator = (const CommandQueue &queue)
4445      {
4446          detail::Wrapper<cl_type>::operator=(queue);
4447          return *this;
4448      }
4449      CommandQueue(CommandQueue&& queue) CL_HPP_NOEXCEPT_ : detail::Wrapper<cl_type>(std::move(queue)) {}
4450      CommandQueue& operator = (CommandQueue &&queue)
4451      {
4452          detail::Wrapper<cl_type>::operator=(std::move(queue));
4453          return *this;
4454      }
4455      template <typename T>
4456      cl_int getInfo(cl_command_queue_info name, T* param) const
4457      {
4458          return detail::errHandler(
4459              detail::getInfo(
4460                  &::clGetCommandQueueInfo, object_, name, param),
4461                  __GET_COMMAND_QUEUE_INFO_ERR);
4462      }
4463      template <cl_int name> typename
4464      detail::param_traits<detail::cl_command_queue_info, name>::param_type
4465      getInfo(cl_int* err = NULL) const
4466      {
4467          typename detail::param_traits<
4468              detail::cl_command_queue_info, name>::param_type param;
4469          cl_int result = getInfo(name, &param);
4470          if (err != NULL) {
4471              *err = result;
4472          }
4473          return param;
4474      }
4475      cl_int enqueueReadBuffer(
4476          const Buffer& buffer,
4477          cl_bool blocking,
4478          size_type offset,
4479          size_type size,
4480          void* ptr,
4481          const vector<Event>* events = NULL,
4482          Event* event = NULL) const
4483      {
4484          cl_event tmp;
4485          cl_int err = detail::errHandler(
4486              ::clEnqueueReadBuffer(
4487                  object_, buffer(), blocking, offset, size,
4488                  ptr,
4489                  (events != NULL) ? (cl_uint) events->size() : 0,
4490                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4491                  (event != NULL) ? &tmp : NULL),
4492              __ENQUEUE_READ_BUFFER_ERR);
4493          if (event != NULL && err == CL_SUCCESS)
4494              *event = tmp;
4495          return err;
4496      }
4497      cl_int enqueueWriteBuffer(
4498          const Buffer& buffer,
4499          cl_bool blocking,
4500          size_type offset,
4501          size_type size,
4502          const void* ptr,
4503          const vector<Event>* events = NULL,
4504          Event* event = NULL) const
4505      {
4506          cl_event tmp;
4507          cl_int err = detail::errHandler(
4508              ::clEnqueueWriteBuffer(
4509                  object_, buffer(), blocking, offset, size,
4510                  ptr,
4511                  (events != NULL) ? (cl_uint) events->size() : 0,
4512                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4513                  (event != NULL) ? &tmp : NULL),
4514                  __ENQUEUE_WRITE_BUFFER_ERR);
4515          if (event != NULL && err == CL_SUCCESS)
4516              *event = tmp;
4517          return err;
4518      }
4519      cl_int enqueueCopyBuffer(
4520          const Buffer& src,
4521          const Buffer& dst,
4522          size_type src_offset,
4523          size_type dst_offset,
4524          size_type size,
4525          const vector<Event>* events = NULL,
4526          Event* event = NULL) const
4527      {
4528          cl_event tmp;
4529          cl_int err = detail::errHandler(
4530              ::clEnqueueCopyBuffer(
4531                  object_, src(), dst(), src_offset, dst_offset, size,
4532                  (events != NULL) ? (cl_uint) events->size() : 0,
4533                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4534                  (event != NULL) ? &tmp : NULL),
4535              __ENQEUE_COPY_BUFFER_ERR);
4536          if (event != NULL && err == CL_SUCCESS)
4537              *event = tmp;
4538          return err;
4539      }
4540      cl_int enqueueReadBufferRect(
4541          const Buffer& buffer,
4542          cl_bool blocking,
4543          const array<size_type, 3>& buffer_offset,
4544          const array<size_type, 3>& host_offset,
4545          const array<size_type, 3>& region,
4546          size_type buffer_row_pitch,
4547          size_type buffer_slice_pitch,
4548          size_type host_row_pitch,
4549          size_type host_slice_pitch,
4550          void *ptr,
4551          const vector<Event>* events = NULL,
4552          Event* event = NULL) const
4553      {
4554          cl_event tmp;
4555          cl_int err = detail::errHandler(
4556              ::clEnqueueReadBufferRect(
4557                  object_, 
4558                  buffer(), 
4559                  blocking,
4560                  buffer_offset.data(),
4561                  host_offset.data(),
4562                  region.data(),
4563                  buffer_row_pitch,
4564                  buffer_slice_pitch,
4565                  host_row_pitch,
4566                  host_slice_pitch,
4567                  ptr,
4568                  (events != NULL) ? (cl_uint) events->size() : 0,
4569                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4570                  (event != NULL) ? &tmp : NULL),
4571                  __ENQUEUE_READ_BUFFER_RECT_ERR);
4572          if (event != NULL && err == CL_SUCCESS)
4573              *event = tmp;
4574          return err;
4575      }
4576      cl_int enqueueWriteBufferRect(
4577          const Buffer& buffer,
4578          cl_bool blocking,
4579          const array<size_type, 3>& buffer_offset,
4580          const array<size_type, 3>& host_offset,
4581          const array<size_type, 3>& region,
4582          size_type buffer_row_pitch,
4583          size_type buffer_slice_pitch,
4584          size_type host_row_pitch,
4585          size_type host_slice_pitch,
4586          void *ptr,
4587          const vector<Event>* events = NULL,
4588          Event* event = NULL) const
4589      {
4590          cl_event tmp;
4591          cl_int err = detail::errHandler(
4592              ::clEnqueueWriteBufferRect(
4593                  object_, 
4594                  buffer(), 
4595                  blocking,
4596                  buffer_offset.data(),
4597                  host_offset.data(),
4598                  region.data(),
4599                  buffer_row_pitch,
4600                  buffer_slice_pitch,
4601                  host_row_pitch,
4602                  host_slice_pitch,
4603                  ptr,
4604                  (events != NULL) ? (cl_uint) events->size() : 0,
4605                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4606                  (event != NULL) ? &tmp : NULL),
4607                  __ENQUEUE_WRITE_BUFFER_RECT_ERR);
4608          if (event != NULL && err == CL_SUCCESS)
4609              *event = tmp;
4610          return err;
4611      }
4612      cl_int enqueueCopyBufferRect(
4613          const Buffer& src,
4614          const Buffer& dst,
4615          const array<size_type, 3>& src_origin,
4616          const array<size_type, 3>& dst_origin,
4617          const array<size_type, 3>& region,
4618          size_type src_row_pitch,
4619          size_type src_slice_pitch,
4620          size_type dst_row_pitch,
4621          size_type dst_slice_pitch,
4622          const vector<Event>* events = NULL,
4623          Event* event = NULL) const
4624      {
4625          cl_event tmp;
4626          cl_int err = detail::errHandler(
4627              ::clEnqueueCopyBufferRect(
4628                  object_, 
4629                  src(), 
4630                  dst(), 
4631                  src_origin.data(),
4632                  dst_origin.data(),
4633                  region.data(),
4634                  src_row_pitch,
4635                  src_slice_pitch,
4636                  dst_row_pitch,
4637                  dst_slice_pitch,
4638                  (events != NULL) ? (cl_uint) events->size() : 0,
4639                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4640                  (event != NULL) ? &tmp : NULL),
4641              __ENQEUE_COPY_BUFFER_RECT_ERR);
4642          if (event != NULL && err == CL_SUCCESS)
4643              *event = tmp;
4644          return err;
4645      }
4646  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
4647      template<typename PatternType>
4648      cl_int enqueueFillBuffer(
4649          const Buffer& buffer,
4650          PatternType pattern,
4651          size_type offset,
4652          size_type size,
4653          const vector<Event>* events = NULL,
4654          Event* event = NULL) const
4655      {
4656          cl_event tmp;
4657          cl_int err = detail::errHandler(
4658              ::clEnqueueFillBuffer(
4659                  object_, 
4660                  buffer(),
4661                  static_cast<void*>(&pattern),
4662                  sizeof(PatternType), 
4663                  offset, 
4664                  size,
4665                  (events != NULL) ? (cl_uint) events->size() : 0,
4666                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4667                  (event != NULL) ? &tmp : NULL),
4668                  __ENQUEUE_FILL_BUFFER_ERR);
4669          if (event != NULL && err == CL_SUCCESS)
4670              *event = tmp;
4671          return err;
4672      }
4673  #endif 
4674      cl_int enqueueReadImage(
4675          const Image& image,
4676          cl_bool blocking,
4677          const array<size_type, 3>& origin,
4678          const array<size_type, 3>& region,
4679          size_type row_pitch,
4680          size_type slice_pitch,
4681          void* ptr,
4682          const vector<Event>* events = NULL,
4683          Event* event = NULL) const
4684      {
4685          cl_event tmp;
4686          cl_int err = detail::errHandler(
4687              ::clEnqueueReadImage(
4688                  object_, 
4689                  image(), 
4690                  blocking, 
4691                  origin.data(),
4692                  region.data(), 
4693                  row_pitch, 
4694                  slice_pitch, 
4695                  ptr,
4696                  (events != NULL) ? (cl_uint) events->size() : 0,
4697                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4698                  (event != NULL) ? &tmp : NULL),
4699              __ENQUEUE_READ_IMAGE_ERR);
4700          if (event != NULL && err == CL_SUCCESS)
4701              *event = tmp;
4702          return err;
4703      }
4704      cl_int enqueueWriteImage(
4705          const Image& image,
4706          cl_bool blocking,
4707          const array<size_type, 3>& origin,
4708          const array<size_type, 3>& region,
4709          size_type row_pitch,
4710          size_type slice_pitch,
4711          void* ptr,
4712          const vector<Event>* events = NULL,
4713          Event* event = NULL) const
4714      {
4715          cl_event tmp;
4716          cl_int err = detail::errHandler(
4717              ::clEnqueueWriteImage(
4718                  object_, 
4719                  image(), 
4720                  blocking, 
4721                  origin.data(),
4722                  region.data(), 
4723                  row_pitch, 
4724                  slice_pitch, 
4725                  ptr,
4726                  (events != NULL) ? (cl_uint) events->size() : 0,
4727                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4728                  (event != NULL) ? &tmp : NULL),
4729              __ENQUEUE_WRITE_IMAGE_ERR);
4730          if (event != NULL && err == CL_SUCCESS)
4731              *event = tmp;
4732          return err;
4733      }
4734      cl_int enqueueCopyImage(
4735          const Image& src,
4736          const Image& dst,
4737          const array<size_type, 3>& src_origin,
4738          const array<size_type, 3>& dst_origin,
4739          const array<size_type, 3>& region,
4740          const vector<Event>* events = NULL,
4741          Event* event = NULL) const
4742      {
4743          cl_event tmp;
4744          cl_int err = detail::errHandler(
4745              ::clEnqueueCopyImage(
4746                  object_, 
4747                  src(), 
4748                  dst(), 
4749                  src_origin.data(),
4750                  dst_origin.data(), 
4751                  region.data(),
4752                  (events != NULL) ? (cl_uint) events->size() : 0,
4753                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4754                  (event != NULL) ? &tmp : NULL),
4755              __ENQUEUE_COPY_IMAGE_ERR);
4756          if (event != NULL && err == CL_SUCCESS)
4757              *event = tmp;
4758          return err;
4759      }
4760  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
4761      cl_int enqueueFillImage(
4762          const Image& image,
4763          cl_float4 fillColor,
4764          const array<size_type, 3>& origin,
4765          const array<size_type, 3>& region,
4766          const vector<Event>* events = NULL,
4767          Event* event = NULL) const
4768      {
4769          cl_event tmp;
4770          cl_int err = detail::errHandler(
4771              ::clEnqueueFillImage(
4772                  object_, 
4773                  image(),
4774                  static_cast<void*>(&fillColor), 
4775                  origin.data(),
4776                  region.data(),
4777                  (events != NULL) ? (cl_uint) events->size() : 0,
4778                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4779                  (event != NULL) ? &tmp : NULL),
4780                  __ENQUEUE_FILL_IMAGE_ERR);
4781          if (event != NULL && err == CL_SUCCESS)
4782              *event = tmp;
4783          return err;
4784      }
4785      cl_int enqueueFillImage(
4786          const Image& image,
4787          cl_int4 fillColor,
4788          const array<size_type, 3>& origin,
4789          const array<size_type, 3>& region,
4790          const vector<Event>* events = NULL,
4791          Event* event = NULL) const
4792      {
4793          cl_event tmp;
4794          cl_int err = detail::errHandler(
4795              ::clEnqueueFillImage(
4796                  object_, 
4797                  image(),
4798                  static_cast<void*>(&fillColor), 
4799                  origin.data(),
4800                  region.data(),
4801                  (events != NULL) ? (cl_uint) events->size() : 0,
4802                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4803                  (event != NULL) ? &tmp : NULL),
4804                  __ENQUEUE_FILL_IMAGE_ERR);
4805          if (event != NULL && err == CL_SUCCESS)
4806              *event = tmp;
4807          return err;
4808      }
4809      cl_int enqueueFillImage(
4810          const Image& image,
4811          cl_uint4 fillColor,
4812          const array<size_type, 3>& origin,
4813          const array<size_type, 3>& region,
4814          const vector<Event>* events = NULL,
4815          Event* event = NULL) const
4816      {
4817          cl_event tmp;
4818          cl_int err = detail::errHandler(
4819              ::clEnqueueFillImage(
4820                  object_, 
4821                  image(),
4822                  static_cast<void*>(&fillColor), 
4823                  origin.data(),
4824                  region.data(),
4825                  (events != NULL) ? (cl_uint) events->size() : 0,
4826                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4827                  (event != NULL) ? &tmp : NULL),
4828                  __ENQUEUE_FILL_IMAGE_ERR);
4829          if (event != NULL && err == CL_SUCCESS)
4830              *event = tmp;
4831          return err;
4832      }
4833  #endif 
4834      cl_int enqueueCopyImageToBuffer(
4835          const Image& src,
4836          const Buffer& dst,
4837          const array<size_type, 3>& src_origin,
4838          const array<size_type, 3>& region,
4839          size_type dst_offset,
4840          const vector<Event>* events = NULL,
4841          Event* event = NULL) const
4842      {
4843          cl_event tmp;
4844          cl_int err = detail::errHandler(
4845              ::clEnqueueCopyImageToBuffer(
4846                  object_, 
4847                  src(), 
4848                  dst(), 
4849                  src_origin.data(),
4850                  region.data(), 
4851                  dst_offset,
4852                  (events != NULL) ? (cl_uint) events->size() : 0,
4853                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4854                  (event != NULL) ? &tmp : NULL),
4855              __ENQUEUE_COPY_IMAGE_TO_BUFFER_ERR);
4856          if (event != NULL && err == CL_SUCCESS)
4857              *event = tmp;
4858          return err;
4859      }
4860      cl_int enqueueCopyBufferToImage(
4861          const Buffer& src,
4862          const Image& dst,
4863          size_type src_offset,
4864          const array<size_type, 3>& dst_origin,
4865          const array<size_type, 3>& region,
4866          const vector<Event>* events = NULL,
4867          Event* event = NULL) const
4868      {
4869          cl_event tmp;
4870          cl_int err = detail::errHandler(
4871              ::clEnqueueCopyBufferToImage(
4872                  object_, 
4873                  src(), 
4874                  dst(), 
4875                  src_offset,
4876                  dst_origin.data(), 
4877                  region.data(),
4878                  (events != NULL) ? (cl_uint) events->size() : 0,
4879                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4880                  (event != NULL) ? &tmp : NULL),
4881              __ENQUEUE_COPY_BUFFER_TO_IMAGE_ERR);
4882          if (event != NULL && err == CL_SUCCESS)
4883              *event = tmp;
4884          return err;
4885      }
4886      void* enqueueMapBuffer(
4887          const Buffer& buffer,
4888          cl_bool blocking,
4889          cl_map_flags flags,
4890          size_type offset,
4891          size_type size,
4892          const vector<Event>* events = NULL,
4893          Event* event = NULL,
4894          cl_int* err = NULL) const
4895      {
4896          cl_event tmp;
4897          cl_int error;
4898          void * result = ::clEnqueueMapBuffer(
4899              object_, buffer(), blocking, flags, offset, size,
4900              (events != NULL) ? (cl_uint) events->size() : 0,
4901              (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4902              (event != NULL) ? &tmp : NULL,
4903              &error);
4904          detail::errHandler(error, __ENQUEUE_MAP_BUFFER_ERR);
4905          if (err != NULL) {
4906              *err = error;
4907          }
4908          if (event != NULL && error == CL_SUCCESS)
4909              *event = tmp;
4910          return result;
4911      }
4912      void* enqueueMapImage(
4913          const Image& buffer,
4914          cl_bool blocking,
4915          cl_map_flags flags,
4916          const array<size_type, 3>& origin,
4917          const array<size_type, 3>& region,
4918          size_type * row_pitch,
4919          size_type * slice_pitch,
4920          const vector<Event>* events = NULL,
4921          Event* event = NULL,
4922          cl_int* err = NULL) const
4923      {
4924          cl_event tmp;
4925          cl_int error;
4926          void * result = ::clEnqueueMapImage(
4927              object_, buffer(), blocking, flags,
4928              origin.data(), 
4929              region.data(),
4930              row_pitch, slice_pitch,
4931              (events != NULL) ? (cl_uint) events->size() : 0,
4932              (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
4933              (event != NULL) ? &tmp : NULL,
4934              &error);
4935          detail::errHandler(error, __ENQUEUE_MAP_IMAGE_ERR);
4936          if (err != NULL) {
4937                *err = error;
4938          }
4939          if (event != NULL && error == CL_SUCCESS)
4940              *event = tmp;
4941          return result;
4942      }
4943  #if CL_HPP_TARGET_OPENCL_VERSION >= 200
4944      template<typename T>
4945      cl_int enqueueMapSVM(
4946          T* ptr,
4947          cl_bool blocking,
4948          cl_map_flags flags,
4949          size_type size,
4950          const vector<Event>* events = NULL,
4951          Event* event = NULL) const
4952      {
4953          cl_event tmp;
4954          cl_int err = detail::errHandler(::clEnqueueSVMMap(
4955              object_, blocking, flags, static_cast<void*>(ptr), size,
4956              (events != NULL) ? (cl_uint)events->size() : 0,
4957              (events != NULL && events->size() > 0) ? (cl_event*)&events->front() : NULL,
4958              (event != NULL) ? &tmp : NULL),
4959              __ENQUEUE_MAP_BUFFER_ERR);
4960          if (event != NULL && err == CL_SUCCESS)
4961              *event = tmp;
4962          return err;
4963      }
4964      template<typename T, class D>
4965      cl_int enqueueMapSVM(
4966          cl::pointer<T, D> &ptr,
4967          cl_bool blocking,
4968          cl_map_flags flags,
4969          size_type size,
4970          const vector<Event>* events = NULL,
4971          Event* event = NULL) const
4972      {
4973          cl_event tmp;
4974          cl_int err = detail::errHandler(::clEnqueueSVMMap(
4975              object_, blocking, flags, static_cast<void*>(ptr.get()), size,
4976              (events != NULL) ? (cl_uint)events->size() : 0,
4977              (events != NULL && events->size() > 0) ? (cl_event*)&events->front() : NULL,
4978              (event != NULL) ? &tmp : NULL),
4979              __ENQUEUE_MAP_BUFFER_ERR);
4980          if (event != NULL && err == CL_SUCCESS)
4981              *event = tmp;
4982          return err;
4983      }
4984      template<typename T, class Alloc>
4985      cl_int enqueueMapSVM(
4986          cl::vector<T, Alloc> &container,
4987          cl_bool blocking,
4988          cl_map_flags flags,
4989          const vector<Event>* events = NULL,
4990          Event* event = NULL) const
4991      {
4992          cl_event tmp;
4993          cl_int err = detail::errHandler(::clEnqueueSVMMap(
4994              object_, blocking, flags, static_cast<void*>(container.data()), container.size(),
4995              (events != NULL) ? (cl_uint)events->size() : 0,
4996              (events != NULL && events->size() > 0) ? (cl_event*)&events->front() : NULL,
4997              (event != NULL) ? &tmp : NULL),
4998              __ENQUEUE_MAP_BUFFER_ERR);
4999          if (event != NULL && err == CL_SUCCESS)
5000              *event = tmp;
5001          return err;
5002      }
5003  #endif 
5004      cl_int enqueueUnmapMemObject(
5005          const Memory& memory,
5006          void* mapped_ptr,
5007          const vector<Event>* events = NULL,
5008          Event* event = NULL) const
5009      {
5010          cl_event tmp;
5011          cl_int err = detail::errHandler(
5012              ::clEnqueueUnmapMemObject(
5013                  object_, memory(), mapped_ptr,
5014                  (events != NULL) ? (cl_uint) events->size() : 0,
5015                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
5016                  (event != NULL) ? &tmp : NULL),
5017              __ENQUEUE_UNMAP_MEM_OBJECT_ERR);
5018          if (event != NULL && err == CL_SUCCESS)
5019              *event = tmp;
5020          return err;
5021      }
5022  #if CL_HPP_TARGET_OPENCL_VERSION >= 200
5023      template<typename T>
5024      cl_int enqueueUnmapSVM(
5025          T* ptr,
5026          const vector<Event>* events = NULL,
5027          Event* event = NULL) const
5028      {
5029          cl_event tmp;
5030          cl_int err = detail::errHandler(
5031              ::clEnqueueSVMUnmap(
5032              object_, static_cast<void*>(ptr),
5033              (events != NULL) ? (cl_uint)events->size() : 0,
5034              (events != NULL && events->size() > 0) ? (cl_event*)&events->front() : NULL,
5035              (event != NULL) ? &tmp : NULL),
5036              __ENQUEUE_UNMAP_MEM_OBJECT_ERR);
5037          if (event != NULL && err == CL_SUCCESS)
5038              *event = tmp;
5039          return err;
5040      }
5041      template<typename T, class D>
5042      cl_int enqueueUnmapSVM(
5043          cl::pointer<T, D> &ptr,
5044          const vector<Event>* events = NULL,
5045          Event* event = NULL) const
5046      {
5047          cl_event tmp;
5048          cl_int err = detail::errHandler(
5049              ::clEnqueueSVMUnmap(
5050              object_, static_cast<void*>(ptr.get()),
5051              (events != NULL) ? (cl_uint)events->size() : 0,
5052              (events != NULL && events->size() > 0) ? (cl_event*)&events->front() : NULL,
5053              (event != NULL) ? &tmp : NULL),
5054              __ENQUEUE_UNMAP_MEM_OBJECT_ERR);
5055          if (event != NULL && err == CL_SUCCESS)
5056              *event = tmp;
5057          return err;
5058      }
5059      template<typename T, class Alloc>
5060      cl_int enqueueUnmapSVM(
5061          cl::vector<T, Alloc> &container,
5062          const vector<Event>* events = NULL,
5063          Event* event = NULL) const
5064      {
5065          cl_event tmp;
5066          cl_int err = detail::errHandler(
5067              ::clEnqueueSVMUnmap(
5068              object_, static_cast<void*>(container.data()),
5069              (events != NULL) ? (cl_uint)events->size() : 0,
5070              (events != NULL && events->size() > 0) ? (cl_event*)&events->front() : NULL,
5071              (event != NULL) ? &tmp : NULL),
5072              __ENQUEUE_UNMAP_MEM_OBJECT_ERR);
5073          if (event != NULL && err == CL_SUCCESS)
5074              *event = tmp;
5075          return err;
5076      }
5077  #endif 
5078  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
5079      cl_int enqueueMarkerWithWaitList(
5080          const vector<Event> *events = 0,
5081          Event *event = 0)
5082      {
5083          cl_event tmp;
5084          cl_int err = detail::errHandler(
5085              ::clEnqueueMarkerWithWaitList(
5086                  object_,
5087                  (events != NULL) ? (cl_uint) events->size() : 0,
5088                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
5089                  (event != NULL) ? &tmp : NULL),
5090              __ENQUEUE_MARKER_WAIT_LIST_ERR);
5091          if (event != NULL && err == CL_SUCCESS)
5092              *event = tmp;
5093          return err;
5094      }
5095      cl_int enqueueBarrierWithWaitList(
5096          const vector<Event> *events = 0,
5097          Event *event = 0)
5098      {
5099          cl_event tmp;
5100          cl_int err = detail::errHandler(
5101              ::clEnqueueBarrierWithWaitList(
5102                  object_,
5103                  (events != NULL) ? (cl_uint) events->size() : 0,
5104                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
5105                  (event != NULL) ? &tmp : NULL),
5106              __ENQUEUE_BARRIER_WAIT_LIST_ERR);
5107          if (event != NULL && err == CL_SUCCESS)
5108              *event = tmp;
5109          return err;
5110      }
5111      cl_int enqueueMigrateMemObjects(
5112          const vector<Memory> &memObjects,
5113          cl_mem_migration_flags flags,
5114          const vector<Event>* events = NULL,
5115          Event* event = NULL
5116          )
5117      {
5118          cl_event tmp;
5119          vector<cl_mem> localMemObjects(memObjects.size());
5120          for( int i = 0; i < (int)memObjects.size(); ++i ) {
5121              localMemObjects[i] = memObjects[i]();
5122          }
5123          cl_int err = detail::errHandler(
5124              ::clEnqueueMigrateMemObjects(
5125                  object_, 
5126                  (cl_uint)memObjects.size(), 
5127                  localMemObjects.data(),
5128                  flags,
5129                  (events != NULL) ? (cl_uint) events->size() : 0,
5130                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
5131                  (event != NULL) ? &tmp : NULL),
5132              __ENQUEUE_UNMAP_MEM_OBJECT_ERR);
5133          if (event != NULL && err == CL_SUCCESS)
5134              *event = tmp;
5135          return err;
5136      }
5137  #endif 
5138      cl_int enqueueNDRangeKernel(
5139          const Kernel& kernel,
5140          const NDRange& offset,
5141          const NDRange& global,
5142          const NDRange& local = NullRange,
5143          const vector<Event>* events = NULL,
5144          Event* event = NULL) const
5145      {
5146          cl_event tmp;
5147          cl_int err = detail::errHandler(
5148              ::clEnqueueNDRangeKernel(
5149                  object_, kernel(), (cl_uint) global.dimensions(),
5150                  offset.dimensions() != 0 ? (const size_type*) offset : NULL,
5151                  (const size_type*) global,
5152                  local.dimensions() != 0 ? (const size_type*) local : NULL,
5153                  (events != NULL) ? (cl_uint) events->size() : 0,
5154                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
5155                  (event != NULL) ? &tmp : NULL),
5156              __ENQUEUE_NDRANGE_KERNEL_ERR);
5157          if (event != NULL && err == CL_SUCCESS)
5158              *event = tmp;
5159          return err;
5160      }
5161  #if defined(CL_USE_DEPRECATED_OPENCL_1_2_APIS)
5162      CL_EXT_PREFIX__VERSION_1_2_DEPRECATED cl_int enqueueTask(
5163          const Kernel& kernel,
5164          const vector<Event>* events = NULL,
5165          Event* event = NULL) CL_EXT_SUFFIX__VERSION_1_2_DEPRECATED const
5166      {
5167          cl_event tmp;
5168          cl_int err = detail::errHandler(
5169              ::clEnqueueTask(
5170                  object_, kernel(),
5171                  (events != NULL) ? (cl_uint) events->size() : 0,
5172                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
5173                  (event != NULL) ? &tmp : NULL),
5174              __ENQUEUE_TASK_ERR);
5175          if (event != NULL && err == CL_SUCCESS)
5176              *event = tmp;
5177          return err;
5178      }
5179  #endif 
5180      cl_int enqueueNativeKernel(
5181          void (CL_CALLBACK *userFptr)(void *),
5182          std::pair<void*, size_type> args,
5183          const vector<Memory>* mem_objects = NULL,
5184          const vector<const void*>* mem_locs = NULL,
5185          const vector<Event>* events = NULL,
5186          Event* event = NULL) const
5187      {
5188          size_type elements = 0;
5189          if (mem_objects != NULL) {
5190              elements = mem_objects->size();
5191          }
5192          vector<cl_mem> mems(elements);
5193          for (unsigned int i = 0; i < elements; i++) {
5194              mems[i] = ((*mem_objects)[i])();
5195          }
5196          cl_event tmp;
5197          cl_int err = detail::errHandler(
5198              ::clEnqueueNativeKernel(
5199                  object_, userFptr, args.first, args.second,
5200                  (mem_objects != NULL) ? (cl_uint) mem_objects->size() : 0,
5201                  mems.data(),
5202                  (mem_locs != NULL && mem_locs->size() > 0) ? (const void **) &mem_locs->front() : NULL,
5203                  (events != NULL) ? (cl_uint) events->size() : 0,
5204                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
5205                  (event != NULL) ? &tmp : NULL),
5206              __ENQUEUE_NATIVE_KERNEL);
5207          if (event != NULL && err == CL_SUCCESS)
5208              *event = tmp;
5209          return err;
5210      }
5211  #if defined(CL_USE_DEPRECATED_OPENCL_1_1_APIS)
5212      CL_EXT_PREFIX__VERSION_1_1_DEPRECATED 
5213      cl_int enqueueMarker(Event* event = NULL) const CL_EXT_SUFFIX__VERSION_1_1_DEPRECATED
5214      {
5215          cl_event tmp;
5216          cl_int err = detail::errHandler(
5217              ::clEnqueueMarker(
5218                  object_, 
5219                  (event != NULL) ? &tmp : NULL),
5220              __ENQUEUE_MARKER_ERR);
5221          if (event != NULL && err == CL_SUCCESS)
5222              *event = tmp;
5223          return err;
5224      }
5225      CL_EXT_PREFIX__VERSION_1_1_DEPRECATED
5226      cl_int enqueueWaitForEvents(const vector<Event>& events) const CL_EXT_SUFFIX__VERSION_1_1_DEPRECATED
5227      {
5228          return detail::errHandler(
5229              ::clEnqueueWaitForEvents(
5230                  object_,
5231                  (cl_uint) events.size(),
5232                  events.size() > 0 ? (const cl_event*) &events.front() : NULL),
5233              __ENQUEUE_WAIT_FOR_EVENTS_ERR);
5234      }
5235  #endif 
5236      cl_int enqueueAcquireGLObjects(
5237           const vector<Memory>* mem_objects = NULL,
5238           const vector<Event>* events = NULL,
5239           Event* event = NULL) const
5240       {
5241          cl_event tmp;
5242          cl_int err = detail::errHandler(
5243               ::clEnqueueAcquireGLObjects(
5244                   object_,
5245                   (mem_objects != NULL) ? (cl_uint) mem_objects->size() : 0,
5246                   (mem_objects != NULL && mem_objects->size() > 0) ? (const cl_mem *) &mem_objects->front(): NULL,
5247                   (events != NULL) ? (cl_uint) events->size() : 0,
5248                   (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
5249                   (event != NULL) ? &tmp : NULL),
5250               __ENQUEUE_ACQUIRE_GL_ERR);
5251          if (event != NULL && err == CL_SUCCESS)
5252              *event = tmp;
5253          return err;
5254       }
5255      cl_int enqueueReleaseGLObjects(
5256           const vector<Memory>* mem_objects = NULL,
5257           const vector<Event>* events = NULL,
5258           Event* event = NULL) const
5259       {
5260          cl_event tmp;
5261          cl_int err = detail::errHandler(
5262               ::clEnqueueReleaseGLObjects(
5263                   object_,
5264                   (mem_objects != NULL) ? (cl_uint) mem_objects->size() : 0,
5265                   (mem_objects != NULL && mem_objects->size() > 0) ? (const cl_mem *) &mem_objects->front(): NULL,
5266                   (events != NULL) ? (cl_uint) events->size() : 0,
5267                   (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
5268                   (event != NULL) ? &tmp : NULL),
5269               __ENQUEUE_RELEASE_GL_ERR);
5270          if (event != NULL && err == CL_SUCCESS)
5271              *event = tmp;
5272          return err;
5273       }
5274  #if defined (CL_HPP_USE_DX_INTEROP)
5275  typedef CL_API_ENTRY cl_int (CL_API_CALL *PFN_clEnqueueAcquireD3D10ObjectsKHR)(
5276      cl_command_queue command_queue, cl_uint num_objects,
5277      const cl_mem* mem_objects, cl_uint num_events_in_wait_list,
5278      const cl_event* event_wait_list, cl_event* event);
5279  typedef CL_API_ENTRY cl_int (CL_API_CALL *PFN_clEnqueueReleaseD3D10ObjectsKHR)(
5280      cl_command_queue command_queue, cl_uint num_objects,
5281      const cl_mem* mem_objects,  cl_uint num_events_in_wait_list,
5282      const cl_event* event_wait_list, cl_event* event);
5283      cl_int enqueueAcquireD3D10Objects(
5284           const vector<Memory>* mem_objects = NULL,
5285           const vector<Event>* events = NULL,
5286           Event* event = NULL) const
5287      {
5288          static PFN_clEnqueueAcquireD3D10ObjectsKHR pfn_clEnqueueAcquireD3D10ObjectsKHR = NULL;
5289  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
5290          cl_context context = getInfo<CL_QUEUE_CONTEXT>();
5291          cl::Device device(getInfo<CL_QUEUE_DEVICE>());
5292          cl_platform_id platform = device.getInfo<CL_DEVICE_PLATFORM>();
5293          CL_HPP_INIT_CL_EXT_FCN_PTR_PLATFORM_(platform, clEnqueueAcquireD3D10ObjectsKHR);
5294  #endif
5295  #if CL_HPP_TARGET_OPENCL_VERSION >= 110
5296          CL_HPP_INIT_CL_EXT_FCN_PTR_(clEnqueueAcquireD3D10ObjectsKHR);
5297  #endif
5298          cl_event tmp;
5299          cl_int err = detail::errHandler(
5300               pfn_clEnqueueAcquireD3D10ObjectsKHR(
5301                   object_,
5302                   (mem_objects != NULL) ? (cl_uint) mem_objects->size() : 0,
5303                   (mem_objects != NULL && mem_objects->size() > 0) ? (const cl_mem *) &mem_objects->front(): NULL,
5304                   (events != NULL) ? (cl_uint) events->size() : 0,
5305                   (events != NULL) ? (cl_event*) &events->front() : NULL,
5306                   (event != NULL) ? &tmp : NULL),
5307               __ENQUEUE_ACQUIRE_GL_ERR);
5308          if (event != NULL && err == CL_SUCCESS)
5309              *event = tmp;
5310          return err;
5311       }
5312      cl_int enqueueReleaseD3D10Objects(
5313           const vector<Memory>* mem_objects = NULL,
5314           const vector<Event>* events = NULL,
5315           Event* event = NULL) const
5316      {
5317          static PFN_clEnqueueReleaseD3D10ObjectsKHR pfn_clEnqueueReleaseD3D10ObjectsKHR = NULL;
5318  #if CL_HPP_TARGET_OPENCL_VERSION >= 120
5319          cl_context context = getInfo<CL_QUEUE_CONTEXT>();
5320          cl::Device device(getInfo<CL_QUEUE_DEVICE>());
5321          cl_platform_id platform = device.getInfo<CL_DEVICE_PLATFORM>();
5322          CL_HPP_INIT_CL_EXT_FCN_PTR_PLATFORM_(platform, clEnqueueReleaseD3D10ObjectsKHR);
5323  #endif 
5324  #if CL_HPP_TARGET_OPENCL_VERSION >= 110
5325          CL_HPP_INIT_CL_EXT_FCN_PTR_(clEnqueueReleaseD3D10ObjectsKHR);
5326  #endif 
5327          cl_event tmp;
5328          cl_int err = detail::errHandler(
5329              pfn_clEnqueueReleaseD3D10ObjectsKHR(
5330                  object_,
5331                  (mem_objects != NULL) ? (cl_uint) mem_objects->size() : 0,
5332                  (mem_objects != NULL && mem_objects->size() > 0) ? (const cl_mem *) &mem_objects->front(): NULL,
5333                  (events != NULL) ? (cl_uint) events->size() : 0,
5334                  (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
5335                  (event != NULL) ? &tmp : NULL),
5336              __ENQUEUE_RELEASE_GL_ERR);
5337          if (event != NULL && err == CL_SUCCESS)
5338              *event = tmp;
5339          return err;
5340      }
5341  #endif
5342  #if defined(CL_USE_DEPRECATED_OPENCL_1_1_APIS)
5343      CL_EXT_PREFIX__VERSION_1_1_DEPRECATED
5344      cl_int enqueueBarrier() const CL_EXT_SUFFIX__VERSION_1_1_DEPRECATED
5345      {
5346          return detail::errHandler(
5347              ::clEnqueueBarrier(object_),
5348              __ENQUEUE_BARRIER_ERR);
5349      }
5350  #endif 
5351      cl_int flush() const
5352      {
5353          return detail::errHandler(::clFlush(object_), __FLUSH_ERR);
5354      }
5355      cl_int finish() const
5356      {
5357          return detail::errHandler(::clFinish(object_), __FINISH_ERR);
5358      }
5359  }; 
5360  CL_HPP_DEFINE_STATIC_MEMBER_ std::once_flag CommandQueue::default_initialized_;
5361  CL_HPP_DEFINE_STATIC_MEMBER_ CommandQueue CommandQueue::default_;
5362  CL_HPP_DEFINE_STATIC_MEMBER_ cl_int CommandQueue::default_error_ = CL_SUCCESS;
5363  #if CL_HPP_TARGET_OPENCL_VERSION >= 200
5364  enum class DeviceQueueProperties : cl_command_queue_properties
5365  {
5366      None = 0,
5367      Profiling = CL_QUEUE_PROFILING_ENABLE,
5368  };
5369  DeviceQueueProperties  operator|(DeviceQueueProperties  lhs, DeviceQueueProperties  rhs)
5370  {
5371      return static_cast<DeviceQueueProperties>(static_cast<cl_command_queue_properties>(lhs) | static_cast<cl_command_queue_properties>(rhs));
5372  }
5373  class DeviceCommandQueue : public detail::Wrapper<cl_command_queue>
5374  {
5375  public:
5376      DeviceCommandQueue() { }
5377      DeviceCommandQueue(DeviceQueueProperties properties, cl_int* err = NULL)
5378      {
5379          cl_int error;
5380          cl::Context context = cl::Context::getDefault();
5381          cl::Device device = cl::Device::getDefault();
5382          cl_command_queue_properties mergedProperties =
5383              CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE | CL_QUEUE_ON_DEVICE | static_cast<cl_command_queue_properties>(properties);
5384          cl_queue_properties queue_properties[] = {
5385              CL_QUEUE_PROPERTIES, mergedProperties, 0 };
5386          object_ = ::clCreateCommandQueueWithProperties(
5387              context(), device(), queue_properties, &error);
5388          detail::errHandler(error, __CREATE_COMMAND_QUEUE_WITH_PROPERTIES_ERR);
5389          if (err != NULL) {
5390              *err = error;
5391          }
5392      }
5393      DeviceCommandQueue(
5394          const Context& context,
5395          const Device& device,
5396          DeviceQueueProperties properties = DeviceQueueProperties::None,
5397          cl_int* err = NULL)
5398      {
5399          cl_int error;
5400          cl_command_queue_properties mergedProperties =
5401              CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE | CL_QUEUE_ON_DEVICE | static_cast<cl_command_queue_properties>(properties);
5402          cl_queue_properties queue_properties[] = {
5403              CL_QUEUE_PROPERTIES, mergedProperties, 0 };
5404          object_ = ::clCreateCommandQueueWithProperties(
5405              context(), device(), queue_properties, &error);
5406          detail::errHandler(error, __CREATE_COMMAND_QUEUE_WITH_PROPERTIES_ERR);
5407          if (err != NULL) {
5408              *err = error;
5409          }
5410      }
5411      DeviceCommandQueue(
5412          const Context& context,
5413          const Device& device,
5414          cl_uint queueSize,
5415          DeviceQueueProperties properties = DeviceQueueProperties::None,
5416          cl_int* err = NULL)
5417      {
5418          cl_int error;
5419          cl_command_queue_properties mergedProperties =
5420              CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE | CL_QUEUE_ON_DEVICE | static_cast<cl_command_queue_properties>(properties);
5421          cl_queue_properties queue_properties[] = {
5422              CL_QUEUE_PROPERTIES, mergedProperties,
5423              CL_QUEUE_SIZE, queueSize, 
5424              0 };
5425          object_ = ::clCreateCommandQueueWithProperties(
5426              context(), device(), queue_properties, &error);
5427          detail::errHandler(error, __CREATE_COMMAND_QUEUE_WITH_PROPERTIES_ERR);
5428          if (err != NULL) {
5429              *err = error;
5430          }
5431      }
5432      explicit DeviceCommandQueue(const cl_command_queue& commandQueue, bool retainObject = false) :
5433          detail::Wrapper<cl_type>(commandQueue, retainObject) { }
5434      DeviceCommandQueue& operator = (const cl_command_queue& rhs)
5435      {
5436          detail::Wrapper<cl_type>::operator=(rhs);
5437          return *this;
5438      }
5439      DeviceCommandQueue(const DeviceCommandQueue& queue) : detail::Wrapper<cl_type>(queue) {}
5440      DeviceCommandQueue& operator = (const DeviceCommandQueue &queue)
5441      {
5442          detail::Wrapper<cl_type>::operator=(queue);
5443          return *this;
5444      }
5445      DeviceCommandQueue(DeviceCommandQueue&& queue) CL_HPP_NOEXCEPT_ : detail::Wrapper<cl_type>(std::move(queue)) {}
5446      DeviceCommandQueue& operator = (DeviceCommandQueue &&queue)
5447      {
5448          detail::Wrapper<cl_type>::operator=(std::move(queue));
5449          return *this;
5450      }
5451      template <typename T>
5452      cl_int getInfo(cl_command_queue_info name, T* param) const
5453      {
5454          return detail::errHandler(
5455              detail::getInfo(
5456              &::clGetCommandQueueInfo, object_, name, param),
5457              __GET_COMMAND_QUEUE_INFO_ERR);
5458      }
5459      template <cl_int name> typename
5460          detail::param_traits<detail::cl_command_queue_info, name>::param_type
5461          getInfo(cl_int* err = NULL) const
5462      {
5463          typename detail::param_traits<
5464              detail::cl_command_queue_info, name>::param_type param;
5465          cl_int result = getInfo(name, &param);
5466          if (err != NULL) {
5467              *err = result;
5468          }
5469          return param;
5470      }
5471      static DeviceCommandQueue makeDefault(
5472          cl_int *err = nullptr)
5473      {
5474          cl_int error;
5475          cl::Context context = cl::Context::getDefault();
5476          cl::Device device = cl::Device::getDefault();
5477          cl_command_queue_properties properties =
5478              CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE | CL_QUEUE_ON_DEVICE | CL_QUEUE_ON_DEVICE_DEFAULT;
5479          cl_queue_properties queue_properties[] = {
5480              CL_QUEUE_PROPERTIES, properties,
5481              0 };
5482          DeviceCommandQueue deviceQueue(
5483              ::clCreateCommandQueueWithProperties(
5484              context(), device(), queue_properties, &error));
5485          detail::errHandler(error, __CREATE_COMMAND_QUEUE_WITH_PROPERTIES_ERR);
5486          if (err != NULL) {
5487              *err = error;
5488          }
5489          return deviceQueue;
5490      }
5491      static DeviceCommandQueue makeDefault(
5492          const Context &context, const Device &device, cl_int *err = nullptr)
5493      {
5494          cl_int error;
5495          cl_command_queue_properties properties =
5496              CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE | CL_QUEUE_ON_DEVICE | CL_QUEUE_ON_DEVICE_DEFAULT;
5497          cl_queue_properties queue_properties[] = {
5498              CL_QUEUE_PROPERTIES, properties,
5499              0 };
5500          DeviceCommandQueue deviceQueue(
5501              ::clCreateCommandQueueWithProperties(
5502              context(), device(), queue_properties, &error));
5503          detail::errHandler(error, __CREATE_COMMAND_QUEUE_WITH_PROPERTIES_ERR);
5504          if (err != NULL) {
5505              *err = error;
5506          }
5507          return deviceQueue;
5508      }
5509      static DeviceCommandQueue makeDefault(
5510          const Context &context, const Device &device, cl_uint queueSize, cl_int *err = nullptr)
5511      {
5512          cl_int error;
5513          cl_command_queue_properties properties =
5514              CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE | CL_QUEUE_ON_DEVICE | CL_QUEUE_ON_DEVICE_DEFAULT;
5515          cl_queue_properties queue_properties[] = {
5516              CL_QUEUE_PROPERTIES, properties,
5517              CL_QUEUE_SIZE, queueSize,
5518              0 };
5519          DeviceCommandQueue deviceQueue(
5520              ::clCreateCommandQueueWithProperties(
5521                  context(), device(), queue_properties, &error));
5522          detail::errHandler(error, __CREATE_COMMAND_QUEUE_WITH_PROPERTIES_ERR);
5523          if (err != NULL) {
5524              *err = error;
5525          }
5526          return deviceQueue;
5527      }
5528  }; 
5529  namespace detail
5530  {
5531      template <>
5532      struct KernelArgumentHandler<cl::DeviceCommandQueue, void>
5533      {
5534          static size_type size(const cl::DeviceCommandQueue&) { return sizeof(cl_command_queue); }
5535          static const cl_command_queue* ptr(const cl::DeviceCommandQueue& value) { return &(value()); }
5536      };
5537  } 
5538  #endif 
5539  template< typename IteratorType >
5540  Buffer::Buffer(
5541      const Context &context,
5542      IteratorType startIterator,
5543      IteratorType endIterator,
5544      bool readOnly,
5545      bool useHostPtr,
5546      cl_int* err)
5547  {
5548      typedef typename std::iterator_traits<IteratorType>::value_type DataType;
5549      cl_int error;
5550      cl_mem_flags flags = 0;
5551      if( readOnly ) {
5552          flags |= CL_MEM_READ_ONLY;
5553      }
5554      else {
5555          flags |= CL_MEM_READ_WRITE;
5556      }
5557      if( useHostPtr ) {
5558          flags |= CL_MEM_USE_HOST_PTR;
5559      }
5560      size_type size = sizeof(DataType)*(endIterator - startIterator);
5561      if( useHostPtr ) {
5562          object_ = ::clCreateBuffer(context(), flags, size, static_cast<DataType*>(&*startIterator), &error);
5563      } else {
5564          object_ = ::clCreateBuffer(context(), flags, size, 0, &error);
5565      }
5566      detail::errHandler(error, __CREATE_BUFFER_ERR);
5567      if (err != NULL) {
5568          *err = error;
5569      }
5570      if( !useHostPtr ) {
5571          CommandQueue queue(context, 0, &error);
5572          detail::errHandler(error, __CREATE_BUFFER_ERR);
5573          if (err != NULL) {
5574              *err = error;
5575          }
5576          error = cl::copy(queue, startIterator, endIterator, *this);
5577          detail::errHandler(error, __CREATE_BUFFER_ERR);
5578          if (err != NULL) {
5579              *err = error;
5580          }
5581      }
5582  }
5583  template< typename IteratorType >
5584  Buffer::Buffer(
5585      const CommandQueue &queue,
5586      IteratorType startIterator,
5587      IteratorType endIterator,
5588      bool readOnly,
5589      bool useHostPtr,
5590      cl_int* err)
5591  {
5592      typedef typename std::iterator_traits<IteratorType>::value_type DataType;
5593      cl_int error;
5594      cl_mem_flags flags = 0;
5595      if (readOnly) {
5596          flags |= CL_MEM_READ_ONLY;
5597      }
5598      else {
5599          flags |= CL_MEM_READ_WRITE;
5600      }
5601      if (useHostPtr) {
5602          flags |= CL_MEM_USE_HOST_PTR;
5603      }
5604      size_type size = sizeof(DataType)*(endIterator - startIterator);
5605      Context context = queue.getInfo<CL_QUEUE_CONTEXT>();
5606      if (useHostPtr) {
5607          object_ = ::clCreateBuffer(context(), flags, size, static_cast<DataType*>(&*startIterator), &error);
5608      }
5609      else {
5610          object_ = ::clCreateBuffer(context(), flags, size, 0, &error);
5611      }
5612      detail::errHandler(error, __CREATE_BUFFER_ERR);
5613      if (err != NULL) {
5614          *err = error;
5615      }
5616      if (!useHostPtr) {
5617          error = cl::copy(queue, startIterator, endIterator, *this);
5618          detail::errHandler(error, __CREATE_BUFFER_ERR);
5619          if (err != NULL) {
5620              *err = error;
5621          }
5622      }
5623  }
5624  inline cl_int enqueueReadBuffer(
5625      const Buffer& buffer,
5626      cl_bool blocking,
5627      size_type offset,
5628      size_type size,
5629      void* ptr,
5630      const vector<Event>* events = NULL,
5631      Event* event = NULL)
5632  {
5633      cl_int error;
5634      CommandQueue queue = CommandQueue::getDefault(&error);
5635      if (error != CL_SUCCESS) {
5636          return error;
5637      }
5638      return queue.enqueueReadBuffer(buffer, blocking, offset, size, ptr, events, event);
5639  }
5640  inline cl_int enqueueWriteBuffer(
5641          const Buffer& buffer,
5642          cl_bool blocking,
5643          size_type offset,
5644          size_type size,
5645          const void* ptr,
5646          const vector<Event>* events = NULL,
5647          Event* event = NULL)
5648  {
5649      cl_int error;
5650      CommandQueue queue = CommandQueue::getDefault(&error);
5651      if (error != CL_SUCCESS) {
5652          return error;
5653      }
5654      return queue.enqueueWriteBuffer(buffer, blocking, offset, size, ptr, events, event);
5655  }
5656  inline void* enqueueMapBuffer(
5657          const Buffer& buffer,
5658          cl_bool blocking,
5659          cl_map_flags flags,
5660          size_type offset,
5661          size_type size,
5662          const vector<Event>* events = NULL,
5663          Event* event = NULL,
5664          cl_int* err = NULL)
5665  {
5666      cl_int error;
5667      CommandQueue queue = CommandQueue::getDefault(&error);
5668      detail::errHandler(error, __ENQUEUE_MAP_BUFFER_ERR);
5669      if (err != NULL) {
5670          *err = error;
5671      }
5672      void * result = ::clEnqueueMapBuffer(
5673              queue(), buffer(), blocking, flags, offset, size,
5674              (events != NULL) ? (cl_uint) events->size() : 0,
5675              (events != NULL && events->size() > 0) ? (cl_event*) &events->front() : NULL,
5676              (cl_event*) event,
5677              &error);
5678      detail::errHandler(error, __ENQUEUE_MAP_BUFFER_ERR);
5679      if (err != NULL) {
5680          *err = error;
5681      }
5682      return result;
5683  }
5684  #if CL_HPP_TARGET_OPENCL_VERSION >= 200
5685  template<typename T>
5686  inline cl_int enqueueMapSVM(
5687      T* ptr,
5688      cl_bool blocking,
5689      cl_map_flags flags,
5690      size_type size,
5691      const vector<Event>* events,
5692      Event* event)
5693  {
5694      cl_int error;
5695      CommandQueue queue = CommandQueue::getDefault(&error);
5696      if (error != CL_SUCCESS) {
5697          return detail::errHandler(error, __ENQUEUE_MAP_BUFFER_ERR);
5698      }
5699      return queue.enqueueMapSVM(
5700          ptr, blocking, flags, size, events, event);
5701  }
5702  template<typename T, class D>
5703  inline cl_int enqueueMapSVM(
5704      cl::pointer<T, D> ptr,
5705      cl_bool blocking,
5706      cl_map_flags flags,
5707      size_type size,
5708      const vector<Event>* events = NULL,
5709      Event* event = NULL)
5710  {
5711      cl_int error;
5712      CommandQueue queue = CommandQueue::getDefault(&error);
5713      if (error != CL_SUCCESS) {
5714          return detail::errHandler(error, __ENQUEUE_MAP_BUFFER_ERR);
5715      }
5716      return queue.enqueueMapSVM(
5717          ptr, blocking, flags, size, events, event);
5718  }
5719  template<typename T, class Alloc>
5720  inline cl_int enqueueMapSVM(
5721      cl::vector<T, Alloc> container,
5722      cl_bool blocking,
5723      cl_map_flags flags,
5724      const vector<Event>* events = NULL,
5725      Event* event = NULL)
5726  {
5727      cl_int error;
5728      CommandQueue queue = CommandQueue::getDefault(&error);
5729      if (error != CL_SUCCESS) {
5730          return detail::errHandler(error, __ENQUEUE_MAP_BUFFER_ERR);
5731      }
5732      return queue.enqueueMapSVM(
5733          container, blocking, flags, events, event);
5734  }
5735  #endif 
5736  inline cl_int enqueueUnmapMemObject(
5737      const Memory& memory,
5738      void* mapped_ptr,
5739      const vector<Event>* events = NULL,
5740      Event* event = NULL)
5741  {
5742      cl_int error;
5743      CommandQueue queue = CommandQueue::getDefault(&error);
5744      detail::errHandler(error, __ENQUEUE_MAP_BUFFER_ERR);
5745      if (error != CL_SUCCESS) {
5746          return error;
5747      }
5748      cl_event tmp;
5749      cl_int err = detail::errHandler(
5750          ::clEnqueueUnmapMemObject(
5751          queue(), memory(), mapped_ptr,
5752          (events != NULL) ? (cl_uint)events->size() : 0,
5753          (events != NULL && events->size() > 0) ? (cl_event*)&events->front() : NULL,
5754          (event != NULL) ? &tmp : NULL),
5755          __ENQUEUE_UNMAP_MEM_OBJECT_ERR);
5756      if (event != NULL && err == CL_SUCCESS)
5757          *event = tmp;
5758      return err;
5759  }
5760  #if CL_HPP_TARGET_OPENCL_VERSION >= 200
5761  template<typename T>
5762  inline cl_int enqueueUnmapSVM(
5763      T* ptr,
5764      const vector<Event>* events = NULL,
5765      Event* event = NULL)
5766  {
5767      cl_int error;
5768      CommandQueue queue = CommandQueue::getDefault(&error);
5769      if (error != CL_SUCCESS) {
5770          return detail::errHandler(error, __ENQUEUE_UNMAP_MEM_OBJECT_ERR);
5771      }
5772      return detail::errHandler(queue.enqueueUnmapSVM(ptr, events, event), 
5773          __ENQUEUE_UNMAP_MEM_OBJECT_ERR);
5774  }
5775  template<typename T, class D>
5776  inline cl_int enqueueUnmapSVM(
5777      cl::pointer<T, D> &ptr,
5778      const vector<Event>* events = NULL,
5779      Event* event = NULL)
5780  {
5781      cl_int error;
5782      CommandQueue queue = CommandQueue::getDefault(&error);
5783      if (error != CL_SUCCESS) {
5784          return detail::errHandler(error, __ENQUEUE_UNMAP_MEM_OBJECT_ERR);
5785      }
5786      return detail::errHandler(queue.enqueueUnmapSVM(ptr, events, event),
5787          __ENQUEUE_UNMAP_MEM_OBJECT_ERR);
5788  }
5789  template<typename T, class Alloc>
5790  inline cl_int enqueueUnmapSVM(
5791      cl::vector<T, Alloc> &container,
5792      const vector<Event>* events = NULL,
5793      Event* event = NULL)
5794  {
5795      cl_int error;
5796      CommandQueue queue = CommandQueue::getDefault(&error);
5797      if (error != CL_SUCCESS) {
5798          return detail::errHandler(error, __ENQUEUE_UNMAP_MEM_OBJECT_ERR);
5799      }
5800      return detail::errHandler(queue.enqueueUnmapSVM(container, events, event),
5801          __ENQUEUE_UNMAP_MEM_OBJECT_ERR);
5802  }
5803  #endif 
5804  inline cl_int enqueueCopyBuffer(
5805          const Buffer& src,
5806          const Buffer& dst,
5807          size_type src_offset,
5808          size_type dst_offset,
5809          size_type size,
5810          const vector<Event>* events = NULL,
5811          Event* event = NULL)
5812  {
5813      cl_int error;
5814      CommandQueue queue = CommandQueue::getDefault(&error);
5815      if (error != CL_SUCCESS) {
5816          return error;
5817      }
5818      return queue.enqueueCopyBuffer(src, dst, src_offset, dst_offset, size, events, event);
5819  }
5820  template< typename IteratorType >
5821  inline cl_int copy( IteratorType startIterator, IteratorType endIterator, cl::Buffer &buffer )
5822  {
5823      cl_int error;
5824      CommandQueue queue = CommandQueue::getDefault(&error);
5825      if (error != CL_SUCCESS)
5826          return error;
5827      return cl::copy(queue, startIterator, endIterator, buffer);
5828  }
5829  template< typename IteratorType >
5830  inline cl_int copy( const cl::Buffer &buffer, IteratorType startIterator, IteratorType endIterator )
5831  {
5832      cl_int error;
5833      CommandQueue queue = CommandQueue::getDefault(&error);
5834      if (error != CL_SUCCESS)
5835          return error;
5836      return cl::copy(queue, buffer, startIterator, endIterator);
5837  }
5838  template< typename IteratorType >
5839  inline cl_int copy( const CommandQueue &queue, IteratorType startIterator, IteratorType endIterator, cl::Buffer &buffer )
5840  {
5841      typedef typename std::iterator_traits<IteratorType>::value_type DataType;
5842      cl_int error;
5843      size_type length = endIterator-startIterator;
5844      size_type byteLength = length*sizeof(DataType);
5845      DataType *pointer = 
5846          static_cast<DataType*>(queue.enqueueMapBuffer(buffer, CL_TRUE, CL_MAP_WRITE, 0, byteLength, 0, 0, &error));
5847      if( error != CL_SUCCESS ) {
5848          return error;
5849      }
5850  #if defined(_MSC_VER)
5851      std::copy(
5852          startIterator, 
5853          endIterator, 
5854          stdext::checked_array_iterator<DataType*>(
5855              pointer, length));
5856  #else
5857      std::copy(startIterator, endIterator, pointer);
5858  #endif
5859      Event endEvent;
5860      error = queue.enqueueUnmapMemObject(buffer, pointer, 0, &endEvent);
5861      if( error != CL_SUCCESS ) { 
5862          return error;
5863      }
5864      endEvent.wait();
5865      return CL_SUCCESS;
5866  }
5867  template< typename IteratorType >
5868  inline cl_int copy( const CommandQueue &queue, const cl::Buffer &buffer, IteratorType startIterator, IteratorType endIterator )
5869  {
5870      typedef typename std::iterator_traits<IteratorType>::value_type DataType;
5871      cl_int error;
5872      size_type length = endIterator-startIterator;
5873      size_type byteLength = length*sizeof(DataType);
5874      DataType *pointer = 
5875          static_cast<DataType*>(queue.enqueueMapBuffer(buffer, CL_TRUE, CL_MAP_READ, 0, byteLength, 0, 0, &error));
5876      if( error != CL_SUCCESS ) {
5877          return error;
5878      }
5879      std::copy(pointer, pointer + length, startIterator);
5880      Event endEvent;
5881      error = queue.enqueueUnmapMemObject(buffer, pointer, 0, &endEvent);
5882      if( error != CL_SUCCESS ) { 
5883          return error;
5884      }
5885      endEvent.wait();
5886      return CL_SUCCESS;
5887  }
5888  #if CL_HPP_TARGET_OPENCL_VERSION >= 200
5889  template<typename T, class Alloc>
5890  inline cl_int mapSVM(cl::vector<T, Alloc> &container)
5891  {
5892      return enqueueMapSVM(container, CL_TRUE, CL_MAP_READ | CL_MAP_WRITE);
5893  }
5894  template<typename T, class Alloc>
5895  inline cl_int unmapSVM(cl::vector<T, Alloc> &container)
5896  {
5897      return enqueueUnmapSVM(container);
5898  }
5899  #endif 
5900  #if CL_HPP_TARGET_OPENCL_VERSION >= 110
5901  inline cl_int enqueueReadBufferRect(
5902      const Buffer& buffer,
5903      cl_bool blocking,
5904      const array<size_type, 3>& buffer_offset,
5905      const array<size_type, 3>& host_offset,
5906      const array<size_type, 3>& region,
5907      size_type buffer_row_pitch,
5908      size_type buffer_slice_pitch,
5909      size_type host_row_pitch,
5910      size_type host_slice_pitch,
5911      void *ptr,
5912      const vector<Event>* events = NULL,
5913      Event* event = NULL)
5914  {
5915      cl_int error;
5916      CommandQueue queue = CommandQueue::getDefault(&error);
5917      if (error != CL_SUCCESS) {
5918          return error;
5919      }
5920      return queue.enqueueReadBufferRect(
5921          buffer, 
5922          blocking, 
5923          buffer_offset, 
5924          host_offset,
5925          region,
5926          buffer_row_pitch,
5927          buffer_slice_pitch,
5928          host_row_pitch,
5929          host_slice_pitch,
5930          ptr, 
5931          events, 
5932          event);
5933  }
5934  inline cl_int enqueueWriteBufferRect(
5935      const Buffer& buffer,
5936      cl_bool blocking,
5937      const array<size_type, 3>& buffer_offset,
5938      const array<size_type, 3>& host_offset,
5939      const array<size_type, 3>& region,
5940      size_type buffer_row_pitch,
5941      size_type buffer_slice_pitch,
5942      size_type host_row_pitch,
5943      size_type host_slice_pitch,
5944      void *ptr,
5945      const vector<Event>* events = NULL,
5946      Event* event = NULL)
5947  {
5948      cl_int error;
5949      CommandQueue queue = CommandQueue::getDefault(&error);
5950      if (error != CL_SUCCESS) {
5951          return error;
5952      }
5953      return queue.enqueueWriteBufferRect(
5954          buffer, 
5955          blocking, 
5956          buffer_offset, 
5957          host_offset,
5958          region,
5959          buffer_row_pitch,
5960          buffer_slice_pitch,
5961          host_row_pitch,
5962          host_slice_pitch,
5963          ptr, 
5964          events, 
5965          event);
5966  }
5967  inline cl_int enqueueCopyBufferRect(
5968      const Buffer& src,
5969      const Buffer& dst,
5970      const array<size_type, 3>& src_origin,
5971      const array<size_type, 3>& dst_origin,
5972      const array<size_type, 3>& region,
5973      size_type src_row_pitch,
5974      size_type src_slice_pitch,
5975      size_type dst_row_pitch,
5976      size_type dst_slice_pitch,
5977      const vector<Event>* events = NULL,
5978      Event* event = NULL)
5979  {
5980      cl_int error;
5981      CommandQueue queue = CommandQueue::getDefault(&error);
5982      if (error != CL_SUCCESS) {
5983          return error;
5984      }
5985      return queue.enqueueCopyBufferRect(
5986          src,
5987          dst,
5988          src_origin,
5989          dst_origin,
5990          region,
5991          src_row_pitch,
5992          src_slice_pitch,
5993          dst_row_pitch,
5994          dst_slice_pitch,
5995          events, 
5996          event);
5997  }
5998  #endif 
5999  inline cl_int enqueueReadImage(
6000      const Image& image,
6001      cl_bool blocking,
6002      const array<size_type, 3>& origin,
6003      const array<size_type, 3>& region,
6004      size_type row_pitch,
6005      size_type slice_pitch,
6006      void* ptr,
6007      const vector<Event>* events = NULL,
6008      Event* event = NULL) 
6009  {
6010      cl_int error;
6011      CommandQueue queue = CommandQueue::getDefault(&error);
6012      if (error != CL_SUCCESS) {
6013          return error;
6014      }
6015      return queue.enqueueReadImage(
6016          image,
6017          blocking,
6018          origin,
6019          region,
6020          row_pitch,
6021          slice_pitch,
6022          ptr,
6023          events, 
6024          event);
6025  }
6026  inline cl_int enqueueWriteImage(
6027      const Image& image,
6028      cl_bool blocking,
6029      const array<size_type, 3>& origin,
6030      const array<size_type, 3>& region,
6031      size_type row_pitch,
6032      size_type slice_pitch,
6033      void* ptr,
6034      const vector<Event>* events = NULL,
6035      Event* event = NULL)
6036  {
6037      cl_int error;
6038      CommandQueue queue = CommandQueue::getDefault(&error);
6039      if (error != CL_SUCCESS) {
6040          return error;
6041      }
6042      return queue.enqueueWriteImage(
6043          image,
6044          blocking,
6045          origin,
6046          region,
6047          row_pitch,
6048          slice_pitch,
6049          ptr,
6050          events, 
6051          event);
6052  }
6053  inline cl_int enqueueCopyImage(
6054      const Image& src,
6055      const Image& dst,
6056      const array<size_type, 3>& src_origin,
6057      const array<size_type, 3>& dst_origin,
6058      const array<size_type, 3>& region,
6059      const vector<Event>* events = NULL,
6060      Event* event = NULL)
6061  {
6062      cl_int error;
6063      CommandQueue queue = CommandQueue::getDefault(&error);
6064      if (error != CL_SUCCESS) {
6065          return error;
6066      }
6067      return queue.enqueueCopyImage(
6068          src,
6069          dst,
6070          src_origin,
6071          dst_origin,
6072          region,
6073          events,
6074          event);
6075  }
6076  inline cl_int enqueueCopyImageToBuffer(
6077      const Image& src,
6078      const Buffer& dst,
6079      const array<size_type, 3>& src_origin,
6080      const array<size_type, 3>& region,
6081      size_type dst_offset,
6082      const vector<Event>* events = NULL,
6083      Event* event = NULL)
6084  {
6085      cl_int error;
6086      CommandQueue queue = CommandQueue::getDefault(&error);
6087      if (error != CL_SUCCESS) {
6088          return error;
6089      }
6090      return queue.enqueueCopyImageToBuffer(
6091          src,
6092          dst,
6093          src_origin,
6094          region,
6095          dst_offset,
6096          events,
6097          event);
6098  }
6099  inline cl_int enqueueCopyBufferToImage(
6100      const Buffer& src,
6101      const Image& dst,
6102      size_type src_offset,
6103      const array<size_type, 3>& dst_origin,
6104      const array<size_type, 3>& region,
6105      const vector<Event>* events = NULL,
6106      Event* event = NULL)
6107  {
6108      cl_int error;
6109      CommandQueue queue = CommandQueue::getDefault(&error);
6110      if (error != CL_SUCCESS) {
6111          return error;
6112      }
6113      return queue.enqueueCopyBufferToImage(
6114          src,
6115          dst,
6116          src_offset,
6117          dst_origin,
6118          region,
6119          events,
6120          event);
6121  }
6122  inline cl_int flush(void)
6123  {
6124      cl_int error;
6125      CommandQueue queue = CommandQueue::getDefault(&error);
6126      if (error != CL_SUCCESS) {
6127          return error;
6128      }
6129      return queue.flush();
6130  }
6131  inline cl_int finish(void)
6132  {
6133      cl_int error;
6134      CommandQueue queue = CommandQueue::getDefault(&error);
6135      if (error != CL_SUCCESS) {
6136          return error;
6137      } 
6138      return queue.finish();
6139  }
6140  class EnqueueArgs
6141  {
6142  private:
6143      CommandQueue queue_;
6144      const NDRange offset_;
6145      const NDRange global_;
6146      const NDRange local_;
6147      vector<Event> events_;
6148      template<typename... Ts>
6149      friend class KernelFunctor;
6150  public:
6151      EnqueueArgs(NDRange global) : 
6152        queue_(CommandQueue::getDefault()),
6153        offset_(NullRange), 
6154        global_(global),
6155        local_(NullRange)
6156      {
6157      }
6158      EnqueueArgs(NDRange global, NDRange local) : 
6159        queue_(CommandQueue::getDefault()),
6160        offset_(NullRange), 
6161        global_(global),
6162        local_(local)
6163      {
6164      }
6165      EnqueueArgs(NDRange offset, NDRange global, NDRange local) : 
6166        queue_(CommandQueue::getDefault()),
6167        offset_(offset), 
6168        global_(global),
6169        local_(local)
6170      {
6171      }
6172      EnqueueArgs(Event e, NDRange global) : 
6173        queue_(CommandQueue::getDefault()),
6174        offset_(NullRange), 
6175        global_(global),
6176        local_(NullRange)
6177      {
6178          events_.push_back(e);
6179      }
6180      EnqueueArgs(Event e, NDRange global, NDRange local) : 
6181        queue_(CommandQueue::getDefault()),
6182        offset_(NullRange), 
6183        global_(global),
6184        local_(local)
6185      {
6186          events_.push_back(e);
6187      }
6188      EnqueueArgs(Event e, NDRange offset, NDRange global, NDRange local) : 
6189        queue_(CommandQueue::getDefault()),
6190        offset_(offset), 
6191        global_(global),
6192        local_(local)
6193      {
6194          events_.push_back(e);
6195      }
6196      EnqueueArgs(const vector<Event> &events, NDRange global) : 
6197        queue_(CommandQueue::getDefault()),
6198        offset_(NullRange), 
6199        global_(global),
6200        local_(NullRange),
6201        events_(events)
6202      {
6203      }
6204      EnqueueArgs(const vector<Event> &events, NDRange global, NDRange local) : 
6205        queue_(CommandQueue::getDefault()),
6206        offset_(NullRange), 
6207        global_(global),
6208        local_(local),
6209        events_(events)
6210      {
6211      }
6212      EnqueueArgs(const vector<Event> &events, NDRange offset, NDRange global, NDRange local) : 
6213        queue_(CommandQueue::getDefault()),
6214        offset_(offset), 
6215        global_(global),
6216        local_(local),
6217        events_(events)
6218      {
6219      }
6220      EnqueueArgs(CommandQueue &queue, NDRange global) : 
6221        queue_(queue),
6222        offset_(NullRange), 
6223        global_(global),
6224        local_(NullRange)
6225      {
6226      }
6227      EnqueueArgs(CommandQueue &queue, NDRange global, NDRange local) : 
6228        queue_(queue),
6229        offset_(NullRange), 
6230        global_(global),
6231        local_(local)
6232      {
6233      }
6234      EnqueueArgs(CommandQueue &queue, NDRange offset, NDRange global, NDRange local) : 
6235        queue_(queue),
6236        offset_(offset), 
6237        global_(global),
6238        local_(local)
6239      {
6240      }
6241      EnqueueArgs(CommandQueue &queue, Event e, NDRange global) : 
6242        queue_(queue),
6243        offset_(NullRange), 
6244        global_(global),
6245        local_(NullRange)
6246      {
6247          events_.push_back(e);
6248      }
6249      EnqueueArgs(CommandQueue &queue, Event e, NDRange global, NDRange local) : 
6250        queue_(queue),
6251        offset_(NullRange), 
6252        global_(global),
6253        local_(local)
6254      {
6255          events_.push_back(e);
6256      }
6257      EnqueueArgs(CommandQueue &queue, Event e, NDRange offset, NDRange global, NDRange local) : 
6258        queue_(queue),
6259        offset_(offset), 
6260        global_(global),
6261        local_(local)
6262      {
6263          events_.push_back(e);
6264      }
6265      EnqueueArgs(CommandQueue &queue, const vector<Event> &events, NDRange global) : 
6266        queue_(queue),
6267        offset_(NullRange), 
6268        global_(global),
6269        local_(NullRange),
6270        events_(events)
6271      {
6272      }
6273      EnqueueArgs(CommandQueue &queue, const vector<Event> &events, NDRange global, NDRange local) : 
6274        queue_(queue),
6275        offset_(NullRange), 
6276        global_(global),
6277        local_(local),
6278        events_(events)
6279      {
6280      }
6281      EnqueueArgs(CommandQueue &queue, const vector<Event> &events, NDRange offset, NDRange global, NDRange local) : 
6282        queue_(queue),
6283        offset_(offset), 
6284        global_(global),
6285        local_(local),
6286        events_(events)
6287      {
6288      }
6289  };
6290  template<typename... Ts>
6291  class KernelFunctor
6292  {
6293  private:
6294      Kernel kernel_;
6295      template<int index, typename T0, typename... T1s>
6296      void setArgs(T0&& t0, T1s&&... t1s)
6297      {
6298          kernel_.setArg(index, t0);
6299          setArgs<index + 1, T1s...>(std::forward<T1s>(t1s)...);
6300      }
6301      template<int index, typename T0>
6302      void setArgs(T0&& t0)
6303      {
6304          kernel_.setArg(index, t0);
6305      }
6306      template<int index>
6307      void setArgs()
6308      {
6309      }
6310  public:
6311      KernelFunctor(Kernel kernel) : kernel_(kernel)
6312      {}
6313      KernelFunctor(
6314          const Program& program,
6315          const string name,
6316          cl_int * err = NULL) :
6317          kernel_(program, name.c_str(), err)
6318      {}
6319      typedef Event result_type;
6320      Event operator() (
6321          const EnqueueArgs& args,
6322          Ts... ts)
6323      {
6324          Event event;
6325          setArgs<0>(std::forward<Ts>(ts)...);
6326          args.queue_.enqueueNDRangeKernel(
6327              kernel_,
6328              args.offset_,
6329              args.global_,
6330              args.local_,
6331              &args.events_,
6332              &event);
6333          return event;
6334      }
6335      Event operator() (
6336          const EnqueueArgs& args,
6337          Ts... ts,
6338          cl_int &error)
6339      {
6340          Event event;
6341          setArgs<0>(std::forward<Ts>(ts)...);
6342          error = args.queue_.enqueueNDRangeKernel(
6343              kernel_,
6344              args.offset_,
6345              args.global_,
6346              args.local_,
6347              &args.events_,
6348              &event);
6349          return event;
6350      }
6351  #if CL_HPP_TARGET_OPENCL_VERSION >= 200
6352      cl_int setSVMPointers(const vector<void*> &pointerList)
6353      {
6354          return kernel_.setSVMPointers(pointerList);
6355      }
6356      template<typename T0, typename... T1s>
6357      cl_int setSVMPointers(const T0 &t0, T1s... ts)
6358      {
6359          return kernel_.setSVMPointers(t0, ts...);
6360      }
6361  #endif 
6362      Kernel getKernel()
6363      {
6364          return kernel_;
6365      }
6366  };
6367  namespace compatibility {
6368      template<typename... Ts>
6369      struct make_kernel
6370      {
6371          typedef KernelFunctor<Ts...> FunctorType;
6372          FunctorType functor_;
6373          make_kernel(
6374              const Program& program,
6375              const string name,
6376              cl_int * err = NULL) :
6377              functor_(FunctorType(program, name, err))
6378          {}
6379          make_kernel(
6380              const Kernel kernel) :
6381              functor_(FunctorType(kernel))
6382          {}
6383          typedef Event result_type;
6384          typedef Event type_(
6385              const EnqueueArgs&,
6386              Ts...);
6387          Event operator()(
6388              const EnqueueArgs& enqueueArgs,
6389              Ts... args)
6390          {
6391              return functor_(
6392                  enqueueArgs, args...);
6393          }
6394      };
6395  } 
6396  #undef CL_HPP_ERR_STR_
6397  #if !defined(CL_HPP_USER_OVERRIDE_ERROR_STRINGS)
6398  #undef __GET_DEVICE_INFO_ERR
6399  #undef __GET_PLATFORM_INFO_ERR
6400  #undef __GET_DEVICE_IDS_ERR
6401  #undef __GET_CONTEXT_INFO_ERR
6402  #undef __GET_EVENT_INFO_ERR
6403  #undef __GET_EVENT_PROFILE_INFO_ERR
6404  #undef __GET_MEM_OBJECT_INFO_ERR
6405  #undef __GET_IMAGE_INFO_ERR
6406  #undef __GET_SAMPLER_INFO_ERR
6407  #undef __GET_KERNEL_INFO_ERR
6408  #undef __GET_KERNEL_ARG_INFO_ERR
6409  #undef __GET_KERNEL_WORK_GROUP_INFO_ERR
6410  #undef __GET_PROGRAM_INFO_ERR
6411  #undef __GET_PROGRAM_BUILD_INFO_ERR
6412  #undef __GET_COMMAND_QUEUE_INFO_ERR
6413  #undef __CREATE_CONTEXT_ERR
6414  #undef __CREATE_CONTEXT_FROM_TYPE_ERR
6415  #undef __GET_SUPPORTED_IMAGE_FORMATS_ERR
6416  #undef __CREATE_BUFFER_ERR
6417  #undef __CREATE_SUBBUFFER_ERR
6418  #undef __CREATE_IMAGE2D_ERR
6419  #undef __CREATE_IMAGE3D_ERR
6420  #undef __CREATE_SAMPLER_ERR
6421  #undef __SET_MEM_OBJECT_DESTRUCTOR_CALLBACK_ERR
6422  #undef __CREATE_USER_EVENT_ERR
6423  #undef __SET_USER_EVENT_STATUS_ERR
6424  #undef __SET_EVENT_CALLBACK_ERR
6425  #undef __SET_PRINTF_CALLBACK_ERR
6426  #undef __WAIT_FOR_EVENTS_ERR
6427  #undef __CREATE_KERNEL_ERR
6428  #undef __SET_KERNEL_ARGS_ERR
6429  #undef __CREATE_PROGRAM_WITH_SOURCE_ERR
6430  #undef __CREATE_PROGRAM_WITH_BINARY_ERR
6431  #undef __CREATE_PROGRAM_WITH_BUILT_IN_KERNELS_ERR
6432  #undef __BUILD_PROGRAM_ERR
6433  #undef __CREATE_KERNELS_IN_PROGRAM_ERR
6434  #undef __CREATE_COMMAND_QUEUE_ERR
6435  #undef __SET_COMMAND_QUEUE_PROPERTY_ERR
6436  #undef __ENQUEUE_READ_BUFFER_ERR
6437  #undef __ENQUEUE_WRITE_BUFFER_ERR
6438  #undef __ENQUEUE_READ_BUFFER_RECT_ERR
6439  #undef __ENQUEUE_WRITE_BUFFER_RECT_ERR
6440  #undef __ENQEUE_COPY_BUFFER_ERR
6441  #undef __ENQEUE_COPY_BUFFER_RECT_ERR
6442  #undef __ENQUEUE_READ_IMAGE_ERR
6443  #undef __ENQUEUE_WRITE_IMAGE_ERR
6444  #undef __ENQUEUE_COPY_IMAGE_ERR
6445  #undef __ENQUEUE_COPY_IMAGE_TO_BUFFER_ERR
6446  #undef __ENQUEUE_COPY_BUFFER_TO_IMAGE_ERR
6447  #undef __ENQUEUE_MAP_BUFFER_ERR
6448  #undef __ENQUEUE_MAP_IMAGE_ERR
6449  #undef __ENQUEUE_UNMAP_MEM_OBJECT_ERR
6450  #undef __ENQUEUE_NDRANGE_KERNEL_ERR
6451  #undef __ENQUEUE_TASK_ERR
6452  #undef __ENQUEUE_NATIVE_KERNEL
6453  #undef __UNLOAD_COMPILER_ERR
6454  #undef __CREATE_SUB_DEVICES_ERR
6455  #undef __CREATE_PIPE_ERR
6456  #undef __GET_PIPE_INFO_ERR
6457  #endif 
6458  #undef CL_HPP_INIT_CL_EXT_FCN_PTR_
6459  #undef CL_HPP_INIT_CL_EXT_FCN_PTR_PLATFORM_
6460  #if defined(CL_HPP_USE_CL_DEVICE_FISSION)
6461  #undef CL_HPP_PARAM_NAME_DEVICE_FISSION_
6462  #endif 
6463  #undef CL_HPP_NOEXCEPT_
6464  #undef CL_HPP_DEFINE_STATIC_MEMBER_
6465  } 
6466  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-cl2.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-cl2.hpp</div>
                </div>
                <div class="column column_space"><pre><code>3327          cl_filter_mode filter_mode,
3328          cl_int* err = NULL)
3329      {
3330          cl_int error;
3331  #if CL_HPP_TARGET_OPENCL_VERSION >= 200
3332          cl_sampler_properties sampler_properties[] = {
3333              CL_SAMPLER_NORMALIZED_COORDS, normalized_coords,
</pre></code></div>
                <div class="column column_space"><pre><code>4394          QueueProperties properties,
4395          cl_int* err = NULL)
4396      {
4397              cl_int error;
4398  #if CL_HPP_TARGET_OPENCL_VERSION >= 200
4399              cl_queue_properties queue_properties[] = {
4400                  CL_QUEUE_PROPERTIES, static_cast<cl_queue_properties>(properties), 0 };
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    