
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.1778584392014517%, Tokens: 9</h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-scanutils.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include <cctype>
5  #include <climits> 
6  #include <cmath>
7  #include <cstdarg>
8  #include <cstddef>
9  #include <cstdint>
10  #include <cstdio>
11  #include <cstring>
12  #include <limits> 
13  #include "scanutils.h"
14  enum Flags {
15    FL_SPLAT = 0x01, 
16    FL_INV = 0x02,   
17    FL_WIDTH = 0x04, 
18    FL_MINUS = 0x08, 
19  };
20  enum Ranks {
21    RANK_CHAR = -2,
22    RANK_SHORT = -1,
23    RANK_INT = 0,
24    RANK_LONG = 1,
25    RANK_LONGLONG = 2,
26    RANK_PTR = std::numeric_limits<int>::max() 
27  };
28  const enum Ranks kMinRank = RANK_CHAR;
29  const enum Ranks kMaxRank = RANK_LONGLONG;
30  const enum Ranks kIntMaxRank = RANK_LONGLONG;
31  const enum Ranks kSizeTRank = RANK_LONG;
32  const enum Ranks kPtrDiffRank = RANK_LONG;
33  enum Bail {
34    BAIL_NONE = 0, 
35    BAIL_EOF,      
36    BAIL_ERR       
37  };
38  inline size_t LongBit() {
39    return CHAR_BIT * sizeof(long);
40  }
41  static inline int SkipSpace(FILE *s) {
42    int p;
43    while (isascii(p = fgetc(s)) && isspace(p)) {
44      ;
45    }
46    ungetc(p, s); 
47    return p;
48  }
49  static inline void SetBit(unsigned long *bitmap, unsigned int bit) {
50    bitmap[bit / LongBit()] |= 1UL << (bit % LongBit());
51  }
52  static inline int TestBit(unsigned long *bitmap, unsigned int bit) {
53    return static_cast<int>(bitmap[bit / LongBit()] >> (bit % LongBit())) & 1;
54  }
55  static inline int DigitValue(int ch, int base) {
56    if (ch >= '0' && ch <= '9') {
57      if (base >= 10 || ch <= '7') {
58        return ch - '0';
59      }
60    } else if (ch >= 'A' && ch <= 'Z' && base == 16) {
61      return ch - 'A' + 10;
62    } else if (ch >= 'a' && ch <= 'z' && base == 16) {
63      return ch - 'a' + 10;
64    }
65    return -1;
66  }
67  static uintmax_t streamtoumax(FILE *s, int base) {
68    int minus = 0;
69    uintmax_t v = 0;
70    int d, c = 0;
71    for (c = fgetc(s); isascii(c) && isspace(c); c = fgetc(s)) {
72      ;
73    }
74    if (c == '-' || c == '+') {
75      minus = (c == '-');
76      c = fgetc(s);
77    }
78    if (base == 0) {
79      if (c == '0') {
80        c = fgetc(s);
81        if (c == 'x' || c == 'X') {
82          base = 16;
83          c = fgetc(s);
84        } else {
85          base = 8;
86        }
87      }
88    } else if (base == 16) {
89      if (c == '0') {
90        c = fgetc(s);
91        if (c == 'x' || c == 'X') {
92          c = fgetc(s);
93        }
94      }
95    }
96    for (; (c != EOF) && (d = DigitValue(c, base)) >= 0; c = fgetc(s)) {
97      v = v * base + d;
98    }
99    ungetc(c, s);
100    return minus ? -v : v;
101  }
102  static double streamtofloat(FILE *s) {
103    bool minus = false;
104    uint64_t v = 0;
105    int d, c;
106    uint64_t k = 1;
107    uint64_t w = 0;
108    for (c = fgetc(s); isascii(c) && isspace(c); c = fgetc(s)) {
109      ;
110    }
111    if (c == '-' || c == '+') {
112      minus = (c == '-');
113      c = fgetc(s);
114    }
115    for (; c != EOF && (d = DigitValue(c, 10)) >= 0; c = fgetc(s)) {
116      v = v * 10 + d;
117    }
118    if (c == '.') {
119      for (c = fgetc(s); c != EOF && (d = DigitValue(c, 10)) >= 0; c = fgetc(s)) {
120        w = w * 10 + d;
121        k *= 10;
122      }
123    }
124    double f = v + static_cast<double>(w) / k;
125    if (c == 'e' || c == 'E') {
126      c = fgetc(s);
127      int expsign = 1;
128      if (c == '-' || c == '+') {
129        expsign = (c == '-') ? -1 : 1;
130        c = fgetc(s);
131      }
132      int exponent = 0;
133      for (; (c != EOF) && (d = DigitValue(c, 10)) >= 0; c = fgetc(s)) {
134        exponent = exponent * 10 + d;
135      }
136      exponent *= expsign;
137      f *= pow(10.0, static_cast<double>(exponent));
138    }
139    ungetc(c, s);
140    return minus ? -f : f;
141  }
142  static int tvfscanf(FILE *stream, const char *format, va_list ap);
143  int tfscanf(FILE *stream, const char *format, ...) {
144    va_list ap;
145    int rv;
146    va_start(ap, format);
147    rv = tvfscanf(stream, format, ap);
148    va_end(ap);
149    return rv;
150  }
151  static int tvfscanf(FILE *stream, const char *format, va_list ap) {
152    const char *p = format;
153    char ch;
154    int q = 0;
155    uintmax_t val = 0;
156    int rank = RANK_INT; 
157    unsigned int width = UINT_MAX;
158    int base;
159    int flags = 0;
160    enum {
161      ST_NORMAL,      
162      ST_FLAGS,       
163      ST_WIDTH,       
164      ST_MODIFIERS,   
165      ST_MATCH_INIT,  
166      ST_MATCH,       
167      ST_MATCH_RANGE, 
168    } state = ST_NORMAL;
169    char *sarg = nullptr; 
170    enum Bail bail = BAIL_NONE;
171    int converted = 0; 
172    unsigned long
173        matchmap[((1 << CHAR_BIT) + (CHAR_BIT * sizeof(long) - 1)) / (CHAR_BIT * sizeof(long))];
174    int matchinv = 0; 
175    unsigned char range_start = 0;
176    auto start_off = std::ftell(stream);
177    SkipSpace(stream);
178    while ((ch = *p++) && !bail) {
179      switch (state) {
180        case ST_NORMAL:
181          if (ch == '%') {
182            state = ST_FLAGS;
183            flags = 0;
184            rank = RANK_INT;
185            width = UINT_MAX;
186          } else if (isascii(ch) && isspace(ch)) {
187            SkipSpace(stream);
188          } else {
189            if (fgetc(stream) != ch) {
190              bail = BAIL_ERR; 
191            }
192          }
193          break;
194        case ST_FLAGS:
195          if (ch == '*') {
196            flags |= FL_SPLAT;
197          } else if ('0' <= ch && ch <= '9') {
198            width = (ch - '0');
199            state = ST_WIDTH;
200            flags |= FL_WIDTH;
201          } else {
202            state = ST_MODIFIERS;
203            p--; 
204          }
205          break;
206        case ST_WIDTH:
207          if (ch >= '0' && ch <= '9') {
208            width = width * 10 + (ch - '0');
209          } else {
210            state = ST_MODIFIERS;
211            p--; 
212          }
213          break;
214        case ST_MODIFIERS:
215          switch (ch) {
216            case 'h':
217              rank--; 
218              break;
219            case 'l':
220              rank++; 
221              break;
222            case 'j':
223              rank = kIntMaxRank;
224              break;
225            case 'z':
226              rank = kSizeTRank;
227              break;
228            case 't':
229              rank = kPtrDiffRank;
230              break;
231            case 'L':
232            case 'q':
233              rank = RANK_LONGLONG; 
234              break;
235            default:
236              state = ST_NORMAL;   
<span onclick='openModal()' class='match'>237              if (rank < kMinRank) { 
238                rank = kMinRank;
239              } else if (rank > kMaxRank) {
240                rank = kMaxRank;
241              }
</span>242              switch (ch) {
243                case 'P': 
244                case 'p': 
245                  rank = RANK_PTR;
246                  base = 0;
247                  goto scan_int;
248                case 'i': 
249                  base = 0;
250                  goto scan_int;
251                case 'd': 
252                  base = 10;
253                  goto scan_int;
254                case 'o': 
255                  base = 8;
256                  goto scan_int;
257                case 'u': 
258                  base = 10;
259                  goto scan_int;
260                case 'x': 
261                case 'X':
262                  base = 16;
263                  goto scan_int;
264                case 'n': 
265                  val = std::ftell(stream) - start_off;
266                  goto set_integer;
267                scan_int:
268                  q = SkipSpace(stream);
269                  if (q <= 0) {
270                    bail = BAIL_EOF;
271                    break;
272                  }
273                  val = streamtoumax(stream, base);
274                set_integer:
275                  if (!(flags & FL_SPLAT)) {
276                    converted++;
277                    switch (rank) {
278                      case RANK_CHAR:
279                        *va_arg(ap, unsigned char *) = static_cast<unsigned char>(val);
280                        break;
281                      case RANK_SHORT:
282                        *va_arg(ap, unsigned short *) = static_cast<unsigned short>(val);
283                        break;
284                      case RANK_INT:
285                        *va_arg(ap, unsigned int *) = static_cast<unsigned int>(val);
286                        break;
287                      case RANK_LONG:
288                        *va_arg(ap, unsigned long *) = static_cast<unsigned long>(val);
289                        break;
290                      case RANK_LONGLONG:
291                        *va_arg(ap, unsigned long long *) = static_cast<unsigned long long>(val);
292                        break;
293                      case RANK_PTR:
294                        *va_arg(ap, void **) = reinterpret_cast<void *>(static_cast<uintptr_t>(val));
295                        break;
296                    }
297                  }
298                  break;
299                case 'f': 
300                case 'g':
301                case 'G':
302                case 'e':
303                case 'E':
304                  q = SkipSpace(stream);
305                  if (q <= 0) {
306                    bail = BAIL_EOF;
307                    break;
308                  }
309                  {
310                    double fval = streamtofloat(stream);
311                    if (!(flags & FL_SPLAT)) {
312                      if (rank == RANK_INT) {
313                        *va_arg(ap, float *) = static_cast<float>(fval);
314                      } else if (rank == RANK_LONG) {
315                        *va_arg(ap, double *) = static_cast<double>(fval);
316                      }
317                      converted++;
318                    }
319                  }
320                  break;
321                case 'c':                                 
322                  width = (flags & FL_WIDTH) ? width : 1; 
323                  sarg = va_arg(ap, char *);
324                  while (width--) {
325                    if ((q = fgetc(stream)) <= 0) {
326                      bail = BAIL_EOF;
327                      break;
328                    }
329                    if (!(flags & FL_SPLAT)) {
330                      *sarg++ = q;
331                      converted++;
332                    }
333                  }
334                  break;
335                case 's': 
336                {
337                  if (!(flags & FL_SPLAT)) {
338                    sarg = va_arg(ap, char *);
339                  }
340                  unsigned length = 0;
341                  while (width--) {
342                    q = fgetc(stream);
343                    if ((isascii(q) && isspace(q)) || (q <= 0)) {
344                      ungetc(q, stream);
345                      break;
346                    }
347                    if (!(flags & FL_SPLAT)) {
348                      sarg[length] = q;
349                    }
350                    length++;
351                  }
352                  if (length == 0) {
353                    bail = BAIL_EOF;
354                  } else if (!(flags & FL_SPLAT)) {
355                    sarg[length] = '\0'; 
356                    converted++;
357                  }
358                } break;
359                case '[': 
360                  sarg = va_arg(ap, char *);
361                  state = ST_MATCH_INIT;
362                  matchinv = 0;
363                  memset(matchmap, 0, sizeof matchmap);
364                  break;
365                case '%': 
366                  if (fgetc(stream) != '%') {
367                    bail = BAIL_ERR;
368                  }
369                  break;
370                default:           
371                  bail = BAIL_ERR; 
372                  break;
373              }
374          }
375          break;
376        case ST_MATCH_INIT: 
377          if (ch == '^' && !(flags & FL_INV)) {
378            matchinv = 1;
379          } else {
380            SetBit(matchmap, static_cast<unsigned char>(ch));
381            state = ST_MATCH;
382          }
383          break;
384        case ST_MATCH: 
385          if (ch == ']') {
386            goto match_run;
387          } else if (ch == '-') {
388            range_start = static_cast<unsigned char>(ch);
389            state = ST_MATCH_RANGE;
390          } else {
391            SetBit(matchmap, static_cast<unsigned char>(ch));
392          }
393          break;
394        case ST_MATCH_RANGE: 
395          if (ch == ']') {
396            SetBit(matchmap, static_cast<unsigned char>('-'));
397            goto match_run;
398          } else {
399            int i;
400            for (i = range_start; i < (static_cast<unsigned char>(ch)); i++) {
401              SetBit(matchmap, i);
402            }
403            state = ST_MATCH;
404          }
405          break;
406        match_run: 
407          char *oarg = sarg;
408          while (width) {
409            q = fgetc(stream);
410            auto qc = static_cast<unsigned char>(q);
411            if (q <= 0 || !(TestBit(matchmap, qc) ^ matchinv)) {
412              ungetc(q, stream);
413              break;
414            }
415            if (!(flags & FL_SPLAT)) {
416              *sarg = q;
417            }
418            sarg++;
419          }
420          if (oarg == sarg) {
421            bail = (q <= 0) ? BAIL_EOF : BAIL_ERR;
422          } else if (!(flags & FL_SPLAT)) {
423            *sarg = '\0';
424            converted++;
425          }
426          break;
427      }
428    }
429    if (bail == BAIL_EOF && !converted) {
430      converted = -1; 
431    }
432    return converted;
433  }
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-mastertrainer.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include <allheaders.h>
5  #include <cmath>
6  #include <ctime>
7  #include "boxread.h"
8  #include "classify.h"
9  #include "errorcounter.h"
10  #include "featdefs.h"
11  #include "mastertrainer.h"
12  #include "sampleiterator.h"
13  #include "shapeclassifier.h"
14  #include "shapetable.h"
15  #ifndef GRAPHICS_DISABLED
16  #  include "svmnode.h"
17  #endif
18  #include "scanutils.h"
19  namespace tesseract {
20  const int kMinClusteredShapes = 1;
21  const int kMaxUnicharsPerCluster = 2000;
22  const float kFontMergeDistance = 0.025;
23  MasterTrainer::MasterTrainer(NormalizationMode norm_mode, bool shape_analysis,
24                               bool replicate_samples, int debug_level)
25      : norm_mode_(norm_mode),
26        samples_(fontinfo_table_),
27        junk_samples_(fontinfo_table_),
28        verify_samples_(fontinfo_table_),
29        charsetsize_(0),
30        enable_shape_analysis_(shape_analysis),
31        enable_replication_(replicate_samples),
32        fragments_(nullptr),
33        prev_unichar_id_(-1),
34        debug_level_(debug_level) {}
35  MasterTrainer::~MasterTrainer() {
36    delete[] fragments_;
37    for (auto &page_image : page_images_) {
38      page_image.destroy();
39    }
40  }
41  bool MasterTrainer::Serialize(FILE *fp) const {
42    uint32_t value = norm_mode_;
43    if (!tesseract::Serialize(fp, &value)) {
44      return false;
45    }
46    if (!unicharset_.save_to_file(fp)) {
47      return false;
48    }
49    if (!feature_space_.Serialize(fp)) {
50      return false;
51    }
52    if (!samples_.Serialize(fp)) {
53      return false;
54    }
55    if (!junk_samples_.Serialize(fp)) {
56      return false;
57    }
58    if (!verify_samples_.Serialize(fp)) {
59      return false;
60    }
61    if (!master_shapes_.Serialize(fp)) {
62      return false;
63    }
64    if (!flat_shapes_.Serialize(fp)) {
65      return false;
66    }
67    if (!fontinfo_table_.Serialize(fp)) {
68      return false;
69    }
70    if (!tesseract::Serialize(fp, xheights_)) {
71      return false;
72    }
73    return true;
74  }
75  void MasterTrainer::LoadUnicharset(const char *filename) {
76    if (!unicharset_.load_from_file(filename)) {
77      tprintf(
78          "Failed to load unicharset from file %s\n"
79          "Building unicharset for training from scratch...\n",
80          filename);
81      unicharset_.clear();
82      UNICHARSET initialized;
83      unicharset_.AppendOtherUnicharset(initialized);
84    }
85    charsetsize_ = unicharset_.size();
86    delete[] fragments_;
87    fragments_ = new int[charsetsize_];
88    memset(fragments_, 0, sizeof(*fragments_) * charsetsize_);
89    samples_.LoadUnicharset(filename);
90    junk_samples_.LoadUnicharset(filename);
91    verify_samples_.LoadUnicharset(filename);
92  }
93  void MasterTrainer::ReadTrainingSamples(const char *page_name,
94                                          const FEATURE_DEFS_STRUCT &feature_defs,
95                                          bool verification) {
96    char buffer[2048];
97    const int int_feature_type =
98        ShortNameToFeatureType(feature_defs, kIntFeatureType);
99    const int micro_feature_type =
100        ShortNameToFeatureType(feature_defs, kMicroFeatureType);
101    const int cn_feature_type =
102        ShortNameToFeatureType(feature_defs, kCNFeatureType);
103    const int geo_feature_type =
104        ShortNameToFeatureType(feature_defs, kGeoFeatureType);
105    FILE *fp = fopen(page_name, "rb");
106    if (fp == nullptr) {
107      tprintf("Failed to open tr file: %s\n", page_name);
108      return;
109    }
110    tr_filenames_.emplace_back(page_name);
111    while (fgets(buffer, sizeof(buffer), fp) != nullptr) {
112      if (buffer[0] == '\n') {
113        continue;
114      }
115      char *space = strchr(buffer, ' ');
116      if (space == nullptr) {
117        tprintf("Bad format in tr file, reading fontname, unichar\n");
118        continue;
119      }
120      *space++ = '\0';
121      int font_id = GetFontInfoId(buffer);
122      if (font_id < 0) {
123        font_id = 0;
124      }
125      int page_number;
126      std::string unichar;
127      TBOX bounding_box;
128      if (!ParseBoxFileStr(space, &page_number, unichar, &bounding_box)) {
129        tprintf("Bad format in tr file, reading box coords\n");
130        continue;
131      }
132      auto char_desc = ReadCharDescription(feature_defs, fp);
133      auto *sample = new TrainingSample;
134      sample->set_font_id(font_id);
135      sample->set_page_num(page_number + page_images_.size());
136      sample->set_bounding_box(bounding_box);
137      sample->ExtractCharDesc(int_feature_type, micro_feature_type,
138                              cn_feature_type, geo_feature_type, char_desc);
139      AddSample(verification, unichar.c_str(), sample);
140      delete char_desc;
141    }
142    charsetsize_ = unicharset_.size();
143    fclose(fp);
144  }
145  void MasterTrainer::AddSample(bool verification, const char *unichar,
146                                TrainingSample *sample) {
147    if (verification) {
148      verify_samples_.AddSample(unichar, sample);
149      prev_unichar_id_ = -1;
150    } else if (unicharset_.contains_unichar(unichar)) {
151      if (prev_unichar_id_ >= 0) {
152        fragments_[prev_unichar_id_] = -1;
153      }
154      prev_unichar_id_ = samples_.AddSample(unichar, sample);
155      if (flat_shapes_.FindShape(prev_unichar_id_, sample->font_id()) < 0) {
156        flat_shapes_.AddShape(prev_unichar_id_, sample->font_id());
157      }
158    } else {
159      const int junk_id = junk_samples_.AddSample(unichar, sample);
160      if (prev_unichar_id_ >= 0) {
161        CHAR_FRAGMENT *frag = CHAR_FRAGMENT::parse_from_string(unichar);
162        if (frag != nullptr && frag->is_natural()) {
<span onclick='openModal()' class='match'>163          if (fragments_[prev_unichar_id_] == 0) {
164            fragments_[prev_unichar_id_] = junk_id;
165          } else if (fragments_[prev_unichar_id_] != junk_id) {
166            fragments_[prev_unichar_id_] = -1;
167          }
</span>168        }
169        delete frag;
170      }
171      prev_unichar_id_ = -1;
172    }
173  }
174  void MasterTrainer::LoadPageImages(const char *filename) {
175    size_t offset = 0;
176    int page;
177    Image pix;
178    for (page = 0;; page++) {
179      pix = pixReadFromMultipageTiff(filename, &offset);
180      if (!pix) {
181        break;
182      }
183      page_images_.push_back(pix);
184      if (!offset) {
185        break;
186      }
187    }
188    tprintf("Loaded %d page images from %s\n", page, filename);
189  }
190  void MasterTrainer::PostLoadCleanup() {
191    if (debug_level_ > 0) {
192      tprintf("PostLoadCleanup...\n");
193    }
194    if (enable_shape_analysis_) {
195      ReplaceFragmentedSamples();
196    }
197    SampleIterator sample_it;
198    sample_it.Init(nullptr, nullptr, true, &verify_samples_);
199    sample_it.NormalizeSamples();
200    verify_samples_.OrganizeByFontAndClass();
201    samples_.IndexFeatures(feature_space_);
202    samples_.OrganizeByFontAndClass();
203    if (debug_level_ > 0) {
204      tprintf("ComputeCanonicalSamples...\n");
205    }
206    samples_.ComputeCanonicalSamples(feature_map_, debug_level_ > 0);
207  }
208  void MasterTrainer::PreTrainingSetup() {
209    if (debug_level_ > 0) {
210      tprintf("PreTrainingSetup...\n");
211    }
212    samples_.IndexFeatures(feature_space_);
213    samples_.ComputeCanonicalFeatures();
214    if (debug_level_ > 0) {
215      tprintf("ComputeCloudFeatures...\n");
216    }
217    samples_.ComputeCloudFeatures(feature_space_.Size());
218  }
219  void MasterTrainer::SetupMasterShapes() {
220    tprintf("Building master shape table\n");
221    const int num_fonts = samples_.NumFonts();
222    ShapeTable char_shapes_begin_fragment(samples_.unicharset());
223    ShapeTable char_shapes_end_fragment(samples_.unicharset());
224    ShapeTable char_shapes(samples_.unicharset());
225    for (int c = 0; c < samples_.charsetsize(); ++c) {
226      ShapeTable shapes(samples_.unicharset());
227      for (int f = 0; f < num_fonts; ++f) {
228        if (samples_.NumClassSamples(f, c, true) > 0) {
229          shapes.AddShape(c, f);
230        }
231      }
232      ClusterShapes(kMinClusteredShapes, 1, kFontMergeDistance, &shapes);
233      const CHAR_FRAGMENT *fragment = samples_.unicharset().get_fragment(c);
234      if (fragment == nullptr) {
235        char_shapes.AppendMasterShapes(shapes, nullptr);
236      } else if (fragment->is_beginning()) {
237        char_shapes_begin_fragment.AppendMasterShapes(shapes, nullptr);
238      } else if (fragment->is_ending()) {
239        char_shapes_end_fragment.AppendMasterShapes(shapes, nullptr);
240      } else {
241        char_shapes.AppendMasterShapes(shapes, nullptr);
242      }
243    }
244    ClusterShapes(kMinClusteredShapes, kMaxUnicharsPerCluster, kFontMergeDistance,
245                  &char_shapes_begin_fragment);
246    char_shapes.AppendMasterShapes(char_shapes_begin_fragment, nullptr);
247    ClusterShapes(kMinClusteredShapes, kMaxUnicharsPerCluster, kFontMergeDistance,
248                  &char_shapes_end_fragment);
249    char_shapes.AppendMasterShapes(char_shapes_end_fragment, nullptr);
250    ClusterShapes(kMinClusteredShapes, kMaxUnicharsPerCluster, kFontMergeDistance,
251                  &char_shapes);
252    master_shapes_.AppendMasterShapes(char_shapes, nullptr);
253    tprintf("Master shape_table:%s\n", master_shapes_.SummaryStr().c_str());
254  }
255  void MasterTrainer::IncludeJunk() {
256    const UNICHARSET &junk_set = junk_samples_.unicharset();
257    const UNICHARSET &sample_set = samples_.unicharset();
258    int num_junks = junk_samples_.num_samples();
259    tprintf("Moving %d junk samples to master sample set.\n", num_junks);
260    for (int s = 0; s < num_junks; ++s) {
261      TrainingSample *sample = junk_samples_.mutable_sample(s);
262      int junk_id = sample->class_id();
263      const char *junk_utf8 = junk_set.id_to_unichar(junk_id);
264      int sample_id = sample_set.unichar_to_id(junk_utf8);
265      if (sample_id == INVALID_UNICHAR_ID) {
266        sample_id = 0;
267      }
268      sample->set_class_id(sample_id);
269      junk_samples_.extract_sample(s);
270      samples_.AddSample(sample_id, sample);
271    }
272    junk_samples_.DeleteDeadSamples();
273    samples_.OrganizeByFontAndClass();
274  }
275  void MasterTrainer::ReplicateAndRandomizeSamplesIfRequired() {
276    if (enable_replication_) {
277      if (debug_level_ > 0) {
278        tprintf("ReplicateAndRandomize...\n");
279      }
280      verify_samples_.ReplicateAndRandomizeSamples();
281      samples_.ReplicateAndRandomizeSamples();
282      samples_.IndexFeatures(feature_space_);
283    }
284  }
285  bool MasterTrainer::LoadFontInfo(const char *filename) {
286    FILE *fp = fopen(filename, "rb");
287    if (fp == nullptr) {
288      fprintf(stderr, "Failed to load font_properties from %s\n", filename);
289      return false;
290    }
291    int italic, bold, fixed, serif, fraktur;
292    while (!feof(fp)) {
293      FontInfo fontinfo;
294      char *font_name = new char[1024];
295      fontinfo.name = font_name;
296      fontinfo.properties = 0;
297      fontinfo.universal_id = 0;
298      if (tfscanf(fp, "%1024s %i %i %i %i %i\n", font_name, &italic, &bold,
299                  &fixed, &serif, &fraktur) != 6) {
300        delete[] font_name;
301        continue;
302      }
303      fontinfo.properties = (italic << 0) + (bold << 1) + (fixed << 2) +
304                            (serif << 3) + (fraktur << 4);
305      if (fontinfo_table_.get_index(fontinfo) < 0) {
306        fontinfo_table_.push_back(fontinfo);
307      } else {
308        delete[] font_name;
309      }
310    }
311    fclose(fp);
312    return true;
313  }
314  bool MasterTrainer::LoadXHeights(const char *filename) {
315    tprintf("fontinfo table is of size %d\n", fontinfo_table_.size());
316    xheights_.clear();
317    xheights_.resize(fontinfo_table_.size(), -1);
318    if (filename == nullptr) {
319      return true;
320    }
321    FILE *f = fopen(filename, "rb");
322    if (f == nullptr) {
323      fprintf(stderr, "Failed to load font xheights from %s\n", filename);
324      return false;
325    }
326    tprintf("Reading x-heights from %s ...\n", filename);
327    FontInfo fontinfo;
328    fontinfo.properties = 0; 
329    fontinfo.universal_id = 0;
330    char buffer[1024];
331    int xht;
332    int total_xheight = 0;
333    int xheight_count = 0;
334    while (!feof(f)) {
335      if (tfscanf(f, "%1023s %d\n", buffer, &xht) != 2) {
336        continue;
337      }
338      buffer[1023] = '\0';
339      fontinfo.name = buffer;
340      auto fontinfo_id = fontinfo_table_.get_index(fontinfo);
341      if (fontinfo_id < 0) {
342        continue;
343      }
344      xheights_[fontinfo_id] = xht;
345      total_xheight += xht;
346      ++xheight_count;
347    }
348    if (xheight_count == 0) {
349      fprintf(stderr, "No valid xheights in %s!\n", filename);
350      fclose(f);
351      return false;
352    }
353    int mean_xheight = DivRounded(total_xheight, xheight_count);
354    for (size_t i = 0; i < fontinfo_table_.size(); ++i) {
355      if (xheights_[i] < 0) {
356        xheights_[i] = mean_xheight;
357      }
358    }
359    fclose(f);
360    return true;
361  } 
362  bool MasterTrainer::AddSpacingInfo(const char *filename) {
363    FILE *fontinfo_file = fopen(filename, "rb");
364    if (fontinfo_file == nullptr) {
365      return true; 
366    }
367    int fontinfo_id = GetBestMatchingFontInfoId(filename);
368    if (fontinfo_id < 0) {
369      tprintf("No font found matching fontinfo filename %s\n", filename);
370      fclose(fontinfo_file);
371      return false;
372    }
373    tprintf("Reading spacing from %s for font %d...\n", filename, fontinfo_id);
374    int scale = kBlnXHeight / xheights_[fontinfo_id];
375    int num_unichars;
376    char uch[UNICHAR_LEN];
377    char kerned_uch[UNICHAR_LEN];
378    int x_gap, x_gap_before, x_gap_after, num_kerned;
379    ASSERT_HOST(tfscanf(fontinfo_file, "%d\n", &num_unichars) == 1);
380    FontInfo *fi = &fontinfo_table_.at(fontinfo_id);
381    fi->init_spacing(unicharset_.size());
382    FontSpacingInfo *spacing = nullptr;
383    for (int l = 0; l < num_unichars; ++l) {
384      if (tfscanf(fontinfo_file, "%s %d %d %d", uch, &x_gap_before, &x_gap_after,
385                  &num_kerned) != 4) {
386        tprintf("Bad format of font spacing file %s\n", filename);
387        fclose(fontinfo_file);
388        return false;
389      }
390      bool valid = unicharset_.contains_unichar(uch);
391      if (valid) {
392        spacing = new FontSpacingInfo();
393        spacing->x_gap_before = static_cast<int16_t>(x_gap_before * scale);
394        spacing->x_gap_after = static_cast<int16_t>(x_gap_after * scale);
395      }
396      for (int k = 0; k < num_kerned; ++k) {
397        if (tfscanf(fontinfo_file, "%s %d", kerned_uch, &x_gap) != 2) {
398          tprintf("Bad format of font spacing file %s\n", filename);
399          fclose(fontinfo_file);
400          delete spacing;
401          return false;
402        }
403        if (!valid || !unicharset_.contains_unichar(kerned_uch)) {
404          continue;
405        }
406        spacing->kerned_unichar_ids.push_back(
407            unicharset_.unichar_to_id(kerned_uch));
408        spacing->kerned_x_gaps.push_back(static_cast<int16_t>(x_gap * scale));
409      }
410      if (valid) {
411        fi->add_spacing(unicharset_.unichar_to_id(uch), spacing);
412      }
413    }
414    fclose(fontinfo_file);
415    return true;
416  }
417  int MasterTrainer::GetFontInfoId(const char *font_name) {
418    FontInfo fontinfo;
419    fontinfo.name = const_cast<char *>(font_name);
420    fontinfo.properties = 0; 
421    fontinfo.universal_id = 0;
422    return fontinfo_table_.get_index(fontinfo);
423  }
424  int MasterTrainer::GetBestMatchingFontInfoId(const char *filename) {
425    int fontinfo_id = -1;
426    int best_len = 0;
427    for (size_t f = 0; f < fontinfo_table_.size(); ++f) {
428      if (strstr(filename, fontinfo_table_.at(f).name) != nullptr) {
429        int len = strlen(fontinfo_table_.at(f).name);
430        if (len > best_len) {
431          best_len = len;
432          fontinfo_id = f;
433        }
434      }
435    }
436    return fontinfo_id;
437  }
438  void MasterTrainer::SetupFlatShapeTable(ShapeTable *shape_table) {
439    std::vector<int> active_fonts;
440    int num_shapes = flat_shapes_.NumShapes();
441    for (int s = 0; s < num_shapes; ++s) {
442      int font = flat_shapes_.GetShape(s)[0].font_ids[0];
443      unsigned f = 0;
444      for (f = 0; f < active_fonts.size(); ++f) {
445        if (active_fonts[f] == font) {
446          break;
447        }
448      }
449      if (f == active_fonts.size()) {
450        active_fonts.push_back(font);
451      }
452    }
453    int num_fonts = active_fonts.size();
454    for (int f = 0; f < num_fonts; ++f) {
455      for (int s = num_shapes - 1; s >= 0; --s) {
456        int font = flat_shapes_.GetShape(s)[0].font_ids[0];
457        if (font == active_fonts[f]) {
458          shape_table->AddShape(flat_shapes_.GetShape(s));
459        }
460      }
461    }
462  }
463  CLUSTERER *MasterTrainer::SetupForClustering(
464      const ShapeTable &shape_table, const FEATURE_DEFS_STRUCT &feature_defs,
465      int shape_id, int *num_samples) {
466    int desc_index = ShortNameToFeatureType(feature_defs, kMicroFeatureType);
467    int num_params = feature_defs.FeatureDesc[desc_index]->NumParams;
468    ASSERT_HOST(num_params == (int)MicroFeatureParameter::MFCount);
469    CLUSTERER *clusterer = MakeClusterer(
470        num_params, feature_defs.FeatureDesc[desc_index]->ParamDesc);
471    IndexMapBiDi shape_map;
472    shape_map.Init(shape_table.NumShapes(), false);
473    shape_map.SetMap(shape_id, true);
474    shape_map.Setup();
475    std::vector<const TrainingSample *> sample_ptrs;
476    SampleIterator it;
477    it.Init(&shape_map, &shape_table, false, &samples_);
478    for (it.Begin(); !it.AtEnd(); it.Next()) {
479      sample_ptrs.push_back(&it.GetSample());
480    }
481    uint32_t sample_id = 0;
482    for (int i = sample_ptrs.size() - 1; i >= 0; --i) {
483      const TrainingSample *sample = sample_ptrs[i];
484      uint32_t num_features = sample->num_micro_features();
485      for (uint32_t f = 0; f < num_features; ++f) {
486        MakeSample(clusterer, sample->micro_features()[f].data(), sample_id);
487      }
488      ++sample_id;
489    }
490    *num_samples = sample_id;
491    return clusterer;
492  }
493  void MasterTrainer::WriteInttempAndPFFMTable(const UNICHARSET &unicharset,
494                                               const UNICHARSET &shape_set,
495                                               const ShapeTable &shape_table,
496                                               CLASS_STRUCT *float_classes,
497                                               const char *inttemp_file,
498                                               const char *pffmtable_file) {
499    auto *classify = new tesseract::Classify();
500    fontinfo_table_.MoveTo(&classify->get_fontinfo_table());
501    INT_TEMPLATES_STRUCT *int_templates =
502        classify->CreateIntTemplates(float_classes, shape_set);
503    FILE *fp = fopen(inttemp_file, "wb");
504    if (fp == nullptr) {
505      tprintf("Error, failed to open file \"%s\"\n", inttemp_file);
506    } else {
507      classify->WriteIntTemplates(fp, int_templates, shape_set);
508      fclose(fp);
509    }
510    std::vector<uint16_t> shapetable_cutoffs;
511    std::vector<uint16_t> unichar_cutoffs(unicharset.size());
512    for (unsigned i = 0; i < int_templates->NumClasses; ++i) {
513      INT_CLASS_STRUCT *Class = ClassForClassId(int_templates, i);
514      uint16_t max_length = 0;
515      for (int config_id = 0; config_id < Class->NumConfigs; config_id++) {
516        uint16_t length = Class->ConfigLengths[config_id];
517        if (length > max_length) {
518          max_length = Class->ConfigLengths[config_id];
519        }
520        int shape_id = float_classes[i].font_set.at(config_id);
521        const Shape &shape = shape_table.GetShape(shape_id);
522        for (int c = 0; c < shape.size(); ++c) {
523          int unichar_id = shape[c].unichar_id;
524          if (length > unichar_cutoffs[unichar_id]) {
525            unichar_cutoffs[unichar_id] = length;
526          }
527        }
528      }
529      shapetable_cutoffs.push_back(max_length);
530    }
531    fp = fopen(pffmtable_file, "wb");
532    if (fp == nullptr) {
533      tprintf("Error, failed to open file \"%s\"\n", pffmtable_file);
534    } else {
535      tesseract::Serialize(fp, shapetable_cutoffs);
536      for (size_t c = 0; c < unicharset.size(); ++c) {
537        const char *unichar = unicharset.id_to_unichar(c);
538        if (strcmp(unichar, " ") == 0) {
539          unichar = "NULL";
540        }
541        fprintf(fp, "%s %d\n", unichar, unichar_cutoffs[c]);
542      }
543      fclose(fp);
544    }
545    delete int_templates;
546    delete classify;
547  }
548  void MasterTrainer::DebugCanonical(const char *unichar_str1,
549                                     const char *unichar_str2) {
550    int class_id1 = unicharset_.unichar_to_id(unichar_str1);
551    int class_id2 = unicharset_.unichar_to_id(unichar_str2);
552    if (class_id2 == INVALID_UNICHAR_ID) {
553      class_id2 = class_id1;
554    }
555    if (class_id1 == INVALID_UNICHAR_ID) {
556      tprintf("No unicharset entry found for %s\n", unichar_str1);
557      return;
558    } else {
559      tprintf("Font ambiguities for unichar %d = %s and %d = %s\n", class_id1,
560              unichar_str1, class_id2, unichar_str2);
561    }
562    int num_fonts = samples_.NumFonts();
563    const IntFeatureMap &feature_map = feature_map_;
564    tprintf("      ");
565    for (int f = 0; f < num_fonts; ++f) {
566      if (samples_.NumClassSamples(f, class_id2, false) == 0) {
567        continue;
568      }
569      tprintf("%6d", f);
570    }
571    tprintf("\n");
572    for (int f1 = 0; f1 < num_fonts; ++f1) {
573      if (samples_.NumClassSamples(f1, class_id1, false) == 0) {
574        continue;
575      }
576      tprintf("%4d  ", f1);
577      for (int f2 = 0; f2 < num_fonts; ++f2) {
578        if (samples_.NumClassSamples(f2, class_id2, false) == 0) {
579          continue;
580        }
581        float dist =
582            samples_.ClusterDistance(f1, class_id1, f2, class_id2, feature_map);
583        tprintf(" %5.3f", dist);
584      }
585      tprintf("\n");
586    }
587    ShapeTable shapes(unicharset_);
588    for (int f = 0; f < num_fonts; ++f) {
589      if (samples_.NumClassSamples(f, class_id1, true) > 0) {
590        shapes.AddShape(class_id1, f);
591      }
592      if (class_id1 != class_id2 &&
593          samples_.NumClassSamples(f, class_id2, true) > 0) {
594        shapes.AddShape(class_id2, f);
595      }
596    }
597  }
598  #ifndef GRAPHICS_DISABLED
599  void MasterTrainer::DisplaySamples(const char *unichar_str1, int cloud_font,
600                                     const char *unichar_str2,
601                                     int canonical_font) {
602    const IntFeatureMap &feature_map = feature_map_;
603    const IntFeatureSpace &feature_space = feature_map.feature_space();
604    ScrollView *f_window = CreateFeatureSpaceWindow("Features", 100, 500);
605    ClearFeatureSpaceWindow(norm_mode_ == NM_BASELINE ? baseline : character,
606                            f_window);
607    int class_id2 = samples_.unicharset().unichar_to_id(unichar_str2);
608    if (class_id2 != INVALID_UNICHAR_ID && canonical_font >= 0) {
609      const TrainingSample *sample =
610          samples_.GetCanonicalSample(canonical_font, class_id2);
611      for (uint32_t f = 0; f < sample->num_features(); ++f) {
612        RenderIntFeature(f_window, &sample->features()[f], ScrollView::RED);
613      }
614    }
615    int class_id1 = samples_.unicharset().unichar_to_id(unichar_str1);
616    if (class_id1 != INVALID_UNICHAR_ID && cloud_font >= 0) {
617      const BitVector &cloud = samples_.GetCloudFeatures(cloud_font, class_id1);
618      for (int f = 0; f < cloud.size(); ++f) {
619        if (cloud[f]) {
620          INT_FEATURE_STRUCT feature = feature_map.InverseIndexFeature(f);
621          RenderIntFeature(f_window, &feature, ScrollView::GREEN);
622        }
623      }
624    }
625    f_window->Update();
626    ScrollView *s_window = CreateFeatureSpaceWindow("Samples", 100, 500);
627    SVEventType ev_type;
628    do {
629      auto ev = f_window->AwaitEvent(SVET_ANY);
630      ev_type = ev->type;
631      if (ev_type == SVET_CLICK) {
632        int feature_index = feature_space.XYToFeatureIndex(ev->x, ev->y);
633        if (feature_index >= 0) {
634          Shape shape;
635          shape.AddToShape(class_id1, cloud_font);
636          s_window->Clear();
637          samples_.DisplaySamplesWithFeature(feature_index, shape, feature_space,
638                                             ScrollView::GREEN, s_window);
639          s_window->Update();
640        }
641      }
642    } while (ev_type != SVET_DESTROY);
643  }
644  #endif 
645  void MasterTrainer::TestClassifierVOld(bool replicate_samples,
646                                         ShapeClassifier *test_classifier,
647                                         ShapeClassifier *old_classifier) {
648    SampleIterator sample_it;
649    sample_it.Init(nullptr, nullptr, replicate_samples, &samples_);
650    ErrorCounter::DebugNewErrors(test_classifier, old_classifier,
651                                 CT_UNICHAR_TOPN_ERR, fontinfo_table_,
652                                 page_images_, &sample_it);
653  }
654  void MasterTrainer::TestClassifierOnSamples(CountTypes error_mode,
655                                              int report_level,
656                                              bool replicate_samples,
657                                              ShapeClassifier *test_classifier,
658                                              std::string *report_string) {
659    TestClassifier(error_mode, report_level, replicate_samples, &samples_,
660                   test_classifier, report_string);
661  }
662  double MasterTrainer::TestClassifier(CountTypes error_mode, int report_level,
663                                       bool replicate_samples,
664                                       TrainingSampleSet *samples,
665                                       ShapeClassifier *test_classifier,
666                                       std::string *report_string) {
667    SampleIterator sample_it;
668    sample_it.Init(nullptr, nullptr, replicate_samples, samples);
669    if (report_level > 0) {
670      int num_samples = 0;
671      for (sample_it.Begin(); !sample_it.AtEnd(); sample_it.Next()) {
672        ++num_samples;
673      }
674      tprintf("Iterator has charset size of %d/%d, %d shapes, %d samples\n",
675              sample_it.SparseCharsetSize(), sample_it.CompactCharsetSize(),
676              test_classifier->GetShapeTable()->NumShapes(), num_samples);
677      tprintf("Testing %sREPLICATED:\n", replicate_samples ? "" : "NON-");
678    }
679    double unichar_error = 0.0;
680    ErrorCounter::ComputeErrorRate(test_classifier, report_level, error_mode,
681                                   fontinfo_table_, page_images_, &sample_it,
682                                   &unichar_error, nullptr, report_string);
683    return unichar_error;
684  }
685  float MasterTrainer::ShapeDistance(const ShapeTable &shapes, int s1, int s2) {
686    const IntFeatureMap &feature_map = feature_map_;
687    const Shape &shape1 = shapes.GetShape(s1);
688    const Shape &shape2 = shapes.GetShape(s2);
689    int num_chars1 = shape1.size();
690    int num_chars2 = shape2.size();
691    float dist_sum = 0.0f;
692    int dist_count = 0;
693    if (num_chars1 > 1 || num_chars2 > 1) {
694      for (int c1 = 0; c1 < num_chars1; ++c1) {
695        for (int c2 = 0; c2 < num_chars2; ++c2) {
696          dist_sum +=
697              samples_.UnicharDistance(shape1[c1], shape2[c2], true, feature_map);
698          ++dist_count;
699        }
700      }
701    } else {
702      dist_sum =
703          samples_.UnicharDistance(shape1[0], shape2[0], false, feature_map);
704      ++dist_count;
705    }
706    return dist_sum / dist_count;
707  }
708  void MasterTrainer::ReplaceFragmentedSamples() {
709    if (fragments_ == nullptr) {
710      return;
711    }
712    int num_samples = samples_.num_samples();
713    for (int s = 0; s < num_samples; ++s) {
714      TrainingSample *sample = samples_.mutable_sample(s);
715      if (fragments_[sample->class_id()] > 0) {
716        samples_.KillSample(sample);
717      }
718    }
719    samples_.DeleteDeadSamples();
720    const UNICHARSET &frag_set = junk_samples_.unicharset();
721  #if 0
722    bool* good_junk = new bool[frag_set.size()];
723    memset(good_junk, 0, sizeof(*good_junk) * frag_set.size());
724    for (int dead_ch = 1; dead_ch < unicharset_.size(); ++dead_ch) {
725      int frag_ch = fragments_[dead_ch];
726      if (frag_ch <= 0) continue;
727      const char* frag_utf8 = frag_set.id_to_unichar(frag_ch);
728      CHAR_FRAGMENT* frag = CHAR_FRAGMENT::parse_from_string(frag_utf8);
729      for (int part = 0; part < frag->get_total(); ++part) {
730        frag->set_pos(part);
731        int good_ch = frag_set.unichar_to_id(frag->to_string().c_str());
732        if (good_ch != INVALID_UNICHAR_ID)
733          good_junk[good_ch] = true;  
734      }
735      delete frag;
736    }
737  #endif
738    int num_junks = junk_samples_.num_samples();
739    for (int s = 0; s < num_junks; ++s) {
740      TrainingSample *sample = junk_samples_.mutable_sample(s);
741      int junk_id = sample->class_id();
742      const char *frag_utf8 = frag_set.id_to_unichar(junk_id);
743      CHAR_FRAGMENT *frag = CHAR_FRAGMENT::parse_from_string(frag_utf8);
744      if (frag != nullptr && frag->is_natural()) {
745        junk_samples_.extract_sample(s);
746        samples_.AddSample(frag_set.id_to_unichar(junk_id), sample);
747      }
748      delete frag;
749    }
750    junk_samples_.DeleteDeadSamples();
751    junk_samples_.OrganizeByFontAndClass();
752    samples_.OrganizeByFontAndClass();
753    unicharset_.clear();
754    unicharset_.AppendOtherUnicharset(samples_.unicharset());
755    delete[] fragments_;
756    fragments_ = nullptr;
757  }
758  const float kInfiniteDist = 999.0f;
759  void MasterTrainer::ClusterShapes(int min_shapes, int max_shape_unichars,
760                                    float max_dist, ShapeTable *shapes) {
761    int num_shapes = shapes->NumShapes();
762    int max_merges = num_shapes - min_shapes;
763    auto *shape_dists = new std::vector<ShapeDist>[num_shapes];
764    float min_dist = kInfiniteDist;
765    int min_s1 = 0;
766    int min_s2 = 0;
767    tprintf("Computing shape distances...");
768    for (int s1 = 0; s1 < num_shapes; ++s1) {
769      for (int s2 = s1 + 1; s2 < num_shapes; ++s2) {
770        ShapeDist dist(s1, s2, ShapeDistance(*shapes, s1, s2));
771        shape_dists[s1].push_back(dist);
772        if (dist.distance < min_dist) {
773          min_dist = dist.distance;
774          min_s1 = s1;
775          min_s2 = s2;
776        }
777      }
778      tprintf(" %d", s1);
779    }
780    tprintf("\n");
781    int num_merged = 0;
782    while (num_merged < max_merges && min_dist < max_dist) {
783      tprintf("Distance = %f: ", min_dist);
784      int num_unichars = shapes->MergedUnicharCount(min_s1, min_s2);
785      shape_dists[min_s1][min_s2 - min_s1 - 1].distance = kInfiniteDist;
786      if (num_unichars > max_shape_unichars) {
787        tprintf("Merge of %d and %d with %d would exceed max of %d unichars\n",
788                min_s1, min_s2, num_unichars, max_shape_unichars);
789      } else {
790        shapes->MergeShapes(min_s1, min_s2);
791        shape_dists[min_s2].clear();
792        ++num_merged;
793        for (int s = 0; s < min_s1; ++s) {
794          if (!shape_dists[s].empty()) {
795            shape_dists[s][min_s1 - s - 1].distance =
796                ShapeDistance(*shapes, s, min_s1);
797            shape_dists[s][min_s2 - s - 1].distance = kInfiniteDist;
798          }
799        }
800        for (int s2 = min_s1 + 1; s2 < num_shapes; ++s2) {
801          if (shape_dists[min_s1][s2 - min_s1 - 1].distance < kInfiniteDist) {
802            shape_dists[min_s1][s2 - min_s1 - 1].distance =
803                ShapeDistance(*shapes, min_s1, s2);
804          }
805        }
806        for (int s = min_s1 + 1; s < min_s2; ++s) {
807          if (!shape_dists[s].empty()) {
808            shape_dists[s][min_s2 - s - 1].distance = kInfiniteDist;
809          }
810        }
811      }
812      min_dist = kInfiniteDist;
813      for (int s1 = 0; s1 < num_shapes; ++s1) {
814        for (unsigned i = 0; i < shape_dists[s1].size(); ++i) {
815          if (shape_dists[s1][i].distance < min_dist) {
816            min_dist = shape_dists[s1][i].distance;
817            min_s1 = s1;
818            min_s2 = s1 + 1 + i;
819          }
820        }
821      }
822    }
823    tprintf("Stopped with %d merged, min dist %f\n", num_merged, min_dist);
824    delete[] shape_dists;
825    if (debug_level_ > 1) {
826      for (int s1 = 0; s1 < num_shapes; ++s1) {
827        if (shapes->MasterDestinationIndex(s1) == s1) {
828          tprintf("Master shape:%s\n", shapes->DebugStr(s1).c_str());
829        }
830      }
831    }
832  }
833  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-scanutils.cpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-mastertrainer.cpp</div>
                <div class="column column_space"><pre><code>237              if (rank < kMinRank) { 
238                rank = kMinRank;
239              } else if (rank > kMaxRank) {
240                rank = kMaxRank;
241              }
</pre></code></div>
                <div class="column column_space"><pre><code>163          if (fragments_[prev_unichar_id_] == 0) {
164            fragments_[prev_unichar_id_] = junk_id;
165          } else if (fragments_[prev_unichar_id_] != junk_id) {
166            fragments_[prev_unichar_id_] = -1;
167          }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    