
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 2.8615348232233653%, Tokens: 9</h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-tesseractclass.h</h3>
            <pre><code>1  #ifndef TESSERACT_CCMAIN_TESSERACTCLASS_H_
2  #define TESSERACT_CCMAIN_TESSERACTCLASS_H_
3  #ifdef HAVE_CONFIG_H
4  #  include "config_auto.h" 
5  #endif
6  #include "control.h"               
7  #include "debugpixa.h"             
8  #include "devanagari_processing.h" 
9  #ifndef DISABLED_LEGACY_ENGINE
10  #  include "docqual.h" 
11  #endif
12  #include "genericvector.h"   
13  #include "pageres.h"         
14  #include "params.h"          
15  #include "points.h"          
16  #include "ratngs.h"          
17  #include "tessdatamanager.h" 
18  #include "textord.h"         
19  #include "wordrec.h"         
20  #include <tesseract/publictypes.h> 
21  #include <tesseract/unichar.h>     
22  #include <allheaders.h> 
23  #include <cstdint> 
24  #include <cstdio>  
25  namespace tesseract {
26  class BLOCK_LIST;
27  class ETEXT_DESC;
28  struct OSResults;
29  class PAGE_RES;
30  class PAGE_RES_IT;
31  class ROW;
32  class SVMenuNode;
33  class TBOX;
34  class TO_BLOCK_LIST;
35  class WERD;
36  class WERD_CHOICE;
37  class WERD_RES;
38  class ColumnFinder;
39  class DocumentData;
40  #ifndef DISABLED_LEGACY_ENGINE
41  class EquationDetect;
42  #endif 
43  class ImageData;
44  class LSTMRecognizer;
45  class Tesseract;
46  struct TesseractStats {
47    TesseractStats()
48        : adaption_word_number(0)
49        , doc_blob_quality(0)
50        , doc_outline_errs(0)
51        , doc_char_quality(0)
52        , good_char_count(0)
53        , doc_good_char_quality(0)
54        , word_count(0)
55        , dict_words(0)
56        , tilde_crunch_written(false)
57        , last_char_was_newline(true)
58        , last_char_was_tilde(false)
59        , write_results_empty_block(true) {}
60    int32_t adaption_word_number;
61    int16_t doc_blob_quality;
62    int16_t doc_outline_errs;
63    int16_t doc_char_quality;
64    int16_t good_char_count;
65    int16_t doc_good_char_quality;
66    int32_t word_count;    
67    int32_t dict_words;    
68    std::string dump_words_str; 
69    bool tilde_crunch_written;
70    bool last_char_was_newline;
71    bool last_char_was_tilde;
72    bool write_results_empty_block;
73  };
74  struct WordData {
75    WordData() : word(nullptr), row(nullptr), block(nullptr), prev_word(nullptr) {}
76    explicit WordData(const PAGE_RES_IT &page_res_it)
77        : word(page_res_it.word())
78        , row(page_res_it.row()->row)
79        , block(page_res_it.block()->block)
80        , prev_word(nullptr) {}
81    WordData(BLOCK *block_in, ROW *row_in, WERD_RES *word_res)
82        : word(word_res), row(row_in), block(block_in), prev_word(nullptr) {}
83    WERD_RES *word;
84    ROW *row;
85    BLOCK *block;
86    WordData *prev_word;
87    PointerVector<WERD_RES> lang_words;
88  };
89  using WordRecognizer = void (Tesseract::*)(const WordData &, WERD_RES **,
90                                             PointerVector<WERD_RES> *);
91  class TESS_API Tesseract : public Wordrec {
92  public:
93    Tesseract();
94    ~Tesseract() override;
95    Dict &getDict() override;
96    void Clear();
97    void ResetAdaptiveClassifier();
98    void ResetDocumentDictionary();
99  #ifndef DISABLED_LEGACY_ENGINE
100    void SetEquationDetect(EquationDetect *detector);
101  #endif 
102    const FCOORD &reskew() const {
103      return reskew_;
104    }
105    Image *mutable_pix_binary() {
106      pix_binary_.destroy();
107      return &pix_binary_;
108    }
109    Image pix_binary() const {
110      return pix_binary_;
111    }
112    Image pix_grey() const {
113      return pix_grey_;
114    }
115    void set_pix_grey(Image grey_pix) {
116      pix_grey_.destroy();
117      pix_grey_ = grey_pix;
118    }
119    Image pix_original() const {
120      return pix_original_;
121    }
122    void set_pix_original(Image original_pix) {
123      pix_original_.destroy();
124      pix_original_ = original_pix;
125      for (auto &lang : sub_langs_) {
126        lang->set_pix_original(original_pix ? original_pix.clone() : nullptr);
127      }
128    }
129    Image BestPix() const {
130      if (pixGetWidth(pix_original_) == ImageWidth()) {
131        return pix_original_;
132      } else if (pix_grey_ != nullptr) {
133        return pix_grey_;
134      } else {
135        return pix_binary_;
136      }
137    }
138    void set_pix_thresholds(Image thresholds) {
139      pix_thresholds_.destroy();
140      pix_thresholds_ = thresholds;
141    }
142    int source_resolution() const {
143      return source_resolution_;
144    }
145    void set_source_resolution(int ppi) {
146      source_resolution_ = ppi;
147    }
148    int ImageWidth() const {
149      return pixGetWidth(pix_binary_);
150    }
151    int ImageHeight() const {
152      return pixGetHeight(pix_binary_);
153    }
154    Image scaled_color() const {
155      return scaled_color_;
156    }
157    int scaled_factor() const {
158      return scaled_factor_;
159    }
160    void SetScaledColor(int factor, Image color) {
161      scaled_factor_ = factor;
162      scaled_color_ = color;
163    }
164    const Textord &textord() const {
165      return textord_;
166    }
167    Textord *mutable_textord() {
168      return &textord_;
169    }
170    bool right_to_left() const {
171      return right_to_left_;
172    }
173    int num_sub_langs() const {
174      return sub_langs_.size();
175    }
176    Tesseract *get_sub_lang(int index) const {
177      return sub_langs_[index];
178    }
179    bool AnyTessLang() const {
180      if (tessedit_ocr_engine_mode != OEM_LSTM_ONLY) {
181        return true;
182      }
183      for (auto &lang : sub_langs_) {
184        if (lang->tessedit_ocr_engine_mode != OEM_LSTM_ONLY) {
185          return true;
186        }
187      }
188      return false;
189    }
190    bool AnyLSTMLang() const {
191      if (tessedit_ocr_engine_mode != OEM_TESSERACT_ONLY) {
192        return true;
193      }
194      for (auto &lang : sub_langs_) {
195        if (lang->tessedit_ocr_engine_mode != OEM_TESSERACT_ONLY) {
196          return true;
197        }
198      }
199      return false;
200    }
201    void SetBlackAndWhitelist();
202    void PrepareForPageseg();
203    void PrepareForTessOCR(BLOCK_LIST *block_list, Tesseract *osd_tess, OSResults *osr);
204    int SegmentPage(const char *input_file, BLOCK_LIST *blocks, Tesseract *osd_tess, OSResults *osr);
205    void SetupWordScripts(BLOCK_LIST *blocks);
206    int AutoPageSeg(PageSegMode pageseg_mode, BLOCK_LIST *blocks, TO_BLOCK_LIST *to_blocks,
207                    BLOBNBOX_LIST *diacritic_blobs, Tesseract *osd_tess, OSResults *osr);
208    ColumnFinder *SetupPageSegAndDetectOrientation(PageSegMode pageseg_mode, BLOCK_LIST *blocks,
209                                                   Tesseract *osd_tess, OSResults *osr,
210                                                   TO_BLOCK_LIST *to_blocks, Image *photo_mask_pix,
211                                                   Image *music_mask_pix);
212    void PrerecAllWordsPar(const std::vector<WordData> &words);
213    bool TrainLineRecognizer(const char *input_imagename, const std::string &output_basename,
214                             BLOCK_LIST *block_list);
215    void TrainFromBoxes(const std::vector<TBOX> &boxes, const std::vector<std::string> &texts,
216                        BLOCK_LIST *block_list, DocumentData *training_data);
217    ImageData *GetLineData(const TBOX &line_box, const std::vector<TBOX> &boxes,
218                           const std::vector<std::string> &texts, int start_box, int end_box,
219                           const BLOCK &block);
220    ImageData *GetRectImage(const TBOX &box, const BLOCK &block, int padding,
221                            TBOX *revised_box) const;
222    void LSTMRecognizeWord(const BLOCK &block, ROW *row, WERD_RES *word,
223                           PointerVector<WERD_RES> *words);
224    void SearchWords(PointerVector<WERD_RES> *words);
225    bool ProcessTargetWord(const TBOX &word_box, const TBOX &target_word_box, const char *word_config,
226                           int pass);
227    void SetupAllWordsPassN(int pass_n, const TBOX *target_word_box, const char *word_config,
228                            PAGE_RES *page_res, std::vector<WordData> *words);
229    void SetupWordPassN(int pass_n, WordData *word);
230    bool RecogAllWordsPassN(int pass_n, ETEXT_DESC *monitor, PAGE_RES_IT *pr_it,
231                            std::vector<WordData> *words);
232    bool recog_all_words(PAGE_RES *page_res, ETEXT_DESC *monitor, const TBOX *target_word_box,
233                         const char *word_config, int dopasses);
234    void rejection_passes(PAGE_RES *page_res, ETEXT_DESC *monitor, const TBOX *target_word_box,
<span onclick='openModal()' class='match'>235                          const char *word_config);
236    void bigram_correction_pass(PAGE_RES *page_res);
237    void blamer_pass(PAGE_RES *page_res);
238    void script_pos_pass(PAGE_RES *page_res);
239    int RetryWithLanguage(const WordData &word_data, WordRecognizer recognizer, bool debug,
240                          WERD_RES **in_word, PointerVector<WERD_RES> *best_words);
241    bool ReassignDiacritics(int pass, PAGE_RES_IT *pr_it, bool *make_next_word_fuzzy);
242    void AssignDiacriticsToOverlappingBlobs(const std::vector<C_OUTLINE *> &outlines, int pass,
243                                            WERD *real_word, PAGE_RES_IT *pr_it,
244                                            std::vector<bool> *word_wanted,
245                                            std::vector<bool> *overlapped_any_blob,
246                                            std::vector<C_BLOB *> *target_blobs);
247    void AssignDiacriticsToNewBlobs(const std::vector<C_OUTLINE *> &outlines, int pass,
</span>248                                    WERD *real_word, PAGE_RES_IT *pr_it,
249                                    std::vector<bool> *word_wanted,
250                                    std::vector<C_BLOB *> *target_blobs);
251    bool SelectGoodDiacriticOutlines(int pass, float certainty_threshold, PAGE_RES_IT *pr_it,
252                                     C_BLOB *blob, const std::vector<C_OUTLINE *> &outlines,
253                                     int num_outlines, std::vector<bool> *ok_outlines);
254    float ClassifyBlobPlusOutlines(const std::vector<bool> &ok_outlines,
255                                   const std::vector<C_OUTLINE *> &outlines, int pass_n,
256                                   PAGE_RES_IT *pr_it, C_BLOB *blob, std::string &best_str);
257    float ClassifyBlobAsWord(int pass_n, PAGE_RES_IT *pr_it, C_BLOB *blob, std::string &best_str,
258                             float *c2);
259    void classify_word_and_language(int pass_n, PAGE_RES_IT *pr_it, WordData *word_data);
260    void classify_word_pass1(const WordData &word_data, WERD_RES **in_word,
261                             PointerVector<WERD_RES> *out_words);
262    void recog_pseudo_word(PAGE_RES *page_res, 
263                           TBOX &selection_box);
264    void fix_rep_char(PAGE_RES_IT *page_res_it);
265    ACCEPTABLE_WERD_TYPE acceptable_word_string(const UNICHARSET &char_set, const char *s,
266                                                const char *lengths);
267    void match_word_pass_n(int pass_n, WERD_RES *word, ROW *row, BLOCK *block);
268    void classify_word_pass2(const WordData &word_data, WERD_RES **in_word,
269                             PointerVector<WERD_RES> *out_words);
270    void ReportXhtFixResult(bool accept_new_word, float new_x_ht, WERD_RES *word, WERD_RES *new_word);
271    bool RunOldFixXht(WERD_RES *word, BLOCK *block, ROW *row);
272    bool TrainedXheightFix(WERD_RES *word, BLOCK *block, ROW *row);
273    bool TestNewNormalization(int original_misfits, float baseline_shift, float new_x_ht,
274                              WERD_RES *word, BLOCK *block, ROW *row);
275    bool recog_interactive(PAGE_RES_IT *pr_it);
276    void set_word_fonts(WERD_RES *word);
277    void font_recognition_pass(PAGE_RES *page_res);
278    void dictionary_correction_pass(PAGE_RES *page_res);
279    bool check_debug_pt(WERD_RES *word, int location);
280    bool SubAndSuperscriptFix(WERD_RES *word_res);
281    void GetSubAndSuperscriptCandidates(const WERD_RES *word, int *num_rebuilt_leading,
282                                        ScriptPos *leading_pos, float *leading_certainty,
283                                        int *num_rebuilt_trailing, ScriptPos *trailing_pos,
284                                        float *trailing_certainty, float *avg_certainty,
285                                        float *unlikely_threshold);
286    WERD_RES *TrySuperscriptSplits(int num_chopped_leading, float leading_certainty,
287                                   ScriptPos leading_pos, int num_chopped_trailing,
288                                   float trailing_certainty, ScriptPos trailing_pos, WERD_RES *word,
289                                   bool *is_good, int *retry_leading, int *retry_trailing);
290    bool BelievableSuperscript(bool debug, const WERD_RES &word, float certainty_threshold,
291                               int *left_ok, int *right_ok) const;
292    void output_pass(PAGE_RES_IT &page_res_it, const TBOX *target_word_box);
293    void write_results(PAGE_RES_IT &page_res_it, 
294                       char newline_type,        
295                       bool force_eol            
296    );
297    void set_unlv_suspects(WERD_RES *word);
298    UNICHAR_ID get_rep_char(WERD_RES *word); 
299    bool acceptable_number_string(const char *s, const char *lengths);
300    int16_t count_alphanums(const WERD_CHOICE &word);
301    int16_t count_alphas(const WERD_CHOICE &word);
302    void read_config_file(const char *filename, SetParamConstraint constraint);
303    int init_tesseract(const std::string &arg0, const std::string &textbase,
304                       const std::string &language, OcrEngineMode oem, char **configs,
305                       int configs_size, const std::vector<std::string> *vars_vec,
306                       const std::vector<std::string> *vars_values, bool set_only_non_debug_params,
307                       TessdataManager *mgr);
308    int init_tesseract(const std::string &datapath, const std::string &language, OcrEngineMode oem) {
309      TessdataManager mgr;
310      return init_tesseract(datapath, {}, language, oem, nullptr, 0, nullptr, nullptr, false, &mgr);
311    }
312    int init_tesseract_internal(const std::string &arg0, const std::string &textbase,
313                                const std::string &language, OcrEngineMode oem, char **configs,
314                                int configs_size, const std::vector<std::string> *vars_vec,
315                                const std::vector<std::string> *vars_values,
316                                bool set_only_non_debug_params, TessdataManager *mgr);
317    void SetupUniversalFontIds();
318    void recognize_page(std::string &image_name);
319    void end_tesseract();
320    bool init_tesseract_lang_data(const std::string &arg0,
321                                  const std::string &language, OcrEngineMode oem, char **configs,
322                                  int configs_size, const std::vector<std::string> *vars_vec,
323                                  const std::vector<std::string> *vars_values,
324                                  bool set_only_non_debug_params, TessdataManager *mgr);
325    void ParseLanguageString(const std::string &lang_str, std::vector<std::string> *to_load,
326                             std::vector<std::string> *not_to_load);
327    SVMenuNode *build_menu_new();
328  #ifndef GRAPHICS_DISABLED
329    void pgeditor_main(int width, int height, PAGE_RES *page_res);
330    void process_image_event( 
331        const SVEvent &event);
332    bool process_cmd_win_event( 
333        int32_t cmd_event,      
334        char *new_value         
335    );
336  #endif 
337    void debug_word(PAGE_RES *page_res, const TBOX &selection_box);
338    void do_re_display(bool (tesseract::Tesseract::*word_painter)(PAGE_RES_IT *pr_it));
339    bool word_display(PAGE_RES_IT *pr_it);
340    bool word_bln_display(PAGE_RES_IT *pr_it);
341    bool word_blank_and_set_display(PAGE_RES_IT *pr_its);
342    bool word_set_display(PAGE_RES_IT *pr_it);
343    bool word_dumper(PAGE_RES_IT *pr_it);
344    void blob_feature_display(PAGE_RES *page_res, const TBOX &selection_box);
345    void make_reject_map(WERD_RES *word, ROW *row, int16_t pass);
346    bool one_ell_conflict(WERD_RES *word_res, bool update_map);
347    int16_t first_alphanum_index(const char *word, const char *word_lengths);
348    int16_t first_alphanum_offset(const char *word, const char *word_lengths);
349    int16_t alpha_count(const char *word, const char *word_lengths);
350    bool word_contains_non_1_digit(const char *word, const char *word_lengths);
351    void dont_allow_1Il(WERD_RES *word);
352    int16_t count_alphanums( 
353        WERD_RES *word);
354    void flip_0O(WERD_RES *word);
355    bool non_0_digit(const UNICHARSET &ch_set, UNICHAR_ID unichar_id);
356    bool non_O_upper(const UNICHARSET &ch_set, UNICHAR_ID unichar_id);
357    bool repeated_nonalphanum_wd(WERD_RES *word, ROW *row);
358    void nn_match_word( 
359        WERD_RES *word, ROW *row);
360    void nn_recover_rejects(WERD_RES *word, ROW *row);
361    void set_done( 
362        WERD_RES *word, int16_t pass);
363    int16_t safe_dict_word(const WERD_RES *werd_res); 
364    void flip_hyphens(WERD_RES *word);
365    void reject_I_1_L(WERD_RES *word);
366    void reject_edge_blobs(WERD_RES *word);
367    void reject_mostly_rejects(WERD_RES *word);
368    bool word_adaptable( 
369        WERD_RES *word, uint16_t mode);
370    void recog_word_recursive(WERD_RES *word);
371    void recog_word(WERD_RES *word);
372    void split_and_recog_word(WERD_RES *word);
373    void split_word(WERD_RES *word, unsigned split_pt, WERD_RES **right_piece,
374                    BlamerBundle **orig_blamer_bundle) const;
375    void join_words(WERD_RES *word, WERD_RES *word2, BlamerBundle *orig_bb) const;
376    bool digit_or_numeric_punct(WERD_RES *word, int char_position);
377    int16_t eval_word_spacing(WERD_RES_LIST &word_res_list);
378    void match_current_words(WERD_RES_LIST &words, ROW *row, BLOCK *block);
379    int16_t fp_eval_word_spacing(WERD_RES_LIST &word_res_list);
380    void fix_noisy_space_list(WERD_RES_LIST &best_perm, ROW *row, BLOCK *block);
381    void fix_fuzzy_space_list(WERD_RES_LIST &best_perm, ROW *row, BLOCK *block);
382    void fix_sp_fp_word(WERD_RES_IT &word_res_it, ROW *row, BLOCK *block);
383    void fix_fuzzy_spaces(   
384        ETEXT_DESC *monitor, 
385        int32_t word_count,  
386        PAGE_RES *page_res);
387    void dump_words(WERD_RES_LIST &perm, int16_t score, int16_t mode, bool improved);
388    bool fixspace_thinks_word_done(WERD_RES *word);
389    int16_t worst_noise_blob(WERD_RES *word_res, float *worst_noise_score);
390    float blob_noise_score(TBLOB *blob);
391    void break_noisiest_blob_word(WERD_RES_LIST &words);
392  #ifndef DISABLED_LEGACY_ENGINE
393    GARBAGE_LEVEL garbage_word(WERD_RES *word, bool ok_dict_word);
394    bool potential_word_crunch(WERD_RES *word, GARBAGE_LEVEL garbage_level, bool ok_dict_word);
395  #endif
396    void tilde_crunch(PAGE_RES_IT &page_res_it);
397    void unrej_good_quality_words( 
398        PAGE_RES_IT &page_res_it);
399    void doc_and_block_rejection( 
400        PAGE_RES_IT &page_res_it, bool good_quality_doc);
401    void quality_based_rejection(PAGE_RES_IT &page_res_it, bool good_quality_doc);
402    void convert_bad_unlv_chs(WERD_RES *word_res);
403    void tilde_delete(PAGE_RES_IT &page_res_it);
404    int16_t word_blob_quality(WERD_RES *word);
405    void word_char_quality(WERD_RES *word, int16_t *match_count, int16_t *accepted_match_count);
406    void unrej_good_chs(WERD_RES *word);
407    int16_t count_outline_errs(char c, int16_t outline_count);
408    int16_t word_outline_errs(WERD_RES *word);
409  #ifndef DISABLED_LEGACY_ENGINE
410    bool terrible_word_crunch(WERD_RES *word, GARBAGE_LEVEL garbage_level);
411  #endif
412    CRUNCH_MODE word_deletable(WERD_RES *word, int16_t &delete_mode);
413    int16_t failure_count(WERD_RES *word);
414    bool noise_outlines(TWERD *word);
415    void process_selected_words(PAGE_RES *page_res, 
416                                TBOX &selection_box,
417                                bool (tesseract::Tesseract::*word_processor)(PAGE_RES_IT *pr_it));
418    void tess_add_doc_word(      
419        WERD_CHOICE *word_choice 
420    );
421    void tess_segment_pass_n(int pass_n, WERD_RES *word);
422    bool tess_acceptable_word(WERD_RES *word);
423    PAGE_RES *ApplyBoxes(const char *filename, bool find_segmentation, BLOCK_LIST *block_list);
424    void PreenXHeights(BLOCK_LIST *block_list);
425    PAGE_RES *SetupApplyBoxes(const std::vector<TBOX> &boxes, BLOCK_LIST *block_list);
426    void MaximallyChopWord(const std::vector<TBOX> &boxes, BLOCK *block, ROW *row,
427                           WERD_RES *word_res);
428    bool ResegmentCharBox(PAGE_RES *page_res, const TBOX *prev_box, const TBOX &box,
429                          const TBOX *next_box, const char *correct_text);
430    bool ResegmentWordBox(BLOCK_LIST *block_list, const TBOX &box, const TBOX *next_box,
431                          const char *correct_text);
432    void ReSegmentByClassification(PAGE_RES *page_res);
433    bool ConvertStringToUnichars(const char *utf8, std::vector<UNICHAR_ID> *class_ids);
434    bool FindSegmentation(const std::vector<UNICHAR_ID> &target_text, WERD_RES *word_res);
435    void SearchForText(const std::vector<BLOB_CHOICE_LIST *> *choices, int choices_pos,
436                       unsigned choices_length, const std::vector<UNICHAR_ID> &target_text,
437                       unsigned text_index, float rating, std::vector<int> *segmentation,
438                       float *best_rating, std::vector<int> *best_segmentation);
439    void TidyUp(PAGE_RES *page_res);
440    void ReportFailedBox(int boxfile_lineno, TBOX box, const char *box_ch, const char *err_msg);
441    void CorrectClassifyWords(PAGE_RES *page_res);
442    void ApplyBoxTraining(const std::string &fontname, PAGE_RES *page_res);
443    int CountMisfitTops(WERD_RES *word_res);
444    float ComputeCompatibleXheight(WERD_RES *word_res, float *baseline_shift);
445    BOOL_VAR_H(tessedit_resegment_from_boxes);
446    BOOL_VAR_H(tessedit_resegment_from_line_boxes);
447    BOOL_VAR_H(tessedit_train_from_boxes);
448    BOOL_VAR_H(tessedit_make_boxes_from_boxes);
449    BOOL_VAR_H(tessedit_train_line_recognizer);
450    BOOL_VAR_H(tessedit_dump_pageseg_images);
451    BOOL_VAR_H(tessedit_do_invert);
452    double_VAR_H(invert_threshold);
453    INT_VAR_H(tessedit_pageseg_mode);
454    INT_VAR_H(thresholding_method);
455    BOOL_VAR_H(thresholding_debug);
456    double_VAR_H(thresholding_window_size);
457    double_VAR_H(thresholding_kfactor);
458    double_VAR_H(thresholding_tile_size);
459    double_VAR_H(thresholding_smooth_kernel_size);
460    double_VAR_H(thresholding_score_fraction);
461    INT_VAR_H(tessedit_ocr_engine_mode);
462    STRING_VAR_H(tessedit_char_blacklist);
463    STRING_VAR_H(tessedit_char_whitelist);
464    STRING_VAR_H(tessedit_char_unblacklist);
465    BOOL_VAR_H(tessedit_ambigs_training);
466    INT_VAR_H(pageseg_devanagari_split_strategy);
467    INT_VAR_H(ocr_devanagari_split_strategy);
468    STRING_VAR_H(tessedit_write_params_to_file);
469    BOOL_VAR_H(tessedit_adaption_debug);
470    INT_VAR_H(bidi_debug);
471    INT_VAR_H(applybox_debug);
472    INT_VAR_H(applybox_page);
473    STRING_VAR_H(applybox_exposure_pattern);
474    BOOL_VAR_H(applybox_learn_chars_and_char_frags_mode);
475    BOOL_VAR_H(applybox_learn_ngrams_mode);
476    BOOL_VAR_H(tessedit_display_outwords);
477    BOOL_VAR_H(tessedit_dump_choices);
478    BOOL_VAR_H(tessedit_timing_debug);
479    BOOL_VAR_H(tessedit_fix_fuzzy_spaces);
480    BOOL_VAR_H(tessedit_unrej_any_wd);
481    BOOL_VAR_H(tessedit_fix_hyphens);
482    BOOL_VAR_H(tessedit_enable_doc_dict);
483    BOOL_VAR_H(tessedit_debug_fonts);
484    INT_VAR_H(tessedit_font_id);
485    BOOL_VAR_H(tessedit_debug_block_rejection);
486    BOOL_VAR_H(tessedit_enable_bigram_correction);
487    BOOL_VAR_H(tessedit_enable_dict_correction);
488    INT_VAR_H(tessedit_bigram_debug);
489    BOOL_VAR_H(enable_noise_removal);
490    INT_VAR_H(debug_noise_removal);
491    double_VAR_H(noise_cert_basechar);
492    double_VAR_H(noise_cert_disjoint);
493    double_VAR_H(noise_cert_punc);
494    double_VAR_H(noise_cert_factor);
495    INT_VAR_H(noise_maxperblob);
496    INT_VAR_H(noise_maxperword);
497    INT_VAR_H(debug_x_ht_level);
498    STRING_VAR_H(chs_leading_punct);
499    STRING_VAR_H(chs_trailing_punct1);
500    STRING_VAR_H(chs_trailing_punct2);
501    double_VAR_H(quality_rej_pc);
502    double_VAR_H(quality_blob_pc);
503    double_VAR_H(quality_outline_pc);
504    double_VAR_H(quality_char_pc);
505    INT_VAR_H(quality_min_initial_alphas_reqd);
506    INT_VAR_H(tessedit_tess_adaption_mode);
507    BOOL_VAR_H(tessedit_minimal_rej_pass1);
508    BOOL_VAR_H(tessedit_test_adaption);
509    BOOL_VAR_H(test_pt);
510    double_VAR_H(test_pt_x);
511    double_VAR_H(test_pt_y);
512    INT_VAR_H(multilang_debug_level);
513    INT_VAR_H(paragraph_debug_level);
514    BOOL_VAR_H(paragraph_text_based);
515    BOOL_VAR_H(lstm_use_matrix);
516    STRING_VAR_H(outlines_odd);
517    STRING_VAR_H(outlines_2);
518    BOOL_VAR_H(tessedit_good_quality_unrej);
519    BOOL_VAR_H(tessedit_use_reject_spaces);
520    double_VAR_H(tessedit_reject_doc_percent);
521    double_VAR_H(tessedit_reject_block_percent);
522    double_VAR_H(tessedit_reject_row_percent);
523    double_VAR_H(tessedit_whole_wd_rej_row_percent);
524    BOOL_VAR_H(tessedit_preserve_blk_rej_perfect_wds);
525    BOOL_VAR_H(tessedit_preserve_row_rej_perfect_wds);
526    BOOL_VAR_H(tessedit_dont_blkrej_good_wds);
527    BOOL_VAR_H(tessedit_dont_rowrej_good_wds);
528    INT_VAR_H(tessedit_preserve_min_wd_len);
529    BOOL_VAR_H(tessedit_row_rej_good_docs);
530    double_VAR_H(tessedit_good_doc_still_rowrej_wd);
531    BOOL_VAR_H(tessedit_reject_bad_qual_wds);
532    BOOL_VAR_H(tessedit_debug_doc_rejection);
533    BOOL_VAR_H(tessedit_debug_quality_metrics);
534    BOOL_VAR_H(bland_unrej);
535    double_VAR_H(quality_rowrej_pc);
536    BOOL_VAR_H(unlv_tilde_crunching);
537    BOOL_VAR_H(hocr_font_info);
538    BOOL_VAR_H(hocr_char_boxes);
539    BOOL_VAR_H(crunch_early_merge_tess_fails);
540    BOOL_VAR_H(crunch_early_convert_bad_unlv_chs);
541    double_VAR_H(crunch_terrible_rating);
542    BOOL_VAR_H(crunch_terrible_garbage);
543    double_VAR_H(crunch_poor_garbage_cert);
544    double_VAR_H(crunch_poor_garbage_rate);
545    double_VAR_H(crunch_pot_poor_rate);
546    double_VAR_H(crunch_pot_poor_cert);
547    double_VAR_H(crunch_del_rating);
548    double_VAR_H(crunch_del_cert);
549    double_VAR_H(crunch_del_min_ht);
550    double_VAR_H(crunch_del_max_ht);
551    double_VAR_H(crunch_del_min_width);
552    double_VAR_H(crunch_del_high_word);
553    double_VAR_H(crunch_del_low_word);
554    double_VAR_H(crunch_small_outlines_size);
555    INT_VAR_H(crunch_rating_max);
556    INT_VAR_H(crunch_pot_indicators);
557    BOOL_VAR_H(crunch_leave_ok_strings);
558    BOOL_VAR_H(crunch_accept_ok);
559    BOOL_VAR_H(crunch_leave_accept_strings);
560    BOOL_VAR_H(crunch_include_numerals);
561    INT_VAR_H(crunch_leave_lc_strings);
562    INT_VAR_H(crunch_leave_uc_strings);
563    INT_VAR_H(crunch_long_repetitions);
564    INT_VAR_H(crunch_debug);
565    INT_VAR_H(fixsp_non_noise_limit);
566    double_VAR_H(fixsp_small_outlines_size);
567    BOOL_VAR_H(tessedit_prefer_joined_punct);
568    INT_VAR_H(fixsp_done_mode);
569    INT_VAR_H(debug_fix_space_level);
570    STRING_VAR_H(numeric_punctuation);
571    INT_VAR_H(x_ht_acceptance_tolerance);
572    INT_VAR_H(x_ht_min_change);
573    INT_VAR_H(superscript_debug);
574    double_VAR_H(superscript_worse_certainty);
575    double_VAR_H(superscript_bettered_certainty);
576    double_VAR_H(superscript_scaledown_ratio);
577    double_VAR_H(subscript_max_y_top);
578    double_VAR_H(superscript_min_y_bottom);
579    BOOL_VAR_H(tessedit_write_block_separators);
580    BOOL_VAR_H(tessedit_write_rep_codes);
581    BOOL_VAR_H(tessedit_write_unlv);
582    BOOL_VAR_H(tessedit_create_txt);
583    BOOL_VAR_H(tessedit_create_hocr);
584    BOOL_VAR_H(tessedit_create_alto);
585    BOOL_VAR_H(tessedit_create_lstmbox);
586    BOOL_VAR_H(tessedit_create_tsv);
587    BOOL_VAR_H(tessedit_create_wordstrbox);
588    BOOL_VAR_H(tessedit_create_pdf);
589    BOOL_VAR_H(textonly_pdf);
590    INT_VAR_H(jpg_quality);
591    INT_VAR_H(user_defined_dpi);
592    INT_VAR_H(min_characters_to_try);
593    STRING_VAR_H(unrecognised_char);
594    INT_VAR_H(suspect_level);
595    INT_VAR_H(suspect_short_words);
596    BOOL_VAR_H(suspect_constrain_1Il);
597    double_VAR_H(suspect_rating_per_ch);
598    double_VAR_H(suspect_accept_rating);
599    BOOL_VAR_H(tessedit_minimal_rejection);
600    BOOL_VAR_H(tessedit_zero_rejection);
601    BOOL_VAR_H(tessedit_word_for_word);
602    BOOL_VAR_H(tessedit_zero_kelvin_rejection);
603    INT_VAR_H(tessedit_reject_mode);
604    BOOL_VAR_H(tessedit_rejection_debug);
605    BOOL_VAR_H(tessedit_flip_0O);
606    double_VAR_H(tessedit_lower_flip_hyphen);
607    double_VAR_H(tessedit_upper_flip_hyphen);
608    BOOL_VAR_H(rej_trust_doc_dawg);
609    BOOL_VAR_H(rej_1Il_use_dict_word);
610    BOOL_VAR_H(rej_1Il_trust_permuter_type);
611    BOOL_VAR_H(rej_use_tess_accepted);
612    BOOL_VAR_H(rej_use_tess_blanks);
613    BOOL_VAR_H(rej_use_good_perm);
614    BOOL_VAR_H(rej_use_sensible_wd);
615    BOOL_VAR_H(rej_alphas_in_number_perm);
616    double_VAR_H(rej_whole_of_mostly_reject_word_fract);
617    INT_VAR_H(tessedit_image_border);
618    STRING_VAR_H(ok_repeated_ch_non_alphanum_wds);
619    STRING_VAR_H(conflict_set_I_l_1);
620    INT_VAR_H(min_sane_x_ht_pixels);
621    BOOL_VAR_H(tessedit_create_boxfile);
622    INT_VAR_H(tessedit_page_number);
623    BOOL_VAR_H(tessedit_write_images);
624    BOOL_VAR_H(interactive_display_mode);
625    STRING_VAR_H(file_type);
626    BOOL_VAR_H(tessedit_override_permuter);
627    STRING_VAR_H(tessedit_load_sublangs);
628    BOOL_VAR_H(tessedit_use_primary_params_model);
629    double_VAR_H(min_orientation_margin);
630    BOOL_VAR_H(textord_tabfind_show_vlines);
631    BOOL_VAR_H(textord_use_cjk_fp_model);
632    BOOL_VAR_H(poly_allow_detailed_fx);
633    BOOL_VAR_H(tessedit_init_config_only);
634  #ifndef DISABLED_LEGACY_ENGINE
635    BOOL_VAR_H(textord_equation_detect);
636  #endif 
637    BOOL_VAR_H(textord_tabfind_vertical_text);
638    BOOL_VAR_H(textord_tabfind_force_vertical_text);
639    double_VAR_H(textord_tabfind_vertical_text_ratio);
640    double_VAR_H(textord_tabfind_aligned_gap_fraction);
641    INT_VAR_H(tessedit_parallelize);
642    BOOL_VAR_H(preserve_interword_spaces);
643    STRING_VAR_H(page_separator);
644    INT_VAR_H(lstm_choice_mode);
645    INT_VAR_H(lstm_choice_iterations);
646    double_VAR_H(lstm_rating_coefficient);
647    BOOL_VAR_H(pageseg_apply_music_mask);
648    FILE *init_recog_training(const char *filename);
649    void recog_training_segmented(const char *filename, PAGE_RES *page_res,
650                                  volatile ETEXT_DESC *monitor, FILE *output_file);
651    void ambigs_classify_and_output(const char *label, PAGE_RES_IT *pr_it, FILE *output_file);
652  private:
653    const char *backup_config_file_;
654    std::string word_config_;
655    Image pix_binary_;
656    Image pix_grey_;
657    Image pix_original_;
658    Image pix_thresholds_;
659    DebugPixa pixa_debug_;
660    int source_resolution_;
661    ShiroRekhaSplitter splitter_;
662    Textord textord_;
663    bool right_to_left_;
664    Image scaled_color_;
665    int scaled_factor_;
666    FCOORD deskew_;
667    FCOORD reskew_;
668    TesseractStats stats_;
669    std::vector<Tesseract *> sub_langs_;
670    Tesseract *most_recently_used_;
671    int font_table_size_;
672  #ifndef DISABLED_LEGACY_ENGINE
673    EquationDetect *equ_detect_;
674  #endif 
675    LSTMRecognizer *lstm_recognizer_;
676    int train_line_page_num_;
677  };
678  } 
679  #endif 
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-network.h</h3>
            <pre><code>1  #ifndef NETWORK_H
2  #define NETWORK_H
3  template <class TNodeData>
4  class TNodeNet {
5  public:
6    typedef TNodeData TNodeDat;
7    typedef TNodeNet<TNodeData> TNet;
8    typedef TPt<TNet> PNet;
9  public:
10    class TNode {
11    private:
12      TInt Id;
13      TNodeData NodeDat;
14      TIntV InNIdV, OutNIdV;
15    public:
16      TNode() : Id(-1), NodeDat(), InNIdV(), OutNIdV() { }
17      TNode(const int& NId) : Id(NId), NodeDat(), InNIdV(), OutNIdV() { }
18      TNode(const int& NId, const TNodeData& NodeData) : Id(NId), NodeDat(NodeData), InNIdV(), OutNIdV() { }
19      TNode(const TNode& Node) : Id(Node.Id), NodeDat(Node.NodeDat), InNIdV(Node.InNIdV), OutNIdV(Node.OutNIdV) { }
20      TNode(TSIn& SIn) : Id(SIn), NodeDat(SIn), InNIdV(SIn), OutNIdV(SIn) { }
21      void Save(TSOut& SOut) const { Id.Save(SOut);  NodeDat.Save(SOut);  InNIdV.Save(SOut);  OutNIdV.Save(SOut); }
22      int GetId() const { return Id; }
23      int GetDeg() const { return GetInDeg() + GetOutDeg(); }
24      int GetInDeg() const { return InNIdV.Len(); }
25      int GetOutDeg() const { return OutNIdV.Len(); }
26      const TNodeData& GetDat() const { return NodeDat; }
27      TNodeData& GetDat() { return NodeDat; }
28      int GetInNId(const int& NodeN) const { return InNIdV[NodeN]; }
29      int GetOutNId(const int& NodeN) const { return OutNIdV[NodeN]; }
30      int GetNbrNId(const int& NodeN) const { return NodeN<GetOutDeg() ? GetOutNId(NodeN):GetInNId(NodeN-GetOutDeg()); }
31      bool IsInNId(const int& NId) const { return InNIdV.SearchBin(NId) != -1; }
32      bool IsOutNId(const int& NId) const { return OutNIdV.SearchBin(NId) != -1; }
33      bool IsNbrNId(const int& NId) const { return IsOutNId(NId) || IsInNId(NId); }
34      void LoadShM(TShMIn& MStream) {
35        Id = TInt(MStream);
36        NodeDat = TNodeData(MStream);
37        InNIdV.LoadShM(MStream);
38        OutNIdV.LoadShM(MStream);
39      }
40      bool operator < (const TNode& Node) const { return NodeDat < Node.NodeDat; }
41      friend class TNodeNet<TNodeData>;
42    };
43    class TNodeI {
44    private:
45      typedef typename THash<TInt, TNode>::TIter THashIter;
46      THashIter NodeHI;
47      TNodeNet *Net;
48    public:
49      TNodeI() : NodeHI(), Net(NULL) { }
50      TNodeI(const THashIter& NodeHIter, const TNodeNet* NetPt) : NodeHI(NodeHIter), Net((TNodeNet *) NetPt) { }
51      TNodeI(const TNodeI& NodeI) : NodeHI(NodeI.NodeHI), Net(NodeI.Net) { }
52      TNodeI& operator = (const TNodeI& NodeI) { NodeHI=NodeI.NodeHI; Net=NodeI.Net; return *this; }
53      TNodeI& operator++ (int) { NodeHI++;  return *this; }
54      bool operator < (const TNodeI& NodeI) const { return NodeHI < NodeI.NodeHI; }
55      bool operator == (const TNodeI& NodeI) const { return NodeHI == NodeI.NodeHI; }
56      int GetId() const { return NodeHI.GetDat().GetId(); }
57      int GetDeg() const { return NodeHI.GetDat().GetDeg(); }
58      int GetInDeg() const { return NodeHI.GetDat().GetInDeg(); }
59      int GetOutDeg() const { return NodeHI.GetDat().GetOutDeg(); }
60      int GetInNId(const int& NodeN) const { return NodeHI.GetDat().GetInNId(NodeN); }
61      int GetOutNId(const int& NodeN) const { return NodeHI.GetDat().GetOutNId(NodeN); }
62      int GetNbrNId(const int& NodeN) const { return NodeHI.GetDat().GetNbrNId(NodeN); }
63      bool IsInNId(const int& NId) const { return NodeHI.GetDat().IsInNId(NId); }
64      bool IsOutNId(const int& NId) const { return NodeHI.GetDat().IsOutNId(NId); }
65      bool IsNbrNId(const int& NId) const { return IsOutNId(NId) || IsInNId(NId); }
66      const TNodeData& operator () () const { return NodeHI.GetDat().NodeDat; }
67      TNodeData& operator () () { return NodeHI.GetDat().GetDat(); }
68      const TNodeData& GetDat() const { return NodeHI.GetDat().GetDat(); }
69      TNodeData& GetDat() { return NodeHI.GetDat().GetDat(); }
70      const TNodeData& GetInNDat(const int& NodeN) const { return Net->GetNDat(GetInNId(NodeN)); }
71      TNodeData& GetInNDat(const int& NodeN) { return Net->GetNDat(GetInNId(NodeN)); }
72      const TNodeData& GetOutNDat(const int& NodeN) const { return Net->GetNDat(GetOutNId(NodeN)); }
73      TNodeData& GetOutNDat(const int& NodeN) { return Net->GetNDat(GetOutNId(NodeN)); }
74      const TNodeData& GetNbrNDat(const int& NodeN) const { return Net->GetNDat(GetNbrNId(NodeN)); }
75      TNodeData& GetNbrNDat(const int& NodeN) { return Net->GetNDat(GetNbrNId(NodeN)); }
76      friend class TNodeNet<TNodeData>;
77    };
78    class TEdgeI {
79    private:
80      TNodeI CurNode, EndNode;
81      int CurEdge;
82    public:
83      TEdgeI() : CurNode(), EndNode(), CurEdge(0) { }
84      TEdgeI(const TNodeI& NodeI, const TNodeI& EndNodeI, const int& EdgeN=0) : CurNode(NodeI), EndNode(EndNodeI), CurEdge(EdgeN) { }
85      TEdgeI(const TEdgeI& EdgeI) : CurNode(EdgeI.CurNode), EndNode(EdgeI.EndNode), CurEdge(EdgeI.CurEdge) { }
86      TEdgeI& operator = (const TEdgeI& EdgeI) { if (this!=&EdgeI) { CurNode=EdgeI.CurNode;  EndNode=EdgeI.EndNode;  CurEdge=EdgeI.CurEdge; }  return *this; }
87      TEdgeI& operator++ (int) { CurEdge++; if (CurEdge >= CurNode.GetOutDeg()) { CurEdge=0;  CurNode++;
88        while (CurNode < EndNode && CurNode.GetOutDeg()==0) { CurNode++; } }  return *this; }
89      bool operator < (const TEdgeI& EdgeI) const { return CurNode<EdgeI.CurNode || (CurNode==EdgeI.CurNode && CurEdge<EdgeI.CurEdge); }
90      bool operator == (const TEdgeI& EdgeI) const { return CurNode == EdgeI.CurNode && CurEdge == EdgeI.CurEdge; }
91      int GetId() const { return -1; }
92      int GetSrcNId() const { return CurNode.GetId(); }
93      int GetDstNId() const { return CurNode.GetOutNId(CurEdge); }
94      const TNodeData& GetSrcNDat() const { return CurNode.GetDat(); }
95      TNodeData& GetDstNDat() { return CurNode.GetOutNDat(CurEdge); }
96      friend class TNodeNet<TNodeData>;
97    };
98  protected:
99    TNode& GetNode(const int& NId) { return NodeH.GetDat(NId); }
100  protected:
101    TCRef CRef;
102    TInt MxNId;
103    THash<TInt, TNode> NodeH;
104  private:
105    class TNodeFunctor {
106    public:
107      TNodeFunctor() {}
108      void operator() (TNode* n, TShMIn& ShMIn) { n->LoadShM(ShMIn);}
109    };
110  private:
111    void LoadNetworkShM(TShMIn& ShMIn) {
112      MxNId = TInt(ShMIn);
113      TNodeFunctor f;
114      NodeH.LoadShM(ShMIn, f);
115    }
116  public:
117    TNodeNet() : CRef(), MxNId(0), NodeH() { }
118    explicit TNodeNet(const int& Nodes, const int& Edges) : MxNId(0) { Reserve(Nodes, Edges); }
119    TNodeNet(const TNodeNet& NodeNet) : MxNId(NodeNet.MxNId), NodeH(NodeNet.NodeH) { }
120    TNodeNet(TSIn& SIn) : MxNId(SIn), NodeH(SIn) { }
121    virtual ~TNodeNet() { }
122    virtual void Save(TSOut& SOut) const { MxNId.Save(SOut);  NodeH.Save(SOut); SOut.Flush(); }
123    static PNet New() { return PNet(new TNodeNet()); }
124    static PNet Load(TSIn& SIn) { return PNet(new TNodeNet(SIn)); }
125    static PNet LoadShM(TShMIn& ShMIn) {
126      TNodeNet* Network = new TNodeNet();
127      Network->LoadNetworkShM(ShMIn);
128      return PNet(Network);
129    }
130    bool HasFlag(const TGraphFlag& Flag) const;
131    TNodeNet& operator = (const TNodeNet& NodeNet) {
132      if (this!=&NodeNet) { NodeH=NodeNet.NodeH;  MxNId=NodeNet.MxNId; }  return *this; }
133    int GetNodes() const { return NodeH.Len(); }
134    int AddNode(int NId = -1);
135    int AddNodeUnchecked(int NId = -1);
136    int AddNode(int NId, const TNodeData& NodeDat);
137    int AddNode(const TNodeI& NodeI) { return AddNode(NodeI.GetId(), NodeI.GetDat()); }
138    virtual void DelNode(const int& NId);
139    void DelNode(const TNode& NodeI) { DelNode(NodeI.GetId()); }
140    bool IsNode(const int& NId) const { return NodeH.IsKey(NId); }
141    TNodeI BegNI() const { return TNodeI(NodeH.BegI(), this); }
142    TNodeI EndNI() const { return TNodeI(NodeH.EndI(), this); }
143    TNodeI GetNI(const int& NId) const { return TNodeI(NodeH.GetI(NId), this); }
144    const TNode& GetNode(const int& NId) const { return NodeH.GetDat(NId); }
145    void SetNDat(const int& NId, const TNodeData& NodeDat);
146    TNodeData& GetNDat(const int& NId) { return NodeH.GetDat(NId).NodeDat; }
147    const TNodeData& GetNDat(const int& NId) const { return NodeH.GetDat(NId).NodeDat; }
148    int GetMxNId() const { return MxNId; }
149    int GetEdges() const;
150    int AddEdge(const int& SrcNId, const int& DstNId);
151    int AddEdge(const TEdgeI& EdgeI) { return AddEdge(EdgeI.GetSrcNId(), EdgeI.GetDstNId()); }
152    void DelEdge(const int& SrcNId, const int& DstNId, const bool& IsDir = true);
153    bool IsEdge(const int& SrcNId, const int& DstNId, const bool& IsDir = true) const;
154    TEdgeI BegEI() const { TNodeI NI=BegNI();  while(NI<EndNI() && NI.GetOutDeg()==0) NI++;  return TEdgeI(NI, EndNI()); }
155    TEdgeI EndEI() const { return TEdgeI(EndNI(), EndNI()); }
156    TEdgeI GetEI(const int& EId) const;
157    TEdgeI GetEI(const int& SrcNId, const int& DstNId) const;
158    int GetRndNId(TRnd& Rnd=TInt::Rnd) { return NodeH.GetKey(NodeH.GetRndKeyId(Rnd, 0.8)); }
159    TNodeI GetRndNI(TRnd& Rnd=TInt::Rnd) { return GetNI(GetRndNId(Rnd)); }
160    void GetNIdV(TIntV& NIdV) const;
161    bool Empty() const { return GetNodes()==0; }
162    void Clr(const bool& DoDel=true, const bool& ResetDat=true) {
163      MxNId = 0;  NodeH.Clr(DoDel, -1, ResetDat); }
164    void Reserve(const int& Nodes, const int& Edges) { if (Nodes>0) { NodeH.Gen(Nodes/2); } }
165    void SortNIdById(const bool& Asc=true) { NodeH.SortByKey(Asc); }
166    void SortNIdByDat(const bool& Asc=true) { NodeH.SortByDat(Asc); }
167    void Defrag(const bool& OnlyNodeLinks=false);
168    bool IsOk(const bool& ThrowExcept=true) const;
169    friend class TPt<TNodeNet<TNodeData> >;
170  };
171  namespace TSnap {
172  template <class TNodeData> struct IsDirected<TNodeNet<TNodeData> > { enum { Val = 1 }; };
173  template <class TNodeData> struct IsNodeDat<TNodeNet<TNodeData> > { enum { Val = 1 }; };
174  }
175  template <class TNodeData>
176  bool TNodeNet<TNodeData>::HasFlag(const TGraphFlag& Flag) const {
177    return HasGraphFlag(typename TNet, Flag);
178  }
179  template <class TNodeData>
180  int TNodeNet<TNodeData>::AddNode(int NId) {
181    if (NId == -1) {
182      NId = MxNId;  MxNId++;
183    } else {
184      IAssertR(!IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
185      MxNId = TMath::Mx(NId+1, MxNId());
186    }
187    NodeH.AddDat(NId, TNode(NId));
188    return NId;
189  }
190  template <class TNodeData>
191  int TNodeNet<TNodeData>::AddNodeUnchecked(int NId) {
192    if (NId == -1) {
193      NId = MxNId;  MxNId++;
194    } else {
195      if (IsNode(NId)) { return -1;}
196      MxNId = TMath::Mx(NId+1, MxNId());
197    }
198    NodeH.AddDat(NId, TNode(NId));
199    return NId;
200  }
201  template <class TNodeData>
202  int TNodeNet<TNodeData>::AddNode(int NId, const TNodeData& NodeDat) {
203    if (NId == -1) {
204      NId = MxNId;  MxNId++;
205    } else {
206      IAssertR(!IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
207      MxNId = TMath::Mx(NId+1, MxNId());
208    }
209    NodeH.AddDat(NId, TNode(NId, NodeDat));
210    return NId;
211  }
212  template <class TNodeData>
213  void TNodeNet<TNodeData>::DelNode(const int& NId) {
214    { TNode& Node = GetNode(NId);
215    for (int e = 0; e < Node.GetOutDeg(); e++) {
216    const int nbr = Node.GetOutNId(e);
217    if (nbr == NId) { continue; }
218      TNode& N = GetNode(nbr);
219      int n = N.InNIdV.SearchBin(NId);
220      if (n!= -1) { N.InNIdV.Del(n); }
221    }
222    for (int e = 0; e < Node.GetInDeg(); e++) {
223    const int nbr = Node.GetInNId(e);
224    if (nbr == NId) { continue; }
225      TNode& N = GetNode(nbr);
226      int n = N.OutNIdV.SearchBin(NId);
227      if (n!= -1) { N.OutNIdV.Del(n); }
228    } }
229    NodeH.DelKey(NId);
230  }
231  template <class TNodeData>
232  void TNodeNet<TNodeData>::SetNDat(const int& NId, const TNodeData& NodeDat) {
233    IAssertR(IsNode(NId), TStr::Fmt("NodeId %d does not exist.", NId).CStr());
234    NodeH.GetDat(NId).NodeDat = NodeDat;
235  }
236  template <class TNodeData>
237  int TNodeNet<TNodeData>::GetEdges() const {
238    int edges=0;
239    for (int N=NodeH.FFirstKeyId(); NodeH.FNextKeyId(N);) {
240      edges+=NodeH[N].GetOutDeg(); }
241    return edges;
242  }
243  template <class TNodeData>
244  int TNodeNet<TNodeData>::AddEdge(const int& SrcNId, const int& DstNId) {
245    IAssertR(IsNode(SrcNId) && IsNode(DstNId), TStr::Fmt("%d or %d not a node.", SrcNId, DstNId).CStr());
246    if (IsEdge(SrcNId, DstNId)) { return -2; }
247    GetNode(SrcNId).OutNIdV.AddSorted(DstNId);
248    GetNode(DstNId).InNIdV.AddSorted(SrcNId);
249    return -1; 
250  }
251  template <class TNodeData>
252  void TNodeNet<TNodeData>::DelEdge(const int& SrcNId, const int& DstNId, const bool& IsDir) {
253    IAssertR(IsNode(SrcNId) && IsNode(DstNId), TStr::Fmt("%d or %d not a node.", SrcNId, DstNId).CStr());
254    GetNode(SrcNId).OutNIdV.DelIfIn(DstNId);
255    GetNode(DstNId).InNIdV.DelIfIn(SrcNId);
256    if (! IsDir) {
257      GetNode(DstNId).OutNIdV.DelIfIn(SrcNId);
258      GetNode(SrcNId).InNIdV.DelIfIn(DstNId);
259    }
260  }
261  template <class TNodeData>
262  bool TNodeNet<TNodeData>::IsEdge(const int& SrcNId, const int& DstNId, const bool& IsDir) const {
263    if (! IsNode(SrcNId) || ! IsNode(DstNId)) { return false; }
264    if (IsDir) { return GetNode(SrcNId).IsOutNId(DstNId); }
265    else { return GetNode(SrcNId).IsOutNId(DstNId) || GetNode(DstNId).IsOutNId(SrcNId); }
266  }
267  template <class TNodeData>
268  void TNodeNet<TNodeData>::GetNIdV(TIntV& NIdV) const {
269    NIdV.Reserve(GetNodes(), 0);
270    for (int N=NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
271      NIdV.Add(NodeH.GetKey(N)); }
272  }
273  template <class TNodeData>
274  typename TNodeNet<TNodeData>::TEdgeI  TNodeNet<TNodeData>::GetEI(const int& SrcNId, const int& DstNId) const {
275    const TNodeI SrcNI = GetNI(SrcNId);
276    const int NodeN = SrcNI.NodeHI.GetDat().OutNIdV.SearchBin(DstNId);
277    if (NodeN == -1) { return EndEI(); }
278    return TEdgeI(SrcNI, EndNI(), NodeN);
279  }
280  template <class TNodeData>
281  void TNodeNet<TNodeData>::Defrag(const bool& OnlyNodeLinks) {
282    for (int n = NodeH.FFirstKeyId(); NodeH.FNextKeyId(n); ) {
283      TNode& Node = NodeH[n];
284      Node.InNIdV.Pack();  Node.OutNIdV.Pack();
285    }
286    if (! OnlyNodeLinks && ! NodeH.IsKeyIdEqKeyN()) {
287      NodeH.Defrag(); }
288  }
289  template <class TNodeData>
290  bool TNodeNet<TNodeData>::IsOk(const bool& ThrowExcept) const {
291    bool RetVal = true;
292    for (int N = NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
293      const TNode& Node = NodeH[N];
294      if (! Node.OutNIdV.IsSorted()) {
295        const TStr Msg = TStr::Fmt("Out-neighbor list of node %d is not sorted.", Node.GetId());
296        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
297      }
298      if (! Node.InNIdV.IsSorted()) {
299        const TStr Msg = TStr::Fmt("In-neighbor list of node %d is not sorted.", Node.GetId());
300        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
301      }
302      int prevNId = -1;
303      for (int e = 0; e < Node.GetOutDeg(); e++) {
304        if (! IsNode(Node.GetOutNId(e))) {
305          const TStr Msg = TStr::Fmt("Out-edge %d --> %d: node %d does not exist.",
306            Node.GetId(), Node.GetOutNId(e), Node.GetOutNId(e));
307          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
308        }
309        if (e > 0 && prevNId == Node.GetOutNId(e)) {
310          const TStr Msg = TStr::Fmt("Node %d has duplidate out-edge %d --> %d.",
311            Node.GetId(), Node.GetId(), Node.GetOutNId(e));
312          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
313        }
314        prevNId = Node.GetOutNId(e);
315      }
316      prevNId = -1;
317      for (int e = 0; e < Node.GetInDeg(); e++) {
318        if (! IsNode(Node.GetInNId(e))) {
319          const TStr Msg = TStr::Fmt("In-edge %d <-- %d: node %d does not exist.",
320            Node.GetId(), Node.GetInNId(e), Node.GetInNId(e));
321          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
322        }
323        if (e > 0 && prevNId == Node.GetInNId(e)) {
324          const TStr Msg = TStr::Fmt("Node %d has duplidate in-edge %d <-- %d.",
325            Node.GetId(), Node.GetId(), Node.GetInNId(e));
326          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
327        }
328        prevNId = Node.GetInNId(e);
329      }
330    }
331    return RetVal;
332  }
333  typedef TNodeNet<TInt> TIntNNet;
334  typedef TPt<TIntNNet> PIntNNet;
335  typedef TNodeNet<TFlt> TFltNNet;
336  typedef TPt<TFltNNet> PFltNNet;
337  typedef TNodeNet<TStr> TStrNNet;
338  typedef TPt<TStrNNet> PStrNNet;
339  template <class TNodeData, class TEdgeData>
340  class TNodeEDatNet {
341  public:
342    typedef TNodeData TNodeDat;
343    typedef TEdgeData TEdgeDat;
344    typedef TNodeEDatNet<TNodeData, TEdgeData> TNet;
345    typedef TPt<TNet> PNet;
346    typedef TVec<TPair<TInt, TEdgeData> > TNIdDatPrV;
347  public:
348    class TNode {
349    private:
350      TInt  Id;
351      TNodeData NodeDat;
352      TIntV InNIdV;
353      TNIdDatPrV OutNIdV;
354    public:
355      TNode() : Id(-1), NodeDat(), InNIdV(), OutNIdV() { }
356      TNode(const int& NId) : Id(NId), NodeDat(), InNIdV(), OutNIdV() { }
357      TNode(const int& NId, const TNodeData& NodeData) : Id(NId), NodeDat(NodeData), InNIdV(), OutNIdV() { }
358      TNode(const TNode& Node) : Id(Node.Id), NodeDat(Node.NodeDat), InNIdV(Node.InNIdV), OutNIdV(Node.OutNIdV) { }
359      TNode(TSIn& SIn) : Id(SIn), NodeDat(SIn), InNIdV(SIn), OutNIdV(SIn) { }
360      void Save(TSOut& SOut) const { Id.Save(SOut);  NodeDat.Save(SOut);  InNIdV.Save(SOut);  OutNIdV.Save(SOut); }
361      int GetId() const { return Id; }
362      int GetDeg() const { return GetInDeg() + GetOutDeg(); }
363      int GetInDeg() const { return InNIdV.Len(); }
364      int GetOutDeg() const { return OutNIdV.Len(); }
365      const TNodeData& GetDat() const { return NodeDat; }
366      TNodeData& GetDat() { return NodeDat; }
367      int GetInNId(const int& EdgeN) const { return InNIdV[EdgeN]; }
368      int GetOutNId(const int& EdgeN) const { return OutNIdV[EdgeN].Val1; }
369      int GetNbrNId(const int& EdgeN) const { return EdgeN<GetOutDeg() ? GetOutNId(EdgeN):GetInNId(EdgeN-GetOutDeg()); }
370      TEdgeData& GetOutEDat(const int& EdgeN) { return OutNIdV[EdgeN].Val2; }
371      const TEdgeData& GetOutEDat(const int& EdgeN) const { return OutNIdV[EdgeN].Val2; }
372      bool IsInNId(const int& NId) const { return InNIdV.SearchBin(NId)!=-1; }
373      bool IsOutNId(const int& NId) const { return TNodeEDatNet::GetNIdPos(OutNIdV, NId)!=-1; }
374      bool IsNbrNId(const int& NId) const { return IsOutNId(NId) || IsInNId(NId); }
375      void LoadShM(TShMIn& MStream) {
376        Id = TInt(MStream);
377        NodeDat = TNodeData(MStream);
378        InNIdV.LoadShM(MStream);
379        OutNIdV.LoadShM(MStream);
380      }
381      bool operator < (const TNode& Node) const { return NodeDat < Node.NodeDat; }
382      friend class TNodeEDatNet<TNodeData, TEdgeData>;
383    };
384    class TNodeI {
385    private:
386      typedef typename THash<TInt, TNode>::TIter THashIter;
387      THashIter NodeHI;
388      TNodeEDatNet *Net;
389    public:
390      TNodeI() : NodeHI(), Net(NULL) { }
391      TNodeI(const THashIter& NodeHIter, const TNodeEDatNet* NetPt) : NodeHI(NodeHIter), Net((TNodeEDatNet *) NetPt) { }
392      TNodeI(const TNodeI& NodeI) : NodeHI(NodeI.NodeHI), Net(NodeI.Net) { }
393      TNodeI& operator = (const TNodeI& NodeI) { NodeHI=NodeI.NodeHI; Net=NodeI.Net; return *this; }
394      TNodeI& operator++ (int) { NodeHI++;  return *this; }
395      bool operator < (const TNodeI& NodeI) const { return NodeHI < NodeI.NodeHI; }
396      bool operator == (const TNodeI& NodeI) const { return NodeHI == NodeI.NodeHI; }
397      int GetId() const { return NodeHI.GetDat().GetId(); }
398      int GetDeg() const { return NodeHI.GetDat().GetDeg(); }
399      int GetInDeg() const { return NodeHI.GetDat().GetInDeg(); }
400      int GetOutDeg() const { return NodeHI.GetDat().GetOutDeg(); }
401      int GetInNId(const int& NodeN) const { return NodeHI.GetDat().GetInNId(NodeN); }
402      int GetOutNId(const int& NodeN) const { return NodeHI.GetDat().GetOutNId(NodeN); }
403      int GetNbrNId(const int& NodeN) const { return NodeHI.GetDat().GetNbrNId(NodeN); }
404      bool IsInNId(const int& NId) const { return NodeHI.GetDat().IsInNId(NId); }
405      bool IsOutNId(const int& NId) const { return NodeHI.GetDat().IsOutNId(NId); }
406      bool IsNbrNId(const int& NId) const { return IsOutNId(NId) || IsInNId(NId); }
407      const TNodeData& operator () () const { return NodeHI.GetDat().NodeDat; }
408      TNodeData& operator () () { return NodeHI.GetDat().GetDat(); }
409      const TNodeData& GetDat() const { return NodeHI.GetDat().GetDat(); }
410      TNodeData& GetDat() { return NodeHI.GetDat().GetDat(); }
411      const TNodeData& GetOutNDat(const int& NodeN) const { return Net->GetNDat(GetOutNId(NodeN)); }
412      TNodeData& GetOutNDat(const int& NodeN) { return Net->GetNDat(GetOutNId(NodeN)); }
413      const TNodeData& GetInNDat(const int& NodeN) const { return Net->GetNDat(GetInNId(NodeN)); }
414      TNodeData& GetInNDat(const int& NodeN) { return Net->GetNDat(GetInNId(NodeN)); }
415      const TNodeData& GetNbrNDat(const int& NodeN) const { return Net->GetNDat(GetNbrNId(NodeN)); }
416      TNodeData& GetNbrNDat(const int& NodeN) { return Net->GetNDat(GetNbrNId(NodeN)); }
417      TEdgeData& GetOutEDat(const int& EdgeN) { return NodeHI.GetDat().GetOutEDat(EdgeN); }
418      const TEdgeData& GetOutEDat(const int& EdgeN) const { return NodeHI.GetDat().GetOutEDat(EdgeN); }
419      TEdgeData& GetInEDat(const int& EdgeN) { return Net->GetEDat(GetInNId(EdgeN), GetId()); }
420      const TEdgeData& GetInEDat(const int& EdgeN) const { return Net->GetEDat(GetInNId(EdgeN), GetId()); }
421      TEdgeData& GetNbrEDat(const int& EdgeN) { return EdgeN<GetOutDeg() ? GetOutEDat(EdgeN) : GetInEDat(EdgeN-GetOutDeg()); }
422      const TEdgeData& GetNbrEDat(const int& EdgeN) const { return EdgeN<GetOutDeg() ? GetOutEDat(EdgeN) : GetInEDat(EdgeN-GetOutDeg()); }
423      friend class TNodeEDatNet<TNodeData, TEdgeData>;
424    };
425    class TEdgeI {
426    private:
427      TNodeI CurNode, EndNode;
428      int CurEdge;
429    public:
430      TEdgeI() : CurNode(), EndNode(), CurEdge(0) { }
431      TEdgeI(const TNodeI& NodeI, const TNodeI& EndNodeI, const int& EdgeN=0) : CurNode(NodeI), EndNode(EndNodeI), CurEdge(EdgeN) { }
432      TEdgeI(const TEdgeI& EdgeI) : CurNode(EdgeI.CurNode), EndNode(EdgeI.EndNode), CurEdge(EdgeI.CurEdge) { }
433      TEdgeI& operator = (const TEdgeI& EdgeI) { if (this!=&EdgeI) { CurNode=EdgeI.CurNode;  EndNode=EdgeI.EndNode;  CurEdge=EdgeI.CurEdge; }  return *this; }
434      TEdgeI& operator++ (int) { CurEdge++; if (CurEdge >= CurNode.GetOutDeg()) { CurEdge=0;  CurNode++;
435        while (CurNode < EndNode && CurNode.GetOutDeg()==0) { CurNode++; } }  return *this; }
436      bool operator < (const TEdgeI& EdgeI) const { return CurNode<EdgeI.CurNode || (CurNode==EdgeI.CurNode && CurEdge<EdgeI.CurEdge); }
437      bool operator == (const TEdgeI& EdgeI) const { return CurNode == EdgeI.CurNode && CurEdge == EdgeI.CurEdge; }
438      int GetId() const { return -1; }
439      int GetSrcNId() const { return CurNode.GetId(); }
440      int GetDstNId() const { return CurNode.GetOutNId(CurEdge); }
441      TEdgeData& operator () () { return CurNode.GetOutEDat(CurEdge); }
442      const TEdgeData& operator () () const { return CurNode.GetOutEDat(CurEdge); }
443      TEdgeData& GetDat() { return CurNode.GetOutEDat(CurEdge); }
444      const TEdgeData& GetDat() const { return CurNode.GetOutEDat(CurEdge); }
445      TNodeData& GetSrcNDat() { return CurNode(); }
446      const TNodeData& GetSrcNDat() const { return CurNode(); }
447      TNodeData& GetDstNDat() { return CurNode.GetOutNDat(CurEdge); }
448      const TNodeData& GetDstNDat() const { return CurNode.GetOutNDat(CurEdge); }
449      friend class TNodeEDatNet<TNodeData, TEdgeData>;
450    };
451  protected:
452    TNode& GetNode(const int& NId) { return NodeH.GetDat(NId); }
453    static int GetNIdPos(const TVec<TPair<TInt, TEdgeData> >& NIdV, const int& NId);
454  protected:
455    TCRef CRef;
456    TInt MxNId;
457    THash<TInt, TNode> NodeH;
458  private:
459    class TNodeFunctor {
460    public:
461      TNodeFunctor() {}
462      void operator() (TNode* n, TShMIn& ShMIn) { n->LoadShM(ShMIn);}
463    };
464  private:
465    void LoadNetworkShM(TShMIn& ShMIn) {
466      MxNId = TInt(ShMIn);
467      TNodeFunctor f;
468      NodeH.LoadShM(ShMIn, f);
469    }
470  public:
471    TNodeEDatNet() : CRef(), MxNId(0), NodeH() { }
472    explicit TNodeEDatNet(const int& Nodes, const int& Edges) : MxNId(0) { Reserve(Nodes, Edges); }
473    TNodeEDatNet(const TNodeEDatNet& NodeNet) : MxNId(NodeNet.MxNId), NodeH(NodeNet.NodeH) { }
474    TNodeEDatNet(TSIn& SIn) : MxNId(SIn), NodeH(SIn) { }
475    virtual ~TNodeEDatNet() { }
476    virtual void Save(TSOut& SOut) const { MxNId.Save(SOut);  NodeH.Save(SOut); SOut.Flush(); }
477    static PNet New() { return PNet(new TNet()); }
478    static PNet Load(TSIn& SIn) { return PNet(new TNet(SIn)); }
479    static PNet LoadShM(TShMIn& ShMIn) {
480      TNet* Network = new TNet();
481      Network->LoadNetworkShM(ShMIn);
482      return PNet(Network);
483    }
484    bool HasFlag(const TGraphFlag& Flag) const;
485    TNodeEDatNet& operator = (const TNodeEDatNet& NodeNet) { if (this!=&NodeNet) {
486      NodeH=NodeNet.NodeH;  MxNId=NodeNet.MxNId; }  return *this; }
487    int GetNodes() const { return NodeH.Len(); }
488    int AddNode(int NId = -1);
489    int AddNodeUnchecked(int NId = -1);
490    int AddNode(int NId, const TNodeData& NodeDat);
491    int AddNode(const TNodeI& NodeI) { return AddNode(NodeI.GetId(), NodeI.GetDat()); }
492    void DelNode(const int& NId);
493    void DelNode(const TNode& NodeI) { DelNode(NodeI.GetId()); }
494    bool IsNode(const int& NId) const { return NodeH.IsKey(NId); }
495    TNodeI BegNI() const { return TNodeI(NodeH.BegI(), this); }
496    TNodeI EndNI() const { return TNodeI(NodeH.EndI(), this); }
497    TNodeI GetNI(const int& NId) const { return TNodeI(NodeH.GetI(NId), this); }
498    const TNode& GetNode(const int& NId) const { return NodeH.GetDat(NId); }
499    void SetNDat(const int& NId, const TNodeData& NodeDat);
500    TNodeData& GetNDat(const int& NId) { return NodeH.GetDat(NId).NodeDat; }
501    const TNodeData& GetNDat(const int& NId) const { return NodeH.GetDat(NId).NodeDat; }
502    int GetMxNId() const { return MxNId; }
503    int GetEdges() const;
<span onclick='openModal()' class='match'>504    int AddEdge(const int& SrcNId, const int& DstNId);
505    int AddEdge(const int& SrcNId, const int& DstNId, const TEdgeData& EdgeDat);
506    int AddEdge(const TEdgeI& EdgeI) { return AddEdge(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), EdgeI()); }
</span>507    void DelEdge(const int& SrcNId, const int& DstNId, const bool& IsDir = true);
508    bool IsEdge(const int& SrcNId, const int& DstNId, const bool& IsDir = true) const;
509    TEdgeI BegEI() const { TNodeI NI=BegNI();  while(NI<EndNI() && NI.GetOutDeg()==0) NI++; return TEdgeI(NI, EndNI()); }
510    TEdgeI EndEI() const { return TEdgeI(EndNI(), EndNI()); }
511    TEdgeI GetEI(const int& EId) const; 
512    TEdgeI GetEI(const int& SrcNId, const int& DstNId) const;
513    void SetEDat(const int& SrcNId, const int& DstNId, const TEdgeData& EdgeDat);
514    bool GetEDat(const int& SrcNId, const int& DstNId, TEdgeData& EdgeDat) const;
515    TEdgeData& GetEDat(const int& SrcNId, const int& DstNId);
516    const TEdgeData& GetEDat(const int& SrcNId, const int& DstNId) const;
517    void SetAllEDat(const TEdgeData& EdgeDat);
518    int GetRndNId(TRnd& Rnd=TInt::Rnd) { return NodeH.GetKey(NodeH.GetRndKeyId(Rnd, 0.8)); }
519    TNodeI GetRndNI(TRnd& Rnd=TInt::Rnd) { return GetNI(GetRndNId(Rnd)); }
520    void GetNIdV(TIntV& NIdV) const;
521    bool Empty() const { return GetNodes()==0; }
522    void Clr(const bool& DoDel=true, const bool& ResetDat=true) {
523      MxNId = 0;  NodeH.Clr(DoDel, -1, ResetDat); }
524    void Reserve(const int& Nodes, const int& Edges) { if (Nodes>0) { NodeH.Gen(Nodes/2); } }
525    void SortNIdById(const bool& Asc=true) { NodeH.SortByKey(Asc); }
526    void SortNIdByDat(const bool& Asc=true) { NodeH.SortByDat(Asc); }
527    void Defrag(const bool& OnlyNodeLinks=false);
528    bool IsOk(const bool& ThrowExcept=true) const;
529    friend class TPt<TNodeEDatNet<TNodeData, TEdgeData> >;
530  };
531  namespace TSnap {
532  template <class TNodeData, class TEdgeData> struct IsDirected<TNodeEDatNet<TNodeData, TEdgeData> > { enum { Val = 1 }; };
533  template <class TNodeData, class TEdgeData> struct IsNodeDat<TNodeEDatNet<TNodeData, TEdgeData> > { enum { Val = 1 }; };
534  template <class TNodeData, class TEdgeData> struct IsEdgeDat<TNodeEDatNet<TNodeData, TEdgeData> > { enum { Val = 1 }; };
535  }
536  template <class TNodeData, class TEdgeData>
537  bool TNodeEDatNet<TNodeData, TEdgeData>::HasFlag(const TGraphFlag& Flag) const {
538    return HasGraphFlag(typename TNet, Flag);
539  }
540  template <class TNodeData, class TEdgeData>
541  int TNodeEDatNet<TNodeData, TEdgeData>::GetNIdPos(const TVec<TPair<TInt, TEdgeData> >& NIdV, const int& NId) {
542    int LValN=0, RValN = NIdV.Len()-1;
543    while (RValN >= LValN) {
544      const int ValN = (LValN+RValN)/2;
545      const int CurNId = NIdV[ValN].Val1;
546      if (NId == CurNId) { return ValN; }
547      if (NId < CurNId) { RValN=ValN-1; }
548      else { LValN=ValN+1; }
549    }
550    return -1;
551  }
552  template <class TNodeData, class TEdgeData>
553  int TNodeEDatNet<TNodeData, TEdgeData>::AddNode(int NId) {
554    if (NId == -1) {
555      NId = MxNId;  MxNId++;
556    } else {
557      IAssertR(!IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
558      MxNId = TMath::Mx(NId+1, MxNId());
559    }
560    NodeH.AddDat(NId, TNode(NId));
561    return NId;
562  }
563  template <class TNodeData, class TEdgeData>
564  int TNodeEDatNet<TNodeData, TEdgeData>::AddNodeUnchecked(int NId) {
565    if (NId == -1) {
566      NId = MxNId;  MxNId++;
567    } else {
568      if (IsNode(NId)) { return -1;}
569      MxNId = TMath::Mx(NId+1, MxNId());
570    }
571    NodeH.AddDat(NId, TNode(NId));
572    return NId;
573  }
574  template <class TNodeData, class TEdgeData>
575  int TNodeEDatNet<TNodeData, TEdgeData>::AddNode(int NId, const TNodeData& NodeDat) {
576    if (NId == -1) {
577      NId = MxNId;  MxNId++;
578    } else {
579      IAssertR(!IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
580      MxNId = TMath::Mx(NId+1, MxNId());
581    }
582    NodeH.AddDat(NId, TNode(NId, NodeDat));
583    return NId;
584  }
585  template <class TNodeData, class TEdgeData>
586  void TNodeEDatNet<TNodeData, TEdgeData>::SetNDat(const int& NId, const TNodeData& NodeDat) {
587    IAssertR(IsNode(NId), TStr::Fmt("NodeId %d does not exist.", NId).CStr());
588    NodeH.GetDat(NId).NodeDat = NodeDat;
589  }
590  template <class TNodeData, class TEdgeData>
591  void TNodeEDatNet<TNodeData, TEdgeData>::DelNode(const int& NId) {
592    const TNode& Node = GetNode(NId);
593    for (int out = 0; out < Node.GetOutDeg(); out++) {
594      const int nbr = Node.GetOutNId(out);
595      if (nbr == NId) { continue; }
596      TIntV& NIdV = GetNode(nbr).InNIdV;
597      const int pos = NIdV.SearchBin(NId);
598      if (pos != -1) { NIdV.Del(pos); }
599    }
600    for (int in = 0; in < Node.GetInDeg(); in++) {
601      const int nbr = Node.GetInNId(in);
602      if (nbr == NId) { continue; }
603      TNIdDatPrV& NIdDatV = GetNode(nbr).OutNIdV;
604      const int pos = GetNIdPos(NIdDatV, NId);
605      if (pos != -1) { NIdDatV.Del(pos); }
606    }
607    NodeH.DelKey(NId);
608  }
609  template <class TNodeData, class TEdgeData>
610  int TNodeEDatNet<TNodeData, TEdgeData>::GetEdges() const {
611    int edges=0;
612    for (int N=NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
613      edges+=NodeH[N].GetOutDeg(); }
614    return edges;
615  }
616  template <class TNodeData, class TEdgeData>
617  int TNodeEDatNet<TNodeData, TEdgeData>::AddEdge(const int& SrcNId, const int& DstNId) {
618    return AddEdge(SrcNId, DstNId, TEdgeData());
619  }
620  template <class TNodeData, class TEdgeData>
621  int TNodeEDatNet<TNodeData, TEdgeData>::AddEdge(const int& SrcNId, const int& DstNId, const TEdgeData& EdgeDat) {
622    IAssertR(IsNode(SrcNId) && IsNode(DstNId), TStr::Fmt("%d or %d not a node.", SrcNId, DstNId).CStr());
623    if (IsEdge(SrcNId, DstNId)) {
624      GetEDat(SrcNId, DstNId) = EdgeDat;
625      return -2;
626    }
627    GetNode(SrcNId).OutNIdV.AddSorted(TPair<TInt, TEdgeData>(DstNId, EdgeDat));
628    GetNode(DstNId).InNIdV.AddSorted(SrcNId);
629    return -1; 
630  }
631  template <class TNodeData, class TEdgeData>
632  void TNodeEDatNet<TNodeData, TEdgeData>::DelEdge(const int& SrcNId, const int& DstNId, const bool& IsDir) {
633    IAssertR(IsNode(SrcNId) && IsNode(DstNId), TStr::Fmt("%d or %d not a node.", SrcNId, DstNId).CStr());
634    int pos = GetNIdPos(GetNode(SrcNId).OutNIdV, DstNId);
635    if (pos != -1) { GetNode(SrcNId).OutNIdV.Del(pos); }
636    pos = GetNode(DstNId).InNIdV.SearchBin(SrcNId);
637    if (pos != -1) { GetNode(DstNId).InNIdV.Del(pos); }
638    if (! IsDir) {
639      pos = GetNIdPos(GetNode(DstNId).OutNIdV, SrcNId);
640      if (pos != -1) { GetNode(DstNId).OutNIdV.Del(pos); }
641      pos = GetNode(SrcNId).InNIdV.SearchBin(DstNId);
642      if (pos != -1) { GetNode(SrcNId).InNIdV.Del(pos); }
643    }
644  }
645  template <class TNodeData, class TEdgeData>
646  bool TNodeEDatNet<TNodeData, TEdgeData>::IsEdge(const int& SrcNId, const int& DstNId, const bool& IsDir) const {
647    if (! IsNode(SrcNId) || ! IsNode(DstNId)) { return false; }
648    if (IsDir) { return GetNode(SrcNId).IsOutNId(DstNId); }
649    else { return GetNode(SrcNId).IsOutNId(DstNId) || GetNode(DstNId).IsOutNId(SrcNId); }
650  }
651  template <class TNodeData, class TEdgeData>
652  void TNodeEDatNet<TNodeData, TEdgeData>::SetEDat(const int& SrcNId, const int& DstNId, const TEdgeData& EdgeDat) {
653    IAssertR(IsNode(SrcNId) && IsNode(DstNId), TStr::Fmt("%d or %d not a node.", SrcNId, DstNId).CStr());
654    IAssertR(IsEdge(SrcNId, DstNId), TStr::Fmt("Edge between %d and %d does not exist.", SrcNId, DstNId).CStr());
655    GetEDat(SrcNId, DstNId) = EdgeDat;
656  }
657  template <class TNodeData, class TEdgeData>
658  bool TNodeEDatNet<TNodeData, TEdgeData>::GetEDat(const int& SrcNId, const int& DstNId, TEdgeData& EdgeDat) const {
659    if (! IsEdge(SrcNId, DstNId)) { return false; }
660    const TNode& N = GetNode(SrcNId);
661    EdgeDat = N.GetOutEDat(GetNIdPos(N.OutNIdV, DstNId));
662    return true;
663  }
664  template <class TNodeData, class TEdgeData>
665  TEdgeData& TNodeEDatNet<TNodeData, TEdgeData>::GetEDat(const int& SrcNId, const int& DstNId) {
666    Assert(IsEdge(SrcNId, DstNId));
667    TNode& N = GetNode(SrcNId);
668    return N.GetOutEDat(GetNIdPos(N.OutNIdV, DstNId));
669  }
670  template <class TNodeData, class TEdgeData>
671  const TEdgeData& TNodeEDatNet<TNodeData, TEdgeData>::GetEDat(const int& SrcNId, const int& DstNId) const {
672    Assert(IsEdge(SrcNId, DstNId));
673    const TNode& N = GetNode(SrcNId);
674    return N.GetOutEDat(GetNIdPos(N.OutNIdV, DstNId));
675  }
676  template <class TNodeData, class TEdgeData>
677  void TNodeEDatNet<TNodeData, TEdgeData>::SetAllEDat(const TEdgeData& EdgeDat) {
678    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
679      EI() = EdgeDat;
680    }
681  }
682  template <class TNodeData, class TEdgeData>
683  typename TNodeEDatNet<TNodeData, TEdgeData>::TEdgeI  TNodeEDatNet<TNodeData, TEdgeData>::GetEI(const int& SrcNId, const int& DstNId) const {
684    const TNodeI SrcNI = GetNI(SrcNId);
685    int NodeN = -1;
686    const TNIdDatPrV& NIdDatV = SrcNI.NodeHI.GetDat().OutNIdV;
687    int LValN=0, RValN=NIdDatV.Len()-1;
688    while (RValN>=LValN){
689      int ValN=(LValN+RValN)/2;
690      if (DstNId==NIdDatV[ValN].Val1){ NodeN=ValN; break; }
691      if (DstNId<NIdDatV[ValN].Val1){RValN=ValN-1;} else {LValN=ValN+1;}
692    }
693    if (NodeN == -1) { return EndEI(); }
694    else { return TEdgeI(SrcNI, EndNI(), NodeN); }
695  }
696  template <class TNodeData, class TEdgeData>
697  void TNodeEDatNet<TNodeData, TEdgeData>::GetNIdV(TIntV& NIdV) const {
698    NIdV.Reserve(GetNodes(), 0);
699    for (int N=NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
700      NIdV.Add(NodeH.GetKey(N)); }
701  }
702  template <class TNodeData, class TEdgeData>
703  void TNodeEDatNet<TNodeData, TEdgeData>::Defrag(const bool& OnlyNodeLinks) {
704    for (int n = NodeH.FFirstKeyId(); NodeH.FNextKeyId(n);) {
705      TNode& Node = NodeH[n];
706      Node.InNIdV.Pack();  Node.OutNIdV.Pack();
707    }
708    if (! OnlyNodeLinks && ! NodeH.IsKeyIdEqKeyN()) {
709      NodeH.Defrag();
710    }
711  }
712  template <class TNodeData, class TEdgeData>
713  bool TNodeEDatNet<TNodeData, TEdgeData>::IsOk(const bool& ThrowExcept) const {
714    bool RetVal = true;
715    for (int N = NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
716      const TNode& Node = NodeH[N];
717      if (! Node.OutNIdV.IsSorted()) {
718        const TStr Msg = TStr::Fmt("Out-neighbor list of node %d is not sorted.", Node.GetId());
719        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
720      }
721      if (! Node.InNIdV.IsSorted()) {
722        const TStr Msg = TStr::Fmt("In-neighbor list of node %d is not sorted.", Node.GetId());
723        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
724      }
725      int prevNId = -1;
726      for (int e = 0; e < Node.GetOutDeg(); e++) {
727        if (! IsNode(Node.GetOutNId(e))) {
728          const TStr Msg = TStr::Fmt("Out-edge %d --> %d: node %d does not exist.",
729            Node.GetId(), Node.GetOutNId(e), Node.GetOutNId(e));
730          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
731        }
732        if (e > 0 && prevNId == Node.GetOutNId(e)) {
733          const TStr Msg = TStr::Fmt("Node %d has duplidate out-edge %d --> %d.",
734            Node.GetId(), Node.GetId(), Node.GetOutNId(e));
735          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
736        }
737        prevNId = Node.GetOutNId(e);
738      }
739      prevNId = -1;
740      for (int e = 0; e < Node.GetInDeg(); e++) {
741        if (! IsNode(Node.GetInNId(e))) {
742          const TStr Msg = TStr::Fmt("In-edge %d <-- %d: node %d does not exist.",
743            Node.GetId(), Node.GetInNId(e), Node.GetInNId(e));
744          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
745        }
746        if (e > 0 && prevNId == Node.GetInNId(e)) {
747          const TStr Msg = TStr::Fmt("Node %d has duplidate in-edge %d <-- %d.",
748            Node.GetId(), Node.GetId(), Node.GetInNId(e));
749          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
750        }
751        prevNId = Node.GetInNId(e);
752      }
753    }
754    return RetVal;
755  }
756  typedef TNodeEDatNet<TInt, TInt> TIntNEDNet;
757  typedef TPt<TIntNEDNet> PIntNEDNet;
758  typedef TNodeEDatNet<TInt, TFlt> TIntFltNEDNet;
759  typedef TPt<TIntFltNEDNet> PIntFltNEDNet;
760  typedef TNodeEDatNet<TStr, TInt> TStrIntNEDNet;
761  typedef TPt<TStrIntNEDNet> PStrIntNEDNet;
762  template <class TNodeData, class TEdgeData>
763  class TNodeEdgeNet {
764  public:
765    typedef TNodeData TNodeDat;
766    typedef TEdgeData TEdgeDat;
767    typedef TNodeEdgeNet<TNodeData, TEdgeData> TNet;
768    typedef TPt<TNet> PNet;
769  public:
770    class TNode {
771    private:
772      TInt Id;
773      TIntV InEIdV, OutEIdV;
774      TNodeData NodeDat;
775    public:
776      TNode() : Id(-1), InEIdV(), OutEIdV(), NodeDat() { }
777      TNode(const int& NId) : Id(NId), InEIdV(), OutEIdV(), NodeDat()  { }
778      TNode(const int& NId, const TNodeData& NodeData) : Id(NId), InEIdV(), OutEIdV(), NodeDat(NodeData) { }
779      TNode(const TNode& Node) : Id(Node.Id), InEIdV(Node.InEIdV), OutEIdV(Node.OutEIdV), NodeDat(Node.NodeDat) { }
780      TNode(TSIn& SIn) : Id(SIn), InEIdV(SIn), OutEIdV(SIn), NodeDat(SIn) { }
781      void Save(TSOut& SOut) const { Id.Save(SOut);  InEIdV.Save(SOut);  OutEIdV.Save(SOut);  NodeDat.Save(SOut); }
782      bool operator < (const TNode& Node) const { return NodeDat < Node.NodeDat; }
783      int GetId() const { return Id; }
784      int GetDeg() const { return GetInDeg() + GetOutDeg(); }
785      int GetInDeg() const { return InEIdV.Len(); }
786      int GetOutDeg() const { return OutEIdV.Len(); }
787      const TNodeData& GetDat() const { return NodeDat; }
788      TNodeData& GetDat() { return NodeDat; }
789      int GetInEId(const int& NodeN) const { return InEIdV[NodeN]; }
790      int GetOutEId(const int& NodeN) const { return OutEIdV[NodeN]; }
791      int GetNbrEId(const int& EdgeN) const { return EdgeN<GetOutDeg()?GetOutEId(EdgeN):GetInEId(EdgeN-GetOutDeg()); }
792      bool IsInEId(const int& EId) const { return InEIdV.SearchBin(EId) != -1; }
793      bool IsOutEId(const int& EId) const { return OutEIdV.SearchBin(EId) != -1; }
794      bool IsNbrEId(const int& EId) const { return IsInEId(EId) || IsOutEId(EId); }
795      void LoadShM(TShMIn& MStream) {
796        Id = TInt(MStream);
797        InEIdV.LoadShM(MStream);
798        OutEIdV.LoadShM(MStream);
799        NodeDat = TNodeData(MStream);
800      }
801      friend class TNodeEdgeNet<TNodeData, TEdgeData>;
802    };
803    class TEdge {
804    private:
805      TInt Id, SrcNId, DstNId;
806      TEdgeData EdgeDat;
807    public:
808      TEdge() : Id(-1), SrcNId(-1), DstNId(-1), EdgeDat() { }
809      TEdge(const int& EId, const int& SourceNId, const int& DestNId) : Id(EId), SrcNId(SourceNId), DstNId(DestNId), EdgeDat() { }
810      TEdge(const int& EId, const int& SourceNId, const int& DestNId, const TEdgeData& EdgeData) : Id(EId), SrcNId(SourceNId), DstNId(DestNId), EdgeDat(EdgeData) { }
811      TEdge(const TEdge& Edge) : Id(Edge.Id), SrcNId(Edge.SrcNId), DstNId(Edge.DstNId), EdgeDat(Edge.EdgeDat) { }
812      TEdge(TSIn& SIn) : Id(SIn), SrcNId(SIn), DstNId(SIn), EdgeDat(SIn) { }
813      void Save(TSOut& SOut) const { Id.Save(SOut);  SrcNId.Save(SOut);  DstNId.Save(SOut);  EdgeDat.Save(SOut); }
814      bool operator < (const TEdge& Edge) const { return EdgeDat < Edge.EdgeDat; }
815      int GetId() const { return Id; }
816      int GetSrcNId() const { return SrcNId; }
817      int GetDstNId() const { return DstNId; }
818      void Load(TSIn& InStream) {
819        Id = TInt(InStream);
820        SrcNId = TInt(InStream);
821        DstNId = TInt(InStream);
822        EdgeDat = TEdgeData(InStream);
823      }
824      const TEdgeData& GetDat() const { return EdgeDat; }
825      TEdgeData& GetDat() { return EdgeDat; }
826      friend class TNodeEdgeNet;
827    };
828    class TNodeI {
829    private:
830      typedef typename THash<TInt, TNode>::TIter THashIter;
831      THashIter NodeHI;
832      TNodeEdgeNet *Net;
833    public:
834      TNodeI() : NodeHI(), Net(NULL) { }
835      TNodeI(const THashIter& NodeHIter, const TNodeEdgeNet* NetPt) : NodeHI(NodeHIter), Net((TNodeEdgeNet *)NetPt) { }
836      TNodeI(const TNodeI& NodeI) : NodeHI(NodeI.NodeHI), Net(NodeI.Net) { }
837      TNodeI& operator = (const TNodeI& NodeI) { NodeHI = NodeI.NodeHI;  Net=NodeI.Net;  return *this; }
838      TNodeI& operator++ (int) { NodeHI++;  return *this; }
839      bool operator < (const TNodeI& NodeI) const { return NodeHI < NodeI.NodeHI; }
840      bool operator == (const TNodeI& NodeI) const { return NodeHI == NodeI.NodeHI; }
841      int GetId() const { return NodeHI.GetDat().GetId(); }
842      int GetDeg() const { return NodeHI.GetDat().GetDeg(); }
843      int GetInDeg() const { return NodeHI.GetDat().GetInDeg(); }
844      int GetOutDeg() const { return NodeHI.GetDat().GetOutDeg(); }
845      int GetInNId(const int& EdgeN) const { return Net->GetEdge(NodeHI.GetDat().GetInEId(EdgeN)).GetSrcNId(); }
846      int GetOutNId(const int& EdgeN) const { return Net->GetEdge(NodeHI.GetDat().GetOutEId(EdgeN)).GetDstNId(); }
847      int GetNbrNId(const int& EdgeN) const { const TEdge& E = Net->GetEdge(NodeHI.GetDat().GetNbrEId(EdgeN));
848        return GetId()==E.GetSrcNId() ? E.GetDstNId():E.GetSrcNId(); }
849      bool IsInNId(const int& NId) const;
850      bool IsOutNId(const int& NId) const;
851      bool IsNbrNId(const int& NId) const { return IsOutNId(NId) || IsInNId(NId); }
852      const TNodeData& operator () () const { return NodeHI.GetDat().GetDat(); }
853      TNodeData& operator () () { return NodeHI.GetDat().GetDat(); }
854      const TNodeData& GetDat() const { return NodeHI.GetDat().GetDat(); }
855      TNodeData& GetDat() { return NodeHI.GetDat().GetDat(); }
856      const TNodeData& GetInNDat(const int& EdgeN) const { return Net->GetNDat(GetInNId(EdgeN)); }
857      TNodeData& GetInNDat(const int& EdgeN) { return Net->GetNDat(GetInNId(EdgeN)); }
858      const TNodeData& GetOutNDat(const int& EdgeN) const { return Net->GetNDat(GetOutNId(EdgeN)); }
859      TNodeData& GetOutNDat(const int& EdgeN) { return Net->GetNDat(GetOutNId(EdgeN)); }
860      const TNodeData& GetNbrNDat(const int& EdgeN) const { return Net->GetNDat(GetNbrNId(EdgeN)); }
861      TNodeData& GetNbrNDat(const int& EdgeN) { return Net->GetNDat(GetNbrNId(EdgeN)); }
862      int GetInEId(const int& EdgeN) const { return NodeHI.GetDat().GetInEId(EdgeN); }
863      int GetOutEId(const int& EdgeN) const { return NodeHI.GetDat().GetOutEId(EdgeN); }
864      int GetNbrEId(const int& EdgeN) const { return NodeHI.GetDat().GetNbrEId(EdgeN); }
865      bool IsInEId(const int& EId) const { return NodeHI.GetDat().IsInEId(EId); }
866      bool IsOutEId(const int& EId) const { return NodeHI.GetDat().IsOutEId(EId); }
867      bool IsNbrEId(const int& EId) const { return NodeHI.GetDat().IsNbrEId(EId); }
868      TEdgeDat& GetInEDat(const int& EdgeN) { return Net->GetEDat(GetInEId(EdgeN)); }
869      const TEdgeDat& GetInEDat(const int& EdgeN) const { return Net->GetEDat(GetInEId(EdgeN)); }
870      TEdgeDat& GetOutEDat(const int& EdgeN) { return Net->GetEDat(GetOutEId(EdgeN)); }
871      const TEdgeDat& GetOutEDat(const int& EdgeN) const { return Net->GetEDat(GetOutEId(EdgeN)); }
872      TEdgeDat& GetNbrEDat(const int& EdgeN) { return Net->GetEDat(GetNbrEId(EdgeN)); }
873      const TEdgeDat& GetNbrEDat(const int& EdgeN) const { return Net->GetEDat(GetNbrEId(EdgeN)); }
874      friend class TNodeEdgeNet;
875    };
876    class TEdgeI {
877    private:
878      typedef typename THash<TInt, TEdge>::TIter THashIter;
879      THashIter EdgeHI;
880      TNodeEdgeNet *Net;
881    public:
882      TEdgeI() : EdgeHI(), Net(NULL) { }
883      TEdgeI(const THashIter& EdgeHIter, const TNodeEdgeNet *NetPt) : EdgeHI(EdgeHIter), Net((TNodeEdgeNet *) NetPt) { }
884      TEdgeI(const TEdgeI& EdgeI) : EdgeHI(EdgeI.EdgeHI), Net(EdgeI.Net) { }
885      TEdgeI& operator = (const TEdgeI& EdgeI) { if (this!=&EdgeI) { EdgeHI=EdgeI.EdgeHI;  Net=EdgeI.Net; }  return *this; }
886      TEdgeI& operator++ (int) { EdgeHI++;  return *this; }
887      bool operator < (const TEdgeI& EdgeI) const { return EdgeHI < EdgeI.EdgeHI; }
888      bool operator == (const TEdgeI& EdgeI) const { return EdgeHI == EdgeI.EdgeHI; }
889      int GetId() const { return EdgeHI.GetDat().GetId(); }
890      int GetSrcNId() const { return EdgeHI.GetDat().GetSrcNId(); }
891      int GetDstNId() const { return EdgeHI.GetDat().GetDstNId(); }
892      const TEdgeData& operator () () const { return EdgeHI.GetDat().GetDat(); }
893      TEdgeData& operator () () { return EdgeHI.GetDat().GetDat(); }
894      const TEdgeData& GetDat() const { return EdgeHI.GetDat().GetDat(); }
895      TEdgeData& GetDat() { return EdgeHI.GetDat().GetDat(); }
896      const TNodeData& GetSrcNDat() const { return Net->GetNDat(GetSrcNId()); }
897      TNodeData& GetSrcNDat() { return Net->GetNDat(GetSrcNId()); }
898      const TNodeData& GetDstNDat() const { return Net->GetNDat(GetDstNId()); }
899      TNodeData& GetDstNDat() { return Net->GetNDat(GetDstNId()); }
900      friend class TNodeEdgeNet;
901    };
902  private:
903    TNode& GetNode(const int& NId) { return NodeH.GetDat(NId); }
904    const TNode& GetNode(const int& NId) const { return NodeH.GetDat(NId); }
905    const TNode& GetNodeKId(const int& NodeKeyId) const { return NodeH[NodeKeyId]; }
906    TEdge& GetEdge(const int& EId) { return EdgeH.GetDat(EId); }
907    const TEdge& GetEdge(const int& EId) const { return EdgeH.GetDat(EId); }
908    const TEdge& GetEdgeKId(const int& EdgeKeyId) const { return EdgeH[EdgeKeyId]; }
909  protected:
910    TCRef CRef;
911    TInt MxNId, MxEId;
912    THash<TInt, TNode> NodeH;
913    THash<TInt, TEdge> EdgeH;
914  private:
915    class LoadTNodeFunctor {
916    public:
917      LoadTNodeFunctor() {}
918      void operator() (TNode* n, TShMIn& ShMIn) { n->LoadShM(ShMIn);}
919    };
920  private:
921    void LoadNetworkShM(TShMIn& ShMIn) {
922      MxNId = TInt(ShMIn);
923      MxEId = TInt(ShMIn);
924      LoadTNodeFunctor fn;
925      NodeH.LoadShM(ShMIn, fn);
926      EdgeH.LoadShM(ShMIn);
927    }
928  public:
929    TNodeEdgeNet() : CRef(), MxNId(0), MxEId(0) { }
930    explicit TNodeEdgeNet(const int& Nodes, const int& Edges) : CRef(), MxNId(0), MxEId(0) { Reserve(Nodes, Edges); }
931    TNodeEdgeNet(const TNodeEdgeNet& Net) : MxNId(Net.MxNId), MxEId(Net.MxEId), NodeH(Net.NodeH), EdgeH(Net.EdgeH) { }
932    TNodeEdgeNet(TSIn& SIn) : MxNId(SIn), MxEId(SIn), NodeH(SIn), EdgeH(SIn) { }
933    virtual ~TNodeEdgeNet() { }
934    virtual void Save(TSOut& SOut) const { MxNId.Save(SOut);  MxEId.Save(SOut);  NodeH.Save(SOut);  EdgeH.Save(SOut); SOut.Flush(); }
935    static PNet New() { return PNet(new TNet()); }
936    static PNet Load(TSIn& SIn) { return PNet(new TNet(SIn)); }
937    static PNet LoadShM(TShMIn& ShMIn) {
938      TNet* Network = new TNet();
939      Network->LoadNetworkShM(ShMIn);
940      return PNet(Network);
941    }
942    bool HasFlag(const TGraphFlag& Flag) const;
943    TNodeEdgeNet& operator = (const TNodeEdgeNet& Net) {
944      if (this!=&Net) { NodeH=Net.NodeH; EdgeH=Net.EdgeH; MxNId=Net.MxNId; MxEId=Net.MxEId; }  return *this; }
945    int GetNodes() const { return NodeH.Len(); }
946    int AddNode(int NId = -1);
947    int AddNodeUnchecked(int NId = -1);
948    int AddNode(int NId, const TNodeData& NodeDat);
949    friend class TCrossNet;
950    int AddNode(const TNodeI& NodeI) { return AddNode(NodeI.GetId(), NodeI.GetDat()); }
951    void DelNode(const int& NId);
952    void DelNode(const TNode& NodeI) { DelNode(NodeI.GetId()); }
953    bool IsNode(const int& NId) const { return NodeH.IsKey(NId); }
954    TNodeI BegNI() const { return TNodeI(NodeH.BegI(), this); }
955    TNodeI EndNI() const { return TNodeI(NodeH.EndI(), this); }
956    TNodeI GetNI(const int& NId) const { return TNodeI(NodeH.GetI(NId), this); }
957    void SetNDat(const int& NId, const TNodeData& NodeDat);
958    TNodeData& GetNDat(const int& NId) { return NodeH.GetDat(NId).NodeDat; }
959    const TNodeData& GetNDat(const int& NId) const { return NodeH.GetDat(NId).NodeDat; }
960    int GetMxNId() const { return MxNId; }
961    int GetEdges() const { return EdgeH.Len(); }
962    int GetUniqEdges(const bool& IsDir=true) const;
963    int AddEdge(const int& SrcNId, const int& DstNId, int EId = -1);
964    int AddEdge(const int& SrcNId, const int& DstNId, int EId, const TEdgeData& EdgeDat);
965    int AddEdge(const TEdgeI& EdgeI) { return AddEdge(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), EdgeI.GetId(), EdgeI.GetDat()); }
966    void DelEdge(const int& EId);
967    void DelEdge(const int& SrcNId, const int& DstNId, const bool& IsDir = true);
968    bool IsEdge(const int& EId) const { return EdgeH.IsKey(EId); }
969    bool IsEdge(const int& SrcNId, const int& DstNId, const bool& IsDir = true) const { int EId;  return IsEdge(SrcNId, DstNId, EId, IsDir); }
970    bool IsEdge(const int& SrcNId, const int& DstNId, int& EId, const bool& IsDir = true) const;
971    int GetEId(const int& SrcNId, const int& DstNId) const { int EId; return IsEdge(SrcNId, DstNId, EId)?EId:-1; }
972    TEdgeI BegEI() const { return TEdgeI(EdgeH.BegI(), this); }
973    TEdgeI EndEI() const { return TEdgeI(EdgeH.EndI(), this); }
974    TEdgeI GetEI(const int& EId) const { return TEdgeI(EdgeH.GetI(EId), this); }
975    TEdgeI GetEI(const int& SrcNId, const int& DstNId) const { return GetEI(GetEId(SrcNId, DstNId)); }
976    void SetEDat(const int& EId, const TEdgeData& EdgeDat);
977    TEdgeData& GetEDat(const int& EId) { return EdgeH.GetDat(EId).EdgeDat; }
978    const TEdgeData& GetEDat(const int& EId) const { return EdgeH.GetDat(EId).EdgeDat; }
979    void SetAllEDat(const TEdgeData& EdgeDat);
980    int GetRndNId(TRnd& Rnd=TInt::Rnd) { return NodeH.GetKey(NodeH.GetRndKeyId(Rnd, 0.8)); }
981    TNodeI GetRndNI(TRnd& Rnd=TInt::Rnd) { return GetNI(GetRndNId(Rnd)); }
982    int GetRndEId(TRnd& Rnd=TInt::Rnd) { return EdgeH.GetKey(EdgeH.GetRndKeyId(Rnd, 0.8)); }
983    TEdgeI GetRndEI(TRnd& Rnd=TInt::Rnd) { return GetEI(GetRndEId(Rnd)); }
984    void GetNIdV(TIntV& NIdV) const;
985    void GetEIdV(TIntV& EIdV) const;
986    bool Empty() const { return GetNodes()==0; }
987    void Clr() { MxNId=0;  MxEId=0;  NodeH.Clr();  EdgeH.Clr(); }
988    void Reserve(const int& Nodes, const int& Edges) {
989      if (Nodes>0) { NodeH.Gen(Nodes/2); }  if (Edges>0) { EdgeH.Gen(Edges/2); } }
990    void SortNIdById(const bool& Asc=true) { NodeH.SortByKey(Asc); }
991    void SortNIdByDat(const bool& Asc=true) { NodeH.SortByDat(Asc); }
992    void SortEIdById(const bool& Asc=true) { EdgeH.SortByKey(Asc); }
993    void SortEIdByDat(const bool& Asc=true) { EdgeH.SortByDat(Asc); }
994    void Defrag(const bool& OnlyNodeLinks=false);
995    bool IsOk(const bool& ThrowExcept=true) const;
996    friend class TPt<TNodeEdgeNet<TNodeData, TEdgeData> >;
997  };
998  namespace TSnap {
999  template <class TNodeData, class TEdgeData> struct IsMultiGraph<TNodeEdgeNet<TNodeData, TEdgeData> > { enum { Val = 1 }; };
1000  template <class TNodeData, class TEdgeData> struct IsDirected<TNodeEdgeNet<TNodeData, TEdgeData> > { enum { Val = 1 }; };
1001  template <class TNodeData, class TEdgeData> struct IsNodeDat<TNodeEdgeNet<TNodeData, TEdgeData> > { enum { Val = 1 }; };
1002  template <class TNodeData, class TEdgeData> struct IsEdgeDat<TNodeEdgeNet<TNodeData, TEdgeData> > { enum { Val = 1 }; };
1003  }
1004  template <class TNodeData, class TEdgeData>
1005  bool TNodeEdgeNet<TNodeData, TEdgeData>::HasFlag(const TGraphFlag& Flag) const {
1006    return HasGraphFlag(typename TNet, Flag);
1007  }
1008  template <class TNodeData, class TEdgeData>
1009  bool TNodeEdgeNet<TNodeData, TEdgeData>::TNodeI::IsInNId(const int& NId) const {
1010    const TNode& Node = NodeHI.GetDat();
1011    for (int edge = 0; edge < Node.GetInDeg(); edge++) {
1012      if (NId == Net->GetEdge(Node.GetInEId(edge)).GetSrcNId())
1013        return true;
1014    }
1015    return false;
1016  }
1017  template <class TNodeData, class TEdgeData>
1018  bool TNodeEdgeNet<TNodeData, TEdgeData>::TNodeI::IsOutNId(const int& NId) const {
1019    const TNode& Node = NodeHI.GetDat();
1020    for (int edge = 0; edge < Node.GetOutDeg(); edge++) {
1021      if (NId == Net->GetEdge(Node.GetOutEId(edge)).GetDstNId())
1022        return true;
1023    }
1024    return false;
1025  }
1026  template <class TNodeData, class TEdgeData>
1027  int TNodeEdgeNet<TNodeData, TEdgeData>::AddNode(int NId) {
1028    if (NId == -1) {
1029      NId = MxNId;  MxNId++;
1030    } else {
1031      IAssertR(!IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
1032      MxNId = TMath::Mx(NId+1, MxNId());
1033    }
1034    NodeH.AddDat(NId, TNode(NId));
1035    return NId;
1036  }
1037  template <class TNodeData, class TEdgeData>
1038  int TNodeEdgeNet<TNodeData, TEdgeData>::AddNodeUnchecked(int NId) {
1039    if (NId == -1) {
1040      NId = MxNId;  MxNId++;
1041    } else {
1042      if (IsNode(NId)) { return -1;}
1043      MxNId = TMath::Mx(NId+1, MxNId());
1044    }
1045    NodeH.AddDat(NId, TNode(NId));
1046    return NId;
1047  }
1048  template <class TNodeData, class TEdgeData>
1049  int TNodeEdgeNet<TNodeData, TEdgeData>::AddNode(int NId, const TNodeData& NodeDat) {
1050    if (NId == -1) {
1051      NId = MxNId;  MxNId++;
1052    } else {
1053      IAssertR(!IsNode(NId), TStr::Fmt("NodeId %d already exists", NId));
1054      MxNId = TMath::Mx(NId+1, MxNId());
1055    }
1056    NodeH.AddDat(NId, TNode(NId, NodeDat));
1057    return NId;
1058  }
1059  template <class TNodeData, class TEdgeData>
1060  void TNodeEdgeNet<TNodeData, TEdgeData>::DelNode(const int& NId) {
1061    const TNode& Node = GetNode(NId);
1062    for (int out = 0; out < Node.GetOutDeg(); out++) {
1063      const int EId = Node.GetOutEId(out);
1064      const TEdge& Edge = GetEdge(EId);
1065      IAssert(Edge.GetSrcNId() == NId);
1066      GetNode(Edge.GetDstNId()).InEIdV.DelIfIn(EId);
1067      EdgeH.DelKey(EId);
1068    }
1069    for (int in = 0; in < Node.GetInDeg(); in++) {
1070      const int EId = Node.GetInEId(in);
1071      const TEdge& Edge = GetEdge(EId);
1072      IAssert(Edge.GetDstNId() == NId);
1073      GetNode(Edge.GetSrcNId()).OutEIdV.DelIfIn(EId);
1074      EdgeH.DelKey(EId);
1075    }
1076    NodeH.DelKey(NId);
1077  }
1078  template <class TNodeData, class TEdgeData>
1079  void TNodeEdgeNet<TNodeData, TEdgeData>::SetNDat(const int& NId, const TNodeData& NodeDat) {
1080    IAssertR(IsNode(NId), TStr::Fmt("NodeId %d does not exist.", NId).CStr());
1081    NodeH.GetDat(NId).NodeDat = NodeDat;
1082  }
1083  template <class TNodeData, class TEdgeData>
1084  int TNodeEdgeNet<TNodeData, TEdgeData>::GetUniqEdges(const bool& IsDir) const {
1085    TIntPrSet UniqESet(GetEdges());
1086    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
1087      const int Src = EI.GetSrcNId();
1088      const int Dst = EI.GetDstNId();
1089      if (IsDir) { UniqESet.AddKey(TIntPr(Src, Dst)); }
1090      else { UniqESet.AddKey(TIntPr(TMath::Mn(Src, Dst), TMath::Mx(Src, Dst))); }
1091    }
1092    return UniqESet.Len();
1093  }
1094  template <class TNodeData, class TEdgeData>
1095  int TNodeEdgeNet<TNodeData, TEdgeData>::AddEdge(const int& SrcNId, const int& DstNId, int EId) {
1096    if (EId == -1) { EId = MxEId;  MxEId++; }
1097    else { MxEId = TMath::Mx(EId+1, MxEId()); }
1098    IAssertR(!IsEdge(EId), TStr::Fmt("EdgeId %d already exists", EId));
1099    IAssertR(IsNode(SrcNId) && IsNode(DstNId), TStr::Fmt("%d or %d not a node.", SrcNId, DstNId).CStr());
1100    EdgeH.AddDat(EId, TEdge(EId, SrcNId, DstNId));
1101    GetNode(SrcNId).OutEIdV.AddSorted(EId);
1102    GetNode(DstNId).InEIdV.AddSorted(EId);
1103    return EId;
1104  }
1105  template <class TNodeData, class TEdgeData>
1106  int TNodeEdgeNet<TNodeData, TEdgeData>::AddEdge(const int& SrcNId, const int& DstNId, int EId, const TEdgeData& EdgeDat) {
1107    if (EId == -1) { EId = MxEId;  MxEId++; }
1108    else { MxEId = TMath::Mx(EId+1, MxEId()); }
1109    IAssertR(!IsEdge(EId), TStr::Fmt("EdgeId %d already exists", EId));
1110    IAssertR(IsNode(SrcNId) && IsNode(DstNId), TStr::Fmt("%d or %d not a node.", SrcNId, DstNId).CStr());
1111    EdgeH.AddDat(EId, TEdge(EId, SrcNId, DstNId, EdgeDat));
1112    GetNode(SrcNId).OutEIdV.AddSorted(EId);
1113    GetNode(DstNId).InEIdV.AddSorted(EId);
1114    return EId;
1115  }
1116  template <class TNodeData, class TEdgeData>
1117  void TNodeEdgeNet<TNodeData, TEdgeData>::DelEdge(const int& EId) {
1118    IAssert(IsEdge(EId));
1119    const int SrcNId = GetEdge(EId).GetSrcNId();
1120    const int DstNId = GetEdge(EId).GetDstNId();
1121    GetNode(SrcNId).OutEIdV.DelIfIn(EId);
1122    GetNode(DstNId).InEIdV.DelIfIn(EId);
1123    EdgeH.DelKey(EId);
1124  }
1125  template <class TNodeData, class TEdgeData>
1126  void TNodeEdgeNet<TNodeData, TEdgeData>::DelEdge(const int& SrcNId, const int& DstNId, const bool& IsDir) {
1127    int EId;
1128    IAssert(IsEdge(SrcNId, DstNId, EId, IsDir));
1129    GetNode(SrcNId).OutEIdV.DelIfIn(EId);
1130    GetNode(DstNId).InEIdV.DelIfIn(EId);
1131    EdgeH.DelKey(EId);
1132  }
1133  template <class TNodeData, class TEdgeData>
1134  bool TNodeEdgeNet<TNodeData, TEdgeData>::IsEdge(const int& SrcNId, const int& DstNId, int& EId, const bool& IsDir) const {
1135    if (! IsNode(SrcNId)) { return false; }
1136    if (! IsNode(DstNId)) { return false; }
1137    const TNode& SrcNode = GetNode(SrcNId);
1138    for (int edge = 0; edge < SrcNode.GetOutDeg(); edge++) {
1139      const TEdge& Edge = GetEdge(SrcNode.GetOutEId(edge));
1140      if (DstNId == Edge.GetDstNId()) {
1141        EId = Edge.GetId();  return true; }
1142    }
1143    if (! IsDir) {
1144      for (int edge = 0; edge < SrcNode.GetInDeg(); edge++) {
1145      const TEdge& Edge = GetEdge(SrcNode.GetInEId(edge));
1146      if (DstNId == Edge.GetSrcNId()) {
1147        EId = Edge.GetId();  return true; }
1148      }
1149    }
1150    return false;
1151  }
1152  template <class TNodeData, class TEdgeData>
1153  void TNodeEdgeNet<TNodeData, TEdgeData>::SetEDat(const int& EId, const TEdgeData& EdgeDat) {
1154    IAssertR(IsEdge(EId), TStr::Fmt("EdgeId %d does not exist.", EId).CStr());
1155    GetEI(EId).GetDat() = EdgeDat;
1156  }
1157  template <class TNodeData, class TEdgeData>
1158  void TNodeEdgeNet<TNodeData, TEdgeData>::SetAllEDat(const TEdgeData& EdgeDat) {
1159    for (TEdgeI EI = BegEI(); EI < EndEI(); EI++) {
1160      EI() = EdgeDat;
1161    }
1162  }
1163  template <class TNodeData, class TEdgeData>
1164  void TNodeEdgeNet<TNodeData, TEdgeData>::GetNIdV(TIntV& NIdV) const {
1165    NIdV.Gen(GetNodes(), 0);
1166    for (int N=NodeH.FFirstKeyId(); NodeH.FNextKeyId(N);) {
1167      NIdV.Add(NodeH.GetKey(N));
1168    }
1169  }
1170  template <class TNodeData, class TEdgeData>
1171  void TNodeEdgeNet<TNodeData, TEdgeData>::GetEIdV(TIntV& EIdV) const {
1172    EIdV.Gen(GetEdges(), 0);
1173    for (int E=EdgeH.FFirstKeyId(); EdgeH.FNextKeyId(E);) {
1174      EIdV.Add(EdgeH.GetKey(E));
1175    }
1176  }
1177  template <class TNodeData, class TEdgeData>
1178  void TNodeEdgeNet<TNodeData, TEdgeData>::Defrag(const bool& OnlyNodeLinks) {
1179    for (int kid = NodeH.FFirstKeyId(); NodeH.FNextKeyId(kid);) {
1180      TNode& Node = NodeH[kid];
1181      Node.InEIdV.Pack();  Node.OutEIdV.Pack();
1182    }
1183    if (! OnlyNodeLinks && ! NodeH.IsKeyIdEqKeyN()) { NodeH.Defrag(); }
1184    if (! OnlyNodeLinks && ! EdgeH.IsKeyIdEqKeyN()) { EdgeH.Defrag(); }
1185  }
1186  template <class TNodeData, class TEdgeData>
1187  bool TNodeEdgeNet<TNodeData, TEdgeData>::IsOk(const bool& ThrowExcept) const {
1188    bool RetVal = true;
1189    for (int N = NodeH.FFirstKeyId(); NodeH.FNextKeyId(N); ) {
1190      const TNode& Node = NodeH[N];
1191      if (! Node.OutEIdV.IsSorted()) {
1192        const TStr Msg = TStr::Fmt("Out-edge list of node %d is not sorted.", Node.GetId());
1193        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
1194      }
1195      if (! Node.InEIdV.IsSorted()) {
1196        const TStr Msg = TStr::Fmt("In-edge list of node %d is not sorted.", Node.GetId());
1197        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
1198      }
1199      int prevEId = -1;
1200      for (int e = 0; e < Node.GetOutDeg(); e++) {
1201        if (! IsEdge(Node.GetOutEId(e))) {
1202          const TStr Msg = TStr::Fmt("Out-edge id %d of node %d does not exist.",  Node.GetOutEId(e), Node.GetId());
1203          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
1204        }
1205        if (e > 0 && prevEId == Node.GetOutEId(e)) {
1206          const TStr Msg = TStr::Fmt("Node %d has duplidate out-edge id %d.", Node.GetId(), Node.GetOutEId(e));
1207          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
1208        }
1209        prevEId = Node.GetOutEId(e);
1210      }
1211      prevEId = -1;
1212      for (int e = 0; e < Node.GetInDeg(); e++) {
1213        if (! IsEdge(Node.GetInEId(e))) {
1214          const TStr Msg = TStr::Fmt("Out-edge id %d of node %d does not exist.",  Node.GetInEId(e), Node.GetId());
1215          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
1216        }
1217        if (e > 0 && prevEId == Node.GetInEId(e)) {
1218          const TStr Msg = TStr::Fmt("Node %d has duplidate out-edge id %d.", Node.GetId(), Node.GetInEId(e));
1219          if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
1220        }
1221        prevEId = Node.GetInEId(e);
1222      }
1223    }
1224    for (int E = EdgeH.FFirstKeyId(); EdgeH.FNextKeyId(E); ) {
1225      const TEdge& Edge = EdgeH[E];
1226      if (! IsNode(Edge.GetSrcNId())) {
1227        const TStr Msg = TStr::Fmt("Edge %d source node %d does not exist.", Edge.GetId(), Edge.GetSrcNId());
1228        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
1229      }
1230      if (! IsNode(Edge.GetDstNId())) {
1231        const TStr Msg = TStr::Fmt("Edge %d destination node %d does not exist.", Edge.GetId(), Edge.GetDstNId());
1232        if (ThrowExcept) { EAssertR(false, Msg); } else { ErrNotify(Msg.CStr()); } RetVal=false;
1233      }
1234    }
1235    return RetVal;
1236  }
1237  typedef TNodeEdgeNet<TInt, TInt> TIntNENet;
1238  typedef TPt<TIntNENet> PIntNENet;
1239  typedef TNodeEdgeNet<TFlt, TFlt> TFltNENet;
1240  typedef TPt<TFltNENet> PFltNENet;
1241  class TNEANet;
1242  typedef TPt<TNEANet> PNEANet;
1243  class TNEANet {
1244  public:
1245    typedef TNEANet TNet;
1246    typedef TPt<TNEANet> PNet;
1247  public:
1248    class TNode {
1249    private:
1250      TInt Id;
1251      TIntV InEIdV, OutEIdV;
1252    public:
1253      TNode() : Id(-1), InEIdV(), OutEIdV() { }
1254      TNode(const int& NId) : Id(NId), InEIdV(), OutEIdV() { }
1255      TNode(const TNode& Node) : Id(Node.Id), InEIdV(Node.InEIdV), OutEIdV(Node.OutEIdV) { }
1256      TNode(TSIn& SIn) : Id(SIn), InEIdV(SIn), OutEIdV(SIn) { }
1257      void Save(TSOut& SOut) const { Id.Save(SOut); InEIdV.Save(SOut); OutEIdV.Save(SOut); }
1258      int GetId() const { return Id; }
1259      int GetDeg() const { return GetInDeg() + GetOutDeg(); }
1260      int GetInDeg() const { return InEIdV.Len(); }
1261      int GetOutDeg() const { return OutEIdV.Len(); }
1262      int GetInEId(const int& EdgeN) const { return InEIdV[EdgeN]; }
1263      int GetOutEId(const int& EdgeN) const { return OutEIdV[EdgeN]; }
1264      int GetNbrEId(const int& EdgeN) const { return EdgeN<GetOutDeg()?GetOutEId(EdgeN):GetInEId(EdgeN-GetOutDeg()); }
1265      bool IsInEId(const int& EId) const { return InEIdV.SearchBin(EId) != -1; }
1266      bool IsOutEId(const int& EId) const { return OutEIdV.SearchBin(EId) != -1; }
1267      void LoadShM(TShMIn& MStream) {
1268        Id = TInt(MStream);
1269        InEIdV.LoadShM(MStream);
1270        OutEIdV.LoadShM(MStream);
1271      }
1272      friend class TNEANet;
1273    };
1274    class TEdge {
1275    private:
1276      TInt Id, SrcNId, DstNId;
1277    public:
1278      TEdge() : Id(-1), SrcNId(-1), DstNId(-1) { }
1279      TEdge(const int& EId, const int& SourceNId, const int& DestNId) : Id(EId), SrcNId(SourceNId), DstNId(DestNId) { }
1280      TEdge(const TEdge& Edge) : Id(Edge.Id), SrcNId(Edge.SrcNId), DstNId(Edge.DstNId) { }
1281      TEdge(TSIn& SIn) : Id(SIn), SrcNId(SIn), DstNId(SIn) { }
1282      void Save(TSOut& SOut) const { Id.Save(SOut); SrcNId.Save(SOut); DstNId.Save(SOut); }
1283      int GetId() const { return Id; }
1284      int GetSrcNId() const { return SrcNId; }
1285      int GetDstNId() const { return DstNId; }
1286      void Load(TSIn& InStream) {
1287        Id = TInt(InStream);
1288        SrcNId = TInt(InStream);
1289        DstNId = TInt(InStream);
1290      }
1291      friend class TNEANet;
1292    };
1293    class TNodeI {
1294    protected:
1295      typedef THash<TInt, TNode>::TIter THashIter;
1296      THashIter NodeHI;
1297      const TNEANet *Graph;
1298    public:
1299      TNodeI() : NodeHI(), Graph(NULL) { }
1300      TNodeI(const THashIter& NodeHIter, const TNEANet* GraphPt) : NodeHI(NodeHIter), Graph(GraphPt) { }
1301      TNodeI(const TNodeI& NodeI) : NodeHI(NodeI.NodeHI), Graph(NodeI.Graph) { }
1302      TNodeI& operator = (const TNodeI& NodeI) { NodeHI = NodeI.NodeHI; Graph=NodeI.Graph; return *this; }
1303      TNodeI& operator++ (int) { NodeHI++; return *this; }
1304      bool operator < (const TNodeI& NodeI) const { return NodeHI < NodeI.NodeHI; }
1305      bool operator == (const TNodeI& NodeI) const { return NodeHI == NodeI.NodeHI; }
1306      int GetId() const { return NodeHI.GetDat().GetId(); }
1307      int GetDeg() const { return NodeHI.GetDat().GetDeg(); }
1308      int GetInDeg() const { return NodeHI.GetDat().GetInDeg(); }
1309      int GetOutDeg() const { return NodeHI.GetDat().GetOutDeg(); }
1310      int GetInNId(const int& EdgeN) const { return Graph->GetEdge(NodeHI.GetDat().GetInEId(EdgeN)).GetSrcNId(); }
1311      int GetOutNId(const int& EdgeN) const { return Graph->GetEdge(NodeHI.GetDat().GetOutEId(EdgeN)).GetDstNId(); }
1312      int GetNbrNId(const int& EdgeN) const { const TEdge& E = Graph->GetEdge(NodeHI.GetDat().GetNbrEId(EdgeN)); return GetId()==E.GetSrcNId() ? E.GetDstNId():E.GetSrcNId(); }
1313      bool IsInNId(const int& NId) const;
1314      bool IsOutNId(const int& NId) const;
1315      bool IsNbrNId(const int& NId) const { return IsOutNId(NId) || IsInNId(NId); }
1316      int GetInEId(const int& EdgeN) const { return NodeHI.GetDat().GetInEId(EdgeN); }
1317      int GetOutEId(const int& EdgeN) const { return NodeHI.GetDat().GetOutEId(EdgeN); }
1318      int GetNbrEId(const int& EdgeN) const { return NodeHI.GetDat().GetNbrEId(EdgeN); }
1319      bool IsInEId(const int& EId) const { return NodeHI.GetDat().IsInEId(EId); }
1320      bool IsOutEId(const int& EId) const { return NodeHI.GetDat().IsOutEId(EId); }
1321      bool IsNbrEId(const int& EId) const { return IsInEId(EId) || IsOutEId(EId); }
1322      void GetAttrNames(TStrV& Names) const { Graph->AttrNameNI(GetId(), Names); }
1323      void GetAttrVal(TStrV& Val) const { Graph->AttrValueNI(GetId(), Val); }
1324      void GetIntAttrNames(TStrV& Names) const { Graph->IntAttrNameNI(GetId(), Names); }
1325      void GetIntAttrVal(TIntV& Val) const { Graph->IntAttrValueNI(GetId(), Val); }
1326      void GetIntVAttrNames(TStrV& Names) const { Graph->IntVAttrNameNI(GetId(), Names); }
1327      void GetIntVAttrVal(TVec<TIntV>& Val) const { Graph->IntVAttrValueNI(GetId(), Val); }
1328      void GetStrAttrNames(TStrV& Names) const { Graph->StrAttrNameNI(GetId(), Names); }
1329      void GetStrAttrVal(TStrV& Val) const { Graph->StrAttrValueNI(GetId(), Val); }
1330      void GetFltAttrNames(TStrV& Names) const { Graph->FltAttrNameNI(GetId(), Names); }
1331      void GetFltAttrVal(TFltV& Val) const { Graph->FltAttrValueNI(GetId(), Val); }
1332      friend class TNEANet;
1333    };
1334    class TEdgeI {
1335    private:
1336      typedef THash<TInt, TEdge>::TIter THashIter;
1337      THashIter EdgeHI;
1338      const TNEANet *Graph;
1339    public:
1340      TEdgeI() : EdgeHI(), Graph(NULL) { }
1341      TEdgeI(const THashIter& EdgeHIter, const TNEANet *GraphPt) : EdgeHI(EdgeHIter), Graph(GraphPt) { }
1342      TEdgeI(const TEdgeI& EdgeI) : EdgeHI(EdgeI.EdgeHI), Graph(EdgeI.Graph) { }
1343      TEdgeI& operator = (const TEdgeI& EdgeI) { if (this!=&EdgeI) { EdgeHI=EdgeI.EdgeHI; Graph=EdgeI.Graph; }  return *this; }
1344      TEdgeI& operator++ (int) { EdgeHI++; return *this; }
1345      bool operator < (const TEdgeI& EdgeI) const { return EdgeHI < EdgeI.EdgeHI; }
1346      bool operator == (const TEdgeI& EdgeI) const { return EdgeHI == EdgeI.EdgeHI; }
1347      int GetId() const { return EdgeHI.GetDat().GetId(); }
1348      int GetSrcNId() const { return EdgeHI.GetDat().GetSrcNId(); }
1349      int GetDstNId() const { return EdgeHI.GetDat().GetDstNId(); }
1350      void GetAttrNames(TStrV& Names) const { Graph->AttrNameEI(GetId(), Names); }
1351      void GetAttrVal(TStrV& Val) const { Graph->AttrValueEI(GetId(), Val); }
1352      void GetIntAttrNames(TStrV& Names) const { Graph->IntAttrNameEI(GetId(), Names); }
1353      void GetIntAttrVal(TIntV& Val) const { Graph->IntAttrValueEI(GetId(), Val); }
1354      void GetIntVAttrNames(TStrV& Names) const { Graph->IntVAttrNameEI(GetId(), Names); }
1355      void GetIntVAttrVal(TVec<TIntV>& Val) const { Graph->IntVAttrValueEI(GetId(), Val); }
1356      void GetStrAttrNames(TStrV& Names) const { Graph->StrAttrNameEI(GetId(), Names); }
1357      void GetStrAttrVal(TStrV& Val) const { Graph->StrAttrValueEI(GetId(), Val); }
1358      void GetFltAttrNames(TStrV& Names) const { Graph->FltAttrNameEI(GetId(), Names); }
1359      void GetFltAttrVal(TFltV& Val) const { Graph->FltAttrValueEI(GetId(), Val); }
1360      friend class TNEANet;
1361    };
1362    class TAIntI {
1363    private:
1364      typedef TIntV::TIter TIntVecIter;
1365      TIntVecIter HI;
1366      bool isNode;
1367      TStr attr;
1368      const TNEANet *Graph;
1369    public:
1370      TAIntI() : HI(), attr(), Graph(NULL) { }
1371      TAIntI(const TIntVecIter& HIter, TStr attribute, bool isEdgeIter, const TNEANet* GraphPt) : HI(HIter), attr(), Graph(GraphPt) { isNode = !isEdgeIter; attr = attribute; }
1372      TAIntI(const TAIntI& I) : HI(I.HI), attr(I.attr), Graph(I.Graph) { isNode = I.isNode; }
1373      TAIntI& operator = (const TAIntI& I) { HI = I.HI; Graph=I.Graph; isNode = I.isNode; attr = I.attr; return *this; }
1374      bool operator < (const TAIntI& I) const { return HI < I.HI; }
1375      bool operator == (const TAIntI& I) const { return HI == I.HI; }
1376      TInt GetDat() const { return HI[0]; }
1377      bool IsDeleted() const { return isNode ? GetDat() == Graph->GetIntAttrDefaultN(attr) : GetDat() == Graph->GetIntAttrDefaultE(attr); };
1378      TAIntI& operator++(int) { HI++; return *this; }
1379      friend class TNEANet;
1380    };
1381    class TAIntVI {
1382    private:
1383      typedef TVec<TIntV>::TIter TIntVVecIter;
1384      TIntVVecIter HI;
1385      bool IsDense;
1386      typedef THash<TInt, TIntV>::TIter TIntHVecIter;
1387      TIntHVecIter HHI;
1388      bool isNode;
1389      TStr attr;
1390      const TNEANet *Graph;
1391    public:
1392      TAIntVI() : HI(), IsDense(), HHI(), attr(), Graph(NULL) { }
1393      TAIntVI(const TIntVVecIter& HIter, const TIntHVecIter& HHIter, TStr attribute, bool isEdgeIter, const TNEANet* GraphPt, bool is_dense) : HI(HIter), IsDense(is_dense), HHI(HHIter), attr(), Graph(GraphPt) {
1394        isNode = !isEdgeIter; attr = attribute;
1395      }
1396      TAIntVI(const TAIntVI& I) : HI(I.HI), IsDense(I.IsDense), HHI(I.HHI), attr(I.attr), Graph(I.Graph) { isNode = I.isNode; }
1397      TAIntVI& operator = (const TAIntVI& I) { HI = I.HI; HHI = I.HHI, Graph=I.Graph; isNode = I.isNode; attr = I.attr; return *this; }
1398      bool operator < (const TAIntVI& I) const { return HI == I.HI ? HHI < I.HHI : HI < I.HI; }
1399      bool operator == (const TAIntVI& I) const { return HI == I.HI && HHI == I.HHI; }
1400      TIntV GetDat() const { return IsDense? HI[0] : HHI.GetDat(); }
1401      TAIntVI& operator++(int) { if (IsDense) {HI++;} else {HHI++;} return *this; }
1402      friend class TNEANet;
1403    };
1404    class TAFltVI {
1405    private:
1406      typedef TVec<TFltV>::TIter TFltVVecIter;
1407      TFltVVecIter HI;
1408      bool IsDense;
1409      typedef THash<TInt, TFltV>::TIter TFltHVecIter;
1410      TFltHVecIter HHI;
1411      bool isNode;
1412      TStr attr;
1413      const TNEANet *Graph;
1414    public:
1415      TAFltVI() : HI(), IsDense(), HHI(), attr(), Graph(NULL) { }
1416      TAFltVI(const TFltVVecIter& HIter, const TFltHVecIter& HHIter, TStr attribute, bool isEdgeIter, const TNEANet* GraphPt, bool is_dense) : HI(HIter), IsDense(is_dense), HHI(HHIter), attr(), Graph(GraphPt) {
1417        isNode = !isEdgeIter; attr = attribute;
1418      }
1419      TAFltVI(const TAFltVI& I) : HI(I.HI), IsDense(I.IsDense), HHI(I.HHI), attr(I.attr), Graph(I.Graph) { isNode = I.isNode; }
1420      TAFltVI& operator = (const TAFltVI& I) { HI = I.HI; HHI = I.HHI, Graph=I.Graph; isNode = I.isNode; attr = I.attr; return *this; }
1421      bool operator < (const TAFltVI& I) const { return HI == I.HI ? HHI < I.HHI : HI < I.HI; }
1422      bool operator == (const TAFltVI& I) const { return HI == I.HI && HHI == I.HHI; }
1423      TFltV GetDat() const { return IsDense? HI[0] : HHI.GetDat(); }
1424      TAFltVI& operator++(int) { if (IsDense) {HI++;} else {HHI++;} return *this; }
1425      friend class TNEANet;
1426    };
1427    class TAStrI {
1428    private:
1429      typedef TStrV::TIter TStrVecIter;
1430      TStrVecIter HI;
1431      bool isNode;
1432      TStr attr;
1433      const TNEANet *Graph;
1434    public:
1435      TAStrI() : HI(), attr(), Graph(NULL) { }
1436      TAStrI(const TStrVecIter& HIter, TStr attribute, bool isEdgeIter, const TNEANet* GraphPt) : HI(HIter), attr(), Graph(GraphPt) { isNode = !isEdgeIter; attr = attribute; }
1437      TAStrI(const TAStrI& I) : HI(I.HI), attr(I.attr), Graph(I.Graph) { isNode = I.isNode; }
1438      TAStrI& operator = (const TAStrI& I) { HI = I.HI; Graph=I.Graph; isNode = I.isNode; attr = I.attr; return *this; }
1439      bool operator < (const TAStrI& I) const { return HI < I.HI; }
1440      bool operator == (const TAStrI& I) const { return HI == I.HI; }
1441      TStr GetDat() const { return HI[0]; }
1442      bool IsDeleted() const { return isNode ? GetDat() == Graph->GetStrAttrDefaultN(attr) : GetDat() == Graph->GetStrAttrDefaultE(attr); };
1443      TAStrI& operator++(int) { HI++; return *this; }
1444      friend class TNEANet;
1445    };
1446    class TAFltI {
1447    private:
1448      typedef TFltV::TIter TFltVecIter;
1449      TFltVecIter HI;
1450      bool isNode;
1451      TStr attr;
1452      const TNEANet *Graph;
1453    public:
1454      TAFltI() : HI(), attr(), Graph(NULL) { }
1455      TAFltI(const TFltVecIter& HIter, TStr attribute, bool isEdgeIter, const TNEANet* GraphPt) : HI(HIter), attr(), Graph(GraphPt) { isNode = !isEdgeIter; attr = attribute; }
1456      TAFltI(const TAFltI& I) : HI(I.HI), attr(I.attr), Graph(I.Graph) { isNode = I.isNode; }
1457      TAFltI& operator = (const TAFltI& I) { HI = I.HI; Graph=I.Graph; isNode = I.isNode; attr = I.attr; return *this; }
1458      bool operator < (const TAFltI& I) const { return HI < I.HI; }
1459      bool operator == (const TAFltI& I) const { return HI == I.HI; }
1460      TFlt GetDat() const { return HI[0]; }
1461      bool IsDeleted() const { return isNode ? GetDat() == Graph->GetFltAttrDefaultN(attr) : GetDat() == Graph->GetFltAttrDefaultE(attr); };
1462      TAFltI& operator++(int) { HI++; return *this; }
1463      friend class TNEANet;
1464    };
1465  protected:
1466    TNode& GetNode(const int& NId) { return NodeH.GetDat(NId); }
1467    const TNode& GetNode(const int& NId) const { return NodeH.GetDat(NId); }
1468    TEdge& GetEdge(const int& EId) { return EdgeH.GetDat(EId); }
1469    const TEdge& GetEdge(const int& EId) const { return EdgeH.GetDat(EId); }
1470    int AddAttributes(const int NId);
1471  protected:
1472    TInt GetIntAttrDefaultN(const TStr& attribute) const { return IntDefaultsN.IsKey(attribute) ? IntDefaultsN.GetDat(attribute) : (TInt) TInt::Mn; }
1473    TStr GetStrAttrDefaultN(const TStr& attribute) const { return StrDefaultsN.IsKey(attribute) ? StrDefaultsN.GetDat(attribute) : (TStr) TStr::GetNullStr(); }
1474    TFlt GetFltAttrDefaultN(const TStr& attribute) const { return FltDefaultsN.IsKey(attribute) ? FltDefaultsN.GetDat(attribute) : (TFlt) TFlt::Mn; }
1475    TInt GetIntAttrDefaultE(const TStr& attribute) const { return IntDefaultsE.IsKey(attribute) ? IntDefaultsE.GetDat(attribute) : (TInt) TInt::Mn; }
1476    TStr GetStrAttrDefaultE(const TStr& attribute) const { return StrDefaultsE.IsKey(attribute) ? StrDefaultsE.GetDat(attribute) : (TStr) TStr::GetNullStr(); }
1477    TFlt GetFltAttrDefaultE(const TStr& attribute) const { return FltDefaultsE.IsKey(attribute) ? FltDefaultsE.GetDat(attribute) : (TFlt) TFlt::Mn; }
1478  public:
1479    TCRef CRef;
1480  protected:
1481    TInt MxNId, MxEId;
1482    THash<TInt, TNode> NodeH;
1483    THash<TInt, TEdge> EdgeH;
1484    TStrIntPrH KeyToIndexTypeN, KeyToIndexTypeE;
1485    THash<TStr, TBool> KeyToDenseN, KeyToDenseE;
1486    THash<TStr, TInt> IntDefaultsN, IntDefaultsE;
1487    THash<TStr, TStr> StrDefaultsN, StrDefaultsE;
1488    THash<TStr, TFlt> FltDefaultsN, FltDefaultsE;
1489    TVec<TIntV> VecOfIntVecsN, VecOfIntVecsE;
1490    TVec<TStrV> VecOfStrVecsN, VecOfStrVecsE;
1491    TVec<TFltV> VecOfFltVecsN, VecOfFltVecsE;
1492    TVec<TVec<TIntV> > VecOfIntVecVecsN, VecOfIntVecVecsE;
1493    TVec<TVec<TFltV> > VecOfFltVecVecsN, VecOfFltVecVecsE; 
1494    TVec<THash<TInt, TIntV> > VecOfIntHashVecsN, VecOfIntHashVecsE;
1495    TVec<THash<TInt, TFltV> > VecOfFltHashVecsN, VecOfFltHashVecsE;
1496    enum { IntType, StrType, FltType, IntVType, FltVType };
1497    TAttr SAttrN;
1498    TAttr SAttrE;
1499  private:
1500    class LoadTNodeFunctor {
1501    public:
1502      LoadTNodeFunctor() {}
1503      void operator() (TNode* n, TShMIn& ShMIn) { n->LoadShM(ShMIn);}
1504    };
1505    class LoadVecFunctor {
1506    public:
1507      LoadVecFunctor() {}
1508      template<typename TElem>
1509      void operator() (TVec<TElem>* n, TShMIn& ShMIn) {
1510        n->LoadShM(ShMIn);
1511      }
1512    };
1513    class LoadVecOfVecFunctor {
1514    public:
1515      LoadVecOfVecFunctor() {}
1516      template<typename TElem>
1517      void operator() (TVec<TVec<TElem> >* n, TShMIn& ShMIn) {
1518        LoadVecFunctor f;
1519        n->LoadShM(ShMIn, f);
1520      }
1521    };
1522    class LoadHashOfVecFunctor {
1523    public:
1524      LoadHashOfVecFunctor() {}
1525      template<typename TElem>
1526      void operator() (THash<TInt, TVec<TElem> >* n, TShMIn& ShMIn) {
1527        LoadVecFunctor f;
1528        n->LoadShM(ShMIn, f);
1529      }
1530    };
1531  protected:
1532    TInt CheckDenseOrSparseN(const TStr& attr) const {
1533      if (!KeyToDenseN.IsKey(attr)) return -1;
1534      if (KeyToDenseN.GetDat(attr)) return 1;
1535      return 0;
1536    }
1537    TInt CheckDenseOrSparseE(const TStr& attr) const {
1538      if (!KeyToDenseE.IsKey(attr)) return -1;
1539      if (KeyToDenseE.GetDat(attr)) return 1;
1540      return 0;
1541    }
1542  public:
1543    TNEANet() : CRef(), MxNId(0), MxEId(0), NodeH(), EdgeH(),
1544      KeyToIndexTypeN(), KeyToIndexTypeE(), KeyToDenseN(), KeyToDenseE(), IntDefaultsN(), IntDefaultsE(),
1545      StrDefaultsN(), StrDefaultsE(), FltDefaultsN(), FltDefaultsE(),
1546      VecOfIntVecsN(), VecOfIntVecsE(), VecOfStrVecsN(), VecOfStrVecsE(),
1547      VecOfFltVecsN(), VecOfFltVecsE(),  VecOfIntVecVecsN(), VecOfIntVecVecsE(),
1548      VecOfFltVecVecsN(), VecOfFltVecVecsE(), 
1549      VecOfIntHashVecsN(), VecOfIntHashVecsE(), 
1550      VecOfFltHashVecsN(), VecOfFltHashVecsE(), 
1551      SAttrN(), SAttrE(){ }
1552    explicit TNEANet(const int& Nodes, const int& Edges) : CRef(),
1553      MxNId(0), MxEId(0), NodeH(), EdgeH(), KeyToIndexTypeN(), KeyToIndexTypeE(), KeyToDenseN(), KeyToDenseE(),
1554      IntDefaultsN(), IntDefaultsE(), StrDefaultsN(), StrDefaultsE(),
1555      FltDefaultsN(), FltDefaultsE(), VecOfIntVecsN(), VecOfIntVecsE(),
1556      VecOfStrVecsN(), VecOfStrVecsE(), VecOfFltVecsN(), VecOfFltVecsE(), VecOfIntVecVecsN(), VecOfIntVecVecsE(),
1557      VecOfFltVecVecsN(), VecOfFltVecVecsE(), 
1558      VecOfIntHashVecsN(), VecOfIntHashVecsE(), 
1559      VecOfFltHashVecsN(), VecOfFltHashVecsE(), 
1560      SAttrN(), SAttrE()
1561      { Reserve(Nodes, Edges); }
1562    TNEANet(const TNEANet& Graph) : MxNId(Graph.MxNId), MxEId(Graph.MxEId),
1563      NodeH(Graph.NodeH), EdgeH(Graph.EdgeH), KeyToIndexTypeN(), KeyToIndexTypeE(), KeyToDenseN(), KeyToDenseE(),
1564      IntDefaultsN(), IntDefaultsE(), StrDefaultsN(), StrDefaultsE(),
1565      FltDefaultsN(), FltDefaultsE(), VecOfIntVecsN(), VecOfIntVecsE(),
1566      VecOfStrVecsN(), VecOfStrVecsE(), VecOfFltVecsN(), VecOfFltVecsE(), VecOfIntVecVecsN(), VecOfIntVecVecsE(),
1567      VecOfFltVecVecsN(), VecOfFltVecVecsE(), 
1568      VecOfIntHashVecsN(), VecOfIntHashVecsE(), 
1569      VecOfFltHashVecsN(), VecOfFltHashVecsE(), 
1570      SAttrN(), SAttrE() { }
1571    TNEANet(TSIn& SIn) : MxNId(SIn), MxEId(SIn), NodeH(SIn), EdgeH(SIn),
1572      KeyToIndexTypeN(SIn), KeyToIndexTypeE(SIn), KeyToDenseN(SIn), KeyToDenseE(SIn), IntDefaultsN(SIn), IntDefaultsE(SIn),
1573      StrDefaultsN(SIn), StrDefaultsE(SIn), FltDefaultsN(SIn), FltDefaultsE(SIn),
1574      VecOfIntVecsN(SIn), VecOfIntVecsE(SIn), VecOfStrVecsN(SIn),VecOfStrVecsE(SIn),
1575      VecOfFltVecsN(SIn), VecOfFltVecsE(SIn), VecOfIntVecVecsN(SIn), VecOfIntVecVecsE(SIn), 
1576      VecOfFltVecVecsN(SIn), VecOfFltVecVecsE(SIn), 
1577      VecOfIntHashVecsN(SIn), VecOfIntHashVecsE(SIn),
1578      VecOfFltHashVecsN(SIn), VecOfFltHashVecsE(SIn), 
1579      SAttrN(SIn), SAttrE(SIn) { }
1580  protected:
1581    TNEANet(const TNEANet& Graph, bool modeSubGraph) : MxNId(Graph.MxNId), MxEId(Graph.MxEId),
1582      NodeH(Graph.NodeH), EdgeH(Graph.EdgeH), KeyToIndexTypeN(), KeyToIndexTypeE(Graph.KeyToIndexTypeE), KeyToDenseN(), KeyToDenseE(Graph.KeyToDenseE),
1583      IntDefaultsN(Graph.IntDefaultsN), IntDefaultsE(Graph.IntDefaultsE), StrDefaultsN(Graph.StrDefaultsN), StrDefaultsE(Graph.StrDefaultsE),
1584      FltDefaultsN(Graph.FltDefaultsN), FltDefaultsE(Graph.FltDefaultsE), VecOfIntVecsN(Graph.VecOfIntVecsN), VecOfIntVecsE(Graph.VecOfIntVecsE),
1585      VecOfStrVecsN(Graph.VecOfStrVecsN), VecOfStrVecsE(Graph.VecOfStrVecsE), VecOfFltVecsN(Graph.VecOfFltVecsN), VecOfFltVecsE(Graph.VecOfFltVecsE),
1586      VecOfIntVecVecsN(), VecOfIntVecVecsE(Graph.VecOfIntVecVecsE), 
1587      VecOfFltVecVecsN(), VecOfFltVecVecsE(Graph.VecOfFltVecVecsE), 
1588      VecOfIntHashVecsN(), VecOfIntHashVecsE(Graph.VecOfIntHashVecsE),
1589      VecOfFltHashVecsN(), VecOfFltHashVecsE(Graph.VecOfFltHashVecsE) 
1590       { }
1591    TNEANet(bool copyAll, const TNEANet& Graph) : MxNId(Graph.MxNId), MxEId(Graph.MxEId),
1592      NodeH(Graph.NodeH), EdgeH(Graph.EdgeH), KeyToIndexTypeN(Graph.KeyToIndexTypeN), KeyToIndexTypeE(Graph.KeyToIndexTypeE), KeyToDenseN(Graph.KeyToDenseN), KeyToDenseE(Graph.KeyToDenseE),
1593      IntDefaultsN(Graph.IntDefaultsN), IntDefaultsE(Graph.IntDefaultsE), StrDefaultsN(Graph.StrDefaultsN), StrDefaultsE(Graph.StrDefaultsE),
1594      FltDefaultsN(Graph.FltDefaultsN), FltDefaultsE(Graph.FltDefaultsE), VecOfIntVecsN(Graph.VecOfIntVecsN), VecOfIntVecsE(Graph.VecOfIntVecsE),
1595      VecOfStrVecsN(Graph.VecOfStrVecsN), VecOfStrVecsE(Graph.VecOfStrVecsE), VecOfFltVecsN(Graph.VecOfFltVecsN), VecOfFltVecsE(Graph.VecOfFltVecsE),
1596      VecOfIntVecVecsN(Graph.VecOfIntVecVecsN), VecOfIntVecVecsE(Graph.VecOfIntVecVecsE), 
1597      VecOfFltVecVecsN(Graph.VecOfFltVecVecsN), VecOfFltVecVecsE(Graph.VecOfFltVecVecsE), 
1598      VecOfIntHashVecsN(Graph.VecOfIntHashVecsN), VecOfIntHashVecsE(Graph.VecOfIntHashVecsE), 
1599      VecOfFltHashVecsN(Graph.VecOfFltHashVecsN), VecOfFltHashVecsE(Graph.VecOfFltHashVecsE), 
1600      SAttrN(Graph.SAttrN), SAttrE(Graph.SAttrE) { }
1601  public:
1602    void Save(TSOut& SOut) const {
1603      MxNId.Save(SOut); MxEId.Save(SOut); NodeH.Save(SOut); EdgeH.Save(SOut);
1604      KeyToIndexTypeN.Save(SOut); KeyToIndexTypeE.Save(SOut);
1605      KeyToDenseN.Save(SOut); KeyToDenseE.Save(SOut);
1606      IntDefaultsN.Save(SOut); IntDefaultsE.Save(SOut);
1607      StrDefaultsN.Save(SOut); StrDefaultsE.Save(SOut);
1608      FltDefaultsN.Save(SOut); FltDefaultsE.Save(SOut);
1609      VecOfIntVecsN.Save(SOut); VecOfIntVecsE.Save(SOut);
1610      VecOfStrVecsN.Save(SOut); VecOfStrVecsE.Save(SOut);
1611      VecOfFltVecsN.Save(SOut); VecOfFltVecsE.Save(SOut);
1612      VecOfIntVecVecsN.Save(SOut); VecOfIntVecVecsE.Save(SOut);
1613      VecOfFltVecVecsN.Save(SOut); VecOfFltVecVecsE.Save(SOut); 
1614      VecOfIntHashVecsN.Save(SOut); VecOfIntHashVecsE.Save(SOut); 
1615      VecOfFltHashVecsN.Save(SOut); VecOfFltHashVecsE.Save(SOut); 
1616      SAttrN.Save(SOut); SAttrE.Save(SOut);
1617      SOut.Flush(); }
1618    void Save_V1(TSOut& SOut) const {
1619      MxNId.Save(SOut); MxEId.Save(SOut); NodeH.Save(SOut); EdgeH.Save(SOut);
1620      KeyToIndexTypeN.Save(SOut); KeyToIndexTypeE.Save(SOut);
1621      IntDefaultsN.Save(SOut); IntDefaultsE.Save(SOut);
1622      StrDefaultsN.Save(SOut); StrDefaultsE.Save(SOut);
1623      FltDefaultsN.Save(SOut); FltDefaultsE.Save(SOut);
1624      VecOfIntVecsN.Save(SOut); VecOfIntVecsE.Save(SOut);
1625      VecOfStrVecsN.Save(SOut); VecOfStrVecsE.Save(SOut);
1626      VecOfFltVecsN.Save(SOut); VecOfFltVecsE.Save(SOut);
1627      SOut.Flush(); }
1628    void Save_V2(TSOut& SOut) const {
1629      MxNId.Save(SOut); MxEId.Save(SOut); NodeH.Save(SOut); EdgeH.Save(SOut);
1630      KeyToIndexTypeN.Save(SOut); KeyToIndexTypeE.Save(SOut);
1631      IntDefaultsN.Save(SOut); IntDefaultsE.Save(SOut);
1632      StrDefaultsN.Save(SOut); StrDefaultsE.Save(SOut);
1633      FltDefaultsN.Save(SOut); FltDefaultsE.Save(SOut);
1634      VecOfIntVecsN.Save(SOut); VecOfIntVecsE.Save(SOut);
1635      VecOfStrVecsN.Save(SOut); VecOfStrVecsE.Save(SOut);
1636      VecOfFltVecsN.Save(SOut); VecOfFltVecsE.Save(SOut);
1637      VecOfIntVecVecsN.Save(SOut); VecOfIntVecVecsE.Save(SOut); 
1638      VecOfFltVecVecsN.Save(SOut); VecOfFltVecVecsE.Save(SOut); 
1639      SAttrN.Save(SOut); SAttrE.Save(SOut);
1640      SOut.Flush(); }
1641    static PNEANet New() { return PNEANet(new TNEANet()); }
1642    static PNEANet New(const int& Nodes, const int& Edges) { return PNEANet(new TNEANet(Nodes, Edges)); }
1643    static PNEANet Load(TSIn& SIn) { return PNEANet(new TNEANet(SIn)); }
1644    static PNEANet Load_V1(TSIn& SIn) {
1645      PNEANet Graph = PNEANet(new TNEANet());
1646      Graph->MxNId.Load(SIn); Graph->MxEId.Load(SIn);
1647      Graph->NodeH.Load(SIn); Graph->EdgeH.Load(SIn);
1648      Graph->KeyToIndexTypeN.Load(SIn); Graph->KeyToIndexTypeE.Load(SIn);
1649      Graph->IntDefaultsN.Load(SIn); Graph->IntDefaultsE.Load(SIn);
1650      Graph->StrDefaultsN.Load(SIn); Graph->StrDefaultsE.Load(SIn);
1651      Graph->FltDefaultsN.Load(SIn); Graph->FltDefaultsE.Load(SIn);
1652      Graph->VecOfIntVecsN.Load(SIn); Graph->VecOfIntVecsE.Load(SIn);
1653      Graph->VecOfStrVecsN.Load(SIn); Graph->VecOfStrVecsE.Load(SIn);
1654      Graph->VecOfFltVecsN.Load(SIn); Graph->VecOfFltVecsE.Load(SIn); 
1655      return Graph;
1656    }
1657    static PNEANet Load_V2(TSIn& SIn) {
1658      PNEANet Graph = PNEANet(new TNEANet());
1659      Graph->MxNId.Load(SIn); Graph->MxEId.Load(SIn);
1660      Graph->NodeH.Load(SIn); Graph->EdgeH.Load(SIn);
1661      Graph->KeyToIndexTypeN.Load(SIn); Graph->KeyToIndexTypeE.Load(SIn);
1662      Graph->IntDefaultsN.Load(SIn); Graph->IntDefaultsE.Load(SIn);
1663      Graph->StrDefaultsN.Load(SIn); Graph->StrDefaultsE.Load(SIn);
1664      Graph->FltDefaultsN.Load(SIn); Graph->FltDefaultsE.Load(SIn);
1665      Graph->VecOfIntVecsN.Load(SIn); Graph->VecOfIntVecsE.Load(SIn);
1666      Graph->VecOfStrVecsN.Load(SIn); Graph->VecOfStrVecsE.Load(SIn);
1667      Graph->VecOfFltVecsN.Load(SIn); Graph->VecOfFltVecsE.Load(SIn);
1668      Graph->VecOfIntVecVecsN.Load(SIn); Graph->VecOfIntVecVecsE.Load(SIn);
1669      Graph->VecOfFltVecVecsN.Load(SIn); Graph->VecOfFltVecVecsE.Load(SIn); 
1670      Graph->SAttrN.Load(SIn); Graph->SAttrE.Load(SIn);
1671      return Graph;
1672    }
1673    void LoadNetworkShM(TShMIn& ShMIn);
1674    static PNEANet LoadShM(TShMIn& ShMIn) {
1675      TNEANet* Network = new TNEANet();
1676      Network->LoadNetworkShM(ShMIn);
1677      return PNEANet(Network);
1678    }
1679    void ConvertToSparse() { 
1680      TInt VecLength = VecOfIntVecVecsN.Len();
1681      THash<TStr, TIntPr>::TIter iter;
1682      if (VecLength != 0) {
1683        VecOfIntHashVecsN = TVec<THash<TInt, TIntV> >(VecLength);
1684        for (iter = KeyToIndexTypeN.BegI(); !iter.IsEnd(); iter=iter.Next()) {
1685          if (iter.GetDat().Val1 == IntVType) {
1686            TStr attribute = iter.GetKey();
1687            TInt index = iter.GetDat().Val2();
1688            for (int i=0; i<VecOfIntVecVecsN[index].Len(); i++) {
1689              if(VecOfIntVecVecsN[index][i].Len() > 0) {
1690                VecOfIntHashVecsN[index].AddDat(TInt(i), VecOfIntVecVecsN[index][i]);
1691              }
1692            }
1693            KeyToDenseN.AddDat(attribute, TBool(false));
1694          }
1695        }
1696      }
1697      VecOfIntVecVecsN.Clr();
1698      VecLength = VecOfIntVecVecsE.Len();
1699      if (VecLength != 0) {
1700        VecOfIntHashVecsE = TVec<THash<TInt, TIntV> >(VecLength);
1701        for (iter = KeyToIndexTypeE.BegI(); !iter.IsEnd(); iter=iter.Next()) {
1702          if (iter.GetDat().Val1 == IntVType) {
1703            TStr attribute = iter.GetKey();
1704            TInt index = iter.GetDat().Val2();
1705            for (int i=0; i<VecOfIntVecVecsE[index].Len(); i++) {
1706              if(VecOfIntVecVecsE[index][i].Len() > 0) {
1707                VecOfIntHashVecsE[index].AddDat(TInt(i), VecOfIntVecVecsE[index][i]);
1708              }
1709            }
1710            KeyToDenseE.AddDat(attribute, TBool(false));
1711          }
1712        }
1713      }
1714      VecOfIntVecVecsE.Clr();
1715      VecLength = VecOfFltVecVecsN.Len();
1716      if (VecLength != 0) {
1717        VecOfFltHashVecsN = TVec<THash<TInt, TFltV> >(VecLength);
1718        for (iter = KeyToIndexTypeN.BegI(); !iter.IsEnd(); iter=iter.Next()) {
1719          if (iter.GetDat().Val1 == FltVType) {
1720            TStr attribute = iter.GetKey();
1721            TInt index = iter.GetDat().Val2();
1722            for (int i=0; i<VecOfFltVecVecsN[index].Len(); i++) {
1723              if(VecOfFltVecVecsN[index][i].Len() > 0) {
1724                VecOfFltHashVecsN[index].AddDat(TInt(i), VecOfFltVecVecsN[index][i]);
1725              }
1726            }
1727            KeyToDenseN.AddDat(attribute, TBool(false));
1728          }
1729        }
1730      }
1731      VecOfFltVecVecsN.Clr();
1732      VecLength = VecOfFltVecVecsE.Len();
1733      if (VecLength != 0) {
1734        VecOfFltHashVecsE = TVec<THash<TInt, TFltV> >(VecLength);
1735        for (iter = KeyToIndexTypeE.BegI(); !iter.IsEnd(); iter=iter.Next()) {
1736          if (iter.GetDat().Val1 == FltVType) {
1737            TStr attribute = iter.GetKey();
1738            TInt index = iter.GetDat().Val2();
1739            for (int i=0; i<VecOfFltVecVecsE[index].Len(); i++) {
1740              if(VecOfFltVecVecsE[index][i].Len() > 0) {
1741                VecOfFltHashVecsE[index].AddDat(TInt(i), VecOfFltVecVecsE[index][i]);
1742              }
1743            }
1744            KeyToDenseE.AddDat(attribute, TBool(false));
1745          }
1746        }
1747      }
1748      VecOfFltVecVecsE.Clr();
1749    }
1750    bool HasFlag(const TGraphFlag& Flag) const;
1751    TNEANet& operator = (const TNEANet& Graph) { if (this!=&Graph) {
1752      MxNId=Graph.MxNId; MxEId=Graph.MxEId; NodeH=Graph.NodeH; EdgeH=Graph.EdgeH; }
1753      return *this; }
1754    int GetNodes() const { return NodeH.Len(); }
1755    int AddNode(int NId = -1);
1756    int AddNodeUnchecked(int NId = -1);
1757    int AddNode(const TNodeI& NodeI) { return AddNode(NodeI.GetId()); }
1758    virtual void DelNode(const int& NId);
1759    void DelNode(const TNode& NodeI) { DelNode(NodeI.GetId()); }
1760    bool IsNode(const int& NId) const { return NodeH.IsKey(NId); }
1761    TNodeI BegNI() const { return TNodeI(NodeH.BegI(), this); }
1762    TNodeI EndNI() const { return TNodeI(NodeH.EndI(), this); }
1763    TNodeI GetNI(const int& NId) const { return TNodeI(NodeH.GetI(NId), this); }
1764    TAIntI BegNAIntI(const TStr& attr) const {
1765      return TAIntI(VecOfIntVecsN[KeyToIndexTypeN.GetDat(attr).Val2].BegI(), attr, false, this); }
1766    TAIntI EndNAIntI(const TStr& attr) const {
1767      return TAIntI(VecOfIntVecsN[KeyToIndexTypeN.GetDat(attr).Val2].EndI(), attr, false, this); }
1768    TAIntI GetNAIntI(const TStr& attr, const int& NId) const {
1769      return TAIntI(VecOfIntVecsN[KeyToIndexTypeN.GetDat(attr).Val2].GetI(NodeH.GetKeyId(NId)), attr, false, this); }
1770    TAIntVI BegNAIntVI(const TStr& attr) const {
1771      TVec<TIntV>::TIter HI = NULL;
1772      THash<TInt, TIntV>::TIter HHI;
1773      TInt location = CheckDenseOrSparseN(attr);
1774      TBool IsDense = true;
1775      if (location != -1) {
1776        TInt index = KeyToIndexTypeN.GetDat(attr).Val2;
1777        if (location == 1) {
1778          HI = VecOfIntVecVecsN[index].BegI();
1779        } else {
1780          IsDense = false;
1781          HHI = VecOfIntHashVecsN[index].BegI();
1782        }
1783      }
1784      return TAIntVI(HI, HHI, attr, false, this, IsDense);
1785    }
1786    TAIntVI EndNAIntVI(const TStr& attr) const {
1787      TVec<TIntV>::TIter HI = NULL;
1788      THash<TInt, TIntV>::TIter HHI;
1789      TInt location = CheckDenseOrSparseN(attr);
1790      TBool IsDense = true;
1791      if (location != -1) {
1792        TInt index = KeyToIndexTypeN.GetDat(attr).Val2;
1793        if (location == 1) {
1794          HI = VecOfIntVecVecsN[index].EndI();
1795        } else {
1796          IsDense = false;
1797          HHI = VecOfIntHashVecsN[index].EndI();
1798        }
1799      }
1800      return TAIntVI(HI, HHI, attr, false, this, IsDense);
1801    }
1802    TAIntVI GetNAIntVI(const TStr& attr, const int& NId) const {
1803      TVec<TIntV>::TIter HI = NULL;
1804      THash<TInt, TIntV>::TIter HHI;
1805      TInt location = CheckDenseOrSparseN(attr);
1806      TBool IsDense = true;
1807      if (location != -1) {
1808        TInt index = KeyToIndexTypeN.GetDat(attr).Val2;
1809        if (location == 1) {
1810          HI = VecOfIntVecVecsN[index].GetI(NodeH.GetKeyId(NId));
1811        } else {
1812          IsDense = false;
1813          HHI = VecOfIntHashVecsN[index].GetI(NodeH.GetKeyId(NId));
1814        }
1815      }
1816      return TAIntVI(HI, HHI, attr, false, this, IsDense);
1817    }
1818    TAFltVI BegNAFltVI(const TStr& attr) const {
1819      TVec<TFltV>::TIter HI = NULL;
1820      THash<TInt, TFltV>::TIter HHI;
1821      TInt location = CheckDenseOrSparseN(attr);
1822      TBool IsDense = true;
1823      if (location != -1) {
1824        TInt index = KeyToIndexTypeN.GetDat(attr).Val2;
1825        if (location == 1) {
1826          HI = VecOfFltVecVecsN[index].BegI();
1827        } else {
1828          IsDense = false;
1829          HHI = VecOfFltHashVecsN[index].BegI();
1830        }
1831      }
1832      return TAFltVI(HI, HHI, attr, false, this, IsDense);
1833    }
1834    TAFltVI EndNAFltVI(const TStr& attr) const {
1835      TVec<TFltV>::TIter HI = NULL;
1836      THash<TInt, TFltV>::TIter HHI;
1837      TInt location = CheckDenseOrSparseN(attr);
1838      TBool IsDense = true;
1839      if (location != -1) {
1840        TInt index = KeyToIndexTypeN.GetDat(attr).Val2;
1841        if (location == 1) {
1842          HI = VecOfFltVecVecsN[index].EndI();
1843        } else {
1844          IsDense = false;
1845          HHI = VecOfFltHashVecsN[index].EndI();
1846        }
1847      }
1848      return TAFltVI(HI, HHI, attr, false, this, IsDense);
1849    }
1850    TAFltVI GetNAFltVI(const TStr& attr, const int& NId) const {
1851      TVec<TFltV>::TIter HI = NULL;
1852      THash<TInt, TFltV>::TIter HHI;
1853      TInt location = CheckDenseOrSparseN(attr);
1854      TBool IsDense = true;
1855      if (location != -1) {
1856        TInt index = KeyToIndexTypeN.GetDat(attr).Val2;
1857        if (location == 1) {
1858          HI = VecOfFltVecVecsN[index].GetI(NodeH.GetKeyId(NId));
1859        } else {
1860          IsDense = false;
1861          HHI = VecOfFltHashVecsN[index].GetI(NodeH.GetKeyId(NId));
1862        }
1863      }
1864      return TAFltVI(HI, HHI, attr, false, this, IsDense);
1865    }
1866    TAStrI BegNAStrI(const TStr& attr) const {
1867      return TAStrI(VecOfStrVecsN[KeyToIndexTypeN.GetDat(attr).Val2].BegI(), attr, false, this); }
1868    TAStrI EndNAStrI(const TStr& attr) const {
1869      return TAStrI(VecOfStrVecsN[KeyToIndexTypeN.GetDat(attr).Val2].EndI(), attr, false, this); }
1870    TAStrI GetNAStrI(const TStr& attr, const int& NId) const {
1871      return TAStrI(VecOfStrVecsN[KeyToIndexTypeN.GetDat(attr).Val2].GetI(NodeH.GetKeyId(NId)), attr, false, this); }
1872    TAFltI BegNAFltI(const TStr& attr) const {
1873      return TAFltI(VecOfFltVecsN[KeyToIndexTypeN.GetDat(attr).Val2].BegI(), attr, false, this); }
1874    TAFltI EndNAFltI(const TStr& attr) const {
1875      return TAFltI(VecOfFltVecsN[KeyToIndexTypeN.GetDat(attr).Val2].EndI(), attr, false, this); }
1876    TAFltI GetNAFltI(const TStr& attr, const int& NId) const {
1877      return TAFltI(VecOfFltVecsN[KeyToIndexTypeN.GetDat(attr).Val2].GetI(NodeH.GetKeyId(NId)), attr, false, this); }
1878    void AttrNameNI(const TInt& NId, TStrV& Names) const {
1879      AttrNameNI(NId, KeyToIndexTypeN.BegI(), Names);}
1880    void AttrNameNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Names) const;
1881    void AttrValueNI(const TInt& NId, TStrV& Values) const {
1882      AttrValueNI(NId, KeyToIndexTypeN.BegI(), Values);}
1883    void AttrValueNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Values) const;
1884    void IntAttrNameNI(const TInt& NId, TStrV& Names) const {
1885      IntAttrNameNI(NId, KeyToIndexTypeN.BegI(), Names);}
1886    void IntAttrNameNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Names) const;
1887    void IntAttrValueNI(const TInt& NId, TIntV& Values) const {
1888      IntAttrValueNI(NId, KeyToIndexTypeN.BegI(), Values);}
1889    void IntAttrValueNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TIntV& Values) const;
1890    void IntVAttrNameNI(const TInt& NId, TStrV& Names) const {
1891      IntVAttrNameNI(NId, KeyToIndexTypeN.BegI(), Names);}
1892    void IntVAttrNameNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Names) const;
1893    void IntVAttrValueNI(const TInt& NId, TVec<TIntV>& Values) const {
1894      IntVAttrValueNI(NId, KeyToIndexTypeN.BegI(), Values);}
1895    void IntVAttrValueNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TVec<TIntV>& Values) const;
1896    void FltVAttrNameNI(const TInt& NId, TStrV& Names) const {
1897      FltVAttrNameNI(NId, KeyToIndexTypeN.BegI(), Names);}
1898    void FltVAttrNameNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Names) const;
1899    void FltVAttrValueNI(const TInt& NId, TVec<TFltV>& Values) const {
1900      FltVAttrValueNI(NId, KeyToIndexTypeN.BegI(), Values);}
1901    void FltVAttrValueNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TVec<TFltV>& Values) const;
1902    void StrAttrNameNI(const TInt& NId, TStrV& Names) const {
1903      StrAttrNameNI(NId, KeyToIndexTypeN.BegI(), Names);}
1904    void StrAttrNameNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Names) const;
1905    void StrAttrValueNI(const TInt& NId, TStrV& Values) const {
1906      StrAttrValueNI(NId, KeyToIndexTypeN.BegI(), Values);}
1907    void StrAttrValueNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Values) const;
1908    void FltAttrNameNI(const TInt& NId, TStrV& Names) const {
1909      FltAttrNameNI(NId, KeyToIndexTypeN.BegI(), Names);}
1910    void FltAttrNameNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TStrV& Names) const;
1911    void FltAttrValueNI(const TInt& NId, TFltV& Values) const {
1912      FltAttrValueNI(NId, KeyToIndexTypeN.BegI(), Values);}
1913    void FltAttrValueNI(const TInt& NId, TStrIntPrH::TIter NodeHI, TFltV& Values) const;
1914    void AttrNameEI(const TInt& EId, TStrV& Names) const {
1915      AttrNameEI(EId, KeyToIndexTypeE.BegI(), Names);}
1916    void AttrNameEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Names) const;
1917    void AttrValueEI(const TInt& EId, TStrV& Values) const {
1918      AttrValueEI(EId, KeyToIndexTypeE.BegI(), Values);}
1919    void AttrValueEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Values) const;
1920    void IntAttrNameEI(const TInt& EId, TStrV& Names) const {
1921      IntAttrNameEI(EId, KeyToIndexTypeE.BegI(), Names);}
1922    void IntAttrNameEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Names) const;
1923    void IntAttrValueEI(const TInt& EId, TIntV& Values) const {
1924      IntAttrValueEI(EId, KeyToIndexTypeE.BegI(), Values);}
1925    void IntAttrValueEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TIntV& Values) const;
1926    void IntVAttrNameEI(const TInt& EId, TStrV& Names) const {
1927      IntVAttrNameEI(EId, KeyToIndexTypeE.BegI(), Names);}
1928    void IntVAttrNameEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Names) const;
1929    void IntVAttrValueEI(const TInt& EId, TVec<TIntV>& Values) const {
1930      IntVAttrValueEI(EId, KeyToIndexTypeE.BegI(), Values);}
1931    void IntVAttrValueEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TVec<TIntV>& Values) const;
1932    void FltVAttrNameEI(const TInt& EId, TStrV& Names) const {
1933      FltVAttrNameEI(EId, KeyToIndexTypeE.BegI(), Names);}
1934    void FltVAttrNameEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Names) const;
1935    void FltVAttrValueEI(const TInt& EId, TVec<TFltV>& Values) const {
1936      FltVAttrValueEI(EId, KeyToIndexTypeE.BegI(), Values);}
1937    void FltVAttrValueEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TVec<TFltV>& Values) const;
1938    void StrAttrNameEI(const TInt& EId, TStrV& Names) const {
1939      StrAttrNameEI(EId, KeyToIndexTypeE.BegI(), Names);}
1940    void StrAttrNameEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Names) const;
1941    void StrAttrValueEI(const TInt& EId, TStrV& Values) const {
1942      StrAttrValueEI(EId, KeyToIndexTypeE.BegI(), Values);}
1943    void StrAttrValueEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Values) const;
1944    void FltAttrNameEI(const TInt& EId, TStrV& Names) const {
1945      FltAttrNameEI(EId, KeyToIndexTypeE.BegI(), Names);}
1946    void FltAttrNameEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TStrV& Names) const;
1947    void FltAttrValueEI(const TInt& EId, TFltV& Values) const {
1948      FltAttrValueEI(EId, KeyToIndexTypeE.BegI(), Values);}
1949    void FltAttrValueEI(const TInt& EId, TStrIntPrH::TIter EdgeHI, TFltV& Values) const;
1950    TAIntI BegEAIntI(const TStr& attr) const {
1951      return TAIntI(VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2].BegI(), attr, true, this);
1952    }
1953    TAIntI EndEAIntI(const TStr& attr) const {
1954      return TAIntI(VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2].EndI(), attr, true, this);
1955    }
1956    TAIntI GetEAIntI(const TStr& attr, const int& EId) const {
1957      return TAIntI(VecOfIntVecsE[KeyToIndexTypeE.GetDat(attr).Val2].GetI(EdgeH.GetKeyId(EId)), attr, true, this);
1958    }
1959    TAIntVI BegEAIntVI(const TStr& attr) const {
1960      TVec<TIntV>::TIter HI = NULL;
1961      THash<TInt, TIntV>::TIter HHI;
1962      TInt location = CheckDenseOrSparseE(attr);
1963      TBool IsDense = true;
1964      if (location != -1) {
1965        TInt index = KeyToIndexTypeE.GetDat(attr).Val2;
1966        if (location == 1) {
1967          HI = VecOfIntVecVecsE[index].BegI();
1968        } else {
1969          IsDense = false;
1970          HHI = VecOfIntHashVecsE[index].BegI();
1971        }
1972      }
1973      return TAIntVI(HI, HHI, attr, true, this, IsDense);
1974    }
1975    TAIntVI EndEAIntVI(const TStr& attr) const {
1976      TVec<TIntV>::TIter HI = NULL;
1977      THash<TInt, TIntV>::TIter HHI;
1978      TInt location = CheckDenseOrSparseE(attr);
1979      TBool IsDense = true;
1980      if (location != -1) {
1981        TInt index = KeyToIndexTypeE.GetDat(attr).Val2;
1982        if (location == 1) {
1983          HI = VecOfIntVecVecsE[index].EndI();
1984        } else {
1985          IsDense = false;
1986          HHI = VecOfIntHashVecsE[index].EndI();
1987        }
1988      }
1989      return TAIntVI(HI, HHI, attr, true, this, IsDense);
1990    }
1991    TAIntVI GetEAIntVI(const TStr& attr, const int& EId) const {
1992      TVec<TIntV>::TIter HI = NULL;
1993      THash<TInt, TIntV>::TIter HHI;
1994      TInt location = CheckDenseOrSparseE(attr);
1995      TBool IsDense = true;
1996      if (location != -1) {
1997        TInt index = KeyToIndexTypeE.GetDat(attr).Val2;
1998        if (location == 1) {
1999          HI = VecOfIntVecVecsE[index].GetI(EdgeH.GetKeyId(EId));
2000        } else {
2001          IsDense = false;
2002          HHI = VecOfIntHashVecsE[index].GetI(EdgeH.GetKeyId(EId));
2003        }
2004      }
2005      return TAIntVI(HI, HHI, attr, true, this, IsDense);
2006    }
2007    TAFltVI BegEAFltVI(const TStr& attr) const {
2008      TVec<TFltV>::TIter HI = NULL;
2009      THash<TInt, TFltV>::TIter HHI;
2010      TInt location = CheckDenseOrSparseE(attr);
2011      TBool IsDense = true;
2012      if (location != -1) {
2013        TInt index = KeyToIndexTypeE.GetDat(attr).Val2;
2014        if (location == 1) {
2015          HI = VecOfFltVecVecsE[index].BegI();
2016        } else {
2017          IsDense = false;
2018          HHI = VecOfFltHashVecsE[index].BegI();
2019        }
2020      }
2021      return TAFltVI(HI, HHI, attr, true, this, IsDense);
2022    }
2023    TAFltVI EndEAFltVI(const TStr& attr) const {
2024      TVec<TFltV>::TIter HI = NULL;
2025      THash<TInt, TFltV>::TIter HHI;
2026      TInt location = CheckDenseOrSparseE(attr);
2027      TBool IsDense = true;
2028      if (location != -1) {
2029        TInt index = KeyToIndexTypeE.GetDat(attr).Val2;
2030        if (location == 1) {
2031          HI = VecOfFltVecVecsE[index].EndI();
2032        } else {
2033          IsDense = false;
2034          HHI = VecOfFltHashVecsE[index].EndI();
2035        }
2036      }
2037      return TAFltVI(HI, HHI, attr, true, this, IsDense);
2038    }
2039    TAFltVI GetEAFltVI(const TStr& attr, const int& EId) const {
2040      TVec<TFltV>::TIter HI = NULL;
2041      THash<TInt, TFltV>::TIter HHI;
2042      TInt location = CheckDenseOrSparseE(attr);
2043      TBool IsDense = true;
2044      if (location != -1) {
2045        TInt index = KeyToIndexTypeE.GetDat(attr).Val2;
2046        if (location == 1) {
2047          HI = VecOfFltVecVecsE[index].GetI(EdgeH.GetKeyId(EId));
2048        } else {
2049          IsDense = false;
2050          HHI = VecOfFltHashVecsE[index].GetI(EdgeH.GetKeyId(EId));
2051        }
2052      }
2053      return TAFltVI(HI, HHI, attr, true, this, IsDense);
2054    }
2055    TAStrI BegEAStrI(const TStr& attr) const {
2056      return TAStrI(VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2].BegI(), attr, true, this);   }
2057    TAStrI EndEAStrI(const TStr& attr) const {
2058      return TAStrI(VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2].EndI(), attr, true, this);
2059    }
2060    TAStrI GetEAStrI(const TStr& attr, const int& EId) const {
2061      return TAStrI(VecOfStrVecsE[KeyToIndexTypeE.GetDat(attr).Val2].GetI(EdgeH.GetKeyId(EId)), attr, true, this);
2062    }
2063    TAFltI BegEAFltI(const TStr& attr) const {
2064      return TAFltI(VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2].BegI(), attr, true, this);
2065    }
2066    TAFltI EndEAFltI(const TStr& attr) const {
2067      return TAFltI(VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2].EndI(), attr, true, this);
2068    }
2069    TAFltI GetEAFltI(const TStr& attr, const int& EId) const {
2070      return TAFltI(VecOfFltVecsE[KeyToIndexTypeE.GetDat(attr).Val2].GetI(EdgeH.GetKeyId(EId)), attr, true, this);
2071    }
2072    int GetMxNId() const { return MxNId; }
2073    int GetMxEId() const { return MxEId; }
2074    int GetEdges() const { return EdgeH.Len(); }
2075    int AddEdge(const int& SrcNId, const int& DstNId, int EId  = -1);
2076    int AddEdge(const TEdgeI& EdgeI) { return AddEdge(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), EdgeI.GetId()); }
2077    void DelEdge(const int& EId);
2078    void DelEdge(const int& SrcNId, const int& DstNId, const bool& IsDir = true);
2079    bool IsEdge(const int& EId) const { return EdgeH.IsKey(EId); }
2080    bool IsEdge(const int& SrcNId, const int& DstNId, const bool& IsDir = true) const { int EId; return IsEdge(SrcNId, DstNId, EId, IsDir); }
2081    bool IsEdge(const int& SrcNId, const int& DstNId, int& EId, const bool& IsDir = true) const;
2082    int GetEId(const int& SrcNId, const int& DstNId) const { int EId; return IsEdge(SrcNId, DstNId, EId)?EId:-1; }
2083    TEdgeI BegEI() const { return TEdgeI(EdgeH.BegI(), this); }
2084    TEdgeI EndEI() const { return TEdgeI(EdgeH.EndI(), this); }
2085    TEdgeI GetEI(const int& EId) const { return TEdgeI(EdgeH.GetI(EId), this); }
2086    TEdgeI GetEI(const int& SrcNId, const int& DstNId) const { return GetEI(GetEId(SrcNId, DstNId)); }
2087    int GetRndNId(TRnd& Rnd=TInt::Rnd) { return NodeH.GetKey(NodeH.GetRndKeyId(Rnd, 0.8)); }
2088    TNodeI GetRndNI(TRnd& Rnd=TInt::Rnd) { return GetNI(GetRndNId(Rnd)); }
2089    int GetRndEId(TRnd& Rnd=TInt::Rnd) { return EdgeH.GetKey(EdgeH.GetRndKeyId(Rnd, 0.8)); }
2090    TEdgeI GetRndEI(TRnd& Rnd=TInt::Rnd) { return GetEI(GetRndEId(Rnd)); }
2091    void GetNIdV(TIntV& NIdV) const;
2092    void GetEIdV(TIntV& EIdV) const;
2093    bool Empty() const { return GetNodes()==0; }
2094    void Clr() { MxNId=0; MxEId=0; NodeH.Clr(); EdgeH.Clr();
2095      KeyToIndexTypeN.Clr(); KeyToIndexTypeE.Clr(); IntDefaultsN.Clr(); IntDefaultsE.Clr();
2096      StrDefaultsN.Clr(); StrDefaultsE.Clr(); FltDefaultsN.Clr(); FltDefaultsE.Clr();
2097      VecOfIntVecsN.Clr(); VecOfIntVecsE.Clr(); VecOfStrVecsN.Clr(); VecOfStrVecsE.Clr();
2098      VecOfFltVecsN.Clr(); VecOfFltVecsE.Clr(); VecOfIntVecVecsN.Clr(); VecOfIntVecVecsE.Clr(); 
2099      VecOfFltVecVecsN.Clr(); VecOfFltVecVecsE.Clr(); 
2100      SAttrN.Clr(); SAttrE.Clr();}
2101    void Reserve(const int& Nodes, const int& Edges) {
2102      if (Nodes>0) { NodeH.Gen(Nodes/2); } if (Edges>0) { EdgeH.Gen(Edges/2); } }
2103    void Defrag(const bool& OnlyNodeLinks=false);
2104    bool IsOk(const bool& ThrowExcept=true) const;
2105    void Dump(FILE *OutF=stdout) const;
2106    int AddIntAttrDatN(const TNodeI& NodeI, const TInt& value, const TStr& attr) { return AddIntAttrDatN(NodeI.GetId(), value, attr); }
2107    int AddIntAttrDatN(const int& NId, const TInt& value, const TStr& attr);
2108    int AddStrAttrDatN(const TNodeI& NodeI, const TStr& value, const TStr& attr) { return AddStrAttrDatN(NodeI.GetId(), value, attr); }
2109    int AddStrAttrDatN(const int& NId, const TStr& value, const TStr& attr);
2110    int AddFltAttrDatN(const TNodeI& NodeI, const TFlt& value, const TStr& attr) { return AddFltAttrDatN(NodeI.GetId(), value, attr); }
2111    int AddFltAttrDatN(const int& NId, const TFlt& value, const TStr& attr);
2112    int AddIntVAttrDatN(const TNodeI& NodeI, const TIntV& value, const TStr& attr) { return AddIntVAttrDatN(NodeI.GetId(), value, attr); }
2113    int AddIntVAttrDatN(const int& NId, const TIntV& value, const TStr& attr, TBool UseDense=true);
2114    int AddFltVAttrDatN(const TNodeI& NodeI, const TFltV& value, const TStr& attr) { return AddFltVAttrDatN(NodeI.GetId(), value, attr); }
2115    int AddFltVAttrDatN(const int& NId, const TFltV& value, const TStr& attr, TBool UseDense=true);
2116    int AppendIntVAttrDatN(const TNodeI& NodeI, const TInt& value, const TStr& attr) { return AppendIntVAttrDatN(NodeI.GetId(), value, attr); }
2117    int AppendIntVAttrDatN(const int& NId, const TInt& value, const TStr& attr, TBool UseDense=true);
2118    int DelFromIntVAttrDatN(const TNodeI& NodeI, const TInt& value, const TStr& attr) { return DelFromIntVAttrDatN(NodeI.GetId(), value, attr); }
2119    int DelFromIntVAttrDatN(const int& NId, const TInt& value, const TStr& attr);
2120    int AppendFltVAttrDatN(const TNodeI& NodeI, const TFlt& value, const TStr& attr) { return AppendFltVAttrDatN(NodeI.GetId(), value, attr); }
2121    int AppendFltVAttrDatN(const int& NId, const TFlt& value, const TStr& attr, TBool UseDense=true);
2122    int DelFromFltVAttrDatN(const TNodeI& NodeI, const TFlt& value, const TStr& attr) { return DelFromFltVAttrDatN(NodeI.GetId(), value, attr); }
2123    int DelFromFltVAttrDatN(const int& NId, const TFlt& value, const TStr& attr);
2124    int AddIntAttrDatE(const TEdgeI& EdgeI, const TInt& value, const TStr& attr) { return AddIntAttrDatE(EdgeI.GetId(), value, attr); }
2125    int AddIntAttrDatE(const int& EId, const TInt& value, const TStr& attr);
2126    int AddStrAttrDatE(const TEdgeI& EdgeI, const TStr& value, const TStr& attr) { return AddStrAttrDatE(EdgeI.GetId(), value, attr); }
2127    int AddStrAttrDatE(const int& EId, const TStr& value, const TStr& attr);
2128    int AddFltAttrDatE(const TEdgeI& EdgeI, const TFlt& value, const TStr& attr) { return AddFltAttrDatE(EdgeI.GetId(), value, attr); }
2129    int AddFltAttrDatE(const int& EId, const TFlt& value, const TStr& attr);
2130    int AddIntVAttrDatE(const TEdgeI& EdgeI, const TIntV& value, const TStr& attr) { return AddIntVAttrDatE(EdgeI.GetId(), value, attr); }
2131    int AddIntVAttrDatE(const int& EId, const TIntV& value, const TStr& attr, TBool UseDense=true);
2132    int AppendIntVAttrDatE(const TEdgeI& EdgeI, const TInt& value, const TStr& attr) { return AppendIntVAttrDatE(EdgeI.GetId(), value, attr); }
2133    int AppendIntVAttrDatE(const int& EId, const TInt& value, const TStr& attr, TBool UseDense=true);
2134    int AddFltVAttrDatE(const TEdgeI& EdgeI, const TFltV& value, const TStr& attr) { return AddFltVAttrDatE(EdgeI.GetId(), value, attr); }
2135    int AddFltVAttrDatE(const int& EId, const TFltV& value, const TStr& attr, TBool UseDense=true);
2136    int AppendFltVAttrDatE(const TEdgeI& EdgeI, const TFlt& value, const TStr& attr) { return AppendFltVAttrDatE(EdgeI.GetId(), value, attr); }
2137    int AppendFltVAttrDatE(const int& EId, const TFlt& value, const TStr& attr, TBool UseDense=true);
2138    TInt GetIntAttrDatN(const TNodeI& NodeI, const TStr& attr) { return GetIntAttrDatN(NodeI.GetId(), attr); }
2139    TInt GetIntAttrDatN(const int& NId, const TStr& attr);
2140    TStr GetStrAttrDatN(const TNodeI& NodeI, const TStr& attr) { return GetStrAttrDatN(NodeI.GetId(), attr); }
2141    TStr GetStrAttrDatN(const int& NId, const TStr& attr);
2142    TFlt GetFltAttrDatN(const TNodeI& NodeI, const TStr& attr) { return GetFltAttrDatN(NodeI.GetId(), attr); }
2143    TFlt GetFltAttrDatN(const int& NId, const TStr& attr);
2144    TIntV GetIntVAttrDatN(const TNodeI& NodeI, const TStr& attr) const { return GetIntVAttrDatN(NodeI.GetId(), attr); }
2145    TIntV GetIntVAttrDatN(const int& NId, const TStr& attr) const;
2146    TFltV GetFltVAttrDatN(const TNodeI& NodeI, const TStr& attr) const { return GetFltVAttrDatN(NodeI.GetId(), attr); }
2147    TFltV GetFltVAttrDatN(const int& NId, const TStr& attr) const;
2148    int GetIntAttrIndN(const TStr& attr);
2149    int GetAttrIndN(const TStr& attr);
2150    TInt GetIntAttrIndDatN(const TNodeI& NodeI, const int& index) { return GetIntAttrIndDatN(NodeI.GetId(), index); }
2151    TInt GetIntAttrIndDatN(const int& NId, const int& index);
2152    TStr GetStrAttrIndDatN(const TNodeI& NodeI, const int& index) { return GetStrAttrIndDatN(NodeI.GetId(), index); }
2153    TStr GetStrAttrIndDatN(const int& NId, const int& index);
2154    TFlt GetFltAttrIndDatN(const TNodeI& NodeI, const int& index) { return GetFltAttrIndDatN(NodeI.GetId(), index); }
2155    TFlt GetFltAttrIndDatN(const int& NId, const int& index);
2156    TInt GetIntAttrDatE(const TEdgeI& EdgeI, const TStr& attr) { return GetIntAttrDatE(EdgeI.GetId(), attr); }
2157    TInt GetIntAttrDatE(const int& EId, const TStr& attr);
2158    TStr GetStrAttrDatE(const TEdgeI& EdgeI, const TStr& attr) { return GetStrAttrDatE(EdgeI.GetId(), attr); }
2159    TStr GetStrAttrDatE(const int& EId, const TStr& attr);
2160    TFlt GetFltAttrDatE(const TEdgeI& EdgeI, const TStr& attr) { return GetFltAttrDatE(EdgeI.GetId(), attr); }
2161    TFlt GetFltAttrDatE(const int& EId, const TStr& attr);
2162    TIntV GetIntVAttrDatE(const TEdgeI& EdgeI, const TStr& attr) { return GetIntVAttrDatE(EdgeI.GetId(), attr); }
2163    TIntV GetIntVAttrDatE(const int& EId, const TStr& attr);
2164    TFltV GetFltVAttrDatE(const TEdgeI& EdgeI, const TStr& attr) { return GetFltVAttrDatE(EdgeI.GetId(), attr); }
2165    TFltV GetFltVAttrDatE(const int& EId, const TStr& attr);
2166    int GetIntAttrIndE(const TStr& attr);
2167    int GetAttrIndE(const TStr& attr);
2168    TInt GetIntAttrIndDatE(const TEdgeI& EdgeI, const int& index) { return GetIntAttrIndDatE(EdgeI.GetId(), index); }
2169    TInt GetIntAttrIndDatE(const int& EId, const int& index);
2170    TFlt GetFltAttrIndDatE(const TEdgeI& EdgeI, const int& index) { return GetFltAttrIndDatE(EdgeI.GetId(), index); }
2171    TFlt GetFltAttrIndDatE(const int& EId, const int& index);
2172    TStr GetStrAttrIndDatE(const TEdgeI& EdgeI, const int& index) { return GetStrAttrIndDatE(EdgeI.GetId(), index); }
2173    TStr GetStrAttrIndDatE(const int& EId, const int& index);
2174    int DelAttrDatN(const TNodeI& NodeI, const TStr& attr) { return DelAttrDatN(NodeI.GetId(), attr); } 
2175    int DelAttrDatN(const int& NId, const TStr& attr); 
2176    int DelAttrDatE(const TEdgeI& EdgeI, const TStr& attr) { return DelAttrDatE(EdgeI.GetId(), attr); } 
2177    int DelAttrDatE(const int& EId, const TStr& attr); 
2178    int AddIntAttrN(const TStr& attr, TInt defaultValue=TInt::Mn);
2179    int AddStrAttrN(const TStr& attr, TStr defaultValue=TStr::GetNullStr());
2180    int AddFltAttrN(const TStr& attr, TFlt defaultValue=TFlt::Mn);
2181    int AddIntVAttrN(const TStr& attr, TBool UseDense=true);
2182    int AddFltVAttrN(const TStr& attr, TBool UseDense=true);
2183    int AddIntAttrE(const TStr& attr, TInt defaultValue=TInt::Mn);
2184    int AddStrAttrE(const TStr& attr, TStr defaultValue=TStr::GetNullStr());
2185    int AddFltAttrE(const TStr& attr, TFlt defaultValue=TFlt::Mn);
2186    int AddIntVAttrE(const TStr& attr, TBool UseDense=true);
2187    int AddFltVAttrE(const TStr& attr, TBool UseDense=true);
2188    int DelAttrN(const TStr& attr);
2189    int DelAttrE(const TStr& attr);
2190    bool IsAttrDeletedN(const int& NId, const TStr& attr) const;
2191    bool IsIntAttrDeletedN(const int& NId, const TStr& attr) const;
2192    bool IsIntVAttrDeletedN(const int& NId, const TStr& attr) const;
2193    bool IsFltVAttrDeletedN(const int& NId, const TStr& attr) const;
2194    bool IsStrAttrDeletedN(const int& NId, const TStr& attr) const;
2195    bool IsFltAttrDeletedN(const int& NId, const TStr& attr) const;
2196    bool NodeAttrIsDeleted(const int& NId, const TStrIntPrH::TIter& NodeHI) const;
2197    bool NodeAttrIsIntDeleted(const int& NId, const TStrIntPrH::TIter& NodeHI) const;
2198    bool NodeAttrIsIntVDeleted(const int& NId, const TStrIntPrH::TIter& NodeHI) const;
2199    bool NodeAttrIsFltVDeleted(const int& NId, const TStrIntPrH::TIter& NodeHI) const;
2200    bool NodeAttrIsStrDeleted(const int& NId, const TStrIntPrH::TIter& NodeHI) const;
2201    bool NodeAttrIsFltDeleted(const int& NId, const TStrIntPrH::TIter& NodeHI) const;
2202    bool IsAttrDeletedE(const int& EId, const TStr& attr) const;
2203    bool IsIntAttrDeletedE(const int& EId, const TStr& attr) const;
2204    bool IsIntVAttrDeletedE(const int& EId, const TStr& attr) const;
2205    bool IsFltVAttrDeletedE(const int& EId, const TStr& attr) const;
2206    bool IsStrAttrDeletedE(const int& EId, const TStr& attr) const;
2207    bool IsFltAttrDeletedE(const int& EId, const TStr& attr) const;
2208    bool EdgeAttrIsDeleted(const int& EId, const TStrIntPrH::TIter& EdgeHI) const;
2209    bool EdgeAttrIsIntDeleted(const int& EId, const TStrIntPrH::TIter& EdgeHI) const;
2210    bool EdgeAttrIsIntVDeleted(const int& EId, const TStrIntPrH::TIter& EdgeHI) const;
2211    bool EdgeAttrIsFltVDeleted(const int& EId, const TStrIntPrH::TIter& EdgeHI) const;
2212    bool EdgeAttrIsStrDeleted(const int& EId, const TStrIntPrH::TIter& EdgeHI) const;
2213    bool EdgeAttrIsFltDeleted(const int& EId, const TStrIntPrH::TIter& EdgeHI) const;
2214    TStr GetNodeAttrValue(const int& NId, const TStrIntPrH::TIter& NodeHI) const;
2215    TStr GetEdgeAttrValue(const int& EId, const TStrIntPrH::TIter& EdgeHI) const;
2216    TFlt GetWeightOutEdges(const TNodeI& NI, const TStr& attr);
2217    bool IsFltAttrE(const TStr& attr);
2218    bool IsIntAttrE(const TStr& attr);
2219    bool IsStrAttrE(const TStr& attr);
2220    TVec<TFlt>& GetFltAttrVecE(const TStr& attr);
2221    int GetFltKeyIdE(const int& EId);
2222    void GetWeightOutEdgesV(TFltV& OutWeights, const TFltV& AttrVal) ;
2223    void GetAttrNNames(TStrV& IntAttrNames, TStrV& FltAttrNames, TStrV& StrAttrNames) const;
2224    void GetAttrENames(TStrV& IntAttrNames, TStrV& FltAttrNames, TStrV& StrAttrNames) const;
2225    int AddSAttrDatN(const TInt& NId, const TStr& AttrName, const TInt& Val);
2226    int AddSAttrDatN(const TInt& NId, const TInt& AttrId, const TInt& Val);
2227    int AddSAttrDatN(const TNodeI& NodeI, const TStr& AttrName, const TInt& Val) {
2228      return AddSAttrDatN(NodeI.GetId(), AttrName, Val);
2229    }
2230    int AddSAttrDatN(const TNodeI& NodeI, const TInt& AttrId, const TInt& Val) {
2231      return AddSAttrDatN(NodeI.GetId(), AttrId, Val);
2232    }
2233    int AddSAttrDatN(const TInt& NId, const TStr& AttrName, const TFlt& Val);
2234    int AddSAttrDatN(const TInt& NId, const TInt& AttrId, const TFlt& Val);
2235    int AddSAttrDatN(const TNodeI& NodeI, const TStr& AttrName, const TFlt& Val) {
2236      return AddSAttrDatN(NodeI.GetId(), AttrName, Val);
2237    }
2238    int AddSAttrDatN(const TNodeI& NodeI, const TInt& AttrId, const TFlt& Val) {
2239      return AddSAttrDatN(NodeI.GetId(), AttrId, Val);
2240    }
2241    int AddSAttrDatN(const TInt& NId, const TStr& AttrName, const TStr& Val);
2242    int AddSAttrDatN(const TInt& NId, const TInt& AttrId, const TStr& Val);
2243    int AddSAttrDatN(const TNodeI& NodeI, const TStr& AttrName, const TStr& Val) {
2244      return AddSAttrDatN(NodeI.GetId(), AttrName, Val);
2245    }
2246    int AddSAttrDatN(const TNodeI& NodeI, const TInt& AttrId, const TStr& Val) {
2247      return AddSAttrDatN(NodeI.GetId(), AttrId, Val);
2248    }
2249    int GetSAttrDatN(const TInt& NId, const TStr& AttrName, TInt& ValX) const;
2250    int GetSAttrDatN(const TInt& NId, const TInt& AttrId, TInt& ValX) const;
2251    int GetSAttrDatN(const TNodeI& NodeI, const TStr& AttrName, TInt& ValX) const {
2252      return GetSAttrDatN(NodeI.GetId(), AttrName, ValX);
2253    }
2254    int GetSAttrDatN(const TNodeI& NodeI, const TInt& AttrId, TInt& ValX) const {
2255      return GetSAttrDatN(NodeI.GetId(), AttrId, ValX);
2256    }
2257    int GetSAttrDatN(const TInt& NId, const TStr& AttrName, TFlt& ValX) const;
2258    int GetSAttrDatN(const TInt& NId, const TInt& AttrId, TFlt& ValX) const;
2259    int GetSAttrDatN(const TNodeI& NodeI, const TStr& AttrName, TFlt& ValX) const {
2260      return GetSAttrDatN(NodeI.GetId(), AttrName, ValX);
2261    } 
2262    int GetSAttrDatN(const TNodeI& NodeI, const TInt& AttrId, TFlt& ValX) const {
2263      return GetSAttrDatN(NodeI.GetId(), AttrId, ValX);
2264    }
2265    int GetSAttrDatN(const TInt& NId, const TStr& AttrName, TStr& ValX) const;
2266    int GetSAttrDatN(const TInt& NId, const TInt& AttrId, TStr& ValX) const;
2267    int GetSAttrDatN(const TNodeI& NodeI, const TStr& AttrName, TStr& ValX) const {
2268      return GetSAttrDatN(NodeI.GetId(), AttrName, ValX);
2269    }
2270    int GetSAttrDatN(const TNodeI& NodeI, const TInt& AttrId, TStr& ValX) const {
2271      return GetSAttrDatN(NodeI.GetId(), AttrId, ValX);
2272    }
2273    int DelSAttrDatN(const TInt& NId, const TStr& AttrName);
2274    int DelSAttrDatN(const TInt& NId, const TInt& AttrId);
2275    int DelSAttrDatN(const TNodeI& NodeI, const TStr& AttrName) {
2276      return DelSAttrDatN(NodeI.GetId(), AttrName);
2277    }
2278    int DelSAttrDatN(const TNodeI& NodeI, const TInt& AttrId) {
2279      return DelSAttrDatN(NodeI.GetId(), AttrId);
2280    }
2281    int GetSAttrVN(const TInt& NId, const TAttrType AttrType, TAttrPrV& AttrV) const;
2282    int GetSAttrVN(const TNodeI& NodeI, const TAttrType AttrType, TAttrPrV& AttrV) const {
2283      return GetSAttrVN(NodeI.GetId(), AttrType, AttrV);
2284    }
2285    int GetIdVSAttrN(const TStr& AttrName, TIntV& IdV) const;
2286    int GetIdVSAttrN(const TInt& AttrId, TIntV& IdV) const;
2287    int AddSAttrN(const TStr& Name, const TAttrType& AttrType, TInt& AttrId);
2288    int GetSAttrIdN(const TStr& Name, TInt& AttrIdX, TAttrType& AttrTypeX) const;
2289    int GetSAttrNameN(const TInt& AttrId, TStr& NameX, TAttrType& AttrTypeX) const;
2290    int AddSAttrDatE(const TInt& EId, const TStr& AttrName, const TInt& Val);
2291    int AddSAttrDatE(const TInt& EId, const TInt& AttrId, const TInt& Val);
2292    int AddSAttrDatE(const TEdgeI& EdgeI, const TStr& AttrName, const TInt& Val) {
2293      return AddSAttrDatE(EdgeI.GetId(), AttrName, Val);
2294    }
2295    int AddSAttrDatE(const TEdgeI& EdgeI, const TInt& AttrId, const TInt& Val) {
2296      return AddSAttrDatE(EdgeI.GetId(), AttrId, Val);
2297    }
2298    int AddSAttrDatE(const TInt& EId, const TStr& AttrName, const TFlt& Val);
2299    int AddSAttrDatE(const TInt& EId, const TInt& AttrId, const TFlt& Val);
2300    int AddSAttrDatE(const TEdgeI& EdgeI, const TStr& AttrName, const TFlt& Val) {
2301      return AddSAttrDatE(EdgeI.GetId(), AttrName, Val);
2302    }
2303    int AddSAttrDatE(const TEdgeI& EdgeI, const TInt& AttrId, const TFlt& Val){
2304      return AddSAttrDatE(EdgeI.GetId(), AttrId, Val);
2305    }
2306    int AddSAttrDatE(const TInt& EId, const TStr& AttrName, const TStr& Val);
2307    int AddSAttrDatE(const TInt& EId, const TInt& AttrId, const TStr& Val);
2308    int AddSAttrDatE(const TEdgeI& EdgeI, const TStr& AttrName, const TStr& Val) {
2309      return AddSAttrDatE(EdgeI.GetId(), AttrName, Val);
2310    }
2311    int AddSAttrDatE(const TEdgeI& EdgeI, const TInt& AttrId, const TStr& Val) {
2312      return AddSAttrDatE(EdgeI.GetId(), AttrId, Val);
2313    }
2314    int GetSAttrDatE(const TInt& EId, const TStr& AttrName, TInt& ValX) const;
2315    int GetSAttrDatE(const TInt& EId, const TInt& AttrId, TInt& ValX) const;
2316    int GetSAttrDatE(const TEdgeI& EdgeI, const TStr& AttrName, TInt& ValX) const {
2317      return GetSAttrDatE(EdgeI.GetId(), AttrName, ValX);
2318    }
2319    int GetSAttrDatE(const TEdgeI& EdgeI, const TInt& AttrId, TInt& ValX) const {
2320      return GetSAttrDatE(EdgeI.GetId(), AttrId, ValX);
2321    } 
2322    int GetSAttrDatE(const TInt& EId, const TStr& AttrName, TFlt& ValX) const; 
2323    int GetSAttrDatE(const TInt& EId, const TInt& AttrId, TFlt& ValX) const;
2324    int GetSAttrDatE(const TEdgeI& EdgeI, const TStr& AttrName, TFlt& ValX) const {
2325      return GetSAttrDatE(EdgeI.GetId(), AttrName, ValX);
2326    }
2327    int GetSAttrDatE(const TEdgeI& EdgeI, const TInt& AttrId, TFlt& ValX) const {
2328      return GetSAttrDatE(EdgeI.GetId(), AttrId, ValX);
2329    } 
2330    int GetSAttrDatE(const TInt& EId, const TStr& AttrName, TStr& ValX) const;
2331    int GetSAttrDatE(const TInt& EId, const TInt& AttrId, TStr& ValX) const;
2332    int GetSAttrDatE(const TEdgeI& EdgeI, const TStr& AttrName, TStr& ValX) const {
2333      return GetSAttrDatE(EdgeI.GetId(), AttrName, ValX);
2334    }
2335    int GetSAttrDatE(const TEdgeI& EdgeI, const TInt& AttrId, TStr& ValX) const {
2336      return GetSAttrDatE(EdgeI.GetId(), AttrId, ValX);
2337    }
2338    int DelSAttrDatE(const TInt& EId, const TStr& AttrName);
2339    int DelSAttrDatE(const TInt& EId, const TInt& AttrId);
2340    int DelSAttrDatE(const TEdgeI& EdgeI, const TStr& AttrName) {
2341      return DelSAttrDatE(EdgeI.GetId(), AttrName);
2342    }
2343    int DelSAttrDatE(const TEdgeI& EdgeI, const TInt& AttrId) {
2344      return DelSAttrDatE(EdgeI.GetId(), AttrId);
2345    } 
2346    int GetSAttrVE(const TInt& EId, const TAttrType AttrType, TAttrPrV& AttrV) const;
2347    int GetSAttrVE(const TEdgeI& EdgeI, const TAttrType AttrType, TAttrPrV& AttrV) const {
2348      return GetSAttrVE(EdgeI.GetId(), AttrType, AttrV);
2349    }
2350    int GetIdVSAttrE(const TStr& AttrName, TIntV& IdV) const;
2351    int GetIdVSAttrE(const TInt& AttrId, TIntV& IdV) const;
2352    int AddSAttrE(const TStr& Name, const TAttrType& AttrType, TInt& AttrId);
2353    int GetSAttrIdE(const TStr& Name, TInt& AttrIdX, TAttrType& AttrTypeX) const;
2354    int GetSAttrNameE(const TInt& AttrId, TStr& NameX, TAttrType& AttrTypeX) const;
2355    static PNEANet GetSmallGraph();
2356    friend class TPt<TNEANet>;
2357  };
2358  namespace TSnap {
2359  template <> struct IsMultiGraph<TNEANet> { enum { Val = 1 }; };
2360  template <> struct IsDirected<TNEANet> { enum { Val = 1 }; };
2361  }
2362  class TUndirNet;
2363  typedef TPt<TUndirNet> PUndirNet;
2364  class TDirNet;
2365  typedef TPt<TDirNet> PDirNet;
2366  class TUndirNet {
2367  public:
2368    typedef TUndirNet TNet;
2369    typedef TPt<TUndirNet> PNet;
2370  public:
2371    class TNode {
2372    private:
2373      TInt Id;
2374      TIntV NIdV;
2375    public:
2376      TNode() : Id(-1), NIdV() { }
2377      TNode(const int& NId) : Id(NId), NIdV() { }
2378      TNode(const TNode& Node) : Id(Node.Id), NIdV(Node.NIdV) { }
2379      TNode(TSIn& SIn) : Id(SIn), NIdV(SIn) { }
2380      void Save(TSOut& SOut) const { Id.Save(SOut); NIdV.Save(SOut); }
2381      int GetId() const { return Id; }
2382      int GetDeg() const { return NIdV.Len(); }
2383      int GetInDeg() const { return GetDeg(); }
2384      int GetOutDeg() const { return GetDeg(); }
2385      int GetInNId(const int& NodeN) const { return GetNbrNId(NodeN); }
2386      int GetOutNId(const int& NodeN) const { return GetNbrNId(NodeN); }
2387      int GetNbrNId(const int& NodeN) const { return NIdV[NodeN]; }
2388      bool IsNbrNId(const int& NId) const { return NIdV.SearchBin(NId)!=-1; }
2389      bool IsInNId(const int& NId) const { return IsNbrNId(NId); }
2390      bool IsOutNId(const int& NId) const { return IsNbrNId(NId); }
2391      void PackOutNIdV() { NIdV.Pack(); }
2392      void PackNIdV() { NIdV.Pack(); }
2393      void SortNIdV() { NIdV.Sort();}
2394      void LoadShM(TShMIn& MStream) {
2395        Id = TInt(MStream);
2396        NIdV.LoadShM(MStream);
2397      }
2398      friend class TUndirNet;
2399      friend class TUndirNetMtx;
2400    };
2401    class TNodeI {
2402    private:
2403      typedef THash<TInt, TNode>::TIter THashIter;
2404      THashIter NodeHI;
2405    public:
2406      TNodeI() : NodeHI() { }
2407      TNodeI(const THashIter& NodeHIter) : NodeHI(NodeHIter) { }
2408      TNodeI(const TNodeI& NodeI) : NodeHI(NodeI.NodeHI) { }
2409      TNodeI& operator = (const TNodeI& NodeI) { NodeHI = NodeI.NodeHI; return *this; }
2410      TNodeI& operator++ (int) { NodeHI++; return *this; }
2411      TNodeI& operator-- (int) { NodeHI--; return *this; }
2412      bool operator < (const TNodeI& NodeI) const { return NodeHI < NodeI.NodeHI; }
2413      bool operator == (const TNodeI& NodeI) const { return NodeHI == NodeI.NodeHI; }
2414      int GetId() const { return NodeHI.GetDat().GetId(); }
2415      int GetDeg() const { return NodeHI.GetDat().GetDeg(); }
2416      int GetInDeg() const { return NodeHI.GetDat().GetInDeg(); }
2417      int GetOutDeg() const { return NodeHI.GetDat().GetOutDeg(); }
2418      void SortNIdV() { NodeHI.GetDat().SortNIdV(); }
2419      int GetInNId(const int& NodeN) const { return NodeHI.GetDat().GetInNId(NodeN); }
2420      int GetOutNId(const int& NodeN) const { return NodeHI.GetDat().GetOutNId(NodeN); }
2421      int GetNbrNId(const int& NodeN) const { return NodeHI.GetDat().GetNbrNId(NodeN); }
2422      bool IsInNId(const int& NId) const { return NodeHI.GetDat().IsInNId(NId); }
2423      bool IsOutNId(const int& NId) const { return NodeHI.GetDat().IsOutNId(NId); }
2424      bool IsNbrNId(const int& NId) const { return NodeHI.GetDat().IsNbrNId(NId); }
2425      friend class TUndirNet;
2426    };
2427    class TEdgeI {
2428    private:
2429      TNodeI CurNode, EndNode;
2430      int CurEdge;
2431    public:
2432      TEdgeI() : CurNode(), EndNode(), CurEdge(0) { }
2433      TEdgeI(const TNodeI& NodeI, const TNodeI& EndNodeI, const int& EdgeN=0) : CurNode(NodeI), EndNode(EndNodeI), CurEdge(EdgeN) { }
2434      TEdgeI(const TEdgeI& EdgeI) : CurNode(EdgeI.CurNode), EndNode(EdgeI.EndNode), CurEdge(EdgeI.CurEdge) { }
2435      TEdgeI& operator = (const TEdgeI& EdgeI) { if (this!=&EdgeI) { CurNode=EdgeI.CurNode; EndNode=EdgeI.EndNode; CurEdge=EdgeI.CurEdge; } return *this; }
2436      TEdgeI& operator++ (int) { do { CurEdge++; if (CurEdge >= CurNode.GetOutDeg()) { CurEdge=0; CurNode++; while (CurNode < EndNode && CurNode.GetOutDeg()==0) { CurNode++; } } } while (CurNode < EndNode && GetSrcNId()>GetDstNId()); return *this; }
2437      bool operator < (const TEdgeI& EdgeI) const { return CurNode<EdgeI.CurNode || (CurNode==EdgeI.CurNode && CurEdge<EdgeI.CurEdge); }
2438      bool operator == (const TEdgeI& EdgeI) const { return CurNode == EdgeI.CurNode && CurEdge == EdgeI.CurEdge; }
2439      int GetId() const { return -1; }
2440      int GetSrcNId() const { return CurNode.GetId(); }
2441      int GetDstNId() const { return CurNode.GetOutNId(CurEdge); }
2442      friend class TUndirNet;
2443    };
2444  private:
2445    TCRef CRef;
2446    TInt MxNId, NEdges;
2447    THash<TInt, TNode> NodeH;
2448    TAttr SAttrN;
2449    TAttrPair SAttrE;
2450  private:
2451    TNode& GetNode(const int& NId) { return NodeH.GetDat(NId); }
2452    const TNode& GetNode(const int& NId) const { return NodeH.GetDat(NId); }
2453    TIntPr OrderEdgeNodes(const int& SrcNId, const int& DstNId) const;
2454  private:
2455    class LoadTNodeFunctor {
2456    public:
2457      LoadTNodeFunctor() {}
2458      void operator() (TNode* n, TShMIn& ShMIn) {n->LoadShM(ShMIn);}
2459    };
2460  private:
2461    void LoadNetworkShM(TShMIn& ShMIn) {
2462      MxNId = TInt(ShMIn);
2463      NEdges = TInt(ShMIn);
2464      LoadTNodeFunctor NodeFn;
2465      NodeH.LoadShM(ShMIn, NodeFn);
2466      SAttrN.Load(ShMIn);
2467      SAttrE = TAttrPair(ShMIn);
2468    }
2469  public:
2470    TUndirNet() : CRef(), MxNId(0), NEdges(0), NodeH(), SAttrN(), SAttrE() { }
2471    explicit TUndirNet(const int& Nodes, const int& Edges) : MxNId(0), NEdges(0), SAttrN(), SAttrE() { Reserve(Nodes, Edges); }
2472    TUndirNet(const TUndirNet& Graph) : MxNId(Graph.MxNId), NEdges(Graph.NEdges), NodeH(Graph.NodeH),
2473      SAttrN(), SAttrE() { }
2474    TUndirNet(TSIn& SIn) : MxNId(SIn), NEdges(SIn), NodeH(SIn), SAttrN(SIn), SAttrE(SIn) { }
2475    void Save(TSOut& SOut) const { MxNId.Save(SOut); NEdges.Save(SOut); NodeH.Save(SOut);
2476      SAttrN.Save(SOut); SAttrE.Save(SOut);
2477      SOut.Flush(); }
2478    void Save_V1(TSOut& SOut) const { MxNId.Save(SOut); NEdges.Save(SOut); NodeH.Save(SOut); SOut.Flush(); }
2479    static PUndirNet New() { return new TUndirNet(); }
2480    static PUndirNet New(const int& Nodes, const int& Edges) { return new TUndirNet(Nodes, Edges); }
2481    static PUndirNet Load(TSIn& SIn) { return PUndirNet(new TUndirNet(SIn)); }
2482    static PUndirNet Load_V1(TSIn& SIn) { PUndirNet Graph = PUndirNet(new TUndirNet());
2483      Graph->MxNId.Load(SIn); Graph->NEdges.Load(SIn); Graph->NodeH.Load(SIn); return Graph;
2484    }
2485    static PUndirNet LoadShM(TShMIn& ShMIn) {
2486      TUndirNet* Network = new TUndirNet();
2487      Network->LoadNetworkShM(ShMIn);
2488      return PUndirNet(Network);
2489    }
2490    bool HasFlag(const TGraphFlag& Flag) const;
2491    TUndirNet& operator = (const TUndirNet& Graph) {
2492      if (this!=&Graph) { MxNId=Graph.MxNId; NEdges=Graph.NEdges; NodeH=Graph.NodeH; } return *this; }
2493    int GetNodes() const { return NodeH.Len(); }
2494    int AddNode(int NId = -1);
2495    int AddNodeUnchecked(int NId = -1);
2496    int AddNode(const TNodeI& NodeI) { return AddNode(NodeI.GetId()); }
2497    int AddNode(const int& NId, const TIntV& NbrNIdV);
2498    int AddNode(const int& NId, const TVecPool<TInt>& Pool, const int& NIdVId);
2499    void DelNode(const int& NId);
2500    void DelNode(const TNode& NodeI) { DelNode(NodeI.GetId()); }
2501    bool IsNode(const int& NId) const { return NodeH.IsKey(NId); }
2502    TNodeI BegNI() const { return TNodeI(NodeH.BegI()); }
2503    TNodeI EndNI() const { return TNodeI(NodeH.EndI()); }
2504    TNodeI GetNI(const int& NId) const { return TNodeI(NodeH.GetI(NId)); }
2505    int GetMxNId() const { return MxNId; }
2506    int GetEdges() const;
2507    int AddEdge(const int& SrcNId, const int& DstNId);
2508    int AddEdgeUnchecked(const int& SrcNId, const int& DstNId);
2509    int AddEdge(const TEdgeI& EdgeI) { return AddEdge(EdgeI.GetSrcNId(), EdgeI.GetDstNId()); }
2510    void DelEdge(const int& SrcNId, const int& DstNId);
2511    bool IsEdge(const int& SrcNId, const int& DstNId) const;
2512    TEdgeI BegEI() const { TNodeI NI = BegNI(); TEdgeI EI(NI, EndNI(), 0); if (GetNodes() != 0 && (NI.GetOutDeg()==0 || NI.GetId()>NI.GetOutNId(0))) { EI++; } return EI; }
2513    TEdgeI EndEI() const { return TEdgeI(EndNI(), EndNI()); }
2514    TEdgeI GetEI(const int& EId) const;
2515    TEdgeI GetEI(const int& SrcNId, const int& DstNId) const;
2516    int GetRndNId(TRnd& Rnd=TInt::Rnd) { return NodeH.GetKey(NodeH.GetRndKeyId(Rnd, 0.8)); }
2517    TNodeI GetRndNI(TRnd& Rnd=TInt::Rnd) { return GetNI(GetRndNId(Rnd)); }
2518    void GetNIdV(TIntV& NIdV) const;
2519    bool Empty() const { return GetNodes()==0; }
2520    void Clr() { MxNId=0; NEdges=0; NodeH.Clr(); SAttrN.Clr(); SAttrE.Clr(); }
2521    void Reserve(const int& Nodes, const int& Edges) { if (Nodes>0) NodeH.Gen(Nodes/2); }
2522    void ReserveNIdDeg(const int& NId, const int& Deg) { GetNode(NId).NIdV.Reserve(Deg); }
2523    void SortNodeAdjV() { for (TNodeI NI = BegNI(); NI < EndNI(); NI++) { NI.SortNIdV();} }
2524    void Defrag(const bool& OnlyNodeLinks=false);
2525    bool IsOk(const bool& ThrowExcept=true) const;
2526    void Dump(FILE *OutF=stdout) const;
2527    static PUndirNet GetSmallGraph();
2528    int AddSAttrDatN(const TInt& NId, const TStr& AttrName, const TInt& Val);
2529    int AddSAttrDatN(const TInt& NId, const TInt& AttrId, const TInt& Val);
2530    int AddSAttrDatN(const TNodeI& NodeI, const TStr& AttrName, const TInt& Val) {
2531      return AddSAttrDatN(NodeI.GetId(), AttrName, Val);
2532    }
2533    int AddSAttrDatN(const TNodeI& NodeI, const TInt& AttrId, const TInt& Val) {
2534      return AddSAttrDatN(NodeI.GetId(), AttrId, Val);
2535    }
2536    int AddSAttrDatN(const TInt& NId, const TStr& AttrName, const TFlt& Val);
2537    int AddSAttrDatN(const TInt& NId, const TInt& AttrId, const TFlt& Val);
2538    int AddSAttrDatN(const TNodeI& NodeI, const TStr& AttrName, const TFlt& Val) {
2539      return AddSAttrDatN(NodeI.GetId(), AttrName, Val);
2540    }
2541    int AddSAttrDatN(const TNodeI& NodeI, const TInt& AttrId, const TFlt& Val) {
2542      return AddSAttrDatN(NodeI.GetId(), AttrId, Val);
2543    }
2544    int AddSAttrDatN(const TInt& NId, const TStr& AttrName, const TStr& Val);
2545    int AddSAttrDatN(const TInt& NId, const TInt& AttrId, const TStr& Val);
2546    int AddSAttrDatN(const TNodeI& NodeI, const TStr& AttrName, const TStr& Val) {
2547      return AddSAttrDatN(NodeI.GetId(), AttrName, Val);
2548    }
2549    int AddSAttrDatN(const TNodeI& NodeI, const TInt& AttrId, const TStr& Val) {
2550      return AddSAttrDatN(NodeI.GetId(), AttrId, Val);
2551    }
2552    int GetSAttrDatN(const TInt& NId, const TStr& AttrName, TInt& ValX) const;
2553    int GetSAttrDatN(const TInt& NId, const TInt& AttrId, TInt& ValX) const;
2554    int GetSAttrDatN(const TNodeI& NodeI, const TStr& AttrName, TInt& ValX) const {
2555      return GetSAttrDatN(NodeI.GetId(), AttrName, ValX);
2556    }
2557    int GetSAttrDatN(const TNodeI& NodeI, const TInt& AttrId, TInt& ValX) const {
2558      return GetSAttrDatN(NodeI.GetId(), AttrId, ValX);
2559    }
2560    int GetSAttrDatN(const TInt& NId, const TStr& AttrName, TFlt& ValX) const;
2561    int GetSAttrDatN(const TInt& NId, const TInt& AttrId, TFlt& ValX) const;
2562    int GetSAttrDatN(const TNodeI& NodeI, const TStr& AttrName, TFlt& ValX) const {
2563      return GetSAttrDatN(NodeI.GetId(), AttrName, ValX);
2564    } 
2565    int GetSAttrDatN(const TNodeI& NodeI, const TInt& AttrId, TFlt& ValX) const {
2566      return GetSAttrDatN(NodeI.GetId(), AttrId, ValX);
2567    }
2568    int GetSAttrDatN(const TInt& NId, const TStr& AttrName, TStr& ValX) const;
2569    int GetSAttrDatN(const TInt& NId, const TInt& AttrId, TStr& ValX) const;
2570    int GetSAttrDatN(const TNodeI& NodeI, const TStr& AttrName, TStr& ValX) const {
2571      return GetSAttrDatN(NodeI.GetId(), AttrName, ValX);
2572    }
2573    int GetSAttrDatN(const TNodeI& NodeI, const TInt& AttrId, TStr& ValX) const {
2574      return GetSAttrDatN(NodeI.GetId(), AttrId, ValX);
2575    }
2576    int DelSAttrDatN(const TInt& NId, const TStr& AttrName);
2577    int DelSAttrDatN(const TInt& NId, const TInt& AttrId);
2578    int DelSAttrDatN(const TNodeI& NodeI, const TStr& AttrName) {
2579      return DelSAttrDatN(NodeI.GetId(), AttrName);
2580    }
2581    int DelSAttrDatN(const TNodeI& NodeI, const TInt& AttrId) {
2582      return DelSAttrDatN(NodeI.GetId(), AttrId);
2583    }
2584    int GetSAttrVN(const TInt& NId, const TAttrType AttrType, TAttrPrV& AttrV) const;
2585    int GetSAttrVN(const TNodeI& NodeI, const TAttrType AttrType, TAttrPrV& AttrV) const {
2586      return GetSAttrVN(NodeI.GetId(), AttrType, AttrV);
2587    }
2588    int GetIdVSAttrN(const TStr& AttrName, TIntV& IdV) const;
2589    int GetIdVSAttrN(const TInt& AttrId, TIntV& IdV) const;
2590    int AddSAttrN(const TStr& Name, const TAttrType& AttrType, TInt& AttrId);
2591    int GetSAttrIdN(const TStr& Name, TInt& AttrIdX, TAttrType& AttrTypeX) const;
2592    int GetSAttrNameN(const TInt& AttrId, TStr& NameX, TAttrType& AttrTypeX) const;
2593    int AddSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, const TInt& Val);
2594    int AddSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, const TInt& Val);
2595    int AddSAttrDatE(const TEdgeI& EdgeI, const TStr& AttrName, const TInt& Val) {
2596      return AddSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrName, Val);
2597    }
2598    int AddSAttrDatE(const TEdgeI& EdgeI, const TInt& AttrId, const TInt& Val) {
2599      return AddSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrId, Val);
2600    }
2601    int AddSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, const TFlt& Val);
2602    int AddSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, const TFlt& Val);
2603    int AddSAttrDatE(const TEdgeI& EdgeI, const TStr& AttrName, const TFlt& Val) {
2604      return AddSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrName, Val);
2605    }
2606    int AddSAttrDatE(const TEdgeI& EdgeI, const TInt& AttrId, const TFlt& Val){
2607      return AddSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrId, Val);
2608    }
2609    int AddSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, const TStr& Val);
2610    int AddSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, const TStr& Val);
2611    int AddSAttrDatE(const TEdgeI& EdgeI, const TStr& AttrName, const TStr& Val) {
2612      return AddSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrName, Val);
2613    }
2614    int AddSAttrDatE(const TEdgeI& EdgeI, const TInt& AttrId, const TStr& Val) {
2615      return AddSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrId, Val);
2616    }
2617    int GetSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, TInt& ValX) const;
2618    int GetSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, TInt& ValX) const;
2619    int GetSAttrDatE(const TEdgeI& EdgeI, const TStr& AttrName, TInt& ValX) const {
2620      return GetSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrName, ValX);
2621    }
2622    int GetSAttrDatE(const TEdgeI& EdgeI, const TInt& AttrId, TInt& ValX) const {
2623      return GetSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrId, ValX);
2624    } 
2625    int GetSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, TFlt& ValX) const; 
2626    int GetSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, TFlt& ValX) const;
2627    int GetSAttrDatE(const TEdgeI& EdgeI, const TStr& AttrName, TFlt& ValX) const {
2628      return GetSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrName, ValX);
2629    }
2630    int GetSAttrDatE(const TEdgeI& EdgeI, const TInt& AttrId, TFlt& ValX) const {
2631      return GetSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrId, ValX);
2632    } 
2633    int GetSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, TStr& ValX) const;
2634    int GetSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, TStr& ValX) const;
2635    int GetSAttrDatE(const TEdgeI& EdgeI, const TStr& AttrName, TStr& ValX) const {
2636      return GetSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrName, ValX);
2637    }
2638    int GetSAttrDatE(const TEdgeI& EdgeI, const TInt& AttrId, TStr& ValX) const {
2639      return GetSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrId, ValX);
2640    }
2641    int DelSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName);
2642    int DelSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId);
2643    int DelSAttrDatE(const TEdgeI& EdgeI, const TStr& AttrName) {
2644      return DelSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrName);
2645    }
2646    int DelSAttrDatE(const TEdgeI& EdgeI, const TInt& AttrId) {
2647      return DelSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrId);
2648    } 
2649    int GetSAttrVE(const int& SrcNId, const int& DstNId, const TAttrType AttrType, TAttrPrV& AttrV) const;
2650    int GetSAttrVE(const TEdgeI& EdgeI, const TAttrType AttrType, TAttrPrV& AttrV) const {
2651      return GetSAttrVE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrType, AttrV);
2652    }
2653    int GetIdVSAttrE(const TStr& AttrName, TIntPrV& IdV) const;
2654    int GetIdVSAttrE(const TInt& AttrId, TIntPrV& IdV) const;
2655    int AddSAttrE(const TStr& Name, const TAttrType& AttrType, TInt& AttrId);
2656    int GetSAttrIdE(const TStr& Name, TInt& AttrIdX, TAttrType& AttrTypeX) const;
2657    int GetSAttrNameE(const TInt& AttrId, TStr& NameX, TAttrType& AttrTypeX) const;
2658    friend class TUndirNetMtx;
2659    friend class TPt<TUndirNet>;
2660  };
2661  class TDirNet {
2662  public:
2663    typedef TDirNet TNet;
2664    typedef TPt<TDirNet> PNet;
2665  public:
2666    class TNode {
2667    private:
2668      TInt Id;
2669      TIntV InNIdV, OutNIdV;
2670    public:
2671      TNode() : Id(-1), InNIdV(), OutNIdV() { }
2672      TNode(const int& NId) : Id(NId), InNIdV(), OutNIdV() { }
2673      TNode(const TNode& Node) : Id(Node.Id), InNIdV(Node.InNIdV), OutNIdV(Node.OutNIdV) { }
2674      TNode(TSIn& SIn) : Id(SIn), InNIdV(SIn), OutNIdV(SIn) { }
2675      void Save(TSOut& SOut) const { Id.Save(SOut); InNIdV.Save(SOut); OutNIdV.Save(SOut); }
2676      int GetId() const { return Id; }
2677      int GetDeg() const { return GetInDeg() + GetOutDeg(); }
2678      int GetInDeg() const { return InNIdV.Len(); }
2679      int GetOutDeg() const { return OutNIdV.Len(); }
2680      int GetInNId(const int& NodeN) const { return InNIdV[NodeN]; }
2681      int GetOutNId(const int& NodeN) const { return OutNIdV[NodeN]; }
2682      int GetNbrNId(const int& NodeN) const { return NodeN<GetOutDeg()?GetOutNId(NodeN):GetInNId(NodeN-GetOutDeg()); }
2683      bool IsInNId(const int& NId) const { return InNIdV.SearchBin(NId) != -1; }
2684      bool IsOutNId(const int& NId) const { return OutNIdV.SearchBin(NId) != -1; }
2685      bool IsNbrNId(const int& NId) const { return IsOutNId(NId) || IsInNId(NId); }
2686      void PackOutNIdV() { OutNIdV.Pack(); }
2687      void PackNIdV() { InNIdV.Pack(); }
2688      void SortNIdV() { InNIdV.Sort(); OutNIdV.Sort();}
2689      void LoadShM(TShMIn& MStream) {
2690        Id = TInt(MStream);
2691        InNIdV.LoadShM(MStream);
2692        OutNIdV.LoadShM(MStream);
2693      }
2694      friend class TDirNet;
2695      friend class TDirNetMtx;
2696    };
2697    class TNodeI {
2698    private:
2699      typedef THash<TInt, TNode>::TIter THashIter;
2700      THashIter NodeHI;
2701    public:
2702      TNodeI() : NodeHI() { }
2703      TNodeI(const THashIter& NodeHIter) : NodeHI(NodeHIter) { }
2704      TNodeI(const TNodeI& NodeI) : NodeHI(NodeI.NodeHI) { }
2705      TNodeI& operator = (const TNodeI& NodeI) { NodeHI = NodeI.NodeHI; return *this; }
2706      TNodeI& operator++ (int) { NodeHI++; return *this; }
2707      TNodeI& operator-- (int) { NodeHI--; return *this; }
2708      bool operator < (const TNodeI& NodeI) const { return NodeHI < NodeI.NodeHI; }
2709      bool operator == (const TNodeI& NodeI) const { return NodeHI == NodeI.NodeHI; }
2710      int GetId() const { return NodeHI.GetDat().GetId(); }
2711      int GetDeg() const { return NodeHI.GetDat().GetDeg(); }
2712      int GetInDeg() const { return NodeHI.GetDat().GetInDeg(); }
2713      int GetOutDeg() const { return NodeHI.GetDat().GetOutDeg(); }
2714      void SortNIdV() { NodeHI.GetDat().SortNIdV(); }
2715      int GetInNId(const int& NodeN) const { return NodeHI.GetDat().GetInNId(NodeN); }
2716      int GetOutNId(const int& NodeN) const { return NodeHI.GetDat().GetOutNId(NodeN); }
2717      int GetNbrNId(const int& NodeN) const { return NodeHI.GetDat().GetNbrNId(NodeN); }
2718      bool IsInNId(const int& NId) const { return NodeHI.GetDat().IsInNId(NId); }
2719      bool IsOutNId(const int& NId) const { return NodeHI.GetDat().IsOutNId(NId); }
2720      bool IsNbrNId(const int& NId) const { return IsOutNId(NId) || IsInNId(NId); }
2721      friend class TDirNet;
2722    };
2723    class TEdgeI {
2724    private:
2725      TNodeI CurNode, EndNode;
2726      int CurEdge;
2727    public:
2728      TEdgeI() : CurNode(), EndNode(), CurEdge(0) { }
2729      TEdgeI(const TNodeI& NodeI, const TNodeI& EndNodeI, const int& EdgeN=0) : CurNode(NodeI), EndNode(EndNodeI), CurEdge(EdgeN) { }
2730      TEdgeI(const TEdgeI& EdgeI) : CurNode(EdgeI.CurNode), EndNode(EdgeI.EndNode), CurEdge(EdgeI.CurEdge) { }
2731      TEdgeI& operator = (const TEdgeI& EdgeI) { if (this!=&EdgeI) { CurNode=EdgeI.CurNode; EndNode=EdgeI.EndNode; CurEdge=EdgeI.CurEdge; }  return *this; }
2732      TEdgeI& operator++ (int) { CurEdge++; if (CurEdge >= CurNode.GetOutDeg()) { CurEdge=0; CurNode++;
2733        while (CurNode < EndNode && CurNode.GetOutDeg()==0) { CurNode++; } }  return *this; }
2734      bool operator < (const TEdgeI& EdgeI) const { return CurNode<EdgeI.CurNode || (CurNode==EdgeI.CurNode && CurEdge<EdgeI.CurEdge); }
2735      bool operator == (const TEdgeI& EdgeI) const { return CurNode == EdgeI.CurNode && CurEdge == EdgeI.CurEdge; }
2736      int GetId() const { return -1; }
2737      int GetSrcNId() const { return CurNode.GetId(); }
2738      int GetDstNId() const { return CurNode.GetOutNId(CurEdge); }
2739      friend class TDirNet;
2740    };
2741  private:
2742    TCRef CRef;
2743    TInt MxNId;
2744    THash<TInt, TNode> NodeH;
2745    TAttr SAttrN;
2746    TAttrPair SAttrE;
2747  private:
2748    TNode& GetNode(const int& NId) { return NodeH.GetDat(NId); }
2749    const TNode& GetNode(const int& NId) const { return NodeH.GetDat(NId); }
2750  private:
2751    class TNodeFunctor {
2752    public:
2753      TNodeFunctor() {}
2754      void operator() (TNode* n, TShMIn& ShMIn) { n->LoadShM(ShMIn);}
2755    };
2756  private:
2757    void LoadNetworkShM(TShMIn& ShMIn) {
2758      MxNId = TInt(ShMIn);
2759      TNodeFunctor f;
2760      NodeH.LoadShM(ShMIn, f);
2761      SAttrN.Load(ShMIn);
2762      SAttrE = TAttrPair(ShMIn);
2763    }
2764  public:
2765    TDirNet() : CRef(), MxNId(0), NodeH(), SAttrN(), SAttrE() { }
2766    explicit TDirNet(const int& Nodes, const int& Edges) : MxNId(0), SAttrN(), SAttrE() { Reserve(Nodes, Edges); }
2767    TDirNet(const TDirNet& Graph) : MxNId(Graph.MxNId), NodeH(Graph.NodeH), SAttrN(), SAttrE() { }
2768    TDirNet(TSIn& SIn) : MxNId(SIn), NodeH(SIn), SAttrN(SIn), SAttrE(SIn) { }
2769    void Save(TSOut& SOut) const { MxNId.Save(SOut); NodeH.Save(SOut); SAttrN.Save(SOut); SAttrE.Save(SOut); SOut.Flush(); }
2770    void Save_V1(TSOut& SOut) const { MxNId.Save(SOut); NodeH.Save(SOut); SOut.Flush(); }
2771    static PDirNet New() { return new TDirNet(); }
2772    static PDirNet New(const int& Nodes, const int& Edges) { return new TDirNet(Nodes, Edges); }
2773    static PDirNet Load(TSIn& SIn) { return PDirNet(new TDirNet(SIn)); }
2774    static PDirNet Load_V1(TSIn& SIn) { PDirNet Graph = PDirNet(new TDirNet());
2775      Graph->MxNId.Load(SIn); Graph->NodeH.Load(SIn); return Graph;
2776    }
2777    static PDirNet LoadShM(TShMIn& ShMIn) {
2778      TDirNet* Network = new TDirNet();
2779      Network->LoadNetworkShM(ShMIn);
2780      return PDirNet(Network);
2781    }
2782    bool HasFlag(const TGraphFlag& Flag) const;
2783    TDirNet& operator = (const TDirNet& Graph) {
2784      if (this!=&Graph) { MxNId=Graph.MxNId; NodeH=Graph.NodeH; }  return *this; }
2785    int GetNodes() const { return NodeH.Len(); }
2786    int AddNode(int NId = -1);
2787    int AddNodeUnchecked(int NId = -1);
2788    int AddNode(const TNodeI& NodeId) { return AddNode(NodeId.GetId()); }
2789    int AddNode(const int& NId, const TIntV& InNIdV, const TIntV& OutNIdV);
2790    int AddNode(const int& NId, const TVecPool<TInt>& Pool, const int& SrcVId, const int& DstVId);
2791    void DelNode(const int& NId);
2792    void DelNode(const TNode& NodeI) { DelNode(NodeI.GetId()); }
2793    bool IsNode(const int& NId) const { return NodeH.IsKey(NId); }
2794    TNodeI BegNI() const { return TNodeI(NodeH.BegI()); }
2795    TNodeI EndNI() const { return TNodeI(NodeH.EndI()); }
2796    TNodeI GetNI(const int& NId) const { return TNodeI(NodeH.GetI(NId)); }
2797    int GetMxNId() const { return MxNId; }
2798    int GetEdges() const;
2799    int AddEdge(const int& SrcNId, const int& DstNId);
2800    int AddEdgeUnchecked(const int& SrcNId, const int& DstNId);
2801    int AddEdge(const TEdgeI& EdgeI) { return AddEdge(EdgeI.GetSrcNId(), EdgeI.GetDstNId()); }
2802    void DelEdge(const int& SrcNId, const int& DstNId, const bool& IsDir = true);
2803    bool IsEdge(const int& SrcNId, const int& DstNId, const bool& IsDir = true) const;
2804    TEdgeI BegEI() const { TNodeI NI=BegNI(); while(NI<EndNI() && NI.GetOutDeg()==0){NI++;} return TEdgeI(NI, EndNI()); }
2805    TEdgeI EndEI() const { return TEdgeI(EndNI(), EndNI()); }
2806    TEdgeI GetEI(const int& EId) const; 
2807    TEdgeI GetEI(const int& SrcNId, const int& DstNId) const;
2808    int GetRndNId(TRnd& Rnd=TInt::Rnd) { return NodeH.GetKey(NodeH.GetRndKeyId(Rnd, 0.8)); }
2809    TNodeI GetRndNI(TRnd& Rnd=TInt::Rnd) { return GetNI(GetRndNId(Rnd)); }
2810    void GetNIdV(TIntV& NIdV) const;
2811    bool Empty() const { return GetNodes()==0; }
2812    void Clr() { MxNId=0; NodeH.Clr(); SAttrN.Clr(); SAttrE.Clr(); }
2813    void Reserve(const int& Nodes, const int& Edges) { if (Nodes>0) { NodeH.Gen(Nodes/2); } }
2814    void ReserveNIdInDeg(const int& NId, const int& InDeg) { GetNode(NId).InNIdV.Reserve(InDeg); }
2815    void ReserveNIdOutDeg(const int& NId, const int& OutDeg) { GetNode(NId).OutNIdV.Reserve(OutDeg); }
2816    void SortNodeAdjV() { for (TNodeI NI = BegNI(); NI < EndNI(); NI++) { NI.SortNIdV();} }
2817    void Defrag(const bool& OnlyNodeLinks=false);
2818    bool IsOk(const bool& ThrowExcept=true) const;
2819    void Dump(FILE *OutF=stdout) const;
2820    static PDirNet GetSmallGraph();
2821    int AddSAttrDatN(const TInt& NId, const TStr& AttrName, const TInt& Val);
2822    int AddSAttrDatN(const TInt& NId, const TInt& AttrId, const TInt& Val);
2823    int AddSAttrDatN(const TNodeI& NodeI, const TStr& AttrName, const TInt& Val) {
2824      return AddSAttrDatN(NodeI.GetId(), AttrName, Val);
2825    }
2826    int AddSAttrDatN(const TNodeI& NodeI, const TInt& AttrId, const TInt& Val) {
2827      return AddSAttrDatN(NodeI.GetId(), AttrId, Val);
2828    }
2829    int AddSAttrDatN(const TInt& NId, const TStr& AttrName, const TFlt& Val);
2830    int AddSAttrDatN(const TInt& NId, const TInt& AttrId, const TFlt& Val);
2831    int AddSAttrDatN(const TNodeI& NodeI, const TStr& AttrName, const TFlt& Val) {
2832      return AddSAttrDatN(NodeI.GetId(), AttrName, Val);
2833    }
2834    int AddSAttrDatN(const TNodeI& NodeI, const TInt& AttrId, const TFlt& Val) {
2835      return AddSAttrDatN(NodeI.GetId(), AttrId, Val);
2836    }
2837    int AddSAttrDatN(const TInt& NId, const TStr& AttrName, const TStr& Val);
2838    int AddSAttrDatN(const TInt& NId, const TInt& AttrId, const TStr& Val);
2839    int AddSAttrDatN(const TNodeI& NodeI, const TStr& AttrName, const TStr& Val) {
2840      return AddSAttrDatN(NodeI.GetId(), AttrName, Val);
2841    }
2842    int AddSAttrDatN(const TNodeI& NodeI, const TInt& AttrId, const TStr& Val) {
2843      return AddSAttrDatN(NodeI.GetId(), AttrId, Val);
2844    }
2845    int GetSAttrDatN(const TInt& NId, const TStr& AttrName, TInt& ValX) const;
2846    int GetSAttrDatN(const TInt& NId, const TInt& AttrId, TInt& ValX) const;
2847    int GetSAttrDatN(const TNodeI& NodeI, const TStr& AttrName, TInt& ValX) const {
2848      return GetSAttrDatN(NodeI.GetId(), AttrName, ValX);
2849    }
2850    int GetSAttrDatN(const TNodeI& NodeI, const TInt& AttrId, TInt& ValX) const {
2851      return GetSAttrDatN(NodeI.GetId(), AttrId, ValX);
2852    }
2853    int GetSAttrDatN(const TInt& NId, const TStr& AttrName, TFlt& ValX) const;
2854    int GetSAttrDatN(const TInt& NId, const TInt& AttrId, TFlt& ValX) const;
2855    int GetSAttrDatN(const TNodeI& NodeI, const TStr& AttrName, TFlt& ValX) const {
2856      return GetSAttrDatN(NodeI.GetId(), AttrName, ValX);
2857    } 
2858    int GetSAttrDatN(const TNodeI& NodeI, const TInt& AttrId, TFlt& ValX) const {
2859      return GetSAttrDatN(NodeI.GetId(), AttrId, ValX);
2860    }
2861    int GetSAttrDatN(const TInt& NId, const TStr& AttrName, TStr& ValX) const;
2862    int GetSAttrDatN(const TInt& NId, const TInt& AttrId, TStr& ValX) const;
2863    int GetSAttrDatN(const TNodeI& NodeI, const TStr& AttrName, TStr& ValX) const {
2864      return GetSAttrDatN(NodeI.GetId(), AttrName, ValX);
2865    }
2866    int GetSAttrDatN(const TNodeI& NodeI, const TInt& AttrId, TStr& ValX) const {
2867      return GetSAttrDatN(NodeI.GetId(), AttrId, ValX);
2868    }
2869    int DelSAttrDatN(const TInt& NId, const TStr& AttrName);
2870    int DelSAttrDatN(const TInt& NId, const TInt& AttrId);
2871    int DelSAttrDatN(const TNodeI& NodeI, const TStr& AttrName) {
2872      return DelSAttrDatN(NodeI.GetId(), AttrName);
2873    }
2874    int DelSAttrDatN(const TNodeI& NodeI, const TInt& AttrId) {
2875      return DelSAttrDatN(NodeI.GetId(), AttrId);
2876    }
2877    int GetSAttrVN(const TInt& NId, const TAttrType AttrType, TAttrPrV& AttrV) const;
2878    int GetSAttrVN(const TNodeI& NodeI, const TAttrType AttrType, TAttrPrV& AttrV) const {
2879      return GetSAttrVN(NodeI.GetId(), AttrType, AttrV);
2880    }
2881    int GetIdVSAttrN(const TStr& AttrName, TIntV& IdV) const;
2882    int GetIdVSAttrN(const TInt& AttrId, TIntV& IdV) const;
2883    int AddSAttrN(const TStr& Name, const TAttrType& AttrType, TInt& AttrId);
2884    int GetSAttrIdN(const TStr& Name, TInt& AttrIdX, TAttrType& AttrTypeX) const;
2885    int GetSAttrNameN(const TInt& AttrId, TStr& NameX, TAttrType& AttrTypeX) const;
2886    int AddSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, const TInt& Val);
2887    int AddSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, const TInt& Val);
2888    int AddSAttrDatE(const TEdgeI& EdgeI, const TStr& AttrName, const TInt& Val) {
2889      return AddSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrName, Val);
2890    }
2891    int AddSAttrDatE(const TEdgeI& EdgeI, const TInt& AttrId, const TInt& Val) {
2892      return AddSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrId, Val);
2893    }
2894    int AddSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, const TFlt& Val);
2895    int AddSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, const TFlt& Val);
2896    int AddSAttrDatE(const TEdgeI& EdgeI, const TStr& AttrName, const TFlt& Val) {
2897      return AddSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrName, Val);
2898    }
2899    int AddSAttrDatE(const TEdgeI& EdgeI, const TInt& AttrId, const TFlt& Val){
2900      return AddSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrId, Val);
2901    }
2902    int AddSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, const TStr& Val);
2903    int AddSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, const TStr& Val);
2904    int AddSAttrDatE(const TEdgeI& EdgeI, const TStr& AttrName, const TStr& Val) {
2905      return AddSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrName, Val);
2906    }
2907    int AddSAttrDatE(const TEdgeI& EdgeI, const TInt& AttrId, const TStr& Val) {
2908      return AddSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrId, Val);
2909    }
2910    int GetSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, TInt& ValX) const;
2911    int GetSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, TInt& ValX) const;
2912    int GetSAttrDatE(const TEdgeI& EdgeI, const TStr& AttrName, TInt& ValX) const {
2913      return GetSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrName, ValX);
2914    }
2915    int GetSAttrDatE(const TEdgeI& EdgeI, const TInt& AttrId, TInt& ValX) const {
2916      return GetSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrId, ValX);
2917    } 
2918    int GetSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, TFlt& ValX) const; 
2919    int GetSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, TFlt& ValX) const;
2920    int GetSAttrDatE(const TEdgeI& EdgeI, const TStr& AttrName, TFlt& ValX) const {
2921      return GetSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrName, ValX);
2922    }
2923    int GetSAttrDatE(const TEdgeI& EdgeI, const TInt& AttrId, TFlt& ValX) const {
2924      return GetSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrId, ValX);
2925    } 
2926    int GetSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName, TStr& ValX) const;
2927    int GetSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId, TStr& ValX) const;
2928    int GetSAttrDatE(const TEdgeI& EdgeI, const TStr& AttrName, TStr& ValX) const {
2929      return GetSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrName, ValX);
2930    }
2931    int GetSAttrDatE(const TEdgeI& EdgeI, const TInt& AttrId, TStr& ValX) const {
2932      return GetSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrId, ValX);
2933    }
2934    int DelSAttrDatE(const int& SrcNId, const int& DstNId, const TStr& AttrName);
2935    int DelSAttrDatE(const int& SrcNId, const int& DstNId, const TInt& AttrId);
2936    int DelSAttrDatE(const TEdgeI& EdgeI, const TStr& AttrName) {
2937      return DelSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrName);
2938    }
2939    int DelSAttrDatE(const TEdgeI& EdgeI, const TInt& AttrId) {
2940      return DelSAttrDatE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrId);
2941    } 
2942    int GetSAttrVE(const int& SrcNId, const int& DstNId, const TAttrType AttrType, TAttrPrV& AttrV) const;
2943    int GetSAttrVE(const TEdgeI& EdgeI, const TAttrType AttrType, TAttrPrV& AttrV) const {
2944      return GetSAttrVE(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), AttrType, AttrV);
2945    }
2946    int GetIdVSAttrE(const TStr& AttrName, TIntPrV& IdV) const;
2947    int GetIdVSAttrE(const TInt& AttrId, TIntPrV& IdV) const;
2948    int AddSAttrE(const TStr& Name, const TAttrType& AttrType, TInt& AttrId);
2949    int GetSAttrIdE(const TStr& Name, TInt& AttrIdX, TAttrType& AttrTypeX) const;
2950    int GetSAttrNameE(const TInt& AttrId, TStr& NameX, TAttrType& AttrTypeX) const;
2951    friend class TPt<TDirNet>;
2952    friend class TDirNetMtx;
2953  };
2954  namespace TSnap {
2955  template <> struct IsDirected<TDirNet> { enum { Val = 1 }; };
2956  }
2957  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-tesseractclass.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-network.h</div>
                </div>
                <div class="column column_space"><pre><code>235                          const char *word_config);
236    void bigram_correction_pass(PAGE_RES *page_res);
237    void blamer_pass(PAGE_RES *page_res);
238    void script_pos_pass(PAGE_RES *page_res);
239    int RetryWithLanguage(const WordData &word_data, WordRecognizer recognizer, bool debug,
240                          WERD_RES **in_word, PointerVector<WERD_RES> *best_words);
241    bool ReassignDiacritics(int pass, PAGE_RES_IT *pr_it, bool *make_next_word_fuzzy);
242    void AssignDiacriticsToOverlappingBlobs(const std::vector<C_OUTLINE *> &outlines, int pass,
243                                            WERD *real_word, PAGE_RES_IT *pr_it,
244                                            std::vector<bool> *word_wanted,
245                                            std::vector<bool> *overlapped_any_blob,
246                                            std::vector<C_BLOB *> *target_blobs);
247    void AssignDiacriticsToNewBlobs(const std::vector<C_OUTLINE *> &outlines, int pass,
</pre></code></div>
                <div class="column column_space"><pre><code>504    int AddEdge(const int& SrcNId, const int& DstNId);
505    int AddEdge(const int& SrcNId, const int& DstNId, const TEdgeData& EdgeDat);
506    int AddEdge(const TEdgeI& EdgeI) { return AddEdge(EdgeI.GetSrcNId(), EdgeI.GetDstNId(), EdgeI()); }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    