
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 1.9313304721030045%, Tokens: 9</h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-message.cpp</h3>
            <pre><code>1  #include <nano/crypto_lib/random_pool.hpp>
2  #include <nano/node/common.hpp>
3  #include <nano/node/network.hpp>
4  #include <nano/secure/buffer.hpp>
5  #include <nano/test_common/testutil.hpp>
6  #include <gtest/gtest.h>
7  #include <boost/asio/ip/address_v6.hpp>
8  namespace
9  {
10  std::shared_ptr<nano::block> random_block ()
11  {
12  	nano::block_builder builder;
13  	auto block = builder
14  				 .send ()
15  				 .previous (nano::test::random_hash ())
16  				 .destination (nano::keypair ().pub)
17  				 .balance (2)
18  				 .sign (nano::keypair ().prv, 4)
19  				 .work (5)
20  				 .build_shared ();
21  	return block;
22  }
23  }
24  TEST (message, keepalive_serialization)
25  {
26  	nano::keepalive request1{ nano::dev::network_params.network };
27  	std::vector<uint8_t> bytes;
28  	{
29  		nano::vectorstream stream (bytes);
30  		request1.serialize (stream);
31  	}
32  	auto error (false);
33  	nano::bufferstream stream (bytes.data (), bytes.size ());
34  	nano::message_header header (error, stream);
35  	ASSERT_FALSE (error);
36  	nano::keepalive request2 (error, stream, header);
37  	ASSERT_FALSE (error);
38  	ASSERT_EQ (request1, request2);
39  }
40  TEST (message, keepalive_deserialize)
41  {
42  	nano::keepalive message1{ nano::dev::network_params.network };
43  	message1.peers[0] = nano::endpoint (boost::asio::ip::address_v6::loopback (), 10000);
44  	std::vector<uint8_t> bytes;
45  	{
46  		nano::vectorstream stream (bytes);
47  		message1.serialize (stream);
48  	}
49  	nano::bufferstream stream (bytes.data (), bytes.size ());
50  	auto error (false);
51  	nano::message_header header (error, stream);
52  	ASSERT_FALSE (error);
53  	ASSERT_EQ (nano::message_type::keepalive, header.type);
54  	nano::keepalive message2 (error, stream, header);
55  	ASSERT_FALSE (error);
56  	ASSERT_EQ (message1.peers, message2.peers);
57  }
58  TEST (message, publish_serialization)
59  {
60  	auto block = random_block ();
61  	nano::publish publish{ nano::dev::network_params.network, block };
62  	ASSERT_EQ (nano::block_type::send, publish.header.block_type ());
63  	std::vector<uint8_t> bytes;
64  	{
65  		nano::vectorstream stream (bytes);
66  		publish.header.serialize (stream);
67  	}
68  	ASSERT_EQ (8, bytes.size ());
69  	ASSERT_EQ (0x52, bytes[0]);
70  	ASSERT_EQ (0x41, bytes[1]);
71  	ASSERT_EQ (nano::dev::network_params.network.protocol_version, bytes[2]);
72  	ASSERT_EQ (nano::dev::network_params.network.protocol_version, bytes[3]);
73  	ASSERT_EQ (nano::dev::network_params.network.protocol_version_min, bytes[4]);
74  	ASSERT_EQ (static_cast<uint8_t> (nano::message_type::publish), bytes[5]);
75  	ASSERT_EQ (0x00, bytes[6]); 
76  	ASSERT_EQ (static_cast<uint8_t> (nano::block_type::send), bytes[7]);
77  	nano::bufferstream stream (bytes.data (), bytes.size ());
78  	auto error (false);
79  	nano::message_header header (error, stream);
80  	ASSERT_FALSE (error);
81  	ASSERT_EQ (nano::dev::network_params.network.protocol_version_min, header.version_min);
82  	ASSERT_EQ (nano::dev::network_params.network.protocol_version, header.version_using);
83  	ASSERT_EQ (nano::dev::network_params.network.protocol_version, header.version_max);
84  	ASSERT_EQ (nano::message_type::publish, header.type);
85  }
86  TEST (message, confirm_ack_hash_serialization)
87  {
88  	std::vector<nano::block_hash> hashes;
89  	for (auto i (hashes.size ()); i < nano::network::confirm_ack_hashes_max; i++)
90  	{
91  		nano::keypair key1;
92  		nano::block_hash previous;
93  		nano::random_pool::generate_block (previous.bytes.data (), previous.bytes.size ());
94  		nano::block_builder builder;
95  		auto block = builder
96  					 .state ()
97  					 .account (key1.pub)
98  					 .previous (previous)
99  					 .representative (key1.pub)
100  					 .balance (2)
101  					 .link (4)
102  					 .sign (key1.prv, key1.pub)
103  					 .work (5)
104  					 .build ();
105  		hashes.push_back (block->hash ());
106  	}
107  	nano::keypair representative1;
108  	auto vote (std::make_shared<nano::vote> (representative1.pub, representative1.prv, 0, 0, hashes));
109  	nano::confirm_ack con1{ nano::dev::network_params.network, vote };
110  	std::vector<uint8_t> bytes;
111  	{
112  		nano::vectorstream stream1 (bytes);
113  		con1.serialize (stream1);
114  	}
115  	nano::bufferstream stream2 (bytes.data (), bytes.size ());
116  	bool error (false);
117  	nano::message_header header (error, stream2);
118  	nano::confirm_ack con2 (error, stream2, header);
119  	ASSERT_FALSE (error);
120  	ASSERT_EQ (con1, con2);
121  	ASSERT_EQ (hashes, con2.vote->hashes);
122  	ASSERT_EQ (header.count_get (), hashes.size ());
123  	ASSERT_EQ (header.block_type (), nano::block_type::not_a_block);
124  }
125  TEST (message, confirm_req_serialization)
126  {
127  	nano::keypair key1;
128  	nano::keypair key2;
129  	nano::block_builder builder;
130  	auto block = builder
131  				 .send ()
132  				 .previous (0)
133  				 .destination (key2.pub)
134  				 .balance (200)
135  				 .sign (nano::keypair ().prv, 2)
136  				 .work (3)
137  				 .build_shared ();
138  	nano::confirm_req req{ nano::dev::network_params.network, block };
139  	std::vector<uint8_t> bytes;
140  	{
141  		nano::vectorstream stream (bytes);
142  		req.serialize (stream);
143  	}
144  	auto error (false);
145  	nano::bufferstream stream2 (bytes.data (), bytes.size ());
146  	nano::message_header header (error, stream2);
147  	nano::confirm_req req2 (error, stream2, header);
148  	ASSERT_FALSE (error);
149  	ASSERT_EQ (req, req2);
150  	ASSERT_EQ (*req.block, *req2.block);
151  }
152  TEST (message, confirm_req_hash_serialization)
153  {
154  	nano::keypair key1;
155  	nano::keypair key2;
156  	nano::block_builder builder;
157  	auto block = builder
158  				 .send ()
159  				 .previous (1)
160  				 .destination (key2.pub)
161  				 .balance (200)
162  				 .sign (nano::keypair ().prv, 2)
163  				 .work (3)
164  				 .build ();
165  	nano::confirm_req req{ nano::dev::network_params.network, block->hash (), block->root () };
166  	std::vector<uint8_t> bytes;
167  	{
168  		nano::vectorstream stream (bytes);
169  		req.serialize (stream);
170  	}
171  	auto error (false);
172  	nano::bufferstream stream2 (bytes.data (), bytes.size ());
173  	nano::message_header header (error, stream2);
174  	nano::confirm_req req2 (error, stream2, header);
175  	ASSERT_FALSE (error);
176  	ASSERT_EQ (req, req2);
177  	ASSERT_EQ (req.roots_hashes, req2.roots_hashes);
178  	ASSERT_EQ (header.block_type (), nano::block_type::not_a_block);
179  	ASSERT_EQ (header.count_get (), req.roots_hashes.size ());
180  }
181  TEST (message, confirm_req_hash_batch_serialization)
182  {
183  	nano::keypair key;
184  	nano::keypair representative;
185  	std::vector<std::pair<nano::block_hash, nano::root>> roots_hashes;
186  	nano::block_builder builder;
187  	auto open = builder
188  				.state ()
189  				.account (key.pub)
190  				.previous (0)
191  				.representative (representative.pub)
192  				.balance (2)
193  				.link (4)
194  				.sign (key.prv, key.pub)
195  				.work (5)
196  				.build ();
197  	roots_hashes.push_back (std::make_pair (open->hash (), open->root ()));
198  	for (auto i (roots_hashes.size ()); i < 7; i++)
199  	{
200  		nano::keypair key1;
201  		nano::block_hash previous;
202  		nano::random_pool::generate_block (previous.bytes.data (), previous.bytes.size ());
203  		auto block = builder
204  					 .state ()
205  					 .account (key1.pub)
206  					 .previous (previous)
207  					 .representative (representative.pub)
208  					 .balance (2)
209  					 .link (4)
210  					 .sign (key1.prv, key1.pub)
211  					 .work (5)
212  					 .build ();
213  		roots_hashes.push_back (std::make_pair (block->hash (), block->root ()));
214  	}
215  	roots_hashes.push_back (std::make_pair (open->hash (), open->root ()));
216  	nano::confirm_req req{ nano::dev::network_params.network, roots_hashes };
217  	std::vector<uint8_t> bytes;
218  	{
219  		nano::vectorstream stream (bytes);
220  		req.serialize (stream);
221  	}
222  	auto error (false);
223  	nano::bufferstream stream2 (bytes.data (), bytes.size ());
224  	nano::message_header header (error, stream2);
225  	nano::confirm_req req2 (error, stream2, header);
226  	ASSERT_FALSE (error);
227  	ASSERT_EQ (req, req2);
228  	ASSERT_EQ (req.roots_hashes, req2.roots_hashes);
229  	ASSERT_EQ (req.roots_hashes, roots_hashes);
230  	ASSERT_EQ (req2.roots_hashes, roots_hashes);
231  	ASSERT_EQ (header.block_type (), nano::block_type::not_a_block);
232  	ASSERT_EQ (header.count_get (), req.roots_hashes.size ());
233  }
234  TEST (message, message_header_to_string)
235  {
236  	int maxver = nano::dev::network_params.network.protocol_version;
237  	int minver = nano::dev::network_params.network.protocol_version_min;
238  	std::stringstream ss;
239  	ss << "NetID: 5241(dev), VerMaxUsingMin: " << maxver << "/" << maxver << "/" << minver << ", MsgType: 2(keepalive), Extensions: 0000";
240  	auto expected_str = ss.str ();
241  	nano::keepalive keepalive_msg{ nano::dev::network_params.network };
242  	std::string header_string = keepalive_msg.header.to_string ();
243  	ASSERT_EQ (expected_str, header_string);
244  }
245  TEST (confirm_ack, empty_vote_hashes)
246  {
247  	nano::keypair key;
248  	auto vote = std::make_shared<nano::vote> (key.pub, key.prv, 0, 0, std::vector<nano::block_hash>{} &bsol;* empty */);
249  	nano::confirm_ack message{ nano::dev::network_params.network, vote };
250  }
251  TEST (message, bulk_pull_serialization)
252  {
253  	nano::bulk_pull message_in{ nano::dev::network_params.network };
254  	message_in.header.flag_set (nano::message_header::bulk_pull_ascending_flag);
255  	std::vector<uint8_t> bytes;
256  	{
257  		nano::vectorstream stream{ bytes };
258  		message_in.serialize (stream);
259  	}
260  	nano::bufferstream stream{ bytes.data (), bytes.size () };
261  	bool error = false;
262  	nano::message_header header{ error, stream };
263  	ASSERT_FALSE (error);
264  	nano::bulk_pull message_out{ error, stream, header };
265  	ASSERT_FALSE (error);
266  	ASSERT_TRUE (header.bulk_pull_ascending ());
267  }
268  TEST (message, asc_pull_req_serialization_blocks)
269  {
270  	nano::asc_pull_req original{ nano::dev::network_params.network };
271  	original.id = 7;
272  	original.type = nano::asc_pull_type::blocks;
273  	nano::asc_pull_req::blocks_payload original_payload;
274  	original_payload.start = nano::test::random_hash ();
275  	original_payload.count = 111;
276  	original.payload = original_payload;
277  	original.update_header ();
278  	std::vector<uint8_t> bytes;
279  	{
280  		nano::vectorstream stream{ bytes };
281  		original.serialize (stream);
282  	}
283  	nano::bufferstream stream{ bytes.data (), bytes.size () };
284  	bool error = false;
285  	nano::message_header header (error, stream);
286  	ASSERT_FALSE (error);
287  	ASSERT_EQ (nano::message_type::asc_pull_req, header.type);
288  	nano::asc_pull_req message (error, stream, header);
289  	ASSERT_FALSE (error);
290  	ASSERT_EQ (original.id, message.id);
291  	ASSERT_EQ (original.type, message.type);
292  	nano::asc_pull_req::blocks_payload message_payload;
293  	ASSERT_NO_THROW (message_payload = std::get<nano::asc_pull_req::blocks_payload> (message.payload));
294  	ASSERT_EQ (original_payload.start, message_payload.start);
295  	ASSERT_EQ (original_payload.count, message_payload.count);
296  	ASSERT_TRUE (nano::at_end (stream));
297  }
298  TEST (message, asc_pull_req_serialization_account_info)
299  {
300  	nano::asc_pull_req original{ nano::dev::network_params.network };
301  	original.id = 7;
302  	original.type = nano::asc_pull_type::account_info;
303  	nano::asc_pull_req::account_info_payload original_payload;
304  	original_payload.target = nano::test::random_hash ();
305  	original.payload = original_payload;
306  	original.update_header ();
307  	std::vector<uint8_t> bytes;
308  	{
309  		nano::vectorstream stream{ bytes };
310  		original.serialize (stream);
311  	}
312  	nano::bufferstream stream{ bytes.data (), bytes.size () };
313  	bool error = false;
314  	nano::message_header header (error, stream);
315  	ASSERT_FALSE (error);
316  	ASSERT_EQ (nano::message_type::asc_pull_req, header.type);
317  	nano::asc_pull_req message (error, stream, header);
318  	ASSERT_FALSE (error);
319  	ASSERT_EQ (original.id, message.id);
320  	ASSERT_EQ (original.type, message.type);
321  	nano::asc_pull_req::account_info_payload message_payload;
322  	ASSERT_NO_THROW (message_payload = std::get<nano::asc_pull_req::account_info_payload> (message.payload));
323  	ASSERT_EQ (original_payload.target, message_payload.target);
324  	ASSERT_TRUE (nano::at_end (stream));
325  }
326  TEST (message, asc_pull_ack_serialization_blocks)
327  {
328  	nano::asc_pull_ack original{ nano::dev::network_params.network };
329  	original.id = 11;
330  	original.type = nano::asc_pull_type::blocks;
331  	nano::asc_pull_ack::blocks_payload original_payload;
<span onclick='openModal()' class='match'>332  	const int num_blocks = 128; 
333  	for (int n = 0; n < num_blocks; ++n)
334  	{
335  		original_payload.blocks.push_back (random_block ());
336  	}
</span>337  	original.payload = original_payload;
338  	original.update_header ();
339  	std::vector<uint8_t> bytes;
340  	{
341  		nano::vectorstream stream{ bytes };
342  		original.serialize (stream);
343  	}
344  	nano::bufferstream stream{ bytes.data (), bytes.size () };
345  	bool error = false;
346  	nano::message_header header (error, stream);
347  	ASSERT_FALSE (error);
348  	ASSERT_EQ (nano::message_type::asc_pull_ack, header.type);
349  	nano::asc_pull_ack message (error, stream, header);
350  	ASSERT_FALSE (error);
351  	ASSERT_EQ (original.id, message.id);
352  	ASSERT_EQ (original.type, message.type);
353  	nano::asc_pull_ack::blocks_payload message_payload;
354  	ASSERT_NO_THROW (message_payload = std::get<nano::asc_pull_ack::blocks_payload> (message.payload));
355  	ASSERT_EQ (original_payload.blocks.size (), message_payload.blocks.size ());
356  	ASSERT_TRUE (std::equal (original_payload.blocks.begin (), original_payload.blocks.end (), message_payload.blocks.begin (), message_payload.blocks.end (), [] (auto a, auto b) {
357  		return *a == *b;
358  	}));
359  	ASSERT_TRUE (nano::at_end (stream));
360  }
361  TEST (message, asc_pull_ack_serialization_account_info)
362  {
363  	nano::asc_pull_ack original{ nano::dev::network_params.network };
364  	original.id = 11;
365  	original.type = nano::asc_pull_type::account_info;
366  	nano::asc_pull_ack::account_info_payload original_payload;
367  	original_payload.account = nano::test::random_account ();
368  	original_payload.account_open = nano::test::random_hash ();
369  	original_payload.account_head = nano::test::random_hash ();
370  	original_payload.account_block_count = 932932132;
371  	original_payload.account_conf_frontier = nano::test::random_hash ();
372  	original_payload.account_conf_height = 847312;
373  	original.payload = original_payload;
374  	original.update_header ();
375  	std::vector<uint8_t> bytes;
376  	{
377  		nano::vectorstream stream{ bytes };
378  		original.serialize (stream);
379  	}
380  	nano::bufferstream stream{ bytes.data (), bytes.size () };
381  	bool error = false;
382  	nano::message_header header (error, stream);
383  	ASSERT_FALSE (error);
384  	ASSERT_EQ (nano::message_type::asc_pull_ack, header.type);
385  	nano::asc_pull_ack message (error, stream, header);
386  	ASSERT_FALSE (error);
387  	ASSERT_EQ (original.id, message.id);
388  	ASSERT_EQ (original.type, message.type);
389  	nano::asc_pull_ack::account_info_payload message_payload;
390  	ASSERT_NO_THROW (message_payload = std::get<nano::asc_pull_ack::account_info_payload> (message.payload));
391  	ASSERT_EQ (original_payload.account, message_payload.account);
392  	ASSERT_EQ (original_payload.account_open, message_payload.account_open);
393  	ASSERT_EQ (original_payload.account_head, message_payload.account_head);
394  	ASSERT_EQ (original_payload.account_block_count, message_payload.account_block_count);
395  	ASSERT_EQ (original_payload.account_conf_frontier, message_payload.account_conf_frontier);
396  	ASSERT_EQ (original_payload.account_conf_height, message_payload.account_conf_height);
397  	ASSERT_TRUE (nano::at_end (stream));
398  }
399  TEST (message, node_id_handshake_query_serialization)
400  {
401  	nano::node_id_handshake::query_payload query{};
402  	query.cookie = 7;
403  	nano::node_id_handshake original{ nano::dev::network_params.network, query };
404  	std::vector<uint8_t> bytes;
405  	{
406  		nano::vectorstream stream{ bytes };
407  		original.serialize (stream);
408  	}
409  	nano::bufferstream stream{ bytes.data (), bytes.size () };
410  	bool error = false;
411  	nano::message_header header (error, stream);
412  	ASSERT_FALSE (error);
413  	ASSERT_EQ (nano::message_type::node_id_handshake, header.type);
414  	nano::node_id_handshake message{ error, stream, header };
415  	ASSERT_FALSE (error);
416  	ASSERT_TRUE (message.query);
417  	ASSERT_FALSE (message.response);
418  	ASSERT_EQ (original.query->cookie, message.query->cookie);
419  	ASSERT_TRUE (nano::at_end (stream));
420  }
421  TEST (message, node_id_handshake_response_serialization)
422  {
423  	nano::node_id_handshake::response_payload response{};
424  	response.node_id = nano::account{ 7 };
425  	response.signature = nano::signature{ 11 };
426  	nano::node_id_handshake original{ nano::dev::network_params.network, std::nullopt, response };
427  	std::vector<uint8_t> bytes;
428  	{
429  		nano::vectorstream stream{ bytes };
430  		original.serialize (stream);
431  	}
432  	nano::bufferstream stream{ bytes.data (), bytes.size () };
433  	bool error = false;
434  	nano::message_header header (error, stream);
435  	ASSERT_FALSE (error);
436  	ASSERT_EQ (nano::message_type::node_id_handshake, header.type);
437  	nano::node_id_handshake message{ error, stream, header };
438  	ASSERT_FALSE (error);
439  	ASSERT_FALSE (message.query);
440  	ASSERT_TRUE (message.response);
441  	ASSERT_FALSE (message.response->v2);
442  	ASSERT_EQ (original.response->node_id, message.response->node_id);
443  	ASSERT_EQ (original.response->signature, message.response->signature);
444  	ASSERT_TRUE (nano::at_end (stream));
445  }
446  TEST (message, node_id_handshake_response_v2_serialization)
447  {
448  	nano::node_id_handshake::response_payload response{};
449  	response.node_id = nano::account{ 7 };
450  	response.signature = nano::signature{ 11 };
451  	nano::node_id_handshake::response_payload::v2_payload v2_pld{};
452  	v2_pld.salt = 17;
453  	v2_pld.genesis = nano::block_hash{ 13 };
454  	response.v2 = v2_pld;
455  	nano::node_id_handshake original{ nano::dev::network_params.network, std::nullopt, response };
456  	std::vector<uint8_t> bytes;
457  	{
458  		nano::vectorstream stream{ bytes };
459  		original.serialize (stream);
460  	}
461  	nano::bufferstream stream{ bytes.data (), bytes.size () };
462  	bool error = false;
463  	nano::message_header header (error, stream);
464  	ASSERT_FALSE (error);
465  	ASSERT_EQ (nano::message_type::node_id_handshake, header.type);
466  	nano::node_id_handshake message{ error, stream, header };
467  	ASSERT_FALSE (error);
468  	ASSERT_FALSE (message.query);
469  	ASSERT_TRUE (message.response);
470  	ASSERT_TRUE (message.response->v2);
471  	ASSERT_EQ (original.response->node_id, message.response->node_id);
472  	ASSERT_EQ (original.response->signature, message.response->signature);
473  	ASSERT_EQ (original.response->v2->salt, message.response->v2->salt);
474  	ASSERT_EQ (original.response->v2->genesis, message.response->v2->genesis);
475  	ASSERT_TRUE (nano::at_end (stream));
476  }
477  TEST (handshake, signature)
478  {
479  	nano::keypair node_id{};
480  	nano::keypair node_id_2{};
481  	auto cookie = nano::random_pool::generate<nano::uint256_union> ();
482  	auto cookie_2 = nano::random_pool::generate<nano::uint256_union> ();
483  	nano::node_id_handshake::response_payload response{};
484  	response.node_id = node_id.pub;
485  	response.sign (cookie, node_id);
486  	ASSERT_TRUE (response.validate (cookie));
487  	ASSERT_FALSE (response.validate (cookie_2));
488  	response.node_id = node_id_2.pub;
489  	ASSERT_FALSE (response.validate (cookie));
490  }
491  TEST (handshake, signature_v2)
492  {
493  	nano::keypair node_id{};
494  	nano::keypair node_id_2{};
495  	auto cookie = nano::random_pool::generate<nano::uint256_union> ();
496  	auto cookie_2 = nano::random_pool::generate<nano::uint256_union> ();
497  	nano::node_id_handshake::response_payload original{};
498  	original.node_id = node_id.pub;
499  	original.v2 = nano::node_id_handshake::response_payload::v2_payload{};
500  	original.v2->genesis = nano::test::random_hash ();
501  	original.v2->salt = nano::random_pool::generate<nano::uint256_union> ();
502  	original.sign (cookie, node_id);
503  	ASSERT_TRUE (original.validate (cookie));
504  	ASSERT_FALSE (original.validate (cookie_2));
505  	{
506  		auto message = original;
507  		ASSERT_TRUE (message.validate (cookie));
508  		message.node_id = node_id_2.pub;
509  		ASSERT_FALSE (message.validate (cookie));
510  	}
511  	{
512  		auto message = original;
513  		ASSERT_TRUE (message.validate (cookie));
514  		message.v2->genesis = nano::test::random_hash ();
515  		ASSERT_FALSE (message.validate (cookie));
516  	}
517  	{
518  		auto message = original;
519  		ASSERT_TRUE (message.validate (cookie));
520  		message.v2->salt = nano::random_pool::generate<nano::uint256_union> ();
521  		ASSERT_FALSE (message.validate (cookie));
522  	}
523  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-sir.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "sir.h"
3  void TEpidemModel::RunModel(const TFltV& StartValV, const double& StartT, const double& StopT, const int& NSteps, TVec<TFltV>& OutValV) {
4    TFltV ValV(StartValV), dydx(StartValV.Len()), ValV2(StartValV.Len());
5    OutValV.Clr(false);
6    for (int v = 0; v < StartValV.Len(); v++) {
7      OutValV.Add();
8      OutValV[v].Clr(false);
9      OutValV[v].Add(StartValV[v]);
10    }
11    const double h = (StopT-StartT) / NSteps;
12    double x = StartT;
13    for (int k = 0; k < NSteps; k++) {
14      GetDerivs(x, ValV, dydx);
15      RungeKutta(ValV, dydx, x, h, ValV2);
16      for (int v = 0; v < ValV2.Len(); v++) {
17        double X = ValV2[v];
18        if (X < 0 || _isnan(X) || !_finite(X)) { X = 0; }
19        OutValV[v].Add(X);
20      }
21      ValV = ValV2;
22      x += h;
23    }
24  }
25  void TEpidemModel::RunModel10(const TFltV& StartValV, const double& StartT, const double& StopT, const int& NSteps, TVec<TFltV>& OutValV) {
26    TFltV ValV(StartValV), dydx(StartValV.Len()), ValV2(StartValV.Len());
27    OutValV.Clr(false);
28    for (int v = 0; v < StartValV.Len(); v++) {
29      OutValV.Add();
30      OutValV[v].Clr(false);
31      OutValV[v].Add(StartValV[v]);
32    }
33    const double h = (StopT-StartT) / (10*NSteps);
34    double x = StartT;
35    for (int k = 0; k < 10*NSteps; k++) {
36      GetDerivs(x, ValV, dydx);
37      RungeKutta(ValV, dydx, x, h, ValV2);
38      if (k % 10 == 0) {
39        for (int v = 0; v < ValV2.Len(); v++) {
40          OutValV[v].Add(ValV2[v]); }
41      }
42      ValV = ValV2;
43      x += h;
44    }
45  }
46  void TEpidemModel::RunEuler(const TFltV& StartValV, const double& StartT, const double& StopT, const int& NSteps, TVec<TFltV>& OutValV) {
<span onclick='openModal()' class='match'>47    const double h = (StopT-StartT) / NSteps;
48    TFltV ValV(StartValV), dydx(StartValV.Len()), ValV2(StartValV.Len());
49    for (int v = 0; v < StartValV.Len(); v++) {
50      OutValV.Add();
51      OutValV[v].Clr(false);
52      OutValV[v].Add(StartValV[v]);
53    }
</span>54    OutValV.Add(); 
55    OutValV.Last().Add(StartT);
56    for (double x = StartT; x <= StopT; x += h) {
57      GetDerivs(x, ValV, dydx);
58      for (int v = 0; v < ValV.Len(); v++) {
59        ValV[v] += h*dydx[v];
60        OutValV[v].Add(ValV[v]);
61      }
62      OutValV.Last().Add(x+h);
63    }
64    for (int v = 1; v < OutValV.Len(); v++) {
65      IAssert(OutValV[v].Len()==OutValV[v-1].Len());
66    }
67  }
68  void TEpidemModel::RungeKutta(const TFltV& y, const TFltV& dydx, double x, double h, TFltV& SirOutV) {
69    const int n = y.Len();
70    IAssert(y.Len() == n && dydx.Len() == n);
71    TFltV dym(n), dyt(n), yt(n);
72    int i;
73    double hh=h*0.5;
74    double h6=h/6.0;
75    double xh=x+hh;
76    for (i=0; i < n; i++) {
77      yt[i]=y[i]+hh*dydx[i];
78    }
79    GetDerivs(xh, yt, dyt);
80    for (i=0; i<n; i++) {
81      yt[i]=y[i]+hh*dyt[i];
82    }
83    GetDerivs(xh,yt,dym);
84    for (i=0; i<n; i++) {
85  	  yt[i]=y[i]+h*dym[i];
86  	  dym[i] += dyt[i];
87    }
88    GetDerivs(x+h,yt,dyt);
89    SirOutV.Clr(false);  
90    for (i=0; i<n; i++) {
91      SirOutV.Add(y[i]+h6 * (dydx[i]+dyt[i]+2.0*dym[i]));
92    }
93  }
94  double TEpidemModel::GetErr(const TFltV& TrueV, const TFltV& SimV, const int& SimT0) { 
95    if (SimV.Empty() || TrueV.Empty()) { return -1.0; }
96    double Err = 0.0;
97    double S=0;
98    for (int t=0; t < TrueV.Len(); t++) {
99      if (t-SimT0 >= 0) { S = SimV[t-SimT0]; } else { S = 0; }
100      Err += TMath::Sqr(TrueV[t]-S);
101    }
102    if (Err <= 0) { Err = TFlt::Mx; }
103    return Err;
104  }
105  void TEpidemModel::Plot(const TFltV& TrueV, const TStr& Label1, const TFltV& SimV, const TStr& Label2, const TStr& OutFNm, const TStr& Desc, const TStr& XLabel, const TStr& YLabel) {
106    TGnuPlot GP(OutFNm, Desc);
107    GP.AddPlot(TrueV, gpwLinesPoints, Label1);
108    GP.AddPlot(SimV, gpwLinesPoints, Label2);
109    GP.SetXYLabel(XLabel, YLabel);
110    GP.SavePng();
111  }
112  void TEpidemModel::LoadTxt(const TStr& InFNm, const int& ColId, TFltV& ValV) {
113    ValV.Clr();
114    if (! TFile::Exists(InFNm)) { 
115      printf("*** %s not found!\n", InFNm.CStr());
116      return; 
117    }
118    TSsParser Ss(InFNm, ssfTabSep);
119    while (Ss.Next()) {
120      ValV.Add(Ss.GetFlt(ColId));
121    }
122  }
123  TSirModel::TSirModel(double NZero, TFltTr NZeroP, double IZero, TFltTr IZeroP, double _Beta, TFltTr BetaP, double _Gamma, TFltTr GammaP, int TZero, TFltTr TZeroP, TStr InFNm, int ColId) :
124   N0(NZero), I0(IZero), Beta(_Beta), Gamma(_Gamma), T0(TZero) { 
125    ParamMnMnRngV.Add(NZeroP);
126    ParamMnMnRngV.Add(IZeroP);
127    ParamMnMnRngV.Add(BetaP);
128    ParamMnMnRngV.Add(GammaP);
129    ParamMnMnRngV.Add(TZeroP);
130    TEpidemModel::LoadTxt(InFNm, ColId, TrueInfectV); 
131  }
132  void TSirModel::GetParam(TFltV& ParamV) const { 
133    ParamV.Clr(false); 
134    ParamV.Add(N0);
135    ParamV.Add(I0);
136    ParamV.Add(Beta); 
137    ParamV.Add(Gamma); 
138    ParamV.Add(T0);
139  }
140  void TSirModel::SetParam(const TFltV& ParamV) { 
141    N0 = ParamV[0];
142    I0 = ParamV[1];
143    Beta = ParamV[2]; 
144    Gamma = ParamV[3]; 
145    T0 = int(ParamV[4]); 
146  }
147  void TSirModel::SetPeakT0() {
148    double Max =0;
149    int Peak=0;
150    for (int i = 0; i < TrueInfectV.Len(); i++) {
151      if (TrueInfectV[i] > Max) { 
152        Max=TrueInfectV[i]; 
153        Peak=i;
154      }
155    }
156    T0 = int(0.9*Peak);
157    ParamMnMnRngV[4].Val1 = Peak - 0.5*abs(Peak); 
158    ParamMnMnRngV[4].Val2 = Peak + 0.5*abs(Peak); 
159    printf("Set peak T0 = %d (%g -- %g)\n", Peak, ParamMnMnRngV[4].Val1, ParamMnMnRngV[4].Val2);
160  }
161  void TSirModel::GetDerivs(const double& T, const TFltV& SirValV, TFltV& dxdyV) {
162    dxdyV[0] = -Beta*SirValV[0]*SirValV[1];
163    dxdyV[1] = Beta*SirValV[0]*SirValV[1] - Gamma*SirValV[1];
164  }
165  double TSirModel::GetErr() const { 
166    return TEpidemModel::GetErr(TrueInfectV, OutValV[1], T0);
167  }
168  double TSirModel::RunCalcErr(const TFltV& ParamV) {
169    SetParam(ParamV);
170    const int EndT = TrueInfectV.Len() - T0 + 2;
171    RunModel(TFltV::GetV(N0-I0, I0), 0, EndT, EndT, OutValV);
172    return GetErr();
173  }
174  void TSirModel::GetParamRange(TFltTrV& ParamMnMxStepV) const {
175    ParamMnMxStepV = ParamMnMnRngV; 
176  }
177  void TSirModel::GetParamNmV(TStrV& ParamNmV) const {
178    ParamNmV = TStrV::GetV("Beta", "Gamma");
179  }
180  void TSirModel::Plot(const TStr& OutFNm, TStr Desc) const {
181    if (OutValV.Empty()) { printf("EMPTY()");  return; }
182    TFltV V2;
183    for (int t=0; t < TrueInfectV.Len(); t++) {
184      if (t-T0 >= 0) { V2.Add(OutValV[1][t-T0]); } else { V2.Add(0); }
185    }
186    TEpidemModel::Plot(TrueInfectV, "TRUE", V2, "SIR model", OutFNm, Desc+" "+GetStr(), "Time", "Number of infected nodes");
187  }
188  void TSirModel::TestEurlerVsRk() {
189  }
190  TSir2Model::TSir2Model(double _N0M, TFltTr N0MP, double _I0M, TFltTr I0MP, double _N0B, TFltTr N0BP, double _I0B, TFltTr I0BP, 
191    int _T0, TFltTr T0P, double _BetaM, TFltTr BetaMP, double _GammaM, TFltTr GammaMP, double _BetaB, TFltTr BetaBP, double _GammaB, TFltTr GammaBP, 
192    double _BetaMB, TFltTr BetaMBP, double _BetaBM, TFltTr BetaBMP, TStr InFNm, int ColId1, int ColId2) : N0M(_N0M), I0M(_I0M), N0B(_N0B), I0B(_I0B), T0(_T0), BetaM(_BetaM), 
193    GammaM(_GammaM), BetaB(_BetaB), GammaB(_GammaB), BetaMB(_BetaMB), BetaBM(_BetaBM) { 
194    ParamMnMnRngV.Add(N0MP);
195    ParamMnMnRngV.Add(I0MP);
196    ParamMnMnRngV.Add(N0BP);
197    ParamMnMnRngV.Add(I0BP);
198    ParamMnMnRngV.Add(T0P);
199    ParamMnMnRngV.Add(BetaMP);
200    ParamMnMnRngV.Add(GammaMP);
201    ParamMnMnRngV.Add(BetaBP);
202    ParamMnMnRngV.Add(GammaBP);
203    ParamMnMnRngV.Add(BetaMBP);
204    ParamMnMnRngV.Add(BetaBMP);
205    if (InFNm.Len()>0 && TFile::Exists(InFNm)) {
206      TEpidemModel::LoadTxt(InFNm, ColId1, MediaV); 
207      TEpidemModel::LoadTxt(InFNm, ColId2, BlogV); 
208    }
209  }
210  void TSir2Model::GetParam(TFltV& ParamV) const { 
211    ParamV.Clr(false); 
212    ParamV.Add(N0M);
213    ParamV.Add(I0M);
214    ParamV.Add(N0B);
215    ParamV.Add(I0B);
216    ParamV.Add(T0);
217    ParamV.Add(BetaM);
218    ParamV.Add(GammaM);
219    ParamV.Add(BetaB);
220    ParamV.Add(GammaB);
221    ParamV.Add(BetaMB);
222    ParamV.Add(BetaBM);
223  }
224  void TSir2Model::SetParam(const TFltV& ParamV) { 
225    N0M = ParamV[0];
226    I0M = ParamV[1];
227    N0B = ParamV[2];
228    I0B = ParamV[3];
229    T0 = (int) ParamV[4];
230    BetaM = ParamV[5];
231    GammaM = ParamV[6];
232    BetaB = ParamV[7];
233    GammaB = ParamV[8];
234    BetaMB = ParamV[9];
235    BetaBM = ParamV[10];
236  }
237  TStr TSir2Model::GetStr() const { 
238    return TStr::Fmt("N0:%g %g  I0:%g %g  T0:%d  Beta:%g %g  Gamma:%g %g M-B:%g B-M:%g Err: %.2f", 
239      N0M, N0B, I0M, I0B, T0, BetaM, BetaB, GammaM, GammaB, BetaMB, BetaBM, GetErr()); 
240  }
241  void TSir2Model::SetPeakT0() {
242    double Max1=0, Max2=0;
243    int Peak1=0, Peak2=0;
244    for (int i = 0; i < MediaV.Len(); i++) {
245      if (MediaV[i] > Max1) { 
246        Max1 = MediaV[i]; Peak1 = i; }
247    }
248    for (int i = 0; i < BlogV.Len(); i++) {
249      if (BlogV[i] > Max2) { 
250        Max2 = BlogV[i]; Peak2 = i; }
251    }
252    int Peak = TMath::Mn(Peak1, Peak2);
253    T0 = int(0.9*Peak);
254    ParamMnMnRngV[4].Val1 = Peak - 0.5*Peak; 
255    ParamMnMnRngV[4].Val2 = TMath::Mx(Peak1, Peak2) + 0.5*TMath::Mx(Peak1, Peak2); 
256    printf("Set peak T0 = %d (%g -- %g) p1:%d p2:%d\n", 
257      Peak, ParamMnMnRngV[4].Val1, ParamMnMnRngV[4].Val2, Peak1, Peak2);
258  }
259  void TSir2Model::SetMediaBlogV(const TFltPrV& _MediaV, const TFltPrV& _BlogV) {
260    IAssert(_MediaV.Len() == _BlogV.Len());
261    MediaV.Clr(false);  BlogV.Clr(false);
262    for (int i = 0; i < _MediaV.Len(); i++) {
263      MediaV.Add(_MediaV[i].Val2);
264      BlogV.Add(_BlogV[i].Val2);
265    }
266  }
267  void TSir2Model::GetDerivs(const double& T, const TFltV& SirValV, TFltV& dxdyV) {
268    const TFlt& SM = SirValV[0];
269    const TFlt& SB = SirValV[1];
270    const TFlt& IM = SirValV[2];
271    const TFlt& IB = SirValV[3];
272    dxdyV[0] = -BetaM*IM*SM - BetaBM*IB*SM;
273    dxdyV[1] = -BetaB*IB*SB - BetaMB*IM*SB;
274    dxdyV[2] = BetaM*IM*SM + BetaBM*IB*SM - GammaM*IM;
275    dxdyV[3] = BetaB*IB*SB + BetaMB*IM*SB - GammaB*IB;
276  }
277  double TSir2Model::GetErr() const { 
278    return TEpidemModel::GetErr(MediaV, OutValV[2], T0) + TEpidemModel::GetErr(BlogV, OutValV[3], T0);
279  }
280  double TSir2Model::RunCalcErr(const TFltV& ParamV) {
281    SetParam(ParamV);
282    const int EndT = BlogV.Len() - T0 + 2;
283    RunModel(TFltV::GetV(N0M-I0M, N0B-I0B, I0M, I0B), 0, EndT, EndT, OutValV);
284    return GetErr();
285  }
286  void TSir2Model::GetParamRange(TFltTrV& ParamMnMxStepV) const {
287    ParamMnMxStepV = ParamMnMnRngV; 
288  }
289  void TSir2Model::GetParamNmV(TStrV& ParamNmV) const {
290    TStr("N0_media,I0_media,N0_blogs,I0_blogs,T0,BetaM,GammaM,BetaB,GammaB,BetaMB,BetaBM").SplitOnAllCh(',', ParamNmV);
291  }
292  void TSir2Model::Plot(const TStr& OutFNm, TStr Desc) const {
293    if (OutValV.Empty()) { printf("EMPTY()");  return; }
294    TFltV MV, BV;
295    const TFltV& SMediaV = OutValV[2];
296    for (int t=0; t < MediaV.Len(); t++) {
297      if (t-T0 >= 0) { MV.Add(SMediaV[t-T0]); } else { MV.Add(0); }
298    }
299    const TFltV& SBlogV = OutValV[3];
300    for (int t=0; t < BlogV.Len(); t++) {
301      if (t-T0 >= 0) { BV.Add(SBlogV[t-T0]); } else { BV.Add(0); }
302    }
303    TGnuPlot GP(OutFNm, Desc+" "+GetStr());
304    GP.AddPlot(MediaV, gpwLines, "TRUE MEDIA");
305    GP.AddPlot(MV, gpwLinesPoints, "SIM MEDIA");
306    GP.AddPlot(BlogV, gpwLines, "TRUE BLOGS");
307    GP.AddPlot(BV, gpwLinesPoints, "SIM BLOGS");
308    GP.SetXYLabel("Time [hours]", "Number of infected nodes");
309    GP.SavePng();
310  }
311  TSirSR2Model::TSirSR2Model(double _N0M, TFltTr N0MP, double _I0M, TFltTr I0MP, double _N0B, TFltTr N0BP, double _I0B, TFltTr I0BP, 
312   int _T0, TFltTr T0P, double _BetaM, TFltTr BetaMP, double _GammaM, TFltTr GammaMP, double _BetaB, TFltTr BetaBP, 
313   double _GammaB, TFltTr GammaBP, double _BetaMB, TFltTr BetaMBP, double _BetaBM, TFltTr BetaBMP, 
314   double _DeltaM, TFltTr DeltaMP, double _DeltaB, TFltTr DeltaBP, TStr InFNm, int ColId1, int ColId2) :  N0M(_N0M), I0M(_I0M), N0B(_N0B), 
315   I0B(_I0B), T0(_T0), BetaM(_BetaM), GammaM(_GammaM), BetaB(_BetaB), GammaB(_GammaB), BetaMB(_BetaMB), BetaBM(_BetaBM),
316   DeltaM(_DeltaM), DeltaB(DeltaB) { 
317    ParamMnMnRngV.Add(N0MP);
318    ParamMnMnRngV.Add(I0MP);
319    ParamMnMnRngV.Add(N0BP);
320    ParamMnMnRngV.Add(I0BP);
321    ParamMnMnRngV.Add(T0P);
322    ParamMnMnRngV.Add(BetaMP);
323    ParamMnMnRngV.Add(GammaMP);
324    ParamMnMnRngV.Add(BetaBP);
325    ParamMnMnRngV.Add(GammaBP);
326    ParamMnMnRngV.Add(BetaMBP);
327    ParamMnMnRngV.Add(BetaBMP);
328    ParamMnMnRngV.Add(DeltaMP);
329    ParamMnMnRngV.Add(DeltaBP);
330    if (InFNm.Len()>0 && TFile::Exists(InFNm)) {
331      TEpidemModel::LoadTxt(InFNm, ColId1, MediaV); 
332      TEpidemModel::LoadTxt(InFNm, ColId2, BlogV); 
333    }
334  }
335  void TSirSR2Model::GetParam(TFltV& ParamV) const { 
336    ParamV.Clr(false); 
337    ParamV.Add(N0M);
338    ParamV.Add(I0M);
339    ParamV.Add(N0B);
340    ParamV.Add(I0B);
341    ParamV.Add(T0);
342    ParamV.Add(BetaM);
343    ParamV.Add(GammaM);
344    ParamV.Add(BetaB);
345    ParamV.Add(GammaB);
346    ParamV.Add(BetaMB);
347    ParamV.Add(BetaBM);
348    ParamV.Add(DeltaM);
349    ParamV.Add(DeltaB);
350  }
351  void TSirSR2Model::SetParam(const TFltV& ParamV) { 
352    N0M = ParamV[0];
353    I0M = ParamV[1];
354    N0B = ParamV[2];
355    I0B = ParamV[3];
356    T0 = (int) ParamV[4];
357    BetaM = ParamV[5];
358    GammaM = ParamV[6];
359    BetaB = ParamV[7];
360    GammaB = ParamV[8];
361    BetaMB = ParamV[9];
362    BetaBM = ParamV[10];
363    DeltaM = ParamV[11];
364    DeltaB = ParamV[12];
365  }
366  TStr TSirSR2Model::GetStr() const { 
367    return TStr::Fmt("N0:%g %g  I0:%g %g  T0:%d  Beta:%g %g  Gamma:%g %g M-B:%g B-M:%g  Delta:%g %g    ERR: %.2f", 
368      N0M, N0B, I0M, I0B, T0, BetaM, BetaB, GammaM, GammaB, BetaMB, BetaBM, DeltaM, DeltaB, GetErr()); 
369  }
370  void TSirSR2Model::SetPeakT0() {
371    double Max1=0, Max2=0;
372    int Peak1=0, Peak2=0;
373    for (int i = 0; i < MediaV.Len(); i++) {
374      if (MediaV[i] > Max1) { 
375        Max1 = MediaV[i]; Peak1 = i; }
376    }
377    for (int i = 0; i < BlogV.Len(); i++) {
378      if (BlogV[i] > Max2) { 
379        Max2 = BlogV[i]; Peak2 = i; }
380    }
381    int Peak = TMath::Mn(Peak1, Peak2);
382    T0 = int(0.9*Peak);
383    ParamMnMnRngV[4].Val1 = Peak - 0.5*Peak; 
384    ParamMnMnRngV[4].Val2 = TMath::Mx(Peak1, Peak2) + 0.5*TMath::Mx(Peak1, Peak2); 
385    printf("Set peak T0 = %d (%g -- %g) p1:%d p2:%d\n", 
386      Peak, ParamMnMnRngV[4].Val1, ParamMnMnRngV[4].Val2, Peak1, Peak2);
387  }
388  void TSirSR2Model::SetMediaBlogV(const TFltPrV& _MediaV, const TFltPrV& _BlogV) {
389    IAssert(_MediaV.Len() == _BlogV.Len());
390    MediaV.Clr(false);  BlogV.Clr(false);
391    for (int i = 0; i < _MediaV.Len(); i++) {
392      MediaV.Add(_MediaV[i].Val2);
393      BlogV.Add(_BlogV[i].Val2);
394    }
395  }
396  void TSirSR2Model::GetDerivs(const double& T, const TFltV& SirValV, TFltV& dxdyV) {
397    const TFlt& SM = SirValV[0];
398    const TFlt& SB = SirValV[1];
399    const TFlt& IM = SirValV[2];
400    const TFlt& IB = SirValV[3];
401    dxdyV[0] = -BetaM*IM*SM - BetaBM*IB*SM - DeltaM*SM;
402    dxdyV[1] = -BetaB*IB*SB - BetaMB*IM*SB - DeltaB*SB;
403    dxdyV[2] = BetaM*IM*SM + BetaBM*IB*SM - GammaM*IM;
404    dxdyV[3] = BetaB*IB*SB + BetaMB*IM*SB - GammaB*IB;
405  }
406  double TSirSR2Model::GetErr() const { 
407    return TEpidemModel::GetErr(MediaV, OutValV[2], T0) + TEpidemModel::GetErr(BlogV, OutValV[3], T0);
408  }
409  double TSirSR2Model::RunCalcErr(const TFltV& ParamV) {
410    SetParam(ParamV);
411    const int EndT = BlogV.Len() - T0 + 2;
412    RunModel(TFltV::GetV(N0M-I0M, N0B-I0B, I0M, I0B), 0, EndT, EndT, OutValV);
413    return GetErr();
414  }
415  void TSirSR2Model::GetParamRange(TFltTrV& ParamMnMxStepV) const {
416    ParamMnMxStepV = ParamMnMnRngV; 
417  }
418  void TSirSR2Model::GetParamNmV(TStrV& ParamNmV) const {
419    TStr("N0_media,I0_media,N0_blogs,I0_blogs,T0,BetaM,GammaM,BetaB,GammaB,BetaMB,BetaBM,DeltaM,DeltaB").SplitOnAllCh(',', ParamNmV);
420  }
421  void TSirSR2Model::Plot(const TStr& OutFNm, TStr Desc) const {
422    if (OutValV.Empty()) { printf("EMPTY()");  return; }
423    TFltV MV, BV;
424    const TFltV& SMediaV = OutValV[2];
425    for (int t=0; t < MediaV.Len(); t++) {
426      if (t-T0 >= 0) { MV.Add(SMediaV[t-T0]); } else { MV.Add(0); }
427    }
428    const TFltV& SBlogV = OutValV[3];
429    for (int t=0; t < BlogV.Len(); t++) {
430      if (t-T0 >= 0) { BV.Add(SBlogV[t-T0]); } else { BV.Add(0); }
431    }
432    TGnuPlot GP(OutFNm, Desc+" "+GetStr());
433    GP.AddPlot(MediaV, gpwLines, "TRUE MEDIA");
434    GP.AddPlot(MV, gpwLinesPoints, "SIM MEDIA");
435    GP.AddPlot(BlogV, gpwLines, "TRUE BLOGS");
436    GP.AddPlot(BV, gpwLinesPoints, "SIM BLOGS");
437    GP.SetXYLabel("Time [hours]", "Number of infected nodes");
438    GP.SavePng();
439  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-message.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-sir.cpp</div>
                </div>
                <div class="column column_space"><pre><code>332  	const int num_blocks = 128; 
333  	for (int n = 0; n < num_blocks; ++n)
334  	{
335  		original_payload.blocks.push_back (random_block ());
336  	}
</pre></code></div>
                <div class="column column_space"><pre><code>47    const double h = (StopT-StartT) / NSteps;
48    TFltV ValV(StartValV), dydx(StartValV.Len()), ValV2(StartValV.Len());
49    for (int v = 0; v < StartValV.Len(); v++) {
50      OutValV.Add();
51      OutValV[v].Clr(false);
52      OutValV[v].Add(StartValV[v]);
53    }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    