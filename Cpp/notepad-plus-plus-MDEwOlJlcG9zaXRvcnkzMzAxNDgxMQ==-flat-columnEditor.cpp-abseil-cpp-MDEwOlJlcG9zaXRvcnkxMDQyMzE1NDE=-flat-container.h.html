
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 6.206896551724138%, Tokens: 9, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-columnEditor.cpp</h3>
            <pre><code>1  #include "columnEditor.h"
2  #include "ScintillaEditView.h"
3  void ColumnEditorDlg::init(HINSTANCE hInst, HWND hPere, ScintillaEditView **ppEditView)
4  {
5  	Window::init(hInst, hPere);
6  	if (!ppEditView)
7  		throw std::runtime_error("StaticDialog::init : ppEditView is null.");
8  	_ppEditView = ppEditView;
9  }
10  void ColumnEditorDlg::display(bool toShow) const
11  {
12      Window::display(toShow);
13      if (toShow)
14          ::SetFocus(::GetDlgItem(_hSelf, ID_GOLINE_EDIT));
15  }
16  intptr_t CALLBACK ColumnEditorDlg::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
17  {
18  	switch (message)
19  	{
20  		case WM_INITDIALOG :
21  		{
22  			ColumnEditorParam colEditParam = NppParameters::getInstance()._columnEditParam;
23  			NppDarkMode::autoSubclassAndThemeChildControls(_hSelf);
24  			::SetDlgItemText(_hSelf, IDC_COL_TEXT_EDIT, colEditParam._insertedTextContent.c_str());
25  			if (colEditParam._initialNum != -1)
26  				::SetDlgItemInt(_hSelf, IDC_COL_INITNUM_EDIT, colEditParam._initialNum, FALSE);
27  			if (colEditParam._increaseNum != -1)
28  				::SetDlgItemInt(_hSelf, IDC_COL_INCREASENUM_EDIT, colEditParam._increaseNum, FALSE);
29  			if (colEditParam._repeatNum != -1)
30  				::SetDlgItemInt(_hSelf, IDC_COL_REPEATNUM_EDIT, colEditParam._repeatNum, FALSE);
31  			::SendDlgItemMessage(_hSelf, IDC_COL_LEADING_COMBO, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("None")));
32  			::SendDlgItemMessage(_hSelf, IDC_COL_LEADING_COMBO, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("Zeros")));
33  			::SendDlgItemMessage(_hSelf, IDC_COL_LEADING_COMBO, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("Spaces")));
34  			WPARAM curSel = 0;
35  			switch (colEditParam._leadingChoice)
36  			{
37  				case ColumnEditorParam::noneLeading: { curSel = 0; break; }
38  				case ColumnEditorParam::zeroLeading : { curSel = 1; break; }
39  				case ColumnEditorParam::spaceLeading : { curSel = 2; break; }
40  				default : { curSel = 0; break; }
41  			}
42  			::SendMessage(::GetDlgItem(_hSelf, IDC_COL_LEADING_COMBO), CB_SETCURSEL, curSel, 0);
43  			int format = IDC_COL_DEC_RADIO;
44  			if (colEditParam._formatChoice == 1)
45  				format = IDC_COL_HEX_RADIO;
46  			else if (colEditParam._formatChoice == 2)
47  				format = IDC_COL_OCT_RADIO;
48  			else if (colEditParam._formatChoice == 3)
49  				format = IDC_COL_BIN_RADIO;
50  			::SendDlgItemMessage(_hSelf, format, BM_SETCHECK,  TRUE, 0);
51  			switchTo(colEditParam._mainChoice);
52  			goToCenter(SWP_SHOWWINDOW | SWP_NOSIZE);
53  			return TRUE;
54  		}
55  		case WM_CTLCOLOREDIT:
56  		{
57  			return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
58  		}
59  		case WM_CTLCOLORLISTBOX:
60  		{
61  			return NppDarkMode::onCtlColor(reinterpret_cast<HDC>(wParam));
62  		}
63  		case WM_CTLCOLORDLG:
64  		{
65  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
66  		}
67  		case WM_CTLCOLORSTATIC:
68  		{
69  			auto hdcStatic = reinterpret_cast<HDC>(wParam);
70  			auto dlgCtrlID = ::GetDlgCtrlID(reinterpret_cast<HWND>(lParam));
71  			bool isStaticText = (dlgCtrlID == IDC_COL_INITNUM_STATIC ||
72  				dlgCtrlID == IDC_COL_INCRNUM_STATIC ||
73  				dlgCtrlID == IDC_COL_REPEATNUM_STATIC ||
74  				dlgCtrlID == IDC_COL_LEADING_STATIC);
75  			if (isStaticText)
76  			{
77  				bool isTextEnabled = isCheckedOrNot(IDC_COL_NUM_RADIO);
78  				return NppDarkMode::onCtlColorDarkerBGStaticText(hdcStatic, isTextEnabled);
79  			}
80  			return NppDarkMode::onCtlColorDarker(hdcStatic);
81  		}
82  		case WM_PRINTCLIENT:
83  		{
84  			if (NppDarkMode::isEnabled())
85  			{
86  				return TRUE;
87  			}
88  			break;
89  		}
90  		case WM_ERASEBKGND:
91  		{
92  			if (NppDarkMode::isEnabled())
93  			{
94  				RECT rc{};
95  				getClientRect(rc);
96  				::FillRect(reinterpret_cast<HDC>(wParam), &rc, NppDarkMode::getDarkerBackgroundBrush());
97  				return TRUE;
98  			}
99  			break;
100  		}
101  		case NPPM_INTERNAL_REFRESHDARKMODE:
102  		{
103  			if (NppDarkMode::isEnabled())
104  			{
105  				const ColumnEditorParam& colEditParam = NppParameters::getInstance()._columnEditParam;
106  				::EnableWindow(::GetDlgItem(_hSelf, IDC_COL_FORMAT_GRP_STATIC), colEditParam._mainChoice == activeNumeric);
107  			}
108  			NppDarkMode::autoThemeChildControls(_hSelf);
109  			return TRUE;
110  		}
111  		case WM_COMMAND:
112  		{
113  			switch (wParam)
114  			{
115  				case IDCANCEL : 
116  					display(false);
117  					return TRUE;
118  				case IDOK :
119                  {
120  					(*_ppEditView)->execute(SCI_BEGINUNDOACTION);
121  					constexpr int stringSize = 1024;
122  					TCHAR str[stringSize]{};
123  					bool isTextMode = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_COL_TEXT_RADIO, BM_GETCHECK, 0, 0));
124  					if (isTextMode)
125  					{
126  						::SendDlgItemMessage(_hSelf, IDC_COL_TEXT_EDIT, WM_GETTEXT, stringSize, reinterpret_cast<LPARAM>(str));
127  						display(false);
128  						if ((*_ppEditView)->execute(SCI_SELECTIONISRECTANGLE) || (*_ppEditView)->execute(SCI_GETSELECTIONS) > 1)
129  						{
130  							ColumnModeInfos colInfos = (*_ppEditView)->getColumnModeSelectInfo();
131  							std::sort(colInfos.begin(), colInfos.end(), SortInPositionOrder());
132  							(*_ppEditView)->columnReplace(colInfos, str);
133  							std::sort(colInfos.begin(), colInfos.end(), SortInSelectOrder());
134  							(*_ppEditView)->setMultiSelections(colInfos);
135  						}
136  						else
137  						{
138  							auto cursorPos = (*_ppEditView)->execute(SCI_GETCURRENTPOS);
139  							auto cursorCol = (*_ppEditView)->execute(SCI_GETCOLUMN, cursorPos);
140  							auto cursorLine = (*_ppEditView)->execute(SCI_LINEFROMPOSITION, cursorPos);
141  							auto endPos = (*_ppEditView)->execute(SCI_GETLENGTH);
142  							auto endLine = (*_ppEditView)->execute(SCI_LINEFROMPOSITION, endPos);
143  							constexpr int lineAllocatedLen = 1024;
144  							TCHAR *line = new TCHAR[lineAllocatedLen];
145  							for (size_t i = cursorLine ; i <= static_cast<size_t>(endLine); ++i)
<span onclick='openModal()' class='match'>146  							{
147  								auto lineBegin = (*_ppEditView)->execute(SCI_POSITIONFROMLINE, i);
148  								auto lineEnd = (*_ppEditView)->execute(SCI_GETLINEENDPOSITION, i);
149  								auto lineEndCol = (*_ppEditView)->execute(SCI_GETCOLUMN, lineEnd);
150  								auto lineLen = lineEnd - lineBegin + 1;
</span>151  								if (lineLen > lineAllocatedLen)
152  								{
153  									delete [] line;
154  									line = new TCHAR[lineLen];
155  								}
156  								(*_ppEditView)->getGenericText(line, lineLen, lineBegin, lineEnd);
157  								generic_string s2r(line);
158  								if (lineEndCol < cursorCol)
159  								{
160  									generic_string s_space(cursorCol - lineEndCol, ' ');
161  									s2r.append(s_space);
162  									s2r.append(str);
163  								}
164  								else
165  								{
166  									auto posAbs2Start = (*_ppEditView)->execute(SCI_FINDCOLUMN, i, cursorCol);
167  									auto posRelative2Start = posAbs2Start - lineBegin;
168  									if (posRelative2Start > static_cast<long long>(s2r.length()))
169  										posRelative2Start = s2r.length();
170  									s2r.insert(posRelative2Start, str);
171  								}
172  								(*_ppEditView)->replaceTarget(s2r.c_str(), lineBegin, lineEnd);
173  							}
174  							delete [] line;
175  						}
176  					}
177  					else
178  					{
179  						int initialNumber = ::GetDlgItemInt(_hSelf, IDC_COL_INITNUM_EDIT, NULL, TRUE);
180  						int increaseNumber = ::GetDlgItemInt(_hSelf, IDC_COL_INCREASENUM_EDIT, NULL, TRUE);
181  						int repeat = ::GetDlgItemInt(_hSelf, IDC_COL_REPEATNUM_EDIT, NULL, TRUE);
182  						if (repeat == 0)
183  						{
184  							repeat = 1; 
185  						}
186  						UCHAR format = getFormat();
187  						display(false);
188  						if ((*_ppEditView)->execute(SCI_SELECTIONISRECTANGLE) || (*_ppEditView)->execute(SCI_GETSELECTIONS) > 1)
189  						{
190  							ColumnModeInfos colInfos = (*_ppEditView)->getColumnModeSelectInfo();
191  							if (colInfos.size() > 0)
192  							{
193  								std::sort(colInfos.begin(), colInfos.end(), SortInPositionOrder());
194  								(*_ppEditView)->columnReplace(colInfos, initialNumber, increaseNumber, repeat, format, getLeading());
195  								std::sort(colInfos.begin(), colInfos.end(), SortInSelectOrder());
196  								(*_ppEditView)->setMultiSelections(colInfos);
197  							}
198  						}
199  						else
200  						{
201  							auto cursorPos = (*_ppEditView)->execute(SCI_GETCURRENTPOS);
202  							auto cursorCol = (*_ppEditView)->execute(SCI_GETCOLUMN, cursorPos);
203  							auto cursorLine = (*_ppEditView)->execute(SCI_LINEFROMPOSITION, cursorPos);
204  							auto endPos = (*_ppEditView)->execute(SCI_GETLENGTH);
205  							auto endLine = (*_ppEditView)->execute(SCI_LINEFROMPOSITION, endPos);
206  							std::vector<int> numbers;
207  							{
208  								int curNumber = initialNumber;
209  								const size_t kiMaxSize = 1 + (size_t)endLine - (size_t)cursorLine;
210  								while (numbers.size() < kiMaxSize)
211  								{
212  									for (int i = 0; i < repeat; i++)
213  									{
214  										numbers.push_back(curNumber);
215  										if (numbers.size() >= kiMaxSize)
216  										{
217  											break;
218  										}
219  									}
220  									curNumber += increaseNumber;
221  								}
222  							}
223  							assert(numbers.size() > 0);
224  							constexpr int lineAllocatedLen = 1024;
225  							TCHAR *line = new TCHAR[lineAllocatedLen];
226  							UCHAR f = format & MASK_FORMAT;
227  							int base = 10;
228  							if (f == BASE_16)
229  								base = 16;
230  							else if (f == BASE_08)
231  								base = 8;
232  							else if (f == BASE_02)
233  								base = 2;
234  							int endNumber = *numbers.rbegin();
235  							int nbEnd = getNbDigits(endNumber, base);
236  							int nbInit = getNbDigits(initialNumber, base);
237  							int nb = std::max<int>(nbInit, nbEnd);
238  							for (size_t i = cursorLine ; i <= size_t(endLine) ; ++i)
239  							{
240  								auto lineBegin = (*_ppEditView)->execute(SCI_POSITIONFROMLINE, i);
241  								auto lineEnd = (*_ppEditView)->execute(SCI_GETLINEENDPOSITION, i);
242  								auto lineEndCol = (*_ppEditView)->execute(SCI_GETCOLUMN, lineEnd);
243  								auto lineLen = lineEnd - lineBegin + 1;
244  								if (lineLen > lineAllocatedLen)
245  								{
246  									delete [] line;
247  									line = new TCHAR[lineLen];
248  								}
249  								(*_ppEditView)->getGenericText(line, lineLen, lineBegin, lineEnd);
250  								generic_string s2r(line);
251  								int2str(str, stringSize, numbers.at(i - cursorLine), base, nb, getLeading());
252  								if (lineEndCol < cursorCol)
253  								{
254  									generic_string s_space(cursorCol - lineEndCol, ' ');
255  									s2r.append(s_space);
256  									s2r.append(str);
257  								}
258  								else
259  								{
260  									auto posAbs2Start = (*_ppEditView)->execute(SCI_FINDCOLUMN, i, cursorCol);
261  									auto posRelative2Start = posAbs2Start - lineBegin;
262  									if (posRelative2Start > static_cast<long long>(s2r.length()))
263  										posRelative2Start = s2r.length();
264  									s2r.insert(posRelative2Start, str);
265  								}
266  								(*_ppEditView)->replaceTarget(s2r.c_str(), int(lineBegin), int(lineEnd));
267  							}
268  							delete [] line;
269  						}
270  					}
271  					(*_ppEditView)->execute(SCI_ENDUNDOACTION);
272                      (*_ppEditView)->getFocus();
273                      return TRUE;
274                  }
275  				case IDC_COL_TEXT_RADIO :
276  				case IDC_COL_NUM_RADIO :
277  				{
278  					ColumnEditorParam& colEditParam = NppParameters::getInstance()._columnEditParam;
279  					colEditParam._mainChoice = (wParam == IDC_COL_TEXT_RADIO) ? activeText : activeNumeric;
280  					switchTo(colEditParam._mainChoice);
281  					return TRUE;
282  				}
283  				case IDC_COL_DEC_RADIO:
284  				case IDC_COL_OCT_RADIO:
285  				case IDC_COL_HEX_RADIO:
286  				case IDC_COL_BIN_RADIO:
287  				{
288  					ColumnEditorParam& colEditParam = NppParameters::getInstance()._columnEditParam;
289  					colEditParam._formatChoice = 0; 
290  					if (wParam == IDC_COL_HEX_RADIO)
291  						colEditParam._formatChoice = 1;
292  					else if (wParam == IDC_COL_OCT_RADIO)
293  						colEditParam._formatChoice = 2;
294  					else if (wParam == IDC_COL_BIN_RADIO)
295  						colEditParam._formatChoice = 3;
296  					return TRUE;
297  				}
298  				default :
299  				{
300  					switch (HIWORD(wParam))
301  					{
302  						case EN_CHANGE:
303  						{
304  							ColumnEditorParam& colEditParam = NppParameters::getInstance()._columnEditParam;
305  							constexpr int stringSize = MAX_PATH;
306  							TCHAR str[stringSize]{};
307  							switch (LOWORD(wParam))
308  							{
309  								case IDC_COL_TEXT_EDIT:
310  								{
311  									::GetDlgItemText(_hSelf, LOWORD(wParam), str, stringSize);
312  									colEditParam._insertedTextContent = str;
313  									::EnableWindow(::GetDlgItem(_hSelf, IDOK), str[0]);
314  									return TRUE;
315  								}
316  								case IDC_COL_INITNUM_EDIT:
317  								{
318  									::GetDlgItemText(_hSelf, LOWORD(wParam), str, stringSize);
319  									if (lstrcmp(str, TEXT("")) == 0)
320  									{
321  										colEditParam._initialNum = -1;
322  										return TRUE;
323  									}
324  									int num = ::GetDlgItemInt(_hSelf, LOWORD(wParam), NULL, TRUE);
325  									colEditParam._initialNum = num;
326  									return TRUE;
327  								}
328  								case IDC_COL_INCREASENUM_EDIT:
329  								{
330  									::GetDlgItemText(_hSelf, LOWORD(wParam), str, stringSize);
331  									if (lstrcmp(str, TEXT("")) == 0)
332  									{
333  										colEditParam._increaseNum = -1;
334  										return TRUE;
335  									}
336  									int num = ::GetDlgItemInt(_hSelf, LOWORD(wParam), NULL, TRUE);
337  									colEditParam._increaseNum = num;
338  									return TRUE;
339  								}
340  								case IDC_COL_REPEATNUM_EDIT:
341  								{
342  									::GetDlgItemText(_hSelf, LOWORD(wParam), str, stringSize);
343  									if (lstrcmp(str, TEXT("")) == 0)
344  									{
345  										colEditParam._repeatNum = -1;
346  										return TRUE;
347  									}
348  									int num = ::GetDlgItemInt(_hSelf, LOWORD(wParam), NULL, TRUE);
349  									colEditParam._repeatNum = num;
350  									return TRUE;
351  								}
352  							}
353  						}
354  						break;
355  						case CBN_SELCHANGE:
356  						{
357  							if (LOWORD(wParam) == IDC_COL_LEADING_COMBO)
358  							{
359  								ColumnEditorParam& colEditParam = NppParameters::getInstance()._columnEditParam;
360  								colEditParam._leadingChoice = getLeading();
361  								return TRUE;
362  							}
363  						}
364  						break;
365  					}
366  					break;
367  				}
368  			}
369  			break;
370  		}
371  		default :
372  			return FALSE;
373  	}
374  	return FALSE;
375  }
376  void ColumnEditorDlg::switchTo(bool toText)
377  {
378  	HWND hText = ::GetDlgItem(_hSelf, IDC_COL_TEXT_EDIT);
379  	::EnableWindow(hText, toText);
380  	::SendDlgItemMessage(_hSelf, IDC_COL_TEXT_RADIO, BM_SETCHECK, toText, 0);
381  	HWND hNum = ::GetDlgItem(_hSelf, IDC_COL_INITNUM_EDIT);
382  	::SendDlgItemMessage(_hSelf, IDC_COL_NUM_RADIO, BM_SETCHECK, !toText, 0);
383  	::EnableWindow(hNum, !toText);
384  	::EnableWindow(::GetDlgItem(_hSelf, IDC_COL_INCREASENUM_EDIT), !toText);
385  	::EnableWindow(::GetDlgItem(_hSelf, IDC_COL_REPEATNUM_EDIT), !toText);
386  	::EnableWindow(::GetDlgItem(_hSelf, IDC_COL_DEC_RADIO), !toText);
387  	::EnableWindow(::GetDlgItem(_hSelf, IDC_COL_HEX_RADIO), !toText);
388  	::EnableWindow(::GetDlgItem(_hSelf, IDC_COL_OCT_RADIO), !toText);
389  	::EnableWindow(::GetDlgItem(_hSelf, IDC_COL_BIN_RADIO), !toText);
390  	::EnableWindow(::GetDlgItem(_hSelf, IDC_COL_LEADING_COMBO), !toText);
391  	::EnableWindow(::GetDlgItem(_hSelf, IDOK), !toText || !NppParameters::getInstance()._columnEditParam._insertedTextContent.empty());
392  	::SetFocus(toText?hText:hNum);
393  	redrawDlgItem(IDC_COL_INITNUM_STATIC);
394  	redrawDlgItem(IDC_COL_INCRNUM_STATIC);
395  	redrawDlgItem(IDC_COL_REPEATNUM_STATIC);
396  	redrawDlgItem(IDC_COL_LEADING_STATIC);
397  	if (NppDarkMode::isEnabled())
398  	{
399  		::EnableWindow(::GetDlgItem(_hSelf, IDC_COL_FORMAT_GRP_STATIC), !toText);
400  		redrawDlgItem(IDC_COL_FORMAT_GRP_STATIC);
401  	}
402  }
403  UCHAR ColumnEditorDlg::getFormat()
404  {
405  	UCHAR f = 0; 
406  	if (isCheckedOrNot(IDC_COL_HEX_RADIO))
407  		f = 1;
408  	else if (isCheckedOrNot(IDC_COL_OCT_RADIO))
409  		f = 2;
410  	else if (isCheckedOrNot(IDC_COL_BIN_RADIO))
411  		f = 3;
412  	return f;
413  }
414  ColumnEditorParam::leadingChoice ColumnEditorDlg::getLeading()
415  {
416  	ColumnEditorParam::leadingChoice leading = ColumnEditorParam::noneLeading;
417  	int curSel = static_cast<int>(::SendDlgItemMessage(_hSelf, IDC_COL_LEADING_COMBO, CB_GETCURSEL, 0, 0));
418  	switch (curSel)
419  	{
420  		case 0:
421  		default:
422  		{
423  			leading = ColumnEditorParam::noneLeading;
424  			break;
425  		}
426  		case 1:
427  		{
428  			leading = ColumnEditorParam::zeroLeading;
429  			break;
430  		}
431  		case 2:
432  		{
433  			leading = ColumnEditorParam::spaceLeading;
434  			break;
435  		}
436  	}
437  	return leading;
438  }
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-container.h</h3>
            <pre><code>1  #ifndef ABSL_ALGORITHM_CONTAINER_H_
2  #define ABSL_ALGORITHM_CONTAINER_H_
3  #include <algorithm>
4  #include <cassert>
5  #include <iterator>
6  #include <numeric>
7  #include <type_traits>
8  #include <unordered_map>
9  #include <unordered_set>
10  #include <utility>
11  #include <vector>
12  #include "absl/algorithm/algorithm.h"
13  #include "absl/base/macros.h"
14  #include "absl/meta/type_traits.h"
15  namespace absl {
16  ABSL_NAMESPACE_BEGIN
17  namespace container_algorithm_internal {
18  using std::begin;
19  using std::end;
20  template <typename C>
21  using ContainerIter = decltype(begin(std::declval<C&>()));
22  template <typename C1, typename C2>
23  using ContainerIterPairType =
24      decltype(std::make_pair(ContainerIter<C1>(), ContainerIter<C2>()));
25  template <typename C>
26  using ContainerDifferenceType = decltype(std::distance(
27      std::declval<ContainerIter<C>>(), std::declval<ContainerIter<C>>()));
28  template <typename C>
29  using ContainerPointerType =
30      typename std::iterator_traits<ContainerIter<C>>::pointer;
31  template <typename C>
32  ContainerIter<C> c_begin(C& c) {
33    return begin(c);
34  }
35  template <typename C>
36  ContainerIter<C> c_end(C& c) {
37    return end(c);
38  }
39  template <typename T>
40  struct IsUnorderedContainer : std::false_type {};
41  template <class Key, class T, class Hash, class KeyEqual, class Allocator>
42  struct IsUnorderedContainer<
43      std::unordered_map<Key, T, Hash, KeyEqual, Allocator>> : std::true_type {};
44  template <class Key, class Hash, class KeyEqual, class Allocator>
45  struct IsUnorderedContainer<std::unordered_set<Key, Hash, KeyEqual, Allocator>>
46      : std::true_type {};
47  template <class C>
48  auto c_size(C& c) -> decltype(c.size()) {
49    return c.size();
50  }
51  template <class T, std::size_t N>
52  constexpr std::size_t c_size(T (&)[N]) {
53    return N;
54  }
55  }  
56  template <typename C, typename EqualityComparable>
57  bool c_linear_search(const C& c, EqualityComparable&& value) {
58    return linear_search(container_algorithm_internal::c_begin(c),
59                         container_algorithm_internal::c_end(c),
60                         std::forward<EqualityComparable>(value));
61  }
62  template <typename C>
63  container_algorithm_internal::ContainerDifferenceType<const C> c_distance(
64      const C& c) {
65    return std::distance(container_algorithm_internal::c_begin(c),
66                         container_algorithm_internal::c_end(c));
67  }
68  template <typename C, typename Pred>
69  bool c_all_of(const C& c, Pred&& pred) {
70    return std::all_of(container_algorithm_internal::c_begin(c),
71                       container_algorithm_internal::c_end(c),
72                       std::forward<Pred>(pred));
73  }
74  template <typename C, typename Pred>
75  bool c_any_of(const C& c, Pred&& pred) {
76    return std::any_of(container_algorithm_internal::c_begin(c),
77                       container_algorithm_internal::c_end(c),
78                       std::forward<Pred>(pred));
79  }
80  template <typename C, typename Pred>
81  bool c_none_of(const C& c, Pred&& pred) {
82    return std::none_of(container_algorithm_internal::c_begin(c),
83                        container_algorithm_internal::c_end(c),
84                        std::forward<Pred>(pred));
85  }
86  template <typename C, typename Function>
87  decay_t<Function> c_for_each(C&& c, Function&& f) {
88    return std::for_each(container_algorithm_internal::c_begin(c),
89                         container_algorithm_internal::c_end(c),
90                         std::forward<Function>(f));
91  }
92  template <typename C, typename T>
93  container_algorithm_internal::ContainerIter<C> c_find(C& c, T&& value) {
94    return std::find(container_algorithm_internal::c_begin(c),
95                     container_algorithm_internal::c_end(c),
96                     std::forward<T>(value));
97  }
98  template <typename C, typename Pred>
99  container_algorithm_internal::ContainerIter<C> c_find_if(C& c, Pred&& pred) {
100    return std::find_if(container_algorithm_internal::c_begin(c),
101                        container_algorithm_internal::c_end(c),
102                        std::forward<Pred>(pred));
103  }
104  template <typename C, typename Pred>
105  container_algorithm_internal::ContainerIter<C> c_find_if_not(C& c,
106                                                               Pred&& pred) {
107    return std::find_if_not(container_algorithm_internal::c_begin(c),
108                            container_algorithm_internal::c_end(c),
109                            std::forward<Pred>(pred));
110  }
111  template <typename Sequence1, typename Sequence2>
112  container_algorithm_internal::ContainerIter<Sequence1> c_find_end(
113      Sequence1& sequence, Sequence2& subsequence) {
114    return std::find_end(container_algorithm_internal::c_begin(sequence),
115                         container_algorithm_internal::c_end(sequence),
116                         container_algorithm_internal::c_begin(subsequence),
117                         container_algorithm_internal::c_end(subsequence));
118  }
119  template <typename Sequence1, typename Sequence2, typename BinaryPredicate>
120  container_algorithm_internal::ContainerIter<Sequence1> c_find_end(
121      Sequence1& sequence, Sequence2& subsequence, BinaryPredicate&& pred) {
122    return std::find_end(container_algorithm_internal::c_begin(sequence),
123                         container_algorithm_internal::c_end(sequence),
124                         container_algorithm_internal::c_begin(subsequence),
125                         container_algorithm_internal::c_end(subsequence),
126                         std::forward<BinaryPredicate>(pred));
127  }
128  template <typename C1, typename C2>
129  container_algorithm_internal::ContainerIter<C1> c_find_first_of(C1& container,
130                                                                  C2& options) {
131    return std::find_first_of(container_algorithm_internal::c_begin(container),
132                              container_algorithm_internal::c_end(container),
133                              container_algorithm_internal::c_begin(options),
134                              container_algorithm_internal::c_end(options));
135  }
136  template <typename C1, typename C2, typename BinaryPredicate>
137  container_algorithm_internal::ContainerIter<C1> c_find_first_of(
138      C1& container, C2& options, BinaryPredicate&& pred) {
139    return std::find_first_of(container_algorithm_internal::c_begin(container),
140                              container_algorithm_internal::c_end(container),
141                              container_algorithm_internal::c_begin(options),
142                              container_algorithm_internal::c_end(options),
143                              std::forward<BinaryPredicate>(pred));
144  }
145  template <typename Sequence>
146  container_algorithm_internal::ContainerIter<Sequence> c_adjacent_find(
147      Sequence& sequence) {
148    return std::adjacent_find(container_algorithm_internal::c_begin(sequence),
149                              container_algorithm_internal::c_end(sequence));
150  }
151  template <typename Sequence, typename BinaryPredicate>
152  container_algorithm_internal::ContainerIter<Sequence> c_adjacent_find(
153      Sequence& sequence, BinaryPredicate&& pred) {
154    return std::adjacent_find(container_algorithm_internal::c_begin(sequence),
155                              container_algorithm_internal::c_end(sequence),
156                              std::forward<BinaryPredicate>(pred));
157  }
158  template <typename C, typename T>
159  container_algorithm_internal::ContainerDifferenceType<const C> c_count(
160      const C& c, T&& value) {
161    return std::count(container_algorithm_internal::c_begin(c),
162                      container_algorithm_internal::c_end(c),
163                      std::forward<T>(value));
164  }
165  template <typename C, typename Pred>
166  container_algorithm_internal::ContainerDifferenceType<const C> c_count_if(
167      const C& c, Pred&& pred) {
168    return std::count_if(container_algorithm_internal::c_begin(c),
169                         container_algorithm_internal::c_end(c),
170                         std::forward<Pred>(pred));
171  }
172  template <typename C1, typename C2>
173  container_algorithm_internal::ContainerIterPairType<C1, C2> c_mismatch(C1& c1,
174                                                                         C2& c2) {
175    auto first1 = container_algorithm_internal::c_begin(c1);
176    auto last1 = container_algorithm_internal::c_end(c1);
177    auto first2 = container_algorithm_internal::c_begin(c2);
178    auto last2 = container_algorithm_internal::c_end(c2);
179    for (; first1 != last1 && first2 != last2; ++first1, (void)++first2) {
180      if (!(*first1 == *first2)) {
181        break;
182      }
183    }
184    return std::make_pair(first1, first2);
185  }
186  template <typename C1, typename C2, typename BinaryPredicate>
187  container_algorithm_internal::ContainerIterPairType<C1, C2> c_mismatch(
<span onclick='openModal()' class='match'>188      C1& c1, C2& c2, BinaryPredicate pred) {
189    auto first1 = container_algorithm_internal::c_begin(c1);
190    auto last1 = container_algorithm_internal::c_end(c1);
191    auto first2 = container_algorithm_internal::c_begin(c2);
192    auto last2 = container_algorithm_internal::c_end(c2);
</span>193    for (; first1 != last1 && first2 != last2; ++first1, (void)++first2) {
194      if (!pred(*first1, *first2)) {
195        break;
196      }
197    }
198    return std::make_pair(first1, first2);
199  }
200  template <typename C1, typename C2>
201  bool c_equal(const C1& c1, const C2& c2) {
202    return ((container_algorithm_internal::c_size(c1) ==
203             container_algorithm_internal::c_size(c2)) &&
204            std::equal(container_algorithm_internal::c_begin(c1),
205                       container_algorithm_internal::c_end(c1),
206                       container_algorithm_internal::c_begin(c2)));
207  }
208  template <typename C1, typename C2, typename BinaryPredicate>
209  bool c_equal(const C1& c1, const C2& c2, BinaryPredicate&& pred) {
210    return ((container_algorithm_internal::c_size(c1) ==
211             container_algorithm_internal::c_size(c2)) &&
212            std::equal(container_algorithm_internal::c_begin(c1),
213                       container_algorithm_internal::c_end(c1),
214                       container_algorithm_internal::c_begin(c2),
215                       std::forward<BinaryPredicate>(pred)));
216  }
217  template <typename C1, typename C2>
218  bool c_is_permutation(const C1& c1, const C2& c2) {
219    using std::begin;
220    using std::end;
221    return c1.size() == c2.size() &&
222           std::is_permutation(begin(c1), end(c1), begin(c2));
223  }
224  template <typename C1, typename C2, typename BinaryPredicate>
225  bool c_is_permutation(const C1& c1, const C2& c2, BinaryPredicate&& pred) {
226    using std::begin;
227    using std::end;
228    return c1.size() == c2.size() &&
229           std::is_permutation(begin(c1), end(c1), begin(c2),
230                               std::forward<BinaryPredicate>(pred));
231  }
232  template <typename Sequence1, typename Sequence2>
233  container_algorithm_internal::ContainerIter<Sequence1> c_search(
234      Sequence1& sequence, Sequence2& subsequence) {
235    return std::search(container_algorithm_internal::c_begin(sequence),
236                       container_algorithm_internal::c_end(sequence),
237                       container_algorithm_internal::c_begin(subsequence),
238                       container_algorithm_internal::c_end(subsequence));
239  }
240  template <typename Sequence1, typename Sequence2, typename BinaryPredicate>
241  container_algorithm_internal::ContainerIter<Sequence1> c_search(
242      Sequence1& sequence, Sequence2& subsequence, BinaryPredicate&& pred) {
243    return std::search(container_algorithm_internal::c_begin(sequence),
244                       container_algorithm_internal::c_end(sequence),
245                       container_algorithm_internal::c_begin(subsequence),
246                       container_algorithm_internal::c_end(subsequence),
247                       std::forward<BinaryPredicate>(pred));
248  }
249  template <typename Sequence, typename Size, typename T>
250  container_algorithm_internal::ContainerIter<Sequence> c_search_n(
251      Sequence& sequence, Size count, T&& value) {
252    return std::search_n(container_algorithm_internal::c_begin(sequence),
253                         container_algorithm_internal::c_end(sequence), count,
254                         std::forward<T>(value));
255  }
256  template <typename Sequence, typename Size, typename T,
257            typename BinaryPredicate>
258  container_algorithm_internal::ContainerIter<Sequence> c_search_n(
259      Sequence& sequence, Size count, T&& value, BinaryPredicate&& pred) {
260    return std::search_n(container_algorithm_internal::c_begin(sequence),
261                         container_algorithm_internal::c_end(sequence), count,
262                         std::forward<T>(value),
263                         std::forward<BinaryPredicate>(pred));
264  }
265  template <typename InputSequence, typename OutputIterator>
266  OutputIterator c_copy(const InputSequence& input, OutputIterator output) {
267    return std::copy(container_algorithm_internal::c_begin(input),
268                     container_algorithm_internal::c_end(input), output);
269  }
270  template <typename C, typename Size, typename OutputIterator>
271  OutputIterator c_copy_n(const C& input, Size n, OutputIterator output) {
272    return std::copy_n(container_algorithm_internal::c_begin(input), n, output);
273  }
274  template <typename InputSequence, typename OutputIterator, typename Pred>
275  OutputIterator c_copy_if(const InputSequence& input, OutputIterator output,
276                           Pred&& pred) {
277    return std::copy_if(container_algorithm_internal::c_begin(input),
278                        container_algorithm_internal::c_end(input), output,
279                        std::forward<Pred>(pred));
280  }
281  template <typename C, typename BidirectionalIterator>
282  BidirectionalIterator c_copy_backward(const C& src,
283                                        BidirectionalIterator dest) {
284    return std::copy_backward(container_algorithm_internal::c_begin(src),
285                              container_algorithm_internal::c_end(src), dest);
286  }
287  template <typename C, typename OutputIterator>
288  OutputIterator c_move(C&& src, OutputIterator dest) {
289    return std::move(container_algorithm_internal::c_begin(src),
290                     container_algorithm_internal::c_end(src), dest);
291  }
292  template <typename C, typename BidirectionalIterator>
293  BidirectionalIterator c_move_backward(C&& src, BidirectionalIterator dest) {
294    return std::move_backward(container_algorithm_internal::c_begin(src),
295                              container_algorithm_internal::c_end(src), dest);
296  }
297  template <typename C1, typename C2>
298  container_algorithm_internal::ContainerIter<C2> c_swap_ranges(C1& c1, C2& c2) {
299    auto first1 = container_algorithm_internal::c_begin(c1);
300    auto last1 = container_algorithm_internal::c_end(c1);
301    auto first2 = container_algorithm_internal::c_begin(c2);
302    auto last2 = container_algorithm_internal::c_end(c2);
303    using std::swap;
304    for (; first1 != last1 && first2 != last2; ++first1, (void)++first2) {
305      swap(*first1, *first2);
306    }
307    return first2;
308  }
309  template <typename InputSequence, typename OutputIterator, typename UnaryOp>
310  OutputIterator c_transform(const InputSequence& input, OutputIterator output,
311                             UnaryOp&& unary_op) {
312    return std::transform(container_algorithm_internal::c_begin(input),
313                          container_algorithm_internal::c_end(input), output,
314                          std::forward<UnaryOp>(unary_op));
315  }
316  template <typename InputSequence1, typename InputSequence2,
317            typename OutputIterator, typename BinaryOp>
318  OutputIterator c_transform(const InputSequence1& input1,
319                             const InputSequence2& input2, OutputIterator output,
320                             BinaryOp&& binary_op) {
321    auto first1 = container_algorithm_internal::c_begin(input1);
322    auto last1 = container_algorithm_internal::c_end(input1);
323    auto first2 = container_algorithm_internal::c_begin(input2);
324    auto last2 = container_algorithm_internal::c_end(input2);
325    for (; first1 != last1 && first2 != last2;
326         ++first1, (void)++first2, ++output) {
327      *output = binary_op(*first1, *first2);
328    }
329    return output;
330  }
331  template <typename Sequence, typename T>
332  void c_replace(Sequence& sequence, const T& old_value, const T& new_value) {
333    std::replace(container_algorithm_internal::c_begin(sequence),
334                 container_algorithm_internal::c_end(sequence), old_value,
335                 new_value);
336  }
337  template <typename C, typename Pred, typename T>
338  void c_replace_if(C& c, Pred&& pred, T&& new_value) {
339    std::replace_if(container_algorithm_internal::c_begin(c),
340                    container_algorithm_internal::c_end(c),
341                    std::forward<Pred>(pred), std::forward<T>(new_value));
342  }
343  template <typename C, typename OutputIterator, typename T>
344  OutputIterator c_replace_copy(const C& c, OutputIterator result, T&& old_value,
345                                T&& new_value) {
346    return std::replace_copy(container_algorithm_internal::c_begin(c),
347                             container_algorithm_internal::c_end(c), result,
348                             std::forward<T>(old_value),
349                             std::forward<T>(new_value));
350  }
351  template <typename C, typename OutputIterator, typename Pred, typename T>
352  OutputIterator c_replace_copy_if(const C& c, OutputIterator result, Pred&& pred,
353                                   const T& new_value) {
354    return std::replace_copy_if(container_algorithm_internal::c_begin(c),
355                                container_algorithm_internal::c_end(c), result,
356                                std::forward<Pred>(pred), new_value);
357  }
358  template <typename C, typename T>
359  void c_fill(C& c, const T& value) {
360    std::fill(container_algorithm_internal::c_begin(c),
361              container_algorithm_internal::c_end(c), value);
362  }
363  template <typename C, typename Size, typename T>
364  void c_fill_n(C& c, Size n, const T& value) {
365    std::fill_n(container_algorithm_internal::c_begin(c), n, value);
366  }
367  template <typename C, typename Generator>
368  void c_generate(C& c, Generator&& gen) {
369    std::generate(container_algorithm_internal::c_begin(c),
370                  container_algorithm_internal::c_end(c),
371                  std::forward<Generator>(gen));
372  }
373  template <typename C, typename Size, typename Generator>
374  container_algorithm_internal::ContainerIter<C> c_generate_n(C& c, Size n,
375                                                              Generator&& gen) {
376    return std::generate_n(container_algorithm_internal::c_begin(c), n,
377                           std::forward<Generator>(gen));
378  }
379  template <typename C, typename OutputIterator, typename T>
380  OutputIterator c_remove_copy(const C& c, OutputIterator result,
381                               const T& value) {
382    return std::remove_copy(container_algorithm_internal::c_begin(c),
383                            container_algorithm_internal::c_end(c), result,
384                            value);
385  }
386  template <typename C, typename OutputIterator, typename Pred>
387  OutputIterator c_remove_copy_if(const C& c, OutputIterator result,
388                                  Pred&& pred) {
389    return std::remove_copy_if(container_algorithm_internal::c_begin(c),
390                               container_algorithm_internal::c_end(c), result,
391                               std::forward<Pred>(pred));
392  }
393  template <typename C, typename OutputIterator>
394  OutputIterator c_unique_copy(const C& c, OutputIterator result) {
395    return std::unique_copy(container_algorithm_internal::c_begin(c),
396                            container_algorithm_internal::c_end(c), result);
397  }
398  template <typename C, typename OutputIterator, typename BinaryPredicate>
399  OutputIterator c_unique_copy(const C& c, OutputIterator result,
400                               BinaryPredicate&& pred) {
401    return std::unique_copy(container_algorithm_internal::c_begin(c),
402                            container_algorithm_internal::c_end(c), result,
403                            std::forward<BinaryPredicate>(pred));
404  }
405  template <typename Sequence>
406  void c_reverse(Sequence& sequence) {
407    std::reverse(container_algorithm_internal::c_begin(sequence),
408                 container_algorithm_internal::c_end(sequence));
409  }
410  template <typename C, typename OutputIterator>
411  OutputIterator c_reverse_copy(const C& sequence, OutputIterator result) {
412    return std::reverse_copy(container_algorithm_internal::c_begin(sequence),
413                             container_algorithm_internal::c_end(sequence),
414                             result);
415  }
416  template <typename C,
417            typename Iterator = container_algorithm_internal::ContainerIter<C>>
418  Iterator c_rotate(C& sequence, Iterator middle) {
419    return absl::rotate(container_algorithm_internal::c_begin(sequence), middle,
420                        container_algorithm_internal::c_end(sequence));
421  }
422  template <typename C, typename OutputIterator>
423  OutputIterator c_rotate_copy(
424      const C& sequence,
425      container_algorithm_internal::ContainerIter<const C> middle,
426      OutputIterator result) {
427    return std::rotate_copy(container_algorithm_internal::c_begin(sequence),
428                            middle, container_algorithm_internal::c_end(sequence),
429                            result);
430  }
431  template <typename RandomAccessContainer, typename UniformRandomBitGenerator>
432  void c_shuffle(RandomAccessContainer& c, UniformRandomBitGenerator&& gen) {
433    std::shuffle(container_algorithm_internal::c_begin(c),
434                 container_algorithm_internal::c_end(c),
435                 std::forward<UniformRandomBitGenerator>(gen));
436  }
437  template <typename C, typename Pred>
438  bool c_is_partitioned(const C& c, Pred&& pred) {
439    return std::is_partitioned(container_algorithm_internal::c_begin(c),
440                               container_algorithm_internal::c_end(c),
441                               std::forward<Pred>(pred));
442  }
443  template <typename C, typename Pred>
444  container_algorithm_internal::ContainerIter<C> c_partition(C& c, Pred&& pred) {
445    return std::partition(container_algorithm_internal::c_begin(c),
446                          container_algorithm_internal::c_end(c),
447                          std::forward<Pred>(pred));
448  }
449  template <typename C, typename Pred>
450  container_algorithm_internal::ContainerIter<C> c_stable_partition(C& c,
451                                                                    Pred&& pred) {
452    return std::stable_partition(container_algorithm_internal::c_begin(c),
453                                 container_algorithm_internal::c_end(c),
454                                 std::forward<Pred>(pred));
455  }
456  template <typename C, typename OutputIterator1, typename OutputIterator2,
457            typename Pred>
458  std::pair<OutputIterator1, OutputIterator2> c_partition_copy(
459      const C& c, OutputIterator1 out_true, OutputIterator2 out_false,
460      Pred&& pred) {
461    return std::partition_copy(container_algorithm_internal::c_begin(c),
462                               container_algorithm_internal::c_end(c), out_true,
463                               out_false, std::forward<Pred>(pred));
464  }
465  template <typename C, typename Pred>
466  container_algorithm_internal::ContainerIter<C> c_partition_point(C& c,
467                                                                   Pred&& pred) {
468    return std::partition_point(container_algorithm_internal::c_begin(c),
469                                container_algorithm_internal::c_end(c),
470                                std::forward<Pred>(pred));
471  }
472  template <typename C>
473  void c_sort(C& c) {
474    std::sort(container_algorithm_internal::c_begin(c),
475              container_algorithm_internal::c_end(c));
476  }
477  template <typename C, typename LessThan>
478  void c_sort(C& c, LessThan&& comp) {
479    std::sort(container_algorithm_internal::c_begin(c),
480              container_algorithm_internal::c_end(c),
481              std::forward<LessThan>(comp));
482  }
483  template <typename C>
484  void c_stable_sort(C& c) {
485    std::stable_sort(container_algorithm_internal::c_begin(c),
486                     container_algorithm_internal::c_end(c));
487  }
488  template <typename C, typename LessThan>
489  void c_stable_sort(C& c, LessThan&& comp) {
490    std::stable_sort(container_algorithm_internal::c_begin(c),
491                     container_algorithm_internal::c_end(c),
492                     std::forward<LessThan>(comp));
493  }
494  template <typename C>
495  bool c_is_sorted(const C& c) {
496    return std::is_sorted(container_algorithm_internal::c_begin(c),
497                          container_algorithm_internal::c_end(c));
498  }
499  template <typename C, typename LessThan>
500  bool c_is_sorted(const C& c, LessThan&& comp) {
501    return std::is_sorted(container_algorithm_internal::c_begin(c),
502                          container_algorithm_internal::c_end(c),
503                          std::forward<LessThan>(comp));
504  }
505  template <typename RandomAccessContainer>
506  void c_partial_sort(
507      RandomAccessContainer& sequence,
508      container_algorithm_internal::ContainerIter<RandomAccessContainer> middle) {
509    std::partial_sort(container_algorithm_internal::c_begin(sequence), middle,
510                      container_algorithm_internal::c_end(sequence));
511  }
512  template <typename RandomAccessContainer, typename LessThan>
513  void c_partial_sort(
514      RandomAccessContainer& sequence,
515      container_algorithm_internal::ContainerIter<RandomAccessContainer> middle,
516      LessThan&& comp) {
517    std::partial_sort(container_algorithm_internal::c_begin(sequence), middle,
518                      container_algorithm_internal::c_end(sequence),
519                      std::forward<LessThan>(comp));
520  }
521  template <typename C, typename RandomAccessContainer>
522  container_algorithm_internal::ContainerIter<RandomAccessContainer>
523  c_partial_sort_copy(const C& sequence, RandomAccessContainer& result) {
524    return std::partial_sort_copy(container_algorithm_internal::c_begin(sequence),
525                                  container_algorithm_internal::c_end(sequence),
526                                  container_algorithm_internal::c_begin(result),
527                                  container_algorithm_internal::c_end(result));
528  }
529  template <typename C, typename RandomAccessContainer, typename LessThan>
530  container_algorithm_internal::ContainerIter<RandomAccessContainer>
531  c_partial_sort_copy(const C& sequence, RandomAccessContainer& result,
532                      LessThan&& comp) {
533    return std::partial_sort_copy(container_algorithm_internal::c_begin(sequence),
534                                  container_algorithm_internal::c_end(sequence),
535                                  container_algorithm_internal::c_begin(result),
536                                  container_algorithm_internal::c_end(result),
537                                  std::forward<LessThan>(comp));
538  }
539  template <typename C>
540  container_algorithm_internal::ContainerIter<C> c_is_sorted_until(C& c) {
541    return std::is_sorted_until(container_algorithm_internal::c_begin(c),
542                                container_algorithm_internal::c_end(c));
543  }
544  template <typename C, typename LessThan>
545  container_algorithm_internal::ContainerIter<C> c_is_sorted_until(
546      C& c, LessThan&& comp) {
547    return std::is_sorted_until(container_algorithm_internal::c_begin(c),
548                                container_algorithm_internal::c_end(c),
549                                std::forward<LessThan>(comp));
550  }
551  template <typename RandomAccessContainer>
552  void c_nth_element(
553      RandomAccessContainer& sequence,
554      container_algorithm_internal::ContainerIter<RandomAccessContainer> nth) {
555    std::nth_element(container_algorithm_internal::c_begin(sequence), nth,
556                     container_algorithm_internal::c_end(sequence));
557  }
558  template <typename RandomAccessContainer, typename LessThan>
559  void c_nth_element(
560      RandomAccessContainer& sequence,
561      container_algorithm_internal::ContainerIter<RandomAccessContainer> nth,
562      LessThan&& comp) {
563    std::nth_element(container_algorithm_internal::c_begin(sequence), nth,
564                     container_algorithm_internal::c_end(sequence),
565                     std::forward<LessThan>(comp));
566  }
567  template <typename Sequence, typename T>
568  container_algorithm_internal::ContainerIter<Sequence> c_lower_bound(
569      Sequence& sequence, const T& value) {
570    return std::lower_bound(container_algorithm_internal::c_begin(sequence),
571                            container_algorithm_internal::c_end(sequence), value);
572  }
573  template <typename Sequence, typename T, typename LessThan>
574  container_algorithm_internal::ContainerIter<Sequence> c_lower_bound(
575      Sequence& sequence, const T& value, LessThan&& comp) {
576    return std::lower_bound(container_algorithm_internal::c_begin(sequence),
577                            container_algorithm_internal::c_end(sequence), value,
578                            std::forward<LessThan>(comp));
579  }
580  template <typename Sequence, typename T>
581  container_algorithm_internal::ContainerIter<Sequence> c_upper_bound(
582      Sequence& sequence, const T& value) {
583    return std::upper_bound(container_algorithm_internal::c_begin(sequence),
584                            container_algorithm_internal::c_end(sequence), value);
585  }
586  template <typename Sequence, typename T, typename LessThan>
587  container_algorithm_internal::ContainerIter<Sequence> c_upper_bound(
588      Sequence& sequence, const T& value, LessThan&& comp) {
589    return std::upper_bound(container_algorithm_internal::c_begin(sequence),
590                            container_algorithm_internal::c_end(sequence), value,
591                            std::forward<LessThan>(comp));
592  }
593  template <typename Sequence, typename T>
594  container_algorithm_internal::ContainerIterPairType<Sequence, Sequence>
595  c_equal_range(Sequence& sequence, const T& value) {
596    return std::equal_range(container_algorithm_internal::c_begin(sequence),
597                            container_algorithm_internal::c_end(sequence), value);
598  }
599  template <typename Sequence, typename T, typename LessThan>
600  container_algorithm_internal::ContainerIterPairType<Sequence, Sequence>
601  c_equal_range(Sequence& sequence, const T& value, LessThan&& comp) {
602    return std::equal_range(container_algorithm_internal::c_begin(sequence),
603                            container_algorithm_internal::c_end(sequence), value,
604                            std::forward<LessThan>(comp));
605  }
606  template <typename Sequence, typename T>
607  bool c_binary_search(const Sequence& sequence, const T& value) {
608    return std::binary_search(container_algorithm_internal::c_begin(sequence),
609                              container_algorithm_internal::c_end(sequence),
610                              value);
611  }
612  template <typename Sequence, typename T, typename LessThan>
613  bool c_binary_search(const Sequence& sequence, const T& value,
614                       LessThan&& comp) {
615    return std::binary_search(container_algorithm_internal::c_begin(sequence),
616                              container_algorithm_internal::c_end(sequence),
617                              value, std::forward<LessThan>(comp));
618  }
619  template <typename C1, typename C2, typename OutputIterator>
620  OutputIterator c_merge(const C1& c1, const C2& c2, OutputIterator result) {
621    return std::merge(container_algorithm_internal::c_begin(c1),
622                      container_algorithm_internal::c_end(c1),
623                      container_algorithm_internal::c_begin(c2),
624                      container_algorithm_internal::c_end(c2), result);
625  }
626  template <typename C1, typename C2, typename OutputIterator, typename LessThan>
627  OutputIterator c_merge(const C1& c1, const C2& c2, OutputIterator result,
628                         LessThan&& comp) {
629    return std::merge(container_algorithm_internal::c_begin(c1),
630                      container_algorithm_internal::c_end(c1),
631                      container_algorithm_internal::c_begin(c2),
632                      container_algorithm_internal::c_end(c2), result,
633                      std::forward<LessThan>(comp));
634  }
635  template <typename C>
636  void c_inplace_merge(C& c,
637                       container_algorithm_internal::ContainerIter<C> middle) {
638    std::inplace_merge(container_algorithm_internal::c_begin(c), middle,
639                       container_algorithm_internal::c_end(c));
640  }
641  template <typename C, typename LessThan>
642  void c_inplace_merge(C& c,
643                       container_algorithm_internal::ContainerIter<C> middle,
644                       LessThan&& comp) {
645    std::inplace_merge(container_algorithm_internal::c_begin(c), middle,
646                       container_algorithm_internal::c_end(c),
647                       std::forward<LessThan>(comp));
648  }
649  template <typename C1, typename C2>
650  bool c_includes(const C1& c1, const C2& c2) {
651    return std::includes(container_algorithm_internal::c_begin(c1),
652                         container_algorithm_internal::c_end(c1),
653                         container_algorithm_internal::c_begin(c2),
654                         container_algorithm_internal::c_end(c2));
655  }
656  template <typename C1, typename C2, typename LessThan>
657  bool c_includes(const C1& c1, const C2& c2, LessThan&& comp) {
658    return std::includes(container_algorithm_internal::c_begin(c1),
659                         container_algorithm_internal::c_end(c1),
660                         container_algorithm_internal::c_begin(c2),
661                         container_algorithm_internal::c_end(c2),
662                         std::forward<LessThan>(comp));
663  }
664  template <typename C1, typename C2, typename OutputIterator,
665            typename = typename std::enable_if<
666                !container_algorithm_internal::IsUnorderedContainer<C1>::value,
667                void>::type,
668            typename = typename std::enable_if<
669                !container_algorithm_internal::IsUnorderedContainer<C2>::value,
670                void>::type>
671  OutputIterator c_set_union(const C1& c1, const C2& c2, OutputIterator output) {
672    return std::set_union(container_algorithm_internal::c_begin(c1),
673                          container_algorithm_internal::c_end(c1),
674                          container_algorithm_internal::c_begin(c2),
675                          container_algorithm_internal::c_end(c2), output);
676  }
677  template <typename C1, typename C2, typename OutputIterator, typename LessThan,
678            typename = typename std::enable_if<
679                !container_algorithm_internal::IsUnorderedContainer<C1>::value,
680                void>::type,
681            typename = typename std::enable_if<
682                !container_algorithm_internal::IsUnorderedContainer<C2>::value,
683                void>::type>
684  OutputIterator c_set_union(const C1& c1, const C2& c2, OutputIterator output,
685                             LessThan&& comp) {
686    return std::set_union(container_algorithm_internal::c_begin(c1),
687                          container_algorithm_internal::c_end(c1),
688                          container_algorithm_internal::c_begin(c2),
689                          container_algorithm_internal::c_end(c2), output,
690                          std::forward<LessThan>(comp));
691  }
692  template <typename C1, typename C2, typename OutputIterator,
693            typename = typename std::enable_if<
694                !container_algorithm_internal::IsUnorderedContainer<C1>::value,
695                void>::type,
696            typename = typename std::enable_if<
697                !container_algorithm_internal::IsUnorderedContainer<C2>::value,
698                void>::type>
699  OutputIterator c_set_intersection(const C1& c1, const C2& c2,
700                                    OutputIterator output) {
701    assert(absl::c_is_sorted(c1));
702    assert(absl::c_is_sorted(c2));
703    return std::set_intersection(container_algorithm_internal::c_begin(c1),
704                                 container_algorithm_internal::c_end(c1),
705                                 container_algorithm_internal::c_begin(c2),
706                                 container_algorithm_internal::c_end(c2), output);
707  }
708  template <typename C1, typename C2, typename OutputIterator, typename LessThan,
709            typename = typename std::enable_if<
710                !container_algorithm_internal::IsUnorderedContainer<C1>::value,
711                void>::type,
712            typename = typename std::enable_if<
713                !container_algorithm_internal::IsUnorderedContainer<C2>::value,
714                void>::type>
715  OutputIterator c_set_intersection(const C1& c1, const C2& c2,
716                                    OutputIterator output, LessThan&& comp) {
717    assert(absl::c_is_sorted(c1, comp));
718    assert(absl::c_is_sorted(c2, comp));
719    return std::set_intersection(container_algorithm_internal::c_begin(c1),
720                                 container_algorithm_internal::c_end(c1),
721                                 container_algorithm_internal::c_begin(c2),
722                                 container_algorithm_internal::c_end(c2), output,
723                                 std::forward<LessThan>(comp));
724  }
725  template <typename C1, typename C2, typename OutputIterator,
726            typename = typename std::enable_if<
727                !container_algorithm_internal::IsUnorderedContainer<C1>::value,
728                void>::type,
729            typename = typename std::enable_if<
730                !container_algorithm_internal::IsUnorderedContainer<C2>::value,
731                void>::type>
732  OutputIterator c_set_difference(const C1& c1, const C2& c2,
733                                  OutputIterator output) {
734    return std::set_difference(container_algorithm_internal::c_begin(c1),
735                               container_algorithm_internal::c_end(c1),
736                               container_algorithm_internal::c_begin(c2),
737                               container_algorithm_internal::c_end(c2), output);
738  }
739  template <typename C1, typename C2, typename OutputIterator, typename LessThan,
740            typename = typename std::enable_if<
741                !container_algorithm_internal::IsUnorderedContainer<C1>::value,
742                void>::type,
743            typename = typename std::enable_if<
744                !container_algorithm_internal::IsUnorderedContainer<C2>::value,
745                void>::type>
746  OutputIterator c_set_difference(const C1& c1, const C2& c2,
747                                  OutputIterator output, LessThan&& comp) {
748    return std::set_difference(container_algorithm_internal::c_begin(c1),
749                               container_algorithm_internal::c_end(c1),
750                               container_algorithm_internal::c_begin(c2),
751                               container_algorithm_internal::c_end(c2), output,
752                               std::forward<LessThan>(comp));
753  }
754  template <typename C1, typename C2, typename OutputIterator,
755            typename = typename std::enable_if<
756                !container_algorithm_internal::IsUnorderedContainer<C1>::value,
757                void>::type,
758            typename = typename std::enable_if<
759                !container_algorithm_internal::IsUnorderedContainer<C2>::value,
760                void>::type>
761  OutputIterator c_set_symmetric_difference(const C1& c1, const C2& c2,
762                                            OutputIterator output) {
763    return std::set_symmetric_difference(
764        container_algorithm_internal::c_begin(c1),
765        container_algorithm_internal::c_end(c1),
766        container_algorithm_internal::c_begin(c2),
767        container_algorithm_internal::c_end(c2), output);
768  }
769  template <typename C1, typename C2, typename OutputIterator, typename LessThan,
770            typename = typename std::enable_if<
771                !container_algorithm_internal::IsUnorderedContainer<C1>::value,
772                void>::type,
773            typename = typename std::enable_if<
774                !container_algorithm_internal::IsUnorderedContainer<C2>::value,
775                void>::type>
776  OutputIterator c_set_symmetric_difference(const C1& c1, const C2& c2,
777                                            OutputIterator output,
778                                            LessThan&& comp) {
779    return std::set_symmetric_difference(
780        container_algorithm_internal::c_begin(c1),
781        container_algorithm_internal::c_end(c1),
782        container_algorithm_internal::c_begin(c2),
783        container_algorithm_internal::c_end(c2), output,
784        std::forward<LessThan>(comp));
785  }
786  template <typename RandomAccessContainer>
787  void c_push_heap(RandomAccessContainer& sequence) {
788    std::push_heap(container_algorithm_internal::c_begin(sequence),
789                   container_algorithm_internal::c_end(sequence));
790  }
791  template <typename RandomAccessContainer, typename LessThan>
792  void c_push_heap(RandomAccessContainer& sequence, LessThan&& comp) {
793    std::push_heap(container_algorithm_internal::c_begin(sequence),
794                   container_algorithm_internal::c_end(sequence),
795                   std::forward<LessThan>(comp));
796  }
797  template <typename RandomAccessContainer>
798  void c_pop_heap(RandomAccessContainer& sequence) {
799    std::pop_heap(container_algorithm_internal::c_begin(sequence),
800                  container_algorithm_internal::c_end(sequence));
801  }
802  template <typename RandomAccessContainer, typename LessThan>
803  void c_pop_heap(RandomAccessContainer& sequence, LessThan&& comp) {
804    std::pop_heap(container_algorithm_internal::c_begin(sequence),
805                  container_algorithm_internal::c_end(sequence),
806                  std::forward<LessThan>(comp));
807  }
808  template <typename RandomAccessContainer>
809  void c_make_heap(RandomAccessContainer& sequence) {
810    std::make_heap(container_algorithm_internal::c_begin(sequence),
811                   container_algorithm_internal::c_end(sequence));
812  }
813  template <typename RandomAccessContainer, typename LessThan>
814  void c_make_heap(RandomAccessContainer& sequence, LessThan&& comp) {
815    std::make_heap(container_algorithm_internal::c_begin(sequence),
816                   container_algorithm_internal::c_end(sequence),
817                   std::forward<LessThan>(comp));
818  }
819  template <typename RandomAccessContainer>
820  void c_sort_heap(RandomAccessContainer& sequence) {
821    std::sort_heap(container_algorithm_internal::c_begin(sequence),
822                   container_algorithm_internal::c_end(sequence));
823  }
824  template <typename RandomAccessContainer, typename LessThan>
825  void c_sort_heap(RandomAccessContainer& sequence, LessThan&& comp) {
826    std::sort_heap(container_algorithm_internal::c_begin(sequence),
827                   container_algorithm_internal::c_end(sequence),
828                   std::forward<LessThan>(comp));
829  }
830  template <typename RandomAccessContainer>
831  bool c_is_heap(const RandomAccessContainer& sequence) {
832    return std::is_heap(container_algorithm_internal::c_begin(sequence),
833                        container_algorithm_internal::c_end(sequence));
834  }
835  template <typename RandomAccessContainer, typename LessThan>
836  bool c_is_heap(const RandomAccessContainer& sequence, LessThan&& comp) {
837    return std::is_heap(container_algorithm_internal::c_begin(sequence),
838                        container_algorithm_internal::c_end(sequence),
839                        std::forward<LessThan>(comp));
840  }
841  template <typename RandomAccessContainer>
842  container_algorithm_internal::ContainerIter<RandomAccessContainer>
843  c_is_heap_until(RandomAccessContainer& sequence) {
844    return std::is_heap_until(container_algorithm_internal::c_begin(sequence),
845                              container_algorithm_internal::c_end(sequence));
846  }
847  template <typename RandomAccessContainer, typename LessThan>
848  container_algorithm_internal::ContainerIter<RandomAccessContainer>
849  c_is_heap_until(RandomAccessContainer& sequence, LessThan&& comp) {
850    return std::is_heap_until(container_algorithm_internal::c_begin(sequence),
851                              container_algorithm_internal::c_end(sequence),
852                              std::forward<LessThan>(comp));
853  }
854  template <typename Sequence>
855  container_algorithm_internal::ContainerIter<Sequence> c_min_element(
856      Sequence& sequence) {
857    return std::min_element(container_algorithm_internal::c_begin(sequence),
858                            container_algorithm_internal::c_end(sequence));
859  }
860  template <typename Sequence, typename LessThan>
861  container_algorithm_internal::ContainerIter<Sequence> c_min_element(
862      Sequence& sequence, LessThan&& comp) {
863    return std::min_element(container_algorithm_internal::c_begin(sequence),
864                            container_algorithm_internal::c_end(sequence),
865                            std::forward<LessThan>(comp));
866  }
867  template <typename Sequence>
868  container_algorithm_internal::ContainerIter<Sequence> c_max_element(
869      Sequence& sequence) {
870    return std::max_element(container_algorithm_internal::c_begin(sequence),
871                            container_algorithm_internal::c_end(sequence));
872  }
873  template <typename Sequence, typename LessThan>
874  container_algorithm_internal::ContainerIter<Sequence> c_max_element(
875      Sequence& sequence, LessThan&& comp) {
876    return std::max_element(container_algorithm_internal::c_begin(sequence),
877                            container_algorithm_internal::c_end(sequence),
878                            std::forward<LessThan>(comp));
879  }
880  template <typename C>
881  container_algorithm_internal::ContainerIterPairType<C, C> c_minmax_element(
882      C& c) {
883    return std::minmax_element(container_algorithm_internal::c_begin(c),
884                               container_algorithm_internal::c_end(c));
885  }
886  template <typename C, typename LessThan>
887  container_algorithm_internal::ContainerIterPairType<C, C> c_minmax_element(
888      C& c, LessThan&& comp) {
889    return std::minmax_element(container_algorithm_internal::c_begin(c),
890                               container_algorithm_internal::c_end(c),
891                               std::forward<LessThan>(comp));
892  }
893  template <typename Sequence1, typename Sequence2>
894  bool c_lexicographical_compare(const Sequence1& sequence1,
895                                 const Sequence2& sequence2) {
896    return std::lexicographical_compare(
897        container_algorithm_internal::c_begin(sequence1),
898        container_algorithm_internal::c_end(sequence1),
899        container_algorithm_internal::c_begin(sequence2),
900        container_algorithm_internal::c_end(sequence2));
901  }
902  template <typename Sequence1, typename Sequence2, typename LessThan>
903  bool c_lexicographical_compare(const Sequence1& sequence1,
904                                 const Sequence2& sequence2, LessThan&& comp) {
905    return std::lexicographical_compare(
906        container_algorithm_internal::c_begin(sequence1),
907        container_algorithm_internal::c_end(sequence1),
908        container_algorithm_internal::c_begin(sequence2),
909        container_algorithm_internal::c_end(sequence2),
910        std::forward<LessThan>(comp));
911  }
912  template <typename C>
913  bool c_next_permutation(C& c) {
914    return std::next_permutation(container_algorithm_internal::c_begin(c),
915                                 container_algorithm_internal::c_end(c));
916  }
917  template <typename C, typename LessThan>
918  bool c_next_permutation(C& c, LessThan&& comp) {
919    return std::next_permutation(container_algorithm_internal::c_begin(c),
920                                 container_algorithm_internal::c_end(c),
921                                 std::forward<LessThan>(comp));
922  }
923  template <typename C>
924  bool c_prev_permutation(C& c) {
925    return std::prev_permutation(container_algorithm_internal::c_begin(c),
926                                 container_algorithm_internal::c_end(c));
927  }
928  template <typename C, typename LessThan>
929  bool c_prev_permutation(C& c, LessThan&& comp) {
930    return std::prev_permutation(container_algorithm_internal::c_begin(c),
931                                 container_algorithm_internal::c_end(c),
932                                 std::forward<LessThan>(comp));
933  }
934  template <typename Sequence, typename T>
935  void c_iota(Sequence& sequence, const T& value) {
936    std::iota(container_algorithm_internal::c_begin(sequence),
937              container_algorithm_internal::c_end(sequence), value);
938  }
939  template <typename Sequence, typename T>
940  decay_t<T> c_accumulate(const Sequence& sequence, T&& init) {
941    return std::accumulate(container_algorithm_internal::c_begin(sequence),
942                           container_algorithm_internal::c_end(sequence),
943                           std::forward<T>(init));
944  }
945  template <typename Sequence, typename T, typename BinaryOp>
946  decay_t<T> c_accumulate(const Sequence& sequence, T&& init,
947                          BinaryOp&& binary_op) {
948    return std::accumulate(container_algorithm_internal::c_begin(sequence),
949                           container_algorithm_internal::c_end(sequence),
950                           std::forward<T>(init),
951                           std::forward<BinaryOp>(binary_op));
952  }
953  template <typename Sequence1, typename Sequence2, typename T>
954  decay_t<T> c_inner_product(const Sequence1& factors1, const Sequence2& factors2,
955                             T&& sum) {
956    return std::inner_product(container_algorithm_internal::c_begin(factors1),
957                              container_algorithm_internal::c_end(factors1),
958                              container_algorithm_internal::c_begin(factors2),
959                              std::forward<T>(sum));
960  }
961  template <typename Sequence1, typename Sequence2, typename T,
962            typename BinaryOp1, typename BinaryOp2>
963  decay_t<T> c_inner_product(const Sequence1& factors1, const Sequence2& factors2,
964                             T&& sum, BinaryOp1&& op1, BinaryOp2&& op2) {
965    return std::inner_product(container_algorithm_internal::c_begin(factors1),
966                              container_algorithm_internal::c_end(factors1),
967                              container_algorithm_internal::c_begin(factors2),
968                              std::forward<T>(sum), std::forward<BinaryOp1>(op1),
969                              std::forward<BinaryOp2>(op2));
970  }
971  template <typename InputSequence, typename OutputIt>
972  OutputIt c_adjacent_difference(const InputSequence& input,
973                                 OutputIt output_first) {
974    return std::adjacent_difference(container_algorithm_internal::c_begin(input),
975                                    container_algorithm_internal::c_end(input),
976                                    output_first);
977  }
978  template <typename InputSequence, typename OutputIt, typename BinaryOp>
979  OutputIt c_adjacent_difference(const InputSequence& input,
980                                 OutputIt output_first, BinaryOp&& op) {
981    return std::adjacent_difference(container_algorithm_internal::c_begin(input),
982                                    container_algorithm_internal::c_end(input),
983                                    output_first, std::forward<BinaryOp>(op));
984  }
985  template <typename InputSequence, typename OutputIt>
986  OutputIt c_partial_sum(const InputSequence& input, OutputIt output_first) {
987    return std::partial_sum(container_algorithm_internal::c_begin(input),
988                            container_algorithm_internal::c_end(input),
989                            output_first);
990  }
991  template <typename InputSequence, typename OutputIt, typename BinaryOp>
992  OutputIt c_partial_sum(const InputSequence& input, OutputIt output_first,
993                         BinaryOp&& op) {
994    return std::partial_sum(container_algorithm_internal::c_begin(input),
995                            container_algorithm_internal::c_end(input),
996                            output_first, std::forward<BinaryOp>(op));
997  }
998  ABSL_NAMESPACE_END
999  }  
1000  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-columnEditor.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-container.h</div>
                </div>
                <div class="column column_space"><pre><code>146  							{
147  								auto lineBegin = (*_ppEditView)->execute(SCI_POSITIONFROMLINE, i);
148  								auto lineEnd = (*_ppEditView)->execute(SCI_GETLINEENDPOSITION, i);
149  								auto lineEndCol = (*_ppEditView)->execute(SCI_GETCOLUMN, lineEnd);
150  								auto lineLen = lineEnd - lineBegin + 1;
</pre></code></div>
                <div class="column column_space"><pre><code>188      C1& c1, C2& c2, BinaryPredicate pred) {
189    auto first1 = container_algorithm_internal::c_begin(c1);
190    auto last1 = container_algorithm_internal::c_end(c1);
191    auto first2 = container_algorithm_internal::c_begin(c2);
192    auto last2 = container_algorithm_internal::c_end(c2);
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    