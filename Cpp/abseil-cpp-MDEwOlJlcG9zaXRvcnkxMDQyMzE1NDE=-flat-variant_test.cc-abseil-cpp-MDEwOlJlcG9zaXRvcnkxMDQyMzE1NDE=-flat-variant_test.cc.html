
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 82, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-variant_test.cc</h3>
            <pre><code>1  #include "absl/types/variant.h"
2  #if !defined(ABSL_USES_STD_VARIANT)
3  #include <algorithm>
4  #include <cstddef>
5  #include <functional>
6  #include <initializer_list>
7  #include <memory>
8  #include <ostream>
9  #include <queue>
10  #include <type_traits>
11  #include <unordered_set>
12  #include <utility>
13  #include <vector>
14  #include "gmock/gmock.h"
15  #include "gtest/gtest.h"
16  #include "absl/base/config.h"
17  #include "absl/base/port.h"
18  #include "absl/memory/memory.h"
19  #include "absl/meta/type_traits.h"
20  #include "absl/strings/string_view.h"
21  #ifdef ABSL_HAVE_EXCEPTIONS
22  #define ABSL_VARIANT_TEST_EXPECT_FAIL(expr, exception_t, text) \
23    EXPECT_THROW(expr, exception_t)
24  #else
25  #define ABSL_VARIANT_TEST_EXPECT_FAIL(expr, exception_t, text) \
26    EXPECT_DEATH_IF_SUPPORTED(expr, text)
27  #endif  
28  #define ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(...)                 \
29    ABSL_VARIANT_TEST_EXPECT_FAIL((void)(__VA_ARGS__), absl::bad_variant_access, \
30                                  "Bad variant access")
31  struct Hashable {};
32  namespace std {
33  template <>
34  struct hash<Hashable> {
35    size_t operator()(const Hashable&);
36  };
37  }  
38  struct NonHashable {};
39  namespace absl {
40  ABSL_NAMESPACE_BEGIN
41  namespace {
42  using ::testing::DoubleEq;
43  using ::testing::Pointee;
44  using ::testing::VariantWith;
45  struct MoveCanThrow {
46    MoveCanThrow() : v(0) {}
47    MoveCanThrow(int v) : v(v) {}  
48    MoveCanThrow(const MoveCanThrow& other) : v(other.v) {}
49    MoveCanThrow& operator=(const MoveCanThrow& &bsol;*other*/) { return *this; }
50    int v;
51  };
52  bool operator==(MoveCanThrow lhs, MoveCanThrow rhs) { return lhs.v == rhs.v; }
53  bool operator!=(MoveCanThrow lhs, MoveCanThrow rhs) { return lhs.v != rhs.v; }
54  bool operator<(MoveCanThrow lhs, MoveCanThrow rhs) { return lhs.v < rhs.v; }
55  bool operator<=(MoveCanThrow lhs, MoveCanThrow rhs) { return lhs.v <= rhs.v; }
56  bool operator>=(MoveCanThrow lhs, MoveCanThrow rhs) { return lhs.v >= rhs.v; }
57  bool operator>(MoveCanThrow lhs, MoveCanThrow rhs) { return lhs.v > rhs.v; }
58  struct SpecialSwap {
59    explicit SpecialSwap(int i) : i(i) {}
60    friend void swap(SpecialSwap& a, SpecialSwap& b) {
61      a.special_swap = b.special_swap = true;
62      std::swap(a.i, b.i);
63    }
64    bool operator==(SpecialSwap other) const { return i == other.i; }
65    int i;
66    bool special_swap = false;
67  };
68  struct MoveOnlyWithListConstructor {
69    MoveOnlyWithListConstructor() = default;
70    explicit MoveOnlyWithListConstructor(std::initializer_list<int> &bsol;*ilist*/,
71                                         int value)
72        : value(value) {}
73    MoveOnlyWithListConstructor(MoveOnlyWithListConstructor&&) = default;
74    MoveOnlyWithListConstructor& operator=(MoveOnlyWithListConstructor&&) =
75        default;
76    int value = 0;
77  };
78  #ifdef ABSL_HAVE_EXCEPTIONS
79  struct ConversionException {};
80  template <class T>
81  struct ExceptionOnConversion {
82    operator T() const {  
83      throw ConversionException();
84    }
85  };
86  template <class H, class... T>
87  void ToValuelessByException(absl::variant<H, T...>& v) {  
88    try {
89      v.template emplace<0>(ExceptionOnConversion<H>());
90    } catch (ConversionException& &bsol;*e*/) {
91    }
92  }
93  #endif  
94  template<typename T, size_t N>
95  struct ValueHolder {
96    explicit ValueHolder(const T& x) : value(x) {}
97    typedef T value_type;
98    value_type value;
99    static const size_t kIndex = N;
100  };
101  template<typename T, size_t N>
102  const size_t ValueHolder<T, N>::kIndex;
103  template<typename T, size_t N>
104  inline bool operator==(const ValueHolder<T, N>& left,
105                         const ValueHolder<T, N>& right) {
106    return left.value == right.value;
107  }
108  template<typename T, size_t N>
109  inline bool operator!=(const ValueHolder<T, N>& left,
110                         const ValueHolder<T, N>& right) {
111    return left.value != right.value;
112  }
113  template<typename T, size_t N>
114  inline std::ostream& operator<<(
115      std::ostream& stream, const ValueHolder<T, N>& object) {
116    return stream << object.value;
117  }
118  template<typename T>
119  struct VariantFactory {
120    typedef variant<ValueHolder<T, 1>, ValueHolder<T, 2>, ValueHolder<T, 3>,
121                    ValueHolder<T, 4>>
122        Type;
123  };
124  typedef ::testing::Types<ValueHolder<size_t, 1>, ValueHolder<size_t, 2>,
125                           ValueHolder<size_t, 3>,
126                           ValueHolder<size_t, 4>> VariantTypes;
127  struct IncrementInDtor {
128    explicit IncrementInDtor(int* counter) : counter(counter) {}
129    ~IncrementInDtor() { *counter += 1; }
130    int* counter;
131  };
132  struct IncrementInDtorCopyCanThrow {
133    explicit IncrementInDtorCopyCanThrow(int* counter) : counter(counter) {}
134    IncrementInDtorCopyCanThrow(IncrementInDtorCopyCanThrow&& other) noexcept =
135        default;
136    IncrementInDtorCopyCanThrow(const IncrementInDtorCopyCanThrow& other)
137        : counter(other.counter) {}
138    IncrementInDtorCopyCanThrow& operator=(
139        IncrementInDtorCopyCanThrow&&) noexcept = default;
140    IncrementInDtorCopyCanThrow& operator=(
141        IncrementInDtorCopyCanThrow const& other) {
142      counter = other.counter;
143      return *this;
144    }
145    ~IncrementInDtorCopyCanThrow() { *counter += 1; }
146    int* counter;
147  };
148  inline bool operator==(const IncrementInDtor& left,
149                         const IncrementInDtor& right) {
150    return left.counter == right.counter;
151  }
152  inline std::ostream& operator<<(
153      std::ostream& stream, const IncrementInDtor& object) {
154    return stream << object.counter;
155  }
156  class CopyNoAssign {
157   public:
158    explicit CopyNoAssign(int value) : foo(value) {}
159    CopyNoAssign(const CopyNoAssign& other) : foo(other.foo) {}
160    int foo;
161   private:
162    const CopyNoAssign& operator=(const CopyNoAssign&);
163  };
164  class NonCopyable {
165   public:
166    NonCopyable()
167        : value(0) {}
168    explicit NonCopyable(int value1)
169        : value(value1) {}
170    NonCopyable(int value1, int value2)
171        : value(value1 + value2) {}
172    NonCopyable(int value1, int value2, int value3)
173        : value(value1 + value2 + value3) {}
174    NonCopyable(int value1, int value2, int value3, int value4)
175        : value(value1 + value2 + value3 + value4) {}
176    NonCopyable(const NonCopyable&) = delete;
177    NonCopyable& operator=(const NonCopyable&) = delete;
178    int value;
179  };
180  template <typename T>
181  class VariantTypesTest : public ::testing::Test {};
182  TYPED_TEST_SUITE(VariantTypesTest, VariantTypes);
183  struct NonNoexceptDefaultConstructible {
184    NonNoexceptDefaultConstructible() {}
185    int value = 5;
186  };
187  struct NonDefaultConstructible {
188    NonDefaultConstructible() = delete;
189  };
190  TEST(VariantTest, TestDefaultConstructor) {
191    {
192      using X = variant<int>;
193      constexpr variant<int> x{};
194      ASSERT_FALSE(x.valueless_by_exception());
195      ASSERT_EQ(0u, x.index());
196      EXPECT_EQ(0, absl::get<0>(x));
197      EXPECT_TRUE(std::is_nothrow_default_constructible<X>::value);
198    }
199    {
200      using X = variant<NonNoexceptDefaultConstructible>;
201      X x{};
202      ASSERT_FALSE(x.valueless_by_exception());
203      ASSERT_EQ(0u, x.index());
204      EXPECT_EQ(5, absl::get<0>(x).value);
205      EXPECT_FALSE(std::is_nothrow_default_constructible<X>::value);
206    }
207    {
208      using X = variant<int, NonNoexceptDefaultConstructible>;
209      X x{};
210      ASSERT_FALSE(x.valueless_by_exception());
211      ASSERT_EQ(0u, x.index());
212      EXPECT_EQ(0, absl::get<0>(x));
213      EXPECT_TRUE(std::is_nothrow_default_constructible<X>::value);
214    }
215    {
216      using X = variant<NonNoexceptDefaultConstructible, int>;
217      X x{};
218      ASSERT_FALSE(x.valueless_by_exception());
219      ASSERT_EQ(0u, x.index());
220      EXPECT_EQ(5, absl::get<0>(x).value);
221      EXPECT_FALSE(std::is_nothrow_default_constructible<X>::value);
222    }
223    EXPECT_FALSE(
224        std::is_default_constructible<variant<NonDefaultConstructible>>::value);
225    EXPECT_FALSE((std::is_default_constructible<
226                  variant<NonDefaultConstructible, int>>::value));
227    EXPECT_TRUE((std::is_default_constructible<
228                 variant<int, NonDefaultConstructible>>::value));
229  }
230  TYPED_TEST(VariantTypesTest, TestCopyCtor) {
231    typedef typename VariantFactory<typename TypeParam::value_type>::Type Variant;
232    using value_type1 = absl::variant_alternative_t<0, Variant>;
233    using value_type2 = absl::variant_alternative_t<1, Variant>;
234    using value_type3 = absl::variant_alternative_t<2, Variant>;
235    using value_type4 = absl::variant_alternative_t<3, Variant>;
236    const TypeParam value(TypeParam::kIndex);
237    Variant original(value);
<span onclick='openModal()' class='match'>238    Variant copied(original);
239    EXPECT_TRUE(absl::holds_alternative<value_type1>(copied) ||
240                TypeParam::kIndex != 1);
241    EXPECT_TRUE(absl::holds_alternative<value_type2>(copied) ||
242                TypeParam::kIndex != 2);
243    EXPECT_TRUE(absl::holds_alternative<value_type3>(copied) ||
244                TypeParam::kIndex != 3);
245    EXPECT_TRUE(absl::holds_alternative<value_type4>(copied) ||
246                TypeParam::kIndex != 4);
247    EXPECT_TRUE((absl::get_if<value_type1>(&original) ==
</span>248                 absl::get_if<value_type1>(&copied)) ||
249                TypeParam::kIndex == 1);
250    EXPECT_TRUE((absl::get_if<value_type2>(&original) ==
251                 absl::get_if<value_type2>(&copied)) ||
252                TypeParam::kIndex == 2);
253    EXPECT_TRUE((absl::get_if<value_type3>(&original) ==
254                 absl::get_if<value_type3>(&copied)) ||
255                TypeParam::kIndex == 3);
256    EXPECT_TRUE((absl::get_if<value_type4>(&original) ==
257                 absl::get_if<value_type4>(&copied)) ||
258                TypeParam::kIndex == 4);
259    EXPECT_TRUE((absl::get_if<value_type1>(&original) ==
260                 absl::get_if<value_type1>(&copied)) ||
261                TypeParam::kIndex == 1);
262    EXPECT_TRUE((absl::get_if<value_type2>(&original) ==
263                 absl::get_if<value_type2>(&copied)) ||
264                TypeParam::kIndex == 2);
265    EXPECT_TRUE((absl::get_if<value_type3>(&original) ==
266                 absl::get_if<value_type3>(&copied)) ||
267                TypeParam::kIndex == 3);
268    EXPECT_TRUE((absl::get_if<value_type4>(&original) ==
269                 absl::get_if<value_type4>(&copied)) ||
270                TypeParam::kIndex == 4);
271    const TypeParam* ovalptr = absl::get_if<TypeParam>(&original);
272    const TypeParam* cvalptr = absl::get_if<TypeParam>(&copied);
273    ASSERT_TRUE(ovalptr != nullptr);
274    ASSERT_TRUE(cvalptr != nullptr);
275    EXPECT_EQ(*ovalptr, *cvalptr);
276    TypeParam* mutable_ovalptr = absl::get_if<TypeParam>(&original);
277    TypeParam* mutable_cvalptr = absl::get_if<TypeParam>(&copied);
278    ASSERT_TRUE(mutable_ovalptr != nullptr);
279    ASSERT_TRUE(mutable_cvalptr != nullptr);
280    EXPECT_EQ(*mutable_ovalptr, *mutable_cvalptr);
281  }
282  template <class>
283  struct MoveOnly {
284    MoveOnly() = default;
285    explicit MoveOnly(int value) : value(value) {}
286    MoveOnly(MoveOnly&&) = default;
287    MoveOnly& operator=(MoveOnly&&) = default;
288    int value = 5;
289  };
290  TEST(VariantTest, TestMoveConstruct) {
291    using V = variant<MoveOnly<class A>, MoveOnly<class B>, MoveOnly<class C>>;
292    V v(in_place_index<1>, 10);
293    V v2 = absl::move(v);
294    EXPECT_EQ(10, absl::get<1>(v2).value);
295  }
296  template <class T>
297  union SingleUnion {
298    T member;
299  };
300  template <class T>
301  struct is_trivially_move_constructible
302      : std::is_move_constructible<SingleUnion<T>>::type {};
303  template <class T>
304  struct is_trivially_move_assignable
305      : absl::is_move_assignable<SingleUnion<T>>::type {};
306  TEST(VariantTest, NothrowMoveConstructible) {
307    using U = std::unique_ptr<int>;
308    struct E {
309      E(E&&) {}
310    };
311    static_assert(std::is_nothrow_move_constructible<variant<U>>::value, "");
312    static_assert(std::is_nothrow_move_constructible<variant<U, int>>::value, "");
313    static_assert(!std::is_nothrow_move_constructible<variant<U, E>>::value, "");
314  }
315  TYPED_TEST(VariantTypesTest, TestValueCtor) {
316    typedef typename VariantFactory<typename TypeParam::value_type>::Type Variant;
317    using value_type1 = absl::variant_alternative_t<0, Variant>;
318    using value_type2 = absl::variant_alternative_t<1, Variant>;
319    using value_type3 = absl::variant_alternative_t<2, Variant>;
320    using value_type4 = absl::variant_alternative_t<3, Variant>;
321    const TypeParam value(TypeParam::kIndex);
322    Variant v(value);
323    EXPECT_TRUE(absl::holds_alternative<value_type1>(v) ||
324                TypeParam::kIndex != 1);
325    EXPECT_TRUE(absl::holds_alternative<value_type2>(v) ||
326                TypeParam::kIndex != 2);
327    EXPECT_TRUE(absl::holds_alternative<value_type3>(v) ||
328                TypeParam::kIndex != 3);
329    EXPECT_TRUE(absl::holds_alternative<value_type4>(v) ||
330                TypeParam::kIndex != 4);
331    EXPECT_TRUE(nullptr != absl::get_if<value_type1>(&v) ||
332                TypeParam::kIndex != 1);
333    EXPECT_TRUE(nullptr != absl::get_if<value_type2>(&v) ||
334                TypeParam::kIndex != 2);
335    EXPECT_TRUE(nullptr != absl::get_if<value_type3>(&v) ||
336                TypeParam::kIndex != 3);
337    EXPECT_TRUE(nullptr != absl::get_if<value_type4>(&v) ||
338                TypeParam::kIndex != 4);
339    EXPECT_TRUE(nullptr != absl::get_if<value_type1>(&v) ||
340                TypeParam::kIndex != 1);
341    EXPECT_TRUE(nullptr != absl::get_if<value_type2>(&v) ||
342                TypeParam::kIndex != 2);
343    EXPECT_TRUE(nullptr != absl::get_if<value_type3>(&v) ||
344                TypeParam::kIndex != 3);
345    EXPECT_TRUE(nullptr != absl::get_if<value_type4>(&v) ||
346                TypeParam::kIndex != 4);
347    const TypeParam* valptr = absl::get_if<TypeParam>(&v);
348    ASSERT_TRUE(nullptr != valptr);
349    EXPECT_EQ(value.value, valptr->value);
350    const TypeParam* mutable_valptr = absl::get_if<TypeParam>(&v);
351    ASSERT_TRUE(nullptr != mutable_valptr);
352    EXPECT_EQ(value.value, mutable_valptr->value);
353  }
354  TEST(VariantTest, AmbiguousValueConstructor) {
355    EXPECT_FALSE((std::is_convertible<int, absl::variant<int, int>>::value));
356    EXPECT_FALSE((std::is_constructible<absl::variant<int, int>, int>::value));
357  }
358  TEST(VariantTest, InPlaceType) {
359    using Var = variant<int, std::string, NonCopyable, std::vector<int>>;
360    Var v1(in_place_type_t<int>(), 7);
361    ASSERT_TRUE(absl::holds_alternative<int>(v1));
362    EXPECT_EQ(7, absl::get<int>(v1));
363    Var v2(in_place_type_t<std::string>(), "ABC");
364    ASSERT_TRUE(absl::holds_alternative<std::string>(v2));
365    EXPECT_EQ("ABC", absl::get<std::string>(v2));
366    Var v3(in_place_type_t<std::string>(), "ABC", 2u);
367    ASSERT_TRUE(absl::holds_alternative<std::string>(v3));
368    EXPECT_EQ("AB", absl::get<std::string>(v3));
369    Var v4(in_place_type_t<NonCopyable>{});
370    ASSERT_TRUE(absl::holds_alternative<NonCopyable>(v4));
371    Var v5(in_place_type_t<std::vector<int>>(), {1, 2, 3});
372    ASSERT_TRUE(absl::holds_alternative<std::vector<int>>(v5));
373    EXPECT_THAT(absl::get<std::vector<int>>(v5), ::testing::ElementsAre(1, 2, 3));
374  }
375  TEST(VariantTest, InPlaceTypeVariableTemplate) {
376    using Var = variant<int, std::string, NonCopyable, std::vector<int>>;
377    Var v1(in_place_type<int>, 7);
378    ASSERT_TRUE(absl::holds_alternative<int>(v1));
379    EXPECT_EQ(7, absl::get<int>(v1));
380    Var v2(in_place_type<std::string>, "ABC");
381    ASSERT_TRUE(absl::holds_alternative<std::string>(v2));
382    EXPECT_EQ("ABC", absl::get<std::string>(v2));
383    Var v3(in_place_type<std::string>, "ABC", 2u);
384    ASSERT_TRUE(absl::holds_alternative<std::string>(v3));
385    EXPECT_EQ("AB", absl::get<std::string>(v3));
386    Var v4(in_place_type<NonCopyable>);
387    ASSERT_TRUE(absl::holds_alternative<NonCopyable>(v4));
388    Var v5(in_place_type<std::vector<int>>, {1, 2, 3});
389    ASSERT_TRUE(absl::holds_alternative<std::vector<int>>(v5));
390    EXPECT_THAT(absl::get<std::vector<int>>(v5), ::testing::ElementsAre(1, 2, 3));
391  }
392  TEST(VariantTest, InPlaceTypeInitializerList) {
393    using Var =
394        variant<int, std::string, NonCopyable, MoveOnlyWithListConstructor>;
395    Var v1(in_place_type_t<MoveOnlyWithListConstructor>(), {1, 2, 3, 4, 5}, 6);
396    ASSERT_TRUE(absl::holds_alternative<MoveOnlyWithListConstructor>(v1));
397    EXPECT_EQ(6, absl::get<MoveOnlyWithListConstructor>(v1).value);
398  }
399  TEST(VariantTest, InPlaceTypeInitializerListVariabletemplate) {
400    using Var =
401        variant<int, std::string, NonCopyable, MoveOnlyWithListConstructor>;
402    Var v1(in_place_type<MoveOnlyWithListConstructor>, {1, 2, 3, 4, 5}, 6);
403    ASSERT_TRUE(absl::holds_alternative<MoveOnlyWithListConstructor>(v1));
404    EXPECT_EQ(6, absl::get<MoveOnlyWithListConstructor>(v1).value);
405  }
406  TEST(VariantTest, InPlaceIndex) {
407    using Var = variant<int, std::string, NonCopyable, std::vector<int>>;
408    Var v1(in_place_index_t<0>(), 7);
409    ASSERT_TRUE(absl::holds_alternative<int>(v1));
410    EXPECT_EQ(7, absl::get<int>(v1));
411    Var v2(in_place_index_t<1>(), "ABC");
412    ASSERT_TRUE(absl::holds_alternative<std::string>(v2));
413    EXPECT_EQ("ABC", absl::get<std::string>(v2));
414    Var v3(in_place_index_t<1>(), "ABC", 2u);
415    ASSERT_TRUE(absl::holds_alternative<std::string>(v3));
416    EXPECT_EQ("AB", absl::get<std::string>(v3));
417    Var v4(in_place_index_t<2>{});
418    EXPECT_TRUE(absl::holds_alternative<NonCopyable>(v4));
419    EXPECT_TRUE(absl::holds_alternative<NonCopyable>(
420        variant<NonCopyable>(in_place_index_t<0>{})));
421    Var v5(in_place_index_t<3>(), {1, 2, 3});
422    ASSERT_TRUE(absl::holds_alternative<std::vector<int>>(v5));
423    EXPECT_THAT(absl::get<std::vector<int>>(v5), ::testing::ElementsAre(1, 2, 3));
424  }
425  TEST(VariantTest, InPlaceIndexVariableTemplate) {
426    using Var = variant<int, std::string, NonCopyable, std::vector<int>>;
427    Var v1(in_place_index<0>, 7);
428    ASSERT_TRUE(absl::holds_alternative<int>(v1));
429    EXPECT_EQ(7, absl::get<int>(v1));
430    Var v2(in_place_index<1>, "ABC");
431    ASSERT_TRUE(absl::holds_alternative<std::string>(v2));
432    EXPECT_EQ("ABC", absl::get<std::string>(v2));
433    Var v3(in_place_index<1>, "ABC", 2u);
434    ASSERT_TRUE(absl::holds_alternative<std::string>(v3));
435    EXPECT_EQ("AB", absl::get<std::string>(v3));
436    Var v4(in_place_index<2>);
437    EXPECT_TRUE(absl::holds_alternative<NonCopyable>(v4));
438    EXPECT_TRUE(absl::holds_alternative<NonCopyable>(
439        variant<NonCopyable>(in_place_index<0>)));
440    Var v5(in_place_index<3>, {1, 2, 3});
441    ASSERT_TRUE(absl::holds_alternative<std::vector<int>>(v5));
442    EXPECT_THAT(absl::get<std::vector<int>>(v5), ::testing::ElementsAre(1, 2, 3));
443  }
444  TEST(VariantTest, InPlaceIndexInitializerList) {
445    using Var =
446        variant<int, std::string, NonCopyable, MoveOnlyWithListConstructor>;
447    Var v1(in_place_index_t<3>(), {1, 2, 3, 4, 5}, 6);
448    ASSERT_TRUE(absl::holds_alternative<MoveOnlyWithListConstructor>(v1));
449    EXPECT_EQ(6, absl::get<MoveOnlyWithListConstructor>(v1).value);
450  }
451  TEST(VariantTest, InPlaceIndexInitializerListVariableTemplate) {
452    using Var =
453        variant<int, std::string, NonCopyable, MoveOnlyWithListConstructor>;
454    Var v1(in_place_index<3>, {1, 2, 3, 4, 5}, 6);
455    ASSERT_TRUE(absl::holds_alternative<MoveOnlyWithListConstructor>(v1));
456    EXPECT_EQ(6, absl::get<MoveOnlyWithListConstructor>(v1).value);
457  }
458  TEST(VariantTest, TestDtor) {
459    typedef VariantFactory<IncrementInDtor>::Type Variant;
460    using value_type1 = absl::variant_alternative_t<0, Variant>;
461    using value_type2 = absl::variant_alternative_t<1, Variant>;
462    using value_type3 = absl::variant_alternative_t<2, Variant>;
463    using value_type4 = absl::variant_alternative_t<3, Variant>;
464    int counter = 0;
465    IncrementInDtor counter_adjuster(&counter);
466    EXPECT_EQ(0, counter);
467    value_type1 value1(counter_adjuster);
468    { Variant object(value1); }
469    EXPECT_EQ(1, counter);
470    value_type2 value2(counter_adjuster);
471    { Variant object(value2); }
472    EXPECT_EQ(2, counter);
473    value_type3 value3(counter_adjuster);
474    { Variant object(value3); }
475    EXPECT_EQ(3, counter);
476    value_type4 value4(counter_adjuster);
477    { Variant object(value4); }
478    EXPECT_EQ(4, counter);
479  }
480  #ifdef ABSL_HAVE_EXCEPTIONS
481  #if defined(ABSL_INTERNAL_MSVC_2017_DBG_MODE)
482  TEST(VariantTest, DISABLED_TestDtorValuelessByException)
483  #else
484  TEST(VariantTest, TestDtorValuelessByException)
485  #endif
486  {
487    int counter = 0;
488    IncrementInDtor counter_adjuster(&counter);
489    {
490      using Variant = VariantFactory<IncrementInDtor>::Type;
491      Variant v(in_place_index<0>, counter_adjuster);
492      EXPECT_EQ(0, counter);
493      ToValuelessByException(v);
494      ASSERT_TRUE(v.valueless_by_exception());
495      EXPECT_EQ(1, counter);
496    }
497    EXPECT_EQ(1, counter);
498  }
499  #endif  
500  TEST(VariantTest, TestSelfAssignment) {
501    typedef VariantFactory<IncrementInDtor>::Type Variant;
502    int counter = 0;
503    IncrementInDtor counter_adjuster(&counter);
504    absl::variant_alternative_t<0, Variant> value(counter_adjuster);
505    Variant object(value);
506    object.operator=(object);
507    EXPECT_EQ(0, counter);
508    const std::string long_str(128, 'a');
509    std::string foo = long_str;
510    foo = *&foo;
511    EXPECT_EQ(long_str, foo);
512    variant<int, std::string> so = long_str;
513    ASSERT_EQ(1u, so.index());
514    EXPECT_EQ(long_str, absl::get<1>(so));
515    so = *&so;
516    ASSERT_EQ(1u, so.index());
517    EXPECT_EQ(long_str, absl::get<1>(so));
518  }
519  TYPED_TEST(VariantTypesTest, TestAssignmentCopiesValueSameTypes) {
520    typedef typename VariantFactory<typename TypeParam::value_type>::Type Variant;
521    const TypeParam value(TypeParam::kIndex);
522    const Variant source(value);
523    Variant target(TypeParam(value.value + 1));
524    ASSERT_TRUE(absl::holds_alternative<TypeParam>(source));
525    ASSERT_TRUE(absl::holds_alternative<TypeParam>(target));
526    ASSERT_NE(absl::get<TypeParam>(source), absl::get<TypeParam>(target));
527    target = source;
528    ASSERT_TRUE(absl::holds_alternative<TypeParam>(source));
529    ASSERT_TRUE(absl::holds_alternative<TypeParam>(target));
530    EXPECT_EQ(absl::get<TypeParam>(source), absl::get<TypeParam>(target));
531  }
532  TYPED_TEST(VariantTypesTest, TestAssignmentCopiesValuesVaryingSourceType) {
533    typedef typename VariantFactory<typename TypeParam::value_type>::Type Variant;
534    using value_type1 = absl::variant_alternative_t<0, Variant>;
535    const TypeParam value(TypeParam::kIndex);
536    const Variant source(value);
537    ASSERT_TRUE(absl::holds_alternative<TypeParam>(source));
538    Variant target(value_type1(1));
539    ASSERT_TRUE(absl::holds_alternative<value_type1>(target));
540    target = source;
541    EXPECT_TRUE(absl::holds_alternative<TypeParam>(source));
542    EXPECT_TRUE(absl::holds_alternative<TypeParam>(target));
543    EXPECT_EQ(absl::get<TypeParam>(source), absl::get<TypeParam>(target));
544  }
545  TYPED_TEST(VariantTypesTest, TestAssignmentCopiesValuesVaryingTargetType) {
546    typedef typename VariantFactory<typename TypeParam::value_type>::Type Variant;
547    using value_type1 = absl::variant_alternative_t<0, Variant>;
548    const Variant source(value_type1(1));
549    ASSERT_TRUE(absl::holds_alternative<value_type1>(source));
550    const TypeParam value(TypeParam::kIndex);
551    Variant target(value);
552    ASSERT_TRUE(absl::holds_alternative<TypeParam>(target));
553    target = source;
554    EXPECT_TRUE(absl::holds_alternative<value_type1>(target));
555    EXPECT_TRUE(absl::holds_alternative<value_type1>(source));
556    EXPECT_EQ(absl::get<value_type1>(source), absl::get<value_type1>(target));
557  }
558  TEST(VariantTest, TestAssign) {
559    typedef VariantFactory<IncrementInDtor>::Type Variant;
560    using value_type1 = absl::variant_alternative_t<0, Variant>;
561    using value_type2 = absl::variant_alternative_t<1, Variant>;
562    using value_type3 = absl::variant_alternative_t<2, Variant>;
563    using value_type4 = absl::variant_alternative_t<3, Variant>;
564    const int kSize = 4;
565    int counter[kSize];
566    std::unique_ptr<IncrementInDtor> counter_adjustor[kSize];
567    for (int i = 0; i != kSize; i++) {
568      counter[i] = 0;
569      counter_adjustor[i] = absl::make_unique<IncrementInDtor>(&counter[i]);
570    }
571    value_type1 v1(*counter_adjustor[0]);
572    value_type2 v2(*counter_adjustor[1]);
573    value_type3 v3(*counter_adjustor[2]);
574    value_type4 v4(*counter_adjustor[3]);
575    {
576      Variant object(v1);
577      object = v2;
578      object = v3;
579      object = v4;
580      object = v1;
581    }
582    EXPECT_EQ(2, counter[0]);
583    EXPECT_EQ(1, counter[1]);
584    EXPECT_EQ(1, counter[2]);
585    EXPECT_EQ(1, counter[3]);
586    std::fill(std::begin(counter), std::end(counter), 0);
587    {
588      Variant object(v1);
589      object.operator=(object);
590      EXPECT_EQ(0, counter[0]);
591    }
592    {
593      Variant object(v2);
594      object.operator=(object);
595      EXPECT_EQ(0, counter[1]);
596    }
597    {
598      Variant object(v3);
599      object.operator=(object);
600      EXPECT_EQ(0, counter[2]);
601    }
602    {
603      Variant object(v4);
604      object.operator=(object);
605      EXPECT_EQ(0, counter[3]);
606    }
607    EXPECT_EQ(1, counter[0]);
608    EXPECT_EQ(1, counter[1]);
609    EXPECT_EQ(1, counter[2]);
610    EXPECT_EQ(1, counter[3]);
611  }
612  TEST(VariantTest, TestBackupAssign) {
613    typedef VariantFactory<IncrementInDtorCopyCanThrow>::Type Variant;
614    using value_type1 = absl::variant_alternative_t<0, Variant>;
615    using value_type2 = absl::variant_alternative_t<1, Variant>;
616    using value_type3 = absl::variant_alternative_t<2, Variant>;
617    using value_type4 = absl::variant_alternative_t<3, Variant>;
618    const int kSize = 4;
619    int counter[kSize];
620    std::unique_ptr<IncrementInDtorCopyCanThrow> counter_adjustor[kSize];
621    for (int i = 0; i != kSize; i++) {
622      counter[i] = 0;
623      counter_adjustor[i].reset(new IncrementInDtorCopyCanThrow(&counter[i]));
624    }
625    value_type1 v1(*counter_adjustor[0]);
626    value_type2 v2(*counter_adjustor[1]);
627    value_type3 v3(*counter_adjustor[2]);
628    value_type4 v4(*counter_adjustor[3]);
629    {
630      Variant object(v1);
631      object = v2;
632      object = v3;
633      object = v4;
634      object = v1;
635    }
636  #if !(defined(ABSL_USES_STD_VARIANT) && defined(__GLIBCXX__))
637    EXPECT_EQ(3, counter[0]);
638    EXPECT_EQ(2, counter[1]);
639    EXPECT_EQ(2, counter[2]);
640    EXPECT_EQ(2, counter[3]);
641  #endif
642    std::fill(std::begin(counter), std::end(counter), 0);
643    {
644      Variant object(v1);
645      object.operator=(object);
646      EXPECT_EQ(0, counter[0]);
647    }
648    {
649      Variant object(v2);
650      object.operator=(object);
651      EXPECT_EQ(0, counter[1]);
652    }
653    {
654      Variant object(v3);
655      object.operator=(object);
656      EXPECT_EQ(0, counter[2]);
657    }
658    {
659      Variant object(v4);
660      object.operator=(object);
661      EXPECT_EQ(0, counter[3]);
662    }
663    EXPECT_EQ(1, counter[0]);
664    EXPECT_EQ(1, counter[1]);
665    EXPECT_EQ(1, counter[2]);
666    EXPECT_EQ(1, counter[3]);
667  }
668  TEST(VariantTest, TestEmplaceBasic) {
669    using Variant = variant<int, char>;
670    Variant v(absl::in_place_index<0>, 0);
671    {
672      char& emplace_result = v.emplace<char>();
673      ASSERT_TRUE(absl::holds_alternative<char>(v));
674      EXPECT_EQ(absl::get<char>(v), 0);
675      EXPECT_EQ(&emplace_result, &absl::get<char>(v));
676    }
677    absl::get<char>(v) = 'a';
678    v.emplace<char>('b');
679    ASSERT_TRUE(absl::holds_alternative<char>(v));
680    EXPECT_EQ(absl::get<char>(v), 'b');
681    {
682      int& emplace_result = v.emplace<int>();
683      EXPECT_TRUE(absl::holds_alternative<int>(v));
684      EXPECT_EQ(absl::get<int>(v), 0);
685      EXPECT_EQ(&emplace_result, &absl::get<int>(v));
686    }
687  }
688  TEST(VariantTest, TestEmplaceInitializerList) {
689    using Var =
690        variant<int, std::string, NonCopyable, MoveOnlyWithListConstructor>;
691    Var v1(absl::in_place_index<0>, 555);
692    MoveOnlyWithListConstructor& emplace_result =
693        v1.emplace<MoveOnlyWithListConstructor>({1, 2, 3, 4, 5}, 6);
694    ASSERT_TRUE(absl::holds_alternative<MoveOnlyWithListConstructor>(v1));
695    EXPECT_EQ(6, absl::get<MoveOnlyWithListConstructor>(v1).value);
696    EXPECT_EQ(&emplace_result, &absl::get<MoveOnlyWithListConstructor>(v1));
697  }
698  TEST(VariantTest, TestEmplaceIndex) {
699    using Variant = variant<int, char>;
700    Variant v(absl::in_place_index<0>, 555);
701    {
702      char& emplace_result = v.emplace<1>();
703      ASSERT_TRUE(absl::holds_alternative<char>(v));
704      EXPECT_EQ(absl::get<char>(v), 0);
705      EXPECT_EQ(&emplace_result, &absl::get<char>(v));
706    }
707    absl::get<char>(v) = 'a';
708    v.emplace<1>('b');
709    ASSERT_TRUE(absl::holds_alternative<char>(v));
710    EXPECT_EQ(absl::get<char>(v), 'b');
711    {
712      int& emplace_result = v.emplace<0>();
713      EXPECT_TRUE(absl::holds_alternative<int>(v));
714      EXPECT_EQ(absl::get<int>(v), 0);
715      EXPECT_EQ(&emplace_result, &absl::get<int>(v));
716    }
717  }
718  TEST(VariantTest, TestEmplaceIndexInitializerList) {
719    using Var =
720        variant<int, std::string, NonCopyable, MoveOnlyWithListConstructor>;
721    Var v1(absl::in_place_index<0>, 555);
722    MoveOnlyWithListConstructor& emplace_result =
723        v1.emplace<3>({1, 2, 3, 4, 5}, 6);
724    ASSERT_TRUE(absl::holds_alternative<MoveOnlyWithListConstructor>(v1));
725    EXPECT_EQ(6, absl::get<MoveOnlyWithListConstructor>(v1).value);
726    EXPECT_EQ(&emplace_result, &absl::get<MoveOnlyWithListConstructor>(v1));
727  }
728  TEST(VariantTest, Index) {
729    using Var = variant<int, std::string, double>;
730    Var v = 1;
731    EXPECT_EQ(0u, v.index());
732    v = "str";
733    EXPECT_EQ(1u, v.index());
734    v = 0.;
735    EXPECT_EQ(2u, v.index());
736    Var v2 = v;
737    EXPECT_EQ(2u, v2.index());
738    v2.emplace<int>(3);
739    EXPECT_EQ(0u, v2.index());
740  }
741  TEST(VariantTest, NotValuelessByException) {
742    using Var = variant<int, std::string, double>;
743    Var v = 1;
744    EXPECT_FALSE(v.valueless_by_exception());
745    v = "str";
746    EXPECT_FALSE(v.valueless_by_exception());
747    v = 0.;
748    EXPECT_FALSE(v.valueless_by_exception());
749    Var v2 = v;
750    EXPECT_FALSE(v.valueless_by_exception());
751    v2.emplace<int>(3);
752    EXPECT_FALSE(v.valueless_by_exception());
753  }
754  #ifdef ABSL_HAVE_EXCEPTIONS
755  TEST(VariantTest, IndexValuelessByException) {
756    using Var = variant<MoveCanThrow, std::string, double>;
757    Var v(absl::in_place_index<0>);
758    EXPECT_EQ(0u, v.index());
759    ToValuelessByException(v);
760    EXPECT_EQ(absl::variant_npos, v.index());
761    v = "str";
762    EXPECT_EQ(1u, v.index());
763  }
764  TEST(VariantTest, ValuelessByException) {
765    using Var = variant<MoveCanThrow, std::string, double>;
766    Var v(absl::in_place_index<0>);
767    EXPECT_FALSE(v.valueless_by_exception());
768    ToValuelessByException(v);
769    EXPECT_TRUE(v.valueless_by_exception());
770    v = "str";
771    EXPECT_FALSE(v.valueless_by_exception());
772  }
773  #endif  
774  TEST(VariantTest, MemberSwap) {
775    SpecialSwap v1(3);
776    SpecialSwap v2(7);
777    variant<SpecialSwap> a = v1, b = v2;
778    EXPECT_THAT(a, VariantWith<SpecialSwap>(v1));
779    EXPECT_THAT(b, VariantWith<SpecialSwap>(v2));
780    a.swap(b);
781    EXPECT_THAT(a, VariantWith<SpecialSwap>(v2));
782    EXPECT_THAT(b, VariantWith<SpecialSwap>(v1));
783    EXPECT_TRUE(absl::get<SpecialSwap>(a).special_swap);
784    using V = variant<MoveCanThrow, std::string, int>;
785    int i = 33;
786    std::string s = "abc";
787    {
788      V lhs(i), rhs(s);
789      lhs.swap(rhs);
790      EXPECT_THAT(lhs, VariantWith<std::string>(s));
791      EXPECT_THAT(rhs, VariantWith<int>(i));
792    }
793  #ifdef ABSL_HAVE_EXCEPTIONS
794    V valueless(in_place_index<0>);
795    ToValuelessByException(valueless);
796    {
797      V lhs(valueless), rhs(i);
798      lhs.swap(rhs);
799      EXPECT_THAT(lhs, VariantWith<int>(i));
800      EXPECT_TRUE(rhs.valueless_by_exception());
801    }
802    {
803      V lhs(s), rhs(valueless);
804      lhs.swap(rhs);
805      EXPECT_THAT(rhs, VariantWith<std::string>(s));
806      EXPECT_TRUE(lhs.valueless_by_exception());
807    }
808    {
809      V lhs(valueless), rhs(valueless);
810      lhs.swap(rhs);
811      EXPECT_TRUE(lhs.valueless_by_exception());
812      EXPECT_TRUE(rhs.valueless_by_exception());
813    }
814  #endif  
815  }
816  TEST(VariantTest, VariantSize) {
817    {
818      using Size1Variant = absl::variant<int>;
819      EXPECT_EQ(1u, absl::variant_size<Size1Variant>::value);
820      EXPECT_EQ(1u, absl::variant_size<const Size1Variant>::value);
821      EXPECT_EQ(1u, absl::variant_size<volatile Size1Variant>::value);
822      EXPECT_EQ(1u, absl::variant_size<const volatile Size1Variant>::value);
823    }
824    {
825      using Size3Variant = absl::variant<int, float, int>;
826      EXPECT_EQ(3u, absl::variant_size<Size3Variant>::value);
827      EXPECT_EQ(3u, absl::variant_size<const Size3Variant>::value);
828      EXPECT_EQ(3u, absl::variant_size<volatile Size3Variant>::value);
829      EXPECT_EQ(3u, absl::variant_size<const volatile Size3Variant>::value);
830    }
831  }
832  TEST(VariantTest, VariantAlternative) {
833    {
834      using V = absl::variant<float, int, const char*>;
835      EXPECT_TRUE(
836          (std::is_same<float, absl::variant_alternative_t<0, V>>::value));
837      EXPECT_TRUE((std::is_same<const float,
838                                absl::variant_alternative_t<0, const V>>::value));
839      EXPECT_TRUE(
840          (std::is_same<volatile float,
841                        absl::variant_alternative_t<0, volatile V>>::value));
842      EXPECT_TRUE((
843          std::is_same<const volatile float,
844                       absl::variant_alternative_t<0, const volatile V>>::value));
845      EXPECT_TRUE((std::is_same<int, absl::variant_alternative_t<1, V>>::value));
846      EXPECT_TRUE((std::is_same<const int,
847                                absl::variant_alternative_t<1, const V>>::value));
848      EXPECT_TRUE(
849          (std::is_same<volatile int,
850                        absl::variant_alternative_t<1, volatile V>>::value));
851      EXPECT_TRUE((
852          std::is_same<const volatile int,
853                       absl::variant_alternative_t<1, const volatile V>>::value));
854      EXPECT_TRUE(
855          (std::is_same<const char*, absl::variant_alternative_t<2, V>>::value));
856      EXPECT_TRUE((std::is_same<const char* const,
857                                absl::variant_alternative_t<2, const V>>::value));
858      EXPECT_TRUE(
859          (std::is_same<const char* volatile,
860                        absl::variant_alternative_t<2, volatile V>>::value));
861      EXPECT_TRUE((
862          std::is_same<const char* const volatile,
863                       absl::variant_alternative_t<2, const volatile V>>::value));
864    }
865    {
866      using V = absl::variant<float, volatile int, const char*>;
867      EXPECT_TRUE(
868          (std::is_same<float, absl::variant_alternative_t<0, V>>::value));
869      EXPECT_TRUE((std::is_same<const float,
870                                absl::variant_alternative_t<0, const V>>::value));
871      EXPECT_TRUE(
872          (std::is_same<volatile float,
873                        absl::variant_alternative_t<0, volatile V>>::value));
874      EXPECT_TRUE((
875          std::is_same<const volatile float,
876                       absl::variant_alternative_t<0, const volatile V>>::value));
877      EXPECT_TRUE(
878          (std::is_same<volatile int, absl::variant_alternative_t<1, V>>::value));
879      EXPECT_TRUE((std::is_same<const volatile int,
880                                absl::variant_alternative_t<1, const V>>::value));
881      EXPECT_TRUE(
882          (std::is_same<volatile int,
883                        absl::variant_alternative_t<1, volatile V>>::value));
884      EXPECT_TRUE((
885          std::is_same<const volatile int,
886                       absl::variant_alternative_t<1, const volatile V>>::value));
887      EXPECT_TRUE(
888          (std::is_same<const char*, absl::variant_alternative_t<2, V>>::value));
889      EXPECT_TRUE((std::is_same<const char* const,
890                                absl::variant_alternative_t<2, const V>>::value));
891      EXPECT_TRUE(
892          (std::is_same<const char* volatile,
893                        absl::variant_alternative_t<2, volatile V>>::value));
894      EXPECT_TRUE((
895          std::is_same<const char* const volatile,
896                       absl::variant_alternative_t<2, const volatile V>>::value));
897    }
898  }
899  TEST(VariantTest, HoldsAlternative) {
900    using Var = variant<int, std::string, double>;
901    Var v = 1;
902    EXPECT_TRUE(absl::holds_alternative<int>(v));
903    EXPECT_FALSE(absl::holds_alternative<std::string>(v));
904    EXPECT_FALSE(absl::holds_alternative<double>(v));
905    v = "str";
906    EXPECT_FALSE(absl::holds_alternative<int>(v));
907    EXPECT_TRUE(absl::holds_alternative<std::string>(v));
908    EXPECT_FALSE(absl::holds_alternative<double>(v));
909    v = 0.;
910    EXPECT_FALSE(absl::holds_alternative<int>(v));
911    EXPECT_FALSE(absl::holds_alternative<std::string>(v));
912    EXPECT_TRUE(absl::holds_alternative<double>(v));
913    Var v2 = v;
914    EXPECT_FALSE(absl::holds_alternative<int>(v2));
915    EXPECT_FALSE(absl::holds_alternative<std::string>(v2));
916    EXPECT_TRUE(absl::holds_alternative<double>(v2));
917    v2.emplace<int>(3);
918    EXPECT_TRUE(absl::holds_alternative<int>(v2));
919    EXPECT_FALSE(absl::holds_alternative<std::string>(v2));
920    EXPECT_FALSE(absl::holds_alternative<double>(v2));
921  }
922  TEST(VariantTest, GetIndex) {
923    using Var = variant<int, std::string, double, int>;
924    {
925      Var v(absl::in_place_index<0>, 0);
926      using LValueGetType = decltype(absl::get<0>(v));
927      using RValueGetType = decltype(absl::get<0>(absl::move(v)));
928      EXPECT_TRUE((std::is_same<LValueGetType, int&>::value));
929      EXPECT_TRUE((std::is_same<RValueGetType, int&&>::value));
930      EXPECT_EQ(absl::get<0>(v), 0);
931      EXPECT_EQ(absl::get<0>(absl::move(v)), 0);
932      const Var& const_v = v;
933      using ConstLValueGetType = decltype(absl::get<0>(const_v));
934      using ConstRValueGetType = decltype(absl::get<0>(absl::move(const_v)));
935      EXPECT_TRUE((std::is_same<ConstLValueGetType, const int&>::value));
936      EXPECT_TRUE((std::is_same<ConstRValueGetType, const int&&>::value));
937      EXPECT_EQ(absl::get<0>(const_v), 0);
938      EXPECT_EQ(absl::get<0>(absl::move(const_v)), 0);
939    }
940    {
941      Var v = std::string("Hello");
942      using LValueGetType = decltype(absl::get<1>(v));
943      using RValueGetType = decltype(absl::get<1>(absl::move(v)));
944      EXPECT_TRUE((std::is_same<LValueGetType, std::string&>::value));
945      EXPECT_TRUE((std::is_same<RValueGetType, std::string&&>::value));
946      EXPECT_EQ(absl::get<1>(v), "Hello");
947      EXPECT_EQ(absl::get<1>(absl::move(v)), "Hello");
948      const Var& const_v = v;
949      using ConstLValueGetType = decltype(absl::get<1>(const_v));
950      using ConstRValueGetType = decltype(absl::get<1>(absl::move(const_v)));
951      EXPECT_TRUE((std::is_same<ConstLValueGetType, const std::string&>::value));
952      EXPECT_TRUE((std::is_same<ConstRValueGetType, const std::string&&>::value));
953      EXPECT_EQ(absl::get<1>(const_v), "Hello");
954      EXPECT_EQ(absl::get<1>(absl::move(const_v)), "Hello");
955    }
956    {
957      Var v = 2.0;
958      using LValueGetType = decltype(absl::get<2>(v));
959      using RValueGetType = decltype(absl::get<2>(absl::move(v)));
960      EXPECT_TRUE((std::is_same<LValueGetType, double&>::value));
961      EXPECT_TRUE((std::is_same<RValueGetType, double&&>::value));
962      EXPECT_EQ(absl::get<2>(v), 2.);
963      EXPECT_EQ(absl::get<2>(absl::move(v)), 2.);
964      const Var& const_v = v;
965      using ConstLValueGetType = decltype(absl::get<2>(const_v));
966      using ConstRValueGetType = decltype(absl::get<2>(absl::move(const_v)));
967      EXPECT_TRUE((std::is_same<ConstLValueGetType, const double&>::value));
968      EXPECT_TRUE((std::is_same<ConstRValueGetType, const double&&>::value));
969      EXPECT_EQ(absl::get<2>(const_v), 2.);
970      EXPECT_EQ(absl::get<2>(absl::move(const_v)), 2.);
971    }
972    {
973      Var v(absl::in_place_index<0>, 0);
974      v.emplace<3>(1);
975      using LValueGetType = decltype(absl::get<3>(v));
976      using RValueGetType = decltype(absl::get<3>(absl::move(v)));
977      EXPECT_TRUE((std::is_same<LValueGetType, int&>::value));
978      EXPECT_TRUE((std::is_same<RValueGetType, int&&>::value));
979      EXPECT_EQ(absl::get<3>(v), 1);
980      EXPECT_EQ(absl::get<3>(absl::move(v)), 1);
981      const Var& const_v = v;
982      using ConstLValueGetType = decltype(absl::get<3>(const_v));
983      using ConstRValueGetType = decltype(absl::get<3>(absl::move(const_v)));
984      EXPECT_TRUE((std::is_same<ConstLValueGetType, const int&>::value));
985      EXPECT_TRUE((std::is_same<ConstRValueGetType, const int&&>::value));
986      EXPECT_EQ(absl::get<3>(const_v), 1);
987      EXPECT_EQ(absl::get<3>(absl::move(const_v)), 1);  
988    }
989  }
990  TEST(VariantTest, BadGetIndex) {
991    using Var = variant<int, std::string, double>;
992    {
993      Var v = 1;
994      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(absl::get<1>(v));
995      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(absl::get<1>(std::move(v)));
996      const Var& const_v = v;
997      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(absl::get<1>(const_v));
998      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(
999          absl::get<1>(std::move(const_v)));  
1000    }
1001    {
1002      Var v = std::string("Hello");
1003      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(absl::get<0>(v));
1004      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(absl::get<0>(std::move(v)));
1005      const Var& const_v = v;
1006      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(absl::get<0>(const_v));
1007      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(
1008          absl::get<0>(std::move(const_v)));  
1009    }
1010  }
1011  TEST(VariantTest, GetType) {
1012    using Var = variant<int, std::string, double>;
1013    {
1014      Var v = 1;
1015      using LValueGetType = decltype(absl::get<int>(v));
1016      using RValueGetType = decltype(absl::get<int>(absl::move(v)));
1017      EXPECT_TRUE((std::is_same<LValueGetType, int&>::value));
1018      EXPECT_TRUE((std::is_same<RValueGetType, int&&>::value));
1019      EXPECT_EQ(absl::get<int>(v), 1);
1020      EXPECT_EQ(absl::get<int>(absl::move(v)), 1);
1021      const Var& const_v = v;
1022      using ConstLValueGetType = decltype(absl::get<int>(const_v));
1023      using ConstRValueGetType = decltype(absl::get<int>(absl::move(const_v)));
1024      EXPECT_TRUE((std::is_same<ConstLValueGetType, const int&>::value));
1025      EXPECT_TRUE((std::is_same<ConstRValueGetType, const int&&>::value));
1026      EXPECT_EQ(absl::get<int>(const_v), 1);
1027      EXPECT_EQ(absl::get<int>(absl::move(const_v)), 1);
1028    }
1029    {
1030      Var v = std::string("Hello");
1031      using LValueGetType = decltype(absl::get<1>(v));
1032      using RValueGetType = decltype(absl::get<1>(absl::move(v)));
1033      EXPECT_TRUE((std::is_same<LValueGetType, std::string&>::value));
1034      EXPECT_TRUE((std::is_same<RValueGetType, std::string&&>::value));
1035      EXPECT_EQ(absl::get<std::string>(v), "Hello");
1036      EXPECT_EQ(absl::get<std::string>(absl::move(v)), "Hello");
1037      const Var& const_v = v;
1038      using ConstLValueGetType = decltype(absl::get<1>(const_v));
1039      using ConstRValueGetType = decltype(absl::get<1>(absl::move(const_v)));
1040      EXPECT_TRUE((std::is_same<ConstLValueGetType, const std::string&>::value));
1041      EXPECT_TRUE((std::is_same<ConstRValueGetType, const std::string&&>::value));
1042      EXPECT_EQ(absl::get<std::string>(const_v), "Hello");
1043      EXPECT_EQ(absl::get<std::string>(absl::move(const_v)), "Hello");
1044    }
1045    {
1046      Var v = 2.0;
1047      using LValueGetType = decltype(absl::get<2>(v));
1048      using RValueGetType = decltype(absl::get<2>(absl::move(v)));
1049      EXPECT_TRUE((std::is_same<LValueGetType, double&>::value));
1050      EXPECT_TRUE((std::is_same<RValueGetType, double&&>::value));
1051      EXPECT_EQ(absl::get<double>(v), 2.);
1052      EXPECT_EQ(absl::get<double>(absl::move(v)), 2.);
1053      const Var& const_v = v;
1054      using ConstLValueGetType = decltype(absl::get<2>(const_v));
1055      using ConstRValueGetType = decltype(absl::get<2>(absl::move(const_v)));
1056      EXPECT_TRUE((std::is_same<ConstLValueGetType, const double&>::value));
1057      EXPECT_TRUE((std::is_same<ConstRValueGetType, const double&&>::value));
1058      EXPECT_EQ(absl::get<double>(const_v), 2.);
1059      EXPECT_EQ(absl::get<double>(absl::move(const_v)), 2.);
1060    }
1061  }
1062  TEST(VariantTest, BadGetType) {
1063    using Var = variant<int, std::string, double>;
1064    {
1065      Var v = 1;
1066      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(absl::get<std::string>(v));
1067      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(
1068          absl::get<std::string>(std::move(v)));
1069      const Var& const_v = v;
1070      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(
1071          absl::get<std::string>(const_v));
1072      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(
1073          absl::get<std::string>(std::move(const_v)));  
1074    }
1075    {
1076      Var v = std::string("Hello");
1077      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(absl::get<int>(v));
1078      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(absl::get<int>(std::move(v)));
1079      const Var& const_v = v;
1080      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(absl::get<int>(const_v));
1081      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(
1082          absl::get<int>(std::move(const_v)));  
1083    }
1084  }
1085  TEST(VariantTest, GetIfIndex) {
1086    using Var = variant<int, std::string, double, int>;
1087    {
1088      Var v(absl::in_place_index<0>, 0);
1089      EXPECT_TRUE(noexcept(absl::get_if<0>(&v)));
1090      {
1091        auto* elem = absl::get_if<0>(&v);
1092        EXPECT_TRUE((std::is_same<decltype(elem), int*>::value));
1093        ASSERT_NE(elem, nullptr);
1094        EXPECT_EQ(*elem, 0);
1095        {
1096          auto* bad_elem = absl::get_if<1>(&v);
1097          EXPECT_TRUE((std::is_same<decltype(bad_elem), std::string*>::value));
1098          EXPECT_EQ(bad_elem, nullptr);
1099        }
1100        {
1101          auto* bad_elem = absl::get_if<2>(&v);
1102          EXPECT_TRUE((std::is_same<decltype(bad_elem), double*>::value));
1103          EXPECT_EQ(bad_elem, nullptr);
1104        }
1105        {
1106          auto* bad_elem = absl::get_if<3>(&v);
1107          EXPECT_TRUE((std::is_same<decltype(bad_elem), int*>::value));
1108          EXPECT_EQ(bad_elem, nullptr);
1109        }
1110      }
1111      const Var& const_v = v;
1112      EXPECT_TRUE(noexcept(absl::get_if<0>(&const_v)));
1113      {
1114        auto* elem = absl::get_if<0>(&const_v);
1115        EXPECT_TRUE((std::is_same<decltype(elem), const int*>::value));
1116        ASSERT_NE(elem, nullptr);
1117        EXPECT_EQ(*elem, 0);
1118        {
1119          auto* bad_elem = absl::get_if<1>(&const_v);
1120          EXPECT_TRUE(
1121              (std::is_same<decltype(bad_elem), const std::string*>::value));
1122          EXPECT_EQ(bad_elem, nullptr);
1123        }
1124        {
1125          auto* bad_elem = absl::get_if<2>(&const_v);
1126          EXPECT_TRUE((std::is_same<decltype(bad_elem), const double*>::value));
1127          EXPECT_EQ(bad_elem, nullptr);
1128        }
1129        {
1130          auto* bad_elem = absl::get_if<3>(&const_v);
1131          EXPECT_EQ(bad_elem, nullptr);
1132          EXPECT_TRUE((std::is_same<decltype(bad_elem), const int*>::value));
1133        }
1134      }
1135    }
1136    {
1137      Var v = std::string("Hello");
1138      EXPECT_TRUE(noexcept(absl::get_if<1>(&v)));
1139      {
1140        auto* elem = absl::get_if<1>(&v);
1141        EXPECT_TRUE((std::is_same<decltype(elem), std::string*>::value));
1142        ASSERT_NE(elem, nullptr);
1143        EXPECT_EQ(*elem, "Hello");
1144        {
1145          auto* bad_elem = absl::get_if<0>(&v);
1146          EXPECT_TRUE((std::is_same<decltype(bad_elem), int*>::value));
1147          EXPECT_EQ(bad_elem, nullptr);
1148        }
1149        {
1150          auto* bad_elem = absl::get_if<2>(&v);
1151          EXPECT_TRUE((std::is_same<decltype(bad_elem), double*>::value));
1152          EXPECT_EQ(bad_elem, nullptr);
1153        }
1154        {
1155          auto* bad_elem = absl::get_if<3>(&v);
1156          EXPECT_TRUE((std::is_same<decltype(bad_elem), int*>::value));
1157          EXPECT_EQ(bad_elem, nullptr);
1158        }
1159      }
1160      const Var& const_v = v;
1161      EXPECT_TRUE(noexcept(absl::get_if<1>(&const_v)));
1162      {
1163        auto* elem = absl::get_if<1>(&const_v);
1164        EXPECT_TRUE((std::is_same<decltype(elem), const std::string*>::value));
1165        ASSERT_NE(elem, nullptr);
1166        EXPECT_EQ(*elem, "Hello");
1167        {
1168          auto* bad_elem = absl::get_if<0>(&const_v);
1169          EXPECT_TRUE((std::is_same<decltype(bad_elem), const int*>::value));
1170          EXPECT_EQ(bad_elem, nullptr);
1171        }
1172        {
1173          auto* bad_elem = absl::get_if<2>(&const_v);
1174          EXPECT_TRUE((std::is_same<decltype(bad_elem), const double*>::value));
1175          EXPECT_EQ(bad_elem, nullptr);
1176        }
1177        {
1178          auto* bad_elem = absl::get_if<3>(&const_v);
1179          EXPECT_EQ(bad_elem, nullptr);
1180          EXPECT_TRUE((std::is_same<decltype(bad_elem), const int*>::value));
1181        }
1182      }
1183    }
1184    {
1185      Var v = 2.0;
1186      EXPECT_TRUE(noexcept(absl::get_if<2>(&v)));
1187      {
1188        auto* elem = absl::get_if<2>(&v);
1189        EXPECT_TRUE((std::is_same<decltype(elem), double*>::value));
1190        ASSERT_NE(elem, nullptr);
1191        EXPECT_EQ(*elem, 2.0);
1192        {
1193          auto* bad_elem = absl::get_if<0>(&v);
1194          EXPECT_TRUE((std::is_same<decltype(bad_elem), int*>::value));
1195          EXPECT_EQ(bad_elem, nullptr);
1196        }
1197        {
1198          auto* bad_elem = absl::get_if<1>(&v);
1199          EXPECT_TRUE((std::is_same<decltype(bad_elem), std::string*>::value));
1200          EXPECT_EQ(bad_elem, nullptr);
1201        }
1202        {
1203          auto* bad_elem = absl::get_if<3>(&v);
1204          EXPECT_TRUE((std::is_same<decltype(bad_elem), int*>::value));
1205          EXPECT_EQ(bad_elem, nullptr);
1206        }
1207      }
1208      const Var& const_v = v;
1209      EXPECT_TRUE(noexcept(absl::get_if<2>(&const_v)));
1210      {
1211        auto* elem = absl::get_if<2>(&const_v);
1212        EXPECT_TRUE((std::is_same<decltype(elem), const double*>::value));
1213        ASSERT_NE(elem, nullptr);
1214        EXPECT_EQ(*elem, 2.0);
1215        {
1216          auto* bad_elem = absl::get_if<0>(&const_v);
1217          EXPECT_TRUE((std::is_same<decltype(bad_elem), const int*>::value));
1218          EXPECT_EQ(bad_elem, nullptr);
1219        }
1220        {
1221          auto* bad_elem = absl::get_if<1>(&const_v);
1222          EXPECT_TRUE(
1223              (std::is_same<decltype(bad_elem), const std::string*>::value));
1224          EXPECT_EQ(bad_elem, nullptr);
1225        }
1226        {
1227          auto* bad_elem = absl::get_if<3>(&const_v);
1228          EXPECT_EQ(bad_elem, nullptr);
1229          EXPECT_TRUE((std::is_same<decltype(bad_elem), const int*>::value));
1230        }
1231      }
1232    }
1233    {
1234      Var v(absl::in_place_index<0>, 0);
1235      v.emplace<3>(1);
1236      EXPECT_TRUE(noexcept(absl::get_if<3>(&v)));
1237      {
1238        auto* elem = absl::get_if<3>(&v);
1239        EXPECT_TRUE((std::is_same<decltype(elem), int*>::value));
1240        ASSERT_NE(elem, nullptr);
1241        EXPECT_EQ(*elem, 1);
1242        {
1243          auto* bad_elem = absl::get_if<0>(&v);
1244          EXPECT_TRUE((std::is_same<decltype(bad_elem), int*>::value));
1245          EXPECT_EQ(bad_elem, nullptr);
1246        }
1247        {
1248          auto* bad_elem = absl::get_if<1>(&v);
1249          EXPECT_TRUE((std::is_same<decltype(bad_elem), std::string*>::value));
1250          EXPECT_EQ(bad_elem, nullptr);
1251        }
1252        {
1253          auto* bad_elem = absl::get_if<2>(&v);
1254          EXPECT_TRUE((std::is_same<decltype(bad_elem), double*>::value));
1255          EXPECT_EQ(bad_elem, nullptr);
1256        }
1257      }
1258      const Var& const_v = v;
1259      EXPECT_TRUE(noexcept(absl::get_if<3>(&const_v)));
1260      {
1261        auto* elem = absl::get_if<3>(&const_v);
1262        EXPECT_TRUE((std::is_same<decltype(elem), const int*>::value));
1263        ASSERT_NE(elem, nullptr);
1264        EXPECT_EQ(*elem, 1);
1265        {
1266          auto* bad_elem = absl::get_if<0>(&const_v);
1267          EXPECT_TRUE((std::is_same<decltype(bad_elem), const int*>::value));
1268          EXPECT_EQ(bad_elem, nullptr);
1269        }
1270        {
1271          auto* bad_elem = absl::get_if<1>(&const_v);
1272          EXPECT_TRUE(
1273              (std::is_same<decltype(bad_elem), const std::string*>::value));
1274          EXPECT_EQ(bad_elem, nullptr);
1275        }
1276        {
1277          auto* bad_elem = absl::get_if<2>(&const_v);
1278          EXPECT_EQ(bad_elem, nullptr);
1279          EXPECT_TRUE((std::is_same<decltype(bad_elem), const double*>::value));
1280        }
1281      }
1282    }
1283  }
1284  TEST(VariantTest, OperatorEquals) {
1285    variant<int, std::string> a(1), b(1);
1286    EXPECT_TRUE(a == b);
1287    EXPECT_TRUE(b == a);
1288    EXPECT_FALSE(a != b);
1289    EXPECT_FALSE(b != a);
1290    b = "str";
1291    EXPECT_FALSE(a == b);
1292    EXPECT_FALSE(b == a);
1293    EXPECT_TRUE(a != b);
1294    EXPECT_TRUE(b != a);
1295    b = 0;
1296    EXPECT_FALSE(a == b);
1297    EXPECT_FALSE(b == a);
1298    EXPECT_TRUE(a != b);
1299    EXPECT_TRUE(b != a);
1300    a = b = "foo";
1301    EXPECT_TRUE(a == b);
1302    EXPECT_TRUE(b == a);
1303    EXPECT_FALSE(a != b);
1304    EXPECT_FALSE(b != a);
1305    a = "bar";
1306    EXPECT_FALSE(a == b);
1307    EXPECT_FALSE(b == a);
1308    EXPECT_TRUE(a != b);
1309    EXPECT_TRUE(b != a);
1310  }
1311  TEST(VariantTest, OperatorRelational) {
1312    variant<int, std::string> a(1), b(1);
1313    EXPECT_FALSE(a < b);
1314    EXPECT_FALSE(b < a);
1315    EXPECT_FALSE(a > b);
1316    EXPECT_FALSE(b > a);
1317    EXPECT_TRUE(a <= b);
1318    EXPECT_TRUE(b <= a);
1319    EXPECT_TRUE(a >= b);
1320    EXPECT_TRUE(b >= a);
1321    b = "str";
1322    EXPECT_TRUE(a < b);
1323    EXPECT_FALSE(b < a);
1324    EXPECT_FALSE(a > b);
1325    EXPECT_TRUE(b > a);
1326    EXPECT_TRUE(a <= b);
1327    EXPECT_FALSE(b <= a);
1328    EXPECT_FALSE(a >= b);
1329    EXPECT_TRUE(b >= a);
1330    b = 0;
1331    EXPECT_FALSE(a < b);
1332    EXPECT_TRUE(b < a);
1333    EXPECT_TRUE(a > b);
1334    EXPECT_FALSE(b > a);
1335    EXPECT_FALSE(a <= b);
1336    EXPECT_TRUE(b <= a);
1337    EXPECT_TRUE(a >= b);
1338    EXPECT_FALSE(b >= a);
1339    a = b = "foo";
1340    EXPECT_FALSE(a < b);
1341    EXPECT_FALSE(b < a);
1342    EXPECT_FALSE(a > b);
1343    EXPECT_FALSE(b > a);
1344    EXPECT_TRUE(a <= b);
1345    EXPECT_TRUE(b <= a);
1346    EXPECT_TRUE(a >= b);
1347    EXPECT_TRUE(b >= a);
1348    a = "bar";
1349    EXPECT_TRUE(a < b);
1350    EXPECT_FALSE(b < a);
1351    EXPECT_FALSE(a > b);
1352    EXPECT_TRUE(b > a);
1353    EXPECT_TRUE(a <= b);
1354    EXPECT_FALSE(b <= a);
1355    EXPECT_FALSE(a >= b);
1356    EXPECT_TRUE(b >= a);
1357  }
1358  #ifdef ABSL_HAVE_EXCEPTIONS
1359  TEST(VariantTest, ValuelessOperatorEquals) {
1360    variant<MoveCanThrow, std::string> int_v(1), string_v("Hello"),
1361        valueless(absl::in_place_index<0>),
1362        other_valueless(absl::in_place_index<0>);
1363    ToValuelessByException(valueless);
1364    ToValuelessByException(other_valueless);
1365    EXPECT_TRUE(valueless == other_valueless);
1366    EXPECT_TRUE(other_valueless == valueless);
1367    EXPECT_FALSE(valueless == int_v);
1368    EXPECT_FALSE(valueless == string_v);
1369    EXPECT_FALSE(int_v == valueless);
1370    EXPECT_FALSE(string_v == valueless);
1371    EXPECT_FALSE(valueless != other_valueless);
1372    EXPECT_FALSE(other_valueless != valueless);
1373    EXPECT_TRUE(valueless != int_v);
1374    EXPECT_TRUE(valueless != string_v);
1375    EXPECT_TRUE(int_v != valueless);
1376    EXPECT_TRUE(string_v != valueless);
1377  }
1378  TEST(VariantTest, ValuelessOperatorRelational) {
1379    variant<MoveCanThrow, std::string> int_v(1), string_v("Hello"),
1380        valueless(absl::in_place_index<0>),
1381        other_valueless(absl::in_place_index<0>);
1382    ToValuelessByException(valueless);
1383    ToValuelessByException(other_valueless);
1384    EXPECT_FALSE(valueless < other_valueless);
1385    EXPECT_FALSE(other_valueless < valueless);
1386    EXPECT_TRUE(valueless < int_v);
1387    EXPECT_TRUE(valueless < string_v);
1388    EXPECT_FALSE(int_v < valueless);
1389    EXPECT_FALSE(string_v < valueless);
1390    EXPECT_TRUE(valueless <= other_valueless);
1391    EXPECT_TRUE(other_valueless <= valueless);
1392    EXPECT_TRUE(valueless <= int_v);
1393    EXPECT_TRUE(valueless <= string_v);
1394    EXPECT_FALSE(int_v <= valueless);
1395    EXPECT_FALSE(string_v <= valueless);
1396    EXPECT_TRUE(valueless >= other_valueless);
1397    EXPECT_TRUE(other_valueless >= valueless);
1398    EXPECT_FALSE(valueless >= int_v);
1399    EXPECT_FALSE(valueless >= string_v);
1400    EXPECT_TRUE(int_v >= valueless);
1401    EXPECT_TRUE(string_v >= valueless);
1402    EXPECT_FALSE(valueless > other_valueless);
1403    EXPECT_FALSE(other_valueless > valueless);
1404    EXPECT_FALSE(valueless > int_v);
1405    EXPECT_FALSE(valueless > string_v);
1406    EXPECT_TRUE(int_v > valueless);
1407    EXPECT_TRUE(string_v > valueless);
1408  }
1409  #endif
1410  template <typename T>
1411  struct ConvertTo {
1412    template <typename U>
1413    T operator()(const U& u) const {
1414      return u;
1415    }
1416  };
1417  TEST(VariantTest, VisitSimple) {
1418    variant<std::string, const char*> v = "A";
1419    std::string str = absl::visit(ConvertTo<std::string>{}, v);
1420    EXPECT_EQ("A", str);
1421    v = std::string("B");
1422    absl::string_view piece = absl::visit(ConvertTo<absl::string_view>{}, v);
1423    EXPECT_EQ("B", piece);
1424    struct StrLen {
1425      size_t operator()(const char* s) const { return strlen(s); }
1426      size_t operator()(const std::string& s) const { return s.size(); }
1427    };
1428    v = "SomeStr";
1429    EXPECT_EQ(7u, absl::visit(StrLen{}, v));
1430    v = std::string("VeryLargeThisTime");
1431    EXPECT_EQ(17u, absl::visit(StrLen{}, v));
1432  }
1433  TEST(VariantTest, VisitRValue) {
1434    variant<std::string> v = std::string("X");
1435    struct Visitor {
1436      bool operator()(const std::string&) const { return false; }
1437      bool operator()(std::string&&) const { return true; }  
1438      int operator()(const std::string&, const std::string&) const { return 0; }
1439      int operator()(const std::string&, std::string&&) const {
1440        return 1;
1441      }  
1442      int operator()(std::string&&, const std::string&) const {
1443        return 2;
1444      }                                                                 
1445      int operator()(std::string&&, std::string&&) const { return 3; }  
1446    };
1447    EXPECT_FALSE(absl::visit(Visitor{}, v));
1448    EXPECT_TRUE(absl::visit(Visitor{}, absl::move(v)));
1449    EXPECT_EQ(0, absl::visit(Visitor{}, v, v));
1450    EXPECT_EQ(1, absl::visit(Visitor{}, v, absl::move(v)));
1451    EXPECT_EQ(2, absl::visit(Visitor{}, absl::move(v), v));
1452    EXPECT_EQ(3, absl::visit(Visitor{}, absl::move(v), absl::move(v)));
1453  }
1454  TEST(VariantTest, VisitRValueVisitor) {
1455    variant<std::string> v = std::string("X");
1456    struct Visitor {
1457      bool operator()(const std::string&) const& { return false; }
1458      bool operator()(const std::string&) && { return true; }
1459    };
1460    Visitor visitor;
1461    EXPECT_FALSE(absl::visit(visitor, v));
1462    EXPECT_TRUE(absl::visit(Visitor{}, v));
1463  }
1464  TEST(VariantTest, VisitResultTypeDifferent) {
1465    variant<std::string> v = std::string("X");
1466    struct LValue_LValue {};
1467    struct RValue_LValue {};
1468    struct LValue_RValue {};
1469    struct RValue_RValue {};
1470    struct Visitor {
1471      LValue_LValue operator()(const std::string&) const& { return {}; }
1472      RValue_LValue operator()(std::string&&) const& { return {}; }  
1473      LValue_RValue operator()(const std::string&) && { return {}; }
1474      RValue_RValue operator()(std::string&&) && { return {}; }  
1475    } visitor;
1476    EXPECT_TRUE(
1477        (std::is_same<LValue_LValue, decltype(absl::visit(visitor, v))>::value));
1478    EXPECT_TRUE(
1479        (std::is_same<RValue_LValue,
1480                      decltype(absl::visit(visitor, absl::move(v)))>::value));
1481    EXPECT_TRUE((
1482        std::is_same<LValue_RValue, decltype(absl::visit(Visitor{}, v))>::value));
1483    EXPECT_TRUE(
1484        (std::is_same<RValue_RValue,
1485                      decltype(absl::visit(Visitor{}, absl::move(v)))>::value));
1486  }
1487  TEST(VariantTest, VisitVariadic) {
1488    using A = variant<int, std::string>;
1489    using B = variant<std::unique_ptr<int>, absl::string_view>;
1490    struct Visitor {
1491      std::pair<int, int> operator()(int a, std::unique_ptr<int> b) const {
1492        return {a, *b};
1493      }
1494      std::pair<int, int> operator()(absl::string_view a,
1495                                     std::unique_ptr<int> b) const {
1496        return {static_cast<int>(a.size()), static_cast<int>(*b)};
1497      }
1498      std::pair<int, int> operator()(int a, absl::string_view b) const {
1499        return {a, static_cast<int>(b.size())};
1500      }
1501      std::pair<int, int> operator()(absl::string_view a,
1502                                     absl::string_view b) const {
1503        return {static_cast<int>(a.size()), static_cast<int>(b.size())};
1504      }
1505    };
1506    EXPECT_THAT(absl::visit(Visitor(), A(1), B(std::unique_ptr<int>(new int(7)))),
1507                ::testing::Pair(1, 7));
1508    EXPECT_THAT(absl::visit(Visitor(), A(1), B(absl::string_view("ABC"))),
1509                ::testing::Pair(1, 3));
1510    EXPECT_THAT(absl::visit(Visitor(), A(std::string("BBBBB")),
1511                            B(std::unique_ptr<int>(new int(7)))),
1512                ::testing::Pair(5, 7));
1513    EXPECT_THAT(absl::visit(Visitor(), A(std::string("BBBBB")),
1514                            B(absl::string_view("ABC"))),
1515                ::testing::Pair(5, 3));
1516  }
1517  TEST(VariantTest, VisitNoArgs) {
1518    EXPECT_EQ(5, absl::visit([] { return 5; }));
1519  }
1520  struct ConstFunctor {
1521    int operator()(int a, int b) const { return a - b; }
1522  };
1523  struct MutableFunctor {
1524    int operator()(int a, int b) { return a - b; }
1525  };
1526  struct Class {
1527    int Method(int a, int b) { return a - b; }
1528    int ConstMethod(int a, int b) const { return a - b; }
1529    int member;
1530  };
1531  TEST(VariantTest, VisitReferenceWrapper) {
1532    ConstFunctor cf;
1533    MutableFunctor mf;
1534    absl::variant<int> three = 3;
1535    absl::variant<int> two = 2;
1536    EXPECT_EQ(1, absl::visit(std::cref(cf), three, two));
1537    EXPECT_EQ(1, absl::visit(std::ref(cf), three, two));
1538    EXPECT_EQ(1, absl::visit(std::ref(mf), three, two));
1539  }
1540  #if !(defined(ABSL_USES_STD_VARIANT) && defined(__GLIBCXX__))
1541  TEST(VariantTest, VisitMemberFunction) {
1542    absl::variant<std::unique_ptr<Class>> p(absl::make_unique<Class>());
1543    absl::variant<std::unique_ptr<const Class>> cp(
1544        absl::make_unique<const Class>());
1545    absl::variant<int> three = 3;
1546    absl::variant<int> two = 2;
1547    EXPECT_EQ(1, absl::visit(&Class::Method, p, three, two));
1548    EXPECT_EQ(1, absl::visit(&Class::ConstMethod, p, three, two));
1549    EXPECT_EQ(1, absl::visit(&Class::ConstMethod, cp, three, two));
1550  }
1551  TEST(VariantTest, VisitDataMember) {
1552    absl::variant<std::unique_ptr<Class>> p(absl::make_unique<Class>(Class{42}));
1553    absl::variant<std::unique_ptr<const Class>> cp(
1554        absl::make_unique<const Class>(Class{42}));
1555    EXPECT_EQ(42, absl::visit(&Class::member, p));
1556    absl::visit(&Class::member, p) = 5;
1557    EXPECT_EQ(5, absl::visit(&Class::member, p));
1558    EXPECT_EQ(42, absl::visit(&Class::member, cp));
1559  }
1560  #endif  
1561  TEST(VariantTest, MonostateBasic) {
1562    absl::monostate mono;
1563    (void)mono;
1564    EXPECT_TRUE(absl::is_trivially_default_constructible<absl::monostate>::value);
1565    EXPECT_TRUE(is_trivially_move_constructible<absl::monostate>::value);
1566    EXPECT_TRUE(absl::is_trivially_copy_constructible<absl::monostate>::value);
1567    EXPECT_TRUE(is_trivially_move_assignable<absl::monostate>::value);
1568    EXPECT_TRUE(absl::is_trivially_copy_assignable<absl::monostate>::value);
1569    EXPECT_TRUE(absl::is_trivially_destructible<absl::monostate>::value);
1570  }
1571  TEST(VariantTest, VariantMonostateDefaultConstruction) {
1572    absl::variant<absl::monostate, NonDefaultConstructible> var;
1573    EXPECT_EQ(var.index(), 0u);
1574  }
1575  TEST(VariantTest, MonostateComparisons) {
1576    absl::monostate lhs, rhs;
1577    EXPECT_EQ(lhs, lhs);
1578    EXPECT_EQ(lhs, rhs);
1579    EXPECT_FALSE(lhs != lhs);
1580    EXPECT_FALSE(lhs != rhs);
1581    EXPECT_FALSE(lhs < lhs);
1582    EXPECT_FALSE(lhs < rhs);
1583    EXPECT_FALSE(lhs > lhs);
1584    EXPECT_FALSE(lhs > rhs);
1585    EXPECT_LE(lhs, lhs);
1586    EXPECT_LE(lhs, rhs);
1587    EXPECT_GE(lhs, lhs);
1588    EXPECT_GE(lhs, rhs);
1589    EXPECT_TRUE(noexcept(std::declval<absl::monostate>() ==
1590                         std::declval<absl::monostate>()));
1591    EXPECT_TRUE(noexcept(std::declval<absl::monostate>() !=
1592                         std::declval<absl::monostate>()));
1593    EXPECT_TRUE(noexcept(std::declval<absl::monostate>() <
1594                         std::declval<absl::monostate>()));
1595    EXPECT_TRUE(noexcept(std::declval<absl::monostate>() >
1596                         std::declval<absl::monostate>()));
1597    EXPECT_TRUE(noexcept(std::declval<absl::monostate>() <=
1598                         std::declval<absl::monostate>()));
1599    EXPECT_TRUE(noexcept(std::declval<absl::monostate>() >=
1600                         std::declval<absl::monostate>()));
1601  }
1602  TEST(VariantTest, NonmemberSwap) {
1603    using std::swap;
1604    SpecialSwap v1(3);
1605    SpecialSwap v2(7);
1606    variant<SpecialSwap> a = v1, b = v2;
1607    EXPECT_THAT(a, VariantWith<SpecialSwap>(v1));
1608    EXPECT_THAT(b, VariantWith<SpecialSwap>(v2));
1609    std::swap(a, b);
1610    EXPECT_THAT(a, VariantWith<SpecialSwap>(v2));
1611    EXPECT_THAT(b, VariantWith<SpecialSwap>(v1));
1612  #ifndef ABSL_USES_STD_VARIANT
1613    EXPECT_FALSE(absl::get<SpecialSwap>(a).special_swap);
1614  #endif
1615    swap(a, b);
1616    EXPECT_THAT(a, VariantWith<SpecialSwap>(v1));
1617    EXPECT_THAT(b, VariantWith<SpecialSwap>(v2));
1618    EXPECT_TRUE(absl::get<SpecialSwap>(b).special_swap);
1619  }
1620  TEST(VariantTest, BadAccess) {
1621    EXPECT_TRUE(noexcept(absl::bad_variant_access()));
1622    absl::bad_variant_access exception_obj;
1623    std::exception* base = &exception_obj;
1624    (void)base;
1625  }
1626  TEST(VariantTest, MonostateHash) {
1627    absl::monostate mono, other_mono;
1628    std::hash<absl::monostate> const hasher{};
1629    static_assert(std::is_same<decltype(hasher(mono)), std::size_t>::value, "");
1630    EXPECT_EQ(hasher(mono), hasher(other_mono));
1631  }
1632  TEST(VariantTest, Hash) {
1633    static_assert(type_traits_internal::IsHashable<variant<int>>::value, "");
1634    static_assert(type_traits_internal::IsHashable<variant<Hashable>>::value, "");
1635    static_assert(type_traits_internal::IsHashable<variant<int, Hashable>>::value,
1636                  "");
1637  #if ABSL_META_INTERNAL_STD_HASH_SFINAE_FRIENDLY_
1638    static_assert(!type_traits_internal::IsHashable<variant<NonHashable>>::value,
1639                  "");
1640    static_assert(
1641        !type_traits_internal::IsHashable<variant<Hashable, NonHashable>>::value,
1642        "");
1643  #endif
1644  #if !(defined(_MSC_VER) && defined(ABSL_USES_STD_VARIANT))
1645    {
1646      variant<int, int> v0(in_place_index<0>, 42);
1647      variant<int, int> v1(in_place_index<1>, 42);
1648      std::hash<variant<int, int>> hash;
1649      EXPECT_NE(hash(v0), hash(v1));
1650    }
1651  #endif  
1652    {
1653      std::hash<variant<int>> hash;
1654      std::set<size_t> hashcodes;
1655      for (int i = 0; i < 100; ++i) {
1656        hashcodes.insert(hash(i));
1657      }
1658      EXPECT_GT(hashcodes.size(), 90u);
1659      static_assert(type_traits_internal::IsHashable<variant<const int>>::value,
1660                    "");
1661      static_assert(
1662          type_traits_internal::IsHashable<variant<const Hashable>>::value, "");
1663      std::hash<absl::variant<const int>> c_hash;
1664      for (int i = 0; i < 100; ++i) {
1665        EXPECT_EQ(hash(i), c_hash(i));
1666      }
1667    }
1668  }
1669  #if !defined(ABSL_USES_STD_VARIANT)
1670  TEST(VariantTest, TestConvertingSet) {
1671    typedef variant<double> Variant;
1672    Variant v(1.0);
1673    const int two = 2;
1674    v = two;
1675    EXPECT_TRUE(absl::holds_alternative<double>(v));
1676    ASSERT_TRUE(nullptr != absl::get_if<double>(&v));
1677    EXPECT_DOUBLE_EQ(2, absl::get<double>(v));
1678  }
1679  #endif  
1680  TEST(VariantTest, Container) {
1681    typedef variant<int, float> Variant;
1682    std::vector<Variant> vec;
1683    vec.push_back(Variant(10));
1684    vec.push_back(Variant(20.0f));
1685    vec.resize(10, Variant(0));
1686  }
1687  TEST(VariantTest, TestVariantWithNonCopyableType) {
1688    typedef variant<int, NonCopyable> Variant;
1689    const int kValue = 1;
1690    Variant v(kValue);
1691    ASSERT_TRUE(absl::holds_alternative<int>(v));
1692    EXPECT_EQ(kValue, absl::get<int>(v));
1693  }
1694  TEST(VariantTest, TestEmplace) {
1695    typedef variant<int, NonCopyable> Variant;
1696    const int kValue = 1;
1697    Variant v(kValue);
1698    ASSERT_TRUE(absl::holds_alternative<int>(v));
1699    EXPECT_EQ(kValue, absl::get<int>(v));
1700    v.emplace<NonCopyable>();
1701    ASSERT_TRUE(absl::holds_alternative<NonCopyable>(v));
1702    EXPECT_EQ(0, absl::get<NonCopyable>(v).value);
1703    v = kValue;
1704    ASSERT_TRUE(absl::holds_alternative<int>(v));
1705    v.emplace<NonCopyable>(1);
1706    ASSERT_TRUE(absl::holds_alternative<NonCopyable>(v));
1707    EXPECT_EQ(1, absl::get<NonCopyable>(v).value);
1708    v = kValue;
1709    ASSERT_TRUE(absl::holds_alternative<int>(v));
1710    v.emplace<NonCopyable>(1, 2);
1711    ASSERT_TRUE(absl::holds_alternative<NonCopyable>(v));
1712    EXPECT_EQ(3, absl::get<NonCopyable>(v).value);
1713    v = kValue;
1714    ASSERT_TRUE(absl::holds_alternative<int>(v));
1715    v.emplace<NonCopyable>(1, 2, 3);
1716    ASSERT_TRUE(absl::holds_alternative<NonCopyable>(v));
1717    EXPECT_EQ(6, absl::get<NonCopyable>(v).value);
1718    v = kValue;
1719    ASSERT_TRUE(absl::holds_alternative<int>(v));
1720    v.emplace<NonCopyable>(1, 2, 3, 4);
1721    ASSERT_TRUE(absl::holds_alternative<NonCopyable>(v));
1722    EXPECT_EQ(10, absl::get<NonCopyable>(v).value);
1723    v = kValue;
1724    ASSERT_TRUE(absl::holds_alternative<int>(v));
1725  }
1726  TEST(VariantTest, TestEmplaceDestroysCurrentValue) {
1727    typedef variant<int, IncrementInDtor, NonCopyable> Variant;
1728    int counter = 0;
1729    Variant v(0);
1730    ASSERT_TRUE(absl::holds_alternative<int>(v));
1731    v.emplace<IncrementInDtor>(&counter);
1732    ASSERT_TRUE(absl::holds_alternative<IncrementInDtor>(v));
1733    ASSERT_EQ(0, counter);
1734    v.emplace<NonCopyable>();
1735    ASSERT_TRUE(absl::holds_alternative<NonCopyable>(v));
1736    EXPECT_EQ(1, counter);
1737  }
1738  TEST(VariantTest, TestMoveSemantics) {
1739    typedef variant<std::unique_ptr<int>, std::unique_ptr<std::string>> Variant;
1740    Variant v(absl::WrapUnique(new int(10)));
1741    EXPECT_TRUE(absl::holds_alternative<std::unique_ptr<int>>(v));
1742    Variant v2(absl::move(v));
1743    ASSERT_TRUE(absl::holds_alternative<std::unique_ptr<int>>(v2));
1744    ASSERT_NE(nullptr, absl::get<std::unique_ptr<int>>(v2));
1745    EXPECT_EQ(10, *absl::get<std::unique_ptr<int>>(v2));
1746    EXPECT_TRUE(absl::holds_alternative<std::unique_ptr<int>>(v));
1747    ASSERT_NE(nullptr, absl::get_if<std::unique_ptr<int>>(&v));
1748    EXPECT_EQ(nullptr, absl::get<std::unique_ptr<int>>(v));
1749    v = absl::make_unique<std::string>("foo");
1750    ASSERT_TRUE(absl::holds_alternative<std::unique_ptr<std::string>>(v));
1751    EXPECT_EQ("foo", *absl::get<std::unique_ptr<std::string>>(v));
1752    v2 = absl::move(v);
1753    ASSERT_TRUE(absl::holds_alternative<std::unique_ptr<std::string>>(v2));
1754    EXPECT_EQ("foo", *absl::get<std::unique_ptr<std::string>>(v2));
1755    EXPECT_TRUE(absl::holds_alternative<std::unique_ptr<std::string>>(v));
1756  }
1757  variant<int, std::string> PassThrough(const variant<int, std::string>& arg) {
1758    return arg;
1759  }
1760  TEST(VariantTest, TestImplicitConversion) {
1761    EXPECT_TRUE(absl::holds_alternative<int>(PassThrough(0)));
1762    EXPECT_TRUE(
1763        absl::holds_alternative<std::string>(PassThrough(std::string("foo"))));
1764  }
1765  struct Convertible2;
1766  struct Convertible1 {
1767    Convertible1() {}
1768    Convertible1(const Convertible1&) {}
1769    Convertible1& operator=(const Convertible1&) { return *this; }
1770    Convertible1(const Convertible2&) {}  
1771  };
1772  struct Convertible2 {
1773    Convertible2() {}
1774    Convertible2(const Convertible2&) {}
1775    Convertible2& operator=(const Convertible2&) { return *this; }
1776    Convertible2(const Convertible1&) {}  
1777  };
1778  TEST(VariantTest, TestRvalueConversion) {
1779  #if !defined(ABSL_USES_STD_VARIANT)
1780    variant<double, std::string> var(
1781        ConvertVariantTo<variant<double, std::string>>(
1782            variant<std::string, int>(0)));
1783    ASSERT_TRUE(absl::holds_alternative<double>(var));
1784    EXPECT_EQ(0.0, absl::get<double>(var));
1785    var = ConvertVariantTo<variant<double, std::string>>(
1786        variant<const char*, float>("foo"));
1787    ASSERT_TRUE(absl::holds_alternative<std::string>(var));
1788    EXPECT_EQ("foo", absl::get<std::string>(var));
1789    variant<double> singleton(
1790        ConvertVariantTo<variant<double>>(variant<int, float>(42)));
1791    ASSERT_TRUE(absl::holds_alternative<double>(singleton));
1792    EXPECT_EQ(42.0, absl::get<double>(singleton));
1793    singleton = ConvertVariantTo<variant<double>>(variant<int, float>(3.14f));
1794    ASSERT_TRUE(absl::holds_alternative<double>(singleton));
1795    EXPECT_FLOAT_EQ(3.14f, static_cast<float>(absl::get<double>(singleton)));
1796    singleton = ConvertVariantTo<variant<double>>(variant<int>(0));
1797    ASSERT_TRUE(absl::holds_alternative<double>(singleton));
1798    EXPECT_EQ(0.0, absl::get<double>(singleton));
1799    variant<int32_t, uint32_t> variant2(
1800        ConvertVariantTo<variant<int32_t, uint32_t>>(variant<int32_t>(42)));
1801    ASSERT_TRUE(absl::holds_alternative<int32_t>(variant2));
1802    EXPECT_EQ(42, absl::get<int32_t>(variant2));
1803    variant2 =
1804        ConvertVariantTo<variant<int32_t, uint32_t>>(variant<uint32_t>(42u));
1805    ASSERT_TRUE(absl::holds_alternative<uint32_t>(variant2));
1806    EXPECT_EQ(42u, absl::get<uint32_t>(variant2));
1807  #endif  
1808    variant<Convertible1, Convertible2> variant3(
1809        ConvertVariantTo<variant<Convertible1, Convertible2>>(
1810            (variant<Convertible2, Convertible1>(Convertible1()))));
1811    ASSERT_TRUE(absl::holds_alternative<Convertible1>(variant3));
1812    variant3 = ConvertVariantTo<variant<Convertible1, Convertible2>>(
1813        variant<Convertible2, Convertible1>(Convertible2()));
1814    ASSERT_TRUE(absl::holds_alternative<Convertible2>(variant3));
1815  }
1816  TEST(VariantTest, TestLvalueConversion) {
1817  #if !defined(ABSL_USES_STD_VARIANT)
1818    variant<std::string, int> source1 = 0;
1819    variant<double, std::string> destination(
1820        ConvertVariantTo<variant<double, std::string>>(source1));
1821    ASSERT_TRUE(absl::holds_alternative<double>(destination));
1822    EXPECT_EQ(0.0, absl::get<double>(destination));
1823    variant<const char*, float> source2 = "foo";
1824    destination = ConvertVariantTo<variant<double, std::string>>(source2);
1825    ASSERT_TRUE(absl::holds_alternative<std::string>(destination));
1826    EXPECT_EQ("foo", absl::get<std::string>(destination));
1827    variant<int, float> source3(42);
1828    variant<double> singleton(ConvertVariantTo<variant<double>>(source3));
1829    ASSERT_TRUE(absl::holds_alternative<double>(singleton));
1830    EXPECT_EQ(42.0, absl::get<double>(singleton));
1831    source3 = 3.14f;
1832    singleton = ConvertVariantTo<variant<double>>(source3);
1833    ASSERT_TRUE(absl::holds_alternative<double>(singleton));
1834    EXPECT_FLOAT_EQ(3.14f, static_cast<float>(absl::get<double>(singleton)));
1835    variant<int> source4(0);
1836    singleton = ConvertVariantTo<variant<double>>(source4);
1837    ASSERT_TRUE(absl::holds_alternative<double>(singleton));
1838    EXPECT_EQ(0.0, absl::get<double>(singleton));
1839    variant<int32_t> source5(42);
1840    variant<int32_t, uint32_t> variant2(
1841        ConvertVariantTo<variant<int32_t, uint32_t>>(source5));
1842    ASSERT_TRUE(absl::holds_alternative<int32_t>(variant2));
1843    EXPECT_EQ(42, absl::get<int32_t>(variant2));
1844    variant<uint32_t> source6(42u);
1845    variant2 = ConvertVariantTo<variant<int32_t, uint32_t>>(source6);
1846    ASSERT_TRUE(absl::holds_alternative<uint32_t>(variant2));
1847    EXPECT_EQ(42u, absl::get<uint32_t>(variant2));
1848  #endif
1849    variant<Convertible2, Convertible1> source7((Convertible1()));
1850    variant<Convertible1, Convertible2> variant3(
1851        ConvertVariantTo<variant<Convertible1, Convertible2>>(source7));
1852    ASSERT_TRUE(absl::holds_alternative<Convertible1>(variant3));
1853    source7 = Convertible2();
1854    variant3 = ConvertVariantTo<variant<Convertible1, Convertible2>>(source7);
1855    ASSERT_TRUE(absl::holds_alternative<Convertible2>(variant3));
1856  }
1857  TEST(VariantTest, TestMoveConversion) {
1858    using Variant =
1859        variant<std::unique_ptr<const int>, std::unique_ptr<const std::string>>;
1860    using OtherVariant =
1861        variant<std::unique_ptr<int>, std::unique_ptr<std::string>>;
1862    Variant var(
1863        ConvertVariantTo<Variant>(OtherVariant{absl::make_unique<int>(0)}));
1864    ASSERT_TRUE(absl::holds_alternative<std::unique_ptr<const int>>(var));
1865    ASSERT_NE(absl::get<std::unique_ptr<const int>>(var), nullptr);
1866    EXPECT_EQ(0, *absl::get<std::unique_ptr<const int>>(var));
1867    var = ConvertVariantTo<Variant>(
1868        OtherVariant(absl::make_unique<std::string>("foo")));
1869    ASSERT_TRUE(absl::holds_alternative<std::unique_ptr<const std::string>>(var));
1870    EXPECT_EQ("foo", *absl::get<std::unique_ptr<const std::string>>(var));
1871  }
1872  TEST(VariantTest, DoesNotMoveFromLvalues) {
1873    using Variant =
1874        variant<std::shared_ptr<const int>, std::shared_ptr<const std::string>>;
1875    using OtherVariant =
1876        variant<std::shared_ptr<int>, std::shared_ptr<std::string>>;
1877    Variant v1(std::make_shared<const int>(0));
1878    Variant v2(v1);
1879    EXPECT_EQ(absl::get<std::shared_ptr<const int>>(v1),
1880              absl::get<std::shared_ptr<const int>>(v2));
1881    v1 = std::make_shared<const std::string>("foo");
1882    v2 = v1;
1883    EXPECT_EQ(absl::get<std::shared_ptr<const std::string>>(v1),
1884              absl::get<std::shared_ptr<const std::string>>(v2));
1885    OtherVariant other(std::make_shared<int>(0));
1886    Variant v3(ConvertVariantTo<Variant>(other));
1887    EXPECT_EQ(absl::get<std::shared_ptr<int>>(other),
1888              absl::get<std::shared_ptr<const int>>(v3));
1889    other = std::make_shared<std::string>("foo");
1890    v3 = ConvertVariantTo<Variant>(other);
1891    EXPECT_EQ(absl::get<std::shared_ptr<std::string>>(other),
1892              absl::get<std::shared_ptr<const std::string>>(v3));
1893  }
1894  TEST(VariantTest, TestRvalueConversionViaConvertVariantTo) {
1895  #if !defined(ABSL_USES_STD_VARIANT)
1896    variant<double, std::string> var(
1897        ConvertVariantTo<variant<double, std::string>>(
1898            variant<std::string, int>(3)));
1899    EXPECT_THAT(absl::get_if<double>(&var), Pointee(3.0));
1900    var = ConvertVariantTo<variant<double, std::string>>(
1901        variant<const char*, float>("foo"));
1902    EXPECT_THAT(absl::get_if<std::string>(&var), Pointee(std::string("foo")));
1903    variant<double> singleton(
1904        ConvertVariantTo<variant<double>>(variant<int, float>(42)));
1905    EXPECT_THAT(absl::get_if<double>(&singleton), Pointee(42.0));
1906    singleton = ConvertVariantTo<variant<double>>(variant<int, float>(3.14f));
1907    EXPECT_THAT(absl::get_if<double>(&singleton), Pointee(DoubleEq(3.14f)));
1908    singleton = ConvertVariantTo<variant<double>>(variant<int>(3));
1909    EXPECT_THAT(absl::get_if<double>(&singleton), Pointee(3.0));
1910    variant<int32_t, uint32_t> variant2(
1911        ConvertVariantTo<variant<int32_t, uint32_t>>(variant<int32_t>(42)));
1912    EXPECT_THAT(absl::get_if<int32_t>(&variant2), Pointee(42));
1913    variant2 =
1914        ConvertVariantTo<variant<int32_t, uint32_t>>(variant<uint32_t>(42u));
1915    EXPECT_THAT(absl::get_if<uint32_t>(&variant2), Pointee(42u));
1916  #endif
1917    variant<Convertible1, Convertible2> variant3(
1918        ConvertVariantTo<variant<Convertible1, Convertible2>>(
1919            (variant<Convertible2, Convertible1>(Convertible1()))));
1920    ASSERT_TRUE(absl::holds_alternative<Convertible1>(variant3));
1921    variant3 = ConvertVariantTo<variant<Convertible1, Convertible2>>(
1922        variant<Convertible2, Convertible1>(Convertible2()));
1923    ASSERT_TRUE(absl::holds_alternative<Convertible2>(variant3));
1924  }
1925  TEST(VariantTest, TestLvalueConversionViaConvertVariantTo) {
1926  #if !defined(ABSL_USES_STD_VARIANT)
1927    variant<std::string, int> source1 = 3;
1928    variant<double, std::string> destination(
1929        ConvertVariantTo<variant<double, std::string>>(source1));
1930    EXPECT_THAT(absl::get_if<double>(&destination), Pointee(3.0));
1931    variant<const char*, float> source2 = "foo";
1932    destination = ConvertVariantTo<variant<double, std::string>>(source2);
1933    EXPECT_THAT(absl::get_if<std::string>(&destination),
1934                Pointee(std::string("foo")));
1935    variant<int, float> source3(42);
1936    variant<double> singleton(ConvertVariantTo<variant<double>>(source3));
1937    EXPECT_THAT(absl::get_if<double>(&singleton), Pointee(42.0));
1938    source3 = 3.14f;
1939    singleton = ConvertVariantTo<variant<double>>(source3);
1940    EXPECT_FLOAT_EQ(3.14f, static_cast<float>(absl::get<double>(singleton)));
1941    EXPECT_THAT(absl::get_if<double>(&singleton), Pointee(DoubleEq(3.14f)));
1942    variant<int> source4(3);
1943    singleton = ConvertVariantTo<variant<double>>(source4);
1944    EXPECT_THAT(absl::get_if<double>(&singleton), Pointee(3.0));
1945    variant<int32_t> source5(42);
1946    variant<int32_t, uint32_t> variant2(
1947        ConvertVariantTo<variant<int32_t, uint32_t>>(source5));
1948    EXPECT_THAT(absl::get_if<int32_t>(&variant2), Pointee(42));
1949    variant<uint32_t> source6(42u);
1950    variant2 = ConvertVariantTo<variant<int32_t, uint32_t>>(source6);
1951    EXPECT_THAT(absl::get_if<uint32_t>(&variant2), Pointee(42u));
1952  #endif  
1953    variant<Convertible2, Convertible1> source7((Convertible1()));
1954    variant<Convertible1, Convertible2> variant3(
1955        ConvertVariantTo<variant<Convertible1, Convertible2>>(source7));
1956    ASSERT_TRUE(absl::holds_alternative<Convertible1>(variant3));
1957    source7 = Convertible2();
1958    variant3 = ConvertVariantTo<variant<Convertible1, Convertible2>>(source7);
1959    ASSERT_TRUE(absl::holds_alternative<Convertible2>(variant3));
1960  }
1961  TEST(VariantTest, TestMoveConversionViaConvertVariantTo) {
1962    using Variant =
1963        variant<std::unique_ptr<const int>, std::unique_ptr<const std::string>>;
1964    using OtherVariant =
1965        variant<std::unique_ptr<int>, std::unique_ptr<std::string>>;
1966    Variant var(
1967        ConvertVariantTo<Variant>(OtherVariant{absl::make_unique<int>(3)}));
1968    EXPECT_THAT(absl::get_if<std::unique_ptr<const int>>(&var),
1969                Pointee(Pointee(3)));
1970    var = ConvertVariantTo<Variant>(
1971        OtherVariant(absl::make_unique<std::string>("foo")));
1972    EXPECT_THAT(absl::get_if<std::unique_ptr<const std::string>>(&var),
1973                Pointee(Pointee(std::string("foo"))));
1974  }
1975  #if !(defined(ABSL_USES_STD_VARIANT) && defined(__GLIBCXX__))
1976  #define ABSL_VARIANT_PROPAGATE_COPY_MOVE_TRIVIALITY 1
1977  #endif
1978  TEST(VariantTest, TestCopyAndMoveTypeTraits) {
1979    EXPECT_TRUE(std::is_copy_constructible<variant<std::string>>::value);
1980    EXPECT_TRUE(absl::is_copy_assignable<variant<std::string>>::value);
1981    EXPECT_TRUE(std::is_move_constructible<variant<std::string>>::value);
1982    EXPECT_TRUE(absl::is_move_assignable<variant<std::string>>::value);
1983    EXPECT_TRUE(std::is_move_constructible<variant<std::unique_ptr<int>>>::value);
1984    EXPECT_TRUE(absl::is_move_assignable<variant<std::unique_ptr<int>>>::value);
1985    EXPECT_FALSE(
1986        std::is_copy_constructible<variant<std::unique_ptr<int>>>::value);
1987    EXPECT_FALSE(absl::is_copy_assignable<variant<std::unique_ptr<int>>>::value);
1988    EXPECT_FALSE(
1989        absl::is_trivially_copy_constructible<variant<std::string>>::value);
1990    EXPECT_FALSE(absl::is_trivially_copy_assignable<variant<std::string>>::value);
1991  #if ABSL_VARIANT_PROPAGATE_COPY_MOVE_TRIVIALITY
1992    EXPECT_TRUE(absl::is_trivially_copy_constructible<variant<int>>::value);
1993    EXPECT_TRUE(absl::is_trivially_copy_assignable<variant<int>>::value);
1994    EXPECT_TRUE(is_trivially_move_constructible<variant<int>>::value);
1995    EXPECT_TRUE(is_trivially_move_assignable<variant<int>>::value);
1996  #endif  
1997  }
1998  TEST(VariantTest, TestVectorOfMoveonlyVariant) {
1999    std::vector<variant<std::unique_ptr<int>, std::string>> vec;
2000    vec.push_back(absl::make_unique<int>(42));
2001    vec.emplace_back("Hello");
2002    vec.reserve(3);
2003    auto another_vec = absl::move(vec);
2004    ASSERT_EQ(2u, another_vec.size());
2005    EXPECT_EQ(42, *absl::get<std::unique_ptr<int>>(another_vec[0]));
2006    EXPECT_EQ("Hello", absl::get<std::string>(another_vec[1]));
2007  }
2008  TEST(VariantTest, NestedVariant) {
2009  #if ABSL_VARIANT_PROPAGATE_COPY_MOVE_TRIVIALITY
2010    static_assert(absl::is_trivially_copy_constructible<variant<int>>(), "");
2011    static_assert(absl::is_trivially_copy_assignable<variant<int>>(), "");
2012    static_assert(is_trivially_move_constructible<variant<int>>(), "");
2013    static_assert(is_trivially_move_assignable<variant<int>>(), "");
2014    static_assert(absl::is_trivially_copy_constructible<variant<variant<int>>>(),
2015                  "");
2016    static_assert(absl::is_trivially_copy_assignable<variant<variant<int>>>(),
2017                  "");
2018    static_assert(is_trivially_move_constructible<variant<variant<int>>>(), "");
2019    static_assert(is_trivially_move_assignable<variant<variant<int>>>(), "");
2020  #endif  
2021    variant<int> x(42);
2022    variant<variant<int>> y(x);
2023    variant<variant<int>> z(y);
2024    EXPECT_TRUE(absl::holds_alternative<variant<int>>(z));
2025    EXPECT_EQ(x, absl::get<variant<int>>(z));
2026  }
2027  struct TriviallyDestructible {
2028    TriviallyDestructible(TriviallyDestructible&&) {}
2029    TriviallyDestructible(const TriviallyDestructible&) {}
2030    TriviallyDestructible& operator=(TriviallyDestructible&&) { return *this; }
2031    TriviallyDestructible& operator=(const TriviallyDestructible&) {
2032      return *this;
2033    }
2034  };
2035  struct TriviallyMovable {
2036    TriviallyMovable(TriviallyMovable&&) = default;
2037    TriviallyMovable(TriviallyMovable const&) {}
2038    TriviallyMovable& operator=(const TriviallyMovable&) { return *this; }
2039  };
2040  struct TriviallyCopyable {
2041    TriviallyCopyable(const TriviallyCopyable&) = default;
2042    TriviallyCopyable& operator=(const TriviallyCopyable&) { return *this; }
2043  };
2044  struct TriviallyMoveAssignable {
2045    TriviallyMoveAssignable(TriviallyMoveAssignable&&) = default;
2046    TriviallyMoveAssignable(const TriviallyMoveAssignable&) {}
2047    TriviallyMoveAssignable& operator=(TriviallyMoveAssignable&&) = default;
2048    TriviallyMoveAssignable& operator=(const TriviallyMoveAssignable&) {
2049      return *this;
2050    }
2051  };
2052  struct TriviallyCopyAssignable {};
2053  #if ABSL_VARIANT_PROPAGATE_COPY_MOVE_TRIVIALITY
2054  TEST(VariantTest, TestTriviality) {
2055    {
2056      using TrivDestVar = absl::variant<TriviallyDestructible>;
2057      EXPECT_FALSE(is_trivially_move_constructible<TrivDestVar>::value);
2058      EXPECT_FALSE(absl::is_trivially_copy_constructible<TrivDestVar>::value);
2059      EXPECT_FALSE(is_trivially_move_assignable<TrivDestVar>::value);
2060      EXPECT_FALSE(absl::is_trivially_copy_assignable<TrivDestVar>::value);
2061      EXPECT_TRUE(absl::is_trivially_destructible<TrivDestVar>::value);
2062    }
2063    {
2064      using TrivMoveVar = absl::variant<TriviallyMovable>;
2065      EXPECT_TRUE(is_trivially_move_constructible<TrivMoveVar>::value);
2066      EXPECT_FALSE(absl::is_trivially_copy_constructible<TrivMoveVar>::value);
2067      EXPECT_FALSE(is_trivially_move_assignable<TrivMoveVar>::value);
2068      EXPECT_FALSE(absl::is_trivially_copy_assignable<TrivMoveVar>::value);
2069      EXPECT_TRUE(absl::is_trivially_destructible<TrivMoveVar>::value);
2070    }
2071    {
2072      using TrivCopyVar = absl::variant<TriviallyCopyable>;
2073      EXPECT_TRUE(is_trivially_move_constructible<TrivCopyVar>::value);
2074      EXPECT_TRUE(absl::is_trivially_copy_constructible<TrivCopyVar>::value);
2075      EXPECT_FALSE(is_trivially_move_assignable<TrivCopyVar>::value);
2076      EXPECT_FALSE(absl::is_trivially_copy_assignable<TrivCopyVar>::value);
2077      EXPECT_TRUE(absl::is_trivially_destructible<TrivCopyVar>::value);
2078    }
2079    {
2080      using TrivMoveAssignVar = absl::variant<TriviallyMoveAssignable>;
2081      EXPECT_TRUE(is_trivially_move_constructible<TrivMoveAssignVar>::value);
2082      EXPECT_FALSE(
2083          absl::is_trivially_copy_constructible<TrivMoveAssignVar>::value);
2084      EXPECT_TRUE(is_trivially_move_assignable<TrivMoveAssignVar>::value);
2085      EXPECT_FALSE(absl::is_trivially_copy_assignable<TrivMoveAssignVar>::value);
2086      EXPECT_TRUE(absl::is_trivially_destructible<TrivMoveAssignVar>::value);
2087    }
2088    {
2089      using TrivCopyAssignVar = absl::variant<TriviallyCopyAssignable>;
2090      EXPECT_TRUE(is_trivially_move_constructible<TrivCopyAssignVar>::value);
2091      EXPECT_TRUE(
2092          absl::is_trivially_copy_constructible<TrivCopyAssignVar>::value);
2093      EXPECT_TRUE(is_trivially_move_assignable<TrivCopyAssignVar>::value);
2094      EXPECT_TRUE(absl::is_trivially_copy_assignable<TrivCopyAssignVar>::value);
2095      EXPECT_TRUE(absl::is_trivially_destructible<TrivCopyAssignVar>::value);
2096    }
2097  }
2098  #endif  
2099  TEST(VariantTest, MoveCtorBug) {
2100    struct TrivialCopyNontrivialMove {
2101      TrivialCopyNontrivialMove() = default;
2102      TrivialCopyNontrivialMove(const TrivialCopyNontrivialMove&) = default;
2103      TrivialCopyNontrivialMove(TrivialCopyNontrivialMove&&) { called = true; }
2104      bool called = false;
2105    };
2106    {
2107      using V = absl::variant<TrivialCopyNontrivialMove, int>;
2108      V v1(absl::in_place_index<0>);
2109      V v2(std::move(v1));
2110      EXPECT_TRUE(absl::get<0>(v2).called);
2111    }
2112    {
2113      using V = absl::variant<int, TrivialCopyNontrivialMove>;
2114      V v1(absl::in_place_index<1>);
2115      V v2(std::move(v1));
2116      EXPECT_TRUE(absl::get<1>(v2).called);
2117    }
2118  }
2119  }  
2120  ABSL_NAMESPACE_END
2121  }  
2122  #endif  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-variant_test.cc</h3>
            <pre><code>1  #include "absl/types/variant.h"
2  #if !defined(ABSL_USES_STD_VARIANT)
3  #include <algorithm>
4  #include <cstddef>
5  #include <functional>
6  #include <initializer_list>
7  #include <memory>
8  #include <ostream>
9  #include <queue>
10  #include <type_traits>
11  #include <unordered_set>
12  #include <utility>
13  #include <vector>
14  #include "gmock/gmock.h"
15  #include "gtest/gtest.h"
16  #include "absl/base/config.h"
17  #include "absl/base/port.h"
18  #include "absl/memory/memory.h"
19  #include "absl/meta/type_traits.h"
20  #include "absl/strings/string_view.h"
21  #ifdef ABSL_HAVE_EXCEPTIONS
22  #define ABSL_VARIANT_TEST_EXPECT_FAIL(expr, exception_t, text) \
23    EXPECT_THROW(expr, exception_t)
24  #else
25  #define ABSL_VARIANT_TEST_EXPECT_FAIL(expr, exception_t, text) \
26    EXPECT_DEATH_IF_SUPPORTED(expr, text)
27  #endif  
28  #define ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(...)                 \
29    ABSL_VARIANT_TEST_EXPECT_FAIL((void)(__VA_ARGS__), absl::bad_variant_access, \
30                                  "Bad variant access")
31  struct Hashable {};
32  namespace std {
33  template <>
34  struct hash<Hashable> {
35    size_t operator()(const Hashable&);
36  };
37  }  
38  struct NonHashable {};
39  namespace absl {
40  ABSL_NAMESPACE_BEGIN
41  namespace {
42  using ::testing::DoubleEq;
43  using ::testing::Pointee;
44  using ::testing::VariantWith;
45  struct MoveCanThrow {
46    MoveCanThrow() : v(0) {}
47    MoveCanThrow(int v) : v(v) {}  
48    MoveCanThrow(const MoveCanThrow& other) : v(other.v) {}
49    MoveCanThrow& operator=(const MoveCanThrow& &bsol;*other*/) { return *this; }
50    int v;
51  };
52  bool operator==(MoveCanThrow lhs, MoveCanThrow rhs) { return lhs.v == rhs.v; }
53  bool operator!=(MoveCanThrow lhs, MoveCanThrow rhs) { return lhs.v != rhs.v; }
54  bool operator<(MoveCanThrow lhs, MoveCanThrow rhs) { return lhs.v < rhs.v; }
55  bool operator<=(MoveCanThrow lhs, MoveCanThrow rhs) { return lhs.v <= rhs.v; }
56  bool operator>=(MoveCanThrow lhs, MoveCanThrow rhs) { return lhs.v >= rhs.v; }
57  bool operator>(MoveCanThrow lhs, MoveCanThrow rhs) { return lhs.v > rhs.v; }
58  struct SpecialSwap {
59    explicit SpecialSwap(int i) : i(i) {}
60    friend void swap(SpecialSwap& a, SpecialSwap& b) {
61      a.special_swap = b.special_swap = true;
62      std::swap(a.i, b.i);
63    }
64    bool operator==(SpecialSwap other) const { return i == other.i; }
65    int i;
66    bool special_swap = false;
67  };
68  struct MoveOnlyWithListConstructor {
69    MoveOnlyWithListConstructor() = default;
70    explicit MoveOnlyWithListConstructor(std::initializer_list<int> &bsol;*ilist*/,
71                                         int value)
72        : value(value) {}
73    MoveOnlyWithListConstructor(MoveOnlyWithListConstructor&&) = default;
74    MoveOnlyWithListConstructor& operator=(MoveOnlyWithListConstructor&&) =
75        default;
76    int value = 0;
77  };
78  #ifdef ABSL_HAVE_EXCEPTIONS
79  struct ConversionException {};
80  template <class T>
81  struct ExceptionOnConversion {
82    operator T() const {  
83      throw ConversionException();
84    }
85  };
86  template <class H, class... T>
87  void ToValuelessByException(absl::variant<H, T...>& v) {  
88    try {
89      v.template emplace<0>(ExceptionOnConversion<H>());
90    } catch (ConversionException& &bsol;*e*/) {
91    }
92  }
93  #endif  
94  template<typename T, size_t N>
95  struct ValueHolder {
96    explicit ValueHolder(const T& x) : value(x) {}
97    typedef T value_type;
98    value_type value;
99    static const size_t kIndex = N;
100  };
101  template<typename T, size_t N>
102  const size_t ValueHolder<T, N>::kIndex;
103  template<typename T, size_t N>
104  inline bool operator==(const ValueHolder<T, N>& left,
105                         const ValueHolder<T, N>& right) {
106    return left.value == right.value;
107  }
108  template<typename T, size_t N>
109  inline bool operator!=(const ValueHolder<T, N>& left,
110                         const ValueHolder<T, N>& right) {
111    return left.value != right.value;
112  }
113  template<typename T, size_t N>
114  inline std::ostream& operator<<(
115      std::ostream& stream, const ValueHolder<T, N>& object) {
116    return stream << object.value;
117  }
118  template<typename T>
119  struct VariantFactory {
120    typedef variant<ValueHolder<T, 1>, ValueHolder<T, 2>, ValueHolder<T, 3>,
121                    ValueHolder<T, 4>>
122        Type;
123  };
124  typedef ::testing::Types<ValueHolder<size_t, 1>, ValueHolder<size_t, 2>,
125                           ValueHolder<size_t, 3>,
126                           ValueHolder<size_t, 4>> VariantTypes;
127  struct IncrementInDtor {
128    explicit IncrementInDtor(int* counter) : counter(counter) {}
129    ~IncrementInDtor() { *counter += 1; }
130    int* counter;
131  };
132  struct IncrementInDtorCopyCanThrow {
133    explicit IncrementInDtorCopyCanThrow(int* counter) : counter(counter) {}
134    IncrementInDtorCopyCanThrow(IncrementInDtorCopyCanThrow&& other) noexcept =
135        default;
136    IncrementInDtorCopyCanThrow(const IncrementInDtorCopyCanThrow& other)
137        : counter(other.counter) {}
138    IncrementInDtorCopyCanThrow& operator=(
139        IncrementInDtorCopyCanThrow&&) noexcept = default;
140    IncrementInDtorCopyCanThrow& operator=(
141        IncrementInDtorCopyCanThrow const& other) {
142      counter = other.counter;
143      return *this;
144    }
145    ~IncrementInDtorCopyCanThrow() { *counter += 1; }
146    int* counter;
147  };
148  inline bool operator==(const IncrementInDtor& left,
149                         const IncrementInDtor& right) {
150    return left.counter == right.counter;
151  }
152  inline std::ostream& operator<<(
153      std::ostream& stream, const IncrementInDtor& object) {
154    return stream << object.counter;
155  }
156  class CopyNoAssign {
157   public:
158    explicit CopyNoAssign(int value) : foo(value) {}
159    CopyNoAssign(const CopyNoAssign& other) : foo(other.foo) {}
160    int foo;
161   private:
162    const CopyNoAssign& operator=(const CopyNoAssign&);
163  };
164  class NonCopyable {
165   public:
166    NonCopyable()
167        : value(0) {}
168    explicit NonCopyable(int value1)
169        : value(value1) {}
170    NonCopyable(int value1, int value2)
171        : value(value1 + value2) {}
172    NonCopyable(int value1, int value2, int value3)
173        : value(value1 + value2 + value3) {}
174    NonCopyable(int value1, int value2, int value3, int value4)
175        : value(value1 + value2 + value3 + value4) {}
176    NonCopyable(const NonCopyable&) = delete;
177    NonCopyable& operator=(const NonCopyable&) = delete;
178    int value;
179  };
180  template <typename T>
181  class VariantTypesTest : public ::testing::Test {};
182  TYPED_TEST_SUITE(VariantTypesTest, VariantTypes);
183  struct NonNoexceptDefaultConstructible {
184    NonNoexceptDefaultConstructible() {}
185    int value = 5;
186  };
187  struct NonDefaultConstructible {
188    NonDefaultConstructible() = delete;
189  };
190  TEST(VariantTest, TestDefaultConstructor) {
191    {
192      using X = variant<int>;
193      constexpr variant<int> x{};
194      ASSERT_FALSE(x.valueless_by_exception());
195      ASSERT_EQ(0u, x.index());
196      EXPECT_EQ(0, absl::get<0>(x));
197      EXPECT_TRUE(std::is_nothrow_default_constructible<X>::value);
198    }
199    {
200      using X = variant<NonNoexceptDefaultConstructible>;
201      X x{};
202      ASSERT_FALSE(x.valueless_by_exception());
203      ASSERT_EQ(0u, x.index());
204      EXPECT_EQ(5, absl::get<0>(x).value);
205      EXPECT_FALSE(std::is_nothrow_default_constructible<X>::value);
206    }
207    {
208      using X = variant<int, NonNoexceptDefaultConstructible>;
209      X x{};
210      ASSERT_FALSE(x.valueless_by_exception());
211      ASSERT_EQ(0u, x.index());
212      EXPECT_EQ(0, absl::get<0>(x));
213      EXPECT_TRUE(std::is_nothrow_default_constructible<X>::value);
214    }
215    {
216      using X = variant<NonNoexceptDefaultConstructible, int>;
217      X x{};
218      ASSERT_FALSE(x.valueless_by_exception());
219      ASSERT_EQ(0u, x.index());
220      EXPECT_EQ(5, absl::get<0>(x).value);
221      EXPECT_FALSE(std::is_nothrow_default_constructible<X>::value);
222    }
223    EXPECT_FALSE(
224        std::is_default_constructible<variant<NonDefaultConstructible>>::value);
225    EXPECT_FALSE((std::is_default_constructible<
226                  variant<NonDefaultConstructible, int>>::value));
227    EXPECT_TRUE((std::is_default_constructible<
228                 variant<int, NonDefaultConstructible>>::value));
229  }
230  TYPED_TEST(VariantTypesTest, TestCopyCtor) {
231    typedef typename VariantFactory<typename TypeParam::value_type>::Type Variant;
232    using value_type1 = absl::variant_alternative_t<0, Variant>;
233    using value_type2 = absl::variant_alternative_t<1, Variant>;
234    using value_type3 = absl::variant_alternative_t<2, Variant>;
235    using value_type4 = absl::variant_alternative_t<3, Variant>;
236    const TypeParam value(TypeParam::kIndex);
237    Variant original(value);
238    Variant copied(original);
239    EXPECT_TRUE(absl::holds_alternative<value_type1>(copied) ||
240                TypeParam::kIndex != 1);
241    EXPECT_TRUE(absl::holds_alternative<value_type2>(copied) ||
242                TypeParam::kIndex != 2);
243    EXPECT_TRUE(absl::holds_alternative<value_type3>(copied) ||
244                TypeParam::kIndex != 3);
245    EXPECT_TRUE(absl::holds_alternative<value_type4>(copied) ||
246                TypeParam::kIndex != 4);
247    EXPECT_TRUE((absl::get_if<value_type1>(&original) ==
248                 absl::get_if<value_type1>(&copied)) ||
249                TypeParam::kIndex == 1);
250    EXPECT_TRUE((absl::get_if<value_type2>(&original) ==
251                 absl::get_if<value_type2>(&copied)) ||
252                TypeParam::kIndex == 2);
253    EXPECT_TRUE((absl::get_if<value_type3>(&original) ==
254                 absl::get_if<value_type3>(&copied)) ||
255                TypeParam::kIndex == 3);
256    EXPECT_TRUE((absl::get_if<value_type4>(&original) ==
257                 absl::get_if<value_type4>(&copied)) ||
258                TypeParam::kIndex == 4);
259    EXPECT_TRUE((absl::get_if<value_type1>(&original) ==
260                 absl::get_if<value_type1>(&copied)) ||
261                TypeParam::kIndex == 1);
262    EXPECT_TRUE((absl::get_if<value_type2>(&original) ==
263                 absl::get_if<value_type2>(&copied)) ||
264                TypeParam::kIndex == 2);
265    EXPECT_TRUE((absl::get_if<value_type3>(&original) ==
266                 absl::get_if<value_type3>(&copied)) ||
267                TypeParam::kIndex == 3);
268    EXPECT_TRUE((absl::get_if<value_type4>(&original) ==
269                 absl::get_if<value_type4>(&copied)) ||
270                TypeParam::kIndex == 4);
271    const TypeParam* ovalptr = absl::get_if<TypeParam>(&original);
272    const TypeParam* cvalptr = absl::get_if<TypeParam>(&copied);
273    ASSERT_TRUE(ovalptr != nullptr);
274    ASSERT_TRUE(cvalptr != nullptr);
275    EXPECT_EQ(*ovalptr, *cvalptr);
276    TypeParam* mutable_ovalptr = absl::get_if<TypeParam>(&original);
277    TypeParam* mutable_cvalptr = absl::get_if<TypeParam>(&copied);
278    ASSERT_TRUE(mutable_ovalptr != nullptr);
279    ASSERT_TRUE(mutable_cvalptr != nullptr);
280    EXPECT_EQ(*mutable_ovalptr, *mutable_cvalptr);
281  }
282  template <class>
283  struct MoveOnly {
284    MoveOnly() = default;
285    explicit MoveOnly(int value) : value(value) {}
286    MoveOnly(MoveOnly&&) = default;
287    MoveOnly& operator=(MoveOnly&&) = default;
288    int value = 5;
289  };
290  TEST(VariantTest, TestMoveConstruct) {
291    using V = variant<MoveOnly<class A>, MoveOnly<class B>, MoveOnly<class C>>;
292    V v(in_place_index<1>, 10);
293    V v2 = absl::move(v);
294    EXPECT_EQ(10, absl::get<1>(v2).value);
295  }
296  template <class T>
297  union SingleUnion {
298    T member;
299  };
300  template <class T>
301  struct is_trivially_move_constructible
302      : std::is_move_constructible<SingleUnion<T>>::type {};
303  template <class T>
304  struct is_trivially_move_assignable
305      : absl::is_move_assignable<SingleUnion<T>>::type {};
306  TEST(VariantTest, NothrowMoveConstructible) {
307    using U = std::unique_ptr<int>;
308    struct E {
309      E(E&&) {}
310    };
311    static_assert(std::is_nothrow_move_constructible<variant<U>>::value, "");
312    static_assert(std::is_nothrow_move_constructible<variant<U, int>>::value, "");
313    static_assert(!std::is_nothrow_move_constructible<variant<U, E>>::value, "");
314  }
315  TYPED_TEST(VariantTypesTest, TestValueCtor) {
316    typedef typename VariantFactory<typename TypeParam::value_type>::Type Variant;
317    using value_type1 = absl::variant_alternative_t<0, Variant>;
318    using value_type2 = absl::variant_alternative_t<1, Variant>;
319    using value_type3 = absl::variant_alternative_t<2, Variant>;
320    using value_type4 = absl::variant_alternative_t<3, Variant>;
321    const TypeParam value(TypeParam::kIndex);
<span onclick='openModal()' class='match'>322    Variant v(value);
323    EXPECT_TRUE(absl::holds_alternative<value_type1>(v) ||
324                TypeParam::kIndex != 1);
325    EXPECT_TRUE(absl::holds_alternative<value_type2>(v) ||
326                TypeParam::kIndex != 2);
327    EXPECT_TRUE(absl::holds_alternative<value_type3>(v) ||
328                TypeParam::kIndex != 3);
329    EXPECT_TRUE(absl::holds_alternative<value_type4>(v) ||
330                TypeParam::kIndex != 4);
331    EXPECT_TRUE(nullptr != absl::get_if<value_type1>(&v) ||
</span>332                TypeParam::kIndex != 1);
333    EXPECT_TRUE(nullptr != absl::get_if<value_type2>(&v) ||
334                TypeParam::kIndex != 2);
335    EXPECT_TRUE(nullptr != absl::get_if<value_type3>(&v) ||
336                TypeParam::kIndex != 3);
337    EXPECT_TRUE(nullptr != absl::get_if<value_type4>(&v) ||
338                TypeParam::kIndex != 4);
339    EXPECT_TRUE(nullptr != absl::get_if<value_type1>(&v) ||
340                TypeParam::kIndex != 1);
341    EXPECT_TRUE(nullptr != absl::get_if<value_type2>(&v) ||
342                TypeParam::kIndex != 2);
343    EXPECT_TRUE(nullptr != absl::get_if<value_type3>(&v) ||
344                TypeParam::kIndex != 3);
345    EXPECT_TRUE(nullptr != absl::get_if<value_type4>(&v) ||
346                TypeParam::kIndex != 4);
347    const TypeParam* valptr = absl::get_if<TypeParam>(&v);
348    ASSERT_TRUE(nullptr != valptr);
349    EXPECT_EQ(value.value, valptr->value);
350    const TypeParam* mutable_valptr = absl::get_if<TypeParam>(&v);
351    ASSERT_TRUE(nullptr != mutable_valptr);
352    EXPECT_EQ(value.value, mutable_valptr->value);
353  }
354  TEST(VariantTest, AmbiguousValueConstructor) {
355    EXPECT_FALSE((std::is_convertible<int, absl::variant<int, int>>::value));
356    EXPECT_FALSE((std::is_constructible<absl::variant<int, int>, int>::value));
357  }
358  TEST(VariantTest, InPlaceType) {
359    using Var = variant<int, std::string, NonCopyable, std::vector<int>>;
360    Var v1(in_place_type_t<int>(), 7);
361    ASSERT_TRUE(absl::holds_alternative<int>(v1));
362    EXPECT_EQ(7, absl::get<int>(v1));
363    Var v2(in_place_type_t<std::string>(), "ABC");
364    ASSERT_TRUE(absl::holds_alternative<std::string>(v2));
365    EXPECT_EQ("ABC", absl::get<std::string>(v2));
366    Var v3(in_place_type_t<std::string>(), "ABC", 2u);
367    ASSERT_TRUE(absl::holds_alternative<std::string>(v3));
368    EXPECT_EQ("AB", absl::get<std::string>(v3));
369    Var v4(in_place_type_t<NonCopyable>{});
370    ASSERT_TRUE(absl::holds_alternative<NonCopyable>(v4));
371    Var v5(in_place_type_t<std::vector<int>>(), {1, 2, 3});
372    ASSERT_TRUE(absl::holds_alternative<std::vector<int>>(v5));
373    EXPECT_THAT(absl::get<std::vector<int>>(v5), ::testing::ElementsAre(1, 2, 3));
374  }
375  TEST(VariantTest, InPlaceTypeVariableTemplate) {
376    using Var = variant<int, std::string, NonCopyable, std::vector<int>>;
377    Var v1(in_place_type<int>, 7);
378    ASSERT_TRUE(absl::holds_alternative<int>(v1));
379    EXPECT_EQ(7, absl::get<int>(v1));
380    Var v2(in_place_type<std::string>, "ABC");
381    ASSERT_TRUE(absl::holds_alternative<std::string>(v2));
382    EXPECT_EQ("ABC", absl::get<std::string>(v2));
383    Var v3(in_place_type<std::string>, "ABC", 2u);
384    ASSERT_TRUE(absl::holds_alternative<std::string>(v3));
385    EXPECT_EQ("AB", absl::get<std::string>(v3));
386    Var v4(in_place_type<NonCopyable>);
387    ASSERT_TRUE(absl::holds_alternative<NonCopyable>(v4));
388    Var v5(in_place_type<std::vector<int>>, {1, 2, 3});
389    ASSERT_TRUE(absl::holds_alternative<std::vector<int>>(v5));
390    EXPECT_THAT(absl::get<std::vector<int>>(v5), ::testing::ElementsAre(1, 2, 3));
391  }
392  TEST(VariantTest, InPlaceTypeInitializerList) {
393    using Var =
394        variant<int, std::string, NonCopyable, MoveOnlyWithListConstructor>;
395    Var v1(in_place_type_t<MoveOnlyWithListConstructor>(), {1, 2, 3, 4, 5}, 6);
396    ASSERT_TRUE(absl::holds_alternative<MoveOnlyWithListConstructor>(v1));
397    EXPECT_EQ(6, absl::get<MoveOnlyWithListConstructor>(v1).value);
398  }
399  TEST(VariantTest, InPlaceTypeInitializerListVariabletemplate) {
400    using Var =
401        variant<int, std::string, NonCopyable, MoveOnlyWithListConstructor>;
402    Var v1(in_place_type<MoveOnlyWithListConstructor>, {1, 2, 3, 4, 5}, 6);
403    ASSERT_TRUE(absl::holds_alternative<MoveOnlyWithListConstructor>(v1));
404    EXPECT_EQ(6, absl::get<MoveOnlyWithListConstructor>(v1).value);
405  }
406  TEST(VariantTest, InPlaceIndex) {
407    using Var = variant<int, std::string, NonCopyable, std::vector<int>>;
408    Var v1(in_place_index_t<0>(), 7);
409    ASSERT_TRUE(absl::holds_alternative<int>(v1));
410    EXPECT_EQ(7, absl::get<int>(v1));
411    Var v2(in_place_index_t<1>(), "ABC");
412    ASSERT_TRUE(absl::holds_alternative<std::string>(v2));
413    EXPECT_EQ("ABC", absl::get<std::string>(v2));
414    Var v3(in_place_index_t<1>(), "ABC", 2u);
415    ASSERT_TRUE(absl::holds_alternative<std::string>(v3));
416    EXPECT_EQ("AB", absl::get<std::string>(v3));
417    Var v4(in_place_index_t<2>{});
418    EXPECT_TRUE(absl::holds_alternative<NonCopyable>(v4));
419    EXPECT_TRUE(absl::holds_alternative<NonCopyable>(
420        variant<NonCopyable>(in_place_index_t<0>{})));
421    Var v5(in_place_index_t<3>(), {1, 2, 3});
422    ASSERT_TRUE(absl::holds_alternative<std::vector<int>>(v5));
423    EXPECT_THAT(absl::get<std::vector<int>>(v5), ::testing::ElementsAre(1, 2, 3));
424  }
425  TEST(VariantTest, InPlaceIndexVariableTemplate) {
426    using Var = variant<int, std::string, NonCopyable, std::vector<int>>;
427    Var v1(in_place_index<0>, 7);
428    ASSERT_TRUE(absl::holds_alternative<int>(v1));
429    EXPECT_EQ(7, absl::get<int>(v1));
430    Var v2(in_place_index<1>, "ABC");
431    ASSERT_TRUE(absl::holds_alternative<std::string>(v2));
432    EXPECT_EQ("ABC", absl::get<std::string>(v2));
433    Var v3(in_place_index<1>, "ABC", 2u);
434    ASSERT_TRUE(absl::holds_alternative<std::string>(v3));
435    EXPECT_EQ("AB", absl::get<std::string>(v3));
436    Var v4(in_place_index<2>);
437    EXPECT_TRUE(absl::holds_alternative<NonCopyable>(v4));
438    EXPECT_TRUE(absl::holds_alternative<NonCopyable>(
439        variant<NonCopyable>(in_place_index<0>)));
440    Var v5(in_place_index<3>, {1, 2, 3});
441    ASSERT_TRUE(absl::holds_alternative<std::vector<int>>(v5));
442    EXPECT_THAT(absl::get<std::vector<int>>(v5), ::testing::ElementsAre(1, 2, 3));
443  }
444  TEST(VariantTest, InPlaceIndexInitializerList) {
445    using Var =
446        variant<int, std::string, NonCopyable, MoveOnlyWithListConstructor>;
447    Var v1(in_place_index_t<3>(), {1, 2, 3, 4, 5}, 6);
448    ASSERT_TRUE(absl::holds_alternative<MoveOnlyWithListConstructor>(v1));
449    EXPECT_EQ(6, absl::get<MoveOnlyWithListConstructor>(v1).value);
450  }
451  TEST(VariantTest, InPlaceIndexInitializerListVariableTemplate) {
452    using Var =
453        variant<int, std::string, NonCopyable, MoveOnlyWithListConstructor>;
454    Var v1(in_place_index<3>, {1, 2, 3, 4, 5}, 6);
455    ASSERT_TRUE(absl::holds_alternative<MoveOnlyWithListConstructor>(v1));
456    EXPECT_EQ(6, absl::get<MoveOnlyWithListConstructor>(v1).value);
457  }
458  TEST(VariantTest, TestDtor) {
459    typedef VariantFactory<IncrementInDtor>::Type Variant;
460    using value_type1 = absl::variant_alternative_t<0, Variant>;
461    using value_type2 = absl::variant_alternative_t<1, Variant>;
462    using value_type3 = absl::variant_alternative_t<2, Variant>;
463    using value_type4 = absl::variant_alternative_t<3, Variant>;
464    int counter = 0;
465    IncrementInDtor counter_adjuster(&counter);
466    EXPECT_EQ(0, counter);
467    value_type1 value1(counter_adjuster);
468    { Variant object(value1); }
469    EXPECT_EQ(1, counter);
470    value_type2 value2(counter_adjuster);
471    { Variant object(value2); }
472    EXPECT_EQ(2, counter);
473    value_type3 value3(counter_adjuster);
474    { Variant object(value3); }
475    EXPECT_EQ(3, counter);
476    value_type4 value4(counter_adjuster);
477    { Variant object(value4); }
478    EXPECT_EQ(4, counter);
479  }
480  #ifdef ABSL_HAVE_EXCEPTIONS
481  #if defined(ABSL_INTERNAL_MSVC_2017_DBG_MODE)
482  TEST(VariantTest, DISABLED_TestDtorValuelessByException)
483  #else
484  TEST(VariantTest, TestDtorValuelessByException)
485  #endif
486  {
487    int counter = 0;
488    IncrementInDtor counter_adjuster(&counter);
489    {
490      using Variant = VariantFactory<IncrementInDtor>::Type;
491      Variant v(in_place_index<0>, counter_adjuster);
492      EXPECT_EQ(0, counter);
493      ToValuelessByException(v);
494      ASSERT_TRUE(v.valueless_by_exception());
495      EXPECT_EQ(1, counter);
496    }
497    EXPECT_EQ(1, counter);
498  }
499  #endif  
500  TEST(VariantTest, TestSelfAssignment) {
501    typedef VariantFactory<IncrementInDtor>::Type Variant;
502    int counter = 0;
503    IncrementInDtor counter_adjuster(&counter);
504    absl::variant_alternative_t<0, Variant> value(counter_adjuster);
505    Variant object(value);
506    object.operator=(object);
507    EXPECT_EQ(0, counter);
508    const std::string long_str(128, 'a');
509    std::string foo = long_str;
510    foo = *&foo;
511    EXPECT_EQ(long_str, foo);
512    variant<int, std::string> so = long_str;
513    ASSERT_EQ(1u, so.index());
514    EXPECT_EQ(long_str, absl::get<1>(so));
515    so = *&so;
516    ASSERT_EQ(1u, so.index());
517    EXPECT_EQ(long_str, absl::get<1>(so));
518  }
519  TYPED_TEST(VariantTypesTest, TestAssignmentCopiesValueSameTypes) {
520    typedef typename VariantFactory<typename TypeParam::value_type>::Type Variant;
521    const TypeParam value(TypeParam::kIndex);
522    const Variant source(value);
523    Variant target(TypeParam(value.value + 1));
524    ASSERT_TRUE(absl::holds_alternative<TypeParam>(source));
525    ASSERT_TRUE(absl::holds_alternative<TypeParam>(target));
526    ASSERT_NE(absl::get<TypeParam>(source), absl::get<TypeParam>(target));
527    target = source;
528    ASSERT_TRUE(absl::holds_alternative<TypeParam>(source));
529    ASSERT_TRUE(absl::holds_alternative<TypeParam>(target));
530    EXPECT_EQ(absl::get<TypeParam>(source), absl::get<TypeParam>(target));
531  }
532  TYPED_TEST(VariantTypesTest, TestAssignmentCopiesValuesVaryingSourceType) {
533    typedef typename VariantFactory<typename TypeParam::value_type>::Type Variant;
534    using value_type1 = absl::variant_alternative_t<0, Variant>;
535    const TypeParam value(TypeParam::kIndex);
536    const Variant source(value);
537    ASSERT_TRUE(absl::holds_alternative<TypeParam>(source));
538    Variant target(value_type1(1));
539    ASSERT_TRUE(absl::holds_alternative<value_type1>(target));
540    target = source;
541    EXPECT_TRUE(absl::holds_alternative<TypeParam>(source));
542    EXPECT_TRUE(absl::holds_alternative<TypeParam>(target));
543    EXPECT_EQ(absl::get<TypeParam>(source), absl::get<TypeParam>(target));
544  }
545  TYPED_TEST(VariantTypesTest, TestAssignmentCopiesValuesVaryingTargetType) {
546    typedef typename VariantFactory<typename TypeParam::value_type>::Type Variant;
547    using value_type1 = absl::variant_alternative_t<0, Variant>;
548    const Variant source(value_type1(1));
549    ASSERT_TRUE(absl::holds_alternative<value_type1>(source));
550    const TypeParam value(TypeParam::kIndex);
551    Variant target(value);
552    ASSERT_TRUE(absl::holds_alternative<TypeParam>(target));
553    target = source;
554    EXPECT_TRUE(absl::holds_alternative<value_type1>(target));
555    EXPECT_TRUE(absl::holds_alternative<value_type1>(source));
556    EXPECT_EQ(absl::get<value_type1>(source), absl::get<value_type1>(target));
557  }
558  TEST(VariantTest, TestAssign) {
559    typedef VariantFactory<IncrementInDtor>::Type Variant;
560    using value_type1 = absl::variant_alternative_t<0, Variant>;
561    using value_type2 = absl::variant_alternative_t<1, Variant>;
562    using value_type3 = absl::variant_alternative_t<2, Variant>;
563    using value_type4 = absl::variant_alternative_t<3, Variant>;
564    const int kSize = 4;
565    int counter[kSize];
566    std::unique_ptr<IncrementInDtor> counter_adjustor[kSize];
567    for (int i = 0; i != kSize; i++) {
568      counter[i] = 0;
569      counter_adjustor[i] = absl::make_unique<IncrementInDtor>(&counter[i]);
570    }
571    value_type1 v1(*counter_adjustor[0]);
572    value_type2 v2(*counter_adjustor[1]);
573    value_type3 v3(*counter_adjustor[2]);
574    value_type4 v4(*counter_adjustor[3]);
575    {
576      Variant object(v1);
577      object = v2;
578      object = v3;
579      object = v4;
580      object = v1;
581    }
582    EXPECT_EQ(2, counter[0]);
583    EXPECT_EQ(1, counter[1]);
584    EXPECT_EQ(1, counter[2]);
585    EXPECT_EQ(1, counter[3]);
586    std::fill(std::begin(counter), std::end(counter), 0);
587    {
588      Variant object(v1);
589      object.operator=(object);
590      EXPECT_EQ(0, counter[0]);
591    }
592    {
593      Variant object(v2);
594      object.operator=(object);
595      EXPECT_EQ(0, counter[1]);
596    }
597    {
598      Variant object(v3);
599      object.operator=(object);
600      EXPECT_EQ(0, counter[2]);
601    }
602    {
603      Variant object(v4);
604      object.operator=(object);
605      EXPECT_EQ(0, counter[3]);
606    }
607    EXPECT_EQ(1, counter[0]);
608    EXPECT_EQ(1, counter[1]);
609    EXPECT_EQ(1, counter[2]);
610    EXPECT_EQ(1, counter[3]);
611  }
612  TEST(VariantTest, TestBackupAssign) {
613    typedef VariantFactory<IncrementInDtorCopyCanThrow>::Type Variant;
614    using value_type1 = absl::variant_alternative_t<0, Variant>;
615    using value_type2 = absl::variant_alternative_t<1, Variant>;
616    using value_type3 = absl::variant_alternative_t<2, Variant>;
617    using value_type4 = absl::variant_alternative_t<3, Variant>;
618    const int kSize = 4;
619    int counter[kSize];
620    std::unique_ptr<IncrementInDtorCopyCanThrow> counter_adjustor[kSize];
621    for (int i = 0; i != kSize; i++) {
622      counter[i] = 0;
623      counter_adjustor[i].reset(new IncrementInDtorCopyCanThrow(&counter[i]));
624    }
625    value_type1 v1(*counter_adjustor[0]);
626    value_type2 v2(*counter_adjustor[1]);
627    value_type3 v3(*counter_adjustor[2]);
628    value_type4 v4(*counter_adjustor[3]);
629    {
630      Variant object(v1);
631      object = v2;
632      object = v3;
633      object = v4;
634      object = v1;
635    }
636  #if !(defined(ABSL_USES_STD_VARIANT) && defined(__GLIBCXX__))
637    EXPECT_EQ(3, counter[0]);
638    EXPECT_EQ(2, counter[1]);
639    EXPECT_EQ(2, counter[2]);
640    EXPECT_EQ(2, counter[3]);
641  #endif
642    std::fill(std::begin(counter), std::end(counter), 0);
643    {
644      Variant object(v1);
645      object.operator=(object);
646      EXPECT_EQ(0, counter[0]);
647    }
648    {
649      Variant object(v2);
650      object.operator=(object);
651      EXPECT_EQ(0, counter[1]);
652    }
653    {
654      Variant object(v3);
655      object.operator=(object);
656      EXPECT_EQ(0, counter[2]);
657    }
658    {
659      Variant object(v4);
660      object.operator=(object);
661      EXPECT_EQ(0, counter[3]);
662    }
663    EXPECT_EQ(1, counter[0]);
664    EXPECT_EQ(1, counter[1]);
665    EXPECT_EQ(1, counter[2]);
666    EXPECT_EQ(1, counter[3]);
667  }
668  TEST(VariantTest, TestEmplaceBasic) {
669    using Variant = variant<int, char>;
670    Variant v(absl::in_place_index<0>, 0);
671    {
672      char& emplace_result = v.emplace<char>();
673      ASSERT_TRUE(absl::holds_alternative<char>(v));
674      EXPECT_EQ(absl::get<char>(v), 0);
675      EXPECT_EQ(&emplace_result, &absl::get<char>(v));
676    }
677    absl::get<char>(v) = 'a';
678    v.emplace<char>('b');
679    ASSERT_TRUE(absl::holds_alternative<char>(v));
680    EXPECT_EQ(absl::get<char>(v), 'b');
681    {
682      int& emplace_result = v.emplace<int>();
683      EXPECT_TRUE(absl::holds_alternative<int>(v));
684      EXPECT_EQ(absl::get<int>(v), 0);
685      EXPECT_EQ(&emplace_result, &absl::get<int>(v));
686    }
687  }
688  TEST(VariantTest, TestEmplaceInitializerList) {
689    using Var =
690        variant<int, std::string, NonCopyable, MoveOnlyWithListConstructor>;
691    Var v1(absl::in_place_index<0>, 555);
692    MoveOnlyWithListConstructor& emplace_result =
693        v1.emplace<MoveOnlyWithListConstructor>({1, 2, 3, 4, 5}, 6);
694    ASSERT_TRUE(absl::holds_alternative<MoveOnlyWithListConstructor>(v1));
695    EXPECT_EQ(6, absl::get<MoveOnlyWithListConstructor>(v1).value);
696    EXPECT_EQ(&emplace_result, &absl::get<MoveOnlyWithListConstructor>(v1));
697  }
698  TEST(VariantTest, TestEmplaceIndex) {
699    using Variant = variant<int, char>;
700    Variant v(absl::in_place_index<0>, 555);
701    {
702      char& emplace_result = v.emplace<1>();
703      ASSERT_TRUE(absl::holds_alternative<char>(v));
704      EXPECT_EQ(absl::get<char>(v), 0);
705      EXPECT_EQ(&emplace_result, &absl::get<char>(v));
706    }
707    absl::get<char>(v) = 'a';
708    v.emplace<1>('b');
709    ASSERT_TRUE(absl::holds_alternative<char>(v));
710    EXPECT_EQ(absl::get<char>(v), 'b');
711    {
712      int& emplace_result = v.emplace<0>();
713      EXPECT_TRUE(absl::holds_alternative<int>(v));
714      EXPECT_EQ(absl::get<int>(v), 0);
715      EXPECT_EQ(&emplace_result, &absl::get<int>(v));
716    }
717  }
718  TEST(VariantTest, TestEmplaceIndexInitializerList) {
719    using Var =
720        variant<int, std::string, NonCopyable, MoveOnlyWithListConstructor>;
721    Var v1(absl::in_place_index<0>, 555);
722    MoveOnlyWithListConstructor& emplace_result =
723        v1.emplace<3>({1, 2, 3, 4, 5}, 6);
724    ASSERT_TRUE(absl::holds_alternative<MoveOnlyWithListConstructor>(v1));
725    EXPECT_EQ(6, absl::get<MoveOnlyWithListConstructor>(v1).value);
726    EXPECT_EQ(&emplace_result, &absl::get<MoveOnlyWithListConstructor>(v1));
727  }
728  TEST(VariantTest, Index) {
729    using Var = variant<int, std::string, double>;
730    Var v = 1;
731    EXPECT_EQ(0u, v.index());
732    v = "str";
733    EXPECT_EQ(1u, v.index());
734    v = 0.;
735    EXPECT_EQ(2u, v.index());
736    Var v2 = v;
737    EXPECT_EQ(2u, v2.index());
738    v2.emplace<int>(3);
739    EXPECT_EQ(0u, v2.index());
740  }
741  TEST(VariantTest, NotValuelessByException) {
742    using Var = variant<int, std::string, double>;
743    Var v = 1;
744    EXPECT_FALSE(v.valueless_by_exception());
745    v = "str";
746    EXPECT_FALSE(v.valueless_by_exception());
747    v = 0.;
748    EXPECT_FALSE(v.valueless_by_exception());
749    Var v2 = v;
750    EXPECT_FALSE(v.valueless_by_exception());
751    v2.emplace<int>(3);
752    EXPECT_FALSE(v.valueless_by_exception());
753  }
754  #ifdef ABSL_HAVE_EXCEPTIONS
755  TEST(VariantTest, IndexValuelessByException) {
756    using Var = variant<MoveCanThrow, std::string, double>;
757    Var v(absl::in_place_index<0>);
758    EXPECT_EQ(0u, v.index());
759    ToValuelessByException(v);
760    EXPECT_EQ(absl::variant_npos, v.index());
761    v = "str";
762    EXPECT_EQ(1u, v.index());
763  }
764  TEST(VariantTest, ValuelessByException) {
765    using Var = variant<MoveCanThrow, std::string, double>;
766    Var v(absl::in_place_index<0>);
767    EXPECT_FALSE(v.valueless_by_exception());
768    ToValuelessByException(v);
769    EXPECT_TRUE(v.valueless_by_exception());
770    v = "str";
771    EXPECT_FALSE(v.valueless_by_exception());
772  }
773  #endif  
774  TEST(VariantTest, MemberSwap) {
775    SpecialSwap v1(3);
776    SpecialSwap v2(7);
777    variant<SpecialSwap> a = v1, b = v2;
778    EXPECT_THAT(a, VariantWith<SpecialSwap>(v1));
779    EXPECT_THAT(b, VariantWith<SpecialSwap>(v2));
780    a.swap(b);
781    EXPECT_THAT(a, VariantWith<SpecialSwap>(v2));
782    EXPECT_THAT(b, VariantWith<SpecialSwap>(v1));
783    EXPECT_TRUE(absl::get<SpecialSwap>(a).special_swap);
784    using V = variant<MoveCanThrow, std::string, int>;
785    int i = 33;
786    std::string s = "abc";
787    {
788      V lhs(i), rhs(s);
789      lhs.swap(rhs);
790      EXPECT_THAT(lhs, VariantWith<std::string>(s));
791      EXPECT_THAT(rhs, VariantWith<int>(i));
792    }
793  #ifdef ABSL_HAVE_EXCEPTIONS
794    V valueless(in_place_index<0>);
795    ToValuelessByException(valueless);
796    {
797      V lhs(valueless), rhs(i);
798      lhs.swap(rhs);
799      EXPECT_THAT(lhs, VariantWith<int>(i));
800      EXPECT_TRUE(rhs.valueless_by_exception());
801    }
802    {
803      V lhs(s), rhs(valueless);
804      lhs.swap(rhs);
805      EXPECT_THAT(rhs, VariantWith<std::string>(s));
806      EXPECT_TRUE(lhs.valueless_by_exception());
807    }
808    {
809      V lhs(valueless), rhs(valueless);
810      lhs.swap(rhs);
811      EXPECT_TRUE(lhs.valueless_by_exception());
812      EXPECT_TRUE(rhs.valueless_by_exception());
813    }
814  #endif  
815  }
816  TEST(VariantTest, VariantSize) {
817    {
818      using Size1Variant = absl::variant<int>;
819      EXPECT_EQ(1u, absl::variant_size<Size1Variant>::value);
820      EXPECT_EQ(1u, absl::variant_size<const Size1Variant>::value);
821      EXPECT_EQ(1u, absl::variant_size<volatile Size1Variant>::value);
822      EXPECT_EQ(1u, absl::variant_size<const volatile Size1Variant>::value);
823    }
824    {
825      using Size3Variant = absl::variant<int, float, int>;
826      EXPECT_EQ(3u, absl::variant_size<Size3Variant>::value);
827      EXPECT_EQ(3u, absl::variant_size<const Size3Variant>::value);
828      EXPECT_EQ(3u, absl::variant_size<volatile Size3Variant>::value);
829      EXPECT_EQ(3u, absl::variant_size<const volatile Size3Variant>::value);
830    }
831  }
832  TEST(VariantTest, VariantAlternative) {
833    {
834      using V = absl::variant<float, int, const char*>;
835      EXPECT_TRUE(
836          (std::is_same<float, absl::variant_alternative_t<0, V>>::value));
837      EXPECT_TRUE((std::is_same<const float,
838                                absl::variant_alternative_t<0, const V>>::value));
839      EXPECT_TRUE(
840          (std::is_same<volatile float,
841                        absl::variant_alternative_t<0, volatile V>>::value));
842      EXPECT_TRUE((
843          std::is_same<const volatile float,
844                       absl::variant_alternative_t<0, const volatile V>>::value));
845      EXPECT_TRUE((std::is_same<int, absl::variant_alternative_t<1, V>>::value));
846      EXPECT_TRUE((std::is_same<const int,
847                                absl::variant_alternative_t<1, const V>>::value));
848      EXPECT_TRUE(
849          (std::is_same<volatile int,
850                        absl::variant_alternative_t<1, volatile V>>::value));
851      EXPECT_TRUE((
852          std::is_same<const volatile int,
853                       absl::variant_alternative_t<1, const volatile V>>::value));
854      EXPECT_TRUE(
855          (std::is_same<const char*, absl::variant_alternative_t<2, V>>::value));
856      EXPECT_TRUE((std::is_same<const char* const,
857                                absl::variant_alternative_t<2, const V>>::value));
858      EXPECT_TRUE(
859          (std::is_same<const char* volatile,
860                        absl::variant_alternative_t<2, volatile V>>::value));
861      EXPECT_TRUE((
862          std::is_same<const char* const volatile,
863                       absl::variant_alternative_t<2, const volatile V>>::value));
864    }
865    {
866      using V = absl::variant<float, volatile int, const char*>;
867      EXPECT_TRUE(
868          (std::is_same<float, absl::variant_alternative_t<0, V>>::value));
869      EXPECT_TRUE((std::is_same<const float,
870                                absl::variant_alternative_t<0, const V>>::value));
871      EXPECT_TRUE(
872          (std::is_same<volatile float,
873                        absl::variant_alternative_t<0, volatile V>>::value));
874      EXPECT_TRUE((
875          std::is_same<const volatile float,
876                       absl::variant_alternative_t<0, const volatile V>>::value));
877      EXPECT_TRUE(
878          (std::is_same<volatile int, absl::variant_alternative_t<1, V>>::value));
879      EXPECT_TRUE((std::is_same<const volatile int,
880                                absl::variant_alternative_t<1, const V>>::value));
881      EXPECT_TRUE(
882          (std::is_same<volatile int,
883                        absl::variant_alternative_t<1, volatile V>>::value));
884      EXPECT_TRUE((
885          std::is_same<const volatile int,
886                       absl::variant_alternative_t<1, const volatile V>>::value));
887      EXPECT_TRUE(
888          (std::is_same<const char*, absl::variant_alternative_t<2, V>>::value));
889      EXPECT_TRUE((std::is_same<const char* const,
890                                absl::variant_alternative_t<2, const V>>::value));
891      EXPECT_TRUE(
892          (std::is_same<const char* volatile,
893                        absl::variant_alternative_t<2, volatile V>>::value));
894      EXPECT_TRUE((
895          std::is_same<const char* const volatile,
896                       absl::variant_alternative_t<2, const volatile V>>::value));
897    }
898  }
899  TEST(VariantTest, HoldsAlternative) {
900    using Var = variant<int, std::string, double>;
901    Var v = 1;
902    EXPECT_TRUE(absl::holds_alternative<int>(v));
903    EXPECT_FALSE(absl::holds_alternative<std::string>(v));
904    EXPECT_FALSE(absl::holds_alternative<double>(v));
905    v = "str";
906    EXPECT_FALSE(absl::holds_alternative<int>(v));
907    EXPECT_TRUE(absl::holds_alternative<std::string>(v));
908    EXPECT_FALSE(absl::holds_alternative<double>(v));
909    v = 0.;
910    EXPECT_FALSE(absl::holds_alternative<int>(v));
911    EXPECT_FALSE(absl::holds_alternative<std::string>(v));
912    EXPECT_TRUE(absl::holds_alternative<double>(v));
913    Var v2 = v;
914    EXPECT_FALSE(absl::holds_alternative<int>(v2));
915    EXPECT_FALSE(absl::holds_alternative<std::string>(v2));
916    EXPECT_TRUE(absl::holds_alternative<double>(v2));
917    v2.emplace<int>(3);
918    EXPECT_TRUE(absl::holds_alternative<int>(v2));
919    EXPECT_FALSE(absl::holds_alternative<std::string>(v2));
920    EXPECT_FALSE(absl::holds_alternative<double>(v2));
921  }
922  TEST(VariantTest, GetIndex) {
923    using Var = variant<int, std::string, double, int>;
924    {
925      Var v(absl::in_place_index<0>, 0);
926      using LValueGetType = decltype(absl::get<0>(v));
927      using RValueGetType = decltype(absl::get<0>(absl::move(v)));
928      EXPECT_TRUE((std::is_same<LValueGetType, int&>::value));
929      EXPECT_TRUE((std::is_same<RValueGetType, int&&>::value));
930      EXPECT_EQ(absl::get<0>(v), 0);
931      EXPECT_EQ(absl::get<0>(absl::move(v)), 0);
932      const Var& const_v = v;
933      using ConstLValueGetType = decltype(absl::get<0>(const_v));
934      using ConstRValueGetType = decltype(absl::get<0>(absl::move(const_v)));
935      EXPECT_TRUE((std::is_same<ConstLValueGetType, const int&>::value));
936      EXPECT_TRUE((std::is_same<ConstRValueGetType, const int&&>::value));
937      EXPECT_EQ(absl::get<0>(const_v), 0);
938      EXPECT_EQ(absl::get<0>(absl::move(const_v)), 0);
939    }
940    {
941      Var v = std::string("Hello");
942      using LValueGetType = decltype(absl::get<1>(v));
943      using RValueGetType = decltype(absl::get<1>(absl::move(v)));
944      EXPECT_TRUE((std::is_same<LValueGetType, std::string&>::value));
945      EXPECT_TRUE((std::is_same<RValueGetType, std::string&&>::value));
946      EXPECT_EQ(absl::get<1>(v), "Hello");
947      EXPECT_EQ(absl::get<1>(absl::move(v)), "Hello");
948      const Var& const_v = v;
949      using ConstLValueGetType = decltype(absl::get<1>(const_v));
950      using ConstRValueGetType = decltype(absl::get<1>(absl::move(const_v)));
951      EXPECT_TRUE((std::is_same<ConstLValueGetType, const std::string&>::value));
952      EXPECT_TRUE((std::is_same<ConstRValueGetType, const std::string&&>::value));
953      EXPECT_EQ(absl::get<1>(const_v), "Hello");
954      EXPECT_EQ(absl::get<1>(absl::move(const_v)), "Hello");
955    }
956    {
957      Var v = 2.0;
958      using LValueGetType = decltype(absl::get<2>(v));
959      using RValueGetType = decltype(absl::get<2>(absl::move(v)));
960      EXPECT_TRUE((std::is_same<LValueGetType, double&>::value));
961      EXPECT_TRUE((std::is_same<RValueGetType, double&&>::value));
962      EXPECT_EQ(absl::get<2>(v), 2.);
963      EXPECT_EQ(absl::get<2>(absl::move(v)), 2.);
964      const Var& const_v = v;
965      using ConstLValueGetType = decltype(absl::get<2>(const_v));
966      using ConstRValueGetType = decltype(absl::get<2>(absl::move(const_v)));
967      EXPECT_TRUE((std::is_same<ConstLValueGetType, const double&>::value));
968      EXPECT_TRUE((std::is_same<ConstRValueGetType, const double&&>::value));
969      EXPECT_EQ(absl::get<2>(const_v), 2.);
970      EXPECT_EQ(absl::get<2>(absl::move(const_v)), 2.);
971    }
972    {
973      Var v(absl::in_place_index<0>, 0);
974      v.emplace<3>(1);
975      using LValueGetType = decltype(absl::get<3>(v));
976      using RValueGetType = decltype(absl::get<3>(absl::move(v)));
977      EXPECT_TRUE((std::is_same<LValueGetType, int&>::value));
978      EXPECT_TRUE((std::is_same<RValueGetType, int&&>::value));
979      EXPECT_EQ(absl::get<3>(v), 1);
980      EXPECT_EQ(absl::get<3>(absl::move(v)), 1);
981      const Var& const_v = v;
982      using ConstLValueGetType = decltype(absl::get<3>(const_v));
983      using ConstRValueGetType = decltype(absl::get<3>(absl::move(const_v)));
984      EXPECT_TRUE((std::is_same<ConstLValueGetType, const int&>::value));
985      EXPECT_TRUE((std::is_same<ConstRValueGetType, const int&&>::value));
986      EXPECT_EQ(absl::get<3>(const_v), 1);
987      EXPECT_EQ(absl::get<3>(absl::move(const_v)), 1);  
988    }
989  }
990  TEST(VariantTest, BadGetIndex) {
991    using Var = variant<int, std::string, double>;
992    {
993      Var v = 1;
994      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(absl::get<1>(v));
995      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(absl::get<1>(std::move(v)));
996      const Var& const_v = v;
997      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(absl::get<1>(const_v));
998      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(
999          absl::get<1>(std::move(const_v)));  
1000    }
1001    {
1002      Var v = std::string("Hello");
1003      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(absl::get<0>(v));
1004      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(absl::get<0>(std::move(v)));
1005      const Var& const_v = v;
1006      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(absl::get<0>(const_v));
1007      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(
1008          absl::get<0>(std::move(const_v)));  
1009    }
1010  }
1011  TEST(VariantTest, GetType) {
1012    using Var = variant<int, std::string, double>;
1013    {
1014      Var v = 1;
1015      using LValueGetType = decltype(absl::get<int>(v));
1016      using RValueGetType = decltype(absl::get<int>(absl::move(v)));
1017      EXPECT_TRUE((std::is_same<LValueGetType, int&>::value));
1018      EXPECT_TRUE((std::is_same<RValueGetType, int&&>::value));
1019      EXPECT_EQ(absl::get<int>(v), 1);
1020      EXPECT_EQ(absl::get<int>(absl::move(v)), 1);
1021      const Var& const_v = v;
1022      using ConstLValueGetType = decltype(absl::get<int>(const_v));
1023      using ConstRValueGetType = decltype(absl::get<int>(absl::move(const_v)));
1024      EXPECT_TRUE((std::is_same<ConstLValueGetType, const int&>::value));
1025      EXPECT_TRUE((std::is_same<ConstRValueGetType, const int&&>::value));
1026      EXPECT_EQ(absl::get<int>(const_v), 1);
1027      EXPECT_EQ(absl::get<int>(absl::move(const_v)), 1);
1028    }
1029    {
1030      Var v = std::string("Hello");
1031      using LValueGetType = decltype(absl::get<1>(v));
1032      using RValueGetType = decltype(absl::get<1>(absl::move(v)));
1033      EXPECT_TRUE((std::is_same<LValueGetType, std::string&>::value));
1034      EXPECT_TRUE((std::is_same<RValueGetType, std::string&&>::value));
1035      EXPECT_EQ(absl::get<std::string>(v), "Hello");
1036      EXPECT_EQ(absl::get<std::string>(absl::move(v)), "Hello");
1037      const Var& const_v = v;
1038      using ConstLValueGetType = decltype(absl::get<1>(const_v));
1039      using ConstRValueGetType = decltype(absl::get<1>(absl::move(const_v)));
1040      EXPECT_TRUE((std::is_same<ConstLValueGetType, const std::string&>::value));
1041      EXPECT_TRUE((std::is_same<ConstRValueGetType, const std::string&&>::value));
1042      EXPECT_EQ(absl::get<std::string>(const_v), "Hello");
1043      EXPECT_EQ(absl::get<std::string>(absl::move(const_v)), "Hello");
1044    }
1045    {
1046      Var v = 2.0;
1047      using LValueGetType = decltype(absl::get<2>(v));
1048      using RValueGetType = decltype(absl::get<2>(absl::move(v)));
1049      EXPECT_TRUE((std::is_same<LValueGetType, double&>::value));
1050      EXPECT_TRUE((std::is_same<RValueGetType, double&&>::value));
1051      EXPECT_EQ(absl::get<double>(v), 2.);
1052      EXPECT_EQ(absl::get<double>(absl::move(v)), 2.);
1053      const Var& const_v = v;
1054      using ConstLValueGetType = decltype(absl::get<2>(const_v));
1055      using ConstRValueGetType = decltype(absl::get<2>(absl::move(const_v)));
1056      EXPECT_TRUE((std::is_same<ConstLValueGetType, const double&>::value));
1057      EXPECT_TRUE((std::is_same<ConstRValueGetType, const double&&>::value));
1058      EXPECT_EQ(absl::get<double>(const_v), 2.);
1059      EXPECT_EQ(absl::get<double>(absl::move(const_v)), 2.);
1060    }
1061  }
1062  TEST(VariantTest, BadGetType) {
1063    using Var = variant<int, std::string, double>;
1064    {
1065      Var v = 1;
1066      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(absl::get<std::string>(v));
1067      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(
1068          absl::get<std::string>(std::move(v)));
1069      const Var& const_v = v;
1070      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(
1071          absl::get<std::string>(const_v));
1072      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(
1073          absl::get<std::string>(std::move(const_v)));  
1074    }
1075    {
1076      Var v = std::string("Hello");
1077      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(absl::get<int>(v));
1078      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(absl::get<int>(std::move(v)));
1079      const Var& const_v = v;
1080      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(absl::get<int>(const_v));
1081      ABSL_VARIANT_TEST_EXPECT_BAD_VARIANT_ACCESS(
1082          absl::get<int>(std::move(const_v)));  
1083    }
1084  }
1085  TEST(VariantTest, GetIfIndex) {
1086    using Var = variant<int, std::string, double, int>;
1087    {
1088      Var v(absl::in_place_index<0>, 0);
1089      EXPECT_TRUE(noexcept(absl::get_if<0>(&v)));
1090      {
1091        auto* elem = absl::get_if<0>(&v);
1092        EXPECT_TRUE((std::is_same<decltype(elem), int*>::value));
1093        ASSERT_NE(elem, nullptr);
1094        EXPECT_EQ(*elem, 0);
1095        {
1096          auto* bad_elem = absl::get_if<1>(&v);
1097          EXPECT_TRUE((std::is_same<decltype(bad_elem), std::string*>::value));
1098          EXPECT_EQ(bad_elem, nullptr);
1099        }
1100        {
1101          auto* bad_elem = absl::get_if<2>(&v);
1102          EXPECT_TRUE((std::is_same<decltype(bad_elem), double*>::value));
1103          EXPECT_EQ(bad_elem, nullptr);
1104        }
1105        {
1106          auto* bad_elem = absl::get_if<3>(&v);
1107          EXPECT_TRUE((std::is_same<decltype(bad_elem), int*>::value));
1108          EXPECT_EQ(bad_elem, nullptr);
1109        }
1110      }
1111      const Var& const_v = v;
1112      EXPECT_TRUE(noexcept(absl::get_if<0>(&const_v)));
1113      {
1114        auto* elem = absl::get_if<0>(&const_v);
1115        EXPECT_TRUE((std::is_same<decltype(elem), const int*>::value));
1116        ASSERT_NE(elem, nullptr);
1117        EXPECT_EQ(*elem, 0);
1118        {
1119          auto* bad_elem = absl::get_if<1>(&const_v);
1120          EXPECT_TRUE(
1121              (std::is_same<decltype(bad_elem), const std::string*>::value));
1122          EXPECT_EQ(bad_elem, nullptr);
1123        }
1124        {
1125          auto* bad_elem = absl::get_if<2>(&const_v);
1126          EXPECT_TRUE((std::is_same<decltype(bad_elem), const double*>::value));
1127          EXPECT_EQ(bad_elem, nullptr);
1128        }
1129        {
1130          auto* bad_elem = absl::get_if<3>(&const_v);
1131          EXPECT_EQ(bad_elem, nullptr);
1132          EXPECT_TRUE((std::is_same<decltype(bad_elem), const int*>::value));
1133        }
1134      }
1135    }
1136    {
1137      Var v = std::string("Hello");
1138      EXPECT_TRUE(noexcept(absl::get_if<1>(&v)));
1139      {
1140        auto* elem = absl::get_if<1>(&v);
1141        EXPECT_TRUE((std::is_same<decltype(elem), std::string*>::value));
1142        ASSERT_NE(elem, nullptr);
1143        EXPECT_EQ(*elem, "Hello");
1144        {
1145          auto* bad_elem = absl::get_if<0>(&v);
1146          EXPECT_TRUE((std::is_same<decltype(bad_elem), int*>::value));
1147          EXPECT_EQ(bad_elem, nullptr);
1148        }
1149        {
1150          auto* bad_elem = absl::get_if<2>(&v);
1151          EXPECT_TRUE((std::is_same<decltype(bad_elem), double*>::value));
1152          EXPECT_EQ(bad_elem, nullptr);
1153        }
1154        {
1155          auto* bad_elem = absl::get_if<3>(&v);
1156          EXPECT_TRUE((std::is_same<decltype(bad_elem), int*>::value));
1157          EXPECT_EQ(bad_elem, nullptr);
1158        }
1159      }
1160      const Var& const_v = v;
1161      EXPECT_TRUE(noexcept(absl::get_if<1>(&const_v)));
1162      {
1163        auto* elem = absl::get_if<1>(&const_v);
1164        EXPECT_TRUE((std::is_same<decltype(elem), const std::string*>::value));
1165        ASSERT_NE(elem, nullptr);
1166        EXPECT_EQ(*elem, "Hello");
1167        {
1168          auto* bad_elem = absl::get_if<0>(&const_v);
1169          EXPECT_TRUE((std::is_same<decltype(bad_elem), const int*>::value));
1170          EXPECT_EQ(bad_elem, nullptr);
1171        }
1172        {
1173          auto* bad_elem = absl::get_if<2>(&const_v);
1174          EXPECT_TRUE((std::is_same<decltype(bad_elem), const double*>::value));
1175          EXPECT_EQ(bad_elem, nullptr);
1176        }
1177        {
1178          auto* bad_elem = absl::get_if<3>(&const_v);
1179          EXPECT_EQ(bad_elem, nullptr);
1180          EXPECT_TRUE((std::is_same<decltype(bad_elem), const int*>::value));
1181        }
1182      }
1183    }
1184    {
1185      Var v = 2.0;
1186      EXPECT_TRUE(noexcept(absl::get_if<2>(&v)));
1187      {
1188        auto* elem = absl::get_if<2>(&v);
1189        EXPECT_TRUE((std::is_same<decltype(elem), double*>::value));
1190        ASSERT_NE(elem, nullptr);
1191        EXPECT_EQ(*elem, 2.0);
1192        {
1193          auto* bad_elem = absl::get_if<0>(&v);
1194          EXPECT_TRUE((std::is_same<decltype(bad_elem), int*>::value));
1195          EXPECT_EQ(bad_elem, nullptr);
1196        }
1197        {
1198          auto* bad_elem = absl::get_if<1>(&v);
1199          EXPECT_TRUE((std::is_same<decltype(bad_elem), std::string*>::value));
1200          EXPECT_EQ(bad_elem, nullptr);
1201        }
1202        {
1203          auto* bad_elem = absl::get_if<3>(&v);
1204          EXPECT_TRUE((std::is_same<decltype(bad_elem), int*>::value));
1205          EXPECT_EQ(bad_elem, nullptr);
1206        }
1207      }
1208      const Var& const_v = v;
1209      EXPECT_TRUE(noexcept(absl::get_if<2>(&const_v)));
1210      {
1211        auto* elem = absl::get_if<2>(&const_v);
1212        EXPECT_TRUE((std::is_same<decltype(elem), const double*>::value));
1213        ASSERT_NE(elem, nullptr);
1214        EXPECT_EQ(*elem, 2.0);
1215        {
1216          auto* bad_elem = absl::get_if<0>(&const_v);
1217          EXPECT_TRUE((std::is_same<decltype(bad_elem), const int*>::value));
1218          EXPECT_EQ(bad_elem, nullptr);
1219        }
1220        {
1221          auto* bad_elem = absl::get_if<1>(&const_v);
1222          EXPECT_TRUE(
1223              (std::is_same<decltype(bad_elem), const std::string*>::value));
1224          EXPECT_EQ(bad_elem, nullptr);
1225        }
1226        {
1227          auto* bad_elem = absl::get_if<3>(&const_v);
1228          EXPECT_EQ(bad_elem, nullptr);
1229          EXPECT_TRUE((std::is_same<decltype(bad_elem), const int*>::value));
1230        }
1231      }
1232    }
1233    {
1234      Var v(absl::in_place_index<0>, 0);
1235      v.emplace<3>(1);
1236      EXPECT_TRUE(noexcept(absl::get_if<3>(&v)));
1237      {
1238        auto* elem = absl::get_if<3>(&v);
1239        EXPECT_TRUE((std::is_same<decltype(elem), int*>::value));
1240        ASSERT_NE(elem, nullptr);
1241        EXPECT_EQ(*elem, 1);
1242        {
1243          auto* bad_elem = absl::get_if<0>(&v);
1244          EXPECT_TRUE((std::is_same<decltype(bad_elem), int*>::value));
1245          EXPECT_EQ(bad_elem, nullptr);
1246        }
1247        {
1248          auto* bad_elem = absl::get_if<1>(&v);
1249          EXPECT_TRUE((std::is_same<decltype(bad_elem), std::string*>::value));
1250          EXPECT_EQ(bad_elem, nullptr);
1251        }
1252        {
1253          auto* bad_elem = absl::get_if<2>(&v);
1254          EXPECT_TRUE((std::is_same<decltype(bad_elem), double*>::value));
1255          EXPECT_EQ(bad_elem, nullptr);
1256        }
1257      }
1258      const Var& const_v = v;
1259      EXPECT_TRUE(noexcept(absl::get_if<3>(&const_v)));
1260      {
1261        auto* elem = absl::get_if<3>(&const_v);
1262        EXPECT_TRUE((std::is_same<decltype(elem), const int*>::value));
1263        ASSERT_NE(elem, nullptr);
1264        EXPECT_EQ(*elem, 1);
1265        {
1266          auto* bad_elem = absl::get_if<0>(&const_v);
1267          EXPECT_TRUE((std::is_same<decltype(bad_elem), const int*>::value));
1268          EXPECT_EQ(bad_elem, nullptr);
1269        }
1270        {
1271          auto* bad_elem = absl::get_if<1>(&const_v);
1272          EXPECT_TRUE(
1273              (std::is_same<decltype(bad_elem), const std::string*>::value));
1274          EXPECT_EQ(bad_elem, nullptr);
1275        }
1276        {
1277          auto* bad_elem = absl::get_if<2>(&const_v);
1278          EXPECT_EQ(bad_elem, nullptr);
1279          EXPECT_TRUE((std::is_same<decltype(bad_elem), const double*>::value));
1280        }
1281      }
1282    }
1283  }
1284  TEST(VariantTest, OperatorEquals) {
1285    variant<int, std::string> a(1), b(1);
1286    EXPECT_TRUE(a == b);
1287    EXPECT_TRUE(b == a);
1288    EXPECT_FALSE(a != b);
1289    EXPECT_FALSE(b != a);
1290    b = "str";
1291    EXPECT_FALSE(a == b);
1292    EXPECT_FALSE(b == a);
1293    EXPECT_TRUE(a != b);
1294    EXPECT_TRUE(b != a);
1295    b = 0;
1296    EXPECT_FALSE(a == b);
1297    EXPECT_FALSE(b == a);
1298    EXPECT_TRUE(a != b);
1299    EXPECT_TRUE(b != a);
1300    a = b = "foo";
1301    EXPECT_TRUE(a == b);
1302    EXPECT_TRUE(b == a);
1303    EXPECT_FALSE(a != b);
1304    EXPECT_FALSE(b != a);
1305    a = "bar";
1306    EXPECT_FALSE(a == b);
1307    EXPECT_FALSE(b == a);
1308    EXPECT_TRUE(a != b);
1309    EXPECT_TRUE(b != a);
1310  }
1311  TEST(VariantTest, OperatorRelational) {
1312    variant<int, std::string> a(1), b(1);
1313    EXPECT_FALSE(a < b);
1314    EXPECT_FALSE(b < a);
1315    EXPECT_FALSE(a > b);
1316    EXPECT_FALSE(b > a);
1317    EXPECT_TRUE(a <= b);
1318    EXPECT_TRUE(b <= a);
1319    EXPECT_TRUE(a >= b);
1320    EXPECT_TRUE(b >= a);
1321    b = "str";
1322    EXPECT_TRUE(a < b);
1323    EXPECT_FALSE(b < a);
1324    EXPECT_FALSE(a > b);
1325    EXPECT_TRUE(b > a);
1326    EXPECT_TRUE(a <= b);
1327    EXPECT_FALSE(b <= a);
1328    EXPECT_FALSE(a >= b);
1329    EXPECT_TRUE(b >= a);
1330    b = 0;
1331    EXPECT_FALSE(a < b);
1332    EXPECT_TRUE(b < a);
1333    EXPECT_TRUE(a > b);
1334    EXPECT_FALSE(b > a);
1335    EXPECT_FALSE(a <= b);
1336    EXPECT_TRUE(b <= a);
1337    EXPECT_TRUE(a >= b);
1338    EXPECT_FALSE(b >= a);
1339    a = b = "foo";
1340    EXPECT_FALSE(a < b);
1341    EXPECT_FALSE(b < a);
1342    EXPECT_FALSE(a > b);
1343    EXPECT_FALSE(b > a);
1344    EXPECT_TRUE(a <= b);
1345    EXPECT_TRUE(b <= a);
1346    EXPECT_TRUE(a >= b);
1347    EXPECT_TRUE(b >= a);
1348    a = "bar";
1349    EXPECT_TRUE(a < b);
1350    EXPECT_FALSE(b < a);
1351    EXPECT_FALSE(a > b);
1352    EXPECT_TRUE(b > a);
1353    EXPECT_TRUE(a <= b);
1354    EXPECT_FALSE(b <= a);
1355    EXPECT_FALSE(a >= b);
1356    EXPECT_TRUE(b >= a);
1357  }
1358  #ifdef ABSL_HAVE_EXCEPTIONS
1359  TEST(VariantTest, ValuelessOperatorEquals) {
1360    variant<MoveCanThrow, std::string> int_v(1), string_v("Hello"),
1361        valueless(absl::in_place_index<0>),
1362        other_valueless(absl::in_place_index<0>);
1363    ToValuelessByException(valueless);
1364    ToValuelessByException(other_valueless);
1365    EXPECT_TRUE(valueless == other_valueless);
1366    EXPECT_TRUE(other_valueless == valueless);
1367    EXPECT_FALSE(valueless == int_v);
1368    EXPECT_FALSE(valueless == string_v);
1369    EXPECT_FALSE(int_v == valueless);
1370    EXPECT_FALSE(string_v == valueless);
1371    EXPECT_FALSE(valueless != other_valueless);
1372    EXPECT_FALSE(other_valueless != valueless);
1373    EXPECT_TRUE(valueless != int_v);
1374    EXPECT_TRUE(valueless != string_v);
1375    EXPECT_TRUE(int_v != valueless);
1376    EXPECT_TRUE(string_v != valueless);
1377  }
1378  TEST(VariantTest, ValuelessOperatorRelational) {
1379    variant<MoveCanThrow, std::string> int_v(1), string_v("Hello"),
1380        valueless(absl::in_place_index<0>),
1381        other_valueless(absl::in_place_index<0>);
1382    ToValuelessByException(valueless);
1383    ToValuelessByException(other_valueless);
1384    EXPECT_FALSE(valueless < other_valueless);
1385    EXPECT_FALSE(other_valueless < valueless);
1386    EXPECT_TRUE(valueless < int_v);
1387    EXPECT_TRUE(valueless < string_v);
1388    EXPECT_FALSE(int_v < valueless);
1389    EXPECT_FALSE(string_v < valueless);
1390    EXPECT_TRUE(valueless <= other_valueless);
1391    EXPECT_TRUE(other_valueless <= valueless);
1392    EXPECT_TRUE(valueless <= int_v);
1393    EXPECT_TRUE(valueless <= string_v);
1394    EXPECT_FALSE(int_v <= valueless);
1395    EXPECT_FALSE(string_v <= valueless);
1396    EXPECT_TRUE(valueless >= other_valueless);
1397    EXPECT_TRUE(other_valueless >= valueless);
1398    EXPECT_FALSE(valueless >= int_v);
1399    EXPECT_FALSE(valueless >= string_v);
1400    EXPECT_TRUE(int_v >= valueless);
1401    EXPECT_TRUE(string_v >= valueless);
1402    EXPECT_FALSE(valueless > other_valueless);
1403    EXPECT_FALSE(other_valueless > valueless);
1404    EXPECT_FALSE(valueless > int_v);
1405    EXPECT_FALSE(valueless > string_v);
1406    EXPECT_TRUE(int_v > valueless);
1407    EXPECT_TRUE(string_v > valueless);
1408  }
1409  #endif
1410  template <typename T>
1411  struct ConvertTo {
1412    template <typename U>
1413    T operator()(const U& u) const {
1414      return u;
1415    }
1416  };
1417  TEST(VariantTest, VisitSimple) {
1418    variant<std::string, const char*> v = "A";
1419    std::string str = absl::visit(ConvertTo<std::string>{}, v);
1420    EXPECT_EQ("A", str);
1421    v = std::string("B");
1422    absl::string_view piece = absl::visit(ConvertTo<absl::string_view>{}, v);
1423    EXPECT_EQ("B", piece);
1424    struct StrLen {
1425      size_t operator()(const char* s) const { return strlen(s); }
1426      size_t operator()(const std::string& s) const { return s.size(); }
1427    };
1428    v = "SomeStr";
1429    EXPECT_EQ(7u, absl::visit(StrLen{}, v));
1430    v = std::string("VeryLargeThisTime");
1431    EXPECT_EQ(17u, absl::visit(StrLen{}, v));
1432  }
1433  TEST(VariantTest, VisitRValue) {
1434    variant<std::string> v = std::string("X");
1435    struct Visitor {
1436      bool operator()(const std::string&) const { return false; }
1437      bool operator()(std::string&&) const { return true; }  
1438      int operator()(const std::string&, const std::string&) const { return 0; }
1439      int operator()(const std::string&, std::string&&) const {
1440        return 1;
1441      }  
1442      int operator()(std::string&&, const std::string&) const {
1443        return 2;
1444      }                                                                 
1445      int operator()(std::string&&, std::string&&) const { return 3; }  
1446    };
1447    EXPECT_FALSE(absl::visit(Visitor{}, v));
1448    EXPECT_TRUE(absl::visit(Visitor{}, absl::move(v)));
1449    EXPECT_EQ(0, absl::visit(Visitor{}, v, v));
1450    EXPECT_EQ(1, absl::visit(Visitor{}, v, absl::move(v)));
1451    EXPECT_EQ(2, absl::visit(Visitor{}, absl::move(v), v));
1452    EXPECT_EQ(3, absl::visit(Visitor{}, absl::move(v), absl::move(v)));
1453  }
1454  TEST(VariantTest, VisitRValueVisitor) {
1455    variant<std::string> v = std::string("X");
1456    struct Visitor {
1457      bool operator()(const std::string&) const& { return false; }
1458      bool operator()(const std::string&) && { return true; }
1459    };
1460    Visitor visitor;
1461    EXPECT_FALSE(absl::visit(visitor, v));
1462    EXPECT_TRUE(absl::visit(Visitor{}, v));
1463  }
1464  TEST(VariantTest, VisitResultTypeDifferent) {
1465    variant<std::string> v = std::string("X");
1466    struct LValue_LValue {};
1467    struct RValue_LValue {};
1468    struct LValue_RValue {};
1469    struct RValue_RValue {};
1470    struct Visitor {
1471      LValue_LValue operator()(const std::string&) const& { return {}; }
1472      RValue_LValue operator()(std::string&&) const& { return {}; }  
1473      LValue_RValue operator()(const std::string&) && { return {}; }
1474      RValue_RValue operator()(std::string&&) && { return {}; }  
1475    } visitor;
1476    EXPECT_TRUE(
1477        (std::is_same<LValue_LValue, decltype(absl::visit(visitor, v))>::value));
1478    EXPECT_TRUE(
1479        (std::is_same<RValue_LValue,
1480                      decltype(absl::visit(visitor, absl::move(v)))>::value));
1481    EXPECT_TRUE((
1482        std::is_same<LValue_RValue, decltype(absl::visit(Visitor{}, v))>::value));
1483    EXPECT_TRUE(
1484        (std::is_same<RValue_RValue,
1485                      decltype(absl::visit(Visitor{}, absl::move(v)))>::value));
1486  }
1487  TEST(VariantTest, VisitVariadic) {
1488    using A = variant<int, std::string>;
1489    using B = variant<std::unique_ptr<int>, absl::string_view>;
1490    struct Visitor {
1491      std::pair<int, int> operator()(int a, std::unique_ptr<int> b) const {
1492        return {a, *b};
1493      }
1494      std::pair<int, int> operator()(absl::string_view a,
1495                                     std::unique_ptr<int> b) const {
1496        return {static_cast<int>(a.size()), static_cast<int>(*b)};
1497      }
1498      std::pair<int, int> operator()(int a, absl::string_view b) const {
1499        return {a, static_cast<int>(b.size())};
1500      }
1501      std::pair<int, int> operator()(absl::string_view a,
1502                                     absl::string_view b) const {
1503        return {static_cast<int>(a.size()), static_cast<int>(b.size())};
1504      }
1505    };
1506    EXPECT_THAT(absl::visit(Visitor(), A(1), B(std::unique_ptr<int>(new int(7)))),
1507                ::testing::Pair(1, 7));
1508    EXPECT_THAT(absl::visit(Visitor(), A(1), B(absl::string_view("ABC"))),
1509                ::testing::Pair(1, 3));
1510    EXPECT_THAT(absl::visit(Visitor(), A(std::string("BBBBB")),
1511                            B(std::unique_ptr<int>(new int(7)))),
1512                ::testing::Pair(5, 7));
1513    EXPECT_THAT(absl::visit(Visitor(), A(std::string("BBBBB")),
1514                            B(absl::string_view("ABC"))),
1515                ::testing::Pair(5, 3));
1516  }
1517  TEST(VariantTest, VisitNoArgs) {
1518    EXPECT_EQ(5, absl::visit([] { return 5; }));
1519  }
1520  struct ConstFunctor {
1521    int operator()(int a, int b) const { return a - b; }
1522  };
1523  struct MutableFunctor {
1524    int operator()(int a, int b) { return a - b; }
1525  };
1526  struct Class {
1527    int Method(int a, int b) { return a - b; }
1528    int ConstMethod(int a, int b) const { return a - b; }
1529    int member;
1530  };
1531  TEST(VariantTest, VisitReferenceWrapper) {
1532    ConstFunctor cf;
1533    MutableFunctor mf;
1534    absl::variant<int> three = 3;
1535    absl::variant<int> two = 2;
1536    EXPECT_EQ(1, absl::visit(std::cref(cf), three, two));
1537    EXPECT_EQ(1, absl::visit(std::ref(cf), three, two));
1538    EXPECT_EQ(1, absl::visit(std::ref(mf), three, two));
1539  }
1540  #if !(defined(ABSL_USES_STD_VARIANT) && defined(__GLIBCXX__))
1541  TEST(VariantTest, VisitMemberFunction) {
1542    absl::variant<std::unique_ptr<Class>> p(absl::make_unique<Class>());
1543    absl::variant<std::unique_ptr<const Class>> cp(
1544        absl::make_unique<const Class>());
1545    absl::variant<int> three = 3;
1546    absl::variant<int> two = 2;
1547    EXPECT_EQ(1, absl::visit(&Class::Method, p, three, two));
1548    EXPECT_EQ(1, absl::visit(&Class::ConstMethod, p, three, two));
1549    EXPECT_EQ(1, absl::visit(&Class::ConstMethod, cp, three, two));
1550  }
1551  TEST(VariantTest, VisitDataMember) {
1552    absl::variant<std::unique_ptr<Class>> p(absl::make_unique<Class>(Class{42}));
1553    absl::variant<std::unique_ptr<const Class>> cp(
1554        absl::make_unique<const Class>(Class{42}));
1555    EXPECT_EQ(42, absl::visit(&Class::member, p));
1556    absl::visit(&Class::member, p) = 5;
1557    EXPECT_EQ(5, absl::visit(&Class::member, p));
1558    EXPECT_EQ(42, absl::visit(&Class::member, cp));
1559  }
1560  #endif  
1561  TEST(VariantTest, MonostateBasic) {
1562    absl::monostate mono;
1563    (void)mono;
1564    EXPECT_TRUE(absl::is_trivially_default_constructible<absl::monostate>::value);
1565    EXPECT_TRUE(is_trivially_move_constructible<absl::monostate>::value);
1566    EXPECT_TRUE(absl::is_trivially_copy_constructible<absl::monostate>::value);
1567    EXPECT_TRUE(is_trivially_move_assignable<absl::monostate>::value);
1568    EXPECT_TRUE(absl::is_trivially_copy_assignable<absl::monostate>::value);
1569    EXPECT_TRUE(absl::is_trivially_destructible<absl::monostate>::value);
1570  }
1571  TEST(VariantTest, VariantMonostateDefaultConstruction) {
1572    absl::variant<absl::monostate, NonDefaultConstructible> var;
1573    EXPECT_EQ(var.index(), 0u);
1574  }
1575  TEST(VariantTest, MonostateComparisons) {
1576    absl::monostate lhs, rhs;
1577    EXPECT_EQ(lhs, lhs);
1578    EXPECT_EQ(lhs, rhs);
1579    EXPECT_FALSE(lhs != lhs);
1580    EXPECT_FALSE(lhs != rhs);
1581    EXPECT_FALSE(lhs < lhs);
1582    EXPECT_FALSE(lhs < rhs);
1583    EXPECT_FALSE(lhs > lhs);
1584    EXPECT_FALSE(lhs > rhs);
1585    EXPECT_LE(lhs, lhs);
1586    EXPECT_LE(lhs, rhs);
1587    EXPECT_GE(lhs, lhs);
1588    EXPECT_GE(lhs, rhs);
1589    EXPECT_TRUE(noexcept(std::declval<absl::monostate>() ==
1590                         std::declval<absl::monostate>()));
1591    EXPECT_TRUE(noexcept(std::declval<absl::monostate>() !=
1592                         std::declval<absl::monostate>()));
1593    EXPECT_TRUE(noexcept(std::declval<absl::monostate>() <
1594                         std::declval<absl::monostate>()));
1595    EXPECT_TRUE(noexcept(std::declval<absl::monostate>() >
1596                         std::declval<absl::monostate>()));
1597    EXPECT_TRUE(noexcept(std::declval<absl::monostate>() <=
1598                         std::declval<absl::monostate>()));
1599    EXPECT_TRUE(noexcept(std::declval<absl::monostate>() >=
1600                         std::declval<absl::monostate>()));
1601  }
1602  TEST(VariantTest, NonmemberSwap) {
1603    using std::swap;
1604    SpecialSwap v1(3);
1605    SpecialSwap v2(7);
1606    variant<SpecialSwap> a = v1, b = v2;
1607    EXPECT_THAT(a, VariantWith<SpecialSwap>(v1));
1608    EXPECT_THAT(b, VariantWith<SpecialSwap>(v2));
1609    std::swap(a, b);
1610    EXPECT_THAT(a, VariantWith<SpecialSwap>(v2));
1611    EXPECT_THAT(b, VariantWith<SpecialSwap>(v1));
1612  #ifndef ABSL_USES_STD_VARIANT
1613    EXPECT_FALSE(absl::get<SpecialSwap>(a).special_swap);
1614  #endif
1615    swap(a, b);
1616    EXPECT_THAT(a, VariantWith<SpecialSwap>(v1));
1617    EXPECT_THAT(b, VariantWith<SpecialSwap>(v2));
1618    EXPECT_TRUE(absl::get<SpecialSwap>(b).special_swap);
1619  }
1620  TEST(VariantTest, BadAccess) {
1621    EXPECT_TRUE(noexcept(absl::bad_variant_access()));
1622    absl::bad_variant_access exception_obj;
1623    std::exception* base = &exception_obj;
1624    (void)base;
1625  }
1626  TEST(VariantTest, MonostateHash) {
1627    absl::monostate mono, other_mono;
1628    std::hash<absl::monostate> const hasher{};
1629    static_assert(std::is_same<decltype(hasher(mono)), std::size_t>::value, "");
1630    EXPECT_EQ(hasher(mono), hasher(other_mono));
1631  }
1632  TEST(VariantTest, Hash) {
1633    static_assert(type_traits_internal::IsHashable<variant<int>>::value, "");
1634    static_assert(type_traits_internal::IsHashable<variant<Hashable>>::value, "");
1635    static_assert(type_traits_internal::IsHashable<variant<int, Hashable>>::value,
1636                  "");
1637  #if ABSL_META_INTERNAL_STD_HASH_SFINAE_FRIENDLY_
1638    static_assert(!type_traits_internal::IsHashable<variant<NonHashable>>::value,
1639                  "");
1640    static_assert(
1641        !type_traits_internal::IsHashable<variant<Hashable, NonHashable>>::value,
1642        "");
1643  #endif
1644  #if !(defined(_MSC_VER) && defined(ABSL_USES_STD_VARIANT))
1645    {
1646      variant<int, int> v0(in_place_index<0>, 42);
1647      variant<int, int> v1(in_place_index<1>, 42);
1648      std::hash<variant<int, int>> hash;
1649      EXPECT_NE(hash(v0), hash(v1));
1650    }
1651  #endif  
1652    {
1653      std::hash<variant<int>> hash;
1654      std::set<size_t> hashcodes;
1655      for (int i = 0; i < 100; ++i) {
1656        hashcodes.insert(hash(i));
1657      }
1658      EXPECT_GT(hashcodes.size(), 90u);
1659      static_assert(type_traits_internal::IsHashable<variant<const int>>::value,
1660                    "");
1661      static_assert(
1662          type_traits_internal::IsHashable<variant<const Hashable>>::value, "");
1663      std::hash<absl::variant<const int>> c_hash;
1664      for (int i = 0; i < 100; ++i) {
1665        EXPECT_EQ(hash(i), c_hash(i));
1666      }
1667    }
1668  }
1669  #if !defined(ABSL_USES_STD_VARIANT)
1670  TEST(VariantTest, TestConvertingSet) {
1671    typedef variant<double> Variant;
1672    Variant v(1.0);
1673    const int two = 2;
1674    v = two;
1675    EXPECT_TRUE(absl::holds_alternative<double>(v));
1676    ASSERT_TRUE(nullptr != absl::get_if<double>(&v));
1677    EXPECT_DOUBLE_EQ(2, absl::get<double>(v));
1678  }
1679  #endif  
1680  TEST(VariantTest, Container) {
1681    typedef variant<int, float> Variant;
1682    std::vector<Variant> vec;
1683    vec.push_back(Variant(10));
1684    vec.push_back(Variant(20.0f));
1685    vec.resize(10, Variant(0));
1686  }
1687  TEST(VariantTest, TestVariantWithNonCopyableType) {
1688    typedef variant<int, NonCopyable> Variant;
1689    const int kValue = 1;
1690    Variant v(kValue);
1691    ASSERT_TRUE(absl::holds_alternative<int>(v));
1692    EXPECT_EQ(kValue, absl::get<int>(v));
1693  }
1694  TEST(VariantTest, TestEmplace) {
1695    typedef variant<int, NonCopyable> Variant;
1696    const int kValue = 1;
1697    Variant v(kValue);
1698    ASSERT_TRUE(absl::holds_alternative<int>(v));
1699    EXPECT_EQ(kValue, absl::get<int>(v));
1700    v.emplace<NonCopyable>();
1701    ASSERT_TRUE(absl::holds_alternative<NonCopyable>(v));
1702    EXPECT_EQ(0, absl::get<NonCopyable>(v).value);
1703    v = kValue;
1704    ASSERT_TRUE(absl::holds_alternative<int>(v));
1705    v.emplace<NonCopyable>(1);
1706    ASSERT_TRUE(absl::holds_alternative<NonCopyable>(v));
1707    EXPECT_EQ(1, absl::get<NonCopyable>(v).value);
1708    v = kValue;
1709    ASSERT_TRUE(absl::holds_alternative<int>(v));
1710    v.emplace<NonCopyable>(1, 2);
1711    ASSERT_TRUE(absl::holds_alternative<NonCopyable>(v));
1712    EXPECT_EQ(3, absl::get<NonCopyable>(v).value);
1713    v = kValue;
1714    ASSERT_TRUE(absl::holds_alternative<int>(v));
1715    v.emplace<NonCopyable>(1, 2, 3);
1716    ASSERT_TRUE(absl::holds_alternative<NonCopyable>(v));
1717    EXPECT_EQ(6, absl::get<NonCopyable>(v).value);
1718    v = kValue;
1719    ASSERT_TRUE(absl::holds_alternative<int>(v));
1720    v.emplace<NonCopyable>(1, 2, 3, 4);
1721    ASSERT_TRUE(absl::holds_alternative<NonCopyable>(v));
1722    EXPECT_EQ(10, absl::get<NonCopyable>(v).value);
1723    v = kValue;
1724    ASSERT_TRUE(absl::holds_alternative<int>(v));
1725  }
1726  TEST(VariantTest, TestEmplaceDestroysCurrentValue) {
1727    typedef variant<int, IncrementInDtor, NonCopyable> Variant;
1728    int counter = 0;
1729    Variant v(0);
1730    ASSERT_TRUE(absl::holds_alternative<int>(v));
1731    v.emplace<IncrementInDtor>(&counter);
1732    ASSERT_TRUE(absl::holds_alternative<IncrementInDtor>(v));
1733    ASSERT_EQ(0, counter);
1734    v.emplace<NonCopyable>();
1735    ASSERT_TRUE(absl::holds_alternative<NonCopyable>(v));
1736    EXPECT_EQ(1, counter);
1737  }
1738  TEST(VariantTest, TestMoveSemantics) {
1739    typedef variant<std::unique_ptr<int>, std::unique_ptr<std::string>> Variant;
1740    Variant v(absl::WrapUnique(new int(10)));
1741    EXPECT_TRUE(absl::holds_alternative<std::unique_ptr<int>>(v));
1742    Variant v2(absl::move(v));
1743    ASSERT_TRUE(absl::holds_alternative<std::unique_ptr<int>>(v2));
1744    ASSERT_NE(nullptr, absl::get<std::unique_ptr<int>>(v2));
1745    EXPECT_EQ(10, *absl::get<std::unique_ptr<int>>(v2));
1746    EXPECT_TRUE(absl::holds_alternative<std::unique_ptr<int>>(v));
1747    ASSERT_NE(nullptr, absl::get_if<std::unique_ptr<int>>(&v));
1748    EXPECT_EQ(nullptr, absl::get<std::unique_ptr<int>>(v));
1749    v = absl::make_unique<std::string>("foo");
1750    ASSERT_TRUE(absl::holds_alternative<std::unique_ptr<std::string>>(v));
1751    EXPECT_EQ("foo", *absl::get<std::unique_ptr<std::string>>(v));
1752    v2 = absl::move(v);
1753    ASSERT_TRUE(absl::holds_alternative<std::unique_ptr<std::string>>(v2));
1754    EXPECT_EQ("foo", *absl::get<std::unique_ptr<std::string>>(v2));
1755    EXPECT_TRUE(absl::holds_alternative<std::unique_ptr<std::string>>(v));
1756  }
1757  variant<int, std::string> PassThrough(const variant<int, std::string>& arg) {
1758    return arg;
1759  }
1760  TEST(VariantTest, TestImplicitConversion) {
1761    EXPECT_TRUE(absl::holds_alternative<int>(PassThrough(0)));
1762    EXPECT_TRUE(
1763        absl::holds_alternative<std::string>(PassThrough(std::string("foo"))));
1764  }
1765  struct Convertible2;
1766  struct Convertible1 {
1767    Convertible1() {}
1768    Convertible1(const Convertible1&) {}
1769    Convertible1& operator=(const Convertible1&) { return *this; }
1770    Convertible1(const Convertible2&) {}  
1771  };
1772  struct Convertible2 {
1773    Convertible2() {}
1774    Convertible2(const Convertible2&) {}
1775    Convertible2& operator=(const Convertible2&) { return *this; }
1776    Convertible2(const Convertible1&) {}  
1777  };
1778  TEST(VariantTest, TestRvalueConversion) {
1779  #if !defined(ABSL_USES_STD_VARIANT)
1780    variant<double, std::string> var(
1781        ConvertVariantTo<variant<double, std::string>>(
1782            variant<std::string, int>(0)));
1783    ASSERT_TRUE(absl::holds_alternative<double>(var));
1784    EXPECT_EQ(0.0, absl::get<double>(var));
1785    var = ConvertVariantTo<variant<double, std::string>>(
1786        variant<const char*, float>("foo"));
1787    ASSERT_TRUE(absl::holds_alternative<std::string>(var));
1788    EXPECT_EQ("foo", absl::get<std::string>(var));
1789    variant<double> singleton(
1790        ConvertVariantTo<variant<double>>(variant<int, float>(42)));
1791    ASSERT_TRUE(absl::holds_alternative<double>(singleton));
1792    EXPECT_EQ(42.0, absl::get<double>(singleton));
1793    singleton = ConvertVariantTo<variant<double>>(variant<int, float>(3.14f));
1794    ASSERT_TRUE(absl::holds_alternative<double>(singleton));
1795    EXPECT_FLOAT_EQ(3.14f, static_cast<float>(absl::get<double>(singleton)));
1796    singleton = ConvertVariantTo<variant<double>>(variant<int>(0));
1797    ASSERT_TRUE(absl::holds_alternative<double>(singleton));
1798    EXPECT_EQ(0.0, absl::get<double>(singleton));
1799    variant<int32_t, uint32_t> variant2(
1800        ConvertVariantTo<variant<int32_t, uint32_t>>(variant<int32_t>(42)));
1801    ASSERT_TRUE(absl::holds_alternative<int32_t>(variant2));
1802    EXPECT_EQ(42, absl::get<int32_t>(variant2));
1803    variant2 =
1804        ConvertVariantTo<variant<int32_t, uint32_t>>(variant<uint32_t>(42u));
1805    ASSERT_TRUE(absl::holds_alternative<uint32_t>(variant2));
1806    EXPECT_EQ(42u, absl::get<uint32_t>(variant2));
1807  #endif  
1808    variant<Convertible1, Convertible2> variant3(
1809        ConvertVariantTo<variant<Convertible1, Convertible2>>(
1810            (variant<Convertible2, Convertible1>(Convertible1()))));
1811    ASSERT_TRUE(absl::holds_alternative<Convertible1>(variant3));
1812    variant3 = ConvertVariantTo<variant<Convertible1, Convertible2>>(
1813        variant<Convertible2, Convertible1>(Convertible2()));
1814    ASSERT_TRUE(absl::holds_alternative<Convertible2>(variant3));
1815  }
1816  TEST(VariantTest, TestLvalueConversion) {
1817  #if !defined(ABSL_USES_STD_VARIANT)
1818    variant<std::string, int> source1 = 0;
1819    variant<double, std::string> destination(
1820        ConvertVariantTo<variant<double, std::string>>(source1));
1821    ASSERT_TRUE(absl::holds_alternative<double>(destination));
1822    EXPECT_EQ(0.0, absl::get<double>(destination));
1823    variant<const char*, float> source2 = "foo";
1824    destination = ConvertVariantTo<variant<double, std::string>>(source2);
1825    ASSERT_TRUE(absl::holds_alternative<std::string>(destination));
1826    EXPECT_EQ("foo", absl::get<std::string>(destination));
1827    variant<int, float> source3(42);
1828    variant<double> singleton(ConvertVariantTo<variant<double>>(source3));
1829    ASSERT_TRUE(absl::holds_alternative<double>(singleton));
1830    EXPECT_EQ(42.0, absl::get<double>(singleton));
1831    source3 = 3.14f;
1832    singleton = ConvertVariantTo<variant<double>>(source3);
1833    ASSERT_TRUE(absl::holds_alternative<double>(singleton));
1834    EXPECT_FLOAT_EQ(3.14f, static_cast<float>(absl::get<double>(singleton)));
1835    variant<int> source4(0);
1836    singleton = ConvertVariantTo<variant<double>>(source4);
1837    ASSERT_TRUE(absl::holds_alternative<double>(singleton));
1838    EXPECT_EQ(0.0, absl::get<double>(singleton));
1839    variant<int32_t> source5(42);
1840    variant<int32_t, uint32_t> variant2(
1841        ConvertVariantTo<variant<int32_t, uint32_t>>(source5));
1842    ASSERT_TRUE(absl::holds_alternative<int32_t>(variant2));
1843    EXPECT_EQ(42, absl::get<int32_t>(variant2));
1844    variant<uint32_t> source6(42u);
1845    variant2 = ConvertVariantTo<variant<int32_t, uint32_t>>(source6);
1846    ASSERT_TRUE(absl::holds_alternative<uint32_t>(variant2));
1847    EXPECT_EQ(42u, absl::get<uint32_t>(variant2));
1848  #endif
1849    variant<Convertible2, Convertible1> source7((Convertible1()));
1850    variant<Convertible1, Convertible2> variant3(
1851        ConvertVariantTo<variant<Convertible1, Convertible2>>(source7));
1852    ASSERT_TRUE(absl::holds_alternative<Convertible1>(variant3));
1853    source7 = Convertible2();
1854    variant3 = ConvertVariantTo<variant<Convertible1, Convertible2>>(source7);
1855    ASSERT_TRUE(absl::holds_alternative<Convertible2>(variant3));
1856  }
1857  TEST(VariantTest, TestMoveConversion) {
1858    using Variant =
1859        variant<std::unique_ptr<const int>, std::unique_ptr<const std::string>>;
1860    using OtherVariant =
1861        variant<std::unique_ptr<int>, std::unique_ptr<std::string>>;
1862    Variant var(
1863        ConvertVariantTo<Variant>(OtherVariant{absl::make_unique<int>(0)}));
1864    ASSERT_TRUE(absl::holds_alternative<std::unique_ptr<const int>>(var));
1865    ASSERT_NE(absl::get<std::unique_ptr<const int>>(var), nullptr);
1866    EXPECT_EQ(0, *absl::get<std::unique_ptr<const int>>(var));
1867    var = ConvertVariantTo<Variant>(
1868        OtherVariant(absl::make_unique<std::string>("foo")));
1869    ASSERT_TRUE(absl::holds_alternative<std::unique_ptr<const std::string>>(var));
1870    EXPECT_EQ("foo", *absl::get<std::unique_ptr<const std::string>>(var));
1871  }
1872  TEST(VariantTest, DoesNotMoveFromLvalues) {
1873    using Variant =
1874        variant<std::shared_ptr<const int>, std::shared_ptr<const std::string>>;
1875    using OtherVariant =
1876        variant<std::shared_ptr<int>, std::shared_ptr<std::string>>;
1877    Variant v1(std::make_shared<const int>(0));
1878    Variant v2(v1);
1879    EXPECT_EQ(absl::get<std::shared_ptr<const int>>(v1),
1880              absl::get<std::shared_ptr<const int>>(v2));
1881    v1 = std::make_shared<const std::string>("foo");
1882    v2 = v1;
1883    EXPECT_EQ(absl::get<std::shared_ptr<const std::string>>(v1),
1884              absl::get<std::shared_ptr<const std::string>>(v2));
1885    OtherVariant other(std::make_shared<int>(0));
1886    Variant v3(ConvertVariantTo<Variant>(other));
1887    EXPECT_EQ(absl::get<std::shared_ptr<int>>(other),
1888              absl::get<std::shared_ptr<const int>>(v3));
1889    other = std::make_shared<std::string>("foo");
1890    v3 = ConvertVariantTo<Variant>(other);
1891    EXPECT_EQ(absl::get<std::shared_ptr<std::string>>(other),
1892              absl::get<std::shared_ptr<const std::string>>(v3));
1893  }
1894  TEST(VariantTest, TestRvalueConversionViaConvertVariantTo) {
1895  #if !defined(ABSL_USES_STD_VARIANT)
1896    variant<double, std::string> var(
1897        ConvertVariantTo<variant<double, std::string>>(
1898            variant<std::string, int>(3)));
1899    EXPECT_THAT(absl::get_if<double>(&var), Pointee(3.0));
1900    var = ConvertVariantTo<variant<double, std::string>>(
1901        variant<const char*, float>("foo"));
1902    EXPECT_THAT(absl::get_if<std::string>(&var), Pointee(std::string("foo")));
1903    variant<double> singleton(
1904        ConvertVariantTo<variant<double>>(variant<int, float>(42)));
1905    EXPECT_THAT(absl::get_if<double>(&singleton), Pointee(42.0));
1906    singleton = ConvertVariantTo<variant<double>>(variant<int, float>(3.14f));
1907    EXPECT_THAT(absl::get_if<double>(&singleton), Pointee(DoubleEq(3.14f)));
1908    singleton = ConvertVariantTo<variant<double>>(variant<int>(3));
1909    EXPECT_THAT(absl::get_if<double>(&singleton), Pointee(3.0));
1910    variant<int32_t, uint32_t> variant2(
1911        ConvertVariantTo<variant<int32_t, uint32_t>>(variant<int32_t>(42)));
1912    EXPECT_THAT(absl::get_if<int32_t>(&variant2), Pointee(42));
1913    variant2 =
1914        ConvertVariantTo<variant<int32_t, uint32_t>>(variant<uint32_t>(42u));
1915    EXPECT_THAT(absl::get_if<uint32_t>(&variant2), Pointee(42u));
1916  #endif
1917    variant<Convertible1, Convertible2> variant3(
1918        ConvertVariantTo<variant<Convertible1, Convertible2>>(
1919            (variant<Convertible2, Convertible1>(Convertible1()))));
1920    ASSERT_TRUE(absl::holds_alternative<Convertible1>(variant3));
1921    variant3 = ConvertVariantTo<variant<Convertible1, Convertible2>>(
1922        variant<Convertible2, Convertible1>(Convertible2()));
1923    ASSERT_TRUE(absl::holds_alternative<Convertible2>(variant3));
1924  }
1925  TEST(VariantTest, TestLvalueConversionViaConvertVariantTo) {
1926  #if !defined(ABSL_USES_STD_VARIANT)
1927    variant<std::string, int> source1 = 3;
1928    variant<double, std::string> destination(
1929        ConvertVariantTo<variant<double, std::string>>(source1));
1930    EXPECT_THAT(absl::get_if<double>(&destination), Pointee(3.0));
1931    variant<const char*, float> source2 = "foo";
1932    destination = ConvertVariantTo<variant<double, std::string>>(source2);
1933    EXPECT_THAT(absl::get_if<std::string>(&destination),
1934                Pointee(std::string("foo")));
1935    variant<int, float> source3(42);
1936    variant<double> singleton(ConvertVariantTo<variant<double>>(source3));
1937    EXPECT_THAT(absl::get_if<double>(&singleton), Pointee(42.0));
1938    source3 = 3.14f;
1939    singleton = ConvertVariantTo<variant<double>>(source3);
1940    EXPECT_FLOAT_EQ(3.14f, static_cast<float>(absl::get<double>(singleton)));
1941    EXPECT_THAT(absl::get_if<double>(&singleton), Pointee(DoubleEq(3.14f)));
1942    variant<int> source4(3);
1943    singleton = ConvertVariantTo<variant<double>>(source4);
1944    EXPECT_THAT(absl::get_if<double>(&singleton), Pointee(3.0));
1945    variant<int32_t> source5(42);
1946    variant<int32_t, uint32_t> variant2(
1947        ConvertVariantTo<variant<int32_t, uint32_t>>(source5));
1948    EXPECT_THAT(absl::get_if<int32_t>(&variant2), Pointee(42));
1949    variant<uint32_t> source6(42u);
1950    variant2 = ConvertVariantTo<variant<int32_t, uint32_t>>(source6);
1951    EXPECT_THAT(absl::get_if<uint32_t>(&variant2), Pointee(42u));
1952  #endif  
1953    variant<Convertible2, Convertible1> source7((Convertible1()));
1954    variant<Convertible1, Convertible2> variant3(
1955        ConvertVariantTo<variant<Convertible1, Convertible2>>(source7));
1956    ASSERT_TRUE(absl::holds_alternative<Convertible1>(variant3));
1957    source7 = Convertible2();
1958    variant3 = ConvertVariantTo<variant<Convertible1, Convertible2>>(source7);
1959    ASSERT_TRUE(absl::holds_alternative<Convertible2>(variant3));
1960  }
1961  TEST(VariantTest, TestMoveConversionViaConvertVariantTo) {
1962    using Variant =
1963        variant<std::unique_ptr<const int>, std::unique_ptr<const std::string>>;
1964    using OtherVariant =
1965        variant<std::unique_ptr<int>, std::unique_ptr<std::string>>;
1966    Variant var(
1967        ConvertVariantTo<Variant>(OtherVariant{absl::make_unique<int>(3)}));
1968    EXPECT_THAT(absl::get_if<std::unique_ptr<const int>>(&var),
1969                Pointee(Pointee(3)));
1970    var = ConvertVariantTo<Variant>(
1971        OtherVariant(absl::make_unique<std::string>("foo")));
1972    EXPECT_THAT(absl::get_if<std::unique_ptr<const std::string>>(&var),
1973                Pointee(Pointee(std::string("foo"))));
1974  }
1975  #if !(defined(ABSL_USES_STD_VARIANT) && defined(__GLIBCXX__))
1976  #define ABSL_VARIANT_PROPAGATE_COPY_MOVE_TRIVIALITY 1
1977  #endif
1978  TEST(VariantTest, TestCopyAndMoveTypeTraits) {
1979    EXPECT_TRUE(std::is_copy_constructible<variant<std::string>>::value);
1980    EXPECT_TRUE(absl::is_copy_assignable<variant<std::string>>::value);
1981    EXPECT_TRUE(std::is_move_constructible<variant<std::string>>::value);
1982    EXPECT_TRUE(absl::is_move_assignable<variant<std::string>>::value);
1983    EXPECT_TRUE(std::is_move_constructible<variant<std::unique_ptr<int>>>::value);
1984    EXPECT_TRUE(absl::is_move_assignable<variant<std::unique_ptr<int>>>::value);
1985    EXPECT_FALSE(
1986        std::is_copy_constructible<variant<std::unique_ptr<int>>>::value);
1987    EXPECT_FALSE(absl::is_copy_assignable<variant<std::unique_ptr<int>>>::value);
1988    EXPECT_FALSE(
1989        absl::is_trivially_copy_constructible<variant<std::string>>::value);
1990    EXPECT_FALSE(absl::is_trivially_copy_assignable<variant<std::string>>::value);
1991  #if ABSL_VARIANT_PROPAGATE_COPY_MOVE_TRIVIALITY
1992    EXPECT_TRUE(absl::is_trivially_copy_constructible<variant<int>>::value);
1993    EXPECT_TRUE(absl::is_trivially_copy_assignable<variant<int>>::value);
1994    EXPECT_TRUE(is_trivially_move_constructible<variant<int>>::value);
1995    EXPECT_TRUE(is_trivially_move_assignable<variant<int>>::value);
1996  #endif  
1997  }
1998  TEST(VariantTest, TestVectorOfMoveonlyVariant) {
1999    std::vector<variant<std::unique_ptr<int>, std::string>> vec;
2000    vec.push_back(absl::make_unique<int>(42));
2001    vec.emplace_back("Hello");
2002    vec.reserve(3);
2003    auto another_vec = absl::move(vec);
2004    ASSERT_EQ(2u, another_vec.size());
2005    EXPECT_EQ(42, *absl::get<std::unique_ptr<int>>(another_vec[0]));
2006    EXPECT_EQ("Hello", absl::get<std::string>(another_vec[1]));
2007  }
2008  TEST(VariantTest, NestedVariant) {
2009  #if ABSL_VARIANT_PROPAGATE_COPY_MOVE_TRIVIALITY
2010    static_assert(absl::is_trivially_copy_constructible<variant<int>>(), "");
2011    static_assert(absl::is_trivially_copy_assignable<variant<int>>(), "");
2012    static_assert(is_trivially_move_constructible<variant<int>>(), "");
2013    static_assert(is_trivially_move_assignable<variant<int>>(), "");
2014    static_assert(absl::is_trivially_copy_constructible<variant<variant<int>>>(),
2015                  "");
2016    static_assert(absl::is_trivially_copy_assignable<variant<variant<int>>>(),
2017                  "");
2018    static_assert(is_trivially_move_constructible<variant<variant<int>>>(), "");
2019    static_assert(is_trivially_move_assignable<variant<variant<int>>>(), "");
2020  #endif  
2021    variant<int> x(42);
2022    variant<variant<int>> y(x);
2023    variant<variant<int>> z(y);
2024    EXPECT_TRUE(absl::holds_alternative<variant<int>>(z));
2025    EXPECT_EQ(x, absl::get<variant<int>>(z));
2026  }
2027  struct TriviallyDestructible {
2028    TriviallyDestructible(TriviallyDestructible&&) {}
2029    TriviallyDestructible(const TriviallyDestructible&) {}
2030    TriviallyDestructible& operator=(TriviallyDestructible&&) { return *this; }
2031    TriviallyDestructible& operator=(const TriviallyDestructible&) {
2032      return *this;
2033    }
2034  };
2035  struct TriviallyMovable {
2036    TriviallyMovable(TriviallyMovable&&) = default;
2037    TriviallyMovable(TriviallyMovable const&) {}
2038    TriviallyMovable& operator=(const TriviallyMovable&) { return *this; }
2039  };
2040  struct TriviallyCopyable {
2041    TriviallyCopyable(const TriviallyCopyable&) = default;
2042    TriviallyCopyable& operator=(const TriviallyCopyable&) { return *this; }
2043  };
2044  struct TriviallyMoveAssignable {
2045    TriviallyMoveAssignable(TriviallyMoveAssignable&&) = default;
2046    TriviallyMoveAssignable(const TriviallyMoveAssignable&) {}
2047    TriviallyMoveAssignable& operator=(TriviallyMoveAssignable&&) = default;
2048    TriviallyMoveAssignable& operator=(const TriviallyMoveAssignable&) {
2049      return *this;
2050    }
2051  };
2052  struct TriviallyCopyAssignable {};
2053  #if ABSL_VARIANT_PROPAGATE_COPY_MOVE_TRIVIALITY
2054  TEST(VariantTest, TestTriviality) {
2055    {
2056      using TrivDestVar = absl::variant<TriviallyDestructible>;
2057      EXPECT_FALSE(is_trivially_move_constructible<TrivDestVar>::value);
2058      EXPECT_FALSE(absl::is_trivially_copy_constructible<TrivDestVar>::value);
2059      EXPECT_FALSE(is_trivially_move_assignable<TrivDestVar>::value);
2060      EXPECT_FALSE(absl::is_trivially_copy_assignable<TrivDestVar>::value);
2061      EXPECT_TRUE(absl::is_trivially_destructible<TrivDestVar>::value);
2062    }
2063    {
2064      using TrivMoveVar = absl::variant<TriviallyMovable>;
2065      EXPECT_TRUE(is_trivially_move_constructible<TrivMoveVar>::value);
2066      EXPECT_FALSE(absl::is_trivially_copy_constructible<TrivMoveVar>::value);
2067      EXPECT_FALSE(is_trivially_move_assignable<TrivMoveVar>::value);
2068      EXPECT_FALSE(absl::is_trivially_copy_assignable<TrivMoveVar>::value);
2069      EXPECT_TRUE(absl::is_trivially_destructible<TrivMoveVar>::value);
2070    }
2071    {
2072      using TrivCopyVar = absl::variant<TriviallyCopyable>;
2073      EXPECT_TRUE(is_trivially_move_constructible<TrivCopyVar>::value);
2074      EXPECT_TRUE(absl::is_trivially_copy_constructible<TrivCopyVar>::value);
2075      EXPECT_FALSE(is_trivially_move_assignable<TrivCopyVar>::value);
2076      EXPECT_FALSE(absl::is_trivially_copy_assignable<TrivCopyVar>::value);
2077      EXPECT_TRUE(absl::is_trivially_destructible<TrivCopyVar>::value);
2078    }
2079    {
2080      using TrivMoveAssignVar = absl::variant<TriviallyMoveAssignable>;
2081      EXPECT_TRUE(is_trivially_move_constructible<TrivMoveAssignVar>::value);
2082      EXPECT_FALSE(
2083          absl::is_trivially_copy_constructible<TrivMoveAssignVar>::value);
2084      EXPECT_TRUE(is_trivially_move_assignable<TrivMoveAssignVar>::value);
2085      EXPECT_FALSE(absl::is_trivially_copy_assignable<TrivMoveAssignVar>::value);
2086      EXPECT_TRUE(absl::is_trivially_destructible<TrivMoveAssignVar>::value);
2087    }
2088    {
2089      using TrivCopyAssignVar = absl::variant<TriviallyCopyAssignable>;
2090      EXPECT_TRUE(is_trivially_move_constructible<TrivCopyAssignVar>::value);
2091      EXPECT_TRUE(
2092          absl::is_trivially_copy_constructible<TrivCopyAssignVar>::value);
2093      EXPECT_TRUE(is_trivially_move_assignable<TrivCopyAssignVar>::value);
2094      EXPECT_TRUE(absl::is_trivially_copy_assignable<TrivCopyAssignVar>::value);
2095      EXPECT_TRUE(absl::is_trivially_destructible<TrivCopyAssignVar>::value);
2096    }
2097  }
2098  #endif  
2099  TEST(VariantTest, MoveCtorBug) {
2100    struct TrivialCopyNontrivialMove {
2101      TrivialCopyNontrivialMove() = default;
2102      TrivialCopyNontrivialMove(const TrivialCopyNontrivialMove&) = default;
2103      TrivialCopyNontrivialMove(TrivialCopyNontrivialMove&&) { called = true; }
2104      bool called = false;
2105    };
2106    {
2107      using V = absl::variant<TrivialCopyNontrivialMove, int>;
2108      V v1(absl::in_place_index<0>);
2109      V v2(std::move(v1));
2110      EXPECT_TRUE(absl::get<0>(v2).called);
2111    }
2112    {
2113      using V = absl::variant<int, TrivialCopyNontrivialMove>;
2114      V v1(absl::in_place_index<1>);
2115      V v2(std::move(v1));
2116      EXPECT_TRUE(absl::get<1>(v2).called);
2117    }
2118  }
2119  }  
2120  ABSL_NAMESPACE_END
2121  }  
2122  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-variant_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-variant_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>238    Variant copied(original);
239    EXPECT_TRUE(absl::holds_alternative<value_type1>(copied) ||
240                TypeParam::kIndex != 1);
241    EXPECT_TRUE(absl::holds_alternative<value_type2>(copied) ||
242                TypeParam::kIndex != 2);
243    EXPECT_TRUE(absl::holds_alternative<value_type3>(copied) ||
244                TypeParam::kIndex != 3);
245    EXPECT_TRUE(absl::holds_alternative<value_type4>(copied) ||
246                TypeParam::kIndex != 4);
247    EXPECT_TRUE((absl::get_if<value_type1>(&original) ==
</pre></code></div>
                <div class="column column_space"><pre><code>322    Variant v(value);
323    EXPECT_TRUE(absl::holds_alternative<value_type1>(v) ||
324                TypeParam::kIndex != 1);
325    EXPECT_TRUE(absl::holds_alternative<value_type2>(v) ||
326                TypeParam::kIndex != 2);
327    EXPECT_TRUE(absl::holds_alternative<value_type3>(v) ||
328                TypeParam::kIndex != 3);
329    EXPECT_TRUE(absl::holds_alternative<value_type4>(v) ||
330                TypeParam::kIndex != 4);
331    EXPECT_TRUE(nullptr != absl::get_if<value_type1>(&v) ||
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    