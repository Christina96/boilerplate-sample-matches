
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 3.454231433506045%, Tokens: 10</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-lshtest.cpp</h3>
            <pre><code>1  #include "Snap.h"
2  #include "lsh.h"
3  #define DIM 3
4  void outputPoint(TFltV Point) {
5    printf("(");
6    for (int i=0; i<Point.Len(); i++) {
7      if (i>0)
8        printf(", ");
9      printf("%.2f", (double)Point[i]);
10    }
11    printf(")");
12  }
13  int main() {
14    TLSHash LSH(7, 7, DIM, TLSHash::EUCLIDEAN);
15    LSH.Init();
16    TRnd Gen;
17    Gen.Randomize();
18    TVec<TFltV> DataV;
<span onclick='openModal()' class='match'>19    for (int i=0; i<1000000; i++) {
20      TFltV Datum;
21      for (int j=0; j<3; j++) {
</span>22        Datum.Add(Gen.GetUniDev()*2100);
23      }
24      DataV.Add(Datum);
25    }
26    LSH.AddV(DataV);
27    TVec<TPair<TFltV, TFltV> > NeighborsV = LSH.GetAllCandidatePairs();
28    printf("Number of Candidates: %d\n", NeighborsV.Len());
29    NeighborsV = LSH.GetAllNearPairs();
30    printf("Number of Close Pairs: %d\n", NeighborsV.Len());
31    for (int i=0; i<NeighborsV.Len(); i++) {
32      outputPoint(NeighborsV[i].GetVal1());
33      printf(" ");
34      outputPoint(NeighborsV[i].GetVal2());
35      printf("\n");
36    }
37    return 0;
38  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-circles.h</h3>
            <pre><code>1  #pragma once
2  #include "stdafx.h"
3  class TGraphAttributes {
4  public:
5    TGraphAttributes(PUNGraph G, const char* nodeFeaturePath, const char* groundtruthPath);
6    ~TGraphAttributes() {
7    }
8    PUNGraph G;
9    TInt NFeatures;
10    THash<TInt, TIntIntH> NodeFeatures;
11    THash<TIntPr, TIntIntH> EdgeFeatures;
12    TVec<TInt> NodeIDs;
13    TCRef CRef;
14    TVec<TIntSet> GroundTruth; 
15  };
16  typedef TPt<TGraphAttributes> PGraphAttributes;
17  class TCluster {
18  public:
19    TCluster(PGraphAttributes GraphAttributes, TInt K, TFlt Lambda) :
20      GraphAttributes(GraphAttributes), K(K), Lambda(Lambda) {
21      Theta = new TFlt[K * GraphAttributes->NFeatures];
22      Derivative = new TFlt[K * GraphAttributes->NFeatures];
<span onclick='openModal()' class='match'>23      for (int k = 0; k < K; k++) {
24        for (int f = 0; f < GraphAttributes->NFeatures; f++) {
</span>25          Theta[k * GraphAttributes->NFeatures + f] = 0;
26          Derivative[k * GraphAttributes->NFeatures + f] = 0;
27        }
28        CHat.Add(TIntSet());
29      }
30    }
31    ~TCluster() {
32      delete[] Theta;
33      delete[] Derivative;
34    }
35    void Train(TInt OuterReps, TInt GradientReps, TInt MCMCReps);
36    TVec<TIntSet> GetCircles(void) {
37      return CHat;
38    }
39    TCRef CRef;
40  private:
41    TFlt* Theta; 
42    TFlt* Derivative; 
43    TVec<TIntSet> CHat; 
44    PGraphAttributes GraphAttributes; 
45    TInt K;
46    TFlt Lambda;
47    TFlt LogLikelihood();
48    TIntSet MCMC(TInt k, TInt MCMCReps);
49    void Gradient();
50  };
51  typedef TPt<TCluster> PCluster;
52  enum lossType
53  {
54    zeroOne = 0,
55    balancedError = 1,
56    fScore = 2
57  };
58  TFlt Loss(TIntSet& l, TIntSet lHat, int N, int Which)
59  {
60    if (l.Len() == 0) {
61      if (lHat.Len() == 0) {
62        return 0;
63      }
64      return 1.0;
65    }
66    if (lHat.Len() == 0) {
67      if (l.Len() == 0) {
68        return 0;
69      }
70      return 1.0;
71    }
72    TInt TruePositives = 0;
73    TInt FalsePositives = 0;
74    TInt FalseNegatives = 0;
75    TFlt LabelLoss = 0;
76    for (THashSetKeyI<TInt> it = l.BegI(); it != l.EndI(); it ++) {
77      int c = it.GetKey();
78      if (!lHat.IsKey(c)) {
79        FalseNegatives ++;
80        if (Which == zeroOne) {
81          LabelLoss += 1.0/N;
82        }
83        else if (Which == balancedError) {
84          LabelLoss += 0.5/l.Len();
85        }
86      }
87    }
88    for (THashSetKeyI<TInt> it = lHat.BegI(); it != lHat.EndI(); it ++) {
89      int c = it.GetKey();
90      if (!l.IsKey(c)) {
91        FalsePositives ++;
92        if (Which == zeroOne) {
93          LabelLoss += 1.0/N;
94        }
95        else if (Which == balancedError) {
96          LabelLoss += 0.5/(N - l.Len());
97        }
98      }
99      else {
100        TruePositives ++;
101      }
102    }
103    if ((lHat.Len() == 0 || TruePositives == 0) && Which == fScore) {
104      return 1.0;
105    }
106    TFlt precision = (1.0*TruePositives)/lHat.Len();
107    TFlt recall = (1.0*TruePositives)/l.Len();
108    if (Which == fScore) {
109      return 1 - 2 * (precision*recall) / (precision + recall);
110    }
111    return LabelLoss;
112  }
113  TGraphAttributes::TGraphAttributes(PUNGraph G, const char* NodeFeaturePath,
114                                     const char* GroundTruthPath) :
115    G(G) {
116    FILE* f = fopen(NodeFeaturePath, "r");
117    int NNodes;
118    int nF;
119    fscanf(f, "%d %d", &NNodes, &nF);
120    NFeatures = nF;
121    for (int i = 0; i < NNodes; i++) {
122      int nid;
123      fscanf(f, "%d", &nid);
124      if (!G->IsNode(nid)) {
125        printf("Warning: %d is not a node in G.\n", nid);
126      }
127      TInt kv = NodeFeatures.AddKey(nid);
128      for (int x = 0; x < nF; x++) {
129        int z = 0;
130        fscanf(f, "%d", &z);
131        if (z) {
132          NodeFeatures[kv].AddDat(x) = z;
133        }
134      }
135      if (G->IsNode(nid)) {
136        NodeIDs.Add(nid);
137      }
138    }
139    fclose(f);
140    f = fopen(GroundTruthPath, "r");
141    if (f == NULL) {
142      printf("Groundtruth file %s not found.\n", GroundTruthPath);
143    }
144    else {
145      char* CircleName = new char [1000];
146      while (fscanf(f, "%s", CircleName) == 1)
147      {
148        TIntSet Circle;
149        while (true) {
150          int nid;
151          fscanf(f, "%d", &nid);
152          Circle.AddKey(nid);
153          char c;
154          while (true) {          
155            c = fgetc(f);
156            if (c == '\n') break;
157            if (c >= '0' && c <= '9') {
158              fseek(f, -1, SEEK_CUR);
159              break;
160            }
161          }
162          if (c == '\n') break;
163        }
164        GroundTruth.Add(Circle);
165      }
166      delete [] CircleName;
167    }
168    fclose(f);
169    for (int i = 0; i < NodeIDs.Len(); i++) {
170      TInt ni = NodeIDs[i];
171      for (int j = i + 1; j < NodeIDs.Len(); j++) {
172        TInt nj = NodeIDs[j];
173        TInt kv = EdgeFeatures.AddKey(TIntPr(ni, nj));
174        for (THashKeyDatI<TInt, TInt> it = NodeFeatures.GetDat(ni).BegI();
175             !it.IsEnd(); it++) {
176          TInt k = it.GetKey();
177          TInt diff = 0;
178          if (NodeFeatures.GetDat(nj).IsKey(k)) {
179            diff = abs(it.GetDat() - NodeFeatures.GetDat(nj).GetDat(k));
180          } else {
181            diff = abs(it.GetDat());
182          }
183          if (diff) {
184            EdgeFeatures[kv].AddDat(k) = diff;
185          }
186        }
187        for (THashKeyDatI<TInt, TInt> it = NodeFeatures.GetDat(nj).BegI();
188             !it.IsEnd(); it++) {
189          TInt k = it.GetKey();
190          TInt diff = 0;
191          if (NodeFeatures.GetDat(ni).IsKey(k)) {
192            diff = abs(it.GetDat() - NodeFeatures.GetDat(ni).GetDat(k));
193          } else {
194            diff = abs(it.GetDat());
195          }
196          if (diff) {
197            EdgeFeatures[kv].AddDat(k) = diff;
198          }
199        }
200      }
201    }
202  }
203  void TCluster::Train(TInt OuterReps, TInt GradientReps, TInt MCMCReps) {
204    TFlt Increment = 1.0 / (1.0 * GraphAttributes->NodeIDs.Len() * GraphAttributes->NodeIDs.Len());
205    TRnd t;
206    for (int OuterRep = 0; OuterRep < OuterReps; OuterRep++) {
207      for (int k = 0; k < K; k++) {
208        if (OuterRep == 0 || CHat[k].Empty() || CHat[k].Len()
209            == GraphAttributes->NodeIDs.Len()) {
210          CHat[k].Clr();
211          for (int i = 0; i < GraphAttributes->NodeIDs.Len(); i++) {
212            if (t.GetUniDevInt(2) == 0) {
213              CHat[k].AddKey(GraphAttributes->NodeIDs[i]);
214            }
215          }
216          for (int i = 0; i < GraphAttributes->NFeatures; i++) {
217            Theta[k * GraphAttributes->NFeatures + i] = 0;
218          }
219          Theta[k * GraphAttributes->NFeatures + t.GetUniDevInt(GraphAttributes->NFeatures)] = 1.0;
220          Theta[k * GraphAttributes->NFeatures] = 1;
221        }
222      }
223      for (int k = 0; k < K; k++) {
224        CHat[k] = MCMC(k, MCMCReps);
225      }
226      TFlt llPrevious = LogLikelihood();
227      TFlt ll = 0;
228      for (int gradientRep = 0; gradientRep < GradientReps; gradientRep++) {
229        Gradient();
230        for (int i = 0; i < K * GraphAttributes->NFeatures; i++) {
231          Theta[i] += Increment * Derivative[i];
232        }
233        printf(".");
234        fflush( stdout);
235        ll = LogLikelihood();
236        if (ll < llPrevious) {
237          for (int i = 0; i < K * GraphAttributes->NFeatures; i++) {
238            Theta[i] -= Increment * Derivative[i];
239          }
240          ll = llPrevious;
241          break;
242        }
243        llPrevious = ll;
244      }
245      printf("\nIteration %d, ll = %f\n", OuterRep + 1, (double) ll);
246    }
247  }
248  TFlt Inner(TIntIntH& Feature, TFlt* Parameter) {
249    TFlt res = 0;
250    for (THashKeyDatI<TInt, TInt> it = Feature.BegI(); !it.IsEnd(); it++) {
251      res += it.GetDat() * Parameter[it.GetKey()];
252    }
253    return res;
254  }
255  TIntSet TCluster::MCMC(TInt k, TInt MCMCReps) {
256    TRnd t;
257    THash<TInt, TFlt> CostNotIncludeHash;
258    THash<TInt, TFlt> CostIncludeHash;
259    TVec<TInt> NewLabel;
260    int csize = 0;
261    for (int i = 0; i < GraphAttributes->NodeIDs.Len(); i++) {
262      if (CHat[k].IsKey(GraphAttributes->NodeIDs[i])) {
263        NewLabel.Add(0);
264      } else {
265        NewLabel.Add(1);
266      }
267      if (CHat[k].IsKey(GraphAttributes->NodeIDs[i])) {
268        csize++;
269      }
270    }
271    for (THashKeyDatI<TIntPr, TIntIntH> it = GraphAttributes->EdgeFeatures.BegI();
272         !it.IsEnd(); it++) {
273      TIntPr e = it.GetKey();
274      TInt kv = GraphAttributes->EdgeFeatures.GetKeyId(e);
275      TInt Src = e.Val1;
276      TInt Dst = e.Val2;
277      TBool Exists = GraphAttributes->G->IsEdge(Src, Dst);
278      TFlt InnerProduct = Inner(it.GetDat(), Theta + k * GraphAttributes->NFeatures);
279      TFlt Other = 0;
280      for (int l = 0; l < K; l++) {
281        if (l == k) {
282          continue;
283        }
284        TFlt d = (CHat[l].IsKey(Src) && CHat[l].IsKey(Dst)) ? 1 : -1;
285        Other += d * Inner(it.GetDat(), Theta + l * GraphAttributes->NFeatures);
286      }
287      TFlt CostNotInclude;
288      TFlt CostInclude;
289      if (Exists) {
290        CostNotInclude = -Other + InnerProduct + log(1 + exp(Other - InnerProduct));
291        CostInclude = -Other - InnerProduct + log(1 + exp(Other + InnerProduct));
292      } else {
293        CostNotInclude = log(1 + exp(Other - InnerProduct));
294        CostInclude = log(1 + exp(Other + InnerProduct));
295      }
296      CostNotIncludeHash.AddDat(kv) = -CostNotInclude;
297      CostIncludeHash.AddDat(kv) = -CostInclude;
298    }
299    TFlt InitialTemperature = 1.0; 
300    for (int r = 2; r < MCMCReps + 2; r++) {
301      TFlt Temperature = InitialTemperature / log((double) r);
302      for (int n = 0; n < GraphAttributes->NodeIDs.Len(); n++) {
303        TFlt l0 = 0;
304        TFlt l1 = 0;
305        for (int np = 0; np < GraphAttributes->NodeIDs.Len(); np++) {
306          if (n == np) {
307            continue;
308          }
309          TIntPr ed(GraphAttributes->NodeIDs[n], GraphAttributes->NodeIDs[np]);
310          if (ed.Val1 > ed.Val2) {
311            ed = TIntPr(ed.Val2, ed.Val1);
312          }
313          TInt kv = GraphAttributes->EdgeFeatures.GetKeyId(ed);
314          TFlt m0 = CostNotIncludeHash.GetDat(kv);
315          if (NewLabel[np] == 0) {
316            l0 += m0;
317            l1 += m0;
318          } else {
319            l0 += m0;
320            l1 += CostIncludeHash.GetDat(kv);
321          }
322        }
323        TFlt LogLikelihoodDiff = exp(l1 - l0);
324        TFlt AcceptProb = pow(LogLikelihoodDiff, 1.0 / Temperature);
325        if (t.GetUniDev() < AcceptProb) {
326          NewLabel[n] = 1;
327        } else {
328          NewLabel[n] = 0;
329        }
330      }
331    }
332    TIntSet Result;
333    for (int i = 0; i < GraphAttributes->NodeIDs.Len(); i++) {
334      if (NewLabel[i]) {
335        Result.AddKey(GraphAttributes->NodeIDs[i]);
336      }
337    }
338    return Result;
339  }
340  void TCluster::Gradient(void) {
341    for (int i = 0; i < K * GraphAttributes->NFeatures; i++) {
342      if (Theta[i] > 0) {
343        Derivative[i] = -Lambda * Theta[i];
344      } else {
345        Derivative[i] = Lambda * Theta[i];
346      }
347    }
348    for (THashKeyDatI<TIntPr, TIntIntH> it = GraphAttributes->EdgeFeatures.BegI();
349         !it.IsEnd(); it++) {
350      TFlt InnerProduct = 0;
351      TIntPr Edge = it.GetKey();
352      TInt Src = Edge.Val1;
353      TInt Dst = Edge.Val2;
354      TBool Exists = GraphAttributes->G->IsEdge(Src, Dst);
355      for (int k = 0; k < K; k++) {
356        TFlt d = CHat[k].IsKey(Src) && CHat[k].IsKey(Dst) ? 1 : -1;
357        InnerProduct += d * Inner(it.GetDat(), Theta + k * GraphAttributes->NFeatures);
358      }
359      TFlt expinp = exp(InnerProduct);
360      TFlt q = expinp / (1 + expinp);
361      if (q != q) {
362        q = 1; 
363      }
364      for (int k = 0; k < K; k++) {
365        TBool d_ = CHat[k].IsKey(Src) && CHat[k].IsKey(Dst);
366        TFlt d = d_ ? 1 : -1;
367        for (THashKeyDatI<TInt, TInt> itf = it.GetDat().BegI();
368             !itf.IsEnd(); itf++) {
369          TInt i = itf.GetKey();
370          TInt f = itf.GetDat();
371          if (Exists) {
372            Derivative[k * GraphAttributes->NFeatures + i] += d * f;
373          }
374          Derivative[k * GraphAttributes->NFeatures + i] += -d * f * q;
375        }
376      }
377    }
378  }
379  TFlt TCluster::LogLikelihood(void) {
380    TFlt ll = 0;
381    for (THashKeyDatI<TIntPr, TIntIntH> it = GraphAttributes->EdgeFeatures.BegI();
382         !it.IsEnd(); it++) {
383      TFlt InnerProduct = 0;
384      TIntPr Edge = it.GetKey();
385      TInt Src = Edge.Val1;
386      TInt Dst = Edge.Val2;
387      TBool Exists = GraphAttributes->G->IsEdge(Src, Dst);
388      for (int k = 0; k < K; k++) {
389        TFlt d = CHat[k].IsKey(Src) && CHat[k].IsKey(Dst) ? 1 : -1;
390        InnerProduct += d * Inner(it.GetDat(), Theta + k * GraphAttributes->NFeatures);
391      }
392      if (Exists) {
393        ll += InnerProduct;
394      }
395      TFlt ll_ = log(1 + exp(InnerProduct));
396      ll += -ll_;
397    }
398    if (ll != ll) {
399      printf("ll isnan\n");
400      exit(1);
401    }
402    return ll;
403  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-lshtest.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-circles.h</div>
                </div>
                <div class="column column_space"><pre><code>19    for (int i=0; i<1000000; i++) {
20      TFltV Datum;
21      for (int j=0; j<3; j++) {
</pre></code></div>
                <div class="column column_space"><pre><code>23      for (int k = 0; k < K; k++) {
24        for (int f = 0; f < GraphAttributes->NFeatures; f++) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    