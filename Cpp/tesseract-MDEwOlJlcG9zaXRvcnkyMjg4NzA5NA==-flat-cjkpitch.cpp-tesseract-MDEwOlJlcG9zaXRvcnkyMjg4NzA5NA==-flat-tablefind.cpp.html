
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 8.74359984245766%, Tokens: 10</h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-cjkpitch.cpp</h3>
            <pre><code>1  #include "cjkpitch.h"
2  #include "topitch.h"
3  #include "tovars.h"
4  #include <algorithm> 
5  #include <cmath>
6  #include <vector>    
7  namespace tesseract {
8  static BOOL_VAR(textord_space_size_is_variable, false,
9                  "If true, word delimiter spaces are assumed to have "
10                  "variable width, even though characters have fixed pitch.");
11  static const float kFPTolerance = 0.1f;
12  static const float kFixedPitchThreshold = 0.35f;
13  class SimpleStats {
14  public:
15    SimpleStats() = default;
16    ~SimpleStats() = default;
17    void Clear() {
18      values_.clear();
19      finalized_ = false;
20    }
21    void Add(float value) {
22      values_.push_back(value);
23      finalized_ = false;
24    }
25    void Finish() {
26      std::sort(values_.begin(), values_.end());
27      finalized_ = true;
28    }
29    float ile(double frac) {
30      if (!finalized_) {
31        Finish();
32      }
33      if (values_.empty()) {
34        return 0.0f;
35      }
36      if (frac >= 1.0) {
37        return values_.back();
38      }
39      if (frac <= 0.0 || values_.size() == 1) {
40        return values_[0];
41      }
42      int index = static_cast<int>((values_.size() - 1) * frac);
43      float reminder = (values_.size() - 1) * frac - index;
44      return values_[index] * (1.0f - reminder) + values_[index + 1] * reminder;
45    }
46    float median() {
47      return ile(0.5);
48    }
49    float minimum() {
50      if (!finalized_) {
51        Finish();
52      }
53      if (values_.empty()) {
54        return 0.0f;
55      }
56      return values_[0];
57    }
58    bool empty() const {
59      return values_.empty();
60    }
61    int size() const {
62      return values_.size();
63    }
64  private:
65    bool finalized_ = false;
66    std::vector<float> values_;
67  };
68  class LocalCorrelation {
69  public:
70    struct float_pair {
71      float x, y;
72      int vote;
73    };
74    LocalCorrelation() : finalized_(false) {}
75    ~LocalCorrelation() = default;
76    void Finish() {
77      std::sort(values_.begin(), values_.end(), float_pair_compare);
78      finalized_ = true;
79    }
80    void Clear() {
81      finalized_ = false;
82    }
83    void Add(float x, float y, int v) {
84      struct float_pair value;
85      value.x = x;
86      value.y = y;
87      value.vote = v;
88      values_.push_back(value);
89      finalized_ = false;
90    }
91    float EstimateYFor(float x, float r) {
92      ASSERT_HOST(finalized_);
93      unsigned start = 0, end = values_.size();
94      while (start < values_.size() && values_[start].x < x * (1 - r)) {
95        start++;
96      }
97      while (end > 0 && values_[end - 1].x > x * (1 + r)) {
98        end--;
99      }
100      if (start >= end) {
101        start = 0;
102        end = values_.size();
103      }
104      float rc = 0;
105      int vote = 0;
106      for (auto i = start; i < end; i++) {
107        rc += values_[i].vote * x * values_[i].y / values_[i].x;
108        vote += values_[i].vote;
109      }
110      return vote == 0 ? 0.0f : rc / vote;
111    }
112  private:
113    static bool float_pair_compare(const float_pair f_a, const float_pair f_b) {
114      return f_a.x < f_b.x;
115    }
116    bool finalized_;
117    std::vector<struct float_pair> values_;
118  };
119  class FPChar {
120  public:
121    enum Alignment { ALIGN_UNKNOWN, ALIGN_GOOD, ALIGN_BAD };
122    FPChar()
123        : box_()
124        , real_body_()
125        , from_(nullptr)
126        , to_(nullptr)
127        , num_blobs_(0)
128        , max_gap_(0)
129        , final_(false)
130        , alignment_(ALIGN_UNKNOWN)
131        , merge_to_prev_(false)
132        , delete_flag_(false) {}
133    void Init(BLOBNBOX *blob) {
134      box_ = blob->bounding_box();
135      real_body_ = box_;
136      from_ = to_ = blob;
137      num_blobs_ = 1;
138    }
139    void Merge(const FPChar &next) {
140      int gap = real_body_.x_gap(next.real_body_);
141      if (gap > max_gap_) {
142        max_gap_ = gap;
143      }
144      box_ += next.box_;
145      real_body_ += next.real_body_;
146      to_ = next.to_;
147      num_blobs_ += next.num_blobs_;
148    }
149    const TBOX &box() const {
150      return box_;
151    }
152    void set_box(const TBOX &box) {
153      box_ = box;
154    }
155    const TBOX &real_body() const {
156      return real_body_;
157    }
158    bool is_final() const {
159      return final_;
160    }
161    void set_final(bool flag) {
162      final_ = flag;
163    }
164    const Alignment &alignment() const {
165      return alignment_;
166    }
167    void set_alignment(Alignment alignment) {
168      alignment_ = alignment;
169    }
170    bool merge_to_prev() const {
171      return merge_to_prev_;
172    }
173    void set_merge_to_prev(bool flag) {
174      merge_to_prev_ = flag;
175    }
176    bool delete_flag() const {
177      return delete_flag_;
178    }
179    void set_delete_flag(bool flag) {
180      delete_flag_ = flag;
181    }
182    int max_gap() const {
183      return max_gap_;
184    }
185    int num_blobs() const {
186      return num_blobs_;
187    }
188  private:
189    TBOX box_; 
190    TBOX real_body_; 
191    BLOBNBOX *from_; 
192    BLOBNBOX *to_;   
193    int num_blobs_;  
194    int max_gap_;    
195    bool final_; 
196    Alignment alignment_; 
197    bool merge_to_prev_;  
198    int delete_flag_; 
199  };
200  class FPRow {
201  public:
202    FPRow() : all_pitches_(), all_gaps_(), good_pitches_(), good_gaps_(), heights_(), characters_() {}
203    ~FPRow() = default;
204    void Init(TO_ROW *row);
205    void EstimatePitch(bool pass1);
206    void Pass1Analyze();
207    bool Pass2Analyze();
208    void MergeFragments();
209    void FinalizeLargeChars();
210    void OutputEstimations();
211    void DebugOutputResult(int row_index);
212    int good_pitches() {
213      return good_pitches_.size();
214    }
215    float pitch() {
216      return pitch_;
217    }
218    float estimated_pitch() {
219      return estimated_pitch_;
220    }
221    void set_estimated_pitch(float v) {
222      estimated_pitch_ = v;
223    }
224    float height() {
225      return height_;
226    }
227    float height_pitch_ratio() {
228      if (good_pitches_.size() < 2) {
229        return -1.0;
230      }
231      return height_ / good_pitches_.median();
232    }
233    float gap() {
234      return gap_;
235    }
236    size_t num_chars() {
237      return characters_.size();
238    }
239    FPChar *character(int i) {
240      return &characters_[i];
241    }
242    const TBOX &box(int i) {
243      return characters_[i].box();
244    }
245    const TBOX &real_body(int i) {
246      return characters_[i].real_body();
247    }
248    bool is_box_modified(int i) {
249      return !(characters_[i].box() == characters_[i].real_body());
250    }
251    float center_x(int i) {
252      return (characters_[i].box().left() + characters_[i].box().right()) / 2.0;
253    }
254    bool is_final(int i) {
255      return characters_[i].is_final();
256    }
257    void finalize(int i) {
258      characters_[i].set_final(true);
259    }
260    bool is_good(int i) {
261      return characters_[i].alignment() == FPChar::ALIGN_GOOD;
262    }
263    void mark_good(int i) {
264      characters_[i].set_alignment(FPChar::ALIGN_GOOD);
265    }
266    void mark_bad(int i) {
267      characters_[i].set_alignment(FPChar::ALIGN_BAD);
268    }
269    void clear_alignment(int i) {
270      characters_[i].set_alignment(FPChar::ALIGN_UNKNOWN);
271    }
272  private:
273    static float x_overlap_fraction(const TBOX &box1, const TBOX &box2) {
274      if (std::min(box1.width(), box2.width()) == 0) {
275        return 0.0;
276      }
277      return -box1.x_gap(box2) / static_cast<float>(std::min(box1.width(), box2.width()));
278    }
279    static bool mostly_overlap(const TBOX &box1, const TBOX &box2) {
280      return x_overlap_fraction(box1, box2) > 0.9;
281    }
282    static bool significant_overlap(const TBOX &box1, const TBOX &box2) {
283      if (std::min(box1.width(), box2.width()) == 0) {
284        return false;
285      }
286      int overlap = -box1.x_gap(box2);
287      return overlap > 1 || x_overlap_fraction(box1, box2) > 0.1;
288    }
289    static float box_pitch(const TBOX &ref, const TBOX &box) {
290      return abs(ref.left() + ref.right() - box.left() - box.right()) / 2.0;
291    }
292    static bool is_good_pitch(float pitch, const TBOX &box1, const TBOX &box2) {
293      if (box1.width() >= pitch * (1.0 + kFPTolerance) ||
294          box2.width() >= pitch * (1.0 + kFPTolerance) ||
295          box1.height() >= pitch * (1.0 + kFPTolerance) ||
296          box2.height() >= pitch * (1.0 + kFPTolerance)) {
297        return false;
298      }
299      const float real_pitch = box_pitch(box1, box2);
300      if (std::fabs(real_pitch - pitch) < pitch * kFPTolerance) {
301        return true;
302      }
303      if (textord_space_size_is_variable) {
304        if (real_pitch > pitch && real_pitch < pitch * 2.0 && real_pitch - box1.x_gap(box2) < pitch) {
305          return true;
306        }
307      }
308      return false;
309    }
310    static bool is_interesting_blob(const BLOBNBOX *blob) {
311      return !blob->joined_to_prev() && blob->flow() != BTFT_LEADER;
312    }
313    void DeleteChars() {
314      unsigned index = 0;
315      for (unsigned i = 0; i < characters_.size(); ++i) {
316        if (!characters_[i].delete_flag()) {
317          if (index != i) {
318            characters_[index] = characters_[i];
319          }
320          index++;
321        }
322      }
323      characters_.resize(index);
324    }
325    float pitch_ = 0.0f;           
326    float estimated_pitch_ = 0.0f; 
327    float height_ = 0.0f; 
328    float gap_ = 0.0f;    
329    SimpleStats all_pitches_;
330    SimpleStats all_gaps_;
331    SimpleStats good_pitches_;
332    SimpleStats good_gaps_;
333    SimpleStats heights_;
334    std::vector<FPChar> characters_;
335    TO_ROW *real_row_ = nullptr; 
336  };
337  void FPRow::Init(TO_ROW *row) {
338    ASSERT_HOST(row != nullptr);
339    ASSERT_HOST(row->xheight > 0);
340    real_row_ = row;
341    real_row_->pitch_decision = PITCH_CORR_PROP; 
342    BLOBNBOX_IT blob_it = row->blob_list();
343    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
344      if (is_interesting_blob(blob_it.data())) {
345        FPChar fp_char;
346        fp_char.Init(blob_it.data());
347        if (!characters_.empty() && significant_overlap(fp_char.box(), characters_.back().box())) {
348          characters_.back().Merge(fp_char);
349        } else {
350          characters_.push_back(fp_char);
351        }
352        TBOX bound = blob_it.data()->bounding_box();
353        if (bound.height() * 3.0 > bound.width()) {
354          heights_.Add(bound.height());
355        }
356      }
357    }
358    heights_.Finish();
359    height_ = heights_.ile(0.875);
360  }
361  void FPRow::OutputEstimations() {
362    if (good_pitches_.empty()) {
363      pitch_ = 0.0f;
364      real_row_->pitch_decision = PITCH_CORR_PROP;
365      return;
366    }
367    pitch_ = good_pitches_.median();
368    real_row_->fixed_pitch = pitch_;
369    real_row_->kern_size = real_row_->pr_nonsp =
370        std::min(good_gaps_.ile(0.125), std::max(pitch_ - height_, 0.0f));
371    real_row_->body_size = pitch_ - real_row_->kern_size;
372    if (good_pitches_.size() < all_pitches_.size() * kFixedPitchThreshold) {
373      real_row_->pitch_decision = PITCH_CORR_PROP;
374      return;
<span onclick='openModal()' class='match'>375    } else if (good_pitches_.size() > all_pitches_.size() * 0.75) {
376      real_row_->pitch_decision = PITCH_DEF_FIXED;
377    } else {
378      real_row_->pitch_decision = PITCH_CORR_FIXED;
379    }
</span>380    real_row_->space_size = real_row_->pr_space = pitch_;
381    real_row_->min_space = (pitch_ + good_gaps_.minimum()) * 0.5;
382    real_row_->max_nonspace =
383        std::max(pitch_ * 0.25 + good_gaps_.minimum(), static_cast<double>(good_gaps_.ile(0.875)));
384    int space_threshold = std::min((real_row_->max_nonspace + real_row_->min_space) / 2,
385                                   static_cast<int>(real_row_->xheight));
386    for (size_t i = 0; i < num_chars(); ++i) {
387      if (characters_[i].max_gap() > real_row_->max_nonspace) {
388        real_row_->max_nonspace = characters_[i].max_gap();
389      }
390    }
391    real_row_->space_threshold = std::min((real_row_->max_nonspace + real_row_->min_space) / 2,
392                                          static_cast<int>(real_row_->xheight));
393    real_row_->used_dm_model = false;
394    ICOORDELT_IT cell_it = &real_row_->char_cells;
395    auto *cell = new ICOORDELT(real_body(0).left(), 0);
396    cell_it.add_after_then_move(cell);
397    int right = real_body(0).right();
398    for (size_t i = 1; i < num_chars(); ++i) {
399      if ((is_final(i - 1) || is_final(i)) &&
400          real_body(i - 1).x_gap(real_body(i)) > space_threshold) {
401        cell = new ICOORDELT(right + 1, 0);
402        cell_it.add_after_then_move(cell);
403        while (right + pitch_ < box(i).left()) {
404          right += pitch_;
405          cell = new ICOORDELT(right + 1, 0);
406          cell_it.add_after_then_move(cell);
407        }
408        right = box(i).left();
409      }
410      cell = new ICOORDELT((right + real_body(i).left()) / 2, 0);
411      cell_it.add_after_then_move(cell);
412      right = real_body(i).right();
413    }
414    cell = new ICOORDELT(right + 1, 0);
415    cell_it.add_after_then_move(cell);
416  }
417  void FPRow::EstimatePitch(bool pass1) {
418    good_pitches_.Clear();
419    all_pitches_.Clear();
420    good_gaps_.Clear();
421    all_gaps_.Clear();
422    heights_.Clear();
423    if (num_chars() == 0) {
424      return;
425    }
426    int32_t cx0, cx1;
427    bool prev_was_good = is_good(0);
428    cx0 = center_x(0);
429    heights_.Add(box(0).height());
430    for (size_t i = 1; i < num_chars(); i++) {
431      cx1 = center_x(i);
432      int32_t pitch = cx1 - cx0;
433      int32_t gap = std::max(0, real_body(i - 1).x_gap(real_body(i)));
434      heights_.Add(box(i).height());
435      if (pitch > height_ * 0.5) {
436        all_pitches_.Add(pitch);
437        all_gaps_.Add(gap);
438        if (is_good(i)) {
439          if (pass1 ||
440              (prev_was_good && std::fabs(estimated_pitch_ - pitch) < kFPTolerance * estimated_pitch_)) {
441            good_pitches_.Add(pitch);
442            if (!is_box_modified(i - 1) && !is_box_modified(i)) {
443              good_gaps_.Add(gap);
444            }
445          }
446          prev_was_good = true;
447        } else {
448          prev_was_good = false;
449        }
450      }
451      cx0 = cx1;
452    }
453    good_pitches_.Finish();
454    all_pitches_.Finish();
455    good_gaps_.Finish();
456    all_gaps_.Finish();
457    heights_.Finish();
458    height_ = heights_.ile(0.875);
459    if (all_pitches_.empty()) {
460      pitch_ = 0.0f;
461      gap_ = 0.0f;
462    } else if (good_pitches_.size() < 2) {
463      pitch_ = all_pitches_.median();
464      ASSERT_HOST(pitch_ > 0.0f);
465      gap_ = all_gaps_.ile(0.125);
466    } else {
467      pitch_ = good_pitches_.median();
468      ASSERT_HOST(pitch_ > 0.0f);
469      gap_ = good_gaps_.ile(0.125);
470    }
471  }
472  void FPRow::DebugOutputResult(int row_index) {
473    if (num_chars() > 0) {
474      tprintf(
475          "Row %d: pitch_decision=%d, fixed_pitch=%f, max_nonspace=%d, "
476          "space_size=%f, space_threshold=%d, xheight=%f\n",
477          row_index, static_cast<int>(real_row_->pitch_decision), real_row_->fixed_pitch,
478          real_row_->max_nonspace, real_row_->space_size, real_row_->space_threshold,
479          real_row_->xheight);
480      for (unsigned i = 0; i < num_chars(); i++) {
481        tprintf("Char %u: is_final=%d is_good=%d num_blobs=%d: ", i, is_final(i), is_good(i),
482                character(i)->num_blobs());
483        box(i).print();
484      }
485    }
486  }
487  void FPRow::Pass1Analyze() {
488    if (num_chars() < 2) {
489      return;
490    }
491    if (estimated_pitch_ > 0.0f) {
492      for (size_t i = 2; i < num_chars(); i++) {
493        if (is_good_pitch(estimated_pitch_, box(i - 2), box(i - 1)) &&
494            is_good_pitch(estimated_pitch_, box(i - 1), box(i))) {
495          mark_good(i - 1);
496        }
497      }
498    } else {
499      for (size_t i = 2; i < num_chars(); i++) {
500        if (is_good_pitch(box_pitch(box(i - 2), box(i - 1)), box(i - 1), box(i))) {
501          mark_good(i - 1);
502        }
503      }
504    }
505    character(0)->set_alignment(character(1)->alignment());
506    character(num_chars() - 1)->set_alignment(character(num_chars() - 2)->alignment());
507  }
508  bool FPRow::Pass2Analyze() {
509    bool changed = false;
510    if (num_chars() <= 1 || estimated_pitch_ == 0.0f) {
511      return false;
512    }
513    for (size_t i = 0; i < num_chars(); i++) {
514      if (is_final(i)) {
515        continue;
516      }
517      FPChar::Alignment alignment = character(i)->alignment();
518      bool intersecting = false;
519      bool not_intersecting = false;
520      if (i < num_chars() - 1 && is_final(i + 1)) {
521        bool skipped_whitespaces = false;
522        float c1 = center_x(i + 1) - 1.5 * estimated_pitch_;
523        while (c1 > box(i).right()) {
524          skipped_whitespaces = true;
525          c1 -= estimated_pitch_;
526        }
527        TBOX ibody(c1, box(i).bottom(), c1 + estimated_pitch_, box(i).top());
528        int j = i;
529        TBOX merged;
530        while (j >= 0 && !is_final(j) && mostly_overlap(ibody, box(j)) &&
531               merged.bounding_union(box(j)).height() < estimated_pitch_ * (1 + kFPTolerance)) {
532          merged += box(j);
533          j--;
534        }
535        if (j >= 0 && significant_overlap(ibody, box(j))) {
536          if (!is_final(j)) {
537            intersecting = true;
538          }
539        } else {
540          not_intersecting = true;
541          if (i - j > 0) {
542            if (i - j == 1) {
543              if (!skipped_whitespaces) {
544                mark_good(i);
545              }
546              if (box(i).width() <= estimated_pitch_ * 0.5) {
547                ibody += box(i);
548                character(i)->set_box(ibody);
549              }
550              character(i)->set_merge_to_prev(false);
551              finalize(i);
552            } else {
553              for (int k = i; k > j + 1; k--) {
554                character(k)->set_merge_to_prev(true);
555              }
556            }
557          }
558        }
559      }
560      if (i > 0 && is_final(i - 1)) {
561        bool skipped_whitespaces = false;
562        float c1 = center_x(i - 1) + 1.5 * estimated_pitch_;
563        while (c1 < box(i).left()) {
564          skipped_whitespaces = true;
565          c1 += estimated_pitch_;
566        }
567        TBOX ibody(c1 - estimated_pitch_, box(i).bottom(), c1, box(i).top());
568        size_t j = i;
569        TBOX merged;
570        while (j < num_chars() && !is_final(j) && mostly_overlap(ibody, box(j)) &&
571               merged.bounding_union(box(j)).height() < estimated_pitch_ * (1 + kFPTolerance)) {
572          merged += box(j);
573          j++;
574        }
575        if (j < num_chars() && significant_overlap(ibody, box(j))) {
576          if (!is_final(j)) {
577            intersecting = true;
578          }
579        } else {
580          not_intersecting = true;
581          if (j - i > 0) {
582            if (j - i == 1) {
583              if (!skipped_whitespaces) {
584                mark_good(i);
585              }
586              if (box(i).width() <= estimated_pitch_ * 0.5) {
587                ibody += box(i);
588                character(i)->set_box(ibody);
589              }
590              character(i)->set_merge_to_prev(false);
591              finalize(i);
592            } else {
593              for (size_t k = i + 1; k < j; k++) {
594                character(k)->set_merge_to_prev(true);
595              }
596            }
597          }
598        }
599      }
600      if (intersecting && !not_intersecting) {
601        mark_bad(i);
602      }
603      if (character(i)->alignment() != alignment || character(i)->merge_to_prev()) {
604        changed = true;
605      }
606    }
607    return changed;
608  }
609  void FPRow::MergeFragments() {
610    int last_char = 0;
611    for (size_t j = 0; j < num_chars(); ++j) {
612      if (character(j)->merge_to_prev()) {
613        character(last_char)->Merge(*character(j));
614        character(j)->set_delete_flag(true);
615        clear_alignment(last_char);
616        character(j - 1)->set_merge_to_prev(false);
617      } else {
618        last_char = j;
619      }
620    }
621    DeleteChars();
622  }
623  void FPRow::FinalizeLargeChars() {
624    float row_pitch = estimated_pitch();
625    for (size_t i = 0; i < num_chars(); i++) {
626      if (is_final(i)) {
627        continue;
628      }
629      if (i > 0 && is_final(i - 1) && i < num_chars() - 1 && is_final(i + 1)) {
630        finalize(i);
631        continue;
632      }
633      float cx = center_x(i);
634      TBOX ibody(cx - 0.5 * row_pitch, 0, cx + 0.5 * row_pitch, 1);
635      if (i > 0) {
636        if (x_overlap_fraction(ibody, box(i - 1)) > 0.1) {
637          continue;
638        }
639        if (!is_final(i - 1)) {
640          TBOX merged = box(i);
641          merged += box(i - 1);
642          if (merged.width() < row_pitch) {
643            continue;
644          }
645        }
646      }
647      if (i < num_chars() - 1) {
648        if (x_overlap_fraction(ibody, box(i + 1)) > 0.1) {
649          continue;
650        }
651        if (!is_final(i + 1)) {
652          TBOX merged = box(i);
653          merged += box(i + 1);
654          if (merged.width() < row_pitch) {
655            continue;
656          }
657        }
658      }
659      finalize(i);
660    }
661    for (size_t i = 0; i < num_chars(); i++) {
662      if (!is_final(i)) {
663        continue;
664      }
665      bool good_pitch = false;
666      bool bad_pitch = false;
667      if (i > 0 && is_final(i - 1)) {
668        if (is_good_pitch(row_pitch, box(i - 1), box(i))) {
669          good_pitch = true;
670        } else {
671          bad_pitch = true;
672        }
673      }
674      if (i < num_chars() - 1 && is_final(i + 1)) {
675        if (is_good_pitch(row_pitch, box(i), box(i + 1))) {
676          good_pitch = true;
677        } else {
678          bad_pitch = true;
679        }
680      }
681      if (good_pitch && !bad_pitch) {
682        mark_good(i);
683      } else if (!good_pitch && bad_pitch) {
684        mark_bad(i);
685      }
686    }
687  }
688  class FPAnalyzer {
689  public:
690    FPAnalyzer(ICOORD page_tr, TO_BLOCK_LIST *port_blocks);
691    ~FPAnalyzer() = default;
692    void Pass1Analyze() {
693      for (auto &row : rows_) {
694        row.Pass1Analyze();
695      }
696    }
697    void EstimatePitch(bool pass1);
698    bool maybe_fixed_pitch() {
699      if (rows_.empty() || rows_.size() <= num_bad_rows_ + num_tall_rows_ + 1) {
700        return false;
701      }
702      return true;
703    }
704    void MergeFragments() {
705      for (auto &row : rows_) {
706        row.MergeFragments();
707      }
708    }
709    void FinalizeLargeChars() {
710      for (auto &row : rows_) {
711        row.FinalizeLargeChars();
712      }
713    }
714    bool Pass2Analyze() {
715      bool changed = false;
716      for (auto &row : rows_) {
717        if (row.Pass2Analyze()) {
718          changed = true;
719        }
720      }
721      return changed;
722    }
723    void OutputEstimations() {
724      for (auto &row : rows_) {
725        row.OutputEstimations();
726      }
727    }
728    void DebugOutputResult() {
729      tprintf("FPAnalyzer: final result\n");
730      for (size_t i = 0; i < rows_.size(); i++) {
731        rows_[i].DebugOutputResult(i);
732      }
733    }
734    size_t num_rows() {
735      return rows_.size();
736    }
737    unsigned max_iteration() {
738      return max_chars_per_row_ + 100;
739    }
740  private:
741    ICOORD page_tr_;
742    std::vector<FPRow> rows_;
743    unsigned num_tall_rows_;
744    unsigned num_bad_rows_;
745    unsigned num_empty_rows_;
746    unsigned max_chars_per_row_;
747  };
748  FPAnalyzer::FPAnalyzer(ICOORD page_tr, TO_BLOCK_LIST *port_blocks)
749      : page_tr_(page_tr)
750      , num_tall_rows_(0)
751      , num_bad_rows_(0)
752      , num_empty_rows_(0)
753      , max_chars_per_row_(0) {
754    TO_BLOCK_IT block_it(port_blocks);
755    for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward()) {
756      TO_BLOCK *block = block_it.data();
757      if (!block->get_rows()->empty()) {
758        ASSERT_HOST(block->xheight > 0);
759        find_repeated_chars(block, false);
760      }
761    }
762    for (block_it.mark_cycle_pt(); !block_it.cycled_list(); block_it.forward()) {
763      TO_ROW_IT row_it = block_it.data()->get_rows();
764      for (row_it.mark_cycle_pt(); !row_it.cycled_list(); row_it.forward()) {
765        FPRow row;
766        row.Init(row_it.data());
767        rows_.push_back(row);
768        size_t num_chars = rows_.back().num_chars();
769        if (num_chars <= 1) {
770          num_empty_rows_++;
771        }
772        if (num_chars > max_chars_per_row_) {
773          max_chars_per_row_ = num_chars;
774        }
775      }
776    }
777  }
778  void FPAnalyzer::EstimatePitch(bool pass1) {
779    LocalCorrelation pitch_height_stats;
780    num_tall_rows_ = 0;
781    num_bad_rows_ = 0;
782    pitch_height_stats.Clear();
783    for (auto &row : rows_) {
784      row.EstimatePitch(pass1);
785      if (row.good_pitches()) {
786        pitch_height_stats.Add(row.height() + row.gap(), row.pitch(), row.good_pitches());
787        if (row.height_pitch_ratio() > 1.1) {
788          num_tall_rows_++;
789        }
790      } else {
791        num_bad_rows_++;
792      }
793    }
794    pitch_height_stats.Finish();
795    for (auto &row : rows_) {
796      if (row.good_pitches() >= 5) {
797        row.set_estimated_pitch(row.pitch());
798      } else if (row.num_chars() > 1) {
799        float estimated_pitch = pitch_height_stats.EstimateYFor(row.height() + row.gap(), 0.1f);
800        if (estimated_pitch > row.pitch() || row.pitch() > row.height() * 2.0) {
801          row.set_estimated_pitch(estimated_pitch);
802        } else {
803          row.set_estimated_pitch(row.pitch());
804        }
805      }
806    }
807  }
808  void compute_fixed_pitch_cjk(ICOORD page_tr, TO_BLOCK_LIST *port_blocks) {
809    FPAnalyzer analyzer(page_tr, port_blocks);
810    if (analyzer.num_rows() == 0) {
811      return;
812    }
813    analyzer.Pass1Analyze();
814    analyzer.EstimatePitch(true);
815    analyzer.Pass1Analyze();
816    analyzer.EstimatePitch(true);
817    if (!analyzer.maybe_fixed_pitch()) {
818      if (textord_debug_pitch_test) {
819        tprintf("Page doesn't seem to contain fixed pitch rows\n");
820      }
821      return;
822    }
823    unsigned iteration = 0;
824    do {
825      analyzer.MergeFragments();
826      analyzer.FinalizeLargeChars();
827      analyzer.EstimatePitch(false);
828      iteration++;
829    } while (analyzer.Pass2Analyze() && iteration < analyzer.max_iteration());
830    if (textord_debug_pitch_test) {
831      tprintf("compute_fixed_pitch_cjk finished after %u iteration (limit=%u)\n", iteration,
832              analyzer.max_iteration());
833    }
834    analyzer.OutputEstimations();
835    if (textord_debug_pitch_test) {
836      analyzer.DebugOutputResult();
837    }
838  }
839  } 
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-tablefind.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include <algorithm>
5  #include <cmath>
6  #include <utility>
7  #include "tablefind.h"
8  #include <allheaders.h>
9  #include "colpartitionset.h"
10  #include "tablerecog.h"
11  namespace tesseract {
12  const int kMaxVerticalSpacing = 500;
13  const int kMaxBlobWidth = 500;
14  const double kSplitPartitionSize = 2.0;
15  const double kAllowTextHeight = 0.5;
16  const double kAllowTextWidth = 0.6;
17  const double kAllowTextArea = 0.8;
18  const double kAllowBlobHeight = 0.3;
19  const double kAllowBlobWidth = 0.4;
20  const double kAllowBlobArea = 0.05;
21  const int kMinBoxesInTextPartition = 10;
22  const int kMaxBoxesInDataPartition = 20;
23  const double kMaxGapInTextPartition = 4.0;
24  const double kMinMaxGapInTextPartition = 0.5;
25  const double kMaxBlobOverlapFactor = 4.0;
26  const double kMaxTableCellXheight = 2.0;
27  const int kMaxColumnHeaderDistance = 4;
28  const double kTableColumnThreshold = 3.0;
29  const double kMinOverlapWithTable = 0.6;
30  const int kSideSpaceMargin = 10;
31  const double kSmallTableProjectionThreshold = 0.35;
32  const double kLargeTableProjectionThreshold = 0.45;
33  const int kLargeTableRowCount = 6;
34  const int kMinRowsInTable = 3;
35  const int kAdjacentLeaderSearchPadding = 2;
36  const double kParagraphEndingPreviousLineRatio = 1.3;
37  const double kMaxParagraphEndingLeftSpaceMultiple = 3.0;
38  const double kMinParagraphEndingTextToWhitespaceRatio = 3.0;
39  const double kMaxXProjectionGapFactor = 2.0;
40  const double kStrokeWidthFractionalTolerance = 0.25;
41  const double kStrokeWidthConstantTolerance = 2.0;
42  #ifndef GRAPHICS_DISABLED
43  static BOOL_VAR(textord_show_tables, false, "Show table regions (ScrollView)");
44  static BOOL_VAR(textord_tablefind_show_mark, false,
45                  "Debug table marking steps in detail (ScrollView)");
46  static BOOL_VAR(textord_tablefind_show_stats, false,
47                  "Show page stats used in table finding (ScrollView)");
48  #endif
49  static BOOL_VAR(textord_tablefind_recognize_tables, false,
50                  "Enables the table recognizer for table layout and filtering.");
51  template <typename T>
52  void DeleteObject(T *object) {
53    delete object;
54  }
55  TableFinder::TableFinder()
56      : resolution_(0),
57        global_median_xheight_(0),
58        global_median_blob_width_(0),
59        global_median_ledding_(0),
60        left_to_right_language_(true) {}
61  TableFinder::~TableFinder() {
62    clean_part_grid_.ClearGridData(&DeleteObject<ColPartition>);
63    leader_and_ruling_grid_.ClearGridData(&DeleteObject<ColPartition>);
64    fragmented_text_grid_.ClearGridData(&DeleteObject<ColPartition>);
65    col_seg_grid_.ClearGridData(&DeleteObject<ColSegment>);
66    table_grid_.ClearGridData(&DeleteObject<ColSegment>);
67  }
68  void TableFinder::set_left_to_right_language(bool order) {
69    left_to_right_language_ = order;
70  }
71  void TableFinder::Init(int grid_size, const ICOORD &bottom_left,
72                         const ICOORD &top_right) {
73    clean_part_grid_.Init(grid_size, bottom_left, top_right);
74    leader_and_ruling_grid_.Init(grid_size, bottom_left, top_right);
75    fragmented_text_grid_.Init(grid_size, bottom_left, top_right);
76    col_seg_grid_.Init(grid_size, bottom_left, top_right);
77    table_grid_.Init(grid_size, bottom_left, top_right);
78  }
79  void TableFinder::InsertCleanPartitions(ColPartitionGrid *grid,
80                                          TO_BLOCK *block) {
81    SetGlobalSpacings(grid);
82    ColPartitionGridSearch gsearch(grid);
83    gsearch.SetUniqueMode(true);
84    gsearch.StartFullSearch();
85    ColPartition *part = nullptr;
86    while ((part = gsearch.NextFullSearch()) != nullptr) {
87      if (part->blob_type() == BRT_NOISE || part->bounding_box().area() <= 0) {
88        continue;
89      }
90      ColPartition *clean_part = part->ShallowCopy();
91      ColPartition *leader_part = nullptr;
92      if (part->IsLineType()) {
93        InsertRulingPartition(clean_part);
94        continue;
95      }
96      if (!part->IsTextType()) {
97        InsertImagePartition(clean_part);
98        continue;
99      }
100      BLOBNBOX_CLIST *part_boxes = part->boxes();
101      BLOBNBOX_C_IT pit(part_boxes);
102      for (pit.mark_cycle_pt(); !pit.cycled_list(); pit.forward()) {
103        BLOBNBOX *pblob = pit.data();
104        if (!AllowBlob(*pblob)) {
105          continue;
106        }
107        if (pblob->flow() == BTFT_LEADER) {
108          if (leader_part == nullptr) {
109            leader_part = part->ShallowCopy();
110            leader_part->set_flow(BTFT_LEADER);
111          }
112          leader_part->AddBox(pblob);
113        } else if (pblob->region_type() != BRT_NOISE) {
114          clean_part->AddBox(pblob);
115        }
116      }
117      clean_part->ComputeLimits();
118      ColPartition *fragmented = clean_part->CopyButDontOwnBlobs();
119      InsertTextPartition(clean_part);
120      SplitAndInsertFragmentedTextPartition(fragmented);
121      if (leader_part != nullptr) {
122        leader_part->ComputeLimits();
123        InsertLeaderPartition(leader_part);
124      }
125    }
126    clean_part_grid_.FindPartitionPartners();
127    clean_part_grid_.RefinePartitionPartners(false);
128  }
129  void TableFinder::LocateTables(ColPartitionGrid *grid,
130                                 ColPartitionSet **all_columns,
131                                 WidthCallback width_cb, const FCOORD &reskew) {
132    InitializePartitions(all_columns);
133  #ifndef GRAPHICS_DISABLED
134    if (textord_show_tables) {
135      ScrollView *table_win = MakeWindow(0, 300, "Column Partitions & Neighbors");
136      DisplayColPartitions(table_win, &clean_part_grid_, ScrollView::BLUE);
137      DisplayColPartitions(table_win, &leader_and_ruling_grid_,
138                           ScrollView::AQUAMARINE);
139      DisplayColPartitionConnections(table_win, &clean_part_grid_,
140                                     ScrollView::ORANGE);
141      table_win = MakeWindow(100, 300, "Fragmented Text");
142      DisplayColPartitions(table_win, &fragmented_text_grid_, ScrollView::BLUE);
143    }
144  #endif 
145    MarkTablePartitions();
146    ColSegment_LIST column_blocks;
147    GetColumnBlocks(all_columns, &column_blocks);
148    SetColumnsType(&column_blocks);
149    MoveColSegmentsToGrid(&column_blocks, &col_seg_grid_);
150    GridMergeColumnBlocks();
151    ColSegment_LIST table_columns;
152    GetTableColumns(&table_columns);
153    ColSegment_LIST table_regions;
154    GetTableRegions(&table_columns, &table_regions);
155  #ifndef GRAPHICS_DISABLED
156    if (textord_tablefind_show_mark) {
157      ScrollView *table_win = MakeWindow(1200, 300, "Table Columns and Regions");
158      DisplayColSegments(table_win, &table_columns, ScrollView::DARK_TURQUOISE);
159      DisplayColSegments(table_win, &table_regions, ScrollView::YELLOW);
160    }
161  #endif 
162    MoveColSegmentsToGrid(&table_regions, &table_grid_);
163    GridMergeTableRegions();
164    AdjustTableBoundaries();
165    GridMergeTableRegions();
166    if (textord_tablefind_recognize_tables) {
167      DeleteSingleColumnTables();
168  #ifndef GRAPHICS_DISABLED
169      if (textord_show_tables) {
170        ScrollView *table_win = MakeWindow(1200, 300, "Detected Table Locations");
171        DisplayColPartitions(table_win, &clean_part_grid_, ScrollView::BLUE);
172        DisplayColSegments(table_win, &table_columns, ScrollView::KHAKI);
173        table_grid_.DisplayBoxes(table_win);
174      }
175  #endif 
176      RecognizeTables();
177      GridMergeTableRegions();
178      RecognizeTables();
179  #ifndef GRAPHICS_DISABLED
180      if (textord_show_tables) {
181        ScrollView *table_win = MakeWindow(1400, 600, "Recognized Tables");
182        DisplayColPartitions(table_win, &clean_part_grid_, ScrollView::BLUE,
183                             ScrollView::BLUE);
184        table_grid_.DisplayBoxes(table_win);
185      }
186  #endif 
187    } else {
188      DeleteSingleColumnTables();
189  #ifndef GRAPHICS_DISABLED
190      if (textord_show_tables) {
191        ScrollView *table_win = MakeWindow(1500, 300, "Detected Tables");
192        DisplayColPartitions(table_win, &clean_part_grid_, ScrollView::BLUE,
193                             ScrollView::BLUE);
194        table_grid_.DisplayBoxes(table_win);
195      }
196  #endif 
197    }
198    MakeTableBlocks(grid, all_columns, width_cb);
199  }
200  int TableFinder::gridsize() const {
201    return clean_part_grid_.gridsize();
202  }
203  int TableFinder::gridwidth() const {
204    return clean_part_grid_.gridwidth();
205  }
206  int TableFinder::gridheight() const {
207    return clean_part_grid_.gridheight();
208  }
209  const ICOORD &TableFinder::bleft() const {
210    return clean_part_grid_.bleft();
211  }
212  const ICOORD &TableFinder::tright() const {
213    return clean_part_grid_.tright();
214  }
215  void TableFinder::InsertTextPartition(ColPartition *part) {
216    ASSERT_HOST(part != nullptr);
217    if (AllowTextPartition(*part)) {
218      clean_part_grid_.InsertBBox(true, true, part);
219    } else {
220      delete part;
221    }
222  }
223  void TableFinder::InsertFragmentedTextPartition(ColPartition *part) {
224    ASSERT_HOST(part != nullptr);
225    if (AllowTextPartition(*part)) {
226      fragmented_text_grid_.InsertBBox(true, true, part);
227    } else {
228      delete part;
229    }
230  }
231  void TableFinder::InsertLeaderPartition(ColPartition *part) {
232    ASSERT_HOST(part != nullptr);
233    if (!part->IsEmpty() && part->bounding_box().area() > 0) {
234      leader_and_ruling_grid_.InsertBBox(true, true, part);
235    } else {
236      delete part;
237    }
238  }
239  void TableFinder::InsertRulingPartition(ColPartition *part) {
240    leader_and_ruling_grid_.InsertBBox(true, true, part);
241  }
242  void TableFinder::InsertImagePartition(ColPartition *part) {
243    clean_part_grid_.InsertBBox(true, true, part);
244  }
245  void TableFinder::SplitAndInsertFragmentedTextPartition(ColPartition *part) {
246    ASSERT_HOST(part != nullptr);
247    if (part->boxes()->empty()) {
248      delete part;
249      return;
250    }
251    ASSERT_HOST(part->median_width() > 0);
252    const double kThreshold = part->median_width() * kSplitPartitionSize;
253    ColPartition *right_part = part;
254    bool found_split = true;
255    while (found_split) {
256      found_split = false;
257      BLOBNBOX_C_IT box_it(right_part->boxes());
258      int previous_right = INT32_MIN;
259      for (box_it.mark_cycle_pt(); !box_it.cycled_list(); box_it.forward()) {
260        const TBOX &box = box_it.data()->bounding_box();
261        if (previous_right != INT32_MIN &&
262            box.left() - previous_right > kThreshold) {
263          int mid_x = (box.left() + previous_right) / 2;
264          ColPartition *left_part = right_part;
265          right_part = left_part->SplitAt(mid_x);
266          InsertFragmentedTextPartition(left_part);
267          found_split = true;
268          break;
269        }
270        previous_right = std::max(previous_right, static_cast<int>(box.right()));
271      }
272    }
273    InsertFragmentedTextPartition(right_part);
274  }
275  bool TableFinder::AllowTextPartition(const ColPartition &part) const {
276    const double kHeightRequired = global_median_xheight_ * kAllowTextHeight;
277    const double kWidthRequired = global_median_blob_width_ * kAllowTextWidth;
278    const int median_area = global_median_xheight_ * global_median_blob_width_;
279    const double kAreaPerBlobRequired = median_area * kAllowTextArea;
280    return part.median_height() > kHeightRequired &&
281           part.median_width() > kWidthRequired &&
282           part.bounding_box().area() > kAreaPerBlobRequired * part.boxes_count();
283  }
284  bool TableFinder::AllowBlob(const BLOBNBOX &blob) const {
285    const TBOX &box = blob.bounding_box();
286    const double kHeightRequired = global_median_xheight_ * kAllowBlobHeight;
287    const double kWidthRequired = global_median_blob_width_ * kAllowBlobWidth;
288    const int median_area = global_median_xheight_ * global_median_blob_width_;
289    const double kAreaRequired = median_area * kAllowBlobArea;
290    return box.height() > kHeightRequired && box.width() > kWidthRequired &&
291           box.area() > kAreaRequired;
292  }
293  #ifndef GRAPHICS_DISABLED
294  ScrollView *TableFinder::MakeWindow(int x, int y, const char *window_name) {
295    return clean_part_grid_.MakeWindow(x, y, window_name);
296  }
297  #endif
298  void TableFinder::GetColumnBlocks(ColPartitionSet **all_columns,
299                                    ColSegment_LIST *column_blocks) {
300    for (int i = 0; i < gridheight(); ++i) {
301      ColPartitionSet *columns = all_columns[i];
302      if (columns != nullptr) {
303        ColSegment_LIST new_blocks;
304        columns->GetColumnBoxes(i * gridsize(), (i + 1) * gridsize(),
305                                &new_blocks);
306        GroupColumnBlocks(&new_blocks, column_blocks);
307      }
308    }
309  }
310  void TableFinder::GroupColumnBlocks(ColSegment_LIST *new_blocks,
311                                      ColSegment_LIST *column_blocks) {
312    ColSegment_IT src_it(new_blocks);
313    ColSegment_IT dest_it(column_blocks);
314    for (src_it.mark_cycle_pt(); !src_it.cycled_list(); src_it.forward()) {
315      ColSegment *src_seg = src_it.data();
316      const TBOX &src_box = src_seg->bounding_box();
317      bool match_found = false;
318      for (dest_it.mark_cycle_pt(); !dest_it.cycled_list(); dest_it.forward()) {
319        ColSegment *dest_seg = dest_it.data();
320        TBOX dest_box = dest_seg->bounding_box();
321        if (ConsecutiveBoxes(src_box, dest_box)) {
322          dest_seg->InsertBox(src_box);
323          match_found = true;
324          delete src_it.extract();
325          break;
326        }
327      }
328      if (!match_found) {
329        dest_it.add_after_then_move(src_it.extract());
330      }
331    }
332  }
333  bool TableFinder::ConsecutiveBoxes(const TBOX &b1, const TBOX &b2) {
334    int x_margin = 20;
335    int y_margin = 5;
336    return (abs(b1.left() - b2.left()) < x_margin) &&
337           (abs(b1.right() - b2.right()) < x_margin) &&
338           (abs(b1.top() - b2.bottom()) < y_margin ||
339            abs(b2.top() - b1.bottom()) < y_margin);
340  }
341  void TableFinder::InitializePartitions(ColPartitionSet **all_columns) {
342    FindNeighbors();
343    SetPartitionSpacings(&clean_part_grid_, all_columns);
344    SetGlobalSpacings(&clean_part_grid_);
345  }
346  void TableFinder::SetPartitionSpacings(ColPartitionGrid *grid,
347                                         ColPartitionSet **all_columns) {
348    ColPartitionGridSearch gsearch(grid);
349    gsearch.StartFullSearch();
350    ColPartition *part = nullptr;
351    while ((part = gsearch.NextFullSearch()) != nullptr) {
352      ColPartitionSet *columns = all_columns[gsearch.GridY()];
353      TBOX box = part->bounding_box();
354      int y = part->MidY();
355      ColPartition *left_column = columns->ColumnContaining(box.left(), y);
356      ColPartition *right_column = columns->ColumnContaining(box.right(), y);
357      if (left_column) {
358        int left_space = std::max(0, box.left() - left_column->LeftAtY(y));
359        part->set_space_to_left(left_space);
360      }
361      if (right_column) {
362        int right_space = std::max(0, right_column->RightAtY(y) - box.right());
363        part->set_space_to_right(right_space);
364      }
365      ColPartitionGridSearch hsearch(grid);
366      hsearch.StartSideSearch(box.left(), box.bottom(), box.top());
367      ColPartition *neighbor = nullptr;
368      while ((neighbor = hsearch.NextSideSearch(true)) != nullptr) {
369        if (neighbor->type() == PT_PULLOUT_IMAGE ||
370            neighbor->type() == PT_FLOWING_IMAGE ||
371            neighbor->type() == PT_HEADING_IMAGE) {
372          int right = neighbor->bounding_box().right();
373          if (right < box.left()) {
374            int space = std::min(box.left() - right, part->space_to_left());
375            part->set_space_to_left(space);
376          }
377        }
378      }
379      hsearch.StartSideSearch(box.left(), box.bottom(), box.top());
380      neighbor = nullptr;
381      while ((neighbor = hsearch.NextSideSearch(false)) != nullptr) {
382        if (neighbor->type() == PT_PULLOUT_IMAGE ||
383            neighbor->type() == PT_FLOWING_IMAGE ||
384            neighbor->type() == PT_HEADING_IMAGE) {
385          int left = neighbor->bounding_box().left();
386          if (left > box.right()) {
387            int space = std::min(left - box.right(), part->space_to_right());
388            part->set_space_to_right(space);
389          }
390        }
391      }
392      ColPartition *upper_part = part->SingletonPartner(true);
393      if (upper_part) {
394        int space =
395            std::max(0, static_cast<int>(upper_part->bounding_box().bottom() -
396                                         part->bounding_box().bottom()));
397        part->set_space_above(space);
398      } else {
399        part->set_space_above(INT32_MAX);
400      }
401      ColPartition *lower_part = part->SingletonPartner(false);
402      if (lower_part) {
403        int space =
404            std::max(0, static_cast<int>(part->bounding_box().bottom() -
405                                         lower_part->bounding_box().bottom()));
406        part->set_space_below(space);
407      } else {
408        part->set_space_below(INT32_MAX);
409      }
410    }
411  }
412  void TableFinder::SetVerticalSpacing(ColPartition *part) {
413    TBOX box = part->bounding_box();
414    int top_range =
415        std::min(box.top() + kMaxVerticalSpacing, static_cast<int>(tright().y()));
416    int bottom_range = std::max(box.bottom() - kMaxVerticalSpacing,
417                                static_cast<int>(bleft().y()));
418    box.set_top(top_range);
419    box.set_bottom(bottom_range);
420    TBOX part_box = part->bounding_box();
421    GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> rectsearch(
422        &clean_part_grid_);
423    rectsearch.StartRectSearch(box);
424    ColPartition *neighbor;
425    int min_space_above = kMaxVerticalSpacing;
426    int min_space_below = kMaxVerticalSpacing;
427    ColPartition *above_neighbor = nullptr;
428    ColPartition *below_neighbor = nullptr;
429    while ((neighbor = rectsearch.NextRectSearch()) != nullptr) {
430      if (neighbor == part) {
431        continue;
432      }
433      TBOX neighbor_box = neighbor->bounding_box();
434      if (neighbor_box.major_x_overlap(part_box)) {
435        int gap = abs(part->median_bottom() - neighbor->median_bottom());
436        if (neighbor_box.top() < part_box.bottom() && gap < min_space_below) {
437          min_space_below = gap;
438          below_neighbor = neighbor;
439        } 
440        else if (part_box.top() < neighbor_box.bottom() &&
441                 gap < min_space_above) {
442          min_space_above = gap;
443          above_neighbor = neighbor;
444        }
445      }
446    }
447    part->set_space_above(min_space_above);
448    part->set_space_below(min_space_below);
449    part->set_nearest_neighbor_above(above_neighbor);
450    part->set_nearest_neighbor_below(below_neighbor);
451  }
452  void TableFinder::SetGlobalSpacings(ColPartitionGrid *grid) {
453    STATS xheight_stats(0, kMaxVerticalSpacing);
454    STATS width_stats(0, kMaxBlobWidth);
455    STATS ledding_stats(0, kMaxVerticalSpacing);
456    ColPartitionGridSearch gsearch(grid);
457    gsearch.SetUniqueMode(true);
458    gsearch.StartFullSearch();
459    ColPartition *part = nullptr;
460    while ((part = gsearch.NextFullSearch()) != nullptr) {
461      if (part->IsTextType()) {
462        BLOBNBOX_C_IT it(part->boxes());
463        for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
464          xheight_stats.add(it.data()->bounding_box().height(), 1);
465          width_stats.add(it.data()->bounding_box().width(), 1);
466        }
467        ledding_stats.add(part->space_above(), 1);
468        ledding_stats.add(part->space_below(), 1);
469      }
470    }
471    set_global_median_xheight(static_cast<int>(xheight_stats.median() + 0.5));
472    set_global_median_blob_width(static_cast<int>(width_stats.median() + 0.5));
473    set_global_median_ledding(static_cast<int>(ledding_stats.median() + 0.5));
474  #ifndef GRAPHICS_DISABLED
475    if (textord_tablefind_show_stats) {
476      const char *kWindowName = "X-height (R), X-width (G), and ledding (B)";
477      ScrollView *stats_win = MakeWindow(500, 10, kWindowName);
478      xheight_stats.plot(stats_win, 10, 200, 2, 15, ScrollView::RED);
479      width_stats.plot(stats_win, 10, 200, 2, 15, ScrollView::GREEN);
480      ledding_stats.plot(stats_win, 10, 200, 2, 15, ScrollView::BLUE);
481    }
482  #endif 
483  }
484  void TableFinder::set_global_median_xheight(int xheight) {
485    global_median_xheight_ = xheight;
486  }
487  void TableFinder::set_global_median_blob_width(int width) {
488    global_median_blob_width_ = width;
489  }
490  void TableFinder::set_global_median_ledding(int ledding) {
491    global_median_ledding_ = ledding;
492  }
493  void TableFinder::FindNeighbors() {
494    ColPartitionGridSearch gsearch(&clean_part_grid_);
495    gsearch.StartFullSearch();
496    ColPartition *part = nullptr;
497    while ((part = gsearch.NextFullSearch()) != nullptr) {
498      ColPartition *upper = part->SingletonPartner(true);
499      if (upper) {
500        part->set_nearest_neighbor_above(upper);
501      }
502      ColPartition *lower = part->SingletonPartner(false);
503      if (lower) {
504        part->set_nearest_neighbor_below(lower);
505      }
506    }
507  }
508  void TableFinder::MarkTablePartitions() {
509    MarkPartitionsUsingLocalInformation();
510  #ifndef GRAPHICS_DISABLED
511    if (textord_tablefind_show_mark) {
512      ScrollView *table_win = MakeWindow(300, 300, "Initial Table Partitions");
513      DisplayColPartitions(table_win, &clean_part_grid_, ScrollView::BLUE);
514      DisplayColPartitions(table_win, &leader_and_ruling_grid_,
515                           ScrollView::AQUAMARINE);
516    }
517  #endif
518    FilterFalseAlarms();
519  #ifndef GRAPHICS_DISABLED
520    if (textord_tablefind_show_mark) {
521      ScrollView *table_win = MakeWindow(600, 300, "Filtered Table Partitions");
522      DisplayColPartitions(table_win, &clean_part_grid_, ScrollView::BLUE);
523      DisplayColPartitions(table_win, &leader_and_ruling_grid_,
524                           ScrollView::AQUAMARINE);
525    }
526  #endif
527    SmoothTablePartitionRuns();
528  #ifndef GRAPHICS_DISABLED
529    if (textord_tablefind_show_mark) {
530      ScrollView *table_win = MakeWindow(900, 300, "Smoothed Table Partitions");
531      DisplayColPartitions(table_win, &clean_part_grid_, ScrollView::BLUE);
532      DisplayColPartitions(table_win, &leader_and_ruling_grid_,
533                           ScrollView::AQUAMARINE);
534    }
535  #endif
536    FilterFalseAlarms();
537  #ifndef GRAPHICS_DISABLED
538    if (textord_tablefind_show_mark || textord_show_tables) {
539      ScrollView *table_win = MakeWindow(900, 300, "Final Table Partitions");
540      DisplayColPartitions(table_win, &clean_part_grid_, ScrollView::BLUE);
541      DisplayColPartitions(table_win, &leader_and_ruling_grid_,
542                           ScrollView::AQUAMARINE);
543    }
544  #endif
545  }
546  void TableFinder::MarkPartitionsUsingLocalInformation() {
547    GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> gsearch(
548        &clean_part_grid_);
549    gsearch.StartFullSearch();
550    ColPartition *part = nullptr;
551    while ((part = gsearch.NextFullSearch()) != nullptr) {
552      if (!part->IsTextType()) { 
553        continue;
554      }
555      if (part->median_height() > kMaxTableCellXheight * global_median_xheight_) {
556        continue;
557      }
558      if (HasWideOrNoInterWordGap(part) || HasLeaderAdjacent(*part)) {
559        part->set_table_type();
560      }
561    }
562  }
563  bool TableFinder::HasWideOrNoInterWordGap(ColPartition *part) const {
564    ASSERT_HOST(part->IsTextType());
565    BLOBNBOX_CLIST *part_boxes = part->boxes();
566    BLOBNBOX_C_IT it(part_boxes);
567    if (part->bounding_box().width() <
568            kMinBoxesInTextPartition * part->median_height() &&
569        part_boxes->length() < kMinBoxesInTextPartition) {
570      return true;
571    }
572    int current_x0 = -1;
573    int current_x1 = -1;
574    int previous_x1 = -1;
575    int largest_partition_gap_found = -1;
576    const double max_gap = kMaxGapInTextPartition * part->median_height();
577    const double min_gap = kMinMaxGapInTextPartition * part->median_height();
578    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
579      BLOBNBOX *blob = it.data();
580      current_x0 = blob->bounding_box().left();
581      current_x1 = blob->bounding_box().right();
582      if (previous_x1 != -1) {
583        int gap = current_x0 - previous_x1;
584        if (gap < 0) {
585          if (-gap < part->median_height() * kMaxBlobOverlapFactor) {
586            previous_x1 = std::max(previous_x1, current_x1);
587            continue;
588          }
589          else {
590          }
591        }
592        if (gap > max_gap) {
593          return true;
594        }
595        if (gap > largest_partition_gap_found) {
596          largest_partition_gap_found = gap;
597        }
598      }
599      previous_x1 = current_x1;
600    }
601    if (part->bounding_box().width() >
602            kMaxBoxesInDataPartition * part->median_height() ||
603        part_boxes->length() > kMaxBoxesInDataPartition) {
604      return false;
605    }
606    if (largest_partition_gap_found == -1) {
607      return true;
608    }
609    return largest_partition_gap_found < min_gap;
610  }
611  bool TableFinder::HasLeaderAdjacent(const ColPartition &part) {
612    if (part.flow() == BTFT_LEADER) {
613      return true;
614    }
615    const TBOX &box = part.bounding_box();
616    const int search_size = kAdjacentLeaderSearchPadding * global_median_xheight_;
617    const int top = box.top() + search_size;
618    const int bottom = box.bottom() - search_size;
619    ColPartitionGridSearch hsearch(&leader_and_ruling_grid_);
620    for (int direction = 0; direction < 2; ++direction) {
621      bool right_to_left = (direction == 0);
622      int x = right_to_left ? box.right() : box.left();
623      hsearch.StartSideSearch(x, bottom, top);
624      ColPartition *leader = nullptr;
625      while ((leader = hsearch.NextSideSearch(right_to_left)) != nullptr) {
626        if (leader->flow() != BTFT_LEADER) {
627          continue;
628        }
629        ASSERT_HOST(&part != leader);
630        if (!part.IsInSameColumnAs(*leader)) {
631          break;
632        }
633        if (!leader->VSignificantCoreOverlap(part)) {
634          continue;
635        }
636        return true;
637      }
638    }
639    return false;
640  }
641  void TableFinder::FilterFalseAlarms() {
642    FilterParagraphEndings();
643    FilterHeaderAndFooter();
644  }
645  void TableFinder::FilterParagraphEndings() {
646    ColPartitionGridSearch gsearch(&clean_part_grid_);
647    gsearch.StartFullSearch();
648    ColPartition *part = nullptr;
649    while ((part = gsearch.NextFullSearch()) != nullptr) {
650      if (part->type() != PT_TABLE) {
651        continue; 
652      }
653      ColPartition *upper_part = part->nearest_neighbor_above();
654      if (!upper_part) {
655        continue;
656      }
657      if (upper_part->type() != PT_FLOWING_TEXT) {
658        continue;
659      }
660      if (upper_part->bounding_box().width() < 2 * part->bounding_box().width()) {
661        continue;
662      }
663      int mid = (part->bounding_box().left() + part->bounding_box().right()) / 2;
664      int upper_mid = (upper_part->bounding_box().left() +
665                       upper_part->bounding_box().right()) /
666                      2;
667      int current_spacing = 0; 
668      int upper_spacing = 0;   
669      if (left_to_right_language_) {
670        int left = std::min(part->bounding_box().left(),
671                            upper_part->bounding_box().left());
672        current_spacing = mid - left;
673        upper_spacing = upper_mid - left;
674      } else {
675        int right = std::max(part->bounding_box().right(),
676                             upper_part->bounding_box().right());
677        current_spacing = right - mid;
678        upper_spacing = right - upper_mid;
679      }
680      if (current_spacing * kParagraphEndingPreviousLineRatio > upper_spacing) {
681        continue;
682      }
683      if (!part->MatchingSizes(*upper_part) ||
684          !part->MatchingStrokeWidth(*upper_part, kStrokeWidthFractionalTolerance,
685                                     kStrokeWidthConstantTolerance)) {
686        continue;
687      }
688      if (part->space_to_left() >
689          kMaxParagraphEndingLeftSpaceMultiple * part->median_height()) {
690        continue;
691      }
692      if (upper_part->bounding_box().width() <
693          kMinParagraphEndingTextToWhitespaceRatio *
694              upper_part->space_to_right()) {
695        continue;
696      }
697      if (part->space_above() >= part->space_below() ||
698          part->space_above() > 2 * global_median_ledding_) {
699        continue;
700      }
701      part->clear_table_type();
702    }
703  }
704  void TableFinder::FilterHeaderAndFooter() {
705    ColPartition *header = nullptr;
706    ColPartition *footer = nullptr;
707    int max_top = INT32_MIN;
708    int min_bottom = INT32_MAX;
709    ColPartitionGridSearch gsearch(&clean_part_grid_);
710    gsearch.StartFullSearch();
711    ColPartition *part = nullptr;
712    while ((part = gsearch.NextFullSearch()) != nullptr) {
713      if (!part->IsTextType()) {
714        continue; 
715      }
716      int top = part->bounding_box().top();
717      int bottom = part->bounding_box().bottom();
718      if (top > max_top) {
719        max_top = top;
720        header = part;
721      }
722      if (bottom < min_bottom) {
723        min_bottom = bottom;
724        footer = part;
725      }
726    }
727    if (header) {
728      header->clear_table_type();
729    }
730    if (footer) {
731      footer->clear_table_type();
732    }
733  }
734  void TableFinder::SmoothTablePartitionRuns() {
735    ColPartitionGridSearch gsearch(&clean_part_grid_);
736    gsearch.StartFullSearch();
737    ColPartition *part = nullptr;
738    while ((part = gsearch.NextFullSearch()) != nullptr) {
739      if (part->type() >= PT_TABLE || part->type() == PT_UNKNOWN) {
740        continue; 
741      }
742      ColPartition *upper_part = part->nearest_neighbor_above();
743      ColPartition *lower_part = part->nearest_neighbor_below();
744      if (!upper_part || !lower_part) {
745        continue;
746      }
747      if (upper_part->type() == PT_TABLE && lower_part->type() == PT_TABLE) {
748        part->set_table_type();
749      }
750    }
751    gsearch.StartFullSearch();
752    part = nullptr;
753    while ((part = gsearch.NextFullSearch()) != nullptr) {
754      if (part->type() != PT_TABLE) {
755        continue; 
756      }
757      ColPartition *upper_part = part->nearest_neighbor_above();
758      ColPartition *lower_part = part->nearest_neighbor_below();
759      if ((upper_part && upper_part->type() != PT_TABLE) &&
760          (lower_part && lower_part->type() != PT_TABLE)) {
761        part->clear_table_type();
762      }
763    }
764  }
765  void TableFinder::SetColumnsType(ColSegment_LIST *column_blocks) {
766    ColSegment_IT it(column_blocks);
767    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
768      ColSegment *seg = it.data();
769      TBOX box = seg->bounding_box();
770      int num_table_cells = 0;
771      int num_text_cells = 0;
772      GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> rsearch(
773          &clean_part_grid_);
774      rsearch.SetUniqueMode(true);
775      rsearch.StartRectSearch(box);
776      ColPartition *part = nullptr;
777      while ((part = rsearch.NextRectSearch()) != nullptr) {
778        if (part->type() == PT_TABLE) {
779          num_table_cells++;
780        } else if (part->type() == PT_FLOWING_TEXT) {
781          num_text_cells++;
782        }
783      }
784      if (!num_table_cells && !num_text_cells) {
785        delete it.extract();
786      } else {
787        seg->set_num_table_cells(num_table_cells);
788        seg->set_num_text_cells(num_text_cells);
789        seg->set_type();
790      }
791    }
792  }
793  void TableFinder::MoveColSegmentsToGrid(ColSegment_LIST *segments,
794                                          ColSegmentGrid *col_seg_grid) {
795    ColSegment_IT it(segments);
796    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
797      ColSegment *seg = it.extract();
798      col_seg_grid->InsertBBox(true, true, seg);
799    }
800  }
801  void TableFinder::GridMergeColumnBlocks() {
802    int margin = gridsize();
803    GridSearch<ColSegment, ColSegment_CLIST, ColSegment_C_IT> gsearch(
804        &col_seg_grid_);
805    gsearch.StartFullSearch();
806    ColSegment *seg;
807    while ((seg = gsearch.NextFullSearch()) != nullptr) {
808      if (seg->type() != COL_TEXT) {
809        continue; 
810      }
811      bool neighbor_found = false;
812      bool modified = false; 
813      do {
814        TBOX box = seg->bounding_box();
815        int top_range =
816            std::min(box.top() + margin, static_cast<int>(tright().y()));
817        int bottom_range =
818            std::max(box.bottom() - margin, static_cast<int>(bleft().y()));
819        box.set_top(top_range);
820        box.set_bottom(bottom_range);
821        neighbor_found = false;
822        GridSearch<ColSegment, ColSegment_CLIST, ColSegment_C_IT> rectsearch(
823            &col_seg_grid_);
824        rectsearch.StartRectSearch(box);
825        ColSegment *neighbor = nullptr;
826        while ((neighbor = rectsearch.NextRectSearch()) != nullptr) {
827          if (neighbor == seg) {
828            continue;
829          }
830          const TBOX &neighbor_box = neighbor->bounding_box();
831          if (neighbor_box.overlap_fraction(box) >= 0.9) {
832            seg->InsertBox(neighbor_box);
833            modified = true;
834            rectsearch.RemoveBBox();
835            gsearch.RepositionIterator();
836            delete neighbor;
837            continue;
838          }
839          if (neighbor->type() != COL_TABLE) {
840            continue;
841          }
842          if (neighbor_box.major_x_overlap(box) && !box.contains(neighbor_box)) {
843            seg->InsertBox(neighbor_box);
844            neighbor_found = true;
845            modified = true;
846            rectsearch.RemoveBBox();
847            gsearch.RepositionIterator();
848            delete neighbor;
849          }
850        }
851      } while (neighbor_found);
852      if (modified) {
853        gsearch.RemoveBBox();
854        col_seg_grid_.InsertBBox(true, true, seg);
855        gsearch.RepositionIterator();
856      }
857    }
858  }
859  void TableFinder::GetTableColumns(ColSegment_LIST *table_columns) {
860    ColSegment_IT it(table_columns);
861    GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> gsearch(
862        &clean_part_grid_);
863    gsearch.StartFullSearch();
864    ColPartition *part;
865    while ((part = gsearch.NextFullSearch()) != nullptr) {
866      if (part->inside_table_column() || part->type() != PT_TABLE) {
867        continue; 
868      }
869      const TBOX &box = part->bounding_box();
870      auto *col = new ColSegment();
871      col->InsertBox(box);
872      part->set_inside_table_column(true);
873      GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> vsearch(
874          &clean_part_grid_);
875      vsearch.StartVerticalSearch(box.left(), box.right(), box.bottom());
876      ColPartition *neighbor = nullptr;
877      bool found_neighbours = false;
878      while ((neighbor = vsearch.NextVerticalSearch(true)) != nullptr) {
879        if (neighbor->inside_table_column()) {
880          continue;
881        }
882        if (neighbor->IsHorizontalLine()) {
883          continue;
884        }
885        if (neighbor->type() != PT_TABLE) {
886          break;
887        }
888        const TBOX &neighbor_box = neighbor->bounding_box();
889        col->InsertBox(neighbor_box);
890        neighbor->set_inside_table_column(true);
891        found_neighbours = true;
892      }
893      if (found_neighbours) {
894        it.add_after_then_move(col);
895      } else {
896        part->set_inside_table_column(false);
897        delete col;
898      }
899    }
900  }
901  void TableFinder::GetTableRegions(ColSegment_LIST *table_columns,
902                                    ColSegment_LIST *table_regions) {
903    ColSegment_IT cit(table_columns);
904    ColSegment_IT rit(table_regions);
905    GridSearch<ColSegment, ColSegment_CLIST, ColSegment_C_IT> gsearch(
906        &col_seg_grid_);
907    gsearch.StartFullSearch();
908    ColSegment *part;
909    int page_height = tright().y() - bleft().y();
910    ASSERT_HOST(page_height > 0);
911    bool *table_region = new bool[page_height];
912    while ((part = gsearch.NextFullSearch()) != nullptr) {
913      const TBOX &part_box = part->bounding_box();
914      for (int i = 0; i < page_height; i++) {
915        table_region[i] = false;
916      }
917      cit.move_to_first();
918      for (cit.mark_cycle_pt(); !cit.cycled_list(); cit.forward()) {
919        TBOX col_box = cit.data()->bounding_box();
920        TBOX intersection_box = col_box.intersection(part_box);
921        for (int i = intersection_box.bottom(); i < intersection_box.top(); i++) {
922          table_region[i - bleft().y()] = true;
923        }
924      }
925      TBOX current_table_box;
926      current_table_box.set_left(part_box.left());
927      current_table_box.set_right(part_box.right());
928      for (int i = 1; i < page_height; i++) {
929        if (!table_region[i - 1] && table_region[i]) {
930          current_table_box.set_bottom(i + bleft().y());
931        }
932        if (table_region[i - 1] && !table_region[i]) {
933          current_table_box.set_top(i + bleft().y());
934          if (!current_table_box.null_box()) {
935            auto *seg = new ColSegment();
936            seg->InsertBox(current_table_box);
937            rit.add_after_then_move(seg);
938          }
939        }
940      }
941    }
942    delete[] table_region;
943  }
944  void TableFinder::GridMergeTableRegions() {
945    GridSearch<ColSegment, ColSegment_CLIST, ColSegment_C_IT> gsearch(
946        &table_grid_);
947    gsearch.StartFullSearch();
948    ColSegment *seg = nullptr;
949    while ((seg = gsearch.NextFullSearch()) != nullptr) {
950      bool neighbor_found = false;
951      bool modified = false; 
952      do {
953        const TBOX &box = seg->bounding_box();
954        TBOX search_region(box);
955        search_region.set_left(bleft().x());
956        search_region.set_right(tright().x());
957        neighbor_found = false;
958        GridSearch<ColSegment, ColSegment_CLIST, ColSegment_C_IT> rectsearch(
959            &table_grid_);
960        rectsearch.StartRectSearch(search_region);
961        ColSegment *neighbor = nullptr;
962        while ((neighbor = rectsearch.NextRectSearch()) != nullptr) {
963          if (neighbor == seg) {
964            continue;
965          }
966          const TBOX &neighbor_box = neighbor->bounding_box();
967          if (neighbor_box.overlap_fraction(box) >= 0.9) {
968            seg->InsertBox(neighbor_box);
969            rectsearch.RemoveBBox();
970            gsearch.RepositionIterator();
971            delete neighbor;
972            modified = true;
973            continue;
974          }
975          if (BelongToOneTable(box, neighbor_box)) {
976            seg->InsertBox(neighbor_box);
977            neighbor_found = true;
978            modified = true;
979            rectsearch.RemoveBBox();
980            gsearch.RepositionIterator();
981            delete neighbor;
982          }
983        }
984      } while (neighbor_found);
985      if (modified) {
986        gsearch.RemoveBBox();
987        table_grid_.InsertBBox(true, true, seg);
988        gsearch.RepositionIterator();
989      }
990    }
991  }
992  bool TableFinder::BelongToOneTable(const TBOX &box1, const TBOX &box2) {
993    if (box1.overlap(box2)) {
994      return true;
995    }
996    TBOX bbox = box1.bounding_union(box2);
997    GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> rectsearch(
998        &clean_part_grid_);
999    rectsearch.StartRectSearch(bbox);
1000    ColPartition *part = nullptr;
1001    while ((part = rectsearch.NextRectSearch()) != nullptr) {
1002      const TBOX &part_box = part->bounding_box();
1003      if (part_box.overlap(box1) && part_box.overlap(box2) &&
1004          !part->IsImageType()) {
1005        return true;
1006      }
1007    }
1008    return false;
1009  }
1010  void TableFinder::AdjustTableBoundaries() {
1011    ColSegment_CLIST adjusted_tables;
1012    ColSegment_C_IT it(&adjusted_tables);
1013    ColSegmentGridSearch gsearch(&table_grid_);
1014    gsearch.StartFullSearch();
1015    ColSegment *table = nullptr;
1016    while ((table = gsearch.NextFullSearch()) != nullptr) {
1017      const TBOX &table_box = table->bounding_box();
1018      TBOX grown_box = table_box;
1019      GrowTableBox(table_box, &grown_box);
1020      if (!grown_box.null_box()) {
1021        auto *col = new ColSegment();
1022        col->InsertBox(grown_box);
1023        it.add_after_then_move(col);
1024      }
1025      gsearch.RemoveBBox();
1026      delete table;
1027    }
1028    table_grid_.Clear();
1029    it.move_to_first();
1030    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1031      ColSegment *seg = it.extract();
1032      table_grid_.InsertBBox(true, true, seg);
1033    }
1034  }
1035  void TableFinder::GrowTableBox(const TBOX &table_box, TBOX *result_box) {
1036    TBOX search_box = table_box;
1037    GrowTableToIncludePartials(table_box, search_box, result_box);
1038    GrowTableToIncludeLines(table_box, search_box, result_box);
1039    IncludeLeftOutColumnHeaders(result_box);
1040  }
1041  void TableFinder::GrowTableToIncludePartials(const TBOX &table_box,
1042                                               const TBOX &search_range,
1043                                               TBOX *result_box) {
1044    for (int i = 0; i < 2; ++i) {
1045      ColPartitionGrid *grid =
1046          (i == 0) ? &fragmented_text_grid_ : &leader_and_ruling_grid_;
1047      ColPartitionGridSearch rectsearch(grid);
1048      rectsearch.StartRectSearch(search_range);
1049      ColPartition *part = nullptr;
1050      while ((part = rectsearch.NextRectSearch()) != nullptr) {
1051        if (part->IsImageType()) {
1052          continue;
1053        }
1054        const TBOX &part_box = part->bounding_box();
1055        if (part_box.overlap_fraction(table_box) > kMinOverlapWithTable) {
1056          *result_box = result_box->bounding_union(part_box);
1057          continue;
1058        }
1059      }
1060    }
1061  }
1062  void TableFinder::GrowTableToIncludeLines(const TBOX &table_box,
1063                                            const TBOX &search_range,
1064                                            TBOX *result_box) {
1065    ColPartitionGridSearch rsearch(&leader_and_ruling_grid_);
1066    rsearch.SetUniqueMode(true);
1067    rsearch.StartRectSearch(search_range);
1068    ColPartition *part = nullptr;
1069    while ((part = rsearch.NextRectSearch()) != nullptr) {
1070      if (!part->IsLineType()) {
1071        continue;
1072      }
1073      const TBOX &part_box = part->bounding_box();
1074      if (result_box->contains(part_box)) {
1075        continue;
1076      }
1077      if (HLineBelongsToTable(*part, table_box)) {
1078        *result_box = result_box->bounding_union(part_box);
1079      }
1080    }
1081  }
1082  bool TableFinder::HLineBelongsToTable(const ColPartition &part,
1083                                        const TBOX &table_box) {
1084    if (!part.IsHorizontalLine()) {
1085      return false;
1086    }
1087    const TBOX &part_box = part.bounding_box();
1088    if (!part_box.major_x_overlap(table_box)) {
1089      return false;
1090    }
1091    const TBOX bbox = part_box.bounding_union(table_box);
1092    int num_extra_partitions = 0;
1093    int extra_space_to_right = 0;
1094    int extra_space_to_left = 0;
1095    for (int i = 0; i < 2; ++i) {
1096      ColPartitionGrid *grid =
1097          (i == 0) ? &clean_part_grid_ : &leader_and_ruling_grid_;
1098      ColPartitionGridSearch rectsearch(grid);
1099      rectsearch.SetUniqueMode(true);
1100      rectsearch.StartRectSearch(bbox);
1101      ColPartition *extra_part = nullptr;
1102      while ((extra_part = rectsearch.NextRectSearch()) != nullptr) {
1103        const TBOX &extra_part_box = extra_part->bounding_box();
1104        if (extra_part_box.overlap_fraction(table_box) > kMinOverlapWithTable) {
1105          continue;
1106        }
1107        if (extra_part->IsImageType()) {
1108          continue;
1109        }
1110        num_extra_partitions++;
1111        if (extra_part->type() == PT_TABLE || extra_part->IsLineType()) {
1112          extra_space_to_right++;
1113          extra_space_to_left++;
1114          continue;
1115        }
1116        int space_threshold = kSideSpaceMargin * part.median_height();
1117        if (extra_part->space_to_right() > space_threshold) {
1118          extra_space_to_right++;
1119        }
1120        if (extra_part->space_to_left() > space_threshold) {
1121          extra_space_to_left++;
1122        }
1123      }
1124    }
1125    return (extra_space_to_right > num_extra_partitions / 2) ||
1126           (extra_space_to_left > num_extra_partitions / 2);
1127  }
1128  void TableFinder::IncludeLeftOutColumnHeaders(TBOX *table_box) {
1129    ColPartitionGridSearch vsearch(&clean_part_grid_);
1130    vsearch.StartVerticalSearch(table_box->left(), table_box->right(),
1131                                table_box->top());
1132    ColPartition *neighbor = nullptr;
1133    ColPartition *previous_neighbor = nullptr;
1134    while ((neighbor = vsearch.NextVerticalSearch(false)) != nullptr) {
1135      const int max_distance =
1136          kMaxColumnHeaderDistance * neighbor->median_height();
1137      int table_top = table_box->top();
1138      const TBOX &box = neighbor->bounding_box();
1139      if (box.bottom() - table_top > max_distance) {
1140        break;
1141      }
1142      if (neighbor->type() == PT_TABLE || neighbor->IsLineType()) {
1143        table_box->set_top(box.top());
1144        previous_neighbor = nullptr;
1145        continue;
1146      }
1147      if (previous_neighbor == nullptr) {
1148        previous_neighbor = neighbor;
1149      } else {
1150        const TBOX &previous_box = previous_neighbor->bounding_box();
1151        if (!box.major_y_overlap(previous_box)) {
1152          break;
1153        }
1154      }
1155    }
1156  }
1157  void TableFinder::DeleteSingleColumnTables() {
1158    int page_width = tright().x() - bleft().x();
1159    ASSERT_HOST(page_width > 0);
1160    int *table_xprojection = new int[page_width];
1161    GridSearch<ColSegment, ColSegment_CLIST, ColSegment_C_IT> table_search(
1162        &table_grid_);
1163    table_search.StartFullSearch();
1164    ColSegment *table;
1165    while ((table = table_search.NextFullSearch()) != nullptr) {
1166      TBOX table_box = table->bounding_box();
1167      for (int i = 0; i < page_width; i++) {
1168        table_xprojection[i] = 0;
1169      }
1170      GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> rectsearch(
1171          &clean_part_grid_);
1172      rectsearch.SetUniqueMode(true);
1173      rectsearch.StartRectSearch(table_box);
1174      ColPartition *part;
1175      while ((part = rectsearch.NextRectSearch()) != nullptr) {
1176        if (!part->IsTextType()) {
1177          continue; 
1178        }
1179        if (part->flow() == BTFT_LEADER) {
1180          continue; 
1181        }
1182        TBOX part_box = part->bounding_box();
1183        if (part_box.overlap_fraction(table_box) < kMinOverlapWithTable) {
1184          continue;
1185        }
1186        BLOBNBOX_CLIST *part_boxes = part->boxes();
1187        BLOBNBOX_C_IT pit(part_boxes);
1188        int next_position_to_write = 0;
1189        for (pit.mark_cycle_pt(); !pit.cycled_list(); pit.forward()) {
1190          BLOBNBOX *pblob = pit.data();
1191          int xstart = pblob->bounding_box().left();
1192          int xend = pblob->bounding_box().right();
1193          xstart = std::max(xstart, next_position_to_write);
1194          for (int i = xstart; i < xend; i++) {
1195            table_xprojection[i - bleft().x()]++;
1196          }
1197          next_position_to_write = xend;
1198        }
1199      }
1200      if (!GapInXProjection(table_xprojection, page_width)) {
1201        table_search.RemoveBBox();
1202        delete table;
1203      }
1204    }
1205    delete[] table_xprojection;
1206  }
1207  bool TableFinder::GapInXProjection(int *xprojection, int length) {
1208    int peak_value = 0;
1209    for (int i = 0; i < length; i++) {
1210      if (xprojection[i] > peak_value) {
1211        peak_value = xprojection[i];
1212      }
1213    }
1214    if (peak_value < kMinRowsInTable) {
1215      return false;
1216    }
1217    double projection_threshold = kSmallTableProjectionThreshold * peak_value;
1218    if (peak_value >= kLargeTableRowCount) {
1219      projection_threshold = kLargeTableProjectionThreshold * peak_value;
1220    }
1221    for (int i = 0; i < length; i++) {
1222      xprojection[i] = (xprojection[i] >= projection_threshold) ? 1 : 0;
1223    }
1224    int largest_gap = 0;
1225    int run_start = -1;
1226    for (int i = 1; i < length; i++) {
1227      if (xprojection[i - 1] && !xprojection[i]) {
1228        run_start = i;
1229      }
1230      if (run_start != -1 && !xprojection[i - 1] && xprojection[i]) {
1231        int gap = i - run_start;
1232        if (gap > largest_gap) {
1233          largest_gap = gap;
1234        }
1235        run_start = -1;
1236      }
1237    }
1238    return largest_gap > kMaxXProjectionGapFactor * global_median_xheight_;
1239  }
1240  void TableFinder::RecognizeTables() {
1241  #ifndef GRAPHICS_DISABLED
1242    ScrollView *table_win = nullptr;
1243    if (textord_show_tables) {
1244      table_win = MakeWindow(0, 0, "Table Structure");
1245      DisplayColPartitions(table_win, &fragmented_text_grid_, ScrollView::BLUE,
1246                           ScrollView::LIGHT_BLUE);
1247    }
1248  #endif
1249    TableRecognizer recognizer;
1250    recognizer.Init();
1251    recognizer.set_line_grid(&leader_and_ruling_grid_);
1252    recognizer.set_text_grid(&fragmented_text_grid_);
1253    recognizer.set_max_text_height(global_median_xheight_ * 2.0);
1254    recognizer.set_min_height(1.5 * gridheight());
1255    ColSegment_CLIST good_tables;
1256    ColSegment_C_IT good_it(&good_tables);
1257    ColSegmentGridSearch gsearch(&table_grid_);
1258    gsearch.StartFullSearch();
1259    ColSegment *found_table = nullptr;
1260    while ((found_table = gsearch.NextFullSearch()) != nullptr) {
1261      gsearch.RemoveBBox();
1262      const TBOX &found_box = found_table->bounding_box();
1263      StructuredTable *table_structure = recognizer.RecognizeTable(found_box);
1264      if (table_structure != nullptr) {
1265  #ifndef GRAPHICS_DISABLED
1266        if (textord_show_tables) {
1267          table_structure->Display(table_win, ScrollView::LIME_GREEN);
1268        }
1269  #endif
1270        found_table->set_bounding_box(table_structure->bounding_box());
1271        delete table_structure;
1272        good_it.add_after_then_move(found_table);
1273      } else {
1274        delete found_table;
1275      }
1276    }
1277    for (good_it.mark_cycle_pt(); !good_it.cycled_list(); good_it.forward()) {
1278      table_grid_.InsertBBox(true, true, good_it.extract());
1279    }
1280  }
1281  #ifndef GRAPHICS_DISABLED
1282  void TableFinder::DisplayColSegments(ScrollView *win, ColSegment_LIST *segments,
1283                                       ScrollView::Color color) {
1284    win->Pen(color);
1285    win->Brush(ScrollView::NONE);
1286    ColSegment_IT it(segments);
1287    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1288      ColSegment *col = it.data();
1289      const TBOX &box = col->bounding_box();
1290      int left_x = box.left();
1291      int right_x = box.right();
1292      int top_y = box.top();
1293      int bottom_y = box.bottom();
1294      win->Rectangle(left_x, bottom_y, right_x, top_y);
1295    }
1296    win->UpdateWindow();
1297  }
1298  void TableFinder::DisplayColPartitions(ScrollView *win, ColPartitionGrid *grid,
1299                                         ScrollView::Color default_color,
1300                                         ScrollView::Color table_color) {
1301    ScrollView::Color color = default_color;
1302    GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> gsearch(grid);
1303    gsearch.StartFullSearch();
1304    ColPartition *part = nullptr;
1305    while ((part = gsearch.NextFullSearch()) != nullptr) {
1306      color = default_color;
1307      if (part->type() == PT_TABLE) {
1308        color = table_color;
1309      }
1310      const TBOX &box = part->bounding_box();
1311      int left_x = box.left();
1312      int right_x = box.right();
1313      int top_y = box.top();
1314      int bottom_y = box.bottom();
1315      win->Brush(ScrollView::NONE);
1316      win->Pen(color);
1317      win->Rectangle(left_x, bottom_y, right_x, top_y);
1318    }
1319    win->UpdateWindow();
1320  }
1321  void TableFinder::DisplayColPartitions(ScrollView *win, ColPartitionGrid *grid,
1322                                         ScrollView::Color default_color) {
1323    DisplayColPartitions(win, grid, default_color, ScrollView::YELLOW);
1324  }
1325  void TableFinder::DisplayColPartitionConnections(ScrollView *win,
1326                                                   ColPartitionGrid *grid,
1327                                                   ScrollView::Color color) {
1328    GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> gsearch(grid);
1329    gsearch.StartFullSearch();
1330    ColPartition *part = nullptr;
1331    while ((part = gsearch.NextFullSearch()) != nullptr) {
1332      const TBOX &box = part->bounding_box();
1333      int left_x = box.left();
1334      int right_x = box.right();
1335      int top_y = box.top();
1336      int bottom_y = box.bottom();
1337      ColPartition *upper_part = part->nearest_neighbor_above();
1338      if (upper_part) {
1339        const TBOX &upper_box = upper_part->bounding_box();
1340        int mid_x = (left_x + right_x) / 2;
1341        int mid_y = (top_y + bottom_y) / 2;
1342        int other_x = (upper_box.left() + upper_box.right()) / 2;
1343        int other_y = (upper_box.top() + upper_box.bottom()) / 2;
1344        win->Brush(ScrollView::NONE);
1345        win->Pen(color);
1346        win->Line(mid_x, mid_y, other_x, other_y);
1347      }
1348      ColPartition *lower_part = part->nearest_neighbor_below();
1349      if (lower_part) {
1350        const TBOX &lower_box = lower_part->bounding_box();
1351        int mid_x = (left_x + right_x) / 2;
1352        int mid_y = (top_y + bottom_y) / 2;
1353        int other_x = (lower_box.left() + lower_box.right()) / 2;
1354        int other_y = (lower_box.top() + lower_box.bottom()) / 2;
1355        win->Brush(ScrollView::NONE);
1356        win->Pen(color);
1357        win->Line(mid_x, mid_y, other_x, other_y);
1358      }
1359    }
1360    win->UpdateWindow();
1361  }
1362  #endif
1363  void TableFinder::MakeTableBlocks(ColPartitionGrid *grid,
1364                                    ColPartitionSet **all_columns,
1365                                    const WidthCallback &width_cb) {
1366    GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> gsearch(grid);
1367    gsearch.StartFullSearch();
1368    ColPartition *part = nullptr;
1369    while ((part = gsearch.NextFullSearch()) != nullptr) {
1370      if (part->type() == PT_TABLE) {
1371        part->clear_table_type();
1372      }
1373    }
1374    GridSearch<ColSegment, ColSegment_CLIST, ColSegment_C_IT> table_search(
1375        &table_grid_);
1376    table_search.StartFullSearch();
1377    ColSegment *table;
1378    while ((table = table_search.NextFullSearch()) != nullptr) {
1379      const TBOX &table_box = table->bounding_box();
1380      GridSearch<ColPartition, ColPartition_CLIST, ColPartition_C_IT> rectsearch(
1381          grid);
1382      rectsearch.StartRectSearch(table_box);
1383      ColPartition *part;
1384      ColPartition *table_partition = nullptr;
1385      while ((part = rectsearch.NextRectSearch()) != nullptr) {
1386        if (!part->IsTextType()) {
1387          continue;
1388        }
1389        TBOX part_box = part->bounding_box();
1390        if (part_box.overlap_fraction(table_box) > kMinOverlapWithTable) {
1391          rectsearch.RemoveBBox();
1392          if (table_partition) {
1393            table_partition->Absorb(part, width_cb);
1394          } else {
1395            table_partition = part;
1396          }
1397        }
1398      }
1399      if (table_partition) {
1400        const TBOX &table_box = table_partition->bounding_box();
1401        int grid_x, grid_y;
1402        grid->GridCoords(table_box.left(), table_box.bottom(), &grid_x, &grid_y);
1403        table_partition->SetPartitionType(resolution_, all_columns[grid_y]);
1404        table_partition->set_table_type();
1405        table_partition->set_blob_type(BRT_TEXT);
1406        table_partition->set_flow(BTFT_CHAIN);
1407        table_partition->SetBlobTypes();
1408        grid->InsertBBox(true, true, table_partition);
1409      }
1410    }
1411  }
1412  ColSegment::ColSegment()
1413      : ELIST_LINK(),
1414        num_table_cells_(0),
1415        num_text_cells_(0),
1416        type_(COL_UNKNOWN) {}
1417  ScrollView::Color ColSegment::BoxColor() const {
1418    const ScrollView::Color kBoxColors[PT_COUNT] = {
1419        ScrollView::YELLOW,
1420        ScrollView::BLUE,
1421        ScrollView::YELLOW,
1422        ScrollView::MAGENTA,
1423    };
1424    return kBoxColors[type_];
1425  }
1426  void ColSegment::InsertBox(const TBOX &other) {
1427    bounding_box_ = bounding_box_.bounding_union(other);
1428  }
1429  void ColSegment::set_type() {
1430    if (num_table_cells_ > kTableColumnThreshold * num_text_cells_) {
1431      type_ = COL_TABLE;
<span onclick='openModal()' class='match'>1432    } else if (num_text_cells_ > num_table_cells_) {
1433      type_ = COL_TEXT;
1434    } else {
1435      type_ = COL_MIXED;
1436    }
</span>1437  }
1438  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-cjkpitch.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-tablefind.cpp</div>
                </div>
                <div class="column column_space"><pre><code>375    } else if (good_pitches_.size() > all_pitches_.size() * 0.75) {
376      real_row_->pitch_decision = PITCH_DEF_FIXED;
377    } else {
378      real_row_->pitch_decision = PITCH_CORR_FIXED;
379    }
</pre></code></div>
                <div class="column column_space"><pre><code>1432    } else if (num_text_cells_ > num_table_cells_) {
1433      type_ = COL_TEXT;
1434    } else {
1435      type_ = COL_MIXED;
1436    }
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    