
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 38, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-zipfl.cpp</h3>
            <pre><code>1  #if defined(GLib_WIN)
2    TStr TZipIn::SevenZipPath = "C:\\7Zip";
3  #elif defined(GLib_CYGWIN)
4    TStr TZipIn::SevenZipPath = "/usr/bin";
5  #elif defined(GLib_MACOSX) 
6    TStr TZipIn::SevenZipPath = "/usr/local/bin";
7  #else 
8    TStr TZipIn::SevenZipPath = "/usr/bin";
9  #endif
10  TStrStrH TZipIn::FExtToCmdH;
11  const int TZipIn::MxBfL=32*1024;
12  void TZipIn::CreateZipProcess(const TStr& Cmd, const TStr& ZipFNm) {
13    const TStr CmdLine = TStr::Fmt("%s %s", Cmd.CStr(), ZipFNm.CStr());
14    #ifdef GLib_WIN
15    PROCESS_INFORMATION piProcInfo;
16    STARTUPINFO siStartInfo;
17    ZeroMemory( &piProcInfo, sizeof(PROCESS_INFORMATION));
18    ZeroMemory( &siStartInfo, sizeof(STARTUPINFO));
19    siStartInfo.cb = sizeof(STARTUPINFO);
20    siStartInfo.hStdOutput = ZipStdoutWr;
21    siStartInfo.dwFlags |= STARTF_USESTDHANDLES;
22    const BOOL FuncRetn = CreateProcess(NULL,
23      (LPSTR) CmdLine.CStr(),  
24      NULL,          
25      NULL,          
26      TRUE,          
27      0,             
28      NULL,          
29      NULL,          
30      &siStartInfo,  
31      &piProcInfo);  
32    EAssertR(FuncRetn!=0, TStr::Fmt("Can not execute '%s' (Set the TZipIn::SevenZipPath)", CmdLine.CStr()).CStr());
33    CloseHandle(piProcInfo.hProcess);
34    CloseHandle(piProcInfo.hThread);
35    #else
36    ZipStdoutRd = popen((TZipIn::SevenZipPath+"/"+CmdLine).CStr(), "r");
37    EAssertR(ZipStdoutRd,  TStr::Fmt("Can not execute '%s' (Set the TZipIn::SevenZipPath)", CmdLine.CStr()).CStr());
38    #endif
39  }
40  void TZipIn::FillBf(){
41    EAssertR(CurFPos < FLen, TStr::Fmt("End of file '%s' reached (CurFPos=%s, FLen=%s).", GetSNm().CStr(), TUInt64(CurFPos).GetStr().CStr(), TUInt64(FLen).GetStr().CStr()));
42    EAssertR((BfC==BfL)&bsol;*&&((BfL==-1)||(BfL==MxBfL))*/, "Error reading file '"+GetSNm()+"' (Set the TZipIn::SevenZipPath).");
43    #ifdef GLib_WIN
44    DWORD BytesRead;
45    EAssert(ReadFile(ZipStdoutRd, Bf, MxBfL, &BytesRead, NULL) != 0);
46    #else
47    size_t BytesRead = fread(Bf, 1, MxBfL, ZipStdoutRd);
48    EAssert(BytesRead != 0);
49    #endif
50    BfL = (int) BytesRead;
51    CurFPos += BytesRead;
52    EAssertR((BfC!=0)||(BfL!=0), "Error reading file '"+GetSNm()+"' (Set the TZipIn::SevenZipPath).");
53    BfC = 0;
54  }
55  TZipIn::TZipIn(const TStr& FNm) : TSBase(FNm.CStr()), TSIn(FNm), ZipStdoutRd(NULL), ZipStdoutWr(NULL),
56    FLen(0), CurFPos(0), Bf(NULL), BfC(0), BfL(0) {
57    EAssertR(! FNm.Empty(), "Empty file-name.");
58    EAssertR(TFile::Exists(FNm), TStr::Fmt("File %s does not exist", FNm.CStr()).CStr());
59    FLen = 0;
60    if (! IsZipFNm(FNm)) {
61      printf("*** Error: file %s, compression format %s not supported\n", FNm.CStr(), FNm.GetFExt().CStr());
62      EFailR(TStr::Fmt("File %s: compression format %s not supported", FNm.CStr(), FNm.GetFExt().CStr()).CStr());
63    }
64    FLen = TZipIn::GetFLen(FNm);
65    if (FLen == 0) { return; } 
66    #ifdef GLib_WIN
67    SECURITY_ATTRIBUTES saAttr;
68    saAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
69    saAttr.bInheritHandle = TRUE;
70    saAttr.lpSecurityDescriptor = NULL;
71    const int PipeBufferSz = 32*1024;
72    EAssertR(CreatePipe(&ZipStdoutRd, &ZipStdoutWr, &saAttr, PipeBufferSz), "Stdout pipe creation failed");
73    SetHandleInformation(ZipStdoutRd, HANDLE_FLAG_INHERIT, 0);
74    #else
75    #endif
76    CreateZipProcess(GetCmd(FNm), FNm);
77    Bf = new char[MxBfL]; BfC = BfL=-1;
78    FillBf();
79  }
80  TZipIn::TZipIn(const TStr& FNm, bool& OpenedP) : TSBase(FNm.CStr()), TSIn(FNm), ZipStdoutRd(NULL), ZipStdoutWr(NULL),
81    FLen(0), CurFPos(0), Bf(NULL), BfC(0), BfL(0) {
82    EAssertR(! FNm.Empty(), "Empty file-name.");
83    FLen = TZipIn::GetFLen(FNm);
84    OpenedP = TFile::Exists(FNm);
85    if (OpenedP) {
86      #ifdef GLib_WIN
87      SECURITY_ATTRIBUTES saAttr;
88      saAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
89      saAttr.bInheritHandle = TRUE;
90      saAttr.lpSecurityDescriptor = NULL;
91      EAssertR(CreatePipe(&ZipStdoutRd, &ZipStdoutWr, &saAttr, 0), "Stdout pipe creation failed");
92      SetHandleInformation(ZipStdoutRd, HANDLE_FLAG_INHERIT, 0);
93      #else
94      #endif
95      CreateZipProcess(GetCmd(FNm.GetFExt()), FNm);
96      Bf = new char[MxBfL]; BfC = BfL=-1;
97      FillBf();
98    }
99  }
100  PSIn TZipIn::New(const TStr& FNm) {
101    return PSIn(new TZipIn(FNm));
102  }
103  PSIn TZipIn::New(const TStr& FNm, bool& OpenedP){
104    return PSIn(new TZipIn(FNm, OpenedP));
105  }
106  TZipIn::~TZipIn(){
107    #ifdef GLib_WIN
108    if (ZipStdoutRd != NULL) {
109      EAssertR(CloseHandle(ZipStdoutRd), "Closing read-end of pipe failed"); }
110    if (ZipStdoutWr != NULL) {
111      EAssertR(CloseHandle(ZipStdoutWr)!=0, "Closing write-end of pipe failed"); }
112    #else
113    if (ZipStdoutRd != NULL) {
114      EAssertR(pclose(ZipStdoutRd) != -1, "Closing of the process failed"); }
115    #endif
116    if (Bf != NULL) { delete[] Bf; }
117  }
118  int TZipIn::GetBf(const void* LBf, const TSize& LBfL){
119    int LBfS=0;
120    if (TSize(BfC+LBfL)>TSize(BfL)){
121      for (TSize LBfC=0; LBfC<LBfL; LBfC++){
122        if (BfC==BfL){FillBf();}
123        LBfS+=((char*)LBf)[LBfC]=Bf[BfC++];}
124    } else {
125      for (TSize LBfC=0; LBfC<LBfL; LBfC++){
126        LBfS+=(((char*)LBf)[LBfC]=Bf[BfC++]);}
127    }
128    return LBfS;
129  }
130  bool TZipIn::GetNextLnBf(TChA& LnChA) {
131    int Status;
132    int BfN;        
133    int BfP;        
134    LnChA.Clr();
135    do {
136      if (BfC >= BfL) { BfP = 0; } 
137      else { BfP = BfC; }
138      Status = FindEol(BfN);
139      if (Status >= 0) {
140        LnChA.AddBf(&Bf[BfP],BfN-BfP);
141        if (Status == 1) { return true; } 
142      }
143    } while (Status == 0);
144    return !LnChA.Empty();
145  }
146  int TZipIn::FindEol(int& BfN) {
147    char Ch;
148    if (BfC >= BfL) { 
149      if (Eof()) { return -1; }
150      FillBf();
151    }
152    while (BfC < BfL) {
153      Ch = Bf[BfC++];
154      if (Ch=='\n') { BfN = BfC-1; return 1; }
155      if (Ch=='\r' && Bf[BfC+1]=='\n') {
156        BfC++;  BfN = BfC-2;  return 1; }
157    }
158    BfN = BfC;
159    return 0;
160  }
161  bool TZipIn::IsZipExt(const TStr& FNmExt) {
162    if (FExtToCmdH.Empty()) FillFExtToCmdH();
163    return FExtToCmdH.IsKey(FNmExt);
164  }
165  void TZipIn::FillFExtToCmdH() {
166    #ifdef GLib_WIN
167    const char* ZipCmd = "7z.exe e -y -bd -so";
168    #else
169    const char* ZipCmd = "7za e -y -bd -so";
170    #endif
171    if (FExtToCmdH.Empty()) {
172      FExtToCmdH.AddDat(".gz",  ZipCmd);
173      FExtToCmdH.AddDat(".7z",  ZipCmd);
174      FExtToCmdH.AddDat(".rar", ZipCmd);
175      FExtToCmdH.AddDat(".zip", ZipCmd);
176      FExtToCmdH.AddDat(".cab", ZipCmd);
177      FExtToCmdH.AddDat(".arj", ZipCmd);
178      FExtToCmdH.AddDat(".bzip2", ZipCmd);
179      FExtToCmdH.AddDat(".bz2", ZipCmd);
180    }
181  }
182  TStr TZipIn::GetCmd(const TStr& ZipFNm) {
183    if (FExtToCmdH.Empty()) FillFExtToCmdH();
184    const TStr Ext = ZipFNm.GetFExt().GetLc();
185    EAssertR(FExtToCmdH.IsKey(Ext), TStr::Fmt("Unsupported file extension '%s'", Ext.CStr()));
186    return FExtToCmdH.GetDat(Ext);
187  }
188  uint64 TZipIn::GetFLen(const TStr& ZipFNm) {
189    #ifdef GLib_WIN
190    HANDLE ZipStdoutRd, ZipStdoutWr;
191    SECURITY_ATTRIBUTES saAttr;
192    saAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
193    saAttr.bInheritHandle = TRUE;
194    saAttr.lpSecurityDescriptor = NULL;
195    const int PipeBufferSz = 32*1024;
196    EAssertR(CreatePipe(&ZipStdoutRd, &ZipStdoutWr, &saAttr, PipeBufferSz), "Stdout pipe creation failed");
197    SetHandleInformation(ZipStdoutRd, HANDLE_FLAG_INHERIT, 0);
198    { const TStr CmdLine = TStr::Fmt("7z.exe l %s", ZipFNm.CStr());
199    PROCESS_INFORMATION piProcInfo;
200    STARTUPINFO siStartInfo;
201    ZeroMemory( &piProcInfo, sizeof(PROCESS_INFORMATION));
202    ZeroMemory( &siStartInfo, sizeof(STARTUPINFO));
203    siStartInfo.cb = sizeof(STARTUPINFO);
204    siStartInfo.hStdOutput = ZipStdoutWr;
205    siStartInfo.dwFlags |= STARTF_USESTDHANDLES;
206    const BOOL FuncRetn = CreateProcess(NULL, (LPSTR) CmdLine.CStr(),
207      NULL, NULL, TRUE, 0, NULL, NULL, &siStartInfo, &piProcInfo);
<span onclick='openModal()' class='match'>208    EAssertR(FuncRetn!=0, TStr::Fmt("Can not execute '%s' (Set the TZipIn::SevenZipPath)", CmdLine.CStr()).CStr());
209    CloseHandle(piProcInfo.hProcess);
210    CloseHandle(piProcInfo.hThread); }
</span>211    #else
212    const TStr CmdLine = TStr::Fmt("7za l %s", ZipFNm.CStr());
213    FILE* ZipStdoutRd = popen((TZipIn::SevenZipPath+"/"+CmdLine).CStr(), "r");
214    EAssertR(ZipStdoutRd, TStr::Fmt("Can not execute '%s/%s' (Set the TZipIn::SevenZipPath)", TZipIn::SevenZipPath.CStr(), CmdLine.CStr()).CStr());
215    #endif
216    const int BfSz = 32*1024;
217    char* Bf = new char [BfSz];
218    int BfC=0, BfL=0;
219    memset(Bf, 0, BfSz);
220    #ifdef GLib_WIN
221    DWORD BytesRead;
222    EAssert(ReadFile(ZipStdoutRd, Bf, MxBfL, &BytesRead, NULL) != 0);
223    #else
224    size_t BytesRead = fread(Bf, 1, MxBfL, ZipStdoutRd);
225    EAssert(BytesRead != 0);
226    EAssert(pclose(ZipStdoutRd) != -1);
227    #endif
228    BfL = (int) BytesRead;  IAssert((BfC!=0)||(BfL!=0));
229    BfC = 0; Bf[BfL] = 0;
230    TStr Str(Bf);  delete [] Bf;
231    TStrV StrV; Str.SplitOnWs(StrV);
232    int n = StrV.Len()-1;
233    while (n > 0 && ! StrV[n].IsPrefix("-----")) { n--; }
234    if (n-7 <= 0) {
235      WrNotify(TStr::Fmt("Corrupt file %s: MESSAGE:\n", ZipFNm.CStr()).CStr(), Str.CStr());
236      SaveToErrLog(TStr::Fmt("Corrupt file %s. Message:\n:%s\n", ZipFNm.CStr(), Str.CStr()).CStr());
237      return 0;
238    }
239    return StrV[n-7].GetInt64();
240  }
241  TStrStrH TZipOut::FExtToCmdH;
242  const TSize TZipOut::MxBfL=4*1024;
243  void TZipOut::FlushBf() {
244    #ifdef GLib_WIN
245    DWORD BytesOut;
246    EAssertR(WriteFile(ZipStdinWr, Bf, DWORD(BfL), &BytesOut, NULL)!=0, "Error writting to the file '"+GetSNm()+"'.");
247    #else
248    size_t BytesOut = fwrite(Bf, 1, BfL, ZipStdinWr);
249    #endif
250    EAssert(BytesOut == BfL);
251    BfL = 0;
252  }
253  void TZipOut::CreateZipProcess(const TStr& Cmd, const TStr& ZipFNm) {
254    const TStr CmdLine = TStr::Fmt("%s %s", Cmd.CStr(), ZipFNm.CStr());
255    #ifdef GLib_WIN
256    PROCESS_INFORMATION piProcInfo;
257    STARTUPINFO siStartInfo;
258    ZeroMemory( &piProcInfo, sizeof(PROCESS_INFORMATION));
259    ZeroMemory( &siStartInfo, sizeof(STARTUPINFO));
260    siStartInfo.cb = sizeof(STARTUPINFO);
261    siStartInfo.hStdInput = ZipStdinRd;
262    siStartInfo.dwFlags |= STARTF_USESTDHANDLES;
263    const BOOL FuncRetn = CreateProcess(NULL,
264      (LPSTR) CmdLine.CStr(),  
265      NULL,          
266      NULL,          
267      TRUE,          
268      0,             
269      NULL,          
270      NULL,          
271      &siStartInfo,  
272      &piProcInfo);  
273    EAssertR(FuncRetn!=0, TStr::Fmt("Can not execute '%s' (Set the TZipIn::SevenZipPath)", CmdLine.CStr()).CStr());
274    CloseHandle(piProcInfo.hProcess);
275    CloseHandle(piProcInfo.hThread);
276    #else
277    ZipStdinWr = popen((TZipIn::SevenZipPath+"/"+CmdLine).CStr(), "r");
278    EAssertR(ZipStdinWr,  TStr::Fmt("Can not execute '%s' (Set the TZipIn::SevenZipPath)", CmdLine.CStr()).CStr());
279    #endif
280  }
281  TZipOut::TZipOut(const TStr& FNm) : TSBase(FNm.CStr()), TSOut(FNm), ZipStdinRd(NULL), ZipStdinWr(NULL), Bf(NULL), BfL(0){
282    EAssertR(! FNm.Empty(), "Empty file-name.");
283    #ifdef GLib_WIN
284    SECURITY_ATTRIBUTES saAttr;
285    saAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
286    saAttr.bInheritHandle = TRUE;
287    saAttr.lpSecurityDescriptor = NULL;
288    EAssertR(CreatePipe(&ZipStdinRd, &ZipStdinWr, &saAttr, 0), "Stdout pipe creation failed");
289    SetHandleInformation(ZipStdinWr, HANDLE_FLAG_INHERIT, 0);
290    #else
291    #endif
292    CreateZipProcess(GetCmd(FNm), FNm);
293    Bf=new char[MxBfL];  BfL=0;
294  }
295  PSOut TZipOut::New(const TStr& FNm){
296    return PSOut(new TZipOut(FNm));
297  }
298  TZipOut::~TZipOut() {
299    if (BfL!=0) { FlushBf(); }
300    #ifdef GLib_WIN
301    if (ZipStdinWr != NULL) { EAssertR(CloseHandle(ZipStdinWr), "Closing write-end of pipe failed"); }
302    if (ZipStdinRd != NULL) { EAssertR(CloseHandle(ZipStdinRd), "Closing read-end of pipe failed"); }
303    #else
304    if (ZipStdinWr != NULL) { EAssertR(pclose(ZipStdinWr) != -1, "Closing of the process failed"); }
305    #endif
306    if (Bf!=NULL) { delete[] Bf; }
307  }
308  int TZipOut::PutCh(const char& Ch){
309    if (BfL==MxBfL) {FlushBf();}
310    return Bf[BfL++]=Ch;
311  }
312  int TZipOut::PutBf(const void* LBf, const TSize& LBfL){
313    int LBfS=0;
314    if (BfL+LBfL>MxBfL){
315      for (TSize LBfC=0; LBfC<LBfL; LBfC++){
316        LBfS+=PutCh(((char*)LBf)[LBfC]);}
317    } else {
318      for (TSize LBfC=0; LBfC<LBfL; LBfC++){
319        LBfS+=(Bf[BfL++]=((char*)LBf)[LBfC]);}
320    }
321    return LBfS;
322  }
323  void TZipOut::Flush(){
324    FlushBf();
325    #ifdef GLib_WIN
326    EAssertR(FlushFileBuffers(ZipStdinWr)!=0, "Can not flush file '"+GetSNm()+"'.");
327    #else
328    EAssertR(fflush(ZipStdinWr)==0, "Can not flush file '"+GetSNm()+"'.");
329    #endif
330  }
331  bool TZipOut::IsZipExt(const TStr& FNmExt) {
332    if (FExtToCmdH.Empty()) FillFExtToCmdH();
333    return FExtToCmdH.IsKey(FNmExt);
334  }
335  void TZipOut::FillFExtToCmdH() {
336    #ifdef GLib_WIN
337    const char* ZipCmd = "7z.exe a -y -bd -si";
338    #else
339    const char* ZipCmd = "7za a -y -bd -si";
340    #endif
341    if (FExtToCmdH.Empty()) {
342      FExtToCmdH.AddDat(".gz",  ZipCmd);
343      FExtToCmdH.AddDat(".7z",  ZipCmd);
344      FExtToCmdH.AddDat(".rar", ZipCmd);
345      FExtToCmdH.AddDat(".zip", ZipCmd);
346      FExtToCmdH.AddDat(".cab", ZipCmd);
347      FExtToCmdH.AddDat(".arj", ZipCmd);
348      FExtToCmdH.AddDat(".bzip2", ZipCmd);
349      FExtToCmdH.AddDat(".bz2", ZipCmd);
350    }
351  }
352  TStr TZipOut::GetCmd(const TStr& ZipFNm) {
353    if (FExtToCmdH.Empty()) FillFExtToCmdH();
354    const TStr Ext = ZipFNm.GetFExt().GetLc();
355    EAssertR(FExtToCmdH.IsKey(Ext), TStr::Fmt("Unsupported file extension '%s'", Ext.CStr()));
356    return FExtToCmdH.GetDat(Ext)+ZipFNm.GetFMid();
357  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-zipfl.cpp</h3>
            <pre><code>1  #if defined(GLib_WIN)
2    TStr TZipIn::SevenZipPath = "C:\\7Zip";
3  #elif defined(GLib_CYGWIN)
4    TStr TZipIn::SevenZipPath = "/usr/bin";
5  #elif defined(GLib_MACOSX) 
6    TStr TZipIn::SevenZipPath = "/usr/local/bin";
7  #else 
8    TStr TZipIn::SevenZipPath = "/usr/bin";
9  #endif
10  TStrStrH TZipIn::FExtToCmdH;
11  const int TZipIn::MxBfL=32*1024;
12  void TZipIn::CreateZipProcess(const TStr& Cmd, const TStr& ZipFNm) {
13    const TStr CmdLine = TStr::Fmt("%s %s", Cmd.CStr(), ZipFNm.CStr());
14    #ifdef GLib_WIN
15    PROCESS_INFORMATION piProcInfo;
16    STARTUPINFO siStartInfo;
17    ZeroMemory( &piProcInfo, sizeof(PROCESS_INFORMATION));
18    ZeroMemory( &siStartInfo, sizeof(STARTUPINFO));
19    siStartInfo.cb = sizeof(STARTUPINFO);
20    siStartInfo.hStdOutput = ZipStdoutWr;
21    siStartInfo.dwFlags |= STARTF_USESTDHANDLES;
22    const BOOL FuncRetn = CreateProcess(NULL,
23      (LPSTR) CmdLine.CStr(),  
24      NULL,          
25      NULL,          
26      TRUE,          
27      0,             
28      NULL,          
29      NULL,          
30      &siStartInfo,  
31      &piProcInfo);  
32    EAssertR(FuncRetn!=0, TStr::Fmt("Can not execute '%s' (Set the TZipIn::SevenZipPath)", CmdLine.CStr()).CStr());
33    CloseHandle(piProcInfo.hProcess);
34    CloseHandle(piProcInfo.hThread);
35    #else
36    ZipStdoutRd = popen((TZipIn::SevenZipPath+"/"+CmdLine).CStr(), "r");
37    EAssertR(ZipStdoutRd,  TStr::Fmt("Can not execute '%s' (Set the TZipIn::SevenZipPath)", CmdLine.CStr()).CStr());
38    #endif
39  }
40  void TZipIn::FillBf(){
41    EAssertR(CurFPos < FLen, TStr::Fmt("End of file '%s' reached (CurFPos=%s, FLen=%s).", GetSNm().CStr(), TUInt64(CurFPos).GetStr().CStr(), TUInt64(FLen).GetStr().CStr()));
42    EAssertR((BfC==BfL)&bsol;*&&((BfL==-1)||(BfL==MxBfL))*/, "Error reading file '"+GetSNm()+"' (Set the TZipIn::SevenZipPath).");
43    #ifdef GLib_WIN
44    DWORD BytesRead;
45    EAssert(ReadFile(ZipStdoutRd, Bf, MxBfL, &BytesRead, NULL) != 0);
46    #else
47    size_t BytesRead = fread(Bf, 1, MxBfL, ZipStdoutRd);
48    EAssert(BytesRead != 0);
49    #endif
50    BfL = (int) BytesRead;
51    CurFPos += BytesRead;
52    EAssertR((BfC!=0)||(BfL!=0), "Error reading file '"+GetSNm()+"' (Set the TZipIn::SevenZipPath).");
53    BfC = 0;
54  }
55  TZipIn::TZipIn(const TStr& FNm) : TSBase(FNm.CStr()), TSIn(FNm), ZipStdoutRd(NULL), ZipStdoutWr(NULL),
56    FLen(0), CurFPos(0), Bf(NULL), BfC(0), BfL(0) {
57    EAssertR(! FNm.Empty(), "Empty file-name.");
58    EAssertR(TFile::Exists(FNm), TStr::Fmt("File %s does not exist", FNm.CStr()).CStr());
59    FLen = 0;
60    if (! IsZipFNm(FNm)) {
61      printf("*** Error: file %s, compression format %s not supported\n", FNm.CStr(), FNm.GetFExt().CStr());
62      EFailR(TStr::Fmt("File %s: compression format %s not supported", FNm.CStr(), FNm.GetFExt().CStr()).CStr());
63    }
64    FLen = TZipIn::GetFLen(FNm);
65    if (FLen == 0) { return; } 
66    #ifdef GLib_WIN
67    SECURITY_ATTRIBUTES saAttr;
68    saAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
69    saAttr.bInheritHandle = TRUE;
70    saAttr.lpSecurityDescriptor = NULL;
71    const int PipeBufferSz = 32*1024;
72    EAssertR(CreatePipe(&ZipStdoutRd, &ZipStdoutWr, &saAttr, PipeBufferSz), "Stdout pipe creation failed");
73    SetHandleInformation(ZipStdoutRd, HANDLE_FLAG_INHERIT, 0);
74    #else
75    #endif
76    CreateZipProcess(GetCmd(FNm), FNm);
77    Bf = new char[MxBfL]; BfC = BfL=-1;
78    FillBf();
79  }
80  TZipIn::TZipIn(const TStr& FNm, bool& OpenedP) : TSBase(FNm.CStr()), TSIn(FNm), ZipStdoutRd(NULL), ZipStdoutWr(NULL),
81    FLen(0), CurFPos(0), Bf(NULL), BfC(0), BfL(0) {
82    EAssertR(! FNm.Empty(), "Empty file-name.");
83    FLen = TZipIn::GetFLen(FNm);
84    OpenedP = TFile::Exists(FNm);
85    if (OpenedP) {
86      #ifdef GLib_WIN
87      SECURITY_ATTRIBUTES saAttr;
88      saAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
89      saAttr.bInheritHandle = TRUE;
90      saAttr.lpSecurityDescriptor = NULL;
91      EAssertR(CreatePipe(&ZipStdoutRd, &ZipStdoutWr, &saAttr, 0), "Stdout pipe creation failed");
92      SetHandleInformation(ZipStdoutRd, HANDLE_FLAG_INHERIT, 0);
93      #else
94      #endif
95      CreateZipProcess(GetCmd(FNm.GetFExt()), FNm);
96      Bf = new char[MxBfL]; BfC = BfL=-1;
97      FillBf();
98    }
99  }
100  PSIn TZipIn::New(const TStr& FNm) {
101    return PSIn(new TZipIn(FNm));
102  }
103  PSIn TZipIn::New(const TStr& FNm, bool& OpenedP){
104    return PSIn(new TZipIn(FNm, OpenedP));
105  }
106  TZipIn::~TZipIn(){
107    #ifdef GLib_WIN
108    if (ZipStdoutRd != NULL) {
109      EAssertR(CloseHandle(ZipStdoutRd), "Closing read-end of pipe failed"); }
110    if (ZipStdoutWr != NULL) {
111      EAssertR(CloseHandle(ZipStdoutWr)!=0, "Closing write-end of pipe failed"); }
112    #else
113    if (ZipStdoutRd != NULL) {
114      EAssertR(pclose(ZipStdoutRd) != -1, "Closing of the process failed"); }
115    #endif
116    if (Bf != NULL) { delete[] Bf; }
117  }
118  int TZipIn::GetBf(const void* LBf, const TSize& LBfL){
119    int LBfS=0;
120    if (TSize(BfC+LBfL)>TSize(BfL)){
121      for (TSize LBfC=0; LBfC<LBfL; LBfC++){
122        if (BfC==BfL){FillBf();}
123        LBfS+=((char*)LBf)[LBfC]=Bf[BfC++];}
124    } else {
125      for (TSize LBfC=0; LBfC<LBfL; LBfC++){
126        LBfS+=(((char*)LBf)[LBfC]=Bf[BfC++]);}
127    }
128    return LBfS;
129  }
130  bool TZipIn::GetNextLnBf(TChA& LnChA) {
131    int Status;
132    int BfN;        
133    int BfP;        
134    LnChA.Clr();
135    do {
136      if (BfC >= BfL) { BfP = 0; } 
137      else { BfP = BfC; }
138      Status = FindEol(BfN);
139      if (Status >= 0) {
140        LnChA.AddBf(&Bf[BfP],BfN-BfP);
141        if (Status == 1) { return true; } 
142      }
143    } while (Status == 0);
144    return !LnChA.Empty();
145  }
146  int TZipIn::FindEol(int& BfN) {
147    char Ch;
148    if (BfC >= BfL) { 
149      if (Eof()) { return -1; }
150      FillBf();
151    }
152    while (BfC < BfL) {
153      Ch = Bf[BfC++];
154      if (Ch=='\n') { BfN = BfC-1; return 1; }
155      if (Ch=='\r' && Bf[BfC+1]=='\n') {
156        BfC++;  BfN = BfC-2;  return 1; }
157    }
158    BfN = BfC;
159    return 0;
160  }
161  bool TZipIn::IsZipExt(const TStr& FNmExt) {
162    if (FExtToCmdH.Empty()) FillFExtToCmdH();
163    return FExtToCmdH.IsKey(FNmExt);
164  }
165  void TZipIn::FillFExtToCmdH() {
166    #ifdef GLib_WIN
167    const char* ZipCmd = "7z.exe e -y -bd -so";
168    #else
169    const char* ZipCmd = "7za e -y -bd -so";
170    #endif
171    if (FExtToCmdH.Empty()) {
172      FExtToCmdH.AddDat(".gz",  ZipCmd);
173      FExtToCmdH.AddDat(".7z",  ZipCmd);
174      FExtToCmdH.AddDat(".rar", ZipCmd);
175      FExtToCmdH.AddDat(".zip", ZipCmd);
176      FExtToCmdH.AddDat(".cab", ZipCmd);
177      FExtToCmdH.AddDat(".arj", ZipCmd);
178      FExtToCmdH.AddDat(".bzip2", ZipCmd);
179      FExtToCmdH.AddDat(".bz2", ZipCmd);
180    }
181  }
182  TStr TZipIn::GetCmd(const TStr& ZipFNm) {
183    if (FExtToCmdH.Empty()) FillFExtToCmdH();
184    const TStr Ext = ZipFNm.GetFExt().GetLc();
185    EAssertR(FExtToCmdH.IsKey(Ext), TStr::Fmt("Unsupported file extension '%s'", Ext.CStr()));
186    return FExtToCmdH.GetDat(Ext);
187  }
188  uint64 TZipIn::GetFLen(const TStr& ZipFNm) {
189    #ifdef GLib_WIN
190    HANDLE ZipStdoutRd, ZipStdoutWr;
191    SECURITY_ATTRIBUTES saAttr;
192    saAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
193    saAttr.bInheritHandle = TRUE;
194    saAttr.lpSecurityDescriptor = NULL;
195    const int PipeBufferSz = 32*1024;
196    EAssertR(CreatePipe(&ZipStdoutRd, &ZipStdoutWr, &saAttr, PipeBufferSz), "Stdout pipe creation failed");
197    SetHandleInformation(ZipStdoutRd, HANDLE_FLAG_INHERIT, 0);
198    { const TStr CmdLine = TStr::Fmt("7z.exe l %s", ZipFNm.CStr());
199    PROCESS_INFORMATION piProcInfo;
200    STARTUPINFO siStartInfo;
201    ZeroMemory( &piProcInfo, sizeof(PROCESS_INFORMATION));
202    ZeroMemory( &siStartInfo, sizeof(STARTUPINFO));
203    siStartInfo.cb = sizeof(STARTUPINFO);
204    siStartInfo.hStdOutput = ZipStdoutWr;
205    siStartInfo.dwFlags |= STARTF_USESTDHANDLES;
206    const BOOL FuncRetn = CreateProcess(NULL, (LPSTR) CmdLine.CStr(),
207      NULL, NULL, TRUE, 0, NULL, NULL, &siStartInfo, &piProcInfo);
208    EAssertR(FuncRetn!=0, TStr::Fmt("Can not execute '%s' (Set the TZipIn::SevenZipPath)", CmdLine.CStr()).CStr());
209    CloseHandle(piProcInfo.hProcess);
210    CloseHandle(piProcInfo.hThread); }
211    #else
212    const TStr CmdLine = TStr::Fmt("7za l %s", ZipFNm.CStr());
213    FILE* ZipStdoutRd = popen((TZipIn::SevenZipPath+"/"+CmdLine).CStr(), "r");
214    EAssertR(ZipStdoutRd, TStr::Fmt("Can not execute '%s/%s' (Set the TZipIn::SevenZipPath)", TZipIn::SevenZipPath.CStr(), CmdLine.CStr()).CStr());
215    #endif
216    const int BfSz = 32*1024;
217    char* Bf = new char [BfSz];
218    int BfC=0, BfL=0;
219    memset(Bf, 0, BfSz);
220    #ifdef GLib_WIN
221    DWORD BytesRead;
222    EAssert(ReadFile(ZipStdoutRd, Bf, MxBfL, &BytesRead, NULL) != 0);
223    #else
224    size_t BytesRead = fread(Bf, 1, MxBfL, ZipStdoutRd);
225    EAssert(BytesRead != 0);
226    EAssert(pclose(ZipStdoutRd) != -1);
227    #endif
228    BfL = (int) BytesRead;  IAssert((BfC!=0)||(BfL!=0));
229    BfC = 0; Bf[BfL] = 0;
230    TStr Str(Bf);  delete [] Bf;
231    TStrV StrV; Str.SplitOnWs(StrV);
232    int n = StrV.Len()-1;
233    while (n > 0 && ! StrV[n].IsPrefix("-----")) { n--; }
234    if (n-7 <= 0) {
235      WrNotify(TStr::Fmt("Corrupt file %s: MESSAGE:\n", ZipFNm.CStr()).CStr(), Str.CStr());
236      SaveToErrLog(TStr::Fmt("Corrupt file %s. Message:\n:%s\n", ZipFNm.CStr(), Str.CStr()).CStr());
237      return 0;
238    }
239    return StrV[n-7].GetInt64();
240  }
241  TStrStrH TZipOut::FExtToCmdH;
242  const TSize TZipOut::MxBfL=4*1024;
243  void TZipOut::FlushBf() {
244    #ifdef GLib_WIN
245    DWORD BytesOut;
246    EAssertR(WriteFile(ZipStdinWr, Bf, DWORD(BfL), &BytesOut, NULL)!=0, "Error writting to the file '"+GetSNm()+"'.");
247    #else
248    size_t BytesOut = fwrite(Bf, 1, BfL, ZipStdinWr);
249    #endif
250    EAssert(BytesOut == BfL);
251    BfL = 0;
252  }
253  void TZipOut::CreateZipProcess(const TStr& Cmd, const TStr& ZipFNm) {
254    const TStr CmdLine = TStr::Fmt("%s %s", Cmd.CStr(), ZipFNm.CStr());
255    #ifdef GLib_WIN
256    PROCESS_INFORMATION piProcInfo;
257    STARTUPINFO siStartInfo;
258    ZeroMemory( &piProcInfo, sizeof(PROCESS_INFORMATION));
259    ZeroMemory( &siStartInfo, sizeof(STARTUPINFO));
260    siStartInfo.cb = sizeof(STARTUPINFO);
261    siStartInfo.hStdInput = ZipStdinRd;
262    siStartInfo.dwFlags |= STARTF_USESTDHANDLES;
263    const BOOL FuncRetn = CreateProcess(NULL,
264      (LPSTR) CmdLine.CStr(),  
265      NULL,          
266      NULL,          
267      TRUE,          
268      0,             
269      NULL,          
270      NULL,          
271      &siStartInfo,  
272      &piProcInfo);  
<span onclick='openModal()' class='match'>273    EAssertR(FuncRetn!=0, TStr::Fmt("Can not execute '%s' (Set the TZipIn::SevenZipPath)", CmdLine.CStr()).CStr());
274    CloseHandle(piProcInfo.hProcess);
275    CloseHandle(piProcInfo.hThread);
276    #else
</span>277    ZipStdinWr = popen((TZipIn::SevenZipPath+"/"+CmdLine).CStr(), "r");
278    EAssertR(ZipStdinWr,  TStr::Fmt("Can not execute '%s' (Set the TZipIn::SevenZipPath)", CmdLine.CStr()).CStr());
279    #endif
280  }
281  TZipOut::TZipOut(const TStr& FNm) : TSBase(FNm.CStr()), TSOut(FNm), ZipStdinRd(NULL), ZipStdinWr(NULL), Bf(NULL), BfL(0){
282    EAssertR(! FNm.Empty(), "Empty file-name.");
283    #ifdef GLib_WIN
284    SECURITY_ATTRIBUTES saAttr;
285    saAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
286    saAttr.bInheritHandle = TRUE;
287    saAttr.lpSecurityDescriptor = NULL;
288    EAssertR(CreatePipe(&ZipStdinRd, &ZipStdinWr, &saAttr, 0), "Stdout pipe creation failed");
289    SetHandleInformation(ZipStdinWr, HANDLE_FLAG_INHERIT, 0);
290    #else
291    #endif
292    CreateZipProcess(GetCmd(FNm), FNm);
293    Bf=new char[MxBfL];  BfL=0;
294  }
295  PSOut TZipOut::New(const TStr& FNm){
296    return PSOut(new TZipOut(FNm));
297  }
298  TZipOut::~TZipOut() {
299    if (BfL!=0) { FlushBf(); }
300    #ifdef GLib_WIN
301    if (ZipStdinWr != NULL) { EAssertR(CloseHandle(ZipStdinWr), "Closing write-end of pipe failed"); }
302    if (ZipStdinRd != NULL) { EAssertR(CloseHandle(ZipStdinRd), "Closing read-end of pipe failed"); }
303    #else
304    if (ZipStdinWr != NULL) { EAssertR(pclose(ZipStdinWr) != -1, "Closing of the process failed"); }
305    #endif
306    if (Bf!=NULL) { delete[] Bf; }
307  }
308  int TZipOut::PutCh(const char& Ch){
309    if (BfL==MxBfL) {FlushBf();}
310    return Bf[BfL++]=Ch;
311  }
312  int TZipOut::PutBf(const void* LBf, const TSize& LBfL){
313    int LBfS=0;
314    if (BfL+LBfL>MxBfL){
315      for (TSize LBfC=0; LBfC<LBfL; LBfC++){
316        LBfS+=PutCh(((char*)LBf)[LBfC]);}
317    } else {
318      for (TSize LBfC=0; LBfC<LBfL; LBfC++){
319        LBfS+=(Bf[BfL++]=((char*)LBf)[LBfC]);}
320    }
321    return LBfS;
322  }
323  void TZipOut::Flush(){
324    FlushBf();
325    #ifdef GLib_WIN
326    EAssertR(FlushFileBuffers(ZipStdinWr)!=0, "Can not flush file '"+GetSNm()+"'.");
327    #else
328    EAssertR(fflush(ZipStdinWr)==0, "Can not flush file '"+GetSNm()+"'.");
329    #endif
330  }
331  bool TZipOut::IsZipExt(const TStr& FNmExt) {
332    if (FExtToCmdH.Empty()) FillFExtToCmdH();
333    return FExtToCmdH.IsKey(FNmExt);
334  }
335  void TZipOut::FillFExtToCmdH() {
336    #ifdef GLib_WIN
337    const char* ZipCmd = "7z.exe a -y -bd -si";
338    #else
339    const char* ZipCmd = "7za a -y -bd -si";
340    #endif
341    if (FExtToCmdH.Empty()) {
342      FExtToCmdH.AddDat(".gz",  ZipCmd);
343      FExtToCmdH.AddDat(".7z",  ZipCmd);
344      FExtToCmdH.AddDat(".rar", ZipCmd);
345      FExtToCmdH.AddDat(".zip", ZipCmd);
346      FExtToCmdH.AddDat(".cab", ZipCmd);
347      FExtToCmdH.AddDat(".arj", ZipCmd);
348      FExtToCmdH.AddDat(".bzip2", ZipCmd);
349      FExtToCmdH.AddDat(".bz2", ZipCmd);
350    }
351  }
352  TStr TZipOut::GetCmd(const TStr& ZipFNm) {
353    if (FExtToCmdH.Empty()) FillFExtToCmdH();
354    const TStr Ext = ZipFNm.GetFExt().GetLc();
355    EAssertR(FExtToCmdH.IsKey(Ext), TStr::Fmt("Unsupported file extension '%s'", Ext.CStr()));
356    return FExtToCmdH.GetDat(Ext)+ZipFNm.GetFMid();
357  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-zipfl.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-zipfl.cpp</div>
                </div>
                <div class="column column_space"><pre><code>208    EAssertR(FuncRetn!=0, TStr::Fmt("Can not execute '%s' (Set the TZipIn::SevenZipPath)", CmdLine.CStr()).CStr());
209    CloseHandle(piProcInfo.hProcess);
210    CloseHandle(piProcInfo.hThread); }
</pre></code></div>
                <div class="column column_space"><pre><code>273    EAssertR(FuncRetn!=0, TStr::Fmt("Can not execute '%s' (Set the TZipIn::SevenZipPath)", CmdLine.CStr()).CStr());
274    CloseHandle(piProcInfo.hProcess);
275    CloseHandle(piProcInfo.hThread);
276    #else
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    