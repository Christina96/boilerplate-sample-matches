
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 15.859030837004406%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-bbgrid.cpp</h3>
            <pre><code>1  #include "bbgrid.h"
2  #include "helpers.h"
3  #include "ocrblock.h"
4  namespace tesseract {
5  GridBase::GridBase(int gridsize, const ICOORD &bleft, const ICOORD &tright) {
6    Init(gridsize, bleft, tright);
7  }
8  GridBase::~GridBase() = default;
9  void GridBase::Init(int gridsize, const ICOORD &bleft, const ICOORD &tright) {
10    gridsize_ = gridsize;
11    bleft_ = bleft;
12    tright_ = tright;
13    if (gridsize_ == 0) {
14      gridsize_ = 1;
15    }
16    gridwidth_ = (tright.x() - bleft.x() + gridsize_ - 1) / gridsize_;
17    gridheight_ = (tright.y() - bleft.y() + gridsize_ - 1) / gridsize_;
18    gridbuckets_ = gridwidth_ * gridheight_;
19  }
20  void GridBase::GridCoords(int x, int y, int *grid_x, int *grid_y) const {
21    *grid_x = (x - bleft_.x()) / gridsize_;
22    *grid_y = (y - bleft_.y()) / gridsize_;
23    ClipGridCoords(grid_x, grid_y);
24  }
25  void GridBase::ClipGridCoords(int *x, int *y) const {
26    *x = ClipToRange(*x, 0, gridwidth_ - 1);
27    *y = ClipToRange(*y, 0, gridheight_ - 1);
28  }
29  IntGrid::IntGrid() {
30    grid_ = nullptr;
31  }
32  IntGrid::IntGrid(int gridsize, const ICOORD &bleft, const ICOORD &tright) : grid_(nullptr) {
33    Init(gridsize, bleft, tright);
34  }
35  IntGrid::~IntGrid() {
36    delete[] grid_;
37  }
38  void IntGrid::Init(int gridsize, const ICOORD &bleft, const ICOORD &tright) {
39    GridBase::Init(gridsize, bleft, tright);
40    delete[] grid_;
41    grid_ = new int[gridbuckets_];
42    Clear();
43  }
44  void IntGrid::Clear() {
45    for (int i = 0; i < gridbuckets_; ++i) {
46      grid_[i] = 0;
47    }
48  }
49  void IntGrid::Rotate(const FCOORD &rotation) {
50    ASSERT_HOST(rotation.x() == 0.0f || rotation.y() == 0.0f);
51    ICOORD old_bleft(bleft());
52    int old_width = gridwidth();
53    int old_height = gridheight();
54    TBOX box(bleft(), tright());
55    box.rotate(rotation);
56    int *old_grid = grid_;
57    grid_ = nullptr;
58    Init(gridsize(), box.botleft(), box.topright());
59    int oldi = 0;
60    FCOORD x_step(rotation);
61    x_step *= gridsize();
62    for (int oldy = 0; oldy < old_height; ++oldy) {
63      FCOORD line_pos(old_bleft.x(), old_bleft.y() + gridsize() * oldy);
64      line_pos.rotate(rotation);
65      for (int oldx = 0; oldx < old_width; ++oldx, line_pos += x_step, ++oldi) {
66        int grid_x, grid_y;
67        GridCoords(static_cast<int>(line_pos.x() + 0.5), static_cast<int>(line_pos.y() + 0.5),
68                   &grid_x, &grid_y);
69        grid_[grid_y * gridwidth() + grid_x] = old_grid[oldi];
70      }
71    }
72    delete[] old_grid;
73  }
74  IntGrid *IntGrid::NeighbourhoodSum() const {
75    auto *sumgrid = new IntGrid(gridsize(), bleft(), tright());
<span onclick='openModal()' class='match'>76    for (int y = 0; y < gridheight(); ++y) {
77      for (int x = 0; x < gridwidth(); ++x) {
</span>78        int cell_count = 0;
79        for (int yoffset = -1; yoffset <= 1; ++yoffset) {
80          for (int xoffset = -1; xoffset <= 1; ++xoffset) {
81            int grid_x = x + xoffset;
82            int grid_y = y + yoffset;
83            ClipGridCoords(&grid_x, &grid_y);
84            cell_count += GridCellValue(grid_x, grid_y);
85          }
86        }
87        if (GridCellValue(x, y) > 1) {
88          sumgrid->SetGridCell(x, y, cell_count);
89        }
90      }
91    }
92    return sumgrid;
93  }
94  bool IntGrid::RectMostlyOverThreshold(const TBOX &rect, int threshold) const {
95    int min_x, min_y, max_x, max_y;
96    GridCoords(rect.left(), rect.bottom(), &min_x, &min_y);
97    GridCoords(rect.right(), rect.top(), &max_x, &max_y);
98    int total_area = 0;
99    for (int y = min_y; y <= max_y; ++y) {
100      for (int x = min_x; x <= max_x; ++x) {
101        int value = GridCellValue(x, y);
102        if (value > threshold) {
103          TBOX cell_box(x * gridsize_, y * gridsize_, (x + 1) * gridsize_, (y + 1) * gridsize_);
104          cell_box &= rect; 
105          total_area += cell_box.area();
106        }
107      }
108    }
109    return total_area * 2 > rect.area();
110  }
111  bool IntGrid::AnyZeroInRect(const TBOX &rect) const {
112    int min_x, min_y, max_x, max_y;
113    GridCoords(rect.left(), rect.bottom(), &min_x, &min_y);
114    GridCoords(rect.right(), rect.top(), &max_x, &max_y);
115    for (int y = min_y; y <= max_y; ++y) {
116      for (int x = min_x; x <= max_x; ++x) {
117        if (GridCellValue(x, y) == 0) {
118          return true;
119        }
120      }
121    }
122    return false;
123  }
124  Image IntGrid::ThresholdToPix(int threshold) const {
125    Image pix = pixCreate(tright().x() - bleft().x(), tright().y() - bleft().y(), 1);
126    int cellsize = gridsize();
127    for (int y = 0; y < gridheight(); ++y) {
128      for (int x = 0; x < gridwidth(); ++x) {
129        if (GridCellValue(x, y) > threshold && GridCellValue(x - 1, y) > 0 &&
130            GridCellValue(x + 1, y) > 0 && GridCellValue(x, y - 1) > 0 &&
131            GridCellValue(x, y + 1) > 0) {
132          pixRasterop(pix, x * cellsize, tright().y() - ((y + 1) * cellsize), cellsize, cellsize,
133                      PIX_SET, nullptr, 0, 0);
134        }
135      }
136    }
137    return pix;
138  }
139  static Image GridReducedPix(const TBOX &box, int gridsize, ICOORD bleft, int *left, int *bottom) {
140    int grid_left = (box.left() - bleft.x()) / gridsize - 1;
141    int grid_bottom = (box.bottom() - bleft.y()) / gridsize - 1;
142    int grid_right = (box.right() - bleft.x()) / gridsize + 1;
143    int grid_top = (box.top() - bleft.y()) / gridsize + 1;
144    *left = grid_left;
145    *bottom = grid_bottom;
146    return pixCreate(grid_right - grid_left + 1, grid_top - grid_bottom + 1, 1);
147  }
148  Image TraceOutlineOnReducedPix(C_OUTLINE *outline, int gridsize, ICOORD bleft, int *left,
149                                int *bottom) {
150    const TBOX &box = outline->bounding_box();
151    Image pix = GridReducedPix(box, gridsize, bleft, left, bottom);
152    int wpl = pixGetWpl(pix);
153    l_uint32 *data = pixGetData(pix);
154    int length = outline->pathlength();
155    ICOORD pos = outline->start_pos();
156    for (int i = 0; i < length; ++i) {
157      int grid_x = (pos.x() - bleft.x()) / gridsize - *left;
158      int grid_y = (pos.y() - bleft.y()) / gridsize - *bottom;
159      SET_DATA_BIT(data + grid_y * wpl, grid_x);
160      pos += outline->step(i);
161    }
162    return pix;
163  }
164  #if 0 
165    C_OUTLINE_IT ol_it(blob->cblob()->out_list());
166    int grid_left, grid_bottom;
167    Pix* pix = TraceOutlineOnReducedPix(ol_it.data(), gridsize_, bleft_,
168                                        &grid_left, &grid_bottom);
169    grid->InsertPixPtBBox(grid_left, grid_bottom, pix, blob);
170    pix.destroy();
171  #endif
172  Image TraceBlockOnReducedPix(BLOCK *block, int gridsize, ICOORD bleft, int *left, int *bottom) {
173    const TBOX &box = block->pdblk.bounding_box();
174    Image pix = GridReducedPix(box, gridsize, bleft, left, bottom);
175    int wpl = pixGetWpl(pix);
176    l_uint32 *data = pixGetData(pix);
177    ICOORDELT_IT it(block->pdblk.poly_block()->points());
178    for (it.mark_cycle_pt(); !it.cycled_list();) {
179      ICOORD pos = *it.data();
180      it.forward();
181      ICOORD next_pos = *it.data();
182      ICOORD line_vector = next_pos - pos;
183      int major, minor;
184      ICOORD major_step, minor_step;
185      line_vector.setup_render(&major_step, &minor_step, &major, &minor);
186      int accumulator = major / 2;
187      while (pos != next_pos) {
188        int grid_x = (pos.x() - bleft.x()) / gridsize - *left;
189        int grid_y = (pos.y() - bleft.y()) / gridsize - *bottom;
190        SET_DATA_BIT(data + grid_y * wpl, grid_x);
191        pos += major_step;
192        accumulator += minor;
193        if (accumulator >= major) {
194          accumulator -= major;
195          pos += minor_step;
196        }
197      }
198    }
199    return pix;
200  }
201  } 
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-centr-exp.h</h3>
            <pre><code>1  namespace TSnap {
2  template<class PGraph> void GetPageRank_v2(const PGraph& Graph, TIntFltH& PRankH, const double& C=0.85, const double& Eps=1e-4, const int& MaxIter=100);
3  #ifdef USE_OPENMP
4  template<class PGraph> void GetPageRankMP1(const PGraph& Graph, TIntFltH& PRankH, const double& C=0.85, const double& Eps=1e-4, const int& MaxIter=100);
5  template<class PGraph> void GetPageRankMP2(const PGraph& Graph, TIntFltH& PRankH, const double& C=0.85, const double& Eps=1e-4, const int& MaxIter=100);
6  template<class PGraph> void GetPageRankMP3(const PGraph& Graph, TIntFltH& PRankH, const double& C=0.85, const double& Eps=1e-4, const int& MaxIter=100);
7  template<class PGraph> void GetPageRankMNetMP(const PGraph& Graph, TIntFltH& PRankH, const double& C, const double& Eps, const int& MaxIter);
8  #endif
9  #ifdef USE_OPENMP
10  int GetWeightedPageRankMP1(const PNEANet Graph, TIntFltH& PRankH, const TStr& Attr, const double& C=0.85, const double& Eps=1e-4, const int& MaxIter=100);
11  int GetWeightedPageRankMP2(const PNEANet Graph, TIntFltH& PRankH, const TStr& Attr, const double& C=0.85, const double& Eps=1e-4, const int& MaxIter=100);
12  #endif
13  template<class PGraph>
14  void GetPageRank_v2(const PGraph& Graph, TIntFltH& PRankH, const double& C, const double& Eps, const int& MaxIter) {
15    const int NNodes = Graph->GetNodes();
16    TVec<typename PGraph::TObj::TNodeI> NV;
17    PRankH.Gen(NNodes);
18    int MxId = -1;
19    for (typename PGraph::TObj::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
20      NV.Add(NI);
21      PRankH.AddDat(NI.GetId(), 1.0/NNodes);
22      int Id = NI.GetId();
23      if (Id > MxId) {
24        MxId = Id;
25      }
26    }
27    TFltV PRankV(MxId+1);
28    TIntV OutDegV(MxId+1);
29    for (int j = 0; j < NNodes; j++) {
30      typename PGraph::TObj::TNodeI NI = NV[j];
31      int Id = NI.GetId();
32      PRankV[Id] = 1.0/NNodes;
33      OutDegV[Id] = NI.GetOutDeg();
34    }
35    TFltV TmpV(NNodes);
<span onclick='openModal()' class='match'>36    for (int iter = 0; iter < MaxIter; iter++) {
37      for (int j = 0; j < NNodes; j++) {
</span>38        typename PGraph::TObj::TNodeI NI = NV[j];
39        TFlt Tmp = 0;
40        for (int e = 0; e < NI.GetInDeg(); e++) {
41          const int InNId = NI.GetInNId(e);
42          const int OutDeg = OutDegV[InNId];
43          if (OutDeg > 0) {
44            Tmp += PRankV[InNId] / OutDeg;
45          }
46        }
47        TmpV[j] =  C*Tmp; 
48      }
49      double sum = 0;
50      for (int i = 0; i < TmpV.Len(); i++) { sum += TmpV[i]; }
51      const double Leaked = (1.0-sum) / double(NNodes);
52      double diff = 0;
53      for (int i = 0; i < NNodes; i++) {
54        typename PGraph::TObj::TNodeI NI = NV[i];
55        double NewVal = TmpV[i] + Leaked; 
56        int Id = NI.GetId();
57        diff += fabs(NewVal-PRankV[Id]);
58        PRankV[Id] = NewVal;
59      }
60      if (diff < Eps) { break; }
61    }
62    for (int i = 0; i < NNodes; i++) {
63      typename PGraph::TObj::TNodeI NI = NV[i];
64      PRankH[i] = PRankV[NI.GetId()];
65    }
66  }
67  #ifdef USE_OPENMP
68  template<class PGraph>
69  void GetPageRankMP1(const PGraph& Graph, TIntFltH& PRankH, const double& C, const double& Eps, const int& MaxIter) {
70    const int NNodes = Graph->GetNodes();
71    TVec<typename PGraph::TObj::TNodeI> NV;
72    PRankH.Gen(NNodes);
73    for (typename PGraph::TObj::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
74      NV.Add(NI);
75      PRankH.AddDat(NI.GetId(), 1.0/NNodes);
76    }
77    TFltV TmpV(NNodes);
78    for (int iter = 0; iter < MaxIter; iter++) {
79      #pragma omp parallel for schedule(dynamic,10000)
80      for (int j = 0; j < NNodes; j++) {
81        typename PGraph::TObj::TNodeI NI = NV[j];
82        TmpV[j] = 0;
83        for (int e = 0; e < NI.GetInDeg(); e++) {
84          const int InNId = NI.GetInNId(e);
85          const int OutDeg = Graph->GetNI(InNId).GetOutDeg();
86          if (OutDeg > 0) {
87            TmpV[j] += PRankH.GetDat(InNId) / OutDeg;
88          }
89        }
90        TmpV[j] =  C*TmpV[j]; 
91      }
92      double sum = 0;
93      #pragma omp parallel for reduction(+:sum) schedule(dynamic,10000)
94      for (int i = 0; i < TmpV.Len(); i++) { sum += TmpV[i]; }
95      const double Leaked = (1.0-sum) / double(NNodes);
96      double diff = 0;
97      #pragma omp parallel for reduction(+:diff) schedule(dynamic,10000)
98      for (int i = 0; i < PRankH.Len(); i++) { 
99        double NewVal = TmpV[i] + Leaked; 
100        diff += fabs(NewVal-PRankH[i]);
101        PRankH[i] = NewVal;
102      }
103      if (diff < Eps) { break; }
104    }
105  }
106  template<class PGraph>
107  void GetPageRankMP2(const PGraph& Graph, TIntFltH& PRankH, const double& C, const double& Eps, const int& MaxIter) {
108    const int NNodes = Graph->GetNodes();
109    TVec<typename PGraph::TObj::TNodeI> NV;
110    PRankH.Gen(NNodes);
111    int MxId = -1;
112    for (typename PGraph::TObj::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
113      NV.Add(NI);
114      PRankH.AddDat(NI.GetId(), 1.0/NNodes);
115      int Id = NI.GetId();
116      if (Id > MxId) {
117        MxId = Id;
118      }
119    }
120    TFltV PRankV(MxId+1);
121    TIntV OutDegV(MxId+1);
122    #pragma omp parallel for schedule(dynamic,10000)
123    for (int j = 0; j < NNodes; j++) {
124      typename PGraph::TObj::TNodeI NI = NV[j];
125      int Id = NI.GetId();
126      PRankV[Id] = 1.0/NNodes;
127      OutDegV[Id] = NI.GetOutDeg();
128    }
129    TFltV TmpV(NNodes);
130    for (int iter = 0; iter < MaxIter; iter++) {
131      #pragma omp parallel for schedule(dynamic,10000)
132      for (int j = 0; j < NNodes; j++) {
133        typename PGraph::TObj::TNodeI NI = NV[j];
134        TFlt Tmp = 0;
135        for (int e = 0; e < NI.GetInDeg(); e++) {
136          const int InNId = NI.GetInNId(e);
137          const int OutDeg = OutDegV[InNId];
138          if (OutDeg > 0) {
139            Tmp += PRankV[InNId] / OutDeg;
140          }
141        }
142        TmpV[j] =  C*Tmp; 
143      }
144      double sum = 0;
145      #pragma omp parallel for reduction(+:sum) schedule(dynamic,10000)
146      for (int i = 0; i < TmpV.Len(); i++) { sum += TmpV[i]; }
147      const double Leaked = (1.0-sum) / double(NNodes);
148      double diff = 0;
149      #pragma omp parallel for reduction(+:diff) schedule(dynamic,10000)
150      for (int i = 0; i < NNodes; i++) {
151        double NewVal = TmpV[i] + Leaked; 
152        int Id = NV[i].GetId();
153        diff += fabs(NewVal-PRankV[Id]);
154        PRankV[Id] = NewVal;
155      }
156      if (diff < Eps) { break; }
157    }
158    #pragma omp parallel for schedule(dynamic,10000)
159    for (int i = 0; i < NNodes; i++) {
160      typename PGraph::TObj::TNodeI NI = NV[i];
161      PRankH[i] = PRankV[NI.GetId()];
162    }
163  }
164  template<class PGraph>
165  void GetPageRankMP3(const PGraph& Graph, TIntFltH& PRankH, const double& C, const double& Eps, const int& MaxIter) {
166    const int NNodes = Graph->GetNodes();
167    TVec<typename PGraph::TObj::TNodeI> NV;
168    PRankH.Gen(NNodes);
169    TIntIntH NIdH(NNodes);
170    int c = 0;
171    for (typename PGraph::TObj::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
172      NV.Add(NI);
173      PRankH.AddDat(NI.GetId(), 1.0/NNodes);
174      int Id = NI.GetId();
175      NIdH.AddDat(Id, c++);
176    }
177    TFltV PRankV(NNodes);
178    TIntV OutDegV(NNodes);
179    #pragma omp parallel for schedule(dynamic,10000)
180    for (int j = 0; j < NNodes; j++) {
181      int Id = NV[j].GetId();
182      PRankV[NIdH.GetDat(Id)] = 1.0/NNodes;
183      OutDegV[NIdH.GetDat(Id)] = NV[j].GetOutDeg();
184    }
185    TFltV TmpV(NNodes);
186    for (int iter = 0; iter < MaxIter; iter++) {
187      #pragma omp parallel for schedule(dynamic,10000)
188      for (int j = 0; j < NNodes; j++) {
189        typename PGraph::TObj::TNodeI NI = NV[j];
190        TFlt Tmp = 0;
191        for (int e = 0; e < NI.GetInDeg(); e++) {
192          const int InNId = NIdH.GetDat(NI.GetInNId(e));
193          const int OutDeg = OutDegV[InNId];
194          if (OutDeg > 0) {
195            Tmp += PRankV[InNId] / OutDeg;
196          }
197        }
198        TmpV[j] =  C*Tmp; 
199      }
200      double sum = 0;
201      #pragma omp parallel for reduction(+:sum) schedule(dynamic,10000)
202      for (int i = 0; i < TmpV.Len(); i++) { sum += TmpV[i]; }
203      const double Leaked = (1.0-sum) / double(NNodes);
204      double diff = 0;
205      #pragma omp parallel for reduction(+:diff) schedule(dynamic,10000)
206      for (int i = 0; i < NNodes; i++) {
207        typename PGraph::TObj::TNodeI NI = NV[i];
208        double NewVal = TmpV[i] + Leaked; 
209        int Id = NIdH.GetDat(NI.GetId());
210        diff += fabs(NewVal-PRankV[Id]);
211        PRankV[Id] = NewVal;
212      }
213      if (diff < Eps) { break; }
214    }
215    #pragma omp parallel for schedule(dynamic,10000)
216    for (int i = 0; i < NNodes; i++) {
217      typename PGraph::TObj::TNodeI NI = NV[i];
218      PRankH[i] = PRankV[NIdH.GetDat(NI.GetId())];
219    }
220  }
221  template<class PGraph>
222  void GetPageRankMNetMP(const PGraph& Graph, TIntFltH& PRankH, const double& C, const double& Eps, const int& MaxIter) {
223    const int NNodes = Graph->GetNodes();
224    TVec<typename PGraph::TObj::TNodeI> NV;
225    PRankH.Gen(NNodes);
226    int MxNTypeId = Graph->GetMxNTypeId();
227    TVec<TFltV> PRankVV(MxNTypeId);
228    TVec<TIntV> OutDegVV(MxNTypeId);
229    for (int NTypeId = 0; NTypeId < MxNTypeId; NTypeId++) {
230      int MxNId = Graph->GetMxNId(NTypeId);
231      PRankVV[NTypeId] = TFltV(MxNId);
232      OutDegVV[NTypeId] = TIntV(MxNId);
233    }
234    for (typename PGraph::TObj::TNodeI NI = Graph->BegNI(); NI < Graph->EndNI(); NI++) {
235      NV.Add(NI);
236      PRankH.AddKey(NI.GetId()); 
237    }
238    #pragma omp parallel for schedule(dynamic,10000)
239    for (int j = 0; j < NNodes; j++) {
240      typename PGraph::TObj::TNodeI NI = NV[j];
241      int Id = NI.GetId();
242      int NTypeId = Graph->GetNTypeId(Id);
243      int LocalNId = Graph->GetLocalNId(Id);
244      PRankVV[NTypeId][LocalNId] = 1.0/NNodes;
245      OutDegVV[NTypeId][LocalNId] = NI.GetOutDeg();
246    }
247    TFltV TmpV(NNodes);
248    for (int iter = 0; iter < MaxIter; iter++) {
249      #pragma omp parallel for schedule(dynamic,10000)
250      for (int j = 0; j < NNodes; j++) {
251        typename PGraph::TObj::TNodeI NI = NV[j];
252        TFlt Tmp = 0;
253        for (int e = 0; e < NI.GetInDeg(); e++) {
254          const int InNId = NI.GetInNId(e);
255          const int InNTypeId = Graph->GetNTypeId(InNId);
256          const int InLocalNId = Graph->GetLocalNId(InNId);
257          const int OutDeg = OutDegVV[InNTypeId][InLocalNId];
258          Tmp += (OutDeg > 0) ? (PRankVV[InNTypeId][InLocalNId] / OutDeg) : 0;
259        }
260        TmpV[j] =  C*Tmp; 
261      }
262      double sum = 0;
263      #pragma omp parallel for reduction(+:sum) schedule(dynamic,10000)
264      for (int i = 0; i < TmpV.Len(); i++) { sum += TmpV[i]; }
265      const double Leaked = (1.0-sum) / double(NNodes);
266      double diff = 0;
267      #pragma omp parallel for reduction(+:diff) schedule(dynamic,10000)
268      for (int i = 0; i < NNodes; i++) {
269        double NewVal = TmpV[i] + Leaked; 
270        int Id = NV[i].GetId();
271        int NTypeId = Graph->GetNTypeId(Id);
272        int LocalNId = Graph->GetLocalNId(Id);
273        diff += fabs(NewVal-PRankVV[NTypeId][LocalNId]);
274        PRankVV[NTypeId][LocalNId] = NewVal;
275      }
276      if (diff < Eps) { break; }
277    }
278    #pragma omp parallel for schedule(dynamic,10000)
279    for (int i = 0; i < NNodes; i++) {
280      typename PGraph::TObj::TNodeI NI = NV[i];
281      int NTypeId = NI.GetTypeId();
282      int LocalNId = NI.GetLocalId();
283      PRankH[i] = PRankVV[NTypeId][LocalNId];
284    }
285  }
286  #endif 
287  }; 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-bbgrid.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-centr-exp.h</div>
                </div>
                <div class="column column_space"><pre><code>76    for (int y = 0; y < gridheight(); ++y) {
77      for (int x = 0; x < gridwidth(); ++x) {
</pre></code></div>
                <div class="column column_space"><pre><code>36    for (int iter = 0; iter < MaxIter; iter++) {
37      for (int j = 0; j < NNodes; j++) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    