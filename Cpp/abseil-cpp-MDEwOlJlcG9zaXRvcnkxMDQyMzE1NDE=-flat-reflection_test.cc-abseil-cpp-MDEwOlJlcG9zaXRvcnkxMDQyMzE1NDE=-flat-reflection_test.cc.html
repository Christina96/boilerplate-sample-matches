
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-reflection_test.cc</h3>
            <pre><code>1  #include "absl/flags/reflection.h"
2  #include <memory>
3  #include <string>
4  #include "gmock/gmock.h"
5  #include "gtest/gtest.h"
6  #include "absl/flags/declare.h"
7  #include "absl/flags/flag.h"
8  #include "absl/flags/internal/commandlineflag.h"
9  #include "absl/flags/marshalling.h"
10  #include "absl/memory/memory.h"
11  #include "absl/strings/str_cat.h"
12  #include "absl/strings/str_split.h"
13  ABSL_FLAG(int, int_flag, 1, "int_flag help");
14  ABSL_FLAG(std::string, string_flag, "dflt", "string_flag help");
15  ABSL_RETIRED_FLAG(bool, bool_retired_flag, false, "bool_retired_flag help");
16  namespace {
17  class ReflectionTest : public testing::Test {
18   protected:
19    void SetUp() override { flag_saver_ = absl::make_unique<absl::FlagSaver>(); }
20    void TearDown() override { flag_saver_.reset(); }
21   private:
22    std::unique_ptr<absl::FlagSaver> flag_saver_;
23  };
24  TEST_F(ReflectionTest, TestFindCommandLineFlag) {
25    auto* handle = absl::FindCommandLineFlag("some_flag");
26    EXPECT_EQ(handle, nullptr);
<span onclick='openModal()' class='match'>27    handle = absl::FindCommandLineFlag("int_flag");
28    EXPECT_NE(handle, nullptr);
29    handle = absl::FindCommandLineFlag("string_flag");
</span>30    EXPECT_NE(handle, nullptr);
31    handle = absl::FindCommandLineFlag("bool_retired_flag");
32    EXPECT_NE(handle, nullptr);
33  }
34  TEST_F(ReflectionTest, TestGetAllFlags) {
35    auto all_flags = absl::GetAllFlags();
36    EXPECT_NE(all_flags.find("int_flag"), all_flags.end());
37    EXPECT_EQ(all_flags.find("bool_retired_flag"), all_flags.end());
38    EXPECT_EQ(all_flags.find("some_undefined_flag"), all_flags.end());
39    std::vector<absl::string_view> flag_names_first_attempt;
40    auto all_flags_1 = absl::GetAllFlags();
41    for (auto f : all_flags_1) {
42      flag_names_first_attempt.push_back(f.first);
43    }
44    std::vector<absl::string_view> flag_names_second_attempt;
45    auto all_flags_2 = absl::GetAllFlags();
46    for (auto f : all_flags_2) {
47      flag_names_second_attempt.push_back(f.first);
48    }
49    EXPECT_THAT(flag_names_first_attempt,
50                ::testing::UnorderedElementsAreArray(flag_names_second_attempt));
51  }
52  struct CustomUDT {
53    CustomUDT() : a(1), b(1) {}
54    CustomUDT(int a_, int b_) : a(a_), b(b_) {}
55    friend bool operator==(const CustomUDT& f1, const CustomUDT& f2) {
56      return f1.a == f2.a && f1.b == f2.b;
57    }
58    int a;
59    int b;
60  };
61  bool AbslParseFlag(absl::string_view in, CustomUDT* f, std::string*) {
62    std::vector<absl::string_view> parts =
63        absl::StrSplit(in, ':', absl::SkipWhitespace());
64    if (parts.size() != 2) return false;
65    if (!absl::SimpleAtoi(parts[0], &f->a)) return false;
66    if (!absl::SimpleAtoi(parts[1], &f->b)) return false;
67    return true;
68  }
69  std::string AbslUnparseFlag(const CustomUDT& f) {
70    return absl::StrCat(f.a, ":", f.b);
71  }
72  }  
73  ABSL_FLAG(bool, test_flag_01, true, "");
74  ABSL_FLAG(int, test_flag_02, 1234, "");
75  ABSL_FLAG(int16_t, test_flag_03, -34, "");
76  ABSL_FLAG(uint16_t, test_flag_04, 189, "");
77  ABSL_FLAG(int32_t, test_flag_05, 10765, "");
78  ABSL_FLAG(uint32_t, test_flag_06, 40000, "");
79  ABSL_FLAG(int64_t, test_flag_07, -1234567, "");
80  ABSL_FLAG(uint64_t, test_flag_08, 9876543, "");
81  ABSL_FLAG(double, test_flag_09, -9.876e-50, "");
82  ABSL_FLAG(float, test_flag_10, 1.234e12f, "");
83  ABSL_FLAG(std::string, test_flag_11, "", "");
84  ABSL_FLAG(absl::Duration, test_flag_12, absl::Minutes(10), "");
85  static int counter = 0;
86  ABSL_FLAG(int, test_flag_13, 200, "").OnUpdate([]() { counter++; });
87  ABSL_FLAG(CustomUDT, test_flag_14, {}, "");
88  namespace {
89  TEST_F(ReflectionTest, TestFlagSaverInScope) {
90    {
91      absl::FlagSaver s;
92      counter = 0;
93      absl::SetFlag(&FLAGS_test_flag_01, false);
94      absl::SetFlag(&FLAGS_test_flag_02, -1021);
95      absl::SetFlag(&FLAGS_test_flag_03, 6009);
96      absl::SetFlag(&FLAGS_test_flag_04, 44);
97      absl::SetFlag(&FLAGS_test_flag_05, +800);
98      absl::SetFlag(&FLAGS_test_flag_06, -40978756);
99      absl::SetFlag(&FLAGS_test_flag_07, 23405);
100      absl::SetFlag(&FLAGS_test_flag_08, 975310);
101      absl::SetFlag(&FLAGS_test_flag_09, 1.00001);
102      absl::SetFlag(&FLAGS_test_flag_10, -3.54f);
103      absl::SetFlag(&FLAGS_test_flag_11, "asdf");
104      absl::SetFlag(&FLAGS_test_flag_12, absl::Hours(20));
105      absl::SetFlag(&FLAGS_test_flag_13, 4);
106      absl::SetFlag(&FLAGS_test_flag_14, CustomUDT{-1, -2});
107    }
108    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_01), true);
109    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_02), 1234);
110    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_03), -34);
111    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_04), 189);
112    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_05), 10765);
113    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_06), 40000);
114    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_07), -1234567);
115    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_08), 9876543);
116    EXPECT_NEAR(absl::GetFlag(FLAGS_test_flag_09), -9.876e-50, 1e-55);
117    EXPECT_NEAR(absl::GetFlag(FLAGS_test_flag_10), 1.234e12f, 1e5f);
118    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_11), "");
119    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_12), absl::Minutes(10));
120    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_13), 200);
121    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_14), CustomUDT{});
122    EXPECT_EQ(counter, 2);
123  }
124  TEST_F(ReflectionTest, TestFlagSaverVsUpdateViaReflection) {
125    {
126      absl::FlagSaver s;
127      counter = 0;
128      std::string error;
129      EXPECT_TRUE(
130          absl::FindCommandLineFlag("test_flag_01")->ParseFrom("false", &error))
131          << error;
132      EXPECT_TRUE(
133          absl::FindCommandLineFlag("test_flag_02")->ParseFrom("-4536", &error))
134          << error;
135      EXPECT_TRUE(
136          absl::FindCommandLineFlag("test_flag_03")->ParseFrom("111", &error))
137          << error;
138      EXPECT_TRUE(
139          absl::FindCommandLineFlag("test_flag_04")->ParseFrom("909", &error))
140          << error;
141      EXPECT_TRUE(
142          absl::FindCommandLineFlag("test_flag_05")->ParseFrom("-2004", &error))
143          << error;
144      EXPECT_TRUE(
145          absl::FindCommandLineFlag("test_flag_06")->ParseFrom("1000023", &error))
146          << error;
147      EXPECT_TRUE(
148          absl::FindCommandLineFlag("test_flag_07")->ParseFrom("69305", &error))
149          << error;
150      EXPECT_TRUE(absl::FindCommandLineFlag("test_flag_08")
151                      ->ParseFrom("1000000001", &error))
152          << error;
153      EXPECT_TRUE(
154          absl::FindCommandLineFlag("test_flag_09")->ParseFrom("2.09021", &error))
155          << error;
156      EXPECT_TRUE(
157          absl::FindCommandLineFlag("test_flag_10")->ParseFrom("-33.1", &error))
158          << error;
159      EXPECT_TRUE(
160          absl::FindCommandLineFlag("test_flag_11")->ParseFrom("ADD_FOO", &error))
161          << error;
162      EXPECT_TRUE(absl::FindCommandLineFlag("test_flag_12")
163                      ->ParseFrom("3h11m16s", &error))
164          << error;
165      EXPECT_TRUE(
166          absl::FindCommandLineFlag("test_flag_13")->ParseFrom("0", &error))
167          << error;
168      EXPECT_TRUE(
169          absl::FindCommandLineFlag("test_flag_14")->ParseFrom("10:1", &error))
170          << error;
171    }
172    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_01), true);
173    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_02), 1234);
174    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_03), -34);
175    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_04), 189);
176    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_05), 10765);
177    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_06), 40000);
178    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_07), -1234567);
179    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_08), 9876543);
180    EXPECT_NEAR(absl::GetFlag(FLAGS_test_flag_09), -9.876e-50, 1e-55);
181    EXPECT_NEAR(absl::GetFlag(FLAGS_test_flag_10), 1.234e12f, 1e5f);
182    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_11), "");
183    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_12), absl::Minutes(10));
184    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_13), 200);
185    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_14), CustomUDT{});
186    EXPECT_EQ(counter, 2);
187  }
188  TEST_F(ReflectionTest, TestMultipleFlagSaversInEnclosedScopes) {
189    {
190      absl::FlagSaver s;
191      absl::SetFlag(&FLAGS_test_flag_08, 10);
192      EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_08), 10);
193      {
194        absl::FlagSaver s;
195        absl::SetFlag(&FLAGS_test_flag_08, 20);
196        EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_08), 20);
197        {
198          absl::FlagSaver s;
199          absl::SetFlag(&FLAGS_test_flag_08, -200);
200          EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_08), -200);
201        }
202        EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_08), 20);
203      }
204      EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_08), 10);
205    }
206    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_08), 9876543);
207  }
208  }  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-reflection_test.cc</h3>
            <pre><code>1  #include "absl/flags/reflection.h"
2  #include <memory>
3  #include <string>
4  #include "gmock/gmock.h"
5  #include "gtest/gtest.h"
6  #include "absl/flags/declare.h"
7  #include "absl/flags/flag.h"
8  #include "absl/flags/internal/commandlineflag.h"
9  #include "absl/flags/marshalling.h"
10  #include "absl/memory/memory.h"
11  #include "absl/strings/str_cat.h"
12  #include "absl/strings/str_split.h"
13  ABSL_FLAG(int, int_flag, 1, "int_flag help");
14  ABSL_FLAG(std::string, string_flag, "dflt", "string_flag help");
15  ABSL_RETIRED_FLAG(bool, bool_retired_flag, false, "bool_retired_flag help");
16  namespace {
17  class ReflectionTest : public testing::Test {
18   protected:
19    void SetUp() override { flag_saver_ = absl::make_unique<absl::FlagSaver>(); }
20    void TearDown() override { flag_saver_.reset(); }
21   private:
22    std::unique_ptr<absl::FlagSaver> flag_saver_;
23  };
24  TEST_F(ReflectionTest, TestFindCommandLineFlag) {
25    auto* handle = absl::FindCommandLineFlag("some_flag");
26    EXPECT_EQ(handle, nullptr);
27    handle = absl::FindCommandLineFlag("int_flag");
28    EXPECT_NE(handle, nullptr);
<span onclick='openModal()' class='match'>29    handle = absl::FindCommandLineFlag("string_flag");
30    EXPECT_NE(handle, nullptr);
31    handle = absl::FindCommandLineFlag("bool_retired_flag");
</span>32    EXPECT_NE(handle, nullptr);
33  }
34  TEST_F(ReflectionTest, TestGetAllFlags) {
35    auto all_flags = absl::GetAllFlags();
36    EXPECT_NE(all_flags.find("int_flag"), all_flags.end());
37    EXPECT_EQ(all_flags.find("bool_retired_flag"), all_flags.end());
38    EXPECT_EQ(all_flags.find("some_undefined_flag"), all_flags.end());
39    std::vector<absl::string_view> flag_names_first_attempt;
40    auto all_flags_1 = absl::GetAllFlags();
41    for (auto f : all_flags_1) {
42      flag_names_first_attempt.push_back(f.first);
43    }
44    std::vector<absl::string_view> flag_names_second_attempt;
45    auto all_flags_2 = absl::GetAllFlags();
46    for (auto f : all_flags_2) {
47      flag_names_second_attempt.push_back(f.first);
48    }
49    EXPECT_THAT(flag_names_first_attempt,
50                ::testing::UnorderedElementsAreArray(flag_names_second_attempt));
51  }
52  struct CustomUDT {
53    CustomUDT() : a(1), b(1) {}
54    CustomUDT(int a_, int b_) : a(a_), b(b_) {}
55    friend bool operator==(const CustomUDT& f1, const CustomUDT& f2) {
56      return f1.a == f2.a && f1.b == f2.b;
57    }
58    int a;
59    int b;
60  };
61  bool AbslParseFlag(absl::string_view in, CustomUDT* f, std::string*) {
62    std::vector<absl::string_view> parts =
63        absl::StrSplit(in, ':', absl::SkipWhitespace());
64    if (parts.size() != 2) return false;
65    if (!absl::SimpleAtoi(parts[0], &f->a)) return false;
66    if (!absl::SimpleAtoi(parts[1], &f->b)) return false;
67    return true;
68  }
69  std::string AbslUnparseFlag(const CustomUDT& f) {
70    return absl::StrCat(f.a, ":", f.b);
71  }
72  }  
73  ABSL_FLAG(bool, test_flag_01, true, "");
74  ABSL_FLAG(int, test_flag_02, 1234, "");
75  ABSL_FLAG(int16_t, test_flag_03, -34, "");
76  ABSL_FLAG(uint16_t, test_flag_04, 189, "");
77  ABSL_FLAG(int32_t, test_flag_05, 10765, "");
78  ABSL_FLAG(uint32_t, test_flag_06, 40000, "");
79  ABSL_FLAG(int64_t, test_flag_07, -1234567, "");
80  ABSL_FLAG(uint64_t, test_flag_08, 9876543, "");
81  ABSL_FLAG(double, test_flag_09, -9.876e-50, "");
82  ABSL_FLAG(float, test_flag_10, 1.234e12f, "");
83  ABSL_FLAG(std::string, test_flag_11, "", "");
84  ABSL_FLAG(absl::Duration, test_flag_12, absl::Minutes(10), "");
85  static int counter = 0;
86  ABSL_FLAG(int, test_flag_13, 200, "").OnUpdate([]() { counter++; });
87  ABSL_FLAG(CustomUDT, test_flag_14, {}, "");
88  namespace {
89  TEST_F(ReflectionTest, TestFlagSaverInScope) {
90    {
91      absl::FlagSaver s;
92      counter = 0;
93      absl::SetFlag(&FLAGS_test_flag_01, false);
94      absl::SetFlag(&FLAGS_test_flag_02, -1021);
95      absl::SetFlag(&FLAGS_test_flag_03, 6009);
96      absl::SetFlag(&FLAGS_test_flag_04, 44);
97      absl::SetFlag(&FLAGS_test_flag_05, +800);
98      absl::SetFlag(&FLAGS_test_flag_06, -40978756);
99      absl::SetFlag(&FLAGS_test_flag_07, 23405);
100      absl::SetFlag(&FLAGS_test_flag_08, 975310);
101      absl::SetFlag(&FLAGS_test_flag_09, 1.00001);
102      absl::SetFlag(&FLAGS_test_flag_10, -3.54f);
103      absl::SetFlag(&FLAGS_test_flag_11, "asdf");
104      absl::SetFlag(&FLAGS_test_flag_12, absl::Hours(20));
105      absl::SetFlag(&FLAGS_test_flag_13, 4);
106      absl::SetFlag(&FLAGS_test_flag_14, CustomUDT{-1, -2});
107    }
108    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_01), true);
109    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_02), 1234);
110    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_03), -34);
111    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_04), 189);
112    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_05), 10765);
113    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_06), 40000);
114    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_07), -1234567);
115    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_08), 9876543);
116    EXPECT_NEAR(absl::GetFlag(FLAGS_test_flag_09), -9.876e-50, 1e-55);
117    EXPECT_NEAR(absl::GetFlag(FLAGS_test_flag_10), 1.234e12f, 1e5f);
118    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_11), "");
119    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_12), absl::Minutes(10));
120    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_13), 200);
121    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_14), CustomUDT{});
122    EXPECT_EQ(counter, 2);
123  }
124  TEST_F(ReflectionTest, TestFlagSaverVsUpdateViaReflection) {
125    {
126      absl::FlagSaver s;
127      counter = 0;
128      std::string error;
129      EXPECT_TRUE(
130          absl::FindCommandLineFlag("test_flag_01")->ParseFrom("false", &error))
131          << error;
132      EXPECT_TRUE(
133          absl::FindCommandLineFlag("test_flag_02")->ParseFrom("-4536", &error))
134          << error;
135      EXPECT_TRUE(
136          absl::FindCommandLineFlag("test_flag_03")->ParseFrom("111", &error))
137          << error;
138      EXPECT_TRUE(
139          absl::FindCommandLineFlag("test_flag_04")->ParseFrom("909", &error))
140          << error;
141      EXPECT_TRUE(
142          absl::FindCommandLineFlag("test_flag_05")->ParseFrom("-2004", &error))
143          << error;
144      EXPECT_TRUE(
145          absl::FindCommandLineFlag("test_flag_06")->ParseFrom("1000023", &error))
146          << error;
147      EXPECT_TRUE(
148          absl::FindCommandLineFlag("test_flag_07")->ParseFrom("69305", &error))
149          << error;
150      EXPECT_TRUE(absl::FindCommandLineFlag("test_flag_08")
151                      ->ParseFrom("1000000001", &error))
152          << error;
153      EXPECT_TRUE(
154          absl::FindCommandLineFlag("test_flag_09")->ParseFrom("2.09021", &error))
155          << error;
156      EXPECT_TRUE(
157          absl::FindCommandLineFlag("test_flag_10")->ParseFrom("-33.1", &error))
158          << error;
159      EXPECT_TRUE(
160          absl::FindCommandLineFlag("test_flag_11")->ParseFrom("ADD_FOO", &error))
161          << error;
162      EXPECT_TRUE(absl::FindCommandLineFlag("test_flag_12")
163                      ->ParseFrom("3h11m16s", &error))
164          << error;
165      EXPECT_TRUE(
166          absl::FindCommandLineFlag("test_flag_13")->ParseFrom("0", &error))
167          << error;
168      EXPECT_TRUE(
169          absl::FindCommandLineFlag("test_flag_14")->ParseFrom("10:1", &error))
170          << error;
171    }
172    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_01), true);
173    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_02), 1234);
174    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_03), -34);
175    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_04), 189);
176    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_05), 10765);
177    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_06), 40000);
178    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_07), -1234567);
179    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_08), 9876543);
180    EXPECT_NEAR(absl::GetFlag(FLAGS_test_flag_09), -9.876e-50, 1e-55);
181    EXPECT_NEAR(absl::GetFlag(FLAGS_test_flag_10), 1.234e12f, 1e5f);
182    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_11), "");
183    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_12), absl::Minutes(10));
184    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_13), 200);
185    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_14), CustomUDT{});
186    EXPECT_EQ(counter, 2);
187  }
188  TEST_F(ReflectionTest, TestMultipleFlagSaversInEnclosedScopes) {
189    {
190      absl::FlagSaver s;
191      absl::SetFlag(&FLAGS_test_flag_08, 10);
192      EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_08), 10);
193      {
194        absl::FlagSaver s;
195        absl::SetFlag(&FLAGS_test_flag_08, 20);
196        EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_08), 20);
197        {
198          absl::FlagSaver s;
199          absl::SetFlag(&FLAGS_test_flag_08, -200);
200          EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_08), -200);
201        }
202        EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_08), 20);
203      }
204      EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_08), 10);
205    }
206    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_08), 9876543);
207  }
208  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-reflection_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-reflection_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>27    handle = absl::FindCommandLineFlag("int_flag");
28    EXPECT_NE(handle, nullptr);
29    handle = absl::FindCommandLineFlag("string_flag");
</pre></code></div>
                <div class="column column_space"><pre><code>29    handle = absl::FindCommandLineFlag("string_flag");
30    EXPECT_NE(handle, nullptr);
31    handle = absl::FindCommandLineFlag("bool_retired_flag");
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    