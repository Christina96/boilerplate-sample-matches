
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 1.3724742661075104%, Tokens: 9</h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cord_ring_test.cc</h3>
            <pre><code>1  #include <cstdlib>
2  #include <ctime>
3  #include <memory>
4  #include <random>
5  #include <sstream>
6  #include "gmock/gmock.h"
7  #include "gtest/gtest.h"
8  #include "absl/base/config.h"
9  #include "absl/base/internal/raw_logging.h"
10  #include "absl/base/macros.h"
11  #include "absl/debugging/leak_check.h"
12  #include "absl/strings/internal/cord_internal.h"
13  #include "absl/strings/internal/cord_rep_ring.h"
14  #include "absl/strings/str_cat.h"
15  #include "absl/strings/string_view.h"
16  extern thread_local bool cord_ring;
17  namespace absl {
18  ABSL_NAMESPACE_BEGIN
19  namespace {
20  using RandomEngine = std::mt19937_64;
21  using ::absl::cord_internal::CordRep;
22  using ::absl::cord_internal::CordRepConcat;
23  using ::absl::cord_internal::CordRepExternal;
24  using ::absl::cord_internal::CordRepFlat;
25  using ::absl::cord_internal::CordRepRing;
26  using ::absl::cord_internal::CordRepSubstring;
27  using ::absl::cord_internal::EXTERNAL;
28  using ::absl::cord_internal::SUBSTRING;
29  using testing::ElementsAre;
30  using testing::ElementsAreArray;
31  using testing::Eq;
32  using testing::Ge;
33  using testing::Le;
34  using testing::Lt;
35  using testing::Ne;
36  using testing::SizeIs;
37  using index_type = CordRepRing::index_type;
38  enum InputShareMode { kPrivate, kShared, kSharedIndirect };
39  struct TestParam {
40    TestParam() = default;
41    explicit TestParam(InputShareMode input_share_mode)
42        : input_share_mode(input_share_mode) {}
43    bool refcount_is_one = true;
44    bool with_capacity = true;
45    InputShareMode input_share_mode = kPrivate;
46    std::string ToString() const {
47      return absl::StrCat(refcount_is_one ? "Private" : "Shared",
48                          with_capacity ? "" : "_NoCapacity",
49                          (input_share_mode == kPrivate) ? ""
50                          : (input_share_mode == kShared)
51                              ? "_SharedInput"
52                              : "_IndirectSharedInput");
53    }
54  };
55  using TestParams = std::vector<TestParam>;
56  MATCHER_P2(EqIfPrivate, param, rep,
57             absl::StrCat("Equal 0x", absl::Hex(rep), " if private")) {
58    return param.refcount_is_one ? arg == rep : true;
59  }
60  MATCHER_P2(EqIfPrivateAndCapacity, param, rep,
61             absl::StrCat("Equal 0x", absl::Hex(rep),
62                          " if private and capacity")) {
63    return (param.refcount_is_one && param.with_capacity) ? arg == rep : true;
64  }
65  MATCHER_P2(NeIfShared, param, rep,
66             absl::StrCat("Not equal 0x", absl::Hex(rep), " if shared")) {
67    return param.refcount_is_one ? true : arg != rep;
68  }
69  MATCHER_P2(EqIfInputPrivate, param, rep, "Equal if input is private") {
70    return param.input_share_mode == kPrivate ? arg == rep : arg != rep;
71  }
72  MATCHER(IsValidRingBuffer, "RingBuffer is valid") {
73    std::stringstream ss;
74    if (!arg->IsValid(ss)) {
75      *result_listener << "\nERROR: " << ss.str() << "\nRING = " << *arg;
76      return false;
77    }
78    return true;
79  }
80  std::vector<string_view> ToFlats(const CordRepRing* r) {
81    std::vector<string_view> flats;
82    flats.reserve(r->entries());
83    index_type pos = r->head();
84    do {
85      flats.push_back(r->entry_data(pos));
86    } while ((pos = r->advance(pos)) != r->tail());
87    return flats;
88  }
89  class not_a_string_view {
90   public:
91    explicit not_a_string_view(absl::string_view s)
92        : data_(s.data()), size_(s.size()) {}
93    explicit not_a_string_view(const void* data, size_t size)
94        : data_(data), size_(size) {}
95    not_a_string_view remove_prefix(size_t n) const {
96      return not_a_string_view(static_cast<const char*>(data_) + n, size_ - n);
97    }
98    not_a_string_view remove_suffix(size_t n) const {
99      return not_a_string_view(data_, size_ - n);
100    }
101    const void* data() const { return data_; }
102    size_t size() const { return size_; }
103   private:
104    const void* data_;
105    size_t size_;
106  };
107  bool operator==(not_a_string_view lhs, not_a_string_view rhs) {
108    return lhs.data() == rhs.data() && lhs.size() == rhs.size();
109  }
110  std::ostream& operator<<(std::ostream& s, not_a_string_view rhs) {
111    return s << "{ data: " << rhs.data() << " size: " << rhs.size() << "}";
112  }
113  std::vector<not_a_string_view> ToRawFlats(const CordRepRing* r) {
114    std::vector<not_a_string_view> flats;
115    flats.reserve(r->entries());
116    index_type pos = r->head();
117    do {
118      flats.emplace_back(r->entry_data(pos));
119    } while ((pos = r->advance(pos)) != r->tail());
120    return flats;
121  }
122  std::string ToString(const CordRepRing* r) {
123    std::string value;
124    value.reserve(r->length);
125    index_type pos = r->head();
126    do {
127      absl::string_view sv = r->entry_data(pos);
128      value.append(sv.data(), sv.size());
129    } while ((pos = r->advance(pos)) != r->tail());
130    return value;
131  }
132  CordRep* MakeFlat(absl::string_view s, size_t extra = 0) {
133    CordRepFlat* flat = CordRepFlat::New(s.length() + extra);
134    memcpy(flat->Data(), s.data(), s.length());
135    flat->length = s.length();
136    return flat;
137  }
138  CordRepExternal* MakeExternal(absl::string_view s) {
139    struct Rep : public CordRepExternal {
140      std::string s;
141      explicit Rep(absl::string_view s) : s(s) {
142        this->tag = EXTERNAL;
143        this->base = s.data();
144        this->length = s.length();
145        this->releaser_invoker = [](CordRepExternal* self) {
146          delete static_cast<Rep*>(self);
147        };
148      }
149    };
150    return new Rep(s);
151  }
152  CordRepExternal* MakeFakeExternal(size_t length) {
153    struct Rep : public CordRepExternal {
154      std::string s;
155      explicit Rep(size_t len) {
156        this->tag = EXTERNAL;
157        this->base = reinterpret_cast<const char*>(this->storage);
158        this->length = len;
159        this->releaser_invoker = [](CordRepExternal* self) {
160          delete static_cast<Rep*>(self);
161        };
162      }
163    };
164    return new Rep(length);
165  }
166  CordRep* MakeLeaf(absl::string_view s, size_t extra = 0) {
167    if (s.size() <= absl::cord_internal::kMaxFlatLength) {
168      return MakeFlat(s, extra);
169    } else {
170      return MakeExternal(s);
171    }
172  }
173  CordRepSubstring* MakeSubstring(size_t start, size_t len, CordRep* rep) {
174    auto* sub = new CordRepSubstring;
175    sub->tag = SUBSTRING;
176    sub->start = start;
177    sub->length = (len <= 0) ? rep->length - start + len : len;
178    sub->child = rep;
179    return sub;
180  }
181  CordRepSubstring* RemovePrefix(size_t start, CordRep* rep) {
182    return MakeSubstring(start, rep->length - start, rep);
183  }
184  CordRepSubstring* RemoveSuffix(size_t length, CordRep* rep) {
185    return MakeSubstring(0, rep->length - length, rep);
186  }
187  enum Composition { kMix, kAppend, kPrepend };
188  Composition RandomComposition() {
189    RandomEngine rng(GTEST_FLAG_GET(random_seed));
190    return (rng() & 1) ? kMix : ((rng() & 1) ? kAppend : kPrepend);
191  }
192  absl::string_view ToString(Composition composition) {
193    switch (composition) {
194      case kAppend:
195        return "Append";
196      case kPrepend:
197        return "Prepend";
198      case kMix:
199        return "Mix";
200    }
201    assert(false);
202    return "???";
203  }
204  constexpr const char* kFox = "The quick brown fox jumps over the lazy dog";
205  constexpr const char* kFoxFlats[] = {"The ", "quick ", "brown ",
206                                       "fox ", "jumps ", "over ",
207                                       "the ", "lazy ",  "dog"};
208  CordRepRing* FromFlats(Span<const char* const> flats,
209                         Composition composition = kAppend) {
210    if (flats.empty()) return nullptr;
211    CordRepRing* ring = nullptr;
212    switch (composition) {
213      case kAppend:
214        ring = CordRepRing::Create(MakeLeaf(flats.front()), flats.size() - 1);
215        for (int i = 1; i < flats.size(); ++i) {
216          ring = CordRepRing::Append(ring, MakeLeaf(flats[i]));
217        }
218        break;
219      case kPrepend:
220        ring = CordRepRing::Create(MakeLeaf(flats.back()), flats.size() - 1);
221        for (int i = static_cast<int>(flats.size() - 2); i >= 0; --i) {
222          ring = CordRepRing::Prepend(ring, MakeLeaf(flats[i]));
223        }
224        break;
225      case kMix:
226        size_t middle1 = flats.size() / 2, middle2 = middle1;
227        ring = CordRepRing::Create(MakeLeaf(flats[middle1]), flats.size() - 1);
228        if (!flats.empty()) {
229          if ((flats.size() & 1) == 0) {
230            ring = CordRepRing::Prepend(ring, MakeLeaf(flats[--middle1]));
231          }
232          for (int i = 1; i <= middle1; ++i) {
233            ring = CordRepRing::Prepend(ring, MakeLeaf(flats[middle1 - i]));
234            ring = CordRepRing::Append(ring, MakeLeaf(flats[middle2 + i]));
235          }
236        }
237        break;
238    }
239    EXPECT_THAT(ToFlats(ring), ElementsAreArray(flats));
240    return ring;
241  }
242  std::ostream& operator<<(std::ostream& s, const TestParam& param) {
243    return s << param.ToString();
244  }
245  std::string TestParamToString(const testing::TestParamInfo<TestParam>& info) {
246    return info.param.ToString();
247  }
248  class CordRingTest : public testing::Test {
249   public:
250    ~CordRingTest() override {
251      for (CordRep* rep : unrefs_) {
252        CordRep::Unref(rep);
253      }
254    }
255    template <typename CordRepType>
256    CordRepType* NeedsUnref(CordRepType* rep) {
257      assert(rep);
258      unrefs_.push_back(rep);
259      return rep;
260    }
261    template <typename CordRepType>
262    CordRepType* Ref(CordRepType* rep) {
263      CordRep::Ref(rep);
264      return NeedsUnref(rep);
265    }
266   private:
267    std::vector<CordRep*> unrefs_;
268  };
269  class CordRingTestWithParam : public testing::TestWithParam<TestParam> {
270   public:
271    ~CordRingTestWithParam() override {
272      for (CordRep* rep : unrefs_) {
273        CordRep::Unref(rep);
274      }
275    }
276    CordRepRing* CreateWithCapacity(CordRep* child, size_t extra_capacity) {
277      if (!GetParam().with_capacity) extra_capacity = 0;
278      CordRepRing* ring = CordRepRing::Create(child, extra_capacity);
279      ring->SetCapacityForTesting(1 + extra_capacity);
280      return RefIfShared(ring);
281    }
282    bool Shared() const { return !GetParam().refcount_is_one; }
283    bool InputShared() const { return GetParam().input_share_mode == kShared; }
284    bool InputSharedIndirect() const {
285      return GetParam().input_share_mode == kSharedIndirect;
286    }
287    template <typename CordRepType>
288    CordRepType* NeedsUnref(CordRepType* rep) {
289      assert(rep);
290      unrefs_.push_back(rep);
291      return rep;
292    }
293    template <typename CordRepType>
294    CordRepType* Ref(CordRepType* rep) {
295      CordRep::Ref(rep);
296      return NeedsUnref(rep);
297    }
298    template <typename CordRepType>
299    CordRepType* RefIfShared(CordRepType* rep) {
300      return Shared() ? Ref(rep) : rep;
301    }
302    template <typename CordRepType>
303    CordRepType* RefIfInputShared(CordRepType* rep) {
304      return InputShared() ? Ref(rep) : rep;
305    }
306    template <typename CordRepType>
307    CordRepType* RefIfInputSharedIndirect(CordRepType* rep) {
308      return InputSharedIndirect() ? Ref(rep) : rep;
309    }
310   private:
311    std::vector<CordRep*> unrefs_;
312  };
313  class CordRingCreateTest : public CordRingTestWithParam {
314   public:
315    static TestParams CreateTestParams() {
316      TestParams params;
317      params.emplace_back(InputShareMode::kPrivate);
318      params.emplace_back(InputShareMode::kShared);
319      return params;
320    }
321  };
322  class CordRingSubTest : public CordRingTestWithParam {
323   public:
324    static TestParams CreateTestParams() {
325      TestParams params;
326      for (bool refcount_is_one : {true, false}) {
327        TestParam param;
328        param.refcount_is_one = refcount_is_one;
329        params.push_back(param);
330      }
331      return params;
332    }
333  };
334  class CordRingBuildTest : public CordRingTestWithParam {
335   public:
336    static TestParams CreateTestParams() {
337      TestParams params;
338      for (bool refcount_is_one : {true, false}) {
339        for (bool with_capacity : {true, false}) {
340          TestParam param;
341          param.refcount_is_one = refcount_is_one;
342          param.with_capacity = with_capacity;
343          params.push_back(param);
344        }
345      }
346      return params;
347    }
348  };
349  class CordRingCreateFromTreeTest : public CordRingTestWithParam {
350   public:
351    static TestParams CreateTestParams() {
352      TestParams params;
353      params.emplace_back(InputShareMode::kPrivate);
354      params.emplace_back(InputShareMode::kShared);
355      params.emplace_back(InputShareMode::kSharedIndirect);
356      return params;
357    }
358  };
359  class CordRingBuildInputTest : public CordRingTestWithParam {
360   public:
361    static TestParams CreateTestParams() {
362      TestParams params;
363      for (bool refcount_is_one : {true, false}) {
364        for (bool with_capacity : {true, false}) {
365          for (InputShareMode share_mode : {kPrivate, kShared, kSharedIndirect}) {
366            TestParam param;
367            param.refcount_is_one = refcount_is_one;
368            param.with_capacity = with_capacity;
369            param.input_share_mode = share_mode;
370            params.push_back(param);
371          }
372        }
373      }
374      return params;
375    }
376  };
377  INSTANTIATE_TEST_SUITE_P(WithParam, CordRingSubTest,
378                           testing::ValuesIn(CordRingSubTest::CreateTestParams()),
379                           TestParamToString);
380  INSTANTIATE_TEST_SUITE_P(
381      WithParam, CordRingCreateTest,
382      testing::ValuesIn(CordRingCreateTest::CreateTestParams()),
383      TestParamToString);
384  INSTANTIATE_TEST_SUITE_P(
385      WithParam, CordRingCreateFromTreeTest,
386      testing::ValuesIn(CordRingCreateFromTreeTest::CreateTestParams()),
387      TestParamToString);
388  INSTANTIATE_TEST_SUITE_P(
389      WithParam, CordRingBuildTest,
390      testing::ValuesIn(CordRingBuildTest::CreateTestParams()),
391      TestParamToString);
392  INSTANTIATE_TEST_SUITE_P(
393      WithParam, CordRingBuildInputTest,
394      testing::ValuesIn(CordRingBuildInputTest::CreateTestParams()),
395      TestParamToString);
396  TEST_P(CordRingCreateTest, CreateFromFlat) {
397    absl::string_view str1 = "abcdefghijklmnopqrstuvwxyz";
398    CordRepRing* result = NeedsUnref(CordRepRing::Create(MakeFlat(str1)));
399    ASSERT_THAT(result, IsValidRingBuffer());
400    EXPECT_THAT(result->length, Eq(str1.size()));
401    EXPECT_THAT(ToFlats(result), ElementsAre(str1));
402  }
403  TEST_P(CordRingCreateTest, CreateFromRing) {
404    CordRepRing* ring = RefIfShared(FromFlats(kFoxFlats));
405    CordRepRing* result = NeedsUnref(CordRepRing::Create(ring));
406    ASSERT_THAT(result, IsValidRingBuffer());
407    EXPECT_THAT(result, EqIfPrivate(GetParam(), ring));
408    EXPECT_THAT(result, NeIfShared(GetParam(), ring));
409    EXPECT_THAT(ToFlats(result), ElementsAreArray(kFoxFlats));
410  }
411  TEST_P(CordRingCreateFromTreeTest, CreateFromSubstringRing) {
412    CordRepRing* ring = RefIfInputSharedIndirect(FromFlats(kFoxFlats));
413    CordRep* sub = RefIfInputShared(MakeSubstring(2, 11, ring));
414    CordRepRing* result = NeedsUnref(CordRepRing::Create(sub));
415    ASSERT_THAT(result, IsValidRingBuffer());
416    EXPECT_THAT(result, EqIfInputPrivate(GetParam(), ring));
417    EXPECT_THAT(ToString(result), string_view(kFox).substr(2, 11));
418  }
419  TEST_F(CordRingTest, CreateWithIllegalExtraCapacity) {
420  #if defined(ABSL_HAVE_EXCEPTIONS)
421    CordRep* flat = NeedsUnref(MakeFlat("Hello world"));
422    try {
423      CordRepRing::Create(flat, CordRepRing::kMaxCapacity);
424      GTEST_FAIL() << "expected std::length_error exception";
425    } catch (const std::length_error&) {
426    }
427  #elif defined(GTEST_HAS_DEATH_TEST)
428    CordRep* flat = NeedsUnref(MakeFlat("Hello world"));
429    EXPECT_DEATH(CordRepRing::Create(flat, CordRepRing::kMaxCapacity), ".*");
430  #endif
431  }
432  TEST_P(CordRingCreateFromTreeTest, CreateFromSubstringOfFlat) {
433    absl::string_view str1 = "abcdefghijklmnopqrstuvwxyz";
434    auto* flat = RefIfInputShared(MakeFlat(str1));
435    auto* child = RefIfInputSharedIndirect(MakeSubstring(4, 20, flat));
436    CordRepRing* result = NeedsUnref(CordRepRing::Create(child));
437    ASSERT_THAT(result, IsValidRingBuffer());
438    EXPECT_THAT(result->length, Eq(20));
439    EXPECT_THAT(ToFlats(result), ElementsAre(str1.substr(4, 20)));
440  }
441  TEST_P(CordRingCreateTest, CreateFromExternal) {
442    absl::string_view str1 = "abcdefghijklmnopqrstuvwxyz";
443    auto* child = RefIfInputShared(MakeExternal(str1));
444    CordRepRing* result = NeedsUnref(CordRepRing::Create(child));
445    ASSERT_THAT(result, IsValidRingBuffer());
446    EXPECT_THAT(result->length, Eq(str1.size()));
447    EXPECT_THAT(ToFlats(result), ElementsAre(str1));
448  }
449  TEST_P(CordRingCreateFromTreeTest, CreateFromSubstringOfExternal) {
450    absl::string_view str1 = "abcdefghijklmnopqrstuvwxyz";
451    auto* external = RefIfInputShared(MakeExternal(str1));
452    auto* child = RefIfInputSharedIndirect(MakeSubstring(1, 24, external));
453    CordRepRing* result = NeedsUnref(CordRepRing::Create(child));
454    ASSERT_THAT(result, IsValidRingBuffer());
455    EXPECT_THAT(result->length, Eq(24));
456    EXPECT_THAT(ToFlats(result), ElementsAre(str1.substr(1, 24)));
457  }
458  TEST_P(CordRingCreateFromTreeTest, CreateFromSubstringOfLargeExternal) {
459    auto* external = RefIfInputShared(MakeFakeExternal(1 << 20));
460    auto str = not_a_string_view(external->base, 1 << 20)
461                   .remove_prefix(1 << 19)
462                   .remove_suffix(6);
463    auto* child =
464        RefIfInputSharedIndirect(MakeSubstring(1 << 19, (1 << 19) - 6, external));
465    CordRepRing* result = NeedsUnref(CordRepRing::Create(child));
466    ASSERT_THAT(result, IsValidRingBuffer());
467    EXPECT_THAT(result->length, Eq(str.size()));
468    EXPECT_THAT(ToRawFlats(result), ElementsAre(str));
469  }
470  TEST_P(CordRingCreateTest, Properties) {
471    absl::string_view str1 = "abcdefghijklmnopqrstuvwxyz";
472    CordRepRing* result = NeedsUnref(CordRepRing::Create(MakeFlat(str1), 120));
473    ASSERT_THAT(result, IsValidRingBuffer());
474    EXPECT_THAT(result->head(), Eq(0));
475    EXPECT_THAT(result->tail(), Eq(1));
476    EXPECT_THAT(result->capacity(), Ge(120 + 1));
477    EXPECT_THAT(result->capacity(), Le(2 * 120 + 1));
478    EXPECT_THAT(result->entries(), Eq(1));
479    EXPECT_THAT(result->begin_pos(), Eq(0));
480  }
481  TEST_P(CordRingCreateTest, EntryForNewFlat) {
482    absl::string_view str1 = "abcdefghijklmnopqrstuvwxyz";
483    CordRep* child = MakeFlat(str1);
484    CordRepRing* result = NeedsUnref(CordRepRing::Create(child, 120));
485    ASSERT_THAT(result, IsValidRingBuffer());
486    EXPECT_THAT(result->entry_child(0), Eq(child));
487    EXPECT_THAT(result->entry_end_pos(0), Eq(str1.length()));
488    EXPECT_THAT(result->entry_data_offset(0), Eq(0));
489  }
490  TEST_P(CordRingCreateTest, EntryForNewFlatSubstring) {
491    absl::string_view str1 = "1234567890abcdefghijklmnopqrstuvwxyz";
492    CordRep* child = MakeFlat(str1);
493    CordRep* substring = MakeSubstring(10, 26, child);
494    CordRepRing* result = NeedsUnref(CordRepRing::Create(substring, 1));
495    ASSERT_THAT(result, IsValidRingBuffer());
496    EXPECT_THAT(result->entry_child(0), Eq(child));
497    EXPECT_THAT(result->entry_end_pos(0), Eq(26));
498    EXPECT_THAT(result->entry_data_offset(0), Eq(10));
499  }
500  TEST_P(CordRingBuildTest, AppendFlat) {
501    absl::string_view str1 = "abcdefghijklmnopqrstuvwxyz";
502    absl::string_view str2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
503    CordRepRing* ring = CreateWithCapacity(MakeExternal(str1), 1);
504    CordRepRing* result = NeedsUnref(CordRepRing::Append(ring, MakeFlat(str2)));
505    ASSERT_THAT(result, IsValidRingBuffer());
506    EXPECT_THAT(result, EqIfPrivateAndCapacity(GetParam(), ring));
507    EXPECT_THAT(result, NeIfShared(GetParam(), ring));
508    EXPECT_THAT(result->length, Eq(str1.size() + str2.size()));
509    EXPECT_THAT(ToFlats(result), ElementsAre(str1, str2));
510  }
511  TEST_P(CordRingBuildTest, PrependFlat) {
512    absl::string_view str1 = "abcdefghijklmnopqrstuvwxyz";
513    absl::string_view str2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
514    CordRepRing* ring = CreateWithCapacity(MakeExternal(str1), 1);
515    CordRepRing* result = NeedsUnref(CordRepRing::Prepend(ring, MakeFlat(str2)));
516    ASSERT_THAT(result, IsValidRingBuffer());
517    EXPECT_THAT(result, EqIfPrivateAndCapacity(GetParam(), ring));
518    EXPECT_THAT(result, NeIfShared(GetParam(), ring));
519    EXPECT_THAT(result->length, Eq(str1.size() + str2.size()));
520    EXPECT_THAT(ToFlats(result), ElementsAre(str2, str1));
521  }
522  TEST_P(CordRingBuildTest, AppendString) {
523    absl::string_view str1 = "abcdefghijklmnopqrstuvwxyz";
524    absl::string_view str2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
525    CordRepRing* ring = CreateWithCapacity(MakeExternal(str1), 1);
526    CordRepRing* result = NeedsUnref(CordRepRing::Append(ring, str2));
527    ASSERT_THAT(result, IsValidRingBuffer());
528    EXPECT_THAT(result, EqIfPrivateAndCapacity(GetParam(), ring));
529    EXPECT_THAT(result, NeIfShared(GetParam(), ring));
530    EXPECT_THAT(result->length, Eq(str1.size() + str2.size()));
531    EXPECT_THAT(ToFlats(result), ElementsAre(str1, str2));
532  }
533  TEST_P(CordRingBuildTest, AppendStringHavingExtra) {
534    absl::string_view str1 = "1234";
535    absl::string_view str2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
536    CordRepRing* ring = CreateWithCapacity(MakeFlat(str1, 26), 0);
537    CordRepRing* result = NeedsUnref(CordRepRing::Append(ring, str2));
538    ASSERT_THAT(result, IsValidRingBuffer());
539    EXPECT_THAT(result->length, Eq(str1.size() + str2.size()));
540    EXPECT_THAT(result, EqIfPrivate(GetParam(), ring));
541    EXPECT_THAT(result, NeIfShared(GetParam(), ring));
542  }
543  TEST_P(CordRingBuildTest, AppendStringHavingPartialExtra) {
544    absl::string_view str1 = "1234";
545    absl::string_view str2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
546    auto* flat = MakeFlat(str1, 1);
547    size_t avail = flat->flat()->Capacity() - flat->length;
548    ASSERT_THAT(avail, Lt(str2.size())) << " adjust test for larger flats!";
549    absl::string_view str1a = str2.substr(0, avail);
550    absl::string_view str2a = str2.substr(avail);
551    CordRepRing* ring = CreateWithCapacity(flat, 1);
552    CordRepRing* result = NeedsUnref(CordRepRing::Append(ring, str2));
553    ASSERT_THAT(result, IsValidRingBuffer());
554    EXPECT_THAT(result->length, Eq(str1.size() + str2.size()));
555    EXPECT_THAT(result, EqIfPrivateAndCapacity(GetParam(), ring));
556    EXPECT_THAT(result, NeIfShared(GetParam(), ring));
557    if (GetParam().refcount_is_one) {
558      EXPECT_THAT(ToFlats(result), ElementsAre(StrCat(str1, str1a), str2a));
559    } else {
560      EXPECT_THAT(ToFlats(result), ElementsAre(str1, str2));
561    }
562  }
563  TEST_P(CordRingBuildTest, AppendStringHavingExtraInSubstring) {
564    absl::string_view str1 = "123456789_1234";
565    absl::string_view str2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
566    CordRep* flat = RemovePrefix(10, MakeFlat(str1, 26));
567    CordRepRing* ring = CreateWithCapacity(flat, 0);
568    CordRepRing* result = NeedsUnref(CordRepRing::Append(ring, str2));
569    ASSERT_THAT(result, IsValidRingBuffer());
570    EXPECT_THAT(result, EqIfPrivate(GetParam(), ring));
571    EXPECT_THAT(result, NeIfShared(GetParam(), ring));
572    EXPECT_THAT(result->length, Eq(4 + str2.size()));
573    if (GetParam().refcount_is_one) {
574      EXPECT_THAT(ToFlats(result), ElementsAre(StrCat("1234", str2)));
575    } else {
576      EXPECT_THAT(ToFlats(result), ElementsAre("1234", str2));
577    }
578  }
579  TEST_P(CordRingBuildTest, AppendStringHavingSharedExtra) {
580    absl::string_view str1 = "123456789_1234";
581    absl::string_view str2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
582    for (int shared_type = 0; shared_type < 2; ++shared_type) {
583      SCOPED_TRACE(absl::StrCat("Shared extra type ", shared_type));
584      CordRep* flat = nullptr;
585      CordRep* flat1 = nullptr;
<span onclick='openModal()' class='match'>586      if (shared_type == 0) {
587        flat = CordRep::Ref(MakeFlat(str1.substr(10), 100));
588      } else if (shared_type == 1) {
589        flat1 = CordRep::Ref(MakeFlat(str1));
590        flat = RemovePrefix(10, flat1);
</span>591      } else {
592        flat = CordRep::Ref(RemovePrefix(10, MakeFlat(str1, 100)));
593      }
594      CordRepRing* ring = CreateWithCapacity(flat, 1);
595      CordRepRing* result = NeedsUnref(CordRepRing::Append(ring, str2));
596      ASSERT_THAT(result, IsValidRingBuffer());
597      EXPECT_THAT(result, EqIfPrivateAndCapacity(GetParam(), ring));
598      EXPECT_THAT(result, NeIfShared(GetParam(), ring));
599      EXPECT_THAT(result->length, Eq(4 + str2.size()));
600      EXPECT_THAT(ToFlats(result), ElementsAre("1234", str2));
601      CordRep::Unref(shared_type == 1 ? flat1 : flat);
602    }
603  }
604  TEST_P(CordRingBuildTest, AppendStringWithExtra) {
605    absl::string_view str1 = "1234";
606    absl::string_view str2 = "1234567890";
607    absl::string_view str3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
608    CordRepRing* ring = CreateWithCapacity(MakeExternal(str1), 1);
609    CordRepRing* result = NeedsUnref(CordRepRing::Append(ring, str2, 26));
610    result = CordRepRing::Append(result, str3);
611    ASSERT_THAT(result, IsValidRingBuffer());
612    EXPECT_THAT(result->length, Eq(str1.size() + str2.size() + str3.size()));
613    EXPECT_THAT(result, EqIfPrivateAndCapacity(GetParam(), ring));
614    EXPECT_THAT(ToFlats(result), ElementsAre(str1, StrCat(str2, str3)));
615  }
616  TEST_P(CordRingBuildTest, PrependString) {
617    absl::string_view str1 = "abcdefghijklmnopqrstuvwxyz";
618    absl::string_view str2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
619    CordRepRing* ring = CreateWithCapacity(MakeExternal(str1), 1);
620    CordRepRing* result = NeedsUnref(CordRepRing::Prepend(ring, str2));
621    ASSERT_THAT(result, IsValidRingBuffer());
622    if (GetParam().with_capacity && GetParam().refcount_is_one) {
623      EXPECT_THAT(result, Eq(ring));
624    } else {
625      EXPECT_THAT(result, Ne(ring));
626    }
627    EXPECT_THAT(result->length, Eq(str1.size() + str2.size()));
628    EXPECT_THAT(ToFlats(result), ElementsAre(str2, str1));
629  }
630  TEST_P(CordRingBuildTest, PrependStringHavingExtra) {
631    absl::string_view str1 = "abcdefghijklmnopqrstuvwxyz1234";
632    absl::string_view str2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
633    CordRep* flat = RemovePrefix(26, MakeFlat(str1));
634    CordRepRing* ring = CreateWithCapacity(flat, 0);
635    CordRepRing* result = NeedsUnref(CordRepRing::Prepend(ring, str2));
636    ASSERT_THAT(result, IsValidRingBuffer());
637    EXPECT_THAT(result, EqIfPrivate(GetParam(), ring));
638    EXPECT_THAT(result, NeIfShared(GetParam(), ring));
639    EXPECT_THAT(result->length, Eq(4 + str2.size()));
640    if (GetParam().refcount_is_one) {
641      EXPECT_THAT(ToFlats(result), ElementsAre(StrCat(str2, "1234")));
642    } else {
643      EXPECT_THAT(ToFlats(result), ElementsAre(str2, "1234"));
644    }
645  }
646  TEST_P(CordRingBuildTest, PrependStringHavingSharedExtra) {
647    absl::string_view str1 = "123456789_ABCDEFGHIJKLMNOPQRSTUVWXYZ";
648    absl::string_view str2 = "abcdefghij";
649    absl::string_view str1a = str1.substr(10);
650    for (int shared_type = 1; shared_type < 2; ++shared_type) {
651      SCOPED_TRACE(absl::StrCat("Shared extra type ", shared_type));
652      CordRep* flat = nullptr;
653      CordRep* flat1 = nullptr;
654      if (shared_type == 1) {
655        flat = RemovePrefix(10, flat1 = CordRep::Ref(MakeFlat(str1)));
656      } else {
657        flat = CordRep::Ref(RemovePrefix(10, MakeFlat(str1, 100)));
658      }
659      CordRepRing* ring = CreateWithCapacity(flat, 1);
660      CordRepRing* result = NeedsUnref(CordRepRing::Prepend(ring, str2));
661      ASSERT_THAT(result, IsValidRingBuffer());
662      EXPECT_THAT(result->length, Eq(str1a.size() + str2.size()));
663      EXPECT_THAT(result, EqIfPrivateAndCapacity(GetParam(), ring));
664      EXPECT_THAT(result, NeIfShared(GetParam(), ring));
665      EXPECT_THAT(ToFlats(result), ElementsAre(str2, str1a));
666      CordRep::Unref(shared_type == 1 ? flat1 : flat);
667    }
668  }
669  TEST_P(CordRingBuildTest, PrependStringWithExtra) {
670    absl::string_view str1 = "1234";
671    absl::string_view str2 = "1234567890";
672    absl::string_view str3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
673    CordRepRing* ring = CreateWithCapacity(MakeExternal(str1), 1);
674    CordRepRing* result = NeedsUnref(CordRepRing::Prepend(ring, str2, 26));
675    ASSERT_THAT(result, IsValidRingBuffer());
676    result = CordRepRing::Prepend(result, str3);
677    EXPECT_THAT(result->length, Eq(str1.size() + str2.size() + str3.size()));
678    EXPECT_THAT(result, EqIfPrivateAndCapacity(GetParam(), ring));
679    EXPECT_THAT(ToFlats(result), ElementsAre(StrCat(str3, str2), str1));
680  }
681  TEST_P(CordRingBuildTest, AppendPrependStringMix) {
682    const auto& flats = kFoxFlats;
683    CordRepRing* ring = CreateWithCapacity(MakeFlat(flats[4]), 8);
684    CordRepRing* result = ring;
685    for (int i = 1; i <= 4; ++i) {
686      result = CordRepRing::Prepend(result, flats[4 - i]);
687      result = CordRepRing::Append(result, flats[4 + i]);
688    }
689    NeedsUnref(result);
690    ASSERT_THAT(result, IsValidRingBuffer());
691    EXPECT_THAT(result, EqIfPrivateAndCapacity(GetParam(), ring));
692    EXPECT_THAT(ToString(result), kFox);
693  }
694  TEST_P(CordRingBuildTest, AppendPrependStringMixWithExtra) {
695    const auto& flats = kFoxFlats;
696    CordRepRing* ring = CreateWithCapacity(MakeFlat(flats[4], 100), 8);
697    CordRepRing* result = ring;
698    for (int i = 1; i <= 4; ++i) {
699      result = CordRepRing::Prepend(result, flats[4 - i], 100);
700      result = CordRepRing::Append(result, flats[4 + i], 100);
701    }
702    NeedsUnref(result);
703    ASSERT_THAT(result, IsValidRingBuffer());
704    EXPECT_THAT(result, EqIfPrivateAndCapacity(GetParam(), ring));
705    if (GetParam().refcount_is_one) {
706      EXPECT_THAT(ToFlats(result),
707                  ElementsAre("The quick brown fox ", "jumps over the lazy dog"));
708    } else {
709      EXPECT_THAT(ToFlats(result), ElementsAre("The quick brown fox ", "jumps ",
710                                               "over the lazy dog"));
711    }
712  }
713  TEST_P(CordRingBuildTest, AppendPrependStringMixWithPrependedExtra) {
714    const auto& flats = kFoxFlats;
715    CordRep* flat = MakeFlat(StrCat(std::string(50, '.'), flats[4]), 50);
716    CordRepRing* ring = CreateWithCapacity(RemovePrefix(50, flat), 0);
717    CordRepRing* result = ring;
718    for (int i = 1; i <= 4; ++i) {
719      result = CordRepRing::Prepend(result, flats[4 - i], 100);
720      result = CordRepRing::Append(result, flats[4 + i], 100);
721    }
722    result = NeedsUnref(result);
723    ASSERT_THAT(result, IsValidRingBuffer());
724    EXPECT_THAT(result, EqIfPrivate(GetParam(), ring));
725    if (GetParam().refcount_is_one) {
726      EXPECT_THAT(ToFlats(result), ElementsAre(kFox));
727    } else {
728      EXPECT_THAT(ToFlats(result), ElementsAre("The quick brown fox ", "jumps ",
729                                               "over the lazy dog"));
730    }
731  }
732  TEST_P(CordRingSubTest, SubRing) {
733    auto composition = RandomComposition();
734    SCOPED_TRACE(ToString(composition));
735    auto flats = MakeSpan(kFoxFlats);
736    string_view all = kFox;
737    for (size_t offset = 0; offset < all.size() - 1; ++offset) {
738      CordRepRing* ring = RefIfShared(FromFlats(flats, composition));
739      CordRepRing* result = CordRepRing::SubRing(ring, offset, 0);
740      EXPECT_THAT(result, nullptr);
741      for (size_t len = 1; len < all.size() - offset; ++len) {
742        ring = RefIfShared(FromFlats(flats, composition));
743        result = NeedsUnref(CordRepRing::SubRing(ring, offset, len));
744        ASSERT_THAT(result, IsValidRingBuffer());
745        ASSERT_THAT(result, EqIfPrivate(GetParam(), ring));
746        ASSERT_THAT(result, NeIfShared(GetParam(), ring));
747        ASSERT_THAT(ToString(result), Eq(all.substr(offset, len)));
748      }
749    }
750  }
751  TEST_P(CordRingSubTest, SubRingFromLargeExternal) {
752    auto composition = RandomComposition();
753    std::string large_string(1 << 20, '.');
754    const char* flats[] = {
755        "abcdefghijklmnopqrstuvwxyz",
756        large_string.c_str(),
757        "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
758    };
759    std::string buffer = absl::StrCat(flats[0], flats[1], flats[2]);
760    absl::string_view all = buffer;
761    for (size_t offset = 0; offset < 30; ++offset) {
762      CordRepRing* ring = RefIfShared(FromFlats(flats, composition));
763      CordRepRing* result = CordRepRing::SubRing(ring, offset, 0);
764      EXPECT_THAT(result, nullptr);
765      for (size_t len = all.size() - 30; len < all.size() - offset; ++len) {
766        ring = RefIfShared(FromFlats(flats, composition));
767        result = NeedsUnref(CordRepRing::SubRing(ring, offset, len));
768        ASSERT_THAT(result, IsValidRingBuffer());
769        ASSERT_THAT(result, EqIfPrivate(GetParam(), ring));
770        ASSERT_THAT(result, NeIfShared(GetParam(), ring));
771        auto str = ToString(result);
772        ASSERT_THAT(str, SizeIs(len));
773        ASSERT_THAT(str, Eq(all.substr(offset, len)));
774      }
775    }
776  }
777  TEST_P(CordRingSubTest, RemovePrefix) {
778    auto composition = RandomComposition();
779    SCOPED_TRACE(ToString(composition));
780    auto flats = MakeSpan(kFoxFlats);
781    string_view all = kFox;
782    CordRepRing* ring = RefIfShared(FromFlats(flats, composition));
783    CordRepRing* result = CordRepRing::RemovePrefix(ring, all.size());
784    EXPECT_THAT(result, nullptr);
785    for (size_t len = 1; len < all.size(); ++len) {
786      ring = RefIfShared(FromFlats(flats, composition));
787      result = NeedsUnref(CordRepRing::RemovePrefix(ring, len));
788      ASSERT_THAT(result, IsValidRingBuffer());
789      EXPECT_THAT(result, EqIfPrivate(GetParam(), ring));
790      ASSERT_THAT(result, NeIfShared(GetParam(), ring));
791      EXPECT_THAT(ToString(result), Eq(all.substr(len)));
792    }
793  }
794  TEST_P(CordRingSubTest, RemovePrefixFromLargeExternal) {
795    CordRepExternal* external1 = MakeFakeExternal(1 << 20);
796    CordRepExternal* external2 = MakeFakeExternal(1 << 20);
797    CordRepRing* ring = CordRepRing::Create(external1, 1);
798    ring = CordRepRing::Append(ring, external2);
799    CordRepRing* result = NeedsUnref(CordRepRing::RemovePrefix(ring, 1 << 16));
800    EXPECT_THAT(
801        ToRawFlats(result),
802        ElementsAre(
803            not_a_string_view(external1->base, 1 << 20).remove_prefix(1 << 16),
804            not_a_string_view(external2->base, 1 << 20)));
805  }
806  TEST_P(CordRingSubTest, RemoveSuffix) {
807    auto composition = RandomComposition();
808    SCOPED_TRACE(ToString(composition));
809    auto flats = MakeSpan(kFoxFlats);
810    string_view all = kFox;
811    CordRepRing* ring = RefIfShared(FromFlats(flats, composition));
812    CordRepRing* result = CordRepRing::RemoveSuffix(ring, all.size());
813    EXPECT_THAT(result, nullptr);
814    for (size_t len = 1; len < all.size(); ++len) {
815      ring = RefIfShared(FromFlats(flats, composition));
816      result = NeedsUnref(CordRepRing::RemoveSuffix(ring, len));
817      ASSERT_THAT(result, IsValidRingBuffer());
818      ASSERT_THAT(result, EqIfPrivate(GetParam(), ring));
819      ASSERT_THAT(result, NeIfShared(GetParam(), ring));
820      ASSERT_THAT(ToString(result), Eq(all.substr(0, all.size() - len)));
821    }
822  }
823  TEST_P(CordRingSubTest, AppendRing) {
824    auto composition = RandomComposition();
825    SCOPED_TRACE(ToString(composition));
826    auto flats = MakeSpan(kFoxFlats).subspan(1);
827    CordRepRing* ring = CreateWithCapacity(MakeFlat(kFoxFlats[0]), flats.size());
828    CordRepRing* child = FromFlats(flats, composition);
829    CordRepRing* result = NeedsUnref(CordRepRing::Append(ring, child));
830    ASSERT_THAT(result, IsValidRingBuffer());
831    EXPECT_THAT(result, EqIfPrivate(GetParam(), ring));
832    EXPECT_THAT(result, NeIfShared(GetParam(), ring));
833    EXPECT_THAT(ToFlats(result), ElementsAreArray(kFoxFlats));
834  }
835  TEST_P(CordRingBuildInputTest, AppendRingWithFlatOffset) {
836    auto composition = RandomComposition();
837    SCOPED_TRACE(ToString(composition));
838    auto flats = MakeSpan(kFoxFlats);
839    CordRepRing* ring = CreateWithCapacity(MakeFlat("Head"), flats.size());
840    CordRep* child = RefIfInputSharedIndirect(FromFlats(flats, composition));
841    CordRep* stripped = RemovePrefix(10, child);
842    CordRepRing* result = NeedsUnref(CordRepRing::Append(ring, stripped));
843    ASSERT_THAT(result, IsValidRingBuffer());
844    EXPECT_THAT(result, EqIfPrivateAndCapacity(GetParam(), ring));
845    EXPECT_THAT(result, NeIfShared(GetParam(), ring));
846    EXPECT_THAT(ToFlats(result), ElementsAre("Head", "brown ", "fox ", "jumps ",
847                                             "over ", "the ", "lazy ", "dog"));
848  }
849  TEST_P(CordRingBuildInputTest, AppendRingWithBrokenOffset) {
850    auto composition = RandomComposition();
851    SCOPED_TRACE(ToString(composition));
852    auto flats = MakeSpan(kFoxFlats);
853    CordRepRing* ring = CreateWithCapacity(MakeFlat("Head"), flats.size());
854    CordRep* child = RefIfInputSharedIndirect(FromFlats(flats, composition));
855    CordRep* stripped = RemovePrefix(21, child);
856    CordRepRing* result = NeedsUnref(CordRepRing::Append(ring, stripped));
857    ASSERT_THAT(result, IsValidRingBuffer());
858    EXPECT_THAT(result, EqIfPrivateAndCapacity(GetParam(), ring));
859    EXPECT_THAT(result, NeIfShared(GetParam(), ring));
860    EXPECT_THAT(ToFlats(result),
861                ElementsAre("Head", "umps ", "over ", "the ", "lazy ", "dog"));
862  }
863  TEST_P(CordRingBuildInputTest, AppendRingWithFlatLength) {
864    auto composition = RandomComposition();
865    SCOPED_TRACE(ToString(composition));
866    auto flats = MakeSpan(kFoxFlats);
867    CordRepRing* ring = CreateWithCapacity(MakeFlat("Head"), flats.size());
868    CordRep* child = RefIfInputSharedIndirect(FromFlats(flats, composition));
869    CordRep* stripped = RemoveSuffix(8, child);
870    CordRepRing* result = NeedsUnref(CordRepRing::Append(ring, stripped));
871    ASSERT_THAT(result, IsValidRingBuffer());
872    EXPECT_THAT(result, EqIfPrivateAndCapacity(GetParam(), ring));
873    EXPECT_THAT(result, NeIfShared(GetParam(), ring));
874    EXPECT_THAT(ToFlats(result), ElementsAre("Head", "The ", "quick ", "brown ",
875                                             "fox ", "jumps ", "over ", "the "));
876  }
877  TEST_P(CordRingBuildTest, AppendRingWithBrokenFlatLength) {
878    auto composition = RandomComposition();
879    SCOPED_TRACE(ToString(composition));
880    auto flats = MakeSpan(kFoxFlats);
881    CordRepRing* ring = CreateWithCapacity(MakeFlat("Head"), flats.size());
882    CordRep* child = RefIfInputSharedIndirect(FromFlats(flats, composition));
883    CordRep* stripped = RemoveSuffix(15, child);
884    CordRepRing* result = NeedsUnref(CordRepRing::Append(ring, stripped));
885    ASSERT_THAT(result, IsValidRingBuffer());
886    EXPECT_THAT(result, EqIfPrivateAndCapacity(GetParam(), ring));
887    EXPECT_THAT(result, NeIfShared(GetParam(), ring));
888    EXPECT_THAT(ToFlats(result), ElementsAre("Head", "The ", "quick ", "brown ",
889                                             "fox ", "jumps ", "ov"));
890  }
891  TEST_P(CordRingBuildTest, AppendRingMiddlePiece) {
892    auto composition = RandomComposition();
893    SCOPED_TRACE(ToString(composition));
894    auto flats = MakeSpan(kFoxFlats);
895    CordRepRing* ring = CreateWithCapacity(MakeFlat("Head"), flats.size());
896    CordRep* child = RefIfInputSharedIndirect(FromFlats(flats, composition));
897    CordRep* stripped = MakeSubstring(7, child->length - 27, child);
898    CordRepRing* result = NeedsUnref(CordRepRing::Append(ring, stripped));
899    ASSERT_THAT(result, IsValidRingBuffer());
900    EXPECT_THAT(result, EqIfPrivateAndCapacity(GetParam(), ring));
901    EXPECT_THAT(result, NeIfShared(GetParam(), ring));
902    EXPECT_THAT(ToFlats(result),
903                ElementsAre("Head", "ck ", "brown ", "fox ", "jum"));
904  }
905  TEST_P(CordRingBuildTest, AppendRingSinglePiece) {
906    auto composition = RandomComposition();
907    SCOPED_TRACE(ToString(composition));
908    auto flats = MakeSpan(kFoxFlats);
909    CordRepRing* ring = CreateWithCapacity(MakeFlat("Head"), flats.size());
910    CordRep* child = RefIfInputSharedIndirect(FromFlats(flats, composition));
911    CordRep* stripped = RefIfInputShared(MakeSubstring(11, 3, child));
912    CordRepRing* result = NeedsUnref(CordRepRing::Append(ring, stripped));
913    ASSERT_THAT(result, IsValidRingBuffer());
914    EXPECT_THAT(result, EqIfPrivateAndCapacity(GetParam(), ring));
915    EXPECT_THAT(result, NeIfShared(GetParam(), ring));
916    EXPECT_THAT(ToFlats(result), ElementsAre("Head", "row"));
917  }
918  TEST_P(CordRingBuildInputTest, AppendRingSinglePieceWithPrefix) {
919    auto composition = RandomComposition();
920    SCOPED_TRACE(ToString(composition));
921    auto flats = MakeSpan(kFoxFlats);
922    size_t extra_capacity = 1 + (GetParam().with_capacity ? flats.size() : 0);
923    CordRepRing* ring = CordRepRing::Create(MakeFlat("Head"), extra_capacity);
924    ring->SetCapacityForTesting(1 + extra_capacity);
925    ring = RefIfShared(CordRepRing::Prepend(ring, MakeFlat("Prepend")));
926    assert(ring->IsValid(std::cout));
927    CordRepRing* child = RefIfInputSharedIndirect(FromFlats(flats, composition));
928    CordRep* stripped = RefIfInputShared(MakeSubstring(11, 3, child));
929    CordRepRing* result = NeedsUnref(CordRepRing::Append(ring, stripped));
930    ASSERT_THAT(result, IsValidRingBuffer());
931    EXPECT_THAT(result, EqIfPrivateAndCapacity(GetParam(), ring));
932    EXPECT_THAT(result, NeIfShared(GetParam(), ring));
933    EXPECT_THAT(ToFlats(result), ElementsAre("Prepend", "Head", "row"));
934  }
935  TEST_P(CordRingBuildInputTest, PrependRing) {
936    auto composition = RandomComposition();
937    SCOPED_TRACE(ToString(composition));
938    auto fox = MakeSpan(kFoxFlats);
939    auto flats = MakeSpan(fox).subspan(0, fox.size() - 1);
940    CordRepRing* ring = CreateWithCapacity(MakeFlat(fox.back()), flats.size());
941    CordRepRing* child = RefIfInputShared(FromFlats(flats, composition));
942    CordRepRing* result = NeedsUnref(CordRepRing::Prepend(ring, child));
943    ASSERT_THAT(result, IsValidRingBuffer());
944    EXPECT_THAT(result, EqIfPrivateAndCapacity(GetParam(), ring));
945    EXPECT_THAT(result, NeIfShared(GetParam(), ring));
946    EXPECT_THAT(ToFlats(result), ElementsAreArray(kFoxFlats));
947  }
948  TEST_P(CordRingBuildInputTest, PrependRingWithFlatOffset) {
949    auto composition = RandomComposition();
950    SCOPED_TRACE(ToString(composition));
951    auto flats = MakeSpan(kFoxFlats);
952    CordRepRing* ring = CreateWithCapacity(MakeFlat("Tail"), flats.size());
953    CordRep* child = RefIfInputShared(FromFlats(flats, composition));
954    CordRep* stripped = RefIfInputSharedIndirect(RemovePrefix(10, child));
955    CordRepRing* result = NeedsUnref(CordRepRing::Prepend(ring, stripped));
956    ASSERT_THAT(result, IsValidRingBuffer());
957    EXPECT_THAT(result, EqIfPrivateAndCapacity(GetParam(), ring));
958    EXPECT_THAT(result, NeIfShared(GetParam(), ring));
959    EXPECT_THAT(ToFlats(result), ElementsAre("brown ", "fox ", "jumps ", "over ",
960                                             "the ", "lazy ", "dog", "Tail"));
961  }
962  TEST_P(CordRingBuildInputTest, PrependRingWithBrokenOffset) {
963    auto composition = RandomComposition();
964    SCOPED_TRACE(ToString(composition));
965    auto flats = MakeSpan(kFoxFlats);
966    CordRepRing* ring = CreateWithCapacity(MakeFlat("Tail"), flats.size());
967    CordRep* child = RefIfInputShared(FromFlats(flats, composition));
968    CordRep* stripped = RefIfInputSharedIndirect(RemovePrefix(21, child));
969    CordRepRing* result = NeedsUnref(CordRepRing::Prepend(ring, stripped));
970    EXPECT_THAT(result, EqIfPrivateAndCapacity(GetParam(), ring));
971    EXPECT_THAT(result, NeIfShared(GetParam(), ring));
972    EXPECT_THAT(ToFlats(result),
973                ElementsAre("umps ", "over ", "the ", "lazy ", "dog", "Tail"));
974  }
975  TEST_P(CordRingBuildInputTest, PrependRingWithFlatLength) {
976    auto composition = RandomComposition();
977    SCOPED_TRACE(ToString(composition));
978    auto flats = MakeSpan(kFoxFlats);
979    CordRepRing* ring = CreateWithCapacity(MakeFlat("Tail"), flats.size());
980    CordRep* child = RefIfInputShared(FromFlats(flats, composition));
981    CordRep* stripped = RefIfInputSharedIndirect(RemoveSuffix(8, child));
982    CordRepRing* result = NeedsUnref(CordRepRing::Prepend(ring, stripped));
983    ASSERT_THAT(result, IsValidRingBuffer());
984    EXPECT_THAT(result, EqIfPrivateAndCapacity(GetParam(), ring));
985    EXPECT_THAT(result, NeIfShared(GetParam(), ring));
986    EXPECT_THAT(ToFlats(result), ElementsAre("The ", "quick ", "brown ", "fox ",
987                                             "jumps ", "over ", "the ", "Tail"));
988  }
989  TEST_P(CordRingBuildInputTest, PrependRingWithBrokenFlatLength) {
990    auto composition = RandomComposition();
991    SCOPED_TRACE(ToString(composition));
992    auto flats = MakeSpan(kFoxFlats);
993    CordRepRing* ring = CreateWithCapacity(MakeFlat("Tail"), flats.size());
994    CordRep* child = RefIfInputShared(FromFlats(flats, composition));
995    CordRep* stripped = RefIfInputSharedIndirect(RemoveSuffix(15, child));
996    CordRepRing* result = NeedsUnref(CordRepRing::Prepend(ring, stripped));
997    ASSERT_THAT(result, IsValidRingBuffer());
998    EXPECT_THAT(result, EqIfPrivateAndCapacity(GetParam(), ring));
999    EXPECT_THAT(result, NeIfShared(GetParam(), ring));
1000    EXPECT_THAT(ToFlats(result), ElementsAre("The ", "quick ", "brown ", "fox ",
1001                                             "jumps ", "ov", "Tail"));
1002  }
1003  TEST_P(CordRingBuildInputTest, PrependRingMiddlePiece) {
1004    auto composition = RandomComposition();
1005    SCOPED_TRACE(ToString(composition));
1006    auto flats = MakeSpan(kFoxFlats);
1007    CordRepRing* ring = CreateWithCapacity(MakeFlat("Tail"), flats.size());
1008    CordRep* child = RefIfInputShared(FromFlats(flats, composition));
1009    CordRep* stripped =
1010        RefIfInputSharedIndirect(MakeSubstring(7, child->length - 27, child));
1011    CordRepRing* result = NeedsUnref(CordRepRing::Prepend(ring, stripped));
1012    ASSERT_THAT(result, IsValidRingBuffer());
1013    EXPECT_THAT(result, EqIfPrivateAndCapacity(GetParam(), ring));
1014    EXPECT_THAT(result, NeIfShared(GetParam(), ring));
1015    EXPECT_THAT(ToFlats(result),
1016                ElementsAre("ck ", "brown ", "fox ", "jum", "Tail"));
1017  }
1018  TEST_P(CordRingBuildInputTest, PrependRingSinglePiece) {
1019    auto composition = RandomComposition();
1020    SCOPED_TRACE(ToString(composition));
1021    auto flats = MakeSpan(kFoxFlats);
1022    CordRepRing* ring = CreateWithCapacity(MakeFlat("Tail"), flats.size());
1023    CordRep* child = RefIfInputShared(FromFlats(flats, composition));
1024    CordRep* stripped = RefIfInputSharedIndirect(MakeSubstring(11, 3, child));
1025    CordRepRing* result = NeedsUnref(CordRepRing::Prepend(ring, stripped));
1026    ASSERT_THAT(result, IsValidRingBuffer());
1027    EXPECT_THAT(result, EqIfPrivateAndCapacity(GetParam(), ring));
1028    EXPECT_THAT(result, NeIfShared(GetParam(), ring));
1029    EXPECT_THAT(ToFlats(result), ElementsAre("row", "Tail"));
1030  }
1031  TEST_P(CordRingBuildInputTest, PrependRingSinglePieceWithPrefix) {
1032    auto composition = RandomComposition();
1033    SCOPED_TRACE(ToString(composition));
1034    auto flats = MakeSpan(kFoxFlats);
1035    size_t extra_capacity = 1 + (GetParam().with_capacity ? flats.size() : 0);
1036    CordRepRing* ring = CordRepRing::Create(MakeFlat("Tail"), extra_capacity);
1037    ring->SetCapacityForTesting(1 + extra_capacity);
1038    ring = RefIfShared(CordRepRing::Prepend(ring, MakeFlat("Prepend")));
1039    CordRep* child = RefIfInputShared(FromFlats(flats, composition));
1040    CordRep* stripped = RefIfInputSharedIndirect(MakeSubstring(11, 3, child));
1041    CordRepRing* result = NeedsUnref(CordRepRing::Prepend(ring, stripped));
1042    ASSERT_THAT(result, IsValidRingBuffer());
1043    EXPECT_THAT(result, EqIfPrivateAndCapacity(GetParam(), ring));
1044    EXPECT_THAT(result, NeIfShared(GetParam(), ring));
1045    EXPECT_THAT(ToFlats(result), ElementsAre("row", "Prepend", "Tail"));
1046  }
1047  TEST_F(CordRingTest, Find) {
1048    constexpr const char* flats[] = {
1049        "abcdefghij", "klmnopqrst", "uvwxyz",     "ABCDEFGHIJ",
1050        "KLMNOPQRST", "UVWXYZ",     "1234567890", "~!@#$%^&*()_",
1051        "+-=",        "[]\\{}|;':", ",/<>?",      "."};
1052    auto composition = RandomComposition();
1053    SCOPED_TRACE(ToString(composition));
1054    CordRepRing* ring = NeedsUnref(FromFlats(flats, composition));
1055    std::string value = ToString(ring);
1056    for (int i = 0; i < value.length(); ++i) {
1057      CordRepRing::Position found = ring->Find(i);
1058      auto data = ring->entry_data(found.index);
1059      ASSERT_THAT(found.offset, Lt(data.length()));
1060      ASSERT_THAT(data[found.offset], Eq(value[i]));
1061    }
1062  }
1063  TEST_F(CordRingTest, FindWithHint) {
1064    constexpr const char* flats[] = {
1065        "abcdefghij", "klmnopqrst", "uvwxyz",     "ABCDEFGHIJ",
1066        "KLMNOPQRST", "UVWXYZ",     "1234567890", "~!@#$%^&*()_",
1067        "+-=",        "[]\\{}|;':", ",/<>?",      "."};
1068    auto composition = RandomComposition();
1069    SCOPED_TRACE(ToString(composition));
1070    CordRepRing* ring = NeedsUnref(FromFlats(flats, composition));
1071    std::string value = ToString(ring);
1072  #if defined(GTEST_HAS_DEATH_TEST)
1073    index_type head = ring->head();
1074    EXPECT_DEBUG_DEATH(ring->Find(ring->advance(head), 0), ".*");
1075    EXPECT_DEBUG_DEATH(ring->Find(ring->advance(head), 9), ".*");
1076    EXPECT_DEBUG_DEATH(ring->Find(ring->advance(head, 3), 24), ".*");
1077  #endif
1078    int flat_pos = 0;
1079    size_t flat_offset = 0;
1080    for (auto sflat : flats) {
1081      string_view flat(sflat);
1082      for (int offset = 0; offset < flat.length(); ++offset) {
1083        for (int start = 0; start <= flat_pos; ++start) {
1084          index_type hint = ring->advance(ring->head(), start);
1085          CordRepRing::Position found = ring->Find(hint, flat_offset + offset);
1086          ASSERT_THAT(found.index, Eq(ring->advance(ring->head(), flat_pos)));
1087          ASSERT_THAT(found.offset, Eq(offset));
1088        }
1089      }
1090      ++flat_pos;
1091      flat_offset += flat.length();
1092    }
1093  }
1094  TEST_F(CordRingTest, FindInLargeRing) {
1095    constexpr const char* flats[] = {
1096        "abcdefghij", "klmnopqrst", "uvwxyz",     "ABCDEFGHIJ",
1097        "KLMNOPQRST", "UVWXYZ",     "1234567890", "~!@#$%^&*()_",
1098        "+-=",        "[]\\{}|;':", ",/<>?",      "."};
1099    auto composition = RandomComposition();
1100    SCOPED_TRACE(ToString(composition));
1101    CordRepRing* ring = FromFlats(flats, composition);
1102    for (int i = 0; i < 13; ++i) {
1103      ring = CordRepRing::Append(ring, FromFlats(flats, composition));
1104    }
1105    NeedsUnref(ring);
1106    std::string value = ToString(ring);
1107    for (int i = 0; i < value.length(); ++i) {
1108      CordRepRing::Position pos = ring->Find(i);
1109      auto data = ring->entry_data(pos.index);
1110      ASSERT_THAT(pos.offset, Lt(data.length()));
1111      ASSERT_THAT(data[pos.offset], Eq(value[i]));
1112    }
1113  }
1114  TEST_F(CordRingTest, FindTail) {
1115    constexpr const char* flats[] = {
1116        "abcdefghij", "klmnopqrst", "uvwxyz",     "ABCDEFGHIJ",
1117        "KLMNOPQRST", "UVWXYZ",     "1234567890", "~!@#$%^&*()_",
1118        "+-=",        "[]\\{}|;':", ",/<>?",      "."};
1119    auto composition = RandomComposition();
1120    SCOPED_TRACE(ToString(composition));
1121    CordRepRing* ring = NeedsUnref(FromFlats(flats, composition));
1122    std::string value = ToString(ring);
1123    for (int i = 0; i < value.length(); ++i) {
1124      CordRepRing::Position pos = ring->FindTail(i + 1);
1125      auto data = ring->entry_data(ring->retreat(pos.index));
1126      ASSERT_THAT(pos.offset, Lt(data.length()));
1127      ASSERT_THAT(data[data.length() - pos.offset - 1], Eq(value[i]));
1128    }
1129  }
1130  TEST_F(CordRingTest, FindTailWithHint) {
1131    constexpr const char* flats[] = {
1132        "abcdefghij", "klmnopqrst", "uvwxyz",     "ABCDEFGHIJ",
1133        "KLMNOPQRST", "UVWXYZ",     "1234567890", "~!@#$%^&*()_",
1134        "+-=",        "[]\\{}|;':", ",/<>?",      "."};
1135    auto composition = RandomComposition();
1136    SCOPED_TRACE(ToString(composition));
1137    CordRepRing* ring = NeedsUnref(FromFlats(flats, composition));
1138    std::string value = ToString(ring);
1139  #if defined(GTEST_HAS_DEATH_TEST)
1140    index_type head = ring->head();
1141    EXPECT_DEBUG_DEATH(ring->FindTail(ring->advance(head), 1), ".*");
1142    EXPECT_DEBUG_DEATH(ring->FindTail(ring->advance(head), 10), ".*");
1143    EXPECT_DEBUG_DEATH(ring->FindTail(ring->advance(head, 3), 26), ".*");
1144  #endif
1145    for (int i = 0; i < value.length(); ++i) {
1146      CordRepRing::Position pos = ring->FindTail(i + 1);
1147      auto data = ring->entry_data(ring->retreat(pos.index));
1148      ASSERT_THAT(pos.offset, Lt(data.length()));
1149      ASSERT_THAT(data[data.length() - pos.offset - 1], Eq(value[i]));
1150    }
1151  }
1152  TEST_F(CordRingTest, FindTailInLargeRing) {
1153    constexpr const char* flats[] = {
1154        "abcdefghij", "klmnopqrst", "uvwxyz",     "ABCDEFGHIJ",
1155        "KLMNOPQRST", "UVWXYZ",     "1234567890", "~!@#$%^&*()_",
1156        "+-=",        "[]\\{}|;':", ",/<>?",      "."};
1157    auto composition = RandomComposition();
1158    SCOPED_TRACE(ToString(composition));
1159    CordRepRing* ring = FromFlats(flats, composition);
1160    for (int i = 0; i < 13; ++i) {
1161      ring = CordRepRing::Append(ring, FromFlats(flats, composition));
1162    }
1163    NeedsUnref(ring);
1164    std::string value = ToString(ring);
1165    for (int i = 0; i < value.length(); ++i) {
1166      CordRepRing::Position pos = ring->FindTail(i + 1);
1167      auto data = ring->entry_data(ring->retreat(pos.index));
1168      ASSERT_THAT(pos.offset, Lt(data.length()));
1169      ASSERT_THAT(data[data.length() - pos.offset - 1], Eq(value[i]));
1170    }
1171  }
1172  TEST_F(CordRingTest, GetCharacter) {
1173    auto flats = MakeSpan(kFoxFlats);
1174    CordRepRing* ring = CordRepRing::Create(MakeFlat("Tail"), flats.size());
1175    CordRep* child = FromFlats(flats, kAppend);
1176    CordRepRing* result = NeedsUnref(CordRepRing::Prepend(ring, child));
1177    std::string value = ToString(result);
1178    for (int i = 0; i < value.length(); ++i) {
1179      ASSERT_THAT(result->GetCharacter(i), Eq(value[i]));
1180    }
1181  }
1182  TEST_F(CordRingTest, GetCharacterWithSubstring) {
1183    absl::string_view str1 = "abcdefghijklmnopqrstuvwxyz";
1184    auto* child = MakeSubstring(4, 20, MakeFlat(str1));
1185    CordRepRing* result = NeedsUnref(CordRepRing::Create(child));
1186    ASSERT_THAT(result, IsValidRingBuffer());
1187    std::string value = ToString(result);
1188    for (int i = 0; i < value.length(); ++i) {
1189      ASSERT_THAT(result->GetCharacter(i), Eq(value[i]));
1190    }
1191  }
1192  TEST_F(CordRingTest, IsFlatSingleFlat) {
1193    for (bool external : {false, true}) {
1194      SCOPED_TRACE(external ? "With External" : "With Flat");
1195      absl::string_view str = "Hello world";
1196      CordRep* rep = external ? MakeExternal(str) : MakeFlat(str);
1197      CordRepRing* ring = NeedsUnref(CordRepRing::Create(rep));
1198      absl::string_view fragment;
1199      EXPECT_TRUE(ring->IsFlat(nullptr));
1200      EXPECT_TRUE(ring->IsFlat(&fragment));
1201      EXPECT_THAT(fragment, Eq("Hello world"));
1202      fragment = "";
1203      EXPECT_TRUE(ring->IsFlat(0, 11, nullptr));
1204      EXPECT_TRUE(ring->IsFlat(0, 11, &fragment));
1205      EXPECT_THAT(fragment, Eq("Hello world"));
1206      EXPECT_TRUE(ring->IsFlat(1, 4, &fragment));
1207      EXPECT_THAT(fragment, Eq("ello"));
1208      EXPECT_TRUE(ring->IsFlat(6, 5, &fragment));
1209      EXPECT_THAT(fragment, Eq("world"));
1210    }
1211  }
1212  TEST_F(CordRingTest, IsFlatMultiFlat) {
1213    for (bool external : {false, true}) {
1214      SCOPED_TRACE(external ? "With External" : "With Flat");
1215      absl::string_view str1 = "Hello world";
1216      absl::string_view str2 = "Halt and catch fire";
1217      CordRep* rep1 = external ? MakeExternal(str1) : MakeFlat(str1);
1218      CordRep* rep2 = external ? MakeExternal(str2) : MakeFlat(str2);
1219      CordRepRing* ring = CordRepRing::Append(CordRepRing::Create(rep1), rep2);
1220      NeedsUnref(ring);
1221      EXPECT_FALSE(ring->IsFlat(nullptr));
1222      absl::string_view fragment = "Don't touch this";
1223      EXPECT_FALSE(ring->IsFlat(&fragment));
1224      EXPECT_THAT(fragment, Eq("Don't touch this"));
1225      EXPECT_TRUE(ring->IsFlat(0, 11, &fragment));
1226      EXPECT_THAT(fragment, Eq("Hello world"));
1227      EXPECT_TRUE(ring->IsFlat(11, 19, &fragment));
1228      EXPECT_THAT(fragment, Eq("Halt and catch fire"));
1229      EXPECT_TRUE(ring->IsFlat(1, 4, &fragment));
1230      EXPECT_THAT(fragment, "ello");
1231      EXPECT_TRUE(ring->IsFlat(26, 4, &fragment));
1232      EXPECT_THAT(fragment, "fire");
1233      fragment = "Don't touch this";
1234      EXPECT_FALSE(ring->IsFlat(1, 18, &fragment));
1235      EXPECT_FALSE(ring->IsFlat(10, 2, &fragment));
1236      EXPECT_THAT(fragment, Eq("Don't touch this"));
1237    }
1238  }
1239  TEST_F(CordRingTest, Dump) {
1240    std::stringstream ss;
1241    auto flats = MakeSpan(kFoxFlats);
1242    CordRepRing* ring = NeedsUnref(FromFlats(flats, kPrepend));
1243    ss << *ring;
1244  }
1245  }  
1246  ABSL_NAMESPACE_END
1247  }  
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-UserDefineDialog.cpp</h3>
            <pre><code>1  #include "localization.h"
2  #include "UserDefineDialog.h"
3  #include "ScintillaEditView.h"
4  #include "Notepad_plus_msgs.h"
5  #include "CustomFileDialog.h"
6  using namespace std;
7  UserLangContainer * SharedParametersDialog::_pUserLang = NULL;
8  ScintillaEditView * SharedParametersDialog::_pScintilla = NULL;
9  GlobalMappers & globalMappper()
10  {
11      static GlobalMappers gm;
12      return gm;
13  }
14  void convertTo(TCHAR *dest, int destLen, const TCHAR *toConvert, const TCHAR *prefix)
15  {
16  	bool inGroup = false;
17  	int index = lstrlen(dest);
18  	if (index > 0)
19  		dest[index++] = ' ';
20  	dest[index++] = prefix[0];
21  	dest[index++] = prefix[1];
22  	for (size_t i = 0, len = lstrlen(toConvert); i < len && index < destLen - 7; ++i)
23  	{
<span onclick='openModal()' class='match'>24  		if (i == 0 && toConvert[i] == '(' && toConvert[i + 1] == '(')
25  		{
26  			inGroup = true;
27  		}
28  		else if (toConvert[i] == ' ' && toConvert[i + 1] == '(' && toConvert[i + 2] == '(')
29  		{
30  			inGroup = true;
31  			dest[index++] = ' ';
</span>32  			dest[index++] = prefix[0];
33  			dest[index++] = prefix[1];
34  			++i;    
35  		}
36  		if (inGroup && toConvert[i - 1] == ')' && toConvert[i - 2] == ')')
37  		{
38  			inGroup = false;
39  		}
40  		if (toConvert[i] == ' ')
41  		{
42  			if (toConvert[i + 1] != ' ' && toConvert[i + 1] != '\0')
43  			{
44  				dest[index++] = ' ';
45  				if (!inGroup)
46  				{
47  					dest[index++] = prefix[0];
48  					dest[index++] = prefix[1];
49  				}
50  			}
51  		}
52  		else
53  		{
54  			dest[index++] = toConvert[i];
55  		}
56  	}
57  	dest[index] = '\0';
58  }
59  bool SharedParametersDialog::setPropertyByCheck(HWND hwnd, WPARAM id, bool & bool2set)
60  {
61      bool2set = (BST_CHECKED == ::SendMessage(::GetDlgItem(hwnd, int(id)), BM_GETCHECK, 0, 0));
62      if (_pScintilla->getCurrentBuffer()->getLangType() == L_USER)
63          _pScintilla->styleChange();
64      return TRUE;
65  }
66  intptr_t CALLBACK SharedParametersDialog::run_dlgProc(UINT Message, WPARAM wParam, LPARAM &bsol;*lParam*/)
67  {
68      switch (Message)
69      {
70          case WM_INITDIALOG :
71          {
72              return TRUE;
73          }
74          case WM_CTLCOLOREDIT:
75          {
76              return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
77          }
78          case WM_CTLCOLORDLG:
79          case WM_CTLCOLORSTATIC:
80          {
81              return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
82          }
83          case WM_PRINTCLIENT:
84          {
85              if (NppDarkMode::isEnabled())
86              {
87                  return TRUE;
88              }
89              break;
90          }
91          case WM_COMMAND :
92          {
93              if (HIWORD(wParam) == EN_CHANGE)
94              {
95                  setKeywords2List(LOWORD(wParam));
96                  if (_pScintilla->getCurrentBuffer()->getLangType() == L_USER)
97                      _pScintilla->styleChange();
98                  return TRUE;
99              }
100              return FALSE;
101          }
102      }
103      return FALSE;
104  }
105  intptr_t CALLBACK FolderStyleDialog::run_dlgProc(UINT Message, WPARAM wParam, LPARAM lParam)
106  {
107      switch (Message)
108      {
109          case WM_INITDIALOG :
110          {
111              _pageLink.init(_hInst, _hSelf);
112              _pageLink.create(::GetDlgItem(_hSelf, IDC_WEB_HELP_LINK), TEXT("https:&bsol;&bsol;ivan-radic.github.io/udl-documentation/"));
113              return TRUE;
114          }
115          case WM_COMMAND :
116          {
117              switch (wParam)
118              {
119                  case IDC_FOLDER_FOLD_COMPACT :
120                  {
121                      return setPropertyByCheck(_hSelf, wParam, _pUserLang->_foldCompact);
122                  }
123                  case IDC_FOLDER_IN_CODE1_STYLER :
124                  {
125                      StylerDlg stylerDlg(_hInst, _hSelf, SCE_USER_STYLE_FOLDER_IN_CODE1, SCE_USER_MASK_NESTING_NONE);
126                      stylerDlg.doDialog();
127                      return TRUE;
128                  }
129                  case IDC_FOLDER_IN_CODE2_STYLER :
130                  {
131                      StylerDlg stylerDlg(_hInst, _hSelf, SCE_USER_STYLE_FOLDER_IN_CODE2, SCE_USER_MASK_NESTING_NONE);
132                      stylerDlg.doDialog();
133                      return TRUE;
134                  }
135                  case IDC_FOLDER_IN_COMMENT_STYLER :
136                  {
137                      StylerDlg stylerDlg(_hInst, _hSelf, SCE_USER_STYLE_FOLDER_IN_COMMENT, SCE_USER_MASK_NESTING_NONE);
138                      stylerDlg.doDialog();
139                      return TRUE;
140                  }
141                  case IDC_DEFAULT_STYLER :
142                  {
143                      StylerDlg stylerDlg(_hInst, _hSelf, SCE_USER_STYLE_DEFAULT, SCE_USER_MASK_NESTING_NONE);
144                      stylerDlg.doDialog();
145                      return TRUE;
146                  }
147                  default :
148                      return SharedParametersDialog::run_dlgProc(Message, wParam, lParam);
149              }
150          }
151          case WM_DESTROY:
152          {
153              _pageLink.destroy();
154              return TRUE;
155          }
156          default :
157              return SharedParametersDialog::run_dlgProc(Message, wParam, lParam);
158      }
159  }
160  void FolderStyleDialog::setKeywords2List(int id)
161  {
162      switch (id)
163      {
164          case IDC_FOLDER_IN_CODE1_OPEN_EDIT :     
165          case IDC_FOLDER_IN_CODE1_MIDDLE_EDIT :   
166          case IDC_FOLDER_IN_CODE1_CLOSE_EDIT :    
167          case IDC_FOLDER_IN_CODE2_OPEN_EDIT :     
168          case IDC_FOLDER_IN_CODE2_MIDDLE_EDIT :   
169          case IDC_FOLDER_IN_CODE2_CLOSE_EDIT :    
170          case IDC_FOLDER_IN_COMMENT_OPEN_EDIT :   
171          case IDC_FOLDER_IN_COMMENT_MIDDLE_EDIT : 
172          case IDC_FOLDER_IN_COMMENT_CLOSE_EDIT :  
173              ::GetDlgItemText(_hSelf, id, _pUserLang->_keywordLists[globalMappper().dialogMapper[id]], max_char);
174              break;
175      }
176  }
177  void FolderStyleDialog::updateDlg()
178  {
179      ::SendDlgItemMessage(_hSelf, IDC_FOLDER_FOLD_COMPACT,           BM_SETCHECK, _pUserLang->_foldCompact, 0);
180      ::SendDlgItemMessage(_hSelf, IDC_FOLDER_IN_CODE1_OPEN_EDIT,     WM_SETTEXT, 0, reinterpret_cast<LPARAM>(_pUserLang->_keywordLists[SCE_USER_KWLIST_FOLDERS_IN_CODE1_OPEN]));
181      ::SendDlgItemMessage(_hSelf, IDC_FOLDER_IN_CODE1_MIDDLE_EDIT,   WM_SETTEXT, 0, reinterpret_cast<LPARAM>(_pUserLang->_keywordLists[SCE_USER_KWLIST_FOLDERS_IN_CODE1_MIDDLE]));
182      ::SendDlgItemMessage(_hSelf, IDC_FOLDER_IN_CODE1_CLOSE_EDIT,    WM_SETTEXT, 0, reinterpret_cast<LPARAM>(_pUserLang->_keywordLists[SCE_USER_KWLIST_FOLDERS_IN_CODE1_CLOSE]));
183      ::SendDlgItemMessage(_hSelf, IDC_FOLDER_IN_CODE2_OPEN_EDIT,     WM_SETTEXT, 0, reinterpret_cast<LPARAM>(_pUserLang->_keywordLists[SCE_USER_KWLIST_FOLDERS_IN_CODE2_OPEN]));
184      ::SendDlgItemMessage(_hSelf, IDC_FOLDER_IN_CODE2_MIDDLE_EDIT,   WM_SETTEXT, 0, reinterpret_cast<LPARAM>(_pUserLang->_keywordLists[SCE_USER_KWLIST_FOLDERS_IN_CODE2_MIDDLE]));
185      ::SendDlgItemMessage(_hSelf, IDC_FOLDER_IN_CODE2_CLOSE_EDIT,    WM_SETTEXT, 0, reinterpret_cast<LPARAM>(_pUserLang->_keywordLists[SCE_USER_KWLIST_FOLDERS_IN_CODE2_CLOSE]));
186      ::SendDlgItemMessage(_hSelf, IDC_FOLDER_IN_COMMENT_OPEN_EDIT,   WM_SETTEXT, 0, reinterpret_cast<LPARAM>(_pUserLang->_keywordLists[SCE_USER_KWLIST_FOLDERS_IN_COMMENT_OPEN]));
187      ::SendDlgItemMessage(_hSelf, IDC_FOLDER_IN_COMMENT_MIDDLE_EDIT, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(_pUserLang->_keywordLists[SCE_USER_KWLIST_FOLDERS_IN_COMMENT_MIDDLE]));
188      ::SendDlgItemMessage(_hSelf, IDC_FOLDER_IN_COMMENT_CLOSE_EDIT,  WM_SETTEXT, 0, reinterpret_cast<LPARAM>(_pUserLang->_keywordLists[SCE_USER_KWLIST_FOLDERS_IN_COMMENT_CLOSE]));
189  }
190  void FolderStyleDialog::retrieve(TCHAR *dest, const TCHAR *toRetrieve, TCHAR *prefix) const
191  {
192      int j = 0;
193      bool begin2Copy = false;
194      for (size_t i = 0, len = lstrlen(toRetrieve); i < len ; ++i)
195      {
196          if ((i == 0 || (toRetrieve[i-1] == ' ')) && (toRetrieve[i] == prefix[0] && toRetrieve[i+1] == prefix[1]))
197          {
198              if (j > 0)
199                  dest[j++] = ' ';
200              begin2Copy = true;
201              ++i;
202              continue;
203          }
204          else if (((toRetrieve[i] == ' ') && begin2Copy == true))
205          {
206              begin2Copy = false;
207          }
208          if (begin2Copy)
209              dest[j++] = toRetrieve[i];
210      }
211      dest[j++] = '\0';
212  }
213  intptr_t CALLBACK KeyWordsStyleDialog::run_dlgProc(UINT Message, WPARAM wParam, LPARAM lParam)
214  {
215      switch (Message)
216      {
217          case WM_INITDIALOG :
218          {
219              ::SendMessage(::GetDlgItem(_hSelf,IDC_KEYWORD1_EDIT), EM_LIMITTEXT, WPARAM(128*1024), 0);
220              ::SendMessage(::GetDlgItem(_hSelf,IDC_KEYWORD2_EDIT), EM_LIMITTEXT, WPARAM(128*1024), 0);
221              ::SendMessage(::GetDlgItem(_hSelf,IDC_KEYWORD3_EDIT), EM_LIMITTEXT, WPARAM(128*1024), 0);
222              ::SendMessage(::GetDlgItem(_hSelf,IDC_KEYWORD4_EDIT), EM_LIMITTEXT, WPARAM(128*1024), 0);
223              ::SendMessage(::GetDlgItem(_hSelf,IDC_KEYWORD5_EDIT), EM_LIMITTEXT, WPARAM(128*1024), 0);
224              ::SendMessage(::GetDlgItem(_hSelf,IDC_KEYWORD6_EDIT), EM_LIMITTEXT, WPARAM(128*1024), 0);
225              ::SendMessage(::GetDlgItem(_hSelf,IDC_KEYWORD7_EDIT), EM_LIMITTEXT, WPARAM(128*1024), 0);
226              ::SendMessage(::GetDlgItem(_hSelf,IDC_KEYWORD8_EDIT), EM_LIMITTEXT, WPARAM(128*1024), 0);
227              return TRUE;
228          }
229          case WM_COMMAND :
230          {
231              switch (wParam)
232              {
233                  case IDC_KEYWORD1_PREFIX_CHECK :
234                      return setPropertyByCheck(_hSelf, wParam, _pUserLang->_isPrefix[0]);
235                  case IDC_KEYWORD2_PREFIX_CHECK :
236                      return setPropertyByCheck(_hSelf, wParam, _pUserLang->_isPrefix[1]);
237                  case IDC_KEYWORD3_PREFIX_CHECK :
238                      return setPropertyByCheck(_hSelf, wParam, _pUserLang->_isPrefix[2]);
239                  case IDC_KEYWORD4_PREFIX_CHECK :
240                      return setPropertyByCheck(_hSelf, wParam, _pUserLang->_isPrefix[3]);
241                  case IDC_KEYWORD5_PREFIX_CHECK :
242                      return setPropertyByCheck(_hSelf, wParam, _pUserLang->_isPrefix[4]);
243                  case IDC_KEYWORD6_PREFIX_CHECK :
244                      return setPropertyByCheck(_hSelf, wParam, _pUserLang->_isPrefix[5]);
245                  case IDC_KEYWORD7_PREFIX_CHECK :
246                      return setPropertyByCheck(_hSelf, wParam, _pUserLang->_isPrefix[6]);
247                  case IDC_KEYWORD8_PREFIX_CHECK :
248                      return setPropertyByCheck(_hSelf, wParam, _pUserLang->_isPrefix[7]);
249                  case IDC_KEYWORD1_STYLER :
250                  {
251                      StylerDlg stylerDlg(_hInst, _hSelf, SCE_USER_STYLE_KEYWORD1, SCE_USER_MASK_NESTING_NONE);
252                      stylerDlg.doDialog();
253                      return TRUE;
254                  }
255                  case IDC_KEYWORD2_STYLER :
256                  {
257                      StylerDlg stylerDlg(_hInst, _hSelf, SCE_USER_STYLE_KEYWORD2, SCE_USER_MASK_NESTING_NONE);
258                      stylerDlg.doDialog();
259                      return TRUE;
260                  }
261                  case IDC_KEYWORD3_STYLER :
262                  {
263                      StylerDlg stylerDlg(_hInst, _hSelf, SCE_USER_STYLE_KEYWORD3, SCE_USER_MASK_NESTING_NONE);
264                      stylerDlg.doDialog();
265                      return TRUE;
266                  }
267                  case IDC_KEYWORD4_STYLER :
268                  {
269                      StylerDlg stylerDlg(_hInst, _hSelf, SCE_USER_STYLE_KEYWORD4, SCE_USER_MASK_NESTING_NONE);
270                      stylerDlg.doDialog();
271                      return TRUE;
272                  }
273                  case IDC_KEYWORD5_STYLER :
274                  {
275                      StylerDlg stylerDlg(_hInst, _hSelf, SCE_USER_STYLE_KEYWORD5, SCE_USER_MASK_NESTING_NONE);
276                      stylerDlg.doDialog();
277                      return TRUE;
278                  }
279                  case IDC_KEYWORD6_STYLER :
280                  {
281                      StylerDlg stylerDlg(_hInst, _hSelf, SCE_USER_STYLE_KEYWORD6, SCE_USER_MASK_NESTING_NONE);
282                      stylerDlg.doDialog();
283                      return TRUE;
284                  }
285                  case IDC_KEYWORD7_STYLER :
286                  {
287                      StylerDlg stylerDlg(_hInst, _hSelf, SCE_USER_STYLE_KEYWORD7, SCE_USER_MASK_NESTING_NONE);
288                      stylerDlg.doDialog();
289                      return TRUE;
290                  }
291                  case IDC_KEYWORD8_STYLER :
292                  {
293                      StylerDlg stylerDlg(_hInst, _hSelf, SCE_USER_STYLE_KEYWORD8, SCE_USER_MASK_NESTING_NONE);
294                      stylerDlg.doDialog();
295                      return TRUE;
296                  }
297                  default :
298                      return SharedParametersDialog::run_dlgProc(Message, wParam, lParam);
299              }
300          }
301          default :
302              return SharedParametersDialog::run_dlgProc(Message, wParam, lParam);
303      }
304  }
305  void KeyWordsStyleDialog::setKeywords2List(int id)
306  {
307      switch (id)
308      {
309          case IDC_KEYWORD1_EDIT :
310          case IDC_KEYWORD2_EDIT :
311          case IDC_KEYWORD3_EDIT :
312          case IDC_KEYWORD4_EDIT :
313          case IDC_KEYWORD5_EDIT :
314          case IDC_KEYWORD6_EDIT :
315          case IDC_KEYWORD7_EDIT :
316          case IDC_KEYWORD8_EDIT :
317              ::GetDlgItemText(_hSelf, id, _pUserLang->_keywordLists[globalMappper().dialogMapper[id]], max_char);
318      }
319  }
320  void KeyWordsStyleDialog::updateDlg()
321  {
322      ::SendDlgItemMessage(_hSelf, IDC_KEYWORD1_EDIT, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(_pUserLang->_keywordLists[SCE_USER_KWLIST_KEYWORDS1]));
323      ::SendDlgItemMessage(_hSelf, IDC_KEYWORD2_EDIT, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(_pUserLang->_keywordLists[SCE_USER_KWLIST_KEYWORDS2]));
324      ::SendDlgItemMessage(_hSelf, IDC_KEYWORD3_EDIT, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(_pUserLang->_keywordLists[SCE_USER_KWLIST_KEYWORDS3]));
325      ::SendDlgItemMessage(_hSelf, IDC_KEYWORD4_EDIT, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(_pUserLang->_keywordLists[SCE_USER_KWLIST_KEYWORDS4]));
326      ::SendDlgItemMessage(_hSelf, IDC_KEYWORD5_EDIT, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(_pUserLang->_keywordLists[SCE_USER_KWLIST_KEYWORDS5]));
327      ::SendDlgItemMessage(_hSelf, IDC_KEYWORD6_EDIT, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(_pUserLang->_keywordLists[SCE_USER_KWLIST_KEYWORDS6]));
328      ::SendDlgItemMessage(_hSelf, IDC_KEYWORD7_EDIT, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(_pUserLang->_keywordLists[SCE_USER_KWLIST_KEYWORDS7]));
329      ::SendDlgItemMessage(_hSelf, IDC_KEYWORD8_EDIT, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(_pUserLang->_keywordLists[SCE_USER_KWLIST_KEYWORDS8]));
330      ::SendDlgItemMessage(_hSelf, IDC_KEYWORD1_PREFIX_CHECK, BM_SETCHECK, _pUserLang->_isPrefix[0], 0);
331      ::SendDlgItemMessage(_hSelf, IDC_KEYWORD2_PREFIX_CHECK, BM_SETCHECK, _pUserLang->_isPrefix[1], 0);
332      ::SendDlgItemMessage(_hSelf, IDC_KEYWORD3_PREFIX_CHECK, BM_SETCHECK, _pUserLang->_isPrefix[2], 0);
333      ::SendDlgItemMessage(_hSelf, IDC_KEYWORD4_PREFIX_CHECK, BM_SETCHECK, _pUserLang->_isPrefix[3], 0);
334      ::SendDlgItemMessage(_hSelf, IDC_KEYWORD5_PREFIX_CHECK, BM_SETCHECK, _pUserLang->_isPrefix[4], 0);
335      ::SendDlgItemMessage(_hSelf, IDC_KEYWORD6_PREFIX_CHECK, BM_SETCHECK, _pUserLang->_isPrefix[5], 0);
336      ::SendDlgItemMessage(_hSelf, IDC_KEYWORD7_PREFIX_CHECK, BM_SETCHECK, _pUserLang->_isPrefix[6], 0);
337      ::SendDlgItemMessage(_hSelf, IDC_KEYWORD8_PREFIX_CHECK, BM_SETCHECK, _pUserLang->_isPrefix[7], 0);
338  }
339  intptr_t CALLBACK CommentStyleDialog::run_dlgProc(UINT Message, WPARAM wParam, LPARAM lParam)
340  {
341      switch (Message)
342      {
343          case WM_ACTIVATE :
344          case WM_SHOWWINDOW :
345          {
346              ::SendDlgItemMessage(_hSelf, IDC_ALLOW_ANYWHERE,    BM_SETCHECK, _pUserLang->_forcePureLC == PURE_LC_NONE, 0);
347              ::SendDlgItemMessage(_hSelf, IDC_FORCE_AT_BOL,      BM_SETCHECK, _pUserLang->_forcePureLC == PURE_LC_BOL,  0);
348              ::SendDlgItemMessage(_hSelf, IDC_ALLOW_WHITESPACE,  BM_SETCHECK, _pUserLang->_forcePureLC == PURE_LC_WSP,  0);
349              ::SendDlgItemMessage(_hSelf, IDC_DOT_RADIO,         BM_SETCHECK, _pUserLang->_decimalSeparator == DECSEP_DOT,   0);
350              ::SendDlgItemMessage(_hSelf, IDC_COMMA_RADIO,       BM_SETCHECK, _pUserLang->_decimalSeparator == DECSEP_COMMA, 0);
351              ::SendDlgItemMessage(_hSelf, IDC_BOTH_RADIO,        BM_SETCHECK, _pUserLang->_decimalSeparator == DECSEP_BOTH,  0);
352              return SharedParametersDialog::run_dlgProc(Message, wParam, lParam);
353          }
354          case WM_COMMAND :
355          {
356              switch (wParam)
357              {
358                  case IDC_FOLDING_OF_COMMENTS :
359                  {
360                      return setPropertyByCheck(_hSelf, wParam, _pUserLang->_allowFoldOfComments);
361                  }
362                  case IDC_ALLOW_ANYWHERE :
363                  case IDC_FORCE_AT_BOL :
364                  case IDC_ALLOW_WHITESPACE :
365                  {
366                      if (BST_CHECKED == ::SendMessage(::GetDlgItem(_hSelf, IDC_ALLOW_ANYWHERE), BM_GETCHECK, 0, 0))
367                          _pUserLang->_forcePureLC = PURE_LC_NONE;
368                      else if (BST_CHECKED == ::SendMessage(::GetDlgItem(_hSelf, IDC_FORCE_AT_BOL), BM_GETCHECK, 0, 0))
369                          _pUserLang->_forcePureLC = PURE_LC_BOL;
370                      else if (BST_CHECKED == ::SendMessage(::GetDlgItem(_hSelf, IDC_ALLOW_WHITESPACE), BM_GETCHECK, 0, 0))
371                          _pUserLang->_forcePureLC = PURE_LC_WSP;
372                      if (_pScintilla->getCurrentBuffer()->getLangType() == L_USER)
373                          _pScintilla->styleChange();
374                      return TRUE;
375                  }
376                  case IDC_DOT_RADIO :
377                  case IDC_COMMA_RADIO :
378                  case IDC_BOTH_RADIO :
379                  {
380                      if (BST_CHECKED == ::SendMessage(::GetDlgItem(_hSelf, IDC_DOT_RADIO), BM_GETCHECK, 0, 0))
381                          _pUserLang->_decimalSeparator = DECSEP_DOT;
382                      else if (BST_CHECKED == ::SendMessage(::GetDlgItem(_hSelf, IDC_COMMA_RADIO), BM_GETCHECK, 0, 0))
383                          _pUserLang->_decimalSeparator = DECSEP_COMMA;
384                      else if (BST_CHECKED == ::SendMessage(::GetDlgItem(_hSelf, IDC_BOTH_RADIO), BM_GETCHECK, 0, 0))
385                          _pUserLang->_decimalSeparator = DECSEP_BOTH;
386                      if (_pScintilla->getCurrentBuffer()->getLangType() == L_USER)
387                          _pScintilla->styleChange();
388                      return TRUE;
389                  }
390                  case IDC_COMMENTLINE_STYLER :
391                  {
392                      StylerDlg stylerDlg(_hInst, _hSelf, SCE_USER_STYLE_COMMENTLINE);
393                      stylerDlg.doDialog();
394                      return TRUE;
395                  }
396                  case IDC_COMMENT_STYLER :
397                  {
398                      StylerDlg stylerDlg(_hInst, _hSelf, SCE_USER_STYLE_COMMENT);
399                      stylerDlg.doDialog();
400                      return TRUE;
401                  }
402                  case IDC_NUMBER_STYLER :
403                  {
404                      StylerDlg stylerDlg(_hInst, _hSelf, SCE_USER_STYLE_NUMBER, SCE_USER_MASK_NESTING_NONE);
405                      stylerDlg.doDialog();
406                      return TRUE;
407                  }
408                  default :
409                      return SharedParametersDialog::run_dlgProc(Message, wParam, lParam);
410              }
411          }
412          default :
413              return SharedParametersDialog::run_dlgProc(Message, wParam, lParam);
414      }
415  }
416  void CommentStyleDialog::setKeywords2List(int id)
417  {
418      int index = 0;
419      switch (id)
420      {
421          case IDC_NUMBER_PREFIX1_EDIT :
422          case IDC_NUMBER_PREFIX2_EDIT :
423          case IDC_NUMBER_EXTRAS1_EDIT :
424          case IDC_NUMBER_EXTRAS2_EDIT :
425          case IDC_NUMBER_SUFFIX1_EDIT :
426          case IDC_NUMBER_SUFFIX2_EDIT :
427          case IDC_NUMBER_RANGE_EDIT :  
428          {
429              ::GetDlgItemText(_hSelf, id, _pUserLang->_keywordLists[globalMappper().dialogMapper[id]], max_char);
430              break;
431          }
432          case IDC_COMMENT_OPEN_EDIT :
433          case IDC_COMMENT_CLOSE_EDIT :
434          case IDC_COMMENTLINE_OPEN_EDIT :
435          case IDC_COMMENTLINE_CONTINUE_EDIT :
436          case IDC_COMMENTLINE_CLOSE_EDIT :
437              index = SCE_USER_KWLIST_COMMENTS;
438              break;
439          default : index = -1;
440      }
441      if (index != -1)
442      {
443          TCHAR* newList = new TCHAR[max_char];
444          newList[0] = '\0';
445          TCHAR* buffer = new TCHAR[max_char];
446          buffer[0] = '\0';
447          const int list[] = {
448              IDC_COMMENTLINE_OPEN_EDIT,
449              IDC_COMMENTLINE_CONTINUE_EDIT,
450              IDC_COMMENTLINE_CLOSE_EDIT,
451              IDC_COMMENT_OPEN_EDIT,
452              IDC_COMMENT_CLOSE_EDIT
453          };
454          TCHAR intBuffer[10] = { '0', 0 };
455          for (int i = 0; static_cast<size_t>(i) < sizeof(list) / sizeof(int); ++i)
456          {
457              _itow(i, intBuffer + 1, 10);
458              ::GetDlgItemText(_hSelf, list[i], buffer, max_char);
459              convertTo(newList, max_char, buffer, intBuffer);
460          }
461  		wcscpy_s(_pUserLang->_keywordLists[index], newList);
462          delete[] newList;
463          delete[] buffer;
464      }
465  }
466  void CommentStyleDialog::retrieve(TCHAR *dest, const TCHAR *toRetrieve, const TCHAR *prefix) const
467  {
468      int j = 0;
469      bool begin2Copy = false;
470      bool inGroup = false;
471      for (size_t i = 0, len = lstrlen(toRetrieve); i < len ; ++i)
472      {
473          if ((i == 0 || (toRetrieve[i-1] == ' ')) && (toRetrieve[i] == prefix[0] && toRetrieve[i+1] == prefix[1]))
474          {
475              if (j > 0)
476                  dest[j++] = ' ';
477              begin2Copy = true;
478              ++i;
479              continue;
480          }
481          if (toRetrieve[i] == '(' && toRetrieve[i+1] == '(' && inGroup == false && begin2Copy == true)
482          {
483              inGroup = true;
484          }
485          if (toRetrieve[i] != ')' && toRetrieve[i-1] == ')' && toRetrieve[i-2] == ')' && inGroup == true)
486          {
487              inGroup = false;
488          }
489          if (toRetrieve[i] == ' ' && begin2Copy == true)
490          {
491              begin2Copy = false;
492          }
493          if (begin2Copy || inGroup)
494              dest[j++] = toRetrieve[i];
495      }
496      dest[j++] = '\0';
497  }
498  void CommentStyleDialog::updateDlg()
499  {
500      TCHAR* buffer = new TCHAR[max_char];
501      buffer[0] = '\0';
502      const int list[] = {
503          IDC_COMMENTLINE_OPEN_EDIT,
504          IDC_COMMENTLINE_CONTINUE_EDIT,
505          IDC_COMMENTLINE_CLOSE_EDIT,
506          IDC_COMMENT_OPEN_EDIT,
507          IDC_COMMENT_CLOSE_EDIT
508      };
509      TCHAR intBuffer[10] = { '0', 0 };
510      for (int i = 0; static_cast<size_t>(i) < sizeof(list) / sizeof(int); ++i)
511      {
512          _itow(i, intBuffer + 1, 10);
513          retrieve(buffer, _pUserLang->_keywordLists[SCE_USER_KWLIST_COMMENTS], intBuffer);
514          ::SendDlgItemMessage(_hSelf, list[i], WM_SETTEXT, 0, reinterpret_cast<LPARAM>(buffer));
515      }
516      ::SendDlgItemMessage(_hSelf, IDC_FOLDING_OF_COMMENTS,   BM_SETCHECK, _pUserLang->_allowFoldOfComments,    0);
517      ::SendDlgItemMessage(_hSelf, IDC_ALLOW_ANYWHERE,        BM_SETCHECK, _pUserLang->_forcePureLC == PURE_LC_NONE, 0);
518      ::SendDlgItemMessage(_hSelf, IDC_FORCE_AT_BOL,          BM_SETCHECK, _pUserLang->_forcePureLC == PURE_LC_BOL,  0);
519      ::SendDlgItemMessage(_hSelf, IDC_ALLOW_WHITESPACE,      BM_SETCHECK, _pUserLang->_forcePureLC == PURE_LC_WSP,  0);
520      ::SendDlgItemMessage(_hSelf, IDC_DOT_RADIO,             BM_SETCHECK, _pUserLang->_decimalSeparator == DECSEP_DOT, 0);
521      ::SendDlgItemMessage(_hSelf, IDC_COMMA_RADIO,           BM_SETCHECK, _pUserLang->_decimalSeparator == DECSEP_COMMA,  0);
522      ::SendDlgItemMessage(_hSelf, IDC_BOTH_RADIO,            BM_SETCHECK, _pUserLang->_decimalSeparator == DECSEP_BOTH,  0);
523      ::SendDlgItemMessage(_hSelf, IDC_NUMBER_PREFIX1_EDIT,    WM_SETTEXT, 0, reinterpret_cast<LPARAM>(_pUserLang->_keywordLists[SCE_USER_KWLIST_NUMBER_PREFIX1]));
524      ::SendDlgItemMessage(_hSelf, IDC_NUMBER_PREFIX2_EDIT,    WM_SETTEXT, 0, reinterpret_cast<LPARAM>(_pUserLang->_keywordLists[SCE_USER_KWLIST_NUMBER_PREFIX2]));
525      ::SendDlgItemMessage(_hSelf, IDC_NUMBER_EXTRAS1_EDIT,    WM_SETTEXT, 0, reinterpret_cast<LPARAM>(_pUserLang->_keywordLists[SCE_USER_KWLIST_NUMBER_EXTRAS1]));
526      ::SendDlgItemMessage(_hSelf, IDC_NUMBER_EXTRAS2_EDIT,    WM_SETTEXT, 0, reinterpret_cast<LPARAM>(_pUserLang->_keywordLists[SCE_USER_KWLIST_NUMBER_EXTRAS2]));
527      ::SendDlgItemMessage(_hSelf, IDC_NUMBER_SUFFIX1_EDIT,    WM_SETTEXT, 0, reinterpret_cast<LPARAM>(_pUserLang->_keywordLists[SCE_USER_KWLIST_NUMBER_SUFFIX1]));
528      ::SendDlgItemMessage(_hSelf, IDC_NUMBER_SUFFIX2_EDIT,    WM_SETTEXT, 0, reinterpret_cast<LPARAM>(_pUserLang->_keywordLists[SCE_USER_KWLIST_NUMBER_SUFFIX2]));
529      ::SendDlgItemMessage(_hSelf, IDC_NUMBER_RANGE_EDIT,      WM_SETTEXT, 0, reinterpret_cast<LPARAM>(_pUserLang->_keywordLists[SCE_USER_KWLIST_NUMBER_RANGE]));
530      delete[] buffer;
531  }
532  void SymbolsStyleDialog::updateDlg()
533  {
534      TCHAR* buffer = new TCHAR[max_char];
535      buffer[0] = '\0';
536      const int list[] = {
537          IDC_DELIMITER1_BOUNDARYOPEN_EDIT,
538          IDC_DELIMITER1_ESCAPE_EDIT,
539          IDC_DELIMITER1_BOUNDARYCLOSE_EDIT,
540          IDC_DELIMITER2_BOUNDARYOPEN_EDIT,
541          IDC_DELIMITER2_ESCAPE_EDIT,
542          IDC_DELIMITER2_BOUNDARYCLOSE_EDIT,
543          IDC_DELIMITER3_BOUNDARYOPEN_EDIT,
544          IDC_DELIMITER3_ESCAPE_EDIT,
545          IDC_DELIMITER3_BOUNDARYCLOSE_EDIT,
546          IDC_DELIMITER4_BOUNDARYOPEN_EDIT,
547          IDC_DELIMITER4_ESCAPE_EDIT,
548          IDC_DELIMITER4_BOUNDARYCLOSE_EDIT,
549          IDC_DELIMITER5_BOUNDARYOPEN_EDIT,
550          IDC_DELIMITER5_ESCAPE_EDIT,
551          IDC_DELIMITER5_BOUNDARYCLOSE_EDIT,
552          IDC_DELIMITER6_BOUNDARYOPEN_EDIT,
553          IDC_DELIMITER6_ESCAPE_EDIT,
554          IDC_DELIMITER6_BOUNDARYCLOSE_EDIT,
555          IDC_DELIMITER7_BOUNDARYOPEN_EDIT,
556          IDC_DELIMITER7_ESCAPE_EDIT,
557          IDC_DELIMITER7_BOUNDARYCLOSE_EDIT,
558          IDC_DELIMITER8_BOUNDARYOPEN_EDIT,
559          IDC_DELIMITER8_ESCAPE_EDIT,
560          IDC_DELIMITER8_BOUNDARYCLOSE_EDIT
561      };
562      TCHAR intBuffer[10] = {'0', 0};
563      for (int i = 0; static_cast<size_t>(i) < sizeof(list)/sizeof(int); ++i)
564      {
565          if (i < 10)
566              _itow(i, intBuffer + 1, 10);
567          else
568              _itow(i, intBuffer, 10);
569          retrieve(buffer, _pUserLang->_keywordLists[SCE_USER_KWLIST_DELIMITERS], intBuffer);
570  		::SendDlgItemMessage(_hSelf, list[i], WM_SETTEXT, 0, reinterpret_cast<LPARAM>(buffer));
571      }
572      delete[] buffer;
573      ::SendDlgItemMessage(_hSelf, IDC_OPERATOR1_EDIT, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(_pUserLang->_keywordLists[SCE_USER_KWLIST_OPERATORS1]));
574      ::SendDlgItemMessage(_hSelf, IDC_OPERATOR2_EDIT, WM_SETTEXT, 0, reinterpret_cast<LPARAM>(_pUserLang->_keywordLists[SCE_USER_KWLIST_OPERATORS2]));
575  }
576  intptr_t CALLBACK SymbolsStyleDialog::run_dlgProc(UINT Message, WPARAM wParam, LPARAM lParam)
577  {
578      switch (Message)
579      {
580          case WM_COMMAND :
581          {
582              switch (wParam)
583              {
584                  case IDC_OPERATOR_STYLER :
585                  {
586                      StylerDlg stylerDlg(_hInst, _hSelf, SCE_USER_STYLE_OPERATOR, SCE_USER_MASK_NESTING_NONE);
587                      stylerDlg.doDialog();
588                      return TRUE;
589                  }
590                  case IDC_DELIMITER1_STYLER :
591                  {
592                      StylerDlg stylerDlg(_hInst, _hSelf, SCE_USER_STYLE_DELIMITER1);
593                      stylerDlg.doDialog();
594                      return TRUE;
595                  }
596                  case IDC_DELIMITER2_STYLER :
597                  {
598                      StylerDlg stylerDlg(_hInst, _hSelf, SCE_USER_STYLE_DELIMITER2);
599                      stylerDlg.doDialog();
600                      return TRUE;
601                  }
602                  case IDC_DELIMITER3_STYLER :
603                  {
604                      StylerDlg stylerDlg(_hInst, _hSelf, SCE_USER_STYLE_DELIMITER3);
605                      stylerDlg.doDialog();
606                      return TRUE;
607                  }
608                  case IDC_DELIMITER4_STYLER :
609                  {
610                      StylerDlg stylerDlg(_hInst, _hSelf, SCE_USER_STYLE_DELIMITER4);
611                      stylerDlg.doDialog();
612                      return TRUE;
613                  }
614                  case IDC_DELIMITER5_STYLER :
615                  {
616                      StylerDlg stylerDlg(_hInst, _hSelf, SCE_USER_STYLE_DELIMITER5);
617                      stylerDlg.doDialog();
618                      return TRUE;
619                  }
620                  case IDC_DELIMITER6_STYLER :
621                  {
622                      StylerDlg stylerDlg(_hInst, _hSelf, SCE_USER_STYLE_DELIMITER6);
623                      stylerDlg.doDialog();
624                      return TRUE;
625                  }
626                  case IDC_DELIMITER7_STYLER :
627                  {
628                      StylerDlg stylerDlg(_hInst, _hSelf, SCE_USER_STYLE_DELIMITER7);
629                      stylerDlg.doDialog();
630                      return TRUE;
631                  }
632                  case IDC_DELIMITER8_STYLER :
633                  {
634                      StylerDlg stylerDlg(_hInst, _hSelf, SCE_USER_STYLE_DELIMITER8);
635                      stylerDlg.doDialog();
636                      return TRUE;
637                  }
638                  default :
639                      return SharedParametersDialog::run_dlgProc(Message, wParam, lParam);
640              }
641          }
642          default :
643              return SharedParametersDialog::run_dlgProc(Message, wParam, lParam);
644      }
645  }
646  void SymbolsStyleDialog::retrieve(TCHAR *dest, const TCHAR *toRetrieve, TCHAR *prefix) const
647  {
648      int j = 0;
649      bool begin2Copy = false;
650      bool inGroup = false;
651      for (size_t i = 0, len = lstrlen(toRetrieve); i < len ; ++i)
652      {
653          if ((i == 0 || (toRetrieve[i-1] == ' ')) && (toRetrieve[i] == prefix[0] && toRetrieve[i+1] == prefix[1]))
654          {
655              if (j > 0)
656                  dest[j++] = ' ';
657              begin2Copy = true;
658              ++i;
659              continue;
660          }
661          if (toRetrieve[i] == '(' && toRetrieve[i+1] == '(' && inGroup == false && begin2Copy == true)
662          {
663              inGroup = true;
664          }
665          if (toRetrieve[i] != ')' && toRetrieve[i-1] == ')' && toRetrieve[i-2] == ')' && inGroup == true)
666          {
667              inGroup = false;
668          }
669          if (toRetrieve[i] == ' ' && begin2Copy == true)
670          {
671              begin2Copy = false;
672          }
673          if (begin2Copy || inGroup)
674              dest[j++] = toRetrieve[i];
675      }
676      dest[j++] = '\0';
677  }
678  void SymbolsStyleDialog::setKeywords2List(int id)
679  {
680      switch (id)
681      {
682          case IDC_OPERATOR1_EDIT :
683              ::GetDlgItemText(_hSelf, id, _pUserLang->_keywordLists[SCE_USER_KWLIST_OPERATORS1], max_char);
684              break;
685          case IDC_OPERATOR2_EDIT :
686              ::GetDlgItemText(_hSelf, id, _pUserLang->_keywordLists[SCE_USER_KWLIST_OPERATORS2], max_char);
687              break;
688          case IDC_DELIMITER1_BOUNDARYOPEN_EDIT :
689          case IDC_DELIMITER1_ESCAPE_EDIT :
690          case IDC_DELIMITER1_BOUNDARYCLOSE_EDIT :
691          case IDC_DELIMITER2_BOUNDARYOPEN_EDIT :
692          case IDC_DELIMITER2_ESCAPE_EDIT :
693          case IDC_DELIMITER2_BOUNDARYCLOSE_EDIT :
694          case IDC_DELIMITER3_BOUNDARYOPEN_EDIT :
695          case IDC_DELIMITER3_ESCAPE_EDIT :
696          case IDC_DELIMITER3_BOUNDARYCLOSE_EDIT :
697          case IDC_DELIMITER4_BOUNDARYOPEN_EDIT :
698          case IDC_DELIMITER4_ESCAPE_EDIT :
699          case IDC_DELIMITER4_BOUNDARYCLOSE_EDIT :
700          case IDC_DELIMITER5_BOUNDARYOPEN_EDIT :
701          case IDC_DELIMITER5_ESCAPE_EDIT :
702          case IDC_DELIMITER5_BOUNDARYCLOSE_EDIT :
703          case IDC_DELIMITER6_BOUNDARYOPEN_EDIT :
704          case IDC_DELIMITER6_ESCAPE_EDIT :
705          case IDC_DELIMITER6_BOUNDARYCLOSE_EDIT :
706          case IDC_DELIMITER7_BOUNDARYOPEN_EDIT :
707          case IDC_DELIMITER7_ESCAPE_EDIT :
708          case IDC_DELIMITER7_BOUNDARYCLOSE_EDIT :
709          case IDC_DELIMITER8_BOUNDARYOPEN_EDIT :
710          case IDC_DELIMITER8_ESCAPE_EDIT :
711          case IDC_DELIMITER8_BOUNDARYCLOSE_EDIT :
712          {
713              TCHAR* newList = new TCHAR[max_char];
714              newList[0] = '\0';
715              TCHAR* buffer = new TCHAR[max_char];
716              buffer[0] = '\0';
717              TCHAR intBuffer[10] = {'0', 0};
718              const int list[] = {
719                  IDC_DELIMITER1_BOUNDARYOPEN_EDIT,
720                  IDC_DELIMITER1_ESCAPE_EDIT,
721                  IDC_DELIMITER1_BOUNDARYCLOSE_EDIT,
722                  IDC_DELIMITER2_BOUNDARYOPEN_EDIT,
723                  IDC_DELIMITER2_ESCAPE_EDIT,
724                  IDC_DELIMITER2_BOUNDARYCLOSE_EDIT,
725                  IDC_DELIMITER3_BOUNDARYOPEN_EDIT,
726                  IDC_DELIMITER3_ESCAPE_EDIT,
727                  IDC_DELIMITER3_BOUNDARYCLOSE_EDIT,
728                  IDC_DELIMITER4_BOUNDARYOPEN_EDIT,
729                  IDC_DELIMITER4_ESCAPE_EDIT,
730                  IDC_DELIMITER4_BOUNDARYCLOSE_EDIT,
731                  IDC_DELIMITER5_BOUNDARYOPEN_EDIT,
732                  IDC_DELIMITER5_ESCAPE_EDIT,
733                  IDC_DELIMITER5_BOUNDARYCLOSE_EDIT,
734                  IDC_DELIMITER6_BOUNDARYOPEN_EDIT,
735                  IDC_DELIMITER6_ESCAPE_EDIT,
736                  IDC_DELIMITER6_BOUNDARYCLOSE_EDIT,
737                  IDC_DELIMITER7_BOUNDARYOPEN_EDIT,
738                  IDC_DELIMITER7_ESCAPE_EDIT,
739                  IDC_DELIMITER7_BOUNDARYCLOSE_EDIT,
740                  IDC_DELIMITER8_BOUNDARYOPEN_EDIT,
741                  IDC_DELIMITER8_ESCAPE_EDIT,
742                  IDC_DELIMITER8_BOUNDARYCLOSE_EDIT
743              };
744              for (int i = 0; static_cast<size_t>(i) < sizeof(list)/sizeof(int); ++i)
745              {
746                  if (i < 10)
747                      _itow(i, intBuffer+1, 10);
748                  else
749                      _itow(i, intBuffer, 10);
750                  int dd = list[i];
751                  ::GetDlgItemText(_hSelf, dd, buffer, max_char);
752                  convertTo(newList, max_char, buffer, intBuffer);
753              }
754  			wcscpy_s(_pUserLang->_keywordLists[SCE_USER_KWLIST_DELIMITERS], newList);
755              delete[] newList;
756              delete[] buffer;
757              break;
758          }
759          default :
760              break;
761      }
762  }
763  UserDefineDialog::UserDefineDialog(): SharedParametersDialog()
764  {
765      _pCurrentUserLang = new UserLangContainer();
766      _pCurrentUserLang->_styles.addStyler(SCE_USER_STYLE_DEFAULT,              globalMappper().styleNameMapper[SCE_USER_STYLE_DEFAULT].c_str());
767      _pCurrentUserLang->_styles.addStyler(SCE_USER_STYLE_COMMENT,              globalMappper().styleNameMapper[SCE_USER_STYLE_COMMENT].c_str());
768      _pCurrentUserLang->_styles.addStyler(SCE_USER_STYLE_COMMENTLINE,          globalMappper().styleNameMapper[SCE_USER_STYLE_COMMENTLINE].c_str());
769      _pCurrentUserLang->_styles.addStyler(SCE_USER_STYLE_NUMBER,               globalMappper().styleNameMapper[SCE_USER_STYLE_NUMBER].c_str());
770      _pCurrentUserLang->_styles.addStyler(SCE_USER_STYLE_KEYWORD1,             globalMappper().styleNameMapper[SCE_USER_STYLE_KEYWORD1].c_str());
771      _pCurrentUserLang->_styles.addStyler(SCE_USER_STYLE_KEYWORD2,             globalMappper().styleNameMapper[SCE_USER_STYLE_KEYWORD2].c_str());
772      _pCurrentUserLang->_styles.addStyler(SCE_USER_STYLE_KEYWORD3,             globalMappper().styleNameMapper[SCE_USER_STYLE_KEYWORD3].c_str());
773      _pCurrentUserLang->_styles.addStyler(SCE_USER_STYLE_KEYWORD4,             globalMappper().styleNameMapper[SCE_USER_STYLE_KEYWORD4].c_str());
774      _pCurrentUserLang->_styles.addStyler(SCE_USER_STYLE_KEYWORD5,             globalMappper().styleNameMapper[SCE_USER_STYLE_KEYWORD5].c_str());
775      _pCurrentUserLang->_styles.addStyler(SCE_USER_STYLE_KEYWORD6,             globalMappper().styleNameMapper[SCE_USER_STYLE_KEYWORD6].c_str());
776      _pCurrentUserLang->_styles.addStyler(SCE_USER_STYLE_KEYWORD7,             globalMappper().styleNameMapper[SCE_USER_STYLE_KEYWORD7].c_str());
777      _pCurrentUserLang->_styles.addStyler(SCE_USER_STYLE_KEYWORD8,             globalMappper().styleNameMapper[SCE_USER_STYLE_KEYWORD8].c_str());
778      _pCurrentUserLang->_styles.addStyler(SCE_USER_STYLE_OPERATOR,             globalMappper().styleNameMapper[SCE_USER_STYLE_OPERATOR].c_str());
779      _pCurrentUserLang->_styles.addStyler(SCE_USER_STYLE_FOLDER_IN_CODE1,      globalMappper().styleNameMapper[SCE_USER_STYLE_FOLDER_IN_CODE1].c_str());
780      _pCurrentUserLang->_styles.addStyler(SCE_USER_STYLE_FOLDER_IN_CODE2,      globalMappper().styleNameMapper[SCE_USER_STYLE_FOLDER_IN_CODE2].c_str());
781      _pCurrentUserLang->_styles.addStyler(SCE_USER_STYLE_FOLDER_IN_COMMENT,    globalMappper().styleNameMapper[SCE_USER_STYLE_FOLDER_IN_COMMENT].c_str());
782      _pCurrentUserLang->_styles.addStyler(SCE_USER_STYLE_DELIMITER1,           globalMappper().styleNameMapper[SCE_USER_STYLE_DELIMITER1].c_str());
783      _pCurrentUserLang->_styles.addStyler(SCE_USER_STYLE_DELIMITER2,           globalMappper().styleNameMapper[SCE_USER_STYLE_DELIMITER2].c_str());
784      _pCurrentUserLang->_styles.addStyler(SCE_USER_STYLE_DELIMITER3,           globalMappper().styleNameMapper[SCE_USER_STYLE_DELIMITER3].c_str());
785      _pCurrentUserLang->_styles.addStyler(SCE_USER_STYLE_DELIMITER4,           globalMappper().styleNameMapper[SCE_USER_STYLE_DELIMITER4].c_str());
786      _pCurrentUserLang->_styles.addStyler(SCE_USER_STYLE_DELIMITER5,           globalMappper().styleNameMapper[SCE_USER_STYLE_DELIMITER5].c_str());
787      _pCurrentUserLang->_styles.addStyler(SCE_USER_STYLE_DELIMITER6,           globalMappper().styleNameMapper[SCE_USER_STYLE_DELIMITER6].c_str());
788      _pCurrentUserLang->_styles.addStyler(SCE_USER_STYLE_DELIMITER7,           globalMappper().styleNameMapper[SCE_USER_STYLE_DELIMITER7].c_str());
789      _pCurrentUserLang->_styles.addStyler(SCE_USER_STYLE_DELIMITER8,           globalMappper().styleNameMapper[SCE_USER_STYLE_DELIMITER8].c_str());
790  }
791  UserDefineDialog::~UserDefineDialog()
792  {
793      delete _pCurrentUserLang;
794  }
795  void UserDefineDialog::reloadLangCombo()
796  {
797      NppParameters& nppParam = NppParameters::getInstance();
798      ::SendDlgItemMessage(_hSelf, IDC_LANGNAME_COMBO, CB_RESETCONTENT, 0, 0);
799  	::SendDlgItemMessage(_hSelf, IDC_LANGNAME_COMBO, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(TEXT("User Defined Language")));
800      for (int i = 0, nb = nppParam.getNbUserLang(); i < nb ; ++i)
801      {
802          UserLangContainer & userLangContainer = nppParam.getULCFromIndex(i);
803  		::SendDlgItemMessage(_hSelf, IDC_LANGNAME_COMBO, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(userLangContainer.getName()));
804      }
805  }
806  void UserDefineDialog::changeStyle()
807  {
808      _status = !_status;
809      NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
810      TiXmlNodeA *targetNode = nullptr;
811      if (pNativeSpeaker->getNativeLangA())
812      {
813          targetNode = (pNativeSpeaker->getNativeLangA())->FirstChildElement("Dialog");
814          if (targetNode)
815              targetNode = targetNode->FirstChildElement("UserDefine");
816      }
817      generic_string dockButtonLabel;
818      generic_string defauleLabel;
819      string idStr;
820      if (_status == DOCK)
821      {
822          defauleLabel = TEXT("Undock");
823          idStr = std::to_string(IDC_UNDOCK_BUTTON);
824      }
825      else
826      {
827          defauleLabel = TEXT("Dock");
828          idStr = std::to_string(IDC_DOCK_BUTTON);
829      }
830      dockButtonLabel = pNativeSpeaker->getAttrNameByIdStr(defauleLabel.c_str(), targetNode, idStr.c_str());
831      ::SetDlgItemText(_hSelf, IDC_DOCK_BUTTON, dockButtonLabel.c_str());
832      auto style = ::GetWindowLongPtr(_hSelf, GWL_STYLE);
833      if (!style)
834          ::MessageBox(NULL, TEXT("GetWindowLongPtr failed in UserDefineDialog::changeStyle()"), TEXT(""), MB_OK);
835      style = (_status == DOCK)?
836          ((style & ~WS_POPUP) & ~DS_MODALFRAME & ~WS_CAPTION) | WS_CHILD :
837          (style & ~WS_CHILD) | WS_POPUP | DS_MODALFRAME | WS_CAPTION;
838      auto result = ::SetWindowLongPtr(_hSelf, GWL_STYLE, style);
839      if (!result)
840          ::MessageBox(NULL, TEXT("SetWindowLongPtr failed in UserDefineDialog::changeStyle()"), TEXT(""), MB_OK);
841      if (_status == DOCK)
842          getActualPosSize();
843      else
844          restorePosSize();
845      ::SetParent(_hSelf, (_status == DOCK)?_hParent:NULL);
846  }
847  void UserDefineDialog::enableLangAndControlsBy(size_t index)
848  {
849      _pUserLang = (index == 0)?_pCurrentUserLang:&((NppParameters::getInstance()).getULCFromIndex(index - 1));
850      if (index != 0)
851          ::SetWindowText(::GetDlgItem(_hSelf, IDC_EXT_EDIT), _pUserLang->_ext.c_str());
852      ::ShowWindow(::GetDlgItem(_hSelf, IDC_EXT_STATIC), (index == 0)?SW_HIDE:SW_SHOW);
853      ::ShowWindow(::GetDlgItem(_hSelf, IDC_EXT_EDIT), (index == 0)?SW_HIDE:SW_SHOW);
854      ::ShowWindow(::GetDlgItem(_hSelf, IDC_RENAME_BUTTON), (index == 0)?SW_HIDE:SW_SHOW);
855      ::ShowWindow(::GetDlgItem(_hSelf, IDC_REMOVELANG_BUTTON), (index == 0)?SW_HIDE:SW_SHOW);
856  }
857  void UserDefineDialog::updateDlg()
858  {
859  	int i = static_cast<int32_t>(::SendDlgItemMessage(_hSelf, IDC_LANGNAME_COMBO, CB_GETCURSEL, 0, 0));
860  	if (i > 0) 
861  	{
862  		NppParameters& nppParam = NppParameters::getInstance();
863  		nppParam.setUdlXmlDirtyFromIndex(i - 1);
864  	}
865      ::SendDlgItemMessage(_hSelf, IDC_LANGNAME_IGNORECASE_CHECK, BM_SETCHECK, _pUserLang->_isCaseIgnored, 0);
866      _folderStyleDlg.updateDlg();
867      _keyWordsStyleDlg.updateDlg();
868      _commentStyleDlg.updateDlg();
869      _symbolsStyleDlg.updateDlg();
870  }
871  intptr_t CALLBACK UserDefineDialog::run_dlgProc(UINT message, WPARAM wParam, LPARAM lParam)
872  {
873      NppParameters& nppParam = NppParameters::getInstance();
874  	NativeLangSpeaker * pNativeSpeaker = nppParam.getNativeLangSpeaker();
875      switch (message)
876      {
877          case WM_INITDIALOG :
878          {
879              _pUserLang = _pCurrentUserLang;
880              _ctrlTab.init(_hInst, _hSelf, false);
881              NppDarkMode::subclassTabControl(_ctrlTab.getHSelf());
882              int tabDpiDynamicalHeight = nppParam._dpiManager.scaleY(13);
883              _ctrlTab.setFont(TEXT("Tahoma"), tabDpiDynamicalHeight);
884              _folderStyleDlg.init(_hInst, _hSelf);
885              _folderStyleDlg.create(IDD_FOLDER_STYLE_DLG);
886              _folderStyleDlg.display();
887              _keyWordsStyleDlg.init(_hInst, _hSelf);
888              _keyWordsStyleDlg.create(IDD_KEYWORD_STYLE_DLG);
889              _keyWordsStyleDlg.display(false);
890              _commentStyleDlg.init(_hInst, _hSelf);
891              _commentStyleDlg.create(IDD_COMMENT_STYLE_DLG);
892              _commentStyleDlg.display(false);
893              _symbolsStyleDlg.init(_hInst, _hSelf);
894              _symbolsStyleDlg.create(IDD_SYMBOL_STYLE_DLG);
895              _symbolsStyleDlg.display(false);
896              _wVector.push_back(DlgInfo(&_folderStyleDlg,    TEXT("Folder && Default")));
897              _wVector.push_back(DlgInfo(&_keyWordsStyleDlg,  TEXT("Keywords Lists")));
898              _wVector.push_back(DlgInfo(&_commentStyleDlg,   TEXT("Comment && Number")));
899              _wVector.push_back(DlgInfo(&_symbolsStyleDlg,   TEXT("Operators && Delimiters")));
900              _ctrlTab.createTabs(_wVector);
901              _ctrlTab.display();
902              RECT arc{};
903              ::GetWindowRect(::GetDlgItem(_hSelf, IDC_IMPORT_BUTTON), &arc);
904              POINT p{};
905              p.x = arc.left;
906              p.y = arc.bottom;
907              ::ScreenToClient(_hSelf, &p);
908              RECT rc{};
909              getClientRect(rc);
910              rc.top = p.y + 10;
911              rc.bottom -= 20;
912              _ctrlTab.reSizeTo(rc);
913              _folderStyleDlg.reSizeTo(rc);
914              _keyWordsStyleDlg.reSizeTo(rc);
915              _commentStyleDlg.reSizeTo(rc);
916              _symbolsStyleDlg.reSizeTo(rc);
917              reloadLangCombo();
918              ::SendDlgItemMessage(_hSelf, IDC_LANGNAME_COMBO, CB_SETCURSEL, 0, 0);
919              enableLangAndControlsBy(0);
920              if (nppParam.isTransparentAvailable())
921              {
922                  ::ShowWindow(::GetDlgItem(_hSelf, IDC_UD_TRANSPARENT_CHECK), SW_SHOW);
923                  ::ShowWindow(::GetDlgItem(_hSelf, IDC_UD_PERCENTAGE_SLIDER), SW_SHOW);
924                  ::SendDlgItemMessage(_hSelf, IDC_UD_PERCENTAGE_SLIDER, TBM_SETRANGE, FALSE, MAKELONG(20, 200));
925                  ::SendDlgItemMessage(_hSelf, IDC_UD_PERCENTAGE_SLIDER, TBM_SETPOS, TRUE, 150);
926                  if (!(BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_UD_PERCENTAGE_SLIDER, BM_GETCHECK, 0, 0)))
927                      ::EnableWindow(::GetDlgItem(_hSelf, IDC_UD_PERCENTAGE_SLIDER), FALSE);
928              }
929              SCROLLINFO si{};
930              si.cbSize = sizeof(si);
931              si.fMask  = SIF_RANGE; 
932              si.nMin   = 0;
933              si.nMax   = 0;
934              ::SetScrollInfo(_hSelf, SB_VERT, &si, TRUE);
935              TCHAR temp[32] = { '\0' };
936              generic_string udlVersion = TEXT("User Defined Language v.");
937              udlVersion += _itow(SCE_UDL_VERSION_MAJOR, temp, 10);
938              udlVersion += TEXT(".");
939              udlVersion += _itow(SCE_UDL_VERSION_MINOR, temp, 10);
940              udlVersion += TEXT(".");
941              udlVersion += _itow(SCE_UDL_VERSION_BUILD, temp, 10);
942              udlVersion += TEXT(".");
943              udlVersion += _itow(SCE_UDL_VERSION_REVISION, temp, 10);
944              ::SetWindowText(_hSelf, udlVersion.c_str());
945              NppDarkMode::autoSubclassAndThemeChildControls(_hSelf);
946              NppDarkMode::setDarkScrollBar(_hSelf);
947              return TRUE;
948          }
949          case WM_CTLCOLOREDIT:
950          {
951              return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
952          }
953          case WM_CTLCOLORLISTBOX:
954          {
955              return NppDarkMode::onCtlColor(reinterpret_cast<HDC>(wParam));
956          }
957          case WM_CTLCOLORDLG:
958          case WM_CTLCOLORSTATIC:
959          {
960              return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
961          }
962          case WM_PRINTCLIENT:
963          {
964              if (NppDarkMode::isEnabled())
965              {
966                  return TRUE;
967              }
968              break;
969          }
970          case NPPM_INTERNAL_REFRESHDARKMODE:
971          {
972              NppDarkMode::autoThemeChildControls(_hSelf);
973              NppDarkMode::setDarkScrollBar(_hSelf);
974              return TRUE;
975          }
976          case WM_NOTIFY:
977          {
978              NMHDR *nmhdr = (NMHDR *)lParam;
979              if (nmhdr->code == TCN_SELCHANGE)
980              {
981                  if (nmhdr->hwndFrom == _ctrlTab.getHSelf())
982                  {
983                      _ctrlTab.clickedUpdate();
984                      return TRUE;
985                  }
986              }
987              break;
988          }
989          case WM_HSCROLL:
990          {
991              if (reinterpret_cast<HWND>(lParam) == ::GetDlgItem(_hSelf, IDC_UD_PERCENTAGE_SLIDER))
992              {
993  				int percent = static_cast<int32_t>(::SendDlgItemMessage(_hSelf, IDC_UD_PERCENTAGE_SLIDER, TBM_GETPOS, 0, 0));
994                  nppParam.SetTransparent(_hSelf, percent);
995              }
996              return TRUE;
997          }
998          case WM_COMMAND :
999          {
1000              if (HIWORD(wParam) == EN_CHANGE)
1001              {
1002                  TCHAR ext[extsLenMax] = { '\0' };
1003  				::SendDlgItemMessage(_hSelf, IDC_EXT_EDIT, WM_GETTEXT, extsLenMax, reinterpret_cast<LPARAM>(ext));
1004                  _pUserLang->_ext = ext;
1005                  return TRUE;
1006              }
1007              else if (HIWORD(wParam) == CBN_SELCHANGE)
1008              {
1009                  if (LOWORD(wParam) == IDC_LANGNAME_COMBO)
1010                  {
1011  					auto i = ::SendDlgItemMessage(_hSelf, LOWORD(wParam), CB_GETCURSEL, 0, 0);
1012                      enableLangAndControlsBy(i);
1013                      updateDlg();
1014                  }
1015                  return TRUE;
1016              }
1017              else
1018              {
1019                  switch (wParam)
1020                  {
1021                      case IDC_DOCK_BUTTON :
1022                      {
1023                          int msg = WM_UNDOCK_USERDEFINE_DLG;
1024                          if (_status == UNDOCK)
1025                          {
1026                              if (nppParam.isTransparentAvailable())
1027                              {
1028                                  nppParam.removeTransparent(_hSelf);
1029                                  ::ShowWindow(::GetDlgItem(_hSelf, IDC_UD_TRANSPARENT_CHECK), SW_HIDE);
1030                                  ::ShowWindow(::GetDlgItem(_hSelf, IDC_UD_PERCENTAGE_SLIDER), SW_HIDE);
1031                              }
1032                              msg = WM_DOCK_USERDEFINE_DLG;
1033                          }
1034                          changeStyle();
1035                          if (_status == UNDOCK)
1036                          {
1037                              if (nppParam.isTransparentAvailable())
1038                              {
1039                                  bool isChecked = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_UD_TRANSPARENT_CHECK, BM_GETCHECK, 0, 0));
1040                                  if (isChecked)
1041                                  {
1042  									int percent = static_cast<int32_t>(::SendDlgItemMessage(_hSelf, IDC_UD_PERCENTAGE_SLIDER, TBM_GETPOS, 0, 0));
1043                                      nppParam.SetTransparent(_hSelf, percent);
1044                                  }
1045                                  ::ShowWindow(::GetDlgItem(_hSelf, IDC_UD_TRANSPARENT_CHECK), SW_SHOW);
1046                                  ::ShowWindow(::GetDlgItem(_hSelf, IDC_UD_PERCENTAGE_SLIDER), SW_SHOW);
1047                              }
1048                          }
1049                          ::SendMessage(_hParent, msg, 0, 0);
1050                          return TRUE;
1051                      }
1052                      case IDCANCEL:
1053  					{
1054  						::SendMessage(_hParent, WM_CLOSE_USERDEFINE_DLG, 0, 0);
1055  						display(false);
1056  						return TRUE;
1057  					}
1058                      case IDC_REMOVELANG_BUTTON :
1059                      {
1060                          int result = nppParam.getNativeLangSpeaker()->messageBox("UDLRemoveCurrentLang",
1061  							_hSelf,
1062  							TEXT("Are you sure?"),
1063  							TEXT("Remove the current language"),
1064  							MB_YESNO);
1065                          if (result == IDYES)
1066                          {
1067                              auto i = ::SendDlgItemMessage(_hSelf, IDC_LANGNAME_COMBO, CB_GETCURSEL, 0, 0);
1068  							const size_t langNameLen = 256;
1069  							TCHAR langName[langNameLen + 1] = { '\0' };
1070  							auto cbTextLen = ::SendDlgItemMessage(_hSelf, IDC_LANGNAME_COMBO, CB_GETLBTEXTLEN, i, 0);
1071  							if (static_cast<size_t>(cbTextLen) > langNameLen)
1072  								return TRUE;
1073  							::SendDlgItemMessage(_hSelf, IDC_LANGNAME_COMBO, CB_GETLBTEXT, i, reinterpret_cast<LPARAM>(langName));
1074                              ::SendDlgItemMessage(_hSelf, IDC_LANGNAME_COMBO, CB_DELETESTRING, i, 0);
1075                              ::SendDlgItemMessage(_hSelf, IDC_LANGNAME_COMBO, CB_SETCURSEL, i-1, 0);
1076  							::SendMessage(_hSelf, WM_COMMAND, MAKELONG(IDC_LANGNAME_COMBO, CBN_SELCHANGE), reinterpret_cast<LPARAM>(::GetDlgItem(_hSelf, IDC_LANGNAME_COMBO)));
1077                              nppParam.removeUserLang(i-1);
1078                              HWND hNpp = ::GetParent(_hSelf);
1079  							HMENU m = reinterpret_cast<HMENU>(::SendMessage(hNpp, NPPM_INTERNAL_GETMENU, 0, 0));
1080  							HMENU subMenu = ::GetSubMenu(m, MENUINDEX_LANGUAGE);
1081  							::RemoveMenu(subMenu, static_cast<UINT>(IDM_LANG_USER + i), MF_BYCOMMAND);
1082                              ::DrawMenuBar(hNpp);
1083  							::SendMessage(_hParent, WM_REMOVE_USERLANG, 0, reinterpret_cast<LPARAM>(langName));
1084                          }
1085                          return TRUE;
1086                      }
1087                      case IDC_RENAME_BUTTON :
1088                      {
1089                          auto i = ::SendDlgItemMessage(_hSelf, IDC_LANGNAME_COMBO, CB_GETCURSEL, 0, 0);
1090  						const size_t langNameLen = 256;
1091  						TCHAR langName[langNameLen + 1] = { '\0' };
1092  						auto cbTextLen = ::SendDlgItemMessage(_hSelf, IDC_LANGNAME_COMBO, CB_GETLBTEXTLEN, i, 0);
1093  						if (static_cast<size_t>(cbTextLen) > langNameLen)
1094  							return TRUE;
1095  						::SendDlgItemMessage(_hSelf, IDC_LANGNAME_COMBO, CB_GETLBTEXT, i, reinterpret_cast<LPARAM>(langName));
1096  						generic_string strName = pNativeSpeaker->getLocalizedStrFromID("common-name", TEXT("Name"));
1097  						generic_string strTitle = pNativeSpeaker->getLocalizedStrFromID("userdefined-title-rename", TEXT("Rename Current Language Name"));
1098                          StringDlg strDlg;
1099                          strDlg.init(_hInst, _hSelf, strTitle.c_str(), strName.c_str(), langName, langNameLenMax - 1);
1100                          TCHAR *newName = (TCHAR *)strDlg.doDialog();
1101                          if (newName)
1102                          {
1103                              if (nppParam.isExistingUserLangName(newName))
1104                              {
1105  								nppParam.getNativeLangSpeaker()->messageBox("UDLNewNameError",
1106  									_hSelf,
1107  									TEXT("This name is used by another language,\rplease give another one."),
1108  									TEXT("UDL Error"),
1109  									MB_OK);
1110                                  ::PostMessage(_hSelf, WM_COMMAND, IDC_RENAME_BUTTON, 0);
1111                                  return TRUE;
1112                              }
1113                              if (nppParam.getNbUserLang() >= NB_MAX_USER_LANG)
1114                                  return TRUE;
1115                              ::SendDlgItemMessage(_hSelf, IDC_LANGNAME_COMBO, CB_DELETESTRING, i, 0);
1116  							::SendDlgItemMessage(_hSelf, IDC_LANGNAME_COMBO, CB_INSERTSTRING, i, reinterpret_cast<LPARAM>(newName));
1117                              ::SendDlgItemMessage(_hSelf, IDC_LANGNAME_COMBO, CB_SETCURSEL, i, 0);
1118                              UserLangContainer & userLangContainer = nppParam.getULCFromIndex(i-1);
1119                              userLangContainer._name = newName;
1120                              HWND hNpp = ::GetParent(_hSelf);
1121  							HMENU hM = reinterpret_cast<HMENU>(::SendMessage(hNpp, NPPM_INTERNAL_GETMENU, 0, 0));
1122  							HMENU hSubM = ::GetSubMenu(hM, MENUINDEX_LANGUAGE);
1123                              ::ModifyMenu(hSubM, static_cast<UINT>(IDM_LANG_USER + i), MF_BYCOMMAND, IDM_LANG_USER + i, newName);
1124                              ::DrawMenuBar(hNpp);
1125  							::SendMessage(_hParent, WM_RENAME_USERLANG, reinterpret_cast<WPARAM>(newName), reinterpret_cast<LPARAM>(langName));
1126                          }
1127                          return TRUE;
1128                      }
1129                      case IDC_ADDNEW_BUTTON :
1130                      case IDC_SAVEAS_BUTTON :
1131                      {
1132                          auto i = ::SendDlgItemMessage(_hSelf, IDC_LANGNAME_COMBO, CB_GETCURSEL, 0, 0);
1133                          if (i == 0)
1134                              wParam = IDC_ADDNEW_BUTTON;
1135  						generic_string strName = pNativeSpeaker->getLocalizedStrFromID("common-name", TEXT("Name"));
1136  						generic_string strTitle = (wParam == IDC_SAVEAS_BUTTON) ?
1137  							pNativeSpeaker->getLocalizedStrFromID("userdefined-title-save", TEXT("Save Current Language Name As...")) :
1138  							pNativeSpeaker->getLocalizedStrFromID("userdefined-title-new", TEXT("Create New Language..."));
1139                          StringDlg strDlg;
1140  						strDlg.init(_hInst, _hSelf, strTitle.c_str(), strName.c_str(), TEXT(""), langNameLenMax - 1);
1141                          TCHAR *tmpName = reinterpret_cast<TCHAR *>(strDlg.doDialog());
1142                          if (tmpName && tmpName[0])
1143                          {
1144                              generic_string newNameString(tmpName);
1145                              const TCHAR *newName = newNameString.c_str();
1146                              if (nppParam.isExistingUserLangName(newName))
1147                              {
1148  								pNativeSpeaker->messageBox("UDLNewNameError",
1149  									_hSelf,
1150  									TEXT("This name is used by another language,\rplease give another one."),
1151  									TEXT("UDL Error"),
1152  									MB_OK);
1153                                  ::PostMessage(_hSelf, WM_COMMAND, IDC_RENAME_BUTTON, 0);
1154                                  return TRUE;
1155                              }
1156                              if (nppParam.getNbUserLang() >= NB_MAX_USER_LANG)
1157                                  return TRUE;
1158                              UserLangContainer & userLang = (wParam == IDC_SAVEAS_BUTTON)?nppParam.getULCFromIndex(i-1):*_pCurrentUserLang;
1159                              int newIndex = nppParam.addUserLangToEnd(userLang, newName);
1160                              ::SendDlgItemMessage(_hSelf, IDC_LANGNAME_COMBO, CB_ADDSTRING, 0, LPARAM(newName));
1161                              ::SendDlgItemMessage(_hSelf, IDC_LANGNAME_COMBO, CB_SETCURSEL, newIndex + 1, 0);
1162  							::SendMessage(_hSelf, WM_COMMAND, MAKELONG(IDC_LANGNAME_COMBO, CBN_SELCHANGE), reinterpret_cast<LPARAM>(::GetDlgItem(_hSelf, IDC_LANGNAME_COMBO)));
1163                              HWND hNpp = ::GetParent(_hSelf);
1164  							HMENU m = reinterpret_cast<HMENU>(::SendMessage(hNpp, NPPM_INTERNAL_GETMENU, 0, 0));
1165                              ::InsertMenu(::GetSubMenu(m, MENUINDEX_LANGUAGE), IDM_LANG_USER + newIndex, MF_BYCOMMAND, IDM_LANG_USER + newIndex + 1, newName);
1166                              ::DrawMenuBar(hNpp);
1167                          }
1168                          return TRUE;
1169                      }
1170                      case IDC_IMPORT_BUTTON :
1171                      {
1172                          CustomFileDialog fDlg(_hSelf);
1173                          fDlg.setExtFilter(TEXT("UDL"), TEXT(".xml"));
1174                          generic_string sourceFile = fDlg.doOpenSingleFileDlg();
1175                          if (sourceFile.empty()) break;
1176                          bool isSuccessful = nppParam.importUDLFromFile(sourceFile);
1177                          if (isSuccessful)
1178                          {
1179                              auto i = ::SendDlgItemMessage(_hSelf, IDC_LANGNAME_COMBO, CB_GETCURSEL, 0, 0);
1180                              reloadLangCombo();
1181                              ::SendDlgItemMessage(_hSelf, IDC_LANGNAME_COMBO, CB_SETCURSEL, i, 0);
1182                              printStr(TEXT("Import successful."));
1183                          }
1184                          else
1185                          {
1186                              printStr(TEXT("Fail to import."));
1187                          }
1188                          break;
1189                      }
1190                      case IDC_EXPORT_BUTTON :
1191                      {
1192  						auto i2Export = ::SendDlgItemMessage(_hSelf, IDC_LANGNAME_COMBO, CB_GETCURSEL, 0, 0);
1193                          if (i2Export == 0)
1194                          {
1195                              printStr(TEXT("Before exporting, save your language definition by clicking \"Save As...\" button"));
1196                              break;
1197                          }
1198                          CustomFileDialog fDlg(_hSelf);
1199                          fDlg.setExtFilter(TEXT("UDL"), TEXT(".xml"));
1200  						fDlg.setExtIndex(0);		
1201  						generic_string fileName2save = fDlg.doSaveDlg();
1202                          if (fileName2save.empty()) break;
1203                          if (i2Export > 0)
1204                          {
1205                              bool isSuccessful = nppParam.exportUDLToFile(i2Export - 1, fileName2save);
1206                              if (isSuccessful)
1207                              {
1208                                  printStr(TEXT("Export successful"));
1209                              }
1210                              else
1211                              {
1212                                  printStr(TEXT("Fail to export."));
1213                              }
1214                          }
1215                          break;
1216                      }
1217                      case IDC_UD_TRANSPARENT_CHECK :
1218                      {
1219                          bool isChecked = (BST_CHECKED == ::SendDlgItemMessage(_hSelf, IDC_UD_TRANSPARENT_CHECK, BM_GETCHECK, 0, 0));
1220                          if (isChecked)
1221                          {
1222  							int percent = static_cast<int32_t>(::SendDlgItemMessage(_hSelf, IDC_UD_PERCENTAGE_SLIDER, TBM_GETPOS, 0, 0));
1223                              nppParam.SetTransparent(_hSelf, percent);
1224                          }
1225                          else
1226                              nppParam.removeTransparent(_hSelf);
1227                          ::EnableWindow(::GetDlgItem(_hSelf, IDC_UD_PERCENTAGE_SLIDER), isChecked);
1228                          return TRUE;
1229                      }
1230                      case IDC_LANGNAME_IGNORECASE_CHECK :
1231                          return setPropertyByCheck(_hSelf, wParam, _pUserLang->_isCaseIgnored);
1232                      default :
1233                          break;
1234                  }
1235              }
1236              return FALSE;
1237          }
1238          case WM_DESTROY:
1239          {
1240              _folderStyleDlg.destroy();
1241              _keyWordsStyleDlg.destroy();
1242              _commentStyleDlg.destroy();
1243              _symbolsStyleDlg.destroy();
1244              _ctrlTab.destroy();
1245              return TRUE;
1246          }
1247          case WM_SIZE:
1248          {
1249              int originalHight = _dlgPos.bottom; 
1250              _currentHight = HIWORD (lParam);
1251              int diff = _currentHight - _prevHightVal;
1252              _prevHightVal = _currentHight;
1253               int maxPos = originalHight - _currentHight;
1254              SCROLLINFO si{};
1255              si.cbSize = sizeof(si);
1256              si.fMask  = SIF_RANGE | SIF_PAGE;
1257              si.nMin   = 0;
1258              si.nMax   = (_status == UNDOCK)?0:originalHight;
1259              si.nPage  = _currentHight;
1260              ::SetScrollInfo(_hSelf, SB_VERT, &si, TRUE);
1261              if ((_yScrollPos >= maxPos) && (_currentHight < originalHight))
1262              {
1263                  if (_yScrollPos > 0)
1264                  {
1265                      _yScrollPos -= diff;
1266                      ::SetScrollPos(_hSelf, SB_VERT, _yScrollPos, TRUE);
1267                      ::ScrollWindow(_hSelf, 0, diff, NULL, NULL);
1268                  }
1269              }
1270              return TRUE;
1271          }
1272          case WM_VSCROLL :
1273          {
1274              int originalHight = _dlgPos.bottom;
1275              int oldy = _yScrollPos;
1276              int maxPos = originalHight - _currentHight;
1277              switch (LOWORD (wParam))
1278              {
1279                  case SB_LINEUP:
1280                      if (_yScrollPos <= 0)
1281                          return FALSE;
1282                      _yScrollPos = 0;
1283                      break;
1284                  case SB_LINEDOWN:
1285                      if (_yScrollPos >= maxPos)
1286                          return FALSE;
1287                      _yScrollPos = maxPos;
1288                      break;
1289                  case SB_PAGEDOWN:
1290                      if (_yScrollPos >= maxPos)
1291                          return FALSE;
1292                      _yScrollPos = maxPos;
1293                      break;
1294                  case SB_PAGEUP:
1295                      if (_yScrollPos <= 0)
1296                          return FALSE;
1297                      _yScrollPos = 0;
1298                      break;
1299                  case SB_THUMBTRACK:
1300                  case SB_THUMBPOSITION:
1301                      _yScrollPos = HIWORD(wParam);
1302                      break;
1303                  default :
1304                      return FALSE;
1305              }
1306              ::SetScrollPos(_hSelf, SB_VERT, _yScrollPos, TRUE);
1307              ::ScrollWindow(_hSelf, 0, oldy-_yScrollPos, NULL, NULL);
1308              break;
1309          }
1310          case NPPM_MODELESSDIALOG :
1311              return ::SendMessage(_hParent, NPPM_MODELESSDIALOG, wParam, lParam);
1312      }
1313      return FALSE;
1314  }
1315  intptr_t CALLBACK StringDlg::run_dlgProc(UINT Message, WPARAM wParam, LPARAM)
1316  {
1317      switch (Message)
1318      {
1319          case WM_INITDIALOG :
1320          {
1321  			NppDarkMode::autoSubclassAndThemeChildControls(_hSelf);
1322  			if (_restrictedChars.length())
1323  			{
1324  				::SetWindowLongPtr(GetDlgItem(_hSelf, IDC_STRING_EDIT), GWLP_USERDATA, reinterpret_cast<LONG_PTR>(this));
1325  				_oldEditProc = reinterpret_cast<WNDPROC>(SetWindowLongPtr(GetDlgItem(_hSelf, IDC_STRING_EDIT), GWLP_WNDPROC, reinterpret_cast<LONG_PTR>(customEditProc)));
1326  			}
1327              ::SetWindowText(_hSelf, _title.c_str());
1328              ::SetDlgItemText(_hSelf, IDC_STRING_STATIC, _static.c_str());
1329              ::SetDlgItemText(_hSelf, IDC_STRING_EDIT, _textValue.c_str());
1330              if (_txtLen)
1331                  ::SendDlgItemMessage(_hSelf, IDC_STRING_EDIT, EM_SETLIMITTEXT, _txtLen, 0);
1332  			NativeLangSpeaker *pNativeSpeaker = (NppParameters::getInstance()).getNativeLangSpeaker();
1333  			if (pNativeSpeaker)
1334  			{
1335  				generic_string ok = pNativeSpeaker->getLocalizedStrFromID("common-ok", TEXT("OK"));
1336  				generic_string cancel = pNativeSpeaker->getLocalizedStrFromID("common-cancel", TEXT("Cancel"));
1337  				::SetDlgItemText(_hSelf, IDOK, ok.c_str());
1338  				::SetDlgItemText(_hSelf, IDCANCEL, cancel.c_str());
1339  			}
1340  			if (_shouldGotoCenter)
1341  				goToCenter(SWP_SHOWWINDOW | SWP_NOSIZE);
1342  			return TRUE;
1343  		}
1344  		case WM_CTLCOLOREDIT:
1345  		{
1346  			return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
1347  		}
1348  		case WM_CTLCOLORDLG:
1349  		case WM_CTLCOLORSTATIC:
1350  		{
1351  			return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
1352  		}
1353  		case WM_PRINTCLIENT:
1354  		{
1355  			if (NppDarkMode::isEnabled())
1356  			{
1357  				return TRUE;
1358  			}
1359  			break;
1360  		}
1361  		case WM_ERASEBKGND:
1362  		{
1363  			if (NppDarkMode::isEnabled())
1364  			{
1365  				RECT rc{};
1366  				getClientRect(rc);
1367  				::FillRect(reinterpret_cast<HDC>(wParam), &rc, NppDarkMode::getDarkerBackgroundBrush());
1368  				return TRUE;
1369  			}
1370  			break;
1371  		}
1372  		case NPPM_INTERNAL_REFRESHDARKMODE:
1373  		{
1374  			NppDarkMode::autoThemeChildControls(_hSelf);
1375  			return TRUE;
1376  		}
1377          case WM_COMMAND :
1378          {
1379              switch (wParam)
1380              {
1381                  case IDOK :
1382                  {
1383                      TCHAR tmpName[langNameLenMax] = { '\0' };
1384                      ::GetDlgItemText(_hSelf, IDC_STRING_EDIT, tmpName, langNameLenMax);
1385                      _textValue = tmpName;
1386                      ::EndDialog(_hSelf, reinterpret_cast<intptr_t>(_textValue.c_str()));
1387                      return TRUE;
1388                  }
1389                  case IDCANCEL :
1390                      ::EndDialog(_hSelf, 0);
1391                      return TRUE;
1392                  default:
1393                      return FALSE;
1394              }
1395          }
1396          default :
1397              return FALSE;
1398      }
1399  	return FALSE;
1400  }
1401  LRESULT StringDlg::customEditProc(HWND hEdit, UINT msg, WPARAM wParam, LPARAM lParam)
1402  {
1403  	StringDlg *pSelf = reinterpret_cast<StringDlg *>(::GetWindowLongPtr(hEdit, GWLP_USERDATA));
1404  	if (!pSelf)
1405  	{
1406  		return 0;
1407  	}
1408  	switch (msg)
1409  	{
1410  	case WM_CHAR:
1411  		if (0x80 & GetKeyState(VK_CONTROL))
1412  		{
1413  			switch (wParam)
1414  			{
1415  			case 0x16: 
1416  				pSelf->HandlePaste(hEdit);
1417  				return 0;
1418  			case 0x03: 
1419  			case 0x18: 
1420  			default:
1421  				break;
1422  			}
1423  		}
1424  		else
1425  		{
1426  			if (!pSelf->isAllowed(reinterpret_cast<TCHAR*>(&wParam)))
1427  				return 0;
1428  		}
1429  		break;
1430  	case WM_DESTROY:
1431  		SetWindowLongPtr(hEdit, GWLP_WNDPROC, reinterpret_cast<LONG_PTR>(pSelf->_oldEditProc));
1432  		return 0;
1433  	}
1434  	return CallWindowProc(pSelf->_oldEditProc, hEdit, msg, wParam, lParam);
1435  }
1436  bool StringDlg::isAllowed([[maybe_unused]] const generic_string & txt)
1437  {
1438  #ifndef __MINGW32__
1439  	for (auto ch : txt)
1440  	{
1441  		if (std::find(_restrictedChars.cbegin(), _restrictedChars.cend(), ch) != _restrictedChars.cend())
1442  			return false;
1443  	}
1444  #endif
1445  	return true;
1446  }
1447  void StringDlg::HandlePaste(HWND hEdit)
1448  {
1449  	if (OpenClipboard(hEdit))
1450  	{
1451  		HANDLE hClipboardData = GetClipboardData(CF_UNICODETEXT);
1452  		if (NULL != hClipboardData)
1453  		{
1454  			LPTSTR pszText = static_cast<LPTSTR>(GlobalLock(hClipboardData));
1455  			if (NULL != pszText && isAllowed(pszText))
1456  			{
1457  				SendMessage(hEdit, EM_REPLACESEL, TRUE, reinterpret_cast<LPARAM>(pszText));
1458  			}
1459  			GlobalUnlock(hClipboardData);
1460  		}
1461  		CloseClipboard();
1462  	}
1463  }
1464  void StylerDlg::move2CtrlRight(HWND hwndDlg, int ctrlID, HWND handle2Move, int handle2MoveWidth, int handle2MoveHeight)
1465  {
1466      POINT p{};
1467      RECT rc{};
1468      ::GetWindowRect(::GetDlgItem(hwndDlg, ctrlID), &rc);
1469      p.x = rc.right + NppParameters::getInstance()._dpiManager.scaleX(5);
1470      p.y = rc.top + ((rc.bottom - rc.top) / 2) - handle2MoveHeight / 2;
1471      ::ScreenToClient(hwndDlg, &p);
1472      ::MoveWindow(handle2Move, p.x, p.y, handle2MoveWidth, handle2MoveHeight, TRUE);
1473  }
1474  intptr_t CALLBACK StylerDlg::dlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
1475  {
1476      StylerDlg * dlg = (StylerDlg *)::GetProp(hwnd, TEXT("Styler dialog prop"));
1477      NppParameters& nppParam = NppParameters::getInstance();
1478      switch (message)
1479      {
1480          case WM_INITDIALOG :
1481          {
1482              NppDarkMode::setDarkTitleBar(hwnd);
1483              NppDarkMode::autoSubclassAndThemeChildControls(hwnd);
1484              NativeLangSpeaker *pNativeLangSpeaker = nppParam.getNativeLangSpeaker();
1485              pNativeLangSpeaker->changeUserDefineLangPopupDlg(hwnd);
1486              ::SetProp(hwnd, TEXT("Styler dialog prop"), (HANDLE)lParam);
1487              dlg = (StylerDlg *)::GetProp(hwnd, TEXT("Styler dialog prop"));
1488              Style & style = SharedParametersDialog::_pUserLang->_styles.getStyler(dlg->_stylerIndex);
1489              RECT wrc{};
1490              ::GetWindowRect(dlg->_parent, &wrc);
1491              wrc.left = wrc.left < 0 ? 200 : wrc.left;   
1492              wrc.top = wrc.top < 0 ? 200 : wrc.top;
1493              ::SetWindowPos(hwnd, HWND_TOP, wrc.left, wrc.top, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
1494              ::SendDlgItemMessage(hwnd, IDC_STYLER_CHECK_UNDERLINE, BM_SETCHECK, style._fontStyle & FONTSTYLE_UNDERLINE, 0);
1495              ::SendDlgItemMessage(hwnd, IDC_STYLER_CHECK_ITALIC,    BM_SETCHECK, style._fontStyle & FONTSTYLE_ITALIC, 0);
1496              ::SendDlgItemMessage(hwnd, IDC_STYLER_CHECK_BOLD,      BM_SETCHECK, style._fontStyle & FONTSTYLE_BOLD, 0);
1497              HWND hFontSizeCombo = ::GetDlgItem(hwnd, IDC_STYLER_COMBO_FONT_SIZE);
1498              for (size_t j = 0 ; j < int(sizeof(fontSizeStrs))/(3*sizeof(TCHAR)) ; ++j)
1499  				::SendMessage(hFontSizeCombo, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(fontSizeStrs[j]));
1500              TCHAR size[10] = { '\0' };
1501              if (style._fontSize == -1)
1502                  size[0] = '\0';
1503              else
1504                  wsprintf(size, TEXT("%d"),style._fontSize);
1505  			auto i = ::SendMessage(hFontSizeCombo, CB_FINDSTRINGEXACT, static_cast<WPARAM>(-1), reinterpret_cast<LPARAM>(size));
1506              if (i != CB_ERR)
1507                  ::SendMessage(hFontSizeCombo, CB_SETCURSEL, i, 0);
1508              HWND hFontNameCombo = ::GetDlgItem(hwnd, IDC_STYLER_COMBO_FONT_NAME);
1509              const std::vector<generic_string> & fontlist = nppParam.getFontList();
1510              for (size_t j = 0, len = fontlist.size() ; j < len ; ++j)
1511              {
1512  				auto k = ::SendMessage(hFontNameCombo, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(fontlist[j].c_str()));
1513  				::SendMessage(hFontNameCombo, CB_SETITEMDATA, k, reinterpret_cast<LPARAM>(fontlist[j].c_str()));
1514              }
1515  			i = ::SendMessage(hFontNameCombo, CB_FINDSTRINGEXACT, static_cast<WPARAM>(-1), reinterpret_cast<LPARAM>(style._fontName.c_str()));
1516              if (i == CB_ERR)
1517                  i = 0;
1518              ::SendMessage(hFontNameCombo, CB_SETCURSEL, i, 0);
1519              if (style._fgColor == COLORREF(-1))
1520                  style._fgColor = black;
1521              if (style._bgColor == COLORREF(-1))
1522                  style._bgColor = white;
1523              dlg->_pFgColour->init(dlg->_hInst, hwnd);
1524              dlg->_pFgColour->setColour(style._fgColor);
1525              bool isFgEnabled = (style._colorStyle & COLORSTYLE_FOREGROUND) != 0;
1526              dlg->_pFgColour->setEnabled(isFgEnabled);
1527              ::SendDlgItemMessage(hwnd, IDC_STYLER_CHECK_FG_TRANSPARENT, BM_SETCHECK, !isFgEnabled, 0);
1528              dlg->_pBgColour->init(dlg->_hInst, hwnd);
1529              dlg->_pBgColour->setColour(style._bgColor);
1530              bool isBgEnabled = (style._colorStyle & COLORSTYLE_BACKGROUND) != 0;
1531              dlg->_pBgColour->setEnabled(isBgEnabled);
1532              ::SendDlgItemMessage(hwnd, IDC_STYLER_CHECK_BG_TRANSPARENT, BM_SETCHECK, !isBgEnabled, 0);
1533              int w = nppParam._dpiManager.scaleX(25);
1534              int h = nppParam._dpiManager.scaleY(25);
1535              dlg->move2CtrlRight(hwnd, IDC_STYLER_FG_STATIC, dlg->_pFgColour->getHSelf(), w, h);
1536              dlg->move2CtrlRight(hwnd, IDC_STYLER_BG_STATIC, dlg->_pBgColour->getHSelf(), w, h);
1537              dlg->_pFgColour->display();
1538              dlg->_pBgColour->display();
1539              unordered_map<int, int>::iterator iter = globalMappper().nestingMapper.begin();
1540              for (; iter != globalMappper().nestingMapper.end(); ++iter)
1541              {
1542                  ::SendDlgItemMessage(hwnd, iter->first, BM_SETCHECK, style._nesting & iter->second, 0);
1543                  ::EnableWindow(::GetDlgItem(hwnd, iter->first), dlg->_enabledNesters & iter->second);
1544              }
1545              return TRUE;
1546          }
1547          case WM_CTLCOLOREDIT:
1548          {
1549              return NppDarkMode::onCtlColorSofter(reinterpret_cast<HDC>(wParam));
1550          }
1551          case WM_CTLCOLORLISTBOX:
1552          {
1553              return NppDarkMode::onCtlColor(reinterpret_cast<HDC>(wParam));
1554          }
1555          case WM_CTLCOLORDLG:
1556          case WM_CTLCOLORSTATIC:
1557          {
1558              return NppDarkMode::onCtlColorDarker(reinterpret_cast<HDC>(wParam));
1559          }
1560          case WM_PRINTCLIENT:
1561          {
1562              if (NppDarkMode::isEnabled())
1563              {
1564                  return TRUE;
1565              }
1566              break;
1567          }
1568          case NPPM_INTERNAL_REFRESHDARKMODE:
1569          {
1570              NppDarkMode::setDarkTitleBar(hwnd);
1571              NppDarkMode::autoThemeChildControls(hwnd);
1572              ::SetWindowPos(hwnd, nullptr, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);
1573              return TRUE;
1574          }
1575          case WM_COMMAND :
1576          {
1577  			if (dlg == nullptr)
1578  				return FALSE;
1579              Style & style = SharedParametersDialog::_pUserLang->_styles.getStyler(dlg->_stylerIndex);
1580              if (HIWORD(wParam) == CBN_SELCHANGE)
1581              {
1582                  auto i = ::SendDlgItemMessage(hwnd, LOWORD(wParam), CB_GETCURSEL, 0, 0);
1583                  if (LOWORD(wParam) == IDC_STYLER_COMBO_FONT_SIZE)
1584                  {
1585                      if (i != 0)
1586                      {
1587  						const size_t intStrLen = 3;
1588  						TCHAR intStr[intStrLen] = { '\0' };
1589  						auto lbTextLen = ::SendDlgItemMessage(hwnd, LOWORD(wParam), CB_GETLBTEXTLEN, i, 0);
1590  						if (static_cast<size_t>(lbTextLen) > intStrLen - 1)
1591  							return TRUE;
1592  						::SendDlgItemMessage(hwnd, LOWORD(wParam), CB_GETLBTEXT, i, reinterpret_cast<LPARAM>(intStr));
1593                          if (!intStr[0])
1594                              style._fontSize = -1;
1595                          else
1596                          {
1597                              TCHAR *finStr = nullptr;
1598                              style._fontSize = wcstol(intStr, &finStr, 10);
1599                              if (*finStr != '\0')
1600                                  style._fontSize = -1;
1601                          }
1602                      }
1603                      else
1604                      {
1605                          style._fontSize = -1;
1606                      }
1607                  }
1608                  else if (LOWORD(wParam) == IDC_STYLER_COMBO_FONT_NAME)
1609                  {
1610                      style._fontName = (TCHAR *)::SendDlgItemMessage(hwnd, LOWORD(wParam), CB_GETITEMDATA, i, 0);
1611                  }
1612                  if (SharedParametersDialog::_pScintilla->getCurrentBuffer()->getLangType() == L_USER)
1613                      SharedParametersDialog::_pScintilla->styleChange();
1614                  return TRUE;
1615              }
1616              else if (HIWORD(wParam) == CPN_COLOURPICKED)    
1617              {
1618                  if (wParam == IDCANCEL)
1619                  {
1620                      style = dlg->_initialStyle;
1621                      if (SharedParametersDialog::_pScintilla->getCurrentBuffer()->getLangType() == L_USER)
1622                          SharedParametersDialog::_pScintilla->styleChange();
1623                      ::RemoveProp(hwnd, TEXT("Styler dialog prop"));
1624                      ::EndDialog(hwnd, IDCANCEL);
1625                      return TRUE;
1626                  }
1627                  if (wParam == IDOK)
1628                  {
1629                      ::RemoveProp(hwnd, TEXT("Styler dialog prop"));
1630                      ::EndDialog(hwnd, IDOK);
1631                      return TRUE;
1632                  }
1633                  style._fgColor = dlg->_pFgColour->getColour();
1634                  style._bgColor = dlg->_pBgColour->getColour();
1635  				if (wParam == IDC_STYLER_CHECK_FG_TRANSPARENT || wParam == IDC_STYLER_CHECK_BG_TRANSPARENT)
1636  				{
1637  					if (wParam == IDC_STYLER_CHECK_FG_TRANSPARENT)
1638  					{
1639  						bool isTransparent = (BST_CHECKED == ::SendDlgItemMessage(hwnd, IDC_STYLER_CHECK_FG_TRANSPARENT, BM_GETCHECK, 0, 0));
1640  						dlg->_pFgColour->setEnabled(!isTransparent);
1641  						dlg->_pFgColour->redraw();
1642                          if (isTransparent)
1643  						    style._colorStyle &= ~COLORSTYLE_FOREGROUND;
1644                          else
1645                              style._colorStyle |= COLORSTYLE_FOREGROUND;
1646  					}
1647  					if (wParam == IDC_STYLER_CHECK_BG_TRANSPARENT)
1648  					{
1649  						bool isTransparent = (BST_CHECKED == ::SendDlgItemMessage(hwnd, IDC_STYLER_CHECK_BG_TRANSPARENT, BM_GETCHECK, 0, 0));
1650  						dlg->_pBgColour->setEnabled(!isTransparent);
1651  						dlg->_pBgColour->redraw();
1652                          if (isTransparent)
1653  						    style._colorStyle &= ~COLORSTYLE_BACKGROUND;
1654                          else
1655  						    style._colorStyle |= COLORSTYLE_BACKGROUND;
1656  					}
1657  				}
1658  				else
1659  				{
1660  					if (dlg->_pFgColour->isEnabled())
1661  					{
1662  						style._colorStyle |= COLORSTYLE_FOREGROUND;
1663  					}
1664  					else
1665  					{
1666  						style._colorStyle &= ~COLORSTYLE_FOREGROUND;
1667  					}
1668  					::SendDlgItemMessage(hwnd, IDC_STYLER_CHECK_FG_TRANSPARENT, BM_SETCHECK, !dlg->_pFgColour->isEnabled(), 0);
1669  					if (dlg->_pBgColour->isEnabled())
1670  					{
1671  						style._colorStyle |= COLORSTYLE_BACKGROUND;
1672  					}
1673  					else
1674  					{
1675  						style._colorStyle &= ~COLORSTYLE_BACKGROUND;
1676  					}
1677  					::SendDlgItemMessage(hwnd, IDC_STYLER_CHECK_BG_TRANSPARENT, BM_SETCHECK, !dlg->_pBgColour->isEnabled(), 0);
1678  				}
1679                  style._fontStyle = FONTSTYLE_NONE;
1680                  if (BST_CHECKED == ::SendMessage(::GetDlgItem(hwnd, IDC_STYLER_CHECK_BOLD), BM_GETCHECK, 0, 0))
1681                      style._fontStyle |= FONTSTYLE_BOLD;
1682                  if (BST_CHECKED == ::SendMessage(::GetDlgItem(hwnd, IDC_STYLER_CHECK_ITALIC), BM_GETCHECK, 0, 0))
1683                      style._fontStyle |= FONTSTYLE_ITALIC;
1684                  if (BST_CHECKED == ::SendMessage(::GetDlgItem(hwnd, IDC_STYLER_CHECK_UNDERLINE), BM_GETCHECK, 0, 0))
1685                      style._fontStyle |= FONTSTYLE_UNDERLINE;
1686                  style._nesting = SCE_USER_MASK_NESTING_NONE;
1687                  unordered_map<int, int>::iterator iter = globalMappper().nestingMapper.begin();
1688                  for (; iter != globalMappper().nestingMapper.end(); ++iter)
1689                  {
1690                      if (BST_CHECKED == ::SendMessage(::GetDlgItem(hwnd, iter->first), BM_GETCHECK, 0, 0))
1691                          style._nesting |= iter->second;
1692                  }
1693                  if (SharedParametersDialog::_pScintilla->getCurrentBuffer()->getLangType() == L_USER)
1694                      SharedParametersDialog::_pScintilla->styleChange();
1695                  return TRUE;
1696              }
1697              return FALSE;
1698          }
1699          case WM_CLOSE:
1700          {
1701              return TRUE;
1702          }
1703          default :
1704              return FALSE;
1705      }
1706      return FALSE;
1707  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-cord_ring_test.cc</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-UserDefineDialog.cpp</div>
                <div class="column column_space"><pre><code>586      if (shared_type == 0) {
587        flat = CordRep::Ref(MakeFlat(str1.substr(10), 100));
588      } else if (shared_type == 1) {
589        flat1 = CordRep::Ref(MakeFlat(str1));
590        flat = RemovePrefix(10, flat1);
</pre></code></div>
                <div class="column column_space"><pre><code>24  		if (i == 0 && toConvert[i] == '(' && toConvert[i + 1] == '(')
25  		{
26  			inGroup = true;
27  		}
28  		else if (toConvert[i] == ' ' && toConvert[i + 1] == '(' && toConvert[i + 2] == '(')
29  		{
30  			inGroup = true;
31  			dest[index++] = ' ';
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    