
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 8.321038654470344%, Tokens: 9</h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-agmattr.h</h3>
            <pre><code>1  #ifndef yanglib_agmattr1_h
2  #define yanglib_agmattr1_h
3  #include "Snap.h"
4  class TCesnaUtil {
5  public:
6  template<class PGraph>
7  static double GetConductance(const PGraph& Graph, const TIntSet& CmtyS, const int Edges) {
8    const bool GraphType = HasGraphFlag(typename PGraph::TObj, gfDirected);
9    int Edges2;
10    if (GraphType) { Edges2 = Edges >= 0 ? Edges : Graph->GetEdges(); }
11    else { Edges2 = Edges >= 0 ? 2 * Edges : Graph->GetEdges(); }
12    int Vol = 0,  Cut = 0; 
13    double Phi = 0.0;
14    for (int i = 0; i < CmtyS.Len(); i++) {
15      if (! Graph->IsNode(CmtyS[i])) { continue; }
16      typename PGraph::TObj::TNodeI  NI = Graph->GetNI(CmtyS[i]);
17      for (int e = 0; e < NI.GetOutDeg(); e++) {
18        if (! CmtyS.IsKey(NI.GetOutNId(e))) { Cut += 1; }
19      }
20      Vol += NI.GetOutDeg();
21    }
22    if (Vol != Edges2) {
23      if (2 * Vol > Edges2) { Phi = Cut / double (Edges2 - Vol); }
24      else if (Vol == 0) { Phi = 0.0; }
25      else { Phi = Cut / double(Vol); }
26    } else {
27      if (Vol == Edges2) { Phi = 1.0; }
28    }
29    return Phi;
30  }
31  template<class PGraph>
32    static void GenHoldOutPairs(const PGraph& G, TVec<TIntSet>& HoldOutSet, double HOFrac, TRnd& Rnd)  {
33      TIntPrV EdgeV(G->GetEdges(), 0);
34      for (typename PGraph::TObj::TEdgeI EI = G->BegEI(); EI < G->EndEI(); EI++) {
35        EdgeV.Add(TIntPr(EI.GetSrcNId(), EI.GetDstNId()));
36      }
37      EdgeV.Shuffle(Rnd);
38      const bool GraphType = HasGraphFlag(typename PGraph::TObj, gfDirected);
39      HoldOutSet.Gen(G->GetNodes());
40      int HOTotal = int(HOFrac * G->GetNodes() * (G->GetNodes() - 1) / 2.0);
41      if (GraphType) { HOTotal *= 2;}
42      int HOCnt = 0;
43      int HOEdges = (int) TMath::Round(HOFrac * G->GetEdges());
44      printf("holding out %d edges...\n", HOEdges);
45      for (int he = 0; he < (int) HOEdges; he++) {
46        HoldOutSet[EdgeV[he].Val1].AddKey(EdgeV[he].Val2);
47        if (! GraphType) { HoldOutSet[EdgeV[he].Val2].AddKey(EdgeV[he].Val1); }
48        HOCnt++;
49      }
50      printf("%d Edges hold out\n", HOCnt);
51      while(HOCnt++ < HOTotal) {
52        int SrcNID = Rnd.GetUniDevInt(G->GetNodes());
53        int DstNID = Rnd.GetUniDevInt(G->GetNodes());
54        if (SrcNID == DstNID) { continue; }
55        HoldOutSet[SrcNID].AddKey(DstNID);
56        if (! GraphType) { HoldOutSet[DstNID].AddKey(SrcNID); }
57      }
58    }
59  template<class PGraph>
60    static void GetNbhCom(const PGraph& Graph, const int NID, TIntSet& NBCmtyS) {
61      typename PGraph::TObj::TNodeI NI = Graph->GetNI(NID);
62      NBCmtyS.Gen(NI.GetDeg());
63      NBCmtyS.AddKey(NID);
64      for (int e = 0; e < NI.GetDeg(); e++) {
65        NBCmtyS.AddKey(NI.GetNbrNId(e));
66      }
67    }
68  template<class PGraph>
69    static void GetNIdPhiV(const PGraph& G, TFltIntPrV& NIdPhiV) {
70      NIdPhiV.Gen(G->GetNodes(), 0);
71      const int Edges = G->GetEdges();
72      TExeTm RunTm;
73      for (typename PGraph::TObj::TNodeI NI = G->BegNI(); NI < G->EndNI(); NI++) {
74        TIntSet NBCmty(NI.GetDeg() + 1);
75        double Phi;
76        if (NI.GetDeg() < 5) { 
77          Phi = 1.0; 
78        } else {
79          TCesnaUtil::GetNbhCom<PGraph>(G, NI.GetId(), NBCmty);
80          Phi = TCesnaUtil::GetConductance(G, NBCmty, Edges);
81        }
82        NIdPhiV.Add(TFltIntPr(Phi, NI.GetId()));
83      }
84      printf("conductance computation completed [%s]\n", RunTm.GetTmStr());
85      fflush(stdout);
86    }
87    static void LoadNIDAttrHFromNIDKH(const TIntV& NIDV, const TStr& InFNm, THash<TInt, TIntV>& NIDAttrH, const TStrHash<TInt>& NodeNameH, const TSsFmt Sep = ssfTabSep) {
88      NIDAttrH.Clr();
89      NIDAttrH.Gen(NIDV.Len());
90      printf("nodes in the graph:%d\n", NIDV.Len());
91      for (int u = 0; u < NIDV.Len(); u++) { NIDAttrH.AddDat(NIDV[u]).Gen(0, 0); }
92      TSsParser Ss(InFNm, ssfTabSep);
93      while (Ss.Next()) {
94        TStr NodeName = Ss.GetFld(0);
95        TInt NID = NodeName.GetInt();
96        if (NodeNameH.Len() > 0 && ! NodeNameH.IsKey(NodeName)) { continue; }
97        if (NodeNameH.Len() > 0) { 
98          IAssertR(NodeNameH.IsKey(NodeName), TStr::Fmt("NodeName:%s", NodeName.CStr())); 
99          NID = NodeNameH.GetKeyId(NodeName);
100        }
101        if (! NIDAttrH.IsKey(NID)) { 
102          continue; } 
103        IAssertR(! NIDAttrH.GetDat(NID).IsIn(Ss.GetInt(1)), TStr::Fmt("NIdx:%d NID:%s, K:%d", NID.Val, NodeName.CStr(), Ss.GetInt(1)));
104        NIDAttrH.GetDat(NID).Add(Ss.GetInt(1));
105      }
106      printf("%s nodes, %s lines read \n",  TUInt64::GetStr(NIDAttrH.Len()).CStr(), TUInt64::GetStr(Ss.GetLineNo()).CStr());
107    }
108    static void LoadNIDAttrHFromNIDKH(const TIntV& NIDV, const TStr& InFNm, THash<TInt, TIntV>& NIDAttrH) {
109      TStrHash<TInt> TmpH;
110      LoadNIDAttrHFromNIDKH(NIDV, InFNm, NIDAttrH, TmpH);
111    }
112    static void DumpNIDAttrHToNIDK(const TStr& FNm, const THash<TInt, TIntSet>& NIDAttrH, const TStrHash<TInt>& FeatNameH, const TStrHash<TInt>& NodeNameH) {
113      FILE* F = fopen(FNm.CStr(), "wt");
114      for (int u = 0; u < NIDAttrH.Len(); u++) {
115        int NID = NIDAttrH.GetKey(u);
116        TStr NodeName = NodeNameH.IsKeyId(NID)? NodeNameH.GetKey(NID): TStr::Fmt("%d", NID);
117        for (int k = 0; k < NIDAttrH[u].Len(); k++) {
118          int KID = NIDAttrH[u][k];
119          TStr FeatName = FeatNameH.IsKeyId(KID)? FeatNameH.GetKey(KID): TStr::Fmt("%d", KID);
120          fprintf(F,"%s\t%s\n", NodeName.CStr(), FeatName.CStr());
121        }
122      }
123      fclose(F);
124    }
125    static void DumpNIDAttrHToNIDK(const TStr& FNm, const THash<TInt, TIntSet>& NIDAttrH, const TStrHash<TInt>& FeatNameH) {
126      TStrHash<TInt> TmpH;
127      DumpNIDAttrHToNIDK(FNm, NIDAttrH, FeatNameH, TmpH);
128    }
129    static void DumpNIDAttrHToNIDK(const TStr& FNm, const THash<TInt, TIntSet>& NIDAttrH) {
130      TStrHash<TInt> TmpH1, TmpH2;
131      DumpNIDAttrHToNIDK(FNm, NIDAttrH, TmpH1, TmpH2);
132    }
133    static void DumpNIDAttrHToNIDK(const TStr& FNm, const THash<TInt, TIntV>& NIDAttrH, const TStrHash<TInt>& FeatNameH, const TStrHash<TInt>& NodeNameH) {
134      FILE* F = fopen(FNm.CStr(), "wt");
135      for (int u = 0; u < NIDAttrH.Len(); u++) {
136        int NID = NIDAttrH.GetKey(u);
137        TStr NodeName = NodeNameH.IsKeyId(NID)? NodeNameH.GetKey(NID): TStr::Fmt("%d", NID);
138        for (int k = 0; k < NIDAttrH[u].Len(); k++) {
139          int KID = NIDAttrH[u][k];
140          TStr FeatName = FeatNameH.IsKeyId(KID)? FeatNameH.GetKey(KID): TStr::Fmt("%d", KID);
141          fprintf(F,"%s\t%s\n", NodeName.CStr(), FeatName.CStr());
142        }
143      }
144      fclose(F);
145    }
146    static void DumpNIDAttrHToNIDK(const TStr& FNm, const THash<TInt, TIntV>& NIDAttrH, const TStrHash<TInt>& FeatNameH) {
147      TStrHash<TInt> TmpH;
148      DumpNIDAttrHToNIDK(FNm, NIDAttrH, FeatNameH, TmpH);
149    }
150    static void DumpNIDAttrHToNIDK(const TStr& FNm, const THash<TInt, TIntV>& NIDAttrH) {
151      TStrHash<TInt> TmpH1, TmpH2;
152      DumpNIDAttrHToNIDK(FNm, NIDAttrH, TmpH1, TmpH2);
153    }
154    static int GetAttrs(const THash<TInt, TIntV>& NIDAttrH) {
155      int Attrs = 0;
156      for (int u = 0; u < NIDAttrH.Len(); u++) {
157        for (int k = 0; k < NIDAttrH[u].Len(); k++) {
158          if (NIDAttrH[u][k] >= Attrs) { Attrs = NIDAttrH[u][k] + 1; }
159        }
160      }
161      return Attrs;
162    }
163    static void DumpNIDAttrHToMetis(const TStr& FNm, const THash<TInt, TIntV>& NIDAttrH, const TIntV& NIDV) {
164      int AttrCnt = 0;
165      for (int u = 1; u < NIDV.Len(); u++) {
166        if (! NIDAttrH.IsKey(NIDV[u])) { continue; }
167        AttrCnt += NIDAttrH.GetDat(NIDV[u]).Len();
168      }
169      IAssert (NIDV[0] == -1);
170      FILE* F = fopen(FNm.CStr(), "wt");
171      fprintf(F, "%d %d\n", NIDV.Len() - 1, AttrCnt);
172      int TmpCnt = 0;
173      for (int u = 1; u < NIDV.Len(); u++) {
174        if (NIDAttrH.IsKey(NIDV[u])) {  
175          for (int k = 0; k < NIDAttrH.GetDat(NIDV[u]).Len(); k++) {
176            if (k > 0) { fprintf(F, " "); }
177            fprintf(F, "%d", NIDAttrH.GetDat(NIDV[u])[k].Val + 1);
178            TmpCnt++;
179          }
180        }
181        fprintf(F, "\n");
182      }
183      fclose(F);
184      IAssert(AttrCnt == TmpCnt);
185    }
186    static void FilterLowEntropy(const THash<TInt, TIntV>& OldNIDAttrH, THash<TInt, TIntV>& NewNIDAttrH, const TIntStrH& OldNameH, TIntStrH& NewNameH, const double MinFrac = 0.00001, const double MaxFrac = 0.95, const int MinCnt = 3) {
187      TIntH KIDCntH;
188      for (int u = 0; u < OldNIDAttrH.Len(); u++) {
189        for (int k = 0; k < OldNIDAttrH[u].Len(); k++) {
190          KIDCntH.AddDat(OldNIDAttrH[u][k])++;
191        }
192      }
193      KIDCntH.SortByDat(false);
194      TIntSet SelectedK(KIDCntH.Len());
195      for (int c = 0; c < KIDCntH.Len(); c++) {
196        double Frac = (double) KIDCntH[c].Val / (double) OldNIDAttrH.Len();
197        if (KIDCntH[c].Val < MinCnt) { continue; }
198        if (Frac > MaxFrac || Frac < MinFrac) { continue; }
199        SelectedK.AddKey(KIDCntH.GetKey(c));
200      }
201      printf("%d attributes selected from %d\n", SelectedK.Len(), KIDCntH.Len());
202      NewNIDAttrH.Gen(OldNIDAttrH.Len());
203      for (int u = 0; u < OldNIDAttrH.Len(); u++) {
204        int NID = OldNIDAttrH.GetKey(u);
205        TIntV& AttrV = NewNIDAttrH.AddDat(NID);
206        for (int k = 0; k < OldNIDAttrH[u].Len(); k++) {
207          if (! SelectedK.IsKey(OldNIDAttrH[u][k])) { continue; }
208          AttrV.Add(SelectedK.GetKeyId(OldNIDAttrH[u][k]));
209        }
210      }
211      if (! OldNameH.Empty()) {
212        NewNameH.Gen(SelectedK.Len());
213        for (int k = 0; k < SelectedK.Len(); k++) {
214          int OldKID = SelectedK.GetKey(k);
215          if (OldNameH.IsKey(OldKID)) {
216            NewNameH.AddDat(k, OldNameH.GetDat(OldKID));
217          }
218        }
219        printf("%d attributes names copied\n", NewNameH.Len());
220      }
221    }
222    static void FilterLowEntropy(const THash<TInt, TIntV>& OldNIDAttrH, THash<TInt, TIntV>& NewNIDAttrH, const double MinFrac = 0.00001, const double MaxFrac = 0.95, const int MinCnt = 3) {
223      TIntStrH TmpH1, TmpH2;
224      FilterLowEntropy(OldNIDAttrH, NewNIDAttrH, TmpH1, TmpH2, MinFrac, MaxFrac, MinCnt);
225    }
226  };
227  class TCesna { 
228  private:
229    PUNGraph G; 
230    TVec<TIntSet> X; 
231    TVec<TIntFltH> F; 
232    TVec<TFltV> W; 
233    TInt Attrs; 
234    TRnd Rnd; 
235    TIntSet NIDToIdx; 
236    TFlt RegCoef; 
237    TFltV SumFV; 
238    TInt NumComs; 
239    TVec<TIntSet> HOVIDSV; 
240    TVec<TIntSet> HOKIDSV; 
241  public:
242    TFlt MinVal; 
243    TFlt MaxVal; 
244    TFlt MinValW; 
245    TFlt MaxValW; 
246    TFlt NegWgt; 
247    TFlt LassoCoef; 
248    TFlt WeightAttr; 
249    TFlt PNoCom; 
250    TBool DoParallel; 
251    TCesna() { G = TUNGraph::New(10, -1); }
252    TCesna(const PUNGraph& GraphPt, const THash<TInt, TIntV>& NIDAttrH, const int& InitComs, const int RndSeed = 0): Rnd(RndSeed), RegCoef(0), 
253      MinVal(0.0), MaxVal(10.0), MinValW(-10.0), MaxValW(10.0), NegWgt(1.0), LassoCoef(1.0), WeightAttr(1.0) { SetGraph(GraphPt, NIDAttrH); NeighborComInit(InitComs); }
254    void Save(TSOut& SOut) {
255      G->Save(SOut);
256      X.Save(SOut);
257      F.Save(SOut);
258      W.Save(SOut);
259      Attrs.Save(SOut);
260      NIDToIdx.Save(SOut);
261      RegCoef.Save(SOut);
262      LassoCoef.Save(SOut);
263      SumFV.Save(SOut);
264      NumComs.Save(SOut);
265      HOVIDSV.Save(SOut);
266      HOKIDSV.Save(SOut);
267      MinVal.Save(SOut);
268      MaxVal.Save(SOut);
269      MinValW.Save(SOut);
270      MaxValW.Save(SOut);
271      NegWgt.Save(SOut);
272      PNoCom.Save(SOut);
273    }
274    void Load(TSIn& SIn, const int& RndSeed = 0) {
275      G->Load(SIn);
276      X.Load(SIn);
277      F.Load(SIn);
278      W.Load(SIn);
279      Attrs.Load(SIn);
280      NIDToIdx.Load(SIn);
281      RegCoef.Load(SIn);
282      LassoCoef.Load(SIn);
283      SumFV.Load(SIn);
284      NumComs.Load(SIn);
285      HOVIDSV.Load(SIn);
286      HOKIDSV.Load(SIn);
287      MinVal.Load(SIn);
288      MaxVal.Load(SIn);
289      MinValW.Load(SIn);
290      MaxValW.Load(SIn);
291      NegWgt.Load(SIn);
292      PNoCom.Load(SIn);
293    }
294    void SetGraph(const PUNGraph& GraphPt, const THash<TInt, TIntV>& NIDAttrH);
295    void SetRegCoef(const double _RegCoef) { RegCoef = _RegCoef; }
296    double GetRegCoef() { return RegCoef; }
297    void SetWeightAttr(const double _WeightAttr) { IAssert (_WeightAttr <= 1.0 && _WeightAttr >= 0.0); WeightAttr = _WeightAttr; }
298    double GetWeightAttr() { return WeightAttr; }
299    void SetLassoCoef(const double _LassoCoef) { LassoCoef = _LassoCoef; }
300    int GetAttrs() { return Attrs; }
301    double GetComFromNID(const int& NID, const int& CID) {
302      int NIdx = NIDToIdx.GetKeyId(NID);
303      if (F[NIdx].IsKey(CID)) {
304        return F[NIdx].GetDat(CID);
305      } else {
306        return 0.0;
307      }
308    }
309    double GetLassoCoef() { return LassoCoef; }
310    void InitW() { 
311      W.Gen(Attrs);
312      for (int k = 0; k < Attrs; k++) {
313        W[k].Gen(NumComs + 1);
314      }
315    }
316    void SetAttrHoldOut(const int NID, const int KID) {
317      int NIdx = NIDToIdx.GetKeyId(NID);
318      HOKIDSV[NIdx].AddKey(KID);
319    }
320    void SetAttrHoldOutForOneNode(const int NID) {
321      for (int k = 0; k < Attrs; k++) {
322        SetAttrHoldOut(NID, k);
323      }
324    }
325    void GetW(TVec<TFltV>& _W) { _W = W; }
326    void SetW(TVec<TFltV>& _W) { W = _W; }
327    void RandomInit(const int InitComs);
328    void NeighborComInit(const int InitComs);
329    void NeighborComInit(TFltIntPrV& NIdPhiV, const int InitComs);
330    int GetNumComs() { return NumComs; }
331    void SetCmtyVV(const TVec<TIntV>& CmtyVV);
332    double Likelihood(const bool DoParallel = false);
333    double LikelihoodForRow(const int UID);
334    double LikelihoodForRow(const int UID, const TIntFltH& FU);
335    double LikelihoodAttrKForRow(const int UID, const int K) { return LikelihoodAttrKForRow(UID, K, F[UID]); }
336    double LikelihoodAttrKForRow(const int UID, const int K, const TIntFltH& FU) { return LikelihoodAttrKForRow(UID, K, FU, W[K]); }
337    double LikelihoodAttrKForRow(const int UID, const int K, const TIntFltH& FU, const TFltV& WK);
338    double LikelihoodForWK(const int K, const TFltV& WK) {
339      double L = 0.0;
340      for (int u = 0; u < F.Len(); u++) {
341        if (HOKIDSV[u].IsKey(K)) { continue; }
342        L += LikelihoodAttrKForRow(u, K, F[u], WK);
343      }
344      for (int c = 0; c < WK.Len() - 1; c++) {
345        L -= LassoCoef * fabs(WK[c]);
346      } 
347      return L;
348    }
349    double LikelihoodForWK(const int K) { return LikelihoodForWK(K, W[K]); }
350    double LikelihoodAttr() {
351      double L = 0.0;
352      for (int k = 0; k < Attrs; k++) {
353        for (int u = 0; u < F.Len(); u++) {
354          if (HOKIDSV[u].IsKey(k)) { continue; }
355          L += LikelihoodAttrKForRow(u, k, F[u], W[k]);
356        }
357      }
358      return L;
359    }
360    double LikelihoodGraph() {
361      double L = Likelihood();
362      if (RegCoef > 0.0) { 
363        for (int u = 0; u < F.Len(); u++) {
364          L += RegCoef * Sum(F[u]);
365        }
366      }
367      if (RegCoef < 0.0) { 
368        for (int u = 0; u < F.Len(); u++) {
369          L -= RegCoef * Norm2(F[u]);
370        }
371      }
372      return L - WeightAttr * LikelihoodAttr();
373    }
374    void GenHoldOutAttr(const double HOFrac, TVec<TIntSet>& HOSetV) {
375      HOSetV.Gen(F.Len());
376      int HoldOutCnt = (int) ceil(HOFrac * G->GetNodes() * Attrs);
377      TIntPrSet NIDKIDSet(HoldOutCnt);
378      int Cnt = 0;
379      for (int h = 0; h < 10 * HoldOutCnt; h++) {
380        int UID = Rnd.GetUniDevInt(F.Len());
381        int KID = Rnd.GetUniDevInt(Attrs);
382        if (! NIDKIDSet.IsKey(TIntPr(UID, KID))) { 
383          NIDKIDSet.AddKey(TIntPr(UID, KID)); 
384          HOSetV[UID].AddKey(KID);
385          Cnt++;
386        }
387        if (Cnt >= HoldOutCnt) { break; }
388      }
389      printf("%d hold out pairs generated for attributes\n", Cnt);
390    }
391    void SetHoldOut(const double HOFrac) { 
392      TVec<TIntSet> HoldOut; 
393      TCesnaUtil::GenHoldOutPairs(G, HoldOut, HOFrac, Rnd); 
394      GenHoldOutAttr(HOFrac, HOKIDSV);
395      HOVIDSV = HoldOut; 
396    }
397    void GradientForRow(const int UID, TIntFltH& GradU, const TIntSet& CIDSet);
398    void GradientForWK(TFltV& GradV, const int K) {
399      GradV.Gen(NumComs + 1);
400      for (int u = 0; u < F.Len(); u++) {
401        if (HOKIDSV[u].IsKey(K)) { continue; }
402        double Pred = PredictAttrK(u, K);
403        for (TIntFltH::TIter CI = F[u].BegI(); CI < F[u].EndI(); CI++) { 
404          GradV[CI.GetKey()] += (GetAttr(u, K) - Pred) * GetCom(u, CI.GetKey());
405        }
406        GradV[NumComs] += (GetAttr(u, K) - Pred);
407      }
408      for (int c = 0; c < GradV.Len() - 1; c++) {
409        GradV[c] -= LassoCoef * TMath::Sign(GetW(c, K));
410      }
411    }
412    void GetCmtyVV(TVec<TIntV>& CmtyVV);
413    void GetCmtyVV(TVec<TIntV>& CmtyVV, TVec<TFltV>& Wck, const double Thres, const int MinSz = 3);
414    void GetCmtyVV(TVec<TIntV>& CmtyVV, const double Thres, const int MinSz = 3) {
415      TVec<TFltV> TmpV;
416      GetCmtyVV(CmtyVV, TmpV, Thres, MinSz); 
417    }
418    void GetCmtyVV(TVec<TIntV>& CmtyVV, TVec<TFltV>& Wck) {
419      GetCmtyVV(CmtyVV, Wck, sqrt(2.0 * (double) G->GetEdges() / G->GetNodes() / G->GetNodes()), 3);
420    }
421    void GetCmtyVVUnSorted(TVec<TIntV>& CmtyVV);
422    void GetCmtyVVUnSorted(TVec<TIntV>& CmtyVV, const double Thres, const int MinSz = 3);
423    int FindComs(TIntV& ComsV, const bool UseBIC = false, const double HOFrac = 0.2, const int NumThreads = 20, const TStr PlotLFNm = TStr(), const double StepAlpha = 0.3, const double StepBeta = 0.1);
424    int FindComs(const int NumThreads, const int MaxComs, const int MinComs, const int DivComs, const TStr OutFNm, const bool UseBIC = false, const double HOFrac = 0.1, const double StepAlpha = 0.3, const double StepBeta = 0.3);
425    void DisplayAttrs(const int TopK, const TStrHash<TInt>& NodeNameH) {
426      for (int u = 0; u < X.Len(); u++) {
427        if (NodeNameH.Len() > 0) {
428          printf("NID: %s\t Attrs: ", NodeNameH.GetKey(NIDToIdx[u]));
429        } else {
430          printf("NID: %d\t Attrs: ", NIDToIdx[u].Val);
431        }
432        for (int k = 0; k < X[u].Len(); k++) {
433          printf("%d, ", X[u][k].Val);
434        }
435        printf("\n");
436        if (u >= TopK) { break; }
437      }
438    }
439    double LikelihoodHoldOut();
440    double GetStepSizeByLineSearch(const int UID, const TIntFltH& DeltaV, const TIntFltH& GradV, const double& Alpha, const double& Beta, const int MaxIter = 10);
441    double GetStepSizeByLineSearchForWK(const int K, const TFltV& DeltaV, const TFltV& GradV, const double& Alpha, const double& Beta, const int MaxIter = 10) {
<span onclick='openModal()' class='match'>442      double StepSize = 1.0;
443      double InitLikelihood = LikelihoodForWK(K);
444      TFltV NewVarV(DeltaV.Len());
445      IAssert(DeltaV.Len() == NumComs + 1);
446      for(int iter = 0; iter < MaxIter; iter++) {
</span>447        for (int c = 0; c < DeltaV.Len(); c++){
448          double NewVal = W[K][c] + StepSize * DeltaV[c];
449          if (NewVal < MinValW) { NewVal = MinValW; }
450          if (NewVal > MaxValW) { NewVal = MaxValW; }
451          NewVarV[c] = NewVal;
452        }
453        if (LikelihoodForWK(K, NewVarV) < InitLikelihood + Alpha * StepSize * TLinAlg::DotProduct(GradV, DeltaV)) {
454          StepSize *= Beta;
455        } else {
456          break;
457        }
458        if (iter == MaxIter - 1) { 
459          StepSize = 0.0;
460          break;
461        }
462      }
463      return StepSize;
464    }
465    int GetPositiveW() {
466      int PosCnt = 0;
467      for (int c = 0; c < NumComs; c++) {
468        for (int k = 0; k < Attrs; k++) {
469          if (GetW(c, k) > 0.0) { PosCnt++; }
470        }
471      }
472      return PosCnt;
473    }
474    int MLEGradAscent(const double& Thres, const int& MaxIter, const TStr PlotNm, const double StepAlpha = 0.3, const double StepBeta = 0.1);
475    int MLEGradAscentParallel(const double& Thres, const int& MaxIter, const int ChunkNum, const int ChunkSize, const TStr PlotNm, const double StepAlpha = 0.3, const double StepBeta = 0.1);
476    int MLEGradAscentParallel(const double& Thres, const int& MaxIter, const int ChunkNum, const TStr PlotNm = TStr(), const double StepAlpha = 0.3, const double StepBeta = 0.1) {
477      int ChunkSize = G->GetNodes() / 10 / ChunkNum;
478      if (ChunkSize == 0) { ChunkSize = 1; }
479      return MLEGradAscentParallel(Thres, MaxIter, ChunkNum, ChunkSize, PlotNm, StepAlpha, StepBeta);
480    }
481    double inline GetCom(const int& NID, const int& CID) {
482      if (F[NID].IsKey(CID)) {
483        return F[NID].GetDat(CID);
484      } else {
485        return 0.0;
486      }
487    }
488    double inline GetAttr(const int& NID, const int& K) {
489      if (X[NID].IsKey(K)) {
490        return 1.0;
491      } else {
492        return 0.0;
493      }
494    }
495    void inline AddCom(const int& NID, const int& CID, const double& Val) {
496      if (F[NID].IsKey(CID)) {
497        SumFV[CID] -= F[NID].GetDat(CID);
498      }
499      F[NID].AddDat(CID) = Val;
500      SumFV[CID] += Val;
501    }
502    void inline DelCom(const int& NID, const int& CID) {
503      if (F[NID].IsKey(CID)) {
504        SumFV[CID] -= F[NID].GetDat(CID);
505        F[NID].DelKey(CID);
506      }
507    }
508    double inline DotProduct(const TIntFltH& UV, const TIntFltH& VV) {
509      double DP = 0;
510      if (UV.Len() > VV.Len()) {
511        for (TIntFltH::TIter HI = UV.BegI(); HI < UV.EndI(); HI++) {
512          if (VV.IsKey(HI.GetKey())) { 
513            DP += VV.GetDat(HI.GetKey()) * HI.GetDat(); 
514          }
515        }
516      } else {
517        for (TIntFltH::TIter HI = VV.BegI(); HI < VV.EndI(); HI++) {
518          if (UV.IsKey(HI.GetKey())) { 
519            DP += UV.GetDat(HI.GetKey()) * HI.GetDat(); 
520          }
521        }
522      }
523      return DP;
524    }
525    double inline DotProduct(const int& UID, const int& VID) {
526      return DotProduct(F[UID], F[VID]);
527    }
528    double inline Prediction(const TIntFltH& FU, const TIntFltH& FV) {
529      double DP = log (1.0 / (1.0 - PNoCom)) + DotProduct(FU, FV);
530      IAssertR(DP > 0.0, TStr::Fmt("DP: %f", DP));
531      return exp(- DP);
532    }
533    double inline PredictAttrK(const TIntFltH& FU, const TFltV& WK) {
534      double DP = 0.0;
535      for (TIntFltH::TIter FI = FU.BegI(); FI < FU.EndI(); FI++) {
536        DP += FI.GetDat() * WK[FI.GetKey()];
537      }
538      DP += WK.Last();
539      return Sigmoid(DP);
540    }
541    double inline PredictAttrK(const TIntFltH& FU, const int K) {
542      return PredictAttrK(FU, W[K]);
543    }
544    double inline PredictAttrK(const int UID, const int K) {
545      return PredictAttrK(F[UID], W[K]);
546    }
547    double inline GetW(const int CID, const int K) {
548      return W[K][CID];
549    }
550    double inline Prediction(const int& UID, const int& VID) {
551      return Prediction(F[UID], F[VID]);
552    }
553    double inline Sum(const TIntFltH& UV) {
554      double N = 0.0;
555      for (TIntFltH::TIter HI = UV.BegI(); HI < UV.EndI(); HI++) {
556        N += HI.GetDat();
557      }
558      return N;
559    }
560    double inline Norm2(const TIntFltH& UV) {
561      double N = 0.0;
562      for (TIntFltH::TIter HI = UV.BegI(); HI < UV.EndI(); HI++) {
563        N += HI.GetDat() * HI.GetDat();
564      }
565      return N;
566    }
567    double inline Sigmoid(const double X) {
568      return 1.0 / ( 1.0 + exp(-X));
569    }
570  };
571  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-colpartition.cpp</h3>
            <pre><code>1  #ifdef HAVE_CONFIG_H
2  #  include "config_auto.h"
3  #endif
4  #include "colpartition.h"
5  #include "colpartitiongrid.h"
6  #include "colpartitionset.h"
7  #include "detlinefit.h"
8  #include "dppoint.h"
9  #include "helpers.h" 
10  #include "host.h"    
11  #include "imagefind.h"
12  #include "workingpartset.h"
13  #include <algorithm>
14  namespace tesseract {
15  enum SpacingNeighbourhood {
16    PN_ABOVE2,
17    PN_ABOVE1,
18    PN_UPPER,
19    PN_LOWER,
20    PN_BELOW1,
21    PN_BELOW2,
22    PN_COUNT
23  };
24  const double kMaxSpacingDrift = 1.0 / 72; 
25  const double kMaxTopSpacingFraction = 0.25;
26  const double kMaxSameBlockLineSpacing = 3;
27  const double kMaxSizeRatio = 1.5;
28  const double kMaxLeaderGapFractionOfMax = 0.25;
29  const double kMaxLeaderGapFractionOfMin = 0.5;
30  const int kMinLeaderCount = 5;
31  const int kMinStrongTextValue = 6;
32  const int kMinChainTextValue = 3;
33  const int kHorzStrongTextlineCount = 8;
34  const int kHorzStrongTextlineHeight = 10;
35  const int kHorzStrongTextlineAspect = 5;
36  const double kMaxBaselineError = 0.4375;
37  const double kMinBaselineCoverage = 0.5;
38  const int kMaxRMSColorNoise = 128;
39  const int kMaxColorDistance = 900;
40  ColPartition::ColPartition(BlobRegionType blob_type, const ICOORD &vertical)
41      : left_margin_(-INT32_MAX),
42        right_margin_(INT32_MAX),
43        median_bottom_(INT32_MAX),
44        median_top_(-INT32_MAX),
45        median_left_(INT32_MAX),
46        median_right_(-INT32_MAX),
47        blob_type_(blob_type),
48        vertical_(vertical) {
49    memset(special_blobs_densities_, 0, sizeof(special_blobs_densities_));
50  }
51  ColPartition *ColPartition::FakePartition(const TBOX &box,
52                                            PolyBlockType block_type,
53                                            BlobRegionType blob_type,
54                                            BlobTextFlowType flow) {
55    auto *part = new ColPartition(blob_type, ICOORD(0, 1));
56    part->set_type(block_type);
57    part->set_flow(flow);
58    part->AddBox(new BLOBNBOX(C_BLOB::FakeBlob(box)));
59    part->set_left_margin(box.left());
60    part->set_right_margin(box.right());
61    part->SetBlobTypes();
62    part->ComputeLimits();
63    part->ClaimBoxes();
64    return part;
65  }
66  ColPartition *ColPartition::MakeBigPartition(BLOBNBOX *box,
67                                               ColPartition_LIST *big_part_list) {
68    box->set_owner(nullptr);
69    auto *single = new ColPartition(BRT_UNKNOWN, ICOORD(0, 1));
70    single->set_flow(BTFT_NONE);
71    single->AddBox(box);
72    single->ComputeLimits();
73    single->ClaimBoxes();
74    single->SetBlobTypes();
75    single->set_block_owned(true);
76    if (big_part_list != nullptr) {
77      ColPartition_IT part_it(big_part_list);
78      part_it.add_to_end(single);
79    }
80    return single;
81  }
82  ColPartition::~ColPartition() {
83    ColPartition_C_IT it(&upper_partners_);
84    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
85      it.data()->RemovePartner(false, this);
86    }
87    it.set_to_list(&lower_partners_);
88    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
89      it.data()->RemovePartner(true, this);
90    }
91  }
92  ColPartition *ColPartition::MakeLinePartition(BlobRegionType blob_type,
93                                                const ICOORD &vertical, int left,
94                                                int bottom, int right, int top) {
95    auto *part = new ColPartition(blob_type, vertical);
96    part->bounding_box_ = TBOX(left, bottom, right, top);
97    part->median_bottom_ = bottom;
98    part->median_top_ = top;
99    part->median_height_ = top - bottom;
100    part->median_left_ = left;
101    part->median_right_ = right;
102    part->median_width_ = right - left;
103    part->left_key_ = part->BoxLeftKey();
104    part->right_key_ = part->BoxRightKey();
105    return part;
106  }
107  void ColPartition::AddBox(BLOBNBOX *bbox) {
108    TBOX box = bbox->bounding_box();
109    if (boxes_.empty()) {
110      bounding_box_ = box;
111    } else {
112      bounding_box_ += box;
113    }
114    if (IsVerticalType()) {
115      if (!last_add_was_vertical_) {
116        boxes_.sort(SortByBoxBottom<BLOBNBOX>);
117        last_add_was_vertical_ = true;
118      }
119      boxes_.add_sorted(SortByBoxBottom<BLOBNBOX>, true, bbox);
120    } else {
121      if (last_add_was_vertical_) {
122        boxes_.sort(SortByBoxLeft<BLOBNBOX>);
123        last_add_was_vertical_ = false;
124      }
125      boxes_.add_sorted(SortByBoxLeft<BLOBNBOX>, true, bbox);
126    }
127    if (!left_key_tab_) {
128      left_key_ = BoxLeftKey();
129    }
130    if (!right_key_tab_) {
131      right_key_ = BoxRightKey();
132    }
133    if (TabFind::WithinTestRegion(2, box.left(), box.bottom())) {
134      tprintf("Added box (%d,%d)->(%d,%d) left_blob_x_=%d, right_blob_x_ = %d\n",
135              box.left(), box.bottom(), box.right(), box.top(),
136              bounding_box_.left(), bounding_box_.right());
137    }
138  }
139  void ColPartition::RemoveBox(BLOBNBOX *box) {
140    BLOBNBOX_C_IT bb_it(&boxes_);
141    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
142      if (box == bb_it.data()) {
143        bb_it.extract();
144        ComputeLimits();
145        return;
146      }
147    }
148  }
149  BLOBNBOX *ColPartition::BiggestBox() {
150    BLOBNBOX *biggest = nullptr;
151    BLOBNBOX_C_IT bb_it(&boxes_);
152    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
153      BLOBNBOX *bbox = bb_it.data();
154      if (IsVerticalType()) {
155        if (biggest == nullptr ||
156            bbox->bounding_box().width() > biggest->bounding_box().width()) {
157          biggest = bbox;
158        }
159      } else {
160        if (biggest == nullptr ||
161            bbox->bounding_box().height() > biggest->bounding_box().height()) {
162          biggest = bbox;
163        }
164      }
165    }
166    return biggest;
167  }
168  TBOX ColPartition::BoundsWithoutBox(BLOBNBOX *box) {
169    TBOX result;
170    BLOBNBOX_C_IT bb_it(&boxes_);
171    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
172      if (box != bb_it.data()) {
173        result += bb_it.data()->bounding_box();
174      }
175    }
176    return result;
177  }
178  void ColPartition::ClaimBoxes() {
179    BLOBNBOX_C_IT bb_it(&boxes_);
180    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
181      BLOBNBOX *bblob = bb_it.data();
182      ColPartition *other = bblob->owner();
183      if (other == nullptr) {
184        bblob->set_owner(this);
185      } else {
186        ASSERT_HOST(other == this);
187      }
188    }
189  }
190  void ColPartition::DisownBoxes() {
191    BLOBNBOX_C_IT bb_it(&boxes_);
192    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
193      BLOBNBOX *bblob = bb_it.data();
194      ASSERT_HOST(bblob->owner() == this || bblob->owner() == nullptr);
195      bblob->set_owner(nullptr);
196    }
197  }
198  void ColPartition::DisownBoxesNoAssert() {
199    BLOBNBOX_C_IT bb_it(&boxes_);
200    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
201      BLOBNBOX *bblob = bb_it.data();
202      if (bblob->owner() == this) {
203        bblob->set_owner(nullptr);
204      }
205    }
206  }
207  bool ColPartition::ReleaseNonLeaderBoxes() {
208    BLOBNBOX_C_IT bb_it(&boxes_);
209    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
210      BLOBNBOX *bblob = bb_it.data();
211      if (bblob->flow() != BTFT_LEADER) {
212        if (bblob->owner() == this) {
213          bblob->set_owner(nullptr);
214        }
215        bb_it.extract();
216      }
217    }
218    if (bb_it.empty()) {
219      return false;
220    }
221    flow_ = BTFT_LEADER;
222    ComputeLimits();
223    return true;
224  }
225  void ColPartition::DeleteBoxes() {
226    for (BLOBNBOX_C_IT bb_it(&boxes_); !bb_it.empty(); bb_it.forward()) {
227      BLOBNBOX *bblob = bb_it.extract();
228      delete bblob->remove_cblob();
229      delete bblob;
230    }
231  }
232  void ColPartition::ReflectInYAxis() {
233    BLOBNBOX_CLIST reversed_boxes;
234    BLOBNBOX_C_IT reversed_it(&reversed_boxes);
235    BLOBNBOX_C_IT bb_it(&boxes_);
236    for (bb_it.mark_cycle_pt(); !bb_it.cycled_list(); bb_it.forward()) {
237      reversed_it.add_before_then_move(bb_it.extract());
238    }
239    bb_it.add_list_after(&reversed_boxes);
240    ASSERT_HOST(!left_key_tab_ && !right_key_tab_);
241    int tmp = left_margin_;
242    left_margin_ = -right_margin_;
243    right_margin_ = -tmp;
244    ComputeLimits();
245  }
246  bool ColPartition::IsLegal() {
247    if (bounding_box_.left() > bounding_box_.right()) {
248      if (textord_debug_bugs) {
249        tprintf("Bounding box invalid\n");
250        Print();
251      }
252      return false; 
253    }
254    if (left_margin_ > bounding_box_.left() ||
255        right_margin_ < bounding_box_.right()) {
256      if (textord_debug_bugs) {
257        tprintf("Margins invalid\n");
258        Print();
259      }
260      return false; 
261    }
262    if (left_key_ > BoxLeftKey() || right_key_ < BoxRightKey()) {
263      if (textord_debug_bugs) {
264        tprintf("Key inside box: %d v %d or %d v %d\n", left_key_, BoxLeftKey(),
265                right_key_, BoxRightKey());
266        Print();
267      }
268      return false; 
269    }
270    return true;
271  }
272  bool ColPartition::MatchingColumns(const ColPartition &other) const {
273    int y = (MidY() + other.MidY()) / 2;
274    if (!NearlyEqual(other.LeftAtY(y) / kColumnWidthFactor,
275                     LeftAtY(y) / kColumnWidthFactor, 1)) {
276      return false;
277    }
278    if (!NearlyEqual(other.RightAtY(y) / kColumnWidthFactor,
279                     RightAtY(y) / kColumnWidthFactor, 1)) {
280      return false;
281    }
282    return true;
283  }
284  bool ColPartition::MatchingTextColor(const ColPartition &other) const {
285    if (color1_[L_ALPHA_CHANNEL] > kMaxRMSColorNoise &&
286        other.color1_[L_ALPHA_CHANNEL] > kMaxRMSColorNoise) {
287      return false; 
288    }
289    double d_this1_o =
290        ImageFind::ColorDistanceFromLine(other.color1_, other.color2_, color1_);
291    double d_this2_o =
292        ImageFind::ColorDistanceFromLine(other.color1_, other.color2_, color2_);
293    double d_o1_this =
294        ImageFind::ColorDistanceFromLine(color1_, color2_, other.color1_);
295    double d_o2_this =
296        ImageFind::ColorDistanceFromLine(color1_, color2_, other.color2_);
297    return d_this1_o < kMaxColorDistance && d_this2_o < kMaxColorDistance &&
298           d_o1_this < kMaxColorDistance && d_o2_this < kMaxColorDistance;
299  }
300  bool ColPartition::MatchingSizes(const ColPartition &other) const {
301    if (blob_type_ == BRT_VERT_TEXT || other.blob_type_ == BRT_VERT_TEXT) {
302      return !TabFind::DifferentSizes(median_width_, other.median_width_);
303    } else {
304      return !TabFind::DifferentSizes(median_height_, other.median_height_);
305    }
306  }
307  bool ColPartition::ConfirmNoTabViolation(const ColPartition &other) const {
308    if (bounding_box_.right() < other.bounding_box_.left() &&
309        bounding_box_.right() < other.LeftBlobRule()) {
310      return false;
311    }
312    if (other.bounding_box_.right() < bounding_box_.left() &&
313        other.bounding_box_.right() < LeftBlobRule()) {
314      return false;
315    }
316    if (bounding_box_.left() > other.bounding_box_.right() &&
317        bounding_box_.left() > other.RightBlobRule()) {
318      return false;
319    }
320    if (other.bounding_box_.left() > bounding_box_.right() &&
321        other.bounding_box_.left() > RightBlobRule()) {
322      return false;
323    }
324    return true;
325  }
326  bool ColPartition::MatchingStrokeWidth(const ColPartition &other,
327                                         double fractional_tolerance,
328                                         double constant_tolerance) const {
329    int match_count = 0;
330    int nonmatch_count = 0;
331    BLOBNBOX_C_IT box_it(const_cast<BLOBNBOX_CLIST *>(&boxes_));
332    BLOBNBOX_C_IT other_it(const_cast<BLOBNBOX_CLIST *>(&other.boxes_));
333    box_it.mark_cycle_pt();
334    other_it.mark_cycle_pt();
335    while (!box_it.cycled_list() && !other_it.cycled_list()) {
336      if (box_it.data()->MatchingStrokeWidth(
337              *other_it.data(), fractional_tolerance, constant_tolerance)) {
338        ++match_count;
339      } else {
340        ++nonmatch_count;
341      }
342      box_it.forward();
343      other_it.forward();
344    }
345    return match_count > nonmatch_count;
346  }
347  bool ColPartition::OKDiacriticMerge(const ColPartition &candidate,
348                                      bool debug) const {
349    BLOBNBOX_C_IT it(const_cast<BLOBNBOX_CLIST *>(&boxes_));
350    int min_top = INT32_MAX;
351    int max_bottom = -INT32_MAX;
352    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
353      BLOBNBOX *blob = it.data();
354      if (!blob->IsDiacritic()) {
355        if (debug) {
356          tprintf("Blob is not a diacritic:");
357          blob->bounding_box().print();
358        }
359        return false; 
360      }
361      if (blob->base_char_top() < min_top) {
362        min_top = blob->base_char_top();
363      }
364      if (blob->base_char_bottom() > max_bottom) {
365        max_bottom = blob->base_char_bottom();
366      }
367    }
368    bool result =
369        min_top > candidate.median_bottom_ && max_bottom < candidate.median_top_;
370    if (debug) {
371      if (result) {
372        tprintf("OKDiacritic!\n");
373      } else {
374        tprintf("y ranges don\'t overlap: %d-%d / %d-%d\n", max_bottom, min_top,
375                median_bottom_, median_top_);
376      }
377    }
378    return result;
379  }
380  void ColPartition::SetLeftTab(const TabVector *tab_vector) {
381    if (tab_vector != nullptr) {
382      left_key_ = tab_vector->sort_key();
383      left_key_tab_ = left_key_ <= BoxLeftKey();
384    } else {
385      left_key_tab_ = false;
386    }
387    if (!left_key_tab_) {
388      left_key_ = BoxLeftKey();
389    }
390  }
391  void ColPartition::SetRightTab(const TabVector *tab_vector) {
392    if (tab_vector != nullptr) {
393      right_key_ = tab_vector->sort_key();
394      right_key_tab_ = right_key_ >= BoxRightKey();
395    } else {
396      right_key_tab_ = false;
397    }
398    if (!right_key_tab_) {
399      right_key_ = BoxRightKey();
400    }
401  }
402  void ColPartition::CopyLeftTab(const ColPartition &src, bool take_box) {
403    left_key_tab_ = take_box ? false : src.left_key_tab_;
404    if (left_key_tab_) {
405      left_key_ = src.left_key_;
406    } else {
407      bounding_box_.set_left(XAtY(src.BoxLeftKey(), MidY()));
408      left_key_ = BoxLeftKey();
409    }
410    if (left_margin_ > bounding_box_.left()) {
411      left_margin_ = src.left_margin_;
412    }
413  }
414  void ColPartition::CopyRightTab(const ColPartition &src, bool take_box) {
415    right_key_tab_ = take_box ? false : src.right_key_tab_;
416    if (right_key_tab_) {
417      right_key_ = src.right_key_;
418    } else {
419      bounding_box_.set_right(XAtY(src.BoxRightKey(), MidY()));
420      right_key_ = BoxRightKey();
421    }
422    if (right_margin_ < bounding_box_.right()) {
423      right_margin_ = src.right_margin_;
424    }
425  }
426  int ColPartition::LeftBlobRule() const {
427    BLOBNBOX_C_IT it(const_cast<BLOBNBOX_CLIST *>(&boxes_));
428    return it.data()->left_rule();
429  }
430  int ColPartition::RightBlobRule() const {
431    BLOBNBOX_C_IT it(const_cast<BLOBNBOX_CLIST *>(&boxes_));
432    it.move_to_last();
433    return it.data()->right_rule();
434  }
435  float ColPartition::SpecialBlobsDensity(const BlobSpecialTextType type) const {
436    ASSERT_HOST(type < BSTT_COUNT);
437    return special_blobs_densities_[type];
438  }
439  int ColPartition::SpecialBlobsCount(const BlobSpecialTextType type) {
440    ASSERT_HOST(type < BSTT_COUNT);
441    BLOBNBOX_C_IT blob_it(&boxes_);
442    int count = 0;
443    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
444      BLOBNBOX *blob = blob_it.data();
445      BlobSpecialTextType blob_type = blob->special_text_type();
446      if (blob_type == type) {
447        count++;
448      }
449    }
450    return count;
451  }
452  void ColPartition::SetSpecialBlobsDensity(const BlobSpecialTextType type,
453                                            const float density) {
454    ASSERT_HOST(type < BSTT_COUNT);
455    special_blobs_densities_[type] = density;
456  }
457  void ColPartition::ComputeSpecialBlobsDensity() {
458    memset(special_blobs_densities_, 0, sizeof(special_blobs_densities_));
459    if (boxes_.empty()) {
460      return;
461    }
462    BLOBNBOX_C_IT blob_it(&boxes_);
463    for (blob_it.mark_cycle_pt(); !blob_it.cycled_list(); blob_it.forward()) {
464      BLOBNBOX *blob = blob_it.data();
465      BlobSpecialTextType type = blob->special_text_type();
466      special_blobs_densities_[type]++;
467    }
468    for (float &special_blobs_density : special_blobs_densities_) {
469      special_blobs_density /= boxes_.length();
470    }
471  }
472  void ColPartition::AddPartner(bool upper, ColPartition *partner) {
473    if (upper) {
474      partner->lower_partners_.add_sorted(SortByBoxLeft<ColPartition>, true,
475                                          this);
476      upper_partners_.add_sorted(SortByBoxLeft<ColPartition>, true, partner);
477    } else {
478      partner->upper_partners_.add_sorted(SortByBoxLeft<ColPartition>, true,
479                                          this);
480      lower_partners_.add_sorted(SortByBoxLeft<ColPartition>, true, partner);
481    }
482  }
483  void ColPartition::RemovePartner(bool upper, ColPartition *partner) {
484    ColPartition_C_IT it(upper ? &upper_partners_ : &lower_partners_);
485    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
486      if (it.data() == partner) {
487        it.extract();
488        break;
489      }
490    }
491  }
492  ColPartition *ColPartition::SingletonPartner(bool upper) {
493    ColPartition_CLIST *partners = upper ? &upper_partners_ : &lower_partners_;
494    if (!partners->singleton()) {
495      return nullptr;
496    }
497    ColPartition_C_IT it(partners);
498    return it.data();
499  }
500  void ColPartition::Absorb(ColPartition *other, const WidthCallback &cb) {
501    ASSERT_HOST(owns_blobs() == other->owns_blobs());
502    if (TabFind::WithinTestRegion(2, bounding_box_.left(),
503                                  bounding_box_.bottom()) ||
504        TabFind::WithinTestRegion(2, other->bounding_box_.left(),
505                                  other->bounding_box_.bottom())) {
506      tprintf("Merging:");
507      Print();
508      other->Print();
509    }
510    memset(special_blobs_densities_, 0, sizeof(special_blobs_densities_));
511    for (int type = 0; type < BSTT_COUNT; ++type) {
512      unsigned w1 = boxes_.length();
513      unsigned w2 = other->boxes_.length();
514      float new_val = special_blobs_densities_[type] * w1 +
515                      other->special_blobs_densities_[type] * w2;
516      if (!w1 || !w2) {
517        ASSERT_HOST((w1 + w2) > 0);
518        special_blobs_densities_[type] = new_val / (w1 + w2);
519      }
520    }
521    BLOBNBOX_C_IT it(&boxes_);
522    BLOBNBOX_C_IT it2(&other->boxes_);
523    for (; !it2.empty(); it2.forward()) {
524      BLOBNBOX *bbox2 = it2.extract();
525      ColPartition *prev_owner = bbox2->owner();
526      if (prev_owner != other && prev_owner != nullptr) {
527        continue;
528      }
529      ASSERT_HOST(prev_owner == other || prev_owner == nullptr);
530      if (prev_owner == other) {
531        bbox2->set_owner(this);
532      }
533      it.add_to_end(bbox2);
534    }
535    left_margin_ = std::min(left_margin_, other->left_margin_);
536    right_margin_ = std::max(right_margin_, other->right_margin_);
537    if (other->left_key_ < left_key_) {
538      left_key_ = other->left_key_;
539      left_key_tab_ = other->left_key_tab_;
540    }
541    if (other->right_key_ > right_key_) {
542      right_key_ = other->right_key_;
543      right_key_tab_ = other->right_key_tab_;
544    }
545    if (!DominatesInMerge(flow_, other->flow_)) {
546      flow_ = other->flow_;
547      blob_type_ = other->blob_type_;
548    }
549    SetBlobTypes();
550    if (IsVerticalType()) {
551      boxes_.sort(SortByBoxBottom<BLOBNBOX>);
552      last_add_was_vertical_ = true;
553    } else {
554      boxes_.sort(SortByBoxLeft<BLOBNBOX>);
555      last_add_was_vertical_ = false;
556    }
557    ComputeLimits();
558    for (int upper = 0; upper < 2; ++upper) {
559      ColPartition_CLIST partners;
560      ColPartition_C_IT part_it(&partners);
561      part_it.add_list_after(upper ? &other->upper_partners_
562                                   : &other->lower_partners_);
563      for (part_it.move_to_first(); !part_it.empty(); part_it.forward()) {
564        ColPartition *partner = part_it.extract();
565        partner->RemovePartner(!upper, other);
566        partner->RemovePartner(!upper, this);
567        partner->AddPartner(!upper, this);
568      }
569    }
570    delete other;
571    if (cb != nullptr) {
572      SetColumnGoodness(cb);
573    }
574  }
575  bool ColPartition::OKMergeOverlap(const ColPartition &merge1,
576                                    const ColPartition &merge2,
577                                    int ok_box_overlap, bool debug) {
578    if (IsVerticalType() || merge1.IsVerticalType() || merge2.IsVerticalType()) {
579      if (debug) {
580        tprintf("Vertical partition\n");
581      }
582      return false;
583    }
584    if (!merge1.VSignificantCoreOverlap(merge2)) {
585      if (debug) {
586        tprintf("Voverlap %d (%d)\n", merge1.VCoreOverlap(merge2),
587                merge1.VSignificantCoreOverlap(merge2));
588      }
589      return false;
590    }
591    TBOX merged_box(merge1.bounding_box());
592    merged_box += merge2.bounding_box();
593    if (merged_box.bottom() < median_top_ && merged_box.top() > median_bottom_ &&
594        merged_box.bottom() < bounding_box_.top() - ok_box_overlap &&
595        merged_box.top() > bounding_box_.bottom() + ok_box_overlap) {
596      if (debug) {
597        tprintf("Excessive box overlap\n");
598      }
599      return false;
600    }
601    return true;
602  }
603  BLOBNBOX *ColPartition::OverlapSplitBlob(const TBOX &box) {
604    if (boxes_.empty() || boxes_.singleton()) {
605      return nullptr;
606    }
607    BLOBNBOX_C_IT it(&boxes_);
608    TBOX left_box(it.data()->bounding_box());
609    for (it.forward(); !it.at_first(); it.forward()) {
610      BLOBNBOX *bbox = it.data();
611      left_box += bbox->bounding_box();
612      if (left_box.overlap(box)) {
613        return bbox;
614      }
615    }
616    return nullptr;
617  }
618  ColPartition *ColPartition::SplitAtBlob(BLOBNBOX *split_blob) {
619    ColPartition *split_part = ShallowCopy();
620    split_part->set_owns_blobs(owns_blobs());
621    BLOBNBOX_C_IT it(&boxes_);
622    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
623      BLOBNBOX *bbox = it.data();
624      ColPartition *prev_owner = bbox->owner();
625      ASSERT_HOST(!owns_blobs() || prev_owner == this || prev_owner == nullptr);
626      if (bbox == split_blob || !split_part->boxes_.empty()) {
627        split_part->AddBox(it.extract());
628        if (owns_blobs() && prev_owner != nullptr) {
629          bbox->set_owner(split_part);
630        }
631      }
632    }
633    ASSERT_HOST(!it.empty());
634    if (split_part->IsEmpty()) {
635      delete split_part;
636      return nullptr;
637    }
638    right_key_tab_ = false;
639    split_part->left_key_tab_ = false;
640    ComputeLimits();
641    split_part->ComputeLimits();
642    return split_part;
643  }
644  ColPartition *ColPartition::SplitAt(int split_x) {
645    if (split_x <= bounding_box_.left() || split_x >= bounding_box_.right()) {
646      return nullptr; 
647    }
648    ColPartition *split_part = ShallowCopy();
649    split_part->set_owns_blobs(owns_blobs());
650    BLOBNBOX_C_IT it(&boxes_);
651    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
652      BLOBNBOX *bbox = it.data();
653      ColPartition *prev_owner = bbox->owner();
654      ASSERT_HOST(!owns_blobs() || prev_owner == this || prev_owner == nullptr);
655      const TBOX &box = bbox->bounding_box();
656      if (box.left() >= split_x) {
657        split_part->AddBox(it.extract());
658        if (owns_blobs() && prev_owner != nullptr) {
659          bbox->set_owner(split_part);
660        }
661      }
662    }
663    if (it.empty()) {
664      it.add_list_after(&split_part->boxes_);
665    }
666    ASSERT_HOST(!it.empty());
667    if (split_part->IsEmpty()) {
668      delete split_part;
669      return nullptr;
670    }
671    right_key_tab_ = false;
672    split_part->left_key_tab_ = false;
673    right_margin_ = split_x;
674    split_part->left_margin_ = split_x;
675    ComputeLimits();
676    split_part->ComputeLimits();
677    return split_part;
678  }
679  void ColPartition::ComputeLimits() {
680    bounding_box_ = TBOX(); 
681    BLOBNBOX_C_IT it(&boxes_);
682    BLOBNBOX *bbox = nullptr;
683    int non_leader_count = 0;
684    if (it.empty()) {
685      bounding_box_.set_left(left_margin_);
686      bounding_box_.set_right(right_margin_);
687      bounding_box_.set_bottom(0);
688      bounding_box_.set_top(0);
689    } else {
690      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
691        bbox = it.data();
692        bounding_box_ += bbox->bounding_box();
693        if (bbox->flow() != BTFT_LEADER) {
694          ++non_leader_count;
695        }
696      }
697    }
698    if (!left_key_tab_) {
699      left_key_ = BoxLeftKey();
700    }
701    if (left_key_ > BoxLeftKey() && textord_debug_bugs) {
702      tprintf("Computed left-illegal partition\n");
703      Print();
704    }
705    if (!right_key_tab_) {
706      right_key_ = BoxRightKey();
707    }
708    if (right_key_ < BoxRightKey() && textord_debug_bugs) {
709      tprintf("Computed right-illegal partition\n");
710      Print();
711    }
712    if (it.empty()) {
713      return;
714    }
715    if (IsImageType() || blob_type() == BRT_RECTIMAGE ||
716        blob_type() == BRT_POLYIMAGE) {
717      median_top_ = bounding_box_.top();
718      median_bottom_ = bounding_box_.bottom();
719      median_height_ = bounding_box_.height();
720      median_left_ = bounding_box_.left();
721      median_right_ = bounding_box_.right();
722      median_width_ = bounding_box_.width();
723    } else {
724      STATS top_stats(bounding_box_.bottom(), bounding_box_.top());
725      STATS bottom_stats(bounding_box_.bottom(), bounding_box_.top());
726      STATS height_stats(0, bounding_box_.height());
727      STATS left_stats(bounding_box_.left(), bounding_box_.right());
728      STATS right_stats(bounding_box_.left(), bounding_box_.right());
729      STATS width_stats(0, bounding_box_.width());
730      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
731        bbox = it.data();
732        if (non_leader_count == 0 || bbox->flow() != BTFT_LEADER) {
733          const TBOX &box = bbox->bounding_box();
734          int area = box.area();
735          top_stats.add(box.top(), area);
736          bottom_stats.add(box.bottom(), area);
737          height_stats.add(box.height(), area);
738          left_stats.add(box.left(), area);
739          right_stats.add(box.right(), area);
740          width_stats.add(box.width(), area);
741        }
742      }
743      median_top_ = static_cast<int>(top_stats.median() + 0.5);
744      median_bottom_ = static_cast<int>(bottom_stats.median() + 0.5);
745      median_height_ = static_cast<int>(height_stats.median() + 0.5);
746      median_left_ = static_cast<int>(left_stats.median() + 0.5);
747      median_right_ = static_cast<int>(right_stats.median() + 0.5);
748      median_width_ = static_cast<int>(width_stats.median() + 0.5);
749    }
750    if (right_margin_ < bounding_box_.right() && textord_debug_bugs) {
751      tprintf("Made partition with bad right coords, %d < %d\n", right_margin_,
752              bounding_box_.right());
753      Print();
754    }
755    if (left_margin_ > bounding_box_.left() && textord_debug_bugs) {
756      tprintf("Made partition with bad left coords, %d > %d\n", left_margin_,
757              bounding_box_.left());
758      Print();
759    }
760    for (int upper = 0; upper < 2; ++upper) {
761      ColPartition_CLIST partners;
762      ColPartition_C_IT part_it(&partners);
763      part_it.add_list_after(upper ? &upper_partners_ : &lower_partners_);
764      for (part_it.move_to_first(); !part_it.empty(); part_it.forward()) {
765        ColPartition *partner = part_it.extract();
766        partner->RemovePartner(!upper, this);
767        partner->AddPartner(!upper, this);
768      }
769    }
770    if (TabFind::WithinTestRegion(2, bounding_box_.left(),
771                                  bounding_box_.bottom())) {
772      tprintf("Recomputed box for partition %p\n", static_cast<void *>(this));
773      Print();
774    }
775  }
776  int ColPartition::CountOverlappingBoxes(const TBOX &box) {
777    BLOBNBOX_C_IT it(&boxes_);
778    int overlap_count = 0;
779    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
780      BLOBNBOX *bbox = it.data();
781      if (box.overlap(bbox->bounding_box())) {
782        ++overlap_count;
783      }
784    }
785    return overlap_count;
786  }
787  void ColPartition::SetPartitionType(int resolution, ColPartitionSet *columns) {
788    int first_spanned_col = -1;
789    ColumnSpanningType span_type = columns->SpanningType(
790        resolution, bounding_box_.left(), bounding_box_.right(),
791        std::min(bounding_box_.height(), bounding_box_.width()), MidY(),
792        left_margin_, right_margin_, &first_column_, &last_column_,
793        &first_spanned_col);
794    column_set_ = columns;
795    if (first_column_ < last_column_ && span_type == CST_PULLOUT &&
796        !IsLineType()) {
797      if (first_spanned_col >= 0) {
798        first_column_ = first_spanned_col;
799        last_column_ = first_spanned_col;
800      } else {
801        if ((first_column_ & 1) == 0) {
802          last_column_ = first_column_;
803        } else if ((last_column_ & 1) == 0) {
804          first_column_ = last_column_;
805        } else {
806          first_column_ = last_column_ = (first_column_ + last_column_) / 2;
807        }
808      }
809    }
810    type_ = PartitionType(span_type);
811  }
812  PolyBlockType ColPartition::PartitionType(ColumnSpanningType flow) const {
813    if (flow == CST_NOISE) {
814      if (blob_type_ != BRT_HLINE && blob_type_ != BRT_VLINE &&
815          blob_type_ != BRT_RECTIMAGE && blob_type_ != BRT_VERT_TEXT) {
816        return PT_NOISE;
817      }
818      flow = CST_FLOWING;
819    }
820    switch (blob_type_) {
821      case BRT_NOISE:
822        return PT_NOISE;
823      case BRT_HLINE:
824        return PT_HORZ_LINE;
825      case BRT_VLINE:
826        return PT_VERT_LINE;
827      case BRT_RECTIMAGE:
828      case BRT_POLYIMAGE:
829        switch (flow) {
830          case CST_FLOWING:
831            return PT_FLOWING_IMAGE;
832          case CST_HEADING:
833            return PT_HEADING_IMAGE;
834          case CST_PULLOUT:
835            return PT_PULLOUT_IMAGE;
836          default:
837            ASSERT_HOST(!"Undefined flow type for image!");
838        }
839        break;
840      case BRT_VERT_TEXT:
841        return PT_VERTICAL_TEXT;
842      case BRT_TEXT:
843      case BRT_UNKNOWN:
844      default:
845        switch (flow) {
846          case CST_FLOWING:
847            return PT_FLOWING_TEXT;
848          case CST_HEADING:
849            return PT_HEADING_TEXT;
850          case CST_PULLOUT:
851            return PT_PULLOUT_TEXT;
852          default:
853            ASSERT_HOST(!"Undefined flow type for text!");
854        }
855    }
856    ASSERT_HOST(!"Should never get here!");
857    return PT_NOISE;
858  }
859  void ColPartition::ColumnRange(int resolution, ColPartitionSet *columns,
860                                 int *first_col, int *last_col) {
861    int first_spanned_col = -1;
862    ColumnSpanningType span_type = columns->SpanningType(
863        resolution, bounding_box_.left(), bounding_box_.right(),
864        std::min(bounding_box_.height(), bounding_box_.width()), MidY(),
865        left_margin_, right_margin_, first_col, last_col, &first_spanned_col);
866    type_ = PartitionType(span_type);
867  }
868  void ColPartition::SetColumnGoodness(const WidthCallback &cb) {
869    int y = MidY();
870    int width = RightAtY(y) - LeftAtY(y);
871    good_width_ = cb(width);
872    good_column_ = blob_type_ == BRT_TEXT && left_key_tab_ && right_key_tab_;
873  }
874  bool ColPartition::MarkAsLeaderIfMonospaced() {
875    bool result = false;
876    int part_width = bounding_box_.width();
877    STATS gap_stats(0, part_width - 1);
878    STATS width_stats(0, part_width - 1);
879    BLOBNBOX_C_IT it(&boxes_);
880    BLOBNBOX *prev_blob = it.data();
881    prev_blob->set_flow(BTFT_NEIGHBOURS);
882    width_stats.add(prev_blob->bounding_box().width(), 1);
883    int blob_count = 1;
884    for (it.forward(); !it.at_first(); it.forward()) {
885      BLOBNBOX *blob = it.data();
886      int left = blob->bounding_box().left();
887      int right = blob->bounding_box().right();
888      gap_stats.add(left - prev_blob->bounding_box().right(), 1);
889      width_stats.add(right - left, 1);
890      blob->set_flow(BTFT_NEIGHBOURS);
891      prev_blob = blob;
892      ++blob_count;
893    }
894    double median_gap = gap_stats.median();
895    double median_width = width_stats.median();
896    double max_width = std::max(median_gap, median_width);
897    double min_width = std::min(median_gap, median_width);
898    double gap_iqr = gap_stats.ile(0.75f) - gap_stats.ile(0.25f);
899    if (textord_debug_tabfind >= 4) {
900      tprintf("gap iqr = %g, blob_count=%d, limits=%g,%g\n", gap_iqr, blob_count,
901              max_width * kMaxLeaderGapFractionOfMax,
902              min_width * kMaxLeaderGapFractionOfMin);
903    }
904    if (gap_iqr < max_width * kMaxLeaderGapFractionOfMax &&
905        gap_iqr < min_width * kMaxLeaderGapFractionOfMin &&
906        blob_count >= kMinLeaderCount) {
907      int offset = static_cast<int>(ceil(gap_iqr * 2));
908      int min_step = static_cast<int>(median_gap + median_width + 0.5);
909      int max_step = min_step + offset;
910      min_step -= offset;
911      int part_left = bounding_box_.left() - min_step / 2;
912      part_width += min_step;
913      auto *projection = new DPPoint[part_width];
914      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
915        BLOBNBOX *blob = it.data();
916        int left = blob->bounding_box().left();
<span onclick='openModal()' class='match'>917        int right = blob->bounding_box().right();
918        int height = blob->bounding_box().height();
919        for (int x = left; x < right; ++x) {
</span>920          projection[left - part_left].AddLocalCost(height);
921        }
922      }
923      DPPoint *best_end =
924          DPPoint::Solve(min_step, max_step, false, &DPPoint::CostWithVariance,
925                         part_width, projection);
926      if (best_end != nullptr && best_end->total_cost() < blob_count) {
927        result = true;
928        bool modified_blob_list = false;
929        for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
930          BLOBNBOX *blob = it.data();
931          if (it.at_first()) {
932            int gap = it.data_relative(1)->bounding_box().left() -
933                      blob->bounding_box().right();
934            if (blob->bounding_box().width() + gap > max_step) {
935              it.extract();
936              modified_blob_list = true;
937              continue;
938            }
939          }
940          if (it.at_last()) {
941            int gap = blob->bounding_box().left() -
942                      it.data_relative(-1)->bounding_box().right();
943            if (blob->bounding_box().width() + gap > max_step) {
944              it.extract();
945              modified_blob_list = true;
946              break;
947            }
948          }
949          blob->set_region_type(BRT_TEXT);
950          blob->set_flow(BTFT_LEADER);
951        }
952        if (modified_blob_list) {
953          ComputeLimits();
954        }
955        blob_type_ = BRT_TEXT;
956        flow_ = BTFT_LEADER;
957      } else if (textord_debug_tabfind) {
958        if (best_end == nullptr) {
959          tprintf("No path\n");
960        } else {
961          tprintf("Total cost = %d vs allowed %d\n", best_end->total_cost(),
962                  blob_count);
963        }
964      }
965      delete[] projection;
966    }
967    return result;
968  }
969  void ColPartition::SetRegionAndFlowTypesFromProjectionValue(int value) {
970    int blob_count = 0;       
971    int good_blob_score_ = 0; 
972    int noisy_count = 0;      
973    int hline_count = 0;
974    int vline_count = 0;
975    BLOBNBOX_C_IT it(&boxes_);
976    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
977      BLOBNBOX *blob = it.data();
978      ++blob_count;
979      noisy_count += blob->NoisyNeighbours();
980      good_blob_score_ += blob->GoodTextBlob();
981      if (blob->region_type() == BRT_HLINE) {
982        ++hline_count;
983      }
984      if (blob->region_type() == BRT_VLINE) {
985        ++vline_count;
986      }
987    }
988    flow_ = BTFT_NEIGHBOURS;
989    blob_type_ = BRT_UNKNOWN;
990    if (hline_count > vline_count) {
991      flow_ = BTFT_NONE;
992      blob_type_ = BRT_HLINE;
993    } else if (vline_count > hline_count) {
994      flow_ = BTFT_NONE;
995      blob_type_ = BRT_VLINE;
996    } else if (value < -1 || 1 < value) {
997      int long_side;
998      int short_side;
999      if (value > 0) {
1000        long_side = bounding_box_.width();
1001        short_side = bounding_box_.height();
1002        blob_type_ = BRT_TEXT;
1003      } else {
1004        long_side = bounding_box_.height();
1005        short_side = bounding_box_.width();
1006        blob_type_ = BRT_VERT_TEXT;
1007      }
1008      int strong_score = blob_count >= kHorzStrongTextlineCount ? 1 : 0;
1009      if (short_side > kHorzStrongTextlineHeight) {
1010        ++strong_score;
1011      }
1012      if (short_side * kHorzStrongTextlineAspect < long_side) {
1013        ++strong_score;
1014      }
1015      if (abs(value) >= kMinStrongTextValue) {
1016        flow_ = BTFT_STRONG_CHAIN;
1017      } else if (abs(value) >= kMinChainTextValue) {
1018        flow_ = BTFT_CHAIN;
1019      } else {
1020        flow_ = BTFT_NEIGHBOURS;
1021      }
1022      if (flow_ == BTFT_CHAIN && strong_score == 3) {
1023        flow_ = BTFT_STRONG_CHAIN;
1024      }
1025      if (flow_ == BTFT_STRONG_CHAIN && value < 0 && strong_score < 2) {
1026        flow_ = BTFT_CHAIN;
1027      }
1028    }
1029    if (flow_ == BTFT_NEIGHBOURS) {
1030      if (noisy_count >= blob_count) {
1031        flow_ = BTFT_NONTEXT;
1032        blob_type_ = BRT_NOISE;
1033      }
1034    }
1035    if (TabFind::WithinTestRegion(2, bounding_box_.left(),
1036                                  bounding_box_.bottom())) {
1037      tprintf("RegionFlowTypesFromProjectionValue count=%d, noisy=%d, score=%d,",
1038              blob_count, noisy_count, good_blob_score_);
1039      tprintf(" Projection value=%d, flow=%d, blob_type=%d\n", value, flow_,
1040              blob_type_);
1041      Print();
1042    }
1043    SetBlobTypes();
1044  }
1045  void ColPartition::SetBlobTypes() {
1046    if (!owns_blobs()) {
1047      return;
1048    }
1049    BLOBNBOX_C_IT it(&boxes_);
1050    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1051      BLOBNBOX *blob = it.data();
1052      if (blob->flow() != BTFT_LEADER) {
1053        blob->set_flow(flow_);
1054      }
1055      blob->set_region_type(blob_type_);
1056      ASSERT_HOST(blob->owner() == nullptr || blob->owner() == this);
1057    }
1058  }
1059  bool ColPartition::HasGoodBaseline() {
1060    DetLineFit linepoints;
1061    int total_height = 0;
1062    int coverage = 0;
1063    int height_count = 0;
1064    int width = 0;
1065    BLOBNBOX_C_IT it(&boxes_);
1066    TBOX box(it.data()->bounding_box());
1067    if (IsVerticalType()) {
1068      ICOORD first_pt(box.right(), box.bottom());
1069      linepoints.Add(first_pt);
1070      for (it.forward(); !it.at_last(); it.forward()) {
1071        BLOBNBOX *blob = it.data();
1072        box = blob->bounding_box();
1073        ICOORD box_pt(box.right(), (box.top() + box.bottom()) / 2);
1074        linepoints.Add(box_pt);
1075        total_height += box.width();
1076        coverage += box.height();
1077        ++height_count;
1078      }
1079      box = it.data()->bounding_box();
1080      ICOORD last_pt(box.right(), box.top());
1081      linepoints.Add(last_pt);
1082      width = last_pt.y() - first_pt.y();
1083    } else {
1084      TBOX box(it.data()->bounding_box());
1085      ICOORD first_pt(box.left(), box.bottom());
1086      linepoints.Add(first_pt);
1087      for (it.forward(); !it.at_last(); it.forward()) {
1088        BLOBNBOX *blob = it.data();
1089        box = blob->bounding_box();
1090        ICOORD box_pt((box.left() + box.right()) / 2, box.bottom());
1091        linepoints.Add(box_pt);
1092        total_height += box.height();
1093        coverage += box.width();
1094        ++height_count;
1095      }
1096      box = it.data()->bounding_box();
1097      ICOORD last_pt(box.right(), box.bottom());
1098      linepoints.Add(last_pt);
1099      width = last_pt.x() - first_pt.x();
1100    }
1101    if (height_count == 0) {
1102      return false;
1103    }
1104    double max_error = kMaxBaselineError * total_height / height_count;
1105    ICOORD start_pt, end_pt;
1106    double error = linepoints.Fit(&start_pt, &end_pt);
1107    return error < max_error && coverage >= kMinBaselineCoverage * width;
1108  }
1109  void ColPartition::AddToWorkingSet(const ICOORD &bleft, const ICOORD &tright,
1110                                     int resolution,
1111                                     ColPartition_LIST *used_parts,
1112                                     WorkingPartSet_LIST *working_sets) {
1113    if (block_owned_) {
1114      return; 
1115    }
1116    block_owned_ = true;
1117    WorkingPartSet_IT it(working_sets);
1118    ColPartition *partner = SingletonPartner(true);
1119    if (partner != nullptr && partner->working_set_ != nullptr) {
1120      working_set_ = partner->working_set_;
1121      working_set_->AddPartition(this);
1122      return;
1123    }
1124    if (partner != nullptr && textord_debug_bugs) {
1125      tprintf("Partition with partner has no working set!:");
1126      Print();
1127      partner->Print();
1128    }
1129    WorkingPartSet *work_set = nullptr;
1130    it.move_to_first();
1131    int col_index = 0;
1132    for (it.mark_cycle_pt(); !it.cycled_list() && col_index != first_column_;
1133         it.forward(), ++col_index) {
1134      ;
1135    }
1136    if (textord_debug_tabfind >= 2) {
1137      tprintf("Match is %s for:", (col_index & 1) ? "Real" : "Between");
1138      Print();
1139    }
1140    if (it.cycled_list() && textord_debug_bugs) {
1141      tprintf("Target column=%d, only had %d\n", first_column_, col_index);
1142    }
1143    ASSERT_HOST(!it.cycled_list());
1144    work_set = it.data();
1145    if (!it.cycled_list() && last_column_ != first_column_ && !IsPulloutType()) {
1146      BLOCK_LIST completed_blocks;
1147      TO_BLOCK_LIST to_blocks;
1148      for (; !it.cycled_list() && col_index <= last_column_;
1149           it.forward(), ++col_index) {
1150        WorkingPartSet *end_set = it.data();
1151        end_set->ExtractCompletedBlocks(bleft, tright, resolution, used_parts,
1152                                        &completed_blocks, &to_blocks);
1153      }
1154      work_set->InsertCompletedBlocks(&completed_blocks, &to_blocks);
1155    }
1156    working_set_ = work_set;
1157    work_set->AddPartition(this);
1158  }
1159  void ColPartition::LineSpacingBlocks(const ICOORD &bleft, const ICOORD &tright,
1160                                       int resolution,
1161                                       ColPartition_LIST *block_parts,
1162                                       ColPartition_LIST *used_parts,
1163                                       BLOCK_LIST *completed_blocks,
1164                                       TO_BLOCK_LIST *to_blocks) {
1165    int page_height = tright.y() - bleft.y();
1166    ColPartition_IT it(block_parts);
1167    int part_count = 0;
1168    int max_line_height = 0;
1169    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1170      ColPartition *part = it.data();
1171      ASSERT_HOST(!part->boxes()->empty());
1172      STATS side_steps(0, part->bounding_box().height() - 1);
1173      if (part->bounding_box().height() > max_line_height) {
1174        max_line_height = part->bounding_box().height();
1175      }
1176      BLOBNBOX_C_IT blob_it(part->boxes());
1177      int prev_bottom = blob_it.data()->bounding_box().bottom();
1178      for (blob_it.forward(); !blob_it.at_first(); blob_it.forward()) {
1179        BLOBNBOX *blob = blob_it.data();
1180        int bottom = blob->bounding_box().bottom();
1181        int step = bottom - prev_bottom;
1182        if (step < 0) {
1183          step = -step;
1184        }
1185        side_steps.add(step, 1);
1186        prev_bottom = bottom;
1187      }
1188      part->set_side_step(static_cast<int>(side_steps.median() + 0.5));
1189      if (!it.at_last()) {
1190        ColPartition *next_part = it.data_relative(1);
1191        part->set_bottom_spacing(part->median_bottom() -
1192                                 next_part->median_bottom());
1193        part->set_top_spacing(part->median_top() - next_part->median_top());
1194      } else {
1195        part->set_bottom_spacing(page_height);
1196        part->set_top_spacing(page_height);
1197      }
1198      if (textord_debug_tabfind) {
1199        part->Print();
1200        tprintf("side step = %.2f, top spacing = %d, bottom spacing=%d\n",
1201                side_steps.median(), part->top_spacing(), part->bottom_spacing());
1202      }
1203      ++part_count;
1204    }
1205    if (part_count == 0) {
1206      return;
1207    }
1208    SmoothSpacings(resolution, page_height, block_parts);
1209    BLOCK_IT block_it(completed_blocks);
1210    TO_BLOCK_IT to_block_it(to_blocks);
1211    ColPartition_LIST spacing_parts;
1212    ColPartition_IT sp_block_it(&spacing_parts);
1213    int same_block_threshold = max_line_height * kMaxSameBlockLineSpacing;
1214    for (it.mark_cycle_pt(); !it.empty();) {
1215      ColPartition *part = it.extract();
1216      sp_block_it.add_to_end(part);
1217      it.forward();
1218      if (it.empty() || part->bottom_spacing() > same_block_threshold ||
1219          !part->SpacingsEqual(*it.data(), resolution)) {
1220        if (!it.empty() && part->bottom_spacing() <= same_block_threshold) {
1221          ColPartition *next_part = it.data();
1222          ColPartition *third_part = it.at_last() ? nullptr : it.data_relative(1);
1223          if (textord_debug_tabfind) {
1224            tprintf(
1225                "Spacings unequal: upper:%d/%d, lower:%d/%d,"
1226                " sizes %d %d %d\n",
1227                part->top_spacing(), part->bottom_spacing(),
1228                next_part->top_spacing(), next_part->bottom_spacing(),
1229                part->median_height(), next_part->median_height(),
1230                third_part != nullptr ? third_part->median_height() : 0);
1231          }
1232          if (part->SizesSimilar(*next_part) &&
1233              next_part->median_height() * kMaxSameBlockLineSpacing >
1234                  part->bottom_spacing() &&
1235              part->median_height() * kMaxSameBlockLineSpacing >
1236                  part->top_spacing()) {
1237            if (third_part == nullptr || !next_part->SizesSimilar(*third_part) ||
1238                third_part->median_height() * kMaxSameBlockLineSpacing <=
1239                    next_part->bottom_spacing() ||
1240                next_part->median_height() * kMaxSameBlockLineSpacing <=
1241                    next_part->top_spacing() ||
1242                next_part->bottom_spacing() > part->bottom_spacing()) {
1243              sp_block_it.add_to_end(it.extract());
1244              it.forward();
1245              if (textord_debug_tabfind) {
1246                tprintf("Added line to current block.\n");
1247              }
1248            }
1249          }
1250        }
1251        TO_BLOCK *to_block = MakeBlock(bleft, tright, &spacing_parts, used_parts);
1252        if (to_block != nullptr) {
1253          to_block_it.add_to_end(to_block);
1254          block_it.add_to_end(to_block->block);
1255        }
1256        sp_block_it.set_to_list(&spacing_parts);
1257      } else {
1258        if (textord_debug_tabfind && !it.empty()) {
1259          ColPartition *next_part = it.data();
1260          tprintf("Spacings equal: upper:%d/%d, lower:%d/%d, median:%d/%d\n",
1261                  part->top_spacing(), part->bottom_spacing(),
1262                  next_part->top_spacing(), next_part->bottom_spacing(),
1263                  part->median_height(), next_part->median_height());
1264        }
1265      }
1266    }
1267  }
1268  static void ClipCoord(const ICOORD &bleft, const ICOORD &tright, ICOORD *pos) {
1269    if (pos->x() < bleft.x()) {
1270      pos->set_x(bleft.x());
1271    }
1272    if (pos->x() > tright.x()) {
1273      pos->set_x(tright.x());
1274    }
1275    if (pos->y() < bleft.y()) {
1276      pos->set_y(bleft.y());
1277    }
1278    if (pos->y() > tright.y()) {
1279      pos->set_y(tright.y());
1280    }
1281  }
1282  static TO_BLOCK *MoveBlobsToBlock(bool vertical_text, int line_spacing,
1283                                    BLOCK *block, ColPartition_LIST *block_parts,
1284                                    ColPartition_LIST *used_parts) {
1285    TBOX block_box(block->pdblk.bounding_box());
1286    STATS sizes(0, std::max(block_box.width(), block_box.height()) - 1);
1287    bool text_type = block->pdblk.poly_block()->IsText();
1288    ColPartition_IT it(block_parts);
1289    auto *to_block = new TO_BLOCK(block);
1290    BLOBNBOX_IT blob_it(&to_block->blobs);
1291    ColPartition_IT used_it(used_parts);
1292    for (it.move_to_first(); !it.empty(); it.forward()) {
1293      ColPartition *part = it.extract();
1294      for (BLOBNBOX_C_IT bb_it(part->boxes()); !bb_it.empty(); bb_it.forward()) {
1295        BLOBNBOX *bblob = bb_it.extract();
1296        if (bblob->owner() != part) {
1297          tprintf("Ownership incorrect for blob:");
1298          bblob->bounding_box().print();
1299          tprintf("Part=");
1300          part->Print();
1301          if (bblob->owner() == nullptr) {
1302            tprintf("Not owned\n");
1303          } else {
1304            tprintf("Owner part:");
1305            bblob->owner()->Print();
1306          }
1307        }
1308        ASSERT_HOST(bblob->owner() == part);
1309        ASSERT_HOST(!text_type || bblob->region_type() >= BRT_UNKNOWN);
1310        C_OUTLINE_LIST *outlines = bblob->cblob()->out_list();
1311        C_OUTLINE_IT ol_it(outlines);
1312        ASSERT_HOST(!text_type || ol_it.data()->pathlength() > 0);
1313        if (vertical_text) {
1314          sizes.add(bblob->bounding_box().width(), 1);
1315        } else {
1316          sizes.add(bblob->bounding_box().height(), 1);
1317        }
1318        blob_it.add_after_then_move(bblob);
1319      }
1320      used_it.add_to_end(part);
1321    }
1322    if (text_type && blob_it.empty()) {
1323      delete block;
1324      delete to_block;
1325      return nullptr;
1326    }
1327    to_block->line_size = sizes.median();
1328    if (vertical_text) {
1329      int block_width = block->pdblk.bounding_box().width();
1330      if (block_width < line_spacing) {
1331        line_spacing = block_width;
1332      }
1333      to_block->line_spacing = static_cast<float>(line_spacing);
1334      to_block->max_blob_size = static_cast<float>(block_width + 1);
1335    } else {
1336      int block_height = block->pdblk.bounding_box().height();
1337      if (block_height < line_spacing) {
1338        line_spacing = block_height;
1339      }
1340      to_block->line_spacing = static_cast<float>(line_spacing);
1341      to_block->max_blob_size = static_cast<float>(block_height + 1);
1342    }
1343    return to_block;
1344  }
1345  TO_BLOCK *ColPartition::MakeBlock(const ICOORD &bleft, const ICOORD &tright,
1346                                    ColPartition_LIST *block_parts,
1347                                    ColPartition_LIST *used_parts) {
1348    if (block_parts->empty()) {
1349      return nullptr; 
1350    }
1351    block_parts->sort(&ColPartition::SortByBBox);
1352    ColPartition_IT it(block_parts);
1353    ColPartition *part = it.data();
1354    PolyBlockType type = part->type();
1355    if (type == PT_VERTICAL_TEXT) {
1356      return MakeVerticalTextBlock(bleft, tright, block_parts, used_parts);
1357    }
1358    int line_spacing = part->bottom_spacing();
1359    if (line_spacing < part->median_height()) {
1360      line_spacing = part->bounding_box().height();
1361    }
1362    ICOORDELT_LIST vertices;
1363    ICOORDELT_IT vert_it(&vertices);
1364    ICOORD start, end;
1365    int min_x = INT32_MAX;
1366    int max_x = -INT32_MAX;
1367    int min_y = INT32_MAX;
1368    int max_y = -INT32_MAX;
1369    int iteration = 0;
1370    do {
1371      if (iteration == 0) {
1372        ColPartition::LeftEdgeRun(&it, &start, &end);
1373      } else {
1374        ColPartition::RightEdgeRun(&it, &start, &end);
1375      }
1376      ClipCoord(bleft, tright, &start);
1377      ClipCoord(bleft, tright, &end);
1378      vert_it.add_after_then_move(new ICOORDELT(start));
1379      vert_it.add_after_then_move(new ICOORDELT(end));
1380      UpdateRange(start.x(), &min_x, &max_x);
1381      UpdateRange(end.x(), &min_x, &max_x);
1382      UpdateRange(start.y(), &min_y, &max_y);
1383      UpdateRange(end.y(), &min_y, &max_y);
1384      if ((iteration == 0 && it.at_first()) || (iteration == 1 && it.at_last())) {
1385        ++iteration;
1386        it.move_to_last();
1387      }
1388    } while (iteration < 2);
1389    if (textord_debug_tabfind) {
1390      tprintf("Making block at (%d,%d)->(%d,%d)\n", min_x, min_y, max_x, max_y);
1391    }
1392    auto *block = new BLOCK("", true, 0, 0, min_x, min_y, max_x, max_y);
1393    block->pdblk.set_poly_block(new POLY_BLOCK(&vertices, type));
1394    return MoveBlobsToBlock(false, line_spacing, block, block_parts, used_parts);
1395  }
1396  TO_BLOCK *ColPartition::MakeVerticalTextBlock(const ICOORD &bleft,
1397                                                const ICOORD &tright,
1398                                                ColPartition_LIST *block_parts,
1399                                                ColPartition_LIST *used_parts) {
1400    if (block_parts->empty()) {
1401      return nullptr; 
1402    }
1403    ColPartition_IT it(block_parts);
1404    ColPartition *part = it.data();
1405    TBOX block_box = part->bounding_box();
1406    int line_spacing = block_box.width();
1407    PolyBlockType type = it.data()->type();
1408    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1409      block_box += it.data()->bounding_box();
1410    }
1411    if (textord_debug_tabfind) {
1412      tprintf("Making block at:");
1413      block_box.print();
1414    }
1415    auto *block = new BLOCK("", true, 0, 0, block_box.left(), block_box.bottom(),
1416                            block_box.right(), block_box.top());
1417    block->pdblk.set_poly_block(new POLY_BLOCK(block_box, type));
1418    return MoveBlobsToBlock(true, line_spacing, block, block_parts, used_parts);
1419  }
1420  TO_ROW *ColPartition::MakeToRow() {
1421    BLOBNBOX_C_IT blob_it(&boxes_);
1422    TO_ROW *row = nullptr;
1423    int line_size = IsVerticalType() ? median_width_ : median_height_;
1424    for (; !blob_it.empty(); blob_it.forward()) {
1425      BLOBNBOX *blob = blob_it.extract();
1426      int top = blob->bounding_box().top();
1427      int bottom = blob->bounding_box().bottom();
1428      if (row == nullptr) {
1429        row =
1430            new TO_ROW(blob, static_cast<float>(top), static_cast<float>(bottom),
1431                       static_cast<float>(line_size));
1432      } else {
1433        row->add_blob(blob, static_cast<float>(top), static_cast<float>(bottom),
1434                      static_cast<float>(line_size));
1435      }
1436    }
1437    return row;
1438  }
1439  ColPartition *ColPartition::ShallowCopy() const {
1440    auto *part = new ColPartition(blob_type_, vertical_);
1441    part->left_margin_ = left_margin_;
1442    part->right_margin_ = right_margin_;
1443    part->bounding_box_ = bounding_box_;
1444    memcpy(part->special_blobs_densities_, special_blobs_densities_,
1445           sizeof(special_blobs_densities_));
1446    part->median_bottom_ = median_bottom_;
1447    part->median_top_ = median_top_;
1448    part->median_height_ = median_height_;
1449    part->median_left_ = median_left_;
1450    part->median_right_ = median_right_;
1451    part->median_width_ = median_width_;
1452    part->good_width_ = good_width_;
1453    part->good_column_ = good_column_;
1454    part->left_key_tab_ = left_key_tab_;
1455    part->right_key_tab_ = right_key_tab_;
1456    part->type_ = type_;
1457    part->flow_ = flow_;
1458    part->left_key_ = left_key_;
1459    part->right_key_ = right_key_;
1460    part->first_column_ = first_column_;
1461    part->last_column_ = last_column_;
1462    part->owns_blobs_ = false;
1463    return part;
1464  }
1465  ColPartition *ColPartition::CopyButDontOwnBlobs() {
1466    ColPartition *copy = ShallowCopy();
1467    copy->set_owns_blobs(false);
1468    BLOBNBOX_C_IT inserter(copy->boxes());
1469    BLOBNBOX_C_IT traverser(boxes());
1470    for (traverser.mark_cycle_pt(); !traverser.cycled_list();
1471         traverser.forward()) {
1472      inserter.add_after_then_move(traverser.data());
1473    }
1474    return copy;
1475  }
1476  #ifndef GRAPHICS_DISABLED
1477  ScrollView::Color ColPartition::BoxColor() const {
1478    if (type_ == PT_UNKNOWN) {
1479      return BLOBNBOX::TextlineColor(blob_type_, flow_);
1480    }
1481    return POLY_BLOCK::ColorForPolyBlockType(type_);
1482  }
1483  #endif 
1484  static char kBlobTypes[BRT_COUNT + 1] = "NHSRIUVT";
1485  void ColPartition::Print() const {
1486    int y = MidY();
1487    tprintf(
1488        "ColPart:%c(M%d-%c%d-B%d/%d,%d/%d)->(%dB-%d%c-%dM/%d,%d/%d)"
1489        " w-ok=%d, v-ok=%d, type=%d%c%d, fc=%d, lc=%d, boxes=%d"
1490        " ts=%d bs=%d ls=%d rs=%d\n",
1491        boxes_.empty() ? 'E' : ' ', left_margin_, left_key_tab_ ? 'T' : 'B',
1492        LeftAtY(y), bounding_box_.left(), median_left_, bounding_box_.bottom(),
1493        median_bottom_, bounding_box_.right(), RightAtY(y),
1494        right_key_tab_ ? 'T' : 'B', right_margin_, median_right_,
1495        bounding_box_.top(), median_top_, good_width_, good_column_, type_,
1496        kBlobTypes[blob_type_], flow_, first_column_, last_column_,
1497        boxes_.length(), space_above_, space_below_, space_to_left_,
1498        space_to_right_);
1499  }
1500  void ColPartition::PrintColors() {
1501    tprintf("Colors:(%d, %d, %d)%d -> (%d, %d, %d)\n", color1_[COLOR_RED],
1502            color1_[COLOR_GREEN], color1_[COLOR_BLUE], color1_[L_ALPHA_CHANNEL],
1503            color2_[COLOR_RED], color2_[COLOR_GREEN], color2_[COLOR_BLUE]);
1504  }
1505  void ColPartition::SmoothPartnerRun(int working_set_count) {
1506    STATS left_stats(0, working_set_count - 1);
1507    STATS right_stats(0, working_set_count - 1);
1508    PolyBlockType max_type = type_;
1509    ColPartition *partner;
1510    for (partner = SingletonPartner(false); partner != nullptr;
1511         partner = partner->SingletonPartner(false)) {
1512      if (partner->type_ > max_type) {
1513        max_type = partner->type_;
1514      }
1515      if (column_set_ == partner->column_set_) {
1516        left_stats.add(partner->first_column_, 1);
1517        right_stats.add(partner->last_column_, 1);
1518      }
1519    }
1520    type_ = max_type;
1521  #if 0
1522    first_column_ = left_stats.mode();
1523    last_column_ = right_stats.mode();
1524    if (last_column_ < first_column_)
1525      last_column_ = first_column_;
1526  #endif
1527    for (partner = SingletonPartner(false); partner != nullptr;
1528         partner = partner->SingletonPartner(false)) {
1529      partner->type_ = max_type;
1530  #if 0 
1531      if (column_set_ == partner->column_set_) {
1532        partner->first_column_ = first_column_;
1533        partner->last_column_ = last_column_;
1534      }
1535  #endif
1536    }
1537  }
1538  void ColPartition::RefinePartners(PolyBlockType type, bool get_desperate,
1539                                    ColPartitionGrid *grid) {
1540    if (TypesSimilar(type_, type)) {
1541      RefinePartnersInternal(true, get_desperate, grid);
1542      RefinePartnersInternal(false, get_desperate, grid);
1543    } else if (type == PT_COUNT) {
1544      RefinePartnersByType(true, &upper_partners_);
1545      RefinePartnersByType(false, &lower_partners_);
1546      if (!upper_partners_.empty() && !upper_partners_.singleton()) {
1547        RefinePartnersByOverlap(true, &upper_partners_);
1548      }
1549      if (!lower_partners_.empty() && !lower_partners_.singleton()) {
1550        RefinePartnersByOverlap(false, &lower_partners_);
1551      }
1552    }
1553  }
1554  void ColPartition::RefinePartnersInternal(bool upper, bool get_desperate,
1555                                            ColPartitionGrid *grid) {
1556    ColPartition_CLIST *partners = upper ? &upper_partners_ : &lower_partners_;
1557    if (!partners->empty() && !partners->singleton()) {
1558      RefinePartnersByType(upper, partners);
1559      if (!partners->empty() && !partners->singleton()) {
1560        RefinePartnerShortcuts(upper, partners);
1561        if (!partners->empty() && !partners->singleton()) {
1562          if (TypesSimilar(type_, PT_FLOWING_TEXT) && get_desperate) {
1563            RefineTextPartnersByMerge(upper, false, partners, grid);
1564            if (!partners->empty() && !partners->singleton()) {
1565              RefineTextPartnersByMerge(upper, true, partners, grid);
1566            }
1567          }
1568          if (!partners->empty() && !partners->singleton()) {
1569            RefinePartnersByOverlap(upper, partners);
1570          }
1571        }
1572      }
1573    }
1574  }
1575  void ColPartition::RefinePartnersByType(bool upper,
1576                                          ColPartition_CLIST *partners) {
1577    bool debug = TabFind::WithinTestRegion(2, bounding_box_.left(),
1578                                           bounding_box_.bottom());
1579    if (debug) {
1580      tprintf("Refining %d %s partners by type for:\n", partners->length(),
1581              upper ? "Upper" : "Lower");
1582      Print();
1583    }
1584    ColPartition_C_IT it(partners);
1585    if (!IsImageType() && !IsLineType() && type() != PT_TABLE) {
1586      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1587        ColPartition *partner = it.data();
1588        if (!TypesSimilar(type_, partner->type_)) {
1589          if (debug) {
1590            tprintf("Removing partner:");
1591            partner->Print();
1592          }
1593          partner->RemovePartner(!upper, this);
1594          it.extract();
1595        } else if (debug) {
1596          tprintf("Keeping partner:");
1597          partner->Print();
1598        }
1599      }
1600    } else {
1601      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1602        ColPartition *partner = it.data();
1603        if (partner->blob_type() != BRT_POLYIMAGE ||
1604            blob_type() != BRT_POLYIMAGE) {
1605          if (debug) {
1606            tprintf("Removing partner:");
1607            partner->Print();
1608          }
1609          partner->RemovePartner(!upper, this);
1610          it.extract();
1611        } else if (debug) {
1612          tprintf("Keeping partner:");
1613          partner->Print();
1614        }
1615      }
1616    }
1617  }
1618  void ColPartition::RefinePartnerShortcuts(bool upper,
1619                                            ColPartition_CLIST *partners) {
1620    bool done_any = false;
1621    do {
1622      done_any = false;
1623      ColPartition_C_IT it(partners);
1624      for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1625        ColPartition *a = it.data();
1626        ColPartition_C_IT it1(upper ? &a->upper_partners_ : &a->lower_partners_);
1627        for (it1.mark_cycle_pt(); !it1.cycled_list(); it1.forward()) {
1628          ColPartition *b1 = it1.data();
1629          if (b1 == this) {
1630            done_any = true;
1631            it.extract();
1632            a->RemovePartner(!upper, this);
1633            break;
1634          }
1635          ColPartition_C_IT it2(partners);
1636          for (it2.mark_cycle_pt(); !it2.cycled_list(); it2.forward()) {
1637            ColPartition *b2 = it2.data();
1638            if (b1 == b2) {
1639              it2.extract();
1640              b2->RemovePartner(!upper, this);
1641              done_any = true;
1642              break;
1643            }
1644          }
1645          if (done_any) {
1646            break;
1647          }
1648        }
1649        if (done_any) {
1650          break;
1651        }
1652      }
1653    } while (done_any && !partners->empty() && !partners->singleton());
1654  }
1655  void ColPartition::RefineTextPartnersByMerge(bool upper, bool desperate,
1656                                               ColPartition_CLIST *partners,
1657                                               ColPartitionGrid *grid) {
1658    bool debug = TabFind::WithinTestRegion(2, bounding_box_.left(),
1659                                           bounding_box_.bottom());
1660    if (debug) {
1661      tprintf("Refining %d %s partners by merge for:\n", partners->length(),
1662              upper ? "Upper" : "Lower");
1663      Print();
1664    }
1665    while (!partners->empty() && !partners->singleton()) {
1666      ColPartition_C_IT it(partners);
1667      ColPartition *part = it.data();
1668      ColPartition_CLIST candidates;
1669      ColPartition_C_IT cand_it(&candidates);
1670      for (it.forward(); !it.at_first(); it.forward()) {
1671        ColPartition *candidate = it.data();
1672        if (part->first_column_ == candidate->last_column_ &&
1673            part->last_column_ == candidate->first_column_) {
1674          cand_it.add_after_then_move(it.data());
1675        }
1676      }
1677      int overlap_increase;
1678      ColPartition *candidate = grid->BestMergeCandidate(
1679          part, &candidates, debug, nullptr, &overlap_increase);
1680      if (candidate != nullptr && (overlap_increase <= 0 || desperate)) {
1681        if (debug) {
1682          tprintf("Merging:hoverlap=%d, voverlap=%d, OLI=%d\n",
1683                  part->HCoreOverlap(*candidate), part->VCoreOverlap(*candidate),
1684                  overlap_increase);
1685        }
1686        grid->RemoveBBox(candidate);
1687        grid->RemoveBBox(part);
1688        part->Absorb(candidate, nullptr);
1689        grid->InsertBBox(true, true, part);
1690        if (overlap_increase > 0) {
1691          part->desperately_merged_ = true;
1692        }
1693      } else {
1694        break; 
1695      }
1696    }
1697  }
1698  void ColPartition::RefinePartnersByOverlap(bool upper,
1699                                             ColPartition_CLIST *partners) {
1700    bool debug = TabFind::WithinTestRegion(2, bounding_box_.left(),
1701                                           bounding_box_.bottom());
1702    if (debug) {
1703      tprintf("Refining %d %s partners by overlap for:\n", partners->length(),
1704              upper ? "Upper" : "Lower");
1705      Print();
1706    }
1707    ColPartition_C_IT it(partners);
1708    ColPartition *best_partner = it.data();
1709    int best_overlap = 0;
1710    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1711      ColPartition *partner = it.data();
1712      int overlap =
1713          std::min(bounding_box_.right(), partner->bounding_box_.right()) -
1714          std::max(bounding_box_.left(), partner->bounding_box_.left());
1715      if (overlap > best_overlap) {
1716        best_overlap = overlap;
1717        best_partner = partner;
1718      }
1719    }
1720    for (it.mark_cycle_pt(); !it.cycled_list(); it.forward()) {
1721      ColPartition *partner = it.data();
1722      if (partner != best_partner) {
1723        if (debug) {
1724          tprintf("Removing partner:");
1725          partner->Print();
1726        }
1727        partner->RemovePartner(!upper, this);
1728        it.extract();
1729      }
1730    }
1731  }
1732  bool ColPartition::ThisPartitionBetter(BLOBNBOX *bbox,
1733                                         const ColPartition &other) {
1734    const TBOX &box = bbox->bounding_box();
1735    int left = box.left();
1736    int right = box.right();
1737    if (left < left_margin_ || right > right_margin_) {
1738      return false;
1739    }
1740    if (left < other.left_margin_ || right > other.right_margin_) {
1741      return true;
1742    }
1743    int top = box.top();
1744    int bottom = box.bottom();
1745    int this_overlap =
1746        std::min(top, median_top_) - std::max(bottom, median_bottom_);
1747    int other_overlap =
1748        std::min(top, other.median_top_) - std::max(bottom, other.median_bottom_);
1749    int this_miss = median_top_ - median_bottom_ - this_overlap;
1750    int other_miss = other.median_top_ - other.median_bottom_ - other_overlap;
1751    if (TabFind::WithinTestRegion(3, box.left(), box.bottom())) {
1752      tprintf("Unique on (%d,%d)->(%d,%d) overlap %d/%d, miss %d/%d, mt=%d/%d\n",
1753              box.left(), box.bottom(), box.right(), box.top(), this_overlap,
1754              other_overlap, this_miss, other_miss, median_top_,
1755              other.median_top_);
1756    }
1757    if (this_miss < other_miss) {
1758      return true;
1759    }
1760    if (this_miss > other_miss) {
1761      return false;
1762    }
1763    if (this_overlap > other_overlap) {
1764      return true;
1765    }
1766    if (this_overlap < other_overlap) {
1767      return false;
1768    }
1769    return median_top_ >= other.median_top_;
1770  }
1771  static int MedianSpacing(int page_height, ColPartition_IT it) {
1772    STATS stats(0, page_height - 1);
1773    while (!it.cycled_list()) {
1774      ColPartition *part = it.data();
1775      it.forward();
1776      stats.add(part->bottom_spacing(), 1);
1777      stats.add(part->top_spacing(), 1);
1778    }
1779    return static_cast<int>(stats.median() + 0.5);
1780  }
1781  bool ColPartition::IsInSameColumnAs(const ColPartition &part) const {
1782    return (last_column_ >= part.first_column_) &&
1783           (first_column_ <= part.last_column_);
1784  }
1785  void ColPartition::SmoothSpacings(int resolution, int page_height,
1786                                    ColPartition_LIST *parts) {
1787    ColPartition *neighbourhood[PN_COUNT];
1788    ColPartition_IT it(parts);
1789    it.mark_cycle_pt();
1790    int median_space = MedianSpacing(page_height, it);
1791    ColPartition_IT start_it(it);
1792    ColPartition_IT end_it(it);
1793    for (int i = 0; i < PN_COUNT; ++i) {
1794      if (i < PN_UPPER || it.cycled_list()) {
1795        neighbourhood[i] = nullptr;
1796      } else {
1797        if (i == PN_LOWER) {
1798          end_it = it;
1799        }
1800        neighbourhood[i] = it.data();
1801        it.forward();
1802      }
1803    }
1804    while (neighbourhood[PN_UPPER] != nullptr) {
1805      if (neighbourhood[PN_LOWER] == nullptr ||
1806          (!neighbourhood[PN_UPPER]->SpacingsEqual(*neighbourhood[PN_LOWER],
1807                                                   resolution) &&
1808           (neighbourhood[PN_UPPER] == nullptr ||
1809            neighbourhood[PN_LOWER] == nullptr ||
1810            !OKSpacingBlip(resolution, median_space, neighbourhood, 0)) &&
1811           (neighbourhood[PN_UPPER - 1] == nullptr ||
1812            neighbourhood[PN_LOWER - 1] == nullptr ||
1813            !OKSpacingBlip(resolution, median_space, neighbourhood, -1) ||
1814            !neighbourhood[PN_LOWER]->SpacingEqual(median_space, resolution)) &&
1815           (neighbourhood[PN_UPPER + 1] == nullptr ||
1816            neighbourhood[PN_LOWER + 1] == nullptr ||
1817            !OKSpacingBlip(resolution, median_space, neighbourhood, 1) ||
1818            !neighbourhood[PN_UPPER]->SpacingEqual(median_space, resolution)))) {
1819        ColPartition_IT sum_it(start_it);
1820        ColPartition *last_part = neighbourhood[PN_UPPER];
1821        double total_bottom = 0.0;
1822        double total_top = 0.0;
1823        int total_count = 0;
1824        ColPartition *upper = sum_it.data();
1825        while (upper != last_part) {
1826          total_bottom += upper->bottom_spacing();
1827          total_top += upper->top_spacing();
1828          ++total_count;
1829          sum_it.forward();
1830          upper = sum_it.data();
1831        }
1832        if (total_count > 0) {
1833          int top_spacing = static_cast<int>(total_top / total_count + 0.5);
1834          int bottom_spacing = static_cast<int>(total_bottom / total_count + 0.5);
1835          if (textord_debug_tabfind) {
1836            tprintf("Spacing run ended. Cause:");
1837            if (neighbourhood[PN_LOWER] == nullptr) {
1838              tprintf("No more lines\n");
1839            } else {
1840              tprintf("Spacing change. Spacings:\n");
1841              for (int i = 0; i < PN_COUNT; ++i) {
1842                if (neighbourhood[i] == nullptr) {
1843                  tprintf("NULL");
1844                  if (i > 0 && neighbourhood[i - 1] != nullptr) {
1845                    if (neighbourhood[i - 1]->SingletonPartner(false) !=
1846                        nullptr) {
1847                      tprintf(" Lower partner:");
1848                      neighbourhood[i - 1]->SingletonPartner(false)->Print();
1849                    } else {
1850                      tprintf(" nullptr lower partner:\n");
1851                    }
1852                  } else {
1853                    tprintf("\n");
1854                  }
1855                } else {
1856                  tprintf("Top = %d, bottom = %d\n",
1857                          neighbourhood[i]->top_spacing(),
1858                          neighbourhood[i]->bottom_spacing());
1859                }
1860              }
1861            }
1862            tprintf("Mean spacing = %d/%d\n", top_spacing, bottom_spacing);
1863          }
1864          sum_it = start_it;
1865          upper = sum_it.data();
1866          while (upper != last_part) {
1867            upper->set_top_spacing(top_spacing);
1868            upper->set_bottom_spacing(bottom_spacing);
1869            if (textord_debug_tabfind) {
1870              tprintf("Setting mean on:");
1871              upper->Print();
1872            }
1873            sum_it.forward();
1874            upper = sum_it.data();
1875          }
1876        }
1877        start_it = end_it;
1878        median_space = MedianSpacing(page_height, end_it);
1879      }
1880      for (int j = 1; j < PN_COUNT; ++j) {
1881        neighbourhood[j - 1] = neighbourhood[j];
1882      }
1883      if (it.cycled_list()) {
1884        neighbourhood[PN_COUNT - 1] = nullptr;
1885      } else {
1886        neighbourhood[PN_COUNT - 1] = it.data();
1887        it.forward();
1888      }
1889      end_it.forward();
1890    }
1891  }
1892  bool ColPartition::OKSpacingBlip(int resolution, int median_spacing,
1893                                   ColPartition **parts, int offset) {
1894    parts += offset;
1895    return parts[PN_UPPER]->SummedSpacingOK(*parts[PN_LOWER], median_spacing,
1896                                            resolution) &&
1897           ((parts[PN_ABOVE1] != nullptr &&
1898             parts[PN_ABOVE1]->SpacingEqual(median_spacing, resolution)) ||
1899            (parts[PN_BELOW1] != nullptr &&
1900             parts[PN_BELOW1]->SpacingEqual(median_spacing, resolution)));
1901  }
1902  bool ColPartition::SpacingEqual(int spacing, int resolution) const {
1903    int bottom_error = BottomSpacingMargin(resolution);
1904    int top_error = TopSpacingMargin(resolution);
1905    return NearlyEqual(bottom_spacing_, spacing, bottom_error) &&
1906           NearlyEqual(top_spacing_, spacing, top_error);
1907  }
1908  bool ColPartition::SpacingsEqual(const ColPartition &other,
1909                                   int resolution) const {
1910    int bottom_error = std::max(BottomSpacingMargin(resolution),
1911                                other.BottomSpacingMargin(resolution));
1912    int top_error = std::max(TopSpacingMargin(resolution),
1913                             other.TopSpacingMargin(resolution));
1914    return NearlyEqual(bottom_spacing_, other.bottom_spacing_, bottom_error) &&
1915           (NearlyEqual(top_spacing_, other.top_spacing_, top_error) ||
1916            NearlyEqual(top_spacing_ + other.top_spacing_, bottom_spacing_ * 2,
1917                        bottom_error));
1918  }
1919  bool ColPartition::SummedSpacingOK(const ColPartition &other, int spacing,
1920                                     int resolution) const {
1921    int bottom_error = std::max(BottomSpacingMargin(resolution),
1922                                other.BottomSpacingMargin(resolution));
1923    int top_error = std::max(TopSpacingMargin(resolution),
1924                             other.TopSpacingMargin(resolution));
1925    int bottom_total = bottom_spacing_ + other.bottom_spacing_;
1926    int top_total = top_spacing_ + other.top_spacing_;
1927    return (NearlyEqual(spacing, bottom_total, bottom_error) &&
1928            NearlyEqual(spacing, top_total, top_error)) ||
1929           (NearlyEqual(spacing * 2, bottom_total, bottom_error) &&
1930            NearlyEqual(spacing * 2, top_total, top_error));
1931  }
1932  int ColPartition::BottomSpacingMargin(int resolution) const {
1933    return static_cast<int>(kMaxSpacingDrift * resolution + 0.5) + side_step_;
1934  }
1935  int ColPartition::TopSpacingMargin(int resolution) const {
1936    return static_cast<int>(kMaxTopSpacingFraction * median_height_ + 0.5) +
1937           BottomSpacingMargin(resolution);
1938  }
1939  bool ColPartition::SizesSimilar(const ColPartition &other) const {
1940    return median_height_ <= other.median_height_ * kMaxSizeRatio &&
1941           other.median_height_ <= median_height_ * kMaxSizeRatio;
1942  }
1943  static bool UpdateLeftMargin(const ColPartition &part, int *margin_left,
1944                               int *margin_right) {
1945    const TBOX &part_box = part.bounding_box();
1946    int top = part_box.top();
1947    int bottom = part_box.bottom();
1948    int tl_key = part.SortKey(part.left_margin(), top);
1949    int tr_key = part.SortKey(part_box.left(), top);
1950    int bl_key = part.SortKey(part.left_margin(), bottom);
1951    int br_key = part.SortKey(part_box.left(), bottom);
1952    int left_key = std::max(tl_key, bl_key);
1953    int right_key = std::min(tr_key, br_key);
1954    if (left_key <= *margin_right && right_key >= *margin_left) {
1955      *margin_right = std::min(*margin_right, right_key);
1956      *margin_left = std::max(*margin_left, left_key);
1957      return true;
1958    }
1959    return false;
1960  }
1961  void ColPartition::LeftEdgeRun(ColPartition_IT *part_it, ICOORD *start,
1962                                 ICOORD *end) {
1963    ColPartition *part = part_it->data();
1964    ColPartition *start_part = part;
1965    int start_y = part->bounding_box_.top();
1966    if (!part_it->at_first()) {
1967      int prev_bottom = part_it->data_relative(-1)->bounding_box_.bottom();
1968      if (prev_bottom < start_y) {
1969        start_y = prev_bottom;
1970      } else if (prev_bottom > start_y) {
1971        start_y = (start_y + prev_bottom) / 2;
1972      }
1973    }
1974    int end_y = part->bounding_box_.bottom();
1975    int margin_right = INT32_MAX;
1976    int margin_left = -INT32_MAX;
1977    UpdateLeftMargin(*part, &margin_left, &margin_right);
1978    do {
1979      part_it->forward();
1980      part = part_it->data();
1981    } while (!part_it->at_first() &&
1982             UpdateLeftMargin(*part, &margin_left, &margin_right));
1983    int next_margin_right = INT32_MAX;
1984    int next_margin_left = -INT32_MAX;
1985    UpdateLeftMargin(*part, &next_margin_left, &next_margin_right);
1986    if (next_margin_left > margin_right) {
1987      ColPartition_IT next_it(*part_it);
1988      do {
1989        next_it.forward();
1990        part = next_it.data();
1991      } while (!next_it.at_first() &&
1992               UpdateLeftMargin(*part, &next_margin_left, &next_margin_right));
1993      do {
1994        part_it->backward();
1995        part = part_it->data();
1996      } while (part != start_part &&
1997               UpdateLeftMargin(*part, &next_margin_left, &next_margin_right));
1998      part_it->forward();
1999    }
2000    part = part_it->data_relative(-1);
2001    end_y = part->bounding_box_.bottom();
2002    if (!part_it->at_first() && part_it->data()->bounding_box_.top() < end_y) {
2003      end_y = (end_y + part_it->data()->bounding_box_.top()) / 2;
2004    }
2005    start->set_y(start_y);
2006    start->set_x(part->XAtY(margin_right, start_y));
2007    end->set_y(end_y);
2008    end->set_x(part->XAtY(margin_right, end_y));
2009    if (textord_debug_tabfind && !part_it->at_first()) {
2010      tprintf("Left run from y=%d to %d terminated with sum %d-%d, new %d-%d\n",
2011              start_y, end_y, part->XAtY(margin_left, end_y), end->x(),
2012              part->left_margin_, part->bounding_box_.left());
2013    }
2014  }
2015  static bool UpdateRightMargin(const ColPartition &part, int *margin_left,
2016                                int *margin_right) {
2017    const TBOX &part_box = part.bounding_box();
2018    int top = part_box.top();
2019    int bottom = part_box.bottom();
2020    int tl_key = part.SortKey(part_box.right(), top);
2021    int tr_key = part.SortKey(part.right_margin(), top);
2022    int bl_key = part.SortKey(part_box.right(), bottom);
2023    int br_key = part.SortKey(part.right_margin(), bottom);
2024    int left_key = std::max(tl_key, bl_key);
2025    int right_key = std::min(tr_key, br_key);
2026    if (left_key <= *margin_right && right_key >= *margin_left) {
2027      *margin_right = std::min(*margin_right, right_key);
2028      *margin_left = std::max(*margin_left, left_key);
2029      return true;
2030    }
2031    return false;
2032  }
2033  void ColPartition::RightEdgeRun(ColPartition_IT *part_it, ICOORD *start,
2034                                  ICOORD *end) {
2035    ColPartition *part = part_it->data();
2036    ColPartition *start_part = part;
2037    int start_y = part->bounding_box_.bottom();
2038    if (!part_it->at_last()) {
2039      int next_y = part_it->data_relative(1)->bounding_box_.top();
2040      if (next_y > start_y) {
2041        start_y = next_y;
2042      } else if (next_y < start_y) {
2043        start_y = (start_y + next_y) / 2;
2044      }
2045    }
2046    int end_y = part->bounding_box_.top();
2047    int margin_right = INT32_MAX;
2048    int margin_left = -INT32_MAX;
2049    UpdateRightMargin(*part, &margin_left, &margin_right);
2050    do {
2051      part_it->backward();
2052      part = part_it->data();
2053    } while (!part_it->at_last() &&
2054             UpdateRightMargin(*part, &margin_left, &margin_right));
2055    int next_margin_right = INT32_MAX;
2056    int next_margin_left = -INT32_MAX;
2057    UpdateRightMargin(*part, &next_margin_left, &next_margin_right);
2058    if (next_margin_right < margin_left) {
2059      ColPartition_IT next_it(*part_it);
2060      do {
2061        next_it.backward();
2062        part = next_it.data();
2063      } while (!next_it.at_last() &&
2064               UpdateRightMargin(*part, &next_margin_left, &next_margin_right));
2065      do {
2066        part_it->forward();
2067        part = part_it->data();
2068      } while (part != start_part &&
2069               UpdateRightMargin(*part, &next_margin_left, &next_margin_right));
2070      part_it->backward();
2071    }
2072    part = part_it->data_relative(1);
2073    end_y = part->bounding_box().top();
2074    if (!part_it->at_last() && part_it->data()->bounding_box_.bottom() > end_y) {
2075      end_y = (end_y + part_it->data()->bounding_box_.bottom()) / 2;
2076    }
2077    start->set_y(start_y);
2078    start->set_x(part->XAtY(margin_left, start_y));
2079    end->set_y(end_y);
2080    end->set_x(part->XAtY(margin_left, end_y));
2081    if (textord_debug_tabfind && !part_it->at_last()) {
2082      tprintf("Right run from y=%d to %d terminated with sum %d-%d, new %d-%d\n",
2083              start_y, end_y, end->x(), part->XAtY(margin_right, end_y),
2084              part->bounding_box_.right(), part->right_margin_);
2085    }
2086  }
2087  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-agmattr.h</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from tesseract-MDEwOlJlcG9zaXRvcnkyMjg4NzA5NA==-flat-colpartition.cpp</div>
                <div class="column column_space"><pre><code>442      double StepSize = 1.0;
443      double InitLikelihood = LikelihoodForWK(K);
444      TFltV NewVarV(DeltaV.Len());
445      IAssert(DeltaV.Len() == NumComs + 1);
446      for(int iter = 0; iter < MaxIter; iter++) {
</pre></code></div>
                <div class="column column_space"><pre><code>917        int right = blob->bounding_box().right();
918        int height = blob->bounding_box().height();
919        for (int x = left; x < right; ++x) {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    