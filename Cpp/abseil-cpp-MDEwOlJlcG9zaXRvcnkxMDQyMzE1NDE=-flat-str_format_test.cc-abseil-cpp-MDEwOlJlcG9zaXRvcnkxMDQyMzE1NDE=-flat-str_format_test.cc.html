
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 22, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-str_format_test.cc</h3>
            <pre><code>1  #include "absl/strings/str_format.h"
2  #include <cstdarg>
3  #include <cstdint>
4  #include <cstdio>
5  #include <string>
6  #include "gmock/gmock.h"
7  #include "gtest/gtest.h"
8  #include "absl/strings/cord.h"
9  #include "absl/strings/str_cat.h"
10  #include "absl/strings/string_view.h"
11  namespace absl {
12  ABSL_NAMESPACE_BEGIN
13  namespace {
14  using str_format_internal::FormatArgImpl;
15  using FormatEntryPointTest = ::testing::Test;
16  TEST_F(FormatEntryPointTest, Format) {
17    std::string sink;
18    EXPECT_TRUE(Format(&sink, "A format %d", 123));
19    EXPECT_EQ("A format 123", sink);
20    sink.clear();
21    ParsedFormat<'d'> pc("A format %d");
22    EXPECT_TRUE(Format(&sink, pc, 123));
23    EXPECT_EQ("A format 123", sink);
24  }
25  TEST_F(FormatEntryPointTest, FormatWithV) {
26    std::string sink;
27    EXPECT_TRUE(Format(&sink, "A format %v", 123));
28    EXPECT_EQ("A format 123", sink);
29    sink.clear();
30    ParsedFormat<'v'> pc("A format %v");
31    EXPECT_TRUE(Format(&sink, pc, 123));
32    EXPECT_EQ("A format 123", sink);
33  }
34  TEST_F(FormatEntryPointTest, UntypedFormat) {
35    constexpr const char* formats[] = {
36      "",
37      "a",
38      "%80d",
39  #if !defined(_MSC_VER) && !defined(__ANDROID__) && !defined(__native_client__)
40      "complicated multipart %% %1$d format %1$0999d",
41  #endif  
42    };
43    for (const char* fmt : formats) {
44      std::string actual;
45      int i = 123;
46      FormatArgImpl arg_123(i);
47      absl::Span<const FormatArgImpl> args(&arg_123, 1);
48      UntypedFormatSpec format(fmt);
49      EXPECT_TRUE(FormatUntyped(&actual, format, args));
50      char buf[4096]{};
51      snprintf(buf, sizeof(buf), fmt, 123);
52      EXPECT_EQ(
53          str_format_internal::FormatPack(
54              str_format_internal::UntypedFormatSpecImpl::Extract(format), args),
55          buf);
56      EXPECT_EQ(actual, buf);
57    }
58    ParsedFormat<'d'> pc("A format %d");
59    int i = 345;
60    FormatArg arg(i);
61    std::string out;
62    EXPECT_TRUE(str_format_internal::FormatUntyped(
63        &out, str_format_internal::UntypedFormatSpecImpl(&pc), {&arg, 1}));
64    EXPECT_EQ("A format 345", out);
65  }
66  TEST_F(FormatEntryPointTest, StringFormat) {
67    EXPECT_EQ("123", StrFormat("%d", 123));
68    constexpr absl::string_view view("=%d=", 4);
69    EXPECT_EQ("=123=", StrFormat(view, 123));
70  }
71  TEST_F(FormatEntryPointTest, StringFormatV) {
72    std::string hello = "hello";
73    EXPECT_EQ("hello", StrFormat("%v", hello));
74    EXPECT_EQ("123", StrFormat("%v", 123));
75    constexpr absl::string_view view("=%v=", 4);
76    EXPECT_EQ("=123=", StrFormat(view, 123));
77  }
78  TEST_F(FormatEntryPointTest, AppendFormat) {
79    std::string s;
80    std::string& r = StrAppendFormat(&s, "%d", 123);
81    EXPECT_EQ(&s, &r);  
82    EXPECT_EQ("123", r);
83  }
84  TEST_F(FormatEntryPointTest, AppendFormatWithV) {
85    std::string s;
86    std::string& r = StrAppendFormat(&s, "%v", 123);
87    EXPECT_EQ(&s, &r);  
88    EXPECT_EQ("123", r);
89  }
90  TEST_F(FormatEntryPointTest, AppendFormatFail) {
91    std::string s = "orig";
92    UntypedFormatSpec format(" more %d");
93    FormatArgImpl arg("not an int");
94    EXPECT_EQ("orig",
95              str_format_internal::AppendPack(
96                  &s, str_format_internal::UntypedFormatSpecImpl::Extract(format),
97                  {&arg, 1}));
98  }
99  TEST_F(FormatEntryPointTest, AppendFormatFailWithV) {
100    std::string s = "orig";
101    UntypedFormatSpec format(" more %v");
102    FormatArgImpl arg("not an int");
103    EXPECT_EQ("orig",
104              str_format_internal::AppendPack(
105                  &s, str_format_internal::UntypedFormatSpecImpl::Extract(format),
106                  {&arg, 1}));
107  }
108  TEST_F(FormatEntryPointTest, ManyArgs) {
109    EXPECT_EQ(
110        "60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 "
111        "36 35 34 33 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 "
112        "12 11 10 9 8 7 6 5 4 3 2 1",
113        StrFormat("%60$d %59$d %58$d %57$d %56$d %55$d %54$d %53$d %52$d %51$d "
114                  "%50$d %49$d %48$d %47$d %46$d %45$d %44$d %43$d %42$d %41$d "
115                  "%40$d %39$d %38$d %37$d %36$d %35$d %34$d %33$d %32$d %31$d "
116                  "%30$d %29$d %28$d %27$d %26$d %25$d %24$d %23$d %22$d %21$d "
117                  "%20$d %19$d %18$d %17$d %16$d %15$d %14$d %13$d %12$d %11$d "
118                  "%10$d %9$d %8$d %7$d %6$d %5$d %4$d %3$d %2$d %1$d",
119                  1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,
120                  19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34,
121                  35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50,
122                  51, 52, 53, 54, 55, 56, 57, 58, 59, 60));
123  }
124  TEST_F(FormatEntryPointTest, Preparsed) {
125    ParsedFormat<'d'> pc("%d");
126    EXPECT_EQ("123", StrFormat(pc, 123));
127    EXPECT_EQ("123", StrFormat(ParsedFormat<'d'>("%d"), 123));
128    constexpr absl::string_view view("=%d=", 4);
129    EXPECT_EQ("=123=", StrFormat(ParsedFormat<'d'>(view), 123));
130  }
131  TEST_F(FormatEntryPointTest, PreparsedWithV) {
132    ParsedFormat<'v'> pc("%v");
133    EXPECT_EQ("123", StrFormat(pc, 123));
134    EXPECT_EQ("123", StrFormat(ParsedFormat<'v'>("%v"), 123));
135    constexpr absl::string_view view("=%v=", 4);
136    EXPECT_EQ("=123=", StrFormat(ParsedFormat<'v'>(view), 123));
137  }
138  TEST_F(FormatEntryPointTest, FormatCountCapture) {
139    int n = 0;
140    EXPECT_EQ("", StrFormat("%n", FormatCountCapture(&n)));
141    EXPECT_EQ(0, n);
142    EXPECT_EQ("123", StrFormat("%d%n", 123, FormatCountCapture(&n)));
143    EXPECT_EQ(3, n);
144  }
145  TEST_F(FormatEntryPointTest, FormatCountCaptureWithV) {
146    int n = 0;
147    EXPECT_EQ("", StrFormat("%n", FormatCountCapture(&n)));
148    EXPECT_EQ(0, n);
149    EXPECT_EQ("123", StrFormat("%v%n", 123, FormatCountCapture(&n)));
150    EXPECT_EQ(3, n);
151  }
152  TEST_F(FormatEntryPointTest, FormatCountCaptureWrongType) {
153    int n = 0;
154    UntypedFormatSpec format("%d%n");
155    int i = 123, *ip = &n;
156    FormatArgImpl args[2] = {FormatArgImpl(i), FormatArgImpl(ip)};
157    EXPECT_EQ("", str_format_internal::FormatPack(
158                      str_format_internal::UntypedFormatSpecImpl::Extract(format),
159                      absl::MakeSpan(args)));
160  }
161  TEST_F(FormatEntryPointTest, FormatCountCaptureWrongTypeWithV) {
162    int n = 0;
163    UntypedFormatSpec format("%v%n");
164    int i = 123, *ip = &n;
165    FormatArgImpl args[2] = {FormatArgImpl(i), FormatArgImpl(ip)};
166    EXPECT_EQ("", str_format_internal::FormatPack(
167                      str_format_internal::UntypedFormatSpecImpl::Extract(format),
168                      absl::MakeSpan(args)));
169  }
170  TEST_F(FormatEntryPointTest, FormatCountCaptureMultiple) {
171    int n1 = 0;
172    int n2 = 0;
173    EXPECT_EQ("    1         2",
174              StrFormat("%5d%n%10d%n", 1, FormatCountCapture(&n1), 2,
175                        FormatCountCapture(&n2)));
176    EXPECT_EQ(5, n1);
177    EXPECT_EQ(15, n2);
178  }
179  TEST_F(FormatEntryPointTest, FormatCountCaptureExample) {
180    int n;
181    std::string s;
182    StrAppendFormat(&s, "%s: %n%s\n", "(1,1)", FormatCountCapture(&n), "(1,2)");
183    StrAppendFormat(&s, "%*s%s\n", n, "", "(2,2)");
184    EXPECT_EQ(7, n);
185    EXPECT_EQ(
186        "(1,1): (1,2)\n"
187        "       (2,2)\n",
188        s);
189  }
190  TEST_F(FormatEntryPointTest, FormatCountCaptureExampleWithV) {
191    int n;
192    std::string s;
193    std::string a1 = "(1,1)";
194    std::string a2 = "(1,2)";
195    std::string a3 = "(2,2)";
196    StrAppendFormat(&s, "%v: %n%v\n", a1, FormatCountCapture(&n), a2);
197    StrAppendFormat(&s, "%*s%v\n", n, "", a3);
198    EXPECT_EQ(7, n);
199    EXPECT_EQ(
200        "(1,1): (1,2)\n"
201        "       (2,2)\n",
202        s);
203  }
204  TEST_F(FormatEntryPointTest, Stream) {
205    const std::string formats[] = {
206      "",
207      "a",
208      "%80d",
209      "%d %u %c %s %f %g",
210  #if !defined(_MSC_VER) && !defined(__ANDROID__) && !defined(__native_client__)
211      "complicated multipart %% %1$d format %1$080d",
212  #endif  
213    };
214    std::string buf(4096, '\0');
215    for (const auto& fmt : formats) {
216      const auto parsed =
217          ParsedFormat<'d', 'u', 'c', 's', 'f', 'g'>::NewAllowIgnored(fmt);
218      std::ostringstream oss;
219      oss << StreamFormat(*parsed, 123, 3, 49, "multistreaming!!!", 1.01, 1.01);
220      int fmt_result = snprintf(&*buf.begin(), buf.size(), fmt.c_str(),  
221                                123, 3, 49, "multistreaming!!!", 1.01, 1.01);
222      ASSERT_TRUE(oss) << fmt;
223      ASSERT_TRUE(fmt_result >= 0 && static_cast<size_t>(fmt_result) < buf.size())
224          << fmt_result;
225      EXPECT_EQ(buf.c_str(), oss.str());
226    }
227  }
228  TEST_F(FormatEntryPointTest, StreamWithV) {
229    const std::string formats[] = {
230        "",
231        "a",
232        "%v %u %c %v %f %v",
233    };
234    const std::string formats_for_buf[] = {
235        "",
236        "a",
237        "%d %u %c %s %f %g",
238    };
239    std::string buf(4096, '\0');
240    for (auto i = 0; i < ABSL_ARRAYSIZE(formats); ++i) {
241      const auto parsed =
242          ParsedFormat<'v', 'u', 'c', 'v', 'f', 'v'>::NewAllowIgnored(formats[i]);
243      std::ostringstream oss;
244      oss << StreamFormat(*parsed, 123, 3, 49,
245                          absl::string_view("multistreaming!!!"), 1.01, 1.01);
246      int fmt_result =
247          snprintf(&*buf.begin(), buf.size(), formats_for_buf[i].c_str(),  
248                   123, 3, 49, "multistreaming!!!", 1.01, 1.01);
249      ASSERT_TRUE(oss) << formats[i];
250      ASSERT_TRUE(fmt_result >= 0 && static_cast<size_t>(fmt_result) < buf.size())
251          << fmt_result;
252      EXPECT_EQ(buf.c_str(), oss.str());
253    }
254  }
255  TEST_F(FormatEntryPointTest, StreamOk) {
256    std::ostringstream oss;
257    oss << StreamFormat("hello %d", 123);
258    EXPECT_EQ("hello 123", oss.str());
259    EXPECT_TRUE(oss.good());
260  }
261  TEST_F(FormatEntryPointTest, StreamOkWithV) {
262    std::ostringstream oss;
263    oss << StreamFormat("hello %v", 123);
264    EXPECT_EQ("hello 123", oss.str());
265    EXPECT_TRUE(oss.good());
266  }
267  TEST_F(FormatEntryPointTest, StreamFail) {
268    std::ostringstream oss;
269    UntypedFormatSpec format("hello %d");
270    FormatArgImpl arg("non-numeric");
271    oss << str_format_internal::Streamable(
272        str_format_internal::UntypedFormatSpecImpl::Extract(format), {&arg, 1});
273    EXPECT_EQ("hello ", oss.str());  
274    EXPECT_TRUE(oss.fail());
275  }
276  TEST_F(FormatEntryPointTest, StreamFailWithV) {
277    std::ostringstream oss;
278    UntypedFormatSpec format("hello %v");
279    FormatArgImpl arg("non-numeric");
280    oss << str_format_internal::Streamable(
281        str_format_internal::UntypedFormatSpecImpl::Extract(format), {&arg, 1});
282    EXPECT_EQ("hello ", oss.str());  
283    EXPECT_TRUE(oss.fail());
284  }
285  std::string WithSnprintf(const char* fmt, ...) {
286    std::string buf;
287    buf.resize(128);
288    va_list va;
289    va_start(va, fmt);
290    int r = vsnprintf(&*buf.begin(), buf.size(), fmt, va);
291    va_end(va);
292    EXPECT_GE(r, 0);
293    EXPECT_LT(r, buf.size());
294    buf.resize(r);
295    return buf;
296  }
297  TEST_F(FormatEntryPointTest, FloatPrecisionArg) {
298    EXPECT_EQ("0.1", StrFormat("%.1f", 0.1));
299    EXPECT_EQ("0.1", WithSnprintf("%.1f", 0.1));
300    EXPECT_EQ("  0.1", StrFormat("%*.1f", 5, 0.1));
301    EXPECT_EQ("  0.1", WithSnprintf("%*.1f", 5, 0.1));
302    EXPECT_EQ("0.1", StrFormat("%.*f", 1, 0.1));
303    EXPECT_EQ("0.1", WithSnprintf("%.*f", 1, 0.1));
304    EXPECT_EQ("  0.1", StrFormat("%*.*f", 5, 1, 0.1));
305    EXPECT_EQ("  0.1", WithSnprintf("%*.*f", 5, 1, 0.1));
306  }
307  namespace streamed_test {
308  struct X {};
309  std::ostream& operator<<(std::ostream& os, const X&) {
310    return os << "X";
311  }
312  }  
313  TEST_F(FormatEntryPointTest, FormatStreamed) {
314    EXPECT_EQ("123", StrFormat("%s", FormatStreamed(123)));
315    EXPECT_EQ("  123", StrFormat("%5s", FormatStreamed(123)));
316    EXPECT_EQ("123  ", StrFormat("%-5s", FormatStreamed(123)));
317    EXPECT_EQ("X", StrFormat("%s", FormatStreamed(streamed_test::X())));
318    EXPECT_EQ("123", StrFormat("%s", FormatStreamed(StreamFormat("%d", 123))));
319  }
320  TEST_F(FormatEntryPointTest, FormatStreamedWithV) {
321    EXPECT_EQ("123", StrFormat("%v", FormatStreamed(123)));
322    EXPECT_EQ("X", StrFormat("%v", FormatStreamed(streamed_test::X())));
323    EXPECT_EQ("123", StrFormat("%v", FormatStreamed(StreamFormat("%d", 123))));
324  }
325  class TempFile {
326   public:
327    TempFile() : file_(std::tmpfile()) {}
328    ~TempFile() { std::fclose(file_); }
329    std::FILE* file() const { return file_; }
330    std::string ReadFile() {
331      std::fseek(file_, 0, SEEK_END);
332      int size = std::ftell(file_);
333      EXPECT_GT(size, 0);
334      std::rewind(file_);
335      std::string str(2 * size, ' ');
336      int read_bytes = std::fread(&str[0], 1, str.size(), file_);
337      EXPECT_EQ(read_bytes, size);
338      str.resize(read_bytes);
339      EXPECT_TRUE(std::feof(file_));
340      return str;
341    }
342   private:
343    std::FILE* file_;
344  };
345  TEST_F(FormatEntryPointTest, FPrintF) {
346    TempFile tmp;
347    int result =
348        FPrintF(tmp.file(), "STRING: %s NUMBER: %010d", std::string("ABC"), -19);
349    EXPECT_EQ(result, 30);
350    EXPECT_EQ(tmp.ReadFile(), "STRING: ABC NUMBER: -000000019");
351  }
352  TEST_F(FormatEntryPointTest, FPrintFWithV) {
353    TempFile tmp;
354    int result =
355        FPrintF(tmp.file(), "STRING: %v NUMBER: %010d", std::string("ABC"), -19);
356    EXPECT_EQ(result, 30);
357    EXPECT_EQ(tmp.ReadFile(), "STRING: ABC NUMBER: -000000019");
358  }
359  TEST_F(FormatEntryPointTest, FPrintFError) {
360    errno = 0;
361    int result = FPrintF(stdin, "ABC");
362    EXPECT_LT(result, 0);
363    EXPECT_EQ(errno, EBADF);
364  }
365  #ifdef __GLIBC__
366  TEST_F(FormatEntryPointTest, FprintfTooLarge) {
367    std::FILE* f = std::fopen("/dev/null", "w");
368    int width = 2000000000;
369    errno = 0;
370    int result = FPrintF(f, "%*d %*d", width, 0, width, 0);
371    EXPECT_LT(result, 0);
372    EXPECT_EQ(errno, EFBIG);
373    std::fclose(f);
374  }
375  TEST_F(FormatEntryPointTest, PrintF) {
376    int stdout_tmp = dup(STDOUT_FILENO);
377    TempFile tmp;
378    std::fflush(stdout);
379    dup2(fileno(tmp.file()), STDOUT_FILENO);
380    int result = PrintF("STRING: %s NUMBER: %010d", std::string("ABC"), -19);
381    std::fflush(stdout);
382    dup2(stdout_tmp, STDOUT_FILENO);
383    close(stdout_tmp);
384    EXPECT_EQ(result, 30);
385    EXPECT_EQ(tmp.ReadFile(), "STRING: ABC NUMBER: -000000019");
386  }
387  TEST_F(FormatEntryPointTest, PrintFWithV) {
388    int stdout_tmp = dup(STDOUT_FILENO);
389    TempFile tmp;
390    std::fflush(stdout);
391    dup2(fileno(tmp.file()), STDOUT_FILENO);
392    int result = PrintF("STRING: %v NUMBER: %010d", std::string("ABC"), -19);
393    std::fflush(stdout);
394    dup2(stdout_tmp, STDOUT_FILENO);
395    close(stdout_tmp);
396    EXPECT_EQ(result, 30);
397    EXPECT_EQ(tmp.ReadFile(), "STRING: ABC NUMBER: -000000019");
398  }
399  #endif  
400  TEST_F(FormatEntryPointTest, SNPrintF) {
401    char buffer[16];
402    int result =
403        SNPrintF(buffer, sizeof(buffer), "STRING: %s", std::string("ABC"));
404    EXPECT_EQ(result, 11);
405    EXPECT_EQ(std::string(buffer), "STRING: ABC");
406    result = SNPrintF(buffer, sizeof(buffer), "NUMBER: %d", 123456);
407    EXPECT_EQ(result, 14);
408    EXPECT_EQ(std::string(buffer), "NUMBER: 123456");
409    result = SNPrintF(buffer, sizeof(buffer), "NUMBER: %d", 1234567);
410    EXPECT_EQ(result, 15);
411    EXPECT_EQ(std::string(buffer), "NUMBER: 1234567");
412    result = SNPrintF(buffer, sizeof(buffer), "NUMBER: %d", 12345678);
413    EXPECT_EQ(result, 16);
414    EXPECT_EQ(std::string(buffer), "NUMBER: 1234567");
415    result = SNPrintF(buffer, sizeof(buffer), "NUMBER: %d", 123456789);
416    EXPECT_EQ(result, 17);
417    EXPECT_EQ(std::string(buffer), "NUMBER: 1234567");
418    result = SNPrintF(nullptr, 0, "Just checking the %s of the output.", "size");
419    EXPECT_EQ(result, 37);
420  }
421  TEST_F(FormatEntryPointTest, SNPrintFWithV) {
422    char buffer[16];
423    int result =
424        SNPrintF(buffer, sizeof(buffer), "STRING: %v", std::string("ABC"));
425    EXPECT_EQ(result, 11);
426    EXPECT_EQ(std::string(buffer), "STRING: ABC");
427    result = SNPrintF(buffer, sizeof(buffer), "NUMBER: %v", 123456);
428    EXPECT_EQ(result, 14);
429    EXPECT_EQ(std::string(buffer), "NUMBER: 123456");
430    result = SNPrintF(buffer, sizeof(buffer), "NUMBER: %v", 1234567);
431    EXPECT_EQ(result, 15);
432    EXPECT_EQ(std::string(buffer), "NUMBER: 1234567");
433    result = SNPrintF(buffer, sizeof(buffer), "NUMBER: %v", 12345678);
434    EXPECT_EQ(result, 16);
435    EXPECT_EQ(std::string(buffer), "NUMBER: 1234567");
436    result = SNPrintF(buffer, sizeof(buffer), "NUMBER: %v", 123456789);
437    EXPECT_EQ(result, 17);
438    EXPECT_EQ(std::string(buffer), "NUMBER: 1234567");
439    std::string size = "size";
440    result = SNPrintF(nullptr, 0, "Just checking the %v of the output.", size);
441    EXPECT_EQ(result, 37);
442  }
443  TEST(StrFormat, BehavesAsDocumented) {
444    std::string s = absl::StrFormat("%s, %d!", "Hello", 123);
445    EXPECT_EQ("Hello, 123!", s);
446    std::string hello = "Hello";
447    std::string s2 = absl::StrFormat("%v, %v!", hello, 123);
448    EXPECT_EQ("Hello, 123!", s2);
449    EXPECT_EQ(absl::StrFormat("%1$+3.2Lf", 1.1), "+1.10");
450    EXPECT_EQ(StrFormat("%c", 'a'), "a");
451    EXPECT_EQ(StrFormat("%c", 0x20), " ");
452    EXPECT_EQ(StrFormat("%c", int{'a'}), "a");
453    EXPECT_EQ(StrFormat("%c", long{'a'}), "a");  
454    EXPECT_EQ(StrFormat("%c", uint64_t{'a'}), "a");
455    EXPECT_EQ(StrFormat("%s", "C"), "C");
456    EXPECT_EQ(StrFormat("%v", std::string("C")), "C");
457    EXPECT_EQ(StrFormat("%s", std::string("C++")), "C++");
458    EXPECT_EQ(StrFormat("%v", std::string("C++")), "C++");
459    EXPECT_EQ(StrFormat("%s", string_view("view")), "view");
460    EXPECT_EQ(StrFormat("%v", string_view("view")), "view");
461    EXPECT_EQ(StrFormat("%s", absl::Cord("cord")), "cord");
462    EXPECT_EQ(StrFormat("%v", absl::Cord("cord")), "cord");
463    EXPECT_EQ(StrFormat("%d", char{10}), "10");
464    EXPECT_EQ(StrFormat("%d", int{10}), "10");
465    EXPECT_EQ(StrFormat("%d", long{10}), "10");  
466    EXPECT_EQ(StrFormat("%d", uint64_t{10}), "10");
467    EXPECT_EQ(StrFormat("%v", int{10}), "10");
468    EXPECT_EQ(StrFormat("%v", long{10}), "10");  
469    EXPECT_EQ(StrFormat("%v", uint64_t{10}), "10");
470    EXPECT_EQ(StrFormat("%d", -10), "-10");
471    EXPECT_EQ(StrFormat("%i", -10), "-10");
472    EXPECT_EQ(StrFormat("%v", -10), "-10");
473    EXPECT_EQ(StrFormat("%o", 10), "12");
474    EXPECT_EQ(StrFormat("%u", 10), "10");
475    EXPECT_EQ(StrFormat("%v", 10), "10");
476    EXPECT_EQ(StrFormat("%x", 10), "a");
477    EXPECT_EQ(StrFormat("%X", 10), "A");
478    EXPECT_EQ(StrFormat("%.1f", float{1}), "1.0");
479    EXPECT_EQ(StrFormat("%.1f", double{1}), "1.0");
480    const long double long_double = 1.0;
481    EXPECT_EQ(StrFormat("%.1f", long_double), "1.0");
482    EXPECT_EQ(StrFormat("%.1f", char{1}), "1.0");
483    EXPECT_EQ(StrFormat("%.1f", int{1}), "1.0");
484    EXPECT_EQ(StrFormat("%.1f", long{1}), "1.0");  
485    EXPECT_EQ(StrFormat("%.1f", uint64_t{1}), "1.0");
486    EXPECT_EQ(StrFormat("%f", 123456789), "123456789.000000");
487    EXPECT_EQ(StrFormat("%F", 123456789), "123456789.000000");
488    EXPECT_EQ(StrFormat("%e", .01), "1.000000e-02");
489    EXPECT_EQ(StrFormat("%E", .01), "1.000000E-02");
490    EXPECT_EQ(StrFormat("%g", .01), "0.01");
491    EXPECT_EQ(StrFormat("%g", 1e10), "1e+10");
492    EXPECT_EQ(StrFormat("%G", 1e10), "1E+10");
493    EXPECT_EQ(StrFormat("%v", .01), "0.01");
494    EXPECT_EQ(StrFormat("%v", 1e10), "1e+10");
495  #if !defined(__ANDROID_API__) || __ANDROID_API__ > 21
496    EXPECT_EQ(StrFormat("%.1a", -3.0), "-0x1.8p+1");  
497    EXPECT_EQ(StrFormat("%.1A", -3.0), "-0X1.8P+1");  
498  #endif
499    int64_t value = 0x7ffdeb4;
500    auto ptr_value = static_cast<uintptr_t>(value);
501    const int& something = *reinterpret_cast<const int*>(ptr_value);
502    EXPECT_EQ(StrFormat("%p", &something), StrFormat("0x%x", ptr_value));
503    EXPECT_EQ(StrFormat("%3d", 1), "  1");
504    EXPECT_EQ(StrFormat("%3d", 123456), "123456");
505    EXPECT_EQ(StrFormat("%06.2f", 1.234), "001.23");
506    EXPECT_EQ(StrFormat("%+d", 1), "+1");
507    EXPECT_EQ(StrFormat("% d", 1), " 1");
508    EXPECT_EQ(StrFormat("%-4d", -1), "-1  ");
509    EXPECT_EQ(StrFormat("%#o", 10), "012");
510    EXPECT_EQ(StrFormat("%#x", 15), "0xf");
511    EXPECT_EQ(StrFormat("%04d", 8), "0008");
512    EXPECT_EQ(absl::StrFormat("%2$s, %3$s, %1$s!", "vici", "veni", "vidi"),
513              "veni, vidi, vici!");
514    EXPECT_EQ(StrFormat("%hhd", int{1}), "1");
515    EXPECT_EQ(StrFormat("%hd", int{1}), "1");
516    EXPECT_EQ(StrFormat("%ld", int{1}), "1");
517    EXPECT_EQ(StrFormat("%lld", int{1}), "1");
518    EXPECT_EQ(StrFormat("%Ld", int{1}), "1");
519    EXPECT_EQ(StrFormat("%jd", int{1}), "1");
520    EXPECT_EQ(StrFormat("%zd", int{1}), "1");
521    EXPECT_EQ(StrFormat("%td", int{1}), "1");
522    EXPECT_EQ(StrFormat("%qd", int{1}), "1");
523    EXPECT_EQ(StrFormat("%v", true), "true");
524    EXPECT_EQ(StrFormat("%v", false), "false");
525    EXPECT_EQ(StrFormat("%d", true), "1");
526  }
527  using str_format_internal::ExtendedParsedFormat;
528  using str_format_internal::ParsedFormatBase;
529  struct SummarizeConsumer {
530    std::string* out;
531    explicit SummarizeConsumer(std::string* out) : out(out) {}
532    bool Append(string_view s) {
533      *out += "[" + std::string(s) + "]";
534      return true;
535    }
536    bool ConvertOne(const str_format_internal::UnboundConversion& conv,
537                    string_view s) {
538      *out += "{";
539      *out += std::string(s);
540      *out += ":";
541      *out += std::to_string(conv.arg_position) + "$";
542      if (conv.width.is_from_arg()) {
543        *out += std::to_string(conv.width.get_from_arg()) + "$*";
544      }
545      if (conv.precision.is_from_arg()) {
546        *out += "." + std::to_string(conv.precision.get_from_arg()) + "$*";
547      }
548      *out += str_format_internal::FormatConversionCharToChar(conv.conv);
549      *out += "}";
550      return true;
551    }
552  };
553  std::string SummarizeParsedFormat(const ParsedFormatBase& pc) {
554    std::string out;
555    if (!pc.ProcessFormat(SummarizeConsumer(&out))) out += "!";
556    return out;
557  }
558  using ParsedFormatTest = ::testing::Test;
559  TEST_F(ParsedFormatTest, SimpleChecked) {
560    EXPECT_EQ("[ABC]{d:1$d}[DEF]",
561              SummarizeParsedFormat(ParsedFormat<'d'>("ABC%dDEF")));
562    EXPECT_EQ("{s:1$s}[FFF]{d:2$d}[ZZZ]{f:3$f}",
563              SummarizeParsedFormat(ParsedFormat<'s', 'd', 'f'>("%sFFF%dZZZ%f")));
564    EXPECT_EQ("{s:1$s}[ ]{.*d:3$.2$*d}",
565              SummarizeParsedFormat(ParsedFormat<'s', '*', 'd'>("%s %.*d")));
566  }
567  TEST_F(ParsedFormatTest, SimpleCheckedWithV) {
568    EXPECT_EQ("[ABC]{v:1$v}[DEF]",
569              SummarizeParsedFormat(ParsedFormat<'v'>("ABC%vDEF")));
570    EXPECT_EQ("{v:1$v}[FFF]{v:2$v}[ZZZ]{f:3$f}",
571              SummarizeParsedFormat(ParsedFormat<'v', 'v', 'f'>("%vFFF%vZZZ%f")));
572    EXPECT_EQ("{v:1$v}[ ]{.*d:3$.2$*d}",
573              SummarizeParsedFormat(ParsedFormat<'v', '*', 'd'>("%v %.*d")));
574  }
575  TEST_F(ParsedFormatTest, SimpleUncheckedCorrect) {
576    auto f = ParsedFormat<'d'>::New("ABC%dDEF");
577    ASSERT_TRUE(f);
578    EXPECT_EQ("[ABC]{d:1$d}[DEF]", SummarizeParsedFormat(*f));
579    std::string format = "%sFFF%dZZZ%f";
580    auto f2 = ParsedFormat<'s', 'd', 'f'>::New(format);
581    ASSERT_TRUE(f2);
582    EXPECT_EQ("{s:1$s}[FFF]{d:2$d}[ZZZ]{f:3$f}", SummarizeParsedFormat(*f2));
583    f2 = ParsedFormat<'s', 'd', 'f'>::New("%s %d %f");
584    ASSERT_TRUE(f2);
585    EXPECT_EQ("{s:1$s}[ ]{d:2$d}[ ]{f:3$f}", SummarizeParsedFormat(*f2));
586    auto star = ParsedFormat<'*', 'd'>::New("%*d");
587    ASSERT_TRUE(star);
588    EXPECT_EQ("{*d:2$1$*d}", SummarizeParsedFormat(*star));
589    auto dollar = ParsedFormat<'d', 's'>::New("%2$s %1$d");
590    ASSERT_TRUE(dollar);
591    EXPECT_EQ("{2$s:2$s}[ ]{1$d:1$d}", SummarizeParsedFormat(*dollar));
592    dollar = ParsedFormat<'d', 's'>::New("%2$s %1$d %1$d");
593    ASSERT_TRUE(dollar);
594    EXPECT_EQ("{2$s:2$s}[ ]{1$d:1$d}[ ]{1$d:1$d}",
595              SummarizeParsedFormat(*dollar));
596  }
597  TEST_F(ParsedFormatTest, SimpleUncheckedCorrectWithV) {
598    auto f = ParsedFormat<'v'>::New("ABC%vDEF");
599    ASSERT_TRUE(f);
600    EXPECT_EQ("[ABC]{v:1$v}[DEF]", SummarizeParsedFormat(*f));
601    std::string format = "%vFFF%vZZZ%f";
602    auto f2 = ParsedFormat<'v', 'v', 'f'>::New(format);
603    ASSERT_TRUE(f2);
604    EXPECT_EQ("{v:1$v}[FFF]{v:2$v}[ZZZ]{f:3$f}", SummarizeParsedFormat(*f2));
605    f2 = ParsedFormat<'v', 'v', 'f'>::New("%v %v %f");
606    ASSERT_TRUE(f2);
607    EXPECT_EQ("{v:1$v}[ ]{v:2$v}[ ]{f:3$f}", SummarizeParsedFormat(*f2));
608  }
609  TEST_F(ParsedFormatTest, SimpleUncheckedIgnoredArgs) {
610    EXPECT_FALSE((ParsedFormat<'d', 's'>::New("ABC")));
611    EXPECT_FALSE((ParsedFormat<'d', 's'>::New("%dABC")));
612    EXPECT_FALSE((ParsedFormat<'d', 's'>::New("ABC%2$s")));
613    auto f = ParsedFormat<'d', 's'>::NewAllowIgnored("ABC");
614    ASSERT_TRUE(f);
615    EXPECT_EQ("[ABC]", SummarizeParsedFormat(*f));
616    f = ParsedFormat<'d', 's'>::NewAllowIgnored("%dABC");
617    ASSERT_TRUE(f);
618    EXPECT_EQ("{d:1$d}[ABC]", SummarizeParsedFormat(*f));
619    f = ParsedFormat<'d', 's'>::NewAllowIgnored("ABC%2$s");
620    ASSERT_TRUE(f);
621    EXPECT_EQ("[ABC]{2$s:2$s}", SummarizeParsedFormat(*f));
622  }
623  TEST_F(ParsedFormatTest, SimpleUncheckedIgnoredArgsWithV) {
624    EXPECT_FALSE((ParsedFormat<'v', 'v'>::New("ABC")));
625    EXPECT_FALSE((ParsedFormat<'v', 'v'>::New("%vABC")));
626    EXPECT_FALSE((ParsedFormat<'v', 's'>::New("ABC%2$s")));
627    auto f = ParsedFormat<'v', 'v'>::NewAllowIgnored("ABC");
628    ASSERT_TRUE(f);
629    EXPECT_EQ("[ABC]", SummarizeParsedFormat(*f));
630    f = ParsedFormat<'v', 'v'>::NewAllowIgnored("%vABC");
631    ASSERT_TRUE(f);
632    EXPECT_EQ("{v:1$v}[ABC]", SummarizeParsedFormat(*f));
633  }
634  TEST_F(ParsedFormatTest, SimpleUncheckedUnsupported) {
635    EXPECT_FALSE(ParsedFormat<'d'>::New("%1$d %1$x"));
636    EXPECT_FALSE(ParsedFormat<'x'>::New("%1$d %1$x"));
637  }
638  TEST_F(ParsedFormatTest, SimpleUncheckedIncorrect) {
639    EXPECT_FALSE(ParsedFormat<'d'>::New(""));
640    EXPECT_FALSE(ParsedFormat<'d'>::New("ABC%dDEF%d"));
641    std::string format = "%sFFF%dZZZ%f";
642    EXPECT_FALSE((ParsedFormat<'s', 'd', 'g'>::New(format)));
643  }
644  TEST_F(ParsedFormatTest, SimpleUncheckedIncorrectWithV) {
645    EXPECT_FALSE(ParsedFormat<'v'>::New(""));
646    EXPECT_FALSE(ParsedFormat<'v'>::New("ABC%vDEF%v"));
647    std::string format = "%vFFF%vZZZ%f";
648    EXPECT_FALSE((ParsedFormat<'v', 'v', 'g'>::New(format)));
649  }
650  #if defined(__cpp_nontype_template_parameter_auto)
651  template <auto T>
652  std::true_type IsValidParsedFormatArgTest(ParsedFormat<T>*);
653  template <auto T>
654  std::false_type IsValidParsedFormatArgTest(...);
655  template <auto T>
656  using IsValidParsedFormatArg = decltype(IsValidParsedFormatArgTest<T>(nullptr));
657  TEST_F(ParsedFormatTest, OnlyValidTypesAllowed) {
658    ASSERT_TRUE(IsValidParsedFormatArg<'c'>::value);
659    ASSERT_TRUE(IsValidParsedFormatArg<FormatConversionCharSet::d>::value);
660    ASSERT_TRUE(IsValidParsedFormatArg<absl::FormatConversionCharSet::d |
661                                       absl::FormatConversionCharSet::x>::value);
662    ASSERT_TRUE(
663        IsValidParsedFormatArg<absl::FormatConversionCharSet::kIntegral>::value);
664    ASSERT_FALSE(IsValidParsedFormatArg<'x' | 'd'>::value);
665    ASSERT_FALSE(IsValidParsedFormatArg<absl::FormatConversionChar::d>::value);
666  }
667  TEST_F(ParsedFormatTest, ExtendedTyping) {
668    EXPECT_FALSE(ParsedFormat<FormatConversionCharSet::d>::New(""));
669    ASSERT_TRUE(ParsedFormat<absl::FormatConversionCharSet::d>::New("%d"));
670    auto v1 = ParsedFormat<'d', absl::FormatConversionCharSet::s>::New("%d%s");
671    ASSERT_TRUE(v1);
672    auto v2 = ParsedFormat<absl::FormatConversionCharSet::d, 's'>::New("%d%s");
673    ASSERT_TRUE(v2);
674    auto v3 = ParsedFormat<absl::FormatConversionCharSet::d |
675                               absl::FormatConversionCharSet::s,
676                           's'>::New("%d%s");
677    ASSERT_TRUE(v3);
678    auto v4 = ParsedFormat<absl::FormatConversionCharSet::d |
679                               absl::FormatConversionCharSet::s,
680                           's'>::New("%s%s");
681    ASSERT_TRUE(v4);
682  }
683  TEST_F(ParsedFormatTest, ExtendedTypingWithV) {
684    EXPECT_FALSE(ParsedFormat<FormatConversionCharSet::v>::New(""));
685    ASSERT_TRUE(ParsedFormat<absl::FormatConversionCharSet::v>::New("%v"));
686    auto v1 = ParsedFormat<'v', absl::FormatConversionCharSet::v>::New("%v%v");
687    ASSERT_TRUE(v1);
688    auto v2 = ParsedFormat<absl::FormatConversionCharSet::v, 'v'>::New("%v%v");
689    ASSERT_TRUE(v2);
690    auto v3 = ParsedFormat<absl::FormatConversionCharSet::v |
691                               absl::FormatConversionCharSet::v,
692                           'v'>::New("%v%v");
693    ASSERT_TRUE(v3);
694    auto v4 = ParsedFormat<absl::FormatConversionCharSet::v |
695                               absl::FormatConversionCharSet::v,
696                           'v'>::New("%v%v");
697    ASSERT_TRUE(v4);
698  }
699  #endif
700  TEST_F(ParsedFormatTest, UncheckedCorrect) {
701    auto f =
702        ExtendedParsedFormat<absl::FormatConversionCharSet::d>::New("ABC%dDEF");
703    ASSERT_TRUE(f);
704    EXPECT_EQ("[ABC]{d:1$d}[DEF]", SummarizeParsedFormat(*f));
705    std::string format = "%sFFF%dZZZ%f";
706    auto f2 = ExtendedParsedFormat<
707        absl::FormatConversionCharSet::kString, absl::FormatConversionCharSet::d,
708        absl::FormatConversionCharSet::kFloating>::New(format);
709    ASSERT_TRUE(f2);
710    EXPECT_EQ("{s:1$s}[FFF]{d:2$d}[ZZZ]{f:3$f}", SummarizeParsedFormat(*f2));
711    f2 = ExtendedParsedFormat<
712        absl::FormatConversionCharSet::kString, absl::FormatConversionCharSet::d,
713        absl::FormatConversionCharSet::kFloating>::New("%s %d %f");
714    ASSERT_TRUE(f2);
715    EXPECT_EQ("{s:1$s}[ ]{d:2$d}[ ]{f:3$f}", SummarizeParsedFormat(*f2));
716    auto star =
717        ExtendedParsedFormat<absl::FormatConversionCharSet::kStar,
718                             absl::FormatConversionCharSet::d>::New("%*d");
719    ASSERT_TRUE(star);
720    EXPECT_EQ("{*d:2$1$*d}", SummarizeParsedFormat(*star));
721    auto dollar =
722        ExtendedParsedFormat<absl::FormatConversionCharSet::d,
723                             absl::FormatConversionCharSet::s>::New("%2$s %1$d");
724    ASSERT_TRUE(dollar);
725    EXPECT_EQ("{2$s:2$s}[ ]{1$d:1$d}", SummarizeParsedFormat(*dollar));
726    dollar = ExtendedParsedFormat<
727        absl::FormatConversionCharSet::d,
728        absl::FormatConversionCharSet::s>::New("%2$s %1$d %1$d");
729    ASSERT_TRUE(dollar);
730    EXPECT_EQ("{2$s:2$s}[ ]{1$d:1$d}[ ]{1$d:1$d}",
731              SummarizeParsedFormat(*dollar));
732  }
733  TEST_F(ParsedFormatTest, UncheckedCorrectWithV) {
734    auto f =
735        ExtendedParsedFormat<absl::FormatConversionCharSet::v>::New("ABC%vDEF");
736    ASSERT_TRUE(f);
737    EXPECT_EQ("[ABC]{v:1$v}[DEF]", SummarizeParsedFormat(*f));
738    std::string format = "%vFFF%vZZZ%f";
739    auto f2 = ExtendedParsedFormat<
740        absl::FormatConversionCharSet::v, absl::FormatConversionCharSet::v,
741        absl::FormatConversionCharSet::kFloating>::New(format);
742    ASSERT_TRUE(f2);
743    EXPECT_EQ("{v:1$v}[FFF]{v:2$v}[ZZZ]{f:3$f}", SummarizeParsedFormat(*f2));
744    f2 = ExtendedParsedFormat<
745        absl::FormatConversionCharSet::v, absl::FormatConversionCharSet::v,
746        absl::FormatConversionCharSet::kFloating>::New("%v %v %f");
747    ASSERT_TRUE(f2);
748    EXPECT_EQ("{v:1$v}[ ]{v:2$v}[ ]{f:3$f}", SummarizeParsedFormat(*f2));
749  }
750  TEST_F(ParsedFormatTest, UncheckedIgnoredArgs) {
751    EXPECT_FALSE(
752        (ExtendedParsedFormat<absl::FormatConversionCharSet::d,
753                              absl::FormatConversionCharSet::s>::New("ABC")));
754    EXPECT_FALSE(
755        (ExtendedParsedFormat<absl::FormatConversionCharSet::d,
756                              absl::FormatConversionCharSet::s>::New("%dABC")));
757    EXPECT_FALSE(
758        (ExtendedParsedFormat<absl::FormatConversionCharSet::d,
759                              absl::FormatConversionCharSet::s>::New("ABC%2$s")));
760    auto f = ExtendedParsedFormat<
761        absl::FormatConversionCharSet::d,
762        absl::FormatConversionCharSet::s>::NewAllowIgnored("ABC");
763    ASSERT_TRUE(f);
764    EXPECT_EQ("[ABC]", SummarizeParsedFormat(*f));
765    f = ExtendedParsedFormat<
766        absl::FormatConversionCharSet::d,
767        absl::FormatConversionCharSet::s>::NewAllowIgnored("%dABC");
768    ASSERT_TRUE(f);
769    EXPECT_EQ("{d:1$d}[ABC]", SummarizeParsedFormat(*f));
770    f = ExtendedParsedFormat<
771        absl::FormatConversionCharSet::d,
772        absl::FormatConversionCharSet::s>::NewAllowIgnored("ABC%2$s");
773    ASSERT_TRUE(f);
774    EXPECT_EQ("[ABC]{2$s:2$s}", SummarizeParsedFormat(*f));
775  }
776  TEST_F(ParsedFormatTest, UncheckedIgnoredArgsWithV) {
777    EXPECT_FALSE(
778        (ExtendedParsedFormat<absl::FormatConversionCharSet::v,
779                              absl::FormatConversionCharSet::v>::New("ABC")));
780    EXPECT_FALSE(
781        (ExtendedParsedFormat<absl::FormatConversionCharSet::v,
782                              absl::FormatConversionCharSet::v>::New("%vABC")));
783    EXPECT_FALSE((ExtendedParsedFormat<absl::FormatConversionCharSet::v,
784                                       absl::FormatConversionCharSet::s>::
785                      New("ABC%2$s")));
786    auto f = ExtendedParsedFormat<
787        absl::FormatConversionCharSet::v,
788        absl::FormatConversionCharSet::v>::NewAllowIgnored("ABC");
789    ASSERT_TRUE(f);
790    EXPECT_EQ("[ABC]", SummarizeParsedFormat(*f));
791    f = ExtendedParsedFormat<
792        absl::FormatConversionCharSet::v,
793        absl::FormatConversionCharSet::v>::NewAllowIgnored("%vABC");
794    ASSERT_TRUE(f);
795    EXPECT_EQ("{v:1$v}[ABC]", SummarizeParsedFormat(*f));
796  }
797  TEST_F(ParsedFormatTest, UncheckedMultipleTypes) {
798    auto dx =
799        ExtendedParsedFormat<absl::FormatConversionCharSet::d |
800                             absl::FormatConversionCharSet::x>::New("%1$d %1$x");
801    EXPECT_TRUE(dx);
802    EXPECT_EQ("{1$d:1$d}[ ]{1$x:1$x}", SummarizeParsedFormat(*dx));
803    dx = ExtendedParsedFormat<absl::FormatConversionCharSet::d |
804                              absl::FormatConversionCharSet::x>::New("%1$d");
805    EXPECT_TRUE(dx);
806    EXPECT_EQ("{1$d:1$d}", SummarizeParsedFormat(*dx));
807  }
808  TEST_F(ParsedFormatTest, UncheckedIncorrect) {
809    EXPECT_FALSE(ExtendedParsedFormat<absl::FormatConversionCharSet::d>::New(""));
810    EXPECT_FALSE(ExtendedParsedFormat<absl::FormatConversionCharSet::d>::New(
811        "ABC%dDEF%d"));
812    std::string format = "%sFFF%dZZZ%f";
813    EXPECT_FALSE(
814        (ExtendedParsedFormat<absl::FormatConversionCharSet::s,
815                              absl::FormatConversionCharSet::d,
816                              absl::FormatConversionCharSet::g>::New(format)));
817  }
818  TEST_F(ParsedFormatTest, UncheckedIncorrectWithV) {
819    EXPECT_FALSE(ExtendedParsedFormat<absl::FormatConversionCharSet::v>::New(""));
820    EXPECT_FALSE(ExtendedParsedFormat<absl::FormatConversionCharSet::v>::New(
821        "ABC%vDEF%v"));
822    std::string format = "%vFFF%vZZZ%f";
823    EXPECT_FALSE(
824        (ExtendedParsedFormat<absl::FormatConversionCharSet::v,
825                              absl::FormatConversionCharSet::g>::New(format)));
826  }
827  TEST_F(ParsedFormatTest, RegressionMixPositional) {
828    EXPECT_FALSE(
829        (ExtendedParsedFormat<absl::FormatConversionCharSet::d,
830                              absl::FormatConversionCharSet::o>::New("%1$d %o")));
831  }
832  TEST_F(ParsedFormatTest, DisallowModifiersWithV) {
833    auto f = ParsedFormat<'v'>::New("ABC%80vDEF");
834    EXPECT_EQ(f, nullptr);
835    f = ParsedFormat<'v'>::New("ABC%0vDEF");
836    EXPECT_EQ(f, nullptr);
837    f = ParsedFormat<'v'>::New("ABC%.1vDEF");
838    EXPECT_EQ(f, nullptr);
839  }
840  using FormatWrapperTest = ::testing::Test;
841  template <typename... Args>
842  std::string WrappedFormat(const absl::FormatSpec<Args...>& format,
843                            const Args&... args) {
844    return StrFormat(format, args...);
845  }
846  TEST_F(FormatWrapperTest, ConstexprStringFormat) {
847    EXPECT_EQ(WrappedFormat("%s there", "hello"), "hello there");
848  }
849  TEST_F(FormatWrapperTest, ConstexprStringFormatWithV) {
850    std::string hello = "hello";
851    EXPECT_EQ(WrappedFormat("%v there", hello), "hello there");
852  }
853  TEST_F(FormatWrapperTest, ParsedFormat) {
854    ParsedFormat<'s'> format("%s there");
855    EXPECT_EQ(WrappedFormat(format, "hello"), "hello there");
856  }
857  TEST_F(FormatWrapperTest, ParsedFormatWithV) {
858    std::string hello = "hello";
859    ParsedFormat<'v'> format("%v there");
860    EXPECT_EQ(WrappedFormat(format, hello), "hello there");
861  }
862  }  
863  ABSL_NAMESPACE_END
864  }  
865  namespace {
866  using FormatExtensionTest = ::testing::Test;
867  struct Point {
868    friend absl::FormatConvertResult<absl::FormatConversionCharSet::kString |
869                                     absl::FormatConversionCharSet::kIntegral |
870                                     absl::FormatConversionCharSet::v>
871    AbslFormatConvert(const Point& p, const absl::FormatConversionSpec& spec,
872                      absl::FormatSink* s) {
873      if (spec.conversion_char() == absl::FormatConversionChar::s) {
874        s->Append(absl::StrCat("x=", p.x, " y=", p.y));
875      } else {
876        s->Append(absl::StrCat(p.x, ",", p.y));
877      }
878      return {true};
879    }
880    int x = 10;
881    int y = 20;
882  };
883  TEST_F(FormatExtensionTest, AbslFormatConvertExample) {
884    Point p;
885    EXPECT_EQ(absl::StrFormat("a %s z", p), "a x=10 y=20 z");
886    EXPECT_EQ(absl::StrFormat("a %d z", p), "a 10,20 z");
887    EXPECT_EQ(absl::StrFormat("a %v z", p), "a 10,20 z");
888    std::string actual;
889    absl::UntypedFormatSpec f1("%f");
890    EXPECT_FALSE(absl::FormatUntyped(&actual, f1, {absl::FormatArg(p)}));
891  }
892  struct PointStringify {
893    template <typename FormatSink>
894    friend void AbslStringify(FormatSink& sink, const PointStringify& p) {
895      sink.Append(absl::StrCat("(", p.x, ", ", p.y, ")"));
896    }
<span onclick='openModal()' class='match'>897    double x = 10.0;
898    double y = 20.0;
899  };
900  TEST_F(FormatExtensionTest, AbslStringifyExample) {
901    PointStringify p;
902    EXPECT_EQ(absl::StrFormat("a %v z", p), "a (10, 20) z");
</span>903  }
904  struct PointStringifyUsingFormat {
905    template <typename FormatSink>
906    friend void AbslStringify(FormatSink& sink,
907                              const PointStringifyUsingFormat& p) {
908      absl::Format(&sink, "(%g, %g)", p.x, p.y);
909    }
910    double x = 10.0;
911    double y = 20.0;
912  };
913  TEST_F(FormatExtensionTest, AbslStringifyExampleUsingFormat) {
914    PointStringifyUsingFormat p;
915    EXPECT_EQ(absl::StrFormat("a %v z", p), "a (10, 20) z");
916  }
917  enum class EnumClassWithStringify { Many = 0, Choices = 1 };
918  template <typename Sink>
919  void AbslStringify(Sink& sink, EnumClassWithStringify e) {
920    absl::Format(&sink, "%s",
921                 e == EnumClassWithStringify::Many ? "Many" : "Choices");
922  }
923  enum EnumWithStringify { Many, Choices };
924  template <typename Sink>
925  void AbslStringify(Sink& sink, EnumWithStringify e) {
926    absl::Format(&sink, "%s", e == EnumWithStringify::Many ? "Many" : "Choices");
927  }
928  TEST_F(FormatExtensionTest, AbslStringifyWithEnumWithV) {
929    const auto e_class = EnumClassWithStringify::Choices;
930    EXPECT_EQ(absl::StrFormat("My choice is %v", e_class),
931              "My choice is Choices");
932    const auto e = EnumWithStringify::Choices;
933    EXPECT_EQ(absl::StrFormat("My choice is %v", e), "My choice is Choices");
934  }
935  TEST_F(FormatExtensionTest, AbslStringifyEnumWithD) {
936    const auto e_class = EnumClassWithStringify::Many;
937    EXPECT_EQ(absl::StrFormat("My choice is %d", e_class), "My choice is 0");
938    const auto e = EnumWithStringify::Choices;
939    EXPECT_EQ(absl::StrFormat("My choice is %d", e), "My choice is 1");
940  }
941  enum class EnumWithLargerValue { x = 32 };
942  template <typename Sink>
943  void AbslStringify(Sink& sink, EnumWithLargerValue e) {
944    absl::Format(&sink, "%s", "Many");
945  }
946  TEST_F(FormatExtensionTest, AbslStringifyEnumOtherSpecifiers) {
947    const auto e = EnumWithLargerValue::x;
948    EXPECT_EQ(absl::StrFormat("My choice is %g", e), "My choice is 32");
949    EXPECT_EQ(absl::StrFormat("My choice is %x", e), "My choice is 20");
950  }
951  }  
952  std::string CodegenAbslStrFormatInt(int i) {  
953    return absl::StrFormat("%d", i);
954  }
955  std::string CodegenAbslStrFormatIntStringInt64(int i, const std::string& s,
956                                                 int64_t i64) {  
957    return absl::StrFormat("%d %s %d", i, s, i64);
958  }
959  void CodegenAbslStrAppendFormatInt(std::string* out, int i) {  
960    absl::StrAppendFormat(out, "%d", i);
961  }
962  void CodegenAbslStrAppendFormatIntStringInt64(std::string* out, int i,
963                                                const std::string& s,
964                                                int64_t i64) {  
965    absl::StrAppendFormat(out, "%d %s %d", i, s, i64);
966  }
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-str_format_test.cc</h3>
            <pre><code>1  #include "absl/strings/str_format.h"
2  #include <cstdarg>
3  #include <cstdint>
4  #include <cstdio>
5  #include <string>
6  #include "gmock/gmock.h"
7  #include "gtest/gtest.h"
8  #include "absl/strings/cord.h"
9  #include "absl/strings/str_cat.h"
10  #include "absl/strings/string_view.h"
11  namespace absl {
12  ABSL_NAMESPACE_BEGIN
13  namespace {
14  using str_format_internal::FormatArgImpl;
15  using FormatEntryPointTest = ::testing::Test;
16  TEST_F(FormatEntryPointTest, Format) {
17    std::string sink;
18    EXPECT_TRUE(Format(&sink, "A format %d", 123));
19    EXPECT_EQ("A format 123", sink);
20    sink.clear();
21    ParsedFormat<'d'> pc("A format %d");
22    EXPECT_TRUE(Format(&sink, pc, 123));
23    EXPECT_EQ("A format 123", sink);
24  }
25  TEST_F(FormatEntryPointTest, FormatWithV) {
26    std::string sink;
27    EXPECT_TRUE(Format(&sink, "A format %v", 123));
28    EXPECT_EQ("A format 123", sink);
29    sink.clear();
30    ParsedFormat<'v'> pc("A format %v");
31    EXPECT_TRUE(Format(&sink, pc, 123));
32    EXPECT_EQ("A format 123", sink);
33  }
34  TEST_F(FormatEntryPointTest, UntypedFormat) {
35    constexpr const char* formats[] = {
36      "",
37      "a",
38      "%80d",
39  #if !defined(_MSC_VER) && !defined(__ANDROID__) && !defined(__native_client__)
40      "complicated multipart %% %1$d format %1$0999d",
41  #endif  
42    };
43    for (const char* fmt : formats) {
44      std::string actual;
45      int i = 123;
46      FormatArgImpl arg_123(i);
47      absl::Span<const FormatArgImpl> args(&arg_123, 1);
48      UntypedFormatSpec format(fmt);
49      EXPECT_TRUE(FormatUntyped(&actual, format, args));
50      char buf[4096]{};
51      snprintf(buf, sizeof(buf), fmt, 123);
52      EXPECT_EQ(
53          str_format_internal::FormatPack(
54              str_format_internal::UntypedFormatSpecImpl::Extract(format), args),
55          buf);
56      EXPECT_EQ(actual, buf);
57    }
58    ParsedFormat<'d'> pc("A format %d");
59    int i = 345;
60    FormatArg arg(i);
61    std::string out;
62    EXPECT_TRUE(str_format_internal::FormatUntyped(
63        &out, str_format_internal::UntypedFormatSpecImpl(&pc), {&arg, 1}));
64    EXPECT_EQ("A format 345", out);
65  }
66  TEST_F(FormatEntryPointTest, StringFormat) {
67    EXPECT_EQ("123", StrFormat("%d", 123));
68    constexpr absl::string_view view("=%d=", 4);
69    EXPECT_EQ("=123=", StrFormat(view, 123));
70  }
71  TEST_F(FormatEntryPointTest, StringFormatV) {
72    std::string hello = "hello";
73    EXPECT_EQ("hello", StrFormat("%v", hello));
74    EXPECT_EQ("123", StrFormat("%v", 123));
75    constexpr absl::string_view view("=%v=", 4);
76    EXPECT_EQ("=123=", StrFormat(view, 123));
77  }
78  TEST_F(FormatEntryPointTest, AppendFormat) {
79    std::string s;
80    std::string& r = StrAppendFormat(&s, "%d", 123);
81    EXPECT_EQ(&s, &r);  
82    EXPECT_EQ("123", r);
83  }
84  TEST_F(FormatEntryPointTest, AppendFormatWithV) {
85    std::string s;
86    std::string& r = StrAppendFormat(&s, "%v", 123);
87    EXPECT_EQ(&s, &r);  
88    EXPECT_EQ("123", r);
89  }
90  TEST_F(FormatEntryPointTest, AppendFormatFail) {
91    std::string s = "orig";
92    UntypedFormatSpec format(" more %d");
93    FormatArgImpl arg("not an int");
94    EXPECT_EQ("orig",
95              str_format_internal::AppendPack(
96                  &s, str_format_internal::UntypedFormatSpecImpl::Extract(format),
97                  {&arg, 1}));
98  }
99  TEST_F(FormatEntryPointTest, AppendFormatFailWithV) {
100    std::string s = "orig";
101    UntypedFormatSpec format(" more %v");
102    FormatArgImpl arg("not an int");
103    EXPECT_EQ("orig",
104              str_format_internal::AppendPack(
105                  &s, str_format_internal::UntypedFormatSpecImpl::Extract(format),
106                  {&arg, 1}));
107  }
108  TEST_F(FormatEntryPointTest, ManyArgs) {
109    EXPECT_EQ(
110        "60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 "
111        "36 35 34 33 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 "
112        "12 11 10 9 8 7 6 5 4 3 2 1",
113        StrFormat("%60$d %59$d %58$d %57$d %56$d %55$d %54$d %53$d %52$d %51$d "
114                  "%50$d %49$d %48$d %47$d %46$d %45$d %44$d %43$d %42$d %41$d "
115                  "%40$d %39$d %38$d %37$d %36$d %35$d %34$d %33$d %32$d %31$d "
116                  "%30$d %29$d %28$d %27$d %26$d %25$d %24$d %23$d %22$d %21$d "
117                  "%20$d %19$d %18$d %17$d %16$d %15$d %14$d %13$d %12$d %11$d "
118                  "%10$d %9$d %8$d %7$d %6$d %5$d %4$d %3$d %2$d %1$d",
119                  1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,
120                  19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34,
121                  35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50,
122                  51, 52, 53, 54, 55, 56, 57, 58, 59, 60));
123  }
124  TEST_F(FormatEntryPointTest, Preparsed) {
125    ParsedFormat<'d'> pc("%d");
126    EXPECT_EQ("123", StrFormat(pc, 123));
127    EXPECT_EQ("123", StrFormat(ParsedFormat<'d'>("%d"), 123));
128    constexpr absl::string_view view("=%d=", 4);
129    EXPECT_EQ("=123=", StrFormat(ParsedFormat<'d'>(view), 123));
130  }
131  TEST_F(FormatEntryPointTest, PreparsedWithV) {
132    ParsedFormat<'v'> pc("%v");
133    EXPECT_EQ("123", StrFormat(pc, 123));
134    EXPECT_EQ("123", StrFormat(ParsedFormat<'v'>("%v"), 123));
135    constexpr absl::string_view view("=%v=", 4);
136    EXPECT_EQ("=123=", StrFormat(ParsedFormat<'v'>(view), 123));
137  }
138  TEST_F(FormatEntryPointTest, FormatCountCapture) {
139    int n = 0;
140    EXPECT_EQ("", StrFormat("%n", FormatCountCapture(&n)));
141    EXPECT_EQ(0, n);
142    EXPECT_EQ("123", StrFormat("%d%n", 123, FormatCountCapture(&n)));
143    EXPECT_EQ(3, n);
144  }
145  TEST_F(FormatEntryPointTest, FormatCountCaptureWithV) {
146    int n = 0;
147    EXPECT_EQ("", StrFormat("%n", FormatCountCapture(&n)));
148    EXPECT_EQ(0, n);
149    EXPECT_EQ("123", StrFormat("%v%n", 123, FormatCountCapture(&n)));
150    EXPECT_EQ(3, n);
151  }
152  TEST_F(FormatEntryPointTest, FormatCountCaptureWrongType) {
153    int n = 0;
154    UntypedFormatSpec format("%d%n");
155    int i = 123, *ip = &n;
156    FormatArgImpl args[2] = {FormatArgImpl(i), FormatArgImpl(ip)};
157    EXPECT_EQ("", str_format_internal::FormatPack(
158                      str_format_internal::UntypedFormatSpecImpl::Extract(format),
159                      absl::MakeSpan(args)));
160  }
161  TEST_F(FormatEntryPointTest, FormatCountCaptureWrongTypeWithV) {
162    int n = 0;
163    UntypedFormatSpec format("%v%n");
164    int i = 123, *ip = &n;
165    FormatArgImpl args[2] = {FormatArgImpl(i), FormatArgImpl(ip)};
166    EXPECT_EQ("", str_format_internal::FormatPack(
167                      str_format_internal::UntypedFormatSpecImpl::Extract(format),
168                      absl::MakeSpan(args)));
169  }
170  TEST_F(FormatEntryPointTest, FormatCountCaptureMultiple) {
171    int n1 = 0;
172    int n2 = 0;
173    EXPECT_EQ("    1         2",
174              StrFormat("%5d%n%10d%n", 1, FormatCountCapture(&n1), 2,
175                        FormatCountCapture(&n2)));
176    EXPECT_EQ(5, n1);
177    EXPECT_EQ(15, n2);
178  }
179  TEST_F(FormatEntryPointTest, FormatCountCaptureExample) {
180    int n;
181    std::string s;
182    StrAppendFormat(&s, "%s: %n%s\n", "(1,1)", FormatCountCapture(&n), "(1,2)");
183    StrAppendFormat(&s, "%*s%s\n", n, "", "(2,2)");
184    EXPECT_EQ(7, n);
185    EXPECT_EQ(
186        "(1,1): (1,2)\n"
187        "       (2,2)\n",
188        s);
189  }
190  TEST_F(FormatEntryPointTest, FormatCountCaptureExampleWithV) {
191    int n;
192    std::string s;
193    std::string a1 = "(1,1)";
194    std::string a2 = "(1,2)";
195    std::string a3 = "(2,2)";
196    StrAppendFormat(&s, "%v: %n%v\n", a1, FormatCountCapture(&n), a2);
197    StrAppendFormat(&s, "%*s%v\n", n, "", a3);
198    EXPECT_EQ(7, n);
199    EXPECT_EQ(
200        "(1,1): (1,2)\n"
201        "       (2,2)\n",
202        s);
203  }
204  TEST_F(FormatEntryPointTest, Stream) {
205    const std::string formats[] = {
206      "",
207      "a",
208      "%80d",
209      "%d %u %c %s %f %g",
210  #if !defined(_MSC_VER) && !defined(__ANDROID__) && !defined(__native_client__)
211      "complicated multipart %% %1$d format %1$080d",
212  #endif  
213    };
214    std::string buf(4096, '\0');
215    for (const auto& fmt : formats) {
216      const auto parsed =
217          ParsedFormat<'d', 'u', 'c', 's', 'f', 'g'>::NewAllowIgnored(fmt);
218      std::ostringstream oss;
219      oss << StreamFormat(*parsed, 123, 3, 49, "multistreaming!!!", 1.01, 1.01);
220      int fmt_result = snprintf(&*buf.begin(), buf.size(), fmt.c_str(),  
221                                123, 3, 49, "multistreaming!!!", 1.01, 1.01);
222      ASSERT_TRUE(oss) << fmt;
223      ASSERT_TRUE(fmt_result >= 0 && static_cast<size_t>(fmt_result) < buf.size())
224          << fmt_result;
225      EXPECT_EQ(buf.c_str(), oss.str());
226    }
227  }
228  TEST_F(FormatEntryPointTest, StreamWithV) {
229    const std::string formats[] = {
230        "",
231        "a",
232        "%v %u %c %v %f %v",
233    };
234    const std::string formats_for_buf[] = {
235        "",
236        "a",
237        "%d %u %c %s %f %g",
238    };
239    std::string buf(4096, '\0');
240    for (auto i = 0; i < ABSL_ARRAYSIZE(formats); ++i) {
241      const auto parsed =
242          ParsedFormat<'v', 'u', 'c', 'v', 'f', 'v'>::NewAllowIgnored(formats[i]);
243      std::ostringstream oss;
244      oss << StreamFormat(*parsed, 123, 3, 49,
245                          absl::string_view("multistreaming!!!"), 1.01, 1.01);
246      int fmt_result =
247          snprintf(&*buf.begin(), buf.size(), formats_for_buf[i].c_str(),  
248                   123, 3, 49, "multistreaming!!!", 1.01, 1.01);
249      ASSERT_TRUE(oss) << formats[i];
250      ASSERT_TRUE(fmt_result >= 0 && static_cast<size_t>(fmt_result) < buf.size())
251          << fmt_result;
252      EXPECT_EQ(buf.c_str(), oss.str());
253    }
254  }
255  TEST_F(FormatEntryPointTest, StreamOk) {
256    std::ostringstream oss;
257    oss << StreamFormat("hello %d", 123);
258    EXPECT_EQ("hello 123", oss.str());
259    EXPECT_TRUE(oss.good());
260  }
261  TEST_F(FormatEntryPointTest, StreamOkWithV) {
262    std::ostringstream oss;
263    oss << StreamFormat("hello %v", 123);
264    EXPECT_EQ("hello 123", oss.str());
265    EXPECT_TRUE(oss.good());
266  }
267  TEST_F(FormatEntryPointTest, StreamFail) {
268    std::ostringstream oss;
269    UntypedFormatSpec format("hello %d");
270    FormatArgImpl arg("non-numeric");
271    oss << str_format_internal::Streamable(
272        str_format_internal::UntypedFormatSpecImpl::Extract(format), {&arg, 1});
273    EXPECT_EQ("hello ", oss.str());  
274    EXPECT_TRUE(oss.fail());
275  }
276  TEST_F(FormatEntryPointTest, StreamFailWithV) {
277    std::ostringstream oss;
278    UntypedFormatSpec format("hello %v");
279    FormatArgImpl arg("non-numeric");
280    oss << str_format_internal::Streamable(
281        str_format_internal::UntypedFormatSpecImpl::Extract(format), {&arg, 1});
282    EXPECT_EQ("hello ", oss.str());  
283    EXPECT_TRUE(oss.fail());
284  }
285  std::string WithSnprintf(const char* fmt, ...) {
286    std::string buf;
287    buf.resize(128);
288    va_list va;
289    va_start(va, fmt);
290    int r = vsnprintf(&*buf.begin(), buf.size(), fmt, va);
291    va_end(va);
292    EXPECT_GE(r, 0);
293    EXPECT_LT(r, buf.size());
294    buf.resize(r);
295    return buf;
296  }
297  TEST_F(FormatEntryPointTest, FloatPrecisionArg) {
298    EXPECT_EQ("0.1", StrFormat("%.1f", 0.1));
299    EXPECT_EQ("0.1", WithSnprintf("%.1f", 0.1));
300    EXPECT_EQ("  0.1", StrFormat("%*.1f", 5, 0.1));
301    EXPECT_EQ("  0.1", WithSnprintf("%*.1f", 5, 0.1));
302    EXPECT_EQ("0.1", StrFormat("%.*f", 1, 0.1));
303    EXPECT_EQ("0.1", WithSnprintf("%.*f", 1, 0.1));
304    EXPECT_EQ("  0.1", StrFormat("%*.*f", 5, 1, 0.1));
305    EXPECT_EQ("  0.1", WithSnprintf("%*.*f", 5, 1, 0.1));
306  }
307  namespace streamed_test {
308  struct X {};
309  std::ostream& operator<<(std::ostream& os, const X&) {
310    return os << "X";
311  }
312  }  
313  TEST_F(FormatEntryPointTest, FormatStreamed) {
314    EXPECT_EQ("123", StrFormat("%s", FormatStreamed(123)));
315    EXPECT_EQ("  123", StrFormat("%5s", FormatStreamed(123)));
316    EXPECT_EQ("123  ", StrFormat("%-5s", FormatStreamed(123)));
317    EXPECT_EQ("X", StrFormat("%s", FormatStreamed(streamed_test::X())));
318    EXPECT_EQ("123", StrFormat("%s", FormatStreamed(StreamFormat("%d", 123))));
319  }
320  TEST_F(FormatEntryPointTest, FormatStreamedWithV) {
321    EXPECT_EQ("123", StrFormat("%v", FormatStreamed(123)));
322    EXPECT_EQ("X", StrFormat("%v", FormatStreamed(streamed_test::X())));
323    EXPECT_EQ("123", StrFormat("%v", FormatStreamed(StreamFormat("%d", 123))));
324  }
325  class TempFile {
326   public:
327    TempFile() : file_(std::tmpfile()) {}
328    ~TempFile() { std::fclose(file_); }
329    std::FILE* file() const { return file_; }
330    std::string ReadFile() {
331      std::fseek(file_, 0, SEEK_END);
332      int size = std::ftell(file_);
333      EXPECT_GT(size, 0);
334      std::rewind(file_);
335      std::string str(2 * size, ' ');
336      int read_bytes = std::fread(&str[0], 1, str.size(), file_);
337      EXPECT_EQ(read_bytes, size);
338      str.resize(read_bytes);
339      EXPECT_TRUE(std::feof(file_));
340      return str;
341    }
342   private:
343    std::FILE* file_;
344  };
345  TEST_F(FormatEntryPointTest, FPrintF) {
346    TempFile tmp;
347    int result =
348        FPrintF(tmp.file(), "STRING: %s NUMBER: %010d", std::string("ABC"), -19);
349    EXPECT_EQ(result, 30);
350    EXPECT_EQ(tmp.ReadFile(), "STRING: ABC NUMBER: -000000019");
351  }
352  TEST_F(FormatEntryPointTest, FPrintFWithV) {
353    TempFile tmp;
354    int result =
355        FPrintF(tmp.file(), "STRING: %v NUMBER: %010d", std::string("ABC"), -19);
356    EXPECT_EQ(result, 30);
357    EXPECT_EQ(tmp.ReadFile(), "STRING: ABC NUMBER: -000000019");
358  }
359  TEST_F(FormatEntryPointTest, FPrintFError) {
360    errno = 0;
361    int result = FPrintF(stdin, "ABC");
362    EXPECT_LT(result, 0);
363    EXPECT_EQ(errno, EBADF);
364  }
365  #ifdef __GLIBC__
366  TEST_F(FormatEntryPointTest, FprintfTooLarge) {
367    std::FILE* f = std::fopen("/dev/null", "w");
368    int width = 2000000000;
369    errno = 0;
370    int result = FPrintF(f, "%*d %*d", width, 0, width, 0);
371    EXPECT_LT(result, 0);
372    EXPECT_EQ(errno, EFBIG);
373    std::fclose(f);
374  }
375  TEST_F(FormatEntryPointTest, PrintF) {
376    int stdout_tmp = dup(STDOUT_FILENO);
377    TempFile tmp;
378    std::fflush(stdout);
379    dup2(fileno(tmp.file()), STDOUT_FILENO);
380    int result = PrintF("STRING: %s NUMBER: %010d", std::string("ABC"), -19);
381    std::fflush(stdout);
382    dup2(stdout_tmp, STDOUT_FILENO);
383    close(stdout_tmp);
384    EXPECT_EQ(result, 30);
385    EXPECT_EQ(tmp.ReadFile(), "STRING: ABC NUMBER: -000000019");
386  }
387  TEST_F(FormatEntryPointTest, PrintFWithV) {
388    int stdout_tmp = dup(STDOUT_FILENO);
389    TempFile tmp;
390    std::fflush(stdout);
391    dup2(fileno(tmp.file()), STDOUT_FILENO);
392    int result = PrintF("STRING: %v NUMBER: %010d", std::string("ABC"), -19);
393    std::fflush(stdout);
394    dup2(stdout_tmp, STDOUT_FILENO);
395    close(stdout_tmp);
396    EXPECT_EQ(result, 30);
397    EXPECT_EQ(tmp.ReadFile(), "STRING: ABC NUMBER: -000000019");
398  }
399  #endif  
400  TEST_F(FormatEntryPointTest, SNPrintF) {
401    char buffer[16];
402    int result =
403        SNPrintF(buffer, sizeof(buffer), "STRING: %s", std::string("ABC"));
404    EXPECT_EQ(result, 11);
405    EXPECT_EQ(std::string(buffer), "STRING: ABC");
406    result = SNPrintF(buffer, sizeof(buffer), "NUMBER: %d", 123456);
407    EXPECT_EQ(result, 14);
408    EXPECT_EQ(std::string(buffer), "NUMBER: 123456");
409    result = SNPrintF(buffer, sizeof(buffer), "NUMBER: %d", 1234567);
410    EXPECT_EQ(result, 15);
411    EXPECT_EQ(std::string(buffer), "NUMBER: 1234567");
412    result = SNPrintF(buffer, sizeof(buffer), "NUMBER: %d", 12345678);
413    EXPECT_EQ(result, 16);
414    EXPECT_EQ(std::string(buffer), "NUMBER: 1234567");
415    result = SNPrintF(buffer, sizeof(buffer), "NUMBER: %d", 123456789);
416    EXPECT_EQ(result, 17);
417    EXPECT_EQ(std::string(buffer), "NUMBER: 1234567");
418    result = SNPrintF(nullptr, 0, "Just checking the %s of the output.", "size");
419    EXPECT_EQ(result, 37);
420  }
421  TEST_F(FormatEntryPointTest, SNPrintFWithV) {
422    char buffer[16];
423    int result =
424        SNPrintF(buffer, sizeof(buffer), "STRING: %v", std::string("ABC"));
425    EXPECT_EQ(result, 11);
426    EXPECT_EQ(std::string(buffer), "STRING: ABC");
427    result = SNPrintF(buffer, sizeof(buffer), "NUMBER: %v", 123456);
428    EXPECT_EQ(result, 14);
429    EXPECT_EQ(std::string(buffer), "NUMBER: 123456");
430    result = SNPrintF(buffer, sizeof(buffer), "NUMBER: %v", 1234567);
431    EXPECT_EQ(result, 15);
432    EXPECT_EQ(std::string(buffer), "NUMBER: 1234567");
433    result = SNPrintF(buffer, sizeof(buffer), "NUMBER: %v", 12345678);
434    EXPECT_EQ(result, 16);
435    EXPECT_EQ(std::string(buffer), "NUMBER: 1234567");
436    result = SNPrintF(buffer, sizeof(buffer), "NUMBER: %v", 123456789);
437    EXPECT_EQ(result, 17);
438    EXPECT_EQ(std::string(buffer), "NUMBER: 1234567");
439    std::string size = "size";
440    result = SNPrintF(nullptr, 0, "Just checking the %v of the output.", size);
441    EXPECT_EQ(result, 37);
442  }
443  TEST(StrFormat, BehavesAsDocumented) {
444    std::string s = absl::StrFormat("%s, %d!", "Hello", 123);
445    EXPECT_EQ("Hello, 123!", s);
446    std::string hello = "Hello";
447    std::string s2 = absl::StrFormat("%v, %v!", hello, 123);
448    EXPECT_EQ("Hello, 123!", s2);
449    EXPECT_EQ(absl::StrFormat("%1$+3.2Lf", 1.1), "+1.10");
450    EXPECT_EQ(StrFormat("%c", 'a'), "a");
451    EXPECT_EQ(StrFormat("%c", 0x20), " ");
452    EXPECT_EQ(StrFormat("%c", int{'a'}), "a");
453    EXPECT_EQ(StrFormat("%c", long{'a'}), "a");  
454    EXPECT_EQ(StrFormat("%c", uint64_t{'a'}), "a");
455    EXPECT_EQ(StrFormat("%s", "C"), "C");
456    EXPECT_EQ(StrFormat("%v", std::string("C")), "C");
457    EXPECT_EQ(StrFormat("%s", std::string("C++")), "C++");
458    EXPECT_EQ(StrFormat("%v", std::string("C++")), "C++");
459    EXPECT_EQ(StrFormat("%s", string_view("view")), "view");
460    EXPECT_EQ(StrFormat("%v", string_view("view")), "view");
461    EXPECT_EQ(StrFormat("%s", absl::Cord("cord")), "cord");
462    EXPECT_EQ(StrFormat("%v", absl::Cord("cord")), "cord");
463    EXPECT_EQ(StrFormat("%d", char{10}), "10");
464    EXPECT_EQ(StrFormat("%d", int{10}), "10");
465    EXPECT_EQ(StrFormat("%d", long{10}), "10");  
466    EXPECT_EQ(StrFormat("%d", uint64_t{10}), "10");
467    EXPECT_EQ(StrFormat("%v", int{10}), "10");
468    EXPECT_EQ(StrFormat("%v", long{10}), "10");  
469    EXPECT_EQ(StrFormat("%v", uint64_t{10}), "10");
470    EXPECT_EQ(StrFormat("%d", -10), "-10");
471    EXPECT_EQ(StrFormat("%i", -10), "-10");
472    EXPECT_EQ(StrFormat("%v", -10), "-10");
473    EXPECT_EQ(StrFormat("%o", 10), "12");
474    EXPECT_EQ(StrFormat("%u", 10), "10");
475    EXPECT_EQ(StrFormat("%v", 10), "10");
476    EXPECT_EQ(StrFormat("%x", 10), "a");
477    EXPECT_EQ(StrFormat("%X", 10), "A");
478    EXPECT_EQ(StrFormat("%.1f", float{1}), "1.0");
479    EXPECT_EQ(StrFormat("%.1f", double{1}), "1.0");
480    const long double long_double = 1.0;
481    EXPECT_EQ(StrFormat("%.1f", long_double), "1.0");
482    EXPECT_EQ(StrFormat("%.1f", char{1}), "1.0");
483    EXPECT_EQ(StrFormat("%.1f", int{1}), "1.0");
484    EXPECT_EQ(StrFormat("%.1f", long{1}), "1.0");  
485    EXPECT_EQ(StrFormat("%.1f", uint64_t{1}), "1.0");
486    EXPECT_EQ(StrFormat("%f", 123456789), "123456789.000000");
487    EXPECT_EQ(StrFormat("%F", 123456789), "123456789.000000");
488    EXPECT_EQ(StrFormat("%e", .01), "1.000000e-02");
489    EXPECT_EQ(StrFormat("%E", .01), "1.000000E-02");
490    EXPECT_EQ(StrFormat("%g", .01), "0.01");
491    EXPECT_EQ(StrFormat("%g", 1e10), "1e+10");
492    EXPECT_EQ(StrFormat("%G", 1e10), "1E+10");
493    EXPECT_EQ(StrFormat("%v", .01), "0.01");
494    EXPECT_EQ(StrFormat("%v", 1e10), "1e+10");
495  #if !defined(__ANDROID_API__) || __ANDROID_API__ > 21
496    EXPECT_EQ(StrFormat("%.1a", -3.0), "-0x1.8p+1");  
497    EXPECT_EQ(StrFormat("%.1A", -3.0), "-0X1.8P+1");  
498  #endif
499    int64_t value = 0x7ffdeb4;
500    auto ptr_value = static_cast<uintptr_t>(value);
501    const int& something = *reinterpret_cast<const int*>(ptr_value);
502    EXPECT_EQ(StrFormat("%p", &something), StrFormat("0x%x", ptr_value));
503    EXPECT_EQ(StrFormat("%3d", 1), "  1");
504    EXPECT_EQ(StrFormat("%3d", 123456), "123456");
505    EXPECT_EQ(StrFormat("%06.2f", 1.234), "001.23");
506    EXPECT_EQ(StrFormat("%+d", 1), "+1");
507    EXPECT_EQ(StrFormat("% d", 1), " 1");
508    EXPECT_EQ(StrFormat("%-4d", -1), "-1  ");
509    EXPECT_EQ(StrFormat("%#o", 10), "012");
510    EXPECT_EQ(StrFormat("%#x", 15), "0xf");
511    EXPECT_EQ(StrFormat("%04d", 8), "0008");
512    EXPECT_EQ(absl::StrFormat("%2$s, %3$s, %1$s!", "vici", "veni", "vidi"),
513              "veni, vidi, vici!");
514    EXPECT_EQ(StrFormat("%hhd", int{1}), "1");
515    EXPECT_EQ(StrFormat("%hd", int{1}), "1");
516    EXPECT_EQ(StrFormat("%ld", int{1}), "1");
517    EXPECT_EQ(StrFormat("%lld", int{1}), "1");
518    EXPECT_EQ(StrFormat("%Ld", int{1}), "1");
519    EXPECT_EQ(StrFormat("%jd", int{1}), "1");
520    EXPECT_EQ(StrFormat("%zd", int{1}), "1");
521    EXPECT_EQ(StrFormat("%td", int{1}), "1");
522    EXPECT_EQ(StrFormat("%qd", int{1}), "1");
523    EXPECT_EQ(StrFormat("%v", true), "true");
524    EXPECT_EQ(StrFormat("%v", false), "false");
525    EXPECT_EQ(StrFormat("%d", true), "1");
526  }
527  using str_format_internal::ExtendedParsedFormat;
528  using str_format_internal::ParsedFormatBase;
529  struct SummarizeConsumer {
530    std::string* out;
531    explicit SummarizeConsumer(std::string* out) : out(out) {}
532    bool Append(string_view s) {
533      *out += "[" + std::string(s) + "]";
534      return true;
535    }
536    bool ConvertOne(const str_format_internal::UnboundConversion& conv,
537                    string_view s) {
538      *out += "{";
539      *out += std::string(s);
540      *out += ":";
541      *out += std::to_string(conv.arg_position) + "$";
542      if (conv.width.is_from_arg()) {
543        *out += std::to_string(conv.width.get_from_arg()) + "$*";
544      }
545      if (conv.precision.is_from_arg()) {
546        *out += "." + std::to_string(conv.precision.get_from_arg()) + "$*";
547      }
548      *out += str_format_internal::FormatConversionCharToChar(conv.conv);
549      *out += "}";
550      return true;
551    }
552  };
553  std::string SummarizeParsedFormat(const ParsedFormatBase& pc) {
554    std::string out;
555    if (!pc.ProcessFormat(SummarizeConsumer(&out))) out += "!";
556    return out;
557  }
558  using ParsedFormatTest = ::testing::Test;
559  TEST_F(ParsedFormatTest, SimpleChecked) {
560    EXPECT_EQ("[ABC]{d:1$d}[DEF]",
561              SummarizeParsedFormat(ParsedFormat<'d'>("ABC%dDEF")));
562    EXPECT_EQ("{s:1$s}[FFF]{d:2$d}[ZZZ]{f:3$f}",
563              SummarizeParsedFormat(ParsedFormat<'s', 'd', 'f'>("%sFFF%dZZZ%f")));
564    EXPECT_EQ("{s:1$s}[ ]{.*d:3$.2$*d}",
565              SummarizeParsedFormat(ParsedFormat<'s', '*', 'd'>("%s %.*d")));
566  }
567  TEST_F(ParsedFormatTest, SimpleCheckedWithV) {
568    EXPECT_EQ("[ABC]{v:1$v}[DEF]",
569              SummarizeParsedFormat(ParsedFormat<'v'>("ABC%vDEF")));
570    EXPECT_EQ("{v:1$v}[FFF]{v:2$v}[ZZZ]{f:3$f}",
571              SummarizeParsedFormat(ParsedFormat<'v', 'v', 'f'>("%vFFF%vZZZ%f")));
572    EXPECT_EQ("{v:1$v}[ ]{.*d:3$.2$*d}",
573              SummarizeParsedFormat(ParsedFormat<'v', '*', 'd'>("%v %.*d")));
574  }
575  TEST_F(ParsedFormatTest, SimpleUncheckedCorrect) {
576    auto f = ParsedFormat<'d'>::New("ABC%dDEF");
577    ASSERT_TRUE(f);
578    EXPECT_EQ("[ABC]{d:1$d}[DEF]", SummarizeParsedFormat(*f));
579    std::string format = "%sFFF%dZZZ%f";
580    auto f2 = ParsedFormat<'s', 'd', 'f'>::New(format);
581    ASSERT_TRUE(f2);
582    EXPECT_EQ("{s:1$s}[FFF]{d:2$d}[ZZZ]{f:3$f}", SummarizeParsedFormat(*f2));
583    f2 = ParsedFormat<'s', 'd', 'f'>::New("%s %d %f");
584    ASSERT_TRUE(f2);
585    EXPECT_EQ("{s:1$s}[ ]{d:2$d}[ ]{f:3$f}", SummarizeParsedFormat(*f2));
586    auto star = ParsedFormat<'*', 'd'>::New("%*d");
587    ASSERT_TRUE(star);
588    EXPECT_EQ("{*d:2$1$*d}", SummarizeParsedFormat(*star));
589    auto dollar = ParsedFormat<'d', 's'>::New("%2$s %1$d");
590    ASSERT_TRUE(dollar);
591    EXPECT_EQ("{2$s:2$s}[ ]{1$d:1$d}", SummarizeParsedFormat(*dollar));
592    dollar = ParsedFormat<'d', 's'>::New("%2$s %1$d %1$d");
593    ASSERT_TRUE(dollar);
594    EXPECT_EQ("{2$s:2$s}[ ]{1$d:1$d}[ ]{1$d:1$d}",
595              SummarizeParsedFormat(*dollar));
596  }
597  TEST_F(ParsedFormatTest, SimpleUncheckedCorrectWithV) {
598    auto f = ParsedFormat<'v'>::New("ABC%vDEF");
599    ASSERT_TRUE(f);
600    EXPECT_EQ("[ABC]{v:1$v}[DEF]", SummarizeParsedFormat(*f));
601    std::string format = "%vFFF%vZZZ%f";
602    auto f2 = ParsedFormat<'v', 'v', 'f'>::New(format);
603    ASSERT_TRUE(f2);
604    EXPECT_EQ("{v:1$v}[FFF]{v:2$v}[ZZZ]{f:3$f}", SummarizeParsedFormat(*f2));
605    f2 = ParsedFormat<'v', 'v', 'f'>::New("%v %v %f");
606    ASSERT_TRUE(f2);
607    EXPECT_EQ("{v:1$v}[ ]{v:2$v}[ ]{f:3$f}", SummarizeParsedFormat(*f2));
608  }
609  TEST_F(ParsedFormatTest, SimpleUncheckedIgnoredArgs) {
610    EXPECT_FALSE((ParsedFormat<'d', 's'>::New("ABC")));
611    EXPECT_FALSE((ParsedFormat<'d', 's'>::New("%dABC")));
612    EXPECT_FALSE((ParsedFormat<'d', 's'>::New("ABC%2$s")));
613    auto f = ParsedFormat<'d', 's'>::NewAllowIgnored("ABC");
614    ASSERT_TRUE(f);
615    EXPECT_EQ("[ABC]", SummarizeParsedFormat(*f));
616    f = ParsedFormat<'d', 's'>::NewAllowIgnored("%dABC");
617    ASSERT_TRUE(f);
618    EXPECT_EQ("{d:1$d}[ABC]", SummarizeParsedFormat(*f));
619    f = ParsedFormat<'d', 's'>::NewAllowIgnored("ABC%2$s");
620    ASSERT_TRUE(f);
621    EXPECT_EQ("[ABC]{2$s:2$s}", SummarizeParsedFormat(*f));
622  }
623  TEST_F(ParsedFormatTest, SimpleUncheckedIgnoredArgsWithV) {
624    EXPECT_FALSE((ParsedFormat<'v', 'v'>::New("ABC")));
625    EXPECT_FALSE((ParsedFormat<'v', 'v'>::New("%vABC")));
626    EXPECT_FALSE((ParsedFormat<'v', 's'>::New("ABC%2$s")));
627    auto f = ParsedFormat<'v', 'v'>::NewAllowIgnored("ABC");
628    ASSERT_TRUE(f);
629    EXPECT_EQ("[ABC]", SummarizeParsedFormat(*f));
630    f = ParsedFormat<'v', 'v'>::NewAllowIgnored("%vABC");
631    ASSERT_TRUE(f);
632    EXPECT_EQ("{v:1$v}[ABC]", SummarizeParsedFormat(*f));
633  }
634  TEST_F(ParsedFormatTest, SimpleUncheckedUnsupported) {
635    EXPECT_FALSE(ParsedFormat<'d'>::New("%1$d %1$x"));
636    EXPECT_FALSE(ParsedFormat<'x'>::New("%1$d %1$x"));
637  }
638  TEST_F(ParsedFormatTest, SimpleUncheckedIncorrect) {
639    EXPECT_FALSE(ParsedFormat<'d'>::New(""));
640    EXPECT_FALSE(ParsedFormat<'d'>::New("ABC%dDEF%d"));
641    std::string format = "%sFFF%dZZZ%f";
642    EXPECT_FALSE((ParsedFormat<'s', 'd', 'g'>::New(format)));
643  }
644  TEST_F(ParsedFormatTest, SimpleUncheckedIncorrectWithV) {
645    EXPECT_FALSE(ParsedFormat<'v'>::New(""));
646    EXPECT_FALSE(ParsedFormat<'v'>::New("ABC%vDEF%v"));
647    std::string format = "%vFFF%vZZZ%f";
648    EXPECT_FALSE((ParsedFormat<'v', 'v', 'g'>::New(format)));
649  }
650  #if defined(__cpp_nontype_template_parameter_auto)
651  template <auto T>
652  std::true_type IsValidParsedFormatArgTest(ParsedFormat<T>*);
653  template <auto T>
654  std::false_type IsValidParsedFormatArgTest(...);
655  template <auto T>
656  using IsValidParsedFormatArg = decltype(IsValidParsedFormatArgTest<T>(nullptr));
657  TEST_F(ParsedFormatTest, OnlyValidTypesAllowed) {
658    ASSERT_TRUE(IsValidParsedFormatArg<'c'>::value);
659    ASSERT_TRUE(IsValidParsedFormatArg<FormatConversionCharSet::d>::value);
660    ASSERT_TRUE(IsValidParsedFormatArg<absl::FormatConversionCharSet::d |
661                                       absl::FormatConversionCharSet::x>::value);
662    ASSERT_TRUE(
663        IsValidParsedFormatArg<absl::FormatConversionCharSet::kIntegral>::value);
664    ASSERT_FALSE(IsValidParsedFormatArg<'x' | 'd'>::value);
665    ASSERT_FALSE(IsValidParsedFormatArg<absl::FormatConversionChar::d>::value);
666  }
667  TEST_F(ParsedFormatTest, ExtendedTyping) {
668    EXPECT_FALSE(ParsedFormat<FormatConversionCharSet::d>::New(""));
669    ASSERT_TRUE(ParsedFormat<absl::FormatConversionCharSet::d>::New("%d"));
670    auto v1 = ParsedFormat<'d', absl::FormatConversionCharSet::s>::New("%d%s");
671    ASSERT_TRUE(v1);
672    auto v2 = ParsedFormat<absl::FormatConversionCharSet::d, 's'>::New("%d%s");
673    ASSERT_TRUE(v2);
674    auto v3 = ParsedFormat<absl::FormatConversionCharSet::d |
675                               absl::FormatConversionCharSet::s,
676                           's'>::New("%d%s");
677    ASSERT_TRUE(v3);
678    auto v4 = ParsedFormat<absl::FormatConversionCharSet::d |
679                               absl::FormatConversionCharSet::s,
680                           's'>::New("%s%s");
681    ASSERT_TRUE(v4);
682  }
683  TEST_F(ParsedFormatTest, ExtendedTypingWithV) {
684    EXPECT_FALSE(ParsedFormat<FormatConversionCharSet::v>::New(""));
685    ASSERT_TRUE(ParsedFormat<absl::FormatConversionCharSet::v>::New("%v"));
686    auto v1 = ParsedFormat<'v', absl::FormatConversionCharSet::v>::New("%v%v");
687    ASSERT_TRUE(v1);
688    auto v2 = ParsedFormat<absl::FormatConversionCharSet::v, 'v'>::New("%v%v");
689    ASSERT_TRUE(v2);
690    auto v3 = ParsedFormat<absl::FormatConversionCharSet::v |
691                               absl::FormatConversionCharSet::v,
692                           'v'>::New("%v%v");
693    ASSERT_TRUE(v3);
694    auto v4 = ParsedFormat<absl::FormatConversionCharSet::v |
695                               absl::FormatConversionCharSet::v,
696                           'v'>::New("%v%v");
697    ASSERT_TRUE(v4);
698  }
699  #endif
700  TEST_F(ParsedFormatTest, UncheckedCorrect) {
701    auto f =
702        ExtendedParsedFormat<absl::FormatConversionCharSet::d>::New("ABC%dDEF");
703    ASSERT_TRUE(f);
704    EXPECT_EQ("[ABC]{d:1$d}[DEF]", SummarizeParsedFormat(*f));
705    std::string format = "%sFFF%dZZZ%f";
706    auto f2 = ExtendedParsedFormat<
707        absl::FormatConversionCharSet::kString, absl::FormatConversionCharSet::d,
708        absl::FormatConversionCharSet::kFloating>::New(format);
709    ASSERT_TRUE(f2);
710    EXPECT_EQ("{s:1$s}[FFF]{d:2$d}[ZZZ]{f:3$f}", SummarizeParsedFormat(*f2));
711    f2 = ExtendedParsedFormat<
712        absl::FormatConversionCharSet::kString, absl::FormatConversionCharSet::d,
713        absl::FormatConversionCharSet::kFloating>::New("%s %d %f");
714    ASSERT_TRUE(f2);
715    EXPECT_EQ("{s:1$s}[ ]{d:2$d}[ ]{f:3$f}", SummarizeParsedFormat(*f2));
716    auto star =
717        ExtendedParsedFormat<absl::FormatConversionCharSet::kStar,
718                             absl::FormatConversionCharSet::d>::New("%*d");
719    ASSERT_TRUE(star);
720    EXPECT_EQ("{*d:2$1$*d}", SummarizeParsedFormat(*star));
721    auto dollar =
722        ExtendedParsedFormat<absl::FormatConversionCharSet::d,
723                             absl::FormatConversionCharSet::s>::New("%2$s %1$d");
724    ASSERT_TRUE(dollar);
725    EXPECT_EQ("{2$s:2$s}[ ]{1$d:1$d}", SummarizeParsedFormat(*dollar));
726    dollar = ExtendedParsedFormat<
727        absl::FormatConversionCharSet::d,
728        absl::FormatConversionCharSet::s>::New("%2$s %1$d %1$d");
729    ASSERT_TRUE(dollar);
730    EXPECT_EQ("{2$s:2$s}[ ]{1$d:1$d}[ ]{1$d:1$d}",
731              SummarizeParsedFormat(*dollar));
732  }
733  TEST_F(ParsedFormatTest, UncheckedCorrectWithV) {
734    auto f =
735        ExtendedParsedFormat<absl::FormatConversionCharSet::v>::New("ABC%vDEF");
736    ASSERT_TRUE(f);
737    EXPECT_EQ("[ABC]{v:1$v}[DEF]", SummarizeParsedFormat(*f));
738    std::string format = "%vFFF%vZZZ%f";
739    auto f2 = ExtendedParsedFormat<
740        absl::FormatConversionCharSet::v, absl::FormatConversionCharSet::v,
741        absl::FormatConversionCharSet::kFloating>::New(format);
742    ASSERT_TRUE(f2);
743    EXPECT_EQ("{v:1$v}[FFF]{v:2$v}[ZZZ]{f:3$f}", SummarizeParsedFormat(*f2));
744    f2 = ExtendedParsedFormat<
745        absl::FormatConversionCharSet::v, absl::FormatConversionCharSet::v,
746        absl::FormatConversionCharSet::kFloating>::New("%v %v %f");
747    ASSERT_TRUE(f2);
748    EXPECT_EQ("{v:1$v}[ ]{v:2$v}[ ]{f:3$f}", SummarizeParsedFormat(*f2));
749  }
750  TEST_F(ParsedFormatTest, UncheckedIgnoredArgs) {
751    EXPECT_FALSE(
752        (ExtendedParsedFormat<absl::FormatConversionCharSet::d,
753                              absl::FormatConversionCharSet::s>::New("ABC")));
754    EXPECT_FALSE(
755        (ExtendedParsedFormat<absl::FormatConversionCharSet::d,
756                              absl::FormatConversionCharSet::s>::New("%dABC")));
757    EXPECT_FALSE(
758        (ExtendedParsedFormat<absl::FormatConversionCharSet::d,
759                              absl::FormatConversionCharSet::s>::New("ABC%2$s")));
760    auto f = ExtendedParsedFormat<
761        absl::FormatConversionCharSet::d,
762        absl::FormatConversionCharSet::s>::NewAllowIgnored("ABC");
763    ASSERT_TRUE(f);
764    EXPECT_EQ("[ABC]", SummarizeParsedFormat(*f));
765    f = ExtendedParsedFormat<
766        absl::FormatConversionCharSet::d,
767        absl::FormatConversionCharSet::s>::NewAllowIgnored("%dABC");
768    ASSERT_TRUE(f);
769    EXPECT_EQ("{d:1$d}[ABC]", SummarizeParsedFormat(*f));
770    f = ExtendedParsedFormat<
771        absl::FormatConversionCharSet::d,
772        absl::FormatConversionCharSet::s>::NewAllowIgnored("ABC%2$s");
773    ASSERT_TRUE(f);
774    EXPECT_EQ("[ABC]{2$s:2$s}", SummarizeParsedFormat(*f));
775  }
776  TEST_F(ParsedFormatTest, UncheckedIgnoredArgsWithV) {
777    EXPECT_FALSE(
778        (ExtendedParsedFormat<absl::FormatConversionCharSet::v,
779                              absl::FormatConversionCharSet::v>::New("ABC")));
780    EXPECT_FALSE(
781        (ExtendedParsedFormat<absl::FormatConversionCharSet::v,
782                              absl::FormatConversionCharSet::v>::New("%vABC")));
783    EXPECT_FALSE((ExtendedParsedFormat<absl::FormatConversionCharSet::v,
784                                       absl::FormatConversionCharSet::s>::
785                      New("ABC%2$s")));
786    auto f = ExtendedParsedFormat<
787        absl::FormatConversionCharSet::v,
788        absl::FormatConversionCharSet::v>::NewAllowIgnored("ABC");
789    ASSERT_TRUE(f);
790    EXPECT_EQ("[ABC]", SummarizeParsedFormat(*f));
791    f = ExtendedParsedFormat<
792        absl::FormatConversionCharSet::v,
793        absl::FormatConversionCharSet::v>::NewAllowIgnored("%vABC");
794    ASSERT_TRUE(f);
795    EXPECT_EQ("{v:1$v}[ABC]", SummarizeParsedFormat(*f));
796  }
797  TEST_F(ParsedFormatTest, UncheckedMultipleTypes) {
798    auto dx =
799        ExtendedParsedFormat<absl::FormatConversionCharSet::d |
800                             absl::FormatConversionCharSet::x>::New("%1$d %1$x");
801    EXPECT_TRUE(dx);
802    EXPECT_EQ("{1$d:1$d}[ ]{1$x:1$x}", SummarizeParsedFormat(*dx));
803    dx = ExtendedParsedFormat<absl::FormatConversionCharSet::d |
804                              absl::FormatConversionCharSet::x>::New("%1$d");
805    EXPECT_TRUE(dx);
806    EXPECT_EQ("{1$d:1$d}", SummarizeParsedFormat(*dx));
807  }
808  TEST_F(ParsedFormatTest, UncheckedIncorrect) {
809    EXPECT_FALSE(ExtendedParsedFormat<absl::FormatConversionCharSet::d>::New(""));
810    EXPECT_FALSE(ExtendedParsedFormat<absl::FormatConversionCharSet::d>::New(
811        "ABC%dDEF%d"));
812    std::string format = "%sFFF%dZZZ%f";
813    EXPECT_FALSE(
814        (ExtendedParsedFormat<absl::FormatConversionCharSet::s,
815                              absl::FormatConversionCharSet::d,
816                              absl::FormatConversionCharSet::g>::New(format)));
817  }
818  TEST_F(ParsedFormatTest, UncheckedIncorrectWithV) {
819    EXPECT_FALSE(ExtendedParsedFormat<absl::FormatConversionCharSet::v>::New(""));
820    EXPECT_FALSE(ExtendedParsedFormat<absl::FormatConversionCharSet::v>::New(
821        "ABC%vDEF%v"));
822    std::string format = "%vFFF%vZZZ%f";
823    EXPECT_FALSE(
824        (ExtendedParsedFormat<absl::FormatConversionCharSet::v,
825                              absl::FormatConversionCharSet::g>::New(format)));
826  }
827  TEST_F(ParsedFormatTest, RegressionMixPositional) {
828    EXPECT_FALSE(
829        (ExtendedParsedFormat<absl::FormatConversionCharSet::d,
830                              absl::FormatConversionCharSet::o>::New("%1$d %o")));
831  }
832  TEST_F(ParsedFormatTest, DisallowModifiersWithV) {
833    auto f = ParsedFormat<'v'>::New("ABC%80vDEF");
834    EXPECT_EQ(f, nullptr);
835    f = ParsedFormat<'v'>::New("ABC%0vDEF");
836    EXPECT_EQ(f, nullptr);
837    f = ParsedFormat<'v'>::New("ABC%.1vDEF");
838    EXPECT_EQ(f, nullptr);
839  }
840  using FormatWrapperTest = ::testing::Test;
841  template <typename... Args>
842  std::string WrappedFormat(const absl::FormatSpec<Args...>& format,
843                            const Args&... args) {
844    return StrFormat(format, args...);
845  }
846  TEST_F(FormatWrapperTest, ConstexprStringFormat) {
847    EXPECT_EQ(WrappedFormat("%s there", "hello"), "hello there");
848  }
849  TEST_F(FormatWrapperTest, ConstexprStringFormatWithV) {
850    std::string hello = "hello";
851    EXPECT_EQ(WrappedFormat("%v there", hello), "hello there");
852  }
853  TEST_F(FormatWrapperTest, ParsedFormat) {
854    ParsedFormat<'s'> format("%s there");
855    EXPECT_EQ(WrappedFormat(format, "hello"), "hello there");
856  }
857  TEST_F(FormatWrapperTest, ParsedFormatWithV) {
858    std::string hello = "hello";
859    ParsedFormat<'v'> format("%v there");
860    EXPECT_EQ(WrappedFormat(format, hello), "hello there");
861  }
862  }  
863  ABSL_NAMESPACE_END
864  }  
865  namespace {
866  using FormatExtensionTest = ::testing::Test;
867  struct Point {
868    friend absl::FormatConvertResult<absl::FormatConversionCharSet::kString |
869                                     absl::FormatConversionCharSet::kIntegral |
870                                     absl::FormatConversionCharSet::v>
871    AbslFormatConvert(const Point& p, const absl::FormatConversionSpec& spec,
872                      absl::FormatSink* s) {
873      if (spec.conversion_char() == absl::FormatConversionChar::s) {
874        s->Append(absl::StrCat("x=", p.x, " y=", p.y));
875      } else {
876        s->Append(absl::StrCat(p.x, ",", p.y));
877      }
878      return {true};
879    }
880    int x = 10;
881    int y = 20;
882  };
883  TEST_F(FormatExtensionTest, AbslFormatConvertExample) {
884    Point p;
885    EXPECT_EQ(absl::StrFormat("a %s z", p), "a x=10 y=20 z");
886    EXPECT_EQ(absl::StrFormat("a %d z", p), "a 10,20 z");
887    EXPECT_EQ(absl::StrFormat("a %v z", p), "a 10,20 z");
888    std::string actual;
889    absl::UntypedFormatSpec f1("%f");
890    EXPECT_FALSE(absl::FormatUntyped(&actual, f1, {absl::FormatArg(p)}));
891  }
892  struct PointStringify {
893    template <typename FormatSink>
894    friend void AbslStringify(FormatSink& sink, const PointStringify& p) {
895      sink.Append(absl::StrCat("(", p.x, ", ", p.y, ")"));
896    }
897    double x = 10.0;
898    double y = 20.0;
899  };
900  TEST_F(FormatExtensionTest, AbslStringifyExample) {
901    PointStringify p;
902    EXPECT_EQ(absl::StrFormat("a %v z", p), "a (10, 20) z");
903  }
904  struct PointStringifyUsingFormat {
905    template <typename FormatSink>
906    friend void AbslStringify(FormatSink& sink,
907                              const PointStringifyUsingFormat& p) {
908      absl::Format(&sink, "(%g, %g)", p.x, p.y);
909    }
<span onclick='openModal()' class='match'>910    double x = 10.0;
911    double y = 20.0;
912  };
913  TEST_F(FormatExtensionTest, AbslStringifyExampleUsingFormat) {
914    PointStringifyUsingFormat p;
915    EXPECT_EQ(absl::StrFormat("a %v z", p), "a (10, 20) z");
</span>916  }
917  enum class EnumClassWithStringify { Many = 0, Choices = 1 };
918  template <typename Sink>
919  void AbslStringify(Sink& sink, EnumClassWithStringify e) {
920    absl::Format(&sink, "%s",
921                 e == EnumClassWithStringify::Many ? "Many" : "Choices");
922  }
923  enum EnumWithStringify { Many, Choices };
924  template <typename Sink>
925  void AbslStringify(Sink& sink, EnumWithStringify e) {
926    absl::Format(&sink, "%s", e == EnumWithStringify::Many ? "Many" : "Choices");
927  }
928  TEST_F(FormatExtensionTest, AbslStringifyWithEnumWithV) {
929    const auto e_class = EnumClassWithStringify::Choices;
930    EXPECT_EQ(absl::StrFormat("My choice is %v", e_class),
931              "My choice is Choices");
932    const auto e = EnumWithStringify::Choices;
933    EXPECT_EQ(absl::StrFormat("My choice is %v", e), "My choice is Choices");
934  }
935  TEST_F(FormatExtensionTest, AbslStringifyEnumWithD) {
936    const auto e_class = EnumClassWithStringify::Many;
937    EXPECT_EQ(absl::StrFormat("My choice is %d", e_class), "My choice is 0");
938    const auto e = EnumWithStringify::Choices;
939    EXPECT_EQ(absl::StrFormat("My choice is %d", e), "My choice is 1");
940  }
941  enum class EnumWithLargerValue { x = 32 };
942  template <typename Sink>
943  void AbslStringify(Sink& sink, EnumWithLargerValue e) {
944    absl::Format(&sink, "%s", "Many");
945  }
946  TEST_F(FormatExtensionTest, AbslStringifyEnumOtherSpecifiers) {
947    const auto e = EnumWithLargerValue::x;
948    EXPECT_EQ(absl::StrFormat("My choice is %g", e), "My choice is 32");
949    EXPECT_EQ(absl::StrFormat("My choice is %x", e), "My choice is 20");
950  }
951  }  
952  std::string CodegenAbslStrFormatInt(int i) {  
953    return absl::StrFormat("%d", i);
954  }
955  std::string CodegenAbslStrFormatIntStringInt64(int i, const std::string& s,
956                                                 int64_t i64) {  
957    return absl::StrFormat("%d %s %d", i, s, i64);
958  }
959  void CodegenAbslStrAppendFormatInt(std::string* out, int i) {  
960    absl::StrAppendFormat(out, "%d", i);
961  }
962  void CodegenAbslStrAppendFormatIntStringInt64(std::string* out, int i,
963                                                const std::string& s,
964                                                int64_t i64) {  
965    absl::StrAppendFormat(out, "%d %s %d", i, s, i64);
966  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-str_format_test.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-str_format_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>897    double x = 10.0;
898    double y = 20.0;
899  };
900  TEST_F(FormatExtensionTest, AbslStringifyExample) {
901    PointStringify p;
902    EXPECT_EQ(absl::StrFormat("a %v z", p), "a (10, 20) z");
</pre></code></div>
                <div class="column column_space"><pre><code>910    double x = 10.0;
911    double y = 20.0;
912  };
913  TEST_F(FormatExtensionTest, AbslStringifyExampleUsingFormat) {
914    PointStringifyUsingFormat p;
915    EXPECT_EQ(absl::StrFormat("a %v z", p), "a (10, 20) z");
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    