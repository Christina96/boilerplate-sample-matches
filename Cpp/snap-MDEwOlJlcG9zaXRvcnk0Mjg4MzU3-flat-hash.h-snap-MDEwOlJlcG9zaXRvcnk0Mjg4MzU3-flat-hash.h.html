
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 15, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-hash.h</h3>
            <pre><code>1  #include "bd.h"
2  #include <stdio.h>
3  #pragma pack(push, 1) 
4  template <class TKey, class TDat>
5  class THashKeyDat{
6  public:
7    TInt Next;
8    TInt HashCd;
9    TKey Key;
10    TDat Dat;
11  public:
12    THashKeyDat():
13      Next(-1), HashCd(-1), Key(), Dat(){}
14    THashKeyDat(const int& _Next, const int& _HashCd, const TKey& _Key):
15      Next(_Next), HashCd(_HashCd), Key(_Key), Dat(){}
16    explicit THashKeyDat(TSIn& SIn):
17      Next(SIn), HashCd(SIn), Key(SIn), Dat(SIn){}
18    void Save(TSOut& SOut) const {
19      Next.Save(SOut); HashCd.Save(SOut); Key.Save(SOut); Dat.Save(SOut);}
20    void LoadXml(const PXmlTok& XmlTok, const TStr& Nm="");
21    void SaveXml(TSOut& SOut, const TStr& Nm) const;
22    template<typename TDatFunctor>
23    void LoadShM(TShMIn& ShMIn, TDatFunctor LoadDatFromShared) {
24      Next = TInt(ShMIn);
25      HashCd = TInt(ShMIn);
26      TKey K(ShMIn);
27      Key = K;
28      LoadDatFromShared(&Dat, ShMIn);
29    }
30    bool operator==(const THashKeyDat& HashKeyDat) const {
31      if (this==&HashKeyDat || (HashCd==HashKeyDat.HashCd
32        && Key==HashKeyDat.Key && Dat==HashKeyDat.Dat)){return true;}
33      return false;}
34    THashKeyDat& operator=(const THashKeyDat& HashKeyDat){
35      if (this!=&HashKeyDat){
36        Next=HashKeyDat.Next; HashCd=HashKeyDat.HashCd;
37        Key=HashKeyDat.Key; Dat=HashKeyDat.Dat;}
38      return *this;}
39  };
40  #pragma pack(pop)
41  template<class TKey, class TDat>
42  class THashKeyDatI{
43  public:
44    typedef THashKeyDat<TKey, TDat> THKeyDat;
45  private:
46    THKeyDat* KeyDatI;
47    THKeyDat* EndI;
48  public:
49    THashKeyDatI(): KeyDatI(NULL), EndI(NULL){}
50    THashKeyDatI(const THashKeyDatI& _HashKeyDatI):
51      KeyDatI(_HashKeyDatI.KeyDatI), EndI(_HashKeyDatI.EndI){}
52    THashKeyDatI(const THKeyDat* _KeyDatI, const THKeyDat* _EndI):
53      KeyDatI((THKeyDat*)_KeyDatI), EndI((THKeyDat*)_EndI){}
54    THashKeyDatI& operator=(const THashKeyDatI& HashKeyDatI){
55      KeyDatI=HashKeyDatI.KeyDatI; EndI=HashKeyDatI.EndI; return *this;}
56    bool operator==(const THashKeyDatI& HashKeyDatI) const {
57      return KeyDatI==HashKeyDatI.KeyDatI;}
58    bool operator<(const THashKeyDatI& HashKeyDatI) const {
59      return KeyDatI<HashKeyDatI.KeyDatI;}
60    THashKeyDatI& operator++(int){ KeyDatI++; while (KeyDatI < EndI && KeyDatI->HashCd==-1) { KeyDatI++; } return *this; }
61    THashKeyDatI& operator--(int){ do { KeyDatI--; } while (KeyDatI->HashCd==-1); return *this;}
62    THKeyDat& operator*() const { return *KeyDatI; }
63    THKeyDat& operator()() const { return *KeyDatI; }
64    THKeyDat* operator->() const { return KeyDatI; }
65    THashKeyDatI& Next(){ operator++(1); return *this; }
66    bool IsEmpty() const { return KeyDatI == NULL; }
67    bool IsEnd() const { return EndI == KeyDatI; }
68    const TKey& GetKey() const {Assert((KeyDatI!=NULL)&&(KeyDatI->HashCd!=-1)); return KeyDatI->Key;}
69    const TDat& GetDat() const {Assert((KeyDatI!=NULL)&&(KeyDatI->HashCd!=-1)); return KeyDatI->Dat;}
70    TDat& GetDat() {Assert((KeyDatI!=NULL)&&(KeyDatI->HashCd!=-1)); return KeyDatI->Dat;}
71  };
72  template<class TKey>
73  class TDefaultHashFunc {
74  public:
75   static inline int GetPrimHashCd(const TKey& Key) { return Key.GetPrimHashCd(); }
76   static inline int GetSecHashCd(const TKey& Key) { return Key.GetSecHashCd(); }
77  };
78  template<class TKey, class TDat, class THashFunc = TDefaultHashFunc<TKey> >
79  class THash{
80  public:
81    enum {HashPrimes=32};
82    static const unsigned int HashPrimeT[HashPrimes];
83  public:
84    typedef THashKeyDatI<TKey, TDat> TIter;
85  private:
86    typedef THashKeyDat<TKey, TDat> THKeyDat;
87    typedef TPair<TKey, TDat> TKeyDatP;
88    TIntV PortV;
89    TVec<THKeyDat> KeyDatV;
90    TBool AutoSizeP;
91    TInt FFreeKeyId, FreeKeys;
92  private:
93    class THashKeyDatCmp {
94    public:
95      const THash<TKey, TDat, THashFunc>& Hash;
96      bool CmpKey, Asc;
97      THashKeyDatCmp(THash<TKey, TDat, THashFunc>& _Hash, const bool& _CmpKey, const bool& _Asc) :
98        Hash(_Hash), CmpKey(_CmpKey), Asc(_Asc) { }
99      bool operator () (const int& KeyId1, const int& KeyId2) const {
100        if (CmpKey) {
101          if (Asc) { return Hash.GetKey(KeyId1) < Hash.GetKey(KeyId2); }
102          else { return Hash.GetKey(KeyId2) < Hash.GetKey(KeyId1); } }
103        else {
104          if (Asc) { return Hash[KeyId1] < Hash[KeyId2]; }
105          else { return Hash[KeyId2] < Hash[KeyId1]; } } }
106    };
107    template<typename TDatInitFn>
108    class TLoadTHKeyDatInitializer {
109    private:
110      TDatInitFn DatInitFn;
111    public:
112      TLoadTHKeyDatInitializer(TDatInitFn Fn) { DatInitFn = Fn;}
113      void operator() (THKeyDat* HKeyDat, TShMIn& ShMIn) { HKeyDat->LoadShM(ShMIn, DatInitFn);}
114    };
115  private:
116    THKeyDat& GetHashKeyDat(const int& KeyId){
117      THKeyDat& KeyDat=KeyDatV[KeyId];
118      Assert(KeyDat.HashCd!=-1); return KeyDat;}
119    const THKeyDat& GetHashKeyDat(const int& KeyId) const {
120      const THKeyDat& KeyDat=KeyDatV[KeyId];
121      Assert(KeyDat.HashCd!=-1); return KeyDat;}
122    uint GetNextPrime(const uint& Val) const;
123    void Resize();
124  public:
125    THash():
126      PortV(), KeyDatV(),
127      AutoSizeP(true), FFreeKeyId(-1), FreeKeys(0){}
128    THash(const THash& Hash):
129      PortV(Hash.PortV), KeyDatV(Hash.KeyDatV), AutoSizeP(Hash.AutoSizeP),
130      FFreeKeyId(Hash.FFreeKeyId), FreeKeys(Hash.FreeKeys){}
131    explicit THash(const int& ExpectVals, const bool& _AutoSizeP=false);
132    explicit THash(TSIn& SIn):
133      PortV(SIn), KeyDatV(SIn),
134      AutoSizeP(SIn), FFreeKeyId(SIn), FreeKeys(SIn){
135      SIn.LoadCs();}
136    void LoadShM(TShMIn& ShMIn) {
137      PortV.LoadShM(ShMIn);
138      KeyDatV.Load(ShMIn);
139      AutoSizeP=TBool(ShMIn);
140      FFreeKeyId=TInt(ShMIn);
141      FreeKeys=TInt(ShMIn);
142      ShMIn.LoadCs();
143    }
144    template <typename TDatInitFn>
145    void LoadShM(TShMIn& ShMIn, TDatInitFn Fn) {
146      TLoadTHKeyDatInitializer<TDatInitFn> HKeyDatFn(Fn);
147      PortV.LoadShM(ShMIn);
148      KeyDatV.LoadShM(ShMIn, HKeyDatFn);
149      AutoSizeP=TBool(ShMIn);
150      FFreeKeyId=TInt(ShMIn);
151      FreeKeys=TInt(ShMIn);
152      ShMIn.LoadCs();
153    }
154    void Load(TSIn& SIn){
155      PortV.Load(SIn); KeyDatV.Load(SIn);
156      AutoSizeP=TBool(SIn); FFreeKeyId=TInt(SIn); FreeKeys=TInt(SIn);
157      SIn.LoadCs();
158    }
159    void Save(TSOut& SOut) const {
160      PortV.Save(SOut); KeyDatV.Save(SOut);
161      AutoSizeP.Save(SOut); FFreeKeyId.Save(SOut); FreeKeys.Save(SOut);
162      SOut.SaveCs();}
163    void LoadXml(const PXmlTok& XmlTok, const TStr& Nm="");
164    void SaveXml(TSOut& SOut, const TStr& Nm);
165    THash& operator=(const THash& Hash){
166      if (this!=&Hash){
167        PortV=Hash.PortV; KeyDatV=Hash.KeyDatV; AutoSizeP=Hash.AutoSizeP;
168        FFreeKeyId=Hash.FFreeKeyId; FreeKeys=Hash.FreeKeys;}
169      return *this;}
170    bool operator==(const THash& Hash) const; 
171    bool operator < (const THash& Hash) const { Fail; return true; }
172    const TDat& operator[](const int& KeyId) const {return GetHashKeyDat(KeyId).Dat;}
173    TDat& operator[](const int& KeyId){return GetHashKeyDat(KeyId).Dat;}
174    TDat& operator()(const TKey& Key){return AddDat(Key);}
175    ::TSize GetMemUsed() const {
176        int64 MemUsed = sizeof(bool)+2*sizeof(int);
177        MemUsed += int64(PortV.Reserved()) * int64(sizeof(TInt));
178        for (int KeyDatN = 0; KeyDatN < KeyDatV.Len(); KeyDatN++) {
179            MemUsed += int64(2 * sizeof(TInt));
180            MemUsed += int64(KeyDatV[KeyDatN].Key.GetMemUsed());
181            MemUsed += int64(KeyDatV[KeyDatN].Dat.GetMemUsed());
182        }
183        return ::TSize(MemUsed);
184    }
185    TIter BegI() const {
186      if (Len() == 0){return TIter(KeyDatV.EndI(), KeyDatV.EndI());}
187      if (IsKeyIdEqKeyN()) { return TIter(KeyDatV.BegI(), KeyDatV.EndI());}
188      int FKeyId=-1;  FNextKeyId(FKeyId);
189      return TIter(KeyDatV.BegI()+FKeyId, KeyDatV.EndI()); }
190    TIter EndI() const {return TIter(KeyDatV.EndI(), KeyDatV.EndI());}
191    TIter GetI(const TKey& Key) const {return TIter(&KeyDatV[GetKeyId(Key)], KeyDatV.EndI());}
192    void Gen(const int& ExpectVals){
193      PortV.Gen(GetNextPrime(ExpectVals/2)); KeyDatV.Gen(ExpectVals, 0);
194      FFreeKeyId=-1; FreeKeys=0; PortV.PutAll(TInt(-1));}
195    void Clr(const bool& DoDel=true, const int& NoDelLim=-1, const bool& ResetDat=true);
196    bool Empty() const {return Len()==0;}
197    int Len() const {return KeyDatV.Len()-FreeKeys;}
198    int GetPorts() const {return PortV.Len();}
199    bool IsAutoSize() const {return AutoSizeP;}
200    int GetMxKeyIds() const {return KeyDatV.Len();}
201    int GetReservedKeyIds() const {return KeyDatV.Reserved();}
202    bool IsKeyIdEqKeyN() const {return FreeKeys==0;}
203    int AddKey(const TKey& Key);
204    TDat& AddDatId(const TKey& Key){
205      int KeyId=AddKey(Key); return KeyDatV[KeyId].Dat=KeyId;}
206    TDat& AddDat(const TKey& Key){return KeyDatV[AddKey(Key)].Dat;}
207    TDat& AddDat(const TKey& Key, const TDat& Dat){
208      return KeyDatV[AddKey(Key)].Dat=Dat;}
209    void DelKey(const TKey& Key);
210    bool DelIfKey(const TKey& Key){
211      int KeyId; if (IsKey(Key, KeyId)){DelKeyId(KeyId); return true;} return false;}
212    void DelKeyId(const int& KeyId){DelKey(GetKey(KeyId));}
213    void DelKeyIdV(const TIntV& KeyIdV){
214      for (int KeyIdN=0; KeyIdN<KeyIdV.Len(); KeyIdN++){DelKeyId(KeyIdV[KeyIdN]);}}
215    void MarkDelKey(const TKey& Key); 
216    void MarkDelKeyId(const int& KeyId){MarkDelKey(GetKey(KeyId));}
217    const TKey& GetKey(const int& KeyId) const { return GetHashKeyDat(KeyId).Key;}
218    int GetKeyId(const TKey& Key) const;
219    int GetRndKeyId(TRnd& Rnd) const;
220    int GetRndKeyId(TRnd& Rnd, const double& EmptyFrac);
221    bool IsKey(const TKey& Key) const {return GetKeyId(Key)!=-1;}
222    bool IsKey(const TKey& Key, int& KeyId) const { KeyId=GetKeyId(Key); return KeyId!=-1;}
223    bool IsKeyId(const int& KeyId) const {
224      return (0<=KeyId)&&(KeyId<KeyDatV.Len())&&(KeyDatV[KeyId].HashCd!=-1);}
225    const TDat& GetDat(const TKey& Key) const {return KeyDatV[GetKeyId(Key)].Dat;}
226    TDat& GetDat(const TKey& Key){return KeyDatV[GetKeyId(Key)].Dat;}
227    TDat GetDatWithDefault(const TKey& Key, TDat DefaultValue) {
228      int KeyId = GetKeyId(Key);
229      return KeyId >= 0 ? KeyDatV[KeyId].Dat : DefaultValue;
230    }
231    void GetKeyDat(const int& KeyId, TKey& Key, TDat& Dat) const {
232      const THKeyDat& KeyDat=GetHashKeyDat(KeyId);
233      Key=KeyDat.Key; Dat=KeyDat.Dat;}
234    bool IsKeyGetDat(const TKey& Key, TDat& Dat) const {int KeyId;
235      if (IsKey(Key, KeyId)){Dat=GetHashKeyDat(KeyId).Dat; return true;}
236      else {return false;}}
237    int FFirstKeyId() const {return 0-1;}
238    bool FNextKeyId(int& KeyId) const;
239    void GetKeyV(TVec<TKey>& KeyV) const;
240    void GetDatV(TVec<TDat>& DatV) const;
241    void GetKeyDatPrV(TVec<TPair<TKey, TDat> >& KeyDatPrV) const;
242    void GetDatKeyPrV(TVec<TPair<TDat, TKey> >& DatKeyPrV) const;
243    void GetKeyDatKdV(TVec<TKeyDat<TKey, TDat> >& KeyDatKdV) const;
244    void GetDatKeyKdV(TVec<TKeyDat<TDat, TKey> >& DatKeyKdV) const;
245    void Swap(THash& Hash);
246    void Defrag();
247    void Pack(){KeyDatV.Pack();}
248    void Sort(const bool& CmpKey, const bool& Asc);
249    void SortByKey(const bool& Asc=true) { Sort(true, Asc); }
250    void SortByDat(const bool& Asc=true) { Sort(false, Asc); }
251  };
252  template<class TKey, class TDat, class THashFunc>
253  const unsigned int THash<TKey, TDat, THashFunc>::HashPrimeT[HashPrimes]={
254    3ul, 5ul, 11ul, 23ul,
255    53ul,         97ul,         193ul,       389ul,       769ul,
256    1543ul,       3079ul,       6151ul,      12289ul,     24593ul,
257    49157ul,      98317ul,      196613ul,    393241ul,    786433ul,
258    1572869ul,    3145739ul,    6291469ul,   12582917ul,  25165843ul,
259    50331653ul,   100663319ul,  201326611ul, 402653189ul, 805306457ul,
260    1610612741ul, 3221225473ul, 4294967291ul
261  };
262  template<class TKey, class TDat, class THashFunc>
263  uint THash<TKey, TDat, THashFunc>::GetNextPrime(const uint& Val) const {
264    const uint* f=(const uint*)HashPrimeT, *m, *l=(const uint*)HashPrimeT + (int)HashPrimes;
265    int h, len = (int)HashPrimes;
266    while (len > 0) {
267      h = len >> 1;  m = f + h;
268      if (*m < Val) { f = m;  f++;  len = len - h - 1; }
269      else len = h;
270    }
271    return f == l ? *(l - 1) : *f;
272  }
273  template<class TKey, class TDat, class THashFunc>
274  void THash<TKey, TDat, THashFunc>::Resize(){
275    if (PortV.Len()==0){
276      PortV.Gen(17);
277    } else if (AutoSizeP&&(KeyDatV.Len()>2*PortV.Len())){
278      PortV.Gen(GetNextPrime(PortV.Len()+1));
279    } else {
280      return;
281    }
282    PortV.PutAll(TInt(-1));
283    for (int KeyId=0; KeyId<KeyDatV.Len(); KeyId++){
284      THKeyDat& KeyDat=KeyDatV[KeyId];
285      if (KeyDat.HashCd!=-1){
286        const int PortN = abs(THashFunc::GetPrimHashCd(KeyDat.Key) % PortV.Len());
287        KeyDat.Next=PortV[PortN];
288        PortV[PortN]=KeyId;
289      }
290    }
291  }
292  template<class TKey, class TDat, class THashFunc>
293  THash<TKey, TDat, THashFunc>::THash(const int& ExpectVals, const bool& _AutoSizeP):
294    PortV(GetNextPrime(ExpectVals/2)), KeyDatV(ExpectVals, 0),
295    AutoSizeP(_AutoSizeP), FFreeKeyId(-1), FreeKeys(0){
296    PortV.PutAll(TInt(-1));
297  }
298  template<class TKey, class TDat, class THashFunc>
299  bool THash<TKey, TDat, THashFunc>::operator==(const THash& Hash) const {
300    if (Len() != Hash.Len()) { return false; }
301    for (int i = FFirstKeyId(); FNextKeyId(i); ) {
302      const TKey& Key = GetKey(i);
303      if (! Hash.IsKey(Key)) { return false; }
304      if (GetDat(Key) != Hash.GetDat(Key)) { return false; }
305    }
306    return true;
307  }
308  template<class TKey, class TDat, class THashFunc>
309  void THash<TKey, TDat, THashFunc>::Clr(const bool& DoDel, const int& NoDelLim, const bool& ResetDat){
310    if (DoDel){
311      PortV.Clr(); KeyDatV.Clr();
312    } else {
313      PortV.PutAll(TInt(-1));
314      KeyDatV.Clr(DoDel, NoDelLim);
315      if (ResetDat){KeyDatV.PutAll(THKeyDat());}
316    }
317    FFreeKeyId=TInt(-1); FreeKeys=TInt(0);
318  }
319  template<class TKey, class TDat, class THashFunc>
320  int THash<TKey, TDat, THashFunc>::AddKey(const TKey& Key){
321    if ((KeyDatV.Len()>2*PortV.Len())||PortV.Empty()){Resize();}
322    const int PortN=abs(THashFunc::GetPrimHashCd(Key)%PortV.Len());
323    const int HashCd=abs(THashFunc::GetSecHashCd(Key));
324    int PrevKeyId=-1;
325    int KeyId=PortV[PortN];
326    while ((KeyId!=-1) &&
327     !((KeyDatV[KeyId].HashCd==HashCd) && (KeyDatV[KeyId].Key==Key))){
328      PrevKeyId=KeyId; KeyId=KeyDatV[KeyId].Next;}
329    if (KeyId==-1){
330      if (FFreeKeyId==-1){
331        KeyId=KeyDatV.Add(THKeyDat(-1, HashCd, Key));
332      } else {
333        KeyId=FFreeKeyId; FFreeKeyId=KeyDatV[FFreeKeyId].Next; FreeKeys--;
334        KeyDatV[KeyId].Next=-1;
335        KeyDatV[KeyId].HashCd=HashCd;
336        KeyDatV[KeyId].Key=Key;
337      }
338      if (PrevKeyId==-1){
339        PortV[PortN]=KeyId;
340      } else {
341        KeyDatV[PrevKeyId].Next=KeyId;
342      }
343    }
344    return KeyId;
345  }
346  template<class TKey, class TDat, class THashFunc>
347  void THash<TKey, TDat, THashFunc>::DelKey(const TKey& Key){
348    IAssert(!PortV.Empty());
349    const int PortN=abs(THashFunc::GetPrimHashCd(Key)%PortV.Len());
350    const int HashCd=abs(THashFunc::GetSecHashCd(Key));
351    int PrevKeyId=-1;
352    int KeyId=PortV[PortN];
353    while ((KeyId!=-1) &&
354     !((KeyDatV[KeyId].HashCd==HashCd) && (KeyDatV[KeyId].Key==Key))){
355      PrevKeyId=KeyId; KeyId=KeyDatV[KeyId].Next;}
356    IAssert(KeyId!=-1); 
357    if (PrevKeyId==-1){PortV[PortN]=KeyDatV[KeyId].Next;}
358    else {KeyDatV[PrevKeyId].Next=KeyDatV[KeyId].Next;}
359    KeyDatV[KeyId].Next=FFreeKeyId; FFreeKeyId=KeyId; FreeKeys++;
360    KeyDatV[KeyId].HashCd=TInt(-1);
361    KeyDatV[KeyId].Key=TKey();
362    KeyDatV[KeyId].Dat=TDat();
363  }
364  template<class TKey, class TDat, class THashFunc>
365  void THash<TKey, TDat, THashFunc>::MarkDelKey(const TKey& Key){
366    IAssert(!PortV.Empty());
367    const int PortN=abs(THashFunc::GetPrimHashCd(Key)%PortV.Len());
368    const int HashCd=abs(THashFunc::GetSecHashCd(Key));
369    int PrevKeyId=-1;
370    int KeyId=PortV[PortN];
371    while ((KeyId!=-1) &&
372     !((KeyDatV[KeyId].HashCd==HashCd) && (KeyDatV[KeyId].Key==Key))){
373      PrevKeyId=KeyId; KeyId=KeyDatV[KeyId].Next;}
374    IAssertR(KeyId!=-1, Key.GetStr());
375    if (PrevKeyId==-1){PortV[PortN]=KeyDatV[KeyId].Next;}
376    else {KeyDatV[PrevKeyId].Next=KeyDatV[KeyId].Next;}
377    KeyDatV[KeyId].Next=FFreeKeyId; FFreeKeyId=KeyId; FreeKeys++;
378    KeyDatV[KeyId].HashCd=TInt(-1);
379  }
380  template<class TKey, class TDat, class THashFunc>
381  int THash<TKey, TDat, THashFunc>::GetRndKeyId(TRnd& Rnd) const  {
382    IAssert(! Empty());
383    int KeyId = abs(Rnd.GetUniDevInt(KeyDatV.Len()));
384    while (KeyDatV[KeyId].HashCd == -1) { 
385      KeyId = abs(Rnd.GetUniDevInt(KeyDatV.Len())); }
386    return KeyId;
387  }
388  template<class TKey, class TDat, class THashFunc>
389  int THash<TKey, TDat, THashFunc>::GetRndKeyId(TRnd& Rnd, const double& EmptyFrac) {
390    IAssert(! Empty());
391    if (FreeKeys/double(Len()+FreeKeys) > EmptyFrac) { Defrag(); }
392    int KeyId = Rnd.GetUniDevInt(KeyDatV.Len());
393    while (KeyDatV[KeyId].HashCd == -1) { 
394      KeyId = Rnd.GetUniDevInt(KeyDatV.Len());
395    }
396    return KeyId;
397  }
398  template<class TKey, class TDat, class THashFunc>
399  int THash<TKey, TDat, THashFunc>::GetKeyId(const TKey& Key) const {
400    if (PortV.Empty()){return -1;}
401    const int PortN=abs(THashFunc::GetPrimHashCd(Key)%PortV.Len());
402    const int HashCd=abs(THashFunc::GetSecHashCd(Key));
403    int KeyId=PortV[PortN];
404    while ((KeyId!=-1) &&
405     !((KeyDatV[KeyId].HashCd==HashCd) && (KeyDatV[KeyId].Key==Key))){
406      KeyId=KeyDatV[KeyId].Next;}
407    return KeyId;
408  }
409  template<class TKey, class TDat, class THashFunc>
410  bool THash<TKey, TDat, THashFunc>::FNextKeyId(int& KeyId) const {
411    do {KeyId++;} while ((KeyId<KeyDatV.Len()) && (KeyDatV[KeyId].HashCd==-1));
412    return KeyId<KeyDatV.Len();
413  }
414  template<class TKey, class TDat, class THashFunc>
415  void THash<TKey, TDat, THashFunc>::GetKeyV(TVec<TKey>& KeyV) const {
416    KeyV.Gen(Len(), 0);
417    int KeyId=FFirstKeyId();
418    while (FNextKeyId(KeyId)){
419      KeyV.Add(GetKey(KeyId));}
420  }
421  template<class TKey, class TDat, class THashFunc>
422  void THash<TKey, TDat, THashFunc>::GetDatV(TVec<TDat>& DatV) const {
423    DatV.Gen(Len(), 0);
424    int KeyId=FFirstKeyId();
425    while (FNextKeyId(KeyId)){
426      DatV.Add(GetHashKeyDat(KeyId).Dat);}
427  }
428  template<class TKey, class TDat, class THashFunc>
429  void THash<TKey, TDat, THashFunc>::GetKeyDatPrV(TVec<TPair<TKey, TDat> >& KeyDatPrV) const {
430    KeyDatPrV.Gen(Len(), 0);
431    TKey Key; TDat Dat;
432    int KeyId=FFirstKeyId();
433    while (FNextKeyId(KeyId)){
434      GetKeyDat(KeyId, Key, Dat);
435      KeyDatPrV.Add(TPair<TKey, TDat>(Key, Dat));
436    }
437  }
438  template<class TKey, class TDat, class THashFunc>
439  void THash<TKey, TDat, THashFunc>::GetDatKeyPrV(TVec<TPair<TDat, TKey> >& DatKeyPrV) const {
440    DatKeyPrV.Gen(Len(), 0);
441    TKey Key; TDat Dat;
442    int KeyId=FFirstKeyId();
443    while (FNextKeyId(KeyId)){
444      GetKeyDat(KeyId, Key, Dat);
445      DatKeyPrV.Add(TPair<TDat, TKey>(Dat, Key));
446    }
447  }
448  template<class TKey, class TDat, class THashFunc>
449  void THash<TKey, TDat, THashFunc>::GetKeyDatKdV(TVec<TKeyDat<TKey, TDat> >& KeyDatKdV) const {
450    KeyDatKdV.Gen(Len(), 0);
451    TKey Key; TDat Dat;
452    int KeyId=FFirstKeyId();
453    while (FNextKeyId(KeyId)){
454      GetKeyDat(KeyId, Key, Dat);
455      KeyDatKdV.Add(TKeyDat<TKey, TDat>(Key, Dat));
456    }
457  }
458  template<class TKey, class TDat, class THashFunc>
459  void THash<TKey, TDat, THashFunc>::GetDatKeyKdV(TVec<TKeyDat<TDat, TKey> >& DatKeyKdV) const {
460    DatKeyKdV.Gen(Len(), 0);
461    TKey Key; TDat Dat;
462    int KeyId=FFirstKeyId();
463    while (FNextKeyId(KeyId)){
464      GetKeyDat(KeyId, Key, Dat);
465      DatKeyKdV.Add(TKeyDat<TDat, TKey>(Dat, Key));
466    }
467  }
468  template<class TKey, class TDat, class THashFunc>
469  void THash<TKey, TDat, THashFunc>::Swap(THash& Hash) {
470    if (this!=&Hash){
471      PortV.Swap(Hash.PortV);
472      KeyDatV.Swap(Hash.KeyDatV);
473      ::Swap(AutoSizeP, Hash.AutoSizeP);
474      ::Swap(FFreeKeyId, Hash.FFreeKeyId);
475      ::Swap(FreeKeys, Hash.FreeKeys);
476    }
477  }
478  template<class TKey, class TDat, class THashFunc>
479  void THash<TKey, TDat, THashFunc>::Defrag(){
480    if (!IsKeyIdEqKeyN()){
481      THash<TKey, TDat, THashFunc> Hash(PortV.Len());
482      int KeyId=FFirstKeyId(); TKey Key; TDat Dat;
483      while (FNextKeyId(KeyId)){
484        GetKeyDat(KeyId, Key, Dat);
485        Hash.AddDat(Key, Dat);
486      }
487      Pack();
<span onclick='openModal()' class='match'>488      operator=(Hash);
489      IAssert(IsKeyIdEqKeyN());
490    }
491  }
492  template<class TKey, class TDat, class THashFunc>
</span>493  void THash<TKey, TDat, THashFunc>::Sort(const bool& CmpKey, const bool& Asc) {
494    IAssertR(IsKeyIdEqKeyN(), "THash::Sort only works when table has no deleted keys.");
495    TIntV TargV(Len()), MapV(Len()), StateV(Len());
496    for (int i = 0; i < TargV.Len(); i++) {
497      TargV[i] = i; MapV[i] = i; StateV[i] = i;
498    }
499    THashKeyDatCmp HashCmp(*this, CmpKey, Asc);
500    TargV.SortCmp(HashCmp);
501    THashKeyDat<TKey, TDat> Tmp;
502    for (int i = 0; i < TargV.Len()-1; i++) {
503      const int SrcPos = MapV[TargV[i]];
504      const int Loc = i;
505      Tmp = KeyDatV[SrcPos];
506      KeyDatV[SrcPos] = KeyDatV[Loc];
507      KeyDatV[Loc] = Tmp;
508      MapV[StateV[i]] = SrcPos;
509      StateV.Swap(Loc, SrcPos);
510    }
511    for (int i = 0; i < TargV.Len(); i++) {
512      MapV[TargV[i]] = i; }
513    for (int p = 0; p < PortV.Len(); p++) {
514      if (PortV[p] != -1) {
515        PortV[p] = MapV[PortV[p]]; } }
516    for (int i = 0; i < KeyDatV.Len(); i++) {
517      if (KeyDatV[i].Next != -1) {
518        KeyDatV[i].Next = MapV[KeyDatV[i].Next]; }
519    }
520  }
521  typedef THash<TCh, TCh> TChChH;
522  typedef THash<TChTr, TInt> TChTrIntH;
523  typedef THash<TInt, TInt> TIntH;
524  typedef THash<TUInt64, TInt> TUInt64H;
525  typedef THash<TInt, TBool> TIntBoolH;
526  typedef THash<TInt, TInt> TIntIntH;
527  typedef THash<TInt, TUInt64> TIntUInt64H;
528  typedef THash<TInt, TIntFltPr> TIntIntFltPrH;
529  typedef THash<TInt, TIntV> TIntIntVH;
530  typedef THash<TInt, TIntH> TIntIntHH;
531  typedef THash<TInt, TFlt> TIntFltH;
532  typedef THash<TInt, TFltPr> TIntFltPrH;
533  typedef THash<TInt, TFltTr> TIntFltTrH;
534  typedef THash<TInt, TFltV> TIntFltVH;
535  typedef THash<TInt, TStr> TIntStrH;
536  typedef THash<TInt, TStrV> TIntStrVH;
537  typedef THash<TInt, TStrPrV> TIntStrPrVH;
538  typedef THash<TInt, TIntPr> TIntIntPrH;
539  typedef THash<TInt, TIntPrV> TIntIntPrVH;
540  typedef THash<TInt, TIntStrPr> TIntIntStrPrH;
541  typedef THash<TInt, TIntVFltVPr> TIntIntVFltVPrH;
542  typedef THash<TUInt64, TStrV> TUInt64StrVH;
543  typedef THash<TIntPr, TInt> TIntPrIntH;
544  typedef THash<TIntPr, TIntPr> TIntPrH;
545  typedef THash<TIntPr, TIntV> TIntPrIntVH;
546  typedef THash<TIntPr, TIntPrV> TIntPrIntPrVH;
547  typedef THash<TIntTr, TInt> TIntTrIntH;
548  typedef THash<TIntV, TInt> TIntVIntH;
549  typedef THash<TUInt, TUInt> TUIntH;
550  typedef THash<TIntPr, TInt> TIntPrIntH;
551  typedef THash<TIntPr, TIntV> TIntPrIntVH;
552  typedef THash<TIntPr, TFlt> TIntPrFltH;
553  typedef THash<TIntTr, TFlt> TIntTrFltH;
554  typedef THash<TIntPr, TStr> TIntPrStrH;
555  typedef THash<TIntPr, TStrV> TIntPrStrVH;
556  typedef THash<TIntStrPr, TInt> TIntStrPrIntH;
557  typedef THash<TIntIntPrPr, TInt> TIntIntPrPrIntH;
558  typedef THash<TIntIntPrPr, TFlt> TIntIntPrPrFltH;
559  typedef THash<TIntIntPrPr, TStr> TIntIntPrPrStrH;
560  typedef THash<TFlt, TFlt> TFltFltH;
561  typedef THash<TStr, TInt> TStrH;
562  typedef THash<TStr, TBool> TStrBoolH;
563  typedef THash<TStr, TInt> TStrIntH;
564  typedef THash<TStr, TIntPr> TStrIntPrH;
565  typedef THash<TStr, TIntV> TStrIntVH;
566  typedef THash<TStr, TUInt64> TStrUInt64H;
567  typedef THash<TStr, TUInt64V> TStrUInt64VH;
568  typedef THash<TStr, TIntPrV> TStrIntPrVH;
569  typedef THash<TStr, TFlt> TStrFltH;
570  typedef THash<TStr, TFltV> TStrFltVH;
571  typedef THash<TStr, TStr> TStrStrH;
572  typedef THash<TStr, TStrPr> TStrStrPrH;
573  typedef THash<TStr, TStrV> TStrStrVH;
574  typedef THash<TStr, TStrPrV> TStrStrPrVH;
575  typedef THash<TStr, TStrKdV> TStrStrKdVH;
576  typedef THash<TStr, TIntFltPr> TStrIntFltPrH;
577  typedef THash<TStr, TStrIntPrV> TStrStrIntPrVH;
578  typedef THash<TStr, TStrIntKdV> TStrStrIntKdVH;
579  typedef THash<TDbStr, TInt> TDbStrIntH;
580  typedef THash<TDbStr, TStr> TDbStrStrH;
581  typedef THash<TStrPr, TBool> TStrPrBoolH;
582  typedef THash<TStrPr, TInt> TStrPrIntH;
583  typedef THash<TStrPr, TFlt> TStrPrFltH;
584  typedef THash<TStrPr, TStr> TStrPrStrH;
585  typedef THash<TStrPr, TStrV> TStrPrStrVH;
586  typedef THash<TStrTr, TInt> TStrTrIntH;
587  typedef THash<TStrIntPr, TInt> TStrIntPrIntH;
588  typedef THash<TStrV, TInt> TStrVH;
589  typedef THash<TStrV, TInt> TStrVIntH;
590  typedef THash<TStrV, TIntV> TStrVIntVH;
591  typedef THash<TStrV, TStr> TStrVStrH;
592  typedef THash<TStrV, TStrV> TStrVStrVH;
593  template <class TKey, class TDat>
594  class PHash{
595  private:
596    TCRef CRef;
597  public:
598    THash<TKey, TDat> H;
599  public:
600    PHash<TKey, TDat>(): H(){}
601    static TPt<PHash<TKey, TDat> > New(){
602      return new PHash<TKey, TDat>();}
603    PHash<TKey, TDat>(const int& MxVals, const int& Vals): H(MxVals, Vals){}
604    static TPt<PHash<TKey, TDat> > New(const int& MxVals, const int& Vals){
605      return new PHash<TKey, TDat>(MxVals, Vals);}
606    PHash<TKey, TDat>(const THash<TKey, TDat>& _V): H(_V){}
607    static TPt<PHash<TKey, TDat> > New(const THash<TKey, TDat>& H){
608      return new PHash<TKey, TDat>(H);}
609    explicit PHash<TKey, TDat>(TSIn& SIn): H(SIn){}
610    static TPt<PHash<TKey, TDat> > Load(TSIn& SIn){return new PHash<TKey, TDat>(SIn);}
611    void Save(TSOut& SOut) const {H.Save(SOut);}
612    PHash<TKey, TDat>& operator=(const PHash<TKey, TDat>& Vec){
613      if (this!=&Vec){H=Vec.H;} return *this;}
614    bool operator==(const PHash<TKey, TDat>& Vec) const {return H==Vec.H;}
615    bool operator<(const PHash<TKey, TDat>& Vec) const {return H<Vec.H;}
616    friend class TPt<PHash<TKey, TDat> >;
617  };
618  ClassTP(TBigStrPool, PBigStrPool)
619  private:
620    TSize MxBfL, BfL;
621    uint GrowBy;
622    char *Bf;
623    TVec<TSize> IdOffV; 
624    bool IsShM; 
625  private:
626    void Resize(TSize _MxBfL);
627    void LoadPoolShM(TShMIn& ShMIn, bool LoadCompact = true);
628  public:
629    TBigStrPool(TSize MxBfLen = 0, uint _GrowBy = 16*1024*1024);
630    TBigStrPool(TSIn& SIn, bool LoadCompact = true);
631    TBigStrPool(const TBigStrPool& Pool) : MxBfL(Pool.MxBfL), BfL(Pool.BfL), GrowBy(Pool.GrowBy) {
632      Bf = (char *) malloc(Pool.MxBfL); IAssert(Bf); memcpy(Bf, Pool.Bf, Pool.BfL); }
633    ~TBigStrPool() { if (Bf && !IsShM) free(Bf); else IAssert(MxBfL == 0 || IsShM);  MxBfL = 0; BfL = 0; }
634    static PBigStrPool New(TSize _MxBfLen = 0, uint _GrowBy = 16*1024*1024) { return PBigStrPool(new TBigStrPool(_MxBfLen, _GrowBy)); }
635    static PBigStrPool New(TSIn& SIn) { return new TBigStrPool(SIn); }
636    static PBigStrPool New(const TStr& fileName) { PSIn SIn = TFIn::New(fileName); return new TBigStrPool(*SIn); }
637    static PBigStrPool Load(TSIn& SIn, bool LoadCompacted = true) { return PBigStrPool(new TBigStrPool(SIn, LoadCompacted)); }
638    static PBigStrPool LoadShM(TShMIn& ShMIn, bool LoadCompact = true) {
639      TBigStrPool* StrPool = new TBigStrPool();
640      StrPool->LoadPoolShM(ShMIn, LoadCompact);
641      return PBigStrPool(StrPool);
642    }
643    void Save(TSOut& SOut) const;
644    void Save(const TStr& fileName) { TFOut FOut(fileName); Save(FOut); }
645    int GetStrs() const { return IdOffV.Len(); }
646    TSize Len() const { return BfL; }
647    TSize Size() const { return MxBfL; }
648    bool Empty() const { return ! Len(); }
649    char* operator () () const { return Bf; }
650    TBigStrPool& operator = (const TBigStrPool& Pool);
651    ::TSize GetMemUsed(){
652    	return 4 * sizeof(int) + IdOffV.GetMemUsed() + MxBfL;
653    }
654    int AddStr(const char *Str, uint Len);
655    int AddStr(const char *Str) { return AddStr(Str, uint(strlen(Str)) + 1); }
656    int AddStr(const TStr& Str) { return AddStr(Str.CStr(), Str.Len() + 1); }
657    TStr GetStr(const int& StrId) const { Assert(StrId < GetStrs());
658      if (StrId == 0) return TStr::GetNullStr(); else return TStr(Bf + (TSize)IdOffV[StrId]); }
659    const char *GetCStr(const int& StrId) const { Assert(StrId < GetStrs());
660      if (StrId == 0) return TStr::GetNullStr().CStr(); else return (Bf + (TSize)IdOffV[StrId]); }
661    TStr GetStrFromOffset(const TSize& Offset) const { Assert(Offset < BfL);
662      if (Offset == 0) return TStr::GetNullStr(); else return TStr(Bf + Offset); }
663    const char *GetCStrFromOffset(const TSize& Offset) const { Assert(Offset < BfL);
664      if (Offset == 0) return TStr::GetNullStr().CStr(); else return Bf + Offset; }
665    void Clr(bool DoDel = false) {
666      BfL = 0; if (DoDel && Bf) {if (!IsShM) { free(Bf);} Bf = 0; MxBfL = 0;}}
667    int Cmp(const int& StrId, const char *Str) const { Assert(StrId < GetStrs());
668      if (StrId != 0) return strcmp(Bf + (TSize)IdOffV[StrId], Str); else return strcmp("", Str); }
669    static int GetPrimHashCd(const char *CStr);
670    static int GetSecHashCd(const char *CStr);
671    int GetPrimHashCd(const int& StrId) { Assert(StrId < GetStrs());
672      if (StrId != 0) return GetPrimHashCd(Bf + (TSize)IdOffV[StrId]); else return GetPrimHashCd(""); }
673    int GetSecHashCd(const int& StrId) { Assert(StrId < GetStrs());
674      if (StrId != 0) return GetSecHashCd(Bf + (TSize)IdOffV[StrId]); else return GetSecHashCd(""); }
675  };
676  template <class TDat, class TStringPool = TStrPool, class THashFunc = TDefaultHashFunc<TStr> >
677  class TStrHash{
678  public:
679    typedef TPt<TStringPool> PStringPool;
680  private:
681    typedef THashKeyDat<TInt, TDat> THKeyDat;
682    typedef TPair<TInt, TDat> TKeyDatP;
683    typedef TVec<THKeyDat> THKeyDatV;
684    TIntV PortV;
685    THKeyDatV KeyDatV;
686    TBool AutoSizeP;
687    TInt FFreeKeyId, FreeKeys;
688    PStringPool Pool;
689  private:
690    uint GetNextPrime(const uint& Val) const;
691    void Resize();
692    const THKeyDat& GetHashKeyDat(const int& KeyId) const {
693      const THKeyDat& KeyDat = KeyDatV[KeyId];  Assert(KeyDat.HashCd != -1);  return KeyDat; }
694    THKeyDat& GetHashKeyDat(const int& KeyId) {
695      THKeyDat& KeyDat = KeyDatV[KeyId];  Assert(KeyDat.HashCd != -1);  return KeyDat; }
696  public:
697    TStrHash(): PortV(), KeyDatV(), AutoSizeP(true), FFreeKeyId(-1), FreeKeys(0), Pool() { }
698    TStrHash(const PStringPool& StrPool): PortV(), KeyDatV(), AutoSizeP(true), FFreeKeyId(-1), FreeKeys(0), Pool(StrPool) { }
699    TStrHash(const int& Ports, const bool& _AutoSizeP = false, const PStringPool& StrPool = PStringPool()) :
700      PortV(Ports), KeyDatV(Ports, 0), AutoSizeP(_AutoSizeP), FFreeKeyId(-1), FreeKeys(0), Pool(StrPool) { PortV.PutAll(-1); }
701    TStrHash(const TStrHash& Hash): PortV(Hash.PortV), KeyDatV(Hash.KeyDatV), AutoSizeP(Hash.AutoSizeP),
702      FFreeKeyId(Hash.FFreeKeyId), FreeKeys(Hash.FreeKeys), Pool() {
703        if (! Hash.Pool.Empty()) { Pool=PStringPool(new TStringPool(*Hash.Pool)); } }
704    TStrHash(TSIn& SIn, bool PoolToo = true): PortV(SIn), KeyDatV(SIn), AutoSizeP(SIn), FFreeKeyId(SIn), FreeKeys(SIn){ SIn.LoadCs(); if (PoolToo) Pool = PStringPool(SIn); }
705    void Load(TSIn& SIn, bool PoolToo = true) {PortV.Load(SIn); KeyDatV.Load(SIn); AutoSizeP.Load(SIn); FFreeKeyId.Load(SIn);
706      FreeKeys.Load(SIn); SIn.LoadCs(); if (PoolToo) Pool = PStringPool(SIn);}
707    void LoadShM(TShMIn& ShMIn, bool SharedPool=true) {
708      PortV.LoadShM(ShMIn);
709      KeyDatV.Load(ShMIn);
710      AutoSizeP.Load(ShMIn);
711      FFreeKeyId.Load(ShMIn);
712      FreeKeys.Load(ShMIn);
713      ShMIn.LoadCs();
714      if (SharedPool) {
715        TBool isNull;
716        isNull.Load(ShMIn);
717        if (!isNull) {
718          Pool = TStringPool::LoadShM(ShMIn);
719        }
720      } else {
721        Pool = PStringPool(ShMIn);
722      }
723    }
724    void Save(TSOut& SOut, bool PoolToo = true) const { PortV.Save(SOut); KeyDatV.Save(SOut);
725      AutoSizeP.Save(SOut); FFreeKeyId.Save(SOut); FreeKeys.Save(SOut); SOut.SaveCs(); if (PoolToo) Pool.Save(SOut); }
726    void SetPool(const PStringPool& StrPool) { IAssert(Pool.Empty() || Pool->Empty()); Pool = StrPool; }
727    PStringPool GetPool() const { return Pool; }
728    TStrHash& operator = (const TStrHash& Hash);
729    bool Empty() const {return ! Len(); }
730    int Len() const { return KeyDatV.Len() - FreeKeys; }
731    int Reserved() const { return KeyDatV.Reserved(); }
732    int GetPorts() const { return PortV.Len(); }
733    bool IsAutoSize() const { return AutoSizeP; }
734    int GetMxKeyIds() const { return KeyDatV.Len(); }
735    bool IsKeyIdEqKeyN() const {return ! FreeKeys; }
736    int AddKey(const char *Key);
737    int AddKey(const TStr& Key) { return AddKey(Key.CStr()); }
738    int AddKey(const TChA& Key) { return AddKey(Key.CStr()); }
739    int AddDat(const char *Key, const TDat& Dat) { const int KeyId = AddKey(Key); KeyDatV[KeyId].Dat = Dat; return KeyId; }
740    int AddDat(const TStr& Key, const TDat& Dat) { const int KeyId = AddKey(Key.CStr()); KeyDatV[KeyId].Dat = Dat; return KeyId; }
741    int AddDat(const TChA& Key, const TDat& Dat) { const int KeyId = AddKey(Key.CStr()); KeyDatV[KeyId].Dat = Dat; return KeyId; }
742    TDat& AddDat(const char *Key) { return KeyDatV[AddKey(Key)].Dat; }
743    TDat& AddDat(const TStr& Key) { return KeyDatV[AddKey(Key.CStr())].Dat; }
744    TDat& AddDat(const TChA& Key) { return KeyDatV[AddKey(Key.CStr())].Dat; }
745    TDat& AddDatId(const char *Key) { const int KeyId = AddKey(Key);  return KeyDatV[KeyId].Dat = KeyId; }
746    TDat& AddDatId(const TStr& Key) { const int KeyId = AddKey(Key.CStr());  return KeyDatV[KeyId].Dat = KeyId; }
747    TDat& AddDatId(const TChA& Key) { const int KeyId = AddKey(Key.CStr());  return KeyDatV[KeyId].Dat = KeyId; }
748    const TDat& operator[](const int& KeyId) const {return GetHashKeyDat(KeyId).Dat;}
749    TDat& operator[](const int& KeyId){return GetHashKeyDat(KeyId).Dat;}
750    const TDat& operator () (const char *Key) const { return GetDat(Key);}
751    ::TSize GetMemUsed() const {
752        int64 MemUsed = sizeof(bool)+2*sizeof(int);
753        MemUsed += int64(PortV.Reserved()) * int64(sizeof(TInt));
754        for (int KeyDatN = 0; KeyDatN < KeyDatV.Len(); KeyDatN++) {
755            MemUsed += int64(2 * sizeof(TInt));
756            MemUsed += int64(KeyDatV[KeyDatN].Key.GetMemUsed());
757            MemUsed += int64(KeyDatV[KeyDatN].Dat.GetMemUsed());
758        }
759        MemUsed += 8 + Pool->GetMemUsed();
760        return ::TSize(MemUsed/1000);
761    }
762    const TDat& GetDat(const char *Key) const { return KeyDatV[GetKeyId(Key)].Dat; }
763    const TDat& GetDat(const TStr& Key) const { return GetDat(Key.CStr()); }
764    TDat& GetDat(const char *Key) { return KeyDatV[GetKeyId(Key)].Dat; }
765    const TDat& GetDat(const TStr& Key) { return GetDat(Key.CStr()); }
766    const TDat& GetDat(const TChA& Key) { return GetDat(Key.CStr()); }
767    TDat& GetDatId(const int& KeyId) { return KeyDatV[KeyId].Dat; }
768    const TDat& GetDatId(const int& KeyId) const { return KeyDatV[KeyId].Dat; }
769    void GetKeyDat(const int& KeyId, int& KeyO, TDat& Dat) const { const THKeyDat& KeyDat = GetHashKeyDat(KeyId); KeyO = KeyDat.Key; Dat = KeyDat.Dat; }
770    void GetKeyDat(const int& KeyId, const char*& Key, TDat& Dat) const { const THKeyDat& KeyDat = GetHashKeyDat(KeyId); Key = KeyFromOfs(KeyDat.Key); Dat = KeyDat.Dat; }
771    void GetKeyDat(const int& KeyId, TStr& Key, TDat& Dat) const { const THKeyDat& KeyDat = GetHashKeyDat(KeyId); Key = KeyFromOfs(KeyDat.Key); Dat = KeyDat.Dat;}
772    void GetKeyDat(const int& KeyId, TChA& Key, TDat& Dat) const { const THKeyDat& KeyDat = GetHashKeyDat(KeyId); Key = KeyFromOfs(KeyDat.Key); Dat = KeyDat.Dat;}
773    int GetKeyId(const char *Key) const;
774    int GetKeyId(const TStr& Key) const { return GetKeyId(Key.CStr()); }
775    const char *GetKey(const int& KeyId) const { return Pool->GetCStr(GetHashKeyDat(KeyId).Key); }
776    int GetKeyOfs(const int& KeyId) const { return GetHashKeyDat(KeyId).Key; } 
777    const char *KeyFromOfs(const int& KeyO) const { return Pool->GetCStr(KeyO); }
778    bool IsKey(const char *Key) const { return GetKeyId(Key) != -1; }
779    bool IsKey(const TStr& Key) const { return GetKeyId(Key.CStr()) != -1; }
780    bool IsKey(const TChA& Key) const { return GetKeyId(Key.CStr()) != -1; }
781    bool IsKey(const char *Key, int& KeyId) const { KeyId = GetKeyId(Key); return KeyId != -1; }
782    bool IsKeyGetDat(const char *Key, TDat& Dat) const { const int KeyId = GetKeyId(Key); if (KeyId != -1) { Dat = KeyDatV[KeyId].Dat; return true; } else return false; }
783    bool IsKeyGetDat(const TStr& Key, TDat& Dat) const { const int KeyId = GetKeyId(Key.CStr()); if (KeyId != -1) { Dat = KeyDatV[KeyId].Dat; return true; } else return false; }
784    bool IsKeyGetDat(const TChA& Key, TDat& Dat) const { const int KeyId = GetKeyId(Key.CStr()); if (KeyId != -1) { Dat = KeyDatV[KeyId].Dat; return true; } else return false; }
785    bool IsKeyId(const int& KeyId) const { return 0 <= KeyId && KeyId < KeyDatV.Len() && KeyDatV[KeyId].HashCd != -1; }
786    int FFirstKeyId() const {return 0-1;}
787    bool FNextKeyId(int& KeyId) const;
788    void GetKeyV(TVec<TStr>& KeyV) const;
789    void GetStrIdV(TIntV& StrIdV) const;
790    void GetDatV(TVec<TDat>& DatV) const;
791    void GetKeyDatPrV(TVec<TPair<TStr, TDat> >& KeyDatPrV) const;
792    void GetDatKeyPrV(TVec<TPair<TDat, TStr> >& DatKeyPrV) const;
793    void Pack(){KeyDatV.Pack();}
794  };
795  template <class TDat, class TStringPool, class THashFunc>
796  uint TStrHash<TDat, TStringPool, THashFunc>::GetNextPrime(const uint& Val) const {
797    uint *f = (uint *) TIntH::HashPrimeT, *m, *l = (uint *) TIntH::HashPrimeT + (int) TIntH::HashPrimes;
798    int h, len = (int)TIntH::HashPrimes;
799    while (len > 0) {
800      h = len >> 1;  m = f + h;
801      if (*m < Val) { f = m;  f++;  len = len - h - 1; }
802      else len = h;
803    }
804    return f == l ? *(l - 1) : *f;
805  }
806  template <class TDat, class TStringPool, class THashFunc>
807  void TStrHash<TDat, TStringPool, THashFunc>::Resize() {
808    if (PortV.Empty()) { PortV.Gen(17);  PortV.PutAll(-1); }
809    else
810    if (AutoSizeP && KeyDatV.Len() > 3 * PortV.Len()) {
811      const int NxPrime = GetNextPrime(KeyDatV.Len());
812      PortV.Gen(NxPrime);  PortV.PutAll(-1); }
813    else
814      return;
815    const int NPorts = PortV.Len();
816    for (int i = 0; i < KeyDatV.Len(); i++) {
817      THKeyDat& KeyDat = KeyDatV[i];
818      if (KeyDat.HashCd != -1) {
819        const int Port = abs(THashFunc::GetPrimHashCd(Pool->GetCStr(KeyDat.Key)) % NPorts);
820        KeyDat.Next = PortV[Port];
821        PortV[Port] = i;
822      }
823    }
824  }
825  template <class TDat, class TStringPool, class THashFunc>
826  TStrHash<TDat, TStringPool, THashFunc>& TStrHash<TDat, TStringPool, THashFunc>:: operator = (const TStrHash& Hash) {
827    if (this != &Hash) {
828      PortV = Hash.PortV;
829      KeyDatV = Hash.KeyDatV;
830      AutoSizeP = Hash.AutoSizeP;
831      FFreeKeyId = Hash.FFreeKeyId;
832      FreeKeys = Hash.FreeKeys;
833      if (! Hash.Pool.Empty()) Pool = PStringPool(new TStringPool(*Hash.Pool));
834      else Pool = NULL;
835    }
836    return *this;
837  }
838  template <class TDat, class TStringPool, class THashFunc>
839  int TStrHash<TDat, TStringPool, THashFunc>::AddKey(const char *Key) {
840    if (Pool.Empty()) Pool = TStringPool::New();
841    if ((AutoSizeP && KeyDatV.Len() > PortV.Len()) || PortV.Empty()) Resize();
842    const int PortN = abs(THashFunc::GetPrimHashCd(Key) % PortV.Len());
843    const int HashCd = abs(THashFunc::GetSecHashCd(Key));
844    int PrevKeyId = -1;
845    int KeyId = PortV[PortN];
846    while (KeyId != -1 && ! (KeyDatV[KeyId].HashCd == HashCd && Pool->Cmp(KeyDatV[KeyId].Key, Key) == 0)) {
847      PrevKeyId = KeyId;  KeyId = KeyDatV[KeyId].Next; }
848    if (KeyId == -1) {
849      const int StrId = Pool->AddStr(Key);
850      if (FFreeKeyId == -1) {
851        KeyId = KeyDatV.Add(THKeyDat(-1, HashCd, StrId));
852      } else {
853        KeyId = FFreeKeyId;
854        FFreeKeyId = KeyDatV[FFreeKeyId].Next;
855        FreeKeys--;
856        KeyDatV[KeyId] = THKeyDat(-1, HashCd, StrId);
857      }
858      if (PrevKeyId == -1) PortV[PortN] = KeyId;
859      else KeyDatV[PrevKeyId].Next = KeyId;
860    }
861    return KeyId;
862  }
863  template <class TDat, class TStringPool, class THashFunc>
864  int TStrHash<TDat, TStringPool, THashFunc>::GetKeyId(const char *Key) const {
865    if (PortV.Empty()) return -1;
866    const int PortN = abs(THashFunc::GetPrimHashCd(Key) % PortV.Len());
867    const int Hc = abs(THashFunc::GetSecHashCd(Key));
868    int KeyId = PortV[PortN];
869    while (KeyId != -1 && ! (KeyDatV[KeyId].HashCd == Hc && Pool->Cmp(KeyDatV[KeyId].Key, Key) == 0))
870      KeyId = KeyDatV[KeyId].Next;
871    return KeyId;
872  }
873  template <class TDat, class TStringPool, class THashFunc>
874  bool TStrHash<TDat, TStringPool, THashFunc>::FNextKeyId(int& KeyId) const {
875    do KeyId++; while (KeyId < KeyDatV.Len() && KeyDatV[KeyId].HashCd == -1);
876    return KeyId < KeyDatV.Len();
877  }
878  template <class TDat, class TStringPool, class THashFunc>
879  void TStrHash<TDat, TStringPool, THashFunc>::GetKeyV(TVec<TStr>& KeyV) const {
880    KeyV.Gen(Len(), 0);
881    int KeyId = FFirstKeyId();
882    while (FNextKeyId(KeyId))
883      KeyV.Add(GetKey(KeyId));
884  }
885  template <class TDat, class TStringPool, class THashFunc>
886  void TStrHash<TDat, TStringPool, THashFunc>::GetStrIdV(TIntV& StrIdV) const {
887    StrIdV.Gen(Len(), 0);
888    int KeyId = FFirstKeyId();
889    while (FNextKeyId(KeyId))
890      StrIdV.Add(GetKeyOfs(KeyId));
891  }
892  template <class TDat, class TStringPool, class THashFunc>
893  void TStrHash<TDat, TStringPool, THashFunc>::GetDatV(TVec<TDat>& DatV) const {
894    DatV.Gen(Len(), 0);
895    int KeyId = FFirstKeyId();
896    while (FNextKeyId(KeyId))
897      DatV.Add(GetHashKeyDat(KeyId).Dat);
898  }
899  template <class TDat, class TStringPool, class THashFunc>
900  void TStrHash<TDat, TStringPool, THashFunc>::GetKeyDatPrV(TVec<TPair<TStr, TDat> >& KeyDatPrV) const {
901    KeyDatPrV.Gen(Len(), 0);
902    TStr Str; TDat Dat;
903    int KeyId = FFirstKeyId();
904    while (FNextKeyId(KeyId)){
905      GetKeyDat(KeyId, Str, Dat);
906      KeyDatPrV.Add(TPair<TStr, TDat>(Str, Dat));
907    }
908  }
909  template <class TDat, class TStringPool, class THashFunc>
910  void TStrHash<TDat, TStringPool, THashFunc>::GetDatKeyPrV(TVec<TPair<TDat, TStr> >& DatKeyPrV) const {
911    DatKeyPrV.Gen(Len(), 0);
912    TStr Str; TDat Dat;
913    int KeyId = FFirstKeyId();
914    while (FNextKeyId(KeyId)){
915      GetKeyDat(KeyId, Str, Dat);
916      DatKeyPrV.Add(TPair<TDat, TStr>(Dat, Str));
917    }
918  }
919  typedef TStrHash<TInt> TStrSH;
920  typedef TStrHash<TInt> TStrIntSH;
921  typedef TStrHash<TIntV> TStrToIntVSH;
922  template <class TKey, class TDat, class THashFunc = TDefaultHashFunc<TKey> >
923  class TCache{
924  private:
925    typedef TLst<TKey> TKeyL; typedef TLstNd<TKey>* TKeyLN;
926    typedef TPair<TKeyLN, TDat> TKeyLNDatPr;
927    int64 MxMemUsed;
928    int64 CurMemUsed;
929    THash<TKey, TKeyLNDatPr, THashFunc> KeyDatH;
930    TKeyL TimeKeyL;
931    void* RefToBs;
932    void Purge(const int64& MemToPurge);
933  public:
934    TCache(){}
935    TCache(const TCache&);
936    TCache(const int64& _MxMemUsed, const int& Ports, void* _RefToBs):
937      MxMemUsed(_MxMemUsed), CurMemUsed(0),
938      KeyDatH(Ports), TimeKeyL(), RefToBs(_RefToBs){}
939    TCache& operator=(const TCache&);
940    int64 GetMemUsed() const;
941    int64 GetMxMemUsed() const { return MxMemUsed; }
942    bool RefreshMemUsed();
943    void Put(const TKey& Key, const TDat& Dat);
944    bool Get(const TKey& Key, TDat& Dat);
945    void Del(const TKey& Key, const bool& DoEventCall=true);
946    void Flush();
947    void FlushAndClr();
948    void* FFirstKeyDat();
949    bool FNextKeyDat(void*& KeyDatP, TKey& Key, TDat& Dat);
950    void PutRefToBs(void* _RefToBs){RefToBs=_RefToBs;}
951    void* GetRefToBs(){return RefToBs;}
952  };
953  template <class TKey, class TDat, class THashFunc>
954  void TCache<TKey, TDat, THashFunc>::Purge(const int64& MemToPurge){
955    const int64 StartMemUsed = CurMemUsed;
956    while (!TimeKeyL.Empty()&&(StartMemUsed-CurMemUsed<MemToPurge)){
957      TKey Key=TimeKeyL.Last()->GetVal();
958      Del(Key);
959    }
960  }
961  template <class TKey, class TDat, class THashFunc>
962  int64 TCache<TKey, TDat, THashFunc>::GetMemUsed() const {
963    int64 MemUsed=0;
964    int KeyId=KeyDatH.FFirstKeyId();
965    while (KeyDatH.FNextKeyId(KeyId)){
966      const TKey& Key=KeyDatH.GetKey(KeyId);
967      const TKeyLNDatPr& KeyLNDatPr=KeyDatH[KeyId];
968      TDat Dat=KeyLNDatPr.Val2;
969      MemUsed+=int64(Key.GetMemUsed()+Dat->GetMemUsed());
970    }
971    return MemUsed;
972  }
973  template <class TKey, class TDat, class THashFunc>
974  bool TCache<TKey, TDat, THashFunc>::RefreshMemUsed(){
975    CurMemUsed=GetMemUsed();
976    if (CurMemUsed>MxMemUsed){
977      Purge(CurMemUsed-MxMemUsed);
978      return true;
979    }
980    return false;
981  }
982  template <class TKey, class TDat, class THashFunc>
983  void TCache<TKey, TDat, THashFunc>::Put(const TKey& Key, const TDat& Dat){
984    int KeyId=KeyDatH.GetKeyId(Key);
985    if (KeyId==-1){
986      int64 KeyDatMem=int64(Key.GetMemUsed()+Dat->GetMemUsed());
987      if (CurMemUsed+KeyDatMem>MxMemUsed){Purge(KeyDatMem);}
988      CurMemUsed+=KeyDatMem;
989      TKeyLN KeyLN=TimeKeyL.AddFront(Key);
990      TKeyLNDatPr KeyLNDatPr(KeyLN, Dat);
991      KeyDatH.AddDat(Key, KeyLNDatPr);
992    } else {
993      TKeyLNDatPr& KeyLNDatPr=KeyDatH[KeyId];
994      TKeyLN KeyLN=KeyLNDatPr.Val1;
995      KeyLNDatPr.Val2=Dat;
996      TimeKeyL.PutFront(KeyLN);
997    }
998  }
999  template <class TKey, class TDat, class THashFunc>
1000  bool TCache<TKey, TDat, THashFunc>::Get(const TKey& Key, TDat& Dat){
1001    int KeyId=KeyDatH.GetKeyId(Key);
1002    if (KeyId==-1){
1003      return false;
1004    } else {
1005      Dat=KeyDatH[KeyId].Val2;
1006      return true;
1007    }
1008  }
1009  template <class TKey, class TDat, class THashFunc>
1010  void TCache<TKey, TDat, THashFunc>::Del(const TKey& Key, const bool& DoEventCall){
1011    int KeyId=KeyDatH.GetKeyId(Key);
1012    if (KeyId!=-1){
1013      TKeyLNDatPr& KeyLNDatPr=KeyDatH[KeyId];
1014      TKeyLN KeyLN=KeyLNDatPr.Val1;
1015      TDat& Dat=KeyLNDatPr.Val2;
1016      if (DoEventCall){
1017        Dat->OnDelFromCache(Key, RefToBs);}
1018      CurMemUsed-=int64(Key.GetMemUsed()+Dat->GetMemUsed());
1019      Dat=NULL;
1020      TimeKeyL.Del(KeyLN);
1021      KeyDatH.DelKeyId(KeyId);
1022    }
1023  }
1024  template <class TKey, class TDat, class THashFunc>
1025  void TCache<TKey, TDat, THashFunc>::Flush(){
1026    printf("To flush: %d\n", KeyDatH.Len());
1027    int KeyId=KeyDatH.FFirstKeyId(); int Done = 0;
1028    while (KeyDatH.FNextKeyId(KeyId)){
1029      if (Done%10000==0){printf("%d\r", Done);}
1030      const TKey& Key=KeyDatH.GetKey(KeyId);
1031      TKeyLNDatPr& KeyLNDatPr=KeyDatH[KeyId];
1032      TDat Dat=KeyLNDatPr.Val2;
1033      Dat->OnDelFromCache(Key, RefToBs);
1034      Done++;
1035    }
1036    printf("Done %d\n", KeyDatH.Len());
1037  }
1038  template <class TKey, class TDat, class THashFunc>
1039  void TCache<TKey, TDat, THashFunc>::FlushAndClr(){
1040    Flush();
1041    CurMemUsed=0;
1042    KeyDatH.Clr();
1043    TimeKeyL.Clr();
1044  }
1045  template <class TKey, class TDat, class THashFunc>
1046  void* TCache<TKey, TDat, THashFunc>::FFirstKeyDat(){
1047    return TimeKeyL.First();
1048  }
1049  template <class TKey, class TDat, class THashFunc>
1050  bool TCache<TKey, TDat, THashFunc>::FNextKeyDat(void*& KeyDatP, TKey& Key, TDat& Dat){
1051    if (KeyDatP==NULL){
1052      return false;
1053    } else {
1054      Key=TKeyLN(KeyDatP)->GetVal(); Dat=KeyDatH.GetDat(Key).Val2;
1055      KeyDatP=TKeyLN(KeyDatP)->Next(); return true;
1056    }
1057  }
1058  class TStrHashF_OldGLib {
1059  public:
1060    inline static int GetPrimHashCd(const char *p) {
1061      const int MulBy = 16;  
1062      int HashCd = 0;
1063      while (*p) { HashCd = (MulBy * HashCd) + *p++; HashCd &= 0x0FFFFFFF; }
1064      return HashCd; }
1065    inline static int GetSecHashCd(const char *p) {
1066      const int MulBy = 16;  
1067      int HashCd = 0;
1068      while (*p) { HashCd = (MulBy * HashCd) ^ *p++; HashCd &= 0x0FFFFFFF; }
1069      return HashCd; }
1070    inline static int GetPrimHashCd(const TStr& s) { return GetPrimHashCd(s.CStr()); }
1071    inline static int GetSecHashCd(const TStr& s) { return GetSecHashCd(s.CStr()); }
1072  };
1073  class TStrHashF_Md5 {
1074  public:
1075    static int GetPrimHashCd(const char *p);
1076    static int GetSecHashCd(const char *p);
1077    static int GetPrimHashCd(const TStr& s);
1078    static int GetSecHashCd(const TStr& s);
1079  };
1080  class TStrHashF_DJB {
1081  private:
1082    inline static unsigned int DJBHash(const char* Str, const ::TSize& Len) {
1083      unsigned int hash = 5381;
1084      for(unsigned int i = 0; i < Len; Str++, i++) {
1085         hash = ((hash << 5) + hash) + (*Str); }
1086      return hash;
1087    }
1088  public:
1089    inline static int GetPrimHashCd(const char *p) {
1090      const char *r = p;  while (*r) { r++; }
1091      return (int) DJBHash((const char *) p, r - p) & 0x7fffffff; }
1092    inline static int GetSecHashCd(const char *p) {
1093      const char *r = p;  while (*r) { r++; }
1094      return (int) DJBHash((const char *) p, r - p) & 0x7fffffff; }
1095    inline static int GetPrimHashCd(const TStr& s) { 
1096      return GetPrimHashCd(s.CStr()); }
1097    inline static int GetSecHashCd(const TStr& s) { 
1098      return GetSecHashCd(s.CStr()); }
1099    inline static int GetPrimHashCd(const char *p, const ::TSize& Len) {
1100      return (int) DJBHash((const char *) p, Len) & 0x7fffffff; }
1101    inline static int GetSecHashCd(const char *p, const ::TSize& Len) {
1102      return (int) DJBHash((const char *) p, Len) & 0x7fffffff; }
1103  };
1104  template <class TVec>
1105  class TVecHashF_OldGLib {
1106  public:
1107    static inline int GetPrimHashCd(const TVec& Vec) {
1108      int HashCd=0;
1109      for (int ValN=0; ValN<Vec.Len(); ValN++){
1110        HashCd+=Vec[ValN].GetPrimHashCd();}
1111      return abs(HashCd);
1112    }
1113    inline static int GetSecHashCd(const TVec& Vec) {
1114      int HashCd=0;
1115      for (int ValN=0; ValN<Vec.Len(); ValN++){
1116        HashCd+=Vec[ValN].GetSecHashCd();}
1117      return abs(HashCd);
1118    }
1119  };
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-hash.h</h3>
            <pre><code>1  #include "bd.h"
2  #include <stdio.h>
3  #pragma pack(push, 1) 
4  template <class TKey, class TDat>
5  class THashKeyDat{
6  public:
7    TInt Next;
8    TInt HashCd;
9    TKey Key;
10    TDat Dat;
11  public:
12    THashKeyDat():
13      Next(-1), HashCd(-1), Key(), Dat(){}
14    THashKeyDat(const int& _Next, const int& _HashCd, const TKey& _Key):
15      Next(_Next), HashCd(_HashCd), Key(_Key), Dat(){}
16    explicit THashKeyDat(TSIn& SIn):
17      Next(SIn), HashCd(SIn), Key(SIn), Dat(SIn){}
18    void Save(TSOut& SOut) const {
19      Next.Save(SOut); HashCd.Save(SOut); Key.Save(SOut); Dat.Save(SOut);}
20    void LoadXml(const PXmlTok& XmlTok, const TStr& Nm="");
21    void SaveXml(TSOut& SOut, const TStr& Nm) const;
22    template<typename TDatFunctor>
23    void LoadShM(TShMIn& ShMIn, TDatFunctor LoadDatFromShared) {
24      Next = TInt(ShMIn);
25      HashCd = TInt(ShMIn);
26      TKey K(ShMIn);
27      Key = K;
28      LoadDatFromShared(&Dat, ShMIn);
29    }
30    bool operator==(const THashKeyDat& HashKeyDat) const {
31      if (this==&HashKeyDat || (HashCd==HashKeyDat.HashCd
32        && Key==HashKeyDat.Key && Dat==HashKeyDat.Dat)){return true;}
33      return false;}
34    THashKeyDat& operator=(const THashKeyDat& HashKeyDat){
35      if (this!=&HashKeyDat){
36        Next=HashKeyDat.Next; HashCd=HashKeyDat.HashCd;
37        Key=HashKeyDat.Key; Dat=HashKeyDat.Dat;}
38      return *this;}
39  };
40  #pragma pack(pop)
41  template<class TKey, class TDat>
42  class THashKeyDatI{
43  public:
44    typedef THashKeyDat<TKey, TDat> THKeyDat;
45  private:
46    THKeyDat* KeyDatI;
47    THKeyDat* EndI;
48  public:
49    THashKeyDatI(): KeyDatI(NULL), EndI(NULL){}
50    THashKeyDatI(const THashKeyDatI& _HashKeyDatI):
51      KeyDatI(_HashKeyDatI.KeyDatI), EndI(_HashKeyDatI.EndI){}
52    THashKeyDatI(const THKeyDat* _KeyDatI, const THKeyDat* _EndI):
53      KeyDatI((THKeyDat*)_KeyDatI), EndI((THKeyDat*)_EndI){}
54    THashKeyDatI& operator=(const THashKeyDatI& HashKeyDatI){
55      KeyDatI=HashKeyDatI.KeyDatI; EndI=HashKeyDatI.EndI; return *this;}
56    bool operator==(const THashKeyDatI& HashKeyDatI) const {
57      return KeyDatI==HashKeyDatI.KeyDatI;}
58    bool operator<(const THashKeyDatI& HashKeyDatI) const {
59      return KeyDatI<HashKeyDatI.KeyDatI;}
60    THashKeyDatI& operator++(int){ KeyDatI++; while (KeyDatI < EndI && KeyDatI->HashCd==-1) { KeyDatI++; } return *this; }
61    THashKeyDatI& operator--(int){ do { KeyDatI--; } while (KeyDatI->HashCd==-1); return *this;}
62    THKeyDat& operator*() const { return *KeyDatI; }
63    THKeyDat& operator()() const { return *KeyDatI; }
64    THKeyDat* operator->() const { return KeyDatI; }
65    THashKeyDatI& Next(){ operator++(1); return *this; }
66    bool IsEmpty() const { return KeyDatI == NULL; }
67    bool IsEnd() const { return EndI == KeyDatI; }
68    const TKey& GetKey() const {Assert((KeyDatI!=NULL)&&(KeyDatI->HashCd!=-1)); return KeyDatI->Key;}
69    const TDat& GetDat() const {Assert((KeyDatI!=NULL)&&(KeyDatI->HashCd!=-1)); return KeyDatI->Dat;}
70    TDat& GetDat() {Assert((KeyDatI!=NULL)&&(KeyDatI->HashCd!=-1)); return KeyDatI->Dat;}
71  };
72  template<class TKey>
73  class TDefaultHashFunc {
74  public:
75   static inline int GetPrimHashCd(const TKey& Key) { return Key.GetPrimHashCd(); }
76   static inline int GetSecHashCd(const TKey& Key) { return Key.GetSecHashCd(); }
77  };
78  template<class TKey, class TDat, class THashFunc = TDefaultHashFunc<TKey> >
79  class THash{
80  public:
81    enum {HashPrimes=32};
82    static const unsigned int HashPrimeT[HashPrimes];
83  public:
84    typedef THashKeyDatI<TKey, TDat> TIter;
85  private:
86    typedef THashKeyDat<TKey, TDat> THKeyDat;
87    typedef TPair<TKey, TDat> TKeyDatP;
88    TIntV PortV;
89    TVec<THKeyDat> KeyDatV;
90    TBool AutoSizeP;
91    TInt FFreeKeyId, FreeKeys;
92  private:
93    class THashKeyDatCmp {
94    public:
95      const THash<TKey, TDat, THashFunc>& Hash;
96      bool CmpKey, Asc;
97      THashKeyDatCmp(THash<TKey, TDat, THashFunc>& _Hash, const bool& _CmpKey, const bool& _Asc) :
98        Hash(_Hash), CmpKey(_CmpKey), Asc(_Asc) { }
99      bool operator () (const int& KeyId1, const int& KeyId2) const {
100        if (CmpKey) {
101          if (Asc) { return Hash.GetKey(KeyId1) < Hash.GetKey(KeyId2); }
102          else { return Hash.GetKey(KeyId2) < Hash.GetKey(KeyId1); } }
103        else {
104          if (Asc) { return Hash[KeyId1] < Hash[KeyId2]; }
105          else { return Hash[KeyId2] < Hash[KeyId1]; } } }
106    };
107    template<typename TDatInitFn>
108    class TLoadTHKeyDatInitializer {
109    private:
110      TDatInitFn DatInitFn;
111    public:
112      TLoadTHKeyDatInitializer(TDatInitFn Fn) { DatInitFn = Fn;}
113      void operator() (THKeyDat* HKeyDat, TShMIn& ShMIn) { HKeyDat->LoadShM(ShMIn, DatInitFn);}
114    };
115  private:
116    THKeyDat& GetHashKeyDat(const int& KeyId){
117      THKeyDat& KeyDat=KeyDatV[KeyId];
118      Assert(KeyDat.HashCd!=-1); return KeyDat;}
119    const THKeyDat& GetHashKeyDat(const int& KeyId) const {
120      const THKeyDat& KeyDat=KeyDatV[KeyId];
121      Assert(KeyDat.HashCd!=-1); return KeyDat;}
122    uint GetNextPrime(const uint& Val) const;
123    void Resize();
124  public:
125    THash():
126      PortV(), KeyDatV(),
127      AutoSizeP(true), FFreeKeyId(-1), FreeKeys(0){}
128    THash(const THash& Hash):
129      PortV(Hash.PortV), KeyDatV(Hash.KeyDatV), AutoSizeP(Hash.AutoSizeP),
130      FFreeKeyId(Hash.FFreeKeyId), FreeKeys(Hash.FreeKeys){}
131    explicit THash(const int& ExpectVals, const bool& _AutoSizeP=false);
132    explicit THash(TSIn& SIn):
133      PortV(SIn), KeyDatV(SIn),
134      AutoSizeP(SIn), FFreeKeyId(SIn), FreeKeys(SIn){
135      SIn.LoadCs();}
136    void LoadShM(TShMIn& ShMIn) {
137      PortV.LoadShM(ShMIn);
138      KeyDatV.Load(ShMIn);
139      AutoSizeP=TBool(ShMIn);
140      FFreeKeyId=TInt(ShMIn);
141      FreeKeys=TInt(ShMIn);
142      ShMIn.LoadCs();
143    }
144    template <typename TDatInitFn>
145    void LoadShM(TShMIn& ShMIn, TDatInitFn Fn) {
146      TLoadTHKeyDatInitializer<TDatInitFn> HKeyDatFn(Fn);
147      PortV.LoadShM(ShMIn);
148      KeyDatV.LoadShM(ShMIn, HKeyDatFn);
149      AutoSizeP=TBool(ShMIn);
150      FFreeKeyId=TInt(ShMIn);
151      FreeKeys=TInt(ShMIn);
152      ShMIn.LoadCs();
153    }
154    void Load(TSIn& SIn){
155      PortV.Load(SIn); KeyDatV.Load(SIn);
156      AutoSizeP=TBool(SIn); FFreeKeyId=TInt(SIn); FreeKeys=TInt(SIn);
157      SIn.LoadCs();
158    }
159    void Save(TSOut& SOut) const {
160      PortV.Save(SOut); KeyDatV.Save(SOut);
161      AutoSizeP.Save(SOut); FFreeKeyId.Save(SOut); FreeKeys.Save(SOut);
162      SOut.SaveCs();}
163    void LoadXml(const PXmlTok& XmlTok, const TStr& Nm="");
164    void SaveXml(TSOut& SOut, const TStr& Nm);
165    THash& operator=(const THash& Hash){
166      if (this!=&Hash){
167        PortV=Hash.PortV; KeyDatV=Hash.KeyDatV; AutoSizeP=Hash.AutoSizeP;
168        FFreeKeyId=Hash.FFreeKeyId; FreeKeys=Hash.FreeKeys;}
169      return *this;}
170    bool operator==(const THash& Hash) const; 
171    bool operator < (const THash& Hash) const { Fail; return true; }
172    const TDat& operator[](const int& KeyId) const {return GetHashKeyDat(KeyId).Dat;}
173    TDat& operator[](const int& KeyId){return GetHashKeyDat(KeyId).Dat;}
174    TDat& operator()(const TKey& Key){return AddDat(Key);}
175    ::TSize GetMemUsed() const {
176        int64 MemUsed = sizeof(bool)+2*sizeof(int);
177        MemUsed += int64(PortV.Reserved()) * int64(sizeof(TInt));
178        for (int KeyDatN = 0; KeyDatN < KeyDatV.Len(); KeyDatN++) {
179            MemUsed += int64(2 * sizeof(TInt));
180            MemUsed += int64(KeyDatV[KeyDatN].Key.GetMemUsed());
181            MemUsed += int64(KeyDatV[KeyDatN].Dat.GetMemUsed());
182        }
183        return ::TSize(MemUsed);
184    }
185    TIter BegI() const {
186      if (Len() == 0){return TIter(KeyDatV.EndI(), KeyDatV.EndI());}
187      if (IsKeyIdEqKeyN()) { return TIter(KeyDatV.BegI(), KeyDatV.EndI());}
188      int FKeyId=-1;  FNextKeyId(FKeyId);
189      return TIter(KeyDatV.BegI()+FKeyId, KeyDatV.EndI()); }
190    TIter EndI() const {return TIter(KeyDatV.EndI(), KeyDatV.EndI());}
191    TIter GetI(const TKey& Key) const {return TIter(&KeyDatV[GetKeyId(Key)], KeyDatV.EndI());}
192    void Gen(const int& ExpectVals){
193      PortV.Gen(GetNextPrime(ExpectVals/2)); KeyDatV.Gen(ExpectVals, 0);
194      FFreeKeyId=-1; FreeKeys=0; PortV.PutAll(TInt(-1));}
195    void Clr(const bool& DoDel=true, const int& NoDelLim=-1, const bool& ResetDat=true);
196    bool Empty() const {return Len()==0;}
197    int Len() const {return KeyDatV.Len()-FreeKeys;}
198    int GetPorts() const {return PortV.Len();}
199    bool IsAutoSize() const {return AutoSizeP;}
200    int GetMxKeyIds() const {return KeyDatV.Len();}
201    int GetReservedKeyIds() const {return KeyDatV.Reserved();}
202    bool IsKeyIdEqKeyN() const {return FreeKeys==0;}
203    int AddKey(const TKey& Key);
204    TDat& AddDatId(const TKey& Key){
205      int KeyId=AddKey(Key); return KeyDatV[KeyId].Dat=KeyId;}
206    TDat& AddDat(const TKey& Key){return KeyDatV[AddKey(Key)].Dat;}
207    TDat& AddDat(const TKey& Key, const TDat& Dat){
208      return KeyDatV[AddKey(Key)].Dat=Dat;}
209    void DelKey(const TKey& Key);
210    bool DelIfKey(const TKey& Key){
211      int KeyId; if (IsKey(Key, KeyId)){DelKeyId(KeyId); return true;} return false;}
212    void DelKeyId(const int& KeyId){DelKey(GetKey(KeyId));}
213    void DelKeyIdV(const TIntV& KeyIdV){
214      for (int KeyIdN=0; KeyIdN<KeyIdV.Len(); KeyIdN++){DelKeyId(KeyIdV[KeyIdN]);}}
215    void MarkDelKey(const TKey& Key); 
216    void MarkDelKeyId(const int& KeyId){MarkDelKey(GetKey(KeyId));}
217    const TKey& GetKey(const int& KeyId) const { return GetHashKeyDat(KeyId).Key;}
218    int GetKeyId(const TKey& Key) const;
219    int GetRndKeyId(TRnd& Rnd) const;
220    int GetRndKeyId(TRnd& Rnd, const double& EmptyFrac);
221    bool IsKey(const TKey& Key) const {return GetKeyId(Key)!=-1;}
222    bool IsKey(const TKey& Key, int& KeyId) const { KeyId=GetKeyId(Key); return KeyId!=-1;}
223    bool IsKeyId(const int& KeyId) const {
224      return (0<=KeyId)&&(KeyId<KeyDatV.Len())&&(KeyDatV[KeyId].HashCd!=-1);}
225    const TDat& GetDat(const TKey& Key) const {return KeyDatV[GetKeyId(Key)].Dat;}
226    TDat& GetDat(const TKey& Key){return KeyDatV[GetKeyId(Key)].Dat;}
227    TDat GetDatWithDefault(const TKey& Key, TDat DefaultValue) {
228      int KeyId = GetKeyId(Key);
229      return KeyId >= 0 ? KeyDatV[KeyId].Dat : DefaultValue;
230    }
231    void GetKeyDat(const int& KeyId, TKey& Key, TDat& Dat) const {
232      const THKeyDat& KeyDat=GetHashKeyDat(KeyId);
233      Key=KeyDat.Key; Dat=KeyDat.Dat;}
234    bool IsKeyGetDat(const TKey& Key, TDat& Dat) const {int KeyId;
235      if (IsKey(Key, KeyId)){Dat=GetHashKeyDat(KeyId).Dat; return true;}
236      else {return false;}}
237    int FFirstKeyId() const {return 0-1;}
238    bool FNextKeyId(int& KeyId) const;
239    void GetKeyV(TVec<TKey>& KeyV) const;
240    void GetDatV(TVec<TDat>& DatV) const;
241    void GetKeyDatPrV(TVec<TPair<TKey, TDat> >& KeyDatPrV) const;
242    void GetDatKeyPrV(TVec<TPair<TDat, TKey> >& DatKeyPrV) const;
243    void GetKeyDatKdV(TVec<TKeyDat<TKey, TDat> >& KeyDatKdV) const;
244    void GetDatKeyKdV(TVec<TKeyDat<TDat, TKey> >& DatKeyKdV) const;
245    void Swap(THash& Hash);
246    void Defrag();
247    void Pack(){KeyDatV.Pack();}
248    void Sort(const bool& CmpKey, const bool& Asc);
249    void SortByKey(const bool& Asc=true) { Sort(true, Asc); }
250    void SortByDat(const bool& Asc=true) { Sort(false, Asc); }
251  };
252  template<class TKey, class TDat, class THashFunc>
253  const unsigned int THash<TKey, TDat, THashFunc>::HashPrimeT[HashPrimes]={
254    3ul, 5ul, 11ul, 23ul,
255    53ul,         97ul,         193ul,       389ul,       769ul,
256    1543ul,       3079ul,       6151ul,      12289ul,     24593ul,
257    49157ul,      98317ul,      196613ul,    393241ul,    786433ul,
258    1572869ul,    3145739ul,    6291469ul,   12582917ul,  25165843ul,
259    50331653ul,   100663319ul,  201326611ul, 402653189ul, 805306457ul,
260    1610612741ul, 3221225473ul, 4294967291ul
261  };
262  template<class TKey, class TDat, class THashFunc>
263  uint THash<TKey, TDat, THashFunc>::GetNextPrime(const uint& Val) const {
264    const uint* f=(const uint*)HashPrimeT, *m, *l=(const uint*)HashPrimeT + (int)HashPrimes;
265    int h, len = (int)HashPrimes;
266    while (len > 0) {
267      h = len >> 1;  m = f + h;
268      if (*m < Val) { f = m;  f++;  len = len - h - 1; }
269      else len = h;
270    }
271    return f == l ? *(l - 1) : *f;
272  }
273  template<class TKey, class TDat, class THashFunc>
274  void THash<TKey, TDat, THashFunc>::Resize(){
275    if (PortV.Len()==0){
276      PortV.Gen(17);
277    } else if (AutoSizeP&&(KeyDatV.Len()>2*PortV.Len())){
278      PortV.Gen(GetNextPrime(PortV.Len()+1));
279    } else {
280      return;
281    }
282    PortV.PutAll(TInt(-1));
283    for (int KeyId=0; KeyId<KeyDatV.Len(); KeyId++){
284      THKeyDat& KeyDat=KeyDatV[KeyId];
285      if (KeyDat.HashCd!=-1){
286        const int PortN = abs(THashFunc::GetPrimHashCd(KeyDat.Key) % PortV.Len());
287        KeyDat.Next=PortV[PortN];
288        PortV[PortN]=KeyId;
289      }
290    }
291  }
292  template<class TKey, class TDat, class THashFunc>
293  THash<TKey, TDat, THashFunc>::THash(const int& ExpectVals, const bool& _AutoSizeP):
294    PortV(GetNextPrime(ExpectVals/2)), KeyDatV(ExpectVals, 0),
295    AutoSizeP(_AutoSizeP), FFreeKeyId(-1), FreeKeys(0){
296    PortV.PutAll(TInt(-1));
297  }
298  template<class TKey, class TDat, class THashFunc>
299  bool THash<TKey, TDat, THashFunc>::operator==(const THash& Hash) const {
300    if (Len() != Hash.Len()) { return false; }
301    for (int i = FFirstKeyId(); FNextKeyId(i); ) {
302      const TKey& Key = GetKey(i);
303      if (! Hash.IsKey(Key)) { return false; }
304      if (GetDat(Key) != Hash.GetDat(Key)) { return false; }
305    }
306    return true;
307  }
308  template<class TKey, class TDat, class THashFunc>
309  void THash<TKey, TDat, THashFunc>::Clr(const bool& DoDel, const int& NoDelLim, const bool& ResetDat){
310    if (DoDel){
311      PortV.Clr(); KeyDatV.Clr();
312    } else {
313      PortV.PutAll(TInt(-1));
314      KeyDatV.Clr(DoDel, NoDelLim);
315      if (ResetDat){KeyDatV.PutAll(THKeyDat());}
316    }
317    FFreeKeyId=TInt(-1); FreeKeys=TInt(0);
318  }
319  template<class TKey, class TDat, class THashFunc>
320  int THash<TKey, TDat, THashFunc>::AddKey(const TKey& Key){
321    if ((KeyDatV.Len()>2*PortV.Len())||PortV.Empty()){Resize();}
322    const int PortN=abs(THashFunc::GetPrimHashCd(Key)%PortV.Len());
323    const int HashCd=abs(THashFunc::GetSecHashCd(Key));
324    int PrevKeyId=-1;
325    int KeyId=PortV[PortN];
326    while ((KeyId!=-1) &&
327     !((KeyDatV[KeyId].HashCd==HashCd) && (KeyDatV[KeyId].Key==Key))){
328      PrevKeyId=KeyId; KeyId=KeyDatV[KeyId].Next;}
329    if (KeyId==-1){
330      if (FFreeKeyId==-1){
331        KeyId=KeyDatV.Add(THKeyDat(-1, HashCd, Key));
332      } else {
333        KeyId=FFreeKeyId; FFreeKeyId=KeyDatV[FFreeKeyId].Next; FreeKeys--;
334        KeyDatV[KeyId].Next=-1;
335        KeyDatV[KeyId].HashCd=HashCd;
336        KeyDatV[KeyId].Key=Key;
337      }
338      if (PrevKeyId==-1){
339        PortV[PortN]=KeyId;
340      } else {
341        KeyDatV[PrevKeyId].Next=KeyId;
342      }
343    }
344    return KeyId;
345  }
346  template<class TKey, class TDat, class THashFunc>
347  void THash<TKey, TDat, THashFunc>::DelKey(const TKey& Key){
348    IAssert(!PortV.Empty());
349    const int PortN=abs(THashFunc::GetPrimHashCd(Key)%PortV.Len());
350    const int HashCd=abs(THashFunc::GetSecHashCd(Key));
351    int PrevKeyId=-1;
352    int KeyId=PortV[PortN];
353    while ((KeyId!=-1) &&
354     !((KeyDatV[KeyId].HashCd==HashCd) && (KeyDatV[KeyId].Key==Key))){
355      PrevKeyId=KeyId; KeyId=KeyDatV[KeyId].Next;}
356    IAssert(KeyId!=-1); 
357    if (PrevKeyId==-1){PortV[PortN]=KeyDatV[KeyId].Next;}
358    else {KeyDatV[PrevKeyId].Next=KeyDatV[KeyId].Next;}
359    KeyDatV[KeyId].Next=FFreeKeyId; FFreeKeyId=KeyId; FreeKeys++;
360    KeyDatV[KeyId].HashCd=TInt(-1);
361    KeyDatV[KeyId].Key=TKey();
362    KeyDatV[KeyId].Dat=TDat();
363  }
364  template<class TKey, class TDat, class THashFunc>
365  void THash<TKey, TDat, THashFunc>::MarkDelKey(const TKey& Key){
366    IAssert(!PortV.Empty());
367    const int PortN=abs(THashFunc::GetPrimHashCd(Key)%PortV.Len());
368    const int HashCd=abs(THashFunc::GetSecHashCd(Key));
369    int PrevKeyId=-1;
370    int KeyId=PortV[PortN];
371    while ((KeyId!=-1) &&
372     !((KeyDatV[KeyId].HashCd==HashCd) && (KeyDatV[KeyId].Key==Key))){
373      PrevKeyId=KeyId; KeyId=KeyDatV[KeyId].Next;}
374    IAssertR(KeyId!=-1, Key.GetStr());
375    if (PrevKeyId==-1){PortV[PortN]=KeyDatV[KeyId].Next;}
376    else {KeyDatV[PrevKeyId].Next=KeyDatV[KeyId].Next;}
377    KeyDatV[KeyId].Next=FFreeKeyId; FFreeKeyId=KeyId; FreeKeys++;
378    KeyDatV[KeyId].HashCd=TInt(-1);
379  }
380  template<class TKey, class TDat, class THashFunc>
381  int THash<TKey, TDat, THashFunc>::GetRndKeyId(TRnd& Rnd) const  {
382    IAssert(! Empty());
383    int KeyId = abs(Rnd.GetUniDevInt(KeyDatV.Len()));
384    while (KeyDatV[KeyId].HashCd == -1) { 
385      KeyId = abs(Rnd.GetUniDevInt(KeyDatV.Len())); }
386    return KeyId;
387  }
388  template<class TKey, class TDat, class THashFunc>
389  int THash<TKey, TDat, THashFunc>::GetRndKeyId(TRnd& Rnd, const double& EmptyFrac) {
390    IAssert(! Empty());
391    if (FreeKeys/double(Len()+FreeKeys) > EmptyFrac) { Defrag(); }
392    int KeyId = Rnd.GetUniDevInt(KeyDatV.Len());
393    while (KeyDatV[KeyId].HashCd == -1) { 
394      KeyId = Rnd.GetUniDevInt(KeyDatV.Len());
395    }
396    return KeyId;
397  }
398  template<class TKey, class TDat, class THashFunc>
399  int THash<TKey, TDat, THashFunc>::GetKeyId(const TKey& Key) const {
400    if (PortV.Empty()){return -1;}
401    const int PortN=abs(THashFunc::GetPrimHashCd(Key)%PortV.Len());
402    const int HashCd=abs(THashFunc::GetSecHashCd(Key));
403    int KeyId=PortV[PortN];
404    while ((KeyId!=-1) &&
405     !((KeyDatV[KeyId].HashCd==HashCd) && (KeyDatV[KeyId].Key==Key))){
406      KeyId=KeyDatV[KeyId].Next;}
407    return KeyId;
408  }
409  template<class TKey, class TDat, class THashFunc>
410  bool THash<TKey, TDat, THashFunc>::FNextKeyId(int& KeyId) const {
411    do {KeyId++;} while ((KeyId<KeyDatV.Len()) && (KeyDatV[KeyId].HashCd==-1));
412    return KeyId<KeyDatV.Len();
413  }
414  template<class TKey, class TDat, class THashFunc>
415  void THash<TKey, TDat, THashFunc>::GetKeyV(TVec<TKey>& KeyV) const {
416    KeyV.Gen(Len(), 0);
417    int KeyId=FFirstKeyId();
418    while (FNextKeyId(KeyId)){
419      KeyV.Add(GetKey(KeyId));}
420  }
421  template<class TKey, class TDat, class THashFunc>
422  void THash<TKey, TDat, THashFunc>::GetDatV(TVec<TDat>& DatV) const {
423    DatV.Gen(Len(), 0);
424    int KeyId=FFirstKeyId();
425    while (FNextKeyId(KeyId)){
426      DatV.Add(GetHashKeyDat(KeyId).Dat);}
427  }
428  template<class TKey, class TDat, class THashFunc>
429  void THash<TKey, TDat, THashFunc>::GetKeyDatPrV(TVec<TPair<TKey, TDat> >& KeyDatPrV) const {
430    KeyDatPrV.Gen(Len(), 0);
431    TKey Key; TDat Dat;
432    int KeyId=FFirstKeyId();
433    while (FNextKeyId(KeyId)){
434      GetKeyDat(KeyId, Key, Dat);
435      KeyDatPrV.Add(TPair<TKey, TDat>(Key, Dat));
436    }
437  }
438  template<class TKey, class TDat, class THashFunc>
439  void THash<TKey, TDat, THashFunc>::GetDatKeyPrV(TVec<TPair<TDat, TKey> >& DatKeyPrV) const {
440    DatKeyPrV.Gen(Len(), 0);
441    TKey Key; TDat Dat;
442    int KeyId=FFirstKeyId();
443    while (FNextKeyId(KeyId)){
444      GetKeyDat(KeyId, Key, Dat);
445      DatKeyPrV.Add(TPair<TDat, TKey>(Dat, Key));
446    }
447  }
448  template<class TKey, class TDat, class THashFunc>
449  void THash<TKey, TDat, THashFunc>::GetKeyDatKdV(TVec<TKeyDat<TKey, TDat> >& KeyDatKdV) const {
450    KeyDatKdV.Gen(Len(), 0);
451    TKey Key; TDat Dat;
452    int KeyId=FFirstKeyId();
453    while (FNextKeyId(KeyId)){
454      GetKeyDat(KeyId, Key, Dat);
455      KeyDatKdV.Add(TKeyDat<TKey, TDat>(Key, Dat));
456    }
457  }
458  template<class TKey, class TDat, class THashFunc>
459  void THash<TKey, TDat, THashFunc>::GetDatKeyKdV(TVec<TKeyDat<TDat, TKey> >& DatKeyKdV) const {
460    DatKeyKdV.Gen(Len(), 0);
461    TKey Key; TDat Dat;
462    int KeyId=FFirstKeyId();
463    while (FNextKeyId(KeyId)){
464      GetKeyDat(KeyId, Key, Dat);
465      DatKeyKdV.Add(TKeyDat<TDat, TKey>(Dat, Key));
466    }
467  }
468  template<class TKey, class TDat, class THashFunc>
469  void THash<TKey, TDat, THashFunc>::Swap(THash& Hash) {
470    if (this!=&Hash){
471      PortV.Swap(Hash.PortV);
472      KeyDatV.Swap(Hash.KeyDatV);
473      ::Swap(AutoSizeP, Hash.AutoSizeP);
474      ::Swap(FFreeKeyId, Hash.FFreeKeyId);
475      ::Swap(FreeKeys, Hash.FreeKeys);
476    }
477  }
478  template<class TKey, class TDat, class THashFunc>
479  void THash<TKey, TDat, THashFunc>::Defrag(){
480    if (!IsKeyIdEqKeyN()){
481      THash<TKey, TDat, THashFunc> Hash(PortV.Len());
482      int KeyId=FFirstKeyId(); TKey Key; TDat Dat;
483      while (FNextKeyId(KeyId)){
484        GetKeyDat(KeyId, Key, Dat);
485        Hash.AddDat(Key, Dat);
486      }
487      Pack();
<span onclick='openModal()' class='match'>488      operator=(Hash);
489      IAssert(IsKeyIdEqKeyN());
490    }
491  }
492  template<class TKey, class TDat, class THashFunc>
</span>493  void THash<TKey, TDat, THashFunc>::Sort(const bool& CmpKey, const bool& Asc) {
494    IAssertR(IsKeyIdEqKeyN(), "THash::Sort only works when table has no deleted keys.");
495    TIntV TargV(Len()), MapV(Len()), StateV(Len());
496    for (int i = 0; i < TargV.Len(); i++) {
497      TargV[i] = i; MapV[i] = i; StateV[i] = i;
498    }
499    THashKeyDatCmp HashCmp(*this, CmpKey, Asc);
500    TargV.SortCmp(HashCmp);
501    THashKeyDat<TKey, TDat> Tmp;
502    for (int i = 0; i < TargV.Len()-1; i++) {
503      const int SrcPos = MapV[TargV[i]];
504      const int Loc = i;
505      Tmp = KeyDatV[SrcPos];
506      KeyDatV[SrcPos] = KeyDatV[Loc];
507      KeyDatV[Loc] = Tmp;
508      MapV[StateV[i]] = SrcPos;
509      StateV.Swap(Loc, SrcPos);
510    }
511    for (int i = 0; i < TargV.Len(); i++) {
512      MapV[TargV[i]] = i; }
513    for (int p = 0; p < PortV.Len(); p++) {
514      if (PortV[p] != -1) {
515        PortV[p] = MapV[PortV[p]]; } }
516    for (int i = 0; i < KeyDatV.Len(); i++) {
517      if (KeyDatV[i].Next != -1) {
518        KeyDatV[i].Next = MapV[KeyDatV[i].Next]; }
519    }
520  }
521  typedef THash<TCh, TCh> TChChH;
522  typedef THash<TChTr, TInt> TChTrIntH;
523  typedef THash<TInt, TInt> TIntH;
524  typedef THash<TUInt64, TInt> TUInt64H;
525  typedef THash<TInt, TBool> TIntBoolH;
526  typedef THash<TInt, TInt> TIntIntH;
527  typedef THash<TInt, TUInt64> TIntUInt64H;
528  typedef THash<TInt, TIntFltPr> TIntIntFltPrH;
529  typedef THash<TInt, TIntV> TIntIntVH;
530  typedef THash<TInt, TIntH> TIntIntHH;
531  typedef THash<TInt, TFlt> TIntFltH;
532  typedef THash<TInt, TFltPr> TIntFltPrH;
533  typedef THash<TInt, TFltTr> TIntFltTrH;
534  typedef THash<TInt, TFltV> TIntFltVH;
535  typedef THash<TInt, TStr> TIntStrH;
536  typedef THash<TInt, TStrV> TIntStrVH;
537  typedef THash<TInt, TStrPrV> TIntStrPrVH;
538  typedef THash<TInt, TIntPr> TIntIntPrH;
539  typedef THash<TInt, TIntPrV> TIntIntPrVH;
540  typedef THash<TInt, TIntStrPr> TIntIntStrPrH;
541  typedef THash<TInt, TIntVFltVPr> TIntIntVFltVPrH;
542  typedef THash<TUInt64, TStrV> TUInt64StrVH;
543  typedef THash<TIntPr, TInt> TIntPrIntH;
544  typedef THash<TIntPr, TIntPr> TIntPrH;
545  typedef THash<TIntPr, TIntV> TIntPrIntVH;
546  typedef THash<TIntPr, TIntPrV> TIntPrIntPrVH;
547  typedef THash<TIntTr, TInt> TIntTrIntH;
548  typedef THash<TIntV, TInt> TIntVIntH;
549  typedef THash<TUInt, TUInt> TUIntH;
550  typedef THash<TIntPr, TInt> TIntPrIntH;
551  typedef THash<TIntPr, TIntV> TIntPrIntVH;
552  typedef THash<TIntPr, TFlt> TIntPrFltH;
553  typedef THash<TIntTr, TFlt> TIntTrFltH;
554  typedef THash<TIntPr, TStr> TIntPrStrH;
555  typedef THash<TIntPr, TStrV> TIntPrStrVH;
556  typedef THash<TIntStrPr, TInt> TIntStrPrIntH;
557  typedef THash<TIntIntPrPr, TInt> TIntIntPrPrIntH;
558  typedef THash<TIntIntPrPr, TFlt> TIntIntPrPrFltH;
559  typedef THash<TIntIntPrPr, TStr> TIntIntPrPrStrH;
560  typedef THash<TFlt, TFlt> TFltFltH;
561  typedef THash<TStr, TInt> TStrH;
562  typedef THash<TStr, TBool> TStrBoolH;
563  typedef THash<TStr, TInt> TStrIntH;
564  typedef THash<TStr, TIntPr> TStrIntPrH;
565  typedef THash<TStr, TIntV> TStrIntVH;
566  typedef THash<TStr, TUInt64> TStrUInt64H;
567  typedef THash<TStr, TUInt64V> TStrUInt64VH;
568  typedef THash<TStr, TIntPrV> TStrIntPrVH;
569  typedef THash<TStr, TFlt> TStrFltH;
570  typedef THash<TStr, TFltV> TStrFltVH;
571  typedef THash<TStr, TStr> TStrStrH;
572  typedef THash<TStr, TStrPr> TStrStrPrH;
573  typedef THash<TStr, TStrV> TStrStrVH;
574  typedef THash<TStr, TStrPrV> TStrStrPrVH;
575  typedef THash<TStr, TStrKdV> TStrStrKdVH;
576  typedef THash<TStr, TIntFltPr> TStrIntFltPrH;
577  typedef THash<TStr, TStrIntPrV> TStrStrIntPrVH;
578  typedef THash<TStr, TStrIntKdV> TStrStrIntKdVH;
579  typedef THash<TDbStr, TInt> TDbStrIntH;
580  typedef THash<TDbStr, TStr> TDbStrStrH;
581  typedef THash<TStrPr, TBool> TStrPrBoolH;
582  typedef THash<TStrPr, TInt> TStrPrIntH;
583  typedef THash<TStrPr, TFlt> TStrPrFltH;
584  typedef THash<TStrPr, TStr> TStrPrStrH;
585  typedef THash<TStrPr, TStrV> TStrPrStrVH;
586  typedef THash<TStrTr, TInt> TStrTrIntH;
587  typedef THash<TStrIntPr, TInt> TStrIntPrIntH;
588  typedef THash<TStrV, TInt> TStrVH;
589  typedef THash<TStrV, TInt> TStrVIntH;
590  typedef THash<TStrV, TIntV> TStrVIntVH;
591  typedef THash<TStrV, TStr> TStrVStrH;
592  typedef THash<TStrV, TStrV> TStrVStrVH;
593  template <class TKey, class TDat>
594  class PHash{
595  private:
596    TCRef CRef;
597  public:
598    THash<TKey, TDat> H;
599  public:
600    PHash<TKey, TDat>(): H(){}
601    static TPt<PHash<TKey, TDat> > New(){
602      return new PHash<TKey, TDat>();}
603    PHash<TKey, TDat>(const int& MxVals, const int& Vals): H(MxVals, Vals){}
604    static TPt<PHash<TKey, TDat> > New(const int& MxVals, const int& Vals){
605      return new PHash<TKey, TDat>(MxVals, Vals);}
606    PHash<TKey, TDat>(const THash<TKey, TDat>& _V): H(_V){}
607    static TPt<PHash<TKey, TDat> > New(const THash<TKey, TDat>& H){
608      return new PHash<TKey, TDat>(H);}
609    explicit PHash<TKey, TDat>(TSIn& SIn): H(SIn){}
610    static TPt<PHash<TKey, TDat> > Load(TSIn& SIn){return new PHash<TKey, TDat>(SIn);}
611    void Save(TSOut& SOut) const {H.Save(SOut);}
612    PHash<TKey, TDat>& operator=(const PHash<TKey, TDat>& Vec){
613      if (this!=&Vec){H=Vec.H;} return *this;}
614    bool operator==(const PHash<TKey, TDat>& Vec) const {return H==Vec.H;}
615    bool operator<(const PHash<TKey, TDat>& Vec) const {return H<Vec.H;}
616    friend class TPt<PHash<TKey, TDat> >;
617  };
618  ClassTP(TBigStrPool, PBigStrPool)
619  private:
620    TSize MxBfL, BfL;
621    uint GrowBy;
622    char *Bf;
623    TVec<TSize> IdOffV; 
624    bool IsShM; 
625  private:
626    void Resize(TSize _MxBfL);
627    void LoadPoolShM(TShMIn& ShMIn, bool LoadCompact = true);
628  public:
629    TBigStrPool(TSize MxBfLen = 0, uint _GrowBy = 16*1024*1024);
630    TBigStrPool(TSIn& SIn, bool LoadCompact = true);
631    TBigStrPool(const TBigStrPool& Pool) : MxBfL(Pool.MxBfL), BfL(Pool.BfL), GrowBy(Pool.GrowBy) {
632      Bf = (char *) malloc(Pool.MxBfL); IAssert(Bf); memcpy(Bf, Pool.Bf, Pool.BfL); }
633    ~TBigStrPool() { if (Bf && !IsShM) free(Bf); else IAssert(MxBfL == 0 || IsShM);  MxBfL = 0; BfL = 0; }
634    static PBigStrPool New(TSize _MxBfLen = 0, uint _GrowBy = 16*1024*1024) { return PBigStrPool(new TBigStrPool(_MxBfLen, _GrowBy)); }
635    static PBigStrPool New(TSIn& SIn) { return new TBigStrPool(SIn); }
636    static PBigStrPool New(const TStr& fileName) { PSIn SIn = TFIn::New(fileName); return new TBigStrPool(*SIn); }
637    static PBigStrPool Load(TSIn& SIn, bool LoadCompacted = true) { return PBigStrPool(new TBigStrPool(SIn, LoadCompacted)); }
638    static PBigStrPool LoadShM(TShMIn& ShMIn, bool LoadCompact = true) {
639      TBigStrPool* StrPool = new TBigStrPool();
640      StrPool->LoadPoolShM(ShMIn, LoadCompact);
641      return PBigStrPool(StrPool);
642    }
643    void Save(TSOut& SOut) const;
644    void Save(const TStr& fileName) { TFOut FOut(fileName); Save(FOut); }
645    int GetStrs() const { return IdOffV.Len(); }
646    TSize Len() const { return BfL; }
647    TSize Size() const { return MxBfL; }
648    bool Empty() const { return ! Len(); }
649    char* operator () () const { return Bf; }
650    TBigStrPool& operator = (const TBigStrPool& Pool);
651    ::TSize GetMemUsed(){
652    	return 4 * sizeof(int) + IdOffV.GetMemUsed() + MxBfL;
653    }
654    int AddStr(const char *Str, uint Len);
655    int AddStr(const char *Str) { return AddStr(Str, uint(strlen(Str)) + 1); }
656    int AddStr(const TStr& Str) { return AddStr(Str.CStr(), Str.Len() + 1); }
657    TStr GetStr(const int& StrId) const { Assert(StrId < GetStrs());
658      if (StrId == 0) return TStr::GetNullStr(); else return TStr(Bf + (TSize)IdOffV[StrId]); }
659    const char *GetCStr(const int& StrId) const { Assert(StrId < GetStrs());
660      if (StrId == 0) return TStr::GetNullStr().CStr(); else return (Bf + (TSize)IdOffV[StrId]); }
661    TStr GetStrFromOffset(const TSize& Offset) const { Assert(Offset < BfL);
662      if (Offset == 0) return TStr::GetNullStr(); else return TStr(Bf + Offset); }
663    const char *GetCStrFromOffset(const TSize& Offset) const { Assert(Offset < BfL);
664      if (Offset == 0) return TStr::GetNullStr().CStr(); else return Bf + Offset; }
665    void Clr(bool DoDel = false) {
666      BfL = 0; if (DoDel && Bf) {if (!IsShM) { free(Bf);} Bf = 0; MxBfL = 0;}}
667    int Cmp(const int& StrId, const char *Str) const { Assert(StrId < GetStrs());
668      if (StrId != 0) return strcmp(Bf + (TSize)IdOffV[StrId], Str); else return strcmp("", Str); }
669    static int GetPrimHashCd(const char *CStr);
670    static int GetSecHashCd(const char *CStr);
671    int GetPrimHashCd(const int& StrId) { Assert(StrId < GetStrs());
672      if (StrId != 0) return GetPrimHashCd(Bf + (TSize)IdOffV[StrId]); else return GetPrimHashCd(""); }
673    int GetSecHashCd(const int& StrId) { Assert(StrId < GetStrs());
674      if (StrId != 0) return GetSecHashCd(Bf + (TSize)IdOffV[StrId]); else return GetSecHashCd(""); }
675  };
676  template <class TDat, class TStringPool = TStrPool, class THashFunc = TDefaultHashFunc<TStr> >
677  class TStrHash{
678  public:
679    typedef TPt<TStringPool> PStringPool;
680  private:
681    typedef THashKeyDat<TInt, TDat> THKeyDat;
682    typedef TPair<TInt, TDat> TKeyDatP;
683    typedef TVec<THKeyDat> THKeyDatV;
684    TIntV PortV;
685    THKeyDatV KeyDatV;
686    TBool AutoSizeP;
687    TInt FFreeKeyId, FreeKeys;
688    PStringPool Pool;
689  private:
690    uint GetNextPrime(const uint& Val) const;
691    void Resize();
692    const THKeyDat& GetHashKeyDat(const int& KeyId) const {
693      const THKeyDat& KeyDat = KeyDatV[KeyId];  Assert(KeyDat.HashCd != -1);  return KeyDat; }
694    THKeyDat& GetHashKeyDat(const int& KeyId) {
695      THKeyDat& KeyDat = KeyDatV[KeyId];  Assert(KeyDat.HashCd != -1);  return KeyDat; }
696  public:
697    TStrHash(): PortV(), KeyDatV(), AutoSizeP(true), FFreeKeyId(-1), FreeKeys(0), Pool() { }
698    TStrHash(const PStringPool& StrPool): PortV(), KeyDatV(), AutoSizeP(true), FFreeKeyId(-1), FreeKeys(0), Pool(StrPool) { }
699    TStrHash(const int& Ports, const bool& _AutoSizeP = false, const PStringPool& StrPool = PStringPool()) :
700      PortV(Ports), KeyDatV(Ports, 0), AutoSizeP(_AutoSizeP), FFreeKeyId(-1), FreeKeys(0), Pool(StrPool) { PortV.PutAll(-1); }
701    TStrHash(const TStrHash& Hash): PortV(Hash.PortV), KeyDatV(Hash.KeyDatV), AutoSizeP(Hash.AutoSizeP),
702      FFreeKeyId(Hash.FFreeKeyId), FreeKeys(Hash.FreeKeys), Pool() {
703        if (! Hash.Pool.Empty()) { Pool=PStringPool(new TStringPool(*Hash.Pool)); } }
704    TStrHash(TSIn& SIn, bool PoolToo = true): PortV(SIn), KeyDatV(SIn), AutoSizeP(SIn), FFreeKeyId(SIn), FreeKeys(SIn){ SIn.LoadCs(); if (PoolToo) Pool = PStringPool(SIn); }
705    void Load(TSIn& SIn, bool PoolToo = true) {PortV.Load(SIn); KeyDatV.Load(SIn); AutoSizeP.Load(SIn); FFreeKeyId.Load(SIn);
706      FreeKeys.Load(SIn); SIn.LoadCs(); if (PoolToo) Pool = PStringPool(SIn);}
707    void LoadShM(TShMIn& ShMIn, bool SharedPool=true) {
708      PortV.LoadShM(ShMIn);
709      KeyDatV.Load(ShMIn);
710      AutoSizeP.Load(ShMIn);
711      FFreeKeyId.Load(ShMIn);
712      FreeKeys.Load(ShMIn);
713      ShMIn.LoadCs();
714      if (SharedPool) {
715        TBool isNull;
716        isNull.Load(ShMIn);
717        if (!isNull) {
718          Pool = TStringPool::LoadShM(ShMIn);
719        }
720      } else {
721        Pool = PStringPool(ShMIn);
722      }
723    }
724    void Save(TSOut& SOut, bool PoolToo = true) const { PortV.Save(SOut); KeyDatV.Save(SOut);
725      AutoSizeP.Save(SOut); FFreeKeyId.Save(SOut); FreeKeys.Save(SOut); SOut.SaveCs(); if (PoolToo) Pool.Save(SOut); }
726    void SetPool(const PStringPool& StrPool) { IAssert(Pool.Empty() || Pool->Empty()); Pool = StrPool; }
727    PStringPool GetPool() const { return Pool; }
728    TStrHash& operator = (const TStrHash& Hash);
729    bool Empty() const {return ! Len(); }
730    int Len() const { return KeyDatV.Len() - FreeKeys; }
731    int Reserved() const { return KeyDatV.Reserved(); }
732    int GetPorts() const { return PortV.Len(); }
733    bool IsAutoSize() const { return AutoSizeP; }
734    int GetMxKeyIds() const { return KeyDatV.Len(); }
735    bool IsKeyIdEqKeyN() const {return ! FreeKeys; }
736    int AddKey(const char *Key);
737    int AddKey(const TStr& Key) { return AddKey(Key.CStr()); }
738    int AddKey(const TChA& Key) { return AddKey(Key.CStr()); }
739    int AddDat(const char *Key, const TDat& Dat) { const int KeyId = AddKey(Key); KeyDatV[KeyId].Dat = Dat; return KeyId; }
740    int AddDat(const TStr& Key, const TDat& Dat) { const int KeyId = AddKey(Key.CStr()); KeyDatV[KeyId].Dat = Dat; return KeyId; }
741    int AddDat(const TChA& Key, const TDat& Dat) { const int KeyId = AddKey(Key.CStr()); KeyDatV[KeyId].Dat = Dat; return KeyId; }
742    TDat& AddDat(const char *Key) { return KeyDatV[AddKey(Key)].Dat; }
743    TDat& AddDat(const TStr& Key) { return KeyDatV[AddKey(Key.CStr())].Dat; }
744    TDat& AddDat(const TChA& Key) { return KeyDatV[AddKey(Key.CStr())].Dat; }
745    TDat& AddDatId(const char *Key) { const int KeyId = AddKey(Key);  return KeyDatV[KeyId].Dat = KeyId; }
746    TDat& AddDatId(const TStr& Key) { const int KeyId = AddKey(Key.CStr());  return KeyDatV[KeyId].Dat = KeyId; }
747    TDat& AddDatId(const TChA& Key) { const int KeyId = AddKey(Key.CStr());  return KeyDatV[KeyId].Dat = KeyId; }
748    const TDat& operator[](const int& KeyId) const {return GetHashKeyDat(KeyId).Dat;}
749    TDat& operator[](const int& KeyId){return GetHashKeyDat(KeyId).Dat;}
750    const TDat& operator () (const char *Key) const { return GetDat(Key);}
751    ::TSize GetMemUsed() const {
752        int64 MemUsed = sizeof(bool)+2*sizeof(int);
753        MemUsed += int64(PortV.Reserved()) * int64(sizeof(TInt));
754        for (int KeyDatN = 0; KeyDatN < KeyDatV.Len(); KeyDatN++) {
755            MemUsed += int64(2 * sizeof(TInt));
756            MemUsed += int64(KeyDatV[KeyDatN].Key.GetMemUsed());
757            MemUsed += int64(KeyDatV[KeyDatN].Dat.GetMemUsed());
758        }
759        MemUsed += 8 + Pool->GetMemUsed();
760        return ::TSize(MemUsed/1000);
761    }
762    const TDat& GetDat(const char *Key) const { return KeyDatV[GetKeyId(Key)].Dat; }
763    const TDat& GetDat(const TStr& Key) const { return GetDat(Key.CStr()); }
764    TDat& GetDat(const char *Key) { return KeyDatV[GetKeyId(Key)].Dat; }
765    const TDat& GetDat(const TStr& Key) { return GetDat(Key.CStr()); }
766    const TDat& GetDat(const TChA& Key) { return GetDat(Key.CStr()); }
767    TDat& GetDatId(const int& KeyId) { return KeyDatV[KeyId].Dat; }
768    const TDat& GetDatId(const int& KeyId) const { return KeyDatV[KeyId].Dat; }
769    void GetKeyDat(const int& KeyId, int& KeyO, TDat& Dat) const { const THKeyDat& KeyDat = GetHashKeyDat(KeyId); KeyO = KeyDat.Key; Dat = KeyDat.Dat; }
770    void GetKeyDat(const int& KeyId, const char*& Key, TDat& Dat) const { const THKeyDat& KeyDat = GetHashKeyDat(KeyId); Key = KeyFromOfs(KeyDat.Key); Dat = KeyDat.Dat; }
771    void GetKeyDat(const int& KeyId, TStr& Key, TDat& Dat) const { const THKeyDat& KeyDat = GetHashKeyDat(KeyId); Key = KeyFromOfs(KeyDat.Key); Dat = KeyDat.Dat;}
772    void GetKeyDat(const int& KeyId, TChA& Key, TDat& Dat) const { const THKeyDat& KeyDat = GetHashKeyDat(KeyId); Key = KeyFromOfs(KeyDat.Key); Dat = KeyDat.Dat;}
773    int GetKeyId(const char *Key) const;
774    int GetKeyId(const TStr& Key) const { return GetKeyId(Key.CStr()); }
775    const char *GetKey(const int& KeyId) const { return Pool->GetCStr(GetHashKeyDat(KeyId).Key); }
776    int GetKeyOfs(const int& KeyId) const { return GetHashKeyDat(KeyId).Key; } 
777    const char *KeyFromOfs(const int& KeyO) const { return Pool->GetCStr(KeyO); }
778    bool IsKey(const char *Key) const { return GetKeyId(Key) != -1; }
779    bool IsKey(const TStr& Key) const { return GetKeyId(Key.CStr()) != -1; }
780    bool IsKey(const TChA& Key) const { return GetKeyId(Key.CStr()) != -1; }
781    bool IsKey(const char *Key, int& KeyId) const { KeyId = GetKeyId(Key); return KeyId != -1; }
782    bool IsKeyGetDat(const char *Key, TDat& Dat) const { const int KeyId = GetKeyId(Key); if (KeyId != -1) { Dat = KeyDatV[KeyId].Dat; return true; } else return false; }
783    bool IsKeyGetDat(const TStr& Key, TDat& Dat) const { const int KeyId = GetKeyId(Key.CStr()); if (KeyId != -1) { Dat = KeyDatV[KeyId].Dat; return true; } else return false; }
784    bool IsKeyGetDat(const TChA& Key, TDat& Dat) const { const int KeyId = GetKeyId(Key.CStr()); if (KeyId != -1) { Dat = KeyDatV[KeyId].Dat; return true; } else return false; }
785    bool IsKeyId(const int& KeyId) const { return 0 <= KeyId && KeyId < KeyDatV.Len() && KeyDatV[KeyId].HashCd != -1; }
786    int FFirstKeyId() const {return 0-1;}
787    bool FNextKeyId(int& KeyId) const;
788    void GetKeyV(TVec<TStr>& KeyV) const;
789    void GetStrIdV(TIntV& StrIdV) const;
790    void GetDatV(TVec<TDat>& DatV) const;
791    void GetKeyDatPrV(TVec<TPair<TStr, TDat> >& KeyDatPrV) const;
792    void GetDatKeyPrV(TVec<TPair<TDat, TStr> >& DatKeyPrV) const;
793    void Pack(){KeyDatV.Pack();}
794  };
795  template <class TDat, class TStringPool, class THashFunc>
796  uint TStrHash<TDat, TStringPool, THashFunc>::GetNextPrime(const uint& Val) const {
797    uint *f = (uint *) TIntH::HashPrimeT, *m, *l = (uint *) TIntH::HashPrimeT + (int) TIntH::HashPrimes;
798    int h, len = (int)TIntH::HashPrimes;
799    while (len > 0) {
800      h = len >> 1;  m = f + h;
801      if (*m < Val) { f = m;  f++;  len = len - h - 1; }
802      else len = h;
803    }
804    return f == l ? *(l - 1) : *f;
805  }
806  template <class TDat, class TStringPool, class THashFunc>
807  void TStrHash<TDat, TStringPool, THashFunc>::Resize() {
808    if (PortV.Empty()) { PortV.Gen(17);  PortV.PutAll(-1); }
809    else
810    if (AutoSizeP && KeyDatV.Len() > 3 * PortV.Len()) {
811      const int NxPrime = GetNextPrime(KeyDatV.Len());
812      PortV.Gen(NxPrime);  PortV.PutAll(-1); }
813    else
814      return;
815    const int NPorts = PortV.Len();
816    for (int i = 0; i < KeyDatV.Len(); i++) {
817      THKeyDat& KeyDat = KeyDatV[i];
818      if (KeyDat.HashCd != -1) {
819        const int Port = abs(THashFunc::GetPrimHashCd(Pool->GetCStr(KeyDat.Key)) % NPorts);
820        KeyDat.Next = PortV[Port];
821        PortV[Port] = i;
822      }
823    }
824  }
825  template <class TDat, class TStringPool, class THashFunc>
826  TStrHash<TDat, TStringPool, THashFunc>& TStrHash<TDat, TStringPool, THashFunc>:: operator = (const TStrHash& Hash) {
827    if (this != &Hash) {
828      PortV = Hash.PortV;
829      KeyDatV = Hash.KeyDatV;
830      AutoSizeP = Hash.AutoSizeP;
831      FFreeKeyId = Hash.FFreeKeyId;
832      FreeKeys = Hash.FreeKeys;
833      if (! Hash.Pool.Empty()) Pool = PStringPool(new TStringPool(*Hash.Pool));
834      else Pool = NULL;
835    }
836    return *this;
837  }
838  template <class TDat, class TStringPool, class THashFunc>
839  int TStrHash<TDat, TStringPool, THashFunc>::AddKey(const char *Key) {
840    if (Pool.Empty()) Pool = TStringPool::New();
841    if ((AutoSizeP && KeyDatV.Len() > PortV.Len()) || PortV.Empty()) Resize();
842    const int PortN = abs(THashFunc::GetPrimHashCd(Key) % PortV.Len());
843    const int HashCd = abs(THashFunc::GetSecHashCd(Key));
844    int PrevKeyId = -1;
845    int KeyId = PortV[PortN];
846    while (KeyId != -1 && ! (KeyDatV[KeyId].HashCd == HashCd && Pool->Cmp(KeyDatV[KeyId].Key, Key) == 0)) {
847      PrevKeyId = KeyId;  KeyId = KeyDatV[KeyId].Next; }
848    if (KeyId == -1) {
849      const int StrId = Pool->AddStr(Key);
850      if (FFreeKeyId == -1) {
851        KeyId = KeyDatV.Add(THKeyDat(-1, HashCd, StrId));
852      } else {
853        KeyId = FFreeKeyId;
854        FFreeKeyId = KeyDatV[FFreeKeyId].Next;
855        FreeKeys--;
856        KeyDatV[KeyId] = THKeyDat(-1, HashCd, StrId);
857      }
858      if (PrevKeyId == -1) PortV[PortN] = KeyId;
859      else KeyDatV[PrevKeyId].Next = KeyId;
860    }
861    return KeyId;
862  }
863  template <class TDat, class TStringPool, class THashFunc>
864  int TStrHash<TDat, TStringPool, THashFunc>::GetKeyId(const char *Key) const {
865    if (PortV.Empty()) return -1;
866    const int PortN = abs(THashFunc::GetPrimHashCd(Key) % PortV.Len());
867    const int Hc = abs(THashFunc::GetSecHashCd(Key));
868    int KeyId = PortV[PortN];
869    while (KeyId != -1 && ! (KeyDatV[KeyId].HashCd == Hc && Pool->Cmp(KeyDatV[KeyId].Key, Key) == 0))
870      KeyId = KeyDatV[KeyId].Next;
871    return KeyId;
872  }
873  template <class TDat, class TStringPool, class THashFunc>
874  bool TStrHash<TDat, TStringPool, THashFunc>::FNextKeyId(int& KeyId) const {
875    do KeyId++; while (KeyId < KeyDatV.Len() && KeyDatV[KeyId].HashCd == -1);
876    return KeyId < KeyDatV.Len();
877  }
878  template <class TDat, class TStringPool, class THashFunc>
879  void TStrHash<TDat, TStringPool, THashFunc>::GetKeyV(TVec<TStr>& KeyV) const {
880    KeyV.Gen(Len(), 0);
881    int KeyId = FFirstKeyId();
882    while (FNextKeyId(KeyId))
883      KeyV.Add(GetKey(KeyId));
884  }
885  template <class TDat, class TStringPool, class THashFunc>
886  void TStrHash<TDat, TStringPool, THashFunc>::GetStrIdV(TIntV& StrIdV) const {
887    StrIdV.Gen(Len(), 0);
888    int KeyId = FFirstKeyId();
889    while (FNextKeyId(KeyId))
890      StrIdV.Add(GetKeyOfs(KeyId));
891  }
892  template <class TDat, class TStringPool, class THashFunc>
893  void TStrHash<TDat, TStringPool, THashFunc>::GetDatV(TVec<TDat>& DatV) const {
894    DatV.Gen(Len(), 0);
895    int KeyId = FFirstKeyId();
896    while (FNextKeyId(KeyId))
897      DatV.Add(GetHashKeyDat(KeyId).Dat);
898  }
899  template <class TDat, class TStringPool, class THashFunc>
900  void TStrHash<TDat, TStringPool, THashFunc>::GetKeyDatPrV(TVec<TPair<TStr, TDat> >& KeyDatPrV) const {
901    KeyDatPrV.Gen(Len(), 0);
902    TStr Str; TDat Dat;
903    int KeyId = FFirstKeyId();
904    while (FNextKeyId(KeyId)){
905      GetKeyDat(KeyId, Str, Dat);
906      KeyDatPrV.Add(TPair<TStr, TDat>(Str, Dat));
907    }
908  }
909  template <class TDat, class TStringPool, class THashFunc>
910  void TStrHash<TDat, TStringPool, THashFunc>::GetDatKeyPrV(TVec<TPair<TDat, TStr> >& DatKeyPrV) const {
911    DatKeyPrV.Gen(Len(), 0);
912    TStr Str; TDat Dat;
913    int KeyId = FFirstKeyId();
914    while (FNextKeyId(KeyId)){
915      GetKeyDat(KeyId, Str, Dat);
916      DatKeyPrV.Add(TPair<TDat, TStr>(Dat, Str));
917    }
918  }
919  typedef TStrHash<TInt> TStrSH;
920  typedef TStrHash<TInt> TStrIntSH;
921  typedef TStrHash<TIntV> TStrToIntVSH;
922  template <class TKey, class TDat, class THashFunc = TDefaultHashFunc<TKey> >
923  class TCache{
924  private:
925    typedef TLst<TKey> TKeyL; typedef TLstNd<TKey>* TKeyLN;
926    typedef TPair<TKeyLN, TDat> TKeyLNDatPr;
927    int64 MxMemUsed;
928    int64 CurMemUsed;
929    THash<TKey, TKeyLNDatPr, THashFunc> KeyDatH;
930    TKeyL TimeKeyL;
931    void* RefToBs;
932    void Purge(const int64& MemToPurge);
933  public:
934    TCache(){}
935    TCache(const TCache&);
936    TCache(const int64& _MxMemUsed, const int& Ports, void* _RefToBs):
937      MxMemUsed(_MxMemUsed), CurMemUsed(0),
938      KeyDatH(Ports), TimeKeyL(), RefToBs(_RefToBs){}
939    TCache& operator=(const TCache&);
940    int64 GetMemUsed() const;
941    int64 GetMxMemUsed() const { return MxMemUsed; }
942    bool RefreshMemUsed();
943    void Put(const TKey& Key, const TDat& Dat);
944    bool Get(const TKey& Key, TDat& Dat);
945    void Del(const TKey& Key, const bool& DoEventCall=true);
946    void Flush();
947    void FlushAndClr();
948    void* FFirstKeyDat();
949    bool FNextKeyDat(void*& KeyDatP, TKey& Key, TDat& Dat);
950    void PutRefToBs(void* _RefToBs){RefToBs=_RefToBs;}
951    void* GetRefToBs(){return RefToBs;}
952  };
953  template <class TKey, class TDat, class THashFunc>
954  void TCache<TKey, TDat, THashFunc>::Purge(const int64& MemToPurge){
955    const int64 StartMemUsed = CurMemUsed;
956    while (!TimeKeyL.Empty()&&(StartMemUsed-CurMemUsed<MemToPurge)){
957      TKey Key=TimeKeyL.Last()->GetVal();
958      Del(Key);
959    }
960  }
961  template <class TKey, class TDat, class THashFunc>
962  int64 TCache<TKey, TDat, THashFunc>::GetMemUsed() const {
963    int64 MemUsed=0;
964    int KeyId=KeyDatH.FFirstKeyId();
965    while (KeyDatH.FNextKeyId(KeyId)){
966      const TKey& Key=KeyDatH.GetKey(KeyId);
967      const TKeyLNDatPr& KeyLNDatPr=KeyDatH[KeyId];
968      TDat Dat=KeyLNDatPr.Val2;
969      MemUsed+=int64(Key.GetMemUsed()+Dat->GetMemUsed());
970    }
971    return MemUsed;
972  }
973  template <class TKey, class TDat, class THashFunc>
974  bool TCache<TKey, TDat, THashFunc>::RefreshMemUsed(){
975    CurMemUsed=GetMemUsed();
976    if (CurMemUsed>MxMemUsed){
977      Purge(CurMemUsed-MxMemUsed);
978      return true;
979    }
980    return false;
981  }
982  template <class TKey, class TDat, class THashFunc>
983  void TCache<TKey, TDat, THashFunc>::Put(const TKey& Key, const TDat& Dat){
984    int KeyId=KeyDatH.GetKeyId(Key);
985    if (KeyId==-1){
986      int64 KeyDatMem=int64(Key.GetMemUsed()+Dat->GetMemUsed());
987      if (CurMemUsed+KeyDatMem>MxMemUsed){Purge(KeyDatMem);}
988      CurMemUsed+=KeyDatMem;
989      TKeyLN KeyLN=TimeKeyL.AddFront(Key);
990      TKeyLNDatPr KeyLNDatPr(KeyLN, Dat);
991      KeyDatH.AddDat(Key, KeyLNDatPr);
992    } else {
993      TKeyLNDatPr& KeyLNDatPr=KeyDatH[KeyId];
994      TKeyLN KeyLN=KeyLNDatPr.Val1;
995      KeyLNDatPr.Val2=Dat;
996      TimeKeyL.PutFront(KeyLN);
997    }
998  }
999  template <class TKey, class TDat, class THashFunc>
1000  bool TCache<TKey, TDat, THashFunc>::Get(const TKey& Key, TDat& Dat){
1001    int KeyId=KeyDatH.GetKeyId(Key);
1002    if (KeyId==-1){
1003      return false;
1004    } else {
1005      Dat=KeyDatH[KeyId].Val2;
1006      return true;
1007    }
1008  }
1009  template <class TKey, class TDat, class THashFunc>
1010  void TCache<TKey, TDat, THashFunc>::Del(const TKey& Key, const bool& DoEventCall){
1011    int KeyId=KeyDatH.GetKeyId(Key);
1012    if (KeyId!=-1){
1013      TKeyLNDatPr& KeyLNDatPr=KeyDatH[KeyId];
1014      TKeyLN KeyLN=KeyLNDatPr.Val1;
1015      TDat& Dat=KeyLNDatPr.Val2;
1016      if (DoEventCall){
1017        Dat->OnDelFromCache(Key, RefToBs);}
1018      CurMemUsed-=int64(Key.GetMemUsed()+Dat->GetMemUsed());
1019      Dat=NULL;
1020      TimeKeyL.Del(KeyLN);
1021      KeyDatH.DelKeyId(KeyId);
1022    }
1023  }
1024  template <class TKey, class TDat, class THashFunc>
1025  void TCache<TKey, TDat, THashFunc>::Flush(){
1026    printf("To flush: %d\n", KeyDatH.Len());
1027    int KeyId=KeyDatH.FFirstKeyId(); int Done = 0;
1028    while (KeyDatH.FNextKeyId(KeyId)){
1029      if (Done%10000==0){printf("%d\r", Done);}
1030      const TKey& Key=KeyDatH.GetKey(KeyId);
1031      TKeyLNDatPr& KeyLNDatPr=KeyDatH[KeyId];
1032      TDat Dat=KeyLNDatPr.Val2;
1033      Dat->OnDelFromCache(Key, RefToBs);
1034      Done++;
1035    }
1036    printf("Done %d\n", KeyDatH.Len());
1037  }
1038  template <class TKey, class TDat, class THashFunc>
1039  void TCache<TKey, TDat, THashFunc>::FlushAndClr(){
1040    Flush();
1041    CurMemUsed=0;
1042    KeyDatH.Clr();
1043    TimeKeyL.Clr();
1044  }
1045  template <class TKey, class TDat, class THashFunc>
1046  void* TCache<TKey, TDat, THashFunc>::FFirstKeyDat(){
1047    return TimeKeyL.First();
1048  }
1049  template <class TKey, class TDat, class THashFunc>
1050  bool TCache<TKey, TDat, THashFunc>::FNextKeyDat(void*& KeyDatP, TKey& Key, TDat& Dat){
1051    if (KeyDatP==NULL){
1052      return false;
1053    } else {
1054      Key=TKeyLN(KeyDatP)->GetVal(); Dat=KeyDatH.GetDat(Key).Val2;
1055      KeyDatP=TKeyLN(KeyDatP)->Next(); return true;
1056    }
1057  }
1058  class TStrHashF_OldGLib {
1059  public:
1060    inline static int GetPrimHashCd(const char *p) {
1061      const int MulBy = 16;  
1062      int HashCd = 0;
1063      while (*p) { HashCd = (MulBy * HashCd) + *p++; HashCd &= 0x0FFFFFFF; }
1064      return HashCd; }
1065    inline static int GetSecHashCd(const char *p) {
1066      const int MulBy = 16;  
1067      int HashCd = 0;
1068      while (*p) { HashCd = (MulBy * HashCd) ^ *p++; HashCd &= 0x0FFFFFFF; }
1069      return HashCd; }
1070    inline static int GetPrimHashCd(const TStr& s) { return GetPrimHashCd(s.CStr()); }
1071    inline static int GetSecHashCd(const TStr& s) { return GetSecHashCd(s.CStr()); }
1072  };
1073  class TStrHashF_Md5 {
1074  public:
1075    static int GetPrimHashCd(const char *p);
1076    static int GetSecHashCd(const char *p);
1077    static int GetPrimHashCd(const TStr& s);
1078    static int GetSecHashCd(const TStr& s);
1079  };
1080  class TStrHashF_DJB {
1081  private:
1082    inline static unsigned int DJBHash(const char* Str, const ::TSize& Len) {
1083      unsigned int hash = 5381;
1084      for(unsigned int i = 0; i < Len; Str++, i++) {
1085         hash = ((hash << 5) + hash) + (*Str); }
1086      return hash;
1087    }
1088  public:
1089    inline static int GetPrimHashCd(const char *p) {
1090      const char *r = p;  while (*r) { r++; }
1091      return (int) DJBHash((const char *) p, r - p) & 0x7fffffff; }
1092    inline static int GetSecHashCd(const char *p) {
1093      const char *r = p;  while (*r) { r++; }
1094      return (int) DJBHash((const char *) p, r - p) & 0x7fffffff; }
1095    inline static int GetPrimHashCd(const TStr& s) { 
1096      return GetPrimHashCd(s.CStr()); }
1097    inline static int GetSecHashCd(const TStr& s) { 
1098      return GetSecHashCd(s.CStr()); }
1099    inline static int GetPrimHashCd(const char *p, const ::TSize& Len) {
1100      return (int) DJBHash((const char *) p, Len) & 0x7fffffff; }
1101    inline static int GetSecHashCd(const char *p, const ::TSize& Len) {
1102      return (int) DJBHash((const char *) p, Len) & 0x7fffffff; }
1103  };
1104  template <class TVec>
1105  class TVecHashF_OldGLib {
1106  public:
1107    static inline int GetPrimHashCd(const TVec& Vec) {
1108      int HashCd=0;
1109      for (int ValN=0; ValN<Vec.Len(); ValN++){
1110        HashCd+=Vec[ValN].GetPrimHashCd();}
1111      return abs(HashCd);
1112    }
1113    inline static int GetSecHashCd(const TVec& Vec) {
1114      int HashCd=0;
1115      for (int ValN=0; ValN<Vec.Len(); ValN++){
1116        HashCd+=Vec[ValN].GetSecHashCd();}
1117      return abs(HashCd);
1118    }
1119  };
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-hash.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-hash.h</div>
                </div>
                <div class="column column_space"><pre><code>488      operator=(Hash);
489      IAssert(IsKeyIdEqKeyN());
490    }
491  }
492  template<class TKey, class TDat, class THashFunc>
</pre></code></div>
                <div class="column column_space"><pre><code>488      operator=(Hash);
489      IAssert(IsKeyIdEqKeyN());
490    }
491  }
492  template<class TKey, class TDat, class THashFunc>
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    