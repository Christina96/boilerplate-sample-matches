
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-concepts.hpp</h3>
            <pre><code>1  #ifndef BOOST_REGEX_CONCEPTS_HPP_INCLUDED
2  #define BOOST_REGEX_CONCEPTS_HPP_INCLUDED
3  #include &lt;boost/concept_archetype.hpp&gt;
4  #include &lt;boost/concept_check.hpp&gt;
5  #include &lt;boost/type_traits/is_enum.hpp&gt;
6  #include &lt;boost/type_traits/is_base_and_derived.hpp&gt;
7  #include &lt;boost/static_assert.hpp&gt;
8  #ifndef BOOST_TEST_TR1_REGEX
9  #include &lt;boost/regex.hpp&gt;
10  #endif
11  #include &lt;bitset&gt;
12  #include &lt;vector&gt;
13  #include &lt;ostream&gt;
14  #ifdef BOOST_REGEX_CXX03
15  #define RW_NS boost
16  #else
17  #define RW_NS std
18  #endif
19  namespace boost{
20  typedef std::bitset&lt;512&gt; bitmask_archetype;
21  struct char_architype
22  {
23     char_architype();
24     char_architype(const char_architype&amp;);
25     char_architype&amp; operator=(const char_architype&amp;);
26     char_architype(unsigned long val);
27     bool operator==(const char_architype&amp;)const;
28     bool operator!=(const char_architype&amp;)const;
29     bool operator&lt;(const char_architype&amp;)const;
30     bool operator&lt;=(const char_architype&amp;)const;
31     bool operator&gt;=(const char_architype&amp;)const;
32     bool operator&gt;(const char_architype&amp;)const;
33     operator long()const;
34  };
35  inline long hash_value(char_architype val)
36  {  return val;  }
37  } 
38  namespace std{
39     template&lt;&gt; struct char_traits&lt;boost::char_architype&gt;
40     {
41        typedef boost::char_architype char_type;
42     };
43  }
44  template &lt;class T&gt;
45  class allocator_architype
46  {
47  public:
48     typedef T* pointer;
49     typedef const T* const_pointer;
50     typedef T&amp; reference;
51     typedef const T&amp; const_reference;
52     typedef T value_type;
53     typedef unsigned size_type;
54     typedef int difference_type;
55     template &lt;class U&gt;
56     struct rebind
57     {
58        typedef allocator_architype&lt;U&gt; other;
59     };
60     pointer address(reference r){ return &amp;r; }
61     const_pointer address(const_reference r) { return &amp;r; }
62     pointer allocate(size_type n) { return static_cast&lt;pointer&gt;(std::malloc(n)); }
63     pointer allocate(size_type n, pointer) { return static_cast&lt;pointer&gt;(std::malloc(n)); }
64     void deallocate(pointer p, size_type) { std::free(p); }
65     size_type max_size()const { return UINT_MAX; }
66     allocator_architype(){}
67     allocator_architype(const allocator_architype&amp;){}
68     template &lt;class Other&gt;
69     allocator_architype(const allocator_architype&lt;Other&gt;&amp;){}
70     void construct(pointer p, const_reference r) { new (p)T(r); }
71     void destroy(pointer p) { p-&gt;~T(); }
72  };
73  template &lt;class T&gt;
74  bool operator == (const allocator_architype&lt;T&gt;&amp;, const allocator_architype&lt;T&gt;&amp;) {return true; }
75  template &lt;class T&gt;
76  bool operator != (const allocator_architype&lt;T&gt;&amp;, const allocator_architype&lt;T&gt;&amp;) { return false; }
77  namespace boost{
78  template &lt;class charT&gt;
79  struct regex_traits_architype
80  {
81  public:
82     regex_traits_architype(){}
83     typedef charT char_type;
84     typedef std::vector&lt;char_type&gt; string_type;
85     typedef copy_constructible_archetype&lt;assignable_archetype&lt;&gt; &gt; locale_type;
86     typedef bitmask_archetype char_class_type;
87     static std::size_t length(const char_type* ) { return 0; }
88     charT translate(charT ) const { return charT(); }
89     charT translate_nocase(charT ) const { return static_object&lt;charT&gt;::get(); }
90     template &lt;class ForwardIterator&gt;
91     string_type transform(ForwardIterator , ForwardIterator ) const
92     { return static_object&lt;string_type&gt;::get(); }
93     template &lt;class ForwardIterator&gt;
94     string_type transform_primary(ForwardIterator , ForwardIterator ) const
95     { return static_object&lt;string_type&gt;::get(); }
96     template &lt;class ForwardIterator&gt;
97     char_class_type lookup_classname(ForwardIterator , ForwardIterator ) const
98     { return static_object&lt;char_class_type&gt;::get(); }
99     template &lt;class ForwardIterator&gt;
100     string_type lookup_collatename(ForwardIterator , ForwardIterator ) const
101     { return static_object&lt;string_type&gt;::get(); }
102     bool isctype(charT, char_class_type) const
103     { return false; }
104     int value(charT, int) const
105     { return 0; }
106     locale_type imbue(locale_type l)
107     { return l; }
108     locale_type getloc()const
109     { return static_object&lt;locale_type&gt;::get(); }
110  private:
111     regex_traits_architype(const regex_traits_architype&amp;){}
112     regex_traits_architype&amp; operator=(const regex_traits_architype&amp;){ return *this; }
113  };
114  #ifndef BOOST_TEST_TR1_REGEX
115  namespace global_regex_namespace = ::boost;
116  #else
117  namespace global_regex_namespace = ::std::tr1;
118  #endif
119  template &lt;class Bitmask&gt;
120  struct BitmaskConcept
121  {
122     void constraints() 
123     {
124        function_requires&lt;CopyConstructibleConcept&lt;Bitmask&gt; &gt;();
125        function_requires&lt;AssignableConcept&lt;Bitmask&gt; &gt;();
126        m_mask1 = m_mask2 | m_mask3;
127        m_mask1 = m_mask2 &amp; m_mask3;
128        m_mask1 = m_mask2 ^ m_mask3;
129        m_mask1 = ~m_mask2;
130        m_mask1 |= m_mask2;
131        m_mask1 &amp;= m_mask2;
132        m_mask1 ^= m_mask2;
133     }
134     Bitmask m_mask1, m_mask2, m_mask3;
135  };
136  template &lt;class traits&gt;
137  struct RegexTraitsConcept
138  {
139     RegexTraitsConcept();
140     typedef typename traits::char_type char_type;
141     typedef typename traits::string_type string_type;
142     typedef typename traits::locale_type locale_type;
143     typedef typename traits::char_class_type char_class_type;
144     void constraints() 
145     {
146        function_requires&lt;RandomAccessContainerConcept&lt;string_type&gt; &gt;();
147        function_requires&lt;DefaultConstructibleConcept&lt;locale_type&gt; &gt;();
148        function_requires&lt;CopyConstructibleConcept&lt;locale_type&gt; &gt;();
149        function_requires&lt;AssignableConcept&lt;locale_type&gt; &gt;();
150        function_requires&lt;BitmaskConcept&lt;char_class_type&gt; &gt;();
151        std::size_t n = traits::length(m_pointer);
152        ignore_unused_variable_warning(n);
153        char_type c = m_ctraits.translate(m_char);
154        ignore_unused_variable_warning(c);
155        c = m_ctraits.translate_nocase(m_char);
156        string_type s1 = m_ctraits.transform(m_pointer, m_pointer);
157        ignore_unused_variable_warning(s1);
158        string_type s2 = m_ctraits.transform_primary(m_pointer, m_pointer);
159        ignore_unused_variable_warning(s2);
160        char_class_type cc = m_ctraits.lookup_classname(m_pointer, m_pointer);
161        ignore_unused_variable_warning(cc);
162        string_type s3 = m_ctraits.lookup_collatename(m_pointer, m_pointer);
163        ignore_unused_variable_warning(s3);
164        bool b = m_ctraits.isctype(m_char, cc);
165        ignore_unused_variable_warning(b);
166        int v = m_ctraits.value(m_char, 16);
167        ignore_unused_variable_warning(v);
168        locale_type l(m_ctraits.getloc());
169        m_traits.imbue(l);
170        ignore_unused_variable_warning(l);
171     }
172     traits m_traits;
173     const traits m_ctraits;
174     const char_type* m_pointer;
175     char_type m_char;
176  private:
177     RegexTraitsConcept&amp; operator=(RegexTraitsConcept&amp;);
178  };
179  template &lt;class Regex&gt;
180  struct regex_traits_computer;
181  template &lt;class charT, class traits&gt;
182  struct regex_traits_computer&lt; global_regex_namespace::basic_regex&lt;charT, traits&gt; &gt;
183  {
184     typedef traits type;
185  };
186  template &lt;class Regex&gt;
187  struct BaseRegexConcept
188  {
189     typedef typename Regex::value_type value_type;
190     typedef typename Regex::flag_type flag_type;
191     typedef typename Regex::locale_type locale_type;
192     typedef input_iterator_archetype&lt;value_type&gt; input_iterator_type;
193     typedef const value_type* pointer_type;
194     typedef bidirectional_iterator_archetype&lt;value_type&gt; BidiIterator;
195     typedef global_regex_namespace::sub_match&lt;BidiIterator&gt; sub_match_type;
196     typedef global_regex_namespace::match_results&lt;BidiIterator, allocator_architype&lt;sub_match_type&gt; &gt; match_results_type;
197     typedef global_regex_namespace::match_results&lt;BidiIterator&gt; match_results_default_type;
198     typedef output_iterator_archetype&lt;value_type&gt; OutIterator;
199     typedef typename regex_traits_computer&lt;Regex&gt;::type traits_type;
200     typedef global_regex_namespace::regex_iterator&lt;BidiIterator, value_type, traits_type&gt; regex_iterator_type;
201     typedef global_regex_namespace::regex_token_iterator&lt;BidiIterator, value_type, traits_type&gt; regex_token_iterator_type;
202     void global_constraints()
203     {
204        function_requires&lt;BitmaskConcept&lt;global_regex_namespace::regex_constants::syntax_option_type&gt; &gt;();
205        global_regex_namespace::regex_constants::syntax_option_type opts
206           = global_regex_namespace::regex_constants::icase
207           | global_regex_namespace::regex_constants::nosubs
208           | global_regex_namespace::regex_constants::optimize
209           | global_regex_namespace::regex_constants::collate
210           | global_regex_namespace::regex_constants::ECMAScript
211           | global_regex_namespace::regex_constants::basic
212           | global_regex_namespace::regex_constants::extended
213           | global_regex_namespace::regex_constants::awk
214           | global_regex_namespace::regex_constants::grep
215           | global_regex_namespace::regex_constants::egrep;
216        ignore_unused_variable_warning(opts);
217        function_requires&lt;BitmaskConcept&lt;global_regex_namespace::regex_constants::match_flag_type&gt; &gt;();
218        global_regex_namespace::regex_constants::match_flag_type mopts
219           = global_regex_namespace::regex_constants::match_default
220           | global_regex_namespace::regex_constants::match_not_bol
221           | global_regex_namespace::regex_constants::match_not_eol
222           | global_regex_namespace::regex_constants::match_not_bow
223           | global_regex_namespace::regex_constants::match_not_eow
224           | global_regex_namespace::regex_constants::match_any
225           | global_regex_namespace::regex_constants::match_not_null
226           | global_regex_namespace::regex_constants::match_continuous
227           | global_regex_namespace::regex_constants::match_prev_avail
228           | global_regex_namespace::regex_constants::format_default
229           | global_regex_namespace::regex_constants::format_sed
230           | global_regex_namespace::regex_constants::format_no_copy
231           | global_regex_namespace::regex_constants::format_first_only;
232        ignore_unused_variable_warning(mopts);
233        BOOST_STATIC_ASSERT((::boost::is_enum&lt;global_regex_namespace::regex_constants::error_type&gt;::value));
234        global_regex_namespace::regex_constants::error_type e1 = global_regex_namespace::regex_constants::error_collate;
235        ignore_unused_variable_warning(e1);
236        e1 = global_regex_namespace::regex_constants::error_ctype;
237        ignore_unused_variable_warning(e1);
238        e1 = global_regex_namespace::regex_constants::error_escape;
239        ignore_unused_variable_warning(e1);
240        e1 = global_regex_namespace::regex_constants::error_backref;
241        ignore_unused_variable_warning(e1);
242        e1 = global_regex_namespace::regex_constants::error_brack;
243        ignore_unused_variable_warning(e1);
244        e1 = global_regex_namespace::regex_constants::error_paren;
245        ignore_unused_variable_warning(e1);
246        e1 = global_regex_namespace::regex_constants::error_brace;
247        ignore_unused_variable_warning(e1);
248        e1 = global_regex_namespace::regex_constants::error_badbrace;
249        ignore_unused_variable_warning(e1);
250        e1 = global_regex_namespace::regex_constants::error_range;
251        ignore_unused_variable_warning(e1);
252        e1 = global_regex_namespace::regex_constants::error_space;
253        ignore_unused_variable_warning(e1);
254        e1 = global_regex_namespace::regex_constants::error_badrepeat;
255        ignore_unused_variable_warning(e1);
256        e1 = global_regex_namespace::regex_constants::error_complexity;
257        ignore_unused_variable_warning(e1);
258        e1 = global_regex_namespace::regex_constants::error_stack;
259        ignore_unused_variable_warning(e1);
260        BOOST_STATIC_ASSERT((::boost::is_base_and_derived&lt;std::runtime_error, global_regex_namespace::regex_error&gt;::value  ));
261        const global_regex_namespace::regex_error except(e1);
262        e1 = except.code();
263        typedef typename Regex::value_type regex_value_type;
264        function_requires&lt; RegexTraitsConcept&lt;global_regex_namespace::regex_traits&lt;char&gt; &gt; &gt;();
265        function_requires&lt; BaseRegexConcept&lt;global_regex_namespace::basic_regex&lt;char&gt; &gt; &gt;();
266     }
267     void constraints() 
268     {
269        global_constraints();
270        BOOST_STATIC_ASSERT((::boost::is_same&lt; flag_type, global_regex_namespace::regex_constants::syntax_option_type&gt;::value));
271        flag_type opts
272           = Regex::icase
273           | Regex::nosubs
274           | Regex::optimize
275           | Regex::collate
276           | Regex::ECMAScript
277           | Regex::basic
278           | Regex::extended
279           | Regex::awk
280           | Regex::grep
281           | Regex::egrep;
282        ignore_unused_variable_warning(opts);
283        function_requires&lt;DefaultConstructibleConcept&lt;Regex&gt; &gt;();
284        function_requires&lt;CopyConstructibleConcept&lt;Regex&gt; &gt;();
285        Regex e1(m_pointer);
286        ignore_unused_variable_warning(e1);
287        Regex e2(m_pointer, m_flags);
288        ignore_unused_variable_warning(e2);
289        Regex e3(m_pointer, m_size, m_flags);
290        ignore_unused_variable_warning(e3);
291        Regex e4(in1, in2);
292        ignore_unused_variable_warning(e4);
293        Regex e5(in1, in2, m_flags);
294        ignore_unused_variable_warning(e5);
295        Regex e;
296        e = m_pointer;
297        e = e1;
298        e.assign(e1);
299        e.assign(m_pointer);
300        e.assign(m_pointer, m_flags);
301        e.assign(m_pointer, m_size, m_flags);
302        e.assign(in1, in2);
303        e.assign(in1, in2, m_flags);
304        const Regex ce;
305        typename Regex::size_type i = ce.mark_count();
306        ignore_unused_variable_warning(i);
307        m_flags = ce.flags();
308        e.imbue(ce.getloc());
309        e.swap(e1);
310        global_regex_namespace::swap(e, e1);
311        BOOST_STATIC_ASSERT((::boost::is_base_and_derived&lt;std::pair&lt;BidiIterator, BidiIterator&gt;, sub_match_type&gt;::value));
312        typedef typename sub_match_type::value_type sub_value_type;
313        typedef typename sub_match_type::difference_type sub_diff_type;
314        typedef typename sub_match_type::iterator sub_iter_type;
315        BOOST_STATIC_ASSERT((::boost::is_same&lt;sub_value_type, value_type&gt;::value));
316        BOOST_STATIC_ASSERT((::boost::is_same&lt;sub_iter_type, BidiIterator&gt;::value));
317        bool b = m_sub.matched;
318        ignore_unused_variable_warning(b);
319        BidiIterator bi = m_sub.first;
320        ignore_unused_variable_warning(bi);
321        bi = m_sub.second;
322        ignore_unused_variable_warning(bi);
323        sub_diff_type diff = m_sub.length();
324        ignore_unused_variable_warning(diff);
325        typedef typename match_results_type::value_type mr_value_type;
326        typedef typename match_results_type::const_reference mr_const_reference;
327        typedef typename match_results_type::reference mr_reference;
328        typedef typename match_results_type::const_iterator mr_const_iterator;
329        typedef typename match_results_type::iterator mr_iterator;
330        typedef typename match_results_type::difference_type mr_difference_type;
331        typedef typename match_results_type::size_type mr_size_type;
332        typedef typename match_results_type::allocator_type mr_allocator_type;
333        typedef typename match_results_type::char_type mr_char_type;
334        typedef typename match_results_type::string_type mr_string_type;
335        match_results_type m1;
336        mr_allocator_type at;
337        match_results_type m2(at);
338        match_results_type m3(m1);
339        m1 = m2;
340        int ival = 0;
341        mr_size_type mrs = m_cresults.size();
342        ignore_unused_variable_warning(mrs);
343        mrs = m_cresults.max_size();
344        ignore_unused_variable_warning(mrs);
345        b = m_cresults.empty();
346        ignore_unused_variable_warning(b);
347        mr_difference_type mrd = m_cresults.length();
348        ignore_unused_variable_warning(mrd);
349        mrd = m_cresults.length(ival);
350        ignore_unused_variable_warning(mrd);
351        mrd = m_cresults.position();
352        ignore_unused_variable_warning(mrd);
353        mrd = m_cresults.position(mrs);
354        ignore_unused_variable_warning(mrd);
355        mr_const_reference mrcr = m_cresults[ival];
356        ignore_unused_variable_warning(mrcr);
357        mr_const_reference mrcr2 = m_cresults.prefix();
358        ignore_unused_variable_warning(mrcr2);
359        mr_const_reference mrcr3 = m_cresults.suffix();
360        ignore_unused_variable_warning(mrcr3);
361        mr_const_iterator mrci = m_cresults.begin();
362        ignore_unused_variable_warning(mrci);
363        mrci = m_cresults.end();
364        ignore_unused_variable_warning(mrci);
365        (void) m_cresults.get_allocator();
366        m_results.swap(m_results);
367        global_regex_namespace::swap(m_results, m_results);
368        b = global_regex_namespace::regex_match(m_in, m_in, m_results, e);
369        ignore_unused_variable_warning(b);
370        b = global_regex_namespace::regex_match(m_in, m_in, m_results, e, m_mft);
371        ignore_unused_variable_warning(b);
372        b = global_regex_namespace::regex_match(m_in, m_in, e);
373        ignore_unused_variable_warning(b);
374        b = global_regex_namespace::regex_match(m_in, m_in, e, m_mft);
375        ignore_unused_variable_warning(b);
376        b = global_regex_namespace::regex_match(m_pointer, m_pmatch, e);
377        ignore_unused_variable_warning(b);
378        b = global_regex_namespace::regex_match(m_pointer, m_pmatch, e, m_mft);
379        ignore_unused_variable_warning(b);
380        b = global_regex_namespace::regex_match(m_pointer, e);
381        ignore_unused_variable_warning(b);
382        b = global_regex_namespace::regex_match(m_pointer, e, m_mft);
383        ignore_unused_variable_warning(b);
384        b = global_regex_namespace::regex_search(m_in, m_in, m_results, e);
385        ignore_unused_variable_warning(b);
386        b = global_regex_namespace::regex_search(m_in, m_in, m_results, e, m_mft);
387        ignore_unused_variable_warning(b);
388        b = global_regex_namespace::regex_search(m_in, m_in, e);
389        ignore_unused_variable_warning(b);
390        b = global_regex_namespace::regex_search(m_in, m_in, e, m_mft);
391        ignore_unused_variable_warning(b);
392        b = global_regex_namespace::regex_search(m_pointer, m_pmatch, e);
393        ignore_unused_variable_warning(b);
394        b = global_regex_namespace::regex_search(m_pointer, m_pmatch, e, m_mft);
395        ignore_unused_variable_warning(b);
396        b = global_regex_namespace::regex_search(m_pointer, e);
397        ignore_unused_variable_warning(b);
398        b = global_regex_namespace::regex_search(m_pointer, e, m_mft);
399        ignore_unused_variable_warning(b);
400        typedef typename regex_iterator_type::regex_type rit_regex_type;
401        typedef typename regex_iterator_type::value_type rit_value_type;
402        typedef typename regex_iterator_type::difference_type rit_difference_type;
403        typedef typename regex_iterator_type::pointer rit_pointer;
404        typedef typename regex_iterator_type::reference rit_reference;
405        typedef typename regex_iterator_type::iterator_category rit_iterator_category;
406        BOOST_STATIC_ASSERT((::boost::is_same&lt;rit_regex_type, Regex&gt;::value));
407        BOOST_STATIC_ASSERT((::boost::is_same&lt;rit_value_type, match_results_default_type&gt;::value));
408        BOOST_STATIC_ASSERT((::boost::is_same&lt;rit_difference_type, std::ptrdiff_t&gt;::value));
409        BOOST_STATIC_ASSERT((::boost::is_same&lt;rit_pointer, const match_results_default_type*&gt;::value));
410        BOOST_STATIC_ASSERT((::boost::is_same&lt;rit_reference, const match_results_default_type&amp;&gt;::value));
411        BOOST_STATIC_ASSERT((::boost::is_convertible&lt;rit_iterator_category*, std::forward_iterator_tag*&gt;::value));
412        function_requires&lt;ForwardIteratorConcept&lt;regex_iterator_type&gt; &gt;();
413        regex_iterator_type iter1(m_in, m_in, e);
414        ignore_unused_variable_warning(iter1);
415        regex_iterator_type iter2(m_in, m_in, e, m_mft);
416        ignore_unused_variable_warning(iter2);
417        typedef typename regex_token_iterator_type::regex_type rtit_regex_type;
418        typedef typename regex_token_iterator_type::value_type rtit_value_type;
419        typedef typename regex_token_iterator_type::difference_type rtit_difference_type;
420        typedef typename regex_token_iterator_type::pointer rtit_pointer;
421        typedef typename regex_token_iterator_type::reference rtit_reference;
422        typedef typename regex_token_iterator_type::iterator_category rtit_iterator_category;
423        BOOST_STATIC_ASSERT((::boost::is_same&lt;rtit_regex_type, Regex&gt;::value));
424        BOOST_STATIC_ASSERT((::boost::is_same&lt;rtit_value_type, sub_match_type&gt;::value));
425        BOOST_STATIC_ASSERT((::boost::is_same&lt;rtit_difference_type, std::ptrdiff_t&gt;::value));
426        BOOST_STATIC_ASSERT((::boost::is_same&lt;rtit_pointer, const sub_match_type*&gt;::value));
427        BOOST_STATIC_ASSERT((::boost::is_same&lt;rtit_reference, const sub_match_type&amp;&gt;::value));
428        BOOST_STATIC_ASSERT((::boost::is_convertible&lt;rtit_iterator_category*, std::forward_iterator_tag*&gt;::value));
429        function_requires&lt;ForwardIteratorConcept&lt;regex_token_iterator_type&gt; &gt;();
430        regex_token_iterator_type ti1(m_in, m_in, e);
431        ignore_unused_variable_warning(ti1);
432        regex_token_iterator_type ti2(m_in, m_in, e, 0);
433        ignore_unused_variable_warning(ti2);
434        regex_token_iterator_type ti3(m_in, m_in, e, 0, m_mft);
435        ignore_unused_variable_warning(ti3);
436        std::vector&lt;int&gt; subs;
437        regex_token_iterator_type ti4(m_in, m_in, e, subs);
438        ignore_unused_variable_warning(ti4);
439        regex_token_iterator_type ti5(m_in, m_in, e, subs, m_mft);
440        ignore_unused_variable_warning(ti5);
441        static const int i_array[3] = { 1, 2, 3, };
442        regex_token_iterator_type ti6(m_in, m_in, e, i_array);
443        ignore_unused_variable_warning(ti6);
444        regex_token_iterator_type ti7(m_in, m_in, e, i_array, m_mft);
445        ignore_unused_variable_warning(ti7);
446     }
447     pointer_type m_pointer;
448     flag_type m_flags;
449     std::size_t m_size;
450     input_iterator_type in1, in2;
451     const sub_match_type m_sub;
452     const value_type m_char;
453     match_results_type m_results;
454     const match_results_type m_cresults;
455     OutIterator m_out;
456     BidiIterator m_in;
457     global_regex_namespace::regex_constants::match_flag_type m_mft;
458     global_regex_namespace::match_results&lt;
459        pointer_type, 
460        allocator_architype&lt;global_regex_namespace::sub_match&lt;pointer_type&gt; &gt; &gt; 
461        m_pmatch;
462     BaseRegexConcept();
463     BaseRegexConcept(const BaseRegexConcept&amp;);
464     BaseRegexConcept&amp; operator=(const BaseRegexConcept&amp;);
465  };
466  template &lt;class Regex&gt;
467  struct RegexConcept
468  {
469     typedef typename Regex::value_type value_type;
470     typedef typename Regex::flag_type flag_type;
471     typedef typename Regex::locale_type locale_type;
472     typedef const value_type* pointer_type;
473     typedef std::basic_string&lt;value_type&gt; string_type;
474     typedef boost::bidirectional_iterator_archetype&lt;value_type&gt; BidiIterator;
475     typedef global_regex_namespace::sub_match&lt;BidiIterator&gt; sub_match_type;
476     typedef global_regex_namespace::match_results&lt;BidiIterator, allocator_architype&lt;sub_match_type&gt; &gt; match_results_type;
477     typedef output_iterator_archetype&lt;value_type&gt; OutIterator;
478     void constraints() 
479     {
480        function_requires&lt;BaseRegexConcept&lt;Regex&gt; &gt;();
481        Regex e1(m_string);
482        ignore_unused_variable_warning(e1);
483        Regex e2(m_string, m_flags);
484        ignore_unused_variable_warning(e2);
485        Regex e;
486        e = m_string;
487        e.assign(m_string);
488        e.assign(m_string, m_flags);
489        string_type s(m_sub);
490        ignore_unused_variable_warning(s);
491        s = m_sub.str();
492        ignore_unused_variable_warning(s);
493        int i = m_sub.compare(m_string);
494        ignore_unused_variable_warning(i);
495        int i2 = m_sub.compare(m_sub);
496        ignore_unused_variable_warning(i2);
497        i2 = m_sub.compare(m_pointer);
498        ignore_unused_variable_warning(i2);
499        bool b = m_sub == m_sub;
500        ignore_unused_variable_warning(b);
501        b = m_sub != m_sub;
502        ignore_unused_variable_warning(b);
503        b = m_sub &lt;= m_sub;
504        ignore_unused_variable_warning(b);
505        b = m_sub &lt;= m_sub;
506        ignore_unused_variable_warning(b);
507        b = m_sub &gt; m_sub;
508        ignore_unused_variable_warning(b);
509        b = m_sub &gt;= m_sub;
510        ignore_unused_variable_warning(b);
511        b = m_sub == m_pointer;
512        ignore_unused_variable_warning(b);
513        b = m_sub != m_pointer;
514        ignore_unused_variable_warning(b);
515        b = m_sub &lt;= m_pointer;
516        ignore_unused_variable_warning(b);
517        b = m_sub &lt;= m_pointer;
518        ignore_unused_variable_warning(b);
519        b = m_sub &gt; m_pointer;
520        ignore_unused_variable_warning(b);
521        b = m_sub &gt;= m_pointer;
522        ignore_unused_variable_warning(b);
523        b = m_pointer == m_sub;
524        ignore_unused_variable_warning(b);
525        b = m_pointer != m_sub;
526        ignore_unused_variable_warning(b);
527        b = m_pointer &lt;= m_sub;
528        ignore_unused_variable_warning(b);
529        b = m_pointer &lt;= m_sub;
530        ignore_unused_variable_warning(b);
531        b = m_pointer &gt; m_sub;
532        ignore_unused_variable_warning(b);
533        b = m_pointer &gt;= m_sub;
534        ignore_unused_variable_warning(b);
535        b = m_sub == m_char;
536        ignore_unused_variable_warning(b);
537        b = m_sub != m_char;
538        ignore_unused_variable_warning(b);
539        b = m_sub &lt;= m_char;
540        ignore_unused_variable_warning(b);
541        b = m_sub &lt;= m_char;
542        ignore_unused_variable_warning(b);
543        b = m_sub &gt; m_char;
544        ignore_unused_variable_warning(b);
545        b = m_sub &gt;= m_char;
546        ignore_unused_variable_warning(b);
547        b = m_char == m_sub;
548        ignore_unused_variable_warning(b);
549        b = m_char != m_sub;
550        ignore_unused_variable_warning(b);
551        b = m_char &lt;= m_sub;
552        ignore_unused_variable_warning(b);
553        b = m_char &lt;= m_sub;
554        ignore_unused_variable_warning(b);
555        b = m_char &gt; m_sub;
556        ignore_unused_variable_warning(b);
557        b = m_char &gt;= m_sub;
558        ignore_unused_variable_warning(b);
559        b = m_sub == m_string;
560        ignore_unused_variable_warning(b);
561        b = m_sub != m_string;
562        ignore_unused_variable_warning(b);
563        b = m_sub &lt;= m_string;
564        ignore_unused_variable_warning(b);
565        b = m_sub &lt;= m_string;
566        ignore_unused_variable_warning(b);
567        b = m_sub &gt; m_string;
568        ignore_unused_variable_warning(b);
569        b = m_sub &gt;= m_string;
570        ignore_unused_variable_warning(b);
571        b = m_string == m_sub;
572        ignore_unused_variable_warning(b);
573        b = m_string != m_sub;
574        ignore_unused_variable_warning(b);
575        b = m_string &lt;= m_sub;
576        ignore_unused_variable_warning(b);
577        b = m_string &lt;= m_sub;
578        ignore_unused_variable_warning(b);
579        b = m_string &gt; m_sub;
580        ignore_unused_variable_warning(b);
581        b = m_string &gt;= m_sub;
582        ignore_unused_variable_warning(b);
583        m_string = m_results.str();
584        ignore_unused_variable_warning(m_string);
585        m_string = m_results.str(0);
586        ignore_unused_variable_warning(m_string);
587        m_out = m_cresults.format(m_out, m_string);
588        m_out = m_cresults.format(m_out, m_string, m_mft);
589        m_string = m_cresults.format(m_string);
590        ignore_unused_variable_warning(m_string);
591        m_string = m_cresults.format(m_string, m_mft);
592        ignore_unused_variable_warning(m_string);
593        b = global_regex_namespace::regex_match(m_string, m_smatch, e);
594        ignore_unused_variable_warning(b);
595        b = global_regex_namespace::regex_match(m_string, m_smatch, e, m_mft);
596        ignore_unused_variable_warning(b);
597        b = global_regex_namespace::regex_match(m_string, e);
598        ignore_unused_variable_warning(b);
599        b = global_regex_namespace::regex_match(m_string, e, m_mft);
600        ignore_unused_variable_warning(b);
601        b = global_regex_namespace::regex_search(m_string, m_smatch, e);
602        ignore_unused_variable_warning(b);
603        b = global_regex_namespace::regex_search(m_string, m_smatch, e, m_mft);
604        ignore_unused_variable_warning(b);
605        b = global_regex_namespace::regex_search(m_string, e);
606        ignore_unused_variable_warning(b);
607        b = global_regex_namespace::regex_search(m_string, e, m_mft);
608        ignore_unused_variable_warning(b);
609        m_out = global_regex_namespace::regex_replace(m_out, m_in, m_in, e, m_string, m_mft);
610        m_out = global_regex_namespace::regex_replace(m_out, m_in, m_in, e, m_string);
611        m_string = global_regex_namespace::regex_replace(m_string, e, m_string, m_mft);
612        ignore_unused_variable_warning(m_string);
613        m_string = global_regex_namespace::regex_replace(m_string, e, m_string);
614        ignore_unused_variable_warning(m_string);
615     }
<span onclick='openModal()' class='match'>616     flag_type m_flags;
617     string_type m_string;
618     const sub_match_type m_sub;
619     match_results_type m_results;
620     pointer_type m_pointer;
621     value_type m_char;
</span>622     const match_results_type m_cresults;
623     OutIterator m_out;
624     BidiIterator m_in;
625     global_regex_namespace::regex_constants::match_flag_type m_mft;
626     global_regex_namespace::match_results&lt;typename string_type::const_iterator, allocator_architype&lt;global_regex_namespace::sub_match&lt;typename string_type::const_iterator&gt; &gt; &gt; m_smatch;
627     RegexConcept();
628     RegexConcept(const RegexConcept&amp;);
629     RegexConcept&amp; operator=(const RegexConcept&amp;);
630  };
631  #ifndef BOOST_REGEX_TEST_STD
632  template &lt;class M&gt;
633  struct functor1
634  {
635     typedef typename M::char_type char_type;
636     const char_type* operator()(const M&amp;)const
637     {
638        static const char_type c = static_cast&lt;char_type&gt;(0);
639        return &amp;c;
640     }
641  };
642  template &lt;class M&gt;
643  struct functor1b
644  {
645     typedef typename M::char_type char_type;
646     std::vector&lt;char_type&gt; operator()(const M&amp;)const
647     {
648        static const std::vector&lt;char_type&gt; c;
649        return c;
650     }
651  };
652  template &lt;class M&gt;
653  struct functor2
654  {
655     template &lt;class O&gt;
656     O operator()(const M&amp; &amp;bsol;*m*/, O i)const
657     {
658        return i;
659     }
660  };
661  template &lt;class M&gt;
662  struct functor3
663  {
664     template &lt;class O&gt;
665     O operator()(const M&amp; &amp;bsol;*m*/, O i, regex_constants::match_flag_type)const
666     {
667        return i;
668     }
669  };
670  template &lt;class Regex&gt;
671  struct BoostRegexConcept
672  {
673     typedef typename Regex::value_type value_type;
674     typedef typename Regex::size_type size_type;
675     typedef typename Regex::flag_type flag_type;
676     typedef typename Regex::locale_type locale_type;
677     typedef const value_type* pointer_type;
678     typedef std::basic_string&lt;value_type&gt; string_type;
679     typedef typename Regex::const_iterator const_iterator;
680     typedef bidirectional_iterator_archetype&lt;value_type&gt; BidiIterator;
681     typedef output_iterator_archetype&lt;value_type&gt; OutputIterator;
682     typedef global_regex_namespace::sub_match&lt;BidiIterator&gt; sub_match_type;
683     typedef global_regex_namespace::match_results&lt;BidiIterator, allocator_architype&lt;sub_match_type&gt; &gt; match_results_type;
684     typedef global_regex_namespace::match_results&lt;BidiIterator&gt; match_results_default_type;
685     void constraints() 
686     {
687        global_regex_namespace::regex_constants::match_flag_type mopts
688           = global_regex_namespace::regex_constants::match_default
689           | global_regex_namespace::regex_constants::match_not_bol
690           | global_regex_namespace::regex_constants::match_not_eol
691           | global_regex_namespace::regex_constants::match_not_bow
692           | global_regex_namespace::regex_constants::match_not_eow
693           | global_regex_namespace::regex_constants::match_any
694           | global_regex_namespace::regex_constants::match_not_null
695           | global_regex_namespace::regex_constants::match_continuous
696           | global_regex_namespace::regex_constants::match_partial
697           | global_regex_namespace::regex_constants::match_prev_avail
698           | global_regex_namespace::regex_constants::format_default
699           | global_regex_namespace::regex_constants::format_sed
700           | global_regex_namespace::regex_constants::format_perl
701           | global_regex_namespace::regex_constants::format_no_copy
702           | global_regex_namespace::regex_constants::format_first_only;
703        (void)mopts;
704        function_requires&lt;RegexConcept&lt;Regex&gt; &gt;();
705        const global_regex_namespace::regex_error except(global_regex_namespace::regex_constants::error_collate);
706        std::ptrdiff_t pt = except.position();
707        ignore_unused_variable_warning(pt);
708        const Regex ce, ce2;
709  #ifndef BOOST_NO_STD_LOCALE
710        m_stream &lt;&lt; ce;
711  #endif
712        unsigned i = ce.error_code();
713        ignore_unused_variable_warning(i);
714        pointer_type p = ce.expression();
715        ignore_unused_variable_warning(p);
716        int i2 = ce.compare(ce2);
717        ignore_unused_variable_warning(i2);
718        bool b = ce == ce2;
719        ignore_unused_variable_warning(b);
720        b = ce.empty();
721        ignore_unused_variable_warning(b);
722        b = ce != ce2;
723        ignore_unused_variable_warning(b);
724        b = ce &lt; ce2;
725        ignore_unused_variable_warning(b);
726        b = ce &gt; ce2;
727        ignore_unused_variable_warning(b);
728        b = ce &lt;= ce2;
729        ignore_unused_variable_warning(b);
730        b = ce &gt;= ce2;
731        ignore_unused_variable_warning(b);
732        i = ce.status();
733        ignore_unused_variable_warning(i);
734        size_type s = ce.max_size();
735        ignore_unused_variable_warning(s);
736        s = ce.size();
737        ignore_unused_variable_warning(s);
738        const_iterator pi = ce.begin();
739        ignore_unused_variable_warning(pi);
740        pi = ce.end();
741        ignore_unused_variable_warning(pi);
742        string_type s2 = ce.str();
743        ignore_unused_variable_warning(s2);
744        m_string = m_sub + m_sub;
745        ignore_unused_variable_warning(m_string);
746        m_string = m_sub + m_pointer;
747        ignore_unused_variable_warning(m_string);
748        m_string = m_pointer + m_sub;
749        ignore_unused_variable_warning(m_string);
750        m_string = m_sub + m_string;
751        ignore_unused_variable_warning(m_string);
752        m_string = m_string + m_sub;
753        ignore_unused_variable_warning(m_string);
754        m_string = m_sub + m_char;
755        ignore_unused_variable_warning(m_string);
756        m_string = m_char + m_sub;
757        ignore_unused_variable_warning(m_string);
758        m_sub = m_cresults[&amp;m_char];
759        ignore_unused_variable_warning(m_sub);
760        m_sub = m_cresults[m_string];
761        ignore_unused_variable_warning(m_sub);
762        m_sub = m_cresults[&quot;&quot;];
763        ignore_unused_variable_warning(m_sub);
764        m_sub = m_cresults[std::string(&quot;&quot;)];
765        ignore_unused_variable_warning(m_sub);
766        m_string = m_cresults.str(&amp;m_char);
767        ignore_unused_variable_warning(m_string);
768        m_string = m_cresults.str(m_string);
769        ignore_unused_variable_warning(m_string);
770        m_string = m_cresults.str(&quot;&quot;);
771        ignore_unused_variable_warning(m_string);
772        m_string = m_cresults.str(std::string(&quot;&quot;));
773        ignore_unused_variable_warning(m_string);
774        typename match_results_type::difference_type diff;
775        diff = m_cresults.length(&amp;m_char);
776        ignore_unused_variable_warning(diff);
777        diff = m_cresults.length(m_string);
778        ignore_unused_variable_warning(diff);
779        diff = m_cresults.length(&quot;&quot;);
780        ignore_unused_variable_warning(diff);
781        diff = m_cresults.length(std::string(&quot;&quot;));
782        ignore_unused_variable_warning(diff);
783        diff = m_cresults.position(&amp;m_char);
784        ignore_unused_variable_warning(diff);
785        diff = m_cresults.position(m_string);
786        ignore_unused_variable_warning(diff);
787        diff = m_cresults.position(&quot;&quot;);
788        ignore_unused_variable_warning(diff);
789        diff = m_cresults.position(std::string(&quot;&quot;));
790        ignore_unused_variable_warning(diff);
791  #ifndef BOOST_NO_STD_LOCALE
792        m_stream &lt;&lt; m_sub;
793        m_stream &lt;&lt; m_cresults;
794  #endif
795        regex_constants::match_flag_type f = regex_constants::match_default;
796        OutputIterator out = static_object&lt;OutputIterator&gt;::get();
797        functor3&lt;match_results_default_type&gt; func3;
798        functor2&lt;match_results_default_type&gt; func2;
799        functor1&lt;match_results_default_type&gt; func1;
800        functor3&lt;match_results_type&gt; func3b;
801        functor2&lt;match_results_type&gt; func2b;
802        functor1&lt;match_results_type&gt; func1b;
803        out = regex_format(out, m_cresults, func3b, f);
804        out = regex_format(out, m_cresults, func3b);
805        out = regex_format(out, m_cresults, func2b, f);
806        out = regex_format(out, m_cresults, func2b);
807        out = regex_format(out, m_cresults, func1b, f);
808        out = regex_format(out, m_cresults, func1b);
809        out = regex_format(out, m_cresults, RW_NS::ref(func3b), f);
810        out = regex_format(out, m_cresults, RW_NS::ref(func3b));
811        out = regex_format(out, m_cresults, RW_NS::ref(func2b), f);
812        out = regex_format(out, m_cresults, RW_NS::ref(func2b));
813        out = regex_format(out, m_cresults, RW_NS::ref(func1b), f);
814        out = regex_format(out, m_cresults, RW_NS::ref(func1b));
815        out = regex_format(out, m_cresults, RW_NS::cref(func3b), f);
816        out = regex_format(out, m_cresults, RW_NS::cref(func3b));
817        out = regex_format(out, m_cresults, RW_NS::cref(func2b), f);
818        out = regex_format(out, m_cresults, RW_NS::cref(func2b));
819        out = regex_format(out, m_cresults, RW_NS::cref(func1b), f);
820        out = regex_format(out, m_cresults, RW_NS::cref(func1b));
821        m_string += regex_format(m_cresults, func3b, f);
822        m_string += regex_format(m_cresults, func3b);
823        m_string += regex_format(m_cresults, func2b, f);
824        m_string += regex_format(m_cresults, func2b);
825        m_string += regex_format(m_cresults, func1b, f);
826        m_string += regex_format(m_cresults, func1b);
827        m_string += regex_format(m_cresults, RW_NS::ref(func3b), f);
828        m_string += regex_format(m_cresults, RW_NS::ref(func3b));
829        m_string += regex_format(m_cresults, RW_NS::ref(func2b), f);
830        m_string += regex_format(m_cresults, RW_NS::ref(func2b));
831        m_string += regex_format(m_cresults, RW_NS::ref(func1b), f);
832        m_string += regex_format(m_cresults, RW_NS::ref(func1b));
833        m_string += regex_format(m_cresults, RW_NS::cref(func3b), f);
834        m_string += regex_format(m_cresults, RW_NS::cref(func3b));
835        m_string += regex_format(m_cresults, RW_NS::cref(func2b), f);
836        m_string += regex_format(m_cresults, RW_NS::cref(func2b));
837        m_string += regex_format(m_cresults, RW_NS::cref(func1b), f);
838        m_string += regex_format(m_cresults, RW_NS::cref(func1b));
839        out = m_cresults.format(out, func3b, f);
840        out = m_cresults.format(out, func3b);
841        out = m_cresults.format(out, func2b, f);
842        out = m_cresults.format(out, func2b);
843        out = m_cresults.format(out, func1b, f);
844        out = m_cresults.format(out, func1b);
845        out = m_cresults.format(out, RW_NS::ref(func3b), f);
846        out = m_cresults.format(out, RW_NS::ref(func3b));
847        out = m_cresults.format(out, RW_NS::ref(func2b), f);
848        out = m_cresults.format(out, RW_NS::ref(func2b));
849        out = m_cresults.format(out, RW_NS::ref(func1b), f);
850        out = m_cresults.format(out, RW_NS::ref(func1b));
851        out = m_cresults.format(out, RW_NS::cref(func3b), f);
852        out = m_cresults.format(out, RW_NS::cref(func3b));
853        out = m_cresults.format(out, RW_NS::cref(func2b), f);
854        out = m_cresults.format(out, RW_NS::cref(func2b));
855        out = m_cresults.format(out, RW_NS::cref(func1b), f);
856        out = m_cresults.format(out, RW_NS::cref(func1b));
857        m_string += m_cresults.format(func3b, f);
858        m_string += m_cresults.format(func3b);
859        m_string += m_cresults.format(func2b, f);
860        m_string += m_cresults.format(func2b);
861        m_string += m_cresults.format(func1b, f);
862        m_string += m_cresults.format(func1b);
863        m_string += m_cresults.format(RW_NS::ref(func3b), f);
864        m_string += m_cresults.format(RW_NS::ref(func3b));
865        m_string += m_cresults.format(RW_NS::ref(func2b), f);
866        m_string += m_cresults.format(RW_NS::ref(func2b));
867        m_string += m_cresults.format(RW_NS::ref(func1b), f);
868        m_string += m_cresults.format(RW_NS::ref(func1b));
869        m_string += m_cresults.format(RW_NS::cref(func3b), f);
870        m_string += m_cresults.format(RW_NS::cref(func3b));
871        m_string += m_cresults.format(RW_NS::cref(func2b), f);
872        m_string += m_cresults.format(RW_NS::cref(func2b));
873        m_string += m_cresults.format(RW_NS::cref(func1b), f);
874        m_string += m_cresults.format(RW_NS::cref(func1b));
875        out = regex_replace(out, m_in, m_in, ce, func3, f);
876        out = regex_replace(out, m_in, m_in, ce, func3);
877        out = regex_replace(out, m_in, m_in, ce, func2, f);
878        out = regex_replace(out, m_in, m_in, ce, func2);
879        out = regex_replace(out, m_in, m_in, ce, func1, f);
880        out = regex_replace(out, m_in, m_in, ce, func1);
881        out = regex_replace(out, m_in, m_in, ce, RW_NS::ref(func3), f);
882        out = regex_replace(out, m_in, m_in, ce, RW_NS::ref(func3));
883        out = regex_replace(out, m_in, m_in, ce, RW_NS::ref(func2), f);
884        out = regex_replace(out, m_in, m_in, ce, RW_NS::ref(func2));
885        out = regex_replace(out, m_in, m_in, ce, RW_NS::ref(func1), f);
886        out = regex_replace(out, m_in, m_in, ce, RW_NS::ref(func1));
887        out = regex_replace(out, m_in, m_in, ce, RW_NS::cref(func3), f);
888        out = regex_replace(out, m_in, m_in, ce, RW_NS::cref(func3));
889        out = regex_replace(out, m_in, m_in, ce, RW_NS::cref(func2), f);
890        out = regex_replace(out, m_in, m_in, ce, RW_NS::cref(func2));
891        out = regex_replace(out, m_in, m_in, ce, RW_NS::cref(func1), f);
892        out = regex_replace(out, m_in, m_in, ce, RW_NS::cref(func1));
893        functor3&lt;match_results&lt;typename string_type::const_iterator&gt; &gt; func3s;
894        functor2&lt;match_results&lt;typename string_type::const_iterator&gt; &gt; func2s;
895        functor1&lt;match_results&lt;typename string_type::const_iterator&gt; &gt; func1s;
896        m_string += regex_replace(m_string, ce, func3s, f);
897        m_string += regex_replace(m_string, ce, func3s);
898        m_string += regex_replace(m_string, ce, func2s, f);
899        m_string += regex_replace(m_string, ce, func2s);
900        m_string += regex_replace(m_string, ce, func1s, f);
901        m_string += regex_replace(m_string, ce, func1s);
902        m_string += regex_replace(m_string, ce, RW_NS::ref(func3s), f);
903        m_string += regex_replace(m_string, ce, RW_NS::ref(func3s));
904        m_string += regex_replace(m_string, ce, RW_NS::ref(func2s), f);
905        m_string += regex_replace(m_string, ce, RW_NS::ref(func2s));
906        m_string += regex_replace(m_string, ce, RW_NS::ref(func1s), f);
907        m_string += regex_replace(m_string, ce, RW_NS::ref(func1s));
908        m_string += regex_replace(m_string, ce, RW_NS::cref(func3s), f);
909        m_string += regex_replace(m_string, ce, RW_NS::cref(func3s));
910        m_string += regex_replace(m_string, ce, RW_NS::cref(func2s), f);
911        m_string += regex_replace(m_string, ce, RW_NS::cref(func2s));
912        m_string += regex_replace(m_string, ce, RW_NS::cref(func1s), f);
913        m_string += regex_replace(m_string, ce, RW_NS::cref(func1s));
914     }
915     std::basic_ostream&lt;value_type&gt; m_stream;
916     sub_match_type m_sub;
917     pointer_type m_pointer;
918     string_type m_string;
919     const value_type m_char;
920     match_results_type m_results;
921     const match_results_type m_cresults;
922     BidiIterator m_in;
923     BoostRegexConcept();
924     BoostRegexConcept(const BoostRegexConcept&amp;);
925     BoostRegexConcept&amp; operator=(const BoostRegexConcept&amp;);
926  };
927  #endif 
928  }
929  #endif
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-regex_token_iterator.hpp</h3>
            <pre><code>1  #ifndef BOOST_REGEX_V5_REGEX_TOKEN_ITERATOR_HPP
2  #define BOOST_REGEX_V5_REGEX_TOKEN_ITERATOR_HPP
3  #include &lt;memory&gt;
4  namespace boost{
5  template &lt;class BidirectionalIterator,
6            class charT,
7            class traits&gt;
8  class regex_token_iterator_implementation 
9  {
10     typedef basic_regex&lt;charT, traits&gt; regex_type;
11     typedef sub_match&lt;BidirectionalIterator&gt;      value_type;
12     match_results&lt;BidirectionalIterator&gt; what;   
<span onclick='openModal()' class='match'>13     BidirectionalIterator                base;    
14     BidirectionalIterator                end;    
15     const regex_type                     re;    
16     match_flag_type                      flags;  
17     value_type                           result; 
18     int                                  N;      
</span>19     std::vector&lt;int&gt;                     subs;   
20  public:
21     regex_token_iterator_implementation(const regex_type* p, BidirectionalIterator last, int sub, match_flag_type f)
22        : end(last), re(*p), flags(f), N(0){ subs.push_back(sub); }
23     regex_token_iterator_implementation(const regex_type* p, BidirectionalIterator last, const std::vector&lt;int&gt;&amp; v, match_flag_type f)
24        : end(last), re(*p), flags(f), N(0), subs(v){}
25     template &lt;std::size_t CN&gt;
26     regex_token_iterator_implementation(const regex_type* p, BidirectionalIterator last, const int (&amp;submatches)[CN], match_flag_type f)
27        : end(last), re(*p), flags(f), N(0)
28     {
29        for(std::size_t i = 0; i &lt; CN; ++i)
30        {
31           subs.push_back(submatches[i]);
32        }
33     }
34     regex_token_iterator_implementation(const regex_token_iterator_implementation&amp; other) = default;
35     bool init(BidirectionalIterator first)
36     {
37        N = 0;
38        base = first;
39        if(regex_search(first, end, what, re, flags, base) == true)
40        {
41           N = 0;
42           result = ((subs[N] == -1) ? what.prefix() : what[(int)subs[N]]);
43           return true;
44        }
45        else if((subs[N] == -1) &amp;&amp; (first != end))
46        {
47           result.first = first;
48           result.second = end;
49           result.matched = (first != end);
50           N = -1;
51           return true;
52        }
53        return false;
54     }
55     bool compare(const regex_token_iterator_implementation&amp; that)
56     {
57        if(this == &amp;that) return true;
58        return (&amp;re.get_data() == &amp;that.re.get_data()) 
59           &amp;&amp; (end == that.end) 
60           &amp;&amp; (flags == that.flags) 
61           &amp;&amp; (N == that.N) 
62           &amp;&amp; (what[0].first == that.what[0].first) 
63           &amp;&amp; (what[0].second == that.what[0].second);
64     }
65     const value_type&amp; get()
66     { return result; }
67     bool next()
68     {
69        if(N == -1)
70           return false;
71        if(N+1 &lt; (int)subs.size())
72        {
73           ++N;
74           result =((subs[N] == -1) ? what.prefix() : what[subs[N]]);
75           return true;
76        }
77        BidirectionalIterator last_end(what[0].second);
78        if(regex_search(last_end, end, what, re, ((what[0].first == what[0].second) ? flags | regex_constants::match_not_initial_null : flags), base))
79        {
80           N =0;
81           result =((subs[N] == -1) ? what.prefix() : what[subs[N]]);
82           return true;
83        }
84        else if((last_end != end) &amp;&amp; (subs[0] == -1))
85        {
86           N =-1;
87           result.first = last_end;
88           result.second = end;
89           result.matched = (last_end != end);
90           return true;
91        }
92        return false;
93     }
94  private:
95     regex_token_iterator_implementation&amp; operator=(const regex_token_iterator_implementation&amp;);
96  };
97  template &lt;class BidirectionalIterator, 
98            class charT = typename std::iterator_traits&lt;BidirectionalIterator&gt;::value_type,
99            class traits = regex_traits&lt;charT&gt; &gt;
100  class regex_token_iterator 
101  {
102  private:
103     typedef regex_token_iterator_implementation&lt;BidirectionalIterator, charT, traits&gt; impl;
104     typedef std::shared_ptr&lt;impl&gt; pimpl;
105  public:
106     typedef          basic_regex&lt;charT, traits&gt;                   regex_type;
107     typedef          sub_match&lt;BidirectionalIterator&gt;                        value_type;
108     typedef typename std::iterator_traits&lt;BidirectionalIterator&gt;::difference_type 
109                                                                              difference_type;
110     typedef          const value_type*                                       pointer;
111     typedef          const value_type&amp;                                       reference; 
112     typedef          std::forward_iterator_tag                               iterator_category;
113     regex_token_iterator(){}
114     regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b, const regex_type&amp; re, 
115                          int submatch = 0, match_flag_type m = match_default)
116                          : pdata(new impl(&amp;re, b, submatch, m))
117     {
118        if(!pdata-&gt;init(a))
119           pdata.reset();
120     }
121     regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b, const regex_type&amp; re, 
122                          const std::vector&lt;int&gt;&amp; submatches, match_flag_type m = match_default)
123                          : pdata(new impl(&amp;re, b, submatches, m))
124     {
125        if(!pdata-&gt;init(a))
126           pdata.reset();
127     }
128     template &lt;std::size_t N&gt;
129     regex_token_iterator(BidirectionalIterator a, BidirectionalIterator b, const regex_type&amp; re,
130                          const int (&amp;submatches)[N], match_flag_type m = match_default)
131                          : pdata(new impl(&amp;re, b, submatches, m))
132     {
133        if(!pdata-&gt;init(a))
134           pdata.reset();
135     }
136     regex_token_iterator(const regex_token_iterator&amp; that)
137        : pdata(that.pdata) {}
138     regex_token_iterator&amp; operator=(const regex_token_iterator&amp; that)
139     {
140        pdata = that.pdata;
141        return *this;
142     }
143     bool operator==(const regex_token_iterator&amp; that)const
144     { 
145        if((pdata.get() == 0) || (that.pdata.get() == 0))
146           return pdata.get() == that.pdata.get();
147        return pdata-&gt;compare(*(that.pdata.get())); 
148     }
149     bool operator!=(const regex_token_iterator&amp; that)const
150     { return !(*this == that); }
151     const value_type&amp; operator*()const
152     { return pdata-&gt;get(); }
153     const value_type* operator-&gt;()const
154     { return &amp;(pdata-&gt;get()); }
155     regex_token_iterator&amp; operator++()
156     {
157        cow();
158        if(0 == pdata-&gt;next())
159        {
160           pdata.reset();
161        }
162        return *this;
163     }
164     regex_token_iterator operator++(int)
165     {
166        regex_token_iterator result(*this);
167        ++(*this);
168        return result;
169     }
170  private:
171     pimpl pdata;
172     void cow()
173     {
174        if(pdata.get() &amp;&amp; (pdata.use_count() &gt; 1))
175        {
176           pdata.reset(new impl(*(pdata.get())));
177        }
178     }
179  };
180  typedef regex_token_iterator&lt;const char*&gt; cregex_token_iterator;
181  typedef regex_token_iterator&lt;std::string::const_iterator&gt; sregex_token_iterator;
182  #ifndef BOOST_NO_WREGEX
183  typedef regex_token_iterator&lt;const wchar_t*&gt; wcregex_token_iterator;
184  typedef regex_token_iterator&lt;std::wstring::const_iterator&gt; wsregex_token_iterator;
185  #endif
186  template &lt;class charT, class traits&gt;
187  inline regex_token_iterator&lt;const charT*, charT, traits&gt; make_regex_token_iterator(const charT* p, const basic_regex&lt;charT, traits&gt;&amp; e, int submatch = 0, regex_constants::match_flag_type m = regex_constants::match_default)
188  {
189     return regex_token_iterator&lt;const charT*, charT, traits&gt;(p, p+traits::length(p), e, submatch, m);
190  }
191  template &lt;class charT, class traits, class ST, class SA&gt;
192  inline regex_token_iterator&lt;typename std::basic_string&lt;charT, ST, SA&gt;::const_iterator, charT, traits&gt; make_regex_token_iterator(const std::basic_string&lt;charT, ST, SA&gt;&amp; p, const basic_regex&lt;charT, traits&gt;&amp; e, int submatch = 0, regex_constants::match_flag_type m = regex_constants::match_default)
193  {
194     return regex_token_iterator&lt;typename std::basic_string&lt;charT, ST, SA&gt;::const_iterator, charT, traits&gt;(p.begin(), p.end(), e, submatch, m);
195  }
196  template &lt;class charT, class traits, std::size_t N&gt;
197  inline regex_token_iterator&lt;const charT*, charT, traits&gt; make_regex_token_iterator(const charT* p, const basic_regex&lt;charT, traits&gt;&amp; e, const int (&amp;submatch)[N], regex_constants::match_flag_type m = regex_constants::match_default)
198  {
199     return regex_token_iterator&lt;const charT*, charT, traits&gt;(p, p+traits::length(p), e, submatch, m);
200  }
201  template &lt;class charT, class traits, class ST, class SA, std::size_t N&gt;
202  inline regex_token_iterator&lt;typename std::basic_string&lt;charT, ST, SA&gt;::const_iterator, charT, traits&gt; make_regex_token_iterator(const std::basic_string&lt;charT, ST, SA&gt;&amp; p, const basic_regex&lt;charT, traits&gt;&amp; e, const int (&amp;submatch)[N], regex_constants::match_flag_type m = regex_constants::match_default)
203  {
204     return regex_token_iterator&lt;typename std::basic_string&lt;charT, ST, SA&gt;::const_iterator, charT, traits&gt;(p.begin(), p.end(), e, submatch, m);
205  }
206  template &lt;class charT, class traits&gt;
207  inline regex_token_iterator&lt;const charT*, charT, traits&gt; make_regex_token_iterator(const charT* p, const basic_regex&lt;charT, traits&gt;&amp; e, const std::vector&lt;int&gt;&amp; submatch, regex_constants::match_flag_type m = regex_constants::match_default)
208  {
209     return regex_token_iterator&lt;const charT*, charT, traits&gt;(p, p+traits::length(p), e, submatch, m);
210  }
211  template &lt;class charT, class traits, class ST, class SA&gt;
212  inline regex_token_iterator&lt;typename std::basic_string&lt;charT, ST, SA&gt;::const_iterator, charT, traits&gt; make_regex_token_iterator(const std::basic_string&lt;charT, ST, SA&gt;&amp; p, const basic_regex&lt;charT, traits&gt;&amp; e, const std::vector&lt;int&gt;&amp; submatch, regex_constants::match_flag_type m = regex_constants::match_default)
213  {
214     return regex_token_iterator&lt;typename std::basic_string&lt;charT, ST, SA&gt;::const_iterator, charT, traits&gt;(p.begin(), p.end(), e, submatch, m);
215  }
216  } 
217  #endif 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-concepts.hpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-regex_token_iterator.hpp</div>
                </div>
                <div class="column column_space"><pre><code>616     flag_type m_flags;
617     string_type m_string;
618     const sub_match_type m_sub;
619     match_results_type m_results;
620     pointer_type m_pointer;
621     value_type m_char;
</pre></code></div>
                <div class="column column_space"><pre><code>13     BidirectionalIterator                base;    
14     BidirectionalIterator                end;    
15     const regex_type                     re;    
16     match_flag_type                      flags;  
17     value_type                           result; 
18     int                                  N;      
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    