
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 14.652014652014653%, Tokens: 10, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-concat_layer.cpp</h3>
            <pre><code>1  #include <vector>
2  #ifdef _OPENMP
3  #include <omp.h>
4  #endif
5  #include "caffe/layers/concat_layer.hpp"
6  #include "caffe/util/math_functions.hpp"
7  namespace caffe {
8  template <typename Dtype>
9  void ConcatLayer<Dtype>::LayerSetUp(const vector<Blob<Dtype>*>& bottom,
10        const vector<Blob<Dtype>*>& top) {
11    const ConcatParameter& concat_param = this->layer_param_.concat_param();
12    CHECK(!(concat_param.has_axis() && concat_param.has_concat_dim()))
13        << "Either axis or concat_dim should be specified; not both.";
14  }
15  template <typename Dtype>
16  void ConcatLayer<Dtype>::Reshape(const vector<Blob<Dtype>*>& bottom,
17        const vector<Blob<Dtype>*>& top) {
18    const int num_axes = bottom[0]->num_axes();
19    const ConcatParameter& concat_param = this->layer_param_.concat_param();
20    if (concat_param.has_concat_dim()) {
21      concat_axis_ = static_cast<int>(concat_param.concat_dim());
22      CHECK_GE(concat_axis_, 0) << "casting concat_dim from uint32 to int32 "
23          << "produced negative result; concat_dim must satisfy "
24          << "0 <= concat_dim < " << kMaxBlobAxes;
25      CHECK_LT(concat_axis_, num_axes) << "concat_dim out of range.";
26    } else {
27      concat_axis_ = bottom[0]->CanonicalAxisIndex(concat_param.axis());
28    }
29    vector<int> top_shape = bottom[0]->shape();
30    num_concats_ = bottom[0]->count(0, concat_axis_);
31    concat_input_size_ = bottom[0]->count(concat_axis_ + 1);
32    int bottom_count_sum = bottom[0]->count();
33    for (int i = 1; i < bottom.size(); ++i) {
34      CHECK_EQ(num_axes, bottom[i]->num_axes())
35          << "All inputs must have the same #axes.";
36      for (int j = 0; j < num_axes; ++j) {
37        if (j == concat_axis_) { continue; }
38        CHECK_EQ(top_shape[j], bottom[i]->shape(j))
39            << "All inputs must have the same shape, except at concat_axis.";
40      }
41      bottom_count_sum += bottom[i]->count();
42      top_shape[concat_axis_] += bottom[i]->shape(concat_axis_);
43    }
44    top[0]->Reshape(top_shape);
45    CHECK_EQ(bottom_count_sum, top[0]->count());
46    if (bottom.size() == 1) {
47      top[0]->ShareData(*bottom[0]);
48      top[0]->ShareDiff(*bottom[0]);
49    }
50  }
51  template <typename Dtype>
52  void ConcatLayer<Dtype>::Forward_cpu(const vector<Blob<Dtype>*>& bottom,
53        const vector<Blob<Dtype>*>& top) {
54    if (bottom.size() == 1) { return; }
55    Dtype* top_data = top[0]->mutable_cpu_data();
56    int offset_concat_axis = 0;
57    const int top_concat_axis = top[0]->shape(concat_axis_);
58    for (int i = 0; i < bottom.size(); ++i) {
59      const Dtype* bottom_data = bottom[i]->cpu_data();
60      const int bottom_concat_axis = bottom[i]->shape(concat_axis_);
61      const int offset_value = offset_concat_axis;
62      offset_concat_axis += bottom_concat_axis;
63  #ifdef _OPENMP
64    #pragma omp parallel for if(num_concats_ > 1)
65  #endif
66      for (int n = 0; n < num_concats_; ++n) {
67        caffe_copy(bottom_concat_axis * concat_input_size_,
68            bottom_data + n * bottom_concat_axis * concat_input_size_,
69            top_data + (n * top_concat_axis + offset_value)
70                * concat_input_size_);
71      }
72    }
73  }
74  template <typename Dtype>
75  void ConcatLayer<Dtype>::Backward_cpu(const vector<Blob<Dtype>*>& top,
76        const vector<bool>& propagate_down, const vector<Blob<Dtype>*>& bottom) {
77    if (bottom.size() == 1) { return; }
78    const Dtype* top_diff = top[0]->cpu_diff();
79    int offset_concat_axis = 0;
80    const int top_concat_axis = top[0]->shape(concat_axis_);
81    for (int i = 0; i < bottom.size(); ++i) {
82      const int bottom_concat_axis = bottom[i]->shape(concat_axis_);
83      const int offset_value = offset_concat_axis;
84      offset_concat_axis += bottom_concat_axis;
85      if (propagate_down[i]) {
86        Dtype* bottom_diff = bottom[i]->mutable_cpu_diff();
87  #ifdef _OPENMP
88    #pragma omp parallel for if(num_concats_ > 1)
89  #endif
<span onclick='openModal()' class='match'>90        for (int n = 0; n < num_concats_; ++n) {
91          caffe_copy(bottom_concat_axis * concat_input_size_, top_diff +
92              (n * top_concat_axis + offset_value) * concat_input_size_,
93              bottom_diff + n * bottom_concat_axis * concat_input_size_);
94        }
95      }
96    }
97  }
98  #ifdef CPU_ONLY
99  STUB_GPU(ConcatLayer);
100  #endif
101  INSTANTIATE_CLASS(ConcatLayer);
102  }  
</span></code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-charconv_bigint_test.cc</h3>
            <pre><code>1  #include "absl/strings/internal/charconv_bigint.h"
2  #include <string>
3  #include "gtest/gtest.h"
4  namespace absl {
5  ABSL_NAMESPACE_BEGIN
6  namespace strings_internal {
7  TEST(BigUnsigned, ShiftLeft) {
8    {
9      BigUnsigned<4> num(3u);
10      num.ShiftLeft(100);
11      EXPECT_EQ(num, BigUnsigned<4>("3802951800684688204490109616128"));
12    }
13    {
14      BigUnsigned<4> a(15u);
15      BigUnsigned<4> b(7u);
16      BigUnsigned<4> c(3u);
17      a.ShiftLeft(125);
18      b.ShiftLeft(125);
19      c.ShiftLeft(125);
20      EXPECT_EQ(a, b);
21      EXPECT_NE(a, c);
22    }
23    {
24      BigUnsigned<84> a(15u);
25      BigUnsigned<84> b(7u);
26      BigUnsigned<84> c(3u);
27      a.ShiftLeft(84 * 32 - 3);
28      b.ShiftLeft(84 * 32 - 3);
29      c.ShiftLeft(84 * 32 - 3);
30      EXPECT_EQ(a, b);
31      EXPECT_NE(a, c);
32    }
33    {
34      const std::string seed = "1234567890123456789012345678901234567890";
35      BigUnsigned<84> a(seed);
36      for (int i = 1; i <= 84 * 32; ++i) {
37        a.ShiftLeft(1);
38        BigUnsigned<84> b(seed);
39        b.ShiftLeft(i);
40        EXPECT_EQ(a, b);
41      }
42      EXPECT_EQ(a, BigUnsigned<84>(0u));
43    }
44    {
45      const BigUnsigned<84> all_bits_one(
46          "1474444211396924248063325089479706787923460402125687709454567433186613"
47          "6228083464060749874845919674257665016359189106695900028098437021384227"
48          "3285029708032466536084583113729486015826557532750465299832071590813090"
49          "2011853039837649252477307070509704043541368002938784757296893793903797"
50          "8180292336310543540677175225040919704702800559606097685920595947397024"
51          "8303316808753252115729411497720357971050627997031988036134171378490368"
52          "6008000778741115399296162550786288457245180872759047016734959330367829"
53          "5235612397427686310674725251378116268607113017720538636924549612987647"
54          "5767411074510311386444547332882472126067840027882117834454260409440463"
55          "9345147252664893456053258463203120637089916304618696601333953616715125"
56          "2115882482473279040772264257431663818610405673876655957323083702713344"
57          "4201105427930770976052393421467136557055");
58      const BigUnsigned<84> zero(0u);
59      const BigUnsigned<84> one(1u);
60      for (int i = 1; i < 84*32; ++i) {
61        BigUnsigned<84> big_shifted = all_bits_one;
62        big_shifted.ShiftLeft(i);
63        EXPECT_GT(all_bits_one, big_shifted);
64        BigUnsigned<84> small_shifted = one;
65        small_shifted.ShiftLeft(i);
66        EXPECT_LT(one, small_shifted);
67      }
68      for (int no_op_shift : {0, -1, -84 * 32, std::numeric_limits<int>::min()}) {
69        BigUnsigned<84> big_shifted = all_bits_one;
70        big_shifted.ShiftLeft(no_op_shift);
71        EXPECT_EQ(all_bits_one, big_shifted);
72        BigUnsigned<84> small_shifted = one;
73        big_shifted.ShiftLeft(no_op_shift);
74        EXPECT_EQ(one, small_shifted);
75      }
76      for (int out_of_bounds_shift :
77           {84 * 32, 84 * 32 + 1, std::numeric_limits<int>::max()}) {
78        BigUnsigned<84> big_shifted = all_bits_one;
79        big_shifted.ShiftLeft(out_of_bounds_shift);
80        EXPECT_EQ(zero, big_shifted);
81        BigUnsigned<84> small_shifted = one;
82        small_shifted.ShiftLeft(out_of_bounds_shift);
83        EXPECT_EQ(zero, small_shifted);
84      }
85    }
86  }
87  TEST(BigUnsigned, MultiplyByUint32) {
88    const BigUnsigned<84> factorial_100(
89        "933262154439441526816992388562667004907159682643816214685929638952175999"
90        "932299156089414639761565182862536979208272237582511852109168640000000000"
91        "00000000000000");
92    BigUnsigned<84> a(1u);
93    for (uint32_t i = 1; i <= 100; ++i) {
94      a.MultiplyBy(i);
95    }
96    EXPECT_EQ(a, BigUnsigned<84>(factorial_100));
97  }
98  TEST(BigUnsigned, MultiplyByBigUnsigned) {
99    {
100      const BigUnsigned<84> factorial_200(
101          "7886578673647905035523632139321850622951359776871732632947425332443594"
102          "4996340334292030428401198462390417721213891963883025764279024263710506"
103          "1926624952829931113462857270763317237396988943922445621451664240254033"
104          "2918641312274282948532775242424075739032403212574055795686602260319041"
105          "7032406235170085879617892222278962370389737472000000000000000000000000"
106          "0000000000000000000000000");
107      BigUnsigned<84> evens(1u);
108      BigUnsigned<84> odds(1u);
109      for (uint32_t i = 1; i < 200; i += 2) {
110        odds.MultiplyBy(i);
111        evens.MultiplyBy(i + 1);
112      }
113      evens.MultiplyBy(odds);
114      EXPECT_EQ(evens, factorial_200);
115    }
116    {
117      for (int a = 0 ; a < 700; a += 25) {
118        SCOPED_TRACE(a);
119        BigUnsigned<84> a_value("3" + std::string(a, '0'));
120        for (int b = 0; b < (700 - a); b += 25) {
121          SCOPED_TRACE(b);
122          BigUnsigned<84> b_value("2" + std::string(b, '0'));
123          BigUnsigned<84> expected_product("6" + std::string(a + b, '0'));
124          b_value.MultiplyBy(a_value);
125          EXPECT_EQ(b_value, expected_product);
126        }
127      }
128    }
129  }
130  TEST(BigUnsigned, MultiplyByOverflow) {
131    {
132      BigUnsigned<4> all_bits_on("340282366920938463463374607431768211455");
133      all_bits_on.MultiplyBy(all_bits_on);
134      EXPECT_EQ(all_bits_on, BigUnsigned<4>(1u));
135    }
136    {
137      BigUnsigned<4> value_1("12345678901234567890123456789012345678");
138      BigUnsigned<4> value_2("12345678901234567890123456789012345678");
139      BigUnsigned<4> two_to_fiftieth(1u);
140      two_to_fiftieth.ShiftLeft(50);
141      value_1.ShiftLeft(50);
142      value_2.MultiplyBy(two_to_fiftieth);
143      EXPECT_EQ(value_1, value_2);
144    }
145  }
146  TEST(BigUnsigned, FiveToTheNth) {
147    {
148      for (int i = 0; i < 1160; ++i) {
149        SCOPED_TRACE(i);
150        BigUnsigned<84> value_1(123u);
151        BigUnsigned<84> value_2(123u);
152        value_1.MultiplyByFiveToTheNth(i);
153        for (int j = 0; j < i; j++) {
154          value_2.MultiplyBy(5u);
155        }
156        EXPECT_EQ(value_1, value_2);
157      }
158    }
159    {
160      for (int i = 0; i < 1160; ++i) {
161        SCOPED_TRACE(i);
162        BigUnsigned<84> value_1(1u);
163        value_1.MultiplyByFiveToTheNth(i);
164        BigUnsigned<84> value_2 = BigUnsigned<84>::FiveToTheNth(i);
165        EXPECT_EQ(value_1, value_2);
166      }
167    }
168  }
169  TEST(BigUnsigned, TenToTheNth) {
170    {
171      for (int i = 0; i < 800; ++i) {
172        SCOPED_TRACE(i);
173        BigUnsigned<84> value_1(123u);
174        BigUnsigned<84> value_2(123u);
175        value_1.MultiplyByTenToTheNth(i);
176        for (int j = 0; j < i; j++) {
177          value_2.MultiplyBy(10u);
178        }
179        EXPECT_EQ(value_1, value_2);
180      }
181    }
182    {
<span onclick='openModal()' class='match'>183      for (int i = 0; i < 200; ++i) {
184        SCOPED_TRACE(i);
185        BigUnsigned<84> value_1(135u);
186        value_1.MultiplyByTenToTheNth(i);
187        BigUnsigned<84> value_2("135" + std::string(i, '0'));
188        EXPECT_EQ(value_1, value_2);
189      }
190    }
191  }
192  }  
193  ABSL_NAMESPACE_END
194  }  
</span></code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-concat_layer.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-charconv_bigint_test.cc</div>
                </div>
                <div class="column column_space"><pre><code>90        for (int n = 0; n < num_concats_; ++n) {
91          caffe_copy(bottom_concat_axis * concat_input_size_, top_diff +
92              (n * top_concat_axis + offset_value) * concat_input_size_,
93              bottom_diff + n * bottom_concat_axis * concat_input_size_);
94        }
95      }
96    }
97  }
98  #ifdef CPU_ONLY
99  STUB_GPU(ConcatLayer);
100  #endif
101  INSTANTIATE_CLASS(ConcatLayer);
102  }  
</pre></code></div>
                <div class="column column_space"><pre><code>183      for (int i = 0; i < 200; ++i) {
184        SCOPED_TRACE(i);
185        BigUnsigned<84> value_1(135u);
186        value_1.MultiplyByTenToTheNth(i);
187        BigUnsigned<84> value_2("135" + std::string(i, '0'));
188        EXPECT_EQ(value_1, value_2);
189      }
190    }
191  }
192  }  
193  ABSL_NAMESPACE_END
194  }  
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    