
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 20, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-btree_benchmark.cc</h3>
            <pre><code>1  #include &lt;stdint.h&gt;
2  #include &lt;algorithm&gt;
3  #include &lt;functional&gt;
4  #include &lt;map&gt;
5  #include &lt;numeric&gt;
6  #include &lt;random&gt;
7  #include &lt;set&gt;
8  #include &lt;string&gt;
9  #include &lt;type_traits&gt;
10  #include &lt;unordered_map&gt;
11  #include &lt;unordered_set&gt;
12  #include &lt;vector&gt;
13  #include &quot;benchmark/benchmark.h&quot;
14  #include &quot;absl/algorithm/container.h&quot;
15  #include &quot;absl/base/internal/raw_logging.h&quot;
16  #include &quot;absl/container/btree_map.h&quot;
17  #include &quot;absl/container/btree_set.h&quot;
18  #include &quot;absl/container/btree_test.h&quot;
19  #include &quot;absl/container/flat_hash_map.h&quot;
20  #include &quot;absl/container/flat_hash_set.h&quot;
21  #include &quot;absl/container/internal/hashtable_debug.h&quot;
22  #include &quot;absl/hash/hash.h&quot;
23  #include &quot;absl/log/log.h&quot;
24  #include &quot;absl/memory/memory.h&quot;
25  #include &quot;absl/random/random.h&quot;
26  #include &quot;absl/strings/cord.h&quot;
27  #include &quot;absl/strings/str_format.h&quot;
28  #include &quot;absl/time/time.h&quot;
29  namespace absl {
30  ABSL_NAMESPACE_BEGIN
31  namespace container_internal {
32  namespace {
33  constexpr size_t kBenchmarkValues = 1 &lt;&lt; 20;
34  constexpr size_t kAddRemBatchSize = 1 &lt;&lt; 2;
35  template &lt;typename V&gt;
36  std::vector&lt;V&gt; GenerateValues(int n) {
37    constexpr int kSeed = 23;
38    return GenerateValuesWithSeed&lt;V&gt;(n, 4 * n, kSeed);
39  }
40  template &lt;typename T&gt;
41  void BM_InsertImpl(benchmark::State&amp; state, bool sorted) {
42    using V = typename remove_pair_const&lt;typename T::value_type&gt;::type;
43    typename KeyOfValue&lt;typename T::key_type, V&gt;::type key_of_value;
44    std::vector&lt;V&gt; values = GenerateValues&lt;V&gt;(kBenchmarkValues);
45    if (sorted) {
46      std::sort(values.begin(), values.end());
47    }
48    T container(values.begin(), values.end());
49    const int batch_size = (kBenchmarkValues + 9) / 10;
50    while (state.KeepRunningBatch(batch_size)) {
51      state.PauseTiming();
52      const auto i = static_cast&lt;int&gt;(state.iterations());
53      for (int j = i; j &lt; i + batch_size; j++) {
54        int x = j % kBenchmarkValues;
55        container.erase(key_of_value(values[x]));
56      }
57      state.ResumeTiming();
58      for (int j = i; j &lt; i + batch_size; j++) {
59        int x = j % kBenchmarkValues;
60        container.insert(values[x]);
61      }
62    }
63  }
64  template &lt;typename T&gt;
65  void BM_Insert(benchmark::State&amp; state) {
66    BM_InsertImpl&lt;T&gt;(state, false);
67  }
68  template &lt;typename T&gt;
69  void BM_InsertSorted(benchmark::State&amp; state) {
70    BM_InsertImpl&lt;T&gt;(state, true);
71  }
72  template &lt;typename T&gt;
73  void BM_InsertSmall(benchmark::State&amp; state) {
74    using V = typename remove_pair_const&lt;typename T::value_type&gt;::type;
75    const int kSize = 8;
76    std::vector&lt;V&gt; values = GenerateValues&lt;V&gt;(kSize);
77    T container;
78    while (state.KeepRunningBatch(kSize)) {
79      for (int i = 0; i &lt; kSize; ++i) {
80        benchmark::DoNotOptimize(container.insert(values[i]));
81      }
82      state.PauseTiming();
83      container.clear();
84      state.ResumeTiming();
85    }
86  }
87  template &lt;typename T&gt;
88  void BM_LookupImpl(benchmark::State&amp; state, bool sorted) {
89    using V = typename remove_pair_const&lt;typename T::value_type&gt;::type;
90    typename KeyOfValue&lt;typename T::key_type, V&gt;::type key_of_value;
91    std::vector&lt;V&gt; values = GenerateValues&lt;V&gt;(kBenchmarkValues);
92    if (sorted) {
93      std::sort(values.begin(), values.end());
94    }
95    T container(values.begin(), values.end());
96    while (state.KeepRunning()) {
97      int idx = state.iterations() % kBenchmarkValues;
98      benchmark::DoNotOptimize(container.find(key_of_value(values[idx])));
99    }
100  }
101  template &lt;typename T&gt;
102  void BM_Lookup(benchmark::State&amp; state) {
103    BM_LookupImpl&lt;T&gt;(state, false);
104  }
105  template &lt;typename T&gt;
106  void BM_FullLookup(benchmark::State&amp; state) {
107    BM_LookupImpl&lt;T&gt;(state, true);
108  }
109  template &lt;typename T&gt;
110  void BM_Erase(benchmark::State&amp; state) {
111    using V = typename remove_pair_const&lt;typename T::value_type&gt;::type;
112    typename KeyOfValue&lt;typename T::key_type, V&gt;::type key_of_value;
113    std::vector&lt;V&gt; values = GenerateValues&lt;V&gt;(kBenchmarkValues);
114    T container(values.begin(), values.end());
115    const int batch_size = (kBenchmarkValues + 9) / 10;
116    while (state.KeepRunningBatch(batch_size)) {
117      const int i = state.iterations();
118      for (int j = i; j &lt; i + batch_size; j++) {
119        int x = j % kBenchmarkValues;
120        container.erase(key_of_value(values[x]));
121      }
122      state.PauseTiming();
123      for (int j = i; j &lt; i + batch_size; j++) {
124        int x = j % kBenchmarkValues;
125        container.insert(values[x]);
126      }
127      state.ResumeTiming();
128    }
129  }
130  template &lt;typename T&gt;
131  void BM_EraseRange(benchmark::State&amp; state) {
132    using V = typename remove_pair_const&lt;typename T::value_type&gt;::type;
133    typename KeyOfValue&lt;typename T::key_type, V&gt;::type key_of_value;
134    std::vector&lt;V&gt; values = GenerateValues&lt;V&gt;(kBenchmarkValues);
135    T container(values.begin(), values.end());
136    const int batch_size = (kBenchmarkValues + 9) / 10;
137    while (state.KeepRunningBatch(batch_size)) {
138      const int i = state.iterations();
139      const int start_index = i % kBenchmarkValues;
140      state.PauseTiming();
141      {
142        std::vector&lt;V&gt; removed;
143        removed.reserve(batch_size);
144        auto itr = container.find(key_of_value(values[start_index]));
145        auto start = itr;
146        for (int j = 0; j &lt; batch_size; j++) {
147          if (itr == container.end()) {
148            state.ResumeTiming();
149            container.erase(start, itr);
150            state.PauseTiming();
151            itr = container.begin();
152            start = itr;
153          }
154          removed.push_back(*itr++);
155        }
156        state.ResumeTiming();
157        container.erase(start, itr);
158        state.PauseTiming();
159        container.insert(removed.begin(), removed.end());
160      }
161      state.ResumeTiming();
162    }
163  }
164  struct EraseIfPred {
165    uint64_t i = 0;
166    template &lt;typename T&gt;
167    bool operator()(const T&amp;) {
168      return ++i % 2;
169    }
170  };
171  template &lt;typename T&gt;
172  void BM_EraseIf(benchmark::State&amp; state) {
173    using V = typename remove_pair_const&lt;typename T::value_type&gt;::type;
174    std::vector&lt;V&gt; values = GenerateValues&lt;V&gt;(kBenchmarkValues);
175    const int batch_size = (kBenchmarkValues + 1) / 2;
176    EraseIfPred pred;
177    while (state.KeepRunningBatch(batch_size)) {
178      state.PauseTiming();
179      {
180        T container(values.begin(), values.end());
181        state.ResumeTiming();
182        erase_if(container, pred);
183        benchmark::DoNotOptimize(container);
184        state.PauseTiming();
185      }
186      state.ResumeTiming();
187    }
188  }
189  template &lt;typename T&gt;
190  void BM_QueueAddRem(benchmark::State&amp; state) {
191    using V = typename remove_pair_const&lt;typename T::value_type&gt;::type;
192    typename KeyOfValue&lt;typename T::key_type, V&gt;::type key_of_value;
193    ABSL_RAW_CHECK(kBenchmarkValues % 2 == 0, &quot;for performance&quot;);
194    T container;
195    const size_t half = kBenchmarkValues / 2;
196    std::vector&lt;int&gt; remove_keys(half);
197    std::vector&lt;int&gt; add_keys(half);
198    while (state.KeepRunningBatch(half * kAddRemBatchSize)) {
199      state.PauseTiming();
200      container.clear();
201      for (size_t i = 0; i &lt; half; ++i) {
202        remove_keys[i] = i;
203        add_keys[i] = i;
204      }
205      constexpr int kSeed = 5;
206      std::mt19937_64 rand(kSeed);
207      std::shuffle(remove_keys.begin(), remove_keys.end(), rand);
208      std::shuffle(add_keys.begin(), add_keys.end(), rand);
209      Generator&lt;V&gt; g(kBenchmarkValues * kAddRemBatchSize);
210      for (size_t i = 0; i &lt; half; ++i) {
211        container.insert(g(add_keys[i]));
212        container.insert(g(half + remove_keys[i]));
213      }
214      size_t offset = 0;
215      for (size_t i = 0; i &lt; kAddRemBatchSize; ++i) {
216        std::shuffle(remove_keys.begin(), remove_keys.end(), rand);
217        std::shuffle(add_keys.begin(), add_keys.end(), rand);
218        offset += half;
219        state.ResumeTiming();
220        for (size_t idx = 0; idx &lt; half; ++idx) {
221          container.erase(key_of_value(g(offset - half + remove_keys[idx])));
222          container.insert(g(offset + half + add_keys[idx]));
223        }
224        state.PauseTiming();
225      }
226      state.ResumeTiming();
227    }
228  }
229  template &lt;typename T&gt;
230  void BM_MixedAddRem(benchmark::State&amp; state) {
231    using V = typename remove_pair_const&lt;typename T::value_type&gt;::type;
232    typename KeyOfValue&lt;typename T::key_type, V&gt;::type key_of_value;
233    ABSL_RAW_CHECK(kBenchmarkValues % 2 == 0, &quot;for performance&quot;);
234    T container;
235    std::vector&lt;int&gt; remove_keys(kBenchmarkValues);
236    std::vector&lt;int&gt; add_keys(kBenchmarkValues);
237    while (state.KeepRunningBatch(kBenchmarkValues * kAddRemBatchSize)) {
238      state.PauseTiming();
239      container.clear();
240      constexpr int kSeed = 7;
241      std::mt19937_64 rand(kSeed);
242      std::vector&lt;V&gt; values = GenerateValues&lt;V&gt;(kBenchmarkValues * 2);
243      container.insert(values.begin(), values.begin() + kBenchmarkValues);
244      for (size_t i = 0; i &lt; kBenchmarkValues; ++i) {
245        remove_keys[i] = i + kBenchmarkValues;
246        add_keys[i] = i;
247      }
248      for (size_t i = 0; i &lt; kAddRemBatchSize; ++i) {
249        remove_keys.swap(add_keys);
250        std::shuffle(remove_keys.begin(), remove_keys.end(), rand);
251        std::shuffle(add_keys.begin(), add_keys.end(), rand);
252        state.ResumeTiming();
253        for (size_t idx = 0; idx &lt; kBenchmarkValues; ++idx) {
254          container.erase(key_of_value(values[remove_keys[idx]]));
255          container.insert(values[add_keys[idx]]);
256        }
257        state.PauseTiming();
258      }
259      state.ResumeTiming();
260    }
261  }
262  template &lt;typename T&gt;
263  void BM_Fifo(benchmark::State&amp; state) {
264    using V = typename remove_pair_const&lt;typename T::value_type&gt;::type;
265    T container;
266    Generator&lt;V&gt; g(kBenchmarkValues + state.max_iterations);
267    for (int i = 0; i &lt; kBenchmarkValues; i++) {
268      container.insert(g(i));
269    }
270    while (state.KeepRunning()) {
271      container.erase(container.begin());
272      container.insert(container.end(), g(state.iterations() + kBenchmarkValues));
273    }
274  }
275  template &lt;typename T&gt;
276  void BM_FwdIter(benchmark::State&amp; state) {
277    using V = typename remove_pair_const&lt;typename T::value_type&gt;::type;
278    using R = typename T::value_type const*;
279    std::vector&lt;V&gt; values = GenerateValues&lt;V&gt;(kBenchmarkValues);
280    T container(values.begin(), values.end());
281    auto iter = container.end();
282    R r = nullptr;
283    while (state.KeepRunning()) {
284      if (iter == container.end()) iter = container.begin();
285      r = &amp;(*iter);
286      ++iter;
287    }
288    benchmark::DoNotOptimize(r);
289  }
290  template &lt;typename T&gt;
291  void BM_RangeConstructionImpl(benchmark::State&amp; state, bool sorted) {
292    using V = typename remove_pair_const&lt;typename T::value_type&gt;::type;
293    std::vector&lt;V&gt; values = GenerateValues&lt;V&gt;(kBenchmarkValues);
294    if (sorted) {
295      std::sort(values.begin(), values.end());
296    }
297    {
298      T container(values.begin(), values.end());
299    }
300    while (state.KeepRunning()) {
301      T container(values.begin(), values.end());
302      benchmark::DoNotOptimize(container);
303    }
304  }
305  template &lt;typename T&gt;
306  void BM_InsertRangeRandom(benchmark::State&amp; state) {
307    BM_RangeConstructionImpl&lt;T&gt;(state, false);
308  }
309  template &lt;typename T&gt;
310  void BM_InsertRangeSorted(benchmark::State&amp; state) {
311    BM_RangeConstructionImpl&lt;T&gt;(state, true);
312  }
313  #define STL_ORDERED_TYPES(value)                     \
314    using stl_set_##value = std::set&lt;value&gt;;           \
315    using stl_map_##value = std::map&lt;value, intptr_t&gt;; \
316    using stl_multiset_##value = std::multiset&lt;value&gt;; \
317    using stl_multimap_##value = std::multimap&lt;value, intptr_t&gt;
318  using StdString = std::string;
319  STL_ORDERED_TYPES(int32_t);
320  STL_ORDERED_TYPES(int64_t);
321  STL_ORDERED_TYPES(StdString);
322  STL_ORDERED_TYPES(Cord);
323  STL_ORDERED_TYPES(Time);
324  #define STL_UNORDERED_TYPES(value)                                       \
325    using stl_unordered_set_##value = std::unordered_set&lt;value&gt;;           \
326    using stl_unordered_map_##value = std::unordered_map&lt;value, intptr_t&gt;; \
327    using flat_hash_set_##value = flat_hash_set&lt;value&gt;;                    \
328    using flat_hash_map_##value = flat_hash_map&lt;value, intptr_t&gt;;          \
329    using stl_unordered_multiset_##value = std::unordered_multiset&lt;value&gt;; \
330    using stl_unordered_multimap_##value =                                 \
331        std::unordered_multimap&lt;value, intptr_t&gt;
332  #define STL_UNORDERED_TYPES_CUSTOM_HASH(value, hash)                           \
333    using stl_unordered_set_##value = std::unordered_set&lt;value, hash&gt;;           \
334    using stl_unordered_map_##value = std::unordered_map&lt;value, intptr_t, hash&gt;; \
335    using flat_hash_set_##value = flat_hash_set&lt;value, hash&gt;;                    \
336    using flat_hash_map_##value = flat_hash_map&lt;value, intptr_t, hash&gt;;          \
337    using stl_unordered_multiset_##value = std::unordered_multiset&lt;value, hash&gt;; \
338    using stl_unordered_multimap_##value =                                       \
339        std::unordered_multimap&lt;value, intptr_t, hash&gt;
340  STL_UNORDERED_TYPES_CUSTOM_HASH(Cord, absl::Hash&lt;absl::Cord&gt;);
341  STL_UNORDERED_TYPES(int32_t);
342  STL_UNORDERED_TYPES(int64_t);
343  STL_UNORDERED_TYPES(StdString);
344  STL_UNORDERED_TYPES_CUSTOM_HASH(Time, absl::Hash&lt;absl::Time&gt;);
345  #define BTREE_TYPES(value)                                            \
346    using btree_256_set_##value =                                       \
347        btree_set&lt;value, std::less&lt;value&gt;, std::allocator&lt;value&gt;&gt;;      \
348    using btree_256_map_##value =                                       \
349        btree_map&lt;value, intptr_t, std::less&lt;value&gt;,                    \
350                  std::allocator&lt;std::pair&lt;const value, intptr_t&gt;&gt;&gt;;    \
351    using btree_256_multiset_##value =                                  \
352        btree_multiset&lt;value, std::less&lt;value&gt;, std::allocator&lt;value&gt;&gt;; \
353    using btree_256_multimap_##value =                                  \
354        btree_multimap&lt;value, intptr_t, std::less&lt;value&gt;,               \
355                       std::allocator&lt;std::pair&lt;const value, intptr_t&gt;&gt;&gt;
356  BTREE_TYPES(int32_t);
357  BTREE_TYPES(int64_t);
358  BTREE_TYPES(StdString);
359  BTREE_TYPES(Cord);
360  BTREE_TYPES(Time);
361  #define MY_BENCHMARK4(type, func)                                              \
362    void BM_##type##_##func(benchmark::State&amp; state) { BM_##func&lt;type&gt;(state); } \
363    BENCHMARK(BM_##type##_##func)
364  #define MY_BENCHMARK3_STL(type)           \
365    MY_BENCHMARK4(type, Insert);            \
366    MY_BENCHMARK4(type, InsertSorted);      \
367    MY_BENCHMARK4(type, InsertSmall);       \
368    MY_BENCHMARK4(type, Lookup);            \
369    MY_BENCHMARK4(type, FullLookup);        \
370    MY_BENCHMARK4(type, Erase);             \
371    MY_BENCHMARK4(type, EraseRange);        \
372    MY_BENCHMARK4(type, QueueAddRem);       \
373    MY_BENCHMARK4(type, MixedAddRem);       \
374    MY_BENCHMARK4(type, Fifo);              \
375    MY_BENCHMARK4(type, FwdIter);           \
376    MY_BENCHMARK4(type, InsertRangeRandom); \
377    MY_BENCHMARK4(type, InsertRangeSorted)
378  #define MY_BENCHMARK3(type)     \
379    MY_BENCHMARK4(type, EraseIf); \
380    MY_BENCHMARK3_STL(type)
381  #define MY_BENCHMARK2_SUPPORTS_MULTI_ONLY(type) \
382    MY_BENCHMARK3_STL(stl_##type);                \
383    MY_BENCHMARK3_STL(stl_unordered_##type);      \
384    MY_BENCHMARK3(btree_256_##type)
385  #define MY_BENCHMARK2(type)                \
386    MY_BENCHMARK2_SUPPORTS_MULTI_ONLY(type); \
387    MY_BENCHMARK3(flat_hash_##type)
388  #ifdef MULTI_TESTING
389  #define MY_BENCHMARK(type)                            \
390    MY_BENCHMARK2(set_##type);                          \
391    MY_BENCHMARK2(map_##type);                          \
392    MY_BENCHMARK2_SUPPORTS_MULTI_ONLY(multiset_##type); \
393    MY_BENCHMARK2_SUPPORTS_MULTI_ONLY(multimap_##type)
394  #else
395  #define MY_BENCHMARK(type)   \
396    MY_BENCHMARK2(set_##type); \
397    MY_BENCHMARK2(map_##type)
398  #endif
399  MY_BENCHMARK(int32_t);
400  MY_BENCHMARK(int64_t);
401  MY_BENCHMARK(StdString);
402  MY_BENCHMARK(Cord);
403  MY_BENCHMARK(Time);
404  template &lt;int Size, int Copies&gt;
405  struct BigType {
406    BigType() : BigType(0) {}
407    explicit BigType(int x) { std::iota(values.begin(), values.end(), x); }
408    void Copy(const BigType&amp; other) {
409      for (int i = 0; i &lt; Size &amp;&amp; i &lt; Copies; ++i) values[i] = other.values[i];
410      for (int i = Size, idx = 0; i &lt; Copies; ++i) {
411        int64_t tmp = other.values[idx];
412        benchmark::DoNotOptimize(tmp);
413        idx = idx + 1 == Size ? 0 : idx + 1;
414      }
415    }
416    BigType(const BigType&amp; other) { Copy(other); }
417    BigType&amp; operator=(const BigType&amp; other) {
418      Copy(other);
419      return *this;
420    }
421    bool operator&lt;(const BigType&amp; other) const {
422      return std::lexicographical_compare(
423          values.begin(), values.begin() + std::min(Size, Copies),
424          other.values.begin(), other.values.begin() + std::min(Size, Copies));
425    }
426    bool operator==(const BigType&amp; other) const {
427      return std::equal(values.begin(), values.begin() + std::min(Size, Copies),
428                        other.values.begin());
429    }
430    template &lt;typename State&gt;
431    friend State AbslHashValue(State h, const BigType&amp; b) {
432      for (int i = 0; i &lt; Size &amp;&amp; i &lt; Copies; ++i)
433        h = State::combine(std::move(h), b.values[i]);
434      return h;
435    }
436    std::array&lt;int64_t, Size&gt; values;
437  };
438  #define BIG_TYPE_BENCHMARKS(SIZE, COPIES)                                     \
439    using stl_set_size##SIZE##copies##COPIES = std::set&lt;BigType&lt;SIZE, COPIES&gt;&gt;; \
440    using stl_map_size##SIZE##copies##COPIES =                                  \
441        std::map&lt;BigType&lt;SIZE, COPIES&gt;, intptr_t&gt;;                              \
442    using stl_multiset_size##SIZE##copies##COPIES =                             \
443        std::multiset&lt;BigType&lt;SIZE, COPIES&gt;&gt;;                                   \
444    using stl_multimap_size##SIZE##copies##COPIES =                             \
445        std::multimap&lt;BigType&lt;SIZE, COPIES&gt;, intptr_t&gt;;                         \
446    using stl_unordered_set_size##SIZE##copies##COPIES =                        \
447        std::unordered_set&lt;BigType&lt;SIZE, COPIES&gt;,                               \
448                           absl::Hash&lt;BigType&lt;SIZE, COPIES&gt;&gt;&gt;;                  \
449    using stl_unordered_map_size##SIZE##copies##COPIES =                        \
450        std::unordered_map&lt;BigType&lt;SIZE, COPIES&gt;, intptr_t,                     \
451                           absl::Hash&lt;BigType&lt;SIZE, COPIES&gt;&gt;&gt;;                  \
452    using flat_hash_set_size##SIZE##copies##COPIES =                            \
453        flat_hash_set&lt;BigType&lt;SIZE, COPIES&gt;&gt;;                                   \
454    using flat_hash_map_size##SIZE##copies##COPIES =                            \
455        flat_hash_map&lt;BigType&lt;SIZE, COPIES&gt;, intptr_t&gt;;                         \
456    using stl_unordered_multiset_size##SIZE##copies##COPIES =                   \
457        std::unordered_multiset&lt;BigType&lt;SIZE, COPIES&gt;,                          \
458                                absl::Hash&lt;BigType&lt;SIZE, COPIES&gt;&gt;&gt;;             \
459    using stl_unordered_multimap_size##SIZE##copies##COPIES =                   \
460        std::unordered_multimap&lt;BigType&lt;SIZE, COPIES&gt;, intptr_t,                \
461                                absl::Hash&lt;BigType&lt;SIZE, COPIES&gt;&gt;&gt;;             \
462    using btree_256_set_size##SIZE##copies##COPIES =                            \
463        btree_set&lt;BigType&lt;SIZE, COPIES&gt;&gt;;                                       \
464    using btree_256_map_size##SIZE##copies##COPIES =                            \
465        btree_map&lt;BigType&lt;SIZE, COPIES&gt;, intptr_t&gt;;                             \
466    using btree_256_multiset_size##SIZE##copies##COPIES =                       \
467        btree_multiset&lt;BigType&lt;SIZE, COPIES&gt;&gt;;                                  \
468    using btree_256_multimap_size##SIZE##copies##COPIES =                       \
469        btree_multimap&lt;BigType&lt;SIZE, COPIES&gt;, intptr_t&gt;;                        \
470    MY_BENCHMARK(size##SIZE##copies##COPIES)
471  #ifndef NODESIZE_TESTING
472  #ifdef BIG_TYPE_TESTING
473  BIG_TYPE_BENCHMARKS(1, 4);
474  BIG_TYPE_BENCHMARKS(4, 1);
475  BIG_TYPE_BENCHMARKS(4, 4);
476  BIG_TYPE_BENCHMARKS(1, 8);
477  BIG_TYPE_BENCHMARKS(8, 1);
478  BIG_TYPE_BENCHMARKS(8, 8);
479  BIG_TYPE_BENCHMARKS(1, 16);
480  BIG_TYPE_BENCHMARKS(16, 1);
481  BIG_TYPE_BENCHMARKS(16, 16);
482  BIG_TYPE_BENCHMARKS(1, 32);
483  BIG_TYPE_BENCHMARKS(32, 1);
484  BIG_TYPE_BENCHMARKS(32, 32);
485  #else
486  BIG_TYPE_BENCHMARKS(32, 32);
487  #endif
488  #endif
489  template &lt;int Size&gt;
490  struct BigTypePtr {
491    BigTypePtr() : BigTypePtr(0) {}
492    explicit BigTypePtr(int x) {
493      ptr = absl::make_unique&lt;BigType&lt;Size, Size&gt;&gt;(x);
494    }
495    BigTypePtr(const BigTypePtr&amp; other) {
<span onclick='openModal()' class='match'>496      ptr = absl::make_unique&lt;BigType&lt;Size, Size&gt;&gt;(*other.ptr);
497    }
498    BigTypePtr(BigTypePtr&amp;&amp; other) noexcept = default;
</span>499    BigTypePtr&amp; operator=(const BigTypePtr&amp; other) {
500      ptr = absl::make_unique&lt;BigType&lt;Size, Size&gt;&gt;(*other.ptr);
501    }
502    BigTypePtr&amp; operator=(BigTypePtr&amp;&amp; other) noexcept = default;
503    bool operator&lt;(const BigTypePtr&amp; other) const { return *ptr &lt; *other.ptr; }
504    bool operator==(const BigTypePtr&amp; other) const { return *ptr == *other.ptr; }
505    std::unique_ptr&lt;BigType&lt;Size, Size&gt;&gt; ptr;
506  };
507  template &lt;int Size&gt;
508  double ContainerInfo(const btree_set&lt;BigTypePtr&lt;Size&gt;&gt;&amp; b) {
509    const double bytes_used =
510        b.bytes_used() + b.size() * sizeof(BigType&lt;Size, Size&gt;);
511    const double bytes_per_value = bytes_used / b.size();
512    BtreeContainerInfoLog(b, bytes_used, bytes_per_value);
513    return bytes_per_value;
514  }
515  template &lt;int Size&gt;
516  double ContainerInfo(const btree_map&lt;int, BigTypePtr&lt;Size&gt;&gt;&amp; b) {
517    const double bytes_used =
518        b.bytes_used() + b.size() * sizeof(BigType&lt;Size, Size&gt;);
519    const double bytes_per_value = bytes_used / b.size();
520    BtreeContainerInfoLog(b, bytes_used, bytes_per_value);
521    return bytes_per_value;
522  }
523  #define BIG_TYPE_PTR_BENCHMARKS(SIZE)                                          \
524    using stl_set_size##SIZE##copies##SIZE##ptr = std::set&lt;BigType&lt;SIZE, SIZE&gt;&gt;; \
525    using stl_map_size##SIZE##copies##SIZE##ptr =                                \
526        std::map&lt;int, BigType&lt;SIZE, SIZE&gt;&gt;;                                      \
527    using stl_unordered_set_size##SIZE##copies##SIZE##ptr =                      \
528        std::unordered_set&lt;BigType&lt;SIZE, SIZE&gt;,                                  \
529                           absl::Hash&lt;BigType&lt;SIZE, SIZE&gt;&gt;&gt;;                     \
530    using stl_unordered_map_size##SIZE##copies##SIZE##ptr =                      \
531        std::unordered_map&lt;int, BigType&lt;SIZE, SIZE&gt;&gt;;                            \
532    using flat_hash_set_size##SIZE##copies##SIZE##ptr =                          \
533        flat_hash_set&lt;BigType&lt;SIZE, SIZE&gt;&gt;;                                      \
534    using flat_hash_map_size##SIZE##copies##SIZE##ptr =                          \
535        flat_hash_map&lt;int, BigTypePtr&lt;SIZE&gt;&gt;;                                    \
536    using btree_256_set_size##SIZE##copies##SIZE##ptr =                          \
537        btree_set&lt;BigTypePtr&lt;SIZE&gt;&gt;;                                             \
538    using btree_256_map_size##SIZE##copies##SIZE##ptr =                          \
539        btree_map&lt;int, BigTypePtr&lt;SIZE&gt;&gt;;                                        \
540    MY_BENCHMARK3_STL(stl_set_size##SIZE##copies##SIZE##ptr);                    \
541    MY_BENCHMARK3_STL(stl_unordered_set_size##SIZE##copies##SIZE##ptr);          \
542    MY_BENCHMARK3(flat_hash_set_size##SIZE##copies##SIZE##ptr);                  \
543    MY_BENCHMARK3(btree_256_set_size##SIZE##copies##SIZE##ptr);                  \
544    MY_BENCHMARK3_STL(stl_map_size##SIZE##copies##SIZE##ptr);                    \
545    MY_BENCHMARK3_STL(stl_unordered_map_size##SIZE##copies##SIZE##ptr);          \
546    MY_BENCHMARK3(flat_hash_map_size##SIZE##copies##SIZE##ptr);                  \
547    MY_BENCHMARK3(btree_256_map_size##SIZE##copies##SIZE##ptr)
548  BIG_TYPE_PTR_BENCHMARKS(32);
549  void BM_BtreeSet_IteratorSubtraction(benchmark::State&amp; state) {
550    absl::InsecureBitGen bitgen;
551    std::vector&lt;int&gt; vec;
552    vec.reserve(state.range(0));
553    for (int i = 0; i &lt; state.range(0); ++i) vec.push_back(i);
554    absl::c_shuffle(vec, bitgen);
555    absl::btree_set&lt;int&gt; set;
556    for (int i : vec) set.insert(i);
557    size_t distance = absl::Uniform(bitgen, 0u, set.size());
558    while (state.KeepRunningBatch(distance)) {
559      size_t end = absl::Uniform(bitgen, distance, set.size());
560      size_t begin = end - distance;
561      benchmark::DoNotOptimize(set.find(static_cast&lt;int&gt;(end)) -
562                               set.find(static_cast&lt;int&gt;(begin)));
563      distance = absl::Uniform(bitgen, 0u, set.size());
564    }
565  }
566  BENCHMARK(BM_BtreeSet_IteratorSubtraction)-&gt;Range(1 &lt;&lt; 10, 1 &lt;&lt; 20);
567  }  
568  }  
569  ABSL_NAMESPACE_END
570  }  
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-btree_benchmark.cc</h3>
            <pre><code>1  #include &lt;stdint.h&gt;
2  #include &lt;algorithm&gt;
3  #include &lt;functional&gt;
4  #include &lt;map&gt;
5  #include &lt;numeric&gt;
6  #include &lt;random&gt;
7  #include &lt;set&gt;
8  #include &lt;string&gt;
9  #include &lt;type_traits&gt;
10  #include &lt;unordered_map&gt;
11  #include &lt;unordered_set&gt;
12  #include &lt;vector&gt;
13  #include &quot;benchmark/benchmark.h&quot;
14  #include &quot;absl/algorithm/container.h&quot;
15  #include &quot;absl/base/internal/raw_logging.h&quot;
16  #include &quot;absl/container/btree_map.h&quot;
17  #include &quot;absl/container/btree_set.h&quot;
18  #include &quot;absl/container/btree_test.h&quot;
19  #include &quot;absl/container/flat_hash_map.h&quot;
20  #include &quot;absl/container/flat_hash_set.h&quot;
21  #include &quot;absl/container/internal/hashtable_debug.h&quot;
22  #include &quot;absl/hash/hash.h&quot;
23  #include &quot;absl/log/log.h&quot;
24  #include &quot;absl/memory/memory.h&quot;
25  #include &quot;absl/random/random.h&quot;
26  #include &quot;absl/strings/cord.h&quot;
27  #include &quot;absl/strings/str_format.h&quot;
28  #include &quot;absl/time/time.h&quot;
29  namespace absl {
30  ABSL_NAMESPACE_BEGIN
31  namespace container_internal {
32  namespace {
33  constexpr size_t kBenchmarkValues = 1 &lt;&lt; 20;
34  constexpr size_t kAddRemBatchSize = 1 &lt;&lt; 2;
35  template &lt;typename V&gt;
36  std::vector&lt;V&gt; GenerateValues(int n) {
37    constexpr int kSeed = 23;
38    return GenerateValuesWithSeed&lt;V&gt;(n, 4 * n, kSeed);
39  }
40  template &lt;typename T&gt;
41  void BM_InsertImpl(benchmark::State&amp; state, bool sorted) {
42    using V = typename remove_pair_const&lt;typename T::value_type&gt;::type;
43    typename KeyOfValue&lt;typename T::key_type, V&gt;::type key_of_value;
44    std::vector&lt;V&gt; values = GenerateValues&lt;V&gt;(kBenchmarkValues);
45    if (sorted) {
46      std::sort(values.begin(), values.end());
47    }
48    T container(values.begin(), values.end());
49    const int batch_size = (kBenchmarkValues + 9) / 10;
50    while (state.KeepRunningBatch(batch_size)) {
51      state.PauseTiming();
52      const auto i = static_cast&lt;int&gt;(state.iterations());
53      for (int j = i; j &lt; i + batch_size; j++) {
54        int x = j % kBenchmarkValues;
55        container.erase(key_of_value(values[x]));
56      }
57      state.ResumeTiming();
58      for (int j = i; j &lt; i + batch_size; j++) {
59        int x = j % kBenchmarkValues;
60        container.insert(values[x]);
61      }
62    }
63  }
64  template &lt;typename T&gt;
65  void BM_Insert(benchmark::State&amp; state) {
66    BM_InsertImpl&lt;T&gt;(state, false);
67  }
68  template &lt;typename T&gt;
69  void BM_InsertSorted(benchmark::State&amp; state) {
70    BM_InsertImpl&lt;T&gt;(state, true);
71  }
72  template &lt;typename T&gt;
73  void BM_InsertSmall(benchmark::State&amp; state) {
74    using V = typename remove_pair_const&lt;typename T::value_type&gt;::type;
75    const int kSize = 8;
76    std::vector&lt;V&gt; values = GenerateValues&lt;V&gt;(kSize);
77    T container;
78    while (state.KeepRunningBatch(kSize)) {
79      for (int i = 0; i &lt; kSize; ++i) {
80        benchmark::DoNotOptimize(container.insert(values[i]));
81      }
82      state.PauseTiming();
83      container.clear();
84      state.ResumeTiming();
85    }
86  }
87  template &lt;typename T&gt;
88  void BM_LookupImpl(benchmark::State&amp; state, bool sorted) {
89    using V = typename remove_pair_const&lt;typename T::value_type&gt;::type;
90    typename KeyOfValue&lt;typename T::key_type, V&gt;::type key_of_value;
91    std::vector&lt;V&gt; values = GenerateValues&lt;V&gt;(kBenchmarkValues);
92    if (sorted) {
93      std::sort(values.begin(), values.end());
94    }
95    T container(values.begin(), values.end());
96    while (state.KeepRunning()) {
97      int idx = state.iterations() % kBenchmarkValues;
98      benchmark::DoNotOptimize(container.find(key_of_value(values[idx])));
99    }
100  }
101  template &lt;typename T&gt;
102  void BM_Lookup(benchmark::State&amp; state) {
103    BM_LookupImpl&lt;T&gt;(state, false);
104  }
105  template &lt;typename T&gt;
106  void BM_FullLookup(benchmark::State&amp; state) {
107    BM_LookupImpl&lt;T&gt;(state, true);
108  }
109  template &lt;typename T&gt;
110  void BM_Erase(benchmark::State&amp; state) {
111    using V = typename remove_pair_const&lt;typename T::value_type&gt;::type;
112    typename KeyOfValue&lt;typename T::key_type, V&gt;::type key_of_value;
113    std::vector&lt;V&gt; values = GenerateValues&lt;V&gt;(kBenchmarkValues);
114    T container(values.begin(), values.end());
115    const int batch_size = (kBenchmarkValues + 9) / 10;
116    while (state.KeepRunningBatch(batch_size)) {
117      const int i = state.iterations();
118      for (int j = i; j &lt; i + batch_size; j++) {
119        int x = j % kBenchmarkValues;
120        container.erase(key_of_value(values[x]));
121      }
122      state.PauseTiming();
123      for (int j = i; j &lt; i + batch_size; j++) {
124        int x = j % kBenchmarkValues;
125        container.insert(values[x]);
126      }
127      state.ResumeTiming();
128    }
129  }
130  template &lt;typename T&gt;
131  void BM_EraseRange(benchmark::State&amp; state) {
132    using V = typename remove_pair_const&lt;typename T::value_type&gt;::type;
133    typename KeyOfValue&lt;typename T::key_type, V&gt;::type key_of_value;
134    std::vector&lt;V&gt; values = GenerateValues&lt;V&gt;(kBenchmarkValues);
135    T container(values.begin(), values.end());
136    const int batch_size = (kBenchmarkValues + 9) / 10;
137    while (state.KeepRunningBatch(batch_size)) {
138      const int i = state.iterations();
139      const int start_index = i % kBenchmarkValues;
140      state.PauseTiming();
141      {
142        std::vector&lt;V&gt; removed;
143        removed.reserve(batch_size);
144        auto itr = container.find(key_of_value(values[start_index]));
145        auto start = itr;
146        for (int j = 0; j &lt; batch_size; j++) {
147          if (itr == container.end()) {
148            state.ResumeTiming();
149            container.erase(start, itr);
150            state.PauseTiming();
151            itr = container.begin();
152            start = itr;
153          }
154          removed.push_back(*itr++);
155        }
156        state.ResumeTiming();
157        container.erase(start, itr);
158        state.PauseTiming();
159        container.insert(removed.begin(), removed.end());
160      }
161      state.ResumeTiming();
162    }
163  }
164  struct EraseIfPred {
165    uint64_t i = 0;
166    template &lt;typename T&gt;
167    bool operator()(const T&amp;) {
168      return ++i % 2;
169    }
170  };
171  template &lt;typename T&gt;
172  void BM_EraseIf(benchmark::State&amp; state) {
173    using V = typename remove_pair_const&lt;typename T::value_type&gt;::type;
174    std::vector&lt;V&gt; values = GenerateValues&lt;V&gt;(kBenchmarkValues);
175    const int batch_size = (kBenchmarkValues + 1) / 2;
176    EraseIfPred pred;
177    while (state.KeepRunningBatch(batch_size)) {
178      state.PauseTiming();
179      {
180        T container(values.begin(), values.end());
181        state.ResumeTiming();
182        erase_if(container, pred);
183        benchmark::DoNotOptimize(container);
184        state.PauseTiming();
185      }
186      state.ResumeTiming();
187    }
188  }
189  template &lt;typename T&gt;
190  void BM_QueueAddRem(benchmark::State&amp; state) {
191    using V = typename remove_pair_const&lt;typename T::value_type&gt;::type;
192    typename KeyOfValue&lt;typename T::key_type, V&gt;::type key_of_value;
193    ABSL_RAW_CHECK(kBenchmarkValues % 2 == 0, &quot;for performance&quot;);
194    T container;
195    const size_t half = kBenchmarkValues / 2;
196    std::vector&lt;int&gt; remove_keys(half);
197    std::vector&lt;int&gt; add_keys(half);
198    while (state.KeepRunningBatch(half * kAddRemBatchSize)) {
199      state.PauseTiming();
200      container.clear();
201      for (size_t i = 0; i &lt; half; ++i) {
202        remove_keys[i] = i;
203        add_keys[i] = i;
204      }
205      constexpr int kSeed = 5;
206      std::mt19937_64 rand(kSeed);
207      std::shuffle(remove_keys.begin(), remove_keys.end(), rand);
208      std::shuffle(add_keys.begin(), add_keys.end(), rand);
209      Generator&lt;V&gt; g(kBenchmarkValues * kAddRemBatchSize);
210      for (size_t i = 0; i &lt; half; ++i) {
211        container.insert(g(add_keys[i]));
212        container.insert(g(half + remove_keys[i]));
213      }
214      size_t offset = 0;
215      for (size_t i = 0; i &lt; kAddRemBatchSize; ++i) {
216        std::shuffle(remove_keys.begin(), remove_keys.end(), rand);
217        std::shuffle(add_keys.begin(), add_keys.end(), rand);
218        offset += half;
219        state.ResumeTiming();
220        for (size_t idx = 0; idx &lt; half; ++idx) {
221          container.erase(key_of_value(g(offset - half + remove_keys[idx])));
222          container.insert(g(offset + half + add_keys[idx]));
223        }
224        state.PauseTiming();
225      }
226      state.ResumeTiming();
227    }
228  }
229  template &lt;typename T&gt;
230  void BM_MixedAddRem(benchmark::State&amp; state) {
231    using V = typename remove_pair_const&lt;typename T::value_type&gt;::type;
232    typename KeyOfValue&lt;typename T::key_type, V&gt;::type key_of_value;
233    ABSL_RAW_CHECK(kBenchmarkValues % 2 == 0, &quot;for performance&quot;);
234    T container;
235    std::vector&lt;int&gt; remove_keys(kBenchmarkValues);
236    std::vector&lt;int&gt; add_keys(kBenchmarkValues);
237    while (state.KeepRunningBatch(kBenchmarkValues * kAddRemBatchSize)) {
238      state.PauseTiming();
239      container.clear();
240      constexpr int kSeed = 7;
241      std::mt19937_64 rand(kSeed);
242      std::vector&lt;V&gt; values = GenerateValues&lt;V&gt;(kBenchmarkValues * 2);
243      container.insert(values.begin(), values.begin() + kBenchmarkValues);
244      for (size_t i = 0; i &lt; kBenchmarkValues; ++i) {
245        remove_keys[i] = i + kBenchmarkValues;
246        add_keys[i] = i;
247      }
248      for (size_t i = 0; i &lt; kAddRemBatchSize; ++i) {
249        remove_keys.swap(add_keys);
250        std::shuffle(remove_keys.begin(), remove_keys.end(), rand);
251        std::shuffle(add_keys.begin(), add_keys.end(), rand);
252        state.ResumeTiming();
253        for (size_t idx = 0; idx &lt; kBenchmarkValues; ++idx) {
254          container.erase(key_of_value(values[remove_keys[idx]]));
255          container.insert(values[add_keys[idx]]);
256        }
257        state.PauseTiming();
258      }
259      state.ResumeTiming();
260    }
261  }
262  template &lt;typename T&gt;
263  void BM_Fifo(benchmark::State&amp; state) {
264    using V = typename remove_pair_const&lt;typename T::value_type&gt;::type;
265    T container;
266    Generator&lt;V&gt; g(kBenchmarkValues + state.max_iterations);
267    for (int i = 0; i &lt; kBenchmarkValues; i++) {
268      container.insert(g(i));
269    }
270    while (state.KeepRunning()) {
271      container.erase(container.begin());
272      container.insert(container.end(), g(state.iterations() + kBenchmarkValues));
273    }
274  }
275  template &lt;typename T&gt;
276  void BM_FwdIter(benchmark::State&amp; state) {
277    using V = typename remove_pair_const&lt;typename T::value_type&gt;::type;
278    using R = typename T::value_type const*;
279    std::vector&lt;V&gt; values = GenerateValues&lt;V&gt;(kBenchmarkValues);
280    T container(values.begin(), values.end());
281    auto iter = container.end();
282    R r = nullptr;
283    while (state.KeepRunning()) {
284      if (iter == container.end()) iter = container.begin();
285      r = &amp;(*iter);
286      ++iter;
287    }
288    benchmark::DoNotOptimize(r);
289  }
290  template &lt;typename T&gt;
291  void BM_RangeConstructionImpl(benchmark::State&amp; state, bool sorted) {
292    using V = typename remove_pair_const&lt;typename T::value_type&gt;::type;
293    std::vector&lt;V&gt; values = GenerateValues&lt;V&gt;(kBenchmarkValues);
294    if (sorted) {
295      std::sort(values.begin(), values.end());
296    }
297    {
298      T container(values.begin(), values.end());
299    }
300    while (state.KeepRunning()) {
301      T container(values.begin(), values.end());
302      benchmark::DoNotOptimize(container);
303    }
304  }
305  template &lt;typename T&gt;
306  void BM_InsertRangeRandom(benchmark::State&amp; state) {
307    BM_RangeConstructionImpl&lt;T&gt;(state, false);
308  }
309  template &lt;typename T&gt;
310  void BM_InsertRangeSorted(benchmark::State&amp; state) {
311    BM_RangeConstructionImpl&lt;T&gt;(state, true);
312  }
313  #define STL_ORDERED_TYPES(value)                     \
314    using stl_set_##value = std::set&lt;value&gt;;           \
315    using stl_map_##value = std::map&lt;value, intptr_t&gt;; \
316    using stl_multiset_##value = std::multiset&lt;value&gt;; \
317    using stl_multimap_##value = std::multimap&lt;value, intptr_t&gt;
318  using StdString = std::string;
319  STL_ORDERED_TYPES(int32_t);
320  STL_ORDERED_TYPES(int64_t);
321  STL_ORDERED_TYPES(StdString);
322  STL_ORDERED_TYPES(Cord);
323  STL_ORDERED_TYPES(Time);
324  #define STL_UNORDERED_TYPES(value)                                       \
325    using stl_unordered_set_##value = std::unordered_set&lt;value&gt;;           \
326    using stl_unordered_map_##value = std::unordered_map&lt;value, intptr_t&gt;; \
327    using flat_hash_set_##value = flat_hash_set&lt;value&gt;;                    \
328    using flat_hash_map_##value = flat_hash_map&lt;value, intptr_t&gt;;          \
329    using stl_unordered_multiset_##value = std::unordered_multiset&lt;value&gt;; \
330    using stl_unordered_multimap_##value =                                 \
331        std::unordered_multimap&lt;value, intptr_t&gt;
332  #define STL_UNORDERED_TYPES_CUSTOM_HASH(value, hash)                           \
333    using stl_unordered_set_##value = std::unordered_set&lt;value, hash&gt;;           \
334    using stl_unordered_map_##value = std::unordered_map&lt;value, intptr_t, hash&gt;; \
335    using flat_hash_set_##value = flat_hash_set&lt;value, hash&gt;;                    \
336    using flat_hash_map_##value = flat_hash_map&lt;value, intptr_t, hash&gt;;          \
337    using stl_unordered_multiset_##value = std::unordered_multiset&lt;value, hash&gt;; \
338    using stl_unordered_multimap_##value =                                       \
339        std::unordered_multimap&lt;value, intptr_t, hash&gt;
340  STL_UNORDERED_TYPES_CUSTOM_HASH(Cord, absl::Hash&lt;absl::Cord&gt;);
341  STL_UNORDERED_TYPES(int32_t);
342  STL_UNORDERED_TYPES(int64_t);
343  STL_UNORDERED_TYPES(StdString);
344  STL_UNORDERED_TYPES_CUSTOM_HASH(Time, absl::Hash&lt;absl::Time&gt;);
345  #define BTREE_TYPES(value)                                            \
346    using btree_256_set_##value =                                       \
347        btree_set&lt;value, std::less&lt;value&gt;, std::allocator&lt;value&gt;&gt;;      \
348    using btree_256_map_##value =                                       \
349        btree_map&lt;value, intptr_t, std::less&lt;value&gt;,                    \
350                  std::allocator&lt;std::pair&lt;const value, intptr_t&gt;&gt;&gt;;    \
351    using btree_256_multiset_##value =                                  \
352        btree_multiset&lt;value, std::less&lt;value&gt;, std::allocator&lt;value&gt;&gt;; \
353    using btree_256_multimap_##value =                                  \
354        btree_multimap&lt;value, intptr_t, std::less&lt;value&gt;,               \
355                       std::allocator&lt;std::pair&lt;const value, intptr_t&gt;&gt;&gt;
356  BTREE_TYPES(int32_t);
357  BTREE_TYPES(int64_t);
358  BTREE_TYPES(StdString);
359  BTREE_TYPES(Cord);
360  BTREE_TYPES(Time);
361  #define MY_BENCHMARK4(type, func)                                              \
362    void BM_##type##_##func(benchmark::State&amp; state) { BM_##func&lt;type&gt;(state); } \
363    BENCHMARK(BM_##type##_##func)
364  #define MY_BENCHMARK3_STL(type)           \
365    MY_BENCHMARK4(type, Insert);            \
366    MY_BENCHMARK4(type, InsertSorted);      \
367    MY_BENCHMARK4(type, InsertSmall);       \
368    MY_BENCHMARK4(type, Lookup);            \
369    MY_BENCHMARK4(type, FullLookup);        \
370    MY_BENCHMARK4(type, Erase);             \
371    MY_BENCHMARK4(type, EraseRange);        \
372    MY_BENCHMARK4(type, QueueAddRem);       \
373    MY_BENCHMARK4(type, MixedAddRem);       \
374    MY_BENCHMARK4(type, Fifo);              \
375    MY_BENCHMARK4(type, FwdIter);           \
376    MY_BENCHMARK4(type, InsertRangeRandom); \
377    MY_BENCHMARK4(type, InsertRangeSorted)
378  #define MY_BENCHMARK3(type)     \
379    MY_BENCHMARK4(type, EraseIf); \
380    MY_BENCHMARK3_STL(type)
381  #define MY_BENCHMARK2_SUPPORTS_MULTI_ONLY(type) \
382    MY_BENCHMARK3_STL(stl_##type);                \
383    MY_BENCHMARK3_STL(stl_unordered_##type);      \
384    MY_BENCHMARK3(btree_256_##type)
385  #define MY_BENCHMARK2(type)                \
386    MY_BENCHMARK2_SUPPORTS_MULTI_ONLY(type); \
387    MY_BENCHMARK3(flat_hash_##type)
388  #ifdef MULTI_TESTING
389  #define MY_BENCHMARK(type)                            \
390    MY_BENCHMARK2(set_##type);                          \
391    MY_BENCHMARK2(map_##type);                          \
392    MY_BENCHMARK2_SUPPORTS_MULTI_ONLY(multiset_##type); \
393    MY_BENCHMARK2_SUPPORTS_MULTI_ONLY(multimap_##type)
394  #else
395  #define MY_BENCHMARK(type)   \
396    MY_BENCHMARK2(set_##type); \
397    MY_BENCHMARK2(map_##type)
398  #endif
399  MY_BENCHMARK(int32_t);
400  MY_BENCHMARK(int64_t);
401  MY_BENCHMARK(StdString);
402  MY_BENCHMARK(Cord);
403  MY_BENCHMARK(Time);
404  template &lt;int Size, int Copies&gt;
405  struct BigType {
406    BigType() : BigType(0) {}
407    explicit BigType(int x) { std::iota(values.begin(), values.end(), x); }
408    void Copy(const BigType&amp; other) {
409      for (int i = 0; i &lt; Size &amp;&amp; i &lt; Copies; ++i) values[i] = other.values[i];
410      for (int i = Size, idx = 0; i &lt; Copies; ++i) {
411        int64_t tmp = other.values[idx];
412        benchmark::DoNotOptimize(tmp);
413        idx = idx + 1 == Size ? 0 : idx + 1;
414      }
415    }
416    BigType(const BigType&amp; other) { Copy(other); }
417    BigType&amp; operator=(const BigType&amp; other) {
418      Copy(other);
419      return *this;
420    }
421    bool operator&lt;(const BigType&amp; other) const {
422      return std::lexicographical_compare(
423          values.begin(), values.begin() + std::min(Size, Copies),
424          other.values.begin(), other.values.begin() + std::min(Size, Copies));
425    }
426    bool operator==(const BigType&amp; other) const {
427      return std::equal(values.begin(), values.begin() + std::min(Size, Copies),
428                        other.values.begin());
429    }
430    template &lt;typename State&gt;
431    friend State AbslHashValue(State h, const BigType&amp; b) {
432      for (int i = 0; i &lt; Size &amp;&amp; i &lt; Copies; ++i)
433        h = State::combine(std::move(h), b.values[i]);
434      return h;
435    }
436    std::array&lt;int64_t, Size&gt; values;
437  };
438  #define BIG_TYPE_BENCHMARKS(SIZE, COPIES)                                     \
439    using stl_set_size##SIZE##copies##COPIES = std::set&lt;BigType&lt;SIZE, COPIES&gt;&gt;; \
440    using stl_map_size##SIZE##copies##COPIES =                                  \
441        std::map&lt;BigType&lt;SIZE, COPIES&gt;, intptr_t&gt;;                              \
442    using stl_multiset_size##SIZE##copies##COPIES =                             \
443        std::multiset&lt;BigType&lt;SIZE, COPIES&gt;&gt;;                                   \
444    using stl_multimap_size##SIZE##copies##COPIES =                             \
445        std::multimap&lt;BigType&lt;SIZE, COPIES&gt;, intptr_t&gt;;                         \
446    using stl_unordered_set_size##SIZE##copies##COPIES =                        \
447        std::unordered_set&lt;BigType&lt;SIZE, COPIES&gt;,                               \
448                           absl::Hash&lt;BigType&lt;SIZE, COPIES&gt;&gt;&gt;;                  \
449    using stl_unordered_map_size##SIZE##copies##COPIES =                        \
450        std::unordered_map&lt;BigType&lt;SIZE, COPIES&gt;, intptr_t,                     \
451                           absl::Hash&lt;BigType&lt;SIZE, COPIES&gt;&gt;&gt;;                  \
452    using flat_hash_set_size##SIZE##copies##COPIES =                            \
453        flat_hash_set&lt;BigType&lt;SIZE, COPIES&gt;&gt;;                                   \
454    using flat_hash_map_size##SIZE##copies##COPIES =                            \
455        flat_hash_map&lt;BigType&lt;SIZE, COPIES&gt;, intptr_t&gt;;                         \
456    using stl_unordered_multiset_size##SIZE##copies##COPIES =                   \
457        std::unordered_multiset&lt;BigType&lt;SIZE, COPIES&gt;,                          \
458                                absl::Hash&lt;BigType&lt;SIZE, COPIES&gt;&gt;&gt;;             \
459    using stl_unordered_multimap_size##SIZE##copies##COPIES =                   \
460        std::unordered_multimap&lt;BigType&lt;SIZE, COPIES&gt;, intptr_t,                \
461                                absl::Hash&lt;BigType&lt;SIZE, COPIES&gt;&gt;&gt;;             \
462    using btree_256_set_size##SIZE##copies##COPIES =                            \
463        btree_set&lt;BigType&lt;SIZE, COPIES&gt;&gt;;                                       \
464    using btree_256_map_size##SIZE##copies##COPIES =                            \
465        btree_map&lt;BigType&lt;SIZE, COPIES&gt;, intptr_t&gt;;                             \
466    using btree_256_multiset_size##SIZE##copies##COPIES =                       \
467        btree_multiset&lt;BigType&lt;SIZE, COPIES&gt;&gt;;                                  \
468    using btree_256_multimap_size##SIZE##copies##COPIES =                       \
469        btree_multimap&lt;BigType&lt;SIZE, COPIES&gt;, intptr_t&gt;;                        \
470    MY_BENCHMARK(size##SIZE##copies##COPIES)
471  #ifndef NODESIZE_TESTING
472  #ifdef BIG_TYPE_TESTING
473  BIG_TYPE_BENCHMARKS(1, 4);
474  BIG_TYPE_BENCHMARKS(4, 1);
475  BIG_TYPE_BENCHMARKS(4, 4);
476  BIG_TYPE_BENCHMARKS(1, 8);
477  BIG_TYPE_BENCHMARKS(8, 1);
478  BIG_TYPE_BENCHMARKS(8, 8);
479  BIG_TYPE_BENCHMARKS(1, 16);
480  BIG_TYPE_BENCHMARKS(16, 1);
481  BIG_TYPE_BENCHMARKS(16, 16);
482  BIG_TYPE_BENCHMARKS(1, 32);
483  BIG_TYPE_BENCHMARKS(32, 1);
484  BIG_TYPE_BENCHMARKS(32, 32);
485  #else
486  BIG_TYPE_BENCHMARKS(32, 32);
487  #endif
488  #endif
489  template &lt;int Size&gt;
490  struct BigTypePtr {
491    BigTypePtr() : BigTypePtr(0) {}
492    explicit BigTypePtr(int x) {
493      ptr = absl::make_unique&lt;BigType&lt;Size, Size&gt;&gt;(x);
494    }
495    BigTypePtr(const BigTypePtr&amp; other) {
496      ptr = absl::make_unique&lt;BigType&lt;Size, Size&gt;&gt;(*other.ptr);
497    }
498    BigTypePtr(BigTypePtr&amp;&amp; other) noexcept = default;
499    BigTypePtr&amp; operator=(const BigTypePtr&amp; other) {
<span onclick='openModal()' class='match'>500      ptr = absl::make_unique&lt;BigType&lt;Size, Size&gt;&gt;(*other.ptr);
501    }
502    BigTypePtr&amp; operator=(BigTypePtr&amp;&amp; other) noexcept = default;
</span>503    bool operator&lt;(const BigTypePtr&amp; other) const { return *ptr &lt; *other.ptr; }
504    bool operator==(const BigTypePtr&amp; other) const { return *ptr == *other.ptr; }
505    std::unique_ptr&lt;BigType&lt;Size, Size&gt;&gt; ptr;
506  };
507  template &lt;int Size&gt;
508  double ContainerInfo(const btree_set&lt;BigTypePtr&lt;Size&gt;&gt;&amp; b) {
509    const double bytes_used =
510        b.bytes_used() + b.size() * sizeof(BigType&lt;Size, Size&gt;);
511    const double bytes_per_value = bytes_used / b.size();
512    BtreeContainerInfoLog(b, bytes_used, bytes_per_value);
513    return bytes_per_value;
514  }
515  template &lt;int Size&gt;
516  double ContainerInfo(const btree_map&lt;int, BigTypePtr&lt;Size&gt;&gt;&amp; b) {
517    const double bytes_used =
518        b.bytes_used() + b.size() * sizeof(BigType&lt;Size, Size&gt;);
519    const double bytes_per_value = bytes_used / b.size();
520    BtreeContainerInfoLog(b, bytes_used, bytes_per_value);
521    return bytes_per_value;
522  }
523  #define BIG_TYPE_PTR_BENCHMARKS(SIZE)                                          \
524    using stl_set_size##SIZE##copies##SIZE##ptr = std::set&lt;BigType&lt;SIZE, SIZE&gt;&gt;; \
525    using stl_map_size##SIZE##copies##SIZE##ptr =                                \
526        std::map&lt;int, BigType&lt;SIZE, SIZE&gt;&gt;;                                      \
527    using stl_unordered_set_size##SIZE##copies##SIZE##ptr =                      \
528        std::unordered_set&lt;BigType&lt;SIZE, SIZE&gt;,                                  \
529                           absl::Hash&lt;BigType&lt;SIZE, SIZE&gt;&gt;&gt;;                     \
530    using stl_unordered_map_size##SIZE##copies##SIZE##ptr =                      \
531        std::unordered_map&lt;int, BigType&lt;SIZE, SIZE&gt;&gt;;                            \
532    using flat_hash_set_size##SIZE##copies##SIZE##ptr =                          \
533        flat_hash_set&lt;BigType&lt;SIZE, SIZE&gt;&gt;;                                      \
534    using flat_hash_map_size##SIZE##copies##SIZE##ptr =                          \
535        flat_hash_map&lt;int, BigTypePtr&lt;SIZE&gt;&gt;;                                    \
536    using btree_256_set_size##SIZE##copies##SIZE##ptr =                          \
537        btree_set&lt;BigTypePtr&lt;SIZE&gt;&gt;;                                             \
538    using btree_256_map_size##SIZE##copies##SIZE##ptr =                          \
539        btree_map&lt;int, BigTypePtr&lt;SIZE&gt;&gt;;                                        \
540    MY_BENCHMARK3_STL(stl_set_size##SIZE##copies##SIZE##ptr);                    \
541    MY_BENCHMARK3_STL(stl_unordered_set_size##SIZE##copies##SIZE##ptr);          \
542    MY_BENCHMARK3(flat_hash_set_size##SIZE##copies##SIZE##ptr);                  \
543    MY_BENCHMARK3(btree_256_set_size##SIZE##copies##SIZE##ptr);                  \
544    MY_BENCHMARK3_STL(stl_map_size##SIZE##copies##SIZE##ptr);                    \
545    MY_BENCHMARK3_STL(stl_unordered_map_size##SIZE##copies##SIZE##ptr);          \
546    MY_BENCHMARK3(flat_hash_map_size##SIZE##copies##SIZE##ptr);                  \
547    MY_BENCHMARK3(btree_256_map_size##SIZE##copies##SIZE##ptr)
548  BIG_TYPE_PTR_BENCHMARKS(32);
549  void BM_BtreeSet_IteratorSubtraction(benchmark::State&amp; state) {
550    absl::InsecureBitGen bitgen;
551    std::vector&lt;int&gt; vec;
552    vec.reserve(state.range(0));
553    for (int i = 0; i &lt; state.range(0); ++i) vec.push_back(i);
554    absl::c_shuffle(vec, bitgen);
555    absl::btree_set&lt;int&gt; set;
556    for (int i : vec) set.insert(i);
557    size_t distance = absl::Uniform(bitgen, 0u, set.size());
558    while (state.KeepRunningBatch(distance)) {
559      size_t end = absl::Uniform(bitgen, distance, set.size());
560      size_t begin = end - distance;
561      benchmark::DoNotOptimize(set.find(static_cast&lt;int&gt;(end)) -
562                               set.find(static_cast&lt;int&gt;(begin)));
563      distance = absl::Uniform(bitgen, 0u, set.size());
564    }
565  }
566  BENCHMARK(BM_BtreeSet_IteratorSubtraction)-&gt;Range(1 &lt;&lt; 10, 1 &lt;&lt; 20);
567  }  
568  }  
569  ABSL_NAMESPACE_END
570  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-btree_benchmark.cc</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-btree_benchmark.cc</div>
                </div>
                <div class="column column_space"><pre><code>496      ptr = absl::make_unique&lt;BigType&lt;Size, Size&gt;&gt;(*other.ptr);
497    }
498    BigTypePtr(BigTypePtr&amp;&amp; other) noexcept = default;
</pre></code></div>
                <div class="column column_space"><pre><code>500      ptr = absl::make_unique&lt;BigType&lt;Size, Size&gt;&gt;(*other.ptr);
501    }
502    BigTypePtr&amp; operator=(BigTypePtr&amp;&amp; other) noexcept = default;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    