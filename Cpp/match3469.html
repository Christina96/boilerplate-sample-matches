<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Matches for test_convolution_layer.cpp &amp; test_data_layer.cpp</title>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<style>.modal {display: none;position: fixed;z-index: 1;left: 0;top: 0;width: 100%;height: 100%;overflow: auto;background-color: rgb(0, 0, 0);background-color: rgba(0, 0, 0, 0.4);}  .modal-content {height: 250%;background-color: #fefefe;margin: 5% auto;padding: 20px;border: 1px solid #888;width: 80%;}  .close {color: #aaa;float: right;font-size: 20px;font-weight: bold;}  .close:hover, .close:focus {color: black;text-decoration: none;cursor: pointer;}  .column {float: left;width: 50%;}  .row:after {content: ;display: table;clear: both;}  #column1, #column2 {white-space: pre-wrap;}</style></head>
<body>
<div style="align-items: center; display: flex; justify-content: space-around;">
<div>
<h3 align="center">
Matches for test_convolution_layer.cpp &amp; test_data_layer.cpp
      </h3>
<h1 align="center">
        3.7%
      </h1>
<center>
<a href="#" target="_top">
          INDEX
        </a>
<span>-</span>
<a href="#" target="_top">
          HELP
        </a>
</center>
</div>
<div>
<table bgcolor="#d0d0d0" border="1" cellspacing="0">
<tr><th><th>test_convolution_layer.cpp (2.5688074%)<th>test_data_layer.cpp (6.6193852%)<th>Tokens
<tr onclick='openModal("#0000ff")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#0000ff"><font color="#0000ff">-</font><td><a href="#" name="0">(79-81)<td><a href="#" name="0">(186-188)</a><td align="center"><font color="#ff0000">15</font>
<tr onclick='openModal("#f63526")' onmouseleave='this.style.backgroundColor = "#D0D0D0"' onmouseover='this.style.backgroundColor = "yellow"' style="cursor:pointer"><td bgcolor="#f63526"><font color="#f63526">-</font><td><a href="#" name="1">(70-74)<td><a href="#" name="1">(121-126)</a><td align="center"><font color="#dd0000">13</font>
</td></td></a></td></td></tr></td></td></a></td></td></tr></th></th></th></th></tr></table>
</div>
</div>
<hr/>
<div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_convolution_layer.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #include &lt;vector&gt;
2 #include "gtest/gtest.h"
3 #include "caffe/blob.hpp"
4 #include "caffe/common.hpp"
5 #include "caffe/filler.hpp"
6 #include "caffe/layers/conv_layer.hpp"
7 #ifdef USE_CUDNN
8 #include "caffe/layers/cudnn_conv_layer.hpp"
9 #endif
10 #include "caffe/test/test_caffe_main.hpp"
11 #include "caffe/test/test_gradient_check_util.hpp"
12 namespace caffe {
13 template &lt;typename Dtype&gt;
14 void caffe_conv(const Blob&lt;Dtype&gt;* in, ConvolutionParameter* conv_param,
15     const vector&lt;shared_ptr&lt;Blob&lt;Dtype&gt; &gt; &gt;&amp; weights,
16     Blob&lt;Dtype&gt;* out) {
17   const bool has_depth = (out-&gt;num_axes() == 5);
18   if (!has_depth) { CHECK_EQ(4, out-&gt;num_axes()); }
19   int kernel_h, kernel_w;
20   if (conv_param-&gt;has_kernel_h() || conv_param-&gt;has_kernel_w()) {
21     kernel_h = conv_param-&gt;kernel_h();
22     kernel_w = conv_param-&gt;kernel_w();
23   } else {
24     kernel_h = kernel_w = conv_param-&gt;kernel_size(0);
25   }
26   int pad_h, pad_w;
27   if (conv_param-&gt;has_pad_h() || conv_param-&gt;has_pad_w()) {
28     pad_h = conv_param-&gt;pad_h();
29     pad_w = conv_param-&gt;pad_w();
30   } else {
31     pad_h = pad_w = conv_param-&gt;pad_size() ? conv_param-&gt;pad(0) : 0;
32   }
33   int stride_h, stride_w;
34   if (conv_param-&gt;has_stride_h() || conv_param-&gt;has_stride_w()) {
35     stride_h = conv_param-&gt;stride_h();
36     stride_w = conv_param-&gt;stride_w();
37   } else {
38     stride_h = stride_w = conv_param-&gt;stride_size() ? conv_param-&gt;stride(0) : 1;
39   }
40   int dilation_h, dilation_w;
41   dilation_h = dilation_w = conv_param-&gt;dilation_size() ?
42                             conv_param-&gt;dilation(0) : 1;
43   int kernel_d, pad_d, stride_d, dilation_d;
44   if (has_depth) {
45     kernel_d = kernel_h;
46     stride_d = stride_h;
47     pad_d = pad_h;
48     dilation_d = dilation_h;
49   } else {
50     kernel_d = stride_d = dilation_d = 1;
51     pad_d = 0;
52   }
53   int groups = conv_param-&gt;group();
54   int o_g = out-&gt;shape(1) / groups;
55   int k_g = in-&gt;shape(1) / groups;
56   int o_head, k_head;
57 <a name="1"></a>    vector&lt;int&gt; weight_offset(4 + has_depth);
58   vector&lt;int&gt; in_offset(4 + has_depth);
59 <font color="#f63526"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>  vector&lt;int&gt; out_offset(4 + has_depth);
60   Dtype* out_data = out-&gt;mutable_cpu_data();
61   for (int n = 0; n &lt; out-&gt;shape(0); n++) {
62     for (int g = 0; g &lt; groups; g++) {
63       o_head = o_g * g;</b></font>
64       k_head = k_g * g;
65 <a name="0"></a>      for (int o = 0; o &lt; o_g; o++) {
66         for (int k = 0; k &lt; k_g; k++) {
67           for (int z = 0; z &lt; (has_depth ? out-&gt;shape(2) : 1); z++) {
68 <font color="#0000ff"><a href="#"><img align="right" alt="other" border="0" src="forward.gif"/></a><b>            for (int y = 0; y &lt; out-&gt;shape(2 + has_depth); y++) {
69               for (int x = 0; x &lt; out-&gt;shape(3 + has_depth); x++) {
70                 for (int r = 0; r &lt; kernel_d; r++) {</b></font>
71                   for (int p = 0; p &lt; kernel_h; p++) {
72                     for (int q = 0; q &lt; kernel_w; q++) {
73                       int in_z = z * stride_d - pad_d + r * dilation_d;
74                       int in_y = y * stride_h - pad_h + p * dilation_h;
75                       int in_x = x * stride_w - pad_w + q * dilation_w;
76                       if (in_z &gt;= 0 &amp;&amp; in_z &lt; (has_depth ? in-&gt;shape(2) : 1)
77                           &amp;&amp; in_y &gt;= 0 &amp;&amp; in_y &lt; in-&gt;shape(2 + has_depth)
78                           &amp;&amp; in_x &gt;= 0 &amp;&amp; in_x &lt; in-&gt;shape(3 + has_depth)) {
79                         weight_offset[0] = o + o_head;
80                         weight_offset[1] = k;
81                         if (has_depth) { weight_offset[2] = r; }
82                         weight_offset[2 + has_depth] = p;
83                         weight_offset[3 + has_depth] = q;
84                         in_offset[0] = n;
85                         in_offset[1] = k + k_head;
86                         if (has_depth) { in_offset[2] = in_z; }
87                         in_offset[2 + has_depth] = in_y;
88                         in_offset[3 + has_depth] = in_x;
89                         out_offset[0] = n;
90                         out_offset[1] = o + o_head;
91                         if (has_depth) { out_offset[2] = z; }
92                         out_offset[2 + has_depth] = y;
93                         out_offset[3 + has_depth] = x;
94                         out_data[out-&gt;offset(out_offset)] +=
95                             in-&gt;data_at(in_offset)
96                             * weights[0]-&gt;data_at(weight_offset);
97                       }
98                     }
99                   }
100                 }
101               }
102             }
103           }
104         }
105       }
106     }
107   }
108   if (conv_param-&gt;bias_term()) {
109     const Dtype* bias_data = weights[1]-&gt;cpu_data();
110     for (int n = 0; n &lt; out-&gt;shape(0); n++) {
111       for (int o = 0; o &lt; out-&gt;shape(1); o++) {
112         for (int z = 0; z &lt; (has_depth ? out-&gt;shape(2) : 1); z++) {
113           for (int y = 0; y &lt; out-&gt;shape(2 + has_depth); y++) {
114             for (int x = 0; x &lt; out-&gt;shape(3 + has_depth); x++) {
115               out_offset[0] = n;
116               out_offset[1] = o;
117               if (has_depth) { out_offset[2] = z; }
118               out_offset[2 + has_depth] = y;
119               out_offset[3 + has_depth] = x;
120               out_data[out-&gt;offset(out_offset)] += bias_data[o];
121             }
122           }
123         }
124       }
125     }
126   }
127 }
128 template void caffe_conv(const Blob&lt;float&gt;* in,
129     ConvolutionParameter* conv_param,
130     const vector&lt;shared_ptr&lt;Blob&lt;float&gt; &gt; &gt;&amp; weights,
131     Blob&lt;float&gt;* out);
132 template void caffe_conv(const Blob&lt;double&gt;* in,
133     ConvolutionParameter* conv_param,
134     const vector&lt;shared_ptr&lt;Blob&lt;double&gt; &gt; &gt;&amp; weights,
135     Blob&lt;double&gt;* out);
136 template &lt;typename TypeParam&gt;
137 class ConvolutionLayerTest : public MultiDeviceTest&lt;TypeParam&gt; {
138   typedef typename TypeParam::Dtype Dtype;
139  protected:
140   ConvolutionLayerTest()
141       : blob_bottom_(new Blob&lt;Dtype&gt;(2, 3, 6, 4)),
142         blob_bottom_2_(new Blob&lt;Dtype&gt;(2, 3, 6, 4)),
143         blob_top_(new Blob&lt;Dtype&gt;()),
144         blob_top_2_(new Blob&lt;Dtype&gt;()) {}
145   virtual void SetUp() {
146     FillerParameter filler_param;
147     filler_param.set_value(1.);
148     GaussianFiller&lt;Dtype&gt; filler(filler_param);
149     filler.Fill(this-&gt;blob_bottom_);
150     filler.Fill(this-&gt;blob_bottom_2_);
151     blob_bottom_vec_.push_back(blob_bottom_);
152     blob_top_vec_.push_back(blob_top_);
153   }
154   virtual ~ConvolutionLayerTest() {
155     delete blob_bottom_;
156     delete blob_bottom_2_;
157     delete blob_top_;
158     delete blob_top_2_;
159   }
160   virtual Blob&lt;Dtype&gt;* MakeReferenceTop(Blob&lt;Dtype&gt;* top) {
161     this-&gt;ref_blob_top_.reset(new Blob&lt;Dtype&gt;());
162     this-&gt;ref_blob_top_-&gt;ReshapeLike(*top);
163     return this-&gt;ref_blob_top_.get();
164   }
165   Blob&lt;Dtype&gt;* const blob_bottom_;
166   Blob&lt;Dtype&gt;* const blob_bottom_2_;
167   Blob&lt;Dtype&gt;* const blob_top_;
168   Blob&lt;Dtype&gt;* const blob_top_2_;
169   shared_ptr&lt;Blob&lt;Dtype&gt; &gt; ref_blob_top_;
170   vector&lt;Blob&lt;Dtype&gt;*&gt; blob_bottom_vec_;
171   vector&lt;Blob&lt;Dtype&gt;*&gt; blob_top_vec_;
172 };
173 TYPED_TEST_CASE(ConvolutionLayerTest, TestDtypesAndDevices);
174 TYPED_TEST(ConvolutionLayerTest, TestSetup) {
175   typedef typename TypeParam::Dtype Dtype;
176   LayerParameter layer_param;
177   ConvolutionParameter* convolution_param =
178       layer_param.mutable_convolution_param();
179   convolution_param-&gt;add_kernel_size(3);
180   convolution_param-&gt;add_stride(2);
181   convolution_param-&gt;set_num_output(4);
182   this-&gt;blob_bottom_vec_.push_back(this-&gt;blob_bottom_2_);
183   this-&gt;blob_top_vec_.push_back(this-&gt;blob_top_2_);
184   shared_ptr&lt;Layer&lt;Dtype&gt; &gt; layer(
185       new ConvolutionLayer&lt;Dtype&gt;(layer_param));
186   layer-&gt;SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
187   EXPECT_EQ(this-&gt;blob_top_-&gt;num(), 2);
188   EXPECT_EQ(this-&gt;blob_top_-&gt;channels(), 4);
189   EXPECT_EQ(this-&gt;blob_top_-&gt;height(), 2);
190   EXPECT_EQ(this-&gt;blob_top_-&gt;width(), 1);
191   EXPECT_EQ(this-&gt;blob_top_2_-&gt;num(), 2);
192   EXPECT_EQ(this-&gt;blob_top_2_-&gt;channels(), 4);
193   EXPECT_EQ(this-&gt;blob_top_2_-&gt;height(), 2);
194   EXPECT_EQ(this-&gt;blob_top_2_-&gt;width(), 1);
195   convolution_param-&gt;set_num_output(3);
196   convolution_param-&gt;set_group(3);
197   layer.reset(new ConvolutionLayer&lt;Dtype&gt;(layer_param));
198   layer-&gt;SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
199   EXPECT_EQ(this-&gt;blob_top_-&gt;num(), 2);
200   EXPECT_EQ(this-&gt;blob_top_-&gt;channels(), 3);
201   EXPECT_EQ(this-&gt;blob_top_-&gt;height(), 2);
202   EXPECT_EQ(this-&gt;blob_top_-&gt;width(), 1);
203   EXPECT_EQ(this-&gt;blob_top_2_-&gt;num(), 2);
204   EXPECT_EQ(this-&gt;blob_top_2_-&gt;channels(), 3);
205   EXPECT_EQ(this-&gt;blob_top_2_-&gt;height(), 2);
206   EXPECT_EQ(this-&gt;blob_top_2_-&gt;width(), 1);
207 }
208 TYPED_TEST(ConvolutionLayerTest, TestSimpleConvolution) {
209   typedef typename TypeParam::Dtype Dtype;
210   this-&gt;blob_bottom_vec_.push_back(this-&gt;blob_bottom_2_);
211   this-&gt;blob_top_vec_.push_back(this-&gt;blob_top_2_);
212   LayerParameter layer_param;
213   ConvolutionParameter* convolution_param =
214       layer_param.mutable_convolution_param();
215   convolution_param-&gt;add_kernel_size(3);
216   convolution_param-&gt;add_stride(2);
217   convolution_param-&gt;set_num_output(4);
218   convolution_param-&gt;mutable_weight_filler()-&gt;set_type("gaussian");
219   convolution_param-&gt;mutable_bias_filler()-&gt;set_type("constant");
220   convolution_param-&gt;mutable_bias_filler()-&gt;set_value(0.1);
221   shared_ptr&lt;Layer&lt;Dtype&gt; &gt; layer(
222       new ConvolutionLayer&lt;Dtype&gt;(layer_param));
223   layer-&gt;SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
224   layer-&gt;Forward(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
225   const Dtype* top_data;
226   const Dtype* ref_top_data;
227   caffe_conv(this-&gt;blob_bottom_, convolution_param, layer-&gt;blobs(),
228       this-&gt;MakeReferenceTop(this-&gt;blob_top_));
229   top_data = this-&gt;blob_top_-&gt;cpu_data();
230   ref_top_data = this-&gt;ref_blob_top_-&gt;cpu_data();
231   for (int i = 0; i &lt; this-&gt;blob_top_-&gt;count(); ++i) {
232     EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
233   }
234   caffe_conv(this-&gt;blob_bottom_2_, convolution_param, layer-&gt;blobs(),
235       this-&gt;MakeReferenceTop(this-&gt;blob_top_2_));
236   top_data = this-&gt;blob_top_2_-&gt;cpu_data();
237   ref_top_data = this-&gt;ref_blob_top_-&gt;cpu_data();
238   for (int i = 0; i &lt; this-&gt;blob_top_-&gt;count(); ++i) {
239     EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
240   }
241 }
242 TYPED_TEST(ConvolutionLayerTest, TestDilatedConvolution) {
243   typedef typename TypeParam::Dtype Dtype;
244   vector&lt;int&gt; bottom_shape;
245   bottom_shape.push_back(2);
246   bottom_shape.push_back(3);
247   bottom_shape.push_back(8);
248   bottom_shape.push_back(7);
249   this-&gt;blob_bottom_vec_.push_back(this-&gt;blob_bottom_2_);
250   this-&gt;blob_top_vec_.push_back(this-&gt;blob_top_2_);
251   for (int i = 0; i &lt; this-&gt;blob_bottom_vec_.size(); ++i) {
252     this-&gt;blob_bottom_vec_[i]-&gt;Reshape(bottom_shape);
253   }
254   LayerParameter layer_param;
255   ConvolutionParameter* convolution_param =
256       layer_param.mutable_convolution_param();
257   convolution_param-&gt;add_kernel_size(3);
258   convolution_param-&gt;add_dilation(2);
259   convolution_param-&gt;set_num_output(4);
260   convolution_param-&gt;mutable_weight_filler()-&gt;set_type("gaussian");
261   convolution_param-&gt;mutable_bias_filler()-&gt;set_type("constant");
262   convolution_param-&gt;mutable_bias_filler()-&gt;set_value(0.1);
263   shared_ptr&lt;Layer&lt;Dtype&gt; &gt; layer(
264       new ConvolutionLayer&lt;Dtype&gt;(layer_param));
265   layer-&gt;SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
266   layer-&gt;Forward(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
267   const Dtype* top_data;
268   const Dtype* ref_top_data;
269   caffe_conv(this-&gt;blob_bottom_, convolution_param, layer-&gt;blobs(),
270              this-&gt;MakeReferenceTop(this-&gt;blob_top_));
271   top_data = this-&gt;blob_top_-&gt;cpu_data();
272   ref_top_data = this-&gt;ref_blob_top_-&gt;cpu_data();
273   for (int i = 0; i &lt; this-&gt;blob_top_-&gt;count(); ++i) {
274     EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
275   }
276   caffe_conv(this-&gt;blob_bottom_2_, convolution_param, layer-&gt;blobs(),
277              this-&gt;MakeReferenceTop(this-&gt;blob_top_2_));
278   top_data = this-&gt;blob_top_2_-&gt;cpu_data();
279   ref_top_data = this-&gt;ref_blob_top_-&gt;cpu_data();
280   for (int i = 0; i &lt; this-&gt;blob_top_-&gt;count(); ++i) {
281     EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
282   }
283 }
284 TYPED_TEST(ConvolutionLayerTest, Test0DConvolution) {
285   typedef typename TypeParam::Dtype Dtype;
286   LayerParameter layer_param;
287   ConvolutionParameter* convolution_param =
288       layer_param.mutable_convolution_param();
289   const int kNumOutput = 3;
290   convolution_param-&gt;set_num_output(kNumOutput);
291   convolution_param-&gt;set_axis(3);
292   convolution_param-&gt;mutable_weight_filler()-&gt;set_type("gaussian");
293   convolution_param-&gt;mutable_bias_filler()-&gt;set_type("gaussian");
294   shared_ptr&lt;Layer&lt;Dtype&gt; &gt; layer(
295       new ConvolutionLayer&lt;Dtype&gt;(layer_param));
296   vector&lt;int&gt; top_shape = this-&gt;blob_bottom_-&gt;shape();
297   top_shape[3] = kNumOutput;
298   layer-&gt;SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
299   EXPECT_EQ(top_shape, this-&gt;blob_top_-&gt;shape());
300   layer-&gt;Forward(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
301   vector&lt;int&gt; weight_offset(2);
302   const Blob&lt;Dtype&gt;* weight = layer-&gt;blobs()[0].get();
303   const Blob&lt;Dtype&gt;* bias = layer-&gt;blobs()[1].get();
304   const int num = this-&gt;blob_top_-&gt;count(3);
305   const int dim = this-&gt;blob_top_-&gt;shape(3);
306   const int bottom_dim = this-&gt;blob_bottom_-&gt;shape(3);
307   for (int n = 0; n &lt; num; ++n) {
308     for (int d = 0; d &lt; dim; ++d) {
309       weight_offset[0] = d;
310       Dtype value = bias-&gt;cpu_data()[d];
311       for (int bottom_d = 0; bottom_d &lt; bottom_dim; ++bottom_d) {
312         weight_offset[1] = bottom_d;
313         value += weight-&gt;data_at(weight_offset) *
314                  this-&gt;blob_bottom_-&gt;cpu_data()[n * bottom_dim + bottom_d];
315       }
316       EXPECT_NEAR(value, this-&gt;blob_top_-&gt;cpu_data()[n * dim + d], 1e-4);
317     }
318   }
319 }
320 TYPED_TEST(ConvolutionLayerTest, TestSimple3DConvolution) {
321   typedef typename TypeParam::Dtype Dtype;
322   this-&gt;blob_bottom_vec_.push_back(this-&gt;blob_bottom_2_);
323   this-&gt;blob_top_vec_.push_back(this-&gt;blob_top_2_);
324   vector&lt;int&gt; bottom_shape(5);
325   bottom_shape[0] = this-&gt;blob_bottom_vec_[0]-&gt;shape(0);
326   bottom_shape[1] = this-&gt;blob_bottom_vec_[0]-&gt;shape(1);
327   bottom_shape[2] = 5;
328   bottom_shape[3] = this-&gt;blob_bottom_vec_[0]-&gt;shape(2);
329   bottom_shape[4] = this-&gt;blob_bottom_vec_[0]-&gt;shape(3);
330   FillerParameter filler_param;
331   GaussianFiller&lt;Dtype&gt; filler(filler_param);
332   for (int i = 0; i &lt; this-&gt;blob_bottom_vec_.size(); ++i) {
333     this-&gt;blob_bottom_vec_[i]-&gt;Reshape(bottom_shape);
334     filler.Fill(this-&gt;blob_bottom_vec_[i]);
335   }
336   LayerParameter layer_param;
337   ConvolutionParameter* convolution_param =
338       layer_param.mutable_convolution_param();
339   convolution_param-&gt;add_kernel_size(3);
340   convolution_param-&gt;add_stride(2);
341   convolution_param-&gt;set_num_output(4);
342   convolution_param-&gt;mutable_weight_filler()-&gt;set_type("gaussian");
343   convolution_param-&gt;mutable_bias_filler()-&gt;set_type("gaussian");
344   shared_ptr&lt;Layer&lt;Dtype&gt; &gt; layer(
345       new ConvolutionLayer&lt;Dtype&gt;(layer_param));
346   layer-&gt;SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
347   layer-&gt;Forward(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
348   const Dtype* top_data;
349   const Dtype* ref_top_data;
350   caffe_conv(this-&gt;blob_bottom_, convolution_param, layer-&gt;blobs(),
351       this-&gt;MakeReferenceTop(this-&gt;blob_top_));
352   top_data = this-&gt;blob_top_-&gt;cpu_data();
353   ref_top_data = this-&gt;ref_blob_top_-&gt;cpu_data();
354   for (int i = 0; i &lt; this-&gt;blob_top_-&gt;count(); ++i) {
355     EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
356   }
357   caffe_conv(this-&gt;blob_bottom_2_, convolution_param, layer-&gt;blobs(),
358       this-&gt;MakeReferenceTop(this-&gt;blob_top_2_));
359   top_data = this-&gt;blob_top_2_-&gt;cpu_data();
360   ref_top_data = this-&gt;ref_blob_top_-&gt;cpu_data();
361   for (int i = 0; i &lt; this-&gt;blob_top_-&gt;count(); ++i) {
362     EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
363   }
364 }
365 TYPED_TEST(ConvolutionLayerTest, TestDilated3DConvolution) {
366   typedef typename TypeParam::Dtype Dtype;
367   this-&gt;blob_bottom_vec_.push_back(this-&gt;blob_bottom_2_);
368   this-&gt;blob_top_vec_.push_back(this-&gt;blob_top_2_);
369   vector&lt;int&gt; bottom_shape(5);
370   bottom_shape[0] = this-&gt;blob_bottom_vec_[0]-&gt;shape(0);
371   bottom_shape[1] = this-&gt;blob_bottom_vec_[0]-&gt;shape(1);
372   bottom_shape[2] = 6;
373   bottom_shape[3] = 7;
374   bottom_shape[4] = 8;
375   FillerParameter filler_param;
376   GaussianFiller&lt;Dtype&gt; filler(filler_param);
377   for (int i = 0; i &lt; this-&gt;blob_bottom_vec_.size(); ++i) {
378     this-&gt;blob_bottom_vec_[i]-&gt;Reshape(bottom_shape);
379     filler.Fill(this-&gt;blob_bottom_vec_[i]);
380   }
381   LayerParameter layer_param;
382   ConvolutionParameter* convolution_param =
383       layer_param.mutable_convolution_param();
384   convolution_param-&gt;add_kernel_size(3);
385   convolution_param-&gt;add_dilation(2);
386   convolution_param-&gt;set_num_output(4);
387   convolution_param-&gt;mutable_weight_filler()-&gt;set_type("gaussian");
388   convolution_param-&gt;mutable_bias_filler()-&gt;set_type("gaussian");
389   shared_ptr&lt;Layer&lt;Dtype&gt; &gt; layer(
390       new ConvolutionLayer&lt;Dtype&gt;(layer_param));
391   layer-&gt;SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
392   layer-&gt;Forward(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
393   const Dtype* top_data;
394   const Dtype* ref_top_data;
395   caffe_conv(this-&gt;blob_bottom_, convolution_param, layer-&gt;blobs(),
396              this-&gt;MakeReferenceTop(this-&gt;blob_top_));
397   top_data = this-&gt;blob_top_-&gt;cpu_data();
398   ref_top_data = this-&gt;ref_blob_top_-&gt;cpu_data();
399   for (int i = 0; i &lt; this-&gt;blob_top_-&gt;count(); ++i) {
400     EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
401   }
402   caffe_conv(this-&gt;blob_bottom_2_, convolution_param, layer-&gt;blobs(),
403              this-&gt;MakeReferenceTop(this-&gt;blob_top_2_));
404   top_data = this-&gt;blob_top_2_-&gt;cpu_data();
405   ref_top_data = this-&gt;ref_blob_top_-&gt;cpu_data();
406   for (int i = 0; i &lt; this-&gt;blob_top_-&gt;count(); ++i) {
407     EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
408   }
409 }
410 TYPED_TEST(ConvolutionLayerTest, Test1x1Convolution) {
411   typedef typename TypeParam::Dtype Dtype;
412   LayerParameter layer_param;
413   ConvolutionParameter* convolution_param =
414       layer_param.mutable_convolution_param();
415   convolution_param-&gt;add_kernel_size(1);
416   convolution_param-&gt;add_stride(1);
417   convolution_param-&gt;set_num_output(4);
418   convolution_param-&gt;mutable_weight_filler()-&gt;set_type("gaussian");
419   convolution_param-&gt;mutable_bias_filler()-&gt;set_type("constant");
420   convolution_param-&gt;mutable_bias_filler()-&gt;set_value(0.1);
421   shared_ptr&lt;Layer&lt;Dtype&gt; &gt; layer(
422       new ConvolutionLayer&lt;Dtype&gt;(layer_param));
423   layer-&gt;SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
424   layer-&gt;Forward(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
425   const Dtype* top_data;
426   const Dtype* ref_top_data;
427   caffe_conv(this-&gt;blob_bottom_, convolution_param, layer-&gt;blobs(),
428       this-&gt;MakeReferenceTop(this-&gt;blob_top_));
429   top_data = this-&gt;blob_top_-&gt;cpu_data();
430   ref_top_data = this-&gt;ref_blob_top_-&gt;cpu_data();
431   for (int i = 0; i &lt; this-&gt;blob_top_-&gt;count(); ++i) {
432     EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
433   }
434 }
435 TYPED_TEST(ConvolutionLayerTest, TestSimpleConvolutionGroup) {
436   typedef typename TypeParam::Dtype Dtype;
437   LayerParameter layer_param;
438   ConvolutionParameter* convolution_param =
439       layer_param.mutable_convolution_param();
440   convolution_param-&gt;add_kernel_size(3);
441   convolution_param-&gt;add_stride(2);
442   convolution_param-&gt;set_num_output(3);
443   convolution_param-&gt;set_group(3);
444   convolution_param-&gt;mutable_weight_filler()-&gt;set_type("gaussian");
445   convolution_param-&gt;mutable_bias_filler()-&gt;set_type("constant");
446   convolution_param-&gt;mutable_bias_filler()-&gt;set_value(0.1);
447   shared_ptr&lt;Layer&lt;Dtype&gt; &gt; layer(
448       new ConvolutionLayer&lt;Dtype&gt;(layer_param));
449   layer-&gt;SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
450   layer-&gt;Forward(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
451   const Dtype* top_data;
452   const Dtype* ref_top_data;
453   caffe_conv(this-&gt;blob_bottom_, convolution_param, layer-&gt;blobs(),
454       this-&gt;MakeReferenceTop(this-&gt;blob_top_));
455   top_data = this-&gt;blob_top_-&gt;cpu_data();
456   ref_top_data = this-&gt;ref_blob_top_-&gt;cpu_data();
457   for (int i = 0; i &lt; this-&gt;blob_top_-&gt;count(); ++i) {
458     EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
459   }
460 }
461 TYPED_TEST(ConvolutionLayerTest, TestSobelConvolution) {
462   typedef typename TypeParam::Dtype Dtype;
463   shared_ptr&lt;GaussianFiller&lt;Dtype&gt; &gt; filler;
464   FillerParameter filler_param;
465   filler_param.set_value(1.);
466   filler.reset(new GaussianFiller&lt;Dtype&gt;(filler_param));
467   filler-&gt;Fill(this-&gt;blob_bottom_);
468   this-&gt;blob_bottom_2_-&gt;CopyFrom(*this-&gt;blob_bottom_);
469   LayerParameter layer_param;
470   ConvolutionParameter* convolution_param =
471       layer_param.mutable_convolution_param();
472   convolution_param-&gt;add_kernel_size(3);
473   convolution_param-&gt;add_stride(2);
474   convolution_param-&gt;set_num_output(1);
475   convolution_param-&gt;set_bias_term(false);
476   shared_ptr&lt;Layer&lt;Dtype&gt; &gt; layer(
477       new ConvolutionLayer&lt;Dtype&gt;(layer_param));
478   layer-&gt;blobs().resize(1);
479   layer-&gt;blobs()[0].reset(new Blob&lt;Dtype&gt;(1, 3, 3, 3));
480   Dtype* weights = layer-&gt;blobs()[0]-&gt;mutable_cpu_data();
481   for (int c = 0; c &lt; 3; ++c) {
482     int i = c * 9;      weights[i +  0] = -1;
483     weights[i +  1] =  0;
484     weights[i +  2] =  1;
485     weights[i +  3] = -2;
486     weights[i +  4] =  0;
487     weights[i +  5] =  2;
488     weights[i +  6] = -1;
489     weights[i +  7] =  0;
490     weights[i +  8] =  1;
491   }
492   layer-&gt;SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
493   layer-&gt;Forward(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
494   vector&lt;Blob&lt;Dtype&gt;*&gt; sep_blob_bottom_vec;
495   vector&lt;Blob&lt;Dtype&gt;*&gt; sep_blob_top_vec;
496   shared_ptr&lt;Blob&lt;Dtype&gt; &gt; blob_sep(new Blob&lt;Dtype&gt;());
497   sep_blob_bottom_vec.push_back(this-&gt;blob_bottom_2_);
498   sep_blob_top_vec.push_back(this-&gt;blob_top_2_);
499   convolution_param-&gt;clear_kernel_size();
500   convolution_param-&gt;clear_stride();
501   convolution_param-&gt;set_kernel_h(3);
502   convolution_param-&gt;set_kernel_w(1);
503   convolution_param-&gt;set_stride_h(2);
504   convolution_param-&gt;set_stride_w(1);
505   convolution_param-&gt;set_num_output(1);
506   convolution_param-&gt;set_bias_term(false);
507   layer.reset(new ConvolutionLayer&lt;Dtype&gt;(layer_param));
508   layer-&gt;blobs().resize(1);
509   layer-&gt;blobs()[0].reset(new Blob&lt;Dtype&gt;(1, 3, 3, 1));
510   Dtype* weights_1 = layer-&gt;blobs()[0]-&gt;mutable_cpu_data();
511   for (int c = 0; c &lt; 3; ++c) {
512     int i = c * 3;      weights_1[i +  0] = 1;
513     weights_1[i +  1] = 2;
514     weights_1[i +  2] = 1;
515   }
516   layer-&gt;SetUp(sep_blob_bottom_vec, sep_blob_top_vec);
517   layer-&gt;Forward(sep_blob_bottom_vec, sep_blob_top_vec);
518   blob_sep-&gt;CopyFrom(*this-&gt;blob_top_2_, false, true);
519   sep_blob_bottom_vec.clear();
520   sep_blob_bottom_vec.push_back(blob_sep.get());
521   convolution_param-&gt;set_kernel_h(1);
522   convolution_param-&gt;set_kernel_w(3);
523   convolution_param-&gt;set_stride_h(1);
524   convolution_param-&gt;set_stride_w(2);
525   convolution_param-&gt;set_num_output(1);
526   convolution_param-&gt;set_bias_term(false);
527   layer.reset(new ConvolutionLayer&lt;Dtype&gt;(layer_param));
528   layer-&gt;blobs().resize(1);
529   layer-&gt;blobs()[0].reset(new Blob&lt;Dtype&gt;(1, 1, 1, 3));
530   Dtype* weights_2 = layer-&gt;blobs()[0]-&gt;mutable_cpu_data();
531   weights_2[0] = -1;
532   weights_2[1] =  0;
533   weights_2[2] =  1;
534   layer-&gt;SetUp(sep_blob_bottom_vec, sep_blob_top_vec);
535   layer-&gt;Forward(sep_blob_bottom_vec, sep_blob_top_vec);
536   const Dtype* top_data = this-&gt;blob_top_-&gt;cpu_data();
537   const Dtype* sep_top_data = this-&gt;blob_top_2_-&gt;cpu_data();
538   for (int i = 0; i &lt; this-&gt;blob_top_-&gt;count(); ++i) {
539     EXPECT_NEAR(top_data[i], sep_top_data[i], 1e-4);
540   }
541 }
542 TYPED_TEST(ConvolutionLayerTest, TestNDAgainst2D) {
543   typedef typename TypeParam::Dtype Dtype;
544   const int kernel_h = 11;
545   const int kernel_w = 13;
546   vector&lt;int&gt; bottom_shape(4);
547   bottom_shape[0] = 15;
548   bottom_shape[1] = 18;
549   bottom_shape[2] = kernel_h * 2;
550   bottom_shape[3] = kernel_w * 2;
551   FillerParameter filler_param;
552   GaussianFiller&lt;Dtype&gt; filler(filler_param);
553   for (int i = 0; i &lt; this-&gt;blob_bottom_vec_.size(); ++i) {
554     this-&gt;blob_bottom_vec_[i]-&gt;Reshape(bottom_shape);
555     filler.Fill(this-&gt;blob_bottom_vec_[i]);
556   }
557   LayerParameter layer_param;
558   ConvolutionParameter* convolution_param =
559       layer_param.mutable_convolution_param();
560   convolution_param-&gt;set_num_output(12);
561   convolution_param-&gt;set_bias_term(false);
562   convolution_param-&gt;set_group(6);
563   convolution_param-&gt;set_kernel_h(kernel_h);
564   convolution_param-&gt;set_kernel_w(kernel_w);
565   convolution_param-&gt;mutable_weight_filler()-&gt;set_type("gaussian");
566   Blob&lt;Dtype&gt; weights;
567   Blob&lt;Dtype&gt; top_diff;
568   bool copy_diff;
569   bool reshape;
570   {
571     ConvolutionLayer&lt;Dtype&gt; layer(layer_param);
572     layer.SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
573     top_diff.ReshapeLike(*this-&gt;blob_top_);
574     filler.Fill(&amp;top_diff);
575     ASSERT_EQ(1, layer.blobs().size());
576     copy_diff = false; reshape = true;
577     weights.CopyFrom(*layer.blobs()[0], copy_diff, reshape);
578   }
579   vector&lt;bool&gt; propagate_down(1, true);
580   Blob&lt;Dtype&gt; result_2d;
581   Blob&lt;Dtype&gt; backward_result_2d;
582   Blob&lt;Dtype&gt; backward_weight_result_2d;
583   {
584     caffe_set(this-&gt;blob_top_-&gt;count(), Dtype(0),
585               this-&gt;blob_top_-&gt;mutable_cpu_data());
586     caffe_set(this-&gt;blob_bottom_-&gt;count(), Dtype(0),
587               this-&gt;blob_bottom_-&gt;mutable_cpu_diff());
588     caffe_set(weights.count(), Dtype(0), weights.mutable_cpu_diff());
589     convolution_param-&gt;set_force_nd_im2col(false);
590     ConvolutionLayer&lt;Dtype&gt; layer_2d(layer_param);
591     layer_2d.SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
592     ASSERT_EQ(1, layer_2d.blobs().size());
593     copy_diff = false; reshape = false;
594     layer_2d.blobs()[0]-&gt;CopyFrom(weights, copy_diff, reshape);
595     layer_2d.Forward(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
596     copy_diff = false; reshape = true;
597     result_2d.CopyFrom(*this-&gt;blob_top_, copy_diff, reshape);
598     ASSERT_EQ(this-&gt;blob_top_-&gt;shape(), top_diff.shape());
599     caffe_copy(top_diff.count(), top_diff.cpu_data(),
600                this-&gt;blob_top_-&gt;mutable_cpu_diff());
601     layer_2d.Backward(this-&gt;blob_top_vec_, propagate_down,
602                       this-&gt;blob_bottom_vec_);
603     copy_diff = true; reshape = true;
604     backward_result_2d.CopyFrom(*this-&gt;blob_bottom_, copy_diff, reshape);
605     backward_weight_result_2d.CopyFrom(weights, copy_diff, reshape);
606   }
607   Blob&lt;Dtype&gt; result_nd;
608   Blob&lt;Dtype&gt; backward_result_nd;
609   Blob&lt;Dtype&gt; backward_weight_result_nd;
610   {
611     caffe_set(this-&gt;blob_top_-&gt;count(), Dtype(0),
612               this-&gt;blob_top_-&gt;mutable_cpu_data());
613     caffe_set(this-&gt;blob_bottom_-&gt;count(), Dtype(0),
614               this-&gt;blob_bottom_-&gt;mutable_cpu_diff());
615     caffe_set(weights.count(), Dtype(0), weights.mutable_cpu_diff());
616     convolution_param-&gt;set_force_nd_im2col(true);
617     ConvolutionLayer&lt;Dtype&gt; layer_nd(layer_param);
618     layer_nd.SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
619     ASSERT_EQ(1, layer_nd.blobs().size());
620     copy_diff = false; reshape = false;
621     layer_nd.blobs()[0]-&gt;CopyFrom(weights, copy_diff, reshape);
622     layer_nd.Forward(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
623     copy_diff = false; reshape = true;
624     result_nd.CopyFrom(*this-&gt;blob_top_, copy_diff, reshape);
625     ASSERT_EQ(this-&gt;blob_top_-&gt;shape(), top_diff.shape());
626     caffe_copy(top_diff.count(), top_diff.cpu_data(),
627                this-&gt;blob_top_-&gt;mutable_cpu_diff());
628     layer_nd.Backward(this-&gt;blob_top_vec_, propagate_down,
629                       this-&gt;blob_bottom_vec_);
630     copy_diff = true; reshape = true;
631     backward_result_nd.CopyFrom(*this-&gt;blob_bottom_, copy_diff, reshape);
632     backward_weight_result_nd.CopyFrom(weights, copy_diff, reshape);
633   }
634   ASSERT_EQ(result_nd.count(), result_2d.count());
635   for (int i = 0; i &lt; result_2d.count(); ++i)  {
636     EXPECT_EQ(result_2d.cpu_data()[i], result_nd.cpu_data()[i]);
637   }
638   ASSERT_EQ(backward_result_nd.count(), backward_result_2d.count());
639   for (int i = 0; i &lt; backward_result_2d.count(); ++i) {
640     EXPECT_FLOAT_EQ(backward_result_2d.cpu_diff()[i],
641               backward_result_nd.cpu_diff()[i]);
642   }
643   ASSERT_EQ(backward_weight_result_nd.count(),
644             backward_weight_result_2d.count());
645   for (int i = 0; i &lt; backward_weight_result_2d.count(); ++i) {
646     EXPECT_EQ(backward_weight_result_2d.cpu_diff()[i],
647               backward_weight_result_nd.cpu_diff()[i]);
648   }
649 }
650 TYPED_TEST(ConvolutionLayerTest, TestGradient) {
651   typedef typename TypeParam::Dtype Dtype;
652   LayerParameter layer_param;
653   ConvolutionParameter* convolution_param =
654       layer_param.mutable_convolution_param();
655   this-&gt;blob_bottom_vec_.push_back(this-&gt;blob_bottom_2_);
656   this-&gt;blob_top_vec_.push_back(this-&gt;blob_top_2_);
657   convolution_param-&gt;add_kernel_size(3);
658   convolution_param-&gt;add_stride(2);
659   convolution_param-&gt;set_num_output(2);
660   convolution_param-&gt;mutable_weight_filler()-&gt;set_type("gaussian");
661   convolution_param-&gt;mutable_bias_filler()-&gt;set_type("gaussian");
662   ConvolutionLayer&lt;Dtype&gt; layer(layer_param);
663   GradientChecker&lt;Dtype&gt; checker(1e-2, 1e-3);
664   checker.CheckGradientExhaustive(&amp;layer, this-&gt;blob_bottom_vec_,
665       this-&gt;blob_top_vec_);
666 }
667 TYPED_TEST(ConvolutionLayerTest, TestDilatedGradient) {
668   typedef typename TypeParam::Dtype Dtype;
669   LayerParameter layer_param;
670   ConvolutionParameter* convolution_param =
671       layer_param.mutable_convolution_param();
672   vector&lt;int&gt; bottom_shape;
673   bottom_shape.push_back(2);
674   bottom_shape.push_back(3);
675   bottom_shape.push_back(5);
676   bottom_shape.push_back(6);
677   for (int i = 0; i &lt; this-&gt;blob_bottom_vec_.size(); ++i) {
678     this-&gt;blob_bottom_vec_[i]-&gt;Reshape(bottom_shape);
679   }
680   convolution_param-&gt;add_kernel_size(3);
681   convolution_param-&gt;add_dilation(2);
682   convolution_param-&gt;set_num_output(2);
683   convolution_param-&gt;mutable_weight_filler()-&gt;set_type("gaussian");
684   convolution_param-&gt;mutable_bias_filler()-&gt;set_type("gaussian");
685   ConvolutionLayer&lt;Dtype&gt; layer(layer_param);
686   GradientChecker&lt;Dtype&gt; checker(1e-2, 1e-3);
687   checker.CheckGradientExhaustive(&amp;layer, this-&gt;blob_bottom_vec_,
688                                   this-&gt;blob_top_vec_);
689 }
690 TYPED_TEST(ConvolutionLayerTest, TestGradient3D) {
691   typedef typename TypeParam::Dtype Dtype;
692   LayerParameter layer_param;
693   ConvolutionParameter* convolution_param =
694       layer_param.mutable_convolution_param();
695   vector&lt;int&gt; bottom_shape(5);
696   bottom_shape[0] = this-&gt;blob_bottom_vec_[0]-&gt;shape(0);
697   bottom_shape[1] = this-&gt;blob_bottom_vec_[0]-&gt;shape(1);
698   bottom_shape[2] = 5;
699   bottom_shape[3] = this-&gt;blob_bottom_vec_[0]-&gt;shape(2);
700   bottom_shape[4] = this-&gt;blob_bottom_vec_[0]-&gt;shape(3);
701   FillerParameter filler_param;
702   GaussianFiller&lt;Dtype&gt; filler(filler_param);
703   for (int i = 0; i &lt; this-&gt;blob_bottom_vec_.size(); ++i) {
704     this-&gt;blob_bottom_vec_[i]-&gt;Reshape(bottom_shape);
705     filler.Fill(this-&gt;blob_bottom_vec_[i]);
706   }
707   convolution_param-&gt;add_kernel_size(3);
708   convolution_param-&gt;add_stride(2);
709   convolution_param-&gt;set_num_output(2);
710   convolution_param-&gt;mutable_weight_filler()-&gt;set_type("gaussian");
711   convolution_param-&gt;mutable_bias_filler()-&gt;set_type("gaussian");
712   ConvolutionLayer&lt;Dtype&gt; layer(layer_param);
713   GradientChecker&lt;Dtype&gt; checker(1e-2, 1e-3);
714   checker.CheckGradientExhaustive(&amp;layer, this-&gt;blob_bottom_vec_,
715       this-&gt;blob_top_vec_);
716 }
717 TYPED_TEST(ConvolutionLayerTest, Test1x1Gradient) {
718   typedef typename TypeParam::Dtype Dtype;
719   LayerParameter layer_param;
720   ConvolutionParameter* convolution_param =
721       layer_param.mutable_convolution_param();
722   this-&gt;blob_bottom_vec_.push_back(this-&gt;blob_bottom_2_);
723   this-&gt;blob_top_vec_.push_back(this-&gt;blob_top_2_);
724   convolution_param-&gt;add_kernel_size(1);
725   convolution_param-&gt;add_stride(1);
726   convolution_param-&gt;set_num_output(2);
727   convolution_param-&gt;mutable_weight_filler()-&gt;set_type("gaussian");
728   convolution_param-&gt;mutable_bias_filler()-&gt;set_type("gaussian");
729   ConvolutionLayer&lt;Dtype&gt; layer(layer_param);
730   GradientChecker&lt;Dtype&gt; checker(1e-2, 1e-3);
731   checker.CheckGradientExhaustive(&amp;layer, this-&gt;blob_bottom_vec_,
732       this-&gt;blob_top_vec_);
733 }
734 TYPED_TEST(ConvolutionLayerTest, TestGradientGroup) {
735   typedef typename TypeParam::Dtype Dtype;
736   LayerParameter layer_param;
737   ConvolutionParameter* convolution_param =
738       layer_param.mutable_convolution_param();
739   convolution_param-&gt;add_kernel_size(3);
740   convolution_param-&gt;add_stride(2);
741   convolution_param-&gt;set_num_output(3);
742   convolution_param-&gt;set_group(3);
743   convolution_param-&gt;mutable_weight_filler()-&gt;set_type("gaussian");
744   convolution_param-&gt;mutable_bias_filler()-&gt;set_type("gaussian");
745   ConvolutionLayer&lt;Dtype&gt; layer(layer_param);
746   GradientChecker&lt;Dtype&gt; checker(1e-2, 1e-3);
747   checker.CheckGradientExhaustive(&amp;layer, this-&gt;blob_bottom_vec_,
748       this-&gt;blob_top_vec_);
749 }
750 #ifdef USE_CUDNN
751 template &lt;typename Dtype&gt;
752 class CuDNNConvolutionLayerTest : public GPUDeviceTest&lt;Dtype&gt; {
753  protected:
754   CuDNNConvolutionLayerTest()
755       : blob_bottom_(new Blob&lt;Dtype&gt;(2, 3, 6, 4)),
756         blob_bottom_2_(new Blob&lt;Dtype&gt;(2, 3, 6, 4)),
757         blob_top_(new Blob&lt;Dtype&gt;()),
758         blob_top_2_(new Blob&lt;Dtype&gt;()) {}
759   virtual void SetUp() {
760     FillerParameter filler_param;
761     filler_param.set_value(1.);
762     GaussianFiller&lt;Dtype&gt; filler(filler_param);
763     filler.Fill(this-&gt;blob_bottom_);
764     filler.Fill(this-&gt;blob_bottom_2_);
765     blob_bottom_vec_.push_back(blob_bottom_);
766     blob_top_vec_.push_back(blob_top_);
767   }
768   virtual ~CuDNNConvolutionLayerTest() {
769     delete blob_bottom_;
770     delete blob_bottom_2_;
771     delete blob_top_;
772     delete blob_top_2_;
773   }
774   virtual Blob&lt;Dtype&gt;* MakeReferenceTop(Blob&lt;Dtype&gt;* top) {
775     this-&gt;ref_blob_top_.reset(new Blob&lt;Dtype&gt;());
776     this-&gt;ref_blob_top_-&gt;ReshapeLike(*top);
777     return this-&gt;ref_blob_top_.get();
778   }
779   Blob&lt;Dtype&gt;* const blob_bottom_;
780   Blob&lt;Dtype&gt;* const blob_bottom_2_;
781   Blob&lt;Dtype&gt;* const blob_top_;
782   Blob&lt;Dtype&gt;* const blob_top_2_;
783   shared_ptr&lt;Blob&lt;Dtype&gt; &gt; ref_blob_top_;
784   vector&lt;Blob&lt;Dtype&gt;*&gt; blob_bottom_vec_;
785   vector&lt;Blob&lt;Dtype&gt;*&gt; blob_top_vec_;
786 };
787 TYPED_TEST_CASE(CuDNNConvolutionLayerTest, TestDtypes);
788 TYPED_TEST(CuDNNConvolutionLayerTest, TestSetupCuDNN) {
789   this-&gt;blob_bottom_vec_.push_back(this-&gt;blob_bottom_2_);
790   this-&gt;blob_top_vec_.push_back(this-&gt;blob_top_2_);
791   LayerParameter layer_param;
792   ConvolutionParameter* convolution_param =
793       layer_param.mutable_convolution_param();
794   convolution_param-&gt;add_kernel_size(3);
795   convolution_param-&gt;add_stride(2);
796   convolution_param-&gt;set_num_output(4);
797   this-&gt;blob_bottom_vec_.push_back(this-&gt;blob_bottom_2_);
798   this-&gt;blob_top_vec_.push_back(this-&gt;blob_top_2_);
799   shared_ptr&lt;Layer&lt;TypeParam&gt; &gt; layer(
800       new CuDNNConvolutionLayer&lt;TypeParam&gt;(layer_param));
801   layer-&gt;SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
802   EXPECT_EQ(this-&gt;blob_top_-&gt;num(), 2);
803   EXPECT_EQ(this-&gt;blob_top_-&gt;channels(), 4);
804   EXPECT_EQ(this-&gt;blob_top_-&gt;height(), 2);
805   EXPECT_EQ(this-&gt;blob_top_-&gt;width(), 1);
806   EXPECT_EQ(this-&gt;blob_top_2_-&gt;num(), 2);
807   EXPECT_EQ(this-&gt;blob_top_2_-&gt;channels(), 4);
808   EXPECT_EQ(this-&gt;blob_top_2_-&gt;height(), 2);
809   EXPECT_EQ(this-&gt;blob_top_2_-&gt;width(), 1);
810   convolution_param-&gt;set_num_output(3);
811   convolution_param-&gt;set_group(3);
812   layer.reset(new CuDNNConvolutionLayer&lt;TypeParam&gt;(layer_param));
813   layer-&gt;SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
814   EXPECT_EQ(this-&gt;blob_top_-&gt;num(), 2);
815   EXPECT_EQ(this-&gt;blob_top_-&gt;channels(), 3);
816   EXPECT_EQ(this-&gt;blob_top_-&gt;height(), 2);
817   EXPECT_EQ(this-&gt;blob_top_-&gt;width(), 1);
818   EXPECT_EQ(this-&gt;blob_top_2_-&gt;num(), 2);
819   EXPECT_EQ(this-&gt;blob_top_2_-&gt;channels(), 3);
820   EXPECT_EQ(this-&gt;blob_top_2_-&gt;height(), 2);
821   EXPECT_EQ(this-&gt;blob_top_2_-&gt;width(), 1);
822 }
823 TYPED_TEST(CuDNNConvolutionLayerTest, TestSimpleConvolutionCuDNN) {
824   this-&gt;blob_bottom_vec_.push_back(this-&gt;blob_bottom_2_);
825   this-&gt;blob_top_vec_.push_back(this-&gt;blob_top_2_);
826   LayerParameter layer_param;
827   ConvolutionParameter* convolution_param =
828       layer_param.mutable_convolution_param();
829   convolution_param-&gt;add_kernel_size(3);
830   convolution_param-&gt;add_stride(2);
831   convolution_param-&gt;set_num_output(4);
832   convolution_param-&gt;mutable_weight_filler()-&gt;set_type("gaussian");
833   convolution_param-&gt;mutable_bias_filler()-&gt;set_type("constant");
834   convolution_param-&gt;mutable_bias_filler()-&gt;set_value(0.1);
835   shared_ptr&lt;Layer&lt;TypeParam&gt; &gt; layer(
836       new CuDNNConvolutionLayer&lt;TypeParam&gt;(layer_param));
837   layer-&gt;SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
838   layer-&gt;Forward(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
839   const TypeParam* top_data;
840   const TypeParam* ref_top_data;
841   caffe_conv(this-&gt;blob_bottom_, convolution_param, layer-&gt;blobs(),
842       this-&gt;MakeReferenceTop(this-&gt;blob_top_));
843   top_data = this-&gt;blob_top_-&gt;cpu_data();
844   ref_top_data = this-&gt;ref_blob_top_-&gt;cpu_data();
845   for (int i = 0; i &lt; this-&gt;blob_top_-&gt;count(); ++i) {
846     EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
847   }
848   caffe_conv(this-&gt;blob_bottom_2_, convolution_param, layer-&gt;blobs(),
849       this-&gt;MakeReferenceTop(this-&gt;blob_top_2_));
850   top_data = this-&gt;blob_top_2_-&gt;cpu_data();
851   ref_top_data = this-&gt;ref_blob_top_-&gt;cpu_data();
852   for (int i = 0; i &lt; this-&gt;blob_top_-&gt;count(); ++i) {
853     EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
854   }
855 }
856 TYPED_TEST(CuDNNConvolutionLayerTest, TestSimpleConvolutionGroupCuDNN) {
857   LayerParameter layer_param;
858   ConvolutionParameter* convolution_param =
859       layer_param.mutable_convolution_param();
860   convolution_param-&gt;add_kernel_size(3);
861   convolution_param-&gt;add_stride(2);
862   convolution_param-&gt;set_num_output(3);
863   convolution_param-&gt;set_group(3);
864   convolution_param-&gt;mutable_weight_filler()-&gt;set_type("gaussian");
865   convolution_param-&gt;mutable_bias_filler()-&gt;set_type("constant");
866   convolution_param-&gt;mutable_bias_filler()-&gt;set_value(0.1);
867   shared_ptr&lt;Layer&lt;TypeParam&gt; &gt; layer(
868       new CuDNNConvolutionLayer&lt;TypeParam&gt;(layer_param));
869   layer-&gt;SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
870   layer-&gt;Forward(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
871   const TypeParam* top_data;
872   const TypeParam* ref_top_data;
873   caffe_conv(this-&gt;blob_bottom_, convolution_param, layer-&gt;blobs(),
874       this-&gt;MakeReferenceTop(this-&gt;blob_top_));
875   top_data = this-&gt;blob_top_-&gt;cpu_data();
876   ref_top_data = this-&gt;ref_blob_top_-&gt;cpu_data();
877   for (int i = 0; i &lt; this-&gt;blob_top_-&gt;count(); ++i) {
878     EXPECT_NEAR(top_data[i], ref_top_data[i], 1e-4);
879   }
880 }
881 TYPED_TEST(CuDNNConvolutionLayerTest, TestSobelConvolutionCuDNN) {
882   shared_ptr&lt;GaussianFiller&lt;TypeParam&gt; &gt; filler;
883   FillerParameter filler_param;
884   filler_param.set_value(1.);
885   filler.reset(new GaussianFiller&lt;TypeParam&gt;(filler_param));
886   filler-&gt;Fill(this-&gt;blob_bottom_);
887   this-&gt;blob_bottom_2_-&gt;CopyFrom(*this-&gt;blob_bottom_);
888   LayerParameter layer_param;
889   ConvolutionParameter* convolution_param =
890       layer_param.mutable_convolution_param();
891   convolution_param-&gt;add_kernel_size(3);
892   convolution_param-&gt;add_stride(2);
893   convolution_param-&gt;set_num_output(1);
894   convolution_param-&gt;set_bias_term(false);
895   shared_ptr&lt;Layer&lt;TypeParam&gt; &gt; layer(
896       new CuDNNConvolutionLayer&lt;TypeParam&gt;(layer_param));
897   layer-&gt;blobs().resize(1);
898   layer-&gt;blobs()[0].reset(new Blob&lt;TypeParam&gt;(1, 3, 3, 3));
899   TypeParam* weights = layer-&gt;blobs()[0]-&gt;mutable_cpu_data();
900   for (int c = 0; c &lt; 3; ++c) {
901     int i = c * 9;      weights[i +  0] = -1;
902     weights[i +  1] =  0;
903     weights[i +  2] =  1;
904     weights[i +  3] = -2;
905     weights[i +  4] =  0;
906     weights[i +  5] =  2;
907     weights[i +  6] = -1;
908     weights[i +  7] =  0;
909     weights[i +  8] =  1;
910   }
911   layer-&gt;SetUp(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
912   layer-&gt;Forward(this-&gt;blob_bottom_vec_, this-&gt;blob_top_vec_);
913   vector&lt;Blob&lt;TypeParam&gt;*&gt; sep_blob_bottom_vec;
914   vector&lt;Blob&lt;TypeParam&gt;*&gt; sep_blob_top_vec;
915   shared_ptr&lt;Blob&lt;TypeParam&gt; &gt; blob_sep(new Blob&lt;TypeParam&gt;());
916   sep_blob_bottom_vec.push_back(this-&gt;blob_bottom_2_);
917   sep_blob_top_vec.push_back(this-&gt;blob_top_2_);
918   convolution_param-&gt;clear_kernel_size();
919   convolution_param-&gt;clear_stride();
920   convolution_param-&gt;set_kernel_h(3);
921   convolution_param-&gt;set_kernel_w(1);
922   convolution_param-&gt;set_stride_h(2);
923   convolution_param-&gt;set_stride_w(1);
924   convolution_param-&gt;set_num_output(1);
925   convolution_param-&gt;set_bias_term(false);
926   layer.reset(new CuDNNConvolutionLayer&lt;TypeParam&gt;(layer_param));
927   layer-&gt;blobs().resize(1);
928   layer-&gt;blobs()[0].reset(new Blob&lt;TypeParam&gt;(1, 3, 3, 1));
929   TypeParam* weights_1 = layer-&gt;blobs()[0]-&gt;mutable_cpu_data();
930   for (int c = 0; c &lt; 3; ++c) {
931     int i = c * 3;      weights_1[i +  0] = 1;
932     weights_1[i +  1] = 2;
933     weights_1[i +  2] = 1;
934   }
935   layer-&gt;SetUp(sep_blob_bottom_vec, sep_blob_top_vec);
936   layer-&gt;Forward(sep_blob_bottom_vec, sep_blob_top_vec);
937   blob_sep-&gt;CopyFrom(*this-&gt;blob_top_2_, false, true);
938   sep_blob_bottom_vec.clear();
939   sep_blob_bottom_vec.push_back(blob_sep.get());
940   convolution_param-&gt;set_kernel_h(1);
941   convolution_param-&gt;set_kernel_w(3);
942   convolution_param-&gt;set_stride_h(1);
943   convolution_param-&gt;set_stride_w(2);
944   convolution_param-&gt;set_num_output(1);
945   convolution_param-&gt;set_bias_term(false);
946   layer.reset(new CuDNNConvolutionLayer&lt;TypeParam&gt;(layer_param));
947   layer-&gt;blobs().resize(1);
948   layer-&gt;blobs()[0].reset(new Blob&lt;TypeParam&gt;(1, 1, 1, 3));
949   TypeParam* weights_2 = layer-&gt;blobs()[0]-&gt;mutable_cpu_data();
950   weights_2[0] = -1;
951   weights_2[1] =  0;
952   weights_2[2] =  1;
953   layer-&gt;SetUp(sep_blob_bottom_vec, sep_blob_top_vec);
954   layer-&gt;Forward(sep_blob_bottom_vec, sep_blob_top_vec);
955   const TypeParam* top_data = this-&gt;blob_top_-&gt;cpu_data();
956   const TypeParam* sep_top_data = this-&gt;blob_top_2_-&gt;cpu_data();
957   for (int i = 0; i &lt; this-&gt;blob_top_-&gt;count(); ++i) {
958     EXPECT_NEAR(top_data[i], sep_top_data[i], 1e-4);
959   }
960 }
961 TYPED_TEST(CuDNNConvolutionLayerTest, TestGradientCuDNN) {
962   LayerParameter layer_param;
963   ConvolutionParameter* convolution_param =
964       layer_param.mutable_convolution_param();
965   this-&gt;blob_bottom_vec_.push_back(this-&gt;blob_bottom_2_);
966   this-&gt;blob_top_vec_.push_back(this-&gt;blob_top_2_);
967   convolution_param-&gt;add_kernel_size(3);
968   convolution_param-&gt;add_stride(2);
969   convolution_param-&gt;set_num_output(2);
970   convolution_param-&gt;mutable_weight_filler()-&gt;set_type("gaussian");
971   convolution_param-&gt;mutable_bias_filler()-&gt;set_type("gaussian");
972   CuDNNConvolutionLayer&lt;TypeParam&gt; layer(layer_param);
973   GradientChecker&lt;TypeParam&gt; checker(1e-2, 1e-3);
974   checker.CheckGradientExhaustive(&amp;layer, this-&gt;blob_bottom_vec_,
975       this-&gt;blob_top_vec_);
976 }
977 TYPED_TEST(CuDNNConvolutionLayerTest, TestGradientGroupCuDNN) {
978   LayerParameter layer_param;
979   ConvolutionParameter* convolution_param =
980       layer_param.mutable_convolution_param();
981   convolution_param-&gt;add_kernel_size(3);
982   convolution_param-&gt;add_stride(2);
983   convolution_param-&gt;set_num_output(3);
984   convolution_param-&gt;set_group(3);
985   convolution_param-&gt;mutable_weight_filler()-&gt;set_type("gaussian");
986   convolution_param-&gt;mutable_bias_filler()-&gt;set_type("gaussian");
987   CuDNNConvolutionLayer&lt;TypeParam&gt; layer(layer_param);
988   GradientChecker&lt;TypeParam&gt; checker(1e-2, 1e-3);
989   checker.CheckGradientExhaustive(&amp;layer, this-&gt;blob_bottom_vec_,
990       this-&gt;blob_top_vec_);
991 }
992 #endif
}  </pre>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>test_data_layer.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<hr/>
<pre>
1 #ifdef USE_OPENCV
2 #include &lt;string&gt;
3 #include &lt;vector&gt;
4 #include "boost/scoped_ptr.hpp"
5 #include "gtest/gtest.h"
6 #include "caffe/blob.hpp"
7 #include "caffe/common.hpp"
8 #include "caffe/filler.hpp"
9 #include "caffe/layers/data_layer.hpp"
10 #include "caffe/proto/caffe.pb.h"
11 #include "caffe/util/db.hpp"
12 #include "caffe/util/io.hpp"
13 #include "caffe/test/test_caffe_main.hpp"
14 namespace caffe {
15 using boost::scoped_ptr;
16 template &lt;typename TypeParam&gt;
17 class DataLayerTest : public MultiDeviceTest&lt;TypeParam&gt; {
18   typedef typename TypeParam::Dtype Dtype;
19  protected:
20   DataLayerTest()
21       : backend_(DataParameter_DB_LEVELDB),
22         blob_top_data_(new Blob&lt;Dtype&gt;()),
23         blob_top_label_(new Blob&lt;Dtype&gt;()),
24         seed_(1701) {}
25   virtual void SetUp() {
26     filename_.reset(new string());
27     MakeTempDir(filename_.get());
28     *filename_ += "/db";
29     blob_top_vec_.push_back(blob_top_data_);
30     blob_top_vec_.push_back(blob_top_label_);
31   }
32   void Fill(const bool unique_pixels, DataParameter_DB backend) {
33     backend_ = backend;
34     LOG(INFO) &lt;&lt; "Using temporary dataset " &lt;&lt; *filename_;
35     scoped_ptr&lt;db::DB&gt; db(db::GetDB(backend));
36     db-&gt;Open(*filename_, db::NEW);
37     scoped_ptr&lt;db::Transaction&gt; txn(db-&gt;NewTransaction());
38     for (int i = 0; i &lt; 5; ++i) {
39       Datum datum;
40       datum.set_label(i);
41       datum.set_channels(2);
42       datum.set_height(3);
43       datum.set_width(4);
44       std::string* data = datum.mutable_data();
45       for (int j = 0; j &lt; 24; ++j) {
46         int datum = unique_pixels ? j : i;
47         data-&gt;push_back(static_cast&lt;uint8_t&gt;(datum));
48       }
49       stringstream ss;
50       ss &lt;&lt; i;
51       string out;
52       CHECK(datum.SerializeToString(&amp;out));
53       txn-&gt;Put(ss.str(), out);
54     }
55     txn-&gt;Commit();
56     db-&gt;Close();
57   }
58   void TestRead() {
59     const Dtype scale = 3;
60     LayerParameter param;
61     param.set_phase(TRAIN);
62     DataParameter* data_param = param.mutable_data_param();
63     data_param-&gt;set_batch_size(5);
64     data_param-&gt;set_source(filename_-&gt;c_str());
65     data_param-&gt;set_backend(backend_);
66     TransformationParameter* transform_param =
67         param.mutable_transform_param();
68     transform_param-&gt;set_scale(scale);
69     DataLayer&lt;Dtype&gt; layer(param);
70     layer.SetUp(blob_bottom_vec_, blob_top_vec_);
71     EXPECT_EQ(blob_top_data_-&gt;num(), 5);
72     EXPECT_EQ(blob_top_data_-&gt;channels(), 2);
73     EXPECT_EQ(blob_top_data_-&gt;height(), 3);
74     EXPECT_EQ(blob_top_data_-&gt;width(), 4);
75     EXPECT_EQ(blob_top_label_-&gt;num(), 5);
76     EXPECT_EQ(blob_top_label_-&gt;channels(), 1);
77     EXPECT_EQ(blob_top_label_-&gt;height(), 1);
78     EXPECT_EQ(blob_top_label_-&gt;width(), 1);
79     for (int iter = 0; iter &lt; 100; ++iter) {
80       layer.Forward(blob_bottom_vec_, blob_top_vec_);
81       for (int i = 0; i &lt; 5; ++i) {
82         EXPECT_EQ(i, blob_top_label_-&gt;cpu_data()[i]);
83       }
84       for (int i = 0; i &lt; 5; ++i) {
85         for (int j = 0; j &lt; 24; ++j) {
86           EXPECT_EQ(scale * i, blob_top_data_-&gt;cpu_data()[i * 24 + j])
87               &lt;&lt; "debug: iter " &lt;&lt; iter &lt;&lt; " i " &lt;&lt; i &lt;&lt; " j " &lt;&lt; j;
88         }
89       }
90     }
91   }
92   void TestSkip() {
93     LayerParameter param;
94     param.set_phase(TRAIN);
95     DataParameter* data_param = param.mutable_data_param();
96     int batch_size = 5;
97     data_param-&gt;set_batch_size(batch_size);
98     data_param-&gt;set_source(filename_-&gt;c_str());
99     data_param-&gt;set_backend(backend_);
100     Caffe::set_solver_count(8);
101     for (int dev = 0; dev &lt; Caffe::solver_count(); ++dev) {
102 <a name="1"></a>      Caffe::set_solver_rank(dev);
103       DataLayer&lt;Dtype&gt; layer(param);
104       layer.SetUp(blob_bottom_vec_, blob_top_vec_);
105 <font color="#f63526"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>      int label = dev;
106       for (int iter = 0; iter &lt; 10; ++iter) {
107         layer.Forward(blob_bottom_vec_, blob_top_vec_);
108         for (int i = 0; i &lt; batch_size; ++i) {
109           EXPECT_EQ(label % batch_size, blob_top_label_-&gt;cpu_data()[i]);
110           label += Caffe::solver_count();</b></font>
111         }
112       }
113     }
114     Caffe::set_solver_count(1);
115     Caffe::set_solver_rank(0);
116   }
117   void TestReshape(DataParameter_DB backend) {
118     const int num_inputs = 5;
119     LOG(INFO) &lt;&lt; "Using temporary dataset " &lt;&lt; *filename_;
120     scoped_ptr&lt;db::DB&gt; db(db::GetDB(backend));
121     db-&gt;Open(*filename_, db::NEW);
122     scoped_ptr&lt;db::Transaction&gt; txn(db-&gt;NewTransaction());
123     for (int i = 0; i &lt; num_inputs; ++i) {
124       Datum datum;
125       datum.set_label(i);
126       datum.set_channels(2);
127       datum.set_height(i % 2 + 1);
128       datum.set_width(i % 4 + 1);
129       std::string* data = datum.mutable_data();
130       const int data_size = datum.channels() * datum.height() * datum.width();
131       for (int j = 0; j &lt; data_size; ++j) {
132         data-&gt;push_back(static_cast&lt;uint8_t&gt;(j));
133       }
134       stringstream ss;
135       ss &lt;&lt; i;
136       string out;
137       CHECK(datum.SerializeToString(&amp;out));
138       txn-&gt;Put(ss.str(), out);
139     }
140     txn-&gt;Commit();
141     db-&gt;Close();
142     LayerParameter param;
143     param.set_phase(TEST);
144     DataParameter* data_param = param.mutable_data_param();
145     data_param-&gt;set_batch_size(1);
146     data_param-&gt;set_source(filename_-&gt;c_str());
147     data_param-&gt;set_backend(backend);
148     DataLayer&lt;Dtype&gt; layer(param);
149     layer.SetUp(blob_bottom_vec_, blob_top_vec_);
150     EXPECT_EQ(blob_top_data_-&gt;num(), 1);
151     EXPECT_EQ(blob_top_data_-&gt;channels(), 2);
152     EXPECT_EQ(blob_top_label_-&gt;num(), 1);
153     EXPECT_EQ(blob_top_label_-&gt;channels(), 1);
154     EXPECT_EQ(blob_top_label_-&gt;height(), 1);
155     EXPECT_EQ(blob_top_label_-&gt;width(), 1);
156     for (int iter = 0; iter &lt; num_inputs; ++iter) {
157       layer.Forward(blob_bottom_vec_, blob_top_vec_);
158       EXPECT_EQ(blob_top_data_-&gt;height(), iter % 2 + 1);
159       EXPECT_EQ(blob_top_data_-&gt;width(), iter % 4 + 1);
160       EXPECT_EQ(iter, blob_top_label_-&gt;cpu_data()[0]);
161 <a name="0"></a>      const int channels = blob_top_data_-&gt;channels();
162       const int height = blob_top_data_-&gt;height();
163       const int width = blob_top_data_-&gt;width();
164 <font color="#0000ff"><div style="position:absolute;left:0"><a href="#"><img align="left" alt="other" border="0" src="back.gif"/></a></div><b>      for (int c = 0; c &lt; channels; ++c) {
165         for (int h = 0; h &lt; height; ++h) {
166           for (int w = 0; w &lt; width; ++w) {</b></font>
167             const int idx = (c * height + h) * width + w;
168             EXPECT_EQ(idx, static_cast&lt;int&gt;(blob_top_data_-&gt;cpu_data()[idx]))
169                 &lt;&lt; "debug: iter " &lt;&lt; iter &lt;&lt; " c " &lt;&lt; c
170                 &lt;&lt; " h " &lt;&lt; h &lt;&lt; " w " &lt;&lt; w;
171           }
172         }
173       }
174     }
175   }
176   void TestReadCrop(Phase phase) {
177     const Dtype scale = 3;
178     LayerParameter param;
179     param.set_phase(phase);
180     Caffe::set_random_seed(1701);
181     DataParameter* data_param = param.mutable_data_param();
182     data_param-&gt;set_batch_size(5);
183     data_param-&gt;set_source(filename_-&gt;c_str());
184     data_param-&gt;set_backend(backend_);
185     TransformationParameter* transform_param =
186         param.mutable_transform_param();
187     transform_param-&gt;set_scale(scale);
188     transform_param-&gt;set_crop_size(1);
189     DataLayer&lt;Dtype&gt; layer(param);
190     layer.SetUp(blob_bottom_vec_, blob_top_vec_);
191     EXPECT_EQ(blob_top_data_-&gt;num(), 5);
192     EXPECT_EQ(blob_top_data_-&gt;channels(), 2);
193     EXPECT_EQ(blob_top_data_-&gt;height(), 1);
194     EXPECT_EQ(blob_top_data_-&gt;width(), 1);
195     EXPECT_EQ(blob_top_label_-&gt;num(), 5);
196     EXPECT_EQ(blob_top_label_-&gt;channels(), 1);
197     EXPECT_EQ(blob_top_label_-&gt;height(), 1);
198     EXPECT_EQ(blob_top_label_-&gt;width(), 1);
199     for (int iter = 0; iter &lt; 2; ++iter) {
200       layer.Forward(blob_bottom_vec_, blob_top_vec_);
201       for (int i = 0; i &lt; 5; ++i) {
202         EXPECT_EQ(i, blob_top_label_-&gt;cpu_data()[i]);
203       }
204       int num_with_center_value = 0;
205       for (int i = 0; i &lt; 5; ++i) {
206         for (int j = 0; j &lt; 2; ++j) {
207           const Dtype center_value = scale * (j ? 17 : 5);
208           num_with_center_value +=
209               (center_value == blob_top_data_-&gt;cpu_data()[i * 2 + j]);
210           if (phase == caffe::TEST) {
211             EXPECT_EQ(center_value, this-&gt;blob_top_data_-&gt;cpu_data()[i * 2 + j])
212                 &lt;&lt; "debug: iter " &lt;&lt; iter &lt;&lt; " i " &lt;&lt; i &lt;&lt; " j " &lt;&lt; j;
213           }
214         }
215       }
216       if (phase == caffe::TRAIN) {
217         EXPECT_LT(num_with_center_value, 10);
218       }
219     }
220   }
221   void TestReadCropTrainSequenceSeeded() {
222     LayerParameter param;
223     param.set_phase(TRAIN);
224     DataParameter* data_param = param.mutable_data_param();
225     data_param-&gt;set_batch_size(5);
226     data_param-&gt;set_source(filename_-&gt;c_str());
227     data_param-&gt;set_backend(backend_);
228     TransformationParameter* transform_param =
229         param.mutable_transform_param();
230     transform_param-&gt;set_crop_size(1);
231     transform_param-&gt;set_mirror(true);
232     Caffe::set_random_seed(seed_);
233     vector&lt;vector&lt;Dtype&gt; &gt; crop_sequence;
234     {
235       DataLayer&lt;Dtype&gt; layer1(param);
236       layer1.SetUp(blob_bottom_vec_, blob_top_vec_);
237       for (int iter = 0; iter &lt; 2; ++iter) {
238         layer1.Forward(blob_bottom_vec_, blob_top_vec_);
239         for (int i = 0; i &lt; 5; ++i) {
240           EXPECT_EQ(i, blob_top_label_-&gt;cpu_data()[i]);
241         }
242         vector&lt;Dtype&gt; iter_crop_sequence;
243         for (int i = 0; i &lt; 5; ++i) {
244           for (int j = 0; j &lt; 2; ++j) {
245             iter_crop_sequence.push_back(
246                 blob_top_data_-&gt;cpu_data()[i * 2 + j]);
247           }
248         }
249         crop_sequence.push_back(iter_crop_sequence);
250       }
251     }  
252     Caffe::set_random_seed(seed_);
253     DataLayer&lt;Dtype&gt; layer2(param);
254     layer2.SetUp(blob_bottom_vec_, blob_top_vec_);
255     for (int iter = 0; iter &lt; 2; ++iter) {
256       layer2.Forward(blob_bottom_vec_, blob_top_vec_);
257       for (int i = 0; i &lt; 5; ++i) {
258         EXPECT_EQ(i, blob_top_label_-&gt;cpu_data()[i]);
259       }
260       for (int i = 0; i &lt; 5; ++i) {
261         for (int j = 0; j &lt; 2; ++j) {
262           EXPECT_EQ(crop_sequence[iter][i * 2 + j],
263                     blob_top_data_-&gt;cpu_data()[i * 2 + j])
264               &lt;&lt; "debug: iter " &lt;&lt; iter &lt;&lt; " i " &lt;&lt; i &lt;&lt; " j " &lt;&lt; j;
265         }
266       }
267     }
268   }
269   void TestReadCropTrainSequenceUnseeded() {
270     LayerParameter param;
271     param.set_phase(TRAIN);
272     DataParameter* data_param = param.mutable_data_param();
273     data_param-&gt;set_batch_size(5);
274     data_param-&gt;set_source(filename_-&gt;c_str());
275     data_param-&gt;set_backend(backend_);
276     TransformationParameter* transform_param =
277         param.mutable_transform_param();
278     transform_param-&gt;set_crop_size(1);
279     transform_param-&gt;set_mirror(true);
280     Caffe::set_random_seed(seed_);
281     srand(seed_);
282     vector&lt;vector&lt;Dtype&gt; &gt; crop_sequence;
283     {
284       DataLayer&lt;Dtype&gt; layer1(param);
285       layer1.SetUp(blob_bottom_vec_, blob_top_vec_);
286       for (int iter = 0; iter &lt; 2; ++iter) {
287         layer1.Forward(blob_bottom_vec_, blob_top_vec_);
288         for (int i = 0; i &lt; 5; ++i) {
289           EXPECT_EQ(i, blob_top_label_-&gt;cpu_data()[i]);
290         }
291         vector&lt;Dtype&gt; iter_crop_sequence;
292         for (int i = 0; i &lt; 5; ++i) {
293           for (int j = 0; j &lt; 2; ++j) {
294             iter_crop_sequence.push_back(
295                 blob_top_data_-&gt;cpu_data()[i * 2 + j]);
296           }
297         }
298         crop_sequence.push_back(iter_crop_sequence);
299       }
300     }  
301     srand(seed_);
302     DataLayer&lt;Dtype&gt; layer2(param);
303     layer2.SetUp(blob_bottom_vec_, blob_top_vec_);
304     for (int iter = 0; iter &lt; 2; ++iter) {
305       layer2.Forward(blob_bottom_vec_, blob_top_vec_);
306       for (int i = 0; i &lt; 5; ++i) {
307         EXPECT_EQ(i, blob_top_label_-&gt;cpu_data()[i]);
308       }
309       int num_sequence_matches = 0;
310       for (int i = 0; i &lt; 5; ++i) {
311         for (int j = 0; j &lt; 2; ++j) {
312           num_sequence_matches += (crop_sequence[iter][i * 2 + j] ==
313                                    blob_top_data_-&gt;cpu_data()[i * 2 + j]);
314         }
315       }
316       EXPECT_LT(num_sequence_matches, 10);
317     }
318   }
319   virtual ~DataLayerTest() { delete blob_top_data_; delete blob_top_label_; }
320   DataParameter_DB backend_;
321   shared_ptr&lt;string&gt; filename_;
322   Blob&lt;Dtype&gt;* const blob_top_data_;
323   Blob&lt;Dtype&gt;* const blob_top_label_;
324   vector&lt;Blob&lt;Dtype&gt;*&gt; blob_bottom_vec_;
325   vector&lt;Blob&lt;Dtype&gt;*&gt; blob_top_vec_;
326   int seed_;
327 };
328 TYPED_TEST_CASE(DataLayerTest, TestDtypesAndDevices);
329 #ifdef USE_LEVELDB
330 TYPED_TEST(DataLayerTest, TestReadLevelDB) {
331   const bool unique_pixels = false;    this-&gt;Fill(unique_pixels, DataParameter_DB_LEVELDB);
332   this-&gt;TestRead();
333 }
334 TYPED_TEST(DataLayerTest, TestSkipLevelDB) {
335   this-&gt;Fill(false, DataParameter_DB_LEVELDB);
336   this-&gt;TestSkip();
337 }
338 TYPED_TEST(DataLayerTest, TestReshapeLevelDB) {
339   this-&gt;TestReshape(DataParameter_DB_LEVELDB);
340 }
341 TYPED_TEST(DataLayerTest, TestReadCropTrainLevelDB) {
342   const bool unique_pixels = true;    this-&gt;Fill(unique_pixels, DataParameter_DB_LEVELDB);
343   this-&gt;TestReadCrop(TRAIN);
344 }
345 TYPED_TEST(DataLayerTest, TestReadCropTrainSequenceSeededLevelDB) {
346   const bool unique_pixels = true;    this-&gt;Fill(unique_pixels, DataParameter_DB_LEVELDB);
347   this-&gt;TestReadCropTrainSequenceSeeded();
348 }
349 TYPED_TEST(DataLayerTest, TestReadCropTrainSequenceUnseededLevelDB) {
350   const bool unique_pixels = true;    this-&gt;Fill(unique_pixels, DataParameter_DB_LEVELDB);
351   this-&gt;TestReadCropTrainSequenceUnseeded();
352 }
353 TYPED_TEST(DataLayerTest, TestReadCropTestLevelDB) {
354   const bool unique_pixels = true;    this-&gt;Fill(unique_pixels, DataParameter_DB_LEVELDB);
355   this-&gt;TestReadCrop(TEST);
356 }
357 #endif  
358 #ifdef USE_LMDB
359 TYPED_TEST(DataLayerTest, TestReadLMDB) {
360   const bool unique_pixels = false;    this-&gt;Fill(unique_pixels, DataParameter_DB_LMDB);
361   this-&gt;TestRead();
362 }
363 TYPED_TEST(DataLayerTest, TestSkipLMDB) {
364   this-&gt;Fill(false, DataParameter_DB_LMDB);
365   this-&gt;TestSkip();
366 }
367 TYPED_TEST(DataLayerTest, TestReshapeLMDB) {
368   this-&gt;TestReshape(DataParameter_DB_LMDB);
369 }
370 TYPED_TEST(DataLayerTest, TestReadCropTrainLMDB) {
371   const bool unique_pixels = true;    this-&gt;Fill(unique_pixels, DataParameter_DB_LMDB);
372   this-&gt;TestReadCrop(TRAIN);
373 }
374 TYPED_TEST(DataLayerTest, TestReadCropTrainSequenceSeededLMDB) {
375   const bool unique_pixels = true;    this-&gt;Fill(unique_pixels, DataParameter_DB_LMDB);
376   this-&gt;TestReadCropTrainSequenceSeeded();
377 }
378 TYPED_TEST(DataLayerTest, TestReadCropTrainSequenceUnseededLMDB) {
379   const bool unique_pixels = true;    this-&gt;Fill(unique_pixels, DataParameter_DB_LMDB);
380   this-&gt;TestReadCropTrainSequenceUnseeded();
381 }
382 TYPED_TEST(DataLayerTest, TestReadCropTestLMDB) {
383   const bool unique_pixels = true;    this-&gt;Fill(unique_pixels, DataParameter_DB_LMDB);
384   this-&gt;TestReadCrop(TEST);
385 }
#endif  }  #endif  </pre>
</div>
</div>
<div class="modal" id="myModal" style="display:none;"><div class="modal-content"><span class="close">x</span><p></p><div class="row"><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 1</div><div class="column" style="font-weight: bold;text-decoration: underline">Fragment from File 2</div></div><div class="row"><div class="column" id="column1">Column 1</div><div class="column" id="column2">Column 2</div></div></div></div><script>var modal=document.getElementById("myModal"),span=document.getElementsByClassName("close")[0];span.onclick=function(){modal.style.display="none"};window.onclick=function(a){a.target==modal&&(modal.style.display="none")};function openModal(a){console.log("the color is "+a);let b=getCodes(a);console.log(b);var c=document.getElementById("column1");c.innerText=b[0];var d=document.getElementById("column2");d.innerText=b[1];c.style.color=a;c.style.fontWeight="bold";d.style.fontWeight="bold";d.style.color=a;var e=document.getElementById("myModal");e.style.display="block"}function getCodes(a){for(var b=document.getElementsByTagName("font"),c=[],d=0;d<b.length;d++)b[d].attributes.color.nodeValue===a&&"-"!==b[d].innerText&&c.push(b[d].innerText);return c}</script><script>const params=window.location.search;const urlParams=new URLSearchParams(params);const searchText=urlParams.get('lines');let lines=searchText.split(',');for(let line of lines){const elements=document.getElementsByTagName('td');for(let i=0;i<elements.length;i++){if(elements[i].innerText.includes(line)){elements[i].style.background='green';break;}}}</script></body>
</html>
