<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Matches for ibex_BxpOptimData.cpp & ibex_BxpLinearRelaxArgMin.cpp</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
</HEAD>
<body>
  <div style="align-items: center; display: flex; justify-content: space-around;">
    <div>
      <h3 align="center">
Matches for ibex_BxpOptimData.cpp & ibex_BxpLinearRelaxArgMin.cpp
      </h3>
      <h1 align="center">
        36.4%
      </h1>
      <center>
        <a href="index.html" target="_top">
          INDEX
        </a>
        <span>-</span>
        <a href="help-en.html" target="_top">
          HELP
        </a>
      </center>
    </div>
    <div>
<TABLE BORDER="1" CELLSPACING="0" BGCOLOR="#d0d0d0">
<TR><TH><TH>ibex_BxpOptimData.cpp (42.028984%)<TH>ibex_BxpLinearRelaxArgMin.cpp (32.22222%)<TH>Tokens
<TR><TD BGCOLOR="#0000ff"><FONT COLOR="#0000ff">-</FONT><TD><A HREF="javascript:ZweiFrames('match503-0.html#0',2,'match503-1.html#0',3)" NAME="0">(15-24)<TD><A HREF="javascript:ZweiFrames('match503-0.html#0',2,'match503-1.html#0',3)" NAME="0">(34-43)</A><TD ALIGN=center><FONT COLOR="#ff0000">15</FONT>
<TR><TD BGCOLOR="#f63526"><FONT COLOR="#f63526">-</FONT><TD><A HREF="javascript:ZweiFrames('match503-0.html#1',2,'match503-1.html#1',3)" NAME="1">(33-40)<TD><A HREF="javascript:ZweiFrames('match503-0.html#1',2,'match503-1.html#1',3)" NAME="1">(76-83)</A><TD ALIGN=center><FONT COLOR="#ee0000">14</FONT>
</TABLE>
    </div>
  </div>
  <hr>
  <div style="display: flex;">
<div style="flex-grow: 1;">
<h3>
<center>
<span>ibex_BxpOptimData.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
//============================================================================
//                                  I B E X                                   
// File        : ibex_BxpOptimData.cpp
// Author      : Jordan Ninin, Gilles Chabert
// License     : See the LICENSE file
// Created     : Oct 18, 2014
// Last Update : Jul 05, 2018
//============================================================================

#include &quot;ibex_BxpOptimData.h&quot;
#include &quot;ibex_Id.h&quot;
<A NAME="0"></A>
namespace ibex {

<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match503-1.html#0',3,'match503-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>Map&lt;long,long,false&gt;&amp; BxpOptimData::ids() {
	static Map&lt;long,long,false&gt; _ids;
	return _ids;
}

BxpOptimData::BxpOptimData(const ExtendedSystem&amp; sys) : Bxp(get_id(sys)), sys(sys), pf(), pu(0) {

}

BxpOptimData::BxpOptimData(const BxpOptimData&amp; e) : Bxp(e.id), sys(e.sys), pf(e.pf), pu(e.pu) {</B></FONT>

}

BxpOptimData::~BxpOptimData() {

<A NAME="1"></A>}

long BxpOptimData::get_id(const ExtendedSystem&amp; sys) {
<FONT color="#f63526"><A HREF="javascript:ZweiFrames('match503-1.html#1',3,'match503-top.html#1',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>	try {
		return ids()[sys.id];
	} catch(Map&lt;long,long,false&gt;::NotFound&amp;) {
		long new_id=next_id();
		ids().insert_new(sys.id, new_id);
		return new_id;
	}
}</B></FONT>

void BxpOptimData::compute_pf(const Function&amp; goal, const IntervalVector&amp; box) {
	pf=goal.eval(box);
}


void BxpOptimData::compute_pu(const ExtendedSystem&amp; sys, const IntervalVector&amp; box) {
	double pu=1;

	if (sys.active_ctrs(box).empty()) return;

	IntervalVector e=sys.active_ctrs_eval(box);

	for (int j=1; j&lt;e.size();j++) {
		double pui=1;
		if (e[j].diam()&gt;0)
			pui= -e[j].lb()/e[j].diam();
		pu=pu*pui;
	}
}

} // end namespace ibex
</PRE>
</div>
<div style="flex-grow: 1;">
<h3>
<center>
<span>ibex_BxpLinearRelaxArgMin.cpp</span>
<span> - </span>
<span></span>
</center>
</h3>
<HR>
<PRE>
//============================================================================
//                                  I B E X
// File        : ibex_BxpLinearRelaxArgMin.cpp
// Authors     : Gilles Chabert
// Copyright   : IMT Atlantique (France)
// License     : See the LICENSE file
// Created     : Jul 30, 2018
// Last Update : Aug 01, 2018
//============================================================================

#include &quot;ibex_BxpLinearRelaxArgMin.h&quot;
#include &quot;ibex_NormalizedSystem.h&quot;
#include &quot;ibex_ExtendedSystem.h&quot;

using namespace std;

namespace ibex {

namespace {

/*
 * TODO: the use of System/NormalizedSystem should
 * be simplified to avoid this kind of stuff:
 */
int get_original_nb_var(const System&amp; sys) {

	const ExtendedSystem* ext_sys = dynamic_cast&lt;const ExtendedSystem*&gt;(&amp;sys);
	if (ext_sys) return ext_sys-&gt;nb_var-1;
	else return sys.nb_var;
}
<A NAME="0"></A>
}

<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match503-0.html#0',2,'match503-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>Map&lt;long,long,false&gt;&amp; BxpLinearRelaxArgMin::ids() {
	static Map&lt;long,long,false&gt; _ids;
	return _ids;
}

BxpLinearRelaxArgMin::BxpLinearRelaxArgMin(const System&amp; sys) : Bxp(get_id(sys)), sys(sys), _argmin(get_original_nb_var(sys)), inside(false) {

}

BxpLinearRelaxArgMin* BxpLinearRelaxArgMin::copy(const IntervalVector&amp; box, const BoxProperties&amp; prop) const {</B></FONT>
	return new BxpLinearRelaxArgMin(sys);
}

void BxpLinearRelaxArgMin::update(const BoxEvent&amp; event, const BoxProperties&amp; prop) {
	if (inside) {
		int n=_argmin.size();
		// box gotten from extended system
		if (event.box.size() &gt; n) {
			assert(event.box.size()==n+1);
			IntervalVector tmpbox(n);
			((ExtendedSystem&amp;) sys).read_ext_box(event.box,tmpbox);
			if (!tmpbox.contains(_argmin))
				inside=false;
		} else {
			assert(event.box.size()==n);
			if (!event.box.contains(_argmin))
				inside=false;
		}
	}
}

string BxpLinearRelaxArgMin::to_string() const {
	stringstream ss;
	ss &lt;&lt; '[' &lt;&lt; id &lt;&lt; &quot;] BxpLinearRelaxArgmin Sys nÂ°&quot;;
	const NormalizedSystem* norm_sys = dynamic_cast&lt;const NormalizedSystem*&gt;(&amp;sys);
	ss &lt;&lt; (norm_sys? norm_sys-&gt;original_sys_id : sys.id);
	return ss.str();
}

<A NAME="1"></A>long BxpLinearRelaxArgMin::get_id(const System&amp; sys) {
	const NormalizedSystem* norm_sys = dynamic_cast&lt;const NormalizedSystem*&gt;(&amp;sys);
	long sys_id = norm_sys? norm_sys-&gt;original_sys_id : sys.id;
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match503-0.html#1',2,'match503-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>	try {
		return ids()[sys_id];
	} catch(Map&lt;long,long,false&gt;::NotFound&amp;) {
		long new_id=next_id();
		ids().insert_new(sys_id, new_id);
		return new_id;
	}
}</B></FONT>

} /* namespace ibex */
</PRE>
</div>
  </div>
</body>
</html>
