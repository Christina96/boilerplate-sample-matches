
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 17, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-EditView.cxx</h3>
            <pre><code>1  #include <cstddef>
2  #include <cstdlib>
3  #include <cstdint>
4  #include <cassert>
5  #include <cstring>
6  #include <cstdio>
7  #include <cmath>
8  #include <stdexcept>
9  #include <string>
10  #include <string_view>
11  #include <vector>
12  #include <map>
13  #include <set>
14  #include <forward_list>
15  #include <optional>
16  #include <algorithm>
17  #include <iterator>
18  #include <memory>
19  #include <chrono>
20  #include <atomic>
21  #include <thread>
22  #include <future>
23  #include "ScintillaTypes.h"
24  #include "ScintillaMessages.h"
25  #include "ScintillaStructures.h"
26  #include "ILoader.h"
27  #include "ILexer.h"
28  #include "Debugging.h"
29  #include "Geometry.h"
30  #include "Platform.h"
31  #include "CharacterType.h"
32  #include "CharacterCategoryMap.h"
33  #include "Position.h"
34  #include "UniqueString.h"
35  #include "SplitVector.h"
36  #include "Partitioning.h"
37  #include "RunStyles.h"
38  #include "ContractionState.h"
39  #include "CellBuffer.h"
40  #include "PerLine.h"
41  #include "KeyMap.h"
42  #include "Indicator.h"
43  #include "LineMarker.h"
44  #include "Style.h"
45  #include "ViewStyle.h"
46  #include "CharClassify.h"
47  #include "Decoration.h"
48  #include "CaseFolder.h"
49  #include "Document.h"
50  #include "UniConversion.h"
51  #include "Selection.h"
52  #include "PositionCache.h"
53  #include "EditModel.h"
54  #include "MarginView.h"
55  #include "EditView.h"
56  #include "ElapsedPeriod.h"
57  using namespace Scintilla;
58  using namespace Scintilla::Internal;
59  PrintParameters::PrintParameters() noexcept {
60  	magnification = 0;
61  	colourMode = PrintOption::Normal;
62  	wrapState = Wrap::Word;
63  }
64  namespace {
65  int WidthStyledText(Surface *surface, const ViewStyle &vs, int styleOffset,
66  	const char *text, const unsigned char *styles, size_t len) {
67  	int width = 0;
68  	size_t start = 0;
69  	while (start < len) {
70  		const unsigned char style = styles[start];
71  		size_t endSegment = start;
72  		while ((endSegment + 1 < len) && (styles[endSegment + 1] == style))
73  			endSegment++;
74  		const Font *fontText = vs.styles[style + styleOffset].font.get();
75  		const std::string_view sv(text + start, endSegment - start + 1);
76  		width += static_cast<int>(surface->WidthText(fontText, sv));
77  		start = endSegment + 1;
78  	}
79  	return width;
80  }
81  }
82  namespace Scintilla::Internal {
83  bool ValidStyledText(const ViewStyle &vs, size_t styleOffset, const StyledText &st) noexcept {
84  	if (st.multipleStyles) {
85  		for (size_t iStyle = 0; iStyle<st.length; iStyle++) {
86  			if (!vs.ValidStyle(styleOffset + st.styles[iStyle]))
87  				return false;
88  		}
89  	} else {
90  		if (!vs.ValidStyle(styleOffset + st.style))
91  			return false;
92  	}
93  	return true;
94  }
95  int WidestLineWidth(Surface *surface, const ViewStyle &vs, int styleOffset, const StyledText &st) {
96  	int widthMax = 0;
97  	size_t start = 0;
98  	while (start < st.length) {
99  		const size_t lenLine = st.LineLength(start);
100  		int widthSubLine;
101  		if (st.multipleStyles) {
102  			widthSubLine = WidthStyledText(surface, vs, styleOffset, st.text + start, st.styles + start, lenLine);
103  		} else {
104  			const Font *fontText = vs.styles[styleOffset + st.style].font.get();
105  			const std::string_view text(st.text + start, lenLine);
106  			widthSubLine = static_cast<int>(surface->WidthText(fontText, text));
107  		}
108  		if (widthSubLine > widthMax)
109  			widthMax = widthSubLine;
110  		start += lenLine + 1;
111  	}
112  	return widthMax;
113  }
114  void DrawTextNoClipPhase(Surface *surface, PRectangle rc, const Style &style, XYPOSITION ybase,
115  	std::string_view text, DrawPhase phase) {
116  	const Font *fontText = style.font.get();
117  	if (FlagSet(phase, DrawPhase::back)) {
118  		if (FlagSet(phase, DrawPhase::text)) {
119  			surface->DrawTextNoClip(rc, fontText, ybase, text,
120  				style.fore, style.back);
121  		} else {
122  			surface->FillRectangleAligned(rc, Fill(style.back));
123  		}
124  	} else if (FlagSet(phase, DrawPhase::text)) {
125  		surface->DrawTextTransparent(rc, fontText, ybase, text, style.fore);
126  	}
127  }
128  void DrawStyledText(Surface *surface, const ViewStyle &vs, int styleOffset, PRectangle rcText,
129  	const StyledText &st, size_t start, size_t length, DrawPhase phase) {
130  	if (st.multipleStyles) {
131  		int x = static_cast<int>(rcText.left);
132  		size_t i = 0;
133  		while (i < length) {
134  			size_t end = i;
135  			size_t style = st.styles[i + start];
136  			while (end < length - 1 && st.styles[start + end + 1] == style)
137  				end++;
138  			style += styleOffset;
139  			const Font *fontText = vs.styles[style].font.get();
140  			const std::string_view text(st.text + start + i, end - i + 1);
141  			const int width = static_cast<int>(surface->WidthText(fontText, text));
142  			PRectangle rcSegment = rcText;
143  			rcSegment.left = static_cast<XYPOSITION>(x);
144  			rcSegment.right = static_cast<XYPOSITION>(x + width + 1);
145  			DrawTextNoClipPhase(surface, rcSegment, vs.styles[style],
146  				rcText.top + vs.maxAscent, text, phase);
147  			x += width;
148  			i = end + 1;
149  		}
150  	} else {
151  		const size_t style = st.style + styleOffset;
152  		DrawTextNoClipPhase(surface, rcText, vs.styles[style],
153  			rcText.top + vs.maxAscent,
154  			std::string_view(st.text + start, length), phase);
155  	}
156  }
157  }
158  EditView::EditView() {
159  	tabWidthMinimumPixels = 2; 
160  	drawOverstrikeCaret = true;
161  	bufferedDraw = true;
162  	phasesDraw = PhasesDraw::Two;
163  	lineWidthMaxSeen = 0;
164  	additionalCaretsBlink = true;
165  	additionalCaretsVisible = true;
166  	imeCaretBlockOverride = false;
167  	llc.SetLevel(LineCache::Caret);
168  	posCache = CreatePositionCache();
169  	posCache->SetSize(0x400);
170  	maxLayoutThreads = 1;
171  	tabArrowHeight = 4;
172  	customDrawTabArrow = nullptr;
173  	customDrawWrapMarker = nullptr;
174  }
175  EditView::~EditView() = default;
176  bool EditView::SetTwoPhaseDraw(bool twoPhaseDraw) noexcept {
177  	const PhasesDraw phasesDrawNew = twoPhaseDraw ? PhasesDraw::Two : PhasesDraw::One;
178  	const bool redraw = phasesDraw != phasesDrawNew;
179  	phasesDraw = phasesDrawNew;
180  	return redraw;
181  }
182  bool EditView::SetPhasesDraw(int phases) noexcept {
183  	const PhasesDraw phasesDrawNew = static_cast<PhasesDraw>(phases);
184  	const bool redraw = phasesDraw != phasesDrawNew;
185  	phasesDraw = phasesDrawNew;
186  	return redraw;
187  }
188  bool EditView::LinesOverlap() const noexcept {
189  	return phasesDraw == PhasesDraw::Multiple;
190  }
191  void EditView::SetLayoutThreads(unsigned int threads) noexcept {
192  	maxLayoutThreads = std::clamp(threads, 1U, std::thread::hardware_concurrency());
193  }
194  unsigned int EditView::GetLayoutThreads() const noexcept {
195  	return maxLayoutThreads;
196  }
197  void EditView::ClearAllTabstops() noexcept {
198  	ldTabstops.reset();
199  }
200  XYPOSITION EditView::NextTabstopPos(Sci::Line line, XYPOSITION x, XYPOSITION tabWidth) const noexcept {
201  	const int next = GetNextTabstop(line, static_cast<int>(x + tabWidthMinimumPixels));
202  	if (next > 0)
203  		return static_cast<XYPOSITION>(next);
204  	return (static_cast<int>((x + tabWidthMinimumPixels) / tabWidth) + 1) * tabWidth;
205  }
206  bool EditView::ClearTabstops(Sci::Line line) noexcept {
207  	return ldTabstops && ldTabstops->ClearTabstops(line);
208  }
209  bool EditView::AddTabstop(Sci::Line line, int x) {
210  	if (!ldTabstops) {
211  		ldTabstops = std::make_unique<LineTabstops>();
212  	}
213  	return ldTabstops && ldTabstops->AddTabstop(line, x);
214  }
215  int EditView::GetNextTabstop(Sci::Line line, int x) const noexcept {
216  	if (ldTabstops) {
217  		return ldTabstops->GetNextTabstop(line, x);
218  	} else {
219  		return 0;
220  	}
221  }
222  void EditView::LinesAddedOrRemoved(Sci::Line lineOfPos, Sci::Line linesAdded) {
223  	if (ldTabstops) {
224  		if (linesAdded > 0) {
225  			for (Sci::Line line = lineOfPos; line < lineOfPos + linesAdded; line++) {
226  				ldTabstops->InsertLine(line);
227  			}
228  		} else {
229  			for (Sci::Line line = (lineOfPos + -linesAdded) - 1; line >= lineOfPos; line--) {
230  				ldTabstops->RemoveLine(line);
231  			}
232  		}
233  	}
234  }
235  void EditView::DropGraphics() noexcept {
236  	pixmapLine.reset();
237  	pixmapIndentGuide.reset();
238  	pixmapIndentGuideHighlight.reset();
239  }
240  void EditView::RefreshPixMaps(Surface *surfaceWindow, const ViewStyle &vsDraw) {
241  	if (!pixmapIndentGuide) {
242  		pixmapIndentGuide = surfaceWindow->AllocatePixMap(1, vsDraw.lineHeight + 1);
243  		pixmapIndentGuideHighlight = surfaceWindow->AllocatePixMap(1, vsDraw.lineHeight + 1);
244  		const PRectangle rcIG = PRectangle::FromInts(0, 0, 1, vsDraw.lineHeight);
245  		pixmapIndentGuide->FillRectangle(rcIG, vsDraw.styles[StyleIndentGuide].back);
246  		pixmapIndentGuideHighlight->FillRectangle(rcIG, vsDraw.styles[StyleBraceLight].back);
247  		for (int stripe = 1; stripe < vsDraw.lineHeight + 1; stripe += 2) {
248  			const PRectangle rcPixel = PRectangle::FromInts(0, stripe, 1, stripe + 1);
249  			pixmapIndentGuide->FillRectangle(rcPixel, vsDraw.styles[StyleIndentGuide].fore);
250  			pixmapIndentGuideHighlight->FillRectangle(rcPixel, vsDraw.styles[StyleBraceLight].fore);
251  		}
252  		pixmapIndentGuide->FlushDrawing();
253  		pixmapIndentGuideHighlight->FlushDrawing();
254  	}
255  }
256  std::shared_ptr<LineLayout> EditView::RetrieveLineLayout(Sci::Line lineNumber, const EditModel &model) {
257  	const Sci::Position posLineStart = model.pdoc->LineStart(lineNumber);
258  	const Sci::Position posLineEnd = model.pdoc->LineStart(lineNumber + 1);
259  	PLATFORM_ASSERT(posLineEnd >= posLineStart);
260  	const Sci::Line lineCaret = model.pdoc->SciLineFromPosition(model.sel.MainCaret());
261  	return llc.Retrieve(lineNumber, lineCaret,
262  		static_cast<int>(posLineEnd - posLineStart), model.pdoc->GetStyleClock(),
263  		model.LinesOnScreen() + 1, model.pdoc->LinesTotal());
264  }
265  namespace {
266  constexpr XYPOSITION epsilon = 0.0001f;	
267  inline char CaseForce(Style::CaseForce caseForce, char chDoc, char chPrevious) noexcept {
268  	switch (caseForce) {
269  	case Style::CaseForce::mixed:
270  		return chDoc;
271  	case Style::CaseForce::lower:
272  		return MakeLowerCase(chDoc);
273  	case Style::CaseForce::upper:
274  		return MakeUpperCase(chDoc);
275  	case Style::CaseForce::camel:
276  	default:	
277  		if (IsUpperOrLowerCase(chDoc) && !IsUpperOrLowerCase(chPrevious)) {
278  			return MakeUpperCase(chDoc);
279  		} else {
280  			return MakeLowerCase(chDoc);
281  		}
282  	}
283  }
284  void LayoutSegments(IPositionCache *pCache,
285  	Surface *surface,
286  	const ViewStyle &vstyle,
287  	LineLayout *ll,
288  	const std::vector<TextSegment> &segments,
289  	std::atomic<uint32_t> &nextIndex,
290  	const bool textUnicode,
291  	const bool multiThreaded) {
292  	while (true) {
293  		const uint32_t i = nextIndex.fetch_add(1, std::memory_order_acq_rel);
294  		if (i >= segments.size()) {
295  			break;
296  		}
297  		const TextSegment &ts = segments[i];
298  		const unsigned int styleSegment = ll->styles[ts.start];
299  		XYPOSITION *positions = &ll->positions[ts.start + 1];
300  		if (vstyle.styles[styleSegment].visible) {
301  			if (ts.representation) {
302  				XYPOSITION representationWidth = 0.0;
303  				if (ll->chars[ts.start] != '\t') {
304  					representationWidth = vstyle.controlCharWidth;
305  					if (representationWidth <= 0.0) {
306  						assert(ts.representation->stringRep.length() <= Representation::maxLength);
307  						XYPOSITION positionsRepr[Representation::maxLength + 1];
308  						pCache->MeasureWidths(surface, vstyle, StyleControlChar, true, ts.representation->stringRep,
309  							positionsRepr, multiThreaded);
310  						representationWidth = positionsRepr[ts.representation->stringRep.length() - 1];
311  						if (FlagSet(ts.representation->appearance, RepresentationAppearance::Blob)) {
312  							representationWidth += vstyle.ctrlCharPadding;
313  						}
314  					}
315  				}
316  				std::fill(positions, positions + ts.length, representationWidth);
317  			} else {
318  				if ((ts.length == 1) && (' ' == ll->chars[ts.start])) {
319  					positions[0] = vstyle.styles[styleSegment].spaceWidth;
320  				} else {
321  					pCache->MeasureWidths(surface, vstyle, styleSegment, textUnicode,
322  						std::string_view(&ll->chars[ts.start], ts.length), positions, multiThreaded);
323  				}
324  			}
325  		} else if (vstyle.styles[styleSegment].invisibleRepresentation[0]) {
326  			const std::string_view text = vstyle.styles[styleSegment].invisibleRepresentation;
327  			XYPOSITION positionsRepr[Representation::maxLength + 1];
328  			pCache->MeasureWidths(surface, vstyle, styleSegment, true, text, positionsRepr, multiThreaded);
329  			const XYPOSITION representationWidth = positionsRepr[text.length() - 1];
330  			std::fill(positions, positions + ts.length, representationWidth);
331  		}
332  	}
333  }
334  }
335  void EditView::LayoutLine(const EditModel &model, Surface *surface, const ViewStyle &vstyle, LineLayout *ll, int width, bool callerMultiThreaded) {
336  	if (!ll)
337  		return;
338  	const Sci::Line line = ll->LineNumber();
339  	PLATFORM_ASSERT(line < model.pdoc->LinesTotal());
340  	PLATFORM_ASSERT(ll->chars);
341  	const Sci::Position posLineStart = model.pdoc->LineStart(line);
342  	Sci::Position posLineEnd = model.pdoc->LineStart(line + 1);
343  	if (posLineEnd >(posLineStart + ll->maxLineLength)) {
344  		posLineEnd = posLineStart + ll->maxLineLength;
345  	}
346  	width = std::max(width, 20);
347  	if (ll->validity == LineLayout::ValidLevel::checkTextAndStyle) {
348  		Sci::Position lineLength = posLineEnd - posLineStart;
349  		if (!vstyle.viewEOL) {
350  			lineLength = model.pdoc->LineEnd(line) - posLineStart;
351  		}
352  		if (lineLength == ll->numCharsInLine) {
353  			bool allSame = true;
354  			char chPrevious = 0;
355  			for (Sci::Position numCharsInLine = 0; numCharsInLine < lineLength; numCharsInLine++) {
356  				const Sci::Position charInDoc = numCharsInLine + posLineStart;
357  				const char chDoc = model.pdoc->CharAt(charInDoc);
358  				const int styleByte = model.pdoc->StyleIndexAt(charInDoc);
359  				allSame = allSame &&
360  					(ll->styles[numCharsInLine] == styleByte);
361  				allSame = allSame &&
362  					(ll->chars[numCharsInLine] == CaseForce(vstyle.styles[styleByte].caseForce, chDoc, chPrevious));
363  				chPrevious = chDoc;
364  			}
365  			const int styleByteLast = (posLineEnd > posLineStart) ? model.pdoc->StyleIndexAt(posLineEnd - 1) : 0;
366  			allSame = allSame && (ll->styles[lineLength] == styleByteLast);	
367  			if (allSame) {
368  				ll->validity = (ll->widthLine != width) ? LineLayout::ValidLevel::positions : LineLayout::ValidLevel::lines;
369  			} else {
370  				ll->validity = LineLayout::ValidLevel::invalid;
371  			}
372  		} else {
373  			ll->validity = LineLayout::ValidLevel::invalid;
374  		}
375  	}
376  	if (ll->validity == LineLayout::ValidLevel::invalid) {
377  		ll->widthLine = LineLayout::wrapWidthInfinite;
378  		ll->lines = 1;
379  		if (vstyle.edgeState == EdgeVisualStyle::Background) {
380  			Sci::Position edgePosition = model.pdoc->FindColumn(line, vstyle.theEdge.column);
381  			if (edgePosition >= posLineStart) {
382  				edgePosition -= posLineStart;
383  			}
384  			ll->edgeColumn = static_cast<int>(edgePosition);
385  		} else {
386  			ll->edgeColumn = -1;
387  		}
388  		const int lineLength = static_cast<int>(posLineEnd - posLineStart);
389  		model.pdoc->GetCharRange(ll->chars.get(), posLineStart, lineLength);
390  		model.pdoc->GetStyleRange(ll->styles.get(), posLineStart, lineLength);
391  		const int numCharsBeforeEOL = static_cast<int>(model.pdoc->LineEnd(line) - posLineStart);
392  		const int numCharsInLine = (vstyle.viewEOL) ? lineLength : numCharsBeforeEOL;
393  		const unsigned char styleByteLast = (lineLength > 0) ? ll->styles[lineLength - 1] : 0;
394  		if (vstyle.someStylesForceCase) {
395  			char chPrevious = 0;
396  			for (int charInLine = 0; charInLine<lineLength; charInLine++) {
397  				const char chDoc = ll->chars[charInLine];
398  				ll->chars[charInLine] = CaseForce(vstyle.styles[ll->styles[charInLine]].caseForce, chDoc, chPrevious);
399  				chPrevious = chDoc;
400  			}
401  		}
402  		ll->xHighlightGuide = 0;
403  		ll->chars[numCharsInLine] = 0;   
404  		ll->styles[numCharsInLine] = styleByteLast;	
405  		ll->positions[0] = 0;
406  		bool lastSegItalics = false;
407  		std::vector<TextSegment> segments;
408  		BreakFinder bfLayout(ll, nullptr, Range(0, numCharsInLine), posLineStart, 0, BreakFinder::BreakFor::Text, model.pdoc, &model.reprs, nullptr);
409  		while (bfLayout.More()) {
410  			segments.push_back(bfLayout.Next());
411  		}
412  		ll->ClearPositions();
413  		if (!segments.empty()) {
414  			const size_t threadsForLength = std::max(1, numCharsInLine / bytesPerLayoutThread);
415  			size_t threads = std::min<size_t>({ segments.size(), threadsForLength, maxLayoutThreads });
416  			if (!surface->SupportsFeature(Supports::ThreadSafeMeasureWidths) || callerMultiThreaded) {
417  				threads = 1;
418  			}
419  			std::atomic<uint32_t> nextIndex = 0;
420  			const bool textUnicode = CpUtf8 == model.pdoc->dbcsCodePage;
421  			const bool multiThreaded = threads > 1;
422  			const bool multiThreadedContext = multiThreaded || callerMultiThreaded;
423  			IPositionCache *pCache = posCache.get();
424  			const std::launch policy = (multiThreaded) ? std::launch::async : std::launch::deferred;
425  			std::vector<std::future<void>> futures;
426  			for (size_t th = 0; th < threads; th++) {
427  				std::future<void> fut = std::async(policy,
428  					[pCache, surface, &vstyle, &ll, &segments, &nextIndex, textUnicode, multiThreadedContext]() {
429  					LayoutSegments(pCache, surface, vstyle, ll, segments, nextIndex, textUnicode, multiThreadedContext);
430  				});
431  				futures.push_back(std::move(fut));
432  			}
433  			for (const std::future<void> &f : futures) {
434  				f.wait();
435  			}
436  		}
437  		XYPOSITION xPosition = 0.0;
438  		size_t iByte = 0;
439  		ll->positions[iByte++] = xPosition;
440  		for (const TextSegment &ts : segments) {
441  			if (vstyle.styles[ll->styles[ts.start]].visible &&
442  				ts.representation &&
443  				(ll->chars[ts.start] == '\t')) {
444  				const XYPOSITION startTab = ll->positions[ts.start];
445  				const XYPOSITION nextTab = NextTabstopPos(line, startTab, vstyle.tabWidth);
446  				xPosition += nextTab - startTab;
447  			}
448  			const XYPOSITION xBeginSegment = xPosition;
449  			for (int i = 0; i < ts.length; i++) {
450  				xPosition = ll->positions[iByte] + xBeginSegment;
451  				ll->positions[iByte++] = xPosition;
452  			}
453  		}
454  		if (!segments.empty()) {
455  			const TextSegment &ts = segments.back();
456  			lastSegItalics = (!ts.representation) && ((ll->chars[ts.end() - 1] != ' ') && vstyle.styles[ll->styles[ts.start]].italic);
457  		}
458  		if (lastSegItalics) {
459  			ll->positions[numCharsInLine] += vstyle.lastSegItalicsOffset;
460  		}
461  		ll->numCharsInLine = numCharsInLine;
462  		ll->numCharsBeforeEOL = numCharsBeforeEOL;
463  		ll->validity = LineLayout::ValidLevel::positions;
464  	}
465  	if ((ll->validity == LineLayout::ValidLevel::positions) || (ll->widthLine != width)) {
466  		ll->widthLine = width;
467  		if (width == LineLayout::wrapWidthInfinite) {
468  			ll->lines = 1;
469  		} else if (width > ll->positions[ll->numCharsInLine]) {
470  			ll->lines = 1;
471  		} else {
472  			if (FlagSet(vstyle.wrap.visualFlags, WrapVisualFlag::End)) {
473  				width -= static_cast<int>(vstyle.aveCharWidth); 
474  			}
475  			XYPOSITION wrapAddIndent = 0; 
476  			switch (vstyle.wrap.indentMode) {
477  			case WrapIndentMode::Fixed:
478  				wrapAddIndent = vstyle.wrap.visualStartIndent * vstyle.aveCharWidth;
479  				break;
480  			case WrapIndentMode::Indent:
481  				wrapAddIndent = model.pdoc->IndentSize() * vstyle.spaceWidth;
482  				break;
483  			case WrapIndentMode::DeepIndent:
484  				wrapAddIndent = model.pdoc->IndentSize() * 2 * vstyle.spaceWidth;
485  				break;
486  			default:	
487  				break;
488  			}
489  			ll->wrapIndent = wrapAddIndent;
490  			if (vstyle.wrap.indentMode != WrapIndentMode::Fixed) {
491  				for (int i = 0; i < ll->numCharsInLine; i++) {
492  					if (!IsSpaceOrTab(ll->chars[i])) {
493  						ll->wrapIndent += ll->positions[i]; 
494  						break;
495  					}
496  				}
497  			}
498  			if (ll->wrapIndent > width - static_cast<int>(vstyle.aveCharWidth) * 15)
499  				ll->wrapIndent = wrapAddIndent;
500  			if ((FlagSet(vstyle.wrap.visualFlags, WrapVisualFlag::Start)) && (ll->wrapIndent < vstyle.aveCharWidth))
501  				ll->wrapIndent = vstyle.aveCharWidth; 
502  			ll->WrapLine(model.pdoc, posLineStart, vstyle.wrap.state, width);
503  		}
504  		ll->validity = LineLayout::ValidLevel::lines;
505  	}
506  }
507  void EditView::UpdateBidiData(const EditModel &model, const ViewStyle &vstyle, LineLayout *ll) {
508  	if (model.BidirectionalEnabled()) {
509  		ll->EnsureBidiData();
510  		for (int stylesInLine = 0; stylesInLine < ll->numCharsInLine; stylesInLine++) {
511  			ll->bidiData->stylesFonts[stylesInLine] = vstyle.styles[ll->styles[stylesInLine]].font;
512  		}
513  		ll->bidiData->stylesFonts[ll->numCharsInLine].reset();
514  		for (int charsInLine = 0; charsInLine < ll->numCharsInLine; charsInLine++) {
515  			const int charWidth = UTF8DrawBytes(&ll->chars[charsInLine], ll->numCharsInLine - charsInLine);
516  			const Representation *repr = model.reprs.RepresentationFromCharacter(std::string_view(&ll->chars[charsInLine], charWidth));
517  			ll->bidiData->widthReprs[charsInLine] = 0.0f;
518  			if (repr && ll->chars[charsInLine] != '\t') {
519  				ll->bidiData->widthReprs[charsInLine] = ll->positions[charsInLine + charWidth] - ll->positions[charsInLine];
520  			}
521  			if (charWidth > 1) {
522  				for (int c = 1; c < charWidth; c++) {
523  					charsInLine++;
524  					ll->bidiData->widthReprs[charsInLine] = 0.0f;
525  				}
526  			}
527  		}
528  		ll->bidiData->widthReprs[ll->numCharsInLine] = 0.0f;
529  	} else {
530  		ll->bidiData.reset();
531  	}
532  }
533  Point EditView::LocationFromPosition(Surface *surface, const EditModel &model, SelectionPosition pos, Sci::Line topLine,
534  				     const ViewStyle &vs, PointEnd pe, const PRectangle rcClient) {
535  	Point pt;
536  	if (pos.Position() == Sci::invalidPosition)
537  		return pt;
538  	Sci::Line lineDoc = model.pdoc->SciLineFromPosition(pos.Position());
539  	Sci::Position posLineStart = model.pdoc->LineStart(lineDoc);
540  	if (FlagSet(pe, PointEnd::lineEnd) && (lineDoc > 0) && (pos.Position() == posLineStart)) {
541  		lineDoc--;
542  		posLineStart = model.pdoc->LineStart(lineDoc);
543  	}
544  	const Sci::Line lineVisible = model.pcs->DisplayFromDoc(lineDoc);
545  	std::shared_ptr<LineLayout> ll = RetrieveLineLayout(lineDoc, model);
546  	if (surface && ll) {
547  		LayoutLine(model, surface, vs, ll.get(), model.wrapWidth);
548  		const int posInLine = static_cast<int>(pos.Position() - posLineStart);
549  		pt = ll->PointFromPosition(posInLine, vs.lineHeight, pe);
550  		pt.x += vs.textStart - model.xOffset;
551  		if (model.BidirectionalEnabled()) {
552  			UpdateBidiData(model, vs, ll.get());
553  			const int subLine = ll->SubLineFromPosition(posInLine, pe);
554  			const int caretPosition = posInLine - ll->LineStart(subLine);
555  			const ScreenLine screenLine(ll.get(), subLine, vs, rcClient.right, tabWidthMinimumPixels);
556  			std::unique_ptr<IScreenLineLayout> slLayout = surface->Layout(&screenLine);
557  			pt.x = slLayout->XFromPosition(caretPosition);
558  			pt.x += vs.textStart - model.xOffset;
559  			pt.y = 0;
560  			if (posInLine >= ll->LineStart(subLine)) {
561  				pt.y = static_cast<XYPOSITION>(subLine*vs.lineHeight);
562  			}
563  		}
564  		pt.y += (lineVisible - topLine) * vs.lineHeight;
565  		pt.x += pos.VirtualSpace() * vs.styles[ll->EndLineStyle()].spaceWidth;
566  	}
567  	return pt;
568  }
569  Range EditView::RangeDisplayLine(Surface *surface, const EditModel &model, Sci::Line lineVisible, const ViewStyle &vs) {
570  	Range rangeSubLine = Range(0, 0);
571  	if (lineVisible < 0) {
572  		return rangeSubLine;
573  	}
574  	const Sci::Line lineDoc = model.pcs->DocFromDisplay(lineVisible);
575  	const Sci::Position positionLineStart = model.pdoc->LineStart(lineDoc);
576  	std::shared_ptr<LineLayout> ll = RetrieveLineLayout(lineDoc, model);
577  	if (surface && ll) {
578  		LayoutLine(model, surface, vs, ll.get(), model.wrapWidth);
579  		const Sci::Line lineStartSet = model.pcs->DisplayFromDoc(lineDoc);
580  		const int subLine = static_cast<int>(lineVisible - lineStartSet);
581  		if (subLine < ll->lines) {
582  			rangeSubLine = ll->SubLineRange(subLine, LineLayout::Scope::visibleOnly);
583  			if (subLine == ll->lines-1) {
584  				rangeSubLine.end = model.pdoc->LineStart(lineDoc + 1) -
585  					positionLineStart;
586  			}
587  		}
588  	}
589  	rangeSubLine.start += positionLineStart;
590  	rangeSubLine.end += positionLineStart;
591  	return rangeSubLine;
592  }
593  SelectionPosition EditView::SPositionFromLocation(Surface *surface, const EditModel &model, PointDocument pt, bool canReturnInvalid,
594  	bool charPosition, bool virtualSpace, const ViewStyle &vs, const PRectangle rcClient) {
595  	pt.x = pt.x - vs.textStart;
596  	Sci::Line visibleLine = static_cast<int>(std::floor(pt.y / vs.lineHeight));
597  	if (!canReturnInvalid && (visibleLine < 0))
598  		visibleLine = 0;
599  	const Sci::Line lineDoc = model.pcs->DocFromDisplay(visibleLine);
600  	if (canReturnInvalid && (lineDoc < 0))
601  		return SelectionPosition(Sci::invalidPosition);
602  	if (lineDoc >= model.pdoc->LinesTotal())
603  		return SelectionPosition(canReturnInvalid ? Sci::invalidPosition :
604  			model.pdoc->Length());
605  	const Sci::Position posLineStart = model.pdoc->LineStart(lineDoc);
606  	std::shared_ptr<LineLayout> ll = RetrieveLineLayout(lineDoc, model);
607  	if (surface && ll) {
608  		LayoutLine(model, surface, vs, ll.get(), model.wrapWidth);
609  		const Sci::Line lineStartSet = model.pcs->DisplayFromDoc(lineDoc);
610  		const int subLine = static_cast<int>(visibleLine - lineStartSet);
611  		if (subLine < ll->lines) {
612  			const Range rangeSubLine = ll->SubLineRange(subLine, LineLayout::Scope::visibleOnly);
613  			const XYPOSITION subLineStart = ll->positions[rangeSubLine.start];
614  			if (subLine > 0)	
615  				pt.x -= ll->wrapIndent;
616  			Sci::Position positionInLine = 0;
617  			if (model.BidirectionalEnabled()) {
618  				UpdateBidiData(model, vs, ll.get());
619  				const ScreenLine screenLine(ll.get(), subLine, vs, rcClient.right, tabWidthMinimumPixels);
620  				std::unique_ptr<IScreenLineLayout> slLayout = surface->Layout(&screenLine);
621  				positionInLine = slLayout->PositionFromX(pt.x, charPosition) +
622  					rangeSubLine.start;
623  			} else {
624  				positionInLine = ll->FindPositionFromX(pt.x + subLineStart,
625  					rangeSubLine, charPosition);
626  			}
627  			if (positionInLine < rangeSubLine.end) {
628  				return SelectionPosition(model.pdoc->MovePositionOutsideChar(positionInLine + posLineStart, 1));
629  			}
630  			if (virtualSpace) {
631  				const XYPOSITION spaceWidth = vs.styles[ll->EndLineStyle()].spaceWidth;
632  				const int spaceOffset = static_cast<int>(
633  					(pt.x + subLineStart - ll->positions[rangeSubLine.end] + spaceWidth / 2) / spaceWidth);
634  				return SelectionPosition(rangeSubLine.end + posLineStart, spaceOffset);
635  			} else if (canReturnInvalid) {
636  				if (pt.x < (ll->positions[rangeSubLine.end] - subLineStart)) {
637  					return SelectionPosition(model.pdoc->MovePositionOutsideChar(rangeSubLine.end + posLineStart, 1));
638  				}
639  			} else {
640  				return SelectionPosition(rangeSubLine.end + posLineStart);
641  			}
642  		}
643  		if (!canReturnInvalid)
644  			return SelectionPosition(ll->numCharsInLine + posLineStart);
645  	}
646  	return SelectionPosition(canReturnInvalid ? Sci::invalidPosition : posLineStart);
647  }
648  SelectionPosition EditView::SPositionFromLineX(Surface *surface, const EditModel &model, Sci::Line lineDoc, int x, const ViewStyle &vs) {
649  	std::shared_ptr<LineLayout> ll = RetrieveLineLayout(lineDoc, model);
650  	if (surface && ll) {
651  		const Sci::Position posLineStart = model.pdoc->LineStart(lineDoc);
652  		LayoutLine(model, surface, vs, ll.get(), model.wrapWidth);
653  		const Range rangeSubLine = ll->SubLineRange(0, LineLayout::Scope::visibleOnly);
654  		const XYPOSITION subLineStart = ll->positions[rangeSubLine.start];
655  		const Sci::Position positionInLine = ll->FindPositionFromX(x + subLineStart, rangeSubLine, false);
656  		if (positionInLine < rangeSubLine.end) {
657  			return SelectionPosition(model.pdoc->MovePositionOutsideChar(positionInLine + posLineStart, 1));
658  		}
659  		const XYPOSITION spaceWidth = vs.styles[ll->EndLineStyle()].spaceWidth;
660  		const int spaceOffset = static_cast<int>(
661  			(x + subLineStart - ll->positions[rangeSubLine.end] + spaceWidth / 2) / spaceWidth);
662  		return SelectionPosition(rangeSubLine.end + posLineStart, spaceOffset);
663  	}
664  	return SelectionPosition(0);
665  }
666  Sci::Line EditView::DisplayFromPosition(Surface *surface, const EditModel &model, Sci::Position pos, const ViewStyle &vs) {
667  	const Sci::Line lineDoc = model.pdoc->SciLineFromPosition(pos);
668  	Sci::Line lineDisplay = model.pcs->DisplayFromDoc(lineDoc);
669  	std::shared_ptr<LineLayout> ll = RetrieveLineLayout(lineDoc, model);
670  	if (surface && ll) {
671  		LayoutLine(model, surface, vs, ll.get(), model.wrapWidth);
672  		const Sci::Position posLineStart = model.pdoc->LineStart(lineDoc);
673  		const Sci::Position posInLine = pos - posLineStart;
674  		lineDisplay--; 
675  		for (int subLine = 0; subLine < ll->lines; subLine++) {
676  			if (posInLine >= ll->LineStart(subLine)) {
677  				lineDisplay++;
678  			}
679  		}
680  	}
681  	return lineDisplay;
682  }
683  Sci::Position EditView::StartEndDisplayLine(Surface *surface, const EditModel &model, Sci::Position pos, bool start, const ViewStyle &vs) {
684  	const Sci::Line line = model.pdoc->SciLineFromPosition(pos);
685  	std::shared_ptr<LineLayout> ll = RetrieveLineLayout(line, model);
686  	Sci::Position posRet = Sci::invalidPosition;
687  	if (surface && ll) {
688  		const Sci::Position posLineStart = model.pdoc->LineStart(line);
689  		LayoutLine(model, surface, vs, ll.get(), model.wrapWidth);
690  		const Sci::Position posInLine = pos - posLineStart;
691  		if (posInLine <= ll->maxLineLength) {
692  			for (int subLine = 0; subLine < ll->lines; subLine++) {
693  				if ((posInLine >= ll->LineStart(subLine)) &&
694  				    (posInLine <= ll->LineStart(subLine + 1)) &&
695  				    (posInLine <= ll->numCharsBeforeEOL)) {
696  					if (start) {
697  						posRet = ll->LineStart(subLine) + posLineStart;
698  					} else {
699  						if (subLine == ll->lines - 1)
700  							posRet = ll->numCharsBeforeEOL + posLineStart;
701  						else
702  							posRet = model.pdoc->MovePositionOutsideChar(ll->LineStart(subLine + 1) + posLineStart - 1, -1, false);
703  					}
704  				}
705  			}
706  		}
707  	}
708  	return posRet;
709  }
710  namespace {
711  constexpr ColourRGBA bugColour = ColourRGBA(0xff, 0, 0xfe, 0xf0);
712  ColourRGBA SelectionBackground(const EditModel &model, const ViewStyle &vsDraw, InSelection inSelection) {
713  	if (inSelection == InSelection::inNone)
714  		return bugColour;	
715  	Element element = Element::SelectionBack;
716  	if (inSelection == InSelection::inAdditional)
717  		element = Element::SelectionAdditionalBack;
718  	if (!model.primarySelection)
719  		element = Element::SelectionSecondaryBack;
720  	if (!model.hasFocus && vsDraw.ElementColour(Element::SelectionInactiveBack))
721  		element = Element::SelectionInactiveBack;
722  	return vsDraw.ElementColour(element).value_or(bugColour);
723  }
724  ColourOptional SelectionForeground(const EditModel &model, const ViewStyle &vsDraw, InSelection inSelection) {
725  	if (inSelection == InSelection::inNone)
726  		return {};
727  	Element element = Element::SelectionText;
728  	if (inSelection == InSelection::inAdditional)
729  		element = Element::SelectionAdditionalText;
730  	if (!model.primarySelection)	
731  		element = Element::SelectionSecondaryText;
732  	if (!model.hasFocus) {
733  		if (vsDraw.ElementColour(Element::SelectionInactiveText)) {
734  			element = Element::SelectionInactiveText;
735  		} else {
736  			return {};
737  		}
738  	}
739  	return vsDraw.ElementColour(element);
740  }
741  ColourRGBA TextBackground(const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
742  	ColourOptional background, InSelection inSelection, bool inHotspot, int styleMain, Sci::Position i) {
743  	if (inSelection && (vsDraw.selection.layer == Layer::Base)) {
744  		return SelectionBackground(model, vsDraw, inSelection).Opaque();
745  	}
746  	if ((vsDraw.edgeState == EdgeVisualStyle::Background) &&
747  		(i >= ll->edgeColumn) &&
748  		(i < ll->numCharsBeforeEOL))
749  		return vsDraw.theEdge.colour;
750  	if (inHotspot) {
751  		if (const ColourOptional colourHotSpotBack = vsDraw.ElementColour(Element::HotSpotActiveBack)) {
752  			return colourHotSpotBack->Opaque();
753  		}
754  	}
755  	if (background && (styleMain != StyleBraceLight) && (styleMain != StyleBraceBad)) {
756  		return *background;
757  	} else {
758  		return vsDraw.styles[styleMain].back;
759  	}
760  }
761  void DrawTextBlob(Surface *surface, const ViewStyle &vsDraw, PRectangle rcSegment,
762  	std::string_view text, ColourRGBA textBack, ColourRGBA textFore, bool fillBackground) {
763  	if (rcSegment.Empty())
764  		return;
765  	if (fillBackground) {
766  		surface->FillRectangleAligned(rcSegment, Fill(textBack));
767  	}
768  	const Font *ctrlCharsFont = vsDraw.styles[StyleControlChar].font.get();
769  	const int normalCharHeight = static_cast<int>(std::ceil(vsDraw.styles[StyleControlChar].capitalHeight));
770  	PRectangle rcCChar = rcSegment;
771  	rcCChar.left = rcCChar.left + 1;
772  	rcCChar.top = rcSegment.top + vsDraw.maxAscent - normalCharHeight;
773  	rcCChar.bottom = rcSegment.top + vsDraw.maxAscent + 1;
774  	PRectangle rcCentral = rcCChar;
775  	rcCentral.top++;
776  	rcCentral.bottom--;
777  	surface->FillRectangleAligned(rcCentral, Fill(textFore));
778  	PRectangle rcChar = rcCChar;
779  	rcChar.left++;
780  	rcChar.right--;
781  	surface->DrawTextClippedUTF8(rcChar, ctrlCharsFont,
782  		rcSegment.top + vsDraw.maxAscent, text,
783  		textBack, textFore);
784  }
785  void FillLineRemainder(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
786  	Sci::Line line, PRectangle rcArea, int subLine) {
787  	InSelection eolInSelection = InSelection::inNone;
788  	if (vsDraw.selection.visible && (subLine == (ll->lines - 1))) {
789  		eolInSelection = model.LineEndInSelection(line);
790  	}
791  	if (eolInSelection && vsDraw.selection.eolFilled && (line < model.pdoc->LinesTotal() - 1) && (vsDraw.selection.layer == Layer::Base)) {
792  		surface->FillRectangleAligned(rcArea, Fill(SelectionBackground(model, vsDraw, eolInSelection).Opaque()));
793  	} else {
794  		const ColourOptional background = vsDraw.Background(model.GetMark(line), model.caret.active, ll->containsCaret);
795  		if (background) {
796  			surface->FillRectangleAligned(rcArea, Fill(*background));
797  		} else if (vsDraw.styles[ll->styles[ll->numCharsInLine]].eolFilled) {
798  			surface->FillRectangleAligned(rcArea, Fill(vsDraw.styles[ll->styles[ll->numCharsInLine]].back));
799  		} else {
800  			surface->FillRectangleAligned(rcArea, Fill(vsDraw.styles[StyleDefault].back));
801  		}
802  		if (eolInSelection && vsDraw.selection.eolFilled && (line < model.pdoc->LinesTotal() - 1) && (vsDraw.selection.layer != Layer::Base)) {
803  			surface->FillRectangleAligned(rcArea, SelectionBackground(model, vsDraw, eolInSelection));
804  		}
805  	}
806  }
807  }
808  void EditView::DrawEOL(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
809  	Sci::Line line, int xStart, PRectangle rcLine, int subLine, Sci::Position lineEnd, XYPOSITION subLineStart, ColourOptional background) {
810  	const Sci::Position posLineStart = model.pdoc->LineStart(line);
811  	PRectangle rcSegment = rcLine;
812  	const bool lastSubLine = subLine == (ll->lines - 1);
813  	XYPOSITION virtualSpace = 0;
814  	if (lastSubLine) {
815  		const XYPOSITION spaceWidth = vsDraw.styles[ll->EndLineStyle()].spaceWidth;
816  		virtualSpace = model.sel.VirtualSpaceFor(model.pdoc->LineEnd(line)) * spaceWidth;
817  	}
818  	const XYPOSITION xEol = ll->positions[lineEnd] - subLineStart;
819  	if (virtualSpace > 0.0f) {
820  		rcSegment.left = xEol + xStart;
821  		rcSegment.right = xEol + xStart + virtualSpace;
822  		const ColourRGBA backgroundFill = background.value_or(vsDraw.styles[ll->styles[ll->numCharsInLine]].back);
823  		surface->FillRectangleAligned(rcSegment, backgroundFill);
824  		if (vsDraw.selection.visible && (vsDraw.selection.layer == Layer::Base)) {
825  			const SelectionSegment virtualSpaceRange(SelectionPosition(model.pdoc->LineEnd(line)),
826  				SelectionPosition(model.pdoc->LineEnd(line),
827  					model.sel.VirtualSpaceFor(model.pdoc->LineEnd(line))));
828  			for (size_t r = 0; r<model.sel.Count(); r++) {
829  				const SelectionSegment portion = model.sel.Range(r).Intersect(virtualSpaceRange);
830  				if (!portion.Empty()) {
831  					const XYPOSITION spaceWidth = vsDraw.styles[ll->EndLineStyle()].spaceWidth;
832  					rcSegment.left = xStart + ll->positions[portion.start.Position() - posLineStart] -
833  						subLineStart+portion.start.VirtualSpace() * spaceWidth;
834  					rcSegment.right = xStart + ll->positions[portion.end.Position() - posLineStart] -
835  						subLineStart+portion.end.VirtualSpace() * spaceWidth;
836  					rcSegment.left = (rcSegment.left > rcLine.left) ? rcSegment.left : rcLine.left;
837  					rcSegment.right = (rcSegment.right < rcLine.right) ? rcSegment.right : rcLine.right;
838  					surface->FillRectangleAligned(rcSegment, Fill(
839  						SelectionBackground(model, vsDraw, model.sel.RangeType(r)).Opaque()));
840  				}
841  			}
842  		}
843  	}
844  	InSelection eolInSelection = InSelection::inNone;
845  	if (vsDraw.selection.visible && lastSubLine) {
846  		eolInSelection = model.LineEndInSelection(line);
847  	}
848  	const ColourRGBA selectionBack = SelectionBackground(model, vsDraw, eolInSelection);
849  	XYPOSITION blobsWidth = 0;
850  	if (lastSubLine) {
851  		for (Sci::Position eolPos = ll->numCharsBeforeEOL; eolPos<ll->numCharsInLine;) {
852  			const int styleMain = ll->styles[eolPos];
853  			const ColourOptional selectionFore = SelectionForeground(model, vsDraw, eolInSelection);
854  			ColourRGBA textFore = selectionFore.value_or(vsDraw.styles[styleMain].fore);
855  			char hexits[4] = "";
856  			std::string_view ctrlChar;
857  			Sci::Position widthBytes = 1;
858  			RepresentationAppearance appearance = RepresentationAppearance::Blob;
859  			const Representation *repr = model.reprs.RepresentationFromCharacter(std::string_view(&ll->chars[eolPos], ll->numCharsInLine - eolPos));
860  			if (repr) {
861  				widthBytes = ll->numCharsInLine - eolPos;
862  			} else {
863  				repr = model.reprs.RepresentationFromCharacter(std::string_view(&ll->chars[eolPos], 1));
864  			}
865  			if (repr) {
866  				ctrlChar = repr->stringRep;
867  				appearance = repr->appearance;
868  				if (FlagSet(appearance, RepresentationAppearance::Colour)) {
869  					textFore = repr->colour;
870  				}
871  			} else {
872  				const unsigned char chEOL = ll->chars[eolPos];
873  				if (UTF8IsAscii(chEOL)) {
874  					ctrlChar = ControlCharacterString(chEOL);
875  				} else {
876  					Hexits(hexits, chEOL);
877  					ctrlChar = hexits;
878  				}
879  			}
880  			rcSegment.left = xStart + ll->positions[eolPos] - subLineStart + virtualSpace;
881  			rcSegment.right = xStart + ll->positions[eolPos + widthBytes] - subLineStart + virtualSpace;
882  			blobsWidth += rcSegment.Width();
883  			const ColourRGBA textBack = TextBackground(model, vsDraw, ll, background, eolInSelection, false, styleMain, eolPos);
884  			if (eolInSelection && (line < model.pdoc->LinesTotal() - 1)) {
885  				if (vsDraw.selection.layer == Layer::Base) {
886  					surface->FillRectangleAligned(rcSegment, Fill(selectionBack.Opaque()));
887  				} else {
888  					surface->FillRectangleAligned(rcSegment, Fill(textBack));
889  				}
890  			} else {
891  				surface->FillRectangleAligned(rcSegment, Fill(textBack));
892  			}
893  			const bool drawEOLSelection = eolInSelection && (line < model.pdoc->LinesTotal() - 1);
894  			ColourRGBA blobText = textBack;
895  			if (drawEOLSelection && (vsDraw.selection.layer == Layer::UnderText)) {
896  				surface->FillRectangleAligned(rcSegment, selectionBack);
897  				blobText = textBack.MixedWith(selectionBack, selectionBack.GetAlphaComponent());
898  			}
899  			if (FlagSet(appearance, RepresentationAppearance::Blob)) {
900  				DrawTextBlob(surface, vsDraw, rcSegment, ctrlChar, blobText, textFore, phasesDraw == PhasesDraw::One);
901  			} else {
902  				surface->DrawTextTransparentUTF8(rcSegment, vsDraw.styles[StyleControlChar].font.get(),
903  					rcSegment.top + vsDraw.maxAscent, ctrlChar, textFore);
904  			}
905  			if (drawEOLSelection && (vsDraw.selection.layer == Layer::OverText)) {
906  				surface->FillRectangleAligned(rcSegment, selectionBack);
907  			}
908  			eolPos += widthBytes;
909  		}
910  	}
911  	rcSegment.left = xEol + xStart + virtualSpace + blobsWidth;
912  	rcSegment.right = rcSegment.left + vsDraw.aveCharWidth;
913  	if (eolInSelection && (line < model.pdoc->LinesTotal() - 1) && (vsDraw.selection.layer == Layer::Base)) {
914  		surface->FillRectangleAligned(rcSegment, Fill(selectionBack.Opaque()));
915  	} else {
916  		if (background) {
917  			surface->FillRectangleAligned(rcSegment, Fill(*background));
918  		} else if (line < model.pdoc->LinesTotal() - 1) {
919  			surface->FillRectangleAligned(rcSegment, Fill(vsDraw.styles[ll->styles[ll->numCharsInLine]].back));
920  		} else if (vsDraw.styles[ll->styles[ll->numCharsInLine]].eolFilled) {
921  			surface->FillRectangleAligned(rcSegment, Fill(vsDraw.styles[ll->styles[ll->numCharsInLine]].back));
922  		} else {
923  			surface->FillRectangleAligned(rcSegment, Fill(vsDraw.styles[StyleDefault].back));
924  		}
925  		if (eolInSelection && (line < model.pdoc->LinesTotal() - 1) && (vsDraw.selection.layer != Layer::Base)) {
926  			surface->FillRectangleAligned(rcSegment, selectionBack);
927  		}
928  	}
929  	rcSegment.left = rcSegment.right;
930  	if (rcSegment.left < rcLine.left)
931  		rcSegment.left = rcLine.left;
932  	rcSegment.right = rcLine.right;
933  	const bool drawEOLAnnotationStyledText = (vsDraw.eolAnnotationVisible != EOLAnnotationVisible::Hidden) && model.pdoc->EOLAnnotationStyledText(line).text;
934  	const bool fillRemainder = (!lastSubLine || (!model.GetFoldDisplayText(line) && !drawEOLAnnotationStyledText));
935  	if (fillRemainder) {
936  		FillLineRemainder(surface, model, vsDraw, ll, line, rcSegment, subLine);
937  	}
938  	bool drawWrapMarkEnd = false;
939  	if (subLine + 1 < ll->lines) {
940  		if (FlagSet(vsDraw.wrap.visualFlags, WrapVisualFlag::End)) {
941  			drawWrapMarkEnd = ll->LineStart(subLine + 1) != 0;
942  		}
943  		if (vsDraw.IsLineFrameOpaque(model.caret.active, ll->containsCaret)) {
944  			surface->FillRectangleAligned(Side(rcLine, Edge::right, vsDraw.GetFrameWidth()),
945  				vsDraw.ElementColourForced(Element::CaretLineBack).Opaque());
946  		}
947  	}
948  	if (drawWrapMarkEnd) {
949  		PRectangle rcPlace = rcSegment;
950  		const XYPOSITION maxLeft = rcPlace.right - vsDraw.aveCharWidth;
951  		if (FlagSet(vsDraw.wrap.visualFlagsLocation, WrapVisualLocation::EndByText)) {
952  			rcPlace.left = std::min(xEol + xStart + virtualSpace, maxLeft);
953  			rcPlace.right = rcPlace.left + vsDraw.aveCharWidth;
954  		} else {
955  			rcPlace.right = rcLine.right;
956  			rcPlace.left = maxLeft;
957  		}
958  		if (!customDrawWrapMarker) {
959  			DrawWrapMarker(surface, rcPlace, true, vsDraw.WrapColour());
960  		} else {
961  			customDrawWrapMarker(surface, rcPlace, true, vsDraw.WrapColour());
962  		}
963  	}
964  }
965  void EditView::DrawFoldDisplayText(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
966  							  Sci::Line line, int xStart, PRectangle rcLine, int subLine, XYPOSITION subLineStart, DrawPhase phase) {
967  	const bool lastSubLine = subLine == (ll->lines - 1);
968  	if (!lastSubLine)
969  		return;
970  	const char *text = model.GetFoldDisplayText(line);
971  	if (!text)
972  		return;
973  	PRectangle rcSegment = rcLine;
974  	const std::string_view foldDisplayText(text);
975  	const Font *fontText = vsDraw.styles[StyleFoldDisplayText].font.get();
976  	const int widthFoldDisplayText = static_cast<int>(surface->WidthText(fontText, foldDisplayText));
977  	InSelection eolInSelection = InSelection::inNone;
978  	if (vsDraw.selection.visible) {
979  		eolInSelection = model.LineEndInSelection(line);
980  	}
981  	const XYPOSITION spaceWidth = vsDraw.styles[ll->EndLineStyle()].spaceWidth;
982  	const XYPOSITION virtualSpace = model.sel.VirtualSpaceFor(
983  		model.pdoc->LineEnd(line)) * spaceWidth;
984  	rcSegment.left = xStart + ll->positions[ll->numCharsInLine] - subLineStart + virtualSpace + vsDraw.aveCharWidth;
985  	rcSegment.right = rcSegment.left + static_cast<XYPOSITION>(widthFoldDisplayText);
986  	const ColourOptional background = vsDraw.Background(model.GetMark(line), model.caret.active, ll->containsCaret);
987  	const ColourOptional selectionFore = SelectionForeground(model, vsDraw, eolInSelection);
988  	const ColourRGBA textFore = selectionFore.value_or(vsDraw.styles[StyleFoldDisplayText].fore);
989  	const ColourRGBA textBack = TextBackground(model, vsDraw, ll, background, eolInSelection,
990  											false, StyleFoldDisplayText, -1);
991  	if (model.trackLineWidth) {
992  		if (rcSegment.right + 1> lineWidthMaxSeen) {
993  			lineWidthMaxSeen = static_cast<int>(rcSegment.right + 1);
994  		}
995  	}
996  	if (FlagSet(phase, DrawPhase::back)) {
997  		surface->FillRectangleAligned(rcSegment, Fill(textBack));
998  		PRectangle rcRemainder = rcSegment;
999  		rcRemainder.left = rcRemainder.right;
1000  		if (rcRemainder.left < rcLine.left)
1001  			rcRemainder.left = rcLine.left;
1002  		rcRemainder.right = rcLine.right;
1003  		FillLineRemainder(surface, model, vsDraw, ll, line, rcRemainder, subLine);
1004  	}
1005  	if (FlagSet(phase, DrawPhase::text)) {
1006  		if (phasesDraw != PhasesDraw::One) {
1007  			surface->DrawTextTransparent(rcSegment, fontText,
1008  				rcSegment.top + vsDraw.maxAscent, foldDisplayText,
1009  				textFore);
1010  		} else {
1011  			surface->DrawTextNoClip(rcSegment, fontText,
1012  				rcSegment.top + vsDraw.maxAscent, foldDisplayText,
1013  				textFore, textBack);
1014  		}
1015  	}
1016  	if (FlagSet(phase, DrawPhase::indicatorsFore)) {
1017  		if (model.foldDisplayTextStyle == FoldDisplayTextStyle::Boxed) {
1018  			PRectangle rcBox = rcSegment;
1019  			rcBox.left = std::round(rcSegment.left);
1020  			rcBox.right = std::round(rcSegment.right);
1021  			surface->RectangleFrame(rcBox, Stroke(textFore));
1022  		}
1023  	}
1024  	if (FlagSet(phase, DrawPhase::selectionTranslucent)) {
1025  		if (eolInSelection && (line < model.pdoc->LinesTotal() - 1) && (vsDraw.selection.layer != Layer::Base)) {
1026  			surface->FillRectangleAligned(rcSegment, SelectionBackground(model, vsDraw, eolInSelection));
1027  		}
1028  	}
1029  }
1030  void EditView::DrawEOLAnnotationText(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
1031  	Sci::Line line, int xStart, PRectangle rcLine, int subLine, XYPOSITION subLineStart, DrawPhase phase) {
1032  	const bool lastSubLine = subLine == (ll->lines - 1);
1033  	if (!lastSubLine)
1034  		return;
1035  	if (vsDraw.eolAnnotationVisible == EOLAnnotationVisible::Hidden) {
1036  		return;
1037  	}
1038  	const StyledText stEOLAnnotation = model.pdoc->EOLAnnotationStyledText(line);
1039  	if (!stEOLAnnotation.text || !ValidStyledText(vsDraw, vsDraw.eolAnnotationStyleOffset, stEOLAnnotation)) {
1040  		return;
1041  	}
1042  	const std::string_view eolAnnotationText(stEOLAnnotation.text, stEOLAnnotation.length);
1043  	const size_t style = stEOLAnnotation.style + vsDraw.eolAnnotationStyleOffset;
1044  	PRectangle rcSegment = rcLine;
1045  	const Font *fontText = vsDraw.styles[style].font.get();
1046  	const Surface::Ends ends = static_cast<Surface::Ends>(static_cast<int>(vsDraw.eolAnnotationVisible) & 0xff);
1047  	const Surface::Ends leftSide = static_cast<Surface::Ends>(static_cast<int>(ends) & 0xf);
1048  	const Surface::Ends rightSide = static_cast<Surface::Ends>(static_cast<int>(ends) & 0xf0);
1049  	XYPOSITION leftBoxSpace = 0;
1050  	XYPOSITION rightBoxSpace = 0;
1051  	if (vsDraw.eolAnnotationVisible >= EOLAnnotationVisible::Boxed) {
1052  		leftBoxSpace = 1;
1053  		rightBoxSpace = 1;
1054  		if (vsDraw.eolAnnotationVisible != EOLAnnotationVisible::Boxed) {
1055  			switch (leftSide) {
1056  			case Surface::Ends::leftFlat:
1057  				leftBoxSpace = 1;
1058  				break;
1059  			case Surface::Ends::leftAngle:
1060  				leftBoxSpace = rcLine.Height() / 2.0;
1061  				break;
1062  			case Surface::Ends::semiCircles:
1063  			default:
1064  				leftBoxSpace = rcLine.Height() / 3.0;
1065  			   break;
1066  			}
1067  			switch (rightSide) {
1068  			case Surface::Ends::rightFlat:
1069  				rightBoxSpace = 1;
1070  				break;
1071  			case Surface::Ends::rightAngle:
1072  				rightBoxSpace = rcLine.Height() / 2.0;
1073  				break;
1074  			case Surface::Ends::semiCircles:
1075  			default:
1076  				rightBoxSpace = rcLine.Height() / 3.0;
1077  			   break;
1078  			}
1079  		}
1080  	}
1081  	const int widthEOLAnnotationText = static_cast<int>(surface->WidthTextUTF8(fontText, eolAnnotationText) +
1082  		leftBoxSpace + rightBoxSpace);
1083  	const XYPOSITION spaceWidth = vsDraw.styles[ll->EndLineStyle()].spaceWidth;
1084  	const XYPOSITION virtualSpace = model.sel.VirtualSpaceFor(
1085  		model.pdoc->LineEnd(line)) * spaceWidth;
1086  	rcSegment.left = xStart +
1087  		ll->positions[ll->numCharsInLine] - subLineStart
1088  		+ virtualSpace + vsDraw.aveCharWidth;
1089  	const char *textFoldDisplay = model.GetFoldDisplayText(line);
1090  	if (textFoldDisplay) {
1091  		const std::string_view foldDisplayText(textFoldDisplay);
1092  		rcSegment.left += static_cast<int>(
1093  			surface->WidthText(vsDraw.styles[StyleFoldDisplayText].font.get(), foldDisplayText)) +
1094  			vsDraw.aveCharWidth;
1095  	}
1096  	rcSegment.right = rcSegment.left + static_cast<XYPOSITION>(widthEOLAnnotationText);
1097  	const ColourOptional background = vsDraw.Background(model.GetMark(line), model.caret.active, ll->containsCaret);
1098  	const ColourRGBA textFore = vsDraw.styles[style].fore;
1099  	const ColourRGBA textBack = TextBackground(model, vsDraw, ll, background, InSelection::inNone,
1100  											false, static_cast<int>(style), -1);
1101  	if (model.trackLineWidth) {
1102  		if (rcSegment.right + 1> lineWidthMaxSeen) {
1103  			lineWidthMaxSeen = static_cast<int>(rcSegment.right + 1);
1104  		}
1105  	}
1106  	if (FlagSet(phase, DrawPhase::back)) {
1107  		PRectangle rcRemainder = rcSegment;
1108  		rcRemainder.right = rcLine.right;
1109  		FillLineRemainder(surface, model, vsDraw, ll, line, rcRemainder, subLine);
1110  	}
1111  	PRectangle rcText = rcSegment;
1112  	rcText.left += leftBoxSpace;
1113  	rcText.right -= rightBoxSpace;
1114  	if (FlagSet(phase, DrawPhase::text)) {
1115  		if (phasesDraw == PhasesDraw::One) {
1116  			surface->DrawTextNoClipUTF8(rcText, fontText,
1117  			rcText.top + vsDraw.maxAscent, eolAnnotationText,
1118  			textFore, textBack);
1119  		}
1120  	}
1121  	if (FlagSet(phase, DrawPhase::indicatorsBack)) {
1122  		const PRectangle rcBox = PixelAlign(rcSegment, 1);
1123  		switch (vsDraw.eolAnnotationVisible) {
1124  		case EOLAnnotationVisible::Standard:
1125  			if (phasesDraw != PhasesDraw::One) {
1126  				surface->FillRectangle(rcBox, textBack);
1127  			}
1128  			break;
1129  		case EOLAnnotationVisible::Boxed:
1130  			if (phasesDraw == PhasesDraw::One) {
1131  				surface->RectangleFrame(rcBox, textFore);
1132  			} else {
1133  				surface->RectangleDraw(rcBox, FillStroke(textBack, textFore));
1134  			}
1135  			break;
1136  		default:
1137  			if (phasesDraw == PhasesDraw::One) {
1138  				surface->Stadium(rcBox, FillStroke(ColourRGBA(textBack, 0), textFore), ends);
1139  			} else {
1140  				surface->Stadium(rcBox, FillStroke(textBack, textFore), ends);
1141  			}
1142  			break;
1143  		}
1144  	}
1145  	if (FlagSet(phase, DrawPhase::text)) {
1146  		if (phasesDraw != PhasesDraw::One) {
1147  			surface->DrawTextTransparentUTF8(rcText, fontText,
1148  				rcText.top + vsDraw.maxAscent, eolAnnotationText,
1149  				textFore);
1150  		}
1151  	}
1152  }
1153  namespace {
1154  constexpr bool AnnotationBoxedOrIndented(AnnotationVisible annotationVisible) noexcept {
1155  	return annotationVisible == AnnotationVisible::Boxed || annotationVisible == AnnotationVisible::Indented;
1156  }
1157  }
1158  void EditView::DrawAnnotation(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
1159  	Sci::Line line, int xStart, PRectangle rcLine, int subLine, DrawPhase phase) {
1160  	const int indent = static_cast<int>(model.pdoc->GetLineIndentation(line) * vsDraw.spaceWidth);
1161  	PRectangle rcSegment = rcLine;
1162  	const int annotationLine = subLine - ll->lines;
1163  	const StyledText stAnnotation = model.pdoc->AnnotationStyledText(line);
1164  	if (stAnnotation.text && ValidStyledText(vsDraw, vsDraw.annotationStyleOffset, stAnnotation)) {
1165  		if (FlagSet(phase, DrawPhase::back)) {
1166  			surface->FillRectangleAligned(rcSegment, Fill(vsDraw.styles[0].back));
1167  		}
1168  		rcSegment.left = static_cast<XYPOSITION>(xStart);
1169  		if (model.trackLineWidth || AnnotationBoxedOrIndented(vsDraw.annotationVisible)) {
1170  			int widthAnnotation = WidestLineWidth(surface, vsDraw, vsDraw.annotationStyleOffset, stAnnotation);
1171  			if (AnnotationBoxedOrIndented(vsDraw.annotationVisible)) {
1172  				widthAnnotation += static_cast<int>(vsDraw.spaceWidth * 2); 
1173  				rcSegment.left = static_cast<XYPOSITION>(xStart + indent);
1174  				rcSegment.right = rcSegment.left + widthAnnotation;
1175  			}
1176  			if (widthAnnotation > lineWidthMaxSeen)
1177  				lineWidthMaxSeen = widthAnnotation;
1178  		}
1179  		const int annotationLines = model.pdoc->AnnotationLines(line);
1180  		size_t start = 0;
1181  		size_t lengthAnnotation = stAnnotation.LineLength(start);
1182  		int lineInAnnotation = 0;
1183  		while ((lineInAnnotation < annotationLine) && (start < stAnnotation.length)) {
1184  			start += lengthAnnotation + 1;
1185  			lengthAnnotation = stAnnotation.LineLength(start);
1186  			lineInAnnotation++;
1187  		}
1188  		PRectangle rcText = rcSegment;
1189  		if ((FlagSet(phase, DrawPhase::back)) && AnnotationBoxedOrIndented(vsDraw.annotationVisible)) {
1190  			surface->FillRectangleAligned(rcText,
1191  				Fill(vsDraw.styles[stAnnotation.StyleAt(start) + vsDraw.annotationStyleOffset].back));
1192  			rcText.left += vsDraw.spaceWidth;
1193  		}
1194  		DrawStyledText(surface, vsDraw, vsDraw.annotationStyleOffset, rcText,
1195  			stAnnotation, start, lengthAnnotation, phase);
1196  		if ((FlagSet(phase, DrawPhase::back)) && (vsDraw.annotationVisible == AnnotationVisible::Boxed)) {
1197  			const ColourRGBA colourBorder = vsDraw.styles[vsDraw.annotationStyleOffset].fore;
1198  			const PRectangle rcBorder = PixelAlignOutside(rcSegment, surface->PixelDivisions());
1199  			surface->FillRectangle(Side(rcBorder, Edge::left, 1), colourBorder);
1200  			surface->FillRectangle(Side(rcBorder, Edge::right, 1), colourBorder);
1201  			if (subLine == ll->lines) {
1202  				surface->FillRectangle(Side(rcBorder, Edge::top, 1), colourBorder);
1203  			}
1204  			if (subLine == ll->lines + annotationLines - 1) {
1205  				surface->FillRectangle(Side(rcBorder, Edge::bottom, 1), colourBorder);
1206  			}
1207  		}
1208  	} else {
1209  		if (FlagSet(phase, DrawPhase::back)) {
1210  			surface->FillRectangle(rcSegment, bugColour.Opaque());
1211  		}
1212  	}
1213  }
1214  namespace {
1215  void DrawBlockCaret(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
1216  	int subLine, int xStart, Sci::Position offset, Sci::Position posCaret, PRectangle rcCaret, ColourRGBA caretColour) {
1217  	const Sci::Position lineStart = ll->LineStart(subLine);
1218  	Sci::Position posBefore = posCaret;
1219  	Sci::Position posAfter = model.pdoc->MovePositionOutsideChar(posCaret + 1, 1);
1220  	Sci::Position numCharsToDraw = posAfter - posCaret;
1221  	Sci::Position offsetFirstChar = offset;
1222  	Sci::Position offsetLastChar = offset + (posAfter - posCaret);
1223  	while ((posBefore > 0) && ((offsetLastChar - numCharsToDraw) >= lineStart)) {
1224  		if ((ll->positions[offsetLastChar] - ll->positions[offsetLastChar - numCharsToDraw]) > 0) {
1225  			break;
1226  		}
1227  		posBefore = model.pdoc->MovePositionOutsideChar(posBefore - 1, -1);
1228  		numCharsToDraw = posAfter - posBefore;
1229  		offsetFirstChar = offset - (posCaret - posBefore);
1230  	}
1231  	if (offsetFirstChar < 0)
1232  		offsetFirstChar = 0;
1233  	numCharsToDraw = offsetLastChar - offsetFirstChar;
1234  	while ((offsetLastChar < ll->LineStart(subLine + 1)) && (offsetLastChar <= ll->numCharsInLine)) {
1235  		posBefore = posAfter;
1236  		posAfter = model.pdoc->MovePositionOutsideChar(posAfter + 1, 1);
1237  		offsetLastChar = offset + (posAfter - posCaret);
1238  		if ((ll->positions[offsetLastChar] - ll->positions[offsetLastChar - (posAfter - posBefore)]) > 0) {
1239  			break;
1240  		}
1241  		numCharsToDraw = offsetLastChar - offsetFirstChar;
1242  	}
1243  	rcCaret.left = ll->positions[offsetFirstChar] - ll->positions[lineStart] + xStart;
1244  	rcCaret.right = ll->positions[offsetFirstChar + numCharsToDraw] - ll->positions[lineStart] + xStart;
1245  	if ((ll->wrapIndent != 0) && (lineStart != 0)) {
1246  		const XYPOSITION wordWrapCharWidth = ll->wrapIndent;
1247  		rcCaret.left += wordWrapCharWidth;
1248  		rcCaret.right += wordWrapCharWidth;
1249  	}
1250  	const int styleMain = ll->styles[offsetFirstChar];
1251  	const Font *fontText = vsDraw.styles[styleMain].font.get();
1252  	const std::string_view text(&ll->chars[offsetFirstChar], numCharsToDraw);
1253  	surface->DrawTextClipped(rcCaret, fontText,
1254  		rcCaret.top + vsDraw.maxAscent, text, vsDraw.styles[styleMain].back,
1255  		caretColour);
1256  }
1257  }
1258  void EditView::DrawCarets(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
1259  	Sci::Line lineDoc, int xStart, PRectangle rcLine, int subLine) const {
1260  	const bool drawDrag = model.posDrag.IsValid();
1261  	if (!vsDraw.selection.visible && !drawDrag)
1262  		return;
1263  	const Sci::Position posLineStart = model.pdoc->LineStart(lineDoc);
1264  	for (size_t r = 0; (r<model.sel.Count()) || drawDrag; r++) {
1265  		const bool mainCaret = r == model.sel.Main();
1266  		SelectionPosition posCaret = (drawDrag ? model.posDrag : model.sel.Range(r).caret);
1267  		if ((vsDraw.DrawCaretInsideSelection(model.inOverstrike, imeCaretBlockOverride)) &&
1268  			!drawDrag &&
1269  			posCaret > model.sel.Range(r).anchor) {
1270  			if (posCaret.VirtualSpace() > 0)
1271  				posCaret.SetVirtualSpace(posCaret.VirtualSpace() - 1);
1272  			else
1273  				posCaret.SetPosition(model.pdoc->MovePositionOutsideChar(posCaret.Position()-1, -1));
1274  		}
1275  		const int offset = static_cast<int>(posCaret.Position() - posLineStart);
1276  		const XYPOSITION spaceWidth = vsDraw.styles[ll->EndLineStyle()].spaceWidth;
1277  		const XYPOSITION virtualOffset = posCaret.VirtualSpace() * spaceWidth;
1278  		if (ll->InLine(offset, subLine) && offset <= ll->numCharsBeforeEOL) {
1279  			XYPOSITION xposCaret = ll->positions[offset] + virtualOffset - ll->positions[ll->LineStart(subLine)];
1280  			if (model.BidirectionalEnabled() && (posCaret.VirtualSpace() == 0)) {
1281  				const ScreenLine screenLine(ll, subLine, vsDraw, rcLine.right, tabWidthMinimumPixels);
1282  				const int caretPosition = offset - ll->LineStart(subLine);
1283  				std::unique_ptr<IScreenLineLayout> slLayout = surface->Layout(&screenLine);
1284  				const XYPOSITION caretLeft = slLayout->XFromPosition(caretPosition);
1285  				xposCaret = caretLeft + virtualOffset;
1286  			}
1287  			if (ll->wrapIndent != 0) {
1288  				const Sci::Position lineStart = ll->LineStart(subLine);
1289  				if (lineStart != 0)	
1290  					xposCaret += ll->wrapIndent;
1291  			}
1292  			const bool caretBlinkState = (model.caret.active && model.caret.on) || (!additionalCaretsBlink && !mainCaret);
1293  			const bool caretVisibleState = additionalCaretsVisible || mainCaret;
1294  			if ((xposCaret >= 0) && vsDraw.IsCaretVisible(mainCaret) &&
1295  				(drawDrag || (caretBlinkState && caretVisibleState))) {
1296  				bool canDrawBlockCaret = true;
1297  				bool drawBlockCaret = false;
1298  				XYPOSITION widthOverstrikeCaret;
1299  				XYPOSITION caretWidthOffset = 0;
1300  				PRectangle rcCaret = rcLine;
1301  				if (posCaret.Position() == model.pdoc->Length()) {   
1302  					canDrawBlockCaret = false;
1303  					widthOverstrikeCaret = vsDraw.aveCharWidth;
1304  				} else if ((posCaret.Position() - posLineStart) >= ll->numCharsInLine) {	
1305  					canDrawBlockCaret = false;
1306  					widthOverstrikeCaret = vsDraw.aveCharWidth;
1307  				} else {
1308  					const int widthChar = model.pdoc->LenChar(posCaret.Position());
1309  					widthOverstrikeCaret = ll->positions[offset + widthChar] - ll->positions[offset];
1310  				}
1311  				if (widthOverstrikeCaret < 3)	
1312  					widthOverstrikeCaret = 3;
1313  				if (xposCaret > 0)
1314  					caretWidthOffset = 0.51f;	
1315  				xposCaret += xStart;
1316  				const ViewStyle::CaretShape caretShape = drawDrag ? ViewStyle::CaretShape::line :
1317  					vsDraw.CaretShapeForMode(model.inOverstrike, mainCaret);
1318  				if (drawDrag) {
1319  					rcCaret.left = std::round(xposCaret - caretWidthOffset);
1320  					rcCaret.right = rcCaret.left + vsDraw.caret.width;
1321  				} else if ((caretShape == ViewStyle::CaretShape::bar) && drawOverstrikeCaret) {
1322  					rcCaret.top = rcCaret.bottom - 2;
1323  					rcCaret.left = xposCaret + 1;
1324  					rcCaret.right = rcCaret.left + widthOverstrikeCaret - 1;
1325  				} else if ((caretShape == ViewStyle::CaretShape::block) || imeCaretBlockOverride) {
1326  					rcCaret.left = xposCaret;
1327  					if (canDrawBlockCaret && !(IsControl(ll->chars[offset]))) {
1328  						drawBlockCaret = true;
1329  						rcCaret.right = xposCaret + widthOverstrikeCaret;
1330  					} else {
1331  						rcCaret.right = xposCaret + vsDraw.aveCharWidth;
1332  					}
1333  				} else {
1334  					rcCaret.left = std::round(xposCaret - caretWidthOffset);
1335  					rcCaret.right = rcCaret.left + vsDraw.caret.width;
1336  				}
1337  				const Element elementCaret = mainCaret ? Element::Caret : Element::CaretAdditional;
1338  				const ColourRGBA caretColour = vsDraw.ElementColourForced(elementCaret);
1339  				if (drawBlockCaret) {
1340  					DrawBlockCaret(surface, model, vsDraw, ll, subLine, xStart, offset, posCaret.Position(), rcCaret, caretColour);
1341  				} else {
1342  					surface->FillRectangleAligned(rcCaret, Fill(caretColour));
1343  				}
1344  			}
1345  		}
1346  		if (drawDrag)
1347  			break;
1348  	}
1349  }
1350  namespace {
1351  void DrawWrapIndentAndMarker(Surface *surface, const ViewStyle &vsDraw, const LineLayout *ll,
1352  	int xStart, PRectangle rcLine, ColourOptional background, DrawWrapMarkerFn customDrawWrapMarker,
1353  	bool caretActive) {
1354  	surface->FillRectangleAligned(rcLine, Fill(background.value_or(vsDraw.styles[StyleDefault].back)));
1355  	if (vsDraw.IsLineFrameOpaque(caretActive, ll->containsCaret)) {
1356  		surface->FillRectangleAligned(Side(rcLine, Edge::left, vsDraw.GetFrameWidth()),
1357  			vsDraw.ElementColourForced(Element::CaretLineBack).Opaque());
1358  	}
1359  	if (FlagSet(vsDraw.wrap.visualFlags, WrapVisualFlag::Start)) {
1360  		PRectangle rcPlace = rcLine;
1361  		rcPlace.left = static_cast<XYPOSITION>(xStart);
1362  		rcPlace.right = rcPlace.left + ll->wrapIndent;
1363  		if (FlagSet(vsDraw.wrap.visualFlagsLocation, WrapVisualLocation::StartByText))
1364  			rcPlace.left = rcPlace.right - vsDraw.aveCharWidth;
1365  		else
1366  			rcPlace.right = rcPlace.left + vsDraw.aveCharWidth;
1367  		if (!customDrawWrapMarker) {
1368  			DrawWrapMarker(surface, rcPlace, false, vsDraw.WrapColour());
1369  		} else {
1370  			customDrawWrapMarker(surface, rcPlace, false, vsDraw.WrapColour());
1371  		}
1372  	}
1373  }
1374  InSelection CharacterInCursesSelection(Sci::Position iDoc, const EditModel &model, const ViewStyle &vsDraw) noexcept {
1375  	const SelectionPosition &posCaret = model.sel.RangeMain().caret;
1376  	const bool caretAtStart = posCaret < model.sel.RangeMain().anchor && posCaret.Position() == iDoc;
1377  	const bool caretAtEnd = posCaret > model.sel.RangeMain().anchor &&
1378  		vsDraw.DrawCaretInsideSelection(false, false) &&
1379  		model.pdoc->MovePositionOutsideChar(posCaret.Position() - 1, -1) == iDoc;
1380  	return (caretAtStart || caretAtEnd) ? InSelection::inNone : InSelection::inMain;
1381  }
1382  void DrawBackground(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
1383  	int xStart, PRectangle rcLine, int subLine, Range lineRange, Sci::Position posLineStart,
1384  	ColourOptional background) {
1385  	const bool selBackDrawn = vsDraw.SelectionBackgroundDrawn();
1386  	bool inIndentation = subLine == 0;	
1387  	const XYPOSITION subLineStart = ll->positions[lineRange.start];
1388  	const XYPOSITION horizontalOffset = xStart - subLineStart;
1389  	const XYPOSITION xStartVisible = subLineStart - xStart;
1390  	const BreakFinder::BreakFor breakFor = selBackDrawn ? BreakFinder::BreakFor::Selection : BreakFinder::BreakFor::Text;
1391  	BreakFinder bfBack(ll, &model.sel, lineRange, posLineStart, xStartVisible, breakFor, model.pdoc, &model.reprs, &vsDraw);
1392  	const bool drawWhitespaceBackground = vsDraw.WhitespaceBackgroundDrawn() && !background;
1393  	while (bfBack.More()) {
1394  		const TextSegment ts = bfBack.Next();
1395  		const Sci::Position i = ts.end() - 1;
1396  		const Sci::Position iDoc = i + posLineStart;
1397  		const Interval horizontal = ll->Span(ts.start, ts.end()).Offset(horizontalOffset);
1398  		if (!horizontal.Empty() && rcLine.Intersects(horizontal)) {
1399  			const PRectangle rcSegment = Intersection(rcLine, horizontal);
1400  			InSelection inSelection = vsDraw.selection.visible ? model.sel.CharacterInSelection(iDoc) : InSelection::inNone;
1401  			if (FlagSet(vsDraw.caret.style, CaretStyle::Curses) && (inSelection == InSelection::inMain))
1402  				inSelection = CharacterInCursesSelection(iDoc, model, vsDraw);
1403  			const bool inHotspot = model.hotspot.Valid() && model.hotspot.ContainsCharacter(iDoc);
1404  			ColourRGBA textBack = TextBackground(model, vsDraw, ll, background, inSelection,
1405  				inHotspot, ll->styles[i], i);
1406  			if (ts.representation) {
1407  				if (ll->chars[i] == '\t') {
1408  					if (drawWhitespaceBackground && vsDraw.WhiteSpaceVisible(inIndentation)) {
1409  						textBack = vsDraw.ElementColourForced(Element::WhiteSpaceBack).Opaque();
1410  					}
1411  				} else {
1412  					inIndentation = false;
1413  				}
1414  				surface->FillRectangleAligned(rcSegment, Fill(textBack));
1415  			} else {
1416  				surface->FillRectangleAligned(rcSegment, Fill(textBack));
1417  				if (vsDraw.viewWhitespace != WhiteSpace::Invisible) {
1418  					for (int cpos = 0; cpos <= i - ts.start; cpos++) {
1419  						if (ll->chars[cpos + ts.start] == ' ') {
1420  							if (drawWhitespaceBackground && vsDraw.WhiteSpaceVisible(inIndentation)) {
1421  								const PRectangle rcSpace = Intersection(rcLine,
1422  									ll->SpanByte(cpos + ts.start).Offset(horizontalOffset));
1423  								surface->FillRectangleAligned(rcSpace,
1424  									vsDraw.ElementColourForced(Element::WhiteSpaceBack).Opaque());
1425  							}
1426  						} else {
1427  							inIndentation = false;
1428  						}
1429  					}
1430  				}
1431  			}
1432  		} else if (horizontal.left > rcLine.right) {
1433  			break;
1434  		}
1435  	}
1436  }
1437  void DrawEdgeLine(Surface *surface, const ViewStyle &vsDraw, const LineLayout *ll,
1438  	int xStart, PRectangle rcLine, Range lineRange) {
1439  	if (vsDraw.edgeState == EdgeVisualStyle::Line) {
1440  		PRectangle rcSegment = rcLine;
1441  		const int edgeX = static_cast<int>(vsDraw.theEdge.column * vsDraw.spaceWidth);
1442  		rcSegment.left = static_cast<XYPOSITION>(edgeX + xStart);
1443  		if ((ll->wrapIndent != 0) && (lineRange.start != 0))
1444  			rcSegment.left -= ll->wrapIndent;
1445  		rcSegment.right = rcSegment.left + 1;
1446  		surface->FillRectangleAligned(rcSegment, Fill(vsDraw.theEdge.colour));
1447  	} else if (vsDraw.edgeState == EdgeVisualStyle::MultiLine) {
1448  		for (size_t edge = 0; edge < vsDraw.theMultiEdge.size(); edge++) {
1449  			if (vsDraw.theMultiEdge[edge].column >= 0) {
1450  				PRectangle rcSegment = rcLine;
1451  				const int edgeX = static_cast<int>(vsDraw.theMultiEdge[edge].column * vsDraw.spaceWidth);
1452  				rcSegment.left = static_cast<XYPOSITION>(edgeX + xStart);
1453  				if ((ll->wrapIndent != 0) && (lineRange.start != 0))
1454  					rcSegment.left -= ll->wrapIndent;
1455  				rcSegment.right = rcSegment.left + 1;
1456  				surface->FillRectangleAligned(rcSegment, Fill(vsDraw.theMultiEdge[edge].colour));
1457  			}
1458  		}
1459  	}
1460  }
1461  void DrawMarkUnderline(Surface *surface, const EditModel &model, const ViewStyle &vsDraw,
1462  	Sci::Line line, PRectangle rcLine) {
1463  	int marks = model.GetMark(line);
1464  	for (int markBit = 0; (markBit < 32) && marks; markBit++) {
1465  		if ((marks & 1) && (vsDraw.markers[markBit].markType == MarkerSymbol::Underline) &&
1466  			(vsDraw.markers[markBit].layer == Layer::Base)) {
1467  			PRectangle rcUnderline = rcLine;
1468  			rcUnderline.top = rcUnderline.bottom - 2;
1469  			surface->FillRectangleAligned(rcUnderline, Fill(vsDraw.markers[markBit].back));
1470  		}
1471  		marks >>= 1;
1472  	}
1473  }
1474  void DrawTranslucentSelection(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
1475  	Sci::Line line, int xStart, PRectangle rcLine, int subLine, Range lineRange, int tabWidthMinimumPixels, Layer layer) {
1476  	if (vsDraw.selection.layer == layer) {
1477  		const Sci::Position posLineStart = model.pdoc->LineStart(line);
1478  		const XYPOSITION subLineStart = ll->positions[lineRange.start];
1479  		const XYPOSITION horizontalOffset = xStart - subLineStart;
1480  		Sci::Position virtualSpaces = 0;
1481  		if (subLine == (ll->lines - 1)) {
1482  			virtualSpaces = model.sel.VirtualSpaceFor(model.pdoc->LineEnd(line));
1483  		}
1484  		const SelectionPosition posStart(posLineStart + lineRange.start);
1485  		const SelectionPosition posEnd(posLineStart + lineRange.end, virtualSpaces);
1486  		const SelectionSegment virtualSpaceRange(posStart, posEnd);
1487  		for (size_t r = 0; r < model.sel.Count(); r++) {
1488  			const SelectionSegment portion = model.sel.Range(r).Intersect(virtualSpaceRange);
1489  			if (!portion.Empty()) {
1490  				const SelectionSegment portionInLine = portion.Subtract(posLineStart);
1491  				const ColourRGBA selectionBack = SelectionBackground(
1492  					model, vsDraw, model.sel.RangeType(r));
1493  				const XYPOSITION spaceWidth = vsDraw.styles[ll->EndLineStyle()].spaceWidth;
1494  				const Interval intervalVirtual{ portion.start.VirtualSpace() * spaceWidth, portion.end.VirtualSpace() * spaceWidth };
1495  				if (model.BidirectionalEnabled()) {
1496  					const SelectionSegment portionInSubLine = portionInLine.Subtract(lineRange.start);
1497  					const ScreenLine screenLine(ll, subLine, vsDraw, rcLine.right, tabWidthMinimumPixels);
1498  					std::unique_ptr<IScreenLineLayout> slLayout = surface->Layout(&screenLine);
1499  					if (slLayout) {
1500  						const std::vector<Interval> intervals = slLayout->FindRangeIntervals(
1501  							portionInSubLine.start.Position(), portionInSubLine.end.Position());
1502  						for (const Interval &interval : intervals) {
1503  							const PRectangle rcSelection = rcLine.WithHorizontalBounds(interval.Offset(xStart));
1504  							surface->FillRectangleAligned(rcSelection, selectionBack);
1505  						}
1506  					}
1507  					if (portion.end.VirtualSpace()) {
1508  						const XYPOSITION xStartVirtual = ll->positions[lineRange.end] + horizontalOffset;
1509  						const PRectangle rcSegment = rcLine.WithHorizontalBounds(intervalVirtual.Offset(xStartVirtual));
1510  						surface->FillRectangleAligned(rcSegment, selectionBack);
1511  					}
1512  				} else {
1513  					Interval intervalSegment = ll->Span(
1514  						static_cast<int>(portionInLine.start.Position()),
1515  						static_cast<int>(portionInLine.end.Position()))
1516  						.Offset(horizontalOffset);
1517  					intervalSegment.left += intervalVirtual.left;
1518  					intervalSegment.right += intervalVirtual.right;
1519  					if ((ll->wrapIndent != 0) && (lineRange.start != 0)) {
1520  						if ((portionInLine.start.Position() == lineRange.start) &&
1521  							model.sel.Range(r).ContainsCharacter(portion.start.Position() - 1))
1522  							intervalSegment.left -= static_cast<int>(ll->wrapIndent); 
1523  					}
1524  					const PRectangle rcSegment = Intersection(rcLine, intervalSegment);
1525  					if (rcSegment.right > rcLine.left)
1526  						surface->FillRectangleAligned(rcSegment, selectionBack);
1527  				}
1528  			}
1529  		}
1530  	}
1531  }
1532  void DrawCaretLineFramed(Surface *surface, const ViewStyle &vsDraw, const LineLayout *ll,
1533  	PRectangle rcLine, int subLine) {
1534  	const ColourOptional caretlineBack = vsDraw.ElementColour(Element::CaretLineBack);
1535  	if (!caretlineBack) {
1536  		return;
1537  	}
1538  	const ColourRGBA colourFrame = (vsDraw.caretLine.layer == Layer::Base) ?
1539  		caretlineBack->Opaque() : *caretlineBack;
1540  	const int width = vsDraw.GetFrameWidth();
1541  	const PRectangle rcWithoutLeftRight = rcLine.Inset(Point(width, 0.0));
1542  	if (subLine == 0 || ll->wrapIndent == 0 || vsDraw.caretLine.layer != Layer::Base || vsDraw.caretLine.subLine) {
1543  		surface->FillRectangleAligned(Side(rcLine, Edge::left, width), colourFrame);
1544  	}
1545  	if (subLine == 0 || vsDraw.caretLine.subLine) {
1546  		surface->FillRectangleAligned(Side(rcWithoutLeftRight, Edge::top, width), colourFrame);
1547  	}
1548  	if (subLine == ll->lines - 1 || vsDraw.caretLine.layer != Layer::Base || vsDraw.caretLine.subLine) {
1549  		surface->FillRectangleAligned(Side(rcLine, Edge::right, width), colourFrame);
1550  	}
1551  	if (subLine == ll->lines - 1 || vsDraw.caretLine.subLine) {
1552  		surface->FillRectangleAligned(Side(rcWithoutLeftRight, Edge::bottom, width), colourFrame);
1553  	}
1554  }
1555  void DrawTranslucentLineState(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
1556  	Sci::Line line, PRectangle rcLine, int subLine, Layer layer) {
1557  	if ((model.caret.active || vsDraw.caretLine.alwaysShow) && vsDraw.ElementColour(Element::CaretLineBack) && ll->containsCaret &&
1558  		vsDraw.caretLine.layer == layer) {
1559  		if (vsDraw.caretLine.frame) {
1560  			DrawCaretLineFramed(surface, vsDraw, ll, rcLine, subLine);
1561  		} else {
1562  			surface->FillRectangleAligned(rcLine, vsDraw.ElementColourForced(Element::CaretLineBack));
1563  		}
1564  	}
1565  	const int marksOfLine = model.GetMark(line);
1566  	int marksDrawnInText = marksOfLine & vsDraw.maskDrawInText;
1567  	for (int markBit = 0; (markBit < 32) && marksDrawnInText; markBit++) {
1568  		if ((marksDrawnInText & 1) && (vsDraw.markers[markBit].layer == layer)) {
1569  			if (vsDraw.markers[markBit].markType == MarkerSymbol::Background) {
1570  				surface->FillRectangleAligned(rcLine, vsDraw.markers[markBit].BackWithAlpha());
1571  			} else if (vsDraw.markers[markBit].markType == MarkerSymbol::Underline) {
1572  				PRectangle rcUnderline = rcLine;
1573  				rcUnderline.top = rcUnderline.bottom - 2;
1574  				surface->FillRectangleAligned(rcUnderline, vsDraw.markers[markBit].BackWithAlpha());
1575  			}
1576  		}
1577  		marksDrawnInText >>= 1;
1578  	}
1579  	int marksDrawnInLine = marksOfLine & vsDraw.maskInLine;
1580  	for (int markBit = 0; (markBit < 32) && marksDrawnInLine; markBit++) {
1581  		if ((marksDrawnInLine & 1) && (vsDraw.markers[markBit].layer == layer)) {
1582  			surface->FillRectangleAligned(rcLine, vsDraw.markers[markBit].BackWithAlpha());
1583  		}
1584  		marksDrawnInLine >>= 1;
1585  	}
1586  }
1587  void DrawTabArrow(Surface *surface, PRectangle rcTab, int ymid,
1588  	const ViewStyle &vsDraw, Stroke stroke) {
1589  	const XYPOSITION halfWidth = stroke.width / 2.0;
1590  	const XYPOSITION leftStroke = std::round(std::min(rcTab.left + 2, rcTab.right - 1)) + halfWidth;
1591  	const XYPOSITION rightStroke = std::max(leftStroke, std::round(rcTab.right) - 1.0f - halfWidth);
1592  	const XYPOSITION yMidAligned = ymid + halfWidth;
1593  	const Point arrowPoint(rightStroke, yMidAligned);
1594  	if (rightStroke > leftStroke) {
1595  		surface->LineDraw(Point(leftStroke, yMidAligned), arrowPoint, stroke);
1596  	}
1597  	if (vsDraw.tabDrawMode == TabDrawMode::LongArrow) {
1598  		XYPOSITION ydiff = std::floor(rcTab.Height() / 2.0f);
1599  		XYPOSITION xhead = rightStroke - ydiff;
1600  		if (xhead <= rcTab.left) {
1601  			ydiff -= rcTab.left - xhead;
1602  			xhead = rcTab.left;
1603  		}
1604  		const Point ptsHead[] = {
1605  			Point(xhead, yMidAligned - ydiff),
1606  			arrowPoint,
1607  			Point(xhead, yMidAligned + ydiff)
1608  		};
1609  		surface->PolyLine(ptsHead, std::size(ptsHead), stroke);
1610  	}
1611  }
1612  void DrawIndicator(int indicNum, Sci::Position startPos, Sci::Position endPos, Surface *surface, const ViewStyle &vsDraw,
1613  	const LineLayout *ll, int xStart, PRectangle rcLine, Sci::Position secondCharacter, int subLine, Indicator::State state,
1614  	int value, bool bidiEnabled, int tabWidthMinimumPixels) {
1615  	const XYPOSITION subLineStart = ll->positions[ll->LineStart(subLine)];
1616  	const XYPOSITION horizontalOffset = xStart - subLineStart;
1617  	std::vector<PRectangle> rectangles;
1618  	const XYPOSITION left = ll->XInLine(startPos) + horizontalOffset;
1619  	const XYPOSITION right = ll->XInLine(endPos) + horizontalOffset;
1620  	const PRectangle rcIndic(left, rcLine.top + vsDraw.maxAscent, right,
1621  		std::max(rcLine.top + vsDraw.maxAscent + 3, rcLine.bottom));
1622  	if (bidiEnabled) {
1623  		ScreenLine screenLine(ll, subLine, vsDraw, rcLine.right - xStart, tabWidthMinimumPixels);
1624  		const Range lineRange = ll->SubLineRange(subLine, LineLayout::Scope::visibleOnly);
1625  		std::unique_ptr<IScreenLineLayout> slLayout = surface->Layout(&screenLine);
1626  		std::vector<Interval> intervals = slLayout->FindRangeIntervals(
1627  			startPos - lineRange.start, endPos - lineRange.start);
1628  		for (const Interval &interval : intervals) {
1629  			PRectangle rcInterval = rcIndic;
1630  			rcInterval.left = interval.left + xStart;
1631  			rcInterval.right = interval.right + xStart;
1632  			rectangles.push_back(rcInterval);
1633  		}
1634  	} else {
1635  		rectangles.push_back(rcIndic);
1636  	}
1637  	for (const PRectangle &rc : rectangles) {
1638  		PRectangle rcFirstCharacter = rc;
1639  		rcFirstCharacter.bottom = rcLine.top + vsDraw.maxAscent + vsDraw.maxDescent;
1640  		if (secondCharacter >= 0) {
1641  			rcFirstCharacter.right = ll->XInLine(secondCharacter) + horizontalOffset;
1642  		} else {
1643  			rcFirstCharacter.right = rcFirstCharacter.left;
1644  		}
1645  		vsDraw.indicators[indicNum].Draw(surface, rc, rcLine, rcFirstCharacter, state, value);
1646  	}
1647  }
1648  void DrawIndicators(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
1649  	Sci::Line line, int xStart, PRectangle rcLine, int subLine, Sci::Position lineEnd, bool under, int tabWidthMinimumPixels) {
1650  	const Sci::Position posLineStart = model.pdoc->LineStart(line);
1651  	const Sci::Position lineStart = ll->LineStart(subLine);
1652  	const Sci::Position posLineEnd = posLineStart + lineEnd;
1653  	for (const IDecoration *deco : model.pdoc->decorations->View()) {
1654  		if (under == vsDraw.indicators[deco->Indicator()].under) {
1655  			Sci::Position startPos = posLineStart + lineStart;
1656  			while (startPos < posLineEnd) {
1657  				const Range rangeRun(deco->StartRun(startPos), deco->EndRun(startPos));
1658  				const Sci::Position endPos = std::min(rangeRun.end, posLineEnd);
1659  				const int value = deco->ValueAt(startPos);
1660  				if (value) {
1661  					const bool hover = vsDraw.indicators[deco->Indicator()].IsDynamic() &&
1662  						rangeRun.ContainsCharacter(model.hoverIndicatorPos);
1663  					const Indicator::State state = hover ? Indicator::State::hover : Indicator::State::normal;
1664  					const Sci::Position posSecond = model.pdoc->MovePositionOutsideChar(rangeRun.First() + 1, 1);
1665  					DrawIndicator(deco->Indicator(), startPos - posLineStart, endPos - posLineStart,
1666  						surface, vsDraw, ll, xStart, rcLine, posSecond - posLineStart, subLine, state,
1667  						value, model.BidirectionalEnabled(), tabWidthMinimumPixels);
1668  				}
1669  				startPos = endPos;
1670  			}
1671  		}
1672  	}
1673  	if ((vsDraw.braceHighlightIndicatorSet && (model.bracesMatchStyle == StyleBraceLight)) ||
1674  		(vsDraw.braceBadLightIndicatorSet && (model.bracesMatchStyle == StyleBraceBad))) {
1675  		const int braceIndicator = (model.bracesMatchStyle == StyleBraceLight) ? vsDraw.braceHighlightIndicator : vsDraw.braceBadLightIndicator;
1676  		if (under == vsDraw.indicators[braceIndicator].under) {
1677  			const Range rangeLine(posLineStart + lineStart, posLineEnd);
1678  			for (size_t brace = 0; brace <= 1; brace++) {
1679  				if (rangeLine.ContainsCharacter(model.braces[brace])) {
1680  					const Sci::Position braceOffset = model.braces[brace] - posLineStart;
1681  					if (braceOffset < ll->numCharsInLine) {
1682  						const Sci::Position braceEnd = model.pdoc->MovePositionOutsideChar(model.braces[brace] + 1, 1) - posLineStart;
1683  						DrawIndicator(braceIndicator, braceOffset, braceEnd,
1684  							surface, vsDraw, ll, xStart, rcLine, braceEnd, subLine, Indicator::State::normal,
1685  							1, model.BidirectionalEnabled(), tabWidthMinimumPixels);
1686  					}
1687  				}
1688  			}
1689  		}
1690  	}
1691  	if (FlagSet(model.changeHistoryOption, ChangeHistoryOption::Indicators)) {
1692  		constexpr int indexHistory = static_cast<int>(IndicatorNumbers::HistoryRevertedToOriginInsertion);
1693  		{
1694  			Sci::Position startPos = posLineStart + lineStart;
1695  			while (startPos < posLineEnd) {
1696  				const Range rangeRun(startPos, model.pdoc->EditionEndRun(startPos));
1697  				const Sci::Position endPos = std::min(rangeRun.end, posLineEnd);
1698  				const int edition = model.pdoc->EditionAt(startPos);
1699  				if (edition != 0) {
1700  					const int indicator = (edition - 1) * 2 + indexHistory;
1701  					const Sci::Position posSecond = model.pdoc->MovePositionOutsideChar(rangeRun.First() + 1, 1);
1702  					DrawIndicator(indicator, startPos - posLineStart, endPos - posLineStart,
1703  						surface, vsDraw, ll, xStart, rcLine, posSecond - posLineStart, subLine, Indicator::State::normal,
1704  						1, model.BidirectionalEnabled(), tabWidthMinimumPixels);
1705  				}
1706  				startPos = endPos;
1707  			}
1708  		}
1709  		{
1710  			Sci::Position startPos = posLineStart + lineStart;
1711  			while (startPos <= posLineEnd) {
1712  				const unsigned int editions = model.pdoc->EditionDeletesAt(startPos);
1713  				const Sci::Position posSecond = model.pdoc->MovePositionOutsideChar(startPos + 1, 1);
1714  				for (unsigned int edition = 0; edition < 4; edition++) {
1715  					if (editions & (1 << edition)) {
1716  						const int indicator = edition * 2 + indexHistory + 1;
1717  						DrawIndicator(indicator, startPos - posLineStart, posSecond - posLineStart,
1718  							surface, vsDraw, ll, xStart, rcLine, posSecond - posLineStart, subLine, Indicator::State::normal,
1719  							1, model.BidirectionalEnabled(), tabWidthMinimumPixels);
1720  					}
1721  				}
1722  				startPos = model.pdoc->EditionNextDelete(startPos);
1723  			}
1724  		}
1725  	}
1726  }
1727  void DrawFoldLines(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
1728  	Sci::Line line, PRectangle rcLine, int subLine) {
1729  	const bool lastSubLine = subLine == (ll->lines - 1);
1730  	const bool expanded = model.pcs->GetExpanded(line);
1731  	const FoldLevel level = model.pdoc->GetFoldLevel(line);
1732  	const FoldLevel levelNext = model.pdoc->GetFoldLevel(line + 1);
1733  	if (LevelIsHeader(level) &&
1734  		(LevelNumber(level) < LevelNumber(levelNext))) {
1735  		const ColourRGBA foldLineColour = vsDraw.ElementColour(Element::FoldLine).value_or(
1736  			vsDraw.styles[StyleDefault].fore);
1737  		if ((subLine == 0) &&
1738  			((expanded && (FlagSet(model.foldFlags, FoldFlag::LineBeforeExpanded)))
1739  				||
1740  				(!expanded && (FlagSet(model.foldFlags, FoldFlag::LineBeforeContracted))))) {
1741  			surface->FillRectangleAligned(Side(rcLine, Edge::top, 1.0), foldLineColour);
1742  		}
1743  		if (lastSubLine &&
1744  			((expanded && (FlagSet(model.foldFlags, FoldFlag::LineAfterExpanded)))
1745  				||
1746  				(!expanded && (FlagSet(model.foldFlags, FoldFlag::LineAfterContracted))))) {
1747  			surface->FillRectangleAligned(Side(rcLine, Edge::bottom, 1.0), foldLineColour);
1748  			if (!expanded) {
1749  				return;
1750  			}
1751  		}
1752  	}
1753  	if (lastSubLine && model.pcs->GetVisible(line) && !model.pcs->GetVisible(line + 1)) {
1754  		if (const ColourOptional hiddenLineColour = vsDraw.ElementColour(Element::HiddenLine)) {
1755  			surface->FillRectangleAligned(Side(rcLine, Edge::bottom, 1.0), *hiddenLineColour);
1756  		}
1757  	}
1758  }
1759  ColourRGBA InvertedLight(ColourRGBA orig) noexcept {
1760  	unsigned int r = orig.GetRed();
1761  	unsigned int g = orig.GetGreen();
1762  	unsigned int b = orig.GetBlue();
1763  	const unsigned int l = (r + g + b) / 3; 	
1764  	const unsigned int il = 0xff - l;
1765  	if (l == 0)
1766  		return ColourRGBA(0xff, 0xff, 0xff);
1767  	r = r * il / l;
1768  	g = g * il / l;
1769  	b = b * il / l;
1770  	return ColourRGBA(std::min(r, 0xffu), std::min(g, 0xffu), std::min(b, 0xffu));
1771  }
1772  }
1773  void EditView::DrawIndentGuide(Surface *surface, XYPOSITION start, PRectangle rcSegment, bool highlight, bool offset) {
1774  	const Point from = Point::FromInts(0, offset ? 1 : 0);
1775  	const PRectangle rcCopyArea(start + 1, rcSegment.top,
1776  		start + 2, rcSegment.bottom);
1777  	surface->Copy(rcCopyArea, from,
1778  		highlight ? *pixmapIndentGuideHighlight : *pixmapIndentGuide);
1779  }
1780  void EditView::DrawForeground(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
1781  	int xStart, PRectangle rcLine, int subLine, Sci::Line lineVisible, Range lineRange, Sci::Position posLineStart,
1782  	ColourOptional background) {
1783  	const bool selBackDrawn = vsDraw.SelectionBackgroundDrawn();
1784  	const bool drawWhitespaceBackground = vsDraw.WhitespaceBackgroundDrawn() && !background;
1785  	bool inIndentation = subLine == 0;	
1786  	const XYPOSITION subLineStart = ll->positions[lineRange.start];
1787  	const XYPOSITION horizontalOffset = xStart - subLineStart;
1788  	const XYPOSITION indentWidth = model.pdoc->IndentSize() * vsDraw.spaceWidth;
1789  	const XYPOSITION xStartVisible = subLineStart - xStart;
1790  	const bool offsetGuide = (lineVisible & 1) && (vsDraw.lineHeight & 1);
1791  	const XYPOSITION ybase = rcLine.top + vsDraw.maxAscent;
1792  	const BreakFinder::BreakFor breakFor = (((phasesDraw == PhasesDraw::One) && selBackDrawn) || vsDraw.SelectionTextDrawn())
1793  		? BreakFinder::BreakFor::ForegroundAndSelection : BreakFinder::BreakFor::Foreground;
1794  	BreakFinder bfFore(ll, &model.sel, lineRange, posLineStart, xStartVisible, breakFor, model.pdoc, &model.reprs, &vsDraw);
1795  	while (bfFore.More()) {
1796  		const TextSegment ts = bfFore.Next();
1797  		const Sci::Position i = ts.end() - 1;
1798  		const Sci::Position iDoc = i + posLineStart;
1799  		const Interval horizontal = ll->Span(ts.start, ts.end()).Offset(horizontalOffset);
1800  		if (rcLine.Intersects(horizontal)) {
1801  			const PRectangle rcSegment = rcLine.WithHorizontalBounds(horizontal);
1802  			const int styleMain = ll->styles[i];
1803  			ColourRGBA textFore = vsDraw.styles[styleMain].fore;
1804  			const Font *textFont = vsDraw.styles[styleMain].font.get();
1805  			const bool inHotspot = model.hotspot.Valid() && model.hotspot.ContainsCharacter(iDoc);
1806  			if (inHotspot) {
1807  				if (const ColourOptional colourHotSpot = vsDraw.ElementColour(Element::HotSpotActive)) {
1808  					textFore = *colourHotSpot;
1809  				}
1810  			}
1811  			if (vsDraw.indicatorsSetFore) {
1812  				for (const IDecoration *deco : model.pdoc->decorations->View()) {
1813  					const int indicatorValue = deco->ValueAt(ts.start + posLineStart);
1814  					if (indicatorValue) {
1815  						const Indicator &indicator = vsDraw.indicators[deco->Indicator()];
1816  						bool hover = false;
1817  						if (indicator.IsDynamic()) {
1818  							const Sci::Position startPos = ts.start + posLineStart;
1819  							const Range rangeRun(deco->StartRun(startPos), deco->EndRun(startPos));
1820  							hover =	rangeRun.ContainsCharacter(model.hoverIndicatorPos);
1821  						}
1822  						if (hover) {
1823  							if (indicator.sacHover.style == IndicatorStyle::TextFore || (indicator.sacHover.style == IndicatorStyle::ExplorerLink)) {
1824  								textFore = indicator.sacHover.fore;
1825  							}
1826  						} else {
1827  							if (indicator.sacNormal.style == IndicatorStyle::TextFore) {
1828  								if (FlagSet(indicator.Flags(), IndicFlag::ValueFore))
1829  									textFore = ColourRGBA::FromRGB(indicatorValue & static_cast<int>(IndicValue::Mask));
1830  								else
1831  									textFore = indicator.sacNormal.fore;
1832  							}
1833  						}
1834  					}
1835  				}
1836  			}
1837  			InSelection inSelection = vsDraw.selection.visible ? model.sel.CharacterInSelection(iDoc) : InSelection::inNone;
1838  			if (FlagSet(vsDraw.caret.style, CaretStyle::Curses) && (inSelection == InSelection::inMain))
1839  				inSelection = CharacterInCursesSelection(iDoc, model, vsDraw);
1840  			if (const ColourOptional selectionFore = SelectionForeground(model, vsDraw, inSelection)) {
1841  				textFore = *selectionFore;
1842  			}
1843  			ColourRGBA textBack = TextBackground(model, vsDraw, ll, background, inSelection, inHotspot, styleMain, i);
1844  			if (ts.representation) {
1845  				if (ll->chars[i] == '\t') {
1846  					if (phasesDraw == PhasesDraw::One) {
1847  						if (drawWhitespaceBackground && vsDraw.WhiteSpaceVisible(inIndentation))
1848  							textBack = vsDraw.ElementColourForced(Element::WhiteSpaceBack).Opaque();
1849  						surface->FillRectangleAligned(rcSegment, Fill(textBack));
1850  					}
1851  					if (inIndentation && vsDraw.viewIndentationGuides == IndentView::Real) {
1852  						const Interval intervalCharacter = ll->SpanByte(static_cast<int>(i));
1853  						for (int indentCount = static_cast<int>((intervalCharacter.left + epsilon) / indentWidth);
1854  							indentCount <= (intervalCharacter.right - epsilon) / indentWidth;
1855  							indentCount++) {
1856  							if (indentCount > 0) {
1857  								const XYPOSITION xIndent = std::floor(indentCount * indentWidth);
1858  								DrawIndentGuide(surface, xIndent + xStart, rcSegment, ll->xHighlightGuide == xIndent, offsetGuide);
1859  							}
1860  						}
1861  					}
1862  					if (vsDraw.viewWhitespace != WhiteSpace::Invisible) {
1863  						if (vsDraw.WhiteSpaceVisible(inIndentation)) {
1864  							const PRectangle rcTab(rcSegment.left + 1, rcSegment.top + tabArrowHeight,
1865  								rcSegment.right - 1, rcSegment.bottom - vsDraw.maxDescent);
1866  							const int segmentTop = static_cast<int>(rcSegment.top) + vsDraw.lineHeight / 2;
1867  							const ColourRGBA whiteSpaceFore = vsDraw.ElementColour(Element::WhiteSpace).value_or(textFore);
1868  							if (!customDrawTabArrow)
1869  								DrawTabArrow(surface, rcTab, segmentTop, vsDraw, Stroke(whiteSpaceFore, 1.0f));
1870  							else
1871  								customDrawTabArrow(surface, rcTab, segmentTop, vsDraw, Stroke(whiteSpaceFore, 1.0f));
1872  						}
1873  					}
1874  				} else {
1875  					inIndentation = false;
1876  					if (vsDraw.controlCharSymbol >= 32) {
1877  						const Font *ctrlCharsFont = vsDraw.styles[StyleControlChar].font.get();
1878  						const char cc[2] = { static_cast<char>(vsDraw.controlCharSymbol), '\0' };
1879  						surface->DrawTextNoClip(rcSegment, ctrlCharsFont,
1880  							ybase, cc, textBack, textFore);
1881  					} else {
1882  						if (FlagSet(ts.representation->appearance, RepresentationAppearance::Colour)) {
1883  							textFore = ts.representation->colour;
1884  						}
1885  						if (FlagSet(ts.representation->appearance, RepresentationAppearance::Blob)) {
1886  							DrawTextBlob(surface, vsDraw, rcSegment, ts.representation->stringRep,
1887  								textBack, textFore, phasesDraw == PhasesDraw::One);
1888  						} else {
1889  							surface->DrawTextTransparentUTF8(rcSegment, vsDraw.styles[StyleControlChar].font.get(),
1890  								ybase, ts.representation->stringRep, textFore);
1891  						}
1892  					}
1893  				}
1894  			} else {
1895  				if (vsDraw.styles[styleMain].visible) {
1896  					const std::string_view text(&ll->chars[ts.start], i - ts.start + 1);
1897  					if (phasesDraw != PhasesDraw::One) {
1898  						surface->DrawTextTransparent(rcSegment, textFont,
1899  							ybase, text, textFore);
1900  					} else {
1901  						surface->DrawTextNoClip(rcSegment, textFont,
1902  							ybase, text, textFore, textBack);
1903  					}
1904  				} else if (vsDraw.styles[styleMain].invisibleRepresentation[0]) {
1905  					const std::string_view text = vsDraw.styles[styleMain].invisibleRepresentation;
1906    					if (phasesDraw != PhasesDraw::One) {
1907  						surface->DrawTextTransparentUTF8(rcSegment, textFont,
1908  							ybase, text, textFore);
1909  					} else {
1910  						surface->DrawTextNoClipUTF8(rcSegment, textFont,
1911  							ybase, text, textFore, textBack);
1912  					}
1913  				}
1914  				if (vsDraw.viewWhitespace != WhiteSpace::Invisible ||
1915  					(inIndentation && vsDraw.viewIndentationGuides != IndentView::None)) {
1916  					for (int cpos = 0; cpos <= i - ts.start; cpos++) {
1917  						if (ll->chars[cpos + ts.start] == ' ') {
1918  							if (vsDraw.viewWhitespace != WhiteSpace::Invisible) {
1919  								if (vsDraw.WhiteSpaceVisible(inIndentation)) {
1920  									const Interval intervalSpace = ll->SpanByte(cpos + ts.start).Offset(horizontalOffset);
1921  									const XYPOSITION xmid = (intervalSpace.left + intervalSpace.right) / 2;
1922  									if ((phasesDraw == PhasesDraw::One) && drawWhitespaceBackground) {
1923  										textBack = vsDraw.ElementColourForced(Element::WhiteSpaceBack).Opaque();
1924  										const PRectangle rcSpace = rcLine.WithHorizontalBounds(intervalSpace);
1925  										surface->FillRectangleAligned(rcSpace, Fill(textBack));
1926  									}
1927  									const int halfDotWidth = vsDraw.whitespaceSize / 2;
1928  									PRectangle rcDot(xmid - halfDotWidth,
1929  										rcSegment.top + vsDraw.lineHeight / 2, 0.0f, 0.0f);
1930  									rcDot.right = rcDot.left + vsDraw.whitespaceSize;
1931  									rcDot.bottom = rcDot.top + vsDraw.whitespaceSize;
1932  									const ColourRGBA whiteSpaceFore = vsDraw.ElementColour(Element::WhiteSpace).value_or(textFore);
1933  									surface->FillRectangleAligned(rcDot, Fill(whiteSpaceFore));
1934  								}
1935  							}
1936  							if (inIndentation && vsDraw.viewIndentationGuides == IndentView::Real) {
1937  								const Interval intervalCharacter = ll->SpanByte(cpos + ts.start);
1938  								for (int indentCount = static_cast<int>((intervalCharacter.left + epsilon) / indentWidth);
1939  									indentCount <= (intervalCharacter.right - epsilon) / indentWidth;
1940  									indentCount++) {
1941  									if (indentCount > 0) {
1942  										const XYPOSITION xIndent = std::floor(indentCount * indentWidth);
1943  										DrawIndentGuide(surface, xIndent + xStart, rcSegment, ll->xHighlightGuide == xIndent, offsetGuide);
1944  									}
1945  								}
1946  							}
1947  						} else {
1948  							inIndentation = false;
1949  						}
1950  					}
1951  				}
1952  			}
1953  			if ((inHotspot && vsDraw.hotspotUnderline) || vsDraw.styles[styleMain].underline) {
1954  				PRectangle rcUL = rcSegment;
1955  				rcUL.top = ybase + 1;
1956  				rcUL.bottom = ybase + 2;
1957  				ColourRGBA colourUnderline = textFore;
1958  				if (inHotspot && vsDraw.hotspotUnderline) {
1959  					colourUnderline = vsDraw.ElementColour(Element::HotSpotActive).value_or(textFore);
1960  				}
1961  				surface->FillRectangleAligned(rcUL, colourUnderline);
1962  			}
1963  		} else if (horizontal.left > rcLine.right) {
1964  			break;
1965  		}
1966  	}
1967  }
1968  void EditView::DrawIndentGuidesOverEmpty(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
1969  	Sci::Line line, int xStart, PRectangle rcLine, int subLine, Sci::Line lineVisible) {
1970  	if ((vsDraw.viewIndentationGuides == IndentView::LookForward || vsDraw.viewIndentationGuides == IndentView::LookBoth)
1971  		&& (subLine == 0)) {
1972  		const Sci::Position posLineStart = model.pdoc->LineStart(line);
1973  		int indentSpace = model.pdoc->GetLineIndentation(line);
1974  		int xStartText = static_cast<int>(ll->positions[model.pdoc->GetLineIndentPosition(line) - posLineStart]);
1975  		Sci::Line lineLastWithText = line;
1976  		while (lineLastWithText > std::max(line - 20, static_cast<Sci::Line>(0)) && model.pdoc->IsWhiteLine(lineLastWithText)) {
1977  			lineLastWithText--;
1978  		}
1979  		if (lineLastWithText < line) {
1980  			xStartText = 100000;	
1981  			int indentLastWithText = model.pdoc->GetLineIndentation(lineLastWithText);
1982  			const int isFoldHeader = LevelIsHeader(model.pdoc->GetFoldLevel(lineLastWithText));
1983  			if (isFoldHeader) {
1984  				indentLastWithText += model.pdoc->IndentSize();
1985  			}
1986  			if (vsDraw.viewIndentationGuides == IndentView::LookForward) {
1987  				if (isFoldHeader) {
1988  					indentSpace = std::max(indentSpace, indentLastWithText);
1989  				}
1990  			} else {	
1991  				indentSpace = std::max(indentSpace, indentLastWithText);
1992  			}
1993  		}
1994  		Sci::Line lineNextWithText = line;
1995  		while (lineNextWithText < std::min(line + 20, model.pdoc->LinesTotal()) && model.pdoc->IsWhiteLine(lineNextWithText)) {
1996  			lineNextWithText++;
1997  		}
1998  		if (lineNextWithText > line) {
1999  			xStartText = 100000;	
2000  			indentSpace = std::max(indentSpace,
2001  				model.pdoc->GetLineIndentation(lineNextWithText));
2002  		}
2003  		const bool offsetGuide = (lineVisible & 1) && (vsDraw.lineHeight & 1);
2004  		for (int indentPos = model.pdoc->IndentSize(); indentPos < indentSpace; indentPos += model.pdoc->IndentSize()) {
2005  			const XYPOSITION xIndent = std::floor(indentPos * vsDraw.spaceWidth);
2006  			if (xIndent < xStartText) {
2007  				DrawIndentGuide(surface, xIndent + xStart, rcLine,	ll->xHighlightGuide == xIndent, offsetGuide);
2008  			}
2009  		}
2010  	}
2011  }
2012  void EditView::DrawLine(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
2013  	Sci::Line line, Sci::Line lineVisible, int xStart, PRectangle rcLine, int subLine, DrawPhase phase) {
2014  	if (subLine >= ll->lines) {
2015  		DrawAnnotation(surface, model, vsDraw, ll, line, xStart, rcLine, subLine, phase);
2016  		return; 
2017  	}
2018  	const bool clipLine = !bufferedDraw && !LinesOverlap();
2019  	if (clipLine) {
2020  		surface->SetClip(rcLine);
2021  	}
2022  	const ColourOptional background = vsDraw.Background(model.GetMark(line), model.caret.active, ll->containsCaret);
2023  	const Sci::Position posLineStart = model.pdoc->LineStart(line);
2024  	const Range lineRange = ll->SubLineRange(subLine, LineLayout::Scope::visibleOnly);
2025  	const Range lineRangeIncludingEnd = ll->SubLineRange(subLine, LineLayout::Scope::includeEnd);
2026  	const XYPOSITION subLineStart = ll->positions[lineRange.start];
2027  	if ((ll->wrapIndent != 0) && (subLine > 0)) {
2028  		if (FlagSet(phase, DrawPhase::back)) {
2029  			DrawWrapIndentAndMarker(surface, vsDraw, ll, xStart, rcLine, background, customDrawWrapMarker, model.caret.active);
2030  		}
2031  		xStart += static_cast<int>(ll->wrapIndent);
2032  	}
2033  	if (phasesDraw != PhasesDraw::One) {
2034  		if (FlagSet(phase, DrawPhase::back)) {
2035  			DrawBackground(surface, model, vsDraw, ll,
2036  				xStart, rcLine, subLine, lineRange, posLineStart,
2037  				background);
2038  			DrawFoldDisplayText(surface, model, vsDraw, ll, line, xStart, rcLine, subLine, subLineStart, DrawPhase::back);
2039  			DrawEOLAnnotationText(surface, model, vsDraw, ll, line, xStart, rcLine, subLine, subLineStart, DrawPhase::back);
2040  			phase = static_cast<DrawPhase>(static_cast<int>(phase) & ~static_cast<int>(DrawPhase::back));
2041  			DrawEOL(surface, model, vsDraw, ll,
2042  				line, xStart, rcLine, subLine, lineRange.end, subLineStart, background);
2043  			if (vsDraw.IsLineFrameOpaque(model.caret.active, ll->containsCaret))
2044  				DrawCaretLineFramed(surface, vsDraw, ll, rcLine, subLine);
2045  		}
2046  		if (FlagSet(phase, DrawPhase::indicatorsBack)) {
2047  			DrawIndicators(surface, model, vsDraw, ll, line, xStart, rcLine, subLine,
2048  				lineRangeIncludingEnd.end, true, tabWidthMinimumPixels);
2049  			DrawEdgeLine(surface, vsDraw, ll, xStart, rcLine, lineRange);
2050  			DrawMarkUnderline(surface, model, vsDraw, line, rcLine);
2051  		}
2052  	}
2053  	if (FlagSet(phase, DrawPhase::text)) {
2054  		if (vsDraw.selection.visible) {
2055  			DrawTranslucentSelection(surface, model, vsDraw, ll,
2056  				line, xStart, rcLine, subLine, lineRange, tabWidthMinimumPixels, Layer::UnderText);
2057  		}
2058  		DrawTranslucentLineState(surface, model, vsDraw, ll, line, rcLine, subLine, Layer::UnderText);
2059  		DrawForeground(surface, model, vsDraw, ll,
2060  			xStart, rcLine, subLine, lineVisible, lineRange, posLineStart,
2061  			background);
2062  	}
2063  	if (FlagSet(phase, DrawPhase::indentationGuides)) {
2064  		DrawIndentGuidesOverEmpty(surface, model, vsDraw, ll, line, xStart, rcLine, subLine, lineVisible);
2065  	}
2066  	if (FlagSet(phase, DrawPhase::indicatorsFore)) {
2067  		DrawIndicators(surface, model, vsDraw, ll, line, xStart, rcLine, subLine,
2068  			lineRangeIncludingEnd.end, false, tabWidthMinimumPixels);
2069  	}
2070  	DrawFoldDisplayText(surface, model, vsDraw, ll, line, xStart, rcLine, subLine, subLineStart, phase);
2071  	DrawEOLAnnotationText(surface, model, vsDraw, ll, line, xStart, rcLine, subLine, subLineStart, phase);
2072  	if (phasesDraw == PhasesDraw::One) {
2073  		DrawEOL(surface, model, vsDraw, ll,
2074  			line, xStart, rcLine, subLine, lineRange.end, subLineStart, background);
2075  		if (vsDraw.IsLineFrameOpaque(model.caret.active, ll->containsCaret))
2076  			DrawCaretLineFramed(surface, vsDraw, ll, rcLine, subLine);
2077  		DrawEdgeLine(surface, vsDraw, ll, xStart, rcLine, lineRange);
2078  		DrawMarkUnderline(surface, model, vsDraw, line, rcLine);
2079  	}
2080  	if (vsDraw.selection.visible && FlagSet(phase, DrawPhase::selectionTranslucent)) {
2081  		DrawTranslucentSelection(surface, model, vsDraw, ll,
2082  			line, xStart, rcLine, subLine, lineRange, tabWidthMinimumPixels, Layer::OverText);
2083  	}
2084  	if (FlagSet(phase, DrawPhase::lineTranslucent)) {
2085  		DrawTranslucentLineState(surface, model, vsDraw, ll, line, rcLine, subLine, Layer::OverText);
2086  	}
2087  	if (clipLine) {
2088  		surface->PopClip();
2089  	}
2090  }
2091  void EditView::PaintText(Surface *surfaceWindow, const EditModel &model, const ViewStyle &vsDraw,
2092  	PRectangle rcArea, PRectangle rcClient) {
2093  	const int leftTextOverlap = ((model.xOffset == 0) && (vsDraw.leftMarginWidth > 0)) ? 1 : 0;
2094  	if (rcArea.right > vsDraw.textStart - leftTextOverlap) {
2095  		Surface *surface = surfaceWindow;
2096  		if (bufferedDraw) {
2097  			surface = pixmapLine.get();
2098  			PLATFORM_ASSERT(pixmapLine->Initialised());
2099  		}
2100  		surface->SetMode(model.CurrentSurfaceMode());
2101  		const Point ptOrigin = model.GetVisibleOriginInMain();
2102  		const int screenLinePaintFirst = static_cast<int>(rcArea.top) / vsDraw.lineHeight;
2103  		const int xStart = vsDraw.textStart - model.xOffset + static_cast<int>(ptOrigin.x);
2104  		const SelectionPosition posCaret = model.posDrag.IsValid() ? model.posDrag : model.sel.RangeMain().caret;
2105  		const Sci::Line lineCaret = model.pdoc->SciLineFromPosition(posCaret.Position());
2106  		const int caretOffset = static_cast<int>(posCaret.Position() - model.pdoc->LineStart(lineCaret));
2107  		PRectangle rcTextArea = rcClient;
2108  		if (vsDraw.marginInside) {
2109  			rcTextArea.left += vsDraw.textStart;
2110  			rcTextArea.right -= vsDraw.rightMarginWidth;
2111  		} else {
2112  			rcTextArea = rcArea;
2113  		}
2114  		const bool clipping = !bufferedDraw && vsDraw.marginInside;
2115  		if (clipping) {
2116  			PRectangle rcClipText = rcTextArea;
2117  			rcClipText.left -= leftTextOverlap;
2118  			surfaceWindow->SetClip(rcClipText);
2119  		}
2120  #if defined(TIME_PAINTING)
2121  		double durLayout = 0.0;
2122  		double durPaint = 0.0;
2123  		double durCopy = 0.0;
2124  		ElapsedPeriod epWhole;
2125  #endif
2126  		const bool bracesIgnoreStyle = ((vsDraw.braceHighlightIndicatorSet && (model.bracesMatchStyle == StyleBraceLight)) ||
2127  			(vsDraw.braceBadLightIndicatorSet && (model.bracesMatchStyle == StyleBraceBad)));
2128  		Sci::Line lineDocPrevious = -1;	
2129  		std::shared_ptr<LineLayout> ll;
2130  		std::vector<DrawPhase> phases;
2131  		if ((phasesDraw == PhasesDraw::Multiple) && !bufferedDraw) {
2132  			for (DrawPhase phase = DrawPhase::back; phase <= DrawPhase::carets; phase = static_cast<DrawPhase>(static_cast<int>(phase) * 2)) {
2133  				phases.push_back(phase);
2134  			}
2135  		} else {
2136  			phases.push_back(DrawPhase::all);
2137  		}
2138  		for (const DrawPhase &phase : phases) {
2139  			int ypos = 0;
2140  			if (!bufferedDraw)
2141  				ypos += screenLinePaintFirst * vsDraw.lineHeight;
2142  			int yposScreen = screenLinePaintFirst * vsDraw.lineHeight;
2143  			Sci::Line visibleLine = model.TopLineOfMain() + screenLinePaintFirst;
2144  			while (visibleLine < model.pcs->LinesDisplayed() && yposScreen < rcArea.bottom) {
2145  				const Sci::Line lineDoc = model.pcs->DocFromDisplay(visibleLine);
2146  				PLATFORM_ASSERT(model.pcs->GetVisible(lineDoc));
2147  				const Sci::Line lineStartSet = model.pcs->DisplayFromDoc(lineDoc);
2148  				const int subLine = static_cast<int>(visibleLine - lineStartSet);
2149  #if defined(TIME_PAINTING)
2150  				ElapsedPeriod ep;
2151  #endif
2152  				if (lineDoc != lineDocPrevious) {
2153  					ll = RetrieveLineLayout(lineDoc, model);
2154  					LayoutLine(model, surface, vsDraw, ll.get(), model.wrapWidth);
2155  					lineDocPrevious = lineDoc;
2156  				}
2157  #if defined(TIME_PAINTING)
2158  				durLayout += ep.Duration(true);
2159  #endif
2160  				if (ll) {
2161  					ll->containsCaret = vsDraw.selection.visible && (lineDoc == lineCaret)
2162  						&& (ll->lines == 1 || !vsDraw.caretLine.subLine || ll->InLine(caretOffset, subLine));
<span onclick='openModal()' class='match'>2163  					PRectangle rcLine = rcTextArea;
2164  					rcLine.top = static_cast<XYPOSITION>(ypos);
2165  					rcLine.bottom = static_cast<XYPOSITION>(ypos + vsDraw.lineHeight);
</span>2166  					const Range rangeLine(model.pdoc->LineStart(lineDoc),
2167  						model.pdoc->LineStart(lineDoc + 1));
2168  					ll->SetBracesHighlight(rangeLine, model.braces, static_cast<char>(model.bracesMatchStyle),
2169  						static_cast<int>(model.highlightGuideColumn * vsDraw.spaceWidth), bracesIgnoreStyle);
2170  					if (leftTextOverlap && (bufferedDraw || ((phasesDraw < PhasesDraw::Multiple) && (FlagSet(phase, DrawPhase::back))))) {
2171  						PRectangle rcSpacer = rcLine;
2172  						rcSpacer.right = rcSpacer.left;
2173  						rcSpacer.left -= 1;
2174  						surface->FillRectangleAligned(rcSpacer, Fill(vsDraw.styles[StyleDefault].back));
2175  					}
2176  					if (model.BidirectionalEnabled()) {
2177  						UpdateBidiData(model, vsDraw, ll.get());
2178  					}
2179  					DrawLine(surface, model, vsDraw, ll.get(), lineDoc, visibleLine, xStart, rcLine, subLine, phase);
2180  #if defined(TIME_PAINTING)
2181  					durPaint += ep.Duration(true);
2182  #endif
2183  					ll->RestoreBracesHighlight(rangeLine, model.braces, bracesIgnoreStyle);
2184  					if (FlagSet(phase, DrawPhase::foldLines)) {
2185  						DrawFoldLines(surface, model, vsDraw, ll.get(), lineDoc, rcLine, subLine);
2186  					}
2187  					if (FlagSet(phase, DrawPhase::carets)) {
2188  						DrawCarets(surface, model, vsDraw, ll.get(), lineDoc, xStart, rcLine, subLine);
2189  					}
2190  					if (bufferedDraw) {
2191  						const Point from = Point::FromInts(vsDraw.textStart - leftTextOverlap, 0);
2192  						const PRectangle rcCopyArea = PRectangle::FromInts(vsDraw.textStart - leftTextOverlap, yposScreen,
2193  							static_cast<int>(rcClient.right - vsDraw.rightMarginWidth),
2194  							yposScreen + vsDraw.lineHeight);
2195  						pixmapLine->FlushDrawing();
2196  						surfaceWindow->Copy(rcCopyArea, from, *pixmapLine);
2197  					}
2198  					lineWidthMaxSeen = std::max(
2199  						lineWidthMaxSeen, static_cast<int>(ll->positions[ll->numCharsInLine]));
2200  #if defined(TIME_PAINTING)
2201  					durCopy += ep.Duration(true);
2202  #endif
2203  				}
2204  				if (!bufferedDraw) {
2205  					ypos += vsDraw.lineHeight;
2206  				}
2207  				yposScreen += vsDraw.lineHeight;
2208  				visibleLine++;
2209  			}
2210  		}
2211  		ll.reset();
2212  #if defined(TIME_PAINTING)
2213  		if (durPaint < 0.00000001)
2214  			durPaint = 0.00000001;
2215  #endif
2216  		PRectangle rcBeyondEOF = (vsDraw.marginInside) ? rcClient : rcArea;
2217  		rcBeyondEOF.left = static_cast<XYPOSITION>(vsDraw.textStart);
2218  		rcBeyondEOF.right = rcBeyondEOF.right - ((vsDraw.marginInside) ? vsDraw.rightMarginWidth : 0);
2219  		rcBeyondEOF.top = static_cast<XYPOSITION>((model.pcs->LinesDisplayed() - model.TopLineOfMain()) * vsDraw.lineHeight);
2220  		if (rcBeyondEOF.top < rcBeyondEOF.bottom) {
2221  			surfaceWindow->FillRectangleAligned(rcBeyondEOF, Fill(vsDraw.styles[StyleDefault].back));
2222  			if (vsDraw.edgeState == EdgeVisualStyle::Line) {
2223  				const int edgeX = static_cast<int>(vsDraw.theEdge.column * vsDraw.spaceWidth);
2224  				rcBeyondEOF.left = static_cast<XYPOSITION>(edgeX + xStart);
2225  				rcBeyondEOF.right = rcBeyondEOF.left + 1;
2226  				surfaceWindow->FillRectangleAligned(rcBeyondEOF, Fill(vsDraw.theEdge.colour));
2227  			} else if (vsDraw.edgeState == EdgeVisualStyle::MultiLine) {
2228  				for (size_t edge = 0; edge < vsDraw.theMultiEdge.size(); edge++) {
2229  					if (vsDraw.theMultiEdge[edge].column >= 0) {
2230  						const int edgeX = static_cast<int>(vsDraw.theMultiEdge[edge].column * vsDraw.spaceWidth);
2231  						rcBeyondEOF.left = static_cast<XYPOSITION>(edgeX + xStart);
2232  						rcBeyondEOF.right = rcBeyondEOF.left + 1;
2233  						surfaceWindow->FillRectangleAligned(rcBeyondEOF, Fill(vsDraw.theMultiEdge[edge].colour));
2234  					}
2235  				}
2236  			}
2237  		}
2238  		if (clipping)
2239  			surfaceWindow->PopClip();
2240  #if defined(TIME_PAINTING)
2241  		Platform::DebugPrintf(
2242  		"Layout:%9.6g    Paint:%9.6g    Ratio:%9.6g   Copy:%9.6g   Total:%9.6g\n",
2243  		durLayout, durPaint, durLayout / durPaint, durCopy, epWhole.Duration());
2244  #endif
2245  	}
2246  }
2247  #define lineNumberPrintSpace "   "
2248  Sci::Position EditView::FormatRange(bool draw, CharacterRangeFull chrg, Rectangle rc, Surface *surface, Surface *surfaceMeasure,
2249  	const EditModel &model, const ViewStyle &vs) {
2250  	posCache->Clear();
2251  	ViewStyle vsPrint(vs);
2252  	vsPrint.technology = Technology::Default;
2253  	int lineNumberIndex = -1;
2254  	for (size_t margin = 0; margin < vs.ms.size(); margin++) {
2255  		if ((vsPrint.ms[margin].style == MarginType::Number) && (vsPrint.ms[margin].width > 0)) {
2256  			lineNumberIndex = static_cast<int>(margin);
2257  		} else {
2258  			vsPrint.ms[margin].width = 0;
2259  		}
2260  	}
2261  	vsPrint.fixedColumnWidth = 0;
2262  	vsPrint.zoomLevel = printParameters.magnification;
2263  	vsPrint.viewIndentationGuides = IndentView::None;
2264  	vsPrint.selection.visible = false;
2265  	vsPrint.elementColours.clear();
2266  	vsPrint.elementBaseColours.clear();
2267  	vsPrint.caretLine.alwaysShow = false;
2268  	vsPrint.braceHighlightIndicatorSet = false;
2269  	vsPrint.braceBadLightIndicatorSet = false;
2270  	const PrintOption colourMode = printParameters.colourMode;
2271  	const std::vector<Style>::iterator endStyles = (colourMode == PrintOption::ColourOnWhiteDefaultBG) ?
2272  		vsPrint.styles.begin() + StyleLineNumber : vsPrint.styles.end();
2273  	for (std::vector<Style>::iterator it = vsPrint.styles.begin(); it != endStyles; ++it) {
2274  		if (colourMode == PrintOption::InvertLight) {
2275  			it->fore = InvertedLight(it->fore);
2276  			it->back = InvertedLight(it->back);
2277  		} else if (colourMode == PrintOption::BlackOnWhite) {
2278  			it->fore = ColourRGBA(0, 0, 0);
2279  			it->back = ColourRGBA(0xff, 0xff, 0xff);
2280  		} else if (colourMode == PrintOption::ColourOnWhite || colourMode == PrintOption::ColourOnWhiteDefaultBG) {
2281  			it->back = ColourRGBA(0xff, 0xff, 0xff);
2282  		}
2283  	}
2284  	if (colourMode != PrintOption::ScreenColours) {
2285  		vsPrint.styles[StyleLineNumber].back = ColourRGBA(0xff, 0xff, 0xff);
2286  	}
2287  	vsPrint.leftMarginWidth = 0;
2288  	vsPrint.rightMarginWidth = 0;
2289  	vsPrint.Refresh(*surfaceMeasure, model.pdoc->tabInChars);
2290  	int lineNumberWidth = 0;
2291  	if (lineNumberIndex >= 0) {
2292  		lineNumberWidth = static_cast<int>(surfaceMeasure->WidthText(vsPrint.styles[StyleLineNumber].font.get(),
2293  			"99999" lineNumberPrintSpace));
2294  		vsPrint.ms[lineNumberIndex].width = lineNumberWidth;
2295  		vsPrint.Refresh(*surfaceMeasure, model.pdoc->tabInChars);	
2296  	}
2297  	constexpr unsigned int changeMarkers =
2298  		1u << static_cast<unsigned int>(MarkerOutline::HistoryRevertedToOrigin) |
2299  		1u << static_cast<unsigned int>(MarkerOutline::HistorySaved) |
2300  		1u << static_cast<unsigned int>(MarkerOutline::HistoryModified) |
2301  		1u << static_cast<unsigned int>(MarkerOutline::HistoryRevertedToModified);
2302  	vsPrint.maskInLine &= ~changeMarkers;
2303  	const Sci::Line linePrintStart = model.pdoc->SciLineFromPosition(chrg.cpMin);
2304  	Sci::Line linePrintLast = linePrintStart + (rc.bottom - rc.top) / vsPrint.lineHeight - 1;
2305  	if (linePrintLast < linePrintStart)
2306  		linePrintLast = linePrintStart;
2307  	const Sci::Line linePrintMax = model.pdoc->SciLineFromPosition(chrg.cpMax);
2308  	if (linePrintLast > linePrintMax)
2309  		linePrintLast = linePrintMax;
2310  	Sci::Position endPosPrint = model.pdoc->Length();
2311  	if (linePrintLast < model.pdoc->LinesTotal())
2312  		endPosPrint = model.pdoc->LineStart(linePrintLast + 1);
2313  	model.pdoc->EnsureStyledTo(endPosPrint);
2314  	const int xStart = vsPrint.fixedColumnWidth + rc.left;
2315  	int ypos = rc.top;
2316  	Sci::Line lineDoc = linePrintStart;
2317  	Sci::Position nPrintPos = chrg.cpMin;
2318  	int visibleLine = 0;
2319  	int widthPrint = rc.right - rc.left - vsPrint.fixedColumnWidth;
2320  	if (printParameters.wrapState == Wrap::None)
2321  		widthPrint = LineLayout::wrapWidthInfinite;
2322  	while (lineDoc <= linePrintLast && ypos < rc.bottom) {
2323  		surfaceMeasure->FlushCachedState();
2324  		LineLayout ll(lineDoc, static_cast<int>(model.pdoc->LineStart(lineDoc + 1) - model.pdoc->LineStart(lineDoc) + 1));
2325  		LayoutLine(model, surfaceMeasure, vsPrint, &ll, widthPrint);
2326  		ll.containsCaret = false;
2327  		PRectangle rcLine = PRectangle::FromInts(
2328  			rc.left,
2329  			ypos,
2330  			rc.right - 1,
2331  			ypos + vsPrint.lineHeight);
2332  		if (visibleLine == 0) {
2333  			const Sci::Position startWithinLine = nPrintPos -
2334  				model.pdoc->LineStart(lineDoc);
2335  			for (int iwl = 0; iwl < ll.lines - 1; iwl++) {
2336  				if (ll.LineStart(iwl) <= startWithinLine && ll.LineStart(iwl + 1) >= startWithinLine) {
2337  					visibleLine = -iwl;
2338  				}
2339  			}
2340  			if (ll.lines > 1 && startWithinLine >= ll.LineStart(ll.lines - 1)) {
2341  				visibleLine = -(ll.lines - 1);
2342  			}
2343  		}
2344  		if (draw && lineNumberWidth &&
2345  			(ypos + vsPrint.lineHeight <= rc.bottom) &&
2346  			(visibleLine >= 0)) {
2347  			const std::string number = std::to_string(lineDoc + 1) + lineNumberPrintSpace;
2348  			PRectangle rcNumber = rcLine;
2349  			rcNumber.right = rcNumber.left + lineNumberWidth;
2350  			rcNumber.left = rcNumber.right - surfaceMeasure->WidthText(
2351  				vsPrint.styles[StyleLineNumber].font.get(), number);
2352  			surface->FlushCachedState();
2353  			surface->DrawTextNoClip(rcNumber, vsPrint.styles[StyleLineNumber].font.get(),
2354  				ypos + vsPrint.maxAscent, number,
2355  				vsPrint.styles[StyleLineNumber].fore,
2356  				vsPrint.styles[StyleLineNumber].back);
2357  		}
2358  		surface->FlushCachedState();
2359  		for (int iwl = 0; iwl < ll.lines; iwl++) {
2360  			if (ypos + vsPrint.lineHeight <= rc.bottom) {
2361  				if (visibleLine >= 0) {
2362  					if (draw) {
2363  						rcLine.top = static_cast<XYPOSITION>(ypos);
2364  						rcLine.bottom = static_cast<XYPOSITION>(ypos + vsPrint.lineHeight);
2365  						DrawLine(surface, model, vsPrint, &ll, lineDoc, visibleLine, xStart, rcLine, iwl, DrawPhase::all);
2366  					}
2367  					ypos += vsPrint.lineHeight;
2368  				}
2369  				visibleLine++;
2370  				if (iwl == ll.lines - 1)
2371  					nPrintPos = model.pdoc->LineStart(lineDoc + 1);
2372  				else
2373  					nPrintPos += ll.LineStart(iwl + 1) - ll.LineStart(iwl);
2374  			}
2375  		}
2376  		++lineDoc;
2377  	}
2378  	posCache->Clear();
2379  	return nPrintPos;
2380  }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-EditView.cxx</h3>
            <pre><code>1  #include <cstddef>
2  #include <cstdlib>
3  #include <cstdint>
4  #include <cassert>
5  #include <cstring>
6  #include <cstdio>
7  #include <cmath>
8  #include <stdexcept>
9  #include <string>
10  #include <string_view>
11  #include <vector>
12  #include <map>
13  #include <set>
14  #include <forward_list>
15  #include <optional>
16  #include <algorithm>
17  #include <iterator>
18  #include <memory>
19  #include <chrono>
20  #include <atomic>
21  #include <thread>
22  #include <future>
23  #include "ScintillaTypes.h"
24  #include "ScintillaMessages.h"
25  #include "ScintillaStructures.h"
26  #include "ILoader.h"
27  #include "ILexer.h"
28  #include "Debugging.h"
29  #include "Geometry.h"
30  #include "Platform.h"
31  #include "CharacterType.h"
32  #include "CharacterCategoryMap.h"
33  #include "Position.h"
34  #include "UniqueString.h"
35  #include "SplitVector.h"
36  #include "Partitioning.h"
37  #include "RunStyles.h"
38  #include "ContractionState.h"
39  #include "CellBuffer.h"
40  #include "PerLine.h"
41  #include "KeyMap.h"
42  #include "Indicator.h"
43  #include "LineMarker.h"
44  #include "Style.h"
45  #include "ViewStyle.h"
46  #include "CharClassify.h"
47  #include "Decoration.h"
48  #include "CaseFolder.h"
49  #include "Document.h"
50  #include "UniConversion.h"
51  #include "Selection.h"
52  #include "PositionCache.h"
53  #include "EditModel.h"
54  #include "MarginView.h"
55  #include "EditView.h"
56  #include "ElapsedPeriod.h"
57  using namespace Scintilla;
58  using namespace Scintilla::Internal;
59  PrintParameters::PrintParameters() noexcept {
60  	magnification = 0;
61  	colourMode = PrintOption::Normal;
62  	wrapState = Wrap::Word;
63  }
64  namespace {
65  int WidthStyledText(Surface *surface, const ViewStyle &vs, int styleOffset,
66  	const char *text, const unsigned char *styles, size_t len) {
67  	int width = 0;
68  	size_t start = 0;
69  	while (start < len) {
70  		const unsigned char style = styles[start];
71  		size_t endSegment = start;
72  		while ((endSegment + 1 < len) && (styles[endSegment + 1] == style))
73  			endSegment++;
74  		const Font *fontText = vs.styles[style + styleOffset].font.get();
75  		const std::string_view sv(text + start, endSegment - start + 1);
76  		width += static_cast<int>(surface->WidthText(fontText, sv));
77  		start = endSegment + 1;
78  	}
79  	return width;
80  }
81  }
82  namespace Scintilla::Internal {
83  bool ValidStyledText(const ViewStyle &vs, size_t styleOffset, const StyledText &st) noexcept {
84  	if (st.multipleStyles) {
85  		for (size_t iStyle = 0; iStyle<st.length; iStyle++) {
86  			if (!vs.ValidStyle(styleOffset + st.styles[iStyle]))
87  				return false;
88  		}
89  	} else {
90  		if (!vs.ValidStyle(styleOffset + st.style))
91  			return false;
92  	}
93  	return true;
94  }
95  int WidestLineWidth(Surface *surface, const ViewStyle &vs, int styleOffset, const StyledText &st) {
96  	int widthMax = 0;
97  	size_t start = 0;
98  	while (start < st.length) {
99  		const size_t lenLine = st.LineLength(start);
100  		int widthSubLine;
101  		if (st.multipleStyles) {
102  			widthSubLine = WidthStyledText(surface, vs, styleOffset, st.text + start, st.styles + start, lenLine);
103  		} else {
104  			const Font *fontText = vs.styles[styleOffset + st.style].font.get();
105  			const std::string_view text(st.text + start, lenLine);
106  			widthSubLine = static_cast<int>(surface->WidthText(fontText, text));
107  		}
108  		if (widthSubLine > widthMax)
109  			widthMax = widthSubLine;
110  		start += lenLine + 1;
111  	}
112  	return widthMax;
113  }
114  void DrawTextNoClipPhase(Surface *surface, PRectangle rc, const Style &style, XYPOSITION ybase,
115  	std::string_view text, DrawPhase phase) {
116  	const Font *fontText = style.font.get();
117  	if (FlagSet(phase, DrawPhase::back)) {
118  		if (FlagSet(phase, DrawPhase::text)) {
119  			surface->DrawTextNoClip(rc, fontText, ybase, text,
120  				style.fore, style.back);
121  		} else {
122  			surface->FillRectangleAligned(rc, Fill(style.back));
123  		}
124  	} else if (FlagSet(phase, DrawPhase::text)) {
125  		surface->DrawTextTransparent(rc, fontText, ybase, text, style.fore);
126  	}
127  }
128  void DrawStyledText(Surface *surface, const ViewStyle &vs, int styleOffset, PRectangle rcText,
129  	const StyledText &st, size_t start, size_t length, DrawPhase phase) {
130  	if (st.multipleStyles) {
131  		int x = static_cast<int>(rcText.left);
132  		size_t i = 0;
133  		while (i < length) {
134  			size_t end = i;
135  			size_t style = st.styles[i + start];
136  			while (end < length - 1 && st.styles[start + end + 1] == style)
137  				end++;
138  			style += styleOffset;
139  			const Font *fontText = vs.styles[style].font.get();
140  			const std::string_view text(st.text + start + i, end - i + 1);
141  			const int width = static_cast<int>(surface->WidthText(fontText, text));
142  			PRectangle rcSegment = rcText;
143  			rcSegment.left = static_cast<XYPOSITION>(x);
144  			rcSegment.right = static_cast<XYPOSITION>(x + width + 1);
145  			DrawTextNoClipPhase(surface, rcSegment, vs.styles[style],
146  				rcText.top + vs.maxAscent, text, phase);
147  			x += width;
148  			i = end + 1;
149  		}
150  	} else {
151  		const size_t style = st.style + styleOffset;
152  		DrawTextNoClipPhase(surface, rcText, vs.styles[style],
153  			rcText.top + vs.maxAscent,
154  			std::string_view(st.text + start, length), phase);
155  	}
156  }
157  }
158  EditView::EditView() {
159  	tabWidthMinimumPixels = 2; 
160  	drawOverstrikeCaret = true;
161  	bufferedDraw = true;
162  	phasesDraw = PhasesDraw::Two;
163  	lineWidthMaxSeen = 0;
164  	additionalCaretsBlink = true;
165  	additionalCaretsVisible = true;
166  	imeCaretBlockOverride = false;
167  	llc.SetLevel(LineCache::Caret);
168  	posCache = CreatePositionCache();
169  	posCache->SetSize(0x400);
170  	maxLayoutThreads = 1;
171  	tabArrowHeight = 4;
172  	customDrawTabArrow = nullptr;
173  	customDrawWrapMarker = nullptr;
174  }
175  EditView::~EditView() = default;
176  bool EditView::SetTwoPhaseDraw(bool twoPhaseDraw) noexcept {
177  	const PhasesDraw phasesDrawNew = twoPhaseDraw ? PhasesDraw::Two : PhasesDraw::One;
178  	const bool redraw = phasesDraw != phasesDrawNew;
179  	phasesDraw = phasesDrawNew;
180  	return redraw;
181  }
182  bool EditView::SetPhasesDraw(int phases) noexcept {
183  	const PhasesDraw phasesDrawNew = static_cast<PhasesDraw>(phases);
184  	const bool redraw = phasesDraw != phasesDrawNew;
185  	phasesDraw = phasesDrawNew;
186  	return redraw;
187  }
188  bool EditView::LinesOverlap() const noexcept {
189  	return phasesDraw == PhasesDraw::Multiple;
190  }
191  void EditView::SetLayoutThreads(unsigned int threads) noexcept {
192  	maxLayoutThreads = std::clamp(threads, 1U, std::thread::hardware_concurrency());
193  }
194  unsigned int EditView::GetLayoutThreads() const noexcept {
195  	return maxLayoutThreads;
196  }
197  void EditView::ClearAllTabstops() noexcept {
198  	ldTabstops.reset();
199  }
200  XYPOSITION EditView::NextTabstopPos(Sci::Line line, XYPOSITION x, XYPOSITION tabWidth) const noexcept {
201  	const int next = GetNextTabstop(line, static_cast<int>(x + tabWidthMinimumPixels));
202  	if (next > 0)
203  		return static_cast<XYPOSITION>(next);
204  	return (static_cast<int>((x + tabWidthMinimumPixels) / tabWidth) + 1) * tabWidth;
205  }
206  bool EditView::ClearTabstops(Sci::Line line) noexcept {
207  	return ldTabstops && ldTabstops->ClearTabstops(line);
208  }
209  bool EditView::AddTabstop(Sci::Line line, int x) {
210  	if (!ldTabstops) {
211  		ldTabstops = std::make_unique<LineTabstops>();
212  	}
213  	return ldTabstops && ldTabstops->AddTabstop(line, x);
214  }
215  int EditView::GetNextTabstop(Sci::Line line, int x) const noexcept {
216  	if (ldTabstops) {
217  		return ldTabstops->GetNextTabstop(line, x);
218  	} else {
219  		return 0;
220  	}
221  }
222  void EditView::LinesAddedOrRemoved(Sci::Line lineOfPos, Sci::Line linesAdded) {
223  	if (ldTabstops) {
224  		if (linesAdded > 0) {
225  			for (Sci::Line line = lineOfPos; line < lineOfPos + linesAdded; line++) {
226  				ldTabstops->InsertLine(line);
227  			}
228  		} else {
229  			for (Sci::Line line = (lineOfPos + -linesAdded) - 1; line >= lineOfPos; line--) {
230  				ldTabstops->RemoveLine(line);
231  			}
232  		}
233  	}
234  }
235  void EditView::DropGraphics() noexcept {
236  	pixmapLine.reset();
237  	pixmapIndentGuide.reset();
238  	pixmapIndentGuideHighlight.reset();
239  }
240  void EditView::RefreshPixMaps(Surface *surfaceWindow, const ViewStyle &vsDraw) {
241  	if (!pixmapIndentGuide) {
242  		pixmapIndentGuide = surfaceWindow->AllocatePixMap(1, vsDraw.lineHeight + 1);
243  		pixmapIndentGuideHighlight = surfaceWindow->AllocatePixMap(1, vsDraw.lineHeight + 1);
244  		const PRectangle rcIG = PRectangle::FromInts(0, 0, 1, vsDraw.lineHeight);
245  		pixmapIndentGuide->FillRectangle(rcIG, vsDraw.styles[StyleIndentGuide].back);
246  		pixmapIndentGuideHighlight->FillRectangle(rcIG, vsDraw.styles[StyleBraceLight].back);
247  		for (int stripe = 1; stripe < vsDraw.lineHeight + 1; stripe += 2) {
248  			const PRectangle rcPixel = PRectangle::FromInts(0, stripe, 1, stripe + 1);
249  			pixmapIndentGuide->FillRectangle(rcPixel, vsDraw.styles[StyleIndentGuide].fore);
250  			pixmapIndentGuideHighlight->FillRectangle(rcPixel, vsDraw.styles[StyleBraceLight].fore);
251  		}
252  		pixmapIndentGuide->FlushDrawing();
253  		pixmapIndentGuideHighlight->FlushDrawing();
254  	}
255  }
256  std::shared_ptr<LineLayout> EditView::RetrieveLineLayout(Sci::Line lineNumber, const EditModel &model) {
257  	const Sci::Position posLineStart = model.pdoc->LineStart(lineNumber);
258  	const Sci::Position posLineEnd = model.pdoc->LineStart(lineNumber + 1);
259  	PLATFORM_ASSERT(posLineEnd >= posLineStart);
260  	const Sci::Line lineCaret = model.pdoc->SciLineFromPosition(model.sel.MainCaret());
261  	return llc.Retrieve(lineNumber, lineCaret,
262  		static_cast<int>(posLineEnd - posLineStart), model.pdoc->GetStyleClock(),
263  		model.LinesOnScreen() + 1, model.pdoc->LinesTotal());
264  }
265  namespace {
266  constexpr XYPOSITION epsilon = 0.0001f;	
267  inline char CaseForce(Style::CaseForce caseForce, char chDoc, char chPrevious) noexcept {
268  	switch (caseForce) {
269  	case Style::CaseForce::mixed:
270  		return chDoc;
271  	case Style::CaseForce::lower:
272  		return MakeLowerCase(chDoc);
273  	case Style::CaseForce::upper:
274  		return MakeUpperCase(chDoc);
275  	case Style::CaseForce::camel:
276  	default:	
277  		if (IsUpperOrLowerCase(chDoc) && !IsUpperOrLowerCase(chPrevious)) {
278  			return MakeUpperCase(chDoc);
279  		} else {
280  			return MakeLowerCase(chDoc);
281  		}
282  	}
283  }
284  void LayoutSegments(IPositionCache *pCache,
285  	Surface *surface,
286  	const ViewStyle &vstyle,
287  	LineLayout *ll,
288  	const std::vector<TextSegment> &segments,
289  	std::atomic<uint32_t> &nextIndex,
290  	const bool textUnicode,
291  	const bool multiThreaded) {
292  	while (true) {
293  		const uint32_t i = nextIndex.fetch_add(1, std::memory_order_acq_rel);
294  		if (i >= segments.size()) {
295  			break;
296  		}
297  		const TextSegment &ts = segments[i];
298  		const unsigned int styleSegment = ll->styles[ts.start];
299  		XYPOSITION *positions = &ll->positions[ts.start + 1];
300  		if (vstyle.styles[styleSegment].visible) {
301  			if (ts.representation) {
302  				XYPOSITION representationWidth = 0.0;
303  				if (ll->chars[ts.start] != '\t') {
304  					representationWidth = vstyle.controlCharWidth;
305  					if (representationWidth <= 0.0) {
306  						assert(ts.representation->stringRep.length() <= Representation::maxLength);
307  						XYPOSITION positionsRepr[Representation::maxLength + 1];
308  						pCache->MeasureWidths(surface, vstyle, StyleControlChar, true, ts.representation->stringRep,
309  							positionsRepr, multiThreaded);
310  						representationWidth = positionsRepr[ts.representation->stringRep.length() - 1];
311  						if (FlagSet(ts.representation->appearance, RepresentationAppearance::Blob)) {
312  							representationWidth += vstyle.ctrlCharPadding;
313  						}
314  					}
315  				}
316  				std::fill(positions, positions + ts.length, representationWidth);
317  			} else {
318  				if ((ts.length == 1) && (' ' == ll->chars[ts.start])) {
319  					positions[0] = vstyle.styles[styleSegment].spaceWidth;
320  				} else {
321  					pCache->MeasureWidths(surface, vstyle, styleSegment, textUnicode,
322  						std::string_view(&ll->chars[ts.start], ts.length), positions, multiThreaded);
323  				}
324  			}
325  		} else if (vstyle.styles[styleSegment].invisibleRepresentation[0]) {
326  			const std::string_view text = vstyle.styles[styleSegment].invisibleRepresentation;
327  			XYPOSITION positionsRepr[Representation::maxLength + 1];
328  			pCache->MeasureWidths(surface, vstyle, styleSegment, true, text, positionsRepr, multiThreaded);
329  			const XYPOSITION representationWidth = positionsRepr[text.length() - 1];
330  			std::fill(positions, positions + ts.length, representationWidth);
331  		}
332  	}
333  }
334  }
335  void EditView::LayoutLine(const EditModel &model, Surface *surface, const ViewStyle &vstyle, LineLayout *ll, int width, bool callerMultiThreaded) {
336  	if (!ll)
337  		return;
338  	const Sci::Line line = ll->LineNumber();
339  	PLATFORM_ASSERT(line < model.pdoc->LinesTotal());
340  	PLATFORM_ASSERT(ll->chars);
341  	const Sci::Position posLineStart = model.pdoc->LineStart(line);
342  	Sci::Position posLineEnd = model.pdoc->LineStart(line + 1);
343  	if (posLineEnd >(posLineStart + ll->maxLineLength)) {
344  		posLineEnd = posLineStart + ll->maxLineLength;
345  	}
346  	width = std::max(width, 20);
347  	if (ll->validity == LineLayout::ValidLevel::checkTextAndStyle) {
348  		Sci::Position lineLength = posLineEnd - posLineStart;
349  		if (!vstyle.viewEOL) {
350  			lineLength = model.pdoc->LineEnd(line) - posLineStart;
351  		}
352  		if (lineLength == ll->numCharsInLine) {
353  			bool allSame = true;
354  			char chPrevious = 0;
355  			for (Sci::Position numCharsInLine = 0; numCharsInLine < lineLength; numCharsInLine++) {
356  				const Sci::Position charInDoc = numCharsInLine + posLineStart;
357  				const char chDoc = model.pdoc->CharAt(charInDoc);
358  				const int styleByte = model.pdoc->StyleIndexAt(charInDoc);
359  				allSame = allSame &&
360  					(ll->styles[numCharsInLine] == styleByte);
361  				allSame = allSame &&
362  					(ll->chars[numCharsInLine] == CaseForce(vstyle.styles[styleByte].caseForce, chDoc, chPrevious));
363  				chPrevious = chDoc;
364  			}
365  			const int styleByteLast = (posLineEnd > posLineStart) ? model.pdoc->StyleIndexAt(posLineEnd - 1) : 0;
366  			allSame = allSame && (ll->styles[lineLength] == styleByteLast);	
367  			if (allSame) {
368  				ll->validity = (ll->widthLine != width) ? LineLayout::ValidLevel::positions : LineLayout::ValidLevel::lines;
369  			} else {
370  				ll->validity = LineLayout::ValidLevel::invalid;
371  			}
372  		} else {
373  			ll->validity = LineLayout::ValidLevel::invalid;
374  		}
375  	}
376  	if (ll->validity == LineLayout::ValidLevel::invalid) {
377  		ll->widthLine = LineLayout::wrapWidthInfinite;
378  		ll->lines = 1;
379  		if (vstyle.edgeState == EdgeVisualStyle::Background) {
380  			Sci::Position edgePosition = model.pdoc->FindColumn(line, vstyle.theEdge.column);
381  			if (edgePosition >= posLineStart) {
382  				edgePosition -= posLineStart;
383  			}
384  			ll->edgeColumn = static_cast<int>(edgePosition);
385  		} else {
386  			ll->edgeColumn = -1;
387  		}
388  		const int lineLength = static_cast<int>(posLineEnd - posLineStart);
389  		model.pdoc->GetCharRange(ll->chars.get(), posLineStart, lineLength);
390  		model.pdoc->GetStyleRange(ll->styles.get(), posLineStart, lineLength);
391  		const int numCharsBeforeEOL = static_cast<int>(model.pdoc->LineEnd(line) - posLineStart);
392  		const int numCharsInLine = (vstyle.viewEOL) ? lineLength : numCharsBeforeEOL;
393  		const unsigned char styleByteLast = (lineLength > 0) ? ll->styles[lineLength - 1] : 0;
394  		if (vstyle.someStylesForceCase) {
395  			char chPrevious = 0;
396  			for (int charInLine = 0; charInLine<lineLength; charInLine++) {
397  				const char chDoc = ll->chars[charInLine];
398  				ll->chars[charInLine] = CaseForce(vstyle.styles[ll->styles[charInLine]].caseForce, chDoc, chPrevious);
399  				chPrevious = chDoc;
400  			}
401  		}
402  		ll->xHighlightGuide = 0;
403  		ll->chars[numCharsInLine] = 0;   
404  		ll->styles[numCharsInLine] = styleByteLast;	
405  		ll->positions[0] = 0;
406  		bool lastSegItalics = false;
407  		std::vector<TextSegment> segments;
408  		BreakFinder bfLayout(ll, nullptr, Range(0, numCharsInLine), posLineStart, 0, BreakFinder::BreakFor::Text, model.pdoc, &model.reprs, nullptr);
409  		while (bfLayout.More()) {
410  			segments.push_back(bfLayout.Next());
411  		}
412  		ll->ClearPositions();
413  		if (!segments.empty()) {
414  			const size_t threadsForLength = std::max(1, numCharsInLine / bytesPerLayoutThread);
415  			size_t threads = std::min<size_t>({ segments.size(), threadsForLength, maxLayoutThreads });
416  			if (!surface->SupportsFeature(Supports::ThreadSafeMeasureWidths) || callerMultiThreaded) {
417  				threads = 1;
418  			}
419  			std::atomic<uint32_t> nextIndex = 0;
420  			const bool textUnicode = CpUtf8 == model.pdoc->dbcsCodePage;
421  			const bool multiThreaded = threads > 1;
422  			const bool multiThreadedContext = multiThreaded || callerMultiThreaded;
423  			IPositionCache *pCache = posCache.get();
424  			const std::launch policy = (multiThreaded) ? std::launch::async : std::launch::deferred;
425  			std::vector<std::future<void>> futures;
426  			for (size_t th = 0; th < threads; th++) {
427  				std::future<void> fut = std::async(policy,
428  					[pCache, surface, &vstyle, &ll, &segments, &nextIndex, textUnicode, multiThreadedContext]() {
429  					LayoutSegments(pCache, surface, vstyle, ll, segments, nextIndex, textUnicode, multiThreadedContext);
430  				});
431  				futures.push_back(std::move(fut));
432  			}
433  			for (const std::future<void> &f : futures) {
434  				f.wait();
435  			}
436  		}
437  		XYPOSITION xPosition = 0.0;
438  		size_t iByte = 0;
439  		ll->positions[iByte++] = xPosition;
440  		for (const TextSegment &ts : segments) {
441  			if (vstyle.styles[ll->styles[ts.start]].visible &&
442  				ts.representation &&
443  				(ll->chars[ts.start] == '\t')) {
444  				const XYPOSITION startTab = ll->positions[ts.start];
445  				const XYPOSITION nextTab = NextTabstopPos(line, startTab, vstyle.tabWidth);
446  				xPosition += nextTab - startTab;
447  			}
448  			const XYPOSITION xBeginSegment = xPosition;
449  			for (int i = 0; i < ts.length; i++) {
450  				xPosition = ll->positions[iByte] + xBeginSegment;
451  				ll->positions[iByte++] = xPosition;
452  			}
453  		}
454  		if (!segments.empty()) {
455  			const TextSegment &ts = segments.back();
456  			lastSegItalics = (!ts.representation) && ((ll->chars[ts.end() - 1] != ' ') && vstyle.styles[ll->styles[ts.start]].italic);
457  		}
458  		if (lastSegItalics) {
459  			ll->positions[numCharsInLine] += vstyle.lastSegItalicsOffset;
460  		}
461  		ll->numCharsInLine = numCharsInLine;
462  		ll->numCharsBeforeEOL = numCharsBeforeEOL;
463  		ll->validity = LineLayout::ValidLevel::positions;
464  	}
465  	if ((ll->validity == LineLayout::ValidLevel::positions) || (ll->widthLine != width)) {
466  		ll->widthLine = width;
467  		if (width == LineLayout::wrapWidthInfinite) {
468  			ll->lines = 1;
469  		} else if (width > ll->positions[ll->numCharsInLine]) {
470  			ll->lines = 1;
471  		} else {
472  			if (FlagSet(vstyle.wrap.visualFlags, WrapVisualFlag::End)) {
473  				width -= static_cast<int>(vstyle.aveCharWidth); 
474  			}
475  			XYPOSITION wrapAddIndent = 0; 
476  			switch (vstyle.wrap.indentMode) {
477  			case WrapIndentMode::Fixed:
478  				wrapAddIndent = vstyle.wrap.visualStartIndent * vstyle.aveCharWidth;
479  				break;
480  			case WrapIndentMode::Indent:
481  				wrapAddIndent = model.pdoc->IndentSize() * vstyle.spaceWidth;
482  				break;
483  			case WrapIndentMode::DeepIndent:
484  				wrapAddIndent = model.pdoc->IndentSize() * 2 * vstyle.spaceWidth;
485  				break;
486  			default:	
487  				break;
488  			}
489  			ll->wrapIndent = wrapAddIndent;
490  			if (vstyle.wrap.indentMode != WrapIndentMode::Fixed) {
491  				for (int i = 0; i < ll->numCharsInLine; i++) {
492  					if (!IsSpaceOrTab(ll->chars[i])) {
493  						ll->wrapIndent += ll->positions[i]; 
494  						break;
495  					}
496  				}
497  			}
498  			if (ll->wrapIndent > width - static_cast<int>(vstyle.aveCharWidth) * 15)
499  				ll->wrapIndent = wrapAddIndent;
500  			if ((FlagSet(vstyle.wrap.visualFlags, WrapVisualFlag::Start)) && (ll->wrapIndent < vstyle.aveCharWidth))
501  				ll->wrapIndent = vstyle.aveCharWidth; 
502  			ll->WrapLine(model.pdoc, posLineStart, vstyle.wrap.state, width);
503  		}
504  		ll->validity = LineLayout::ValidLevel::lines;
505  	}
506  }
507  void EditView::UpdateBidiData(const EditModel &model, const ViewStyle &vstyle, LineLayout *ll) {
508  	if (model.BidirectionalEnabled()) {
509  		ll->EnsureBidiData();
510  		for (int stylesInLine = 0; stylesInLine < ll->numCharsInLine; stylesInLine++) {
511  			ll->bidiData->stylesFonts[stylesInLine] = vstyle.styles[ll->styles[stylesInLine]].font;
512  		}
513  		ll->bidiData->stylesFonts[ll->numCharsInLine].reset();
514  		for (int charsInLine = 0; charsInLine < ll->numCharsInLine; charsInLine++) {
515  			const int charWidth = UTF8DrawBytes(&ll->chars[charsInLine], ll->numCharsInLine - charsInLine);
516  			const Representation *repr = model.reprs.RepresentationFromCharacter(std::string_view(&ll->chars[charsInLine], charWidth));
517  			ll->bidiData->widthReprs[charsInLine] = 0.0f;
518  			if (repr && ll->chars[charsInLine] != '\t') {
519  				ll->bidiData->widthReprs[charsInLine] = ll->positions[charsInLine + charWidth] - ll->positions[charsInLine];
520  			}
521  			if (charWidth > 1) {
522  				for (int c = 1; c < charWidth; c++) {
523  					charsInLine++;
524  					ll->bidiData->widthReprs[charsInLine] = 0.0f;
525  				}
526  			}
527  		}
528  		ll->bidiData->widthReprs[ll->numCharsInLine] = 0.0f;
529  	} else {
530  		ll->bidiData.reset();
531  	}
532  }
533  Point EditView::LocationFromPosition(Surface *surface, const EditModel &model, SelectionPosition pos, Sci::Line topLine,
534  				     const ViewStyle &vs, PointEnd pe, const PRectangle rcClient) {
535  	Point pt;
536  	if (pos.Position() == Sci::invalidPosition)
537  		return pt;
538  	Sci::Line lineDoc = model.pdoc->SciLineFromPosition(pos.Position());
539  	Sci::Position posLineStart = model.pdoc->LineStart(lineDoc);
540  	if (FlagSet(pe, PointEnd::lineEnd) && (lineDoc > 0) && (pos.Position() == posLineStart)) {
541  		lineDoc--;
542  		posLineStart = model.pdoc->LineStart(lineDoc);
543  	}
544  	const Sci::Line lineVisible = model.pcs->DisplayFromDoc(lineDoc);
545  	std::shared_ptr<LineLayout> ll = RetrieveLineLayout(lineDoc, model);
546  	if (surface && ll) {
547  		LayoutLine(model, surface, vs, ll.get(), model.wrapWidth);
548  		const int posInLine = static_cast<int>(pos.Position() - posLineStart);
549  		pt = ll->PointFromPosition(posInLine, vs.lineHeight, pe);
550  		pt.x += vs.textStart - model.xOffset;
551  		if (model.BidirectionalEnabled()) {
552  			UpdateBidiData(model, vs, ll.get());
553  			const int subLine = ll->SubLineFromPosition(posInLine, pe);
554  			const int caretPosition = posInLine - ll->LineStart(subLine);
555  			const ScreenLine screenLine(ll.get(), subLine, vs, rcClient.right, tabWidthMinimumPixels);
556  			std::unique_ptr<IScreenLineLayout> slLayout = surface->Layout(&screenLine);
557  			pt.x = slLayout->XFromPosition(caretPosition);
558  			pt.x += vs.textStart - model.xOffset;
559  			pt.y = 0;
560  			if (posInLine >= ll->LineStart(subLine)) {
561  				pt.y = static_cast<XYPOSITION>(subLine*vs.lineHeight);
562  			}
563  		}
564  		pt.y += (lineVisible - topLine) * vs.lineHeight;
565  		pt.x += pos.VirtualSpace() * vs.styles[ll->EndLineStyle()].spaceWidth;
566  	}
567  	return pt;
568  }
569  Range EditView::RangeDisplayLine(Surface *surface, const EditModel &model, Sci::Line lineVisible, const ViewStyle &vs) {
570  	Range rangeSubLine = Range(0, 0);
571  	if (lineVisible < 0) {
572  		return rangeSubLine;
573  	}
574  	const Sci::Line lineDoc = model.pcs->DocFromDisplay(lineVisible);
575  	const Sci::Position positionLineStart = model.pdoc->LineStart(lineDoc);
576  	std::shared_ptr<LineLayout> ll = RetrieveLineLayout(lineDoc, model);
577  	if (surface && ll) {
578  		LayoutLine(model, surface, vs, ll.get(), model.wrapWidth);
579  		const Sci::Line lineStartSet = model.pcs->DisplayFromDoc(lineDoc);
580  		const int subLine = static_cast<int>(lineVisible - lineStartSet);
581  		if (subLine < ll->lines) {
582  			rangeSubLine = ll->SubLineRange(subLine, LineLayout::Scope::visibleOnly);
583  			if (subLine == ll->lines-1) {
584  				rangeSubLine.end = model.pdoc->LineStart(lineDoc + 1) -
585  					positionLineStart;
586  			}
587  		}
588  	}
589  	rangeSubLine.start += positionLineStart;
590  	rangeSubLine.end += positionLineStart;
591  	return rangeSubLine;
592  }
593  SelectionPosition EditView::SPositionFromLocation(Surface *surface, const EditModel &model, PointDocument pt, bool canReturnInvalid,
594  	bool charPosition, bool virtualSpace, const ViewStyle &vs, const PRectangle rcClient) {
595  	pt.x = pt.x - vs.textStart;
596  	Sci::Line visibleLine = static_cast<int>(std::floor(pt.y / vs.lineHeight));
597  	if (!canReturnInvalid && (visibleLine < 0))
598  		visibleLine = 0;
599  	const Sci::Line lineDoc = model.pcs->DocFromDisplay(visibleLine);
600  	if (canReturnInvalid && (lineDoc < 0))
601  		return SelectionPosition(Sci::invalidPosition);
602  	if (lineDoc >= model.pdoc->LinesTotal())
603  		return SelectionPosition(canReturnInvalid ? Sci::invalidPosition :
604  			model.pdoc->Length());
605  	const Sci::Position posLineStart = model.pdoc->LineStart(lineDoc);
606  	std::shared_ptr<LineLayout> ll = RetrieveLineLayout(lineDoc, model);
607  	if (surface && ll) {
608  		LayoutLine(model, surface, vs, ll.get(), model.wrapWidth);
609  		const Sci::Line lineStartSet = model.pcs->DisplayFromDoc(lineDoc);
610  		const int subLine = static_cast<int>(visibleLine - lineStartSet);
611  		if (subLine < ll->lines) {
612  			const Range rangeSubLine = ll->SubLineRange(subLine, LineLayout::Scope::visibleOnly);
613  			const XYPOSITION subLineStart = ll->positions[rangeSubLine.start];
614  			if (subLine > 0)	
615  				pt.x -= ll->wrapIndent;
616  			Sci::Position positionInLine = 0;
617  			if (model.BidirectionalEnabled()) {
618  				UpdateBidiData(model, vs, ll.get());
619  				const ScreenLine screenLine(ll.get(), subLine, vs, rcClient.right, tabWidthMinimumPixels);
620  				std::unique_ptr<IScreenLineLayout> slLayout = surface->Layout(&screenLine);
621  				positionInLine = slLayout->PositionFromX(pt.x, charPosition) +
622  					rangeSubLine.start;
623  			} else {
624  				positionInLine = ll->FindPositionFromX(pt.x + subLineStart,
625  					rangeSubLine, charPosition);
626  			}
627  			if (positionInLine < rangeSubLine.end) {
628  				return SelectionPosition(model.pdoc->MovePositionOutsideChar(positionInLine + posLineStart, 1));
629  			}
630  			if (virtualSpace) {
631  				const XYPOSITION spaceWidth = vs.styles[ll->EndLineStyle()].spaceWidth;
632  				const int spaceOffset = static_cast<int>(
633  					(pt.x + subLineStart - ll->positions[rangeSubLine.end] + spaceWidth / 2) / spaceWidth);
634  				return SelectionPosition(rangeSubLine.end + posLineStart, spaceOffset);
635  			} else if (canReturnInvalid) {
636  				if (pt.x < (ll->positions[rangeSubLine.end] - subLineStart)) {
637  					return SelectionPosition(model.pdoc->MovePositionOutsideChar(rangeSubLine.end + posLineStart, 1));
638  				}
639  			} else {
640  				return SelectionPosition(rangeSubLine.end + posLineStart);
641  			}
642  		}
643  		if (!canReturnInvalid)
644  			return SelectionPosition(ll->numCharsInLine + posLineStart);
645  	}
646  	return SelectionPosition(canReturnInvalid ? Sci::invalidPosition : posLineStart);
647  }
648  SelectionPosition EditView::SPositionFromLineX(Surface *surface, const EditModel &model, Sci::Line lineDoc, int x, const ViewStyle &vs) {
649  	std::shared_ptr<LineLayout> ll = RetrieveLineLayout(lineDoc, model);
650  	if (surface && ll) {
651  		const Sci::Position posLineStart = model.pdoc->LineStart(lineDoc);
652  		LayoutLine(model, surface, vs, ll.get(), model.wrapWidth);
653  		const Range rangeSubLine = ll->SubLineRange(0, LineLayout::Scope::visibleOnly);
654  		const XYPOSITION subLineStart = ll->positions[rangeSubLine.start];
655  		const Sci::Position positionInLine = ll->FindPositionFromX(x + subLineStart, rangeSubLine, false);
656  		if (positionInLine < rangeSubLine.end) {
657  			return SelectionPosition(model.pdoc->MovePositionOutsideChar(positionInLine + posLineStart, 1));
658  		}
659  		const XYPOSITION spaceWidth = vs.styles[ll->EndLineStyle()].spaceWidth;
660  		const int spaceOffset = static_cast<int>(
661  			(x + subLineStart - ll->positions[rangeSubLine.end] + spaceWidth / 2) / spaceWidth);
662  		return SelectionPosition(rangeSubLine.end + posLineStart, spaceOffset);
663  	}
664  	return SelectionPosition(0);
665  }
666  Sci::Line EditView::DisplayFromPosition(Surface *surface, const EditModel &model, Sci::Position pos, const ViewStyle &vs) {
667  	const Sci::Line lineDoc = model.pdoc->SciLineFromPosition(pos);
668  	Sci::Line lineDisplay = model.pcs->DisplayFromDoc(lineDoc);
669  	std::shared_ptr<LineLayout> ll = RetrieveLineLayout(lineDoc, model);
670  	if (surface && ll) {
671  		LayoutLine(model, surface, vs, ll.get(), model.wrapWidth);
672  		const Sci::Position posLineStart = model.pdoc->LineStart(lineDoc);
673  		const Sci::Position posInLine = pos - posLineStart;
674  		lineDisplay--; 
675  		for (int subLine = 0; subLine < ll->lines; subLine++) {
676  			if (posInLine >= ll->LineStart(subLine)) {
677  				lineDisplay++;
678  			}
679  		}
680  	}
681  	return lineDisplay;
682  }
683  Sci::Position EditView::StartEndDisplayLine(Surface *surface, const EditModel &model, Sci::Position pos, bool start, const ViewStyle &vs) {
684  	const Sci::Line line = model.pdoc->SciLineFromPosition(pos);
685  	std::shared_ptr<LineLayout> ll = RetrieveLineLayout(line, model);
686  	Sci::Position posRet = Sci::invalidPosition;
687  	if (surface && ll) {
688  		const Sci::Position posLineStart = model.pdoc->LineStart(line);
689  		LayoutLine(model, surface, vs, ll.get(), model.wrapWidth);
690  		const Sci::Position posInLine = pos - posLineStart;
691  		if (posInLine <= ll->maxLineLength) {
692  			for (int subLine = 0; subLine < ll->lines; subLine++) {
693  				if ((posInLine >= ll->LineStart(subLine)) &&
694  				    (posInLine <= ll->LineStart(subLine + 1)) &&
695  				    (posInLine <= ll->numCharsBeforeEOL)) {
696  					if (start) {
697  						posRet = ll->LineStart(subLine) + posLineStart;
698  					} else {
699  						if (subLine == ll->lines - 1)
700  							posRet = ll->numCharsBeforeEOL + posLineStart;
701  						else
702  							posRet = model.pdoc->MovePositionOutsideChar(ll->LineStart(subLine + 1) + posLineStart - 1, -1, false);
703  					}
704  				}
705  			}
706  		}
707  	}
708  	return posRet;
709  }
710  namespace {
711  constexpr ColourRGBA bugColour = ColourRGBA(0xff, 0, 0xfe, 0xf0);
712  ColourRGBA SelectionBackground(const EditModel &model, const ViewStyle &vsDraw, InSelection inSelection) {
713  	if (inSelection == InSelection::inNone)
714  		return bugColour;	
715  	Element element = Element::SelectionBack;
716  	if (inSelection == InSelection::inAdditional)
717  		element = Element::SelectionAdditionalBack;
718  	if (!model.primarySelection)
719  		element = Element::SelectionSecondaryBack;
720  	if (!model.hasFocus && vsDraw.ElementColour(Element::SelectionInactiveBack))
721  		element = Element::SelectionInactiveBack;
722  	return vsDraw.ElementColour(element).value_or(bugColour);
723  }
724  ColourOptional SelectionForeground(const EditModel &model, const ViewStyle &vsDraw, InSelection inSelection) {
725  	if (inSelection == InSelection::inNone)
726  		return {};
727  	Element element = Element::SelectionText;
728  	if (inSelection == InSelection::inAdditional)
729  		element = Element::SelectionAdditionalText;
730  	if (!model.primarySelection)	
731  		element = Element::SelectionSecondaryText;
732  	if (!model.hasFocus) {
733  		if (vsDraw.ElementColour(Element::SelectionInactiveText)) {
734  			element = Element::SelectionInactiveText;
735  		} else {
736  			return {};
737  		}
738  	}
739  	return vsDraw.ElementColour(element);
740  }
741  ColourRGBA TextBackground(const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
742  	ColourOptional background, InSelection inSelection, bool inHotspot, int styleMain, Sci::Position i) {
743  	if (inSelection && (vsDraw.selection.layer == Layer::Base)) {
744  		return SelectionBackground(model, vsDraw, inSelection).Opaque();
745  	}
746  	if ((vsDraw.edgeState == EdgeVisualStyle::Background) &&
747  		(i >= ll->edgeColumn) &&
748  		(i < ll->numCharsBeforeEOL))
749  		return vsDraw.theEdge.colour;
750  	if (inHotspot) {
751  		if (const ColourOptional colourHotSpotBack = vsDraw.ElementColour(Element::HotSpotActiveBack)) {
752  			return colourHotSpotBack->Opaque();
753  		}
754  	}
755  	if (background && (styleMain != StyleBraceLight) && (styleMain != StyleBraceBad)) {
756  		return *background;
757  	} else {
758  		return vsDraw.styles[styleMain].back;
759  	}
760  }
761  void DrawTextBlob(Surface *surface, const ViewStyle &vsDraw, PRectangle rcSegment,
762  	std::string_view text, ColourRGBA textBack, ColourRGBA textFore, bool fillBackground) {
763  	if (rcSegment.Empty())
764  		return;
765  	if (fillBackground) {
766  		surface->FillRectangleAligned(rcSegment, Fill(textBack));
767  	}
768  	const Font *ctrlCharsFont = vsDraw.styles[StyleControlChar].font.get();
769  	const int normalCharHeight = static_cast<int>(std::ceil(vsDraw.styles[StyleControlChar].capitalHeight));
770  	PRectangle rcCChar = rcSegment;
771  	rcCChar.left = rcCChar.left + 1;
772  	rcCChar.top = rcSegment.top + vsDraw.maxAscent - normalCharHeight;
773  	rcCChar.bottom = rcSegment.top + vsDraw.maxAscent + 1;
774  	PRectangle rcCentral = rcCChar;
775  	rcCentral.top++;
776  	rcCentral.bottom--;
777  	surface->FillRectangleAligned(rcCentral, Fill(textFore));
778  	PRectangle rcChar = rcCChar;
779  	rcChar.left++;
780  	rcChar.right--;
781  	surface->DrawTextClippedUTF8(rcChar, ctrlCharsFont,
782  		rcSegment.top + vsDraw.maxAscent, text,
783  		textBack, textFore);
784  }
785  void FillLineRemainder(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
786  	Sci::Line line, PRectangle rcArea, int subLine) {
787  	InSelection eolInSelection = InSelection::inNone;
788  	if (vsDraw.selection.visible && (subLine == (ll->lines - 1))) {
789  		eolInSelection = model.LineEndInSelection(line);
790  	}
791  	if (eolInSelection && vsDraw.selection.eolFilled && (line < model.pdoc->LinesTotal() - 1) && (vsDraw.selection.layer == Layer::Base)) {
792  		surface->FillRectangleAligned(rcArea, Fill(SelectionBackground(model, vsDraw, eolInSelection).Opaque()));
793  	} else {
794  		const ColourOptional background = vsDraw.Background(model.GetMark(line), model.caret.active, ll->containsCaret);
795  		if (background) {
796  			surface->FillRectangleAligned(rcArea, Fill(*background));
797  		} else if (vsDraw.styles[ll->styles[ll->numCharsInLine]].eolFilled) {
798  			surface->FillRectangleAligned(rcArea, Fill(vsDraw.styles[ll->styles[ll->numCharsInLine]].back));
799  		} else {
800  			surface->FillRectangleAligned(rcArea, Fill(vsDraw.styles[StyleDefault].back));
801  		}
802  		if (eolInSelection && vsDraw.selection.eolFilled && (line < model.pdoc->LinesTotal() - 1) && (vsDraw.selection.layer != Layer::Base)) {
803  			surface->FillRectangleAligned(rcArea, SelectionBackground(model, vsDraw, eolInSelection));
804  		}
805  	}
806  }
807  }
808  void EditView::DrawEOL(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
809  	Sci::Line line, int xStart, PRectangle rcLine, int subLine, Sci::Position lineEnd, XYPOSITION subLineStart, ColourOptional background) {
810  	const Sci::Position posLineStart = model.pdoc->LineStart(line);
811  	PRectangle rcSegment = rcLine;
812  	const bool lastSubLine = subLine == (ll->lines - 1);
813  	XYPOSITION virtualSpace = 0;
814  	if (lastSubLine) {
815  		const XYPOSITION spaceWidth = vsDraw.styles[ll->EndLineStyle()].spaceWidth;
816  		virtualSpace = model.sel.VirtualSpaceFor(model.pdoc->LineEnd(line)) * spaceWidth;
817  	}
818  	const XYPOSITION xEol = ll->positions[lineEnd] - subLineStart;
819  	if (virtualSpace > 0.0f) {
820  		rcSegment.left = xEol + xStart;
821  		rcSegment.right = xEol + xStart + virtualSpace;
822  		const ColourRGBA backgroundFill = background.value_or(vsDraw.styles[ll->styles[ll->numCharsInLine]].back);
823  		surface->FillRectangleAligned(rcSegment, backgroundFill);
824  		if (vsDraw.selection.visible && (vsDraw.selection.layer == Layer::Base)) {
825  			const SelectionSegment virtualSpaceRange(SelectionPosition(model.pdoc->LineEnd(line)),
826  				SelectionPosition(model.pdoc->LineEnd(line),
827  					model.sel.VirtualSpaceFor(model.pdoc->LineEnd(line))));
828  			for (size_t r = 0; r<model.sel.Count(); r++) {
829  				const SelectionSegment portion = model.sel.Range(r).Intersect(virtualSpaceRange);
830  				if (!portion.Empty()) {
831  					const XYPOSITION spaceWidth = vsDraw.styles[ll->EndLineStyle()].spaceWidth;
832  					rcSegment.left = xStart + ll->positions[portion.start.Position() - posLineStart] -
833  						subLineStart+portion.start.VirtualSpace() * spaceWidth;
834  					rcSegment.right = xStart + ll->positions[portion.end.Position() - posLineStart] -
835  						subLineStart+portion.end.VirtualSpace() * spaceWidth;
836  					rcSegment.left = (rcSegment.left > rcLine.left) ? rcSegment.left : rcLine.left;
837  					rcSegment.right = (rcSegment.right < rcLine.right) ? rcSegment.right : rcLine.right;
838  					surface->FillRectangleAligned(rcSegment, Fill(
839  						SelectionBackground(model, vsDraw, model.sel.RangeType(r)).Opaque()));
840  				}
841  			}
842  		}
843  	}
844  	InSelection eolInSelection = InSelection::inNone;
845  	if (vsDraw.selection.visible && lastSubLine) {
846  		eolInSelection = model.LineEndInSelection(line);
847  	}
848  	const ColourRGBA selectionBack = SelectionBackground(model, vsDraw, eolInSelection);
849  	XYPOSITION blobsWidth = 0;
850  	if (lastSubLine) {
851  		for (Sci::Position eolPos = ll->numCharsBeforeEOL; eolPos<ll->numCharsInLine;) {
852  			const int styleMain = ll->styles[eolPos];
853  			const ColourOptional selectionFore = SelectionForeground(model, vsDraw, eolInSelection);
854  			ColourRGBA textFore = selectionFore.value_or(vsDraw.styles[styleMain].fore);
855  			char hexits[4] = "";
856  			std::string_view ctrlChar;
857  			Sci::Position widthBytes = 1;
858  			RepresentationAppearance appearance = RepresentationAppearance::Blob;
859  			const Representation *repr = model.reprs.RepresentationFromCharacter(std::string_view(&ll->chars[eolPos], ll->numCharsInLine - eolPos));
860  			if (repr) {
861  				widthBytes = ll->numCharsInLine - eolPos;
862  			} else {
863  				repr = model.reprs.RepresentationFromCharacter(std::string_view(&ll->chars[eolPos], 1));
864  			}
865  			if (repr) {
866  				ctrlChar = repr->stringRep;
867  				appearance = repr->appearance;
868  				if (FlagSet(appearance, RepresentationAppearance::Colour)) {
869  					textFore = repr->colour;
870  				}
871  			} else {
872  				const unsigned char chEOL = ll->chars[eolPos];
873  				if (UTF8IsAscii(chEOL)) {
874  					ctrlChar = ControlCharacterString(chEOL);
875  				} else {
876  					Hexits(hexits, chEOL);
877  					ctrlChar = hexits;
878  				}
879  			}
880  			rcSegment.left = xStart + ll->positions[eolPos] - subLineStart + virtualSpace;
881  			rcSegment.right = xStart + ll->positions[eolPos + widthBytes] - subLineStart + virtualSpace;
882  			blobsWidth += rcSegment.Width();
883  			const ColourRGBA textBack = TextBackground(model, vsDraw, ll, background, eolInSelection, false, styleMain, eolPos);
884  			if (eolInSelection && (line < model.pdoc->LinesTotal() - 1)) {
885  				if (vsDraw.selection.layer == Layer::Base) {
886  					surface->FillRectangleAligned(rcSegment, Fill(selectionBack.Opaque()));
887  				} else {
888  					surface->FillRectangleAligned(rcSegment, Fill(textBack));
889  				}
890  			} else {
891  				surface->FillRectangleAligned(rcSegment, Fill(textBack));
892  			}
893  			const bool drawEOLSelection = eolInSelection && (line < model.pdoc->LinesTotal() - 1);
894  			ColourRGBA blobText = textBack;
895  			if (drawEOLSelection && (vsDraw.selection.layer == Layer::UnderText)) {
896  				surface->FillRectangleAligned(rcSegment, selectionBack);
897  				blobText = textBack.MixedWith(selectionBack, selectionBack.GetAlphaComponent());
898  			}
899  			if (FlagSet(appearance, RepresentationAppearance::Blob)) {
900  				DrawTextBlob(surface, vsDraw, rcSegment, ctrlChar, blobText, textFore, phasesDraw == PhasesDraw::One);
901  			} else {
902  				surface->DrawTextTransparentUTF8(rcSegment, vsDraw.styles[StyleControlChar].font.get(),
903  					rcSegment.top + vsDraw.maxAscent, ctrlChar, textFore);
904  			}
905  			if (drawEOLSelection && (vsDraw.selection.layer == Layer::OverText)) {
906  				surface->FillRectangleAligned(rcSegment, selectionBack);
907  			}
908  			eolPos += widthBytes;
909  		}
910  	}
911  	rcSegment.left = xEol + xStart + virtualSpace + blobsWidth;
912  	rcSegment.right = rcSegment.left + vsDraw.aveCharWidth;
913  	if (eolInSelection && (line < model.pdoc->LinesTotal() - 1) && (vsDraw.selection.layer == Layer::Base)) {
914  		surface->FillRectangleAligned(rcSegment, Fill(selectionBack.Opaque()));
915  	} else {
916  		if (background) {
917  			surface->FillRectangleAligned(rcSegment, Fill(*background));
918  		} else if (line < model.pdoc->LinesTotal() - 1) {
919  			surface->FillRectangleAligned(rcSegment, Fill(vsDraw.styles[ll->styles[ll->numCharsInLine]].back));
920  		} else if (vsDraw.styles[ll->styles[ll->numCharsInLine]].eolFilled) {
921  			surface->FillRectangleAligned(rcSegment, Fill(vsDraw.styles[ll->styles[ll->numCharsInLine]].back));
922  		} else {
923  			surface->FillRectangleAligned(rcSegment, Fill(vsDraw.styles[StyleDefault].back));
924  		}
925  		if (eolInSelection && (line < model.pdoc->LinesTotal() - 1) && (vsDraw.selection.layer != Layer::Base)) {
926  			surface->FillRectangleAligned(rcSegment, selectionBack);
927  		}
928  	}
929  	rcSegment.left = rcSegment.right;
930  	if (rcSegment.left < rcLine.left)
931  		rcSegment.left = rcLine.left;
932  	rcSegment.right = rcLine.right;
933  	const bool drawEOLAnnotationStyledText = (vsDraw.eolAnnotationVisible != EOLAnnotationVisible::Hidden) && model.pdoc->EOLAnnotationStyledText(line).text;
934  	const bool fillRemainder = (!lastSubLine || (!model.GetFoldDisplayText(line) && !drawEOLAnnotationStyledText));
935  	if (fillRemainder) {
936  		FillLineRemainder(surface, model, vsDraw, ll, line, rcSegment, subLine);
937  	}
938  	bool drawWrapMarkEnd = false;
939  	if (subLine + 1 < ll->lines) {
940  		if (FlagSet(vsDraw.wrap.visualFlags, WrapVisualFlag::End)) {
941  			drawWrapMarkEnd = ll->LineStart(subLine + 1) != 0;
942  		}
943  		if (vsDraw.IsLineFrameOpaque(model.caret.active, ll->containsCaret)) {
944  			surface->FillRectangleAligned(Side(rcLine, Edge::right, vsDraw.GetFrameWidth()),
945  				vsDraw.ElementColourForced(Element::CaretLineBack).Opaque());
946  		}
947  	}
948  	if (drawWrapMarkEnd) {
949  		PRectangle rcPlace = rcSegment;
950  		const XYPOSITION maxLeft = rcPlace.right - vsDraw.aveCharWidth;
951  		if (FlagSet(vsDraw.wrap.visualFlagsLocation, WrapVisualLocation::EndByText)) {
952  			rcPlace.left = std::min(xEol + xStart + virtualSpace, maxLeft);
953  			rcPlace.right = rcPlace.left + vsDraw.aveCharWidth;
954  		} else {
955  			rcPlace.right = rcLine.right;
956  			rcPlace.left = maxLeft;
957  		}
958  		if (!customDrawWrapMarker) {
959  			DrawWrapMarker(surface, rcPlace, true, vsDraw.WrapColour());
960  		} else {
961  			customDrawWrapMarker(surface, rcPlace, true, vsDraw.WrapColour());
962  		}
963  	}
964  }
965  void EditView::DrawFoldDisplayText(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
966  							  Sci::Line line, int xStart, PRectangle rcLine, int subLine, XYPOSITION subLineStart, DrawPhase phase) {
967  	const bool lastSubLine = subLine == (ll->lines - 1);
968  	if (!lastSubLine)
969  		return;
970  	const char *text = model.GetFoldDisplayText(line);
971  	if (!text)
972  		return;
973  	PRectangle rcSegment = rcLine;
974  	const std::string_view foldDisplayText(text);
975  	const Font *fontText = vsDraw.styles[StyleFoldDisplayText].font.get();
976  	const int widthFoldDisplayText = static_cast<int>(surface->WidthText(fontText, foldDisplayText));
977  	InSelection eolInSelection = InSelection::inNone;
978  	if (vsDraw.selection.visible) {
979  		eolInSelection = model.LineEndInSelection(line);
980  	}
981  	const XYPOSITION spaceWidth = vsDraw.styles[ll->EndLineStyle()].spaceWidth;
982  	const XYPOSITION virtualSpace = model.sel.VirtualSpaceFor(
983  		model.pdoc->LineEnd(line)) * spaceWidth;
984  	rcSegment.left = xStart + ll->positions[ll->numCharsInLine] - subLineStart + virtualSpace + vsDraw.aveCharWidth;
985  	rcSegment.right = rcSegment.left + static_cast<XYPOSITION>(widthFoldDisplayText);
986  	const ColourOptional background = vsDraw.Background(model.GetMark(line), model.caret.active, ll->containsCaret);
987  	const ColourOptional selectionFore = SelectionForeground(model, vsDraw, eolInSelection);
988  	const ColourRGBA textFore = selectionFore.value_or(vsDraw.styles[StyleFoldDisplayText].fore);
989  	const ColourRGBA textBack = TextBackground(model, vsDraw, ll, background, eolInSelection,
990  											false, StyleFoldDisplayText, -1);
991  	if (model.trackLineWidth) {
992  		if (rcSegment.right + 1> lineWidthMaxSeen) {
993  			lineWidthMaxSeen = static_cast<int>(rcSegment.right + 1);
994  		}
995  	}
996  	if (FlagSet(phase, DrawPhase::back)) {
997  		surface->FillRectangleAligned(rcSegment, Fill(textBack));
998  		PRectangle rcRemainder = rcSegment;
999  		rcRemainder.left = rcRemainder.right;
1000  		if (rcRemainder.left < rcLine.left)
1001  			rcRemainder.left = rcLine.left;
1002  		rcRemainder.right = rcLine.right;
1003  		FillLineRemainder(surface, model, vsDraw, ll, line, rcRemainder, subLine);
1004  	}
1005  	if (FlagSet(phase, DrawPhase::text)) {
1006  		if (phasesDraw != PhasesDraw::One) {
1007  			surface->DrawTextTransparent(rcSegment, fontText,
1008  				rcSegment.top + vsDraw.maxAscent, foldDisplayText,
1009  				textFore);
1010  		} else {
1011  			surface->DrawTextNoClip(rcSegment, fontText,
1012  				rcSegment.top + vsDraw.maxAscent, foldDisplayText,
1013  				textFore, textBack);
1014  		}
1015  	}
1016  	if (FlagSet(phase, DrawPhase::indicatorsFore)) {
1017  		if (model.foldDisplayTextStyle == FoldDisplayTextStyle::Boxed) {
1018  			PRectangle rcBox = rcSegment;
1019  			rcBox.left = std::round(rcSegment.left);
1020  			rcBox.right = std::round(rcSegment.right);
1021  			surface->RectangleFrame(rcBox, Stroke(textFore));
1022  		}
1023  	}
1024  	if (FlagSet(phase, DrawPhase::selectionTranslucent)) {
1025  		if (eolInSelection && (line < model.pdoc->LinesTotal() - 1) && (vsDraw.selection.layer != Layer::Base)) {
1026  			surface->FillRectangleAligned(rcSegment, SelectionBackground(model, vsDraw, eolInSelection));
1027  		}
1028  	}
1029  }
1030  void EditView::DrawEOLAnnotationText(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
1031  	Sci::Line line, int xStart, PRectangle rcLine, int subLine, XYPOSITION subLineStart, DrawPhase phase) {
1032  	const bool lastSubLine = subLine == (ll->lines - 1);
1033  	if (!lastSubLine)
1034  		return;
1035  	if (vsDraw.eolAnnotationVisible == EOLAnnotationVisible::Hidden) {
1036  		return;
1037  	}
1038  	const StyledText stEOLAnnotation = model.pdoc->EOLAnnotationStyledText(line);
1039  	if (!stEOLAnnotation.text || !ValidStyledText(vsDraw, vsDraw.eolAnnotationStyleOffset, stEOLAnnotation)) {
1040  		return;
1041  	}
1042  	const std::string_view eolAnnotationText(stEOLAnnotation.text, stEOLAnnotation.length);
1043  	const size_t style = stEOLAnnotation.style + vsDraw.eolAnnotationStyleOffset;
1044  	PRectangle rcSegment = rcLine;
1045  	const Font *fontText = vsDraw.styles[style].font.get();
1046  	const Surface::Ends ends = static_cast<Surface::Ends>(static_cast<int>(vsDraw.eolAnnotationVisible) & 0xff);
1047  	const Surface::Ends leftSide = static_cast<Surface::Ends>(static_cast<int>(ends) & 0xf);
1048  	const Surface::Ends rightSide = static_cast<Surface::Ends>(static_cast<int>(ends) & 0xf0);
1049  	XYPOSITION leftBoxSpace = 0;
1050  	XYPOSITION rightBoxSpace = 0;
1051  	if (vsDraw.eolAnnotationVisible >= EOLAnnotationVisible::Boxed) {
1052  		leftBoxSpace = 1;
1053  		rightBoxSpace = 1;
1054  		if (vsDraw.eolAnnotationVisible != EOLAnnotationVisible::Boxed) {
1055  			switch (leftSide) {
1056  			case Surface::Ends::leftFlat:
1057  				leftBoxSpace = 1;
1058  				break;
1059  			case Surface::Ends::leftAngle:
1060  				leftBoxSpace = rcLine.Height() / 2.0;
1061  				break;
1062  			case Surface::Ends::semiCircles:
1063  			default:
1064  				leftBoxSpace = rcLine.Height() / 3.0;
1065  			   break;
1066  			}
1067  			switch (rightSide) {
1068  			case Surface::Ends::rightFlat:
1069  				rightBoxSpace = 1;
1070  				break;
1071  			case Surface::Ends::rightAngle:
1072  				rightBoxSpace = rcLine.Height() / 2.0;
1073  				break;
1074  			case Surface::Ends::semiCircles:
1075  			default:
1076  				rightBoxSpace = rcLine.Height() / 3.0;
1077  			   break;
1078  			}
1079  		}
1080  	}
1081  	const int widthEOLAnnotationText = static_cast<int>(surface->WidthTextUTF8(fontText, eolAnnotationText) +
1082  		leftBoxSpace + rightBoxSpace);
1083  	const XYPOSITION spaceWidth = vsDraw.styles[ll->EndLineStyle()].spaceWidth;
1084  	const XYPOSITION virtualSpace = model.sel.VirtualSpaceFor(
1085  		model.pdoc->LineEnd(line)) * spaceWidth;
1086  	rcSegment.left = xStart +
1087  		ll->positions[ll->numCharsInLine] - subLineStart
1088  		+ virtualSpace + vsDraw.aveCharWidth;
1089  	const char *textFoldDisplay = model.GetFoldDisplayText(line);
1090  	if (textFoldDisplay) {
1091  		const std::string_view foldDisplayText(textFoldDisplay);
1092  		rcSegment.left += static_cast<int>(
1093  			surface->WidthText(vsDraw.styles[StyleFoldDisplayText].font.get(), foldDisplayText)) +
1094  			vsDraw.aveCharWidth;
1095  	}
1096  	rcSegment.right = rcSegment.left + static_cast<XYPOSITION>(widthEOLAnnotationText);
1097  	const ColourOptional background = vsDraw.Background(model.GetMark(line), model.caret.active, ll->containsCaret);
1098  	const ColourRGBA textFore = vsDraw.styles[style].fore;
1099  	const ColourRGBA textBack = TextBackground(model, vsDraw, ll, background, InSelection::inNone,
1100  											false, static_cast<int>(style), -1);
1101  	if (model.trackLineWidth) {
1102  		if (rcSegment.right + 1> lineWidthMaxSeen) {
1103  			lineWidthMaxSeen = static_cast<int>(rcSegment.right + 1);
1104  		}
1105  	}
1106  	if (FlagSet(phase, DrawPhase::back)) {
1107  		PRectangle rcRemainder = rcSegment;
1108  		rcRemainder.right = rcLine.right;
1109  		FillLineRemainder(surface, model, vsDraw, ll, line, rcRemainder, subLine);
1110  	}
1111  	PRectangle rcText = rcSegment;
1112  	rcText.left += leftBoxSpace;
1113  	rcText.right -= rightBoxSpace;
1114  	if (FlagSet(phase, DrawPhase::text)) {
1115  		if (phasesDraw == PhasesDraw::One) {
1116  			surface->DrawTextNoClipUTF8(rcText, fontText,
1117  			rcText.top + vsDraw.maxAscent, eolAnnotationText,
1118  			textFore, textBack);
1119  		}
1120  	}
1121  	if (FlagSet(phase, DrawPhase::indicatorsBack)) {
1122  		const PRectangle rcBox = PixelAlign(rcSegment, 1);
1123  		switch (vsDraw.eolAnnotationVisible) {
1124  		case EOLAnnotationVisible::Standard:
1125  			if (phasesDraw != PhasesDraw::One) {
1126  				surface->FillRectangle(rcBox, textBack);
1127  			}
1128  			break;
1129  		case EOLAnnotationVisible::Boxed:
1130  			if (phasesDraw == PhasesDraw::One) {
1131  				surface->RectangleFrame(rcBox, textFore);
1132  			} else {
1133  				surface->RectangleDraw(rcBox, FillStroke(textBack, textFore));
1134  			}
1135  			break;
1136  		default:
1137  			if (phasesDraw == PhasesDraw::One) {
1138  				surface->Stadium(rcBox, FillStroke(ColourRGBA(textBack, 0), textFore), ends);
1139  			} else {
1140  				surface->Stadium(rcBox, FillStroke(textBack, textFore), ends);
1141  			}
1142  			break;
1143  		}
1144  	}
1145  	if (FlagSet(phase, DrawPhase::text)) {
1146  		if (phasesDraw != PhasesDraw::One) {
1147  			surface->DrawTextTransparentUTF8(rcText, fontText,
1148  				rcText.top + vsDraw.maxAscent, eolAnnotationText,
1149  				textFore);
1150  		}
1151  	}
1152  }
1153  namespace {
1154  constexpr bool AnnotationBoxedOrIndented(AnnotationVisible annotationVisible) noexcept {
1155  	return annotationVisible == AnnotationVisible::Boxed || annotationVisible == AnnotationVisible::Indented;
1156  }
1157  }
1158  void EditView::DrawAnnotation(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
1159  	Sci::Line line, int xStart, PRectangle rcLine, int subLine, DrawPhase phase) {
1160  	const int indent = static_cast<int>(model.pdoc->GetLineIndentation(line) * vsDraw.spaceWidth);
1161  	PRectangle rcSegment = rcLine;
1162  	const int annotationLine = subLine - ll->lines;
1163  	const StyledText stAnnotation = model.pdoc->AnnotationStyledText(line);
1164  	if (stAnnotation.text && ValidStyledText(vsDraw, vsDraw.annotationStyleOffset, stAnnotation)) {
1165  		if (FlagSet(phase, DrawPhase::back)) {
1166  			surface->FillRectangleAligned(rcSegment, Fill(vsDraw.styles[0].back));
1167  		}
1168  		rcSegment.left = static_cast<XYPOSITION>(xStart);
1169  		if (model.trackLineWidth || AnnotationBoxedOrIndented(vsDraw.annotationVisible)) {
1170  			int widthAnnotation = WidestLineWidth(surface, vsDraw, vsDraw.annotationStyleOffset, stAnnotation);
1171  			if (AnnotationBoxedOrIndented(vsDraw.annotationVisible)) {
1172  				widthAnnotation += static_cast<int>(vsDraw.spaceWidth * 2); 
1173  				rcSegment.left = static_cast<XYPOSITION>(xStart + indent);
1174  				rcSegment.right = rcSegment.left + widthAnnotation;
1175  			}
1176  			if (widthAnnotation > lineWidthMaxSeen)
1177  				lineWidthMaxSeen = widthAnnotation;
1178  		}
1179  		const int annotationLines = model.pdoc->AnnotationLines(line);
1180  		size_t start = 0;
1181  		size_t lengthAnnotation = stAnnotation.LineLength(start);
1182  		int lineInAnnotation = 0;
1183  		while ((lineInAnnotation < annotationLine) && (start < stAnnotation.length)) {
1184  			start += lengthAnnotation + 1;
1185  			lengthAnnotation = stAnnotation.LineLength(start);
1186  			lineInAnnotation++;
1187  		}
1188  		PRectangle rcText = rcSegment;
1189  		if ((FlagSet(phase, DrawPhase::back)) && AnnotationBoxedOrIndented(vsDraw.annotationVisible)) {
1190  			surface->FillRectangleAligned(rcText,
1191  				Fill(vsDraw.styles[stAnnotation.StyleAt(start) + vsDraw.annotationStyleOffset].back));
1192  			rcText.left += vsDraw.spaceWidth;
1193  		}
1194  		DrawStyledText(surface, vsDraw, vsDraw.annotationStyleOffset, rcText,
1195  			stAnnotation, start, lengthAnnotation, phase);
1196  		if ((FlagSet(phase, DrawPhase::back)) && (vsDraw.annotationVisible == AnnotationVisible::Boxed)) {
1197  			const ColourRGBA colourBorder = vsDraw.styles[vsDraw.annotationStyleOffset].fore;
1198  			const PRectangle rcBorder = PixelAlignOutside(rcSegment, surface->PixelDivisions());
1199  			surface->FillRectangle(Side(rcBorder, Edge::left, 1), colourBorder);
1200  			surface->FillRectangle(Side(rcBorder, Edge::right, 1), colourBorder);
1201  			if (subLine == ll->lines) {
1202  				surface->FillRectangle(Side(rcBorder, Edge::top, 1), colourBorder);
1203  			}
1204  			if (subLine == ll->lines + annotationLines - 1) {
1205  				surface->FillRectangle(Side(rcBorder, Edge::bottom, 1), colourBorder);
1206  			}
1207  		}
1208  	} else {
1209  		if (FlagSet(phase, DrawPhase::back)) {
1210  			surface->FillRectangle(rcSegment, bugColour.Opaque());
1211  		}
1212  	}
1213  }
1214  namespace {
1215  void DrawBlockCaret(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
1216  	int subLine, int xStart, Sci::Position offset, Sci::Position posCaret, PRectangle rcCaret, ColourRGBA caretColour) {
1217  	const Sci::Position lineStart = ll->LineStart(subLine);
1218  	Sci::Position posBefore = posCaret;
1219  	Sci::Position posAfter = model.pdoc->MovePositionOutsideChar(posCaret + 1, 1);
1220  	Sci::Position numCharsToDraw = posAfter - posCaret;
1221  	Sci::Position offsetFirstChar = offset;
1222  	Sci::Position offsetLastChar = offset + (posAfter - posCaret);
1223  	while ((posBefore > 0) && ((offsetLastChar - numCharsToDraw) >= lineStart)) {
1224  		if ((ll->positions[offsetLastChar] - ll->positions[offsetLastChar - numCharsToDraw]) > 0) {
1225  			break;
1226  		}
1227  		posBefore = model.pdoc->MovePositionOutsideChar(posBefore - 1, -1);
1228  		numCharsToDraw = posAfter - posBefore;
1229  		offsetFirstChar = offset - (posCaret - posBefore);
1230  	}
1231  	if (offsetFirstChar < 0)
1232  		offsetFirstChar = 0;
1233  	numCharsToDraw = offsetLastChar - offsetFirstChar;
1234  	while ((offsetLastChar < ll->LineStart(subLine + 1)) && (offsetLastChar <= ll->numCharsInLine)) {
1235  		posBefore = posAfter;
1236  		posAfter = model.pdoc->MovePositionOutsideChar(posAfter + 1, 1);
1237  		offsetLastChar = offset + (posAfter - posCaret);
1238  		if ((ll->positions[offsetLastChar] - ll->positions[offsetLastChar - (posAfter - posBefore)]) > 0) {
1239  			break;
1240  		}
1241  		numCharsToDraw = offsetLastChar - offsetFirstChar;
1242  	}
1243  	rcCaret.left = ll->positions[offsetFirstChar] - ll->positions[lineStart] + xStart;
1244  	rcCaret.right = ll->positions[offsetFirstChar + numCharsToDraw] - ll->positions[lineStart] + xStart;
1245  	if ((ll->wrapIndent != 0) && (lineStart != 0)) {
1246  		const XYPOSITION wordWrapCharWidth = ll->wrapIndent;
1247  		rcCaret.left += wordWrapCharWidth;
1248  		rcCaret.right += wordWrapCharWidth;
1249  	}
1250  	const int styleMain = ll->styles[offsetFirstChar];
1251  	const Font *fontText = vsDraw.styles[styleMain].font.get();
1252  	const std::string_view text(&ll->chars[offsetFirstChar], numCharsToDraw);
1253  	surface->DrawTextClipped(rcCaret, fontText,
1254  		rcCaret.top + vsDraw.maxAscent, text, vsDraw.styles[styleMain].back,
1255  		caretColour);
1256  }
1257  }
1258  void EditView::DrawCarets(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
1259  	Sci::Line lineDoc, int xStart, PRectangle rcLine, int subLine) const {
1260  	const bool drawDrag = model.posDrag.IsValid();
1261  	if (!vsDraw.selection.visible && !drawDrag)
1262  		return;
1263  	const Sci::Position posLineStart = model.pdoc->LineStart(lineDoc);
1264  	for (size_t r = 0; (r<model.sel.Count()) || drawDrag; r++) {
1265  		const bool mainCaret = r == model.sel.Main();
1266  		SelectionPosition posCaret = (drawDrag ? model.posDrag : model.sel.Range(r).caret);
1267  		if ((vsDraw.DrawCaretInsideSelection(model.inOverstrike, imeCaretBlockOverride)) &&
1268  			!drawDrag &&
1269  			posCaret > model.sel.Range(r).anchor) {
1270  			if (posCaret.VirtualSpace() > 0)
1271  				posCaret.SetVirtualSpace(posCaret.VirtualSpace() - 1);
1272  			else
1273  				posCaret.SetPosition(model.pdoc->MovePositionOutsideChar(posCaret.Position()-1, -1));
1274  		}
1275  		const int offset = static_cast<int>(posCaret.Position() - posLineStart);
1276  		const XYPOSITION spaceWidth = vsDraw.styles[ll->EndLineStyle()].spaceWidth;
1277  		const XYPOSITION virtualOffset = posCaret.VirtualSpace() * spaceWidth;
1278  		if (ll->InLine(offset, subLine) && offset <= ll->numCharsBeforeEOL) {
1279  			XYPOSITION xposCaret = ll->positions[offset] + virtualOffset - ll->positions[ll->LineStart(subLine)];
1280  			if (model.BidirectionalEnabled() && (posCaret.VirtualSpace() == 0)) {
1281  				const ScreenLine screenLine(ll, subLine, vsDraw, rcLine.right, tabWidthMinimumPixels);
1282  				const int caretPosition = offset - ll->LineStart(subLine);
1283  				std::unique_ptr<IScreenLineLayout> slLayout = surface->Layout(&screenLine);
1284  				const XYPOSITION caretLeft = slLayout->XFromPosition(caretPosition);
1285  				xposCaret = caretLeft + virtualOffset;
1286  			}
1287  			if (ll->wrapIndent != 0) {
1288  				const Sci::Position lineStart = ll->LineStart(subLine);
1289  				if (lineStart != 0)	
1290  					xposCaret += ll->wrapIndent;
1291  			}
1292  			const bool caretBlinkState = (model.caret.active && model.caret.on) || (!additionalCaretsBlink && !mainCaret);
1293  			const bool caretVisibleState = additionalCaretsVisible || mainCaret;
1294  			if ((xposCaret >= 0) && vsDraw.IsCaretVisible(mainCaret) &&
1295  				(drawDrag || (caretBlinkState && caretVisibleState))) {
1296  				bool canDrawBlockCaret = true;
1297  				bool drawBlockCaret = false;
1298  				XYPOSITION widthOverstrikeCaret;
1299  				XYPOSITION caretWidthOffset = 0;
1300  				PRectangle rcCaret = rcLine;
1301  				if (posCaret.Position() == model.pdoc->Length()) {   
1302  					canDrawBlockCaret = false;
1303  					widthOverstrikeCaret = vsDraw.aveCharWidth;
1304  				} else if ((posCaret.Position() - posLineStart) >= ll->numCharsInLine) {	
1305  					canDrawBlockCaret = false;
1306  					widthOverstrikeCaret = vsDraw.aveCharWidth;
1307  				} else {
1308  					const int widthChar = model.pdoc->LenChar(posCaret.Position());
1309  					widthOverstrikeCaret = ll->positions[offset + widthChar] - ll->positions[offset];
1310  				}
1311  				if (widthOverstrikeCaret < 3)	
1312  					widthOverstrikeCaret = 3;
1313  				if (xposCaret > 0)
1314  					caretWidthOffset = 0.51f;	
1315  				xposCaret += xStart;
1316  				const ViewStyle::CaretShape caretShape = drawDrag ? ViewStyle::CaretShape::line :
1317  					vsDraw.CaretShapeForMode(model.inOverstrike, mainCaret);
1318  				if (drawDrag) {
1319  					rcCaret.left = std::round(xposCaret - caretWidthOffset);
1320  					rcCaret.right = rcCaret.left + vsDraw.caret.width;
1321  				} else if ((caretShape == ViewStyle::CaretShape::bar) && drawOverstrikeCaret) {
1322  					rcCaret.top = rcCaret.bottom - 2;
1323  					rcCaret.left = xposCaret + 1;
1324  					rcCaret.right = rcCaret.left + widthOverstrikeCaret - 1;
1325  				} else if ((caretShape == ViewStyle::CaretShape::block) || imeCaretBlockOverride) {
1326  					rcCaret.left = xposCaret;
1327  					if (canDrawBlockCaret && !(IsControl(ll->chars[offset]))) {
1328  						drawBlockCaret = true;
1329  						rcCaret.right = xposCaret + widthOverstrikeCaret;
1330  					} else {
1331  						rcCaret.right = xposCaret + vsDraw.aveCharWidth;
1332  					}
1333  				} else {
1334  					rcCaret.left = std::round(xposCaret - caretWidthOffset);
1335  					rcCaret.right = rcCaret.left + vsDraw.caret.width;
1336  				}
1337  				const Element elementCaret = mainCaret ? Element::Caret : Element::CaretAdditional;
1338  				const ColourRGBA caretColour = vsDraw.ElementColourForced(elementCaret);
1339  				if (drawBlockCaret) {
1340  					DrawBlockCaret(surface, model, vsDraw, ll, subLine, xStart, offset, posCaret.Position(), rcCaret, caretColour);
1341  				} else {
1342  					surface->FillRectangleAligned(rcCaret, Fill(caretColour));
1343  				}
1344  			}
1345  		}
1346  		if (drawDrag)
1347  			break;
1348  	}
1349  }
1350  namespace {
1351  void DrawWrapIndentAndMarker(Surface *surface, const ViewStyle &vsDraw, const LineLayout *ll,
1352  	int xStart, PRectangle rcLine, ColourOptional background, DrawWrapMarkerFn customDrawWrapMarker,
1353  	bool caretActive) {
1354  	surface->FillRectangleAligned(rcLine, Fill(background.value_or(vsDraw.styles[StyleDefault].back)));
1355  	if (vsDraw.IsLineFrameOpaque(caretActive, ll->containsCaret)) {
1356  		surface->FillRectangleAligned(Side(rcLine, Edge::left, vsDraw.GetFrameWidth()),
1357  			vsDraw.ElementColourForced(Element::CaretLineBack).Opaque());
1358  	}
1359  	if (FlagSet(vsDraw.wrap.visualFlags, WrapVisualFlag::Start)) {
<span onclick='openModal()' class='match'>1360  		PRectangle rcPlace = rcLine;
1361  		rcPlace.left = static_cast<XYPOSITION>(xStart);
1362  		rcPlace.right = rcPlace.left + ll->wrapIndent;
</span>1363  		if (FlagSet(vsDraw.wrap.visualFlagsLocation, WrapVisualLocation::StartByText))
1364  			rcPlace.left = rcPlace.right - vsDraw.aveCharWidth;
1365  		else
1366  			rcPlace.right = rcPlace.left + vsDraw.aveCharWidth;
1367  		if (!customDrawWrapMarker) {
1368  			DrawWrapMarker(surface, rcPlace, false, vsDraw.WrapColour());
1369  		} else {
1370  			customDrawWrapMarker(surface, rcPlace, false, vsDraw.WrapColour());
1371  		}
1372  	}
1373  }
1374  InSelection CharacterInCursesSelection(Sci::Position iDoc, const EditModel &model, const ViewStyle &vsDraw) noexcept {
1375  	const SelectionPosition &posCaret = model.sel.RangeMain().caret;
1376  	const bool caretAtStart = posCaret < model.sel.RangeMain().anchor && posCaret.Position() == iDoc;
1377  	const bool caretAtEnd = posCaret > model.sel.RangeMain().anchor &&
1378  		vsDraw.DrawCaretInsideSelection(false, false) &&
1379  		model.pdoc->MovePositionOutsideChar(posCaret.Position() - 1, -1) == iDoc;
1380  	return (caretAtStart || caretAtEnd) ? InSelection::inNone : InSelection::inMain;
1381  }
1382  void DrawBackground(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
1383  	int xStart, PRectangle rcLine, int subLine, Range lineRange, Sci::Position posLineStart,
1384  	ColourOptional background) {
1385  	const bool selBackDrawn = vsDraw.SelectionBackgroundDrawn();
1386  	bool inIndentation = subLine == 0;	
1387  	const XYPOSITION subLineStart = ll->positions[lineRange.start];
1388  	const XYPOSITION horizontalOffset = xStart - subLineStart;
1389  	const XYPOSITION xStartVisible = subLineStart - xStart;
1390  	const BreakFinder::BreakFor breakFor = selBackDrawn ? BreakFinder::BreakFor::Selection : BreakFinder::BreakFor::Text;
1391  	BreakFinder bfBack(ll, &model.sel, lineRange, posLineStart, xStartVisible, breakFor, model.pdoc, &model.reprs, &vsDraw);
1392  	const bool drawWhitespaceBackground = vsDraw.WhitespaceBackgroundDrawn() && !background;
1393  	while (bfBack.More()) {
1394  		const TextSegment ts = bfBack.Next();
1395  		const Sci::Position i = ts.end() - 1;
1396  		const Sci::Position iDoc = i + posLineStart;
1397  		const Interval horizontal = ll->Span(ts.start, ts.end()).Offset(horizontalOffset);
1398  		if (!horizontal.Empty() && rcLine.Intersects(horizontal)) {
1399  			const PRectangle rcSegment = Intersection(rcLine, horizontal);
1400  			InSelection inSelection = vsDraw.selection.visible ? model.sel.CharacterInSelection(iDoc) : InSelection::inNone;
1401  			if (FlagSet(vsDraw.caret.style, CaretStyle::Curses) && (inSelection == InSelection::inMain))
1402  				inSelection = CharacterInCursesSelection(iDoc, model, vsDraw);
1403  			const bool inHotspot = model.hotspot.Valid() && model.hotspot.ContainsCharacter(iDoc);
1404  			ColourRGBA textBack = TextBackground(model, vsDraw, ll, background, inSelection,
1405  				inHotspot, ll->styles[i], i);
1406  			if (ts.representation) {
1407  				if (ll->chars[i] == '\t') {
1408  					if (drawWhitespaceBackground && vsDraw.WhiteSpaceVisible(inIndentation)) {
1409  						textBack = vsDraw.ElementColourForced(Element::WhiteSpaceBack).Opaque();
1410  					}
1411  				} else {
1412  					inIndentation = false;
1413  				}
1414  				surface->FillRectangleAligned(rcSegment, Fill(textBack));
1415  			} else {
1416  				surface->FillRectangleAligned(rcSegment, Fill(textBack));
1417  				if (vsDraw.viewWhitespace != WhiteSpace::Invisible) {
1418  					for (int cpos = 0; cpos <= i - ts.start; cpos++) {
1419  						if (ll->chars[cpos + ts.start] == ' ') {
1420  							if (drawWhitespaceBackground && vsDraw.WhiteSpaceVisible(inIndentation)) {
1421  								const PRectangle rcSpace = Intersection(rcLine,
1422  									ll->SpanByte(cpos + ts.start).Offset(horizontalOffset));
1423  								surface->FillRectangleAligned(rcSpace,
1424  									vsDraw.ElementColourForced(Element::WhiteSpaceBack).Opaque());
1425  							}
1426  						} else {
1427  							inIndentation = false;
1428  						}
1429  					}
1430  				}
1431  			}
1432  		} else if (horizontal.left > rcLine.right) {
1433  			break;
1434  		}
1435  	}
1436  }
1437  void DrawEdgeLine(Surface *surface, const ViewStyle &vsDraw, const LineLayout *ll,
1438  	int xStart, PRectangle rcLine, Range lineRange) {
1439  	if (vsDraw.edgeState == EdgeVisualStyle::Line) {
1440  		PRectangle rcSegment = rcLine;
1441  		const int edgeX = static_cast<int>(vsDraw.theEdge.column * vsDraw.spaceWidth);
1442  		rcSegment.left = static_cast<XYPOSITION>(edgeX + xStart);
1443  		if ((ll->wrapIndent != 0) && (lineRange.start != 0))
1444  			rcSegment.left -= ll->wrapIndent;
1445  		rcSegment.right = rcSegment.left + 1;
1446  		surface->FillRectangleAligned(rcSegment, Fill(vsDraw.theEdge.colour));
1447  	} else if (vsDraw.edgeState == EdgeVisualStyle::MultiLine) {
1448  		for (size_t edge = 0; edge < vsDraw.theMultiEdge.size(); edge++) {
1449  			if (vsDraw.theMultiEdge[edge].column >= 0) {
1450  				PRectangle rcSegment = rcLine;
1451  				const int edgeX = static_cast<int>(vsDraw.theMultiEdge[edge].column * vsDraw.spaceWidth);
1452  				rcSegment.left = static_cast<XYPOSITION>(edgeX + xStart);
1453  				if ((ll->wrapIndent != 0) && (lineRange.start != 0))
1454  					rcSegment.left -= ll->wrapIndent;
1455  				rcSegment.right = rcSegment.left + 1;
1456  				surface->FillRectangleAligned(rcSegment, Fill(vsDraw.theMultiEdge[edge].colour));
1457  			}
1458  		}
1459  	}
1460  }
1461  void DrawMarkUnderline(Surface *surface, const EditModel &model, const ViewStyle &vsDraw,
1462  	Sci::Line line, PRectangle rcLine) {
1463  	int marks = model.GetMark(line);
1464  	for (int markBit = 0; (markBit < 32) && marks; markBit++) {
1465  		if ((marks & 1) && (vsDraw.markers[markBit].markType == MarkerSymbol::Underline) &&
1466  			(vsDraw.markers[markBit].layer == Layer::Base)) {
1467  			PRectangle rcUnderline = rcLine;
1468  			rcUnderline.top = rcUnderline.bottom - 2;
1469  			surface->FillRectangleAligned(rcUnderline, Fill(vsDraw.markers[markBit].back));
1470  		}
1471  		marks >>= 1;
1472  	}
1473  }
1474  void DrawTranslucentSelection(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
1475  	Sci::Line line, int xStart, PRectangle rcLine, int subLine, Range lineRange, int tabWidthMinimumPixels, Layer layer) {
1476  	if (vsDraw.selection.layer == layer) {
1477  		const Sci::Position posLineStart = model.pdoc->LineStart(line);
1478  		const XYPOSITION subLineStart = ll->positions[lineRange.start];
1479  		const XYPOSITION horizontalOffset = xStart - subLineStart;
1480  		Sci::Position virtualSpaces = 0;
1481  		if (subLine == (ll->lines - 1)) {
1482  			virtualSpaces = model.sel.VirtualSpaceFor(model.pdoc->LineEnd(line));
1483  		}
1484  		const SelectionPosition posStart(posLineStart + lineRange.start);
1485  		const SelectionPosition posEnd(posLineStart + lineRange.end, virtualSpaces);
1486  		const SelectionSegment virtualSpaceRange(posStart, posEnd);
1487  		for (size_t r = 0; r < model.sel.Count(); r++) {
1488  			const SelectionSegment portion = model.sel.Range(r).Intersect(virtualSpaceRange);
1489  			if (!portion.Empty()) {
1490  				const SelectionSegment portionInLine = portion.Subtract(posLineStart);
1491  				const ColourRGBA selectionBack = SelectionBackground(
1492  					model, vsDraw, model.sel.RangeType(r));
1493  				const XYPOSITION spaceWidth = vsDraw.styles[ll->EndLineStyle()].spaceWidth;
1494  				const Interval intervalVirtual{ portion.start.VirtualSpace() * spaceWidth, portion.end.VirtualSpace() * spaceWidth };
1495  				if (model.BidirectionalEnabled()) {
1496  					const SelectionSegment portionInSubLine = portionInLine.Subtract(lineRange.start);
1497  					const ScreenLine screenLine(ll, subLine, vsDraw, rcLine.right, tabWidthMinimumPixels);
1498  					std::unique_ptr<IScreenLineLayout> slLayout = surface->Layout(&screenLine);
1499  					if (slLayout) {
1500  						const std::vector<Interval> intervals = slLayout->FindRangeIntervals(
1501  							portionInSubLine.start.Position(), portionInSubLine.end.Position());
1502  						for (const Interval &interval : intervals) {
1503  							const PRectangle rcSelection = rcLine.WithHorizontalBounds(interval.Offset(xStart));
1504  							surface->FillRectangleAligned(rcSelection, selectionBack);
1505  						}
1506  					}
1507  					if (portion.end.VirtualSpace()) {
1508  						const XYPOSITION xStartVirtual = ll->positions[lineRange.end] + horizontalOffset;
1509  						const PRectangle rcSegment = rcLine.WithHorizontalBounds(intervalVirtual.Offset(xStartVirtual));
1510  						surface->FillRectangleAligned(rcSegment, selectionBack);
1511  					}
1512  				} else {
1513  					Interval intervalSegment = ll->Span(
1514  						static_cast<int>(portionInLine.start.Position()),
1515  						static_cast<int>(portionInLine.end.Position()))
1516  						.Offset(horizontalOffset);
1517  					intervalSegment.left += intervalVirtual.left;
1518  					intervalSegment.right += intervalVirtual.right;
1519  					if ((ll->wrapIndent != 0) && (lineRange.start != 0)) {
1520  						if ((portionInLine.start.Position() == lineRange.start) &&
1521  							model.sel.Range(r).ContainsCharacter(portion.start.Position() - 1))
1522  							intervalSegment.left -= static_cast<int>(ll->wrapIndent); 
1523  					}
1524  					const PRectangle rcSegment = Intersection(rcLine, intervalSegment);
1525  					if (rcSegment.right > rcLine.left)
1526  						surface->FillRectangleAligned(rcSegment, selectionBack);
1527  				}
1528  			}
1529  		}
1530  	}
1531  }
1532  void DrawCaretLineFramed(Surface *surface, const ViewStyle &vsDraw, const LineLayout *ll,
1533  	PRectangle rcLine, int subLine) {
1534  	const ColourOptional caretlineBack = vsDraw.ElementColour(Element::CaretLineBack);
1535  	if (!caretlineBack) {
1536  		return;
1537  	}
1538  	const ColourRGBA colourFrame = (vsDraw.caretLine.layer == Layer::Base) ?
1539  		caretlineBack->Opaque() : *caretlineBack;
1540  	const int width = vsDraw.GetFrameWidth();
1541  	const PRectangle rcWithoutLeftRight = rcLine.Inset(Point(width, 0.0));
1542  	if (subLine == 0 || ll->wrapIndent == 0 || vsDraw.caretLine.layer != Layer::Base || vsDraw.caretLine.subLine) {
1543  		surface->FillRectangleAligned(Side(rcLine, Edge::left, width), colourFrame);
1544  	}
1545  	if (subLine == 0 || vsDraw.caretLine.subLine) {
1546  		surface->FillRectangleAligned(Side(rcWithoutLeftRight, Edge::top, width), colourFrame);
1547  	}
1548  	if (subLine == ll->lines - 1 || vsDraw.caretLine.layer != Layer::Base || vsDraw.caretLine.subLine) {
1549  		surface->FillRectangleAligned(Side(rcLine, Edge::right, width), colourFrame);
1550  	}
1551  	if (subLine == ll->lines - 1 || vsDraw.caretLine.subLine) {
1552  		surface->FillRectangleAligned(Side(rcWithoutLeftRight, Edge::bottom, width), colourFrame);
1553  	}
1554  }
1555  void DrawTranslucentLineState(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
1556  	Sci::Line line, PRectangle rcLine, int subLine, Layer layer) {
1557  	if ((model.caret.active || vsDraw.caretLine.alwaysShow) && vsDraw.ElementColour(Element::CaretLineBack) && ll->containsCaret &&
1558  		vsDraw.caretLine.layer == layer) {
1559  		if (vsDraw.caretLine.frame) {
1560  			DrawCaretLineFramed(surface, vsDraw, ll, rcLine, subLine);
1561  		} else {
1562  			surface->FillRectangleAligned(rcLine, vsDraw.ElementColourForced(Element::CaretLineBack));
1563  		}
1564  	}
1565  	const int marksOfLine = model.GetMark(line);
1566  	int marksDrawnInText = marksOfLine & vsDraw.maskDrawInText;
1567  	for (int markBit = 0; (markBit < 32) && marksDrawnInText; markBit++) {
1568  		if ((marksDrawnInText & 1) && (vsDraw.markers[markBit].layer == layer)) {
1569  			if (vsDraw.markers[markBit].markType == MarkerSymbol::Background) {
1570  				surface->FillRectangleAligned(rcLine, vsDraw.markers[markBit].BackWithAlpha());
1571  			} else if (vsDraw.markers[markBit].markType == MarkerSymbol::Underline) {
1572  				PRectangle rcUnderline = rcLine;
1573  				rcUnderline.top = rcUnderline.bottom - 2;
1574  				surface->FillRectangleAligned(rcUnderline, vsDraw.markers[markBit].BackWithAlpha());
1575  			}
1576  		}
1577  		marksDrawnInText >>= 1;
1578  	}
1579  	int marksDrawnInLine = marksOfLine & vsDraw.maskInLine;
1580  	for (int markBit = 0; (markBit < 32) && marksDrawnInLine; markBit++) {
1581  		if ((marksDrawnInLine & 1) && (vsDraw.markers[markBit].layer == layer)) {
1582  			surface->FillRectangleAligned(rcLine, vsDraw.markers[markBit].BackWithAlpha());
1583  		}
1584  		marksDrawnInLine >>= 1;
1585  	}
1586  }
1587  void DrawTabArrow(Surface *surface, PRectangle rcTab, int ymid,
1588  	const ViewStyle &vsDraw, Stroke stroke) {
1589  	const XYPOSITION halfWidth = stroke.width / 2.0;
1590  	const XYPOSITION leftStroke = std::round(std::min(rcTab.left + 2, rcTab.right - 1)) + halfWidth;
1591  	const XYPOSITION rightStroke = std::max(leftStroke, std::round(rcTab.right) - 1.0f - halfWidth);
1592  	const XYPOSITION yMidAligned = ymid + halfWidth;
1593  	const Point arrowPoint(rightStroke, yMidAligned);
1594  	if (rightStroke > leftStroke) {
1595  		surface->LineDraw(Point(leftStroke, yMidAligned), arrowPoint, stroke);
1596  	}
1597  	if (vsDraw.tabDrawMode == TabDrawMode::LongArrow) {
1598  		XYPOSITION ydiff = std::floor(rcTab.Height() / 2.0f);
1599  		XYPOSITION xhead = rightStroke - ydiff;
1600  		if (xhead <= rcTab.left) {
1601  			ydiff -= rcTab.left - xhead;
1602  			xhead = rcTab.left;
1603  		}
1604  		const Point ptsHead[] = {
1605  			Point(xhead, yMidAligned - ydiff),
1606  			arrowPoint,
1607  			Point(xhead, yMidAligned + ydiff)
1608  		};
1609  		surface->PolyLine(ptsHead, std::size(ptsHead), stroke);
1610  	}
1611  }
1612  void DrawIndicator(int indicNum, Sci::Position startPos, Sci::Position endPos, Surface *surface, const ViewStyle &vsDraw,
1613  	const LineLayout *ll, int xStart, PRectangle rcLine, Sci::Position secondCharacter, int subLine, Indicator::State state,
1614  	int value, bool bidiEnabled, int tabWidthMinimumPixels) {
1615  	const XYPOSITION subLineStart = ll->positions[ll->LineStart(subLine)];
1616  	const XYPOSITION horizontalOffset = xStart - subLineStart;
1617  	std::vector<PRectangle> rectangles;
1618  	const XYPOSITION left = ll->XInLine(startPos) + horizontalOffset;
1619  	const XYPOSITION right = ll->XInLine(endPos) + horizontalOffset;
1620  	const PRectangle rcIndic(left, rcLine.top + vsDraw.maxAscent, right,
1621  		std::max(rcLine.top + vsDraw.maxAscent + 3, rcLine.bottom));
1622  	if (bidiEnabled) {
1623  		ScreenLine screenLine(ll, subLine, vsDraw, rcLine.right - xStart, tabWidthMinimumPixels);
1624  		const Range lineRange = ll->SubLineRange(subLine, LineLayout::Scope::visibleOnly);
1625  		std::unique_ptr<IScreenLineLayout> slLayout = surface->Layout(&screenLine);
1626  		std::vector<Interval> intervals = slLayout->FindRangeIntervals(
1627  			startPos - lineRange.start, endPos - lineRange.start);
1628  		for (const Interval &interval : intervals) {
1629  			PRectangle rcInterval = rcIndic;
1630  			rcInterval.left = interval.left + xStart;
1631  			rcInterval.right = interval.right + xStart;
1632  			rectangles.push_back(rcInterval);
1633  		}
1634  	} else {
1635  		rectangles.push_back(rcIndic);
1636  	}
1637  	for (const PRectangle &rc : rectangles) {
1638  		PRectangle rcFirstCharacter = rc;
1639  		rcFirstCharacter.bottom = rcLine.top + vsDraw.maxAscent + vsDraw.maxDescent;
1640  		if (secondCharacter >= 0) {
1641  			rcFirstCharacter.right = ll->XInLine(secondCharacter) + horizontalOffset;
1642  		} else {
1643  			rcFirstCharacter.right = rcFirstCharacter.left;
1644  		}
1645  		vsDraw.indicators[indicNum].Draw(surface, rc, rcLine, rcFirstCharacter, state, value);
1646  	}
1647  }
1648  void DrawIndicators(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
1649  	Sci::Line line, int xStart, PRectangle rcLine, int subLine, Sci::Position lineEnd, bool under, int tabWidthMinimumPixels) {
1650  	const Sci::Position posLineStart = model.pdoc->LineStart(line);
1651  	const Sci::Position lineStart = ll->LineStart(subLine);
1652  	const Sci::Position posLineEnd = posLineStart + lineEnd;
1653  	for (const IDecoration *deco : model.pdoc->decorations->View()) {
1654  		if (under == vsDraw.indicators[deco->Indicator()].under) {
1655  			Sci::Position startPos = posLineStart + lineStart;
1656  			while (startPos < posLineEnd) {
1657  				const Range rangeRun(deco->StartRun(startPos), deco->EndRun(startPos));
1658  				const Sci::Position endPos = std::min(rangeRun.end, posLineEnd);
1659  				const int value = deco->ValueAt(startPos);
1660  				if (value) {
1661  					const bool hover = vsDraw.indicators[deco->Indicator()].IsDynamic() &&
1662  						rangeRun.ContainsCharacter(model.hoverIndicatorPos);
1663  					const Indicator::State state = hover ? Indicator::State::hover : Indicator::State::normal;
1664  					const Sci::Position posSecond = model.pdoc->MovePositionOutsideChar(rangeRun.First() + 1, 1);
1665  					DrawIndicator(deco->Indicator(), startPos - posLineStart, endPos - posLineStart,
1666  						surface, vsDraw, ll, xStart, rcLine, posSecond - posLineStart, subLine, state,
1667  						value, model.BidirectionalEnabled(), tabWidthMinimumPixels);
1668  				}
1669  				startPos = endPos;
1670  			}
1671  		}
1672  	}
1673  	if ((vsDraw.braceHighlightIndicatorSet && (model.bracesMatchStyle == StyleBraceLight)) ||
1674  		(vsDraw.braceBadLightIndicatorSet && (model.bracesMatchStyle == StyleBraceBad))) {
1675  		const int braceIndicator = (model.bracesMatchStyle == StyleBraceLight) ? vsDraw.braceHighlightIndicator : vsDraw.braceBadLightIndicator;
1676  		if (under == vsDraw.indicators[braceIndicator].under) {
1677  			const Range rangeLine(posLineStart + lineStart, posLineEnd);
1678  			for (size_t brace = 0; brace <= 1; brace++) {
1679  				if (rangeLine.ContainsCharacter(model.braces[brace])) {
1680  					const Sci::Position braceOffset = model.braces[brace] - posLineStart;
1681  					if (braceOffset < ll->numCharsInLine) {
1682  						const Sci::Position braceEnd = model.pdoc->MovePositionOutsideChar(model.braces[brace] + 1, 1) - posLineStart;
1683  						DrawIndicator(braceIndicator, braceOffset, braceEnd,
1684  							surface, vsDraw, ll, xStart, rcLine, braceEnd, subLine, Indicator::State::normal,
1685  							1, model.BidirectionalEnabled(), tabWidthMinimumPixels);
1686  					}
1687  				}
1688  			}
1689  		}
1690  	}
1691  	if (FlagSet(model.changeHistoryOption, ChangeHistoryOption::Indicators)) {
1692  		constexpr int indexHistory = static_cast<int>(IndicatorNumbers::HistoryRevertedToOriginInsertion);
1693  		{
1694  			Sci::Position startPos = posLineStart + lineStart;
1695  			while (startPos < posLineEnd) {
1696  				const Range rangeRun(startPos, model.pdoc->EditionEndRun(startPos));
1697  				const Sci::Position endPos = std::min(rangeRun.end, posLineEnd);
1698  				const int edition = model.pdoc->EditionAt(startPos);
1699  				if (edition != 0) {
1700  					const int indicator = (edition - 1) * 2 + indexHistory;
1701  					const Sci::Position posSecond = model.pdoc->MovePositionOutsideChar(rangeRun.First() + 1, 1);
1702  					DrawIndicator(indicator, startPos - posLineStart, endPos - posLineStart,
1703  						surface, vsDraw, ll, xStart, rcLine, posSecond - posLineStart, subLine, Indicator::State::normal,
1704  						1, model.BidirectionalEnabled(), tabWidthMinimumPixels);
1705  				}
1706  				startPos = endPos;
1707  			}
1708  		}
1709  		{
1710  			Sci::Position startPos = posLineStart + lineStart;
1711  			while (startPos <= posLineEnd) {
1712  				const unsigned int editions = model.pdoc->EditionDeletesAt(startPos);
1713  				const Sci::Position posSecond = model.pdoc->MovePositionOutsideChar(startPos + 1, 1);
1714  				for (unsigned int edition = 0; edition < 4; edition++) {
1715  					if (editions & (1 << edition)) {
1716  						const int indicator = edition * 2 + indexHistory + 1;
1717  						DrawIndicator(indicator, startPos - posLineStart, posSecond - posLineStart,
1718  							surface, vsDraw, ll, xStart, rcLine, posSecond - posLineStart, subLine, Indicator::State::normal,
1719  							1, model.BidirectionalEnabled(), tabWidthMinimumPixels);
1720  					}
1721  				}
1722  				startPos = model.pdoc->EditionNextDelete(startPos);
1723  			}
1724  		}
1725  	}
1726  }
1727  void DrawFoldLines(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
1728  	Sci::Line line, PRectangle rcLine, int subLine) {
1729  	const bool lastSubLine = subLine == (ll->lines - 1);
1730  	const bool expanded = model.pcs->GetExpanded(line);
1731  	const FoldLevel level = model.pdoc->GetFoldLevel(line);
1732  	const FoldLevel levelNext = model.pdoc->GetFoldLevel(line + 1);
1733  	if (LevelIsHeader(level) &&
1734  		(LevelNumber(level) < LevelNumber(levelNext))) {
1735  		const ColourRGBA foldLineColour = vsDraw.ElementColour(Element::FoldLine).value_or(
1736  			vsDraw.styles[StyleDefault].fore);
1737  		if ((subLine == 0) &&
1738  			((expanded && (FlagSet(model.foldFlags, FoldFlag::LineBeforeExpanded)))
1739  				||
1740  				(!expanded && (FlagSet(model.foldFlags, FoldFlag::LineBeforeContracted))))) {
1741  			surface->FillRectangleAligned(Side(rcLine, Edge::top, 1.0), foldLineColour);
1742  		}
1743  		if (lastSubLine &&
1744  			((expanded && (FlagSet(model.foldFlags, FoldFlag::LineAfterExpanded)))
1745  				||
1746  				(!expanded && (FlagSet(model.foldFlags, FoldFlag::LineAfterContracted))))) {
1747  			surface->FillRectangleAligned(Side(rcLine, Edge::bottom, 1.0), foldLineColour);
1748  			if (!expanded) {
1749  				return;
1750  			}
1751  		}
1752  	}
1753  	if (lastSubLine && model.pcs->GetVisible(line) && !model.pcs->GetVisible(line + 1)) {
1754  		if (const ColourOptional hiddenLineColour = vsDraw.ElementColour(Element::HiddenLine)) {
1755  			surface->FillRectangleAligned(Side(rcLine, Edge::bottom, 1.0), *hiddenLineColour);
1756  		}
1757  	}
1758  }
1759  ColourRGBA InvertedLight(ColourRGBA orig) noexcept {
1760  	unsigned int r = orig.GetRed();
1761  	unsigned int g = orig.GetGreen();
1762  	unsigned int b = orig.GetBlue();
1763  	const unsigned int l = (r + g + b) / 3; 	
1764  	const unsigned int il = 0xff - l;
1765  	if (l == 0)
1766  		return ColourRGBA(0xff, 0xff, 0xff);
1767  	r = r * il / l;
1768  	g = g * il / l;
1769  	b = b * il / l;
1770  	return ColourRGBA(std::min(r, 0xffu), std::min(g, 0xffu), std::min(b, 0xffu));
1771  }
1772  }
1773  void EditView::DrawIndentGuide(Surface *surface, XYPOSITION start, PRectangle rcSegment, bool highlight, bool offset) {
1774  	const Point from = Point::FromInts(0, offset ? 1 : 0);
1775  	const PRectangle rcCopyArea(start + 1, rcSegment.top,
1776  		start + 2, rcSegment.bottom);
1777  	surface->Copy(rcCopyArea, from,
1778  		highlight ? *pixmapIndentGuideHighlight : *pixmapIndentGuide);
1779  }
1780  void EditView::DrawForeground(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
1781  	int xStart, PRectangle rcLine, int subLine, Sci::Line lineVisible, Range lineRange, Sci::Position posLineStart,
1782  	ColourOptional background) {
1783  	const bool selBackDrawn = vsDraw.SelectionBackgroundDrawn();
1784  	const bool drawWhitespaceBackground = vsDraw.WhitespaceBackgroundDrawn() && !background;
1785  	bool inIndentation = subLine == 0;	
1786  	const XYPOSITION subLineStart = ll->positions[lineRange.start];
1787  	const XYPOSITION horizontalOffset = xStart - subLineStart;
1788  	const XYPOSITION indentWidth = model.pdoc->IndentSize() * vsDraw.spaceWidth;
1789  	const XYPOSITION xStartVisible = subLineStart - xStart;
1790  	const bool offsetGuide = (lineVisible & 1) && (vsDraw.lineHeight & 1);
1791  	const XYPOSITION ybase = rcLine.top + vsDraw.maxAscent;
1792  	const BreakFinder::BreakFor breakFor = (((phasesDraw == PhasesDraw::One) && selBackDrawn) || vsDraw.SelectionTextDrawn())
1793  		? BreakFinder::BreakFor::ForegroundAndSelection : BreakFinder::BreakFor::Foreground;
1794  	BreakFinder bfFore(ll, &model.sel, lineRange, posLineStart, xStartVisible, breakFor, model.pdoc, &model.reprs, &vsDraw);
1795  	while (bfFore.More()) {
1796  		const TextSegment ts = bfFore.Next();
1797  		const Sci::Position i = ts.end() - 1;
1798  		const Sci::Position iDoc = i + posLineStart;
1799  		const Interval horizontal = ll->Span(ts.start, ts.end()).Offset(horizontalOffset);
1800  		if (rcLine.Intersects(horizontal)) {
1801  			const PRectangle rcSegment = rcLine.WithHorizontalBounds(horizontal);
1802  			const int styleMain = ll->styles[i];
1803  			ColourRGBA textFore = vsDraw.styles[styleMain].fore;
1804  			const Font *textFont = vsDraw.styles[styleMain].font.get();
1805  			const bool inHotspot = model.hotspot.Valid() && model.hotspot.ContainsCharacter(iDoc);
1806  			if (inHotspot) {
1807  				if (const ColourOptional colourHotSpot = vsDraw.ElementColour(Element::HotSpotActive)) {
1808  					textFore = *colourHotSpot;
1809  				}
1810  			}
1811  			if (vsDraw.indicatorsSetFore) {
1812  				for (const IDecoration *deco : model.pdoc->decorations->View()) {
1813  					const int indicatorValue = deco->ValueAt(ts.start + posLineStart);
1814  					if (indicatorValue) {
1815  						const Indicator &indicator = vsDraw.indicators[deco->Indicator()];
1816  						bool hover = false;
1817  						if (indicator.IsDynamic()) {
1818  							const Sci::Position startPos = ts.start + posLineStart;
1819  							const Range rangeRun(deco->StartRun(startPos), deco->EndRun(startPos));
1820  							hover =	rangeRun.ContainsCharacter(model.hoverIndicatorPos);
1821  						}
1822  						if (hover) {
1823  							if (indicator.sacHover.style == IndicatorStyle::TextFore || (indicator.sacHover.style == IndicatorStyle::ExplorerLink)) {
1824  								textFore = indicator.sacHover.fore;
1825  							}
1826  						} else {
1827  							if (indicator.sacNormal.style == IndicatorStyle::TextFore) {
1828  								if (FlagSet(indicator.Flags(), IndicFlag::ValueFore))
1829  									textFore = ColourRGBA::FromRGB(indicatorValue & static_cast<int>(IndicValue::Mask));
1830  								else
1831  									textFore = indicator.sacNormal.fore;
1832  							}
1833  						}
1834  					}
1835  				}
1836  			}
1837  			InSelection inSelection = vsDraw.selection.visible ? model.sel.CharacterInSelection(iDoc) : InSelection::inNone;
1838  			if (FlagSet(vsDraw.caret.style, CaretStyle::Curses) && (inSelection == InSelection::inMain))
1839  				inSelection = CharacterInCursesSelection(iDoc, model, vsDraw);
1840  			if (const ColourOptional selectionFore = SelectionForeground(model, vsDraw, inSelection)) {
1841  				textFore = *selectionFore;
1842  			}
1843  			ColourRGBA textBack = TextBackground(model, vsDraw, ll, background, inSelection, inHotspot, styleMain, i);
1844  			if (ts.representation) {
1845  				if (ll->chars[i] == '\t') {
1846  					if (phasesDraw == PhasesDraw::One) {
1847  						if (drawWhitespaceBackground && vsDraw.WhiteSpaceVisible(inIndentation))
1848  							textBack = vsDraw.ElementColourForced(Element::WhiteSpaceBack).Opaque();
1849  						surface->FillRectangleAligned(rcSegment, Fill(textBack));
1850  					}
1851  					if (inIndentation && vsDraw.viewIndentationGuides == IndentView::Real) {
1852  						const Interval intervalCharacter = ll->SpanByte(static_cast<int>(i));
1853  						for (int indentCount = static_cast<int>((intervalCharacter.left + epsilon) / indentWidth);
1854  							indentCount <= (intervalCharacter.right - epsilon) / indentWidth;
1855  							indentCount++) {
1856  							if (indentCount > 0) {
1857  								const XYPOSITION xIndent = std::floor(indentCount * indentWidth);
1858  								DrawIndentGuide(surface, xIndent + xStart, rcSegment, ll->xHighlightGuide == xIndent, offsetGuide);
1859  							}
1860  						}
1861  					}
1862  					if (vsDraw.viewWhitespace != WhiteSpace::Invisible) {
1863  						if (vsDraw.WhiteSpaceVisible(inIndentation)) {
1864  							const PRectangle rcTab(rcSegment.left + 1, rcSegment.top + tabArrowHeight,
1865  								rcSegment.right - 1, rcSegment.bottom - vsDraw.maxDescent);
1866  							const int segmentTop = static_cast<int>(rcSegment.top) + vsDraw.lineHeight / 2;
1867  							const ColourRGBA whiteSpaceFore = vsDraw.ElementColour(Element::WhiteSpace).value_or(textFore);
1868  							if (!customDrawTabArrow)
1869  								DrawTabArrow(surface, rcTab, segmentTop, vsDraw, Stroke(whiteSpaceFore, 1.0f));
1870  							else
1871  								customDrawTabArrow(surface, rcTab, segmentTop, vsDraw, Stroke(whiteSpaceFore, 1.0f));
1872  						}
1873  					}
1874  				} else {
1875  					inIndentation = false;
1876  					if (vsDraw.controlCharSymbol >= 32) {
1877  						const Font *ctrlCharsFont = vsDraw.styles[StyleControlChar].font.get();
1878  						const char cc[2] = { static_cast<char>(vsDraw.controlCharSymbol), '\0' };
1879  						surface->DrawTextNoClip(rcSegment, ctrlCharsFont,
1880  							ybase, cc, textBack, textFore);
1881  					} else {
1882  						if (FlagSet(ts.representation->appearance, RepresentationAppearance::Colour)) {
1883  							textFore = ts.representation->colour;
1884  						}
1885  						if (FlagSet(ts.representation->appearance, RepresentationAppearance::Blob)) {
1886  							DrawTextBlob(surface, vsDraw, rcSegment, ts.representation->stringRep,
1887  								textBack, textFore, phasesDraw == PhasesDraw::One);
1888  						} else {
1889  							surface->DrawTextTransparentUTF8(rcSegment, vsDraw.styles[StyleControlChar].font.get(),
1890  								ybase, ts.representation->stringRep, textFore);
1891  						}
1892  					}
1893  				}
1894  			} else {
1895  				if (vsDraw.styles[styleMain].visible) {
1896  					const std::string_view text(&ll->chars[ts.start], i - ts.start + 1);
1897  					if (phasesDraw != PhasesDraw::One) {
1898  						surface->DrawTextTransparent(rcSegment, textFont,
1899  							ybase, text, textFore);
1900  					} else {
1901  						surface->DrawTextNoClip(rcSegment, textFont,
1902  							ybase, text, textFore, textBack);
1903  					}
1904  				} else if (vsDraw.styles[styleMain].invisibleRepresentation[0]) {
1905  					const std::string_view text = vsDraw.styles[styleMain].invisibleRepresentation;
1906    					if (phasesDraw != PhasesDraw::One) {
1907  						surface->DrawTextTransparentUTF8(rcSegment, textFont,
1908  							ybase, text, textFore);
1909  					} else {
1910  						surface->DrawTextNoClipUTF8(rcSegment, textFont,
1911  							ybase, text, textFore, textBack);
1912  					}
1913  				}
1914  				if (vsDraw.viewWhitespace != WhiteSpace::Invisible ||
1915  					(inIndentation && vsDraw.viewIndentationGuides != IndentView::None)) {
1916  					for (int cpos = 0; cpos <= i - ts.start; cpos++) {
1917  						if (ll->chars[cpos + ts.start] == ' ') {
1918  							if (vsDraw.viewWhitespace != WhiteSpace::Invisible) {
1919  								if (vsDraw.WhiteSpaceVisible(inIndentation)) {
1920  									const Interval intervalSpace = ll->SpanByte(cpos + ts.start).Offset(horizontalOffset);
1921  									const XYPOSITION xmid = (intervalSpace.left + intervalSpace.right) / 2;
1922  									if ((phasesDraw == PhasesDraw::One) && drawWhitespaceBackground) {
1923  										textBack = vsDraw.ElementColourForced(Element::WhiteSpaceBack).Opaque();
1924  										const PRectangle rcSpace = rcLine.WithHorizontalBounds(intervalSpace);
1925  										surface->FillRectangleAligned(rcSpace, Fill(textBack));
1926  									}
1927  									const int halfDotWidth = vsDraw.whitespaceSize / 2;
1928  									PRectangle rcDot(xmid - halfDotWidth,
1929  										rcSegment.top + vsDraw.lineHeight / 2, 0.0f, 0.0f);
1930  									rcDot.right = rcDot.left + vsDraw.whitespaceSize;
1931  									rcDot.bottom = rcDot.top + vsDraw.whitespaceSize;
1932  									const ColourRGBA whiteSpaceFore = vsDraw.ElementColour(Element::WhiteSpace).value_or(textFore);
1933  									surface->FillRectangleAligned(rcDot, Fill(whiteSpaceFore));
1934  								}
1935  							}
1936  							if (inIndentation && vsDraw.viewIndentationGuides == IndentView::Real) {
1937  								const Interval intervalCharacter = ll->SpanByte(cpos + ts.start);
1938  								for (int indentCount = static_cast<int>((intervalCharacter.left + epsilon) / indentWidth);
1939  									indentCount <= (intervalCharacter.right - epsilon) / indentWidth;
1940  									indentCount++) {
1941  									if (indentCount > 0) {
1942  										const XYPOSITION xIndent = std::floor(indentCount * indentWidth);
1943  										DrawIndentGuide(surface, xIndent + xStart, rcSegment, ll->xHighlightGuide == xIndent, offsetGuide);
1944  									}
1945  								}
1946  							}
1947  						} else {
1948  							inIndentation = false;
1949  						}
1950  					}
1951  				}
1952  			}
1953  			if ((inHotspot && vsDraw.hotspotUnderline) || vsDraw.styles[styleMain].underline) {
1954  				PRectangle rcUL = rcSegment;
1955  				rcUL.top = ybase + 1;
1956  				rcUL.bottom = ybase + 2;
1957  				ColourRGBA colourUnderline = textFore;
1958  				if (inHotspot && vsDraw.hotspotUnderline) {
1959  					colourUnderline = vsDraw.ElementColour(Element::HotSpotActive).value_or(textFore);
1960  				}
1961  				surface->FillRectangleAligned(rcUL, colourUnderline);
1962  			}
1963  		} else if (horizontal.left > rcLine.right) {
1964  			break;
1965  		}
1966  	}
1967  }
1968  void EditView::DrawIndentGuidesOverEmpty(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
1969  	Sci::Line line, int xStart, PRectangle rcLine, int subLine, Sci::Line lineVisible) {
1970  	if ((vsDraw.viewIndentationGuides == IndentView::LookForward || vsDraw.viewIndentationGuides == IndentView::LookBoth)
1971  		&& (subLine == 0)) {
1972  		const Sci::Position posLineStart = model.pdoc->LineStart(line);
1973  		int indentSpace = model.pdoc->GetLineIndentation(line);
1974  		int xStartText = static_cast<int>(ll->positions[model.pdoc->GetLineIndentPosition(line) - posLineStart]);
1975  		Sci::Line lineLastWithText = line;
1976  		while (lineLastWithText > std::max(line - 20, static_cast<Sci::Line>(0)) && model.pdoc->IsWhiteLine(lineLastWithText)) {
1977  			lineLastWithText--;
1978  		}
1979  		if (lineLastWithText < line) {
1980  			xStartText = 100000;	
1981  			int indentLastWithText = model.pdoc->GetLineIndentation(lineLastWithText);
1982  			const int isFoldHeader = LevelIsHeader(model.pdoc->GetFoldLevel(lineLastWithText));
1983  			if (isFoldHeader) {
1984  				indentLastWithText += model.pdoc->IndentSize();
1985  			}
1986  			if (vsDraw.viewIndentationGuides == IndentView::LookForward) {
1987  				if (isFoldHeader) {
1988  					indentSpace = std::max(indentSpace, indentLastWithText);
1989  				}
1990  			} else {	
1991  				indentSpace = std::max(indentSpace, indentLastWithText);
1992  			}
1993  		}
1994  		Sci::Line lineNextWithText = line;
1995  		while (lineNextWithText < std::min(line + 20, model.pdoc->LinesTotal()) && model.pdoc->IsWhiteLine(lineNextWithText)) {
1996  			lineNextWithText++;
1997  		}
1998  		if (lineNextWithText > line) {
1999  			xStartText = 100000;	
2000  			indentSpace = std::max(indentSpace,
2001  				model.pdoc->GetLineIndentation(lineNextWithText));
2002  		}
2003  		const bool offsetGuide = (lineVisible & 1) && (vsDraw.lineHeight & 1);
2004  		for (int indentPos = model.pdoc->IndentSize(); indentPos < indentSpace; indentPos += model.pdoc->IndentSize()) {
2005  			const XYPOSITION xIndent = std::floor(indentPos * vsDraw.spaceWidth);
2006  			if (xIndent < xStartText) {
2007  				DrawIndentGuide(surface, xIndent + xStart, rcLine,	ll->xHighlightGuide == xIndent, offsetGuide);
2008  			}
2009  		}
2010  	}
2011  }
2012  void EditView::DrawLine(Surface *surface, const EditModel &model, const ViewStyle &vsDraw, const LineLayout *ll,
2013  	Sci::Line line, Sci::Line lineVisible, int xStart, PRectangle rcLine, int subLine, DrawPhase phase) {
2014  	if (subLine >= ll->lines) {
2015  		DrawAnnotation(surface, model, vsDraw, ll, line, xStart, rcLine, subLine, phase);
2016  		return; 
2017  	}
2018  	const bool clipLine = !bufferedDraw && !LinesOverlap();
2019  	if (clipLine) {
2020  		surface->SetClip(rcLine);
2021  	}
2022  	const ColourOptional background = vsDraw.Background(model.GetMark(line), model.caret.active, ll->containsCaret);
2023  	const Sci::Position posLineStart = model.pdoc->LineStart(line);
2024  	const Range lineRange = ll->SubLineRange(subLine, LineLayout::Scope::visibleOnly);
2025  	const Range lineRangeIncludingEnd = ll->SubLineRange(subLine, LineLayout::Scope::includeEnd);
2026  	const XYPOSITION subLineStart = ll->positions[lineRange.start];
2027  	if ((ll->wrapIndent != 0) && (subLine > 0)) {
2028  		if (FlagSet(phase, DrawPhase::back)) {
2029  			DrawWrapIndentAndMarker(surface, vsDraw, ll, xStart, rcLine, background, customDrawWrapMarker, model.caret.active);
2030  		}
2031  		xStart += static_cast<int>(ll->wrapIndent);
2032  	}
2033  	if (phasesDraw != PhasesDraw::One) {
2034  		if (FlagSet(phase, DrawPhase::back)) {
2035  			DrawBackground(surface, model, vsDraw, ll,
2036  				xStart, rcLine, subLine, lineRange, posLineStart,
2037  				background);
2038  			DrawFoldDisplayText(surface, model, vsDraw, ll, line, xStart, rcLine, subLine, subLineStart, DrawPhase::back);
2039  			DrawEOLAnnotationText(surface, model, vsDraw, ll, line, xStart, rcLine, subLine, subLineStart, DrawPhase::back);
2040  			phase = static_cast<DrawPhase>(static_cast<int>(phase) & ~static_cast<int>(DrawPhase::back));
2041  			DrawEOL(surface, model, vsDraw, ll,
2042  				line, xStart, rcLine, subLine, lineRange.end, subLineStart, background);
2043  			if (vsDraw.IsLineFrameOpaque(model.caret.active, ll->containsCaret))
2044  				DrawCaretLineFramed(surface, vsDraw, ll, rcLine, subLine);
2045  		}
2046  		if (FlagSet(phase, DrawPhase::indicatorsBack)) {
2047  			DrawIndicators(surface, model, vsDraw, ll, line, xStart, rcLine, subLine,
2048  				lineRangeIncludingEnd.end, true, tabWidthMinimumPixels);
2049  			DrawEdgeLine(surface, vsDraw, ll, xStart, rcLine, lineRange);
2050  			DrawMarkUnderline(surface, model, vsDraw, line, rcLine);
2051  		}
2052  	}
2053  	if (FlagSet(phase, DrawPhase::text)) {
2054  		if (vsDraw.selection.visible) {
2055  			DrawTranslucentSelection(surface, model, vsDraw, ll,
2056  				line, xStart, rcLine, subLine, lineRange, tabWidthMinimumPixels, Layer::UnderText);
2057  		}
2058  		DrawTranslucentLineState(surface, model, vsDraw, ll, line, rcLine, subLine, Layer::UnderText);
2059  		DrawForeground(surface, model, vsDraw, ll,
2060  			xStart, rcLine, subLine, lineVisible, lineRange, posLineStart,
2061  			background);
2062  	}
2063  	if (FlagSet(phase, DrawPhase::indentationGuides)) {
2064  		DrawIndentGuidesOverEmpty(surface, model, vsDraw, ll, line, xStart, rcLine, subLine, lineVisible);
2065  	}
2066  	if (FlagSet(phase, DrawPhase::indicatorsFore)) {
2067  		DrawIndicators(surface, model, vsDraw, ll, line, xStart, rcLine, subLine,
2068  			lineRangeIncludingEnd.end, false, tabWidthMinimumPixels);
2069  	}
2070  	DrawFoldDisplayText(surface, model, vsDraw, ll, line, xStart, rcLine, subLine, subLineStart, phase);
2071  	DrawEOLAnnotationText(surface, model, vsDraw, ll, line, xStart, rcLine, subLine, subLineStart, phase);
2072  	if (phasesDraw == PhasesDraw::One) {
2073  		DrawEOL(surface, model, vsDraw, ll,
2074  			line, xStart, rcLine, subLine, lineRange.end, subLineStart, background);
2075  		if (vsDraw.IsLineFrameOpaque(model.caret.active, ll->containsCaret))
2076  			DrawCaretLineFramed(surface, vsDraw, ll, rcLine, subLine);
2077  		DrawEdgeLine(surface, vsDraw, ll, xStart, rcLine, lineRange);
2078  		DrawMarkUnderline(surface, model, vsDraw, line, rcLine);
2079  	}
2080  	if (vsDraw.selection.visible && FlagSet(phase, DrawPhase::selectionTranslucent)) {
2081  		DrawTranslucentSelection(surface, model, vsDraw, ll,
2082  			line, xStart, rcLine, subLine, lineRange, tabWidthMinimumPixels, Layer::OverText);
2083  	}
2084  	if (FlagSet(phase, DrawPhase::lineTranslucent)) {
2085  		DrawTranslucentLineState(surface, model, vsDraw, ll, line, rcLine, subLine, Layer::OverText);
2086  	}
2087  	if (clipLine) {
2088  		surface->PopClip();
2089  	}
2090  }
2091  void EditView::PaintText(Surface *surfaceWindow, const EditModel &model, const ViewStyle &vsDraw,
2092  	PRectangle rcArea, PRectangle rcClient) {
2093  	const int leftTextOverlap = ((model.xOffset == 0) && (vsDraw.leftMarginWidth > 0)) ? 1 : 0;
2094  	if (rcArea.right > vsDraw.textStart - leftTextOverlap) {
2095  		Surface *surface = surfaceWindow;
2096  		if (bufferedDraw) {
2097  			surface = pixmapLine.get();
2098  			PLATFORM_ASSERT(pixmapLine->Initialised());
2099  		}
2100  		surface->SetMode(model.CurrentSurfaceMode());
2101  		const Point ptOrigin = model.GetVisibleOriginInMain();
2102  		const int screenLinePaintFirst = static_cast<int>(rcArea.top) / vsDraw.lineHeight;
2103  		const int xStart = vsDraw.textStart - model.xOffset + static_cast<int>(ptOrigin.x);
2104  		const SelectionPosition posCaret = model.posDrag.IsValid() ? model.posDrag : model.sel.RangeMain().caret;
2105  		const Sci::Line lineCaret = model.pdoc->SciLineFromPosition(posCaret.Position());
2106  		const int caretOffset = static_cast<int>(posCaret.Position() - model.pdoc->LineStart(lineCaret));
2107  		PRectangle rcTextArea = rcClient;
2108  		if (vsDraw.marginInside) {
2109  			rcTextArea.left += vsDraw.textStart;
2110  			rcTextArea.right -= vsDraw.rightMarginWidth;
2111  		} else {
2112  			rcTextArea = rcArea;
2113  		}
2114  		const bool clipping = !bufferedDraw && vsDraw.marginInside;
2115  		if (clipping) {
2116  			PRectangle rcClipText = rcTextArea;
2117  			rcClipText.left -= leftTextOverlap;
2118  			surfaceWindow->SetClip(rcClipText);
2119  		}
2120  #if defined(TIME_PAINTING)
2121  		double durLayout = 0.0;
2122  		double durPaint = 0.0;
2123  		double durCopy = 0.0;
2124  		ElapsedPeriod epWhole;
2125  #endif
2126  		const bool bracesIgnoreStyle = ((vsDraw.braceHighlightIndicatorSet && (model.bracesMatchStyle == StyleBraceLight)) ||
2127  			(vsDraw.braceBadLightIndicatorSet && (model.bracesMatchStyle == StyleBraceBad)));
2128  		Sci::Line lineDocPrevious = -1;	
2129  		std::shared_ptr<LineLayout> ll;
2130  		std::vector<DrawPhase> phases;
2131  		if ((phasesDraw == PhasesDraw::Multiple) && !bufferedDraw) {
2132  			for (DrawPhase phase = DrawPhase::back; phase <= DrawPhase::carets; phase = static_cast<DrawPhase>(static_cast<int>(phase) * 2)) {
2133  				phases.push_back(phase);
2134  			}
2135  		} else {
2136  			phases.push_back(DrawPhase::all);
2137  		}
2138  		for (const DrawPhase &phase : phases) {
2139  			int ypos = 0;
2140  			if (!bufferedDraw)
2141  				ypos += screenLinePaintFirst * vsDraw.lineHeight;
2142  			int yposScreen = screenLinePaintFirst * vsDraw.lineHeight;
2143  			Sci::Line visibleLine = model.TopLineOfMain() + screenLinePaintFirst;
2144  			while (visibleLine < model.pcs->LinesDisplayed() && yposScreen < rcArea.bottom) {
2145  				const Sci::Line lineDoc = model.pcs->DocFromDisplay(visibleLine);
2146  				PLATFORM_ASSERT(model.pcs->GetVisible(lineDoc));
2147  				const Sci::Line lineStartSet = model.pcs->DisplayFromDoc(lineDoc);
2148  				const int subLine = static_cast<int>(visibleLine - lineStartSet);
2149  #if defined(TIME_PAINTING)
2150  				ElapsedPeriod ep;
2151  #endif
2152  				if (lineDoc != lineDocPrevious) {
2153  					ll = RetrieveLineLayout(lineDoc, model);
2154  					LayoutLine(model, surface, vsDraw, ll.get(), model.wrapWidth);
2155  					lineDocPrevious = lineDoc;
2156  				}
2157  #if defined(TIME_PAINTING)
2158  				durLayout += ep.Duration(true);
2159  #endif
2160  				if (ll) {
2161  					ll->containsCaret = vsDraw.selection.visible && (lineDoc == lineCaret)
2162  						&& (ll->lines == 1 || !vsDraw.caretLine.subLine || ll->InLine(caretOffset, subLine));
2163  					PRectangle rcLine = rcTextArea;
2164  					rcLine.top = static_cast<XYPOSITION>(ypos);
2165  					rcLine.bottom = static_cast<XYPOSITION>(ypos + vsDraw.lineHeight);
2166  					const Range rangeLine(model.pdoc->LineStart(lineDoc),
2167  						model.pdoc->LineStart(lineDoc + 1));
2168  					ll->SetBracesHighlight(rangeLine, model.braces, static_cast<char>(model.bracesMatchStyle),
2169  						static_cast<int>(model.highlightGuideColumn * vsDraw.spaceWidth), bracesIgnoreStyle);
2170  					if (leftTextOverlap && (bufferedDraw || ((phasesDraw < PhasesDraw::Multiple) && (FlagSet(phase, DrawPhase::back))))) {
2171  						PRectangle rcSpacer = rcLine;
2172  						rcSpacer.right = rcSpacer.left;
2173  						rcSpacer.left -= 1;
2174  						surface->FillRectangleAligned(rcSpacer, Fill(vsDraw.styles[StyleDefault].back));
2175  					}
2176  					if (model.BidirectionalEnabled()) {
2177  						UpdateBidiData(model, vsDraw, ll.get());
2178  					}
2179  					DrawLine(surface, model, vsDraw, ll.get(), lineDoc, visibleLine, xStart, rcLine, subLine, phase);
2180  #if defined(TIME_PAINTING)
2181  					durPaint += ep.Duration(true);
2182  #endif
2183  					ll->RestoreBracesHighlight(rangeLine, model.braces, bracesIgnoreStyle);
2184  					if (FlagSet(phase, DrawPhase::foldLines)) {
2185  						DrawFoldLines(surface, model, vsDraw, ll.get(), lineDoc, rcLine, subLine);
2186  					}
2187  					if (FlagSet(phase, DrawPhase::carets)) {
2188  						DrawCarets(surface, model, vsDraw, ll.get(), lineDoc, xStart, rcLine, subLine);
2189  					}
2190  					if (bufferedDraw) {
2191  						const Point from = Point::FromInts(vsDraw.textStart - leftTextOverlap, 0);
2192  						const PRectangle rcCopyArea = PRectangle::FromInts(vsDraw.textStart - leftTextOverlap, yposScreen,
2193  							static_cast<int>(rcClient.right - vsDraw.rightMarginWidth),
2194  							yposScreen + vsDraw.lineHeight);
2195  						pixmapLine->FlushDrawing();
2196  						surfaceWindow->Copy(rcCopyArea, from, *pixmapLine);
2197  					}
2198  					lineWidthMaxSeen = std::max(
2199  						lineWidthMaxSeen, static_cast<int>(ll->positions[ll->numCharsInLine]));
2200  #if defined(TIME_PAINTING)
2201  					durCopy += ep.Duration(true);
2202  #endif
2203  				}
2204  				if (!bufferedDraw) {
2205  					ypos += vsDraw.lineHeight;
2206  				}
2207  				yposScreen += vsDraw.lineHeight;
2208  				visibleLine++;
2209  			}
2210  		}
2211  		ll.reset();
2212  #if defined(TIME_PAINTING)
2213  		if (durPaint < 0.00000001)
2214  			durPaint = 0.00000001;
2215  #endif
2216  		PRectangle rcBeyondEOF = (vsDraw.marginInside) ? rcClient : rcArea;
2217  		rcBeyondEOF.left = static_cast<XYPOSITION>(vsDraw.textStart);
2218  		rcBeyondEOF.right = rcBeyondEOF.right - ((vsDraw.marginInside) ? vsDraw.rightMarginWidth : 0);
2219  		rcBeyondEOF.top = static_cast<XYPOSITION>((model.pcs->LinesDisplayed() - model.TopLineOfMain()) * vsDraw.lineHeight);
2220  		if (rcBeyondEOF.top < rcBeyondEOF.bottom) {
2221  			surfaceWindow->FillRectangleAligned(rcBeyondEOF, Fill(vsDraw.styles[StyleDefault].back));
2222  			if (vsDraw.edgeState == EdgeVisualStyle::Line) {
2223  				const int edgeX = static_cast<int>(vsDraw.theEdge.column * vsDraw.spaceWidth);
2224  				rcBeyondEOF.left = static_cast<XYPOSITION>(edgeX + xStart);
2225  				rcBeyondEOF.right = rcBeyondEOF.left + 1;
2226  				surfaceWindow->FillRectangleAligned(rcBeyondEOF, Fill(vsDraw.theEdge.colour));
2227  			} else if (vsDraw.edgeState == EdgeVisualStyle::MultiLine) {
2228  				for (size_t edge = 0; edge < vsDraw.theMultiEdge.size(); edge++) {
2229  					if (vsDraw.theMultiEdge[edge].column >= 0) {
2230  						const int edgeX = static_cast<int>(vsDraw.theMultiEdge[edge].column * vsDraw.spaceWidth);
2231  						rcBeyondEOF.left = static_cast<XYPOSITION>(edgeX + xStart);
2232  						rcBeyondEOF.right = rcBeyondEOF.left + 1;
2233  						surfaceWindow->FillRectangleAligned(rcBeyondEOF, Fill(vsDraw.theMultiEdge[edge].colour));
2234  					}
2235  				}
2236  			}
2237  		}
2238  		if (clipping)
2239  			surfaceWindow->PopClip();
2240  #if defined(TIME_PAINTING)
2241  		Platform::DebugPrintf(
2242  		"Layout:%9.6g    Paint:%9.6g    Ratio:%9.6g   Copy:%9.6g   Total:%9.6g\n",
2243  		durLayout, durPaint, durLayout / durPaint, durCopy, epWhole.Duration());
2244  #endif
2245  	}
2246  }
2247  #define lineNumberPrintSpace "   "
2248  Sci::Position EditView::FormatRange(bool draw, CharacterRangeFull chrg, Rectangle rc, Surface *surface, Surface *surfaceMeasure,
2249  	const EditModel &model, const ViewStyle &vs) {
2250  	posCache->Clear();
2251  	ViewStyle vsPrint(vs);
2252  	vsPrint.technology = Technology::Default;
2253  	int lineNumberIndex = -1;
2254  	for (size_t margin = 0; margin < vs.ms.size(); margin++) {
2255  		if ((vsPrint.ms[margin].style == MarginType::Number) && (vsPrint.ms[margin].width > 0)) {
2256  			lineNumberIndex = static_cast<int>(margin);
2257  		} else {
2258  			vsPrint.ms[margin].width = 0;
2259  		}
2260  	}
2261  	vsPrint.fixedColumnWidth = 0;
2262  	vsPrint.zoomLevel = printParameters.magnification;
2263  	vsPrint.viewIndentationGuides = IndentView::None;
2264  	vsPrint.selection.visible = false;
2265  	vsPrint.elementColours.clear();
2266  	vsPrint.elementBaseColours.clear();
2267  	vsPrint.caretLine.alwaysShow = false;
2268  	vsPrint.braceHighlightIndicatorSet = false;
2269  	vsPrint.braceBadLightIndicatorSet = false;
2270  	const PrintOption colourMode = printParameters.colourMode;
2271  	const std::vector<Style>::iterator endStyles = (colourMode == PrintOption::ColourOnWhiteDefaultBG) ?
2272  		vsPrint.styles.begin() + StyleLineNumber : vsPrint.styles.end();
2273  	for (std::vector<Style>::iterator it = vsPrint.styles.begin(); it != endStyles; ++it) {
2274  		if (colourMode == PrintOption::InvertLight) {
2275  			it->fore = InvertedLight(it->fore);
2276  			it->back = InvertedLight(it->back);
2277  		} else if (colourMode == PrintOption::BlackOnWhite) {
2278  			it->fore = ColourRGBA(0, 0, 0);
2279  			it->back = ColourRGBA(0xff, 0xff, 0xff);
2280  		} else if (colourMode == PrintOption::ColourOnWhite || colourMode == PrintOption::ColourOnWhiteDefaultBG) {
2281  			it->back = ColourRGBA(0xff, 0xff, 0xff);
2282  		}
2283  	}
2284  	if (colourMode != PrintOption::ScreenColours) {
2285  		vsPrint.styles[StyleLineNumber].back = ColourRGBA(0xff, 0xff, 0xff);
2286  	}
2287  	vsPrint.leftMarginWidth = 0;
2288  	vsPrint.rightMarginWidth = 0;
2289  	vsPrint.Refresh(*surfaceMeasure, model.pdoc->tabInChars);
2290  	int lineNumberWidth = 0;
2291  	if (lineNumberIndex >= 0) {
2292  		lineNumberWidth = static_cast<int>(surfaceMeasure->WidthText(vsPrint.styles[StyleLineNumber].font.get(),
2293  			"99999" lineNumberPrintSpace));
2294  		vsPrint.ms[lineNumberIndex].width = lineNumberWidth;
2295  		vsPrint.Refresh(*surfaceMeasure, model.pdoc->tabInChars);	
2296  	}
2297  	constexpr unsigned int changeMarkers =
2298  		1u << static_cast<unsigned int>(MarkerOutline::HistoryRevertedToOrigin) |
2299  		1u << static_cast<unsigned int>(MarkerOutline::HistorySaved) |
2300  		1u << static_cast<unsigned int>(MarkerOutline::HistoryModified) |
2301  		1u << static_cast<unsigned int>(MarkerOutline::HistoryRevertedToModified);
2302  	vsPrint.maskInLine &= ~changeMarkers;
2303  	const Sci::Line linePrintStart = model.pdoc->SciLineFromPosition(chrg.cpMin);
2304  	Sci::Line linePrintLast = linePrintStart + (rc.bottom - rc.top) / vsPrint.lineHeight - 1;
2305  	if (linePrintLast < linePrintStart)
2306  		linePrintLast = linePrintStart;
2307  	const Sci::Line linePrintMax = model.pdoc->SciLineFromPosition(chrg.cpMax);
2308  	if (linePrintLast > linePrintMax)
2309  		linePrintLast = linePrintMax;
2310  	Sci::Position endPosPrint = model.pdoc->Length();
2311  	if (linePrintLast < model.pdoc->LinesTotal())
2312  		endPosPrint = model.pdoc->LineStart(linePrintLast + 1);
2313  	model.pdoc->EnsureStyledTo(endPosPrint);
2314  	const int xStart = vsPrint.fixedColumnWidth + rc.left;
2315  	int ypos = rc.top;
2316  	Sci::Line lineDoc = linePrintStart;
2317  	Sci::Position nPrintPos = chrg.cpMin;
2318  	int visibleLine = 0;
2319  	int widthPrint = rc.right - rc.left - vsPrint.fixedColumnWidth;
2320  	if (printParameters.wrapState == Wrap::None)
2321  		widthPrint = LineLayout::wrapWidthInfinite;
2322  	while (lineDoc <= linePrintLast && ypos < rc.bottom) {
2323  		surfaceMeasure->FlushCachedState();
2324  		LineLayout ll(lineDoc, static_cast<int>(model.pdoc->LineStart(lineDoc + 1) - model.pdoc->LineStart(lineDoc) + 1));
2325  		LayoutLine(model, surfaceMeasure, vsPrint, &ll, widthPrint);
2326  		ll.containsCaret = false;
2327  		PRectangle rcLine = PRectangle::FromInts(
2328  			rc.left,
2329  			ypos,
2330  			rc.right - 1,
2331  			ypos + vsPrint.lineHeight);
2332  		if (visibleLine == 0) {
2333  			const Sci::Position startWithinLine = nPrintPos -
2334  				model.pdoc->LineStart(lineDoc);
2335  			for (int iwl = 0; iwl < ll.lines - 1; iwl++) {
2336  				if (ll.LineStart(iwl) <= startWithinLine && ll.LineStart(iwl + 1) >= startWithinLine) {
2337  					visibleLine = -iwl;
2338  				}
2339  			}
2340  			if (ll.lines > 1 && startWithinLine >= ll.LineStart(ll.lines - 1)) {
2341  				visibleLine = -(ll.lines - 1);
2342  			}
2343  		}
2344  		if (draw && lineNumberWidth &&
2345  			(ypos + vsPrint.lineHeight <= rc.bottom) &&
2346  			(visibleLine >= 0)) {
2347  			const std::string number = std::to_string(lineDoc + 1) + lineNumberPrintSpace;
2348  			PRectangle rcNumber = rcLine;
2349  			rcNumber.right = rcNumber.left + lineNumberWidth;
2350  			rcNumber.left = rcNumber.right - surfaceMeasure->WidthText(
2351  				vsPrint.styles[StyleLineNumber].font.get(), number);
2352  			surface->FlushCachedState();
2353  			surface->DrawTextNoClip(rcNumber, vsPrint.styles[StyleLineNumber].font.get(),
2354  				ypos + vsPrint.maxAscent, number,
2355  				vsPrint.styles[StyleLineNumber].fore,
2356  				vsPrint.styles[StyleLineNumber].back);
2357  		}
2358  		surface->FlushCachedState();
2359  		for (int iwl = 0; iwl < ll.lines; iwl++) {
2360  			if (ypos + vsPrint.lineHeight <= rc.bottom) {
2361  				if (visibleLine >= 0) {
2362  					if (draw) {
2363  						rcLine.top = static_cast<XYPOSITION>(ypos);
2364  						rcLine.bottom = static_cast<XYPOSITION>(ypos + vsPrint.lineHeight);
2365  						DrawLine(surface, model, vsPrint, &ll, lineDoc, visibleLine, xStart, rcLine, iwl, DrawPhase::all);
2366  					}
2367  					ypos += vsPrint.lineHeight;
2368  				}
2369  				visibleLine++;
2370  				if (iwl == ll.lines - 1)
2371  					nPrintPos = model.pdoc->LineStart(lineDoc + 1);
2372  				else
2373  					nPrintPos += ll.LineStart(iwl + 1) - ll.LineStart(iwl);
2374  			}
2375  		}
2376  		++lineDoc;
2377  	}
2378  	posCache->Clear();
2379  	return nPrintPos;
2380  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-EditView.cxx</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-EditView.cxx</div>
                </div>
                <div class="column column_space"><pre><code>2163  					PRectangle rcLine = rcTextArea;
2164  					rcLine.top = static_cast<XYPOSITION>(ypos);
2165  					rcLine.bottom = static_cast<XYPOSITION>(ypos + vsDraw.lineHeight);
</pre></code></div>
                <div class="column column_space"><pre><code>1360  		PRectangle rcPlace = rcLine;
1361  		rcPlace.left = static_cast<XYPOSITION>(xStart);
1362  		rcPlace.right = rcPlace.left + ll->wrapIndent;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    