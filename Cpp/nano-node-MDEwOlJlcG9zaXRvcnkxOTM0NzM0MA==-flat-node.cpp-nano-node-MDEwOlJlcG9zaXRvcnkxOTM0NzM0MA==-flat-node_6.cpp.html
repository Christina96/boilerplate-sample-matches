
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 34, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-node.cpp</h3>
            <pre><code>1  #include <nano/lib/config.hpp>
2  #include <nano/node/election.hpp>
3  #include <nano/node/scheduler/buckets.hpp>
4  #include <nano/node/scheduler/component.hpp>
5  #include <nano/node/transport/fake.hpp>
6  #include <nano/node/transport/inproc.hpp>
7  #include <nano/test_common/network.hpp>
8  #include <nano/test_common/system.hpp>
9  #include <nano/test_common/testutil.hpp>
10  #include <gtest/gtest.h>
11  #include <boost/filesystem.hpp>
12  #include <boost/make_shared.hpp>
13  #include <boost/optional.hpp>
14  #include <fstream>
15  #include <numeric>
16  using namespace std::chrono_literals;
17  TEST (node, null_account)
18  {
19  	auto const & null_account = nano::account::null ();
20  	ASSERT_TRUE (null_account == nullptr);
21  	ASSERT_FALSE (null_account != nullptr);
22  	nano::account default_account{};
23  	ASSERT_FALSE (default_account == nullptr);
24  	ASSERT_TRUE (default_account != nullptr);
25  }
26  TEST (node, stop)
27  {
28  	nano::test::system system (1);
29  	ASSERT_NE (system.nodes[0]->wallets.items.end (), system.nodes[0]->wallets.items.begin ());
30  	system.nodes[0]->stop ();
31  	system.io_ctx.run ();
32  	ASSERT_TRUE (true);
33  }
34  TEST (node, work_generate)
35  {
36  	nano::test::system system (1);
37  	auto & node (*system.nodes[0]);
38  	nano::block_hash root{ 1 };
39  	nano::work_version version{ nano::work_version::work_1 };
40  	{
41  		auto difficulty = nano::difficulty::from_multiplier (1.5, node.network_params.work.base);
42  		auto work = node.work_generate_blocking (version, root, difficulty);
43  		ASSERT_TRUE (work.is_initialized ());
44  		ASSERT_TRUE (nano::dev::network_params.work.difficulty (version, root, *work) >= difficulty);
45  	}
46  	{
47  		auto difficulty = nano::difficulty::from_multiplier (0.5, node.network_params.work.base);
48  		boost::optional<uint64_t> work;
49  		do
50  		{
51  			work = node.work_generate_blocking (version, root, difficulty);
52  		} while (nano::dev::network_params.work.difficulty (version, root, *work) >= node.network_params.work.base);
53  		ASSERT_TRUE (work.is_initialized ());
54  		ASSERT_TRUE (nano::dev::network_params.work.difficulty (version, root, *work) >= difficulty);
55  		ASSERT_FALSE (nano::dev::network_params.work.difficulty (version, root, *work) >= node.network_params.work.base);
56  	}
57  }
58  TEST (node, block_store_path_failure)
59  {
60  	nano::test::system system;
61  	auto service (boost::make_shared<boost::asio::io_context> ());
62  	auto path (nano::unique_path ());
63  	nano::logging logging;
64  	logging.init (path);
65  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
66  	auto node (std::make_shared<nano::node> (*service, system.get_available_port (), path, logging, pool));
67  	ASSERT_TRUE (node->wallets.items.empty ());
68  	node->stop ();
69  }
70  #if defined(__clang__) && defined(__linux__) && CI
71  TEST (node_DeathTest, DISABLED_readonly_block_store_not_exist)
72  #else
73  TEST (node_DeathTest, readonly_block_store_not_exist)
74  #endif
75  {
76  	if (nano::rocksdb_config::using_rocksdb_in_tests ())
77  	{
78  		nano::inactive_node node (nano::unique_path (), nano::inactive_node_flag_defaults ());
79  		ASSERT_TRUE (node.node->init_error ());
80  	}
81  	else
82  	{
83  		ASSERT_EXIT (nano::inactive_node node (nano::unique_path (), nano::inactive_node_flag_defaults ()), ::testing::ExitedWithCode (1), "");
84  	}
85  }
86  TEST (node, password_fanout)
87  {
88  	nano::test::system system;
89  	boost::asio::io_context io_ctx;
90  	auto path (nano::unique_path ());
91  	nano::node_config config;
92  	config.peering_port = system.get_available_port ();
93  	config.logging.init (path);
94  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
95  	config.password_fanout = 10;
96  	nano::node node (io_ctx, path, config, pool);
97  	auto wallet (node.wallets.create (100));
98  	ASSERT_EQ (10, wallet->store.password.values.size ());
99  	node.stop ();
100  }
101  TEST (node, balance)
102  {
103  	nano::test::system system (1);
104  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
105  	auto transaction (system.nodes[0]->store.tx_begin_write ());
106  	ASSERT_EQ (std::numeric_limits<nano::uint128_t>::max (), system.nodes[0]->ledger.account_balance (transaction, nano::dev::genesis_key.pub));
107  }
108  TEST (node, representative)
109  {
110  	nano::test::system system (1);
111  	auto block1 (system.nodes[0]->rep_block (nano::dev::genesis_key.pub));
112  	{
113  		auto transaction (system.nodes[0]->store.tx_begin_read ());
114  		ASSERT_TRUE (system.nodes[0]->ledger.store.block.exists (transaction, block1));
115  	}
116  	nano::keypair key;
117  	ASSERT_TRUE (system.nodes[0]->rep_block (key.pub).is_zero ());
118  }
119  TEST (node, send_unkeyed)
120  {
121  	nano::test::system system (1);
122  	nano::keypair key2;
123  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
124  	system.wallet (0)->store.password.value_set (nano::keypair ().prv);
125  	ASSERT_EQ (nullptr, system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, system.nodes[0]->config.receive_minimum.number ()));
126  }
127  TEST (node, send_self)
128  {
129  	nano::test::system system (1);
130  	nano::keypair key2;
131  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
132  	system.wallet (0)->insert_adhoc (key2.prv);
133  	ASSERT_NE (nullptr, system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, system.nodes[0]->config.receive_minimum.number ()));
134  	ASSERT_TIMELY (10s, !system.nodes[0]->balance (key2.pub).is_zero ());
135  	ASSERT_EQ (std::numeric_limits<nano::uint128_t>::max () - system.nodes[0]->config.receive_minimum.number (), system.nodes[0]->balance (nano::dev::genesis_key.pub));
136  }
137  TEST (node, send_single)
138  {
139  	nano::test::system system (2);
140  	nano::keypair key2;
141  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
142  	system.wallet (1)->insert_adhoc (key2.prv);
143  	ASSERT_NE (nullptr, system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, system.nodes[0]->config.receive_minimum.number ()));
144  	ASSERT_EQ (std::numeric_limits<nano::uint128_t>::max () - system.nodes[0]->config.receive_minimum.number (), system.nodes[0]->balance (nano::dev::genesis_key.pub));
145  	ASSERT_TRUE (system.nodes[0]->balance (key2.pub).is_zero ());
146  	ASSERT_TIMELY (10s, !system.nodes[0]->balance (key2.pub).is_zero ());
147  }
148  TEST (node, send_single_observing_peer)
149  {
150  	nano::test::system system (3);
151  	nano::keypair key2;
152  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
153  	system.wallet (1)->insert_adhoc (key2.prv);
154  	ASSERT_NE (nullptr, system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, system.nodes[0]->config.receive_minimum.number ()));
155  	ASSERT_EQ (std::numeric_limits<nano::uint128_t>::max () - system.nodes[0]->config.receive_minimum.number (), system.nodes[0]->balance (nano::dev::genesis_key.pub));
156  	ASSERT_TRUE (system.nodes[0]->balance (key2.pub).is_zero ());
157  	ASSERT_TIMELY (10s, std::all_of (system.nodes.begin (), system.nodes.end (), [&] (std::shared_ptr<nano::node> const & node_a) { return !node_a->balance (key2.pub).is_zero (); }));
158  }
159  TEST (node, send_out_of_order)
160  {
161  	nano::test::system system (2);
162  	auto & node1 (*system.nodes[0]);
163  	nano::keypair key2;
164  	nano::send_block_builder builder;
165  	auto send1 = builder.make_block ()
166  				 .previous (nano::dev::genesis->hash ())
167  				 .destination (key2.pub)
168  				 .balance (std::numeric_limits<nano::uint128_t>::max () - node1.config.receive_minimum.number ())
169  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
170  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
171  				 .build_shared ();
172  	auto send2 = builder.make_block ()
173  				 .previous (send1->hash ())
174  				 .destination (key2.pub)
175  				 .balance (std::numeric_limits<nano::uint128_t>::max () - 2 * node1.config.receive_minimum.number ())
176  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
177  				 .work (*system.work.generate (send1->hash ()))
178  				 .build_shared ();
179  	auto send3 = builder.make_block ()
180  				 .previous (send2->hash ())
181  				 .destination (key2.pub)
182  				 .balance (std::numeric_limits<nano::uint128_t>::max () - 3 * node1.config.receive_minimum.number ())
183  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
184  				 .work (*system.work.generate (send2->hash ()))
185  				 .build_shared ();
186  	node1.process_active (send3);
187  	node1.process_active (send2);
188  	node1.process_active (send1);
189  	ASSERT_TIMELY (10s, std::all_of (system.nodes.begin (), system.nodes.end (), [&] (std::shared_ptr<nano::node> const & node_a) { return node_a->balance (nano::dev::genesis_key.pub) == nano::dev::constants.genesis_amount - node1.config.receive_minimum.number () * 3; }));
190  }
191  TEST (node, quick_confirm)
192  {
193  	nano::test::system system (1);
194  	auto & node1 (*system.nodes[0]);
195  	nano::keypair key;
196  	nano::block_hash previous (node1.latest (nano::dev::genesis_key.pub));
197  	auto genesis_start_balance (node1.balance (nano::dev::genesis_key.pub));
198  	system.wallet (0)->insert_adhoc (key.prv);
199  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
200  	auto send = nano::send_block_builder ()
201  				.previous (previous)
202  				.destination (key.pub)
203  				.balance (node1.online_reps.delta () + 1)
204  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
205  				.work (*system.work.generate (previous))
206  				.build_shared ();
207  	node1.process_active (send);
208  	ASSERT_TIMELY (10s, !node1.balance (key.pub).is_zero ());
209  	ASSERT_EQ (node1.balance (nano::dev::genesis_key.pub), node1.online_reps.delta () + 1);
210  	ASSERT_EQ (node1.balance (key.pub), genesis_start_balance - (node1.online_reps.delta () + 1));
211  }
212  TEST (node, node_receive_quorum)
213  {
214  	nano::test::system system (1);
215  	auto & node1 = *system.nodes[0];
216  	nano::keypair key;
217  	nano::block_hash previous (node1.latest (nano::dev::genesis_key.pub));
218  	system.wallet (0)->insert_adhoc (key.prv);
219  	auto send = nano::send_block_builder ()
220  				.previous (previous)
221  				.destination (key.pub)
222  				.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
223  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
224  				.work (*system.work.generate (previous))
225  				.build_shared ();
226  	node1.process_active (send);
227  	ASSERT_TIMELY (10s, node1.ledger.block_or_pruned_exists (send->hash ()));
228  	ASSERT_TIMELY (10s, node1.active.election (nano::qualified_root (previous, previous)) != nullptr);
229  	auto election (node1.active.election (nano::qualified_root (previous, previous)));
230  	ASSERT_NE (nullptr, election);
231  	ASSERT_FALSE (election->confirmed ());
232  	ASSERT_EQ (1, election->votes ().size ());
233  	nano::test::system system2;
234  	system2.add_node ();
235  	system2.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
236  	ASSERT_TRUE (node1.balance (key.pub).is_zero ());
237  	node1.network.tcp_channels.start_tcp (system2.nodes[0]->network.endpoint ());
238  	while (node1.balance (key.pub).is_zero ())
239  	{
240  		ASSERT_NO_ERROR (system.poll ());
241  		ASSERT_NO_ERROR (system2.poll ());
242  	}
243  }
244  TEST (node, auto_bootstrap)
245  {
246  	nano::test::system system;
247  	nano::node_config config (system.get_available_port (), system.logging);
248  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
249  	nano::node_flags node_flags;
250  	node_flags.disable_bootstrap_bulk_push_client = true;
251  	node_flags.disable_lazy_bootstrap = true;
252  	auto node0 = system.add_node (config, node_flags);
253  	nano::keypair key2;
254  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
255  	system.wallet (0)->insert_adhoc (key2.prv);
256  	auto send1 (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, node0->config.receive_minimum.number ()));
257  	ASSERT_NE (nullptr, send1);
258  	ASSERT_TIMELY (10s, node0->balance (key2.pub) == node0->config.receive_minimum.number ());
259  	auto node1 (std::make_shared<nano::node> (system.io_ctx, system.get_available_port (), nano::unique_path (), system.logging, system.work, node_flags));
260  	ASSERT_FALSE (node1->init_error ());
261  	node1->start ();
262  	system.nodes.push_back (node1);
263  	ASSERT_NE (nullptr, nano::test::establish_tcp (system, *node1, node0->network.endpoint ()));
264  	ASSERT_TIMELY (10s, node1->bootstrap_initiator.in_progress ());
265  	ASSERT_TIMELY (10s, node1->balance (key2.pub) == node0->config.receive_minimum.number ());
266  	ASSERT_TIMELY (10s, !node1->bootstrap_initiator.in_progress ());
267  	ASSERT_TRUE (node1->ledger.block_or_pruned_exists (send1->hash ()));
268  	ASSERT_TIMELY (5s, node1->ledger.cache.block_count == 3);
269  	ASSERT_TIMELY (5s, node1->ledger.cache.cemented_count == 3);
270  	node1->stop ();
271  }
272  TEST (node, auto_bootstrap_reverse)
273  {
274  	nano::test::system system;
275  	nano::node_config config (system.get_available_port (), system.logging);
276  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
277  	nano::node_flags node_flags;
278  	node_flags.disable_bootstrap_bulk_push_client = true;
279  	node_flags.disable_lazy_bootstrap = true;
280  	auto node0 = system.add_node (config, node_flags);
281  	nano::keypair key2;
282  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
283  	system.wallet (0)->insert_adhoc (key2.prv);
284  	auto node1 (std::make_shared<nano::node> (system.io_ctx, system.get_available_port (), nano::unique_path (), system.logging, system.work, node_flags));
285  	ASSERT_FALSE (node1->init_error ());
286  	ASSERT_NE (nullptr, system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, node0->config.receive_minimum.number ()));
287  	node1->start ();
288  	system.nodes.push_back (node1);
289  	ASSERT_NE (nullptr, nano::test::establish_tcp (system, *node0, node1->network.endpoint ()));
290  	ASSERT_TIMELY (10s, node1->balance (key2.pub) == node0->config.receive_minimum.number ());
291  }
292  TEST (node, auto_bootstrap_age)
293  {
294  	nano::test::system system;
295  	nano::node_config config (system.get_available_port (), system.logging);
296  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
297  	nano::node_flags node_flags;
298  	node_flags.disable_bootstrap_bulk_push_client = true;
299  	node_flags.disable_lazy_bootstrap = true;
300  	node_flags.bootstrap_interval = 1;
301  	auto node0 = system.add_node (config, node_flags);
302  	auto node1 (std::make_shared<nano::node> (system.io_ctx, system.get_available_port (), nano::unique_path (), system.logging, system.work, node_flags));
303  	ASSERT_FALSE (node1->init_error ());
304  	node1->start ();
<span onclick='openModal()' class='match'>305  	system.nodes.push_back (node1);
306  	ASSERT_NE (nullptr, nano::test::establish_tcp (system, *node1, node0->network.endpoint ()));
307  	ASSERT_TIMELY (10s, node1->bootstrap_initiator.in_progress ());
</span>308  	ASSERT_TIMELY (10s, node0->stats.count (nano::stat::type::bootstrap, nano::stat::detail::initiate_legacy_age, nano::stat::dir::out) >= 3);
309  	ASSERT_GE (node0->stats.count (nano::stat::type::bootstrap, nano::stat::detail::initiate_legacy_age, nano::stat::dir::out), node0->stats.count (nano::stat::type::bootstrap, nano::stat::detail::initiate, nano::stat::dir::out));
310  	node1->stop ();
311  }
312  TEST (node, receive_gap)
313  {
314  	nano::test::system system (1);
315  	auto & node1 (*system.nodes[0]);
316  	ASSERT_EQ (0, node1.gap_cache.size ());
317  	auto block = nano::send_block_builder ()
318  				 .previous (5)
319  				 .destination (1)
320  				 .balance (2)
321  				 .sign (nano::keypair ().prv, 4)
322  				 .work (0)
323  				 .build_shared ();
324  	node1.work_generate_blocking (*block);
325  	nano::publish message{ nano::dev::network_params.network, block };
326  	auto channel1 = std::make_shared<nano::transport::fake::channel> (node1);
327  	node1.network.inbound (message, channel1);
328  	node1.block_processor.flush ();
329  	ASSERT_EQ (1, node1.gap_cache.size ());
330  }
331  TEST (node, merge_peers)
332  {
333  	nano::test::system system (1);
334  	std::array<nano::endpoint, 8> endpoints;
335  	endpoints.fill (nano::endpoint (boost::asio::ip::address_v6::loopback (), system.get_available_port ()));
336  	endpoints[0] = nano::endpoint (boost::asio::ip::address_v6::loopback (), system.get_available_port ());
337  	system.nodes[0]->network.merge_peers (endpoints);
338  	ASSERT_EQ (0, system.nodes[0]->network.size ());
339  }
340  TEST (node, search_receivable)
341  {
342  	nano::test::system system (1);
343  	auto node (system.nodes[0]);
344  	nano::keypair key2;
345  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
346  	ASSERT_NE (nullptr, system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, node->config.receive_minimum.number ()));
347  	system.wallet (0)->insert_adhoc (key2.prv);
348  	ASSERT_FALSE (system.wallet (0)->search_receivable (system.wallet (0)->wallets.tx_begin_read ()));
349  	ASSERT_TIMELY (10s, !node->balance (key2.pub).is_zero ());
350  }
351  TEST (node, search_receivable_same)
352  {
353  	nano::test::system system (1);
354  	auto node (system.nodes[0]);
355  	nano::keypair key2;
356  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
357  	ASSERT_NE (nullptr, system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, node->config.receive_minimum.number ()));
358  	ASSERT_NE (nullptr, system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, node->config.receive_minimum.number ()));
359  	system.wallet (0)->insert_adhoc (key2.prv);
360  	ASSERT_FALSE (system.wallet (0)->search_receivable (system.wallet (0)->wallets.tx_begin_read ()));
361  	ASSERT_TIMELY (10s, node->balance (key2.pub) == 2 * node->config.receive_minimum.number ());
362  }
363  TEST (node, search_receivable_multiple)
364  {
365  	nano::test::system system (1);
366  	auto node (system.nodes[0]);
367  	nano::keypair key2;
368  	nano::keypair key3;
369  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
370  	system.wallet (0)->insert_adhoc (key3.prv);
371  	ASSERT_NE (nullptr, system.wallet (0)->send_action (nano::dev::genesis_key.pub, key3.pub, node->config.receive_minimum.number ()));
372  	ASSERT_TIMELY (10s, !node->balance (key3.pub).is_zero ());
373  	ASSERT_NE (nullptr, system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, node->config.receive_minimum.number ()));
374  	ASSERT_NE (nullptr, system.wallet (0)->send_action (key3.pub, key2.pub, node->config.receive_minimum.number ()));
375  	system.wallet (0)->insert_adhoc (key2.prv);
376  	ASSERT_FALSE (system.wallet (0)->search_receivable (system.wallet (0)->wallets.tx_begin_read ()));
377  	ASSERT_TIMELY (10s, node->balance (key2.pub) == 2 * node->config.receive_minimum.number ());
378  }
379  TEST (node, search_receivable_confirmed)
380  {
381  	nano::test::system system;
382  	nano::node_config node_config (system.get_available_port (), system.logging);
383  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
384  	auto node = system.add_node (node_config);
385  	nano::keypair key2;
386  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
387  	auto send1 (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, node->config.receive_minimum.number ()));
388  	ASSERT_NE (nullptr, send1);
389  	auto send2 (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, node->config.receive_minimum.number ()));
390  	ASSERT_NE (nullptr, send2);
391  	ASSERT_TIMELY (10s, node->active.empty ());
392  	bool confirmed (false);
393  	system.deadline_set (5s);
394  	while (!confirmed)
395  	{
396  		auto transaction (node->store.tx_begin_read ());
397  		confirmed = node->ledger.block_confirmed (transaction, send2->hash ());
398  		ASSERT_NO_ERROR (system.poll ());
399  	}
400  	{
401  		auto transaction (node->wallets.tx_begin_write ());
402  		system.wallet (0)->store.erase (transaction, nano::dev::genesis_key.pub);
403  	}
404  	system.wallet (0)->insert_adhoc (key2.prv);
405  	ASSERT_FALSE (system.wallet (0)->search_receivable (system.wallet (0)->wallets.tx_begin_read ()));
406  	{
407  		ASSERT_FALSE (node->active.active (send1->hash ()));
408  		ASSERT_FALSE (node->active.active (send2->hash ()));
409  	}
410  	ASSERT_TIMELY (10s, node->balance (key2.pub) == 2 * node->config.receive_minimum.number ());
411  }
412  TEST (node, search_receivable_pruned)
413  {
414  	nano::test::system system;
415  	nano::node_config node_config (system.get_available_port (), system.logging);
416  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
417  	auto node1 = system.add_node (node_config);
418  	nano::node_flags node_flags;
419  	node_flags.enable_pruning = true;
420  	nano::node_config config (system.get_available_port (), system.logging);
421  	config.enable_voting = false; 
422  	auto node2 = system.add_node (config, node_flags);
423  	nano::keypair key2;
424  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
425  	auto send1 (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, node2->config.receive_minimum.number ()));
426  	ASSERT_NE (nullptr, send1);
427  	auto send2 (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, node2->config.receive_minimum.number ()));
428  	ASSERT_NE (nullptr, send2);
429  	ASSERT_TIMELY (10s, node1->active.empty () && node2->active.empty ());
430  	ASSERT_TIMELY (5s, node1->ledger.block_confirmed (node1->store.tx_begin_read (), send2->hash ()));
431  	ASSERT_TIMELY (5s, node2->ledger.cache.cemented_count == 3);
432  	system.wallet (0)->store.erase (node1->wallets.tx_begin_write (), nano::dev::genesis_key.pub);
433  	{
434  		auto transaction (node2->store.tx_begin_write ());
435  		ASSERT_EQ (1, node2->ledger.pruning_action (transaction, send1->hash (), 1));
436  	}
437  	ASSERT_EQ (1, node2->ledger.cache.pruned_count);
438  	ASSERT_TRUE (node2->ledger.block_or_pruned_exists (send1->hash ())); 
439  	system.wallet (1)->insert_adhoc (key2.prv);
440  	ASSERT_FALSE (system.wallet (1)->search_receivable (system.wallet (1)->wallets.tx_begin_read ()));
441  	ASSERT_TIMELY (10s, node2->balance (key2.pub) == 2 * node2->config.receive_minimum.number ());
442  }
443  TEST (node, unlock_search)
444  {
445  	nano::test::system system (1);
446  	auto node (system.nodes[0]);
447  	nano::keypair key2;
448  	nano::uint128_t balance (node->balance (nano::dev::genesis_key.pub));
449  	{
450  		auto transaction (system.wallet (0)->wallets.tx_begin_write ());
451  		system.wallet (0)->store.rekey (transaction, "");
452  	}
453  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
454  	ASSERT_NE (nullptr, system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, node->config.receive_minimum.number ()));
455  	ASSERT_TIMELY (10s, node->balance (nano::dev::genesis_key.pub) != balance);
456  	ASSERT_TIMELY (10s, node->active.empty ());
457  	system.wallet (0)->insert_adhoc (key2.prv);
458  	{
459  		nano::lock_guard<std::recursive_mutex> lock{ system.wallet (0)->store.mutex };
460  		system.wallet (0)->store.password.value_set (nano::keypair ().prv);
461  	}
462  	{
463  		auto transaction (system.wallet (0)->wallets.tx_begin_write ());
464  		ASSERT_FALSE (system.wallet (0)->enter_password (transaction, ""));
465  	}
466  	ASSERT_TIMELY (10s, !node->balance (key2.pub).is_zero ());
467  }
468  TEST (node, working)
469  {
470  	auto path (nano::working_path ());
471  	ASSERT_FALSE (path.empty ());
472  }
473  TEST (node, price)
474  {
475  	nano::test::system system (1);
476  	auto price1 (system.nodes[0]->price (nano::Gxrb_ratio, 1));
477  	ASSERT_EQ (nano::node::price_max * 100.0, price1);
478  	auto price2 (system.nodes[0]->price (nano::Gxrb_ratio * int (nano::node::free_cutoff + 1), 1));
479  	ASSERT_EQ (0, price2);
480  	auto price3 (system.nodes[0]->price (nano::Gxrb_ratio * int (nano::node::free_cutoff + 2) / 2, 1));
481  	ASSERT_EQ (nano::node::price_max * 100.0 / 2, price3);
482  	auto price4 (system.nodes[0]->price (nano::Gxrb_ratio * int (nano::node::free_cutoff) * 2, 1));
483  	ASSERT_EQ (0, price4);
484  }
485  TEST (node, confirm_locked)
486  {
487  	nano::test::system system (1);
488  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
489  	auto transaction (system.wallet (0)->wallets.tx_begin_read ());
490  	system.wallet (0)->enter_password (transaction, "1");
491  	auto block = nano::send_block_builder ()
492  				 .previous (0)
493  				 .destination (0)
494  				 .balance (0)
495  				 .sign (nano::keypair ().prv, 0)
496  				 .work (0)
497  				 .build_shared ();
498  	system.nodes[0]->network.flood_block (block);
499  }
500  TEST (node_config, random_rep)
501  {
502  	auto path (nano::unique_path ());
503  	nano::logging logging1;
504  	logging1.init (path);
505  	nano::node_config config1 (100, logging1);
506  	auto rep (config1.random_representative ());
507  	ASSERT_NE (config1.preconfigured_representatives.end (), std::find (config1.preconfigured_representatives.begin (), config1.preconfigured_representatives.end (), rep));
508  }
509  TEST (node, fork_publish)
510  {
511  	std::weak_ptr<nano::node> node0;
512  	{
513  		nano::test::system system (1);
514  		node0 = system.nodes[0];
515  		auto & node1 (*system.nodes[0]);
516  		system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
517  		nano::keypair key1;
518  		nano::send_block_builder builder;
519  		auto send1 = builder.make_block ()
520  					 .previous (nano::dev::genesis->hash ())
521  					 .destination (key1.pub)
522  					 .balance (nano::dev::constants.genesis_amount - 100)
523  					 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
524  					 .work (0)
525  					 .build_shared ();
526  		node1.work_generate_blocking (*send1);
527  		nano::keypair key2;
528  		auto send2 = builder.make_block ()
529  					 .previous (nano::dev::genesis->hash ())
530  					 .destination (key2.pub)
531  					 .balance (nano::dev::constants.genesis_amount - 100)
532  					 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
533  					 .work (0)
534  					 .build_shared ();
535  		node1.work_generate_blocking (*send2);
536  		node1.process_active (send1);
537  		node1.block_processor.flush ();
538  		ASSERT_TIMELY_EQ (5s, 1, node1.active.size ());
539  		auto election (node1.active.election (send1->qualified_root ()));
540  		ASSERT_NE (nullptr, election);
541  		ASSERT_TIMELY (1s, election->votes ().size () == 2);
542  		node1.process_active (send2);
543  		node1.block_processor.flush ();
544  		auto votes1 (election->votes ());
545  		auto existing1 (votes1.find (nano::dev::genesis_key.pub));
546  		ASSERT_NE (votes1.end (), existing1);
547  		ASSERT_EQ (send1->hash (), existing1->second.hash);
548  		auto winner (*election->tally ().begin ());
549  		ASSERT_EQ (*send1, *winner.second);
550  		ASSERT_EQ (nano::dev::constants.genesis_amount - 100, winner.first);
551  	}
552  	ASSERT_TRUE (node0.expired ());
553  }
554  TEST (node, fork_publish_inactive)
555  {
556  	nano::test::system system (1);
557  	auto & node = *system.nodes[0];
558  	nano::keypair key1;
559  	nano::keypair key2;
560  	nano::send_block_builder builder;
561  	auto send1 = builder.make_block ()
562  				 .previous (nano::dev::genesis->hash ())
563  				 .destination (key1.pub)
564  				 .balance (nano::dev::constants.genesis_amount - 100)
565  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
566  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
567  				 .build_shared ();
568  	auto send2 = builder.make_block ()
569  				 .previous (nano::dev::genesis->hash ())
570  				 .destination (key2.pub)
571  				 .balance (nano::dev::constants.genesis_amount - 100)
572  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
573  				 .work (send1->block_work ())
574  				 .build_shared ();
575  	node.process_active (send1);
576  	ASSERT_TIMELY (5s, node.block (send1->hash ()));
577  	std::shared_ptr<nano::election> election;
578  	ASSERT_TIMELY (5s, election = node.active.election (send1->qualified_root ()));
579  	ASSERT_EQ (nano::process_result::fork, node.process_local (send2).value ().code);
580  	auto blocks = election->blocks ();
581  	ASSERT_TIMELY_EQ (5s, blocks.size (), 2);
582  	ASSERT_NE (blocks.end (), blocks.find (send1->hash ()));
583  	ASSERT_NE (blocks.end (), blocks.find (send2->hash ()));
584  	ASSERT_EQ (election->winner ()->hash (), send1->hash ());
585  	ASSERT_NE (election->winner ()->hash (), send2->hash ());
586  }
587  TEST (node, fork_keep)
588  {
589  	nano::test::system system (2);
590  	auto & node1 (*system.nodes[0]);
591  	auto & node2 (*system.nodes[1]);
592  	ASSERT_EQ (1, node1.network.size ());
593  	nano::keypair key1;
594  	nano::keypair key2;
595  	nano::send_block_builder builder;
596  	auto send1 = builder.make_block ()
597  				 .previous (nano::dev::genesis->hash ())
598  				 .destination (key1.pub)
599  				 .balance (nano::dev::constants.genesis_amount - 100)
600  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
601  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
602  				 .build_shared ();
603  	auto send2 = builder.make_block ()
604  				 .previous (nano::dev::genesis->hash ())
605  				 .destination (key2.pub)
606  				 .balance (nano::dev::constants.genesis_amount - 100)
607  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
608  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
609  				 .build_shared ();
610  	node1.process_active (send1);
611  	node1.block_processor.flush ();
612  	node2.process_active (send1);
613  	node2.block_processor.flush ();
614  	ASSERT_TIMELY_EQ (5s, 1, node1.active.size ());
615  	ASSERT_TIMELY_EQ (5s, 1, node2.active.size ());
616  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
617  	node1.process_active (send2);
618  	node1.block_processor.flush ();
619  	node2.process_active (send2);
620  	node2.block_processor.flush ();
621  	auto election1 (node2.active.election (nano::qualified_root (nano::dev::genesis->hash (), nano::dev::genesis->hash ())));
622  	ASSERT_NE (nullptr, election1);
623  	ASSERT_EQ (1, election1->votes ().size ());
624  	ASSERT_TRUE (node1.ledger.block_or_pruned_exists (send1->hash ()));
625  	ASSERT_TRUE (node2.ledger.block_or_pruned_exists (send1->hash ()));
626  	ASSERT_TIMELY (1.5min, election1->votes ().size () != 1);
627  	auto transaction0 (node1.store.tx_begin_read ());
628  	auto transaction1 (node2.store.tx_begin_read ());
629  	auto winner (*election1->tally ().begin ());
630  	ASSERT_EQ (*send1, *winner.second);
631  	ASSERT_EQ (nano::dev::constants.genesis_amount - 100, winner.first);
632  	ASSERT_TRUE (node1.store.block.exists (transaction0, send1->hash ()));
633  	ASSERT_TRUE (node2.store.block.exists (transaction1, send1->hash ()));
634  }
635  TEST (node, fork_flip)
636  {
637  	nano::test::system system (2);
638  	auto & node1 (*system.nodes[0]);
639  	auto & node2 (*system.nodes[1]);
640  	ASSERT_EQ (1, node1.network.size ());
641  	nano::keypair key1;
642  	nano::send_block_builder builder;
643  	auto send1 = builder.make_block ()
644  				 .previous (nano::dev::genesis->hash ())
645  				 .destination (key1.pub)
646  				 .balance (nano::dev::constants.genesis_amount - 100)
647  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
648  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
649  				 .build_shared ();
650  	nano::publish publish1{ nano::dev::network_params.network, send1 };
651  	nano::keypair key2;
652  	auto send2 = builder.make_block ()
653  				 .previous (nano::dev::genesis->hash ())
654  				 .destination (key2.pub)
655  				 .balance (nano::dev::constants.genesis_amount - 100)
656  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
657  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
658  				 .build_shared ();
659  	nano::publish publish2{ nano::dev::network_params.network, send2 };
660  	auto ignored_channel{ std::make_shared<nano::transport::channel_tcp> (node1, std::weak_ptr<nano::transport::socket> ()) };
661  	node1.network.inbound (publish1, ignored_channel);
662  	node1.block_processor.flush ();
663  	node2.network.inbound (publish2, ignored_channel);
664  	node2.block_processor.flush ();
665  	ASSERT_TIMELY_EQ (5s, 1, node1.active.size ());
666  	ASSERT_TIMELY_EQ (5s, 1, node2.active.size ());
667  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
668  	node1.network.inbound (publish2, ignored_channel);
669  	node1.block_processor.flush ();
670  	node2.network.inbound (publish1, ignored_channel);
671  	node2.block_processor.flush ();
672  	auto election1 (node2.active.election (nano::qualified_root (nano::dev::genesis->hash (), nano::dev::genesis->hash ())));
673  	ASSERT_NE (nullptr, election1);
674  	ASSERT_EQ (1, election1->votes ().size ());
675  	ASSERT_NE (nullptr, node1.block (publish1.block->hash ()));
676  	ASSERT_NE (nullptr, node2.block (publish2.block->hash ()));
677  	ASSERT_TIMELY (10s, node2.ledger.block_or_pruned_exists (publish1.block->hash ()));
678  	auto winner (*election1->tally ().begin ());
679  	ASSERT_EQ (*publish1.block, *winner.second);
680  	ASSERT_EQ (nano::dev::constants.genesis_amount - 100, winner.first);
681  	ASSERT_TRUE (node1.ledger.block_or_pruned_exists (publish1.block->hash ()));
682  	ASSERT_TRUE (node2.ledger.block_or_pruned_exists (publish1.block->hash ()));
683  	ASSERT_FALSE (node2.ledger.block_or_pruned_exists (publish2.block->hash ()));
684  }
685  TEST (node, fork_multi_flip)
686  {
687  	auto type = nano::transport::transport_type::tcp;
688  	nano::test::system system;
689  	nano::node_flags node_flags;
690  	nano::node_config node_config (system.get_available_port (), system.logging);
691  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
692  	auto & node1 (*system.add_node (node_config, node_flags, type));
693  	node_config.peering_port = system.get_available_port ();
694  	auto & node2 (*system.add_node (node_config, node_flags, type));
695  	ASSERT_EQ (1, node1.network.size ());
696  	nano::keypair key1;
697  	nano::send_block_builder builder;
698  	auto send1 = builder.make_block ()
699  				 .previous (nano::dev::genesis->hash ())
700  				 .destination (key1.pub)
701  				 .balance (nano::dev::constants.genesis_amount - 100)
702  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
703  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
704  				 .build_shared ();
705  	nano::publish publish1{ nano::dev::network_params.network, send1 };
706  	nano::keypair key2;
707  	auto send2 = builder.make_block ()
708  				 .previous (nano::dev::genesis->hash ())
709  				 .destination (key2.pub)
710  				 .balance (nano::dev::constants.genesis_amount - 100)
711  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
712  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
713  				 .build_shared ();
714  	nano::publish publish2{ nano::dev::network_params.network, send2 };
715  	auto send3 = builder.make_block ()
716  				 .previous (publish2.block->hash ())
717  				 .destination (key2.pub)
718  				 .balance (nano::dev::constants.genesis_amount - 100)
719  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
720  				 .work (*system.work.generate (publish2.block->hash ()))
721  				 .build_shared ();
722  	nano::publish publish3{ nano::dev::network_params.network, send3 };
723  	auto channel1 = std::make_shared<nano::transport::fake::channel> (node1);
724  	auto channel2 = std::make_shared<nano::transport::fake::channel> (node2);
725  	node1.network.inbound (publish1, channel1);
726  	node2.network.inbound (publish2, channel2);
727  	node2.network.inbound (publish3, channel2);
728  	node1.block_processor.flush ();
729  	node2.block_processor.flush ();
730  	ASSERT_TIMELY_EQ (5s, 1, node1.active.size ());
731  	ASSERT_TIMELY_EQ (5s, 1, node2.active.size ());
732  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
733  	node1.network.inbound (publish2, channel1);
734  	node1.network.inbound (publish3, channel1);
735  	node1.block_processor.flush ();
736  	node2.network.inbound (publish1, channel2);
737  	node2.block_processor.flush ();
738  	ASSERT_TIMELY (5s, node2.active.election (nano::qualified_root (nano::dev::genesis->hash (), nano::dev::genesis->hash ())));
739  	auto election1 (node2.active.election (nano::qualified_root (nano::dev::genesis->hash (), nano::dev::genesis->hash ())));
740  	ASSERT_NE (nullptr, election1);
741  	ASSERT_EQ (1, election1->votes ().size ());
742  	ASSERT_TRUE (node1.ledger.block_or_pruned_exists (publish1.block->hash ()));
743  	ASSERT_TRUE (node2.ledger.block_or_pruned_exists (publish2.block->hash ()));
744  	ASSERT_TRUE (node2.ledger.block_or_pruned_exists (publish3.block->hash ()));
745  	ASSERT_TIMELY (10s, node2.ledger.block_or_pruned_exists (publish1.block->hash ()));
746  	auto winner (*election1->tally ().begin ());
747  	ASSERT_EQ (*publish1.block, *winner.second);
748  	ASSERT_EQ (nano::dev::constants.genesis_amount - 100, winner.first);
749  	ASSERT_TRUE (node1.ledger.block_or_pruned_exists (publish1.block->hash ()));
750  	ASSERT_TRUE (node2.ledger.block_or_pruned_exists (publish1.block->hash ()));
751  	ASSERT_FALSE (node2.ledger.block_or_pruned_exists (publish2.block->hash ()));
752  	ASSERT_FALSE (node2.ledger.block_or_pruned_exists (publish3.block->hash ()));
753  }
754  TEST (node, fork_bootstrap_flip)
755  {
756  	nano::test::system system;
757  	nano::test::system system0;
758  	nano::test::system system1;
759  	nano::node_config config0{ system.get_available_port (), system0.logging };
760  	config0.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
761  	nano::node_flags node_flags;
762  	node_flags.disable_bootstrap_bulk_push_client = true;
763  	node_flags.disable_lazy_bootstrap = true;
764  	auto & node1 = *system0.add_node (config0, node_flags);
765  	nano::node_config config1 (system.get_available_port (), system1.logging);
766  	auto & node2 = *system1.add_node (config1, node_flags);
767  	system0.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
768  	nano::block_hash latest = node1.latest (nano::dev::genesis_key.pub);
769  	nano::keypair key1;
770  	nano::send_block_builder builder;
771  	auto send1 = builder.make_block ()
772  				 .previous (latest)
773  				 .destination (key1.pub)
774  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
775  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
776  				 .work (*system0.work.generate (latest))
777  				 .build_shared ();
778  	nano::keypair key2;
779  	auto send2 = builder.make_block ()
780  				 .previous (latest)
781  				 .destination (key2.pub)
782  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
783  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
784  				 .work (*system0.work.generate (latest))
785  				 .build_shared ();
786  	ASSERT_EQ (nano::process_result::progress, node1.ledger.process (node1.store.tx_begin_write (), *send1).code);
787  	ASSERT_EQ (nano::process_result::progress, node2.ledger.process (node2.store.tx_begin_write (), *send2).code);
788  	ASSERT_TRUE (node2.store.block.exists (node2.store.tx_begin_read (), send2->hash ()));
789  	node2.bootstrap_initiator.bootstrap (node1.network.endpoint ()); 
790  	auto again (true);
791  	system0.deadline_set (50s);
792  	system1.deadline_set (50s);
793  	while (again)
794  	{
795  		ASSERT_NO_ERROR (system0.poll ());
796  		ASSERT_NO_ERROR (system1.poll ());
797  		again = !node2.store.block.exists (node2.store.tx_begin_read (), send1->hash ());
798  	}
799  }
800  TEST (node, fork_open)
801  {
802  	nano::test::system system (1);
803  	auto & node = *system.nodes[0];
804  	std::shared_ptr<nano::election> election;
805  	nano::keypair key1;
806  	auto send1 = nano::send_block_builder ()
807  				 .previous (nano::dev::genesis->hash ())
808  				 .destination (key1.pub)
809  				 .balance (0)
810  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
811  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
812  				 .build_shared ();
813  	nano::publish publish1{ nano::dev::network_params.network, send1 };
814  	auto channel1 = std::make_shared<nano::transport::fake::channel> (node);
815  	node.network.inbound (publish1, channel1);
816  	ASSERT_TIMELY (5s, (election = node.active.election (publish1.block->qualified_root ())) != nullptr);
817  	election->force_confirm ();
818  	ASSERT_TIMELY (5s, node.active.empty () && node.block_confirmed (publish1.block->hash ()));
819  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
820  	nano::open_block_builder builder;
821  	auto open1 = builder.make_block ()
822  				 .source (publish1.block->hash ())
823  				 .representative (1)
824  				 .account (key1.pub)
825  				 .sign (key1.prv, key1.pub)
826  				 .work (*system.work.generate (key1.pub))
827  				 .build_shared ();
828  	nano::publish publish2{ nano::dev::network_params.network, open1 };
829  	node.network.inbound (publish2, channel1);
830  	ASSERT_TIMELY (5s, 1 == node.active.size ());
831  	auto open2 = builder.make_block ()
832  				 .source (publish1.block->hash ())
833  				 .representative (2)
834  				 .account (key1.pub)
835  				 .sign (key1.prv, key1.pub)
836  				 .work (*system.work.generate (key1.pub))
837  				 .build_shared ();
838  	nano::publish publish3{ nano::dev::network_params.network, open2 };
839  	node.network.inbound (publish3, channel1);
840  	ASSERT_TIMELY (5s, (election = node.active.election (publish3.block->qualified_root ())) != nullptr);
841  	ASSERT_TIMELY (5s, 2 == election->blocks ().size ());
842  	ASSERT_EQ (publish2.block->hash (), election->winner ()->hash ());
843  	system.delay_ms (1000ms);
844  	ASSERT_FALSE (election->confirmed ());
845  	ASSERT_TIMELY (5s, node.block (publish2.block->hash ()));
846  	ASSERT_FALSE (node.block (publish3.block->hash ()));
847  }
848  TEST (node, fork_open_flip)
849  {
850  	nano::test::system system (1);
851  	auto & node1 = *system.nodes[0];
852  	std::shared_ptr<nano::election> election;
853  	nano::keypair key1;
854  	nano::keypair rep1;
855  	nano::keypair rep2;
856  	auto send1 = nano::send_block_builder ()
857  				 .previous (nano::dev::genesis->hash ())
858  				 .destination (key1.pub)
859  				 .balance (nano::dev::constants.genesis_amount - 1)
860  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
861  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
862  				 .build_shared ();
863  	node1.process_active (send1);
864  	nano::open_block_builder builder;
865  	auto open1 = builder.make_block ()
866  				 .source (send1->hash ())
867  				 .representative (rep1.pub)
868  				 .account (key1.pub)
869  				 .sign (key1.prv, key1.pub)
870  				 .work (*system.work.generate (key1.pub))
871  				 .build_shared ();
872  	auto open2 = builder.make_block ()
873  				 .source (send1->hash ())
874  				 .representative (rep2.pub)
875  				 .account (key1.pub)
876  				 .sign (key1.prv, key1.pub)
877  				 .work (*system.work.generate (key1.pub))
878  				 .build_shared ();
879  	ASSERT_FALSE (*open1 == *open2);
880  	node1.process_active (open1);
881  	ASSERT_TIMELY (5s, node1.block (open1->hash ()) != nullptr);
882  	node1.scheduler.buckets.manual (open1);
883  	ASSERT_TIMELY (5s, (election = node1.active.election (open1->qualified_root ())) != nullptr);
884  	election->transition_active ();
885  	system.initialization_blocks.push_back (send1);
886  	system.initialization_blocks.push_back (open2);
887  	auto & node2 = *system.add_node ();
888  	system.initialization_blocks.clear ();
889  	ASSERT_TIMELY (5s, node2.block (open2->hash ()) != nullptr);
890  	node2.scheduler.buckets.manual (open2);
891  	ASSERT_TIMELY (5s, (election = node2.active.election (open2->qualified_root ())) != nullptr);
892  	election->transition_active ();
893  	ASSERT_TIMELY (5s, 2 == node1.active.size ());
894  	ASSERT_TIMELY (5s, 2 == node2.active.size ());
895  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
896  	ASSERT_TIMELY (5s, node1.block_confirmed (open1->hash ()));
897  	node1.process_active (open2);
898  	node2.process_active (open1);
899  	ASSERT_TIMELY (5s, 2 == election->votes ().size ()); 
900  	ASSERT_TIMELY (10s, node2.block (open1->hash ()));
901  	ASSERT_TIMELY (5s, node1.block_confirmed (open1->hash ()));
902  	auto winner = *election->tally ().begin ();
903  	ASSERT_EQ (*open1, *winner.second);
904  	ASSERT_EQ (nano::dev::constants.genesis_amount - 1, winner.first);
905  	auto transaction1 (node1.store.tx_begin_read ());
906  	auto transaction2 (node2.store.tx_begin_read ());
907  	ASSERT_TRUE (node1.store.block.exists (transaction1, open1->hash ()));
908  	ASSERT_TRUE (node2.store.block.exists (transaction2, open1->hash ()));
909  	ASSERT_FALSE (node2.store.block.exists (transaction2, open2->hash ()));
910  }
911  TEST (node, coherent_observer)
912  {
913  	nano::test::system system (1);
914  	auto & node1 (*system.nodes[0]);
915  	node1.observers.blocks.add ([&node1] (nano::election_status const & status_a, std::vector<nano::vote_with_weight_info> const &, nano::account const &, nano::uint128_t const &, bool, bool) {
916  		auto transaction (node1.store.tx_begin_read ());
917  		ASSERT_TRUE (node1.store.block.exists (transaction, status_a.winner->hash ()));
918  	});
919  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
920  	nano::keypair key;
921  	system.wallet (0)->send_action (nano::dev::genesis_key.pub, key.pub, 1);
922  }
923  TEST (node, fork_no_vote_quorum)
924  {
925  	nano::test::system system (3);
926  	auto & node1 (*system.nodes[0]);
927  	auto & node2 (*system.nodes[1]);
928  	auto & node3 (*system.nodes[2]);
929  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
930  	auto key4 (system.wallet (0)->deterministic_insert ());
931  	system.wallet (0)->send_action (nano::dev::genesis_key.pub, key4, nano::dev::constants.genesis_amount / 4);
932  	auto key1 (system.wallet (1)->deterministic_insert ());
933  	{
934  		auto transaction (system.wallet (1)->wallets.tx_begin_write ());
935  		system.wallet (1)->store.representative_set (transaction, key1);
936  	}
937  	auto block (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key1, node1.config.receive_minimum.number ()));
938  	ASSERT_NE (nullptr, block);
939  	ASSERT_TIMELY (30s, node3.balance (key1) == node1.config.receive_minimum.number () && node2.balance (key1) == node1.config.receive_minimum.number () && node1.balance (key1) == node1.config.receive_minimum.number ());
940  	ASSERT_EQ (node1.config.receive_minimum.number (), node1.weight (key1));
941  	ASSERT_EQ (node1.config.receive_minimum.number (), node2.weight (key1));
942  	ASSERT_EQ (node1.config.receive_minimum.number (), node3.weight (key1));
943  	nano::block_builder builder;
944  	auto send1 = builder
945  				 .state ()
946  				 .account (nano::dev::genesis_key.pub)
947  				 .previous (block->hash ())
948  				 .representative (nano::dev::genesis_key.pub)
949  				 .balance ((nano::dev::constants.genesis_amount / 4) - (node1.config.receive_minimum.number () * 2))
950  				 .link (key1)
951  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
952  				 .work (*system.work.generate (block->hash ()))
953  				 .build ();
954  	ASSERT_EQ (nano::process_result::progress, node1.process (*send1).code);
955  	ASSERT_EQ (nano::process_result::progress, node2.process (*send1).code);
956  	ASSERT_EQ (nano::process_result::progress, node3.process (*send1).code);
957  	auto key2 (system.wallet (2)->deterministic_insert ());
958  	auto send2 = nano::send_block_builder ()
959  				 .previous (block->hash ())
960  				 .destination (key2)
961  				 .balance ((nano::dev::constants.genesis_amount / 4) - (node1.config.receive_minimum.number () * 2))
962  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
963  				 .work (*system.work.generate (block->hash ()))
964  				 .build_shared ();
965  	nano::raw_key key3;
966  	auto transaction (system.wallet (1)->wallets.tx_begin_read ());
967  	ASSERT_FALSE (system.wallet (1)->store.fetch (transaction, key1, key3));
968  	auto vote = std::make_shared<nano::vote> (key1, key3, 0, 0, std::vector<nano::block_hash>{ send2->hash () });
969  	nano::confirm_ack confirm{ nano::dev::network_params.network, vote };
970  	std::vector<uint8_t> buffer;
971  	{
972  		nano::vectorstream stream (buffer);
973  		confirm.serialize (stream);
974  	}
975  	auto channel = node2.network.find_node_id (node3.node_id.pub);
976  	ASSERT_NE (nullptr, channel);
977  	channel->send_buffer (nano::shared_const_buffer (std::move (buffer)));
978  	ASSERT_TIMELY (10s, node3.stats.count (nano::stat::type::message, nano::stat::detail::confirm_ack, nano::stat::dir::in) >= 3);
979  	ASSERT_TRUE (node1.latest (nano::dev::genesis_key.pub) == send1->hash ());
980  	ASSERT_TRUE (node2.latest (nano::dev::genesis_key.pub) == send1->hash ());
981  	ASSERT_TRUE (node3.latest (nano::dev::genesis_key.pub) == send1->hash ());
982  }
983  TEST (node, DISABLED_fork_pre_confirm)
984  {
985  	nano::test::system system (3);
986  	auto & node0 (*system.nodes[0]);
987  	auto & node1 (*system.nodes[1]);
988  	auto & node2 (*system.nodes[2]);
989  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
990  	nano::keypair key1;
991  	system.wallet (1)->insert_adhoc (key1.prv);
992  	{
993  		auto transaction (system.wallet (1)->wallets.tx_begin_write ());
994  		system.wallet (1)->store.representative_set (transaction, key1.pub);
995  	}
996  	nano::keypair key2;
997  	system.wallet (2)->insert_adhoc (key2.prv);
998  	{
999  		auto transaction (system.wallet (2)->wallets.tx_begin_write ());
1000  		system.wallet (2)->store.representative_set (transaction, key2.pub);
1001  	}
1002  	auto block0 (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key1.pub, nano::dev::constants.genesis_amount / 3));
1003  	ASSERT_NE (nullptr, block0);
1004  	ASSERT_TIMELY (30s, node0.balance (key1.pub) != 0);
1005  	auto block1 (system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, nano::dev::constants.genesis_amount / 3));
1006  	ASSERT_NE (nullptr, block1);
1007  	ASSERT_TIMELY (30s, node0.balance (key2.pub) != 0);
1008  	nano::keypair key3;
1009  	nano::keypair key4;
1010  	nano::state_block_builder builder;
1011  	auto block2 = builder.make_block ()
1012  				  .account (nano::dev::genesis_key.pub)
1013  				  .previous (node0.latest (nano::dev::genesis_key.pub))
1014  				  .representative (key3.pub)
1015  				  .balance (node0.balance (nano::dev::genesis_key.pub))
1016  				  .link (0)
1017  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1018  				  .work (0)
1019  				  .build_shared ();
1020  	auto block3 = builder.make_block ()
1021  				  .account (nano::dev::genesis_key.pub)
1022  				  .previous (node0.latest (nano::dev::genesis_key.pub))
1023  				  .representative (key4.pub)
1024  				  .balance (node0.balance (nano::dev::genesis_key.pub))
1025  				  .link (0)
1026  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1027  				  .work (0)
1028  				  .build_shared ();
1029  	node0.work_generate_blocking (*block2);
1030  	node0.work_generate_blocking (*block3);
1031  	node0.process_active (block2);
1032  	node1.process_active (block2);
1033  	node2.process_active (block3);
1034  	auto done (false);
1035  	system.deadline_set (70s);
1036  	while (!done)
1037  	{
1038  		done |= node0.latest (nano::dev::genesis_key.pub) == block2->hash () && node1.latest (nano::dev::genesis_key.pub) == block2->hash () && node2.latest (nano::dev::genesis_key.pub) == block2->hash ();
1039  		done |= node0.latest (nano::dev::genesis_key.pub) == block3->hash () && node1.latest (nano::dev::genesis_key.pub) == block3->hash () && node2.latest (nano::dev::genesis_key.pub) == block3->hash ();
1040  		ASSERT_NO_ERROR (system.poll ());
1041  	}
1042  }
1043  TEST (node, DISABLED_fork_stale)
1044  {
1045  	nano::test::system system1 (1);
1046  	system1.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
1047  	nano::test::system system2 (1);
1048  	auto & node1 (*system1.nodes[0]);
1049  	auto & node2 (*system2.nodes[0]);
1050  	node2.bootstrap_initiator.bootstrap (node1.network.endpoint (), false);
1051  	auto channel = nano::test::establish_tcp (system1, node2, node1.network.endpoint ());
1052  	auto vote = std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, 0, 0, std::vector<nano::block_hash> ());
1053  	node2.rep_crawler.response (channel, vote);
1054  	nano::keypair key1;
1055  	nano::keypair key2;
1056  	nano::state_block_builder builder;
1057  	auto send3 = builder.make_block ()
1058  				 .account (nano::dev::genesis_key.pub)
1059  				 .previous (nano::dev::genesis->hash ())
1060  				 .representative (nano::dev::genesis_key.pub)
1061  				 .balance (nano::dev::constants.genesis_amount - nano::Mxrb_ratio)
1062  				 .link (key1.pub)
1063  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1064  				 .work (0)
1065  				 .build_shared ();
1066  	node1.work_generate_blocking (*send3);
1067  	node1.process_active (send3);
1068  	system2.deadline_set (10s);
1069  	while (node2.block (send3->hash ()) == nullptr)
1070  	{
1071  		system1.poll ();
1072  		ASSERT_NO_ERROR (system2.poll ());
1073  	}
1074  	auto send1 = builder.make_block ()
1075  				 .account (nano::dev::genesis_key.pub)
1076  				 .previous (send3->hash ())
1077  				 .representative (nano::dev::genesis_key.pub)
1078  				 .balance (nano::dev::constants.genesis_amount - 2 * nano::Mxrb_ratio)
1079  				 .link (key1.pub)
1080  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1081  				 .work (0)
1082  				 .build_shared ();
1083  	node1.work_generate_blocking (*send1);
1084  	auto send2 = builder.make_block ()
1085  				 .account (nano::dev::genesis_key.pub)
1086  				 .previous (send3->hash ())
1087  				 .representative (nano::dev::genesis_key.pub)
1088  				 .balance (nano::dev::constants.genesis_amount - 2 * nano::Mxrb_ratio)
1089  				 .link (key2.pub)
1090  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1091  				 .work (0)
1092  				 .build_shared ();
1093  	node1.work_generate_blocking (*send2);
1094  	{
1095  		auto transaction1 (node1.store.tx_begin_write ());
1096  		ASSERT_EQ (nano::process_result::progress, node1.ledger.process (transaction1, *send1).code);
1097  		auto transaction2 (node2.store.tx_begin_write ());
1098  		ASSERT_EQ (nano::process_result::progress, node2.ledger.process (transaction2, *send2).code);
1099  	}
1100  	node1.process_active (send1);
1101  	node1.process_active (send2);
1102  	node2.process_active (send1);
1103  	node2.process_active (send2);
1104  	node2.bootstrap_initiator.bootstrap (node1.network.endpoint (), false);
1105  	while (node2.block (send1->hash ()) == nullptr)
1106  	{
1107  		system1.poll ();
1108  		ASSERT_NO_ERROR (system2.poll ());
1109  	}
1110  }
1111  TEST (node, DISABLED_broadcast_elected)
1112  {
1113  	auto type = nano::transport::transport_type::tcp;
1114  	nano::node_flags node_flags;
1115  	nano::test::system system;
1116  	nano::node_config node_config (system.get_available_port (), system.logging);
1117  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1118  	auto node0 = system.add_node (node_config, node_flags, type);
1119  	node_config.peering_port = system.get_available_port ();
1120  	auto node1 = system.add_node (node_config, node_flags, type);
1121  	node_config.peering_port = system.get_available_port ();
1122  	auto node2 = system.add_node (node_config, node_flags, type);
1123  	nano::keypair rep_big;
1124  	nano::keypair rep_small;
1125  	nano::keypair rep_other;
1126  	nano::block_builder builder;
1127  	{
1128  		auto transaction0 (node0->store.tx_begin_write ());
1129  		auto transaction1 (node1->store.tx_begin_write ());
1130  		auto transaction2 (node2->store.tx_begin_write ());
1131  		auto fund_big = *builder.send ()
1132  						 .previous (nano::dev::genesis->hash ())
1133  						 .destination (rep_big.pub)
1134  						 .balance (nano::Gxrb_ratio * 5)
1135  						 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1136  						 .work (*system.work.generate (nano::dev::genesis->hash ()))
1137  						 .build ();
1138  		auto open_big = *builder.open ()
1139  						 .source (fund_big.hash ())
1140  						 .representative (rep_big.pub)
1141  						 .account (rep_big.pub)
1142  						 .sign (rep_big.prv, rep_big.pub)
1143  						 .work (*system.work.generate (rep_big.pub))
1144  						 .build ();
1145  		auto fund_small = *builder.send ()
1146  						   .previous (fund_big.hash ())
1147  						   .destination (rep_small.pub)
1148  						   .balance (nano::Gxrb_ratio * 2)
1149  						   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1150  						   .work (*system.work.generate (fund_big.hash ()))
1151  						   .build ();
1152  		auto open_small = *builder.open ()
1153  						   .source (fund_small.hash ())
1154  						   .representative (rep_small.pub)
1155  						   .account (rep_small.pub)
1156  						   .sign (rep_small.prv, rep_small.pub)
1157  						   .work (*system.work.generate (rep_small.pub))
1158  						   .build ();
1159  		auto fund_other = *builder.send ()
1160  						   .previous (fund_small.hash ())
1161  						   .destination (rep_other.pub)
1162  						   .balance (nano::Gxrb_ratio)
1163  						   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1164  						   .work (*system.work.generate (fund_small.hash ()))
1165  						   .build ();
1166  		auto open_other = *builder.open ()
1167  						   .source (fund_other.hash ())
1168  						   .representative (rep_other.pub)
1169  						   .account (rep_other.pub)
1170  						   .sign (rep_other.prv, rep_other.pub)
1171  						   .work (*system.work.generate (rep_other.pub))
1172  						   .build ();
1173  		ASSERT_EQ (nano::process_result::progress, node0->ledger.process (transaction0, fund_big).code);
1174  		ASSERT_EQ (nano::process_result::progress, node1->ledger.process (transaction1, fund_big).code);
1175  		ASSERT_EQ (nano::process_result::progress, node2->ledger.process (transaction2, fund_big).code);
1176  		ASSERT_EQ (nano::process_result::progress, node0->ledger.process (transaction0, open_big).code);
1177  		ASSERT_EQ (nano::process_result::progress, node1->ledger.process (transaction1, open_big).code);
1178  		ASSERT_EQ (nano::process_result::progress, node2->ledger.process (transaction2, open_big).code);
1179  		ASSERT_EQ (nano::process_result::progress, node0->ledger.process (transaction0, fund_small).code);
1180  		ASSERT_EQ (nano::process_result::progress, node1->ledger.process (transaction1, fund_small).code);
1181  		ASSERT_EQ (nano::process_result::progress, node2->ledger.process (transaction2, fund_small).code);
1182  		ASSERT_EQ (nano::process_result::progress, node0->ledger.process (transaction0, open_small).code);
1183  		ASSERT_EQ (nano::process_result::progress, node1->ledger.process (transaction1, open_small).code);
1184  		ASSERT_EQ (nano::process_result::progress, node2->ledger.process (transaction2, open_small).code);
1185  		ASSERT_EQ (nano::process_result::progress, node0->ledger.process (transaction0, fund_other).code);
1186  		ASSERT_EQ (nano::process_result::progress, node1->ledger.process (transaction1, fund_other).code);
1187  		ASSERT_EQ (nano::process_result::progress, node2->ledger.process (transaction2, fund_other).code);
1188  		ASSERT_EQ (nano::process_result::progress, node0->ledger.process (transaction0, open_other).code);
1189  		ASSERT_EQ (nano::process_result::progress, node1->ledger.process (transaction1, open_other).code);
1190  		ASSERT_EQ (nano::process_result::progress, node2->ledger.process (transaction2, open_other).code);
1191  	}
1192  	for (auto & node : system.nodes)
1193  	{
1194  		auto block (node->block (node->latest (nano::dev::genesis_key.pub)));
1195  		ASSERT_NE (nullptr, block);
1196  		node->block_confirm (block);
1197  		auto election (node->active.election (block->qualified_root ()));
1198  		ASSERT_NE (nullptr, election);
1199  		election->force_confirm ();
1200  		ASSERT_TIMELY (5s, 4 == node->ledger.cache.cemented_count)
1201  	}
1202  	system.wallet (0)->insert_adhoc (rep_big.prv);
1203  	system.wallet (1)->insert_adhoc (rep_small.prv);
1204  	system.wallet (2)->insert_adhoc (rep_other.prv);
1205  	auto fork0 = builder.send ()
1206  				 .previous (node2->latest (nano::dev::genesis_key.pub))
1207  				 .destination (rep_small.pub)
1208  				 .balance (0)
1209  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1210  				 .work (*node0->work_generate_blocking (node2->latest (nano::dev::genesis_key.pub)))
1211  				 .build_shared ();
1212  	auto fork0_copy (std::make_shared<nano::send_block> (*fork0));
1213  	node0->process_active (fork0);
1214  	node1->process_active (fork0_copy);
1215  	auto fork1 = builder.send ()
1216  				 .previous (node2->latest (nano::dev::genesis_key.pub))
1217  				 .destination (rep_big.pub)
1218  				 .balance (0)
1219  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1220  				 .work (*node0->work_generate_blocking (node2->latest (nano::dev::genesis_key.pub)))
1221  				 .build_shared ();
1222  	system.wallet (2)->insert_adhoc (rep_small.prv);
1223  	node2->process_active (fork1);
1224  	ASSERT_TIMELY (10s, node0->ledger.block_or_pruned_exists (fork0->hash ()) && node1->ledger.block_or_pruned_exists (fork0->hash ()));
1225  	system.deadline_set (50s);
1226  	while (!node2->ledger.block_or_pruned_exists (fork0->hash ()))
1227  	{
1228  		auto ec = system.poll ();
1229  		ASSERT_TRUE (node0->ledger.block_or_pruned_exists (fork0->hash ()));
1230  		ASSERT_TRUE (node1->ledger.block_or_pruned_exists (fork0->hash ()));
1231  		ASSERT_NO_ERROR (ec);
1232  	}
1233  	ASSERT_TIMELY (5s, node1->stats.count (nano::stat::type::confirmation_observer, nano::stat::detail::inactive_conf_height, nano::stat::dir::out) != 0);
1234  }
1235  TEST (node, rep_self_vote)
1236  {
1237  	nano::test::system system;
1238  	nano::node_config node_config (system.get_available_port (), system.logging);
1239  	node_config.online_weight_minimum = std::numeric_limits<nano::uint128_t>::max ();
1240  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1241  	auto node0 = system.add_node (node_config);
1242  	nano::keypair rep_big;
1243  	nano::block_builder builder;
1244  	auto fund_big = *builder.send ()
1245  					 .previous (nano::dev::genesis->hash ())
1246  					 .destination (rep_big.pub)
1247  					 .balance (nano::uint128_t{ "0xb0000000000000000000000000000000" })
1248  					 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1249  					 .work (*system.work.generate (nano::dev::genesis->hash ()))
1250  					 .build ();
1251  	auto open_big = *builder.open ()
1252  					 .source (fund_big.hash ())
1253  					 .representative (rep_big.pub)
1254  					 .account (rep_big.pub)
1255  					 .sign (rep_big.prv, rep_big.pub)
1256  					 .work (*system.work.generate (rep_big.pub))
1257  					 .build ();
1258  	ASSERT_EQ (nano::process_result::progress, node0->process (fund_big).code);
1259  	ASSERT_EQ (nano::process_result::progress, node0->process (open_big).code);
1260  	node0->block_confirm (node0->block (open_big.hash ()));
1261  	auto election = node0->active.election (open_big.qualified_root ());
1262  	ASSERT_NE (nullptr, election);
1263  	election->force_confirm ();
1264  	system.wallet (0)->insert_adhoc (rep_big.prv);
1265  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
1266  	ASSERT_EQ (system.wallet (0)->wallets.reps ().voting, 2);
1267  	auto block0 = builder.send ()
1268  				  .previous (fund_big.hash ())
1269  				  .destination (rep_big.pub)
1270  				  .balance (nano::uint128_t ("0x60000000000000000000000000000000"))
1271  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1272  				  .work (*system.work.generate (fund_big.hash ()))
1273  				  .build_shared ();
1274  	ASSERT_EQ (nano::process_result::progress, node0->process (*block0).code);
1275  	auto & active = node0->active;
1276  	auto & scheduler = node0->scheduler;
1277  	scheduler.buckets.activate (nano::dev::genesis_key.pub, node0->store.tx_begin_read ());
1278  	ASSERT_TIMELY (5s, active.election (block0->qualified_root ()));
1279  	auto election1 = active.election (block0->qualified_root ());
1280  	ASSERT_NE (nullptr, election1);
1281  	ASSERT_TIMELY (1s, election1->votes ().size () == 3);
1282  	auto rep_votes (election1->votes ());
1283  	ASSERT_NE (rep_votes.end (), rep_votes.find (nano::dev::genesis_key.pub));
1284  	ASSERT_NE (rep_votes.end (), rep_votes.find (rep_big.pub));
1285  }
1286  TEST (node, DISABLED_bootstrap_no_publish)
1287  {
1288  	nano::test::system system0 (1);
1289  	nano::test::system system1 (1);
1290  	auto node0 (system0.nodes[0]);
1291  	auto node1 (system1.nodes[0]);
1292  	nano::keypair key0;
1293  	nano::block_builder builder;
1294  	auto send0 = builder
1295  				 .send ()
1296  				 .previous (node0->latest (nano::dev::genesis_key.pub))
1297  				 .destination (key0.pub)
1298  				 .balance (500)
1299  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1300  				 .work (0)
1301  				 .build ();
1302  	{
1303  		auto transaction (node0->store.tx_begin_write ());
1304  		ASSERT_EQ (nano::process_result::progress, node0->ledger.process (transaction, *send0).code);
1305  	}
1306  	ASSERT_FALSE (node1->bootstrap_initiator.in_progress ());
1307  	node1->bootstrap_initiator.bootstrap (node0->network.endpoint (), false);
1308  	ASSERT_TRUE (node1->active.empty ());
1309  	system1.deadline_set (10s);
1310  	while (node1->block (send0->hash ()) == nullptr)
1311  	{
1312  		system0.poll ();
1313  		auto ec = system1.poll ();
1314  		ASSERT_TRUE (node1->active.empty ());
1315  		ASSERT_NO_ERROR (ec);
1316  	}
1317  }
1318  TEST (node, DISABLED_bootstrap_bulk_push)
1319  {
1320  	nano::test::system system;
1321  	nano::test::system system0;
1322  	nano::test::system system1;
1323  	nano::node_config config0 (system.get_available_port (), system0.logging);
1324  	config0.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1325  	auto node0 (system0.add_node (config0));
1326  	nano::node_config config1 (system.get_available_port (), system1.logging);
1327  	config1.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1328  	auto node1 (system1.add_node (config1));
1329  	nano::keypair key0;
1330  	auto send0 = nano::send_block_builder ()
1331  				 .previous (nano::dev::genesis->hash ())
1332  				 .destination (key0.pub)
1333  				 .balance (500)
1334  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1335  				 .work (*node0->work_generate_blocking (nano::dev::genesis->hash ()))
1336  				 .build_shared ();
1337  	ASSERT_EQ (nano::process_result::progress, node0->process (*send0).code);
1338  	ASSERT_FALSE (node0->bootstrap_initiator.in_progress ());
1339  	ASSERT_FALSE (node1->bootstrap_initiator.in_progress ());
1340  	ASSERT_TRUE (node1->active.empty ());
1341  	node0->bootstrap_initiator.bootstrap (node1->network.endpoint (), false);
1342  	system1.deadline_set (10s);
1343  	while (node1->block (send0->hash ()) == nullptr)
1344  	{
1345  		ASSERT_NO_ERROR (system0.poll ());
1346  		ASSERT_NO_ERROR (system1.poll ());
1347  	}
1348  	system1.deadline_set (10s);
1349  	while (node1->active.empty ())
1350  	{
1351  		ASSERT_NO_ERROR (system0.poll ());
1352  		ASSERT_NO_ERROR (system1.poll ());
1353  	}
1354  }
1355  TEST (node, bootstrap_fork_open)
1356  {
1357  	nano::test::system system;
1358  	nano::node_config node_config (system.get_available_port (), system.logging);
1359  	auto node0 = system.add_node (node_config);
1360  	node_config.peering_port = system.get_available_port ();
1361  	auto node1 = system.add_node (node_config);
1362  	nano::keypair key0;
1363  	nano::block_builder builder;
1364  	auto send0 = *builder.send ()
1365  				  .previous (nano::dev::genesis->hash ())
1366  				  .destination (key0.pub)
1367  				  .balance (nano::dev::constants.genesis_amount - 500)
1368  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1369  				  .work (*system.work.generate (nano::dev::genesis->hash ()))
1370  				  .build ();
1371  	auto open0 = *builder.open ()
1372  				  .source (send0.hash ())
1373  				  .representative (1)
1374  				  .account (key0.pub)
1375  				  .sign (key0.prv, key0.pub)
1376  				  .work (*system.work.generate (key0.pub))
1377  				  .build ();
1378  	auto open1 = *builder.open ()
1379  				  .source (send0.hash ())
1380  				  .representative (2)
1381  				  .account (key0.pub)
1382  				  .sign (key0.prv, key0.pub)
1383  				  .work (*system.work.generate (key0.pub))
1384  				  .build ();
1385  	ASSERT_EQ (nano::process_result::progress, node0->process (send0).code);
1386  	ASSERT_EQ (nano::process_result::progress, node1->process (send0).code);
1387  	for (auto node : system.nodes)
1388  	{
1389  		node->block_confirm (node->block (node->latest (nano::dev::genesis_key.pub)));
1390  		ASSERT_TIMELY (1s, node->active.election (send0.qualified_root ()));
1391  		auto election = node->active.election (send0.qualified_root ());
1392  		ASSERT_NE (nullptr, election);
1393  		election->force_confirm ();
1394  		ASSERT_TIMELY (2s, node->active.empty ());
1395  	}
1396  	ASSERT_TIMELY (3s, node0->block_confirmed (send0.hash ()));
1397  	ASSERT_EQ (nano::process_result::progress, node0->process (open0).code);
1398  	ASSERT_EQ (nano::process_result::progress, node1->process (open1).code);
1399  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
1400  	ASSERT_FALSE (node1->ledger.block_or_pruned_exists (open0.hash ()));
1401  	ASSERT_FALSE (node1->bootstrap_initiator.in_progress ());
1402  	node1->bootstrap_initiator.bootstrap (node0->network.endpoint (), false);
1403  	ASSERT_TIMELY (1s, node1->active.empty ());
1404  	ASSERT_TIMELY (10s, !node1->ledger.block_or_pruned_exists (open1.hash ()) && node1->ledger.block_or_pruned_exists (open0.hash ()));
1405  }
1406  TEST (node, bootstrap_confirm_frontiers)
1407  {
1408  	nano::test::system system0 (1);
1409  	nano::test::system system1 (1);
1410  	auto node0 = system0.nodes[0];
1411  	auto node1 = system1.nodes[0];
1412  	system0.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
1413  	nano::keypair key0;
1414  	auto send0 = nano::send_block_builder ()
1415  				 .previous (nano::dev::genesis->hash ())
1416  				 .destination (key0.pub)
1417  				 .balance (nano::dev::constants.genesis_amount - 500)
1418  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1419  				 .work (*node0->work_generate_blocking (nano::dev::genesis->hash ()))
1420  				 .build_shared ();
1421  	ASSERT_EQ (nano::process_result::progress, node0->process (*send0).code);
1422  	ASSERT_FALSE (node0->bootstrap_initiator.in_progress ());
1423  	ASSERT_FALSE (node1->bootstrap_initiator.in_progress ());
1424  	ASSERT_TRUE (node1->active.empty ());
1425  	node1->bootstrap_initiator.bootstrap (node0->network.endpoint ());
1426  	system0.deadline_set (10s);
1427  	system1.deadline_set (10s);
1428  	while (!node1->ledger.block_confirmed (node1->store.tx_begin_read (), send0->hash ()))
1429  	{
1430  		ASSERT_NO_ERROR (system0.poll (std::chrono::milliseconds (1)));
1431  		ASSERT_NO_ERROR (system1.poll (std::chrono::milliseconds (1)));
1432  	}
1433  }
1434  TEST (node, unconfirmed_send)
1435  {
1436  	nano::test::system system{};
1437  	auto & node1 = *system.add_node ();
1438  	auto wallet1 = system.wallet (0);
1439  	wallet1->insert_adhoc (nano::dev::genesis_key.prv);
1440  	nano::keypair key2{};
1441  	auto & node2 = *system.add_node ();
1442  	auto wallet2 = system.wallet (1);
1443  	wallet2->insert_adhoc (key2.prv);
1444  	auto send1 = wallet1->send_action (nano::dev::genesis->account (), key2.pub, 2 * nano::Mxrb_ratio);
1445  	ASSERT_TIMELY (5s, node1.block_confirmed (send1->hash ()));
1446  	ASSERT_TIMELY (5s, node2.block_confirmed (send1->hash ()));
1447  	ASSERT_TIMELY (5s, node2.get_confirmation_height (node2.store.tx_begin_read (), key2.pub) == 1);
1448  	ASSERT_EQ (node2.balance (key2.pub), 2 * nano::Mxrb_ratio);
1449  	auto recv1 = node2.ledger.find_receive_block_by_send_hash (node2.store.tx_begin_read (), key2.pub, send1->hash ());
1450  	auto send2 = nano::state_block_builder{}
1451  				 .make_block ()
1452  				 .account (key2.pub)
1453  				 .previous (recv1->hash ())
1454  				 .representative (nano::dev::genesis_key.pub)
1455  				 .balance (nano::Mxrb_ratio)
1456  				 .link (nano::dev::genesis->account ())
1457  				 .sign (key2.prv, key2.pub)
1458  				 .work (*system.work.generate (recv1->hash ()))
1459  				 .build_shared ();
1460  	ASSERT_EQ (nano::process_result::progress, node2.process (*send2).code);
1461  	auto send3 = wallet2->send_action (key2.pub, nano::dev::genesis->account (), nano::Mxrb_ratio);
1462  	ASSERT_TIMELY (5s, node2.block_confirmed (send2->hash ()));
1463  	ASSERT_TIMELY (5s, node1.block_confirmed (send2->hash ()));
1464  	ASSERT_TIMELY (5s, node2.block_confirmed (send3->hash ()));
1465  	ASSERT_TIMELY (5s, node1.block_confirmed (send3->hash ()));
1466  	ASSERT_TIMELY (5s, node2.ledger.cache.cemented_count == 7);
1467  	ASSERT_TIMELY (5s, node1.balance (nano::dev::genesis->account ()) == nano::dev::constants.genesis_amount);
1468  }
1469  TEST (node, rep_list)
1470  {
1471  	nano::test::system system (2);
1472  	auto & node1 (*system.nodes[1]);
1473  	auto wallet0 (system.wallet (0));
1474  	auto wallet1 (system.wallet (1));
1475  	wallet0->insert_adhoc (nano::dev::genesis_key.prv);
1476  	nano::keypair key1;
1477  	wallet0->send_action (nano::dev::genesis_key.pub, key1.pub, nano::Mxrb_ratio);
1478  	ASSERT_EQ (0, node1.rep_crawler.representatives (1).size ());
1479  	system.deadline_set (10s);
1480  	auto done (false);
1481  	while (!done)
1482  	{
1483  		auto reps = node1.rep_crawler.representatives (1);
1484  		if (!reps.empty ())
1485  		{
1486  			if (!node1.ledger.weight (reps[0].account).is_zero ())
1487  			{
1488  				done = true;
1489  			}
1490  		}
1491  		ASSERT_NO_ERROR (system.poll ());
1492  	}
1493  }
1494  TEST (node, rep_weight)
1495  {
1496  	nano::test::system system;
1497  	auto add_node = [&system] {
1498  		auto node = std::make_shared<nano::node> (system.io_ctx, system.get_available_port (), nano::unique_path (), system.logging, system.work);
1499  		node->start ();
1500  		system.nodes.push_back (node);
1501  		return node;
1502  	};
1503  	auto & node = *add_node ();
1504  	auto & node1 = *add_node ();
1505  	auto & node2 = *add_node ();
1506  	auto & node3 = *add_node ();
1507  	nano::keypair keypair1;
1508  	nano::keypair keypair2;
1509  	nano::block_builder builder;
1510  	auto amount_pr (node.minimum_principal_weight () + 100);
1511  	auto amount_not_pr (node.minimum_principal_weight () - 100);
1512  	std::shared_ptr<nano::block> block1 = builder
1513  										  .state ()
1514  										  .account (nano::dev::genesis_key.pub)
1515  										  .previous (nano::dev::genesis->hash ())
1516  										  .representative (nano::dev::genesis_key.pub)
1517  										  .balance (nano::dev::constants.genesis_amount - amount_not_pr)
1518  										  .link (keypair1.pub)
1519  										  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1520  										  .work (*system.work.generate (nano::dev::genesis->hash ()))
1521  										  .build ();
1522  	std::shared_ptr<nano::block> block2 = builder
1523  										  .state ()
1524  										  .account (keypair1.pub)
1525  										  .previous (0)
1526  										  .representative (keypair1.pub)
1527  										  .balance (amount_not_pr)
1528  										  .link (block1->hash ())
1529  										  .sign (keypair1.prv, keypair1.pub)
1530  										  .work (*system.work.generate (keypair1.pub))
1531  										  .build ();
1532  	std::shared_ptr<nano::block> block3 = builder
1533  										  .state ()
1534  										  .account (nano::dev::genesis_key.pub)
1535  										  .previous (block1->hash ())
1536  										  .representative (nano::dev::genesis_key.pub)
1537  										  .balance (nano::dev::constants.genesis_amount - amount_not_pr - amount_pr)
1538  										  .link (keypair2.pub)
1539  										  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1540  										  .work (*system.work.generate (block1->hash ()))
1541  										  .build ();
1542  	std::shared_ptr<nano::block> block4 = builder
1543  										  .state ()
1544  										  .account (keypair2.pub)
1545  										  .previous (0)
1546  										  .representative (keypair2.pub)
1547  										  .balance (amount_pr)
1548  										  .link (block3->hash ())
1549  										  .sign (keypair2.prv, keypair2.pub)
1550  										  .work (*system.work.generate (keypair2.pub))
1551  										  .build ();
1552  	{
1553  		auto transaction = node.store.tx_begin_write ();
1554  		ASSERT_EQ (nano::process_result::progress, node.ledger.process (transaction, *block1).code);
1555  		ASSERT_EQ (nano::process_result::progress, node.ledger.process (transaction, *block2).code);
1556  		ASSERT_EQ (nano::process_result::progress, node.ledger.process (transaction, *block3).code);
1557  		ASSERT_EQ (nano::process_result::progress, node.ledger.process (transaction, *block4).code);
1558  	}
1559  	ASSERT_TRUE (node.rep_crawler.representatives (1).empty ());
1560  	std::shared_ptr<nano::transport::channel> channel1 = nano::test::establish_tcp (system, node, node1.network.endpoint ());
1561  	ASSERT_NE (nullptr, channel1);
1562  	std::shared_ptr<nano::transport::channel> channel2 = nano::test::establish_tcp (system, node, node2.network.endpoint ());
1563  	ASSERT_NE (nullptr, channel2);
1564  	std::shared_ptr<nano::transport::channel> channel3 = nano::test::establish_tcp (system, node, node3.network.endpoint ());
1565  	ASSERT_NE (nullptr, channel3);
1566  	auto vote0 = std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, 0, 0, std::vector<nano::block_hash>{ nano::dev::genesis->hash () });
1567  	auto vote1 = std::make_shared<nano::vote> (keypair1.pub, keypair1.prv, 0, 0, std::vector<nano::block_hash>{ nano::dev::genesis->hash () });
1568  	auto vote2 = std::make_shared<nano::vote> (keypair2.pub, keypair2.prv, 0, 0, std::vector<nano::block_hash>{ nano::dev::genesis->hash () });
1569  	node.rep_crawler.response (channel1, vote0);
1570  	node.rep_crawler.response (channel2, vote1);
1571  	node.rep_crawler.response (channel3, vote2);
1572  	ASSERT_TIMELY (5s, node.rep_crawler.representative_count () == 2);
1573  	auto reps = node.rep_crawler.representatives (1);
1574  	ASSERT_EQ (1, reps.size ());
1575  	ASSERT_EQ (node.balance (nano::dev::genesis_key.pub), node.ledger.weight (reps[0].account));
1576  	ASSERT_EQ (nano::dev::genesis_key.pub, reps[0].account);
1577  	ASSERT_EQ (*channel1, reps[0].channel_ref ());
1578  	ASSERT_TRUE (node.rep_crawler.is_pr (*channel1));
1579  	ASSERT_FALSE (node.rep_crawler.is_pr (*channel2));
1580  	ASSERT_TRUE (node.rep_crawler.is_pr (*channel3));
1581  }
1582  TEST (node, rep_remove)
1583  {
1584  	nano::test::system system;
1585  	auto & searching_node = *system.add_node (); 
1586  	nano::keypair keys_rep1; 
1587  	nano::keypair keys_rep2; 
1588  	nano::block_builder builder;
1589  	std::shared_ptr<nano::block> send_to_rep1 = builder
1590  												.state ()
1591  												.account (nano::dev::genesis_key.pub)
1592  												.previous (nano::dev::genesis->hash ())
1593  												.representative (nano::dev::genesis_key.pub)
1594  												.balance (nano::dev::constants.genesis_amount - searching_node.minimum_principal_weight () * 2)
1595  												.link (keys_rep1.pub)
1596  												.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1597  												.work (*system.work.generate (nano::dev::genesis->hash ()))
1598  												.build ();
1599  	std::shared_ptr<nano::block> receive_rep1 = builder
1600  												.state ()
1601  												.account (keys_rep1.pub)
1602  												.previous (0)
1603  												.representative (keys_rep1.pub)
1604  												.balance (searching_node.minimum_principal_weight () * 2)
1605  												.link (send_to_rep1->hash ())
1606  												.sign (keys_rep1.prv, keys_rep1.pub)
1607  												.work (*system.work.generate (keys_rep1.pub))
1608  												.build ();
1609  	std::shared_ptr<nano::block> send_to_rep2 = builder
1610  												.state ()
1611  												.account (nano::dev::genesis_key.pub)
1612  												.previous (send_to_rep1->hash ())
1613  												.representative (nano::dev::genesis_key.pub)
1614  												.balance (nano::dev::constants.genesis_amount - searching_node.minimum_principal_weight () * 4)
1615  												.link (keys_rep2.pub)
1616  												.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1617  												.work (*system.work.generate (send_to_rep1->hash ()))
1618  												.build ();
1619  	std::shared_ptr<nano::block> receive_rep2 = builder
1620  												.state ()
1621  												.account (keys_rep2.pub)
1622  												.previous (0)
1623  												.representative (keys_rep2.pub)
1624  												.balance (searching_node.minimum_principal_weight () * 2)
1625  												.link (send_to_rep2->hash ())
1626  												.sign (keys_rep2.prv, keys_rep2.pub)
1627  												.work (*system.work.generate (keys_rep2.pub))
1628  												.build ();
1629  	{
1630  		auto transaction = searching_node.store.tx_begin_write ();
1631  		ASSERT_EQ (nano::process_result::progress, searching_node.ledger.process (transaction, *send_to_rep1).code);
1632  		ASSERT_EQ (nano::process_result::progress, searching_node.ledger.process (transaction, *receive_rep1).code);
1633  		ASSERT_EQ (nano::process_result::progress, searching_node.ledger.process (transaction, *send_to_rep2).code);
1634  		ASSERT_EQ (nano::process_result::progress, searching_node.ledger.process (transaction, *receive_rep2).code);
1635  	}
1636  	auto channel_rep1 (std::make_shared<nano::transport::fake::channel> (searching_node));
1637  	auto vote_rep1 = std::make_shared<nano::vote> (keys_rep1.pub, keys_rep1.prv, 0, 0, std::vector<nano::block_hash>{ nano::dev::genesis->hash () });
1638  	ASSERT_FALSE (searching_node.rep_crawler.response (channel_rep1, vote_rep1, true));
1639  	ASSERT_TIMELY (5s, searching_node.rep_crawler.representative_count () == 1);
1640  	auto reps (searching_node.rep_crawler.representatives (1));
1641  	ASSERT_EQ (1, reps.size ());
1642  	ASSERT_EQ (searching_node.minimum_principal_weight () * 2, searching_node.ledger.weight (reps[0].account));
1643  	ASSERT_EQ (keys_rep1.pub, reps[0].account);
1644  	ASSERT_EQ (*channel_rep1, reps[0].channel_ref ());
1645  	channel_rep1->close ();
1646  	ASSERT_TIMELY (5s, searching_node.rep_crawler.representative_count () == 0);
1647  	auto node_genesis_rep = system.add_node (nano::node_config (system.get_available_port (), system.logging));
1648  	system.wallet (1)->insert_adhoc (nano::dev::genesis_key.prv);
1649  	auto channel_genesis_rep (searching_node.network.find_node_id (node_genesis_rep->get_node_id ()));
1650  	ASSERT_NE (nullptr, channel_genesis_rep);
1651  	auto vote_genesis_rep = std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, 0, 0, std::vector<nano::block_hash>{ nano::dev::genesis->hash () });
1652  	searching_node.rep_crawler.response (channel_genesis_rep, vote_genesis_rep, true);
1653  	ASSERT_TIMELY (10s, searching_node.rep_crawler.representative_count () == 1);
1654  	auto node_rep2 (std::make_shared<nano::node> (system.io_ctx, nano::unique_path (), nano::node_config (system.get_available_port (), system.logging), system.work));
1655  	node_rep2->start ();
1656  	searching_node.network.tcp_channels.start_tcp (node_rep2->network.endpoint ());
1657  	std::shared_ptr<nano::transport::channel> channel_rep2;
1658  	ASSERT_TIMELY (10s, (channel_rep2 = searching_node.network.tcp_channels.find_node_id (node_rep2->get_node_id ())) != nullptr);
1659  	auto vote_rep2 = std::make_shared<nano::vote> (keys_rep2.pub, keys_rep2.prv, 0, 0, std::vector<nano::block_hash>{ nano::dev::genesis->hash () });
1660  	ASSERT_FALSE (searching_node.rep_crawler.response (channel_rep2, vote_rep2, true));
1661  	ASSERT_TIMELY (10s, searching_node.rep_crawler.representative_count () == 2);
1662  	node_rep2->stop ();
1663  	ASSERT_TIMELY (10s, searching_node.rep_crawler.representative_count () == 1);
1664  	reps = searching_node.rep_crawler.representatives (1);
1665  	ASSERT_EQ (nano::dev::genesis_key.pub, reps[0].account);
1666  	ASSERT_TIMELY_EQ (5s, searching_node.network.size (), 1);
1667  	auto list (searching_node.network.list (1));
1668  	ASSERT_EQ (node_genesis_rep->network.endpoint (), list[0]->get_endpoint ());
1669  }
1670  TEST (node, rep_connection_close)
1671  {
1672  	nano::test::system system (2);
1673  	auto & node1 (*system.nodes[0]);
1674  	auto & node2 (*system.nodes[1]);
1675  	system.wallet (1)->insert_adhoc (nano::dev::genesis_key.prv);
1676  	ASSERT_TIMELY (10s, node1.rep_crawler.representative_count () == 1);
1677  	node2.stop ();
1678  	ASSERT_TIMELY (10s, node1.rep_crawler.representative_count () == 0);
1679  }
1680  TEST (node, no_voting)
1681  {
1682  	nano::test::system system (1);
1683  	auto & node0 (*system.nodes[0]);
1684  	nano::node_config node_config (system.get_available_port (), system.logging);
1685  	node_config.enable_voting = false;
1686  	system.add_node (node_config);
1687  	auto wallet0 (system.wallet (0));
1688  	auto wallet1 (system.wallet (1));
1689  	wallet1->insert_adhoc (nano::dev::genesis_key.prv);
1690  	nano::keypair key1;
1691  	wallet1->insert_adhoc (key1.prv);
1692  	wallet1->send_action (nano::dev::genesis_key.pub, key1.pub, nano::Mxrb_ratio);
1693  	ASSERT_TIMELY (10s, node0.active.empty ());
1694  	ASSERT_EQ (0, node0.stats.count (nano::stat::type::message, nano::stat::detail::confirm_ack, nano::stat::dir::in));
1695  }
1696  TEST (node, send_callback)
1697  {
1698  	nano::test::system system (1);
1699  	auto & node0 (*system.nodes[0]);
1700  	nano::keypair key2;
1701  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
1702  	system.wallet (0)->insert_adhoc (key2.prv);
1703  	node0.config.callback_address = "localhost";
1704  	node0.config.callback_port = 8010;
1705  	node0.config.callback_target = "/";
1706  	ASSERT_NE (nullptr, system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, node0.config.receive_minimum.number ()));
1707  	ASSERT_TIMELY (10s, node0.balance (key2.pub).is_zero ());
1708  	ASSERT_EQ (std::numeric_limits<nano::uint128_t>::max () - node0.config.receive_minimum.number (), node0.balance (nano::dev::genesis_key.pub));
1709  }
1710  TEST (node, balance_observer)
1711  {
1712  	nano::test::system system (1);
1713  	auto & node1 (*system.nodes[0]);
1714  	std::atomic<int> balances (0);
1715  	nano::keypair key;
1716  	node1.observers.account_balance.add ([&key, &balances] (nano::account const & account_a, bool is_pending) {
1717  		if (key.pub == account_a && is_pending)
1718  		{
1719  			balances++;
1720  		}
1721  		else if (nano::dev::genesis_key.pub == account_a && !is_pending)
1722  		{
1723  			balances++;
1724  		}
1725  	});
1726  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
1727  	system.wallet (0)->send_action (nano::dev::genesis_key.pub, key.pub, 1);
1728  	system.deadline_set (10s);
1729  	auto done (false);
1730  	while (!done)
1731  	{
1732  		auto ec = system.poll ();
1733  		done = balances.load () == 2;
1734  		ASSERT_NO_ERROR (ec);
1735  	}
1736  }
1737  TEST (node, bootstrap_connection_scaling)
1738  {
1739  	nano::test::system system (1);
1740  	auto & node1 (*system.nodes[0]);
1741  	ASSERT_EQ (34, node1.bootstrap_initiator.connections->target_connections (5000, 1));
1742  	ASSERT_EQ (4, node1.bootstrap_initiator.connections->target_connections (0, 1));
1743  	ASSERT_EQ (64, node1.bootstrap_initiator.connections->target_connections (50000, 1));
1744  	ASSERT_EQ (64, node1.bootstrap_initiator.connections->target_connections (10000000000, 1));
1745  	ASSERT_EQ (32, node1.bootstrap_initiator.connections->target_connections (5000, 0));
1746  	ASSERT_EQ (1, node1.bootstrap_initiator.connections->target_connections (0, 0));
1747  	ASSERT_EQ (64, node1.bootstrap_initiator.connections->target_connections (50000, 0));
1748  	ASSERT_EQ (64, node1.bootstrap_initiator.connections->target_connections (10000000000, 0));
1749  	ASSERT_EQ (36, node1.bootstrap_initiator.connections->target_connections (5000, 2));
1750  	ASSERT_EQ (8, node1.bootstrap_initiator.connections->target_connections (0, 2));
1751  	ASSERT_EQ (64, node1.bootstrap_initiator.connections->target_connections (50000, 2));
1752  	ASSERT_EQ (64, node1.bootstrap_initiator.connections->target_connections (10000000000, 2));
1753  	node1.config.bootstrap_connections = 128;
1754  	ASSERT_EQ (64, node1.bootstrap_initiator.connections->target_connections (0, 1));
1755  	ASSERT_EQ (64, node1.bootstrap_initiator.connections->target_connections (50000, 1));
1756  	ASSERT_EQ (64, node1.bootstrap_initiator.connections->target_connections (0, 2));
1757  	ASSERT_EQ (64, node1.bootstrap_initiator.connections->target_connections (50000, 2));
1758  	node1.config.bootstrap_connections_max = 256;
1759  	ASSERT_EQ (128, node1.bootstrap_initiator.connections->target_connections (0, 1));
1760  	ASSERT_EQ (256, node1.bootstrap_initiator.connections->target_connections (50000, 1));
1761  	ASSERT_EQ (256, node1.bootstrap_initiator.connections->target_connections (0, 2));
1762  	ASSERT_EQ (256, node1.bootstrap_initiator.connections->target_connections (50000, 2));
1763  	node1.config.bootstrap_connections_max = 0;
1764  	ASSERT_EQ (1, node1.bootstrap_initiator.connections->target_connections (0, 1));
1765  	ASSERT_EQ (1, node1.bootstrap_initiator.connections->target_connections (50000, 1));
1766  }
1767  TEST (node, stat_counting)
1768  {
1769  	nano::test::system system (1);
1770  	auto & node1 (*system.nodes[0]);
1771  	node1.stats.add (nano::stat::type::ledger, nano::stat::dir::in, 1);
1772  	node1.stats.add (nano::stat::type::ledger, nano::stat::dir::in, 5);
1773  	node1.stats.inc (nano::stat::type::ledger, nano::stat::dir::in);
1774  	node1.stats.inc (nano::stat::type::ledger, nano::stat::detail::send, nano::stat::dir::in);
1775  	node1.stats.inc (nano::stat::type::ledger, nano::stat::detail::send, nano::stat::dir::in);
1776  	node1.stats.inc (nano::stat::type::ledger, nano::stat::detail::receive, nano::stat::dir::in);
1777  	ASSERT_EQ (10, node1.stats.count (nano::stat::type::ledger, nano::stat::dir::in));
1778  	ASSERT_EQ (2, node1.stats.count (nano::stat::type::ledger, nano::stat::detail::send, nano::stat::dir::in));
1779  	ASSERT_EQ (1, node1.stats.count (nano::stat::type::ledger, nano::stat::detail::receive, nano::stat::dir::in));
1780  	node1.stats.add (nano::stat::type::ledger, nano::stat::dir::in, 0);
1781  	ASSERT_EQ (10, node1.stats.count (nano::stat::type::ledger, nano::stat::dir::in));
1782  }
1783  TEST (node, stat_histogram)
1784  {
1785  	nano::test::system system (1);
1786  	auto & node1 (*system.nodes[0]);
1787  	node1.stats.define_histogram (nano::stat::type::vote, nano::stat::detail::confirm_req, nano::stat::dir::in, { 1, 6, 10, 16 });
1788  	node1.stats.update_histogram (nano::stat::type::vote, nano::stat::detail::confirm_req, nano::stat::dir::in, 1, 50);
1789  	auto histogram_req (node1.stats.get_histogram (nano::stat::type::vote, nano::stat::detail::confirm_req, nano::stat::dir::in));
1790  	ASSERT_EQ (histogram_req->get_bins ()[0].value, 50);
1791  	node1.stats.define_histogram (nano::stat::type::vote, nano::stat::detail::confirm_ack, nano::stat::dir::in, { 1, 13 }, 12);
1792  	node1.stats.update_histogram (nano::stat::type::vote, nano::stat::detail::confirm_ack, nano::stat::dir::in, 1);
1793  	node1.stats.update_histogram (nano::stat::type::vote, nano::stat::detail::confirm_ack, nano::stat::dir::in, 8, 10);
1794  	node1.stats.update_histogram (nano::stat::type::vote, nano::stat::detail::confirm_ack, nano::stat::dir::in, 100);
1795  	auto histogram_ack (node1.stats.get_histogram (nano::stat::type::vote, nano::stat::detail::confirm_ack, nano::stat::dir::in));
1796  	ASSERT_EQ (histogram_ack->get_bins ()[0].value, 1);
1797  	ASSERT_EQ (histogram_ack->get_bins ()[7].value, 10);
1798  	ASSERT_EQ (histogram_ack->get_bins ()[11].value, 1);
1799  	node1.stats.define_histogram (nano::stat::type::vote, nano::stat::detail::confirm_ack, nano::stat::dir::out, { 1, 11 }, 2);
1800  	node1.stats.update_histogram (nano::stat::type::vote, nano::stat::detail::confirm_ack, nano::stat::dir::out, 1, 1);
1801  	node1.stats.update_histogram (nano::stat::type::vote, nano::stat::detail::confirm_ack, nano::stat::dir::out, 6, 1);
1802  	auto histogram_ack_out (node1.stats.get_histogram (nano::stat::type::vote, nano::stat::detail::confirm_ack, nano::stat::dir::out));
1803  	ASSERT_EQ (histogram_ack_out->get_bins ()[0].value, 1);
1804  	ASSERT_EQ (histogram_ack_out->get_bins ()[1].value, 1);
1805  }
1806  TEST (node, online_reps)
1807  {
1808  	nano::test::system system (1);
1809  	auto & node1 (*system.nodes[0]);
1810  	ASSERT_EQ (node1.config.online_weight_minimum, node1.online_reps.trended ());
1811  	auto vote (std::make_shared<nano::vote> ());
1812  	ASSERT_EQ (0, node1.online_reps.online ());
1813  	node1.online_reps.observe (nano::dev::genesis_key.pub);
1814  	ASSERT_EQ (nano::dev::constants.genesis_amount, node1.online_reps.online ());
1815  	ASSERT_EQ (node1.config.online_weight_minimum, node1.online_reps.trended ());
1816  	node1.online_reps.sample ();
1817  	ASSERT_EQ (nano::dev::constants.genesis_amount, node1.online_reps.trended ());
1818  	node1.online_reps.clear ();
1819  	node1.online_reps.sample ();
1820  	ASSERT_EQ (node1.config.online_weight_minimum, node1.online_reps.trended ());
1821  }
1822  namespace nano
1823  {
1824  TEST (node, online_reps_rep_crawler)
1825  {
1826  	nano::test::system system;
1827  	nano::node_flags flags;
1828  	flags.disable_rep_crawler = true;
1829  	auto & node1 = *system.add_node (flags);
1830  	auto vote = std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::milliseconds_since_epoch (), 0, std::vector<nano::block_hash>{ nano::dev::genesis->hash () });
1831  	ASSERT_EQ (0, node1.online_reps.online ());
1832  	node1.vote_processor.vote_blocking (vote, std::make_shared<nano::transport::fake::channel> (node1));
1833  	ASSERT_EQ (0, node1.online_reps.online ());
1834  	{
1835  		nano::lock_guard<nano::mutex> guard{ node1.rep_crawler.probable_reps_mutex };
1836  		node1.rep_crawler.active.insert (nano::dev::genesis->hash ());
1837  	}
1838  	node1.vote_processor.vote_blocking (vote, std::make_shared<nano::transport::fake::channel> (node1));
1839  	ASSERT_EQ (nano::dev::constants.genesis_amount, node1.online_reps.online ());
1840  }
1841  }
1842  TEST (node, online_reps_election)
1843  {
1844  	nano::test::system system;
1845  	nano::node_flags flags;
1846  	flags.disable_rep_crawler = true;
1847  	auto & node1 = *system.add_node (flags);
1848  	nano::keypair key;
1849  	nano::state_block_builder builder;
1850  	auto send1 = builder.make_block ()
1851  				 .account (nano::dev::genesis_key.pub)
1852  				 .previous (nano::dev::genesis->hash ())
1853  				 .representative (nano::dev::genesis_key.pub)
1854  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
1855  				 .link (key.pub)
1856  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1857  				 .work (*node1.work_generate_blocking (nano::dev::genesis->hash ()))
1858  				 .build_shared ();
1859  	node1.process_active (send1);
1860  	node1.block_processor.flush ();
1861  	ASSERT_TIMELY_EQ (5s, 1, node1.active.size ());
1862  	auto vote = std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::milliseconds_since_epoch (), 0, std::vector<nano::block_hash>{ send1->hash () });
1863  	ASSERT_EQ (0, node1.online_reps.online ());
1864  	node1.vote_processor.vote_blocking (vote, std::make_shared<nano::transport::fake::channel> (node1));
1865  	ASSERT_EQ (nano::dev::constants.genesis_amount - nano::Gxrb_ratio, node1.online_reps.online ());
1866  }
1867  TEST (node, block_confirm)
1868  {
1869  	auto type = nano::transport::transport_type::tcp;
1870  	nano::node_flags node_flags;
1871  	nano::test::system system (2, type, node_flags);
1872  	auto & node1 (*system.nodes[0]);
1873  	auto & node2 (*system.nodes[1]);
1874  	nano::keypair key;
1875  	nano::state_block_builder builder;
1876  	system.wallet (1)->insert_adhoc (nano::dev::genesis_key.prv);
1877  	auto send1 = builder.make_block ()
1878  				 .account (nano::dev::genesis_key.pub)
1879  				 .previous (nano::dev::genesis->hash ())
1880  				 .representative (nano::dev::genesis_key.pub)
1881  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
1882  				 .link (key.pub)
1883  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1884  				 .work (*node1.work_generate_blocking (nano::dev::genesis->hash ()))
1885  				 .build_shared ();
1886  	auto send1_copy = builder.make_block ()
1887  					  .from (*send1)
1888  					  .build_shared ();
1889  	node1.block_processor.add (send1);
1890  	node2.block_processor.add (send1_copy);
1891  	ASSERT_TIMELY (5s, node1.ledger.block_or_pruned_exists (send1->hash ()) && node2.ledger.block_or_pruned_exists (send1_copy->hash ()));
1892  	ASSERT_TRUE (node1.ledger.block_or_pruned_exists (send1->hash ()));
1893  	ASSERT_TRUE (node2.ledger.block_or_pruned_exists (send1_copy->hash ()));
1894  	node2.block_confirm (send1_copy);
1895  	auto election = node2.active.election (send1_copy->qualified_root ());
1896  	ASSERT_NE (nullptr, election);
1897  	ASSERT_TIMELY (10s, node1.active.recently_cemented.list ().size () == 1);
1898  }
1899  TEST (node, block_arrival)
1900  {
1901  	nano::test::system system (1);
1902  	auto & node (*system.nodes[0]);
1903  	ASSERT_EQ (0, node.block_arrival.arrival.size ());
1904  	nano::block_hash hash1 (1);
1905  	node.block_arrival.add (hash1);
1906  	ASSERT_EQ (1, node.block_arrival.arrival.size ());
1907  	node.block_arrival.add (hash1);
1908  	ASSERT_EQ (1, node.block_arrival.arrival.size ());
1909  	nano::block_hash hash2 (2);
1910  	node.block_arrival.add (hash2);
1911  	ASSERT_EQ (2, node.block_arrival.arrival.size ());
1912  }
1913  TEST (node, block_arrival_size)
1914  {
1915  	nano::test::system system (1);
1916  	auto & node (*system.nodes[0]);
1917  	auto time (std::chrono::steady_clock::now () - nano::block_arrival::arrival_time_min - std::chrono::seconds (5));
1918  	nano::block_hash hash (0);
1919  	for (auto i (0); i < nano::block_arrival::arrival_size_min * 2; ++i)
1920  	{
1921  		node.block_arrival.arrival.push_back (nano::block_arrival_info{ time, hash });
1922  		++hash.qwords[0];
1923  	}
1924  	ASSERT_EQ (nano::block_arrival::arrival_size_min * 2, node.block_arrival.arrival.size ());
1925  	node.block_arrival.recent (0);
1926  	ASSERT_EQ (nano::block_arrival::arrival_size_min, node.block_arrival.arrival.size ());
1927  }
1928  TEST (node, block_arrival_time)
1929  {
1930  	nano::test::system system (1);
1931  	auto & node (*system.nodes[0]);
1932  	auto time (std::chrono::steady_clock::now ());
1933  	nano::block_hash hash (0);
1934  	for (auto i (0); i < nano::block_arrival::arrival_size_min * 2; ++i)
1935  	{
1936  		node.block_arrival.arrival.push_back (nano::block_arrival_info{ time, hash });
1937  		++hash.qwords[0];
1938  	}
1939  	ASSERT_EQ (nano::block_arrival::arrival_size_min * 2, node.block_arrival.arrival.size ());
1940  	node.block_arrival.recent (0);
1941  	ASSERT_EQ (nano::block_arrival::arrival_size_min * 2, node.block_arrival.arrival.size ());
1942  }
1943  TEST (node, confirm_quorum)
1944  {
1945  	nano::test::system system (1);
1946  	auto & node1 = *system.nodes[0];
1947  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
1948  	nano::amount new_balance = node1.online_reps.delta () - nano::Gxrb_ratio;
1949  	auto send1 = nano::state_block_builder ()
1950  				 .account (nano::dev::genesis_key.pub)
1951  				 .previous (nano::dev::genesis->hash ())
1952  				 .representative (nano::dev::genesis_key.pub)
1953  				 .balance (new_balance)
1954  				 .link (nano::dev::genesis_key.pub)
1955  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1956  				 .work (*node1.work_generate_blocking (nano::dev::genesis->hash ()))
1957  				 .build_shared ();
1958  	ASSERT_EQ (nano::process_result::progress, node1.process (*send1).code);
1959  	system.wallet (0)->send_action (nano::dev::genesis_key.pub, nano::dev::genesis_key.pub, new_balance.number ());
1960  	ASSERT_TIMELY (2s, node1.active.election (send1->qualified_root ()));
1961  	auto election = node1.active.election (send1->qualified_root ());
1962  	ASSERT_NE (nullptr, election);
1963  	ASSERT_FALSE (election->confirmed ());
1964  	ASSERT_EQ (1, election->votes ().size ());
1965  	ASSERT_EQ (0, node1.balance (nano::dev::genesis_key.pub));
1966  }
1967  TEST (node, local_votes_cache)
1968  {
1969  	nano::test::system system;
1970  	nano::node_config node_config (system.get_available_port (), system.logging);
1971  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1972  	node_config.receive_minimum = nano::dev::constants.genesis_amount;
1973  	auto & node (*system.add_node (node_config));
1974  	nano::state_block_builder builder;
1975  	auto send1 = builder.make_block ()
1976  				 .account (nano::dev::genesis_key.pub)
1977  				 .previous (nano::dev::genesis->hash ())
1978  				 .representative (nano::dev::genesis_key.pub)
1979  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
1980  				 .link (nano::dev::genesis_key.pub)
1981  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1982  				 .work (*node.work_generate_blocking (nano::dev::genesis->hash ()))
1983  				 .build_shared ();
1984  	auto send2 = builder.make_block ()
1985  				 .account (nano::dev::genesis_key.pub)
1986  				 .previous (send1->hash ())
1987  				 .representative (nano::dev::genesis_key.pub)
1988  				 .balance (nano::dev::constants.genesis_amount - 2 * nano::Gxrb_ratio)
1989  				 .link (nano::dev::genesis_key.pub)
1990  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1991  				 .work (*node.work_generate_blocking (send1->hash ()))
1992  				 .build_shared ();
1993  	auto send3 = builder.make_block ()
1994  				 .account (nano::dev::genesis_key.pub)
1995  				 .previous (send2->hash ())
1996  				 .representative (nano::dev::genesis_key.pub)
1997  				 .balance (nano::dev::constants.genesis_amount - 3 * nano::Gxrb_ratio)
1998  				 .link (nano::dev::genesis_key.pub)
1999  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2000  				 .work (*node.work_generate_blocking (send2->hash ()))
2001  				 .build_shared ();
2002  	{
2003  		auto transaction (node.store.tx_begin_write ());
2004  		ASSERT_EQ (nano::process_result::progress, node.ledger.process (transaction, *send1).code);
2005  		ASSERT_EQ (nano::process_result::progress, node.ledger.process (transaction, *send2).code);
2006  	}
2007  	node.block_confirm (send2);
2008  	auto election = node.active.election (send2->qualified_root ());
2009  	ASSERT_NE (nullptr, election);
2010  	election->force_confirm ();
2011  	ASSERT_TIMELY (3s, node.ledger.cache.cemented_count == 3);
2012  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
2013  	nano::confirm_req message1{ nano::dev::network_params.network, send1 };
2014  	nano::confirm_req message2{ nano::dev::network_params.network, send2 };
2015  	auto channel = std::make_shared<nano::transport::fake::channel> (node);
2016  	node.network.inbound (message1, channel);
2017  	ASSERT_TIMELY (3s, node.stats.count (nano::stat::type::requests, nano::stat::detail::requests_generated_votes) == 1);
2018  	node.network.inbound (message2, channel);
2019  	ASSERT_TIMELY (3s, node.stats.count (nano::stat::type::requests, nano::stat::detail::requests_generated_votes) == 2);
2020  	for (auto i (0); i < 100; ++i)
2021  	{
2022  		node.network.inbound (message1, channel);
2023  		node.network.inbound (message2, channel);
2024  	}
2025  	for (int i = 0; i < 4; ++i)
2026  	{
2027  		ASSERT_NO_ERROR (system.poll (node.aggregator.max_delay));
2028  	}
2029  	ASSERT_TIMELY (3s, node.stats.count (nano::stat::type::requests, nano::stat::detail::requests_generated_votes) == 2);
2030  	{
2031  		auto transaction (node.store.tx_begin_write ());
2032  		ASSERT_EQ (nano::process_result::progress, node.ledger.process (transaction, *send3).code);
2033  	}
2034  	nano::confirm_req message3{ nano::dev::network_params.network, send3 };
2035  	for (auto i (0); i < 100; ++i)
2036  	{
2037  		node.network.inbound (message3, channel);
2038  	}
2039  	for (int i = 0; i < 4; ++i)
2040  	{
2041  		ASSERT_NO_ERROR (system.poll (node.aggregator.max_delay));
2042  	}
2043  	ASSERT_TIMELY (3s, node.stats.count (nano::stat::type::requests, nano::stat::detail::requests_generated_votes) == 3);
2044  	ASSERT_TIMELY (3s, !node.history.votes (send1->root (), send1->hash ()).empty ());
2045  	ASSERT_TIMELY (3s, !node.history.votes (send2->root (), send2->hash ()).empty ());
2046  	ASSERT_TIMELY (3s, !node.history.votes (send3->root (), send3->hash ()).empty ());
2047  }
2048  TEST (node, DISABLED_local_votes_cache_batch)
2049  {
2050  	nano::test::system system;
2051  	nano::node_config node_config (system.get_available_port (), system.logging);
2052  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
2053  	auto & node (*system.add_node (node_config));
2054  	ASSERT_GE (node.network_params.voting.max_cache, 2);
2055  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
2056  	nano::keypair key1;
2057  	auto send1 = nano::state_block_builder ()
2058  				 .account (nano::dev::genesis_key.pub)
2059  				 .previous (nano::dev::genesis->hash ())
2060  				 .representative (nano::dev::genesis_key.pub)
2061  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
2062  				 .link (key1.pub)
2063  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2064  				 .work (*node.work_generate_blocking (nano::dev::genesis->hash ()))
2065  				 .build_shared ();
2066  	ASSERT_EQ (nano::process_result::progress, node.ledger.process (node.store.tx_begin_write (), *send1).code);
2067  	node.confirmation_height_processor.add (send1);
2068  	ASSERT_TIMELY (5s, node.ledger.block_confirmed (node.store.tx_begin_read (), send1->hash ()));
2069  	auto send2 = nano::state_block_builder ()
2070  				 .account (nano::dev::genesis_key.pub)
2071  				 .previous (send1->hash ())
2072  				 .representative (nano::dev::genesis_key.pub)
2073  				 .balance (nano::dev::constants.genesis_amount - 2 * nano::Gxrb_ratio)
2074  				 .link (nano::dev::genesis_key.pub)
2075  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2076  				 .work (*node.work_generate_blocking (send1->hash ()))
2077  				 .build_shared ();
2078  	ASSERT_EQ (nano::process_result::progress, node.ledger.process (node.store.tx_begin_write (), *send2).code);
2079  	auto receive1 = nano::state_block_builder ()
2080  					.account (key1.pub)
2081  					.previous (0)
2082  					.representative (nano::dev::genesis_key.pub)
2083  					.balance (nano::Gxrb_ratio)
2084  					.link (send1->hash ())
2085  					.sign (key1.prv, key1.pub)
2086  					.work (*node.work_generate_blocking (key1.pub))
2087  					.build_shared ();
2088  	ASSERT_EQ (nano::process_result::progress, node.ledger.process (node.store.tx_begin_write (), *receive1).code);
2089  	std::vector<std::pair<nano::block_hash, nano::root>> batch{ { send2->hash (), send2->root () }, { receive1->hash (), receive1->root () } };
2090  	nano::confirm_req message{ nano::dev::network_params.network, batch };
2091  	auto channel = std::make_shared<nano::transport::fake::channel> (node);
2092  	node.network.inbound (message, channel);
2093  	ASSERT_TIMELY (3s, node.stats.count (nano::stat::type::message, nano::stat::detail::confirm_ack, nano::stat::dir::out) == 1);
2094  	ASSERT_EQ (1, node.stats.count (nano::stat::type::message, nano::stat::detail::confirm_ack, nano::stat::dir::out));
2095  	ASSERT_FALSE (node.history.votes (send2->root (), send2->hash ()).empty ());
2096  	ASSERT_FALSE (node.history.votes (receive1->root (), receive1->hash ()).empty ());
2097  	node.network.inbound (message, channel);
2098  	ASSERT_TIMELY (3s, node.stats.count (nano::stat::type::message, nano::stat::detail::confirm_ack, nano::stat::dir::out) == 2);
2099  	ASSERT_EQ (2, node.stats.count (nano::stat::type::message, nano::stat::detail::confirm_ack, nano::stat::dir::out));
2100  	node.history.erase (send2->root ());
2101  	node.history.erase (receive1->root ());
2102  	node.network.inbound (nano::confirm_req{ nano::dev::network_params.network, send2->hash (), send2->root () }, channel);
2103  	ASSERT_TIMELY (3s, node.stats.count (nano::stat::type::message, nano::stat::detail::confirm_ack, nano::stat::dir::out) == 3);
2104  	ASSERT_EQ (3, node.stats.count (nano::stat::type::message, nano::stat::detail::confirm_ack, nano::stat::dir::out));
2105  	node.network.inbound (nano::confirm_req{ nano::dev::network_params.network, receive1->hash (), receive1->root () }, channel);
2106  	ASSERT_TIMELY (3s, node.stats.count (nano::stat::type::message, nano::stat::detail::confirm_ack, nano::stat::dir::out) == 4);
2107  	ASSERT_EQ (4, node.stats.count (nano::stat::type::message, nano::stat::detail::confirm_ack, nano::stat::dir::out));
2108  	node.network.inbound (message, channel);
2109  	ASSERT_TIMELY (3s, node.stats.count (nano::stat::type::message, nano::stat::detail::confirm_ack, nano::stat::dir::out) == 6);
2110  	ASSERT_EQ (6, node.stats.count (nano::stat::type::message, nano::stat::detail::confirm_ack, nano::stat::dir::out));
2111  }
2112  TEST (node, local_votes_cache_generate_new_vote)
2113  {
2114  	nano::test::system system;
2115  	nano::node_config node_config (system.get_available_port (), system.logging);
2116  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
2117  	auto & node (*system.add_node (node_config));
2118  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
2119  	nano::confirm_req message1{ nano::dev::network_params.network, nano::dev::genesis };
2120  	auto channel = std::make_shared<nano::transport::fake::channel> (node);
2121  	node.network.inbound (message1, channel);
2122  	ASSERT_TIMELY (5s, !node.history.votes (nano::dev::genesis->root (), nano::dev::genesis->hash ()).empty ());
2123  	auto votes1 = node.history.votes (nano::dev::genesis->root (), nano::dev::genesis->hash ());
2124  	ASSERT_EQ (1, votes1.size ());
2125  	ASSERT_EQ (1, votes1[0]->hashes.size ());
2126  	ASSERT_EQ (nano::dev::genesis->hash (), votes1[0]->hashes[0]);
2127  	ASSERT_TIMELY (3s, node.stats.count (nano::stat::type::requests, nano::stat::detail::requests_generated_votes) == 1);
2128  	auto send1 = nano::state_block_builder ()
2129  				 .account (nano::dev::genesis_key.pub)
2130  				 .previous (nano::dev::genesis->hash ())
2131  				 .representative (nano::dev::genesis_key.pub)
2132  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
2133  				 .link (nano::dev::genesis_key.pub)
2134  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2135  				 .work (*node.work_generate_blocking (nano::dev::genesis->hash ()))
2136  				 .build_shared ();
2137  	ASSERT_EQ (nano::process_result::progress, node.process (*send1).code);
2138  	std::vector<std::pair<nano::block_hash, nano::root>> roots_hashes{ std::make_pair (nano::dev::genesis->hash (), nano::dev::genesis->root ()), std::make_pair (send1->hash (), send1->root ()) };
2139  	nano::confirm_req message2{ nano::dev::network_params.network, roots_hashes };
2140  	node.network.inbound (message2, channel);
2141  	ASSERT_TIMELY (3s, !node.history.votes (send1->root (), send1->hash ()).empty ());
2142  	auto votes2 (node.history.votes (send1->root (), send1->hash ()));
2143  	ASSERT_EQ (1, votes2.size ());
2144  	ASSERT_EQ (1, votes2[0]->hashes.size ());
2145  	ASSERT_TIMELY (3s, node.stats.count (nano::stat::type::requests, nano::stat::detail::requests_generated_votes) == 2);
2146  	ASSERT_FALSE (node.history.votes (nano::dev::genesis->root (), nano::dev::genesis->hash ()).empty ());
2147  	ASSERT_FALSE (node.history.votes (send1->root (), send1->hash ()).empty ());
2148  	ASSERT_TIMELY (3s, 3 == node.stats.count (nano::stat::type::message, nano::stat::detail::confirm_ack, nano::stat::dir::out));
2149  }
2150  TEST (node, local_votes_cache_fork)
2151  {
2152  	nano::test::system system;
2153  	nano::node_flags node_flags;
2154  	node_flags.disable_bootstrap_bulk_push_client = true;
2155  	node_flags.disable_bootstrap_bulk_pull_server = true;
2156  	node_flags.disable_bootstrap_listener = true;
2157  	node_flags.disable_lazy_bootstrap = true;
2158  	node_flags.disable_legacy_bootstrap = true;
2159  	node_flags.disable_wallet_bootstrap = true;
2160  	nano::node_config node_config (system.get_available_port (), system.logging);
2161  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
2162  	auto & node1 (*system.add_node (node_config, node_flags));
2163  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
2164  	auto send1 = nano::state_block_builder ()
2165  				 .account (nano::dev::genesis_key.pub)
2166  				 .previous (nano::dev::genesis->hash ())
2167  				 .representative (nano::dev::genesis_key.pub)
2168  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
2169  				 .link (nano::dev::genesis_key.pub)
2170  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2171  				 .work (*node1.work_generate_blocking (nano::dev::genesis->hash ()))
2172  				 .build_shared ();
2173  	auto send1_fork = nano::state_block_builder ()
2174  					  .account (nano::dev::genesis_key.pub)
2175  					  .previous (nano::dev::genesis->hash ())
2176  					  .representative (nano::dev::genesis_key.pub)
2177  					  .balance (nano::dev::constants.genesis_amount - 2 * nano::Gxrb_ratio)
2178  					  .link (nano::dev::genesis_key.pub)
2179  					  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2180  					  .work (*node1.work_generate_blocking (nano::dev::genesis->hash ()))
2181  					  .build_shared ();
2182  	ASSERT_EQ (nano::process_result::progress, node1.process (*send1).code);
2183  	auto vote (std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, 0, 0, std::vector<nano::block_hash> (1, send1->hash ())));
2184  	node1.vote_processor.vote (vote, std::make_shared<nano::transport::fake::channel> (node1));
2185  	node1.history.add (send1->root (), send1->hash (), vote);
2186  	auto votes2 (node1.history.votes (send1->root (), send1->hash ()));
2187  	ASSERT_EQ (1, votes2.size ());
2188  	ASSERT_EQ (1, votes2[0]->hashes.size ());
2189  	node_config.peering_port = system.get_available_port ();
2190  	auto & node2 (*system.add_node (node_config, node_flags));
2191  	node2.process_active (send1_fork);
2192  	node2.block_processor.flush ();
2193  	ASSERT_TIMELY (5s, node2.ledger.block_or_pruned_exists (send1->hash ()));
2194  }
2195  TEST (node, vote_republish)
2196  {
2197  	nano::test::system system (2);
2198  	auto & node1 = *system.nodes[0];
2199  	auto & node2 = *system.nodes[1];
2200  	nano::keypair key2;
2201  	system.wallet (1)->insert_adhoc (key2.prv);
2202  	nano::send_block_builder builder;
2203  	auto send1 = builder.make_block ()
2204  				 .previous (nano::dev::genesis->hash ())
2205  				 .destination (key2.pub)
2206  				 .balance (std::numeric_limits<nano::uint128_t>::max () - node1.config.receive_minimum.number ())
2207  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2208  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
2209  				 .build_shared ();
2210  	auto send2 = builder.make_block ()
2211  				 .previous (nano::dev::genesis->hash ())
2212  				 .destination (key2.pub)
2213  				 .balance (std::numeric_limits<nano::uint128_t>::max () - node1.config.receive_minimum.number () * 2)
2214  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2215  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
2216  				 .build_shared ();
2217  	node1.process_active (send1);
2218  	ASSERT_TIMELY (5s, node2.block (send1->hash ()));
2219  	ASSERT_TIMELY (5s, node1.active.active (*send1));
2220  	ASSERT_TIMELY (5s, node2.active.active (*send1));
2221  	node1.process_active (send2);
2222  	ASSERT_TIMELY (5s, node1.active.active (*send2));
2223  	ASSERT_FALSE (node1.block (send2->hash ()));
2224  	auto vote (std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::vote::timestamp_max, nano::vote::duration_max, std::vector<nano::block_hash>{ send2->hash () }));
2225  	node1.vote_processor.vote (vote, std::make_shared<nano::transport::fake::channel> (node1));
2226  	ASSERT_TIMELY (5s, node1.block_confirmed (send2->hash ()));
2227  	ASSERT_TIMELY (5s, node2.block_confirmed (send2->hash ()));
2228  	ASSERT_FALSE (node1.block (send1->hash ()));
2229  	ASSERT_FALSE (node2.block (send1->hash ()));
2230  	ASSERT_TIMELY (5s, node2.balance (key2.pub) == node1.config.receive_minimum.number () * 2);
2231  	ASSERT_TIMELY (5s, node1.balance (key2.pub) == node1.config.receive_minimum.number () * 2);
2232  }
2233  TEST (node, vote_by_hash_bundle)
2234  {
2235  	std::atomic<size_t> max_hashes{ 0 };
2236  	nano::test::system system (1);
2237  	auto & node = *system.nodes[0];
2238  	nano::state_block_builder builder;
2239  	std::vector<std::shared_ptr<nano::state_block>> blocks;
2240  	auto block = builder.make_block ()
2241  				 .account (nano::dev::genesis_key.pub)
2242  				 .previous (nano::dev::genesis->hash ())
2243  				 .representative (nano::dev::genesis_key.pub)
2244  				 .balance (nano::dev::constants.genesis_amount - 1)
2245  				 .link (nano::dev::genesis_key.pub)
2246  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2247  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
2248  				 .build_shared ();
2249  	blocks.push_back (block);
2250  	ASSERT_EQ (nano::process_result::progress, node.ledger.process (node.store.tx_begin_write (), *blocks.back ()).code);
2251  	for (auto i = 2; i < 200; ++i)
2252  	{
2253  		auto block = builder.make_block ()
2254  					 .from (*blocks.back ())
2255  					 .previous (blocks.back ()->hash ())
2256  					 .balance (nano::dev::constants.genesis_amount - i)
2257  					 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2258  					 .work (*system.work.generate (blocks.back ()->hash ()))
2259  					 .build_shared ();
2260  		blocks.push_back (block);
2261  		ASSERT_EQ (nano::process_result::progress, node.ledger.process (node.store.tx_begin_write (), *blocks.back ()).code);
2262  	}
2263  	ASSERT_TIMELY (5s, nano::test::confirm (node, { blocks.back () }));
2264  	ASSERT_TIMELY (5s, nano::test::confirmed (node, { blocks.back () }));
2265  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
2266  	nano::keypair key1;
2267  	system.wallet (0)->insert_adhoc (key1.prv);
2268  	system.nodes[0]->observers.vote.add ([&max_hashes] (std::shared_ptr<nano::vote> const & vote_a, std::shared_ptr<nano::transport::channel> const &, nano::vote_code) {
2269  		if (vote_a->hashes.size () > max_hashes)
2270  		{
2271  			max_hashes = vote_a->hashes.size ();
2272  		}
2273  	});
2274  	for (auto const & block : blocks)
2275  	{
2276  		system.nodes[0]->generator.add (block->root (), block->hash ());
2277  	}
2278  	ASSERT_TIMELY (20s, max_hashes.load () >= 3);
2279  }
2280  TEST (node, vote_by_hash_republish)
2281  {
2282  	nano::test::system system{ 2 };
2283  	auto & node1 = *system.nodes[0];
2284  	auto & node2 = *system.nodes[1];
2285  	nano::keypair key2;
2286  	system.wallet (1)->insert_adhoc (key2.prv);
2287  	nano::send_block_builder builder;
2288  	auto send1 = builder.make_block ()
2289  				 .previous (nano::dev::genesis->hash ())
2290  				 .destination (key2.pub)
2291  				 .balance (std::numeric_limits<nano::uint128_t>::max () - node1.config.receive_minimum.number ())
2292  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2293  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
2294  				 .build_shared ();
2295  	auto send2 = builder.make_block ()
2296  				 .previous (nano::dev::genesis->hash ())
2297  				 .destination (key2.pub)
2298  				 .balance (std::numeric_limits<nano::uint128_t>::max () - node1.config.receive_minimum.number () * 2)
2299  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2300  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
2301  				 .build_shared ();
2302  	node1.process_active (send1);
2303  	ASSERT_TIMELY (5s, node1.active.active (*send1));
2304  	ASSERT_TIMELY (5s, node2.active.active (*send1));
2305  	node1.network.publish_filter.clear ();
2306  	node1.process_active (send2);
2307  	ASSERT_TIMELY (5s, node1.active.active (*send2));
2308  	std::vector<nano::block_hash> vote_blocks;
2309  	vote_blocks.push_back (send2->hash ());
2310  	auto vote = std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::vote::timestamp_max, nano::vote::duration_max, vote_blocks);
2311  	node1.vote_processor.vote (vote, std::make_shared<nano::transport::fake::channel> (node1));
2312  	ASSERT_TIMELY (5s, node1.block_confirmed (send2->hash ()));
2313  	ASSERT_TIMELY (5s, node2.block_confirmed (send2->hash ()));
2314  	ASSERT_FALSE (node1.block (send1->hash ()));
2315  	ASSERT_FALSE (node2.block (send1->hash ()));
2316  	ASSERT_TIMELY (5s, node2.balance (key2.pub) == node1.config.receive_minimum.number () * 2);
2317  	ASSERT_TIMELY (5s, node1.balance (key2.pub) == node1.config.receive_minimum.number () * 2);
2318  }
2319  TEST (node, DISABLED_vote_by_hash_epoch_block_republish)
2320  {
2321  	nano::test::system system (2);
2322  	auto & node1 (*system.nodes[0]);
2323  	auto & node2 (*system.nodes[1]);
2324  	nano::keypair key2;
2325  	system.wallet (1)->insert_adhoc (key2.prv);
2326  	auto send1 = nano::send_block_builder ()
2327  				 .previous (nano::dev::genesis->hash ())
2328  				 .destination (key2.pub)
2329  				 .balance (std::numeric_limits<nano::uint128_t>::max () - node1.config.receive_minimum.number ())
2330  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2331  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
2332  				 .build_shared ();
2333  	auto epoch1 = nano::state_block_builder ()
2334  				  .account (nano::dev::genesis->account ())
2335  				  .previous (nano::dev::genesis->hash ())
2336  				  .representative (nano::dev::genesis->account ())
2337  				  .balance (nano::dev::constants.genesis_amount)
2338  				  .link (node1.ledger.epoch_link (nano::epoch::epoch_1))
2339  				  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2340  				  .work (*system.work.generate (nano::dev::genesis->hash ()))
2341  				  .build_shared ();
2342  	node1.process_active (send1);
2343  	ASSERT_TIMELY (5s, node2.active.active (*send1));
2344  	node1.active.publish (epoch1);
2345  	std::vector<nano::block_hash> vote_blocks;
2346  	vote_blocks.push_back (epoch1->hash ());
2347  	auto vote (std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, 0, 0, vote_blocks));
2348  	ASSERT_TRUE (node1.active.active (*send1));
2349  	ASSERT_TRUE (node2.active.active (*send1));
2350  	node1.vote_processor.vote (vote, std::make_shared<nano::transport::fake::channel> (node1));
2351  	ASSERT_TIMELY (10s, node1.block (epoch1->hash ()));
2352  	ASSERT_TIMELY (10s, node2.block (epoch1->hash ()));
2353  	ASSERT_FALSE (node1.block (send1->hash ()));
2354  	ASSERT_FALSE (node2.block (send1->hash ()));
2355  }
2356  TEST (node, epoch_conflict_confirm)
2357  {
2358  	nano::test::system system;
2359  	nano::node_config node_config (system.get_available_port (), system.logging);
2360  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
2361  	auto & node0 = *system.add_node (node_config);
2362  	node_config.peering_port = system.get_available_port ();
2363  	auto & node1 = *system.add_node (node_config);
2364  	nano::keypair key;
2365  	nano::keypair epoch_signer (nano::dev::genesis_key);
2366  	nano::state_block_builder builder;
2367  	auto send = builder.make_block ()
2368  				.account (nano::dev::genesis_key.pub)
2369  				.previous (nano::dev::genesis->hash ())
2370  				.representative (nano::dev::genesis_key.pub)
2371  				.balance (nano::dev::constants.genesis_amount - 1)
2372  				.link (key.pub)
2373  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2374  				.work (*system.work.generate (nano::dev::genesis->hash ()))
2375  				.build_shared ();
2376  	auto open = builder.make_block ()
2377  				.account (key.pub)
2378  				.previous (0)
2379  				.representative (key.pub)
2380  				.balance (1)
2381  				.link (send->hash ())
2382  				.sign (key.prv, key.pub)
2383  				.work (*system.work.generate (key.pub))
2384  				.build_shared ();
2385  	auto change = builder.make_block ()
2386  				  .account (key.pub)
2387  				  .previous (open->hash ())
2388  				  .representative (key.pub)
2389  				  .balance (1)
2390  				  .link (0)
2391  				  .sign (key.prv, key.pub)
2392  				  .work (*system.work.generate (open->hash ()))
2393  				  .build_shared ();
2394  	auto send2 = builder.make_block ()
2395  				 .account (nano::dev::genesis_key.pub)
2396  				 .previous (send->hash ())
2397  				 .representative (nano::dev::genesis_key.pub)
2398  				 .balance (nano::dev::constants.genesis_amount - 2)
2399  				 .link (open->hash ())
2400  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2401  				 .work (*system.work.generate (send->hash ()))
2402  				 .build_shared ();
2403  	auto epoch_open = builder.make_block ()
2404  					  .account (change->root ().as_account ())
2405  					  .previous (0)
2406  					  .representative (0)
2407  					  .balance (0)
2408  					  .link (node0.ledger.epoch_link (nano::epoch::epoch_1))
2409  					  .sign (epoch_signer.prv, epoch_signer.pub)
2410  					  .work (*system.work.generate (open->hash ()))
2411  					  .build_shared ();
2412  	ASSERT_TRUE (nano::test::process (node1, { send, send2, open }));
2413  	ASSERT_TIMELY (5s, nano::test::confirm (node1, { open }));
2414  	ASSERT_TIMELY (5s, nano::test::confirmed (node1, { open }));
2415  	ASSERT_TRUE (nano::test::process (node0, { send, send2, open }));
2416  	ASSERT_TRUE (nano::test::process_live (node0, { change, epoch_open }));
2417  	ASSERT_TIMELY (5s, nano::test::exists (node0, { change, epoch_open }));
2418  	ASSERT_TIMELY (5s, nano::test::exists (node1, { change, epoch_open }));
2419  	ASSERT_TIMELY (5s, nano::test::confirm (node1, { change, epoch_open, send2 }));
2420  	ASSERT_TIMELY (5s, nano::test::confirmed (node1, { change, epoch_open, send2 }));
2421  	ASSERT_TRUE (nano::test::activate (node0, { change, epoch_open }));
2422  	ASSERT_TIMELY (5s, nano::test::active (node0, { change, epoch_open }));
2423  	system.wallet (1)->insert_adhoc (nano::dev::genesis_key.prv);
2424  	ASSERT_TIMELY (5s, nano::test::active (node0, { change, epoch_open }));
2425  	ASSERT_TIMELY (5s, nano::test::confirmed (node0, { change, epoch_open }));
2426  }
2427  TEST (node, DISABLED_fork_invalid_block_signature)
2428  {
2429  	nano::test::system system;
2430  	nano::node_flags node_flags;
2431  	node_flags.disable_block_processor_republishing = true;
2432  	auto & node1 (*system.add_node (node_flags));
2433  	auto & node2 (*system.add_node (node_flags));
2434  	nano::keypair key2;
2435  	nano::send_block_builder builder;
2436  	auto send1 = builder.make_block ()
2437  				 .previous (nano::dev::genesis->hash ())
2438  				 .destination (key2.pub)
2439  				 .balance (std::numeric_limits<nano::uint128_t>::max () - node1.config.receive_minimum.number ())
2440  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2441  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
2442  				 .build_shared ();
2443  	auto send2 = builder.make_block ()
2444  				 .previous (nano::dev::genesis->hash ())
2445  				 .destination (key2.pub)
2446  				 .balance (std::numeric_limits<nano::uint128_t>::max () - node1.config.receive_minimum.number () * 2)
2447  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2448  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
2449  				 .build_shared ();
2450  	auto send2_corrupt (std::make_shared<nano::send_block> (*send2));
2451  	send2_corrupt->signature = nano::signature (123);
2452  	auto vote (std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, 0, 0, std::vector<nano::block_hash>{ send2->hash () }));
2453  	auto vote_corrupt (std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, 0, 0, std::vector<nano::block_hash>{ send2_corrupt->hash () }));
2454  	node1.process_active (send1);
2455  	ASSERT_TIMELY (5s, node1.block (send1->hash ()));
2456  	node2.network.flood_vote (vote_corrupt, 1.0f);
2457  	ASSERT_TIMELY (5s, node1.stats.count (nano::stat::type::rollback, nano::stat::detail::all));
2458  	node2.network.flood_vote (vote, 1.0f);
2459  	ASSERT_TIMELY (10s, !node1.block (send1->hash ()));
2460  	ASSERT_TIMELY (10s, node1.block (send2->hash ()));
2461  	ASSERT_EQ (node1.block (send2->hash ())->block_signature (), send2->block_signature ());
2462  }
2463  TEST (node, fork_election_invalid_block_signature)
2464  {
2465  	nano::test::system system (1);
2466  	auto & node1 (*system.nodes[0]);
2467  	nano::block_builder builder;
2468  	auto send1 = builder.state ()
2469  				 .account (nano::dev::genesis_key.pub)
2470  				 .previous (nano::dev::genesis->hash ())
2471  				 .representative (nano::dev::genesis_key.pub)
2472  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
2473  				 .link (nano::dev::genesis_key.pub)
2474  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
2475  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2476  				 .build_shared ();
2477  	auto send2 = builder.state ()
2478  				 .account (nano::dev::genesis_key.pub)
2479  				 .previous (nano::dev::genesis->hash ())
2480  				 .representative (nano::dev::genesis_key.pub)
2481  				 .balance (nano::dev::constants.genesis_amount - 2 * nano::Gxrb_ratio)
2482  				 .link (nano::dev::genesis_key.pub)
2483  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
2484  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2485  				 .build_shared ();
2486  	auto send3 = builder.state ()
2487  				 .account (nano::dev::genesis_key.pub)
2488  				 .previous (nano::dev::genesis->hash ())
2489  				 .representative (nano::dev::genesis_key.pub)
2490  				 .balance (nano::dev::constants.genesis_amount - 2 * nano::Gxrb_ratio)
2491  				 .link (nano::dev::genesis_key.pub)
2492  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
2493  				 .sign (nano::dev::genesis_key.prv, 0) 
2494  				 .build_shared ();
2495  	auto channel1 = std::make_shared<nano::transport::fake::channel> (node1);
2496  	node1.network.inbound (nano::publish{ nano::dev::network_params.network, send1 }, channel1);
2497  	ASSERT_TIMELY (5s, node1.active.active (send1->qualified_root ()));
2498  	auto election (node1.active.election (send1->qualified_root ()));
2499  	ASSERT_NE (nullptr, election);
2500  	ASSERT_EQ (1, election->blocks ().size ());
2501  	node1.network.inbound (nano::publish{ nano::dev::network_params.network, send3 }, channel1);
2502  	node1.network.inbound (nano::publish{ nano::dev::network_params.network, send2 }, channel1);
2503  	ASSERT_TIMELY (3s, election->blocks ().size () > 1);
2504  	ASSERT_EQ (election->blocks ()[send2->hash ()]->block_signature (), send2->block_signature ());
2505  }
2506  TEST (node, block_processor_signatures)
2507  {
2508  	nano::test::system system{ 1 };
2509  	auto & node1 = *system.nodes[0];
2510  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
2511  	nano::block_hash latest = system.nodes[0]->latest (nano::dev::genesis_key.pub);
2512  	nano::state_block_builder builder;
2513  	nano::keypair key1;
2514  	nano::keypair key2;
2515  	nano::keypair key3;
2516  	auto send1 = builder.make_block ()
2517  				 .account (nano::dev::genesis_key.pub)
2518  				 .previous (latest)
2519  				 .representative (nano::dev::genesis_key.pub)
2520  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
2521  				 .link (key1.pub)
2522  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2523  				 .work (*node1.work_generate_blocking (latest))
2524  				 .build_shared ();
2525  	auto send2 = builder.make_block ()
2526  				 .account (nano::dev::genesis_key.pub)
2527  				 .previous (send1->hash ())
2528  				 .representative (nano::dev::genesis_key.pub)
2529  				 .balance (nano::dev::constants.genesis_amount - 2 * nano::Gxrb_ratio)
2530  				 .link (key2.pub)
2531  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2532  				 .work (*node1.work_generate_blocking (send1->hash ()))
2533  				 .build_shared ();
2534  	auto send3 = builder.make_block ()
2535  				 .account (nano::dev::genesis_key.pub)
2536  				 .previous (send2->hash ())
2537  				 .representative (nano::dev::genesis_key.pub)
2538  				 .balance (nano::dev::constants.genesis_amount - 3 * nano::Gxrb_ratio)
2539  				 .link (key3.pub)
2540  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2541  				 .work (*node1.work_generate_blocking (send2->hash ()))
2542  				 .build_shared ();
2543  	auto send4 = builder.make_block ()
2544  				 .account (nano::dev::genesis_key.pub)
2545  				 .previous (send3->hash ())
2546  				 .representative (nano::dev::genesis_key.pub)
2547  				 .balance (nano::dev::constants.genesis_amount - 4 * nano::Gxrb_ratio)
2548  				 .link (key3.pub)
2549  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2550  				 .work (*node1.work_generate_blocking (send3->hash ()))
2551  				 .build_shared ();
2552  	send4->signature.bytes[32] ^= 0x1;
2553  	auto send5 = builder.make_block ()
2554  				 .account (nano::dev::genesis_key.pub)
2555  				 .previous (send3->hash ())
2556  				 .representative (nano::dev::genesis_key.pub)
2557  				 .balance (nano::dev::constants.genesis_amount - 5 * nano::Gxrb_ratio)
2558  				 .link (key3.pub)
2559  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2560  				 .work (*node1.work_generate_blocking (send3->hash ()))
2561  				 .build_shared ();
2562  	send5->signature.bytes[32] ^= 0x1;
2563  	node1.unchecked.put (send5->previous (), nano::unchecked_info{ send5 });
2564  	auto receive1 = builder.make_block ()
2565  					.account (key1.pub)
2566  					.previous (0)
2567  					.representative (nano::dev::genesis_key.pub)
2568  					.balance (nano::Gxrb_ratio)
2569  					.link (send1->hash ())
2570  					.sign (key1.prv, key1.pub)
2571  					.work (*node1.work_generate_blocking (key1.pub))
2572  					.build_shared ();
2573  	auto receive2 = builder.make_block ()
2574  					.account (key2.pub)
2575  					.previous (0)
2576  					.representative (nano::dev::genesis_key.pub)
2577  					.balance (nano::Gxrb_ratio)
2578  					.link (send2->hash ())
2579  					.sign (key2.prv, key2.pub)
2580  					.work (*node1.work_generate_blocking (key2.pub))
2581  					.build_shared ();
2582  	auto receive3 = builder.make_block ()
2583  					.account (key3.pub)
2584  					.previous (0)
2585  					.representative (nano::dev::genesis_key.pub)
2586  					.balance (nano::Gxrb_ratio)
2587  					.link (send3->hash ())
2588  					.sign (key2.prv, key3.pub)
2589  					.work (*node1.work_generate_blocking (key3.pub))
2590  					.build_shared ();
2591  	node1.process_active (send1);
2592  	node1.process_active (send2);
2593  	node1.process_active (send3);
2594  	node1.process_active (send4);
2595  	node1.process_active (receive1);
2596  	node1.process_active (receive2);
2597  	node1.process_active (receive3);
2598  	ASSERT_TIMELY (5s, node1.block (receive2->hash ()) != nullptr); 
2599  	ASSERT_TIMELY (5s, node1.unchecked.count () == 0);
2600  	ASSERT_EQ (nullptr, node1.block (receive3->hash ())); 
2601  	ASSERT_EQ (nullptr, node1.block (send4->hash ())); 
2602  	ASSERT_EQ (nullptr, node1.block (send5->hash ())); 
2603  }
2604  TEST (node, block_processor_reject_state)
2605  {
2606  	nano::test::system system (1);
2607  	auto & node (*system.nodes[0]);
2608  	nano::state_block_builder builder;
2609  	auto send1 = builder.make_block ()
2610  				 .account (nano::dev::genesis_key.pub)
2611  				 .previous (nano::dev::genesis->hash ())
2612  				 .representative (nano::dev::genesis_key.pub)
2613  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
2614  				 .link (nano::dev::genesis_key.pub)
2615  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2616  				 .work (*node.work_generate_blocking (nano::dev::genesis->hash ()))
2617  				 .build_shared ();
2618  	send1->signature.bytes[0] ^= 1;
2619  	ASSERT_FALSE (node.ledger.block_or_pruned_exists (send1->hash ()));
2620  	node.process_active (send1);
2621  	auto flushed = std::async (std::launch::async, [&node] { node.block_processor.flush (); });
2622  	ASSERT_NE (std::future_status::timeout, flushed.wait_for (5s));
2623  	ASSERT_FALSE (node.ledger.block_or_pruned_exists (send1->hash ()));
2624  	auto send2 = builder.make_block ()
2625  				 .account (nano::dev::genesis_key.pub)
2626  				 .previous (nano::dev::genesis->hash ())
2627  				 .representative (nano::dev::genesis_key.pub)
2628  				 .balance (nano::dev::constants.genesis_amount - 2 * nano::Gxrb_ratio)
2629  				 .link (nano::dev::genesis_key.pub)
2630  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2631  				 .work (*node.work_generate_blocking (nano::dev::genesis->hash ()))
2632  				 .build_shared ();
2633  	node.process_active (send2);
2634  	auto flushed2 = std::async (std::launch::async, [&node] { node.block_processor.flush (); });
2635  	ASSERT_NE (std::future_status::timeout, flushed2.wait_for (5s));
2636  	ASSERT_TRUE (node.ledger.block_or_pruned_exists (send2->hash ()));
2637  }
2638  TEST (node, block_processor_full)
2639  {
2640  	nano::test::system system;
2641  	nano::node_flags node_flags;
2642  	node_flags.force_use_write_database_queue = true;
2643  	node_flags.block_processor_full_size = 3;
2644  	auto & node = *system.add_node (nano::node_config (system.get_available_port (), system.logging), node_flags);
2645  	nano::state_block_builder builder;
2646  	auto send1 = builder.make_block ()
2647  				 .account (nano::dev::genesis_key.pub)
2648  				 .previous (nano::dev::genesis->hash ())
2649  				 .representative (nano::dev::genesis_key.pub)
2650  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
2651  				 .link (nano::dev::genesis_key.pub)
2652  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2653  				 .work (*node.work_generate_blocking (nano::dev::genesis->hash ()))
2654  				 .build_shared ();
2655  	auto send2 = builder.make_block ()
2656  				 .account (nano::dev::genesis_key.pub)
2657  				 .previous (nano::dev::genesis->hash ())
2658  				 .representative (nano::dev::genesis_key.pub)
2659  				 .balance (nano::dev::constants.genesis_amount - 2 * nano::Gxrb_ratio)
2660  				 .link (nano::dev::genesis_key.pub)
2661  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2662  				 .work (*node.work_generate_blocking (nano::dev::genesis->hash ()))
2663  				 .build_shared ();
2664  	auto send3 = builder.make_block ()
2665  				 .account (nano::dev::genesis_key.pub)
2666  				 .previous (nano::dev::genesis->hash ())
2667  				 .representative (nano::dev::genesis_key.pub)
2668  				 .balance (nano::dev::constants.genesis_amount - 3 * nano::Gxrb_ratio)
2669  				 .link (nano::dev::genesis_key.pub)
2670  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2671  				 .work (*node.work_generate_blocking (nano::dev::genesis->hash ()))
2672  				 .build_shared ();
2673  	node.block_processor.stop (); 
2674  	node.block_processor.add (send1);
2675  	ASSERT_FALSE (node.block_processor.full ());
2676  	node.block_processor.add (send2);
2677  	ASSERT_FALSE (node.block_processor.full ());
2678  	node.block_processor.add (send3);
2679  	ASSERT_TIMELY (5s, node.block_processor.full ());
2680  }
2681  TEST (node, block_processor_half_full)
2682  {
2683  	nano::test::system system;
2684  	nano::node_flags node_flags;
2685  	node_flags.block_processor_full_size = 6;
2686  	node_flags.force_use_write_database_queue = true;
2687  	auto & node = *system.add_node (nano::node_config (system.get_available_port (), system.logging), node_flags);
2688  	nano::state_block_builder builder;
2689  	auto send1 = builder.make_block ()
2690  				 .account (nano::dev::genesis_key.pub)
2691  				 .previous (nano::dev::genesis->hash ())
2692  				 .representative (nano::dev::genesis_key.pub)
2693  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
2694  				 .link (nano::dev::genesis_key.pub)
2695  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2696  				 .work (*node.work_generate_blocking (nano::dev::genesis->hash ()))
2697  				 .build_shared ();
2698  	auto send2 = builder.make_block ()
2699  				 .account (nano::dev::genesis_key.pub)
2700  				 .previous (send1->hash ())
2701  				 .representative (nano::dev::genesis_key.pub)
2702  				 .balance (nano::dev::constants.genesis_amount - 2 * nano::Gxrb_ratio)
2703  				 .link (nano::dev::genesis_key.pub)
2704  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2705  				 .work (*node.work_generate_blocking (send1->hash ()))
2706  				 .build_shared ();
2707  	auto send3 = builder.make_block ()
2708  				 .account (nano::dev::genesis_key.pub)
2709  				 .previous (send2->hash ())
2710  				 .representative (nano::dev::genesis_key.pub)
2711  				 .balance (nano::dev::constants.genesis_amount - 3 * nano::Gxrb_ratio)
2712  				 .link (nano::dev::genesis_key.pub)
2713  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2714  				 .work (*node.work_generate_blocking (send2->hash ()))
2715  				 .build_shared ();
2716  	auto write_guard = node.write_database_queue.wait (nano::writer::testing);
2717  	node.block_processor.add (send1);
2718  	ASSERT_FALSE (node.block_processor.half_full ());
2719  	node.block_processor.add (send2);
2720  	ASSERT_FALSE (node.block_processor.half_full ());
2721  	node.block_processor.add (send3);
2722  	ASSERT_TIMELY (2s, node.block_processor.half_full ());
2723  	ASSERT_FALSE (node.block_processor.full ());
2724  }
2725  TEST (node, confirm_back)
2726  {
2727  	nano::test::system system (1);
2728  	nano::keypair key;
2729  	auto & node (*system.nodes[0]);
2730  	auto genesis_start_balance (node.balance (nano::dev::genesis_key.pub));
2731  	auto send1 = nano::send_block_builder ()
2732  				 .previous (nano::dev::genesis->hash ())
2733  				 .destination (key.pub)
2734  				 .balance (genesis_start_balance - 1)
2735  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2736  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
2737  				 .build_shared ();
2738  	nano::state_block_builder builder;
2739  	auto open = builder.make_block ()
2740  				.account (key.pub)
2741  				.previous (0)
2742  				.representative (key.pub)
2743  				.balance (1)
2744  				.link (send1->hash ())
2745  				.sign (key.prv, key.pub)
2746  				.work (*system.work.generate (key.pub))
2747  				.build_shared ();
2748  	auto send2 = builder.make_block ()
2749  				 .account (key.pub)
2750  				 .previous (open->hash ())
2751  				 .representative (key.pub)
2752  				 .balance (0)
2753  				 .link (nano::dev::genesis_key.pub)
2754  				 .sign (key.prv, key.pub)
2755  				 .work (*system.work.generate (open->hash ()))
2756  				 .build_shared ();
2757  	node.process_active (send1);
2758  	node.process_active (open);
2759  	node.process_active (send2);
2760  	ASSERT_TIMELY (5s, node.block (send2->hash ()) != nullptr);
2761  	nano::test::start_elections (system, node, { send1, open, send2 });
2762  	ASSERT_EQ (3, node.active.size ());
2763  	std::vector<nano::block_hash> vote_blocks;
2764  	vote_blocks.push_back (send2->hash ());
2765  	auto vote (std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, nano::vote::timestamp_max, nano::vote::duration_max, vote_blocks));
2766  	node.vote_processor.vote_blocking (vote, std::make_shared<nano::transport::fake::channel> (node));
2767  	ASSERT_TIMELY (10s, node.active.empty ());
2768  }
2769  TEST (node, peers)
2770  {
2771  	nano::test::system system (1);
2772  	auto node1 (system.nodes[0]);
2773  	ASSERT_TRUE (node1->network.empty ());
2774  	auto node2 (std::make_shared<nano::node> (system.io_ctx, system.get_available_port (), nano::unique_path (), system.logging, system.work));
2775  	system.nodes.push_back (node2);
2776  	auto endpoint = node1->network.endpoint ();
2777  	nano::endpoint_key endpoint_key{ endpoint.address ().to_v6 ().to_bytes (), endpoint.port () };
2778  	auto & store = node2->store;
2779  	{
2780  		auto transaction (store.tx_begin_write ());
2781  		store.peer.put (transaction, endpoint_key);
2782  		store.peer.put (transaction, nano::endpoint_key{ boost::asio::ip::address_v6::any ().to_bytes (), 55555 });
2783  	}
2784  	node2->start ();
2785  	ASSERT_TIMELY (10s, !node2->network.empty () && !node1->network.empty ())
2786  	ASSERT_TIMELY (10s, node1->tcp_listener.realtime_count != 0 && node2->tcp_listener.realtime_count != 0);
2787  	ASSERT_EQ (1, node1->network.size ());
2788  	auto list1 (node1->network.list (2));
2789  	ASSERT_EQ (node2->get_node_id (), list1[0]->get_node_id ());
2790  	ASSERT_EQ (nano::transport::transport_type::tcp, list1[0]->get_type ());
2791  	ASSERT_EQ (1, node2->network.size ());
2792  	auto list2 (node2->network.list (2));
2793  	ASSERT_EQ (node1->get_node_id (), list2[0]->get_node_id ());
2794  	ASSERT_EQ (nano::transport::transport_type::tcp, list2[0]->get_type ());
2795  	ASSERT_TIMELY_EQ (5s, store.peer.count (store.tx_begin_read ()), 1);
2796  	ASSERT_TRUE (store.peer.exists (store.tx_begin_read (), endpoint_key));
2797  	node1->stop ();
2798  	ASSERT_TIMELY (10s, node2->network.empty ());
2799  }
2800  TEST (node, peer_cache_restart)
2801  {
2802  	nano::test::system system (1);
2803  	auto node1 (system.nodes[0]);
2804  	ASSERT_TRUE (node1->network.empty ());
2805  	auto endpoint = node1->network.endpoint ();
2806  	nano::endpoint_key endpoint_key{ endpoint.address ().to_v6 ().to_bytes (), endpoint.port () };
2807  	auto path (nano::unique_path ());
2808  	{
2809  		auto node2 (std::make_shared<nano::node> (system.io_ctx, system.get_available_port (), path, system.logging, system.work));
2810  		system.nodes.push_back (node2);
2811  		auto & store = node2->store;
2812  		{
2813  			auto transaction (store.tx_begin_write ());
2814  			store.peer.put (transaction, endpoint_key);
2815  		}
2816  		node2->start ();
2817  		ASSERT_TIMELY (10s, !node2->network.empty ());
2818  		auto list (node2->network.list (2));
2819  		ASSERT_EQ (node1->network.endpoint (), list[0]->get_endpoint ());
2820  		ASSERT_EQ (1, node2->network.size ());
2821  		node2->stop ();
2822  	}
2823  	{
2824  		nano::node_flags node_flags;
2825  		node_flags.read_only = true;
2826  		auto node3 (std::make_shared<nano::node> (system.io_ctx, system.get_available_port (), path, system.logging, system.work, node_flags));
2827  		system.nodes.push_back (node3);
2828  		node3->network.start ();
2829  		node3->add_initial_peers ();
2830  		auto & store = node3->store;
2831  		{
2832  			auto transaction (store.tx_begin_read ());
2833  			ASSERT_EQ (store.peer.count (transaction), 1);
2834  			ASSERT_TRUE (store.peer.exists (transaction, endpoint_key));
2835  		}
2836  		ASSERT_TIMELY (10s, !node3->network.empty ());
2837  		auto list (node3->network.list (2));
2838  		ASSERT_EQ (node1->network.endpoint (), list[0]->get_endpoint ());
2839  		ASSERT_EQ (1, node3->network.size ());
2840  		node3->stop ();
2841  	}
2842  }
2843  TEST (node, unchecked_cleanup)
2844  {
2845  	nano::test::system system{};
2846  	nano::node_flags node_flags{};
2847  	node_flags.disable_unchecked_cleanup = true;
2848  	nano::keypair key{};
2849  	auto & node = *system.add_node (node_flags);
2850  	auto open = nano::state_block_builder ()
2851  				.account (key.pub)
2852  				.previous (0)
2853  				.representative (key.pub)
2854  				.balance (1)
2855  				.link (key.pub)
2856  				.sign (key.prv, key.pub)
2857  				.work (*system.work.generate (key.pub))
2858  				.build_shared ();
2859  	std::vector<uint8_t> bytes;
2860  	{
2861  		nano::vectorstream stream (bytes);
2862  		open->serialize (stream);
2863  	}
2864  	ASSERT_FALSE (node.network.publish_filter.apply (bytes.data (), bytes.size ()));
2865  	node.process_active (open);
2866  	ASSERT_TIMELY (15s, 1 == node.unchecked.count ());
2867  	node.config.unchecked_cutoff_time = std::chrono::seconds (2);
2868  	ASSERT_EQ (1, node.unchecked.count ());
2869  	std::this_thread::sleep_for (std::chrono::seconds (1));
2870  	node.unchecked_cleanup ();
2871  	ASSERT_TRUE (node.network.publish_filter.apply (bytes.data (), bytes.size ()));
2872  	ASSERT_EQ (1, node.unchecked.count ());
2873  	std::this_thread::sleep_for (std::chrono::seconds (2));
2874  	node.unchecked_cleanup ();
2875  	ASSERT_FALSE (node.network.publish_filter.apply (bytes.data (), bytes.size ()));
2876  	ASSERT_EQ (0, node.unchecked.count ());
2877  }
2878  TEST (node, dont_write_lock_node)
2879  {
2880  	auto path = nano::unique_path ();
2881  	std::promise<void> write_lock_held_promise;
2882  	std::promise<void> finished_promise;
2883  	std::thread ([&path, &write_lock_held_promise, &finished_promise] () {
2884  		nano::logger_mt logger;
2885  		auto store = nano::make_store (logger, path, nano::dev::constants, false, true);
2886  		{
2887  			nano::ledger_cache ledger_cache;
2888  			auto transaction (store->tx_begin_write ());
2889  			store->initialize (transaction, ledger_cache, nano::dev::constants);
2890  		}
2891  		auto transaction (store->tx_begin_write ());
2892  		write_lock_held_promise.set_value ();
2893  		finished_promise.get_future ().wait ();
2894  	})
2895  	.detach ();
2896  	write_lock_held_promise.get_future ().wait ();
2897  	nano::inactive_node node (path, nano::inactive_node_flag_defaults ());
2898  	finished_promise.set_value ();
2899  }
2900  TEST (node, bidirectional_tcp)
2901  {
2902  #ifdef _WIN32
2903  	if (nano::rocksdb_config::using_rocksdb_in_tests ())
2904  	{
2905  		GTEST_SKIP ();
2906  	}
2907  #endif
2908  	nano::test::system system;
2909  	nano::node_flags node_flags;
2910  	node_flags.disable_legacy_bootstrap = true;
2911  	node_flags.disable_lazy_bootstrap = true;
2912  	node_flags.disable_wallet_bootstrap = true;
2913  	nano::node_config node_config (system.get_available_port (), system.logging);
2914  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
2915  	auto node1 = system.add_node (node_config, node_flags);
2916  	node_config.peering_port = system.get_available_port ();
2917  	node_config.tcp_incoming_connections_max = 0; 
2918  	auto node2 = system.add_node (node_config, node_flags);
2919  	ASSERT_EQ (1, node1->network.size ());
2920  	ASSERT_EQ (1, node2->network.size ());
2921  	auto list1 (node1->network.list (1));
2922  	ASSERT_EQ (nano::transport::transport_type::tcp, list1[0]->get_type ());
2923  	ASSERT_NE (node2->network.endpoint (), list1[0]->get_endpoint ()); 
2924  	ASSERT_EQ (node2->node_id.pub, list1[0]->get_node_id ());
2925  	auto list2 (node2->network.list (1));
2926  	ASSERT_EQ (nano::transport::transport_type::tcp, list2[0]->get_type ());
2927  	ASSERT_EQ (node1->network.endpoint (), list2[0]->get_endpoint ());
2928  	ASSERT_EQ (node1->node_id.pub, list2[0]->get_node_id ());
2929  	nano::keypair key;
2930  	nano::state_block_builder builder;
2931  	auto send1 = builder.make_block ()
2932  				 .account (nano::dev::genesis_key.pub)
2933  				 .previous (nano::dev::genesis->hash ())
2934  				 .representative (nano::dev::genesis_key.pub)
2935  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
2936  				 .link (key.pub)
2937  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2938  				 .work (*node1->work_generate_blocking (nano::dev::genesis->hash ()))
2939  				 .build_shared ();
2940  	node1->process_active (send1);
2941  	ASSERT_TIMELY (10s, node1->ledger.block_or_pruned_exists (send1->hash ()) && node2->ledger.block_or_pruned_exists (send1->hash ()));
2942  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
2943  	ASSERT_TIMELY (10s, node2->rep_crawler.representative_count () != 0);
2944  	bool confirmed (false);
2945  	system.deadline_set (10s);
2946  	while (!confirmed)
2947  	{
2948  		auto transaction2 (node2->store.tx_begin_read ());
2949  		confirmed = node2->ledger.block_confirmed (transaction2, send1->hash ());
2950  		ASSERT_NO_ERROR (system.poll ());
2951  	}
2952  	{
2953  		auto transaction (system.wallet (0)->wallets.tx_begin_write ());
2954  		system.wallet (0)->store.erase (transaction, nano::dev::genesis_key.pub);
2955  	}
2956  	auto send2 = builder.make_block ()
2957  				 .account (nano::dev::genesis_key.pub)
2958  				 .previous (send1->hash ())
2959  				 .representative (nano::dev::genesis_key.pub)
2960  				 .balance (nano::dev::constants.genesis_amount - 2 * nano::Gxrb_ratio)
2961  				 .link (key.pub)
2962  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
2963  				 .work (*node1->work_generate_blocking (send1->hash ()))
2964  				 .build_shared ();
2965  	node2->process_active (send2);
2966  	node2->block_processor.flush ();
2967  	ASSERT_TIMELY (10s, node1->ledger.block_or_pruned_exists (send2->hash ()) && node2->ledger.block_or_pruned_exists (send2->hash ()));
2968  	system.wallet (1)->insert_adhoc (nano::dev::genesis_key.prv);
2969  	ASSERT_TIMELY (10s, node1->rep_crawler.representative_count () != 0);
2970  	confirmed = false;
2971  	system.deadline_set (20s);
2972  	while (!confirmed)
2973  	{
2974  		auto transaction1 (node1->store.tx_begin_read ());
2975  		confirmed = node1->ledger.block_confirmed (transaction1, send2->hash ());
2976  		ASSERT_NO_ERROR (system.poll ());
2977  	}
2978  }
2979  TEST (node, node_sequence)
2980  {
2981  	nano::test::system system (3);
2982  	ASSERT_EQ (0, system.nodes[0]->node_seq);
2983  	ASSERT_EQ (0, system.nodes[0]->node_seq);
2984  	ASSERT_EQ (1, system.nodes[1]->node_seq);
2985  	ASSERT_EQ (2, system.nodes[2]->node_seq);
2986  }
2987  TEST (node, rollback_vote_self)
2988  {
2989  	nano::test::system system;
2990  	nano::node_flags flags;
2991  	flags.disable_request_loop = true;
2992  	auto & node = *system.add_node (flags);
2993  	nano::state_block_builder builder;
2994  	nano::keypair key;
2995  	auto send1 = builder.make_block ()
2996  				 .account (nano::dev::genesis_key.pub)
2997  				 .previous (nano::dev::genesis->hash ())
2998  				 .representative (nano::dev::genesis_key.pub)
2999  				 .link (key.pub)
3000  				 .balance (nano::dev::constants.genesis_amount - (nano::dev::constants.genesis_amount / 2))
3001  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3002  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
3003  				 .build_shared ();
3004  	auto open = builder.make_block ()
3005  				.account (key.pub)
3006  				.previous (0)
3007  				.representative (key.pub)
3008  				.link (send1->hash ())
3009  				.balance (nano::dev::constants.genesis_amount / 2)
3010  				.sign (key.prv, key.pub)
3011  				.work (*system.work.generate (key.pub))
3012  				.build_shared ();
3013  	auto send2 = builder.make_block ()
3014  				 .from (*send1)
3015  				 .previous (send1->hash ())
3016  				 .balance (send1->balance ().number () - 1)
3017  				 .link (nano::dev::genesis_key.pub)
3018  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3019  				 .work (*system.work.generate (send1->hash ()))
3020  				 .build_shared ();
3021  	auto fork = builder.make_block ()
3022  				.from (*send2)
3023  				.balance (send1->balance ().number () - 2)
3024  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3025  				.build_shared ();
3026  	ASSERT_TRUE (nano::test::process (node, { send1, open }));
3027  	ASSERT_TIMELY (5s, nano::test::confirm (node, { send1, open }));
3028  	ASSERT_TIMELY (5s, node.ledger.cache.cemented_count == 3);
3029  	ASSERT_TIMELY_EQ (5s, nano::dev::constants.genesis_amount / 2, node.weight (key.pub));
3030  	node.process_active (send2);
3031  	std::shared_ptr<nano::election> election;
3032  	ASSERT_TIMELY (5s, election = node.active.election (send2->qualified_root ()));
3033  	node.process_active (fork);
3034  	ASSERT_TIMELY_EQ (5s, 2, election->blocks ().size ());
3035  	ASSERT_EQ (election->winner ()->hash (), send2->hash ());
3036  	{
3037  		auto write_guard = node.write_database_queue.wait (nano::writer::testing);
3038  		ASSERT_EQ (0, election->votes_with_weight ().size ());
3039  		election->vote (key.pub, 0, fork->hash ());
3040  		ASSERT_EQ (1, election->votes_with_weight ().size ());
3041  		ASSERT_EQ (election->winner ()->hash (), fork->hash ());
3042  		system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
3043  		ASSERT_TRUE (node.history.votes (send2->root (), send2->hash ()).empty ());
3044  		ASSERT_TRUE (node.history.votes (fork->root (), fork->hash ()).empty ());
3045  		auto channel = std::make_shared<nano::transport::fake::channel> (node);
3046  		node.aggregator.add (channel, { { send2->hash (), send2->root () } });
3047  		ASSERT_TIMELY (5s, !node.history.votes (fork->root (), fork->hash ()).empty ());
3048  		ASSERT_TRUE (node.history.votes (send2->root (), send2->hash ()).empty ());
3049  	}
3050  	auto is_genesis_vote = [] (nano::vote_with_weight_info info) {
3051  		return info.representative == nano::dev::genesis_key.pub;
3052  	};
3053  	ASSERT_TIMELY_EQ (5s, 2, election->votes_with_weight ().size ());
3054  	auto votes_with_weight = election->votes_with_weight ();
3055  	ASSERT_EQ (1, std::count_if (votes_with_weight.begin (), votes_with_weight.end (), is_genesis_vote));
3056  	auto vote = std::find_if (votes_with_weight.begin (), votes_with_weight.end (), is_genesis_vote);
3057  	ASSERT_NE (votes_with_weight.end (), vote);
3058  	ASSERT_EQ (fork->hash (), vote->hash);
3059  }
3060  TEST (node, rollback_gap_source)
3061  {
3062  	nano::test::system system;
3063  	nano::node_config node_config (system.get_available_port (), system.logging);
3064  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
3065  	auto & node = *system.add_node (node_config);
3066  	nano::state_block_builder builder;
3067  	nano::keypair key;
3068  	auto send1 = builder.make_block ()
3069  				 .account (nano::dev::genesis_key.pub)
3070  				 .previous (nano::dev::genesis->hash ())
3071  				 .representative (nano::dev::genesis_key.pub)
3072  				 .link (key.pub)
3073  				 .balance (nano::dev::constants.genesis_amount - 1)
3074  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3075  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
3076  				 .build_shared ();
3077  	auto fork1a = builder.make_block ()
3078  				  .account (key.pub)
3079  				  .previous (0)
3080  				  .representative (key.pub)
3081  				  .link (send1->hash ())
3082  				  .balance (1)
3083  				  .sign (key.prv, key.pub)
3084  				  .work (*system.work.generate (key.pub))
3085  				  .build_shared ();
3086  	auto send2 = builder.make_block ()
3087  				 .from (*send1)
3088  				 .previous (send1->hash ())
3089  				 .balance (send1->balance ().number () - 1)
3090  				 .link (key.pub)
3091  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3092  				 .work (*system.work.generate (send1->hash ()))
3093  				 .build_shared ();
3094  	auto fork1b = builder.make_block ()
3095  				  .from (*fork1a)
3096  				  .link (send2->hash ())
3097  				  .sign (key.prv, key.pub)
3098  				  .build_shared ();
3099  	ASSERT_EQ (nano::process_result::progress, node.process (*send1).code);
3100  	ASSERT_EQ (nano::process_result::progress, node.process (*fork1a).code);
3101  	ASSERT_EQ (nullptr, node.block (send2->hash ()));
3102  	node.block_processor.force (fork1b);
3103  	ASSERT_TIMELY (5s, node.block (fork1a->hash ()) == nullptr);
3104  	ASSERT_TIMELY (5s, node.stats.count (nano::stat::type::rollback, nano::stat::detail::open) == 1);
3105  	ASSERT_EQ (nullptr, node.block (fork1b->hash ()));
3106  	node.process_active (fork1a);
3107  	ASSERT_TIMELY (5s, node.block (fork1a->hash ()) != nullptr);
3108  	ASSERT_EQ (nano::process_result::progress, node.process (*send2).code);
3109  	node.block_processor.force (fork1b);
3110  	ASSERT_TIMELY (5s, node.stats.count (nano::stat::type::rollback, nano::stat::detail::open) == 2);
3111  	ASSERT_TIMELY (5s, node.block (fork1b->hash ()) != nullptr);
3112  	ASSERT_EQ (nullptr, node.block (fork1a->hash ()));
3113  }
3114  TEST (node, dependency_graph)
3115  {
3116  	nano::test::system system;
3117  	nano::node_config config (system.get_available_port (), system.logging);
3118  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
3119  	auto & node = *system.add_node (config);
3120  	nano::state_block_builder builder;
3121  	nano::keypair key1, key2, key3;
3122  	auto gen_send1 = builder.make_block ()
3123  					 .account (nano::dev::genesis_key.pub)
3124  					 .previous (nano::dev::genesis->hash ())
3125  					 .representative (nano::dev::genesis_key.pub)
3126  					 .link (key1.pub)
3127  					 .balance (nano::dev::constants.genesis_amount - 1)
3128  					 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3129  					 .work (*system.work.generate (nano::dev::genesis->hash ()))
3130  					 .build_shared ();
3131  	auto key1_open = builder.make_block ()
3132  					 .account (key1.pub)
3133  					 .previous (0)
3134  					 .representative (key1.pub)
3135  					 .link (gen_send1->hash ())
3136  					 .balance (1)
3137  					 .sign (key1.prv, key1.pub)
3138  					 .work (*system.work.generate (key1.pub))
3139  					 .build ();
3140  	auto key1_send1 = builder.make_block ()
3141  					  .account (key1.pub)
3142  					  .previous (key1_open->hash ())
3143  					  .representative (key1.pub)
3144  					  .link (nano::dev::genesis_key.pub)
3145  					  .balance (0)
3146  					  .sign (key1.prv, key1.pub)
3147  					  .work (*system.work.generate (key1_open->hash ()))
3148  					  .build ();
3149  	auto gen_receive = builder.make_block ()
3150  					   .from (*gen_send1)
3151  					   .previous (gen_send1->hash ())
3152  					   .link (key1_send1->hash ())
3153  					   .balance (nano::dev::constants.genesis_amount)
3154  					   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3155  					   .work (*system.work.generate (gen_send1->hash ()))
3156  					   .build ();
3157  	auto gen_send2 = builder.make_block ()
3158  					 .from (*gen_receive)
3159  					 .previous (gen_receive->hash ())
3160  					 .link (key2.pub)
3161  					 .balance (gen_receive->balance ().number () - 2)
3162  					 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3163  					 .work (*system.work.generate (gen_receive->hash ()))
3164  					 .build ();
3165  	auto key2_open = builder.make_block ()
3166  					 .account (key2.pub)
3167  					 .previous (0)
3168  					 .representative (key2.pub)
3169  					 .link (gen_send2->hash ())
3170  					 .balance (2)
3171  					 .sign (key2.prv, key2.pub)
3172  					 .work (*system.work.generate (key2.pub))
3173  					 .build ();
3174  	auto key2_send1 = builder.make_block ()
3175  					  .account (key2.pub)
3176  					  .previous (key2_open->hash ())
3177  					  .representative (key2.pub)
3178  					  .link (key3.pub)
3179  					  .balance (1)
3180  					  .sign (key2.prv, key2.pub)
3181  					  .work (*system.work.generate (key2_open->hash ()))
3182  					  .build ();
3183  	auto key3_open = builder.make_block ()
3184  					 .account (key3.pub)
3185  					 .previous (0)
3186  					 .representative (key3.pub)
3187  					 .link (key2_send1->hash ())
3188  					 .balance (1)
3189  					 .sign (key3.prv, key3.pub)
3190  					 .work (*system.work.generate (key3.pub))
3191  					 .build ();
3192  	auto key2_send2 = builder.make_block ()
3193  					  .from (*key2_send1)
3194  					  .previous (key2_send1->hash ())
3195  					  .link (key1.pub)
3196  					  .balance (key2_send1->balance ().number () - 1)
3197  					  .sign (key2.prv, key2.pub)
3198  					  .work (*system.work.generate (key2_send1->hash ()))
3199  					  .build ();
3200  	auto key1_receive = builder.make_block ()
3201  						.from (*key1_send1)
3202  						.previous (key1_send1->hash ())
3203  						.link (key2_send2->hash ())
3204  						.balance (key1_send1->balance ().number () + 1)
3205  						.sign (key1.prv, key1.pub)
3206  						.work (*system.work.generate (key1_send1->hash ()))
3207  						.build ();
3208  	auto key1_send2 = builder.make_block ()
3209  					  .from (*key1_receive)
3210  					  .previous (key1_receive->hash ())
3211  					  .link (key3.pub)
3212  					  .balance (key1_receive->balance ().number () - 1)
3213  					  .sign (key1.prv, key1.pub)
3214  					  .work (*system.work.generate (key1_receive->hash ()))
3215  					  .build ();
3216  	auto key3_receive = builder.make_block ()
3217  						.from (*key3_open)
3218  						.previous (key3_open->hash ())
3219  						.link (key1_send2->hash ())
3220  						.balance (key3_open->balance ().number () + 1)
3221  						.sign (key3.prv, key3.pub)
3222  						.work (*system.work.generate (key3_open->hash ()))
3223  						.build ();
3224  	auto key3_epoch = builder.make_block ()
3225  					  .from (*key3_receive)
3226  					  .previous (key3_receive->hash ())
3227  					  .link (node.ledger.epoch_link (nano::epoch::epoch_1))
3228  					  .balance (key3_receive->balance ())
3229  					  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3230  					  .work (*system.work.generate (key3_receive->hash ()))
3231  					  .build ();
3232  	ASSERT_EQ (nano::process_result::progress, node.process (*gen_send1).code);
3233  	ASSERT_EQ (nano::process_result::progress, node.process (*key1_open).code);
3234  	ASSERT_EQ (nano::process_result::progress, node.process (*key1_send1).code);
3235  	ASSERT_EQ (nano::process_result::progress, node.process (*gen_receive).code);
3236  	ASSERT_EQ (nano::process_result::progress, node.process (*gen_send2).code);
3237  	ASSERT_EQ (nano::process_result::progress, node.process (*key2_open).code);
3238  	ASSERT_EQ (nano::process_result::progress, node.process (*key2_send1).code);
3239  	ASSERT_EQ (nano::process_result::progress, node.process (*key3_open).code);
3240  	ASSERT_EQ (nano::process_result::progress, node.process (*key2_send2).code);
3241  	ASSERT_EQ (nano::process_result::progress, node.process (*key1_receive).code);
3242  	ASSERT_EQ (nano::process_result::progress, node.process (*key1_send2).code);
3243  	ASSERT_EQ (nano::process_result::progress, node.process (*key3_receive).code);
3244  	ASSERT_EQ (nano::process_result::progress, node.process (*key3_epoch).code);
3245  	ASSERT_TRUE (node.active.empty ());
3246  	std::unordered_map<nano::block_hash, std::vector<nano::block_hash>> dependency_graph{
3247  		{ key1_open->hash (), { gen_send1->hash () } },
3248  		{ key1_send1->hash (), { key1_open->hash () } },
3249  		{ gen_receive->hash (), { gen_send1->hash (), key1_open->hash () } },
3250  		{ gen_send2->hash (), { gen_receive->hash () } },
3251  		{ key2_open->hash (), { gen_send2->hash () } },
3252  		{ key2_send1->hash (), { key2_open->hash () } },
3253  		{ key3_open->hash (), { key2_send1->hash () } },
3254  		{ key2_send2->hash (), { key2_send1->hash () } },
3255  		{ key1_receive->hash (), { key1_send1->hash (), key2_send2->hash () } },
3256  		{ key1_send2->hash (), { key1_send1->hash () } },
3257  		{ key3_receive->hash (), { key3_open->hash (), key1_send2->hash () } },
3258  		{ key3_epoch->hash (), { key3_receive->hash () } },
3259  	};
3260  	ASSERT_EQ (node.ledger.cache.block_count - 2, dependency_graph.size ());
3261  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
3262  	node.block_confirm (gen_send1);
3263  	ASSERT_NO_ERROR (system.poll_until_true (15s, [&] {
3264  		EXPECT_LT (node.active.size (), 6);
3265  		auto error = std::any_of (dependency_graph.cbegin (), dependency_graph.cend (), [&] (auto entry) {
3266  			if (node.active.active (entry.first))
3267  			{
3268  				for (auto ancestor : entry.second)
3269  				{
3270  					if (!node.block_confirmed (ancestor))
3271  					{
3272  						return true;
3273  					}
3274  				}
3275  			}
3276  			return false;
3277  		});
3278  		EXPECT_FALSE (error);
3279  		return error || node.ledger.cache.cemented_count == node.ledger.cache.block_count;
3280  	}));
3281  	ASSERT_EQ (node.ledger.cache.cemented_count, node.ledger.cache.block_count);
3282  	ASSERT_TIMELY (5s, node.active.empty ());
3283  }
3284  TEST (node, dependency_graph_frontier)
3285  {
3286  	nano::test::system system;
3287  	nano::node_config config (system.get_available_port (), system.logging);
3288  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
3289  	auto & node1 = *system.add_node (config);
3290  	config.peering_port = system.get_available_port ();
3291  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::always;
3292  	auto & node2 = *system.add_node (config);
3293  	nano::state_block_builder builder;
3294  	nano::keypair key1, key2, key3;
3295  	auto gen_send1 = builder.make_block ()
3296  					 .account (nano::dev::genesis_key.pub)
3297  					 .previous (nano::dev::genesis->hash ())
3298  					 .representative (nano::dev::genesis_key.pub)
3299  					 .link (key1.pub)
3300  					 .balance (nano::dev::constants.genesis_amount - 1)
3301  					 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3302  					 .work (*system.work.generate (nano::dev::genesis->hash ()))
3303  					 .build_shared ();
3304  	auto key1_open = builder.make_block ()
3305  					 .account (key1.pub)
3306  					 .previous (0)
3307  					 .representative (key1.pub)
3308  					 .link (gen_send1->hash ())
3309  					 .balance (1)
3310  					 .sign (key1.prv, key1.pub)
3311  					 .work (*system.work.generate (key1.pub))
3312  					 .build ();
3313  	auto key1_send1 = builder.make_block ()
3314  					  .account (key1.pub)
3315  					  .previous (key1_open->hash ())
3316  					  .representative (key1.pub)
3317  					  .link (nano::dev::genesis_key.pub)
3318  					  .balance (0)
3319  					  .sign (key1.prv, key1.pub)
3320  					  .work (*system.work.generate (key1_open->hash ()))
3321  					  .build ();
3322  	auto gen_receive = builder.make_block ()
3323  					   .from (*gen_send1)
3324  					   .previous (gen_send1->hash ())
3325  					   .link (key1_send1->hash ())
3326  					   .balance (nano::dev::constants.genesis_amount)
3327  					   .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3328  					   .work (*system.work.generate (gen_send1->hash ()))
3329  					   .build ();
3330  	auto gen_send2 = builder.make_block ()
3331  					 .from (*gen_receive)
3332  					 .previous (gen_receive->hash ())
3333  					 .link (key2.pub)
3334  					 .balance (gen_receive->balance ().number () - 2)
3335  					 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3336  					 .work (*system.work.generate (gen_receive->hash ()))
3337  					 .build ();
3338  	auto key2_open = builder.make_block ()
3339  					 .account (key2.pub)
3340  					 .previous (0)
3341  					 .representative (key2.pub)
3342  					 .link (gen_send2->hash ())
3343  					 .balance (2)
3344  					 .sign (key2.prv, key2.pub)
3345  					 .work (*system.work.generate (key2.pub))
3346  					 .build ();
3347  	auto key2_send1 = builder.make_block ()
3348  					  .account (key2.pub)
3349  					  .previous (key2_open->hash ())
3350  					  .representative (key2.pub)
3351  					  .link (key3.pub)
3352  					  .balance (1)
3353  					  .sign (key2.prv, key2.pub)
3354  					  .work (*system.work.generate (key2_open->hash ()))
3355  					  .build ();
3356  	auto key3_open = builder.make_block ()
3357  					 .account (key3.pub)
3358  					 .previous (0)
3359  					 .representative (key3.pub)
3360  					 .link (key2_send1->hash ())
3361  					 .balance (1)
3362  					 .sign (key3.prv, key3.pub)
3363  					 .work (*system.work.generate (key3.pub))
3364  					 .build ();
3365  	auto key2_send2 = builder.make_block ()
3366  					  .from (*key2_send1)
3367  					  .previous (key2_send1->hash ())
3368  					  .link (key1.pub)
3369  					  .balance (key2_send1->balance ().number () - 1)
3370  					  .sign (key2.prv, key2.pub)
3371  					  .work (*system.work.generate (key2_send1->hash ()))
3372  					  .build ();
3373  	auto key1_receive = builder.make_block ()
3374  						.from (*key1_send1)
3375  						.previous (key1_send1->hash ())
3376  						.link (key2_send2->hash ())
3377  						.balance (key1_send1->balance ().number () + 1)
3378  						.sign (key1.prv, key1.pub)
3379  						.work (*system.work.generate (key1_send1->hash ()))
3380  						.build ();
3381  	auto key1_send2 = builder.make_block ()
3382  					  .from (*key1_receive)
3383  					  .previous (key1_receive->hash ())
3384  					  .link (key3.pub)
3385  					  .balance (key1_receive->balance ().number () - 1)
3386  					  .sign (key1.prv, key1.pub)
3387  					  .work (*system.work.generate (key1_receive->hash ()))
3388  					  .build ();
3389  	auto key3_receive = builder.make_block ()
3390  						.from (*key3_open)
3391  						.previous (key3_open->hash ())
3392  						.link (key1_send2->hash ())
3393  						.balance (key3_open->balance ().number () + 1)
3394  						.sign (key3.prv, key3.pub)
3395  						.work (*system.work.generate (key3_open->hash ()))
3396  						.build ();
3397  	auto key3_epoch = builder.make_block ()
3398  					  .from (*key3_receive)
3399  					  .previous (key3_receive->hash ())
3400  					  .link (node1.ledger.epoch_link (nano::epoch::epoch_1))
3401  					  .balance (key3_receive->balance ())
3402  					  .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3403  					  .work (*system.work.generate (key3_receive->hash ()))
3404  					  .build ();
3405  	for (auto const & node : system.nodes)
3406  	{
3407  		auto transaction (node->store.tx_begin_write ());
3408  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *gen_send1).code);
3409  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *key1_open).code);
3410  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *key1_send1).code);
3411  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *gen_receive).code);
3412  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *gen_send2).code);
3413  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *key2_open).code);
3414  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *key2_send1).code);
3415  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *key3_open).code);
3416  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *key2_send2).code);
3417  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *key1_receive).code);
3418  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *key1_send2).code);
3419  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *key3_receive).code);
3420  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *key3_epoch).code);
3421  	}
3422  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
3423  	ASSERT_TIMELY (10s, node2.active.active (gen_send1->qualified_root ()));
3424  	node1.block_confirm (gen_send1);
3425  	ASSERT_TIMELY (15s, node1.ledger.cache.cemented_count == node1.ledger.cache.block_count);
3426  	ASSERT_TIMELY (15s, node2.ledger.cache.cemented_count == node2.ledger.cache.block_count);
3427  }
3428  namespace nano
3429  {
3430  TEST (node, deferred_dependent_elections)
3431  {
3432  	nano::test::system system;
3433  	nano::node_config node_config_1{ system.get_available_port (), system.logging };
3434  	node_config_1.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
3435  	nano::node_config node_config_2{ system.get_available_port (), system.logging };
3436  	node_config_2.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
3437  	nano::node_flags flags;
3438  	flags.disable_request_loop = true;
3439  	auto & node = *system.add_node (node_config_1, flags);
3440  	auto & node2 = *system.add_node (node_config_2, flags); 
3441  	nano::state_block_builder builder;
3442  	nano::keypair key;
3443  	auto send1 = builder.make_block ()
3444  				 .account (nano::dev::genesis_key.pub)
3445  				 .previous (nano::dev::genesis->hash ())
3446  				 .representative (nano::dev::genesis_key.pub)
3447  				 .link (key.pub)
3448  				 .balance (nano::dev::constants.genesis_amount - 1)
3449  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3450  				 .work (*system.work.generate (nano::dev::genesis->hash ()))
3451  				 .build_shared ();
3452  	auto open = builder.make_block ()
3453  				.account (key.pub)
3454  				.previous (0)
3455  				.representative (key.pub)
3456  				.link (send1->hash ())
3457  				.balance (1)
3458  				.sign (key.prv, key.pub)
3459  				.work (*system.work.generate (key.pub))
3460  				.build_shared ();
3461  	auto send2 = builder.make_block ()
3462  				 .from (*send1)
3463  				 .previous (send1->hash ())
3464  				 .balance (send1->balance ().number () - 1)
3465  				 .link (key.pub)
3466  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3467  				 .work (*system.work.generate (send1->hash ()))
3468  				 .build_shared ();
3469  	auto receive = builder.make_block ()
3470  				   .from (*open)
3471  				   .previous (open->hash ())
3472  				   .link (send2->hash ())
3473  				   .balance (2)
3474  				   .sign (key.prv, key.pub)
3475  				   .work (*system.work.generate (open->hash ()))
3476  				   .build_shared ();
3477  	auto fork = builder.make_block ()
3478  				.from (*receive)
3479  				.representative (nano::dev::genesis_key.pub) 
3480  				.sign (key.prv, key.pub)
3481  				.build_shared ();
3482  	nano::test::process (node, { send1 });
3483  	auto election_send1 = nano::test::start_election (system, node, send1->hash ());
3484  	ASSERT_NE (nullptr, election_send1);
3485  	nano::test::process (node, { open, send2 });
3486  	ASSERT_TIMELY (5s, node.block (open->hash ()));
3487  	ASSERT_TIMELY (5s, node.block (send2->hash ()));
3488  	ASSERT_NEVER (0.5s, node.active.active (open->qualified_root ()) || node.active.active (send2->qualified_root ()));
3489  	ASSERT_TIMELY (5s, node2.block (open->hash ()));
3490  	ASSERT_TIMELY (5s, node2.block (send2->hash ()));
3491  	node.work_generate_blocking (*open, nano::dev::network_params.work.difficulty (*open) + 1);
3492  	node.process_local (open);
3493  	ASSERT_NEVER (0.5s, node.active.active (open->qualified_root ()));
3494  	ASSERT_TRUE (nano::test::start_election (system, node, open->hash ()));
3495  	node.active.erase (*open);
3496  	ASSERT_FALSE (node.active.active (open->qualified_root ()));
3497  	node.work_generate_blocking (*open, nano::dev::network_params.work.difficulty (*open) + 1);
3498  	ASSERT_FALSE (node.active.active (open->qualified_root ()));
3499  	node.process_local (open);
3500  	ASSERT_NEVER (0.5s, node.active.active (open->qualified_root ()));
3501  	node.active.erase (*open);
3502  	ASSERT_FALSE (node.active.active (open->qualified_root ()));
3503  	node.active.erase (*send2);
3504  	ASSERT_FALSE (node.active.active (send2->qualified_root ()));
3505  	election_send1->force_confirm ();
3506  	ASSERT_TIMELY (5s, node.block_confirmed (send1->hash ()));
3507  	ASSERT_TIMELY (5s, node.active.active (open->qualified_root ()));
3508  	ASSERT_TIMELY (5s, node.active.active (send2->qualified_root ()));
3509  	auto election_open = node.active.election (open->qualified_root ());
3510  	ASSERT_NE (nullptr, election_open);
3511  	auto election_send2 = node.active.election (send2->qualified_root ());
3512  	ASSERT_NE (nullptr, election_open);
3513  	ASSERT_EQ (nano::process_result::progress, node.process (*receive).code);
3514  	ASSERT_FALSE (node.active.active (receive->qualified_root ()));
3515  	election_open->force_confirm ();
3516  	ASSERT_TIMELY (5s, node.block_confirmed (open->hash ()));
3517  	ASSERT_FALSE (node.ledger.dependents_confirmed (node.store.tx_begin_read (), *receive));
3518  	ASSERT_NEVER (0.5s, node.active.active (receive->qualified_root ()));
3519  	ASSERT_FALSE (node.ledger.rollback (node.store.tx_begin_write (), receive->hash ()));
3520  	ASSERT_FALSE (node.block (receive->hash ()));
3521  	node.process_local (receive);
3522  	ASSERT_TIMELY (5s, node.block (receive->hash ()));
3523  	ASSERT_NEVER (0.5s, node.active.active (receive->qualified_root ()));
3524  	ASSERT_EQ (nano::process_result::fork, node.process (*fork).code);
3525  	node.process_local (fork);
3526  	ASSERT_NEVER (0.5s, node.active.active (receive->qualified_root ()));
3527  	election_send2->force_confirm ();
3528  	ASSERT_TIMELY (5s, node.block_confirmed (send2->hash ()));
3529  	ASSERT_TIMELY (5s, node.active.active (receive->qualified_root ()));
3530  }
3531  }
3532  TEST (rep_crawler, recently_confirmed)
3533  {
3534  	nano::test::system system (1);
3535  	auto & node1 (*system.nodes[0]);
3536  	ASSERT_EQ (1, node1.ledger.cache.block_count);
3537  	auto const block = nano::dev::genesis;
3538  	node1.active.recently_confirmed.put (block->qualified_root (), block->hash ());
3539  	auto & node2 (*system.add_node ());
3540  	system.wallet (1)->insert_adhoc (nano::dev::genesis_key.prv);
3541  	auto channel = node1.network.find_node_id (node2.get_node_id ());
3542  	ASSERT_NE (nullptr, channel);
3543  	node1.rep_crawler.query (channel);
3544  	ASSERT_TIMELY (3s, node1.rep_crawler.representative_count () == 1);
3545  }
3546  namespace nano
3547  {
3548  TEST (rep_crawler, local)
3549  {
3550  	nano::test::system system;
3551  	nano::node_flags flags;
3552  	flags.disable_rep_crawler = true;
3553  	auto & node = *system.add_node (flags);
3554  	auto loopback = std::make_shared<nano::transport::inproc::channel> (node, node);
3555  	auto vote = std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, 0, 0, std::vector{ nano::dev::genesis->hash () });
3556  	{
3557  		nano::lock_guard<nano::mutex> guard{ node.rep_crawler.probable_reps_mutex };
3558  		node.rep_crawler.active.insert (nano::dev::genesis->hash ());
3559  		node.rep_crawler.responses.emplace_back (loopback, vote);
3560  	}
3561  	node.rep_crawler.validate ();
3562  	ASSERT_EQ (0, node.rep_crawler.representative_count ());
3563  }
3564  }
3565  TEST (node, pruning_automatic)
3566  {
3567  	nano::test::system system{};
3568  	nano::node_config node_config{ system.get_available_port (), system.logging };
3569  	node_config.enable_voting = false;
3570  	node_config.max_pruning_age = std::chrono::seconds (1);
3571  	nano::node_flags node_flags{};
3572  	node_flags.enable_pruning = true;
3573  	auto & node1 = *system.add_node (node_config, node_flags);
3574  	nano::keypair key1{};
3575  	nano::send_block_builder builder{};
3576  	auto latest_hash = nano::dev::genesis->hash ();
3577  	auto send1 = builder.make_block ()
3578  				 .previous (latest_hash)
3579  				 .destination (key1.pub)
3580  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
3581  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3582  				 .work (*system.work.generate (latest_hash))
3583  				 .build_shared ();
3584  	node1.process_active (send1);
3585  	latest_hash = send1->hash ();
3586  	auto send2 = builder.make_block ()
3587  				 .previous (latest_hash)
3588  				 .destination (key1.pub)
3589  				 .balance (0)
3590  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3591  				 .work (*system.work.generate (latest_hash))
3592  				 .build_shared ();
3593  	node1.process_active (send2);
3594  	ASSERT_TIMELY (5s, node1.block (send2->hash ()) != nullptr);
3595  	node1.process_confirmed (nano::election_status{ send1 });
3596  	ASSERT_TIMELY (5s, node1.block_confirmed (send1->hash ()));
3597  	node1.process_confirmed (nano::election_status{ send2 });
3598  	ASSERT_TIMELY (5s, node1.block_confirmed (send2->hash ()));
3599  	ASSERT_EQ (3, node1.ledger.cache.block_count);
3600  	ASSERT_TIMELY (5s, node1.ledger.cache.pruned_count == 1);
3601  	ASSERT_TIMELY (5s, node1.store.pruned.count (node1.store.tx_begin_read ()) == 1);
3602  	ASSERT_EQ (1, node1.ledger.cache.pruned_count);
3603  	ASSERT_EQ (3, node1.ledger.cache.block_count);
3604  	ASSERT_TRUE (node1.ledger.block_or_pruned_exists (nano::dev::genesis->hash ()));
3605  	ASSERT_TRUE (node1.ledger.block_or_pruned_exists (send1->hash ()));
3606  	ASSERT_TRUE (node1.ledger.block_or_pruned_exists (send2->hash ()));
3607  }
3608  TEST (node, pruning_age)
3609  {
3610  	nano::test::system system{};
3611  	nano::node_config node_config{ system.get_available_port (), system.logging };
3612  	node_config.enable_voting = false;
3613  	nano::node_flags node_flags{};
3614  	node_flags.enable_pruning = true;
3615  	auto & node1 = *system.add_node (node_config, node_flags);
3616  	nano::keypair key1{};
3617  	nano::send_block_builder builder{};
3618  	auto latest_hash = nano::dev::genesis->hash ();
3619  	auto send1 = builder.make_block ()
3620  				 .previous (latest_hash)
3621  				 .destination (key1.pub)
3622  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
3623  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3624  				 .work (*system.work.generate (latest_hash))
3625  				 .build_shared ();
3626  	node1.process_active (send1);
3627  	latest_hash = send1->hash ();
3628  	auto send2 = builder.make_block ()
3629  				 .previous (latest_hash)
3630  				 .destination (key1.pub)
3631  				 .balance (0)
3632  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3633  				 .work (*system.work.generate (latest_hash))
3634  				 .build_shared ();
3635  	node1.process_active (send2);
3636  	node1.process_confirmed (nano::election_status{ send1 });
3637  	ASSERT_TIMELY (5s, node1.block_confirmed (send1->hash ()));
3638  	node1.process_confirmed (nano::election_status{ send2 });
3639  	ASSERT_TIMELY (5s, node1.block_confirmed (send2->hash ()));
3640  	ASSERT_EQ (0, node1.ledger.cache.pruned_count);
3641  	ASSERT_EQ (3, node1.ledger.cache.block_count);
3642  	node1.ledger_pruning (1, true, false);
3643  	ASSERT_EQ (0, node1.ledger.cache.pruned_count);
3644  	ASSERT_EQ (3, node1.ledger.cache.block_count);
3645  	node1.config.max_pruning_age = std::chrono::seconds{ 0 };
3646  	node1.ledger_pruning (1, true, false);
3647  	ASSERT_EQ (1, node1.ledger.cache.pruned_count);
3648  	ASSERT_EQ (3, node1.ledger.cache.block_count);
3649  	ASSERT_TRUE (node1.ledger.block_or_pruned_exists (nano::dev::genesis->hash ()));
3650  	ASSERT_TRUE (node1.ledger.block_or_pruned_exists (send1->hash ()));
3651  	ASSERT_TRUE (node1.ledger.block_or_pruned_exists (send2->hash ()));
3652  }
3653  TEST (node, pruning_depth)
3654  {
3655  	nano::test::system system{};
3656  	nano::node_config node_config{ system.get_available_port (), system.logging };
3657  	node_config.enable_voting = false;
3658  	nano::node_flags node_flags{};
3659  	node_flags.enable_pruning = true;
3660  	auto & node1 = *system.add_node (node_config, node_flags);
3661  	nano::keypair key1{};
3662  	nano::send_block_builder builder{};
3663  	auto latest_hash = nano::dev::genesis->hash ();
3664  	auto send1 = builder.make_block ()
3665  				 .previous (latest_hash)
3666  				 .destination (key1.pub)
3667  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
3668  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3669  				 .work (*system.work.generate (latest_hash))
3670  				 .build_shared ();
3671  	node1.process_active (send1);
3672  	latest_hash = send1->hash ();
3673  	auto send2 = builder.make_block ()
3674  				 .previous (latest_hash)
3675  				 .destination (key1.pub)
3676  				 .balance (0)
3677  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
3678  				 .work (*system.work.generate (latest_hash))
3679  				 .build_shared ();
3680  	node1.process_active (send2);
3681  	node1.process_confirmed (nano::election_status{ send1 });
3682  	ASSERT_TIMELY (5s, node1.block_confirmed (send1->hash ()));
3683  	node1.process_confirmed (nano::election_status{ send2 });
3684  	ASSERT_TIMELY (5s, node1.block_confirmed (send2->hash ()));
3685  	ASSERT_EQ (0, node1.ledger.cache.pruned_count);
3686  	ASSERT_EQ (3, node1.ledger.cache.block_count);
3687  	node1.ledger_pruning (1, true, false);
3688  	ASSERT_EQ (0, node1.ledger.cache.pruned_count);
3689  	ASSERT_EQ (3, node1.ledger.cache.block_count);
3690  	node1.config.max_pruning_depth = 1;
3691  	node1.ledger_pruning (1, true, false);
3692  	ASSERT_EQ (1, node1.ledger.cache.pruned_count);
3693  	ASSERT_EQ (3, node1.ledger.cache.block_count);
3694  	ASSERT_TRUE (node1.ledger.block_or_pruned_exists (nano::dev::genesis->hash ()));
3695  	ASSERT_TRUE (node1.ledger.block_or_pruned_exists (send1->hash ()));
3696  	ASSERT_TRUE (node1.ledger.block_or_pruned_exists (send2->hash ()));
3697  }
3698  TEST (node_config, node_id_private_key_persistence)
3699  {
3700  	nano::logger_mt logger;
3701  	auto path = nano::unique_path ();
3702  	ASSERT_TRUE (boost::filesystem::create_directories (path));
3703  	auto priv_key_filename = path / "node_id_private.key";
3704  	nano::keypair kp1 = nano::load_or_create_node_id (path, logger);
3705  	boost::filesystem::remove (priv_key_filename);
3706  	nano::keypair kp2 = nano::load_or_create_node_id (path, logger);
3707  	ASSERT_NE (kp1.prv, kp2.prv);
3708  	nano::keypair kp3 = nano::load_or_create_node_id (path, logger);
3709  	ASSERT_EQ (kp2.prv, kp3.prv);
3710  	std::ofstream ofs (priv_key_filename.string (), std::ofstream::out | std::ofstream::trunc);
3711  	ofs << "3F28D035B8AA75EA53DF753BFD065CF6138E742971B2C99B84FD8FE328FED2D9" << std::flush;
3712  	ofs.close ();
3713  	nano::keypair kp4 = nano::load_or_create_node_id (path, logger);
3714  	ASSERT_EQ (kp4.prv, nano::keypair ("3F28D035B8AA75EA53DF753BFD065CF6138E742971B2C99B84FD8FE328FED2D9").prv);
3715  }
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-node_6.cpp</h3>
            <pre><code>1  #include <nano/crypto_lib/random_pool.hpp>
2  #include <nano/lib/threading.hpp>
3  #include <nano/node/election.hpp>
4  #include <nano/node/scheduler/buckets.hpp>
5  #include <nano/node/scheduler/component.hpp>
6  #include <nano/node/transport/inproc.hpp>
7  #include <nano/node/unchecked_map.hpp>
8  #include <nano/test_common/network.hpp>
9  #include <nano/test_common/system.hpp>
10  #include <nano/test_common/testutil.hpp>
11  #include <gtest/gtest.h>
12  #include <boost/format.hpp>
13  #include <boost/unordered_set.hpp>
14  #include <numeric>
15  #include <random>
16  using namespace std::chrono_literals;
17  size_t manually_count_pruned_blocks (nano::store & store)
18  {
19  	size_t count = 0;
20  	auto transaction = store.tx_begin_read ();
21  	auto i = store.pruned.begin (transaction);
22  	for (; i != store.pruned.end (); ++i)
23  	{
24  		++count;
25  	}
26  	return count;
27  }
28  TEST (system, generate_mass_activity)
29  {
30  	nano::test::system system;
31  	nano::node_config node_config = system.default_config ();
32  	node_config.enable_voting = false; 
33  	auto node = system.add_node (node_config);
34  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
35  	uint32_t count (20);
36  	system.generate_mass_activity (count, *system.nodes[0]);
37  	auto transaction (system.nodes[0]->store.tx_begin_read ());
38  	for (auto i (system.nodes[0]->store.account.begin (transaction)), n (system.nodes[0]->store.account.end ()); i != n; ++i)
39  	{
40  	}
41  }
42  TEST (system, generate_mass_activity_long)
43  {
44  	nano::test::system system;
45  	nano::node_config node_config = system.default_config ();
46  	node_config.enable_voting = false; 
47  	auto node = system.add_node (node_config);
48  	nano::thread_runner runner (system.io_ctx, system.nodes[0]->config.io_threads);
49  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
50  	uint32_t count (1000000);
51  	auto count_env_var = std::getenv ("SLOW_TEST_SYSTEM_GENERATE_MASS_ACTIVITY_LONG_COUNT");
52  	if (count_env_var)
53  	{
54  		count = boost::lexical_cast<uint32_t> (count_env_var);
55  		std::cout << "count override due to env variable set, count=" << count << std::endl;
56  	}
57  	system.generate_mass_activity (count, *system.nodes[0]);
58  	auto transaction (system.nodes[0]->store.tx_begin_read ());
59  	for (auto i (system.nodes[0]->store.account.begin (transaction)), n (system.nodes[0]->store.account.end ()); i != n; ++i)
60  	{
61  	}
62  	system.stop ();
63  	runner.join ();
64  }
65  TEST (system, receive_while_synchronizing)
66  {
67  	std::vector<boost::thread> threads;
68  	{
69  		nano::test::system system;
70  		nano::node_config node_config = system.default_config ();
71  		node_config.enable_voting = false; 
72  		auto node = system.add_node (node_config);
73  		nano::thread_runner runner (system.io_ctx, system.nodes[0]->config.io_threads);
74  		system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
75  		uint32_t count (1000);
76  		system.generate_mass_activity (count, *system.nodes[0]);
77  		nano::keypair key;
78  		auto node1 (std::make_shared<nano::node> (system.io_ctx, system.get_available_port (), nano::unique_path (), system.logging, system.work));
79  		ASSERT_FALSE (node1->init_error ());
80  		auto wallet (node1->wallets.create (1));
81  		wallet->insert_adhoc (nano::dev::genesis_key.prv); 
82  		ASSERT_EQ (key.pub, wallet->insert_adhoc (key.prv));
83  		node1->start ();
<span onclick='openModal()' class='match'>84  		system.nodes.push_back (node1);
85  		ASSERT_NE (nullptr, nano::test::establish_tcp (system, *node1, node->network.endpoint ()));
86  		node1->workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::milliseconds (200), ([&system, &key] () {
</span>87  			auto hash (system.wallet (0)->send_sync (nano::dev::genesis_key.pub, key.pub, system.nodes[0]->config.receive_minimum.number ()));
88  			auto transaction (system.nodes[0]->store.tx_begin_read ());
89  			auto block (system.nodes[0]->store.block.get (transaction, hash));
90  			std::string block_text;
91  			block->serialize_json (block_text);
92  		}));
93  		ASSERT_TIMELY (10s, !node1->balance (key.pub).is_zero ());
94  		node1->stop ();
95  		system.stop ();
96  		runner.join ();
97  	}
98  	for (auto i (threads.begin ()), n (threads.end ()); i != n; ++i)
99  	{
100  		i->join ();
101  	}
102  }
103  TEST (ledger, deep_account_compute)
104  {
105  	nano::logger_mt logger;
106  	auto store = nano::make_store (logger, nano::unique_path (), nano::dev::constants);
107  	ASSERT_FALSE (store->init_error ());
108  	nano::stats stats;
109  	nano::ledger ledger (*store, stats, nano::dev::constants);
110  	auto transaction (store->tx_begin_write ());
111  	store->initialize (transaction, ledger.cache, ledger.constants);
112  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
113  	nano::keypair key;
114  	auto balance (nano::dev::constants.genesis_amount - 1);
115  	nano::block_builder builder;
116  	auto send = builder
117  				.send ()
118  				.previous (nano::dev::genesis->hash ())
119  				.destination (key.pub)
120  				.balance (balance)
121  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
122  				.work (*pool.generate (nano::dev::genesis->hash ()))
123  				.build ();
124  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send).code);
125  	auto open = builder
126  				.open ()
127  				.source (send->hash ())
128  				.representative (nano::dev::genesis_key.pub)
129  				.account (key.pub)
130  				.sign (key.prv, key.pub)
131  				.work (*pool.generate (key.pub))
132  				.build ();
133  	ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *open).code);
134  	auto sprevious (send->hash ());
135  	auto rprevious (open->hash ());
136  	for (auto i (0), n (100000); i != n; ++i)
137  	{
138  		balance -= 1;
139  		auto send = builder
140  					.send ()
141  					.previous (sprevious)
142  					.destination (key.pub)
143  					.balance (balance)
144  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
145  					.work (*pool.generate (sprevious))
146  					.build ();
147  		ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send).code);
148  		sprevious = send->hash ();
149  		auto receive = builder
150  					   .receive ()
151  					   .previous (rprevious)
152  					   .source (send->hash ())
153  					   .sign (key.prv, key.pub)
154  					   .work (*pool.generate (rprevious))
155  					   .build ();
156  		ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *receive).code);
157  		rprevious = receive->hash ();
158  		if (i % 100 == 0)
159  		{
160  			std::cerr << i << ' ';
161  		}
162  		ledger.account (transaction, sprevious);
163  		ledger.balance (transaction, rprevious);
164  	}
165  }
166  TEST (wallet, multithreaded_send_async)
167  {
168  	std::vector<boost::thread> threads;
169  	{
170  		nano::test::system system (1);
171  		nano::keypair key;
172  		auto wallet_l (system.wallet (0));
173  		wallet_l->insert_adhoc (nano::dev::genesis_key.prv);
174  		wallet_l->insert_adhoc (key.prv);
175  		int num_of_threads = 20;
176  		int num_of_sends = 1000;
177  		for (auto i (0); i < num_of_threads; ++i)
178  		{
179  			threads.push_back (boost::thread ([wallet_l, &key, num_of_threads, num_of_sends] () {
180  				for (auto i (0); i < num_of_sends; ++i)
181  				{
182  					wallet_l->send_async (nano::dev::genesis_key.pub, key.pub, 1000, [] (std::shared_ptr<nano::block> const & block_a) {
183  						ASSERT_FALSE (block_a == nullptr);
184  						ASSERT_FALSE (block_a->hash ().is_zero ());
185  					});
186  				}
187  			}));
188  		}
189  		ASSERT_TIMELY (1000s, system.nodes[0]->balance (nano::dev::genesis_key.pub) == (nano::dev::constants.genesis_amount - num_of_threads * num_of_sends * 1000));
190  	}
191  	for (auto i (threads.begin ()), n (threads.end ()); i != n; ++i)
192  	{
193  		i->join ();
194  	}
195  }
196  TEST (store, load)
197  {
198  	nano::test::system system (1);
199  	std::vector<boost::thread> threads;
200  	for (auto i (0); i < 100; ++i)
201  	{
202  		threads.push_back (boost::thread ([&system] () {
203  			for (auto i (0); i != 1000; ++i)
204  			{
205  				auto transaction (system.nodes[0]->store.tx_begin_write ());
206  				for (auto j (0); j != 10; ++j)
207  				{
208  					nano::account account;
209  					nano::random_pool::generate_block (account.bytes.data (), account.bytes.size ());
210  					system.nodes[0]->store.confirmation_height.put (transaction, account, { 0, nano::block_hash (0) });
211  					system.nodes[0]->store.account.put (transaction, account, nano::account_info ());
212  				}
213  			}
214  		}));
215  	}
216  	for (auto & i : threads)
217  	{
218  		i.join ();
219  	}
220  }
221  namespace nano
222  {
223  TEST (node, fork_storm)
224  {
225  	static const auto node_count (23);
226  	nano::node_flags flags;
227  	flags.disable_max_peers_per_ip = true;
228  	nano::test::system system (node_count, nano::transport::transport_type::tcp, flags);
229  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
230  	auto previous (system.nodes[0]->latest (nano::dev::genesis_key.pub));
231  	auto balance (system.nodes[0]->balance (nano::dev::genesis_key.pub));
232  	ASSERT_FALSE (previous.is_zero ());
233  	nano::block_builder builder;
234  	for (auto node_j : system.nodes)
235  	{
236  		balance -= 1;
237  		nano::keypair key;
238  		auto send = builder
239  					.send ()
240  					.previous (previous)
241  					.destination (key.pub)
242  					.balance (balance)
243  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
244  					.work (0)
245  					.build ();
246  		node_j->work_generate_blocking (*send);
247  		previous = send->hash ();
248  		for (auto node_i : system.nodes)
249  		{
250  			auto send_result (node_i->process (*send));
251  			ASSERT_EQ (nano::process_result::progress, send_result.code);
252  			nano::keypair rep;
253  			auto open = builder
254  						.open ()
255  						.source (previous)
256  						.representative (rep.pub)
257  						.account (key.pub)
258  						.sign (key.prv, key.pub)
259  						.work (0)
260  						.build_shared ();
261  			node_i->work_generate_blocking (*open);
262  			auto open_result (node_i->process (*open));
263  			ASSERT_EQ (nano::process_result::progress, open_result.code);
264  			auto transaction (node_i->store.tx_begin_read ());
265  			node_i->network.flood_block (open);
266  		}
267  	}
268  	auto again (true);
269  	int iteration (0);
270  	auto old_empty (0);
271  	auto old_single (0);
272  	auto stall_count (0);
273  	while (again)
274  	{
275  		auto empty = 0;
276  		auto single = 0;
277  		std::for_each (system.nodes.begin (), system.nodes.end (), [&] (std::shared_ptr<nano::node> const & node_a) {
278  			if (node_a->active.empty ())
279  			{
280  				++empty;
281  			}
282  			else
283  			{
284  				nano::unique_lock<nano::mutex> lock{ node_a->active.mutex };
285  				auto election = node_a->active.roots.begin ()->election;
286  				lock.unlock ();
287  				if (election->votes ().size () == 1)
288  				{
289  					++single;
290  				}
291  			}
292  		});
293  		ASSERT_NO_ERROR (system.poll ());
294  		if (old_empty == empty && old_single == single)
295  		{
296  			static const auto stall_tolerance (100000);
297  			++stall_count;
298  			ASSERT_LE (stall_count, stall_tolerance) << "Stall deteceted. These values were both expected to eventually reach 0 but have remained unchanged for " << stall_tolerance << " iterations. Empty: " << empty << " single: " << single << std::endl;
299  		}
300  		else
301  		{
302  			stall_count = 0;
303  			old_empty = empty;
304  			old_single = single;
305  		}
306  		again = (empty != 0) || (single != 0);
307  		++iteration;
308  	}
309  	ASSERT_TRUE (true);
310  }
311  } 
312  namespace
313  {
314  size_t heard_count (std::vector<uint8_t> const & nodes)
315  {
316  	auto result (0);
317  	for (auto i (nodes.begin ()), n (nodes.end ()); i != n; ++i)
318  	{
319  		switch (*i)
320  		{
321  			case 0:
322  				break;
323  			case 1:
324  				++result;
325  				break;
326  			case 2:
327  				++result;
328  				break;
329  		}
330  	}
331  	return result;
332  }
333  }
334  TEST (broadcast, world_broadcast_simulate)
335  {
336  	auto node_count (10000);
337  	std::vector<uint8_t> nodes;
338  	nodes.resize (node_count, 0);
339  	nodes[0] = 1;
340  	auto any_changed (true);
341  	auto message_count (0);
342  	while (any_changed)
343  	{
344  		any_changed = false;
345  		for (auto i (nodes.begin ()), n (nodes.end ()); i != n; ++i)
346  		{
347  			switch (*i)
348  			{
349  				case 0:
350  					break;
351  				case 1:
352  					for (auto j (nodes.begin ()), m (nodes.end ()); j != m; ++j)
353  					{
354  						++message_count;
355  						switch (*j)
356  						{
357  							case 0:
358  								*j = 1;
359  								any_changed = true;
360  								break;
361  							case 1:
362  								break;
363  							case 2:
364  								break;
365  						}
366  					}
367  					*i = 2;
368  					any_changed = true;
369  					break;
370  				case 2:
371  					break;
372  				default:
373  					ASSERT_FALSE (true);
374  					break;
375  			}
376  		}
377  	}
378  	auto count (heard_count (nodes));
379  	(void)count;
380  }
381  TEST (broadcast, sqrt_broadcast_simulate)
382  {
383  	auto node_count (10000);
384  	auto broadcast_count (std::ceil (std::sqrt (node_count)));
385  	std::vector<uint8_t> nodes;
386  	nodes.resize (node_count, 0);
387  	nodes[0] = 1;
388  	auto any_changed (true);
389  	uint64_t message_count (0);
390  	while (any_changed)
391  	{
392  		any_changed = false;
393  		for (auto i (nodes.begin ()), n (nodes.end ()); i != n; ++i)
394  		{
395  			switch (*i)
396  			{
397  				case 0:
398  					break;
399  				case 1:
400  					for (auto j (0); j != broadcast_count; ++j)
401  					{
402  						++message_count;
403  						auto entry (nano::random_pool::generate_word32 (0, node_count - 1));
404  						switch (nodes[entry])
405  						{
406  							case 0:
407  								nodes[entry] = 1;
408  								any_changed = true;
409  								break;
410  							case 1:
411  								break;
412  							case 2:
413  								break;
414  						}
415  					}
416  					*i = 2;
417  					any_changed = true;
418  					break;
419  				case 2:
420  					break;
421  				default:
422  					ASSERT_FALSE (true);
423  					break;
424  			}
425  		}
426  	}
427  	auto count (heard_count (nodes));
428  	(void)count;
429  }
430  TEST (peer_container, random_set)
431  {
432  	nano::test::system system (1);
433  	auto old (std::chrono::steady_clock::now ());
434  	auto current (std::chrono::steady_clock::now ());
435  	for (auto i (0); i < 10000; ++i)
436  	{
437  		auto list (system.nodes[0]->network.random_set (15));
438  	}
439  	auto end (std::chrono::steady_clock::now ());
440  	(void)end;
441  	auto old_ms (std::chrono::duration_cast<std::chrono::milliseconds> (current - old));
442  	(void)old_ms;
443  	auto new_ms (std::chrono::duration_cast<std::chrono::milliseconds> (end - current));
444  	(void)new_ms;
445  }
446  TEST (store, unchecked_load)
447  {
448  	nano::test::system system{ 1 };
449  	auto & node = *system.nodes[0];
450  	nano::block_builder builder;
451  	std::shared_ptr<nano::block> block = builder
452  										 .send ()
453  										 .previous (0)
454  										 .destination (0)
455  										 .balance (0)
456  										 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
457  										 .work (0)
458  										 .build_shared ();
459  	constexpr auto num_unchecked = 1'000'000;
460  	for (auto i (0); i < num_unchecked; ++i)
461  	{
462  		node.unchecked.put (i, block);
463  	}
464  	ASSERT_TIMELY (8000s, num_unchecked == node.unchecked.count ());
465  }
466  TEST (store, vote_load)
467  {
468  	nano::test::system system{ 1 };
469  	auto & node = *system.nodes[0];
470  	for (auto i = 0u; i < 1000000u; ++i)
471  	{
472  		auto vote = std::make_shared<nano::vote> (nano::dev::genesis_key.pub, nano::dev::genesis_key.prv, i, 0, std::vector<nano::block_hash>{ i });
473  		node.vote_processor.vote (vote, std::make_shared<nano::transport::inproc::channel> (node, node));
474  	}
475  }
476  TEST (store, pruned_load)
477  {
478  	nano::logger_mt logger;
479  	auto path (nano::unique_path ());
480  	constexpr auto num_pruned = 2000000;
481  	auto const expected_result = num_pruned / 2;
482  	constexpr auto batch_size = 20;
483  	boost::unordered_set<nano::block_hash> hashes;
484  	{
485  		auto store = nano::make_store (logger, path, nano::dev::constants);
486  		ASSERT_FALSE (store->init_error ());
487  		for (auto i (0); i < num_pruned / batch_size; ++i)
488  		{
489  			{
490  				auto transaction (store->tx_begin_write ());
491  				for (auto k (0); k < batch_size; ++k)
492  				{
493  					nano::block_hash random_hash;
494  					nano::random_pool::generate_block (random_hash.bytes.data (), random_hash.bytes.size ());
495  					store->pruned.put (transaction, random_hash);
496  					hashes.insert (random_hash);
497  				}
498  			}
499  			{
500  				auto transaction (store->tx_begin_write ());
501  				for (auto k (0); !hashes.empty () && k < batch_size / 2; ++k)
502  				{
503  					auto hash (hashes.begin ());
504  					store->pruned.del (transaction, *hash);
505  					hashes.erase (hash);
506  				}
507  			}
508  		}
509  		ASSERT_EQ (expected_result, manually_count_pruned_blocks (*store));
510  	}
511  	{
512  		auto store = nano::make_store (logger, path, nano::dev::constants);
513  		ASSERT_FALSE (store->init_error ());
514  		ASSERT_EQ (expected_result, manually_count_pruned_blocks (*store));
515  	}
516  }
517  TEST (wallets, rep_scan)
518  {
519  	nano::test::system system (1);
520  	auto & node (*system.nodes[0]);
521  	auto wallet (system.wallet (0));
522  	{
523  		auto transaction (node.wallets.tx_begin_write ());
524  		for (auto i (0); i < 10000; ++i)
525  		{
526  			wallet->deterministic_insert (transaction);
527  		}
528  	}
529  	auto begin (std::chrono::steady_clock::now ());
530  	node.wallets.foreach_representative ([] (nano::public_key const & pub_a, nano::raw_key const & prv_a) {
531  	});
532  	ASSERT_LT (std::chrono::steady_clock::now () - begin, std::chrono::milliseconds (5));
533  }
534  TEST (node, mass_vote_by_hash)
535  {
536  	nano::test::system system (1);
537  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
538  	nano::block_hash previous (nano::dev::genesis->hash ());
539  	nano::keypair key;
540  	std::vector<std::shared_ptr<nano::state_block>> blocks;
541  	nano::block_builder builder;
542  	for (auto i (0); i < 10000; ++i)
543  	{
544  		auto block = builder
545  					 .state ()
546  					 .account (nano::dev::genesis_key.pub)
547  					 .previous (previous)
548  					 .representative (nano::dev::genesis_key.pub)
549  					 .balance (nano::dev::constants.genesis_amount - (i + 1) * nano::Gxrb_ratio)
550  					 .link (key.pub)
551  					 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
552  					 .work (*system.work.generate (previous))
553  					 .build_shared ();
554  		previous = block->hash ();
555  		blocks.push_back (block);
556  	}
557  	for (auto i (blocks.begin ()), n (blocks.end ()); i != n; ++i)
558  	{
559  		system.nodes[0]->block_processor.add (*i);
560  	}
561  }
562  namespace nano
563  {
564  TEST (confirmation_height, many_accounts_single_confirmation)
565  {
566  	nano::test::system system;
567  	nano::node_config node_config = system.default_config ();
568  	node_config.online_weight_minimum = 100;
569  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
570  	auto node = system.add_node (node_config);
571  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
572  	node->confirmation_height_processor.batch_write_size = 500;
573  	auto const num_accounts = nano::confirmation_height::unbounded_cutoff * 2 + 50;
574  	nano::keypair last_keypair = nano::dev::genesis_key;
575  	nano::block_builder builder;
576  	auto last_open_hash = node->latest (nano::dev::genesis_key.pub);
577  	{
578  		auto transaction = node->store.tx_begin_write ();
579  		for (auto i = num_accounts - 1; i > 0; --i)
580  		{
581  			nano::keypair key;
582  			system.wallet (0)->insert_adhoc (key.prv);
583  			auto send = builder
584  						.send ()
585  						.previous (last_open_hash)
586  						.destination (key.pub)
587  						.balance (node->online_reps.delta ())
588  						.sign (last_keypair.prv, last_keypair.pub)
589  						.work (*system.work.generate (last_open_hash))
590  						.build ();
591  			ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *send).code);
592  			auto open = builder
593  						.open ()
594  						.source (send->hash ())
595  						.representative (last_keypair.pub)
596  						.account (key.pub)
597  						.sign (key.prv, key.pub)
598  						.work (*system.work.generate (key.pub))
599  						.build ();
600  			ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *open).code);
601  			last_open_hash = open->hash ();
602  			last_keypair = key;
603  		}
604  	}
605  	{
606  		auto block = node->block (last_open_hash);
607  		ASSERT_NE (nullptr, block);
608  		node->scheduler.buckets.manual (block);
609  		std::shared_ptr<nano::election> election;
610  		ASSERT_TIMELY (10s, (election = node->active.election (block->qualified_root ())) != nullptr);
611  		election->force_confirm ();
612  	}
613  	ASSERT_TIMELY (120s, node->ledger.block_confirmed (node->store.tx_begin_read (), last_open_hash));
614  	auto transaction = node->store.tx_begin_read ();
615  	for (auto i (node->store.account.begin (transaction)), n (node->store.account.end ()); i != n; ++i)
616  	{
617  		auto & account = i->first;
618  		auto & account_info = i->second;
619  		auto count = (account != last_keypair.pub) ? 2 : 1;
620  		nano::confirmation_height_info confirmation_height_info;
621  		ASSERT_FALSE (node->store.confirmation_height.get (transaction, account, confirmation_height_info));
622  		ASSERT_EQ (count, confirmation_height_info.height);
623  		ASSERT_EQ (count, account_info.block_count);
624  	}
625  	size_t cemented_count = 0;
626  	for (auto i (node->ledger.store.confirmation_height.begin (transaction)), n (node->ledger.store.confirmation_height.end ()); i != n; ++i)
627  	{
628  		cemented_count += i->second.height;
629  	}
630  	ASSERT_EQ (cemented_count, node->ledger.cache.cemented_count);
631  	ASSERT_EQ (node->ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed, nano::stat::dir::in), num_accounts * 2 - 2);
632  	ASSERT_EQ (node->ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_bounded, nano::stat::dir::in), num_accounts * 2 - 2);
633  	ASSERT_EQ (node->ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_unbounded, nano::stat::dir::in), 0);
634  	ASSERT_TIMELY (40s, (node->ledger.cache.cemented_count - 1) == node->stats.count (nano::stat::type::confirmation_observer, nano::stat::detail::all, nano::stat::dir::out));
635  	ASSERT_TIMELY (10s, node->active.election_winner_details_size () == 0);
636  }
637  TEST (confirmation_height, many_accounts_many_confirmations)
638  {
639  	nano::test::system system;
640  	nano::node_config node_config = system.default_config ();
641  	node_config.online_weight_minimum = 100;
642  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
643  	auto node = system.add_node (node_config);
644  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
645  	node->confirmation_height_processor.batch_write_size = 500;
646  	auto const num_accounts = nano::confirmation_height::unbounded_cutoff * 2 + 50;
647  	auto latest_genesis = node->latest (nano::dev::genesis_key.pub);
648  	nano::block_builder builder;
649  	std::vector<std::shared_ptr<nano::open_block>> open_blocks;
650  	{
651  		auto transaction = node->store.tx_begin_write ();
652  		for (auto i = num_accounts - 1; i > 0; --i)
653  		{
654  			nano::keypair key;
655  			system.wallet (0)->insert_adhoc (key.prv);
656  			auto send = builder
657  						.send ()
658  						.previous (latest_genesis)
659  						.destination (key.pub)
660  						.balance (node->online_reps.delta ())
661  						.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
662  						.work (*system.work.generate (latest_genesis))
663  						.build ();
664  			ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *send).code);
665  			auto open = builder
666  						.open ()
667  						.source (send->hash ())
668  						.representative (nano::dev::genesis_key.pub)
669  						.account (key.pub)
670  						.sign (key.prv, key.pub)
671  						.work (*system.work.generate (key.pub))
672  						.build_shared ();
673  			ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *open).code);
674  			open_blocks.push_back (std::move (open));
675  			latest_genesis = send->hash ();
676  		}
677  	}
678  	for (auto & open_block : open_blocks)
679  	{
680  		node->scheduler.buckets.manual (open_block);
681  		std::shared_ptr<nano::election> election;
682  		ASSERT_TIMELY (10s, (election = node->active.election (open_block->qualified_root ())) != nullptr);
683  		election->force_confirm ();
684  	}
685  	auto const num_blocks_to_confirm = (num_accounts - 1) * 2;
686  	ASSERT_TIMELY (1500s, node->stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed, nano::stat::dir::in) == num_blocks_to_confirm);
687  	auto num_confirmed_bounded = node->ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_bounded, nano::stat::dir::in);
688  	ASSERT_GE (num_confirmed_bounded, nano::confirmation_height::unbounded_cutoff);
689  	ASSERT_EQ (node->ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_unbounded, nano::stat::dir::in), num_blocks_to_confirm - num_confirmed_bounded);
690  	ASSERT_TIMELY (60s, (node->ledger.cache.cemented_count - 1) == node->stats.count (nano::stat::type::confirmation_observer, nano::stat::detail::all, nano::stat::dir::out));
691  	auto transaction = node->store.tx_begin_read ();
692  	size_t cemented_count = 0;
693  	for (auto i (node->ledger.store.confirmation_height.begin (transaction)), n (node->ledger.store.confirmation_height.end ()); i != n; ++i)
694  	{
695  		cemented_count += i->second.height;
696  	}
697  	ASSERT_EQ (num_blocks_to_confirm + 1, cemented_count);
698  	ASSERT_EQ (cemented_count, node->ledger.cache.cemented_count);
699  	ASSERT_TIMELY (20s, (node->ledger.cache.cemented_count - 1) == node->stats.count (nano::stat::type::confirmation_observer, nano::stat::detail::all, nano::stat::dir::out));
700  	ASSERT_TIMELY (10s, node->active.election_winner_details_size () == 0);
701  }
702  TEST (confirmation_height, long_chains)
703  {
704  	nano::test::system system;
705  	nano::node_config node_config = system.default_config ();
706  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
707  	auto node = system.add_node (node_config);
708  	nano::keypair key1;
709  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
710  	nano::block_hash latest (node->latest (nano::dev::genesis_key.pub));
711  	system.wallet (0)->insert_adhoc (key1.prv);
712  	node->confirmation_height_processor.batch_write_size = 500;
713  	auto const num_blocks = nano::confirmation_height::unbounded_cutoff * 2 + 50;
714  	nano::block_builder builder;
715  	auto send = builder
716  				.send ()
717  				.previous (latest)
718  				.destination (key1.pub)
719  				.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio + num_blocks + 1)
720  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
721  				.work (*system.work.generate (latest))
722  				.build ();
723  	auto open = builder
724  				.open ()
725  				.source (send->hash ())
726  				.representative (nano::dev::genesis->account ())
727  				.account (key1.pub)
728  				.sign (key1.prv, key1.pub)
729  				.work (*system.work.generate (key1.pub))
730  				.build ();
731  	{
732  		auto transaction = node->store.tx_begin_write ();
733  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *send).code);
734  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *open).code);
735  	}
736  	auto previous_genesis_chain_hash = send->hash ();
737  	auto previous_destination_chain_hash = open->hash ();
738  	{
739  		auto transaction = node->store.tx_begin_write ();
740  		for (auto i = num_blocks - 1; i > 0; --i)
741  		{
742  			auto send = builder
743  						.send ()
744  						.previous (previous_genesis_chain_hash)
745  						.destination (key1.pub)
746  						.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio + i + 1)
747  						.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
748  						.work (*system.work.generate (previous_genesis_chain_hash))
749  						.build ();
750  			ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *send).code);
751  			auto receive = builder
752  						   .receive ()
753  						   .previous (previous_destination_chain_hash)
754  						   .source (send->hash ())
755  						   .sign (key1.prv, key1.pub)
756  						   .work (*system.work.generate (previous_destination_chain_hash))
757  						   .build ();
758  			ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *receive).code);
759  			previous_genesis_chain_hash = send->hash ();
760  			previous_destination_chain_hash = receive->hash ();
761  		}
762  	}
763  	auto send1 = builder
764  				 .send ()
765  				 .previous (previous_destination_chain_hash)
766  				 .destination (nano::dev::genesis_key.pub)
767  				 .balance (nano::Gxrb_ratio - 2)
768  				 .sign (key1.prv, key1.pub)
769  				 .work (*system.work.generate (previous_destination_chain_hash))
770  				 .build ();
771  	auto receive1 = builder
772  					.state ()
773  					.account (nano::dev::genesis_key.pub)
774  					.previous (previous_genesis_chain_hash)
775  					.representative (nano::dev::genesis->account ())
776  					.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio + 1)
777  					.link (send1->hash ())
778  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
779  					.work (*system.work.generate (previous_genesis_chain_hash))
780  					.build_shared ();
781  	nano::keypair key2;
782  	auto send2 = builder
783  				 .state ()
784  				 .account (nano::dev::genesis->account ())
785  				 .previous (receive1->hash ())
786  				 .representative (nano::dev::genesis->account ())
787  				 .balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio)
788  				 .link (key2.pub)
789  				 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
790  				 .work (*system.work.generate (receive1->hash ()))
791  				 .build ();
792  	{
793  		auto transaction = node->store.tx_begin_write ();
794  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *send1).code);
795  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *receive1).code);
796  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *send2).code);
797  	}
798  	{
799  		node->scheduler.buckets.manual (receive1);
800  		std::shared_ptr<nano::election> election;
801  		ASSERT_TIMELY (10s, (election = node->active.election (receive1->qualified_root ())) != nullptr);
802  		election->force_confirm ();
803  	}
804  	ASSERT_TIMELY (30s, node->ledger.block_confirmed (node->store.tx_begin_read (), receive1->hash ()));
805  	auto transaction (node->store.tx_begin_read ());
806  	auto info = node->ledger.account_info (transaction, nano::dev::genesis_key.pub);
807  	ASSERT_TRUE (info);
808  	nano::confirmation_height_info confirmation_height_info;
809  	ASSERT_FALSE (node->store.confirmation_height.get (transaction, nano::dev::genesis_key.pub, confirmation_height_info));
810  	ASSERT_EQ (num_blocks + 2, confirmation_height_info.height);
811  	ASSERT_EQ (num_blocks + 3, info->block_count); 
812  	info = node->ledger.account_info (transaction, key1.pub);
813  	ASSERT_TRUE (info);
814  	ASSERT_FALSE (node->store.confirmation_height.get (transaction, key1.pub, confirmation_height_info));
815  	ASSERT_EQ (num_blocks + 1, confirmation_height_info.height);
816  	ASSERT_EQ (num_blocks + 1, info->block_count);
817  	size_t cemented_count = 0;
818  	for (auto i (node->ledger.store.confirmation_height.begin (transaction)), n (node->ledger.store.confirmation_height.end ()); i != n; ++i)
819  	{
820  		cemented_count += i->second.height;
821  	}
822  	ASSERT_EQ (cemented_count, node->ledger.cache.cemented_count);
823  	ASSERT_EQ (node->ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed, nano::stat::dir::in), num_blocks * 2 + 2);
824  	ASSERT_EQ (node->ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_bounded, nano::stat::dir::in), num_blocks * 2 + 2);
825  	ASSERT_EQ (node->ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_unbounded, nano::stat::dir::in), 0);
826  	ASSERT_TIMELY (40s, (node->ledger.cache.cemented_count - 1) == node->stats.count (nano::stat::type::confirmation_observer, nano::stat::detail::all, nano::stat::dir::out));
827  	ASSERT_TIMELY (10s, node->active.election_winner_details_size () == 0);
828  }
829  TEST (confirmation_height, dynamic_algorithm)
830  {
831  	nano::test::system system;
832  	nano::node_config node_config = system.default_config ();
833  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
834  	auto node = system.add_node (node_config);
835  	nano::keypair key;
836  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
837  	auto const num_blocks = nano::confirmation_height::unbounded_cutoff;
838  	auto latest_genesis = nano::dev::genesis;
839  	std::vector<std::shared_ptr<nano::state_block>> state_blocks;
840  	nano::block_builder builder;
841  	for (auto i = 0; i < num_blocks; ++i)
842  	{
843  		auto send = builder
844  					.state ()
845  					.account (nano::dev::genesis_key.pub)
846  					.previous (latest_genesis->hash ())
847  					.representative (nano::dev::genesis_key.pub)
848  					.balance (nano::dev::constants.genesis_amount - i - 1)
849  					.link (key.pub)
850  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
851  					.work (*system.work.generate (latest_genesis->hash ()))
852  					.build_shared ();
853  		latest_genesis = send;
854  		state_blocks.push_back (send);
855  	}
856  	{
857  		auto transaction = node->store.tx_begin_write ();
858  		for (auto const & block : state_blocks)
859  		{
860  			ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *block).code);
861  		}
862  	}
863  	node->confirmation_height_processor.add (state_blocks.front ());
864  	ASSERT_TIMELY (20s, node->ledger.cache.cemented_count == 2);
865  	node->confirmation_height_processor.add (latest_genesis);
866  	ASSERT_TIMELY (20s, node->ledger.cache.cemented_count == num_blocks + 1);
867  	ASSERT_EQ (node->ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed, nano::stat::dir::in), num_blocks);
868  	ASSERT_EQ (node->ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_bounded, nano::stat::dir::in), 1);
869  	ASSERT_EQ (node->ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_unbounded, nano::stat::dir::in), num_blocks - 1);
870  	ASSERT_TIMELY (10s, node->active.election_winner_details_size () == 0);
871  }
872  TEST (confirmation_height, dynamic_algorithm_no_transition_while_pending)
873  {
874  	for (auto _ = 0; _ < 3; ++_)
875  	{
876  		nano::test::system system;
877  		nano::node_config node_config = system.default_config ();
878  		node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
879  		nano::node_flags node_flags;
880  		node_flags.force_use_write_database_queue = true;
881  		auto node = system.add_node (node_config, node_flags);
882  		nano::keypair key;
883  		system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
884  		auto latest_genesis = node->latest (nano::dev::genesis_key.pub);
885  		std::vector<std::shared_ptr<nano::state_block>> state_blocks;
886  		auto const num_blocks = nano::confirmation_height::unbounded_cutoff - 2;
887  		auto add_block_to_genesis_chain = [&] (nano::write_transaction & transaction) {
888  			static int num = 0;
889  			nano::block_builder builder;
890  			auto send = builder
891  						.state ()
892  						.account (nano::dev::genesis_key.pub)
893  						.previous (latest_genesis)
894  						.representative (nano::dev::genesis_key.pub)
895  						.balance (nano::dev::constants.genesis_amount - num - 1)
896  						.link (key.pub)
897  						.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
898  						.work (*system.work.generate (latest_genesis))
899  						.build_shared ();
900  			latest_genesis = send->hash ();
901  			state_blocks.push_back (send);
902  			ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *send).code);
903  			++num;
904  		};
905  		for (auto i = 0; i < num_blocks; ++i)
906  		{
907  			auto transaction = node->store.tx_begin_write ();
908  			add_block_to_genesis_chain (transaction);
909  		}
910  		{
911  			auto write_guard = node->write_database_queue.wait (nano::writer::testing);
912  			node->confirmation_height_processor.add (state_blocks.back ());
913  			nano::timer<> timer;
914  			timer.start ();
915  			while (node->confirmation_height_processor.current ().is_zero ())
916  			{
917  				ASSERT_LT (timer.since_start (), 2s);
918  			}
919  			node->confirmation_height_processor.pause ();
920  			timer.restart ();
921  			ASSERT_TIMELY (10s, node->confirmation_height_processor.unbounded_processor.pending_writes_size != 0);
922  			{
923  				auto transaction = node->store.tx_begin_write ();
924  				add_block_to_genesis_chain (transaction);
925  				add_block_to_genesis_chain (transaction);
926  			}
927  			node->confirmation_height_processor.add (state_blocks.front ());
928  			node->confirmation_height_processor.unpause ();
929  		}
930  		ASSERT_TIMELY (10s, node->ledger.cache.cemented_count == num_blocks + 1);
931  		ASSERT_EQ (node->ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed, nano::stat::dir::in), num_blocks);
932  		ASSERT_EQ (node->ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_bounded, nano::stat::dir::in), 0);
933  		ASSERT_EQ (node->ledger.stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed_unbounded, nano::stat::dir::in), num_blocks);
934  		ASSERT_TIMELY (10s, node->active.election_winner_details_size () == 0);
935  	}
936  }
937  TEST (confirmation_height, many_accounts_send_receive_self)
938  {
939  	nano::test::system system;
940  	nano::node_config node_config = system.default_config ();
941  	node_config.online_weight_minimum = 100;
942  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
943  	node_config.active_elections_size = 400000;
944  	nano::node_flags node_flags;
945  	node_flags.confirmation_height_processor_mode = nano::confirmation_height_mode::unbounded;
946  	auto node = system.add_node (node_config);
947  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
948  #ifndef NDEBUG
949  	auto const num_accounts = 10000;
950  #else
951  	auto const num_accounts = 100000;
952  #endif
953  	auto latest_genesis = node->latest (nano::dev::genesis_key.pub);
954  	std::vector<nano::keypair> keys;
955  	nano::block_builder builder;
956  	std::vector<std::shared_ptr<nano::open_block>> open_blocks;
957  	{
958  		auto transaction = node->store.tx_begin_write ();
959  		for (auto i = 0; i < num_accounts; ++i)
960  		{
961  			nano::keypair key;
962  			keys.emplace_back (key);
963  			auto send = builder
964  						.send ()
965  						.previous (latest_genesis)
966  						.destination (key.pub)
967  						.balance (nano::dev::constants.genesis_amount - 1 - i)
968  						.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
969  						.work (*system.work.generate (latest_genesis))
970  						.build ();
971  			ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *send).code);
972  			auto open = builder
973  						.open ()
974  						.source (send->hash ())
975  						.representative (nano::dev::genesis_key.pub)
976  						.account (key.pub)
977  						.sign (key.prv, key.pub)
978  						.work (*system.work.generate (key.pub))
979  						.build_shared ();
980  			ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *open).code);
981  			open_blocks.push_back (std::move (open));
982  			latest_genesis = send->hash ();
983  		}
984  	}
985  	for (auto & open_block : open_blocks)
986  	{
987  		node->block_confirm (open_block);
988  		std::shared_ptr<nano::election> election;
989  		ASSERT_TIMELY (10s, (election = node->active.election (open_block->qualified_root ())) != nullptr);
990  		election->force_confirm ();
991  	}
992  	system.deadline_set (100s);
993  	auto num_blocks_to_confirm = num_accounts * 2;
994  	while (node->stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed, nano::stat::dir::in) != num_blocks_to_confirm)
995  	{
996  		ASSERT_NO_ERROR (system.poll ());
997  	}
998  	std::vector<std::shared_ptr<nano::send_block>> send_blocks;
999  	std::vector<std::shared_ptr<nano::receive_block>> receive_blocks;
1000  	for (int i = 0; i < open_blocks.size (); ++i)
1001  	{
1002  		auto open_block = open_blocks[i];
1003  		auto & keypair = keys[i];
1004  		send_blocks.emplace_back (builder
1005  								  .send ()
1006  								  .previous (open_block->hash ())
1007  								  .destination (keypair.pub)
1008  								  .balance (1)
1009  								  .sign (keypair.prv, keypair.pub)
1010  								  .work (*system.work.generate (open_block->hash ()))
1011  								  .build_shared ());
1012  		receive_blocks.emplace_back (builder
1013  									 .receive ()
1014  									 .previous (send_blocks.back ()->hash ())
1015  									 .source (send_blocks.back ()->hash ())
1016  									 .sign (keypair.prv, keypair.pub)
1017  									 .work (*system.work.generate (send_blocks.back ()->hash ()))
1018  									 .build_shared ());
1019  	}
1020  	for (int i = 0; i < open_blocks.size (); ++i)
1021  	{
1022  		node->process_active (send_blocks[i]);
1023  		node->process_active (receive_blocks[i]);
1024  	}
1025  	system.deadline_set (300s);
1026  	num_blocks_to_confirm = num_accounts * 4;
1027  	while (node->stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed, nano::stat::dir::in) != num_blocks_to_confirm)
1028  	{
1029  		ASSERT_NO_ERROR (system.poll ());
1030  	}
1031  	system.deadline_set (200s);
1032  	while ((node->ledger.cache.cemented_count - 1) != node->stats.count (nano::stat::type::confirmation_observer, nano::stat::detail::all, nano::stat::dir::out))
1033  	{
1034  		ASSERT_NO_ERROR (system.poll ());
1035  	}
1036  	auto transaction = node->store.tx_begin_read ();
1037  	size_t cemented_count = 0;
1038  	for (auto i (node->ledger.store.confirmation_height.begin (transaction)), n (node->ledger.store.confirmation_height.end ()); i != n; ++i)
1039  	{
1040  		cemented_count += i->second.height;
1041  	}
1042  	ASSERT_EQ (num_blocks_to_confirm + 1, cemented_count);
1043  	ASSERT_EQ (cemented_count, node->ledger.cache.cemented_count);
1044  	system.deadline_set (60s);
1045  	while ((node->ledger.cache.cemented_count - 1) != node->stats.count (nano::stat::type::confirmation_observer, nano::stat::detail::all, nano::stat::dir::out))
1046  	{
1047  		ASSERT_NO_ERROR (system.poll ());
1048  	}
1049  	system.deadline_set (60s);
1050  	while (node->active.election_winner_details_size () > 0)
1051  	{
1052  		ASSERT_NO_ERROR (system.poll ());
1053  	}
1054  }
1055  TEST (confirmation_height, many_accounts_send_receive_self_no_elections)
1056  {
1057  	if (nano::rocksdb_config::using_rocksdb_in_tests ())
1058  	{
1059  		return;
1060  	}
1061  	nano::logger_mt logger;
1062  	nano::logging logging;
1063  	auto path (nano::unique_path ());
1064  	auto store = nano::make_store (logger, path, nano::dev::constants);
1065  	ASSERT_TRUE (!store->init_error ());
1066  	nano::stats stats;
1067  	nano::ledger ledger (*store, stats, nano::dev::constants);
1068  	nano::write_database_queue write_database_queue (false);
1069  	nano::work_pool pool{ nano::dev::network_params.network, std::numeric_limits<unsigned>::max () };
1070  	std::atomic<bool> stopped{ false };
1071  	boost::latch initialized_latch{ 0 };
1072  	nano::block_hash block_hash_being_processed{ 0 };
1073  	nano::confirmation_height_processor confirmation_height_processor{ ledger, write_database_queue, 10ms, logging, logger, initialized_latch, confirmation_height_mode::automatic };
1074  	auto const num_accounts = 100000;
1075  	auto latest_genesis = nano::dev::genesis->hash ();
1076  	std::vector<nano::keypair> keys;
1077  	std::vector<std::shared_ptr<nano::open_block>> open_blocks;
1078  	nano::block_builder builder;
1079  	nano::test::system system;
1080  	{
1081  		auto transaction (store->tx_begin_write ());
1082  		store->initialize (transaction, ledger.cache, ledger.constants);
1083  		for (auto i = 0; i < num_accounts; ++i)
1084  		{
1085  			nano::keypair key;
1086  			keys.emplace_back (key);
1087  			auto send = builder
1088  						.send ()
1089  						.previous (latest_genesis)
1090  						.destination (key.pub)
1091  						.balance (nano::dev::constants.genesis_amount - 1 - i)
1092  						.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1093  						.work (*pool.generate (latest_genesis))
1094  						.build ();
1095  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send).code);
1096  			auto open = builder
1097  						.open ()
1098  						.source (send->hash ())
1099  						.representative (nano::dev::genesis_key.pub)
1100  						.account (key.pub)
1101  						.sign (key.prv, key.pub)
1102  						.work (*pool.generate (key.pub))
1103  						.build_shared ();
1104  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *open).code);
1105  			open_blocks.push_back (std::move (open));
1106  			latest_genesis = send->hash ();
1107  		}
1108  	}
1109  	for (auto & open_block : open_blocks)
1110  	{
1111  		confirmation_height_processor.add (open_block);
1112  	}
1113  	system.deadline_set (1000s);
1114  	auto num_blocks_to_confirm = num_accounts * 2;
1115  	while (stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed, nano::stat::dir::in) != num_blocks_to_confirm)
1116  	{
1117  		ASSERT_NO_ERROR (system.poll ());
1118  	}
1119  	std::vector<std::shared_ptr<nano::send_block>> send_blocks;
1120  	std::vector<std::shared_ptr<nano::receive_block>> receive_blocks;
1121  	{
1122  		auto transaction (store->tx_begin_write ());
1123  		for (int i = 0; i < open_blocks.size (); ++i)
1124  		{
1125  			auto open_block = open_blocks[i];
1126  			auto & keypair = keys[i];
1127  			send_blocks.emplace_back (builder
1128  									  .send ()
1129  									  .previous (open_block->hash ())
1130  									  .destination (keypair.pub)
1131  									  .balance (1)
1132  									  .sign (keypair.prv, keypair.pub)
1133  									  .work (*system.work.generate (open_block->hash ()))
1134  									  .build_shared ());
1135  			receive_blocks.emplace_back (builder
1136  										 .receive ()
1137  										 .previous (send_blocks.back ()->hash ())
1138  										 .source (send_blocks.back ()->hash ())
1139  										 .sign (keypair.prv, keypair.pub)
1140  										 .work (*system.work.generate (send_blocks.back ()->hash ()))
1141  										 .build_shared ());
1142  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *send_blocks.back ()).code);
1143  			ASSERT_EQ (nano::process_result::progress, ledger.process (transaction, *receive_blocks.back ()).code);
1144  		}
1145  	}
1146  	std::random_device rd;
1147  	std::mt19937 g (rd ());
1148  	std::shuffle (send_blocks.begin (), send_blocks.end (), g);
1149  	std::mt19937 g1 (rd ());
1150  	std::shuffle (receive_blocks.begin (), receive_blocks.end (), g1);
1151  	for (int i = 0; i < open_blocks.size (); ++i)
1152  	{
1153  		confirmation_height_processor.add (send_blocks[i]);
1154  		confirmation_height_processor.add (receive_blocks[i]);
1155  	}
1156  	system.deadline_set (1000s);
1157  	num_blocks_to_confirm = num_accounts * 4;
1158  	while (stats.count (nano::stat::type::confirmation_height, nano::stat::detail::blocks_confirmed, nano::stat::dir::in) != num_blocks_to_confirm)
1159  	{
1160  		ASSERT_NO_ERROR (system.poll ());
1161  	}
1162  	while (!confirmation_height_processor.current ().is_zero ())
1163  	{
1164  		ASSERT_NO_ERROR (system.poll ());
1165  	}
1166  	auto transaction = store->tx_begin_read ();
1167  	size_t cemented_count = 0;
1168  	for (auto i (store->confirmation_height.begin (transaction)), n (store->confirmation_height.end ()); i != n; ++i)
1169  	{
1170  		cemented_count += i->second.height;
1171  	}
1172  	ASSERT_EQ (num_blocks_to_confirm + 1, cemented_count);
1173  	ASSERT_EQ (cemented_count, ledger.cache.cemented_count);
1174  }
1175  }
1176  namespace
1177  {
1178  class data
1179  {
1180  public:
1181  	std::atomic<bool> awaiting_cache{ false };
1182  	std::atomic<bool> keep_requesting_metrics{ true };
1183  	std::shared_ptr<nano::node> node;
1184  	std::chrono::system_clock::time_point orig_time;
1185  	std::atomic_flag orig_time_set = ATOMIC_FLAG_INIT;
1186  };
1187  class shared_data
1188  {
1189  public:
1190  	nano::test::counted_completion write_completion{ 0 };
1191  	std::atomic<bool> done{ false };
1192  };
1193  template <typename T>
1194  void callback_process (shared_data & shared_data_a, data & data, T & all_node_data_a, std::chrono::system_clock::time_point last_updated)
1195  {
1196  	if (!data.orig_time_set.test_and_set ())
1197  	{
1198  		data.orig_time = last_updated;
1199  	}
1200  	if (data.awaiting_cache && data.orig_time != last_updated)
1201  	{
1202  		data.keep_requesting_metrics = false;
1203  	}
1204  	if (data.orig_time != last_updated)
1205  	{
1206  		data.awaiting_cache = true;
1207  		data.orig_time = last_updated;
1208  	}
1209  	shared_data_a.write_completion.increment ();
1210  };
1211  }
1212  TEST (telemetry, ongoing_requests)
1213  {
1214  	nano::test::system system;
1215  	nano::node_flags node_flags;
1216  	auto node_client = system.add_node (node_flags);
1217  	auto node_server = system.add_node (node_flags);
1218  	nano::test::wait_peer_connections (system);
1219  	ASSERT_EQ (0, node_client->telemetry.size ());
1220  	ASSERT_EQ (0, node_server->telemetry.size ());
1221  	ASSERT_EQ (0, node_client->stats.count (nano::stat::type::bootstrap, nano::stat::detail::telemetry_ack, nano::stat::dir::in));
1222  	ASSERT_EQ (0, node_client->stats.count (nano::stat::type::bootstrap, nano::stat::detail::telemetry_req, nano::stat::dir::out));
1223  	ASSERT_TIMELY (20s, node_client->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_ack, nano::stat::dir::in) == 1 && node_server->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_ack, nano::stat::dir::in) == 1);
1224  	auto time = std::chrono::steady_clock::now ();
1225  	ASSERT_TIMELY (10s, std::chrono::steady_clock::now () >= (time + nano::dev::network_params.network.telemetry_cache_cutoff + 1s));
1226  	ASSERT_EQ (2, node_client->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_ack, nano::stat::dir::in));
1227  	ASSERT_EQ (2, node_client->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::in));
1228  	ASSERT_EQ (2, node_client->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::out));
1229  	ASSERT_EQ (2, node_server->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_ack, nano::stat::dir::in));
1230  	ASSERT_EQ (2, node_server->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::in));
1231  	ASSERT_EQ (2, node_server->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::out));
1232  }
1233  namespace nano
1234  {
1235  namespace transport
1236  {
1237  	TEST (telemetry, simultaneous_requests)
1238  	{
1239  		nano::test::system system;
1240  		nano::node_flags node_flags;
1241  		auto const num_nodes = 4;
1242  		for (int i = 0; i < num_nodes; ++i)
1243  		{
1244  			system.add_node (node_flags);
1245  		}
1246  		nano::test::wait_peer_connections (system);
1247  		std::vector<std::thread> threads;
1248  		auto const num_threads = 4;
1249  		std::array<data, num_nodes> node_data{};
1250  		for (auto i = 0; i < num_nodes; ++i)
1251  		{
1252  			node_data[i].node = system.nodes[i];
1253  		}
1254  		shared_data shared_data;
1255  		for (int i = 0; i < num_threads; ++i)
1256  		{
1257  			threads.emplace_back ([&node_data, &shared_data] () {
1258  				while (std::any_of (node_data.cbegin (), node_data.cend (), [] (auto const & data) { return data.keep_requesting_metrics.load (); }))
1259  				{
1260  					for (auto & data : node_data)
1261  					{
1262  						if (data.keep_requesting_metrics)
1263  						{
1264  							shared_data.write_completion.increment_required_count ();
1265  							auto peer = data.node->network.tcp_channels.channels[0].channel;
1266  							auto maybe_telemetry = data.node->telemetry.get_telemetry (peer->get_endpoint ());
1267  							if (maybe_telemetry)
1268  							{
1269  								callback_process (shared_data, data, node_data, maybe_telemetry->timestamp);
1270  							}
1271  						}
1272  						std::this_thread::sleep_for (1ms);
1273  					}
1274  				}
1275  				shared_data.write_completion.await_count_for (20s);
1276  				shared_data.done = true;
1277  			});
1278  		}
1279  		ASSERT_TIMELY (30s, shared_data.done);
1280  		ASSERT_TRUE (std::all_of (node_data.begin (), node_data.end (), [] (auto const & data) { return !data.keep_requesting_metrics; }));
1281  		for (auto & thread : threads)
1282  		{
1283  			thread.join ();
1284  		}
1285  	}
1286  }
1287  }
1288  TEST (telemetry, under_load)
1289  {
1290  	nano::test::system system;
1291  	nano::node_config node_config = system.default_config ();
1292  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1293  	nano::node_flags node_flags;
1294  	auto node = system.add_node (node_config, node_flags);
1295  	node_config.peering_port = system.get_available_port ();
1296  	auto node1 = system.add_node (node_config, node_flags);
1297  	nano::keypair key;
1298  	nano::keypair key1;
1299  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
1300  	system.wallet (0)->insert_adhoc (key.prv);
1301  	auto latest_genesis = node->latest (nano::dev::genesis_key.pub);
1302  	auto num_blocks = 150000;
1303  	nano::block_builder builder;
1304  	auto send = builder
1305  				.state ()
1306  				.account (nano::dev::genesis_key.pub)
1307  				.previous (latest_genesis)
1308  				.representative (nano::dev::genesis_key.pub)
1309  				.balance (nano::dev::constants.genesis_amount - num_blocks)
1310  				.link (key.pub)
1311  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1312  				.work (*system.work.generate (latest_genesis))
1313  				.build_shared ();
1314  	node->process_active (send);
1315  	latest_genesis = send->hash ();
1316  	auto open = builder
1317  				.state ()
1318  				.account (key.pub)
1319  				.previous (0)
1320  				.representative (key.pub)
1321  				.balance (num_blocks)
1322  				.link (send->hash ())
1323  				.sign (key.prv, key.pub)
1324  				.work (*system.work.generate (key.pub))
1325  				.build_shared ();
1326  	node->process_active (open);
1327  	auto latest_key = open->hash ();
1328  	auto thread_func = [key1, &system, node, num_blocks] (nano::keypair const & keypair, nano::block_hash const & latest, nano::uint128_t const initial_amount) {
1329  		auto latest_l = latest;
1330  		nano::block_builder builder;
1331  		for (int i = 0; i < num_blocks; ++i)
1332  		{
1333  			auto send = builder
1334  						.state ()
1335  						.account (keypair.pub)
1336  						.previous (latest_l)
1337  						.representative (keypair.pub)
1338  						.balance (initial_amount - i - 1)
1339  						.link (key1.pub)
1340  						.sign (keypair.prv, keypair.pub)
1341  						.work (*system.work.generate (latest_l))
1342  						.build_shared ();
1343  			latest_l = send->hash ();
1344  			node->process_active (send);
1345  		}
1346  	};
1347  	std::thread thread1 (thread_func, nano::dev::genesis_key, latest_genesis, nano::dev::constants.genesis_amount - num_blocks);
1348  	std::thread thread2 (thread_func, key, latest_key, num_blocks);
1349  	ASSERT_TIMELY (200s, node1->ledger.cache.block_count == num_blocks * 2 + 3);
1350  	thread1.join ();
1351  	thread2.join ();
1352  	for (auto const & node : system.nodes)
1353  	{
1354  		ASSERT_EQ (0, node->stats.count (nano::stat::type::telemetry, nano::stat::detail::failed_send_telemetry_req));
1355  		ASSERT_EQ (0, node->stats.count (nano::stat::type::telemetry, nano::stat::detail::request_within_protection_cache_zone));
1356  		ASSERT_EQ (0, node->stats.count (nano::stat::type::telemetry, nano::stat::detail::unsolicited_telemetry_ack));
1357  		ASSERT_EQ (0, node->stats.count (nano::stat::type::telemetry, nano::stat::detail::no_response_received));
1358  	}
1359  }
1360  TEST (telemetry, cache_read_and_timeout)
1361  {
1362  	nano::test::system system;
1363  	nano::node_flags node_flags;
1364  	node_flags.disable_ongoing_telemetry_requests = true;
1365  	auto node_client = system.add_node (node_flags);
1366  	auto node_server = system.add_node (node_flags);
1367  	nano::test::wait_peer_connections (system);
1368  	std::optional<nano::telemetry_data> telemetry_data;
1369  	auto channel = node_client->network.find_node_id (node_server->get_node_id ());
1370  	ASSERT_NE (channel, nullptr);
1371  	node_client->telemetry.trigger ();
1372  	ASSERT_TIMELY (5s, telemetry_data = node_client->telemetry.get_telemetry (channel->get_endpoint ()));
1373  	auto responses = node_client->telemetry.get_all_telemetries ();
1374  	ASSERT_TRUE (!responses.empty ());
1375  	ASSERT_EQ (telemetry_data, responses.begin ()->second);
1376  	ASSERT_EQ (1, node_client->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_ack, nano::stat::dir::in));
1377  	ASSERT_EQ (0, node_client->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::in));
1378  	ASSERT_EQ (1, node_client->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::out));
1379  	ASSERT_EQ (0, node_server->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_ack, nano::stat::dir::in));
1380  	ASSERT_EQ (1, node_server->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::in));
1381  	ASSERT_EQ (0, node_server->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::out));
1382  	ASSERT_TIMELY (5s, node_client->telemetry.get_all_telemetries ().empty ());
1383  	responses = node_client->telemetry.get_all_telemetries ();
1384  	ASSERT_TRUE (responses.empty ());
1385  	node_client->telemetry.trigger ();
1386  	ASSERT_TIMELY (5s, telemetry_data = node_client->telemetry.get_telemetry (channel->get_endpoint ()));
1387  	responses = node_client->telemetry.get_all_telemetries ();
1388  	ASSERT_TRUE (!responses.empty ());
1389  	ASSERT_EQ (telemetry_data, responses.begin ()->second);
1390  	ASSERT_EQ (2, node_client->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_ack, nano::stat::dir::in));
1391  	ASSERT_EQ (0, node_client->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::in));
1392  	ASSERT_EQ (2, node_client->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::out));
1393  	ASSERT_EQ (0, node_server->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_ack, nano::stat::dir::in));
1394  	ASSERT_EQ (2, node_server->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::in));
1395  	ASSERT_EQ (0, node_server->stats.count (nano::stat::type::message, nano::stat::detail::telemetry_req, nano::stat::dir::out));
1396  }
1397  TEST (telemetry, many_nodes)
1398  {
1399  	nano::test::system system;
1400  	nano::node_flags node_flags;
1401  	node_flags.disable_request_loop = true;
1402  	auto const num_nodes = nano::memory_intensive_instrumentation () ? 4 : 10;
1403  	for (auto i = 0; i < num_nodes; ++i)
1404  	{
1405  		nano::node_config node_config = system.default_config ();
1406  		node_config.bandwidth_limit = 100000 + i;
1407  		auto node = std::make_shared<nano::node> (system.io_ctx, nano::unique_path (), node_config, system.work, node_flags);
1408  		node->start ();
1409  		system.nodes.push_back (node);
1410  	}
1411  	for (auto const & node : system.nodes)
1412  	{
1413  		for (auto const & other_node : system.nodes)
1414  		{
1415  			if (node != other_node)
1416  			{
1417  				node->network.merge_peer (other_node->network.endpoint ());
1418  			}
1419  		}
1420  	}
1421  	nano::test::wait_peer_connections (system);
1422  	nano::keypair key;
1423  	nano::block_builder builder;
1424  	auto send = builder
1425  				.state ()
1426  				.account (nano::dev::genesis_key.pub)
1427  				.previous (nano::dev::genesis->hash ())
1428  				.representative (nano::dev::genesis_key.pub)
1429  				.balance (nano::dev::constants.genesis_amount - nano::Mxrb_ratio)
1430  				.link (key.pub)
1431  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1432  				.work (*system.work.generate (nano::dev::genesis->hash ()))
1433  				.build ();
1434  	for (auto node : system.nodes)
1435  	{
1436  		auto transaction (node->store.tx_begin_write ());
1437  		ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *send).code);
1438  	}
1439  	auto node_client = system.nodes.front ();
1440  	std::vector<nano::telemetry_data> telemetry_datas;
1441  	auto peers = node_client->network.list (num_nodes - 1);
1442  	ASSERT_EQ (peers.size (), num_nodes - 1);
1443  	for (auto const & peer : peers)
1444  	{
1445  		std::optional<nano::telemetry_data> telemetry_data;
1446  		ASSERT_TIMELY (5s, telemetry_data = node_client->telemetry.get_telemetry (peer->get_endpoint ()));
1447  		telemetry_datas.push_back (*telemetry_data);
1448  	}
1449  	ASSERT_EQ (telemetry_datas.size (), num_nodes - 1);
1450  	for (auto & data : telemetry_datas)
1451  	{
1452  		ASSERT_EQ (data.unchecked_count, 0);
1453  		ASSERT_EQ (data.cemented_count, 1);
1454  		ASSERT_LE (data.peer_count, 9U);
1455  		ASSERT_EQ (data.account_count, 1);
1456  		ASSERT_TRUE (data.block_count == 2);
1457  		ASSERT_EQ (data.protocol_version, nano::dev::network_params.network.protocol_version);
1458  		ASSERT_GE (data.bandwidth_cap, 100000);
1459  		ASSERT_LT (data.bandwidth_cap, 100000 + system.nodes.size ());
1460  		ASSERT_EQ (data.major_version, nano::get_major_node_version ());
1461  		ASSERT_EQ (data.minor_version, nano::get_minor_node_version ());
1462  		ASSERT_EQ (data.patch_version, nano::get_patch_node_version ());
1463  		ASSERT_EQ (data.pre_release_version, nano::get_pre_release_node_version ());
1464  		ASSERT_EQ (data.maker, 0);
1465  		ASSERT_LT (data.uptime, 100);
1466  		ASSERT_EQ (data.genesis_block, nano::dev::genesis->hash ());
1467  		ASSERT_LE (data.timestamp, std::chrono::system_clock::now ());
1468  		ASSERT_EQ (data.active_difficulty, system.nodes.front ()->default_difficulty (nano::work_version::work_1));
1469  	}
1470  	auto bandwidth_cap = telemetry_datas.front ().bandwidth_cap;
1471  	telemetry_datas.erase (telemetry_datas.begin ());
1472  	auto all_bandwidth_limits_same = std::all_of (telemetry_datas.begin (), telemetry_datas.end (), [bandwidth_cap] (auto & telemetry_data) {
1473  		return telemetry_data.bandwidth_cap == bandwidth_cap;
1474  	});
1475  	ASSERT_FALSE (all_bandwidth_limits_same);
1476  }
1477  TEST (signature_checker, mass_boundary_checks)
1478  {
1479  	std::vector<size_t> sizes{ 0, 1 };
1480  	auto add_boundary = [&sizes] (size_t boundary) {
1481  		sizes.insert (sizes.end (), { boundary - 1, boundary, boundary + 1 });
1482  	};
1483  	for (auto i = 1; i <= 10; ++i)
1484  	{
1485  		add_boundary (nano::signature_checker::batch_size * i);
1486  	}
1487  	nano::block_builder builder;
1488  	for (auto num_threads = 0; num_threads < 5; ++num_threads)
1489  	{
1490  		nano::signature_checker checker (num_threads);
1491  		auto max_size = *(sizes.end () - 1);
1492  		std::vector<nano::uint256_union> hashes;
1493  		hashes.reserve (max_size);
1494  		std::vector<unsigned char const *> messages;
1495  		messages.reserve (max_size);
1496  		std::vector<size_t> lengths;
1497  		lengths.reserve (max_size);
1498  		std::vector<unsigned char const *> pub_keys;
1499  		pub_keys.reserve (max_size);
1500  		std::vector<unsigned char const *> signatures;
1501  		signatures.reserve (max_size);
1502  		nano::keypair key;
1503  		auto block = builder
1504  					 .state ()
1505  					 .account (key.pub)
1506  					 .previous (0)
1507  					 .representative (key.pub)
1508  					 .balance (0)
1509  					 .link (0)
1510  					 .sign (key.prv, key.pub)
1511  					 .work (0)
1512  					 .build ();
1513  		size_t last_size = 0;
1514  		for (auto size : sizes)
1515  		{
1516  			auto extra_size = size - last_size;
1517  			std::vector<int> verifications;
1518  			verifications.resize (size);
1519  			for (auto i (0); i < extra_size; ++i)
1520  			{
1521  				hashes.push_back (block->hash ());
1522  				messages.push_back (hashes.back ().bytes.data ());
1523  				lengths.push_back (sizeof (decltype (hashes)::value_type));
1524  				pub_keys.push_back (block->hashables.account.bytes.data ());
1525  				signatures.push_back (block->signature.bytes.data ());
1526  			}
1527  			nano::signature_check_set check = { size, messages.data (), lengths.data (), pub_keys.data (), signatures.data (), verifications.data () };
1528  			checker.verify (check);
1529  			bool all_valid = std::all_of (verifications.cbegin (), verifications.cend (), [] (auto verification) { return verification == 1; });
1530  			ASSERT_TRUE (all_valid);
1531  			last_size = size;
1532  		}
1533  	}
1534  }
1535  TEST (node, mass_epoch_upgrader)
1536  {
1537  	auto perform_test = [] (size_t const batch_size) {
1538  		unsigned threads = 5;
1539  		size_t total_accounts = 2500;
1540  #ifndef NDEBUG
1541  		total_accounts /= 5;
1542  #endif
1543  		struct info
1544  		{
1545  			nano::keypair key;
1546  			nano::block_hash pending_hash;
1547  		};
1548  		std::vector<info> opened (total_accounts / 2);
1549  		std::vector<info> unopened (total_accounts / 2);
1550  		nano::test::system system;
1551  		nano::node_config node_config = system.default_config ();
1552  		node_config.work_threads = 4;
1553  		auto & node = *system.add_node (node_config);
1554  		auto balance = node.balance (nano::dev::genesis_key.pub);
1555  		auto latest = node.latest (nano::dev::genesis_key.pub);
1556  		nano::uint128_t amount = 1;
1557  		std::array<std::vector<info> *, 2> all{ &opened, &unopened };
1558  		for (auto & accounts : all)
1559  		{
1560  			for (auto & info : *accounts)
1561  			{
1562  				balance -= amount;
1563  				nano::state_block_builder builder;
1564  				std::error_code ec;
1565  				auto block = builder
1566  							 .account (nano::dev::genesis_key.pub)
1567  							 .previous (latest)
1568  							 .balance (balance)
1569  							 .link (info.key.pub)
1570  							 .representative (nano::dev::genesis_key.pub)
1571  							 .sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1572  							 .work (*node.work_generate_blocking (latest, node_config.network_params.work.threshold (nano::work_version::work_1, nano::block_details (nano::epoch::epoch_0, false, false, false))))
1573  							 .build (ec);
1574  				ASSERT_FALSE (ec);
1575  				ASSERT_NE (nullptr, block);
1576  				ASSERT_EQ (nano::process_result::progress, node.process (*block).code);
1577  				latest = block->hash ();
1578  				info.pending_hash = block->hash ();
1579  			}
1580  		}
1581  		ASSERT_EQ (1 + total_accounts, node.ledger.cache.block_count);
1582  		ASSERT_EQ (1, node.ledger.cache.account_count);
1583  		for (auto const & info : opened)
1584  		{
1585  			nano::state_block_builder builder;
1586  			std::error_code ec;
1587  			auto block = builder
1588  						 .account (info.key.pub)
1589  						 .previous (0)
1590  						 .balance (amount)
1591  						 .link (info.pending_hash)
1592  						 .representative (info.key.pub)
1593  						 .sign (info.key.prv, info.key.pub)
1594  						 .work (*node.work_generate_blocking (info.key.pub, node_config.network_params.work.threshold (nano::work_version::work_1, nano::block_details (nano::epoch::epoch_0, false, false, false))))
1595  						 .build (ec);
1596  			ASSERT_FALSE (ec);
1597  			ASSERT_NE (nullptr, block);
1598  			ASSERT_EQ (nano::process_result::progress, node.process (*block).code);
1599  		}
1600  		ASSERT_EQ (1 + total_accounts + opened.size (), node.ledger.cache.block_count);
1601  		ASSERT_EQ (1 + opened.size (), node.ledger.cache.account_count);
1602  		nano::keypair epoch_signer (nano::dev::genesis_key);
1603  		auto const block_count_before = node.ledger.cache.block_count.load ();
1604  		auto const total_to_upgrade = 1 + total_accounts;
1605  		std::cout << "Mass upgrading " << total_to_upgrade << " accounts" << std::endl;
1606  		while (node.ledger.cache.block_count != block_count_before + total_to_upgrade)
1607  		{
1608  			auto const pre_upgrade = node.ledger.cache.block_count.load ();
1609  			auto upgrade_count = std::min<size_t> (batch_size, block_count_before + total_to_upgrade - pre_upgrade);
1610  			ASSERT_FALSE (node.epoch_upgrader.start (epoch_signer.prv, nano::epoch::epoch_1, upgrade_count, threads));
1611  			ASSERT_TRUE (node.epoch_upgrader.start (epoch_signer.prv, nano::epoch::epoch_1, upgrade_count, threads));
1612  			system.deadline_set (60s);
1613  			while (node.ledger.cache.block_count != pre_upgrade + upgrade_count)
1614  			{
1615  				ASSERT_NO_ERROR (system.poll ());
1616  				std::this_thread::sleep_for (200ms);
1617  				std::cout << node.ledger.cache.block_count - block_count_before << " / " << total_to_upgrade << std::endl;
1618  			}
1619  			std::this_thread::sleep_for (50ms);
1620  		}
1621  		auto expected_blocks = block_count_before + total_accounts + 1;
1622  		ASSERT_EQ (expected_blocks, node.ledger.cache.block_count);
1623  		{
1624  			auto transaction (node.store.tx_begin_read ());
1625  			size_t block_count_sum = 0;
1626  			for (auto i (node.store.account.begin (transaction)); i != node.store.account.end (); ++i)
1627  			{
1628  				nano::account_info info (i->second);
1629  				ASSERT_EQ (info.epoch (), nano::epoch::epoch_1);
1630  				block_count_sum += info.block_count;
1631  			}
1632  			ASSERT_EQ (expected_blocks, block_count_sum);
1633  		}
1634  	};
1635  	perform_test (42);
1636  	perform_test (std::numeric_limits<size_t>::max ());
1637  }
1638  namespace nano
1639  {
1640  TEST (node, mass_block_new)
1641  {
1642  	nano::test::system system;
1643  	nano::node_config node_config = system.default_config ();
1644  	node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1645  	auto & node = *system.add_node (node_config);
1646  	node.network_params.network.aec_loop_interval_ms = 500;
1647  #ifndef NDEBUG
1648  	auto const num_blocks = 5000;
1649  #else
1650  	auto const num_blocks = 50000;
1651  #endif
1652  	std::cout << num_blocks << " x4 blocks" << std::endl;
1653  	system.upgrade_genesis_epoch (node, nano::epoch::epoch_1);
1654  	system.upgrade_genesis_epoch (node, nano::epoch::epoch_2);
1655  	auto next_block_count = num_blocks + 3;
1656  	auto process_all = [&] (std::vector<std::shared_ptr<nano::state_block>> const & blocks_a) {
1657  		for (auto const & block : blocks_a)
1658  		{
1659  			node.process_active (block);
1660  		}
1661  		ASSERT_TIMELY (200s, node.ledger.cache.block_count == next_block_count);
1662  		next_block_count += num_blocks;
1663  		node.block_processor.flush ();
1664  		{
1665  			nano::lock_guard<nano::mutex> guard{ node.active.mutex };
1666  			node.active.roots.clear ();
1667  			node.active.blocks.clear ();
1668  		}
1669  	};
1670  	nano::keypair key;
1671  	std::vector<nano::keypair> keys (num_blocks);
1672  	nano::state_block_builder builder;
1673  	std::vector<std::shared_ptr<nano::state_block>> send_blocks;
1674  	auto send_threshold (nano::dev::network_params.work.threshold (nano::work_version::work_1, nano::block_details (nano::epoch::epoch_2, true, false, false)));
1675  	auto latest_genesis = node.latest (nano::dev::genesis_key.pub);
1676  	for (auto i = 0; i < num_blocks; ++i)
1677  	{
1678  		auto send = builder.make_block ()
1679  					.account (nano::dev::genesis_key.pub)
1680  					.previous (latest_genesis)
1681  					.balance (nano::dev::constants.genesis_amount - i - 1)
1682  					.representative (nano::dev::genesis_key.pub)
1683  					.link (keys[i].pub)
1684  					.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1685  					.work (*system.work.generate (nano::work_version::work_1, latest_genesis, send_threshold))
1686  					.build ();
1687  		latest_genesis = send->hash ();
1688  		send_blocks.push_back (std::move (send));
1689  	}
1690  	std::cout << "Send blocks built, start processing" << std::endl;
1691  	nano::timer<> timer;
1692  	timer.start ();
1693  	process_all (send_blocks);
1694  	std::cout << "Send blocks time: " << timer.stop ().count () << " " << timer.unit () << "\n\n";
1695  	std::vector<std::shared_ptr<nano::state_block>> open_blocks;
1696  	auto receive_threshold (nano::dev::network_params.work.threshold (nano::work_version::work_1, nano::block_details (nano::epoch::epoch_2, false, true, false)));
1697  	for (auto i = 0; i < num_blocks; ++i)
1698  	{
1699  		auto const & key = keys[i];
1700  		auto open = builder.make_block ()
1701  					.account (key.pub)
1702  					.previous (0)
1703  					.balance (1)
1704  					.representative (key.pub)
1705  					.link (send_blocks[i]->hash ())
1706  					.sign (key.prv, key.pub)
1707  					.work (*system.work.generate (nano::work_version::work_1, key.pub, receive_threshold))
1708  					.build ();
1709  		open_blocks.push_back (std::move (open));
1710  	}
1711  	std::cout << "Open blocks built, start processing" << std::endl;
1712  	timer.restart ();
1713  	process_all (open_blocks);
1714  	std::cout << "Open blocks time: " << timer.stop ().count () << " " << timer.unit () << "\n\n";
1715  	std::vector<std::shared_ptr<nano::state_block>> send_blocks2;
1716  	for (auto i = 0; i < num_blocks; ++i)
1717  	{
1718  		auto const & key = keys[i];
1719  		auto const & latest = open_blocks[i];
1720  		auto send2 = builder.make_block ()
1721  					 .account (key.pub)
1722  					 .previous (latest->hash ())
1723  					 .balance (0)
1724  					 .representative (key.pub)
1725  					 .link (key.pub)
1726  					 .sign (key.prv, key.pub)
1727  					 .work (*system.work.generate (nano::work_version::work_1, latest->hash (), send_threshold))
1728  					 .build ();
1729  		send_blocks2.push_back (std::move (send2));
1730  	}
1731  	std::cout << "Send2 blocks built, start processing" << std::endl;
1732  	timer.restart ();
1733  	process_all (send_blocks2);
1734  	std::cout << "Send2 blocks time: " << timer.stop ().count () << " " << timer.unit () << "\n\n";
1735  	std::vector<std::shared_ptr<nano::state_block>> receive_blocks;
1736  	for (auto i = 0; i < num_blocks; ++i)
1737  	{
1738  		auto const & key = keys[i];
1739  		auto const & latest = send_blocks2[i];
1740  		auto send2 = builder.make_block ()
1741  					 .account (key.pub)
1742  					 .previous (latest->hash ())
1743  					 .balance (1)
1744  					 .representative (key.pub)
1745  					 .link (latest->hash ())
1746  					 .sign (key.prv, key.pub)
1747  					 .work (*system.work.generate (nano::work_version::work_1, latest->hash (), receive_threshold))
1748  					 .build ();
1749  		receive_blocks.push_back (std::move (send2));
1750  	}
1751  	std::cout << "Receive blocks built, start processing" << std::endl;
1752  	timer.restart ();
1753  	process_all (receive_blocks);
1754  	std::cout << "Receive blocks time: " << timer.stop ().count () << " " << timer.unit () << "\n\n";
1755  }
1756  TEST (node, aggressive_flooding)
1757  {
1758  	nano::test::system system;
1759  	nano::node_flags node_flags;
1760  	node_flags.disable_request_loop = true;
1761  	node_flags.disable_bootstrap_bulk_push_client = true;
1762  	node_flags.disable_bootstrap_bulk_pull_server = true;
1763  	node_flags.disable_bootstrap_listener = true;
1764  	node_flags.disable_lazy_bootstrap = true;
1765  	node_flags.disable_legacy_bootstrap = true;
1766  	node_flags.disable_wallet_bootstrap = true;
1767  	node_flags.disable_ascending_bootstrap = true;
1768  	auto & node1 (*system.add_node (node_flags));
1769  	auto & wallet1 (*system.wallet (0));
1770  	wallet1.insert_adhoc (nano::dev::genesis_key.prv);
1771  	std::vector<std::pair<std::shared_ptr<nano::node>, std::shared_ptr<nano::wallet>>> nodes_wallets;
1772  	nodes_wallets.resize (!nano::memory_intensive_instrumentation () ? 5 : 3);
1773  	std::generate (nodes_wallets.begin (), nodes_wallets.end (), [&system, node_flags] () {
1774  		nano::node_config node_config = system.default_config ();
1775  		auto node (system.add_node (node_config, node_flags));
1776  		return std::make_pair (node, system.wallet (system.nodes.size () - 1));
1777  	});
1778  	ASSERT_TIMELY (5s, node1.network.size () == nodes_wallets.size ());
1779  	ASSERT_LT (node1.network.fanout (), nodes_wallets.size ());
1780  	ASSERT_TIMELY (10s, std::all_of (nodes_wallets.begin (), nodes_wallets.end (), [] (auto const & node_wallet) { return node_wallet.first->rep_crawler.principal_representatives ().size () != 0; }));
1781  	auto large_amount = (nano::dev::constants.genesis_amount / 2) / nodes_wallets.size ();
1782  	std::vector<std::shared_ptr<nano::block>> genesis_blocks;
1783  	for (auto & node_wallet : nodes_wallets)
1784  	{
1785  		nano::keypair keypair;
1786  		node_wallet.second->store.representative_set (node_wallet.first->wallets.tx_begin_write (), keypair.pub);
1787  		node_wallet.second->insert_adhoc (keypair.prv);
1788  		auto block (wallet1.send_action (nano::dev::genesis_key.pub, keypair.pub, large_amount));
1789  		ASSERT_NE (nullptr, block);
1790  		genesis_blocks.push_back (block);
1791  	}
1792  	for (auto & node_wallet : nodes_wallets)
1793  	{
1794  		for (auto const & block : genesis_blocks)
1795  		{
1796  			auto process_result (node_wallet.first->process (*block));
1797  			ASSERT_TRUE (nano::process_result::progress == process_result.code || nano::process_result::old == process_result.code);
1798  		}
1799  		ASSERT_EQ (node1.latest (nano::dev::genesis_key.pub), node_wallet.first->latest (nano::dev::genesis_key.pub));
1800  		ASSERT_EQ (genesis_blocks.back ()->hash (), node_wallet.first->latest (nano::dev::genesis_key.pub));
1801  		nano::test::start_elections (system, *node_wallet.first, { genesis_blocks.back () }, true);
1802  	}
1803  	nano::test::start_elections (system, node1, { genesis_blocks.back () }, true);
1804  	auto all_received = [&nodes_wallets] () {
1805  		return std::all_of (nodes_wallets.begin (), nodes_wallets.end (), [] (auto const & node_wallet) {
1806  			auto local_representative (node_wallet.second->store.representative (node_wallet.first->wallets.tx_begin_read ()));
1807  			return node_wallet.first->ledger.account_balance (node_wallet.first->store.tx_begin_read (), local_representative) > 0;
1808  		});
1809  	};
1810  	ASSERT_TIMELY (!nano::slow_instrumentation () ? 10s : 40s, all_received ());
1811  	ASSERT_TIMELY (!nano::slow_instrumentation () ? 10s : 40s, node1.ledger.cache.block_count == 1 + 2 * nodes_wallets.size ());
1812  	ASSERT_TIMELY (!nano::slow_instrumentation () ? 10s : 40s, node1.rep_crawler.principal_representatives ().size () == nodes_wallets.size ());
1813  	nano::state_block_builder builder;
1814  	std::shared_ptr<nano::state_block> block{};
1815  	{
1816  		auto transaction (node1.store.tx_begin_read ());
1817  		block = builder.make_block ()
1818  				.account (nano::dev::genesis_key.pub)
1819  				.representative (nano::dev::genesis_key.pub)
1820  				.previous (node1.ledger.latest (transaction, nano::dev::genesis_key.pub))
1821  				.balance (node1.ledger.account_balance (transaction, nano::dev::genesis_key.pub) - 1)
1822  				.link (nano::dev::genesis_key.pub)
1823  				.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1824  				.work (*node1.work_generate_blocking (node1.ledger.latest (transaction, nano::dev::genesis_key.pub)))
1825  				.build ();
1826  	}
1827  	ASSERT_EQ (nano::process_result::progress, node1.process_local (block).value ().code);
1828  	auto all_have_block = [&nodes_wallets] (nano::block_hash const & hash_a) {
1829  		return std::all_of (nodes_wallets.begin (), nodes_wallets.end (), [hash = hash_a] (auto const & node_wallet) {
1830  			return node_wallet.first->block (hash) != nullptr;
1831  		});
1832  	};
1833  	ASSERT_TIMELY (!nano::slow_instrumentation () ? 5s : 25s, all_have_block (block->hash ()));
1834  	auto wallet_block = wallet1.send_sync (nano::dev::genesis_key.pub, nano::dev::genesis_key.pub, 10);
1835  	ASSERT_TIMELY (!nano::slow_instrumentation () ? 5s : 25s, all_have_block (wallet_block));
1836  	ASSERT_EQ (1 + 2 * nodes_wallets.size () + 2, node1.ledger.cache.block_count);
1837  }
1838  TEST (node, send_single_many_peers)
1839  {
1840  	nano::test::system system (nano::memory_intensive_instrumentation () ? 4 : 10);
1841  	nano::keypair key2;
1842  	system.wallet (0)->insert_adhoc (nano::dev::genesis_key.prv);
1843  	system.wallet (1)->insert_adhoc (key2.prv);
1844  	ASSERT_NE (nullptr, system.wallet (0)->send_action (nano::dev::genesis_key.pub, key2.pub, system.nodes[0]->config.receive_minimum.number ()));
1845  	ASSERT_EQ (std::numeric_limits<nano::uint128_t>::max () - system.nodes[0]->config.receive_minimum.number (), system.nodes[0]->balance (nano::dev::genesis_key.pub));
1846  	ASSERT_TRUE (system.nodes[0]->balance (key2.pub).is_zero ());
1847  	ASSERT_TIMELY (3.5min, std::all_of (system.nodes.begin (), system.nodes.end (), [&] (std::shared_ptr<nano::node> const & node_a) { return !node_a->balance (key2.pub).is_zero (); }));
1848  	system.stop ();
1849  	for (auto node : system.nodes)
1850  	{
1851  		ASSERT_TRUE (node->stopped);
1852  	}
1853  }
1854  }
1855  TEST (node, wallet_create_block_confirm_conflicts)
1856  {
1857  	for (int i = 0; i < 5; ++i)
1858  	{
1859  		nano::test::system system;
1860  		nano::block_builder builder;
1861  		nano::node_config node_config (system.get_available_port (), system.logging);
1862  		node_config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1863  		auto node = system.add_node (node_config);
1864  		auto const num_blocks = 10000;
1865  		auto latest = nano::dev::genesis->hash ();
1866  		nano::keypair key1;
1867  		{
1868  			auto transaction = node->store.tx_begin_write ();
1869  			for (auto i = num_blocks - 1; i > 0; --i)
1870  			{
1871  				auto send = builder
1872  							.send ()
1873  							.previous (latest)
1874  							.destination (key1.pub)
1875  							.balance (nano::dev::constants.genesis_amount - nano::Gxrb_ratio + i + 1)
1876  							.sign (nano::dev::genesis_key.prv, nano::dev::genesis_key.pub)
1877  							.work (*system.work.generate (latest))
1878  							.build ();
1879  				ASSERT_EQ (nano::process_result::progress, node->ledger.process (transaction, *send).code);
1880  				latest = send->hash ();
1881  			}
1882  		}
1883  		std::atomic<bool> done{ false };
1884  		std::thread t ([node, &done] () {
1885  			while (!done)
1886  			{
1887  				node->wallets.create (nano::random_wallet_id ());
1888  			}
1889  		});
1890  		{
1891  			auto block = node->store.block.get (node->store.tx_begin_read (), latest);
1892  			node->scheduler.buckets.manual (block);
1893  			std::shared_ptr<nano::election> election;
1894  			ASSERT_TIMELY (10s, (election = node->active.election (block->qualified_root ())) != nullptr);
1895  			election->force_confirm ();
1896  		}
1897  		ASSERT_TIMELY (120s, node->ledger.block_confirmed (node->store.tx_begin_read (), latest) && node->confirmation_height_processor.current () == 0);
1898  		done = true;
1899  		t.join ();
1900  	}
1901  }
1902  namespace nano
1903  {
1904  TEST (system, block_sequence)
1905  {
1906  	size_t const block_count = 400;
1907  	size_t const pr_count = 4;
1908  	size_t const listeners_per_pr = 0;
1909  	nano::test::system system;
1910  	std::vector<nano::keypair> reps;
1911  	for (auto i = 0; i < pr_count; ++i)
1912  	{
1913  		reps.push_back (nano::keypair{});
1914  	}
1915  	system.ledger_initialization_set (reps, nano::Gxrb_ratio);
1916  	system.deadline_set (3600s);
1917  	nano::node_config config;
1918  	config.peering_port = system.get_available_port ();
1919  	config.enable_voting = true;
1920  	config.frontiers_confirmation = nano::frontiers_confirmation_mode::disabled;
1921  	nano::node_flags flags;
1922  	flags.disable_max_peers_per_ip = true;
1923  	flags.disable_ongoing_bootstrap = true;
1924  	auto root = system.add_node (config, flags);
1925  	auto wallet = root->wallets.items.begin ()->second;
1926  	wallet->insert_adhoc (nano::dev::genesis_key.prv);
1927  	for (auto rep : reps)
1928  	{
1929  		system.wallet (0);
1930  		config.peering_port = system.get_available_port ();
1931  		auto pr = system.add_node (config, flags, nano::transport::transport_type::tcp, rep);
1932  		for (auto j = 0; j < listeners_per_pr; ++j)
1933  		{
1934  			config.peering_port = system.get_available_port ();
1935  			system.add_node (config, flags);
1936  		}
1937  		std::cerr << rep.pub.to_account () << ' ' << pr->wallets.items.begin ()->second->exists (rep.pub) << pr->weight (rep.pub) << ' ' << '\n';
1938  	}
1939  	while (std::any_of (system.nodes.begin (), system.nodes.end (), [] (std::shared_ptr<nano::node> const & node) {
1940  		return node->rep_crawler.representative_count () < 3;
1941  	}))
1942  	{
1943  		system.poll ();
1944  	}
1945  	for (auto & node : system.nodes)
1946  	{
1947  		std::cerr << std::to_string (node->network.port) << ": ";
1948  		auto prs = node->rep_crawler.principal_representatives ();
1949  		for (auto pr : prs)
1950  		{
1951  			std::cerr << pr.account.to_account () << ' ';
1952  		}
1953  		std::cerr << '\n';
1954  	}
1955  	nano::keypair key;
1956  	auto start = std::chrono::system_clock::now ();
1957  	std::deque<std::shared_ptr<nano::block>> blocks;
1958  	for (auto i = 0; i < block_count; ++i)
1959  	{
1960  		if ((i % 1000) == 0)
1961  		{
1962  			std::cerr << "Block: " << std::to_string (i) << " ms: " << std::to_string (std::chrono::duration_cast<std::chrono::milliseconds> (std::chrono::system_clock::now () - start).count ()) << "\n";
1963  		}
1964  		auto block = wallet->send_action (nano::dev::genesis_key.pub, key.pub, 1);
1965  		debug_assert (block != nullptr);
1966  		blocks.push_back (block);
1967  	}
1968  	auto done = false;
1969  	std::chrono::system_clock::time_point last;
1970  	auto interval = 1000ms;
1971  	while (!done)
1972  	{
1973  		if (std::chrono::system_clock::now () - last > interval)
1974  		{
1975  			std::string message;
1976  			for (auto i : system.nodes)
1977  			{
1978  				message += boost::str (boost::format ("N:%1% b:%2% c:%3% a:%4% s:%5% p:%6%\n") % std::to_string (i->network.port) % std::to_string (i->ledger.cache.block_count) % std::to_string (i->ledger.cache.cemented_count) % std::to_string (i->active.size ()) % std::to_string (i->scheduler.buckets.size ()) % std::to_string (i->network.size ()));
1979  				nano::lock_guard<nano::mutex> lock{ i->active.mutex };
1980  				for (auto const & j : i->active.roots)
1981  				{
1982  					auto election = j.election;
1983  					if (election->confirmation_request_count > 10)
1984  					{
1985  						message += boost::str (boost::format ("\t r:%1% i:%2%\n") % j.root.to_string () % std::to_string (election->confirmation_request_count));
1986  						for (auto const & k : election->votes ())
1987  						{
1988  							message += boost::str (boost::format ("\t\t r:%1% t:%2%\n") % k.first.to_account () % std::to_string (k.second.timestamp));
1989  						}
1990  					}
1991  				}
1992  			}
1993  			std::cerr << message << std::endl;
1994  			last = std::chrono::system_clock::now ();
1995  		}
1996  		done = std::all_of (system.nodes.begin (), system.nodes.end (), [&blocks] (std::shared_ptr<nano::node> node) { return node->block_confirmed (blocks.back ()->hash ()); });
1997  		system.poll ();
1998  	}
1999  }
2000  } 
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-node.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-node_6.cpp</div>
                </div>
                <div class="column column_space"><pre><code>305  	system.nodes.push_back (node1);
306  	ASSERT_NE (nullptr, nano::test::establish_tcp (system, *node1, node0->network.endpoint ()));
307  	ASSERT_TIMELY (10s, node1->bootstrap_initiator.in_progress ());
</pre></code></div>
                <div class="column column_space"><pre><code>84  		system.nodes.push_back (node1);
85  		ASSERT_NE (nullptr, nano::test::establish_tcp (system, *node1, node->network.endpoint ()));
86  		node1->workers.add_timed_task (std::chrono::steady_clock::now () + std::chrono::milliseconds (200), ([&system, &key] () {
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    