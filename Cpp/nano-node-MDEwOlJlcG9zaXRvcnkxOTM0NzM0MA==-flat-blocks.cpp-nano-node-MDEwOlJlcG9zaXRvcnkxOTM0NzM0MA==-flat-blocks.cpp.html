
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 49, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-blocks.cpp</h3>
            <pre><code>1  #include <nano/crypto_lib/random_pool.hpp>
2  #include <nano/lib/blocks.hpp>
3  #include <nano/lib/memory.hpp>
4  #include <nano/lib/numbers.hpp>
5  #include <nano/lib/threading.hpp>
6  #include <nano/secure/common.hpp>
7  #include <boost/endian/conversion.hpp>
8  #include <boost/property_tree/json_parser.hpp>
9  #include <bitset>
10  #include <cryptopp/words.h>
11  namespace
12  {
13  template <typename T>
14  bool blocks_equal (T const & first, nano::block const & second)
15  {
16  	static_assert (std::is_base_of<nano::block, T>::value, "Input parameter is not a block type");
17  	return (first.type () == second.type ()) && (static_cast<T const &> (second)) == first;
18  }
19  template <typename block>
20  std::shared_ptr<block> deserialize_block (nano::stream & stream_a)
21  {
22  	auto error (false);
23  	auto result = nano::make_shared<block> (error, stream_a);
24  	if (error)
25  	{
26  		result = nullptr;
27  	}
28  	return result;
29  }
30  }
31  void nano::block_memory_pool_purge ()
32  {
33  	nano::purge_shared_ptr_singleton_pool_memory<nano::open_block> ();
34  	nano::purge_shared_ptr_singleton_pool_memory<nano::state_block> ();
35  	nano::purge_shared_ptr_singleton_pool_memory<nano::send_block> ();
36  	nano::purge_shared_ptr_singleton_pool_memory<nano::change_block> ();
37  }
38  std::string nano::block::to_json () const
39  {
40  	std::string result;
41  	serialize_json (result);
42  	return result;
43  }
44  size_t nano::block::size (nano::block_type type_a)
45  {
46  	size_t result (0);
47  	switch (type_a)
48  	{
49  		case nano::block_type::invalid:
50  		case nano::block_type::not_a_block:
51  			debug_assert (false);
52  			break;
53  		case nano::block_type::send:
54  			result = nano::send_block::size;
55  			break;
56  		case nano::block_type::receive:
57  			result = nano::receive_block::size;
58  			break;
59  		case nano::block_type::change:
60  			result = nano::change_block::size;
61  			break;
62  		case nano::block_type::open:
63  			result = nano::open_block::size;
64  			break;
65  		case nano::block_type::state:
66  			result = nano::state_block::size;
67  			break;
68  	}
69  	return result;
70  }
71  nano::work_version nano::block::work_version () const
72  {
73  	return nano::work_version::work_1;
74  }
75  nano::block_hash nano::block::generate_hash () const
76  {
77  	nano::block_hash result;
78  	blake2b_state hash_l;
79  	auto status (blake2b_init (&hash_l, sizeof (result.bytes)));
80  	debug_assert (status == 0);
81  	hash (hash_l);
82  	status = blake2b_final (&hash_l, result.bytes.data (), sizeof (result.bytes));
83  	debug_assert (status == 0);
84  	return result;
85  }
86  void nano::block::refresh ()
87  {
88  	if (!cached_hash.is_zero ())
89  	{
90  		cached_hash = generate_hash ();
91  	}
92  }
93  nano::block_hash const & nano::block::hash () const
94  {
95  	if (!cached_hash.is_zero ())
96  	{
97  		debug_assert (cached_hash == generate_hash ());
98  	}
99  	else
100  	{
101  		cached_hash = generate_hash ();
102  	}
103  	return cached_hash;
104  }
105  nano::block_hash nano::block::full_hash () const
106  {
107  	nano::block_hash result;
108  	blake2b_state state;
109  	blake2b_init (&state, sizeof (result.bytes));
110  	blake2b_update (&state, hash ().bytes.data (), sizeof (hash ()));
111  	auto signature (block_signature ());
112  	blake2b_update (&state, signature.bytes.data (), sizeof (signature));
113  	auto work (block_work ());
114  	blake2b_update (&state, &work, sizeof (work));
115  	blake2b_final (&state, result.bytes.data (), sizeof (result.bytes));
116  	return result;
117  }
118  nano::block_sideband const & nano::block::sideband () const
119  {
120  	debug_assert (sideband_m.is_initialized ());
121  	return *sideband_m;
122  }
123  void nano::block::sideband_set (nano::block_sideband const & sideband_a)
124  {
125  	sideband_m = sideband_a;
126  }
127  bool nano::block::has_sideband () const
128  {
129  	return sideband_m.is_initialized ();
130  }
131  nano::account const & nano::block::representative () const
132  {
133  	static nano::account representative{};
134  	return representative;
135  }
136  nano::block_hash const & nano::block::source () const
137  {
138  	static nano::block_hash source{ 0 };
139  	return source;
140  }
141  nano::account const & nano::block::destination () const
142  {
143  	static nano::account destination{};
144  	return destination;
145  }
146  nano::link const & nano::block::link () const
147  {
148  	static nano::link link{ 0 };
149  	return link;
150  }
151  nano::account const & nano::block::account () const
152  {
153  	static nano::account account{};
154  	return account;
155  }
156  nano::qualified_root nano::block::qualified_root () const
157  {
158  	return nano::qualified_root (root (), previous ());
159  }
160  nano::amount const & nano::block::balance () const
161  {
162  	static nano::amount amount{ 0 };
163  	return amount;
164  }
165  void nano::send_block::visit (nano::block_visitor & visitor_a) const
166  {
167  	visitor_a.send_block (*this);
168  }
169  void nano::send_block::visit (nano::mutable_block_visitor & visitor_a)
170  {
171  	visitor_a.send_block (*this);
172  }
173  void nano::send_block::hash (blake2b_state & hash_a) const
174  {
175  	hashables.hash (hash_a);
176  }
177  uint64_t nano::send_block::block_work () const
178  {
179  	return work;
180  }
181  void nano::send_block::block_work_set (uint64_t work_a)
182  {
183  	work = work_a;
184  }
185  nano::send_hashables::send_hashables (nano::block_hash const & previous_a, nano::account const & destination_a, nano::amount const & balance_a) :
186  	previous (previous_a),
187  	destination (destination_a),
188  	balance (balance_a)
189  {
190  }
191  nano::send_hashables::send_hashables (bool & error_a, nano::stream & stream_a)
192  {
193  	try
194  	{
195  		nano::read (stream_a, previous.bytes);
196  		nano::read (stream_a, destination.bytes);
197  		nano::read (stream_a, balance.bytes);
198  	}
199  	catch (std::runtime_error const &)
200  	{
201  		error_a = true;
202  	}
203  }
204  nano::send_hashables::send_hashables (bool & error_a, boost::property_tree::ptree const & tree_a)
205  {
206  	try
207  	{
208  		auto previous_l (tree_a.get<std::string> ("previous"));
209  		auto destination_l (tree_a.get<std::string> ("destination"));
210  		auto balance_l (tree_a.get<std::string> ("balance"));
211  		error_a = previous.decode_hex (previous_l);
212  		if (!error_a)
213  		{
214  			error_a = destination.decode_account (destination_l);
215  			if (!error_a)
216  			{
217  				error_a = balance.decode_hex (balance_l);
218  			}
219  		}
220  	}
221  	catch (std::runtime_error const &)
222  	{
223  		error_a = true;
224  	}
225  }
226  void nano::send_hashables::hash (blake2b_state & hash_a) const
227  {
228  	auto status (blake2b_update (&hash_a, previous.bytes.data (), sizeof (previous.bytes)));
229  	debug_assert (status == 0);
230  	status = blake2b_update (&hash_a, destination.bytes.data (), sizeof (destination.bytes));
231  	debug_assert (status == 0);
232  	status = blake2b_update (&hash_a, balance.bytes.data (), sizeof (balance.bytes));
233  	debug_assert (status == 0);
234  }
235  void nano::send_block::serialize (nano::stream & stream_a) const
236  {
237  	write (stream_a, hashables.previous.bytes);
238  	write (stream_a, hashables.destination.bytes);
239  	write (stream_a, hashables.balance.bytes);
240  	write (stream_a, signature.bytes);
241  	write (stream_a, work);
242  }
243  bool nano::send_block::deserialize (nano::stream & stream_a)
244  {
245  	auto error (false);
246  	try
247  	{
248  		read (stream_a, hashables.previous.bytes);
249  		read (stream_a, hashables.destination.bytes);
250  		read (stream_a, hashables.balance.bytes);
251  		read (stream_a, signature.bytes);
252  		read (stream_a, work);
253  	}
254  	catch (std::exception const &)
255  	{
256  		error = true;
257  	}
258  	return error;
259  }
260  void nano::send_block::serialize_json (std::string & string_a, bool single_line) const
261  {
262  	boost::property_tree::ptree tree;
263  	serialize_json (tree);
264  	std::stringstream ostream;
265  	boost::property_tree::write_json (ostream, tree, !single_line);
266  	string_a = ostream.str ();
267  }
268  void nano::send_block::serialize_json (boost::property_tree::ptree & tree) const
269  {
270  	tree.put ("type", "send");
271  	std::string previous;
272  	hashables.previous.encode_hex (previous);
273  	tree.put ("previous", previous);
274  	tree.put ("destination", hashables.destination.to_account ());
275  	std::string balance;
276  	hashables.balance.encode_hex (balance);
277  	tree.put ("balance", balance);
278  	std::string signature_l;
279  	signature.encode_hex (signature_l);
280  	tree.put ("work", nano::to_string_hex (work));
281  	tree.put ("signature", signature_l);
282  }
283  bool nano::send_block::deserialize_json (boost::property_tree::ptree const & tree_a)
284  {
285  	auto error (false);
286  	try
287  	{
288  		debug_assert (tree_a.get<std::string> ("type") == "send");
289  		auto previous_l (tree_a.get<std::string> ("previous"));
290  		auto destination_l (tree_a.get<std::string> ("destination"));
291  		auto balance_l (tree_a.get<std::string> ("balance"));
292  		auto work_l (tree_a.get<std::string> ("work"));
293  		auto signature_l (tree_a.get<std::string> ("signature"));
294  		error = hashables.previous.decode_hex (previous_l);
295  		if (!error)
296  		{
297  			error = hashables.destination.decode_account (destination_l);
298  			if (!error)
299  			{
300  				error = hashables.balance.decode_hex (balance_l);
301  				if (!error)
302  				{
303  					error = nano::from_string_hex (work_l, work);
304  					if (!error)
305  					{
306  						error = signature.decode_hex (signature_l);
307  					}
308  				}
309  			}
310  		}
311  	}
312  	catch (std::runtime_error const &)
313  	{
314  		error = true;
315  	}
316  	return error;
317  }
318  nano::send_block::send_block (nano::block_hash const & previous_a, nano::account const & destination_a, nano::amount const & balance_a, nano::raw_key const & prv_a, nano::public_key const & pub_a, uint64_t work_a) :
319  	hashables (previous_a, destination_a, balance_a),
320  	signature (nano::sign_message (prv_a, pub_a, hash ())),
321  	work (work_a)
322  {
323  	debug_assert (destination_a != nullptr);
324  	debug_assert (pub_a != nullptr);
325  }
326  nano::send_block::send_block (bool & error_a, nano::stream & stream_a) :
327  	hashables (error_a, stream_a)
328  {
329  	if (!error_a)
330  	{
331  		try
332  		{
333  			nano::read (stream_a, signature.bytes);
334  			nano::read (stream_a, work);
335  		}
336  		catch (std::runtime_error const &)
337  		{
338  			error_a = true;
339  		}
340  	}
341  }
342  nano::send_block::send_block (bool & error_a, boost::property_tree::ptree const & tree_a) :
343  	hashables (error_a, tree_a)
344  {
345  	if (!error_a)
346  	{
347  		try
348  		{
349  			auto signature_l (tree_a.get<std::string> ("signature"));
350  			auto work_l (tree_a.get<std::string> ("work"));
351  			error_a = signature.decode_hex (signature_l);
352  			if (!error_a)
353  			{
354  				error_a = nano::from_string_hex (work_l, work);
355  			}
356  		}
357  		catch (std::runtime_error const &)
358  		{
359  			error_a = true;
360  		}
361  	}
362  }
363  bool nano::send_block::operator== (nano::block const & other_a) const
364  {
365  	return blocks_equal (*this, other_a);
366  }
367  bool nano::send_block::valid_predecessor (nano::block const & block_a) const
368  {
369  	bool result;
370  	switch (block_a.type ())
371  	{
372  		case nano::block_type::send:
373  		case nano::block_type::receive:
374  		case nano::block_type::open:
375  		case nano::block_type::change:
376  			result = true;
377  			break;
378  		default:
379  			result = false;
380  			break;
381  	}
382  	return result;
383  }
384  nano::block_type nano::send_block::type () const
385  {
386  	return nano::block_type::send;
387  }
388  bool nano::send_block::operator== (nano::send_block const & other_a) const
389  {
390  	auto result (hashables.destination == other_a.hashables.destination && hashables.previous == other_a.hashables.previous && hashables.balance == other_a.hashables.balance && work == other_a.work && signature == other_a.signature);
391  	return result;
392  }
393  nano::block_hash const & nano::send_block::previous () const
394  {
395  	return hashables.previous;
396  }
397  nano::account const & nano::send_block::destination () const
398  {
399  	return hashables.destination;
400  }
401  nano::root const & nano::send_block::root () const
402  {
403  	return hashables.previous;
404  }
405  nano::amount const & nano::send_block::balance () const
406  {
407  	return hashables.balance;
408  }
409  nano::signature const & nano::send_block::block_signature () const
410  {
411  	return signature;
412  }
413  void nano::send_block::signature_set (nano::signature const & signature_a)
414  {
415  	signature = signature_a;
416  }
417  nano::open_hashables::open_hashables (nano::block_hash const & source_a, nano::account const & representative_a, nano::account const & account_a) :
418  	source (source_a),
419  	representative (representative_a),
420  	account (account_a)
421  {
422  }
423  nano::open_hashables::open_hashables (bool & error_a, nano::stream & stream_a)
424  {
425  	try
426  	{
427  		nano::read (stream_a, source.bytes);
428  		nano::read (stream_a, representative.bytes);
429  		nano::read (stream_a, account.bytes);
430  	}
431  	catch (std::runtime_error const &)
432  	{
433  		error_a = true;
434  	}
435  }
436  nano::open_hashables::open_hashables (bool & error_a, boost::property_tree::ptree const & tree_a)
437  {
438  	try
439  	{
440  		auto source_l (tree_a.get<std::string> ("source"));
441  		auto representative_l (tree_a.get<std::string> ("representative"));
442  		auto account_l (tree_a.get<std::string> ("account"));
443  		error_a = source.decode_hex (source_l);
444  		if (!error_a)
445  		{
446  			error_a = representative.decode_account (representative_l);
447  			if (!error_a)
448  			{
449  				error_a = account.decode_account (account_l);
450  			}
451  		}
452  	}
453  	catch (std::runtime_error const &)
454  	{
455  		error_a = true;
456  	}
457  }
458  void nano::open_hashables::hash (blake2b_state & hash_a) const
459  {
460  	blake2b_update (&hash_a, source.bytes.data (), sizeof (source.bytes));
461  	blake2b_update (&hash_a, representative.bytes.data (), sizeof (representative.bytes));
462  	blake2b_update (&hash_a, account.bytes.data (), sizeof (account.bytes));
463  }
464  nano::open_block::open_block (nano::block_hash const & source_a, nano::account const & representative_a, nano::account const & account_a, nano::raw_key const & prv_a, nano::public_key const & pub_a, uint64_t work_a) :
465  	hashables (source_a, representative_a, account_a),
466  	signature (nano::sign_message (prv_a, pub_a, hash ())),
467  	work (work_a)
468  {
469  	debug_assert (representative_a != nullptr);
470  	debug_assert (account_a != nullptr);
471  	debug_assert (pub_a != nullptr);
472  }
473  nano::open_block::open_block (nano::block_hash const & source_a, nano::account const & representative_a, nano::account const & account_a, std::nullptr_t) :
474  	hashables (source_a, representative_a, account_a),
475  	work (0)
476  {
477  	debug_assert (representative_a != nullptr);
478  	debug_assert (account_a != nullptr);
479  	signature.clear ();
480  }
481  nano::open_block::open_block (bool & error_a, nano::stream & stream_a) :
482  	hashables (error_a, stream_a)
483  {
484  	if (!error_a)
485  	{
486  		try
487  		{
488  			nano::read (stream_a, signature);
489  			nano::read (stream_a, work);
490  		}
491  		catch (std::runtime_error const &)
492  		{
493  			error_a = true;
494  		}
495  	}
496  }
497  nano::open_block::open_block (bool & error_a, boost::property_tree::ptree const & tree_a) :
498  	hashables (error_a, tree_a)
499  {
500  	if (!error_a)
501  	{
502  		try
503  		{
504  			auto work_l (tree_a.get<std::string> ("work"));
505  			auto signature_l (tree_a.get<std::string> ("signature"));
506  			error_a = nano::from_string_hex (work_l, work);
507  			if (!error_a)
508  			{
509  				error_a = signature.decode_hex (signature_l);
510  			}
511  		}
512  		catch (std::runtime_error const &)
513  		{
514  			error_a = true;
515  		}
516  	}
517  }
518  void nano::open_block::hash (blake2b_state & hash_a) const
519  {
520  	hashables.hash (hash_a);
521  }
522  uint64_t nano::open_block::block_work () const
523  {
524  	return work;
525  }
526  void nano::open_block::block_work_set (uint64_t work_a)
527  {
528  	work = work_a;
529  }
530  nano::block_hash const & nano::open_block::previous () const
531  {
532  	static nano::block_hash result{ 0 };
533  	return result;
534  }
535  nano::account const & nano::open_block::account () const
536  {
537  	return hashables.account;
538  }
539  void nano::open_block::serialize (nano::stream & stream_a) const
540  {
541  	write (stream_a, hashables.source);
542  	write (stream_a, hashables.representative);
543  	write (stream_a, hashables.account);
544  	write (stream_a, signature);
545  	write (stream_a, work);
546  }
547  bool nano::open_block::deserialize (nano::stream & stream_a)
548  {
549  	auto error (false);
550  	try
551  	{
552  		read (stream_a, hashables.source);
553  		read (stream_a, hashables.representative);
554  		read (stream_a, hashables.account);
555  		read (stream_a, signature);
556  		read (stream_a, work);
557  	}
558  	catch (std::runtime_error const &)
559  	{
560  		error = true;
561  	}
562  	return error;
563  }
564  void nano::open_block::serialize_json (std::string & string_a, bool single_line) const
565  {
566  	boost::property_tree::ptree tree;
567  	serialize_json (tree);
568  	std::stringstream ostream;
569  	boost::property_tree::write_json (ostream, tree, !single_line);
570  	string_a = ostream.str ();
571  }
572  void nano::open_block::serialize_json (boost::property_tree::ptree & tree) const
573  {
574  	tree.put ("type", "open");
575  	tree.put ("source", hashables.source.to_string ());
576  	tree.put ("representative", representative ().to_account ());
577  	tree.put ("account", hashables.account.to_account ());
578  	std::string signature_l;
579  	signature.encode_hex (signature_l);
580  	tree.put ("work", nano::to_string_hex (work));
581  	tree.put ("signature", signature_l);
582  }
583  bool nano::open_block::deserialize_json (boost::property_tree::ptree const & tree_a)
584  {
585  	auto error (false);
586  	try
587  	{
588  		debug_assert (tree_a.get<std::string> ("type") == "open");
589  		auto source_l (tree_a.get<std::string> ("source"));
590  		auto representative_l (tree_a.get<std::string> ("representative"));
591  		auto account_l (tree_a.get<std::string> ("account"));
592  		auto work_l (tree_a.get<std::string> ("work"));
593  		auto signature_l (tree_a.get<std::string> ("signature"));
594  		error = hashables.source.decode_hex (source_l);
595  		if (!error)
596  		{
597  			error = hashables.representative.decode_hex (representative_l);
598  			if (!error)
599  			{
600  				error = hashables.account.decode_hex (account_l);
601  				if (!error)
602  				{
603  					error = nano::from_string_hex (work_l, work);
604  					if (!error)
605  					{
606  						error = signature.decode_hex (signature_l);
607  					}
608  				}
609  			}
610  		}
611  	}
612  	catch (std::runtime_error const &)
613  	{
614  		error = true;
615  	}
616  	return error;
617  }
618  void nano::open_block::visit (nano::block_visitor & visitor_a) const
619  {
620  	visitor_a.open_block (*this);
621  }
622  void nano::open_block::visit (nano::mutable_block_visitor & visitor_a)
623  {
624  	visitor_a.open_block (*this);
625  }
626  nano::block_type nano::open_block::type () const
627  {
628  	return nano::block_type::open;
629  }
630  bool nano::open_block::operator== (nano::block const & other_a) const
631  {
632  	return blocks_equal (*this, other_a);
633  }
634  bool nano::open_block::operator== (nano::open_block const & other_a) const
635  {
636  	return hashables.source == other_a.hashables.source && hashables.representative == other_a.hashables.representative && hashables.account == other_a.hashables.account && work == other_a.work && signature == other_a.signature;
637  }
638  bool nano::open_block::valid_predecessor (nano::block const & block_a) const
639  {
640  	return false;
641  }
642  nano::block_hash const & nano::open_block::source () const
643  {
644  	return hashables.source;
645  }
646  nano::root const & nano::open_block::root () const
647  {
648  	return hashables.account;
649  }
650  nano::account const & nano::open_block::representative () const
651  {
652  	return hashables.representative;
653  }
654  nano::signature const & nano::open_block::block_signature () const
655  {
656  	return signature;
657  }
658  void nano::open_block::signature_set (nano::signature const & signature_a)
659  {
660  	signature = signature_a;
661  }
662  nano::change_hashables::change_hashables (nano::block_hash const & previous_a, nano::account const & representative_a) :
663  	previous (previous_a),
664  	representative (representative_a)
665  {
666  }
667  nano::change_hashables::change_hashables (bool & error_a, nano::stream & stream_a)
668  {
669  	try
670  	{
671  		nano::read (stream_a, previous);
672  		nano::read (stream_a, representative);
673  	}
674  	catch (std::runtime_error const &)
675  	{
676  		error_a = true;
677  	}
678  }
679  nano::change_hashables::change_hashables (bool & error_a, boost::property_tree::ptree const & tree_a)
680  {
681  	try
682  	{
683  		auto previous_l (tree_a.get<std::string> ("previous"));
684  		auto representative_l (tree_a.get<std::string> ("representative"));
685  		error_a = previous.decode_hex (previous_l);
686  		if (!error_a)
687  		{
688  			error_a = representative.decode_account (representative_l);
689  		}
690  	}
691  	catch (std::runtime_error const &)
692  	{
693  		error_a = true;
694  	}
695  }
696  void nano::change_hashables::hash (blake2b_state & hash_a) const
697  {
698  	blake2b_update (&hash_a, previous.bytes.data (), sizeof (previous.bytes));
699  	blake2b_update (&hash_a, representative.bytes.data (), sizeof (representative.bytes));
700  }
701  nano::change_block::change_block (nano::block_hash const & previous_a, nano::account const & representative_a, nano::raw_key const & prv_a, nano::public_key const & pub_a, uint64_t work_a) :
702  	hashables (previous_a, representative_a),
703  	signature (nano::sign_message (prv_a, pub_a, hash ())),
704  	work (work_a)
705  {
706  	debug_assert (representative_a != nullptr);
707  	debug_assert (pub_a != nullptr);
708  }
709  nano::change_block::change_block (bool & error_a, nano::stream & stream_a) :
710  	hashables (error_a, stream_a)
711  {
712  	if (!error_a)
713  	{
714  		try
715  		{
716  			nano::read (stream_a, signature);
717  			nano::read (stream_a, work);
718  		}
719  		catch (std::runtime_error const &)
720  		{
721  			error_a = true;
722  		}
723  	}
724  }
725  nano::change_block::change_block (bool & error_a, boost::property_tree::ptree const & tree_a) :
726  	hashables (error_a, tree_a)
727  {
728  	if (!error_a)
729  	{
730  		try
731  		{
732  			auto work_l (tree_a.get<std::string> ("work"));
733  			auto signature_l (tree_a.get<std::string> ("signature"));
734  			error_a = nano::from_string_hex (work_l, work);
735  			if (!error_a)
736  			{
737  				error_a = signature.decode_hex (signature_l);
738  			}
739  		}
740  		catch (std::runtime_error const &)
741  		{
742  			error_a = true;
743  		}
744  	}
745  }
746  void nano::change_block::hash (blake2b_state & hash_a) const
747  {
748  	hashables.hash (hash_a);
749  }
750  uint64_t nano::change_block::block_work () const
751  {
752  	return work;
753  }
754  void nano::change_block::block_work_set (uint64_t work_a)
755  {
756  	work = work_a;
757  }
758  nano::block_hash const & nano::change_block::previous () const
759  {
760  	return hashables.previous;
761  }
762  void nano::change_block::serialize (nano::stream & stream_a) const
763  {
764  	write (stream_a, hashables.previous);
765  	write (stream_a, hashables.representative);
766  	write (stream_a, signature);
767  	write (stream_a, work);
768  }
769  bool nano::change_block::deserialize (nano::stream & stream_a)
770  {
771  	auto error (false);
772  	try
773  	{
774  		read (stream_a, hashables.previous);
775  		read (stream_a, hashables.representative);
776  		read (stream_a, signature);
777  		read (stream_a, work);
778  	}
779  	catch (std::runtime_error const &)
780  	{
781  		error = true;
782  	}
783  	return error;
784  }
785  void nano::change_block::serialize_json (std::string & string_a, bool single_line) const
786  {
787  	boost::property_tree::ptree tree;
788  	serialize_json (tree);
789  	std::stringstream ostream;
790  	boost::property_tree::write_json (ostream, tree, !single_line);
791  	string_a = ostream.str ();
792  }
793  void nano::change_block::serialize_json (boost::property_tree::ptree & tree) const
794  {
795  	tree.put ("type", "change");
796  	tree.put ("previous", hashables.previous.to_string ());
797  	tree.put ("representative", representative ().to_account ());
798  	tree.put ("work", nano::to_string_hex (work));
799  	std::string signature_l;
800  	signature.encode_hex (signature_l);
801  	tree.put ("signature", signature_l);
802  }
803  bool nano::change_block::deserialize_json (boost::property_tree::ptree const & tree_a)
804  {
805  	auto error (false);
806  	try
807  	{
808  		debug_assert (tree_a.get<std::string> ("type") == "change");
809  		auto previous_l (tree_a.get<std::string> ("previous"));
810  		auto representative_l (tree_a.get<std::string> ("representative"));
811  		auto work_l (tree_a.get<std::string> ("work"));
812  		auto signature_l (tree_a.get<std::string> ("signature"));
813  		error = hashables.previous.decode_hex (previous_l);
814  		if (!error)
815  		{
816  			error = hashables.representative.decode_hex (representative_l);
817  			if (!error)
818  			{
819  				error = nano::from_string_hex (work_l, work);
820  				if (!error)
821  				{
822  					error = signature.decode_hex (signature_l);
823  				}
824  			}
825  		}
826  	}
827  	catch (std::runtime_error const &)
828  	{
829  		error = true;
830  	}
831  	return error;
832  }
833  void nano::change_block::visit (nano::block_visitor & visitor_a) const
834  {
835  	visitor_a.change_block (*this);
836  }
837  void nano::change_block::visit (nano::mutable_block_visitor & visitor_a)
838  {
839  	visitor_a.change_block (*this);
840  }
841  nano::block_type nano::change_block::type () const
842  {
843  	return nano::block_type::change;
844  }
845  bool nano::change_block::operator== (nano::block const & other_a) const
846  {
847  	return blocks_equal (*this, other_a);
848  }
849  bool nano::change_block::operator== (nano::change_block const & other_a) const
850  {
851  	return hashables.previous == other_a.hashables.previous && hashables.representative == other_a.hashables.representative && work == other_a.work && signature == other_a.signature;
852  }
853  bool nano::change_block::valid_predecessor (nano::block const & block_a) const
854  {
855  	bool result;
856  	switch (block_a.type ())
857  	{
858  		case nano::block_type::send:
859  		case nano::block_type::receive:
860  		case nano::block_type::open:
861  		case nano::block_type::change:
862  			result = true;
863  			break;
864  		default:
865  			result = false;
866  			break;
867  	}
868  	return result;
869  }
870  nano::root const & nano::change_block::root () const
871  {
872  	return hashables.previous;
873  }
874  nano::account const & nano::change_block::representative () const
875  {
876  	return hashables.representative;
877  }
878  nano::signature const & nano::change_block::block_signature () const
879  {
880  	return signature;
881  }
882  void nano::change_block::signature_set (nano::signature const & signature_a)
883  {
884  	signature = signature_a;
885  }
886  nano::state_hashables::state_hashables (nano::account const & account_a, nano::block_hash const & previous_a, nano::account const & representative_a, nano::amount const & balance_a, nano::link const & link_a) :
887  	account (account_a),
888  	previous (previous_a),
889  	representative (representative_a),
890  	balance (balance_a),
891  	link (link_a)
892  {
893  }
894  nano::state_hashables::state_hashables (bool & error_a, nano::stream & stream_a)
895  {
896  	try
897  	{
898  		nano::read (stream_a, account);
899  		nano::read (stream_a, previous);
900  		nano::read (stream_a, representative);
901  		nano::read (stream_a, balance);
902  		nano::read (stream_a, link);
903  	}
904  	catch (std::runtime_error const &)
905  	{
906  		error_a = true;
907  	}
908  }
909  nano::state_hashables::state_hashables (bool & error_a, boost::property_tree::ptree const & tree_a)
910  {
911  	try
912  	{
913  		auto account_l (tree_a.get<std::string> ("account"));
914  		auto previous_l (tree_a.get<std::string> ("previous"));
915  		auto representative_l (tree_a.get<std::string> ("representative"));
916  		auto balance_l (tree_a.get<std::string> ("balance"));
917  		auto link_l (tree_a.get<std::string> ("link"));
918  		error_a = account.decode_account (account_l);
919  		if (!error_a)
920  		{
921  			error_a = previous.decode_hex (previous_l);
922  			if (!error_a)
923  			{
924  				error_a = representative.decode_account (representative_l);
925  				if (!error_a)
926  				{
927  					error_a = balance.decode_dec (balance_l);
928  					if (!error_a)
929  					{
930  						error_a = link.decode_account (link_l) && link.decode_hex (link_l);
931  					}
932  				}
933  			}
934  		}
935  	}
936  	catch (std::runtime_error const &)
937  	{
938  		error_a = true;
939  	}
940  }
941  void nano::state_hashables::hash (blake2b_state & hash_a) const
942  {
943  	blake2b_update (&hash_a, account.bytes.data (), sizeof (account.bytes));
944  	blake2b_update (&hash_a, previous.bytes.data (), sizeof (previous.bytes));
945  	blake2b_update (&hash_a, representative.bytes.data (), sizeof (representative.bytes));
946  	blake2b_update (&hash_a, balance.bytes.data (), sizeof (balance.bytes));
947  	blake2b_update (&hash_a, link.bytes.data (), sizeof (link.bytes));
948  }
949  nano::state_block::state_block (nano::account const & account_a, nano::block_hash const & previous_a, nano::account const & representative_a, nano::amount const & balance_a, nano::link const & link_a, nano::raw_key const & prv_a, nano::public_key const & pub_a, uint64_t work_a) :
950  	hashables (account_a, previous_a, representative_a, balance_a, link_a),
951  	signature (nano::sign_message (prv_a, pub_a, hash ())),
952  	work (work_a)
953  {
954  	debug_assert (account_a != nullptr);
955  	debug_assert (representative_a != nullptr);
956  	debug_assert (link_a.as_account () != nullptr);
957  	debug_assert (pub_a != nullptr);
958  }
959  nano::state_block::state_block (bool & error_a, nano::stream & stream_a) :
960  	hashables (error_a, stream_a)
961  {
962  	if (!error_a)
963  	{
964  		try
965  		{
966  			nano::read (stream_a, signature);
967  			nano::read (stream_a, work);
968  			boost::endian::big_to_native_inplace (work);
969  		}
970  		catch (std::runtime_error const &)
971  		{
972  			error_a = true;
973  		}
974  	}
975  }
976  nano::state_block::state_block (bool & error_a, boost::property_tree::ptree const & tree_a) :
977  	hashables (error_a, tree_a)
978  {
979  	if (!error_a)
980  	{
981  		try
982  		{
983  			auto type_l (tree_a.get<std::string> ("type"));
984  			auto signature_l (tree_a.get<std::string> ("signature"));
985  			auto work_l (tree_a.get<std::string> ("work"));
986  			error_a = type_l != "state";
987  			if (!error_a)
988  			{
989  				error_a = nano::from_string_hex (work_l, work);
990  				if (!error_a)
991  				{
992  					error_a = signature.decode_hex (signature_l);
993  				}
994  			}
995  		}
996  		catch (std::runtime_error const &)
997  		{
998  			error_a = true;
999  		}
1000  	}
1001  }
1002  void nano::state_block::hash (blake2b_state & hash_a) const
1003  {
1004  	nano::uint256_union preamble (static_cast<uint64_t> (nano::block_type::state));
1005  	blake2b_update (&hash_a, preamble.bytes.data (), preamble.bytes.size ());
1006  	hashables.hash (hash_a);
1007  }
1008  uint64_t nano::state_block::block_work () const
1009  {
1010  	return work;
1011  }
1012  void nano::state_block::block_work_set (uint64_t work_a)
1013  {
1014  	work = work_a;
1015  }
1016  nano::block_hash const & nano::state_block::previous () const
1017  {
1018  	return hashables.previous;
1019  }
1020  nano::account const & nano::state_block::account () const
1021  {
1022  	return hashables.account;
1023  }
1024  void nano::state_block::serialize (nano::stream & stream_a) const
1025  {
1026  	write (stream_a, hashables.account);
1027  	write (stream_a, hashables.previous);
1028  	write (stream_a, hashables.representative);
1029  	write (stream_a, hashables.balance);
1030  	write (stream_a, hashables.link);
1031  	write (stream_a, signature);
1032  	write (stream_a, boost::endian::native_to_big (work));
1033  }
1034  bool nano::state_block::deserialize (nano::stream & stream_a)
1035  {
1036  	auto error (false);
1037  	try
1038  	{
1039  		read (stream_a, hashables.account);
1040  		read (stream_a, hashables.previous);
1041  		read (stream_a, hashables.representative);
1042  		read (stream_a, hashables.balance);
1043  		read (stream_a, hashables.link);
1044  		read (stream_a, signature);
1045  		read (stream_a, work);
1046  		boost::endian::big_to_native_inplace (work);
1047  	}
1048  	catch (std::runtime_error const &)
1049  	{
1050  		error = true;
1051  	}
1052  	return error;
1053  }
1054  void nano::state_block::serialize_json (std::string & string_a, bool single_line) const
1055  {
1056  	boost::property_tree::ptree tree;
1057  	serialize_json (tree);
1058  	std::stringstream ostream;
1059  	boost::property_tree::write_json (ostream, tree, !single_line);
1060  	string_a = ostream.str ();
1061  }
1062  void nano::state_block::serialize_json (boost::property_tree::ptree & tree) const
1063  {
1064  	tree.put ("type", "state");
1065  	tree.put ("account", hashables.account.to_account ());
1066  	tree.put ("previous", hashables.previous.to_string ());
1067  	tree.put ("representative", representative ().to_account ());
1068  	tree.put ("balance", hashables.balance.to_string_dec ());
1069  	tree.put ("link", hashables.link.to_string ());
1070  	tree.put ("link_as_account", hashables.link.to_account ());
1071  	std::string signature_l;
1072  	signature.encode_hex (signature_l);
1073  	tree.put ("signature", signature_l);
1074  	tree.put ("work", nano::to_string_hex (work));
1075  }
1076  bool nano::state_block::deserialize_json (boost::property_tree::ptree const & tree_a)
1077  {
1078  	auto error (false);
1079  	try
1080  	{
1081  		debug_assert (tree_a.get<std::string> ("type") == "state");
1082  		auto account_l (tree_a.get<std::string> ("account"));
1083  		auto previous_l (tree_a.get<std::string> ("previous"));
1084  		auto representative_l (tree_a.get<std::string> ("representative"));
1085  		auto balance_l (tree_a.get<std::string> ("balance"));
1086  		auto link_l (tree_a.get<std::string> ("link"));
1087  		auto work_l (tree_a.get<std::string> ("work"));
1088  		auto signature_l (tree_a.get<std::string> ("signature"));
1089  		error = hashables.account.decode_account (account_l);
1090  		if (!error)
1091  		{
1092  			error = hashables.previous.decode_hex (previous_l);
1093  			if (!error)
1094  			{
1095  				error = hashables.representative.decode_account (representative_l);
1096  				if (!error)
1097  				{
1098  					error = hashables.balance.decode_dec (balance_l);
1099  					if (!error)
1100  					{
1101  						error = hashables.link.decode_account (link_l) && hashables.link.decode_hex (link_l);
1102  						if (!error)
1103  						{
1104  							error = nano::from_string_hex (work_l, work);
1105  							if (!error)
1106  							{
1107  								error = signature.decode_hex (signature_l);
1108  							}
1109  						}
1110  					}
1111  				}
1112  			}
1113  		}
1114  	}
1115  	catch (std::runtime_error const &)
1116  	{
1117  		error = true;
1118  	}
1119  	return error;
1120  }
1121  void nano::state_block::visit (nano::block_visitor & visitor_a) const
1122  {
1123  	visitor_a.state_block (*this);
1124  }
1125  void nano::state_block::visit (nano::mutable_block_visitor & visitor_a)
1126  {
1127  	visitor_a.state_block (*this);
1128  }
1129  nano::block_type nano::state_block::type () const
1130  {
1131  	return nano::block_type::state;
1132  }
1133  bool nano::state_block::operator== (nano::block const & other_a) const
1134  {
1135  	return blocks_equal (*this, other_a);
1136  }
1137  bool nano::state_block::operator== (nano::state_block const & other_a) const
1138  {
1139  	return hashables.account == other_a.hashables.account && hashables.previous == other_a.hashables.previous && hashables.representative == other_a.hashables.representative && hashables.balance == other_a.hashables.balance && hashables.link == other_a.hashables.link && signature == other_a.signature && work == other_a.work;
1140  }
1141  bool nano::state_block::valid_predecessor (nano::block const & block_a) const
1142  {
1143  	return true;
1144  }
1145  nano::root const & nano::state_block::root () const
1146  {
1147  	if (!hashables.previous.is_zero ())
1148  	{
1149  		return hashables.previous;
1150  	}
1151  	else
1152  	{
1153  		return hashables.account;
1154  	}
1155  }
1156  nano::link const & nano::state_block::link () const
1157  {
1158  	return hashables.link;
1159  }
1160  nano::account const & nano::state_block::representative () const
1161  {
1162  	return hashables.representative;
1163  }
1164  nano::amount const & nano::state_block::balance () const
1165  {
1166  	return hashables.balance;
1167  }
1168  nano::signature const & nano::state_block::block_signature () const
1169  {
1170  	return signature;
1171  }
1172  void nano::state_block::signature_set (nano::signature const & signature_a)
1173  {
1174  	signature = signature_a;
1175  }
1176  std::shared_ptr<nano::block> nano::deserialize_block_json (boost::property_tree::ptree const & tree_a, nano::block_uniquer * uniquer_a)
1177  {
1178  	std::shared_ptr<nano::block> result;
1179  	try
1180  	{
1181  		auto type (tree_a.get<std::string> ("type"));
1182  		bool error (false);
1183  		std::unique_ptr<nano::block> obj;
1184  		if (type == "receive")
1185  		{
1186  			obj = std::make_unique<nano::receive_block> (error, tree_a);
1187  		}
1188  		else if (type == "send")
1189  		{
1190  			obj = std::make_unique<nano::send_block> (error, tree_a);
1191  		}
1192  		else if (type == "open")
1193  		{
1194  			obj = std::make_unique<nano::open_block> (error, tree_a);
1195  		}
1196  		else if (type == "change")
1197  		{
1198  			obj = std::make_unique<nano::change_block> (error, tree_a);
1199  		}
1200  		else if (type == "state")
1201  		{
1202  			obj = std::make_unique<nano::state_block> (error, tree_a);
1203  		}
1204  		if (!error)
1205  		{
1206  			result = std::move (obj);
1207  		}
1208  	}
1209  	catch (std::runtime_error const &)
1210  	{
1211  	}
1212  	if (uniquer_a != nullptr)
1213  	{
1214  		result = uniquer_a->unique (result);
1215  	}
1216  	return result;
1217  }
1218  void nano::serialize_block_type (nano::stream & stream, const nano::block_type & type)
1219  {
1220  	nano::write (stream, type);
1221  }
1222  void nano::serialize_block (nano::stream & stream_a, nano::block const & block_a)
1223  {
1224  	nano::serialize_block_type (stream_a, block_a.type ());
1225  	block_a.serialize (stream_a);
1226  }
1227  std::shared_ptr<nano::block> nano::deserialize_block (nano::stream & stream_a)
1228  {
1229  	nano::block_type type;
1230  	auto error (try_read (stream_a, type));
1231  	std::shared_ptr<nano::block> result;
1232  	if (!error)
1233  	{
1234  		result = nano::deserialize_block (stream_a, type);
1235  	}
1236  	return result;
1237  }
1238  std::shared_ptr<nano::block> nano::deserialize_block (nano::stream & stream_a, nano::block_type type_a, nano::block_uniquer * uniquer_a)
1239  {
1240  	std::shared_ptr<nano::block> result;
1241  	switch (type_a)
1242  	{
1243  		case nano::block_type::receive:
1244  		{
1245  			result = ::deserialize_block<nano::receive_block> (stream_a);
1246  			break;
1247  		}
1248  		case nano::block_type::send:
1249  		{
1250  			result = ::deserialize_block<nano::send_block> (stream_a);
1251  			break;
1252  		}
1253  		case nano::block_type::open:
1254  		{
1255  			result = ::deserialize_block<nano::open_block> (stream_a);
1256  			break;
1257  		}
1258  		case nano::block_type::change:
1259  		{
1260  			result = ::deserialize_block<nano::change_block> (stream_a);
1261  			break;
1262  		}
1263  		case nano::block_type::state:
1264  		{
1265  			result = ::deserialize_block<nano::state_block> (stream_a);
1266  			break;
1267  		}
1268  		default:
1269  		{
1270  			return {};
1271  		}
1272  	}
1273  	if (result && uniquer_a != nullptr)
1274  	{
1275  		result = uniquer_a->unique (result);
1276  	}
1277  	return result;
1278  }
1279  void nano::receive_block::visit (nano::block_visitor & visitor_a) const
1280  {
1281  	visitor_a.receive_block (*this);
1282  }
1283  void nano::receive_block::visit (nano::mutable_block_visitor & visitor_a)
1284  {
1285  	visitor_a.receive_block (*this);
1286  }
1287  bool nano::receive_block::operator== (nano::receive_block const & other_a) const
1288  {
1289  	auto result (hashables.previous == other_a.hashables.previous && hashables.source == other_a.hashables.source && work == other_a.work && signature == other_a.signature);
1290  	return result;
1291  }
1292  void nano::receive_block::serialize (nano::stream & stream_a) const
1293  {
1294  	write (stream_a, hashables.previous.bytes);
1295  	write (stream_a, hashables.source.bytes);
1296  	write (stream_a, signature.bytes);
1297  	write (stream_a, work);
1298  }
1299  bool nano::receive_block::deserialize (nano::stream & stream_a)
1300  {
1301  	auto error (false);
1302  	try
1303  	{
1304  		read (stream_a, hashables.previous.bytes);
1305  		read (stream_a, hashables.source.bytes);
1306  		read (stream_a, signature.bytes);
1307  		read (stream_a, work);
1308  	}
1309  	catch (std::runtime_error const &)
1310  	{
1311  		error = true;
1312  	}
1313  	return error;
1314  }
1315  void nano::receive_block::serialize_json (std::string & string_a, bool single_line) const
1316  {
1317  	boost::property_tree::ptree tree;
1318  	serialize_json (tree);
1319  	std::stringstream ostream;
<span onclick='openModal()' class='match'>1320  	boost::property_tree::write_json (ostream, tree, !single_line);
1321  	string_a = ostream.str ();
1322  }
1323  void nano::receive_block::serialize_json (boost::property_tree::ptree & tree) const
1324  {
1325  	tree.put ("type", "receive");
1326  	std::string previous;
</span>1327  	hashables.previous.encode_hex (previous);
1328  	tree.put ("previous", previous);
1329  	std::string source;
1330  	hashables.source.encode_hex (source);
1331  	tree.put ("source", source);
1332  	std::string signature_l;
1333  	signature.encode_hex (signature_l);
1334  	tree.put ("work", nano::to_string_hex (work));
1335  	tree.put ("signature", signature_l);
1336  }
1337  bool nano::receive_block::deserialize_json (boost::property_tree::ptree const & tree_a)
1338  {
1339  	auto error (false);
1340  	try
1341  	{
1342  		debug_assert (tree_a.get<std::string> ("type") == "receive");
1343  		auto previous_l (tree_a.get<std::string> ("previous"));
1344  		auto source_l (tree_a.get<std::string> ("source"));
1345  		auto work_l (tree_a.get<std::string> ("work"));
1346  		auto signature_l (tree_a.get<std::string> ("signature"));
1347  		error = hashables.previous.decode_hex (previous_l);
1348  		if (!error)
1349  		{
1350  			error = hashables.source.decode_hex (source_l);
1351  			if (!error)
1352  			{
1353  				error = nano::from_string_hex (work_l, work);
1354  				if (!error)
1355  				{
1356  					error = signature.decode_hex (signature_l);
1357  				}
1358  			}
1359  		}
1360  	}
1361  	catch (std::runtime_error const &)
1362  	{
1363  		error = true;
1364  	}
1365  	return error;
1366  }
1367  nano::receive_block::receive_block (nano::block_hash const & previous_a, nano::block_hash const & source_a, nano::raw_key const & prv_a, nano::public_key const & pub_a, uint64_t work_a) :
1368  	hashables (previous_a, source_a),
1369  	signature (nano::sign_message (prv_a, pub_a, hash ())),
1370  	work (work_a)
1371  {
1372  	debug_assert (pub_a != nullptr);
1373  }
1374  nano::receive_block::receive_block (bool & error_a, nano::stream & stream_a) :
1375  	hashables (error_a, stream_a)
1376  {
1377  	if (!error_a)
1378  	{
1379  		try
1380  		{
1381  			nano::read (stream_a, signature);
1382  			nano::read (stream_a, work);
1383  		}
1384  		catch (std::runtime_error const &)
1385  		{
1386  			error_a = true;
1387  		}
1388  	}
1389  }
1390  nano::receive_block::receive_block (bool & error_a, boost::property_tree::ptree const & tree_a) :
1391  	hashables (error_a, tree_a)
1392  {
1393  	if (!error_a)
1394  	{
1395  		try
1396  		{
1397  			auto signature_l (tree_a.get<std::string> ("signature"));
1398  			auto work_l (tree_a.get<std::string> ("work"));
1399  			error_a = signature.decode_hex (signature_l);
1400  			if (!error_a)
1401  			{
1402  				error_a = nano::from_string_hex (work_l, work);
1403  			}
1404  		}
1405  		catch (std::runtime_error const &)
1406  		{
1407  			error_a = true;
1408  		}
1409  	}
1410  }
1411  void nano::receive_block::hash (blake2b_state & hash_a) const
1412  {
1413  	hashables.hash (hash_a);
1414  }
1415  uint64_t nano::receive_block::block_work () const
1416  {
1417  	return work;
1418  }
1419  void nano::receive_block::block_work_set (uint64_t work_a)
1420  {
1421  	work = work_a;
1422  }
1423  bool nano::receive_block::operator== (nano::block const & other_a) const
1424  {
1425  	return blocks_equal (*this, other_a);
1426  }
1427  bool nano::receive_block::valid_predecessor (nano::block const & block_a) const
1428  {
1429  	bool result;
1430  	switch (block_a.type ())
1431  	{
1432  		case nano::block_type::send:
1433  		case nano::block_type::receive:
1434  		case nano::block_type::open:
1435  		case nano::block_type::change:
1436  			result = true;
1437  			break;
1438  		default:
1439  			result = false;
1440  			break;
1441  	}
1442  	return result;
1443  }
1444  nano::block_hash const & nano::receive_block::previous () const
1445  {
1446  	return hashables.previous;
1447  }
1448  nano::block_hash const & nano::receive_block::source () const
1449  {
1450  	return hashables.source;
1451  }
1452  nano::root const & nano::receive_block::root () const
1453  {
1454  	return hashables.previous;
1455  }
1456  nano::signature const & nano::receive_block::block_signature () const
1457  {
1458  	return signature;
1459  }
1460  void nano::receive_block::signature_set (nano::signature const & signature_a)
1461  {
1462  	signature = signature_a;
1463  }
1464  nano::block_type nano::receive_block::type () const
1465  {
1466  	return nano::block_type::receive;
1467  }
1468  nano::receive_hashables::receive_hashables (nano::block_hash const & previous_a, nano::block_hash const & source_a) :
1469  	previous (previous_a),
1470  	source (source_a)
1471  {
1472  }
1473  nano::receive_hashables::receive_hashables (bool & error_a, nano::stream & stream_a)
1474  {
1475  	try
1476  	{
1477  		nano::read (stream_a, previous.bytes);
1478  		nano::read (stream_a, source.bytes);
1479  	}
1480  	catch (std::runtime_error const &)
1481  	{
1482  		error_a = true;
1483  	}
1484  }
1485  nano::receive_hashables::receive_hashables (bool & error_a, boost::property_tree::ptree const & tree_a)
1486  {
1487  	try
1488  	{
1489  		auto previous_l (tree_a.get<std::string> ("previous"));
1490  		auto source_l (tree_a.get<std::string> ("source"));
1491  		error_a = previous.decode_hex (previous_l);
1492  		if (!error_a)
1493  		{
1494  			error_a = source.decode_hex (source_l);
1495  		}
1496  	}
1497  	catch (std::runtime_error const &)
1498  	{
1499  		error_a = true;
1500  	}
1501  }
1502  void nano::receive_hashables::hash (blake2b_state & hash_a) const
1503  {
1504  	blake2b_update (&hash_a, previous.bytes.data (), sizeof (previous.bytes));
1505  	blake2b_update (&hash_a, source.bytes.data (), sizeof (source.bytes));
1506  }
1507  nano::block_details::block_details (nano::epoch const epoch_a, bool const is_send_a, bool const is_receive_a, bool const is_epoch_a) :
1508  	epoch (epoch_a), is_send (is_send_a), is_receive (is_receive_a), is_epoch (is_epoch_a)
1509  {
1510  }
1511  bool nano::block_details::operator== (nano::block_details const & other_a) const
1512  {
1513  	return epoch == other_a.epoch && is_send == other_a.is_send && is_receive == other_a.is_receive && is_epoch == other_a.is_epoch;
1514  }
1515  uint8_t nano::block_details::packed () const
1516  {
1517  	std::bitset<8> result (static_cast<uint8_t> (epoch));
1518  	result.set (7, is_send);
1519  	result.set (6, is_receive);
1520  	result.set (5, is_epoch);
1521  	return static_cast<uint8_t> (result.to_ulong ());
1522  }
1523  void nano::block_details::unpack (uint8_t details_a)
1524  {
1525  	constexpr std::bitset<8> epoch_mask{ 0b00011111 };
1526  	auto as_bitset = static_cast<std::bitset<8>> (details_a);
1527  	is_send = as_bitset.test (7);
1528  	is_receive = as_bitset.test (6);
1529  	is_epoch = as_bitset.test (5);
1530  	epoch = static_cast<nano::epoch> ((as_bitset & epoch_mask).to_ulong ());
1531  }
1532  void nano::block_details::serialize (nano::stream & stream_a) const
1533  {
1534  	nano::write (stream_a, packed ());
1535  }
1536  bool nano::block_details::deserialize (nano::stream & stream_a)
1537  {
1538  	bool result (false);
1539  	try
1540  	{
1541  		uint8_t packed{ 0 };
1542  		nano::read (stream_a, packed);
1543  		unpack (packed);
1544  	}
1545  	catch (std::runtime_error &)
1546  	{
1547  		result = true;
1548  	}
1549  	return result;
1550  }
1551  std::string nano::state_subtype (nano::block_details const details_a)
1552  {
1553  	debug_assert (details_a.is_epoch + details_a.is_receive + details_a.is_send <= 1);
1554  	if (details_a.is_send)
1555  	{
1556  		return "send";
1557  	}
1558  	else if (details_a.is_receive)
1559  	{
1560  		return "receive";
1561  	}
1562  	else if (details_a.is_epoch)
1563  	{
1564  		return "epoch";
1565  	}
1566  	else
1567  	{
1568  		return "change";
1569  	}
1570  }
1571  nano::block_sideband::block_sideband (nano::account const & account_a, nano::block_hash const & successor_a, nano::amount const & balance_a, uint64_t const height_a, nano::seconds_t const timestamp_a, nano::block_details const & details_a, nano::epoch const source_epoch_a) :
1572  	successor (successor_a),
1573  	account (account_a),
1574  	balance (balance_a),
1575  	height (height_a),
1576  	timestamp (timestamp_a),
1577  	details (details_a),
1578  	source_epoch (source_epoch_a)
1579  {
1580  }
1581  nano::block_sideband::block_sideband (nano::account const & account_a, nano::block_hash const & successor_a, nano::amount const & balance_a, uint64_t const height_a, nano::seconds_t const timestamp_a, nano::epoch const epoch_a, bool const is_send, bool const is_receive, bool const is_epoch, nano::epoch const source_epoch_a) :
1582  	successor (successor_a),
1583  	account (account_a),
1584  	balance (balance_a),
1585  	height (height_a),
1586  	timestamp (timestamp_a),
1587  	details (epoch_a, is_send, is_receive, is_epoch),
1588  	source_epoch (source_epoch_a)
1589  {
1590  }
1591  size_t nano::block_sideband::size (nano::block_type type_a)
1592  {
1593  	size_t result (0);
1594  	result += sizeof (successor);
1595  	if (type_a != nano::block_type::state && type_a != nano::block_type::open)
1596  	{
1597  		result += sizeof (account);
1598  	}
1599  	if (type_a != nano::block_type::open)
1600  	{
1601  		result += sizeof (height);
1602  	}
1603  	if (type_a == nano::block_type::receive || type_a == nano::block_type::change || type_a == nano::block_type::open)
1604  	{
1605  		result += sizeof (balance);
1606  	}
1607  	result += sizeof (timestamp);
1608  	if (type_a == nano::block_type::state)
1609  	{
1610  		static_assert (sizeof (nano::epoch) == nano::block_details::size (), "block_details is larger than the epoch enum");
1611  		result += nano::block_details::size () + sizeof (nano::epoch);
1612  	}
1613  	return result;
1614  }
1615  void nano::block_sideband::serialize (nano::stream & stream_a, nano::block_type type_a) const
1616  {
1617  	nano::write (stream_a, successor.bytes);
1618  	if (type_a != nano::block_type::state && type_a != nano::block_type::open)
1619  	{
1620  		nano::write (stream_a, account.bytes);
1621  	}
1622  	if (type_a != nano::block_type::open)
1623  	{
1624  		nano::write (stream_a, boost::endian::native_to_big (height));
1625  	}
1626  	if (type_a == nano::block_type::receive || type_a == nano::block_type::change || type_a == nano::block_type::open)
1627  	{
1628  		nano::write (stream_a, balance.bytes);
1629  	}
1630  	nano::write (stream_a, boost::endian::native_to_big (timestamp));
1631  	if (type_a == nano::block_type::state)
1632  	{
1633  		details.serialize (stream_a);
1634  		nano::write (stream_a, static_cast<uint8_t> (source_epoch));
1635  	}
1636  }
1637  bool nano::block_sideband::deserialize (nano::stream & stream_a, nano::block_type type_a)
1638  {
1639  	bool result (false);
1640  	try
1641  	{
1642  		nano::read (stream_a, successor.bytes);
1643  		if (type_a != nano::block_type::state && type_a != nano::block_type::open)
1644  		{
1645  			nano::read (stream_a, account.bytes);
1646  		}
1647  		if (type_a != nano::block_type::open)
1648  		{
1649  			nano::read (stream_a, height);
1650  			boost::endian::big_to_native_inplace (height);
1651  		}
1652  		else
1653  		{
1654  			height = 1;
1655  		}
1656  		if (type_a == nano::block_type::receive || type_a == nano::block_type::change || type_a == nano::block_type::open)
1657  		{
1658  			nano::read (stream_a, balance.bytes);
1659  		}
1660  		nano::read (stream_a, timestamp);
1661  		boost::endian::big_to_native_inplace (timestamp);
1662  		if (type_a == nano::block_type::state)
1663  		{
1664  			result = details.deserialize (stream_a);
1665  			uint8_t source_epoch_uint8_t{ 0 };
1666  			nano::read (stream_a, source_epoch_uint8_t);
1667  			source_epoch = static_cast<nano::epoch> (source_epoch_uint8_t);
1668  		}
1669  	}
1670  	catch (std::runtime_error &)
1671  	{
1672  		result = true;
1673  	}
1674  	return result;
1675  }
1676  std::shared_ptr<nano::block> nano::block_uniquer::unique (std::shared_ptr<nano::block> const & block_a)
1677  {
1678  	auto result (block_a);
1679  	if (result != nullptr)
1680  	{
1681  		nano::uint256_union key (block_a->full_hash ());
1682  		nano::lock_guard<nano::mutex> lock{ mutex };
1683  		auto & existing (blocks[key]);
1684  		if (auto block_l = existing.lock ())
1685  		{
1686  			result = block_l;
1687  		}
1688  		else
1689  		{
1690  			existing = block_a;
1691  		}
1692  		release_assert (std::numeric_limits<CryptoPP::word32>::max () > blocks.size ());
1693  		for (auto i (0); i < cleanup_count && !blocks.empty (); ++i)
1694  		{
1695  			auto random_offset (nano::random_pool::generate_word32 (0, static_cast<CryptoPP::word32> (blocks.size () - 1)));
1696  			auto existing (std::next (blocks.begin (), random_offset));
1697  			if (existing == blocks.end ())
1698  			{
1699  				existing = blocks.begin ();
1700  			}
1701  			if (existing != blocks.end ())
1702  			{
1703  				if (auto block_l = existing->second.lock ())
1704  				{
1705  				}
1706  				else
1707  				{
1708  					blocks.erase (existing);
1709  				}
1710  			}
1711  		}
1712  	}
1713  	return result;
1714  }
1715  size_t nano::block_uniquer::size ()
1716  {
1717  	nano::lock_guard<nano::mutex> lock{ mutex };
1718  	return blocks.size ();
1719  }
1720  std::unique_ptr<nano::container_info_component> nano::collect_container_info (block_uniquer & block_uniquer, std::string const & name)
1721  {
1722  	auto count = block_uniquer.size ();
1723  	auto sizeof_element = sizeof (block_uniquer::value_type);
1724  	auto composite = std::make_unique<container_info_composite> (name);
1725  	composite->add_component (std::make_unique<container_info_leaf> (container_info{ "blocks", count, sizeof_element }));
1726  	return composite;
1727  }
</code></pre>
        </div>
        <div class="column">
            <h3>nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-blocks.cpp</h3>
            <pre><code>1  #include <nano/crypto_lib/random_pool.hpp>
2  #include <nano/lib/blocks.hpp>
3  #include <nano/lib/memory.hpp>
4  #include <nano/lib/numbers.hpp>
5  #include <nano/lib/threading.hpp>
6  #include <nano/secure/common.hpp>
7  #include <boost/endian/conversion.hpp>
8  #include <boost/property_tree/json_parser.hpp>
9  #include <bitset>
10  #include <cryptopp/words.h>
11  namespace
12  {
13  template <typename T>
14  bool blocks_equal (T const & first, nano::block const & second)
15  {
16  	static_assert (std::is_base_of<nano::block, T>::value, "Input parameter is not a block type");
17  	return (first.type () == second.type ()) && (static_cast<T const &> (second)) == first;
18  }
19  template <typename block>
20  std::shared_ptr<block> deserialize_block (nano::stream & stream_a)
21  {
22  	auto error (false);
23  	auto result = nano::make_shared<block> (error, stream_a);
24  	if (error)
25  	{
26  		result = nullptr;
27  	}
28  	return result;
29  }
30  }
31  void nano::block_memory_pool_purge ()
32  {
33  	nano::purge_shared_ptr_singleton_pool_memory<nano::open_block> ();
34  	nano::purge_shared_ptr_singleton_pool_memory<nano::state_block> ();
35  	nano::purge_shared_ptr_singleton_pool_memory<nano::send_block> ();
36  	nano::purge_shared_ptr_singleton_pool_memory<nano::change_block> ();
37  }
38  std::string nano::block::to_json () const
39  {
40  	std::string result;
41  	serialize_json (result);
42  	return result;
43  }
44  size_t nano::block::size (nano::block_type type_a)
45  {
46  	size_t result (0);
47  	switch (type_a)
48  	{
49  		case nano::block_type::invalid:
50  		case nano::block_type::not_a_block:
51  			debug_assert (false);
52  			break;
53  		case nano::block_type::send:
54  			result = nano::send_block::size;
55  			break;
56  		case nano::block_type::receive:
57  			result = nano::receive_block::size;
58  			break;
59  		case nano::block_type::change:
60  			result = nano::change_block::size;
61  			break;
62  		case nano::block_type::open:
63  			result = nano::open_block::size;
64  			break;
65  		case nano::block_type::state:
66  			result = nano::state_block::size;
67  			break;
68  	}
69  	return result;
70  }
71  nano::work_version nano::block::work_version () const
72  {
73  	return nano::work_version::work_1;
74  }
75  nano::block_hash nano::block::generate_hash () const
76  {
77  	nano::block_hash result;
78  	blake2b_state hash_l;
79  	auto status (blake2b_init (&hash_l, sizeof (result.bytes)));
80  	debug_assert (status == 0);
81  	hash (hash_l);
82  	status = blake2b_final (&hash_l, result.bytes.data (), sizeof (result.bytes));
83  	debug_assert (status == 0);
84  	return result;
85  }
86  void nano::block::refresh ()
87  {
88  	if (!cached_hash.is_zero ())
89  	{
90  		cached_hash = generate_hash ();
91  	}
92  }
93  nano::block_hash const & nano::block::hash () const
94  {
95  	if (!cached_hash.is_zero ())
96  	{
97  		debug_assert (cached_hash == generate_hash ());
98  	}
99  	else
100  	{
101  		cached_hash = generate_hash ();
102  	}
103  	return cached_hash;
104  }
105  nano::block_hash nano::block::full_hash () const
106  {
107  	nano::block_hash result;
108  	blake2b_state state;
109  	blake2b_init (&state, sizeof (result.bytes));
110  	blake2b_update (&state, hash ().bytes.data (), sizeof (hash ()));
111  	auto signature (block_signature ());
112  	blake2b_update (&state, signature.bytes.data (), sizeof (signature));
113  	auto work (block_work ());
114  	blake2b_update (&state, &work, sizeof (work));
115  	blake2b_final (&state, result.bytes.data (), sizeof (result.bytes));
116  	return result;
117  }
118  nano::block_sideband const & nano::block::sideband () const
119  {
120  	debug_assert (sideband_m.is_initialized ());
121  	return *sideband_m;
122  }
123  void nano::block::sideband_set (nano::block_sideband const & sideband_a)
124  {
125  	sideband_m = sideband_a;
126  }
127  bool nano::block::has_sideband () const
128  {
129  	return sideband_m.is_initialized ();
130  }
131  nano::account const & nano::block::representative () const
132  {
133  	static nano::account representative{};
134  	return representative;
135  }
136  nano::block_hash const & nano::block::source () const
137  {
138  	static nano::block_hash source{ 0 };
139  	return source;
140  }
141  nano::account const & nano::block::destination () const
142  {
143  	static nano::account destination{};
144  	return destination;
145  }
146  nano::link const & nano::block::link () const
147  {
148  	static nano::link link{ 0 };
149  	return link;
150  }
151  nano::account const & nano::block::account () const
152  {
153  	static nano::account account{};
154  	return account;
155  }
156  nano::qualified_root nano::block::qualified_root () const
157  {
158  	return nano::qualified_root (root (), previous ());
159  }
160  nano::amount const & nano::block::balance () const
161  {
162  	static nano::amount amount{ 0 };
163  	return amount;
164  }
165  void nano::send_block::visit (nano::block_visitor & visitor_a) const
166  {
167  	visitor_a.send_block (*this);
168  }
169  void nano::send_block::visit (nano::mutable_block_visitor & visitor_a)
170  {
171  	visitor_a.send_block (*this);
172  }
173  void nano::send_block::hash (blake2b_state & hash_a) const
174  {
175  	hashables.hash (hash_a);
176  }
177  uint64_t nano::send_block::block_work () const
178  {
179  	return work;
180  }
181  void nano::send_block::block_work_set (uint64_t work_a)
182  {
183  	work = work_a;
184  }
185  nano::send_hashables::send_hashables (nano::block_hash const & previous_a, nano::account const & destination_a, nano::amount const & balance_a) :
186  	previous (previous_a),
187  	destination (destination_a),
188  	balance (balance_a)
189  {
190  }
191  nano::send_hashables::send_hashables (bool & error_a, nano::stream & stream_a)
192  {
193  	try
194  	{
195  		nano::read (stream_a, previous.bytes);
196  		nano::read (stream_a, destination.bytes);
197  		nano::read (stream_a, balance.bytes);
198  	}
199  	catch (std::runtime_error const &)
200  	{
201  		error_a = true;
202  	}
203  }
204  nano::send_hashables::send_hashables (bool & error_a, boost::property_tree::ptree const & tree_a)
205  {
206  	try
207  	{
208  		auto previous_l (tree_a.get<std::string> ("previous"));
209  		auto destination_l (tree_a.get<std::string> ("destination"));
210  		auto balance_l (tree_a.get<std::string> ("balance"));
211  		error_a = previous.decode_hex (previous_l);
212  		if (!error_a)
213  		{
214  			error_a = destination.decode_account (destination_l);
215  			if (!error_a)
216  			{
217  				error_a = balance.decode_hex (balance_l);
218  			}
219  		}
220  	}
221  	catch (std::runtime_error const &)
222  	{
223  		error_a = true;
224  	}
225  }
226  void nano::send_hashables::hash (blake2b_state & hash_a) const
227  {
228  	auto status (blake2b_update (&hash_a, previous.bytes.data (), sizeof (previous.bytes)));
229  	debug_assert (status == 0);
230  	status = blake2b_update (&hash_a, destination.bytes.data (), sizeof (destination.bytes));
231  	debug_assert (status == 0);
232  	status = blake2b_update (&hash_a, balance.bytes.data (), sizeof (balance.bytes));
233  	debug_assert (status == 0);
234  }
235  void nano::send_block::serialize (nano::stream & stream_a) const
236  {
237  	write (stream_a, hashables.previous.bytes);
238  	write (stream_a, hashables.destination.bytes);
239  	write (stream_a, hashables.balance.bytes);
240  	write (stream_a, signature.bytes);
241  	write (stream_a, work);
242  }
243  bool nano::send_block::deserialize (nano::stream & stream_a)
244  {
245  	auto error (false);
246  	try
247  	{
248  		read (stream_a, hashables.previous.bytes);
249  		read (stream_a, hashables.destination.bytes);
250  		read (stream_a, hashables.balance.bytes);
251  		read (stream_a, signature.bytes);
252  		read (stream_a, work);
253  	}
254  	catch (std::exception const &)
255  	{
256  		error = true;
257  	}
258  	return error;
259  }
260  void nano::send_block::serialize_json (std::string & string_a, bool single_line) const
261  {
262  	boost::property_tree::ptree tree;
263  	serialize_json (tree);
264  	std::stringstream ostream;
265  	boost::property_tree::write_json (ostream, tree, !single_line);
266  	string_a = ostream.str ();
267  }
268  void nano::send_block::serialize_json (boost::property_tree::ptree & tree) const
269  {
270  	tree.put ("type", "send");
271  	std::string previous;
272  	hashables.previous.encode_hex (previous);
273  	tree.put ("previous", previous);
274  	tree.put ("destination", hashables.destination.to_account ());
275  	std::string balance;
276  	hashables.balance.encode_hex (balance);
277  	tree.put ("balance", balance);
278  	std::string signature_l;
279  	signature.encode_hex (signature_l);
280  	tree.put ("work", nano::to_string_hex (work));
281  	tree.put ("signature", signature_l);
282  }
283  bool nano::send_block::deserialize_json (boost::property_tree::ptree const & tree_a)
284  {
285  	auto error (false);
286  	try
287  	{
288  		debug_assert (tree_a.get<std::string> ("type") == "send");
289  		auto previous_l (tree_a.get<std::string> ("previous"));
290  		auto destination_l (tree_a.get<std::string> ("destination"));
291  		auto balance_l (tree_a.get<std::string> ("balance"));
292  		auto work_l (tree_a.get<std::string> ("work"));
293  		auto signature_l (tree_a.get<std::string> ("signature"));
294  		error = hashables.previous.decode_hex (previous_l);
295  		if (!error)
296  		{
297  			error = hashables.destination.decode_account (destination_l);
298  			if (!error)
299  			{
300  				error = hashables.balance.decode_hex (balance_l);
301  				if (!error)
302  				{
303  					error = nano::from_string_hex (work_l, work);
304  					if (!error)
305  					{
306  						error = signature.decode_hex (signature_l);
307  					}
308  				}
309  			}
310  		}
311  	}
312  	catch (std::runtime_error const &)
313  	{
314  		error = true;
315  	}
316  	return error;
317  }
318  nano::send_block::send_block (nano::block_hash const & previous_a, nano::account const & destination_a, nano::amount const & balance_a, nano::raw_key const & prv_a, nano::public_key const & pub_a, uint64_t work_a) :
319  	hashables (previous_a, destination_a, balance_a),
320  	signature (nano::sign_message (prv_a, pub_a, hash ())),
321  	work (work_a)
322  {
323  	debug_assert (destination_a != nullptr);
324  	debug_assert (pub_a != nullptr);
325  }
326  nano::send_block::send_block (bool & error_a, nano::stream & stream_a) :
327  	hashables (error_a, stream_a)
328  {
329  	if (!error_a)
330  	{
331  		try
332  		{
333  			nano::read (stream_a, signature.bytes);
334  			nano::read (stream_a, work);
335  		}
336  		catch (std::runtime_error const &)
337  		{
338  			error_a = true;
339  		}
340  	}
341  }
342  nano::send_block::send_block (bool & error_a, boost::property_tree::ptree const & tree_a) :
343  	hashables (error_a, tree_a)
344  {
345  	if (!error_a)
346  	{
347  		try
348  		{
349  			auto signature_l (tree_a.get<std::string> ("signature"));
350  			auto work_l (tree_a.get<std::string> ("work"));
351  			error_a = signature.decode_hex (signature_l);
352  			if (!error_a)
353  			{
354  				error_a = nano::from_string_hex (work_l, work);
355  			}
356  		}
357  		catch (std::runtime_error const &)
358  		{
359  			error_a = true;
360  		}
361  	}
362  }
363  bool nano::send_block::operator== (nano::block const & other_a) const
364  {
365  	return blocks_equal (*this, other_a);
366  }
367  bool nano::send_block::valid_predecessor (nano::block const & block_a) const
368  {
369  	bool result;
370  	switch (block_a.type ())
371  	{
372  		case nano::block_type::send:
373  		case nano::block_type::receive:
374  		case nano::block_type::open:
375  		case nano::block_type::change:
376  			result = true;
377  			break;
378  		default:
379  			result = false;
380  			break;
381  	}
382  	return result;
383  }
384  nano::block_type nano::send_block::type () const
385  {
386  	return nano::block_type::send;
387  }
388  bool nano::send_block::operator== (nano::send_block const & other_a) const
389  {
390  	auto result (hashables.destination == other_a.hashables.destination && hashables.previous == other_a.hashables.previous && hashables.balance == other_a.hashables.balance && work == other_a.work && signature == other_a.signature);
391  	return result;
392  }
393  nano::block_hash const & nano::send_block::previous () const
394  {
395  	return hashables.previous;
396  }
397  nano::account const & nano::send_block::destination () const
398  {
399  	return hashables.destination;
400  }
401  nano::root const & nano::send_block::root () const
402  {
403  	return hashables.previous;
404  }
405  nano::amount const & nano::send_block::balance () const
406  {
407  	return hashables.balance;
408  }
409  nano::signature const & nano::send_block::block_signature () const
410  {
411  	return signature;
412  }
413  void nano::send_block::signature_set (nano::signature const & signature_a)
414  {
415  	signature = signature_a;
416  }
417  nano::open_hashables::open_hashables (nano::block_hash const & source_a, nano::account const & representative_a, nano::account const & account_a) :
418  	source (source_a),
419  	representative (representative_a),
420  	account (account_a)
421  {
422  }
423  nano::open_hashables::open_hashables (bool & error_a, nano::stream & stream_a)
424  {
425  	try
426  	{
427  		nano::read (stream_a, source.bytes);
428  		nano::read (stream_a, representative.bytes);
429  		nano::read (stream_a, account.bytes);
430  	}
431  	catch (std::runtime_error const &)
432  	{
433  		error_a = true;
434  	}
435  }
436  nano::open_hashables::open_hashables (bool & error_a, boost::property_tree::ptree const & tree_a)
437  {
438  	try
439  	{
440  		auto source_l (tree_a.get<std::string> ("source"));
441  		auto representative_l (tree_a.get<std::string> ("representative"));
442  		auto account_l (tree_a.get<std::string> ("account"));
443  		error_a = source.decode_hex (source_l);
444  		if (!error_a)
445  		{
446  			error_a = representative.decode_account (representative_l);
447  			if (!error_a)
448  			{
449  				error_a = account.decode_account (account_l);
450  			}
451  		}
452  	}
453  	catch (std::runtime_error const &)
454  	{
455  		error_a = true;
456  	}
457  }
458  void nano::open_hashables::hash (blake2b_state & hash_a) const
459  {
460  	blake2b_update (&hash_a, source.bytes.data (), sizeof (source.bytes));
461  	blake2b_update (&hash_a, representative.bytes.data (), sizeof (representative.bytes));
462  	blake2b_update (&hash_a, account.bytes.data (), sizeof (account.bytes));
463  }
464  nano::open_block::open_block (nano::block_hash const & source_a, nano::account const & representative_a, nano::account const & account_a, nano::raw_key const & prv_a, nano::public_key const & pub_a, uint64_t work_a) :
465  	hashables (source_a, representative_a, account_a),
466  	signature (nano::sign_message (prv_a, pub_a, hash ())),
467  	work (work_a)
468  {
469  	debug_assert (representative_a != nullptr);
470  	debug_assert (account_a != nullptr);
471  	debug_assert (pub_a != nullptr);
472  }
473  nano::open_block::open_block (nano::block_hash const & source_a, nano::account const & representative_a, nano::account const & account_a, std::nullptr_t) :
474  	hashables (source_a, representative_a, account_a),
475  	work (0)
476  {
477  	debug_assert (representative_a != nullptr);
478  	debug_assert (account_a != nullptr);
479  	signature.clear ();
480  }
481  nano::open_block::open_block (bool & error_a, nano::stream & stream_a) :
482  	hashables (error_a, stream_a)
483  {
484  	if (!error_a)
485  	{
486  		try
487  		{
488  			nano::read (stream_a, signature);
489  			nano::read (stream_a, work);
490  		}
491  		catch (std::runtime_error const &)
492  		{
493  			error_a = true;
494  		}
495  	}
496  }
497  nano::open_block::open_block (bool & error_a, boost::property_tree::ptree const & tree_a) :
498  	hashables (error_a, tree_a)
499  {
500  	if (!error_a)
501  	{
502  		try
503  		{
504  			auto work_l (tree_a.get<std::string> ("work"));
505  			auto signature_l (tree_a.get<std::string> ("signature"));
506  			error_a = nano::from_string_hex (work_l, work);
507  			if (!error_a)
508  			{
509  				error_a = signature.decode_hex (signature_l);
510  			}
511  		}
512  		catch (std::runtime_error const &)
513  		{
514  			error_a = true;
515  		}
516  	}
517  }
518  void nano::open_block::hash (blake2b_state & hash_a) const
519  {
520  	hashables.hash (hash_a);
521  }
522  uint64_t nano::open_block::block_work () const
523  {
524  	return work;
525  }
526  void nano::open_block::block_work_set (uint64_t work_a)
527  {
528  	work = work_a;
529  }
530  nano::block_hash const & nano::open_block::previous () const
531  {
532  	static nano::block_hash result{ 0 };
533  	return result;
534  }
535  nano::account const & nano::open_block::account () const
536  {
537  	return hashables.account;
538  }
539  void nano::open_block::serialize (nano::stream & stream_a) const
540  {
541  	write (stream_a, hashables.source);
542  	write (stream_a, hashables.representative);
543  	write (stream_a, hashables.account);
544  	write (stream_a, signature);
545  	write (stream_a, work);
546  }
547  bool nano::open_block::deserialize (nano::stream & stream_a)
548  {
549  	auto error (false);
550  	try
551  	{
552  		read (stream_a, hashables.source);
553  		read (stream_a, hashables.representative);
554  		read (stream_a, hashables.account);
555  		read (stream_a, signature);
556  		read (stream_a, work);
557  	}
558  	catch (std::runtime_error const &)
559  	{
560  		error = true;
561  	}
562  	return error;
563  }
564  void nano::open_block::serialize_json (std::string & string_a, bool single_line) const
565  {
566  	boost::property_tree::ptree tree;
567  	serialize_json (tree);
568  	std::stringstream ostream;
569  	boost::property_tree::write_json (ostream, tree, !single_line);
570  	string_a = ostream.str ();
571  }
572  void nano::open_block::serialize_json (boost::property_tree::ptree & tree) const
573  {
574  	tree.put ("type", "open");
575  	tree.put ("source", hashables.source.to_string ());
576  	tree.put ("representative", representative ().to_account ());
577  	tree.put ("account", hashables.account.to_account ());
578  	std::string signature_l;
579  	signature.encode_hex (signature_l);
580  	tree.put ("work", nano::to_string_hex (work));
581  	tree.put ("signature", signature_l);
582  }
583  bool nano::open_block::deserialize_json (boost::property_tree::ptree const & tree_a)
584  {
585  	auto error (false);
586  	try
587  	{
588  		debug_assert (tree_a.get<std::string> ("type") == "open");
589  		auto source_l (tree_a.get<std::string> ("source"));
590  		auto representative_l (tree_a.get<std::string> ("representative"));
591  		auto account_l (tree_a.get<std::string> ("account"));
592  		auto work_l (tree_a.get<std::string> ("work"));
593  		auto signature_l (tree_a.get<std::string> ("signature"));
594  		error = hashables.source.decode_hex (source_l);
595  		if (!error)
596  		{
597  			error = hashables.representative.decode_hex (representative_l);
598  			if (!error)
599  			{
600  				error = hashables.account.decode_hex (account_l);
601  				if (!error)
602  				{
603  					error = nano::from_string_hex (work_l, work);
604  					if (!error)
605  					{
606  						error = signature.decode_hex (signature_l);
607  					}
608  				}
609  			}
610  		}
611  	}
612  	catch (std::runtime_error const &)
613  	{
614  		error = true;
615  	}
616  	return error;
617  }
618  void nano::open_block::visit (nano::block_visitor & visitor_a) const
619  {
620  	visitor_a.open_block (*this);
621  }
622  void nano::open_block::visit (nano::mutable_block_visitor & visitor_a)
623  {
624  	visitor_a.open_block (*this);
625  }
626  nano::block_type nano::open_block::type () const
627  {
628  	return nano::block_type::open;
629  }
630  bool nano::open_block::operator== (nano::block const & other_a) const
631  {
632  	return blocks_equal (*this, other_a);
633  }
634  bool nano::open_block::operator== (nano::open_block const & other_a) const
635  {
636  	return hashables.source == other_a.hashables.source && hashables.representative == other_a.hashables.representative && hashables.account == other_a.hashables.account && work == other_a.work && signature == other_a.signature;
637  }
638  bool nano::open_block::valid_predecessor (nano::block const & block_a) const
639  {
640  	return false;
641  }
642  nano::block_hash const & nano::open_block::source () const
643  {
644  	return hashables.source;
645  }
646  nano::root const & nano::open_block::root () const
647  {
648  	return hashables.account;
649  }
650  nano::account const & nano::open_block::representative () const
651  {
652  	return hashables.representative;
653  }
654  nano::signature const & nano::open_block::block_signature () const
655  {
656  	return signature;
657  }
658  void nano::open_block::signature_set (nano::signature const & signature_a)
659  {
660  	signature = signature_a;
661  }
662  nano::change_hashables::change_hashables (nano::block_hash const & previous_a, nano::account const & representative_a) :
663  	previous (previous_a),
664  	representative (representative_a)
665  {
666  }
667  nano::change_hashables::change_hashables (bool & error_a, nano::stream & stream_a)
668  {
669  	try
670  	{
671  		nano::read (stream_a, previous);
672  		nano::read (stream_a, representative);
673  	}
674  	catch (std::runtime_error const &)
675  	{
676  		error_a = true;
677  	}
678  }
679  nano::change_hashables::change_hashables (bool & error_a, boost::property_tree::ptree const & tree_a)
680  {
681  	try
682  	{
683  		auto previous_l (tree_a.get<std::string> ("previous"));
684  		auto representative_l (tree_a.get<std::string> ("representative"));
685  		error_a = previous.decode_hex (previous_l);
686  		if (!error_a)
687  		{
688  			error_a = representative.decode_account (representative_l);
689  		}
690  	}
691  	catch (std::runtime_error const &)
692  	{
693  		error_a = true;
694  	}
695  }
696  void nano::change_hashables::hash (blake2b_state & hash_a) const
697  {
698  	blake2b_update (&hash_a, previous.bytes.data (), sizeof (previous.bytes));
699  	blake2b_update (&hash_a, representative.bytes.data (), sizeof (representative.bytes));
700  }
701  nano::change_block::change_block (nano::block_hash const & previous_a, nano::account const & representative_a, nano::raw_key const & prv_a, nano::public_key const & pub_a, uint64_t work_a) :
702  	hashables (previous_a, representative_a),
703  	signature (nano::sign_message (prv_a, pub_a, hash ())),
704  	work (work_a)
705  {
706  	debug_assert (representative_a != nullptr);
707  	debug_assert (pub_a != nullptr);
708  }
709  nano::change_block::change_block (bool & error_a, nano::stream & stream_a) :
710  	hashables (error_a, stream_a)
711  {
712  	if (!error_a)
713  	{
714  		try
715  		{
716  			nano::read (stream_a, signature);
717  			nano::read (stream_a, work);
718  		}
719  		catch (std::runtime_error const &)
720  		{
721  			error_a = true;
722  		}
723  	}
724  }
725  nano::change_block::change_block (bool & error_a, boost::property_tree::ptree const & tree_a) :
726  	hashables (error_a, tree_a)
727  {
728  	if (!error_a)
729  	{
730  		try
731  		{
732  			auto work_l (tree_a.get<std::string> ("work"));
733  			auto signature_l (tree_a.get<std::string> ("signature"));
734  			error_a = nano::from_string_hex (work_l, work);
735  			if (!error_a)
736  			{
737  				error_a = signature.decode_hex (signature_l);
738  			}
739  		}
740  		catch (std::runtime_error const &)
741  		{
742  			error_a = true;
743  		}
744  	}
745  }
746  void nano::change_block::hash (blake2b_state & hash_a) const
747  {
748  	hashables.hash (hash_a);
749  }
750  uint64_t nano::change_block::block_work () const
751  {
752  	return work;
753  }
754  void nano::change_block::block_work_set (uint64_t work_a)
755  {
756  	work = work_a;
757  }
758  nano::block_hash const & nano::change_block::previous () const
759  {
760  	return hashables.previous;
761  }
762  void nano::change_block::serialize (nano::stream & stream_a) const
763  {
764  	write (stream_a, hashables.previous);
765  	write (stream_a, hashables.representative);
766  	write (stream_a, signature);
767  	write (stream_a, work);
768  }
769  bool nano::change_block::deserialize (nano::stream & stream_a)
770  {
771  	auto error (false);
772  	try
773  	{
774  		read (stream_a, hashables.previous);
775  		read (stream_a, hashables.representative);
776  		read (stream_a, signature);
777  		read (stream_a, work);
778  	}
779  	catch (std::runtime_error const &)
780  	{
781  		error = true;
782  	}
783  	return error;
784  }
785  void nano::change_block::serialize_json (std::string & string_a, bool single_line) const
786  {
787  	boost::property_tree::ptree tree;
788  	serialize_json (tree);
789  	std::stringstream ostream;
790  	boost::property_tree::write_json (ostream, tree, !single_line);
791  	string_a = ostream.str ();
792  }
793  void nano::change_block::serialize_json (boost::property_tree::ptree & tree) const
794  {
795  	tree.put ("type", "change");
796  	tree.put ("previous", hashables.previous.to_string ());
797  	tree.put ("representative", representative ().to_account ());
798  	tree.put ("work", nano::to_string_hex (work));
799  	std::string signature_l;
800  	signature.encode_hex (signature_l);
801  	tree.put ("signature", signature_l);
802  }
803  bool nano::change_block::deserialize_json (boost::property_tree::ptree const & tree_a)
804  {
805  	auto error (false);
806  	try
807  	{
808  		debug_assert (tree_a.get<std::string> ("type") == "change");
809  		auto previous_l (tree_a.get<std::string> ("previous"));
810  		auto representative_l (tree_a.get<std::string> ("representative"));
811  		auto work_l (tree_a.get<std::string> ("work"));
812  		auto signature_l (tree_a.get<std::string> ("signature"));
813  		error = hashables.previous.decode_hex (previous_l);
814  		if (!error)
815  		{
816  			error = hashables.representative.decode_hex (representative_l);
817  			if (!error)
818  			{
819  				error = nano::from_string_hex (work_l, work);
820  				if (!error)
821  				{
822  					error = signature.decode_hex (signature_l);
823  				}
824  			}
825  		}
826  	}
827  	catch (std::runtime_error const &)
828  	{
829  		error = true;
830  	}
831  	return error;
832  }
833  void nano::change_block::visit (nano::block_visitor & visitor_a) const
834  {
835  	visitor_a.change_block (*this);
836  }
837  void nano::change_block::visit (nano::mutable_block_visitor & visitor_a)
838  {
839  	visitor_a.change_block (*this);
840  }
841  nano::block_type nano::change_block::type () const
842  {
843  	return nano::block_type::change;
844  }
845  bool nano::change_block::operator== (nano::block const & other_a) const
846  {
847  	return blocks_equal (*this, other_a);
848  }
849  bool nano::change_block::operator== (nano::change_block const & other_a) const
850  {
851  	return hashables.previous == other_a.hashables.previous && hashables.representative == other_a.hashables.representative && work == other_a.work && signature == other_a.signature;
852  }
853  bool nano::change_block::valid_predecessor (nano::block const & block_a) const
854  {
855  	bool result;
856  	switch (block_a.type ())
857  	{
858  		case nano::block_type::send:
859  		case nano::block_type::receive:
860  		case nano::block_type::open:
861  		case nano::block_type::change:
862  			result = true;
863  			break;
864  		default:
865  			result = false;
866  			break;
867  	}
868  	return result;
869  }
870  nano::root const & nano::change_block::root () const
871  {
872  	return hashables.previous;
873  }
874  nano::account const & nano::change_block::representative () const
875  {
876  	return hashables.representative;
877  }
878  nano::signature const & nano::change_block::block_signature () const
879  {
880  	return signature;
881  }
882  void nano::change_block::signature_set (nano::signature const & signature_a)
883  {
884  	signature = signature_a;
885  }
886  nano::state_hashables::state_hashables (nano::account const & account_a, nano::block_hash const & previous_a, nano::account const & representative_a, nano::amount const & balance_a, nano::link const & link_a) :
887  	account (account_a),
888  	previous (previous_a),
889  	representative (representative_a),
890  	balance (balance_a),
891  	link (link_a)
892  {
893  }
894  nano::state_hashables::state_hashables (bool & error_a, nano::stream & stream_a)
895  {
896  	try
897  	{
898  		nano::read (stream_a, account);
899  		nano::read (stream_a, previous);
900  		nano::read (stream_a, representative);
901  		nano::read (stream_a, balance);
902  		nano::read (stream_a, link);
903  	}
904  	catch (std::runtime_error const &)
905  	{
906  		error_a = true;
907  	}
908  }
909  nano::state_hashables::state_hashables (bool & error_a, boost::property_tree::ptree const & tree_a)
910  {
911  	try
912  	{
913  		auto account_l (tree_a.get<std::string> ("account"));
914  		auto previous_l (tree_a.get<std::string> ("previous"));
915  		auto representative_l (tree_a.get<std::string> ("representative"));
916  		auto balance_l (tree_a.get<std::string> ("balance"));
917  		auto link_l (tree_a.get<std::string> ("link"));
918  		error_a = account.decode_account (account_l);
919  		if (!error_a)
920  		{
921  			error_a = previous.decode_hex (previous_l);
922  			if (!error_a)
923  			{
924  				error_a = representative.decode_account (representative_l);
925  				if (!error_a)
926  				{
927  					error_a = balance.decode_dec (balance_l);
928  					if (!error_a)
929  					{
930  						error_a = link.decode_account (link_l) && link.decode_hex (link_l);
931  					}
932  				}
933  			}
934  		}
935  	}
936  	catch (std::runtime_error const &)
937  	{
938  		error_a = true;
939  	}
940  }
941  void nano::state_hashables::hash (blake2b_state & hash_a) const
942  {
943  	blake2b_update (&hash_a, account.bytes.data (), sizeof (account.bytes));
944  	blake2b_update (&hash_a, previous.bytes.data (), sizeof (previous.bytes));
945  	blake2b_update (&hash_a, representative.bytes.data (), sizeof (representative.bytes));
946  	blake2b_update (&hash_a, balance.bytes.data (), sizeof (balance.bytes));
947  	blake2b_update (&hash_a, link.bytes.data (), sizeof (link.bytes));
948  }
949  nano::state_block::state_block (nano::account const & account_a, nano::block_hash const & previous_a, nano::account const & representative_a, nano::amount const & balance_a, nano::link const & link_a, nano::raw_key const & prv_a, nano::public_key const & pub_a, uint64_t work_a) :
950  	hashables (account_a, previous_a, representative_a, balance_a, link_a),
951  	signature (nano::sign_message (prv_a, pub_a, hash ())),
952  	work (work_a)
953  {
954  	debug_assert (account_a != nullptr);
955  	debug_assert (representative_a != nullptr);
956  	debug_assert (link_a.as_account () != nullptr);
957  	debug_assert (pub_a != nullptr);
958  }
959  nano::state_block::state_block (bool & error_a, nano::stream & stream_a) :
960  	hashables (error_a, stream_a)
961  {
962  	if (!error_a)
963  	{
964  		try
965  		{
966  			nano::read (stream_a, signature);
967  			nano::read (stream_a, work);
968  			boost::endian::big_to_native_inplace (work);
969  		}
970  		catch (std::runtime_error const &)
971  		{
972  			error_a = true;
973  		}
974  	}
975  }
976  nano::state_block::state_block (bool & error_a, boost::property_tree::ptree const & tree_a) :
977  	hashables (error_a, tree_a)
978  {
979  	if (!error_a)
980  	{
981  		try
982  		{
983  			auto type_l (tree_a.get<std::string> ("type"));
984  			auto signature_l (tree_a.get<std::string> ("signature"));
985  			auto work_l (tree_a.get<std::string> ("work"));
986  			error_a = type_l != "state";
987  			if (!error_a)
988  			{
989  				error_a = nano::from_string_hex (work_l, work);
990  				if (!error_a)
991  				{
992  					error_a = signature.decode_hex (signature_l);
993  				}
994  			}
995  		}
996  		catch (std::runtime_error const &)
997  		{
998  			error_a = true;
999  		}
1000  	}
1001  }
1002  void nano::state_block::hash (blake2b_state & hash_a) const
1003  {
1004  	nano::uint256_union preamble (static_cast<uint64_t> (nano::block_type::state));
1005  	blake2b_update (&hash_a, preamble.bytes.data (), preamble.bytes.size ());
1006  	hashables.hash (hash_a);
1007  }
1008  uint64_t nano::state_block::block_work () const
1009  {
1010  	return work;
1011  }
1012  void nano::state_block::block_work_set (uint64_t work_a)
1013  {
1014  	work = work_a;
1015  }
1016  nano::block_hash const & nano::state_block::previous () const
1017  {
1018  	return hashables.previous;
1019  }
1020  nano::account const & nano::state_block::account () const
1021  {
1022  	return hashables.account;
1023  }
1024  void nano::state_block::serialize (nano::stream & stream_a) const
1025  {
1026  	write (stream_a, hashables.account);
1027  	write (stream_a, hashables.previous);
1028  	write (stream_a, hashables.representative);
1029  	write (stream_a, hashables.balance);
1030  	write (stream_a, hashables.link);
1031  	write (stream_a, signature);
1032  	write (stream_a, boost::endian::native_to_big (work));
1033  }
1034  bool nano::state_block::deserialize (nano::stream & stream_a)
1035  {
1036  	auto error (false);
1037  	try
1038  	{
1039  		read (stream_a, hashables.account);
1040  		read (stream_a, hashables.previous);
1041  		read (stream_a, hashables.representative);
1042  		read (stream_a, hashables.balance);
1043  		read (stream_a, hashables.link);
1044  		read (stream_a, signature);
1045  		read (stream_a, work);
1046  		boost::endian::big_to_native_inplace (work);
1047  	}
1048  	catch (std::runtime_error const &)
1049  	{
1050  		error = true;
1051  	}
1052  	return error;
1053  }
1054  void nano::state_block::serialize_json (std::string & string_a, bool single_line) const
1055  {
1056  	boost::property_tree::ptree tree;
1057  	serialize_json (tree);
1058  	std::stringstream ostream;
1059  	boost::property_tree::write_json (ostream, tree, !single_line);
1060  	string_a = ostream.str ();
1061  }
1062  void nano::state_block::serialize_json (boost::property_tree::ptree & tree) const
1063  {
1064  	tree.put ("type", "state");
1065  	tree.put ("account", hashables.account.to_account ());
1066  	tree.put ("previous", hashables.previous.to_string ());
1067  	tree.put ("representative", representative ().to_account ());
1068  	tree.put ("balance", hashables.balance.to_string_dec ());
1069  	tree.put ("link", hashables.link.to_string ());
1070  	tree.put ("link_as_account", hashables.link.to_account ());
1071  	std::string signature_l;
1072  	signature.encode_hex (signature_l);
1073  	tree.put ("signature", signature_l);
1074  	tree.put ("work", nano::to_string_hex (work));
1075  }
1076  bool nano::state_block::deserialize_json (boost::property_tree::ptree const & tree_a)
1077  {
1078  	auto error (false);
1079  	try
1080  	{
1081  		debug_assert (tree_a.get<std::string> ("type") == "state");
1082  		auto account_l (tree_a.get<std::string> ("account"));
1083  		auto previous_l (tree_a.get<std::string> ("previous"));
1084  		auto representative_l (tree_a.get<std::string> ("representative"));
1085  		auto balance_l (tree_a.get<std::string> ("balance"));
1086  		auto link_l (tree_a.get<std::string> ("link"));
1087  		auto work_l (tree_a.get<std::string> ("work"));
1088  		auto signature_l (tree_a.get<std::string> ("signature"));
1089  		error = hashables.account.decode_account (account_l);
1090  		if (!error)
1091  		{
1092  			error = hashables.previous.decode_hex (previous_l);
1093  			if (!error)
1094  			{
1095  				error = hashables.representative.decode_account (representative_l);
1096  				if (!error)
1097  				{
1098  					error = hashables.balance.decode_dec (balance_l);
1099  					if (!error)
1100  					{
1101  						error = hashables.link.decode_account (link_l) && hashables.link.decode_hex (link_l);
1102  						if (!error)
1103  						{
1104  							error = nano::from_string_hex (work_l, work);
1105  							if (!error)
1106  							{
1107  								error = signature.decode_hex (signature_l);
1108  							}
1109  						}
1110  					}
1111  				}
1112  			}
1113  		}
1114  	}
1115  	catch (std::runtime_error const &)
1116  	{
1117  		error = true;
1118  	}
1119  	return error;
1120  }
1121  void nano::state_block::visit (nano::block_visitor & visitor_a) const
1122  {
1123  	visitor_a.state_block (*this);
1124  }
1125  void nano::state_block::visit (nano::mutable_block_visitor & visitor_a)
1126  {
1127  	visitor_a.state_block (*this);
1128  }
1129  nano::block_type nano::state_block::type () const
1130  {
1131  	return nano::block_type::state;
1132  }
1133  bool nano::state_block::operator== (nano::block const & other_a) const
1134  {
1135  	return blocks_equal (*this, other_a);
1136  }
1137  bool nano::state_block::operator== (nano::state_block const & other_a) const
1138  {
1139  	return hashables.account == other_a.hashables.account && hashables.previous == other_a.hashables.previous && hashables.representative == other_a.hashables.representative && hashables.balance == other_a.hashables.balance && hashables.link == other_a.hashables.link && signature == other_a.signature && work == other_a.work;
1140  }
1141  bool nano::state_block::valid_predecessor (nano::block const & block_a) const
1142  {
1143  	return true;
1144  }
1145  nano::root const & nano::state_block::root () const
1146  {
1147  	if (!hashables.previous.is_zero ())
1148  	{
1149  		return hashables.previous;
1150  	}
1151  	else
1152  	{
1153  		return hashables.account;
1154  	}
1155  }
1156  nano::link const & nano::state_block::link () const
1157  {
1158  	return hashables.link;
1159  }
1160  nano::account const & nano::state_block::representative () const
1161  {
1162  	return hashables.representative;
1163  }
1164  nano::amount const & nano::state_block::balance () const
1165  {
1166  	return hashables.balance;
1167  }
1168  nano::signature const & nano::state_block::block_signature () const
1169  {
1170  	return signature;
1171  }
1172  void nano::state_block::signature_set (nano::signature const & signature_a)
1173  {
1174  	signature = signature_a;
1175  }
1176  std::shared_ptr<nano::block> nano::deserialize_block_json (boost::property_tree::ptree const & tree_a, nano::block_uniquer * uniquer_a)
1177  {
1178  	std::shared_ptr<nano::block> result;
1179  	try
1180  	{
1181  		auto type (tree_a.get<std::string> ("type"));
1182  		bool error (false);
1183  		std::unique_ptr<nano::block> obj;
1184  		if (type == "receive")
1185  		{
1186  			obj = std::make_unique<nano::receive_block> (error, tree_a);
1187  		}
1188  		else if (type == "send")
1189  		{
1190  			obj = std::make_unique<nano::send_block> (error, tree_a);
1191  		}
1192  		else if (type == "open")
1193  		{
1194  			obj = std::make_unique<nano::open_block> (error, tree_a);
1195  		}
1196  		else if (type == "change")
1197  		{
1198  			obj = std::make_unique<nano::change_block> (error, tree_a);
1199  		}
1200  		else if (type == "state")
1201  		{
1202  			obj = std::make_unique<nano::state_block> (error, tree_a);
1203  		}
1204  		if (!error)
1205  		{
1206  			result = std::move (obj);
1207  		}
1208  	}
1209  	catch (std::runtime_error const &)
1210  	{
1211  	}
1212  	if (uniquer_a != nullptr)
1213  	{
1214  		result = uniquer_a->unique (result);
1215  	}
1216  	return result;
1217  }
1218  void nano::serialize_block_type (nano::stream & stream, const nano::block_type & type)
1219  {
1220  	nano::write (stream, type);
1221  }
1222  void nano::serialize_block (nano::stream & stream_a, nano::block const & block_a)
1223  {
1224  	nano::serialize_block_type (stream_a, block_a.type ());
1225  	block_a.serialize (stream_a);
1226  }
1227  std::shared_ptr<nano::block> nano::deserialize_block (nano::stream & stream_a)
1228  {
1229  	nano::block_type type;
1230  	auto error (try_read (stream_a, type));
1231  	std::shared_ptr<nano::block> result;
1232  	if (!error)
1233  	{
1234  		result = nano::deserialize_block (stream_a, type);
1235  	}
1236  	return result;
1237  }
1238  std::shared_ptr<nano::block> nano::deserialize_block (nano::stream & stream_a, nano::block_type type_a, nano::block_uniquer * uniquer_a)
1239  {
1240  	std::shared_ptr<nano::block> result;
1241  	switch (type_a)
1242  	{
1243  		case nano::block_type::receive:
1244  		{
1245  			result = ::deserialize_block<nano::receive_block> (stream_a);
1246  			break;
1247  		}
1248  		case nano::block_type::send:
1249  		{
1250  			result = ::deserialize_block<nano::send_block> (stream_a);
1251  			break;
1252  		}
1253  		case nano::block_type::open:
1254  		{
1255  			result = ::deserialize_block<nano::open_block> (stream_a);
1256  			break;
1257  		}
1258  		case nano::block_type::change:
1259  		{
1260  			result = ::deserialize_block<nano::change_block> (stream_a);
1261  			break;
1262  		}
1263  		case nano::block_type::state:
1264  		{
1265  			result = ::deserialize_block<nano::state_block> (stream_a);
1266  			break;
1267  		}
1268  		default:
1269  		{
1270  			return {};
1271  		}
1272  	}
1273  	if (result && uniquer_a != nullptr)
1274  	{
1275  		result = uniquer_a->unique (result);
1276  	}
1277  	return result;
1278  }
1279  void nano::receive_block::visit (nano::block_visitor & visitor_a) const
1280  {
1281  	visitor_a.receive_block (*this);
1282  }
1283  void nano::receive_block::visit (nano::mutable_block_visitor & visitor_a)
1284  {
1285  	visitor_a.receive_block (*this);
1286  }
1287  bool nano::receive_block::operator== (nano::receive_block const & other_a) const
1288  {
1289  	auto result (hashables.previous == other_a.hashables.previous && hashables.source == other_a.hashables.source && work == other_a.work && signature == other_a.signature);
1290  	return result;
1291  }
1292  void nano::receive_block::serialize (nano::stream & stream_a) const
1293  {
1294  	write (stream_a, hashables.previous.bytes);
1295  	write (stream_a, hashables.source.bytes);
1296  	write (stream_a, signature.bytes);
1297  	write (stream_a, work);
1298  }
1299  bool nano::receive_block::deserialize (nano::stream & stream_a)
1300  {
1301  	auto error (false);
1302  	try
1303  	{
1304  		read (stream_a, hashables.previous.bytes);
1305  		read (stream_a, hashables.source.bytes);
1306  		read (stream_a, signature.bytes);
1307  		read (stream_a, work);
1308  	}
1309  	catch (std::runtime_error const &)
1310  	{
1311  		error = true;
1312  	}
1313  	return error;
1314  }
1315  void nano::receive_block::serialize_json (std::string & string_a, bool single_line) const
1316  {
1317  	boost::property_tree::ptree tree;
1318  	serialize_json (tree);
1319  	std::stringstream ostream;
<span onclick='openModal()' class='match'>1320  	boost::property_tree::write_json (ostream, tree, !single_line);
1321  	string_a = ostream.str ();
1322  }
1323  void nano::receive_block::serialize_json (boost::property_tree::ptree & tree) const
1324  {
1325  	tree.put ("type", "receive");
1326  	std::string previous;
</span>1327  	hashables.previous.encode_hex (previous);
1328  	tree.put ("previous", previous);
1329  	std::string source;
1330  	hashables.source.encode_hex (source);
1331  	tree.put ("source", source);
1332  	std::string signature_l;
1333  	signature.encode_hex (signature_l);
1334  	tree.put ("work", nano::to_string_hex (work));
1335  	tree.put ("signature", signature_l);
1336  }
1337  bool nano::receive_block::deserialize_json (boost::property_tree::ptree const & tree_a)
1338  {
1339  	auto error (false);
1340  	try
1341  	{
1342  		debug_assert (tree_a.get<std::string> ("type") == "receive");
1343  		auto previous_l (tree_a.get<std::string> ("previous"));
1344  		auto source_l (tree_a.get<std::string> ("source"));
1345  		auto work_l (tree_a.get<std::string> ("work"));
1346  		auto signature_l (tree_a.get<std::string> ("signature"));
1347  		error = hashables.previous.decode_hex (previous_l);
1348  		if (!error)
1349  		{
1350  			error = hashables.source.decode_hex (source_l);
1351  			if (!error)
1352  			{
1353  				error = nano::from_string_hex (work_l, work);
1354  				if (!error)
1355  				{
1356  					error = signature.decode_hex (signature_l);
1357  				}
1358  			}
1359  		}
1360  	}
1361  	catch (std::runtime_error const &)
1362  	{
1363  		error = true;
1364  	}
1365  	return error;
1366  }
1367  nano::receive_block::receive_block (nano::block_hash const & previous_a, nano::block_hash const & source_a, nano::raw_key const & prv_a, nano::public_key const & pub_a, uint64_t work_a) :
1368  	hashables (previous_a, source_a),
1369  	signature (nano::sign_message (prv_a, pub_a, hash ())),
1370  	work (work_a)
1371  {
1372  	debug_assert (pub_a != nullptr);
1373  }
1374  nano::receive_block::receive_block (bool & error_a, nano::stream & stream_a) :
1375  	hashables (error_a, stream_a)
1376  {
1377  	if (!error_a)
1378  	{
1379  		try
1380  		{
1381  			nano::read (stream_a, signature);
1382  			nano::read (stream_a, work);
1383  		}
1384  		catch (std::runtime_error const &)
1385  		{
1386  			error_a = true;
1387  		}
1388  	}
1389  }
1390  nano::receive_block::receive_block (bool & error_a, boost::property_tree::ptree const & tree_a) :
1391  	hashables (error_a, tree_a)
1392  {
1393  	if (!error_a)
1394  	{
1395  		try
1396  		{
1397  			auto signature_l (tree_a.get<std::string> ("signature"));
1398  			auto work_l (tree_a.get<std::string> ("work"));
1399  			error_a = signature.decode_hex (signature_l);
1400  			if (!error_a)
1401  			{
1402  				error_a = nano::from_string_hex (work_l, work);
1403  			}
1404  		}
1405  		catch (std::runtime_error const &)
1406  		{
1407  			error_a = true;
1408  		}
1409  	}
1410  }
1411  void nano::receive_block::hash (blake2b_state & hash_a) const
1412  {
1413  	hashables.hash (hash_a);
1414  }
1415  uint64_t nano::receive_block::block_work () const
1416  {
1417  	return work;
1418  }
1419  void nano::receive_block::block_work_set (uint64_t work_a)
1420  {
1421  	work = work_a;
1422  }
1423  bool nano::receive_block::operator== (nano::block const & other_a) const
1424  {
1425  	return blocks_equal (*this, other_a);
1426  }
1427  bool nano::receive_block::valid_predecessor (nano::block const & block_a) const
1428  {
1429  	bool result;
1430  	switch (block_a.type ())
1431  	{
1432  		case nano::block_type::send:
1433  		case nano::block_type::receive:
1434  		case nano::block_type::open:
1435  		case nano::block_type::change:
1436  			result = true;
1437  			break;
1438  		default:
1439  			result = false;
1440  			break;
1441  	}
1442  	return result;
1443  }
1444  nano::block_hash const & nano::receive_block::previous () const
1445  {
1446  	return hashables.previous;
1447  }
1448  nano::block_hash const & nano::receive_block::source () const
1449  {
1450  	return hashables.source;
1451  }
1452  nano::root const & nano::receive_block::root () const
1453  {
1454  	return hashables.previous;
1455  }
1456  nano::signature const & nano::receive_block::block_signature () const
1457  {
1458  	return signature;
1459  }
1460  void nano::receive_block::signature_set (nano::signature const & signature_a)
1461  {
1462  	signature = signature_a;
1463  }
1464  nano::block_type nano::receive_block::type () const
1465  {
1466  	return nano::block_type::receive;
1467  }
1468  nano::receive_hashables::receive_hashables (nano::block_hash const & previous_a, nano::block_hash const & source_a) :
1469  	previous (previous_a),
1470  	source (source_a)
1471  {
1472  }
1473  nano::receive_hashables::receive_hashables (bool & error_a, nano::stream & stream_a)
1474  {
1475  	try
1476  	{
1477  		nano::read (stream_a, previous.bytes);
1478  		nano::read (stream_a, source.bytes);
1479  	}
1480  	catch (std::runtime_error const &)
1481  	{
1482  		error_a = true;
1483  	}
1484  }
1485  nano::receive_hashables::receive_hashables (bool & error_a, boost::property_tree::ptree const & tree_a)
1486  {
1487  	try
1488  	{
1489  		auto previous_l (tree_a.get<std::string> ("previous"));
1490  		auto source_l (tree_a.get<std::string> ("source"));
1491  		error_a = previous.decode_hex (previous_l);
1492  		if (!error_a)
1493  		{
1494  			error_a = source.decode_hex (source_l);
1495  		}
1496  	}
1497  	catch (std::runtime_error const &)
1498  	{
1499  		error_a = true;
1500  	}
1501  }
1502  void nano::receive_hashables::hash (blake2b_state & hash_a) const
1503  {
1504  	blake2b_update (&hash_a, previous.bytes.data (), sizeof (previous.bytes));
1505  	blake2b_update (&hash_a, source.bytes.data (), sizeof (source.bytes));
1506  }
1507  nano::block_details::block_details (nano::epoch const epoch_a, bool const is_send_a, bool const is_receive_a, bool const is_epoch_a) :
1508  	epoch (epoch_a), is_send (is_send_a), is_receive (is_receive_a), is_epoch (is_epoch_a)
1509  {
1510  }
1511  bool nano::block_details::operator== (nano::block_details const & other_a) const
1512  {
1513  	return epoch == other_a.epoch && is_send == other_a.is_send && is_receive == other_a.is_receive && is_epoch == other_a.is_epoch;
1514  }
1515  uint8_t nano::block_details::packed () const
1516  {
1517  	std::bitset<8> result (static_cast<uint8_t> (epoch));
1518  	result.set (7, is_send);
1519  	result.set (6, is_receive);
1520  	result.set (5, is_epoch);
1521  	return static_cast<uint8_t> (result.to_ulong ());
1522  }
1523  void nano::block_details::unpack (uint8_t details_a)
1524  {
1525  	constexpr std::bitset<8> epoch_mask{ 0b00011111 };
1526  	auto as_bitset = static_cast<std::bitset<8>> (details_a);
1527  	is_send = as_bitset.test (7);
1528  	is_receive = as_bitset.test (6);
1529  	is_epoch = as_bitset.test (5);
1530  	epoch = static_cast<nano::epoch> ((as_bitset & epoch_mask).to_ulong ());
1531  }
1532  void nano::block_details::serialize (nano::stream & stream_a) const
1533  {
1534  	nano::write (stream_a, packed ());
1535  }
1536  bool nano::block_details::deserialize (nano::stream & stream_a)
1537  {
1538  	bool result (false);
1539  	try
1540  	{
1541  		uint8_t packed{ 0 };
1542  		nano::read (stream_a, packed);
1543  		unpack (packed);
1544  	}
1545  	catch (std::runtime_error &)
1546  	{
1547  		result = true;
1548  	}
1549  	return result;
1550  }
1551  std::string nano::state_subtype (nano::block_details const details_a)
1552  {
1553  	debug_assert (details_a.is_epoch + details_a.is_receive + details_a.is_send <= 1);
1554  	if (details_a.is_send)
1555  	{
1556  		return "send";
1557  	}
1558  	else if (details_a.is_receive)
1559  	{
1560  		return "receive";
1561  	}
1562  	else if (details_a.is_epoch)
1563  	{
1564  		return "epoch";
1565  	}
1566  	else
1567  	{
1568  		return "change";
1569  	}
1570  }
1571  nano::block_sideband::block_sideband (nano::account const & account_a, nano::block_hash const & successor_a, nano::amount const & balance_a, uint64_t const height_a, nano::seconds_t const timestamp_a, nano::block_details const & details_a, nano::epoch const source_epoch_a) :
1572  	successor (successor_a),
1573  	account (account_a),
1574  	balance (balance_a),
1575  	height (height_a),
1576  	timestamp (timestamp_a),
1577  	details (details_a),
1578  	source_epoch (source_epoch_a)
1579  {
1580  }
1581  nano::block_sideband::block_sideband (nano::account const & account_a, nano::block_hash const & successor_a, nano::amount const & balance_a, uint64_t const height_a, nano::seconds_t const timestamp_a, nano::epoch const epoch_a, bool const is_send, bool const is_receive, bool const is_epoch, nano::epoch const source_epoch_a) :
1582  	successor (successor_a),
1583  	account (account_a),
1584  	balance (balance_a),
1585  	height (height_a),
1586  	timestamp (timestamp_a),
1587  	details (epoch_a, is_send, is_receive, is_epoch),
1588  	source_epoch (source_epoch_a)
1589  {
1590  }
1591  size_t nano::block_sideband::size (nano::block_type type_a)
1592  {
1593  	size_t result (0);
1594  	result += sizeof (successor);
1595  	if (type_a != nano::block_type::state && type_a != nano::block_type::open)
1596  	{
1597  		result += sizeof (account);
1598  	}
1599  	if (type_a != nano::block_type::open)
1600  	{
1601  		result += sizeof (height);
1602  	}
1603  	if (type_a == nano::block_type::receive || type_a == nano::block_type::change || type_a == nano::block_type::open)
1604  	{
1605  		result += sizeof (balance);
1606  	}
1607  	result += sizeof (timestamp);
1608  	if (type_a == nano::block_type::state)
1609  	{
1610  		static_assert (sizeof (nano::epoch) == nano::block_details::size (), "block_details is larger than the epoch enum");
1611  		result += nano::block_details::size () + sizeof (nano::epoch);
1612  	}
1613  	return result;
1614  }
1615  void nano::block_sideband::serialize (nano::stream & stream_a, nano::block_type type_a) const
1616  {
1617  	nano::write (stream_a, successor.bytes);
1618  	if (type_a != nano::block_type::state && type_a != nano::block_type::open)
1619  	{
1620  		nano::write (stream_a, account.bytes);
1621  	}
1622  	if (type_a != nano::block_type::open)
1623  	{
1624  		nano::write (stream_a, boost::endian::native_to_big (height));
1625  	}
1626  	if (type_a == nano::block_type::receive || type_a == nano::block_type::change || type_a == nano::block_type::open)
1627  	{
1628  		nano::write (stream_a, balance.bytes);
1629  	}
1630  	nano::write (stream_a, boost::endian::native_to_big (timestamp));
1631  	if (type_a == nano::block_type::state)
1632  	{
1633  		details.serialize (stream_a);
1634  		nano::write (stream_a, static_cast<uint8_t> (source_epoch));
1635  	}
1636  }
1637  bool nano::block_sideband::deserialize (nano::stream & stream_a, nano::block_type type_a)
1638  {
1639  	bool result (false);
1640  	try
1641  	{
1642  		nano::read (stream_a, successor.bytes);
1643  		if (type_a != nano::block_type::state && type_a != nano::block_type::open)
1644  		{
1645  			nano::read (stream_a, account.bytes);
1646  		}
1647  		if (type_a != nano::block_type::open)
1648  		{
1649  			nano::read (stream_a, height);
1650  			boost::endian::big_to_native_inplace (height);
1651  		}
1652  		else
1653  		{
1654  			height = 1;
1655  		}
1656  		if (type_a == nano::block_type::receive || type_a == nano::block_type::change || type_a == nano::block_type::open)
1657  		{
1658  			nano::read (stream_a, balance.bytes);
1659  		}
1660  		nano::read (stream_a, timestamp);
1661  		boost::endian::big_to_native_inplace (timestamp);
1662  		if (type_a == nano::block_type::state)
1663  		{
1664  			result = details.deserialize (stream_a);
1665  			uint8_t source_epoch_uint8_t{ 0 };
1666  			nano::read (stream_a, source_epoch_uint8_t);
1667  			source_epoch = static_cast<nano::epoch> (source_epoch_uint8_t);
1668  		}
1669  	}
1670  	catch (std::runtime_error &)
1671  	{
1672  		result = true;
1673  	}
1674  	return result;
1675  }
1676  std::shared_ptr<nano::block> nano::block_uniquer::unique (std::shared_ptr<nano::block> const & block_a)
1677  {
1678  	auto result (block_a);
1679  	if (result != nullptr)
1680  	{
1681  		nano::uint256_union key (block_a->full_hash ());
1682  		nano::lock_guard<nano::mutex> lock{ mutex };
1683  		auto & existing (blocks[key]);
1684  		if (auto block_l = existing.lock ())
1685  		{
1686  			result = block_l;
1687  		}
1688  		else
1689  		{
1690  			existing = block_a;
1691  		}
1692  		release_assert (std::numeric_limits<CryptoPP::word32>::max () > blocks.size ());
1693  		for (auto i (0); i < cleanup_count && !blocks.empty (); ++i)
1694  		{
1695  			auto random_offset (nano::random_pool::generate_word32 (0, static_cast<CryptoPP::word32> (blocks.size () - 1)));
1696  			auto existing (std::next (blocks.begin (), random_offset));
1697  			if (existing == blocks.end ())
1698  			{
1699  				existing = blocks.begin ();
1700  			}
1701  			if (existing != blocks.end ())
1702  			{
1703  				if (auto block_l = existing->second.lock ())
1704  				{
1705  				}
1706  				else
1707  				{
1708  					blocks.erase (existing);
1709  				}
1710  			}
1711  		}
1712  	}
1713  	return result;
1714  }
1715  size_t nano::block_uniquer::size ()
1716  {
1717  	nano::lock_guard<nano::mutex> lock{ mutex };
1718  	return blocks.size ();
1719  }
1720  std::unique_ptr<nano::container_info_component> nano::collect_container_info (block_uniquer & block_uniquer, std::string const & name)
1721  {
1722  	auto count = block_uniquer.size ();
1723  	auto sizeof_element = sizeof (block_uniquer::value_type);
1724  	auto composite = std::make_unique<container_info_composite> (name);
1725  	composite->add_component (std::make_unique<container_info_leaf> (container_info{ "blocks", count, sizeof_element }));
1726  	return composite;
1727  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-blocks.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from nano-node-MDEwOlJlcG9zaXRvcnkxOTM0NzM0MA==-flat-blocks.cpp</div>
                </div>
                <div class="column column_space"><pre><code>1320  	boost::property_tree::write_json (ostream, tree, !single_line);
1321  	string_a = ostream.str ();
1322  }
1323  void nano::receive_block::serialize_json (boost::property_tree::ptree & tree) const
1324  {
1325  	tree.put ("type", "receive");
1326  	std::string previous;
</pre></code></div>
                <div class="column column_space"><pre><code>1320  	boost::property_tree::write_json (ostream, tree, !single_line);
1321  	string_a = ostream.str ();
1322  }
1323  void nano::receive_block::serialize_json (boost::property_tree::ptree & tree) const
1324  {
1325  	tree.put ("type", "receive");
1326  	std::string previous;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    