
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 16, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-cordis.cpp</h3>
            <pre><code>1  #include "cordisold.h"
2  TStr TCordisEuPart::ExtrCountry(const TStr& AddrStr){
3    TStr CountryStr;
4    TStrV LnV; AddrStr.SplitOnStr("<br>", LnV);
5    if (LnV.Len()>0){
6      CountryStr=LnV.Last();
7      if (CountryStr.Empty()&&(LnV.Len()>1)){
8        CountryStr=LnV[LnV.Len()-2];}
9      CountryStr.DelChAll('\r');
10      CountryStr.DelChAll('\n');
11    }
12    if (CountryStr.Empty()){
13      printf("Country Field Not Found!\n");}
14    return CountryStr;
15  }
16  TStr TCordisEuPart::ExtrDeptNm(const TStr& EuPartStr){
17    TStr DeptNm=EuPartStr.GetWcMatch("*Department:</span>*</td>*", 1).GetTrunc();
18    if (!DeptNm.Empty()){
19      DeptNm.ChangeStrAll("\n<BR>", " ");
20      DeptNm=TXmlLx::GetPlainStrFromXmlStr(DeptNm);
21    }
22    return DeptNm;
23  }
24  void TCordisEuPart::ExtrEuPartV(const TStr& AllEuPartStr, TCordisEuPartV& EuPartV){
25    TStrV EuPartStrV; AllEuPartStr.SplitOnStr("Organisation Type:", EuPartStrV);
26    for (int EuPartN=1; EuPartN<EuPartStrV.Len(); EuPartN++){
27      TStr EuPartStr=EuPartStrV[EuPartN];
28      TStr WcStr=
29       "</span>*</td>"
30       "*Organisation:</span>*<br>"
31       "*</td>*";
32      TStrV StarStrV;
33      if (EuPartStr.IsWcMatch(WcStr, StarStrV)){
34        PCordisEuPart EuPart=TCordisEuPart::New();
35        EuPart->DeptNm=ExtrDeptNm(EuPartStr);
36        EuPart->OrgNm=TXmlLx::GetPlainStrFromXmlStr(StarStrV[2].GetTrunc());
37        EuPart->OrgTypeNm=StarStrV[0].GetTrunc();
38        EuPart->CountryNm=ExtrCountry(StarStrV[3].GetTrunc());
39        EuPart->CoordP=(EuPartN==1);
40        printf("   Partner: '%s'/'%s'/'%s'/'%s'/'%s'\n",
41         EuPart->DeptNm.CStr(), EuPart->OrgNm.CStr(),
42         EuPart->OrgTypeNm.CStr(), EuPart->CountryNm.CStr(),
43         TBool::GetStr(EuPart->CoordP).CStr());
44        EuPartV.Add(EuPart);
45      } else {
46        printf("Partner Fields Not Found!\n");
47      }
48    }
49  }
50  TStr TCordisEuPart::GetNrOrgNm(const TStr& Str){
51    TStrV NrStrV; TChA ChA;
52    PSwSet SwSet=TSwSet::GetSwSet(swstEnglish523);
53    PSIn HtmlSIn=TStrIn::New(Str);
54    THtmlLx Lx(HtmlSIn);
55    while (Lx.Sym!=hsyEof){
56      if ((Lx.Sym==hsyStr)||(Lx.Sym==hsyNum)){
57        Lx.UcChA.ChangeCh('\xc2', 'A');
58        Lx.UcChA.ChangeCh('\xc1', 'A');
59        Lx.UcChA.ChangeCh('\xc4', 'A');
60        Lx.UcChA.ChangeCh('\xc3', 'A');
61        Lx.UcChA.ChangeCh('\xc0', 'A');
62        Lx.UcChA.ChangeCh('\xc7', 'C');
63        Lx.UcChA.ChangeCh('\xc9', 'E');
64        Lx.UcChA.ChangeCh('\xc8', 'E');
65        Lx.UcChA.ChangeCh('\xca', 'E');
66        Lx.UcChA.ChangeCh('\xcd', 'I');
67        Lx.UcChA.ChangeCh('\xd3', 'O');
68        Lx.UcChA.ChangeCh('\xd6', 'O');
69        Lx.UcChA.ChangeCh('\xd1', 'N');
70        Lx.UcChA.ChangeCh('\xdc', 'U');
71        Lx.UcChA.ChangeCh('\xda', 'U');
72        TStr NrStr=THtmlLx::GetAsciiStr(Lx.UcChA);
73        if ((NrStr.Len()==1)||(SwSet->IsIn(NrStr))||
74         (NrStr=="AG")||(NrStr=="GMBH")||(NrStr=="LTD")||(NrStr=="SRL")||
75         (NrStr=="SA")||(NrStr=="EV")||(NrStr=="AS")||(NrStr=="AB")||
76         (NrStr=="NV")||(NrStr=="BV")||
77         (NrStr=="AKTIENGESELLSCHAFT")||(NrStr=="LIMITED")||
78         (NrStr=="FUER")||(NrStr=="FUR")){
79          NrStr="";}
80        if (!NrStr.Empty()){NrStrV.Add(NrStr);}
81      }
82      Lx.GetSym();
83    }
84    TChA NrChA;
85    for (int NrStrN=0; NrStrN<NrStrV.Len(); NrStrN++){
86      if (NrStrN>0){NrChA+=' ';}
87      NrChA+=NrStrV[NrStrN];
88    }
89    if (NrChA.Empty()){
90      NrChA=Str.GetUc();
91    }
92    return NrChA;
93  }
94  void TCordisEuProj::ExtrEuProjV(const TStr& EuProjHtmlBsFNm, TCordisEuProjV& EuProjV){
95    PSIn EuProjSIn(TFIn::New(EuProjHtmlBsFNm)); int EuProjRecN=0;
96    while (!EuProjSIn->Eof()){
97      printf("[%d]\n", EuProjRecN); EuProjRecN++;
98      TStr UrlStr(*EuProjSIn);
99      TStr HtmlStr(*EuProjSIn);
100      TStr WcStr=
101       "*FP5 Project Record*<center><span class=h3>*.\n*</span></center>"
102       "*FP5 Programme Acronym:</span> <B><I>*</I></B></td>"
103       "*Project Reference:</span>*</td>"
104       "*Start Date:</span>*</td>"
105       "*End Date:</span>*</td>"
106       "*Duration:</span>*</td>"
107       "*Project Status:</span>*</td>"
108       "*Project Acronym:</span>*</td>"
109       "*<span class=b>Project Description</span>*"
110       "<span class=b>Coordinator</span>*";
111      TStrV StarStrV;
112      if (HtmlStr.IsWcMatch(WcStr, StarStrV)){
113        PCordisEuProj EuProj=TCordisEuProj::New();
114        EuProj->TitleStr=TXmlLx::GetPlainStrFromXmlStr(StarStrV[3].GetTrunc());
115        EuProj->EuProgAcrStr=StarStrV[5].GetTrunc();
116        EuProj->EuProjRefStr=StarStrV[7].GetTrunc();
117        EuProj->StartDateStr=StarStrV[9].GetTrunc();
118        EuProj->EndDateStr=StarStrV[11].GetTrunc();
119        EuProj->DurationStr=StarStrV[13].GetTrunc();
120        EuProj->EuProjStatusStr=StarStrV[15].GetTrunc();
121        EuProj->EuProjAcrStr=StarStrV[17].GetTrunc();
122        EuProj->EuProjDescHtmlStr=StarStrV[19].GetTrunc();
123        TStr AllEuPartStr=StarStrV[20].GetTrunc();
124        printf("Project: '%s'/'%s'/'%s'/'%s'/'%s'/'%s'/'%s'/'%s'\n",
<span onclick='openModal()' class='match'>125         EuProj->TitleStr.CStr(), EuProj->EuProgAcrStr.CStr(),
126         EuProj->EuProjRefStr.CStr(), EuProj->StartDateStr.CStr(),
</span>127         EuProj->EndDateStr.CStr(), EuProj->DurationStr.CStr(),
128         EuProj->EuProjStatusStr.CStr(), EuProj->EuProjAcrStr.CStr());
129        TCordisEuPart::ExtrEuPartV(AllEuPartStr, EuProj->EuPartV);
130        EuProjV.Add(EuProj);
131      } else {
132        printf("Project Fields Not Found!\n");
133      }
134    }
135  }
136  PCordisEuProjBs TCordisEuProjBs::ExtrEuProjBs(const TStr& EuProjHtmlBsFNm){
137    PCordisEuProjBs EuProjBs=TCordisEuProjBs::New();
138    TCordisEuProj::ExtrEuProjV(EuProjHtmlBsFNm, EuProjBs->EuProjV);
139    return EuProjBs;
140  }
141  PBowDocBs TCordisEuProjBs::GetBowDocBsFromEuProjDesc() const {
142    printf("Generating Bag-Of-Words...\n");
143    TStrV HtmlStrV;
144    int EuProjs=GetEuProjs();
145    for (int EuProjN=0; EuProjN<EuProjs; EuProjN++){
146      PCordisEuProj EuProj=GetEuProj(EuProjN);
147      TStr EuProjNm=EuProj->GetEuProjAcrStr();
148      TStr EuProjHtmlStr=EuProj->GetTitleStr()+" "+EuProj->GetEuProjDescHtmlStr();
149      HtmlStrV.Add(EuProjHtmlStr);
150    }
151    PSwSet SwSet=TSwSet::GetSwSet(swstEnglish523);
152    PNGramBs NGramBs=TNGramBs::GetNGramBsFromHtmlStrV(HtmlStrV, 3, 3, SwSet);
153    NGramBs->SaveTxt("NGram.Txt");
154    printf("\n");
155    PBowDocBs BowDocBs=TBowDocBs::New();
156    BowDocBs->PutNGramBs(NGramBs);
157    {for (int EuProjN=0; EuProjN<EuProjs; EuProjN++){
158      if (EuProjN%100==0){printf("%d/%d\r", EuProjN, EuProjs);}
159      PCordisEuProj EuProj=GetEuProj(EuProjN);
160      TStr DocNm=EuProj->GetEuProjAcrStr();
161      TStr HtmlStr=EuProj->GetTitleStr()+" "+EuProj->GetEuProjDescHtmlStr();
162      BowDocBs->AddHtmlDoc(DocNm, TStrV(), HtmlStr);
163    }}
164    BowDocBs->AssertOk();
165    printf("\nDone.\n");
166    return BowDocBs;
167  }
168  void TCordisEuProjWebFetch::OnFetch(const int&, const PWebPg& WebPg){
169    printf("%s\n", WebPg->GetUrlStr().CStr());
170    printf("-----------------------\n");
171    TStr WebPgUrlStr=WebPg->GetUrlStr();
172    TStrKdV DescUrlStrKdV; WebPg->GetOutDescUrlStrKdV(DescUrlStrKdV);
173    if (WebPgUrlStr.IsPrefix("http:&bsol;&bsol;dbs.cordis.lu/fep-cgi/srchidadb?ACTION=D&")){
174      TStr HtmlStr=WebPg->GetHttpBodyAsStr();
175      WebPgUrlStr.Save(*EuProjSOut);
176      HtmlStr.Save(*EuProjSOut);
177      EuProjSOut->Flush();
178      int DescUrlStrKdN=DescUrlStrKdV.SearchForw(TStrKd("NEXT RECORD"));
179      if (DescUrlStrKdN!=-1){
180        FetchDocN++;
181        FetchUrlStr=
182         TStr("http:&bsol;&bsol;dbs.cordis.lu/fep-cgi/srchidadb?ACTION=D&SESSION=")+
183         FetchSesIdStr+"&DOC="+TInt::GetStr(FetchDocN);
184        FetchRetries=0;
185        FetchUrl(FetchUrlStr);
186      } else {
187        printf("*** No forward pointer.\n");
188        TSysMsg::Quit();
189      }
190    } else
191    if (WebPgUrlStr.IsPrefix("http:&bsol;&bsol;dbs.cordis.lu/fep-cgi/srchidadb?ACTION=R&")){
192      FetchSesIdStr=WebPgUrlStr.GetWcMatch("*SESSION=*&*", 1);
193      FetchDocN=1;
194      FetchUrlStr=
195       TStr("http:&bsol;&bsol;dbs.cordis.lu/fep-cgi/srchidadb?ACTION=D&SESSION=")+
196       FetchSesIdStr+"&DOC="+TInt::GetStr(FetchDocN);
197      FetchRetries=0;
198      FetchUrl(FetchUrlStr);
199    } else {
200      int DescUrlStrKdN=DescUrlStrKdV.SearchForw(TStrKd("NEXT 20 RECORDS"));
201      if (DescUrlStrKdN!=-1){
202        FetchUrl(DescUrlStrKdV[DescUrlStrKdN].Dat);}
203    }
204  }
205  void TCordisEuProjWebFetch::OnError(const int&, const TStr& MsgStr){
206    printf("*** Error: '%s'\n", MsgStr.CStr());
207    if (FetchUrlStr.Empty()||(FetchRetries>10)){
208      TSysMsg::Quit(); 
209    } else {
210      FetchRetries++;
211      printf("*** Retry (#%d): '%s'\n", FetchRetries, FetchUrlStr.CStr());
212      FetchUrl(FetchUrlStr);
213    }
214  }
215  TStr TCordisEuProjWebFetch::GetEuProgUrlStr(const TEuProg& EuProg){
216    switch (EuProg){
217      case eupAll: return "http:&bsol;&bsol;dbs.cordis.lu/fep-cgi/srchidadb?CALLER=PROJ_FP5&QM_EP_PGA_D=LIFE+QUALITY&QM_EP_PGA_D=EESD&QM_EP_PGA_D=GROWTH&QM_EP_PGA_D=FP5-EAECTP+C&QM_EP_PGA_D=HUMAN+POTENTIAL&QM_EP_PGA_D=INCO+2&QM_EP_PGA_D=INNOVATION-SME&QM_EP_PGA_D=IST&QM_EP_PGA_D=FRAMEWORK+5C&QZ_WEBSRCH=&USR_SORT=EP_PGA_A+CHAR+ASC"; &bsol;&bsol; All
218      case eupIST: return "http:&bsol;&bsol;dbs.cordis.lu/fep-cgi/srchidadb?CALLER=PROJ_FP5&QM_EP_PGA_D=LIFE+QUALITY&QM_EP_PGA_D=EESD&QM_EP_PGA_D=GROWTH&QM_EP_PGA_D=FP5-EAECTP+C&QM_EP_PGA_D=HUMAN+POTENTIAL&QM_EP_PGA_D=INCO+2&QM_EP_PGA_D=INNOVATION-SME&QM_EP_PGA_D=IST&QM_EP_PGA_D=FRAMEWORK+5C&QZ_WEBSRCH=&QM_EP_PGA_A=IST&USR_SORT=EP_PGA_A+CHAR+ASC"; &bsol;&bsol; IST
219      case eupQualityOfLife: return "http:&bsol;&bsol;dbs.cordis.lu/fep-cgi/srchidadb?CALLER=PROJ_FP5&QM_EP_PGA_D=LIFE+QUALITY&QM_EP_PGA_D=EESD&QM_EP_PGA_D=GROWTH&QM_EP_PGA_D=FP5-EAECTP+C&QM_EP_PGA_D=HUMAN+POTENTIAL&QM_EP_PGA_D=INCO+2&QM_EP_PGA_D=INNOVATION-SME&QM_EP_PGA_D=IST&QM_EP_PGA_D=FRAMEWORK+5C&QZ_WEBSRCH=&QM_EP_PGA_A=LIFE+QUALITY&USR_SORT=EP_PGA_A+CHAR+ASC"; &bsol;&bsol; Quality-Of-Life
220      case eupGrowth: return "http:&bsol;&bsol;dbs.cordis.lu/fep-cgi/srchidadb?CALLER=PROJ_FP5&QM_EP_PGA_D=LIFE+QUALITY&QM_EP_PGA_D=EESD&QM_EP_PGA_D=GROWTH&QM_EP_PGA_D=FP5-EAECTP+C&QM_EP_PGA_D=HUMAN+POTENTIAL&QM_EP_PGA_D=INCO+2&QM_EP_PGA_D=INNOVATION-SME&QM_EP_PGA_D=IST&QM_EP_PGA_D=FRAMEWORK+5C&QZ_WEBSRCH=&QM_EP_PGA_A=GROWTH&USR_SORT=EP_PGA_A+CHAR+ASC"; &bsol;&bsol; Growth
221      case eupEEST: return "http:&bsol;&bsol;dbs.cordis.lu/fep-cgi/srchidadb?CALLER=PROJ_FP5&QM_EP_PGA_D=LIFE+QUALITY&QM_EP_PGA_D=EESD&QM_EP_PGA_D=GROWTH&QM_EP_PGA_D=FP5-EAECTP+C&QM_EP_PGA_D=HUMAN+POTENTIAL&QM_EP_PGA_D=INCO+2&QM_EP_PGA_D=INNOVATION-SME&QM_EP_PGA_D=IST&QM_EP_PGA_D=FRAMEWORK+5C&QZ_WEBSRCH=&QM_EP_PGA_A=EESD&USR_SORT=EP_PGA_A+CHAR+ASC"; &bsol;&bsol; EEST
222      case eupINCO2: return "http:&bsol;&bsol;dbs.cordis.lu/fep-cgi/srchidadb?CALLER=PROJ_FP5&QM_EP_PGA_D=LIFE+QUALITY&QM_EP_PGA_D=EESD&QM_EP_PGA_D=GROWTH&QM_EP_PGA_D=FP5-EAECTP+C&QM_EP_PGA_D=HUMAN+POTENTIAL&QM_EP_PGA_D=INCO+2&QM_EP_PGA_D=INNOVATION-SME&QM_EP_PGA_D=IST&QM_EP_PGA_D=FRAMEWORK+5C&QZ_WEBSRCH=&QM_EP_PGA_A=INCO+2&USR_SORT=EP_PGA_A+CHAR+ASC"; &bsol;&bsol; INCO 2
223      case eupInnovationSMEs: return "http:&bsol;&bsol;dbs.cordis.lu/fep-cgi/srchidadb?CALLER=PROJ_FP5&QM_EP_PGA_D=LIFE+QUALITY&QM_EP_PGA_D=EESD&QM_EP_PGA_D=GROWTH&QM_EP_PGA_D=FP5-EAECTP+C&QM_EP_PGA_D=HUMAN+POTENTIAL&QM_EP_PGA_D=INCO+2&QM_EP_PGA_D=INNOVATION-SME&QM_EP_PGA_D=IST&QM_EP_PGA_D=FRAMEWORK+5C&QZ_WEBSRCH=&QM_EP_PGA_A=INNOVATION-SME&USR_SORT=EP_PGA_A+CHAR+ASC"; &bsol;&bsol; Innovation-SMEs
224      case eupImprovingHumanPotential: return "http:&bsol;&bsol;dbs.cordis.lu/fep-cgi/srchidadb?CALLER=PROJ_FP5&QM_EP_PGA_D=LIFE+QUALITY&QM_EP_PGA_D=EESD&QM_EP_PGA_D=GROWTH&QM_EP_PGA_D=FP5-EAECTP+C&QM_EP_PGA_D=HUMAN+POTENTIAL&QM_EP_PGA_D=INCO+2&QM_EP_PGA_D=INNOVATION-SME&QM_EP_PGA_D=IST&QM_EP_PGA_D=FRAMEWORK+5C&QZ_WEBSRCH=&QM_EP_PGA_A=HUMAN+POTENTIAL&USR_SORT=EP_PGA_A+CHAR+ASC"; &bsol;&bsol; Improving-Human-Potential
225      case eupEurAtom: return "http:&bsol;&bsol;dbs.cordis.lu/fep-cgi/srchidadb?CALLER=PROJ_FP5&QM_EP_PGA_D=LIFE+QUALITY&QM_EP_PGA_D=EESD&QM_EP_PGA_D=GROWTH&QM_EP_PGA_D=FP5-EAECTP+C&QM_EP_PGA_D=HUMAN+POTENTIAL&QM_EP_PGA_D=INCO+2&QM_EP_PGA_D=INNOVATION-SME&QM_EP_PGA_D=IST&QM_EP_PGA_D=FRAMEWORK+5C&QZ_WEBSRCH=&QM_EP_PGA_A=FP5-EAECTP+C&USR_SORT=EP_PGA_A+CHAR+ASC"; &bsol;&bsol; EurAtom
226      default: Fail; return "";
227    }
228  }
229  void TCordisEuProjWebFetch::FetchEuProg(
230   const TEuProg& EuProg, const TStr& EuProjHtmlBsFNm){
231    TCordisEuProjWebFetch EuProjWebFetch(EuProjHtmlBsFNm);
232    TStr EuProgUrlStr=GetEuProgUrlStr(EuProg);
233    EuProjWebFetch.FetchUrl(EuProgUrlStr);
234    TSysMsg::Loop();
235  }
</code></pre>
        </div>
        <div class="column">
            <h3>abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-graphcycles.cc</h3>
            <pre><code>1  #include "absl/base/attributes.h"
2  #include "absl/base/internal/low_level_alloc.h"
3  #ifndef ABSL_LOW_LEVEL_ALLOC_MISSING
4  #include "absl/synchronization/internal/graphcycles.h"
5  #include <algorithm>
6  #include <array>
7  #include <limits>
8  #include "absl/base/internal/hide_ptr.h"
9  #include "absl/base/internal/raw_logging.h"
10  #include "absl/base/internal/spinlock.h"
11  namespace absl {
12  ABSL_NAMESPACE_BEGIN
13  namespace synchronization_internal {
14  namespace {
15  ABSL_CONST_INIT static absl::base_internal::SpinLock arena_mu(
16      absl::kConstInit, base_internal::SCHEDULE_KERNEL_ONLY);
17  ABSL_CONST_INIT static base_internal::LowLevelAlloc::Arena* arena;
18  static void InitArenaIfNecessary() {
19    arena_mu.Lock();
20    if (arena == nullptr) {
21      arena = base_internal::LowLevelAlloc::NewArena(0);
22    }
23    arena_mu.Unlock();
24  }
25  static const uint32_t kInline = 8;
26  template <typename T>
27  class Vec {
28   public:
29    Vec() { Init(); }
30    ~Vec() { Discard(); }
31    void clear() {
32      Discard();
33      Init();
34    }
35    bool empty() const { return size_ == 0; }
36    uint32_t size() const { return size_; }
37    T* begin() { return ptr_; }
38    T* end() { return ptr_ + size_; }
39    const T& operator[](uint32_t i) const { return ptr_[i]; }
40    T& operator[](uint32_t i) { return ptr_[i]; }
41    const T& back() const { return ptr_[size_-1]; }
42    void pop_back() { size_--; }
43    void push_back(const T& v) {
44      if (size_ == capacity_) Grow(size_ + 1);
45      ptr_[size_] = v;
46      size_++;
47    }
48    void resize(uint32_t n) {
49      if (n > capacity_) Grow(n);
50      size_ = n;
51    }
52    void fill(const T& val) {
53      for (uint32_t i = 0; i < size(); i++) {
54        ptr_[i] = val;
55      }
56    }
57    void MoveFrom(Vec<T>* src) {
58      if (src->ptr_ == src->space_) {
59        resize(src->size_);
60        std::copy_n(src->ptr_, src->size_, ptr_);
61        src->size_ = 0;
62      } else {
63        Discard();
64        ptr_ = src->ptr_;
65        size_ = src->size_;
66        capacity_ = src->capacity_;
67        src->Init();
68      }
69    }
70   private:
71    T* ptr_;
72    T space_[kInline];
73    uint32_t size_;
74    uint32_t capacity_;
75    void Init() {
76      ptr_ = space_;
77      size_ = 0;
78      capacity_ = kInline;
79    }
80    void Discard() {
81      if (ptr_ != space_) base_internal::LowLevelAlloc::Free(ptr_);
82    }
83    void Grow(uint32_t n) {
84      while (capacity_ < n) {
85        capacity_ *= 2;
86      }
87      size_t request = static_cast<size_t>(capacity_) * sizeof(T);
88      T* copy = static_cast<T*>(
89          base_internal::LowLevelAlloc::AllocWithArena(request, arena));
90      std::copy_n(ptr_, size_, copy);
91      Discard();
92      ptr_ = copy;
93    }
94    Vec(const Vec&) = delete;
95    Vec& operator=(const Vec&) = delete;
96  };
97  class NodeSet {
98   public:
99    NodeSet() { Init(); }
100    void clear() { Init(); }
101    bool contains(int32_t v) const { return table_[FindIndex(v)] == v; }
102    bool insert(int32_t v) {
103      uint32_t i = FindIndex(v);
104      if (table_[i] == v) {
105        return false;
106      }
107      if (table_[i] == kEmpty) {
108        occupied_++;
109      }
110      table_[i] = v;
111      if (occupied_ >= table_.size() - table_.size()/4) Grow();
112      return true;
113    }
114    void erase(int32_t v) {
115      uint32_t i = FindIndex(v);
116      if (table_[i] == v) {
117        table_[i] = kDel;
118      }
119    }
120  #define HASH_FOR_EACH(elem, eset) \
121    for (int32_t elem, _cursor = 0; (eset).Next(&_cursor, &elem); )
122    bool Next(int32_t* cursor, int32_t* elem) {
123      while (static_cast<uint32_t>(*cursor) < table_.size()) {
124        int32_t v = table_[static_cast<uint32_t>(*cursor)];
125        (*cursor)++;
126        if (v >= 0) {
127          *elem = v;
128          return true;
129        }
130      }
131      return false;
132    }
133   private:
134    enum : int32_t { kEmpty = -1, kDel = -2 };
135    Vec<int32_t> table_;
136    uint32_t occupied_;     
137    static uint32_t Hash(int32_t a) { return static_cast<uint32_t>(a * 41); }
138    uint32_t FindIndex(int32_t v) const {
139      const uint32_t mask = table_.size() - 1;
140      uint32_t i = Hash(v) & mask;
141      uint32_t deleted_index = 0;  
142      bool seen_deleted_element = false;
143      while (true) {
144        int32_t e = table_[i];
145        if (v == e) {
146          return i;
147        } else if (e == kEmpty) {
148          return seen_deleted_element ? deleted_index : i;
149        } else if (e == kDel && !seen_deleted_element) {
150          deleted_index = i;
151          seen_deleted_element = true;
152        }
153        i = (i + 1) & mask;  
154      }
155    }
156    void Init() {
157      table_.clear();
158      table_.resize(kInline);
159      table_.fill(kEmpty);
160      occupied_ = 0;
161    }
162    void Grow() {
163      Vec<int32_t> copy;
164      copy.MoveFrom(&table_);
165      occupied_ = 0;
166      table_.resize(copy.size() * 2);
167      table_.fill(kEmpty);
168      for (const auto& e : copy) {
169        if (e >= 0) insert(e);
170      }
171    }
172    NodeSet(const NodeSet&) = delete;
173    NodeSet& operator=(const NodeSet&) = delete;
174  };
175  inline GraphId MakeId(int32_t index, uint32_t version) {
176    GraphId g;
177    g.handle =
178        (static_cast<uint64_t>(version) << 32) | static_cast<uint32_t>(index);
179    return g;
180  }
181  inline int32_t NodeIndex(GraphId id) {
182    return static_cast<int32_t>(id.handle);
183  }
184  inline uint32_t NodeVersion(GraphId id) {
185    return static_cast<uint32_t>(id.handle >> 32);
186  }
187  struct Node {
188    int32_t rank;               
189    uint32_t version;           
190    int32_t next_hash;          
191    bool visited;               
192    uintptr_t masked_ptr;       
193    NodeSet in;                 
194    NodeSet out;                
195    int priority;               
196    int nstack;                 
197    void* stack[40];            
198  };
199  class PointerMap {
200   public:
201    explicit PointerMap(const Vec<Node*>* nodes) : nodes_(nodes) {
202      table_.fill(-1);
203    }
204    int32_t Find(void* ptr) {
205      auto masked = base_internal::HidePtr(ptr);
206      for (int32_t i = table_[Hash(ptr)]; i != -1;) {
207        Node* n = (*nodes_)[static_cast<uint32_t>(i)];
208        if (n->masked_ptr == masked) return i;
209        i = n->next_hash;
210      }
211      return -1;
212    }
213    void Add(void* ptr, int32_t i) {
214      int32_t* head = &table_[Hash(ptr)];
215      (*nodes_)[static_cast<uint32_t>(i)]->next_hash = *head;
216      *head = i;
217    }
218    int32_t Remove(void* ptr) {
219      auto masked = base_internal::HidePtr(ptr);
220      for (int32_t* slot = &table_[Hash(ptr)]; *slot != -1; ) {
221        int32_t index = *slot;
222        Node* n = (*nodes_)[static_cast<uint32_t>(index)];
223        if (n->masked_ptr == masked) {
224          *slot = n->next_hash;  
225          n->next_hash = -1;
226          return index;
227        }
228        slot = &n->next_hash;
229      }
230      return -1;
231    }
232   private:
233    static constexpr uint32_t kHashTableSize = 8171;  
234    const Vec<Node*>* nodes_;
235    std::array<int32_t, kHashTableSize> table_;
236    static uint32_t Hash(void* ptr) {
237      return reinterpret_cast<uintptr_t>(ptr) % kHashTableSize;
238    }
239  };
240  }  
241  struct GraphCycles::Rep {
242    Vec<Node*> nodes_;
243    Vec<int32_t> free_nodes_;  
244    PointerMap ptrmap_;
245    Vec<int32_t> deltaf_;  
246    Vec<int32_t> deltab_;  
247    Vec<int32_t> list_;    
248    Vec<int32_t> merged_;  
249    Vec<int32_t> stack_;   
250    Rep() : ptrmap_(&nodes_) {}
251  };
252  static Node* FindNode(GraphCycles::Rep* rep, GraphId id) {
253    Node* n = rep->nodes_[static_cast<uint32_t>(NodeIndex(id))];
254    return (n->version == NodeVersion(id)) ? n : nullptr;
255  }
256  GraphCycles::GraphCycles() {
257    InitArenaIfNecessary();
258    rep_ = new (base_internal::LowLevelAlloc::AllocWithArena(sizeof(Rep), arena))
259        Rep;
260  }
261  GraphCycles::~GraphCycles() {
262    for (auto* node : rep_->nodes_) {
263      node->Node::~Node();
264      base_internal::LowLevelAlloc::Free(node);
265    }
266    rep_->Rep::~Rep();
267    base_internal::LowLevelAlloc::Free(rep_);
268  }
269  bool GraphCycles::CheckInvariants() const {
270    Rep* r = rep_;
271    NodeSet ranks;  
272    for (uint32_t x = 0; x < r->nodes_.size(); x++) {
273      Node* nx = r->nodes_[x];
274      void* ptr = base_internal::UnhidePtr<void>(nx->masked_ptr);
275      if (ptr != nullptr && static_cast<uint32_t>(r->ptrmap_.Find(ptr)) != x) {
276        ABSL_RAW_LOG(FATAL, "Did not find live node in hash table %u %p", x, ptr);
277      }
278      if (nx->visited) {
279        ABSL_RAW_LOG(FATAL, "Did not clear visited marker on node %u", x);
280      }
281      if (!ranks.insert(nx->rank)) {
282        ABSL_RAW_LOG(FATAL, "Duplicate occurrence of rank %d", nx->rank);
283      }
284      HASH_FOR_EACH(y, nx->out) {
285        Node* ny = r->nodes_[static_cast<uint32_t>(y)];
286        if (nx->rank >= ny->rank) {
287          ABSL_RAW_LOG(FATAL, "Edge %u->%d has bad rank assignment %d->%d", x, y,
288                       nx->rank, ny->rank);
289        }
290      }
291    }
292    return true;
293  }
294  GraphId GraphCycles::GetId(void* ptr) {
295    int32_t i = rep_->ptrmap_.Find(ptr);
296    if (i != -1) {
297      return MakeId(i, rep_->nodes_[static_cast<uint32_t>(i)]->version);
298    } else if (rep_->free_nodes_.empty()) {
299      Node* n =
300          new (base_internal::LowLevelAlloc::AllocWithArena(sizeof(Node), arena))
301              Node;
302      n->version = 1;  
303      n->visited = false;
304      n->rank = static_cast<int32_t>(rep_->nodes_.size());
305      n->masked_ptr = base_internal::HidePtr(ptr);
306      n->nstack = 0;
307      n->priority = 0;
308      rep_->nodes_.push_back(n);
309      rep_->ptrmap_.Add(ptr, n->rank);
310      return MakeId(n->rank, n->version);
311    } else {
312      int32_t r = rep_->free_nodes_.back();
313      rep_->free_nodes_.pop_back();
314      Node* n = rep_->nodes_[static_cast<uint32_t>(r)];
315      n->masked_ptr = base_internal::HidePtr(ptr);
316      n->nstack = 0;
317      n->priority = 0;
318      rep_->ptrmap_.Add(ptr, r);
319      return MakeId(r, n->version);
320    }
321  }
322  void GraphCycles::RemoveNode(void* ptr) {
323    int32_t i = rep_->ptrmap_.Remove(ptr);
324    if (i == -1) {
325      return;
326    }
327    Node* x = rep_->nodes_[static_cast<uint32_t>(i)];
328    HASH_FOR_EACH(y, x->out) {
329      rep_->nodes_[static_cast<uint32_t>(y)]->in.erase(i);
330    }
331    HASH_FOR_EACH(y, x->in) {
332      rep_->nodes_[static_cast<uint32_t>(y)]->out.erase(i);
333    }
334    x->in.clear();
335    x->out.clear();
336    x->masked_ptr = base_internal::HidePtr<void>(nullptr);
337    if (x->version == std::numeric_limits<uint32_t>::max()) {
338    } else {
339      x->version++;  
340      rep_->free_nodes_.push_back(i);
341    }
342  }
343  void* GraphCycles::Ptr(GraphId id) {
344    Node* n = FindNode(rep_, id);
345    return n == nullptr ? nullptr
346                        : base_internal::UnhidePtr<void>(n->masked_ptr);
347  }
348  bool GraphCycles::HasNode(GraphId node) {
349    return FindNode(rep_, node) != nullptr;
350  }
351  bool GraphCycles::HasEdge(GraphId x, GraphId y) const {
352    Node* xn = FindNode(rep_, x);
353    return xn && FindNode(rep_, y) && xn->out.contains(NodeIndex(y));
354  }
355  void GraphCycles::RemoveEdge(GraphId x, GraphId y) {
356    Node* xn = FindNode(rep_, x);
357    Node* yn = FindNode(rep_, y);
358    if (xn && yn) {
359      xn->out.erase(NodeIndex(y));
360      yn->in.erase(NodeIndex(x));
361    }
362  }
363  static bool ForwardDFS(GraphCycles::Rep* r, int32_t n, int32_t upper_bound);
364  static void BackwardDFS(GraphCycles::Rep* r, int32_t n, int32_t lower_bound);
365  static void Reorder(GraphCycles::Rep* r);
366  static void Sort(const Vec<Node*>&, Vec<int32_t>* delta);
367  static void MoveToList(
368      GraphCycles::Rep* r, Vec<int32_t>* src, Vec<int32_t>* dst);
369  bool GraphCycles::InsertEdge(GraphId idx, GraphId idy) {
370    Rep* r = rep_;
371    const int32_t x = NodeIndex(idx);
372    const int32_t y = NodeIndex(idy);
373    Node* nx = FindNode(r, idx);
374    Node* ny = FindNode(r, idy);
375    if (nx == nullptr || ny == nullptr) return true;  
376    if (nx == ny) return false;  
377    if (!nx->out.insert(y)) {
378      return true;
379    }
380    ny->in.insert(x);
381    if (nx->rank <= ny->rank) {
382      return true;
383    }
384    if (!ForwardDFS(r, y, nx->rank)) {
385      nx->out.erase(y);
386      ny->in.erase(x);
387      for (const auto& d : r->deltaf_) {
388        r->nodes_[static_cast<uint32_t>(d)]->visited = false;
389      }
390      return false;
391    }
392    BackwardDFS(r, x, ny->rank);
393    Reorder(r);
394    return true;
395  }
396  static bool ForwardDFS(GraphCycles::Rep* r, int32_t n, int32_t upper_bound) {
397    r->deltaf_.clear();
398    r->stack_.clear();
399    r->stack_.push_back(n);
400    while (!r->stack_.empty()) {
401      n = r->stack_.back();
402      r->stack_.pop_back();
403      Node* nn = r->nodes_[static_cast<uint32_t>(n)];
404      if (nn->visited) continue;
405      nn->visited = true;
406      r->deltaf_.push_back(n);
407      HASH_FOR_EACH(w, nn->out) {
408        Node* nw = r->nodes_[static_cast<uint32_t>(w)];
409        if (nw->rank == upper_bound) {
410          return false;  
411        }
412        if (!nw->visited && nw->rank < upper_bound) {
413          r->stack_.push_back(w);
414        }
415      }
416    }
417    return true;
418  }
419  static void BackwardDFS(GraphCycles::Rep* r, int32_t n, int32_t lower_bound) {
420    r->deltab_.clear();
421    r->stack_.clear();
422    r->stack_.push_back(n);
423    while (!r->stack_.empty()) {
424      n = r->stack_.back();
425      r->stack_.pop_back();
426      Node* nn = r->nodes_[static_cast<uint32_t>(n)];
427      if (nn->visited) continue;
428      nn->visited = true;
429      r->deltab_.push_back(n);
430      HASH_FOR_EACH(w, nn->in) {
431        Node* nw = r->nodes_[static_cast<uint32_t>(w)];
432        if (!nw->visited && lower_bound < nw->rank) {
433          r->stack_.push_back(w);
434        }
435      }
436    }
437  }
438  static void Reorder(GraphCycles::Rep* r) {
439    Sort(r->nodes_, &r->deltab_);
440    Sort(r->nodes_, &r->deltaf_);
441    r->list_.clear();
442    MoveToList(r, &r->deltab_, &r->list_);
443    MoveToList(r, &r->deltaf_, &r->list_);
444    r->merged_.resize(r->deltab_.size() + r->deltaf_.size());
445    std::merge(r->deltab_.begin(), r->deltab_.end(),
<span onclick='openModal()' class='match'>446               r->deltaf_.begin(), r->deltaf_.end(),
447               r->merged_.begin());
</span>448    for (uint32_t i = 0; i < r->list_.size(); i++) {
449      r->nodes_[static_cast<uint32_t>(r->list_[i])]->rank = r->merged_[i];
450    }
451  }
452  static void Sort(const Vec<Node*>& nodes, Vec<int32_t>* delta) {
453    struct ByRank {
454      const Vec<Node*>* nodes;
455      bool operator()(int32_t a, int32_t b) const {
456        return (*nodes)[static_cast<uint32_t>(a)]->rank <
457               (*nodes)[static_cast<uint32_t>(b)]->rank;
458      }
459    };
460    ByRank cmp;
461    cmp.nodes = &nodes;
462    std::sort(delta->begin(), delta->end(), cmp);
463  }
464  static void MoveToList(
465      GraphCycles::Rep* r, Vec<int32_t>* src, Vec<int32_t>* dst) {
466    for (auto& v : *src) {
467      int32_t w = v;
468      v = r->nodes_[static_cast<uint32_t>(w)]->rank;
469      r->nodes_[static_cast<uint32_t>(w)]->visited = false;
470      dst->push_back(w);
471    }
472  }
473  int GraphCycles::FindPath(GraphId idx, GraphId idy, int max_path_len,
474                            GraphId path[]) const {
475    Rep* r = rep_;
476    if (FindNode(r, idx) == nullptr || FindNode(r, idy) == nullptr) return 0;
477    const int32_t x = NodeIndex(idx);
478    const int32_t y = NodeIndex(idy);
479    int path_len = 0;
480    NodeSet seen;
481    r->stack_.clear();
482    r->stack_.push_back(x);
483    while (!r->stack_.empty()) {
484      int32_t n = r->stack_.back();
485      r->stack_.pop_back();
486      if (n < 0) {
487        path_len--;
488        continue;
489      }
490      if (path_len < max_path_len) {
491        path[path_len] =
492            MakeId(n, rep_->nodes_[static_cast<uint32_t>(n)]->version);
493      }
494      path_len++;
495      r->stack_.push_back(-1);  
496      if (n == y) {
497        return path_len;
498      }
499      HASH_FOR_EACH(w, r->nodes_[static_cast<uint32_t>(n)]->out) {
500        if (seen.insert(w)) {
501          r->stack_.push_back(w);
502        }
503      }
504    }
505    return 0;
506  }
507  bool GraphCycles::IsReachable(GraphId x, GraphId y) const {
508    return FindPath(x, y, 0, nullptr) > 0;
509  }
510  void GraphCycles::UpdateStackTrace(GraphId id, int priority,
511                                     int (*get_stack_trace)(void** stack, int)) {
512    Node* n = FindNode(rep_, id);
513    if (n == nullptr || n->priority >= priority) {
514      return;
515    }
516    n->nstack = (*get_stack_trace)(n->stack, ABSL_ARRAYSIZE(n->stack));
517    n->priority = priority;
518  }
519  int GraphCycles::GetStackTrace(GraphId id, void*** ptr) {
520    Node* n = FindNode(rep_, id);
521    if (n == nullptr) {
522      *ptr = nullptr;
523      return 0;
524    } else {
525      *ptr = n->stack;
526      return n->nstack;
527    }
528  }
529  }  
530  ABSL_NAMESPACE_END
531  }  
532  #endif  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-cordis.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from abseil-cpp-MDEwOlJlcG9zaXRvcnkxMDQyMzE1NDE=-flat-graphcycles.cc</div>
                </div>
                <div class="column column_space"><pre><code>125         EuProj->TitleStr.CStr(), EuProj->EuProgAcrStr.CStr(),
126         EuProj->EuProjRefStr.CStr(), EuProj->StartDateStr.CStr(),
</pre></code></div>
                <div class="column column_space"><pre><code>446               r->deltaf_.begin(), r->deltaf_.end(),
447               r->merged_.begin());
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    