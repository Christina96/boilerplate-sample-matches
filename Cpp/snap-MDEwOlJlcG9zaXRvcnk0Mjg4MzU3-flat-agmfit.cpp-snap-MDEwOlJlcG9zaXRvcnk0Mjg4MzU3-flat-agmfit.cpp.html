
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 36, <button onclick='openModal()' class='match'></button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-agmfit.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "agmfit.h"
3  #include "agm.h"
4  void TAGMFit::Save(TSOut& SOut) {
5    G->Save(SOut);
6    CIDNSetV.Save(SOut);
7    EdgeComVH.Save(SOut);
8    NIDComVH.Save(SOut);
9    ComEdgesV.Save(SOut);
10    PNoCom.Save(SOut);
11    LambdaV.Save(SOut);
12    NIDCIDPrH.Save(SOut);
13    NIDCIDPrS.Save(SOut);
14    MinLambda.Save(SOut);
15    MaxLambda.Save(SOut);
16    RegCoef.Save(SOut);
17    BaseCID.Save(SOut);
18  }
19  void TAGMFit::Load(TSIn& SIn, const int& RndSeed) {
20    G = TUNGraph::Load(SIn);
21    CIDNSetV.Load(SIn);
22    EdgeComVH.Load(SIn);
23    NIDComVH.Load(SIn);
24    ComEdgesV.Load(SIn);
25    PNoCom.Load(SIn);
26    LambdaV.Load(SIn);
27    NIDCIDPrH.Load(SIn);
28    NIDCIDPrS.Load(SIn);
29    MinLambda.Load(SIn);
30    MaxLambda.Load(SIn);
31    RegCoef.Load(SIn);
32    BaseCID.Load(SIn);
33    Rnd.PutSeed(RndSeed);
34  }
35  void TAGMFit::RandomInitCmtyVV(const int InitComs, const double ComSzAlpha, const double MemAlpha, const int MinComSz, const int MaxComSz, const int MinMem, const int MaxMem) {
36    TVec<TIntV> InitCmtyVV(InitComs, 0);
37    TAGMUtil::GenCmtyVVFromPL(InitCmtyVV, G, G->GetNodes(), InitComs, ComSzAlpha, MemAlpha, MinComSz, MaxComSz,
38        MinMem, MaxMem, Rnd);
39    SetCmtyVV(InitCmtyVV);
40  }
41  void TAGMFit::GetEdgeJointCom() {
42    ComEdgesV.Gen(CIDNSetV.Len());
43    EdgeComVH.Gen(G->GetEdges());
44    for (TUNGraph::TNodeI SrcNI = G->BegNI(); SrcNI < G->EndNI(); SrcNI++) {
45      int SrcNID = SrcNI.GetId();
46      for (int v = 0; v < SrcNI.GetDeg(); v++) {
47        int DstNID = SrcNI.GetNbrNId(v);
48        if (SrcNID >= DstNID) { continue; }
49        TIntSet JointCom;
50        IAssert(NIDComVH.IsKey(SrcNID));
51        IAssert(NIDComVH.IsKey(DstNID));
52        TAGMUtil::GetIntersection(NIDComVH.GetDat(SrcNID), NIDComVH.GetDat(DstNID), JointCom);
53        EdgeComVH.AddDat(TIntPr(SrcNID,DstNID),JointCom);
54        for (int k = 0; k < JointCom.Len(); k++) {
55          ComEdgesV[JointCom[k]]++;
56        }
57      }
58    }
59    IAssert(EdgeComVH.Len() == G->GetEdges());
60  }
61  void TAGMFit::SetDefaultPNoCom() {
62    PNoCom = 1.0 / (double) G->GetNodes() / (double) G->GetNodes();
63  }
64  double TAGMFit::Likelihood(const TFltV& NewLambdaV, double& LEdges, double& LNoEdges) {
65    IAssert(CIDNSetV.Len() == NewLambdaV.Len());
66    IAssert(ComEdgesV.Len() == CIDNSetV.Len());
67    LEdges = 0.0; LNoEdges = 0.0;
68    for (int e = 0; e < EdgeComVH.Len(); e++) {
69      TIntSet& JointCom = EdgeComVH[e];
70      double LambdaSum = SelectLambdaSum(NewLambdaV, JointCom);
71      double Puv = 1 - exp(- LambdaSum);
72      if (JointCom.Len() == 0) {  Puv = PNoCom;  }
73      IAssert(! _isnan(log(Puv)));
74      LEdges += log(Puv);
75    }
76    for (int k = 0; k < NewLambdaV.Len(); k++) {
77      int MaxEk = CIDNSetV[k].Len() * (CIDNSetV[k].Len() - 1) / 2;
78      int NotEdgesInCom = MaxEk - ComEdgesV[k];
79      if(NotEdgesInCom > 0) {
80        if (LNoEdges >= TFlt::Mn + double(NotEdgesInCom) * NewLambdaV[k]) { 
81          LNoEdges -= double(NotEdgesInCom) * NewLambdaV[k];
82        }
83      }
84    }
85    double LReg = 0.0;
86    if (RegCoef > 0.0) {
87      LReg = - RegCoef * TLinAlg::SumVec(NewLambdaV);
88    }
89    return LEdges + LNoEdges + LReg;
90  }
91  double TAGMFit::Likelihood() { 
92    return Likelihood(LambdaV); 
93  }
94  double TAGMFit::GetStepSizeByLineSearchForLambda(const TFltV& DeltaV, const TFltV& GradV, const double& Alpha, const double& Beta) {
95    double StepSize = 1.0;
96    double InitLikelihood = Likelihood();
97    IAssert(LambdaV.Len() == DeltaV.Len());
98    TFltV NewLambdaV(LambdaV.Len());
99    for (int iter = 0; ; iter++) {
100      for (int i = 0; i < LambdaV.Len(); i++) {
101        NewLambdaV[i] = LambdaV[i] + StepSize * DeltaV[i];
102        if (NewLambdaV[i] < MinLambda) { NewLambdaV[i] = MinLambda; }
103        if (NewLambdaV[i] > MaxLambda) { NewLambdaV[i] = MaxLambda; }
104      }
105      if (Likelihood(NewLambdaV) < InitLikelihood + Alpha * StepSize * TLinAlg::DotProduct(GradV, DeltaV)) {
106        StepSize *= Beta;
107      } else {
108        break;
109      }
110    }
111    return StepSize;
112  }
113  int TAGMFit::MLEGradAscentGivenCAG(const double& Thres, const int& MaxIter, const TStr PlotNm) {
114    int Edges = G->GetEdges();
115    TExeTm ExeTm;
116    TFltV GradV(LambdaV.Len());
117    int iter = 0;
118    TIntFltPrV IterLV, IterGradNormV;
119    double GradCutOff = 1000;
120    for (iter = 0; iter < MaxIter; iter++) {
121      GradLogLForLambda(GradV);    
122      for (int i = 0; i < LambdaV.Len(); i++) {
123        if (GradV[i] < -GradCutOff) { GradV[i] = -GradCutOff; }
124        if (GradV[i] > GradCutOff) { GradV[i] = GradCutOff; }
125        if (LambdaV[i] <= MinLambda && GradV[i] < 0) { GradV[i] = 0.0; }
126        if (LambdaV[i] >= MaxLambda && GradV[i] > 0) { GradV[i] = 0.0; }
127      }
128      double Alpha = 0.15, Beta = 0.2;
129      if (Edges > Kilo(100)) { Alpha = 0.00015; Beta = 0.3;}
130      double LearnRate = GetStepSizeByLineSearchForLambda(GradV, GradV, Alpha, Beta);
131      if (TLinAlg::Norm(GradV) < Thres) { break; }
132      for (int i = 0; i < LambdaV.Len(); i++) {
133        double Change = LearnRate * GradV[i];
134        LambdaV[i] += Change;
135        if(LambdaV[i] < MinLambda) { LambdaV[i] = MinLambda;}
136        if(LambdaV[i] > MaxLambda) { LambdaV[i] = MaxLambda;}
137      }
138      if (! PlotNm.Empty()) {
139        double L = Likelihood();
140        IterLV.Add(TIntFltPr(iter, L));
141        IterGradNormV.Add(TIntFltPr(iter, TLinAlg::Norm(GradV)));
142      }
143    }
144    if (! PlotNm.Empty()) {
145      TGnuPlot::PlotValV(IterLV, PlotNm + ".likelihood_Q");
146      TGnuPlot::PlotValV(IterGradNormV, PlotNm + ".gradnorm_Q");
147      printf("MLE for Lambda completed with %d iterations(%s)\n",iter,ExeTm.GetTmStr());
148    }
149    return iter;
150  }
151  void TAGMFit::RandomInit(const int& MaxK) {
152    CIDNSetV.Clr();
153    for (int c = 0; c < MaxK; c++) {
154      CIDNSetV.Add();
155      int NC = Rnd.GetUniDevInt(G -> GetNodes());
156      TUNGraph::TNodeI NI = G -> GetRndNI();
157      CIDNSetV.Last().AddKey(NI.GetId());
158      for (int v = 0; v < NC; v++) {
159        NI = G->GetNI(NI.GetNbrNId(Rnd.GetUniDevInt(NI.GetDeg())));
160        CIDNSetV.Last().AddKey(NI.GetId());
161      }
162    }
163    InitNodeData();
164    SetDefaultPNoCom();
165  }
166  void TAGMFit::NeighborComInit(const int InitComs) {
167    CIDNSetV.Gen(InitComs);
168    const int Edges = G->GetEdges();
169    TFltIntPrV NIdPhiV(G->GetNodes(), 0);
170    TIntSet InvalidNIDS(G->GetNodes());
171    TIntV ChosenNIDV(InitComs, 0); 
172    TExeTm RunTm;
173    TIntV NIdV;
174    G->GetNIdV(NIdV);
175    for (int u = 0; u < NIdV.Len(); u++) {
176      TIntSet NBCmty(G->GetNI(NIdV[u]).GetDeg() + 1);
177      double Phi;
178      if (G->GetNI(NIdV[u]).GetDeg() < 5) { 
179        Phi = 1.0; 
180      } else {
181        TAGMUtil::GetNbhCom(G, NIdV[u], NBCmty);
182        IAssert(NBCmty.Len() == G->GetNI(NIdV[u]).GetDeg() + 1);
183        Phi = TAGMUtil::GetConductance(G, NBCmty, Edges);
184      }
185      NIdPhiV.Add(TFltIntPr(Phi, NIdV[u]));
186    }
187    NIdPhiV.Sort(true);
188    printf("conductance computation completed [%s]\n", RunTm.GetTmStr());
189    fflush(stdout);
190    int CurCID = 0;
191    for (int ui = 0; ui < NIdPhiV.Len(); ui++) {
192      int UID = NIdPhiV[ui].Val2;
193      fflush(stdout);
194      if (InvalidNIDS.IsKey(UID)) { continue; }
195      ChosenNIDV.Add(UID); 
196      CIDNSetV[CurCID].AddKey(UID);
197      TUNGraph::TNodeI NI = G->GetNI(UID);
198      fflush(stdout);
199      for (int e = 0; e < NI.GetDeg(); e++) {
200        CIDNSetV[CurCID].AddKey(NI.GetNbrNId(e));
201      }
202      for (int e = 0; e < NI.GetDeg(); e++) {
203        InvalidNIDS.AddKey(NI.GetNbrNId(e));
204      }
205      CurCID++;
206      fflush(stdout);
207      if (CurCID >= InitComs) { break;  }
208    }
209    if (InitComs > CurCID) {
210      printf("%d communities needed to fill randomly\n", InitComs - CurCID);
211    }
212    for (int c = 0; c < CIDNSetV.Len(); c++) {
213      if (CIDNSetV[c].Len() == 0) {
214        int ComSz = 10;
215        for (int u = 0; u < ComSz; u++) {
216          int UID = G->GetRndNI().GetId();
217          CIDNSetV[c].AddKey(UID);
218        }
219      }
220    }
221    InitNodeData();
222    SetDefaultPNoCom();
223  }
224  void TAGMFit::AddBaseCmty() {
225    TVec<TIntV> CmtyVV;
226    GetCmtyVV(CmtyVV);
227    TIntV TmpV = CmtyVV[0];
228    CmtyVV.Add(TmpV);
229    G->GetNIdV(CmtyVV[0]);
230    IAssert(CIDNSetV.Len() + 1 == CmtyVV.Len());
231    SetCmtyVV(CmtyVV);
232    InitNodeData();
233    BaseCID = 0;
234    PNoCom = 0.0;
235  }
236  void TAGMFit::InitNodeData() {
237    TSnap::DelSelfEdges(G);
238    NIDComVH.Gen(G->GetNodes());
239    for (TUNGraph::TNodeI NI = G->BegNI(); NI < G->EndNI(); NI++) {
240      NIDComVH.AddDat(NI.GetId());
241    }
242    TAGMUtil::GetNodeMembership(NIDComVH, CIDNSetV);
243    GetEdgeJointCom();
244    LambdaV.Gen(CIDNSetV.Len());
245    for (int c = 0; c < CIDNSetV.Len(); c++) {
246      int MaxE = (CIDNSetV[c].Len()) * (CIDNSetV[c].Len() - 1) / 2;
247      if (MaxE < 2) {
248        LambdaV[c] = MaxLambda;
249      }
250      else{
251        LambdaV[c] = -log((double) (MaxE - ComEdgesV[c]) / MaxE);
252      }
253      if (LambdaV[c] > MaxLambda) {  LambdaV[c] = MaxLambda;  }
254      if (LambdaV[c] < MinLambda) {  LambdaV[c] = MinLambda;  }
255    }
256    NIDCIDPrS.Gen(G->GetNodes() * 10);
257    for (int c = 0; c < CIDNSetV.Len(); c++) {
258      for (TIntSet::TIter SI = CIDNSetV[c].BegI(); SI < CIDNSetV[c].EndI(); SI++) {
259        NIDCIDPrS.AddKey(TIntPr(SI.GetKey(), c));
260      }
261    }
262  }
263  void TAGMFit::LeaveCom(const int& NID, const int& CID) {
264    TUNGraph::TNodeI NI = G->GetNI(NID);
265    for (int e = 0; e < NI.GetDeg(); e++) {
266      int VID = NI.GetNbrNId(e);
267      if (NIDComVH.GetDat(VID).IsKey(CID)) {
268        TIntPr SrcDstNIDPr = TIntPr(TMath::Mn(NID,VID), TMath::Mx(NID,VID));
269        EdgeComVH.GetDat(SrcDstNIDPr).DelKey(CID);
270        ComEdgesV[CID]--;
271      }
272    }
273    CIDNSetV[CID].DelKey(NID);
274    NIDComVH.GetDat(NID).DelKey(CID);
275    NIDCIDPrS.DelKey(TIntPr(NID, CID));
276  }
277  void TAGMFit::JoinCom(const int& NID, const int& JoinCID) {
278    TUNGraph::TNodeI NI = G->GetNI(NID);
279    for (int e = 0; e < NI.GetDeg(); e++) {
280      int VID = NI.GetNbrNId(e);
281      if (NIDComVH.GetDat(VID).IsKey(JoinCID)) {
<span onclick='openModal()' class='match'>282        TIntPr SrcDstNIDPr = TIntPr(TMath::Mn(NID,VID), TMath::Mx(NID,VID));
283        EdgeComVH.GetDat(SrcDstNIDPr).AddKey(JoinCID);
284        ComEdgesV[JoinCID]++;
</span>285      }
286    }
287    CIDNSetV[JoinCID].AddKey(NID);
288    NIDComVH.GetDat(NID).AddKey(JoinCID);
289    NIDCIDPrS.AddKey(TIntPr(NID, JoinCID));
290  }
291  void TAGMFit::SampleTransition(int& NID, int& JoinCID, int& LeaveCID, double& DeltaL) {
292    int Option = Rnd.GetUniDevInt(3); 
293    if (NIDCIDPrS.Len() <= 1) {    Option = 0;  } 
294    int TryCnt = 0;
295    const int MaxTryCnt = G->GetNodes();
296    DeltaL = TFlt::Mn;
297    if (Option == 0) {
298      do {
299        JoinCID = Rnd.GetUniDevInt(CIDNSetV.Len());
300        NID = G->GetRndNId();
301      } while (TryCnt++ < MaxTryCnt && NIDCIDPrS.IsKey(TIntPr(NID, JoinCID)));
302      if (TryCnt < MaxTryCnt) { 
303        DeltaL = SeekJoin(NID, JoinCID);
304      }
305    }
306    else if (Option == 1) {
307      do {
308        TIntPr NIDCIDPr = NIDCIDPrS.GetKey(NIDCIDPrS.GetRndKeyId(Rnd));
309        NID = NIDCIDPr.Val1;
310        LeaveCID = NIDCIDPr.Val2;
311      } while (TryCnt++ < MaxTryCnt && LeaveCID == BaseCID);
312      if (TryCnt < MaxTryCnt) {
313        DeltaL = SeekLeave(NID, LeaveCID);
314      }
315    }
316    else{
317      do {
318        TIntPr NIDCIDPr = NIDCIDPrS.GetKey(NIDCIDPrS.GetRndKeyId(Rnd));
319        NID = NIDCIDPr.Val1;
320        LeaveCID = NIDCIDPr.Val2;
321      } while (TryCnt++ < MaxTryCnt && (NIDComVH.GetDat(NID).Len() == CIDNSetV.Len() || LeaveCID == BaseCID));
322      do {
323        JoinCID = Rnd.GetUniDevInt(CIDNSetV.Len());
324      } while (TryCnt++ < G->GetNodes() && NIDCIDPrS.IsKey(TIntPr(NID, JoinCID)));
325      if (TryCnt < MaxTryCnt) {
326        DeltaL = SeekSwitch(NID, LeaveCID, JoinCID);
327      }
328    }
329  }
330  void TAGMFit::RunMCMC(const int& MaxIter, const int& EvalLambdaIter, const TStr& PlotFPrx) {
331    TExeTm IterTm, TotalTm;
332    double PrevL = Likelihood(), DeltaL = 0;
333    double BestL = PrevL;
334    printf("initial likelihood = %f\n",PrevL);
335    TIntFltPrV IterTrueLV, IterJoinV, IterLeaveV, IterAcceptV, IterSwitchV, IterLBV;
336    TIntPrV IterTotMemV;
337    TIntV IterV;
338    TFltV BestLV;
339    TVec<TIntSet> BestCmtySetV;
340    int SwitchCnt = 0, LeaveCnt = 0, JoinCnt = 0, AcceptCnt = 0, ProbBinSz;
341    int Nodes = G->GetNodes(), Edges = G->GetEdges();
342    TExeTm PlotTm;
343    ProbBinSz = TMath::Mx(1000, G->GetNodes() / 10); 
344    IterLBV.Add(TIntFltPr(1, BestL));
345    for (int iter = 0; iter < MaxIter; iter++) {
346      IterTm.Tick();
347      int NID = -1;
348      int JoinCID = -1, LeaveCID = -1;
349      SampleTransition(NID, JoinCID, LeaveCID, DeltaL); 
350      double OptL = PrevL;
351      if (DeltaL > 0 || Rnd.GetUniDev() < exp(DeltaL)) { 
352        IterTm.Tick();
353        if (LeaveCID > -1 && LeaveCID != BaseCID) { LeaveCom(NID, LeaveCID); }
354        if (JoinCID > -1 && JoinCID != BaseCID) { JoinCom(NID, JoinCID); }
355        if (LeaveCID > -1 && JoinCID > -1 && JoinCID != BaseCID && LeaveCID != BaseCID) { SwitchCnt++; }
356        else if (LeaveCID > -1  && LeaveCID != BaseCID) { LeaveCnt++;}
357        else if (JoinCID > -1 && JoinCID != BaseCID) { JoinCnt++;}
358        AcceptCnt++;
359        if ((iter + 1) % EvalLambdaIter == 0) {
360          IterTm.Tick();
361          MLEGradAscentGivenCAG(0.01, 3);
362          OptL = Likelihood();
363        }
364        else{
365          OptL = PrevL + DeltaL;
366        }
367        if (BestL <= OptL && CIDNSetV.Len() > 0) {
368          BestCmtySetV = CIDNSetV;
369          BestLV = LambdaV;
370          BestL = OptL;
371        }
372      }
373      if (iter > 0 && (iter % ProbBinSz == 0) && PlotFPrx.Len() > 0) { 
374        IterLBV.Add(TIntFltPr(iter, OptL));
375        IterSwitchV.Add(TIntFltPr(iter, (double) SwitchCnt / (double) AcceptCnt));
376        IterLeaveV.Add(TIntFltPr(iter, (double) LeaveCnt / (double) AcceptCnt));
377        IterJoinV.Add(TIntFltPr(iter, (double) JoinCnt / (double) AcceptCnt));
378        IterAcceptV.Add(TIntFltPr(iter, (double) AcceptCnt / (double) ProbBinSz));
379        SwitchCnt = JoinCnt = LeaveCnt = AcceptCnt = 0;
380      }
381      PrevL = OptL;
382      if ((iter + 1) % 10000 == 0) {
383        printf("\r%d iterations completed [%.2f]", iter, (double) iter / (double) MaxIter);
384      }
385    }
386    if (PlotFPrx.Len() > 0) {
387      TGnuPlot GP1;
388      GP1.AddPlot(IterLBV, gpwLinesPoints, "likelihood");
389      GP1.SetDataPlotFNm(PlotFPrx + ".likelihood.tab", PlotFPrx + ".likelihood.plt");
390      TStr TitleStr = TStr::Fmt(" N:%d E:%d", Nodes, Edges);
391      GP1.SetTitle(PlotFPrx + ".likelihood" + TitleStr);
392      GP1.SavePng(PlotFPrx + ".likelihood.png");
393      TGnuPlot GP2;
394      GP2.AddPlot(IterSwitchV, gpwLinesPoints, "Switch");
395      GP2.AddPlot(IterLeaveV, gpwLinesPoints, "Leave");
396      GP2.AddPlot(IterJoinV, gpwLinesPoints, "Join");
397      GP2.AddPlot(IterAcceptV, gpwLinesPoints, "Accept");
398      GP2.SetTitle(PlotFPrx + ".transition");
399      GP2.SetDataPlotFNm(PlotFPrx + "transition_prob.tab", PlotFPrx + "transition_prob.plt");
400      GP2.SavePng(PlotFPrx + "transition_prob.png");
401    }
402    CIDNSetV = BestCmtySetV;
403    LambdaV = BestLV;
404    InitNodeData();
405    MLEGradAscentGivenCAG(0.001, 100);
406    printf("\nMCMC completed (best likelihood: %.2f) [%s]\n", BestL, TotalTm.GetTmStr());
407  }
408  void TAGMFit::GetQV(TFltV& OutV) {
409    OutV.Gen(LambdaV.Len());
410    for (int i = 0; i < LambdaV.Len(); i++) {
411      OutV[i] = exp(- LambdaV[i]);
412    }
413  }
414  int TAGMFit::RemoveEmptyCom() {
415    int DelCnt = 0;
416    for (int c = 0; c < CIDNSetV.Len(); c++) {
417      if (CIDNSetV[c].Len() == 0) {
418        CIDNSetV[c] = CIDNSetV.Last();
419        CIDNSetV.DelLast();
420        LambdaV[c] = LambdaV.Last();
421        LambdaV.DelLast();
422        DelCnt++;
423        c--;
424      }
425    }
426    return DelCnt;
427  }
428  double TAGMFit::SeekLeave(const int& UID, const int& CID) {
429    IAssert(CIDNSetV[CID].IsKey(UID));
430    IAssert(G->IsNode(UID));
431    double Delta = 0.0;
432    TUNGraph::TNodeI NI = G->GetNI(UID);
433    int NbhsInC = 0;
434    for (int e = 0; e < NI.GetDeg(); e++) {
435      const int VID = NI.GetNbrNId(e);
436      if (! NIDComVH.GetDat(VID).IsKey(CID)) { continue; }
437      TIntPr SrcDstNIDPr(TMath::Mn(UID,VID), TMath::Mx(UID,VID));
438      TIntSet& JointCom = EdgeComVH.GetDat(SrcDstNIDPr);
439      double CurPuv, NewPuv, LambdaSum = SelectLambdaSum(JointCom);
440      CurPuv = 1 - exp(- LambdaSum);
441      NewPuv = 1 - exp(- LambdaSum + LambdaV[CID]);
442      IAssert(JointCom.Len() > 0);
443      if (JointCom.Len() == 1) {
444        NewPuv = PNoCom;
445      }
446      Delta += (log(NewPuv) - log(CurPuv));
447      IAssert(!_isnan(Delta));
448      NbhsInC++;
449    }
450    Delta += LambdaV[CID] * (CIDNSetV[CID].Len() - 1 - NbhsInC);
451    return Delta;
452  }
453  double TAGMFit::SeekJoin(const int& UID, const int& CID) {
454    IAssert(! CIDNSetV[CID].IsKey(UID));
455    double Delta = 0.0;
456    TUNGraph::TNodeI NI = G->GetNI(UID);
457    int NbhsInC = 0;
458    for (int e = 0; e < NI.GetDeg(); e++) {
459      const int VID = NI.GetNbrNId(e);
460      if (! NIDComVH.GetDat(VID).IsKey(CID)) { continue; }
461      TIntPr SrcDstNIDPr(TMath::Mn(UID,VID), TMath::Mx(UID,VID));
462      TIntSet& JointCom = EdgeComVH.GetDat(SrcDstNIDPr);
463      double CurPuv, NewPuv, LambdaSum = SelectLambdaSum(JointCom);
464      CurPuv = 1 - exp(- LambdaSum);
465      if (JointCom.Len() == 0) { CurPuv = PNoCom; }
466      NewPuv = 1 - exp(- LambdaSum - LambdaV[CID]);
467      Delta += (log(NewPuv) - log(CurPuv));
468      IAssert(!_isnan(Delta));
469      NbhsInC++;
470    }
471    Delta -= LambdaV[CID] * (CIDNSetV[CID].Len() - NbhsInC);
472    return Delta;
473  }
474  double TAGMFit::SeekSwitch(const int& UID, const int& CurCID, const int& NewCID) {
475    IAssert(! CIDNSetV[NewCID].IsKey(UID));
476    IAssert(CIDNSetV[CurCID].IsKey(UID));
477    double Delta = SeekJoin(UID, NewCID) + SeekLeave(UID, CurCID);
478    TUNGraph::TNodeI NI = G->GetNI(UID);
479    for (int e = 0; e < NI.GetDeg(); e++) {
480      const int VID = NI.GetNbrNId(e);
481      if (! NIDComVH.GetDat(VID).IsKey(CurCID) || ! NIDComVH.GetDat(VID).IsKey(NewCID)) {continue;}
482      TIntPr SrcDstNIDPr(TMath::Mn(UID,VID), TMath::Mx(UID,VID));
483      TIntSet& JointCom = EdgeComVH.GetDat(SrcDstNIDPr);
484      double CurPuv, NewPuvAfterJoin, NewPuvAfterLeave, NewPuvAfterSwitch, LambdaSum = SelectLambdaSum(JointCom);
485      CurPuv = 1 - exp(- LambdaSum);
486      NewPuvAfterLeave = 1 - exp(- LambdaSum + LambdaV[CurCID]);
487      NewPuvAfterJoin = 1 - exp(- LambdaSum - LambdaV[NewCID]);
488      NewPuvAfterSwitch = 1 - exp(- LambdaSum - LambdaV[NewCID] + LambdaV[CurCID]);
489      if (JointCom.Len() == 1 || NewPuvAfterLeave == 0.0) {
490        NewPuvAfterLeave = PNoCom;
491      }
492      Delta += (log(NewPuvAfterSwitch) + log(CurPuv) - log(NewPuvAfterLeave) - log(NewPuvAfterJoin));
493      if (_isnan(Delta)) {
494        printf("NS:%f C:%f NL:%f NJ:%f PNoCom:%f", NewPuvAfterSwitch, CurPuv, NewPuvAfterLeave, NewPuvAfterJoin, PNoCom.Val);
495      }
496      IAssert(!_isnan(Delta));
497    }
498    return Delta;
499  }
500  void TAGMFit::GetCmtyVV(TVec<TIntV>& CmtyVV, const double QMax) {
501    TFltV TmpQV;
502    GetCmtyVV(CmtyVV, TmpQV, QMax);
503  }
504  void TAGMFit::GetCmtyVV(TVec<TIntV>& CmtyVV, TFltV& QV, const double QMax) {
505    CmtyVV.Gen(CIDNSetV.Len(), 0);
506    QV.Gen(CIDNSetV.Len(), 0);
507    TIntFltH CIDLambdaH(CIDNSetV.Len());
508    for (int c = 0; c < CIDNSetV.Len(); c++) {
509      CIDLambdaH.AddDat(c, LambdaV[c]);
510    }
511    CIDLambdaH.SortByDat(false);
512    for (int c = 0; c < CIDNSetV.Len(); c++) {
513      int CID = CIDLambdaH.GetKey(c);
514      IAssert(LambdaV[CID] >= MinLambda);
515      double Q = exp( - (double) LambdaV[CID]);
516      if (Q > QMax) { continue; }
517      TIntV CmtyV;
518      CIDNSetV[CID].GetKeyV(CmtyV);
519      if (CmtyV.Len() == 0) { continue; }
520      if (CID == BaseCID) { 
521        IAssert(CmtyV.Len() == G->GetNodes());
522      } else {
523        CmtyVV.Add(CmtyV);
524        QV.Add(Q);
525      }
526    }
527  }
528  void TAGMFit::SetCmtyVV(const TVec<TIntV>& CmtyVV) {
529    CIDNSetV.Gen(CmtyVV.Len());
530    for (int c = 0; c < CIDNSetV.Len(); c++) {
531      CIDNSetV[c].AddKeyV(CmtyVV[c]);
532      for (int j = 0; j < CmtyVV[c].Len(); j++) { IAssert(G->IsNode(CmtyVV[c][j])); } 
533    }
534    InitNodeData();
535    SetDefaultPNoCom();
536  }
537  void TAGMFit::GradLogLForLambda(TFltV& GradV) {
538    GradV.Gen(LambdaV.Len());
539    TFltV SumEdgeProbsV(LambdaV.Len());
540    for (int e = 0; e < EdgeComVH.Len(); e++) {
541      TIntSet& JointCom = EdgeComVH[e];
542      double LambdaSum = SelectLambdaSum(JointCom);
543      double Puv = 1 - exp(- LambdaSum);
544      if (JointCom.Len() == 0) {  Puv = PNoCom;  }
545      for (TIntSet::TIter SI = JointCom.BegI(); SI < JointCom.EndI(); SI++) {
546        SumEdgeProbsV[SI.GetKey()] += (1 - Puv) / Puv;
547      }
548    }
549    for (int k = 0; k < LambdaV.Len(); k++) {
550      int MaxEk = CIDNSetV[k].Len() * (CIDNSetV[k].Len() - 1) / 2;
551      int NotEdgesInCom = MaxEk - ComEdgesV[k];
552      GradV[k] = SumEdgeProbsV[k] - (double) NotEdgesInCom;
553      if (LambdaV[k] > 0.0 && RegCoef > 0.0) { 
554        GradV[k] -= RegCoef;
555      }
556    }
557  }
558  double TAGMFit::SelectLambdaSum(const TIntSet& ComK) { 
559    return SelectLambdaSum(LambdaV, ComK); 
560  }
561  double TAGMFit::SelectLambdaSum(const TFltV& NewLambdaV, const TIntSet& ComK) {
562    double Result = 0.0;
563    for (TIntSet::TIter SI = ComK.BegI(); SI < ComK.EndI(); SI++) {
564      IAssert(NewLambdaV[SI.GetKey()] >= 0);
565      Result += NewLambdaV[SI.GetKey()];
566    }
567    return Result;
568  }
569  double TAGMFit::CalcPNoComByCmtyVV(const int& SamplePairs) {
570    TIntV NIdV;
571    G->GetNIdV(NIdV);
572    uint64 PairNoCom = 0, EdgesNoCom = 0;
573    for (int u = 0; u < NIdV.Len(); u++) {
574      for (int v = u + 1; v < NIdV.Len(); v++) {
575        int SrcNID = NIdV[u], DstNID = NIdV[v];
576        TIntSet JointCom;
577        TAGMUtil::GetIntersection(NIDComVH.GetDat(SrcNID),NIDComVH.GetDat(DstNID),JointCom);
578        if(JointCom.Len() == 0) {
579          PairNoCom++;
580          if (G->IsEdge(SrcNID, DstNID)) { EdgesNoCom++; }
581          if (SamplePairs > 0 && PairNoCom >= (uint64) SamplePairs) { break; }
582        }
583      }
584      if (SamplePairs > 0 && PairNoCom >= (uint64) SamplePairs) { break; }
585    }
586    double DefaultVal = 1.0 / (double)G->GetNodes() / (double)G->GetNodes();
587    if (EdgesNoCom > 0) {
588      PNoCom = (double) EdgesNoCom / (double) PairNoCom;
589    } else {
590      PNoCom = DefaultVal;
591    }
592    printf("%s / %s edges without joint com detected (PNoCom = %f)\n", TUInt64::GetStr(EdgesNoCom).CStr(), TUInt64::GetStr(PairNoCom).CStr(), PNoCom.Val);
593    return PNoCom;
594  }
595  void TAGMFit::PrintSummary() {
596    TIntFltH CIDLambdaH(CIDNSetV.Len());
597    for (int c = 0; c < CIDNSetV.Len(); c++) {
598      CIDLambdaH.AddDat(c, LambdaV[c]);
599    }
600    CIDLambdaH.SortByDat(false);
601    int Coms = 0;
602    for (int i = 0; i < LambdaV.Len(); i++) {
603      int CID = CIDLambdaH.GetKey(i);
604      if (LambdaV[CID] <= 0.0001) { continue; }
605      printf("P_c : %.3f Com Sz: %d, Total Edges inside: %d \n", 1.0 - exp(- LambdaV[CID]), CIDNSetV[CID].Len(), (int) ComEdgesV[CID]);
606      Coms++;
607    }
608    printf("%d Communities, Total Memberships = %d, Likelihood = %.2f, Epsilon = %f\n", Coms, NIDCIDPrS.Len(), Likelihood(), PNoCom.Val);
609  }
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-agmfit.cpp</h3>
            <pre><code>1  #include "stdafx.h"
2  #include "agmfit.h"
3  #include "agm.h"
4  void TAGMFit::Save(TSOut& SOut) {
5    G->Save(SOut);
6    CIDNSetV.Save(SOut);
7    EdgeComVH.Save(SOut);
8    NIDComVH.Save(SOut);
9    ComEdgesV.Save(SOut);
10    PNoCom.Save(SOut);
11    LambdaV.Save(SOut);
12    NIDCIDPrH.Save(SOut);
13    NIDCIDPrS.Save(SOut);
14    MinLambda.Save(SOut);
15    MaxLambda.Save(SOut);
16    RegCoef.Save(SOut);
17    BaseCID.Save(SOut);
18  }
19  void TAGMFit::Load(TSIn& SIn, const int& RndSeed) {
20    G = TUNGraph::Load(SIn);
21    CIDNSetV.Load(SIn);
22    EdgeComVH.Load(SIn);
23    NIDComVH.Load(SIn);
24    ComEdgesV.Load(SIn);
25    PNoCom.Load(SIn);
26    LambdaV.Load(SIn);
27    NIDCIDPrH.Load(SIn);
28    NIDCIDPrS.Load(SIn);
29    MinLambda.Load(SIn);
30    MaxLambda.Load(SIn);
31    RegCoef.Load(SIn);
32    BaseCID.Load(SIn);
33    Rnd.PutSeed(RndSeed);
34  }
35  void TAGMFit::RandomInitCmtyVV(const int InitComs, const double ComSzAlpha, const double MemAlpha, const int MinComSz, const int MaxComSz, const int MinMem, const int MaxMem) {
36    TVec<TIntV> InitCmtyVV(InitComs, 0);
37    TAGMUtil::GenCmtyVVFromPL(InitCmtyVV, G, G->GetNodes(), InitComs, ComSzAlpha, MemAlpha, MinComSz, MaxComSz,
38        MinMem, MaxMem, Rnd);
39    SetCmtyVV(InitCmtyVV);
40  }
41  void TAGMFit::GetEdgeJointCom() {
42    ComEdgesV.Gen(CIDNSetV.Len());
43    EdgeComVH.Gen(G->GetEdges());
44    for (TUNGraph::TNodeI SrcNI = G->BegNI(); SrcNI < G->EndNI(); SrcNI++) {
45      int SrcNID = SrcNI.GetId();
46      for (int v = 0; v < SrcNI.GetDeg(); v++) {
47        int DstNID = SrcNI.GetNbrNId(v);
48        if (SrcNID >= DstNID) { continue; }
49        TIntSet JointCom;
50        IAssert(NIDComVH.IsKey(SrcNID));
51        IAssert(NIDComVH.IsKey(DstNID));
52        TAGMUtil::GetIntersection(NIDComVH.GetDat(SrcNID), NIDComVH.GetDat(DstNID), JointCom);
53        EdgeComVH.AddDat(TIntPr(SrcNID,DstNID),JointCom);
54        for (int k = 0; k < JointCom.Len(); k++) {
55          ComEdgesV[JointCom[k]]++;
56        }
57      }
58    }
59    IAssert(EdgeComVH.Len() == G->GetEdges());
60  }
61  void TAGMFit::SetDefaultPNoCom() {
62    PNoCom = 1.0 / (double) G->GetNodes() / (double) G->GetNodes();
63  }
64  double TAGMFit::Likelihood(const TFltV& NewLambdaV, double& LEdges, double& LNoEdges) {
65    IAssert(CIDNSetV.Len() == NewLambdaV.Len());
66    IAssert(ComEdgesV.Len() == CIDNSetV.Len());
67    LEdges = 0.0; LNoEdges = 0.0;
68    for (int e = 0; e < EdgeComVH.Len(); e++) {
69      TIntSet& JointCom = EdgeComVH[e];
70      double LambdaSum = SelectLambdaSum(NewLambdaV, JointCom);
71      double Puv = 1 - exp(- LambdaSum);
72      if (JointCom.Len() == 0) {  Puv = PNoCom;  }
73      IAssert(! _isnan(log(Puv)));
74      LEdges += log(Puv);
75    }
76    for (int k = 0; k < NewLambdaV.Len(); k++) {
77      int MaxEk = CIDNSetV[k].Len() * (CIDNSetV[k].Len() - 1) / 2;
78      int NotEdgesInCom = MaxEk - ComEdgesV[k];
79      if(NotEdgesInCom > 0) {
80        if (LNoEdges >= TFlt::Mn + double(NotEdgesInCom) * NewLambdaV[k]) { 
81          LNoEdges -= double(NotEdgesInCom) * NewLambdaV[k];
82        }
83      }
84    }
85    double LReg = 0.0;
86    if (RegCoef > 0.0) {
87      LReg = - RegCoef * TLinAlg::SumVec(NewLambdaV);
88    }
89    return LEdges + LNoEdges + LReg;
90  }
91  double TAGMFit::Likelihood() { 
92    return Likelihood(LambdaV); 
93  }
94  double TAGMFit::GetStepSizeByLineSearchForLambda(const TFltV& DeltaV, const TFltV& GradV, const double& Alpha, const double& Beta) {
95    double StepSize = 1.0;
96    double InitLikelihood = Likelihood();
97    IAssert(LambdaV.Len() == DeltaV.Len());
98    TFltV NewLambdaV(LambdaV.Len());
99    for (int iter = 0; ; iter++) {
100      for (int i = 0; i < LambdaV.Len(); i++) {
101        NewLambdaV[i] = LambdaV[i] + StepSize * DeltaV[i];
102        if (NewLambdaV[i] < MinLambda) { NewLambdaV[i] = MinLambda; }
103        if (NewLambdaV[i] > MaxLambda) { NewLambdaV[i] = MaxLambda; }
104      }
105      if (Likelihood(NewLambdaV) < InitLikelihood + Alpha * StepSize * TLinAlg::DotProduct(GradV, DeltaV)) {
106        StepSize *= Beta;
107      } else {
108        break;
109      }
110    }
111    return StepSize;
112  }
113  int TAGMFit::MLEGradAscentGivenCAG(const double& Thres, const int& MaxIter, const TStr PlotNm) {
114    int Edges = G->GetEdges();
115    TExeTm ExeTm;
116    TFltV GradV(LambdaV.Len());
117    int iter = 0;
118    TIntFltPrV IterLV, IterGradNormV;
119    double GradCutOff = 1000;
120    for (iter = 0; iter < MaxIter; iter++) {
121      GradLogLForLambda(GradV);    
122      for (int i = 0; i < LambdaV.Len(); i++) {
123        if (GradV[i] < -GradCutOff) { GradV[i] = -GradCutOff; }
124        if (GradV[i] > GradCutOff) { GradV[i] = GradCutOff; }
125        if (LambdaV[i] <= MinLambda && GradV[i] < 0) { GradV[i] = 0.0; }
126        if (LambdaV[i] >= MaxLambda && GradV[i] > 0) { GradV[i] = 0.0; }
127      }
128      double Alpha = 0.15, Beta = 0.2;
129      if (Edges > Kilo(100)) { Alpha = 0.00015; Beta = 0.3;}
130      double LearnRate = GetStepSizeByLineSearchForLambda(GradV, GradV, Alpha, Beta);
131      if (TLinAlg::Norm(GradV) < Thres) { break; }
132      for (int i = 0; i < LambdaV.Len(); i++) {
133        double Change = LearnRate * GradV[i];
134        LambdaV[i] += Change;
135        if(LambdaV[i] < MinLambda) { LambdaV[i] = MinLambda;}
136        if(LambdaV[i] > MaxLambda) { LambdaV[i] = MaxLambda;}
137      }
138      if (! PlotNm.Empty()) {
139        double L = Likelihood();
140        IterLV.Add(TIntFltPr(iter, L));
141        IterGradNormV.Add(TIntFltPr(iter, TLinAlg::Norm(GradV)));
142      }
143    }
144    if (! PlotNm.Empty()) {
145      TGnuPlot::PlotValV(IterLV, PlotNm + ".likelihood_Q");
146      TGnuPlot::PlotValV(IterGradNormV, PlotNm + ".gradnorm_Q");
147      printf("MLE for Lambda completed with %d iterations(%s)\n",iter,ExeTm.GetTmStr());
148    }
149    return iter;
150  }
151  void TAGMFit::RandomInit(const int& MaxK) {
152    CIDNSetV.Clr();
153    for (int c = 0; c < MaxK; c++) {
154      CIDNSetV.Add();
155      int NC = Rnd.GetUniDevInt(G -> GetNodes());
156      TUNGraph::TNodeI NI = G -> GetRndNI();
157      CIDNSetV.Last().AddKey(NI.GetId());
158      for (int v = 0; v < NC; v++) {
159        NI = G->GetNI(NI.GetNbrNId(Rnd.GetUniDevInt(NI.GetDeg())));
160        CIDNSetV.Last().AddKey(NI.GetId());
161      }
162    }
163    InitNodeData();
164    SetDefaultPNoCom();
165  }
166  void TAGMFit::NeighborComInit(const int InitComs) {
167    CIDNSetV.Gen(InitComs);
168    const int Edges = G->GetEdges();
169    TFltIntPrV NIdPhiV(G->GetNodes(), 0);
170    TIntSet InvalidNIDS(G->GetNodes());
171    TIntV ChosenNIDV(InitComs, 0); 
172    TExeTm RunTm;
173    TIntV NIdV;
174    G->GetNIdV(NIdV);
175    for (int u = 0; u < NIdV.Len(); u++) {
176      TIntSet NBCmty(G->GetNI(NIdV[u]).GetDeg() + 1);
177      double Phi;
178      if (G->GetNI(NIdV[u]).GetDeg() < 5) { 
179        Phi = 1.0; 
180      } else {
181        TAGMUtil::GetNbhCom(G, NIdV[u], NBCmty);
182        IAssert(NBCmty.Len() == G->GetNI(NIdV[u]).GetDeg() + 1);
183        Phi = TAGMUtil::GetConductance(G, NBCmty, Edges);
184      }
185      NIdPhiV.Add(TFltIntPr(Phi, NIdV[u]));
186    }
187    NIdPhiV.Sort(true);
188    printf("conductance computation completed [%s]\n", RunTm.GetTmStr());
189    fflush(stdout);
190    int CurCID = 0;
191    for (int ui = 0; ui < NIdPhiV.Len(); ui++) {
192      int UID = NIdPhiV[ui].Val2;
193      fflush(stdout);
194      if (InvalidNIDS.IsKey(UID)) { continue; }
195      ChosenNIDV.Add(UID); 
196      CIDNSetV[CurCID].AddKey(UID);
197      TUNGraph::TNodeI NI = G->GetNI(UID);
198      fflush(stdout);
199      for (int e = 0; e < NI.GetDeg(); e++) {
200        CIDNSetV[CurCID].AddKey(NI.GetNbrNId(e));
201      }
202      for (int e = 0; e < NI.GetDeg(); e++) {
203        InvalidNIDS.AddKey(NI.GetNbrNId(e));
204      }
205      CurCID++;
206      fflush(stdout);
207      if (CurCID >= InitComs) { break;  }
208    }
209    if (InitComs > CurCID) {
210      printf("%d communities needed to fill randomly\n", InitComs - CurCID);
211    }
212    for (int c = 0; c < CIDNSetV.Len(); c++) {
213      if (CIDNSetV[c].Len() == 0) {
214        int ComSz = 10;
215        for (int u = 0; u < ComSz; u++) {
216          int UID = G->GetRndNI().GetId();
217          CIDNSetV[c].AddKey(UID);
218        }
219      }
220    }
221    InitNodeData();
222    SetDefaultPNoCom();
223  }
224  void TAGMFit::AddBaseCmty() {
225    TVec<TIntV> CmtyVV;
226    GetCmtyVV(CmtyVV);
227    TIntV TmpV = CmtyVV[0];
228    CmtyVV.Add(TmpV);
229    G->GetNIdV(CmtyVV[0]);
230    IAssert(CIDNSetV.Len() + 1 == CmtyVV.Len());
231    SetCmtyVV(CmtyVV);
232    InitNodeData();
233    BaseCID = 0;
234    PNoCom = 0.0;
235  }
236  void TAGMFit::InitNodeData() {
237    TSnap::DelSelfEdges(G);
238    NIDComVH.Gen(G->GetNodes());
239    for (TUNGraph::TNodeI NI = G->BegNI(); NI < G->EndNI(); NI++) {
240      NIDComVH.AddDat(NI.GetId());
241    }
242    TAGMUtil::GetNodeMembership(NIDComVH, CIDNSetV);
243    GetEdgeJointCom();
244    LambdaV.Gen(CIDNSetV.Len());
245    for (int c = 0; c < CIDNSetV.Len(); c++) {
246      int MaxE = (CIDNSetV[c].Len()) * (CIDNSetV[c].Len() - 1) / 2;
247      if (MaxE < 2) {
248        LambdaV[c] = MaxLambda;
249      }
250      else{
251        LambdaV[c] = -log((double) (MaxE - ComEdgesV[c]) / MaxE);
252      }
253      if (LambdaV[c] > MaxLambda) {  LambdaV[c] = MaxLambda;  }
254      if (LambdaV[c] < MinLambda) {  LambdaV[c] = MinLambda;  }
255    }
256    NIDCIDPrS.Gen(G->GetNodes() * 10);
257    for (int c = 0; c < CIDNSetV.Len(); c++) {
258      for (TIntSet::TIter SI = CIDNSetV[c].BegI(); SI < CIDNSetV[c].EndI(); SI++) {
259        NIDCIDPrS.AddKey(TIntPr(SI.GetKey(), c));
260      }
261    }
262  }
263  void TAGMFit::LeaveCom(const int& NID, const int& CID) {
264    TUNGraph::TNodeI NI = G->GetNI(NID);
265    for (int e = 0; e < NI.GetDeg(); e++) {
266      int VID = NI.GetNbrNId(e);
267      if (NIDComVH.GetDat(VID).IsKey(CID)) {
268        TIntPr SrcDstNIDPr = TIntPr(TMath::Mn(NID,VID), TMath::Mx(NID,VID));
269        EdgeComVH.GetDat(SrcDstNIDPr).DelKey(CID);
270        ComEdgesV[CID]--;
271      }
272    }
273    CIDNSetV[CID].DelKey(NID);
274    NIDComVH.GetDat(NID).DelKey(CID);
275    NIDCIDPrS.DelKey(TIntPr(NID, CID));
276  }
277  void TAGMFit::JoinCom(const int& NID, const int& JoinCID) {
278    TUNGraph::TNodeI NI = G->GetNI(NID);
279    for (int e = 0; e < NI.GetDeg(); e++) {
280      int VID = NI.GetNbrNId(e);
281      if (NIDComVH.GetDat(VID).IsKey(JoinCID)) {
<span onclick='openModal()' class='match'>282        TIntPr SrcDstNIDPr = TIntPr(TMath::Mn(NID,VID), TMath::Mx(NID,VID));
283        EdgeComVH.GetDat(SrcDstNIDPr).AddKey(JoinCID);
284        ComEdgesV[JoinCID]++;
</span>285      }
286    }
287    CIDNSetV[JoinCID].AddKey(NID);
288    NIDComVH.GetDat(NID).AddKey(JoinCID);
289    NIDCIDPrS.AddKey(TIntPr(NID, JoinCID));
290  }
291  void TAGMFit::SampleTransition(int& NID, int& JoinCID, int& LeaveCID, double& DeltaL) {
292    int Option = Rnd.GetUniDevInt(3); 
293    if (NIDCIDPrS.Len() <= 1) {    Option = 0;  } 
294    int TryCnt = 0;
295    const int MaxTryCnt = G->GetNodes();
296    DeltaL = TFlt::Mn;
297    if (Option == 0) {
298      do {
299        JoinCID = Rnd.GetUniDevInt(CIDNSetV.Len());
300        NID = G->GetRndNId();
301      } while (TryCnt++ < MaxTryCnt && NIDCIDPrS.IsKey(TIntPr(NID, JoinCID)));
302      if (TryCnt < MaxTryCnt) { 
303        DeltaL = SeekJoin(NID, JoinCID);
304      }
305    }
306    else if (Option == 1) {
307      do {
308        TIntPr NIDCIDPr = NIDCIDPrS.GetKey(NIDCIDPrS.GetRndKeyId(Rnd));
309        NID = NIDCIDPr.Val1;
310        LeaveCID = NIDCIDPr.Val2;
311      } while (TryCnt++ < MaxTryCnt && LeaveCID == BaseCID);
312      if (TryCnt < MaxTryCnt) {
313        DeltaL = SeekLeave(NID, LeaveCID);
314      }
315    }
316    else{
317      do {
318        TIntPr NIDCIDPr = NIDCIDPrS.GetKey(NIDCIDPrS.GetRndKeyId(Rnd));
319        NID = NIDCIDPr.Val1;
320        LeaveCID = NIDCIDPr.Val2;
321      } while (TryCnt++ < MaxTryCnt && (NIDComVH.GetDat(NID).Len() == CIDNSetV.Len() || LeaveCID == BaseCID));
322      do {
323        JoinCID = Rnd.GetUniDevInt(CIDNSetV.Len());
324      } while (TryCnt++ < G->GetNodes() && NIDCIDPrS.IsKey(TIntPr(NID, JoinCID)));
325      if (TryCnt < MaxTryCnt) {
326        DeltaL = SeekSwitch(NID, LeaveCID, JoinCID);
327      }
328    }
329  }
330  void TAGMFit::RunMCMC(const int& MaxIter, const int& EvalLambdaIter, const TStr& PlotFPrx) {
331    TExeTm IterTm, TotalTm;
332    double PrevL = Likelihood(), DeltaL = 0;
333    double BestL = PrevL;
334    printf("initial likelihood = %f\n",PrevL);
335    TIntFltPrV IterTrueLV, IterJoinV, IterLeaveV, IterAcceptV, IterSwitchV, IterLBV;
336    TIntPrV IterTotMemV;
337    TIntV IterV;
338    TFltV BestLV;
339    TVec<TIntSet> BestCmtySetV;
340    int SwitchCnt = 0, LeaveCnt = 0, JoinCnt = 0, AcceptCnt = 0, ProbBinSz;
341    int Nodes = G->GetNodes(), Edges = G->GetEdges();
342    TExeTm PlotTm;
343    ProbBinSz = TMath::Mx(1000, G->GetNodes() / 10); 
344    IterLBV.Add(TIntFltPr(1, BestL));
345    for (int iter = 0; iter < MaxIter; iter++) {
346      IterTm.Tick();
347      int NID = -1;
348      int JoinCID = -1, LeaveCID = -1;
349      SampleTransition(NID, JoinCID, LeaveCID, DeltaL); 
350      double OptL = PrevL;
351      if (DeltaL > 0 || Rnd.GetUniDev() < exp(DeltaL)) { 
352        IterTm.Tick();
353        if (LeaveCID > -1 && LeaveCID != BaseCID) { LeaveCom(NID, LeaveCID); }
354        if (JoinCID > -1 && JoinCID != BaseCID) { JoinCom(NID, JoinCID); }
355        if (LeaveCID > -1 && JoinCID > -1 && JoinCID != BaseCID && LeaveCID != BaseCID) { SwitchCnt++; }
356        else if (LeaveCID > -1  && LeaveCID != BaseCID) { LeaveCnt++;}
357        else if (JoinCID > -1 && JoinCID != BaseCID) { JoinCnt++;}
358        AcceptCnt++;
359        if ((iter + 1) % EvalLambdaIter == 0) {
360          IterTm.Tick();
361          MLEGradAscentGivenCAG(0.01, 3);
362          OptL = Likelihood();
363        }
364        else{
365          OptL = PrevL + DeltaL;
366        }
367        if (BestL <= OptL && CIDNSetV.Len() > 0) {
368          BestCmtySetV = CIDNSetV;
369          BestLV = LambdaV;
370          BestL = OptL;
371        }
372      }
373      if (iter > 0 && (iter % ProbBinSz == 0) && PlotFPrx.Len() > 0) { 
374        IterLBV.Add(TIntFltPr(iter, OptL));
375        IterSwitchV.Add(TIntFltPr(iter, (double) SwitchCnt / (double) AcceptCnt));
376        IterLeaveV.Add(TIntFltPr(iter, (double) LeaveCnt / (double) AcceptCnt));
377        IterJoinV.Add(TIntFltPr(iter, (double) JoinCnt / (double) AcceptCnt));
378        IterAcceptV.Add(TIntFltPr(iter, (double) AcceptCnt / (double) ProbBinSz));
379        SwitchCnt = JoinCnt = LeaveCnt = AcceptCnt = 0;
380      }
381      PrevL = OptL;
382      if ((iter + 1) % 10000 == 0) {
383        printf("\r%d iterations completed [%.2f]", iter, (double) iter / (double) MaxIter);
384      }
385    }
386    if (PlotFPrx.Len() > 0) {
387      TGnuPlot GP1;
388      GP1.AddPlot(IterLBV, gpwLinesPoints, "likelihood");
389      GP1.SetDataPlotFNm(PlotFPrx + ".likelihood.tab", PlotFPrx + ".likelihood.plt");
390      TStr TitleStr = TStr::Fmt(" N:%d E:%d", Nodes, Edges);
391      GP1.SetTitle(PlotFPrx + ".likelihood" + TitleStr);
392      GP1.SavePng(PlotFPrx + ".likelihood.png");
393      TGnuPlot GP2;
394      GP2.AddPlot(IterSwitchV, gpwLinesPoints, "Switch");
395      GP2.AddPlot(IterLeaveV, gpwLinesPoints, "Leave");
396      GP2.AddPlot(IterJoinV, gpwLinesPoints, "Join");
397      GP2.AddPlot(IterAcceptV, gpwLinesPoints, "Accept");
398      GP2.SetTitle(PlotFPrx + ".transition");
399      GP2.SetDataPlotFNm(PlotFPrx + "transition_prob.tab", PlotFPrx + "transition_prob.plt");
400      GP2.SavePng(PlotFPrx + "transition_prob.png");
401    }
402    CIDNSetV = BestCmtySetV;
403    LambdaV = BestLV;
404    InitNodeData();
405    MLEGradAscentGivenCAG(0.001, 100);
406    printf("\nMCMC completed (best likelihood: %.2f) [%s]\n", BestL, TotalTm.GetTmStr());
407  }
408  void TAGMFit::GetQV(TFltV& OutV) {
409    OutV.Gen(LambdaV.Len());
410    for (int i = 0; i < LambdaV.Len(); i++) {
411      OutV[i] = exp(- LambdaV[i]);
412    }
413  }
414  int TAGMFit::RemoveEmptyCom() {
415    int DelCnt = 0;
416    for (int c = 0; c < CIDNSetV.Len(); c++) {
417      if (CIDNSetV[c].Len() == 0) {
418        CIDNSetV[c] = CIDNSetV.Last();
419        CIDNSetV.DelLast();
420        LambdaV[c] = LambdaV.Last();
421        LambdaV.DelLast();
422        DelCnt++;
423        c--;
424      }
425    }
426    return DelCnt;
427  }
428  double TAGMFit::SeekLeave(const int& UID, const int& CID) {
429    IAssert(CIDNSetV[CID].IsKey(UID));
430    IAssert(G->IsNode(UID));
431    double Delta = 0.0;
432    TUNGraph::TNodeI NI = G->GetNI(UID);
433    int NbhsInC = 0;
434    for (int e = 0; e < NI.GetDeg(); e++) {
435      const int VID = NI.GetNbrNId(e);
436      if (! NIDComVH.GetDat(VID).IsKey(CID)) { continue; }
437      TIntPr SrcDstNIDPr(TMath::Mn(UID,VID), TMath::Mx(UID,VID));
438      TIntSet& JointCom = EdgeComVH.GetDat(SrcDstNIDPr);
439      double CurPuv, NewPuv, LambdaSum = SelectLambdaSum(JointCom);
440      CurPuv = 1 - exp(- LambdaSum);
441      NewPuv = 1 - exp(- LambdaSum + LambdaV[CID]);
442      IAssert(JointCom.Len() > 0);
443      if (JointCom.Len() == 1) {
444        NewPuv = PNoCom;
445      }
446      Delta += (log(NewPuv) - log(CurPuv));
447      IAssert(!_isnan(Delta));
448      NbhsInC++;
449    }
450    Delta += LambdaV[CID] * (CIDNSetV[CID].Len() - 1 - NbhsInC);
451    return Delta;
452  }
453  double TAGMFit::SeekJoin(const int& UID, const int& CID) {
454    IAssert(! CIDNSetV[CID].IsKey(UID));
455    double Delta = 0.0;
456    TUNGraph::TNodeI NI = G->GetNI(UID);
457    int NbhsInC = 0;
458    for (int e = 0; e < NI.GetDeg(); e++) {
459      const int VID = NI.GetNbrNId(e);
460      if (! NIDComVH.GetDat(VID).IsKey(CID)) { continue; }
461      TIntPr SrcDstNIDPr(TMath::Mn(UID,VID), TMath::Mx(UID,VID));
462      TIntSet& JointCom = EdgeComVH.GetDat(SrcDstNIDPr);
463      double CurPuv, NewPuv, LambdaSum = SelectLambdaSum(JointCom);
464      CurPuv = 1 - exp(- LambdaSum);
465      if (JointCom.Len() == 0) { CurPuv = PNoCom; }
466      NewPuv = 1 - exp(- LambdaSum - LambdaV[CID]);
467      Delta += (log(NewPuv) - log(CurPuv));
468      IAssert(!_isnan(Delta));
469      NbhsInC++;
470    }
471    Delta -= LambdaV[CID] * (CIDNSetV[CID].Len() - NbhsInC);
472    return Delta;
473  }
474  double TAGMFit::SeekSwitch(const int& UID, const int& CurCID, const int& NewCID) {
475    IAssert(! CIDNSetV[NewCID].IsKey(UID));
476    IAssert(CIDNSetV[CurCID].IsKey(UID));
477    double Delta = SeekJoin(UID, NewCID) + SeekLeave(UID, CurCID);
478    TUNGraph::TNodeI NI = G->GetNI(UID);
479    for (int e = 0; e < NI.GetDeg(); e++) {
480      const int VID = NI.GetNbrNId(e);
481      if (! NIDComVH.GetDat(VID).IsKey(CurCID) || ! NIDComVH.GetDat(VID).IsKey(NewCID)) {continue;}
482      TIntPr SrcDstNIDPr(TMath::Mn(UID,VID), TMath::Mx(UID,VID));
483      TIntSet& JointCom = EdgeComVH.GetDat(SrcDstNIDPr);
484      double CurPuv, NewPuvAfterJoin, NewPuvAfterLeave, NewPuvAfterSwitch, LambdaSum = SelectLambdaSum(JointCom);
485      CurPuv = 1 - exp(- LambdaSum);
486      NewPuvAfterLeave = 1 - exp(- LambdaSum + LambdaV[CurCID]);
487      NewPuvAfterJoin = 1 - exp(- LambdaSum - LambdaV[NewCID]);
488      NewPuvAfterSwitch = 1 - exp(- LambdaSum - LambdaV[NewCID] + LambdaV[CurCID]);
489      if (JointCom.Len() == 1 || NewPuvAfterLeave == 0.0) {
490        NewPuvAfterLeave = PNoCom;
491      }
492      Delta += (log(NewPuvAfterSwitch) + log(CurPuv) - log(NewPuvAfterLeave) - log(NewPuvAfterJoin));
493      if (_isnan(Delta)) {
494        printf("NS:%f C:%f NL:%f NJ:%f PNoCom:%f", NewPuvAfterSwitch, CurPuv, NewPuvAfterLeave, NewPuvAfterJoin, PNoCom.Val);
495      }
496      IAssert(!_isnan(Delta));
497    }
498    return Delta;
499  }
500  void TAGMFit::GetCmtyVV(TVec<TIntV>& CmtyVV, const double QMax) {
501    TFltV TmpQV;
502    GetCmtyVV(CmtyVV, TmpQV, QMax);
503  }
504  void TAGMFit::GetCmtyVV(TVec<TIntV>& CmtyVV, TFltV& QV, const double QMax) {
505    CmtyVV.Gen(CIDNSetV.Len(), 0);
506    QV.Gen(CIDNSetV.Len(), 0);
507    TIntFltH CIDLambdaH(CIDNSetV.Len());
508    for (int c = 0; c < CIDNSetV.Len(); c++) {
509      CIDLambdaH.AddDat(c, LambdaV[c]);
510    }
511    CIDLambdaH.SortByDat(false);
512    for (int c = 0; c < CIDNSetV.Len(); c++) {
513      int CID = CIDLambdaH.GetKey(c);
514      IAssert(LambdaV[CID] >= MinLambda);
515      double Q = exp( - (double) LambdaV[CID]);
516      if (Q > QMax) { continue; }
517      TIntV CmtyV;
518      CIDNSetV[CID].GetKeyV(CmtyV);
519      if (CmtyV.Len() == 0) { continue; }
520      if (CID == BaseCID) { 
521        IAssert(CmtyV.Len() == G->GetNodes());
522      } else {
523        CmtyVV.Add(CmtyV);
524        QV.Add(Q);
525      }
526    }
527  }
528  void TAGMFit::SetCmtyVV(const TVec<TIntV>& CmtyVV) {
529    CIDNSetV.Gen(CmtyVV.Len());
530    for (int c = 0; c < CIDNSetV.Len(); c++) {
531      CIDNSetV[c].AddKeyV(CmtyVV[c]);
532      for (int j = 0; j < CmtyVV[c].Len(); j++) { IAssert(G->IsNode(CmtyVV[c][j])); } 
533    }
534    InitNodeData();
535    SetDefaultPNoCom();
536  }
537  void TAGMFit::GradLogLForLambda(TFltV& GradV) {
538    GradV.Gen(LambdaV.Len());
539    TFltV SumEdgeProbsV(LambdaV.Len());
540    for (int e = 0; e < EdgeComVH.Len(); e++) {
541      TIntSet& JointCom = EdgeComVH[e];
542      double LambdaSum = SelectLambdaSum(JointCom);
543      double Puv = 1 - exp(- LambdaSum);
544      if (JointCom.Len() == 0) {  Puv = PNoCom;  }
545      for (TIntSet::TIter SI = JointCom.BegI(); SI < JointCom.EndI(); SI++) {
546        SumEdgeProbsV[SI.GetKey()] += (1 - Puv) / Puv;
547      }
548    }
549    for (int k = 0; k < LambdaV.Len(); k++) {
550      int MaxEk = CIDNSetV[k].Len() * (CIDNSetV[k].Len() - 1) / 2;
551      int NotEdgesInCom = MaxEk - ComEdgesV[k];
552      GradV[k] = SumEdgeProbsV[k] - (double) NotEdgesInCom;
553      if (LambdaV[k] > 0.0 && RegCoef > 0.0) { 
554        GradV[k] -= RegCoef;
555      }
556    }
557  }
558  double TAGMFit::SelectLambdaSum(const TIntSet& ComK) { 
559    return SelectLambdaSum(LambdaV, ComK); 
560  }
561  double TAGMFit::SelectLambdaSum(const TFltV& NewLambdaV, const TIntSet& ComK) {
562    double Result = 0.0;
563    for (TIntSet::TIter SI = ComK.BegI(); SI < ComK.EndI(); SI++) {
564      IAssert(NewLambdaV[SI.GetKey()] >= 0);
565      Result += NewLambdaV[SI.GetKey()];
566    }
567    return Result;
568  }
569  double TAGMFit::CalcPNoComByCmtyVV(const int& SamplePairs) {
570    TIntV NIdV;
571    G->GetNIdV(NIdV);
572    uint64 PairNoCom = 0, EdgesNoCom = 0;
573    for (int u = 0; u < NIdV.Len(); u++) {
574      for (int v = u + 1; v < NIdV.Len(); v++) {
575        int SrcNID = NIdV[u], DstNID = NIdV[v];
576        TIntSet JointCom;
577        TAGMUtil::GetIntersection(NIDComVH.GetDat(SrcNID),NIDComVH.GetDat(DstNID),JointCom);
578        if(JointCom.Len() == 0) {
579          PairNoCom++;
580          if (G->IsEdge(SrcNID, DstNID)) { EdgesNoCom++; }
581          if (SamplePairs > 0 && PairNoCom >= (uint64) SamplePairs) { break; }
582        }
583      }
584      if (SamplePairs > 0 && PairNoCom >= (uint64) SamplePairs) { break; }
585    }
586    double DefaultVal = 1.0 / (double)G->GetNodes() / (double)G->GetNodes();
587    if (EdgesNoCom > 0) {
588      PNoCom = (double) EdgesNoCom / (double) PairNoCom;
589    } else {
590      PNoCom = DefaultVal;
591    }
592    printf("%s / %s edges without joint com detected (PNoCom = %f)\n", TUInt64::GetStr(EdgesNoCom).CStr(), TUInt64::GetStr(PairNoCom).CStr(), PNoCom.Val);
593    return PNoCom;
594  }
595  void TAGMFit::PrintSummary() {
596    TIntFltH CIDLambdaH(CIDNSetV.Len());
597    for (int c = 0; c < CIDNSetV.Len(); c++) {
598      CIDLambdaH.AddDat(c, LambdaV[c]);
599    }
600    CIDLambdaH.SortByDat(false);
601    int Coms = 0;
602    for (int i = 0; i < LambdaV.Len(); i++) {
603      int CID = CIDLambdaH.GetKey(i);
604      if (LambdaV[CID] <= 0.0001) { continue; }
605      printf("P_c : %.3f Com Sz: %d, Total Edges inside: %d \n", 1.0 - exp(- LambdaV[CID]), CIDNSetV[CID].Len(), (int) ComEdgesV[CID]);
606      Coms++;
607    }
608    printf("%d Communities, Total Memberships = %d, Likelihood = %.2f, Epsilon = %f\n", Coms, NIDCIDPrS.Len(), Likelihood(), PNoCom.Val);
609  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-agmfit.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-agmfit.cpp</div>
                </div>
                <div class="column column_space"><pre><code>282        TIntPr SrcDstNIDPr = TIntPr(TMath::Mn(NID,VID), TMath::Mx(NID,VID));
283        EdgeComVH.GetDat(SrcDstNIDPr).AddKey(JoinCID);
284        ComEdgesV[JoinCID]++;
</pre></code></div>
                <div class="column column_space"><pre><code>282        TIntPr SrcDstNIDPr = TIntPr(TMath::Mn(NID,VID), TMath::Mx(NID,VID));
283        EdgeComVH.GetDat(SrcDstNIDPr).AddKey(JoinCID);
284        ComEdgesV[JoinCID]++;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    