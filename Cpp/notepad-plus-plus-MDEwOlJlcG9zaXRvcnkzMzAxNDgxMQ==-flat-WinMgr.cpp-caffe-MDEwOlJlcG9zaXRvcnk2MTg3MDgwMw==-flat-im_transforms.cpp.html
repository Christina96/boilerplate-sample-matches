
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Similarity: 7.1889400921658995%, Tokens: 10</h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-WinMgr.cpp</h3>
            <pre><code>1  #include "WinMgr.h"
2  inline static DWORD GetStyle(HWND hWnd) {
3  	return (DWORD)GetWindowLongPtr(hWnd, GWL_STYLE);
4  }
5  inline static DWORD GetExStyle(HWND hWnd) {
6  	return (DWORD)GetWindowLongPtr(hWnd, GWL_EXSTYLE);
7  }
8  const UINT WM_WINMGR = RegisterWindowMessage(TEXT("WM_WINMGR"));
9  CWinMgr::CWinMgr(WINRECT* pWinMap) : m_map(pWinMap)
10  {
11  	WINRECT::InitMap(m_map);
12  }
13  CWinMgr::~CWinMgr()
14  {
15  }
16  void CWinMgr::InitToFitSizeFromCurrent(HWND hWnd)
17  {
18  	assert(hWnd);
19  	assert(m_map);
20  	GetWindowPositions(hWnd);
21  	for (WINRECT* w = m_map; !w->IsEnd(); ++w) {
22  		if (w->Type()==WRCT_TOFIT && !w->IsGroup()) {
23  			w->SetToFitSize(RectToSize(w->GetRect()));
24  		}
25  	}
26  }
27  void CWinMgr::GetWindowPositions(HWND hWnd)
28  {
29  	assert(m_map);
30  	assert(hWnd);
31  	for (WINRECT* wrc=m_map; !wrc->IsEnd(); ++wrc) {
32  		if (wrc->IsWindow()) {
33  			HWND HChild = GetDlgItem(hWnd, wrc->GetID());
34  			if (HChild) {
35  				GetWindowRect(HChild, &wrc->GetRect());
36  				POINT p = RectToPoint(wrc->GetRect());
37  				::ScreenToClient(hWnd, &p);
38  			}
39  		}
40  	}
41  }
42  void
43  CWinMgr::SetWindowPositions(HWND hWnd)
44  {
45  	int nWindows = CountWindows();
46  	if (m_map && hWnd && nWindows>0) {
47  		HDWP hdwp = ::BeginDeferWindowPos(nWindows);
48  		int count=0;
49  		for (WINRECT* wrc=m_map; !wrc->IsEnd(); ++wrc) {
50  			if (wrc->IsWindow()) {
51  				assert(count < nWindows);
52  				HWND hwndChild = ::GetDlgItem(hWnd, wrc->GetID());
53  				if (hwndChild) {
54  					const RECT& rc = wrc->GetRect();
55  					::DeferWindowPos(hdwp,
56  						hwndChild,
57  						NULL,		
58  						rc.left,rc.top,RectWidth(rc),RectHeight(rc),
59  						SWP_NOZORDER);
60  					InvalidateRect(hwndChild,NULL,TRUE); 
61  					++count;
62  				}
63  			} else {
64  				InvalidateRect(hWnd, &wrc->GetRect(), TRUE);
65  			}
66  		}
67  		::EndDeferWindowPos(hdwp);
68  	}
69  }
70  int CWinMgr::CountWindows()
71  {
72  	assert(m_map);
73  	int nWin = 0;
74  	for (WINRECT* w=m_map; !w->IsEnd(); ++w) {
75  		if (w->IsWindow())
76  			++nWin;
77  	}
78  	return nWin;
79  }
80  WINRECT* CWinMgr::FindRect(int nID)
81  {
82  	assert(m_map);
83  	for (WINRECT* w=m_map; !w->IsEnd(); ++w) {
84  		if (w->GetID() == static_cast<UINT>(nID))
85  			return w;
86  	}
87  	return NULL;
88  }
89  void
90  CWinMgr::CalcGroup(WINRECT* pGroup, HWND hWnd)
91  {
92  	assert(pGroup && pGroup->IsGroup());
93  	assert(hWnd);
94  	RECT rcTotal = pGroup->GetRect();
95  	int w,h;
96  	if (pGroup->GetMargins(w,h)) {
97  		w = std::min<int>(abs(w), RectWidth(rcTotal)/2);
98  		h = std::min<int>(abs(h), RectHeight(rcTotal)/2);
99  		::InflateRect(&rcTotal, -w, -h);
100  	}
101  	BOOL bRow = pGroup->IsRowGroup();		 
102  	int hwRemaining = bRow ? RectHeight(rcTotal) : RectWidth(rcTotal);
103  	CWinGroupIterator it;
104  	for (it=pGroup; it; it.Next()) {
105  		WINRECT* wrc = it;
106  		SIZEINFO szi;
107  		OnGetSizeInfo(szi, wrc, hWnd);
108  		int hwMin = bRow ? szi.szMin.cy : szi.szMin.cx;
109  		hwMin = std::min<int>(hwMin, hwRemaining);		
110  		wrc->SetHeightOrWidth(hwMin, bRow);	
111  		hwRemaining -= hwMin;					
112  		assert(hwRemaining>=0);
113  	}
114  	WINRECT* pRestRect = NULL;
115  	for (it=pGroup; it; it.Next()) {
116  		WINRECT* wrc = it;
117  		if (wrc->Type()==WRCT_REST) {
118  			assert(pRestRect==NULL);		 
119  			pRestRect = wrc;					 
120  		} else {
121  			AdjustSize(wrc, bRow, hwRemaining, hWnd);
122  		}
123  	}
124  	assert(hwRemaining>=0);
125  	if (pRestRect) {
126  		AdjustSize(pRestRect, bRow, hwRemaining, hWnd);
127  		assert(hwRemaining==0);
128  	}
129  	PositionRects(pGroup, rcTotal, bRow);
130  	for (it=pGroup; it; it.Next()) {
131  		WINRECT* wrc = it;
132  		if (wrc->IsGroup())
133  			CalcGroup(wrc, hWnd); 
134  	}
135  }
136  void
137  CWinMgr::AdjustSize(WINRECT* wrc, BOOL bRow,
138  	int& hwRemaining, HWND hWnd)
139  {
140  	SIZEINFO szi;
141  	OnGetSizeInfo(szi, wrc, hWnd);
142  	int hw = bRow ? szi.szDesired.cy : szi.szDesired.cx; 
143  	if (wrc->Type() == WRCT_REST) {
144  		RECT& rc = wrc->GetRect();
145  		hw = hwRemaining + (bRow ? RectHeight(rc) : RectWidth(rc));
146  	}
147  	int hwCurrent = wrc->GetHeightOrWidth(bRow); 
148  	int hwExtra = hw - hwCurrent;						
149  	hwExtra = std::min<int>(std::max<int>(hwExtra, 0), hwRemaining);	
150  	hw = hwCurrent + hwExtra;							
151  	wrc->SetHeightOrWidth(hw, bRow);				
152  	hwRemaining -= hwExtra;								
153  }
154  void
155  CWinMgr::PositionRects(WINRECT* pGroup, const RECT& rcTotal, BOOL bRow)
156  {
157  	LONG xoryPos = bRow ? rcTotal.top : rcTotal.left;
158  	CWinGroupIterator it;
159  	for (it=pGroup; it; it.Next()) {
160  		WINRECT* wrc = it;
161  		RECT& rc = wrc->GetRect();
162  		if (bRow) {							 
163  			LONG height = RectHeight(rc);		 
164  			rc.top    = xoryPos;				 
165  			rc.bottom = rc.top + height;	 
166  			rc.left   = rcTotal.left;		 
167  			rc.right  = rcTotal.right;		 
168  			xoryPos += height;				 
169  		} else {									 
170  			LONG width = RectWidth(rc);		 
171  			rc.left    = xoryPos;			 
172  			rc.right   = rc.left + width;	 
173  			rc.top     = rcTotal.top;		 
174  			rc.bottom  = rcTotal.bottom;	 
175  			xoryPos += width;					 
176  		}
177  	}
178  }
179  void
180  CWinMgr::OnGetSizeInfo(SIZEINFO& szi, WINRECT* wrc, HWND hWnd)
181  {
182  	szi.szMin = SIZEZERO;				
183  	szi.szMax = SIZEMAX;					
184  	szi.szDesired = RectToSize(wrc->GetRect());	
185  	if (wrc->IsGroup()) {
186  		szi.szDesired = SIZEZERO;
187  		BOOL bRow = wrc->IsRowGroup();
188  		CWinGroupIterator it;
189  		for (it=wrc; it; it.Next()) {
190  			WINRECT* wrc2 = it;
191  			SIZEINFO szi2;
192  			OnGetSizeInfo(szi2, wrc2, hWnd);
193  			if (bRow) {
194  				szi.szMin.cx = std::max<LONG>(szi.szMin.cx, szi2.szMin.cx);
195  				szi.szMin.cy += szi2.szMin.cy;
196  				szi.szMax.cx = std::min<LONG>(szi.szMax.cx, szi2.szMax.cx);
197  				szi.szMax.cy = std::min<LONG>(szi.szMax.cy + szi2.szMax.cy, SHRT_MAX);
198  				szi.szDesired.cx = std::max<LONG>(szi.szDesired.cx, szi2.szDesired.cx);
199  				szi.szDesired.cy += szi2.szDesired.cy;
200  			} else {
201  				szi.szMin.cx += szi2.szMin.cx;
202  				szi.szMin.cy = std::max<LONG>(szi.szMin.cy, szi2.szMin.cy);
203  				szi.szMax.cx = std::min<LONG>(szi.szMax.cx + szi2.szMax.cx, SHRT_MAX);
204  				szi.szMax.cy = std::min<LONG>(szi.szMax.cy, szi2.szMax.cy);
205  				szi.szDesired.cx += szi2.szDesired.cx;
206  				szi.szDesired.cy = std::max<LONG>(szi.szDesired.cy, szi2.szDesired.cy);
207  			}
208  		}
209  		int w2,h2;
210  		wrc->GetMargins(w2,h2);			
211  		w2<<=1; h2<<=1;					
212  		szi.szMin.cx += std::max<LONG>(0,w2);		
213  		szi.szMin.cy += std::max<LONG>(0,h2);		
214  		szi.szDesired.cx += abs(w2);	
215  		szi.szDesired.cy += abs(h2);	
216  	} else {
217  		WINRECT* parent = wrc->Parent();
218  		assert(parent);
219  		RECT& rcParent = parent->GetRect();
220  		BOOL bRow = parent->IsRowGroup();
221  		int hw, hwMin, hwTotal, pct;
222  		switch (wrc->Type()) {
223  		case WRCT_FIXED:
224  			hw = hwMin = wrc->GetParam();	 
225  			if (hw<0) {							 
226  				hw = -hw;						 
227  				hwMin = 0;						 
228  			}
229  			if (bRow) {
230  				szi.szMax.cy = szi.szDesired.cy = hw;
231  				szi.szMin.cy = hwMin;
232  			} else {
233  				szi.szMax.cx = szi.szDesired.cx = hw;
234  				szi.szMin.cx = hwMin;
235  			}
236  			break;
237  		case WRCT_PCT:
238  			pct = wrc->GetParam();
239  			assert(0<pct && pct<100);
240  			hwTotal = bRow ? RectHeight(rcParent) : RectWidth(rcParent);
241  			hw = (hwTotal * pct) / 100;
242  			szi.szDesired = bRow ? GetSize(RectWidth(rcParent), hw) : GetSize(hw, RectHeight(rcParent));
243  			break;
244  		case WRCT_TOFIT:
245  			if (wrc->HasToFitSize()) {
246  				szi.szDesired = wrc->GetToFitSize();
247  			}
248  			break;
249  		case WRCT_REST:
250  			break;
251  		default:
252  			assert(FALSE);
253  		}
254  		if (wrc->IsWindow() && hWnd) {
255  			HWND hChild = GetDlgItem(hWnd, wrc->GetID());
256  			if (hChild) {
257  				if (!IsWindowVisible(hChild) && IsWindowVisible(hWnd)) {
258  					szi.szDesired = SIZEZERO;
259  				} else {
260  					szi.szAvail = RectToSize(rcParent);
261  					SendGetSizeInfo(szi, hWnd, wrc->GetID());
262  				}
263  			}
264  		}
265  		szi.szDesired = maxsize(minsize(szi.szDesired,szi.szMax), szi.szMin);
266  	}
267  }
268  BOOL CWinMgr::SendGetSizeInfo(SIZEINFO& szi, HWND hWnd, UINT nID)
269  {
270  	NMWINMGR nmw{};
271  	nmw.code = NMWINMGR::GET_SIZEINFO;	
272  	nmw.idFrom = nID;							
273  	nmw.sizeinfo = szi;						
274  	if (!SendMessage(hWnd, WM_WINMGR, nID, reinterpret_cast<LPARAM>(&nmw)) && !nmw.processed)
275  	{
276  		HWND hwndChild = ::GetDlgItem(hWnd, nID);
277  		if (!hwndChild || !::SendMessage(hwndChild, WM_WINMGR, nID, reinterpret_cast<LPARAM>(&nmw)))
278  			return FALSE;
279  	}
280  	szi = nmw.sizeinfo; 
281  	return TRUE;
282  }
283  void
284  CWinMgr::GetMinMaxInfo(HWND hWnd, MINMAXINFO* lpMMI)
285  {
286  	SIZEINFO szi;
287  	GetMinMaxInfo(hWnd, szi); 
288  	lpMMI->ptMinTrackSize = SizeToPoint(szi.szMin);
289  	lpMMI->ptMaxTrackSize = SizeToPoint(szi.szMax);
290  }
291  void CWinMgr::GetMinMaxInfo(HWND hWnd, SIZEINFO& szi)
292  {
293  	OnGetSizeInfo(szi, m_map, hWnd);  
294  	if (!hWnd)					 
295  		return;
296  	DWORD dwStyle = GetStyle(hWnd);
297  	DWORD dwExStyle = GetExStyle(hWnd);
298  	if (dwStyle & WS_VISIBLE)
299  	{
300  		SIZE& szMin = szi.szMin; 
301  		if (!(dwStyle & WS_CHILD))
302  		{
303  			if (dwStyle & WS_CAPTION)
304  				szMin.cy += GetSystemMetrics(SM_CYCAPTION);
305  			if (::GetMenu(hWnd))
306  				szMin.cy += GetSystemMetrics(SM_CYMENU);
307  		}
308  		if (dwStyle & WS_THICKFRAME)
309  		{
310  			szMin.cx += 2*GetSystemMetrics(SM_CXSIZEFRAME);
311  			szMin.cy += 2*GetSystemMetrics(SM_CYSIZEFRAME);
312  		}
313  		else if (dwStyle & WS_BORDER)
314  		{
315  			szMin.cx += 2*GetSystemMetrics(SM_CXBORDER);
316  			szMin.cy += 2*GetSystemMetrics(SM_CYBORDER);
317  		}
318  		if (dwExStyle & WS_EX_CLIENTEDGE)
319  		{
320  			szMin.cx += 2*GetSystemMetrics(SM_CXEDGE);
321  			szMin.cy += 2*GetSystemMetrics(SM_CYEDGE);
322  		}
323  	}
324  }
325  void CWinMgr::MoveRect(WINRECT* pwrcMove, POINT ptMove, HWND pParentWnd)
326  {
327  	assert(pwrcMove);
328  	WINRECT* prev = pwrcMove->Prev();
329  	assert(prev);
330  	WINRECT* next = pwrcMove->Next();
331  	assert(next);
332  	BOOL bIsRow = pwrcMove->Parent()->IsRowGroup();
333  	RECT& rcNext = next->GetRect();
<span onclick='openModal()' class='match'>334  	RECT& rcPrev = prev->GetRect();
335  	if (bIsRow)
336  	{
337  		ptMove.x = 0;
338  		rcPrev.bottom += ptMove.y;
339  		rcNext.top += ptMove.y;
340  	}
341  	else
342  	{
343  		ptMove.y = 0;
</span>344  		rcPrev.right += ptMove.x;
345  		rcNext.left += ptMove.x;
346  	}
347  	OffsetRect(pwrcMove->GetRect(), ptMove);
348  	if (prev->IsGroup())
349  		CalcGroup(prev, pParentWnd);
350  	if (next->IsGroup())
351  		CalcGroup(next, pParentWnd);
352  }
</code></pre>
        </div>
        <div class="column">
            <h3>caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-im_transforms.cpp</h3>
            <pre><code>1  #ifdef USE_OPENCV
2  #include <opencv2/highgui/highgui.hpp>
3  #if CV_VERSION_MAJOR == 3
4  #include <opencv2/imgcodecs/imgcodecs.hpp>
5  #define CV_GRAY2BGR cv::COLOR_GRAY2BGR
6  #define CV_BGR2GRAY cv::COLOR_BGR2GRAY
7  #define CV_BGR2YCrCb cv::COLOR_BGR2YCrCb
8  #define CV_YCrCb2BGR cv::COLOR_YCrCb2BGR
9  #define CV_IMWRITE_JPEG_QUALITY cv::IMWRITE_JPEG_QUALITY
10  #define CV_LOAD_IMAGE_COLOR cv::IMREAD_COLOR
11  #define CV_THRESH_BINARY_INV cv::THRESH_BINARY_INV
12  #define CV_THRESH_OTSU cv::THRESH_OTSU
13  #endif
14  #endif  
15  #include <algorithm>
16  #include <numeric>
17  #include <vector>
18  #include "caffe/util/im_transforms.hpp"
19  #include "caffe/util/math_functions.hpp"
20  namespace caffe {
21  const float prob_eps = 0.01;
22  int roll_weighted_die(const vector<float>& probabilities) {
23    vector<float> cumulative;
24    std::partial_sum(&probabilities[0], &probabilities[0] + probabilities.size(),
25                     std::back_inserter(cumulative));
26    float val;
27    caffe_rng_uniform(1, static_cast<float>(0), cumulative.back(), &val);
28    return (std::lower_bound(cumulative.begin(), cumulative.end(), val)
29            - cumulative.begin());
30  }
31  void UpdateBBoxByResizePolicy(const ResizeParameter& param,
32                                const int old_width, const int old_height,
33                                NormalizedBBox* bbox) {
34    float new_height = param.height();
35    float new_width = param.width();
36    float orig_aspect = static_cast<float>(old_width) / old_height;
37    float new_aspect = new_width / new_height;
38    float x_min = bbox->xmin() * old_width;
39    float y_min = bbox->ymin() * old_height;
40    float x_max = bbox->xmax() * old_width;
41    float y_max = bbox->ymax() * old_height;
42    float padding;
43    switch (param.resize_mode()) {
44      case ResizeParameter_Resize_mode_WARP:
45        x_min = std::max(0.f, x_min * new_width / old_width);
46        x_max = std::min(new_width, x_max * new_width / old_width);
47        y_min = std::max(0.f, y_min * new_height / old_height);
48        y_max = std::min(new_height, y_max * new_height / old_height);
49        break;
50      case ResizeParameter_Resize_mode_FIT_LARGE_SIZE_AND_PAD:
51        if (orig_aspect > new_aspect) {
52          padding = (new_height - new_width / orig_aspect) / 2;
53          x_min = std::max(0.f, x_min * new_width / old_width);
54          x_max = std::min(new_width, x_max * new_width / old_width);
55          y_min = y_min * (new_height - 2 * padding) / old_height;
56          y_min = padding + std::max(0.f, y_min);
57          y_max = y_max * (new_height - 2 * padding) / old_height;
58          y_max = padding + std::min(new_height, y_max);
59        } else {
60          padding = (new_width - orig_aspect * new_height) / 2;
61          x_min = x_min * (new_width - 2 * padding) / old_width;
62          x_min = padding + std::max(0.f, x_min);
63          x_max = x_max * (new_width - 2 * padding) / old_width;
64          x_max = padding + std::min(new_width, x_max);
65          y_min = std::max(0.f, y_min * new_height / old_height);
66          y_max = std::min(new_height, y_max * new_height / old_height);
67        }
68        break;
69      case ResizeParameter_Resize_mode_FIT_SMALL_SIZE:
70        if (orig_aspect < new_aspect) {
71          new_height = new_width / orig_aspect;
72        } else {
73          new_width = orig_aspect * new_height;
74        }
75        x_min = std::max(0.f, x_min * new_width / old_width);
76        x_max = std::min(new_width, x_max * new_width / old_width);
77        y_min = std::max(0.f, y_min * new_height / old_height);
78        y_max = std::min(new_height, y_max * new_height / old_height);
79        break;
80      default:
81        LOG(FATAL) << "Unknown resize mode.";
82    }
83    bbox->set_xmin(x_min / new_width);
84    bbox->set_ymin(y_min / new_height);
85    bbox->set_xmax(x_max / new_width);
86    bbox->set_ymax(y_max / new_height);
87  }
88  void InferNewSize(const ResizeParameter& resize_param,
89                    const int old_width, const int old_height,
90                    int* new_width, int* new_height) {
91    int height = resize_param.height();
92    int width = resize_param.width();
93    float orig_aspect = static_cast<float>(old_width) / old_height;
94    float aspect = static_cast<float>(width) / height;
95    switch (resize_param.resize_mode()) {
96      case ResizeParameter_Resize_mode_WARP:
97        break;
98      case ResizeParameter_Resize_mode_FIT_LARGE_SIZE_AND_PAD:
99        break;
100      case ResizeParameter_Resize_mode_FIT_SMALL_SIZE:
101        if (orig_aspect < aspect) {
102          height = static_cast<int>(width / orig_aspect);
103        } else {
104          width = static_cast<int>(orig_aspect * height);
105        }
106        break;
107      default:
108        LOG(FATAL) << "Unknown resize mode.";
109    }
110    *new_height = height;
111    *new_width = width;
112  }
113  #ifdef USE_OPENCV
114  template <typename T>
115  bool is_border(const cv::Mat& edge, T color) {
116    cv::Mat im = edge.clone().reshape(0, 1);
117    bool res = true;
118    for (int i = 0; i < im.cols; ++i) {
119      res &= (color == im.at<T>(0, i));
120    }
121    return res;
122  }
123  template
124  bool is_border(const cv::Mat& edge, uchar color);
125  template <typename T>
126  cv::Rect CropMask(const cv::Mat& src, T point, int padding) {
127    cv::Rect win(0, 0, src.cols, src.rows);
128    vector<cv::Rect> edges;
129    edges.push_back(cv::Rect(0, 0, src.cols, 1));
130    edges.push_back(cv::Rect(src.cols-2, 0, 1, src.rows));
131    edges.push_back(cv::Rect(0, src.rows-2, src.cols, 1));
132    edges.push_back(cv::Rect(0, 0, 1, src.rows));
133    cv::Mat edge;
134    int nborder = 0;
135    T color = src.at<T>(0, 0);
136    for (int i = 0; i < edges.size(); ++i) {
137      edge = src(edges[i]);
138      nborder += is_border(edge, color);
139    }
140    if (nborder < 4) {
141      return win;
142    }
143    bool next;
144    do {
145      edge = src(cv::Rect(win.x, win.height - 2, win.width, 1));
146      next = is_border(edge, color);
147      if (next) {
148        win.height--;
149      }
150    } while (next && (win.height > 0));
151    do {
152      edge = src(cv::Rect(win.width - 2, win.y, 1, win.height));
153      next = is_border(edge, color);
154      if (next) {
155        win.width--;
156      }
157    } while (next && (win.width > 0));
158    do {
159      edge = src(cv::Rect(win.x, win.y, win.width, 1));
160      next = is_border(edge, color);
161      if (next) {
162        win.y++;
163        win.height--;
164      }
165    } while (next && (win.y <= src.rows));
166    do {
167      edge = src(cv::Rect(win.x, win.y, 1, win.height));
168      next = is_border(edge, color);
169      if (next) {
170        win.x++;
171        win.width--;
172      }
173    } while (next && (win.x <= src.cols));
174    if (win.x > padding) {
175      win.x -= padding;
176    }
177    if (win.y > padding) {
178      win.y -= padding;
179    }
180    if ((win.width + win.x + padding) < src.cols) {
181      win.width += padding;
182    }
183    if ((win.height + win.y + padding) < src.rows) {
184      win.height += padding;
185    }
186    return win;
187  }
188  template
189  cv::Rect CropMask(const cv::Mat& src, uchar point, int padding);
190  cv::Mat colorReduce(const cv::Mat& image, int div) {
191    cv::Mat out_img;
192    cv::Mat lookUpTable(1, 256, CV_8U);
193    uchar* p = lookUpTable.data;
194    const int div_2 = div / 2;
195    for ( int i = 0; i < 256; ++i ) {
196      p[i] = i / div * div + div_2;
197    }
198    cv::LUT(image, lookUpTable, out_img);
199    return out_img;
200  }
201  void fillEdgeImage(const cv::Mat& edgesIn, cv::Mat* filledEdgesOut) {
202    cv::Mat edgesNeg = edgesIn.clone();
203    cv::Scalar val(255, 255, 255);
204    cv::floodFill(edgesNeg, cv::Point(0, 0), val);
205    cv::floodFill(edgesNeg, cv::Point(edgesIn.cols - 1, edgesIn.rows - 1), val);
206    cv::floodFill(edgesNeg, cv::Point(0, edgesIn.rows - 1), val);
207    cv::floodFill(edgesNeg, cv::Point(edgesIn.cols - 1, 0), val);
208    cv::bitwise_not(edgesNeg, edgesNeg);
209    *filledEdgesOut = (edgesNeg | edgesIn);
210    return;
211  }
212  void CenterObjectAndFillBg(const cv::Mat& in_img, const bool fill_bg,
213                             cv::Mat* out_img) {
214    cv::Mat mask, crop_mask;
215    if (in_img.channels() > 1) {
216      cv::Mat in_img_gray;
217      cv::cvtColor(in_img, in_img_gray, CV_BGR2GRAY);
218      cv::threshold(in_img_gray, mask, 0, 255,
219                    CV_THRESH_BINARY_INV | CV_THRESH_OTSU);
220    } else {
221      cv::threshold(in_img, mask, 0, 255,
222                    CV_THRESH_BINARY_INV | CV_THRESH_OTSU);
223    }
<span onclick='openModal()' class='match'>224    cv::Rect crop_rect = CropMask(mask, mask.at<uchar>(0, 0), 2);
225    if (fill_bg) {
226      cv::Mat temp_img = in_img(crop_rect);
227      fillEdgeImage(mask, &mask);
228      crop_mask = mask(crop_rect).clone();
229      *out_img = cv::Mat::zeros(crop_rect.size(), in_img.type());
230      temp_img.copyTo(*out_img, crop_mask);
231    } else {
232      *out_img = in_img(crop_rect).clone();
</span>233    }
234  }
235  cv::Mat AspectKeepingResizeAndPad(const cv::Mat& in_img,
236                                    const int new_width, const int new_height,
237                                    const int pad_type,  const cv::Scalar pad_val,
238                                    const int interp_mode) {
239    cv::Mat img_resized;
240    float orig_aspect = static_cast<float>(in_img.cols) / in_img.rows;
241    float new_aspect = static_cast<float>(new_width) / new_height;
242    if (orig_aspect > new_aspect) {
243      int height = floor(static_cast<float>(new_width) / orig_aspect);
244      cv::resize(in_img, img_resized, cv::Size(new_width, height), 0, 0,
245                 interp_mode);
246      cv::Size resSize = img_resized.size();
247      int padding = floor((new_height - resSize.height) / 2.0);
248      cv::copyMakeBorder(img_resized, img_resized, padding,
249                         new_height - resSize.height - padding, 0, 0,
250                         pad_type, pad_val);
251    } else {
252      int width = floor(orig_aspect * new_height);
253      cv::resize(in_img, img_resized, cv::Size(width, new_height), 0, 0,
254                 interp_mode);
255      cv::Size resSize = img_resized.size();
256      int padding = floor((new_width - resSize.width) / 2.0);
257      cv::copyMakeBorder(img_resized, img_resized, 0, 0, padding,
258                         new_width - resSize.width - padding,
259                         pad_type, pad_val);
260    }
261    return img_resized;
262  }
263  cv::Mat AspectKeepingResizeBySmall(const cv::Mat& in_img,
264                                     const int new_width,
265                                     const int new_height,
266                                     const int interp_mode) {
267    cv::Mat img_resized;
268    float orig_aspect = static_cast<float>(in_img.cols) / in_img.rows;
269    float new_aspect = static_cast<float> (new_width) / new_height;
270    if (orig_aspect < new_aspect) {
271      int height = floor(static_cast<float>(new_width) / orig_aspect);
272      cv::resize(in_img, img_resized, cv::Size(new_width, height), 0, 0,
273                 interp_mode);
274    } else {
275      int width = floor(orig_aspect * new_height);
276      cv::resize(in_img, img_resized, cv::Size(width, new_height), 0, 0,
277                 interp_mode);
278    }
279    return img_resized;
280  }
281  void constantNoise(const int n, const vector<uchar>& val, cv::Mat* image) {
282    const int cols = image->cols;
283    const int rows = image->rows;
284    if (image->channels() == 1) {
285      for (int k = 0; k < n; ++k) {
286        const int i = caffe_rng_rand() % cols;
287        const int j = caffe_rng_rand() % rows;
288        uchar* ptr = image->ptr<uchar>(j);
289        ptr[i]= val[0];
290      }
291    } else if (image->channels() == 3) {  
292      for (int k = 0; k < n; ++k) {
293        const int i = caffe_rng_rand() % cols;
294        const int j = caffe_rng_rand() % rows;
295        cv::Vec3b* ptr = image->ptr<cv::Vec3b>(j);
296        (ptr[i])[0] = val[0];
297        (ptr[i])[1] = val[1];
298        (ptr[i])[2] = val[2];
299      }
300    }
301  }
302  cv::Mat ApplyResize(const cv::Mat& in_img, const ResizeParameter& param) {
303    cv::Mat out_img;
304    const int new_height = param.height();
305    const int new_width = param.width();
306    int pad_mode = cv::BORDER_CONSTANT;
307    switch (param.pad_mode()) {
308      case ResizeParameter_Pad_mode_CONSTANT:
309        break;
310      case ResizeParameter_Pad_mode_MIRRORED:
311        pad_mode = cv::BORDER_REFLECT101;
312        break;
313      case ResizeParameter_Pad_mode_REPEAT_NEAREST:
314        pad_mode = cv::BORDER_REPLICATE;
315        break;
316      default:
317        LOG(FATAL) << "Unknown pad mode.";
318    }
319    int interp_mode = cv::INTER_LINEAR;
320    int num_interp_mode = param.interp_mode_size();
321    if (num_interp_mode > 0) {
322      vector<float> probs(num_interp_mode, 1.f / num_interp_mode);
323      int prob_num = roll_weighted_die(probs);
324      switch (param.interp_mode(prob_num)) {
325        case ResizeParameter_Interp_mode_AREA:
326          interp_mode = cv::INTER_AREA;
327          break;
328        case ResizeParameter_Interp_mode_CUBIC:
329          interp_mode = cv::INTER_CUBIC;
330          break;
331        case ResizeParameter_Interp_mode_LINEAR:
332          interp_mode = cv::INTER_LINEAR;
333          break;
334        case ResizeParameter_Interp_mode_NEAREST:
335          interp_mode = cv::INTER_NEAREST;
336          break;
337        case ResizeParameter_Interp_mode_LANCZOS4:
338          interp_mode = cv::INTER_LANCZOS4;
339          break;
340        default:
341          LOG(FATAL) << "Unknown interp mode.";
342      }
343    }
344    cv::Scalar pad_val = cv::Scalar(0, 0, 0);
345    const int img_channels = in_img.channels();
346    if (param.pad_value_size() > 0) {
347      CHECK(param.pad_value_size() == 1 ||
348            param.pad_value_size() == img_channels) <<
349          "Specify either 1 pad_value or as many as channels: " << img_channels;
350      vector<float> pad_values;
351      for (int i = 0; i < param.pad_value_size(); ++i) {
352        pad_values.push_back(param.pad_value(i));
353      }
354      if (img_channels > 1 && param.pad_value_size() == 1) {
355        for (int c = 1; c < img_channels; ++c) {
356          pad_values.push_back(pad_values[0]);
357        }
358      }
359      pad_val = cv::Scalar(pad_values[0], pad_values[1], pad_values[2]);
360    }
361    switch (param.resize_mode()) {
362      case ResizeParameter_Resize_mode_WARP:
363        cv::resize(in_img, out_img, cv::Size(new_width, new_height), 0, 0,
364                   interp_mode);
365        break;
366      case ResizeParameter_Resize_mode_FIT_LARGE_SIZE_AND_PAD:
367        out_img = AspectKeepingResizeAndPad(in_img, new_width, new_height,
368                                            pad_mode, pad_val, interp_mode);
369        break;
370      case ResizeParameter_Resize_mode_FIT_SMALL_SIZE:
371        out_img = AspectKeepingResizeBySmall(in_img, new_width, new_height,
372                                             interp_mode);
373        break;
374      default:
375        LOG(INFO) << "Unknown resize mode.";
376    }
377    return  out_img;
378  }
379  cv::Mat ApplyNoise(const cv::Mat& in_img, const NoiseParameter& param) {
380    cv::Mat out_img;
381    if (param.decolorize()) {
382      cv::Mat grayscale_img;
383      cv::cvtColor(in_img, grayscale_img, CV_BGR2GRAY);
384      cv::cvtColor(grayscale_img, out_img,  CV_GRAY2BGR);
385    } else {
386      out_img = in_img;
387    }
388    if (param.gauss_blur()) {
389      cv::GaussianBlur(out_img, out_img, cv::Size(7, 7), 1.5);
390    }
391    if (param.hist_eq()) {
392      if (out_img.channels() > 1) {
393        cv::Mat ycrcb_image;
394        cv::cvtColor(out_img, ycrcb_image, CV_BGR2YCrCb);
395        vector<cv::Mat> ycrcb_planes(3);
396        cv::split(ycrcb_image, ycrcb_planes);
397        cv::Mat dst;
398        cv::equalizeHist(ycrcb_planes[0], dst);
399        ycrcb_planes[0] = dst;
400        cv::merge(ycrcb_planes, ycrcb_image);
401        cv::cvtColor(ycrcb_image, out_img, CV_YCrCb2BGR);
402      } else {
403        cv::Mat temp_img;
404        cv::equalizeHist(out_img, temp_img);
405        out_img = temp_img;
406      }
407    }
408    if (param.clahe()) {
409      cv::Ptr<cv::CLAHE> clahe = cv::createCLAHE();
410      clahe->setClipLimit(4);
411      if (out_img.channels() > 1) {
412        cv::Mat ycrcb_image;
413        cv::cvtColor(out_img, ycrcb_image, CV_BGR2YCrCb);
414        vector<cv::Mat> ycrcb_planes(3);
415        cv::split(ycrcb_image, ycrcb_planes);
416        cv::Mat dst;
417        clahe->apply(ycrcb_planes[0], dst);
418        ycrcb_planes[0] = dst;
419        cv::merge(ycrcb_planes, ycrcb_image);
420        cv::cvtColor(ycrcb_image, out_img, CV_YCrCb2BGR);
421      } else {
422        cv::Ptr<cv::CLAHE> clahe = cv::createCLAHE();
423        clahe->setClipLimit(4);
424        cv::Mat temp_img;
425        clahe->apply(out_img, temp_img);
426        out_img = temp_img;
427      }
428    }
429    if (param.jpeg() > 0) {
430      vector<uchar> buf;
431      vector<int> params;
432      params.push_back(CV_IMWRITE_JPEG_QUALITY);
433      params.push_back(param.jpeg());
434      cv::imencode(".jpg", out_img, buf, params);
435      out_img = cv::imdecode(buf, CV_LOAD_IMAGE_COLOR);
436    }
437    if (param.erode()) {
438      cv::Mat element = cv::getStructuringElement(
439          2, cv::Size(3, 3), cv::Point(1, 1));
440      cv::erode(out_img, out_img, element);
441    }
442    if (param.posterize()) {
443      cv::Mat tmp_img;
444      tmp_img = colorReduce(out_img);
445      out_img = tmp_img;
446    }
447    if (param.inverse()) {
448      cv::Mat tmp_img;
449      cv::bitwise_not(out_img, tmp_img);
450      out_img = tmp_img;
451    }
452    vector<uchar> noise_values;
453    if (param.saltpepper_param().value_size() > 0) {
454      CHECK(param.saltpepper_param().value_size() == 1
455            || param.saltpepper_param().value_size() == out_img.channels())
456          << "Specify either 1 pad_value or as many as channels: "
457          << out_img.channels();
458      for (int i = 0; i < param.saltpepper_param().value_size(); i++) {
459        noise_values.push_back(uchar(param.saltpepper_param().value(i)));
460      }
461      if (out_img.channels()  > 1
462          && param.saltpepper_param().value_size() == 1) {
463        for (int c = 1; c < out_img.channels(); ++c) {
464          noise_values.push_back(uchar(noise_values[0]));
465        }
466      }
467    }
468    if (param.saltpepper()) {
469      const int noise_pixels_num =
470          floor(param.saltpepper_param().fraction()
471                * out_img.cols * out_img.rows);
472      constantNoise(noise_pixels_num, noise_values, &out_img);
473    }
474    if (param.convert_to_hsv()) {
475      cv::Mat hsv_image;
476      cv::cvtColor(out_img, hsv_image, CV_BGR2HSV);
477      out_img = hsv_image;
478    }
479    if (param.convert_to_lab()) {
480      cv::Mat lab_image;
481      out_img.convertTo(lab_image, CV_32F);
482      lab_image *= 1.0 / 255;
483      cv::cvtColor(lab_image, out_img, CV_BGR2Lab);
484    }
485    return  out_img;
486  }
487  void RandomBrightness(const cv::Mat& in_img, cv::Mat* out_img,
488      const float brightness_prob, const float brightness_delta) {
489    float prob;
490    caffe_rng_uniform(1, 0.f, 1.f, &prob);
491    if (prob < brightness_prob) {
492      CHECK_GE(brightness_delta, 0) << "brightness_delta must be non-negative.";
493      float delta;
494      caffe_rng_uniform(1, -brightness_delta, brightness_delta, &delta);
495      AdjustBrightness(in_img, delta, out_img);
496    } else {
497      *out_img = in_img;
498    }
499  }
500  void AdjustBrightness(const cv::Mat& in_img, const float delta,
501                        cv::Mat* out_img) {
502    if (fabs(delta) > 0) {
503      in_img.convertTo(*out_img, -1, 1, delta);
504    } else {
505      *out_img = in_img;
506    }
507  }
508  void RandomContrast(const cv::Mat& in_img, cv::Mat* out_img,
509      const float contrast_prob, const float lower, const float upper) {
510    float prob;
511    caffe_rng_uniform(1, 0.f, 1.f, &prob);
512    if (prob < contrast_prob) {
513      CHECK_GE(upper, lower) << "contrast upper must be >= lower.";
514      CHECK_GE(lower, 0) << "contrast lower must be non-negative.";
515      float delta;
516      caffe_rng_uniform(1, lower, upper, &delta);
517      AdjustContrast(in_img, delta, out_img);
518    } else {
519      *out_img = in_img;
520    }
521  }
522  void AdjustContrast(const cv::Mat& in_img, const float delta,
523                      cv::Mat* out_img) {
524    if (fabs(delta - 1.f) > 1e-3) {
525      in_img.convertTo(*out_img, -1, delta, 0);
526    } else {
527      *out_img = in_img;
528    }
529  }
530  void RandomSaturation(const cv::Mat& in_img, cv::Mat* out_img,
531      const float saturation_prob, const float lower, const float upper) {
532    float prob;
533    caffe_rng_uniform(1, 0.f, 1.f, &prob);
534    if (prob < saturation_prob) {
535      CHECK_GE(upper, lower) << "saturation upper must be >= lower.";
536      CHECK_GE(lower, 0) << "saturation lower must be non-negative.";
537      float delta;
538      caffe_rng_uniform(1, lower, upper, &delta);
539      AdjustSaturation(in_img, delta, out_img);
540    } else {
541      *out_img = in_img;
542    }
543  }
544  void AdjustSaturation(const cv::Mat& in_img, const float delta,
545                        cv::Mat* out_img) {
546    if (fabs(delta - 1.f) != 1e-3) {
547      cv::cvtColor(in_img, *out_img, CV_BGR2HSV);
548      vector<cv::Mat> channels;
549      cv::split(*out_img, channels);
550      channels[1].convertTo(channels[1], -1, delta, 0);
551      cv::merge(channels, *out_img);
552      cvtColor(*out_img, *out_img, CV_HSV2BGR);
553    } else {
554      *out_img = in_img;
555    }
556  }
557  void RandomHue(const cv::Mat& in_img, cv::Mat* out_img,
558                 const float hue_prob, const float hue_delta) {
559    float prob;
560    caffe_rng_uniform(1, 0.f, 1.f, &prob);
561    if (prob < hue_prob) {
562      CHECK_GE(hue_delta, 0) << "hue_delta must be non-negative.";
563      float delta;
564      caffe_rng_uniform(1, -hue_delta, hue_delta, &delta);
565      AdjustHue(in_img, delta, out_img);
566    } else {
567      *out_img = in_img;
568    }
569  }
570  void AdjustHue(const cv::Mat& in_img, const float delta, cv::Mat* out_img) {
571    if (fabs(delta) > 0) {
572      cv::cvtColor(in_img, *out_img, CV_BGR2HSV);
573      vector<cv::Mat> channels;
574      cv::split(*out_img, channels);
575      channels[0].convertTo(channels[0], -1, 1, delta);
576      cv::merge(channels, *out_img);
577      cvtColor(*out_img, *out_img, CV_HSV2BGR);
578    } else {
579      *out_img = in_img;
580    }
581  }
582  void RandomOrderChannels(const cv::Mat& in_img, cv::Mat* out_img,
583                           const float random_order_prob) {
584    float prob;
585    caffe_rng_uniform(1, 0.f, 1.f, &prob);
586    if (prob < random_order_prob) {
587      vector<cv::Mat> channels;
588      cv::split(*out_img, channels);
589      CHECK_EQ(channels.size(), 3);
590      std::random_shuffle(channels.begin(), channels.end());
591      cv::merge(channels, *out_img);
592    } else {
593      *out_img = in_img;
594    }
595  }
596  cv::Mat ApplyDistort(const cv::Mat& in_img, const DistortionParameter& param) {
597    cv::Mat out_img = in_img;
598    float prob;
599    caffe_rng_uniform(1, 0.f, 1.f, &prob);
600    if (prob > 0.5) {
601      RandomBrightness(out_img, &out_img, param.brightness_prob(),
602                       param.brightness_delta());
603      RandomContrast(out_img, &out_img, param.contrast_prob(),
604                     param.contrast_lower(), param.contrast_upper());
605      RandomSaturation(out_img, &out_img, param.saturation_prob(),
606                       param.saturation_lower(), param.saturation_upper());
607      RandomHue(out_img, &out_img, param.hue_prob(), param.hue_delta());
608      RandomOrderChannels(out_img, &out_img, param.random_order_prob());
609    } else {
610      RandomBrightness(out_img, &out_img, param.brightness_prob(),
611                       param.brightness_delta());
612      RandomSaturation(out_img, &out_img, param.saturation_prob(),
613                       param.saturation_lower(), param.saturation_upper());
614      RandomHue(out_img, &out_img, param.hue_prob(), param.hue_delta());
615      RandomContrast(out_img, &out_img, param.contrast_prob(),
616                     param.contrast_lower(), param.contrast_upper());
617      RandomOrderChannels(out_img, &out_img, param.random_order_prob());
618    }
619    return out_img;
620  }
621  #endif  
622  }  
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-WinMgr.cpp</div>
                <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from caffe-MDEwOlJlcG9zaXRvcnk2MTg3MDgwMw==-flat-im_transforms.cpp</div>
                <div class="column column_space"><pre><code>334  	RECT& rcPrev = prev->GetRect();
335  	if (bIsRow)
336  	{
337  		ptMove.x = 0;
338  		rcPrev.bottom += ptMove.y;
339  		rcNext.top += ptMove.y;
340  	}
341  	else
342  	{
343  		ptMove.y = 0;
</pre></code></div>
                <div class="column column_space"><pre><code>224    cv::Rect crop_rect = CropMask(mask, mask.at<uchar>(0, 0), 2);
225    if (fill_bg) {
226      cv::Mat temp_img = in_img(crop_rect);
227      fillEdgeImage(mask, &mask);
228      crop_mask = mask(crop_rect).clone();
229      *out_img = cv::Mat::zeros(crop_rect.size(), in_img.type());
230      temp_img.copyTo(*out_img, crop_mask);
231    } else {
232      *out_img = in_img(crop_rect).clone();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    