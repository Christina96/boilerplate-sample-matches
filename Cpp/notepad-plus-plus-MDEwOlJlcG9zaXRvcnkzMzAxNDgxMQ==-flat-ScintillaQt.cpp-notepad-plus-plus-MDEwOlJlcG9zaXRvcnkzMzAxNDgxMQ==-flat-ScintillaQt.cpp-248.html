
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 19, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ScintillaQt.cpp</h3>
            <pre><code>1  #include &quot;ScintillaQt.h&quot;
2  #include &quot;PlatQt.h&quot;
3  #include &lt;QApplication&gt;
4  #include &lt;QDrag&gt;
5  #if QT_VERSION &lt; QT_VERSION_CHECK(5, 0, 0)
6  #include &lt;QInputContext&gt;
7  #endif
8  #include &lt;QMimeData&gt;
9  #include &lt;QMenu&gt;
10  #include &lt;QTextCodec&gt;
11  #include &lt;QScrollBar&gt;
12  #include &lt;QTimer&gt;
13  using namespace Scintilla;
14  using namespace Scintilla::Internal;
15  ScintillaQt::ScintillaQt(QAbstractScrollArea *parent)
16  : QObject(parent), scrollArea(parent), vMax(0),  hMax(0), vPage(0), hPage(0),
17   haveMouseCapture(false), dragWasDropped(false),
18   rectangularSelectionModifier(SCMOD_ALT)
19  {
20  	wMain = scrollArea-&gt;viewport();
21  	imeInteraction = IMEInteraction::Inline;
22  	view.bufferedDraw = false;
23  	Init();
24  	std::fill(timers, std::end(timers), 0);
25  }
26  ScintillaQt::~ScintillaQt()
27  {
28  	CancelTimers();
29  	ChangeIdle(false);
30  }
31  void ScintillaQt::execCommand(QAction *action)
32  {
33  	const int commandNum = action-&gt;data().toInt();
34  	Command(commandNum);
35  }
36  #if defined(Q_OS_WIN)
37  static const QString sMSDEVColumnSelect(&quot;MSDEVColumnSelect&quot;);
38  static const QString sWrappedMSDEVColumnSelect(&quot;application/x-qt-windows-mime;value=\&quot;MSDEVColumnSelect\&quot;&quot;);
39  static const QString sVSEditorLineCutCopy(&quot;VisualStudioEditorOperationsLineCutCopyClipboardTag&quot;);
40  static const QString sWrappedVSEditorLineCutCopy(&quot;application/x-qt-windows-mime;value=\&quot;VisualStudioEditorOperationsLineCutCopyClipboardTag\&quot;&quot;);
41  #elif defined(Q_OS_MAC)
42  static const QString sScintillaRecPboardType(&quot;com.scintilla.utf16-plain-text.rectangular&quot;);
43  static const QString sScintillaRecMimeType(&quot;text/x-scintilla.utf16-plain-text.rectangular&quot;);
44  #else
45  static const QString sMimeRectangularMarker(&quot;text/x-rectangular-marker&quot;);
46  #endif
47  #if defined(Q_OS_MAC) &amp;&amp; QT_VERSION &lt; QT_VERSION_CHECK(5, 0, 0)
48  class ScintillaRectangularMime : public QMacPasteboardMime {
49  public:
50  	ScintillaRectangularMime() : QMacPasteboardMime(MIME_ALL) {
51  	}
52  	QString convertorName() {
53  		return QString(&quot;ScintillaRectangularMime&quot;);
54  	}
55  	bool canConvert(const QString &amp;mime, QString flav) {
56  		return mimeFor(flav) == mime;
57  	}
58  	QString mimeFor(QString flav) {
59  		if (flav == sScintillaRecPboardType)
60  			return sScintillaRecMimeType;
61  		return QString();
62  	}
63  	QString flavorFor(const QString &amp;mime) {
64  		if (mime == sScintillaRecMimeType)
65  			return sScintillaRecPboardType;
66  		return QString();
67  	}
68  	QVariant convertToMime(const QString &amp; &amp;bsol;* mime */, QList&lt;QByteArray&gt; data, QString &amp;bsol;* flav */) {
69  		QByteArray all;
70  		foreach (QByteArray i, data) {
71  			all += i;
72  		}
73  		return QVariant(all);
74  	}
75  	QList&lt;QByteArray&gt; convertFromMime(const QString &amp; &amp;bsol;* mime */, QVariant data, QString &amp;bsol;* flav */) {
76  		QByteArray a = data.toByteArray();
77  		QList&lt;QByteArray&gt; l;
78  		l.append(a);
79  		return l;
80  	}
81  };
82  static ScintillaRectangularMime *singletonMime = 0;
83  #endif
84  void ScintillaQt::Init()
85  {
86  	rectangularSelectionModifier = SCMOD_ALT;
87  #if defined(Q_OS_MAC) &amp;&amp; QT_VERSION &lt; QT_VERSION_CHECK(5, 0, 0)
88  	if (!singletonMime) {
89  		singletonMime = new ScintillaRectangularMime();
90  		QStringList slTypes(sScintillaRecPboardType);
91  		qRegisterDraggedTypes(slTypes);
92  	}
93  #endif
94  	connect(QApplication::clipboard(), SIGNAL(selectionChanged()),
95  		this, SLOT(SelectionChanged()));
96  }
97  void ScintillaQt::Finalise()
98  {
99  	CancelTimers();
100  	ScintillaBase::Finalise();
101  }
102  void ScintillaQt::SelectionChanged()
103  {
104  	bool nowPrimary = QApplication::clipboard()-&gt;ownsSelection();
105  	if (nowPrimary != primarySelection) {
106  		primarySelection = nowPrimary;
107  		Redraw();
108  	}
109  }
110  bool ScintillaQt::DragThreshold(Point ptStart, Point ptNow)
111  {
112  	int xMove = std::abs(ptStart.x - ptNow.x);
113  	int yMove = std::abs(ptStart.y - ptNow.y);
114  	return (xMove &gt; QApplication::startDragDistance()) ||
115  		(yMove &gt; QApplication::startDragDistance());
116  }
117  static QString StringFromSelectedText(const SelectionText &amp;selectedText)
118  {
119  	if (selectedText.codePage == SC_CP_UTF8) {
120  		return QString::fromUtf8(selectedText.Data(), static_cast&lt;int&gt;(selectedText.Length()));
121  	} else {
122  		QTextCodec *codec = QTextCodec::codecForName(
123  				CharacterSetID(selectedText.characterSet));
124  		return codec-&gt;toUnicode(selectedText.Data(), static_cast&lt;int&gt;(selectedText.Length()));
125  	}
126  }
127  static void AddRectangularToMime(QMimeData *mimeData, [[maybe_unused]] const QString &amp;su)
128  {
129  #if defined(Q_OS_WIN)
130  	mimeData-&gt;setData(sMSDEVColumnSelect, QByteArray());
131  #elif defined(Q_OS_MAC)
132  	mimeData-&gt;setData(sScintillaRecMimeType, su.toUtf8());
133  #else
134  	mimeData-&gt;setData(sMimeRectangularMarker, QByteArray());
135  #endif
136  }
137  static void AddLineCutCopyToMime([[maybe_unused]] QMimeData *mimeData)
138  {
139  #if defined(Q_OS_WIN)
140  	mimeData-&gt;setData(sVSEditorLineCutCopy, QByteArray());
141  #endif
142  }
143  static bool IsRectangularInMime(const QMimeData *mimeData)
144  {
145  	QStringList formats = mimeData-&gt;formats();
146  	for (int i = 0; i &lt; formats.size(); ++i) {
147  #if defined(Q_OS_WIN)
148  		if (formats[i] == sMSDEVColumnSelect)
149  			return true;
150  		if (formats[i] == sWrappedMSDEVColumnSelect)
151  			return true;
152  #elif defined(Q_OS_MAC)
153  		if (formats[i] == sScintillaRecMimeType)
154  			return true;
155  #else
156  		if (formats[i] == sMimeRectangularMarker)
157  			return true;
158  #endif
159  	}
160  	return false;
161  }
162  static bool IsLineCutCopyInMime(const QMimeData *mimeData)
163  {
164  	QStringList formats = mimeData-&gt;formats();
165  	for (int i = 0; i &lt; formats.size(); ++i) {
166  #if defined(Q_OS_WIN)
167  		if (formats[i] == sVSEditorLineCutCopy)
168  			return true;
169  		if (formats[i] == sWrappedVSEditorLineCutCopy)
170  			return true;
171  #endif
172  	}
173  	return false;
174  }
175  bool ScintillaQt::ValidCodePage(int codePage) const
176  {
177  	return codePage == 0
178  	|| codePage == SC_CP_UTF8
179  	|| codePage == 932
180  	|| codePage == 936
181  	|| codePage == 949
182  	|| codePage == 950
183  	|| codePage == 1361;
184  }
185  std::string ScintillaQt::UTF8FromEncoded(std::string_view encoded) const {
186  	if (IsUnicodeMode()) {
187  		return std::string(encoded);
188  	} else {
189  		QTextCodec *codec = QTextCodec::codecForName(
190  				CharacterSetID(CharacterSetOfDocument()));
191  		QString text = codec-&gt;toUnicode(encoded.data(), static_cast&lt;int&gt;(encoded.length()));
192  		return text.toStdString();
193  	}
194  }
195  std::string ScintillaQt::EncodedFromUTF8(std::string_view utf8) const {
196  	if (IsUnicodeMode()) {
197  		return std::string(utf8);
198  	} else {
199  		QString text = QString::fromUtf8(utf8.data(), static_cast&lt;int&gt;(utf8.length()));
200  		QTextCodec *codec = QTextCodec::codecForName(
201  				CharacterSetID(CharacterSetOfDocument()));
202  		QByteArray ba = codec-&gt;fromUnicode(text);
203  		return std::string(ba.data(), ba.length());
204  	}
205  }
206  void ScintillaQt::ScrollText(Sci::Line linesToMove)
207  {
208  	int dy = vs.lineHeight * (linesToMove);
209  	scrollArea-&gt;viewport()-&gt;scroll(0, dy);
210  }
211  void ScintillaQt::SetVerticalScrollPos()
212  {
213  	scrollArea-&gt;verticalScrollBar()-&gt;setValue(topLine);
214  	emit verticalScrolled(topLine);
215  }
216  void ScintillaQt::SetHorizontalScrollPos()
217  {
218  	scrollArea-&gt;horizontalScrollBar()-&gt;setValue(xOffset);
219  	emit horizontalScrolled(xOffset);
220  }
221  bool ScintillaQt::ModifyScrollBars(Sci::Line nMax, Sci::Line nPage)
222  {
223  	bool modified = false;
224  	int vNewPage = nPage;
225  	int vNewMax = nMax - vNewPage + 1;
226  	if (vMax != vNewMax || vPage != vNewPage) {
227  		vMax = vNewMax;
228  		vPage = vNewPage;
229  		modified = true;
230  		scrollArea-&gt;verticalScrollBar()-&gt;setMaximum(vMax);
231  		scrollArea-&gt;verticalScrollBar()-&gt;setPageStep(vPage);
232  		emit verticalRangeChanged(vMax, vPage);
233  	}
234  	int hNewPage = GetTextRectangle().Width();
235  	int hNewMax = (scrollWidth &gt; hNewPage) ? scrollWidth - hNewPage : 0;
236  	int charWidth = vs.styles[STYLE_DEFAULT].aveCharWidth;
237  	if (hMax != hNewMax || hPage != hNewPage ||
238  	    scrollArea-&gt;horizontalScrollBar()-&gt;singleStep() != charWidth) {
239  		hMax = hNewMax;
240  		hPage = hNewPage;
241  		modified = true;
242  		scrollArea-&gt;horizontalScrollBar()-&gt;setMaximum(hMax);
243  		scrollArea-&gt;horizontalScrollBar()-&gt;setPageStep(hPage);
244  		scrollArea-&gt;horizontalScrollBar()-&gt;setSingleStep(charWidth);
245  		emit horizontalRangeChanged(hMax, hPage);
246  	}
247  	return modified;
248  }
249  void ScintillaQt::ReconfigureScrollBars()
250  {
251  	if (verticalScrollBarVisible) {
252  		scrollArea-&gt;setVerticalScrollBarPolicy(Qt::ScrollBarAsNeeded);
253  	} else {
254  		scrollArea-&gt;setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
255  	}
256  	if (horizontalScrollBarVisible &amp;&amp; !Wrapping()) {
257  		scrollArea-&gt;setHorizontalScrollBarPolicy(Qt::ScrollBarAsNeeded);
258  	} else {
259  		scrollArea-&gt;setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
260  	}
261  }
262  void ScintillaQt::CopyToModeClipboard(const SelectionText &amp;selectedText, QClipboard::Mode clipboardMode_)
263  {
264  	QClipboard *clipboard = QApplication::clipboard();
265  	QString su = StringFromSelectedText(selectedText);
266  	QMimeData *mimeData = new QMimeData();
267  	mimeData-&gt;setText(su);
268  	if (selectedText.rectangular) {
269  		AddRectangularToMime(mimeData, su);
270  	}
271  	if (selectedText.lineCopy) {
272  		AddLineCutCopyToMime(mimeData);
273  	}
274  	emit aboutToCopy(mimeData);
275  	clipboard-&gt;setMimeData(mimeData, clipboardMode_);
276  }
277  void ScintillaQt::Copy()
278  {
279  	if (!sel.Empty()) {
280  		SelectionText st;
281  		CopySelectionRange(&amp;st);
282  		CopyToClipboard(st);
283  	}
284  }
285  void ScintillaQt::CopyToClipboard(const SelectionText &amp;selectedText)
286  {
287  	CopyToModeClipboard(selectedText, QClipboard::Clipboard);
288  }
289  void ScintillaQt::PasteFromMode(QClipboard::Mode clipboardMode_)
290  {
291  	QClipboard *clipboard = QApplication::clipboard();
292  	const QMimeData *mimeData = clipboard-&gt;mimeData(clipboardMode_);
293  	bool isRectangular = IsRectangularInMime(mimeData);
294  	bool isLine = SelectionEmpty() &amp;&amp; IsLineCutCopyInMime(mimeData);
295  	QString text = clipboard-&gt;text(clipboardMode_);
296  	QByteArray utext = BytesForDocument(text);
297  	std::string dest(utext.constData(), utext.length());
298  	SelectionText selText;
299  	selText.Copy(dest, pdoc-&gt;dbcsCodePage, CharacterSetOfDocument(), isRectangular, false);
300  	UndoGroup ug(pdoc);
301  	ClearSelection(multiPasteMode == MultiPaste::Each);
302  	InsertPasteShape(selText.Data(), selText.Length(),
303  		isRectangular ? PasteShape::rectangular : (isLine ? PasteShape::line : PasteShape::stream));
304  	EnsureCaretVisible();
305  }
306  void ScintillaQt::Paste()
307  {
308  	PasteFromMode(QClipboard::Clipboard);
309  }
310  void ScintillaQt::ClaimSelection()
311  {
312  	if (QApplication::clipboard()-&gt;supportsSelection()) {
313  		if (!sel.Empty()) {
314  			primarySelection = true;
315  			SelectionText st;
316  			CopySelectionRange(&amp;st);
317  			CopyToModeClipboard(st, QClipboard::Selection);
318  		} else {
319  			primarySelection = false;
320  		}
321  	}
322  }
323  void ScintillaQt::NotifyChange()
324  {
325  	emit notifyChange();
326  	emit command(
327  			Platform::LongFromTwoShorts(GetCtrlID(), SCEN_CHANGE),
328  			reinterpret_cast&lt;sptr_t&gt;(wMain.GetID()));
329  }
330  void ScintillaQt::NotifyFocus(bool focus)
331  {
332  	if (commandEvents) {
333  		emit command(
334  				Platform::LongFromTwoShorts
335  						(GetCtrlID(), focus ? SCEN_SETFOCUS : SCEN_KILLFOCUS),
336  				reinterpret_cast&lt;sptr_t&gt;(wMain.GetID()));
337  	}
338  	Editor::NotifyFocus(focus);
339  }
340  void ScintillaQt::NotifyParent(NotificationData scn)
341  {
342  	scn.nmhdr.hwndFrom = wMain.GetID();
343  	scn.nmhdr.idFrom = GetCtrlID();
344  	emit notifyParent(scn);
345  }
346  void ScintillaQt::NotifyURIDropped(const char *uri)
347  {
348  	NotificationData scn = {};
349  	scn.nmhdr.code = Notification::URIDropped;
350  	scn.text = uri;
351  	NotifyParent(scn);
352  }
353  bool ScintillaQt::FineTickerRunning(TickReason reason)
354  {
355  	return timers[static_cast&lt;size_t&gt;(reason)] != 0;
356  }
357  void ScintillaQt::FineTickerStart(TickReason reason, int millis, int &amp;bsol;* tolerance */)
358  {
359  	FineTickerCancel(reason);
360  	timers[static_cast&lt;size_t&gt;(reason)] = startTimer(millis);
361  }
362  void ScintillaQt::CancelTimers()
363  {
364  	for (size_t tr = static_cast&lt;size_t&gt;(TickReason::caret); tr &lt;= static_cast&lt;size_t&gt;(TickReason::dwell); tr++) {
365  		if (timers[tr]) {
366  			killTimer(timers[tr]);
367  			timers[tr] = 0;
368  		}
369  	}
370  }
371  void ScintillaQt::FineTickerCancel(TickReason reason)
372  {
373  	const size_t reasonIndex = static_cast&lt;size_t&gt;(reason);
374  	if (timers[reasonIndex]) {
375  		killTimer(timers[reasonIndex]);
376  		timers[reasonIndex] = 0;
377  	}
378  }
379  void ScintillaQt::onIdle()
380  {
381  	bool continueIdling = Idle();
382  	if (!continueIdling) {
383  		SetIdle(false);
384  	}
385  }
386  bool ScintillaQt::ChangeIdle(bool on)
387  {
388  	if (on) {
389  		if (!idler.state) {
390  			idler.state = true;
391  			QTimer *qIdle = new QTimer;
392  			connect(qIdle, SIGNAL(timeout()), this, SLOT(onIdle()));
393  			qIdle-&gt;start(0);
394  			idler.idlerID = qIdle;
395  		}
396  	} else {
397  		if (idler.state) {
398  			idler.state = false;
399  			QTimer *qIdle = static_cast&lt;QTimer *&gt;(idler.idlerID);
400  			qIdle-&gt;stop();
401  			disconnect(qIdle, SIGNAL(timeout()), nullptr, nullptr);
402  			delete qIdle;
403  			idler.idlerID = {};
404  		}
405  	}
406  	return true;
407  }
408  bool ScintillaQt::SetIdle(bool on)
409  {
410  	return ChangeIdle(on);
411  }
412  CharacterSet ScintillaQt::CharacterSetOfDocument() const
413  {
414  	return vs.styles[STYLE_DEFAULT].characterSet;
415  }
416  const char *ScintillaQt::CharacterSetIDOfDocument() const
417  {
418  	return CharacterSetID(CharacterSetOfDocument());
419  }
420  QString ScintillaQt::StringFromDocument(const char *s) const
421  {
422  	if (IsUnicodeMode()) {
423  		return QString::fromUtf8(s);
424  	} else {
425  		QTextCodec *codec = QTextCodec::codecForName(
426  				CharacterSetID(CharacterSetOfDocument()));
427  		return codec-&gt;toUnicode(s);
428  	}
429  }
430  QByteArray ScintillaQt::BytesForDocument(const QString &amp;text) const
431  {
432  	if (IsUnicodeMode()) {
433  		return text.toUtf8();
434  	} else {
435  		QTextCodec *codec = QTextCodec::codecForName(
436  				CharacterSetID(CharacterSetOfDocument()));
437  		return codec-&gt;fromUnicode(text);
438  	}
439  }
440  namespace {
441  class CaseFolderDBCS : public CaseFolderTable {
442  	QTextCodec *codec;
443  public:
444  	explicit CaseFolderDBCS(QTextCodec *codec_) : codec(codec_) {
445  	}
446  	size_t Fold(char *folded, size_t sizeFolded, const char *mixed, size_t lenMixed) override {
447  		if ((lenMixed == 1) &amp;&amp; (sizeFolded &gt; 0)) {
448  			folded[0] = mapping[static_cast&lt;unsigned char&gt;(mixed[0])];
449  			return 1;
450  		} else if (codec) {
451  			QString su = codec-&gt;toUnicode(mixed, static_cast&lt;int&gt;(lenMixed));
452  			QString suFolded = su.toCaseFolded();
453  			QByteArray bytesFolded = codec-&gt;fromUnicode(suFolded);
454  			if (bytesFolded.length() &lt; static_cast&lt;int&gt;(sizeFolded)) {
455  				memcpy(folded, bytesFolded,  bytesFolded.length());
456  				return bytesFolded.length();
457  			}
458  		}
459  		folded[0] = &#x27;\0&#x27;;
460  		return 1;
461  	}
462  };
463  }
464  std::unique_ptr&lt;CaseFolder&gt; ScintillaQt::CaseFolderForEncoding()
465  {
466  	if (pdoc-&gt;dbcsCodePage == SC_CP_UTF8) {
467  		return std::make_unique&lt;CaseFolderUnicode&gt;();
468  	} else {
469  		const char *charSetBuffer = CharacterSetIDOfDocument();
470  		if (charSetBuffer) {
471  			if (pdoc-&gt;dbcsCodePage == 0) {
472  				std::unique_ptr&lt;CaseFolderTable&gt; pcf = std::make_unique&lt;CaseFolderTable&gt;();
473  				QTextCodec *codec = QTextCodec::codecForName(charSetBuffer);
474  				for (int i=0x80; i&lt;0x100; i++) {
475  					char sCharacter[2] = &quot;A&quot;;
476  					sCharacter[0] = static_cast&lt;char&gt;(i);
477  					QString su = codec-&gt;toUnicode(sCharacter, 1);
478  					QString suFolded = su.toCaseFolded();
479  					if (codec-&gt;canEncode(suFolded)) {
480  						QByteArray bytesFolded = codec-&gt;fromUnicode(suFolded);
481  						if (bytesFolded.length() == 1) {
482  							pcf-&gt;SetTranslation(sCharacter[0], bytesFolded[0]);
483  						}
484  					}
485  				}
486  				return pcf;
487  			} else {
488  				return std::make_unique&lt;CaseFolderDBCS&gt;(QTextCodec::codecForName(charSetBuffer));
489  			}
490  		}
491  		return nullptr;
492  	}
493  }
494  std::string ScintillaQt::CaseMapString(const std::string &amp;s, CaseMapping caseMapping)
495  {
496  	if (s.empty() || (caseMapping == CaseMapping::same))
497  		return s;
498  	if (IsUnicodeMode()) {
499  		std::string retMapped(s.length() * maxExpansionCaseConversion, 0);
500  		size_t lenMapped = CaseConvertString(&amp;retMapped[0], retMapped.length(), s.c_str(), s.length(),
501  			(caseMapping == CaseMapping::upper) ? CaseConversion::upper : CaseConversion::lower);
502  		retMapped.resize(lenMapped);
503  		return retMapped;
504  	}
505  	QTextCodec *codec = QTextCodec::codecForName(CharacterSetIDOfDocument());
506  	QString text = codec-&gt;toUnicode(s.c_str(), static_cast&lt;int&gt;(s.length()));
507  	if (caseMapping == CaseMapping::upper) {
508  		text = text.toUpper();
509  	} else {
510  		text = text.toLower();
511  	}
512  	QByteArray bytes = BytesForDocument(text);
513  	return std::string(bytes.data(), bytes.length());
514  }
515  void ScintillaQt::SetMouseCapture(bool on)
516  {
517  	if (mouseDownCaptures) {
518  		haveMouseCapture = on;
519  	}
520  }
521  bool ScintillaQt::HaveMouseCapture()
522  {
523  	return haveMouseCapture;
524  }
525  void ScintillaQt::StartDrag()
526  {
527  	inDragDrop = DragDrop::dragging;
528  	dropWentOutside = true;
529  	if (drag.Length()) {
530  		QMimeData *mimeData = new QMimeData;
531  		QString sText = StringFromSelectedText(drag);
532  		mimeData-&gt;setText(sText);
533  		if (drag.rectangular) {
534  			AddRectangularToMime(mimeData, sText);
535  		}
536  		QDrag *dragon = new QDrag(scrollArea);
537  		dragon-&gt;setMimeData(mimeData);
538  		Qt::DropAction dropAction = dragon-&gt;exec(static_cast&lt;Qt::DropActions&gt;(Qt::CopyAction|Qt::MoveAction));
539  		if ((dropAction == Qt::MoveAction) &amp;&amp; dropWentOutside) {
540  			ClearSelection();
541  		}
542  	}
543  	inDragDrop = DragDrop::none;
544  	SetDragPosition(SelectionPosition(Sci::invalidPosition));
545  }
546  class CallTipImpl : public QWidget {
547  public:
548  	explicit CallTipImpl(CallTip *pct_)
549  		: QWidget(nullptr, Qt::ToolTip),
550  		  pct(pct_)
551  	{
552  #if QT_VERSION &gt;= QT_VERSION_CHECK(5, 9, 0)
553  		setWindowFlag(Qt::WindowTransparentForInput);
554  #endif
555  	}
556  	void paintEvent(QPaintEvent *) override
557  	{
558  		if (pct-&gt;inCallTipMode) {
559  			std::unique_ptr&lt;Surface&gt; surfaceWindow = Surface::Allocate(Technology::Default);
560  			surfaceWindow-&gt;Init(this);
561  			surfaceWindow-&gt;SetMode(SurfaceMode(pct-&gt;codePage, false));
562  			pct-&gt;PaintCT(surfaceWindow.get());
563  		}
564  	}
565  private:
566  	CallTip *pct;
567  };
568  void ScintillaQt::CreateCallTipWindow(PRectangle rc)
569  {
570  	if (!ct.wCallTip.Created()) {
571  		QWidget *pCallTip = new CallTipImpl(&amp;ct);
572  		ct.wCallTip = pCallTip;
573  		pCallTip-&gt;move(rc.left, rc.top);
574  		pCallTip-&gt;resize(rc.Width(), rc.Height());
575  	}
576  }
577  void ScintillaQt::AddToPopUp(const char *label,
578                               int cmd,
579                               bool enabled)
580  {
581  	QMenu *menu = static_cast&lt;QMenu *&gt;(popup.GetID());
582  	QString text(label);
583  	if (text.isEmpty()) {
584  		menu-&gt;addSeparator();
585  	} else {
586  		QAction *action = menu-&gt;addAction(text);
587  		action-&gt;setData(cmd);
588  		action-&gt;setEnabled(enabled);
589  	}
590  	menu-&gt;disconnect();
591  	connect(menu, SIGNAL(triggered(QAction*)),
592  		this, SLOT(execCommand(QAction*)));
593  }
594  sptr_t ScintillaQt::WndProc(Message iMessage, uptr_t wParam, sptr_t lParam)
595  {
596  	try {
597  		switch (iMessage) {
598  		case Message::SetIMEInteraction:
599  			break;
600  		case Message::GrabFocus:
601  			scrollArea-&gt;setFocus(Qt::OtherFocusReason);
602  			break;
603  		case Message::GetDirectFunction:
604  			return reinterpret_cast&lt;sptr_t&gt;(DirectFunction);
605  		case Message::GetDirectStatusFunction:
606  			return reinterpret_cast&lt;sptr_t&gt;(DirectStatusFunction);
607  		case Message::GetDirectPointer:
608  			return reinterpret_cast&lt;sptr_t&gt;(this);
609  		case Message::SetRectangularSelectionModifier:
610  			rectangularSelectionModifier = static_cast&lt;int&gt;(wParam);
611  			break;
612  		case Message::GetRectangularSelectionModifier:
613  			return rectangularSelectionModifier;
614  		default:
615  			return ScintillaBase::WndProc(iMessage, wParam, lParam);
616  		}
617  	} catch (std::bad_alloc &amp;) {
618  		errorStatus = Status::BadAlloc;
619  	} catch (...) {
620  		errorStatus = Status::Failure;
621  	}
622  	return 0;
623  }
624  sptr_t ScintillaQt::DefWndProc(Message, uptr_t, sptr_t)
625  {
626  	return 0;
627  }
628  sptr_t ScintillaQt::DirectFunction(
629      sptr_t ptr, unsigned int iMessage, uptr_t wParam, sptr_t lParam)
630  {
631  	ScintillaQt *sci = reinterpret_cast&lt;ScintillaQt *&gt;(ptr);
632  	return sci-&gt;WndProc(static_cast&lt;Message&gt;(iMessage), wParam, lParam);
633  }
634  sptr_t ScintillaQt::DirectStatusFunction(
635      sptr_t ptr, unsigned int iMessage, uptr_t wParam, sptr_t lParam, int *pStatus)
636  {
637  	ScintillaQt *sci = reinterpret_cast&lt;ScintillaQt *&gt;(ptr);
638  	const sptr_t returnValue = sci-&gt;WndProc(static_cast&lt;Message&gt;(iMessage), wParam, lParam);
639  	*pStatus = static_cast&lt;int&gt;(sci-&gt;errorStatus);
640  	return returnValue;
641  }
642  void ScintillaQt::PartialPaint(const PRectangle &amp;rect)
643  {
644  	rcPaint = rect;
645  	paintState = PaintState::painting;
646  	PRectangle rcClient = GetClientRectangle();
647  	paintingAllText = rcPaint.Contains(rcClient);
<span onclick='openModal()' class='match'>648  	AutoSurface surfacePaint(this);
649  	Paint(surfacePaint, rcPaint);
650  	surfacePaint-&gt;Release();
651  	if (paintState == PaintState::abandoned) {
</span>652  		paintState = PaintState::painting;
653  		paintingAllText = true;
654  		AutoSurface surface(this);
655  		Paint(surface, rcPaint);
656  		surface-&gt;Release();
657  		scrollArea-&gt;viewport()-&gt;update();
658  	}
659  	paintState = PaintState::notPainting;
660  }
661  void ScintillaQt::DragEnter(const Point &amp;point)
662  {
663  	SetDragPosition(SPositionFromLocation(point,
664  					      false, false, UserVirtualSpace()));
665  }
666  void ScintillaQt::DragMove(const Point &amp;point)
667  {
668  	SetDragPosition(SPositionFromLocation(point,
669  					      false, false, UserVirtualSpace()));
670  }
671  void ScintillaQt::DragLeave()
672  {
673  	SetDragPosition(SelectionPosition(Sci::invalidPosition));
674  }
675  void ScintillaQt::Drop(const Point &amp;point, const QMimeData *data, bool move)
676  {
677  	QString text = data-&gt;text();
678  	bool rectangular = IsRectangularInMime(data);
679  	QByteArray bytes = BytesForDocument(text);
680  	int len = bytes.length();
681  	SelectionPosition movePos = SPositionFromLocation(point,
682  				false, false, UserVirtualSpace());
683  	DropAt(movePos, bytes, len, move, rectangular);
684  }
685  void ScintillaQt::DropUrls(const QMimeData *data)
686  {
687  	foreach(const QUrl &amp;url, data-&gt;urls()) {
688  		NotifyURIDropped(url.toString().toUtf8().constData());
689  	}
690  }
691  void ScintillaQt::timerEvent(QTimerEvent *event)
692  {
693  	for (size_t tr=static_cast&lt;size_t&gt;(TickReason::caret); tr&lt;=static_cast&lt;size_t&gt;(TickReason::dwell); tr++) {
694  		if (timers[tr] == event-&gt;timerId()) {
695  			TickFor(static_cast&lt;TickReason&gt;(tr));
696  		}
697  	}
698  }
</code></pre>
        </div>
        <div class="column">
            <h3>notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ScintillaQt.cpp</h3>
            <pre><code>1  #include &quot;ScintillaQt.h&quot;
2  #include &quot;PlatQt.h&quot;
3  #include &lt;QApplication&gt;
4  #include &lt;QDrag&gt;
5  #if QT_VERSION &lt; QT_VERSION_CHECK(5, 0, 0)
6  #include &lt;QInputContext&gt;
7  #endif
8  #include &lt;QMimeData&gt;
9  #include &lt;QMenu&gt;
10  #include &lt;QTextCodec&gt;
11  #include &lt;QScrollBar&gt;
12  #include &lt;QTimer&gt;
13  using namespace Scintilla;
14  using namespace Scintilla::Internal;
15  ScintillaQt::ScintillaQt(QAbstractScrollArea *parent)
16  : QObject(parent), scrollArea(parent), vMax(0),  hMax(0), vPage(0), hPage(0),
17   haveMouseCapture(false), dragWasDropped(false),
18   rectangularSelectionModifier(SCMOD_ALT)
19  {
20  	wMain = scrollArea-&gt;viewport();
21  	imeInteraction = IMEInteraction::Inline;
22  	view.bufferedDraw = false;
23  	Init();
24  	std::fill(timers, std::end(timers), 0);
25  }
26  ScintillaQt::~ScintillaQt()
27  {
28  	CancelTimers();
29  	ChangeIdle(false);
30  }
31  void ScintillaQt::execCommand(QAction *action)
32  {
33  	const int commandNum = action-&gt;data().toInt();
34  	Command(commandNum);
35  }
36  #if defined(Q_OS_WIN)
37  static const QString sMSDEVColumnSelect(&quot;MSDEVColumnSelect&quot;);
38  static const QString sWrappedMSDEVColumnSelect(&quot;application/x-qt-windows-mime;value=\&quot;MSDEVColumnSelect\&quot;&quot;);
39  static const QString sVSEditorLineCutCopy(&quot;VisualStudioEditorOperationsLineCutCopyClipboardTag&quot;);
40  static const QString sWrappedVSEditorLineCutCopy(&quot;application/x-qt-windows-mime;value=\&quot;VisualStudioEditorOperationsLineCutCopyClipboardTag\&quot;&quot;);
41  #elif defined(Q_OS_MAC)
42  static const QString sScintillaRecPboardType(&quot;com.scintilla.utf16-plain-text.rectangular&quot;);
43  static const QString sScintillaRecMimeType(&quot;text/x-scintilla.utf16-plain-text.rectangular&quot;);
44  #else
45  static const QString sMimeRectangularMarker(&quot;text/x-rectangular-marker&quot;);
46  #endif
47  #if defined(Q_OS_MAC) &amp;&amp; QT_VERSION &lt; QT_VERSION_CHECK(5, 0, 0)
48  class ScintillaRectangularMime : public QMacPasteboardMime {
49  public:
50  	ScintillaRectangularMime() : QMacPasteboardMime(MIME_ALL) {
51  	}
52  	QString convertorName() {
53  		return QString(&quot;ScintillaRectangularMime&quot;);
54  	}
55  	bool canConvert(const QString &amp;mime, QString flav) {
56  		return mimeFor(flav) == mime;
57  	}
58  	QString mimeFor(QString flav) {
59  		if (flav == sScintillaRecPboardType)
60  			return sScintillaRecMimeType;
61  		return QString();
62  	}
63  	QString flavorFor(const QString &amp;mime) {
64  		if (mime == sScintillaRecMimeType)
65  			return sScintillaRecPboardType;
66  		return QString();
67  	}
68  	QVariant convertToMime(const QString &amp; &amp;bsol;* mime */, QList&lt;QByteArray&gt; data, QString &amp;bsol;* flav */) {
69  		QByteArray all;
70  		foreach (QByteArray i, data) {
71  			all += i;
72  		}
73  		return QVariant(all);
74  	}
75  	QList&lt;QByteArray&gt; convertFromMime(const QString &amp; &amp;bsol;* mime */, QVariant data, QString &amp;bsol;* flav */) {
76  		QByteArray a = data.toByteArray();
77  		QList&lt;QByteArray&gt; l;
78  		l.append(a);
79  		return l;
80  	}
81  };
82  static ScintillaRectangularMime *singletonMime = 0;
83  #endif
84  void ScintillaQt::Init()
85  {
86  	rectangularSelectionModifier = SCMOD_ALT;
87  #if defined(Q_OS_MAC) &amp;&amp; QT_VERSION &lt; QT_VERSION_CHECK(5, 0, 0)
88  	if (!singletonMime) {
89  		singletonMime = new ScintillaRectangularMime();
90  		QStringList slTypes(sScintillaRecPboardType);
91  		qRegisterDraggedTypes(slTypes);
92  	}
93  #endif
94  	connect(QApplication::clipboard(), SIGNAL(selectionChanged()),
95  		this, SLOT(SelectionChanged()));
96  }
97  void ScintillaQt::Finalise()
98  {
99  	CancelTimers();
100  	ScintillaBase::Finalise();
101  }
102  void ScintillaQt::SelectionChanged()
103  {
104  	bool nowPrimary = QApplication::clipboard()-&gt;ownsSelection();
105  	if (nowPrimary != primarySelection) {
106  		primarySelection = nowPrimary;
107  		Redraw();
108  	}
109  }
110  bool ScintillaQt::DragThreshold(Point ptStart, Point ptNow)
111  {
112  	int xMove = std::abs(ptStart.x - ptNow.x);
113  	int yMove = std::abs(ptStart.y - ptNow.y);
114  	return (xMove &gt; QApplication::startDragDistance()) ||
115  		(yMove &gt; QApplication::startDragDistance());
116  }
117  static QString StringFromSelectedText(const SelectionText &amp;selectedText)
118  {
119  	if (selectedText.codePage == SC_CP_UTF8) {
120  		return QString::fromUtf8(selectedText.Data(), static_cast&lt;int&gt;(selectedText.Length()));
121  	} else {
122  		QTextCodec *codec = QTextCodec::codecForName(
123  				CharacterSetID(selectedText.characterSet));
124  		return codec-&gt;toUnicode(selectedText.Data(), static_cast&lt;int&gt;(selectedText.Length()));
125  	}
126  }
127  static void AddRectangularToMime(QMimeData *mimeData, [[maybe_unused]] const QString &amp;su)
128  {
129  #if defined(Q_OS_WIN)
130  	mimeData-&gt;setData(sMSDEVColumnSelect, QByteArray());
131  #elif defined(Q_OS_MAC)
132  	mimeData-&gt;setData(sScintillaRecMimeType, su.toUtf8());
133  #else
134  	mimeData-&gt;setData(sMimeRectangularMarker, QByteArray());
135  #endif
136  }
137  static void AddLineCutCopyToMime([[maybe_unused]] QMimeData *mimeData)
138  {
139  #if defined(Q_OS_WIN)
140  	mimeData-&gt;setData(sVSEditorLineCutCopy, QByteArray());
141  #endif
142  }
143  static bool IsRectangularInMime(const QMimeData *mimeData)
144  {
145  	QStringList formats = mimeData-&gt;formats();
146  	for (int i = 0; i &lt; formats.size(); ++i) {
147  #if defined(Q_OS_WIN)
148  		if (formats[i] == sMSDEVColumnSelect)
149  			return true;
150  		if (formats[i] == sWrappedMSDEVColumnSelect)
151  			return true;
152  #elif defined(Q_OS_MAC)
153  		if (formats[i] == sScintillaRecMimeType)
154  			return true;
155  #else
156  		if (formats[i] == sMimeRectangularMarker)
157  			return true;
158  #endif
159  	}
160  	return false;
161  }
162  static bool IsLineCutCopyInMime(const QMimeData *mimeData)
163  {
164  	QStringList formats = mimeData-&gt;formats();
165  	for (int i = 0; i &lt; formats.size(); ++i) {
166  #if defined(Q_OS_WIN)
167  		if (formats[i] == sVSEditorLineCutCopy)
168  			return true;
169  		if (formats[i] == sWrappedVSEditorLineCutCopy)
170  			return true;
171  #endif
172  	}
173  	return false;
174  }
175  bool ScintillaQt::ValidCodePage(int codePage) const
176  {
177  	return codePage == 0
178  	|| codePage == SC_CP_UTF8
179  	|| codePage == 932
180  	|| codePage == 936
181  	|| codePage == 949
182  	|| codePage == 950
183  	|| codePage == 1361;
184  }
185  std::string ScintillaQt::UTF8FromEncoded(std::string_view encoded) const {
186  	if (IsUnicodeMode()) {
187  		return std::string(encoded);
188  	} else {
189  		QTextCodec *codec = QTextCodec::codecForName(
190  				CharacterSetID(CharacterSetOfDocument()));
191  		QString text = codec-&gt;toUnicode(encoded.data(), static_cast&lt;int&gt;(encoded.length()));
192  		return text.toStdString();
193  	}
194  }
195  std::string ScintillaQt::EncodedFromUTF8(std::string_view utf8) const {
196  	if (IsUnicodeMode()) {
197  		return std::string(utf8);
198  	} else {
199  		QString text = QString::fromUtf8(utf8.data(), static_cast&lt;int&gt;(utf8.length()));
200  		QTextCodec *codec = QTextCodec::codecForName(
201  				CharacterSetID(CharacterSetOfDocument()));
202  		QByteArray ba = codec-&gt;fromUnicode(text);
203  		return std::string(ba.data(), ba.length());
204  	}
205  }
206  void ScintillaQt::ScrollText(Sci::Line linesToMove)
207  {
208  	int dy = vs.lineHeight * (linesToMove);
209  	scrollArea-&gt;viewport()-&gt;scroll(0, dy);
210  }
211  void ScintillaQt::SetVerticalScrollPos()
212  {
213  	scrollArea-&gt;verticalScrollBar()-&gt;setValue(topLine);
214  	emit verticalScrolled(topLine);
215  }
216  void ScintillaQt::SetHorizontalScrollPos()
217  {
218  	scrollArea-&gt;horizontalScrollBar()-&gt;setValue(xOffset);
219  	emit horizontalScrolled(xOffset);
220  }
221  bool ScintillaQt::ModifyScrollBars(Sci::Line nMax, Sci::Line nPage)
222  {
223  	bool modified = false;
224  	int vNewPage = nPage;
225  	int vNewMax = nMax - vNewPage + 1;
226  	if (vMax != vNewMax || vPage != vNewPage) {
227  		vMax = vNewMax;
228  		vPage = vNewPage;
229  		modified = true;
230  		scrollArea-&gt;verticalScrollBar()-&gt;setMaximum(vMax);
231  		scrollArea-&gt;verticalScrollBar()-&gt;setPageStep(vPage);
232  		emit verticalRangeChanged(vMax, vPage);
233  	}
234  	int hNewPage = GetTextRectangle().Width();
235  	int hNewMax = (scrollWidth &gt; hNewPage) ? scrollWidth - hNewPage : 0;
236  	int charWidth = vs.styles[STYLE_DEFAULT].aveCharWidth;
237  	if (hMax != hNewMax || hPage != hNewPage ||
238  	    scrollArea-&gt;horizontalScrollBar()-&gt;singleStep() != charWidth) {
239  		hMax = hNewMax;
240  		hPage = hNewPage;
241  		modified = true;
242  		scrollArea-&gt;horizontalScrollBar()-&gt;setMaximum(hMax);
243  		scrollArea-&gt;horizontalScrollBar()-&gt;setPageStep(hPage);
244  		scrollArea-&gt;horizontalScrollBar()-&gt;setSingleStep(charWidth);
245  		emit horizontalRangeChanged(hMax, hPage);
246  	}
247  	return modified;
248  }
249  void ScintillaQt::ReconfigureScrollBars()
250  {
251  	if (verticalScrollBarVisible) {
252  		scrollArea-&gt;setVerticalScrollBarPolicy(Qt::ScrollBarAsNeeded);
253  	} else {
254  		scrollArea-&gt;setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
255  	}
256  	if (horizontalScrollBarVisible &amp;&amp; !Wrapping()) {
257  		scrollArea-&gt;setHorizontalScrollBarPolicy(Qt::ScrollBarAsNeeded);
258  	} else {
259  		scrollArea-&gt;setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
260  	}
261  }
262  void ScintillaQt::CopyToModeClipboard(const SelectionText &amp;selectedText, QClipboard::Mode clipboardMode_)
263  {
264  	QClipboard *clipboard = QApplication::clipboard();
265  	QString su = StringFromSelectedText(selectedText);
266  	QMimeData *mimeData = new QMimeData();
267  	mimeData-&gt;setText(su);
268  	if (selectedText.rectangular) {
269  		AddRectangularToMime(mimeData, su);
270  	}
271  	if (selectedText.lineCopy) {
272  		AddLineCutCopyToMime(mimeData);
273  	}
274  	emit aboutToCopy(mimeData);
275  	clipboard-&gt;setMimeData(mimeData, clipboardMode_);
276  }
277  void ScintillaQt::Copy()
278  {
279  	if (!sel.Empty()) {
280  		SelectionText st;
281  		CopySelectionRange(&amp;st);
282  		CopyToClipboard(st);
283  	}
284  }
285  void ScintillaQt::CopyToClipboard(const SelectionText &amp;selectedText)
286  {
287  	CopyToModeClipboard(selectedText, QClipboard::Clipboard);
288  }
289  void ScintillaQt::PasteFromMode(QClipboard::Mode clipboardMode_)
290  {
291  	QClipboard *clipboard = QApplication::clipboard();
292  	const QMimeData *mimeData = clipboard-&gt;mimeData(clipboardMode_);
293  	bool isRectangular = IsRectangularInMime(mimeData);
294  	bool isLine = SelectionEmpty() &amp;&amp; IsLineCutCopyInMime(mimeData);
295  	QString text = clipboard-&gt;text(clipboardMode_);
296  	QByteArray utext = BytesForDocument(text);
297  	std::string dest(utext.constData(), utext.length());
298  	SelectionText selText;
299  	selText.Copy(dest, pdoc-&gt;dbcsCodePage, CharacterSetOfDocument(), isRectangular, false);
300  	UndoGroup ug(pdoc);
301  	ClearSelection(multiPasteMode == MultiPaste::Each);
302  	InsertPasteShape(selText.Data(), selText.Length(),
303  		isRectangular ? PasteShape::rectangular : (isLine ? PasteShape::line : PasteShape::stream));
304  	EnsureCaretVisible();
305  }
306  void ScintillaQt::Paste()
307  {
308  	PasteFromMode(QClipboard::Clipboard);
309  }
310  void ScintillaQt::ClaimSelection()
311  {
312  	if (QApplication::clipboard()-&gt;supportsSelection()) {
313  		if (!sel.Empty()) {
314  			primarySelection = true;
315  			SelectionText st;
316  			CopySelectionRange(&amp;st);
317  			CopyToModeClipboard(st, QClipboard::Selection);
318  		} else {
319  			primarySelection = false;
320  		}
321  	}
322  }
323  void ScintillaQt::NotifyChange()
324  {
325  	emit notifyChange();
326  	emit command(
327  			Platform::LongFromTwoShorts(GetCtrlID(), SCEN_CHANGE),
328  			reinterpret_cast&lt;sptr_t&gt;(wMain.GetID()));
329  }
330  void ScintillaQt::NotifyFocus(bool focus)
331  {
332  	if (commandEvents) {
333  		emit command(
334  				Platform::LongFromTwoShorts
335  						(GetCtrlID(), focus ? SCEN_SETFOCUS : SCEN_KILLFOCUS),
336  				reinterpret_cast&lt;sptr_t&gt;(wMain.GetID()));
337  	}
338  	Editor::NotifyFocus(focus);
339  }
340  void ScintillaQt::NotifyParent(NotificationData scn)
341  {
342  	scn.nmhdr.hwndFrom = wMain.GetID();
343  	scn.nmhdr.idFrom = GetCtrlID();
344  	emit notifyParent(scn);
345  }
346  void ScintillaQt::NotifyURIDropped(const char *uri)
347  {
348  	NotificationData scn = {};
349  	scn.nmhdr.code = Notification::URIDropped;
350  	scn.text = uri;
351  	NotifyParent(scn);
352  }
353  bool ScintillaQt::FineTickerRunning(TickReason reason)
354  {
355  	return timers[static_cast&lt;size_t&gt;(reason)] != 0;
356  }
357  void ScintillaQt::FineTickerStart(TickReason reason, int millis, int &amp;bsol;* tolerance */)
358  {
359  	FineTickerCancel(reason);
360  	timers[static_cast&lt;size_t&gt;(reason)] = startTimer(millis);
361  }
362  void ScintillaQt::CancelTimers()
363  {
364  	for (size_t tr = static_cast&lt;size_t&gt;(TickReason::caret); tr &lt;= static_cast&lt;size_t&gt;(TickReason::dwell); tr++) {
365  		if (timers[tr]) {
366  			killTimer(timers[tr]);
367  			timers[tr] = 0;
368  		}
369  	}
370  }
371  void ScintillaQt::FineTickerCancel(TickReason reason)
372  {
373  	const size_t reasonIndex = static_cast&lt;size_t&gt;(reason);
374  	if (timers[reasonIndex]) {
375  		killTimer(timers[reasonIndex]);
376  		timers[reasonIndex] = 0;
377  	}
378  }
379  void ScintillaQt::onIdle()
380  {
381  	bool continueIdling = Idle();
382  	if (!continueIdling) {
383  		SetIdle(false);
384  	}
385  }
386  bool ScintillaQt::ChangeIdle(bool on)
387  {
388  	if (on) {
389  		if (!idler.state) {
390  			idler.state = true;
391  			QTimer *qIdle = new QTimer;
392  			connect(qIdle, SIGNAL(timeout()), this, SLOT(onIdle()));
393  			qIdle-&gt;start(0);
394  			idler.idlerID = qIdle;
395  		}
396  	} else {
397  		if (idler.state) {
398  			idler.state = false;
399  			QTimer *qIdle = static_cast&lt;QTimer *&gt;(idler.idlerID);
400  			qIdle-&gt;stop();
401  			disconnect(qIdle, SIGNAL(timeout()), nullptr, nullptr);
402  			delete qIdle;
403  			idler.idlerID = {};
404  		}
405  	}
406  	return true;
407  }
408  bool ScintillaQt::SetIdle(bool on)
409  {
410  	return ChangeIdle(on);
411  }
412  CharacterSet ScintillaQt::CharacterSetOfDocument() const
413  {
414  	return vs.styles[STYLE_DEFAULT].characterSet;
415  }
416  const char *ScintillaQt::CharacterSetIDOfDocument() const
417  {
418  	return CharacterSetID(CharacterSetOfDocument());
419  }
420  QString ScintillaQt::StringFromDocument(const char *s) const
421  {
422  	if (IsUnicodeMode()) {
423  		return QString::fromUtf8(s);
424  	} else {
425  		QTextCodec *codec = QTextCodec::codecForName(
426  				CharacterSetID(CharacterSetOfDocument()));
427  		return codec-&gt;toUnicode(s);
428  	}
429  }
430  QByteArray ScintillaQt::BytesForDocument(const QString &amp;text) const
431  {
432  	if (IsUnicodeMode()) {
433  		return text.toUtf8();
434  	} else {
435  		QTextCodec *codec = QTextCodec::codecForName(
436  				CharacterSetID(CharacterSetOfDocument()));
437  		return codec-&gt;fromUnicode(text);
438  	}
439  }
440  namespace {
441  class CaseFolderDBCS : public CaseFolderTable {
442  	QTextCodec *codec;
443  public:
444  	explicit CaseFolderDBCS(QTextCodec *codec_) : codec(codec_) {
445  	}
446  	size_t Fold(char *folded, size_t sizeFolded, const char *mixed, size_t lenMixed) override {
447  		if ((lenMixed == 1) &amp;&amp; (sizeFolded &gt; 0)) {
448  			folded[0] = mapping[static_cast&lt;unsigned char&gt;(mixed[0])];
449  			return 1;
450  		} else if (codec) {
451  			QString su = codec-&gt;toUnicode(mixed, static_cast&lt;int&gt;(lenMixed));
452  			QString suFolded = su.toCaseFolded();
453  			QByteArray bytesFolded = codec-&gt;fromUnicode(suFolded);
454  			if (bytesFolded.length() &lt; static_cast&lt;int&gt;(sizeFolded)) {
455  				memcpy(folded, bytesFolded,  bytesFolded.length());
456  				return bytesFolded.length();
457  			}
458  		}
459  		folded[0] = &#x27;\0&#x27;;
460  		return 1;
461  	}
462  };
463  }
464  std::unique_ptr&lt;CaseFolder&gt; ScintillaQt::CaseFolderForEncoding()
465  {
466  	if (pdoc-&gt;dbcsCodePage == SC_CP_UTF8) {
467  		return std::make_unique&lt;CaseFolderUnicode&gt;();
468  	} else {
469  		const char *charSetBuffer = CharacterSetIDOfDocument();
470  		if (charSetBuffer) {
471  			if (pdoc-&gt;dbcsCodePage == 0) {
472  				std::unique_ptr&lt;CaseFolderTable&gt; pcf = std::make_unique&lt;CaseFolderTable&gt;();
473  				QTextCodec *codec = QTextCodec::codecForName(charSetBuffer);
474  				for (int i=0x80; i&lt;0x100; i++) {
475  					char sCharacter[2] = &quot;A&quot;;
476  					sCharacter[0] = static_cast&lt;char&gt;(i);
477  					QString su = codec-&gt;toUnicode(sCharacter, 1);
478  					QString suFolded = su.toCaseFolded();
479  					if (codec-&gt;canEncode(suFolded)) {
480  						QByteArray bytesFolded = codec-&gt;fromUnicode(suFolded);
481  						if (bytesFolded.length() == 1) {
482  							pcf-&gt;SetTranslation(sCharacter[0], bytesFolded[0]);
483  						}
484  					}
485  				}
486  				return pcf;
487  			} else {
488  				return std::make_unique&lt;CaseFolderDBCS&gt;(QTextCodec::codecForName(charSetBuffer));
489  			}
490  		}
491  		return nullptr;
492  	}
493  }
494  std::string ScintillaQt::CaseMapString(const std::string &amp;s, CaseMapping caseMapping)
495  {
496  	if (s.empty() || (caseMapping == CaseMapping::same))
497  		return s;
498  	if (IsUnicodeMode()) {
499  		std::string retMapped(s.length() * maxExpansionCaseConversion, 0);
500  		size_t lenMapped = CaseConvertString(&amp;retMapped[0], retMapped.length(), s.c_str(), s.length(),
501  			(caseMapping == CaseMapping::upper) ? CaseConversion::upper : CaseConversion::lower);
502  		retMapped.resize(lenMapped);
503  		return retMapped;
504  	}
505  	QTextCodec *codec = QTextCodec::codecForName(CharacterSetIDOfDocument());
506  	QString text = codec-&gt;toUnicode(s.c_str(), static_cast&lt;int&gt;(s.length()));
507  	if (caseMapping == CaseMapping::upper) {
508  		text = text.toUpper();
509  	} else {
510  		text = text.toLower();
511  	}
512  	QByteArray bytes = BytesForDocument(text);
513  	return std::string(bytes.data(), bytes.length());
514  }
515  void ScintillaQt::SetMouseCapture(bool on)
516  {
517  	if (mouseDownCaptures) {
518  		haveMouseCapture = on;
519  	}
520  }
521  bool ScintillaQt::HaveMouseCapture()
522  {
523  	return haveMouseCapture;
524  }
525  void ScintillaQt::StartDrag()
526  {
527  	inDragDrop = DragDrop::dragging;
528  	dropWentOutside = true;
529  	if (drag.Length()) {
530  		QMimeData *mimeData = new QMimeData;
531  		QString sText = StringFromSelectedText(drag);
532  		mimeData-&gt;setText(sText);
533  		if (drag.rectangular) {
534  			AddRectangularToMime(mimeData, sText);
535  		}
536  		QDrag *dragon = new QDrag(scrollArea);
537  		dragon-&gt;setMimeData(mimeData);
538  		Qt::DropAction dropAction = dragon-&gt;exec(static_cast&lt;Qt::DropActions&gt;(Qt::CopyAction|Qt::MoveAction));
539  		if ((dropAction == Qt::MoveAction) &amp;&amp; dropWentOutside) {
540  			ClearSelection();
541  		}
542  	}
543  	inDragDrop = DragDrop::none;
544  	SetDragPosition(SelectionPosition(Sci::invalidPosition));
545  }
546  class CallTipImpl : public QWidget {
547  public:
548  	explicit CallTipImpl(CallTip *pct_)
549  		: QWidget(nullptr, Qt::ToolTip),
550  		  pct(pct_)
551  	{
552  #if QT_VERSION &gt;= QT_VERSION_CHECK(5, 9, 0)
553  		setWindowFlag(Qt::WindowTransparentForInput);
554  #endif
555  	}
556  	void paintEvent(QPaintEvent *) override
557  	{
558  		if (pct-&gt;inCallTipMode) {
559  			std::unique_ptr&lt;Surface&gt; surfaceWindow = Surface::Allocate(Technology::Default);
560  			surfaceWindow-&gt;Init(this);
561  			surfaceWindow-&gt;SetMode(SurfaceMode(pct-&gt;codePage, false));
562  			pct-&gt;PaintCT(surfaceWindow.get());
563  		}
564  	}
565  private:
566  	CallTip *pct;
567  };
568  void ScintillaQt::CreateCallTipWindow(PRectangle rc)
569  {
570  	if (!ct.wCallTip.Created()) {
571  		QWidget *pCallTip = new CallTipImpl(&amp;ct);
572  		ct.wCallTip = pCallTip;
573  		pCallTip-&gt;move(rc.left, rc.top);
574  		pCallTip-&gt;resize(rc.Width(), rc.Height());
575  	}
576  }
577  void ScintillaQt::AddToPopUp(const char *label,
578                               int cmd,
579                               bool enabled)
580  {
581  	QMenu *menu = static_cast&lt;QMenu *&gt;(popup.GetID());
582  	QString text(label);
583  	if (text.isEmpty()) {
584  		menu-&gt;addSeparator();
585  	} else {
586  		QAction *action = menu-&gt;addAction(text);
587  		action-&gt;setData(cmd);
588  		action-&gt;setEnabled(enabled);
589  	}
590  	menu-&gt;disconnect();
591  	connect(menu, SIGNAL(triggered(QAction*)),
592  		this, SLOT(execCommand(QAction*)));
593  }
594  sptr_t ScintillaQt::WndProc(Message iMessage, uptr_t wParam, sptr_t lParam)
595  {
596  	try {
597  		switch (iMessage) {
598  		case Message::SetIMEInteraction:
599  			break;
600  		case Message::GrabFocus:
601  			scrollArea-&gt;setFocus(Qt::OtherFocusReason);
602  			break;
603  		case Message::GetDirectFunction:
604  			return reinterpret_cast&lt;sptr_t&gt;(DirectFunction);
605  		case Message::GetDirectStatusFunction:
606  			return reinterpret_cast&lt;sptr_t&gt;(DirectStatusFunction);
607  		case Message::GetDirectPointer:
608  			return reinterpret_cast&lt;sptr_t&gt;(this);
609  		case Message::SetRectangularSelectionModifier:
610  			rectangularSelectionModifier = static_cast&lt;int&gt;(wParam);
611  			break;
612  		case Message::GetRectangularSelectionModifier:
613  			return rectangularSelectionModifier;
614  		default:
615  			return ScintillaBase::WndProc(iMessage, wParam, lParam);
616  		}
617  	} catch (std::bad_alloc &amp;) {
618  		errorStatus = Status::BadAlloc;
619  	} catch (...) {
620  		errorStatus = Status::Failure;
621  	}
622  	return 0;
623  }
624  sptr_t ScintillaQt::DefWndProc(Message, uptr_t, sptr_t)
625  {
626  	return 0;
627  }
628  sptr_t ScintillaQt::DirectFunction(
629      sptr_t ptr, unsigned int iMessage, uptr_t wParam, sptr_t lParam)
630  {
631  	ScintillaQt *sci = reinterpret_cast&lt;ScintillaQt *&gt;(ptr);
632  	return sci-&gt;WndProc(static_cast&lt;Message&gt;(iMessage), wParam, lParam);
633  }
634  sptr_t ScintillaQt::DirectStatusFunction(
635      sptr_t ptr, unsigned int iMessage, uptr_t wParam, sptr_t lParam, int *pStatus)
636  {
637  	ScintillaQt *sci = reinterpret_cast&lt;ScintillaQt *&gt;(ptr);
638  	const sptr_t returnValue = sci-&gt;WndProc(static_cast&lt;Message&gt;(iMessage), wParam, lParam);
639  	*pStatus = static_cast&lt;int&gt;(sci-&gt;errorStatus);
640  	return returnValue;
641  }
642  void ScintillaQt::PartialPaint(const PRectangle &amp;rect)
643  {
644  	rcPaint = rect;
645  	paintState = PaintState::painting;
646  	PRectangle rcClient = GetClientRectangle();
647  	paintingAllText = rcPaint.Contains(rcClient);
648  	AutoSurface surfacePaint(this);
649  	Paint(surfacePaint, rcPaint);
650  	surfacePaint-&gt;Release();
651  	if (paintState == PaintState::abandoned) {
652  		paintState = PaintState::painting;
653  		paintingAllText = true;
<span onclick='openModal()' class='match'>654  		AutoSurface surface(this);
655  		Paint(surface, rcPaint);
656  		surface-&gt;Release();
657  		scrollArea-&gt;viewport()-&gt;update();
</span>658  	}
659  	paintState = PaintState::notPainting;
660  }
661  void ScintillaQt::DragEnter(const Point &amp;point)
662  {
663  	SetDragPosition(SPositionFromLocation(point,
664  					      false, false, UserVirtualSpace()));
665  }
666  void ScintillaQt::DragMove(const Point &amp;point)
667  {
668  	SetDragPosition(SPositionFromLocation(point,
669  					      false, false, UserVirtualSpace()));
670  }
671  void ScintillaQt::DragLeave()
672  {
673  	SetDragPosition(SelectionPosition(Sci::invalidPosition));
674  }
675  void ScintillaQt::Drop(const Point &amp;point, const QMimeData *data, bool move)
676  {
677  	QString text = data-&gt;text();
678  	bool rectangular = IsRectangularInMime(data);
679  	QByteArray bytes = BytesForDocument(text);
680  	int len = bytes.length();
681  	SelectionPosition movePos = SPositionFromLocation(point,
682  				false, false, UserVirtualSpace());
683  	DropAt(movePos, bytes, len, move, rectangular);
684  }
685  void ScintillaQt::DropUrls(const QMimeData *data)
686  {
687  	foreach(const QUrl &amp;url, data-&gt;urls()) {
688  		NotifyURIDropped(url.toString().toUtf8().constData());
689  	}
690  }
691  void ScintillaQt::timerEvent(QTimerEvent *event)
692  {
693  	for (size_t tr=static_cast&lt;size_t&gt;(TickReason::caret); tr&lt;=static_cast&lt;size_t&gt;(TickReason::dwell); tr++) {
694  		if (timers[tr] == event-&gt;timerId()) {
695  			TickFor(static_cast&lt;TickReason&gt;(tr));
696  		}
697  	}
698  }
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ScintillaQt.cpp</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from notepad-plus-plus-MDEwOlJlcG9zaXRvcnkzMzAxNDgxMQ==-flat-ScintillaQt.cpp</div>
                </div>
                <div class="column column_space"><pre><code>648  	AutoSurface surfacePaint(this);
649  	Paint(surfacePaint, rcPaint);
650  	surfacePaint-&gt;Release();
651  	if (paintState == PaintState::abandoned) {
</pre></code></div>
                <div class="column column_space"><pre><code>654  		AutoSurface surface(this);
655  		Paint(surface, rcPaint);
656  		surface-&gt;Release();
657  		scrollArea-&gt;viewport()-&gt;update();
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    