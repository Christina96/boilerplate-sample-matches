
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Code Files</title>
            <style>
                .column {
                    width: 47%;
                    float: left;
                    padding: 12px;
                    border: 2px solid #ffd0d0;
                }
        
                .modal {
                    display: none;
                    position: fixed;
                    z-index: 1;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    overflow: auto;
                    background-color: rgb(0, 0, 0);
                    background-color: rgba(0, 0, 0, 0.4);
                }
    
                .modal-content {
                    height: 250%;
                    background-color: #fefefe;
                    margin: 5% auto;
                    padding: 20px;
                    border: 1px solid #888;
                    width: 80%;
                }
    
                .close {
                    color: #aaa;
                    float: right;
                    font-size: 20px;
                    font-weight: bold;
                    text-align: right;
                }
    
                .close:hover, .close:focus {
                    color: black;
                    text-decoration: none;
                    cursor: pointer;
                }
    
                .row {
                    float: right;
                    width: 100%;
                }
    
                .column_space  {
                    white - space: pre-wrap;
                }
                 
                pre {
                    width: 100%;
                    overflow-y: auto;
                    background: #f8fef2;
                }
                
                .match {
                    cursor:pointer; 
                    background-color:#00ffbb;
                }
        </style>
    </head>
    <body>
        <h2>Tokens: 33, <button onclick='openModal()' class='match'>CODE CLONE</button></h2>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-flx.h</h3>
            <pre><code>1  class TMem;
2  class TChA;
3  class TStr;
4  class TCs{
5  private:
6    static const int MxMask;
7    int Val;
8  public:
9    TCs(): Val(0){}
10    TCs(const TCs&amp; Cs): Val(Cs.Val&amp;MxMask){}
11    TCs(const int&amp; Int): Val(Int&amp;MxMask){}
12    TCs&amp; operator=(const TCs&amp; Cs){Val=Cs.Val; return *this;}
13    bool operator==(const TCs&amp; Cs) const {return Val==Cs.Val;}
14    TCs&amp; TCs::operator+=(const TCs&amp; Cs){Val=(Val+Cs.Val)&amp;MxMask; return *this;}
15    TCs&amp; TCs::operator+=(const char&amp; Ch){Val=(Val+Ch)&amp;MxMask; return *this;}
16    TCs&amp; TCs::operator+=(const int&amp; Int){Val=(Val+Int)&amp;MxMask; return *this;}
17    int Get() const {return Val;}
18    static TCs GetCsFromBf(char* Bf, const int&amp; BfL);
19  };
20  class TSOutMnp {
21  public:
22    virtual TSOut&amp; operator()(TSOut&amp; SOut) const=0;
23  };
24  class TSBase{
25  protected:
26    TCRef CRef;
27    TSStr SNm;
28    TCs Cs;
29  protected:
30    TSBase(){}
31    TSBase(const TSBase&amp;);
32    TSBase&amp; operator=(const TSBase&amp;);
33  public:
34    TSBase(const TSStr&amp; Nm): SNm(Nm){}
35    virtual ~TSBase(){}
36    virtual TStr GetSNm() const;
37  };
38  class TSIn: virtual public TSBase{
39  private:
40    bool FastMode;
41  private:
42    TSIn(const TSIn&amp;);
43    TSIn&amp; operator=(const TSIn&amp;);
44  public:
45    TSIn(): TSBase(&quot;Input-Stream&quot;), FastMode(false){}
46    TSIn(const TStr&amp; Str);
47    virtual ~TSIn(){}
48    virtual bool Eof() const=0; 
49    virtual int Len() const=0; 
50    virtual char GetCh()=0; 
51    virtual char PeekCh()=0; 
52    virtual int GetBf(const void* Bf, const int&amp; BfL)=0;
53    bool IsFastMode() const {return FastMode;}
54    void SetFastMode(const bool&amp; _FastMode){FastMode=_FastMode;}
55    void LoadCs();
56    void LoadBf(const void* Bf, const int&amp; BfL){Cs+=GetBf(Bf, BfL);}
57    void* LoadNewBf(const int&amp; BfL){
58      void* Bf=(void*)new char[BfL]; Cs+=GetBf(Bf, BfL); return Bf;}
59    void Load(bool&amp; Bool){Cs+=GetBf(&amp;Bool, sizeof(Bool));}
60    void Load(uchar&amp; UCh){Cs+=GetBf(&amp;UCh, sizeof(UCh));}
61    void Load(char&amp; Ch){Cs+=GetBf(&amp;Ch, sizeof(Ch));}
62    void Load(short&amp; Short){Cs+=GetBf(&amp;Short, sizeof(Short));} 
63    void Load(ushort&amp; UShort){Cs+=GetBf(&amp;UShort, sizeof(UShort));} 
64    void Load(int&amp; Int){Cs+=GetBf(&amp;Int, sizeof(Int));}
65    void Load(uint&amp; UInt){Cs+=GetBf(&amp;UInt, sizeof(UInt));}
66    void Load(int64&amp; Int){Cs+=GetBf(&amp;Int, sizeof(Int));}
67    void Load(uint64&amp; UInt){Cs+=GetBf(&amp;UInt, sizeof(UInt));}
68    void Load(double&amp; Flt){Cs+=GetBf(&amp;Flt, sizeof(Flt));}
69    void Load(sdouble&amp; SFlt){Cs+=GetBf(&amp;SFlt, sizeof(SFlt));}
70    void Load(ldouble&amp; LFlt){Cs+=GetBf(&amp;LFlt, sizeof(LFlt));}
71    void Load(char*&amp; CStr, const int&amp; MxCStrLen, const int&amp; CStrLen){
72      CStr=new char[MxCStrLen+1]; Cs+=GetBf(CStr, CStrLen+1);}
73    void Load(char*&amp; CStr);
74    TSIn&amp; operator&gt;&gt;(bool&amp; Bool){Cs+=GetBf(&amp;Bool, sizeof(Bool)); return *this;}
75    TSIn&amp; operator&gt;&gt;(uchar&amp; UCh){Cs+=GetBf(&amp;UCh, sizeof(UCh)); return *this;}
76    TSIn&amp; operator&gt;&gt;(char&amp; Ch){Cs+=GetBf(&amp;Ch, sizeof(Ch)); return *this;}
77    TSIn&amp; operator&gt;&gt;(short&amp; Sh){Cs+=GetBf(&amp;Sh, sizeof(Sh)); return *this;}
78    TSIn&amp; operator&gt;&gt;(ushort&amp; USh){Cs+=GetBf(&amp;USh, sizeof(USh)); return *this;}
79    TSIn&amp; operator&gt;&gt;(int&amp; Int){Cs+=GetBf(&amp;Int, sizeof(Int)); return *this;}
80    TSIn&amp; operator&gt;&gt;(uint&amp; UInt){Cs+=GetBf(&amp;UInt, sizeof(UInt)); return *this;}
81    TSIn&amp; operator&gt;&gt;(int64&amp; Int){Cs+=GetBf(&amp;Int, sizeof(Int)); return *this;}
82    TSIn&amp; operator&gt;&gt;(uint64&amp; UInt){Cs+=GetBf(&amp;UInt, sizeof(UInt)); return *this;}
83    TSIn&amp; operator&gt;&gt;(float&amp; Flt){Cs+=GetBf(&amp;Flt, sizeof(Flt)); return *this;}
84    TSIn&amp; operator&gt;&gt;(double&amp; Double){Cs+=GetBf(&amp;Double, sizeof(Double)); return *this;}
85    TSIn&amp; operator&gt;&gt;(long double&amp; LDouble){Cs+=GetBf(&amp;LDouble, sizeof(LDouble)); return *this;}
86    static const TPt&lt;TSIn&gt; StdIn;
87    friend class TPt&lt;TSIn&gt;;
88  };
89  typedef TPt&lt;TSIn&gt; PSIn;
90  template &lt;class T&gt;
91  TSIn&amp; operator&gt;&gt;(TSIn&amp; SIn, T&amp; Val) {
92    Val.Load(SIn); return SIn;
93  }
94  class TSOut: virtual public TSBase{
95  private:
96    int MxLnLen, LnLen;
97    int UpdateLnLen(const int&amp; StrLen, const bool&amp; ForceInLn=false);
98  private:
99    TSOut(const TSIn&amp;);
100    TSOut&amp; operator = (const TSOut&amp;);
101  public:
102    TSOut(): TSBase(&quot;Output-Stream&quot;), MxLnLen(-1), LnLen(0){}
103    TSOut(const TStr&amp; Str);
104    virtual ~TSOut(){}
105    void EnableLnTrunc(const int&amp; _MxLnLen){MxLnLen=_MxLnLen;}
106    void DisableLnTrunc(){MxLnLen=-1;}
107    virtual int PutCh(const char&amp; Ch)=0;
108    virtual int PutBf(const void* LBf, const int&amp; LBfL)=0;
109    virtual void Flush()=0;
110    virtual TFileId GetFileId() const {return NULL;}
111    int PutMem(const TMem&amp; Mem);
112    int PutCh(const char&amp; Ch, const int&amp; Chs);
113    int PutBool(const bool&amp; Bool);
114    int PutInt(const int&amp; Int);
115    int PutInt(const int&amp; Int, char* FmtStr);
116    int PutUInt(const uint&amp; Int);
117    int PutUInt(const uint&amp; Int, char* FmtStr);
118    int PutFlt(const double&amp; Flt);
119    int PutFlt(const double&amp; Flt, char* FmtStr);
120    int PutStr(const char* CStr);
121    int PutStr(const TChA&amp; ChA);
122    int PutStr(const TStr&amp; Str, char* FmtStr);
123    int PutStr(const TStr&amp; Str, const bool&amp; ForceInLn=false);
124    int PutStrLn(const TStr&amp; Str, const bool&amp; ForceInLn=false){
125      int Cs=PutStr(Str,ForceInLn); Cs+=PutLn(); return Cs;}
126    int PutIndent(const int&amp; IndentLev=1);
127    int PutLn(const int&amp; Lns=1);
128    int PutDosLn(const int&amp; Lns=1);
129    int PutSep(const int&amp; NextStrLen=0);
130    int PutSepLn(const int&amp; Lns=0);
131    void SaveCs(){Cs+=PutBf(&amp;Cs, sizeof(Cs));}
132    void SaveBf(const void* Bf, const int&amp; BfL){Cs+=PutBf(Bf, BfL);}
133    void Save(const bool&amp; Bool){Cs+=PutBf(&amp;Bool, sizeof(Bool));}
134    void Save(const char&amp; Ch){Cs+=PutBf(&amp;Ch, sizeof(Ch));}
135    void Save(const uchar&amp; UCh){Cs+=PutBf(&amp;UCh, sizeof(UCh));}
136    void Save(const short&amp; Short){Cs+=PutBf(&amp;Short, sizeof(Short));}
137    void Save(const ushort&amp; UShort){Cs+=PutBf(&amp;UShort, sizeof(UShort));}
138    void Save(const int&amp; Int){Cs+=PutBf(&amp;Int, sizeof(Int));}
139    void Save(const uint&amp; UInt){Cs+=PutBf(&amp;UInt, sizeof(UInt));}
140    void Save(const int64&amp; Int){Cs+=PutBf(&amp;Int, sizeof(Int));}
141    void Save(const uint64&amp; UInt){Cs+=PutBf(&amp;UInt, sizeof(UInt));}
142    void Save(const double&amp; Flt){Cs+=PutBf(&amp;Flt, sizeof(Flt));}
143    void Save(const sdouble&amp; SFlt){Cs+=PutBf(&amp;SFlt, sizeof(SFlt));}
144    void Save(const ldouble&amp; LFlt){Cs+=PutBf(&amp;LFlt, sizeof(LFlt));}
145    void Save(const char* CStr, const int&amp; CStrLen){Cs+=PutBf(CStr, CStrLen+1);}
146    void Save(const char* CStr);
147    void Save(TSIn&amp; SIn, const int&amp; BfL=-1);
148    void Save(const PSIn&amp; SIn, const int&amp; BfL=-1){Save(*SIn, BfL);}
149    void Save(const void* Bf, const int&amp; BfL){Cs+=PutBf(Bf, BfL);}
150    TSOut&amp; operator&lt;&lt;(const bool&amp; Bool){Cs+=PutBf(&amp;Bool, sizeof(Bool)); return *this;}
151    TSOut&amp; operator&lt;&lt;(const uchar&amp; UCh){Cs+=PutBf(&amp;UCh, sizeof(UCh)); return *this;}
152    TSOut&amp; operator&lt;&lt;(const char&amp; Ch){Cs+=PutBf(&amp;Ch, sizeof(Ch)); return *this;}
153    TSOut&amp; operator&lt;&lt;(const short&amp; Sh){Cs+=PutBf(&amp;Sh, sizeof(Sh)); return *this;}
154    TSOut&amp; operator&lt;&lt;(const ushort&amp; USh){Cs+=PutBf(&amp;USh, sizeof(USh)); return *this;}
155    TSOut&amp; operator&lt;&lt;(const int&amp; Int){Cs+=PutBf(&amp;Int, sizeof(Int)); return *this;}
156    TSOut&amp; operator&lt;&lt;(const uint&amp; Int){Cs+=PutBf(&amp;Int, sizeof(Int)); return *this;}
157    TSOut&amp; operator&lt;&lt;(const int64&amp; Int){Cs+=PutBf(&amp;Int, sizeof(Int)); return *this;}
158    TSOut&amp; operator&lt;&lt;(const uint64&amp; UInt){Cs+=PutBf(&amp;UInt, sizeof(UInt)); return *this;}
159    TSOut&amp; operator&lt;&lt;(const float&amp; Flt){Cs+=PutBf(&amp;Flt, sizeof(Flt)); return *this;}
160    TSOut&amp; operator&lt;&lt;(const double&amp; Double){Cs+=PutBf(&amp;Double, sizeof(Double)); return *this;}
161    TSOut&amp; operator&lt;&lt;(const long double&amp; LDouble){Cs+=PutBf(&amp;LDouble, sizeof(LDouble)); return *this;}
162    TSOut&amp; operator&lt;&lt;(const TSOutMnp&amp; Mnp){return Mnp(*this);}
163    TSOut&amp; operator&lt;&lt;(TSOut&amp;(*FuncPt)(TSOut&amp;)){return FuncPt(*this);}
164    TSOut&amp; operator&lt;&lt;(TSIn&amp; SIn);
165    TSOut&amp; operator&lt;&lt;(PSIn&amp; SIn){return operator&lt;&lt;(*SIn);}
166    static const TPt&lt;TSOut&gt; StdOut;
167    friend class TPt&lt;TSOut&gt;;
168  };
169  typedef TPt&lt;TSOut&gt; PSOut;
170  template &lt;class T&gt;
171  TSOut&amp; operator&lt;&lt;(TSOut&amp; SOut, const T&amp; Val){
172    Val.Save(SOut); return SOut;
173  }
174  class TSInOut: public TSIn, public TSOut{
175  private:
176    TSInOut(const TSInOut&amp;);
177    TSInOut&amp; operator=(const TSInOut&amp;);
178  public:
179    TSInOut(): TSBase(&quot;Input-Output-Stream&quot;), TSIn(), TSOut() {}
180    virtual ~TSInOut(){}
<span onclick='openModal()' class='match'>181    virtual void SetPos(const int&amp; Pos)=0;
182    virtual void MovePos(const int&amp; DPos)=0;
183    virtual int GetPos() const=0;
184    virtual int GetSize() const=0; 
</span>185    virtual void Clr()=0; 
186    friend class TPt&lt;TSInOut&gt;;
187  };
188  typedef TPt&lt;TSInOut&gt; PSInOut;
189  class TStdIn: public TSIn{
190  private:
191    TStdIn(const TStdIn&amp;);
192    TStdIn&amp; operator=(const TStdIn&amp;);
193  public:
194    TStdIn(): TSBase(&quot;Standard input&quot;), TSIn() {}
195    bool Eof() const {return feof(stdin)!=0;}
196    int Len() const {return -1;}
197    char GetCh(){return char(getchar());}
198    char PeekCh(){
199      int Ch=getchar(); ungetc(Ch, stdin); return char(Ch);}
200    int GetBf(const void* LBf, const int&amp; LBfL);
201  };
202  class TStdOut: public TSOut{
203  private:
204    TStdOut(const TStdOut&amp;);
205    TStdOut&amp; operator=(const TStdOut&amp;);
206  public:
207    TStdOut(): TSBase(TSStr(&quot;Standard output&quot;)), TSOut(){}
208    int PutCh(const char&amp; Ch){putchar(Ch); return Ch;}
209    int PutBf(const void *LBf, const int&amp; LBfL);
210    void Flush(){fflush(stdout);}
211  };
212  class TFIn: public TSIn{
213  private:
214    static const int MxBfL;
215    TFileId FileId;
216    char* Bf;
217    int BfC, BfL;
218  public:
219    void SetFPos(const int&amp; FPos) const;
220    int GetFPos() const;
221    int GetFLen() const;
222  private:
223    void FillBf();
224  private:
225    TFIn();
226    TFIn(const TFIn&amp;);
227    TFIn&amp; operator=(const TFIn&amp;);
228  public:
229    TFIn(const TStr&amp; FNm);
230    TFIn(const TStr&amp; FNm, bool&amp; OpenedP);
231    static PSIn New(const TStr&amp; FNm);
232    static PSIn New(const TStr&amp; FNm, bool&amp; OpenedP);
233    ~TFIn();
234    bool Eof() const {return (BfC==BfL)&amp;&amp;(BfL&lt;MxBfL);}
235    int Len() const {return GetFLen()-(GetFPos()-BfL+BfC);}
236    char GetCh(){if (BfC==BfL){FillBf();} return Bf[BfC++];}
237    char PeekCh(){if (BfC==BfL){FillBf();} return Bf[BfC];}
238    int GetBf(const void* LBf, const int&amp; LBfL);
239  };
240  class TFOut: public TSOut{
241  private:
242    static const int MxBfL;
243    TFileId FileId;
244    char* Bf;
245    int BfL;
246  private:
247    void FlushBf();
248  private:
249    TFOut();
250    TFOut(const TFOut&amp;);
251    TFOut&amp; operator=(const TFOut&amp;);
252  public:
253    TFOut(const TStr&amp; _FNm, const bool&amp; Append=false);
254    TFOut(const TStr&amp; _FNm, const bool&amp; Append, bool&amp; OpenedP);
255    static PSOut New(const TStr&amp; FNm, const bool&amp; Append=false);
256    static PSOut New(const TStr&amp; FNm, const bool&amp; Append, bool&amp; OpenedP);
257    ~TFOut();
258    int PutCh(const char&amp; Ch);
259    int PutBf(const void* LBf, const int&amp; LBfL);
260    void Flush();
261    TFileId GetFileId() const {return FileId;}
262  };
263  typedef enum {faUndef, faCreate, faUpdate, faAppend, faRdOnly, faRestore} TFAccess;
264  class TFInOut : public TSInOut {
265  private:
266    TFileId FileId;
267  private:
268    TFInOut();
269    TFInOut(const TFIn&amp;);
270    TFInOut&amp; operator=(const TFIn&amp;);
271  public:
272    TFInOut(const TStr&amp; FNm, const TFAccess&amp; FAccess, const bool&amp; CreateIfNo);
273    static PSInOut New(const TStr&amp; FNm, const TFAccess&amp; FAccess, const bool&amp; CreateIfNo);
274    ~TFInOut() { if (FileId!=NULL) IAssert(fclose(FileId) == 0); }
275    TStr GetFNm() const;
276    TFileId GetFileId() const {return FileId;}
277    bool Eof() const { return feof(FileId) != 0; }
278    int Len() const { return GetSize() - GetPos(); } 
279    char GetCh() { return char(fgetc(FileId)); }
280    char PeekCh() { const char Ch = GetCh();  MovePos(-1);  return Ch; }
281    int GetBf(const void* LBf, const int&amp; LBfL);
282    void SetPos(const int&amp; Pos) { IAssert(fseek(FileId, Pos, SEEK_SET)==0); }
283    void MovePos(const int&amp; DPos) { IAssert(fseek(FileId, DPos, SEEK_CUR)==0); }
284    int GetPos() const { return ftell(FileId); }
285    int GetSize() const;
286    void Clr() { Fail; }
287    int PutCh(const char&amp; Ch) { return PutBf(&amp;Ch, sizeof(Ch)); }
288    int PutBf(const void* LBf, const int&amp; LBfL);
289    void Flush() { IAssert(fflush(FileId) == 0); }
290  };
291  class TMIn: public TSIn{
292  private:
293    char* Bf;
294    int BfC, BfL;
295    bool Free;
296  private:
297    TMIn();
298    TMIn(const TMIn&amp;);
299    TMIn&amp; operator=(const TMIn&amp;);
300  public:
301    TMIn(const void* _Bf, const int&amp; _BfL, const bool&amp; TakeBf=false, const bool&amp; _Free=true);
302    TMIn(TSIn&amp; SIn);
303    TMIn(const char* CStr);
304    TMIn(const TStr&amp; Str);
305    TMIn(const TChA&amp; ChA);
306    static PSIn New(const char* CStr);
307    static PSIn New(const TStr&amp; Str);
308    static PSIn New(const TChA&amp; ChA);
309    ~TMIn(){if (Bf!=NULL&amp;&amp;Free){delete[] Bf;}}
310    bool Eof() const {return BfC==BfL;}
311    int Len() const {return BfL-BfC;}
312    char GetCh();
313    char PeekCh();
314    int GetBf(const void* LBf, const int&amp; LBfL);
315    char* GetBfAddr(){return Bf;}
316  };
317  class TMOut: public TSOut{
318  private:
319    char* Bf;
320    int BfL, MxBfL;
321    bool OwnBf;
322    void Resize();
323  private:
324    TMOut(const TMOut&amp;);
325    TMOut&amp; operator=(const TMOut&amp;);
326  public:
327    TMOut(const int&amp; _MxBfL=1024);
328    static PSOut New(const int&amp; MxBfL=1024){
329      return PSOut(new TMOut(MxBfL));}
330    TMOut(char* _Bf, const int&amp; _MxBfL);
331    ~TMOut(){if (OwnBf&amp;&amp;(Bf!=NULL)){delete[] Bf;}}
332    int PutCh(const char&amp; Ch){if (BfL==MxBfL){
333      Resize();} return Bf[BfL++]=Ch;}
334    int PutBf(const void* LBf, const int&amp; LBfL);
335    void Flush(){}
336    int Len() const {return BfL;}
337    void Clr(){BfL=0;}
338    char GetCh(const int&amp; ChN) const {
339      IAssert((0&lt;=ChN)&amp;&amp;(ChN&lt;BfL)); return Bf[ChN];}
340    TStr GetAsStr() const;
341    void CutBf(const int&amp; CutBfL);
342    PSIn GetSIn(const bool&amp; IsCut=true, const int&amp; CutBfL=-1);
343    char* GetBfAddr() const {return Bf;}
344    bool IsCrLfLn() const;
345    TStr GetCrLfLn();
346    bool IsEolnLn() const;
347    TStr GetEolnLn(const bool&amp; DoAddEoln, const bool&amp; DoCutBf);
348    void MkEolnLn();
349  };
350  class TChRet{
351  private:
352    PSIn SIn;
353    char EofCh;
354    char Ch;
355  private:
356    TChRet();
357    TChRet(const TChRet&amp;);
358    TChRet&amp; operator=(const TChRet&amp;);
359  public:
360    TChRet(const PSIn&amp; _SIn, const char&amp; _EofCh=0):
361      SIn(_SIn), EofCh(_EofCh), Ch(_EofCh){}
362    bool Eof() const {return Ch==EofCh;}
363    char GetCh(){
364      if (SIn-&gt;Eof()){return Ch=EofCh;} else {return Ch=SIn-&gt;GetCh();}}
365    char operator()(){return Ch;}
366  };
367  ClassTP(TFRnd, PFRnd)
368  private:
369    TFileId FileId;
370    TSStr FNm;
371    bool RecAct;
372    int HdLen, RecLen;
373  private:
374    void RefreshFPos();
375  private:
376    TFRnd(const TFRnd&amp;);
377    TFRnd&amp; operator=(const TFRnd&amp;);
378  public:
379    TFRnd(const TStr&amp; _FNm, const TFAccess&amp; FAccess,
380     const bool&amp; CreateIfNo=true, const int&amp; _HdLen=-1, const int&amp; _RecLen=-1);
381    static PFRnd New(const TStr&amp; FNm,
382     const TFAccess&amp; FAccess, const bool&amp; CreateIfNo=true,
383     const int&amp; HdLen=-1, const int&amp; RecLen=-1){
384      return new TFRnd(FNm, FAccess, CreateIfNo, HdLen, RecLen);}
385    ~TFRnd();
386    TStr GetFNm() const;
387    void SetHdRecLen(const int&amp; _HdLen, const int&amp; _RecLen){
388      HdLen=_HdLen; RecLen=_RecLen; RecAct=(HdLen&gt;=0)&amp;&amp;(RecLen&gt;0);}
389    void SetFPos(const int&amp; FPos);
390    void MoveFPos(const int&amp; DFPos);
391    int GetFPos();
392    int GetFLen();
393    bool Empty(){return GetFLen()==0;}
394    bool Eof(){return GetFPos()==GetFLen();}
395    void SetRecN(const int&amp; RecN);
396    int GetRecN();
397    int GetRecs();
398    void GetBf(void* Bf, const int&amp; BfL);
399    void PutBf(const void* Bf, const int&amp; BfL);
400    void Flush();
401    void GetHd(void* Hd){IAssert(RecAct);
402      int FPos=GetFPos(); SetFPos(0); GetBf(Hd, HdLen); SetFPos(FPos);}
403    void PutHd(const void* Hd){IAssert(RecAct);
404      int FPos=GetFPos(); SetFPos(0); PutBf(Hd, HdLen); SetFPos(FPos);}
405    void GetRec(void* Rec, const int&amp; RecN=-1){
406      IAssert(RecAct); if (RecN!=-1){SetRecN(RecN);} GetBf(Rec, RecLen);}
407    void PutRec(const void* Rec, const int&amp; RecN=-1){
408      IAssert(RecAct); if (RecN!=-1){SetRecN(RecN);} PutBf(Rec, RecLen);}
409    void PutCs(const TCs&amp; Cs){PutBf(&amp;Cs, sizeof(Cs));}
410    TCs GetCs(){TCs Cs; GetBf(&amp;Cs, sizeof(Cs)); return Cs;}
411    void PutCh(const char&amp; Ch){PutBf(&amp;Ch, sizeof(Ch));}
412    void PutCh(const char&amp; Ch, const int&amp; Chs);
413    char GetCh(){char Ch; GetBf(&amp;Ch, sizeof(Ch)); return Ch;}
414    void PutUCh(const uchar&amp; UCh){PutBf(&amp;UCh, sizeof(UCh));}
415    uchar GetUCh(){uchar UCh; GetBf(&amp;UCh, sizeof(UCh)); return UCh;}
416    void PutInt(const int&amp; Int){PutBf(&amp;Int, sizeof(Int));}
417    int GetInt(){int Int; GetBf(&amp;Int, sizeof(Int)); return Int;}
418    void PutUInt(const uint&amp; UInt){PutBf(&amp;UInt, sizeof(UInt));}
419    uint GetUInt(){uint UInt; GetBf(&amp;UInt, sizeof(UInt)); return UInt;}
420    void PutStr(const TStr&amp; Str);
421    TStr GetStr(const int&amp; StrLen);
422    TStr GetStr(const int&amp; MxStrLen, bool&amp; IsOk);
423    void PutSIn(const PSIn&amp; SIn, TCs&amp; Cs);
424    PSIn GetSIn(const int&amp; SInLen, TCs&amp; Cs);
425    static TStr GetStrFromFAccess(const TFAccess&amp; FAccess);
426    static TFAccess GetFAccessFromStr(const TStr&amp; Str);
427  };
428  class TFile{
429  public:
430    static const TStr TxtFExt;
431    static const TStr HtmlFExt;
432    static const TStr HtmFExt;
433    static const TStr GifFExt;
434    static const TStr JarFExt;
435  public:
436    static bool Exists(const TStr&amp; FNm);
437    static void Del(const TStr&amp; FNm, const bool&amp; ThrowExceptP=true);
438    static void DelWc(const TStr&amp; WcStr, const bool&amp; RecurseDirP=false);
439    static void Rename(const TStr&amp; SrcFNm, const TStr&amp; DstFNm);
440    static TStr GetUniqueFNm(const TStr&amp; FNm);
441  };
</code></pre>
        </div>
        <div class="column">
            <h3>snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-graph.h</h3>
            <pre><code>1  #ifndef graph_h
2  #define graph_h
3  #include &quot;base.h&quot;
4  #include &quot;gks.h&quot;
5  ClassHdTPV(TGraph, PGraph, TGraphV)
6  ClassTPV(TVrtx, PVrtx, TVrtxV)
7  protected: 
8    static TStr VIdNm;
9    static TStr PpNm;
10    static TStr VNmNm;
11    static TStr DNmNm;
12    static TStr BriefNm;
13    static TStr MarkNm;
14    static TStr WgtNm;
15    static TStr HitsHubWNm;
16    static TStr HitsAuthWNm;
17    static TStr PageRankWNm;
18    static TStr XNm;
19    static TStr YNm;
20    static TStr ZNm;
21    static TStr ColorNm;
22    static TStr ShapeNm;
23    static TStr RectNm;
24    static TStr RectX1Nm, X1Nm;
25    static TStr RectY1Nm, Y1Nm;
26    static TStr RectX2Nm, X2Nm;
27    static TStr RectY2Nm, Y2Nm;
28    static TStr DmNm;
29  private:
30    UndefCopyAssign(TVrtx);
31  public:
32    TVrtx(){}
33    virtual ~TVrtx(){}
34    TVrtx(TSIn&amp;){Fail;}
35    static PVrtx Load(TSIn&amp;){Fail; return NULL;}
36    void Save(TSOut&amp;){Fail;}
37    bool operator==(TVrtx&amp;){Fail; return false;}
38    virtual void DefVrtx(const PGraph&amp; Graph)=0;
39    virtual int GetVId() const=0;
40    virtual PPp GetPp() const=0;
41    virtual TStr GetVNm() const=0;
42    virtual void PutDNm(const TStr&amp; DNm){ GetPp()-&gt;PutValStr(DNmNm, DNm); }
43    virtual TStr GetDNm() const {return GetPp()-&gt;GetValStr(DNmNm);}
44    virtual void PutBrief(const int&amp; Brief){GetPp()-&gt;PutValInt(BriefNm, Brief);}
45    virtual int GetBrief() const {return GetPp()-&gt;GetValInt(BriefNm);}
46    virtual bool IsMark() const {return GetPp()-&gt;GetValInt(MarkNm)!=0;}
47    virtual void ClrMark(){GetPp()-&gt;PutValInt(MarkNm, 0);}
48    virtual void SetMark(){GetPp()-&gt;PutValInt(MarkNm, 1);}
49    virtual int GetMark() const {return GetPp()-&gt;GetValInt(MarkNm);}
50    virtual void PutMark(const int&amp; Mark){GetPp()-&gt;PutValInt(MarkNm, Mark);}
51    virtual void PutWgt(const double&amp; Wgt){GetPp()-&gt;PutValFlt(WgtNm, Wgt);}
52    virtual double GetWgt() const {return GetPp()-&gt;GetValFlt(WgtNm);}
53    virtual void PutHitsHubW(const double&amp; HitsHubW){GetPp()-&gt;PutValFlt(HitsHubWNm, HitsHubW);}
54    virtual double GetHitsHubW() const {return GetPp()-&gt;GetValFlt(HitsHubWNm);}
55    virtual void PutHitsAuthW(const double&amp; HitsAuthW){GetPp()-&gt;PutValFlt(HitsAuthWNm, HitsAuthW);}
56    virtual double GetHitsAuthW() const {return GetPp()-&gt;GetValFlt(HitsAuthWNm);}
57    virtual void PutPageRankW(const double&amp; PageRankW){GetPp()-&gt;PutValFlt(PageRankWNm, PageRankW);}
58    virtual double GetPageRankW() const {return GetPp()-&gt;GetValFlt(PageRankWNm);}
59    virtual void PutX(const double&amp; X){GetPp()-&gt;PutValFlt(XNm, X);}
60    virtual double GetX() const {return GetPp()-&gt;GetValFlt(XNm);}
61    virtual void PutY(const double&amp; Y){GetPp()-&gt;PutValFlt(YNm, Y);}
62    virtual double GetY() const {return GetPp()-&gt;GetValFlt(YNm);}
63    virtual void PutZ(const double&amp; Z){GetPp()-&gt;PutValFlt(ZNm, Z);}
64    virtual double GetZ() const {return GetPp()-&gt;GetValFlt(ZNm);}
65    virtual void PutXY(const double&amp; X, const double&amp; Y){PutX(X); PutY(Y);}
66    virtual void PutColor(const int&amp; Color){GetPp()-&gt;PutValInt(ColorNm, Color);}
67    virtual int GetColor() const {return GetPp()-&gt;GetValInt(ColorNm);}
68    virtual void PutShape(const TStr&amp; Shape){GetPp()-&gt;PutValStr(ShapeNm, Shape);}
69    virtual TStr GetShape() const {return GetPp()-&gt;GetValStr(ShapeNm);}
70    virtual void PutRect(const TGksRect&amp; Rect);
71    virtual TGksRect GetRect() const;
72    virtual bool IsInRect(const double&amp; X, const double&amp; Y) const;
<span onclick='openModal()' class='match'>73    virtual void DelEId(const int&amp; EId)=0;
74    virtual void AddInEId(const int&amp; EId)=0;
75    virtual int GetInEIds() const=0;
76    virtual int GetInEId(const int&amp; InEIdN) const=0;
</span>77    virtual bool NoInEIds() const {return GetInEIds()==0;}
78    virtual void AddOutEId(const int&amp; EId)=0;
79    virtual int GetOutEIds() const=0;
80    virtual int GetOutEId(const int&amp; OutEIdN) const=0;
81    virtual bool NoOutEIds() const {return GetOutEIds()==0;}
82    virtual PPp GetDmPp(){return GetPp()-&gt;GetPp(DmNm);}
83    static PPp GetDrawPp();
84    static PVrtx LoadXml(const PXmlTok&amp; XmlTok);
85    PXmlTok GetXmlTok() const;
86    static PVrtx LoadTxt(TILx&amp; Lx);
87    void SaveTxt(TOLx&amp; Lx) const;
88  };
89  class TGVrtx: public TVrtx{
90  private:
91    TInt VId;
92    TStr VNm;
93    TStr DNm;
94    TInt Brief;
95    TInt Mark;
96    TFlt Wgt, HitsHubW, HitsAuthW, PageRankW;
97    TFlt X, Y, Z;
98    TInt Color;
99    TStr Shape;
100    TGksRect Rect;
101    PPp Pp;
102    TIntV InEIdV;
103    TIntV OutEIdV;
104  public:
105    TGVrtx(const int&amp; _VId=-1, const TStr&amp; _VNm=TStr(), const PPp&amp; _Pp=NULL):
106      TVrtx(), VId(_VId), VNm(_VNm), DNm(TStr()), Brief(0), Mark(0),
107      Wgt(0), HitsHubW(0), HitsAuthW(0), PageRankW(0),
108      X(0), Y(0), Z(0),
109      Color(), Shape(), Rect(),
110      Pp(_Pp), InEIdV(), OutEIdV(){}
111    TGVrtx(const TStr&amp; _VNm, const PPp&amp; _Pp=NULL):
112      TVrtx(), VId(-1), VNm(_VNm), DNm(TStr()), Brief(0), Mark(0),
113      Wgt(0), HitsHubW(0), HitsAuthW(0), PageRankW(0),
114      X(0), Y(0), Z(0),
115      Color(), Shape(), Rect(),
116      Pp(_Pp), InEIdV(), OutEIdV(){}
117    static PVrtx New(const TStr&amp; VNm, const PPp&amp; Pp=NULL){
118      return new TGVrtx(VNm, Pp);}
119    static PVrtx New(const int&amp; VId, const TStr&amp; VNm, const PPp&amp; Pp=NULL){
120      return new TGVrtx(VId, VNm, Pp);}
121    virtual ~TGVrtx(){}
122    TGVrtx(TSIn&amp;){Fail;}
123    void Save(TSOut&amp;){Fail;}
124    virtual void DefVrtx(const PGraph&amp; Graph);
125    virtual int GetVId() const {return VId;}
126    virtual PPp GetPp() const { return Pp;}
127    virtual TStr GetVNm() const {
128      if (VNm.Empty()){return TStr(&#x27;V&#x27;)+TInt::GetStr(VId);} else {return VNm;}}
129    virtual TStr GetDNm() const { return DNm; }
130    virtual void PutDNm(const TStr&amp; _DNm) { DNm = _DNm; }
131    virtual int GetBrief() const { return Brief; }
132    virtual void PutBrief(const int&amp; _Brief) { Brief = _Brief; }
133    virtual bool IsMark() const {return Mark!=0;}
134    virtual void ClrMark(){Mark=0;}
135    virtual void SetMark(){Mark=1;}
136    virtual int GetMark() const {return Mark;}
137    virtual void PutMark(const int&amp; _Mark){Mark=_Mark;}
138    virtual double GetWgt() const {return Wgt;}
139    virtual void PutWgt(const double&amp; _Wgt){Wgt=_Wgt;}
140    virtual double GetHitsHubW() const {return HitsHubW;}
141    virtual void PutHitsHubW(const double&amp; _HitsHubW){HitsHubW=_HitsHubW;}
142    virtual double GetHitsAuthW() const {return HitsAuthW;}
143    virtual void PutHitsAuthW(const double&amp; _HitsAuthW){HitsAuthW=_HitsAuthW;}
144    virtual double GetPageRankW() const {return PageRankW;}
145    virtual void PutPageRankW(const double&amp; _PageRankW){PageRankW=_PageRankW;}
146    virtual void PutX(const double&amp; _X){X=_X;}
147    virtual double GetX() const {return X;}
148    virtual void PutY(const double&amp; _Y){Y=_Y;}
149    virtual double GetY() const {return Y;}
150    virtual void PutZ(const double&amp; _Z){Z=_Z;}
151    virtual double GetZ() const {return Z;}
152    virtual void PutXY(const double&amp; _X, const double&amp; _Y){X=_X; Y=_Y;}
153    virtual void PutColor(const int&amp; _Color){Color=_Color;}
154    virtual int GetColor() const {return Color;}
155    virtual void PutShape(const TStr&amp; _Shape){Shape=_Shape;}
156    virtual TStr GetShape() const {return ShapeNm;}
157    virtual void PutRect(const TGksRect&amp; _Rect){Rect=_Rect;}
158    virtual TGksRect GetRect() const {return Rect;}
159    virtual bool IsInRect(const double&amp; X, const double&amp; Y) const {
160      return Rect.IsIn(X, Y);}
161    void DelEId(const int&amp; EId){InEIdV.DelIfIn(EId); OutEIdV.DelIfIn(EId);}
162    virtual void AddInEId(const int&amp; EId){InEIdV.Add(EId);}
163    virtual int GetInEIds() const {return InEIdV.Len();}
164    virtual int GetInEId(const int&amp; InEIdN) const {return InEIdV[InEIdN];}
165    virtual void AddOutEId(const int&amp; EId){OutEIdV.Add(EId);}
166    virtual int GetOutEIds() const {return OutEIdV.Len();}
167    virtual int GetOutEId(const int&amp; OutEIdN) const {return OutEIdV[OutEIdN];}
168  };
169  ClassTPV(TEdge, PEdge, TEdgeV)
170  protected: 
171    static TStr EIdNm;
172    static TStr VId1Nm;
173    static TStr VId2Nm;
174    static TStr PpNm;
175    static TStr DirPNm;
176    static TStr ENmNm;
177    static TStr MarkNm;
178    static TStr WgtNm;
179    static TStr WidthNm;
180    static TStr DNmNm;
181    static TStr BriefNm;
182    static TStr RectNm;
183    static TStr RectX1Nm, X1Nm;
184    static TStr RectY1Nm, Y1Nm;
185    static TStr RectX2Nm, X2Nm;
186    static TStr RectY2Nm, Y2Nm;
187    static TStr DmNm;
188  private:
189    UndefCopyAssign(TEdge);
190  public:
191    TEdge(){}
192    virtual ~TEdge(){}
193    TEdge(TSIn&amp;){Fail;}
194    static PEdge Load(TSIn&amp;){Fail; return NULL;}
195    void Save(TSOut&amp;){Fail;}
196    bool operator==(TEdge&amp;){Fail; return false;}
197    virtual void DefEdge(const PGraph&amp; Graph)=0;
198    virtual int GetEId() const=0;
199    virtual int GetVId1() const=0;
200    virtual int GetVId2() const=0;
201    virtual int GetInVId() const {IAssert(IsDir()); return GetVId1();}
202    virtual int GetOutVId() const {IAssert(IsDir()); return GetVId2();}
203    virtual int GetOtherVId(const PVrtx&amp; Vrtx) const {
204      if (Vrtx-&gt;GetVId()==GetVId1()){return GetVId2();} else {return GetVId1();}}
205    virtual bool IsDir() const=0;
206    virtual TStr GetENm() const=0;
207    virtual PPp GetPp() const=0;
208    virtual bool IsMark() const=0;
209    virtual void ClrMark()=0;
210    virtual void SetMark()=0;
211    virtual int GetMark() const=0;
212    virtual void PutMark(const int&amp; _Mark)=0;
213    virtual double GetWgt() const=0;
214    virtual void PutWgt(const double&amp; _Wgt)=0;
215    virtual int GetWidth() const=0;
216    virtual void PutWidth(const double&amp; _Width)=0;
217    virtual void PutDNm(const TStr&amp; DNm){GetPp()-&gt;PutValStr(DNmNm, DNm);}
218    virtual TStr GetDNm() const {return GetPp()-&gt;GetValStr(DNmNm);}
219    virtual void PutBrief(const int&amp; Brief){GetPp()-&gt;PutValInt(BriefNm, Brief);}
220    virtual int GetBrief() const {return GetPp()-&gt;GetValInt(BriefNm);}
221    virtual void PutRect(const TGksRect&amp; Rect);
222    virtual TGksRect GetRect() const;
223    virtual bool IsInRect(const double&amp; X, const double&amp; Y) const;
224    virtual PPp GetDmPp(){return GetPp()-&gt;GetPp(DmNm);}
225    static PPp GetDrawPp();
226    static PEdge LoadXml(const PXmlTok&amp; XmlTok);
227    PXmlTok GetXmlTok() const;
228    static PEdge LoadTxt(TILx&amp; Lx);
229    void SaveTxt(TOLx&amp; Lx) const;
230  };
231  class TGEdge: public TEdge{
232  private:
233    TInt EId;
234    TInt VId1;
235    TInt VId2;
236    TBool DirP;
237    TStr ENm;
238    TStr DNm; 
239    TInt Mark;
240    TFlt Wgt;
241    TInt Width;
242    PPp Pp;
243  public:
244    TGEdge(const int&amp; _EId, const int&amp; _VId1, const int&amp; _VId2,
245     const bool&amp; _DirP, const TStr&amp; _ENm=TStr(), const PPp&amp; _Pp=NULL);
246    TGEdge(const PVrtx&amp; Vrtx1, const PVrtx&amp; Vrtx2,
247     const TStr&amp; _ENm=TStr(), const bool&amp; _DirP=true, const PPp&amp; _Pp=NULL);
248    static PEdge New(const PVrtx&amp; Vrtx1, const PVrtx&amp; Vrtx2,
249     const TStr&amp; ENm=TStr(), const bool&amp; DirP=true, const PPp&amp; Pp=NULL){
250      return new TGEdge(Vrtx1, Vrtx2, ENm, DirP, Pp);}
251    virtual ~TGEdge(){}
252    TGEdge(TSIn&amp;){Fail;}
253    static PEdge Load(TSIn&amp;){Fail; return NULL;}
254    void Save(TSOut&amp;){Fail;}
255    virtual void DefEdge(const PGraph&amp; Graph);
256    virtual int GetEId() const {return EId;}
257    virtual int GetVId1() const {return VId1;}
258    virtual int GetVId2() const {return VId2;}
259    virtual bool IsDir() const {return DirP;}
260    virtual TStr GetENm() const {
261      if (ENm.Empty()){return TStr(&#x27;E&#x27;)+TInt::GetStr(EId);} else {return ENm;}}
262    virtual PPp GetPp() const {return Pp;}
263    virtual bool IsMark() const {return Mark!=0;}
264    virtual void ClrMark(){Mark=0;}
265    virtual void SetMark(){Mark=1;}
266    virtual int GetMark() const {return Mark;}
267    virtual void PutMark(const int&amp; _Mark){Mark=_Mark;}
268    virtual double GetWgt() const {return Wgt;}
269    virtual void PutWgt(const double&amp; _Wgt){Wgt=_Wgt;}
270    virtual TStr GetDNm() const { return DNm; }
271    virtual void PutDNm(const TStr&amp; _DNm) { DNm = _DNm; }
272    virtual int GetWidth() const {return Width;}
273    virtual void PutWidth(const double&amp; _Width){Width=int(_Width);}
274  };
275  ClassTPV(TGraph, PGraph, TGraphV)
276  public: 
277    static TStr PpNm;
278    static TStr VrtxNm;
279    static TStr EdgeNm;
280    static TStr GNmNm;
281    static TStr DNmNm;
282    static TStr BriefNm;
283  protected: 
284    typedef PGraph (*TGraphNew)();
285    typedef TFunc&lt;TGraphNew&gt; TGraphNewF;
286    static THash&lt;TStr, TGraphNewF&gt; TypeToNewFH;
287    typedef PGraph (*TGraphLoad)(TSIn&amp; SIn);
288    typedef TFunc&lt;TGraphLoad&gt; TGraphLoadF;
289    static THash&lt;TStr, TGraphLoadF&gt; TypeToLoadFH;
290  private:
291    UndefCopyAssign(TGraph);
292  public: 
293    TInt LastVId;
294    TInt LastEId;
295    int GetNewVId() const {return LastVId;}
296    int GetNewEId() const {return LastEId;}
297    void DefVId(const int&amp; VId){if (VId&gt;=LastVId){LastVId=VId+1;}}
298    void DefEId(const int&amp; EId){if (EId&gt;=LastEId){LastEId=EId+1;}}
299  public:
300    TGraph(): LastVId(0), LastEId(0){}
301    virtual ~TGraph(){}
302    static PGraph New(const TStr&amp; TypeNm=TStr());
303    TGraph(TSIn&amp;){Fail;}
304    static PGraph Load(TSIn&amp; SIn);
305    void Save(TSOut&amp;){Fail;}
306    static bool Reg(
307     const TStr&amp; TypeNm, const TGraphNewF&amp; NewF, const TGraphLoadF&amp; LoadF);
308    virtual TStr GetTypeNm() const=0;
309    virtual void Defrag()=0;
310    virtual PPp GetPp() const=0;
311    virtual int AddPp(const PPp&amp; Pp)=0;
312    virtual int GetPps() const=0;
313    virtual PPp GetPp(const int&amp; PpN) const=0;
314    virtual int AddVrtx(const PVrtx&amp; Vrtx)=0;
315    virtual void DelVrtx(const int&amp; VId)=0;
316    virtual void DelVrtx(const PVrtx&amp; Vrtx)=0;
317    virtual int GetVrtxs() const=0;
318    virtual PVrtx GetVrtx(const int&amp; VId) const=0;
319    virtual PVrtx GetVrtx(const TStr&amp; VNm) const=0;
320    virtual PVrtx GetRndVrtx(TRnd&amp; Rnd) const=0;
321    bool IsVrtx(const TStr&amp; VNm) const {
322      PVrtx Vrtx; return IsVrtx(VNm, Vrtx);}
323    virtual bool IsVrtx(const TStr&amp; VNm, PVrtx&amp; Vrtx) const=0;
324    virtual int FFirstVrtx() const=0;
325    virtual bool FNextVrtx(int&amp; VrtxP, PVrtx&amp; Vrtx) const=0;
326    virtual void ClrVrtxMarks() const=0;
327    virtual int AddEdge(const PEdge&amp; Edge)=0;
328    virtual void DelEdge(const int&amp; EId)=0;
329    virtual void DelEdge(const PEdge&amp; Edge)=0;
330    virtual int GetEdges() const=0;
331    virtual PEdge GetEdge(const int&amp; EId) const=0;
332    virtual PEdge GetEdge(const TStr&amp; ENm) const=0;
333    virtual bool IsEdge(const TStr&amp; ENm, PEdge&amp; Edge) const=0;
334    virtual int FFirstEdge() const=0;
335    virtual bool FNextEdge(int&amp; EdgeP, PEdge&amp; Edge) const=0;
336    virtual bool IsVrtxsEdge(
337     const int&amp; VId1, const int&amp; VId2, const bool&amp; DirP, PEdge&amp; Edge) const=0;
338    bool IsVrtxsEdge(
339     const int&amp; VId1, const int&amp; VId2, const bool&amp; DirP) const {
340      PEdge Edge; return IsVrtxsEdge(VId1, VId2, DirP, Edge);}
341    virtual void PutGNm(const TStr&amp; GNm){GetPp()-&gt;PutValStr(GNmNm, GNm);}
342    virtual TStr GetGNm() const {return GetPp()-&gt;GetValStr(GNmNm);}
343    virtual void PutDNm(const TStr&amp; DNm){GetPp()-&gt;PutValStr(DNmNm, DNm);}
344    virtual TStr GetDNm() const {return GetPp()-&gt;GetValStr(DNmNm);}
345    virtual void PutBrief(const int&amp; Brief){GetPp()-&gt;PutValInt(BriefNm, Brief);}
346    virtual int GetBrief() const {return GetPp()-&gt;GetValInt(BriefNm);}
347    void _GetMnMxXY(double&amp; MnX, double&amp; MnY, double&amp; MxX, double&amp; MxY) const;
348    void _AddBorders(const double&amp; BorderFac,
349     double&amp; MnX, double&amp; MnY, double&amp; MxX, double&amp; MxY) const;
350    void RescaleXY(const double&amp; BorderFac, const PVrtx&amp; CenterVrtx=NULL) const;
351    void RescaleXY(const double&amp; MnX, const double&amp; MnY,
352     const double&amp; MxX, const double&amp; MxY) const;
353    virtual int _IsEdgeXYInts(
354     const PVrtx&amp; Vrtx0, const PVrtx&amp; Vrtx1, const PVrtx&amp; Vrtx2) const;
355    virtual bool IsEdgeXYInts(const PEdge&amp; Edge1, const PEdge&amp; Edge2) const;
356    virtual double GetVrtxXYLen(const PVrtx&amp; Vrtx1, const PVrtx&amp; Vrtx2) const;
357    virtual double GetEdgeXYLen(const PEdge&amp; Edge) const;
358    virtual double GetSumEdgeXYLen() const;
359    virtual void PlaceRndXY(TRnd&amp; Rnd) const;
360    virtual void PlaceBestRndXY(const int&amp; Tries, TRnd&amp; Rnd) const;
361    virtual double GetSimAnnXYEnergy(
362     const double&amp; NodeDistrWgt, const double&amp; BorderWgt,
363     const double&amp; EdgeLenWgt, const double&amp; EdgeCrossWgt,
364     const double&amp; NodeEdgeDistWgt, const bool&amp; UseNodeEdgeDist) const;
365    virtual double GetSimAnnXYEnergy(
366     const PXmlDoc&amp; CfgXmlDoc=NULL, const bool&amp; UseNodeEdgeDist=true) const;
367    virtual void PlaceSimAnnXY(
368     TRnd&amp; Rnd, const PGks&amp; Gks=NULL,
369     const PXmlDoc&amp; CfgXmlDoc=NULL, const PNotify&amp; Notify=NULL,
370     const int&amp; _TempStages=100, const int&amp; _TempStageTrys=100,
371     const int&amp; Secs=-1) const;
372    virtual void PlaceFineTuning(
373     TRnd&amp; Rnd, const PGks&amp; Gks, const PNotify&amp; Notify=NULL,
374     const int&amp; Secs=-1) const;
375    virtual void PlaceCircle() const;
376    virtual void PlaceTreeAsStar(
377     const PVrtx&amp; HomeVrtx, const int&amp; Lev,
378     const double&amp; HomeX, const double&amp; HomeY,
379     const double&amp; MnAng, const double&amp; MxAng) const;
380    virtual void PlaceTreeAsStar() const;
381    virtual void PlaceGraphAsStar(
382     const PVrtx&amp; HomeVrtx, const TStr&amp; DrawENm) const;
383    virtual void SetEdgeWidth(const int&amp; Intvs) const;
384    virtual void Draw(const PGks&amp; Gks, const bool&amp; SimpleP=false,
385     const bool&amp; DrawEdgesP=true, const int&amp; FontSize=8, 
386     const int&amp; EdgeFontSize=8, const int&amp; MxLnLen=-1) const;
387    virtual void _DrawTxtTree(const PVrtx&amp; Vrtx, TChAV&amp; LnV) const;
388    virtual void DrawTxtTree(const PSOut&amp; SOut) const;
389    virtual void DrawTxtTree(const TStr&amp; FNm) const {
390      PSOut SOut=TFOut::New(FNm); DrawTxtTree(SOut);}
391    virtual bool IsVrtxAt(
392     const PGks&amp; Gks, const int&amp; X, const int&amp; Y, PVrtx&amp; Vrtx) const;
393    virtual bool IsEdgeAt(
394     const PGks&amp; Gks, const int&amp; X, const int&amp; Y, PEdge&amp; Edge) const;
395    virtual bool IsDir() const;
396    virtual bool _IsDag(const PVrtx&amp; Vrtx, const int&amp; Mark) const;
397    virtual bool IsDag() const;
398    virtual bool IsTree(PVrtx&amp; RootVrtx) const;
399    virtual PVrtx GetTreeRoot() const {
400      PVrtx RootVrtx; IAssert(IsTree(RootVrtx)); return RootVrtx;}
401    virtual void GetLeafVIdV(const int&amp; RootVId, TIntV&amp; VIdV) const;
402    virtual void GetHitsW() const;
403    virtual void GetTopHitsVrtxV(TVrtxV&amp; TopHubVrtxV, TVrtxV&amp; TopAuthVrtxV) const;
404    virtual void GetConnVrtxV(PVrtx&amp; RootVrtx, TVrtxV&amp; ConnVrtxV) const;
405    static PGraph GetRndGraph(
406     TRnd&amp; Rnd, const int&amp; Vrtxs, const int&amp; Edges,
407     const bool&amp; DirEdgeP=true, const int&amp; EdgeToSameVrtxP=false);
408    static PGraph LoadXml(const PXmlDoc&amp; XmlDoc, const TStr&amp; TypeNm=TStr());
409    static PGraph LoadXml(const PSIn&amp; SIn, const TStr&amp; TypeNm=TStr()){
410      PXmlDoc XmlDoc=TXmlDoc::LoadTxt(SIn); return LoadXml(XmlDoc, TypeNm);}
411    static PGraph LoadXml(const TStr&amp; FNm, const TStr&amp; TypeNm=TStr()){
412      PSIn SIn=TFIn::New(FNm); return LoadXml(SIn, TypeNm);}
413    PXmlDoc GetXmlDoc() const;
414    void SaveXml(const PSOut&amp; SOut) const {
415      PXmlDoc XmlDoc=GetXmlDoc(); XmlDoc-&gt;SaveTxt(SOut);}
416    void SaveXml(const TStr&amp; FNm) const {
417      PSOut SOut=TFOut::New(FNm); SaveXml(SOut);}
418    static const TStr FExt;
419    static const TStr HitsFExt;
420    static const TStr PageRankFExt;
421    static PGraph LoadTxt(const PSIn&amp; SIn, const TStr&amp; TypeNm=TStr());
422    static PGraph LoadTxt(const TStr&amp; FNm, const TStr&amp; TypeNm=TStr()){
423      PSIn SIn=TFIn::New(FNm); return LoadTxt(SIn, TypeNm);}
424    void SaveTxt(const PSOut&amp; SOut) const;
425    void SaveTxt(const TStr&amp; FNm) const {
426      PSOut SOut=TFOut::New(FNm); SaveTxt(SOut);}
427    void SaveTxtTab(const TStr&amp; FNm) const;
428    void SaveTxtPajek(const TStr&amp; FNm) const;
429    void SaveTxtMatlab(const TStr&amp; FNm) const;
430    void SaveTxtHits(const TStr&amp; FNm, const int&amp; TopN=-1) const;
431    void _SaveTxtSparseNbrs(const int&amp; SrcVId,
432     const int&amp; Lev, const int&amp; MxLev, TIntFltH&amp; VIdToWgtH) const;
433    void SaveTxtSparseNbrs(
434     const TStr&amp; VarIdFNm, const TStr&amp; TupIdFNm, const TStr&amp; TupVarValFNm,
435     const int&amp; MxLev) const;
436  };
437  class TGGraph: public TGraph{
438  private: 
439    static bool IsReg;
440    static bool MkReg(){
441      return TGraph::Reg(TTypeNm&lt;TGGraph&gt;(), TGraphNewF(&amp;New), TGraphLoadF(&amp;Load));}
442  private: 
443    int MxEId;
444    PPp Pp;
445    THash&lt;TInt, PVrtx&gt; VIdToVrtxH;
446    THash&lt;TInt, PEdge&gt; EIdToEdgeH;
447    TStrIntH VNmToVIdH;
448    TStrIntH ENmToEIdH;
449  public:
450    TGGraph(const int&amp; EstVrtxs=1000, const int&amp; EstEdges=1000):
451      TGraph(), MxEId(0), Pp(TPp::GetSetPp(PpNm)),
452      VIdToVrtxH(EstVrtxs), EIdToEdgeH(EstEdges),
453      VNmToVIdH(EstVrtxs), ENmToEIdH(EstEdges){}
454    virtual ~TGGraph(){}
455    static PGraph New(){
456      return PGraph(new TGGraph());}
457    TGGraph(TSIn&amp;){Fail;}
458    static PGraph Load(TSIn&amp; SIn){return PGraph(new TGGraph(SIn));}
459    void Save(TSOut&amp;){Fail;}
460    virtual TStr GetTypeNm() const {return TTypeNm&lt;TGGraph&gt;();}
461    virtual void Defrag(){
462      VIdToVrtxH.Defrag(); EIdToEdgeH.Defrag();
463      VNmToVIdH.Defrag(); ENmToEIdH.Defrag();}
464    virtual PPp GetPp() const {return Pp;}
465    virtual int AddPp(const PPp&amp; _Pp){return Pp-&gt;AddPp(_Pp);}
466    virtual int GetPps() const {return Pp-&gt;GetPps();}
467    virtual PPp GetPp(const int&amp; PpN) const {return Pp-&gt;GetPp(PpN);}
468    virtual int AddVrtx(const PVrtx&amp; Vrtx);
469    virtual void DelVrtx(const int&amp; VId){DelVrtx(GetVrtx(VId));}
470    virtual void DelVrtx(const PVrtx&amp; Vrtx);
471    virtual int GetVrtxs() const {return VIdToVrtxH.Len();}
472    virtual PVrtx GetVrtx(const int&amp; VId) const {return VIdToVrtxH.GetDat(VId);}
473    virtual PVrtx GetVrtx(const TStr&amp; VNm) const {
474      return GetVrtx(VNmToVIdH.GetDat(VNm));}
475    virtual PVrtx GetRndVrtx(TRnd&amp; Rnd) const {
476      return VIdToVrtxH[VIdToVrtxH.GetRndKeyId(Rnd)];}
477    virtual bool IsVrtx(const TStr&amp; VNm, PVrtx&amp; Vrtx) const;
478    virtual int FFirstVrtx() const {return VIdToVrtxH.FFirstKeyId();}
479    virtual bool FNextVrtx(int&amp; VrtxP, PVrtx&amp; Vrtx) const;
480    virtual void ClrVrtxMarks() const;
481    virtual int AddEdge(const PEdge&amp; Edge);
482    virtual void DelEdge(const int&amp; EId){DelEdge(GetEdge(EId));}
483    virtual void DelEdge(const PEdge&amp; Edge);
484    virtual int GetEdges() const {return EIdToEdgeH.Len();}
485    virtual PEdge GetEdge(const int&amp; EId) const {return EIdToEdgeH.GetDat(EId);}
486    virtual PEdge GetEdge(const TStr&amp; ENm) const {
487      return GetEdge(ENmToEIdH.GetDat(ENm));}
488    virtual bool IsEdge(const TStr&amp; ENm, PEdge&amp; Edge) const;
489    virtual int FFirstEdge() const {return EIdToEdgeH.FFirstKeyId();}
490    virtual bool FNextEdge(int&amp; EdgeP, PEdge&amp; Edge) const;
491    virtual bool IsVrtxsEdge(
492     const int&amp; VId1, const int&amp; VId2, const bool&amp; DirP, PEdge&amp; Edge) const;
493  };
494  #endif
</code></pre>
        </div>
    
        <!-- The Modal -->
        <div id="myModal" class="modal">
            <div class="modal-content">
                <span class="row close">&times;</span>
                <div class='row'>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-flx.h</div>
                    <div class="column" style="font-weight: bold;text-decoration: underline">Fragment from snap-MDEwOlJlcG9zaXRvcnk0Mjg4MzU3-flat-graph.h</div>
                </div>
                <div class="column column_space"><pre><code>181    virtual void SetPos(const int&amp; Pos)=0;
182    virtual void MovePos(const int&amp; DPos)=0;
183    virtual int GetPos() const=0;
184    virtual int GetSize() const=0; 
</pre></code></div>
                <div class="column column_space"><pre><code>73    virtual void DelEId(const int&amp; EId)=0;
74    virtual void AddInEId(const int&amp; EId)=0;
75    virtual int GetInEIds() const=0;
76    virtual int GetInEId(const int&amp; InEIdN) const=0;
</pre></code></div>
            </div>
        </div>
        <script>
        // Get the modal
        var modal = document.getElementById("myModal");
        
        // Get the button that opens the modal
        var btn = document.getElementById("myBtn");
        
        // Get the <span> element that closes the modal
        var span = document.getElementsByClassName("close")[0];
        
        // When the user clicks the button, open the modal
        function openModal(){
          modal.style.display = "block";
        }
        
        // When the user clicks on <span> (x), close the modal
        span.onclick = function() {
        modal.style.display = "none";
        }
        
        // When the user clicks anywhere outside of the modal, close it
        window.onclick = function(event) {
        if (event.target == modal) {
        modal.style.display = "none";
        } }
        
        </script>
    </body>
    </html>
    